<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.controls/src/main/java/javafx/scene/control/Labeled.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../javafx.base/src/main/java/javafx/collections/ObservableSet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Pagination.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.controls/src/main/java/javafx/scene/control/Labeled.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 
<span class="line-removed">  28 </span>
  29 import com.sun.javafx.css.StyleManager;
  30 import com.sun.javafx.scene.NodeHelper;
  31 import javafx.css.converter.BooleanConverter;
  32 import javafx.css.converter.EnumConverter;
  33 import javafx.css.converter.InsetsConverter;
  34 import javafx.css.converter.PaintConverter;
  35 import javafx.css.converter.SizeConverter;
  36 import javafx.css.converter.StringConverter;
  37 
  38 import java.util.ArrayList;
  39 import java.util.Collections;
  40 import java.util.List;
  41 
  42 import javafx.beans.property.BooleanProperty;
  43 import javafx.beans.property.DoubleProperty;
  44 import javafx.beans.property.ObjectProperty;
  45 import javafx.beans.property.ReadOnlyObjectProperty;
  46 import javafx.beans.property.SimpleBooleanProperty;
  47 import javafx.beans.property.SimpleStringProperty;
  48 import javafx.beans.property.StringProperty;
</pre>
<hr />
<pre>
  51 import javafx.geometry.Orientation;
  52 import javafx.geometry.Pos;
  53 import javafx.scene.Node;
  54 import javafx.scene.image.Image;
  55 import javafx.scene.image.ImageView;
  56 import javafx.scene.paint.Color;
  57 import javafx.scene.paint.Paint;
  58 import javafx.scene.text.Font;
  59 import javafx.scene.text.TextAlignment;
  60 import javafx.beans.DefaultProperty;
  61 import javafx.css.CssMetaData;
  62 import javafx.css.FontCssMetaData;
  63 import javafx.css.StyleOrigin;
  64 import javafx.css.Styleable;
  65 import javafx.css.StyleableBooleanProperty;
  66 import javafx.css.StyleableDoubleProperty;
  67 import javafx.css.StyleableObjectProperty;
  68 import javafx.css.StyleableProperty;
  69 import javafx.css.StyleableStringProperty;
  70 
<span class="line-removed">  71 </span>
  72 /**
  73  * A Labeled {@link Control} is one which has as part of its user interface
  74  * a textual content associated with it. For example, a {@link Button} displays
  75  * {@code text}, as does a {@link Label}, a {@link Tooltip}, and many
  76  * other controls.
  77  * &lt;p&gt;
  78  * Labeled is also a convenient base class from which to extend when building
  79  * new Controls which, as part of their UI, display read-only textual content.
  80  * &lt;/p&gt;
  81  *
  82  * &lt;p&gt;Example of how to place a graphic above the text:
  83  * &lt;pre&gt;&lt;code&gt;
  84  *  Image image = new Image(getClass().getResourceAsStream(&quot;image.png&quot;));
  85  *  ImageView imageView = new ImageView();
  86  *  imageView.setImage(image);
  87  *  Label label = new Label(&quot;text&quot;, imageView);
  88  *  label.setContentDisplay(ContentDisplay.TOP);
  89  * &lt;/code&gt;&lt;/pre&gt;
  90  *
  91  * @see Button
</pre>
<hr />
<pre>
 118         setText(text);
 119     }
 120 
 121     /**
 122      * Creates a Label with text and a graphic
 123      * @param text The text for the label.
 124      * @param graphic The graphic for the label.
 125      */
 126     public Labeled(String text, Node graphic) {
 127         setText(text);
 128         ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphicProperty()).applyStyle(null, graphic);
 129     }
 130 
 131     /***************************************************************************
 132      *                                                                         *
 133      * Properties                                                              *
 134      *                                                                         *
 135      **************************************************************************/
 136     /**
 137      * The text to display in the label. The text may be null.

 138      * @return the text to display in the label

 139      */
 140     public final StringProperty textProperty() {
 141         if (text == null) {
 142             text = new SimpleStringProperty(this, &quot;text&quot;, &quot;&quot;);
 143         }
 144         return text;
 145     }
 146     private StringProperty text;
 147     public final void setText(String value) { textProperty().setValue(value); }
 148     public final String getText() { return text == null ? &quot;&quot; : text.getValue(); }
 149 
 150     /**
 151      * Specifies how the text and graphic within the Labeled should be
 152      * aligned when there is empty space within the Labeled.

 153      * @return the alignment within this labeled

 154      */
 155     public final ObjectProperty&lt;Pos&gt; alignmentProperty() {
 156         if (alignment == null) {
 157             alignment = new StyleableObjectProperty&lt;Pos&gt;(Pos.CENTER_LEFT) {
 158 
 159                 @Override public CssMetaData&lt;Labeled,Pos&gt; getCssMetaData() {
 160                     return StyleableProperties.ALIGNMENT;
 161                 }
 162 
 163                 @Override
 164                 public Object getBean() {
 165                     return Labeled.this;
 166                 }
 167 
 168                 @Override
 169                 public String getName() {
 170                     return &quot;alignment&quot;;
 171                 }
 172             };
 173         }
 174         return alignment;
 175     }
 176     private ObjectProperty&lt;Pos&gt; alignment;
 177     public final void setAlignment(Pos value) { alignmentProperty().set(value); }
 178     public final Pos getAlignment() { return alignment == null ? Pos.CENTER_LEFT : alignment.get(); }
 179 
 180 
 181     /**
 182      * Specifies the behavior for lines of text &lt;em&gt;when text is multiline&lt;/em&gt;.
 183      * Unlike {@link #contentDisplayProperty} which affects the graphic and text, this setting
 184      * only affects multiple lines of text relative to the text bounds.

 185      * @return the alignment of lines of text within this labeled

 186      */
 187     public final ObjectProperty&lt;TextAlignment&gt; textAlignmentProperty() {
 188         if (textAlignment == null) {
 189             textAlignment = new StyleableObjectProperty&lt;TextAlignment&gt;(TextAlignment.LEFT) {
 190 
 191                 @Override
 192                 public CssMetaData&lt;Labeled,TextAlignment&gt; getCssMetaData() {
 193                     return StyleableProperties.TEXT_ALIGNMENT;
 194                 }
 195 
 196                 @Override
 197                 public Object getBean() {
 198                     return Labeled.this;
 199                 }
 200 
 201                 @Override
 202                 public String getName() {
 203                     return &quot;textAlignment&quot;;
 204                 }
 205             };
 206         }
 207         return textAlignment;
 208     }
 209     private ObjectProperty&lt;TextAlignment&gt; textAlignment;
 210     public final void setTextAlignment(TextAlignment value) { textAlignmentProperty().setValue(value); }
 211     public final TextAlignment getTextAlignment() { return textAlignment == null ? TextAlignment.LEFT : textAlignment.getValue(); }
 212 
 213     /**
 214      * Specifies the behavior to use if the text of the {@code Labeled}
 215      * exceeds the available space for rendering the text.

 216      * @return the overrun behavior if the text exceeds the available space

 217      */
 218     public final ObjectProperty&lt;OverrunStyle&gt; textOverrunProperty() {
 219         if (textOverrun == null) {
 220             textOverrun = new StyleableObjectProperty&lt;OverrunStyle&gt;(OverrunStyle.ELLIPSIS) {
 221 
 222                 @Override
 223                 public CssMetaData&lt;Labeled,OverrunStyle&gt; getCssMetaData() {
 224                     return StyleableProperties.TEXT_OVERRUN;
 225                 }
 226 
 227                 @Override
 228                 public Object getBean() {
 229                     return Labeled.this;
 230                 }
 231 
 232                 @Override
 233                 public String getName() {
 234                     return &quot;textOverrun&quot;;
 235                 }
 236             };
</pre>
<hr />
<pre>
 242     public final OverrunStyle getTextOverrun() { return textOverrun == null ? OverrunStyle.ELLIPSIS : textOverrun.getValue(); }
 243 
 244     /**
 245      * Specifies the string to display for the ellipsis when text is truncated.
 246      *
 247      * &lt;table&gt;
 248      *   &lt;caption&gt;Ellipsis Table&lt;/caption&gt;
 249      *   &lt;tr&gt;&lt;th scope=&quot;col&quot; colspan=2&gt;Examples&lt;/th&gt;&lt;/tr&gt;
 250      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;...&quot; &lt;/th&gt;        &lt;td&gt;Default value for most locales&lt;/td&gt;
 251      *   &lt;tr class=&quot;rowColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot; . . . &quot; &lt;/th&gt;    &lt;td&gt;&lt;/td&gt;
 252      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot; [...] &quot; &lt;/th&gt;    &lt;td&gt;&lt;/td&gt;
 253      *   &lt;tr class=&quot;rowColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;&amp;#92;u2026&quot; &lt;/th&gt; &lt;td&gt;The Unicode ellipsis character &#39;&amp;hellip;&#39;&lt;/td&gt;
 254      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;&quot; &lt;/th&gt;           &lt;td&gt;No ellipsis, just display the truncated string&lt;/td&gt;
 255      * &lt;/table&gt;
 256      *
 257      * &lt;p&gt;Note that not all fonts support all Unicode characters.
 258      *
 259      * @return the ellipsis property on the string to display for the ellipsis
 260      * when text is truncated
 261      * @see &lt;a href=&quot;http://en.wikipedia.org/wiki/Ellipsis#Computer_representations&quot;&gt;Wikipedia:ellipsis&lt;/a&gt;

 262      * @since JavaFX 2.2
 263      */
 264     public final StringProperty ellipsisStringProperty() {
 265         if (ellipsisString == null) {
 266             ellipsisString = new StyleableStringProperty(DEFAULT_ELLIPSIS_STRING) {
 267                 @Override public Object getBean() {
 268                     return Labeled.this;
 269                 }
 270 
 271                 @Override public String getName() {
 272                     return &quot;ellipsisString&quot;;
 273                 }
 274 
 275                 @Override public CssMetaData&lt;Labeled,String&gt; getCssMetaData() {
 276                     return StyleableProperties.ELLIPSIS_STRING;
 277                 }
 278             };
 279         }
 280         return ellipsisString;
 281     }
 282     private StringProperty ellipsisString;
 283     public final void setEllipsisString(String value) { ellipsisStringProperty().set((value == null) ? &quot;&quot; : value); }
 284     public final String getEllipsisString() { return ellipsisString == null ? DEFAULT_ELLIPSIS_STRING : ellipsisString.get(); }
 285 
 286 
 287     /**
 288      * If a run of text exceeds the width of the Labeled, then this variable
 289      * indicates whether the text should wrap onto another line.

 290      * @return the wrap property if a run of text exceeds the width of the Labeled

 291      */
 292     public final BooleanProperty wrapTextProperty() {
 293         if (wrapText == null) {
 294             wrapText = new StyleableBooleanProperty() {
 295 
 296                 @Override
 297                 public CssMetaData&lt;Labeled,Boolean&gt; getCssMetaData() {
 298                     return StyleableProperties.WRAP_TEXT;
 299                 }
 300 
 301                 @Override
 302                 public Object getBean() {
 303                     return Labeled.this;
 304                 }
 305 
 306                 @Override
 307                 public String getName() {
 308                     return &quot;wrapText&quot;;
 309                 }
 310             };
 311         }
 312         return wrapText;
 313     }
 314     private BooleanProperty wrapText;
 315     public final void setWrapText(boolean value) { wrapTextProperty().setValue(value); }
 316     public final boolean isWrapText() { return wrapText == null ? false : wrapText.getValue(); }
 317 
 318     /**
 319      * If wrapText is true, then contentBias will be HORIZONTAL, otherwise it is null.
 320      * @return orientation of width/height dependency or null if there is none
 321      */
 322     @Override public Orientation getContentBias() {
 323         return isWrapText()? Orientation.HORIZONTAL : null;
 324     }
 325 
 326     /**
 327      * The default font to use for text in the Labeled. If the Label&#39;s text is
 328      * rich text then this font may or may not be used depending on the font
 329      * information embedded in the rich text, but in any case where a default
 330      * font is required, this font will be used.

 331      * @return the default font to use for text in this labeled

 332      */
 333     public final ObjectProperty&lt;Font&gt; fontProperty() {
 334 
 335         if (font == null) {
 336             font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {
 337 
 338                 private boolean fontSetByCss = false;
 339 
 340                 @Override
 341                 public void applyStyle(StyleOrigin newOrigin, Font value) {
 342 
 343                     //
 344                     // RT-20727 - if CSS is setting the font, then make sure invalidate doesn&#39;t call NodeHelper.reapplyCSS
 345                     //
 346                     try {
 347                         // super.applyStyle calls set which might throw if value is bound.
 348                         // Have to make sure fontSetByCss is reset.
 349                         fontSetByCss = true;
 350                         super.applyStyle(newOrigin, value);
 351                     } catch(Exception e) {
</pre>
<hr />
<pre>
 386                 }
 387 
 388                 @Override
 389                 public String getName() {
 390                     return &quot;font&quot;;
 391                 }
 392             };
 393         }
 394         return font;
 395     }
 396     private ObjectProperty&lt;Font&gt; font;
 397     public final void setFont(Font value) { fontProperty().setValue(value); }
 398     public final Font getFont() { return font == null ? Font.getDefault() : font.getValue(); }
 399 
 400 
 401     /**
 402      * An optional icon for the Labeled. This can be positioned relative to the
 403      * text by using {@link #setContentDisplay}.  The node specified for this
 404      * variable cannot appear elsewhere in the scene graph, otherwise
 405      * the {@code IllegalArgumentException} is thrown.  See the class
<span class="line-modified"> 406      * description of {@link javafx.scene.Node Node} for more detail.</span>

 407      * @return the optional icon for this labeled

 408      */
 409     public final ObjectProperty&lt;Node&gt; graphicProperty() {
 410         if (graphic == null) {
 411             graphic = new StyleableObjectProperty&lt;Node&gt;() {
 412 
 413                 // The graphic is styleable by css, but it is the
 414                 // imageUrlProperty that handles the style value.
 415                 @Override
 416                 public CssMetaData getCssMetaData() {
 417                     return StyleableProperties.GRAPHIC;
 418                 }
 419 
 420                 @Override
 421                 public Object getBean() {
 422                     return Labeled.this;
 423                 }
 424 
 425                 @Override
 426                 public String getName() {
 427                     return &quot;graphic&quot;;
</pre>
<hr />
<pre>
 545                     return Labeled.this;
 546                 }
 547 
 548                 @Override
 549                 public String getName() {
 550                     return &quot;imageUrl&quot;;
 551                 }
 552 
 553                 @Override
 554                 public CssMetaData&lt;Labeled,String&gt; getCssMetaData() {
 555                     return StyleableProperties.GRAPHIC;
 556                 }
 557 
 558             };
 559         }
 560         return imageUrl;
 561     }
 562 
 563     /**
 564      * Whether all text should be underlined.

 565      * @return the underline property of all text in this labeled

 566      */
 567     public final BooleanProperty underlineProperty() {
 568         if (underline == null) {
 569             underline = new StyleableBooleanProperty(false) {
 570 
 571                 @Override
 572                 public CssMetaData&lt;Labeled, Boolean&gt; getCssMetaData() {
 573                     return StyleableProperties.UNDERLINE;
 574                 }
 575 
 576                 @Override
 577                 public Object getBean() {
 578                     return Labeled.this;
 579                 }
 580 
 581                 @Override
 582                 public String getName() {
 583                     return &quot;underline&quot;;
 584                 }
 585             };
 586         }
 587         return underline;
 588     }
 589     private BooleanProperty underline;
 590     public final void setUnderline(boolean value) { underlineProperty().setValue(value); }
 591     public final boolean isUnderline() { return underline == null ? false : underline.getValue(); }
 592 
 593     /**
 594      * Specifies the space in pixel between lines.

 595      * @return the line spacing property between lines in this labeled

 596      * @since JavaFX 8.0
 597      */
 598     public final DoubleProperty lineSpacingProperty() {
 599         if (lineSpacing == null) {
 600             lineSpacing = new StyleableDoubleProperty(0) {
 601 
 602                 @Override
 603                 public CssMetaData&lt;Labeled,Number&gt; getCssMetaData() {
 604                     return StyleableProperties.LINE_SPACING;
 605                 }
 606 
 607                 @Override
 608                 public Object getBean() {
 609                     return Labeled.this;
 610                 }
 611 
 612                 @Override
 613                 public String getName() {
 614                     return &quot;lineSpacing&quot;;
 615                 }
 616             };
 617         }
 618         return lineSpacing;
 619     }
 620     private DoubleProperty lineSpacing;
 621     public final void setLineSpacing(double value) { lineSpacingProperty().setValue(value); }
 622     public final double getLineSpacing() { return lineSpacing == null ? 0 : lineSpacing.getValue(); }
 623 
 624     /**
 625      * Specifies the positioning of the graphic relative to the text.

 626      * @return content display property of this labeled

 627      */
 628     public final ObjectProperty&lt;ContentDisplay&gt; contentDisplayProperty() {
 629         if (contentDisplay == null) {
 630             contentDisplay = new StyleableObjectProperty&lt;ContentDisplay&gt;(ContentDisplay.LEFT) {
 631 
 632                 @Override
 633                 public CssMetaData&lt;Labeled,ContentDisplay&gt; getCssMetaData() {
 634                     return StyleableProperties.CONTENT_DISPLAY;
 635                 }
 636 
 637                 @Override
 638                 public Object getBean() {
 639                     return Labeled.this;
 640                 }
 641 
 642                 @Override
 643                 public String getName() {
 644                     return &quot;contentDisplay&quot;;
 645                 }
 646             };
 647         }
 648         return contentDisplay;
 649     }
 650     private ObjectProperty&lt;ContentDisplay&gt; contentDisplay;
 651     public final void setContentDisplay(ContentDisplay value) { contentDisplayProperty().setValue(value); }
 652     public final ContentDisplay getContentDisplay() { return contentDisplay == null ? ContentDisplay.LEFT : contentDisplay.getValue(); }
 653 
 654     /**
 655      * The padding around the Labeled&#39;s text and graphic content.
 656      * By default labelPadding is Insets.EMPTY and cannot be set to null.
 657      * Subclasses may add nodes outside this padding and inside the Labeled&#39;s padding.
 658      *
 659      * This property can only be set from CSS.
<span class="line-modified"> 660      * @return  the label padding property of this labeled</span>


 661      */
 662     public final ReadOnlyObjectProperty&lt;Insets&gt; labelPaddingProperty() {
 663         return labelPaddingPropertyImpl();
 664     }
 665     private ObjectProperty&lt;Insets&gt; labelPaddingPropertyImpl() {
 666         if (labelPadding == null) {
 667             labelPadding = new StyleableObjectProperty&lt;Insets&gt;(Insets.EMPTY) {
 668                 private Insets lastValidValue = Insets.EMPTY;
 669 
 670                 @Override
 671                 public void invalidated() {
 672                     final Insets newValue = get();
 673                     if (newValue == null) {
 674                         set(lastValidValue);
 675                         throw new NullPointerException(&quot;cannot set labelPadding to null&quot;);
 676                     }
 677                     lastValidValue = newValue;
 678                     requestLayout();
 679                 }
 680 
</pre>
<hr />
<pre>
 685 
 686                 @Override
 687                 public Object getBean() {
 688                     return Labeled.this;
 689                 }
 690 
 691                 @Override
 692                 public String getName() {
 693                     return &quot;labelPadding&quot;;
 694                 }
 695             };
 696         }
 697         return labelPadding;
 698     }
 699     private ObjectProperty&lt;Insets&gt; labelPadding;
 700     private void setLabelPadding(Insets value) { labelPaddingPropertyImpl().set(value); }
 701     public final Insets getLabelPadding() { return labelPadding == null ? Insets.EMPTY : labelPadding.get(); }
 702 
 703     /**
 704      * The amount of space between the graphic and text

 705      * @return the graphics text gap property of this labeled

 706      */
 707     public final DoubleProperty graphicTextGapProperty() {
 708         if (graphicTextGap == null) {
 709             graphicTextGap = new StyleableDoubleProperty(4) {
 710 
 711                 @Override
 712                 public CssMetaData&lt;Labeled,Number&gt; getCssMetaData() {
 713                     return StyleableProperties.GRAPHIC_TEXT_GAP;
 714                 }
 715 
 716                 @Override
 717                 public Object getBean() {
 718                     return Labeled.this;
 719                 }
 720 
 721                 @Override
 722                 public String getName() {
 723                     return &quot;graphicTextGap&quot;;
 724                 }
 725             };
 726         }
 727         return graphicTextGap;
 728     }
 729     private DoubleProperty graphicTextGap;
 730     public final void setGraphicTextGap(double value) { graphicTextGapProperty().setValue(value); }
 731     public final double getGraphicTextGap() { return graphicTextGap == null ? 4 : graphicTextGap.getValue(); }
 732 
 733 
 734     /**
 735      * The {@link Paint} used to fill the text.


 736      */
 737     private ObjectProperty&lt;Paint&gt; textFill; // TODO for now change this
 738 
 739     public final void setTextFill(Paint value) {
 740         textFillProperty().set(value);
 741     }
 742 
 743     public final Paint getTextFill() {
 744         return textFill == null ? Color.BLACK : textFill.get();
 745     }
 746 
 747     public final ObjectProperty&lt;Paint&gt; textFillProperty() {
 748         if (textFill == null) {
 749             textFill = new StyleableObjectProperty&lt;Paint&gt;(Color.BLACK) {
 750 
 751                 @Override
 752                 public CssMetaData&lt;Labeled,Paint&gt; getCssMetaData() {
 753                     return StyleableProperties.TEXT_FILL;
 754                 }
 755 
</pre>
<hr />
<pre>
 759                 }
 760 
 761                 @Override
 762                 public String getName() {
 763                     return &quot;textFill&quot;;
 764                 }
 765             };
 766         }
 767         return textFill;
 768     }
 769 
 770 
 771     /**
 772      * MnemonicParsing property to enable/disable text parsing.
 773      * If this is set to true, then the Label text will be
 774      * parsed to see if it contains the mnemonic parsing character &#39;_&#39;.
 775      * When a mnemonic is detected the key combination will
 776      * be determined based on the succeeding character, and the mnemonic
 777      * added.
 778      *
<span class="line-modified"> 779      * &lt;p&gt;</span>
<span class="line-removed"> 780      * The default value for Labeled is false, but it</span>
<span class="line-removed"> 781      * is enabled by default on some Controls.</span>
<span class="line-removed"> 782      * &lt;/p&gt;</span>
 783      */
 784     private BooleanProperty mnemonicParsing;
 785     public final void setMnemonicParsing(boolean value) {
 786         mnemonicParsingProperty().set(value);
 787     }
 788     public final boolean isMnemonicParsing() {
 789         return mnemonicParsing == null ? false : mnemonicParsing.get();
 790     }
 791     public final BooleanProperty mnemonicParsingProperty() {
 792         if (mnemonicParsing == null) {
 793             mnemonicParsing = new SimpleBooleanProperty(this, &quot;mnemonicParsing&quot;);
 794         }
 795         return mnemonicParsing;
 796     }
 797 
 798     //    /**
 799     //     * This is the symbol that is searched for in the text and used as
 800     //     * a mnemonic. You can change what symbol is used. Using the symbol
 801     //     * more than once will cause the symbol to be escaped. Thus, if &quot;_&quot;
 802     //     * (the default) is used, then the string &quot;H_ello World&quot; will use
</pre>
</td>
<td>
<hr />
<pre>
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 

  28 import com.sun.javafx.css.StyleManager;
  29 import com.sun.javafx.scene.NodeHelper;
  30 import javafx.css.converter.BooleanConverter;
  31 import javafx.css.converter.EnumConverter;
  32 import javafx.css.converter.InsetsConverter;
  33 import javafx.css.converter.PaintConverter;
  34 import javafx.css.converter.SizeConverter;
  35 import javafx.css.converter.StringConverter;
  36 
  37 import java.util.ArrayList;
  38 import java.util.Collections;
  39 import java.util.List;
  40 
  41 import javafx.beans.property.BooleanProperty;
  42 import javafx.beans.property.DoubleProperty;
  43 import javafx.beans.property.ObjectProperty;
  44 import javafx.beans.property.ReadOnlyObjectProperty;
  45 import javafx.beans.property.SimpleBooleanProperty;
  46 import javafx.beans.property.SimpleStringProperty;
  47 import javafx.beans.property.StringProperty;
</pre>
<hr />
<pre>
  50 import javafx.geometry.Orientation;
  51 import javafx.geometry.Pos;
  52 import javafx.scene.Node;
  53 import javafx.scene.image.Image;
  54 import javafx.scene.image.ImageView;
  55 import javafx.scene.paint.Color;
  56 import javafx.scene.paint.Paint;
  57 import javafx.scene.text.Font;
  58 import javafx.scene.text.TextAlignment;
  59 import javafx.beans.DefaultProperty;
  60 import javafx.css.CssMetaData;
  61 import javafx.css.FontCssMetaData;
  62 import javafx.css.StyleOrigin;
  63 import javafx.css.Styleable;
  64 import javafx.css.StyleableBooleanProperty;
  65 import javafx.css.StyleableDoubleProperty;
  66 import javafx.css.StyleableObjectProperty;
  67 import javafx.css.StyleableProperty;
  68 import javafx.css.StyleableStringProperty;
  69 

  70 /**
  71  * A Labeled {@link Control} is one which has as part of its user interface
  72  * a textual content associated with it. For example, a {@link Button} displays
  73  * {@code text}, as does a {@link Label}, a {@link Tooltip}, and many
  74  * other controls.
  75  * &lt;p&gt;
  76  * Labeled is also a convenient base class from which to extend when building
  77  * new Controls which, as part of their UI, display read-only textual content.
  78  * &lt;/p&gt;
  79  *
  80  * &lt;p&gt;Example of how to place a graphic above the text:
  81  * &lt;pre&gt;&lt;code&gt;
  82  *  Image image = new Image(getClass().getResourceAsStream(&quot;image.png&quot;));
  83  *  ImageView imageView = new ImageView();
  84  *  imageView.setImage(image);
  85  *  Label label = new Label(&quot;text&quot;, imageView);
  86  *  label.setContentDisplay(ContentDisplay.TOP);
  87  * &lt;/code&gt;&lt;/pre&gt;
  88  *
  89  * @see Button
</pre>
<hr />
<pre>
 116         setText(text);
 117     }
 118 
 119     /**
 120      * Creates a Label with text and a graphic
 121      * @param text The text for the label.
 122      * @param graphic The graphic for the label.
 123      */
 124     public Labeled(String text, Node graphic) {
 125         setText(text);
 126         ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphicProperty()).applyStyle(null, graphic);
 127     }
 128 
 129     /***************************************************************************
 130      *                                                                         *
 131      * Properties                                                              *
 132      *                                                                         *
 133      **************************************************************************/
 134     /**
 135      * The text to display in the label. The text may be null.
<span class="line-added"> 136      *</span>
 137      * @return the text to display in the label
<span class="line-added"> 138      * @defaultValue empty string</span>
 139      */
 140     public final StringProperty textProperty() {
 141         if (text == null) {
 142             text = new SimpleStringProperty(this, &quot;text&quot;, &quot;&quot;);
 143         }
 144         return text;
 145     }
 146     private StringProperty text;
 147     public final void setText(String value) { textProperty().setValue(value); }
 148     public final String getText() { return text == null ? &quot;&quot; : text.getValue(); }
 149 
 150     /**
 151      * Specifies how the text and graphic within the Labeled should be
 152      * aligned when there is empty space within the Labeled.
<span class="line-added"> 153      *</span>
 154      * @return the alignment within this labeled
<span class="line-added"> 155      * @defaultValue {@code Pos.CENTER_LEFT}</span>
 156      */
 157     public final ObjectProperty&lt;Pos&gt; alignmentProperty() {
 158         if (alignment == null) {
 159             alignment = new StyleableObjectProperty&lt;Pos&gt;(Pos.CENTER_LEFT) {
 160 
 161                 @Override public CssMetaData&lt;Labeled,Pos&gt; getCssMetaData() {
 162                     return StyleableProperties.ALIGNMENT;
 163                 }
 164 
 165                 @Override
 166                 public Object getBean() {
 167                     return Labeled.this;
 168                 }
 169 
 170                 @Override
 171                 public String getName() {
 172                     return &quot;alignment&quot;;
 173                 }
 174             };
 175         }
 176         return alignment;
 177     }
 178     private ObjectProperty&lt;Pos&gt; alignment;
 179     public final void setAlignment(Pos value) { alignmentProperty().set(value); }
 180     public final Pos getAlignment() { return alignment == null ? Pos.CENTER_LEFT : alignment.get(); }
 181 
 182 
 183     /**
 184      * Specifies the behavior for lines of text &lt;em&gt;when text is multiline&lt;/em&gt;.
 185      * Unlike {@link #contentDisplayProperty} which affects the graphic and text, this setting
 186      * only affects multiple lines of text relative to the text bounds.
<span class="line-added"> 187      *</span>
 188      * @return the alignment of lines of text within this labeled
<span class="line-added"> 189      * @defaultValue {@code TextAlignment.LEFT}</span>
 190      */
 191     public final ObjectProperty&lt;TextAlignment&gt; textAlignmentProperty() {
 192         if (textAlignment == null) {
 193             textAlignment = new StyleableObjectProperty&lt;TextAlignment&gt;(TextAlignment.LEFT) {
 194 
 195                 @Override
 196                 public CssMetaData&lt;Labeled,TextAlignment&gt; getCssMetaData() {
 197                     return StyleableProperties.TEXT_ALIGNMENT;
 198                 }
 199 
 200                 @Override
 201                 public Object getBean() {
 202                     return Labeled.this;
 203                 }
 204 
 205                 @Override
 206                 public String getName() {
 207                     return &quot;textAlignment&quot;;
 208                 }
 209             };
 210         }
 211         return textAlignment;
 212     }
 213     private ObjectProperty&lt;TextAlignment&gt; textAlignment;
 214     public final void setTextAlignment(TextAlignment value) { textAlignmentProperty().setValue(value); }
 215     public final TextAlignment getTextAlignment() { return textAlignment == null ? TextAlignment.LEFT : textAlignment.getValue(); }
 216 
 217     /**
 218      * Specifies the behavior to use if the text of the {@code Labeled}
 219      * exceeds the available space for rendering the text.
<span class="line-added"> 220      *</span>
 221      * @return the overrun behavior if the text exceeds the available space
<span class="line-added"> 222      * @defaultValue {@code OverrunStyle.ELLIPSIS}</span>
 223      */
 224     public final ObjectProperty&lt;OverrunStyle&gt; textOverrunProperty() {
 225         if (textOverrun == null) {
 226             textOverrun = new StyleableObjectProperty&lt;OverrunStyle&gt;(OverrunStyle.ELLIPSIS) {
 227 
 228                 @Override
 229                 public CssMetaData&lt;Labeled,OverrunStyle&gt; getCssMetaData() {
 230                     return StyleableProperties.TEXT_OVERRUN;
 231                 }
 232 
 233                 @Override
 234                 public Object getBean() {
 235                     return Labeled.this;
 236                 }
 237 
 238                 @Override
 239                 public String getName() {
 240                     return &quot;textOverrun&quot;;
 241                 }
 242             };
</pre>
<hr />
<pre>
 248     public final OverrunStyle getTextOverrun() { return textOverrun == null ? OverrunStyle.ELLIPSIS : textOverrun.getValue(); }
 249 
 250     /**
 251      * Specifies the string to display for the ellipsis when text is truncated.
 252      *
 253      * &lt;table&gt;
 254      *   &lt;caption&gt;Ellipsis Table&lt;/caption&gt;
 255      *   &lt;tr&gt;&lt;th scope=&quot;col&quot; colspan=2&gt;Examples&lt;/th&gt;&lt;/tr&gt;
 256      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;...&quot; &lt;/th&gt;        &lt;td&gt;Default value for most locales&lt;/td&gt;
 257      *   &lt;tr class=&quot;rowColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot; . . . &quot; &lt;/th&gt;    &lt;td&gt;&lt;/td&gt;
 258      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot; [...] &quot; &lt;/th&gt;    &lt;td&gt;&lt;/td&gt;
 259      *   &lt;tr class=&quot;rowColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;&amp;#92;u2026&quot; &lt;/th&gt; &lt;td&gt;The Unicode ellipsis character &#39;&amp;hellip;&#39;&lt;/td&gt;
 260      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;&quot; &lt;/th&gt;           &lt;td&gt;No ellipsis, just display the truncated string&lt;/td&gt;
 261      * &lt;/table&gt;
 262      *
 263      * &lt;p&gt;Note that not all fonts support all Unicode characters.
 264      *
 265      * @return the ellipsis property on the string to display for the ellipsis
 266      * when text is truncated
 267      * @see &lt;a href=&quot;http://en.wikipedia.org/wiki/Ellipsis#Computer_representations&quot;&gt;Wikipedia:ellipsis&lt;/a&gt;
<span class="line-added"> 268      * @defaultValue {@code &quot;...&quot;}</span>
 269      * @since JavaFX 2.2
 270      */
 271     public final StringProperty ellipsisStringProperty() {
 272         if (ellipsisString == null) {
 273             ellipsisString = new StyleableStringProperty(DEFAULT_ELLIPSIS_STRING) {
 274                 @Override public Object getBean() {
 275                     return Labeled.this;
 276                 }
 277 
 278                 @Override public String getName() {
 279                     return &quot;ellipsisString&quot;;
 280                 }
 281 
 282                 @Override public CssMetaData&lt;Labeled,String&gt; getCssMetaData() {
 283                     return StyleableProperties.ELLIPSIS_STRING;
 284                 }
 285             };
 286         }
 287         return ellipsisString;
 288     }
 289     private StringProperty ellipsisString;
 290     public final void setEllipsisString(String value) { ellipsisStringProperty().set((value == null) ? &quot;&quot; : value); }
 291     public final String getEllipsisString() { return ellipsisString == null ? DEFAULT_ELLIPSIS_STRING : ellipsisString.get(); }
 292 
 293 
 294     /**
 295      * If a run of text exceeds the width of the Labeled, then this variable
 296      * indicates whether the text should wrap onto another line.
<span class="line-added"> 297      *</span>
 298      * @return the wrap property if a run of text exceeds the width of the Labeled
<span class="line-added"> 299      * @defaultValue {@code false}</span>
 300      */
 301     public final BooleanProperty wrapTextProperty() {
 302         if (wrapText == null) {
 303             wrapText = new StyleableBooleanProperty() {
 304 
 305                 @Override
 306                 public CssMetaData&lt;Labeled,Boolean&gt; getCssMetaData() {
 307                     return StyleableProperties.WRAP_TEXT;
 308                 }
 309 
 310                 @Override
 311                 public Object getBean() {
 312                     return Labeled.this;
 313                 }
 314 
 315                 @Override
 316                 public String getName() {
 317                     return &quot;wrapText&quot;;
 318                 }
 319             };
 320         }
 321         return wrapText;
 322     }
 323     private BooleanProperty wrapText;
 324     public final void setWrapText(boolean value) { wrapTextProperty().setValue(value); }
 325     public final boolean isWrapText() { return wrapText == null ? false : wrapText.getValue(); }
 326 
 327     /**
 328      * If wrapText is true, then contentBias will be HORIZONTAL, otherwise it is null.
 329      * @return orientation of width/height dependency or null if there is none
 330      */
 331     @Override public Orientation getContentBias() {
 332         return isWrapText()? Orientation.HORIZONTAL : null;
 333     }
 334 
 335     /**
 336      * The default font to use for text in the Labeled. If the Label&#39;s text is
 337      * rich text then this font may or may not be used depending on the font
 338      * information embedded in the rich text, but in any case where a default
 339      * font is required, this font will be used.
<span class="line-added"> 340      *</span>
 341      * @return the default font to use for text in this labeled
<span class="line-added"> 342      * @defaultValue {@link Font#getDefault()}</span>
 343      */
 344     public final ObjectProperty&lt;Font&gt; fontProperty() {
 345 
 346         if (font == null) {
 347             font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {
 348 
 349                 private boolean fontSetByCss = false;
 350 
 351                 @Override
 352                 public void applyStyle(StyleOrigin newOrigin, Font value) {
 353 
 354                     //
 355                     // RT-20727 - if CSS is setting the font, then make sure invalidate doesn&#39;t call NodeHelper.reapplyCSS
 356                     //
 357                     try {
 358                         // super.applyStyle calls set which might throw if value is bound.
 359                         // Have to make sure fontSetByCss is reset.
 360                         fontSetByCss = true;
 361                         super.applyStyle(newOrigin, value);
 362                     } catch(Exception e) {
</pre>
<hr />
<pre>
 397                 }
 398 
 399                 @Override
 400                 public String getName() {
 401                     return &quot;font&quot;;
 402                 }
 403             };
 404         }
 405         return font;
 406     }
 407     private ObjectProperty&lt;Font&gt; font;
 408     public final void setFont(Font value) { fontProperty().setValue(value); }
 409     public final Font getFont() { return font == null ? Font.getDefault() : font.getValue(); }
 410 
 411 
 412     /**
 413      * An optional icon for the Labeled. This can be positioned relative to the
 414      * text by using {@link #setContentDisplay}.  The node specified for this
 415      * variable cannot appear elsewhere in the scene graph, otherwise
 416      * the {@code IllegalArgumentException} is thrown.  See the class
<span class="line-modified"> 417      * description of {@link Node} for more detail.</span>
<span class="line-added"> 418      *</span>
 419      * @return the optional icon for this labeled
<span class="line-added"> 420      * @defaultValue {@code null}</span>
 421      */
 422     public final ObjectProperty&lt;Node&gt; graphicProperty() {
 423         if (graphic == null) {
 424             graphic = new StyleableObjectProperty&lt;Node&gt;() {
 425 
 426                 // The graphic is styleable by css, but it is the
 427                 // imageUrlProperty that handles the style value.
 428                 @Override
 429                 public CssMetaData getCssMetaData() {
 430                     return StyleableProperties.GRAPHIC;
 431                 }
 432 
 433                 @Override
 434                 public Object getBean() {
 435                     return Labeled.this;
 436                 }
 437 
 438                 @Override
 439                 public String getName() {
 440                     return &quot;graphic&quot;;
</pre>
<hr />
<pre>
 558                     return Labeled.this;
 559                 }
 560 
 561                 @Override
 562                 public String getName() {
 563                     return &quot;imageUrl&quot;;
 564                 }
 565 
 566                 @Override
 567                 public CssMetaData&lt;Labeled,String&gt; getCssMetaData() {
 568                     return StyleableProperties.GRAPHIC;
 569                 }
 570 
 571             };
 572         }
 573         return imageUrl;
 574     }
 575 
 576     /**
 577      * Whether all text should be underlined.
<span class="line-added"> 578      *</span>
 579      * @return the underline property of all text in this labeled
<span class="line-added"> 580      * @defaultValue {@code false}</span>
 581      */
 582     public final BooleanProperty underlineProperty() {
 583         if (underline == null) {
 584             underline = new StyleableBooleanProperty(false) {
 585 
 586                 @Override
 587                 public CssMetaData&lt;Labeled, Boolean&gt; getCssMetaData() {
 588                     return StyleableProperties.UNDERLINE;
 589                 }
 590 
 591                 @Override
 592                 public Object getBean() {
 593                     return Labeled.this;
 594                 }
 595 
 596                 @Override
 597                 public String getName() {
 598                     return &quot;underline&quot;;
 599                 }
 600             };
 601         }
 602         return underline;
 603     }
 604     private BooleanProperty underline;
 605     public final void setUnderline(boolean value) { underlineProperty().setValue(value); }
 606     public final boolean isUnderline() { return underline == null ? false : underline.getValue(); }
 607 
 608     /**
 609      * Specifies the space in pixel between lines.
<span class="line-added"> 610      *</span>
 611      * @return the line spacing property between lines in this labeled
<span class="line-added"> 612      * @defaultValue 0</span>
 613      * @since JavaFX 8.0
 614      */
 615     public final DoubleProperty lineSpacingProperty() {
 616         if (lineSpacing == null) {
 617             lineSpacing = new StyleableDoubleProperty(0) {
 618 
 619                 @Override
 620                 public CssMetaData&lt;Labeled,Number&gt; getCssMetaData() {
 621                     return StyleableProperties.LINE_SPACING;
 622                 }
 623 
 624                 @Override
 625                 public Object getBean() {
 626                     return Labeled.this;
 627                 }
 628 
 629                 @Override
 630                 public String getName() {
 631                     return &quot;lineSpacing&quot;;
 632                 }
 633             };
 634         }
 635         return lineSpacing;
 636     }
 637     private DoubleProperty lineSpacing;
 638     public final void setLineSpacing(double value) { lineSpacingProperty().setValue(value); }
 639     public final double getLineSpacing() { return lineSpacing == null ? 0 : lineSpacing.getValue(); }
 640 
 641     /**
 642      * Specifies the positioning of the graphic relative to the text.
<span class="line-added"> 643      *</span>
 644      * @return content display property of this labeled
<span class="line-added"> 645      * @defaultValue {@code ContentDisplay.LEFT}</span>
 646      */
 647     public final ObjectProperty&lt;ContentDisplay&gt; contentDisplayProperty() {
 648         if (contentDisplay == null) {
 649             contentDisplay = new StyleableObjectProperty&lt;ContentDisplay&gt;(ContentDisplay.LEFT) {
 650 
 651                 @Override
 652                 public CssMetaData&lt;Labeled,ContentDisplay&gt; getCssMetaData() {
 653                     return StyleableProperties.CONTENT_DISPLAY;
 654                 }
 655 
 656                 @Override
 657                 public Object getBean() {
 658                     return Labeled.this;
 659                 }
 660 
 661                 @Override
 662                 public String getName() {
 663                     return &quot;contentDisplay&quot;;
 664                 }
 665             };
 666         }
 667         return contentDisplay;
 668     }
 669     private ObjectProperty&lt;ContentDisplay&gt; contentDisplay;
 670     public final void setContentDisplay(ContentDisplay value) { contentDisplayProperty().setValue(value); }
 671     public final ContentDisplay getContentDisplay() { return contentDisplay == null ? ContentDisplay.LEFT : contentDisplay.getValue(); }
 672 
 673     /**
 674      * The padding around the Labeled&#39;s text and graphic content.
 675      * By default labelPadding is Insets.EMPTY and cannot be set to null.
 676      * Subclasses may add nodes outside this padding and inside the Labeled&#39;s padding.
 677      *
 678      * This property can only be set from CSS.
<span class="line-modified"> 679      *</span>
<span class="line-added"> 680      * @return the label padding property of this labeled</span>
<span class="line-added"> 681      * @defaultValue {@code Insets.EMPTY}</span>
 682      */
 683     public final ReadOnlyObjectProperty&lt;Insets&gt; labelPaddingProperty() {
 684         return labelPaddingPropertyImpl();
 685     }
 686     private ObjectProperty&lt;Insets&gt; labelPaddingPropertyImpl() {
 687         if (labelPadding == null) {
 688             labelPadding = new StyleableObjectProperty&lt;Insets&gt;(Insets.EMPTY) {
 689                 private Insets lastValidValue = Insets.EMPTY;
 690 
 691                 @Override
 692                 public void invalidated() {
 693                     final Insets newValue = get();
 694                     if (newValue == null) {
 695                         set(lastValidValue);
 696                         throw new NullPointerException(&quot;cannot set labelPadding to null&quot;);
 697                     }
 698                     lastValidValue = newValue;
 699                     requestLayout();
 700                 }
 701 
</pre>
<hr />
<pre>
 706 
 707                 @Override
 708                 public Object getBean() {
 709                     return Labeled.this;
 710                 }
 711 
 712                 @Override
 713                 public String getName() {
 714                     return &quot;labelPadding&quot;;
 715                 }
 716             };
 717         }
 718         return labelPadding;
 719     }
 720     private ObjectProperty&lt;Insets&gt; labelPadding;
 721     private void setLabelPadding(Insets value) { labelPaddingPropertyImpl().set(value); }
 722     public final Insets getLabelPadding() { return labelPadding == null ? Insets.EMPTY : labelPadding.get(); }
 723 
 724     /**
 725      * The amount of space between the graphic and text
<span class="line-added"> 726      *</span>
 727      * @return the graphics text gap property of this labeled
<span class="line-added"> 728      * @defaultValue 4</span>
 729      */
 730     public final DoubleProperty graphicTextGapProperty() {
 731         if (graphicTextGap == null) {
 732             graphicTextGap = new StyleableDoubleProperty(4) {
 733 
 734                 @Override
 735                 public CssMetaData&lt;Labeled,Number&gt; getCssMetaData() {
 736                     return StyleableProperties.GRAPHIC_TEXT_GAP;
 737                 }
 738 
 739                 @Override
 740                 public Object getBean() {
 741                     return Labeled.this;
 742                 }
 743 
 744                 @Override
 745                 public String getName() {
 746                     return &quot;graphicTextGap&quot;;
 747                 }
 748             };
 749         }
 750         return graphicTextGap;
 751     }
 752     private DoubleProperty graphicTextGap;
 753     public final void setGraphicTextGap(double value) { graphicTextGapProperty().setValue(value); }
 754     public final double getGraphicTextGap() { return graphicTextGap == null ? 4 : graphicTextGap.getValue(); }
 755 
 756 
 757     /**
 758      * The {@link Paint} used to fill the text.
<span class="line-added"> 759      *</span>
<span class="line-added"> 760      * @defaultValue {@code Color.BLACK}</span>
 761      */
 762     private ObjectProperty&lt;Paint&gt; textFill; // TODO for now change this
 763 
 764     public final void setTextFill(Paint value) {
 765         textFillProperty().set(value);
 766     }
 767 
 768     public final Paint getTextFill() {
 769         return textFill == null ? Color.BLACK : textFill.get();
 770     }
 771 
 772     public final ObjectProperty&lt;Paint&gt; textFillProperty() {
 773         if (textFill == null) {
 774             textFill = new StyleableObjectProperty&lt;Paint&gt;(Color.BLACK) {
 775 
 776                 @Override
 777                 public CssMetaData&lt;Labeled,Paint&gt; getCssMetaData() {
 778                     return StyleableProperties.TEXT_FILL;
 779                 }
 780 
</pre>
<hr />
<pre>
 784                 }
 785 
 786                 @Override
 787                 public String getName() {
 788                     return &quot;textFill&quot;;
 789                 }
 790             };
 791         }
 792         return textFill;
 793     }
 794 
 795 
 796     /**
 797      * MnemonicParsing property to enable/disable text parsing.
 798      * If this is set to true, then the Label text will be
 799      * parsed to see if it contains the mnemonic parsing character &#39;_&#39;.
 800      * When a mnemonic is detected the key combination will
 801      * be determined based on the succeeding character, and the mnemonic
 802      * added.
 803      *
<span class="line-modified"> 804      * @defaultValue {@code false}; {@code true} for some {@code Control}s.</span>



 805      */
 806     private BooleanProperty mnemonicParsing;
 807     public final void setMnemonicParsing(boolean value) {
 808         mnemonicParsingProperty().set(value);
 809     }
 810     public final boolean isMnemonicParsing() {
 811         return mnemonicParsing == null ? false : mnemonicParsing.get();
 812     }
 813     public final BooleanProperty mnemonicParsingProperty() {
 814         if (mnemonicParsing == null) {
 815             mnemonicParsing = new SimpleBooleanProperty(this, &quot;mnemonicParsing&quot;);
 816         }
 817         return mnemonicParsing;
 818     }
 819 
 820     //    /**
 821     //     * This is the symbol that is searched for in the text and used as
 822     //     * a mnemonic. You can change what symbol is used. Using the symbol
 823     //     * more than once will cause the symbol to be escaped. Thus, if &quot;_&quot;
 824     //     * (the default) is used, then the string &quot;H_ello World&quot; will use
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../javafx.base/src/main/java/javafx/collections/ObservableSet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Pagination.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>