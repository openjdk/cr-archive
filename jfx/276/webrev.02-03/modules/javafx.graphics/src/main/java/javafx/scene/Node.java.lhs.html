<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/javafx/scene/Node.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 /*
    2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
    3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4  *
    5  * This code is free software; you can redistribute it and/or modify it
    6  * under the terms of the GNU General Public License version 2 only, as
    7  * published by the Free Software Foundation.  Oracle designates this
    8  * particular file as subject to the &quot;Classpath&quot; exception as provided
    9  * by Oracle in the LICENSE file that accompanied this code.
   10  *
   11  * This code is distributed in the hope that it will be useful, but WITHOUT
   12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   14  * version 2 for more details (a copy is included in the LICENSE file that
   15  * accompanied this code).
   16  *
   17  * You should have received a copy of the GNU General Public License version
   18  * 2 along with this work; if not, write to the Free Software Foundation,
   19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   20  *
   21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   22  * or visit www.oracle.com if you need additional information or have any
   23  * questions.
   24  */
   25 
   26 package javafx.scene;
   27 
   28 
   29 import com.sun.javafx.geometry.BoundsUtils;
   30 import javafx.application.Platform;
   31 import javafx.beans.InvalidationListener;
   32 import javafx.beans.Observable;
   33 import javafx.beans.binding.BooleanExpression;
   34 import javafx.beans.property.BooleanProperty;
   35 import javafx.beans.property.BooleanPropertyBase;
   36 import javafx.beans.property.DoubleProperty;
   37 import javafx.beans.property.DoublePropertyBase;
   38 import javafx.beans.property.IntegerProperty;
   39 import javafx.beans.property.ObjectProperty;
   40 import javafx.beans.property.ObjectPropertyBase;
   41 import javafx.beans.property.ReadOnlyBooleanProperty;
   42 import javafx.beans.property.ReadOnlyBooleanPropertyBase;
   43 import javafx.beans.property.ReadOnlyBooleanWrapper;
   44 import javafx.beans.property.ReadOnlyObjectProperty;
   45 import javafx.beans.property.ReadOnlyObjectPropertyBase;
   46 import javafx.beans.property.ReadOnlyObjectWrapper;
   47 import javafx.beans.property.SimpleBooleanProperty;
   48 import javafx.beans.property.SimpleObjectProperty;
   49 import javafx.beans.property.StringProperty;
   50 import javafx.beans.property.StringPropertyBase;
   51 import javafx.beans.value.ChangeListener;
   52 import javafx.collections.FXCollections;
   53 import javafx.collections.ListChangeListener.Change;
   54 import javafx.collections.ObservableList;
   55 import javafx.collections.ObservableMap;
   56 import javafx.collections.ObservableSet;
   57 import javafx.css.CssMetaData;
   58 import javafx.css.ParsedValue;
   59 import javafx.css.PseudoClass;
   60 import javafx.css.StyleConverter;
   61 import javafx.css.Styleable;
   62 import javafx.css.StyleableBooleanProperty;
   63 import javafx.css.StyleableDoubleProperty;
   64 import javafx.css.StyleableObjectProperty;
   65 import javafx.css.StyleableProperty;
   66 import javafx.event.Event;
   67 import javafx.event.EventDispatchChain;
   68 import javafx.event.EventDispatcher;
   69 import javafx.event.EventHandler;
   70 import javafx.event.EventTarget;
   71 import javafx.event.EventType;
   72 import javafx.geometry.BoundingBox;
   73 import javafx.geometry.Bounds;
   74 import javafx.geometry.NodeOrientation;
   75 import javafx.geometry.Orientation;
   76 import javafx.geometry.Point2D;
   77 import javafx.geometry.Point3D;
   78 import javafx.geometry.Rectangle2D;
   79 import javafx.scene.effect.BlendMode;
   80 import javafx.scene.effect.Effect;
   81 import javafx.scene.image.WritableImage;
   82 import javafx.scene.input.ContextMenuEvent;
   83 import javafx.scene.input.DragEvent;
   84 import javafx.scene.input.Dragboard;
   85 import javafx.scene.input.InputEvent;
   86 import javafx.scene.input.InputMethodEvent;
   87 import javafx.scene.input.InputMethodRequests;
   88 import javafx.scene.input.KeyEvent;
   89 import javafx.scene.input.MouseDragEvent;
   90 import javafx.scene.input.MouseEvent;
   91 import javafx.scene.input.PickResult;
   92 import javafx.scene.input.RotateEvent;
   93 import javafx.scene.input.ScrollEvent;
   94 import javafx.scene.input.SwipeEvent;
   95 import javafx.scene.input.TouchEvent;
   96 import javafx.scene.input.TransferMode;
   97 import javafx.scene.input.ZoomEvent;
   98 import javafx.scene.text.Font;
   99 import javafx.scene.transform.Rotate;
  100 import javafx.scene.transform.Transform;
  101 import javafx.stage.Window;
  102 import javafx.util.Callback;
  103 import java.security.AccessControlContext;
  104 
  105 import java.util.ArrayList;
  106 import java.util.Collections;
  107 import java.util.EnumSet;
  108 import java.util.HashMap;
  109 import java.util.LinkedList;
  110 import java.util.List;
  111 import java.util.Map;
  112 import java.util.Set;
  113 
  114 import com.sun.glass.ui.Accessible;
  115 import com.sun.glass.ui.Application;
  116 import com.sun.javafx.util.Logging;
  117 import com.sun.javafx.util.TempState;
  118 import com.sun.javafx.util.Utils;
  119 import com.sun.javafx.beans.IDProperty;
  120 import com.sun.javafx.beans.event.AbstractNotifyListener;
  121 import com.sun.javafx.binding.ExpressionHelper;
  122 import com.sun.javafx.collections.TrackableObservableList;
  123 import com.sun.javafx.collections.UnmodifiableListSet;
  124 import com.sun.javafx.css.PseudoClassState;
  125 import javafx.css.Selector;
  126 import javafx.css.Style;
  127 import javafx.css.converter.BooleanConverter;
  128 import javafx.css.converter.CursorConverter;
  129 import javafx.css.converter.EffectConverter;
  130 import javafx.css.converter.EnumConverter;
  131 import javafx.css.converter.SizeConverter;
  132 import com.sun.javafx.effect.EffectDirtyBits;
  133 import com.sun.javafx.geom.BaseBounds;
  134 import com.sun.javafx.geom.BoxBounds;
  135 import com.sun.javafx.geom.PickRay;
  136 import com.sun.javafx.geom.RectBounds;
  137 import com.sun.javafx.geom.Vec3d;
  138 import com.sun.javafx.geom.transform.Affine3D;
  139 import com.sun.javafx.geom.transform.BaseTransform;
  140 import com.sun.javafx.geom.transform.GeneralTransform3D;
  141 import com.sun.javafx.geom.transform.NoninvertibleTransformException;
  142 import com.sun.javafx.perf.PerformanceTracker;
  143 import com.sun.javafx.scene.BoundsAccessor;
  144 import com.sun.javafx.scene.CameraHelper;
  145 import com.sun.javafx.scene.CssFlags;
  146 import com.sun.javafx.scene.DirtyBits;
  147 import com.sun.javafx.scene.EventHandlerProperties;
  148 import com.sun.javafx.scene.LayoutFlags;
  149 import com.sun.javafx.scene.NodeEventDispatcher;
  150 import com.sun.javafx.scene.NodeHelper;
  151 import com.sun.javafx.scene.SceneHelper;
  152 import com.sun.javafx.scene.SceneUtils;
  153 import com.sun.javafx.scene.input.PickResultChooser;
  154 import com.sun.javafx.scene.transform.TransformHelper;
  155 import com.sun.javafx.scene.transform.TransformUtils;
  156 import com.sun.javafx.scene.traversal.Direction;
  157 import com.sun.javafx.sg.prism.NGNode;
  158 import com.sun.javafx.tk.Toolkit;
  159 import com.sun.prism.impl.PrismSettings;
  160 import com.sun.scenario.effect.EffectHelper;
  161 
  162 import javafx.scene.shape.Shape3D;
  163 import com.sun.javafx.logging.PlatformLogger;
  164 import com.sun.javafx.logging.PlatformLogger.Level;
  165 
  166 /**
  167  * Base class for scene graph nodes. A scene graph is a set of tree data structures
  168  * where every item has zero or one parent, and each item is either
  169  * a &quot;leaf&quot; with zero sub-items or a &quot;branch&quot; with zero or more sub-items.
  170  * &lt;p&gt;
  171  * Each item in the scene graph is called a {@code Node}. Branch nodes are
  172  * of type {@link Parent}, whose concrete subclasses are {@link Group},
  173  * {@link javafx.scene.layout.Region}, and {@link javafx.scene.control.Control},
  174  * or subclasses thereof.
  175  * &lt;p&gt;
  176  * Leaf nodes are classes such as
  177  * {@link javafx.scene.shape.Rectangle}, {@link javafx.scene.text.Text},
  178  * {@link javafx.scene.image.ImageView}, {@link javafx.scene.media.MediaView},
  179  * or other such leaf classes which cannot have children. Only a single node within
  180  * each scene graph tree will have no parent, which is referred to as the &quot;root&quot; node.
  181  * &lt;p&gt;
  182  * There may be several trees in the scene graph. Some trees may be part of
  183  * a {@link Scene}, in which case they are eligible to be displayed.
  184  * Other trees might not be part of any {@link Scene}.
  185  * &lt;p&gt;
  186  * A node may occur at most once anywhere in the scene graph. Specifically,
  187  * a node must appear no more than once in all of the following:
  188  * as the root node of a {@link Scene},
  189  * the children ObservableList of a {@link Parent},
  190  * or as the clip of a {@link Node}.
  191  * &lt;p&gt;
  192  * The scene graph must not have cycles. A cycle would exist if a node is
  193  * an ancestor of itself in the tree, considering the {@link Group} content
  194  * ObservableList, {@link Parent} children ObservableList, and {@link Node} clip relationships
  195  * mentioned above.
  196  * &lt;p&gt;
  197  * If a program adds a child node to a Parent (including Group, Region, etc)
  198  * and that node is already a child of a different Parent or the root of a Scene,
  199  * the node is automatically (and silently) removed from its former parent.
  200  * If a program attempts to modify the scene graph in any other way that violates
  201  * the above rules, an exception is thrown, the modification attempt is ignored
  202  * and the scene graph is restored to its previous state.
  203  * &lt;p&gt;
  204  * It is possible to rearrange the structure of the scene graph, for
  205  * example, to move a subtree from one location in the scene graph to
  206  * another. In order to do this, one would normally remove the subtree from
  207  * its old location before inserting it at the new location. However, the
  208  * subtree will be automatically removed as described above if the application
  209  * doesn&#39;t explicitly remove it.
  210  * &lt;p&gt;
  211  * Node objects may be constructed and modified on any thread as long they are
  212  * not yet attached to a {@link Scene} in a {@link Window} that is
  213  * {@link Window#isShowing showing}.
  214  * An application must attach nodes to such a Scene or modify them on the JavaFX
  215  * Application Thread.
  216  *
  217  * &lt;p&gt;
  218  * The JavaFX Application Thread is created as part of the startup process for
  219  * the JavaFX runtime. See the {@link javafx.application.Application} class and
  220  * the {@link Platform#startup(Runnable)} method for more information.
  221  * &lt;/p&gt;
  222  *
  223  * &lt;p&gt;
  224  * An application should not extend the Node class directly. Doing so may lead to
  225  * an UnsupportedOperationException being thrown.
  226  * &lt;/p&gt;
  227  *
  228  * &lt;h2&gt;String ID&lt;/h2&gt;
  229  * &lt;p&gt;
  230  * Each node in the scene graph can be given a unique {@link #idProperty id}. This id is
  231  * much like the &quot;id&quot; attribute of an HTML tag in that it is up to the designer
  232  * and developer to ensure that the {@code id} is unique within the scene graph.
  233  * A convenience function called {@link #lookup(String)} can be used to find
  234  * a node with a unique id within the scene graph, or within a subtree of the
  235  * scene graph. The id can also be used identify nodes for applying styles; see
  236  * the CSS section below.
  237  *
  238  * &lt;h2&gt;Coordinate System&lt;/h2&gt;
  239  * &lt;p&gt;
  240  * The {@code Node} class defines a traditional computer graphics &quot;local&quot;
  241  * coordinate system in which the {@code x} axis increases to the right and the
  242  * {@code y} axis increases downwards.  The concrete node classes for shapes
  243  * provide variables for defining the geometry and location of the shape
  244  * within this local coordinate space.  For example,
  245  * {@link javafx.scene.shape.Rectangle} provides {@code x}, {@code y},
  246  * {@code width}, {@code height} variables while
  247  * {@link javafx.scene.shape.Circle} provides {@code centerX}, {@code centerY},
  248  * and {@code radius}.
  249  * &lt;p&gt;
  250  * At the device pixel level, integer coordinates map onto the corners and
  251  * cracks between the pixels and the centers of the pixels appear at the
  252  * midpoints between integer pixel locations.  Because all coordinate values
  253  * are specified with floating point numbers, coordinates can precisely
  254  * point to these corners (when the floating point values have exact integer
  255  * values) or to any location on the pixel.  For example, a coordinate of
  256  * {@code (0.5, 0.5)} would point to the center of the upper left pixel on the
  257  * {@code Stage}.  Similarly, a rectangle at {@code (0, 0)} with dimensions
  258  * of {@code 10} by {@code 10} would span from the upper left corner of the
  259  * upper left pixel on the {@code Stage} to the lower right corner of the
  260  * 10th pixel on the 10th scanline.  The pixel center of the last pixel
  261  * inside that rectangle would be at the coordinates {@code (9.5, 9.5)}.
  262  * &lt;p&gt;
  263  * In practice, most nodes have transformations applied to their coordinate
  264  * system as mentioned below.  As a result, the information above describing
  265  * the alignment of device coordinates to the pixel grid is relative to
  266  * the transformed coordinates, not the local coordinates of the nodes.
  267  * The {@link javafx.scene.shape.Shape Shape} class describes some additional
  268  * important context-specific information about coordinate mapping and how
  269  * it can affect rendering.
  270  *
  271  * &lt;h2&gt;Transformations&lt;/h2&gt;
  272  * &lt;p&gt;
  273  * Any {@code Node} can have transformations applied to it. These include
  274  * translation, rotation, scaling, or shearing.
  275  * &lt;p&gt;
  276  * A &lt;b&gt;translation&lt;/b&gt; transformation is one which shifts the origin of the
  277  * node&#39;s coordinate space along either the x or y axis. For example, if you
  278  * create a {@link javafx.scene.shape.Rectangle} which is drawn at the origin
  279  * (x=0, y=0) and has a width of 100 and a height of 50, and then apply a
  280  * {@link javafx.scene.transform.Translate} with a shift of 10 along the x axis
  281  * (x=10), then the rectangle will appear drawn at (x=10, y=0) and remain
  282  * 100 points wide and 50 tall. Note that the origin was shifted, not the
  283  * {@code x} variable of the rectangle.
  284  * &lt;p&gt;
  285  * A common node transform is a translation by an integer distance, most often
  286  * used to lay out nodes on the stage.  Such integer translations maintain the
  287  * device pixel mapping so that local coordinates that are integers still
  288  * map to the cracks between pixels.
  289  * &lt;p&gt;
  290  * A &lt;b&gt;rotation&lt;/b&gt; transformation is one which rotates the coordinate space of
  291  * the node about a specified &quot;pivot&quot; point, causing the node to appear rotated.
  292  * For example, if you create a {@link javafx.scene.shape.Rectangle} which is
  293  * drawn at the origin (x=0, y=0) and has a width of 100 and height of 30 and
  294  * you apply a {@link javafx.scene.transform.Rotate} with a 90 degree rotation
  295  * (angle=90) and a pivot at the origin (pivotX=0, pivotY=0), then
  296  * the rectangle will be drawn as if its x and y were zero but its height was
  297  * 100 and its width -30. That is, it is as if a pin is being stuck at the top
  298  * left corner and the rectangle is rotating 90 degrees clockwise around that
  299  * pin. If the pivot point is instead placed in the center of the rectangle
  300  * (at point x=50, y=15) then the rectangle will instead appear to rotate about
  301  * its center.
  302  * &lt;p&gt;
  303  * Note that as with all transformations, the x, y, width, and height variables
  304  * of the rectangle (which remain relative to the local coordinate space) have
  305  * not changed, but rather the transformation alters the entire coordinate space
  306  * of the rectangle.
  307  * &lt;p&gt;
  308  * A &lt;b&gt;scaling&lt;/b&gt; transformation causes a node to either appear larger or
  309  * smaller depending on the scaling factor. Scaling alters the coordinate space
  310  * of the node such that each unit of distance along the axis in local
  311  * coordinates is multiplied by the scale factor. As with rotation
  312  * transformations, scaling transformations are applied about a &quot;pivot&quot; point.
  313  * You can think of this as the point in the {@code Node} around which you &quot;zoom&quot;.  For
  314  * example, if you create a {@link javafx.scene.shape.Rectangle} with a
  315  * {@code strokeWidth} of 5, and a width and height of 50, and you apply a
  316  * {@link javafx.scene.transform.Scale} with scale factors (x=2.0, y=2.0) and
  317  * a pivot at the origin (pivotX=0, pivotY=0), the entire rectangle
  318  * (including the stroke) will double in size, growing to the right and
  319  * downwards from the origin.
  320  * &lt;p&gt;
  321  * A &lt;b&gt;shearing&lt;/b&gt; transformation, sometimes called a skew, effectively
  322  * rotates one axis so that the x and y axes are no longer perpendicular.
  323  * &lt;p&gt;
<a name="1" id="anc1"></a><span class="line-modified">  324  * Multiple transformations may be applied to a node. Custom transforms are applied first using the {@link #getTransforms transforms}</span>
<span class="line-modified">  325  * list. Predefined transforms are applied afterwards in this order: scale, rotation and translation. These are applied using the</span>
<span class="line-modified">  326  * {@link #scaleXProperty scaleX}, {@link #scaleYProperty scaleY}, {@link #scaleZProperty scaleZ}, {@link #rotateProperty rotate},</span>
<span class="line-removed">  327  * {@link #translateXProperty translateX}, {@link #translateYProperty translateY} and {@link #translateZProperty translateZ}</span>
<span class="line-removed">  328  * properties.</span>
  329  *
  330  * &lt;h2&gt;Bounding Rectangles&lt;/h2&gt;
  331  * &lt;p&gt;
  332  * Since every {@code Node} has transformations, every Node&#39;s geometric
  333  * bounding rectangle can be described differently depending on whether
  334  * transformations are accounted for or not.
  335  * &lt;p&gt;
  336  * Each {@code Node} has a read-only {@link #boundsInLocalProperty boundsInLocal}
  337  * variable which specifies the bounding rectangle of the {@code Node} in
  338  * untransformed local coordinates. {@code boundsInLocal} includes the
  339  * Node&#39;s shape geometry, including any space required for a
  340  * non-zero stroke that may fall outside the local position/size variables,
  341  * and its {@link #clipProperty clip} and {@link #effectProperty effect} variables.
  342  * &lt;p&gt;
  343  * Each {@code Node} also has a read-only {@link #boundsInParentProperty boundsInParent} variable which
  344  * specifies the bounding rectangle of the {@code Node} after all transformations
<a name="2" id="anc2"></a><span class="line-modified">  345  * have been applied as described in the &lt;i&gt;Transformations&lt;/i&gt; section.</span>


  346  * It is called &quot;boundsInParent&quot; because the rectangle will be relative to the
  347  * parent&#39;s coordinate system.  This is the &#39;visual&#39; bounds of the node.
  348  * &lt;p&gt;
  349  * Finally, the {@link #layoutBoundsProperty layoutBounds} variable defines the rectangular bounds of
  350  * the {@code Node} that should be used as the basis for layout calculations and
  351  * may differ from the visual bounds of the node.  For shapes, Text, and ImageView,
  352  * layoutBounds by default includes only the shape geometry, including space required
  353  * for a non-zero {@code strokeWidth}, but does &lt;i&gt;not&lt;/i&gt; include the effect,
  354  * clip, or any transforms. For resizable classes (Regions and Controls)
  355  * layoutBounds will always map to {@code 0,0 width x height}.
  356  *
  357  * &lt;p&gt; The image shows a node without any transformation and its {@code boundsInLocal}:
  358  * &lt;p&gt; &lt;img src=&quot;doc-files/boundsLocal.png&quot; alt=&quot;A sine wave shape enclosed by
  359  * an axis-aligned rectangular bounds&quot;&gt; &lt;/p&gt;
  360  * If we rotate the image by 20 degrees we get following result:
  361  * &lt;p&gt; &lt;img src=&quot;doc-files/boundsParent.png&quot; alt=&quot;An axis-aligned rectangular
  362  * bounds that encloses the shape rotated by 20 degrees&quot;&gt; &lt;/p&gt;
  363  * The red rectangle represents {@code boundsInParent} in the
  364  * coordinate space of the Node&#39;s parent. The {@code boundsInLocal} stays the same
  365  * as in the first image, the green rectangle in this image represents {@code boundsInLocal}
  366  * in the coordinate space of the Node.
  367  *
  368  * &lt;p&gt; The images show a filled and stroked rectangle and their bounds. The
  369  * first rectangle {@code [x:10.0 y:10.0 width:100.0 height:100.0 strokeWidth:0]}
  370  * has the following bounds bounds: {@code [x:10.0 y:10.0 width:100.0 height:100.0]}.
  371  *
  372  * The second rectangle {@code [x:10.0 y:10.0 width:100.0 height:100.0 strokeWidth:5]}
  373  * has the following bounds: {@code [x:7.5 y:7.5 width:105 height:105]}
  374  * (the stroke is centered by default, so only half of it is outside
  375  * of the original bounds; it is also possible to create inside or outside
  376  * stroke).
  377  *
  378  * Since neither of the rectangles has any transformation applied,
  379  * {@code boundsInParent} and {@code boundsInLocal} are the same. &lt;/p&gt;
  380  * &lt;p&gt; &lt;img src=&quot;doc-files/bounds.png&quot; alt=&quot;The rectangles are enclosed by their
  381  * respective bounds&quot;&gt; &lt;/p&gt;
  382  *
  383  *
  384  * &lt;h2&gt;CSS&lt;/h2&gt;
  385  * &lt;p&gt;
  386  * The {@code Node} class contains {@code id}, {@code styleClass}, and
  387  * {@code style} variables that are used in styling this node from
  388  * CSS. The {@code id} and {@code styleClass} variables are used in
  389  * CSS style sheets to identify nodes to which styles should be
  390  * applied. The {@code style} variable contains style properties and
  391  * values that are applied directly to this node.
  392  * &lt;p&gt;
  393  * For further information about CSS and how to apply CSS styles
  394  * to nodes, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
  395  * Guide&lt;/a&gt;.
  396  * @since JavaFX 2.0
  397  */
  398 @IDProperty(&quot;id&quot;)
  399 public abstract class Node implements EventTarget, Styleable {
  400 
  401     /*
  402      * Store the singleton instance of the NodeHelper subclass corresponding
  403      * to the subclass of this instance of Node
  404      */
  405     private NodeHelper nodeHelper = null;
  406 
  407     static {
  408         PerformanceTracker.logEvent(&quot;Node class loaded&quot;);
  409 
  410         // This is used by classes in different packages to get access to
  411         // private and package private methods.
  412         NodeHelper.setNodeAccessor(new NodeHelper.NodeAccessor() {
  413             @Override
  414             public NodeHelper getHelper(Node node) {
  415                 return node.nodeHelper;
  416             }
  417 
  418             @Override
  419             public void setHelper(Node node, NodeHelper nodeHelper) {
  420                 node.nodeHelper = nodeHelper;
  421             }
  422 
  423             @Override
  424             public void doMarkDirty(Node node, DirtyBits dirtyBit) {
  425                 node.doMarkDirty(dirtyBit);
  426             }
  427 
  428             @Override
  429             public void doUpdatePeer(Node node) {
  430                 node.doUpdatePeer();
  431             }
  432 
  433             @Override
  434             public BaseTransform getLeafTransform(Node node) {
  435                 return node.getLeafTransform();
  436             }
  437 
  438             @Override
  439             public Bounds doComputeLayoutBounds(Node node) {
  440                 return node.doComputeLayoutBounds();
  441             }
  442 
  443             @Override
  444             public void doTransformsChanged(Node node) {
  445                 node.doTransformsChanged();
  446             }
  447 
  448             @Override
  449             public void doPickNodeLocal(Node node, PickRay localPickRay,
  450                     PickResultChooser result) {
  451                 node.doPickNodeLocal(localPickRay, result);
  452             }
  453 
  454             @Override
  455             public boolean doComputeIntersects(Node node, PickRay pickRay,
  456                     PickResultChooser pickResult) {
  457                 return node.doComputeIntersects(pickRay, pickResult);
  458             }
  459 
  460             @Override
  461             public void doGeomChanged(Node node) {
  462                 node.doGeomChanged();
  463             }
  464 
  465             @Override
  466             public void doNotifyLayoutBoundsChanged(Node node) {
  467                 node.doNotifyLayoutBoundsChanged();
  468             }
  469 
  470             @Override
  471             public void doProcessCSS(Node node) {
  472                 node.doProcessCSS();
  473             }
  474 
  475             @Override
  476             public boolean isDirty(Node node, DirtyBits dirtyBit) {
  477                 return node.isDirty(dirtyBit);
  478             }
  479 
  480             @Override
  481             public boolean isDirtyEmpty(Node node) {
  482                 return node.isDirtyEmpty();
  483             }
  484 
  485             @Override
  486             public void syncPeer(Node node) {
  487                 node.syncPeer();
  488             }
  489 
  490             @Override
  491             public void layoutBoundsChanged(Node node) {
  492                 node.layoutBoundsChanged();
  493             }
  494 
  495             @Override
  496             public &lt;P extends NGNode&gt; P getPeer(Node node) {
  497                 return node.getPeer();
  498             }
  499 
  500             @Override
  501             public void setShowMnemonics(Node node, boolean value) {
  502                 node.setShowMnemonics(value);
  503             }
  504 
  505             @Override
  506             public boolean isShowMnemonics(Node node) {
  507                 return node.isShowMnemonics();
  508             }
  509 
  510             @Override
  511             public BooleanProperty showMnemonicsProperty(Node node) {
  512                 return node.showMnemonicsProperty();
  513             }
  514 
  515             @Override
  516             public boolean traverse(Node node, Direction direction) {
  517                 return node.traverse(direction);
  518             }
  519 
  520             @Override
  521             public double getPivotX(Node node) {
  522                 return node.getPivotX();
  523             }
  524 
  525             @Override
  526             public double getPivotY(Node node) {
  527                 return node.getPivotY();
  528             }
  529 
  530             @Override
  531             public double getPivotZ(Node node) {
  532                 return node.getPivotZ();
  533             }
  534 
  535             @Override
  536             public void pickNode(Node node,PickRay pickRay,
  537                     PickResultChooser result) {
  538                 node.pickNode(pickRay, result);
  539             }
  540 
  541             @Override
  542             public boolean intersects(Node node, PickRay pickRay,
  543                     PickResultChooser pickResult) {
  544                 return node.intersects(pickRay, pickResult);
  545             }
  546 
  547             @Override
  548             public double intersectsBounds(Node node, PickRay pickRay) {
  549                 return node.intersectsBounds(pickRay);
  550             }
  551 
  552             @Override
  553             public void layoutNodeForPrinting(Node node) {
  554                 node.doCSSLayoutSyncForSnapshot();
  555             }
  556 
  557             @Override
  558             public boolean isDerivedDepthTest(Node node) {
  559                 return node.isDerivedDepthTest();
  560             }
  561 
  562             @Override
  563             public SubScene getSubScene(Node node) {
  564                 return node.getSubScene();
  565             }
  566 
  567             @Override
  568             public void setLabeledBy(Node node, Node labeledBy) {
  569                 node.labeledBy = labeledBy;
  570             }
  571 
  572             @Override
  573             public Accessible getAccessible(Node node) {
  574                 return node.getAccessible();
  575             }
  576 
  577             @Override
  578             public void reapplyCSS(Node node) {
  579                 node.reapplyCSS();
  580             }
  581 
  582             @Override
  583             public boolean isTreeVisible(Node node) {
  584                 return node.isTreeVisible();
  585             }
  586 
  587             @Override
  588             public BooleanExpression treeVisibleProperty(Node node) {
  589                 return node.treeVisibleProperty();
  590             }
  591 
  592             @Override
  593             public boolean isTreeShowing(Node node) {
  594                 return node.isTreeShowing();
  595             }
  596 
  597             @Override
  598             public BooleanExpression treeShowingProperty(Node node) {
  599                 return node.treeShowingProperty();
  600             }
  601 
  602             @Override
  603             public List&lt;Style&gt; getMatchingStyles(CssMetaData cssMetaData,
  604                     Styleable styleable) {
  605                 return Node.getMatchingStyles(cssMetaData, styleable);
  606             }
  607 
  608             @Override
  609             public Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; findStyles(Node node,
  610                     Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; styleMap) {
  611                 return node.findStyles(styleMap);
  612             }
  613         });
  614     }
  615 
  616     /**************************************************************************
  617      *                                                                        *
  618      * Methods and state for managing the dirty bits of a Node. The dirty     *
  619      * bits are flags used to keep track of what things are dirty on the      *
  620      * node and therefore need processing on the next pulse. Since the pulse  *
  621      * happens asynchronously to the change that made the node dirty (for     *
  622      * performance reasons), we need to keep track of what things have        *
  623      * changed.                                                               *
  624      *                                                                        *
  625      *************************************************************************/
  626 
  627     /**
  628      * Set of dirty bits that are set when state is invalidated and cleared by
  629      * the updateState method, which is called from the synchronizer.
  630      * &lt;p&gt;
  631      * A node starts dirty.
  632      */
  633     private Set&lt;DirtyBits&gt; dirtyBits = EnumSet.allOf(DirtyBits.class);
  634 
  635     /**
  636      * Mark the specified bit as dirty, and add this node to the scene&#39;s dirty list.
  637      *
  638      * Note: This method MUST only be called via its accessor method.
  639      */
  640     private void doMarkDirty(DirtyBits dirtyBit) {
  641         if (isDirtyEmpty()) {
  642             addToSceneDirtyList();
  643         }
  644 
  645         dirtyBits.add(dirtyBit);
  646     }
  647 
  648     private void addToSceneDirtyList() {
  649         Scene s = getScene();
  650         if (s != null) {
  651             s.addToDirtyList(this);
  652             if (getSubScene() != null) {
  653                 getSubScene().setDirty(this);
  654             }
  655         }
  656     }
  657 
  658     /**
  659      * Test whether the specified dirty bit is set
  660      */
  661     final boolean isDirty(DirtyBits dirtyBit) {
  662         return dirtyBits.contains(dirtyBit);
  663     }
  664 
  665     /**
  666      * Clear the specified dirty bit
  667      */
  668     final void clearDirty(DirtyBits dirtyBit) {
  669         dirtyBits.remove(dirtyBit);
  670     }
  671 
  672     /**
  673      * Clear all dirty bits
  674      */
  675     private void clearDirty() {
  676         dirtyBits.clear();
  677     }
  678 
  679     /**
  680      * Test whether the set of dirty bits is empty
  681      */
  682     private boolean isDirtyEmpty() {
  683         return dirtyBits.isEmpty();
  684     }
  685 
  686     /**************************************************************************
  687      *                                                                        *
  688      * Methods for synchronizing state from this Node to its PG peer. This    *
  689      * should only *ever* be called during synchronization initialized as a   *
  690      * result of a pulse. Any attempt to synchronize at any other time may    *
  691      * cause rendering artifacts.                                             *
  692      *                                                                        *
  693      *************************************************************************/
  694 
  695     /**
  696      * Called by the synchronizer to update the state and
  697      * clear dirtybits of this node in the PG graph
  698      */
  699     final void syncPeer() {
  700         // Do not synchronize invisible nodes unless their visibility has changed
  701         // or they have requested a forced synchronization
  702         if (!isDirtyEmpty() &amp;&amp; (treeVisible
  703                                      || isDirty(DirtyBits.NODE_VISIBLE)
  704                                      || isDirty(DirtyBits.NODE_FORCE_SYNC)))
  705         {
  706             NodeHelper.updatePeer(this);
  707             clearDirty();
  708         }
  709     }
  710 
  711     /**
  712      * A temporary rect used for computing bounds by the various bounds
  713      * variables. This bounds starts life as a RectBounds, but may be promoted
  714      * to a BoxBounds if there is a 3D transform mixed into its computation.
  715      * These two fields were held in a thread local, but were then pulled
  716      * out of it so that we could compute bounds before holding the
  717      * synchronization lock. These objects have to be per-instance so
  718      * that we can pass the right data down to the PG side later during
  719      * synchronization (rather than statics as they were before).
  720      */
  721     private BaseBounds _geomBounds = new RectBounds(0, 0, -1, -1);
  722     private BaseBounds _txBounds = new RectBounds(0, 0, -1, -1);
  723 
  724     private boolean pendingUpdateBounds = false;
  725 
  726     // Happens before we hold the sync lock
  727     void updateBounds() {
  728         // Note: the clip must be handled before the visibility is checked. This is because the visiblity might be
  729         // changing in the clip and it is going to be synchronized, so it needs to recompute the bounds.
  730         Node n = getClip();
  731         if (n != null) {
  732             n.updateBounds();
  733         }
  734 
  735         // See syncPeer()
  736         if (!treeVisible &amp;&amp; !isDirty(DirtyBits.NODE_VISIBLE)) {
  737 
  738             // Need to save the dirty bits since they will be cleared even for the
  739             // case of short circuiting dirty bit processing.
  740             if (isDirty(DirtyBits.NODE_TRANSFORM)
  741                     || isDirty(DirtyBits.NODE_TRANSFORMED_BOUNDS)
  742                     || isDirty(DirtyBits.NODE_BOUNDS)) {
  743                 pendingUpdateBounds = true;
  744             }
  745 
  746             return;
  747         }
  748 
  749         // Set transform and bounds dirty bits when this node becomes visible
  750         if (pendingUpdateBounds) {
  751             NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORM);
  752             NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORMED_BOUNDS);
  753             NodeHelper.markDirty(this, DirtyBits.NODE_BOUNDS);
  754 
  755             pendingUpdateBounds = false;
  756         }
  757 
  758         if (isDirty(DirtyBits.NODE_TRANSFORM) || isDirty(DirtyBits.NODE_TRANSFORMED_BOUNDS)) {
  759             if (isDirty(DirtyBits.NODE_TRANSFORM)) {
  760                 updateLocalToParentTransform();
  761             }
  762             _txBounds = getTransformedBounds(_txBounds,
  763                                              BaseTransform.IDENTITY_TRANSFORM);
  764         }
  765 
  766         if (isDirty(DirtyBits.NODE_BOUNDS)) {
  767             _geomBounds = getGeomBounds(_geomBounds,
  768                     BaseTransform.IDENTITY_TRANSFORM);
  769         }
  770 
  771     }
  772 
  773     /*
  774      * This function is called during synchronization to update the state of the
  775      * NG Node from the FX Node. Subclasses of Node should override this method
  776      * and must call NodeHelper.updatePeer(this)
  777      *
  778      * Note: This method MUST only be called via its accessor method.
  779      */
  780     private void doUpdatePeer() {
  781         final NGNode peer = getPeer();
  782 
  783         // For debug / diagnostic purposes, we will copy across a name for this node down to
  784         // the NG layer, where we can use the name to figure out what the NGNode represents.
  785         // An alternative would be to have a back-reference from the NGNode back to the Node it
  786         // is a peer to, however it was felt that this would make it too easy to communicate back
  787         // to the Node and possibly violate thread invariants. But of course, we only need to do this
  788         // if we&#39;re going to print the render graph (otherwise all the work we&#39;d do to keep the name
  789         // properly updated would be a waste).
  790         if (PrismSettings.printRenderGraph &amp;&amp; isDirty(DirtyBits.DEBUG)) {
  791             final String id = getId();
  792             String className = getClass().getSimpleName();
  793             if (className.isEmpty()) {
  794                 className = getClass().getName();
  795             }
  796             peer.setName(id == null ? className : id + &quot;(&quot; + className + &quot;)&quot;);
  797         }
  798 
  799         if (isDirty(DirtyBits.NODE_TRANSFORM)) {
  800             peer.setTransformMatrix(localToParentTx);
  801         }
  802 
  803         if (isDirty(DirtyBits.NODE_VIEW_ORDER)) {
  804             peer.setViewOrder(getViewOrder());
  805         }
  806 
  807         if (isDirty(DirtyBits.NODE_BOUNDS)) {
  808             peer.setContentBounds(_geomBounds);
  809         }
  810 
  811         if (isDirty(DirtyBits.NODE_TRANSFORMED_BOUNDS)) {
  812             peer.setTransformedBounds(_txBounds, !isDirty(DirtyBits.NODE_BOUNDS));
  813         }
  814 
  815         if (isDirty(DirtyBits.NODE_OPACITY)) {
  816             peer.setOpacity((float)Utils.clamp(0, getOpacity(), 1));
  817         }
  818 
  819         if (isDirty(DirtyBits.NODE_CACHE)) {
  820             peer.setCachedAsBitmap(isCache(), getCacheHint());
  821         }
  822 
  823         if (isDirty(DirtyBits.NODE_CLIP)) {
  824             peer.setClipNode(getClip() != null ? getClip().getPeer() : null);
  825         }
  826 
  827         if (isDirty(DirtyBits.EFFECT_EFFECT)) {
  828             if (getEffect() != null) {
  829                 EffectHelper.sync(getEffect());
  830                 peer.effectChanged();
  831             }
  832         }
  833 
  834         if (isDirty(DirtyBits.NODE_EFFECT)) {
  835             peer.setEffect(getEffect() != null ? EffectHelper.getPeer(getEffect()) : null);
  836         }
  837 
  838         if (isDirty(DirtyBits.NODE_VISIBLE)) {
  839             peer.setVisible(isVisible());
  840         }
  841 
  842         if (isDirty(DirtyBits.NODE_DEPTH_TEST)) {
  843             peer.setDepthTest(isDerivedDepthTest());
  844         }
  845 
  846         if (isDirty(DirtyBits.NODE_BLENDMODE)) {
  847             BlendMode mode = getBlendMode();
  848             peer.setNodeBlendMode((mode == null)
  849                                   ? null
  850                                   : EffectHelper.getToolkitBlendMode(mode));
  851         }
  852     }
  853 
  854     /*************************************************************************
  855     *                                                                        *
  856     *                                                                        *
  857     *                                                                        *
  858     *************************************************************************/
  859 
  860     private static final Object USER_DATA_KEY = new Object();
  861     // A map containing a set of properties for this node
  862     private ObservableMap&lt;Object, Object&gt; properties;
  863 
  864     /**
<a name="3" id="anc3"></a><span class="line-modified">  865      * Returns an observable map of properties on this node for use primarily by application developers. Layout managers use this map</span>
<span class="line-removed">  866      * as well to specify layout constraints on the node, such as {@code HBox#setHgrow}, so the developer should be mindful of</span>
<span class="line-removed">  867      * clearing the map or overriding its values. These entries are not removed automatically if the node is removed from the layout</span>
<span class="line-removed">  868      * manager, so unused entries can exist throughout the life of the node.</span>
  869      *
<a name="4" id="anc4"></a><span class="line-modified">  870      * @return an observable map of properties on this node for use primarily</span>
<span class="line-modified">  871      * by application developers</span>


  872      */
  873      public final ObservableMap&lt;Object, Object&gt; getProperties() {
  874         if (properties == null) {
  875             properties = FXCollections.observableMap(new HashMap&lt;Object, Object&gt;());
  876         }
  877         return properties;
  878     }
  879 
  880     /**
  881      * Tests if Node has properties.
  882      * @return true if node has properties.
  883      */
  884      public boolean hasProperties() {
  885         return properties != null &amp;&amp; !properties.isEmpty();
  886     }
  887 
  888     /**
  889      * Convenience method for setting a single Object property that can be
  890      * retrieved at a later date. This is functionally equivalent to calling
  891      * the getProperties().put(Object key, Object value) method. This can later
  892      * be retrieved by calling {@link Node#getUserData()}.
  893      *
  894      * @param value The value to be stored - this can later be retrieved by calling
  895      *          {@link Node#getUserData()}.
  896      */
  897     public void setUserData(Object value) {
  898         getProperties().put(USER_DATA_KEY, value);
  899     }
  900 
  901     /**
  902      * Returns a previously set Object property, or null if no such property
  903      * has been set using the {@link Node#setUserData(java.lang.Object)} method.
  904      *
  905      * @return The Object that was previously set, or null if no property
  906      *          has been set or if null was set.
  907      */
  908     public Object getUserData() {
  909         return getProperties().get(USER_DATA_KEY);
  910     }
  911 
  912     /**************************************************************************
  913      *                                                                        *
  914      *
  915      *                                                                        *
  916      *************************************************************************/
  917 
  918     /**
  919      * The parent of this {@code Node}. If this {@code Node} has not been added
  920      * to a scene graph, then parent will be null.
  921      *
  922      * @defaultValue null
  923      */
  924     private ReadOnlyObjectWrapper&lt;Parent&gt; parent;
  925 
  926     final void setParent(Parent value) {
  927         parentPropertyImpl().set(value);
  928     }
  929 
  930     public final Parent getParent() {
  931         return parent == null ? null : parent.get();
  932     }
  933 
  934     public final ReadOnlyObjectProperty&lt;Parent&gt; parentProperty() {
  935         return parentPropertyImpl().getReadOnlyProperty();
  936     }
  937 
  938     private ReadOnlyObjectWrapper&lt;Parent&gt; parentPropertyImpl() {
  939         if (parent == null) {
  940             parent = new ReadOnlyObjectWrapper&lt;Parent&gt;() {
  941                 private Parent oldParent;
  942 
  943                 @Override
  944                 protected void invalidated() {
  945                     if (oldParent != null) {
  946                         oldParent.disabledProperty().removeListener(parentDisabledChangedListener);
  947                         oldParent.treeVisibleProperty().removeListener(parentTreeVisibleChangedListener);
  948                         if (nodeTransformation != null &amp;&amp; nodeTransformation.listenerReasons &gt; 0) {
  949                             ((Node) oldParent).localToSceneTransformProperty().removeListener(
  950                                     nodeTransformation.getLocalToSceneInvalidationListener());
  951                         }
  952                     }
  953                     updateDisabled();
  954                     computeDerivedDepthTest();
  955                     final Parent newParent = get();
  956                     if (newParent != null) {
  957                         newParent.disabledProperty().addListener(parentDisabledChangedListener);
  958                         newParent.treeVisibleProperty().addListener(parentTreeVisibleChangedListener);
  959                         if (nodeTransformation != null &amp;&amp; nodeTransformation.listenerReasons &gt; 0) {
  960                             ((Node) newParent).localToSceneTransformProperty().addListener(
  961                                     nodeTransformation.getLocalToSceneInvalidationListener());
  962                         }
  963                         //
  964                         // if parent changed, then CSS needs to be reapplied so
  965                         // that this node will get the right styles. This used
  966                         // to be done from Parent.children&#39;s onChanged method.
  967                         // See the comments there, also.
  968                         //
  969                         reapplyCSS();
  970                     } else {
  971                         // RT-31168: reset CssFlag to clean so css will be reapplied if the node is added back later.
  972                         // If flag is REAPPLY, then reapplyCSS() will just return and the call to
  973                         // notifyParentsOfInvalidatedCSS() will be skipped thus leaving the node un-styled.
  974                         cssFlag = CssFlags.CLEAN;
  975                     }
  976                     updateTreeVisible(true);
  977                     oldParent = newParent;
  978                     invalidateLocalToSceneTransform();
  979                     parentResolvedOrientationInvalidated();
  980                     notifyAccessibleAttributeChanged(AccessibleAttribute.PARENT);
  981                 }
  982 
  983                 @Override
  984                 public Object getBean() {
  985                     return Node.this;
  986                 }
  987 
  988                 @Override
  989                 public String getName() {
  990                     return &quot;parent&quot;;
  991                 }
  992             };
  993         }
  994         return parent;
  995     }
  996 
  997     private final InvalidationListener parentDisabledChangedListener = valueModel -&gt; updateDisabled();
  998 
  999     private final InvalidationListener parentTreeVisibleChangedListener = valueModel -&gt; updateTreeVisible(true);
 1000 
 1001     private final ChangeListener&lt;Boolean&gt; windowShowingChangedListener
 1002             = (win, oldVal, newVal) -&gt; updateTreeShowing();
 1003 
 1004     private final ChangeListener&lt;Window&gt; sceneWindowChangedListener = (scene, oldWindow, newWindow) -&gt; {
 1005         // Replace the windowShowingListener and call updateTreeShowing()
 1006         if (oldWindow != null) {
 1007             oldWindow.showingProperty().removeListener(windowShowingChangedListener);
 1008         }
 1009         if (newWindow != null) {
 1010             newWindow.showingProperty().addListener(windowShowingChangedListener);
 1011         }
 1012         updateTreeShowing();
 1013     };
 1014 
 1015     private SubScene subScene = null;
 1016 
 1017     /**
 1018      * The {@link Scene} that this {@code Node} is part of. If the Node is not
 1019      * part of a scene, then this variable will be null.
 1020      *
 1021      * @defaultValue null
 1022      */
 1023     private ReadOnlyObjectWrapperManualFire&lt;Scene&gt; scene = new ReadOnlyObjectWrapperManualFire&lt;Scene&gt;();
 1024 
 1025     private class ReadOnlyObjectWrapperManualFire&lt;T&gt; extends ReadOnlyObjectWrapper&lt;T&gt; {
 1026         @Override
 1027         public Object getBean() {
 1028             return Node.this;
 1029         }
 1030 
 1031         @Override
 1032         public String getName() {
 1033             return &quot;scene&quot;;
 1034         }
 1035 
 1036         @Override
 1037         protected void fireValueChangedEvent() {
 1038             /*
 1039              * Note: This method has been intentionally made into a no-op. In
 1040              * order to override the default set behavior. By default calling
 1041              * set(...) on a different scene will trigger:
 1042              * - invalidated();
 1043              * - fireValueChangedEvent();
 1044              * Both of the above are no-ops, but are handled manually via
 1045              * - Node.this.setScenes(...)
 1046              * - Node.this.invalidatedScenes(...)
 1047              * - forceValueChangedEvent()
 1048              */
 1049         }
 1050 
 1051         public void fireSuperValueChangedEvent() {
 1052             super.fireValueChangedEvent();
 1053         }
 1054     }
 1055 
 1056     private void invalidatedScenes(Scene oldScene, SubScene oldSubScene) {
 1057         Scene newScene = sceneProperty().get();
 1058         boolean sceneChanged = oldScene != newScene;
 1059         SubScene newSubScene = subScene;
 1060 
 1061         if (getClip() != null) {
 1062             getClip().setScenes(newScene, newSubScene);
 1063         }
 1064         if (sceneChanged) {
 1065             updateCanReceiveFocus();
 1066             if (isFocusTraversable()) {
 1067                 if (newScene != null) {
 1068                     newScene.initializeInternalEventDispatcher();
 1069                 }
 1070             }
 1071             focusSetDirty(oldScene);
 1072             focusSetDirty(newScene);
 1073         }
 1074         scenesChanged(newScene, newSubScene, oldScene, oldSubScene);
 1075 
 1076         // isTreeShowing needs to take into account of Window&#39;s showing
 1077         if (oldScene != null) {
 1078             oldScene.windowProperty().removeListener(sceneWindowChangedListener);
 1079 
 1080             Window window = oldScene.windowProperty().get();
 1081             if (window != null) {
 1082                 window.showingProperty().removeListener(windowShowingChangedListener);
 1083             }
 1084         }
 1085         if (newScene != null) {
 1086             newScene.windowProperty().addListener(sceneWindowChangedListener);
 1087 
 1088             Window window = newScene.windowProperty().get();
 1089             if (window != null) {
 1090                 window.showingProperty().addListener(windowShowingChangedListener);
 1091             }
 1092 
 1093         }
 1094         updateTreeShowing();
 1095 
 1096         if (sceneChanged) reapplyCSS();
 1097 
 1098         if (sceneChanged &amp;&amp; !isDirtyEmpty()) {
 1099             //Note: no need to remove from scene&#39;s dirty list
 1100             //Scene&#39;s is checking if the node&#39;s scene is correct
 1101             /* TODO: looks like an existing bug when a node is moved from one
 1102              * location to another, setScenes will be called twice by
 1103              * Parent.VetoableListDecorator onProposedChange and onChanged
 1104              * respectively. Removing the node and setting setScense(null,null)
 1105              * then adding it back to potentially the same scene. Causing the
 1106              * same node to being added twice to the same scene.
 1107              */
 1108             addToSceneDirtyList();
 1109         }
 1110 
 1111         if (newScene == null &amp;&amp; peer != null) {
 1112             peer.release();
 1113         }
 1114 
 1115         if (oldScene != null) {
 1116             oldScene.clearNodeMnemonics(this);
 1117         }
 1118         if (getParent() == null) {
 1119             // if we are the root we need to handle scene change
 1120             parentResolvedOrientationInvalidated();
 1121         }
 1122 
 1123         if (sceneChanged) { scene.fireSuperValueChangedEvent(); }
 1124 
 1125         /* Dispose the accessible peer, if any. If AT ever needs this node again
 1126          * a new accessible peer is created. */
 1127         if (accessible != null) {
 1128             /* Generally accessibility does not retain any state, therefore deleting objects
 1129              * generally does not cause problems (AT just asks everything back).
 1130              * The exception to this rule is when the object sends a notifications to the AT,
 1131              * in which case it is expected to be around to answer request for the new values.
 1132              * It is possible that a object is reparented (within the scene) in the middle of
 1133              * this process. For example, when a tree item is expanded, the notification is
 1134              * sent to the AT by the cell. But when the TreeView relayouts the cell can be
 1135              * reparented before AT can query the relevant information about the expand event.
 1136              * If the accessible was disposed, AT can&#39;t properly report the event.
 1137              *
 1138              * The fix is to defer the disposal of the accessible to the next pulse.
 1139              * If at that time the node is placed back to the scene, then the accessible is hooked
 1140              * to Node and AT requests are processed. Otherwise the accessible is disposed.
 1141              */
 1142             if (oldScene != null &amp;&amp; oldScene != newScene &amp;&amp; newScene == null) {
 1143                 // Strictly speaking we need some type of accessible.thaw() at this point.
 1144                 oldScene.addAccessible(Node.this, accessible);
 1145             } else {
 1146                 accessible.dispose();
 1147             }
 1148             /* Always set to null to ensure this accessible is never on more than one
 1149              * Scene#accMap at the same time (At lest not with the same accessible).
 1150              */
 1151             accessible = null;
 1152         }
 1153     }
 1154 
 1155     final void setScenes(Scene newScene, SubScene newSubScene) {
 1156         Scene oldScene = sceneProperty().get();
 1157         if (newScene != oldScene || newSubScene != subScene) {
 1158             scene.set(newScene);
 1159             SubScene oldSubScene = subScene;
 1160             subScene = newSubScene;
 1161             invalidatedScenes(oldScene, oldSubScene);
 1162             if (this instanceof SubScene) { // TODO: find better solution
 1163                 SubScene thisSubScene = (SubScene)this;
 1164                 thisSubScene.getRoot().setScenes(newScene, thisSubScene);
 1165             }
 1166         }
 1167     }
 1168 
 1169     final SubScene getSubScene() {
 1170         return subScene;
 1171     }
 1172 
 1173     public final Scene getScene() {
 1174         return scene.get();
 1175     }
 1176 
 1177     public final ReadOnlyObjectProperty&lt;Scene&gt; sceneProperty() {
 1178         return scene.getReadOnlyProperty();
 1179     }
 1180 
 1181     /**
 1182      * Exists for Parent and LightBase
 1183      */
 1184     void scenesChanged(final Scene newScene, final SubScene newSubScene,
 1185                        final Scene oldScene, final SubScene oldSubScene) { }
 1186 
 1187 
 1188     /**
 1189      * The id of this {@code Node}. This simple string identifier is useful for
 1190      * finding a specific Node within the scene graph. While the id of a Node
 1191      * should be unique within the scene graph, this uniqueness is not enforced.
 1192      * This is analogous to the &quot;id&quot; attribute on an HTML element
 1193      * (&lt;a href=&quot;http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier&quot;&gt;CSS ID Specification&lt;/a&gt;).
 1194      * &lt;p&gt;
 1195      *     For example, if a Node is given the id of &quot;myId&quot;, then the lookup method can
 1196      *     be used to find this node as follows: &lt;code&gt;scene.lookup(&quot;#myId&quot;);&lt;/code&gt;.
 1197      * &lt;/p&gt;
 1198      *
 1199      * @defaultValue null
 1200      * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
 1201      */
 1202     private StringProperty id;
 1203 
 1204     public final void setId(String value) {
 1205         idProperty().set(value);
 1206     }
 1207 
 1208     //TODO: this is copied from the property in order to add the @return statement.
 1209     //      We should have a better, general solution without the need to copy it.
 1210     /**
 1211      * The id of this {@code Node}. This simple string identifier is useful for
 1212      * finding a specific Node within the scene graph. While the id of a Node
 1213      * should be unique within the scene graph, this uniqueness is not enforced.
 1214      * This is analogous to the &quot;id&quot; attribute on an HTML element
 1215      * (&lt;a href=&quot;http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier&quot;&gt;CSS ID Specification&lt;/a&gt;).
 1216      *
 1217      * @return the id assigned to this {@code Node} using the {@code setId}
 1218      *         method or {@code null}, if no id has been assigned.
 1219      * @defaultValue null
 1220      * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;
 1221      */
 1222     public final String getId() {
 1223         return id == null ? null : id.get();
 1224     }
 1225 
 1226     public final StringProperty idProperty() {
 1227         if (id == null) {
 1228             id = new StringPropertyBase() {
 1229 
 1230                 @Override
 1231                 protected void invalidated() {
 1232                     reapplyCSS();
 1233                     if (PrismSettings.printRenderGraph) {
 1234                         NodeHelper.markDirty(Node.this, DirtyBits.DEBUG);
 1235                     }
 1236                 }
 1237 
 1238                 @Override
 1239                 public Object getBean() {
 1240                     return Node.this;
 1241                 }
 1242 
 1243                 @Override
 1244                 public String getName() {
 1245                     return &quot;id&quot;;
 1246                 }
 1247             };
 1248         }
 1249         return id;
 1250     }
 1251 
 1252     /**
 1253      * A list of String identifiers which can be used to logically group
 1254      * Nodes, specifically for an external style engine. This variable is
 1255      * analogous to the &quot;class&quot; attribute on an HTML element and, as such,
 1256      * each element of the list is a style class to which this Node belongs.
 1257      *
 1258      * @see &lt;a href=&quot;http://www.w3.org/TR/css3-selectors/#class-html&quot;&gt;CSS3 class selectors&lt;/a&gt;
 1259      * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
 1260      * @defaultValue null
 1261      */
 1262     private ObservableList&lt;String&gt; styleClass = new TrackableObservableList&lt;String&gt;() {
 1263         @Override
 1264         protected void onChanged(Change&lt;String&gt; c) {
 1265             reapplyCSS();
 1266         }
 1267 
 1268         @Override
 1269         public String toString() {
 1270             if (size() == 0) {
 1271                 return &quot;&quot;;
 1272             } else if (size() == 1) {
 1273                 return get(0);
 1274             } else {
 1275                 StringBuilder buf = new StringBuilder();
 1276                 for (int i = 0; i &lt; size(); i++) {
 1277                     buf.append(get(i));
 1278                     if (i + 1 &lt; size()) {
 1279                         buf.append(&#39; &#39;);
 1280                     }
 1281                 }
 1282                 return buf.toString();
 1283             }
 1284         }
 1285     };
 1286 
 1287     @Override
 1288     public final ObservableList&lt;String&gt; getStyleClass() {
 1289         return styleClass;
 1290     }
 1291 
 1292     /**
 1293      * A string representation of the CSS style associated with this
 1294      * specific {@code Node}. This is analogous to the &quot;style&quot; attribute of an
 1295      * HTML element. Note that, like the HTML style attribute, this
 1296      * variable contains style properties and values and not the
 1297      * selector portion of a style rule.
 1298      * @defaultValue empty string
 1299      * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
 1300      */
 1301     private StringProperty style;
 1302 
 1303     /**
 1304      * A string representation of the CSS style associated with this
 1305      * specific {@code Node}. This is analogous to the &quot;style&quot; attribute of an
 1306      * HTML element. Note that, like the HTML style attribute, this
 1307      * variable contains style properties and values and not the
 1308      * selector portion of a style rule.
 1309      * @param value The inline CSS style to use for this {@code Node}.
 1310      *         {@code null} is implicitly converted to an empty String.
 1311      * @defaultValue empty string
 1312      * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;
 1313      */
 1314     public final void setStyle(String value) {
 1315         styleProperty().set(value);
 1316     }
 1317 
 1318     // TODO: javadoc copied from property for the sole purpose of providing a return tag
 1319     /**
 1320      * A string representation of the CSS style associated with this
 1321      * specific {@code Node}. This is analogous to the &quot;style&quot; attribute of an
 1322      * HTML element. Note that, like the HTML style attribute, this
 1323      * variable contains style properties and values and not the
 1324      * selector portion of a style rule.
 1325      * @defaultValue empty string
 1326      * @return The inline CSS style associated with this {@code Node}.
 1327      *         If this {@code Node} does not have an inline style,
 1328      *         an empty String is returned.
 1329      * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;
 1330      */
 1331     public final String getStyle() {
 1332         return style == null ? &quot;&quot; : style.get();
 1333     }
 1334 
 1335     public final StringProperty styleProperty() {
 1336         if (style == null) {
 1337             style = new StringPropertyBase(&quot;&quot;) {
 1338 
 1339                 @Override public void set(String value) {
 1340                     // getStyle returns an empty string if the style property
 1341                     // is null. To be consistent, getStyle should also return
 1342                     // an empty string when the style property&#39;s value is null.
 1343                     super.set((value != null) ? value : &quot;&quot;);
 1344                 }
 1345 
 1346                 @Override
 1347                 protected void invalidated() {
 1348                     // If the style has changed, then styles of this node
 1349                     // and child nodes might be affected.
 1350                     reapplyCSS();
 1351                 }
 1352 
 1353                 @Override
 1354                 public Object getBean() {
 1355                     return Node.this;
 1356                 }
 1357 
 1358                 @Override
 1359                 public String getName() {
 1360                     return &quot;style&quot;;
 1361                 }
 1362             };
 1363         }
 1364         return style;
 1365     }
 1366 
 1367     /**
 1368      * Specifies whether this {@code Node} and any subnodes should be rendered
 1369      * as part of the scene graph. A node may be visible and yet not be shown
 1370      * in the rendered scene if, for instance, it is off the screen or obscured
 1371      * by another Node. Invisible nodes never receive mouse events or
 1372      * keyboard focus and never maintain keyboard focus when they become
 1373      * invisible.
 1374      *
 1375      * @defaultValue true
 1376      */
 1377     private BooleanProperty visible;
 1378 
 1379     public final void setVisible(boolean value) {
 1380         visibleProperty().set(value);
 1381     }
 1382 
 1383     public final boolean isVisible() {
 1384         return visible == null ? true : visible.get();
 1385     }
 1386 
 1387     public final BooleanProperty visibleProperty() {
 1388         if (visible == null) {
 1389             visible = new StyleableBooleanProperty(true) {
 1390                 boolean oldValue = true;
 1391                 @Override
 1392                 protected void invalidated() {
 1393                     if (oldValue != get()) {
 1394                         NodeHelper.markDirty(Node.this, DirtyBits.NODE_VISIBLE);
 1395                         NodeHelper.geomChanged(Node.this);
 1396                         updateTreeVisible(false);
 1397                         if (getParent() != null) {
 1398                             // notify the parent of the potential change in visibility
 1399                             // of this node, since visibility affects bounds of the
 1400                             // parent node
 1401                             getParent().childVisibilityChanged(Node.this);
 1402                         }
 1403                         oldValue = get();
 1404                     }
 1405                 }
 1406 
 1407                 @Override
 1408                 public CssMetaData getCssMetaData() {
 1409                     return StyleableProperties.VISIBILITY;
 1410                 }
 1411 
 1412                 @Override
 1413                 public Object getBean() {
 1414                     return Node.this;
 1415                 }
 1416 
 1417                 @Override
 1418                 public String getName() {
 1419                     return &quot;visible&quot;;
 1420                 }
 1421             };
 1422         }
 1423         return visible;
 1424     }
 1425 
 1426     public final void setCursor(Cursor value) {
 1427         cursorProperty().set(value);
 1428     }
 1429 
 1430     public final Cursor getCursor() {
 1431         return (miscProperties == null) ? DEFAULT_CURSOR
 1432                                         : miscProperties.getCursor();
 1433     }
 1434 
 1435     /**
 1436      * Defines the mouse cursor for this {@code Node} and subnodes. If null,
 1437      * then the cursor of the first parent node with a non-null cursor will be
 1438      * used. If no Node in the scene graph defines a cursor, then the cursor
 1439      * of the {@code Scene} will be used.
 1440      *
 1441      * @return the mouse cursor for this {@code Node} and subnodes
 1442      * @defaultValue null
 1443      */
 1444     public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
 1445         return getMiscProperties().cursorProperty();
 1446     }
 1447 
 1448     /**
 1449      * Specifies how opaque (that is, solid) the {@code Node} appears. A Node
 1450      * with 0% opacity is fully translucent. That is, while it is still
 1451      * {@link #visibleProperty visible} and rendered, you generally won&#39;t be able to see it. The
 1452      * exception to this rule is when the {@code Node} is combined with a
 1453      * blending mode and blend effect in which case a translucent Node may still
 1454      * have an impact in rendering. An opacity of 50% will render the node as
 1455      * being 50% transparent.
 1456      * &lt;p&gt;
 1457      * A {@link #visibleProperty visible} node with any opacity setting still receives mouse
 1458      * events and can receive keyboard focus. For example, if you want to have
 1459      * a large invisible rectangle overlay all {@code Node}s in the scene graph
 1460      * in order to intercept mouse events but not be visible to the user, you could
 1461      * create a large {@code Rectangle} that had an opacity of 0%.
 1462      * &lt;p&gt;
 1463      * Opacity is specified as a value between 0 and 1. Values less than 0 are
 1464      * treated as 0, values greater than 1 are treated as 1.
 1465      * &lt;p&gt;
 1466      * On some platforms ImageView might not support opacity variable.
 1467      *
 1468      * &lt;p&gt;
 1469      * There is a known limitation of mixing opacity &amp;lt; 1.0 with a 3D Transform.
 1470      * Opacity/Blending is essentially a 2D image operation. The result of
 1471      * an opacity &amp;lt; 1.0 set on a {@link Group} node with 3D transformed children
 1472      * will cause its children to be rendered in order without Z-buffering
 1473      * applied between those children.
 1474      *
 1475      * @defaultValue 1.0
 1476      */
 1477     private DoubleProperty opacity;
 1478 
 1479     public final void setOpacity(double value) {
 1480         opacityProperty().set(value);
 1481     }
 1482     public final double getOpacity() {
 1483         return opacity == null ? 1 : opacity.get();
 1484     }
 1485 
 1486     public final DoubleProperty opacityProperty() {
 1487         if (opacity == null) {
 1488             opacity = new StyleableDoubleProperty(1) {
 1489 
 1490                 @Override
 1491                 public void invalidated() {
 1492                     NodeHelper.markDirty(Node.this, DirtyBits.NODE_OPACITY);
 1493                 }
 1494 
 1495                 @Override
 1496                 public CssMetaData getCssMetaData() {
 1497                     return StyleableProperties.OPACITY;
 1498                 }
 1499 
 1500                 @Override
 1501                 public Object getBean() {
 1502                     return Node.this;
 1503                 }
 1504 
 1505                 @Override
 1506                 public String getName() {
 1507                     return &quot;opacity&quot;;
 1508                 }
 1509             };
 1510         }
 1511         return opacity;
 1512     }
 1513 
 1514     /**
 1515      * The {@link javafx.scene.effect.BlendMode} used to blend this individual node
 1516      * into the scene behind it. If this node is a {@code Group}, then all of the
 1517      * children will be composited individually into a temporary buffer using their
 1518      * own blend modes and then that temporary buffer will be composited into the
 1519      * scene using the specified blend mode.
 1520      *
 1521      * A value of {@code null} is treated as pass-through. This means no effect on a
 1522      * parent (such as a {@code Group}), and the equivalent of {@code SRC_OVER} for a single {@code Node}.
 1523      *
 1524      * @defaultValue {@code null}
 1525      */
 1526     private javafx.beans.property.ObjectProperty&lt;BlendMode&gt; blendMode;
 1527 
 1528     public final void setBlendMode(BlendMode value) {
 1529         blendModeProperty().set(value);
 1530     }
 1531     public final BlendMode getBlendMode() {
 1532         return blendMode == null ? null : blendMode.get();
 1533     }
 1534 
 1535     public final ObjectProperty&lt;BlendMode&gt; blendModeProperty() {
 1536         if (blendMode == null) {
 1537             blendMode = new StyleableObjectProperty&lt;BlendMode&gt;(null) {
 1538                 @Override public void invalidated() {
 1539                     NodeHelper.markDirty(Node.this, DirtyBits.NODE_BLENDMODE);
 1540                 }
 1541 
 1542                 @Override
 1543                 public CssMetaData getCssMetaData() {
 1544                     return StyleableProperties.BLEND_MODE;
 1545                 }
 1546 
 1547                 @Override
 1548                 public Object getBean() {
 1549                     return Node.this;
 1550                 }
 1551 
 1552                 @Override
 1553                 public String getName() {
 1554                     return &quot;blendMode&quot;;
 1555                 }
 1556             };
 1557         }
 1558         return blendMode;
 1559     }
 1560 
 1561     public final void setClip(Node value) {
 1562         clipProperty().set(value);
 1563     }
 1564 
 1565     public final Node getClip() {
 1566         return (miscProperties == null) ? DEFAULT_CLIP
 1567                                         : miscProperties.getClip();
 1568     }
 1569 
 1570     /**
 1571      * Specifies a {@code Node} to use to define the clipping shape for this
 1572      * Node. This clipping Node is not a child of this {@code Node} in the scene
 1573      * graph sense. Rather, it is used to define the clip for this {@code Node}.
 1574      * &lt;p&gt;
 1575      * For example, you can use an {@link javafx.scene.image.ImageView} Node as
 1576      * a mask to represent the Clip. Or you could use one of the geometric shape
 1577      * Nodes such as {@link javafx.scene.shape.Rectangle} or
 1578      * {@link javafx.scene.shape.Circle}. Or you could use a
 1579      * {@link javafx.scene.text.Text} node to represent the Clip.
 1580      * &lt;p&gt;
 1581      * See the class documentation for {@link Node} for scene graph structure
 1582      * restrictions on setting the clip. If these restrictions are violated by
 1583      * a change to the clip variable, the change is ignored and the
 1584      * previous value of the clip variable is restored.
 1585      * &lt;p&gt;
 1586      * Note that this is a conditional feature. See
 1587      * {@link javafx.application.ConditionalFeature#SHAPE_CLIP ConditionalFeature.SHAPE_CLIP}
 1588      * for more information.
 1589      * &lt;p&gt;
 1590      * There is a known limitation of mixing Clip with a 3D Transform.
 1591      * Clipping is essentially a 2D image operation. The result of
 1592      * a Clip set on a {@link Group} node with 3D transformed children
 1593      * will cause its children to be rendered in order without Z-buffering
 1594      * applied between those children.
 1595      *
 1596      * @return the the clipping shape for this {@code Node}
 1597      * @defaultValue null
 1598      */
 1599     public final ObjectProperty&lt;Node&gt; clipProperty() {
 1600         return getMiscProperties().clipProperty();
 1601     }
 1602 
 1603     public final void setCache(boolean value) {
 1604         cacheProperty().set(value);
 1605     }
 1606 
 1607     public final boolean isCache() {
 1608         return (miscProperties == null) ? DEFAULT_CACHE
 1609                                         : miscProperties.isCache();
 1610     }
 1611 
 1612     /**
 1613      * A performance hint to the system to indicate that this {@code Node}
 1614      * should be cached as a bitmap. Rendering a bitmap representation of a node
 1615      * will be faster than rendering primitives in many cases, especially in the
 1616      * case of primitives with effects applied (such as a blur). However, it
 1617      * also increases memory usage. This hint indicates whether that trade-off
 1618      * (increased memory usage for increased performance) is worthwhile. Also
 1619      * note that on some platforms such as GPU accelerated platforms there is
 1620      * little benefit to caching Nodes as bitmaps when blurs and other effects
 1621      * are used since they are very fast to render on the GPU.
 1622      *
 1623      * The {@link #cacheHintProperty} variable provides additional options for enabling
 1624      * more aggressive bitmap caching.
 1625      *
 1626      * &lt;p&gt;
 1627      * Caching may be disabled for any node that has a 3D transform on itself,
 1628      * any of its ancestors, or any of its descendants.
 1629      *
 1630      * @return the hint to cache for this {@code Node}
 1631      * @see #cacheHintProperty
 1632      * @defaultValue false
 1633      */
 1634     public final BooleanProperty cacheProperty() {
 1635         return getMiscProperties().cacheProperty();
 1636     }
 1637 
 1638     public final void setCacheHint(CacheHint value) {
 1639         cacheHintProperty().set(value);
 1640     }
 1641 
 1642     public final CacheHint getCacheHint() {
 1643         return (miscProperties == null) ? DEFAULT_CACHE_HINT
 1644                                         : miscProperties.getCacheHint();
 1645     }
 1646 
 1647     /**
 1648      * Additional hint for controlling bitmap caching.
 1649      * &lt;p&gt;
 1650      * Under certain circumstances, such as animating nodes that are very
 1651      * expensive to render, it is desirable to be able to perform
 1652      * transformations on the node without having to regenerate the cached
 1653      * bitmap.  An option in such cases is to perform the transforms on the
 1654      * cached bitmap itself.
 1655      * &lt;p&gt;
 1656      * This technique can provide a dramatic improvement to animation
 1657      * performance, though may also result in a reduction in visual quality.
 1658      * The {@code cacheHint} variable provides a hint to the system about how
 1659      * and when that trade-off (visual quality for animation performance) is
 1660      * acceptable.
 1661      * &lt;p&gt;
 1662      * It is possible to enable the cacheHint only at times when your node is
 1663      * animating.  In this way, expensive nodes can appear on screen with full
 1664      * visual quality, yet still animate smoothly.
 1665      * &lt;p&gt;
 1666      * Example:
 1667      * &lt;pre&gt;{@code
 1668         expensiveNode.setCache(true);
 1669         expensiveNode.setCacheHint(CacheHint.QUALITY);
 1670         ...
 1671         // Do an animation
 1672         expensiveNode.setCacheHint(CacheHint.SPEED);
 1673         new Timeline(
 1674             new KeyFrame(Duration.seconds(2),
 1675                 new KeyValue(expensiveNode.scaleXProperty(), 2.0),
 1676                 new KeyValue(expensiveNode.scaleYProperty(), 2.0),
 1677                 new KeyValue(expensiveNode.rotateProperty(), 360),
 1678                 new KeyValue(expensiveNode.cacheHintProperty(), CacheHint.QUALITY)
 1679             )
 1680         ).play();
 1681      }&lt;/pre&gt;
 1682      *
 1683      * Note that {@code cacheHint} is only a hint to the system.  Depending on
 1684      * the details of the node or the transform, this hint may be ignored.
 1685      *
 1686      * &lt;p&gt;
 1687      * If {@code Node.cache} is false, cacheHint is ignored.
 1688      * Caching may be disabled for any node that has a 3D transform on itself,
 1689      * any of its ancestors, or any of its descendants.
 1690      *
 1691      * @return the {@code CacheHint} for this {@code Node}
 1692      * @see #cacheProperty
 1693      * @defaultValue CacheHint.DEFAULT
 1694      */
 1695     public final ObjectProperty&lt;CacheHint&gt; cacheHintProperty() {
 1696         return getMiscProperties().cacheHintProperty();
 1697     }
 1698 
 1699     public final void setEffect(Effect value) {
 1700         effectProperty().set(value);
 1701     }
 1702 
 1703     public final Effect getEffect() {
 1704         return (miscProperties == null) ? DEFAULT_EFFECT
 1705                                         : miscProperties.getEffect();
 1706     }
 1707 
 1708     /**
 1709      * Specifies an effect to apply to this {@code Node}.
 1710      * &lt;p&gt;
 1711      * Note that this is a conditional feature. See
 1712      * {@link javafx.application.ConditionalFeature#EFFECT ConditionalFeature.EFFECT}
 1713      * for more information.
 1714      *
 1715      * &lt;p&gt;
 1716      * There is a known limitation of mixing Effect with a 3D Transform. Effect is
 1717      * essentially a 2D image operation. The result of an Effect set on
 1718      * a {@link Group} node with 3D transformed children will cause its children
 1719      * to be rendered in order without Z-buffering applied between those
 1720      * children.
 1721      *
 1722      * @return the effect for this {@code Node}
 1723      * @defaultValue null
 1724      */
 1725     public final ObjectProperty&lt;Effect&gt; effectProperty() {
 1726         return getMiscProperties().effectProperty();
 1727     }
 1728 
 1729     public final void setDepthTest(DepthTest value) {
 1730         depthTestProperty().set(value);
 1731     }
 1732 
 1733     public final DepthTest getDepthTest() {
 1734         return (miscProperties == null) ? DEFAULT_DEPTH_TEST
 1735                                         : miscProperties.getDepthTest();
 1736     }
 1737 
 1738     /**
 1739      * Indicates whether depth testing is used when rendering this node.
 1740      * If the depthTest flag is {@code DepthTest.DISABLE}, then depth testing
 1741      * is disabled for this node.
 1742      * If the depthTest flag is {@code DepthTest.ENABLE}, then depth testing
 1743      * is enabled for this node.
 1744      * If the depthTest flag is {@code DepthTest.INHERIT}, then depth testing
 1745      * is enabled for this node if it is enabled for the parent node or the
 1746      * parent node is null.
 1747      * &lt;p&gt;
 1748      * The depthTest flag is only used when the depthBuffer flag for
 1749      * the {@link Scene} is true (meaning that the
 1750      * {@link Scene} has an associated depth buffer)
 1751      * &lt;p&gt;
 1752      * Depth test comparison is only done among nodes with depthTest enabled.
 1753      * A node with depthTest disabled does not read, test, or write the depth buffer,
 1754      * that is to say its Z value will not be considered for depth testing
 1755      * with other nodes.
 1756      * &lt;p&gt;
 1757      * Note that this is a conditional feature. See
 1758      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 1759      * for more information.
 1760      * &lt;p&gt;
 1761      * See the constructor in Scene with depthBuffer as one of its input
 1762      * arguments.
 1763      *
 1764      * @return the depth test setting for this {@code Node}
 1765      * @see javafx.scene.Scene
 1766      * @defaultValue INHERIT
 1767      */
 1768     public final ObjectProperty&lt;DepthTest&gt; depthTestProperty() {
 1769         return getMiscProperties().depthTestProperty();
 1770     }
 1771 
 1772     /**
 1773      * Recompute the derived depth test flag. This flag is true
 1774      * if the depthTest flag for this node is true and the
 1775      * depth test flag for each ancestor node is true. It is false
 1776      * otherwise. Equivalently, the derived depth flag is true
 1777      * if the depthTest flag for this node is true and the derivedDepthTest
 1778      * flag for its parent is true.
 1779      */
 1780     void computeDerivedDepthTest() {
 1781         boolean newDDT;
 1782         if (getDepthTest() == DepthTest.INHERIT) {
 1783             if (getParent() != null) {
 1784                 newDDT = getParent().isDerivedDepthTest();
 1785             } else {
 1786                 newDDT = true;
 1787             }
 1788         } else if (getDepthTest() == DepthTest.ENABLE) {
 1789             newDDT = true;
 1790         } else {
 1791             newDDT = false;
 1792         }
 1793 
 1794         if (isDerivedDepthTest() != newDDT) {
 1795             NodeHelper.markDirty(this, DirtyBits.NODE_DEPTH_TEST);
 1796             setDerivedDepthTest(newDDT);
 1797         }
 1798     }
 1799 
 1800     // This is the derived depthTest value to pass to PG level
 1801     private boolean derivedDepthTest = true;
 1802 
 1803     void setDerivedDepthTest(boolean value) {
 1804         derivedDepthTest = value;
 1805     }
 1806 
 1807     boolean isDerivedDepthTest() {
 1808         return derivedDepthTest;
 1809     }
 1810 
 1811     public final void setDisable(boolean value) {
 1812         disableProperty().set(value);
 1813     }
 1814 
 1815     public final boolean isDisable() {
 1816         return (miscProperties == null) ? DEFAULT_DISABLE
 1817                                         : miscProperties.isDisable();
 1818     }
 1819 
 1820     /**
 1821      * Defines the individual disabled state of this {@code Node}. Setting
 1822      * {@code disable} to true will cause this {@code Node} and any subnodes to
 1823      * become disabled. This property should be used only to set the disabled
 1824      * state of a {@code Node}.  For querying the disabled state of a
 1825      * {@code Node}, the {@link #disabledProperty disabled} property should instead be used,
 1826      * since it is possible that a {@code Node} was disabled as a result of an
 1827      * ancestor being disabled even if the individual {@code disable} state on
 1828      * this {@code Node} is {@code false}.
 1829      *
 1830      * @return the disabled state for this {@code Node}
 1831      * @defaultValue false
 1832      */
 1833     public final BooleanProperty disableProperty() {
 1834         return getMiscProperties().disableProperty();
 1835     }
 1836 
 1837 
 1838 //    /**
 1839 //     * TODO document - null by default, could be non-null in subclasses (e.g. Control)
 1840 //     */
 1841 //    public final ObjectProperty&lt;InputMap&lt;?&gt;&gt; inputMapProperty() {
 1842 //        if (inputMap == null) {
 1843 //            inputMap = new SimpleObjectProperty&lt;InputMap&lt;?&gt;&gt;(this, &quot;inputMap&quot;) {
 1844 //                private InputMap&lt;?&gt; currentMap = get();
 1845 //                @Override protected void invalidated() {
 1846 //                    if (currentMap != null) {
 1847 //                        currentMap.dispose();
 1848 //                    }
 1849 //                    currentMap = get();
 1850 //                }
 1851 //            };
 1852 //        }
 1853 //        return inputMap;
 1854 //    }
 1855 //    public final void setInputMap(InputMap&lt;?&gt; value) { inputMapProperty().set(value); }
 1856 //    public final InputMap&lt;?&gt; getInputMap() { return inputMapProperty().getValue(); }
 1857 //    private ObjectProperty&lt;InputMap&lt;?&gt;&gt; inputMap;
 1858 
 1859 
 1860     /**************************************************************************
 1861      *                                                                        *
 1862      *
 1863      *                                                                        *
 1864      *************************************************************************/
 1865     /**
 1866      * Defines how the picking computation is done for this node when
 1867      * triggered by a {@code MouseEvent} or a {@code contains} function call.
 1868      *
 1869      * If {@code pickOnBounds} is {@code true}, then picking is computed by
 1870      * intersecting with the bounds of this node, else picking is computed
 1871      * by intersecting with the geometric shape of this node.
 1872      *
 1873      * The default value of this property is {@code false} unless
 1874      * overridden by a subclass. The default value is {@code true}
 1875      * for {@link javafx.scene.layout.Region}.
 1876      *
 1877      * @defaultValue false; true for {@code Region}
 1878      */
 1879     private BooleanProperty pickOnBounds;
 1880 
 1881     public final void setPickOnBounds(boolean value) {
 1882         pickOnBoundsProperty().set(value);
 1883     }
 1884 
 1885     public final boolean isPickOnBounds() {
 1886         return pickOnBounds == null ? false : pickOnBounds.get();
 1887     }
 1888 
 1889     public final BooleanProperty pickOnBoundsProperty() {
 1890         if (pickOnBounds == null) {
 1891             pickOnBounds = new SimpleBooleanProperty(this, &quot;pickOnBounds&quot;);
 1892         }
 1893         return pickOnBounds;
 1894     }
 1895 
 1896     /**
 1897      * Indicates whether or not this {@code Node} is disabled.  A {@code Node}
 1898      * will become disabled if {@link #disableProperty disable} is set to {@code true} on either
 1899      * itself or one of its ancestors in the scene graph.
 1900      * &lt;p&gt;
 1901      * A disabled {@code Node} should render itself differently to indicate its
 1902      * disabled state to the user.
 1903      * Such disabled rendering is dependent on the implementation of the
 1904      * {@code Node}. The shape classes contained in {@code javafx.scene.shape}
 1905      * do not implement such rendering by default, therefore applications using
 1906      * shapes for handling input must implement appropriate disabled rendering
 1907      * themselves. The user-interface controls defined in
 1908      * {@code javafx.scene.control} will implement disabled-sensitive rendering,
 1909      * however.
 1910      * &lt;p&gt;
 1911      * A disabled {@code Node} does not receive mouse or key events.
 1912      *
 1913      * @defaultValue false
 1914      */
 1915     private ReadOnlyBooleanWrapper disabled;
 1916 
 1917     protected final void setDisabled(boolean value) {
 1918         disabledPropertyImpl().set(value);
 1919     }
 1920 
 1921     public final boolean isDisabled() {
 1922         return disabled == null ? false : disabled.get();
 1923     }
 1924 
 1925     public final ReadOnlyBooleanProperty disabledProperty() {
 1926         return disabledPropertyImpl().getReadOnlyProperty();
 1927     }
 1928 
 1929     private ReadOnlyBooleanWrapper disabledPropertyImpl() {
 1930         if (disabled == null) {
 1931             disabled = new ReadOnlyBooleanWrapper() {
 1932 
 1933                 @Override
 1934                 protected void invalidated() {
 1935                     pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, get());
 1936                     updateCanReceiveFocus();
 1937                     focusSetDirty(getScene());
 1938                 }
 1939 
 1940                 @Override
 1941                 public Object getBean() {
 1942                     return Node.this;
 1943                 }
 1944 
 1945                 @Override
 1946                 public String getName() {
 1947                     return &quot;disabled&quot;;
 1948                 }
 1949             };
 1950         }
 1951         return disabled;
 1952     }
 1953 
 1954     private void updateDisabled() {
 1955         boolean isDisabled = isDisable();
 1956         if (!isDisabled) {
 1957             isDisabled = getParent() != null ? getParent().isDisabled() :
 1958                     getSubScene() != null &amp;&amp; getSubScene().isDisabled();
 1959         }
 1960         setDisabled(isDisabled);
 1961         if (this instanceof SubScene) {
 1962             ((SubScene)this).getRoot().setDisabled(isDisabled);
 1963         }
 1964     }
 1965 
 1966     /**
 1967      * Finds this {@code Node}, or the first sub-node, based on the given CSS selector.
 1968      * If this node is a {@code Parent}, then this function will traverse down
 1969      * into the branch until it finds a match. If more than one sub-node matches the
 1970      * specified selector, this function returns the first of them.
 1971      * &lt;p&gt;
 1972      *     For example, if a Node is given the id of &quot;myId&quot;, then the lookup method can
 1973      *     be used to find this node as follows: &lt;code&gt;scene.lookup(&quot;#myId&quot;);&lt;/code&gt;.
 1974      * &lt;/p&gt;
 1975      *
 1976      * @param selector The css selector of the node to find
 1977      * @return The first node, starting from this {@code Node}, which matches
 1978      *         the CSS {@code selector}, null if none is found.
 1979      */
 1980     public Node lookup(String selector) {
 1981         if (selector == null) return null;
 1982         Selector s = Selector.createSelector(selector);
 1983         return s != null &amp;&amp; s.applies(this) ? this : null;
 1984     }
 1985 
 1986     /**
 1987      * Finds all {@code Node}s, including this one and any children, which match
 1988      * the given CSS selector. If no matches are found, an empty unmodifiable set is
 1989      * returned. The set is explicitly unordered.
 1990      *
 1991      * @param selector The css selector of the nodes to find
 1992      * @return All nodes, starting from and including this {@code Node}, which match
 1993      *         the CSS {@code selector}. The returned set is always unordered and
 1994      *         unmodifiable, and never null.
 1995      */
 1996     public Set&lt;Node&gt; lookupAll(String selector) {
 1997         final Selector s = Selector.createSelector(selector);
 1998         final Set&lt;Node&gt; empty = Collections.emptySet();
 1999         if (s == null) return empty;
 2000         List&lt;Node&gt; results = lookupAll(s, null);
 2001         return results == null ? empty : new UnmodifiableListSet&lt;Node&gt;(results);
 2002     }
 2003 
 2004     /**
 2005      * Used by Node and Parent for traversing the tree and adding all nodes which
 2006      * match the given selector.
 2007      *
 2008      * @param selector The Selector. This will never be null.
 2009      * @param results The results. This will never be null.
 2010      */
 2011     List&lt;Node&gt; lookupAll(Selector selector, List&lt;Node&gt; results) {
 2012         if (selector.applies(this)) {
 2013             // Lazily create the set to reduce some trash.
 2014             if (results == null) {
 2015                 results = new LinkedList&lt;Node&gt;();
 2016             }
 2017             results.add(this);
 2018         }
 2019         return results;
 2020     }
 2021 
 2022     /**
 2023      * Moves this {@code Node} to the back of its sibling nodes in terms of
 2024      * z-order.  This is accomplished by moving this {@code Node} to the
 2025      * first position in its parent&#39;s {@code content} ObservableList.
 2026      * This function has no effect if this {@code Node} is not part of a group.
 2027      */
 2028     public void toBack() {
 2029         if (getParent() != null) {
 2030             getParent().toBack(this);
 2031         }
 2032     }
 2033 
 2034     /**
 2035      * Moves this {@code Node} to the front of its sibling nodes in terms of
 2036      * z-order.  This is accomplished by moving this {@code Node} to the
 2037      * last position in its parent&#39;s {@code content} ObservableList.
 2038      * This function has no effect if this {@code Node} is not part of a group.
 2039      */
 2040     public void toFront() {
 2041         if (getParent() != null) {
 2042             getParent().toFront(this);
 2043         }
 2044     }
 2045 
 2046     // TODO: need to verify whether this is OK to do starting from a node in
 2047     // the scene graph other than the root.
 2048     private void doCSSPass() {
 2049         if (this.cssFlag != CssFlags.CLEAN) {
 2050             // The dirty bit isn&#39;t checked but we must ensure it is cleared.
 2051             // The cssFlag is set to clean in either Node.processCSS or
 2052             // NodeHelper.processCSS
 2053 
 2054             // Don&#39;t clear the dirty bit in case it will cause problems
 2055             // with a full CSS pass on the scene.
 2056             // TODO: is this the right thing to do?
 2057             // this.clearDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);
 2058 
 2059             this.processCSS();
 2060         }
 2061     }
 2062 
 2063     /**
 2064      * Recursive function for synchronizing a node and all descendents
 2065      */
 2066     private static void syncAll(Node node) {
 2067         node.syncPeer();
 2068         if (node instanceof Parent) {
 2069             Parent p = (Parent) node;
 2070             final int childrenCount = p.getChildren().size();
 2071 
 2072             for (int i = 0; i &lt; childrenCount; i++) {
 2073                 Node n = p.getChildren().get(i);
 2074                 if (n != null) {
 2075                     syncAll(n);
 2076                 }
 2077             }
 2078         }
 2079         if (node.getClip() != null) {
 2080             syncAll(node.getClip());
 2081         }
 2082     }
 2083 
 2084     private void doLayoutPass() {
 2085         if (this instanceof Parent) {
 2086             // TODO: As an optimization we only need to layout those dirty
 2087             // roots that are descendants of this node
 2088             Parent p = (Parent)this;
 2089             for (int i = 0; i &lt; 3; i++) {
 2090                 p.layout();
 2091             }
 2092         }
 2093     }
 2094 
 2095     private void doCSSLayoutSyncForSnapshot() {
 2096         doCSSPass();
 2097         doLayoutPass();
 2098         updateBounds();
 2099         Scene.setAllowPGAccess(true);
 2100         syncAll(this);
 2101         Scene.setAllowPGAccess(false);
 2102     }
 2103 
 2104     private WritableImage doSnapshot(SnapshotParameters params, WritableImage img) {
 2105         if (getScene() != null) {
 2106             getScene().doCSSLayoutSyncForSnapshot(this);
 2107         } else {
 2108             doCSSLayoutSyncForSnapshot();
 2109         }
 2110 
 2111         BaseTransform transform = BaseTransform.IDENTITY_TRANSFORM;
 2112         if (params.getTransform() != null) {
 2113             Affine3D tempTx = new Affine3D();
 2114             TransformHelper.apply(params.getTransform(), tempTx);
 2115             transform = tempTx;
 2116         }
 2117         double x;
 2118         double y;
 2119         double w;
 2120         double h;
 2121         Rectangle2D viewport = params.getViewport();
 2122         if (viewport != null) {
 2123             // Use the specified viewport
 2124             x = viewport.getMinX();
 2125             y = viewport.getMinY();
 2126             w = viewport.getWidth();
 2127             h = viewport.getHeight();
 2128         } else {
 2129             // Get the bounds in parent of this node, transformed by the
 2130             // specified transform.
 2131             BaseBounds tempBounds = TempState.getInstance().bounds;
 2132             tempBounds = getTransformedBounds(tempBounds, transform);
 2133             x = tempBounds.getMinX();
 2134             y = tempBounds.getMinY();
 2135             w = tempBounds.getWidth();
 2136             h = tempBounds.getHeight();
 2137         }
 2138         WritableImage result = Scene.doSnapshot(getScene(), x, y, w, h,
 2139                 this, transform, params.isDepthBufferInternal(),
 2140                 params.getFill(), params.getEffectiveCamera(), img);
 2141 
 2142         return result;
 2143     }
 2144 
 2145     /**
 2146      * Takes a snapshot of this node and returns the rendered image when
 2147      * it is ready.
 2148      * CSS and layout processing will be done for the node, and any of its
 2149      * children, prior to rendering it.
 2150      * The entire destination image is cleared to the fill {@code Paint}
 2151      * specified by the SnapshotParameters. This node is then rendered to
 2152      * the image.
 2153      * If the viewport specified by the SnapshotParameters is null, the
 2154      * upper-left pixel of the {@code boundsInParent} of this
 2155      * node, after first applying the transform specified by the
 2156      * SnapshotParameters,
 2157      * is mapped to the upper-left pixel (0,0) in the image.
 2158      * If a non-null viewport is specified,
 2159      * the upper-left pixel of the viewport is mapped to upper-left pixel
 2160      * (0,0) in the image.
 2161      * In both cases, this mapping to (0,0) of the image is done with an integer
 2162      * translation. The portion of the node that is outside of the rendered
 2163      * image will be clipped by the image.
 2164      *
 2165      * &lt;p&gt;
 2166      * When taking a snapshot of a scene that is being animated, either
 2167      * explicitly by the application or implicitly (such as chart animation),
 2168      * the snapshot will be rendered based on the state of the scene graph at
 2169      * the moment the snapshot is taken and will not reflect any subsequent
 2170      * animation changes.
 2171      * &lt;/p&gt;
 2172      *
 2173      * &lt;p&gt;
 2174      * NOTE: In order for CSS and layout to function correctly, the node
 2175      * must be part of a Scene (the Scene may be attached to a Stage, but need
 2176      * not be).
 2177      * &lt;/p&gt;
 2178      *
 2179      * @param params the snapshot parameters containing attributes that
 2180      * will control the rendering. If the SnapshotParameters object is null,
 2181      * then the Scene&#39;s attributes will be used if this node is part of a scene,
 2182      * or default attributes will be used if this node is not part of a scene.
 2183      *
 2184      * @param image the writable image that will be used to hold the rendered node.
 2185      * It may be null in which case a new WritableImage will be constructed.
 2186      * The new image is constructed using integer width and
 2187      * height values that are derived either from the transformed bounds of this
 2188      * Node or from the size of the viewport as specified in the
 2189      * SnapShotParameters. These integer values are chosen such that the image
 2190      * will wholly contain the bounds of this Node or the specified viewport.
 2191      * If the image is non-null, the node will be rendered into the
 2192      * existing image.
 2193      * In this case, the width and height of the image determine the area
 2194      * that is rendered instead of the width and height of the bounds or
 2195      * viewport.
 2196      *
 2197      * @throws IllegalStateException if this method is called on a thread
 2198      *     other than the JavaFX Application Thread.
 2199      *
 2200      * @return the rendered image
 2201      * @since JavaFX 2.2
 2202      */
 2203     public WritableImage snapshot(SnapshotParameters params, WritableImage image) {
 2204         Toolkit.getToolkit().checkFxUserThread();
 2205 
 2206         if (params == null) {
 2207             params = new SnapshotParameters();
 2208             Scene s = getScene();
 2209             if (s != null) {
 2210                 params.setCamera(s.getEffectiveCamera());
 2211                 params.setDepthBuffer(s.isDepthBufferInternal());
 2212                 params.setFill(s.getFill());
 2213             }
 2214         }
 2215 
 2216         return doSnapshot(params, image);
 2217     }
 2218 
 2219     /**
 2220      * Takes a snapshot of this node at the next frame and calls the
 2221      * specified callback method when the image is ready.
 2222      * CSS and layout processing will be done for the node, and any of its
 2223      * children, prior to rendering it.
 2224      * The entire destination image is cleared to the fill {@code Paint}
 2225      * specified by the SnapshotParameters. This node is then rendered to
 2226      * the image.
 2227      * If the viewport specified by the SnapshotParameters is null, the
 2228      * upper-left pixel of the {@code boundsInParent} of this
 2229      * node, after first applying the transform specified by the
 2230      * SnapshotParameters,
 2231      * is mapped to the upper-left pixel (0,0) in the image.
 2232      * If a non-null viewport is specified,
 2233      * the upper-left pixel of the viewport is mapped to upper-left pixel
 2234      * (0,0) in the image.
 2235      * In both cases, this mapping to (0,0) of the image is done with an integer
 2236      * translation. The portion of the node that is outside of the rendered
 2237      * image will be clipped by the image.
 2238      *
 2239      * &lt;p&gt;
 2240      * This is an asynchronous call, which means that other
 2241      * events or animation might be processed before the node is rendered.
 2242      * If any such events modify the node, or any of its children, that
 2243      * modification will be reflected in the rendered image (just like it
 2244      * will also be reflected in the frame rendered to the Stage, if this node
 2245      * is part of a live scene graph).
 2246      * &lt;/p&gt;
 2247      *
 2248      * &lt;p&gt;
 2249      * When taking a snapshot of a node that is being animated, either
 2250      * explicitly by the application or implicitly (such as chart animation),
 2251      * the snapshot will be rendered based on the state of the scene graph at
 2252      * the moment the snapshot is taken and will not reflect any subsequent
 2253      * animation changes.
 2254      * &lt;/p&gt;
 2255      *
 2256      * &lt;p&gt;
 2257      * NOTE: In order for CSS and layout to function correctly, the node
 2258      * must be part of a Scene (the Scene may be attached to a Stage, but need
 2259      * not be).
 2260      * &lt;/p&gt;
 2261      *
 2262      * @param callback a class whose call method will be called when the image
 2263      * is ready. The SnapshotResult that is passed into the call method of
 2264      * the callback will contain the rendered image, the source node
 2265      * that was rendered, and a copy of the SnapshotParameters.
 2266      * The callback parameter must not be null.
 2267      *
 2268      * @param params the snapshot parameters containing attributes that
 2269      * will control the rendering. If the SnapshotParameters object is null,
 2270      * then the Scene&#39;s attributes will be used if this node is part of a scene,
 2271      * or default attributes will be used if this node is not part of a scene.
 2272      *
 2273      * @param image the writable image that will be used to hold the rendered node.
 2274      * It may be null in which case a new WritableImage will be constructed.
 2275      * The new image is constructed using integer width and
 2276      * height values that are derived either from the transformed bounds of this
 2277      * Node or from the size of the viewport as specified in the
 2278      * SnapShotParameters. These integer values are chosen such that the image
 2279      * will wholly contain the bounds of this Node or the specified viewport.
 2280      * If the image is non-null, the node will be rendered into the
 2281      * existing image.
 2282      * In this case, the width and height of the image determine the area
 2283      * that is rendered instead of the width and height of the bounds or
 2284      * viewport.
 2285      *
 2286      * @throws IllegalStateException if this method is called on a thread
 2287      *     other than the JavaFX Application Thread.
 2288      *
 2289      * @throws NullPointerException if the callback parameter is null.
 2290      * @since JavaFX 2.2
 2291      */
 2292     public void snapshot(Callback&lt;SnapshotResult, Void&gt; callback,
 2293             SnapshotParameters params, WritableImage image) {
 2294 
 2295         Toolkit.getToolkit().checkFxUserThread();
 2296         if (callback == null) {
 2297             throw new NullPointerException(&quot;The callback must not be null&quot;);
 2298         }
 2299 
 2300         if (params == null) {
 2301             params = new SnapshotParameters();
 2302             Scene s = getScene();
 2303             if (s != null) {
 2304                 params.setCamera(s.getEffectiveCamera());
 2305                 params.setDepthBuffer(s.isDepthBufferInternal());
 2306                 params.setFill(s.getFill());
 2307             }
 2308         } else {
 2309             params = params.copy();
 2310         }
 2311 
 2312         final SnapshotParameters theParams = params;
 2313         final Callback&lt;SnapshotResult, Void&gt; theCallback = callback;
 2314         final WritableImage theImage = image;
 2315 
 2316         // Create a deferred runnable that will be run from a pulse listener
 2317         // that is called after all of the scenes have been synced but before
 2318         // any of them have been rendered.
 2319         final Runnable snapshotRunnable = () -&gt; {
 2320             WritableImage img = doSnapshot(theParams, theImage);
 2321             SnapshotResult result = new SnapshotResult(img, Node.this, theParams);
 2322 //                System.err.println(&quot;Calling snapshot callback&quot;);
 2323             try {
 2324                 Void v = theCallback.call(result);
 2325             } catch (Throwable th) {
 2326                 System.err.println(&quot;Exception in snapshot callback&quot;);
 2327                 th.printStackTrace(System.err);
 2328             }
 2329         };
 2330 
 2331 //        System.err.println(&quot;Schedule a snapshot in the future&quot;);
 2332         Scene.addSnapshotRunnable(snapshotRunnable);
 2333     }
 2334 
 2335     /* ************************************************************************
 2336      *                                                                        *
 2337      *
 2338      *                                                                        *
 2339      *************************************************************************/
 2340 
 2341     public final void setOnDragEntered(
 2342             EventHandler&lt;? super DragEvent&gt; value) {
 2343         onDragEnteredProperty().set(value);
 2344     }
 2345 
 2346     public final EventHandler&lt;? super DragEvent&gt; getOnDragEntered() {
 2347         return (eventHandlerProperties == null)
 2348                 ? null : eventHandlerProperties.getOnDragEntered();
 2349     }
 2350 
 2351     /**
 2352      * Defines a function to be called when drag gesture
 2353      * enters this {@code Node}.
 2354      * @return the event handler that is called when drag gesture enters this
 2355      * {@code Node}
 2356      */
 2357     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
 2358             onDragEnteredProperty() {
 2359         return getEventHandlerProperties().onDragEnteredProperty();
 2360     }
 2361 
 2362     public final void setOnDragExited(
 2363             EventHandler&lt;? super DragEvent&gt; value) {
 2364         onDragExitedProperty().set(value);
 2365     }
 2366 
 2367     public final EventHandler&lt;? super DragEvent&gt; getOnDragExited() {
 2368         return (eventHandlerProperties == null)
 2369                 ? null : eventHandlerProperties.getOnDragExited();
 2370     }
 2371 
 2372     /**
 2373      * Defines a function to be called when drag gesture
 2374      * exits this {@code Node}.
 2375      * @return the event handler that is called when drag gesture exits this
 2376      * {@code Node}
 2377      */
 2378     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
 2379             onDragExitedProperty() {
 2380         return getEventHandlerProperties().onDragExitedProperty();
 2381     }
 2382 
 2383     public final void setOnDragOver(
 2384             EventHandler&lt;? super DragEvent&gt; value) {
 2385         onDragOverProperty().set(value);
 2386     }
 2387 
 2388     public final EventHandler&lt;? super DragEvent&gt; getOnDragOver() {
 2389         return (eventHandlerProperties == null)
 2390                 ? null : eventHandlerProperties.getOnDragOver();
 2391     }
 2392 
 2393     /**
 2394      * Defines a function to be called when drag gesture progresses within
 2395      * this {@code Node}.
 2396      * @return the event handler that is called when drag gesture progresses
 2397      * within this {@code Node}
 2398      */
 2399     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
 2400             onDragOverProperty() {
 2401         return getEventHandlerProperties().onDragOverProperty();
 2402     }
 2403 
 2404     // Do we want DRAG_TRANSFER_MODE_CHANGED event?
 2405 //    public final void setOnDragTransferModeChanged(
 2406 //            EventHandler&lt;? super DragEvent&gt; value) {
 2407 //        onDragTransferModeChangedProperty().set(value);
 2408 //    }
 2409 //
 2410 //    public final EventHandler&lt;? super DragEvent&gt; getOnDragTransferModeChanged() {
 2411 //        return (eventHandlerProperties == null)
 2412 //                ? null : eventHandlerProperties.getOnDragTransferModeChanged();
 2413 //    }
 2414 //
 2415 //    /**
 2416 //     * Defines a function to be called this {@code Node} if it is a potential
 2417 //     * drag-and-drop target when the user takes action to change the intended
 2418 //     * {@code TransferMode}.
 2419 //     * The user can change the intended {@link TransferMode} by holding down
 2420 //     * or releasing key modifiers.
 2421 //     */
 2422 //    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
 2423 //            onDragTransferModeChangedProperty() {
 2424 //        return getEventHandlerProperties().onDragTransferModeChangedProperty();
 2425 //    }
 2426 
 2427     public final void setOnDragDropped(
 2428             EventHandler&lt;? super DragEvent&gt; value) {
 2429         onDragDroppedProperty().set(value);
 2430     }
 2431 
 2432     public final EventHandler&lt;? super DragEvent&gt; getOnDragDropped() {
 2433         return (eventHandlerProperties == null)
 2434                 ? null : eventHandlerProperties.getOnDragDropped();
 2435     }
 2436 
 2437     /**
 2438      * Defines a function to be called when the mouse button is released
 2439      * on this {@code Node} during drag and drop gesture. Transfer of data from
 2440      * the {@link DragEvent}&#39;s {@link DragEvent#getDragboard() dragboard} should
 2441      * happen in this function.
 2442      * @return the event handler that is called when the mouse button is
 2443      * released on this {@code Node}
 2444      */
 2445     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
 2446             onDragDroppedProperty() {
 2447         return getEventHandlerProperties().onDragDroppedProperty();
 2448     }
 2449 
 2450     public final void setOnDragDone(
 2451             EventHandler&lt;? super DragEvent&gt; value) {
 2452         onDragDoneProperty().set(value);
 2453     }
 2454 
 2455     public final EventHandler&lt;? super DragEvent&gt; getOnDragDone() {
 2456         return (eventHandlerProperties == null)
 2457                 ? null : eventHandlerProperties.getOnDragDone();
 2458     }
 2459 
 2460     /**
 2461      * Defines a function to be called when this {@code Node} is a
 2462      * drag and drop gesture source after its data has
 2463      * been dropped on a drop target. The {@code transferMode} of the
 2464      * event shows what just happened at the drop target.
 2465      * If {@code transferMode} has the value {@code MOVE}, then the source can
 2466      * clear out its data. Clearing the source&#39;s data gives the appropriate
 2467      * appearance to a user that the data has been moved by the drag and drop
 2468      * gesture. A {@code transferMode} that has the value {@code NONE}
 2469      * indicates that no data was transferred during the drag and drop gesture.
 2470      * @return the event handler that is called when this {@code Node} is a drag
 2471      * and drop gesture source after its data has been dropped on a drop target
 2472      */
 2473     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
 2474             onDragDoneProperty() {
 2475         return getEventHandlerProperties().onDragDoneProperty();
 2476     }
 2477 
 2478     /**
 2479      * Confirms a potential drag and drop gesture that is recognized over this
 2480      * {@code Node}.
 2481      * Can be called only from a DRAG_DETECTED event handler. The returned
 2482      * {@link Dragboard} is used to transfer data during
 2483      * the drag and drop gesture. Placing this {@code Node}&#39;s data on the
 2484      * {@link Dragboard} also identifies this {@code Node} as the source of
 2485      * the drag and drop gesture.
 2486      * More detail about drag and drop gestures is described in the overivew
 2487      * of {@link DragEvent}.
 2488      *
 2489      * @see DragEvent
 2490      * @param transferModes The supported {@code TransferMode}(s) of this {@code Node}
 2491      * @return A {@code Dragboard} to place this {@code Node}&#39;s data on
 2492      * @throws IllegalStateException if drag and drop cannot be started at this
 2493      * moment (it&#39;s called outside of {@code DRAG_DETECTED} event handling or
 2494      * this node is not in scene).
 2495      */
 2496     public Dragboard startDragAndDrop(TransferMode... transferModes) {
 2497         if (getScene() != null) {
 2498             return getScene().startDragAndDrop(this, transferModes);
 2499         }
 2500 
 2501         throw new IllegalStateException(&quot;Cannot start drag and drop on node &quot;
 2502                 + &quot;that is not in scene&quot;);
 2503     }
 2504 
 2505     /**
 2506      * Starts a full press-drag-release gesture with this node as gesture
 2507      * source. This method can be called only from a {@code DRAG_DETECTED} mouse
 2508      * event handler. More detail about dragging gestures can be found
 2509      * in the overview of {@link MouseEvent} and {@link MouseDragEvent}.
 2510      *
 2511      * @see MouseEvent
 2512      * @see MouseDragEvent
 2513      * @throws IllegalStateException if the full press-drag-release gesture
 2514      * cannot be started at this moment (it&#39;s called outside of
 2515      * {@code DRAG_DETECTED} event handling or this node is not in scene).
 2516      * @since JavaFX 2.1
 2517      */
 2518     public void startFullDrag() {
 2519         if (getScene() != null) {
 2520             getScene().startFullDrag(this);
 2521             return;
 2522         }
 2523 
 2524         throw new IllegalStateException(&quot;Cannot start full drag on node &quot;
 2525                 + &quot;that is not in scene&quot;);
 2526     }
 2527 
 2528     ////////////////////////////
 2529     //  Private Implementation
 2530     ////////////////////////////
 2531 
 2532     /**
 2533      * If this Node is being used as the clip of another Node, that other node
 2534      * is referred to as the clipParent. If the boundsInParent of this Node
 2535      * changes, it must update the clipParent&#39;s bounds as well.
 2536      */
 2537     private Node clipParent;
 2538     // Use a getter function instead of giving clipParent package access,
 2539     // so that clipParent doesn&#39;t get turned into a Location.
 2540     final Node getClipParent() {
 2541         return clipParent;
 2542     }
 2543 
 2544     /**
 2545      * Determines whether this node is connected anywhere in the scene graph.
 2546      */
 2547     boolean isConnected() {
 2548         // don&#39;t need to check scene, because if scene is non-null
 2549         // parent must also be non-null
 2550         return getParent() != null || clipParent != null;
 2551     }
 2552 
 2553     /**
 2554      * Tests whether creating a parent-child relationship between these
 2555      * nodes would cause a cycle. The parent relationship includes not only
 2556      * the &quot;real&quot; parent (child of Group) but also the clipParent.
 2557      */
 2558     boolean wouldCreateCycle(Node parent, Node child) {
 2559         if (child != null &amp;&amp; child.getClip() == null &amp;&amp; (!(child instanceof Parent))) {
 2560             return false;
 2561     }
 2562 
 2563         Node n = parent;
 2564         while (n != child) {
 2565             if (n.getParent() != null) {
 2566                 n = n.getParent();
 2567             } else if (n.getSubScene() != null) {
 2568                 n = n.getSubScene();
 2569             } else if (n.clipParent != null) {
 2570                 n = n.clipParent;
 2571             } else {
 2572                 return false;
 2573             }
 2574         }
 2575         return true;
 2576     }
 2577 
 2578     /**
 2579      * The peer node created by the graphics Toolkit/Pipeline implementation
 2580      */
 2581     private NGNode peer;
 2582 
 2583     @SuppressWarnings(&quot;CallToPrintStackTrace&quot;)
 2584     &lt;P extends NGNode&gt; P getPeer() {
 2585         if (Utils.assertionEnabled()) {
 2586             // Assertion checking code
 2587             if (getScene() != null &amp;&amp; !Scene.isPGAccessAllowed()) {
 2588                 java.lang.System.err.println();
 2589                 java.lang.System.err.println(&quot;*** unexpected PG access&quot;);
 2590                 java.lang.Thread.dumpStack();
 2591             }
 2592         }
 2593 
 2594         if (peer == null) {
 2595             //if (PerformanceTracker.isLoggingEnabled()) {
 2596             //    PerformanceTracker.logEvent(&quot;Creating NGNode for [{this}, id=\&quot;{id}\&quot;]&quot;);
 2597             //}
 2598             peer = NodeHelper.createPeer(this);
 2599             //if (PerformanceTracker.isLoggingEnabled()) {
 2600             //    PerformanceTracker.logEvent(&quot;NGNode created&quot;);
 2601             //}
 2602         }
 2603         return (P) peer;
 2604     }
 2605 
 2606     /***************************************************************************
 2607      *                                                                         *
 2608      *                              Initialization                             *
 2609      *                                                                         *
 2610      *  To Note limit the number of bounds computations and improve startup    *
 2611      *  performance.                                                           *
 2612      *                                                                         *
 2613      **************************************************************************/
 2614 
 2615     /**
 2616      * Creates a new instance of Node.
 2617      */
 2618     protected Node() {
 2619         //if (PerformanceTracker.isLoggingEnabled()) {
 2620         //    PerformanceTracker.logEvent(&quot;Node.init for [{this}, id=\&quot;{id}\&quot;]&quot;);
 2621         //}
 2622         updateTreeVisible(false);
 2623         //if (PerformanceTracker.isLoggingEnabled()) {
 2624         //    PerformanceTracker.logEvent(&quot;Node.postinit &quot; +
 2625         //                                &quot;for [{this}, id=\&quot;{id}\&quot;] finished&quot;);
 2626         //}
 2627     }
 2628 
 2629     /***************************************************************************
 2630      *                                                                         *
 2631      * Layout related APIs.                                                    *
 2632      *                                                                         *
 2633      **************************************************************************/
 2634     /**
 2635      * Defines whether or not this node&#39;s layout will be managed by it&#39;s parent.
 2636      * If the node is managed, it&#39;s parent will factor the node&#39;s geometry
 2637      * into its own preferred size and {@link #layoutBoundsProperty layoutBounds}
 2638      * calculations and will lay it
 2639      * out during the scene&#39;s layout pass.  If a managed node&#39;s layoutBounds
 2640      * changes, it will automatically trigger relayout up the scene-graph
 2641      * to the nearest layout root (which is typically the scene&#39;s root node).
 2642      * &lt;p&gt;
 2643      * If the node is unmanaged, its parent will ignore the child in both preferred
 2644      * size computations and layout.   Changes in layoutBounds will not trigger
 2645      * relayout above it.   If an unmanaged node is of type {@link javafx.scene.Parent Parent},
 2646      * it will act as a &quot;layout root&quot;, meaning that calls to {@link Parent#requestLayout()}
 2647      * beneath it will cause only the branch rooted by the node to be relayed out,
 2648      * thereby isolating layout changes to that root and below.  It&#39;s the application&#39;s
 2649      * responsibility to set the size and position of an unmanaged node.
 2650      * &lt;p&gt;
 2651      * By default all nodes are managed.
 2652      * &lt;/p&gt;
 2653      *
 2654      * @see #isResizable()
 2655      * @see #layoutBoundsProperty()
 2656      * @see Parent#requestLayout()
 2657      *
 2658      */
 2659     private BooleanProperty managed;
 2660 
 2661     public final void setManaged(boolean value) {
 2662         managedProperty().set(value);
 2663     }
 2664 
 2665     public final boolean isManaged() {
 2666         return managed == null ? true : managed.get();
 2667     }
 2668 
 2669     public final BooleanProperty managedProperty() {
 2670         if (managed == null) {
 2671             managed = new BooleanPropertyBase(true) {
 2672 
 2673                 @Override
 2674                 protected void invalidated() {
 2675                     final Parent parent = getParent();
 2676                     if (parent != null) {
 2677                         parent.managedChildChanged();
 2678                     }
 2679                     notifyManagedChanged();
 2680                 }
 2681 
 2682                 @Override
 2683                 public Object getBean() {
 2684                     return Node.this;
 2685                 }
 2686 
 2687                 @Override
 2688                 public String getName() {
 2689                     return &quot;managed&quot;;
 2690                 }
 2691 
 2692             };
 2693         }
 2694         return managed;
 2695     }
 2696 
 2697     /**
 2698      * Called whenever the &quot;managed&quot; flag has changed. This is only
 2699      * used by Parent as an optimization to keep track of whether a
 2700      * Parent node is a layout root or not.
 2701      */
 2702     void notifyManagedChanged() { }
 2703 
 2704     /**
 2705      * Defines the x coordinate of the translation that is added to this {@code Node}&#39;s
 2706      * transform for the purpose of layout. The value should be computed as the
 2707      * offset required to adjust the position of the node from its current
 2708      * {@link #layoutBoundsProperty() layoutBounds minX} position (which might not be 0) to the desired location.
 2709      *
 2710      * &lt;p&gt;For example, if {@code textnode} should be positioned at {@code finalX}
 2711      * &lt;pre&gt;{@code
 2712      *     textnode.setLayoutX(finalX - textnode.getLayoutBounds().getMinX());
 2713      * }&lt;/pre&gt;
 2714      * &lt;p&gt;
 2715      * Failure to subtract {@code layoutBounds minX} may result in misplacement
 2716      * of the node.  The {@link #relocate(double, double) relocate(x, y)} method will automatically do the
 2717      * correct computation and should generally be used over setting layoutX directly.
 2718      * &lt;p&gt;
 2719      * The node&#39;s final translation will be computed as {@code layoutX} + {@link #translateXProperty translateX},
 2720      * where {@code layoutX} establishes the node&#39;s stable position
 2721      * and {@code translateX} optionally makes dynamic adjustments to that
 2722      * position.
 2723      * &lt;p&gt;
 2724      * If the node is managed and has a {@link javafx.scene.layout.Region}
 2725      * as its parent, then the layout region will set {@code layoutX} according to its
 2726      * own layout policy.   If the node is unmanaged or parented by a {@link Group},
 2727      * then the application may set {@code layoutX} directly to position it.
 2728      *
 2729      * @see #relocate(double, double)
 2730      * @see #layoutBoundsProperty()
 2731      *
 2732      */
 2733     private DoubleProperty layoutX;
 2734 
 2735     public final void setLayoutX(double value) {
 2736         layoutXProperty().set(value);
 2737     }
 2738 
 2739     public final double getLayoutX() {
 2740         return layoutX == null ? 0.0 : layoutX.get();
 2741     }
 2742 
 2743     public final DoubleProperty layoutXProperty() {
 2744         if (layoutX == null) {
 2745             layoutX = new DoublePropertyBase(0.0) {
 2746 
 2747                 @Override
 2748                 protected void invalidated() {
 2749                     NodeHelper.transformsChanged(Node.this);
 2750                     final Parent p = getParent();
 2751 
 2752                     // Propagate layout if this change isn&#39;t triggered by its parent
 2753                     if (p != null &amp;&amp; !p.isCurrentLayoutChild(Node.this)) {
 2754                         if (isManaged()) {
 2755                             // Force its parent to fix the layout since it is a managed child.
 2756                             p.requestLayout(true);
 2757                         } else {
 2758                             // Parent size changed, parent&#39;s parent might need to re-layout
 2759                             p.clearSizeCache();
 2760                             p.requestParentLayout();
 2761                         }
 2762                     }
 2763                 }
 2764 
 2765                 @Override
 2766                 public Object getBean() {
 2767                     return Node.this;
 2768                 }
 2769 
 2770                 @Override
 2771                 public String getName() {
 2772                     return &quot;layoutX&quot;;
 2773                 }
 2774             };
 2775         }
 2776         return layoutX;
 2777     }
 2778 
 2779     /**
 2780      * Defines the y coordinate of the translation that is added to this {@code Node}&#39;s
 2781      * transform for the purpose of layout. The value should be computed as the
 2782      * offset required to adjust the position of the node from its current
 2783      * {@link #layoutBoundsProperty() layoutBounds minY} position (which might not be 0) to the desired location.
 2784      *
 2785      * &lt;p&gt;For example, if {@code textnode} should be positioned at {@code finalY}
 2786      * &lt;pre&gt;{@code
 2787      *     textnode.setLayoutY(finalY - textnode.getLayoutBounds().getMinY());
 2788      * }&lt;/pre&gt;
 2789      * &lt;p&gt;
 2790      * Failure to subtract {@code layoutBounds minY} may result in misplacement
 2791      * of the node.  The {@link #relocate(double, double) relocate(x, y)} method will automatically do the
 2792      * correct computation and should generally be used over setting layoutY directly.
 2793      * &lt;p&gt;
 2794      * The node&#39;s final translation will be computed as {@code layoutY} + {@link #translateYProperty translateY},
 2795      * where {@code layoutY} establishes the node&#39;s stable position
 2796      * and {@code translateY} optionally makes dynamic adjustments to that
 2797      * position.
 2798      * &lt;p&gt;
 2799      * If the node is managed and has a {@link javafx.scene.layout.Region}
 2800      * as its parent, then the region will set {@code layoutY} according to its
 2801      * own layout policy.   If the node is unmanaged or parented by a {@link Group},
 2802      * then the application may set {@code layoutY} directly to position it.
 2803      *
 2804      * @see #relocate(double, double)
 2805      * @see #layoutBoundsProperty()
 2806      */
 2807     private DoubleProperty layoutY;
 2808 
 2809     public final void setLayoutY(double value) {
 2810         layoutYProperty().set(value);
 2811     }
 2812 
 2813     public final double getLayoutY() {
 2814         return layoutY == null ? 0.0 : layoutY.get();
 2815     }
 2816 
 2817     public final DoubleProperty layoutYProperty() {
 2818         if (layoutY == null) {
 2819             layoutY = new DoublePropertyBase(0.0) {
 2820 
 2821                 @Override
 2822                 protected void invalidated() {
 2823                     NodeHelper.transformsChanged(Node.this);
 2824                     final Parent p = getParent();
 2825 
 2826                     // Propagate layout if this change isn&#39;t triggered by its parent
 2827                     if (p != null &amp;&amp; !p.isCurrentLayoutChild(Node.this)) {
 2828                         if (isManaged()) {
 2829                             // Force its parent to fix the layout since it is a managed child.
 2830                             p.requestLayout(true);
 2831                         } else {
 2832                             // Parent size changed, parent&#39;s parent might need to re-layout
 2833                             p.clearSizeCache();
 2834                             p.requestParentLayout();
 2835                         }
 2836                     }
 2837                 }
 2838 
 2839                 @Override
 2840                 public Object getBean() {
 2841                     return Node.this;
 2842                 }
 2843 
 2844                 @Override
 2845                 public String getName() {
 2846                     return &quot;layoutY&quot;;
 2847                 }
 2848 
 2849             };
 2850         }
 2851         return layoutY;
 2852     }
 2853 
 2854     /**
 2855      * Sets the node&#39;s layoutX and layoutY translation properties in order to
 2856      * relocate this node to the x,y location in the parent.
 2857      * &lt;p&gt;
 2858      * This method does not alter translateX or translateY, which if also set
 2859      * will be added to layoutX and layoutY, adjusting the final location by
 2860      * corresponding amounts.
 2861      *
 2862      * @param x the target x coordinate location
 2863      * @param y the target y coordinate location
 2864      */
 2865     public void relocate(double x, double y) {
 2866         setLayoutX(x - getLayoutBounds().getMinX());
 2867         setLayoutY(y - getLayoutBounds().getMinY());
 2868 
 2869         PlatformLogger logger = Logging.getLayoutLogger();
 2870         if (logger.isLoggable(Level.FINER)) {
 2871             logger.finer(this.toString()+&quot; moved to (&quot;+x+&quot;,&quot;+y+&quot;)&quot;);
 2872         }
 2873     }
 2874 
 2875     /**
 2876      * Indicates whether this node is a type which can be resized by its parent.
 2877      * If this method returns true, then the parent will resize the node (ideally
 2878      * within its size range) by calling node.resize(width,height) during the
 2879      * layout pass.  All Regions, Controls, and WebView are resizable classes
 2880      * which depend on their parents resizing them during layout once all sizing
 2881      * and CSS styling information has been applied.
 2882      * &lt;p&gt;
 2883      * If this method returns false, then the parent cannot resize it during
 2884      * layout (resize() is a no-op) and it should return its layoutBounds for
 2885      * minimum, preferred, and maximum sizes.  Group, Text, and all Shapes are not
 2886      * resizable and hence depend on the application to establish their sizing
 2887      * by setting appropriate properties (e.g.  width/height for Rectangle,
 2888      * text on Text, and so on).  Non-resizable nodes may still be relocated
 2889      * during layout.
 2890      *
 2891      * @see #getContentBias()
 2892      * @see #minWidth(double)
 2893      * @see #minHeight(double)
 2894      * @see #prefWidth(double)
 2895      * @see #prefHeight(double)
 2896      * @see #maxWidth(double)
 2897      * @see #maxHeight(double)
 2898      * @see #resize(double, double)
 2899      * @see #getLayoutBounds()
 2900      *
 2901      * @return whether or not this node type can be resized by its parent during layout
 2902      */
 2903     public boolean isResizable() {
 2904         return false;
 2905     }
 2906 
 2907     /**
 2908      * Returns the orientation of a node&#39;s resizing bias for layout purposes.
 2909      * If the node type has no bias, returns null.  If the node is resizable and
 2910      * it&#39;s height depends on its width, returns HORIZONTAL, else if its width
 2911      * depends on its height, returns VERTICAL.
 2912      * &lt;p&gt;
 2913      * Resizable subclasses should override this method to return an
 2914      * appropriate value.
 2915      *
 2916      * @see #isResizable()
 2917      * @see #minWidth(double)
 2918      * @see #minHeight(double)
 2919      * @see #prefWidth(double)
 2920      * @see #prefHeight(double)
 2921      * @see #maxWidth(double)
 2922      * @see #maxHeight(double)
 2923      *
 2924      * @return orientation of width/height dependency or null if there is none
 2925      */
 2926     public Orientation getContentBias() {
 2927         return null;
 2928     }
 2929 
 2930     /**
 2931      * Returns the node&#39;s minimum width for use in layout calculations.
 2932      * If the node is resizable, its parent should not resize its width any
 2933      * smaller than this value.  If the node is not resizable, returns its
 2934      * layoutBounds width.
 2935      * &lt;p&gt;
 2936      * Layout code which calls this method should first check the content-bias
 2937      * of the node.  If the node has a vertical content-bias, then callers
 2938      * should pass in a height value that the minimum width should be based on.
 2939      * If the node has either a horizontal or null content-bias, then the caller
 2940      * should pass in -1.
 2941      * &lt;p&gt;
 2942      * Node subclasses with a vertical content-bias should honor the height
 2943      * parameter whether -1 or a positive value.   All other subclasses may ignore
 2944      * the height parameter (which will likely be -1).
 2945      * &lt;p&gt;
 2946      * If Node&#39;s {@link #maxWidth(double)} is lower than this number,
 2947      * {@code minWidth} takes precedence. This means the Node should never be resized below {@code minWidth}.
 2948      *
 2949      * @see #isResizable()
 2950      * @see #getContentBias()
 2951      *
 2952      * @param height the height that should be used if minimum width depends on it
 2953      * @return the minimum width that the node should be resized to during layout.
 2954      *         The result will never be NaN, nor will it ever be negative.
 2955      */
 2956     public double minWidth(double height) {
 2957         return prefWidth(height);
 2958     }
 2959 
 2960     /**
 2961      * Returns the node&#39;s minimum height for use in layout calculations.
 2962      * If the node is resizable, its parent should not resize its height any
 2963      * smaller than this value.  If the node is not resizable, returns its
 2964      * layoutBounds height.
 2965      * &lt;p&gt;
 2966      * Layout code which calls this method should first check the content-bias
 2967      * of the node.  If the node has a horizontal content-bias, then callers
 2968      * should pass in a width value that the minimum height should be based on.
 2969      * If the node has either a vertical or null content-bias, then the caller
 2970      * should pass in -1.
 2971      * &lt;p&gt;
 2972      * Node subclasses with a horizontal content-bias should honor the width
 2973      * parameter whether -1 or a positive value.   All other subclasses may ignore
 2974      * the width parameter (which will likely be -1).
 2975      * &lt;p&gt;
 2976      * If Node&#39;s {@link #maxHeight(double)} is lower than this number,
 2977      * {@code minHeight} takes precedence. This means the Node should never be resized below {@code minHeight}.
 2978      *
 2979      * @see #isResizable()
 2980      * @see #getContentBias()
 2981      *
 2982      * @param width the width that should be used if minimum height depends on it
 2983      * @return the minimum height that the node should be resized to during layout
 2984      *         The result will never be NaN, nor will it ever be negative.
 2985      */
 2986     public double minHeight(double width) {
 2987         return prefHeight(width);
 2988     }
 2989 
 2990     /**
 2991      * Returns the node&#39;s preferred width for use in layout calculations.
 2992      * If the node is resizable, its parent should treat this value as the
 2993      * node&#39;s ideal width within its range.  If the node is not resizable,
 2994      * just returns its layoutBounds width, which should be treated as the rigid
 2995      * width of the node.
 2996      * &lt;p&gt;
 2997      * Layout code which calls this method should first check the content-bias
 2998      * of the node.  If the node has a vertical content-bias, then callers
 2999      * should pass in a height value that the preferred width should be based on.
 3000      * If the node has either a horizontal or null content-bias, then the caller
 3001      * should pass in -1.
 3002      * &lt;p&gt;
 3003      * Node subclasses with a vertical content-bias should honor the height
 3004      * parameter whether -1 or a positive value.   All other subclasses may ignore
 3005      * the height parameter (which will likely be -1).
 3006      *
 3007      * @see #isResizable()
 3008      * @see #getContentBias()
 3009      * @see #autosize()
 3010      *
 3011      * @param height the height that should be used if preferred width depends on it
 3012      * @return the preferred width that the node should be resized to during layout
 3013      *         The result will never be NaN, nor will it ever be negative.
 3014      */
 3015     public double prefWidth(double height) {
 3016         final double result = getLayoutBounds().getWidth();
 3017         return Double.isNaN(result) || result &lt; 0 ? 0 : result;
 3018     }
 3019 
 3020     /**
 3021      * Returns the node&#39;s preferred height for use in layout calculations.
 3022      * If the node is resizable, its parent should treat this value as the
 3023      * node&#39;s ideal height within its range.  If the node is not resizable,
 3024      * just returns its layoutBounds height, which should be treated as the rigid
 3025      * height of the node.
 3026      * &lt;p&gt;
 3027      * Layout code which calls this method should first check the content-bias
 3028      * of the node.  If the node has a horizontal content-bias, then callers
 3029      * should pass in a width value that the preferred height should be based on.
 3030      * If the node has either a vertical or null content-bias, then the caller
 3031      * should pass in -1.
 3032      * &lt;p&gt;
 3033      * Node subclasses with a horizontal content-bias should honor the height
 3034      * parameter whether -1 or a positive value.   All other subclasses may ignore
 3035      * the height parameter (which will likely be -1).
 3036      *
 3037      * @see #getContentBias()
 3038      * @see #autosize()
 3039      *
 3040      * @param width the width that should be used if preferred height depends on it
 3041      * @return the preferred height that the node should be resized to during layout
 3042      *         The result will never be NaN, nor will it ever be negative.
 3043      */
 3044     public double prefHeight(double width) {
 3045         final double result = getLayoutBounds().getHeight();
 3046         return Double.isNaN(result) || result &lt; 0 ? 0 : result;
 3047     }
 3048 
 3049     /**
 3050      * Returns the node&#39;s maximum width for use in layout calculations.
 3051      * If the node is resizable, its parent should not resize its width any
 3052      * larger than this value.  A value of Double.MAX_VALUE indicates the
 3053      * parent may expand the node&#39;s width beyond its preferred without limits.
 3054      * &lt;p&gt;
 3055      * If the node is not resizable, returns its layoutBounds width.
 3056      * &lt;p&gt;
 3057      * Layout code which calls this method should first check the content-bias
 3058      * of the node.  If the node has a vertical content-bias, then callers
 3059      * should pass in a height value that the maximum width should be based on.
 3060      * If the node has either a horizontal or null content-bias, then the caller
 3061      * should pass in -1.
 3062      * &lt;p&gt;
 3063      * Node subclasses with a vertical content-bias should honor the height
 3064      * parameter whether -1 or a positive value.   All other subclasses may ignore
 3065      * the height parameter (which will likely be -1).
 3066      * &lt;p&gt;
 3067      * If Node&#39;s {@link #minWidth(double)} is greater, it should take precedence
 3068      * over the {@code maxWidth}. This means the Node should never be resized below {@code minWidth}.
 3069      *
 3070      * @see #isResizable()
 3071      * @see #getContentBias()
 3072      *
 3073      * @param height the height that should be used if maximum width depends on it
 3074      * @return the maximum width that the node should be resized to during layout
 3075      *         The result will never be NaN, nor will it ever be negative.
 3076      */
 3077     public double maxWidth(double height) {
 3078         return prefWidth(height);
 3079     }
 3080 
 3081     /**
 3082      * Returns the node&#39;s maximum height for use in layout calculations.
 3083      * If the node is resizable, its parent should not resize its height any
 3084      * larger than this value.  A value of Double.MAX_VALUE indicates the
 3085      * parent may expand the node&#39;s height beyond its preferred without limits.
 3086      * &lt;p&gt;
 3087      * If the node is not resizable, returns its layoutBounds height.
 3088      * &lt;p&gt;
 3089      * Layout code which calls this method should first check the content-bias
 3090      * of the node.  If the node has a horizontal content-bias, then callers
 3091      * should pass in a width value that the maximum height should be based on.
 3092      * If the node has either a vertical or null content-bias, then the caller
 3093      * should pass in -1.
 3094      * &lt;p&gt;
 3095      * Node subclasses with a horizontal content-bias should honor the width
 3096      * parameter whether -1 or a positive value.   All other subclasses may ignore
 3097      * the width parameter (which will likely be -1).
 3098      * &lt;p&gt;
 3099      * If Node&#39;s {@link #minHeight(double)} is greater, it should take precedence
 3100      * over the {@code maxHeight}.  This means the Node should never be resized below {@code minHeight}.
 3101      *
 3102      * @see #isResizable()
 3103      * @see #getContentBias()
 3104      *
 3105      * @param width the width that should be used if maximum height depends on it
 3106      * @return the maximum height that the node should be resized to during layout
 3107      *         The result will never be NaN, nor will it ever be negative.
 3108      */
 3109     public double maxHeight(double width) {
 3110         return prefHeight(width);
 3111     }
 3112 
 3113     /**
 3114      * If the node is resizable, will set its layout bounds to the specified
 3115      * width and height.   If the node is not resizable, this method is a no-op.
 3116      * &lt;p&gt;
 3117      * This method should generally only be called by parent nodes from their
 3118      * layoutChildren() methods.   All Parent classes will automatically resize
 3119      * resizable children, so resizing done directly by the application will be
 3120      * overridden by the node&#39;s parent, unless the child is unmanaged.
 3121      * &lt;p&gt;
 3122      * Parents are responsible for ensuring the width and height values fall
 3123      * within the resizable node&#39;s preferred range.  The autosize() method may
 3124      * be used if the parent just needs to resize the node to its preferred size.
 3125      *
 3126      * @see #isResizable()
 3127      * @see #getContentBias()
 3128      * @see #autosize()
 3129      * @see #minWidth(double)
 3130      * @see #minHeight(double)
 3131      * @see #prefWidth(double)
 3132      * @see #prefHeight(double)
 3133      * @see #maxWidth(double)
 3134      * @see #maxHeight(double)
 3135      * @see #getLayoutBounds()
 3136      *
 3137      * @param width the target layout bounds width
 3138      * @param height the target layout bounds height
 3139      */
 3140     public void resize(double width, double height) {
 3141     }
 3142 
 3143     /**
 3144      * If the node is resizable, will set its layout bounds to its current preferred
 3145      * width and height. If the node is not resizable, this method is a no-op.
 3146      * &lt;p&gt;
 3147      * This method automatically queries the node&#39;s content-bias and if it&#39;s
 3148      * horizontal, will pass in the node&#39;s preferred width to get the preferred
 3149      * height; if vertical, will pass in the node&#39;s preferred height to get the width,
 3150      * and if null, will compute the preferred width/height independently.
 3151      * &lt;/p&gt;
 3152      *
 3153      * @see #isResizable()
 3154      * @see #getContentBias()
 3155      *
 3156      */
 3157     public final void autosize() {
 3158         if (isResizable()) {
 3159             Orientation contentBias = getContentBias();
 3160             double w, h;
 3161             if (contentBias == null) {
 3162                 w = boundedSize(prefWidth(-1), minWidth(-1), maxWidth(-1));
 3163                 h = boundedSize(prefHeight(-1), minHeight(-1), maxHeight(-1));
 3164             } else if (contentBias == Orientation.HORIZONTAL) {
 3165                 w = boundedSize(prefWidth(-1), minWidth(-1), maxWidth(-1));
 3166                 h = boundedSize(prefHeight(w), minHeight(w), maxHeight(w));
 3167             } else { // bias == VERTICAL
 3168                 h = boundedSize(prefHeight(-1), minHeight(-1), maxHeight(-1));
 3169                 w = boundedSize(prefWidth(h), minWidth(h), maxWidth(h));
 3170             }
 3171             resize(w,h);
 3172         }
 3173     }
 3174 
 3175     double boundedSize(double value, double min, double max) {
 3176         // if max &lt; value, return max
 3177         // if min &gt; value, return min
 3178         // if min &gt; max, return min
 3179         return Math.min(Math.max(value, min), Math.max(min,max));
 3180     }
 3181 
 3182     /**
 3183      * If the node is resizable, will set its layout bounds to the specified
 3184      * width and height.   If the node is not resizable, the resize step is skipped.
 3185      * &lt;p&gt;
 3186      * Once the node has been resized (if resizable) then sets the node&#39;s layoutX
 3187      * and layoutY translation properties in order to relocate it to x,y in the
 3188      * parent&#39;s coordinate space.
 3189      * &lt;p&gt;
 3190      * This method should generally only be called by parent nodes from their
 3191      * layoutChildren() methods.   All Parent classes will automatically resize
 3192      * resizable children, so resizing done directly by the application will be
 3193      * overridden by the node&#39;s parent, unless the child is unmanaged.
 3194      * &lt;p&gt;
 3195      * Parents are responsible for ensuring the width and height values fall
 3196      * within the resizable node&#39;s preferred range.  The autosize() and relocate()
 3197      * methods may be used if the parent just needs to resize the node to its
 3198      * preferred size and reposition it.
 3199      *
 3200      * @see #isResizable()
 3201      * @see #getContentBias()
 3202      * @see #autosize()
 3203      * @see #minWidth(double)
 3204      * @see #minHeight(double)
 3205      * @see #prefWidth(double)
 3206      * @see #prefHeight(double)
 3207      * @see #maxWidth(double)
 3208      * @see #maxHeight(double)
 3209      *
 3210      * @param x the target x coordinate location
 3211      * @param y the target y coordinate location
 3212      * @param width the target layout bounds width
 3213      * @param height the target layout bounds height
 3214      *
 3215      */
 3216     public void resizeRelocate(double x, double y, double width, double height) {
 3217         resize(width, height);
 3218         relocate(x,y);
 3219     }
 3220 
 3221     /**
 3222      * This is a special value that might be returned by {@link #getBaselineOffset()}.
 3223      * This means that the Parent (layout Pane) of this Node should use the height of this Node as a baseline.
 3224      */
 3225     public static final double BASELINE_OFFSET_SAME_AS_HEIGHT = Double.NEGATIVE_INFINITY;
 3226 
 3227     /**
 3228      * The &#39;alphabetic&#39; (or &#39;roman&#39;) baseline offset from the node&#39;s layoutBounds.minY location
 3229      * that should be used when this node is being vertically aligned by baseline with
 3230      * other nodes.  By default this returns {@link #BASELINE_OFFSET_SAME_AS_HEIGHT} for resizable Nodes
 3231      * and layoutBounds height for non-resizable.  Subclasses
 3232      * which contain text should override this method to return their actual text baseline offset.
 3233      *
 3234      * @return offset of text baseline from layoutBounds.minY for non-resizable Nodes or {@link #BASELINE_OFFSET_SAME_AS_HEIGHT} otherwise
 3235      */
 3236     public double getBaselineOffset() {
 3237         if (isResizable()) {
 3238             return BASELINE_OFFSET_SAME_AS_HEIGHT;
 3239         } else {
 3240             return getLayoutBounds().getHeight();
 3241         }
 3242     }
 3243 
 3244     /**
 3245      * Returns the area of this {@code Node} projected onto the
 3246      * physical screen in pixel units.
 3247      * @return the area of this {@code Node} projected onto the physical screen
 3248      * @since JavaFX 8.0
 3249      */
 3250     public double computeAreaInScreen() {
 3251         return doComputeAreaInScreen();
 3252     }
 3253 
 3254     /*
 3255      * Help application or utility to implement LOD support by returning the
 3256      * projected area of a Node in pixel unit. The projected area is not clipped.
 3257      *
 3258      * For perspective camera, this method first exams node&#39;s bounds against
 3259      * camera&#39;s clipping plane to cut off those out of viewing frustrum. After
 3260      * computing areaInScreen, it applies a tight viewing frustrum check using
 3261      * canonical view volume.
 3262      *
 3263      * The result of areaInScreen comes from the product of
 3264      * (projViewTx x localToSceneTransform x localBounds).
 3265      *
 3266      * Returns 0 for those fall outside viewing frustrum.
 3267      */
 3268     private double doComputeAreaInScreen() {
 3269         Scene tmpScene = getScene();
 3270         if (tmpScene != null) {
 3271             Bounds bounds = getBoundsInLocal();
 3272             Camera camera = tmpScene.getEffectiveCamera();
 3273             boolean isPerspective = camera instanceof PerspectiveCamera ? true : false;
 3274             Transform localToSceneTx = getLocalToSceneTransform();
 3275             Affine3D tempTx = TempState.getInstance().tempTx;
 3276             BaseBounds localBounds = new BoxBounds((float) bounds.getMinX(),
 3277                                                    (float) bounds.getMinY(),
 3278                                                    (float) bounds.getMinZ(),
 3279                                                    (float) bounds.getMaxX(),
 3280                                                    (float) bounds.getMaxY(),
 3281                                                    (float) bounds.getMaxZ());
 3282 
 3283             // NOTE: Viewing frustrum check on camera&#39;s clipping plane is now only
 3284             // for perspective camera.
 3285             // TODO: Need to hook up parallel camera&#39;s nearClip and farClip.
 3286             if (isPerspective) {
 3287                 Transform cameraL2STx = camera.getLocalToSceneTransform();
 3288 
 3289                 // If camera transform only contains translate, compare in scene
 3290                 // coordinate. Otherwise, compare in camera coordinate.
 3291                 if (cameraL2STx.getMxx() == 1.0
 3292                         &amp;&amp; cameraL2STx.getMxy() == 0.0
 3293                         &amp;&amp; cameraL2STx.getMxz() == 0.0
 3294                         &amp;&amp; cameraL2STx.getMyx() == 0.0
 3295                         &amp;&amp; cameraL2STx.getMyy() == 1.0
 3296                         &amp;&amp; cameraL2STx.getMyz() == 0.0
 3297                         &amp;&amp; cameraL2STx.getMzx() == 0.0
 3298                         &amp;&amp; cameraL2STx.getMzy() == 0.0
 3299                         &amp;&amp; cameraL2STx.getMzz() == 1.0) {
 3300 
 3301                     double minZ, maxZ;
 3302 
 3303                     // If node transform only contains translate, only convert
 3304                     // minZ and maxZ to scene coordinate. Otherwise, convert
 3305                     // node bounds to scene coordinate.
 3306                     if (localToSceneTx.getMxx() == 1.0
 3307                             &amp;&amp; localToSceneTx.getMxy() == 0.0
 3308                             &amp;&amp; localToSceneTx.getMxz() == 0.0
 3309                             &amp;&amp; localToSceneTx.getMyx() == 0.0
 3310                             &amp;&amp; localToSceneTx.getMyy() == 1.0
 3311                             &amp;&amp; localToSceneTx.getMyz() == 0.0
 3312                             &amp;&amp; localToSceneTx.getMzx() == 0.0
 3313                             &amp;&amp; localToSceneTx.getMzy() == 0.0
 3314                             &amp;&amp; localToSceneTx.getMzz() == 1.0) {
 3315 
 3316                         Vec3d tempV3D = TempState.getInstance().vec3d;
 3317                         tempV3D.set(0, 0, bounds.getMinZ());
 3318                         localToScene(tempV3D);
 3319                         minZ = tempV3D.z;
 3320 
 3321                         tempV3D.set(0, 0, bounds.getMaxZ());
 3322                         localToScene(tempV3D);
 3323                         maxZ = tempV3D.z;
 3324                     } else {
 3325                         Bounds nodeInSceneBounds = localToScene(bounds);
 3326                         minZ = nodeInSceneBounds.getMinZ();
 3327                         maxZ = nodeInSceneBounds.getMaxZ();
 3328                     }
 3329 
 3330                     if (minZ &gt; camera.getFarClipInScene()
 3331                             || maxZ &lt; camera.getNearClipInScene()) {
 3332                         return 0;
 3333                     }
 3334 
 3335                 } else {
 3336                     BaseBounds nodeInCameraBounds = new BoxBounds();
 3337 
 3338                     // We need to set tempTx to identity since it is a recycled transform.
 3339                     // This is because TransformHelper.apply() is a matrix concatenation operation.
 3340                     tempTx.setToIdentity();
 3341                     TransformHelper.apply(localToSceneTx, tempTx);
 3342 
 3343                     // Convert node from local coordinate to camera coordinate
 3344                     tempTx.preConcatenate(camera.getSceneToLocalTransform());
 3345                     tempTx.transform(localBounds, nodeInCameraBounds);
 3346 
 3347                     // Compare in camera coordinate
 3348                     if (nodeInCameraBounds.getMinZ() &gt; camera.getFarClip()
 3349                             || nodeInCameraBounds.getMaxZ() &lt; camera.getNearClip()) {
 3350                         return 0;
 3351                     }
 3352                 }
 3353             }
 3354 
 3355             GeneralTransform3D projViewTx = TempState.getInstance().projViewTx;
 3356             projViewTx.set(camera.getProjViewTransform());
 3357 
 3358             // We need to set tempTx to identity since it is a recycled transform.
 3359             // This is because TransformHelper.apply() is a matrix concatenation operation.
 3360             tempTx.setToIdentity();
 3361             TransformHelper.apply(localToSceneTx, tempTx);
 3362 
 3363             // The product of projViewTx * localToSceneTransform
 3364             GeneralTransform3D tx = projViewTx.mul(tempTx);
 3365 
 3366             // Transform localBounds to projected bounds
 3367             localBounds = tx.transform(localBounds, localBounds);
 3368             double area = localBounds.getWidth() * localBounds.getHeight();
 3369 
 3370             // Use canonical view volume to check whether object is outside the
 3371             // viewing frustrum
 3372             if (isPerspective) {
 3373                 localBounds.intersectWith(-1, -1, 0, 1, 1, 1);
 3374                 area = (localBounds.getWidth() &lt; 0 || localBounds.getHeight() &lt; 0) ? 0 : area;
 3375             }
 3376             return area * (camera.getViewWidth() / 2 * camera.getViewHeight() / 2);
 3377         }
 3378         return 0;
 3379     }
 3380 
 3381     /* *************************************************************************
 3382      *                                                                         *
 3383      * Bounds related APIs                                                     *
 3384      *                                                                         *
 3385      **************************************************************************/
 3386 
 3387     public final Bounds getBoundsInParent() {
 3388         return boundsInParentProperty().get();
 3389     }
 3390 
 3391     /**
 3392      * The rectangular bounds of this {@code Node} which include its transforms.
 3393      * {@code boundsInParent} is calculated by
 3394      * taking the local bounds (defined by {@link #boundsInLocalProperty boundsInLocal}) and applying
<a name="5" id="anc5"></a><span class="line-modified"> 3395      * the transform created by setting the following additional variables:</span>
 3396      * &lt;ol&gt;
 3397      * &lt;li&gt;{@link #getTransforms transforms} ObservableList&lt;/li&gt;
 3398      * &lt;li&gt;{@link #scaleXProperty scaleX}, {@link #scaleYProperty scaleY}, {@link #scaleZProperty scaleZ}&lt;/li&gt;
 3399      * &lt;li&gt;{@link #rotateProperty rotate}&lt;/li&gt;
<a name="6" id="anc6"></a><span class="line-modified"> 3400      * &lt;li&gt;{@link #layoutXProperty layoutX}, {@link #layoutYProperty layoutY} and</span>
<span class="line-modified"> 3401      * {@link #translateXProperty translateX}, {@link #translateYProperty translateY}, {@link #translateZProperty translateZ}&lt;/li&gt;</span>

 3402      * &lt;/ol&gt;
 3403      * &lt;p&gt;
 3404      * The resulting bounds will be conceptually in the coordinate space of the
 3405      * {@code Node}&#39;s parent, however the node need not have a parent to calculate
 3406      * these bounds.
 3407      * &lt;p&gt;
 3408      * Note that this method does not take the node&#39;s visibility into account;
 3409      * the computation is based on the geometry of this {@code Node} only.
 3410      * &lt;p&gt;
 3411      * This property will always have a non-null value.
 3412      * &lt;p&gt;
 3413      * Note that {@code boundsInParent} is automatically recomputed whenever the
 3414      * geometry of a node changes, or when any of the following the change:
 3415      * transforms {@code ObservableList}, any of the translate, layout or scale
 3416      * variables, or the rotate variable. For this reason, it is an error
 3417      * to bind any of these values in a node to an expression that depends upon
 3418      * this variable. For example, the x or y variables of a shape, or
 3419      * {@code translateX}, {@code translateY} should never be bound to
 3420      * {@code boundsInParent} for the purpose of positioning the node.
 3421      * @return the boundsInParent for this {@code Node}
 3422      */
 3423     public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInParentProperty() {
 3424         return getMiscProperties().boundsInParentProperty();
 3425     }
 3426 
 3427     private void invalidateBoundsInParent() {
 3428         if (miscProperties != null) {
 3429             miscProperties.invalidateBoundsInParent();
 3430         }
 3431     }
 3432 
 3433     public final Bounds getBoundsInLocal() {
 3434         return boundsInLocalProperty().get();
 3435     }
 3436 
 3437     /**
 3438      * The rectangular bounds of this {@code Node} in the node&#39;s
 3439      * untransformed local coordinate space.  For nodes that extend
 3440      * {@link javafx.scene.shape.Shape}, the local bounds will also include
 3441      * space required for a non-zero stroke that may fall outside the shape&#39;s
 3442      * geometry that is defined by position and size attributes.
 3443      * The local bounds will also include any clipping set with {@link #clipProperty clip}
 3444      * as well as effects set with {@link #effectProperty effect}.
 3445      *
 3446      * &lt;p&gt;
 3447      * Note that this method does not take the node&#39;s visibility into account;
 3448      * the computation is based on the geometry of this {@code Node} only.
 3449      * &lt;p&gt;
 3450      * This property will always have a non-null value.
 3451      * &lt;p&gt;
 3452      * Note that boundsInLocal is automatically recomputed whenever the
 3453      * geometry of a node changes. For this reason, it is an error to bind any
 3454      * of these values in a node to an expression that depends upon this variable.
 3455      * For example, the x or y variables of a shape should never be bound
 3456      * to boundsInLocal for the purpose of positioning the node.
 3457      * @return the boundsInLocal for this {@code Node}
 3458      */
 3459     public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInLocalProperty() {
 3460         return getMiscProperties().boundsInLocalProperty();
 3461     }
 3462 
 3463     private void invalidateBoundsInLocal() {
 3464         if (miscProperties != null) {
 3465             miscProperties.invalidateBoundsInLocal();
 3466         }
 3467     }
 3468 
 3469     /**
 3470      * The rectangular bounds that should be used for layout calculations for
 3471      * this node. {@code layoutBounds} may differ from the visual bounds
 3472      * of the node and is computed differently depending on the node type.
 3473      * &lt;p&gt;
 3474      * If the node type is resizable ({@link javafx.scene.layout.Region Region},
 3475      * {@link javafx.scene.control.Control Control}, or {@link javafx.scene.web.WebView WebView})
 3476      * then the layoutBounds will always be {@code 0,0 width x height}.
 3477      * If the node type is not resizable ({@link javafx.scene.shape.Shape Shape},
 3478      * {@link javafx.scene.text.Text Text}, or {@link Group}), then the {@code layoutBounds}
 3479      * are computed based on the node&#39;s geometric properties and does not include the
 3480      * node&#39;s clip, effect, or transforms.  See individual class documentation
 3481      * for details.
 3482      * &lt;p&gt;
 3483      * Note that the {@link #layoutXProperty layoutX}, {@link #layoutYProperty layoutY},
 3484      * {@link #translateXProperty translateX}, and {@link #translateYProperty translateY}
 3485      * variables are not included in the layoutBounds.
 3486      * This is important because layout code must first determine the current
 3487      * size and location of the node (using {@code layoutBounds}) and then set
 3488      * {@code layoutX} and {@code layoutY} to adjust the translation of the
 3489      * node so that it will have the desired layout position.
 3490      * &lt;p&gt;
 3491      * Because the computation of layoutBounds is often tied to a node&#39;s
 3492      * geometric variables, it is an error to bind any such variables to an
 3493      * expression that depends upon {@code layoutBounds}. For example, the
 3494      * x or y variables of a shape should never be bound to {@code layoutBounds}
 3495      * for the purpose of positioning the node.
 3496      * &lt;p&gt;
 3497      * Note that for 3D shapes, the layout bounds is actually a rectangular box
 3498      * with X, Y, and Z values, although only X and Y are used in layout calculations.
 3499      * &lt;p&gt;
 3500      * The {@code layoutBounds} will never be null.
 3501      *
 3502      */
 3503     private LazyBoundsProperty layoutBounds = new LazyBoundsProperty() {
 3504         @Override
 3505         protected Bounds computeBounds() {
 3506             return NodeHelper.computeLayoutBounds(Node.this);
 3507         }
 3508 
 3509         @Override
 3510         public Object getBean() {
 3511             return Node.this;
 3512         }
 3513 
 3514         @Override
 3515         public String getName() {
 3516             return &quot;layoutBounds&quot;;
 3517         }
 3518     };
 3519 
 3520     public final Bounds getLayoutBounds() {
 3521         return layoutBoundsProperty().get();
 3522     }
 3523 
 3524     public final ReadOnlyObjectProperty&lt;Bounds&gt; layoutBoundsProperty() {
 3525         return layoutBounds;
 3526     }
 3527 
 3528     /*
 3529      *                  Bounds And Transforms Computation
 3530      *
 3531      *  This section of the code is responsible for computing and caching
 3532      *  various bounds and transforms. For optimal performance and minimal
 3533      *  recomputation of bounds (which can be quite expensive), we cache
 3534      *  values on two different levels. We expose two public immutable
 3535      *  Bounds boundsInParent objects and boundsInLocal. Because they are
 3536      *  immutable and because they may change quite frequently (especially
 3537      *  in the case of a Parent whose children are animated), it is
 3538      *  important that the system does not rely on these variables, because
 3539      *  doing so would produce a large amount of garbage. Rather, these
 3540      *  variables are provided solely for the convenience of application
 3541      *  developers and, being lazily bound, should generally be created at
 3542      *  most once per frame.
 3543      *
 3544      *  The second level of caching are within local Bounds2D variables.
 3545      *  These variables, txBounds and geomBounds, are mutable and as such
 3546      *  can be cached and updated as frequently as necessary without creating
 3547      *  excessive garbage. However, since the computation of bounds is still
 3548      *  expensive, it is desirable to cache both the geometric bounds and
 3549      *  the &quot;complete&quot; transformed bounds (essentially, boundsInParent).
 3550      *  Cached txBounds is particularly useful when computing the geometric
 3551      *  bounds of a Parent since it would not require complete or partial
 3552      *  recomputation of each child.
 3553      *
 3554      *  Finally, we cache the complete transform for this node which converts
 3555      *  its coord system from local to parent coords. This is useful both for
 3556      *  minimizing bounds recomputations in the case of the geometry having
 3557      *  changed but the transform not having changed, and also because the tx
 3558      *  is required for several different computations (for example, it must
 3559      *  be computed once during state synchronization with the PG peer, and
 3560      *  must also be computed when the pivot point changes, and also when
 3561      *  deriving the txBounds of the Node).
 3562      *
 3563      *  As with any caching system, a subtle and non-trivial amount of code
 3564      *  is devoted to invalidating the bounds / transforms at appropriate
 3565      *  times and in appropriate places to make sure bounds / transforms
 3566      *  are recomputed at all necessary times.
 3567      *
 3568      *  There are three computeXXX functions. One is for computing the
 3569      *  boundsInParent, the second for computing boundsInLocal, and the
 3570      *  third for computing the default layout bounds (which, by default,
 3571      *  is based on the geometric bounds). These functions are all prefixed
 3572      *  with &quot;compute&quot; because they create and return new immutable
 3573      *  Bounds objects.
 3574      *
 3575      *  There are three getXXXBounds functions. One is for returning the
 3576      *  complete transformed bounds. The second is for returning the
 3577      *  local bounds. The last is for returning the geometric bounds. These
 3578      *  functions are all prefixed with &quot;get&quot; because they may well return
 3579      *  a cached value, or may actually compute the bounds if necessary. These
 3580      *  functions all have the same signature. They take a Bounds2D and
 3581      *  BaseTransform, and return a Bounds2D (the same as they took). These
 3582      *  functions essentially populate the supplied bounds2D with the
 3583      *  appropriate bounds information, leveraging cached bounds if possible.
 3584      *
 3585      *  There is a single NodeHelper.computeGeomBoundsImpl function which is abstract.
 3586      *  This must be implemented in each subclass, and is responsible for
 3587      *  computing the actual geometric bounds for the Node. For example, Parent
 3588      *  is written such that this function is the union of the transformed
 3589      *  bounds of each child. Rectangle is written such that this takes into
 3590      *  account the size and stroke. Text is written such that it is computed
 3591      *  based on the actual glyphs.
 3592      *
 3593      *  There are two updateXXX functions, updateGeomBounds and updateTxBounds.
 3594      *  These functions are for ensuring that geomBounds and txBounds are
 3595      *  valid. They only execute in the case of the cached value being invalid,
 3596      *  so the function call is very cheap in cases where the cached bounds
 3597      *  values are still valid.
 3598      */
 3599 
 3600     /**
 3601      * An affine transform that holds the computed local-to-parent transform.
 3602      * This is the concatenation of all transforms in this node, including all
 3603      * of the convenience transforms.
 3604      */
 3605     private BaseTransform localToParentTx = BaseTransform.IDENTITY_TRANSFORM;
 3606 
 3607     /**
 3608      * This flag is used to indicate that localToParentTx is dirty and needs
 3609      * to be recomputed.
 3610      */
 3611     private boolean transformDirty = true;
 3612 
 3613     /**
 3614      * The cached transformed bounds. This is never null, but is frequently set
 3615      * to be invalid whenever the bounds for the node have changed. These are
 3616      * &quot;complete&quot; bounds, that is, with transforms and effect and clip applied.
 3617      * Note that this is equivalent to boundsInParent
 3618      */
 3619     private BaseBounds txBounds = new RectBounds();
 3620 
 3621     /**
 3622      * The cached bounds. This is never null, but is frequently set to be
 3623      * invalid whenever the bounds for the node have changed. These are the
 3624      * &quot;content&quot; bounds, that is, without transforms or effects applied.
 3625      */
 3626     private BaseBounds geomBounds = new RectBounds();
 3627 
 3628     /**
 3629      * The cached local bounds (without transforms, with clip and effects).
 3630      * If there is neither clip nor effect
 3631      * local bounds are equal to geom bounds, so in this case we don&#39;t keep
 3632      * the extra instance and set null to this variable.
 3633      */
 3634     private BaseBounds localBounds = null;
 3635 
 3636     /**
 3637      * This special flag is used only by Parent to flag whether or not
 3638      * the *parent* has processed the fact that bounds have changed for this
 3639      * child Node. We need some way of flagging this on a per-node basis to
 3640      * enable the significant performance optimizations and fast paths that
 3641      * are in the Parent code.
 3642      * &lt;p&gt;
 3643      * To reduce confusion, although this variable is defined on Node, it
 3644      * really belongs to the Parent of the node and should *only* be modified
 3645      * by the parent.
 3646      */
 3647     boolean boundsChanged;
 3648 
 3649     /*
 3650      * Returns geometric bounds, but may be over-ridden by a subclass.
 3651      */
 3652     private Bounds doComputeLayoutBounds() {
 3653         BaseBounds tempBounds = TempState.getInstance().bounds;
 3654         tempBounds = getGeomBounds(tempBounds,
 3655                                    BaseTransform.IDENTITY_TRANSFORM);
 3656         return new BoundingBox(tempBounds.getMinX(),
 3657                                tempBounds.getMinY(),
 3658                                tempBounds.getMinZ(),
 3659                                tempBounds.getWidth(),
 3660                                tempBounds.getHeight(),
 3661                                tempBounds.getDepth());
 3662     }
 3663 
 3664     /*
 3665      * Subclasses may customize the layoutBounds by means of overriding the
 3666      * NodeHelper.computeLayoutBoundsImpl method. If the layout bounds need to be
 3667      * recomputed, the subclass must notify the Node implementation of this
 3668      * fact so that appropriate notifications and internal state can be
 3669      * kept in sync. Subclasses must call NodeHelper.layoutBoundsChanged to
 3670      * let Node know that the layout bounds are invalid and need to be
 3671      * recomputed.
 3672      */
 3673     final void layoutBoundsChanged() {
 3674         if (!layoutBounds.valid) {
 3675             return;
 3676         }
 3677         layoutBounds.invalidate();
 3678         if ((nodeTransformation != null &amp;&amp; nodeTransformation.hasScaleOrRotate()) || hasMirroring()) {
 3679             // if either the scale or rotate convenience variables are used,
 3680             // then we need a valid pivot point. Since the layoutBounds
 3681             // affects the pivot we need to invalidate the transform
 3682             NodeHelper.transformsChanged(this);
 3683         }
 3684     }
 3685 
 3686     /**
 3687      * Loads the given bounds object with the transformed bounds relative to,
 3688      * and based on, the given transform. That is, this is the local bounds
 3689      * with the local-to-parent transform applied.
 3690      *
 3691      * We *never* pass null in as a bounds. This method will
 3692      * NOT take a null bounds object. The returned value may be
 3693      * the same bounds object passed in, or it may be a new object.
 3694      * The reason for this object promotion is in the case of needing
 3695      * to promote from a RectBounds to a BoxBounds (3D).
 3696      */
 3697     BaseBounds getTransformedBounds(BaseBounds bounds, BaseTransform tx) {
 3698         updateLocalToParentTransform();
 3699         if (tx.isTranslateOrIdentity()) {
 3700             updateTxBounds();
 3701             bounds = bounds.deriveWithNewBounds(txBounds);
 3702             if (!tx.isIdentity()) {
 3703                 final double translateX = tx.getMxt();
 3704                 final double translateY = tx.getMyt();
 3705                 final double translateZ = tx.getMzt();
 3706                 bounds = bounds.deriveWithNewBounds(
 3707                                     (float) (bounds.getMinX() + translateX),
 3708                                     (float) (bounds.getMinY() + translateY),
 3709                                     (float) (bounds.getMinZ() + translateZ),
 3710                                     (float) (bounds.getMaxX() + translateX),
 3711                                     (float) (bounds.getMaxY() + translateY),
 3712                                     (float) (bounds.getMaxZ() + translateZ));
 3713             }
 3714             return bounds;
 3715         } else if (localToParentTx.isIdentity()) {
 3716             return getLocalBounds(bounds, tx);
 3717         } else {
 3718             double mxx = tx.getMxx();
 3719             double mxy = tx.getMxy();
 3720             double mxz = tx.getMxz();
 3721             double mxt = tx.getMxt();
 3722             double myx = tx.getMyx();
 3723             double myy = tx.getMyy();
 3724             double myz = tx.getMyz();
 3725             double myt = tx.getMyt();
 3726             double mzx = tx.getMzx();
 3727             double mzy = tx.getMzy();
 3728             double mzz = tx.getMzz();
 3729             double mzt = tx.getMzt();
 3730             BaseTransform boundsTx = tx.deriveWithConcatenation(localToParentTx);
 3731             bounds = getLocalBounds(bounds, boundsTx);
 3732             if (boundsTx == tx) {
 3733                 tx.restoreTransform(mxx, mxy, mxz, mxt,
 3734                                     myx, myy, myz, myt,
 3735                                     mzx, mzy, mzz, mzt);
 3736             }
 3737             return bounds;
 3738         }
 3739     }
 3740 
 3741     /**
 3742      * Loads the given bounds object with the local bounds relative to,
 3743      * and based on, the given transform. That is, these are the geometric
 3744      * bounds + clip and effect.
 3745      *
 3746      * We *never* pass null in as a bounds. This method will
 3747      * NOT take a null bounds object. The returned value may be
 3748      * the same bounds object passed in, or it may be a new object.
 3749      * The reason for this object promotion is in the case of needing
 3750      * to promote from a RectBounds to a BoxBounds (3D).
 3751      */
 3752     BaseBounds getLocalBounds(BaseBounds bounds, BaseTransform tx) {
 3753         if (getEffect() == null &amp;&amp; getClip() == null) {
 3754             return getGeomBounds(bounds, tx);
 3755         }
 3756 
 3757         if (tx.isTranslateOrIdentity()) {
 3758             // we can take a fast path since we know tx is either a simple
 3759             // translation or is identity
 3760             updateLocalBounds();
 3761             bounds = bounds.deriveWithNewBounds(localBounds);
 3762             if (!tx.isIdentity()) {
 3763                 double translateX = tx.getMxt();
 3764                 double translateY = tx.getMyt();
 3765                 double translateZ = tx.getMzt();
 3766                 bounds = bounds.deriveWithNewBounds((float) (bounds.getMinX() + translateX),
 3767                         (float) (bounds.getMinY() + translateY),
 3768                         (float) (bounds.getMinZ() + translateZ),
 3769                         (float) (bounds.getMaxX() + translateX),
 3770                         (float) (bounds.getMaxY() + translateY),
 3771                         (float) (bounds.getMaxZ() + translateZ));
 3772             }
 3773             return bounds;
 3774         } else if (tx.is2D()
 3775                 &amp;&amp; (tx.getType()
 3776                 &amp; ~(BaseTransform.TYPE_UNIFORM_SCALE | BaseTransform.TYPE_TRANSLATION
 3777                 | BaseTransform.TYPE_FLIP | BaseTransform.TYPE_QUADRANT_ROTATION)) != 0) {
 3778             // this is a non-uniform scale / non-quadrant rotate / skew transform
 3779             return computeLocalBounds(bounds, tx);
 3780         } else {
 3781             // 3D transformations and
 3782             // selected 2D transformations (uniform transform, flip, quadrant rotation).
 3783             // These 2D transformation will yield tight bounds when applied on the pre-computed
 3784             // geomBounds
 3785             // Note: Transforming the local bounds into a 3D space will yield a bounds
 3786             // that isn&#39;t as tight as transforming its geometry and compute it bounds.
 3787             updateLocalBounds();
 3788             return tx.transform(localBounds, bounds);
 3789         }
 3790     }
 3791 
 3792     /**
 3793      * Loads the given bounds object with the geometric bounds relative to,
 3794      * and based on, the given transform.
 3795      *
 3796      * We *never* pass null in as a bounds. This method will
 3797      * NOT take a null bounds object. The returned value may be
 3798      * the same bounds object passed in, or it may be a new object.
 3799      * The reason for this object promotion is in the case of needing
 3800      * to promote from a RectBounds to a BoxBounds (3D).
 3801      */
 3802     BaseBounds getGeomBounds(BaseBounds bounds, BaseTransform tx) {
 3803         if (tx.isTranslateOrIdentity()) {
 3804             // we can take a fast path since we know tx is either a simple
 3805             // translation or is identity
 3806             updateGeomBounds();
 3807             bounds = bounds.deriveWithNewBounds(geomBounds);
 3808             if (!tx.isIdentity()) {
 3809                 double translateX = tx.getMxt();
 3810                 double translateY = tx.getMyt();
 3811                 double translateZ = tx.getMzt();
 3812                 bounds = bounds.deriveWithNewBounds((float) (bounds.getMinX() + translateX),
 3813                         (float) (bounds.getMinY() + translateY),
 3814                         (float) (bounds.getMinZ() + translateZ),
 3815                         (float) (bounds.getMaxX() + translateX),
 3816                         (float) (bounds.getMaxY() + translateY),
 3817                         (float) (bounds.getMaxZ() + translateZ));
 3818             }
 3819             return bounds;
 3820         } else if (tx.is2D()
 3821                 &amp;&amp; (tx.getType()
 3822                 &amp; ~(BaseTransform.TYPE_UNIFORM_SCALE | BaseTransform.TYPE_TRANSLATION
 3823                 | BaseTransform.TYPE_FLIP | BaseTransform.TYPE_QUADRANT_ROTATION)) != 0) {
 3824             // this is a non-uniform scale / non-quadrant rotate / skew transform
 3825             return NodeHelper.computeGeomBounds(this, bounds, tx);
 3826         } else {
 3827             // 3D transformations and
 3828             // selected 2D transformations (unifrom transform, flip, quadrant rotation).
 3829             // These 2D transformation will yield tight bounds when applied on the pre-computed
 3830             // geomBounds
 3831             // Note: Transforming the local geomBounds into a 3D space will yield a bounds
 3832             // that isn&#39;t as tight as transforming its geometry and compute it bounds.
 3833             updateGeomBounds();
 3834             return tx.transform(geomBounds, bounds);
 3835         }
 3836     }
 3837 
 3838     /**
 3839      * If necessary, recomputes the cached geom bounds. If the bounds are not
 3840      * invalid, then this method is a no-op.
 3841      */
 3842     void updateGeomBounds() {
 3843         if (geomBoundsInvalid) {
 3844             geomBounds = NodeHelper.computeGeomBounds(this, geomBounds, BaseTransform.IDENTITY_TRANSFORM);
 3845             geomBoundsInvalid = false;
 3846         }
 3847     }
 3848 
 3849     /**
 3850      * Computes the local bounds of this Node.
 3851      */
 3852     private BaseBounds computeLocalBounds(BaseBounds bounds, BaseTransform tx) {
 3853         // We either get the bounds of the effect (if it isn&#39;t null)
 3854         // or we get the geom bounds (if effect is null). We will then
 3855         // intersect this with the clip.
 3856         if (getEffect() != null) {
 3857             BaseBounds b = EffectHelper.getBounds(getEffect(), bounds, tx, this, boundsAccessor);
 3858             bounds = bounds.deriveWithNewBounds(b);
 3859         } else {
 3860             bounds = getGeomBounds(bounds, tx);
 3861         }
 3862         // intersect with the clip. Take care with &quot;bounds&quot; as it may
 3863         // actually be TEMP_BOUNDS, so we save off state
 3864         if (getClip() != null
 3865                 // FIXME: All 3D picking is currently ignored by rendering.
 3866                 // Until this is fixed or defined differently (RT-28510),
 3867                 // we follow this behavior.
 3868                 &amp;&amp; !(this instanceof Shape3D) &amp;&amp; !(getClip() instanceof Shape3D)) {
 3869             double x1 = bounds.getMinX();
 3870             double y1 = bounds.getMinY();
 3871             double x2 = bounds.getMaxX();
 3872             double y2 = bounds.getMaxY();
 3873             double z1 = bounds.getMinZ();
 3874             double z2 = bounds.getMaxZ();
 3875             bounds = getClip().getTransformedBounds(bounds, tx);
 3876             bounds.intersectWith((float)x1, (float)y1, (float)z1,
 3877                     (float)x2, (float)y2, (float)z2);
 3878         }
 3879         return bounds;
 3880     }
 3881 
 3882 
 3883     /**
 3884      * If necessary, recomputes the cached local bounds. If the bounds are not
 3885      * invalid, then this method is a no-op.
 3886      */
 3887     private void updateLocalBounds() {
 3888         if (localBoundsInvalid) {
 3889             if (getClip() != null || getEffect() != null) {
 3890                 localBounds = computeLocalBounds(
 3891                         localBounds == null ? new RectBounds() : localBounds,
 3892                         BaseTransform.IDENTITY_TRANSFORM);
 3893             } else {
 3894                 localBounds = null;
 3895             }
 3896             localBoundsInvalid = false;
 3897         }
 3898     }
 3899 
 3900     /**
 3901      * If necessary, recomputes the cached transformed bounds.
 3902      * If the cached transformed bounds are not invalid, then
 3903      * this method is a no-op.
 3904      */
 3905     void updateTxBounds() {
 3906         if (txBoundsInvalid) {
 3907             updateLocalToParentTransform();
 3908             txBounds = getLocalBounds(txBounds, localToParentTx);
 3909             txBoundsInvalid = false;
 3910         }
 3911     }
 3912 
 3913     /*
 3914      *                   Bounds Invalidation And Notification
 3915      *
 3916      *  The goal of this section is to efficiently propagate bounds
 3917      *  invalidation through the scenegraph while also being semantically
 3918      *  correct.
 3919      *
 3920      *  The code path for invalidation of layout bounds is somewhat confusing
 3921      *  primarily due to performance enhancements and the desire to reduce the
 3922      *  number of requestLayout() calls that are performed when layout bounds
 3923      *  change. Before diving into layout bounds, I will first describe how
 3924      *  normal bounds invalidation occurs.
 3925      *
 3926      *  When a node&#39;s geometry changes (for example, if the width of a
 3927      *  Rectangle is changed) then the Node must call NodeHelper.geomChanged().
 3928      *  Invoking this function will eventually clear all cached bounds and
 3929      *  notify to each parent up the tree that their bounds may have changed.
 3930      *
 3931      *  After invalidating geomBounds (and after kicking off layout bounds
 3932      *  notification), NodeHelper.geomChanged calls localBoundsChanged(). It should
 3933      *  be noted that NodeHelper.geomChanged should only be called when the geometry
 3934      *  of the node has changed such that it may result in the geom bounds
 3935      *  actually changing.
 3936      *
 3937      *  localBoundsChanged() simply invalidates boundsInLocal and then calls
 3938      *  transformedBoundsChanged().
 3939      *
 3940      *  transformedBoundsChanged() is responsible for invalidating
 3941      *  boundsInParent and txBounds. If the Node is not visible, then there is
 3942      *  no need to notify the parent of the bounds change because the parent&#39;s
 3943      *  bounds do not include invisible nodes. If the node is visible, then
 3944      *  it must tell the parent that this child node&#39;s bounds have changed.
 3945      *  It is up to the parent to eventually invoke its own NodeHelper.geomChanged
 3946      *  function. If instead of a parent this node has a clipParent, then the
 3947      *  clipParent&#39;s localBoundsChanged() is called instead.
 3948      *
 3949      *  There are a few other ways in which we enter the invalidate steps
 3950      *  beyond just the geometry changes. If the visibility of a Node changes,
 3951      *  its own bounds are not affected but its parent&#39;s bounds are. So a
 3952      *  special call to parent.childVisibilityChanged is made so the parent
 3953      *  can react accordingly.
 3954      *
 3955      *  If a transform is changed (layoutX, layoutY, rotate, transforms, etc)
 3956      *  then the transform must be invalidated. When a transform is invalidated,
 3957      *  it must also invalidate the txBounds by invoking
 3958      *  transformedBoundsChanged, which will in turn notify the parent as
 3959      *  before.
 3960      *
 3961      *  If an effect is changed or replaced then the local bounds must be
 3962      *  invalidated, as well as the transformedBounds and the parent notified
 3963      *  of the change in bounds.
 3964      *
 3965      *  layoutBound is somewhat unique in that it can be redefined in
 3966      *  subclasses. By default, the layoutBounds is the geomBounds, and so
 3967      *  whenever the geomBounds() function is called the layoutBounds
 3968      *  must be invalidated. However in subclasses, especially Resizables,
 3969      *  the layout bounds may not be defined to be the same as the geometric
 3970      *  bounds. This is both useful and provides a very nice performance
 3971      *  optimization for regions and controls. In this case, subclasses
 3972      *  need some way to interpose themselves such that a call to
 3973      *  NodeHelper.geomChanged() *does not* invalidate the layout bounds.
 3974      *
 3975      *  This interposition happens by providing the
 3976      *  NodeHelper.notifyLayoutBoundsChanged function. The default implementation
 3977      *  simply invalidates boundsInLocal. Subclasses (such as Region and
 3978      *  Control) can override this function so that it does not invalidate
 3979      *  the layout bounds.
 3980      *
 3981      *  An on invalidate trigger on layoutBounds handles kicking off the rest
 3982      *  of the invalidate process for layoutBounds. Because the layout bounds
 3983      *  define the pivot point, if scaleX, scaleY, or rotate contain
 3984      *  non-identity values then whenever the layoutBounds change the
 3985      *  transformed bounds also change. Finally, if this node&#39;s parent is
 3986      *  a Region and if the Node is being managed by the Region, then
 3987      *  we must call requestLayout on the Region whenever the layout bounds
 3988      *  have changed.
 3989      */
 3990 
 3991     /*
 3992      * Invoked by subclasses whenever their geometric bounds have changed.
 3993      * Because the default layout bounds is based on the node geometry, this
 3994      * function will invoke NodeHelper.notifyLayoutBoundsChanged. The default
 3995      * implementation of NodeHelper.notifyLayoutBoundsChanged() will simply invalidate
 3996      * layoutBounds. Resizable subclasses will want to override this function
 3997      * in most cases to be a no-op.
 3998      *
 3999      * This function will also invalidate the cached geom bounds, and then
 4000      * invoke localBoundsChanged() which will eventually end up invoking a
 4001      * chain of functions up the tree to ensure that each parent of this
 4002      * Node is notified that its bounds may have also changed.
 4003      *
 4004      * This function should be treated as though it were final. It is not
 4005      * intended to be overridden by subclasses.
 4006      *
 4007      * Note: This method MUST only be called via its accessor method.
 4008      */
 4009     private void doGeomChanged() {
 4010         if (geomBoundsInvalid) {
 4011             // GeomBoundsInvalid is false when node geometry changed and
 4012             // the untransformed node bounds haven&#39;t been recalculated yet.
 4013             // Most of the time, the recalculation of layout and transformed
 4014             // node bounds don&#39;t require validation of untransformed bounds
 4015             // and so we can not skip the following notifications.
 4016             NodeHelper.notifyLayoutBoundsChanged(this);
 4017             transformedBoundsChanged();
 4018             return;
 4019         }
 4020         geomBounds.makeEmpty();
 4021         geomBoundsInvalid = true;
 4022         NodeHelper.markDirty(this, DirtyBits.NODE_BOUNDS);
 4023         NodeHelper.notifyLayoutBoundsChanged(this);
 4024         localBoundsChanged();
 4025     }
 4026 
 4027     private boolean geomBoundsInvalid = true;
 4028     private boolean localBoundsInvalid = true;
 4029     private boolean txBoundsInvalid = true;
 4030 
 4031     /**
 4032      * Responds to changes in the local bounds by invalidating boundsInLocal
 4033      * and notifying this node that its transformed bounds have changed.
 4034      */
 4035     void localBoundsChanged() {
 4036         localBoundsInvalid = true;
 4037         invalidateBoundsInLocal();
 4038         transformedBoundsChanged();
 4039     }
 4040 
 4041     /**
 4042      * Responds to changes in the transformed bounds by invalidating txBounds
 4043      * and boundsInParent. If this Node is not visible, then we have no need
 4044      * to walk further up the tree but can instead simply invalidate state.
 4045      * Otherwise, this function will notify parents (either the parent or the
 4046      * clipParent) that this child Node&#39;s bounds have changed.
 4047      */
 4048     void transformedBoundsChanged() {
 4049         if (!txBoundsInvalid) {
 4050             txBounds.makeEmpty();
 4051             txBoundsInvalid = true;
 4052             invalidateBoundsInParent();
 4053             NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORMED_BOUNDS);
 4054         }
 4055         if (isVisible()) {
 4056             notifyParentOfBoundsChange();
 4057         }
 4058     }
 4059 
 4060     /*
 4061      * Invoked by geomChanged(). Since layoutBounds is by default based
 4062      * on the geometric bounds, the default implementation of this function will
 4063      * invalidate the layoutBounds. Resizable Node subclasses generally base
 4064      * layoutBounds on the width/height instead of the geometric bounds, and so
 4065      * will generally want to override this function to be a no-op.
 4066      *
 4067      * Note: This method MUST only be called via its accessor method.
 4068      */
 4069     private void doNotifyLayoutBoundsChanged() {
 4070         layoutBoundsChanged();
 4071         // notify the parent
 4072         // Group instanceof check a little hoaky, but it allows us to disable
 4073         // unnecessary layout for the case of a non-resizable within a group
 4074         Parent p = getParent();
 4075 
 4076         // Need to propagate layout if parent isn&#39;t part of performing layout
 4077         if (isManaged() &amp;&amp; (p != null) &amp;&amp; !(p instanceof Group &amp;&amp; !isResizable())
 4078                 &amp;&amp; !p.isPerformingLayout()) {
 4079             // Force its parent to fix the layout since it is a managed child.
 4080             p.requestLayout(true);
 4081         }
 4082     }
 4083 
 4084     /**
 4085      * Notifies both the real parent and the clip parent (if they exist) that
 4086      * the bounds of the child has changed. Note that since FX doesn&#39;t throw
 4087      * NPE&#39;s, things actually are faster if we don&#39;t check twice for Null
 4088      * (we check once, the compiler checks again)
 4089      */
 4090     void notifyParentOfBoundsChange() {
 4091         // let the parent know which node has changed and the parent will
 4092         // deal with marking itself invalid correctly
 4093         Parent p = getParent();
 4094         if (p != null) {
 4095             p.childBoundsChanged(this);
 4096         }
 4097         // since the clip is used to compute the local bounds (and not the
 4098         // geom bounds), we just need to notify that local bounds on the
 4099         // clip parent have changed
 4100         if (clipParent != null) {
 4101             clipParent.localBoundsChanged();
 4102         }
 4103     }
 4104 
 4105     /***************************************************************************
 4106      *                                                                         *
 4107      * Geometry and coordinate system related APIs. For example, methods       *
 4108      * related to containment, intersection, coordinate space conversion, etc. *
 4109      *                                                                         *
 4110      **************************************************************************/
 4111 
 4112     /**
 4113      * Returns {@code true} if the given point (specified in the local
 4114      * coordinate space of this {@code Node}) is contained within the shape of
 4115      * this {@code Node}. Note that this method does not take visibility into
 4116      * account; the test is based on the geometry of this {@code Node} only.
 4117      * @param localX the x coordinate of the point in Node&#39;s space
 4118      * @param localY the y coordinate of the point in Node&#39;s space
 4119      * @return the result of contains for this {@code Node}
 4120      */
 4121     public boolean contains(double localX, double localY) {
 4122         if (containsBounds(localX, localY)) {
 4123             return (isPickOnBounds() || NodeHelper.computeContains(this, localX, localY));
 4124         }
 4125         return false;
 4126     }
 4127 
 4128     /*
 4129      * This method only does the contains check based on the bounds, clip and
 4130      * effect of this node, excluding its shape (or geometry).
 4131      *
 4132      * Returns true if the given point (specified in the local
 4133      * coordinate space of this {@code Node}) is contained within the bounds,
 4134      * clip and effect of this node.
 4135      */
 4136     private boolean containsBounds(double localX, double localY) {
 4137         final TempState tempState = TempState.getInstance();
 4138         BaseBounds tempBounds = tempState.bounds;
 4139 
 4140         // first, we do a quick test to see if the point is contained in
 4141         // our local bounds. If so, then we will go the next step and check
 4142         // the clip, effect, and geometry for containment.
 4143         tempBounds = getLocalBounds(tempBounds,
 4144                                     BaseTransform.IDENTITY_TRANSFORM);
 4145         if (tempBounds.contains((float)localX, (float)localY)) {
 4146             // if the clip is defined, then check it for containment, being
 4147             // sure to convert from this node&#39;s local coordinate system
 4148             // to the local coordinate system of the clip node
 4149             if (getClip() != null) {
 4150                 tempState.point.x = (float)localX;
 4151                 tempState.point.y = (float)localY;
 4152                 try {
 4153                     getClip().parentToLocal(tempState.point);
 4154                 } catch (NoninvertibleTransformException e) {
 4155                     return false;
 4156                 }
 4157                 if (!getClip().contains(tempState.point.x, tempState.point.y)) {
 4158                     return false;
 4159                 }
 4160             }
 4161             return true;
 4162         }
 4163         return false;
 4164     }
 4165 
 4166     /**
 4167      * Returns {@code true} if the given point (specified in the local
 4168      * coordinate space of this {@code Node}) is contained within the shape of
 4169      * this {@code Node}. Note that this method does not take visibility into
 4170      * account; the test is based on the geometry of this {@code Node} only.
 4171      * @param localPoint the 2D point in Node&#39;s space
 4172      * @return the result of contains for this {@code Node}
 4173      */
 4174     public boolean contains(Point2D localPoint) {
 4175         return contains(localPoint.getX(), localPoint.getY());
 4176     }
 4177 
 4178     /**
 4179      * Returns {@code true} if the given rectangle (specified in the local
 4180      * coordinate space of this {@code Node}) intersects the shape of this
 4181      * {@code Node}. Note that this method does not take visibility into
 4182      * account; the test is based on the geometry of this {@code Node} only.
 4183      * The default behavior of this function is simply to check if the
 4184      * given coordinates intersect with the local bounds.
 4185      * @param localX the x coordinate of a rectangle in Node&#39;s space
 4186      * @param localY the y coordinate of a rectangle in Node&#39;s space
 4187      * @param localWidth the width of a rectangle in Node&#39;s space
 4188      * @param localHeight the height of a rectangle in Node&#39;s space
 4189      * @return the result of intersects for this {@code Node}
 4190      */
 4191     public boolean intersects(double localX, double localY, double localWidth, double localHeight) {
 4192         BaseBounds tempBounds = TempState.getInstance().bounds;
 4193         tempBounds = getLocalBounds(tempBounds,
 4194                                     BaseTransform.IDENTITY_TRANSFORM);
 4195         return tempBounds.intersects((float)localX,
 4196                                      (float)localY,
 4197                                      (float)localWidth,
 4198                                      (float)localHeight);
 4199     }
 4200 
 4201     /**
 4202      * Returns {@code true} if the given bounds (specified in the local
 4203      * coordinate space of this {@code Node}) intersects the shape of this
 4204      * {@code Node}. Note that this method does not take visibility into
 4205      * account; the test is based on the geometry of this {@code Node} only.
 4206      * The default behavior of this function is simply to check if the
 4207      * given coordinates intersect with the local bounds.
 4208      * @param localBounds the bounds
 4209      * @return the result of intersects for this {@code Node}
 4210      */
 4211     public boolean intersects(Bounds localBounds) {
 4212         return intersects(localBounds.getMinX(), localBounds.getMinY(), localBounds.getWidth(), localBounds.getHeight());
 4213     }
 4214 
 4215     /**
 4216      * Transforms a point from the coordinate space of the {@link javafx.stage.Screen}
 4217      * into the local coordinate space of this {@code Node}.
 4218      * @param screenX x coordinate of a point on a Screen
 4219      * @param screenY y coordinate of a point on a Screen
 4220      * @return local Node&#39;s coordinates of the point or null if Node is not in a {@link Window}.
 4221      * Null is also returned if the transformation from local to Scene is not invertible.
 4222      * @since JavaFX 8.0
 4223      */
 4224     public Point2D screenToLocal(double screenX, double screenY) {
 4225         Scene scene = getScene();
 4226         if (scene == null) return null;
 4227         Window window = scene.getWindow();
 4228         if (window == null) return null;
 4229 
 4230         final com.sun.javafx.geom.Point2D tempPt =
 4231                 TempState.getInstance().point;
 4232 
 4233         tempPt.setLocation((float)(screenX - scene.getX() - window.getX()),
 4234                            (float)(screenY - scene.getY() - window.getY()));
 4235 
 4236         final SubScene subScene = getSubScene();
 4237         if (subScene != null) {
 4238             final Point2D ssCoord = SceneUtils.sceneToSubScenePlane(subScene,
 4239                     new Point2D(tempPt.x, tempPt.y));
 4240             if (ssCoord == null) {
 4241                 return null;
 4242             }
 4243             tempPt.setLocation((float) ssCoord.getX(), (float) ssCoord.getY());
 4244         }
 4245 
 4246         final Point3D ppIntersect =
 4247                 scene.getEffectiveCamera().pickProjectPlane(tempPt.x, tempPt.y);
 4248         tempPt.setLocation((float) ppIntersect.getX(), (float) ppIntersect.getY());
 4249 
 4250         try {
 4251             sceneToLocal(tempPt);
 4252         } catch (NoninvertibleTransformException e) {
 4253             return null;
 4254         }
 4255         return new Point2D(tempPt.x, tempPt.y);
 4256     }
 4257 
 4258     /**
 4259      * Transforms a point from the coordinate space of the {@link javafx.stage.Screen}
 4260      * into the local coordinate space of this {@code Node}.
 4261      * @param screenPoint a point on a Screen
 4262      * @return local Node&#39;s coordinates of the point or null if Node is not in a {@link Window}.
 4263      * Null is also returned if the transformation from local to Scene is not invertible.
 4264      * @since JavaFX 8.0
 4265      */
 4266     public Point2D screenToLocal(Point2D screenPoint) {
 4267         return screenToLocal(screenPoint.getX(), screenPoint.getY());
 4268     }
 4269 
 4270     /**
 4271      * Transforms a rectangle from the coordinate space of the
 4272      * {@link javafx.stage.Screen} into the local coordinate space of this
 4273      * {@code Node}. Returns reasonable result only in 2D space.
 4274      * @param screenBounds bounds on a Screen
 4275      * @return bounds in the local Node&#39;space or null if Node is not in a {@link Window}.
 4276      * Null is also returned if the transformation from local to Scene is not invertible.
 4277      * @since JavaFX 8.0
 4278      */
 4279     public Bounds screenToLocal(Bounds screenBounds) {
 4280         final Point2D p1 = screenToLocal(screenBounds.getMinX(), screenBounds.getMinY());
 4281         final Point2D p2 = screenToLocal(screenBounds.getMinX(), screenBounds.getMaxY());
 4282         final Point2D p3 = screenToLocal(screenBounds.getMaxX(), screenBounds.getMinY());
 4283         final Point2D p4 = screenToLocal(screenBounds.getMaxX(), screenBounds.getMaxY());
 4284 
 4285         return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
 4286     }
 4287 
 4288 
 4289     /**
 4290      * Transforms a point from the coordinate space of the scene
 4291      * into the local coordinate space of this {@code Node}.
 4292      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4293      * arguments are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4294      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4295      * {@link #sceneToLocal(double, double)}.
 4296      *
 4297      * @param x the x coordinate
 4298      * @param y the y coordinate
 4299      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4300      * @return local coordinates of the point
 4301      * @since JavaFX 8u40
 4302      */
 4303     public Point2D sceneToLocal(double x, double y, boolean rootScene) {
 4304         if (!rootScene) {
 4305             return sceneToLocal(x, y);
 4306         }
 4307         final com.sun.javafx.geom.Point2D tempPt =
 4308                 TempState.getInstance().point;
 4309 
 4310         tempPt.setLocation((float)(x), (float)y);
 4311 
 4312         final SubScene subScene = getSubScene();
 4313         if (subScene != null) {
 4314             final Point2D ssCoord = SceneUtils.sceneToSubScenePlane(subScene,
 4315                     new Point2D(tempPt.x, tempPt.y));
 4316             if (ssCoord == null) {
 4317                 return null;
 4318             }
 4319             tempPt.setLocation((float) ssCoord.getX(), (float) ssCoord.getY());
 4320         }
 4321 
 4322         try {
 4323             sceneToLocal(tempPt);
 4324             return new Point2D(tempPt.x, tempPt.y);
 4325         } catch (NoninvertibleTransformException e) {
 4326             return null;
 4327         }
 4328     }
 4329 
 4330     /**
 4331      * Transforms a point from the coordinate space of the scene
 4332      * into the local coordinate space of this {@code Node}.
 4333      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4334      * arguments are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4335      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4336      * {@link #sceneToLocal(javafx.geometry.Point2D)}.
 4337      *
 4338      * @param point the point
 4339      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4340      * @return local coordinates of the point
 4341      * @since JavaFX 8u40
 4342      */
 4343     public Point2D sceneToLocal(Point2D point, boolean rootScene) {
 4344         return sceneToLocal(point.getX(), point.getY(), rootScene);
 4345     }
 4346 
 4347     /**
 4348      * Transforms a bounds from the coordinate space of the scene
 4349      * into the local coordinate space of this {@code Node}.
 4350      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4351      * arguments are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4352      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4353      * {@link #sceneToLocal(javafx.geometry.Bounds)}.
 4354      * &lt;p&gt;
 4355      *     Since 3D bounds cannot be converted with {@code rootScene} set to {@code true}, trying to convert 3D bounds will yield {@code null}.
 4356      * &lt;/p&gt;
 4357      * @param bounds the bounds
 4358      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4359      * @return local coordinates of the bounds
 4360      * @since JavaFX 8u40
 4361      */
 4362     public Bounds sceneToLocal(Bounds bounds, boolean rootScene) {
 4363         if (!rootScene) {
 4364             return sceneToLocal(bounds);
 4365         }
 4366         if (bounds.getMinZ() != 0 || bounds.getMaxZ() != 0) {
 4367             return null;
 4368         }
 4369         final Point2D p1 = sceneToLocal(bounds.getMinX(), bounds.getMinY(), true);
 4370         final Point2D p2 = sceneToLocal(bounds.getMinX(), bounds.getMaxY(), true);
 4371         final Point2D p3 = sceneToLocal(bounds.getMaxX(), bounds.getMinY(), true);
 4372         final Point2D p4 = sceneToLocal(bounds.getMaxX(), bounds.getMaxY(), true);
 4373 
 4374         return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
 4375     }
 4376 
 4377     /**
 4378      * Transforms a point from the coordinate space of the scene
 4379      * into the local coordinate space of this {@code Node}.
 4380      *
 4381      * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
 4382      * not that of {@link javafx.scene.Scene}.
 4383      *
 4384      * @param sceneX x coordinate of a point on a Scene
 4385      * @param sceneY y coordinate of a point on a Scene
 4386      * @return local Node&#39;s coordinates of the point or null if Node is not in a {@link Window}.
 4387      * Null is also returned if the transformation from local to Scene is not invertible.
 4388      */
 4389     public Point2D sceneToLocal(double sceneX, double sceneY) {
 4390         final com.sun.javafx.geom.Point2D tempPt =
 4391                 TempState.getInstance().point;
 4392         tempPt.setLocation((float)sceneX, (float)sceneY);
 4393         try {
 4394             sceneToLocal(tempPt);
 4395         } catch (NoninvertibleTransformException e) {
 4396             return null;
 4397         }
 4398         return new Point2D(tempPt.x, tempPt.y);
 4399     }
 4400 
 4401     /**
 4402      * Transforms a point from the coordinate space of the scene
 4403      * into the local coordinate space of this {@code Node}.
 4404      *
 4405      * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
 4406      * not that of {@link javafx.scene.Scene}.
 4407      *
 4408      * @param scenePoint a point on a Scene
 4409      * @return local Node&#39;s coordinates of the point or null if Node is not in a {@link Window}.
 4410      * Null is also returned if the transformation from local to Scene is not invertible.
 4411      */
 4412     public Point2D sceneToLocal(Point2D scenePoint) {
 4413         return sceneToLocal(scenePoint.getX(), scenePoint.getY());
 4414     }
 4415 
 4416     /**
 4417      * Transforms a point from the coordinate space of the scene
 4418      * into the local coordinate space of this {@code Node}.
 4419      *
 4420      * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
 4421      * not that of {@link javafx.scene.Scene}.
 4422      *
 4423      * @param scenePoint a point on a Scene
 4424      * @return local Node&#39;s coordinates of the point or null if Node is not in a {@link Window}.
 4425      * Null is also returned if the transformation from local to Scene is not invertible.
 4426      * @since JavaFX 8.0
 4427      */
 4428     public Point3D sceneToLocal(Point3D scenePoint) {
 4429         return sceneToLocal(scenePoint.getX(), scenePoint.getY(), scenePoint.getZ());
 4430     }
 4431 
 4432     /**
 4433      * Transforms a point from the coordinate space of the scene
 4434      * into the local coordinate space of this {@code Node}.
 4435      *
 4436      * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
 4437      * not that of {@link javafx.scene.Scene}.
 4438      *
 4439      * @param sceneX x coordinate of a point on a Scene
 4440      * @param sceneY y coordinate of a point on a Scene
 4441      * @param sceneZ z coordinate of a point on a Scene
 4442      * @return local Node&#39;s coordinates of the point or null if Node is not in a {@link Window}.
 4443      * Null is also returned if the transformation from local to Scene is not invertible.
 4444      * @since JavaFX 8.0
 4445      */
 4446     public Point3D sceneToLocal(double sceneX, double sceneY, double sceneZ) {
 4447         try {
 4448             return sceneToLocal0(sceneX, sceneY, sceneZ);
 4449         } catch (NoninvertibleTransformException ex) {
 4450             return null;
 4451         }
 4452     }
 4453 
 4454     /**
 4455      * Internal method to transform a point from scene to local coordinates.
 4456      */
 4457     private Point3D sceneToLocal0(double x, double y, double z) throws NoninvertibleTransformException {
 4458         final com.sun.javafx.geom.Vec3d tempV3D =
 4459                 TempState.getInstance().vec3d;
 4460         tempV3D.set(x, y, z);
 4461         sceneToLocal(tempV3D);
 4462         return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
 4463     }
 4464 
 4465     /**
 4466      * Transforms a rectangle from the coordinate space of the
 4467      * scene into the local coordinate space of this
 4468      * {@code Node}.
 4469      *
 4470      * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
 4471      * not that of {@link javafx.scene.Scene}.
 4472      *
 4473      * @param sceneBounds bounds on a Scene
 4474      * @return bounds in the local Node&#39;space or null if Node is not in a {@link Window}.
 4475      * Null is also returned if the transformation from local to Scene is not invertible.
 4476      */
 4477     public Bounds sceneToLocal(Bounds sceneBounds) {
 4478         // Do a quick update of localToParentTransform so that we can determine
 4479         // if this tx is 2D transform
 4480         updateLocalToParentTransform();
 4481         if (localToParentTx.is2D() &amp;&amp; (sceneBounds.getMinZ() == 0) &amp;&amp; (sceneBounds.getMaxZ() == 0)) {
 4482             Point2D p1 = sceneToLocal(sceneBounds.getMinX(), sceneBounds.getMinY());
 4483             Point2D p2 = sceneToLocal(sceneBounds.getMaxX(), sceneBounds.getMinY());
 4484             Point2D p3 = sceneToLocal(sceneBounds.getMaxX(), sceneBounds.getMaxY());
 4485             Point2D p4 = sceneToLocal(sceneBounds.getMinX(), sceneBounds.getMaxY());
 4486 
 4487             return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
 4488         }
 4489         try {
 4490             Point3D p1 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMinY(), sceneBounds.getMinZ());
 4491             Point3D p2 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMinY(), sceneBounds.getMaxZ());
 4492             Point3D p3 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMaxY(), sceneBounds.getMinZ());
 4493             Point3D p4 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMaxY(), sceneBounds.getMaxZ());
 4494             Point3D p5 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMaxY(), sceneBounds.getMinZ());
 4495             Point3D p6 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMaxY(), sceneBounds.getMaxZ());
 4496             Point3D p7 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMinY(), sceneBounds.getMinZ());
 4497             Point3D p8 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMinY(), sceneBounds.getMaxZ());
 4498             return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
 4499         } catch (NoninvertibleTransformException e) {
 4500             return null;
 4501         }
 4502     }
 4503 
 4504     /**
 4505      * Transforms a point from the local coordinate space of this {@code Node}
 4506      * into the coordinate space of its {@link javafx.stage.Screen}.
 4507      * @param localX x coordinate of a point in Node&#39;s space
 4508      * @param localY y coordinate of a point in Node&#39;s space
 4509      * @return screen coordinates of the point or null if Node is not in a {@link Window}
 4510      * @since JavaFX 8.0
 4511      */
 4512     public Point2D localToScreen(double localX, double localY) {
 4513         return localToScreen(localX, localY, 0.0);
 4514     }
 4515 
 4516     /**
 4517      * Transforms a point from the local coordinate space of this {@code Node}
 4518      * into the coordinate space of its {@link javafx.stage.Screen}.
 4519      * @param localPoint a point in Node&#39;s space
 4520      * @return screen coordinates of the point or null if Node is not in a {@link Window}
 4521      * @since JavaFX 8.0
 4522      */
 4523     public Point2D localToScreen(Point2D localPoint) {
 4524         return localToScreen(localPoint.getX(), localPoint.getY());
 4525     }
 4526 
 4527     /**
 4528      * Transforms a point from the local coordinate space of this {@code Node}
 4529      * into the coordinate space of its {@link javafx.stage.Screen}.
 4530      * @param localX x coordinate of a point in Node&#39;s space
 4531      * @param localY y coordinate of a point in Node&#39;s space
 4532      * @param localZ z coordinate of a point in Node&#39;s space
 4533      * @return screen coordinates of the point or null if Node is not in a {@link Window}
 4534      * @since JavaFX 8.0
 4535      */
 4536     public Point2D localToScreen(double localX, double localY, double localZ) {
 4537         Scene scene = getScene();
 4538         if (scene == null) return null;
 4539         Window window = scene.getWindow();
 4540         if (window == null) return null;
 4541 
 4542         Point3D pt = localToScene(localX, localY, localZ);
 4543         final SubScene subScene = getSubScene();
 4544         if (subScene != null) {
 4545             pt = SceneUtils.subSceneToScene(subScene, pt);
 4546         }
 4547         final Point2D projection = CameraHelper.project(
 4548                 SceneHelper.getEffectiveCamera(getScene()), pt);
 4549 
 4550         return new Point2D(projection.getX() + scene.getX() + window.getX(),
 4551                            projection.getY() + scene.getY() + window.getY());
 4552     }
 4553 
 4554     /**
 4555      * Transforms a point from the local coordinate space of this {@code Node}
 4556      * into the coordinate space of its {@link javafx.stage.Screen}.
 4557      * @param localPoint a point in Node&#39;s space
 4558      * @return screen coordinates of the point or null if Node is not in a {@link Window}
 4559      * @since JavaFX 8.0
 4560      */
 4561     public Point2D localToScreen(Point3D localPoint) {
 4562         return localToScreen(localPoint.getX(), localPoint.getY(), localPoint.getZ());
 4563     }
 4564 
 4565     /**
 4566      * Transforms a bounds from the local coordinate space of this
 4567      * {@code Node} into the coordinate space of its {@link javafx.stage.Screen}.
 4568      * @param localBounds bounds in Node&#39;s space
 4569      * @return the bounds in screen coordinates or null if Node is not in a {@link Window}
 4570      * @since JavaFX 8.0
 4571      */
 4572     public Bounds localToScreen(Bounds localBounds) {
 4573         final Point2D p1 = localToScreen(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ());
 4574         final Point2D p2 = localToScreen(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ());
 4575         final Point2D p3 = localToScreen(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ());
 4576         final Point2D p4 = localToScreen(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ());
 4577         final Point2D p5 = localToScreen(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ());
 4578         final Point2D p6 = localToScreen(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ());
 4579         final Point2D p7 = localToScreen(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ());
 4580         final Point2D p8 = localToScreen(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ());
 4581 
 4582         return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
 4583     }
 4584 
 4585     /**
 4586      * Transforms a point from the local coordinate space of this {@code Node}
 4587      * into the coordinate space of its scene.
 4588      * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
 4589      * not that of {@link javafx.scene.Scene}.
 4590      * @param localX x coordinate of a point in Node&#39;s space
 4591      * @param localY y coordinate of a point in Node&#39;s space
 4592      * @return scene coordinates of the point or null if Node is not in a {@link Window}
 4593      */
 4594     public Point2D localToScene(double localX, double localY) {
 4595         final com.sun.javafx.geom.Point2D tempPt =
 4596                 TempState.getInstance().point;
 4597         tempPt.setLocation((float)localX, (float)localY);
 4598         localToScene(tempPt);
 4599         return new Point2D(tempPt.x, tempPt.y);
 4600     }
 4601 
 4602     /**
 4603      * Transforms a point from the local coordinate space of this {@code Node}
 4604      * into the coordinate space of its scene.
 4605      * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
 4606      * not that of {@link javafx.scene.Scene}.
 4607      * @param localPoint a point in Node&#39;s space
 4608      * @return scene coordinates of the point or null if Node is not in a {@link Window}
 4609      */
 4610     public Point2D localToScene(Point2D localPoint) {
 4611         return localToScene(localPoint.getX(), localPoint.getY());
 4612     }
 4613 
 4614     /**
 4615      * Transforms a point from the local coordinate space of this {@code Node}
 4616      * into the coordinate space of its scene.
 4617      * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
 4618      * not that of {@link javafx.scene.Scene}.
 4619      * @param localPoint a 3D point in Node&#39;s space
 4620      * @return the transformed 3D point in Scene&#39;s space
 4621      * @see #localToScene(javafx.geometry.Point3D, boolean)
 4622      * @since JavaFX 8.0
 4623      */
 4624     public Point3D localToScene(Point3D localPoint) {
 4625         return localToScene(localPoint.getX(), localPoint.getY(), localPoint.getZ());
 4626     }
 4627 
 4628     /**
 4629      * Transforms a point from the local coordinate space of this {@code Node}
 4630      * into the coordinate space of its scene.
 4631      * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
 4632      * not that of {@link javafx.scene.Scene}.
 4633      * @param x the x coordinate of a point in Node&#39;s space
 4634      * @param y the y coordinate of a point in Node&#39;s space
 4635      * @param z the z coordinate of a point in Node&#39;s space
 4636      * @return the transformed 3D point in Scene&#39;s space
 4637      * @see #localToScene(double, double, double, boolean)
 4638      * @since JavaFX 8.0
 4639      */
 4640     public Point3D localToScene(double x, double y, double z) {
 4641         final com.sun.javafx.geom.Vec3d tempV3D =
 4642                 TempState.getInstance().vec3d;
 4643         tempV3D.set(x, y, z);
 4644         localToScene(tempV3D);
 4645         return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
 4646     }
 4647 
 4648     /**
 4649      * Transforms a point from the local coordinate space of this {@code Node}
 4650      * into the coordinate space of its scene.
 4651      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4652      * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4653      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4654      * {@link #localToScene(javafx.geometry.Point3D)}.
 4655      *
 4656      * @param localPoint the point in local coordinates
 4657      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4658      * @return transformed point
 4659      *
 4660      * @see #localToScene(javafx.geometry.Point3D)
 4661      * @since JavaFX 8u40
 4662      */
 4663     public Point3D localToScene(Point3D localPoint, boolean rootScene) {
 4664         Point3D pt = localToScene(localPoint);
 4665         if (rootScene) {
 4666             final SubScene subScene = getSubScene();
 4667             if (subScene != null) {
 4668                 pt = SceneUtils.subSceneToScene(subScene, pt);
 4669             }
 4670         }
 4671         return pt;
 4672     }
 4673 
 4674     /**
 4675      * Transforms a point from the local coordinate space of this {@code Node}
 4676      * into the coordinate space of its scene.
 4677      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4678      * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4679      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4680      * {@link #localToScene(double, double, double)}.
 4681      *
 4682      * @param x the x coordinate of the point in local coordinates
 4683      * @param y the y coordinate of the point in local coordinates
 4684      * @param z the z coordinate of the point in local coordinates
 4685      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4686      * @return transformed point
 4687      *
 4688      * @see #localToScene(double, double, double)
 4689      * @since JavaFX 8u40
 4690      */
 4691     public Point3D localToScene(double x, double y, double z, boolean rootScene) {
 4692         return localToScene(new Point3D(x, y, z), rootScene);
 4693     }
 4694 
 4695     /**
 4696      * Transforms a point from the local coordinate space of this {@code Node}
 4697      * into the coordinate space of its scene.
 4698      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4699      * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4700      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4701      * {@link #localToScene(javafx.geometry.Point2D)}.
 4702      *
 4703      * @param localPoint the point in local coordinates
 4704      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4705      * @return transformed point
 4706      *
 4707      * @see #localToScene(javafx.geometry.Point2D)
 4708      * @since JavaFX 8u40
 4709      */
 4710     public Point2D localToScene(Point2D localPoint, boolean rootScene) {
 4711         if (!rootScene) {
 4712             return localToScene(localPoint);
 4713         }
 4714         Point3D pt = localToScene(localPoint.getX(), localPoint.getY(), 0, rootScene);
 4715         return new Point2D(pt.getX(), pt.getY());
 4716     }
 4717 
 4718     /**
 4719      * Transforms a point from the local coordinate space of this {@code Node}
 4720      * into the coordinate space of its scene.
 4721      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4722      * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4723      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4724      * {@link #localToScene(double, double)}.
 4725      *
 4726      * @param x the x coordinate of the point in local coordinates
 4727      * @param y the y coordinate of the point in local coordinates
 4728      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4729      * @return transformed point
 4730      *
 4731      * @see #localToScene(double, double)
 4732      * @since JavaFX 8u40
 4733      */
 4734     public Point2D localToScene(double x, double y, boolean rootScene) {
 4735         return localToScene(new Point2D(x, y), rootScene);
 4736     }
 4737 
 4738     /**
 4739      * Transforms a bounds from the local coordinate space of this {@code Node}
 4740      * into the coordinate space of its scene.
 4741      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4742      * result bounds are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4743      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4744      * {@link #localToScene(javafx.geometry.Bounds)}.
 4745      *
 4746      * @param localBounds the bounds in local coordinates
 4747      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4748      * @return transformed bounds
 4749      *
 4750      * @see #localToScene(javafx.geometry.Bounds)
 4751      * @since JavaFX 8u40
 4752      */
 4753     public Bounds localToScene(Bounds localBounds, boolean rootScene) {
 4754         if (!rootScene) {
 4755             return localToScene(localBounds);
 4756         }
 4757         Point3D p1 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ(), true);
 4758         Point3D p2 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ(), true);
 4759         Point3D p3 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ(), true);
 4760         Point3D p4 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ(), true);
 4761         Point3D p5 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ(), true);
 4762         Point3D p6 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ(), true);
 4763         Point3D p7 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ(), true);
 4764         Point3D p8 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ(), true);
 4765         return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
 4766     }
 4767 
 4768     /**
 4769      * Transforms a bounds from the local coordinate space of this
 4770      * {@code Node} into the coordinate space of its scene.
 4771      * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
 4772      * not that of {@link javafx.scene.Scene}.
 4773      * @param localBounds bounds in Node&#39;s space
 4774      * @return the bounds in the scene coordinates or null if Node is not in a {@link Window}
 4775      * @see #localToScene(javafx.geometry.Bounds, boolean)
 4776      */
 4777     public Bounds localToScene(Bounds localBounds) {
 4778         // Do a quick update of localToParentTransform so that we can determine
 4779         // if this tx is 2D transform
 4780         updateLocalToParentTransform();
 4781         if (localToParentTx.is2D() &amp;&amp; (localBounds.getMinZ() == 0) &amp;&amp; (localBounds.getMaxZ() == 0)) {
 4782             Point2D p1 = localToScene(localBounds.getMinX(), localBounds.getMinY());
 4783             Point2D p2 = localToScene(localBounds.getMaxX(), localBounds.getMinY());
 4784             Point2D p3 = localToScene(localBounds.getMaxX(), localBounds.getMaxY());
 4785             Point2D p4 = localToScene(localBounds.getMinX(), localBounds.getMaxY());
 4786 
 4787             return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
 4788         }
 4789         Point3D p1 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ());
 4790         Point3D p2 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ());
 4791         Point3D p3 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ());
 4792         Point3D p4 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ());
 4793         Point3D p5 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ());
 4794         Point3D p6 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ());
 4795         Point3D p7 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ());
 4796         Point3D p8 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ());
 4797         return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
 4798 
 4799     }
 4800 
 4801     /**
 4802      * Transforms a point from the coordinate space of the parent into the
 4803      * local coordinate space of this {@code Node}.
 4804      * @param parentX the x coordinate in Parent&#39;s space
 4805      * @param parentY the y coordinate in Parent&#39;s space
 4806      * @return the transformed 2D point in Node&#39;s space
 4807      */
 4808     public Point2D parentToLocal(double parentX, double parentY) {
 4809         final com.sun.javafx.geom.Point2D tempPt =
 4810                 TempState.getInstance().point;
 4811         tempPt.setLocation((float)parentX, (float)parentY);
 4812         try {
 4813             parentToLocal(tempPt);
 4814         } catch (NoninvertibleTransformException e) {
 4815             return null;
 4816         }
 4817         return new Point2D(tempPt.x, tempPt.y);
 4818     }
 4819 
 4820     /**
 4821      * Transforms a point from the coordinate space of the parent into the
 4822      * local coordinate space of this {@code Node}.
 4823      * @param parentPoint the 2D point in Parent&#39;s space
 4824      * @return the transformed 2D point in Node&#39;s space
 4825      */
 4826     public Point2D parentToLocal(Point2D parentPoint) {
 4827         return parentToLocal(parentPoint.getX(), parentPoint.getY());
 4828     }
 4829 
 4830     /**
 4831      * Transforms a point from the coordinate space of the parent into the
 4832      * local coordinate space of this {@code Node}.
 4833      * @param parentPoint parentPoint the 3D point in Parent&#39;s space
 4834      * @return the transformed 3D point in Node&#39;s space
 4835      * @since JavaFX 8.0
 4836      */
 4837     public Point3D parentToLocal(Point3D parentPoint) {
 4838         return parentToLocal(parentPoint.getX(), parentPoint.getY(), parentPoint.getZ());
 4839     }
 4840 
 4841     /**
 4842      * Transforms a point from the coordinate space of the parent into the
 4843      * local coordinate space of this {@code Node}.
 4844      * @param parentX the x coordinate in Parent&#39;s space
 4845      * @param parentY the y coordinate in Parent&#39;s space
 4846      * @param parentZ the z coordinate in Parent&#39;s space
 4847      * @return the transformed 3D point in Node&#39;s space
 4848      * @since JavaFX 8.0
 4849      */
 4850     public Point3D parentToLocal(double parentX, double parentY, double parentZ) {
 4851         final com.sun.javafx.geom.Vec3d tempV3D =
 4852                 TempState.getInstance().vec3d;
 4853         tempV3D.set(parentX, parentY, parentZ);
 4854         try {
 4855             parentToLocal(tempV3D);
 4856         } catch (NoninvertibleTransformException e) {
 4857             return null;
 4858         }
 4859         return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
 4860     }
 4861 
 4862     /**
 4863      * Transforms a rectangle from the coordinate space of the parent into the
 4864      * local coordinate space of this {@code Node}.
 4865      * @param parentBounds the bounds in Parent&#39;s space
 4866      * @return the transformed bounds in Node&#39;s space
 4867      */
 4868     public Bounds parentToLocal(Bounds parentBounds) {
 4869         // Do a quick update of localToParentTransform so that we can determine
 4870         // if this tx is 2D transform
 4871         updateLocalToParentTransform();
 4872         if (localToParentTx.is2D() &amp;&amp; (parentBounds.getMinZ() == 0) &amp;&amp; (parentBounds.getMaxZ() == 0)) {
 4873             Point2D p1 = parentToLocal(parentBounds.getMinX(), parentBounds.getMinY());
 4874             Point2D p2 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMinY());
 4875             Point2D p3 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMaxY());
 4876             Point2D p4 = parentToLocal(parentBounds.getMinX(), parentBounds.getMaxY());
 4877 
 4878             return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
 4879         }
 4880         Point3D p1 = parentToLocal(parentBounds.getMinX(), parentBounds.getMinY(), parentBounds.getMinZ());
 4881         Point3D p2 = parentToLocal(parentBounds.getMinX(), parentBounds.getMinY(), parentBounds.getMaxZ());
 4882         Point3D p3 = parentToLocal(parentBounds.getMinX(), parentBounds.getMaxY(), parentBounds.getMinZ());
 4883         Point3D p4 = parentToLocal(parentBounds.getMinX(), parentBounds.getMaxY(), parentBounds.getMaxZ());
 4884         Point3D p5 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMaxY(), parentBounds.getMinZ());
 4885         Point3D p6 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMaxY(), parentBounds.getMaxZ());
 4886         Point3D p7 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMinY(), parentBounds.getMinZ());
 4887         Point3D p8 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMinY(), parentBounds.getMaxZ());
 4888         return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
 4889     }
 4890 
 4891     /**
 4892      * Transforms a point from the local coordinate space of this {@code Node}
 4893      * into the coordinate space of its parent.
 4894      * @param localX the x coordinate of the point in Node&#39;s space
 4895      * @param localY the y coordinate of the point in Node&#39;s space
 4896      * @return the transformed 2D point in Parent&#39;s space
 4897      */
 4898     public Point2D localToParent(double localX, double localY) {
 4899         final com.sun.javafx.geom.Point2D tempPt =
 4900                 TempState.getInstance().point;
 4901         tempPt.setLocation((float)localX, (float)localY);
 4902         localToParent(tempPt);
 4903         return new Point2D(tempPt.x, tempPt.y);
 4904     }
 4905 
 4906     /**
 4907      * Transforms a point from the local coordinate space of this {@code Node}
 4908      * into the coordinate space of its parent.
 4909      * @param localPoint the 2D point in Node&#39;s space
 4910      * @return the transformed 2D point in Parent&#39;s space
 4911      */
 4912     public Point2D localToParent(Point2D localPoint) {
 4913         return localToParent(localPoint.getX(), localPoint.getY());
 4914     }
 4915 
 4916     /**
 4917      * Transforms a point from the local coordinate space of this {@code Node}
 4918      * into the coordinate space of its parent.
 4919      * @param localPoint the 3D point in Node&#39;s space
 4920      * @return the transformed 3D point in Parent&#39;s space
 4921      * @since JavaFX 8.0
 4922      */
 4923     public Point3D localToParent(Point3D localPoint) {
 4924         return localToParent(localPoint.getX(), localPoint.getY(), localPoint.getZ());
 4925     }
 4926 
 4927     /**
 4928      * Transforms a point from the local coordinate space of this {@code Node}
 4929      * into the coordinate space of its parent.
 4930      * @param x the x coordinate of the point in Node&#39;s space
 4931      * @param y the y coordinate of the point in Node&#39;s space
 4932      * @param z the z coordinate of the point in Node&#39;s space
 4933      * @return the transformed 3D point in Parent&#39;s space
 4934      * @since JavaFX 8.0
 4935      */
 4936     public Point3D localToParent(double x, double y, double z) {
 4937         final com.sun.javafx.geom.Vec3d tempV3D =
 4938                 TempState.getInstance().vec3d;
 4939         tempV3D.set(x, y, z);
 4940         localToParent(tempV3D);
 4941         return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
 4942     }
 4943 
 4944     /**
 4945      * Transforms a bounds from the local coordinate space of this
 4946      * {@code Node} into the coordinate space of its parent.
 4947      * @param localBounds the bounds in Node&#39;s space
 4948      * @return the transformed bounds in Parent&#39;s space
 4949      */
 4950     public Bounds localToParent(Bounds localBounds) {
 4951         // Do a quick update of localToParentTransform so that we can determine
 4952         // if this tx is 2D transform
 4953         updateLocalToParentTransform();
 4954         if (localToParentTx.is2D() &amp;&amp; (localBounds.getMinZ() == 0) &amp;&amp; (localBounds.getMaxZ() == 0)) {
 4955             Point2D p1 = localToParent(localBounds.getMinX(), localBounds.getMinY());
 4956             Point2D p2 = localToParent(localBounds.getMaxX(), localBounds.getMinY());
 4957             Point2D p3 = localToParent(localBounds.getMaxX(), localBounds.getMaxY());
 4958             Point2D p4 = localToParent(localBounds.getMinX(), localBounds.getMaxY());
 4959 
 4960             return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
 4961         }
 4962         Point3D p1 = localToParent(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ());
 4963         Point3D p2 = localToParent(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ());
 4964         Point3D p3 = localToParent(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ());
 4965         Point3D p4 = localToParent(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ());
 4966         Point3D p5 = localToParent(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ());
 4967         Point3D p6 = localToParent(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ());
 4968         Point3D p7 = localToParent(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ());
 4969         Point3D p8 = localToParent(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ());
 4970         return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
 4971     }
 4972 
 4973     /**
 4974      * Copy the localToParent transform into specified transform.
 4975      */
 4976     BaseTransform getLocalToParentTransform(BaseTransform tx) {
 4977         updateLocalToParentTransform();
 4978         tx.setTransform(localToParentTx);
 4979         return tx;
 4980     }
 4981 
 4982     /*
 4983      * Currently used only by PathTransition
 4984      */
 4985     final BaseTransform getLeafTransform() {
 4986         return getLocalToParentTransform(TempState.getInstance().leafTx);
 4987     }
 4988 
 4989     /*
 4990      * Invoked whenever the transforms[] ObservableList changes, or by the transforms
 4991      * in that ObservableList whenever they are changed.
 4992      *
 4993      * Note: This method MUST only be called via its accessor method.
 4994      */
 4995     private void doTransformsChanged() {
 4996         if (!transformDirty) {
 4997             NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORM);
 4998             transformDirty = true;
 4999             transformedBoundsChanged();
 5000         }
 5001         invalidateLocalToParentTransform();
 5002         invalidateLocalToSceneTransform();
 5003     }
 5004 
 5005     final double getPivotX() {
 5006         final Bounds bounds = getLayoutBounds();
 5007         return bounds.getMinX() + bounds.getWidth()/2;
 5008     }
 5009 
 5010     final double getPivotY() {
 5011         final Bounds bounds = getLayoutBounds();
 5012         return bounds.getMinY() + bounds.getHeight()/2;
 5013     }
 5014 
 5015     final double getPivotZ() {
 5016         final Bounds bounds = getLayoutBounds();
 5017         return bounds.getMinZ() + bounds.getDepth()/2;
 5018     }
 5019 
 5020     /**
 5021      * This helper function will update the transform matrix on the peer based
 5022      * on the &quot;complete&quot; transform for this node.
 5023      */
 5024     void updateLocalToParentTransform() {
 5025         if (transformDirty) {
 5026             localToParentTx.setToIdentity();
 5027 
 5028             boolean mirror = false;
 5029             double mirroringCenter = 0;
 5030             if (hasMirroring()) {
 5031                 final Scene sceneValue = getScene();
 5032                 if ((sceneValue != null) &amp;&amp; (sceneValue.getRoot() == this)) {
 5033                     // handle scene mirroring in this branch
 5034                     // (must be the last transformation)
 5035                     mirroringCenter = sceneValue.getWidth() / 2;
 5036                     if (mirroringCenter == 0.0) {
 5037                         mirroringCenter = getPivotX();
 5038                     }
 5039 
 5040                     localToParentTx = localToParentTx.deriveWithTranslation(
 5041                             mirroringCenter, 0.0);
 5042                     localToParentTx = localToParentTx.deriveWithScale(
 5043                             -1.0, 1.0, 1.0);
 5044                     localToParentTx = localToParentTx.deriveWithTranslation(
 5045                             -mirroringCenter, 0.0);
 5046                 } else {
 5047                     // mirror later
 5048                     mirror = true;
 5049                     mirroringCenter = getPivotX();
 5050                 }
 5051             }
 5052 
 5053             if (getScaleX() != 1 || getScaleY() != 1 || getScaleZ() != 1 || getRotate() != 0) {
 5054                 // recompute pivotX, pivotY and pivotZ
 5055                 double pivotX = getPivotX();
 5056                 double pivotY = getPivotY();
 5057                 double pivotZ = getPivotZ();
 5058 
 5059                 localToParentTx = localToParentTx.deriveWithTranslation(
 5060                         getTranslateX() + getLayoutX() + pivotX,
 5061                         getTranslateY() + getLayoutY() + pivotY,
 5062                         getTranslateZ() + pivotZ);
 5063                 localToParentTx = localToParentTx.deriveWithRotation(
 5064                         Math.toRadians(getRotate()), getRotationAxis().getX(),
 5065                         getRotationAxis().getY(), getRotationAxis().getZ());
 5066                 localToParentTx = localToParentTx.deriveWithScale(
 5067                         getScaleX(), getScaleY(), getScaleZ());
 5068                 localToParentTx = localToParentTx.deriveWithTranslation(
 5069                         -pivotX, -pivotY, -pivotZ);
 5070             } else {
 5071                 localToParentTx = localToParentTx.deriveWithTranslation(
 5072                         getTranslateX() + getLayoutX(),
 5073                         getTranslateY() + getLayoutY(),
 5074                         getTranslateZ());
 5075             }
 5076 
 5077             if (hasTransforms()) {
 5078                 for (Transform t : getTransforms()) {
 5079                     localToParentTx = TransformHelper.derive(t, localToParentTx);
 5080                 }
 5081             }
 5082 
 5083             // Check to see whether the node requires mirroring
 5084             if (mirror) {
 5085                 localToParentTx = localToParentTx.deriveWithTranslation(
 5086                         mirroringCenter, 0);
 5087                 localToParentTx = localToParentTx.deriveWithScale(
 5088                         -1.0, 1.0, 1.0);
 5089                 localToParentTx = localToParentTx.deriveWithTranslation(
 5090                         -mirroringCenter, 0);
 5091             }
 5092 
 5093             transformDirty = false;
 5094         }
 5095     }
 5096 
 5097     /**
 5098      * Transforms in place the specified point from parent coords to local
 5099      * coords. Made package private for the sake of testing.
 5100      */
 5101     void parentToLocal(com.sun.javafx.geom.Point2D pt) throws NoninvertibleTransformException {
 5102         updateLocalToParentTransform();
 5103         localToParentTx.inverseTransform(pt, pt);
 5104     }
 5105 
 5106     void parentToLocal(com.sun.javafx.geom.Vec3d pt) throws NoninvertibleTransformException {
 5107         updateLocalToParentTransform();
 5108         localToParentTx.inverseTransform(pt, pt);
 5109     }
 5110 
 5111     void sceneToLocal(com.sun.javafx.geom.Point2D pt) throws NoninvertibleTransformException {
 5112         if (getParent() != null) {
 5113             getParent().sceneToLocal(pt);
 5114         }
 5115         parentToLocal(pt);
 5116     }
 5117 
 5118     void sceneToLocal(com.sun.javafx.geom.Vec3d pt) throws NoninvertibleTransformException {
 5119         if (getParent() != null) {
 5120             getParent().sceneToLocal(pt);
 5121         }
 5122         parentToLocal(pt);
 5123     }
 5124 
 5125     void localToScene(com.sun.javafx.geom.Point2D pt) {
 5126         localToParent(pt);
 5127         if (getParent() != null) {
 5128             getParent().localToScene(pt);
 5129         }
 5130     }
 5131 
 5132     void localToScene(com.sun.javafx.geom.Vec3d pt) {
 5133         localToParent(pt);
 5134         if (getParent() != null) {
 5135             getParent().localToScene(pt);
 5136         }
 5137     }
 5138 
 5139     /***************************************************************************
 5140      *                                                                         *
 5141      * Mouse event related APIs                                                *
 5142      *                                                                         *
 5143      **************************************************************************/
 5144 
 5145     /**
 5146      * Transforms in place the specified point from local coords to parent
 5147      * coords. Made package private for the sake of testing.
 5148      */
 5149     void localToParent(com.sun.javafx.geom.Point2D pt) {
 5150         updateLocalToParentTransform();
 5151         localToParentTx.transform(pt, pt);
 5152     }
 5153 
 5154     void localToParent(com.sun.javafx.geom.Vec3d pt) {
 5155         updateLocalToParentTransform();
 5156         localToParentTx.transform(pt, pt);
 5157     }
 5158 
 5159     /*
 5160      * Finds a top-most child node that contains the given local coordinates.
 5161      *
 5162      * The result argument is used for storing the picking result.
 5163      *
 5164      * Note: This method MUST only be called via its accessor method.
 5165      */
 5166     private void doPickNodeLocal(PickRay localPickRay, PickResultChooser result) {
 5167         intersects(localPickRay, result);
 5168     }
 5169 
 5170     /*
 5171      * Finds a top-most child node that intersects the given ray.
 5172      *
 5173      * The result argument is used for storing the picking result.
 5174      */
 5175     final void pickNode(PickRay pickRay, PickResultChooser result) {
 5176 
 5177         // In some conditions we can omit picking this node or subgraph
 5178         if (!isVisible() || isDisable() || isMouseTransparent()) {
 5179             return;
 5180         }
 5181 
 5182         final Vec3d o = pickRay.getOriginNoClone();
 5183         final double ox = o.x;
 5184         final double oy = o.y;
 5185         final double oz = o.z;
 5186         final Vec3d d = pickRay.getDirectionNoClone();
 5187         final double dx = d.x;
 5188         final double dy = d.y;
 5189         final double dz = d.z;
 5190 
 5191         updateLocalToParentTransform();
 5192         try {
 5193             localToParentTx.inverseTransform(o, o);
 5194             localToParentTx.inverseDeltaTransform(d, d);
 5195 
 5196             // Delegate to a function which can be overridden by subclasses which
 5197             // actually does the pick. The implementation is markedly different
 5198             // for leaf nodes vs. parent nodes vs. region nodes.
 5199             NodeHelper.pickNodeLocal(this, pickRay, result);
 5200         } catch (NoninvertibleTransformException e) {
 5201             // in this case we just don&#39;t pick anything
 5202         }
 5203 
 5204         pickRay.setOrigin(ox, oy, oz);
 5205         pickRay.setDirection(dx, dy, dz);
 5206     }
 5207 
 5208     /*
 5209      * Returns {@code true} if the given ray (start, dir), specified in the
 5210      * local coordinate space of this {@code Node}, intersects the
 5211      * shape of this {@code Node}. Note that this method does not take visibility
 5212      * into account; the test is based on the geometry of this {@code Node} only.
 5213      * &lt;p&gt;
 5214      * The pickResult is updated if the found intersection is closer than
 5215      * the currently held one.
 5216      * &lt;p&gt;
 5217      * Note that this is a conditional feature. See
 5218      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 5219      * for more information.
 5220      */
 5221     final boolean intersects(PickRay pickRay, PickResultChooser pickResult) {
 5222         double boundsDistance = intersectsBounds(pickRay);
 5223         if (!Double.isNaN(boundsDistance)) {
 5224             if (isPickOnBounds()) {
 5225                 if (pickResult != null) {
 5226                     pickResult.offer(this, boundsDistance, PickResultChooser.computePoint(pickRay, boundsDistance));
 5227                 }
 5228                 return true;
 5229             } else {
 5230                 return NodeHelper.computeIntersects(this, pickRay, pickResult);
 5231             }
 5232         }
 5233         return false;
 5234     }
 5235 
 5236     /*
 5237      * Computes the intersection of the pickRay with this node.
 5238      * The pickResult argument is updated if the found intersection
 5239      * is closer than the passed one. On the other hand, the return value
 5240      * specifies whether the intersection exists, regardless of its comparison
 5241      * with the given pickResult.
 5242      */
 5243     private boolean doComputeIntersects(PickRay pickRay, PickResultChooser pickResult) {
 5244         double origZ = pickRay.getOriginNoClone().z;
 5245         double dirZ = pickRay.getDirectionNoClone().z;
 5246         // Handle the case where pickRay is almost parallel to the Z-plane
 5247         if (almostZero(dirZ)) {
 5248             return false;
 5249         }
 5250         double t = -origZ / dirZ;
 5251         if (t &lt; pickRay.getNearClip() || t &gt; pickRay.getFarClip()) {
 5252             return false;
 5253         }
 5254         double x = pickRay.getOriginNoClone().x + (pickRay.getDirectionNoClone().x * t);
 5255         double y = pickRay.getOriginNoClone().y + (pickRay.getDirectionNoClone().y * t);
 5256 
 5257         if (contains((float) x, (float) y)) {
 5258             if (pickResult != null) {
 5259                 pickResult.offer(this, t, PickResultChooser.computePoint(pickRay, t));
 5260             }
 5261             return true;
 5262         }
 5263         return false;
 5264     }
 5265 
 5266     /*
 5267      * Computes the intersection of the pickRay with the bounds of this node.
 5268      * The return value is the distance between the camera and the intersection
 5269      * point, measured in pickRay direction magnitudes. If there is
 5270      * no intersection, it returns NaN.
 5271      *
 5272      * @param pickRay The pick ray
 5273      * @return Distance of the intersection point, a NaN if there
 5274      *         is no intersection
 5275      */
 5276     final double intersectsBounds(PickRay pickRay) {
 5277 
 5278         final Vec3d dir = pickRay.getDirectionNoClone();
 5279         double tmin, tmax;
 5280 
 5281         final Vec3d origin = pickRay.getOriginNoClone();
 5282         final double originX = origin.x;
 5283         final double originY = origin.y;
 5284         final double originZ = origin.z;
 5285 
 5286         final TempState tempState = TempState.getInstance();
 5287         BaseBounds tempBounds = tempState.bounds;
 5288 
 5289         tempBounds = getLocalBounds(tempBounds,
 5290                                     BaseTransform.IDENTITY_TRANSFORM);
 5291 
 5292         if (dir.x == 0.0 &amp;&amp; dir.y == 0.0) {
 5293             // fast path for the usual 2D picking
 5294 
 5295             if (dir.z == 0.0) {
 5296                 return Double.NaN;
 5297             }
 5298 
 5299             if (originX &lt; tempBounds.getMinX() ||
 5300                     originX &gt; tempBounds.getMaxX() ||
 5301                     originY &lt; tempBounds.getMinY() ||
 5302                     originY &gt; tempBounds.getMaxY()) {
 5303                 return Double.NaN;
 5304             }
 5305 
 5306             final double invDirZ = 1.0 / dir.z;
 5307             final boolean signZ = invDirZ &lt; 0.0;
 5308 
 5309             final double minZ = tempBounds.getMinZ();
 5310             final double maxZ = tempBounds.getMaxZ();
 5311             tmin = ((signZ ? maxZ : minZ) - originZ) * invDirZ;
 5312             tmax = ((signZ ? minZ : maxZ) - originZ) * invDirZ;
 5313 
 5314         } else if (tempBounds.getDepth() == 0.0) {
 5315             // fast path for 3D picking of 2D bounds
 5316 
 5317             if (almostZero(dir.z)) {
 5318                 return Double.NaN;
 5319             }
 5320 
 5321             final double t = (tempBounds.getMinZ() - originZ) / dir.z;
 5322             final double x = originX + (dir.x * t);
 5323             final double y = originY + (dir.y * t);
 5324 
 5325             if (x &lt; tempBounds.getMinX() ||
 5326                     x &gt; tempBounds.getMaxX() ||
 5327                     y &lt; tempBounds.getMinY() ||
 5328                     y &gt; tempBounds.getMaxY()) {
 5329                 return Double.NaN;
 5330             }
 5331 
 5332             tmin = tmax = t;
 5333 
 5334         } else {
 5335 
 5336             final double invDirX = dir.x == 0.0 ? Double.POSITIVE_INFINITY : (1.0 / dir.x);
 5337             final double invDirY = dir.y == 0.0 ? Double.POSITIVE_INFINITY : (1.0 / dir.y);
 5338             final double invDirZ = dir.z == 0.0 ? Double.POSITIVE_INFINITY : (1.0 / dir.z);
 5339             final boolean signX = invDirX &lt; 0.0;
 5340             final boolean signY = invDirY &lt; 0.0;
 5341             final boolean signZ = invDirZ &lt; 0.0;
 5342             final double minX = tempBounds.getMinX();
 5343             final double minY = tempBounds.getMinY();
 5344             final double maxX = tempBounds.getMaxX();
 5345             final double maxY = tempBounds.getMaxY();
 5346 
 5347             tmin = Double.NEGATIVE_INFINITY;
 5348             tmax = Double.POSITIVE_INFINITY;
 5349             if (Double.isInfinite(invDirX)) {
 5350                 if (minX &lt;= originX &amp;&amp; maxX &gt;= originX) {
 5351                     // move on, we are inside for the whole length
 5352                 } else {
 5353                     return Double.NaN;
 5354                 }
 5355             } else {
 5356                 tmin = ((signX ? maxX : minX) - originX) * invDirX;
 5357                 tmax = ((signX ? minX : maxX) - originX) * invDirX;
 5358             }
 5359 
 5360             if (Double.isInfinite(invDirY)) {
 5361                 if (minY &lt;= originY &amp;&amp; maxY &gt;= originY) {
 5362                     // move on, we are inside for the whole length
 5363                 } else {
 5364                     return Double.NaN;
 5365                 }
 5366             } else {
 5367                 final double tymin = ((signY ? maxY : minY) - originY) * invDirY;
 5368                 final double tymax = ((signY ? minY : maxY) - originY) * invDirY;
 5369 
 5370                 if ((tmin &gt; tymax) || (tymin &gt; tmax)) {
 5371                     return Double.NaN;
 5372                 }
 5373                 if (tymin &gt; tmin) {
 5374                     tmin = tymin;
 5375                 }
 5376                 if (tymax &lt; tmax) {
 5377                     tmax = tymax;
 5378                 }
 5379             }
 5380 
 5381             final double minZ = tempBounds.getMinZ();
 5382             final double maxZ = tempBounds.getMaxZ();
 5383             if (Double.isInfinite(invDirZ)) {
 5384                 if (minZ &lt;= originZ &amp;&amp; maxZ &gt;= originZ) {
 5385                     // move on, we are inside for the whole length
 5386                 } else {
 5387                     return Double.NaN;
 5388                 }
 5389             } else {
 5390                 final double tzmin = ((signZ ? maxZ : minZ) - originZ) * invDirZ;
 5391                 final double tzmax = ((signZ ? minZ : maxZ) - originZ) * invDirZ;
 5392 
 5393                 if ((tmin &gt; tzmax) || (tzmin &gt; tmax)) {
 5394                     return Double.NaN;
 5395                 }
 5396                 if (tzmin &gt; tmin) {
 5397                     tmin = tzmin;
 5398                 }
 5399                 if (tzmax &lt; tmax) {
 5400                     tmax = tzmax;
 5401                 }
 5402             }
 5403         }
 5404 
 5405         // For clip we use following semantics: pick the node normally
 5406         // if there is an intersection with the clip node. We don&#39;t consider
 5407         // clip node distance.
 5408         Node clip = getClip();
 5409         if (clip != null
 5410                 // FIXME: All 3D picking is currently ignored by rendering.
 5411                 // Until this is fixed or defined differently (RT-28510),
 5412                 // we follow this behavior.
 5413                 &amp;&amp; !(this instanceof Shape3D) &amp;&amp; !(clip instanceof Shape3D)) {
 5414             final double dirX = dir.x;
 5415             final double dirY = dir.y;
 5416             final double dirZ = dir.z;
 5417 
 5418             clip.updateLocalToParentTransform();
 5419 
 5420             boolean hitClip = true;
 5421             try {
 5422                 clip.localToParentTx.inverseTransform(origin, origin);
 5423                 clip.localToParentTx.inverseDeltaTransform(dir, dir);
 5424             } catch (NoninvertibleTransformException e) {
 5425                 hitClip = false;
 5426             }
 5427             hitClip = hitClip &amp;&amp; clip.intersects(pickRay, null);
 5428             pickRay.setOrigin(originX, originY, originZ);
 5429             pickRay.setDirection(dirX, dirY, dirZ);
 5430 
 5431             if (!hitClip) {
 5432                 return Double.NaN;
 5433             }
 5434         }
 5435 
 5436         if (Double.isInfinite(tmin) || Double.isNaN(tmin)) {
 5437             // We&#39;ve got a nonsense pick ray or bounds.
 5438             return Double.NaN;
 5439         }
 5440 
 5441         final double minDistance = pickRay.getNearClip();
 5442         final double maxDistance = pickRay.getFarClip();
 5443         if (tmin &lt; minDistance) {
 5444             if (tmax &gt;= minDistance) {
 5445                 // we are inside bounds
 5446                 return 0.0;
 5447             } else {
 5448                 return Double.NaN;
 5449             }
 5450         } else if (tmin &gt; maxDistance) {
 5451             return Double.NaN;
 5452         }
 5453 
 5454         return tmin;
 5455     }
 5456 
 5457 
 5458     // Good to find a home for commonly use util. code such as EPS.
 5459     // and almostZero. This code currently defined in multiple places,
 5460     // such as Affine3D and GeneralTransform3D.
 5461     private static final double EPSILON_ABSOLUTE = 1.0e-5;
 5462 
 5463     static boolean almostZero(double a) {
 5464         return ((a &lt; EPSILON_ABSOLUTE) &amp;&amp; (a &gt; -EPSILON_ABSOLUTE));
 5465     }
 5466 
 5467     /***************************************************************************
 5468      *                                                                         *
 5469      *                      viewOrder property handling                        *
 5470      *                                                                         *
 5471      **************************************************************************/
 5472 
 5473     /**
 5474      * Defines the rendering and picking order of this {@code Node} within its
 5475      * parent.
 5476      * &lt;p&gt;
 5477      * This property is used to alter the rendering and picking order of a node
 5478      * within its parent without reordering the parent&#39;s {@code children} list.
 5479      * For example, this can be used as a more efficient way to implement
 5480      * transparency sorting. To do this, an application can assign the viewOrder
 5481      * value of each node to the computed distance between that node and the
 5482      * viewer.
 5483      * &lt;/p&gt;
 5484      * &lt;p&gt;
 5485      * The parent will traverse its {@code children} in decreasing
 5486      * {@code viewOrder} order. This means that a child with a lower
 5487      * {@code viewOrder} will be in front of a child with a higher
 5488      * {@code viewOrder}. If two children have the same {@code viewOrder}, the
 5489      * parent will traverse them in the order they appear in the parent&#39;s
 5490      * {@code children} list.
 5491      * &lt;/p&gt;
 5492      * &lt;p&gt;
 5493      * However, {@code viewOrder} does not alter the layout and focus traversal
 5494      * order of this Node within its parent. A parent always traverses its
 5495      * {@code children} list in order when doing layout or focus traversal.
 5496      * &lt;/p&gt;
 5497      *
 5498      * @return the view order for this {@code Node}
 5499      * @defaultValue 0.0
 5500      *
 5501      * @since 9
 5502      */
 5503     public final DoubleProperty viewOrderProperty() {
 5504         return getMiscProperties().viewOrderProperty();
 5505     }
 5506 
 5507     public final void setViewOrder(double value) {
 5508         viewOrderProperty().set(value);
 5509     }
 5510 
 5511     public final double getViewOrder() {
 5512         return (miscProperties == null) ? DEFAULT_VIEW_ORDER
 5513                 : miscProperties.getViewOrder();
 5514     }
 5515 
 5516     /***************************************************************************
 5517      *                                                                         *
 5518      *                             Transformations                             *
 5519      *                                                                         *
 5520      **************************************************************************/
 5521     /**
<a name="7" id="anc7"></a><span class="line-modified"> 5522      * Defines the {@code ObservableList} of {@link Transform} objects to be applied to this {@code Node}. The transforms in this list</span>
<span class="line-modified"> 5523      * are applied in the &lt;i&gt;reverse&lt;/i&gt; order of which they are specified as per matrix multiplication rules. This list of transforms</span>
<span class="line-modified"> 5524      * is applied before scaling ({@link #scaleXProperty scaleX}, {@link #scaleYProperty scaleY} and {@link #scaleZProperty scaleZ}),</span>
<span class="line-modified"> 5525      * rotation ({@link #rotateProperty rotate}), and layout and translation ({@link #layoutXProperty layoutX},</span>
<span class="line-removed"> 5526      * {@link #layoutYProperty layoutY}, {@link #translateXProperty translateX}, {@link #translateYProperty translateY} and</span>
<span class="line-removed"> 5527      * {@link #translateYProperty translateZ}), in that order.</span>
 5528      *
 5529      * @return the transforms for this {@code Node}
 5530      * @defaultValue empty
 5531      */
 5532     public final ObservableList&lt;Transform&gt; getTransforms() {
 5533         return transformsProperty();
 5534     }
 5535 
 5536     private ObservableList&lt;Transform&gt; transformsProperty() {
 5537         return getNodeTransformation().getTransforms();
 5538     }
 5539 
 5540     public final void setTranslateX(double value) {
 5541         translateXProperty().set(value);
 5542     }
 5543 
 5544     public final double getTranslateX() {
 5545         return (nodeTransformation == null)
 5546                 ? DEFAULT_TRANSLATE_X
 5547                 : nodeTransformation.getTranslateX();
 5548     }
 5549 
 5550     /**
 5551      * Defines the x coordinate of the translation that is added to this {@code Node}&#39;s
 5552      * transform.
 5553      * &lt;p&gt;
 5554      * The node&#39;s final translation will be computed as {@link #layoutXProperty layoutX} + {@code translateX},
 5555      * where {@code layoutX} establishes the node&#39;s stable position and {@code translateX}
 5556      * optionally makes dynamic adjustments to that position.
 5557      *&lt;p&gt;
 5558      * This variable can be used to alter the location of a node without disturbing
 5559      * its {@link #layoutBoundsProperty layoutBounds}, which makes it useful for animating a node&#39;s location.
 5560      *
 5561      * @return the translateX for this {@code Node}
 5562      * @defaultValue 0
 5563      */
 5564     public final DoubleProperty translateXProperty() {
 5565         return getNodeTransformation().translateXProperty();
 5566     }
 5567 
 5568     public final void setTranslateY(double value) {
 5569         translateYProperty().set(value);
 5570     }
 5571 
 5572     public final double getTranslateY() {
 5573         return (nodeTransformation == null)
 5574                 ? DEFAULT_TRANSLATE_Y
 5575                 : nodeTransformation.getTranslateY();
 5576     }
 5577 
 5578     /**
 5579      * Defines the y coordinate of the translation that is added to this {@code Node}&#39;s
 5580      * transform.
 5581      * &lt;p&gt;
 5582      * The node&#39;s final translation will be computed as {@link #layoutYProperty layoutY} + {@code translateY},
 5583      * where {@code layoutY} establishes the node&#39;s stable position and {@code translateY}
 5584      * optionally makes dynamic adjustments to that position.
 5585      * &lt;p&gt;
 5586      * This variable can be used to alter the location of a node without disturbing
 5587      * its {@link #layoutBoundsProperty layoutBounds}, which makes it useful for animating a node&#39;s location.
 5588      *
 5589      * @return the translateY for this {@code Node}
 5590      * @defaultValue 0
 5591      */
 5592     public final DoubleProperty translateYProperty() {
 5593         return getNodeTransformation().translateYProperty();
 5594     }
 5595 
 5596     public final void setTranslateZ(double value) {
 5597         translateZProperty().set(value);
 5598     }
 5599 
 5600     public final double getTranslateZ() {
 5601         return (nodeTransformation == null)
 5602                 ? DEFAULT_TRANSLATE_Z
 5603                 : nodeTransformation.getTranslateZ();
 5604     }
 5605 
 5606     /**
 5607      * Defines the Z coordinate of the translation that is added to the
 5608      * transformed coordinates of this {@code Node}.  This value will be added
 5609      * to any translation defined by the {@code transforms} ObservableList and
 5610      * {@code layoutZ}.
 5611      * &lt;p&gt;
 5612      * This variable can be used to alter the location of a Node without
 5613      * disturbing its layout bounds, which makes it useful for animating a
 5614      * node&#39;s location.
 5615      * &lt;p&gt;
 5616      * Note that this is a conditional feature. See
 5617      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 5618      * for more information.
 5619      *
 5620      * @return the translateZ for this {@code Node}
 5621      * @defaultValue 0
 5622      */
 5623     public final DoubleProperty translateZProperty() {
 5624         return getNodeTransformation().translateZProperty();
 5625     }
 5626 
 5627     public final void setScaleX(double value) {
 5628         scaleXProperty().set(value);
 5629     }
 5630 
 5631     public final double getScaleX() {
 5632         return (nodeTransformation == null) ? DEFAULT_SCALE_X
 5633                                             : nodeTransformation.getScaleX();
 5634     }
 5635 
 5636     /**
 5637      * Defines the factor by which coordinates are scaled about the center of the
 5638      * object along the X axis of this {@code Node}. This is used to stretch or
 5639      * shrink the node either manually or by using an animation.
 5640      * &lt;p&gt;
 5641      * This scale factor is not included in {@link #layoutBoundsProperty layoutBounds} by
 5642      * default, which makes it ideal for scaling the entire node after
 5643      * all effects and transforms have been taken into account.
 5644      * &lt;p&gt;
 5645      * The pivot point about which the scale occurs is the center of the
 5646      * untransformed {@link #layoutBoundsProperty layoutBounds}.
 5647      *
 5648      * @return the scaleX for this {@code Node}
 5649      * @defaultValue 1.0
 5650      */
 5651     public final DoubleProperty scaleXProperty() {
 5652         return getNodeTransformation().scaleXProperty();
 5653     }
 5654 
 5655     public final void setScaleY(double value) {
 5656         scaleYProperty().set(value);
 5657     }
 5658 
 5659     public final double getScaleY() {
 5660         return (nodeTransformation == null) ? DEFAULT_SCALE_Y
 5661                                             : nodeTransformation.getScaleY();
 5662     }
 5663 
 5664     /**
 5665      * Defines the factor by which coordinates are scaled about the center of the
 5666      * object along the Y axis of this {@code Node}. This is used to stretch or
 5667      * shrink the node either manually or by using an animation.
 5668      * &lt;p&gt;
 5669      * This scale factor is not included in {@link #layoutBoundsProperty layoutBounds} by
 5670      * default, which makes it ideal for scaling the entire node after
 5671      * all effects and transforms have been taken into account.
 5672      * &lt;p&gt;
 5673      * The pivot point about which the scale occurs is the center of the
 5674      * untransformed {@link #layoutBoundsProperty layoutBounds}.
 5675      *
 5676      * @return the scaleY for this {@code Node}
 5677      * @defaultValue 1.0
 5678      */
 5679     public final DoubleProperty scaleYProperty() {
 5680         return getNodeTransformation().scaleYProperty();
 5681     }
 5682 
 5683     public final void setScaleZ(double value) {
 5684         scaleZProperty().set(value);
 5685     }
 5686 
 5687     public final double getScaleZ() {
 5688         return (nodeTransformation == null) ? DEFAULT_SCALE_Z
 5689                                             : nodeTransformation.getScaleZ();
 5690     }
 5691 
 5692     /**
 5693      * Defines the factor by which coordinates are scaled about the center of the
 5694      * object along the Z axis of this {@code Node}. This is used to stretch or
 5695      * shrink the node either manually or by using an animation.
 5696      * &lt;p&gt;
 5697      * This scale factor is not included in {@link #layoutBoundsProperty layoutBounds} by
 5698      * default, which makes it ideal for scaling the entire node after
 5699      * all effects and transforms have been taken into account.
 5700      * &lt;p&gt;
 5701      * The pivot point about which the scale occurs is the center of the
 5702      * rectangular bounds formed by taking {@link #boundsInLocalProperty boundsInLocal} and applying
 5703      * all the transforms in the {@link #getTransforms transforms} ObservableList.
 5704      * &lt;p&gt;
 5705      * Note that this is a conditional feature. See
 5706      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 5707      * for more information.
 5708      *
 5709      * @return the scaleZ for this {@code Node}
 5710      * @defaultValue 1.0
 5711      */
 5712     public final DoubleProperty scaleZProperty() {
 5713         return getNodeTransformation().scaleZProperty();
 5714     }
 5715 
 5716     public final void setRotate(double value) {
 5717         rotateProperty().set(value);
 5718     }
 5719 
 5720     public final double getRotate() {
 5721         return (nodeTransformation == null) ? DEFAULT_ROTATE
 5722                                             : nodeTransformation.getRotate();
 5723     }
 5724 
 5725     /**
 5726      * Defines the angle of rotation about the {@code Node}&#39;s center, measured in
 5727      * degrees. This is used to rotate the {@code Node}.
 5728      * &lt;p&gt;
 5729      * This rotation factor is not included in {@link #layoutBoundsProperty layoutBounds} by
 5730      * default, which makes it ideal for rotating the entire node after
 5731      * all effects and transforms have been taken into account.
 5732      * &lt;p&gt;
 5733      * The pivot point about which the rotation occurs is the center of the
 5734      * untransformed {@link #layoutBoundsProperty layoutBounds}.
 5735      * &lt;p&gt;
 5736      * Note that because the pivot point is computed as the center of this
 5737      * {@code Node}&#39;s layout bounds, any change to the layout bounds will cause
 5738      * the pivot point to change, which can move the object. For a leaf node,
 5739      * any change to the geometry will cause the layout bounds to change.
 5740      * For a group node, any change to any of its children, including a
 5741      * change in a child&#39;s geometry, clip, effect, position, orientation, or
 5742      * scale, will cause the group&#39;s layout bounds to change. If this movement
 5743      * of the pivot point is not
 5744      * desired, applications should instead use the Node&#39;s {@link #getTransforms transforms}
 5745      * ObservableList, and add a {@link javafx.scene.transform.Rotate} transform,
 5746      * which has a user-specifiable pivot point.
 5747      *
 5748      * @return the rotate for this {@code Node}
 5749      * @defaultValue 0.0
 5750      */
 5751     public final DoubleProperty rotateProperty() {
 5752         return getNodeTransformation().rotateProperty();
 5753     }
 5754 
 5755     public final void setRotationAxis(Point3D value) {
 5756         rotationAxisProperty().set(value);
 5757     }
 5758 
 5759     public final Point3D getRotationAxis() {
 5760         return (nodeTransformation == null)
 5761                 ? DEFAULT_ROTATION_AXIS
 5762                 : nodeTransformation.getRotationAxis();
 5763     }
 5764 
 5765     /**
 5766      * Defines the axis of rotation of this {@code Node}.
 5767      * &lt;p&gt;
 5768      * Note that this is a conditional feature. See
 5769      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 5770      * for more information.
 5771      *
 5772      * @return the rotationAxis for this {@code Node}
 5773      * @defaultValue Rotate.Z_AXIS
 5774      */
 5775     public final ObjectProperty&lt;Point3D&gt; rotationAxisProperty() {
 5776         return getNodeTransformation().rotationAxisProperty();
 5777     }
 5778 
 5779     /**
 5780      * An affine transform that holds the computed local-to-parent transform.
 5781      * This is the concatenation of all transforms in this node, including all
 5782      * of the convenience transforms.
 5783      * @return the localToParent transform for this {@code Node}
 5784      * @since JavaFX 2.2
 5785      */
 5786     public final ReadOnlyObjectProperty&lt;Transform&gt; localToParentTransformProperty() {
 5787         return getNodeTransformation().localToParentTransformProperty();
 5788     }
 5789 
 5790     private void invalidateLocalToParentTransform() {
 5791         if (nodeTransformation != null) {
 5792             nodeTransformation.invalidateLocalToParentTransform();
 5793         }
 5794     }
 5795 
 5796     public final Transform getLocalToParentTransform() {
 5797         return localToParentTransformProperty().get();
 5798     }
 5799 
 5800     /**
 5801      * An affine transform that holds the computed local-to-scene transform.
 5802      * This is the concatenation of all transforms in this node&#39;s parents and
 5803      * in this node, including all of the convenience transforms up to the root.
 5804      * If this node is in a {@link javafx.scene.SubScene}, this property represents
 5805      * transforms up to the subscene, not the root scene.
 5806      *
 5807      * &lt;p&gt;
 5808      * Note that when you register a listener or a binding to this property,
 5809      * it needs to listen for invalidation on all its parents to the root node.
 5810      * This means that registering a listener on this
 5811      * property on many nodes may negatively affect performance of
 5812      * transformation changes in their common parents.
 5813      * &lt;/p&gt;
 5814      *
 5815      * @return the localToScene transform for this {@code Node}
 5816      * @since JavaFX 2.2
 5817      */
 5818     public final ReadOnlyObjectProperty&lt;Transform&gt; localToSceneTransformProperty() {
 5819         return getNodeTransformation().localToSceneTransformProperty();
 5820     }
 5821 
 5822     private void invalidateLocalToSceneTransform() {
 5823         if (nodeTransformation != null) {
 5824             nodeTransformation.invalidateLocalToSceneTransform();
 5825         }
 5826     }
 5827 
 5828     public final Transform getLocalToSceneTransform() {
 5829         return localToSceneTransformProperty().get();
 5830     }
 5831 
 5832     private NodeTransformation nodeTransformation;
 5833 
 5834     private NodeTransformation getNodeTransformation() {
 5835         if (nodeTransformation == null) {
 5836             nodeTransformation = new NodeTransformation();
 5837         }
 5838 
 5839         return nodeTransformation;
 5840     }
 5841 
 5842     private boolean hasTransforms() {
 5843         return (nodeTransformation != null)
 5844                 &amp;&amp; nodeTransformation.hasTransforms();
 5845     }
 5846 
 5847     // for tests only
 5848     Transform getCurrentLocalToSceneTransformState() {
 5849         if (nodeTransformation == null ||
 5850                 nodeTransformation.localToSceneTransform == null) {
 5851             return null;
 5852         }
 5853 
 5854         return nodeTransformation.localToSceneTransform.transform;
 5855     }
 5856 
 5857     private static final double DEFAULT_TRANSLATE_X = 0;
 5858     private static final double DEFAULT_TRANSLATE_Y = 0;
 5859     private static final double DEFAULT_TRANSLATE_Z = 0;
 5860     private static final double DEFAULT_SCALE_X = 1;
 5861     private static final double DEFAULT_SCALE_Y = 1;
 5862     private static final double DEFAULT_SCALE_Z = 1;
 5863     private static final double DEFAULT_ROTATE = 0;
 5864     private static final Point3D DEFAULT_ROTATION_AXIS = Rotate.Z_AXIS;
 5865 
 5866     private final class NodeTransformation {
 5867         private DoubleProperty translateX;
 5868         private DoubleProperty translateY;
 5869         private DoubleProperty translateZ;
 5870         private DoubleProperty scaleX;
 5871         private DoubleProperty scaleY;
 5872         private DoubleProperty scaleZ;
 5873         private DoubleProperty rotate;
 5874         private ObjectProperty&lt;Point3D&gt; rotationAxis;
 5875         private ObservableList&lt;Transform&gt; transforms;
 5876         private LazyTransformProperty localToParentTransform;
 5877         private LazyTransformProperty localToSceneTransform;
 5878         private int listenerReasons = 0;
 5879         private InvalidationListener localToSceneInvLstnr;
 5880 
 5881         private InvalidationListener getLocalToSceneInvalidationListener() {
 5882             if (localToSceneInvLstnr == null) {
 5883                 localToSceneInvLstnr = observable -&gt; invalidateLocalToSceneTransform();
 5884             }
 5885             return localToSceneInvLstnr;
 5886         }
 5887 
 5888         public void incListenerReasons() {
 5889             if (listenerReasons == 0) {
 5890                 Node n = Node.this.getParent();
 5891                 if (n != null) {
 5892                     n.localToSceneTransformProperty().addListener(
 5893                             getLocalToSceneInvalidationListener());
 5894                 }
 5895             }
 5896             listenerReasons++;
 5897         }
 5898 
 5899         public void decListenerReasons() {
 5900             listenerReasons--;
 5901             if (listenerReasons == 0) {
 5902                 Node n = Node.this.getParent();
 5903                 if (n != null) {
 5904                     n.localToSceneTransformProperty().removeListener(
 5905                             getLocalToSceneInvalidationListener());
 5906                 }
 5907                 if (localToSceneTransform != null) {
 5908                     localToSceneTransform.validityUnknown();
 5909                 }
 5910             }
 5911         }
 5912 
 5913         public final Transform getLocalToParentTransform() {
 5914             return localToParentTransformProperty().get();
 5915         }
 5916 
 5917         public final ReadOnlyObjectProperty&lt;Transform&gt; localToParentTransformProperty() {
 5918             if (localToParentTransform == null) {
 5919                 localToParentTransform = new LazyTransformProperty() {
 5920                     @Override
 5921                     protected Transform computeTransform(Transform reuse) {
 5922                         updateLocalToParentTransform();
 5923                         return TransformUtils.immutableTransform(reuse,
 5924                                 localToParentTx.getMxx(), localToParentTx.getMxy(), localToParentTx.getMxz(), localToParentTx.getMxt(),
 5925                                 localToParentTx.getMyx(), localToParentTx.getMyy(), localToParentTx.getMyz(), localToParentTx.getMyt(),
 5926                                 localToParentTx.getMzx(), localToParentTx.getMzy(), localToParentTx.getMzz(), localToParentTx.getMzt());
 5927                     }
 5928 
 5929                     @Override
 5930                     protected boolean validityKnown() {
 5931                         return true;
 5932                     }
 5933 
 5934                     @Override
 5935                     protected int computeValidity() {
 5936                         return valid;
 5937                     }
 5938 
 5939                     @Override
 5940                     public Object getBean() {
 5941                         return Node.this;
 5942                     }
 5943 
 5944                     @Override
 5945                     public String getName() {
 5946                         return &quot;localToParentTransform&quot;;
 5947                     }
 5948                 };
 5949             }
 5950 
 5951             return localToParentTransform;
 5952         }
 5953 
 5954         public void invalidateLocalToParentTransform() {
 5955             if (localToParentTransform != null) {
 5956                 localToParentTransform.invalidate();
 5957             }
 5958         }
 5959 
 5960         public final Transform getLocalToSceneTransform() {
 5961             return localToSceneTransformProperty().get();
 5962         }
 5963 
 5964         class LocalToSceneTransformProperty extends LazyTransformProperty {
 5965             // need this to track number of listeners
 5966             private List localToSceneListeners;
 5967             // stamps to watch for parent changes when the listeners
 5968             // are not present
 5969             private long stamp, parentStamp;
 5970 
 5971             @Override
 5972             protected Transform computeTransform(Transform reuse) {
 5973                 stamp++;
 5974                 updateLocalToParentTransform();
 5975 
 5976                 Node parentNode = Node.this.getParent();
 5977                 if (parentNode != null) {
 5978                     final LocalToSceneTransformProperty parentProperty =
 5979                             (LocalToSceneTransformProperty) parentNode.localToSceneTransformProperty();
 5980                     final Transform parentTransform = parentProperty.getInternalValue();
 5981 
 5982                     parentStamp = parentProperty.stamp;
 5983 
 5984                     return TransformUtils.immutableTransform(reuse,
 5985                             parentTransform,
 5986                             ((LazyTransformProperty) localToParentTransformProperty()).getInternalValue());
 5987                 } else {
 5988                     return TransformUtils.immutableTransform(reuse,
 5989                             ((LazyTransformProperty) localToParentTransformProperty()).getInternalValue());
 5990                 }
 5991             }
 5992 
 5993             @Override
 5994             public Object getBean() {
 5995                 return Node.this;
 5996             }
 5997 
 5998             @Override
 5999             public String getName() {
 6000                 return &quot;localToSceneTransform&quot;;
 6001             }
 6002 
 6003             @Override
 6004             protected boolean validityKnown() {
 6005                 return listenerReasons &gt; 0;
 6006             }
 6007 
 6008             @Override
 6009             protected int computeValidity() {
 6010                 if (valid != VALIDITY_UNKNOWN) {
 6011                     return valid;
 6012                 }
 6013 
 6014                 Node n = (Node) getBean();
 6015                 Node parent = n.getParent();
 6016 
 6017                 if (parent != null) {
 6018                     final LocalToSceneTransformProperty parentProperty =
 6019                             (LocalToSceneTransformProperty) parent.localToSceneTransformProperty();
 6020 
 6021                     if (parentStamp != parentProperty.stamp) {
 6022                         valid = INVALID;
 6023                         return INVALID;
 6024                     }
 6025 
 6026                     int parentValid = parentProperty.computeValidity();
 6027                     if (parentValid == INVALID) {
 6028                         valid = INVALID;
 6029                     }
 6030                     return parentValid;
 6031                 }
 6032 
 6033                 // Validity unknown for root means it is valid
 6034                 return VALID;
 6035             }
 6036 
 6037             @Override
 6038             public void addListener(InvalidationListener listener) {
 6039                 incListenerReasons();
 6040                 if (localToSceneListeners == null) {
 6041                     localToSceneListeners = new LinkedList&lt;Object&gt;();
 6042                 }
 6043                 localToSceneListeners.add(listener);
 6044                 super.addListener(listener);
 6045             }
 6046 
 6047             @Override
 6048             public void addListener(ChangeListener&lt;? super Transform&gt; listener) {
 6049                 incListenerReasons();
 6050                 if (localToSceneListeners == null) {
 6051                     localToSceneListeners = new LinkedList&lt;Object&gt;();
 6052                 }
 6053                 localToSceneListeners.add(listener);
 6054                 super.addListener(listener);
 6055             }
 6056 
 6057             @Override
 6058             public void removeListener(InvalidationListener listener) {
 6059                 if (localToSceneListeners != null &amp;&amp;
 6060                         localToSceneListeners.remove(listener)) {
 6061                     decListenerReasons();
 6062                 }
 6063                 super.removeListener(listener);
 6064             }
 6065 
 6066             @Override
 6067             public void removeListener(ChangeListener&lt;? super Transform&gt; listener) {
 6068                 if (localToSceneListeners != null &amp;&amp;
 6069                         localToSceneListeners.remove(listener)) {
 6070                     decListenerReasons();
 6071                 }
 6072                 super.removeListener(listener);
 6073             }
 6074         }
 6075 
 6076         public final ReadOnlyObjectProperty&lt;Transform&gt; localToSceneTransformProperty() {
 6077             if (localToSceneTransform == null) {
 6078                 localToSceneTransform = new LocalToSceneTransformProperty();
 6079             }
 6080 
 6081             return localToSceneTransform;
 6082         }
 6083 
 6084         public void invalidateLocalToSceneTransform() {
 6085             if (localToSceneTransform != null) {
 6086                 localToSceneTransform.invalidate();
 6087             }
 6088         }
 6089 
 6090         public double getTranslateX() {
 6091             return (translateX == null) ? DEFAULT_TRANSLATE_X
 6092                                         : translateX.get();
 6093         }
 6094 
 6095         public final DoubleProperty translateXProperty() {
 6096             if (translateX == null) {
 6097                 translateX = new StyleableDoubleProperty(DEFAULT_TRANSLATE_X) {
 6098                     @Override
 6099                     public void invalidated() {
 6100                         NodeHelper.transformsChanged(Node.this);
 6101                     }
 6102 
 6103                     @Override
 6104                     public CssMetaData getCssMetaData() {
 6105                         return StyleableProperties.TRANSLATE_X;
 6106                     }
 6107 
 6108                     @Override
 6109                     public Object getBean() {
 6110                         return Node.this;
 6111                     }
 6112 
 6113                     @Override
 6114                     public String getName() {
 6115                         return &quot;translateX&quot;;
 6116                     }
 6117                 };
 6118             }
 6119             return translateX;
 6120         }
 6121 
 6122         public double getTranslateY() {
 6123             return (translateY == null) ? DEFAULT_TRANSLATE_Y : translateY.get();
 6124         }
 6125 
 6126         public final DoubleProperty translateYProperty() {
 6127             if (translateY == null) {
 6128                 translateY = new StyleableDoubleProperty(DEFAULT_TRANSLATE_Y) {
 6129                     @Override
 6130                     public void invalidated() {
 6131                         NodeHelper.transformsChanged(Node.this);
 6132                     }
 6133 
 6134                     @Override
 6135                     public CssMetaData getCssMetaData() {
 6136                         return StyleableProperties.TRANSLATE_Y;
 6137                     }
 6138 
 6139                     @Override
 6140                     public Object getBean() {
 6141                         return Node.this;
 6142                     }
 6143 
 6144                     @Override
 6145                     public String getName() {
 6146                         return &quot;translateY&quot;;
 6147                     }
 6148                 };
 6149             }
 6150             return translateY;
 6151         }
 6152 
 6153         public double getTranslateZ() {
 6154             return (translateZ == null) ? DEFAULT_TRANSLATE_Z : translateZ.get();
 6155         }
 6156 
 6157         public final DoubleProperty translateZProperty() {
 6158             if (translateZ == null) {
 6159                 translateZ = new StyleableDoubleProperty(DEFAULT_TRANSLATE_Z) {
 6160                     @Override
 6161                     public void invalidated() {
 6162                         NodeHelper.transformsChanged(Node.this);
 6163                     }
 6164 
 6165                     @Override
 6166                     public CssMetaData getCssMetaData() {
 6167                         return StyleableProperties.TRANSLATE_Z;
 6168                     }
 6169 
 6170                     @Override
 6171                     public Object getBean() {
 6172                         return Node.this;
 6173                     }
 6174 
 6175                     @Override
 6176                     public String getName() {
 6177                         return &quot;translateZ&quot;;
 6178                     }
 6179                 };
 6180             }
 6181             return translateZ;
 6182         }
 6183 
 6184         public double getScaleX() {
 6185             return (scaleX == null) ? DEFAULT_SCALE_X : scaleX.get();
 6186         }
 6187 
 6188         public final DoubleProperty scaleXProperty() {
 6189             if (scaleX == null) {
 6190                 scaleX = new StyleableDoubleProperty(DEFAULT_SCALE_X) {
 6191                     @Override
 6192                     public void invalidated() {
 6193                         NodeHelper.transformsChanged(Node.this);
 6194                     }
 6195 
 6196                     @Override
 6197                     public CssMetaData getCssMetaData() {
 6198                         return StyleableProperties.SCALE_X;
 6199                     }
 6200 
 6201                     @Override
 6202                     public Object getBean() {
 6203                         return Node.this;
 6204                     }
 6205 
 6206                     @Override
 6207                     public String getName() {
 6208                         return &quot;scaleX&quot;;
 6209                     }
 6210                 };
 6211             }
 6212             return scaleX;
 6213         }
 6214 
 6215         public double getScaleY() {
 6216             return (scaleY == null) ? DEFAULT_SCALE_Y : scaleY.get();
 6217         }
 6218 
 6219         public final DoubleProperty scaleYProperty() {
 6220             if (scaleY == null) {
 6221                 scaleY = new StyleableDoubleProperty(DEFAULT_SCALE_Y) {
 6222                     @Override
 6223                     public void invalidated() {
 6224                         NodeHelper.transformsChanged(Node.this);
 6225                     }
 6226 
 6227                     @Override
 6228                     public CssMetaData getCssMetaData() {
 6229                         return StyleableProperties.SCALE_Y;
 6230                     }
 6231 
 6232                     @Override
 6233                     public Object getBean() {
 6234                         return Node.this;
 6235                     }
 6236 
 6237                     @Override
 6238                     public String getName() {
 6239                         return &quot;scaleY&quot;;
 6240                     }
 6241                 };
 6242             }
 6243             return scaleY;
 6244         }
 6245 
 6246         public double getScaleZ() {
 6247             return (scaleZ == null) ? DEFAULT_SCALE_Z : scaleZ.get();
 6248         }
 6249 
 6250         public final DoubleProperty scaleZProperty() {
 6251             if (scaleZ == null) {
 6252                 scaleZ = new StyleableDoubleProperty(DEFAULT_SCALE_Z) {
 6253                     @Override
 6254                     public void invalidated() {
 6255                         NodeHelper.transformsChanged(Node.this);
 6256                     }
 6257 
 6258                     @Override
 6259                     public CssMetaData getCssMetaData() {
 6260                         return StyleableProperties.SCALE_Z;
 6261                     }
 6262 
 6263                     @Override
 6264                     public Object getBean() {
 6265                         return Node.this;
 6266                     }
 6267 
 6268                     @Override
 6269                     public String getName() {
 6270                         return &quot;scaleZ&quot;;
 6271                     }
 6272                 };
 6273             }
 6274             return scaleZ;
 6275         }
 6276 
 6277         public double getRotate() {
 6278             return (rotate == null) ? DEFAULT_ROTATE : rotate.get();
 6279         }
 6280 
 6281         public final DoubleProperty rotateProperty() {
 6282             if (rotate == null) {
 6283                 rotate = new StyleableDoubleProperty(DEFAULT_ROTATE) {
 6284                     @Override
 6285                     public void invalidated() {
 6286                         NodeHelper.transformsChanged(Node.this);
 6287                     }
 6288 
 6289                     @Override
 6290                     public CssMetaData getCssMetaData() {
 6291                         return StyleableProperties.ROTATE;
 6292                     }
 6293 
 6294                     @Override
 6295                     public Object getBean() {
 6296                         return Node.this;
 6297                     }
 6298 
 6299                     @Override
 6300                     public String getName() {
 6301                         return &quot;rotate&quot;;
 6302                     }
 6303                 };
 6304             }
 6305             return rotate;
 6306         }
 6307 
 6308         public Point3D getRotationAxis() {
 6309             return (rotationAxis == null) ? DEFAULT_ROTATION_AXIS
 6310                                           : rotationAxis.get();
 6311         }
 6312 
 6313         public final ObjectProperty&lt;Point3D&gt; rotationAxisProperty() {
 6314             if (rotationAxis == null) {
 6315                 rotationAxis = new ObjectPropertyBase&lt;Point3D&gt;(
 6316                                            DEFAULT_ROTATION_AXIS) {
 6317                     @Override
 6318                     protected void invalidated() {
 6319                         NodeHelper.transformsChanged(Node.this);
 6320                     }
 6321 
 6322                     @Override
 6323                     public Object getBean() {
 6324                         return Node.this;
 6325                     }
 6326 
 6327                     @Override
 6328                     public String getName() {
 6329                         return &quot;rotationAxis&quot;;
 6330                     }
 6331                 };
 6332             }
 6333             return rotationAxis;
 6334         }
 6335 
 6336         public ObservableList&lt;Transform&gt; getTransforms() {
 6337             if (transforms == null) {
 6338                 transforms = new TrackableObservableList&lt;Transform&gt;() {
 6339                     @Override
 6340                     protected void onChanged(Change&lt;Transform&gt; c) {
 6341                         while (c.next()) {
 6342                             for (Transform t : c.getRemoved()) {
 6343                                 TransformHelper.remove(t, Node.this);
 6344                             }
 6345                             for (Transform t : c.getAddedSubList()) {
 6346                                 TransformHelper.add(t, Node.this);
 6347                             }
 6348                         }
 6349 
 6350                         NodeHelper.transformsChanged(Node.this);
 6351                     }
 6352                 };
 6353             }
 6354 
 6355             return transforms;
 6356         }
 6357 
 6358         public boolean canSetTranslateX() {
 6359             return (translateX == null) || !translateX.isBound();
 6360         }
 6361 
 6362         public boolean canSetTranslateY() {
 6363             return (translateY == null) || !translateY.isBound();
 6364         }
 6365 
 6366         public boolean canSetTranslateZ() {
 6367             return (translateZ == null) || !translateZ.isBound();
 6368         }
 6369 
 6370         public boolean canSetScaleX() {
 6371             return (scaleX == null) || !scaleX.isBound();
 6372         }
 6373 
 6374         public boolean canSetScaleY() {
 6375             return (scaleY == null) || !scaleY.isBound();
 6376         }
 6377 
 6378         public boolean canSetScaleZ() {
 6379             return (scaleZ == null) || !scaleZ.isBound();
 6380         }
 6381 
 6382         public boolean canSetRotate() {
 6383             return (rotate == null) || !rotate.isBound();
 6384         }
 6385 
 6386         public boolean hasTransforms() {
 6387             return (transforms != null &amp;&amp; !transforms.isEmpty());
 6388         }
 6389 
 6390         public boolean hasScaleOrRotate() {
 6391             if (scaleX != null &amp;&amp; scaleX.get() != DEFAULT_SCALE_X) {
 6392                 return true;
 6393             }
 6394             if (scaleY != null &amp;&amp; scaleY.get() != DEFAULT_SCALE_Y) {
 6395                 return true;
 6396             }
 6397             if (scaleZ != null &amp;&amp; scaleZ.get() != DEFAULT_SCALE_Z) {
 6398                 return true;
 6399             }
 6400             if (rotate != null &amp;&amp; rotate.get() != DEFAULT_ROTATE) {
 6401                 return true;
 6402             }
 6403             return false;
 6404         }
 6405 
 6406     }
 6407 
 6408     ////////////////////////////
 6409     //  Private Implementation
 6410     ////////////////////////////
 6411 
 6412     /***************************************************************************
 6413      *                                                                         *
 6414      *                        Event Handler Properties                         *
 6415      *                                                                         *
 6416      **************************************************************************/
 6417 
 6418     private EventHandlerProperties eventHandlerProperties;
 6419 
 6420     private EventHandlerProperties getEventHandlerProperties() {
 6421         if (eventHandlerProperties == null) {
 6422             eventHandlerProperties =
 6423                     new EventHandlerProperties(
 6424                         getInternalEventDispatcher().getEventHandlerManager(),
 6425                         this);
 6426         }
 6427 
 6428         return eventHandlerProperties;
 6429     }
 6430 
 6431     /***************************************************************************
 6432      *                                                                         *
 6433      *                       Component Orientation Properties                  *
 6434      *                                                                         *
 6435      **************************************************************************/
 6436 
 6437     private ObjectProperty&lt;NodeOrientation&gt; nodeOrientation;
 6438     private EffectiveOrientationProperty effectiveNodeOrientationProperty;
 6439 
 6440     private static final byte EFFECTIVE_ORIENTATION_LTR = 0;
 6441     private static final byte EFFECTIVE_ORIENTATION_RTL = 1;
 6442     private static final byte EFFECTIVE_ORIENTATION_MASK = 1;
 6443     private static final byte AUTOMATIC_ORIENTATION_LTR = 0;
 6444     private static final byte AUTOMATIC_ORIENTATION_RTL = 2;
 6445     private static final byte AUTOMATIC_ORIENTATION_MASK = 2;
 6446 
 6447     private byte resolvedNodeOrientation =
 6448             EFFECTIVE_ORIENTATION_LTR | AUTOMATIC_ORIENTATION_LTR;
 6449 
 6450     public final void setNodeOrientation(NodeOrientation orientation) {
 6451         nodeOrientationProperty().set(orientation);
 6452     }
 6453 
 6454     public final NodeOrientation getNodeOrientation() {
 6455         return nodeOrientation == null ? NodeOrientation.INHERIT : nodeOrientation.get();
 6456     }
 6457     /**
 6458      * Property holding NodeOrientation.
 6459      * &lt;p&gt;
 6460      * Node orientation describes the flow of visual data within a node.
 6461      * In the English speaking world, visual data normally flows from
 6462      * left-to-right. In an Arabic or Hebrew world, visual data flows
 6463      * from right-to-left.  This is consistent with the reading order
 6464      * of text in both worlds.  The default value is left-to-right.
 6465      * &lt;/p&gt;
 6466      *
 6467      * @return NodeOrientation
 6468      * @since JavaFX 8.0
 6469      */
 6470     public final ObjectProperty&lt;NodeOrientation&gt; nodeOrientationProperty() {
 6471         if (nodeOrientation == null) {
 6472             nodeOrientation = new StyleableObjectProperty&lt;NodeOrientation&gt;(NodeOrientation.INHERIT) {
 6473                 @Override
 6474                 protected void invalidated() {
 6475                     nodeResolvedOrientationInvalidated();
 6476                 }
 6477 
 6478                 @Override
 6479                 public Object getBean() {
 6480                     return Node.this;
 6481                 }
 6482 
 6483                 @Override
 6484                 public String getName() {
 6485                     return &quot;nodeOrientation&quot;;
 6486                 }
 6487 
 6488                 @Override
 6489                 public CssMetaData getCssMetaData() {
 6490                     //TODO - not supported
 6491                     throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
 6492                 }
 6493 
 6494             };
 6495         }
 6496         return nodeOrientation;
 6497     }
 6498 
 6499     public final NodeOrientation getEffectiveNodeOrientation() {
 6500         return (getEffectiveOrientation(resolvedNodeOrientation)
 6501                     == EFFECTIVE_ORIENTATION_LTR)
 6502                        ? NodeOrientation.LEFT_TO_RIGHT
 6503                        : NodeOrientation.RIGHT_TO_LEFT;
 6504     }
 6505 
 6506     /**
 6507      * The effective orientation of a node resolves the inheritance of
 6508      * node orientation, returning either left-to-right or right-to-left.
 6509      * @return the node orientation for this {@code Node}
 6510      * @since JavaFX 8.0
 6511      */
 6512     public final ReadOnlyObjectProperty&lt;NodeOrientation&gt;
 6513             effectiveNodeOrientationProperty() {
 6514         if (effectiveNodeOrientationProperty == null) {
 6515             effectiveNodeOrientationProperty =
 6516                     new EffectiveOrientationProperty();
 6517         }
 6518 
 6519         return effectiveNodeOrientationProperty;
 6520     }
 6521 
 6522     /**
 6523      * Determines whether a node should be mirrored when node orientation
 6524      * is right-to-left.
 6525      * &lt;p&gt;
 6526      * When a node is mirrored, the origin is automatically moved to the
 6527      * top right corner causing the node to layout children and draw from
 6528      * right to left using a mirroring transformation.  Some nodes may wish
 6529      * to draw from right to left without using a transformation.  These
 6530      * nodes will will answer {@code false} and implement right-to-left
 6531      * orientation without using the automatic transformation.
 6532      * &lt;/p&gt;
 6533      * @return true if this {@code Node} should be mirrored
 6534      * @since JavaFX 8.0
 6535      */
 6536     public boolean usesMirroring() {
 6537         return true;
 6538     }
 6539 
 6540     final void parentResolvedOrientationInvalidated() {
 6541         if (getNodeOrientation() == NodeOrientation.INHERIT) {
 6542             nodeResolvedOrientationInvalidated();
 6543         } else {
 6544             // mirroring changed
 6545             NodeHelper.transformsChanged(this);
 6546         }
 6547     }
 6548 
 6549     final void nodeResolvedOrientationInvalidated() {
 6550         final byte oldResolvedNodeOrientation =
 6551                 resolvedNodeOrientation;
 6552 
 6553         resolvedNodeOrientation =
 6554                 (byte) (calcEffectiveNodeOrientation()
 6555                             | calcAutomaticNodeOrientation());
 6556 
 6557         if ((effectiveNodeOrientationProperty != null)
 6558                 &amp;&amp; (getEffectiveOrientation(resolvedNodeOrientation)
 6559                         != getEffectiveOrientation(
 6560                                oldResolvedNodeOrientation))) {
 6561             effectiveNodeOrientationProperty.invalidate();
 6562         }
 6563 
 6564         // mirroring changed
 6565         NodeHelper.transformsChanged(this);
 6566 
 6567         if (resolvedNodeOrientation != oldResolvedNodeOrientation) {
 6568             nodeResolvedOrientationChanged();
 6569         }
 6570     }
 6571 
 6572     void nodeResolvedOrientationChanged() {
 6573         // overriden in Parent
 6574     }
 6575 
 6576     private Node getMirroringOrientationParent() {
 6577         Node parentValue = getParent();
 6578         while (parentValue != null) {
 6579             if (parentValue.usesMirroring()) {
 6580                 return parentValue;
 6581             }
 6582             parentValue = parentValue.getParent();
 6583         }
 6584 
 6585         final Node subSceneValue = getSubScene();
 6586         if (subSceneValue != null) {
 6587             return subSceneValue;
 6588         }
 6589 
 6590         return null;
 6591     }
 6592 
 6593     private Node getOrientationParent() {
 6594         final Node parentValue = getParent();
 6595         if (parentValue != null) {
 6596             return parentValue;
 6597         }
 6598 
 6599         final Node subSceneValue = getSubScene();
 6600         if (subSceneValue != null) {
 6601             return subSceneValue;
 6602         }
 6603 
 6604         return null;
 6605     }
 6606 
 6607     private byte calcEffectiveNodeOrientation() {
 6608         final NodeOrientation nodeOrientationValue = getNodeOrientation();
 6609         if (nodeOrientationValue != NodeOrientation.INHERIT) {
 6610             return (nodeOrientationValue == NodeOrientation.LEFT_TO_RIGHT)
 6611                        ? EFFECTIVE_ORIENTATION_LTR
 6612                        : EFFECTIVE_ORIENTATION_RTL;
 6613         }
 6614 
 6615         final Node parentValue = getOrientationParent();
 6616         if (parentValue != null) {
 6617             return getEffectiveOrientation(parentValue.resolvedNodeOrientation);
 6618         }
 6619 
 6620         final Scene sceneValue = getScene();
 6621         if (sceneValue != null) {
 6622             return (sceneValue.getEffectiveNodeOrientation()
 6623                         == NodeOrientation.LEFT_TO_RIGHT)
 6624                            ? EFFECTIVE_ORIENTATION_LTR
 6625                            : EFFECTIVE_ORIENTATION_RTL;
 6626         }
 6627 
 6628         return EFFECTIVE_ORIENTATION_LTR;
 6629     }
 6630 
 6631     private byte calcAutomaticNodeOrientation() {
 6632         if (!usesMirroring()) {
 6633             return AUTOMATIC_ORIENTATION_LTR;
 6634         }
 6635 
 6636         final NodeOrientation nodeOrientationValue = getNodeOrientation();
 6637         if (nodeOrientationValue != NodeOrientation.INHERIT) {
 6638             return (nodeOrientationValue == NodeOrientation.LEFT_TO_RIGHT)
 6639                        ? AUTOMATIC_ORIENTATION_LTR
 6640                        : AUTOMATIC_ORIENTATION_RTL;
 6641         }
 6642 
 6643         final Node parentValue = getMirroringOrientationParent();
 6644         if (parentValue != null) {
 6645             // automatic node orientation is inherited
 6646             return getAutomaticOrientation(parentValue.resolvedNodeOrientation);
 6647         }
 6648 
 6649         final Scene sceneValue = getScene();
 6650         if (sceneValue != null) {
 6651             return (sceneValue.getEffectiveNodeOrientation()
 6652                         == NodeOrientation.LEFT_TO_RIGHT)
 6653                            ? AUTOMATIC_ORIENTATION_LTR
 6654                            : AUTOMATIC_ORIENTATION_RTL;
 6655         }
 6656 
 6657         return AUTOMATIC_ORIENTATION_LTR;
 6658     }
 6659 
 6660     // Return true if the node needs to be mirrored.
 6661     // A node has mirroring if the orientation differs from the parent
 6662     // package private for testing
 6663     final boolean hasMirroring() {
 6664         final Node parentValue = getOrientationParent();
 6665 
 6666         final byte thisOrientation =
 6667                 getAutomaticOrientation(resolvedNodeOrientation);
 6668         final byte parentOrientation =
 6669                 (parentValue != null)
 6670                     ? getAutomaticOrientation(
 6671                           parentValue.resolvedNodeOrientation)
 6672                     : AUTOMATIC_ORIENTATION_LTR;
 6673 
 6674         return thisOrientation != parentOrientation;
 6675     }
 6676 
 6677     private static byte getEffectiveOrientation(
 6678             final byte resolvedNodeOrientation) {
 6679         return (byte) (resolvedNodeOrientation &amp; EFFECTIVE_ORIENTATION_MASK);
 6680     }
 6681 
 6682     private static byte getAutomaticOrientation(
 6683             final byte resolvedNodeOrientation) {
 6684         return (byte) (resolvedNodeOrientation &amp; AUTOMATIC_ORIENTATION_MASK);
 6685     }
 6686 
 6687     private final class EffectiveOrientationProperty
 6688             extends ReadOnlyObjectPropertyBase&lt;NodeOrientation&gt; {
 6689         @Override
 6690         public NodeOrientation get() {
 6691             return getEffectiveNodeOrientation();
 6692         }
 6693 
 6694         @Override
 6695         public Object getBean() {
 6696             return Node.this;
 6697         }
 6698 
 6699         @Override
 6700         public String getName() {
 6701             return &quot;effectiveNodeOrientation&quot;;
 6702         }
 6703 
 6704         public void invalidate() {
 6705             fireValueChangedEvent();
 6706         }
 6707     }
 6708 
 6709     /***************************************************************************
 6710      *                                                                         *
 6711      *                       Misc Seldom Used Properties                       *
 6712      *                                                                         *
 6713      **************************************************************************/
 6714 
 6715     private MiscProperties miscProperties;
 6716 
 6717     private MiscProperties getMiscProperties() {
 6718         if (miscProperties == null) {
 6719             miscProperties = new MiscProperties();
 6720         }
 6721 
 6722         return miscProperties;
 6723     }
 6724 
 6725     private static final double DEFAULT_VIEW_ORDER = 0;
 6726     private static final boolean DEFAULT_CACHE = false;
 6727     private static final CacheHint DEFAULT_CACHE_HINT = CacheHint.DEFAULT;
 6728     private static final Node DEFAULT_CLIP = null;
 6729     private static final Cursor DEFAULT_CURSOR = null;
 6730     private static final DepthTest DEFAULT_DEPTH_TEST = DepthTest.INHERIT;
 6731     private static final boolean DEFAULT_DISABLE = false;
 6732     private static final Effect DEFAULT_EFFECT = null;
 6733     private static final InputMethodRequests DEFAULT_INPUT_METHOD_REQUESTS =
 6734             null;
 6735     private static final boolean DEFAULT_MOUSE_TRANSPARENT = false;
 6736 
 6737     private final class MiscProperties {
 6738         private LazyBoundsProperty boundsInParent;
 6739         private LazyBoundsProperty boundsInLocal;
 6740         private BooleanProperty cache;
 6741         private ObjectProperty&lt;CacheHint&gt; cacheHint;
 6742         private ObjectProperty&lt;Node&gt; clip;
 6743         private ObjectProperty&lt;Cursor&gt; cursor;
 6744         private ObjectProperty&lt;DepthTest&gt; depthTest;
 6745         private BooleanProperty disable;
 6746         private ObjectProperty&lt;Effect&gt; effect;
 6747         private ObjectProperty&lt;InputMethodRequests&gt; inputMethodRequests;
 6748         private BooleanProperty mouseTransparent;
 6749         private DoubleProperty viewOrder;
 6750 
 6751         public double getViewOrder() {
 6752             return (viewOrder == null) ? DEFAULT_VIEW_ORDER : viewOrder.get();
 6753         }
 6754 
 6755         public final DoubleProperty viewOrderProperty() {
 6756             if (viewOrder == null) {
 6757                 viewOrder = new StyleableDoubleProperty(DEFAULT_VIEW_ORDER) {
 6758                     @Override
 6759                     public void invalidated() {
 6760                         Parent p = getParent();
 6761                         if (p != null) {
 6762                             // Parent will be responsible to update sorted children list
 6763                             p.markViewOrderChildrenDirty();
 6764                         }
 6765                         NodeHelper.markDirty(Node.this, DirtyBits.NODE_VIEW_ORDER);
 6766                     }
 6767 
 6768                     @Override
 6769                     public CssMetaData getCssMetaData() {
 6770                         return StyleableProperties.VIEW_ORDER;
 6771                     }
 6772 
 6773                     @Override
 6774                     public Object getBean() {
 6775                         return Node.this;
 6776                     }
 6777 
 6778                     @Override
 6779                     public String getName() {
 6780                         return &quot;viewOrder&quot;;
 6781                     }
 6782                 };
 6783             }
 6784             return viewOrder;
 6785         }
 6786 
 6787         public final Bounds getBoundsInParent() {
 6788             return boundsInParentProperty().get();
 6789         }
 6790 
 6791         public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInParentProperty() {
 6792             if (boundsInParent == null) {
 6793                 boundsInParent = new LazyBoundsProperty() {
 6794                     /**
 6795                      * Computes the bounds including the clip, effects, and all
 6796                      * transforms. This function is essentially how to compute
 6797                      * the boundsInParent. Optimizations are made to compute as
 6798                      * little as possible and create as little trash as
 6799                      * possible.
 6800                      */
 6801                     @Override
 6802                     protected Bounds computeBounds() {
 6803                         BaseBounds tempBounds = TempState.getInstance().bounds;
 6804                         tempBounds = getTransformedBounds(
 6805                                              tempBounds,
 6806                                              BaseTransform.IDENTITY_TRANSFORM);
 6807                         return new BoundingBox(tempBounds.getMinX(),
 6808                                                tempBounds.getMinY(),
 6809                                                tempBounds.getMinZ(),
 6810                                                tempBounds.getWidth(),
 6811                                                tempBounds.getHeight(),
 6812                                                tempBounds.getDepth());
 6813                     }
 6814 
 6815                     @Override
 6816                     public Object getBean() {
 6817                         return Node.this;
 6818                     }
 6819 
 6820                     @Override
 6821                     public String getName() {
 6822                         return &quot;boundsInParent&quot;;
 6823                     }
 6824                 };
 6825             }
 6826 
 6827             return boundsInParent;
 6828         }
 6829 
 6830         public void invalidateBoundsInParent() {
 6831             if (boundsInParent != null) {
 6832                 boundsInParent.invalidate();
 6833             }
 6834         }
 6835 
 6836         public final Bounds getBoundsInLocal() {
 6837             return boundsInLocalProperty().get();
 6838         }
 6839 
 6840         public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInLocalProperty() {
 6841             if (boundsInLocal == null) {
 6842                 boundsInLocal = new LazyBoundsProperty() {
 6843                     @Override
 6844                     protected Bounds computeBounds() {
 6845                         BaseBounds tempBounds = TempState.getInstance().bounds;
 6846                         tempBounds = getLocalBounds(
 6847                                              tempBounds,
 6848                                              BaseTransform.IDENTITY_TRANSFORM);
 6849                         return new BoundingBox(tempBounds.getMinX(),
 6850                                                tempBounds.getMinY(),
 6851                                                tempBounds.getMinZ(),
 6852                                                tempBounds.getWidth(),
 6853                                                tempBounds.getHeight(),
 6854                                                tempBounds.getDepth());
 6855                     }
 6856 
 6857                     @Override
 6858                     public Object getBean() {
 6859                         return Node.this;
 6860                     }
 6861 
 6862                     @Override
 6863                     public String getName() {
 6864                         return &quot;boundsInLocal&quot;;
 6865                     }
 6866                 };
 6867             }
 6868 
 6869             return boundsInLocal;
 6870         }
 6871 
 6872         public void invalidateBoundsInLocal() {
 6873             if (boundsInLocal != null) {
 6874                 boundsInLocal.invalidate();
 6875             }
 6876         }
 6877 
 6878         public final boolean isCache() {
 6879             return (cache == null) ? DEFAULT_CACHE
 6880                                    : cache.get();
 6881         }
 6882 
 6883         public final BooleanProperty cacheProperty() {
 6884             if (cache == null) {
 6885                 cache = new BooleanPropertyBase(DEFAULT_CACHE) {
 6886                     @Override
 6887                     protected void invalidated() {
 6888                         NodeHelper.markDirty(Node.this, DirtyBits.NODE_CACHE);
 6889                     }
 6890 
 6891                     @Override
 6892                     public Object getBean() {
 6893                         return Node.this;
 6894                     }
 6895 
 6896                     @Override
 6897                     public String getName() {
 6898                         return &quot;cache&quot;;
 6899                     }
 6900                 };
 6901             }
 6902             return cache;
 6903         }
 6904 
 6905         public final CacheHint getCacheHint() {
 6906             return (cacheHint == null) ? DEFAULT_CACHE_HINT
 6907                                        : cacheHint.get();
 6908         }
 6909 
 6910         public final ObjectProperty&lt;CacheHint&gt; cacheHintProperty() {
 6911             if (cacheHint == null) {
 6912                 cacheHint = new ObjectPropertyBase&lt;CacheHint&gt;(DEFAULT_CACHE_HINT) {
 6913                     @Override
 6914                     protected void invalidated() {
 6915                         NodeHelper.markDirty(Node.this, DirtyBits.NODE_CACHE);
 6916                     }
 6917 
 6918                     @Override
 6919                     public Object getBean() {
 6920                         return Node.this;
 6921                     }
 6922 
 6923                     @Override
 6924                     public String getName() {
 6925                         return &quot;cacheHint&quot;;
 6926                     }
 6927                 };
 6928             }
 6929             return cacheHint;
 6930         }
 6931 
 6932         public final Node getClip() {
 6933             return (clip == null) ? DEFAULT_CLIP : clip.get();
 6934         }
 6935 
 6936         public final ObjectProperty&lt;Node&gt; clipProperty() {
 6937             if (clip == null) {
 6938                 clip = new ObjectPropertyBase&lt;Node&gt;(DEFAULT_CLIP) {
 6939 
 6940                     //temp variables used when clip was invalid to rollback to
 6941                     // last value
 6942                     private Node oldClip;
 6943 
 6944                     @Override
 6945                     protected void invalidated() {
 6946                         final Node newClip = get();
 6947                         if ((newClip != null)
 6948                                 &amp;&amp; ((newClip.isConnected()
 6949                                            &amp;&amp; newClip.clipParent != Node.this)
 6950                                        || wouldCreateCycle(Node.this,
 6951                                                            newClip))) {
 6952                             // Assigning this node to clip is illegal.
 6953                             // Roll back to the previous state and throw an
 6954                             // exception.
 6955                             final String cause =
 6956                                     newClip.isConnected()
 6957                                         &amp;&amp; (newClip.clipParent != Node.this)
 6958                                             ? &quot;node already connected&quot;
 6959                                             : &quot;cycle detected&quot;;
 6960 
 6961                             if (isBound()) {
 6962                                 unbind();
 6963                                 set(oldClip);
 6964                                 throw new IllegalArgumentException(
 6965                                         &quot;Node&#39;s clip set to incorrect value &quot;
 6966                                             + &quot; through binding&quot;
 6967                                             + &quot; (&quot; + cause + &quot;, node  = &quot;
 6968                                                    + Node.this + &quot;, clip = &quot;
 6969                                                    + clip + &quot;).&quot;
 6970                                             + &quot; Binding has been removed.&quot;);
 6971                             } else {
 6972                                 set(oldClip);
 6973                                 throw new IllegalArgumentException(
 6974                                         &quot;Node&#39;s clip set to incorrect value&quot;
 6975                                             + &quot; (&quot; + cause + &quot;, node  = &quot;
 6976                                                    + Node.this + &quot;, clip = &quot;
 6977                                                    + clip + &quot;).&quot;);
 6978                             }
 6979                         } else {
 6980                             if (oldClip != null) {
 6981                                 oldClip.clipParent = null;
 6982                                 oldClip.setScenes(null, null);
 6983                                 oldClip.updateTreeVisible(false);
 6984                             }
 6985 
 6986                             if (newClip != null) {
 6987                                 newClip.clipParent = Node.this;
 6988                                 newClip.setScenes(getScene(), getSubScene());
 6989                                 newClip.updateTreeVisible(true);
 6990                             }
 6991 
 6992                             NodeHelper.markDirty(Node.this, DirtyBits.NODE_CLIP);
 6993 
 6994                             // the local bounds have (probably) changed
 6995                             localBoundsChanged();
 6996 
 6997                             oldClip = newClip;
 6998                         }
 6999                     }
 7000 
 7001                     @Override
 7002                     public Object getBean() {
 7003                         return Node.this;
 7004                     }
 7005 
 7006                     @Override
 7007                     public String getName() {
 7008                         return &quot;clip&quot;;
 7009                     }
 7010                 };
 7011             }
 7012             return clip;
 7013         }
 7014 
 7015         public final Cursor getCursor() {
 7016             return (cursor == null) ? DEFAULT_CURSOR : cursor.get();
 7017         }
 7018 
 7019         public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
 7020             if (cursor == null) {
 7021                 cursor = new StyleableObjectProperty&lt;Cursor&gt;(DEFAULT_CURSOR) {
 7022 
 7023                     @Override
 7024                     protected void invalidated() {
 7025                         final Scene sceneValue = getScene();
 7026                         if (sceneValue != null) {
 7027                             sceneValue.markCursorDirty();
 7028                         }
 7029                     }
 7030 
 7031                     @Override
 7032                     public CssMetaData getCssMetaData() {
 7033                         return StyleableProperties.CURSOR;
 7034                     }
 7035 
 7036                     @Override
 7037                     public Object getBean() {
 7038                         return Node.this;
 7039                     }
 7040 
 7041                     @Override
 7042                     public String getName() {
 7043                         return &quot;cursor&quot;;
 7044                     }
 7045 
 7046                 };
 7047             }
 7048             return cursor;
 7049         }
 7050 
 7051         public final DepthTest getDepthTest() {
 7052             return (depthTest == null) ? DEFAULT_DEPTH_TEST
 7053                                        : depthTest.get();
 7054         }
 7055 
 7056         public final ObjectProperty&lt;DepthTest&gt; depthTestProperty() {
 7057             if (depthTest == null) {
 7058                 depthTest = new ObjectPropertyBase&lt;DepthTest&gt;(DEFAULT_DEPTH_TEST) {
 7059                     @Override protected void invalidated() {
 7060                         computeDerivedDepthTest();
 7061                     }
 7062 
 7063                     @Override
 7064                     public Object getBean() {
 7065                         return Node.this;
 7066                     }
 7067 
 7068                     @Override
 7069                     public String getName() {
 7070                         return &quot;depthTest&quot;;
 7071                     }
 7072                 };
 7073             }
 7074             return depthTest;
 7075         }
 7076 
 7077         public final boolean isDisable() {
 7078             return (disable == null) ? DEFAULT_DISABLE : disable.get();
 7079         }
 7080 
 7081         public final BooleanProperty disableProperty() {
 7082             if (disable == null) {
 7083                 disable = new BooleanPropertyBase(DEFAULT_DISABLE) {
 7084                     @Override
 7085                     protected void invalidated() {
 7086                         updateDisabled();
 7087                     }
 7088 
 7089                     @Override
 7090                     public Object getBean() {
 7091                         return Node.this;
 7092                     }
 7093 
 7094                     @Override
 7095                     public String getName() {
 7096                         return &quot;disable&quot;;
 7097                     }
 7098                 };
 7099             }
 7100             return disable;
 7101         }
 7102 
 7103         public final Effect getEffect() {
 7104             return (effect == null) ? DEFAULT_EFFECT : effect.get();
 7105         }
 7106 
 7107         public final ObjectProperty&lt;Effect&gt; effectProperty() {
 7108             if (effect == null) {
 7109                 effect = new StyleableObjectProperty&lt;Effect&gt;(DEFAULT_EFFECT) {
 7110                     private Effect oldEffect = null;
 7111                     private int oldBits;
 7112 
 7113                     private final AbstractNotifyListener effectChangeListener =
 7114                             new AbstractNotifyListener() {
 7115 
 7116                         @Override
 7117                         public void invalidated(Observable valueModel) {
 7118                             int newBits = ((IntegerProperty) valueModel).get();
 7119                             int changedBits = newBits ^ oldBits;
 7120                             oldBits = newBits;
 7121                             if (EffectDirtyBits.isSet(
 7122                                     changedBits,
 7123                                     EffectDirtyBits.EFFECT_DIRTY)
 7124                                 &amp;&amp; EffectDirtyBits.isSet(
 7125                                        newBits,
 7126                                        EffectDirtyBits.EFFECT_DIRTY)) {
 7127                                 NodeHelper.markDirty(Node.this, DirtyBits.EFFECT_EFFECT);
 7128                             }
 7129                             if (EffectDirtyBits.isSet(
 7130                                     changedBits,
 7131                                     EffectDirtyBits.BOUNDS_CHANGED)) {
 7132                                 localBoundsChanged();
 7133                             }
 7134                         }
 7135                     };
 7136 
 7137                     @Override
 7138                     protected void invalidated() {
 7139                         Effect _effect = get();
 7140                         if (oldEffect != null) {
 7141                             EffectHelper.effectDirtyProperty(oldEffect).removeListener(
 7142                                     effectChangeListener.getWeakListener());
 7143                         }
 7144                         oldEffect = _effect;
 7145                         if (_effect != null) {
 7146                             EffectHelper.effectDirtyProperty(_effect)
 7147                                    .addListener(
 7148                                        effectChangeListener.getWeakListener());
 7149                             if (EffectHelper.isEffectDirty(_effect)) {
 7150                                 NodeHelper.markDirty(Node.this, DirtyBits.EFFECT_EFFECT);
 7151                             }
 7152                             oldBits = EffectHelper.effectDirtyProperty(_effect).get();
 7153                         }
 7154 
 7155                         NodeHelper.markDirty(Node.this, DirtyBits.NODE_EFFECT);
 7156                         // bounds may have changed regardless whether
 7157                         // the dirty flag on effect is set
 7158                         localBoundsChanged();
 7159                     }
 7160 
 7161                     @Override
 7162                     public CssMetaData getCssMetaData() {
 7163                         return StyleableProperties.EFFECT;
 7164                     }
 7165 
 7166                     @Override
 7167                     public Object getBean() {
 7168                         return Node.this;
 7169                     }
 7170 
 7171                     @Override
 7172                     public String getName() {
 7173                         return &quot;effect&quot;;
 7174                     }
 7175                 };
 7176             }
 7177             return effect;
 7178         }
 7179 
 7180         public final InputMethodRequests getInputMethodRequests() {
 7181             return (inputMethodRequests == null) ? DEFAULT_INPUT_METHOD_REQUESTS
 7182                                                  : inputMethodRequests.get();
 7183         }
 7184 
 7185         public ObjectProperty&lt;InputMethodRequests&gt;
 7186                 inputMethodRequestsProperty() {
 7187             if (inputMethodRequests == null) {
 7188                 inputMethodRequests =
 7189                         new SimpleObjectProperty&lt;InputMethodRequests&gt;(
 7190                                 Node.this,
 7191                                 &quot;inputMethodRequests&quot;,
 7192                                 DEFAULT_INPUT_METHOD_REQUESTS);
 7193             }
 7194             return inputMethodRequests;
 7195         }
 7196 
 7197         public final boolean isMouseTransparent() {
 7198             return (mouseTransparent == null) ? DEFAULT_MOUSE_TRANSPARENT
 7199                                               : mouseTransparent.get();
 7200         }
 7201 
 7202         public final BooleanProperty mouseTransparentProperty() {
 7203             if (mouseTransparent == null) {
 7204                 mouseTransparent =
 7205                         new SimpleBooleanProperty(
 7206                                 Node.this,
 7207                                 &quot;mouseTransparent&quot;,
 7208                                 DEFAULT_MOUSE_TRANSPARENT);
 7209             }
 7210             return mouseTransparent;
 7211         }
 7212 
 7213         public boolean canSetCursor() {
 7214             return (cursor == null) || !cursor.isBound();
 7215         }
 7216 
 7217         public boolean canSetEffect() {
 7218             return (effect == null) || !effect.isBound();
 7219         }
 7220     }
 7221 
 7222     /* *************************************************************************
 7223      *                                                                         *
 7224      *                             Mouse Handling                              *
 7225      *                                                                         *
 7226      **************************************************************************/
 7227 
 7228     public final void setMouseTransparent(boolean value) {
 7229         mouseTransparentProperty().set(value);
 7230     }
 7231 
 7232     public final boolean isMouseTransparent() {
 7233         return (miscProperties == null) ? DEFAULT_MOUSE_TRANSPARENT
 7234                                         : miscProperties.isMouseTransparent();
 7235     }
 7236 
 7237     /**
 7238      * If {@code true}, this node (together with all its children) is completely
 7239      * transparent to mouse events. When choosing target for mouse event, nodes
 7240      * with {@code mouseTransparent} set to {@code true} and their subtrees
 7241      * won&#39;t be taken into account.
 7242      * @return is this {@code Node} (together with all its children) is completely
 7243      * transparent to mouse events.
 7244      */
 7245     public final BooleanProperty mouseTransparentProperty() {
 7246         return getMiscProperties().mouseTransparentProperty();
 7247     }
 7248 
 7249     /**
 7250      * Whether or not this {@code Node} is being hovered over. Typically this is
 7251      * due to the mouse being over the node, though it could be due to a pen
 7252      * hovering on a graphics tablet or other form of input.
 7253      *
 7254      * &lt;p&gt;Note that current implementation of hover relies on mouse enter and
 7255      * exit events to determine whether this Node is in the hover state; this
 7256      * means that this feature is currently supported only on systems that
 7257      * have a mouse. Future implementations may provide alternative means of
 7258      * supporting hover.
 7259      *
 7260      * @defaultValue false
 7261      */
 7262     private ReadOnlyBooleanWrapper hover;
 7263 
 7264     protected final void setHover(boolean value) {
 7265         hoverPropertyImpl().set(value);
 7266     }
 7267 
 7268     public final boolean isHover() {
 7269         return hover == null ? false : hover.get();
 7270     }
 7271 
 7272     public final ReadOnlyBooleanProperty hoverProperty() {
 7273         return hoverPropertyImpl().getReadOnlyProperty();
 7274     }
 7275 
 7276     private ReadOnlyBooleanWrapper hoverPropertyImpl() {
 7277         if (hover == null) {
 7278             hover = new ReadOnlyBooleanWrapper() {
 7279 
 7280                 @Override
 7281                 protected void invalidated() {
 7282                     PlatformLogger logger = Logging.getInputLogger();
 7283                     if (logger.isLoggable(Level.FINER)) {
 7284                         logger.finer(this + &quot; hover=&quot; + get());
 7285                     }
 7286                     pseudoClassStateChanged(HOVER_PSEUDOCLASS_STATE, get());
 7287                 }
 7288 
 7289                 @Override
 7290                 public Object getBean() {
 7291                     return Node.this;
 7292                 }
 7293 
 7294                 @Override
 7295                 public String getName() {
 7296                     return &quot;hover&quot;;
 7297                 }
 7298             };
 7299         }
 7300         return hover;
 7301     }
 7302 
 7303     /**
 7304      * Whether or not the {@code Node} is pressed. Typically this is true when
 7305      * the primary mouse button is down, though subclasses may define other
 7306      * mouse button state or key state to cause the node to be &quot;pressed&quot;.
 7307      *
 7308      * @defaultValue false
 7309      */
 7310     private ReadOnlyBooleanWrapper pressed;
 7311 
 7312     protected final void setPressed(boolean value) {
 7313         pressedPropertyImpl().set(value);
 7314     }
 7315 
 7316     public final boolean isPressed() {
 7317         return pressed == null ? false : pressed.get();
 7318     }
 7319 
 7320     public final ReadOnlyBooleanProperty pressedProperty() {
 7321         return pressedPropertyImpl().getReadOnlyProperty();
 7322     }
 7323 
 7324     private ReadOnlyBooleanWrapper pressedPropertyImpl() {
 7325         if (pressed == null) {
 7326             pressed = new ReadOnlyBooleanWrapper() {
 7327 
 7328                 @Override
 7329                 protected void invalidated() {
 7330                     PlatformLogger logger = Logging.getInputLogger();
 7331                     if (logger.isLoggable(Level.FINER)) {
 7332                         logger.finer(this + &quot; pressed=&quot; + get());
 7333                     }
 7334                     pseudoClassStateChanged(PRESSED_PSEUDOCLASS_STATE, get());
 7335                 }
 7336 
 7337                 @Override
 7338                 public Object getBean() {
 7339                     return Node.this;
 7340                 }
 7341 
 7342                 @Override
 7343                 public String getName() {
 7344                     return &quot;pressed&quot;;
 7345                 }
 7346             };
 7347         }
 7348         return pressed;
 7349     }
 7350 
 7351     public final void setOnContextMenuRequested(
 7352             EventHandler&lt;? super ContextMenuEvent&gt; value) {
 7353         onContextMenuRequestedProperty().set(value);
 7354     }
 7355 
 7356     public final EventHandler&lt;? super ContextMenuEvent&gt; getOnContextMenuRequested() {
 7357         return (eventHandlerProperties == null)
 7358                 ? null : eventHandlerProperties.onContextMenuRequested();
 7359     }
 7360 
 7361     /**
 7362      * Defines a function to be called when a context menu
 7363      * has been requested on this {@code Node}.
 7364      * @return the event handler that is called when a context menu has been
 7365      * requested on this {@code Node}
 7366      * @since JavaFX 2.1
 7367      */
 7368     public final ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt;
 7369             onContextMenuRequestedProperty() {
 7370         return getEventHandlerProperties().onContextMenuRequestedProperty();
 7371     }
 7372 
 7373     public final void setOnMouseClicked(
 7374             EventHandler&lt;? super MouseEvent&gt; value) {
 7375         onMouseClickedProperty().set(value);
 7376     }
 7377 
 7378     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseClicked() {
 7379         return (eventHandlerProperties == null)
 7380                 ? null : eventHandlerProperties.getOnMouseClicked();
 7381     }
 7382 
 7383     /**
 7384      * Defines a function to be called when a mouse button has been clicked
 7385      * (pressed and released) on this {@code Node}.
 7386      * @return the event handler that is called when a mouse button has been
 7387      * clicked (pressed and released) on this {@code Node}
 7388      */
 7389     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7390             onMouseClickedProperty() {
 7391         return getEventHandlerProperties().onMouseClickedProperty();
 7392     }
 7393 
 7394     public final void setOnMouseDragged(
 7395             EventHandler&lt;? super MouseEvent&gt; value) {
 7396         onMouseDraggedProperty().set(value);
 7397     }
 7398 
 7399     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseDragged() {
 7400         return (eventHandlerProperties == null)
 7401                 ? null : eventHandlerProperties.getOnMouseDragged();
 7402     }
 7403 
 7404     /**
 7405      * Defines a function to be called when a mouse button is pressed
 7406      * on this {@code Node} and then dragged.
 7407      * @return the event handler that is called when a mouse button is pressed
 7408      * on this {@code Node} and then dragged
 7409      */
 7410     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7411             onMouseDraggedProperty() {
 7412         return getEventHandlerProperties().onMouseDraggedProperty();
 7413     }
 7414 
 7415     public final void setOnMouseEntered(
 7416             EventHandler&lt;? super MouseEvent&gt; value) {
 7417         onMouseEnteredProperty().set(value);
 7418     }
 7419 
 7420     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseEntered() {
 7421         return (eventHandlerProperties == null)
 7422                 ? null : eventHandlerProperties.getOnMouseEntered();
 7423     }
 7424 
 7425     /**
 7426      * Defines a function to be called when the mouse enters this {@code Node}.
 7427      * @return the event handler that is called when a mouse enters this
 7428      * {@code Node}
 7429      */
 7430     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7431             onMouseEnteredProperty() {
 7432         return getEventHandlerProperties().onMouseEnteredProperty();
 7433     }
 7434 
 7435     public final void setOnMouseExited(
 7436             EventHandler&lt;? super MouseEvent&gt; value) {
 7437         onMouseExitedProperty().set(value);
 7438     }
 7439 
 7440     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseExited() {
 7441         return (eventHandlerProperties == null)
 7442                 ? null : eventHandlerProperties.getOnMouseExited();
 7443     }
 7444 
 7445     /**
 7446      * Defines a function to be called when the mouse exits this {@code Node}.
 7447      * @return the event handler that is called when a mouse exits this
 7448      * {@code Node}
 7449      */
 7450     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7451             onMouseExitedProperty() {
 7452         return getEventHandlerProperties().onMouseExitedProperty();
 7453     }
 7454 
 7455     public final void setOnMouseMoved(
 7456             EventHandler&lt;? super MouseEvent&gt; value) {
 7457         onMouseMovedProperty().set(value);
 7458     }
 7459 
 7460     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseMoved() {
 7461         return (eventHandlerProperties == null)
 7462                 ? null : eventHandlerProperties.getOnMouseMoved();
 7463     }
 7464 
 7465     /**
 7466      * Defines a function to be called when mouse cursor moves within
 7467      * this {@code Node} but no buttons have been pushed.
 7468      * @return the event handler that is called when a mouse cursor moves
 7469      * within this {@code Node} but no buttons have been pushed
 7470      */
 7471     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7472             onMouseMovedProperty() {
 7473         return getEventHandlerProperties().onMouseMovedProperty();
 7474     }
 7475 
 7476     public final void setOnMousePressed(
 7477             EventHandler&lt;? super MouseEvent&gt; value) {
 7478         onMousePressedProperty().set(value);
 7479     }
 7480 
 7481     public final EventHandler&lt;? super MouseEvent&gt; getOnMousePressed() {
 7482         return (eventHandlerProperties == null)
 7483                 ? null : eventHandlerProperties.getOnMousePressed();
 7484     }
 7485 
 7486     /**
 7487      * Defines a function to be called when a mouse button
 7488      * has been pressed on this {@code Node}.
 7489      * @return the event handler that is called when a mouse button has been
 7490      * pressed on this {@code Node}
 7491      */
 7492     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7493             onMousePressedProperty() {
 7494         return getEventHandlerProperties().onMousePressedProperty();
 7495     }
 7496 
 7497     public final void setOnMouseReleased(
 7498             EventHandler&lt;? super MouseEvent&gt; value) {
 7499         onMouseReleasedProperty().set(value);
 7500     }
 7501 
 7502     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseReleased() {
 7503         return (eventHandlerProperties == null)
 7504                 ? null : eventHandlerProperties.getOnMouseReleased();
 7505     }
 7506 
 7507     /**
 7508      * Defines a function to be called when a mouse button
 7509      * has been released on this {@code Node}.
 7510      * @return the event handler that is called when a mouse button has been
 7511      * released on this {@code Node}
 7512      */
 7513     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7514             onMouseReleasedProperty() {
 7515         return getEventHandlerProperties().onMouseReleasedProperty();
 7516     }
 7517 
 7518     public final void setOnDragDetected(
 7519             EventHandler&lt;? super MouseEvent&gt; value) {
 7520         onDragDetectedProperty().set(value);
 7521     }
 7522 
 7523     public final EventHandler&lt;? super MouseEvent&gt; getOnDragDetected() {
 7524         return (eventHandlerProperties == null)
 7525                 ? null : eventHandlerProperties.getOnDragDetected();
 7526     }
 7527 
 7528     /**
 7529      * Defines a function to be called when drag gesture has been
 7530      * detected. This is the right place to start drag and drop operation.
 7531      * @return the event handler that is called when drag gesture has been
 7532      * detected
 7533      */
 7534     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7535             onDragDetectedProperty() {
 7536         return getEventHandlerProperties().onDragDetectedProperty();
 7537     }
 7538 
 7539     public final void setOnMouseDragOver(
 7540             EventHandler&lt;? super MouseDragEvent&gt; value) {
 7541         onMouseDragOverProperty().set(value);
 7542     }
 7543 
 7544     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragOver() {
 7545         return (eventHandlerProperties == null)
 7546                 ? null : eventHandlerProperties.getOnMouseDragOver();
 7547     }
 7548 
 7549     /**
 7550      * Defines a function to be called when a full press-drag-release gesture
 7551      * progresses within this {@code Node}.
 7552      * @return the event handler that is called when a full press-drag-release
 7553      * gesture progresses within this {@code Node}
 7554      * @since JavaFX 2.1
 7555      */
 7556     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
 7557             onMouseDragOverProperty() {
 7558         return getEventHandlerProperties().onMouseDragOverProperty();
 7559     }
 7560 
 7561     public final void setOnMouseDragReleased(
 7562             EventHandler&lt;? super MouseDragEvent&gt; value) {
 7563         onMouseDragReleasedProperty().set(value);
 7564     }
 7565 
 7566     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragReleased() {
 7567         return (eventHandlerProperties == null)
 7568                 ? null : eventHandlerProperties.getOnMouseDragReleased();
 7569     }
 7570 
 7571     /**
 7572      * Defines a function to be called when a full press-drag-release gesture
 7573      * ends (by releasing mouse button) within this {@code Node}.
 7574      * @return the event handler that is called when a full press-drag-release
 7575      * gesture ends (by releasing mouse button) within this {@code Node}
 7576      * @since JavaFX 2.1
 7577      */
 7578     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
 7579             onMouseDragReleasedProperty() {
 7580         return getEventHandlerProperties().onMouseDragReleasedProperty();
 7581     }
 7582 
 7583     public final void setOnMouseDragEntered(
 7584             EventHandler&lt;? super MouseDragEvent&gt; value) {
 7585         onMouseDragEnteredProperty().set(value);
 7586     }
 7587 
 7588     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragEntered() {
 7589         return (eventHandlerProperties == null)
 7590                 ? null : eventHandlerProperties.getOnMouseDragEntered();
 7591     }
 7592 
 7593     /**
 7594      * Defines a function to be called when a full press-drag-release gesture
 7595      * enters this {@code Node}.
 7596      * @return the event handler that is called when a full press-drag-release
 7597      * gesture enters this {@code Node}
 7598      * @since JavaFX 2.1
 7599      */
 7600     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
 7601             onMouseDragEnteredProperty() {
 7602         return getEventHandlerProperties().onMouseDragEnteredProperty();
 7603     }
 7604 
 7605     public final void setOnMouseDragExited(
 7606             EventHandler&lt;? super MouseDragEvent&gt; value) {
 7607         onMouseDragExitedProperty().set(value);
 7608     }
 7609 
 7610     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragExited() {
 7611         return (eventHandlerProperties == null)
 7612                 ? null : eventHandlerProperties.getOnMouseDragExited();
 7613     }
 7614 
 7615     /**
 7616      * Defines a function to be called when a full press-drag-release gesture
 7617      * leaves this {@code Node}.
 7618      * @return the event handler that is called when a full press-drag-release
 7619      * gesture leaves this {@code Node}
 7620      * @since JavaFX 2.1
 7621      */
 7622     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
 7623             onMouseDragExitedProperty() {
 7624         return getEventHandlerProperties().onMouseDragExitedProperty();
 7625     }
 7626 
 7627 
 7628     /* *************************************************************************
 7629      *                                                                         *
 7630      *                           Gestures Handling                             *
 7631      *                                                                         *
 7632      **************************************************************************/
 7633 
 7634     public final void setOnScrollStarted(
 7635             EventHandler&lt;? super ScrollEvent&gt; value) {
 7636         onScrollStartedProperty().set(value);
 7637     }
 7638 
 7639     public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollStarted() {
 7640         return (eventHandlerProperties == null)
 7641                 ? null : eventHandlerProperties.getOnScrollStarted();
 7642     }
 7643 
 7644     /**
 7645      * Defines a function to be called when a scrolling gesture is detected.
 7646      * @return the event handler that is called when a scrolling gesture is
 7647      * detected
 7648      * @since JavaFX 2.2
 7649      */
 7650     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;
 7651             onScrollStartedProperty() {
 7652         return getEventHandlerProperties().onScrollStartedProperty();
 7653     }
 7654 
 7655     public final void setOnScroll(
 7656             EventHandler&lt;? super ScrollEvent&gt; value) {
 7657         onScrollProperty().set(value);
 7658     }
 7659 
 7660     public final EventHandler&lt;? super ScrollEvent&gt; getOnScroll() {
 7661         return (eventHandlerProperties == null)
 7662                 ? null : eventHandlerProperties.getOnScroll();
 7663     }
 7664 
 7665     /**
 7666      * Defines a function to be called when user performs a scrolling action.
 7667      * @return the event handler that is called when user performs a scrolling
 7668      * action
 7669      */
 7670     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;
 7671             onScrollProperty() {
 7672         return getEventHandlerProperties().onScrollProperty();
 7673     }
 7674 
 7675     public final void setOnScrollFinished(
 7676             EventHandler&lt;? super ScrollEvent&gt; value) {
 7677         onScrollFinishedProperty().set(value);
 7678     }
 7679 
 7680     public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollFinished() {
 7681         return (eventHandlerProperties == null)
 7682                 ? null : eventHandlerProperties.getOnScrollFinished();
 7683     }
 7684 
 7685     /**
 7686      * Defines a function to be called when a scrolling gesture ends.
 7687      * @return the event handler that is called when a scrolling gesture ends
 7688      * @since JavaFX 2.2
 7689      */
 7690     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;
 7691             onScrollFinishedProperty() {
 7692         return getEventHandlerProperties().onScrollFinishedProperty();
 7693     }
 7694 
 7695     public final void setOnRotationStarted(
 7696             EventHandler&lt;? super RotateEvent&gt; value) {
 7697         onRotationStartedProperty().set(value);
 7698     }
 7699 
 7700     public final EventHandler&lt;? super RotateEvent&gt; getOnRotationStarted() {
 7701         return (eventHandlerProperties == null)
 7702                 ? null : eventHandlerProperties.getOnRotationStarted();
 7703     }
 7704 
 7705     /**
 7706      * Defines a function to be called when a rotation gesture is detected.
 7707      * @return the event handler that is called when a rotation gesture is
 7708      * detected
 7709      * @since JavaFX 2.2
 7710      */
 7711     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt;
 7712             onRotationStartedProperty() {
 7713         return getEventHandlerProperties().onRotationStartedProperty();
 7714     }
 7715 
 7716     public final void setOnRotate(
 7717             EventHandler&lt;? super RotateEvent&gt; value) {
 7718         onRotateProperty().set(value);
 7719     }
 7720 
 7721     public final EventHandler&lt;? super RotateEvent&gt; getOnRotate() {
 7722         return (eventHandlerProperties == null)
 7723                 ? null : eventHandlerProperties.getOnRotate();
 7724     }
 7725 
 7726     /**
 7727      * Defines a function to be called when user performs a rotation action.
 7728      * @return the event handler that is called when user performs a rotation
 7729      * action
 7730      * @since JavaFX 2.2
 7731      */
 7732     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt;
 7733             onRotateProperty() {
 7734         return getEventHandlerProperties().onRotateProperty();
 7735     }
 7736 
 7737     public final void setOnRotationFinished(
 7738             EventHandler&lt;? super RotateEvent&gt; value) {
 7739         onRotationFinishedProperty().set(value);
 7740     }
 7741 
 7742     public final EventHandler&lt;? super RotateEvent&gt; getOnRotationFinished() {
 7743         return (eventHandlerProperties == null)
 7744                 ? null : eventHandlerProperties.getOnRotationFinished();
 7745     }
 7746 
 7747     /**
 7748      * Defines a function to be called when a rotation gesture ends.
 7749      * @return the event handler that is called when a rotation gesture ends
 7750      * @since JavaFX 2.2
 7751      */
 7752     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt;
 7753             onRotationFinishedProperty() {
 7754         return getEventHandlerProperties().onRotationFinishedProperty();
 7755     }
 7756 
 7757     public final void setOnZoomStarted(
 7758             EventHandler&lt;? super ZoomEvent&gt; value) {
 7759         onZoomStartedProperty().set(value);
 7760     }
 7761 
 7762     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomStarted() {
 7763         return (eventHandlerProperties == null)
 7764                 ? null : eventHandlerProperties.getOnZoomStarted();
 7765     }
 7766 
 7767     /**
 7768      * Defines a function to be called when a zooming gesture is detected.
 7769      * @return the event handler that is called when a zooming gesture is
 7770      * detected
 7771      * @since JavaFX 2.2
 7772      */
 7773     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;
 7774             onZoomStartedProperty() {
 7775         return getEventHandlerProperties().onZoomStartedProperty();
 7776     }
 7777 
 7778     public final void setOnZoom(
 7779             EventHandler&lt;? super ZoomEvent&gt; value) {
 7780         onZoomProperty().set(value);
 7781     }
 7782 
 7783     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoom() {
 7784         return (eventHandlerProperties == null)
 7785                 ? null : eventHandlerProperties.getOnZoom();
 7786     }
 7787 
 7788     /**
 7789      * Defines a function to be called when user performs a zooming action.
 7790      * @return the event handler that is called when user performs a zooming
 7791      * action
 7792      * @since JavaFX 2.2
 7793      */
 7794     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;
 7795             onZoomProperty() {
 7796         return getEventHandlerProperties().onZoomProperty();
 7797     }
 7798 
 7799     public final void setOnZoomFinished(
 7800             EventHandler&lt;? super ZoomEvent&gt; value) {
 7801         onZoomFinishedProperty().set(value);
 7802     }
 7803 
 7804     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomFinished() {
 7805         return (eventHandlerProperties == null)
 7806                 ? null : eventHandlerProperties.getOnZoomFinished();
 7807     }
 7808 
 7809     /**
 7810      * Defines a function to be called when a zooming gesture ends.
 7811      * @return the event handler that is called when a zooming gesture ends
 7812      * @since JavaFX 2.2
 7813      */
 7814     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;
 7815             onZoomFinishedProperty() {
 7816         return getEventHandlerProperties().onZoomFinishedProperty();
 7817     }
 7818 
 7819     public final void setOnSwipeUp(
 7820             EventHandler&lt;? super SwipeEvent&gt; value) {
 7821         onSwipeUpProperty().set(value);
 7822     }
 7823 
 7824     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeUp() {
 7825         return (eventHandlerProperties == null)
 7826                 ? null : eventHandlerProperties.getOnSwipeUp();
 7827     }
 7828 
 7829     /**
 7830      * Defines a function to be called when an upward swipe gesture
 7831      * centered over this node happens.
 7832      * @return the event handler that is called when an upward swipe gesture
 7833      * centered over this node happens
 7834      * @since JavaFX 2.2
 7835      */
 7836     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
 7837             onSwipeUpProperty() {
 7838         return getEventHandlerProperties().onSwipeUpProperty();
 7839     }
 7840 
 7841     public final void setOnSwipeDown(
 7842             EventHandler&lt;? super SwipeEvent&gt; value) {
 7843         onSwipeDownProperty().set(value);
 7844     }
 7845 
 7846     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeDown() {
 7847         return (eventHandlerProperties == null)
 7848                 ? null : eventHandlerProperties.getOnSwipeDown();
 7849     }
 7850 
 7851     /**
 7852      * Defines a function to be called when a downward swipe gesture
 7853      * centered over this node happens.
 7854      * @return the event handler that is called when a downward swipe gesture
 7855      * centered over this node happens
 7856      * @since JavaFX 2.2
 7857      */
 7858     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
 7859             onSwipeDownProperty() {
 7860         return getEventHandlerProperties().onSwipeDownProperty();
 7861     }
 7862 
 7863     public final void setOnSwipeLeft(
 7864             EventHandler&lt;? super SwipeEvent&gt; value) {
 7865         onSwipeLeftProperty().set(value);
 7866     }
 7867 
 7868     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeLeft() {
 7869         return (eventHandlerProperties == null)
 7870                 ? null : eventHandlerProperties.getOnSwipeLeft();
 7871     }
 7872 
 7873     /**
 7874      * Defines a function to be called when a leftward swipe gesture
 7875      * centered over this node happens.
 7876      * @return the event handler that is called when a leftward swipe gesture
 7877      * centered over this node happens
 7878      * @since JavaFX 2.2
 7879      */
 7880     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
 7881             onSwipeLeftProperty() {
 7882         return getEventHandlerProperties().onSwipeLeftProperty();
 7883     }
 7884 
 7885     public final void setOnSwipeRight(
 7886             EventHandler&lt;? super SwipeEvent&gt; value) {
 7887         onSwipeRightProperty().set(value);
 7888     }
 7889 
 7890     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeRight() {
 7891         return (eventHandlerProperties == null)
 7892                 ? null : eventHandlerProperties.getOnSwipeRight();
 7893     }
 7894 
 7895     /**
 7896      * Defines a function to be called when an rightward swipe gesture
 7897      * centered over this node happens.
 7898      * @return the event handler that is called when an rightward swipe gesture
 7899      * centered over this node happens
 7900      * @since JavaFX 2.2
 7901      */
 7902     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
 7903             onSwipeRightProperty() {
 7904         return getEventHandlerProperties().onSwipeRightProperty();
 7905     }
 7906 
 7907 
 7908     /* *************************************************************************
 7909      *                                                                         *
 7910      *                             Touch Handling                              *
 7911      *                                                                         *
 7912      **************************************************************************/
 7913 
 7914     public final void setOnTouchPressed(
 7915             EventHandler&lt;? super TouchEvent&gt; value) {
 7916         onTouchPressedProperty().set(value);
 7917     }
 7918 
 7919     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchPressed() {
 7920         return (eventHandlerProperties == null)
 7921                 ? null : eventHandlerProperties.getOnTouchPressed();
 7922     }
 7923 
 7924     /**
 7925      * Defines a function to be called when a new touch point is pressed.
 7926      * @return the event handler that is called when a new touch point is pressed
 7927      * @since JavaFX 2.2
 7928      */
 7929     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
 7930             onTouchPressedProperty() {
 7931         return getEventHandlerProperties().onTouchPressedProperty();
 7932     }
 7933 
 7934     public final void setOnTouchMoved(
 7935             EventHandler&lt;? super TouchEvent&gt; value) {
 7936         onTouchMovedProperty().set(value);
 7937     }
 7938 
 7939     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchMoved() {
 7940         return (eventHandlerProperties == null)
 7941                 ? null : eventHandlerProperties.getOnTouchMoved();
 7942     }
 7943 
 7944     /**
 7945      * Defines a function to be called when a touch point is moved.
 7946      * @return the event handler that is called when a touch point is moved
 7947      * @since JavaFX 2.2
 7948      */
 7949     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
 7950             onTouchMovedProperty() {
 7951         return getEventHandlerProperties().onTouchMovedProperty();
 7952     }
 7953 
 7954     public final void setOnTouchReleased(
 7955             EventHandler&lt;? super TouchEvent&gt; value) {
 7956         onTouchReleasedProperty().set(value);
 7957     }
 7958 
 7959     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchReleased() {
 7960         return (eventHandlerProperties == null)
 7961                 ? null : eventHandlerProperties.getOnTouchReleased();
 7962     }
 7963 
 7964     /**
 7965      * Defines a function to be called when a touch point is released.
 7966      * @return the event handler that is called when a touch point is released
 7967      * @since JavaFX 2.2
 7968      */
 7969     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
 7970             onTouchReleasedProperty() {
 7971         return getEventHandlerProperties().onTouchReleasedProperty();
 7972     }
 7973 
 7974     public final void setOnTouchStationary(
 7975             EventHandler&lt;? super TouchEvent&gt; value) {
 7976         onTouchStationaryProperty().set(value);
 7977     }
 7978 
 7979     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchStationary() {
 7980         return (eventHandlerProperties == null)
 7981                 ? null : eventHandlerProperties.getOnTouchStationary();
 7982     }
 7983 
 7984     /**
 7985      * Defines a function to be called when a touch point stays pressed and
 7986      * still.
 7987      * @return the event handler that is called when a touch point stays pressed
 7988      * and still
 7989      * @since JavaFX 2.2
 7990      */
 7991     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
 7992             onTouchStationaryProperty() {
 7993         return getEventHandlerProperties().onTouchStationaryProperty();
 7994     }
 7995 
 7996     /* *************************************************************************
 7997      *                                                                         *
 7998      *                           Keyboard Handling                             *
 7999      *                                                                         *
 8000      **************************************************************************/
 8001 
 8002     public final void setOnKeyPressed(
 8003             EventHandler&lt;? super KeyEvent&gt; value) {
 8004         onKeyPressedProperty().set(value);
 8005     }
 8006 
 8007     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyPressed() {
 8008         return (eventHandlerProperties == null)
 8009                 ? null : eventHandlerProperties.getOnKeyPressed();
 8010     }
 8011 
 8012     /**
 8013      * Defines a function to be called when this {@code Node} or its child
 8014      * {@code Node} has input focus and a key has been pressed. The function
 8015      * is called only if the event hasn&#39;t been already consumed during its
 8016      * capturing or bubbling phase.
 8017      * @return the event handler that is called when this {@code Node} or its
 8018      * child {@code Node} has input focus and a key has been pressed
 8019      */
 8020     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt;
 8021             onKeyPressedProperty() {
 8022         return getEventHandlerProperties().onKeyPressedProperty();
 8023     }
 8024 
 8025     public final void setOnKeyReleased(
 8026             EventHandler&lt;? super KeyEvent&gt; value) {
 8027         onKeyReleasedProperty().set(value);
 8028     }
 8029 
 8030     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyReleased() {
 8031         return (eventHandlerProperties == null)
 8032                 ? null : eventHandlerProperties.getOnKeyReleased();
 8033     }
 8034 
 8035     /**
 8036      * Defines a function to be called when this {@code Node} or its child
 8037      * {@code Node} has input focus and a key has been released. The function
 8038      * is called only if the event hasn&#39;t been already consumed during its
 8039      * capturing or bubbling phase.
 8040      * @return the event handler that is called when this {@code Node} or its
 8041      * child {@code Node} has input focus and a key has been released
 8042      */
 8043     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt;
 8044             onKeyReleasedProperty() {
 8045         return getEventHandlerProperties().onKeyReleasedProperty();
 8046     }
 8047 
 8048     public final void setOnKeyTyped(
 8049             EventHandler&lt;? super KeyEvent&gt; value) {
 8050         onKeyTypedProperty().set(value);
 8051     }
 8052 
 8053     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyTyped() {
 8054         return (eventHandlerProperties == null)
 8055                 ? null : eventHandlerProperties.getOnKeyTyped();
 8056     }
 8057 
 8058     /**
 8059      * Defines a function to be called when this {@code Node} or its child
 8060      * {@code Node} has input focus and a key has been typed. The function
 8061      * is called only if the event hasn&#39;t been already consumed during its
 8062      * capturing or bubbling phase.
 8063      * @return the event handler that is called when this {@code Node} or its
 8064      * child {@code Node} has input focus and a key has been typed
 8065      */
 8066     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt;
 8067             onKeyTypedProperty() {
 8068         return getEventHandlerProperties().onKeyTypedProperty();
 8069     }
 8070 
 8071     /* *************************************************************************
 8072      *                                                                         *
 8073      *                           Input Method Handling                         *
 8074      *                                                                         *
 8075      **************************************************************************/
 8076 
 8077     public final void setOnInputMethodTextChanged(
 8078             EventHandler&lt;? super InputMethodEvent&gt; value) {
 8079         onInputMethodTextChangedProperty().set(value);
 8080     }
 8081 
 8082     public final EventHandler&lt;? super InputMethodEvent&gt;
 8083             getOnInputMethodTextChanged() {
 8084         return (eventHandlerProperties == null)
 8085                 ? null : eventHandlerProperties.getOnInputMethodTextChanged();
 8086     }
 8087 
 8088     /**
 8089      * Defines a function to be called when this {@code Node}
 8090      * has input focus and the input method text has changed.  If this
 8091      * function is not defined in this {@code Node}, then it
 8092      * receives the result string of the input method composition as a
 8093      * series of {@code onKeyTyped} function calls.
 8094      * &lt;p&gt;
 8095      * When the {@code Node} loses the input focus, the JavaFX runtime
 8096      * automatically commits the existing composed text if any.
 8097      * &lt;/p&gt;
 8098      * @return the event handler that is called when this {@code Node} has input
 8099      * focus and the input method text has changed
 8100      */
 8101     public final ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt;
 8102             onInputMethodTextChangedProperty() {
 8103         return getEventHandlerProperties().onInputMethodTextChangedProperty();
 8104     }
 8105 
 8106     public final void setInputMethodRequests(InputMethodRequests value) {
 8107         inputMethodRequestsProperty().set(value);
 8108     }
 8109 
 8110     public final InputMethodRequests getInputMethodRequests() {
 8111         return (miscProperties == null)
 8112                        ? DEFAULT_INPUT_METHOD_REQUESTS
 8113                        : miscProperties.getInputMethodRequests();
 8114     }
 8115 
 8116     /**
 8117      * Property holding InputMethodRequests.
 8118      *
 8119      * @return InputMethodRequestsProperty
 8120      */
 8121     public final ObjectProperty&lt;InputMethodRequests&gt; inputMethodRequestsProperty() {
 8122         return getMiscProperties().inputMethodRequestsProperty();
 8123     }
 8124 
 8125     /***************************************************************************
 8126      *                                                                         *
 8127      *                             Focus Traversal                             *
 8128      *                                                                         *
 8129      **************************************************************************/
 8130 
 8131     /**
 8132      * Special boolean property which allows for atomic focus change.
 8133      * Focus change means defocusing the old focus owner and focusing a new
 8134      * one. With a usual property, defocusing the old node fires the value
 8135      * changed event and user code can react with something that breaks
 8136      * focusability of the new node, or even remove the new node from the scene.
 8137      * This leads to various error states. This property allows for setting
 8138      * the state without firing the event. The focus change first sets both
 8139      * properties and then fires both events. This makes the focus change look
 8140      * like an atomic operation - when the old node is notified to loose focus,
 8141      * the new node is already focused.
 8142      */
 8143     final class FocusedProperty extends ReadOnlyBooleanPropertyBase {
 8144         private boolean value;
 8145         private boolean valid = true;
 8146         private boolean needsChangeEvent = false;
 8147 
 8148         public void store(final boolean value) {
 8149             if (value != this.value) {
 8150                 this.value = value;
 8151                 markInvalid();
 8152             }
 8153         }
 8154 
 8155         public void notifyListeners() {
 8156             if (needsChangeEvent) {
 8157                 fireValueChangedEvent();
 8158                 needsChangeEvent = false;
 8159             }
 8160         }
 8161 
 8162         private void markInvalid() {
 8163             if (valid) {
 8164                 valid = false;
 8165 
 8166                 pseudoClassStateChanged(FOCUSED_PSEUDOCLASS_STATE, get());
 8167                 PlatformLogger logger = Logging.getFocusLogger();
 8168                 if (logger.isLoggable(Level.FINE)) {
 8169                     logger.fine(this + &quot; focused=&quot; + get());
 8170                 }
 8171 
 8172                 needsChangeEvent = true;
 8173 
 8174                 notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUSED);
 8175             }
 8176         }
 8177 
 8178         @Override
 8179         public boolean get() {
 8180             valid = true;
 8181             return value;
 8182         }
 8183 
 8184         @Override
 8185         public Object getBean() {
 8186             return Node.this;
 8187         }
 8188 
 8189         @Override
 8190         public String getName() {
 8191             return &quot;focused&quot;;
 8192         }
 8193     }
 8194 
 8195     /**
 8196      * Indicates whether this {@code Node} currently has the input focus.
 8197      * To have the input focus, a node must be the {@code Scene}&#39;s focus
 8198      * owner, and the scene must be in a {@code Stage} that is visible
 8199      * and active. See {@link #requestFocus()} for more information.
 8200      *
 8201      * @see #requestFocus()
 8202      * @defaultValue false
 8203      */
 8204     private FocusedProperty focused;
 8205 
 8206     protected final void setFocused(boolean value) {
 8207         FocusedProperty fp = focusedPropertyImpl();
 8208         if (fp.value != value) {
 8209             fp.store(value);
 8210             fp.notifyListeners();
 8211         }
 8212     }
 8213 
 8214     public final boolean isFocused() {
 8215         return focused == null ? false : focused.get();
 8216     }
 8217 
 8218     public final ReadOnlyBooleanProperty focusedProperty() {
 8219         return focusedPropertyImpl();
 8220     }
 8221 
 8222     private FocusedProperty focusedPropertyImpl() {
 8223         if (focused == null) {
 8224             focused = new FocusedProperty();
 8225         }
 8226         return focused;
 8227     }
 8228 
 8229     /**
 8230      * Specifies whether this {@code Node} should be a part of focus traversal
 8231      * cycle. When this property is {@code true} focus can be moved to this
 8232      * {@code Node} and from this {@code Node} using regular focus traversal
 8233      * keys. On a desktop such keys are usually {@code TAB} for moving focus
 8234      * forward and {@code SHIFT+TAB} for moving focus backward.
 8235      *
 8236      * When a {@code Scene} is created, the system gives focus to a
 8237      * {@code Node} whose {@code focusTraversable} variable is true
 8238      * and that is eligible to receive the focus,
 8239      * unless the focus had been set explicitly via a call
 8240      * to {@link #requestFocus()}.
 8241      *
 8242      * @see #requestFocus()
 8243      * @defaultValue false
 8244      */
 8245     private BooleanProperty focusTraversable;
 8246 
 8247     public final void setFocusTraversable(boolean value) {
 8248         focusTraversableProperty().set(value);
 8249     }
 8250     public final boolean isFocusTraversable() {
 8251         return focusTraversable == null ? false : focusTraversable.get();
 8252     }
 8253 
 8254     public final BooleanProperty focusTraversableProperty() {
 8255         if (focusTraversable == null) {
 8256             focusTraversable = new StyleableBooleanProperty(false) {
 8257 
 8258                 @Override
 8259                 public void invalidated() {
 8260                     Scene _scene = getScene();
 8261                     if (_scene != null) {
 8262                         if (get()) {
 8263                             _scene.initializeInternalEventDispatcher();
 8264                         }
 8265                         focusSetDirty(_scene);
 8266                     }
 8267                 }
 8268 
 8269                 @Override
 8270                 public CssMetaData getCssMetaData() {
 8271                     return StyleableProperties.FOCUS_TRAVERSABLE;
 8272                 }
 8273 
 8274                 @Override
 8275                 public Object getBean() {
 8276                     return Node.this;
 8277                 }
 8278 
 8279                 @Override
 8280                 public String getName() {
 8281                     return &quot;focusTraversable&quot;;
 8282                 }
 8283             };
 8284         }
 8285         return focusTraversable;
 8286     }
 8287 
 8288     /**
 8289      * Called when something has changed on this node that *may* have made the
 8290      * scene&#39;s focus dirty. This covers the cases where this node is the focus
 8291      * owner and it may have lost eligibility, or it&#39;s traversable and it may
 8292      * have gained eligibility. Note that we do not want to use disabled
 8293      * or treeVisible here, as this function is called from their
 8294      * &quot;on invalidate&quot; triggers, and using them will cause them to be
 8295      * revalidated. The pulse will revalidate everything and make the final
 8296      * determination.
 8297      */
 8298     private void focusSetDirty(Scene s) {
 8299         if (s != null &amp;&amp;
 8300             (this == s.getFocusOwner() || isFocusTraversable())) {
 8301                 s.setFocusDirty(true);
 8302         }
 8303     }
 8304 
 8305     /**
 8306      * Requests that this {@code Node} get the input focus, and that this
 8307      * {@code Node}&#39;s top-level ancestor become the focused window. To be
 8308      * eligible to receive the focus, the node must be part of a scene, it and
 8309      * all of its ancestors must be visible, and it must not be disabled.
 8310      * If this node is eligible, this function will cause it to become this
 8311      * {@code Scene}&#39;s &quot;focus owner&quot;. Each scene has at most one focus owner
 8312      * node. The focus owner will not actually have the input focus, however,
 8313      * unless the scene belongs to a {@code Stage} that is both visible
 8314      * and active.
 8315      */
 8316     public void requestFocus() {
 8317         if (getScene() != null) {
 8318             getScene().requestFocus(this);
 8319         }
 8320     }
 8321 
 8322     /**
 8323      * Traverses from this node in the direction indicated. Note that this
 8324      * node need not actually have the focus, nor need it be focusTraversable.
 8325      * However, the node must be part of a scene, otherwise this request
 8326      * is ignored.
 8327      */
 8328     final boolean traverse(Direction dir) {
 8329         if (getScene() == null) {
 8330             return false;
 8331         }
 8332         return getScene().traverse(this, dir);
 8333     }
 8334 
 8335     ////////////////////////////
 8336     //  Private Implementation
 8337     ////////////////////////////
 8338 
 8339      /**
 8340       * Returns a string representation for the object.
 8341       * @return a string representation for the object.
 8342       */
 8343     @Override
 8344     public String toString() {
 8345         String klassName = getClass().getName();
 8346         String simpleName = klassName.substring(klassName.lastIndexOf(&#39;.&#39;)+1);
 8347         StringBuilder sbuf = new StringBuilder(simpleName);
 8348         boolean hasId = id != null &amp;&amp; !&quot;&quot;.equals(getId());
 8349         boolean hasStyleClass = !getStyleClass().isEmpty();
 8350 
 8351         if (!hasId) {
 8352             sbuf.append(&#39;@&#39;);
 8353             sbuf.append(Integer.toHexString(hashCode()));
 8354         } else {
 8355             sbuf.append(&quot;[id=&quot;);
 8356             sbuf.append(getId());
 8357             if (!hasStyleClass) sbuf.append(&quot;]&quot;);
 8358         }
 8359         if (hasStyleClass) {
 8360             if (!hasId) sbuf.append(&#39;[&#39;);
 8361             else sbuf.append(&quot;, &quot;);
 8362             sbuf.append(&quot;styleClass=&quot;);
 8363             sbuf.append(getStyleClass());
 8364             sbuf.append(&quot;]&quot;);
 8365         }
 8366         return sbuf.toString();
 8367     }
 8368 
 8369     private void preprocessMouseEvent(MouseEvent e) {
 8370         final EventType&lt;?&gt; eventType = e.getEventType();
 8371         if (eventType == MouseEvent.MOUSE_PRESSED) {
 8372             for (Node n = this; n != null; n = n.getParent()) {
 8373                 n.setPressed(e.isPrimaryButtonDown());
 8374             }
 8375             return;
 8376         }
 8377         if (eventType == MouseEvent.MOUSE_RELEASED) {
 8378             for (Node n = this; n != null; n = n.getParent()) {
 8379                 n.setPressed(e.isPrimaryButtonDown());
 8380             }
 8381             return;
 8382         }
 8383 
 8384         if (e.getTarget() == this) {
 8385             // the mouse event types are translated only when the node uses
 8386             // its internal event dispatcher, so both entered / exited variants
 8387             // are possible here
 8388 
 8389             if ((eventType == MouseEvent.MOUSE_ENTERED)
 8390                     || (eventType == MouseEvent.MOUSE_ENTERED_TARGET)) {
 8391                 setHover(true);
 8392                 return;
 8393             }
 8394 
 8395             if ((eventType == MouseEvent.MOUSE_EXITED)
 8396                     || (eventType == MouseEvent.MOUSE_EXITED_TARGET)) {
 8397                 setHover(false);
 8398                 return;
 8399             }
 8400         }
 8401     }
 8402 
 8403     void markDirtyLayoutBranch() {
 8404         Parent p = getParent();
 8405         while (p != null &amp;&amp; p.layoutFlag == LayoutFlags.CLEAN) {
 8406             p.setLayoutFlag(LayoutFlags.DIRTY_BRANCH);
 8407             if (p.isSceneRoot()) {
 8408                 Toolkit.getToolkit().requestNextPulse();
 8409                 if (getSubScene() != null) {
 8410                     getSubScene().setDirtyLayout(p);
 8411                 }
 8412             }
 8413             p = p.getParent();
 8414         }
 8415 
 8416     }
 8417 
 8418     private boolean isWindowShowing() {
 8419         Scene s = getScene();
 8420         if (s == null) return false;
 8421         Window w = s.getWindow();
 8422         return w != null &amp;&amp; w.isShowing();
 8423     }
 8424 
 8425     private void updateTreeShowing() {
 8426         setTreeShowing(isTreeVisible() &amp;&amp; isWindowShowing());
 8427     }
 8428 
 8429     private boolean treeShowing;
 8430     private TreeShowingPropertyReadOnly treeShowingRO;
 8431 
 8432     final void setTreeShowing(boolean value) {
 8433         if (treeShowing != value) {
 8434             treeShowing = value;
 8435             ((TreeShowingPropertyReadOnly) treeShowingProperty()).invalidate();
 8436         }
 8437     }
 8438 
 8439     final boolean isTreeShowing() {
 8440         return treeShowingProperty().get();
 8441     }
 8442 
 8443     final BooleanExpression treeShowingProperty() {
 8444         if (treeShowingRO == null) {
 8445             treeShowingRO = new TreeShowingPropertyReadOnly();
 8446         }
 8447         return treeShowingRO;
 8448     }
 8449 
 8450     class TreeShowingPropertyReadOnly extends BooleanExpression {
 8451 
 8452         private ExpressionHelper&lt;Boolean&gt; helper;
 8453         private boolean valid;
 8454 
 8455         @Override
 8456         public void addListener(InvalidationListener listener) {
 8457             helper = ExpressionHelper.addListener(helper, this, listener);
 8458         }
 8459 
 8460         @Override
 8461         public void removeListener(InvalidationListener listener) {
 8462             helper = ExpressionHelper.removeListener(helper, listener);
 8463         }
 8464 
 8465         @Override
 8466         public void addListener(ChangeListener&lt;? super Boolean&gt; listener) {
 8467             helper = ExpressionHelper.addListener(helper, this, listener);
 8468         }
 8469 
 8470         @Override
 8471         public void removeListener(ChangeListener&lt;? super Boolean&gt; listener) {
 8472             helper = ExpressionHelper.removeListener(helper, listener);
 8473         }
 8474 
 8475         protected void invalidate() {
 8476             if (valid) {
 8477                 valid = false;
 8478                 ExpressionHelper.fireValueChangedEvent(helper);
 8479             }
 8480         }
 8481 
 8482         @Override
 8483         public boolean get() {
 8484             valid = true;
 8485             return Node.this.treeShowing;
 8486         }
 8487 
 8488     }
 8489 
 8490     private void updateTreeVisible(boolean parentChanged) {
 8491         boolean isTreeVisible = isVisible();
 8492         final Node parentNode = getParent() != null ? getParent() :
 8493                     clipParent != null ? clipParent :
 8494                     getSubScene() != null ? getSubScene() : null;
 8495         if (isTreeVisible) {
 8496             isTreeVisible = parentNode == null || parentNode.isTreeVisible();
 8497         }
 8498         // When the parent has changed to visible and we have unsynchronized visibility,
 8499         // we have to synchronize, because the rendering will now pass through the newly-visible parent
 8500         // Otherwise an invisible Node might get rendered
 8501         if (parentChanged &amp;&amp; parentNode != null &amp;&amp; parentNode.isTreeVisible()
 8502                 &amp;&amp; isDirty(DirtyBits.NODE_VISIBLE)) {
 8503             addToSceneDirtyList();
 8504         }
 8505         setTreeVisible(isTreeVisible);
 8506 
 8507         updateTreeShowing();
 8508     }
 8509 
 8510     private boolean treeVisible;
 8511     private TreeVisiblePropertyReadOnly treeVisibleRO;
 8512 
 8513     final void setTreeVisible(boolean value) {
 8514         if (treeVisible != value) {
 8515             treeVisible = value;
 8516             updateCanReceiveFocus();
 8517             focusSetDirty(getScene());
 8518             if (getClip() != null) {
 8519                 getClip().updateTreeVisible(true);
 8520             }
 8521             if (treeVisible &amp;&amp; !isDirtyEmpty()) {
 8522                 addToSceneDirtyList();
 8523             }
 8524             ((TreeVisiblePropertyReadOnly) treeVisibleProperty()).invalidate();
 8525             if (Node.this instanceof SubScene) {
 8526                 Node subSceneRoot = ((SubScene)Node.this).getRoot();
 8527                 if (subSceneRoot != null) {
 8528                     // SubScene.getRoot() is only null if it&#39;s constructor
 8529                     // has not finished.
 8530                     subSceneRoot.setTreeVisible(value &amp;&amp; subSceneRoot.isVisible());
 8531                 }
 8532             }
 8533         }
 8534     }
 8535 
 8536     final boolean isTreeVisible() {
 8537         return treeVisibleProperty().get();
 8538     }
 8539 
 8540     final BooleanExpression treeVisibleProperty() {
 8541         if (treeVisibleRO == null) {
 8542             treeVisibleRO = new TreeVisiblePropertyReadOnly();
 8543         }
 8544         return treeVisibleRO;
 8545     }
 8546 
 8547     class TreeVisiblePropertyReadOnly extends BooleanExpression {
 8548 
 8549         private ExpressionHelper&lt;Boolean&gt; helper;
 8550         private boolean valid;
 8551 
 8552         @Override
 8553         public void addListener(InvalidationListener listener) {
 8554             helper = ExpressionHelper.addListener(helper, this, listener);
 8555         }
 8556 
 8557         @Override
 8558         public void removeListener(InvalidationListener listener) {
 8559             helper = ExpressionHelper.removeListener(helper, listener);
 8560         }
 8561 
 8562         @Override
 8563         public void addListener(ChangeListener&lt;? super Boolean&gt; listener) {
 8564             helper = ExpressionHelper.addListener(helper, this, listener);
 8565         }
 8566 
 8567         @Override
 8568         public void removeListener(ChangeListener&lt;? super Boolean&gt; listener) {
 8569             helper = ExpressionHelper.removeListener(helper, listener);
 8570         }
 8571 
 8572         protected void invalidate() {
 8573             if (valid) {
 8574                 valid = false;
 8575                 ExpressionHelper.fireValueChangedEvent(helper);
 8576             }
 8577         }
 8578 
 8579         @Override
 8580         public boolean get() {
 8581             valid = true;
 8582             return Node.this.treeVisible;
 8583         }
 8584 
 8585     }
 8586 
 8587     private boolean canReceiveFocus = false;
 8588 
 8589     private void setCanReceiveFocus(boolean value) {
 8590         canReceiveFocus = value;
 8591     }
 8592 
 8593     final boolean isCanReceiveFocus() {
 8594         return canReceiveFocus;
 8595     }
 8596 
 8597     private void updateCanReceiveFocus() {
 8598         setCanReceiveFocus(getScene() != null
 8599           &amp;&amp; !isDisabled()
 8600           &amp;&amp; isTreeVisible());
 8601     }
 8602 
 8603     // for indenting messages based on scene-graph depth
 8604     String indent() {
 8605         String indent = &quot;&quot;;
 8606         Parent p = this.getParent();
 8607         while (p != null) {
 8608             indent += &quot;  &quot;;
 8609             p = p.getParent();
 8610         }
 8611         return indent;
 8612     }
 8613 
 8614     /*
 8615      * Should we underline the mnemonic character?
 8616      */
 8617     private BooleanProperty showMnemonics;
 8618 
 8619     final void setShowMnemonics(boolean value) {
 8620         showMnemonicsProperty().set(value);
 8621     }
 8622 
 8623     final boolean isShowMnemonics() {
 8624         return showMnemonics == null ? false : showMnemonics.get();
 8625     }
 8626 
 8627     final BooleanProperty showMnemonicsProperty() {
 8628         if (showMnemonics == null) {
 8629             showMnemonics = new BooleanPropertyBase(false) {
 8630 
 8631                 @Override
 8632                 protected void invalidated() {
 8633                     pseudoClassStateChanged(SHOW_MNEMONICS_PSEUDOCLASS_STATE, get());
 8634                 }
 8635 
 8636                 @Override
 8637                 public Object getBean() {
 8638                     return Node.this;
 8639                 }
 8640 
 8641                 @Override
 8642                 public String getName() {
 8643                     return &quot;showMnemonics&quot;;
 8644                 }
 8645             };
 8646         }
 8647         return showMnemonics;
 8648     }
 8649 
 8650 
 8651     /**
 8652      * References a node that is a labelFor this node.
 8653      * Accessible via a NodeAccessor. See Label.labelFor for details.
 8654      */
 8655     private Node labeledBy = null;
 8656 
 8657 
 8658     /***************************************************************************
 8659      *                                                                         *
 8660      *                         Event Dispatch                                  *
 8661      *                                                                         *
 8662      **************************************************************************/
 8663 
 8664     // PENDING_DOC_REVIEW
 8665     /**
 8666      * Specifies the event dispatcher for this node. The default event
 8667      * dispatcher sends the received events to the registered event handlers and
 8668      * filters. When replacing the value with a new {@code EventDispatcher},
 8669      * the new dispatcher should forward events to the replaced dispatcher
 8670      * to maintain the node&#39;s default event handling behavior.
 8671      */
 8672     private ObjectProperty&lt;EventDispatcher&gt; eventDispatcher;
 8673 
 8674     public final void setEventDispatcher(EventDispatcher value) {
 8675         eventDispatcherProperty().set(value);
 8676     }
 8677 
 8678     public final EventDispatcher getEventDispatcher() {
 8679         return eventDispatcherProperty().get();
 8680     }
 8681 
 8682     public final ObjectProperty&lt;EventDispatcher&gt; eventDispatcherProperty() {
 8683         initializeInternalEventDispatcher();
 8684         return eventDispatcher;
 8685     }
 8686 
 8687     private NodeEventDispatcher internalEventDispatcher;
 8688 
 8689     // PENDING_DOC_REVIEW
 8690     /**
 8691      * Registers an event handler to this node. The handler is called when the
 8692      * node receives an {@code Event} of the specified type during the bubbling
 8693      * phase of event delivery.
 8694      *
 8695      * @param &lt;T&gt; the specific event class of the handler
 8696      * @param eventType the type of the events to receive by the handler
 8697      * @param eventHandler the handler to register
 8698      * @throws NullPointerException if the event type or handler is null
 8699      */
 8700     public final &lt;T extends Event&gt; void addEventHandler(
 8701             final EventType&lt;T&gt; eventType,
 8702             final EventHandler&lt;? super T&gt; eventHandler) {
 8703         getInternalEventDispatcher().getEventHandlerManager()
 8704                                     .addEventHandler(eventType, eventHandler);
 8705     }
 8706 
 8707     // PENDING_DOC_REVIEW
 8708     /**
 8709      * Unregisters a previously registered event handler from this node. One
 8710      * handler might have been registered for different event types, so the
 8711      * caller needs to specify the particular event type from which to
 8712      * unregister the handler.
 8713      *
 8714      * @param &lt;T&gt; the specific event class of the handler
 8715      * @param eventType the event type from which to unregister
 8716      * @param eventHandler the handler to unregister
 8717      * @throws NullPointerException if the event type or handler is null
 8718      */
 8719     public final &lt;T extends Event&gt; void removeEventHandler(
 8720             final EventType&lt;T&gt; eventType,
 8721             final EventHandler&lt;? super T&gt; eventHandler) {
 8722         getInternalEventDispatcher()
 8723                 .getEventHandlerManager()
 8724                 .removeEventHandler(eventType, eventHandler);
 8725     }
 8726 
 8727     // PENDING_DOC_REVIEW
 8728     /**
 8729      * Registers an event filter to this node. The filter is called when the
 8730      * node receives an {@code Event} of the specified type during the capturing
 8731      * phase of event delivery.
 8732      *
 8733      * @param &lt;T&gt; the specific event class of the filter
 8734      * @param eventType the type of the events to receive by the filter
 8735      * @param eventFilter the filter to register
 8736      * @throws NullPointerException if the event type or filter is null
 8737      */
 8738     public final &lt;T extends Event&gt; void addEventFilter(
 8739             final EventType&lt;T&gt; eventType,
 8740             final EventHandler&lt;? super T&gt; eventFilter) {
 8741         getInternalEventDispatcher().getEventHandlerManager()
 8742                                     .addEventFilter(eventType, eventFilter);
 8743     }
 8744 
 8745     // PENDING_DOC_REVIEW
 8746     /**
 8747      * Unregisters a previously registered event filter from this node. One
 8748      * filter might have been registered for different event types, so the
 8749      * caller needs to specify the particular event type from which to
 8750      * unregister the filter.
 8751      *
 8752      * @param &lt;T&gt; the specific event class of the filter
 8753      * @param eventType the event type from which to unregister
 8754      * @param eventFilter the filter to unregister
 8755      * @throws NullPointerException if the event type or filter is null
 8756      */
 8757     public final &lt;T extends Event&gt; void removeEventFilter(
 8758             final EventType&lt;T&gt; eventType,
 8759             final EventHandler&lt;? super T&gt; eventFilter) {
 8760         getInternalEventDispatcher().getEventHandlerManager()
 8761                                     .removeEventFilter(eventType, eventFilter);
 8762     }
 8763 
 8764     /**
 8765      * Sets the handler to use for this event type. There can only be one such handler
 8766      * specified at a time. This handler is guaranteed to be called as the last, after
 8767      * handlers added using {@link #addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}.
 8768      * This is used for registering the user-defined onFoo event handlers.
 8769      *
 8770      * @param &lt;T&gt; the specific event class of the handler
 8771      * @param eventType the event type to associate with the given eventHandler
 8772      * @param eventHandler the handler to register, or null to unregister
 8773      * @throws NullPointerException if the event type is null
 8774      */
 8775     protected final &lt;T extends Event&gt; void setEventHandler(
 8776             final EventType&lt;T&gt; eventType,
 8777             final EventHandler&lt;? super T&gt; eventHandler) {
 8778         getInternalEventDispatcher().getEventHandlerManager()
 8779                                     .setEventHandler(eventType, eventHandler);
 8780     }
 8781 
 8782     private NodeEventDispatcher getInternalEventDispatcher() {
 8783         initializeInternalEventDispatcher();
 8784         return internalEventDispatcher;
 8785     }
 8786 
 8787     private void initializeInternalEventDispatcher() {
 8788         if (internalEventDispatcher == null) {
 8789             internalEventDispatcher = createInternalEventDispatcher();
 8790             eventDispatcher = new SimpleObjectProperty&lt;EventDispatcher&gt;(
 8791                                           Node.this,
 8792                                           &quot;eventDispatcher&quot;,
 8793                                           internalEventDispatcher);
 8794         }
 8795     }
 8796 
 8797     private NodeEventDispatcher createInternalEventDispatcher() {
 8798         return new NodeEventDispatcher(this);
 8799     }
 8800 
 8801     /**
 8802      * Event dispatcher for invoking preprocessing of mouse events
 8803      */
 8804     private EventDispatcher preprocessMouseEventDispatcher;
 8805 
 8806     // PENDING_DOC_REVIEW
 8807     /**
 8808      * Construct an event dispatch chain for this node. The event dispatch chain
 8809      * contains all event dispatchers from the stage to this node.
 8810      *
 8811      * @param tail the initial chain to build from
 8812      * @return the resulting event dispatch chain for this node
 8813      */
 8814     @Override
 8815     public EventDispatchChain buildEventDispatchChain(
 8816             EventDispatchChain tail) {
 8817 
 8818         if (preprocessMouseEventDispatcher == null) {
 8819             preprocessMouseEventDispatcher = (event, tail1) -&gt; {
 8820                 event = tail1.dispatchEvent(event);
 8821                 if (event instanceof MouseEvent) {
 8822                     preprocessMouseEvent((MouseEvent) event);
 8823                 }
 8824 
 8825                 return event;
 8826             };
 8827         }
 8828 
 8829         tail = tail.prepend(preprocessMouseEventDispatcher);
 8830 
 8831         // prepend all event dispatchers from this node to the root
 8832         Node curNode = this;
 8833         do {
 8834             if (curNode.eventDispatcher != null) {
 8835                 final EventDispatcher eventDispatcherValue =
 8836                         curNode.eventDispatcher.get();
 8837                 if (eventDispatcherValue != null) {
 8838                     tail = tail.prepend(eventDispatcherValue);
 8839                 }
 8840             }
 8841             final Node curParent = curNode.getParent();
 8842             curNode = curParent != null ? curParent : curNode.getSubScene();
 8843         } while (curNode != null);
 8844 
 8845         if (getScene() != null) {
 8846             // prepend scene&#39;s dispatch chain
 8847             tail = getScene().buildEventDispatchChain(tail);
 8848         }
 8849 
 8850         return tail;
 8851     }
 8852 
 8853     // PENDING_DOC_REVIEW
 8854     /**
 8855      * Fires the specified event. By default the event will travel through the
 8856      * hierarchy from the stage to this node. Any event filter encountered will
 8857      * be notified and can consume the event. If not consumed by the filters,
 8858      * the event handlers on this node are notified. If these don&#39;t consume the
 8859      * event either, the event will travel back the same path it arrived to
 8860      * this node. All event handlers encountered are called and can consume the
 8861      * event.
 8862      * &lt;p&gt;
 8863      * This method must be called on the FX user thread.
 8864      *
 8865      * @param event the event to fire
 8866      */
 8867     public final void fireEvent(Event event) {
 8868 
 8869         /* Log input events.  We do a coarse filter for at least the FINE
 8870          * level and then granularize from there.
 8871          */
 8872         if (event instanceof InputEvent) {
 8873             PlatformLogger logger = Logging.getInputLogger();
 8874             if (logger.isLoggable(Level.FINE)) {
 8875                 EventType eventType = event.getEventType();
 8876                 if (eventType == MouseEvent.MOUSE_ENTERED ||
 8877                     eventType == MouseEvent.MOUSE_EXITED) {
 8878                     logger.finer(event.toString());
 8879                 } else if (eventType == MouseEvent.MOUSE_MOVED ||
 8880                            eventType == MouseEvent.MOUSE_DRAGGED) {
 8881                     logger.finest(event.toString());
 8882                 } else {
 8883                     logger.fine(event.toString());
 8884                 }
 8885             }
 8886         }
 8887 
 8888         Event.fireEvent(this, event);
 8889     }
 8890 
 8891     /***************************************************************************
 8892      *                                                                         *
 8893      *                         Stylesheet Handling                             *
 8894      *                                                                         *
 8895      **************************************************************************/
 8896 
 8897 
 8898     /**
 8899      * {@inheritDoc}
 8900      * @return {@code getClass().getName()} without the package name
 8901      * @since JavaFX 8.0
 8902      */
 8903     @Override
 8904     public String getTypeSelector() {
 8905 
 8906         final Class&lt;?&gt; clazz = getClass();
 8907         final Package pkg = clazz.getPackage();
 8908 
 8909         // package could be null. not likely, but could be.
 8910         int plen = 0;
 8911         if (pkg != null) {
 8912             plen = pkg.getName().length();
 8913         }
 8914 
 8915         final int clen = clazz.getName().length();
 8916         final int pos = (0 &lt; plen &amp;&amp; plen &lt; clen) ? plen + 1 : 0;
 8917 
 8918         return clazz.getName().substring(pos);
 8919     }
 8920 
 8921     /**
 8922      * {@inheritDoc}
 8923      * @return {@code getParent()}
 8924      * @since JavaFX 8.0
 8925      */
 8926     @Override
 8927     public Styleable getStyleableParent() {
 8928         return getParent();
 8929     }
 8930 
 8931 
 8932     /**
 8933      * Returns the initial focus traversable state of this node, for use
 8934      * by the JavaFX CSS engine to correctly set its initial value. This method
 8935      * can be overridden by subclasses in instances where focus traversable should
 8936      * initially be true (as the default implementation of this method is to return
 8937      * false).
 8938      *
 8939      * @return the initial focus traversable state for this {@code Node}.
 8940      * @since 9
 8941      */
 8942     protected Boolean getInitialFocusTraversable() {
 8943         return Boolean.FALSE;
 8944     }
 8945 
 8946     /**
 8947      * Returns the initial cursor state of this node, for use
 8948      * by the JavaFX CSS engine to correctly set its initial value. This method
 8949      * can be overridden by subclasses in instances where the cursor should
 8950      * initially be non-null (as the default implementation of this method is to return
 8951      * null).
 8952      *
 8953      * @return the initial cursor state for this {@code Node}.
 8954      * @since 9
 8955      */
 8956     protected Cursor getInitialCursor() {
 8957         return null;
 8958     }
 8959 
 8960      /**
 8961       * Super-lazy instantiation pattern from Bill Pugh.
 8962       */
 8963      private static class StyleableProperties {
 8964 
 8965         private static final CssMetaData&lt;Node,Cursor&gt; CURSOR =
 8966             new CssMetaData&lt;Node,Cursor&gt;(&quot;-fx-cursor&quot;, CursorConverter.getInstance()) {
 8967 
 8968                 @Override
 8969                 public boolean isSettable(Node node) {
 8970                     return node.miscProperties == null || node.miscProperties.canSetCursor();
 8971                 }
 8972 
 8973                 @Override
 8974                 public StyleableProperty&lt;Cursor&gt; getStyleableProperty(Node node) {
 8975                     return (StyleableProperty&lt;Cursor&gt;)node.cursorProperty();
 8976                 }
 8977 
 8978                 @Override
 8979                 public Cursor getInitialValue(Node node) {
 8980                     // Most controls default focusTraversable to true.
 8981                     // Give a way to have them return the correct default value.
 8982                     return node.getInitialCursor();
 8983                 }
 8984 
 8985             };
 8986         private static final CssMetaData&lt;Node,Effect&gt; EFFECT =
 8987             new CssMetaData&lt;Node,Effect&gt;(&quot;-fx-effect&quot;, EffectConverter.getInstance()) {
 8988 
 8989                 @Override
 8990                 public boolean isSettable(Node node) {
 8991                     return node.miscProperties == null || node.miscProperties.canSetEffect();
 8992                 }
 8993 
 8994                 @Override
 8995                 public StyleableProperty&lt;Effect&gt; getStyleableProperty(Node node) {
 8996                     return (StyleableProperty&lt;Effect&gt;)node.effectProperty();
 8997                 }
 8998             };
 8999         private static final CssMetaData&lt;Node,Boolean&gt; FOCUS_TRAVERSABLE =
 9000             new CssMetaData&lt;Node,Boolean&gt;(&quot;-fx-focus-traversable&quot;,
 9001                 BooleanConverter.getInstance(), Boolean.FALSE) {
 9002 
 9003                 @Override
 9004                 public boolean isSettable(Node node) {
 9005                     return node.focusTraversable == null || !node.focusTraversable.isBound();
 9006                 }
 9007 
 9008                 @Override
 9009                 public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Node node) {
 9010                     return (StyleableProperty&lt;Boolean&gt;)node.focusTraversableProperty();
 9011                 }
 9012 
 9013                 @Override
 9014                 public Boolean getInitialValue(Node node) {
 9015                     // Most controls default focusTraversable to true.
 9016                     // Give a way to have them return the correct default value.
 9017                     return node.getInitialFocusTraversable();
 9018                 }
 9019 
 9020             };
 9021         private static final CssMetaData&lt;Node,Number&gt; OPACITY =
 9022             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-opacity&quot;,
 9023                 SizeConverter.getInstance(), 1.0) {
 9024 
 9025                 @Override
 9026                 public boolean isSettable(Node node) {
 9027                     return node.opacity == null || !node.opacity.isBound();
 9028                 }
 9029 
 9030                 @Override
 9031                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9032                     return (StyleableProperty&lt;Number&gt;)node.opacityProperty();
 9033                 }
 9034             };
 9035         private static final CssMetaData&lt;Node,BlendMode&gt; BLEND_MODE =
 9036             new CssMetaData&lt;Node,BlendMode&gt;(&quot;-fx-blend-mode&quot;, new EnumConverter&lt;BlendMode&gt;(BlendMode.class)) {
 9037 
 9038                 @Override
 9039                 public boolean isSettable(Node node) {
 9040                     return node.blendMode == null || !node.blendMode.isBound();
 9041                 }
 9042 
 9043                 @Override
 9044                 public StyleableProperty&lt;BlendMode&gt; getStyleableProperty(Node node) {
 9045                     return (StyleableProperty&lt;BlendMode&gt;)node.blendModeProperty();
 9046                 }
 9047             };
 9048         private static final CssMetaData&lt;Node,Number&gt; ROTATE =
 9049             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-rotate&quot;,
 9050                 SizeConverter.getInstance(), 0.0) {
 9051 
 9052                 @Override
 9053                 public boolean isSettable(Node node) {
 9054                     return node.nodeTransformation == null
 9055                         || node.nodeTransformation.rotate == null
 9056                         || node.nodeTransformation.canSetRotate();
 9057                 }
 9058 
 9059                 @Override
 9060                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9061                     return (StyleableProperty&lt;Number&gt;)node.rotateProperty();
 9062                 }
 9063             };
 9064         private static final CssMetaData&lt;Node,Number&gt; SCALE_X =
 9065             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-scale-x&quot;,
 9066                 SizeConverter.getInstance(), 1.0) {
 9067 
 9068                 @Override
 9069                 public boolean isSettable(Node node) {
 9070                     return node.nodeTransformation == null
 9071                         || node.nodeTransformation.scaleX == null
 9072                         || node.nodeTransformation.canSetScaleX();
 9073                 }
 9074 
 9075                 @Override
 9076                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9077                     return (StyleableProperty&lt;Number&gt;)node.scaleXProperty();
 9078                 }
 9079             };
 9080         private static final CssMetaData&lt;Node,Number&gt; SCALE_Y =
 9081             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-scale-y&quot;,
 9082                 SizeConverter.getInstance(), 1.0) {
 9083 
 9084                 @Override
 9085                 public boolean isSettable(Node node) {
 9086                     return node.nodeTransformation == null
 9087                         || node.nodeTransformation.scaleY == null
 9088                         || node.nodeTransformation.canSetScaleY();
 9089                 }
 9090 
 9091                 @Override
 9092                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9093                     return (StyleableProperty&lt;Number&gt;)node.scaleYProperty();
 9094                 }
 9095             };
 9096         private static final CssMetaData&lt;Node,Number&gt; SCALE_Z =
 9097             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-scale-z&quot;,
 9098                 SizeConverter.getInstance(), 1.0) {
 9099 
 9100                 @Override
 9101                 public boolean isSettable(Node node) {
 9102                     return node.nodeTransformation == null
 9103                         || node.nodeTransformation.scaleZ == null
 9104                         || node.nodeTransformation.canSetScaleZ();
 9105                 }
 9106 
 9107                 @Override
 9108                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9109                     return (StyleableProperty&lt;Number&gt;)node.scaleZProperty();
 9110                 }
 9111             };
 9112         private static final CssMetaData&lt;Node,Number&gt; TRANSLATE_X =
 9113             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-translate-x&quot;,
 9114                 SizeConverter.getInstance(), 0.0) {
 9115 
 9116                 @Override
 9117                 public boolean isSettable(Node node) {
 9118                     return node.nodeTransformation == null
 9119                         || node.nodeTransformation.translateX == null
 9120                         || node.nodeTransformation.canSetTranslateX();
 9121                 }
 9122 
 9123                 @Override
 9124                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9125                     return (StyleableProperty&lt;Number&gt;)node.translateXProperty();
 9126                 }
 9127             };
 9128         private static final CssMetaData&lt;Node,Number&gt; TRANSLATE_Y =
 9129             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-translate-y&quot;,
 9130                 SizeConverter.getInstance(), 0.0) {
 9131 
 9132                 @Override
 9133                 public boolean isSettable(Node node) {
 9134                     return node.nodeTransformation == null
 9135                         || node.nodeTransformation.translateY == null
 9136                         || node.nodeTransformation.canSetTranslateY();
 9137                 }
 9138 
 9139                 @Override
 9140                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9141                     return (StyleableProperty&lt;Number&gt;)node.translateYProperty();
 9142                 }
 9143             };
 9144         private static final CssMetaData&lt;Node,Number&gt; TRANSLATE_Z =
 9145             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-translate-z&quot;,
 9146                 SizeConverter.getInstance(), 0.0) {
 9147 
 9148                 @Override
 9149                 public boolean isSettable(Node node) {
 9150                     return node.nodeTransformation == null
 9151                         || node.nodeTransformation.translateZ == null
 9152                         || node.nodeTransformation.canSetTranslateZ();
 9153                 }
 9154 
 9155                 @Override
 9156                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9157                     return (StyleableProperty&lt;Number&gt;)node.translateZProperty();
 9158                 }
 9159             };
 9160          private static final CssMetaData&lt;Node, Number&gt; VIEW_ORDER
 9161                  = new CssMetaData&lt;Node, Number&gt;(&quot;-fx-view-order&quot;,
 9162                          SizeConverter.getInstance(), 0.0) {
 9163 
 9164                      @Override
 9165                      public boolean isSettable(Node node) {
 9166                          return node.miscProperties == null
 9167                          || node.miscProperties.viewOrder == null
 9168                          || !node.miscProperties.viewOrder.isBound();
 9169                      }
 9170 
 9171                      @Override
 9172                      public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9173                          return (StyleableProperty&lt;Number&gt;) node.viewOrderProperty();
 9174                      }
 9175                  };
 9176         private static final CssMetaData&lt;Node,Boolean&gt; VISIBILITY =
 9177             new CssMetaData&lt;Node,Boolean&gt;(&quot;visibility&quot;,
 9178                 new StyleConverter&lt;String,Boolean&gt;() {
 9179 
 9180                     @Override
 9181                     // [ visible | hidden | collapse | inherit ]
 9182                     public Boolean convert(ParsedValue&lt;String, Boolean&gt; value, Font font) {
 9183                         final String sval = value != null ? value.getValue() : null;
 9184                         return &quot;visible&quot;.equalsIgnoreCase(sval);
 9185                     }
 9186 
 9187                 },
 9188                 Boolean.TRUE) {
 9189 
 9190                 @Override
 9191                 public boolean isSettable(Node node) {
 9192                     return node.visible == null || !node.visible.isBound();
 9193                 }
 9194 
 9195                 @Override
 9196                 public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Node node) {
 9197                     return (StyleableProperty&lt;Boolean&gt;)node.visibleProperty();
 9198                 }
 9199             };
 9200 
 9201          private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
 9202 
 9203          static {
 9204 
 9205              final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
 9206                      new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;();
 9207              styleables.add(CURSOR);
 9208              styleables.add(EFFECT);
 9209              styleables.add(FOCUS_TRAVERSABLE);
 9210              styleables.add(OPACITY);
 9211              styleables.add(BLEND_MODE);
 9212              styleables.add(ROTATE);
 9213              styleables.add(SCALE_X);
 9214              styleables.add(SCALE_Y);
 9215              styleables.add(SCALE_Z);
 9216              styleables.add(VIEW_ORDER);
 9217              styleables.add(TRANSLATE_X);
 9218              styleables.add(TRANSLATE_Y);
 9219              styleables.add(TRANSLATE_Z);
 9220              styleables.add(VISIBILITY);
 9221              STYLEABLES = Collections.unmodifiableList(styleables);
 9222 
 9223          }
 9224     }
 9225 
 9226     /**
 9227      * @return The CssMetaData associated with this class, which may include the
 9228      * CssMetaData of its superclasses.
 9229      * @since JavaFX 8.0
 9230      */
 9231     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
 9232         //
 9233         // Super-lazy instantiation pattern from Bill Pugh. StyleableProperties
 9234         // is referenced no earlier (and therefore loaded no earlier by the
 9235         // class loader) than the moment that  getClassCssMetaData() is called.
 9236         // This avoids loading the CssMetaData instances until the point at
 9237         // which CSS needs the data.
 9238         //
 9239         return StyleableProperties.STYLEABLES;
 9240     }
 9241 
 9242     /**
 9243      * This method should delegate to {@link Node#getClassCssMetaData()} so that
 9244      * a Node&#39;s CssMetaData can be accessed without the need for reflection.
 9245      *
 9246      * @return The CssMetaData associated with this node, which may include the
 9247      * CssMetaData of its superclasses.
 9248      * @since JavaFX 8.0
 9249      */
 9250 
 9251     @Override
 9252     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
 9253         return getClassCssMetaData();
 9254     }
 9255 
 9256     /*
 9257      * @return  The Styles that match this CSS property for the given Node. The
 9258      * list is sorted by descending specificity.
 9259      */
 9260     // SB-dependency: RT-21096 has been filed to track this
 9261     static List&lt;Style&gt; getMatchingStyles(CssMetaData cssMetaData, Styleable styleable) {
 9262          return CssStyleHelper.getMatchingStyles(styleable, cssMetaData);
 9263     }
 9264 
 9265     final ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; getStyleMap() {
 9266          ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; map =
 9267                  (ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt;)getProperties().get(&quot;STYLEMAP&quot;);
 9268          Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; ret = CssStyleHelper.getMatchingStyles(map, this);
 9269          if (ret != null) {
 9270              if (ret instanceof ObservableMap) return (ObservableMap)ret;
 9271              return FXCollections.observableMap(ret);
 9272          }
 9273          return FXCollections.&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt;emptyObservableMap();
 9274      }
 9275 
 9276      /*
 9277       * RT-17293
 9278       */
 9279      // SB-dependency: RT-21096 has been filed to track this
 9280      final void setStyleMap(ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; styleMap) {
 9281          if (styleMap != null) getProperties().put(&quot;STYLEMAP&quot;, styleMap);
 9282          else getProperties().remove(&quot;STYLEMAP&quot;);
 9283      }
 9284 
 9285     /*
 9286      * Find CSS styles that were used to style this Node in its current pseudo-class state. The map will contain the styles from this node and,
 9287      * if the node is a Parent, its children. The node corresponding to an entry in the Map can be obtained by casting a StyleableProperty key to a
 9288      * javafx.beans.property.Property and calling getBean(). The List contains only those styles used to style the property and will contain
 9289      * styles used to resolve lookup values.
 9290      *
 9291      * @param styleMap A Map to be populated with the styles. If null, a new Map will be allocated.
 9292      * @return The Map populated with matching styles.
 9293      */
 9294     // SB-dependency: RT-21096 has been filed to track this
 9295     Map&lt;StyleableProperty&lt;?&gt;,List&lt;Style&gt;&gt; findStyles(Map&lt;StyleableProperty&lt;?&gt;,List&lt;Style&gt;&gt; styleMap) {
 9296 
 9297         Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; ret = CssStyleHelper.getMatchingStyles(styleMap, this);
 9298         return (ret != null) ? ret : Collections.&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt;emptyMap();
 9299     }
 9300 
 9301     /**
 9302      * Flags used to indicate in which way this node is dirty (or whether it
 9303      * is clean) and what must happen during the next CSS cycle on the
 9304      * scenegraph.
 9305      */
 9306     CssFlags cssFlag = CssFlags.CLEAN;
 9307 
 9308     /**
 9309      * Needed for testing.
 9310      */
 9311     final CssFlags getCSSFlags() { return cssFlag; }
 9312 
 9313     /**
 9314      * Called when a CSS pseudo-class change would cause styles to be reapplied.
 9315      */
 9316     private void requestCssStateTransition() {
 9317         // If there is no scene, then we cannot make it dirty, so we&#39;ll leave
 9318         // the flag alone
 9319         if (getScene() == null) return;
 9320         // Don&#39;t bother doing anything if the cssFlag is not CLEAN.
 9321         // If the flag indicates a DIRTY_BRANCH, the flag needs to be changed
 9322         // to UPDATE to ensure that NodeHelper.processCSS is called on the node.
 9323         if (cssFlag == CssFlags.CLEAN || cssFlag == CssFlags.DIRTY_BRANCH) {
 9324             cssFlag = CssFlags.UPDATE;
 9325             notifyParentsOfInvalidatedCSS();
 9326         }
 9327     }
 9328 
 9329     /**
 9330      * Used to specify that a pseudo-class of this Node has changed. If the
 9331      * pseudo-class is used in a CSS selector that matches this Node, CSS will
 9332      * be reapplied. Typically, this method is called from the {@code invalidated}
 9333      * method of a property that is used as a pseudo-class. For example:
 9334      * &lt;pre&gt;&lt;code&gt;
 9335      *
 9336      *     private static final PseudoClass MY_PSEUDO_CLASS_STATE = PseudoClass.getPseudoClass(&quot;my-state&quot;);
 9337      *
 9338      *     BooleanProperty myPseudoClassState = new BooleanPropertyBase(false) {
 9339      *
 9340      *           {@literal @}Override public void invalidated() {
 9341      *                pseudoClassStateChanged(MY_PSEUDO_CLASS_STATE, get());
 9342      *           }
 9343      *
 9344      *           {@literal @}Override public Object getBean() {
 9345      *               return MyControl.this;
 9346      *           }
 9347      *
 9348      *           {@literal @}Override public String getName() {
 9349      *               return &quot;myPseudoClassState&quot;;
 9350      *           }
 9351      *       };
 9352      * &lt;/code&gt;&lt;/pre&gt;
 9353      * @param pseudoClass the pseudo-class that has changed state
 9354      * @param active whether or not the state is active
 9355      * @since JavaFX 8.0
 9356      */
 9357     public final void pseudoClassStateChanged(PseudoClass pseudoClass, boolean active) {
 9358 
 9359         final boolean modified = active
 9360                 ? pseudoClassStates.add(pseudoClass)
 9361                 : pseudoClassStates.remove(pseudoClass);
 9362 
 9363         if (modified &amp;&amp; styleHelper != null) {
 9364             final boolean isTransition = styleHelper.pseudoClassStateChanged(pseudoClass);
 9365             if (isTransition) {
 9366                 requestCssStateTransition();
 9367             }
 9368         }
 9369    }
 9370 
 9371     // package so that StyleHelper can get at it
 9372     final ObservableSet&lt;PseudoClass&gt; pseudoClassStates = new PseudoClassState();
 9373     private final ObservableSet&lt;PseudoClass&gt; unmodifiablePseudoClassStates =
 9374             FXCollections.unmodifiableObservableSet(pseudoClassStates);
 9375     /**
 9376      * @return The active pseudo-class states of this Node, wrapped in an unmodifiable ObservableSet
 9377      * @since JavaFX 8.0
 9378      */
 9379     @Override
 9380     public final ObservableSet&lt;PseudoClass&gt; getPseudoClassStates() {
 9381         return unmodifiablePseudoClassStates;
 9382     }
 9383 
 9384     // Walks up the tree telling each parent that the pseudo class state of
 9385     // this node has changed.
 9386     final void notifyParentsOfInvalidatedCSS() {
 9387         SubScene subScene = getSubScene();
 9388         Parent root = (subScene != null) ?
 9389                 subScene.getRoot() : getScene().getRoot();
 9390 
 9391         if (!root.isDirty(DirtyBits.NODE_CSS)) {
 9392             // Ensure that Scene.root is marked as dirty. If the scene isn&#39;t
 9393             // dirty, nothing will get repainted. This bit is cleared from
 9394             // Scene in doCSSPass().
 9395             NodeHelper.markDirty(root, DirtyBits.NODE_CSS);
 9396             if (subScene != null) {
 9397                 // If the node is part of a subscene, then we must ensure that
 9398                 // the we not only mark subScene.root dirty, but continue and
 9399                 // call subScene.notifyParentsOfInvalidatedCSS() until
 9400                 // Scene.root gets marked dirty, via the recursive call:
 9401                 subScene.cssFlag = CssFlags.UPDATE;
 9402                 subScene.notifyParentsOfInvalidatedCSS();
 9403             }
 9404         }
 9405         Parent _parent = getParent();
 9406         while (_parent != null) {
 9407             if (_parent.cssFlag == CssFlags.CLEAN) {
 9408                 _parent.cssFlag = CssFlags.DIRTY_BRANCH;
 9409                 _parent = _parent.getParent();
 9410             } else {
 9411                 _parent = null;
 9412             }
 9413         }
 9414     }
 9415 
 9416     final void reapplyCSS() {
 9417 
 9418         if (getScene() == null) return;
 9419 
 9420         if (cssFlag == CssFlags.REAPPLY) return;
 9421 
 9422         if (cssFlag == CssFlags.DIRTY_BRANCH) {
 9423             // JDK-8193445 - don&#39;t reapply CSS from here
 9424             // Defer CSS application to this Node by marking cssFlag as REAPPLY
 9425             cssFlag = CssFlags.REAPPLY;
 9426             return;
 9427         }
 9428 
 9429         // RT-36838 - don&#39;t reapply CSS in the middle of an update
 9430         if (cssFlag == CssFlags.UPDATE) {
 9431             cssFlag = CssFlags.REAPPLY;
 9432             notifyParentsOfInvalidatedCSS();
 9433             return;
 9434         }
 9435 
 9436         reapplyCss();
 9437 
 9438         //
 9439         // One idiom employed by developers is to, during the layout pass,
 9440         // add or remove nodes from the scene. For example, a ScrollPane
 9441         // might add scroll bars to itself if it determines during layout
 9442         // that it needs them, or a ListView might add cells to itself if
 9443         // it determines that it needs to. In such situations we must
 9444         // apply the CSS immediately and not add it to the scene&#39;s queue
 9445         // for deferred action.
 9446         //
 9447         if (getParent() != null &amp;&amp; getParent().isPerformingLayout()) {
 9448             NodeHelper.processCSS(this);
 9449         } else {
 9450             notifyParentsOfInvalidatedCSS();
 9451         }
 9452 
 9453     }
 9454 
 9455     //
 9456     // This method &quot;reapplies&quot; CSS to this node and all of its children. Reapplying CSS
 9457     // means that new style maps are calculated for the node. The process of reapplying
 9458     // CSS may reset the CSS properties of a node to their initial state, but the _new_
 9459     // styles are not applied as part of this process.
 9460     //
 9461     // There is no check of the CSS state of a child since reapply takes precedence
 9462     // over other CSS states.
 9463     //
 9464     private void reapplyCss() {
 9465 
 9466         // Hang on to current styleHelper so we can know whether
 9467         // createStyleHelper returned the same styleHelper
 9468         final CssStyleHelper oldStyleHelper = styleHelper;
 9469 
 9470         // CSS state is &quot;REAPPLY&quot;
 9471         cssFlag = CssFlags.REAPPLY;
 9472 
 9473         styleHelper = CssStyleHelper.createStyleHelper(this);
 9474 
 9475         // REAPPLY to my children, too.
 9476         if (this instanceof Parent) {
 9477 
 9478             // minor optimization to avoid calling createStyleHelper on children
 9479             // when we know there will not be any change in the style maps.
 9480             final boolean visitChildren =
 9481                     // If we don&#39;t have a styleHelper, then we should visit the children of this parent
 9482                     // since there might be styles that depend on being a child of this parent.
 9483                     // In other words, we have .a &gt; .b { blah: blort; }, but no styles for &quot;.a&quot; itself.
 9484                     styleHelper == null ||
 9485                     // if the styleHelper changed, then we definitely need to visit the children
 9486                     // since the new styles may have an effect on the children&#39;s styles calculated values.
 9487                     (oldStyleHelper != styleHelper) ||
 9488                     // If our parent is null, then we&#39;re the root of a scene or sub-scene, most likely,
 9489                     // and we&#39;ll visit children because elsewhere the code depends on root.reapplyCSS()
 9490                     // to force css to be reapplied (whether it needs to be or not).
 9491                     (getParent() == null) ||
 9492                     // If our parent&#39;s cssFlag is other than clean, then the parent may have just had
 9493                     // CSS reapplied. If the parent just had CSS reapplied, then some of its styles
 9494                     // may affect my children&#39;s styles.
 9495                     (getParent().cssFlag != CssFlags.CLEAN);
 9496 
 9497             if (visitChildren) {
 9498 
 9499                 List&lt;Node&gt; children = ((Parent) this).getChildren();
 9500                 for (int n = 0, nMax = children.size(); n &lt; nMax; n++) {
 9501                     Node child = children.get(n);
 9502                     child.reapplyCss();
 9503                 }
 9504             }
 9505 
 9506         } else if (this instanceof SubScene) {
 9507 
 9508             // SubScene root is a Parent, but reapplyCss is a private method in Node
 9509             final Node subSceneRoot = ((SubScene)this).getRoot();
 9510             if (subSceneRoot != null) {
 9511                 subSceneRoot.reapplyCss();
 9512             }
 9513 
 9514         } else if (styleHelper == null) {
 9515             //
 9516             // If this is not a Parent and there is no styleHelper, then the CSS state is &quot;CLEAN&quot;
 9517             // since there are no styles to apply or children to update.
 9518             //
 9519             cssFlag = CssFlags.CLEAN;
 9520             return;
 9521         }
 9522 
 9523         cssFlag = CssFlags.UPDATE;
 9524 
 9525     }
 9526 
 9527     void processCSS() {
 9528         switch (cssFlag) {
 9529             case CLEAN:
 9530                 break;
 9531             case DIRTY_BRANCH:
 9532             {
 9533                 Parent me = (Parent)this;
 9534                 // clear the flag first in case the flag is set to something
 9535                 // other than clean by downstream processing.
 9536                 me.cssFlag = CssFlags.CLEAN;
 9537                 List&lt;Node&gt; children = me.getChildren();
 9538                 for (int i=0, max=children.size(); i&lt;max; i++) {
 9539                     children.get(i).processCSS();
 9540                 }
 9541                 break;
 9542             }
 9543             case REAPPLY:
 9544             case UPDATE:
 9545             default:
 9546                 NodeHelper.processCSS(this);
 9547         }
 9548     }
 9549 
 9550     /**
 9551      * If required, apply styles to this Node and its children, if any. This method does not normally need to
 9552      * be invoked directly but may be used in conjunction with {@link Parent#layout()} to size a Node before the
 9553      * next pulse, or if the {@link #getScene() Scene} is not in a {@link javafx.stage.Stage}.
 9554      * &lt;p&gt;Provided that the Node&amp;#39;s {@link #getScene() Scene} is not null, CSS is applied to this Node regardless
 9555      * of whether this Node&amp;#39;s CSS state is clean. CSS styles are applied from the top-most parent
 9556      * of this Node whose CSS state is other than clean, which may affect the styling of other nodes.
 9557      * This method is a no-op if the Node is not in a Scene. The Scene does not have to be in a Stage.&lt;/p&gt;
 9558      * &lt;p&gt;This method does not invoke the {@link Parent#layout()} method. Typically, the caller will use the
 9559      * following sequence of operations.&lt;/p&gt;
 9560      * &lt;pre&gt;{@code
 9561      *     parentNode.applyCss();
 9562      *     parentNode.layout();
 9563      * }&lt;/pre&gt;
 9564      * &lt;p&gt;As a more complete example, the following code uses {@code applyCss()} and {@code layout()} to find
 9565      * the width and height of the Button before the Stage has been shown. If either the call to {@code applyCss()}
 9566      * or the call to {@code layout()} is commented out, the calls to {@code getWidth()} and {@code getHeight()}
 9567      * will return zero (until some time after the Stage is shown). &lt;/p&gt;
 9568      * &lt;pre&gt;&lt;code&gt;
 9569      * {@literal @}Override
 9570      * public void start(Stage stage) throws Exception {
 9571      *
 9572      *    Group root = new Group();
 9573      *    Scene scene = new Scene(root);
 9574      *
 9575      *    Button button = new Button(&quot;Hello World&quot;);
 9576      *    root.getChildren().add(button);
 9577      *
 9578      *    root.applyCss();
 9579      *    root.layout();
 9580      *
 9581      *    double width = button.getWidth();
 9582      *    double height = button.getHeight();
 9583      *
 9584      *    System.out.println(width + &quot;, &quot; + height);
 9585      *
 9586      *    stage.setScene(scene);
 9587      *    stage.show();
 9588      * }
 9589      * &lt;/code&gt;&lt;/pre&gt;
 9590      * @since JavaFX 8.0
 9591      */
 9592     public final void applyCss() {
 9593 
 9594         if (getScene() == null) {
 9595             return;
 9596         }
 9597 
 9598         // update, unless reapply
 9599         if (cssFlag != CssFlags.REAPPLY) cssFlag = CssFlags.UPDATE;
 9600 
 9601         //
 9602         // RT-28394 - need to see if any ancestor has a flag UPDATE
 9603         // If so, process css from the top-most CssFlags.UPDATE node
 9604         // since my ancestor&#39;s styles may affect mine.
 9605         //
 9606         // If the scene-graph root isn&#39;t NODE_CSS dirty, then all my
 9607         // ancestor flags should be CLEAN and I can skip this lookup.
 9608         //
 9609         Node topMost = this;
 9610 
 9611         final boolean dirtyRoot = getScene().getRoot().isDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);
 9612         if (dirtyRoot) {
 9613 
 9614             Node _parent = getParent();
 9615             while (_parent != null) {
 9616                 if (_parent.cssFlag == CssFlags.UPDATE || _parent.cssFlag == CssFlags.REAPPLY) {
 9617                     topMost = _parent;
 9618                 }
 9619                 _parent = _parent.getParent();
 9620             }
 9621 
 9622             // Note: this code used to mark the parent nodes with DIRTY_BRANCH,
 9623             // but that isn&#39;t necessary since UPDATE will apply css to all of
 9624             // a Parent&#39;s children.
 9625 
 9626             // If we&#39;re at the root of the scene-graph, make sure the NODE_CSS
 9627             // dirty bit is cleared (see Scene#doCSSPass())
 9628             if (topMost == getScene().getRoot()) {
 9629                 getScene().getRoot().clearDirty(DirtyBits.NODE_CSS);
 9630             }
 9631         }
 9632 
 9633         topMost.processCSS();
 9634 
 9635     }
 9636 
 9637     /*
 9638      * If invoked, will update styles from here on down. This method should not be called directly. If
 9639      * overridden, the overriding method must at some point call {@code super.processCSSImpl} to ensure that
 9640      * this Node&#39;s CSS state is properly updated.
 9641      *
 9642      * Note that the difference between this method and {@link #applyCss()} is that this method
 9643      * updates styles for this node on down; whereas, {@code applyCss()} looks for the top-most ancestor that needs
 9644      * CSS update and apply styles from that node on down.
 9645      *
 9646      * Note: This method MUST only be called via its accessor method.
 9647      */
 9648     private void doProcessCSS() {
 9649 
 9650         // Nothing to do...
 9651         if (cssFlag == CssFlags.CLEAN) return;
 9652 
 9653         // if REAPPLY was deferred, process it now...
 9654         if (cssFlag == CssFlags.REAPPLY) {
 9655             reapplyCss();
 9656         }
 9657 
 9658         // Clear the flag first in case the flag is set to something
 9659         // other than clean by downstream processing.
 9660         cssFlag = CssFlags.CLEAN;
 9661 
 9662         // Transition to the new state and apply styles
 9663         if (styleHelper != null &amp;&amp; getScene() != null) {
 9664             styleHelper.transitionToState(this);
 9665         }
 9666     }
 9667 
 9668 
 9669     /**
 9670      * A StyleHelper for this node.
 9671      * A StyleHelper contains all the css styles for this node
 9672      * and knows how to apply them when our state changes.
 9673      */
 9674     CssStyleHelper styleHelper;
 9675 
 9676     private static final PseudoClass HOVER_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;hover&quot;);
 9677     private static final PseudoClass PRESSED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;pressed&quot;);
 9678     private static final PseudoClass DISABLED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;disabled&quot;);
 9679     private static final PseudoClass FOCUSED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;focused&quot;);
 9680     private static final PseudoClass SHOW_MNEMONICS_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;show-mnemonics&quot;);
 9681 
 9682     private static abstract class LazyTransformProperty
 9683             extends ReadOnlyObjectProperty&lt;Transform&gt; {
 9684 
 9685         protected static final int VALID = 0;
 9686         protected static final int INVALID = 1;
 9687         protected static final int VALIDITY_UNKNOWN = 2;
 9688         protected int valid = INVALID;
 9689 
 9690         private ExpressionHelper&lt;Transform&gt; helper;
 9691 
 9692         private Transform transform;
 9693         private boolean canReuse = false;
 9694 
 9695         @Override
 9696         public void addListener(InvalidationListener listener) {
 9697             helper = ExpressionHelper.addListener(helper, this, listener);
 9698         }
 9699 
 9700         @Override
 9701         public void removeListener(InvalidationListener listener) {
 9702             helper = ExpressionHelper.removeListener(helper, listener);
 9703         }
 9704 
 9705         @Override
 9706         public void addListener(ChangeListener&lt;? super Transform&gt; listener) {
 9707             helper = ExpressionHelper.addListener(helper, this, listener);
 9708         }
 9709 
 9710         @Override
 9711         public void removeListener(ChangeListener&lt;? super Transform&gt; listener) {
 9712             helper = ExpressionHelper.removeListener(helper, listener);
 9713         }
 9714 
 9715         protected Transform getInternalValue() {
 9716             if (valid == INVALID ||
 9717                     (valid == VALIDITY_UNKNOWN &amp;&amp; computeValidity() == INVALID)) {
 9718                 transform = computeTransform(canReuse ? transform : null);
 9719                 canReuse = true;
 9720                 valid = validityKnown() ? VALID : VALIDITY_UNKNOWN;
 9721             }
 9722 
 9723             return transform;
 9724         }
 9725 
 9726         @Override
 9727         public Transform get() {
 9728             transform = getInternalValue();
 9729             canReuse = false;
 9730             return transform;
 9731         }
 9732 
 9733         public void validityUnknown() {
 9734             if (valid == VALID) {
 9735                 valid = VALIDITY_UNKNOWN;
 9736             }
 9737         }
 9738 
 9739         public void invalidate() {
 9740             if (valid != INVALID) {
 9741                 valid = INVALID;
 9742                 ExpressionHelper.fireValueChangedEvent(helper);
 9743             }
 9744         }
 9745 
 9746         protected abstract boolean validityKnown();
 9747         protected abstract int computeValidity();
 9748         protected abstract Transform computeTransform(Transform reuse);
 9749     }
 9750 
 9751     private static abstract class LazyBoundsProperty
 9752             extends ReadOnlyObjectProperty&lt;Bounds&gt; {
 9753         private ExpressionHelper&lt;Bounds&gt; helper;
 9754         private boolean valid;
 9755 
 9756         private Bounds bounds;
 9757 
 9758         @Override
 9759         public void addListener(InvalidationListener listener) {
 9760             helper = ExpressionHelper.addListener(helper, this, listener);
 9761         }
 9762 
 9763         @Override
 9764         public void removeListener(InvalidationListener listener) {
 9765             helper = ExpressionHelper.removeListener(helper, listener);
 9766         }
 9767 
 9768         @Override
 9769         public void addListener(ChangeListener&lt;? super Bounds&gt; listener) {
 9770             helper = ExpressionHelper.addListener(helper, this, listener);
 9771         }
 9772 
 9773         @Override
 9774         public void removeListener(ChangeListener&lt;? super Bounds&gt; listener) {
 9775             helper = ExpressionHelper.removeListener(helper, listener);
 9776         }
 9777 
 9778         @Override
 9779         public Bounds get() {
 9780             if (!valid) {
 9781                 bounds = computeBounds();
 9782                 valid = true;
 9783             }
 9784 
 9785             return bounds;
 9786         }
 9787 
 9788         public void invalidate() {
 9789             if (valid) {
 9790                 valid = false;
 9791                 ExpressionHelper.fireValueChangedEvent(helper);
 9792             }
 9793         }
 9794 
 9795         protected abstract Bounds computeBounds();
 9796     }
 9797 
 9798     private static final BoundsAccessor boundsAccessor = (bounds, tx, node) -&gt; node.getGeomBounds(bounds, tx);
 9799 
 9800     /**
 9801      * The accessible role for this {@code Node}.
 9802      * &lt;p&gt;
 9803      * The screen reader uses the role of a node to determine the
 9804      * attributes and actions that are supported.
 9805      *
 9806      * @defaultValue {@link AccessibleRole#NODE}
 9807      * @see AccessibleRole
 9808      *
 9809      * @since JavaFX 8u40
 9810      */
 9811     private ObjectProperty&lt;AccessibleRole&gt; accessibleRole;
 9812 
 9813     public final void setAccessibleRole(AccessibleRole value) {
 9814         if (value == null) value = AccessibleRole.NODE;
 9815         accessibleRoleProperty().set(value);
 9816     }
 9817 
 9818     public final AccessibleRole getAccessibleRole() {
 9819         if (accessibleRole == null) return AccessibleRole.NODE;
 9820         return accessibleRoleProperty().get();
 9821     }
 9822 
 9823     public final ObjectProperty&lt;AccessibleRole&gt; accessibleRoleProperty() {
 9824         if (accessibleRole == null) {
 9825             accessibleRole = new SimpleObjectProperty&lt;AccessibleRole&gt;(this, &quot;accessibleRole&quot;, AccessibleRole.NODE);
 9826         }
 9827         return accessibleRole;
 9828     }
 9829 
 9830     public final void setAccessibleRoleDescription(String value) {
 9831         accessibleRoleDescriptionProperty().set(value);
 9832     }
 9833 
 9834     public final String getAccessibleRoleDescription() {
 9835         if (accessibilityProperties == null) return null;
 9836         if (accessibilityProperties.accessibleRoleDescription == null) return null;
 9837         return accessibleRoleDescriptionProperty().get();
 9838     }
 9839 
 9840     /**
 9841      * The role description of this {@code Node}.
 9842      * &lt;p&gt;
 9843      * Normally, when a role is provided for a node, the screen reader
 9844      * speaks the role as well as the contents of the node.  When this
 9845      * value is set, it is possible to override the default.  This is
 9846      * useful because the set of roles is predefined.  For example,
 9847      * it is possible to set the role of a node to be a button, but
 9848      * have the role description be arbitrary text.
 9849      *
 9850      * @return the role description of this {@code Node}.
 9851      * @defaultValue null
 9852      *
 9853      * @since JavaFX 8u40
 9854      */
 9855     public final ObjectProperty&lt;String&gt; accessibleRoleDescriptionProperty() {
 9856         return getAccessibilityProperties().getAccessibleRoleDescription();
 9857     }
 9858 
 9859     public final void setAccessibleText(String value) {
 9860         accessibleTextProperty().set(value);
 9861     }
 9862 
 9863     public final String getAccessibleText() {
 9864         if (accessibilityProperties == null) return null;
 9865         if (accessibilityProperties.accessibleText == null) return null;
 9866         return accessibleTextProperty().get();
 9867     }
 9868 
 9869     /**
 9870      * The accessible text for this {@code Node}.
 9871      * &lt;p&gt;
 9872      * This property is used to set the text that the screen
 9873      * reader will speak.  If a node normally speaks text,
 9874      * that text is overriden.  For example, a button
 9875      * usually speaks using the text in the control but will
 9876      * no longer do this when this value is set.
 9877      *
 9878      * @return accessible text for this {@code Node}.
 9879      * @defaultValue null
 9880      *
 9881      * @since JavaFX 8u40
 9882      */
 9883     public final ObjectProperty&lt;String&gt; accessibleTextProperty() {
 9884         return getAccessibilityProperties().getAccessibleText();
 9885     }
 9886 
 9887     public final void setAccessibleHelp(String value) {
 9888         accessibleHelpProperty().set(value);
 9889     }
 9890 
 9891     public final String getAccessibleHelp() {
 9892         if (accessibilityProperties == null) return null;
 9893         if (accessibilityProperties.accessibleHelp == null) return null;
 9894         return accessibleHelpProperty().get();
 9895     }
 9896 
 9897     /**
 9898      * The accessible help text for this {@code Node}.
 9899      * &lt;p&gt;
 9900      * The help text provides a more detailed description of the
 9901      * accessible text for a node.  By default, if the node has
 9902      * a tool tip, this text is used.
 9903      *
 9904      * @return the accessible help text for this {@code Node}.
 9905      * @defaultValue null
 9906      *
 9907      * @since JavaFX 8u40
 9908      */
 9909     public final ObjectProperty&lt;String&gt; accessibleHelpProperty() {
 9910         return getAccessibilityProperties().getAccessibleHelp();
 9911     }
 9912 
 9913     AccessibilityProperties accessibilityProperties;
 9914     private AccessibilityProperties getAccessibilityProperties() {
 9915         if (accessibilityProperties == null) {
 9916             accessibilityProperties = new AccessibilityProperties();
 9917         }
 9918         return accessibilityProperties;
 9919     }
 9920 
 9921     private class AccessibilityProperties {
 9922         ObjectProperty&lt;String&gt; accessibleRoleDescription;
 9923         ObjectProperty&lt;String&gt; getAccessibleRoleDescription() {
 9924             if (accessibleRoleDescription == null) {
 9925                 accessibleRoleDescription = new SimpleObjectProperty&lt;String&gt;(Node.this, &quot;accessibleRoleDescription&quot;, null);
 9926             }
 9927             return accessibleRoleDescription;
 9928         }
 9929         ObjectProperty&lt;String&gt; accessibleText;
 9930         ObjectProperty&lt;String&gt; getAccessibleText() {
 9931             if (accessibleText == null) {
 9932                 accessibleText = new SimpleObjectProperty&lt;String&gt;(Node.this, &quot;accessibleText&quot;, null);
 9933             }
 9934             return accessibleText;
 9935         }
 9936         ObjectProperty&lt;String&gt; accessibleHelp;
 9937         ObjectProperty&lt;String&gt; getAccessibleHelp() {
 9938             if (accessibleHelp == null) {
 9939                 accessibleHelp = new SimpleObjectProperty&lt;String&gt;(Node.this, &quot;accessibleHelp&quot;, null);
 9940             }
 9941             return accessibleHelp;
 9942         }
 9943     }
 9944 
 9945     /**
 9946      * This method is called by the assistive technology to request
 9947      * the value for an attribute.
 9948      * &lt;p&gt;
 9949      * This method is commonly overridden by subclasses to implement
 9950      * attributes that are required for a specific role.&lt;br&gt;
 9951      * If a particular attribute is not handled, the superclass implementation
 9952      * must be called.
 9953      * &lt;/p&gt;
 9954      *
 9955      * @param attribute the requested attribute
 9956      * @param parameters optional list of parameters
 9957      * @return the value for the requested attribute
 9958      *
 9959      * @see AccessibleAttribute
 9960      *
 9961      * @since JavaFX 8u40
 9962      */
 9963     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
 9964         switch (attribute) {
 9965             case ROLE: return getAccessibleRole();
 9966             case ROLE_DESCRIPTION: return getAccessibleRoleDescription();
 9967             case TEXT: return getAccessibleText();
 9968             case HELP: return getAccessibleHelp();
 9969             case PARENT: return getParent();
 9970             case SCENE: return getScene();
 9971             case BOUNDS: return localToScreen(getBoundsInLocal());
 9972             case DISABLED: return isDisabled();
 9973             case FOCUSED: return isFocused();
 9974             case VISIBLE: return isVisible();
 9975             case LABELED_BY: return labeledBy;
 9976             default: return null;
 9977         }
 9978     }
 9979 
 9980     /**
 9981      * This method is called by the assistive technology to request the action
 9982      * indicated by the argument should be executed.
 9983      * &lt;p&gt;
 9984      * This method is commonly overridden by subclasses to implement
 9985      * action that are required for a specific role.&lt;br&gt;
 9986      * If a particular action is not handled, the superclass implementation
 9987      * must be called.
 9988      * &lt;/p&gt;
 9989      *
 9990      * @param action the action to execute
 9991      * @param parameters optional list of parameters
 9992      *
 9993      * @see AccessibleAction
 9994      *
 9995      * @since JavaFX 8u40
 9996      */
 9997     public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
 9998         switch (action) {
 9999             case REQUEST_FOCUS:
10000                 if (isFocusTraversable()) {
10001                     requestFocus();
10002                 }
10003                 break;
10004             case SHOW_MENU: {
10005                 Bounds b = getBoundsInLocal();
10006                 Point2D pt = localToScreen(b.getMaxX(), b.getMaxY());
10007                 ContextMenuEvent event =
10008                     new ContextMenuEvent(ContextMenuEvent.CONTEXT_MENU_REQUESTED,
10009                     b.getMaxX(), b.getMaxY(), pt.getX(), pt.getY(),
10010                     false, new PickResult(this, b.getMaxX(), b.getMaxY()));
10011                 Event.fireEvent(this, event);
10012                 break;
10013             }
10014             default:
10015         }
10016     }
10017 
10018     /**
10019      * This method is called by the application to notify the assistive
10020      * technology that the value for an attribute has changed.
10021      *
10022      * @param attributes the attribute whose value has changed
10023      *
10024      * @see AccessibleAttribute
10025      *
10026      * @since JavaFX 8u40
10027      */
10028     public final void notifyAccessibleAttributeChanged(AccessibleAttribute attributes) {
10029         if (accessible == null) {
10030             Scene scene = getScene();
10031             if (scene != null) {
10032                 accessible = scene.removeAccessible(this);
10033             }
10034         }
10035         if (accessible != null) {
10036             accessible.sendNotification(attributes);
10037         }
10038     }
10039 
10040     Accessible accessible;
10041     Accessible getAccessible() {
10042         if (accessible == null) {
10043             Scene scene = getScene();
10044             /* It is possible the node was reparented and getAccessible()
10045              * is called before the pulse. Try to recycle the accessible
10046              * before creating a new one.
10047              * Note: this code relies that an accessible can never be on
10048              * more than one Scene#accMap. Thus, the only way
10049              * scene#removeAccessible() returns non-null is if the node
10050              * old scene and new scene are the same object.
10051              */
10052             if (scene != null) {
10053                 accessible = scene.removeAccessible(this);
10054             }
10055         }
10056         if (accessible == null) {
10057             accessible = Application.GetApplication().createAccessible();
10058             accessible.setEventHandler(new Accessible.EventHandler() {
10059                 @SuppressWarnings(&quot;deprecation&quot;)
10060                 @Override public AccessControlContext getAccessControlContext() {
10061                     Scene scene = getScene();
10062                     if (scene == null) {
10063                         /* This can happen during the release process of an accessible object. */
10064                         throw new RuntimeException(&quot;Accessbility requested for node not on a scene&quot;);
10065                     }
10066                     if (scene.getPeer() != null) {
10067                         return scene.getPeer().getAccessControlContext();
10068                     } else {
10069                         /* In some rare cases the accessible for a Node is needed
10070                          * before its scene is made visible. For example, the screen reader
10071                          * might ask a Menu for its ContextMenu before the ContextMenu
10072                          * is made visible. That is a problem because the Window for the
10073                          * ContextMenu is only created immediately before the first time
10074                          * it is shown.
10075                          */
10076                         return scene.acc;
10077                     }
10078                 }
10079                 @Override public Object getAttribute(AccessibleAttribute attribute, Object... parameters) {
10080                     return queryAccessibleAttribute(attribute, parameters);
10081                 }
10082                 @Override public void executeAction(AccessibleAction action, Object... parameters) {
10083                     executeAccessibleAction(action, parameters);
10084                 }
10085                 @Override public String toString() {
10086                     String klassName = Node.this.getClass().getName();
10087                     return klassName.substring(klassName.lastIndexOf(&#39;.&#39;)+1);
10088                 }
10089             });
10090         }
10091         return accessible;
10092     }
10093 
10094     void releaseAccessible() {
10095         Accessible acc = this.accessible;
10096         if (acc != null) {
10097             accessible = null;
10098             acc.dispose();
10099         }
10100     }
10101 
10102 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>