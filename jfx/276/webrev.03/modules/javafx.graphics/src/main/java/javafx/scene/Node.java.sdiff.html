<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/java/javafx/scene/Node.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../animation/Timeline.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>modules/javafx.graphics/src/main/java/javafx/scene/Node.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  293  * drawn at the origin (x=0, y=0) and has a width of 100 and height of 30 and
  294  * you apply a {@link javafx.scene.transform.Rotate} with a 90 degree rotation
  295  * (angle=90) and a pivot at the origin (pivotX=0, pivotY=0), then
  296  * the rectangle will be drawn as if its x and y were zero but its height was
  297  * 100 and its width -30. That is, it is as if a pin is being stuck at the top
  298  * left corner and the rectangle is rotating 90 degrees clockwise around that
  299  * pin. If the pivot point is instead placed in the center of the rectangle
  300  * (at point x=50, y=15) then the rectangle will instead appear to rotate about
  301  * its center.
  302  * &lt;p&gt;
  303  * Note that as with all transformations, the x, y, width, and height variables
  304  * of the rectangle (which remain relative to the local coordinate space) have
  305  * not changed, but rather the transformation alters the entire coordinate space
  306  * of the rectangle.
  307  * &lt;p&gt;
  308  * A &lt;b&gt;scaling&lt;/b&gt; transformation causes a node to either appear larger or
  309  * smaller depending on the scaling factor. Scaling alters the coordinate space
  310  * of the node such that each unit of distance along the axis in local
  311  * coordinates is multiplied by the scale factor. As with rotation
  312  * transformations, scaling transformations are applied about a &quot;pivot&quot; point.
<span class="line-modified">  313  * You can think of this as the point in the Node around which you &quot;zoom&quot;.  For</span>
  314  * example, if you create a {@link javafx.scene.shape.Rectangle} with a
  315  * {@code strokeWidth} of 5, and a width and height of 50, and you apply a
  316  * {@link javafx.scene.transform.Scale} with scale factors (x=2.0, y=2.0) and
  317  * a pivot at the origin (pivotX=0, pivotY=0), the entire rectangle
  318  * (including the stroke) will double in size, growing to the right and
  319  * downwards from the origin.
  320  * &lt;p&gt;
  321  * A &lt;b&gt;shearing&lt;/b&gt; transformation, sometimes called a skew, effectively
  322  * rotates one axis so that the x and y axes are no longer perpendicular.
  323  * &lt;p&gt;
  324  * Multiple transformations may be applied to a node by specifying an ordered
  325  * chain of transforms.  The order in which the transforms are applied is
  326  * defined by the ObservableList specified in the {@link #getTransforms transforms} variable.
  327  *
  328  * &lt;h2&gt;Bounding Rectangles&lt;/h2&gt;
  329  * &lt;p&gt;
  330  * Since every {@code Node} has transformations, every Node&#39;s geometric
  331  * bounding rectangle can be described differently depending on whether
  332  * transformations are accounted for or not.
  333  * &lt;p&gt;
</pre>
<hr />
<pre>
  845 
  846         if (isDirty(DirtyBits.NODE_BLENDMODE)) {
  847             BlendMode mode = getBlendMode();
  848             peer.setNodeBlendMode((mode == null)
  849                                   ? null
  850                                   : EffectHelper.getToolkitBlendMode(mode));
  851         }
  852     }
  853 
  854     /*************************************************************************
  855     *                                                                        *
  856     *                                                                        *
  857     *                                                                        *
  858     *************************************************************************/
  859 
  860     private static final Object USER_DATA_KEY = new Object();
  861     // A map containing a set of properties for this node
  862     private ObservableMap&lt;Object, Object&gt; properties;
  863 
  864     /**
<span class="line-modified">  865       * Returns an observable map of properties on this node for use primarily</span>
<span class="line-modified">  866       * by application developers.</span>
<span class="line-modified">  867       *</span>
<span class="line-modified">  868       * @return an observable map of properties on this node for use primarily</span>
<span class="line-modified">  869       * by application developers</span>
<span class="line-modified">  870       */</span>

  871      public final ObservableMap&lt;Object, Object&gt; getProperties() {
  872         if (properties == null) {
  873             properties = FXCollections.observableMap(new HashMap&lt;Object, Object&gt;());
  874         }
  875         return properties;
  876     }
  877 
  878     /**
  879      * Tests if Node has properties.
  880      * @return true if node has properties.
  881      */
  882      public boolean hasProperties() {
  883         return properties != null &amp;&amp; !properties.isEmpty();
  884     }
  885 
  886     /**
  887      * Convenience method for setting a single Object property that can be
  888      * retrieved at a later date. This is functionally equivalent to calling
  889      * the getProperties().put(Object key, Object value) method. This can later
  890      * be retrieved by calling {@link Node#getUserData()}.
</pre>
</td>
<td>
<hr />
<pre>
  293  * drawn at the origin (x=0, y=0) and has a width of 100 and height of 30 and
  294  * you apply a {@link javafx.scene.transform.Rotate} with a 90 degree rotation
  295  * (angle=90) and a pivot at the origin (pivotX=0, pivotY=0), then
  296  * the rectangle will be drawn as if its x and y were zero but its height was
  297  * 100 and its width -30. That is, it is as if a pin is being stuck at the top
  298  * left corner and the rectangle is rotating 90 degrees clockwise around that
  299  * pin. If the pivot point is instead placed in the center of the rectangle
  300  * (at point x=50, y=15) then the rectangle will instead appear to rotate about
  301  * its center.
  302  * &lt;p&gt;
  303  * Note that as with all transformations, the x, y, width, and height variables
  304  * of the rectangle (which remain relative to the local coordinate space) have
  305  * not changed, but rather the transformation alters the entire coordinate space
  306  * of the rectangle.
  307  * &lt;p&gt;
  308  * A &lt;b&gt;scaling&lt;/b&gt; transformation causes a node to either appear larger or
  309  * smaller depending on the scaling factor. Scaling alters the coordinate space
  310  * of the node such that each unit of distance along the axis in local
  311  * coordinates is multiplied by the scale factor. As with rotation
  312  * transformations, scaling transformations are applied about a &quot;pivot&quot; point.
<span class="line-modified">  313  * You can think of this as the point in the {@code Node} around which you &quot;zoom&quot;.  For</span>
  314  * example, if you create a {@link javafx.scene.shape.Rectangle} with a
  315  * {@code strokeWidth} of 5, and a width and height of 50, and you apply a
  316  * {@link javafx.scene.transform.Scale} with scale factors (x=2.0, y=2.0) and
  317  * a pivot at the origin (pivotX=0, pivotY=0), the entire rectangle
  318  * (including the stroke) will double in size, growing to the right and
  319  * downwards from the origin.
  320  * &lt;p&gt;
  321  * A &lt;b&gt;shearing&lt;/b&gt; transformation, sometimes called a skew, effectively
  322  * rotates one axis so that the x and y axes are no longer perpendicular.
  323  * &lt;p&gt;
  324  * Multiple transformations may be applied to a node by specifying an ordered
  325  * chain of transforms.  The order in which the transforms are applied is
  326  * defined by the ObservableList specified in the {@link #getTransforms transforms} variable.
  327  *
  328  * &lt;h2&gt;Bounding Rectangles&lt;/h2&gt;
  329  * &lt;p&gt;
  330  * Since every {@code Node} has transformations, every Node&#39;s geometric
  331  * bounding rectangle can be described differently depending on whether
  332  * transformations are accounted for or not.
  333  * &lt;p&gt;
</pre>
<hr />
<pre>
  845 
  846         if (isDirty(DirtyBits.NODE_BLENDMODE)) {
  847             BlendMode mode = getBlendMode();
  848             peer.setNodeBlendMode((mode == null)
  849                                   ? null
  850                                   : EffectHelper.getToolkitBlendMode(mode));
  851         }
  852     }
  853 
  854     /*************************************************************************
  855     *                                                                        *
  856     *                                                                        *
  857     *                                                                        *
  858     *************************************************************************/
  859 
  860     private static final Object USER_DATA_KEY = new Object();
  861     // A map containing a set of properties for this node
  862     private ObservableMap&lt;Object, Object&gt; properties;
  863 
  864     /**
<span class="line-modified">  865      * Returns an observable map of properties on this node for use primarily by application developers.</span>
<span class="line-modified">  866      *</span>
<span class="line-modified">  867      * @return an observable map of properties on this node for use primarily by application developers</span>
<span class="line-modified">  868      * @apiNote Layout managers use this map as well to specify layout constraints on the node, such as {@code HBox#setHgrow}, so the</span>
<span class="line-modified">  869      *          developer should be mindful of clearing the map or overriding its values. These entries are not removed automatically</span>
<span class="line-modified">  870      *          if the node is removed from the layout manager, so unused entries can exist throughout the life of the node.</span>
<span class="line-added">  871      */</span>
  872      public final ObservableMap&lt;Object, Object&gt; getProperties() {
  873         if (properties == null) {
  874             properties = FXCollections.observableMap(new HashMap&lt;Object, Object&gt;());
  875         }
  876         return properties;
  877     }
  878 
  879     /**
  880      * Tests if Node has properties.
  881      * @return true if node has properties.
  882      */
  883      public boolean hasProperties() {
  884         return properties != null &amp;&amp; !properties.isEmpty();
  885     }
  886 
  887     /**
  888      * Convenience method for setting a single Object property that can be
  889      * retrieved at a later date. This is functionally equivalent to calling
  890      * the getProperties().put(Object key, Object value) method. This can later
  891      * be retrieved by calling {@link Node#getUserData()}.
</pre>
</td>
</tr>
</table>
<center><a href="../animation/Timeline.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>