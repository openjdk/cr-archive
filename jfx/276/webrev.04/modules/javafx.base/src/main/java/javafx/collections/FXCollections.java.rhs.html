<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.base/src/main/java/javafx/collections/FXCollections.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.collections;
  27 
  28 import com.sun.javafx.collections.ListListenerHelper;
  29 import com.sun.javafx.collections.MapListenerHelper;
  30 import com.sun.javafx.collections.SetListenerHelper;
  31 import java.lang.reflect.Array;
  32 import java.util.AbstractList;
  33 import java.util.AbstractMap;
  34 import java.util.AbstractSet;
  35 import java.util.ArrayList;
  36 import java.util.Arrays;
  37 import java.util.Collection;
  38 import java.util.Collections;
  39 import java.util.Comparator;
  40 import java.util.HashMap;
  41 import java.util.HashSet;
  42 import java.util.Iterator;
  43 import java.util.List;
  44 import java.util.ListIterator;
  45 import java.util.Map;
  46 import java.util.NoSuchElementException;
  47 import java.util.Random;
  48 import java.util.Set;
  49 
  50 import javafx.beans.InvalidationListener;
  51 
  52 import com.sun.javafx.collections.ObservableListWrapper;
  53 import com.sun.javafx.collections.ObservableMapWrapper;
  54 import com.sun.javafx.collections.ObservableSetWrapper;
  55 import com.sun.javafx.collections.MapAdapterChange;
  56 import com.sun.javafx.collections.ObservableFloatArrayImpl;
  57 import com.sun.javafx.collections.ObservableIntegerArrayImpl;
  58 import com.sun.javafx.collections.ObservableSequentialListWrapper;
  59 import com.sun.javafx.collections.SetAdapterChange;
  60 import com.sun.javafx.collections.SortableList;
  61 import com.sun.javafx.collections.SourceAdapterChange;
  62 import java.util.RandomAccess;
  63 import javafx.beans.Observable;
  64 import javafx.collections.ListChangeListener.Change;
  65 import javafx.util.Callback;
  66 
  67 /**
  68  * Utility class that consists of static methods that are 1:1 copies of java.util.Collections methods.
  69  * &lt;br&gt;&lt;br&gt;
  70  * The wrapper methods (like synchronizedObservableList or emptyObservableList) has exactly the same
  71  * functionality as the methods in Collections, with exception that they return ObservableList and are
  72  * therefore suitable for methods that require ObservableList on input.
  73  * &lt;br&gt;&lt;br&gt;
  74  * The utility methods are here mainly for performance reasons. All methods are optimized in a way that
  75  * they yield only limited number of notifications. On the other hand, java.util.Collections methods
  76  * might call &quot;modification methods&quot; on an ObservableList multiple times, resulting in a number of notifications.
  77  *
  78  * @since JavaFX 2.0
  79  */
  80 public class FXCollections {
  81     /** Not to be instantiated. */
  82     private FXCollections() { }
  83 
  84     /**
  85      * Constructs an ObservableList that is backed by the specified list.
  86      * Mutation operations on the ObservableList instance will be reported
  87      * to observers that have registered on that instance.&lt;br&gt;
  88      * Note that mutation operations made directly to the underlying list are
  89      * &lt;em&gt;not&lt;/em&gt; reported to observers of any ObservableList that
  90      * wraps it.
  91      *
  92      * @param &lt;E&gt; The type of List to be wrapped
  93      * @param list a concrete List that backs this ObservableList
  94      * @return a newly created ObservableList
  95      */
  96     public static &lt;E&gt; ObservableList&lt;E&gt; observableList(List&lt;E&gt; list) {
  97         if (list == null) {
  98             throw new NullPointerException();
  99         }
 100         return list instanceof RandomAccess ? new ObservableListWrapper&lt;E&gt;(list) :
 101                 new ObservableSequentialListWrapper&lt;E&gt;(list);
 102     }
 103 
 104     /**
<a name="1" id="anc1"></a><span class="line-modified"> 105      * Constructs an {@code ObservableList} that is backed by the specified list and listens to changes in observables of its items.</span>
<span class="line-modified"> 106      * Mutation operations made directly to the underlying list are</span>
<span class="line-modified"> 107      * &lt;em&gt;not&lt;/em&gt; reported to observers of any {@code ObservableList} that</span>


 108      * wraps it.
<a name="2" id="anc2"></a><span class="line-modified"> 109      * &lt;p&gt;</span>
<span class="line-modified"> 110      * The {@code extractor} returns observables (usually properties) of the objects in the created list. These observables are</span>
<span class="line-modified"> 111      * listened for changes, and the user is notified of these through an</span>
<span class="line-modified"> 112      * {@linkplain ListChangeListener.Change#wasUpdated() update} change of an attached {@code ListChangeListener}. These changes</span>
<span class="line-added"> 113      * are unrelated to the changes made to the observable list itself using methods such as {@code add} and {@code remove}.</span>
<span class="line-added"> 114      * &lt;p&gt;</span>
<span class="line-added"> 115      * For example, a list of {@code Shape}s can listen to changes in the shapes&#39; {@code fill} property.</span>
 116      *
<a name="3" id="anc3"></a><span class="line-modified"> 117      * @param &lt;E&gt; The type of {@code List} to be wrapped</span>
<span class="line-modified"> 118      * @param list a concrete {@code List} that backs this {@code ObservableList}</span>
<span class="line-modified"> 119      * @param extractor element to {@code Observable[]} converter</span>
<span class="line-added"> 120      * @return a newly created {@code ObservableList}</span>
<span class="line-added"> 121      * @see #observableArrayList(javafx.util.Callback)</span>
 122      * @since JavaFX 2.1
<a name="4" id="anc4"></a>
 123      */
 124     public static &lt;E&gt; ObservableList&lt;E&gt; observableList(List&lt;E&gt; list, Callback&lt;E, Observable[]&gt; extractor) {
 125         if (list == null || extractor == null) {
 126             throw new NullPointerException();
 127         }
 128         return list instanceof RandomAccess ? new ObservableListWrapper&lt;E&gt;(list, extractor) :
 129             new ObservableSequentialListWrapper&lt;E&gt;(list, extractor);
 130     }
 131 
 132     /**
 133      * Constructs an ObservableMap that is backed by the specified map.
 134      * Mutation operations on the ObservableMap instance will be reported
 135      * to observers that have registered on that instance.&lt;br&gt;
 136      * Note that mutation operations made directly to the underlying map are &lt;em&gt;not&lt;/em&gt;
 137      * reported to observers of any ObservableMap that wraps it.
 138      * @param &lt;K&gt; the type of the wrapped key
 139      * @param &lt;V&gt; the type of the wrapped value
 140      * @param map a Map that backs this ObservableMap
 141      * @return a newly created ObservableMap
 142      */
 143     public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; observableMap(Map&lt;K, V&gt; map) {
 144         if (map == null) {
 145             throw new NullPointerException();
 146         }
 147         return new ObservableMapWrapper&lt;K, V&gt;(map);
 148     }
 149 
 150     /**
 151      * Constructs an ObservableSet that is backed by the specified set.
 152      * Mutation operations on the ObservableSet instance will be reported
 153      * to observers that have registered on that instance.&lt;br&gt;
 154      * Note that mutation operations made directly to the underlying set are &lt;em&gt;not&lt;/em&gt;
 155      * reported to observers of any ObservableSet that wraps it.
 156      * @param &lt;E&gt; The type of List to be wrapped
 157      * @param set a Set that backs this ObservableSet
 158      * @return a newly created ObservableSet
 159      * @since JavaFX 2.1
 160      */
 161     public static &lt;E&gt; ObservableSet&lt;E&gt; observableSet(Set&lt;E&gt; set) {
 162         if (set == null) {
 163             throw new NullPointerException();
 164         }
 165         return new ObservableSetWrapper&lt;E&gt;(set);
 166     }
 167 
 168     /**
 169      * Constructs an ObservableSet backed by a HashSet
 170      * that contains all the specified elements.
 171      * @param &lt;E&gt; The type of List to be wrapped
 172      * @param elements elements that will be added into returned ObservableSet
 173      * @return a newly created ObservableSet
 174      * @since JavaFX 2.1
 175      */
 176     public static &lt;E&gt; ObservableSet&lt;E&gt; observableSet(E... elements) {
 177         if (elements == null) {
 178             throw new NullPointerException();
 179         }
 180         Set&lt;E&gt; set = new HashSet&lt;E&gt;(elements.length);
 181         Collections.addAll(set, elements);
 182         return new ObservableSetWrapper&lt;E&gt;(set);
 183     }
 184 
 185     /**
 186      * Constructs a read-only interface to the specified ObservableMap. Only
 187      * mutation operations made to the underlying ObservableMap will be reported
 188      * to observers that have registered on the unmodifiable instance. This allows
 189      * clients to track changes in a Map but disallows the ability to modify it.
 190      * @param &lt;K&gt; the type of the wrapped key
 191      * @param &lt;V&gt; the type of the wrapped value
 192      * @param map an ObservableMap that is to be monitored by this interface
 193      * @return a newly created UnmodifiableObservableMap
 194      */
 195     public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; unmodifiableObservableMap(ObservableMap&lt;K, V&gt; map) {
 196         if (map == null) {
 197             throw new NullPointerException();
 198         }
 199         return new com.sun.javafx.collections.UnmodifiableObservableMap&lt;K, V&gt;(map);
 200     }
 201 
 202     /**
 203      * Creates and returns a typesafe wrapper on top of provided observable map.
 204      * @param &lt;K&gt; the type of the wrapped key
 205      * @param &lt;V&gt; the type of the wrapped value
 206      * @param map an Observable map to be wrapped
 207      * @param keyType the type of key that {@code map} is permitted to hold
 208      * @param valueType the type of value that {@code map} is permitted to hold
 209      * @return a dynamically typesafe view of the specified map
 210      * @see Collections#checkedMap(java.util.Map, java.lang.Class, java.lang.Class)
 211      * @since JavaFX 8.0
 212      */
 213     public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; checkedObservableMap(ObservableMap&lt;K, V&gt; map, Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) {
 214         if (map == null || keyType == null || valueType == null) {
 215             throw new NullPointerException();
 216         }
 217         return new CheckedObservableMap&lt;K, V&gt;(map, keyType, valueType);
 218     }
 219 
 220     /**
 221      * Creates and returns a synchronized wrapper on top of provided observable map.
 222      * @param &lt;K&gt; the type of the wrapped key
 223      * @param &lt;V&gt; the type of the wrapped value
 224      * @param  map the map to be &quot;wrapped&quot; in a synchronized map.
 225      * @return A synchronized version of the observable map
 226      * @see Collections#synchronizedMap(java.util.Map)
 227      * @since JavaFX 8.0
 228      */
 229     public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; synchronizedObservableMap(ObservableMap&lt;K, V&gt; map) {
 230         if (map == null) {
 231             throw new NullPointerException();
 232         }
 233         return new SynchronizedObservableMap&lt;K, V&gt;(map);
 234     }
 235 
 236     private static ObservableMap EMPTY_OBSERVABLE_MAP = new EmptyObservableMap();
 237 
 238     /**
 239      * Creates an empty unmodifiable observable map.
 240      * @param &lt;K&gt; the type of the wrapped key
 241      * @param &lt;V&gt; the type of the wrapped value
 242      * @return An empty unmodifiable observable map
 243      * @see Collections#emptyMap()
 244      * @since JavaFX 8.0
 245      */
 246     @SuppressWarnings(&quot;unchecked&quot;)
 247     public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; emptyObservableMap() {
 248         return EMPTY_OBSERVABLE_MAP;
 249     }
 250 
 251     /**
 252      * Creates a new empty observable integer array.
 253      * @return a newly created ObservableIntegerArray
 254      * @since JavaFX 8.0
 255      */
 256     public static ObservableIntegerArray observableIntegerArray() {
 257         return new ObservableIntegerArrayImpl();
 258     }
 259 
 260     /**
 261      * Creates a new observable integer array with {@code values} set to it.
 262      * @param values the values that will be in the new observable integer array
 263      * @return a newly created ObservableIntegerArray
 264      * @since JavaFX 8.0
 265      */
 266     public static ObservableIntegerArray observableIntegerArray(int... values) {
 267         return new ObservableIntegerArrayImpl(values);
 268     }
 269 
 270     /**
 271      * Creates a new observable integer array with copy of elements in given
 272      * {@code array}.
 273      * @param array observable integer array to copy
 274      * @return a newly created ObservableIntegerArray
 275      * @since JavaFX 8.0
 276      */
 277     public static ObservableIntegerArray observableIntegerArray(ObservableIntegerArray array) {
 278         return new ObservableIntegerArrayImpl(array);
 279     }
 280 
 281     /**
 282      * Creates a new empty observable float array.
 283      * @return a newly created ObservableFloatArray
 284      * @since JavaFX 8.0
 285      */
 286     public static ObservableFloatArray observableFloatArray() {
 287         return new ObservableFloatArrayImpl();
 288     }
 289 
 290     /**
 291      * Creates a new observable float array with {@code values} set to it.
 292      * @param values the values that will be in the new observable float array
 293      * @return a newly created ObservableFloatArray
 294      * @since JavaFX 8.0
 295      */
 296     public static ObservableFloatArray observableFloatArray(float... values) {
 297         return new ObservableFloatArrayImpl(values);
 298     }
 299 
 300     /**
 301      * Creates a new observable float array with copy of elements in given
 302      * {@code array}.
 303      * @param array observable float array to copy
 304      * @return a newly created ObservableFloatArray
 305      * @since JavaFX 8.0
 306      */
 307     public static ObservableFloatArray observableFloatArray(ObservableFloatArray array) {
 308         return new ObservableFloatArrayImpl(array);
 309     }
 310 
 311     /**
<a name="5" id="anc5"></a><span class="line-modified"> 312      * Creates a new empty observable list that is backed by an array list.</span>
 313      * @see #observableList(java.util.List)
 314      * @param &lt;E&gt; The type of List to be wrapped
 315      * @return a newly created ObservableList
 316      */
 317     @SuppressWarnings(&quot;unchecked&quot;)
 318     public static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList() {
 319         return observableList(new ArrayList());
 320     }
 321 
 322     /**
<a name="6" id="anc6"></a><span class="line-modified"> 323      * Creates a new empty {@code ObservableList} that is backed by an array list and listens to changes in observables of its items.</span>
<span class="line-added"> 324      * &lt;p&gt;</span>
<span class="line-added"> 325      * The {@code extractor} returns observables (usually properties) of the objects in the created list. These observables are</span>
<span class="line-added"> 326      * listened for changes and the user is notified of these through an</span>
<span class="line-added"> 327      * {@linkplain ListChangeListener.Change#wasUpdated() update} change of an attached {@code ListChangeListener}. These changes</span>
<span class="line-added"> 328      * are unrelated to the changes made to the observable list itself using methods such as {@code add} and {@code remove}.</span>
<span class="line-added"> 329      * &lt;p&gt;</span>
<span class="line-added"> 330      * For example, a list of {@code Shape}s can listen to changes in the shapes&#39; {@code fill} property.</span>
 331      *
<a name="7" id="anc7"></a><span class="line-modified"> 332      * @param &lt;E&gt; The type of {@code List} to be wrapped</span>
<span class="line-modified"> 333      * @param extractor element to {@code Observable[]} converter</span>
<span class="line-modified"> 334      * @return a newly created {@code ObservableList}</span>
 335      * @see #observableList(java.util.List, javafx.util.Callback)
 336      * @since JavaFX 2.1
<a name="8" id="anc8"></a>
 337      */
 338     public static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList(Callback&lt;E, Observable[]&gt; extractor) {
 339         return observableList(new ArrayList(), extractor);
 340     }
 341 
 342     /**
 343      * Creates a new observable array list with {@code items} added to it.
 344      * @param &lt;E&gt; The type of List to be wrapped
 345      * @param items the items that will be in the new observable ArrayList
 346      * @return a newly created observableArrayList
 347      * @see #observableArrayList()
 348      */
 349     public static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList(E... items) {
 350         ObservableList&lt;E&gt; list = observableArrayList();
 351         list.addAll(items);
 352         return list;
 353     }
 354 
 355     /**
 356      * Creates a new observable array list and adds a content of collection {@code col}
 357      * to it.
 358      * @param &lt;E&gt; The type of List to be wrapped
 359      * @param col a collection which content should be added to the observableArrayList
 360      * @return a newly created observableArrayList
 361      */
 362     public static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList(Collection&lt;? extends E&gt; col) {
 363         ObservableList&lt;E&gt; list = observableArrayList();
 364         list.addAll(col);
 365         return list;
 366     }
 367 
 368     /**
 369      * Creates a new empty observable map that is backed by a HashMap.
 370      * @param &lt;K&gt; the type of the wrapped key
 371      * @param &lt;V&gt; the type of the wrapped value
 372      * @return a newly created observable HashMap
 373      */
 374     public static &lt;K,V&gt; ObservableMap&lt;K,V&gt; observableHashMap() {
 375         return observableMap(new HashMap&lt;K, V&gt;());
 376     }
 377 
 378     /**
 379      * Concatenates more observable lists into one. The resulting list
<a name="9" id="anc9"></a><span class="line-modified"> 380      * would be backed by an array list.</span>
 381      * @param &lt;E&gt; The type of List to be wrapped
 382      * @param lists lists to concatenate
 383      * @return new observable array list concatenated from the arguments
 384      */
 385     public static &lt;E&gt; ObservableList&lt;E&gt; concat(ObservableList&lt;E&gt;... lists) {
 386         if (lists.length == 0 ) {
 387             return observableArrayList();
 388         }
 389         if (lists.length == 1) {
 390             return observableArrayList(lists[0]);
 391         }
 392         ArrayList&lt;E&gt; backingList = new ArrayList&lt;E&gt;();
 393         for (ObservableList&lt;E&gt; s : lists) {
 394             backingList.addAll(s);
 395         }
 396 
 397         return observableList(backingList);
 398     }
 399 
 400     /**
 401      * Creates and returns unmodifiable wrapper list on top of provided observable list.
 402      * @param list  an ObservableList that is to be wrapped
 403      * @param &lt;E&gt; The type of List to be wrapped
 404      * @return an ObserableList wrapper that is unmodifiable
 405      * @see Collections#unmodifiableList(java.util.List)
 406      */
 407     public static&lt;E&gt; ObservableList&lt;E&gt; unmodifiableObservableList(ObservableList&lt;E&gt; list) {
 408         if (list == null) {
 409             throw new NullPointerException();
 410         }
 411         return new UnmodifiableObservableListImpl&lt;E&gt;(list);
 412     }
 413 
 414     /**
 415      * Creates and returns a typesafe wrapper on top of provided observable list.
 416      * @param &lt;E&gt; The type of List to be wrapped
 417      * @param list  an Observable list to be wrapped
 418      * @param type   the type of element that {@code list} is permitted to hold
 419      * @return a dynamically typesafe view of the specified list
 420      * @see Collections#checkedList(java.util.List, java.lang.Class)
 421      */
 422     public static&lt;E&gt; ObservableList&lt;E&gt; checkedObservableList(ObservableList&lt;E&gt; list, Class&lt;E&gt; type) {
 423         if (list == null) {
 424             throw new NullPointerException();
 425         }
 426         return new CheckedObservableList&lt;E&gt;(list, type);
 427     }
 428 
 429     /**
 430      * Creates and returns a synchronized wrapper on top of provided observable list.
 431      * @param &lt;E&gt; The type of List to be wrapped
 432      * @param  list the list to be &quot;wrapped&quot; in a synchronized list.
 433      * @return A synchronized version of the observable list
 434      * @see Collections#synchronizedList(java.util.List)
 435      */
 436     public static&lt;E&gt; ObservableList&lt;E&gt; synchronizedObservableList(ObservableList&lt;E&gt; list) {
 437         if (list == null) {
 438             throw new NullPointerException();
 439         }
 440         return new SynchronizedObservableList&lt;E&gt;(list);
 441     }
 442 
 443     private static ObservableList EMPTY_OBSERVABLE_LIST = new EmptyObservableList();
 444 
 445 
 446     /**
 447      * Creates an empty unmodifiable observable list.
 448      * @param &lt;E&gt; The type of List to be wrapped
 449      * @return An empty unmodifiable observable list
 450      * @see Collections#emptyList()
 451      */
 452     @SuppressWarnings(&quot;unchecked&quot;)
 453     public static&lt;E&gt; ObservableList&lt;E&gt; emptyObservableList() {
 454         return EMPTY_OBSERVABLE_LIST;
 455     }
 456 
 457     /**
 458      * Creates an unmodifiable observable list with single element.
 459      * @param &lt;E&gt; The type of List to be wrapped
 460      * @param e the only elements that will be contained in this singleton observable list
 461      * @return a singleton observable list
 462      * @see Collections#singletonList(java.lang.Object)
 463      */
 464     public static&lt;E&gt; ObservableList&lt;E&gt; singletonObservableList(E e) {
 465         return new SingletonObservableList&lt;E&gt;(e);
 466     }
 467 
 468     /**
 469      * Creates and returns unmodifiable wrapper on top of provided observable set.
 470      * @param &lt;E&gt; The type of List to be wrapped
 471      * @param set an ObservableSet that is to be wrapped
 472      * @return an ObserableSet wrapper that is unmodifiable
 473      * @see Collections#unmodifiableSet(java.util.Set)
 474      * @since JavaFX 8.0
 475      */
 476     public static&lt;E&gt; ObservableSet&lt;E&gt; unmodifiableObservableSet(ObservableSet&lt;E&gt; set) {
 477         if (set == null) {
 478             throw new NullPointerException();
 479         }
 480         return new UnmodifiableObservableSet&lt;E&gt;(set);
 481     }
 482 
 483     /**
 484      * Creates and returns a typesafe wrapper on top of provided observable set.
 485      * @param &lt;E&gt; The type of List to be wrapped
 486      * @param set an Observable set to be wrapped
 487      * @param type  the type of element that {@code set} is permitted to hold
 488      * @return a dynamically typesafe view of the specified set
 489      * @see Collections#checkedSet(java.util.Set, java.lang.Class)
 490      * @since JavaFX 8.0
 491      */
 492     public static&lt;E&gt; ObservableSet&lt;E&gt; checkedObservableSet(ObservableSet&lt;E&gt; set, Class&lt;E&gt; type) {
 493         if (set == null) {
 494             throw new NullPointerException();
 495         }
 496         return new CheckedObservableSet&lt;E&gt;(set, type);
 497     }
 498 
 499     /**
 500      * Creates and returns a synchronized wrapper on top of provided observable set.
 501      * @param &lt;E&gt; The type of List to be wrapped
 502      * @param  set the set to be &quot;wrapped&quot; in a synchronized set.
 503      * @return A synchronized version of the observable set
 504      * @see Collections#synchronizedSet(java.util.Set)
 505      * @since JavaFX 8.0
 506      */
 507     public static&lt;E&gt; ObservableSet&lt;E&gt; synchronizedObservableSet(ObservableSet&lt;E&gt; set) {
 508         if (set == null) {
 509             throw new NullPointerException();
 510         }
 511         return new SynchronizedObservableSet&lt;E&gt;(set);
 512     }
 513 
 514     private static ObservableSet EMPTY_OBSERVABLE_SET = new EmptyObservableSet();
 515 
 516     /**
 517      * Creates an empty unmodifiable observable set.
 518      * @param &lt;E&gt; The type of List to be wrapped
 519      * @return An empty unmodifiable observable set
 520      * @see Collections#emptySet()
 521      * @since JavaFX 8.0
 522      */
 523     @SuppressWarnings(&quot;unchecked&quot;)
 524     public static&lt;E&gt; ObservableSet&lt;E&gt; emptyObservableSet() {
 525         return EMPTY_OBSERVABLE_SET;
 526     }
 527 
 528     /**
 529      * Copies elements from src to dest. Fires only &lt;b&gt;one&lt;/b&gt; change notification on dest.
 530      * @param &lt;T&gt; The type of List to be wrapped
 531      * @param dest the destination observable list
 532      * @param src the source list
 533      * @see Collections#copy(java.util.List, java.util.List)
 534      */
 535     @SuppressWarnings(&quot;unchecked&quot;)
 536     public static &lt;T&gt; void copy(ObservableList&lt;? super T&gt; dest, List&lt;? extends T&gt; src) {
 537         final int srcSize = src.size();
 538         if (srcSize &gt; dest.size()) {
 539             throw new IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;);
 540         }
 541         T[] destArray = (T[]) dest.toArray();
 542         System.arraycopy(src.toArray(), 0, destArray, 0, srcSize);
 543         dest.setAll(destArray);
 544     }
 545 
 546     /**
 547      * Fills the provided list with obj. Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 548      * @param &lt;T&gt; The type of List to be wrapped
 549      * @param list the list to fill
 550      * @param obj the object to fill the list with
 551      * @see Collections#fill(java.util.List, java.lang.Object)
 552      */
 553     @SuppressWarnings(&quot;unchecked&quot;)
 554     public static &lt;T&gt; void fill(ObservableList&lt;? super T&gt; list, T obj) {
 555         T[] newContent = (T[]) new Object[list.size()];
 556         Arrays.fill(newContent, obj);
 557         list.setAll(newContent);
 558     }
 559 
 560     /**
 561      * Replace all oldVal elements in the list with newVal element.
 562      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 563      * @param &lt;T&gt; The type of List to be wrapped
 564      * @param list the list which will have it&#39;s elements replaced
 565      * @param oldVal the element that is going to be replace
 566      * @param newVal the replacement
 567      * @return true if the list was modified
 568      * @see Collections#replaceAll(java.util.List, java.lang.Object, java.lang.Object)
 569      */
 570     @SuppressWarnings(&quot;unchecked&quot;)
 571     public static &lt;T&gt; boolean replaceAll(ObservableList&lt;T&gt; list, T oldVal, T newVal) {
 572         T[] newContent = (T[]) list.toArray();
 573         boolean modified = false;
 574         for (int i = 0 ; i &lt; newContent.length; ++i) {
 575             if (newContent[i].equals(oldVal)) {
 576                 newContent[i] = newVal;
 577                 modified = true;
 578             }
 579         }
 580         if (modified) {
 581             list.setAll(newContent);
 582         }
 583         return modified;
 584     }
 585 
 586     /**
 587      * Reverses the order in the list.
 588      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 589      * @param list the list to be reversed
 590      * @see Collections#reverse(java.util.List)
 591      */
 592     @SuppressWarnings(&quot;unchecked&quot;)
 593     public static void reverse(ObservableList list) {
 594         Object[] newContent = list.toArray();
 595         for (int i = 0; i &lt; newContent.length / 2; ++i) {
 596             Object tmp = newContent[i];
 597             newContent[i] = newContent[newContent.length - i - 1];
 598             newContent[newContent.length -i - 1] = tmp;
 599         }
 600         list.setAll(newContent);
 601     }
 602 
 603     /**
 604      * Rotates the list by distance.
 605      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 606      * @param list the list to be rotated
 607      * @param distance the distance of rotation
 608      * @see Collections#rotate(java.util.List, int)
 609      */
 610     @SuppressWarnings(&quot;unchecked&quot;)
 611     public static void rotate(ObservableList list, int distance) {
 612         Object[] newContent = list.toArray();
 613 
 614         int size = list.size();
 615         distance = distance % size;
 616         if (distance &lt; 0)
 617             distance += size;
 618         if (distance == 0)
 619             return;
 620 
 621         for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) {
 622             Object displaced = newContent[cycleStart];
 623             Object tmp;
 624             int i = cycleStart;
 625             do {
 626                 i += distance;
 627                 if (i &gt;= size)
 628                     i -= size;
 629                 tmp = newContent[i];
 630                 newContent[i] = displaced;
 631                 displaced = tmp;
 632                 nMoved ++;
 633             } while(i != cycleStart);
 634         }
 635         list.setAll(newContent);
 636     }
 637 
 638     /**
 639      * Shuffles all elements in the observable list.
 640      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 641      * @param list the list to shuffle
 642      * @see Collections#shuffle(java.util.List)
 643      */
 644     public static void shuffle(ObservableList&lt;?&gt; list) {
 645         if (r == null) {
 646             r = new Random();
 647         }
 648         shuffle(list, r);
 649     }
 650     private static Random r;
 651 
 652     /**
 653      * Shuffles all elements in the observable list.
 654      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 655      * @param list the list to be shuffled
 656      * @param rnd the random generator used for shuffling
 657      * @see Collections#shuffle(java.util.List, java.util.Random)
 658      */
 659     @SuppressWarnings(&quot;unchecked&quot;)
 660     public static void shuffle(ObservableList list, Random rnd) {
 661         Object newContent[] = list.toArray();
 662 
 663         for (int i = list.size(); i &gt; 1; i--) {
 664             swap(newContent, i - 1, rnd.nextInt(i));
 665         }
 666 
 667         list.setAll(newContent);
 668     }
 669 
 670     private static void swap(Object[] arr, int i, int j) {
 671         Object tmp = arr[i];
 672         arr[i] = arr[j];
 673         arr[j] = tmp;
 674     }
 675 
 676     /**
 677      * Sorts the provided observable list.
 678      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 679      * @param &lt;T&gt; The type of List to be wrapped
 680      * @param list the list to be sorted
 681      * @see Collections#sort(java.util.List)
 682      */
 683     @SuppressWarnings(&quot;unchecked&quot;)
 684     public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(ObservableList&lt;T&gt; list) {
 685         if (list instanceof SortableList) {
 686             ((SortableList&lt;? extends T&gt;)list).sort();
 687         } else {
 688             List&lt;T&gt; newContent = new ArrayList&lt;T&gt;(list);
 689             Collections.sort(newContent);
 690             list.setAll((Collection&lt;T&gt;)newContent);
 691         }
 692     }
 693 
 694     /**
 695      * Sorts the provided observable list using the c comparator.
 696      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 697      * @param &lt;T&gt; The type of List to be wrapped
 698      * @param list the list to sort
 699      * @param c comparator used for sorting. Null if natural ordering is required.
 700      * @see Collections#sort(java.util.List, java.util.Comparator)
 701      */
 702     @SuppressWarnings(&quot;unchecked&quot;)
 703     public static &lt;T&gt; void sort(ObservableList&lt;T&gt; list, Comparator&lt;? super T&gt; c) {
 704         if (list instanceof SortableList) {
 705             ((SortableList&lt;? extends T&gt;)list).sort(c);
 706         } else {
 707             List&lt;T&gt; newContent = new ArrayList&lt;T&gt;(list);
 708             Collections.sort(newContent, c);
 709             list.setAll((Collection&lt;T&gt;)newContent);
 710         }
 711     }
 712 
 713     private static class EmptyObservableList&lt;E&gt; extends AbstractList&lt;E&gt; implements ObservableList&lt;E&gt; {
 714 
 715         private static final ListIterator iterator = new ListIterator() {
 716 
 717             @Override
 718             public boolean hasNext() {
 719                 return false;
 720             }
 721 
 722             @Override
 723             public Object next() {
 724                 throw new NoSuchElementException();
 725             }
 726 
 727             @Override
 728             public void remove() {
 729                 throw new UnsupportedOperationException();
 730             }
 731 
 732             @Override
 733             public boolean hasPrevious() {
 734                 return false;
 735             }
 736 
 737             @Override
 738             public Object previous() {
 739                 throw new NoSuchElementException();
 740             }
 741 
 742             @Override
 743             public int nextIndex() {
 744                 return 0;
 745             }
 746 
 747             @Override
 748             public int previousIndex() {
 749                 return -1;
 750             }
 751 
 752             @Override
 753             public void set(Object e) {
 754                 throw new UnsupportedOperationException();
 755             }
 756 
 757             @Override
 758             public void add(Object e) {
 759                 throw new UnsupportedOperationException();
 760             }
 761         };
 762 
 763         public EmptyObservableList() {
 764         }
 765 
 766         @Override
 767         public final void addListener(InvalidationListener listener) {
 768         }
 769 
 770         @Override
 771         public final void removeListener(InvalidationListener listener) {
 772         }
 773 
 774 
 775         @Override
 776         public void addListener(ListChangeListener&lt;? super E&gt; o) {
 777         }
 778 
 779         @Override
 780         public void removeListener(ListChangeListener&lt;? super E&gt; o) {
 781         }
 782 
 783         @Override
 784         public int size() {
 785             return 0;
 786         }
 787 
 788         @Override
 789         public boolean contains(Object o) {
 790             return false;
 791         }
 792 
 793         @Override
 794         @SuppressWarnings(&quot;unchecked&quot;)
 795         public Iterator&lt;E&gt; iterator() {
 796             return iterator;
 797         }
 798 
 799         @Override
 800         public boolean containsAll(Collection&lt;?&gt; c) {
 801             return c.isEmpty();
 802         }
 803 
 804         @Override
 805         public E get(int index) {
 806             throw new IndexOutOfBoundsException();
 807         }
 808 
 809         @Override
 810         public int indexOf(Object o) {
 811             return -1;
 812         }
 813 
 814         @Override
 815         public int lastIndexOf(Object o) {
 816             return -1;
 817         }
 818 
 819         @Override
 820         @SuppressWarnings(&quot;unchecked&quot;)
 821         public ListIterator&lt;E&gt; listIterator() {
 822             return iterator;
 823         }
 824 
 825         @Override
 826         @SuppressWarnings(&quot;unchecked&quot;)
 827         public ListIterator&lt;E&gt; listIterator(int index) {
 828             if (index != 0) {
 829                 throw new IndexOutOfBoundsException();
 830             }
 831             return iterator;
 832         }
 833 
 834         @Override
 835         public List&lt;E&gt; subList(int fromIndex, int toIndex) {
 836             if (fromIndex != 0 || toIndex != 0) {
 837                 throw new IndexOutOfBoundsException();
 838             }
 839             return this;
 840         }
 841 
 842         @Override
 843         public boolean addAll(E... elements) {
 844             throw new UnsupportedOperationException();
 845         }
 846 
 847         @Override
 848         public boolean setAll(E... elements) {
 849             throw new UnsupportedOperationException();
 850         }
 851 
 852         @Override
 853         public boolean setAll(Collection&lt;? extends E&gt; col) {
 854             throw new UnsupportedOperationException();
 855         }
 856 
 857         @Override
 858         public boolean removeAll(E... elements) {
 859             throw new UnsupportedOperationException();
 860         }
 861 
 862         @Override
 863         public boolean retainAll(E... elements) {
 864             throw new UnsupportedOperationException();
 865         }
 866 
 867         @Override
 868         public void remove(int from, int to) {
 869             throw new UnsupportedOperationException();
 870         }
 871     }
 872 
 873     private static class SingletonObservableList&lt;E&gt; extends AbstractList&lt;E&gt; implements ObservableList&lt;E&gt; {
 874 
 875         private final E element;
 876 
 877         public SingletonObservableList(E element) {
 878             if (element == null) {
 879                 throw new NullPointerException();
 880             }
 881             this.element = element;
 882         }
 883 
 884         @Override
 885         public boolean addAll(E... elements) {
 886             throw new UnsupportedOperationException();
 887         }
 888 
 889         @Override
 890         public boolean setAll(E... elements) {
 891             throw new UnsupportedOperationException();
 892         }
 893 
 894         @Override
 895         public boolean setAll(Collection&lt;? extends E&gt; col) {
 896             throw new UnsupportedOperationException();
 897         }
 898 
 899         @Override
 900         public boolean removeAll(E... elements) {
 901             throw new UnsupportedOperationException();
 902         }
 903 
 904         @Override
 905         public boolean retainAll(E... elements) {
 906             throw new UnsupportedOperationException();
 907         }
 908 
 909         @Override
 910         public void remove(int from, int to) {
 911             throw new UnsupportedOperationException();
 912         }
 913 
 914         @Override
 915         public void addListener(InvalidationListener listener) {
 916         }
 917 
 918         @Override
 919         public void removeListener(InvalidationListener listener) {
 920         }
 921 
 922         @Override
 923         public void addListener(ListChangeListener&lt;? super E&gt; o) {
 924         }
 925 
 926         @Override
 927         public void removeListener(ListChangeListener&lt;? super E&gt; o) {
 928         }
 929 
 930         @Override
 931         public int size() {
 932             return 1;
 933         }
 934 
 935         @Override
 936         public boolean isEmpty() {
 937             return false;
 938         }
 939 
 940         @Override
 941         public boolean contains(Object o) {
 942             return element.equals(o);
 943         }
 944 
 945         @Override
 946         public E get(int index) {
 947             if (index != 0) {
 948                 throw new IndexOutOfBoundsException();
 949             }
 950             return element;
 951         }
 952 
 953     }
 954 
 955     private static class UnmodifiableObservableListImpl&lt;T&gt; extends ObservableListBase&lt;T&gt; implements ObservableList&lt;T&gt; {
 956 
 957         private final ObservableList&lt;T&gt; backingList;
 958         private final ListChangeListener&lt;T&gt; listener;
 959 
 960         public UnmodifiableObservableListImpl(ObservableList&lt;T&gt; backingList) {
 961             this.backingList = backingList;
 962             listener = c -&gt; {
 963                 fireChange(new SourceAdapterChange&lt;T&gt;(UnmodifiableObservableListImpl.this, c));
 964             };
 965             this.backingList.addListener(new WeakListChangeListener&lt;T&gt;(listener));
 966         }
 967 
 968         @Override
 969         public T get(int index) {
 970             return backingList.get(index);
 971         }
 972 
 973         @Override
 974         public int size() {
 975             return backingList.size();
 976         }
 977 
 978         @Override
 979         public boolean addAll(T... elements) {
 980             throw new UnsupportedOperationException();
 981         }
 982 
 983         @Override
 984         public boolean setAll(T... elements) {
 985             throw new UnsupportedOperationException();
 986         }
 987 
 988         @Override
 989         public boolean setAll(Collection&lt;? extends T&gt; col) {
 990             throw new UnsupportedOperationException();
 991         }
 992 
 993         @Override
 994         public boolean removeAll(T... elements) {
 995             throw new UnsupportedOperationException();
 996         }
 997 
 998         @Override
 999         public boolean retainAll(T... elements) {
1000             throw new UnsupportedOperationException();
1001         }
1002 
1003         @Override
1004         public void remove(int from, int to) {
1005             throw new UnsupportedOperationException();
1006         }
1007 
1008     }
1009 
1010     private static class SynchronizedList&lt;T&gt; implements List&lt;T&gt; {
1011         final Object mutex;
1012         private final List&lt;T&gt; backingList;
1013 
1014         SynchronizedList(List&lt;T&gt; list, Object mutex) {
1015             this.backingList = list;
1016             this.mutex = mutex;
1017         }
1018 
1019         SynchronizedList(List&lt;T&gt; list) {
1020             this.backingList = list;
1021             this.mutex = this;
1022         }
1023 
1024         @Override
1025         public int size() {
1026             synchronized(mutex) {
1027                 return backingList.size();
1028             }
1029         }
1030 
1031         @Override
1032         public boolean isEmpty() {
1033             synchronized(mutex) {
1034                 return backingList.isEmpty();
1035             }
1036         }
1037 
1038         @Override
1039         public boolean contains(Object o) {
1040             synchronized(mutex) {
1041                 return backingList.contains(o);
1042             }
1043         }
1044 
1045         @Override
1046         public Iterator&lt;T&gt; iterator() {
1047             return backingList.iterator();
1048         }
1049 
1050         @Override
1051         public Object[] toArray() {
1052             synchronized(mutex)  {
1053                 return backingList.toArray();
1054             }
1055         }
1056 
1057         @Override
1058         public &lt;T&gt; T[] toArray(T[] a) {
1059             synchronized(mutex) {
1060                 return backingList.toArray(a);
1061             }
1062         }
1063 
1064         @Override
1065         public boolean add(T e) {
1066             synchronized(mutex) {
1067                 return backingList.add(e);
1068             }
1069         }
1070 
1071         @Override
1072         public boolean remove(Object o) {
1073             synchronized(mutex) {
1074                 return backingList.remove(o);
1075             }
1076         }
1077 
1078         @Override
1079         public boolean containsAll(Collection&lt;?&gt; c) {
1080             synchronized(mutex) {
1081                 return backingList.containsAll(c);
1082             }
1083         }
1084 
1085         @Override
1086         public boolean addAll(Collection&lt;? extends T&gt; c) {
1087             synchronized(mutex) {
1088                 return backingList.addAll(c);
1089             }
1090         }
1091 
1092         @Override
1093         public boolean addAll(int index, Collection&lt;? extends T&gt; c) {
1094             synchronized(mutex) {
1095                 return backingList.addAll(index, c);
1096 
1097             }
1098         }
1099 
1100         @Override
1101         public boolean removeAll(Collection&lt;?&gt; c) {
1102             synchronized(mutex) {
1103                 return backingList.removeAll(c);
1104             }
1105         }
1106 
1107         @Override
1108         public boolean retainAll(Collection&lt;?&gt; c) {
1109             synchronized(mutex) {
1110                 return backingList.retainAll(c);
1111             }
1112         }
1113 
1114         @Override
1115         public void clear() {
1116             synchronized(mutex) {
1117                 backingList.clear();
1118             }
1119         }
1120 
1121         @Override
1122         public T get(int index) {
1123             synchronized(mutex) {
1124                 return backingList.get(index);
1125             }
1126         }
1127 
1128         @Override
1129         public T set(int index, T element) {
1130             synchronized(mutex) {
1131                 return backingList.set(index, element);
1132             }
1133         }
1134 
1135         @Override
1136         public void add(int index, T element) {
1137             synchronized(mutex) {
1138                 backingList.add(index, element);
1139             }
1140         }
1141 
1142         @Override
1143         public T remove(int index) {
1144             synchronized(mutex) {
1145                 return backingList.remove(index);
1146             }
1147         }
1148 
1149         @Override
1150         public int indexOf(Object o) {
1151             synchronized(mutex) {
1152                 return backingList.indexOf(o);
1153             }
1154         }
1155 
1156         @Override
1157         public int lastIndexOf(Object o) {
1158             synchronized(mutex) {
1159                 return backingList.lastIndexOf(o);
1160             }
1161         }
1162 
1163         @Override
1164         public ListIterator&lt;T&gt; listIterator() {
1165             return backingList.listIterator();
1166         }
1167 
1168         @Override
1169         public ListIterator&lt;T&gt; listIterator(int index) {
1170             synchronized(mutex) {
1171                 return backingList.listIterator(index);
1172             }
1173         }
1174 
1175         @Override
1176         public List&lt;T&gt; subList(int fromIndex, int toIndex) {
1177             synchronized(mutex) {
1178                 return new SynchronizedList&lt;T&gt;(backingList.subList(fromIndex, toIndex),
1179                         mutex);
1180             }
1181         }
1182 
1183         @Override
1184         public String toString() {
1185             synchronized(mutex) {
1186                 return backingList.toString();
1187             }
1188         }
1189 
1190         @Override
1191         public int hashCode() {
1192             synchronized(mutex) {
1193                 return backingList.hashCode();
1194             }
1195         }
1196 
1197         @Override
1198         public boolean equals(Object o) {
1199             synchronized(mutex) {
1200                 return backingList.equals(o);
1201             }
1202         }
1203 
1204     }
1205 
1206     private static class SynchronizedObservableList&lt;T&gt; extends SynchronizedList&lt;T&gt; implements ObservableList&lt;T&gt; {
1207 
1208         private ListListenerHelper helper;
1209 
1210         private final ObservableList&lt;T&gt; backingList;
1211         private final ListChangeListener&lt;T&gt; listener;
1212 
1213         SynchronizedObservableList(ObservableList&lt;T&gt; seq) {
1214             super(seq);
1215             this.backingList = seq;
1216             listener = c -&gt; {
1217                 ListListenerHelper.fireValueChangedEvent(helper, new SourceAdapterChange&lt;T&gt;(SynchronizedObservableList.this, c));
1218             };
1219             backingList.addListener(new WeakListChangeListener&lt;T&gt;(listener));
1220         }
1221 
1222         @Override
1223         public boolean addAll(T... elements) {
1224             synchronized(mutex) {
1225                 return backingList.addAll(elements);
1226             }
1227         }
1228 
1229         @Override
1230         public boolean setAll(T... elements) {
1231             synchronized(mutex) {
1232                 return backingList.setAll(elements);
1233             }
1234         }
1235 
1236         @Override
1237         public boolean removeAll(T... elements) {
1238             synchronized(mutex) {
1239                 return backingList.removeAll(elements);
1240             }
1241         }
1242 
1243         @Override
1244         public boolean retainAll(T... elements) {
1245             synchronized(mutex) {
1246                 return backingList.retainAll(elements);
1247             }
1248         }
1249 
1250         @Override
1251         public void remove(int from, int to) {
1252             synchronized(mutex) {
1253                 backingList.remove(from, to);
1254             }
1255         }
1256 
1257         @Override
1258         public boolean setAll(Collection&lt;? extends T&gt; col) {
1259             synchronized(mutex) {
1260                 return backingList.setAll(col);
1261             }
1262         }
1263 
1264         @Override
1265         public final void addListener(InvalidationListener listener) {
1266             synchronized (mutex) {
1267                 helper = ListListenerHelper.addListener(helper, listener);
1268             }
1269         }
1270 
1271         @Override
1272         public final void removeListener(InvalidationListener listener) {
1273             synchronized (mutex) {
1274                 helper = ListListenerHelper.removeListener(helper, listener);
1275             }
1276         }
1277 
1278         @Override
1279         public void addListener(ListChangeListener&lt;? super T&gt; listener) {
1280             synchronized (mutex) {
1281                 helper = ListListenerHelper.addListener(helper, listener);
1282             }
1283         }
1284 
1285         @Override
1286         public void removeListener(ListChangeListener&lt;? super T&gt; listener) {
1287             synchronized (mutex) {
1288                 helper = ListListenerHelper.removeListener(helper, listener);
1289             }
1290         }
1291 
1292 
1293     }
1294 
1295     private static class CheckedObservableList&lt;T&gt; extends ObservableListBase&lt;T&gt; implements ObservableList&lt;T&gt; {
1296 
1297         private final ObservableList&lt;T&gt; list;
1298         private final Class&lt;T&gt; type;
1299         private final ListChangeListener&lt;T&gt; listener;
1300 
1301         CheckedObservableList(ObservableList&lt;T&gt; list, Class&lt;T&gt; type) {
1302             if (list == null || type == null) {
1303                 throw new NullPointerException();
1304             }
1305             this.list = list;
1306             this.type = type;
1307             listener = c -&gt; {
1308                 fireChange(new SourceAdapterChange&lt;T&gt;(CheckedObservableList.this, c));
1309             };
1310             list.addListener(new WeakListChangeListener&lt;T&gt;(listener));
1311         }
1312 
1313         void typeCheck(Object o) {
1314             if (o != null &amp;&amp; !type.isInstance(o)) {
1315                 throw new ClassCastException(&quot;Attempt to insert &quot;
1316                         + o.getClass() + &quot; element into collection with element type &quot;
1317                         + type);
1318             }
1319         }
1320 
1321         @Override
1322         public int size() {
1323             return list.size();
1324         }
1325 
1326         @Override
1327         public boolean isEmpty() {
1328             return list.isEmpty();
1329         }
1330 
1331         @Override
1332         public boolean contains(Object o) {
1333             return list.contains(o);
1334         }
1335 
1336         @Override
1337         public Object[] toArray() {
1338             return list.toArray();
1339         }
1340 
1341         @Override
1342         public &lt;T&gt; T[] toArray(T[] a) {
1343             return list.toArray(a);
1344         }
1345 
1346         @Override
1347         public String toString() {
1348             return list.toString();
1349         }
1350 
1351         @Override
1352         public boolean remove(Object o) {
1353             return list.remove(o);
1354         }
1355 
1356         @Override
1357         public boolean containsAll(Collection&lt;?&gt; coll) {
1358             return list.containsAll(coll);
1359         }
1360 
1361         @Override
1362         public boolean removeAll(Collection&lt;?&gt; coll) {
1363             return list.removeAll(coll);
1364         }
1365 
1366         @Override
1367         public boolean retainAll(Collection&lt;?&gt; coll) {
1368             return list.retainAll(coll);
1369         }
1370 
1371         @Override
1372         public boolean removeAll(T... elements) {
1373             return list.removeAll(elements);
1374         }
1375 
1376         @Override
1377         public boolean retainAll(T... elements) {
1378             return list.retainAll(elements);
1379         }
1380 
1381         @Override
1382         public void remove(int from, int to) {
1383             list.remove(from, to);
1384         }
1385 
1386         @Override
1387         public void clear() {
1388             list.clear();
1389         }
1390 
1391         @Override
1392         public boolean equals(Object o) {
1393             return o == this || list.equals(o);
1394         }
1395 
1396         @Override
1397         public int hashCode() {
1398             return list.hashCode();
1399         }
1400 
1401         @Override
1402         public T get(int index) {
1403             return list.get(index);
1404         }
1405 
1406         @Override
1407         public T remove(int index) {
1408             return list.remove(index);
1409         }
1410 
1411         @Override
1412         public int indexOf(Object o) {
1413             return list.indexOf(o);
1414         }
1415 
1416         @Override
1417         public int lastIndexOf(Object o) {
1418             return list.lastIndexOf(o);
1419         }
1420 
1421         @Override
1422         public T set(int index, T element) {
1423             typeCheck(element);
1424             return list.set(index, element);
1425         }
1426 
1427         @Override
1428         public void add(int index, T element) {
1429             typeCheck(element);
1430             list.add(index, element);
1431         }
1432 
1433         @Override
1434         @SuppressWarnings(&quot;unchecked&quot;)
1435         public boolean addAll(int index, Collection&lt;? extends T&gt; c) {
1436             T[] a = null;
1437             try {
1438                 a = c.toArray((T[]) Array.newInstance(type, 0));
1439             } catch (ArrayStoreException e) {
1440                 throw new ClassCastException();
1441             }
1442 
1443             return this.list.addAll(index, Arrays.asList(a));
1444         }
1445 
1446         @Override
1447         @SuppressWarnings(&quot;unchecked&quot;)
1448         public boolean addAll(Collection&lt;? extends T&gt; coll) {
1449             T[] a = null;
1450             try {
1451                 a = coll.toArray((T[]) Array.newInstance(type, 0));
1452             } catch (ArrayStoreException e) {
1453                 throw new ClassCastException();
1454             }
1455 
1456             return this.list.addAll(Arrays.asList(a));
1457         }
1458 
1459         @Override
1460         public ListIterator&lt;T&gt; listIterator() {
1461             return listIterator(0);
1462         }
1463 
1464         @Override
1465         public ListIterator&lt;T&gt; listIterator(final int index) {
1466             return new ListIterator&lt;T&gt;() {
1467 
1468                 ListIterator&lt;T&gt; i = list.listIterator(index);
1469 
1470                 @Override
1471                 public boolean hasNext() {
1472                     return i.hasNext();
1473                 }
1474 
1475                 @Override
1476                 public T next() {
1477                     return i.next();
1478                 }
1479 
1480                 @Override
1481                 public boolean hasPrevious() {
1482                     return i.hasPrevious();
1483                 }
1484 
1485                 @Override
1486                 public T previous() {
1487                     return i.previous();
1488                 }
1489 
1490                 @Override
1491                 public int nextIndex() {
1492                     return i.nextIndex();
1493                 }
1494 
1495                 @Override
1496                 public int previousIndex() {
1497                     return i.previousIndex();
1498                 }
1499 
1500                 @Override
1501                 public void remove() {
1502                     i.remove();
1503                 }
1504 
1505                 @Override
1506                 public void set(T e) {
1507                     typeCheck(e);
1508                     i.set(e);
1509                 }
1510 
1511                 @Override
1512                 public void add(T e) {
1513                     typeCheck(e);
1514                     i.add(e);
1515                 }
1516             };
1517         }
1518 
1519         @Override
1520         public Iterator&lt;T&gt; iterator() {
1521             return new Iterator&lt;T&gt;() {
1522 
1523                 private final Iterator&lt;T&gt; it = list.iterator();
1524 
1525                 @Override
1526                 public boolean hasNext() {
1527                     return it.hasNext();
1528                 }
1529 
1530                 @Override
1531                 public T next() {
1532                     return it.next();
1533                 }
1534 
1535                 @Override
1536                 public void remove() {
1537                     it.remove();
1538                 }
1539             };
1540         }
1541 
1542         @Override
1543         public boolean add(T e) {
1544             typeCheck(e);
1545             return list.add(e);
1546         }
1547 
1548         @Override
1549         public List&lt;T&gt; subList(int fromIndex, int toIndex) {
1550             return Collections.checkedList(list.subList(fromIndex, toIndex), type);
1551         }
1552 
1553         @Override
1554         @SuppressWarnings(&quot;unchecked&quot;)
1555         public boolean addAll(T... elements) {
1556             try {
1557                 T[] array = (T[]) Array.newInstance(type, elements.length);
1558                 System.arraycopy(elements, 0, array, 0, elements.length);
1559                 return list.addAll(array);
1560             } catch (ArrayStoreException e) {
1561                 throw new ClassCastException();
1562             }
1563         }
1564 
1565         @Override
1566         @SuppressWarnings(&quot;unchecked&quot;)
1567         public boolean setAll(T... elements) {
1568             try {
1569                 T[] array = (T[]) Array.newInstance(type, elements.length);
1570                 System.arraycopy(elements, 0, array, 0, elements.length);
1571                 return list.setAll(array);
1572             } catch (ArrayStoreException e) {
1573                 throw new ClassCastException();
1574             }
1575         }
1576 
1577         @Override
1578         @SuppressWarnings(&quot;unchecked&quot;)
1579         public boolean setAll(Collection&lt;? extends T&gt; col) {
1580             T[] a = null;
1581             try {
1582                 a = col.toArray((T[]) Array.newInstance(type, 0));
1583             } catch (ArrayStoreException e) {
1584                 throw new ClassCastException();
1585             }
1586 
1587             return list.setAll(Arrays.asList(a));
1588         }
1589     }
1590 
1591     private static class EmptyObservableSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements ObservableSet&lt;E&gt; {
1592 
1593         public EmptyObservableSet() {
1594         }
1595 
1596         @Override
1597         public void addListener(InvalidationListener listener) {
1598         }
1599 
1600         @Override
1601         public void removeListener(InvalidationListener listener) {
1602         }
1603 
1604         @Override
1605         public void addListener(SetChangeListener&lt;? super E&gt; listener) {
1606         }
1607 
1608         @Override
1609         public void removeListener(SetChangeListener&lt;? super E&gt; listener) {
1610         }
1611 
1612         @Override
1613         public int size() {
1614             return 0;
1615         }
1616 
1617         @Override
1618         public boolean isEmpty() {
1619             return true;
1620         }
1621 
1622         @Override
1623         public boolean contains(Object obj) {
1624             return false;
1625         }
1626 
1627         @Override
1628         public boolean containsAll(Collection&lt;?&gt; c) {
1629             return c.isEmpty();
1630         }
1631 
1632         @Override
1633         public Object[] toArray() {
1634             return new Object[0];
1635         }
1636 
1637         @Override
1638         public &lt;E&gt; E[] toArray(E[] a) {
1639             if (a.length &gt; 0)
1640                 a[0] = null;
1641             return a;
1642         }
1643 
1644         @Override
1645         public Iterator&lt;E&gt; iterator() {
1646             return new Iterator() {
1647 
1648                 @Override
1649                 public boolean hasNext() {
1650                     return false;
1651                 }
1652 
1653                 @Override
1654                 public Object next() {
1655                     throw new NoSuchElementException();
1656                 }
1657 
1658                 @Override
1659                 public void remove() {
1660                     throw new UnsupportedOperationException();
1661                 }
1662             };
1663         }
1664 
1665     }
1666 
1667     private static class UnmodifiableObservableSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements ObservableSet&lt;E&gt; {
1668 
1669         private final ObservableSet&lt;E&gt; backingSet;
1670         private SetListenerHelper&lt;E&gt; listenerHelper;
1671         private SetChangeListener&lt;E&gt; listener;
1672 
1673         public UnmodifiableObservableSet(ObservableSet&lt;E&gt; backingSet) {
1674             this.backingSet = backingSet;
1675             this.listener = null;
1676         }
1677 
1678         private void initListener() {
1679             if (listener == null) {
1680                 listener = c -&gt; {
1681                     callObservers(new SetAdapterChange&lt;E&gt;(UnmodifiableObservableSet.this, c));
1682                 };
1683                 this.backingSet.addListener(new WeakSetChangeListener&lt;E&gt;(listener));
1684             }
1685         }
1686 
1687         private void callObservers(SetChangeListener.Change&lt;? extends E&gt; change) {
1688             SetListenerHelper.fireValueChangedEvent(listenerHelper, change);
1689         }
1690 
1691         @Override
1692         public Iterator&lt;E&gt; iterator() {
1693             return new Iterator&lt;E&gt;() {
1694                 private final Iterator&lt;? extends E&gt; i = backingSet.iterator();
1695 
1696                 @Override
1697                 public boolean hasNext() {
1698                     return i.hasNext();
1699                 }
1700 
1701                 @Override
1702                 public E next() {
1703                     return i.next();
1704                 }
1705             };
1706         }
1707 
1708         @Override
1709         public int size() {
1710             return backingSet.size();
1711         }
1712 
1713         @Override
1714         public boolean isEmpty() {
1715             return backingSet.isEmpty();
1716         }
1717 
1718         @Override
1719         public boolean contains(Object o) {
1720             return backingSet.contains(o);
1721         }
1722 
1723         @Override
1724         public void addListener(InvalidationListener listener) {
1725             initListener();
1726             listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1727         }
1728 
1729         @Override
1730         public void removeListener(InvalidationListener listener) {
1731             listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1732         }
1733 
1734         @Override
1735         public void addListener(SetChangeListener&lt;? super E&gt; listener) {
1736             initListener();
1737             listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1738         }
1739 
1740         @Override
1741         public void removeListener(SetChangeListener&lt;? super E&gt; listener) {
1742             listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1743         }
1744 
1745         @Override
1746         public boolean add(E e) {
1747             throw new UnsupportedOperationException();
1748         }
1749 
1750         @Override
1751         public boolean remove(Object o) {
1752             throw new UnsupportedOperationException();
1753         }
1754 
1755         @Override
1756         public boolean addAll(Collection&lt;? extends E&gt; c) {
1757             throw new UnsupportedOperationException();
1758         }
1759 
1760         @Override
1761         public boolean retainAll(Collection&lt;?&gt; c) {
1762             throw new UnsupportedOperationException();
1763         }
1764 
1765         @Override
1766         public boolean removeAll(Collection&lt;?&gt; c) {
1767             throw new UnsupportedOperationException();
1768         }
1769 
1770         @Override
1771         public void clear() {
1772             throw new UnsupportedOperationException();
1773         }
1774     }
1775 
1776     private static class SynchronizedSet&lt;E&gt; implements Set&lt;E&gt; {
1777         final Object mutex;
1778         private final Set&lt;E&gt; backingSet;
1779 
1780         SynchronizedSet(Set&lt;E&gt; set, Object mutex) {
1781             this.backingSet = set;
1782             this.mutex = mutex;
1783         }
1784 
1785         SynchronizedSet(Set&lt;E&gt; set) {
1786             this.backingSet = set;
1787             this.mutex = this;
1788         }
1789 
1790         @Override
1791         public int size() {
1792             synchronized(mutex) {
1793                 return backingSet.size();
1794             }
1795         }
1796 
1797         @Override
1798         public boolean isEmpty() {
1799             synchronized(mutex) {
1800                 return backingSet.isEmpty();
1801             }
1802         }
1803 
1804         @Override
1805         public boolean contains(Object o) {
1806             synchronized(mutex) {
1807                 return backingSet.contains(o);
1808             }
1809         }
1810 
1811         @Override
1812         public Iterator&lt;E&gt; iterator() {
1813             return backingSet.iterator();
1814         }
1815 
1816         @Override
1817         public Object[] toArray() {
1818             synchronized(mutex) {
1819                 return backingSet.toArray();
1820             }
1821         }
1822 
1823         @Override
1824         public &lt;E&gt; E[] toArray(E[] a) {
1825             synchronized(mutex) {
1826                 return backingSet.toArray(a);
1827             }
1828         }
1829 
1830         @Override
1831         public boolean add(E e) {
1832             synchronized(mutex) {
1833                 return backingSet.add(e);
1834             }
1835         }
1836 
1837         @Override
1838         public boolean remove(Object o) {
1839             synchronized(mutex) {
1840                 return backingSet.remove(o);
1841             }
1842         }
1843 
1844         @Override
1845         public boolean containsAll(Collection&lt;?&gt; c) {
1846             synchronized(mutex) {
1847                 return backingSet.containsAll(c);
1848             }
1849         }
1850 
1851         @Override
1852         public boolean addAll(Collection&lt;? extends E&gt; c) {
1853             synchronized(mutex) {
1854                 return backingSet.addAll(c);
1855             }
1856         }
1857 
1858         @Override
1859         public boolean retainAll(Collection&lt;?&gt; c) {
1860             synchronized(mutex) {
1861                 return backingSet.retainAll(c);
1862             }
1863         }
1864 
1865         @Override
1866         public boolean removeAll(Collection&lt;?&gt; c) {
1867             synchronized(mutex) {
1868                 return backingSet.removeAll(c);
1869             }
1870         }
1871 
1872         @Override
1873         public void clear() {
1874             synchronized(mutex) {
1875                 backingSet.clear();
1876             }
1877         }
1878 
1879         @Override
1880         public boolean equals(Object o) {
1881             if (o == this) {
1882                 return true;
1883             }
1884             synchronized(mutex) {
1885                 return backingSet.equals(o);
1886             }
1887         }
1888 
1889         @Override
1890         public int hashCode() {
1891             synchronized (mutex) {
1892                 return backingSet.hashCode();
1893             }
1894         }
1895     }
1896 
1897     private static class SynchronizedObservableSet&lt;E&gt; extends SynchronizedSet&lt;E&gt; implements ObservableSet&lt;E&gt; {
1898 
1899         private final ObservableSet&lt;E&gt; backingSet;
1900         private SetListenerHelper listenerHelper;
1901         private final SetChangeListener&lt;E&gt; listener;
1902 
1903         SynchronizedObservableSet(ObservableSet&lt;E&gt; set) {
1904             super(set);
1905             backingSet = set;
1906             listener = c -&gt; {
1907                 SetListenerHelper.fireValueChangedEvent(listenerHelper, new SetAdapterChange&lt;E&gt;(SynchronizedObservableSet.this, c));
1908             };
1909             backingSet.addListener(new WeakSetChangeListener&lt;E&gt;(listener));
1910         }
1911 
1912         @Override
1913         public void addListener(InvalidationListener listener) {
1914             synchronized (mutex) {
1915                 listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1916             }
1917         }
1918 
1919         @Override
1920         public void removeListener(InvalidationListener listener) {
1921             synchronized (mutex) {
1922                 listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1923             }
1924         }
1925         @Override
1926         public void addListener(SetChangeListener&lt;? super E&gt; listener) {
1927             synchronized (mutex) {
1928                 listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1929             }
1930         }
1931 
1932         @Override
1933         public void removeListener(SetChangeListener&lt;? super E&gt; listener) {
1934             synchronized (mutex) {
1935                 listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1936             }
1937         }
1938     }
1939 
1940     private static class CheckedObservableSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements ObservableSet&lt;E&gt; {
1941 
1942         private final ObservableSet&lt;E&gt; backingSet;
1943         private final Class&lt;E&gt; type;
1944         private SetListenerHelper listenerHelper;
1945         private final SetChangeListener&lt;E&gt; listener;
1946 
1947         CheckedObservableSet(ObservableSet&lt;E&gt; set, Class&lt;E&gt; type) {
1948             if (set == null || type == null) {
1949                 throw new NullPointerException();
1950             }
1951             backingSet = set;
1952             this.type = type;
1953             listener = c -&gt; {
1954                 callObservers(new SetAdapterChange&lt;E&gt;(CheckedObservableSet.this, c));
1955             };
1956             backingSet.addListener(new WeakSetChangeListener&lt;E&gt;(listener));
1957         }
1958 
1959         private void callObservers(SetChangeListener.Change&lt;? extends E&gt; c) {
1960             SetListenerHelper.fireValueChangedEvent(listenerHelper, c);
1961         }
1962 
1963         void typeCheck(Object o) {
1964             if (o != null &amp;&amp; !type.isInstance(o)) {
1965                 throw new ClassCastException(&quot;Attempt to insert &quot;
1966                         + o.getClass() + &quot; element into collection with element type &quot;
1967                         + type);
1968             }
1969         }
1970 
1971         @Override
1972         public void addListener(InvalidationListener listener) {
1973             listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1974         }
1975 
1976         @Override
1977         public void removeListener(InvalidationListener listener) {
1978             listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1979         }
1980 
1981         @Override
1982         public void addListener(SetChangeListener&lt;? super E&gt; listener) {
1983             listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1984         }
1985 
1986         @Override
1987         public void removeListener(SetChangeListener&lt;? super E&gt; listener) {
1988             listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1989         }
1990 
1991         @Override
1992         public int size() {
1993             return backingSet.size();
1994         }
1995 
1996         @Override
1997         public boolean isEmpty() {
1998             return backingSet.isEmpty();
1999         }
2000 
2001         @Override
2002         public boolean contains(Object o) {
2003             return backingSet.contains(o);
2004         }
2005 
2006         @Override
2007         public Object[] toArray() {
2008             return backingSet.toArray();
2009         }
2010 
2011         @Override
2012         public &lt;T&gt; T[] toArray(T[] a) {
2013             return backingSet.toArray(a);
2014         }
2015 
2016         @Override
2017         public boolean add(E e) {
2018             typeCheck(e);
2019             return backingSet.add(e);
2020         }
2021 
2022         @Override
2023         public boolean remove(Object o) {
2024             return backingSet.remove(o);
2025         }
2026 
2027         @Override
2028         public boolean containsAll(Collection&lt;?&gt; c) {
2029             return backingSet.containsAll(c);
2030         }
2031 
2032         @Override
2033         @SuppressWarnings(&quot;unchecked&quot;)
2034         public boolean addAll(Collection&lt;? extends E&gt; c) {
2035             E[] a = null;
2036             try {
2037                 a = c.toArray((E[]) Array.newInstance(type, 0));
2038             } catch (ArrayStoreException e) {
2039                 throw new ClassCastException();
2040             }
2041 
2042             return backingSet.addAll(Arrays.asList(a));
2043         }
2044 
2045         @Override
2046         public boolean retainAll(Collection&lt;?&gt; c) {
2047             return backingSet.retainAll(c);
2048         }
2049 
2050         @Override
2051         public boolean removeAll(Collection&lt;?&gt; c) {
2052             return backingSet.removeAll(c);
2053         }
2054 
2055         @Override
2056         public void clear() {
2057             backingSet.clear();
2058         }
2059 
2060         @Override
2061         public boolean equals(Object o) {
2062             return o == this || backingSet.equals(o);
2063         }
2064 
2065         @Override
2066         public int hashCode() {
2067             return backingSet.hashCode();
2068         }
2069 
2070         @Override
2071         public Iterator&lt;E&gt; iterator() {
2072             final Iterator&lt;E&gt; it = backingSet.iterator();
2073 
2074             return new Iterator&lt;E&gt;() {
2075                 @Override
2076                 public boolean hasNext() {
2077                     return it.hasNext();
2078                 }
2079 
2080                 @Override
2081                 public E next() {
2082                     return it.next();
2083                 }
2084 
2085                 @Override
2086                 public void remove() {
2087                     it.remove();
2088                 }
2089             };
2090         }
2091 
2092     }
2093 
2094     private static class EmptyObservableMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements ObservableMap&lt;K, V&gt; {
2095 
2096         public EmptyObservableMap() {
2097         }
2098 
2099         @Override
2100         public void addListener(InvalidationListener listener) {
2101         }
2102 
2103         @Override
2104         public void removeListener(InvalidationListener listener) {
2105         }
2106 
2107         @Override
2108         public void addListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2109         }
2110 
2111         @Override
2112         public void removeListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2113         }
2114 
2115         @Override
2116         public int size() {
2117             return 0;
2118         }
2119 
2120         @Override
2121         public boolean isEmpty() {
2122             return true;
2123         }
2124 
2125         @Override
2126         public boolean containsKey(Object key) {
2127             return false;
2128         }
2129 
2130         @Override
2131         public boolean containsValue(Object value) {
2132             return false;
2133         }
2134 
2135         @Override
2136         public V get(Object key) {
2137             return null;
2138         }
2139 
2140         @Override
2141         public Set&lt;K&gt; keySet() {
2142             return emptyObservableSet();
2143         }
2144 
2145         @Override
2146         public Collection&lt;V&gt; values() {
2147             return emptyObservableSet();
2148         }
2149 
2150         @Override
2151         public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
2152             return emptyObservableSet();
2153         }
2154 
2155         @Override
2156         public boolean equals(Object o) {
2157             return (o instanceof Map) &amp;&amp; ((Map&lt;?,?&gt;)o).isEmpty();
2158         }
2159 
2160         @Override
2161         public int hashCode() {
2162             return 0;
2163         }
2164     }
2165 
2166     private static class CheckedObservableMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements ObservableMap&lt;K, V&gt; {
2167 
2168         private final ObservableMap&lt;K, V&gt; backingMap;
2169         private final Class&lt;K&gt; keyType;
2170         private final Class&lt;V&gt; valueType;
2171         private MapListenerHelper listenerHelper;
2172         private final MapChangeListener&lt;K, V&gt; listener;
2173 
2174         CheckedObservableMap(ObservableMap&lt;K, V&gt; map, Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) {
2175             backingMap = map;
2176             this.keyType = keyType;
2177             this.valueType = valueType;
2178             listener = c -&gt; {
2179                 callObservers(new MapAdapterChange&lt;K, V&gt;(CheckedObservableMap.this, c));
2180             };
2181             backingMap.addListener(new WeakMapChangeListener&lt;K, V&gt;(listener));
2182         }
2183 
2184         private void callObservers(MapChangeListener.Change&lt;? extends K, ? extends V&gt; c) {
2185             MapListenerHelper.fireValueChangedEvent(listenerHelper, c);
2186         }
2187 
2188         void typeCheck(Object key, Object value) {
2189             if (key != null &amp;&amp; !keyType.isInstance(key)) {
2190                 throw new ClassCastException(&quot;Attempt to insert &quot;
2191                         + key.getClass() + &quot; key into map with key type &quot;
2192                         + keyType);
2193             }
2194 
2195             if (value != null &amp;&amp; !valueType.isInstance(value)) {
2196                 throw new ClassCastException(&quot;Attempt to insert &quot;
2197                         + value.getClass() + &quot; value into map with value type &quot;
2198                         + valueType);
2199             }
2200         }
2201 
2202         @Override
2203         public void addListener(InvalidationListener listener) {
2204             listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
2205         }
2206 
2207         @Override
2208         public void removeListener(InvalidationListener listener) {
2209             listenerHelper = MapListenerHelper.removeListener(listenerHelper, listener);
2210         }
2211 
2212         @Override
2213         public void addListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2214             listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
2215         }
2216 
2217         @Override
2218         public void removeListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2219             listenerHelper = MapListenerHelper.removeListener(listenerHelper, listener);
2220         }
2221 
2222         @Override
2223         public int size() {
2224             return backingMap.size();
2225         }
2226 
2227         @Override
2228         public boolean isEmpty() {
2229             return backingMap.isEmpty();
2230         }
2231 
2232         @Override
2233         public boolean containsKey(Object key) {
2234             return backingMap.containsKey(key);
2235         }
2236 
2237         @Override
2238         public boolean containsValue(Object value) {
2239             return backingMap.containsValue(value);
2240         }
2241 
2242         @Override
2243         public V get(Object key) {
2244             return backingMap.get(key);
2245         }
2246 
2247         @Override
2248         public V put(K key, V value) {
2249             typeCheck(key, value);
2250             return backingMap.put(key, value);
2251         }
2252 
2253         @Override
2254         public V remove(Object key) {
2255             return backingMap.remove(key);
2256         }
2257 
2258         @Override
2259         @SuppressWarnings(&quot;unchecked&quot;)
2260         public void putAll(Map t) {
2261             // Satisfy the following goals:
2262             // - good diagnostics in case of type mismatch
2263             // - all-or-nothing semantics
2264             // - protection from malicious t
2265             // - correct behavior if t is a concurrent map
2266             Object[] entries = t.entrySet().toArray();
2267             List&lt;Map.Entry&lt;K,V&gt;&gt; checked =
2268                 new ArrayList&lt;Map.Entry&lt;K,V&gt;&gt;(entries.length);
2269             for (Object o : entries) {
2270                 Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;
2271                 Object k = e.getKey();
2272                 Object v = e.getValue();
2273                 typeCheck(k, v);
2274                 checked.add(
2275                     new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;((K) k, (V) v));
2276             }
2277             for (Map.Entry&lt;K,V&gt; e : checked)
2278                 backingMap.put(e.getKey(), e.getValue());
2279         }
2280 
2281         @Override
2282         public void clear() {
2283             backingMap.clear();
2284         }
2285 
2286         @Override
2287         public Set&lt;K&gt; keySet() {
2288             return backingMap.keySet();
2289         }
2290 
2291         @Override
2292         public Collection&lt;V&gt; values() {
2293             return backingMap.values();
2294         }
2295 
2296         private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;
2297 
2298         @Override
2299         public Set entrySet() {
2300             if (entrySet==null)
2301                 entrySet = new CheckedEntrySet&lt;K,V&gt;(backingMap.entrySet(), valueType);
2302             return entrySet;
2303         }
2304 
2305         @Override
2306         public boolean equals(Object o) {
2307             return o == this || backingMap.equals(o);
2308         }
2309 
2310         @Override
2311         public int hashCode() {
2312             return backingMap.hashCode();
2313         }
2314 
2315         static class CheckedEntrySet&lt;K,V&gt; implements Set&lt;Map.Entry&lt;K,V&gt;&gt; {
2316             private final Set&lt;Map.Entry&lt;K,V&gt;&gt; s;
2317             private final Class&lt;V&gt; valueType;
2318 
2319             CheckedEntrySet(Set&lt;Map.Entry&lt;K, V&gt;&gt; s, Class&lt;V&gt; valueType) {
2320                 this.s = s;
2321                 this.valueType = valueType;
2322             }
2323 
2324             @Override
2325             public int size() {
2326                 return s.size();
2327             }
2328 
2329             @Override
2330             public boolean isEmpty() {
2331                 return s.isEmpty();
2332             }
2333 
2334             @Override
2335             public String toString() {
2336                 return s.toString();
2337             }
2338 
2339             @Override
2340             public int hashCode() {
2341                 return s.hashCode();
2342             }
2343 
2344             @Override
2345             public void clear() {
2346                 s.clear();
2347             }
2348 
2349             @Override
2350             public boolean add(Map.Entry&lt;K, V&gt; e) {
2351                 throw new UnsupportedOperationException();
2352             }
2353 
2354             @Override
2355             public boolean addAll(Collection&lt;? extends Map.Entry&lt;K, V&gt;&gt; coll) {
2356                 throw new UnsupportedOperationException();
2357             }
2358 
2359             @Override
2360             public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
2361                 final Iterator&lt;Map.Entry&lt;K, V&gt;&gt; i = s.iterator();
2362                 final Class&lt;V&gt; valueType = this.valueType;
2363 
2364                 return new Iterator&lt;Map.Entry&lt;K,V&gt;&gt;() {
2365                     @Override
2366                     public boolean hasNext() {
2367                         return i.hasNext();
2368                     }
2369 
2370                     @Override
2371                     public void remove() {
2372                         i.remove();
2373                     }
2374 
2375                     @Override
2376                     public Map.Entry&lt;K,V&gt; next() {
2377                         return checkedEntry(i.next(), valueType);
2378                     }
2379                 };
2380             }
2381 
2382             @Override
2383             @SuppressWarnings(&quot;unchecked&quot;)
2384             public Object[] toArray() {
2385                 Object[] source = s.toArray();
2386 
2387                 /*
2388                  * Ensure that we don&#39;t get an ArrayStoreException even if
2389                  * s.toArray returns an array of something other than Object
2390                  */
2391                 Object[] dest = (CheckedEntry.class.isInstance(
2392                     source.getClass().getComponentType()) ? source :
2393                                  new Object[source.length]);
2394 
2395                 for (int i = 0; i &lt; source.length; i++)
2396                     dest[i] = checkedEntry((Map.Entry&lt;K,V&gt;)source[i],
2397                                            valueType);
2398                 return dest;
2399             }
2400 
2401             @Override
2402             @SuppressWarnings(&quot;unchecked&quot;)
2403             public &lt;T&gt; T[] toArray(T[] a) {
2404                 // We don&#39;t pass a to s.toArray, to avoid window of
2405                 // vulnerability wherein an unscrupulous multithreaded client
2406                 // could get his hands on raw (unwrapped) Entries from s.
2407                 T[] arr = s.toArray(a.length==0 ? a : Arrays.copyOf(a, 0));
2408 
2409                 for (int i=0; i&lt;arr.length; i++)
2410                     arr[i] = (T) checkedEntry((Map.Entry&lt;K,V&gt;)arr[i],
2411                                               valueType);
2412                 if (arr.length &gt; a.length)
2413                     return arr;
2414 
2415                 System.arraycopy(arr, 0, a, 0, arr.length);
2416                 if (a.length &gt; arr.length)
2417                     a[arr.length] = null;
2418                 return a;
2419             }
2420 
2421             /**
2422              * This method is overridden to protect the backing set against
2423              * an object with a nefarious equals function that senses
2424              * that the equality-candidate is Map.Entry and calls its
2425              * setValue method.
2426              */
2427             @Override
2428             public boolean contains(Object o) {
2429                 if (!(o instanceof Map.Entry))
2430                     return false;
2431                 Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;
2432                 return s.contains(
2433                     (e instanceof CheckedEntry) ? e : checkedEntry(e, valueType));
2434             }
2435 
2436             /**
2437              * The bulk collection methods are overridden to protect
2438              * against an unscrupulous collection whose contains(Object o)
2439              * method senses when o is a Map.Entry, and calls o.setValue.
2440              */
2441             @Override
2442             public boolean containsAll(Collection&lt;?&gt; c) {
2443                 for (Object o : c)
2444                     if (!contains(o)) // Invokes safe contains() above
2445                         return false;
2446                 return true;
2447             }
2448 
2449             @Override
2450             public boolean remove(Object o) {
2451                 if (!(o instanceof Map.Entry))
2452                     return false;
2453                 return s.remove(new AbstractMap.SimpleImmutableEntry
2454                                 &lt;Object, Object&gt;((Map.Entry&lt;?,?&gt;)o));
2455             }
2456 
2457             @Override
2458             public boolean removeAll(Collection&lt;?&gt; c) {
2459                 return batchRemove(c, false);
2460             }
2461 
2462             @Override
2463             public boolean retainAll(Collection&lt;?&gt; c) {
2464                 return batchRemove(c, true);
2465             }
2466 
2467             private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {
2468                 boolean modified = false;
2469                 Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = iterator();
2470                 while (it.hasNext()) {
2471                     if (c.contains(it.next()) != complement) {
2472                         it.remove();
2473                         modified = true;
2474                     }
2475                 }
2476                 return modified;
2477             }
2478 
2479             @Override
2480             public boolean equals(Object o) {
2481                 if (o == this)
2482                     return true;
2483                 if (!(o instanceof Set))
2484                     return false;
2485                 Set&lt;?&gt; that = (Set&lt;?&gt;) o;
2486                 return that.size() == s.size()
2487                     &amp;&amp; containsAll(that); // Invokes safe containsAll() above
2488             }
2489 
2490             static &lt;K,V,T&gt; CheckedEntry&lt;K,V,T&gt; checkedEntry(Map.Entry&lt;K,V&gt; e,
2491                                                             Class&lt;T&gt; valueType) {
2492                 return new CheckedEntry&lt;K,V,T&gt;(e, valueType);
2493             }
2494 
2495             /**
2496              * This &quot;wrapper class&quot; serves two purposes: it prevents
2497              * the client from modifying the backing Map, by short-circuiting
2498              * the setValue method, and it protects the backing Map against
2499              * an ill-behaved Map.Entry that attempts to modify another
2500              * Map.Entry when asked to perform an equality check.
2501              */
2502             private static class CheckedEntry&lt;K,V,T&gt; implements Map.Entry&lt;K,V&gt; {
2503                 private final Map.Entry&lt;K, V&gt; e;
2504                 private final Class&lt;T&gt; valueType;
2505 
2506                 CheckedEntry(Map.Entry&lt;K, V&gt; e, Class&lt;T&gt; valueType) {
2507                     this.e = e;
2508                     this.valueType = valueType;
2509                 }
2510 
2511                 @Override
2512                 public K getKey() {
2513                     return e.getKey();
2514                 }
2515 
2516                 @Override
2517                 public V getValue() {
2518                     return e.getValue();
2519                 }
2520 
2521                 @Override
2522                 public int hashCode() {
2523                     return e.hashCode();
2524                 }
2525 
2526                 @Override
2527                 public String toString() {
2528                     return e.toString();
2529                 }
2530 
2531                 @Override
2532                 public V setValue(V value) {
2533                     if (value != null &amp;&amp; !valueType.isInstance(value))
2534                         throw new ClassCastException(badValueMsg(value));
2535                     return e.setValue(value);
2536                 }
2537 
2538                 private String badValueMsg(Object value) {
2539                     return &quot;Attempt to insert &quot; + value.getClass() +
2540                         &quot; value into map with value type &quot; + valueType;
2541                 }
2542 
2543                 @Override
2544                 public boolean equals(Object o) {
2545                     if (o == this)
2546                         return true;
2547                     if (!(o instanceof Map.Entry))
2548                         return false;
2549                     return e.equals(new AbstractMap.SimpleImmutableEntry
2550                                     &lt;Object, Object&gt;((Map.Entry&lt;?,?&gt;)o));
2551                 }
2552             }
2553         }
2554 
2555     }
2556 
2557     private static class SynchronizedMap&lt;K, V&gt; implements Map&lt;K, V&gt; {
2558         final Object mutex;
2559         private final Map&lt;K, V&gt; backingMap;
2560 
2561         SynchronizedMap(Map&lt;K, V&gt; map) {
2562             backingMap = map;
2563             this.mutex = this;
2564         }
2565 
2566         @Override
2567         public int size() {
2568             synchronized (mutex) {
2569                 return backingMap.size();
2570             }
2571         }
2572 
2573         @Override
2574         public boolean isEmpty() {
2575             synchronized (mutex) {
2576                 return backingMap.isEmpty();
2577             }
2578         }
2579 
2580         @Override
2581         public boolean containsKey(Object key) {
2582             synchronized (mutex) {
2583                 return backingMap.containsKey(key);
2584             }
2585         }
2586 
2587         @Override
2588         public boolean containsValue(Object value) {
2589             synchronized (mutex) {
2590                 return backingMap.containsValue(value);
2591             }
2592         }
2593 
2594         @Override
2595         public V get(Object key) {
2596             synchronized (mutex) {
2597                 return backingMap.get(key);
2598             }
2599         }
2600 
2601         @Override
2602         public V put(K key, V value) {
2603             synchronized (mutex) {
2604                 return backingMap.put(key, value);
2605             }
2606         }
2607 
2608         @Override
2609         public V remove(Object key) {
2610             synchronized (mutex) {
2611                 return backingMap.remove(key);
2612             }
2613         }
2614 
2615         @Override
2616         public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
2617             synchronized (mutex) {
2618                 backingMap.putAll(m);
2619             }
2620         }
2621 
2622         @Override
2623         public void clear() {
2624             synchronized (mutex) {
2625                 backingMap.clear();
2626             }
2627         }
2628 
2629         private transient Set&lt;K&gt; keySet = null;
2630         private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;
2631         private transient Collection&lt;V&gt; values = null;
2632 
2633         @Override
2634         public Set&lt;K&gt; keySet() {
2635             synchronized(mutex) {
2636                 if (keySet==null)
2637                     keySet = new SynchronizedSet&lt;K&gt;(backingMap.keySet(), mutex);
2638                 return keySet;
2639             }
2640         }
2641 
2642         @Override
2643         public Collection&lt;V&gt; values() {
2644             synchronized(mutex) {
2645                 if (values==null)
2646                     values = new SynchronizedCollection&lt;V&gt;(backingMap.values(), mutex);
2647                 return values;
2648             }
2649         }
2650 
2651         @Override
2652         public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {
2653             synchronized(mutex) {
2654                 if (entrySet==null)
2655                     entrySet = new SynchronizedSet&lt;Map.Entry&lt;K,V&gt;&gt;(backingMap.entrySet(), mutex);
2656                 return entrySet;
2657             }
2658         }
2659 
2660         @Override
2661         public boolean equals(Object o) {
2662             if (o == this) {
2663                 return true;
2664             }
2665             synchronized(mutex) {
2666                 return backingMap.equals(o);
2667             }
2668         }
2669 
2670         @Override
2671         public int hashCode() {
2672             synchronized(mutex) {
2673                 return backingMap.hashCode();
2674             }
2675         }
2676 
2677     }
2678 
2679     private static class SynchronizedCollection&lt;E&gt; implements Collection&lt;E&gt; {
2680 
2681         private final Collection&lt;E&gt; backingCollection;
2682         final Object mutex;
2683 
2684         SynchronizedCollection(Collection&lt;E&gt; c, Object mutex) {
2685             backingCollection = c;
2686             this.mutex = mutex;
2687         }
2688 
2689         SynchronizedCollection(Collection&lt;E&gt; c) {
2690             this(c, new Object());
2691         }
2692 
2693         @Override
2694         public int size() {
2695             synchronized (mutex) {
2696                 return backingCollection.size();
2697             }
2698         }
2699 
2700         @Override
2701         public boolean isEmpty() {
2702             synchronized (mutex) {
2703                 return backingCollection.isEmpty();
2704             }
2705         }
2706 
2707         @Override
2708         public boolean contains(Object o) {
2709             synchronized (mutex) {
2710                 return backingCollection.contains(o);
2711             }
2712         }
2713 
2714         @Override
2715         public Iterator&lt;E&gt; iterator() {
2716             return backingCollection.iterator();
2717         }
2718 
2719         @Override
2720         public Object[] toArray() {
2721             synchronized (mutex) {
2722                 return backingCollection.toArray();
2723             }
2724         }
2725 
2726         @Override
2727         public &lt;T&gt; T[] toArray(T[] a) {
2728             synchronized (mutex) {
2729                 return backingCollection.toArray(a);
2730             }
2731         }
2732 
2733         @Override
2734         public boolean add(E e) {
2735             synchronized (mutex) {
2736                 return backingCollection.add(e);
2737             }
2738         }
2739 
2740         @Override
2741         public boolean remove(Object o) {
2742             synchronized (mutex) {
2743                 return backingCollection.remove(o);
2744             }
2745         }
2746 
2747         @Override
2748         public boolean containsAll(Collection&lt;?&gt; c) {
2749             synchronized (mutex) {
2750                 return backingCollection.containsAll(c);
2751             }
2752         }
2753 
2754         @Override
2755         public boolean addAll(Collection&lt;? extends E&gt; c) {
2756             synchronized (mutex) {
2757                 return backingCollection.addAll(c);
2758             }
2759         }
2760 
2761         @Override
2762         public boolean removeAll(Collection&lt;?&gt; c) {
2763             synchronized (mutex) {
2764                 return backingCollection.removeAll(c);
2765             }
2766         }
2767 
2768         @Override
2769         public boolean retainAll(Collection&lt;?&gt; c) {
2770             synchronized (mutex) {
2771                 return backingCollection.retainAll(c);
2772             }
2773         }
2774 
2775         @Override
2776         public void clear() {
2777             synchronized (mutex) {
2778                 backingCollection.clear();
2779             }
2780         }
2781     }
2782 
2783     private static class SynchronizedObservableMap&lt;K, V&gt; extends SynchronizedMap&lt;K, V&gt; implements ObservableMap&lt;K, V&gt; {
2784 
2785         private final ObservableMap&lt;K, V&gt; backingMap;
2786         private MapListenerHelper listenerHelper;
2787         private final MapChangeListener&lt;K, V&gt; listener;
2788 
2789         SynchronizedObservableMap(ObservableMap&lt;K, V&gt; map) {
2790             super(map);
2791             backingMap = map;
2792             listener = c -&gt; {
2793                 MapListenerHelper.fireValueChangedEvent(listenerHelper, new MapAdapterChange&lt;K, V&gt;(SynchronizedObservableMap.this, c));
2794             };
2795             backingMap.addListener(new WeakMapChangeListener&lt;K, V&gt;(listener));
2796         }
2797 
2798         @Override
2799         public void addListener(InvalidationListener listener) {
2800             synchronized (mutex) {
2801                 listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
2802             }
2803         }
2804 
2805         @Override
2806         public void removeListener(InvalidationListener listener) {
2807             synchronized (mutex) {
2808                 listenerHelper = MapListenerHelper.removeListener(listenerHelper, listener);
2809             }
2810         }
2811 
2812         @Override
2813         public void addListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2814             synchronized (mutex) {
2815                 listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
2816             }
2817         }
2818 
2819         @Override
2820         public void removeListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2821             synchronized (mutex) {
2822                 listenerHelper = MapListenerHelper.removeListener(listenerHelper, listener);
2823             }
2824         }
2825 
2826     }
2827 
2828 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>