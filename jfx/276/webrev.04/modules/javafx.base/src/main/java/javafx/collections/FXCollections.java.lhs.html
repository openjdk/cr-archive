<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.base/src/main/java/javafx/collections/FXCollections.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.collections;
  27 
  28 import com.sun.javafx.collections.ListListenerHelper;
  29 import com.sun.javafx.collections.MapListenerHelper;
  30 import com.sun.javafx.collections.SetListenerHelper;
  31 import java.lang.reflect.Array;
  32 import java.util.AbstractList;
  33 import java.util.AbstractMap;
  34 import java.util.AbstractSet;
  35 import java.util.ArrayList;
  36 import java.util.Arrays;
  37 import java.util.Collection;
  38 import java.util.Collections;
  39 import java.util.Comparator;
  40 import java.util.HashMap;
  41 import java.util.HashSet;
  42 import java.util.Iterator;
  43 import java.util.List;
  44 import java.util.ListIterator;
  45 import java.util.Map;
  46 import java.util.NoSuchElementException;
  47 import java.util.Random;
  48 import java.util.Set;
  49 
  50 import javafx.beans.InvalidationListener;
  51 
  52 import com.sun.javafx.collections.ObservableListWrapper;
  53 import com.sun.javafx.collections.ObservableMapWrapper;
  54 import com.sun.javafx.collections.ObservableSetWrapper;
  55 import com.sun.javafx.collections.MapAdapterChange;
  56 import com.sun.javafx.collections.ObservableFloatArrayImpl;
  57 import com.sun.javafx.collections.ObservableIntegerArrayImpl;
  58 import com.sun.javafx.collections.ObservableSequentialListWrapper;
  59 import com.sun.javafx.collections.SetAdapterChange;
  60 import com.sun.javafx.collections.SortableList;
  61 import com.sun.javafx.collections.SourceAdapterChange;
  62 import java.util.RandomAccess;
  63 import javafx.beans.Observable;
  64 import javafx.collections.ListChangeListener.Change;
  65 import javafx.util.Callback;
  66 
  67 /**
  68  * Utility class that consists of static methods that are 1:1 copies of java.util.Collections methods.
  69  * &lt;br&gt;&lt;br&gt;
  70  * The wrapper methods (like synchronizedObservableList or emptyObservableList) has exactly the same
  71  * functionality as the methods in Collections, with exception that they return ObservableList and are
  72  * therefore suitable for methods that require ObservableList on input.
  73  * &lt;br&gt;&lt;br&gt;
  74  * The utility methods are here mainly for performance reasons. All methods are optimized in a way that
  75  * they yield only limited number of notifications. On the other hand, java.util.Collections methods
  76  * might call &quot;modification methods&quot; on an ObservableList multiple times, resulting in a number of notifications.
  77  *
  78  * @since JavaFX 2.0
  79  */
  80 public class FXCollections {
  81     /** Not to be instantiated. */
  82     private FXCollections() { }
  83 
  84     /**
  85      * Constructs an ObservableList that is backed by the specified list.
  86      * Mutation operations on the ObservableList instance will be reported
  87      * to observers that have registered on that instance.&lt;br&gt;
  88      * Note that mutation operations made directly to the underlying list are
  89      * &lt;em&gt;not&lt;/em&gt; reported to observers of any ObservableList that
  90      * wraps it.
  91      *
  92      * @param &lt;E&gt; The type of List to be wrapped
  93      * @param list a concrete List that backs this ObservableList
  94      * @return a newly created ObservableList
  95      */
  96     public static &lt;E&gt; ObservableList&lt;E&gt; observableList(List&lt;E&gt; list) {
  97         if (list == null) {
  98             throw new NullPointerException();
  99         }
 100         return list instanceof RandomAccess ? new ObservableListWrapper&lt;E&gt;(list) :
 101                 new ObservableSequentialListWrapper&lt;E&gt;(list);
 102     }
 103 
 104     /**
<a name="1" id="anc1"></a><span class="line-modified"> 105      * Constructs an ObservableList that is backed by the specified list.</span>
<span class="line-modified"> 106      * Mutation operations on the ObservableList instance will be reported</span>
<span class="line-modified"> 107      * to observers that have registered on that instance.&lt;br&gt;</span>
<span class="line-removed"> 108      * Note that mutation operations made directly to the underlying list are</span>
<span class="line-removed"> 109      * &lt;em&gt;not&lt;/em&gt; reported to observers of any ObservableList that</span>
 110      * wraps it.
<a name="2" id="anc2"></a><span class="line-modified"> 111      * &lt;br&gt;</span>
<span class="line-modified"> 112      * This list also reports mutations of the elements in it by using &lt;code&gt;extractor&lt;/code&gt;.</span>
<span class="line-modified"> 113      * Observable objects returned by extractor (applied to each list element) are listened for changes</span>
<span class="line-modified"> 114      * and transformed into &quot;update&quot; change of ListChangeListener.</span>



 115      *
<a name="3" id="anc3"></a><span class="line-modified"> 116      * @param &lt;E&gt; The type of List to be wrapped</span>
<span class="line-modified"> 117      * @param list a concrete List that backs this ObservableList</span>
<span class="line-modified"> 118      * @param extractor element to Observable[] convertor</span>


 119      * @since JavaFX 2.1
<a name="4" id="anc4"></a><span class="line-removed"> 120      * @return a newly created ObservableList</span>
 121      */
 122     public static &lt;E&gt; ObservableList&lt;E&gt; observableList(List&lt;E&gt; list, Callback&lt;E, Observable[]&gt; extractor) {
 123         if (list == null || extractor == null) {
 124             throw new NullPointerException();
 125         }
 126         return list instanceof RandomAccess ? new ObservableListWrapper&lt;E&gt;(list, extractor) :
 127             new ObservableSequentialListWrapper&lt;E&gt;(list, extractor);
 128     }
 129 
 130     /**
 131      * Constructs an ObservableMap that is backed by the specified map.
 132      * Mutation operations on the ObservableMap instance will be reported
 133      * to observers that have registered on that instance.&lt;br&gt;
 134      * Note that mutation operations made directly to the underlying map are &lt;em&gt;not&lt;/em&gt;
 135      * reported to observers of any ObservableMap that wraps it.
 136      * @param &lt;K&gt; the type of the wrapped key
 137      * @param &lt;V&gt; the type of the wrapped value
 138      * @param map a Map that backs this ObservableMap
 139      * @return a newly created ObservableMap
 140      */
 141     public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; observableMap(Map&lt;K, V&gt; map) {
 142         if (map == null) {
 143             throw new NullPointerException();
 144         }
 145         return new ObservableMapWrapper&lt;K, V&gt;(map);
 146     }
 147 
 148     /**
 149      * Constructs an ObservableSet that is backed by the specified set.
 150      * Mutation operations on the ObservableSet instance will be reported
 151      * to observers that have registered on that instance.&lt;br&gt;
 152      * Note that mutation operations made directly to the underlying set are &lt;em&gt;not&lt;/em&gt;
 153      * reported to observers of any ObservableSet that wraps it.
 154      * @param &lt;E&gt; The type of List to be wrapped
 155      * @param set a Set that backs this ObservableSet
 156      * @return a newly created ObservableSet
 157      * @since JavaFX 2.1
 158      */
 159     public static &lt;E&gt; ObservableSet&lt;E&gt; observableSet(Set&lt;E&gt; set) {
 160         if (set == null) {
 161             throw new NullPointerException();
 162         }
 163         return new ObservableSetWrapper&lt;E&gt;(set);
 164     }
 165 
 166     /**
 167      * Constructs an ObservableSet backed by a HashSet
 168      * that contains all the specified elements.
 169      * @param &lt;E&gt; The type of List to be wrapped
 170      * @param elements elements that will be added into returned ObservableSet
 171      * @return a newly created ObservableSet
 172      * @since JavaFX 2.1
 173      */
 174     public static &lt;E&gt; ObservableSet&lt;E&gt; observableSet(E... elements) {
 175         if (elements == null) {
 176             throw new NullPointerException();
 177         }
 178         Set&lt;E&gt; set = new HashSet&lt;E&gt;(elements.length);
 179         Collections.addAll(set, elements);
 180         return new ObservableSetWrapper&lt;E&gt;(set);
 181     }
 182 
 183     /**
 184      * Constructs a read-only interface to the specified ObservableMap. Only
 185      * mutation operations made to the underlying ObservableMap will be reported
 186      * to observers that have registered on the unmodifiable instance. This allows
 187      * clients to track changes in a Map but disallows the ability to modify it.
 188      * @param &lt;K&gt; the type of the wrapped key
 189      * @param &lt;V&gt; the type of the wrapped value
 190      * @param map an ObservableMap that is to be monitored by this interface
 191      * @return a newly created UnmodifiableObservableMap
 192      */
 193     public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; unmodifiableObservableMap(ObservableMap&lt;K, V&gt; map) {
 194         if (map == null) {
 195             throw new NullPointerException();
 196         }
 197         return new com.sun.javafx.collections.UnmodifiableObservableMap&lt;K, V&gt;(map);
 198     }
 199 
 200     /**
 201      * Creates and returns a typesafe wrapper on top of provided observable map.
 202      * @param &lt;K&gt; the type of the wrapped key
 203      * @param &lt;V&gt; the type of the wrapped value
 204      * @param map an Observable map to be wrapped
 205      * @param keyType the type of key that {@code map} is permitted to hold
 206      * @param valueType the type of value that {@code map} is permitted to hold
 207      * @return a dynamically typesafe view of the specified map
 208      * @see Collections#checkedMap(java.util.Map, java.lang.Class, java.lang.Class)
 209      * @since JavaFX 8.0
 210      */
 211     public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; checkedObservableMap(ObservableMap&lt;K, V&gt; map, Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) {
 212         if (map == null || keyType == null || valueType == null) {
 213             throw new NullPointerException();
 214         }
 215         return new CheckedObservableMap&lt;K, V&gt;(map, keyType, valueType);
 216     }
 217 
 218     /**
 219      * Creates and returns a synchronized wrapper on top of provided observable map.
 220      * @param &lt;K&gt; the type of the wrapped key
 221      * @param &lt;V&gt; the type of the wrapped value
 222      * @param  map the map to be &quot;wrapped&quot; in a synchronized map.
 223      * @return A synchronized version of the observable map
 224      * @see Collections#synchronizedMap(java.util.Map)
 225      * @since JavaFX 8.0
 226      */
 227     public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; synchronizedObservableMap(ObservableMap&lt;K, V&gt; map) {
 228         if (map == null) {
 229             throw new NullPointerException();
 230         }
 231         return new SynchronizedObservableMap&lt;K, V&gt;(map);
 232     }
 233 
 234     private static ObservableMap EMPTY_OBSERVABLE_MAP = new EmptyObservableMap();
 235 
 236     /**
 237      * Creates an empty unmodifiable observable map.
 238      * @param &lt;K&gt; the type of the wrapped key
 239      * @param &lt;V&gt; the type of the wrapped value
 240      * @return An empty unmodifiable observable map
 241      * @see Collections#emptyMap()
 242      * @since JavaFX 8.0
 243      */
 244     @SuppressWarnings(&quot;unchecked&quot;)
 245     public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; emptyObservableMap() {
 246         return EMPTY_OBSERVABLE_MAP;
 247     }
 248 
 249     /**
 250      * Creates a new empty observable integer array.
 251      * @return a newly created ObservableIntegerArray
 252      * @since JavaFX 8.0
 253      */
 254     public static ObservableIntegerArray observableIntegerArray() {
 255         return new ObservableIntegerArrayImpl();
 256     }
 257 
 258     /**
 259      * Creates a new observable integer array with {@code values} set to it.
 260      * @param values the values that will be in the new observable integer array
 261      * @return a newly created ObservableIntegerArray
 262      * @since JavaFX 8.0
 263      */
 264     public static ObservableIntegerArray observableIntegerArray(int... values) {
 265         return new ObservableIntegerArrayImpl(values);
 266     }
 267 
 268     /**
 269      * Creates a new observable integer array with copy of elements in given
 270      * {@code array}.
 271      * @param array observable integer array to copy
 272      * @return a newly created ObservableIntegerArray
 273      * @since JavaFX 8.0
 274      */
 275     public static ObservableIntegerArray observableIntegerArray(ObservableIntegerArray array) {
 276         return new ObservableIntegerArrayImpl(array);
 277     }
 278 
 279     /**
 280      * Creates a new empty observable float array.
 281      * @return a newly created ObservableFloatArray
 282      * @since JavaFX 8.0
 283      */
 284     public static ObservableFloatArray observableFloatArray() {
 285         return new ObservableFloatArrayImpl();
 286     }
 287 
 288     /**
 289      * Creates a new observable float array with {@code values} set to it.
 290      * @param values the values that will be in the new observable float array
 291      * @return a newly created ObservableFloatArray
 292      * @since JavaFX 8.0
 293      */
 294     public static ObservableFloatArray observableFloatArray(float... values) {
 295         return new ObservableFloatArrayImpl(values);
 296     }
 297 
 298     /**
 299      * Creates a new observable float array with copy of elements in given
 300      * {@code array}.
 301      * @param array observable float array to copy
 302      * @return a newly created ObservableFloatArray
 303      * @since JavaFX 8.0
 304      */
 305     public static ObservableFloatArray observableFloatArray(ObservableFloatArray array) {
 306         return new ObservableFloatArrayImpl(array);
 307     }
 308 
 309     /**
<a name="5" id="anc5"></a><span class="line-modified"> 310      * Creates a new empty observable list that is backed by an arraylist.</span>
 311      * @see #observableList(java.util.List)
 312      * @param &lt;E&gt; The type of List to be wrapped
 313      * @return a newly created ObservableList
 314      */
 315     @SuppressWarnings(&quot;unchecked&quot;)
 316     public static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList() {
 317         return observableList(new ArrayList());
 318     }
 319 
 320     /**
<a name="6" id="anc6"></a><span class="line-modified"> 321      * Creates a new empty observable list backed by an arraylist.</span>







 322      *
<a name="7" id="anc7"></a><span class="line-modified"> 323      * This list reports element updates.</span>
<span class="line-modified"> 324      * @param &lt;E&gt; The type of List to be wrapped</span>
<span class="line-modified"> 325      * @param extractor element to Observable[] convertor. Observable objects are listened for changes on the element.</span>
 326      * @see #observableList(java.util.List, javafx.util.Callback)
 327      * @since JavaFX 2.1
<a name="8" id="anc8"></a><span class="line-removed"> 328      * @return a newly created ObservableList</span>
 329      */
 330     public static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList(Callback&lt;E, Observable[]&gt; extractor) {
 331         return observableList(new ArrayList(), extractor);
 332     }
 333 
 334     /**
 335      * Creates a new observable array list with {@code items} added to it.
 336      * @param &lt;E&gt; The type of List to be wrapped
 337      * @param items the items that will be in the new observable ArrayList
 338      * @return a newly created observableArrayList
 339      * @see #observableArrayList()
 340      */
 341     public static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList(E... items) {
 342         ObservableList&lt;E&gt; list = observableArrayList();
 343         list.addAll(items);
 344         return list;
 345     }
 346 
 347     /**
 348      * Creates a new observable array list and adds a content of collection {@code col}
 349      * to it.
 350      * @param &lt;E&gt; The type of List to be wrapped
 351      * @param col a collection which content should be added to the observableArrayList
 352      * @return a newly created observableArrayList
 353      */
 354     public static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList(Collection&lt;? extends E&gt; col) {
 355         ObservableList&lt;E&gt; list = observableArrayList();
 356         list.addAll(col);
 357         return list;
 358     }
 359 
 360     /**
 361      * Creates a new empty observable map that is backed by a HashMap.
 362      * @param &lt;K&gt; the type of the wrapped key
 363      * @param &lt;V&gt; the type of the wrapped value
 364      * @return a newly created observable HashMap
 365      */
 366     public static &lt;K,V&gt; ObservableMap&lt;K,V&gt; observableHashMap() {
 367         return observableMap(new HashMap&lt;K, V&gt;());
 368     }
 369 
 370     /**
 371      * Concatenates more observable lists into one. The resulting list
<a name="9" id="anc9"></a><span class="line-modified"> 372      * would be backed by an arraylist.</span>
 373      * @param &lt;E&gt; The type of List to be wrapped
 374      * @param lists lists to concatenate
 375      * @return new observable array list concatenated from the arguments
 376      */
 377     public static &lt;E&gt; ObservableList&lt;E&gt; concat(ObservableList&lt;E&gt;... lists) {
 378         if (lists.length == 0 ) {
 379             return observableArrayList();
 380         }
 381         if (lists.length == 1) {
 382             return observableArrayList(lists[0]);
 383         }
 384         ArrayList&lt;E&gt; backingList = new ArrayList&lt;E&gt;();
 385         for (ObservableList&lt;E&gt; s : lists) {
 386             backingList.addAll(s);
 387         }
 388 
 389         return observableList(backingList);
 390     }
 391 
 392     /**
 393      * Creates and returns unmodifiable wrapper list on top of provided observable list.
 394      * @param list  an ObservableList that is to be wrapped
 395      * @param &lt;E&gt; The type of List to be wrapped
 396      * @return an ObserableList wrapper that is unmodifiable
 397      * @see Collections#unmodifiableList(java.util.List)
 398      */
 399     public static&lt;E&gt; ObservableList&lt;E&gt; unmodifiableObservableList(ObservableList&lt;E&gt; list) {
 400         if (list == null) {
 401             throw new NullPointerException();
 402         }
 403         return new UnmodifiableObservableListImpl&lt;E&gt;(list);
 404     }
 405 
 406     /**
 407      * Creates and returns a typesafe wrapper on top of provided observable list.
 408      * @param &lt;E&gt; The type of List to be wrapped
 409      * @param list  an Observable list to be wrapped
 410      * @param type   the type of element that {@code list} is permitted to hold
 411      * @return a dynamically typesafe view of the specified list
 412      * @see Collections#checkedList(java.util.List, java.lang.Class)
 413      */
 414     public static&lt;E&gt; ObservableList&lt;E&gt; checkedObservableList(ObservableList&lt;E&gt; list, Class&lt;E&gt; type) {
 415         if (list == null) {
 416             throw new NullPointerException();
 417         }
 418         return new CheckedObservableList&lt;E&gt;(list, type);
 419     }
 420 
 421     /**
 422      * Creates and returns a synchronized wrapper on top of provided observable list.
 423      * @param &lt;E&gt; The type of List to be wrapped
 424      * @param  list the list to be &quot;wrapped&quot; in a synchronized list.
 425      * @return A synchronized version of the observable list
 426      * @see Collections#synchronizedList(java.util.List)
 427      */
 428     public static&lt;E&gt; ObservableList&lt;E&gt; synchronizedObservableList(ObservableList&lt;E&gt; list) {
 429         if (list == null) {
 430             throw new NullPointerException();
 431         }
 432         return new SynchronizedObservableList&lt;E&gt;(list);
 433     }
 434 
 435     private static ObservableList EMPTY_OBSERVABLE_LIST = new EmptyObservableList();
 436 
 437 
 438     /**
 439      * Creates an empty unmodifiable observable list.
 440      * @param &lt;E&gt; The type of List to be wrapped
 441      * @return An empty unmodifiable observable list
 442      * @see Collections#emptyList()
 443      */
 444     @SuppressWarnings(&quot;unchecked&quot;)
 445     public static&lt;E&gt; ObservableList&lt;E&gt; emptyObservableList() {
 446         return EMPTY_OBSERVABLE_LIST;
 447     }
 448 
 449     /**
 450      * Creates an unmodifiable observable list with single element.
 451      * @param &lt;E&gt; The type of List to be wrapped
 452      * @param e the only elements that will be contained in this singleton observable list
 453      * @return a singleton observable list
 454      * @see Collections#singletonList(java.lang.Object)
 455      */
 456     public static&lt;E&gt; ObservableList&lt;E&gt; singletonObservableList(E e) {
 457         return new SingletonObservableList&lt;E&gt;(e);
 458     }
 459 
 460     /**
 461      * Creates and returns unmodifiable wrapper on top of provided observable set.
 462      * @param &lt;E&gt; The type of List to be wrapped
 463      * @param set an ObservableSet that is to be wrapped
 464      * @return an ObserableSet wrapper that is unmodifiable
 465      * @see Collections#unmodifiableSet(java.util.Set)
 466      * @since JavaFX 8.0
 467      */
 468     public static&lt;E&gt; ObservableSet&lt;E&gt; unmodifiableObservableSet(ObservableSet&lt;E&gt; set) {
 469         if (set == null) {
 470             throw new NullPointerException();
 471         }
 472         return new UnmodifiableObservableSet&lt;E&gt;(set);
 473     }
 474 
 475     /**
 476      * Creates and returns a typesafe wrapper on top of provided observable set.
 477      * @param &lt;E&gt; The type of List to be wrapped
 478      * @param set an Observable set to be wrapped
 479      * @param type  the type of element that {@code set} is permitted to hold
 480      * @return a dynamically typesafe view of the specified set
 481      * @see Collections#checkedSet(java.util.Set, java.lang.Class)
 482      * @since JavaFX 8.0
 483      */
 484     public static&lt;E&gt; ObservableSet&lt;E&gt; checkedObservableSet(ObservableSet&lt;E&gt; set, Class&lt;E&gt; type) {
 485         if (set == null) {
 486             throw new NullPointerException();
 487         }
 488         return new CheckedObservableSet&lt;E&gt;(set, type);
 489     }
 490 
 491     /**
 492      * Creates and returns a synchronized wrapper on top of provided observable set.
 493      * @param &lt;E&gt; The type of List to be wrapped
 494      * @param  set the set to be &quot;wrapped&quot; in a synchronized set.
 495      * @return A synchronized version of the observable set
 496      * @see Collections#synchronizedSet(java.util.Set)
 497      * @since JavaFX 8.0
 498      */
 499     public static&lt;E&gt; ObservableSet&lt;E&gt; synchronizedObservableSet(ObservableSet&lt;E&gt; set) {
 500         if (set == null) {
 501             throw new NullPointerException();
 502         }
 503         return new SynchronizedObservableSet&lt;E&gt;(set);
 504     }
 505 
 506     private static ObservableSet EMPTY_OBSERVABLE_SET = new EmptyObservableSet();
 507 
 508     /**
 509      * Creates an empty unmodifiable observable set.
 510      * @param &lt;E&gt; The type of List to be wrapped
 511      * @return An empty unmodifiable observable set
 512      * @see Collections#emptySet()
 513      * @since JavaFX 8.0
 514      */
 515     @SuppressWarnings(&quot;unchecked&quot;)
 516     public static&lt;E&gt; ObservableSet&lt;E&gt; emptyObservableSet() {
 517         return EMPTY_OBSERVABLE_SET;
 518     }
 519 
 520     /**
 521      * Copies elements from src to dest. Fires only &lt;b&gt;one&lt;/b&gt; change notification on dest.
 522      * @param &lt;T&gt; The type of List to be wrapped
 523      * @param dest the destination observable list
 524      * @param src the source list
 525      * @see Collections#copy(java.util.List, java.util.List)
 526      */
 527     @SuppressWarnings(&quot;unchecked&quot;)
 528     public static &lt;T&gt; void copy(ObservableList&lt;? super T&gt; dest, List&lt;? extends T&gt; src) {
 529         final int srcSize = src.size();
 530         if (srcSize &gt; dest.size()) {
 531             throw new IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;);
 532         }
 533         T[] destArray = (T[]) dest.toArray();
 534         System.arraycopy(src.toArray(), 0, destArray, 0, srcSize);
 535         dest.setAll(destArray);
 536     }
 537 
 538     /**
 539      * Fills the provided list with obj. Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 540      * @param &lt;T&gt; The type of List to be wrapped
 541      * @param list the list to fill
 542      * @param obj the object to fill the list with
 543      * @see Collections#fill(java.util.List, java.lang.Object)
 544      */
 545     @SuppressWarnings(&quot;unchecked&quot;)
 546     public static &lt;T&gt; void fill(ObservableList&lt;? super T&gt; list, T obj) {
 547         T[] newContent = (T[]) new Object[list.size()];
 548         Arrays.fill(newContent, obj);
 549         list.setAll(newContent);
 550     }
 551 
 552     /**
 553      * Replace all oldVal elements in the list with newVal element.
 554      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 555      * @param &lt;T&gt; The type of List to be wrapped
 556      * @param list the list which will have it&#39;s elements replaced
 557      * @param oldVal the element that is going to be replace
 558      * @param newVal the replacement
 559      * @return true if the list was modified
 560      * @see Collections#replaceAll(java.util.List, java.lang.Object, java.lang.Object)
 561      */
 562     @SuppressWarnings(&quot;unchecked&quot;)
 563     public static &lt;T&gt; boolean replaceAll(ObservableList&lt;T&gt; list, T oldVal, T newVal) {
 564         T[] newContent = (T[]) list.toArray();
 565         boolean modified = false;
 566         for (int i = 0 ; i &lt; newContent.length; ++i) {
 567             if (newContent[i].equals(oldVal)) {
 568                 newContent[i] = newVal;
 569                 modified = true;
 570             }
 571         }
 572         if (modified) {
 573             list.setAll(newContent);
 574         }
 575         return modified;
 576     }
 577 
 578     /**
 579      * Reverses the order in the list.
 580      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 581      * @param list the list to be reversed
 582      * @see Collections#reverse(java.util.List)
 583      */
 584     @SuppressWarnings(&quot;unchecked&quot;)
 585     public static void reverse(ObservableList list) {
 586         Object[] newContent = list.toArray();
 587         for (int i = 0; i &lt; newContent.length / 2; ++i) {
 588             Object tmp = newContent[i];
 589             newContent[i] = newContent[newContent.length - i - 1];
 590             newContent[newContent.length -i - 1] = tmp;
 591         }
 592         list.setAll(newContent);
 593     }
 594 
 595     /**
 596      * Rotates the list by distance.
 597      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 598      * @param list the list to be rotated
 599      * @param distance the distance of rotation
 600      * @see Collections#rotate(java.util.List, int)
 601      */
 602     @SuppressWarnings(&quot;unchecked&quot;)
 603     public static void rotate(ObservableList list, int distance) {
 604         Object[] newContent = list.toArray();
 605 
 606         int size = list.size();
 607         distance = distance % size;
 608         if (distance &lt; 0)
 609             distance += size;
 610         if (distance == 0)
 611             return;
 612 
 613         for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) {
 614             Object displaced = newContent[cycleStart];
 615             Object tmp;
 616             int i = cycleStart;
 617             do {
 618                 i += distance;
 619                 if (i &gt;= size)
 620                     i -= size;
 621                 tmp = newContent[i];
 622                 newContent[i] = displaced;
 623                 displaced = tmp;
 624                 nMoved ++;
 625             } while(i != cycleStart);
 626         }
 627         list.setAll(newContent);
 628     }
 629 
 630     /**
 631      * Shuffles all elements in the observable list.
 632      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 633      * @param list the list to shuffle
 634      * @see Collections#shuffle(java.util.List)
 635      */
 636     public static void shuffle(ObservableList&lt;?&gt; list) {
 637         if (r == null) {
 638             r = new Random();
 639         }
 640         shuffle(list, r);
 641     }
 642     private static Random r;
 643 
 644     /**
 645      * Shuffles all elements in the observable list.
 646      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 647      * @param list the list to be shuffled
 648      * @param rnd the random generator used for shuffling
 649      * @see Collections#shuffle(java.util.List, java.util.Random)
 650      */
 651     @SuppressWarnings(&quot;unchecked&quot;)
 652     public static void shuffle(ObservableList list, Random rnd) {
 653         Object newContent[] = list.toArray();
 654 
 655         for (int i = list.size(); i &gt; 1; i--) {
 656             swap(newContent, i - 1, rnd.nextInt(i));
 657         }
 658 
 659         list.setAll(newContent);
 660     }
 661 
 662     private static void swap(Object[] arr, int i, int j) {
 663         Object tmp = arr[i];
 664         arr[i] = arr[j];
 665         arr[j] = tmp;
 666     }
 667 
 668     /**
 669      * Sorts the provided observable list.
 670      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 671      * @param &lt;T&gt; The type of List to be wrapped
 672      * @param list the list to be sorted
 673      * @see Collections#sort(java.util.List)
 674      */
 675     @SuppressWarnings(&quot;unchecked&quot;)
 676     public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(ObservableList&lt;T&gt; list) {
 677         if (list instanceof SortableList) {
 678             ((SortableList&lt;? extends T&gt;)list).sort();
 679         } else {
 680             List&lt;T&gt; newContent = new ArrayList&lt;T&gt;(list);
 681             Collections.sort(newContent);
 682             list.setAll((Collection&lt;T&gt;)newContent);
 683         }
 684     }
 685 
 686     /**
 687      * Sorts the provided observable list using the c comparator.
 688      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 689      * @param &lt;T&gt; The type of List to be wrapped
 690      * @param list the list to sort
 691      * @param c comparator used for sorting. Null if natural ordering is required.
 692      * @see Collections#sort(java.util.List, java.util.Comparator)
 693      */
 694     @SuppressWarnings(&quot;unchecked&quot;)
 695     public static &lt;T&gt; void sort(ObservableList&lt;T&gt; list, Comparator&lt;? super T&gt; c) {
 696         if (list instanceof SortableList) {
 697             ((SortableList&lt;? extends T&gt;)list).sort(c);
 698         } else {
 699             List&lt;T&gt; newContent = new ArrayList&lt;T&gt;(list);
 700             Collections.sort(newContent, c);
 701             list.setAll((Collection&lt;T&gt;)newContent);
 702         }
 703     }
 704 
 705     private static class EmptyObservableList&lt;E&gt; extends AbstractList&lt;E&gt; implements ObservableList&lt;E&gt; {
 706 
 707         private static final ListIterator iterator = new ListIterator() {
 708 
 709             @Override
 710             public boolean hasNext() {
 711                 return false;
 712             }
 713 
 714             @Override
 715             public Object next() {
 716                 throw new NoSuchElementException();
 717             }
 718 
 719             @Override
 720             public void remove() {
 721                 throw new UnsupportedOperationException();
 722             }
 723 
 724             @Override
 725             public boolean hasPrevious() {
 726                 return false;
 727             }
 728 
 729             @Override
 730             public Object previous() {
 731                 throw new NoSuchElementException();
 732             }
 733 
 734             @Override
 735             public int nextIndex() {
 736                 return 0;
 737             }
 738 
 739             @Override
 740             public int previousIndex() {
 741                 return -1;
 742             }
 743 
 744             @Override
 745             public void set(Object e) {
 746                 throw new UnsupportedOperationException();
 747             }
 748 
 749             @Override
 750             public void add(Object e) {
 751                 throw new UnsupportedOperationException();
 752             }
 753         };
 754 
 755         public EmptyObservableList() {
 756         }
 757 
 758         @Override
 759         public final void addListener(InvalidationListener listener) {
 760         }
 761 
 762         @Override
 763         public final void removeListener(InvalidationListener listener) {
 764         }
 765 
 766 
 767         @Override
 768         public void addListener(ListChangeListener&lt;? super E&gt; o) {
 769         }
 770 
 771         @Override
 772         public void removeListener(ListChangeListener&lt;? super E&gt; o) {
 773         }
 774 
 775         @Override
 776         public int size() {
 777             return 0;
 778         }
 779 
 780         @Override
 781         public boolean contains(Object o) {
 782             return false;
 783         }
 784 
 785         @Override
 786         @SuppressWarnings(&quot;unchecked&quot;)
 787         public Iterator&lt;E&gt; iterator() {
 788             return iterator;
 789         }
 790 
 791         @Override
 792         public boolean containsAll(Collection&lt;?&gt; c) {
 793             return c.isEmpty();
 794         }
 795 
 796         @Override
 797         public E get(int index) {
 798             throw new IndexOutOfBoundsException();
 799         }
 800 
 801         @Override
 802         public int indexOf(Object o) {
 803             return -1;
 804         }
 805 
 806         @Override
 807         public int lastIndexOf(Object o) {
 808             return -1;
 809         }
 810 
 811         @Override
 812         @SuppressWarnings(&quot;unchecked&quot;)
 813         public ListIterator&lt;E&gt; listIterator() {
 814             return iterator;
 815         }
 816 
 817         @Override
 818         @SuppressWarnings(&quot;unchecked&quot;)
 819         public ListIterator&lt;E&gt; listIterator(int index) {
 820             if (index != 0) {
 821                 throw new IndexOutOfBoundsException();
 822             }
 823             return iterator;
 824         }
 825 
 826         @Override
 827         public List&lt;E&gt; subList(int fromIndex, int toIndex) {
 828             if (fromIndex != 0 || toIndex != 0) {
 829                 throw new IndexOutOfBoundsException();
 830             }
 831             return this;
 832         }
 833 
 834         @Override
 835         public boolean addAll(E... elements) {
 836             throw new UnsupportedOperationException();
 837         }
 838 
 839         @Override
 840         public boolean setAll(E... elements) {
 841             throw new UnsupportedOperationException();
 842         }
 843 
 844         @Override
 845         public boolean setAll(Collection&lt;? extends E&gt; col) {
 846             throw new UnsupportedOperationException();
 847         }
 848 
 849         @Override
 850         public boolean removeAll(E... elements) {
 851             throw new UnsupportedOperationException();
 852         }
 853 
 854         @Override
 855         public boolean retainAll(E... elements) {
 856             throw new UnsupportedOperationException();
 857         }
 858 
 859         @Override
 860         public void remove(int from, int to) {
 861             throw new UnsupportedOperationException();
 862         }
 863     }
 864 
 865     private static class SingletonObservableList&lt;E&gt; extends AbstractList&lt;E&gt; implements ObservableList&lt;E&gt; {
 866 
 867         private final E element;
 868 
 869         public SingletonObservableList(E element) {
 870             if (element == null) {
 871                 throw new NullPointerException();
 872             }
 873             this.element = element;
 874         }
 875 
 876         @Override
 877         public boolean addAll(E... elements) {
 878             throw new UnsupportedOperationException();
 879         }
 880 
 881         @Override
 882         public boolean setAll(E... elements) {
 883             throw new UnsupportedOperationException();
 884         }
 885 
 886         @Override
 887         public boolean setAll(Collection&lt;? extends E&gt; col) {
 888             throw new UnsupportedOperationException();
 889         }
 890 
 891         @Override
 892         public boolean removeAll(E... elements) {
 893             throw new UnsupportedOperationException();
 894         }
 895 
 896         @Override
 897         public boolean retainAll(E... elements) {
 898             throw new UnsupportedOperationException();
 899         }
 900 
 901         @Override
 902         public void remove(int from, int to) {
 903             throw new UnsupportedOperationException();
 904         }
 905 
 906         @Override
 907         public void addListener(InvalidationListener listener) {
 908         }
 909 
 910         @Override
 911         public void removeListener(InvalidationListener listener) {
 912         }
 913 
 914         @Override
 915         public void addListener(ListChangeListener&lt;? super E&gt; o) {
 916         }
 917 
 918         @Override
 919         public void removeListener(ListChangeListener&lt;? super E&gt; o) {
 920         }
 921 
 922         @Override
 923         public int size() {
 924             return 1;
 925         }
 926 
 927         @Override
 928         public boolean isEmpty() {
 929             return false;
 930         }
 931 
 932         @Override
 933         public boolean contains(Object o) {
 934             return element.equals(o);
 935         }
 936 
 937         @Override
 938         public E get(int index) {
 939             if (index != 0) {
 940                 throw new IndexOutOfBoundsException();
 941             }
 942             return element;
 943         }
 944 
 945     }
 946 
 947     private static class UnmodifiableObservableListImpl&lt;T&gt; extends ObservableListBase&lt;T&gt; implements ObservableList&lt;T&gt; {
 948 
 949         private final ObservableList&lt;T&gt; backingList;
 950         private final ListChangeListener&lt;T&gt; listener;
 951 
 952         public UnmodifiableObservableListImpl(ObservableList&lt;T&gt; backingList) {
 953             this.backingList = backingList;
 954             listener = c -&gt; {
 955                 fireChange(new SourceAdapterChange&lt;T&gt;(UnmodifiableObservableListImpl.this, c));
 956             };
 957             this.backingList.addListener(new WeakListChangeListener&lt;T&gt;(listener));
 958         }
 959 
 960         @Override
 961         public T get(int index) {
 962             return backingList.get(index);
 963         }
 964 
 965         @Override
 966         public int size() {
 967             return backingList.size();
 968         }
 969 
 970         @Override
 971         public boolean addAll(T... elements) {
 972             throw new UnsupportedOperationException();
 973         }
 974 
 975         @Override
 976         public boolean setAll(T... elements) {
 977             throw new UnsupportedOperationException();
 978         }
 979 
 980         @Override
 981         public boolean setAll(Collection&lt;? extends T&gt; col) {
 982             throw new UnsupportedOperationException();
 983         }
 984 
 985         @Override
 986         public boolean removeAll(T... elements) {
 987             throw new UnsupportedOperationException();
 988         }
 989 
 990         @Override
 991         public boolean retainAll(T... elements) {
 992             throw new UnsupportedOperationException();
 993         }
 994 
 995         @Override
 996         public void remove(int from, int to) {
 997             throw new UnsupportedOperationException();
 998         }
 999 
1000     }
1001 
1002     private static class SynchronizedList&lt;T&gt; implements List&lt;T&gt; {
1003         final Object mutex;
1004         private final List&lt;T&gt; backingList;
1005 
1006         SynchronizedList(List&lt;T&gt; list, Object mutex) {
1007             this.backingList = list;
1008             this.mutex = mutex;
1009         }
1010 
1011         SynchronizedList(List&lt;T&gt; list) {
1012             this.backingList = list;
1013             this.mutex = this;
1014         }
1015 
1016         @Override
1017         public int size() {
1018             synchronized(mutex) {
1019                 return backingList.size();
1020             }
1021         }
1022 
1023         @Override
1024         public boolean isEmpty() {
1025             synchronized(mutex) {
1026                 return backingList.isEmpty();
1027             }
1028         }
1029 
1030         @Override
1031         public boolean contains(Object o) {
1032             synchronized(mutex) {
1033                 return backingList.contains(o);
1034             }
1035         }
1036 
1037         @Override
1038         public Iterator&lt;T&gt; iterator() {
1039             return backingList.iterator();
1040         }
1041 
1042         @Override
1043         public Object[] toArray() {
1044             synchronized(mutex)  {
1045                 return backingList.toArray();
1046             }
1047         }
1048 
1049         @Override
1050         public &lt;T&gt; T[] toArray(T[] a) {
1051             synchronized(mutex) {
1052                 return backingList.toArray(a);
1053             }
1054         }
1055 
1056         @Override
1057         public boolean add(T e) {
1058             synchronized(mutex) {
1059                 return backingList.add(e);
1060             }
1061         }
1062 
1063         @Override
1064         public boolean remove(Object o) {
1065             synchronized(mutex) {
1066                 return backingList.remove(o);
1067             }
1068         }
1069 
1070         @Override
1071         public boolean containsAll(Collection&lt;?&gt; c) {
1072             synchronized(mutex) {
1073                 return backingList.containsAll(c);
1074             }
1075         }
1076 
1077         @Override
1078         public boolean addAll(Collection&lt;? extends T&gt; c) {
1079             synchronized(mutex) {
1080                 return backingList.addAll(c);
1081             }
1082         }
1083 
1084         @Override
1085         public boolean addAll(int index, Collection&lt;? extends T&gt; c) {
1086             synchronized(mutex) {
1087                 return backingList.addAll(index, c);
1088 
1089             }
1090         }
1091 
1092         @Override
1093         public boolean removeAll(Collection&lt;?&gt; c) {
1094             synchronized(mutex) {
1095                 return backingList.removeAll(c);
1096             }
1097         }
1098 
1099         @Override
1100         public boolean retainAll(Collection&lt;?&gt; c) {
1101             synchronized(mutex) {
1102                 return backingList.retainAll(c);
1103             }
1104         }
1105 
1106         @Override
1107         public void clear() {
1108             synchronized(mutex) {
1109                 backingList.clear();
1110             }
1111         }
1112 
1113         @Override
1114         public T get(int index) {
1115             synchronized(mutex) {
1116                 return backingList.get(index);
1117             }
1118         }
1119 
1120         @Override
1121         public T set(int index, T element) {
1122             synchronized(mutex) {
1123                 return backingList.set(index, element);
1124             }
1125         }
1126 
1127         @Override
1128         public void add(int index, T element) {
1129             synchronized(mutex) {
1130                 backingList.add(index, element);
1131             }
1132         }
1133 
1134         @Override
1135         public T remove(int index) {
1136             synchronized(mutex) {
1137                 return backingList.remove(index);
1138             }
1139         }
1140 
1141         @Override
1142         public int indexOf(Object o) {
1143             synchronized(mutex) {
1144                 return backingList.indexOf(o);
1145             }
1146         }
1147 
1148         @Override
1149         public int lastIndexOf(Object o) {
1150             synchronized(mutex) {
1151                 return backingList.lastIndexOf(o);
1152             }
1153         }
1154 
1155         @Override
1156         public ListIterator&lt;T&gt; listIterator() {
1157             return backingList.listIterator();
1158         }
1159 
1160         @Override
1161         public ListIterator&lt;T&gt; listIterator(int index) {
1162             synchronized(mutex) {
1163                 return backingList.listIterator(index);
1164             }
1165         }
1166 
1167         @Override
1168         public List&lt;T&gt; subList(int fromIndex, int toIndex) {
1169             synchronized(mutex) {
1170                 return new SynchronizedList&lt;T&gt;(backingList.subList(fromIndex, toIndex),
1171                         mutex);
1172             }
1173         }
1174 
1175         @Override
1176         public String toString() {
1177             synchronized(mutex) {
1178                 return backingList.toString();
1179             }
1180         }
1181 
1182         @Override
1183         public int hashCode() {
1184             synchronized(mutex) {
1185                 return backingList.hashCode();
1186             }
1187         }
1188 
1189         @Override
1190         public boolean equals(Object o) {
1191             synchronized(mutex) {
1192                 return backingList.equals(o);
1193             }
1194         }
1195 
1196     }
1197 
1198     private static class SynchronizedObservableList&lt;T&gt; extends SynchronizedList&lt;T&gt; implements ObservableList&lt;T&gt; {
1199 
1200         private ListListenerHelper helper;
1201 
1202         private final ObservableList&lt;T&gt; backingList;
1203         private final ListChangeListener&lt;T&gt; listener;
1204 
1205         SynchronizedObservableList(ObservableList&lt;T&gt; seq) {
1206             super(seq);
1207             this.backingList = seq;
1208             listener = c -&gt; {
1209                 ListListenerHelper.fireValueChangedEvent(helper, new SourceAdapterChange&lt;T&gt;(SynchronizedObservableList.this, c));
1210             };
1211             backingList.addListener(new WeakListChangeListener&lt;T&gt;(listener));
1212         }
1213 
1214         @Override
1215         public boolean addAll(T... elements) {
1216             synchronized(mutex) {
1217                 return backingList.addAll(elements);
1218             }
1219         }
1220 
1221         @Override
1222         public boolean setAll(T... elements) {
1223             synchronized(mutex) {
1224                 return backingList.setAll(elements);
1225             }
1226         }
1227 
1228         @Override
1229         public boolean removeAll(T... elements) {
1230             synchronized(mutex) {
1231                 return backingList.removeAll(elements);
1232             }
1233         }
1234 
1235         @Override
1236         public boolean retainAll(T... elements) {
1237             synchronized(mutex) {
1238                 return backingList.retainAll(elements);
1239             }
1240         }
1241 
1242         @Override
1243         public void remove(int from, int to) {
1244             synchronized(mutex) {
1245                 backingList.remove(from, to);
1246             }
1247         }
1248 
1249         @Override
1250         public boolean setAll(Collection&lt;? extends T&gt; col) {
1251             synchronized(mutex) {
1252                 return backingList.setAll(col);
1253             }
1254         }
1255 
1256         @Override
1257         public final void addListener(InvalidationListener listener) {
1258             synchronized (mutex) {
1259                 helper = ListListenerHelper.addListener(helper, listener);
1260             }
1261         }
1262 
1263         @Override
1264         public final void removeListener(InvalidationListener listener) {
1265             synchronized (mutex) {
1266                 helper = ListListenerHelper.removeListener(helper, listener);
1267             }
1268         }
1269 
1270         @Override
1271         public void addListener(ListChangeListener&lt;? super T&gt; listener) {
1272             synchronized (mutex) {
1273                 helper = ListListenerHelper.addListener(helper, listener);
1274             }
1275         }
1276 
1277         @Override
1278         public void removeListener(ListChangeListener&lt;? super T&gt; listener) {
1279             synchronized (mutex) {
1280                 helper = ListListenerHelper.removeListener(helper, listener);
1281             }
1282         }
1283 
1284 
1285     }
1286 
1287     private static class CheckedObservableList&lt;T&gt; extends ObservableListBase&lt;T&gt; implements ObservableList&lt;T&gt; {
1288 
1289         private final ObservableList&lt;T&gt; list;
1290         private final Class&lt;T&gt; type;
1291         private final ListChangeListener&lt;T&gt; listener;
1292 
1293         CheckedObservableList(ObservableList&lt;T&gt; list, Class&lt;T&gt; type) {
1294             if (list == null || type == null) {
1295                 throw new NullPointerException();
1296             }
1297             this.list = list;
1298             this.type = type;
1299             listener = c -&gt; {
1300                 fireChange(new SourceAdapterChange&lt;T&gt;(CheckedObservableList.this, c));
1301             };
1302             list.addListener(new WeakListChangeListener&lt;T&gt;(listener));
1303         }
1304 
1305         void typeCheck(Object o) {
1306             if (o != null &amp;&amp; !type.isInstance(o)) {
1307                 throw new ClassCastException(&quot;Attempt to insert &quot;
1308                         + o.getClass() + &quot; element into collection with element type &quot;
1309                         + type);
1310             }
1311         }
1312 
1313         @Override
1314         public int size() {
1315             return list.size();
1316         }
1317 
1318         @Override
1319         public boolean isEmpty() {
1320             return list.isEmpty();
1321         }
1322 
1323         @Override
1324         public boolean contains(Object o) {
1325             return list.contains(o);
1326         }
1327 
1328         @Override
1329         public Object[] toArray() {
1330             return list.toArray();
1331         }
1332 
1333         @Override
1334         public &lt;T&gt; T[] toArray(T[] a) {
1335             return list.toArray(a);
1336         }
1337 
1338         @Override
1339         public String toString() {
1340             return list.toString();
1341         }
1342 
1343         @Override
1344         public boolean remove(Object o) {
1345             return list.remove(o);
1346         }
1347 
1348         @Override
1349         public boolean containsAll(Collection&lt;?&gt; coll) {
1350             return list.containsAll(coll);
1351         }
1352 
1353         @Override
1354         public boolean removeAll(Collection&lt;?&gt; coll) {
1355             return list.removeAll(coll);
1356         }
1357 
1358         @Override
1359         public boolean retainAll(Collection&lt;?&gt; coll) {
1360             return list.retainAll(coll);
1361         }
1362 
1363         @Override
1364         public boolean removeAll(T... elements) {
1365             return list.removeAll(elements);
1366         }
1367 
1368         @Override
1369         public boolean retainAll(T... elements) {
1370             return list.retainAll(elements);
1371         }
1372 
1373         @Override
1374         public void remove(int from, int to) {
1375             list.remove(from, to);
1376         }
1377 
1378         @Override
1379         public void clear() {
1380             list.clear();
1381         }
1382 
1383         @Override
1384         public boolean equals(Object o) {
1385             return o == this || list.equals(o);
1386         }
1387 
1388         @Override
1389         public int hashCode() {
1390             return list.hashCode();
1391         }
1392 
1393         @Override
1394         public T get(int index) {
1395             return list.get(index);
1396         }
1397 
1398         @Override
1399         public T remove(int index) {
1400             return list.remove(index);
1401         }
1402 
1403         @Override
1404         public int indexOf(Object o) {
1405             return list.indexOf(o);
1406         }
1407 
1408         @Override
1409         public int lastIndexOf(Object o) {
1410             return list.lastIndexOf(o);
1411         }
1412 
1413         @Override
1414         public T set(int index, T element) {
1415             typeCheck(element);
1416             return list.set(index, element);
1417         }
1418 
1419         @Override
1420         public void add(int index, T element) {
1421             typeCheck(element);
1422             list.add(index, element);
1423         }
1424 
1425         @Override
1426         @SuppressWarnings(&quot;unchecked&quot;)
1427         public boolean addAll(int index, Collection&lt;? extends T&gt; c) {
1428             T[] a = null;
1429             try {
1430                 a = c.toArray((T[]) Array.newInstance(type, 0));
1431             } catch (ArrayStoreException e) {
1432                 throw new ClassCastException();
1433             }
1434 
1435             return this.list.addAll(index, Arrays.asList(a));
1436         }
1437 
1438         @Override
1439         @SuppressWarnings(&quot;unchecked&quot;)
1440         public boolean addAll(Collection&lt;? extends T&gt; coll) {
1441             T[] a = null;
1442             try {
1443                 a = coll.toArray((T[]) Array.newInstance(type, 0));
1444             } catch (ArrayStoreException e) {
1445                 throw new ClassCastException();
1446             }
1447 
1448             return this.list.addAll(Arrays.asList(a));
1449         }
1450 
1451         @Override
1452         public ListIterator&lt;T&gt; listIterator() {
1453             return listIterator(0);
1454         }
1455 
1456         @Override
1457         public ListIterator&lt;T&gt; listIterator(final int index) {
1458             return new ListIterator&lt;T&gt;() {
1459 
1460                 ListIterator&lt;T&gt; i = list.listIterator(index);
1461 
1462                 @Override
1463                 public boolean hasNext() {
1464                     return i.hasNext();
1465                 }
1466 
1467                 @Override
1468                 public T next() {
1469                     return i.next();
1470                 }
1471 
1472                 @Override
1473                 public boolean hasPrevious() {
1474                     return i.hasPrevious();
1475                 }
1476 
1477                 @Override
1478                 public T previous() {
1479                     return i.previous();
1480                 }
1481 
1482                 @Override
1483                 public int nextIndex() {
1484                     return i.nextIndex();
1485                 }
1486 
1487                 @Override
1488                 public int previousIndex() {
1489                     return i.previousIndex();
1490                 }
1491 
1492                 @Override
1493                 public void remove() {
1494                     i.remove();
1495                 }
1496 
1497                 @Override
1498                 public void set(T e) {
1499                     typeCheck(e);
1500                     i.set(e);
1501                 }
1502 
1503                 @Override
1504                 public void add(T e) {
1505                     typeCheck(e);
1506                     i.add(e);
1507                 }
1508             };
1509         }
1510 
1511         @Override
1512         public Iterator&lt;T&gt; iterator() {
1513             return new Iterator&lt;T&gt;() {
1514 
1515                 private final Iterator&lt;T&gt; it = list.iterator();
1516 
1517                 @Override
1518                 public boolean hasNext() {
1519                     return it.hasNext();
1520                 }
1521 
1522                 @Override
1523                 public T next() {
1524                     return it.next();
1525                 }
1526 
1527                 @Override
1528                 public void remove() {
1529                     it.remove();
1530                 }
1531             };
1532         }
1533 
1534         @Override
1535         public boolean add(T e) {
1536             typeCheck(e);
1537             return list.add(e);
1538         }
1539 
1540         @Override
1541         public List&lt;T&gt; subList(int fromIndex, int toIndex) {
1542             return Collections.checkedList(list.subList(fromIndex, toIndex), type);
1543         }
1544 
1545         @Override
1546         @SuppressWarnings(&quot;unchecked&quot;)
1547         public boolean addAll(T... elements) {
1548             try {
1549                 T[] array = (T[]) Array.newInstance(type, elements.length);
1550                 System.arraycopy(elements, 0, array, 0, elements.length);
1551                 return list.addAll(array);
1552             } catch (ArrayStoreException e) {
1553                 throw new ClassCastException();
1554             }
1555         }
1556 
1557         @Override
1558         @SuppressWarnings(&quot;unchecked&quot;)
1559         public boolean setAll(T... elements) {
1560             try {
1561                 T[] array = (T[]) Array.newInstance(type, elements.length);
1562                 System.arraycopy(elements, 0, array, 0, elements.length);
1563                 return list.setAll(array);
1564             } catch (ArrayStoreException e) {
1565                 throw new ClassCastException();
1566             }
1567         }
1568 
1569         @Override
1570         @SuppressWarnings(&quot;unchecked&quot;)
1571         public boolean setAll(Collection&lt;? extends T&gt; col) {
1572             T[] a = null;
1573             try {
1574                 a = col.toArray((T[]) Array.newInstance(type, 0));
1575             } catch (ArrayStoreException e) {
1576                 throw new ClassCastException();
1577             }
1578 
1579             return list.setAll(Arrays.asList(a));
1580         }
1581     }
1582 
1583     private static class EmptyObservableSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements ObservableSet&lt;E&gt; {
1584 
1585         public EmptyObservableSet() {
1586         }
1587 
1588         @Override
1589         public void addListener(InvalidationListener listener) {
1590         }
1591 
1592         @Override
1593         public void removeListener(InvalidationListener listener) {
1594         }
1595 
1596         @Override
1597         public void addListener(SetChangeListener&lt;? super E&gt; listener) {
1598         }
1599 
1600         @Override
1601         public void removeListener(SetChangeListener&lt;? super E&gt; listener) {
1602         }
1603 
1604         @Override
1605         public int size() {
1606             return 0;
1607         }
1608 
1609         @Override
1610         public boolean isEmpty() {
1611             return true;
1612         }
1613 
1614         @Override
1615         public boolean contains(Object obj) {
1616             return false;
1617         }
1618 
1619         @Override
1620         public boolean containsAll(Collection&lt;?&gt; c) {
1621             return c.isEmpty();
1622         }
1623 
1624         @Override
1625         public Object[] toArray() {
1626             return new Object[0];
1627         }
1628 
1629         @Override
1630         public &lt;E&gt; E[] toArray(E[] a) {
1631             if (a.length &gt; 0)
1632                 a[0] = null;
1633             return a;
1634         }
1635 
1636         @Override
1637         public Iterator&lt;E&gt; iterator() {
1638             return new Iterator() {
1639 
1640                 @Override
1641                 public boolean hasNext() {
1642                     return false;
1643                 }
1644 
1645                 @Override
1646                 public Object next() {
1647                     throw new NoSuchElementException();
1648                 }
1649 
1650                 @Override
1651                 public void remove() {
1652                     throw new UnsupportedOperationException();
1653                 }
1654             };
1655         }
1656 
1657     }
1658 
1659     private static class UnmodifiableObservableSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements ObservableSet&lt;E&gt; {
1660 
1661         private final ObservableSet&lt;E&gt; backingSet;
1662         private SetListenerHelper&lt;E&gt; listenerHelper;
1663         private SetChangeListener&lt;E&gt; listener;
1664 
1665         public UnmodifiableObservableSet(ObservableSet&lt;E&gt; backingSet) {
1666             this.backingSet = backingSet;
1667             this.listener = null;
1668         }
1669 
1670         private void initListener() {
1671             if (listener == null) {
1672                 listener = c -&gt; {
1673                     callObservers(new SetAdapterChange&lt;E&gt;(UnmodifiableObservableSet.this, c));
1674                 };
1675                 this.backingSet.addListener(new WeakSetChangeListener&lt;E&gt;(listener));
1676             }
1677         }
1678 
1679         private void callObservers(SetChangeListener.Change&lt;? extends E&gt; change) {
1680             SetListenerHelper.fireValueChangedEvent(listenerHelper, change);
1681         }
1682 
1683         @Override
1684         public Iterator&lt;E&gt; iterator() {
1685             return new Iterator&lt;E&gt;() {
1686                 private final Iterator&lt;? extends E&gt; i = backingSet.iterator();
1687 
1688                 @Override
1689                 public boolean hasNext() {
1690                     return i.hasNext();
1691                 }
1692 
1693                 @Override
1694                 public E next() {
1695                     return i.next();
1696                 }
1697             };
1698         }
1699 
1700         @Override
1701         public int size() {
1702             return backingSet.size();
1703         }
1704 
1705         @Override
1706         public boolean isEmpty() {
1707             return backingSet.isEmpty();
1708         }
1709 
1710         @Override
1711         public boolean contains(Object o) {
1712             return backingSet.contains(o);
1713         }
1714 
1715         @Override
1716         public void addListener(InvalidationListener listener) {
1717             initListener();
1718             listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1719         }
1720 
1721         @Override
1722         public void removeListener(InvalidationListener listener) {
1723             listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1724         }
1725 
1726         @Override
1727         public void addListener(SetChangeListener&lt;? super E&gt; listener) {
1728             initListener();
1729             listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1730         }
1731 
1732         @Override
1733         public void removeListener(SetChangeListener&lt;? super E&gt; listener) {
1734             listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1735         }
1736 
1737         @Override
1738         public boolean add(E e) {
1739             throw new UnsupportedOperationException();
1740         }
1741 
1742         @Override
1743         public boolean remove(Object o) {
1744             throw new UnsupportedOperationException();
1745         }
1746 
1747         @Override
1748         public boolean addAll(Collection&lt;? extends E&gt; c) {
1749             throw new UnsupportedOperationException();
1750         }
1751 
1752         @Override
1753         public boolean retainAll(Collection&lt;?&gt; c) {
1754             throw new UnsupportedOperationException();
1755         }
1756 
1757         @Override
1758         public boolean removeAll(Collection&lt;?&gt; c) {
1759             throw new UnsupportedOperationException();
1760         }
1761 
1762         @Override
1763         public void clear() {
1764             throw new UnsupportedOperationException();
1765         }
1766     }
1767 
1768     private static class SynchronizedSet&lt;E&gt; implements Set&lt;E&gt; {
1769         final Object mutex;
1770         private final Set&lt;E&gt; backingSet;
1771 
1772         SynchronizedSet(Set&lt;E&gt; set, Object mutex) {
1773             this.backingSet = set;
1774             this.mutex = mutex;
1775         }
1776 
1777         SynchronizedSet(Set&lt;E&gt; set) {
1778             this.backingSet = set;
1779             this.mutex = this;
1780         }
1781 
1782         @Override
1783         public int size() {
1784             synchronized(mutex) {
1785                 return backingSet.size();
1786             }
1787         }
1788 
1789         @Override
1790         public boolean isEmpty() {
1791             synchronized(mutex) {
1792                 return backingSet.isEmpty();
1793             }
1794         }
1795 
1796         @Override
1797         public boolean contains(Object o) {
1798             synchronized(mutex) {
1799                 return backingSet.contains(o);
1800             }
1801         }
1802 
1803         @Override
1804         public Iterator&lt;E&gt; iterator() {
1805             return backingSet.iterator();
1806         }
1807 
1808         @Override
1809         public Object[] toArray() {
1810             synchronized(mutex) {
1811                 return backingSet.toArray();
1812             }
1813         }
1814 
1815         @Override
1816         public &lt;E&gt; E[] toArray(E[] a) {
1817             synchronized(mutex) {
1818                 return backingSet.toArray(a);
1819             }
1820         }
1821 
1822         @Override
1823         public boolean add(E e) {
1824             synchronized(mutex) {
1825                 return backingSet.add(e);
1826             }
1827         }
1828 
1829         @Override
1830         public boolean remove(Object o) {
1831             synchronized(mutex) {
1832                 return backingSet.remove(o);
1833             }
1834         }
1835 
1836         @Override
1837         public boolean containsAll(Collection&lt;?&gt; c) {
1838             synchronized(mutex) {
1839                 return backingSet.containsAll(c);
1840             }
1841         }
1842 
1843         @Override
1844         public boolean addAll(Collection&lt;? extends E&gt; c) {
1845             synchronized(mutex) {
1846                 return backingSet.addAll(c);
1847             }
1848         }
1849 
1850         @Override
1851         public boolean retainAll(Collection&lt;?&gt; c) {
1852             synchronized(mutex) {
1853                 return backingSet.retainAll(c);
1854             }
1855         }
1856 
1857         @Override
1858         public boolean removeAll(Collection&lt;?&gt; c) {
1859             synchronized(mutex) {
1860                 return backingSet.removeAll(c);
1861             }
1862         }
1863 
1864         @Override
1865         public void clear() {
1866             synchronized(mutex) {
1867                 backingSet.clear();
1868             }
1869         }
1870 
1871         @Override
1872         public boolean equals(Object o) {
1873             if (o == this) {
1874                 return true;
1875             }
1876             synchronized(mutex) {
1877                 return backingSet.equals(o);
1878             }
1879         }
1880 
1881         @Override
1882         public int hashCode() {
1883             synchronized (mutex) {
1884                 return backingSet.hashCode();
1885             }
1886         }
1887     }
1888 
1889     private static class SynchronizedObservableSet&lt;E&gt; extends SynchronizedSet&lt;E&gt; implements ObservableSet&lt;E&gt; {
1890 
1891         private final ObservableSet&lt;E&gt; backingSet;
1892         private SetListenerHelper listenerHelper;
1893         private final SetChangeListener&lt;E&gt; listener;
1894 
1895         SynchronizedObservableSet(ObservableSet&lt;E&gt; set) {
1896             super(set);
1897             backingSet = set;
1898             listener = c -&gt; {
1899                 SetListenerHelper.fireValueChangedEvent(listenerHelper, new SetAdapterChange&lt;E&gt;(SynchronizedObservableSet.this, c));
1900             };
1901             backingSet.addListener(new WeakSetChangeListener&lt;E&gt;(listener));
1902         }
1903 
1904         @Override
1905         public void addListener(InvalidationListener listener) {
1906             synchronized (mutex) {
1907                 listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1908             }
1909         }
1910 
1911         @Override
1912         public void removeListener(InvalidationListener listener) {
1913             synchronized (mutex) {
1914                 listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1915             }
1916         }
1917         @Override
1918         public void addListener(SetChangeListener&lt;? super E&gt; listener) {
1919             synchronized (mutex) {
1920                 listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1921             }
1922         }
1923 
1924         @Override
1925         public void removeListener(SetChangeListener&lt;? super E&gt; listener) {
1926             synchronized (mutex) {
1927                 listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1928             }
1929         }
1930     }
1931 
1932     private static class CheckedObservableSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements ObservableSet&lt;E&gt; {
1933 
1934         private final ObservableSet&lt;E&gt; backingSet;
1935         private final Class&lt;E&gt; type;
1936         private SetListenerHelper listenerHelper;
1937         private final SetChangeListener&lt;E&gt; listener;
1938 
1939         CheckedObservableSet(ObservableSet&lt;E&gt; set, Class&lt;E&gt; type) {
1940             if (set == null || type == null) {
1941                 throw new NullPointerException();
1942             }
1943             backingSet = set;
1944             this.type = type;
1945             listener = c -&gt; {
1946                 callObservers(new SetAdapterChange&lt;E&gt;(CheckedObservableSet.this, c));
1947             };
1948             backingSet.addListener(new WeakSetChangeListener&lt;E&gt;(listener));
1949         }
1950 
1951         private void callObservers(SetChangeListener.Change&lt;? extends E&gt; c) {
1952             SetListenerHelper.fireValueChangedEvent(listenerHelper, c);
1953         }
1954 
1955         void typeCheck(Object o) {
1956             if (o != null &amp;&amp; !type.isInstance(o)) {
1957                 throw new ClassCastException(&quot;Attempt to insert &quot;
1958                         + o.getClass() + &quot; element into collection with element type &quot;
1959                         + type);
1960             }
1961         }
1962 
1963         @Override
1964         public void addListener(InvalidationListener listener) {
1965             listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1966         }
1967 
1968         @Override
1969         public void removeListener(InvalidationListener listener) {
1970             listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1971         }
1972 
1973         @Override
1974         public void addListener(SetChangeListener&lt;? super E&gt; listener) {
1975             listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1976         }
1977 
1978         @Override
1979         public void removeListener(SetChangeListener&lt;? super E&gt; listener) {
1980             listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1981         }
1982 
1983         @Override
1984         public int size() {
1985             return backingSet.size();
1986         }
1987 
1988         @Override
1989         public boolean isEmpty() {
1990             return backingSet.isEmpty();
1991         }
1992 
1993         @Override
1994         public boolean contains(Object o) {
1995             return backingSet.contains(o);
1996         }
1997 
1998         @Override
1999         public Object[] toArray() {
2000             return backingSet.toArray();
2001         }
2002 
2003         @Override
2004         public &lt;T&gt; T[] toArray(T[] a) {
2005             return backingSet.toArray(a);
2006         }
2007 
2008         @Override
2009         public boolean add(E e) {
2010             typeCheck(e);
2011             return backingSet.add(e);
2012         }
2013 
2014         @Override
2015         public boolean remove(Object o) {
2016             return backingSet.remove(o);
2017         }
2018 
2019         @Override
2020         public boolean containsAll(Collection&lt;?&gt; c) {
2021             return backingSet.containsAll(c);
2022         }
2023 
2024         @Override
2025         @SuppressWarnings(&quot;unchecked&quot;)
2026         public boolean addAll(Collection&lt;? extends E&gt; c) {
2027             E[] a = null;
2028             try {
2029                 a = c.toArray((E[]) Array.newInstance(type, 0));
2030             } catch (ArrayStoreException e) {
2031                 throw new ClassCastException();
2032             }
2033 
2034             return backingSet.addAll(Arrays.asList(a));
2035         }
2036 
2037         @Override
2038         public boolean retainAll(Collection&lt;?&gt; c) {
2039             return backingSet.retainAll(c);
2040         }
2041 
2042         @Override
2043         public boolean removeAll(Collection&lt;?&gt; c) {
2044             return backingSet.removeAll(c);
2045         }
2046 
2047         @Override
2048         public void clear() {
2049             backingSet.clear();
2050         }
2051 
2052         @Override
2053         public boolean equals(Object o) {
2054             return o == this || backingSet.equals(o);
2055         }
2056 
2057         @Override
2058         public int hashCode() {
2059             return backingSet.hashCode();
2060         }
2061 
2062         @Override
2063         public Iterator&lt;E&gt; iterator() {
2064             final Iterator&lt;E&gt; it = backingSet.iterator();
2065 
2066             return new Iterator&lt;E&gt;() {
2067                 @Override
2068                 public boolean hasNext() {
2069                     return it.hasNext();
2070                 }
2071 
2072                 @Override
2073                 public E next() {
2074                     return it.next();
2075                 }
2076 
2077                 @Override
2078                 public void remove() {
2079                     it.remove();
2080                 }
2081             };
2082         }
2083 
2084     }
2085 
2086     private static class EmptyObservableMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements ObservableMap&lt;K, V&gt; {
2087 
2088         public EmptyObservableMap() {
2089         }
2090 
2091         @Override
2092         public void addListener(InvalidationListener listener) {
2093         }
2094 
2095         @Override
2096         public void removeListener(InvalidationListener listener) {
2097         }
2098 
2099         @Override
2100         public void addListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2101         }
2102 
2103         @Override
2104         public void removeListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2105         }
2106 
2107         @Override
2108         public int size() {
2109             return 0;
2110         }
2111 
2112         @Override
2113         public boolean isEmpty() {
2114             return true;
2115         }
2116 
2117         @Override
2118         public boolean containsKey(Object key) {
2119             return false;
2120         }
2121 
2122         @Override
2123         public boolean containsValue(Object value) {
2124             return false;
2125         }
2126 
2127         @Override
2128         public V get(Object key) {
2129             return null;
2130         }
2131 
2132         @Override
2133         public Set&lt;K&gt; keySet() {
2134             return emptyObservableSet();
2135         }
2136 
2137         @Override
2138         public Collection&lt;V&gt; values() {
2139             return emptyObservableSet();
2140         }
2141 
2142         @Override
2143         public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
2144             return emptyObservableSet();
2145         }
2146 
2147         @Override
2148         public boolean equals(Object o) {
2149             return (o instanceof Map) &amp;&amp; ((Map&lt;?,?&gt;)o).isEmpty();
2150         }
2151 
2152         @Override
2153         public int hashCode() {
2154             return 0;
2155         }
2156     }
2157 
2158     private static class CheckedObservableMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements ObservableMap&lt;K, V&gt; {
2159 
2160         private final ObservableMap&lt;K, V&gt; backingMap;
2161         private final Class&lt;K&gt; keyType;
2162         private final Class&lt;V&gt; valueType;
2163         private MapListenerHelper listenerHelper;
2164         private final MapChangeListener&lt;K, V&gt; listener;
2165 
2166         CheckedObservableMap(ObservableMap&lt;K, V&gt; map, Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) {
2167             backingMap = map;
2168             this.keyType = keyType;
2169             this.valueType = valueType;
2170             listener = c -&gt; {
2171                 callObservers(new MapAdapterChange&lt;K, V&gt;(CheckedObservableMap.this, c));
2172             };
2173             backingMap.addListener(new WeakMapChangeListener&lt;K, V&gt;(listener));
2174         }
2175 
2176         private void callObservers(MapChangeListener.Change&lt;? extends K, ? extends V&gt; c) {
2177             MapListenerHelper.fireValueChangedEvent(listenerHelper, c);
2178         }
2179 
2180         void typeCheck(Object key, Object value) {
2181             if (key != null &amp;&amp; !keyType.isInstance(key)) {
2182                 throw new ClassCastException(&quot;Attempt to insert &quot;
2183                         + key.getClass() + &quot; key into map with key type &quot;
2184                         + keyType);
2185             }
2186 
2187             if (value != null &amp;&amp; !valueType.isInstance(value)) {
2188                 throw new ClassCastException(&quot;Attempt to insert &quot;
2189                         + value.getClass() + &quot; value into map with value type &quot;
2190                         + valueType);
2191             }
2192         }
2193 
2194         @Override
2195         public void addListener(InvalidationListener listener) {
2196             listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
2197         }
2198 
2199         @Override
2200         public void removeListener(InvalidationListener listener) {
2201             listenerHelper = MapListenerHelper.removeListener(listenerHelper, listener);
2202         }
2203 
2204         @Override
2205         public void addListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2206             listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
2207         }
2208 
2209         @Override
2210         public void removeListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2211             listenerHelper = MapListenerHelper.removeListener(listenerHelper, listener);
2212         }
2213 
2214         @Override
2215         public int size() {
2216             return backingMap.size();
2217         }
2218 
2219         @Override
2220         public boolean isEmpty() {
2221             return backingMap.isEmpty();
2222         }
2223 
2224         @Override
2225         public boolean containsKey(Object key) {
2226             return backingMap.containsKey(key);
2227         }
2228 
2229         @Override
2230         public boolean containsValue(Object value) {
2231             return backingMap.containsValue(value);
2232         }
2233 
2234         @Override
2235         public V get(Object key) {
2236             return backingMap.get(key);
2237         }
2238 
2239         @Override
2240         public V put(K key, V value) {
2241             typeCheck(key, value);
2242             return backingMap.put(key, value);
2243         }
2244 
2245         @Override
2246         public V remove(Object key) {
2247             return backingMap.remove(key);
2248         }
2249 
2250         @Override
2251         @SuppressWarnings(&quot;unchecked&quot;)
2252         public void putAll(Map t) {
2253             // Satisfy the following goals:
2254             // - good diagnostics in case of type mismatch
2255             // - all-or-nothing semantics
2256             // - protection from malicious t
2257             // - correct behavior if t is a concurrent map
2258             Object[] entries = t.entrySet().toArray();
2259             List&lt;Map.Entry&lt;K,V&gt;&gt; checked =
2260                 new ArrayList&lt;Map.Entry&lt;K,V&gt;&gt;(entries.length);
2261             for (Object o : entries) {
2262                 Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;
2263                 Object k = e.getKey();
2264                 Object v = e.getValue();
2265                 typeCheck(k, v);
2266                 checked.add(
2267                     new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;((K) k, (V) v));
2268             }
2269             for (Map.Entry&lt;K,V&gt; e : checked)
2270                 backingMap.put(e.getKey(), e.getValue());
2271         }
2272 
2273         @Override
2274         public void clear() {
2275             backingMap.clear();
2276         }
2277 
2278         @Override
2279         public Set&lt;K&gt; keySet() {
2280             return backingMap.keySet();
2281         }
2282 
2283         @Override
2284         public Collection&lt;V&gt; values() {
2285             return backingMap.values();
2286         }
2287 
2288         private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;
2289 
2290         @Override
2291         public Set entrySet() {
2292             if (entrySet==null)
2293                 entrySet = new CheckedEntrySet&lt;K,V&gt;(backingMap.entrySet(), valueType);
2294             return entrySet;
2295         }
2296 
2297         @Override
2298         public boolean equals(Object o) {
2299             return o == this || backingMap.equals(o);
2300         }
2301 
2302         @Override
2303         public int hashCode() {
2304             return backingMap.hashCode();
2305         }
2306 
2307         static class CheckedEntrySet&lt;K,V&gt; implements Set&lt;Map.Entry&lt;K,V&gt;&gt; {
2308             private final Set&lt;Map.Entry&lt;K,V&gt;&gt; s;
2309             private final Class&lt;V&gt; valueType;
2310 
2311             CheckedEntrySet(Set&lt;Map.Entry&lt;K, V&gt;&gt; s, Class&lt;V&gt; valueType) {
2312                 this.s = s;
2313                 this.valueType = valueType;
2314             }
2315 
2316             @Override
2317             public int size() {
2318                 return s.size();
2319             }
2320 
2321             @Override
2322             public boolean isEmpty() {
2323                 return s.isEmpty();
2324             }
2325 
2326             @Override
2327             public String toString() {
2328                 return s.toString();
2329             }
2330 
2331             @Override
2332             public int hashCode() {
2333                 return s.hashCode();
2334             }
2335 
2336             @Override
2337             public void clear() {
2338                 s.clear();
2339             }
2340 
2341             @Override
2342             public boolean add(Map.Entry&lt;K, V&gt; e) {
2343                 throw new UnsupportedOperationException();
2344             }
2345 
2346             @Override
2347             public boolean addAll(Collection&lt;? extends Map.Entry&lt;K, V&gt;&gt; coll) {
2348                 throw new UnsupportedOperationException();
2349             }
2350 
2351             @Override
2352             public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
2353                 final Iterator&lt;Map.Entry&lt;K, V&gt;&gt; i = s.iterator();
2354                 final Class&lt;V&gt; valueType = this.valueType;
2355 
2356                 return new Iterator&lt;Map.Entry&lt;K,V&gt;&gt;() {
2357                     @Override
2358                     public boolean hasNext() {
2359                         return i.hasNext();
2360                     }
2361 
2362                     @Override
2363                     public void remove() {
2364                         i.remove();
2365                     }
2366 
2367                     @Override
2368                     public Map.Entry&lt;K,V&gt; next() {
2369                         return checkedEntry(i.next(), valueType);
2370                     }
2371                 };
2372             }
2373 
2374             @Override
2375             @SuppressWarnings(&quot;unchecked&quot;)
2376             public Object[] toArray() {
2377                 Object[] source = s.toArray();
2378 
2379                 /*
2380                  * Ensure that we don&#39;t get an ArrayStoreException even if
2381                  * s.toArray returns an array of something other than Object
2382                  */
2383                 Object[] dest = (CheckedEntry.class.isInstance(
2384                     source.getClass().getComponentType()) ? source :
2385                                  new Object[source.length]);
2386 
2387                 for (int i = 0; i &lt; source.length; i++)
2388                     dest[i] = checkedEntry((Map.Entry&lt;K,V&gt;)source[i],
2389                                            valueType);
2390                 return dest;
2391             }
2392 
2393             @Override
2394             @SuppressWarnings(&quot;unchecked&quot;)
2395             public &lt;T&gt; T[] toArray(T[] a) {
2396                 // We don&#39;t pass a to s.toArray, to avoid window of
2397                 // vulnerability wherein an unscrupulous multithreaded client
2398                 // could get his hands on raw (unwrapped) Entries from s.
2399                 T[] arr = s.toArray(a.length==0 ? a : Arrays.copyOf(a, 0));
2400 
2401                 for (int i=0; i&lt;arr.length; i++)
2402                     arr[i] = (T) checkedEntry((Map.Entry&lt;K,V&gt;)arr[i],
2403                                               valueType);
2404                 if (arr.length &gt; a.length)
2405                     return arr;
2406 
2407                 System.arraycopy(arr, 0, a, 0, arr.length);
2408                 if (a.length &gt; arr.length)
2409                     a[arr.length] = null;
2410                 return a;
2411             }
2412 
2413             /**
2414              * This method is overridden to protect the backing set against
2415              * an object with a nefarious equals function that senses
2416              * that the equality-candidate is Map.Entry and calls its
2417              * setValue method.
2418              */
2419             @Override
2420             public boolean contains(Object o) {
2421                 if (!(o instanceof Map.Entry))
2422                     return false;
2423                 Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;
2424                 return s.contains(
2425                     (e instanceof CheckedEntry) ? e : checkedEntry(e, valueType));
2426             }
2427 
2428             /**
2429              * The bulk collection methods are overridden to protect
2430              * against an unscrupulous collection whose contains(Object o)
2431              * method senses when o is a Map.Entry, and calls o.setValue.
2432              */
2433             @Override
2434             public boolean containsAll(Collection&lt;?&gt; c) {
2435                 for (Object o : c)
2436                     if (!contains(o)) // Invokes safe contains() above
2437                         return false;
2438                 return true;
2439             }
2440 
2441             @Override
2442             public boolean remove(Object o) {
2443                 if (!(o instanceof Map.Entry))
2444                     return false;
2445                 return s.remove(new AbstractMap.SimpleImmutableEntry
2446                                 &lt;Object, Object&gt;((Map.Entry&lt;?,?&gt;)o));
2447             }
2448 
2449             @Override
2450             public boolean removeAll(Collection&lt;?&gt; c) {
2451                 return batchRemove(c, false);
2452             }
2453 
2454             @Override
2455             public boolean retainAll(Collection&lt;?&gt; c) {
2456                 return batchRemove(c, true);
2457             }
2458 
2459             private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {
2460                 boolean modified = false;
2461                 Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = iterator();
2462                 while (it.hasNext()) {
2463                     if (c.contains(it.next()) != complement) {
2464                         it.remove();
2465                         modified = true;
2466                     }
2467                 }
2468                 return modified;
2469             }
2470 
2471             @Override
2472             public boolean equals(Object o) {
2473                 if (o == this)
2474                     return true;
2475                 if (!(o instanceof Set))
2476                     return false;
2477                 Set&lt;?&gt; that = (Set&lt;?&gt;) o;
2478                 return that.size() == s.size()
2479                     &amp;&amp; containsAll(that); // Invokes safe containsAll() above
2480             }
2481 
2482             static &lt;K,V,T&gt; CheckedEntry&lt;K,V,T&gt; checkedEntry(Map.Entry&lt;K,V&gt; e,
2483                                                             Class&lt;T&gt; valueType) {
2484                 return new CheckedEntry&lt;K,V,T&gt;(e, valueType);
2485             }
2486 
2487             /**
2488              * This &quot;wrapper class&quot; serves two purposes: it prevents
2489              * the client from modifying the backing Map, by short-circuiting
2490              * the setValue method, and it protects the backing Map against
2491              * an ill-behaved Map.Entry that attempts to modify another
2492              * Map.Entry when asked to perform an equality check.
2493              */
2494             private static class CheckedEntry&lt;K,V,T&gt; implements Map.Entry&lt;K,V&gt; {
2495                 private final Map.Entry&lt;K, V&gt; e;
2496                 private final Class&lt;T&gt; valueType;
2497 
2498                 CheckedEntry(Map.Entry&lt;K, V&gt; e, Class&lt;T&gt; valueType) {
2499                     this.e = e;
2500                     this.valueType = valueType;
2501                 }
2502 
2503                 @Override
2504                 public K getKey() {
2505                     return e.getKey();
2506                 }
2507 
2508                 @Override
2509                 public V getValue() {
2510                     return e.getValue();
2511                 }
2512 
2513                 @Override
2514                 public int hashCode() {
2515                     return e.hashCode();
2516                 }
2517 
2518                 @Override
2519                 public String toString() {
2520                     return e.toString();
2521                 }
2522 
2523                 @Override
2524                 public V setValue(V value) {
2525                     if (value != null &amp;&amp; !valueType.isInstance(value))
2526                         throw new ClassCastException(badValueMsg(value));
2527                     return e.setValue(value);
2528                 }
2529 
2530                 private String badValueMsg(Object value) {
2531                     return &quot;Attempt to insert &quot; + value.getClass() +
2532                         &quot; value into map with value type &quot; + valueType;
2533                 }
2534 
2535                 @Override
2536                 public boolean equals(Object o) {
2537                     if (o == this)
2538                         return true;
2539                     if (!(o instanceof Map.Entry))
2540                         return false;
2541                     return e.equals(new AbstractMap.SimpleImmutableEntry
2542                                     &lt;Object, Object&gt;((Map.Entry&lt;?,?&gt;)o));
2543                 }
2544             }
2545         }
2546 
2547     }
2548 
2549     private static class SynchronizedMap&lt;K, V&gt; implements Map&lt;K, V&gt; {
2550         final Object mutex;
2551         private final Map&lt;K, V&gt; backingMap;
2552 
2553         SynchronizedMap(Map&lt;K, V&gt; map) {
2554             backingMap = map;
2555             this.mutex = this;
2556         }
2557 
2558         @Override
2559         public int size() {
2560             synchronized (mutex) {
2561                 return backingMap.size();
2562             }
2563         }
2564 
2565         @Override
2566         public boolean isEmpty() {
2567             synchronized (mutex) {
2568                 return backingMap.isEmpty();
2569             }
2570         }
2571 
2572         @Override
2573         public boolean containsKey(Object key) {
2574             synchronized (mutex) {
2575                 return backingMap.containsKey(key);
2576             }
2577         }
2578 
2579         @Override
2580         public boolean containsValue(Object value) {
2581             synchronized (mutex) {
2582                 return backingMap.containsValue(value);
2583             }
2584         }
2585 
2586         @Override
2587         public V get(Object key) {
2588             synchronized (mutex) {
2589                 return backingMap.get(key);
2590             }
2591         }
2592 
2593         @Override
2594         public V put(K key, V value) {
2595             synchronized (mutex) {
2596                 return backingMap.put(key, value);
2597             }
2598         }
2599 
2600         @Override
2601         public V remove(Object key) {
2602             synchronized (mutex) {
2603                 return backingMap.remove(key);
2604             }
2605         }
2606 
2607         @Override
2608         public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
2609             synchronized (mutex) {
2610                 backingMap.putAll(m);
2611             }
2612         }
2613 
2614         @Override
2615         public void clear() {
2616             synchronized (mutex) {
2617                 backingMap.clear();
2618             }
2619         }
2620 
2621         private transient Set&lt;K&gt; keySet = null;
2622         private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;
2623         private transient Collection&lt;V&gt; values = null;
2624 
2625         @Override
2626         public Set&lt;K&gt; keySet() {
2627             synchronized(mutex) {
2628                 if (keySet==null)
2629                     keySet = new SynchronizedSet&lt;K&gt;(backingMap.keySet(), mutex);
2630                 return keySet;
2631             }
2632         }
2633 
2634         @Override
2635         public Collection&lt;V&gt; values() {
2636             synchronized(mutex) {
2637                 if (values==null)
2638                     values = new SynchronizedCollection&lt;V&gt;(backingMap.values(), mutex);
2639                 return values;
2640             }
2641         }
2642 
2643         @Override
2644         public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {
2645             synchronized(mutex) {
2646                 if (entrySet==null)
2647                     entrySet = new SynchronizedSet&lt;Map.Entry&lt;K,V&gt;&gt;(backingMap.entrySet(), mutex);
2648                 return entrySet;
2649             }
2650         }
2651 
2652         @Override
2653         public boolean equals(Object o) {
2654             if (o == this) {
2655                 return true;
2656             }
2657             synchronized(mutex) {
2658                 return backingMap.equals(o);
2659             }
2660         }
2661 
2662         @Override
2663         public int hashCode() {
2664             synchronized(mutex) {
2665                 return backingMap.hashCode();
2666             }
2667         }
2668 
2669     }
2670 
2671     private static class SynchronizedCollection&lt;E&gt; implements Collection&lt;E&gt; {
2672 
2673         private final Collection&lt;E&gt; backingCollection;
2674         final Object mutex;
2675 
2676         SynchronizedCollection(Collection&lt;E&gt; c, Object mutex) {
2677             backingCollection = c;
2678             this.mutex = mutex;
2679         }
2680 
2681         SynchronizedCollection(Collection&lt;E&gt; c) {
2682             this(c, new Object());
2683         }
2684 
2685         @Override
2686         public int size() {
2687             synchronized (mutex) {
2688                 return backingCollection.size();
2689             }
2690         }
2691 
2692         @Override
2693         public boolean isEmpty() {
2694             synchronized (mutex) {
2695                 return backingCollection.isEmpty();
2696             }
2697         }
2698 
2699         @Override
2700         public boolean contains(Object o) {
2701             synchronized (mutex) {
2702                 return backingCollection.contains(o);
2703             }
2704         }
2705 
2706         @Override
2707         public Iterator&lt;E&gt; iterator() {
2708             return backingCollection.iterator();
2709         }
2710 
2711         @Override
2712         public Object[] toArray() {
2713             synchronized (mutex) {
2714                 return backingCollection.toArray();
2715             }
2716         }
2717 
2718         @Override
2719         public &lt;T&gt; T[] toArray(T[] a) {
2720             synchronized (mutex) {
2721                 return backingCollection.toArray(a);
2722             }
2723         }
2724 
2725         @Override
2726         public boolean add(E e) {
2727             synchronized (mutex) {
2728                 return backingCollection.add(e);
2729             }
2730         }
2731 
2732         @Override
2733         public boolean remove(Object o) {
2734             synchronized (mutex) {
2735                 return backingCollection.remove(o);
2736             }
2737         }
2738 
2739         @Override
2740         public boolean containsAll(Collection&lt;?&gt; c) {
2741             synchronized (mutex) {
2742                 return backingCollection.containsAll(c);
2743             }
2744         }
2745 
2746         @Override
2747         public boolean addAll(Collection&lt;? extends E&gt; c) {
2748             synchronized (mutex) {
2749                 return backingCollection.addAll(c);
2750             }
2751         }
2752 
2753         @Override
2754         public boolean removeAll(Collection&lt;?&gt; c) {
2755             synchronized (mutex) {
2756                 return backingCollection.removeAll(c);
2757             }
2758         }
2759 
2760         @Override
2761         public boolean retainAll(Collection&lt;?&gt; c) {
2762             synchronized (mutex) {
2763                 return backingCollection.retainAll(c);
2764             }
2765         }
2766 
2767         @Override
2768         public void clear() {
2769             synchronized (mutex) {
2770                 backingCollection.clear();
2771             }
2772         }
2773     }
2774 
2775     private static class SynchronizedObservableMap&lt;K, V&gt; extends SynchronizedMap&lt;K, V&gt; implements ObservableMap&lt;K, V&gt; {
2776 
2777         private final ObservableMap&lt;K, V&gt; backingMap;
2778         private MapListenerHelper listenerHelper;
2779         private final MapChangeListener&lt;K, V&gt; listener;
2780 
2781         SynchronizedObservableMap(ObservableMap&lt;K, V&gt; map) {
2782             super(map);
2783             backingMap = map;
2784             listener = c -&gt; {
2785                 MapListenerHelper.fireValueChangedEvent(listenerHelper, new MapAdapterChange&lt;K, V&gt;(SynchronizedObservableMap.this, c));
2786             };
2787             backingMap.addListener(new WeakMapChangeListener&lt;K, V&gt;(listener));
2788         }
2789 
2790         @Override
2791         public void addListener(InvalidationListener listener) {
2792             synchronized (mutex) {
2793                 listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
2794             }
2795         }
2796 
2797         @Override
2798         public void removeListener(InvalidationListener listener) {
2799             synchronized (mutex) {
2800                 listenerHelper = MapListenerHelper.removeListener(listenerHelper, listener);
2801             }
2802         }
2803 
2804         @Override
2805         public void addListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2806             synchronized (mutex) {
2807                 listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
2808             }
2809         }
2810 
2811         @Override
2812         public void removeListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2813             synchronized (mutex) {
2814                 listenerHelper = MapListenerHelper.removeListener(listenerHelper, listener);
2815             }
2816         }
2817 
2818     }
2819 
2820 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>