<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.graphics/src/main/java/javafx/scene/Node.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
    1 /*
    2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
    3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4  *
    5  * This code is free software; you can redistribute it and/or modify it
    6  * under the terms of the GNU General Public License version 2 only, as
    7  * published by the Free Software Foundation.  Oracle designates this
    8  * particular file as subject to the &quot;Classpath&quot; exception as provided
    9  * by Oracle in the LICENSE file that accompanied this code.
   10  *
   11  * This code is distributed in the hope that it will be useful, but WITHOUT
   12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   14  * version 2 for more details (a copy is included in the LICENSE file that
   15  * accompanied this code).
   16  *
   17  * You should have received a copy of the GNU General Public License version
   18  * 2 along with this work; if not, write to the Free Software Foundation,
   19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   20  *
   21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   22  * or visit www.oracle.com if you need additional information or have any
   23  * questions.
   24  */
   25 
   26 package javafx.scene;
   27 
   28 
   29 import com.sun.javafx.geometry.BoundsUtils;
   30 import javafx.application.Platform;
   31 import javafx.beans.InvalidationListener;
   32 import javafx.beans.Observable;
   33 import javafx.beans.binding.BooleanExpression;
   34 import javafx.beans.property.BooleanProperty;
   35 import javafx.beans.property.BooleanPropertyBase;
   36 import javafx.beans.property.DoubleProperty;
   37 import javafx.beans.property.DoublePropertyBase;
   38 import javafx.beans.property.IntegerProperty;
   39 import javafx.beans.property.ObjectProperty;
   40 import javafx.beans.property.ObjectPropertyBase;
   41 import javafx.beans.property.ReadOnlyBooleanProperty;
   42 import javafx.beans.property.ReadOnlyBooleanPropertyBase;
   43 import javafx.beans.property.ReadOnlyBooleanWrapper;
   44 import javafx.beans.property.ReadOnlyObjectProperty;
   45 import javafx.beans.property.ReadOnlyObjectPropertyBase;
   46 import javafx.beans.property.ReadOnlyObjectWrapper;
   47 import javafx.beans.property.SimpleBooleanProperty;
   48 import javafx.beans.property.SimpleObjectProperty;
   49 import javafx.beans.property.StringProperty;
   50 import javafx.beans.property.StringPropertyBase;
   51 import javafx.beans.value.ChangeListener;
   52 import javafx.collections.FXCollections;
   53 import javafx.collections.ListChangeListener.Change;
   54 import javafx.collections.ObservableList;
   55 import javafx.collections.ObservableMap;
   56 import javafx.collections.ObservableSet;
   57 import javafx.css.CssMetaData;
   58 import javafx.css.ParsedValue;
   59 import javafx.css.PseudoClass;
   60 import javafx.css.StyleConverter;
   61 import javafx.css.Styleable;
   62 import javafx.css.StyleableBooleanProperty;
   63 import javafx.css.StyleableDoubleProperty;
   64 import javafx.css.StyleableObjectProperty;
   65 import javafx.css.StyleableProperty;
   66 import javafx.event.Event;
   67 import javafx.event.EventDispatchChain;
   68 import javafx.event.EventDispatcher;
   69 import javafx.event.EventHandler;
   70 import javafx.event.EventTarget;
   71 import javafx.event.EventType;
   72 import javafx.geometry.BoundingBox;
   73 import javafx.geometry.Bounds;
   74 import javafx.geometry.NodeOrientation;
   75 import javafx.geometry.Orientation;
   76 import javafx.geometry.Point2D;
   77 import javafx.geometry.Point3D;
   78 import javafx.geometry.Rectangle2D;
   79 import javafx.scene.effect.BlendMode;
   80 import javafx.scene.effect.Effect;
   81 import javafx.scene.image.WritableImage;
   82 import javafx.scene.input.ContextMenuEvent;
   83 import javafx.scene.input.DragEvent;
   84 import javafx.scene.input.Dragboard;
   85 import javafx.scene.input.InputEvent;
   86 import javafx.scene.input.InputMethodEvent;
   87 import javafx.scene.input.InputMethodRequests;
   88 import javafx.scene.input.KeyEvent;
   89 import javafx.scene.input.MouseDragEvent;
   90 import javafx.scene.input.MouseEvent;
   91 import javafx.scene.input.PickResult;
   92 import javafx.scene.input.RotateEvent;
   93 import javafx.scene.input.ScrollEvent;
   94 import javafx.scene.input.SwipeEvent;
   95 import javafx.scene.input.TouchEvent;
   96 import javafx.scene.input.TransferMode;
   97 import javafx.scene.input.ZoomEvent;
   98 import javafx.scene.text.Font;
   99 import javafx.scene.transform.Rotate;
  100 import javafx.scene.transform.Transform;
  101 import javafx.stage.Window;
  102 import javafx.util.Callback;
  103 import java.security.AccessControlContext;
  104 
  105 import java.util.ArrayList;
  106 import java.util.Collections;
  107 import java.util.EnumSet;
  108 import java.util.HashMap;
  109 import java.util.LinkedList;
  110 import java.util.List;
  111 import java.util.Map;
  112 import java.util.Set;
  113 
  114 import com.sun.glass.ui.Accessible;
  115 import com.sun.glass.ui.Application;
  116 import com.sun.javafx.util.Logging;
  117 import com.sun.javafx.util.TempState;
  118 import com.sun.javafx.util.Utils;
  119 import com.sun.javafx.beans.IDProperty;
  120 import com.sun.javafx.beans.event.AbstractNotifyListener;
  121 import com.sun.javafx.binding.ExpressionHelper;
  122 import com.sun.javafx.collections.TrackableObservableList;
  123 import com.sun.javafx.collections.UnmodifiableListSet;
  124 import com.sun.javafx.css.PseudoClassState;
  125 import javafx.css.Selector;
  126 import javafx.css.Style;
  127 import javafx.css.converter.BooleanConverter;
  128 import javafx.css.converter.CursorConverter;
  129 import javafx.css.converter.EffectConverter;
  130 import javafx.css.converter.EnumConverter;
  131 import javafx.css.converter.SizeConverter;
  132 import com.sun.javafx.effect.EffectDirtyBits;
  133 import com.sun.javafx.geom.BaseBounds;
  134 import com.sun.javafx.geom.BoxBounds;
  135 import com.sun.javafx.geom.PickRay;
  136 import com.sun.javafx.geom.RectBounds;
  137 import com.sun.javafx.geom.Vec3d;
  138 import com.sun.javafx.geom.transform.Affine3D;
  139 import com.sun.javafx.geom.transform.BaseTransform;
  140 import com.sun.javafx.geom.transform.GeneralTransform3D;
  141 import com.sun.javafx.geom.transform.NoninvertibleTransformException;
  142 import com.sun.javafx.perf.PerformanceTracker;
  143 import com.sun.javafx.scene.BoundsAccessor;
  144 import com.sun.javafx.scene.CameraHelper;
  145 import com.sun.javafx.scene.CssFlags;
  146 import com.sun.javafx.scene.DirtyBits;
  147 import com.sun.javafx.scene.EventHandlerProperties;
  148 import com.sun.javafx.scene.LayoutFlags;
  149 import com.sun.javafx.scene.NodeEventDispatcher;
  150 import com.sun.javafx.scene.NodeHelper;
  151 import com.sun.javafx.scene.SceneHelper;
  152 import com.sun.javafx.scene.SceneUtils;
  153 import com.sun.javafx.scene.input.PickResultChooser;
  154 import com.sun.javafx.scene.transform.TransformHelper;
  155 import com.sun.javafx.scene.transform.TransformUtils;
  156 import com.sun.javafx.scene.traversal.Direction;
  157 import com.sun.javafx.sg.prism.NGNode;
  158 import com.sun.javafx.tk.Toolkit;
  159 import com.sun.prism.impl.PrismSettings;
  160 import com.sun.scenario.effect.EffectHelper;
  161 
  162 import javafx.scene.shape.Shape3D;
  163 import com.sun.javafx.logging.PlatformLogger;
  164 import com.sun.javafx.logging.PlatformLogger.Level;
  165 
  166 /**
  167  * Base class for scene graph nodes. A scene graph is a set of tree data structures
  168  * where every item has zero or one parent, and each item is either
  169  * a &quot;leaf&quot; with zero sub-items or a &quot;branch&quot; with zero or more sub-items.
  170  * &lt;p&gt;
  171  * Each item in the scene graph is called a {@code Node}. Branch nodes are
  172  * of type {@link Parent}, whose concrete subclasses are {@link Group},
  173  * {@link javafx.scene.layout.Region}, and {@link javafx.scene.control.Control},
  174  * or subclasses thereof.
  175  * &lt;p&gt;
  176  * Leaf nodes are classes such as
  177  * {@link javafx.scene.shape.Rectangle}, {@link javafx.scene.text.Text},
  178  * {@link javafx.scene.image.ImageView}, {@link javafx.scene.media.MediaView},
  179  * or other such leaf classes which cannot have children. Only a single node within
  180  * each scene graph tree will have no parent, which is referred to as the &quot;root&quot; node.
  181  * &lt;p&gt;
  182  * There may be several trees in the scene graph. Some trees may be part of
  183  * a {@link Scene}, in which case they are eligible to be displayed.
  184  * Other trees might not be part of any {@link Scene}.
  185  * &lt;p&gt;
  186  * A node may occur at most once anywhere in the scene graph. Specifically,
  187  * a node must appear no more than once in all of the following:
  188  * as the root node of a {@link Scene},
  189  * the children ObservableList of a {@link Parent},
  190  * or as the clip of a {@link Node}.
  191  * &lt;p&gt;
  192  * The scene graph must not have cycles. A cycle would exist if a node is
  193  * an ancestor of itself in the tree, considering the {@link Group} content
  194  * ObservableList, {@link Parent} children ObservableList, and {@link Node} clip relationships
  195  * mentioned above.
  196  * &lt;p&gt;
  197  * If a program adds a child node to a Parent (including Group, Region, etc)
  198  * and that node is already a child of a different Parent or the root of a Scene,
  199  * the node is automatically (and silently) removed from its former parent.
  200  * If a program attempts to modify the scene graph in any other way that violates
  201  * the above rules, an exception is thrown, the modification attempt is ignored
  202  * and the scene graph is restored to its previous state.
  203  * &lt;p&gt;
  204  * It is possible to rearrange the structure of the scene graph, for
  205  * example, to move a subtree from one location in the scene graph to
  206  * another. In order to do this, one would normally remove the subtree from
  207  * its old location before inserting it at the new location. However, the
  208  * subtree will be automatically removed as described above if the application
  209  * doesn&#39;t explicitly remove it.
  210  * &lt;p&gt;
  211  * Node objects may be constructed and modified on any thread as long they are
  212  * not yet attached to a {@link Scene} in a {@link Window} that is
  213  * {@link Window#isShowing showing}.
  214  * An application must attach nodes to such a Scene or modify them on the JavaFX
  215  * Application Thread.
  216  *
  217  * &lt;p&gt;
  218  * The JavaFX Application Thread is created as part of the startup process for
  219  * the JavaFX runtime. See the {@link javafx.application.Application} class and
  220  * the {@link Platform#startup(Runnable)} method for more information.
  221  * &lt;/p&gt;
  222  *
  223  * &lt;p&gt;
  224  * An application should not extend the Node class directly. Doing so may lead to
  225  * an UnsupportedOperationException being thrown.
  226  * &lt;/p&gt;
  227  *
  228  * &lt;h2&gt;String ID&lt;/h2&gt;
  229  * &lt;p&gt;
  230  * Each node in the scene graph can be given a unique {@link #idProperty id}. This id is
  231  * much like the &quot;id&quot; attribute of an HTML tag in that it is up to the designer
  232  * and developer to ensure that the {@code id} is unique within the scene graph.
  233  * A convenience function called {@link #lookup(String)} can be used to find
  234  * a node with a unique id within the scene graph, or within a subtree of the
  235  * scene graph. The id can also be used identify nodes for applying styles; see
  236  * the CSS section below.
  237  *
  238  * &lt;h2&gt;Coordinate System&lt;/h2&gt;
  239  * &lt;p&gt;
  240  * The {@code Node} class defines a traditional computer graphics &quot;local&quot;
  241  * coordinate system in which the {@code x} axis increases to the right and the
  242  * {@code y} axis increases downwards.  The concrete node classes for shapes
  243  * provide variables for defining the geometry and location of the shape
  244  * within this local coordinate space.  For example,
  245  * {@link javafx.scene.shape.Rectangle} provides {@code x}, {@code y},
  246  * {@code width}, {@code height} variables while
  247  * {@link javafx.scene.shape.Circle} provides {@code centerX}, {@code centerY},
  248  * and {@code radius}.
  249  * &lt;p&gt;
  250  * At the device pixel level, integer coordinates map onto the corners and
  251  * cracks between the pixels and the centers of the pixels appear at the
  252  * midpoints between integer pixel locations.  Because all coordinate values
  253  * are specified with floating point numbers, coordinates can precisely
  254  * point to these corners (when the floating point values have exact integer
  255  * values) or to any location on the pixel.  For example, a coordinate of
  256  * {@code (0.5, 0.5)} would point to the center of the upper left pixel on the
  257  * {@code Stage}.  Similarly, a rectangle at {@code (0, 0)} with dimensions
  258  * of {@code 10} by {@code 10} would span from the upper left corner of the
  259  * upper left pixel on the {@code Stage} to the lower right corner of the
  260  * 10th pixel on the 10th scanline.  The pixel center of the last pixel
  261  * inside that rectangle would be at the coordinates {@code (9.5, 9.5)}.
  262  * &lt;p&gt;
  263  * In practice, most nodes have transformations applied to their coordinate
  264  * system as mentioned below.  As a result, the information above describing
  265  * the alignment of device coordinates to the pixel grid is relative to
  266  * the transformed coordinates, not the local coordinates of the nodes.
  267  * The {@link javafx.scene.shape.Shape Shape} class describes some additional
  268  * important context-specific information about coordinate mapping and how
  269  * it can affect rendering.
  270  *
  271  * &lt;h2&gt;Transformations&lt;/h2&gt;
  272  * &lt;p&gt;
  273  * Any {@code Node} can have transformations applied to it. These include
  274  * translation, rotation, scaling, or shearing.
  275  * &lt;p&gt;
  276  * A &lt;b&gt;translation&lt;/b&gt; transformation is one which shifts the origin of the
  277  * node&#39;s coordinate space along either the x or y axis. For example, if you
  278  * create a {@link javafx.scene.shape.Rectangle} which is drawn at the origin
  279  * (x=0, y=0) and has a width of 100 and a height of 50, and then apply a
  280  * {@link javafx.scene.transform.Translate} with a shift of 10 along the x axis
  281  * (x=10), then the rectangle will appear drawn at (x=10, y=0) and remain
  282  * 100 points wide and 50 tall. Note that the origin was shifted, not the
  283  * {@code x} variable of the rectangle.
  284  * &lt;p&gt;
  285  * A common node transform is a translation by an integer distance, most often
  286  * used to lay out nodes on the stage.  Such integer translations maintain the
  287  * device pixel mapping so that local coordinates that are integers still
  288  * map to the cracks between pixels.
  289  * &lt;p&gt;
  290  * A &lt;b&gt;rotation&lt;/b&gt; transformation is one which rotates the coordinate space of
  291  * the node about a specified &quot;pivot&quot; point, causing the node to appear rotated.
  292  * For example, if you create a {@link javafx.scene.shape.Rectangle} which is
  293  * drawn at the origin (x=0, y=0) and has a width of 100 and height of 30 and
  294  * you apply a {@link javafx.scene.transform.Rotate} with a 90 degree rotation
  295  * (angle=90) and a pivot at the origin (pivotX=0, pivotY=0), then
  296  * the rectangle will be drawn as if its x and y were zero but its height was
  297  * 100 and its width -30. That is, it is as if a pin is being stuck at the top
  298  * left corner and the rectangle is rotating 90 degrees clockwise around that
  299  * pin. If the pivot point is instead placed in the center of the rectangle
  300  * (at point x=50, y=15) then the rectangle will instead appear to rotate about
  301  * its center.
  302  * &lt;p&gt;
  303  * Note that as with all transformations, the x, y, width, and height variables
  304  * of the rectangle (which remain relative to the local coordinate space) have
  305  * not changed, but rather the transformation alters the entire coordinate space
  306  * of the rectangle.
  307  * &lt;p&gt;
  308  * A &lt;b&gt;scaling&lt;/b&gt; transformation causes a node to either appear larger or
  309  * smaller depending on the scaling factor. Scaling alters the coordinate space
  310  * of the node such that each unit of distance along the axis in local
  311  * coordinates is multiplied by the scale factor. As with rotation
  312  * transformations, scaling transformations are applied about a &quot;pivot&quot; point.
  313  * You can think of this as the point in the {@code Node} around which you &quot;zoom&quot;.  For
  314  * example, if you create a {@link javafx.scene.shape.Rectangle} with a
  315  * {@code strokeWidth} of 5, and a width and height of 50, and you apply a
  316  * {@link javafx.scene.transform.Scale} with scale factors (x=2.0, y=2.0) and
  317  * a pivot at the origin (pivotX=0, pivotY=0), the entire rectangle
  318  * (including the stroke) will double in size, growing to the right and
  319  * downwards from the origin.
  320  * &lt;p&gt;
  321  * A &lt;b&gt;shearing&lt;/b&gt; transformation, sometimes called a skew, effectively
  322  * rotates one axis so that the x and y axes are no longer perpendicular.
  323  * &lt;p&gt;
  324  * Multiple transformations may be applied to a node by specifying an ordered
  325  * chain of transforms.  The order in which the transforms are applied is
  326  * defined by the ObservableList specified in the {@link #getTransforms transforms} variable.
  327  *
  328  * &lt;h2&gt;Bounding Rectangles&lt;/h2&gt;
  329  * &lt;p&gt;
  330  * Since every {@code Node} has transformations, every Node&#39;s geometric
  331  * bounding rectangle can be described differently depending on whether
  332  * transformations are accounted for or not.
  333  * &lt;p&gt;
  334  * Each {@code Node} has a read-only {@link #boundsInLocalProperty boundsInLocal}
  335  * variable which specifies the bounding rectangle of the {@code Node} in
  336  * untransformed local coordinates. {@code boundsInLocal} includes the
  337  * Node&#39;s shape geometry, including any space required for a
  338  * non-zero stroke that may fall outside the local position/size variables,
  339  * and its {@link #clipProperty clip} and {@link #effectProperty effect} variables.
  340  * &lt;p&gt;
  341  * Each {@code Node} also has a read-only {@link #boundsInParentProperty boundsInParent} variable which
  342  * specifies the bounding rectangle of the {@code Node} after all transformations
  343  * have been applied, including those set in {@link #getTransforms transforms},
  344  * {@link #scaleXProperty scaleX}/{@link #scaleYProperty scaleY}, {@link #rotateProperty rotate},
  345  * {@link #translateXProperty translateX}/{@link #translateYProperty translateY}, and {@link #layoutXProperty layoutX}/{@link #layoutYProperty layoutY}.
  346  * It is called &quot;boundsInParent&quot; because the rectangle will be relative to the
  347  * parent&#39;s coordinate system.  This is the &#39;visual&#39; bounds of the node.
  348  * &lt;p&gt;
  349  * Finally, the {@link #layoutBoundsProperty layoutBounds} variable defines the rectangular bounds of
  350  * the {@code Node} that should be used as the basis for layout calculations and
  351  * may differ from the visual bounds of the node.  For shapes, Text, and ImageView,
  352  * layoutBounds by default includes only the shape geometry, including space required
  353  * for a non-zero {@code strokeWidth}, but does &lt;i&gt;not&lt;/i&gt; include the effect,
  354  * clip, or any transforms. For resizable classes (Regions and Controls)
  355  * layoutBounds will always map to {@code 0,0 width x height}.
  356  *
  357  * &lt;p&gt; The image shows a node without any transformation and its {@code boundsInLocal}:
  358  * &lt;p&gt; &lt;img src=&quot;doc-files/boundsLocal.png&quot; alt=&quot;A sine wave shape enclosed by
  359  * an axis-aligned rectangular bounds&quot;&gt; &lt;/p&gt;
  360  * If we rotate the image by 20 degrees we get following result:
  361  * &lt;p&gt; &lt;img src=&quot;doc-files/boundsParent.png&quot; alt=&quot;An axis-aligned rectangular
  362  * bounds that encloses the shape rotated by 20 degrees&quot;&gt; &lt;/p&gt;
  363  * The red rectangle represents {@code boundsInParent} in the
  364  * coordinate space of the Node&#39;s parent. The {@code boundsInLocal} stays the same
  365  * as in the first image, the green rectangle in this image represents {@code boundsInLocal}
  366  * in the coordinate space of the Node.
  367  *
  368  * &lt;p&gt; The images show a filled and stroked rectangle and their bounds. The
  369  * first rectangle {@code [x:10.0 y:10.0 width:100.0 height:100.0 strokeWidth:0]}
  370  * has the following bounds bounds: {@code [x:10.0 y:10.0 width:100.0 height:100.0]}.
  371  *
  372  * The second rectangle {@code [x:10.0 y:10.0 width:100.0 height:100.0 strokeWidth:5]}
  373  * has the following bounds: {@code [x:7.5 y:7.5 width:105 height:105]}
  374  * (the stroke is centered by default, so only half of it is outside
  375  * of the original bounds; it is also possible to create inside or outside
  376  * stroke).
  377  *
  378  * Since neither of the rectangles has any transformation applied,
  379  * {@code boundsInParent} and {@code boundsInLocal} are the same. &lt;/p&gt;
  380  * &lt;p&gt; &lt;img src=&quot;doc-files/bounds.png&quot; alt=&quot;The rectangles are enclosed by their
  381  * respective bounds&quot;&gt; &lt;/p&gt;
  382  *
  383  *
  384  * &lt;h2&gt;CSS&lt;/h2&gt;
  385  * &lt;p&gt;
  386  * The {@code Node} class contains {@code id}, {@code styleClass}, and
  387  * {@code style} variables that are used in styling this node from
  388  * CSS. The {@code id} and {@code styleClass} variables are used in
  389  * CSS style sheets to identify nodes to which styles should be
  390  * applied. The {@code style} variable contains style properties and
  391  * values that are applied directly to this node.
  392  * &lt;p&gt;
  393  * For further information about CSS and how to apply CSS styles
  394  * to nodes, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
  395  * Guide&lt;/a&gt;.
  396  * @since JavaFX 2.0
  397  */
  398 @IDProperty(&quot;id&quot;)
  399 public abstract class Node implements EventTarget, Styleable {
  400 
  401     /*
  402      * Store the singleton instance of the NodeHelper subclass corresponding
  403      * to the subclass of this instance of Node
  404      */
  405     private NodeHelper nodeHelper = null;
  406 
  407     static {
  408         PerformanceTracker.logEvent(&quot;Node class loaded&quot;);
  409 
  410         // This is used by classes in different packages to get access to
  411         // private and package private methods.
  412         NodeHelper.setNodeAccessor(new NodeHelper.NodeAccessor() {
  413             @Override
  414             public NodeHelper getHelper(Node node) {
  415                 return node.nodeHelper;
  416             }
  417 
  418             @Override
  419             public void setHelper(Node node, NodeHelper nodeHelper) {
  420                 node.nodeHelper = nodeHelper;
  421             }
  422 
  423             @Override
  424             public void doMarkDirty(Node node, DirtyBits dirtyBit) {
  425                 node.doMarkDirty(dirtyBit);
  426             }
  427 
  428             @Override
  429             public void doUpdatePeer(Node node) {
  430                 node.doUpdatePeer();
  431             }
  432 
  433             @Override
  434             public BaseTransform getLeafTransform(Node node) {
  435                 return node.getLeafTransform();
  436             }
  437 
  438             @Override
  439             public Bounds doComputeLayoutBounds(Node node) {
  440                 return node.doComputeLayoutBounds();
  441             }
  442 
  443             @Override
  444             public void doTransformsChanged(Node node) {
  445                 node.doTransformsChanged();
  446             }
  447 
  448             @Override
  449             public void doPickNodeLocal(Node node, PickRay localPickRay,
  450                     PickResultChooser result) {
  451                 node.doPickNodeLocal(localPickRay, result);
  452             }
  453 
  454             @Override
  455             public boolean doComputeIntersects(Node node, PickRay pickRay,
  456                     PickResultChooser pickResult) {
  457                 return node.doComputeIntersects(pickRay, pickResult);
  458             }
  459 
  460             @Override
  461             public void doGeomChanged(Node node) {
  462                 node.doGeomChanged();
  463             }
  464 
  465             @Override
  466             public void doNotifyLayoutBoundsChanged(Node node) {
  467                 node.doNotifyLayoutBoundsChanged();
  468             }
  469 
  470             @Override
  471             public void doProcessCSS(Node node) {
  472                 node.doProcessCSS();
  473             }
  474 
  475             @Override
  476             public boolean isDirty(Node node, DirtyBits dirtyBit) {
  477                 return node.isDirty(dirtyBit);
  478             }
  479 
  480             @Override
  481             public boolean isDirtyEmpty(Node node) {
  482                 return node.isDirtyEmpty();
  483             }
  484 
  485             @Override
  486             public void syncPeer(Node node) {
  487                 node.syncPeer();
  488             }
  489 
  490             @Override
  491             public void layoutBoundsChanged(Node node) {
  492                 node.layoutBoundsChanged();
  493             }
  494 
  495             @Override
  496             public &lt;P extends NGNode&gt; P getPeer(Node node) {
  497                 return node.getPeer();
  498             }
  499 
  500             @Override
  501             public void setShowMnemonics(Node node, boolean value) {
  502                 node.setShowMnemonics(value);
  503             }
  504 
  505             @Override
  506             public boolean isShowMnemonics(Node node) {
  507                 return node.isShowMnemonics();
  508             }
  509 
  510             @Override
  511             public BooleanProperty showMnemonicsProperty(Node node) {
  512                 return node.showMnemonicsProperty();
  513             }
  514 
  515             @Override
  516             public boolean traverse(Node node, Direction direction) {
  517                 return node.traverse(direction);
  518             }
  519 
  520             @Override
  521             public double getPivotX(Node node) {
  522                 return node.getPivotX();
  523             }
  524 
  525             @Override
  526             public double getPivotY(Node node) {
  527                 return node.getPivotY();
  528             }
  529 
  530             @Override
  531             public double getPivotZ(Node node) {
  532                 return node.getPivotZ();
  533             }
  534 
  535             @Override
  536             public void pickNode(Node node,PickRay pickRay,
  537                     PickResultChooser result) {
  538                 node.pickNode(pickRay, result);
  539             }
  540 
  541             @Override
  542             public boolean intersects(Node node, PickRay pickRay,
  543                     PickResultChooser pickResult) {
  544                 return node.intersects(pickRay, pickResult);
  545             }
  546 
  547             @Override
  548             public double intersectsBounds(Node node, PickRay pickRay) {
  549                 return node.intersectsBounds(pickRay);
  550             }
  551 
  552             @Override
  553             public void layoutNodeForPrinting(Node node) {
  554                 node.doCSSLayoutSyncForSnapshot();
  555             }
  556 
  557             @Override
  558             public boolean isDerivedDepthTest(Node node) {
  559                 return node.isDerivedDepthTest();
  560             }
  561 
  562             @Override
  563             public SubScene getSubScene(Node node) {
  564                 return node.getSubScene();
  565             }
  566 
  567             @Override
  568             public void setLabeledBy(Node node, Node labeledBy) {
  569                 node.labeledBy = labeledBy;
  570             }
  571 
  572             @Override
  573             public Accessible getAccessible(Node node) {
  574                 return node.getAccessible();
  575             }
  576 
  577             @Override
  578             public void reapplyCSS(Node node) {
  579                 node.reapplyCSS();
  580             }
  581 
  582             @Override
  583             public boolean isTreeVisible(Node node) {
  584                 return node.isTreeVisible();
  585             }
  586 
  587             @Override
  588             public BooleanExpression treeVisibleProperty(Node node) {
  589                 return node.treeVisibleProperty();
  590             }
  591 
  592             @Override
  593             public boolean isTreeShowing(Node node) {
  594                 return node.isTreeShowing();
  595             }
  596 
  597             @Override
  598             public BooleanExpression treeShowingProperty(Node node) {
  599                 return node.treeShowingProperty();
  600             }
  601 
  602             @Override
  603             public List&lt;Style&gt; getMatchingStyles(CssMetaData cssMetaData,
  604                     Styleable styleable) {
  605                 return Node.getMatchingStyles(cssMetaData, styleable);
  606             }
  607 
  608             @Override
  609             public Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; findStyles(Node node,
  610                     Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; styleMap) {
  611                 return node.findStyles(styleMap);
  612             }
  613         });
  614     }
  615 
  616     /**************************************************************************
  617      *                                                                        *
  618      * Methods and state for managing the dirty bits of a Node. The dirty     *
  619      * bits are flags used to keep track of what things are dirty on the      *
  620      * node and therefore need processing on the next pulse. Since the pulse  *
  621      * happens asynchronously to the change that made the node dirty (for     *
  622      * performance reasons), we need to keep track of what things have        *
  623      * changed.                                                               *
  624      *                                                                        *
  625      *************************************************************************/
  626 
  627     /**
  628      * Set of dirty bits that are set when state is invalidated and cleared by
  629      * the updateState method, which is called from the synchronizer.
  630      * &lt;p&gt;
  631      * A node starts dirty.
  632      */
  633     private Set&lt;DirtyBits&gt; dirtyBits = EnumSet.allOf(DirtyBits.class);
  634 
  635     /**
  636      * Mark the specified bit as dirty, and add this node to the scene&#39;s dirty list.
  637      *
  638      * Note: This method MUST only be called via its accessor method.
  639      */
  640     private void doMarkDirty(DirtyBits dirtyBit) {
  641         if (isDirtyEmpty()) {
  642             addToSceneDirtyList();
  643         }
  644 
  645         dirtyBits.add(dirtyBit);
  646     }
  647 
  648     private void addToSceneDirtyList() {
  649         Scene s = getScene();
  650         if (s != null) {
  651             s.addToDirtyList(this);
  652             if (getSubScene() != null) {
  653                 getSubScene().setDirty(this);
  654             }
  655         }
  656     }
  657 
  658     /**
  659      * Test whether the specified dirty bit is set
  660      */
  661     final boolean isDirty(DirtyBits dirtyBit) {
  662         return dirtyBits.contains(dirtyBit);
  663     }
  664 
  665     /**
  666      * Clear the specified dirty bit
  667      */
  668     final void clearDirty(DirtyBits dirtyBit) {
  669         dirtyBits.remove(dirtyBit);
  670     }
  671 
  672     /**
  673      * Clear all dirty bits
  674      */
  675     private void clearDirty() {
  676         dirtyBits.clear();
  677     }
  678 
  679     /**
  680      * Test whether the set of dirty bits is empty
  681      */
  682     private boolean isDirtyEmpty() {
  683         return dirtyBits.isEmpty();
  684     }
  685 
  686     /**************************************************************************
  687      *                                                                        *
  688      * Methods for synchronizing state from this Node to its PG peer. This    *
  689      * should only *ever* be called during synchronization initialized as a   *
  690      * result of a pulse. Any attempt to synchronize at any other time may    *
  691      * cause rendering artifacts.                                             *
  692      *                                                                        *
  693      *************************************************************************/
  694 
  695     /**
  696      * Called by the synchronizer to update the state and
  697      * clear dirtybits of this node in the PG graph
  698      */
  699     final void syncPeer() {
  700         // Do not synchronize invisible nodes unless their visibility has changed
  701         // or they have requested a forced synchronization
  702         if (!isDirtyEmpty() &amp;&amp; (treeVisible
  703                                      || isDirty(DirtyBits.NODE_VISIBLE)
  704                                      || isDirty(DirtyBits.NODE_FORCE_SYNC)))
  705         {
  706             NodeHelper.updatePeer(this);
  707             clearDirty();
  708         }
  709     }
  710 
  711     /**
  712      * A temporary rect used for computing bounds by the various bounds
  713      * variables. This bounds starts life as a RectBounds, but may be promoted
  714      * to a BoxBounds if there is a 3D transform mixed into its computation.
  715      * These two fields were held in a thread local, but were then pulled
  716      * out of it so that we could compute bounds before holding the
  717      * synchronization lock. These objects have to be per-instance so
  718      * that we can pass the right data down to the PG side later during
  719      * synchronization (rather than statics as they were before).
  720      */
  721     private BaseBounds _geomBounds = new RectBounds(0, 0, -1, -1);
  722     private BaseBounds _txBounds = new RectBounds(0, 0, -1, -1);
  723 
  724     private boolean pendingUpdateBounds = false;
  725 
  726     // Happens before we hold the sync lock
  727     void updateBounds() {
  728         // Note: the clip must be handled before the visibility is checked. This is because the visiblity might be
  729         // changing in the clip and it is going to be synchronized, so it needs to recompute the bounds.
  730         Node n = getClip();
  731         if (n != null) {
  732             n.updateBounds();
  733         }
  734 
  735         // See syncPeer()
  736         if (!treeVisible &amp;&amp; !isDirty(DirtyBits.NODE_VISIBLE)) {
  737 
  738             // Need to save the dirty bits since they will be cleared even for the
  739             // case of short circuiting dirty bit processing.
  740             if (isDirty(DirtyBits.NODE_TRANSFORM)
  741                     || isDirty(DirtyBits.NODE_TRANSFORMED_BOUNDS)
  742                     || isDirty(DirtyBits.NODE_BOUNDS)) {
  743                 pendingUpdateBounds = true;
  744             }
  745 
  746             return;
  747         }
  748 
  749         // Set transform and bounds dirty bits when this node becomes visible
  750         if (pendingUpdateBounds) {
  751             NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORM);
  752             NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORMED_BOUNDS);
  753             NodeHelper.markDirty(this, DirtyBits.NODE_BOUNDS);
  754 
  755             pendingUpdateBounds = false;
  756         }
  757 
  758         if (isDirty(DirtyBits.NODE_TRANSFORM) || isDirty(DirtyBits.NODE_TRANSFORMED_BOUNDS)) {
  759             if (isDirty(DirtyBits.NODE_TRANSFORM)) {
  760                 updateLocalToParentTransform();
  761             }
  762             _txBounds = getTransformedBounds(_txBounds,
  763                                              BaseTransform.IDENTITY_TRANSFORM);
  764         }
  765 
  766         if (isDirty(DirtyBits.NODE_BOUNDS)) {
  767             _geomBounds = getGeomBounds(_geomBounds,
  768                     BaseTransform.IDENTITY_TRANSFORM);
  769         }
  770 
  771     }
  772 
  773     /*
  774      * This function is called during synchronization to update the state of the
  775      * NG Node from the FX Node. Subclasses of Node should override this method
  776      * and must call NodeHelper.updatePeer(this)
  777      *
  778      * Note: This method MUST only be called via its accessor method.
  779      */
  780     private void doUpdatePeer() {
  781         final NGNode peer = getPeer();
  782 
  783         // For debug / diagnostic purposes, we will copy across a name for this node down to
  784         // the NG layer, where we can use the name to figure out what the NGNode represents.
  785         // An alternative would be to have a back-reference from the NGNode back to the Node it
  786         // is a peer to, however it was felt that this would make it too easy to communicate back
  787         // to the Node and possibly violate thread invariants. But of course, we only need to do this
  788         // if we&#39;re going to print the render graph (otherwise all the work we&#39;d do to keep the name
  789         // properly updated would be a waste).
  790         if (PrismSettings.printRenderGraph &amp;&amp; isDirty(DirtyBits.DEBUG)) {
  791             final String id = getId();
  792             String className = getClass().getSimpleName();
  793             if (className.isEmpty()) {
  794                 className = getClass().getName();
  795             }
  796             peer.setName(id == null ? className : id + &quot;(&quot; + className + &quot;)&quot;);
  797         }
  798 
  799         if (isDirty(DirtyBits.NODE_TRANSFORM)) {
  800             peer.setTransformMatrix(localToParentTx);
  801         }
  802 
  803         if (isDirty(DirtyBits.NODE_VIEW_ORDER)) {
  804             peer.setViewOrder(getViewOrder());
  805         }
  806 
  807         if (isDirty(DirtyBits.NODE_BOUNDS)) {
  808             peer.setContentBounds(_geomBounds);
  809         }
  810 
  811         if (isDirty(DirtyBits.NODE_TRANSFORMED_BOUNDS)) {
  812             peer.setTransformedBounds(_txBounds, !isDirty(DirtyBits.NODE_BOUNDS));
  813         }
  814 
  815         if (isDirty(DirtyBits.NODE_OPACITY)) {
  816             peer.setOpacity((float)Utils.clamp(0, getOpacity(), 1));
  817         }
  818 
  819         if (isDirty(DirtyBits.NODE_CACHE)) {
  820             peer.setCachedAsBitmap(isCache(), getCacheHint());
  821         }
  822 
  823         if (isDirty(DirtyBits.NODE_CLIP)) {
  824             peer.setClipNode(getClip() != null ? getClip().getPeer() : null);
  825         }
  826 
  827         if (isDirty(DirtyBits.EFFECT_EFFECT)) {
  828             if (getEffect() != null) {
  829                 EffectHelper.sync(getEffect());
  830                 peer.effectChanged();
  831             }
  832         }
  833 
  834         if (isDirty(DirtyBits.NODE_EFFECT)) {
  835             peer.setEffect(getEffect() != null ? EffectHelper.getPeer(getEffect()) : null);
  836         }
  837 
  838         if (isDirty(DirtyBits.NODE_VISIBLE)) {
  839             peer.setVisible(isVisible());
  840         }
  841 
  842         if (isDirty(DirtyBits.NODE_DEPTH_TEST)) {
  843             peer.setDepthTest(isDerivedDepthTest());
  844         }
  845 
  846         if (isDirty(DirtyBits.NODE_BLENDMODE)) {
  847             BlendMode mode = getBlendMode();
  848             peer.setNodeBlendMode((mode == null)
  849                                   ? null
  850                                   : EffectHelper.getToolkitBlendMode(mode));
  851         }
  852     }
  853 
  854     /*************************************************************************
  855     *                                                                        *
  856     *                                                                        *
  857     *                                                                        *
  858     *************************************************************************/
  859 
  860     private static final Object USER_DATA_KEY = new Object();
  861     // A map containing a set of properties for this node
  862     private ObservableMap&lt;Object, Object&gt; properties;
  863 
  864     /**
  865      * Returns an observable map of properties on this node for use primarily by application developers.
  866      *
  867      * @return an observable map of properties on this node for use primarily by application developers
  868      * @apiNote Layout managers use this map as well to specify layout constraints on the node, such as {@code HBox#setHgrow}, so the
  869      *          developer should be mindful of clearing the map or overriding its values. These entries are not removed automatically
  870      *          if the node is removed from the layout manager, so unused entries can exist throughout the life of the node.
  871      */
  872      public final ObservableMap&lt;Object, Object&gt; getProperties() {
  873         if (properties == null) {
  874             properties = FXCollections.observableMap(new HashMap&lt;Object, Object&gt;());
  875         }
  876         return properties;
  877     }
  878 
  879     /**
  880      * Tests if Node has properties.
  881      * @return true if node has properties.
  882      */
  883      public boolean hasProperties() {
  884         return properties != null &amp;&amp; !properties.isEmpty();
  885     }
  886 
  887     /**
  888      * Convenience method for setting a single Object property that can be
  889      * retrieved at a later date. This is functionally equivalent to calling
  890      * the getProperties().put(Object key, Object value) method. This can later
  891      * be retrieved by calling {@link Node#getUserData()}.
  892      *
  893      * @param value The value to be stored - this can later be retrieved by calling
  894      *          {@link Node#getUserData()}.
  895      */
  896     public void setUserData(Object value) {
  897         getProperties().put(USER_DATA_KEY, value);
  898     }
  899 
  900     /**
  901      * Returns a previously set Object property, or null if no such property
  902      * has been set using the {@link Node#setUserData(java.lang.Object)} method.
  903      *
  904      * @return The Object that was previously set, or null if no property
  905      *          has been set or if null was set.
  906      */
  907     public Object getUserData() {
  908         return getProperties().get(USER_DATA_KEY);
  909     }
  910 
  911     /**************************************************************************
  912      *                                                                        *
  913      *
  914      *                                                                        *
  915      *************************************************************************/
  916 
  917     /**
  918      * The parent of this {@code Node}. If this {@code Node} has not been added
  919      * to a scene graph, then parent will be null.
  920      *
  921      * @defaultValue null
  922      */
  923     private ReadOnlyObjectWrapper&lt;Parent&gt; parent;
  924 
  925     final void setParent(Parent value) {
  926         parentPropertyImpl().set(value);
  927     }
  928 
  929     public final Parent getParent() {
  930         return parent == null ? null : parent.get();
  931     }
  932 
  933     public final ReadOnlyObjectProperty&lt;Parent&gt; parentProperty() {
  934         return parentPropertyImpl().getReadOnlyProperty();
  935     }
  936 
  937     private ReadOnlyObjectWrapper&lt;Parent&gt; parentPropertyImpl() {
  938         if (parent == null) {
  939             parent = new ReadOnlyObjectWrapper&lt;Parent&gt;() {
  940                 private Parent oldParent;
  941 
  942                 @Override
  943                 protected void invalidated() {
  944                     if (oldParent != null) {
  945                         oldParent.disabledProperty().removeListener(parentDisabledChangedListener);
  946                         oldParent.treeVisibleProperty().removeListener(parentTreeVisibleChangedListener);
  947                         if (nodeTransformation != null &amp;&amp; nodeTransformation.listenerReasons &gt; 0) {
  948                             ((Node) oldParent).localToSceneTransformProperty().removeListener(
  949                                     nodeTransformation.getLocalToSceneInvalidationListener());
  950                         }
  951                     }
  952                     updateDisabled();
  953                     computeDerivedDepthTest();
  954                     final Parent newParent = get();
  955                     if (newParent != null) {
  956                         newParent.disabledProperty().addListener(parentDisabledChangedListener);
  957                         newParent.treeVisibleProperty().addListener(parentTreeVisibleChangedListener);
  958                         if (nodeTransformation != null &amp;&amp; nodeTransformation.listenerReasons &gt; 0) {
  959                             ((Node) newParent).localToSceneTransformProperty().addListener(
  960                                     nodeTransformation.getLocalToSceneInvalidationListener());
  961                         }
  962                         //
  963                         // if parent changed, then CSS needs to be reapplied so
  964                         // that this node will get the right styles. This used
  965                         // to be done from Parent.children&#39;s onChanged method.
  966                         // See the comments there, also.
  967                         //
  968                         reapplyCSS();
  969                     } else {
  970                         // RT-31168: reset CssFlag to clean so css will be reapplied if the node is added back later.
  971                         // If flag is REAPPLY, then reapplyCSS() will just return and the call to
  972                         // notifyParentsOfInvalidatedCSS() will be skipped thus leaving the node un-styled.
  973                         cssFlag = CssFlags.CLEAN;
  974                     }
  975                     updateTreeVisible(true);
  976                     oldParent = newParent;
  977                     invalidateLocalToSceneTransform();
  978                     parentResolvedOrientationInvalidated();
  979                     notifyAccessibleAttributeChanged(AccessibleAttribute.PARENT);
  980                 }
  981 
  982                 @Override
  983                 public Object getBean() {
  984                     return Node.this;
  985                 }
  986 
  987                 @Override
  988                 public String getName() {
  989                     return &quot;parent&quot;;
  990                 }
  991             };
  992         }
  993         return parent;
  994     }
  995 
  996     private final InvalidationListener parentDisabledChangedListener = valueModel -&gt; updateDisabled();
  997 
  998     private final InvalidationListener parentTreeVisibleChangedListener = valueModel -&gt; updateTreeVisible(true);
  999 
 1000     private final ChangeListener&lt;Boolean&gt; windowShowingChangedListener
 1001             = (win, oldVal, newVal) -&gt; updateTreeShowing();
 1002 
 1003     private final ChangeListener&lt;Window&gt; sceneWindowChangedListener = (scene, oldWindow, newWindow) -&gt; {
 1004         // Replace the windowShowingListener and call updateTreeShowing()
 1005         if (oldWindow != null) {
 1006             oldWindow.showingProperty().removeListener(windowShowingChangedListener);
 1007         }
 1008         if (newWindow != null) {
 1009             newWindow.showingProperty().addListener(windowShowingChangedListener);
 1010         }
 1011         updateTreeShowing();
 1012     };
 1013 
 1014     private SubScene subScene = null;
 1015 
 1016     /**
 1017      * The {@link Scene} that this {@code Node} is part of. If the Node is not
 1018      * part of a scene, then this variable will be null.
 1019      *
 1020      * @defaultValue null
 1021      */
 1022     private ReadOnlyObjectWrapperManualFire&lt;Scene&gt; scene = new ReadOnlyObjectWrapperManualFire&lt;Scene&gt;();
 1023 
 1024     private class ReadOnlyObjectWrapperManualFire&lt;T&gt; extends ReadOnlyObjectWrapper&lt;T&gt; {
 1025         @Override
 1026         public Object getBean() {
 1027             return Node.this;
 1028         }
 1029 
 1030         @Override
 1031         public String getName() {
 1032             return &quot;scene&quot;;
 1033         }
 1034 
 1035         @Override
 1036         protected void fireValueChangedEvent() {
 1037             /*
 1038              * Note: This method has been intentionally made into a no-op. In
 1039              * order to override the default set behavior. By default calling
 1040              * set(...) on a different scene will trigger:
 1041              * - invalidated();
 1042              * - fireValueChangedEvent();
 1043              * Both of the above are no-ops, but are handled manually via
 1044              * - Node.this.setScenes(...)
 1045              * - Node.this.invalidatedScenes(...)
 1046              * - forceValueChangedEvent()
 1047              */
 1048         }
 1049 
 1050         public void fireSuperValueChangedEvent() {
 1051             super.fireValueChangedEvent();
 1052         }
 1053     }
 1054 
 1055     private void invalidatedScenes(Scene oldScene, SubScene oldSubScene) {
 1056         Scene newScene = sceneProperty().get();
 1057         boolean sceneChanged = oldScene != newScene;
 1058         SubScene newSubScene = subScene;
 1059 
 1060         if (getClip() != null) {
 1061             getClip().setScenes(newScene, newSubScene);
 1062         }
 1063         if (sceneChanged) {
 1064             updateCanReceiveFocus();
 1065             if (isFocusTraversable()) {
 1066                 if (newScene != null) {
 1067                     newScene.initializeInternalEventDispatcher();
 1068                 }
 1069             }
 1070             focusSetDirty(oldScene);
 1071             focusSetDirty(newScene);
 1072         }
 1073         scenesChanged(newScene, newSubScene, oldScene, oldSubScene);
 1074 
 1075         // isTreeShowing needs to take into account of Window&#39;s showing
 1076         if (oldScene != null) {
 1077             oldScene.windowProperty().removeListener(sceneWindowChangedListener);
 1078 
 1079             Window window = oldScene.windowProperty().get();
 1080             if (window != null) {
 1081                 window.showingProperty().removeListener(windowShowingChangedListener);
 1082             }
 1083         }
 1084         if (newScene != null) {
 1085             newScene.windowProperty().addListener(sceneWindowChangedListener);
 1086 
 1087             Window window = newScene.windowProperty().get();
 1088             if (window != null) {
 1089                 window.showingProperty().addListener(windowShowingChangedListener);
 1090             }
 1091 
 1092         }
 1093         updateTreeShowing();
 1094 
 1095         if (sceneChanged) reapplyCSS();
 1096 
 1097         if (sceneChanged &amp;&amp; !isDirtyEmpty()) {
 1098             //Note: no need to remove from scene&#39;s dirty list
 1099             //Scene&#39;s is checking if the node&#39;s scene is correct
 1100             /* TODO: looks like an existing bug when a node is moved from one
 1101              * location to another, setScenes will be called twice by
 1102              * Parent.VetoableListDecorator onProposedChange and onChanged
 1103              * respectively. Removing the node and setting setScense(null,null)
 1104              * then adding it back to potentially the same scene. Causing the
 1105              * same node to being added twice to the same scene.
 1106              */
 1107             addToSceneDirtyList();
 1108         }
 1109 
 1110         if (newScene == null &amp;&amp; peer != null) {
 1111             peer.release();
 1112         }
 1113 
 1114         if (oldScene != null) {
 1115             oldScene.clearNodeMnemonics(this);
 1116         }
 1117         if (getParent() == null) {
 1118             // if we are the root we need to handle scene change
 1119             parentResolvedOrientationInvalidated();
 1120         }
 1121 
 1122         if (sceneChanged) { scene.fireSuperValueChangedEvent(); }
 1123 
 1124         /* Dispose the accessible peer, if any. If AT ever needs this node again
 1125          * a new accessible peer is created. */
 1126         if (accessible != null) {
 1127             /* Generally accessibility does not retain any state, therefore deleting objects
 1128              * generally does not cause problems (AT just asks everything back).
 1129              * The exception to this rule is when the object sends a notifications to the AT,
 1130              * in which case it is expected to be around to answer request for the new values.
 1131              * It is possible that a object is reparented (within the scene) in the middle of
 1132              * this process. For example, when a tree item is expanded, the notification is
 1133              * sent to the AT by the cell. But when the TreeView relayouts the cell can be
 1134              * reparented before AT can query the relevant information about the expand event.
 1135              * If the accessible was disposed, AT can&#39;t properly report the event.
 1136              *
 1137              * The fix is to defer the disposal of the accessible to the next pulse.
 1138              * If at that time the node is placed back to the scene, then the accessible is hooked
 1139              * to Node and AT requests are processed. Otherwise the accessible is disposed.
 1140              */
 1141             if (oldScene != null &amp;&amp; oldScene != newScene &amp;&amp; newScene == null) {
 1142                 // Strictly speaking we need some type of accessible.thaw() at this point.
 1143                 oldScene.addAccessible(Node.this, accessible);
 1144             } else {
 1145                 accessible.dispose();
 1146             }
 1147             /* Always set to null to ensure this accessible is never on more than one
 1148              * Scene#accMap at the same time (At lest not with the same accessible).
 1149              */
 1150             accessible = null;
 1151         }
 1152     }
 1153 
 1154     final void setScenes(Scene newScene, SubScene newSubScene) {
 1155         Scene oldScene = sceneProperty().get();
 1156         if (newScene != oldScene || newSubScene != subScene) {
 1157             scene.set(newScene);
 1158             SubScene oldSubScene = subScene;
 1159             subScene = newSubScene;
 1160             invalidatedScenes(oldScene, oldSubScene);
 1161             if (this instanceof SubScene) { // TODO: find better solution
 1162                 SubScene thisSubScene = (SubScene)this;
 1163                 thisSubScene.getRoot().setScenes(newScene, thisSubScene);
 1164             }
 1165         }
 1166     }
 1167 
 1168     final SubScene getSubScene() {
 1169         return subScene;
 1170     }
 1171 
 1172     public final Scene getScene() {
 1173         return scene.get();
 1174     }
 1175 
 1176     public final ReadOnlyObjectProperty&lt;Scene&gt; sceneProperty() {
 1177         return scene.getReadOnlyProperty();
 1178     }
 1179 
 1180     /**
 1181      * Exists for Parent and LightBase
 1182      */
 1183     void scenesChanged(final Scene newScene, final SubScene newSubScene,
 1184                        final Scene oldScene, final SubScene oldSubScene) { }
 1185 
 1186 
 1187     /**
 1188      * The id of this {@code Node}. This simple string identifier is useful for
 1189      * finding a specific Node within the scene graph. While the id of a Node
 1190      * should be unique within the scene graph, this uniqueness is not enforced.
 1191      * This is analogous to the &quot;id&quot; attribute on an HTML element
 1192      * (&lt;a href=&quot;http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier&quot;&gt;CSS ID Specification&lt;/a&gt;).
 1193      * &lt;p&gt;
 1194      *     For example, if a Node is given the id of &quot;myId&quot;, then the lookup method can
 1195      *     be used to find this node as follows: &lt;code&gt;scene.lookup(&quot;#myId&quot;);&lt;/code&gt;.
 1196      * &lt;/p&gt;
 1197      *
 1198      * @defaultValue null
 1199      * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
 1200      */
 1201     private StringProperty id;
 1202 
 1203     public final void setId(String value) {
 1204         idProperty().set(value);
 1205     }
 1206 
 1207     //TODO: this is copied from the property in order to add the @return statement.
 1208     //      We should have a better, general solution without the need to copy it.
 1209     /**
 1210      * The id of this {@code Node}. This simple string identifier is useful for
 1211      * finding a specific Node within the scene graph. While the id of a Node
 1212      * should be unique within the scene graph, this uniqueness is not enforced.
 1213      * This is analogous to the &quot;id&quot; attribute on an HTML element
 1214      * (&lt;a href=&quot;http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier&quot;&gt;CSS ID Specification&lt;/a&gt;).
 1215      *
 1216      * @return the id assigned to this {@code Node} using the {@code setId}
 1217      *         method or {@code null}, if no id has been assigned.
 1218      * @defaultValue null
 1219      * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;
 1220      */
 1221     public final String getId() {
 1222         return id == null ? null : id.get();
 1223     }
 1224 
 1225     public final StringProperty idProperty() {
 1226         if (id == null) {
 1227             id = new StringPropertyBase() {
 1228 
 1229                 @Override
 1230                 protected void invalidated() {
 1231                     reapplyCSS();
 1232                     if (PrismSettings.printRenderGraph) {
 1233                         NodeHelper.markDirty(Node.this, DirtyBits.DEBUG);
 1234                     }
 1235                 }
 1236 
 1237                 @Override
 1238                 public Object getBean() {
 1239                     return Node.this;
 1240                 }
 1241 
 1242                 @Override
 1243                 public String getName() {
 1244                     return &quot;id&quot;;
 1245                 }
 1246             };
 1247         }
 1248         return id;
 1249     }
 1250 
 1251     /**
 1252      * A list of String identifiers which can be used to logically group
 1253      * Nodes, specifically for an external style engine. This variable is
 1254      * analogous to the &quot;class&quot; attribute on an HTML element and, as such,
 1255      * each element of the list is a style class to which this Node belongs.
 1256      *
 1257      * @see &lt;a href=&quot;http://www.w3.org/TR/css3-selectors/#class-html&quot;&gt;CSS3 class selectors&lt;/a&gt;
 1258      * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
 1259      * @defaultValue null
 1260      */
 1261     private ObservableList&lt;String&gt; styleClass = new TrackableObservableList&lt;String&gt;() {
 1262         @Override
 1263         protected void onChanged(Change&lt;String&gt; c) {
 1264             reapplyCSS();
 1265         }
 1266 
 1267         @Override
 1268         public String toString() {
 1269             if (size() == 0) {
 1270                 return &quot;&quot;;
 1271             } else if (size() == 1) {
 1272                 return get(0);
 1273             } else {
 1274                 StringBuilder buf = new StringBuilder();
 1275                 for (int i = 0; i &lt; size(); i++) {
 1276                     buf.append(get(i));
 1277                     if (i + 1 &lt; size()) {
 1278                         buf.append(&#39; &#39;);
 1279                     }
 1280                 }
 1281                 return buf.toString();
 1282             }
 1283         }
 1284     };
 1285 
 1286     @Override
 1287     public final ObservableList&lt;String&gt; getStyleClass() {
 1288         return styleClass;
 1289     }
 1290 
 1291     /**
 1292      * A string representation of the CSS style associated with this
 1293      * specific {@code Node}. This is analogous to the &quot;style&quot; attribute of an
 1294      * HTML element. Note that, like the HTML style attribute, this
 1295      * variable contains style properties and values and not the
 1296      * selector portion of a style rule.
 1297      * @defaultValue empty string
 1298      * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
 1299      */
 1300     private StringProperty style;
 1301 
 1302     /**
 1303      * A string representation of the CSS style associated with this
 1304      * specific {@code Node}. This is analogous to the &quot;style&quot; attribute of an
 1305      * HTML element. Note that, like the HTML style attribute, this
 1306      * variable contains style properties and values and not the
 1307      * selector portion of a style rule.
 1308      * @param value The inline CSS style to use for this {@code Node}.
 1309      *         {@code null} is implicitly converted to an empty String.
 1310      * @defaultValue empty string
 1311      * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;
 1312      */
 1313     public final void setStyle(String value) {
 1314         styleProperty().set(value);
 1315     }
 1316 
 1317     // TODO: javadoc copied from property for the sole purpose of providing a return tag
 1318     /**
 1319      * A string representation of the CSS style associated with this
 1320      * specific {@code Node}. This is analogous to the &quot;style&quot; attribute of an
 1321      * HTML element. Note that, like the HTML style attribute, this
 1322      * variable contains style properties and values and not the
 1323      * selector portion of a style rule.
 1324      * @defaultValue empty string
 1325      * @return The inline CSS style associated with this {@code Node}.
 1326      *         If this {@code Node} does not have an inline style,
 1327      *         an empty String is returned.
 1328      * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;
 1329      */
 1330     public final String getStyle() {
 1331         return style == null ? &quot;&quot; : style.get();
 1332     }
 1333 
 1334     public final StringProperty styleProperty() {
 1335         if (style == null) {
 1336             style = new StringPropertyBase(&quot;&quot;) {
 1337 
 1338                 @Override public void set(String value) {
 1339                     // getStyle returns an empty string if the style property
 1340                     // is null. To be consistent, getStyle should also return
 1341                     // an empty string when the style property&#39;s value is null.
 1342                     super.set((value != null) ? value : &quot;&quot;);
 1343                 }
 1344 
 1345                 @Override
 1346                 protected void invalidated() {
 1347                     // If the style has changed, then styles of this node
 1348                     // and child nodes might be affected.
 1349                     reapplyCSS();
 1350                 }
 1351 
 1352                 @Override
 1353                 public Object getBean() {
 1354                     return Node.this;
 1355                 }
 1356 
 1357                 @Override
 1358                 public String getName() {
 1359                     return &quot;style&quot;;
 1360                 }
 1361             };
 1362         }
 1363         return style;
 1364     }
 1365 
 1366     /**
 1367      * Specifies whether this {@code Node} and any subnodes should be rendered
 1368      * as part of the scene graph. A node may be visible and yet not be shown
 1369      * in the rendered scene if, for instance, it is off the screen or obscured
 1370      * by another Node. Invisible nodes never receive mouse events or
 1371      * keyboard focus and never maintain keyboard focus when they become
 1372      * invisible.
 1373      *
 1374      * @defaultValue true
 1375      */
 1376     private BooleanProperty visible;
 1377 
 1378     public final void setVisible(boolean value) {
 1379         visibleProperty().set(value);
 1380     }
 1381 
 1382     public final boolean isVisible() {
 1383         return visible == null ? true : visible.get();
 1384     }
 1385 
 1386     public final BooleanProperty visibleProperty() {
 1387         if (visible == null) {
 1388             visible = new StyleableBooleanProperty(true) {
 1389                 boolean oldValue = true;
 1390                 @Override
 1391                 protected void invalidated() {
 1392                     if (oldValue != get()) {
 1393                         NodeHelper.markDirty(Node.this, DirtyBits.NODE_VISIBLE);
 1394                         NodeHelper.geomChanged(Node.this);
 1395                         updateTreeVisible(false);
 1396                         if (getParent() != null) {
 1397                             // notify the parent of the potential change in visibility
 1398                             // of this node, since visibility affects bounds of the
 1399                             // parent node
 1400                             getParent().childVisibilityChanged(Node.this);
 1401                         }
 1402                         oldValue = get();
 1403                     }
 1404                 }
 1405 
 1406                 @Override
 1407                 public CssMetaData getCssMetaData() {
 1408                     return StyleableProperties.VISIBILITY;
 1409                 }
 1410 
 1411                 @Override
 1412                 public Object getBean() {
 1413                     return Node.this;
 1414                 }
 1415 
 1416                 @Override
 1417                 public String getName() {
 1418                     return &quot;visible&quot;;
 1419                 }
 1420             };
 1421         }
 1422         return visible;
 1423     }
 1424 
 1425     public final void setCursor(Cursor value) {
 1426         cursorProperty().set(value);
 1427     }
 1428 
 1429     public final Cursor getCursor() {
 1430         return (miscProperties == null) ? DEFAULT_CURSOR
 1431                                         : miscProperties.getCursor();
 1432     }
 1433 
 1434     /**
 1435      * Defines the mouse cursor for this {@code Node} and subnodes. If null,
 1436      * then the cursor of the first parent node with a non-null cursor will be
 1437      * used. If no Node in the scene graph defines a cursor, then the cursor
 1438      * of the {@code Scene} will be used.
 1439      *
 1440      * @return the mouse cursor for this {@code Node} and subnodes
 1441      * @defaultValue null
 1442      */
 1443     public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
 1444         return getMiscProperties().cursorProperty();
 1445     }
 1446 
 1447     /**
 1448      * Specifies how opaque (that is, solid) the {@code Node} appears. A Node
 1449      * with 0% opacity is fully translucent. That is, while it is still
 1450      * {@link #visibleProperty visible} and rendered, you generally won&#39;t be able to see it. The
 1451      * exception to this rule is when the {@code Node} is combined with a
 1452      * blending mode and blend effect in which case a translucent Node may still
 1453      * have an impact in rendering. An opacity of 50% will render the node as
 1454      * being 50% transparent.
 1455      * &lt;p&gt;
 1456      * A {@link #visibleProperty visible} node with any opacity setting still receives mouse
 1457      * events and can receive keyboard focus. For example, if you want to have
 1458      * a large invisible rectangle overlay all {@code Node}s in the scene graph
 1459      * in order to intercept mouse events but not be visible to the user, you could
 1460      * create a large {@code Rectangle} that had an opacity of 0%.
 1461      * &lt;p&gt;
 1462      * Opacity is specified as a value between 0 and 1. Values less than 0 are
 1463      * treated as 0, values greater than 1 are treated as 1.
 1464      * &lt;p&gt;
 1465      * On some platforms ImageView might not support opacity variable.
 1466      *
 1467      * &lt;p&gt;
 1468      * There is a known limitation of mixing opacity &amp;lt; 1.0 with a 3D Transform.
 1469      * Opacity/Blending is essentially a 2D image operation. The result of
 1470      * an opacity &amp;lt; 1.0 set on a {@link Group} node with 3D transformed children
 1471      * will cause its children to be rendered in order without Z-buffering
 1472      * applied between those children.
 1473      *
 1474      * @defaultValue 1.0
 1475      */
 1476     private DoubleProperty opacity;
 1477 
 1478     public final void setOpacity(double value) {
 1479         opacityProperty().set(value);
 1480     }
 1481     public final double getOpacity() {
 1482         return opacity == null ? 1 : opacity.get();
 1483     }
 1484 
 1485     public final DoubleProperty opacityProperty() {
 1486         if (opacity == null) {
 1487             opacity = new StyleableDoubleProperty(1) {
 1488 
 1489                 @Override
 1490                 public void invalidated() {
 1491                     NodeHelper.markDirty(Node.this, DirtyBits.NODE_OPACITY);
 1492                 }
 1493 
 1494                 @Override
 1495                 public CssMetaData getCssMetaData() {
 1496                     return StyleableProperties.OPACITY;
 1497                 }
 1498 
 1499                 @Override
 1500                 public Object getBean() {
 1501                     return Node.this;
 1502                 }
 1503 
 1504                 @Override
 1505                 public String getName() {
 1506                     return &quot;opacity&quot;;
 1507                 }
 1508             };
 1509         }
 1510         return opacity;
 1511     }
 1512 
 1513     /**
 1514      * The {@link javafx.scene.effect.BlendMode} used to blend this individual node
 1515      * into the scene behind it. If this node is a {@code Group}, then all of the
 1516      * children will be composited individually into a temporary buffer using their
 1517      * own blend modes and then that temporary buffer will be composited into the
 1518      * scene using the specified blend mode.
 1519      *
 1520      * A value of {@code null} is treated as pass-through. This means no effect on a
 1521      * parent (such as a {@code Group}), and the equivalent of {@code SRC_OVER} for a single {@code Node}.
 1522      *
 1523      * @defaultValue {@code null}
 1524      */
 1525     private javafx.beans.property.ObjectProperty&lt;BlendMode&gt; blendMode;
 1526 
 1527     public final void setBlendMode(BlendMode value) {
 1528         blendModeProperty().set(value);
 1529     }
 1530     public final BlendMode getBlendMode() {
 1531         return blendMode == null ? null : blendMode.get();
 1532     }
 1533 
 1534     public final ObjectProperty&lt;BlendMode&gt; blendModeProperty() {
 1535         if (blendMode == null) {
 1536             blendMode = new StyleableObjectProperty&lt;BlendMode&gt;(null) {
 1537                 @Override public void invalidated() {
 1538                     NodeHelper.markDirty(Node.this, DirtyBits.NODE_BLENDMODE);
 1539                 }
 1540 
 1541                 @Override
 1542                 public CssMetaData getCssMetaData() {
 1543                     return StyleableProperties.BLEND_MODE;
 1544                 }
 1545 
 1546                 @Override
 1547                 public Object getBean() {
 1548                     return Node.this;
 1549                 }
 1550 
 1551                 @Override
 1552                 public String getName() {
 1553                     return &quot;blendMode&quot;;
 1554                 }
 1555             };
 1556         }
 1557         return blendMode;
 1558     }
 1559 
 1560     public final void setClip(Node value) {
 1561         clipProperty().set(value);
 1562     }
 1563 
 1564     public final Node getClip() {
 1565         return (miscProperties == null) ? DEFAULT_CLIP
 1566                                         : miscProperties.getClip();
 1567     }
 1568 
 1569     /**
 1570      * Specifies a {@code Node} to use to define the clipping shape for this
 1571      * Node. This clipping Node is not a child of this {@code Node} in the scene
 1572      * graph sense. Rather, it is used to define the clip for this {@code Node}.
 1573      * &lt;p&gt;
 1574      * For example, you can use an {@link javafx.scene.image.ImageView} Node as
 1575      * a mask to represent the Clip. Or you could use one of the geometric shape
 1576      * Nodes such as {@link javafx.scene.shape.Rectangle} or
 1577      * {@link javafx.scene.shape.Circle}. Or you could use a
 1578      * {@link javafx.scene.text.Text} node to represent the Clip.
 1579      * &lt;p&gt;
 1580      * See the class documentation for {@link Node} for scene graph structure
 1581      * restrictions on setting the clip. If these restrictions are violated by
 1582      * a change to the clip variable, the change is ignored and the
 1583      * previous value of the clip variable is restored.
 1584      * &lt;p&gt;
 1585      * Note that this is a conditional feature. See
 1586      * {@link javafx.application.ConditionalFeature#SHAPE_CLIP ConditionalFeature.SHAPE_CLIP}
 1587      * for more information.
 1588      * &lt;p&gt;
 1589      * There is a known limitation of mixing Clip with a 3D Transform.
 1590      * Clipping is essentially a 2D image operation. The result of
 1591      * a Clip set on a {@link Group} node with 3D transformed children
 1592      * will cause its children to be rendered in order without Z-buffering
 1593      * applied between those children.
 1594      *
 1595      * @return the the clipping shape for this {@code Node}
 1596      * @defaultValue null
 1597      */
 1598     public final ObjectProperty&lt;Node&gt; clipProperty() {
 1599         return getMiscProperties().clipProperty();
 1600     }
 1601 
 1602     public final void setCache(boolean value) {
 1603         cacheProperty().set(value);
 1604     }
 1605 
 1606     public final boolean isCache() {
 1607         return (miscProperties == null) ? DEFAULT_CACHE
 1608                                         : miscProperties.isCache();
 1609     }
 1610 
 1611     /**
 1612      * A performance hint to the system to indicate that this {@code Node}
 1613      * should be cached as a bitmap. Rendering a bitmap representation of a node
 1614      * will be faster than rendering primitives in many cases, especially in the
 1615      * case of primitives with effects applied (such as a blur). However, it
 1616      * also increases memory usage. This hint indicates whether that trade-off
 1617      * (increased memory usage for increased performance) is worthwhile. Also
 1618      * note that on some platforms such as GPU accelerated platforms there is
 1619      * little benefit to caching Nodes as bitmaps when blurs and other effects
 1620      * are used since they are very fast to render on the GPU.
 1621      *
 1622      * The {@link #cacheHintProperty} variable provides additional options for enabling
 1623      * more aggressive bitmap caching.
 1624      *
 1625      * &lt;p&gt;
 1626      * Caching may be disabled for any node that has a 3D transform on itself,
 1627      * any of its ancestors, or any of its descendants.
 1628      *
 1629      * @return the hint to cache for this {@code Node}
 1630      * @see #cacheHintProperty
 1631      * @defaultValue false
 1632      */
 1633     public final BooleanProperty cacheProperty() {
 1634         return getMiscProperties().cacheProperty();
 1635     }
 1636 
 1637     public final void setCacheHint(CacheHint value) {
 1638         cacheHintProperty().set(value);
 1639     }
 1640 
 1641     public final CacheHint getCacheHint() {
 1642         return (miscProperties == null) ? DEFAULT_CACHE_HINT
 1643                                         : miscProperties.getCacheHint();
 1644     }
 1645 
 1646     /**
 1647      * Additional hint for controlling bitmap caching.
 1648      * &lt;p&gt;
 1649      * Under certain circumstances, such as animating nodes that are very
 1650      * expensive to render, it is desirable to be able to perform
 1651      * transformations on the node without having to regenerate the cached
 1652      * bitmap.  An option in such cases is to perform the transforms on the
 1653      * cached bitmap itself.
 1654      * &lt;p&gt;
 1655      * This technique can provide a dramatic improvement to animation
 1656      * performance, though may also result in a reduction in visual quality.
 1657      * The {@code cacheHint} variable provides a hint to the system about how
 1658      * and when that trade-off (visual quality for animation performance) is
 1659      * acceptable.
 1660      * &lt;p&gt;
 1661      * It is possible to enable the cacheHint only at times when your node is
 1662      * animating.  In this way, expensive nodes can appear on screen with full
 1663      * visual quality, yet still animate smoothly.
 1664      * &lt;p&gt;
 1665      * Example:
 1666      * &lt;pre&gt;{@code
 1667         expensiveNode.setCache(true);
 1668         expensiveNode.setCacheHint(CacheHint.QUALITY);
 1669         ...
 1670         // Do an animation
 1671         expensiveNode.setCacheHint(CacheHint.SPEED);
 1672         new Timeline(
 1673             new KeyFrame(Duration.seconds(2),
 1674                 new KeyValue(expensiveNode.scaleXProperty(), 2.0),
 1675                 new KeyValue(expensiveNode.scaleYProperty(), 2.0),
 1676                 new KeyValue(expensiveNode.rotateProperty(), 360),
 1677                 new KeyValue(expensiveNode.cacheHintProperty(), CacheHint.QUALITY)
 1678             )
 1679         ).play();
 1680      }&lt;/pre&gt;
 1681      *
 1682      * Note that {@code cacheHint} is only a hint to the system.  Depending on
 1683      * the details of the node or the transform, this hint may be ignored.
 1684      *
 1685      * &lt;p&gt;
 1686      * If {@code Node.cache} is false, cacheHint is ignored.
 1687      * Caching may be disabled for any node that has a 3D transform on itself,
 1688      * any of its ancestors, or any of its descendants.
 1689      *
 1690      * @return the {@code CacheHint} for this {@code Node}
 1691      * @see #cacheProperty
 1692      * @defaultValue CacheHint.DEFAULT
 1693      */
 1694     public final ObjectProperty&lt;CacheHint&gt; cacheHintProperty() {
 1695         return getMiscProperties().cacheHintProperty();
 1696     }
 1697 
 1698     public final void setEffect(Effect value) {
 1699         effectProperty().set(value);
 1700     }
 1701 
 1702     public final Effect getEffect() {
 1703         return (miscProperties == null) ? DEFAULT_EFFECT
 1704                                         : miscProperties.getEffect();
 1705     }
 1706 
 1707     /**
 1708      * Specifies an effect to apply to this {@code Node}.
 1709      * &lt;p&gt;
 1710      * Note that this is a conditional feature. See
 1711      * {@link javafx.application.ConditionalFeature#EFFECT ConditionalFeature.EFFECT}
 1712      * for more information.
 1713      *
 1714      * &lt;p&gt;
 1715      * There is a known limitation of mixing Effect with a 3D Transform. Effect is
 1716      * essentially a 2D image operation. The result of an Effect set on
 1717      * a {@link Group} node with 3D transformed children will cause its children
 1718      * to be rendered in order without Z-buffering applied between those
 1719      * children.
 1720      *
 1721      * @return the effect for this {@code Node}
 1722      * @defaultValue null
 1723      */
 1724     public final ObjectProperty&lt;Effect&gt; effectProperty() {
 1725         return getMiscProperties().effectProperty();
 1726     }
 1727 
 1728     public final void setDepthTest(DepthTest value) {
 1729         depthTestProperty().set(value);
 1730     }
 1731 
 1732     public final DepthTest getDepthTest() {
 1733         return (miscProperties == null) ? DEFAULT_DEPTH_TEST
 1734                                         : miscProperties.getDepthTest();
 1735     }
 1736 
 1737     /**
 1738      * Indicates whether depth testing is used when rendering this node.
 1739      * If the depthTest flag is {@code DepthTest.DISABLE}, then depth testing
 1740      * is disabled for this node.
 1741      * If the depthTest flag is {@code DepthTest.ENABLE}, then depth testing
 1742      * is enabled for this node.
 1743      * If the depthTest flag is {@code DepthTest.INHERIT}, then depth testing
 1744      * is enabled for this node if it is enabled for the parent node or the
 1745      * parent node is null.
 1746      * &lt;p&gt;
 1747      * The depthTest flag is only used when the depthBuffer flag for
 1748      * the {@link Scene} is true (meaning that the
 1749      * {@link Scene} has an associated depth buffer)
 1750      * &lt;p&gt;
 1751      * Depth test comparison is only done among nodes with depthTest enabled.
 1752      * A node with depthTest disabled does not read, test, or write the depth buffer,
 1753      * that is to say its Z value will not be considered for depth testing
 1754      * with other nodes.
 1755      * &lt;p&gt;
 1756      * Note that this is a conditional feature. See
 1757      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 1758      * for more information.
 1759      * &lt;p&gt;
 1760      * See the constructor in Scene with depthBuffer as one of its input
 1761      * arguments.
 1762      *
 1763      * @return the depth test setting for this {@code Node}
 1764      * @see javafx.scene.Scene
 1765      * @defaultValue INHERIT
 1766      */
 1767     public final ObjectProperty&lt;DepthTest&gt; depthTestProperty() {
 1768         return getMiscProperties().depthTestProperty();
 1769     }
 1770 
 1771     /**
 1772      * Recompute the derived depth test flag. This flag is true
 1773      * if the depthTest flag for this node is true and the
 1774      * depth test flag for each ancestor node is true. It is false
 1775      * otherwise. Equivalently, the derived depth flag is true
 1776      * if the depthTest flag for this node is true and the derivedDepthTest
 1777      * flag for its parent is true.
 1778      */
 1779     void computeDerivedDepthTest() {
 1780         boolean newDDT;
 1781         if (getDepthTest() == DepthTest.INHERIT) {
 1782             if (getParent() != null) {
 1783                 newDDT = getParent().isDerivedDepthTest();
 1784             } else {
 1785                 newDDT = true;
 1786             }
 1787         } else if (getDepthTest() == DepthTest.ENABLE) {
 1788             newDDT = true;
 1789         } else {
 1790             newDDT = false;
 1791         }
 1792 
 1793         if (isDerivedDepthTest() != newDDT) {
 1794             NodeHelper.markDirty(this, DirtyBits.NODE_DEPTH_TEST);
 1795             setDerivedDepthTest(newDDT);
 1796         }
 1797     }
 1798 
 1799     // This is the derived depthTest value to pass to PG level
 1800     private boolean derivedDepthTest = true;
 1801 
 1802     void setDerivedDepthTest(boolean value) {
 1803         derivedDepthTest = value;
 1804     }
 1805 
 1806     boolean isDerivedDepthTest() {
 1807         return derivedDepthTest;
 1808     }
 1809 
 1810     public final void setDisable(boolean value) {
 1811         disableProperty().set(value);
 1812     }
 1813 
 1814     public final boolean isDisable() {
 1815         return (miscProperties == null) ? DEFAULT_DISABLE
 1816                                         : miscProperties.isDisable();
 1817     }
 1818 
 1819     /**
 1820      * Defines the individual disabled state of this {@code Node}. Setting
 1821      * {@code disable} to true will cause this {@code Node} and any subnodes to
 1822      * become disabled. This property should be used only to set the disabled
 1823      * state of a {@code Node}.  For querying the disabled state of a
 1824      * {@code Node}, the {@link #disabledProperty disabled} property should instead be used,
 1825      * since it is possible that a {@code Node} was disabled as a result of an
 1826      * ancestor being disabled even if the individual {@code disable} state on
 1827      * this {@code Node} is {@code false}.
 1828      *
 1829      * @return the disabled state for this {@code Node}
 1830      * @defaultValue false
 1831      */
 1832     public final BooleanProperty disableProperty() {
 1833         return getMiscProperties().disableProperty();
 1834     }
 1835 
 1836 
 1837 //    /**
 1838 //     * TODO document - null by default, could be non-null in subclasses (e.g. Control)
 1839 //     */
 1840 //    public final ObjectProperty&lt;InputMap&lt;?&gt;&gt; inputMapProperty() {
 1841 //        if (inputMap == null) {
 1842 //            inputMap = new SimpleObjectProperty&lt;InputMap&lt;?&gt;&gt;(this, &quot;inputMap&quot;) {
 1843 //                private InputMap&lt;?&gt; currentMap = get();
 1844 //                @Override protected void invalidated() {
 1845 //                    if (currentMap != null) {
 1846 //                        currentMap.dispose();
 1847 //                    }
 1848 //                    currentMap = get();
 1849 //                }
 1850 //            };
 1851 //        }
 1852 //        return inputMap;
 1853 //    }
 1854 //    public final void setInputMap(InputMap&lt;?&gt; value) { inputMapProperty().set(value); }
 1855 //    public final InputMap&lt;?&gt; getInputMap() { return inputMapProperty().getValue(); }
 1856 //    private ObjectProperty&lt;InputMap&lt;?&gt;&gt; inputMap;
 1857 
 1858 
 1859     /**************************************************************************
 1860      *                                                                        *
 1861      *
 1862      *                                                                        *
 1863      *************************************************************************/
 1864     /**
 1865      * Defines how the picking computation is done for this node when
 1866      * triggered by a {@code MouseEvent} or a {@code contains} function call.
 1867      *
 1868      * If {@code pickOnBounds} is {@code true}, then picking is computed by
 1869      * intersecting with the bounds of this node, else picking is computed
 1870      * by intersecting with the geometric shape of this node.
 1871      *
 1872      * The default value of this property is {@code false} unless
 1873      * overridden by a subclass. The default value is {@code true}
 1874      * for {@link javafx.scene.layout.Region}.
 1875      *
 1876      * @defaultValue false; true for {@code Region}
 1877      */
 1878     private BooleanProperty pickOnBounds;
 1879 
 1880     public final void setPickOnBounds(boolean value) {
 1881         pickOnBoundsProperty().set(value);
 1882     }
 1883 
 1884     public final boolean isPickOnBounds() {
 1885         return pickOnBounds == null ? false : pickOnBounds.get();
 1886     }
 1887 
 1888     public final BooleanProperty pickOnBoundsProperty() {
 1889         if (pickOnBounds == null) {
 1890             pickOnBounds = new SimpleBooleanProperty(this, &quot;pickOnBounds&quot;);
 1891         }
 1892         return pickOnBounds;
 1893     }
 1894 
 1895     /**
 1896      * Indicates whether or not this {@code Node} is disabled.  A {@code Node}
 1897      * will become disabled if {@link #disableProperty disable} is set to {@code true} on either
 1898      * itself or one of its ancestors in the scene graph.
 1899      * &lt;p&gt;
 1900      * A disabled {@code Node} should render itself differently to indicate its
 1901      * disabled state to the user.
 1902      * Such disabled rendering is dependent on the implementation of the
 1903      * {@code Node}. The shape classes contained in {@code javafx.scene.shape}
 1904      * do not implement such rendering by default, therefore applications using
 1905      * shapes for handling input must implement appropriate disabled rendering
 1906      * themselves. The user-interface controls defined in
 1907      * {@code javafx.scene.control} will implement disabled-sensitive rendering,
 1908      * however.
 1909      * &lt;p&gt;
 1910      * A disabled {@code Node} does not receive mouse or key events.
 1911      *
 1912      * @defaultValue false
 1913      */
 1914     private ReadOnlyBooleanWrapper disabled;
 1915 
 1916     protected final void setDisabled(boolean value) {
 1917         disabledPropertyImpl().set(value);
 1918     }
 1919 
 1920     public final boolean isDisabled() {
 1921         return disabled == null ? false : disabled.get();
 1922     }
 1923 
 1924     public final ReadOnlyBooleanProperty disabledProperty() {
 1925         return disabledPropertyImpl().getReadOnlyProperty();
 1926     }
 1927 
 1928     private ReadOnlyBooleanWrapper disabledPropertyImpl() {
 1929         if (disabled == null) {
 1930             disabled = new ReadOnlyBooleanWrapper() {
 1931 
 1932                 @Override
 1933                 protected void invalidated() {
 1934                     pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, get());
 1935                     updateCanReceiveFocus();
 1936                     focusSetDirty(getScene());
 1937                 }
 1938 
 1939                 @Override
 1940                 public Object getBean() {
 1941                     return Node.this;
 1942                 }
 1943 
 1944                 @Override
 1945                 public String getName() {
 1946                     return &quot;disabled&quot;;
 1947                 }
 1948             };
 1949         }
 1950         return disabled;
 1951     }
 1952 
 1953     private void updateDisabled() {
 1954         boolean isDisabled = isDisable();
 1955         if (!isDisabled) {
 1956             isDisabled = getParent() != null ? getParent().isDisabled() :
 1957                     getSubScene() != null &amp;&amp; getSubScene().isDisabled();
 1958         }
 1959         setDisabled(isDisabled);
 1960         if (this instanceof SubScene) {
 1961             ((SubScene)this).getRoot().setDisabled(isDisabled);
 1962         }
 1963     }
 1964 
 1965     /**
 1966      * Finds this {@code Node}, or the first sub-node, based on the given CSS selector.
 1967      * If this node is a {@code Parent}, then this function will traverse down
 1968      * into the branch until it finds a match. If more than one sub-node matches the
 1969      * specified selector, this function returns the first of them.
 1970      * &lt;p&gt;
 1971      *     For example, if a Node is given the id of &quot;myId&quot;, then the lookup method can
 1972      *     be used to find this node as follows: &lt;code&gt;scene.lookup(&quot;#myId&quot;);&lt;/code&gt;.
 1973      * &lt;/p&gt;
 1974      *
 1975      * @param selector The css selector of the node to find
 1976      * @return The first node, starting from this {@code Node}, which matches
 1977      *         the CSS {@code selector}, null if none is found.
 1978      */
 1979     public Node lookup(String selector) {
 1980         if (selector == null) return null;
 1981         Selector s = Selector.createSelector(selector);
 1982         return s != null &amp;&amp; s.applies(this) ? this : null;
 1983     }
 1984 
 1985     /**
 1986      * Finds all {@code Node}s, including this one and any children, which match
 1987      * the given CSS selector. If no matches are found, an empty unmodifiable set is
 1988      * returned. The set is explicitly unordered.
 1989      *
 1990      * @param selector The css selector of the nodes to find
 1991      * @return All nodes, starting from and including this {@code Node}, which match
 1992      *         the CSS {@code selector}. The returned set is always unordered and
 1993      *         unmodifiable, and never null.
 1994      */
 1995     public Set&lt;Node&gt; lookupAll(String selector) {
 1996         final Selector s = Selector.createSelector(selector);
 1997         final Set&lt;Node&gt; empty = Collections.emptySet();
 1998         if (s == null) return empty;
 1999         List&lt;Node&gt; results = lookupAll(s, null);
 2000         return results == null ? empty : new UnmodifiableListSet&lt;Node&gt;(results);
 2001     }
 2002 
 2003     /**
 2004      * Used by Node and Parent for traversing the tree and adding all nodes which
 2005      * match the given selector.
 2006      *
 2007      * @param selector The Selector. This will never be null.
 2008      * @param results The results. This will never be null.
 2009      */
 2010     List&lt;Node&gt; lookupAll(Selector selector, List&lt;Node&gt; results) {
 2011         if (selector.applies(this)) {
 2012             // Lazily create the set to reduce some trash.
 2013             if (results == null) {
 2014                 results = new LinkedList&lt;Node&gt;();
 2015             }
 2016             results.add(this);
 2017         }
 2018         return results;
 2019     }
 2020 
 2021     /**
 2022      * Moves this {@code Node} to the back of its sibling nodes in terms of
 2023      * z-order.  This is accomplished by moving this {@code Node} to the
 2024      * first position in its parent&#39;s {@code content} ObservableList.
 2025      * This function has no effect if this {@code Node} is not part of a group.
 2026      */
 2027     public void toBack() {
 2028         if (getParent() != null) {
 2029             getParent().toBack(this);
 2030         }
 2031     }
 2032 
 2033     /**
 2034      * Moves this {@code Node} to the front of its sibling nodes in terms of
 2035      * z-order.  This is accomplished by moving this {@code Node} to the
 2036      * last position in its parent&#39;s {@code content} ObservableList.
 2037      * This function has no effect if this {@code Node} is not part of a group.
 2038      */
 2039     public void toFront() {
 2040         if (getParent() != null) {
 2041             getParent().toFront(this);
 2042         }
 2043     }
 2044 
 2045     // TODO: need to verify whether this is OK to do starting from a node in
 2046     // the scene graph other than the root.
 2047     private void doCSSPass() {
 2048         if (this.cssFlag != CssFlags.CLEAN) {
 2049             // The dirty bit isn&#39;t checked but we must ensure it is cleared.
 2050             // The cssFlag is set to clean in either Node.processCSS or
 2051             // NodeHelper.processCSS
 2052 
 2053             // Don&#39;t clear the dirty bit in case it will cause problems
 2054             // with a full CSS pass on the scene.
 2055             // TODO: is this the right thing to do?
 2056             // this.clearDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);
 2057 
 2058             this.processCSS();
 2059         }
 2060     }
 2061 
 2062     /**
 2063      * Recursive function for synchronizing a node and all descendents
 2064      */
 2065     private static void syncAll(Node node) {
 2066         node.syncPeer();
 2067         if (node instanceof Parent) {
 2068             Parent p = (Parent) node;
 2069             final int childrenCount = p.getChildren().size();
 2070 
 2071             for (int i = 0; i &lt; childrenCount; i++) {
 2072                 Node n = p.getChildren().get(i);
 2073                 if (n != null) {
 2074                     syncAll(n);
 2075                 }
 2076             }
 2077         }
 2078         if (node.getClip() != null) {
 2079             syncAll(node.getClip());
 2080         }
 2081     }
 2082 
 2083     private void doLayoutPass() {
 2084         if (this instanceof Parent) {
 2085             // TODO: As an optimization we only need to layout those dirty
 2086             // roots that are descendants of this node
 2087             Parent p = (Parent)this;
 2088             for (int i = 0; i &lt; 3; i++) {
 2089                 p.layout();
 2090             }
 2091         }
 2092     }
 2093 
 2094     private void doCSSLayoutSyncForSnapshot() {
 2095         doCSSPass();
 2096         doLayoutPass();
 2097         updateBounds();
 2098         Scene.setAllowPGAccess(true);
 2099         syncAll(this);
 2100         Scene.setAllowPGAccess(false);
 2101     }
 2102 
 2103     private WritableImage doSnapshot(SnapshotParameters params, WritableImage img) {
 2104         if (getScene() != null) {
 2105             getScene().doCSSLayoutSyncForSnapshot(this);
 2106         } else {
 2107             doCSSLayoutSyncForSnapshot();
 2108         }
 2109 
 2110         BaseTransform transform = BaseTransform.IDENTITY_TRANSFORM;
 2111         if (params.getTransform() != null) {
 2112             Affine3D tempTx = new Affine3D();
 2113             TransformHelper.apply(params.getTransform(), tempTx);
 2114             transform = tempTx;
 2115         }
 2116         double x;
 2117         double y;
 2118         double w;
 2119         double h;
 2120         Rectangle2D viewport = params.getViewport();
 2121         if (viewport != null) {
 2122             // Use the specified viewport
 2123             x = viewport.getMinX();
 2124             y = viewport.getMinY();
 2125             w = viewport.getWidth();
 2126             h = viewport.getHeight();
 2127         } else {
 2128             // Get the bounds in parent of this node, transformed by the
 2129             // specified transform.
 2130             BaseBounds tempBounds = TempState.getInstance().bounds;
 2131             tempBounds = getTransformedBounds(tempBounds, transform);
 2132             x = tempBounds.getMinX();
 2133             y = tempBounds.getMinY();
 2134             w = tempBounds.getWidth();
 2135             h = tempBounds.getHeight();
 2136         }
 2137         WritableImage result = Scene.doSnapshot(getScene(), x, y, w, h,
 2138                 this, transform, params.isDepthBufferInternal(),
 2139                 params.getFill(), params.getEffectiveCamera(), img);
 2140 
 2141         return result;
 2142     }
 2143 
 2144     /**
 2145      * Takes a snapshot of this node and returns the rendered image when
 2146      * it is ready.
 2147      * CSS and layout processing will be done for the node, and any of its
 2148      * children, prior to rendering it.
 2149      * The entire destination image is cleared to the fill {@code Paint}
 2150      * specified by the SnapshotParameters. This node is then rendered to
 2151      * the image.
 2152      * If the viewport specified by the SnapshotParameters is null, the
 2153      * upper-left pixel of the {@code boundsInParent} of this
 2154      * node, after first applying the transform specified by the
 2155      * SnapshotParameters,
 2156      * is mapped to the upper-left pixel (0,0) in the image.
 2157      * If a non-null viewport is specified,
 2158      * the upper-left pixel of the viewport is mapped to upper-left pixel
 2159      * (0,0) in the image.
 2160      * In both cases, this mapping to (0,0) of the image is done with an integer
 2161      * translation. The portion of the node that is outside of the rendered
 2162      * image will be clipped by the image.
 2163      *
 2164      * &lt;p&gt;
 2165      * When taking a snapshot of a scene that is being animated, either
 2166      * explicitly by the application or implicitly (such as chart animation),
 2167      * the snapshot will be rendered based on the state of the scene graph at
 2168      * the moment the snapshot is taken and will not reflect any subsequent
 2169      * animation changes.
 2170      * &lt;/p&gt;
 2171      *
 2172      * &lt;p&gt;
 2173      * NOTE: In order for CSS and layout to function correctly, the node
 2174      * must be part of a Scene (the Scene may be attached to a Stage, but need
 2175      * not be).
 2176      * &lt;/p&gt;
 2177      *
 2178      * @param params the snapshot parameters containing attributes that
 2179      * will control the rendering. If the SnapshotParameters object is null,
 2180      * then the Scene&#39;s attributes will be used if this node is part of a scene,
 2181      * or default attributes will be used if this node is not part of a scene.
 2182      *
 2183      * @param image the writable image that will be used to hold the rendered node.
 2184      * It may be null in which case a new WritableImage will be constructed.
 2185      * The new image is constructed using integer width and
 2186      * height values that are derived either from the transformed bounds of this
 2187      * Node or from the size of the viewport as specified in the
 2188      * SnapShotParameters. These integer values are chosen such that the image
 2189      * will wholly contain the bounds of this Node or the specified viewport.
 2190      * If the image is non-null, the node will be rendered into the
 2191      * existing image.
 2192      * In this case, the width and height of the image determine the area
 2193      * that is rendered instead of the width and height of the bounds or
 2194      * viewport.
 2195      *
 2196      * @throws IllegalStateException if this method is called on a thread
 2197      *     other than the JavaFX Application Thread.
 2198      *
 2199      * @return the rendered image
 2200      * @since JavaFX 2.2
 2201      */
 2202     public WritableImage snapshot(SnapshotParameters params, WritableImage image) {
 2203         Toolkit.getToolkit().checkFxUserThread();
 2204 
 2205         if (params == null) {
 2206             params = new SnapshotParameters();
 2207             Scene s = getScene();
 2208             if (s != null) {
 2209                 params.setCamera(s.getEffectiveCamera());
 2210                 params.setDepthBuffer(s.isDepthBufferInternal());
 2211                 params.setFill(s.getFill());
 2212             }
 2213         }
 2214 
 2215         return doSnapshot(params, image);
 2216     }
 2217 
 2218     /**
 2219      * Takes a snapshot of this node at the next frame and calls the
 2220      * specified callback method when the image is ready.
 2221      * CSS and layout processing will be done for the node, and any of its
 2222      * children, prior to rendering it.
 2223      * The entire destination image is cleared to the fill {@code Paint}
 2224      * specified by the SnapshotParameters. This node is then rendered to
 2225      * the image.
 2226      * If the viewport specified by the SnapshotParameters is null, the
 2227      * upper-left pixel of the {@code boundsInParent} of this
 2228      * node, after first applying the transform specified by the
 2229      * SnapshotParameters,
 2230      * is mapped to the upper-left pixel (0,0) in the image.
 2231      * If a non-null viewport is specified,
 2232      * the upper-left pixel of the viewport is mapped to upper-left pixel
 2233      * (0,0) in the image.
 2234      * In both cases, this mapping to (0,0) of the image is done with an integer
 2235      * translation. The portion of the node that is outside of the rendered
 2236      * image will be clipped by the image.
 2237      *
 2238      * &lt;p&gt;
 2239      * This is an asynchronous call, which means that other
 2240      * events or animation might be processed before the node is rendered.
 2241      * If any such events modify the node, or any of its children, that
 2242      * modification will be reflected in the rendered image (just like it
 2243      * will also be reflected in the frame rendered to the Stage, if this node
 2244      * is part of a live scene graph).
 2245      * &lt;/p&gt;
 2246      *
 2247      * &lt;p&gt;
 2248      * When taking a snapshot of a node that is being animated, either
 2249      * explicitly by the application or implicitly (such as chart animation),
 2250      * the snapshot will be rendered based on the state of the scene graph at
 2251      * the moment the snapshot is taken and will not reflect any subsequent
 2252      * animation changes.
 2253      * &lt;/p&gt;
 2254      *
 2255      * &lt;p&gt;
 2256      * NOTE: In order for CSS and layout to function correctly, the node
 2257      * must be part of a Scene (the Scene may be attached to a Stage, but need
 2258      * not be).
 2259      * &lt;/p&gt;
 2260      *
 2261      * @param callback a class whose call method will be called when the image
 2262      * is ready. The SnapshotResult that is passed into the call method of
 2263      * the callback will contain the rendered image, the source node
 2264      * that was rendered, and a copy of the SnapshotParameters.
 2265      * The callback parameter must not be null.
 2266      *
 2267      * @param params the snapshot parameters containing attributes that
 2268      * will control the rendering. If the SnapshotParameters object is null,
 2269      * then the Scene&#39;s attributes will be used if this node is part of a scene,
 2270      * or default attributes will be used if this node is not part of a scene.
 2271      *
 2272      * @param image the writable image that will be used to hold the rendered node.
 2273      * It may be null in which case a new WritableImage will be constructed.
 2274      * The new image is constructed using integer width and
 2275      * height values that are derived either from the transformed bounds of this
 2276      * Node or from the size of the viewport as specified in the
 2277      * SnapShotParameters. These integer values are chosen such that the image
 2278      * will wholly contain the bounds of this Node or the specified viewport.
 2279      * If the image is non-null, the node will be rendered into the
 2280      * existing image.
 2281      * In this case, the width and height of the image determine the area
 2282      * that is rendered instead of the width and height of the bounds or
 2283      * viewport.
 2284      *
 2285      * @throws IllegalStateException if this method is called on a thread
 2286      *     other than the JavaFX Application Thread.
 2287      *
 2288      * @throws NullPointerException if the callback parameter is null.
 2289      * @since JavaFX 2.2
 2290      */
 2291     public void snapshot(Callback&lt;SnapshotResult, Void&gt; callback,
 2292             SnapshotParameters params, WritableImage image) {
 2293 
 2294         Toolkit.getToolkit().checkFxUserThread();
 2295         if (callback == null) {
 2296             throw new NullPointerException(&quot;The callback must not be null&quot;);
 2297         }
 2298 
 2299         if (params == null) {
 2300             params = new SnapshotParameters();
 2301             Scene s = getScene();
 2302             if (s != null) {
 2303                 params.setCamera(s.getEffectiveCamera());
 2304                 params.setDepthBuffer(s.isDepthBufferInternal());
 2305                 params.setFill(s.getFill());
 2306             }
 2307         } else {
 2308             params = params.copy();
 2309         }
 2310 
 2311         final SnapshotParameters theParams = params;
 2312         final Callback&lt;SnapshotResult, Void&gt; theCallback = callback;
 2313         final WritableImage theImage = image;
 2314 
 2315         // Create a deferred runnable that will be run from a pulse listener
 2316         // that is called after all of the scenes have been synced but before
 2317         // any of them have been rendered.
 2318         final Runnable snapshotRunnable = () -&gt; {
 2319             WritableImage img = doSnapshot(theParams, theImage);
 2320             SnapshotResult result = new SnapshotResult(img, Node.this, theParams);
 2321 //                System.err.println(&quot;Calling snapshot callback&quot;);
 2322             try {
 2323                 Void v = theCallback.call(result);
 2324             } catch (Throwable th) {
 2325                 System.err.println(&quot;Exception in snapshot callback&quot;);
 2326                 th.printStackTrace(System.err);
 2327             }
 2328         };
 2329 
 2330 //        System.err.println(&quot;Schedule a snapshot in the future&quot;);
 2331         Scene.addSnapshotRunnable(snapshotRunnable);
 2332     }
 2333 
 2334     /* ************************************************************************
 2335      *                                                                        *
 2336      *
 2337      *                                                                        *
 2338      *************************************************************************/
 2339 
 2340     public final void setOnDragEntered(
 2341             EventHandler&lt;? super DragEvent&gt; value) {
 2342         onDragEnteredProperty().set(value);
 2343     }
 2344 
 2345     public final EventHandler&lt;? super DragEvent&gt; getOnDragEntered() {
 2346         return (eventHandlerProperties == null)
 2347                 ? null : eventHandlerProperties.getOnDragEntered();
 2348     }
 2349 
 2350     /**
 2351      * Defines a function to be called when drag gesture
 2352      * enters this {@code Node}.
 2353      * @return the event handler that is called when drag gesture enters this
 2354      * {@code Node}
 2355      */
 2356     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
 2357             onDragEnteredProperty() {
 2358         return getEventHandlerProperties().onDragEnteredProperty();
 2359     }
 2360 
 2361     public final void setOnDragExited(
 2362             EventHandler&lt;? super DragEvent&gt; value) {
 2363         onDragExitedProperty().set(value);
 2364     }
 2365 
 2366     public final EventHandler&lt;? super DragEvent&gt; getOnDragExited() {
 2367         return (eventHandlerProperties == null)
 2368                 ? null : eventHandlerProperties.getOnDragExited();
 2369     }
 2370 
 2371     /**
 2372      * Defines a function to be called when drag gesture
 2373      * exits this {@code Node}.
 2374      * @return the event handler that is called when drag gesture exits this
 2375      * {@code Node}
 2376      */
 2377     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
 2378             onDragExitedProperty() {
 2379         return getEventHandlerProperties().onDragExitedProperty();
 2380     }
 2381 
 2382     public final void setOnDragOver(
 2383             EventHandler&lt;? super DragEvent&gt; value) {
 2384         onDragOverProperty().set(value);
 2385     }
 2386 
 2387     public final EventHandler&lt;? super DragEvent&gt; getOnDragOver() {
 2388         return (eventHandlerProperties == null)
 2389                 ? null : eventHandlerProperties.getOnDragOver();
 2390     }
 2391 
 2392     /**
 2393      * Defines a function to be called when drag gesture progresses within
 2394      * this {@code Node}.
 2395      * @return the event handler that is called when drag gesture progresses
 2396      * within this {@code Node}
 2397      */
 2398     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
 2399             onDragOverProperty() {
 2400         return getEventHandlerProperties().onDragOverProperty();
 2401     }
 2402 
 2403     // Do we want DRAG_TRANSFER_MODE_CHANGED event?
 2404 //    public final void setOnDragTransferModeChanged(
 2405 //            EventHandler&lt;? super DragEvent&gt; value) {
 2406 //        onDragTransferModeChangedProperty().set(value);
 2407 //    }
 2408 //
 2409 //    public final EventHandler&lt;? super DragEvent&gt; getOnDragTransferModeChanged() {
 2410 //        return (eventHandlerProperties == null)
 2411 //                ? null : eventHandlerProperties.getOnDragTransferModeChanged();
 2412 //    }
 2413 //
 2414 //    /**
 2415 //     * Defines a function to be called this {@code Node} if it is a potential
 2416 //     * drag-and-drop target when the user takes action to change the intended
 2417 //     * {@code TransferMode}.
 2418 //     * The user can change the intended {@link TransferMode} by holding down
 2419 //     * or releasing key modifiers.
 2420 //     */
 2421 //    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
 2422 //            onDragTransferModeChangedProperty() {
 2423 //        return getEventHandlerProperties().onDragTransferModeChangedProperty();
 2424 //    }
 2425 
 2426     public final void setOnDragDropped(
 2427             EventHandler&lt;? super DragEvent&gt; value) {
 2428         onDragDroppedProperty().set(value);
 2429     }
 2430 
 2431     public final EventHandler&lt;? super DragEvent&gt; getOnDragDropped() {
 2432         return (eventHandlerProperties == null)
 2433                 ? null : eventHandlerProperties.getOnDragDropped();
 2434     }
 2435 
 2436     /**
 2437      * Defines a function to be called when the mouse button is released
 2438      * on this {@code Node} during drag and drop gesture. Transfer of data from
 2439      * the {@link DragEvent}&#39;s {@link DragEvent#getDragboard() dragboard} should
 2440      * happen in this function.
 2441      * @return the event handler that is called when the mouse button is
 2442      * released on this {@code Node}
 2443      */
 2444     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
 2445             onDragDroppedProperty() {
 2446         return getEventHandlerProperties().onDragDroppedProperty();
 2447     }
 2448 
 2449     public final void setOnDragDone(
 2450             EventHandler&lt;? super DragEvent&gt; value) {
 2451         onDragDoneProperty().set(value);
 2452     }
 2453 
 2454     public final EventHandler&lt;? super DragEvent&gt; getOnDragDone() {
 2455         return (eventHandlerProperties == null)
 2456                 ? null : eventHandlerProperties.getOnDragDone();
 2457     }
 2458 
 2459     /**
 2460      * Defines a function to be called when this {@code Node} is a
 2461      * drag and drop gesture source after its data has
 2462      * been dropped on a drop target. The {@code transferMode} of the
 2463      * event shows what just happened at the drop target.
 2464      * If {@code transferMode} has the value {@code MOVE}, then the source can
 2465      * clear out its data. Clearing the source&#39;s data gives the appropriate
 2466      * appearance to a user that the data has been moved by the drag and drop
 2467      * gesture. A {@code transferMode} that has the value {@code NONE}
 2468      * indicates that no data was transferred during the drag and drop gesture.
 2469      * @return the event handler that is called when this {@code Node} is a drag
 2470      * and drop gesture source after its data has been dropped on a drop target
 2471      */
 2472     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
 2473             onDragDoneProperty() {
 2474         return getEventHandlerProperties().onDragDoneProperty();
 2475     }
 2476 
 2477     /**
 2478      * Confirms a potential drag and drop gesture that is recognized over this
 2479      * {@code Node}.
 2480      * Can be called only from a DRAG_DETECTED event handler. The returned
 2481      * {@link Dragboard} is used to transfer data during
 2482      * the drag and drop gesture. Placing this {@code Node}&#39;s data on the
 2483      * {@link Dragboard} also identifies this {@code Node} as the source of
 2484      * the drag and drop gesture.
 2485      * More detail about drag and drop gestures is described in the overivew
 2486      * of {@link DragEvent}.
 2487      *
 2488      * @see DragEvent
 2489      * @param transferModes The supported {@code TransferMode}(s) of this {@code Node}
 2490      * @return A {@code Dragboard} to place this {@code Node}&#39;s data on
 2491      * @throws IllegalStateException if drag and drop cannot be started at this
 2492      * moment (it&#39;s called outside of {@code DRAG_DETECTED} event handling or
 2493      * this node is not in scene).
 2494      */
 2495     public Dragboard startDragAndDrop(TransferMode... transferModes) {
 2496         if (getScene() != null) {
 2497             return getScene().startDragAndDrop(this, transferModes);
 2498         }
 2499 
 2500         throw new IllegalStateException(&quot;Cannot start drag and drop on node &quot;
 2501                 + &quot;that is not in scene&quot;);
 2502     }
 2503 
 2504     /**
 2505      * Starts a full press-drag-release gesture with this node as gesture
 2506      * source. This method can be called only from a {@code DRAG_DETECTED} mouse
 2507      * event handler. More detail about dragging gestures can be found
 2508      * in the overview of {@link MouseEvent} and {@link MouseDragEvent}.
 2509      *
 2510      * @see MouseEvent
 2511      * @see MouseDragEvent
 2512      * @throws IllegalStateException if the full press-drag-release gesture
 2513      * cannot be started at this moment (it&#39;s called outside of
 2514      * {@code DRAG_DETECTED} event handling or this node is not in scene).
 2515      * @since JavaFX 2.1
 2516      */
 2517     public void startFullDrag() {
 2518         if (getScene() != null) {
 2519             getScene().startFullDrag(this);
 2520             return;
 2521         }
 2522 
 2523         throw new IllegalStateException(&quot;Cannot start full drag on node &quot;
 2524                 + &quot;that is not in scene&quot;);
 2525     }
 2526 
 2527     ////////////////////////////
 2528     //  Private Implementation
 2529     ////////////////////////////
 2530 
 2531     /**
 2532      * If this Node is being used as the clip of another Node, that other node
 2533      * is referred to as the clipParent. If the boundsInParent of this Node
 2534      * changes, it must update the clipParent&#39;s bounds as well.
 2535      */
 2536     private Node clipParent;
 2537     // Use a getter function instead of giving clipParent package access,
 2538     // so that clipParent doesn&#39;t get turned into a Location.
 2539     final Node getClipParent() {
 2540         return clipParent;
 2541     }
 2542 
 2543     /**
 2544      * Determines whether this node is connected anywhere in the scene graph.
 2545      */
 2546     boolean isConnected() {
 2547         // don&#39;t need to check scene, because if scene is non-null
 2548         // parent must also be non-null
 2549         return getParent() != null || clipParent != null;
 2550     }
 2551 
 2552     /**
 2553      * Tests whether creating a parent-child relationship between these
 2554      * nodes would cause a cycle. The parent relationship includes not only
 2555      * the &quot;real&quot; parent (child of Group) but also the clipParent.
 2556      */
 2557     boolean wouldCreateCycle(Node parent, Node child) {
 2558         if (child != null &amp;&amp; child.getClip() == null &amp;&amp; (!(child instanceof Parent))) {
 2559             return false;
 2560     }
 2561 
 2562         Node n = parent;
 2563         while (n != child) {
 2564             if (n.getParent() != null) {
 2565                 n = n.getParent();
 2566             } else if (n.getSubScene() != null) {
 2567                 n = n.getSubScene();
 2568             } else if (n.clipParent != null) {
 2569                 n = n.clipParent;
 2570             } else {
 2571                 return false;
 2572             }
 2573         }
 2574         return true;
 2575     }
 2576 
 2577     /**
 2578      * The peer node created by the graphics Toolkit/Pipeline implementation
 2579      */
 2580     private NGNode peer;
 2581 
 2582     @SuppressWarnings(&quot;CallToPrintStackTrace&quot;)
 2583     &lt;P extends NGNode&gt; P getPeer() {
 2584         if (Utils.assertionEnabled()) {
 2585             // Assertion checking code
 2586             if (getScene() != null &amp;&amp; !Scene.isPGAccessAllowed()) {
 2587                 java.lang.System.err.println();
 2588                 java.lang.System.err.println(&quot;*** unexpected PG access&quot;);
 2589                 java.lang.Thread.dumpStack();
 2590             }
 2591         }
 2592 
 2593         if (peer == null) {
 2594             //if (PerformanceTracker.isLoggingEnabled()) {
 2595             //    PerformanceTracker.logEvent(&quot;Creating NGNode for [{this}, id=\&quot;{id}\&quot;]&quot;);
 2596             //}
 2597             peer = NodeHelper.createPeer(this);
 2598             //if (PerformanceTracker.isLoggingEnabled()) {
 2599             //    PerformanceTracker.logEvent(&quot;NGNode created&quot;);
 2600             //}
 2601         }
 2602         return (P) peer;
 2603     }
 2604 
 2605     /***************************************************************************
 2606      *                                                                         *
 2607      *                              Initialization                             *
 2608      *                                                                         *
 2609      *  To Note limit the number of bounds computations and improve startup    *
 2610      *  performance.                                                           *
 2611      *                                                                         *
 2612      **************************************************************************/
 2613 
 2614     /**
 2615      * Creates a new instance of Node.
 2616      */
 2617     protected Node() {
 2618         //if (PerformanceTracker.isLoggingEnabled()) {
 2619         //    PerformanceTracker.logEvent(&quot;Node.init for [{this}, id=\&quot;{id}\&quot;]&quot;);
 2620         //}
 2621         updateTreeVisible(false);
 2622         //if (PerformanceTracker.isLoggingEnabled()) {
 2623         //    PerformanceTracker.logEvent(&quot;Node.postinit &quot; +
 2624         //                                &quot;for [{this}, id=\&quot;{id}\&quot;] finished&quot;);
 2625         //}
 2626     }
 2627 
 2628     /***************************************************************************
 2629      *                                                                         *
 2630      * Layout related APIs.                                                    *
 2631      *                                                                         *
 2632      **************************************************************************/
 2633     /**
 2634      * Defines whether or not this node&#39;s layout will be managed by it&#39;s parent.
 2635      * If the node is managed, it&#39;s parent will factor the node&#39;s geometry
 2636      * into its own preferred size and {@link #layoutBoundsProperty layoutBounds}
 2637      * calculations and will lay it
 2638      * out during the scene&#39;s layout pass.  If a managed node&#39;s layoutBounds
 2639      * changes, it will automatically trigger relayout up the scene-graph
 2640      * to the nearest layout root (which is typically the scene&#39;s root node).
 2641      * &lt;p&gt;
 2642      * If the node is unmanaged, its parent will ignore the child in both preferred
 2643      * size computations and layout.   Changes in layoutBounds will not trigger
 2644      * relayout above it.   If an unmanaged node is of type {@link javafx.scene.Parent Parent},
 2645      * it will act as a &quot;layout root&quot;, meaning that calls to {@link Parent#requestLayout()}
 2646      * beneath it will cause only the branch rooted by the node to be relayed out,
 2647      * thereby isolating layout changes to that root and below.  It&#39;s the application&#39;s
 2648      * responsibility to set the size and position of an unmanaged node.
 2649      * &lt;p&gt;
 2650      * By default all nodes are managed.
 2651      * &lt;/p&gt;
 2652      *
 2653      * @see #isResizable()
 2654      * @see #layoutBoundsProperty()
 2655      * @see Parent#requestLayout()
 2656      *
 2657      */
 2658     private BooleanProperty managed;
 2659 
 2660     public final void setManaged(boolean value) {
 2661         managedProperty().set(value);
 2662     }
 2663 
 2664     public final boolean isManaged() {
 2665         return managed == null ? true : managed.get();
 2666     }
 2667 
 2668     public final BooleanProperty managedProperty() {
 2669         if (managed == null) {
 2670             managed = new BooleanPropertyBase(true) {
 2671 
 2672                 @Override
 2673                 protected void invalidated() {
 2674                     final Parent parent = getParent();
 2675                     if (parent != null) {
 2676                         parent.managedChildChanged();
 2677                     }
 2678                     notifyManagedChanged();
 2679                 }
 2680 
 2681                 @Override
 2682                 public Object getBean() {
 2683                     return Node.this;
 2684                 }
 2685 
 2686                 @Override
 2687                 public String getName() {
 2688                     return &quot;managed&quot;;
 2689                 }
 2690 
 2691             };
 2692         }
 2693         return managed;
 2694     }
 2695 
 2696     /**
 2697      * Called whenever the &quot;managed&quot; flag has changed. This is only
 2698      * used by Parent as an optimization to keep track of whether a
 2699      * Parent node is a layout root or not.
 2700      */
 2701     void notifyManagedChanged() { }
 2702 
 2703     /**
 2704      * Defines the x coordinate of the translation that is added to this {@code Node}&#39;s
 2705      * transform for the purpose of layout. The value should be computed as the
 2706      * offset required to adjust the position of the node from its current
 2707      * {@link #layoutBoundsProperty() layoutBounds minX} position (which might not be 0) to the desired location.
 2708      *
 2709      * &lt;p&gt;For example, if {@code textnode} should be positioned at {@code finalX}
 2710      * &lt;pre&gt;{@code
 2711      *     textnode.setLayoutX(finalX - textnode.getLayoutBounds().getMinX());
 2712      * }&lt;/pre&gt;
 2713      * &lt;p&gt;
 2714      * Failure to subtract {@code layoutBounds minX} may result in misplacement
 2715      * of the node.  The {@link #relocate(double, double) relocate(x, y)} method will automatically do the
 2716      * correct computation and should generally be used over setting layoutX directly.
 2717      * &lt;p&gt;
 2718      * The node&#39;s final translation will be computed as {@code layoutX} + {@link #translateXProperty translateX},
 2719      * where {@code layoutX} establishes the node&#39;s stable position
 2720      * and {@code translateX} optionally makes dynamic adjustments to that
 2721      * position.
 2722      * &lt;p&gt;
 2723      * If the node is managed and has a {@link javafx.scene.layout.Region}
 2724      * as its parent, then the layout region will set {@code layoutX} according to its
 2725      * own layout policy.   If the node is unmanaged or parented by a {@link Group},
 2726      * then the application may set {@code layoutX} directly to position it.
 2727      *
 2728      * @see #relocate(double, double)
 2729      * @see #layoutBoundsProperty()
 2730      *
 2731      */
 2732     private DoubleProperty layoutX;
 2733 
 2734     public final void setLayoutX(double value) {
 2735         layoutXProperty().set(value);
 2736     }
 2737 
 2738     public final double getLayoutX() {
 2739         return layoutX == null ? 0.0 : layoutX.get();
 2740     }
 2741 
 2742     public final DoubleProperty layoutXProperty() {
 2743         if (layoutX == null) {
 2744             layoutX = new DoublePropertyBase(0.0) {
 2745 
 2746                 @Override
 2747                 protected void invalidated() {
 2748                     NodeHelper.transformsChanged(Node.this);
 2749                     final Parent p = getParent();
 2750 
 2751                     // Propagate layout if this change isn&#39;t triggered by its parent
 2752                     if (p != null &amp;&amp; !p.isCurrentLayoutChild(Node.this)) {
 2753                         if (isManaged()) {
 2754                             // Force its parent to fix the layout since it is a managed child.
 2755                             p.requestLayout(true);
 2756                         } else {
 2757                             // Parent size changed, parent&#39;s parent might need to re-layout
 2758                             p.clearSizeCache();
 2759                             p.requestParentLayout();
 2760                         }
 2761                     }
 2762                 }
 2763 
 2764                 @Override
 2765                 public Object getBean() {
 2766                     return Node.this;
 2767                 }
 2768 
 2769                 @Override
 2770                 public String getName() {
 2771                     return &quot;layoutX&quot;;
 2772                 }
 2773             };
 2774         }
 2775         return layoutX;
 2776     }
 2777 
 2778     /**
 2779      * Defines the y coordinate of the translation that is added to this {@code Node}&#39;s
 2780      * transform for the purpose of layout. The value should be computed as the
 2781      * offset required to adjust the position of the node from its current
 2782      * {@link #layoutBoundsProperty() layoutBounds minY} position (which might not be 0) to the desired location.
 2783      *
 2784      * &lt;p&gt;For example, if {@code textnode} should be positioned at {@code finalY}
 2785      * &lt;pre&gt;{@code
 2786      *     textnode.setLayoutY(finalY - textnode.getLayoutBounds().getMinY());
 2787      * }&lt;/pre&gt;
 2788      * &lt;p&gt;
 2789      * Failure to subtract {@code layoutBounds minY} may result in misplacement
 2790      * of the node.  The {@link #relocate(double, double) relocate(x, y)} method will automatically do the
 2791      * correct computation and should generally be used over setting layoutY directly.
 2792      * &lt;p&gt;
 2793      * The node&#39;s final translation will be computed as {@code layoutY} + {@link #translateYProperty translateY},
 2794      * where {@code layoutY} establishes the node&#39;s stable position
 2795      * and {@code translateY} optionally makes dynamic adjustments to that
 2796      * position.
 2797      * &lt;p&gt;
 2798      * If the node is managed and has a {@link javafx.scene.layout.Region}
 2799      * as its parent, then the region will set {@code layoutY} according to its
 2800      * own layout policy.   If the node is unmanaged or parented by a {@link Group},
 2801      * then the application may set {@code layoutY} directly to position it.
 2802      *
 2803      * @see #relocate(double, double)
 2804      * @see #layoutBoundsProperty()
 2805      */
 2806     private DoubleProperty layoutY;
 2807 
 2808     public final void setLayoutY(double value) {
 2809         layoutYProperty().set(value);
 2810     }
 2811 
 2812     public final double getLayoutY() {
 2813         return layoutY == null ? 0.0 : layoutY.get();
 2814     }
 2815 
 2816     public final DoubleProperty layoutYProperty() {
 2817         if (layoutY == null) {
 2818             layoutY = new DoublePropertyBase(0.0) {
 2819 
 2820                 @Override
 2821                 protected void invalidated() {
 2822                     NodeHelper.transformsChanged(Node.this);
 2823                     final Parent p = getParent();
 2824 
 2825                     // Propagate layout if this change isn&#39;t triggered by its parent
 2826                     if (p != null &amp;&amp; !p.isCurrentLayoutChild(Node.this)) {
 2827                         if (isManaged()) {
 2828                             // Force its parent to fix the layout since it is a managed child.
 2829                             p.requestLayout(true);
 2830                         } else {
 2831                             // Parent size changed, parent&#39;s parent might need to re-layout
 2832                             p.clearSizeCache();
 2833                             p.requestParentLayout();
 2834                         }
 2835                     }
 2836                 }
 2837 
 2838                 @Override
 2839                 public Object getBean() {
 2840                     return Node.this;
 2841                 }
 2842 
 2843                 @Override
 2844                 public String getName() {
 2845                     return &quot;layoutY&quot;;
 2846                 }
 2847 
 2848             };
 2849         }
 2850         return layoutY;
 2851     }
 2852 
 2853     /**
 2854      * Sets the node&#39;s layoutX and layoutY translation properties in order to
 2855      * relocate this node to the x,y location in the parent.
 2856      * &lt;p&gt;
 2857      * This method does not alter translateX or translateY, which if also set
 2858      * will be added to layoutX and layoutY, adjusting the final location by
 2859      * corresponding amounts.
 2860      *
 2861      * @param x the target x coordinate location
 2862      * @param y the target y coordinate location
 2863      */
 2864     public void relocate(double x, double y) {
 2865         setLayoutX(x - getLayoutBounds().getMinX());
 2866         setLayoutY(y - getLayoutBounds().getMinY());
 2867 
 2868         PlatformLogger logger = Logging.getLayoutLogger();
 2869         if (logger.isLoggable(Level.FINER)) {
 2870             logger.finer(this.toString()+&quot; moved to (&quot;+x+&quot;,&quot;+y+&quot;)&quot;);
 2871         }
 2872     }
 2873 
 2874     /**
 2875      * Indicates whether this node is a type which can be resized by its parent.
 2876      * If this method returns true, then the parent will resize the node (ideally
 2877      * within its size range) by calling node.resize(width,height) during the
 2878      * layout pass.  All Regions, Controls, and WebView are resizable classes
 2879      * which depend on their parents resizing them during layout once all sizing
 2880      * and CSS styling information has been applied.
 2881      * &lt;p&gt;
 2882      * If this method returns false, then the parent cannot resize it during
 2883      * layout (resize() is a no-op) and it should return its layoutBounds for
 2884      * minimum, preferred, and maximum sizes.  Group, Text, and all Shapes are not
 2885      * resizable and hence depend on the application to establish their sizing
 2886      * by setting appropriate properties (e.g.  width/height for Rectangle,
 2887      * text on Text, and so on).  Non-resizable nodes may still be relocated
 2888      * during layout.
 2889      *
 2890      * @see #getContentBias()
 2891      * @see #minWidth(double)
 2892      * @see #minHeight(double)
 2893      * @see #prefWidth(double)
 2894      * @see #prefHeight(double)
 2895      * @see #maxWidth(double)
 2896      * @see #maxHeight(double)
 2897      * @see #resize(double, double)
 2898      * @see #getLayoutBounds()
 2899      *
 2900      * @return whether or not this node type can be resized by its parent during layout
 2901      */
 2902     public boolean isResizable() {
 2903         return false;
 2904     }
 2905 
 2906     /**
 2907      * Returns the orientation of a node&#39;s resizing bias for layout purposes.
 2908      * If the node type has no bias, returns null.  If the node is resizable and
 2909      * it&#39;s height depends on its width, returns HORIZONTAL, else if its width
 2910      * depends on its height, returns VERTICAL.
 2911      * &lt;p&gt;
 2912      * Resizable subclasses should override this method to return an
 2913      * appropriate value.
 2914      *
 2915      * @see #isResizable()
 2916      * @see #minWidth(double)
 2917      * @see #minHeight(double)
 2918      * @see #prefWidth(double)
 2919      * @see #prefHeight(double)
 2920      * @see #maxWidth(double)
 2921      * @see #maxHeight(double)
 2922      *
 2923      * @return orientation of width/height dependency or null if there is none
 2924      */
 2925     public Orientation getContentBias() {
 2926         return null;
 2927     }
 2928 
 2929     /**
 2930      * Returns the node&#39;s minimum width for use in layout calculations.
 2931      * If the node is resizable, its parent should not resize its width any
 2932      * smaller than this value.  If the node is not resizable, returns its
 2933      * layoutBounds width.
 2934      * &lt;p&gt;
 2935      * Layout code which calls this method should first check the content-bias
 2936      * of the node.  If the node has a vertical content-bias, then callers
 2937      * should pass in a height value that the minimum width should be based on.
 2938      * If the node has either a horizontal or null content-bias, then the caller
 2939      * should pass in -1.
 2940      * &lt;p&gt;
 2941      * Node subclasses with a vertical content-bias should honor the height
 2942      * parameter whether -1 or a positive value.   All other subclasses may ignore
 2943      * the height parameter (which will likely be -1).
 2944      * &lt;p&gt;
 2945      * If Node&#39;s {@link #maxWidth(double)} is lower than this number,
 2946      * {@code minWidth} takes precedence. This means the Node should never be resized below {@code minWidth}.
 2947      *
 2948      * @see #isResizable()
 2949      * @see #getContentBias()
 2950      *
 2951      * @param height the height that should be used if minimum width depends on it
 2952      * @return the minimum width that the node should be resized to during layout.
 2953      *         The result will never be NaN, nor will it ever be negative.
 2954      */
 2955     public double minWidth(double height) {
 2956         return prefWidth(height);
 2957     }
 2958 
 2959     /**
 2960      * Returns the node&#39;s minimum height for use in layout calculations.
 2961      * If the node is resizable, its parent should not resize its height any
 2962      * smaller than this value.  If the node is not resizable, returns its
 2963      * layoutBounds height.
 2964      * &lt;p&gt;
 2965      * Layout code which calls this method should first check the content-bias
 2966      * of the node.  If the node has a horizontal content-bias, then callers
 2967      * should pass in a width value that the minimum height should be based on.
 2968      * If the node has either a vertical or null content-bias, then the caller
 2969      * should pass in -1.
 2970      * &lt;p&gt;
 2971      * Node subclasses with a horizontal content-bias should honor the width
 2972      * parameter whether -1 or a positive value.   All other subclasses may ignore
 2973      * the width parameter (which will likely be -1).
 2974      * &lt;p&gt;
 2975      * If Node&#39;s {@link #maxHeight(double)} is lower than this number,
 2976      * {@code minHeight} takes precedence. This means the Node should never be resized below {@code minHeight}.
 2977      *
 2978      * @see #isResizable()
 2979      * @see #getContentBias()
 2980      *
 2981      * @param width the width that should be used if minimum height depends on it
 2982      * @return the minimum height that the node should be resized to during layout
 2983      *         The result will never be NaN, nor will it ever be negative.
 2984      */
 2985     public double minHeight(double width) {
 2986         return prefHeight(width);
 2987     }
 2988 
 2989     /**
 2990      * Returns the node&#39;s preferred width for use in layout calculations.
 2991      * If the node is resizable, its parent should treat this value as the
 2992      * node&#39;s ideal width within its range.  If the node is not resizable,
 2993      * just returns its layoutBounds width, which should be treated as the rigid
 2994      * width of the node.
 2995      * &lt;p&gt;
 2996      * Layout code which calls this method should first check the content-bias
 2997      * of the node.  If the node has a vertical content-bias, then callers
 2998      * should pass in a height value that the preferred width should be based on.
 2999      * If the node has either a horizontal or null content-bias, then the caller
 3000      * should pass in -1.
 3001      * &lt;p&gt;
 3002      * Node subclasses with a vertical content-bias should honor the height
 3003      * parameter whether -1 or a positive value.   All other subclasses may ignore
 3004      * the height parameter (which will likely be -1).
 3005      *
 3006      * @see #isResizable()
 3007      * @see #getContentBias()
 3008      * @see #autosize()
 3009      *
 3010      * @param height the height that should be used if preferred width depends on it
 3011      * @return the preferred width that the node should be resized to during layout
 3012      *         The result will never be NaN, nor will it ever be negative.
 3013      */
 3014     public double prefWidth(double height) {
 3015         final double result = getLayoutBounds().getWidth();
 3016         return Double.isNaN(result) || result &lt; 0 ? 0 : result;
 3017     }
 3018 
 3019     /**
 3020      * Returns the node&#39;s preferred height for use in layout calculations.
 3021      * If the node is resizable, its parent should treat this value as the
 3022      * node&#39;s ideal height within its range.  If the node is not resizable,
 3023      * just returns its layoutBounds height, which should be treated as the rigid
 3024      * height of the node.
 3025      * &lt;p&gt;
 3026      * Layout code which calls this method should first check the content-bias
 3027      * of the node.  If the node has a horizontal content-bias, then callers
 3028      * should pass in a width value that the preferred height should be based on.
 3029      * If the node has either a vertical or null content-bias, then the caller
 3030      * should pass in -1.
 3031      * &lt;p&gt;
 3032      * Node subclasses with a horizontal content-bias should honor the height
 3033      * parameter whether -1 or a positive value.   All other subclasses may ignore
 3034      * the height parameter (which will likely be -1).
 3035      *
 3036      * @see #getContentBias()
 3037      * @see #autosize()
 3038      *
 3039      * @param width the width that should be used if preferred height depends on it
 3040      * @return the preferred height that the node should be resized to during layout
 3041      *         The result will never be NaN, nor will it ever be negative.
 3042      */
 3043     public double prefHeight(double width) {
 3044         final double result = getLayoutBounds().getHeight();
 3045         return Double.isNaN(result) || result &lt; 0 ? 0 : result;
 3046     }
 3047 
 3048     /**
 3049      * Returns the node&#39;s maximum width for use in layout calculations.
 3050      * If the node is resizable, its parent should not resize its width any
 3051      * larger than this value.  A value of Double.MAX_VALUE indicates the
 3052      * parent may expand the node&#39;s width beyond its preferred without limits.
 3053      * &lt;p&gt;
 3054      * If the node is not resizable, returns its layoutBounds width.
 3055      * &lt;p&gt;
 3056      * Layout code which calls this method should first check the content-bias
 3057      * of the node.  If the node has a vertical content-bias, then callers
 3058      * should pass in a height value that the maximum width should be based on.
 3059      * If the node has either a horizontal or null content-bias, then the caller
 3060      * should pass in -1.
 3061      * &lt;p&gt;
 3062      * Node subclasses with a vertical content-bias should honor the height
 3063      * parameter whether -1 or a positive value.   All other subclasses may ignore
 3064      * the height parameter (which will likely be -1).
 3065      * &lt;p&gt;
 3066      * If Node&#39;s {@link #minWidth(double)} is greater, it should take precedence
 3067      * over the {@code maxWidth}. This means the Node should never be resized below {@code minWidth}.
 3068      *
 3069      * @see #isResizable()
 3070      * @see #getContentBias()
 3071      *
 3072      * @param height the height that should be used if maximum width depends on it
 3073      * @return the maximum width that the node should be resized to during layout
 3074      *         The result will never be NaN, nor will it ever be negative.
 3075      */
 3076     public double maxWidth(double height) {
 3077         return prefWidth(height);
 3078     }
 3079 
 3080     /**
 3081      * Returns the node&#39;s maximum height for use in layout calculations.
 3082      * If the node is resizable, its parent should not resize its height any
 3083      * larger than this value.  A value of Double.MAX_VALUE indicates the
 3084      * parent may expand the node&#39;s height beyond its preferred without limits.
 3085      * &lt;p&gt;
 3086      * If the node is not resizable, returns its layoutBounds height.
 3087      * &lt;p&gt;
 3088      * Layout code which calls this method should first check the content-bias
 3089      * of the node.  If the node has a horizontal content-bias, then callers
 3090      * should pass in a width value that the maximum height should be based on.
 3091      * If the node has either a vertical or null content-bias, then the caller
 3092      * should pass in -1.
 3093      * &lt;p&gt;
 3094      * Node subclasses with a horizontal content-bias should honor the width
 3095      * parameter whether -1 or a positive value.   All other subclasses may ignore
 3096      * the width parameter (which will likely be -1).
 3097      * &lt;p&gt;
 3098      * If Node&#39;s {@link #minHeight(double)} is greater, it should take precedence
 3099      * over the {@code maxHeight}.  This means the Node should never be resized below {@code minHeight}.
 3100      *
 3101      * @see #isResizable()
 3102      * @see #getContentBias()
 3103      *
 3104      * @param width the width that should be used if maximum height depends on it
 3105      * @return the maximum height that the node should be resized to during layout
 3106      *         The result will never be NaN, nor will it ever be negative.
 3107      */
 3108     public double maxHeight(double width) {
 3109         return prefHeight(width);
 3110     }
 3111 
 3112     /**
 3113      * If the node is resizable, will set its layout bounds to the specified
 3114      * width and height.   If the node is not resizable, this method is a no-op.
 3115      * &lt;p&gt;
 3116      * This method should generally only be called by parent nodes from their
 3117      * layoutChildren() methods.   All Parent classes will automatically resize
 3118      * resizable children, so resizing done directly by the application will be
 3119      * overridden by the node&#39;s parent, unless the child is unmanaged.
 3120      * &lt;p&gt;
 3121      * Parents are responsible for ensuring the width and height values fall
 3122      * within the resizable node&#39;s preferred range.  The autosize() method may
 3123      * be used if the parent just needs to resize the node to its preferred size.
 3124      *
 3125      * @see #isResizable()
 3126      * @see #getContentBias()
 3127      * @see #autosize()
 3128      * @see #minWidth(double)
 3129      * @see #minHeight(double)
 3130      * @see #prefWidth(double)
 3131      * @see #prefHeight(double)
 3132      * @see #maxWidth(double)
 3133      * @see #maxHeight(double)
 3134      * @see #getLayoutBounds()
 3135      *
 3136      * @param width the target layout bounds width
 3137      * @param height the target layout bounds height
 3138      */
 3139     public void resize(double width, double height) {
 3140     }
 3141 
 3142     /**
 3143      * If the node is resizable, will set its layout bounds to its current preferred
 3144      * width and height. If the node is not resizable, this method is a no-op.
 3145      * &lt;p&gt;
 3146      * This method automatically queries the node&#39;s content-bias and if it&#39;s
 3147      * horizontal, will pass in the node&#39;s preferred width to get the preferred
 3148      * height; if vertical, will pass in the node&#39;s preferred height to get the width,
 3149      * and if null, will compute the preferred width/height independently.
 3150      * &lt;/p&gt;
 3151      *
 3152      * @see #isResizable()
 3153      * @see #getContentBias()
 3154      *
 3155      */
 3156     public final void autosize() {
 3157         if (isResizable()) {
 3158             Orientation contentBias = getContentBias();
 3159             double w, h;
 3160             if (contentBias == null) {
 3161                 w = boundedSize(prefWidth(-1), minWidth(-1), maxWidth(-1));
 3162                 h = boundedSize(prefHeight(-1), minHeight(-1), maxHeight(-1));
 3163             } else if (contentBias == Orientation.HORIZONTAL) {
 3164                 w = boundedSize(prefWidth(-1), minWidth(-1), maxWidth(-1));
 3165                 h = boundedSize(prefHeight(w), minHeight(w), maxHeight(w));
 3166             } else { // bias == VERTICAL
 3167                 h = boundedSize(prefHeight(-1), minHeight(-1), maxHeight(-1));
 3168                 w = boundedSize(prefWidth(h), minWidth(h), maxWidth(h));
 3169             }
 3170             resize(w,h);
 3171         }
 3172     }
 3173 
 3174     double boundedSize(double value, double min, double max) {
 3175         // if max &lt; value, return max
 3176         // if min &gt; value, return min
 3177         // if min &gt; max, return min
 3178         return Math.min(Math.max(value, min), Math.max(min,max));
 3179     }
 3180 
 3181     /**
 3182      * If the node is resizable, will set its layout bounds to the specified
 3183      * width and height.   If the node is not resizable, the resize step is skipped.
 3184      * &lt;p&gt;
 3185      * Once the node has been resized (if resizable) then sets the node&#39;s layoutX
 3186      * and layoutY translation properties in order to relocate it to x,y in the
 3187      * parent&#39;s coordinate space.
 3188      * &lt;p&gt;
 3189      * This method should generally only be called by parent nodes from their
 3190      * layoutChildren() methods.   All Parent classes will automatically resize
 3191      * resizable children, so resizing done directly by the application will be
 3192      * overridden by the node&#39;s parent, unless the child is unmanaged.
 3193      * &lt;p&gt;
 3194      * Parents are responsible for ensuring the width and height values fall
 3195      * within the resizable node&#39;s preferred range.  The autosize() and relocate()
 3196      * methods may be used if the parent just needs to resize the node to its
 3197      * preferred size and reposition it.
 3198      *
 3199      * @see #isResizable()
 3200      * @see #getContentBias()
 3201      * @see #autosize()
 3202      * @see #minWidth(double)
 3203      * @see #minHeight(double)
 3204      * @see #prefWidth(double)
 3205      * @see #prefHeight(double)
 3206      * @see #maxWidth(double)
 3207      * @see #maxHeight(double)
 3208      *
 3209      * @param x the target x coordinate location
 3210      * @param y the target y coordinate location
 3211      * @param width the target layout bounds width
 3212      * @param height the target layout bounds height
 3213      *
 3214      */
 3215     public void resizeRelocate(double x, double y, double width, double height) {
 3216         resize(width, height);
 3217         relocate(x,y);
 3218     }
 3219 
 3220     /**
 3221      * This is a special value that might be returned by {@link #getBaselineOffset()}.
 3222      * This means that the Parent (layout Pane) of this Node should use the height of this Node as a baseline.
 3223      */
 3224     public static final double BASELINE_OFFSET_SAME_AS_HEIGHT = Double.NEGATIVE_INFINITY;
 3225 
 3226     /**
 3227      * The &#39;alphabetic&#39; (or &#39;roman&#39;) baseline offset from the node&#39;s layoutBounds.minY location
 3228      * that should be used when this node is being vertically aligned by baseline with
 3229      * other nodes.  By default this returns {@link #BASELINE_OFFSET_SAME_AS_HEIGHT} for resizable Nodes
 3230      * and layoutBounds height for non-resizable.  Subclasses
 3231      * which contain text should override this method to return their actual text baseline offset.
 3232      *
 3233      * @return offset of text baseline from layoutBounds.minY for non-resizable Nodes or {@link #BASELINE_OFFSET_SAME_AS_HEIGHT} otherwise
 3234      */
 3235     public double getBaselineOffset() {
 3236         if (isResizable()) {
 3237             return BASELINE_OFFSET_SAME_AS_HEIGHT;
 3238         } else {
 3239             return getLayoutBounds().getHeight();
 3240         }
 3241     }
 3242 
 3243     /**
 3244      * Returns the area of this {@code Node} projected onto the
 3245      * physical screen in pixel units.
 3246      * @return the area of this {@code Node} projected onto the physical screen
 3247      * @since JavaFX 8.0
 3248      */
 3249     public double computeAreaInScreen() {
 3250         return doComputeAreaInScreen();
 3251     }
 3252 
 3253     /*
 3254      * Help application or utility to implement LOD support by returning the
 3255      * projected area of a Node in pixel unit. The projected area is not clipped.
 3256      *
 3257      * For perspective camera, this method first exams node&#39;s bounds against
 3258      * camera&#39;s clipping plane to cut off those out of viewing frustrum. After
 3259      * computing areaInScreen, it applies a tight viewing frustrum check using
 3260      * canonical view volume.
 3261      *
 3262      * The result of areaInScreen comes from the product of
 3263      * (projViewTx x localToSceneTransform x localBounds).
 3264      *
 3265      * Returns 0 for those fall outside viewing frustrum.
 3266      */
 3267     private double doComputeAreaInScreen() {
 3268         Scene tmpScene = getScene();
 3269         if (tmpScene != null) {
 3270             Bounds bounds = getBoundsInLocal();
 3271             Camera camera = tmpScene.getEffectiveCamera();
 3272             boolean isPerspective = camera instanceof PerspectiveCamera ? true : false;
 3273             Transform localToSceneTx = getLocalToSceneTransform();
 3274             Affine3D tempTx = TempState.getInstance().tempTx;
 3275             BaseBounds localBounds = new BoxBounds((float) bounds.getMinX(),
 3276                                                    (float) bounds.getMinY(),
 3277                                                    (float) bounds.getMinZ(),
 3278                                                    (float) bounds.getMaxX(),
 3279                                                    (float) bounds.getMaxY(),
 3280                                                    (float) bounds.getMaxZ());
 3281 
 3282             // NOTE: Viewing frustrum check on camera&#39;s clipping plane is now only
 3283             // for perspective camera.
 3284             // TODO: Need to hook up parallel camera&#39;s nearClip and farClip.
 3285             if (isPerspective) {
 3286                 Transform cameraL2STx = camera.getLocalToSceneTransform();
 3287 
 3288                 // If camera transform only contains translate, compare in scene
 3289                 // coordinate. Otherwise, compare in camera coordinate.
 3290                 if (cameraL2STx.getMxx() == 1.0
 3291                         &amp;&amp; cameraL2STx.getMxy() == 0.0
 3292                         &amp;&amp; cameraL2STx.getMxz() == 0.0
 3293                         &amp;&amp; cameraL2STx.getMyx() == 0.0
 3294                         &amp;&amp; cameraL2STx.getMyy() == 1.0
 3295                         &amp;&amp; cameraL2STx.getMyz() == 0.0
 3296                         &amp;&amp; cameraL2STx.getMzx() == 0.0
 3297                         &amp;&amp; cameraL2STx.getMzy() == 0.0
 3298                         &amp;&amp; cameraL2STx.getMzz() == 1.0) {
 3299 
 3300                     double minZ, maxZ;
 3301 
 3302                     // If node transform only contains translate, only convert
 3303                     // minZ and maxZ to scene coordinate. Otherwise, convert
 3304                     // node bounds to scene coordinate.
 3305                     if (localToSceneTx.getMxx() == 1.0
 3306                             &amp;&amp; localToSceneTx.getMxy() == 0.0
 3307                             &amp;&amp; localToSceneTx.getMxz() == 0.0
 3308                             &amp;&amp; localToSceneTx.getMyx() == 0.0
 3309                             &amp;&amp; localToSceneTx.getMyy() == 1.0
 3310                             &amp;&amp; localToSceneTx.getMyz() == 0.0
 3311                             &amp;&amp; localToSceneTx.getMzx() == 0.0
 3312                             &amp;&amp; localToSceneTx.getMzy() == 0.0
 3313                             &amp;&amp; localToSceneTx.getMzz() == 1.0) {
 3314 
 3315                         Vec3d tempV3D = TempState.getInstance().vec3d;
 3316                         tempV3D.set(0, 0, bounds.getMinZ());
 3317                         localToScene(tempV3D);
 3318                         minZ = tempV3D.z;
 3319 
 3320                         tempV3D.set(0, 0, bounds.getMaxZ());
 3321                         localToScene(tempV3D);
 3322                         maxZ = tempV3D.z;
 3323                     } else {
 3324                         Bounds nodeInSceneBounds = localToScene(bounds);
 3325                         minZ = nodeInSceneBounds.getMinZ();
 3326                         maxZ = nodeInSceneBounds.getMaxZ();
 3327                     }
 3328 
 3329                     if (minZ &gt; camera.getFarClipInScene()
 3330                             || maxZ &lt; camera.getNearClipInScene()) {
 3331                         return 0;
 3332                     }
 3333 
 3334                 } else {
 3335                     BaseBounds nodeInCameraBounds = new BoxBounds();
 3336 
 3337                     // We need to set tempTx to identity since it is a recycled transform.
 3338                     // This is because TransformHelper.apply() is a matrix concatenation operation.
 3339                     tempTx.setToIdentity();
 3340                     TransformHelper.apply(localToSceneTx, tempTx);
 3341 
 3342                     // Convert node from local coordinate to camera coordinate
 3343                     tempTx.preConcatenate(camera.getSceneToLocalTransform());
 3344                     tempTx.transform(localBounds, nodeInCameraBounds);
 3345 
 3346                     // Compare in camera coordinate
 3347                     if (nodeInCameraBounds.getMinZ() &gt; camera.getFarClip()
 3348                             || nodeInCameraBounds.getMaxZ() &lt; camera.getNearClip()) {
 3349                         return 0;
 3350                     }
 3351                 }
 3352             }
 3353 
 3354             GeneralTransform3D projViewTx = TempState.getInstance().projViewTx;
 3355             projViewTx.set(camera.getProjViewTransform());
 3356 
 3357             // We need to set tempTx to identity since it is a recycled transform.
 3358             // This is because TransformHelper.apply() is a matrix concatenation operation.
 3359             tempTx.setToIdentity();
 3360             TransformHelper.apply(localToSceneTx, tempTx);
 3361 
 3362             // The product of projViewTx * localToSceneTransform
 3363             GeneralTransform3D tx = projViewTx.mul(tempTx);
 3364 
 3365             // Transform localBounds to projected bounds
 3366             localBounds = tx.transform(localBounds, localBounds);
 3367             double area = localBounds.getWidth() * localBounds.getHeight();
 3368 
 3369             // Use canonical view volume to check whether object is outside the
 3370             // viewing frustrum
 3371             if (isPerspective) {
 3372                 localBounds.intersectWith(-1, -1, 0, 1, 1, 1);
 3373                 area = (localBounds.getWidth() &lt; 0 || localBounds.getHeight() &lt; 0) ? 0 : area;
 3374             }
 3375             return area * (camera.getViewWidth() / 2 * camera.getViewHeight() / 2);
 3376         }
 3377         return 0;
 3378     }
 3379 
 3380     /* *************************************************************************
 3381      *                                                                         *
 3382      * Bounds related APIs                                                     *
 3383      *                                                                         *
 3384      **************************************************************************/
 3385 
 3386     public final Bounds getBoundsInParent() {
 3387         return boundsInParentProperty().get();
 3388     }
 3389 
 3390     /**
 3391      * The rectangular bounds of this {@code Node} which include its transforms.
 3392      * {@code boundsInParent} is calculated by
 3393      * taking the local bounds (defined by {@link #boundsInLocalProperty boundsInLocal}) and applying
 3394      * the transform created by setting the following additional variables
 3395      * &lt;ol&gt;
 3396      * &lt;li&gt;{@link #getTransforms transforms} ObservableList&lt;/li&gt;
 3397      * &lt;li&gt;{@link #scaleXProperty scaleX}, {@link #scaleYProperty scaleY}, {@link #scaleZProperty scaleZ}&lt;/li&gt;
 3398      * &lt;li&gt;{@link #rotateProperty rotate}&lt;/li&gt;
 3399      * &lt;li&gt;{@link #layoutXProperty layoutX}, {@link #layoutYProperty layoutY}&lt;/li&gt;
 3400      * &lt;li&gt;{@link #translateXProperty translateX}, {@link #translateYProperty translateY},
 3401      * {@link #translateZProperty translateZ}&lt;/li&gt;
 3402      * &lt;/ol&gt;
 3403      * &lt;p&gt;
 3404      * The resulting bounds will be conceptually in the coordinate space of the
 3405      * {@code Node}&#39;s parent, however the node need not have a parent to calculate
 3406      * these bounds.
 3407      * &lt;p&gt;
 3408      * Note that this method does not take the node&#39;s visibility into account;
 3409      * the computation is based on the geometry of this {@code Node} only.
 3410      * &lt;p&gt;
 3411      * This property will always have a non-null value.
 3412      * &lt;p&gt;
 3413      * Note that {@code boundsInParent} is automatically recomputed whenever the
 3414      * geometry of a node changes, or when any of the following the change:
 3415      * transforms {@code ObservableList}, any of the translate, layout or scale
 3416      * variables, or the rotate variable. For this reason, it is an error
 3417      * to bind any of these values in a node to an expression that depends upon
 3418      * this variable. For example, the x or y variables of a shape, or
 3419      * {@code translateX}, {@code translateY} should never be bound to
 3420      * {@code boundsInParent} for the purpose of positioning the node.
 3421      * @return the boundsInParent for this {@code Node}
 3422      */
 3423     public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInParentProperty() {
 3424         return getMiscProperties().boundsInParentProperty();
 3425     }
 3426 
 3427     private void invalidateBoundsInParent() {
 3428         if (miscProperties != null) {
 3429             miscProperties.invalidateBoundsInParent();
 3430         }
 3431     }
 3432 
 3433     public final Bounds getBoundsInLocal() {
 3434         return boundsInLocalProperty().get();
 3435     }
 3436 
 3437     /**
 3438      * The rectangular bounds of this {@code Node} in the node&#39;s
 3439      * untransformed local coordinate space.  For nodes that extend
 3440      * {@link javafx.scene.shape.Shape}, the local bounds will also include
 3441      * space required for a non-zero stroke that may fall outside the shape&#39;s
 3442      * geometry that is defined by position and size attributes.
 3443      * The local bounds will also include any clipping set with {@link #clipProperty clip}
 3444      * as well as effects set with {@link #effectProperty effect}.
 3445      *
 3446      * &lt;p&gt;
 3447      * Note that this method does not take the node&#39;s visibility into account;
 3448      * the computation is based on the geometry of this {@code Node} only.
 3449      * &lt;p&gt;
 3450      * This property will always have a non-null value.
 3451      * &lt;p&gt;
 3452      * Note that boundsInLocal is automatically recomputed whenever the
 3453      * geometry of a node changes. For this reason, it is an error to bind any
 3454      * of these values in a node to an expression that depends upon this variable.
 3455      * For example, the x or y variables of a shape should never be bound
 3456      * to boundsInLocal for the purpose of positioning the node.
 3457      * @return the boundsInLocal for this {@code Node}
 3458      */
 3459     public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInLocalProperty() {
 3460         return getMiscProperties().boundsInLocalProperty();
 3461     }
 3462 
 3463     private void invalidateBoundsInLocal() {
 3464         if (miscProperties != null) {
 3465             miscProperties.invalidateBoundsInLocal();
 3466         }
 3467     }
 3468 
 3469     /**
 3470      * The rectangular bounds that should be used for layout calculations for
 3471      * this node. {@code layoutBounds} may differ from the visual bounds
 3472      * of the node and is computed differently depending on the node type.
 3473      * &lt;p&gt;
 3474      * If the node type is resizable ({@link javafx.scene.layout.Region Region},
 3475      * {@link javafx.scene.control.Control Control}, or {@link javafx.scene.web.WebView WebView})
 3476      * then the layoutBounds will always be {@code 0,0 width x height}.
 3477      * If the node type is not resizable ({@link javafx.scene.shape.Shape Shape},
 3478      * {@link javafx.scene.text.Text Text}, or {@link Group}), then the {@code layoutBounds}
 3479      * are computed based on the node&#39;s geometric properties and does not include the
 3480      * node&#39;s clip, effect, or transforms.  See individual class documentation
 3481      * for details.
 3482      * &lt;p&gt;
 3483      * Note that the {@link #layoutXProperty layoutX}, {@link #layoutYProperty layoutY},
 3484      * {@link #translateXProperty translateX}, and {@link #translateYProperty translateY}
 3485      * variables are not included in the layoutBounds.
 3486      * This is important because layout code must first determine the current
 3487      * size and location of the node (using {@code layoutBounds}) and then set
 3488      * {@code layoutX} and {@code layoutY} to adjust the translation of the
 3489      * node so that it will have the desired layout position.
 3490      * &lt;p&gt;
 3491      * Because the computation of layoutBounds is often tied to a node&#39;s
 3492      * geometric variables, it is an error to bind any such variables to an
 3493      * expression that depends upon {@code layoutBounds}. For example, the
 3494      * x or y variables of a shape should never be bound to {@code layoutBounds}
 3495      * for the purpose of positioning the node.
 3496      * &lt;p&gt;
 3497      * Note that for 3D shapes, the layout bounds is actually a rectangular box
 3498      * with X, Y, and Z values, although only X and Y are used in layout calculations.
 3499      * &lt;p&gt;
 3500      * The {@code layoutBounds} will never be null.
 3501      *
 3502      */
 3503     private LazyBoundsProperty layoutBounds = new LazyBoundsProperty() {
 3504         @Override
 3505         protected Bounds computeBounds() {
 3506             return NodeHelper.computeLayoutBounds(Node.this);
 3507         }
 3508 
 3509         @Override
 3510         public Object getBean() {
 3511             return Node.this;
 3512         }
 3513 
 3514         @Override
 3515         public String getName() {
 3516             return &quot;layoutBounds&quot;;
 3517         }
 3518     };
 3519 
 3520     public final Bounds getLayoutBounds() {
 3521         return layoutBoundsProperty().get();
 3522     }
 3523 
 3524     public final ReadOnlyObjectProperty&lt;Bounds&gt; layoutBoundsProperty() {
 3525         return layoutBounds;
 3526     }
 3527 
 3528     /*
 3529      *                  Bounds And Transforms Computation
 3530      *
 3531      *  This section of the code is responsible for computing and caching
 3532      *  various bounds and transforms. For optimal performance and minimal
 3533      *  recomputation of bounds (which can be quite expensive), we cache
 3534      *  values on two different levels. We expose two public immutable
 3535      *  Bounds boundsInParent objects and boundsInLocal. Because they are
 3536      *  immutable and because they may change quite frequently (especially
 3537      *  in the case of a Parent whose children are animated), it is
 3538      *  important that the system does not rely on these variables, because
 3539      *  doing so would produce a large amount of garbage. Rather, these
 3540      *  variables are provided solely for the convenience of application
 3541      *  developers and, being lazily bound, should generally be created at
 3542      *  most once per frame.
 3543      *
 3544      *  The second level of caching are within local Bounds2D variables.
 3545      *  These variables, txBounds and geomBounds, are mutable and as such
 3546      *  can be cached and updated as frequently as necessary without creating
 3547      *  excessive garbage. However, since the computation of bounds is still
 3548      *  expensive, it is desirable to cache both the geometric bounds and
 3549      *  the &quot;complete&quot; transformed bounds (essentially, boundsInParent).
 3550      *  Cached txBounds is particularly useful when computing the geometric
 3551      *  bounds of a Parent since it would not require complete or partial
 3552      *  recomputation of each child.
 3553      *
 3554      *  Finally, we cache the complete transform for this node which converts
 3555      *  its coord system from local to parent coords. This is useful both for
 3556      *  minimizing bounds recomputations in the case of the geometry having
 3557      *  changed but the transform not having changed, and also because the tx
 3558      *  is required for several different computations (for example, it must
 3559      *  be computed once during state synchronization with the PG peer, and
 3560      *  must also be computed when the pivot point changes, and also when
 3561      *  deriving the txBounds of the Node).
 3562      *
 3563      *  As with any caching system, a subtle and non-trivial amount of code
 3564      *  is devoted to invalidating the bounds / transforms at appropriate
 3565      *  times and in appropriate places to make sure bounds / transforms
 3566      *  are recomputed at all necessary times.
 3567      *
 3568      *  There are three computeXXX functions. One is for computing the
 3569      *  boundsInParent, the second for computing boundsInLocal, and the
 3570      *  third for computing the default layout bounds (which, by default,
 3571      *  is based on the geometric bounds). These functions are all prefixed
 3572      *  with &quot;compute&quot; because they create and return new immutable
 3573      *  Bounds objects.
 3574      *
 3575      *  There are three getXXXBounds functions. One is for returning the
 3576      *  complete transformed bounds. The second is for returning the
 3577      *  local bounds. The last is for returning the geometric bounds. These
 3578      *  functions are all prefixed with &quot;get&quot; because they may well return
 3579      *  a cached value, or may actually compute the bounds if necessary. These
 3580      *  functions all have the same signature. They take a Bounds2D and
 3581      *  BaseTransform, and return a Bounds2D (the same as they took). These
 3582      *  functions essentially populate the supplied bounds2D with the
 3583      *  appropriate bounds information, leveraging cached bounds if possible.
 3584      *
 3585      *  There is a single NodeHelper.computeGeomBoundsImpl function which is abstract.
 3586      *  This must be implemented in each subclass, and is responsible for
 3587      *  computing the actual geometric bounds for the Node. For example, Parent
 3588      *  is written such that this function is the union of the transformed
 3589      *  bounds of each child. Rectangle is written such that this takes into
 3590      *  account the size and stroke. Text is written such that it is computed
 3591      *  based on the actual glyphs.
 3592      *
 3593      *  There are two updateXXX functions, updateGeomBounds and updateTxBounds.
 3594      *  These functions are for ensuring that geomBounds and txBounds are
 3595      *  valid. They only execute in the case of the cached value being invalid,
 3596      *  so the function call is very cheap in cases where the cached bounds
 3597      *  values are still valid.
 3598      */
 3599 
 3600     /**
 3601      * An affine transform that holds the computed local-to-parent transform.
 3602      * This is the concatenation of all transforms in this node, including all
 3603      * of the convenience transforms.
 3604      */
 3605     private BaseTransform localToParentTx = BaseTransform.IDENTITY_TRANSFORM;
 3606 
 3607     /**
 3608      * This flag is used to indicate that localToParentTx is dirty and needs
 3609      * to be recomputed.
 3610      */
 3611     private boolean transformDirty = true;
 3612 
 3613     /**
 3614      * The cached transformed bounds. This is never null, but is frequently set
 3615      * to be invalid whenever the bounds for the node have changed. These are
 3616      * &quot;complete&quot; bounds, that is, with transforms and effect and clip applied.
 3617      * Note that this is equivalent to boundsInParent
 3618      */
 3619     private BaseBounds txBounds = new RectBounds();
 3620 
 3621     /**
 3622      * The cached bounds. This is never null, but is frequently set to be
 3623      * invalid whenever the bounds for the node have changed. These are the
 3624      * &quot;content&quot; bounds, that is, without transforms or effects applied.
 3625      */
 3626     private BaseBounds geomBounds = new RectBounds();
 3627 
 3628     /**
 3629      * The cached local bounds (without transforms, with clip and effects).
 3630      * If there is neither clip nor effect
 3631      * local bounds are equal to geom bounds, so in this case we don&#39;t keep
 3632      * the extra instance and set null to this variable.
 3633      */
 3634     private BaseBounds localBounds = null;
 3635 
 3636     /**
 3637      * This special flag is used only by Parent to flag whether or not
 3638      * the *parent* has processed the fact that bounds have changed for this
 3639      * child Node. We need some way of flagging this on a per-node basis to
 3640      * enable the significant performance optimizations and fast paths that
 3641      * are in the Parent code.
 3642      * &lt;p&gt;
 3643      * To reduce confusion, although this variable is defined on Node, it
 3644      * really belongs to the Parent of the node and should *only* be modified
 3645      * by the parent.
 3646      */
 3647     boolean boundsChanged;
 3648 
 3649     /*
 3650      * Returns geometric bounds, but may be over-ridden by a subclass.
 3651      */
 3652     private Bounds doComputeLayoutBounds() {
 3653         BaseBounds tempBounds = TempState.getInstance().bounds;
 3654         tempBounds = getGeomBounds(tempBounds,
 3655                                    BaseTransform.IDENTITY_TRANSFORM);
 3656         return new BoundingBox(tempBounds.getMinX(),
 3657                                tempBounds.getMinY(),
 3658                                tempBounds.getMinZ(),
 3659                                tempBounds.getWidth(),
 3660                                tempBounds.getHeight(),
 3661                                tempBounds.getDepth());
 3662     }
 3663 
 3664     /*
 3665      * Subclasses may customize the layoutBounds by means of overriding the
 3666      * NodeHelper.computeLayoutBoundsImpl method. If the layout bounds need to be
 3667      * recomputed, the subclass must notify the Node implementation of this
 3668      * fact so that appropriate notifications and internal state can be
 3669      * kept in sync. Subclasses must call NodeHelper.layoutBoundsChanged to
 3670      * let Node know that the layout bounds are invalid and need to be
 3671      * recomputed.
 3672      */
 3673     final void layoutBoundsChanged() {
 3674         if (!layoutBounds.valid) {
 3675             return;
 3676         }
 3677         layoutBounds.invalidate();
 3678         if ((nodeTransformation != null &amp;&amp; nodeTransformation.hasScaleOrRotate()) || hasMirroring()) {
 3679             // if either the scale or rotate convenience variables are used,
 3680             // then we need a valid pivot point. Since the layoutBounds
 3681             // affects the pivot we need to invalidate the transform
 3682             NodeHelper.transformsChanged(this);
 3683         }
 3684     }
 3685 
 3686     /**
 3687      * Loads the given bounds object with the transformed bounds relative to,
 3688      * and based on, the given transform. That is, this is the local bounds
 3689      * with the local-to-parent transform applied.
 3690      *
 3691      * We *never* pass null in as a bounds. This method will
 3692      * NOT take a null bounds object. The returned value may be
 3693      * the same bounds object passed in, or it may be a new object.
 3694      * The reason for this object promotion is in the case of needing
 3695      * to promote from a RectBounds to a BoxBounds (3D).
 3696      */
 3697     BaseBounds getTransformedBounds(BaseBounds bounds, BaseTransform tx) {
 3698         updateLocalToParentTransform();
 3699         if (tx.isTranslateOrIdentity()) {
 3700             updateTxBounds();
 3701             bounds = bounds.deriveWithNewBounds(txBounds);
 3702             if (!tx.isIdentity()) {
 3703                 final double translateX = tx.getMxt();
 3704                 final double translateY = tx.getMyt();
 3705                 final double translateZ = tx.getMzt();
 3706                 bounds = bounds.deriveWithNewBounds(
 3707                                     (float) (bounds.getMinX() + translateX),
 3708                                     (float) (bounds.getMinY() + translateY),
 3709                                     (float) (bounds.getMinZ() + translateZ),
 3710                                     (float) (bounds.getMaxX() + translateX),
 3711                                     (float) (bounds.getMaxY() + translateY),
 3712                                     (float) (bounds.getMaxZ() + translateZ));
 3713             }
 3714             return bounds;
 3715         } else if (localToParentTx.isIdentity()) {
 3716             return getLocalBounds(bounds, tx);
 3717         } else {
 3718             double mxx = tx.getMxx();
 3719             double mxy = tx.getMxy();
 3720             double mxz = tx.getMxz();
 3721             double mxt = tx.getMxt();
 3722             double myx = tx.getMyx();
 3723             double myy = tx.getMyy();
 3724             double myz = tx.getMyz();
 3725             double myt = tx.getMyt();
 3726             double mzx = tx.getMzx();
 3727             double mzy = tx.getMzy();
 3728             double mzz = tx.getMzz();
 3729             double mzt = tx.getMzt();
 3730             BaseTransform boundsTx = tx.deriveWithConcatenation(localToParentTx);
 3731             bounds = getLocalBounds(bounds, boundsTx);
 3732             if (boundsTx == tx) {
 3733                 tx.restoreTransform(mxx, mxy, mxz, mxt,
 3734                                     myx, myy, myz, myt,
 3735                                     mzx, mzy, mzz, mzt);
 3736             }
 3737             return bounds;
 3738         }
 3739     }
 3740 
 3741     /**
 3742      * Loads the given bounds object with the local bounds relative to,
 3743      * and based on, the given transform. That is, these are the geometric
 3744      * bounds + clip and effect.
 3745      *
 3746      * We *never* pass null in as a bounds. This method will
 3747      * NOT take a null bounds object. The returned value may be
 3748      * the same bounds object passed in, or it may be a new object.
 3749      * The reason for this object promotion is in the case of needing
 3750      * to promote from a RectBounds to a BoxBounds (3D).
 3751      */
 3752     BaseBounds getLocalBounds(BaseBounds bounds, BaseTransform tx) {
 3753         if (getEffect() == null &amp;&amp; getClip() == null) {
 3754             return getGeomBounds(bounds, tx);
 3755         }
 3756 
 3757         if (tx.isTranslateOrIdentity()) {
 3758             // we can take a fast path since we know tx is either a simple
 3759             // translation or is identity
 3760             updateLocalBounds();
 3761             bounds = bounds.deriveWithNewBounds(localBounds);
 3762             if (!tx.isIdentity()) {
 3763                 double translateX = tx.getMxt();
 3764                 double translateY = tx.getMyt();
 3765                 double translateZ = tx.getMzt();
 3766                 bounds = bounds.deriveWithNewBounds((float) (bounds.getMinX() + translateX),
 3767                         (float) (bounds.getMinY() + translateY),
 3768                         (float) (bounds.getMinZ() + translateZ),
 3769                         (float) (bounds.getMaxX() + translateX),
 3770                         (float) (bounds.getMaxY() + translateY),
 3771                         (float) (bounds.getMaxZ() + translateZ));
 3772             }
 3773             return bounds;
 3774         } else if (tx.is2D()
 3775                 &amp;&amp; (tx.getType()
 3776                 &amp; ~(BaseTransform.TYPE_UNIFORM_SCALE | BaseTransform.TYPE_TRANSLATION
 3777                 | BaseTransform.TYPE_FLIP | BaseTransform.TYPE_QUADRANT_ROTATION)) != 0) {
 3778             // this is a non-uniform scale / non-quadrant rotate / skew transform
 3779             return computeLocalBounds(bounds, tx);
 3780         } else {
 3781             // 3D transformations and
 3782             // selected 2D transformations (uniform transform, flip, quadrant rotation).
 3783             // These 2D transformation will yield tight bounds when applied on the pre-computed
 3784             // geomBounds
 3785             // Note: Transforming the local bounds into a 3D space will yield a bounds
 3786             // that isn&#39;t as tight as transforming its geometry and compute it bounds.
 3787             updateLocalBounds();
 3788             return tx.transform(localBounds, bounds);
 3789         }
 3790     }
 3791 
 3792     /**
 3793      * Loads the given bounds object with the geometric bounds relative to,
 3794      * and based on, the given transform.
 3795      *
 3796      * We *never* pass null in as a bounds. This method will
 3797      * NOT take a null bounds object. The returned value may be
 3798      * the same bounds object passed in, or it may be a new object.
 3799      * The reason for this object promotion is in the case of needing
 3800      * to promote from a RectBounds to a BoxBounds (3D).
 3801      */
 3802     BaseBounds getGeomBounds(BaseBounds bounds, BaseTransform tx) {
 3803         if (tx.isTranslateOrIdentity()) {
 3804             // we can take a fast path since we know tx is either a simple
 3805             // translation or is identity
 3806             updateGeomBounds();
 3807             bounds = bounds.deriveWithNewBounds(geomBounds);
 3808             if (!tx.isIdentity()) {
 3809                 double translateX = tx.getMxt();
 3810                 double translateY = tx.getMyt();
 3811                 double translateZ = tx.getMzt();
 3812                 bounds = bounds.deriveWithNewBounds((float) (bounds.getMinX() + translateX),
 3813                         (float) (bounds.getMinY() + translateY),
 3814                         (float) (bounds.getMinZ() + translateZ),
 3815                         (float) (bounds.getMaxX() + translateX),
 3816                         (float) (bounds.getMaxY() + translateY),
 3817                         (float) (bounds.getMaxZ() + translateZ));
 3818             }
 3819             return bounds;
 3820         } else if (tx.is2D()
 3821                 &amp;&amp; (tx.getType()
 3822                 &amp; ~(BaseTransform.TYPE_UNIFORM_SCALE | BaseTransform.TYPE_TRANSLATION
 3823                 | BaseTransform.TYPE_FLIP | BaseTransform.TYPE_QUADRANT_ROTATION)) != 0) {
 3824             // this is a non-uniform scale / non-quadrant rotate / skew transform
 3825             return NodeHelper.computeGeomBounds(this, bounds, tx);
 3826         } else {
 3827             // 3D transformations and
 3828             // selected 2D transformations (unifrom transform, flip, quadrant rotation).
 3829             // These 2D transformation will yield tight bounds when applied on the pre-computed
 3830             // geomBounds
 3831             // Note: Transforming the local geomBounds into a 3D space will yield a bounds
 3832             // that isn&#39;t as tight as transforming its geometry and compute it bounds.
 3833             updateGeomBounds();
 3834             return tx.transform(geomBounds, bounds);
 3835         }
 3836     }
 3837 
 3838     /**
 3839      * If necessary, recomputes the cached geom bounds. If the bounds are not
 3840      * invalid, then this method is a no-op.
 3841      */
 3842     void updateGeomBounds() {
 3843         if (geomBoundsInvalid) {
 3844             geomBounds = NodeHelper.computeGeomBounds(this, geomBounds, BaseTransform.IDENTITY_TRANSFORM);
 3845             geomBoundsInvalid = false;
 3846         }
 3847     }
 3848 
 3849     /**
 3850      * Computes the local bounds of this Node.
 3851      */
 3852     private BaseBounds computeLocalBounds(BaseBounds bounds, BaseTransform tx) {
 3853         // We either get the bounds of the effect (if it isn&#39;t null)
 3854         // or we get the geom bounds (if effect is null). We will then
 3855         // intersect this with the clip.
 3856         if (getEffect() != null) {
 3857             BaseBounds b = EffectHelper.getBounds(getEffect(), bounds, tx, this, boundsAccessor);
 3858             bounds = bounds.deriveWithNewBounds(b);
 3859         } else {
 3860             bounds = getGeomBounds(bounds, tx);
 3861         }
 3862         // intersect with the clip. Take care with &quot;bounds&quot; as it may
 3863         // actually be TEMP_BOUNDS, so we save off state
 3864         if (getClip() != null
 3865                 // FIXME: All 3D picking is currently ignored by rendering.
 3866                 // Until this is fixed or defined differently (RT-28510),
 3867                 // we follow this behavior.
 3868                 &amp;&amp; !(this instanceof Shape3D) &amp;&amp; !(getClip() instanceof Shape3D)) {
 3869             double x1 = bounds.getMinX();
 3870             double y1 = bounds.getMinY();
 3871             double x2 = bounds.getMaxX();
 3872             double y2 = bounds.getMaxY();
 3873             double z1 = bounds.getMinZ();
 3874             double z2 = bounds.getMaxZ();
 3875             bounds = getClip().getTransformedBounds(bounds, tx);
 3876             bounds.intersectWith((float)x1, (float)y1, (float)z1,
 3877                     (float)x2, (float)y2, (float)z2);
 3878         }
 3879         return bounds;
 3880     }
 3881 
 3882 
 3883     /**
 3884      * If necessary, recomputes the cached local bounds. If the bounds are not
 3885      * invalid, then this method is a no-op.
 3886      */
 3887     private void updateLocalBounds() {
 3888         if (localBoundsInvalid) {
 3889             if (getClip() != null || getEffect() != null) {
 3890                 localBounds = computeLocalBounds(
 3891                         localBounds == null ? new RectBounds() : localBounds,
 3892                         BaseTransform.IDENTITY_TRANSFORM);
 3893             } else {
 3894                 localBounds = null;
 3895             }
 3896             localBoundsInvalid = false;
 3897         }
 3898     }
 3899 
 3900     /**
 3901      * If necessary, recomputes the cached transformed bounds.
 3902      * If the cached transformed bounds are not invalid, then
 3903      * this method is a no-op.
 3904      */
 3905     void updateTxBounds() {
 3906         if (txBoundsInvalid) {
 3907             updateLocalToParentTransform();
 3908             txBounds = getLocalBounds(txBounds, localToParentTx);
 3909             txBoundsInvalid = false;
 3910         }
 3911     }
 3912 
 3913     /*
 3914      *                   Bounds Invalidation And Notification
 3915      *
 3916      *  The goal of this section is to efficiently propagate bounds
 3917      *  invalidation through the scenegraph while also being semantically
 3918      *  correct.
 3919      *
 3920      *  The code path for invalidation of layout bounds is somewhat confusing
 3921      *  primarily due to performance enhancements and the desire to reduce the
 3922      *  number of requestLayout() calls that are performed when layout bounds
 3923      *  change. Before diving into layout bounds, I will first describe how
 3924      *  normal bounds invalidation occurs.
 3925      *
 3926      *  When a node&#39;s geometry changes (for example, if the width of a
 3927      *  Rectangle is changed) then the Node must call NodeHelper.geomChanged().
 3928      *  Invoking this function will eventually clear all cached bounds and
 3929      *  notify to each parent up the tree that their bounds may have changed.
 3930      *
 3931      *  After invalidating geomBounds (and after kicking off layout bounds
 3932      *  notification), NodeHelper.geomChanged calls localBoundsChanged(). It should
 3933      *  be noted that NodeHelper.geomChanged should only be called when the geometry
 3934      *  of the node has changed such that it may result in the geom bounds
 3935      *  actually changing.
 3936      *
 3937      *  localBoundsChanged() simply invalidates boundsInLocal and then calls
 3938      *  transformedBoundsChanged().
 3939      *
 3940      *  transformedBoundsChanged() is responsible for invalidating
 3941      *  boundsInParent and txBounds. If the Node is not visible, then there is
 3942      *  no need to notify the parent of the bounds change because the parent&#39;s
 3943      *  bounds do not include invisible nodes. If the node is visible, then
 3944      *  it must tell the parent that this child node&#39;s bounds have changed.
 3945      *  It is up to the parent to eventually invoke its own NodeHelper.geomChanged
 3946      *  function. If instead of a parent this node has a clipParent, then the
 3947      *  clipParent&#39;s localBoundsChanged() is called instead.
 3948      *
 3949      *  There are a few other ways in which we enter the invalidate steps
 3950      *  beyond just the geometry changes. If the visibility of a Node changes,
 3951      *  its own bounds are not affected but its parent&#39;s bounds are. So a
 3952      *  special call to parent.childVisibilityChanged is made so the parent
 3953      *  can react accordingly.
 3954      *
 3955      *  If a transform is changed (layoutX, layoutY, rotate, transforms, etc)
 3956      *  then the transform must be invalidated. When a transform is invalidated,
 3957      *  it must also invalidate the txBounds by invoking
 3958      *  transformedBoundsChanged, which will in turn notify the parent as
 3959      *  before.
 3960      *
 3961      *  If an effect is changed or replaced then the local bounds must be
 3962      *  invalidated, as well as the transformedBounds and the parent notified
 3963      *  of the change in bounds.
 3964      *
 3965      *  layoutBound is somewhat unique in that it can be redefined in
 3966      *  subclasses. By default, the layoutBounds is the geomBounds, and so
 3967      *  whenever the geomBounds() function is called the layoutBounds
 3968      *  must be invalidated. However in subclasses, especially Resizables,
 3969      *  the layout bounds may not be defined to be the same as the geometric
 3970      *  bounds. This is both useful and provides a very nice performance
 3971      *  optimization for regions and controls. In this case, subclasses
 3972      *  need some way to interpose themselves such that a call to
 3973      *  NodeHelper.geomChanged() *does not* invalidate the layout bounds.
 3974      *
 3975      *  This interposition happens by providing the
 3976      *  NodeHelper.notifyLayoutBoundsChanged function. The default implementation
 3977      *  simply invalidates boundsInLocal. Subclasses (such as Region and
 3978      *  Control) can override this function so that it does not invalidate
 3979      *  the layout bounds.
 3980      *
 3981      *  An on invalidate trigger on layoutBounds handles kicking off the rest
 3982      *  of the invalidate process for layoutBounds. Because the layout bounds
 3983      *  define the pivot point, if scaleX, scaleY, or rotate contain
 3984      *  non-identity values then whenever the layoutBounds change the
 3985      *  transformed bounds also change. Finally, if this node&#39;s parent is
 3986      *  a Region and if the Node is being managed by the Region, then
 3987      *  we must call requestLayout on the Region whenever the layout bounds
 3988      *  have changed.
 3989      */
 3990 
 3991     /*
 3992      * Invoked by subclasses whenever their geometric bounds have changed.
 3993      * Because the default layout bounds is based on the node geometry, this
 3994      * function will invoke NodeHelper.notifyLayoutBoundsChanged. The default
 3995      * implementation of NodeHelper.notifyLayoutBoundsChanged() will simply invalidate
 3996      * layoutBounds. Resizable subclasses will want to override this function
 3997      * in most cases to be a no-op.
 3998      *
 3999      * This function will also invalidate the cached geom bounds, and then
 4000      * invoke localBoundsChanged() which will eventually end up invoking a
 4001      * chain of functions up the tree to ensure that each parent of this
 4002      * Node is notified that its bounds may have also changed.
 4003      *
 4004      * This function should be treated as though it were final. It is not
 4005      * intended to be overridden by subclasses.
 4006      *
 4007      * Note: This method MUST only be called via its accessor method.
 4008      */
 4009     private void doGeomChanged() {
 4010         if (geomBoundsInvalid) {
 4011             // GeomBoundsInvalid is false when node geometry changed and
 4012             // the untransformed node bounds haven&#39;t been recalculated yet.
 4013             // Most of the time, the recalculation of layout and transformed
 4014             // node bounds don&#39;t require validation of untransformed bounds
 4015             // and so we can not skip the following notifications.
 4016             NodeHelper.notifyLayoutBoundsChanged(this);
 4017             transformedBoundsChanged();
 4018             return;
 4019         }
 4020         geomBounds.makeEmpty();
 4021         geomBoundsInvalid = true;
 4022         NodeHelper.markDirty(this, DirtyBits.NODE_BOUNDS);
 4023         NodeHelper.notifyLayoutBoundsChanged(this);
 4024         localBoundsChanged();
 4025     }
 4026 
 4027     private boolean geomBoundsInvalid = true;
 4028     private boolean localBoundsInvalid = true;
 4029     private boolean txBoundsInvalid = true;
 4030 
 4031     /**
 4032      * Responds to changes in the local bounds by invalidating boundsInLocal
 4033      * and notifying this node that its transformed bounds have changed.
 4034      */
 4035     void localBoundsChanged() {
 4036         localBoundsInvalid = true;
 4037         invalidateBoundsInLocal();
 4038         transformedBoundsChanged();
 4039     }
 4040 
 4041     /**
 4042      * Responds to changes in the transformed bounds by invalidating txBounds
 4043      * and boundsInParent. If this Node is not visible, then we have no need
 4044      * to walk further up the tree but can instead simply invalidate state.
 4045      * Otherwise, this function will notify parents (either the parent or the
 4046      * clipParent) that this child Node&#39;s bounds have changed.
 4047      */
 4048     void transformedBoundsChanged() {
 4049         if (!txBoundsInvalid) {
 4050             txBounds.makeEmpty();
 4051             txBoundsInvalid = true;
 4052             invalidateBoundsInParent();
 4053             NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORMED_BOUNDS);
 4054         }
 4055         if (isVisible()) {
 4056             notifyParentOfBoundsChange();
 4057         }
 4058     }
 4059 
 4060     /*
 4061      * Invoked by geomChanged(). Since layoutBounds is by default based
 4062      * on the geometric bounds, the default implementation of this function will
 4063      * invalidate the layoutBounds. Resizable Node subclasses generally base
 4064      * layoutBounds on the width/height instead of the geometric bounds, and so
 4065      * will generally want to override this function to be a no-op.
 4066      *
 4067      * Note: This method MUST only be called via its accessor method.
 4068      */
 4069     private void doNotifyLayoutBoundsChanged() {
 4070         layoutBoundsChanged();
 4071         // notify the parent
 4072         // Group instanceof check a little hoaky, but it allows us to disable
 4073         // unnecessary layout for the case of a non-resizable within a group
 4074         Parent p = getParent();
 4075 
 4076         // Need to propagate layout if parent isn&#39;t part of performing layout
 4077         if (isManaged() &amp;&amp; (p != null) &amp;&amp; !(p instanceof Group &amp;&amp; !isResizable())
 4078                 &amp;&amp; !p.isPerformingLayout()) {
 4079             // Force its parent to fix the layout since it is a managed child.
 4080             p.requestLayout(true);
 4081         }
 4082     }
 4083 
 4084     /**
 4085      * Notifies both the real parent and the clip parent (if they exist) that
 4086      * the bounds of the child has changed. Note that since FX doesn&#39;t throw
 4087      * NPE&#39;s, things actually are faster if we don&#39;t check twice for Null
 4088      * (we check once, the compiler checks again)
 4089      */
 4090     void notifyParentOfBoundsChange() {
 4091         // let the parent know which node has changed and the parent will
 4092         // deal with marking itself invalid correctly
 4093         Parent p = getParent();
 4094         if (p != null) {
 4095             p.childBoundsChanged(this);
 4096         }
 4097         // since the clip is used to compute the local bounds (and not the
 4098         // geom bounds), we just need to notify that local bounds on the
 4099         // clip parent have changed
 4100         if (clipParent != null) {
 4101             clipParent.localBoundsChanged();
 4102         }
 4103     }
 4104 
 4105     /***************************************************************************
 4106      *                                                                         *
 4107      * Geometry and coordinate system related APIs. For example, methods       *
 4108      * related to containment, intersection, coordinate space conversion, etc. *
 4109      *                                                                         *
 4110      **************************************************************************/
 4111 
 4112     /**
 4113      * Returns {@code true} if the given point (specified in the local
 4114      * coordinate space of this {@code Node}) is contained within the shape of
 4115      * this {@code Node}. Note that this method does not take visibility into
 4116      * account; the test is based on the geometry of this {@code Node} only.
 4117      * @param localX the x coordinate of the point in Node&#39;s space
 4118      * @param localY the y coordinate of the point in Node&#39;s space
 4119      * @return the result of contains for this {@code Node}
 4120      */
 4121     public boolean contains(double localX, double localY) {
 4122         if (containsBounds(localX, localY)) {
 4123             return (isPickOnBounds() || NodeHelper.computeContains(this, localX, localY));
 4124         }
 4125         return false;
 4126     }
 4127 
 4128     /*
 4129      * This method only does the contains check based on the bounds, clip and
 4130      * effect of this node, excluding its shape (or geometry).
 4131      *
 4132      * Returns true if the given point (specified in the local
 4133      * coordinate space of this {@code Node}) is contained within the bounds,
 4134      * clip and effect of this node.
 4135      */
 4136     private boolean containsBounds(double localX, double localY) {
 4137         final TempState tempState = TempState.getInstance();
 4138         BaseBounds tempBounds = tempState.bounds;
 4139 
 4140         // first, we do a quick test to see if the point is contained in
 4141         // our local bounds. If so, then we will go the next step and check
 4142         // the clip, effect, and geometry for containment.
 4143         tempBounds = getLocalBounds(tempBounds,
 4144                                     BaseTransform.IDENTITY_TRANSFORM);
 4145         if (tempBounds.contains((float)localX, (float)localY)) {
 4146             // if the clip is defined, then check it for containment, being
 4147             // sure to convert from this node&#39;s local coordinate system
 4148             // to the local coordinate system of the clip node
 4149             if (getClip() != null) {
 4150                 tempState.point.x = (float)localX;
 4151                 tempState.point.y = (float)localY;
 4152                 try {
 4153                     getClip().parentToLocal(tempState.point);
 4154                 } catch (NoninvertibleTransformException e) {
 4155                     return false;
 4156                 }
 4157                 if (!getClip().contains(tempState.point.x, tempState.point.y)) {
 4158                     return false;
 4159                 }
 4160             }
 4161             return true;
 4162         }
 4163         return false;
 4164     }
 4165 
 4166     /**
 4167      * Returns {@code true} if the given point (specified in the local
 4168      * coordinate space of this {@code Node}) is contained within the shape of
 4169      * this {@code Node}. Note that this method does not take visibility into
 4170      * account; the test is based on the geometry of this {@code Node} only.
 4171      * @param localPoint the 2D point in Node&#39;s space
 4172      * @return the result of contains for this {@code Node}
 4173      */
 4174     public boolean contains(Point2D localPoint) {
 4175         return contains(localPoint.getX(), localPoint.getY());
 4176     }
 4177 
 4178     /**
 4179      * Returns {@code true} if the given rectangle (specified in the local
 4180      * coordinate space of this {@code Node}) intersects the shape of this
 4181      * {@code Node}. Note that this method does not take visibility into
 4182      * account; the test is based on the geometry of this {@code Node} only.
 4183      * The default behavior of this function is simply to check if the
 4184      * given coordinates intersect with the local bounds.
 4185      * @param localX the x coordinate of a rectangle in Node&#39;s space
 4186      * @param localY the y coordinate of a rectangle in Node&#39;s space
 4187      * @param localWidth the width of a rectangle in Node&#39;s space
 4188      * @param localHeight the height of a rectangle in Node&#39;s space
 4189      * @return the result of intersects for this {@code Node}
 4190      */
 4191     public boolean intersects(double localX, double localY, double localWidth, double localHeight) {
 4192         BaseBounds tempBounds = TempState.getInstance().bounds;
 4193         tempBounds = getLocalBounds(tempBounds,
 4194                                     BaseTransform.IDENTITY_TRANSFORM);
 4195         return tempBounds.intersects((float)localX,
 4196                                      (float)localY,
 4197                                      (float)localWidth,
 4198                                      (float)localHeight);
 4199     }
 4200 
 4201     /**
 4202      * Returns {@code true} if the given bounds (specified in the local
 4203      * coordinate space of this {@code Node}) intersects the shape of this
 4204      * {@code Node}. Note that this method does not take visibility into
 4205      * account; the test is based on the geometry of this {@code Node} only.
 4206      * The default behavior of this function is simply to check if the
 4207      * given coordinates intersect with the local bounds.
 4208      * @param localBounds the bounds
 4209      * @return the result of intersects for this {@code Node}
 4210      */
 4211     public boolean intersects(Bounds localBounds) {
 4212         return intersects(localBounds.getMinX(), localBounds.getMinY(), localBounds.getWidth(), localBounds.getHeight());
 4213     }
 4214 
 4215     /**
 4216      * Transforms a point from the coordinate space of the {@link javafx.stage.Screen}
 4217      * into the local coordinate space of this {@code Node}.
 4218      * @param screenX x coordinate of a point on a Screen
 4219      * @param screenY y coordinate of a point on a Screen
 4220      * @return local Node&#39;s coordinates of the point or null if Node is not in a {@link Window}.
 4221      * Null is also returned if the transformation from local to Scene is not invertible.
 4222      * @since JavaFX 8.0
 4223      */
 4224     public Point2D screenToLocal(double screenX, double screenY) {
 4225         Scene scene = getScene();
 4226         if (scene == null) return null;
 4227         Window window = scene.getWindow();
 4228         if (window == null) return null;
 4229 
 4230         final com.sun.javafx.geom.Point2D tempPt =
 4231                 TempState.getInstance().point;
 4232 
 4233         tempPt.setLocation((float)(screenX - scene.getX() - window.getX()),
 4234                            (float)(screenY - scene.getY() - window.getY()));
 4235 
 4236         final SubScene subScene = getSubScene();
 4237         if (subScene != null) {
 4238             final Point2D ssCoord = SceneUtils.sceneToSubScenePlane(subScene,
 4239                     new Point2D(tempPt.x, tempPt.y));
 4240             if (ssCoord == null) {
 4241                 return null;
 4242             }
 4243             tempPt.setLocation((float) ssCoord.getX(), (float) ssCoord.getY());
 4244         }
 4245 
 4246         final Point3D ppIntersect =
 4247                 scene.getEffectiveCamera().pickProjectPlane(tempPt.x, tempPt.y);
 4248         tempPt.setLocation((float) ppIntersect.getX(), (float) ppIntersect.getY());
 4249 
 4250         try {
 4251             sceneToLocal(tempPt);
 4252         } catch (NoninvertibleTransformException e) {
 4253             return null;
 4254         }
 4255         return new Point2D(tempPt.x, tempPt.y);
 4256     }
 4257 
 4258     /**
 4259      * Transforms a point from the coordinate space of the {@link javafx.stage.Screen}
 4260      * into the local coordinate space of this {@code Node}.
 4261      * @param screenPoint a point on a Screen
 4262      * @return local Node&#39;s coordinates of the point or null if Node is not in a {@link Window}.
 4263      * Null is also returned if the transformation from local to Scene is not invertible.
 4264      * @since JavaFX 8.0
 4265      */
 4266     public Point2D screenToLocal(Point2D screenPoint) {
 4267         return screenToLocal(screenPoint.getX(), screenPoint.getY());
 4268     }
 4269 
 4270     /**
 4271      * Transforms a rectangle from the coordinate space of the
 4272      * {@link javafx.stage.Screen} into the local coordinate space of this
 4273      * {@code Node}. Returns reasonable result only in 2D space.
 4274      * @param screenBounds bounds on a Screen
 4275      * @return bounds in the local Node&#39;space or null if Node is not in a {@link Window}.
 4276      * Null is also returned if the transformation from local to Scene is not invertible.
 4277      * @since JavaFX 8.0
 4278      */
 4279     public Bounds screenToLocal(Bounds screenBounds) {
 4280         final Point2D p1 = screenToLocal(screenBounds.getMinX(), screenBounds.getMinY());
 4281         final Point2D p2 = screenToLocal(screenBounds.getMinX(), screenBounds.getMaxY());
 4282         final Point2D p3 = screenToLocal(screenBounds.getMaxX(), screenBounds.getMinY());
 4283         final Point2D p4 = screenToLocal(screenBounds.getMaxX(), screenBounds.getMaxY());
 4284 
 4285         return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
 4286     }
 4287 
 4288 
 4289     /**
 4290      * Transforms a point from the coordinate space of the scene
 4291      * into the local coordinate space of this {@code Node}.
 4292      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4293      * arguments are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4294      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4295      * {@link #sceneToLocal(double, double)}.
 4296      *
 4297      * @param x the x coordinate
 4298      * @param y the y coordinate
 4299      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4300      * @return local coordinates of the point
 4301      * @since JavaFX 8u40
 4302      */
 4303     public Point2D sceneToLocal(double x, double y, boolean rootScene) {
 4304         if (!rootScene) {
 4305             return sceneToLocal(x, y);
 4306         }
 4307         final com.sun.javafx.geom.Point2D tempPt =
 4308                 TempState.getInstance().point;
 4309 
 4310         tempPt.setLocation((float)(x), (float)y);
 4311 
 4312         final SubScene subScene = getSubScene();
 4313         if (subScene != null) {
 4314             final Point2D ssCoord = SceneUtils.sceneToSubScenePlane(subScene,
 4315                     new Point2D(tempPt.x, tempPt.y));
 4316             if (ssCoord == null) {
 4317                 return null;
 4318             }
 4319             tempPt.setLocation((float) ssCoord.getX(), (float) ssCoord.getY());
 4320         }
 4321 
 4322         try {
 4323             sceneToLocal(tempPt);
 4324             return new Point2D(tempPt.x, tempPt.y);
 4325         } catch (NoninvertibleTransformException e) {
 4326             return null;
 4327         }
 4328     }
 4329 
 4330     /**
 4331      * Transforms a point from the coordinate space of the scene
 4332      * into the local coordinate space of this {@code Node}.
 4333      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4334      * arguments are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4335      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4336      * {@link #sceneToLocal(javafx.geometry.Point2D)}.
 4337      *
 4338      * @param point the point
 4339      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4340      * @return local coordinates of the point
 4341      * @since JavaFX 8u40
 4342      */
 4343     public Point2D sceneToLocal(Point2D point, boolean rootScene) {
 4344         return sceneToLocal(point.getX(), point.getY(), rootScene);
 4345     }
 4346 
 4347     /**
 4348      * Transforms a bounds from the coordinate space of the scene
 4349      * into the local coordinate space of this {@code Node}.
 4350      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4351      * arguments are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4352      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4353      * {@link #sceneToLocal(javafx.geometry.Bounds)}.
 4354      * &lt;p&gt;
 4355      *     Since 3D bounds cannot be converted with {@code rootScene} set to {@code true}, trying to convert 3D bounds will yield {@code null}.
 4356      * &lt;/p&gt;
 4357      * @param bounds the bounds
 4358      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4359      * @return local coordinates of the bounds
 4360      * @since JavaFX 8u40
 4361      */
 4362     public Bounds sceneToLocal(Bounds bounds, boolean rootScene) {
 4363         if (!rootScene) {
 4364             return sceneToLocal(bounds);
 4365         }
 4366         if (bounds.getMinZ() != 0 || bounds.getMaxZ() != 0) {
 4367             return null;
 4368         }
 4369         final Point2D p1 = sceneToLocal(bounds.getMinX(), bounds.getMinY(), true);
 4370         final Point2D p2 = sceneToLocal(bounds.getMinX(), bounds.getMaxY(), true);
 4371         final Point2D p3 = sceneToLocal(bounds.getMaxX(), bounds.getMinY(), true);
 4372         final Point2D p4 = sceneToLocal(bounds.getMaxX(), bounds.getMaxY(), true);
 4373 
 4374         return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
 4375     }
 4376 
 4377     /**
 4378      * Transforms a point from the coordinate space of the scene
 4379      * into the local coordinate space of this {@code Node}.
 4380      *
 4381      * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
 4382      * not that of {@link javafx.scene.Scene}.
 4383      *
 4384      * @param sceneX x coordinate of a point on a Scene
 4385      * @param sceneY y coordinate of a point on a Scene
 4386      * @return local Node&#39;s coordinates of the point or null if Node is not in a {@link Window}.
 4387      * Null is also returned if the transformation from local to Scene is not invertible.
 4388      */
 4389     public Point2D sceneToLocal(double sceneX, double sceneY) {
 4390         final com.sun.javafx.geom.Point2D tempPt =
 4391                 TempState.getInstance().point;
 4392         tempPt.setLocation((float)sceneX, (float)sceneY);
 4393         try {
 4394             sceneToLocal(tempPt);
 4395         } catch (NoninvertibleTransformException e) {
 4396             return null;
 4397         }
 4398         return new Point2D(tempPt.x, tempPt.y);
 4399     }
 4400 
 4401     /**
 4402      * Transforms a point from the coordinate space of the scene
 4403      * into the local coordinate space of this {@code Node}.
 4404      *
 4405      * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
 4406      * not that of {@link javafx.scene.Scene}.
 4407      *
 4408      * @param scenePoint a point on a Scene
 4409      * @return local Node&#39;s coordinates of the point or null if Node is not in a {@link Window}.
 4410      * Null is also returned if the transformation from local to Scene is not invertible.
 4411      */
 4412     public Point2D sceneToLocal(Point2D scenePoint) {
 4413         return sceneToLocal(scenePoint.getX(), scenePoint.getY());
 4414     }
 4415 
 4416     /**
 4417      * Transforms a point from the coordinate space of the scene
 4418      * into the local coordinate space of this {@code Node}.
 4419      *
 4420      * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
 4421      * not that of {@link javafx.scene.Scene}.
 4422      *
 4423      * @param scenePoint a point on a Scene
 4424      * @return local Node&#39;s coordinates of the point or null if Node is not in a {@link Window}.
 4425      * Null is also returned if the transformation from local to Scene is not invertible.
 4426      * @since JavaFX 8.0
 4427      */
 4428     public Point3D sceneToLocal(Point3D scenePoint) {
 4429         return sceneToLocal(scenePoint.getX(), scenePoint.getY(), scenePoint.getZ());
 4430     }
 4431 
 4432     /**
 4433      * Transforms a point from the coordinate space of the scene
 4434      * into the local coordinate space of this {@code Node}.
 4435      *
 4436      * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
 4437      * not that of {@link javafx.scene.Scene}.
 4438      *
 4439      * @param sceneX x coordinate of a point on a Scene
 4440      * @param sceneY y coordinate of a point on a Scene
 4441      * @param sceneZ z coordinate of a point on a Scene
 4442      * @return local Node&#39;s coordinates of the point or null if Node is not in a {@link Window}.
 4443      * Null is also returned if the transformation from local to Scene is not invertible.
 4444      * @since JavaFX 8.0
 4445      */
 4446     public Point3D sceneToLocal(double sceneX, double sceneY, double sceneZ) {
 4447         try {
 4448             return sceneToLocal0(sceneX, sceneY, sceneZ);
 4449         } catch (NoninvertibleTransformException ex) {
 4450             return null;
 4451         }
 4452     }
 4453 
 4454     /**
 4455      * Internal method to transform a point from scene to local coordinates.
 4456      */
 4457     private Point3D sceneToLocal0(double x, double y, double z) throws NoninvertibleTransformException {
 4458         final com.sun.javafx.geom.Vec3d tempV3D =
 4459                 TempState.getInstance().vec3d;
 4460         tempV3D.set(x, y, z);
 4461         sceneToLocal(tempV3D);
 4462         return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
 4463     }
 4464 
 4465     /**
 4466      * Transforms a rectangle from the coordinate space of the
 4467      * scene into the local coordinate space of this
 4468      * {@code Node}.
 4469      *
 4470      * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
 4471      * not that of {@link javafx.scene.Scene}.
 4472      *
 4473      * @param sceneBounds bounds on a Scene
 4474      * @return bounds in the local Node&#39;space or null if Node is not in a {@link Window}.
 4475      * Null is also returned if the transformation from local to Scene is not invertible.
 4476      */
 4477     public Bounds sceneToLocal(Bounds sceneBounds) {
 4478         // Do a quick update of localToParentTransform so that we can determine
 4479         // if this tx is 2D transform
 4480         updateLocalToParentTransform();
 4481         if (localToParentTx.is2D() &amp;&amp; (sceneBounds.getMinZ() == 0) &amp;&amp; (sceneBounds.getMaxZ() == 0)) {
 4482             Point2D p1 = sceneToLocal(sceneBounds.getMinX(), sceneBounds.getMinY());
 4483             Point2D p2 = sceneToLocal(sceneBounds.getMaxX(), sceneBounds.getMinY());
 4484             Point2D p3 = sceneToLocal(sceneBounds.getMaxX(), sceneBounds.getMaxY());
 4485             Point2D p4 = sceneToLocal(sceneBounds.getMinX(), sceneBounds.getMaxY());
 4486 
 4487             return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
 4488         }
 4489         try {
 4490             Point3D p1 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMinY(), sceneBounds.getMinZ());
 4491             Point3D p2 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMinY(), sceneBounds.getMaxZ());
 4492             Point3D p3 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMaxY(), sceneBounds.getMinZ());
 4493             Point3D p4 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMaxY(), sceneBounds.getMaxZ());
 4494             Point3D p5 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMaxY(), sceneBounds.getMinZ());
 4495             Point3D p6 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMaxY(), sceneBounds.getMaxZ());
 4496             Point3D p7 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMinY(), sceneBounds.getMinZ());
 4497             Point3D p8 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMinY(), sceneBounds.getMaxZ());
 4498             return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
 4499         } catch (NoninvertibleTransformException e) {
 4500             return null;
 4501         }
 4502     }
 4503 
 4504     /**
 4505      * Transforms a point from the local coordinate space of this {@code Node}
 4506      * into the coordinate space of its {@link javafx.stage.Screen}.
 4507      * @param localX x coordinate of a point in Node&#39;s space
 4508      * @param localY y coordinate of a point in Node&#39;s space
 4509      * @return screen coordinates of the point or null if Node is not in a {@link Window}
 4510      * @since JavaFX 8.0
 4511      */
 4512     public Point2D localToScreen(double localX, double localY) {
 4513         return localToScreen(localX, localY, 0.0);
 4514     }
 4515 
 4516     /**
 4517      * Transforms a point from the local coordinate space of this {@code Node}
 4518      * into the coordinate space of its {@link javafx.stage.Screen}.
 4519      * @param localPoint a point in Node&#39;s space
 4520      * @return screen coordinates of the point or null if Node is not in a {@link Window}
 4521      * @since JavaFX 8.0
 4522      */
 4523     public Point2D localToScreen(Point2D localPoint) {
 4524         return localToScreen(localPoint.getX(), localPoint.getY());
 4525     }
 4526 
 4527     /**
 4528      * Transforms a point from the local coordinate space of this {@code Node}
 4529      * into the coordinate space of its {@link javafx.stage.Screen}.
 4530      * @param localX x coordinate of a point in Node&#39;s space
 4531      * @param localY y coordinate of a point in Node&#39;s space
 4532      * @param localZ z coordinate of a point in Node&#39;s space
 4533      * @return screen coordinates of the point or null if Node is not in a {@link Window}
 4534      * @since JavaFX 8.0
 4535      */
 4536     public Point2D localToScreen(double localX, double localY, double localZ) {
 4537         Scene scene = getScene();
 4538         if (scene == null) return null;
 4539         Window window = scene.getWindow();
 4540         if (window == null) return null;
 4541 
 4542         Point3D pt = localToScene(localX, localY, localZ);
 4543         final SubScene subScene = getSubScene();
 4544         if (subScene != null) {
 4545             pt = SceneUtils.subSceneToScene(subScene, pt);
 4546         }
 4547         final Point2D projection = CameraHelper.project(
 4548                 SceneHelper.getEffectiveCamera(getScene()), pt);
 4549 
 4550         return new Point2D(projection.getX() + scene.getX() + window.getX(),
 4551                            projection.getY() + scene.getY() + window.getY());
 4552     }
 4553 
 4554     /**
 4555      * Transforms a point from the local coordinate space of this {@code Node}
 4556      * into the coordinate space of its {@link javafx.stage.Screen}.
 4557      * @param localPoint a point in Node&#39;s space
 4558      * @return screen coordinates of the point or null if Node is not in a {@link Window}
 4559      * @since JavaFX 8.0
 4560      */
 4561     public Point2D localToScreen(Point3D localPoint) {
 4562         return localToScreen(localPoint.getX(), localPoint.getY(), localPoint.getZ());
 4563     }
 4564 
 4565     /**
 4566      * Transforms a bounds from the local coordinate space of this
 4567      * {@code Node} into the coordinate space of its {@link javafx.stage.Screen}.
 4568      * @param localBounds bounds in Node&#39;s space
 4569      * @return the bounds in screen coordinates or null if Node is not in a {@link Window}
 4570      * @since JavaFX 8.0
 4571      */
 4572     public Bounds localToScreen(Bounds localBounds) {
 4573         final Point2D p1 = localToScreen(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ());
 4574         final Point2D p2 = localToScreen(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ());
 4575         final Point2D p3 = localToScreen(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ());
 4576         final Point2D p4 = localToScreen(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ());
 4577         final Point2D p5 = localToScreen(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ());
 4578         final Point2D p6 = localToScreen(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ());
 4579         final Point2D p7 = localToScreen(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ());
 4580         final Point2D p8 = localToScreen(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ());
 4581 
 4582         return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
 4583     }
 4584 
 4585     /**
 4586      * Transforms a point from the local coordinate space of this {@code Node}
 4587      * into the coordinate space of its scene.
 4588      * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
 4589      * not that of {@link javafx.scene.Scene}.
 4590      * @param localX x coordinate of a point in Node&#39;s space
 4591      * @param localY y coordinate of a point in Node&#39;s space
 4592      * @return scene coordinates of the point or null if Node is not in a {@link Window}
 4593      */
 4594     public Point2D localToScene(double localX, double localY) {
 4595         final com.sun.javafx.geom.Point2D tempPt =
 4596                 TempState.getInstance().point;
 4597         tempPt.setLocation((float)localX, (float)localY);
 4598         localToScene(tempPt);
 4599         return new Point2D(tempPt.x, tempPt.y);
 4600     }
 4601 
 4602     /**
 4603      * Transforms a point from the local coordinate space of this {@code Node}
 4604      * into the coordinate space of its scene.
 4605      * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
 4606      * not that of {@link javafx.scene.Scene}.
 4607      * @param localPoint a point in Node&#39;s space
 4608      * @return scene coordinates of the point or null if Node is not in a {@link Window}
 4609      */
 4610     public Point2D localToScene(Point2D localPoint) {
 4611         return localToScene(localPoint.getX(), localPoint.getY());
 4612     }
 4613 
 4614     /**
 4615      * Transforms a point from the local coordinate space of this {@code Node}
 4616      * into the coordinate space of its scene.
 4617      * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
 4618      * not that of {@link javafx.scene.Scene}.
 4619      * @param localPoint a 3D point in Node&#39;s space
 4620      * @return the transformed 3D point in Scene&#39;s space
 4621      * @see #localToScene(javafx.geometry.Point3D, boolean)
 4622      * @since JavaFX 8.0
 4623      */
 4624     public Point3D localToScene(Point3D localPoint) {
 4625         return localToScene(localPoint.getX(), localPoint.getY(), localPoint.getZ());
 4626     }
 4627 
 4628     /**
 4629      * Transforms a point from the local coordinate space of this {@code Node}
 4630      * into the coordinate space of its scene.
 4631      * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
 4632      * not that of {@link javafx.scene.Scene}.
 4633      * @param x the x coordinate of a point in Node&#39;s space
 4634      * @param y the y coordinate of a point in Node&#39;s space
 4635      * @param z the z coordinate of a point in Node&#39;s space
 4636      * @return the transformed 3D point in Scene&#39;s space
 4637      * @see #localToScene(double, double, double, boolean)
 4638      * @since JavaFX 8.0
 4639      */
 4640     public Point3D localToScene(double x, double y, double z) {
 4641         final com.sun.javafx.geom.Vec3d tempV3D =
 4642                 TempState.getInstance().vec3d;
 4643         tempV3D.set(x, y, z);
 4644         localToScene(tempV3D);
 4645         return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
 4646     }
 4647 
 4648     /**
 4649      * Transforms a point from the local coordinate space of this {@code Node}
 4650      * into the coordinate space of its scene.
 4651      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4652      * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4653      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4654      * {@link #localToScene(javafx.geometry.Point3D)}.
 4655      *
 4656      * @param localPoint the point in local coordinates
 4657      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4658      * @return transformed point
 4659      *
 4660      * @see #localToScene(javafx.geometry.Point3D)
 4661      * @since JavaFX 8u40
 4662      */
 4663     public Point3D localToScene(Point3D localPoint, boolean rootScene) {
 4664         Point3D pt = localToScene(localPoint);
 4665         if (rootScene) {
 4666             final SubScene subScene = getSubScene();
 4667             if (subScene != null) {
 4668                 pt = SceneUtils.subSceneToScene(subScene, pt);
 4669             }
 4670         }
 4671         return pt;
 4672     }
 4673 
 4674     /**
 4675      * Transforms a point from the local coordinate space of this {@code Node}
 4676      * into the coordinate space of its scene.
 4677      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4678      * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4679      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4680      * {@link #localToScene(double, double, double)}.
 4681      *
 4682      * @param x the x coordinate of the point in local coordinates
 4683      * @param y the y coordinate of the point in local coordinates
 4684      * @param z the z coordinate of the point in local coordinates
 4685      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4686      * @return transformed point
 4687      *
 4688      * @see #localToScene(double, double, double)
 4689      * @since JavaFX 8u40
 4690      */
 4691     public Point3D localToScene(double x, double y, double z, boolean rootScene) {
 4692         return localToScene(new Point3D(x, y, z), rootScene);
 4693     }
 4694 
 4695     /**
 4696      * Transforms a point from the local coordinate space of this {@code Node}
 4697      * into the coordinate space of its scene.
 4698      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4699      * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4700      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4701      * {@link #localToScene(javafx.geometry.Point2D)}.
 4702      *
 4703      * @param localPoint the point in local coordinates
 4704      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4705      * @return transformed point
 4706      *
 4707      * @see #localToScene(javafx.geometry.Point2D)
 4708      * @since JavaFX 8u40
 4709      */
 4710     public Point2D localToScene(Point2D localPoint, boolean rootScene) {
 4711         if (!rootScene) {
 4712             return localToScene(localPoint);
 4713         }
 4714         Point3D pt = localToScene(localPoint.getX(), localPoint.getY(), 0, rootScene);
 4715         return new Point2D(pt.getX(), pt.getY());
 4716     }
 4717 
 4718     /**
 4719      * Transforms a point from the local coordinate space of this {@code Node}
 4720      * into the coordinate space of its scene.
 4721      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4722      * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4723      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4724      * {@link #localToScene(double, double)}.
 4725      *
 4726      * @param x the x coordinate of the point in local coordinates
 4727      * @param y the y coordinate of the point in local coordinates
 4728      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4729      * @return transformed point
 4730      *
 4731      * @see #localToScene(double, double)
 4732      * @since JavaFX 8u40
 4733      */
 4734     public Point2D localToScene(double x, double y, boolean rootScene) {
 4735         return localToScene(new Point2D(x, y), rootScene);
 4736     }
 4737 
 4738     /**
 4739      * Transforms a bounds from the local coordinate space of this {@code Node}
 4740      * into the coordinate space of its scene.
 4741      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4742      * result bounds are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4743      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4744      * {@link #localToScene(javafx.geometry.Bounds)}.
 4745      *
 4746      * @param localBounds the bounds in local coordinates
 4747      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4748      * @return transformed bounds
 4749      *
 4750      * @see #localToScene(javafx.geometry.Bounds)
 4751      * @since JavaFX 8u40
 4752      */
 4753     public Bounds localToScene(Bounds localBounds, boolean rootScene) {
 4754         if (!rootScene) {
 4755             return localToScene(localBounds);
 4756         }
 4757         Point3D p1 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ(), true);
 4758         Point3D p2 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ(), true);
 4759         Point3D p3 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ(), true);
 4760         Point3D p4 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ(), true);
 4761         Point3D p5 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ(), true);
 4762         Point3D p6 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ(), true);
 4763         Point3D p7 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ(), true);
 4764         Point3D p8 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ(), true);
 4765         return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
 4766     }
 4767 
 4768     /**
 4769      * Transforms a bounds from the local coordinate space of this
 4770      * {@code Node} into the coordinate space of its scene.
 4771      * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
 4772      * not that of {@link javafx.scene.Scene}.
 4773      * @param localBounds bounds in Node&#39;s space
 4774      * @return the bounds in the scene coordinates or null if Node is not in a {@link Window}
 4775      * @see #localToScene(javafx.geometry.Bounds, boolean)
 4776      */
 4777     public Bounds localToScene(Bounds localBounds) {
 4778         // Do a quick update of localToParentTransform so that we can determine
 4779         // if this tx is 2D transform
 4780         updateLocalToParentTransform();
 4781         if (localToParentTx.is2D() &amp;&amp; (localBounds.getMinZ() == 0) &amp;&amp; (localBounds.getMaxZ() == 0)) {
 4782             Point2D p1 = localToScene(localBounds.getMinX(), localBounds.getMinY());
 4783             Point2D p2 = localToScene(localBounds.getMaxX(), localBounds.getMinY());
 4784             Point2D p3 = localToScene(localBounds.getMaxX(), localBounds.getMaxY());
 4785             Point2D p4 = localToScene(localBounds.getMinX(), localBounds.getMaxY());
 4786 
 4787             return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
 4788         }
 4789         Point3D p1 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ());
 4790         Point3D p2 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ());
 4791         Point3D p3 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ());
 4792         Point3D p4 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ());
 4793         Point3D p5 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ());
 4794         Point3D p6 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ());
 4795         Point3D p7 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ());
 4796         Point3D p8 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ());
 4797         return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
 4798 
 4799     }
 4800 
 4801     /**
 4802      * Transforms a point from the coordinate space of the parent into the
 4803      * local coordinate space of this {@code Node}.
 4804      * @param parentX the x coordinate in Parent&#39;s space
 4805      * @param parentY the y coordinate in Parent&#39;s space
 4806      * @return the transformed 2D point in Node&#39;s space
 4807      */
 4808     public Point2D parentToLocal(double parentX, double parentY) {
 4809         final com.sun.javafx.geom.Point2D tempPt =
 4810                 TempState.getInstance().point;
 4811         tempPt.setLocation((float)parentX, (float)parentY);
 4812         try {
 4813             parentToLocal(tempPt);
 4814         } catch (NoninvertibleTransformException e) {
 4815             return null;
 4816         }
 4817         return new Point2D(tempPt.x, tempPt.y);
 4818     }
 4819 
 4820     /**
 4821      * Transforms a point from the coordinate space of the parent into the
 4822      * local coordinate space of this {@code Node}.
 4823      * @param parentPoint the 2D point in Parent&#39;s space
 4824      * @return the transformed 2D point in Node&#39;s space
 4825      */
 4826     public Point2D parentToLocal(Point2D parentPoint) {
 4827         return parentToLocal(parentPoint.getX(), parentPoint.getY());
 4828     }
 4829 
 4830     /**
 4831      * Transforms a point from the coordinate space of the parent into the
 4832      * local coordinate space of this {@code Node}.
 4833      * @param parentPoint parentPoint the 3D point in Parent&#39;s space
 4834      * @return the transformed 3D point in Node&#39;s space
 4835      * @since JavaFX 8.0
 4836      */
 4837     public Point3D parentToLocal(Point3D parentPoint) {
 4838         return parentToLocal(parentPoint.getX(), parentPoint.getY(), parentPoint.getZ());
 4839     }
 4840 
 4841     /**
 4842      * Transforms a point from the coordinate space of the parent into the
 4843      * local coordinate space of this {@code Node}.
 4844      * @param parentX the x coordinate in Parent&#39;s space
 4845      * @param parentY the y coordinate in Parent&#39;s space
 4846      * @param parentZ the z coordinate in Parent&#39;s space
 4847      * @return the transformed 3D point in Node&#39;s space
 4848      * @since JavaFX 8.0
 4849      */
 4850     public Point3D parentToLocal(double parentX, double parentY, double parentZ) {
 4851         final com.sun.javafx.geom.Vec3d tempV3D =
 4852                 TempState.getInstance().vec3d;
 4853         tempV3D.set(parentX, parentY, parentZ);
 4854         try {
 4855             parentToLocal(tempV3D);
 4856         } catch (NoninvertibleTransformException e) {
 4857             return null;
 4858         }
 4859         return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
 4860     }
 4861 
 4862     /**
 4863      * Transforms a rectangle from the coordinate space of the parent into the
 4864      * local coordinate space of this {@code Node}.
 4865      * @param parentBounds the bounds in Parent&#39;s space
 4866      * @return the transformed bounds in Node&#39;s space
 4867      */
 4868     public Bounds parentToLocal(Bounds parentBounds) {
 4869         // Do a quick update of localToParentTransform so that we can determine
 4870         // if this tx is 2D transform
 4871         updateLocalToParentTransform();
 4872         if (localToParentTx.is2D() &amp;&amp; (parentBounds.getMinZ() == 0) &amp;&amp; (parentBounds.getMaxZ() == 0)) {
 4873             Point2D p1 = parentToLocal(parentBounds.getMinX(), parentBounds.getMinY());
 4874             Point2D p2 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMinY());
 4875             Point2D p3 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMaxY());
 4876             Point2D p4 = parentToLocal(parentBounds.getMinX(), parentBounds.getMaxY());
 4877 
 4878             return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
 4879         }
 4880         Point3D p1 = parentToLocal(parentBounds.getMinX(), parentBounds.getMinY(), parentBounds.getMinZ());
 4881         Point3D p2 = parentToLocal(parentBounds.getMinX(), parentBounds.getMinY(), parentBounds.getMaxZ());
 4882         Point3D p3 = parentToLocal(parentBounds.getMinX(), parentBounds.getMaxY(), parentBounds.getMinZ());
 4883         Point3D p4 = parentToLocal(parentBounds.getMinX(), parentBounds.getMaxY(), parentBounds.getMaxZ());
 4884         Point3D p5 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMaxY(), parentBounds.getMinZ());
 4885         Point3D p6 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMaxY(), parentBounds.getMaxZ());
 4886         Point3D p7 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMinY(), parentBounds.getMinZ());
 4887         Point3D p8 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMinY(), parentBounds.getMaxZ());
 4888         return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
 4889     }
 4890 
 4891     /**
 4892      * Transforms a point from the local coordinate space of this {@code Node}
 4893      * into the coordinate space of its parent.
 4894      * @param localX the x coordinate of the point in Node&#39;s space
 4895      * @param localY the y coordinate of the point in Node&#39;s space
 4896      * @return the transformed 2D point in Parent&#39;s space
 4897      */
 4898     public Point2D localToParent(double localX, double localY) {
 4899         final com.sun.javafx.geom.Point2D tempPt =
 4900                 TempState.getInstance().point;
 4901         tempPt.setLocation((float)localX, (float)localY);
 4902         localToParent(tempPt);
 4903         return new Point2D(tempPt.x, tempPt.y);
 4904     }
 4905 
 4906     /**
 4907      * Transforms a point from the local coordinate space of this {@code Node}
 4908      * into the coordinate space of its parent.
 4909      * @param localPoint the 2D point in Node&#39;s space
 4910      * @return the transformed 2D point in Parent&#39;s space
 4911      */
 4912     public Point2D localToParent(Point2D localPoint) {
 4913         return localToParent(localPoint.getX(), localPoint.getY());
 4914     }
 4915 
 4916     /**
 4917      * Transforms a point from the local coordinate space of this {@code Node}
 4918      * into the coordinate space of its parent.
 4919      * @param localPoint the 3D point in Node&#39;s space
 4920      * @return the transformed 3D point in Parent&#39;s space
 4921      * @since JavaFX 8.0
 4922      */
 4923     public Point3D localToParent(Point3D localPoint) {
 4924         return localToParent(localPoint.getX(), localPoint.getY(), localPoint.getZ());
 4925     }
 4926 
 4927     /**
 4928      * Transforms a point from the local coordinate space of this {@code Node}
 4929      * into the coordinate space of its parent.
 4930      * @param x the x coordinate of the point in Node&#39;s space
 4931      * @param y the y coordinate of the point in Node&#39;s space
 4932      * @param z the z coordinate of the point in Node&#39;s space
 4933      * @return the transformed 3D point in Parent&#39;s space
 4934      * @since JavaFX 8.0
 4935      */
 4936     public Point3D localToParent(double x, double y, double z) {
 4937         final com.sun.javafx.geom.Vec3d tempV3D =
 4938                 TempState.getInstance().vec3d;
 4939         tempV3D.set(x, y, z);
 4940         localToParent(tempV3D);
 4941         return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
 4942     }
 4943 
 4944     /**
 4945      * Transforms a bounds from the local coordinate space of this
 4946      * {@code Node} into the coordinate space of its parent.
 4947      * @param localBounds the bounds in Node&#39;s space
 4948      * @return the transformed bounds in Parent&#39;s space
 4949      */
 4950     public Bounds localToParent(Bounds localBounds) {
 4951         // Do a quick update of localToParentTransform so that we can determine
 4952         // if this tx is 2D transform
 4953         updateLocalToParentTransform();
 4954         if (localToParentTx.is2D() &amp;&amp; (localBounds.getMinZ() == 0) &amp;&amp; (localBounds.getMaxZ() == 0)) {
 4955             Point2D p1 = localToParent(localBounds.getMinX(), localBounds.getMinY());
 4956             Point2D p2 = localToParent(localBounds.getMaxX(), localBounds.getMinY());
 4957             Point2D p3 = localToParent(localBounds.getMaxX(), localBounds.getMaxY());
 4958             Point2D p4 = localToParent(localBounds.getMinX(), localBounds.getMaxY());
 4959 
 4960             return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
 4961         }
 4962         Point3D p1 = localToParent(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ());
 4963         Point3D p2 = localToParent(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ());
 4964         Point3D p3 = localToParent(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ());
 4965         Point3D p4 = localToParent(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ());
 4966         Point3D p5 = localToParent(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ());
 4967         Point3D p6 = localToParent(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ());
 4968         Point3D p7 = localToParent(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ());
 4969         Point3D p8 = localToParent(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ());
 4970         return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
 4971     }
 4972 
 4973     /**
 4974      * Copy the localToParent transform into specified transform.
 4975      */
 4976     BaseTransform getLocalToParentTransform(BaseTransform tx) {
 4977         updateLocalToParentTransform();
 4978         tx.setTransform(localToParentTx);
 4979         return tx;
 4980     }
 4981 
 4982     /*
 4983      * Currently used only by PathTransition
 4984      */
 4985     final BaseTransform getLeafTransform() {
 4986         return getLocalToParentTransform(TempState.getInstance().leafTx);
 4987     }
 4988 
 4989     /*
 4990      * Invoked whenever the transforms[] ObservableList changes, or by the transforms
 4991      * in that ObservableList whenever they are changed.
 4992      *
 4993      * Note: This method MUST only be called via its accessor method.
 4994      */
 4995     private void doTransformsChanged() {
 4996         if (!transformDirty) {
 4997             NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORM);
 4998             transformDirty = true;
 4999             transformedBoundsChanged();
 5000         }
 5001         invalidateLocalToParentTransform();
 5002         invalidateLocalToSceneTransform();
 5003     }
 5004 
 5005     final double getPivotX() {
 5006         final Bounds bounds = getLayoutBounds();
 5007         return bounds.getMinX() + bounds.getWidth()/2;
 5008     }
 5009 
 5010     final double getPivotY() {
 5011         final Bounds bounds = getLayoutBounds();
 5012         return bounds.getMinY() + bounds.getHeight()/2;
 5013     }
 5014 
 5015     final double getPivotZ() {
 5016         final Bounds bounds = getLayoutBounds();
 5017         return bounds.getMinZ() + bounds.getDepth()/2;
 5018     }
 5019 
 5020     /**
 5021      * This helper function will update the transform matrix on the peer based
 5022      * on the &quot;complete&quot; transform for this node.
 5023      */
 5024     void updateLocalToParentTransform() {
 5025         if (transformDirty) {
 5026             localToParentTx.setToIdentity();
 5027 
 5028             boolean mirror = false;
 5029             double mirroringCenter = 0;
 5030             if (hasMirroring()) {
 5031                 final Scene sceneValue = getScene();
 5032                 if ((sceneValue != null) &amp;&amp; (sceneValue.getRoot() == this)) {
 5033                     // handle scene mirroring in this branch
 5034                     // (must be the last transformation)
 5035                     mirroringCenter = sceneValue.getWidth() / 2;
 5036                     if (mirroringCenter == 0.0) {
 5037                         mirroringCenter = getPivotX();
 5038                     }
 5039 
 5040                     localToParentTx = localToParentTx.deriveWithTranslation(
 5041                             mirroringCenter, 0.0);
 5042                     localToParentTx = localToParentTx.deriveWithScale(
 5043                             -1.0, 1.0, 1.0);
 5044                     localToParentTx = localToParentTx.deriveWithTranslation(
 5045                             -mirroringCenter, 0.0);
 5046                 } else {
 5047                     // mirror later
 5048                     mirror = true;
 5049                     mirroringCenter = getPivotX();
 5050                 }
 5051             }
 5052 
 5053             if (getScaleX() != 1 || getScaleY() != 1 || getScaleZ() != 1 || getRotate() != 0) {
 5054                 // recompute pivotX, pivotY and pivotZ
 5055                 double pivotX = getPivotX();
 5056                 double pivotY = getPivotY();
 5057                 double pivotZ = getPivotZ();
 5058 
 5059                 localToParentTx = localToParentTx.deriveWithTranslation(
 5060                         getTranslateX() + getLayoutX() + pivotX,
 5061                         getTranslateY() + getLayoutY() + pivotY,
 5062                         getTranslateZ() + pivotZ);
 5063                 localToParentTx = localToParentTx.deriveWithRotation(
 5064                         Math.toRadians(getRotate()), getRotationAxis().getX(),
 5065                         getRotationAxis().getY(), getRotationAxis().getZ());
 5066                 localToParentTx = localToParentTx.deriveWithScale(
 5067                         getScaleX(), getScaleY(), getScaleZ());
 5068                 localToParentTx = localToParentTx.deriveWithTranslation(
 5069                         -pivotX, -pivotY, -pivotZ);
 5070             } else {
 5071                 localToParentTx = localToParentTx.deriveWithTranslation(
 5072                         getTranslateX() + getLayoutX(),
 5073                         getTranslateY() + getLayoutY(),
 5074                         getTranslateZ());
 5075             }
 5076 
 5077             if (hasTransforms()) {
 5078                 for (Transform t : getTransforms()) {
 5079                     localToParentTx = TransformHelper.derive(t, localToParentTx);
 5080                 }
 5081             }
 5082 
 5083             // Check to see whether the node requires mirroring
 5084             if (mirror) {
 5085                 localToParentTx = localToParentTx.deriveWithTranslation(
 5086                         mirroringCenter, 0);
 5087                 localToParentTx = localToParentTx.deriveWithScale(
 5088                         -1.0, 1.0, 1.0);
 5089                 localToParentTx = localToParentTx.deriveWithTranslation(
 5090                         -mirroringCenter, 0);
 5091             }
 5092 
 5093             transformDirty = false;
 5094         }
 5095     }
 5096 
 5097     /**
 5098      * Transforms in place the specified point from parent coords to local
 5099      * coords. Made package private for the sake of testing.
 5100      */
 5101     void parentToLocal(com.sun.javafx.geom.Point2D pt) throws NoninvertibleTransformException {
 5102         updateLocalToParentTransform();
 5103         localToParentTx.inverseTransform(pt, pt);
 5104     }
 5105 
 5106     void parentToLocal(com.sun.javafx.geom.Vec3d pt) throws NoninvertibleTransformException {
 5107         updateLocalToParentTransform();
 5108         localToParentTx.inverseTransform(pt, pt);
 5109     }
 5110 
 5111     void sceneToLocal(com.sun.javafx.geom.Point2D pt) throws NoninvertibleTransformException {
 5112         if (getParent() != null) {
 5113             getParent().sceneToLocal(pt);
 5114         }
 5115         parentToLocal(pt);
 5116     }
 5117 
 5118     void sceneToLocal(com.sun.javafx.geom.Vec3d pt) throws NoninvertibleTransformException {
 5119         if (getParent() != null) {
 5120             getParent().sceneToLocal(pt);
 5121         }
 5122         parentToLocal(pt);
 5123     }
 5124 
 5125     void localToScene(com.sun.javafx.geom.Point2D pt) {
 5126         localToParent(pt);
 5127         if (getParent() != null) {
 5128             getParent().localToScene(pt);
 5129         }
 5130     }
 5131 
 5132     void localToScene(com.sun.javafx.geom.Vec3d pt) {
 5133         localToParent(pt);
 5134         if (getParent() != null) {
 5135             getParent().localToScene(pt);
 5136         }
 5137     }
 5138 
 5139     /***************************************************************************
 5140      *                                                                         *
 5141      * Mouse event related APIs                                                *
 5142      *                                                                         *
 5143      **************************************************************************/
 5144 
 5145     /**
 5146      * Transforms in place the specified point from local coords to parent
 5147      * coords. Made package private for the sake of testing.
 5148      */
 5149     void localToParent(com.sun.javafx.geom.Point2D pt) {
 5150         updateLocalToParentTransform();
 5151         localToParentTx.transform(pt, pt);
 5152     }
 5153 
 5154     void localToParent(com.sun.javafx.geom.Vec3d pt) {
 5155         updateLocalToParentTransform();
 5156         localToParentTx.transform(pt, pt);
 5157     }
 5158 
 5159     /*
 5160      * Finds a top-most child node that contains the given local coordinates.
 5161      *
 5162      * The result argument is used for storing the picking result.
 5163      *
 5164      * Note: This method MUST only be called via its accessor method.
 5165      */
 5166     private void doPickNodeLocal(PickRay localPickRay, PickResultChooser result) {
 5167         intersects(localPickRay, result);
 5168     }
 5169 
 5170     /*
 5171      * Finds a top-most child node that intersects the given ray.
 5172      *
 5173      * The result argument is used for storing the picking result.
 5174      */
 5175     final void pickNode(PickRay pickRay, PickResultChooser result) {
 5176 
 5177         // In some conditions we can omit picking this node or subgraph
 5178         if (!isVisible() || isDisable() || isMouseTransparent()) {
 5179             return;
 5180         }
 5181 
 5182         final Vec3d o = pickRay.getOriginNoClone();
 5183         final double ox = o.x;
 5184         final double oy = o.y;
 5185         final double oz = o.z;
 5186         final Vec3d d = pickRay.getDirectionNoClone();
 5187         final double dx = d.x;
 5188         final double dy = d.y;
 5189         final double dz = d.z;
 5190 
 5191         updateLocalToParentTransform();
 5192         try {
 5193             localToParentTx.inverseTransform(o, o);
 5194             localToParentTx.inverseDeltaTransform(d, d);
 5195 
 5196             // Delegate to a function which can be overridden by subclasses which
 5197             // actually does the pick. The implementation is markedly different
 5198             // for leaf nodes vs. parent nodes vs. region nodes.
 5199             NodeHelper.pickNodeLocal(this, pickRay, result);
 5200         } catch (NoninvertibleTransformException e) {
 5201             // in this case we just don&#39;t pick anything
 5202         }
 5203 
 5204         pickRay.setOrigin(ox, oy, oz);
 5205         pickRay.setDirection(dx, dy, dz);
 5206     }
 5207 
 5208     /*
 5209      * Returns {@code true} if the given ray (start, dir), specified in the
 5210      * local coordinate space of this {@code Node}, intersects the
 5211      * shape of this {@code Node}. Note that this method does not take visibility
 5212      * into account; the test is based on the geometry of this {@code Node} only.
 5213      * &lt;p&gt;
 5214      * The pickResult is updated if the found intersection is closer than
 5215      * the currently held one.
 5216      * &lt;p&gt;
 5217      * Note that this is a conditional feature. See
 5218      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 5219      * for more information.
 5220      */
 5221     final boolean intersects(PickRay pickRay, PickResultChooser pickResult) {
 5222         double boundsDistance = intersectsBounds(pickRay);
 5223         if (!Double.isNaN(boundsDistance)) {
 5224             if (isPickOnBounds()) {
 5225                 if (pickResult != null) {
 5226                     pickResult.offer(this, boundsDistance, PickResultChooser.computePoint(pickRay, boundsDistance));
 5227                 }
 5228                 return true;
 5229             } else {
 5230                 return NodeHelper.computeIntersects(this, pickRay, pickResult);
 5231             }
 5232         }
 5233         return false;
 5234     }
 5235 
 5236     /*
 5237      * Computes the intersection of the pickRay with this node.
 5238      * The pickResult argument is updated if the found intersection
 5239      * is closer than the passed one. On the other hand, the return value
 5240      * specifies whether the intersection exists, regardless of its comparison
 5241      * with the given pickResult.
 5242      */
 5243     private boolean doComputeIntersects(PickRay pickRay, PickResultChooser pickResult) {
 5244         double origZ = pickRay.getOriginNoClone().z;
 5245         double dirZ = pickRay.getDirectionNoClone().z;
 5246         // Handle the case where pickRay is almost parallel to the Z-plane
 5247         if (almostZero(dirZ)) {
 5248             return false;
 5249         }
 5250         double t = -origZ / dirZ;
 5251         if (t &lt; pickRay.getNearClip() || t &gt; pickRay.getFarClip()) {
 5252             return false;
 5253         }
 5254         double x = pickRay.getOriginNoClone().x + (pickRay.getDirectionNoClone().x * t);
 5255         double y = pickRay.getOriginNoClone().y + (pickRay.getDirectionNoClone().y * t);
 5256 
 5257         if (contains((float) x, (float) y)) {
 5258             if (pickResult != null) {
 5259                 pickResult.offer(this, t, PickResultChooser.computePoint(pickRay, t));
 5260             }
 5261             return true;
 5262         }
 5263         return false;
 5264     }
 5265 
 5266     /*
 5267      * Computes the intersection of the pickRay with the bounds of this node.
 5268      * The return value is the distance between the camera and the intersection
 5269      * point, measured in pickRay direction magnitudes. If there is
 5270      * no intersection, it returns NaN.
 5271      *
 5272      * @param pickRay The pick ray
 5273      * @return Distance of the intersection point, a NaN if there
 5274      *         is no intersection
 5275      */
 5276     final double intersectsBounds(PickRay pickRay) {
 5277 
 5278         final Vec3d dir = pickRay.getDirectionNoClone();
 5279         double tmin, tmax;
 5280 
 5281         final Vec3d origin = pickRay.getOriginNoClone();
 5282         final double originX = origin.x;
 5283         final double originY = origin.y;
 5284         final double originZ = origin.z;
 5285 
 5286         final TempState tempState = TempState.getInstance();
 5287         BaseBounds tempBounds = tempState.bounds;
 5288 
 5289         tempBounds = getLocalBounds(tempBounds,
 5290                                     BaseTransform.IDENTITY_TRANSFORM);
 5291 
 5292         if (dir.x == 0.0 &amp;&amp; dir.y == 0.0) {
 5293             // fast path for the usual 2D picking
 5294 
 5295             if (dir.z == 0.0) {
 5296                 return Double.NaN;
 5297             }
 5298 
 5299             if (originX &lt; tempBounds.getMinX() ||
 5300                     originX &gt; tempBounds.getMaxX() ||
 5301                     originY &lt; tempBounds.getMinY() ||
 5302                     originY &gt; tempBounds.getMaxY()) {
 5303                 return Double.NaN;
 5304             }
 5305 
 5306             final double invDirZ = 1.0 / dir.z;
 5307             final boolean signZ = invDirZ &lt; 0.0;
 5308 
 5309             final double minZ = tempBounds.getMinZ();
 5310             final double maxZ = tempBounds.getMaxZ();
 5311             tmin = ((signZ ? maxZ : minZ) - originZ) * invDirZ;
 5312             tmax = ((signZ ? minZ : maxZ) - originZ) * invDirZ;
 5313 
 5314         } else if (tempBounds.getDepth() == 0.0) {
 5315             // fast path for 3D picking of 2D bounds
 5316 
 5317             if (almostZero(dir.z)) {
 5318                 return Double.NaN;
 5319             }
 5320 
 5321             final double t = (tempBounds.getMinZ() - originZ) / dir.z;
 5322             final double x = originX + (dir.x * t);
 5323             final double y = originY + (dir.y * t);
 5324 
 5325             if (x &lt; tempBounds.getMinX() ||
 5326                     x &gt; tempBounds.getMaxX() ||
 5327                     y &lt; tempBounds.getMinY() ||
 5328                     y &gt; tempBounds.getMaxY()) {
 5329                 return Double.NaN;
 5330             }
 5331 
 5332             tmin = tmax = t;
 5333 
 5334         } else {
 5335 
 5336             final double invDirX = dir.x == 0.0 ? Double.POSITIVE_INFINITY : (1.0 / dir.x);
 5337             final double invDirY = dir.y == 0.0 ? Double.POSITIVE_INFINITY : (1.0 / dir.y);
 5338             final double invDirZ = dir.z == 0.0 ? Double.POSITIVE_INFINITY : (1.0 / dir.z);
 5339             final boolean signX = invDirX &lt; 0.0;
 5340             final boolean signY = invDirY &lt; 0.0;
 5341             final boolean signZ = invDirZ &lt; 0.0;
 5342             final double minX = tempBounds.getMinX();
 5343             final double minY = tempBounds.getMinY();
 5344             final double maxX = tempBounds.getMaxX();
 5345             final double maxY = tempBounds.getMaxY();
 5346 
 5347             tmin = Double.NEGATIVE_INFINITY;
 5348             tmax = Double.POSITIVE_INFINITY;
 5349             if (Double.isInfinite(invDirX)) {
 5350                 if (minX &lt;= originX &amp;&amp; maxX &gt;= originX) {
 5351                     // move on, we are inside for the whole length
 5352                 } else {
 5353                     return Double.NaN;
 5354                 }
 5355             } else {
 5356                 tmin = ((signX ? maxX : minX) - originX) * invDirX;
 5357                 tmax = ((signX ? minX : maxX) - originX) * invDirX;
 5358             }
 5359 
 5360             if (Double.isInfinite(invDirY)) {
 5361                 if (minY &lt;= originY &amp;&amp; maxY &gt;= originY) {
 5362                     // move on, we are inside for the whole length
 5363                 } else {
 5364                     return Double.NaN;
 5365                 }
 5366             } else {
 5367                 final double tymin = ((signY ? maxY : minY) - originY) * invDirY;
 5368                 final double tymax = ((signY ? minY : maxY) - originY) * invDirY;
 5369 
 5370                 if ((tmin &gt; tymax) || (tymin &gt; tmax)) {
 5371                     return Double.NaN;
 5372                 }
 5373                 if (tymin &gt; tmin) {
 5374                     tmin = tymin;
 5375                 }
 5376                 if (tymax &lt; tmax) {
 5377                     tmax = tymax;
 5378                 }
 5379             }
 5380 
 5381             final double minZ = tempBounds.getMinZ();
 5382             final double maxZ = tempBounds.getMaxZ();
 5383             if (Double.isInfinite(invDirZ)) {
 5384                 if (minZ &lt;= originZ &amp;&amp; maxZ &gt;= originZ) {
 5385                     // move on, we are inside for the whole length
 5386                 } else {
 5387                     return Double.NaN;
 5388                 }
 5389             } else {
 5390                 final double tzmin = ((signZ ? maxZ : minZ) - originZ) * invDirZ;
 5391                 final double tzmax = ((signZ ? minZ : maxZ) - originZ) * invDirZ;
 5392 
 5393                 if ((tmin &gt; tzmax) || (tzmin &gt; tmax)) {
 5394                     return Double.NaN;
 5395                 }
 5396                 if (tzmin &gt; tmin) {
 5397                     tmin = tzmin;
 5398                 }
 5399                 if (tzmax &lt; tmax) {
 5400                     tmax = tzmax;
 5401                 }
 5402             }
 5403         }
 5404 
 5405         // For clip we use following semantics: pick the node normally
 5406         // if there is an intersection with the clip node. We don&#39;t consider
 5407         // clip node distance.
 5408         Node clip = getClip();
 5409         if (clip != null
 5410                 // FIXME: All 3D picking is currently ignored by rendering.
 5411                 // Until this is fixed or defined differently (RT-28510),
 5412                 // we follow this behavior.
 5413                 &amp;&amp; !(this instanceof Shape3D) &amp;&amp; !(clip instanceof Shape3D)) {
 5414             final double dirX = dir.x;
 5415             final double dirY = dir.y;
 5416             final double dirZ = dir.z;
 5417 
 5418             clip.updateLocalToParentTransform();
 5419 
 5420             boolean hitClip = true;
 5421             try {
 5422                 clip.localToParentTx.inverseTransform(origin, origin);
 5423                 clip.localToParentTx.inverseDeltaTransform(dir, dir);
 5424             } catch (NoninvertibleTransformException e) {
 5425                 hitClip = false;
 5426             }
 5427             hitClip = hitClip &amp;&amp; clip.intersects(pickRay, null);
 5428             pickRay.setOrigin(originX, originY, originZ);
 5429             pickRay.setDirection(dirX, dirY, dirZ);
 5430 
 5431             if (!hitClip) {
 5432                 return Double.NaN;
 5433             }
 5434         }
 5435 
 5436         if (Double.isInfinite(tmin) || Double.isNaN(tmin)) {
 5437             // We&#39;ve got a nonsense pick ray or bounds.
 5438             return Double.NaN;
 5439         }
 5440 
 5441         final double minDistance = pickRay.getNearClip();
 5442         final double maxDistance = pickRay.getFarClip();
 5443         if (tmin &lt; minDistance) {
 5444             if (tmax &gt;= minDistance) {
 5445                 // we are inside bounds
 5446                 return 0.0;
 5447             } else {
 5448                 return Double.NaN;
 5449             }
 5450         } else if (tmin &gt; maxDistance) {
 5451             return Double.NaN;
 5452         }
 5453 
 5454         return tmin;
 5455     }
 5456 
 5457 
 5458     // Good to find a home for commonly use util. code such as EPS.
 5459     // and almostZero. This code currently defined in multiple places,
 5460     // such as Affine3D and GeneralTransform3D.
 5461     private static final double EPSILON_ABSOLUTE = 1.0e-5;
 5462 
 5463     static boolean almostZero(double a) {
 5464         return ((a &lt; EPSILON_ABSOLUTE) &amp;&amp; (a &gt; -EPSILON_ABSOLUTE));
 5465     }
 5466 
 5467     /***************************************************************************
 5468      *                                                                         *
 5469      *                      viewOrder property handling                        *
 5470      *                                                                         *
 5471      **************************************************************************/
 5472 
 5473     /**
 5474      * Defines the rendering and picking order of this {@code Node} within its
 5475      * parent.
 5476      * &lt;p&gt;
 5477      * This property is used to alter the rendering and picking order of a node
 5478      * within its parent without reordering the parent&#39;s {@code children} list.
 5479      * For example, this can be used as a more efficient way to implement
 5480      * transparency sorting. To do this, an application can assign the viewOrder
 5481      * value of each node to the computed distance between that node and the
 5482      * viewer.
 5483      * &lt;/p&gt;
 5484      * &lt;p&gt;
 5485      * The parent will traverse its {@code children} in decreasing
 5486      * {@code viewOrder} order. This means that a child with a lower
 5487      * {@code viewOrder} will be in front of a child with a higher
 5488      * {@code viewOrder}. If two children have the same {@code viewOrder}, the
 5489      * parent will traverse them in the order they appear in the parent&#39;s
 5490      * {@code children} list.
 5491      * &lt;/p&gt;
 5492      * &lt;p&gt;
 5493      * However, {@code viewOrder} does not alter the layout and focus traversal
 5494      * order of this Node within its parent. A parent always traverses its
 5495      * {@code children} list in order when doing layout or focus traversal.
 5496      * &lt;/p&gt;
 5497      *
 5498      * @return the view order for this {@code Node}
 5499      * @defaultValue 0.0
 5500      *
 5501      * @since 9
 5502      */
 5503     public final DoubleProperty viewOrderProperty() {
 5504         return getMiscProperties().viewOrderProperty();
 5505     }
 5506 
 5507     public final void setViewOrder(double value) {
 5508         viewOrderProperty().set(value);
 5509     }
 5510 
 5511     public final double getViewOrder() {
 5512         return (miscProperties == null) ? DEFAULT_VIEW_ORDER
 5513                 : miscProperties.getViewOrder();
 5514     }
 5515 
 5516     /***************************************************************************
 5517      *                                                                         *
 5518      *                             Transformations                             *
 5519      *                                                                         *
 5520      **************************************************************************/
 5521     /**
 5522      * Defines the ObservableList of {@link javafx.scene.transform.Transform} objects
 5523      * to be applied to this {@code Node}. This ObservableList of transforms is applied
 5524      * before {@link #translateXProperty translateX}, {@link #translateYProperty translateY}, {@link #scaleXProperty scaleX}, and
 5525      * {@link #scaleYProperty scaleY}, {@link #rotateProperty rotate} transforms.
 5526      *
 5527      * @return the transforms for this {@code Node}
 5528      * @defaultValue empty
 5529      */
 5530     public final ObservableList&lt;Transform&gt; getTransforms() {
 5531         return transformsProperty();
 5532     }
 5533 
 5534     private ObservableList&lt;Transform&gt; transformsProperty() {
 5535         return getNodeTransformation().getTransforms();
 5536     }
 5537 
 5538     public final void setTranslateX(double value) {
 5539         translateXProperty().set(value);
 5540     }
 5541 
 5542     public final double getTranslateX() {
 5543         return (nodeTransformation == null)
 5544                 ? DEFAULT_TRANSLATE_X
 5545                 : nodeTransformation.getTranslateX();
 5546     }
 5547 
 5548     /**
 5549      * Defines the x coordinate of the translation that is added to this {@code Node}&#39;s
 5550      * transform.
 5551      * &lt;p&gt;
 5552      * The node&#39;s final translation will be computed as {@link #layoutXProperty layoutX} + {@code translateX},
 5553      * where {@code layoutX} establishes the node&#39;s stable position and {@code translateX}
 5554      * optionally makes dynamic adjustments to that position.
 5555      *&lt;p&gt;
 5556      * This variable can be used to alter the location of a node without disturbing
 5557      * its {@link #layoutBoundsProperty layoutBounds}, which makes it useful for animating a node&#39;s location.
 5558      *
 5559      * @return the translateX for this {@code Node}
 5560      * @defaultValue 0
 5561      */
 5562     public final DoubleProperty translateXProperty() {
 5563         return getNodeTransformation().translateXProperty();
 5564     }
 5565 
 5566     public final void setTranslateY(double value) {
 5567         translateYProperty().set(value);
 5568     }
 5569 
 5570     public final double getTranslateY() {
 5571         return (nodeTransformation == null)
 5572                 ? DEFAULT_TRANSLATE_Y
 5573                 : nodeTransformation.getTranslateY();
 5574     }
 5575 
 5576     /**
 5577      * Defines the y coordinate of the translation that is added to this {@code Node}&#39;s
 5578      * transform.
 5579      * &lt;p&gt;
 5580      * The node&#39;s final translation will be computed as {@link #layoutYProperty layoutY} + {@code translateY},
 5581      * where {@code layoutY} establishes the node&#39;s stable position and {@code translateY}
 5582      * optionally makes dynamic adjustments to that position.
 5583      * &lt;p&gt;
 5584      * This variable can be used to alter the location of a node without disturbing
 5585      * its {@link #layoutBoundsProperty layoutBounds}, which makes it useful for animating a node&#39;s location.
 5586      *
 5587      * @return the translateY for this {@code Node}
 5588      * @defaultValue 0
 5589      */
 5590     public final DoubleProperty translateYProperty() {
 5591         return getNodeTransformation().translateYProperty();
 5592     }
 5593 
 5594     public final void setTranslateZ(double value) {
 5595         translateZProperty().set(value);
 5596     }
 5597 
 5598     public final double getTranslateZ() {
 5599         return (nodeTransformation == null)
 5600                 ? DEFAULT_TRANSLATE_Z
 5601                 : nodeTransformation.getTranslateZ();
 5602     }
 5603 
 5604     /**
 5605      * Defines the Z coordinate of the translation that is added to the
 5606      * transformed coordinates of this {@code Node}.  This value will be added
 5607      * to any translation defined by the {@code transforms} ObservableList and
 5608      * {@code layoutZ}.
 5609      * &lt;p&gt;
 5610      * This variable can be used to alter the location of a Node without
 5611      * disturbing its layout bounds, which makes it useful for animating a
 5612      * node&#39;s location.
 5613      * &lt;p&gt;
 5614      * Note that this is a conditional feature. See
 5615      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 5616      * for more information.
 5617      *
 5618      * @return the translateZ for this {@code Node}
 5619      * @defaultValue 0
 5620      */
 5621     public final DoubleProperty translateZProperty() {
 5622         return getNodeTransformation().translateZProperty();
 5623     }
 5624 
 5625     public final void setScaleX(double value) {
 5626         scaleXProperty().set(value);
 5627     }
 5628 
 5629     public final double getScaleX() {
 5630         return (nodeTransformation == null) ? DEFAULT_SCALE_X
 5631                                             : nodeTransformation.getScaleX();
 5632     }
 5633 
 5634     /**
 5635      * Defines the factor by which coordinates are scaled about the center of the
 5636      * object along the X axis of this {@code Node}. This is used to stretch or
 5637      * shrink the node either manually or by using an animation.
 5638      * &lt;p&gt;
 5639      * This scale factor is not included in {@link #layoutBoundsProperty layoutBounds} by
 5640      * default, which makes it ideal for scaling the entire node after
 5641      * all effects and transforms have been taken into account.
 5642      * &lt;p&gt;
 5643      * The pivot point about which the scale occurs is the center of the
 5644      * untransformed {@link #layoutBoundsProperty layoutBounds}.
 5645      *
 5646      * @return the scaleX for this {@code Node}
 5647      * @defaultValue 1.0
 5648      */
 5649     public final DoubleProperty scaleXProperty() {
 5650         return getNodeTransformation().scaleXProperty();
 5651     }
 5652 
 5653     public final void setScaleY(double value) {
 5654         scaleYProperty().set(value);
 5655     }
 5656 
 5657     public final double getScaleY() {
 5658         return (nodeTransformation == null) ? DEFAULT_SCALE_Y
 5659                                             : nodeTransformation.getScaleY();
 5660     }
 5661 
 5662     /**
 5663      * Defines the factor by which coordinates are scaled about the center of the
 5664      * object along the Y axis of this {@code Node}. This is used to stretch or
 5665      * shrink the node either manually or by using an animation.
 5666      * &lt;p&gt;
 5667      * This scale factor is not included in {@link #layoutBoundsProperty layoutBounds} by
 5668      * default, which makes it ideal for scaling the entire node after
 5669      * all effects and transforms have been taken into account.
 5670      * &lt;p&gt;
 5671      * The pivot point about which the scale occurs is the center of the
 5672      * untransformed {@link #layoutBoundsProperty layoutBounds}.
 5673      *
 5674      * @return the scaleY for this {@code Node}
 5675      * @defaultValue 1.0
 5676      */
 5677     public final DoubleProperty scaleYProperty() {
 5678         return getNodeTransformation().scaleYProperty();
 5679     }
 5680 
 5681     public final void setScaleZ(double value) {
 5682         scaleZProperty().set(value);
 5683     }
 5684 
 5685     public final double getScaleZ() {
 5686         return (nodeTransformation == null) ? DEFAULT_SCALE_Z
 5687                                             : nodeTransformation.getScaleZ();
 5688     }
 5689 
 5690     /**
 5691      * Defines the factor by which coordinates are scaled about the center of the
 5692      * object along the Z axis of this {@code Node}. This is used to stretch or
 5693      * shrink the node either manually or by using an animation.
 5694      * &lt;p&gt;
 5695      * This scale factor is not included in {@link #layoutBoundsProperty layoutBounds} by
 5696      * default, which makes it ideal for scaling the entire node after
 5697      * all effects and transforms have been taken into account.
 5698      * &lt;p&gt;
 5699      * The pivot point about which the scale occurs is the center of the
 5700      * rectangular bounds formed by taking {@link #boundsInLocalProperty boundsInLocal} and applying
 5701      * all the transforms in the {@link #getTransforms transforms} ObservableList.
 5702      * &lt;p&gt;
 5703      * Note that this is a conditional feature. See
 5704      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 5705      * for more information.
 5706      *
 5707      * @return the scaleZ for this {@code Node}
 5708      * @defaultValue 1.0
 5709      */
 5710     public final DoubleProperty scaleZProperty() {
 5711         return getNodeTransformation().scaleZProperty();
 5712     }
 5713 
 5714     public final void setRotate(double value) {
 5715         rotateProperty().set(value);
 5716     }
 5717 
 5718     public final double getRotate() {
 5719         return (nodeTransformation == null) ? DEFAULT_ROTATE
 5720                                             : nodeTransformation.getRotate();
 5721     }
 5722 
 5723     /**
 5724      * Defines the angle of rotation about the {@code Node}&#39;s center, measured in
 5725      * degrees. This is used to rotate the {@code Node}.
 5726      * &lt;p&gt;
 5727      * This rotation factor is not included in {@link #layoutBoundsProperty layoutBounds} by
 5728      * default, which makes it ideal for rotating the entire node after
 5729      * all effects and transforms have been taken into account.
 5730      * &lt;p&gt;
 5731      * The pivot point about which the rotation occurs is the center of the
 5732      * untransformed {@link #layoutBoundsProperty layoutBounds}.
 5733      * &lt;p&gt;
 5734      * Note that because the pivot point is computed as the center of this
 5735      * {@code Node}&#39;s layout bounds, any change to the layout bounds will cause
 5736      * the pivot point to change, which can move the object. For a leaf node,
 5737      * any change to the geometry will cause the layout bounds to change.
 5738      * For a group node, any change to any of its children, including a
 5739      * change in a child&#39;s geometry, clip, effect, position, orientation, or
 5740      * scale, will cause the group&#39;s layout bounds to change. If this movement
 5741      * of the pivot point is not
 5742      * desired, applications should instead use the Node&#39;s {@link #getTransforms transforms}
 5743      * ObservableList, and add a {@link javafx.scene.transform.Rotate} transform,
 5744      * which has a user-specifiable pivot point.
 5745      *
 5746      * @return the rotate for this {@code Node}
 5747      * @defaultValue 0.0
 5748      */
 5749     public final DoubleProperty rotateProperty() {
 5750         return getNodeTransformation().rotateProperty();
 5751     }
 5752 
 5753     public final void setRotationAxis(Point3D value) {
 5754         rotationAxisProperty().set(value);
 5755     }
 5756 
 5757     public final Point3D getRotationAxis() {
 5758         return (nodeTransformation == null)
 5759                 ? DEFAULT_ROTATION_AXIS
 5760                 : nodeTransformation.getRotationAxis();
 5761     }
 5762 
 5763     /**
 5764      * Defines the axis of rotation of this {@code Node}.
 5765      * &lt;p&gt;
 5766      * Note that this is a conditional feature. See
 5767      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 5768      * for more information.
 5769      *
 5770      * @return the rotationAxis for this {@code Node}
 5771      * @defaultValue Rotate.Z_AXIS
 5772      */
 5773     public final ObjectProperty&lt;Point3D&gt; rotationAxisProperty() {
 5774         return getNodeTransformation().rotationAxisProperty();
 5775     }
 5776 
 5777     /**
 5778      * An affine transform that holds the computed local-to-parent transform.
 5779      * This is the concatenation of all transforms in this node, including all
 5780      * of the convenience transforms.
 5781      * @return the localToParent transform for this {@code Node}
 5782      * @since JavaFX 2.2
 5783      */
 5784     public final ReadOnlyObjectProperty&lt;Transform&gt; localToParentTransformProperty() {
 5785         return getNodeTransformation().localToParentTransformProperty();
 5786     }
 5787 
 5788     private void invalidateLocalToParentTransform() {
 5789         if (nodeTransformation != null) {
 5790             nodeTransformation.invalidateLocalToParentTransform();
 5791         }
 5792     }
 5793 
 5794     public final Transform getLocalToParentTransform() {
 5795         return localToParentTransformProperty().get();
 5796     }
 5797 
 5798     /**
 5799      * An affine transform that holds the computed local-to-scene transform.
 5800      * This is the concatenation of all transforms in this node&#39;s parents and
 5801      * in this node, including all of the convenience transforms up to the root.
 5802      * If this node is in a {@link javafx.scene.SubScene}, this property represents
 5803      * transforms up to the subscene, not the root scene.
 5804      *
 5805      * &lt;p&gt;
 5806      * Note that when you register a listener or a binding to this property,
 5807      * it needs to listen for invalidation on all its parents to the root node.
 5808      * This means that registering a listener on this
 5809      * property on many nodes may negatively affect performance of
 5810      * transformation changes in their common parents.
 5811      * &lt;/p&gt;
 5812      *
 5813      * @return the localToScene transform for this {@code Node}
 5814      * @since JavaFX 2.2
 5815      */
 5816     public final ReadOnlyObjectProperty&lt;Transform&gt; localToSceneTransformProperty() {
 5817         return getNodeTransformation().localToSceneTransformProperty();
 5818     }
 5819 
 5820     private void invalidateLocalToSceneTransform() {
 5821         if (nodeTransformation != null) {
 5822             nodeTransformation.invalidateLocalToSceneTransform();
 5823         }
 5824     }
 5825 
 5826     public final Transform getLocalToSceneTransform() {
 5827         return localToSceneTransformProperty().get();
 5828     }
 5829 
 5830     private NodeTransformation nodeTransformation;
 5831 
 5832     private NodeTransformation getNodeTransformation() {
 5833         if (nodeTransformation == null) {
 5834             nodeTransformation = new NodeTransformation();
 5835         }
 5836 
 5837         return nodeTransformation;
 5838     }
 5839 
 5840     private boolean hasTransforms() {
 5841         return (nodeTransformation != null)
 5842                 &amp;&amp; nodeTransformation.hasTransforms();
 5843     }
 5844 
 5845     // for tests only
 5846     Transform getCurrentLocalToSceneTransformState() {
 5847         if (nodeTransformation == null ||
 5848                 nodeTransformation.localToSceneTransform == null) {
 5849             return null;
 5850         }
 5851 
 5852         return nodeTransformation.localToSceneTransform.transform;
 5853     }
 5854 
 5855     private static final double DEFAULT_TRANSLATE_X = 0;
 5856     private static final double DEFAULT_TRANSLATE_Y = 0;
 5857     private static final double DEFAULT_TRANSLATE_Z = 0;
 5858     private static final double DEFAULT_SCALE_X = 1;
 5859     private static final double DEFAULT_SCALE_Y = 1;
 5860     private static final double DEFAULT_SCALE_Z = 1;
 5861     private static final double DEFAULT_ROTATE = 0;
 5862     private static final Point3D DEFAULT_ROTATION_AXIS = Rotate.Z_AXIS;
 5863 
 5864     private final class NodeTransformation {
 5865         private DoubleProperty translateX;
 5866         private DoubleProperty translateY;
 5867         private DoubleProperty translateZ;
 5868         private DoubleProperty scaleX;
 5869         private DoubleProperty scaleY;
 5870         private DoubleProperty scaleZ;
 5871         private DoubleProperty rotate;
 5872         private ObjectProperty&lt;Point3D&gt; rotationAxis;
 5873         private ObservableList&lt;Transform&gt; transforms;
 5874         private LazyTransformProperty localToParentTransform;
 5875         private LazyTransformProperty localToSceneTransform;
 5876         private int listenerReasons = 0;
 5877         private InvalidationListener localToSceneInvLstnr;
 5878 
 5879         private InvalidationListener getLocalToSceneInvalidationListener() {
 5880             if (localToSceneInvLstnr == null) {
 5881                 localToSceneInvLstnr = observable -&gt; invalidateLocalToSceneTransform();
 5882             }
 5883             return localToSceneInvLstnr;
 5884         }
 5885 
 5886         public void incListenerReasons() {
 5887             if (listenerReasons == 0) {
 5888                 Node n = Node.this.getParent();
 5889                 if (n != null) {
 5890                     n.localToSceneTransformProperty().addListener(
 5891                             getLocalToSceneInvalidationListener());
 5892                 }
 5893             }
 5894             listenerReasons++;
 5895         }
 5896 
 5897         public void decListenerReasons() {
 5898             listenerReasons--;
 5899             if (listenerReasons == 0) {
 5900                 Node n = Node.this.getParent();
 5901                 if (n != null) {
 5902                     n.localToSceneTransformProperty().removeListener(
 5903                             getLocalToSceneInvalidationListener());
 5904                 }
 5905                 if (localToSceneTransform != null) {
 5906                     localToSceneTransform.validityUnknown();
 5907                 }
 5908             }
 5909         }
 5910 
 5911         public final Transform getLocalToParentTransform() {
 5912             return localToParentTransformProperty().get();
 5913         }
 5914 
 5915         public final ReadOnlyObjectProperty&lt;Transform&gt; localToParentTransformProperty() {
 5916             if (localToParentTransform == null) {
 5917                 localToParentTransform = new LazyTransformProperty() {
 5918                     @Override
 5919                     protected Transform computeTransform(Transform reuse) {
 5920                         updateLocalToParentTransform();
 5921                         return TransformUtils.immutableTransform(reuse,
 5922                                 localToParentTx.getMxx(), localToParentTx.getMxy(), localToParentTx.getMxz(), localToParentTx.getMxt(),
 5923                                 localToParentTx.getMyx(), localToParentTx.getMyy(), localToParentTx.getMyz(), localToParentTx.getMyt(),
 5924                                 localToParentTx.getMzx(), localToParentTx.getMzy(), localToParentTx.getMzz(), localToParentTx.getMzt());
 5925                     }
 5926 
 5927                     @Override
 5928                     protected boolean validityKnown() {
 5929                         return true;
 5930                     }
 5931 
 5932                     @Override
 5933                     protected int computeValidity() {
 5934                         return valid;
 5935                     }
 5936 
 5937                     @Override
 5938                     public Object getBean() {
 5939                         return Node.this;
 5940                     }
 5941 
 5942                     @Override
 5943                     public String getName() {
 5944                         return &quot;localToParentTransform&quot;;
 5945                     }
 5946                 };
 5947             }
 5948 
 5949             return localToParentTransform;
 5950         }
 5951 
 5952         public void invalidateLocalToParentTransform() {
 5953             if (localToParentTransform != null) {
 5954                 localToParentTransform.invalidate();
 5955             }
 5956         }
 5957 
 5958         public final Transform getLocalToSceneTransform() {
 5959             return localToSceneTransformProperty().get();
 5960         }
 5961 
 5962         class LocalToSceneTransformProperty extends LazyTransformProperty {
 5963             // need this to track number of listeners
 5964             private List localToSceneListeners;
 5965             // stamps to watch for parent changes when the listeners
 5966             // are not present
 5967             private long stamp, parentStamp;
 5968 
 5969             @Override
 5970             protected Transform computeTransform(Transform reuse) {
 5971                 stamp++;
 5972                 updateLocalToParentTransform();
 5973 
 5974                 Node parentNode = Node.this.getParent();
 5975                 if (parentNode != null) {
 5976                     final LocalToSceneTransformProperty parentProperty =
 5977                             (LocalToSceneTransformProperty) parentNode.localToSceneTransformProperty();
 5978                     final Transform parentTransform = parentProperty.getInternalValue();
 5979 
 5980                     parentStamp = parentProperty.stamp;
 5981 
 5982                     return TransformUtils.immutableTransform(reuse,
 5983                             parentTransform,
 5984                             ((LazyTransformProperty) localToParentTransformProperty()).getInternalValue());
 5985                 } else {
 5986                     return TransformUtils.immutableTransform(reuse,
 5987                             ((LazyTransformProperty) localToParentTransformProperty()).getInternalValue());
 5988                 }
 5989             }
 5990 
 5991             @Override
 5992             public Object getBean() {
 5993                 return Node.this;
 5994             }
 5995 
 5996             @Override
 5997             public String getName() {
 5998                 return &quot;localToSceneTransform&quot;;
 5999             }
 6000 
 6001             @Override
 6002             protected boolean validityKnown() {
 6003                 return listenerReasons &gt; 0;
 6004             }
 6005 
 6006             @Override
 6007             protected int computeValidity() {
 6008                 if (valid != VALIDITY_UNKNOWN) {
 6009                     return valid;
 6010                 }
 6011 
 6012                 Node n = (Node) getBean();
 6013                 Node parent = n.getParent();
 6014 
 6015                 if (parent != null) {
 6016                     final LocalToSceneTransformProperty parentProperty =
 6017                             (LocalToSceneTransformProperty) parent.localToSceneTransformProperty();
 6018 
 6019                     if (parentStamp != parentProperty.stamp) {
 6020                         valid = INVALID;
 6021                         return INVALID;
 6022                     }
 6023 
 6024                     int parentValid = parentProperty.computeValidity();
 6025                     if (parentValid == INVALID) {
 6026                         valid = INVALID;
 6027                     }
 6028                     return parentValid;
 6029                 }
 6030 
 6031                 // Validity unknown for root means it is valid
 6032                 return VALID;
 6033             }
 6034 
 6035             @Override
 6036             public void addListener(InvalidationListener listener) {
 6037                 incListenerReasons();
 6038                 if (localToSceneListeners == null) {
 6039                     localToSceneListeners = new LinkedList&lt;Object&gt;();
 6040                 }
 6041                 localToSceneListeners.add(listener);
 6042                 super.addListener(listener);
 6043             }
 6044 
 6045             @Override
 6046             public void addListener(ChangeListener&lt;? super Transform&gt; listener) {
 6047                 incListenerReasons();
 6048                 if (localToSceneListeners == null) {
 6049                     localToSceneListeners = new LinkedList&lt;Object&gt;();
 6050                 }
 6051                 localToSceneListeners.add(listener);
 6052                 super.addListener(listener);
 6053             }
 6054 
 6055             @Override
 6056             public void removeListener(InvalidationListener listener) {
 6057                 if (localToSceneListeners != null &amp;&amp;
 6058                         localToSceneListeners.remove(listener)) {
 6059                     decListenerReasons();
 6060                 }
 6061                 super.removeListener(listener);
 6062             }
 6063 
 6064             @Override
 6065             public void removeListener(ChangeListener&lt;? super Transform&gt; listener) {
 6066                 if (localToSceneListeners != null &amp;&amp;
 6067                         localToSceneListeners.remove(listener)) {
 6068                     decListenerReasons();
 6069                 }
 6070                 super.removeListener(listener);
 6071             }
 6072         }
 6073 
 6074         public final ReadOnlyObjectProperty&lt;Transform&gt; localToSceneTransformProperty() {
 6075             if (localToSceneTransform == null) {
 6076                 localToSceneTransform = new LocalToSceneTransformProperty();
 6077             }
 6078 
 6079             return localToSceneTransform;
 6080         }
 6081 
 6082         public void invalidateLocalToSceneTransform() {
 6083             if (localToSceneTransform != null) {
 6084                 localToSceneTransform.invalidate();
 6085             }
 6086         }
 6087 
 6088         public double getTranslateX() {
 6089             return (translateX == null) ? DEFAULT_TRANSLATE_X
 6090                                         : translateX.get();
 6091         }
 6092 
 6093         public final DoubleProperty translateXProperty() {
 6094             if (translateX == null) {
 6095                 translateX = new StyleableDoubleProperty(DEFAULT_TRANSLATE_X) {
 6096                     @Override
 6097                     public void invalidated() {
 6098                         NodeHelper.transformsChanged(Node.this);
 6099                     }
 6100 
 6101                     @Override
 6102                     public CssMetaData getCssMetaData() {
 6103                         return StyleableProperties.TRANSLATE_X;
 6104                     }
 6105 
 6106                     @Override
 6107                     public Object getBean() {
 6108                         return Node.this;
 6109                     }
 6110 
 6111                     @Override
 6112                     public String getName() {
 6113                         return &quot;translateX&quot;;
 6114                     }
 6115                 };
 6116             }
 6117             return translateX;
 6118         }
 6119 
 6120         public double getTranslateY() {
 6121             return (translateY == null) ? DEFAULT_TRANSLATE_Y : translateY.get();
 6122         }
 6123 
 6124         public final DoubleProperty translateYProperty() {
 6125             if (translateY == null) {
 6126                 translateY = new StyleableDoubleProperty(DEFAULT_TRANSLATE_Y) {
 6127                     @Override
 6128                     public void invalidated() {
 6129                         NodeHelper.transformsChanged(Node.this);
 6130                     }
 6131 
 6132                     @Override
 6133                     public CssMetaData getCssMetaData() {
 6134                         return StyleableProperties.TRANSLATE_Y;
 6135                     }
 6136 
 6137                     @Override
 6138                     public Object getBean() {
 6139                         return Node.this;
 6140                     }
 6141 
 6142                     @Override
 6143                     public String getName() {
 6144                         return &quot;translateY&quot;;
 6145                     }
 6146                 };
 6147             }
 6148             return translateY;
 6149         }
 6150 
 6151         public double getTranslateZ() {
 6152             return (translateZ == null) ? DEFAULT_TRANSLATE_Z : translateZ.get();
 6153         }
 6154 
 6155         public final DoubleProperty translateZProperty() {
 6156             if (translateZ == null) {
 6157                 translateZ = new StyleableDoubleProperty(DEFAULT_TRANSLATE_Z) {
 6158                     @Override
 6159                     public void invalidated() {
 6160                         NodeHelper.transformsChanged(Node.this);
 6161                     }
 6162 
 6163                     @Override
 6164                     public CssMetaData getCssMetaData() {
 6165                         return StyleableProperties.TRANSLATE_Z;
 6166                     }
 6167 
 6168                     @Override
 6169                     public Object getBean() {
 6170                         return Node.this;
 6171                     }
 6172 
 6173                     @Override
 6174                     public String getName() {
 6175                         return &quot;translateZ&quot;;
 6176                     }
 6177                 };
 6178             }
 6179             return translateZ;
 6180         }
 6181 
 6182         public double getScaleX() {
 6183             return (scaleX == null) ? DEFAULT_SCALE_X : scaleX.get();
 6184         }
 6185 
 6186         public final DoubleProperty scaleXProperty() {
 6187             if (scaleX == null) {
 6188                 scaleX = new StyleableDoubleProperty(DEFAULT_SCALE_X) {
 6189                     @Override
 6190                     public void invalidated() {
 6191                         NodeHelper.transformsChanged(Node.this);
 6192                     }
 6193 
 6194                     @Override
 6195                     public CssMetaData getCssMetaData() {
 6196                         return StyleableProperties.SCALE_X;
 6197                     }
 6198 
 6199                     @Override
 6200                     public Object getBean() {
 6201                         return Node.this;
 6202                     }
 6203 
 6204                     @Override
 6205                     public String getName() {
 6206                         return &quot;scaleX&quot;;
 6207                     }
 6208                 };
 6209             }
 6210             return scaleX;
 6211         }
 6212 
 6213         public double getScaleY() {
 6214             return (scaleY == null) ? DEFAULT_SCALE_Y : scaleY.get();
 6215         }
 6216 
 6217         public final DoubleProperty scaleYProperty() {
 6218             if (scaleY == null) {
 6219                 scaleY = new StyleableDoubleProperty(DEFAULT_SCALE_Y) {
 6220                     @Override
 6221                     public void invalidated() {
 6222                         NodeHelper.transformsChanged(Node.this);
 6223                     }
 6224 
 6225                     @Override
 6226                     public CssMetaData getCssMetaData() {
 6227                         return StyleableProperties.SCALE_Y;
 6228                     }
 6229 
 6230                     @Override
 6231                     public Object getBean() {
 6232                         return Node.this;
 6233                     }
 6234 
 6235                     @Override
 6236                     public String getName() {
 6237                         return &quot;scaleY&quot;;
 6238                     }
 6239                 };
 6240             }
 6241             return scaleY;
 6242         }
 6243 
 6244         public double getScaleZ() {
 6245             return (scaleZ == null) ? DEFAULT_SCALE_Z : scaleZ.get();
 6246         }
 6247 
 6248         public final DoubleProperty scaleZProperty() {
 6249             if (scaleZ == null) {
 6250                 scaleZ = new StyleableDoubleProperty(DEFAULT_SCALE_Z) {
 6251                     @Override
 6252                     public void invalidated() {
 6253                         NodeHelper.transformsChanged(Node.this);
 6254                     }
 6255 
 6256                     @Override
 6257                     public CssMetaData getCssMetaData() {
 6258                         return StyleableProperties.SCALE_Z;
 6259                     }
 6260 
 6261                     @Override
 6262                     public Object getBean() {
 6263                         return Node.this;
 6264                     }
 6265 
 6266                     @Override
 6267                     public String getName() {
 6268                         return &quot;scaleZ&quot;;
 6269                     }
 6270                 };
 6271             }
 6272             return scaleZ;
 6273         }
 6274 
 6275         public double getRotate() {
 6276             return (rotate == null) ? DEFAULT_ROTATE : rotate.get();
 6277         }
 6278 
 6279         public final DoubleProperty rotateProperty() {
 6280             if (rotate == null) {
 6281                 rotate = new StyleableDoubleProperty(DEFAULT_ROTATE) {
 6282                     @Override
 6283                     public void invalidated() {
 6284                         NodeHelper.transformsChanged(Node.this);
 6285                     }
 6286 
 6287                     @Override
 6288                     public CssMetaData getCssMetaData() {
 6289                         return StyleableProperties.ROTATE;
 6290                     }
 6291 
 6292                     @Override
 6293                     public Object getBean() {
 6294                         return Node.this;
 6295                     }
 6296 
 6297                     @Override
 6298                     public String getName() {
 6299                         return &quot;rotate&quot;;
 6300                     }
 6301                 };
 6302             }
 6303             return rotate;
 6304         }
 6305 
 6306         public Point3D getRotationAxis() {
 6307             return (rotationAxis == null) ? DEFAULT_ROTATION_AXIS
 6308                                           : rotationAxis.get();
 6309         }
 6310 
 6311         public final ObjectProperty&lt;Point3D&gt; rotationAxisProperty() {
 6312             if (rotationAxis == null) {
 6313                 rotationAxis = new ObjectPropertyBase&lt;Point3D&gt;(
 6314                                            DEFAULT_ROTATION_AXIS) {
 6315                     @Override
 6316                     protected void invalidated() {
 6317                         NodeHelper.transformsChanged(Node.this);
 6318                     }
 6319 
 6320                     @Override
 6321                     public Object getBean() {
 6322                         return Node.this;
 6323                     }
 6324 
 6325                     @Override
 6326                     public String getName() {
 6327                         return &quot;rotationAxis&quot;;
 6328                     }
 6329                 };
 6330             }
 6331             return rotationAxis;
 6332         }
 6333 
 6334         public ObservableList&lt;Transform&gt; getTransforms() {
 6335             if (transforms == null) {
 6336                 transforms = new TrackableObservableList&lt;Transform&gt;() {
 6337                     @Override
 6338                     protected void onChanged(Change&lt;Transform&gt; c) {
 6339                         while (c.next()) {
 6340                             for (Transform t : c.getRemoved()) {
 6341                                 TransformHelper.remove(t, Node.this);
 6342                             }
 6343                             for (Transform t : c.getAddedSubList()) {
 6344                                 TransformHelper.add(t, Node.this);
 6345                             }
 6346                         }
 6347 
 6348                         NodeHelper.transformsChanged(Node.this);
 6349                     }
 6350                 };
 6351             }
 6352 
 6353             return transforms;
 6354         }
 6355 
 6356         public boolean canSetTranslateX() {
 6357             return (translateX == null) || !translateX.isBound();
 6358         }
 6359 
 6360         public boolean canSetTranslateY() {
 6361             return (translateY == null) || !translateY.isBound();
 6362         }
 6363 
 6364         public boolean canSetTranslateZ() {
 6365             return (translateZ == null) || !translateZ.isBound();
 6366         }
 6367 
 6368         public boolean canSetScaleX() {
 6369             return (scaleX == null) || !scaleX.isBound();
 6370         }
 6371 
 6372         public boolean canSetScaleY() {
 6373             return (scaleY == null) || !scaleY.isBound();
 6374         }
 6375 
 6376         public boolean canSetScaleZ() {
 6377             return (scaleZ == null) || !scaleZ.isBound();
 6378         }
 6379 
 6380         public boolean canSetRotate() {
 6381             return (rotate == null) || !rotate.isBound();
 6382         }
 6383 
 6384         public boolean hasTransforms() {
 6385             return (transforms != null &amp;&amp; !transforms.isEmpty());
 6386         }
 6387 
 6388         public boolean hasScaleOrRotate() {
 6389             if (scaleX != null &amp;&amp; scaleX.get() != DEFAULT_SCALE_X) {
 6390                 return true;
 6391             }
 6392             if (scaleY != null &amp;&amp; scaleY.get() != DEFAULT_SCALE_Y) {
 6393                 return true;
 6394             }
 6395             if (scaleZ != null &amp;&amp; scaleZ.get() != DEFAULT_SCALE_Z) {
 6396                 return true;
 6397             }
 6398             if (rotate != null &amp;&amp; rotate.get() != DEFAULT_ROTATE) {
 6399                 return true;
 6400             }
 6401             return false;
 6402         }
 6403 
 6404     }
 6405 
 6406     ////////////////////////////
 6407     //  Private Implementation
 6408     ////////////////////////////
 6409 
 6410     /***************************************************************************
 6411      *                                                                         *
 6412      *                        Event Handler Properties                         *
 6413      *                                                                         *
 6414      **************************************************************************/
 6415 
 6416     private EventHandlerProperties eventHandlerProperties;
 6417 
 6418     private EventHandlerProperties getEventHandlerProperties() {
 6419         if (eventHandlerProperties == null) {
 6420             eventHandlerProperties =
 6421                     new EventHandlerProperties(
 6422                         getInternalEventDispatcher().getEventHandlerManager(),
 6423                         this);
 6424         }
 6425 
 6426         return eventHandlerProperties;
 6427     }
 6428 
 6429     /***************************************************************************
 6430      *                                                                         *
 6431      *                       Component Orientation Properties                  *
 6432      *                                                                         *
 6433      **************************************************************************/
 6434 
 6435     private ObjectProperty&lt;NodeOrientation&gt; nodeOrientation;
 6436     private EffectiveOrientationProperty effectiveNodeOrientationProperty;
 6437 
 6438     private static final byte EFFECTIVE_ORIENTATION_LTR = 0;
 6439     private static final byte EFFECTIVE_ORIENTATION_RTL = 1;
 6440     private static final byte EFFECTIVE_ORIENTATION_MASK = 1;
 6441     private static final byte AUTOMATIC_ORIENTATION_LTR = 0;
 6442     private static final byte AUTOMATIC_ORIENTATION_RTL = 2;
 6443     private static final byte AUTOMATIC_ORIENTATION_MASK = 2;
 6444 
 6445     private byte resolvedNodeOrientation =
 6446             EFFECTIVE_ORIENTATION_LTR | AUTOMATIC_ORIENTATION_LTR;
 6447 
 6448     public final void setNodeOrientation(NodeOrientation orientation) {
 6449         nodeOrientationProperty().set(orientation);
 6450     }
 6451 
 6452     public final NodeOrientation getNodeOrientation() {
 6453         return nodeOrientation == null ? NodeOrientation.INHERIT : nodeOrientation.get();
 6454     }
 6455     /**
 6456      * Property holding NodeOrientation.
 6457      * &lt;p&gt;
 6458      * Node orientation describes the flow of visual data within a node.
 6459      * In the English speaking world, visual data normally flows from
 6460      * left-to-right. In an Arabic or Hebrew world, visual data flows
 6461      * from right-to-left.  This is consistent with the reading order
 6462      * of text in both worlds.  The default value is left-to-right.
 6463      * &lt;/p&gt;
 6464      *
 6465      * @return NodeOrientation
 6466      * @since JavaFX 8.0
 6467      */
 6468     public final ObjectProperty&lt;NodeOrientation&gt; nodeOrientationProperty() {
 6469         if (nodeOrientation == null) {
 6470             nodeOrientation = new StyleableObjectProperty&lt;NodeOrientation&gt;(NodeOrientation.INHERIT) {
 6471                 @Override
 6472                 protected void invalidated() {
 6473                     nodeResolvedOrientationInvalidated();
 6474                 }
 6475 
 6476                 @Override
 6477                 public Object getBean() {
 6478                     return Node.this;
 6479                 }
 6480 
 6481                 @Override
 6482                 public String getName() {
 6483                     return &quot;nodeOrientation&quot;;
 6484                 }
 6485 
 6486                 @Override
 6487                 public CssMetaData getCssMetaData() {
 6488                     //TODO - not supported
 6489                     throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
 6490                 }
 6491 
 6492             };
 6493         }
 6494         return nodeOrientation;
 6495     }
 6496 
 6497     public final NodeOrientation getEffectiveNodeOrientation() {
 6498         return (getEffectiveOrientation(resolvedNodeOrientation)
 6499                     == EFFECTIVE_ORIENTATION_LTR)
 6500                        ? NodeOrientation.LEFT_TO_RIGHT
 6501                        : NodeOrientation.RIGHT_TO_LEFT;
 6502     }
 6503 
 6504     /**
 6505      * The effective orientation of a node resolves the inheritance of
 6506      * node orientation, returning either left-to-right or right-to-left.
 6507      * @return the node orientation for this {@code Node}
 6508      * @since JavaFX 8.0
 6509      */
 6510     public final ReadOnlyObjectProperty&lt;NodeOrientation&gt;
 6511             effectiveNodeOrientationProperty() {
 6512         if (effectiveNodeOrientationProperty == null) {
 6513             effectiveNodeOrientationProperty =
 6514                     new EffectiveOrientationProperty();
 6515         }
 6516 
 6517         return effectiveNodeOrientationProperty;
 6518     }
 6519 
 6520     /**
 6521      * Determines whether a node should be mirrored when node orientation
 6522      * is right-to-left.
 6523      * &lt;p&gt;
 6524      * When a node is mirrored, the origin is automatically moved to the
 6525      * top right corner causing the node to layout children and draw from
 6526      * right to left using a mirroring transformation.  Some nodes may wish
 6527      * to draw from right to left without using a transformation.  These
 6528      * nodes will will answer {@code false} and implement right-to-left
 6529      * orientation without using the automatic transformation.
 6530      * &lt;/p&gt;
 6531      * @return true if this {@code Node} should be mirrored
 6532      * @since JavaFX 8.0
 6533      */
 6534     public boolean usesMirroring() {
 6535         return true;
 6536     }
 6537 
 6538     final void parentResolvedOrientationInvalidated() {
 6539         if (getNodeOrientation() == NodeOrientation.INHERIT) {
 6540             nodeResolvedOrientationInvalidated();
 6541         } else {
 6542             // mirroring changed
 6543             NodeHelper.transformsChanged(this);
 6544         }
 6545     }
 6546 
 6547     final void nodeResolvedOrientationInvalidated() {
 6548         final byte oldResolvedNodeOrientation =
 6549                 resolvedNodeOrientation;
 6550 
 6551         resolvedNodeOrientation =
 6552                 (byte) (calcEffectiveNodeOrientation()
 6553                             | calcAutomaticNodeOrientation());
 6554 
 6555         if ((effectiveNodeOrientationProperty != null)
 6556                 &amp;&amp; (getEffectiveOrientation(resolvedNodeOrientation)
 6557                         != getEffectiveOrientation(
 6558                                oldResolvedNodeOrientation))) {
 6559             effectiveNodeOrientationProperty.invalidate();
 6560         }
 6561 
 6562         // mirroring changed
 6563         NodeHelper.transformsChanged(this);
 6564 
 6565         if (resolvedNodeOrientation != oldResolvedNodeOrientation) {
 6566             nodeResolvedOrientationChanged();
 6567         }
 6568     }
 6569 
 6570     void nodeResolvedOrientationChanged() {
 6571         // overriden in Parent
 6572     }
 6573 
 6574     private Node getMirroringOrientationParent() {
 6575         Node parentValue = getParent();
 6576         while (parentValue != null) {
 6577             if (parentValue.usesMirroring()) {
 6578                 return parentValue;
 6579             }
 6580             parentValue = parentValue.getParent();
 6581         }
 6582 
 6583         final Node subSceneValue = getSubScene();
 6584         if (subSceneValue != null) {
 6585             return subSceneValue;
 6586         }
 6587 
 6588         return null;
 6589     }
 6590 
 6591     private Node getOrientationParent() {
 6592         final Node parentValue = getParent();
 6593         if (parentValue != null) {
 6594             return parentValue;
 6595         }
 6596 
 6597         final Node subSceneValue = getSubScene();
 6598         if (subSceneValue != null) {
 6599             return subSceneValue;
 6600         }
 6601 
 6602         return null;
 6603     }
 6604 
 6605     private byte calcEffectiveNodeOrientation() {
 6606         final NodeOrientation nodeOrientationValue = getNodeOrientation();
 6607         if (nodeOrientationValue != NodeOrientation.INHERIT) {
 6608             return (nodeOrientationValue == NodeOrientation.LEFT_TO_RIGHT)
 6609                        ? EFFECTIVE_ORIENTATION_LTR
 6610                        : EFFECTIVE_ORIENTATION_RTL;
 6611         }
 6612 
 6613         final Node parentValue = getOrientationParent();
 6614         if (parentValue != null) {
 6615             return getEffectiveOrientation(parentValue.resolvedNodeOrientation);
 6616         }
 6617 
 6618         final Scene sceneValue = getScene();
 6619         if (sceneValue != null) {
 6620             return (sceneValue.getEffectiveNodeOrientation()
 6621                         == NodeOrientation.LEFT_TO_RIGHT)
 6622                            ? EFFECTIVE_ORIENTATION_LTR
 6623                            : EFFECTIVE_ORIENTATION_RTL;
 6624         }
 6625 
 6626         return EFFECTIVE_ORIENTATION_LTR;
 6627     }
 6628 
 6629     private byte calcAutomaticNodeOrientation() {
 6630         if (!usesMirroring()) {
 6631             return AUTOMATIC_ORIENTATION_LTR;
 6632         }
 6633 
 6634         final NodeOrientation nodeOrientationValue = getNodeOrientation();
 6635         if (nodeOrientationValue != NodeOrientation.INHERIT) {
 6636             return (nodeOrientationValue == NodeOrientation.LEFT_TO_RIGHT)
 6637                        ? AUTOMATIC_ORIENTATION_LTR
 6638                        : AUTOMATIC_ORIENTATION_RTL;
 6639         }
 6640 
 6641         final Node parentValue = getMirroringOrientationParent();
 6642         if (parentValue != null) {
 6643             // automatic node orientation is inherited
 6644             return getAutomaticOrientation(parentValue.resolvedNodeOrientation);
 6645         }
 6646 
 6647         final Scene sceneValue = getScene();
 6648         if (sceneValue != null) {
 6649             return (sceneValue.getEffectiveNodeOrientation()
 6650                         == NodeOrientation.LEFT_TO_RIGHT)
 6651                            ? AUTOMATIC_ORIENTATION_LTR
 6652                            : AUTOMATIC_ORIENTATION_RTL;
 6653         }
 6654 
 6655         return AUTOMATIC_ORIENTATION_LTR;
 6656     }
 6657 
 6658     // Return true if the node needs to be mirrored.
 6659     // A node has mirroring if the orientation differs from the parent
 6660     // package private for testing
 6661     final boolean hasMirroring() {
 6662         final Node parentValue = getOrientationParent();
 6663 
 6664         final byte thisOrientation =
 6665                 getAutomaticOrientation(resolvedNodeOrientation);
 6666         final byte parentOrientation =
 6667                 (parentValue != null)
 6668                     ? getAutomaticOrientation(
 6669                           parentValue.resolvedNodeOrientation)
 6670                     : AUTOMATIC_ORIENTATION_LTR;
 6671 
 6672         return thisOrientation != parentOrientation;
 6673     }
 6674 
 6675     private static byte getEffectiveOrientation(
 6676             final byte resolvedNodeOrientation) {
 6677         return (byte) (resolvedNodeOrientation &amp; EFFECTIVE_ORIENTATION_MASK);
 6678     }
 6679 
 6680     private static byte getAutomaticOrientation(
 6681             final byte resolvedNodeOrientation) {
 6682         return (byte) (resolvedNodeOrientation &amp; AUTOMATIC_ORIENTATION_MASK);
 6683     }
 6684 
 6685     private final class EffectiveOrientationProperty
 6686             extends ReadOnlyObjectPropertyBase&lt;NodeOrientation&gt; {
 6687         @Override
 6688         public NodeOrientation get() {
 6689             return getEffectiveNodeOrientation();
 6690         }
 6691 
 6692         @Override
 6693         public Object getBean() {
 6694             return Node.this;
 6695         }
 6696 
 6697         @Override
 6698         public String getName() {
 6699             return &quot;effectiveNodeOrientation&quot;;
 6700         }
 6701 
 6702         public void invalidate() {
 6703             fireValueChangedEvent();
 6704         }
 6705     }
 6706 
 6707     /***************************************************************************
 6708      *                                                                         *
 6709      *                       Misc Seldom Used Properties                       *
 6710      *                                                                         *
 6711      **************************************************************************/
 6712 
 6713     private MiscProperties miscProperties;
 6714 
 6715     private MiscProperties getMiscProperties() {
 6716         if (miscProperties == null) {
 6717             miscProperties = new MiscProperties();
 6718         }
 6719 
 6720         return miscProperties;
 6721     }
 6722 
 6723     private static final double DEFAULT_VIEW_ORDER = 0;
 6724     private static final boolean DEFAULT_CACHE = false;
 6725     private static final CacheHint DEFAULT_CACHE_HINT = CacheHint.DEFAULT;
 6726     private static final Node DEFAULT_CLIP = null;
 6727     private static final Cursor DEFAULT_CURSOR = null;
 6728     private static final DepthTest DEFAULT_DEPTH_TEST = DepthTest.INHERIT;
 6729     private static final boolean DEFAULT_DISABLE = false;
 6730     private static final Effect DEFAULT_EFFECT = null;
 6731     private static final InputMethodRequests DEFAULT_INPUT_METHOD_REQUESTS =
 6732             null;
 6733     private static final boolean DEFAULT_MOUSE_TRANSPARENT = false;
 6734 
 6735     private final class MiscProperties {
 6736         private LazyBoundsProperty boundsInParent;
 6737         private LazyBoundsProperty boundsInLocal;
 6738         private BooleanProperty cache;
 6739         private ObjectProperty&lt;CacheHint&gt; cacheHint;
 6740         private ObjectProperty&lt;Node&gt; clip;
 6741         private ObjectProperty&lt;Cursor&gt; cursor;
 6742         private ObjectProperty&lt;DepthTest&gt; depthTest;
 6743         private BooleanProperty disable;
 6744         private ObjectProperty&lt;Effect&gt; effect;
 6745         private ObjectProperty&lt;InputMethodRequests&gt; inputMethodRequests;
 6746         private BooleanProperty mouseTransparent;
 6747         private DoubleProperty viewOrder;
 6748 
 6749         public double getViewOrder() {
 6750             return (viewOrder == null) ? DEFAULT_VIEW_ORDER : viewOrder.get();
 6751         }
 6752 
 6753         public final DoubleProperty viewOrderProperty() {
 6754             if (viewOrder == null) {
 6755                 viewOrder = new StyleableDoubleProperty(DEFAULT_VIEW_ORDER) {
 6756                     @Override
 6757                     public void invalidated() {
 6758                         Parent p = getParent();
 6759                         if (p != null) {
 6760                             // Parent will be responsible to update sorted children list
 6761                             p.markViewOrderChildrenDirty();
 6762                         }
 6763                         NodeHelper.markDirty(Node.this, DirtyBits.NODE_VIEW_ORDER);
 6764                     }
 6765 
 6766                     @Override
 6767                     public CssMetaData getCssMetaData() {
 6768                         return StyleableProperties.VIEW_ORDER;
 6769                     }
 6770 
 6771                     @Override
 6772                     public Object getBean() {
 6773                         return Node.this;
 6774                     }
 6775 
 6776                     @Override
 6777                     public String getName() {
 6778                         return &quot;viewOrder&quot;;
 6779                     }
 6780                 };
 6781             }
 6782             return viewOrder;
 6783         }
 6784 
 6785         public final Bounds getBoundsInParent() {
 6786             return boundsInParentProperty().get();
 6787         }
 6788 
 6789         public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInParentProperty() {
 6790             if (boundsInParent == null) {
 6791                 boundsInParent = new LazyBoundsProperty() {
 6792                     /**
 6793                      * Computes the bounds including the clip, effects, and all
 6794                      * transforms. This function is essentially how to compute
 6795                      * the boundsInParent. Optimizations are made to compute as
 6796                      * little as possible and create as little trash as
 6797                      * possible.
 6798                      */
 6799                     @Override
 6800                     protected Bounds computeBounds() {
 6801                         BaseBounds tempBounds = TempState.getInstance().bounds;
 6802                         tempBounds = getTransformedBounds(
 6803                                              tempBounds,
 6804                                              BaseTransform.IDENTITY_TRANSFORM);
 6805                         return new BoundingBox(tempBounds.getMinX(),
 6806                                                tempBounds.getMinY(),
 6807                                                tempBounds.getMinZ(),
 6808                                                tempBounds.getWidth(),
 6809                                                tempBounds.getHeight(),
 6810                                                tempBounds.getDepth());
 6811                     }
 6812 
 6813                     @Override
 6814                     public Object getBean() {
 6815                         return Node.this;
 6816                     }
 6817 
 6818                     @Override
 6819                     public String getName() {
 6820                         return &quot;boundsInParent&quot;;
 6821                     }
 6822                 };
 6823             }
 6824 
 6825             return boundsInParent;
 6826         }
 6827 
 6828         public void invalidateBoundsInParent() {
 6829             if (boundsInParent != null) {
 6830                 boundsInParent.invalidate();
 6831             }
 6832         }
 6833 
 6834         public final Bounds getBoundsInLocal() {
 6835             return boundsInLocalProperty().get();
 6836         }
 6837 
 6838         public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInLocalProperty() {
 6839             if (boundsInLocal == null) {
 6840                 boundsInLocal = new LazyBoundsProperty() {
 6841                     @Override
 6842                     protected Bounds computeBounds() {
 6843                         BaseBounds tempBounds = TempState.getInstance().bounds;
 6844                         tempBounds = getLocalBounds(
 6845                                              tempBounds,
 6846                                              BaseTransform.IDENTITY_TRANSFORM);
 6847                         return new BoundingBox(tempBounds.getMinX(),
 6848                                                tempBounds.getMinY(),
 6849                                                tempBounds.getMinZ(),
 6850                                                tempBounds.getWidth(),
 6851                                                tempBounds.getHeight(),
 6852                                                tempBounds.getDepth());
 6853                     }
 6854 
 6855                     @Override
 6856                     public Object getBean() {
 6857                         return Node.this;
 6858                     }
 6859 
 6860                     @Override
 6861                     public String getName() {
 6862                         return &quot;boundsInLocal&quot;;
 6863                     }
 6864                 };
 6865             }
 6866 
 6867             return boundsInLocal;
 6868         }
 6869 
 6870         public void invalidateBoundsInLocal() {
 6871             if (boundsInLocal != null) {
 6872                 boundsInLocal.invalidate();
 6873             }
 6874         }
 6875 
 6876         public final boolean isCache() {
 6877             return (cache == null) ? DEFAULT_CACHE
 6878                                    : cache.get();
 6879         }
 6880 
 6881         public final BooleanProperty cacheProperty() {
 6882             if (cache == null) {
 6883                 cache = new BooleanPropertyBase(DEFAULT_CACHE) {
 6884                     @Override
 6885                     protected void invalidated() {
 6886                         NodeHelper.markDirty(Node.this, DirtyBits.NODE_CACHE);
 6887                     }
 6888 
 6889                     @Override
 6890                     public Object getBean() {
 6891                         return Node.this;
 6892                     }
 6893 
 6894                     @Override
 6895                     public String getName() {
 6896                         return &quot;cache&quot;;
 6897                     }
 6898                 };
 6899             }
 6900             return cache;
 6901         }
 6902 
 6903         public final CacheHint getCacheHint() {
 6904             return (cacheHint == null) ? DEFAULT_CACHE_HINT
 6905                                        : cacheHint.get();
 6906         }
 6907 
 6908         public final ObjectProperty&lt;CacheHint&gt; cacheHintProperty() {
 6909             if (cacheHint == null) {
 6910                 cacheHint = new ObjectPropertyBase&lt;CacheHint&gt;(DEFAULT_CACHE_HINT) {
 6911                     @Override
 6912                     protected void invalidated() {
 6913                         NodeHelper.markDirty(Node.this, DirtyBits.NODE_CACHE);
 6914                     }
 6915 
 6916                     @Override
 6917                     public Object getBean() {
 6918                         return Node.this;
 6919                     }
 6920 
 6921                     @Override
 6922                     public String getName() {
 6923                         return &quot;cacheHint&quot;;
 6924                     }
 6925                 };
 6926             }
 6927             return cacheHint;
 6928         }
 6929 
 6930         public final Node getClip() {
 6931             return (clip == null) ? DEFAULT_CLIP : clip.get();
 6932         }
 6933 
 6934         public final ObjectProperty&lt;Node&gt; clipProperty() {
 6935             if (clip == null) {
 6936                 clip = new ObjectPropertyBase&lt;Node&gt;(DEFAULT_CLIP) {
 6937 
 6938                     //temp variables used when clip was invalid to rollback to
 6939                     // last value
 6940                     private Node oldClip;
 6941 
 6942                     @Override
 6943                     protected void invalidated() {
 6944                         final Node newClip = get();
 6945                         if ((newClip != null)
 6946                                 &amp;&amp; ((newClip.isConnected()
 6947                                            &amp;&amp; newClip.clipParent != Node.this)
 6948                                        || wouldCreateCycle(Node.this,
 6949                                                            newClip))) {
 6950                             // Assigning this node to clip is illegal.
 6951                             // Roll back to the previous state and throw an
 6952                             // exception.
 6953                             final String cause =
 6954                                     newClip.isConnected()
 6955                                         &amp;&amp; (newClip.clipParent != Node.this)
 6956                                             ? &quot;node already connected&quot;
 6957                                             : &quot;cycle detected&quot;;
 6958 
 6959                             if (isBound()) {
 6960                                 unbind();
 6961                                 set(oldClip);
 6962                                 throw new IllegalArgumentException(
 6963                                         &quot;Node&#39;s clip set to incorrect value &quot;
 6964                                             + &quot; through binding&quot;
 6965                                             + &quot; (&quot; + cause + &quot;, node  = &quot;
 6966                                                    + Node.this + &quot;, clip = &quot;
 6967                                                    + clip + &quot;).&quot;
 6968                                             + &quot; Binding has been removed.&quot;);
 6969                             } else {
 6970                                 set(oldClip);
 6971                                 throw new IllegalArgumentException(
 6972                                         &quot;Node&#39;s clip set to incorrect value&quot;
 6973                                             + &quot; (&quot; + cause + &quot;, node  = &quot;
 6974                                                    + Node.this + &quot;, clip = &quot;
 6975                                                    + clip + &quot;).&quot;);
 6976                             }
 6977                         } else {
 6978                             if (oldClip != null) {
 6979                                 oldClip.clipParent = null;
 6980                                 oldClip.setScenes(null, null);
 6981                                 oldClip.updateTreeVisible(false);
 6982                             }
 6983 
 6984                             if (newClip != null) {
 6985                                 newClip.clipParent = Node.this;
 6986                                 newClip.setScenes(getScene(), getSubScene());
 6987                                 newClip.updateTreeVisible(true);
 6988                             }
 6989 
 6990                             NodeHelper.markDirty(Node.this, DirtyBits.NODE_CLIP);
 6991 
 6992                             // the local bounds have (probably) changed
 6993                             localBoundsChanged();
 6994 
 6995                             oldClip = newClip;
 6996                         }
 6997                     }
 6998 
 6999                     @Override
 7000                     public Object getBean() {
 7001                         return Node.this;
 7002                     }
 7003 
 7004                     @Override
 7005                     public String getName() {
 7006                         return &quot;clip&quot;;
 7007                     }
 7008                 };
 7009             }
 7010             return clip;
 7011         }
 7012 
 7013         public final Cursor getCursor() {
 7014             return (cursor == null) ? DEFAULT_CURSOR : cursor.get();
 7015         }
 7016 
 7017         public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
 7018             if (cursor == null) {
 7019                 cursor = new StyleableObjectProperty&lt;Cursor&gt;(DEFAULT_CURSOR) {
 7020 
 7021                     @Override
 7022                     protected void invalidated() {
 7023                         final Scene sceneValue = getScene();
 7024                         if (sceneValue != null) {
 7025                             sceneValue.markCursorDirty();
 7026                         }
 7027                     }
 7028 
 7029                     @Override
 7030                     public CssMetaData getCssMetaData() {
 7031                         return StyleableProperties.CURSOR;
 7032                     }
 7033 
 7034                     @Override
 7035                     public Object getBean() {
 7036                         return Node.this;
 7037                     }
 7038 
 7039                     @Override
 7040                     public String getName() {
 7041                         return &quot;cursor&quot;;
 7042                     }
 7043 
 7044                 };
 7045             }
 7046             return cursor;
 7047         }
 7048 
 7049         public final DepthTest getDepthTest() {
 7050             return (depthTest == null) ? DEFAULT_DEPTH_TEST
 7051                                        : depthTest.get();
 7052         }
 7053 
 7054         public final ObjectProperty&lt;DepthTest&gt; depthTestProperty() {
 7055             if (depthTest == null) {
 7056                 depthTest = new ObjectPropertyBase&lt;DepthTest&gt;(DEFAULT_DEPTH_TEST) {
 7057                     @Override protected void invalidated() {
 7058                         computeDerivedDepthTest();
 7059                     }
 7060 
 7061                     @Override
 7062                     public Object getBean() {
 7063                         return Node.this;
 7064                     }
 7065 
 7066                     @Override
 7067                     public String getName() {
 7068                         return &quot;depthTest&quot;;
 7069                     }
 7070                 };
 7071             }
 7072             return depthTest;
 7073         }
 7074 
 7075         public final boolean isDisable() {
 7076             return (disable == null) ? DEFAULT_DISABLE : disable.get();
 7077         }
 7078 
 7079         public final BooleanProperty disableProperty() {
 7080             if (disable == null) {
 7081                 disable = new BooleanPropertyBase(DEFAULT_DISABLE) {
 7082                     @Override
 7083                     protected void invalidated() {
 7084                         updateDisabled();
 7085                     }
 7086 
 7087                     @Override
 7088                     public Object getBean() {
 7089                         return Node.this;
 7090                     }
 7091 
 7092                     @Override
 7093                     public String getName() {
 7094                         return &quot;disable&quot;;
 7095                     }
 7096                 };
 7097             }
 7098             return disable;
 7099         }
 7100 
 7101         public final Effect getEffect() {
 7102             return (effect == null) ? DEFAULT_EFFECT : effect.get();
 7103         }
 7104 
 7105         public final ObjectProperty&lt;Effect&gt; effectProperty() {
 7106             if (effect == null) {
 7107                 effect = new StyleableObjectProperty&lt;Effect&gt;(DEFAULT_EFFECT) {
 7108                     private Effect oldEffect = null;
 7109                     private int oldBits;
 7110 
 7111                     private final AbstractNotifyListener effectChangeListener =
 7112                             new AbstractNotifyListener() {
 7113 
 7114                         @Override
 7115                         public void invalidated(Observable valueModel) {
 7116                             int newBits = ((IntegerProperty) valueModel).get();
 7117                             int changedBits = newBits ^ oldBits;
 7118                             oldBits = newBits;
 7119                             if (EffectDirtyBits.isSet(
 7120                                     changedBits,
 7121                                     EffectDirtyBits.EFFECT_DIRTY)
 7122                                 &amp;&amp; EffectDirtyBits.isSet(
 7123                                        newBits,
 7124                                        EffectDirtyBits.EFFECT_DIRTY)) {
 7125                                 NodeHelper.markDirty(Node.this, DirtyBits.EFFECT_EFFECT);
 7126                             }
 7127                             if (EffectDirtyBits.isSet(
 7128                                     changedBits,
 7129                                     EffectDirtyBits.BOUNDS_CHANGED)) {
 7130                                 localBoundsChanged();
 7131                             }
 7132                         }
 7133                     };
 7134 
 7135                     @Override
 7136                     protected void invalidated() {
 7137                         Effect _effect = get();
 7138                         if (oldEffect != null) {
 7139                             EffectHelper.effectDirtyProperty(oldEffect).removeListener(
 7140                                     effectChangeListener.getWeakListener());
 7141                         }
 7142                         oldEffect = _effect;
 7143                         if (_effect != null) {
 7144                             EffectHelper.effectDirtyProperty(_effect)
 7145                                    .addListener(
 7146                                        effectChangeListener.getWeakListener());
 7147                             if (EffectHelper.isEffectDirty(_effect)) {
 7148                                 NodeHelper.markDirty(Node.this, DirtyBits.EFFECT_EFFECT);
 7149                             }
 7150                             oldBits = EffectHelper.effectDirtyProperty(_effect).get();
 7151                         }
 7152 
 7153                         NodeHelper.markDirty(Node.this, DirtyBits.NODE_EFFECT);
 7154                         // bounds may have changed regardless whether
 7155                         // the dirty flag on effect is set
 7156                         localBoundsChanged();
 7157                     }
 7158 
 7159                     @Override
 7160                     public CssMetaData getCssMetaData() {
 7161                         return StyleableProperties.EFFECT;
 7162                     }
 7163 
 7164                     @Override
 7165                     public Object getBean() {
 7166                         return Node.this;
 7167                     }
 7168 
 7169                     @Override
 7170                     public String getName() {
 7171                         return &quot;effect&quot;;
 7172                     }
 7173                 };
 7174             }
 7175             return effect;
 7176         }
 7177 
 7178         public final InputMethodRequests getInputMethodRequests() {
 7179             return (inputMethodRequests == null) ? DEFAULT_INPUT_METHOD_REQUESTS
 7180                                                  : inputMethodRequests.get();
 7181         }
 7182 
 7183         public ObjectProperty&lt;InputMethodRequests&gt;
 7184                 inputMethodRequestsProperty() {
 7185             if (inputMethodRequests == null) {
 7186                 inputMethodRequests =
 7187                         new SimpleObjectProperty&lt;InputMethodRequests&gt;(
 7188                                 Node.this,
 7189                                 &quot;inputMethodRequests&quot;,
 7190                                 DEFAULT_INPUT_METHOD_REQUESTS);
 7191             }
 7192             return inputMethodRequests;
 7193         }
 7194 
 7195         public final boolean isMouseTransparent() {
 7196             return (mouseTransparent == null) ? DEFAULT_MOUSE_TRANSPARENT
 7197                                               : mouseTransparent.get();
 7198         }
 7199 
 7200         public final BooleanProperty mouseTransparentProperty() {
 7201             if (mouseTransparent == null) {
 7202                 mouseTransparent =
 7203                         new SimpleBooleanProperty(
 7204                                 Node.this,
 7205                                 &quot;mouseTransparent&quot;,
 7206                                 DEFAULT_MOUSE_TRANSPARENT);
 7207             }
 7208             return mouseTransparent;
 7209         }
 7210 
 7211         public boolean canSetCursor() {
 7212             return (cursor == null) || !cursor.isBound();
 7213         }
 7214 
 7215         public boolean canSetEffect() {
 7216             return (effect == null) || !effect.isBound();
 7217         }
 7218     }
 7219 
 7220     /* *************************************************************************
 7221      *                                                                         *
 7222      *                             Mouse Handling                              *
 7223      *                                                                         *
 7224      **************************************************************************/
 7225 
 7226     public final void setMouseTransparent(boolean value) {
 7227         mouseTransparentProperty().set(value);
 7228     }
 7229 
 7230     public final boolean isMouseTransparent() {
 7231         return (miscProperties == null) ? DEFAULT_MOUSE_TRANSPARENT
 7232                                         : miscProperties.isMouseTransparent();
 7233     }
 7234 
 7235     /**
 7236      * If {@code true}, this node (together with all its children) is completely
 7237      * transparent to mouse events. When choosing target for mouse event, nodes
 7238      * with {@code mouseTransparent} set to {@code true} and their subtrees
 7239      * won&#39;t be taken into account.
 7240      * @return is this {@code Node} (together with all its children) is completely
 7241      * transparent to mouse events.
 7242      */
 7243     public final BooleanProperty mouseTransparentProperty() {
 7244         return getMiscProperties().mouseTransparentProperty();
 7245     }
 7246 
 7247     /**
 7248      * Whether or not this {@code Node} is being hovered over. Typically this is
 7249      * due to the mouse being over the node, though it could be due to a pen
 7250      * hovering on a graphics tablet or other form of input.
 7251      *
 7252      * &lt;p&gt;Note that current implementation of hover relies on mouse enter and
 7253      * exit events to determine whether this Node is in the hover state; this
 7254      * means that this feature is currently supported only on systems that
 7255      * have a mouse. Future implementations may provide alternative means of
 7256      * supporting hover.
 7257      *
 7258      * @defaultValue false
 7259      */
 7260     private ReadOnlyBooleanWrapper hover;
 7261 
 7262     protected final void setHover(boolean value) {
 7263         hoverPropertyImpl().set(value);
 7264     }
 7265 
 7266     public final boolean isHover() {
 7267         return hover == null ? false : hover.get();
 7268     }
 7269 
 7270     public final ReadOnlyBooleanProperty hoverProperty() {
 7271         return hoverPropertyImpl().getReadOnlyProperty();
 7272     }
 7273 
 7274     private ReadOnlyBooleanWrapper hoverPropertyImpl() {
 7275         if (hover == null) {
 7276             hover = new ReadOnlyBooleanWrapper() {
 7277 
 7278                 @Override
 7279                 protected void invalidated() {
 7280                     PlatformLogger logger = Logging.getInputLogger();
 7281                     if (logger.isLoggable(Level.FINER)) {
 7282                         logger.finer(this + &quot; hover=&quot; + get());
 7283                     }
 7284                     pseudoClassStateChanged(HOVER_PSEUDOCLASS_STATE, get());
 7285                 }
 7286 
 7287                 @Override
 7288                 public Object getBean() {
 7289                     return Node.this;
 7290                 }
 7291 
 7292                 @Override
 7293                 public String getName() {
 7294                     return &quot;hover&quot;;
 7295                 }
 7296             };
 7297         }
 7298         return hover;
 7299     }
 7300 
 7301     /**
 7302      * Whether or not the {@code Node} is pressed. Typically this is true when
 7303      * the primary mouse button is down, though subclasses may define other
 7304      * mouse button state or key state to cause the node to be &quot;pressed&quot;.
 7305      *
 7306      * @defaultValue false
 7307      */
 7308     private ReadOnlyBooleanWrapper pressed;
 7309 
 7310     protected final void setPressed(boolean value) {
 7311         pressedPropertyImpl().set(value);
 7312     }
 7313 
 7314     public final boolean isPressed() {
 7315         return pressed == null ? false : pressed.get();
 7316     }
 7317 
 7318     public final ReadOnlyBooleanProperty pressedProperty() {
 7319         return pressedPropertyImpl().getReadOnlyProperty();
 7320     }
 7321 
 7322     private ReadOnlyBooleanWrapper pressedPropertyImpl() {
 7323         if (pressed == null) {
 7324             pressed = new ReadOnlyBooleanWrapper() {
 7325 
 7326                 @Override
 7327                 protected void invalidated() {
 7328                     PlatformLogger logger = Logging.getInputLogger();
 7329                     if (logger.isLoggable(Level.FINER)) {
 7330                         logger.finer(this + &quot; pressed=&quot; + get());
 7331                     }
 7332                     pseudoClassStateChanged(PRESSED_PSEUDOCLASS_STATE, get());
 7333                 }
 7334 
 7335                 @Override
 7336                 public Object getBean() {
 7337                     return Node.this;
 7338                 }
 7339 
 7340                 @Override
 7341                 public String getName() {
 7342                     return &quot;pressed&quot;;
 7343                 }
 7344             };
 7345         }
 7346         return pressed;
 7347     }
 7348 
 7349     public final void setOnContextMenuRequested(
 7350             EventHandler&lt;? super ContextMenuEvent&gt; value) {
 7351         onContextMenuRequestedProperty().set(value);
 7352     }
 7353 
 7354     public final EventHandler&lt;? super ContextMenuEvent&gt; getOnContextMenuRequested() {
 7355         return (eventHandlerProperties == null)
 7356                 ? null : eventHandlerProperties.onContextMenuRequested();
 7357     }
 7358 
 7359     /**
 7360      * Defines a function to be called when a context menu
 7361      * has been requested on this {@code Node}.
 7362      * @return the event handler that is called when a context menu has been
 7363      * requested on this {@code Node}
 7364      * @since JavaFX 2.1
 7365      */
 7366     public final ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt;
 7367             onContextMenuRequestedProperty() {
 7368         return getEventHandlerProperties().onContextMenuRequestedProperty();
 7369     }
 7370 
 7371     public final void setOnMouseClicked(
 7372             EventHandler&lt;? super MouseEvent&gt; value) {
 7373         onMouseClickedProperty().set(value);
 7374     }
 7375 
 7376     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseClicked() {
 7377         return (eventHandlerProperties == null)
 7378                 ? null : eventHandlerProperties.getOnMouseClicked();
 7379     }
 7380 
 7381     /**
 7382      * Defines a function to be called when a mouse button has been clicked
 7383      * (pressed and released) on this {@code Node}.
 7384      * @return the event handler that is called when a mouse button has been
 7385      * clicked (pressed and released) on this {@code Node}
 7386      */
 7387     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7388             onMouseClickedProperty() {
 7389         return getEventHandlerProperties().onMouseClickedProperty();
 7390     }
 7391 
 7392     public final void setOnMouseDragged(
 7393             EventHandler&lt;? super MouseEvent&gt; value) {
 7394         onMouseDraggedProperty().set(value);
 7395     }
 7396 
 7397     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseDragged() {
 7398         return (eventHandlerProperties == null)
 7399                 ? null : eventHandlerProperties.getOnMouseDragged();
 7400     }
 7401 
 7402     /**
 7403      * Defines a function to be called when a mouse button is pressed
 7404      * on this {@code Node} and then dragged.
 7405      * @return the event handler that is called when a mouse button is pressed
 7406      * on this {@code Node} and then dragged
 7407      */
 7408     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7409             onMouseDraggedProperty() {
 7410         return getEventHandlerProperties().onMouseDraggedProperty();
 7411     }
 7412 
 7413     public final void setOnMouseEntered(
 7414             EventHandler&lt;? super MouseEvent&gt; value) {
 7415         onMouseEnteredProperty().set(value);
 7416     }
 7417 
 7418     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseEntered() {
 7419         return (eventHandlerProperties == null)
 7420                 ? null : eventHandlerProperties.getOnMouseEntered();
 7421     }
 7422 
 7423     /**
 7424      * Defines a function to be called when the mouse enters this {@code Node}.
 7425      * @return the event handler that is called when a mouse enters this
 7426      * {@code Node}
 7427      */
 7428     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7429             onMouseEnteredProperty() {
 7430         return getEventHandlerProperties().onMouseEnteredProperty();
 7431     }
 7432 
 7433     public final void setOnMouseExited(
 7434             EventHandler&lt;? super MouseEvent&gt; value) {
 7435         onMouseExitedProperty().set(value);
 7436     }
 7437 
 7438     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseExited() {
 7439         return (eventHandlerProperties == null)
 7440                 ? null : eventHandlerProperties.getOnMouseExited();
 7441     }
 7442 
 7443     /**
 7444      * Defines a function to be called when the mouse exits this {@code Node}.
 7445      * @return the event handler that is called when a mouse exits this
 7446      * {@code Node}
 7447      */
 7448     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7449             onMouseExitedProperty() {
 7450         return getEventHandlerProperties().onMouseExitedProperty();
 7451     }
 7452 
 7453     public final void setOnMouseMoved(
 7454             EventHandler&lt;? super MouseEvent&gt; value) {
 7455         onMouseMovedProperty().set(value);
 7456     }
 7457 
 7458     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseMoved() {
 7459         return (eventHandlerProperties == null)
 7460                 ? null : eventHandlerProperties.getOnMouseMoved();
 7461     }
 7462 
 7463     /**
 7464      * Defines a function to be called when mouse cursor moves within
 7465      * this {@code Node} but no buttons have been pushed.
 7466      * @return the event handler that is called when a mouse cursor moves
 7467      * within this {@code Node} but no buttons have been pushed
 7468      */
 7469     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7470             onMouseMovedProperty() {
 7471         return getEventHandlerProperties().onMouseMovedProperty();
 7472     }
 7473 
 7474     public final void setOnMousePressed(
 7475             EventHandler&lt;? super MouseEvent&gt; value) {
 7476         onMousePressedProperty().set(value);
 7477     }
 7478 
 7479     public final EventHandler&lt;? super MouseEvent&gt; getOnMousePressed() {
 7480         return (eventHandlerProperties == null)
 7481                 ? null : eventHandlerProperties.getOnMousePressed();
 7482     }
 7483 
 7484     /**
 7485      * Defines a function to be called when a mouse button
 7486      * has been pressed on this {@code Node}.
 7487      * @return the event handler that is called when a mouse button has been
 7488      * pressed on this {@code Node}
 7489      */
 7490     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7491             onMousePressedProperty() {
 7492         return getEventHandlerProperties().onMousePressedProperty();
 7493     }
 7494 
 7495     public final void setOnMouseReleased(
 7496             EventHandler&lt;? super MouseEvent&gt; value) {
 7497         onMouseReleasedProperty().set(value);
 7498     }
 7499 
 7500     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseReleased() {
 7501         return (eventHandlerProperties == null)
 7502                 ? null : eventHandlerProperties.getOnMouseReleased();
 7503     }
 7504 
 7505     /**
 7506      * Defines a function to be called when a mouse button
 7507      * has been released on this {@code Node}.
 7508      * @return the event handler that is called when a mouse button has been
 7509      * released on this {@code Node}
 7510      */
 7511     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7512             onMouseReleasedProperty() {
 7513         return getEventHandlerProperties().onMouseReleasedProperty();
 7514     }
 7515 
 7516     public final void setOnDragDetected(
 7517             EventHandler&lt;? super MouseEvent&gt; value) {
 7518         onDragDetectedProperty().set(value);
 7519     }
 7520 
 7521     public final EventHandler&lt;? super MouseEvent&gt; getOnDragDetected() {
 7522         return (eventHandlerProperties == null)
 7523                 ? null : eventHandlerProperties.getOnDragDetected();
 7524     }
 7525 
 7526     /**
 7527      * Defines a function to be called when drag gesture has been
 7528      * detected. This is the right place to start drag and drop operation.
 7529      * @return the event handler that is called when drag gesture has been
 7530      * detected
 7531      */
 7532     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7533             onDragDetectedProperty() {
 7534         return getEventHandlerProperties().onDragDetectedProperty();
 7535     }
 7536 
 7537     public final void setOnMouseDragOver(
 7538             EventHandler&lt;? super MouseDragEvent&gt; value) {
 7539         onMouseDragOverProperty().set(value);
 7540     }
 7541 
 7542     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragOver() {
 7543         return (eventHandlerProperties == null)
 7544                 ? null : eventHandlerProperties.getOnMouseDragOver();
 7545     }
 7546 
 7547     /**
 7548      * Defines a function to be called when a full press-drag-release gesture
 7549      * progresses within this {@code Node}.
 7550      * @return the event handler that is called when a full press-drag-release
 7551      * gesture progresses within this {@code Node}
 7552      * @since JavaFX 2.1
 7553      */
 7554     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
 7555             onMouseDragOverProperty() {
 7556         return getEventHandlerProperties().onMouseDragOverProperty();
 7557     }
 7558 
 7559     public final void setOnMouseDragReleased(
 7560             EventHandler&lt;? super MouseDragEvent&gt; value) {
 7561         onMouseDragReleasedProperty().set(value);
 7562     }
 7563 
 7564     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragReleased() {
 7565         return (eventHandlerProperties == null)
 7566                 ? null : eventHandlerProperties.getOnMouseDragReleased();
 7567     }
 7568 
 7569     /**
 7570      * Defines a function to be called when a full press-drag-release gesture
 7571      * ends (by releasing mouse button) within this {@code Node}.
 7572      * @return the event handler that is called when a full press-drag-release
 7573      * gesture ends (by releasing mouse button) within this {@code Node}
 7574      * @since JavaFX 2.1
 7575      */
 7576     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
 7577             onMouseDragReleasedProperty() {
 7578         return getEventHandlerProperties().onMouseDragReleasedProperty();
 7579     }
 7580 
 7581     public final void setOnMouseDragEntered(
 7582             EventHandler&lt;? super MouseDragEvent&gt; value) {
 7583         onMouseDragEnteredProperty().set(value);
 7584     }
 7585 
 7586     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragEntered() {
 7587         return (eventHandlerProperties == null)
 7588                 ? null : eventHandlerProperties.getOnMouseDragEntered();
 7589     }
 7590 
 7591     /**
 7592      * Defines a function to be called when a full press-drag-release gesture
 7593      * enters this {@code Node}.
 7594      * @return the event handler that is called when a full press-drag-release
 7595      * gesture enters this {@code Node}
 7596      * @since JavaFX 2.1
 7597      */
 7598     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
 7599             onMouseDragEnteredProperty() {
 7600         return getEventHandlerProperties().onMouseDragEnteredProperty();
 7601     }
 7602 
 7603     public final void setOnMouseDragExited(
 7604             EventHandler&lt;? super MouseDragEvent&gt; value) {
 7605         onMouseDragExitedProperty().set(value);
 7606     }
 7607 
 7608     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragExited() {
 7609         return (eventHandlerProperties == null)
 7610                 ? null : eventHandlerProperties.getOnMouseDragExited();
 7611     }
 7612 
 7613     /**
 7614      * Defines a function to be called when a full press-drag-release gesture
 7615      * leaves this {@code Node}.
 7616      * @return the event handler that is called when a full press-drag-release
 7617      * gesture leaves this {@code Node}
 7618      * @since JavaFX 2.1
 7619      */
 7620     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
 7621             onMouseDragExitedProperty() {
 7622         return getEventHandlerProperties().onMouseDragExitedProperty();
 7623     }
 7624 
 7625 
 7626     /* *************************************************************************
 7627      *                                                                         *
 7628      *                           Gestures Handling                             *
 7629      *                                                                         *
 7630      **************************************************************************/
 7631 
 7632     public final void setOnScrollStarted(
 7633             EventHandler&lt;? super ScrollEvent&gt; value) {
 7634         onScrollStartedProperty().set(value);
 7635     }
 7636 
 7637     public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollStarted() {
 7638         return (eventHandlerProperties == null)
 7639                 ? null : eventHandlerProperties.getOnScrollStarted();
 7640     }
 7641 
 7642     /**
 7643      * Defines a function to be called when a scrolling gesture is detected.
 7644      * @return the event handler that is called when a scrolling gesture is
 7645      * detected
 7646      * @since JavaFX 2.2
 7647      */
 7648     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;
 7649             onScrollStartedProperty() {
 7650         return getEventHandlerProperties().onScrollStartedProperty();
 7651     }
 7652 
 7653     public final void setOnScroll(
 7654             EventHandler&lt;? super ScrollEvent&gt; value) {
 7655         onScrollProperty().set(value);
 7656     }
 7657 
 7658     public final EventHandler&lt;? super ScrollEvent&gt; getOnScroll() {
 7659         return (eventHandlerProperties == null)
 7660                 ? null : eventHandlerProperties.getOnScroll();
 7661     }
 7662 
 7663     /**
 7664      * Defines a function to be called when user performs a scrolling action.
 7665      * @return the event handler that is called when user performs a scrolling
 7666      * action
 7667      */
 7668     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;
 7669             onScrollProperty() {
 7670         return getEventHandlerProperties().onScrollProperty();
 7671     }
 7672 
 7673     public final void setOnScrollFinished(
 7674             EventHandler&lt;? super ScrollEvent&gt; value) {
 7675         onScrollFinishedProperty().set(value);
 7676     }
 7677 
 7678     public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollFinished() {
 7679         return (eventHandlerProperties == null)
 7680                 ? null : eventHandlerProperties.getOnScrollFinished();
 7681     }
 7682 
 7683     /**
 7684      * Defines a function to be called when a scrolling gesture ends.
 7685      * @return the event handler that is called when a scrolling gesture ends
 7686      * @since JavaFX 2.2
 7687      */
 7688     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;
 7689             onScrollFinishedProperty() {
 7690         return getEventHandlerProperties().onScrollFinishedProperty();
 7691     }
 7692 
 7693     public final void setOnRotationStarted(
 7694             EventHandler&lt;? super RotateEvent&gt; value) {
 7695         onRotationStartedProperty().set(value);
 7696     }
 7697 
 7698     public final EventHandler&lt;? super RotateEvent&gt; getOnRotationStarted() {
 7699         return (eventHandlerProperties == null)
 7700                 ? null : eventHandlerProperties.getOnRotationStarted();
 7701     }
 7702 
 7703     /**
 7704      * Defines a function to be called when a rotation gesture is detected.
 7705      * @return the event handler that is called when a rotation gesture is
 7706      * detected
 7707      * @since JavaFX 2.2
 7708      */
 7709     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt;
 7710             onRotationStartedProperty() {
 7711         return getEventHandlerProperties().onRotationStartedProperty();
 7712     }
 7713 
 7714     public final void setOnRotate(
 7715             EventHandler&lt;? super RotateEvent&gt; value) {
 7716         onRotateProperty().set(value);
 7717     }
 7718 
 7719     public final EventHandler&lt;? super RotateEvent&gt; getOnRotate() {
 7720         return (eventHandlerProperties == null)
 7721                 ? null : eventHandlerProperties.getOnRotate();
 7722     }
 7723 
 7724     /**
 7725      * Defines a function to be called when user performs a rotation action.
 7726      * @return the event handler that is called when user performs a rotation
 7727      * action
 7728      * @since JavaFX 2.2
 7729      */
 7730     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt;
 7731             onRotateProperty() {
 7732         return getEventHandlerProperties().onRotateProperty();
 7733     }
 7734 
 7735     public final void setOnRotationFinished(
 7736             EventHandler&lt;? super RotateEvent&gt; value) {
 7737         onRotationFinishedProperty().set(value);
 7738     }
 7739 
 7740     public final EventHandler&lt;? super RotateEvent&gt; getOnRotationFinished() {
 7741         return (eventHandlerProperties == null)
 7742                 ? null : eventHandlerProperties.getOnRotationFinished();
 7743     }
 7744 
 7745     /**
 7746      * Defines a function to be called when a rotation gesture ends.
 7747      * @return the event handler that is called when a rotation gesture ends
 7748      * @since JavaFX 2.2
 7749      */
 7750     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt;
 7751             onRotationFinishedProperty() {
 7752         return getEventHandlerProperties().onRotationFinishedProperty();
 7753     }
 7754 
 7755     public final void setOnZoomStarted(
 7756             EventHandler&lt;? super ZoomEvent&gt; value) {
 7757         onZoomStartedProperty().set(value);
 7758     }
 7759 
 7760     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomStarted() {
 7761         return (eventHandlerProperties == null)
 7762                 ? null : eventHandlerProperties.getOnZoomStarted();
 7763     }
 7764 
 7765     /**
 7766      * Defines a function to be called when a zooming gesture is detected.
 7767      * @return the event handler that is called when a zooming gesture is
 7768      * detected
 7769      * @since JavaFX 2.2
 7770      */
 7771     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;
 7772             onZoomStartedProperty() {
 7773         return getEventHandlerProperties().onZoomStartedProperty();
 7774     }
 7775 
 7776     public final void setOnZoom(
 7777             EventHandler&lt;? super ZoomEvent&gt; value) {
 7778         onZoomProperty().set(value);
 7779     }
 7780 
 7781     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoom() {
 7782         return (eventHandlerProperties == null)
 7783                 ? null : eventHandlerProperties.getOnZoom();
 7784     }
 7785 
 7786     /**
 7787      * Defines a function to be called when user performs a zooming action.
 7788      * @return the event handler that is called when user performs a zooming
 7789      * action
 7790      * @since JavaFX 2.2
 7791      */
 7792     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;
 7793             onZoomProperty() {
 7794         return getEventHandlerProperties().onZoomProperty();
 7795     }
 7796 
 7797     public final void setOnZoomFinished(
 7798             EventHandler&lt;? super ZoomEvent&gt; value) {
 7799         onZoomFinishedProperty().set(value);
 7800     }
 7801 
 7802     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomFinished() {
 7803         return (eventHandlerProperties == null)
 7804                 ? null : eventHandlerProperties.getOnZoomFinished();
 7805     }
 7806 
 7807     /**
 7808      * Defines a function to be called when a zooming gesture ends.
 7809      * @return the event handler that is called when a zooming gesture ends
 7810      * @since JavaFX 2.2
 7811      */
 7812     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;
 7813             onZoomFinishedProperty() {
 7814         return getEventHandlerProperties().onZoomFinishedProperty();
 7815     }
 7816 
 7817     public final void setOnSwipeUp(
 7818             EventHandler&lt;? super SwipeEvent&gt; value) {
 7819         onSwipeUpProperty().set(value);
 7820     }
 7821 
 7822     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeUp() {
 7823         return (eventHandlerProperties == null)
 7824                 ? null : eventHandlerProperties.getOnSwipeUp();
 7825     }
 7826 
 7827     /**
 7828      * Defines a function to be called when an upward swipe gesture
 7829      * centered over this node happens.
 7830      * @return the event handler that is called when an upward swipe gesture
 7831      * centered over this node happens
 7832      * @since JavaFX 2.2
 7833      */
 7834     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
 7835             onSwipeUpProperty() {
 7836         return getEventHandlerProperties().onSwipeUpProperty();
 7837     }
 7838 
 7839     public final void setOnSwipeDown(
 7840             EventHandler&lt;? super SwipeEvent&gt; value) {
 7841         onSwipeDownProperty().set(value);
 7842     }
 7843 
 7844     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeDown() {
 7845         return (eventHandlerProperties == null)
 7846                 ? null : eventHandlerProperties.getOnSwipeDown();
 7847     }
 7848 
 7849     /**
 7850      * Defines a function to be called when a downward swipe gesture
 7851      * centered over this node happens.
 7852      * @return the event handler that is called when a downward swipe gesture
 7853      * centered over this node happens
 7854      * @since JavaFX 2.2
 7855      */
 7856     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
 7857             onSwipeDownProperty() {
 7858         return getEventHandlerProperties().onSwipeDownProperty();
 7859     }
 7860 
 7861     public final void setOnSwipeLeft(
 7862             EventHandler&lt;? super SwipeEvent&gt; value) {
 7863         onSwipeLeftProperty().set(value);
 7864     }
 7865 
 7866     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeLeft() {
 7867         return (eventHandlerProperties == null)
 7868                 ? null : eventHandlerProperties.getOnSwipeLeft();
 7869     }
 7870 
 7871     /**
 7872      * Defines a function to be called when a leftward swipe gesture
 7873      * centered over this node happens.
 7874      * @return the event handler that is called when a leftward swipe gesture
 7875      * centered over this node happens
 7876      * @since JavaFX 2.2
 7877      */
 7878     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
 7879             onSwipeLeftProperty() {
 7880         return getEventHandlerProperties().onSwipeLeftProperty();
 7881     }
 7882 
 7883     public final void setOnSwipeRight(
 7884             EventHandler&lt;? super SwipeEvent&gt; value) {
 7885         onSwipeRightProperty().set(value);
 7886     }
 7887 
 7888     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeRight() {
 7889         return (eventHandlerProperties == null)
 7890                 ? null : eventHandlerProperties.getOnSwipeRight();
 7891     }
 7892 
 7893     /**
 7894      * Defines a function to be called when an rightward swipe gesture
 7895      * centered over this node happens.
 7896      * @return the event handler that is called when an rightward swipe gesture
 7897      * centered over this node happens
 7898      * @since JavaFX 2.2
 7899      */
 7900     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
 7901             onSwipeRightProperty() {
 7902         return getEventHandlerProperties().onSwipeRightProperty();
 7903     }
 7904 
 7905 
 7906     /* *************************************************************************
 7907      *                                                                         *
 7908      *                             Touch Handling                              *
 7909      *                                                                         *
 7910      **************************************************************************/
 7911 
 7912     public final void setOnTouchPressed(
 7913             EventHandler&lt;? super TouchEvent&gt; value) {
 7914         onTouchPressedProperty().set(value);
 7915     }
 7916 
 7917     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchPressed() {
 7918         return (eventHandlerProperties == null)
 7919                 ? null : eventHandlerProperties.getOnTouchPressed();
 7920     }
 7921 
 7922     /**
 7923      * Defines a function to be called when a new touch point is pressed.
 7924      * @return the event handler that is called when a new touch point is pressed
 7925      * @since JavaFX 2.2
 7926      */
 7927     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
 7928             onTouchPressedProperty() {
 7929         return getEventHandlerProperties().onTouchPressedProperty();
 7930     }
 7931 
 7932     public final void setOnTouchMoved(
 7933             EventHandler&lt;? super TouchEvent&gt; value) {
 7934         onTouchMovedProperty().set(value);
 7935     }
 7936 
 7937     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchMoved() {
 7938         return (eventHandlerProperties == null)
 7939                 ? null : eventHandlerProperties.getOnTouchMoved();
 7940     }
 7941 
 7942     /**
 7943      * Defines a function to be called when a touch point is moved.
 7944      * @return the event handler that is called when a touch point is moved
 7945      * @since JavaFX 2.2
 7946      */
 7947     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
 7948             onTouchMovedProperty() {
 7949         return getEventHandlerProperties().onTouchMovedProperty();
 7950     }
 7951 
 7952     public final void setOnTouchReleased(
 7953             EventHandler&lt;? super TouchEvent&gt; value) {
 7954         onTouchReleasedProperty().set(value);
 7955     }
 7956 
 7957     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchReleased() {
 7958         return (eventHandlerProperties == null)
 7959                 ? null : eventHandlerProperties.getOnTouchReleased();
 7960     }
 7961 
 7962     /**
 7963      * Defines a function to be called when a touch point is released.
 7964      * @return the event handler that is called when a touch point is released
 7965      * @since JavaFX 2.2
 7966      */
 7967     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
 7968             onTouchReleasedProperty() {
 7969         return getEventHandlerProperties().onTouchReleasedProperty();
 7970     }
 7971 
 7972     public final void setOnTouchStationary(
 7973             EventHandler&lt;? super TouchEvent&gt; value) {
 7974         onTouchStationaryProperty().set(value);
 7975     }
 7976 
 7977     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchStationary() {
 7978         return (eventHandlerProperties == null)
 7979                 ? null : eventHandlerProperties.getOnTouchStationary();
 7980     }
 7981 
 7982     /**
 7983      * Defines a function to be called when a touch point stays pressed and
 7984      * still.
 7985      * @return the event handler that is called when a touch point stays pressed
 7986      * and still
 7987      * @since JavaFX 2.2
 7988      */
 7989     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
 7990             onTouchStationaryProperty() {
 7991         return getEventHandlerProperties().onTouchStationaryProperty();
 7992     }
 7993 
 7994     /* *************************************************************************
 7995      *                                                                         *
 7996      *                           Keyboard Handling                             *
 7997      *                                                                         *
 7998      **************************************************************************/
 7999 
 8000     public final void setOnKeyPressed(
 8001             EventHandler&lt;? super KeyEvent&gt; value) {
 8002         onKeyPressedProperty().set(value);
 8003     }
 8004 
 8005     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyPressed() {
 8006         return (eventHandlerProperties == null)
 8007                 ? null : eventHandlerProperties.getOnKeyPressed();
 8008     }
 8009 
 8010     /**
 8011      * Defines a function to be called when this {@code Node} or its child
 8012      * {@code Node} has input focus and a key has been pressed. The function
 8013      * is called only if the event hasn&#39;t been already consumed during its
 8014      * capturing or bubbling phase.
 8015      * @return the event handler that is called when this {@code Node} or its
 8016      * child {@code Node} has input focus and a key has been pressed
 8017      */
 8018     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt;
 8019             onKeyPressedProperty() {
 8020         return getEventHandlerProperties().onKeyPressedProperty();
 8021     }
 8022 
 8023     public final void setOnKeyReleased(
 8024             EventHandler&lt;? super KeyEvent&gt; value) {
 8025         onKeyReleasedProperty().set(value);
 8026     }
 8027 
 8028     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyReleased() {
 8029         return (eventHandlerProperties == null)
 8030                 ? null : eventHandlerProperties.getOnKeyReleased();
 8031     }
 8032 
 8033     /**
 8034      * Defines a function to be called when this {@code Node} or its child
 8035      * {@code Node} has input focus and a key has been released. The function
 8036      * is called only if the event hasn&#39;t been already consumed during its
 8037      * capturing or bubbling phase.
 8038      * @return the event handler that is called when this {@code Node} or its
 8039      * child {@code Node} has input focus and a key has been released
 8040      */
 8041     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt;
 8042             onKeyReleasedProperty() {
 8043         return getEventHandlerProperties().onKeyReleasedProperty();
 8044     }
 8045 
 8046     public final void setOnKeyTyped(
 8047             EventHandler&lt;? super KeyEvent&gt; value) {
 8048         onKeyTypedProperty().set(value);
 8049     }
 8050 
 8051     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyTyped() {
 8052         return (eventHandlerProperties == null)
 8053                 ? null : eventHandlerProperties.getOnKeyTyped();
 8054     }
 8055 
 8056     /**
 8057      * Defines a function to be called when this {@code Node} or its child
 8058      * {@code Node} has input focus and a key has been typed. The function
 8059      * is called only if the event hasn&#39;t been already consumed during its
 8060      * capturing or bubbling phase.
 8061      * @return the event handler that is called when this {@code Node} or its
 8062      * child {@code Node} has input focus and a key has been typed
 8063      */
 8064     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt;
 8065             onKeyTypedProperty() {
 8066         return getEventHandlerProperties().onKeyTypedProperty();
 8067     }
 8068 
 8069     /* *************************************************************************
 8070      *                                                                         *
 8071      *                           Input Method Handling                         *
 8072      *                                                                         *
 8073      **************************************************************************/
 8074 
 8075     public final void setOnInputMethodTextChanged(
 8076             EventHandler&lt;? super InputMethodEvent&gt; value) {
 8077         onInputMethodTextChangedProperty().set(value);
 8078     }
 8079 
 8080     public final EventHandler&lt;? super InputMethodEvent&gt;
 8081             getOnInputMethodTextChanged() {
 8082         return (eventHandlerProperties == null)
 8083                 ? null : eventHandlerProperties.getOnInputMethodTextChanged();
 8084     }
 8085 
 8086     /**
 8087      * Defines a function to be called when this {@code Node}
 8088      * has input focus and the input method text has changed.  If this
 8089      * function is not defined in this {@code Node}, then it
 8090      * receives the result string of the input method composition as a
 8091      * series of {@code onKeyTyped} function calls.
 8092      * &lt;p&gt;
 8093      * When the {@code Node} loses the input focus, the JavaFX runtime
 8094      * automatically commits the existing composed text if any.
 8095      * &lt;/p&gt;
 8096      * @return the event handler that is called when this {@code Node} has input
 8097      * focus and the input method text has changed
 8098      */
 8099     public final ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt;
 8100             onInputMethodTextChangedProperty() {
 8101         return getEventHandlerProperties().onInputMethodTextChangedProperty();
 8102     }
 8103 
 8104     public final void setInputMethodRequests(InputMethodRequests value) {
 8105         inputMethodRequestsProperty().set(value);
 8106     }
 8107 
 8108     public final InputMethodRequests getInputMethodRequests() {
 8109         return (miscProperties == null)
 8110                        ? DEFAULT_INPUT_METHOD_REQUESTS
 8111                        : miscProperties.getInputMethodRequests();
 8112     }
 8113 
 8114     /**
 8115      * Property holding InputMethodRequests.
 8116      *
 8117      * @return InputMethodRequestsProperty
 8118      */
 8119     public final ObjectProperty&lt;InputMethodRequests&gt; inputMethodRequestsProperty() {
 8120         return getMiscProperties().inputMethodRequestsProperty();
 8121     }
 8122 
 8123     /***************************************************************************
 8124      *                                                                         *
 8125      *                             Focus Traversal                             *
 8126      *                                                                         *
 8127      **************************************************************************/
 8128 
 8129     /**
 8130      * Special boolean property which allows for atomic focus change.
 8131      * Focus change means defocusing the old focus owner and focusing a new
 8132      * one. With a usual property, defocusing the old node fires the value
 8133      * changed event and user code can react with something that breaks
 8134      * focusability of the new node, or even remove the new node from the scene.
 8135      * This leads to various error states. This property allows for setting
 8136      * the state without firing the event. The focus change first sets both
 8137      * properties and then fires both events. This makes the focus change look
 8138      * like an atomic operation - when the old node is notified to loose focus,
 8139      * the new node is already focused.
 8140      */
 8141     final class FocusedProperty extends ReadOnlyBooleanPropertyBase {
 8142         private boolean value;
 8143         private boolean valid = true;
 8144         private boolean needsChangeEvent = false;
 8145 
 8146         public void store(final boolean value) {
 8147             if (value != this.value) {
 8148                 this.value = value;
 8149                 markInvalid();
 8150             }
 8151         }
 8152 
 8153         public void notifyListeners() {
 8154             if (needsChangeEvent) {
 8155                 fireValueChangedEvent();
 8156                 needsChangeEvent = false;
 8157             }
 8158         }
 8159 
 8160         private void markInvalid() {
 8161             if (valid) {
 8162                 valid = false;
 8163 
 8164                 pseudoClassStateChanged(FOCUSED_PSEUDOCLASS_STATE, get());
 8165                 PlatformLogger logger = Logging.getFocusLogger();
 8166                 if (logger.isLoggable(Level.FINE)) {
 8167                     logger.fine(this + &quot; focused=&quot; + get());
 8168                 }
 8169 
 8170                 needsChangeEvent = true;
 8171 
 8172                 notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUSED);
 8173             }
 8174         }
 8175 
 8176         @Override
 8177         public boolean get() {
 8178             valid = true;
 8179             return value;
 8180         }
 8181 
 8182         @Override
 8183         public Object getBean() {
 8184             return Node.this;
 8185         }
 8186 
 8187         @Override
 8188         public String getName() {
 8189             return &quot;focused&quot;;
 8190         }
 8191     }
 8192 
 8193     /**
 8194      * Indicates whether this {@code Node} currently has the input focus.
 8195      * To have the input focus, a node must be the {@code Scene}&#39;s focus
 8196      * owner, and the scene must be in a {@code Stage} that is visible
 8197      * and active. See {@link #requestFocus()} for more information.
 8198      *
 8199      * @see #requestFocus()
 8200      * @defaultValue false
 8201      */
 8202     private FocusedProperty focused;
 8203 
 8204     protected final void setFocused(boolean value) {
 8205         FocusedProperty fp = focusedPropertyImpl();
 8206         if (fp.value != value) {
 8207             fp.store(value);
 8208             fp.notifyListeners();
 8209         }
 8210     }
 8211 
 8212     public final boolean isFocused() {
 8213         return focused == null ? false : focused.get();
 8214     }
 8215 
 8216     public final ReadOnlyBooleanProperty focusedProperty() {
 8217         return focusedPropertyImpl();
 8218     }
 8219 
 8220     private FocusedProperty focusedPropertyImpl() {
 8221         if (focused == null) {
 8222             focused = new FocusedProperty();
 8223         }
 8224         return focused;
 8225     }
 8226 
 8227     /**
 8228      * Specifies whether this {@code Node} should be a part of focus traversal
 8229      * cycle. When this property is {@code true} focus can be moved to this
 8230      * {@code Node} and from this {@code Node} using regular focus traversal
 8231      * keys. On a desktop such keys are usually {@code TAB} for moving focus
 8232      * forward and {@code SHIFT+TAB} for moving focus backward.
 8233      *
 8234      * When a {@code Scene} is created, the system gives focus to a
 8235      * {@code Node} whose {@code focusTraversable} variable is true
 8236      * and that is eligible to receive the focus,
 8237      * unless the focus had been set explicitly via a call
 8238      * to {@link #requestFocus()}.
 8239      *
 8240      * @see #requestFocus()
 8241      * @defaultValue false
 8242      */
 8243     private BooleanProperty focusTraversable;
 8244 
 8245     public final void setFocusTraversable(boolean value) {
 8246         focusTraversableProperty().set(value);
 8247     }
 8248     public final boolean isFocusTraversable() {
 8249         return focusTraversable == null ? false : focusTraversable.get();
 8250     }
 8251 
 8252     public final BooleanProperty focusTraversableProperty() {
 8253         if (focusTraversable == null) {
 8254             focusTraversable = new StyleableBooleanProperty(false) {
 8255 
 8256                 @Override
 8257                 public void invalidated() {
 8258                     Scene _scene = getScene();
 8259                     if (_scene != null) {
 8260                         if (get()) {
 8261                             _scene.initializeInternalEventDispatcher();
 8262                         }
 8263                         focusSetDirty(_scene);
 8264                     }
 8265                 }
 8266 
 8267                 @Override
 8268                 public CssMetaData getCssMetaData() {
 8269                     return StyleableProperties.FOCUS_TRAVERSABLE;
 8270                 }
 8271 
 8272                 @Override
 8273                 public Object getBean() {
 8274                     return Node.this;
 8275                 }
 8276 
 8277                 @Override
 8278                 public String getName() {
 8279                     return &quot;focusTraversable&quot;;
 8280                 }
 8281             };
 8282         }
 8283         return focusTraversable;
 8284     }
 8285 
 8286     /**
 8287      * Called when something has changed on this node that *may* have made the
 8288      * scene&#39;s focus dirty. This covers the cases where this node is the focus
 8289      * owner and it may have lost eligibility, or it&#39;s traversable and it may
 8290      * have gained eligibility. Note that we do not want to use disabled
 8291      * or treeVisible here, as this function is called from their
 8292      * &quot;on invalidate&quot; triggers, and using them will cause them to be
 8293      * revalidated. The pulse will revalidate everything and make the final
 8294      * determination.
 8295      */
 8296     private void focusSetDirty(Scene s) {
 8297         if (s != null &amp;&amp;
 8298             (this == s.getFocusOwner() || isFocusTraversable())) {
 8299                 s.setFocusDirty(true);
 8300         }
 8301     }
 8302 
 8303     /**
 8304      * Requests that this {@code Node} get the input focus, and that this
 8305      * {@code Node}&#39;s top-level ancestor become the focused window. To be
 8306      * eligible to receive the focus, the node must be part of a scene, it and
 8307      * all of its ancestors must be visible, and it must not be disabled.
 8308      * If this node is eligible, this function will cause it to become this
 8309      * {@code Scene}&#39;s &quot;focus owner&quot;. Each scene has at most one focus owner
 8310      * node. The focus owner will not actually have the input focus, however,
 8311      * unless the scene belongs to a {@code Stage} that is both visible
 8312      * and active.
 8313      */
 8314     public void requestFocus() {
 8315         if (getScene() != null) {
 8316             getScene().requestFocus(this);
 8317         }
 8318     }
 8319 
 8320     /**
 8321      * Traverses from this node in the direction indicated. Note that this
 8322      * node need not actually have the focus, nor need it be focusTraversable.
 8323      * However, the node must be part of a scene, otherwise this request
 8324      * is ignored.
 8325      */
 8326     final boolean traverse(Direction dir) {
 8327         if (getScene() == null) {
 8328             return false;
 8329         }
 8330         return getScene().traverse(this, dir);
 8331     }
 8332 
 8333     ////////////////////////////
 8334     //  Private Implementation
 8335     ////////////////////////////
 8336 
 8337      /**
 8338       * Returns a string representation for the object.
 8339       * @return a string representation for the object.
 8340       */
 8341     @Override
 8342     public String toString() {
 8343         String klassName = getClass().getName();
 8344         String simpleName = klassName.substring(klassName.lastIndexOf(&#39;.&#39;)+1);
 8345         StringBuilder sbuf = new StringBuilder(simpleName);
 8346         boolean hasId = id != null &amp;&amp; !&quot;&quot;.equals(getId());
 8347         boolean hasStyleClass = !getStyleClass().isEmpty();
 8348 
 8349         if (!hasId) {
 8350             sbuf.append(&#39;@&#39;);
 8351             sbuf.append(Integer.toHexString(hashCode()));
 8352         } else {
 8353             sbuf.append(&quot;[id=&quot;);
 8354             sbuf.append(getId());
 8355             if (!hasStyleClass) sbuf.append(&quot;]&quot;);
 8356         }
 8357         if (hasStyleClass) {
 8358             if (!hasId) sbuf.append(&#39;[&#39;);
 8359             else sbuf.append(&quot;, &quot;);
 8360             sbuf.append(&quot;styleClass=&quot;);
 8361             sbuf.append(getStyleClass());
 8362             sbuf.append(&quot;]&quot;);
 8363         }
 8364         return sbuf.toString();
 8365     }
 8366 
 8367     private void preprocessMouseEvent(MouseEvent e) {
 8368         final EventType&lt;?&gt; eventType = e.getEventType();
 8369         if (eventType == MouseEvent.MOUSE_PRESSED) {
 8370             for (Node n = this; n != null; n = n.getParent()) {
 8371                 n.setPressed(e.isPrimaryButtonDown());
 8372             }
 8373             return;
 8374         }
 8375         if (eventType == MouseEvent.MOUSE_RELEASED) {
 8376             for (Node n = this; n != null; n = n.getParent()) {
 8377                 n.setPressed(e.isPrimaryButtonDown());
 8378             }
 8379             return;
 8380         }
 8381 
 8382         if (e.getTarget() == this) {
 8383             // the mouse event types are translated only when the node uses
 8384             // its internal event dispatcher, so both entered / exited variants
 8385             // are possible here
 8386 
 8387             if ((eventType == MouseEvent.MOUSE_ENTERED)
 8388                     || (eventType == MouseEvent.MOUSE_ENTERED_TARGET)) {
 8389                 setHover(true);
 8390                 return;
 8391             }
 8392 
 8393             if ((eventType == MouseEvent.MOUSE_EXITED)
 8394                     || (eventType == MouseEvent.MOUSE_EXITED_TARGET)) {
 8395                 setHover(false);
 8396                 return;
 8397             }
 8398         }
 8399     }
 8400 
 8401     void markDirtyLayoutBranch() {
 8402         Parent p = getParent();
 8403         while (p != null &amp;&amp; p.layoutFlag == LayoutFlags.CLEAN) {
 8404             p.setLayoutFlag(LayoutFlags.DIRTY_BRANCH);
 8405             if (p.isSceneRoot()) {
 8406                 Toolkit.getToolkit().requestNextPulse();
 8407                 if (getSubScene() != null) {
 8408                     getSubScene().setDirtyLayout(p);
 8409                 }
 8410             }
 8411             p = p.getParent();
 8412         }
 8413 
 8414     }
 8415 
 8416     private boolean isWindowShowing() {
 8417         Scene s = getScene();
 8418         if (s == null) return false;
 8419         Window w = s.getWindow();
 8420         return w != null &amp;&amp; w.isShowing();
 8421     }
 8422 
 8423     private void updateTreeShowing() {
 8424         setTreeShowing(isTreeVisible() &amp;&amp; isWindowShowing());
 8425     }
 8426 
 8427     private boolean treeShowing;
 8428     private TreeShowingPropertyReadOnly treeShowingRO;
 8429 
 8430     final void setTreeShowing(boolean value) {
 8431         if (treeShowing != value) {
 8432             treeShowing = value;
 8433             ((TreeShowingPropertyReadOnly) treeShowingProperty()).invalidate();
 8434         }
 8435     }
 8436 
 8437     final boolean isTreeShowing() {
 8438         return treeShowingProperty().get();
 8439     }
 8440 
 8441     final BooleanExpression treeShowingProperty() {
 8442         if (treeShowingRO == null) {
 8443             treeShowingRO = new TreeShowingPropertyReadOnly();
 8444         }
 8445         return treeShowingRO;
 8446     }
 8447 
 8448     class TreeShowingPropertyReadOnly extends BooleanExpression {
 8449 
 8450         private ExpressionHelper&lt;Boolean&gt; helper;
 8451         private boolean valid;
 8452 
 8453         @Override
 8454         public void addListener(InvalidationListener listener) {
 8455             helper = ExpressionHelper.addListener(helper, this, listener);
 8456         }
 8457 
 8458         @Override
 8459         public void removeListener(InvalidationListener listener) {
 8460             helper = ExpressionHelper.removeListener(helper, listener);
 8461         }
 8462 
 8463         @Override
 8464         public void addListener(ChangeListener&lt;? super Boolean&gt; listener) {
 8465             helper = ExpressionHelper.addListener(helper, this, listener);
 8466         }
 8467 
 8468         @Override
 8469         public void removeListener(ChangeListener&lt;? super Boolean&gt; listener) {
 8470             helper = ExpressionHelper.removeListener(helper, listener);
 8471         }
 8472 
 8473         protected void invalidate() {
 8474             if (valid) {
 8475                 valid = false;
 8476                 ExpressionHelper.fireValueChangedEvent(helper);
 8477             }
 8478         }
 8479 
 8480         @Override
 8481         public boolean get() {
 8482             valid = true;
 8483             return Node.this.treeShowing;
 8484         }
 8485 
 8486     }
 8487 
 8488     private void updateTreeVisible(boolean parentChanged) {
 8489         boolean isTreeVisible = isVisible();
 8490         final Node parentNode = getParent() != null ? getParent() :
 8491                     clipParent != null ? clipParent :
 8492                     getSubScene() != null ? getSubScene() : null;
 8493         if (isTreeVisible) {
 8494             isTreeVisible = parentNode == null || parentNode.isTreeVisible();
 8495         }
 8496         // When the parent has changed to visible and we have unsynchronized visibility,
 8497         // we have to synchronize, because the rendering will now pass through the newly-visible parent
 8498         // Otherwise an invisible Node might get rendered
 8499         if (parentChanged &amp;&amp; parentNode != null &amp;&amp; parentNode.isTreeVisible()
 8500                 &amp;&amp; isDirty(DirtyBits.NODE_VISIBLE)) {
 8501             addToSceneDirtyList();
 8502         }
 8503         setTreeVisible(isTreeVisible);
 8504 
 8505         updateTreeShowing();
 8506     }
 8507 
 8508     private boolean treeVisible;
 8509     private TreeVisiblePropertyReadOnly treeVisibleRO;
 8510 
 8511     final void setTreeVisible(boolean value) {
 8512         if (treeVisible != value) {
 8513             treeVisible = value;
 8514             updateCanReceiveFocus();
 8515             focusSetDirty(getScene());
 8516             if (getClip() != null) {
 8517                 getClip().updateTreeVisible(true);
 8518             }
 8519             if (treeVisible &amp;&amp; !isDirtyEmpty()) {
 8520                 addToSceneDirtyList();
 8521             }
 8522             ((TreeVisiblePropertyReadOnly) treeVisibleProperty()).invalidate();
 8523             if (Node.this instanceof SubScene) {
 8524                 Node subSceneRoot = ((SubScene)Node.this).getRoot();
 8525                 if (subSceneRoot != null) {
 8526                     // SubScene.getRoot() is only null if it&#39;s constructor
 8527                     // has not finished.
 8528                     subSceneRoot.setTreeVisible(value &amp;&amp; subSceneRoot.isVisible());
 8529                 }
 8530             }
 8531         }
 8532     }
 8533 
 8534     final boolean isTreeVisible() {
 8535         return treeVisibleProperty().get();
 8536     }
 8537 
 8538     final BooleanExpression treeVisibleProperty() {
 8539         if (treeVisibleRO == null) {
 8540             treeVisibleRO = new TreeVisiblePropertyReadOnly();
 8541         }
 8542         return treeVisibleRO;
 8543     }
 8544 
 8545     class TreeVisiblePropertyReadOnly extends BooleanExpression {
 8546 
 8547         private ExpressionHelper&lt;Boolean&gt; helper;
 8548         private boolean valid;
 8549 
 8550         @Override
 8551         public void addListener(InvalidationListener listener) {
 8552             helper = ExpressionHelper.addListener(helper, this, listener);
 8553         }
 8554 
 8555         @Override
 8556         public void removeListener(InvalidationListener listener) {
 8557             helper = ExpressionHelper.removeListener(helper, listener);
 8558         }
 8559 
 8560         @Override
 8561         public void addListener(ChangeListener&lt;? super Boolean&gt; listener) {
 8562             helper = ExpressionHelper.addListener(helper, this, listener);
 8563         }
 8564 
 8565         @Override
 8566         public void removeListener(ChangeListener&lt;? super Boolean&gt; listener) {
 8567             helper = ExpressionHelper.removeListener(helper, listener);
 8568         }
 8569 
 8570         protected void invalidate() {
 8571             if (valid) {
 8572                 valid = false;
 8573                 ExpressionHelper.fireValueChangedEvent(helper);
 8574             }
 8575         }
 8576 
 8577         @Override
 8578         public boolean get() {
 8579             valid = true;
 8580             return Node.this.treeVisible;
 8581         }
 8582 
 8583     }
 8584 
 8585     private boolean canReceiveFocus = false;
 8586 
 8587     private void setCanReceiveFocus(boolean value) {
 8588         canReceiveFocus = value;
 8589     }
 8590 
 8591     final boolean isCanReceiveFocus() {
 8592         return canReceiveFocus;
 8593     }
 8594 
 8595     private void updateCanReceiveFocus() {
 8596         setCanReceiveFocus(getScene() != null
 8597           &amp;&amp; !isDisabled()
 8598           &amp;&amp; isTreeVisible());
 8599     }
 8600 
 8601     // for indenting messages based on scene-graph depth
 8602     String indent() {
 8603         String indent = &quot;&quot;;
 8604         Parent p = this.getParent();
 8605         while (p != null) {
 8606             indent += &quot;  &quot;;
 8607             p = p.getParent();
 8608         }
 8609         return indent;
 8610     }
 8611 
 8612     /*
 8613      * Should we underline the mnemonic character?
 8614      */
 8615     private BooleanProperty showMnemonics;
 8616 
 8617     final void setShowMnemonics(boolean value) {
 8618         showMnemonicsProperty().set(value);
 8619     }
 8620 
 8621     final boolean isShowMnemonics() {
 8622         return showMnemonics == null ? false : showMnemonics.get();
 8623     }
 8624 
 8625     final BooleanProperty showMnemonicsProperty() {
 8626         if (showMnemonics == null) {
 8627             showMnemonics = new BooleanPropertyBase(false) {
 8628 
 8629                 @Override
 8630                 protected void invalidated() {
 8631                     pseudoClassStateChanged(SHOW_MNEMONICS_PSEUDOCLASS_STATE, get());
 8632                 }
 8633 
 8634                 @Override
 8635                 public Object getBean() {
 8636                     return Node.this;
 8637                 }
 8638 
 8639                 @Override
 8640                 public String getName() {
 8641                     return &quot;showMnemonics&quot;;
 8642                 }
 8643             };
 8644         }
 8645         return showMnemonics;
 8646     }
 8647 
 8648 
 8649     /**
 8650      * References a node that is a labelFor this node.
 8651      * Accessible via a NodeAccessor. See Label.labelFor for details.
 8652      */
 8653     private Node labeledBy = null;
 8654 
 8655 
 8656     /***************************************************************************
 8657      *                                                                         *
 8658      *                         Event Dispatch                                  *
 8659      *                                                                         *
 8660      **************************************************************************/
 8661 
 8662     // PENDING_DOC_REVIEW
 8663     /**
 8664      * Specifies the event dispatcher for this node. The default event
 8665      * dispatcher sends the received events to the registered event handlers and
 8666      * filters. When replacing the value with a new {@code EventDispatcher},
 8667      * the new dispatcher should forward events to the replaced dispatcher
 8668      * to maintain the node&#39;s default event handling behavior.
 8669      */
 8670     private ObjectProperty&lt;EventDispatcher&gt; eventDispatcher;
 8671 
 8672     public final void setEventDispatcher(EventDispatcher value) {
 8673         eventDispatcherProperty().set(value);
 8674     }
 8675 
 8676     public final EventDispatcher getEventDispatcher() {
 8677         return eventDispatcherProperty().get();
 8678     }
 8679 
 8680     public final ObjectProperty&lt;EventDispatcher&gt; eventDispatcherProperty() {
 8681         initializeInternalEventDispatcher();
 8682         return eventDispatcher;
 8683     }
 8684 
 8685     private NodeEventDispatcher internalEventDispatcher;
 8686 
 8687     // PENDING_DOC_REVIEW
 8688     /**
 8689      * Registers an event handler to this node. The handler is called when the
 8690      * node receives an {@code Event} of the specified type during the bubbling
 8691      * phase of event delivery.
 8692      *
 8693      * @param &lt;T&gt; the specific event class of the handler
 8694      * @param eventType the type of the events to receive by the handler
 8695      * @param eventHandler the handler to register
 8696      * @throws NullPointerException if the event type or handler is null
 8697      */
 8698     public final &lt;T extends Event&gt; void addEventHandler(
 8699             final EventType&lt;T&gt; eventType,
 8700             final EventHandler&lt;? super T&gt; eventHandler) {
 8701         getInternalEventDispatcher().getEventHandlerManager()
 8702                                     .addEventHandler(eventType, eventHandler);
 8703     }
 8704 
 8705     // PENDING_DOC_REVIEW
 8706     /**
 8707      * Unregisters a previously registered event handler from this node. One
 8708      * handler might have been registered for different event types, so the
 8709      * caller needs to specify the particular event type from which to
 8710      * unregister the handler.
 8711      *
 8712      * @param &lt;T&gt; the specific event class of the handler
 8713      * @param eventType the event type from which to unregister
 8714      * @param eventHandler the handler to unregister
 8715      * @throws NullPointerException if the event type or handler is null
 8716      */
 8717     public final &lt;T extends Event&gt; void removeEventHandler(
 8718             final EventType&lt;T&gt; eventType,
 8719             final EventHandler&lt;? super T&gt; eventHandler) {
 8720         getInternalEventDispatcher()
 8721                 .getEventHandlerManager()
 8722                 .removeEventHandler(eventType, eventHandler);
 8723     }
 8724 
 8725     // PENDING_DOC_REVIEW
 8726     /**
 8727      * Registers an event filter to this node. The filter is called when the
 8728      * node receives an {@code Event} of the specified type during the capturing
 8729      * phase of event delivery.
 8730      *
 8731      * @param &lt;T&gt; the specific event class of the filter
 8732      * @param eventType the type of the events to receive by the filter
 8733      * @param eventFilter the filter to register
 8734      * @throws NullPointerException if the event type or filter is null
 8735      */
 8736     public final &lt;T extends Event&gt; void addEventFilter(
 8737             final EventType&lt;T&gt; eventType,
 8738             final EventHandler&lt;? super T&gt; eventFilter) {
 8739         getInternalEventDispatcher().getEventHandlerManager()
 8740                                     .addEventFilter(eventType, eventFilter);
 8741     }
 8742 
 8743     // PENDING_DOC_REVIEW
 8744     /**
 8745      * Unregisters a previously registered event filter from this node. One
 8746      * filter might have been registered for different event types, so the
 8747      * caller needs to specify the particular event type from which to
 8748      * unregister the filter.
 8749      *
 8750      * @param &lt;T&gt; the specific event class of the filter
 8751      * @param eventType the event type from which to unregister
 8752      * @param eventFilter the filter to unregister
 8753      * @throws NullPointerException if the event type or filter is null
 8754      */
 8755     public final &lt;T extends Event&gt; void removeEventFilter(
 8756             final EventType&lt;T&gt; eventType,
 8757             final EventHandler&lt;? super T&gt; eventFilter) {
 8758         getInternalEventDispatcher().getEventHandlerManager()
 8759                                     .removeEventFilter(eventType, eventFilter);
 8760     }
 8761 
 8762     /**
 8763      * Sets the handler to use for this event type. There can only be one such handler
 8764      * specified at a time. This handler is guaranteed to be called as the last, after
 8765      * handlers added using {@link #addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}.
 8766      * This is used for registering the user-defined onFoo event handlers.
 8767      *
 8768      * @param &lt;T&gt; the specific event class of the handler
 8769      * @param eventType the event type to associate with the given eventHandler
 8770      * @param eventHandler the handler to register, or null to unregister
 8771      * @throws NullPointerException if the event type is null
 8772      */
 8773     protected final &lt;T extends Event&gt; void setEventHandler(
 8774             final EventType&lt;T&gt; eventType,
 8775             final EventHandler&lt;? super T&gt; eventHandler) {
 8776         getInternalEventDispatcher().getEventHandlerManager()
 8777                                     .setEventHandler(eventType, eventHandler);
 8778     }
 8779 
 8780     private NodeEventDispatcher getInternalEventDispatcher() {
 8781         initializeInternalEventDispatcher();
 8782         return internalEventDispatcher;
 8783     }
 8784 
 8785     private void initializeInternalEventDispatcher() {
 8786         if (internalEventDispatcher == null) {
 8787             internalEventDispatcher = createInternalEventDispatcher();
 8788             eventDispatcher = new SimpleObjectProperty&lt;EventDispatcher&gt;(
 8789                                           Node.this,
 8790                                           &quot;eventDispatcher&quot;,
 8791                                           internalEventDispatcher);
 8792         }
 8793     }
 8794 
 8795     private NodeEventDispatcher createInternalEventDispatcher() {
 8796         return new NodeEventDispatcher(this);
 8797     }
 8798 
 8799     /**
 8800      * Event dispatcher for invoking preprocessing of mouse events
 8801      */
 8802     private EventDispatcher preprocessMouseEventDispatcher;
 8803 
 8804     // PENDING_DOC_REVIEW
 8805     /**
 8806      * Construct an event dispatch chain for this node. The event dispatch chain
 8807      * contains all event dispatchers from the stage to this node.
 8808      *
 8809      * @param tail the initial chain to build from
 8810      * @return the resulting event dispatch chain for this node
 8811      */
 8812     @Override
 8813     public EventDispatchChain buildEventDispatchChain(
 8814             EventDispatchChain tail) {
 8815 
 8816         if (preprocessMouseEventDispatcher == null) {
 8817             preprocessMouseEventDispatcher = (event, tail1) -&gt; {
 8818                 event = tail1.dispatchEvent(event);
 8819                 if (event instanceof MouseEvent) {
 8820                     preprocessMouseEvent((MouseEvent) event);
 8821                 }
 8822 
 8823                 return event;
 8824             };
 8825         }
 8826 
 8827         tail = tail.prepend(preprocessMouseEventDispatcher);
 8828 
 8829         // prepend all event dispatchers from this node to the root
 8830         Node curNode = this;
 8831         do {
 8832             if (curNode.eventDispatcher != null) {
 8833                 final EventDispatcher eventDispatcherValue =
 8834                         curNode.eventDispatcher.get();
 8835                 if (eventDispatcherValue != null) {
 8836                     tail = tail.prepend(eventDispatcherValue);
 8837                 }
 8838             }
 8839             final Node curParent = curNode.getParent();
 8840             curNode = curParent != null ? curParent : curNode.getSubScene();
 8841         } while (curNode != null);
 8842 
 8843         if (getScene() != null) {
 8844             // prepend scene&#39;s dispatch chain
 8845             tail = getScene().buildEventDispatchChain(tail);
 8846         }
 8847 
 8848         return tail;
 8849     }
 8850 
 8851     // PENDING_DOC_REVIEW
 8852     /**
 8853      * Fires the specified event. By default the event will travel through the
 8854      * hierarchy from the stage to this node. Any event filter encountered will
 8855      * be notified and can consume the event. If not consumed by the filters,
 8856      * the event handlers on this node are notified. If these don&#39;t consume the
 8857      * event either, the event will travel back the same path it arrived to
 8858      * this node. All event handlers encountered are called and can consume the
 8859      * event.
 8860      * &lt;p&gt;
 8861      * This method must be called on the FX user thread.
 8862      *
 8863      * @param event the event to fire
 8864      */
 8865     public final void fireEvent(Event event) {
 8866 
 8867         /* Log input events.  We do a coarse filter for at least the FINE
 8868          * level and then granularize from there.
 8869          */
 8870         if (event instanceof InputEvent) {
 8871             PlatformLogger logger = Logging.getInputLogger();
 8872             if (logger.isLoggable(Level.FINE)) {
 8873                 EventType eventType = event.getEventType();
 8874                 if (eventType == MouseEvent.MOUSE_ENTERED ||
 8875                     eventType == MouseEvent.MOUSE_EXITED) {
 8876                     logger.finer(event.toString());
 8877                 } else if (eventType == MouseEvent.MOUSE_MOVED ||
 8878                            eventType == MouseEvent.MOUSE_DRAGGED) {
 8879                     logger.finest(event.toString());
 8880                 } else {
 8881                     logger.fine(event.toString());
 8882                 }
 8883             }
 8884         }
 8885 
 8886         Event.fireEvent(this, event);
 8887     }
 8888 
 8889     /***************************************************************************
 8890      *                                                                         *
 8891      *                         Stylesheet Handling                             *
 8892      *                                                                         *
 8893      **************************************************************************/
 8894 
 8895 
 8896     /**
 8897      * {@inheritDoc}
 8898      * @return {@code getClass().getName()} without the package name
 8899      * @since JavaFX 8.0
 8900      */
 8901     @Override
 8902     public String getTypeSelector() {
 8903 
 8904         final Class&lt;?&gt; clazz = getClass();
 8905         final Package pkg = clazz.getPackage();
 8906 
 8907         // package could be null. not likely, but could be.
 8908         int plen = 0;
 8909         if (pkg != null) {
 8910             plen = pkg.getName().length();
 8911         }
 8912 
 8913         final int clen = clazz.getName().length();
 8914         final int pos = (0 &lt; plen &amp;&amp; plen &lt; clen) ? plen + 1 : 0;
 8915 
 8916         return clazz.getName().substring(pos);
 8917     }
 8918 
 8919     /**
 8920      * {@inheritDoc}
 8921      * @return {@code getParent()}
 8922      * @since JavaFX 8.0
 8923      */
 8924     @Override
 8925     public Styleable getStyleableParent() {
 8926         return getParent();
 8927     }
 8928 
 8929 
 8930     /**
 8931      * Returns the initial focus traversable state of this node, for use
 8932      * by the JavaFX CSS engine to correctly set its initial value. This method
 8933      * can be overridden by subclasses in instances where focus traversable should
 8934      * initially be true (as the default implementation of this method is to return
 8935      * false).
 8936      *
 8937      * @return the initial focus traversable state for this {@code Node}.
 8938      * @since 9
 8939      */
 8940     protected Boolean getInitialFocusTraversable() {
 8941         return Boolean.FALSE;
 8942     }
 8943 
 8944     /**
 8945      * Returns the initial cursor state of this node, for use
 8946      * by the JavaFX CSS engine to correctly set its initial value. This method
 8947      * can be overridden by subclasses in instances where the cursor should
 8948      * initially be non-null (as the default implementation of this method is to return
 8949      * null).
 8950      *
 8951      * @return the initial cursor state for this {@code Node}.
 8952      * @since 9
 8953      */
 8954     protected Cursor getInitialCursor() {
 8955         return null;
 8956     }
 8957 
 8958      /**
 8959       * Super-lazy instantiation pattern from Bill Pugh.
 8960       */
 8961      private static class StyleableProperties {
 8962 
 8963         private static final CssMetaData&lt;Node,Cursor&gt; CURSOR =
 8964             new CssMetaData&lt;Node,Cursor&gt;(&quot;-fx-cursor&quot;, CursorConverter.getInstance()) {
 8965 
 8966                 @Override
 8967                 public boolean isSettable(Node node) {
 8968                     return node.miscProperties == null || node.miscProperties.canSetCursor();
 8969                 }
 8970 
 8971                 @Override
 8972                 public StyleableProperty&lt;Cursor&gt; getStyleableProperty(Node node) {
 8973                     return (StyleableProperty&lt;Cursor&gt;)node.cursorProperty();
 8974                 }
 8975 
 8976                 @Override
 8977                 public Cursor getInitialValue(Node node) {
 8978                     // Most controls default focusTraversable to true.
 8979                     // Give a way to have them return the correct default value.
 8980                     return node.getInitialCursor();
 8981                 }
 8982 
 8983             };
 8984         private static final CssMetaData&lt;Node,Effect&gt; EFFECT =
 8985             new CssMetaData&lt;Node,Effect&gt;(&quot;-fx-effect&quot;, EffectConverter.getInstance()) {
 8986 
 8987                 @Override
 8988                 public boolean isSettable(Node node) {
 8989                     return node.miscProperties == null || node.miscProperties.canSetEffect();
 8990                 }
 8991 
 8992                 @Override
 8993                 public StyleableProperty&lt;Effect&gt; getStyleableProperty(Node node) {
 8994                     return (StyleableProperty&lt;Effect&gt;)node.effectProperty();
 8995                 }
 8996             };
 8997         private static final CssMetaData&lt;Node,Boolean&gt; FOCUS_TRAVERSABLE =
 8998             new CssMetaData&lt;Node,Boolean&gt;(&quot;-fx-focus-traversable&quot;,
 8999                 BooleanConverter.getInstance(), Boolean.FALSE) {
 9000 
 9001                 @Override
 9002                 public boolean isSettable(Node node) {
 9003                     return node.focusTraversable == null || !node.focusTraversable.isBound();
 9004                 }
 9005 
 9006                 @Override
 9007                 public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Node node) {
 9008                     return (StyleableProperty&lt;Boolean&gt;)node.focusTraversableProperty();
 9009                 }
 9010 
 9011                 @Override
 9012                 public Boolean getInitialValue(Node node) {
 9013                     // Most controls default focusTraversable to true.
 9014                     // Give a way to have them return the correct default value.
 9015                     return node.getInitialFocusTraversable();
 9016                 }
 9017 
 9018             };
 9019         private static final CssMetaData&lt;Node,Number&gt; OPACITY =
 9020             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-opacity&quot;,
 9021                 SizeConverter.getInstance(), 1.0) {
 9022 
 9023                 @Override
 9024                 public boolean isSettable(Node node) {
 9025                     return node.opacity == null || !node.opacity.isBound();
 9026                 }
 9027 
 9028                 @Override
 9029                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9030                     return (StyleableProperty&lt;Number&gt;)node.opacityProperty();
 9031                 }
 9032             };
 9033         private static final CssMetaData&lt;Node,BlendMode&gt; BLEND_MODE =
 9034             new CssMetaData&lt;Node,BlendMode&gt;(&quot;-fx-blend-mode&quot;, new EnumConverter&lt;BlendMode&gt;(BlendMode.class)) {
 9035 
 9036                 @Override
 9037                 public boolean isSettable(Node node) {
 9038                     return node.blendMode == null || !node.blendMode.isBound();
 9039                 }
 9040 
 9041                 @Override
 9042                 public StyleableProperty&lt;BlendMode&gt; getStyleableProperty(Node node) {
 9043                     return (StyleableProperty&lt;BlendMode&gt;)node.blendModeProperty();
 9044                 }
 9045             };
 9046         private static final CssMetaData&lt;Node,Number&gt; ROTATE =
 9047             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-rotate&quot;,
 9048                 SizeConverter.getInstance(), 0.0) {
 9049 
 9050                 @Override
 9051                 public boolean isSettable(Node node) {
 9052                     return node.nodeTransformation == null
 9053                         || node.nodeTransformation.rotate == null
 9054                         || node.nodeTransformation.canSetRotate();
 9055                 }
 9056 
 9057                 @Override
 9058                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9059                     return (StyleableProperty&lt;Number&gt;)node.rotateProperty();
 9060                 }
 9061             };
 9062         private static final CssMetaData&lt;Node,Number&gt; SCALE_X =
 9063             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-scale-x&quot;,
 9064                 SizeConverter.getInstance(), 1.0) {
 9065 
 9066                 @Override
 9067                 public boolean isSettable(Node node) {
 9068                     return node.nodeTransformation == null
 9069                         || node.nodeTransformation.scaleX == null
 9070                         || node.nodeTransformation.canSetScaleX();
 9071                 }
 9072 
 9073                 @Override
 9074                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9075                     return (StyleableProperty&lt;Number&gt;)node.scaleXProperty();
 9076                 }
 9077             };
 9078         private static final CssMetaData&lt;Node,Number&gt; SCALE_Y =
 9079             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-scale-y&quot;,
 9080                 SizeConverter.getInstance(), 1.0) {
 9081 
 9082                 @Override
 9083                 public boolean isSettable(Node node) {
 9084                     return node.nodeTransformation == null
 9085                         || node.nodeTransformation.scaleY == null
 9086                         || node.nodeTransformation.canSetScaleY();
 9087                 }
 9088 
 9089                 @Override
 9090                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9091                     return (StyleableProperty&lt;Number&gt;)node.scaleYProperty();
 9092                 }
 9093             };
 9094         private static final CssMetaData&lt;Node,Number&gt; SCALE_Z =
 9095             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-scale-z&quot;,
 9096                 SizeConverter.getInstance(), 1.0) {
 9097 
 9098                 @Override
 9099                 public boolean isSettable(Node node) {
 9100                     return node.nodeTransformation == null
 9101                         || node.nodeTransformation.scaleZ == null
 9102                         || node.nodeTransformation.canSetScaleZ();
 9103                 }
 9104 
 9105                 @Override
 9106                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9107                     return (StyleableProperty&lt;Number&gt;)node.scaleZProperty();
 9108                 }
 9109             };
 9110         private static final CssMetaData&lt;Node,Number&gt; TRANSLATE_X =
 9111             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-translate-x&quot;,
 9112                 SizeConverter.getInstance(), 0.0) {
 9113 
 9114                 @Override
 9115                 public boolean isSettable(Node node) {
 9116                     return node.nodeTransformation == null
 9117                         || node.nodeTransformation.translateX == null
 9118                         || node.nodeTransformation.canSetTranslateX();
 9119                 }
 9120 
 9121                 @Override
 9122                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9123                     return (StyleableProperty&lt;Number&gt;)node.translateXProperty();
 9124                 }
 9125             };
 9126         private static final CssMetaData&lt;Node,Number&gt; TRANSLATE_Y =
 9127             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-translate-y&quot;,
 9128                 SizeConverter.getInstance(), 0.0) {
 9129 
 9130                 @Override
 9131                 public boolean isSettable(Node node) {
 9132                     return node.nodeTransformation == null
 9133                         || node.nodeTransformation.translateY == null
 9134                         || node.nodeTransformation.canSetTranslateY();
 9135                 }
 9136 
 9137                 @Override
 9138                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9139                     return (StyleableProperty&lt;Number&gt;)node.translateYProperty();
 9140                 }
 9141             };
 9142         private static final CssMetaData&lt;Node,Number&gt; TRANSLATE_Z =
 9143             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-translate-z&quot;,
 9144                 SizeConverter.getInstance(), 0.0) {
 9145 
 9146                 @Override
 9147                 public boolean isSettable(Node node) {
 9148                     return node.nodeTransformation == null
 9149                         || node.nodeTransformation.translateZ == null
 9150                         || node.nodeTransformation.canSetTranslateZ();
 9151                 }
 9152 
 9153                 @Override
 9154                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9155                     return (StyleableProperty&lt;Number&gt;)node.translateZProperty();
 9156                 }
 9157             };
 9158          private static final CssMetaData&lt;Node, Number&gt; VIEW_ORDER
 9159                  = new CssMetaData&lt;Node, Number&gt;(&quot;-fx-view-order&quot;,
 9160                          SizeConverter.getInstance(), 0.0) {
 9161 
 9162                      @Override
 9163                      public boolean isSettable(Node node) {
 9164                          return node.miscProperties == null
 9165                          || node.miscProperties.viewOrder == null
 9166                          || !node.miscProperties.viewOrder.isBound();
 9167                      }
 9168 
 9169                      @Override
 9170                      public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9171                          return (StyleableProperty&lt;Number&gt;) node.viewOrderProperty();
 9172                      }
 9173                  };
 9174         private static final CssMetaData&lt;Node,Boolean&gt; VISIBILITY =
 9175             new CssMetaData&lt;Node,Boolean&gt;(&quot;visibility&quot;,
 9176                 new StyleConverter&lt;String,Boolean&gt;() {
 9177 
 9178                     @Override
 9179                     // [ visible | hidden | collapse | inherit ]
 9180                     public Boolean convert(ParsedValue&lt;String, Boolean&gt; value, Font font) {
 9181                         final String sval = value != null ? value.getValue() : null;
 9182                         return &quot;visible&quot;.equalsIgnoreCase(sval);
 9183                     }
 9184 
 9185                 },
 9186                 Boolean.TRUE) {
 9187 
 9188                 @Override
 9189                 public boolean isSettable(Node node) {
 9190                     return node.visible == null || !node.visible.isBound();
 9191                 }
 9192 
 9193                 @Override
 9194                 public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Node node) {
 9195                     return (StyleableProperty&lt;Boolean&gt;)node.visibleProperty();
 9196                 }
 9197             };
 9198 
 9199          private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
 9200 
 9201          static {
 9202 
 9203              final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
 9204                      new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;();
 9205              styleables.add(CURSOR);
 9206              styleables.add(EFFECT);
 9207              styleables.add(FOCUS_TRAVERSABLE);
 9208              styleables.add(OPACITY);
 9209              styleables.add(BLEND_MODE);
 9210              styleables.add(ROTATE);
 9211              styleables.add(SCALE_X);
 9212              styleables.add(SCALE_Y);
 9213              styleables.add(SCALE_Z);
 9214              styleables.add(VIEW_ORDER);
 9215              styleables.add(TRANSLATE_X);
 9216              styleables.add(TRANSLATE_Y);
 9217              styleables.add(TRANSLATE_Z);
 9218              styleables.add(VISIBILITY);
 9219              STYLEABLES = Collections.unmodifiableList(styleables);
 9220 
 9221          }
 9222     }
 9223 
 9224     /**
 9225      * @return The CssMetaData associated with this class, which may include the
 9226      * CssMetaData of its superclasses.
 9227      * @since JavaFX 8.0
 9228      */
 9229     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
 9230         //
 9231         // Super-lazy instantiation pattern from Bill Pugh. StyleableProperties
 9232         // is referenced no earlier (and therefore loaded no earlier by the
 9233         // class loader) than the moment that  getClassCssMetaData() is called.
 9234         // This avoids loading the CssMetaData instances until the point at
 9235         // which CSS needs the data.
 9236         //
 9237         return StyleableProperties.STYLEABLES;
 9238     }
 9239 
 9240     /**
 9241      * This method should delegate to {@link Node#getClassCssMetaData()} so that
 9242      * a Node&#39;s CssMetaData can be accessed without the need for reflection.
 9243      *
 9244      * @return The CssMetaData associated with this node, which may include the
 9245      * CssMetaData of its superclasses.
 9246      * @since JavaFX 8.0
 9247      */
 9248 
 9249     @Override
 9250     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
 9251         return getClassCssMetaData();
 9252     }
 9253 
 9254     /*
 9255      * @return  The Styles that match this CSS property for the given Node. The
 9256      * list is sorted by descending specificity.
 9257      */
 9258     // SB-dependency: RT-21096 has been filed to track this
 9259     static List&lt;Style&gt; getMatchingStyles(CssMetaData cssMetaData, Styleable styleable) {
 9260          return CssStyleHelper.getMatchingStyles(styleable, cssMetaData);
 9261     }
 9262 
 9263     final ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; getStyleMap() {
 9264          ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; map =
 9265                  (ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt;)getProperties().get(&quot;STYLEMAP&quot;);
 9266          Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; ret = CssStyleHelper.getMatchingStyles(map, this);
 9267          if (ret != null) {
 9268              if (ret instanceof ObservableMap) return (ObservableMap)ret;
 9269              return FXCollections.observableMap(ret);
 9270          }
 9271          return FXCollections.&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt;emptyObservableMap();
 9272      }
 9273 
 9274      /*
 9275       * RT-17293
 9276       */
 9277      // SB-dependency: RT-21096 has been filed to track this
 9278      final void setStyleMap(ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; styleMap) {
 9279          if (styleMap != null) getProperties().put(&quot;STYLEMAP&quot;, styleMap);
 9280          else getProperties().remove(&quot;STYLEMAP&quot;);
 9281      }
 9282 
 9283     /*
 9284      * Find CSS styles that were used to style this Node in its current pseudo-class state. The map will contain the styles from this node and,
 9285      * if the node is a Parent, its children. The node corresponding to an entry in the Map can be obtained by casting a StyleableProperty key to a
 9286      * javafx.beans.property.Property and calling getBean(). The List contains only those styles used to style the property and will contain
 9287      * styles used to resolve lookup values.
 9288      *
 9289      * @param styleMap A Map to be populated with the styles. If null, a new Map will be allocated.
 9290      * @return The Map populated with matching styles.
 9291      */
 9292     // SB-dependency: RT-21096 has been filed to track this
 9293     Map&lt;StyleableProperty&lt;?&gt;,List&lt;Style&gt;&gt; findStyles(Map&lt;StyleableProperty&lt;?&gt;,List&lt;Style&gt;&gt; styleMap) {
 9294 
 9295         Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; ret = CssStyleHelper.getMatchingStyles(styleMap, this);
 9296         return (ret != null) ? ret : Collections.&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt;emptyMap();
 9297     }
 9298 
 9299     /**
 9300      * Flags used to indicate in which way this node is dirty (or whether it
 9301      * is clean) and what must happen during the next CSS cycle on the
 9302      * scenegraph.
 9303      */
 9304     CssFlags cssFlag = CssFlags.CLEAN;
 9305 
 9306     /**
 9307      * Needed for testing.
 9308      */
 9309     final CssFlags getCSSFlags() { return cssFlag; }
 9310 
 9311     /**
 9312      * Called when a CSS pseudo-class change would cause styles to be reapplied.
 9313      */
 9314     private void requestCssStateTransition() {
 9315         // If there is no scene, then we cannot make it dirty, so we&#39;ll leave
 9316         // the flag alone
 9317         if (getScene() == null) return;
 9318         // Don&#39;t bother doing anything if the cssFlag is not CLEAN.
 9319         // If the flag indicates a DIRTY_BRANCH, the flag needs to be changed
 9320         // to UPDATE to ensure that NodeHelper.processCSS is called on the node.
 9321         if (cssFlag == CssFlags.CLEAN || cssFlag == CssFlags.DIRTY_BRANCH) {
 9322             cssFlag = CssFlags.UPDATE;
 9323             notifyParentsOfInvalidatedCSS();
 9324         }
 9325     }
 9326 
 9327     /**
 9328      * Used to specify that a pseudo-class of this Node has changed. If the
 9329      * pseudo-class is used in a CSS selector that matches this Node, CSS will
 9330      * be reapplied. Typically, this method is called from the {@code invalidated}
 9331      * method of a property that is used as a pseudo-class. For example:
 9332      * &lt;pre&gt;&lt;code&gt;
 9333      *
 9334      *     private static final PseudoClass MY_PSEUDO_CLASS_STATE = PseudoClass.getPseudoClass(&quot;my-state&quot;);
 9335      *
 9336      *     BooleanProperty myPseudoClassState = new BooleanPropertyBase(false) {
 9337      *
 9338      *           {@literal @}Override public void invalidated() {
 9339      *                pseudoClassStateChanged(MY_PSEUDO_CLASS_STATE, get());
 9340      *           }
 9341      *
 9342      *           {@literal @}Override public Object getBean() {
 9343      *               return MyControl.this;
 9344      *           }
 9345      *
 9346      *           {@literal @}Override public String getName() {
 9347      *               return &quot;myPseudoClassState&quot;;
 9348      *           }
 9349      *       };
 9350      * &lt;/code&gt;&lt;/pre&gt;
 9351      * @param pseudoClass the pseudo-class that has changed state
 9352      * @param active whether or not the state is active
 9353      * @since JavaFX 8.0
 9354      */
 9355     public final void pseudoClassStateChanged(PseudoClass pseudoClass, boolean active) {
 9356 
 9357         final boolean modified = active
 9358                 ? pseudoClassStates.add(pseudoClass)
 9359                 : pseudoClassStates.remove(pseudoClass);
 9360 
 9361         if (modified &amp;&amp; styleHelper != null) {
 9362             final boolean isTransition = styleHelper.pseudoClassStateChanged(pseudoClass);
 9363             if (isTransition) {
 9364                 requestCssStateTransition();
 9365             }
 9366         }
 9367    }
 9368 
 9369     // package so that StyleHelper can get at it
 9370     final ObservableSet&lt;PseudoClass&gt; pseudoClassStates = new PseudoClassState();
 9371     private final ObservableSet&lt;PseudoClass&gt; unmodifiablePseudoClassStates =
 9372             FXCollections.unmodifiableObservableSet(pseudoClassStates);
 9373     /**
 9374      * @return The active pseudo-class states of this Node, wrapped in an unmodifiable ObservableSet
 9375      * @since JavaFX 8.0
 9376      */
 9377     @Override
 9378     public final ObservableSet&lt;PseudoClass&gt; getPseudoClassStates() {
 9379         return unmodifiablePseudoClassStates;
 9380     }
 9381 
 9382     // Walks up the tree telling each parent that the pseudo class state of
 9383     // this node has changed.
 9384     final void notifyParentsOfInvalidatedCSS() {
 9385         SubScene subScene = getSubScene();
 9386         Parent root = (subScene != null) ?
 9387                 subScene.getRoot() : getScene().getRoot();
 9388 
 9389         if (!root.isDirty(DirtyBits.NODE_CSS)) {
 9390             // Ensure that Scene.root is marked as dirty. If the scene isn&#39;t
 9391             // dirty, nothing will get repainted. This bit is cleared from
 9392             // Scene in doCSSPass().
 9393             NodeHelper.markDirty(root, DirtyBits.NODE_CSS);
 9394             if (subScene != null) {
 9395                 // If the node is part of a subscene, then we must ensure that
 9396                 // the we not only mark subScene.root dirty, but continue and
 9397                 // call subScene.notifyParentsOfInvalidatedCSS() until
 9398                 // Scene.root gets marked dirty, via the recursive call:
 9399                 subScene.cssFlag = CssFlags.UPDATE;
 9400                 subScene.notifyParentsOfInvalidatedCSS();
 9401             }
 9402         }
 9403         Parent _parent = getParent();
 9404         while (_parent != null) {
 9405             if (_parent.cssFlag == CssFlags.CLEAN) {
 9406                 _parent.cssFlag = CssFlags.DIRTY_BRANCH;
 9407                 _parent = _parent.getParent();
 9408             } else {
 9409                 _parent = null;
 9410             }
 9411         }
 9412     }
 9413 
 9414     final void reapplyCSS() {
 9415 
 9416         if (getScene() == null) return;
 9417 
 9418         if (cssFlag == CssFlags.REAPPLY) return;
 9419 
 9420         if (cssFlag == CssFlags.DIRTY_BRANCH) {
 9421             // JDK-8193445 - don&#39;t reapply CSS from here
 9422             // Defer CSS application to this Node by marking cssFlag as REAPPLY
 9423             cssFlag = CssFlags.REAPPLY;
 9424             return;
 9425         }
 9426 
 9427         // RT-36838 - don&#39;t reapply CSS in the middle of an update
 9428         if (cssFlag == CssFlags.UPDATE) {
 9429             cssFlag = CssFlags.REAPPLY;
 9430             notifyParentsOfInvalidatedCSS();
 9431             return;
 9432         }
 9433 
 9434         reapplyCss();
 9435 
 9436         //
 9437         // One idiom employed by developers is to, during the layout pass,
 9438         // add or remove nodes from the scene. For example, a ScrollPane
 9439         // might add scroll bars to itself if it determines during layout
 9440         // that it needs them, or a ListView might add cells to itself if
 9441         // it determines that it needs to. In such situations we must
 9442         // apply the CSS immediately and not add it to the scene&#39;s queue
 9443         // for deferred action.
 9444         //
 9445         if (getParent() != null &amp;&amp; getParent().isPerformingLayout()) {
 9446             NodeHelper.processCSS(this);
 9447         } else {
 9448             notifyParentsOfInvalidatedCSS();
 9449         }
 9450 
 9451     }
 9452 
 9453     //
 9454     // This method &quot;reapplies&quot; CSS to this node and all of its children. Reapplying CSS
 9455     // means that new style maps are calculated for the node. The process of reapplying
 9456     // CSS may reset the CSS properties of a node to their initial state, but the _new_
 9457     // styles are not applied as part of this process.
 9458     //
 9459     // There is no check of the CSS state of a child since reapply takes precedence
 9460     // over other CSS states.
 9461     //
 9462     private void reapplyCss() {
 9463 
 9464         // Hang on to current styleHelper so we can know whether
 9465         // createStyleHelper returned the same styleHelper
 9466         final CssStyleHelper oldStyleHelper = styleHelper;
 9467 
 9468         // CSS state is &quot;REAPPLY&quot;
 9469         cssFlag = CssFlags.REAPPLY;
 9470 
 9471         styleHelper = CssStyleHelper.createStyleHelper(this);
 9472 
 9473         // REAPPLY to my children, too.
 9474         if (this instanceof Parent) {
 9475 
 9476             // minor optimization to avoid calling createStyleHelper on children
 9477             // when we know there will not be any change in the style maps.
 9478             final boolean visitChildren =
 9479                     // If we don&#39;t have a styleHelper, then we should visit the children of this parent
 9480                     // since there might be styles that depend on being a child of this parent.
 9481                     // In other words, we have .a &gt; .b { blah: blort; }, but no styles for &quot;.a&quot; itself.
 9482                     styleHelper == null ||
 9483                     // if the styleHelper changed, then we definitely need to visit the children
 9484                     // since the new styles may have an effect on the children&#39;s styles calculated values.
 9485                     (oldStyleHelper != styleHelper) ||
 9486                     // If our parent is null, then we&#39;re the root of a scene or sub-scene, most likely,
 9487                     // and we&#39;ll visit children because elsewhere the code depends on root.reapplyCSS()
 9488                     // to force css to be reapplied (whether it needs to be or not).
 9489                     (getParent() == null) ||
 9490                     // If our parent&#39;s cssFlag is other than clean, then the parent may have just had
 9491                     // CSS reapplied. If the parent just had CSS reapplied, then some of its styles
 9492                     // may affect my children&#39;s styles.
 9493                     (getParent().cssFlag != CssFlags.CLEAN);
 9494 
 9495             if (visitChildren) {
 9496 
 9497                 List&lt;Node&gt; children = ((Parent) this).getChildren();
 9498                 for (int n = 0, nMax = children.size(); n &lt; nMax; n++) {
 9499                     Node child = children.get(n);
 9500                     child.reapplyCss();
 9501                 }
 9502             }
 9503 
 9504         } else if (this instanceof SubScene) {
 9505 
 9506             // SubScene root is a Parent, but reapplyCss is a private method in Node
 9507             final Node subSceneRoot = ((SubScene)this).getRoot();
 9508             if (subSceneRoot != null) {
 9509                 subSceneRoot.reapplyCss();
 9510             }
 9511 
 9512         } else if (styleHelper == null) {
 9513             //
 9514             // If this is not a Parent and there is no styleHelper, then the CSS state is &quot;CLEAN&quot;
 9515             // since there are no styles to apply or children to update.
 9516             //
 9517             cssFlag = CssFlags.CLEAN;
 9518             return;
 9519         }
 9520 
 9521         cssFlag = CssFlags.UPDATE;
 9522 
 9523     }
 9524 
 9525     void processCSS() {
 9526         switch (cssFlag) {
 9527             case CLEAN:
 9528                 break;
 9529             case DIRTY_BRANCH:
 9530             {
 9531                 Parent me = (Parent)this;
 9532                 // clear the flag first in case the flag is set to something
 9533                 // other than clean by downstream processing.
 9534                 me.cssFlag = CssFlags.CLEAN;
 9535                 List&lt;Node&gt; children = me.getChildren();
 9536                 for (int i=0, max=children.size(); i&lt;max; i++) {
 9537                     children.get(i).processCSS();
 9538                 }
 9539                 break;
 9540             }
 9541             case REAPPLY:
 9542             case UPDATE:
 9543             default:
 9544                 NodeHelper.processCSS(this);
 9545         }
 9546     }
 9547 
 9548     /**
 9549      * If required, apply styles to this Node and its children, if any. This method does not normally need to
 9550      * be invoked directly but may be used in conjunction with {@link Parent#layout()} to size a Node before the
 9551      * next pulse, or if the {@link #getScene() Scene} is not in a {@link javafx.stage.Stage}.
 9552      * &lt;p&gt;Provided that the Node&amp;#39;s {@link #getScene() Scene} is not null, CSS is applied to this Node regardless
 9553      * of whether this Node&amp;#39;s CSS state is clean. CSS styles are applied from the top-most parent
 9554      * of this Node whose CSS state is other than clean, which may affect the styling of other nodes.
 9555      * This method is a no-op if the Node is not in a Scene. The Scene does not have to be in a Stage.&lt;/p&gt;
 9556      * &lt;p&gt;This method does not invoke the {@link Parent#layout()} method. Typically, the caller will use the
 9557      * following sequence of operations.&lt;/p&gt;
 9558      * &lt;pre&gt;{@code
 9559      *     parentNode.applyCss();
 9560      *     parentNode.layout();
 9561      * }&lt;/pre&gt;
 9562      * &lt;p&gt;As a more complete example, the following code uses {@code applyCss()} and {@code layout()} to find
 9563      * the width and height of the Button before the Stage has been shown. If either the call to {@code applyCss()}
 9564      * or the call to {@code layout()} is commented out, the calls to {@code getWidth()} and {@code getHeight()}
 9565      * will return zero (until some time after the Stage is shown). &lt;/p&gt;
 9566      * &lt;pre&gt;&lt;code&gt;
 9567      * {@literal @}Override
 9568      * public void start(Stage stage) throws Exception {
 9569      *
 9570      *    Group root = new Group();
 9571      *    Scene scene = new Scene(root);
 9572      *
 9573      *    Button button = new Button(&quot;Hello World&quot;);
 9574      *    root.getChildren().add(button);
 9575      *
 9576      *    root.applyCss();
 9577      *    root.layout();
 9578      *
 9579      *    double width = button.getWidth();
 9580      *    double height = button.getHeight();
 9581      *
 9582      *    System.out.println(width + &quot;, &quot; + height);
 9583      *
 9584      *    stage.setScene(scene);
 9585      *    stage.show();
 9586      * }
 9587      * &lt;/code&gt;&lt;/pre&gt;
 9588      * @since JavaFX 8.0
 9589      */
 9590     public final void applyCss() {
 9591 
 9592         if (getScene() == null) {
 9593             return;
 9594         }
 9595 
 9596         // update, unless reapply
 9597         if (cssFlag != CssFlags.REAPPLY) cssFlag = CssFlags.UPDATE;
 9598 
 9599         //
 9600         // RT-28394 - need to see if any ancestor has a flag UPDATE
 9601         // If so, process css from the top-most CssFlags.UPDATE node
 9602         // since my ancestor&#39;s styles may affect mine.
 9603         //
 9604         // If the scene-graph root isn&#39;t NODE_CSS dirty, then all my
 9605         // ancestor flags should be CLEAN and I can skip this lookup.
 9606         //
 9607         Node topMost = this;
 9608 
 9609         final boolean dirtyRoot = getScene().getRoot().isDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);
 9610         if (dirtyRoot) {
 9611 
 9612             Node _parent = getParent();
 9613             while (_parent != null) {
 9614                 if (_parent.cssFlag == CssFlags.UPDATE || _parent.cssFlag == CssFlags.REAPPLY) {
 9615                     topMost = _parent;
 9616                 }
 9617                 _parent = _parent.getParent();
 9618             }
 9619 
 9620             // Note: this code used to mark the parent nodes with DIRTY_BRANCH,
 9621             // but that isn&#39;t necessary since UPDATE will apply css to all of
 9622             // a Parent&#39;s children.
 9623 
 9624             // If we&#39;re at the root of the scene-graph, make sure the NODE_CSS
 9625             // dirty bit is cleared (see Scene#doCSSPass())
 9626             if (topMost == getScene().getRoot()) {
 9627                 getScene().getRoot().clearDirty(DirtyBits.NODE_CSS);
 9628             }
 9629         }
 9630 
 9631         topMost.processCSS();
 9632 
 9633     }
 9634 
 9635     /*
 9636      * If invoked, will update styles from here on down. This method should not be called directly. If
 9637      * overridden, the overriding method must at some point call {@code super.processCSSImpl} to ensure that
 9638      * this Node&#39;s CSS state is properly updated.
 9639      *
 9640      * Note that the difference between this method and {@link #applyCss()} is that this method
 9641      * updates styles for this node on down; whereas, {@code applyCss()} looks for the top-most ancestor that needs
 9642      * CSS update and apply styles from that node on down.
 9643      *
 9644      * Note: This method MUST only be called via its accessor method.
 9645      */
 9646     private void doProcessCSS() {
 9647 
 9648         // Nothing to do...
 9649         if (cssFlag == CssFlags.CLEAN) return;
 9650 
 9651         // if REAPPLY was deferred, process it now...
 9652         if (cssFlag == CssFlags.REAPPLY) {
 9653             reapplyCss();
 9654         }
 9655 
 9656         // Clear the flag first in case the flag is set to something
 9657         // other than clean by downstream processing.
 9658         cssFlag = CssFlags.CLEAN;
 9659 
 9660         // Transition to the new state and apply styles
 9661         if (styleHelper != null &amp;&amp; getScene() != null) {
 9662             styleHelper.transitionToState(this);
 9663         }
 9664     }
 9665 
 9666 
 9667     /**
 9668      * A StyleHelper for this node.
 9669      * A StyleHelper contains all the css styles for this node
 9670      * and knows how to apply them when our state changes.
 9671      */
 9672     CssStyleHelper styleHelper;
 9673 
 9674     private static final PseudoClass HOVER_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;hover&quot;);
 9675     private static final PseudoClass PRESSED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;pressed&quot;);
 9676     private static final PseudoClass DISABLED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;disabled&quot;);
 9677     private static final PseudoClass FOCUSED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;focused&quot;);
 9678     private static final PseudoClass SHOW_MNEMONICS_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;show-mnemonics&quot;);
 9679 
 9680     private static abstract class LazyTransformProperty
 9681             extends ReadOnlyObjectProperty&lt;Transform&gt; {
 9682 
 9683         protected static final int VALID = 0;
 9684         protected static final int INVALID = 1;
 9685         protected static final int VALIDITY_UNKNOWN = 2;
 9686         protected int valid = INVALID;
 9687 
 9688         private ExpressionHelper&lt;Transform&gt; helper;
 9689 
 9690         private Transform transform;
 9691         private boolean canReuse = false;
 9692 
 9693         @Override
 9694         public void addListener(InvalidationListener listener) {
 9695             helper = ExpressionHelper.addListener(helper, this, listener);
 9696         }
 9697 
 9698         @Override
 9699         public void removeListener(InvalidationListener listener) {
 9700             helper = ExpressionHelper.removeListener(helper, listener);
 9701         }
 9702 
 9703         @Override
 9704         public void addListener(ChangeListener&lt;? super Transform&gt; listener) {
 9705             helper = ExpressionHelper.addListener(helper, this, listener);
 9706         }
 9707 
 9708         @Override
 9709         public void removeListener(ChangeListener&lt;? super Transform&gt; listener) {
 9710             helper = ExpressionHelper.removeListener(helper, listener);
 9711         }
 9712 
 9713         protected Transform getInternalValue() {
 9714             if (valid == INVALID ||
 9715                     (valid == VALIDITY_UNKNOWN &amp;&amp; computeValidity() == INVALID)) {
 9716                 transform = computeTransform(canReuse ? transform : null);
 9717                 canReuse = true;
 9718                 valid = validityKnown() ? VALID : VALIDITY_UNKNOWN;
 9719             }
 9720 
 9721             return transform;
 9722         }
 9723 
 9724         @Override
 9725         public Transform get() {
 9726             transform = getInternalValue();
 9727             canReuse = false;
 9728             return transform;
 9729         }
 9730 
 9731         public void validityUnknown() {
 9732             if (valid == VALID) {
 9733                 valid = VALIDITY_UNKNOWN;
 9734             }
 9735         }
 9736 
 9737         public void invalidate() {
 9738             if (valid != INVALID) {
 9739                 valid = INVALID;
 9740                 ExpressionHelper.fireValueChangedEvent(helper);
 9741             }
 9742         }
 9743 
 9744         protected abstract boolean validityKnown();
 9745         protected abstract int computeValidity();
 9746         protected abstract Transform computeTransform(Transform reuse);
 9747     }
 9748 
 9749     private static abstract class LazyBoundsProperty
 9750             extends ReadOnlyObjectProperty&lt;Bounds&gt; {
 9751         private ExpressionHelper&lt;Bounds&gt; helper;
 9752         private boolean valid;
 9753 
 9754         private Bounds bounds;
 9755 
 9756         @Override
 9757         public void addListener(InvalidationListener listener) {
 9758             helper = ExpressionHelper.addListener(helper, this, listener);
 9759         }
 9760 
 9761         @Override
 9762         public void removeListener(InvalidationListener listener) {
 9763             helper = ExpressionHelper.removeListener(helper, listener);
 9764         }
 9765 
 9766         @Override
 9767         public void addListener(ChangeListener&lt;? super Bounds&gt; listener) {
 9768             helper = ExpressionHelper.addListener(helper, this, listener);
 9769         }
 9770 
 9771         @Override
 9772         public void removeListener(ChangeListener&lt;? super Bounds&gt; listener) {
 9773             helper = ExpressionHelper.removeListener(helper, listener);
 9774         }
 9775 
 9776         @Override
 9777         public Bounds get() {
 9778             if (!valid) {
 9779                 bounds = computeBounds();
 9780                 valid = true;
 9781             }
 9782 
 9783             return bounds;
 9784         }
 9785 
 9786         public void invalidate() {
 9787             if (valid) {
 9788                 valid = false;
 9789                 ExpressionHelper.fireValueChangedEvent(helper);
 9790             }
 9791         }
 9792 
 9793         protected abstract Bounds computeBounds();
 9794     }
 9795 
 9796     private static final BoundsAccessor boundsAccessor = (bounds, tx, node) -&gt; node.getGeomBounds(bounds, tx);
 9797 
 9798     /**
 9799      * The accessible role for this {@code Node}.
 9800      * &lt;p&gt;
 9801      * The screen reader uses the role of a node to determine the
 9802      * attributes and actions that are supported.
 9803      *
 9804      * @defaultValue {@link AccessibleRole#NODE}
 9805      * @see AccessibleRole
 9806      *
 9807      * @since JavaFX 8u40
 9808      */
 9809     private ObjectProperty&lt;AccessibleRole&gt; accessibleRole;
 9810 
 9811     public final void setAccessibleRole(AccessibleRole value) {
 9812         if (value == null) value = AccessibleRole.NODE;
 9813         accessibleRoleProperty().set(value);
 9814     }
 9815 
 9816     public final AccessibleRole getAccessibleRole() {
 9817         if (accessibleRole == null) return AccessibleRole.NODE;
 9818         return accessibleRoleProperty().get();
 9819     }
 9820 
 9821     public final ObjectProperty&lt;AccessibleRole&gt; accessibleRoleProperty() {
 9822         if (accessibleRole == null) {
 9823             accessibleRole = new SimpleObjectProperty&lt;AccessibleRole&gt;(this, &quot;accessibleRole&quot;, AccessibleRole.NODE);
 9824         }
 9825         return accessibleRole;
 9826     }
 9827 
 9828     public final void setAccessibleRoleDescription(String value) {
 9829         accessibleRoleDescriptionProperty().set(value);
 9830     }
 9831 
 9832     public final String getAccessibleRoleDescription() {
 9833         if (accessibilityProperties == null) return null;
 9834         if (accessibilityProperties.accessibleRoleDescription == null) return null;
 9835         return accessibleRoleDescriptionProperty().get();
 9836     }
 9837 
 9838     /**
 9839      * The role description of this {@code Node}.
 9840      * &lt;p&gt;
 9841      * Normally, when a role is provided for a node, the screen reader
 9842      * speaks the role as well as the contents of the node.  When this
 9843      * value is set, it is possible to override the default.  This is
 9844      * useful because the set of roles is predefined.  For example,
 9845      * it is possible to set the role of a node to be a button, but
 9846      * have the role description be arbitrary text.
 9847      *
 9848      * @return the role description of this {@code Node}.
 9849      * @defaultValue null
 9850      *
 9851      * @since JavaFX 8u40
 9852      */
 9853     public final ObjectProperty&lt;String&gt; accessibleRoleDescriptionProperty() {
 9854         return getAccessibilityProperties().getAccessibleRoleDescription();
 9855     }
 9856 
 9857     public final void setAccessibleText(String value) {
 9858         accessibleTextProperty().set(value);
 9859     }
 9860 
 9861     public final String getAccessibleText() {
 9862         if (accessibilityProperties == null) return null;
 9863         if (accessibilityProperties.accessibleText == null) return null;
 9864         return accessibleTextProperty().get();
 9865     }
 9866 
 9867     /**
 9868      * The accessible text for this {@code Node}.
 9869      * &lt;p&gt;
 9870      * This property is used to set the text that the screen
 9871      * reader will speak.  If a node normally speaks text,
 9872      * that text is overriden.  For example, a button
 9873      * usually speaks using the text in the control but will
 9874      * no longer do this when this value is set.
 9875      *
 9876      * @return accessible text for this {@code Node}.
 9877      * @defaultValue null
 9878      *
 9879      * @since JavaFX 8u40
 9880      */
 9881     public final ObjectProperty&lt;String&gt; accessibleTextProperty() {
 9882         return getAccessibilityProperties().getAccessibleText();
 9883     }
 9884 
 9885     public final void setAccessibleHelp(String value) {
 9886         accessibleHelpProperty().set(value);
 9887     }
 9888 
 9889     public final String getAccessibleHelp() {
 9890         if (accessibilityProperties == null) return null;
 9891         if (accessibilityProperties.accessibleHelp == null) return null;
 9892         return accessibleHelpProperty().get();
 9893     }
 9894 
 9895     /**
 9896      * The accessible help text for this {@code Node}.
 9897      * &lt;p&gt;
 9898      * The help text provides a more detailed description of the
 9899      * accessible text for a node.  By default, if the node has
 9900      * a tool tip, this text is used.
 9901      *
 9902      * @return the accessible help text for this {@code Node}.
 9903      * @defaultValue null
 9904      *
 9905      * @since JavaFX 8u40
 9906      */
 9907     public final ObjectProperty&lt;String&gt; accessibleHelpProperty() {
 9908         return getAccessibilityProperties().getAccessibleHelp();
 9909     }
 9910 
 9911     AccessibilityProperties accessibilityProperties;
 9912     private AccessibilityProperties getAccessibilityProperties() {
 9913         if (accessibilityProperties == null) {
 9914             accessibilityProperties = new AccessibilityProperties();
 9915         }
 9916         return accessibilityProperties;
 9917     }
 9918 
 9919     private class AccessibilityProperties {
 9920         ObjectProperty&lt;String&gt; accessibleRoleDescription;
 9921         ObjectProperty&lt;String&gt; getAccessibleRoleDescription() {
 9922             if (accessibleRoleDescription == null) {
 9923                 accessibleRoleDescription = new SimpleObjectProperty&lt;String&gt;(Node.this, &quot;accessibleRoleDescription&quot;, null);
 9924             }
 9925             return accessibleRoleDescription;
 9926         }
 9927         ObjectProperty&lt;String&gt; accessibleText;
 9928         ObjectProperty&lt;String&gt; getAccessibleText() {
 9929             if (accessibleText == null) {
 9930                 accessibleText = new SimpleObjectProperty&lt;String&gt;(Node.this, &quot;accessibleText&quot;, null);
 9931             }
 9932             return accessibleText;
 9933         }
 9934         ObjectProperty&lt;String&gt; accessibleHelp;
 9935         ObjectProperty&lt;String&gt; getAccessibleHelp() {
 9936             if (accessibleHelp == null) {
 9937                 accessibleHelp = new SimpleObjectProperty&lt;String&gt;(Node.this, &quot;accessibleHelp&quot;, null);
 9938             }
 9939             return accessibleHelp;
 9940         }
 9941     }
 9942 
 9943     /**
 9944      * This method is called by the assistive technology to request
 9945      * the value for an attribute.
 9946      * &lt;p&gt;
 9947      * This method is commonly overridden by subclasses to implement
 9948      * attributes that are required for a specific role.&lt;br&gt;
 9949      * If a particular attribute is not handled, the superclass implementation
 9950      * must be called.
 9951      * &lt;/p&gt;
 9952      *
 9953      * @param attribute the requested attribute
 9954      * @param parameters optional list of parameters
 9955      * @return the value for the requested attribute
 9956      *
 9957      * @see AccessibleAttribute
 9958      *
 9959      * @since JavaFX 8u40
 9960      */
 9961     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
 9962         switch (attribute) {
 9963             case ROLE: return getAccessibleRole();
 9964             case ROLE_DESCRIPTION: return getAccessibleRoleDescription();
 9965             case TEXT: return getAccessibleText();
 9966             case HELP: return getAccessibleHelp();
 9967             case PARENT: return getParent();
 9968             case SCENE: return getScene();
 9969             case BOUNDS: return localToScreen(getBoundsInLocal());
 9970             case DISABLED: return isDisabled();
 9971             case FOCUSED: return isFocused();
 9972             case VISIBLE: return isVisible();
 9973             case LABELED_BY: return labeledBy;
 9974             default: return null;
 9975         }
 9976     }
 9977 
 9978     /**
 9979      * This method is called by the assistive technology to request the action
 9980      * indicated by the argument should be executed.
 9981      * &lt;p&gt;
 9982      * This method is commonly overridden by subclasses to implement
 9983      * action that are required for a specific role.&lt;br&gt;
 9984      * If a particular action is not handled, the superclass implementation
 9985      * must be called.
 9986      * &lt;/p&gt;
 9987      *
 9988      * @param action the action to execute
 9989      * @param parameters optional list of parameters
 9990      *
 9991      * @see AccessibleAction
 9992      *
 9993      * @since JavaFX 8u40
 9994      */
 9995     public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
 9996         switch (action) {
 9997             case REQUEST_FOCUS:
 9998                 if (isFocusTraversable()) {
 9999                     requestFocus();
10000                 }
10001                 break;
10002             case SHOW_MENU: {
10003                 Bounds b = getBoundsInLocal();
10004                 Point2D pt = localToScreen(b.getMaxX(), b.getMaxY());
10005                 ContextMenuEvent event =
10006                     new ContextMenuEvent(ContextMenuEvent.CONTEXT_MENU_REQUESTED,
10007                     b.getMaxX(), b.getMaxY(), pt.getX(), pt.getY(),
10008                     false, new PickResult(this, b.getMaxX(), b.getMaxY()));
10009                 Event.fireEvent(this, event);
10010                 break;
10011             }
10012             default:
10013         }
10014     }
10015 
10016     /**
10017      * This method is called by the application to notify the assistive
10018      * technology that the value for an attribute has changed.
10019      *
10020      * @param attributes the attribute whose value has changed
10021      *
10022      * @see AccessibleAttribute
10023      *
10024      * @since JavaFX 8u40
10025      */
10026     public final void notifyAccessibleAttributeChanged(AccessibleAttribute attributes) {
10027         if (accessible == null) {
10028             Scene scene = getScene();
10029             if (scene != null) {
10030                 accessible = scene.removeAccessible(this);
10031             }
10032         }
10033         if (accessible != null) {
10034             accessible.sendNotification(attributes);
10035         }
10036     }
10037 
10038     Accessible accessible;
10039     Accessible getAccessible() {
10040         if (accessible == null) {
10041             Scene scene = getScene();
10042             /* It is possible the node was reparented and getAccessible()
10043              * is called before the pulse. Try to recycle the accessible
10044              * before creating a new one.
10045              * Note: this code relies that an accessible can never be on
10046              * more than one Scene#accMap. Thus, the only way
10047              * scene#removeAccessible() returns non-null is if the node
10048              * old scene and new scene are the same object.
10049              */
10050             if (scene != null) {
10051                 accessible = scene.removeAccessible(this);
10052             }
10053         }
10054         if (accessible == null) {
10055             accessible = Application.GetApplication().createAccessible();
10056             accessible.setEventHandler(new Accessible.EventHandler() {
10057                 @SuppressWarnings(&quot;deprecation&quot;)
10058                 @Override public AccessControlContext getAccessControlContext() {
10059                     Scene scene = getScene();
10060                     if (scene == null) {
10061                         /* This can happen during the release process of an accessible object. */
10062                         throw new RuntimeException(&quot;Accessbility requested for node not on a scene&quot;);
10063                     }
10064                     if (scene.getPeer() != null) {
10065                         return scene.getPeer().getAccessControlContext();
10066                     } else {
10067                         /* In some rare cases the accessible for a Node is needed
10068                          * before its scene is made visible. For example, the screen reader
10069                          * might ask a Menu for its ContextMenu before the ContextMenu
10070                          * is made visible. That is a problem because the Window for the
10071                          * ContextMenu is only created immediately before the first time
10072                          * it is shown.
10073                          */
10074                         return scene.acc;
10075                     }
10076                 }
10077                 @Override public Object getAttribute(AccessibleAttribute attribute, Object... parameters) {
10078                     return queryAccessibleAttribute(attribute, parameters);
10079                 }
10080                 @Override public void executeAction(AccessibleAction action, Object... parameters) {
10081                     executeAccessibleAction(action, parameters);
10082                 }
10083                 @Override public String toString() {
10084                     String klassName = Node.this.getClass().getName();
10085                     return klassName.substring(klassName.lastIndexOf(&#39;.&#39;)+1);
10086                 }
10087             });
10088         }
10089         return accessible;
10090     }
10091 
10092     void releaseAccessible() {
10093         Accessible acc = this.accessible;
10094         if (acc != null) {
10095             accessible = null;
10096             acc.dispose();
10097         }
10098     }
10099 
10100 }
    </pre>
  </body>
</html>