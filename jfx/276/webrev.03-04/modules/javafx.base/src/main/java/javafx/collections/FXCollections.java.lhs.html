<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.base/src/main/java/javafx/collections/FXCollections.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.collections;
  27 
  28 import com.sun.javafx.collections.ListListenerHelper;
  29 import com.sun.javafx.collections.MapListenerHelper;
  30 import com.sun.javafx.collections.SetListenerHelper;
  31 import java.lang.reflect.Array;
  32 import java.util.AbstractList;
  33 import java.util.AbstractMap;
  34 import java.util.AbstractSet;
  35 import java.util.ArrayList;
  36 import java.util.Arrays;
  37 import java.util.Collection;
  38 import java.util.Collections;
  39 import java.util.Comparator;
  40 import java.util.HashMap;
  41 import java.util.HashSet;
  42 import java.util.Iterator;
  43 import java.util.List;
  44 import java.util.ListIterator;
  45 import java.util.Map;
  46 import java.util.NoSuchElementException;
  47 import java.util.Random;
  48 import java.util.Set;
  49 
  50 import javafx.beans.InvalidationListener;
  51 
  52 import com.sun.javafx.collections.ObservableListWrapper;
  53 import com.sun.javafx.collections.ObservableMapWrapper;
  54 import com.sun.javafx.collections.ObservableSetWrapper;
  55 import com.sun.javafx.collections.MapAdapterChange;
  56 import com.sun.javafx.collections.ObservableFloatArrayImpl;
  57 import com.sun.javafx.collections.ObservableIntegerArrayImpl;
  58 import com.sun.javafx.collections.ObservableSequentialListWrapper;
  59 import com.sun.javafx.collections.SetAdapterChange;
  60 import com.sun.javafx.collections.SortableList;
  61 import com.sun.javafx.collections.SourceAdapterChange;
  62 import java.util.RandomAccess;
  63 import javafx.beans.Observable;
  64 import javafx.collections.ListChangeListener.Change;
  65 import javafx.util.Callback;
  66 
  67 /**
  68  * Utility class that consists of static methods that are 1:1 copies of java.util.Collections methods.
  69  * &lt;br&gt;&lt;br&gt;
  70  * The wrapper methods (like synchronizedObservableList or emptyObservableList) has exactly the same
  71  * functionality as the methods in Collections, with exception that they return ObservableList and are
  72  * therefore suitable for methods that require ObservableList on input.
  73  * &lt;br&gt;&lt;br&gt;
  74  * The utility methods are here mainly for performance reasons. All methods are optimized in a way that
  75  * they yield only limited number of notifications. On the other hand, java.util.Collections methods
  76  * might call &quot;modification methods&quot; on an ObservableList multiple times, resulting in a number of notifications.
  77  *
  78  * @since JavaFX 2.0
  79  */
  80 public class FXCollections {
  81     /** Not to be instantiated. */
  82     private FXCollections() { }
  83 
  84     /**
  85      * Constructs an ObservableList that is backed by the specified list.
  86      * Mutation operations on the ObservableList instance will be reported
  87      * to observers that have registered on that instance.&lt;br&gt;
  88      * Note that mutation operations made directly to the underlying list are
  89      * &lt;em&gt;not&lt;/em&gt; reported to observers of any ObservableList that
  90      * wraps it.
  91      *
  92      * @param &lt;E&gt; The type of List to be wrapped
  93      * @param list a concrete List that backs this ObservableList
  94      * @return a newly created ObservableList
  95      */
  96     public static &lt;E&gt; ObservableList&lt;E&gt; observableList(List&lt;E&gt; list) {
  97         if (list == null) {
  98             throw new NullPointerException();
  99         }
 100         return list instanceof RandomAccess ? new ObservableListWrapper&lt;E&gt;(list) :
 101                 new ObservableSequentialListWrapper&lt;E&gt;(list);
 102     }
 103 
 104     /**
<a name="1" id="anc1"></a><span class="line-modified"> 105      * Constructs an {@code ObservableList} that is backed by the specified list.</span>
<span class="line-modified"> 106      * Mutation operations on the {@code ObservableList} instance will be reported</span>
<span class="line-removed"> 107      * to observers that have registered on that instance.&lt;br&gt;</span>
<span class="line-removed"> 108      * Note that mutation operations made directly to the underlying list are</span>
 109      * &lt;em&gt;not&lt;/em&gt; reported to observers of any {@code ObservableList} that
 110      * wraps it.
 111      * &lt;p&gt;
<a name="2" id="anc2"></a><span class="line-modified"> 112      * This list also reports mutations of the elements in it by using an {@code extractor}.</span>
<span class="line-modified"> 113      * Observable objects returned by the extractor (applied to each list element) are listened for changes</span>
<span class="line-modified"> 114      * and transformed into {@linkplain ListChangeListener.Change#wasUpdated() &quot;update&quot;} changes of a {@code ListChangeListener}.</span>



 115      *
<a name="3" id="anc3"></a><span class="line-modified"> 116      * @param &lt;E&gt; The type of List to be wrapped</span>
<span class="line-modified"> 117      * @param list a concrete List that backs this ObservableList</span>
<span class="line-modified"> 118      * @param extractor element to Observable[] converter</span>
<span class="line-modified"> 119      * @return a newly created ObservableList</span>

 120      * @since JavaFX 2.1
 121      */
 122     public static &lt;E&gt; ObservableList&lt;E&gt; observableList(List&lt;E&gt; list, Callback&lt;E, Observable[]&gt; extractor) {
 123         if (list == null || extractor == null) {
 124             throw new NullPointerException();
 125         }
 126         return list instanceof RandomAccess ? new ObservableListWrapper&lt;E&gt;(list, extractor) :
 127             new ObservableSequentialListWrapper&lt;E&gt;(list, extractor);
 128     }
 129 
 130     /**
 131      * Constructs an ObservableMap that is backed by the specified map.
 132      * Mutation operations on the ObservableMap instance will be reported
 133      * to observers that have registered on that instance.&lt;br&gt;
 134      * Note that mutation operations made directly to the underlying map are &lt;em&gt;not&lt;/em&gt;
 135      * reported to observers of any ObservableMap that wraps it.
 136      * @param &lt;K&gt; the type of the wrapped key
 137      * @param &lt;V&gt; the type of the wrapped value
 138      * @param map a Map that backs this ObservableMap
 139      * @return a newly created ObservableMap
 140      */
 141     public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; observableMap(Map&lt;K, V&gt; map) {
 142         if (map == null) {
 143             throw new NullPointerException();
 144         }
 145         return new ObservableMapWrapper&lt;K, V&gt;(map);
 146     }
 147 
 148     /**
 149      * Constructs an ObservableSet that is backed by the specified set.
 150      * Mutation operations on the ObservableSet instance will be reported
 151      * to observers that have registered on that instance.&lt;br&gt;
 152      * Note that mutation operations made directly to the underlying set are &lt;em&gt;not&lt;/em&gt;
 153      * reported to observers of any ObservableSet that wraps it.
 154      * @param &lt;E&gt; The type of List to be wrapped
 155      * @param set a Set that backs this ObservableSet
 156      * @return a newly created ObservableSet
 157      * @since JavaFX 2.1
 158      */
 159     public static &lt;E&gt; ObservableSet&lt;E&gt; observableSet(Set&lt;E&gt; set) {
 160         if (set == null) {
 161             throw new NullPointerException();
 162         }
 163         return new ObservableSetWrapper&lt;E&gt;(set);
 164     }
 165 
 166     /**
 167      * Constructs an ObservableSet backed by a HashSet
 168      * that contains all the specified elements.
 169      * @param &lt;E&gt; The type of List to be wrapped
 170      * @param elements elements that will be added into returned ObservableSet
 171      * @return a newly created ObservableSet
 172      * @since JavaFX 2.1
 173      */
 174     public static &lt;E&gt; ObservableSet&lt;E&gt; observableSet(E... elements) {
 175         if (elements == null) {
 176             throw new NullPointerException();
 177         }
 178         Set&lt;E&gt; set = new HashSet&lt;E&gt;(elements.length);
 179         Collections.addAll(set, elements);
 180         return new ObservableSetWrapper&lt;E&gt;(set);
 181     }
 182 
 183     /**
 184      * Constructs a read-only interface to the specified ObservableMap. Only
 185      * mutation operations made to the underlying ObservableMap will be reported
 186      * to observers that have registered on the unmodifiable instance. This allows
 187      * clients to track changes in a Map but disallows the ability to modify it.
 188      * @param &lt;K&gt; the type of the wrapped key
 189      * @param &lt;V&gt; the type of the wrapped value
 190      * @param map an ObservableMap that is to be monitored by this interface
 191      * @return a newly created UnmodifiableObservableMap
 192      */
 193     public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; unmodifiableObservableMap(ObservableMap&lt;K, V&gt; map) {
 194         if (map == null) {
 195             throw new NullPointerException();
 196         }
 197         return new com.sun.javafx.collections.UnmodifiableObservableMap&lt;K, V&gt;(map);
 198     }
 199 
 200     /**
 201      * Creates and returns a typesafe wrapper on top of provided observable map.
 202      * @param &lt;K&gt; the type of the wrapped key
 203      * @param &lt;V&gt; the type of the wrapped value
 204      * @param map an Observable map to be wrapped
 205      * @param keyType the type of key that {@code map} is permitted to hold
 206      * @param valueType the type of value that {@code map} is permitted to hold
 207      * @return a dynamically typesafe view of the specified map
 208      * @see Collections#checkedMap(java.util.Map, java.lang.Class, java.lang.Class)
 209      * @since JavaFX 8.0
 210      */
 211     public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; checkedObservableMap(ObservableMap&lt;K, V&gt; map, Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) {
 212         if (map == null || keyType == null || valueType == null) {
 213             throw new NullPointerException();
 214         }
 215         return new CheckedObservableMap&lt;K, V&gt;(map, keyType, valueType);
 216     }
 217 
 218     /**
 219      * Creates and returns a synchronized wrapper on top of provided observable map.
 220      * @param &lt;K&gt; the type of the wrapped key
 221      * @param &lt;V&gt; the type of the wrapped value
 222      * @param  map the map to be &quot;wrapped&quot; in a synchronized map.
 223      * @return A synchronized version of the observable map
 224      * @see Collections#synchronizedMap(java.util.Map)
 225      * @since JavaFX 8.0
 226      */
 227     public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; synchronizedObservableMap(ObservableMap&lt;K, V&gt; map) {
 228         if (map == null) {
 229             throw new NullPointerException();
 230         }
 231         return new SynchronizedObservableMap&lt;K, V&gt;(map);
 232     }
 233 
 234     private static ObservableMap EMPTY_OBSERVABLE_MAP = new EmptyObservableMap();
 235 
 236     /**
 237      * Creates an empty unmodifiable observable map.
 238      * @param &lt;K&gt; the type of the wrapped key
 239      * @param &lt;V&gt; the type of the wrapped value
 240      * @return An empty unmodifiable observable map
 241      * @see Collections#emptyMap()
 242      * @since JavaFX 8.0
 243      */
 244     @SuppressWarnings(&quot;unchecked&quot;)
 245     public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; emptyObservableMap() {
 246         return EMPTY_OBSERVABLE_MAP;
 247     }
 248 
 249     /**
 250      * Creates a new empty observable integer array.
 251      * @return a newly created ObservableIntegerArray
 252      * @since JavaFX 8.0
 253      */
 254     public static ObservableIntegerArray observableIntegerArray() {
 255         return new ObservableIntegerArrayImpl();
 256     }
 257 
 258     /**
 259      * Creates a new observable integer array with {@code values} set to it.
 260      * @param values the values that will be in the new observable integer array
 261      * @return a newly created ObservableIntegerArray
 262      * @since JavaFX 8.0
 263      */
 264     public static ObservableIntegerArray observableIntegerArray(int... values) {
 265         return new ObservableIntegerArrayImpl(values);
 266     }
 267 
 268     /**
 269      * Creates a new observable integer array with copy of elements in given
 270      * {@code array}.
 271      * @param array observable integer array to copy
 272      * @return a newly created ObservableIntegerArray
 273      * @since JavaFX 8.0
 274      */
 275     public static ObservableIntegerArray observableIntegerArray(ObservableIntegerArray array) {
 276         return new ObservableIntegerArrayImpl(array);
 277     }
 278 
 279     /**
 280      * Creates a new empty observable float array.
 281      * @return a newly created ObservableFloatArray
 282      * @since JavaFX 8.0
 283      */
 284     public static ObservableFloatArray observableFloatArray() {
 285         return new ObservableFloatArrayImpl();
 286     }
 287 
 288     /**
 289      * Creates a new observable float array with {@code values} set to it.
 290      * @param values the values that will be in the new observable float array
 291      * @return a newly created ObservableFloatArray
 292      * @since JavaFX 8.0
 293      */
 294     public static ObservableFloatArray observableFloatArray(float... values) {
 295         return new ObservableFloatArrayImpl(values);
 296     }
 297 
 298     /**
 299      * Creates a new observable float array with copy of elements in given
 300      * {@code array}.
 301      * @param array observable float array to copy
 302      * @return a newly created ObservableFloatArray
 303      * @since JavaFX 8.0
 304      */
 305     public static ObservableFloatArray observableFloatArray(ObservableFloatArray array) {
 306         return new ObservableFloatArrayImpl(array);
 307     }
 308 
 309     /**
 310      * Creates a new empty observable list that is backed by an array list.
 311      * @see #observableList(java.util.List)
 312      * @param &lt;E&gt; The type of List to be wrapped
 313      * @return a newly created ObservableList
 314      */
 315     @SuppressWarnings(&quot;unchecked&quot;)
 316     public static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList() {
 317         return observableList(new ArrayList());
 318     }
 319 
 320     /**
<a name="4" id="anc4"></a><span class="line-modified"> 321      * Creates a new empty {@code ObservableList} backed by an array list that listens to changes in observables of its items.</span>
<span class="line-modified"> 322      * The {@code extractor} parameter specifies observables (usually properties) of the objects in the created list. When there is</span>
<span class="line-modified"> 323      * a change in one of those observables, the user is notified of it through an</span>
<span class="line-modified"> 324      * {@link ListChangeListener.Change#wasUpdated() update} change of an attached {@code ListChangeListener}. These changes</span>

 325      * are unrelated to the changes made to the observable list itself using methods such as {@code add} and {@code remove}.
 326      * &lt;p&gt;
 327      * For example, a list of {@code Shape}s can listen to changes in the shapes&#39; {@code fill} property.
 328      *
<a name="5" id="anc5"></a><span class="line-modified"> 329      * @param &lt;E&gt; The type of List to be wrapped</span>
<span class="line-modified"> 330      * @param extractor element to Observable[] converter. Observable objects are listened for changes on the element.</span>
<span class="line-modified"> 331      * @return a newly created ObservableList</span>
 332      * @see #observableList(java.util.List, javafx.util.Callback)
 333      * @since JavaFX 2.1
 334      */
 335     public static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList(Callback&lt;E, Observable[]&gt; extractor) {
 336         return observableList(new ArrayList(), extractor);
 337     }
 338 
 339     /**
 340      * Creates a new observable array list with {@code items} added to it.
 341      * @param &lt;E&gt; The type of List to be wrapped
 342      * @param items the items that will be in the new observable ArrayList
 343      * @return a newly created observableArrayList
 344      * @see #observableArrayList()
 345      */
 346     public static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList(E... items) {
 347         ObservableList&lt;E&gt; list = observableArrayList();
 348         list.addAll(items);
 349         return list;
 350     }
 351 
 352     /**
 353      * Creates a new observable array list and adds a content of collection {@code col}
 354      * to it.
 355      * @param &lt;E&gt; The type of List to be wrapped
 356      * @param col a collection which content should be added to the observableArrayList
 357      * @return a newly created observableArrayList
 358      */
 359     public static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList(Collection&lt;? extends E&gt; col) {
 360         ObservableList&lt;E&gt; list = observableArrayList();
 361         list.addAll(col);
 362         return list;
 363     }
 364 
 365     /**
 366      * Creates a new empty observable map that is backed by a HashMap.
 367      * @param &lt;K&gt; the type of the wrapped key
 368      * @param &lt;V&gt; the type of the wrapped value
 369      * @return a newly created observable HashMap
 370      */
 371     public static &lt;K,V&gt; ObservableMap&lt;K,V&gt; observableHashMap() {
 372         return observableMap(new HashMap&lt;K, V&gt;());
 373     }
 374 
 375     /**
 376      * Concatenates more observable lists into one. The resulting list
 377      * would be backed by an array list.
 378      * @param &lt;E&gt; The type of List to be wrapped
 379      * @param lists lists to concatenate
 380      * @return new observable array list concatenated from the arguments
 381      */
 382     public static &lt;E&gt; ObservableList&lt;E&gt; concat(ObservableList&lt;E&gt;... lists) {
 383         if (lists.length == 0 ) {
 384             return observableArrayList();
 385         }
 386         if (lists.length == 1) {
 387             return observableArrayList(lists[0]);
 388         }
 389         ArrayList&lt;E&gt; backingList = new ArrayList&lt;E&gt;();
 390         for (ObservableList&lt;E&gt; s : lists) {
 391             backingList.addAll(s);
 392         }
 393 
 394         return observableList(backingList);
 395     }
 396 
 397     /**
 398      * Creates and returns unmodifiable wrapper list on top of provided observable list.
 399      * @param list  an ObservableList that is to be wrapped
 400      * @param &lt;E&gt; The type of List to be wrapped
 401      * @return an ObserableList wrapper that is unmodifiable
 402      * @see Collections#unmodifiableList(java.util.List)
 403      */
 404     public static&lt;E&gt; ObservableList&lt;E&gt; unmodifiableObservableList(ObservableList&lt;E&gt; list) {
 405         if (list == null) {
 406             throw new NullPointerException();
 407         }
 408         return new UnmodifiableObservableListImpl&lt;E&gt;(list);
 409     }
 410 
 411     /**
 412      * Creates and returns a typesafe wrapper on top of provided observable list.
 413      * @param &lt;E&gt; The type of List to be wrapped
 414      * @param list  an Observable list to be wrapped
 415      * @param type   the type of element that {@code list} is permitted to hold
 416      * @return a dynamically typesafe view of the specified list
 417      * @see Collections#checkedList(java.util.List, java.lang.Class)
 418      */
 419     public static&lt;E&gt; ObservableList&lt;E&gt; checkedObservableList(ObservableList&lt;E&gt; list, Class&lt;E&gt; type) {
 420         if (list == null) {
 421             throw new NullPointerException();
 422         }
 423         return new CheckedObservableList&lt;E&gt;(list, type);
 424     }
 425 
 426     /**
 427      * Creates and returns a synchronized wrapper on top of provided observable list.
 428      * @param &lt;E&gt; The type of List to be wrapped
 429      * @param  list the list to be &quot;wrapped&quot; in a synchronized list.
 430      * @return A synchronized version of the observable list
 431      * @see Collections#synchronizedList(java.util.List)
 432      */
 433     public static&lt;E&gt; ObservableList&lt;E&gt; synchronizedObservableList(ObservableList&lt;E&gt; list) {
 434         if (list == null) {
 435             throw new NullPointerException();
 436         }
 437         return new SynchronizedObservableList&lt;E&gt;(list);
 438     }
 439 
 440     private static ObservableList EMPTY_OBSERVABLE_LIST = new EmptyObservableList();
 441 
 442 
 443     /**
 444      * Creates an empty unmodifiable observable list.
 445      * @param &lt;E&gt; The type of List to be wrapped
 446      * @return An empty unmodifiable observable list
 447      * @see Collections#emptyList()
 448      */
 449     @SuppressWarnings(&quot;unchecked&quot;)
 450     public static&lt;E&gt; ObservableList&lt;E&gt; emptyObservableList() {
 451         return EMPTY_OBSERVABLE_LIST;
 452     }
 453 
 454     /**
 455      * Creates an unmodifiable observable list with single element.
 456      * @param &lt;E&gt; The type of List to be wrapped
 457      * @param e the only elements that will be contained in this singleton observable list
 458      * @return a singleton observable list
 459      * @see Collections#singletonList(java.lang.Object)
 460      */
 461     public static&lt;E&gt; ObservableList&lt;E&gt; singletonObservableList(E e) {
 462         return new SingletonObservableList&lt;E&gt;(e);
 463     }
 464 
 465     /**
 466      * Creates and returns unmodifiable wrapper on top of provided observable set.
 467      * @param &lt;E&gt; The type of List to be wrapped
 468      * @param set an ObservableSet that is to be wrapped
 469      * @return an ObserableSet wrapper that is unmodifiable
 470      * @see Collections#unmodifiableSet(java.util.Set)
 471      * @since JavaFX 8.0
 472      */
 473     public static&lt;E&gt; ObservableSet&lt;E&gt; unmodifiableObservableSet(ObservableSet&lt;E&gt; set) {
 474         if (set == null) {
 475             throw new NullPointerException();
 476         }
 477         return new UnmodifiableObservableSet&lt;E&gt;(set);
 478     }
 479 
 480     /**
 481      * Creates and returns a typesafe wrapper on top of provided observable set.
 482      * @param &lt;E&gt; The type of List to be wrapped
 483      * @param set an Observable set to be wrapped
 484      * @param type  the type of element that {@code set} is permitted to hold
 485      * @return a dynamically typesafe view of the specified set
 486      * @see Collections#checkedSet(java.util.Set, java.lang.Class)
 487      * @since JavaFX 8.0
 488      */
 489     public static&lt;E&gt; ObservableSet&lt;E&gt; checkedObservableSet(ObservableSet&lt;E&gt; set, Class&lt;E&gt; type) {
 490         if (set == null) {
 491             throw new NullPointerException();
 492         }
 493         return new CheckedObservableSet&lt;E&gt;(set, type);
 494     }
 495 
 496     /**
 497      * Creates and returns a synchronized wrapper on top of provided observable set.
 498      * @param &lt;E&gt; The type of List to be wrapped
 499      * @param  set the set to be &quot;wrapped&quot; in a synchronized set.
 500      * @return A synchronized version of the observable set
 501      * @see Collections#synchronizedSet(java.util.Set)
 502      * @since JavaFX 8.0
 503      */
 504     public static&lt;E&gt; ObservableSet&lt;E&gt; synchronizedObservableSet(ObservableSet&lt;E&gt; set) {
 505         if (set == null) {
 506             throw new NullPointerException();
 507         }
 508         return new SynchronizedObservableSet&lt;E&gt;(set);
 509     }
 510 
 511     private static ObservableSet EMPTY_OBSERVABLE_SET = new EmptyObservableSet();
 512 
 513     /**
 514      * Creates an empty unmodifiable observable set.
 515      * @param &lt;E&gt; The type of List to be wrapped
 516      * @return An empty unmodifiable observable set
 517      * @see Collections#emptySet()
 518      * @since JavaFX 8.0
 519      */
 520     @SuppressWarnings(&quot;unchecked&quot;)
 521     public static&lt;E&gt; ObservableSet&lt;E&gt; emptyObservableSet() {
 522         return EMPTY_OBSERVABLE_SET;
 523     }
 524 
 525     /**
 526      * Copies elements from src to dest. Fires only &lt;b&gt;one&lt;/b&gt; change notification on dest.
 527      * @param &lt;T&gt; The type of List to be wrapped
 528      * @param dest the destination observable list
 529      * @param src the source list
 530      * @see Collections#copy(java.util.List, java.util.List)
 531      */
 532     @SuppressWarnings(&quot;unchecked&quot;)
 533     public static &lt;T&gt; void copy(ObservableList&lt;? super T&gt; dest, List&lt;? extends T&gt; src) {
 534         final int srcSize = src.size();
 535         if (srcSize &gt; dest.size()) {
 536             throw new IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;);
 537         }
 538         T[] destArray = (T[]) dest.toArray();
 539         System.arraycopy(src.toArray(), 0, destArray, 0, srcSize);
 540         dest.setAll(destArray);
 541     }
 542 
 543     /**
 544      * Fills the provided list with obj. Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 545      * @param &lt;T&gt; The type of List to be wrapped
 546      * @param list the list to fill
 547      * @param obj the object to fill the list with
 548      * @see Collections#fill(java.util.List, java.lang.Object)
 549      */
 550     @SuppressWarnings(&quot;unchecked&quot;)
 551     public static &lt;T&gt; void fill(ObservableList&lt;? super T&gt; list, T obj) {
 552         T[] newContent = (T[]) new Object[list.size()];
 553         Arrays.fill(newContent, obj);
 554         list.setAll(newContent);
 555     }
 556 
 557     /**
 558      * Replace all oldVal elements in the list with newVal element.
 559      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 560      * @param &lt;T&gt; The type of List to be wrapped
 561      * @param list the list which will have it&#39;s elements replaced
 562      * @param oldVal the element that is going to be replace
 563      * @param newVal the replacement
 564      * @return true if the list was modified
 565      * @see Collections#replaceAll(java.util.List, java.lang.Object, java.lang.Object)
 566      */
 567     @SuppressWarnings(&quot;unchecked&quot;)
 568     public static &lt;T&gt; boolean replaceAll(ObservableList&lt;T&gt; list, T oldVal, T newVal) {
 569         T[] newContent = (T[]) list.toArray();
 570         boolean modified = false;
 571         for (int i = 0 ; i &lt; newContent.length; ++i) {
 572             if (newContent[i].equals(oldVal)) {
 573                 newContent[i] = newVal;
 574                 modified = true;
 575             }
 576         }
 577         if (modified) {
 578             list.setAll(newContent);
 579         }
 580         return modified;
 581     }
 582 
 583     /**
 584      * Reverses the order in the list.
 585      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 586      * @param list the list to be reversed
 587      * @see Collections#reverse(java.util.List)
 588      */
 589     @SuppressWarnings(&quot;unchecked&quot;)
 590     public static void reverse(ObservableList list) {
 591         Object[] newContent = list.toArray();
 592         for (int i = 0; i &lt; newContent.length / 2; ++i) {
 593             Object tmp = newContent[i];
 594             newContent[i] = newContent[newContent.length - i - 1];
 595             newContent[newContent.length -i - 1] = tmp;
 596         }
 597         list.setAll(newContent);
 598     }
 599 
 600     /**
 601      * Rotates the list by distance.
 602      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 603      * @param list the list to be rotated
 604      * @param distance the distance of rotation
 605      * @see Collections#rotate(java.util.List, int)
 606      */
 607     @SuppressWarnings(&quot;unchecked&quot;)
 608     public static void rotate(ObservableList list, int distance) {
 609         Object[] newContent = list.toArray();
 610 
 611         int size = list.size();
 612         distance = distance % size;
 613         if (distance &lt; 0)
 614             distance += size;
 615         if (distance == 0)
 616             return;
 617 
 618         for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) {
 619             Object displaced = newContent[cycleStart];
 620             Object tmp;
 621             int i = cycleStart;
 622             do {
 623                 i += distance;
 624                 if (i &gt;= size)
 625                     i -= size;
 626                 tmp = newContent[i];
 627                 newContent[i] = displaced;
 628                 displaced = tmp;
 629                 nMoved ++;
 630             } while(i != cycleStart);
 631         }
 632         list.setAll(newContent);
 633     }
 634 
 635     /**
 636      * Shuffles all elements in the observable list.
 637      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 638      * @param list the list to shuffle
 639      * @see Collections#shuffle(java.util.List)
 640      */
 641     public static void shuffle(ObservableList&lt;?&gt; list) {
 642         if (r == null) {
 643             r = new Random();
 644         }
 645         shuffle(list, r);
 646     }
 647     private static Random r;
 648 
 649     /**
 650      * Shuffles all elements in the observable list.
 651      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 652      * @param list the list to be shuffled
 653      * @param rnd the random generator used for shuffling
 654      * @see Collections#shuffle(java.util.List, java.util.Random)
 655      */
 656     @SuppressWarnings(&quot;unchecked&quot;)
 657     public static void shuffle(ObservableList list, Random rnd) {
 658         Object newContent[] = list.toArray();
 659 
 660         for (int i = list.size(); i &gt; 1; i--) {
 661             swap(newContent, i - 1, rnd.nextInt(i));
 662         }
 663 
 664         list.setAll(newContent);
 665     }
 666 
 667     private static void swap(Object[] arr, int i, int j) {
 668         Object tmp = arr[i];
 669         arr[i] = arr[j];
 670         arr[j] = tmp;
 671     }
 672 
 673     /**
 674      * Sorts the provided observable list.
 675      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 676      * @param &lt;T&gt; The type of List to be wrapped
 677      * @param list the list to be sorted
 678      * @see Collections#sort(java.util.List)
 679      */
 680     @SuppressWarnings(&quot;unchecked&quot;)
 681     public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(ObservableList&lt;T&gt; list) {
 682         if (list instanceof SortableList) {
 683             ((SortableList&lt;? extends T&gt;)list).sort();
 684         } else {
 685             List&lt;T&gt; newContent = new ArrayList&lt;T&gt;(list);
 686             Collections.sort(newContent);
 687             list.setAll((Collection&lt;T&gt;)newContent);
 688         }
 689     }
 690 
 691     /**
 692      * Sorts the provided observable list using the c comparator.
 693      * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
 694      * @param &lt;T&gt; The type of List to be wrapped
 695      * @param list the list to sort
 696      * @param c comparator used for sorting. Null if natural ordering is required.
 697      * @see Collections#sort(java.util.List, java.util.Comparator)
 698      */
 699     @SuppressWarnings(&quot;unchecked&quot;)
 700     public static &lt;T&gt; void sort(ObservableList&lt;T&gt; list, Comparator&lt;? super T&gt; c) {
 701         if (list instanceof SortableList) {
 702             ((SortableList&lt;? extends T&gt;)list).sort(c);
 703         } else {
 704             List&lt;T&gt; newContent = new ArrayList&lt;T&gt;(list);
 705             Collections.sort(newContent, c);
 706             list.setAll((Collection&lt;T&gt;)newContent);
 707         }
 708     }
 709 
 710     private static class EmptyObservableList&lt;E&gt; extends AbstractList&lt;E&gt; implements ObservableList&lt;E&gt; {
 711 
 712         private static final ListIterator iterator = new ListIterator() {
 713 
 714             @Override
 715             public boolean hasNext() {
 716                 return false;
 717             }
 718 
 719             @Override
 720             public Object next() {
 721                 throw new NoSuchElementException();
 722             }
 723 
 724             @Override
 725             public void remove() {
 726                 throw new UnsupportedOperationException();
 727             }
 728 
 729             @Override
 730             public boolean hasPrevious() {
 731                 return false;
 732             }
 733 
 734             @Override
 735             public Object previous() {
 736                 throw new NoSuchElementException();
 737             }
 738 
 739             @Override
 740             public int nextIndex() {
 741                 return 0;
 742             }
 743 
 744             @Override
 745             public int previousIndex() {
 746                 return -1;
 747             }
 748 
 749             @Override
 750             public void set(Object e) {
 751                 throw new UnsupportedOperationException();
 752             }
 753 
 754             @Override
 755             public void add(Object e) {
 756                 throw new UnsupportedOperationException();
 757             }
 758         };
 759 
 760         public EmptyObservableList() {
 761         }
 762 
 763         @Override
 764         public final void addListener(InvalidationListener listener) {
 765         }
 766 
 767         @Override
 768         public final void removeListener(InvalidationListener listener) {
 769         }
 770 
 771 
 772         @Override
 773         public void addListener(ListChangeListener&lt;? super E&gt; o) {
 774         }
 775 
 776         @Override
 777         public void removeListener(ListChangeListener&lt;? super E&gt; o) {
 778         }
 779 
 780         @Override
 781         public int size() {
 782             return 0;
 783         }
 784 
 785         @Override
 786         public boolean contains(Object o) {
 787             return false;
 788         }
 789 
 790         @Override
 791         @SuppressWarnings(&quot;unchecked&quot;)
 792         public Iterator&lt;E&gt; iterator() {
 793             return iterator;
 794         }
 795 
 796         @Override
 797         public boolean containsAll(Collection&lt;?&gt; c) {
 798             return c.isEmpty();
 799         }
 800 
 801         @Override
 802         public E get(int index) {
 803             throw new IndexOutOfBoundsException();
 804         }
 805 
 806         @Override
 807         public int indexOf(Object o) {
 808             return -1;
 809         }
 810 
 811         @Override
 812         public int lastIndexOf(Object o) {
 813             return -1;
 814         }
 815 
 816         @Override
 817         @SuppressWarnings(&quot;unchecked&quot;)
 818         public ListIterator&lt;E&gt; listIterator() {
 819             return iterator;
 820         }
 821 
 822         @Override
 823         @SuppressWarnings(&quot;unchecked&quot;)
 824         public ListIterator&lt;E&gt; listIterator(int index) {
 825             if (index != 0) {
 826                 throw new IndexOutOfBoundsException();
 827             }
 828             return iterator;
 829         }
 830 
 831         @Override
 832         public List&lt;E&gt; subList(int fromIndex, int toIndex) {
 833             if (fromIndex != 0 || toIndex != 0) {
 834                 throw new IndexOutOfBoundsException();
 835             }
 836             return this;
 837         }
 838 
 839         @Override
 840         public boolean addAll(E... elements) {
 841             throw new UnsupportedOperationException();
 842         }
 843 
 844         @Override
 845         public boolean setAll(E... elements) {
 846             throw new UnsupportedOperationException();
 847         }
 848 
 849         @Override
 850         public boolean setAll(Collection&lt;? extends E&gt; col) {
 851             throw new UnsupportedOperationException();
 852         }
 853 
 854         @Override
 855         public boolean removeAll(E... elements) {
 856             throw new UnsupportedOperationException();
 857         }
 858 
 859         @Override
 860         public boolean retainAll(E... elements) {
 861             throw new UnsupportedOperationException();
 862         }
 863 
 864         @Override
 865         public void remove(int from, int to) {
 866             throw new UnsupportedOperationException();
 867         }
 868     }
 869 
 870     private static class SingletonObservableList&lt;E&gt; extends AbstractList&lt;E&gt; implements ObservableList&lt;E&gt; {
 871 
 872         private final E element;
 873 
 874         public SingletonObservableList(E element) {
 875             if (element == null) {
 876                 throw new NullPointerException();
 877             }
 878             this.element = element;
 879         }
 880 
 881         @Override
 882         public boolean addAll(E... elements) {
 883             throw new UnsupportedOperationException();
 884         }
 885 
 886         @Override
 887         public boolean setAll(E... elements) {
 888             throw new UnsupportedOperationException();
 889         }
 890 
 891         @Override
 892         public boolean setAll(Collection&lt;? extends E&gt; col) {
 893             throw new UnsupportedOperationException();
 894         }
 895 
 896         @Override
 897         public boolean removeAll(E... elements) {
 898             throw new UnsupportedOperationException();
 899         }
 900 
 901         @Override
 902         public boolean retainAll(E... elements) {
 903             throw new UnsupportedOperationException();
 904         }
 905 
 906         @Override
 907         public void remove(int from, int to) {
 908             throw new UnsupportedOperationException();
 909         }
 910 
 911         @Override
 912         public void addListener(InvalidationListener listener) {
 913         }
 914 
 915         @Override
 916         public void removeListener(InvalidationListener listener) {
 917         }
 918 
 919         @Override
 920         public void addListener(ListChangeListener&lt;? super E&gt; o) {
 921         }
 922 
 923         @Override
 924         public void removeListener(ListChangeListener&lt;? super E&gt; o) {
 925         }
 926 
 927         @Override
 928         public int size() {
 929             return 1;
 930         }
 931 
 932         @Override
 933         public boolean isEmpty() {
 934             return false;
 935         }
 936 
 937         @Override
 938         public boolean contains(Object o) {
 939             return element.equals(o);
 940         }
 941 
 942         @Override
 943         public E get(int index) {
 944             if (index != 0) {
 945                 throw new IndexOutOfBoundsException();
 946             }
 947             return element;
 948         }
 949 
 950     }
 951 
 952     private static class UnmodifiableObservableListImpl&lt;T&gt; extends ObservableListBase&lt;T&gt; implements ObservableList&lt;T&gt; {
 953 
 954         private final ObservableList&lt;T&gt; backingList;
 955         private final ListChangeListener&lt;T&gt; listener;
 956 
 957         public UnmodifiableObservableListImpl(ObservableList&lt;T&gt; backingList) {
 958             this.backingList = backingList;
 959             listener = c -&gt; {
 960                 fireChange(new SourceAdapterChange&lt;T&gt;(UnmodifiableObservableListImpl.this, c));
 961             };
 962             this.backingList.addListener(new WeakListChangeListener&lt;T&gt;(listener));
 963         }
 964 
 965         @Override
 966         public T get(int index) {
 967             return backingList.get(index);
 968         }
 969 
 970         @Override
 971         public int size() {
 972             return backingList.size();
 973         }
 974 
 975         @Override
 976         public boolean addAll(T... elements) {
 977             throw new UnsupportedOperationException();
 978         }
 979 
 980         @Override
 981         public boolean setAll(T... elements) {
 982             throw new UnsupportedOperationException();
 983         }
 984 
 985         @Override
 986         public boolean setAll(Collection&lt;? extends T&gt; col) {
 987             throw new UnsupportedOperationException();
 988         }
 989 
 990         @Override
 991         public boolean removeAll(T... elements) {
 992             throw new UnsupportedOperationException();
 993         }
 994 
 995         @Override
 996         public boolean retainAll(T... elements) {
 997             throw new UnsupportedOperationException();
 998         }
 999 
1000         @Override
1001         public void remove(int from, int to) {
1002             throw new UnsupportedOperationException();
1003         }
1004 
1005     }
1006 
1007     private static class SynchronizedList&lt;T&gt; implements List&lt;T&gt; {
1008         final Object mutex;
1009         private final List&lt;T&gt; backingList;
1010 
1011         SynchronizedList(List&lt;T&gt; list, Object mutex) {
1012             this.backingList = list;
1013             this.mutex = mutex;
1014         }
1015 
1016         SynchronizedList(List&lt;T&gt; list) {
1017             this.backingList = list;
1018             this.mutex = this;
1019         }
1020 
1021         @Override
1022         public int size() {
1023             synchronized(mutex) {
1024                 return backingList.size();
1025             }
1026         }
1027 
1028         @Override
1029         public boolean isEmpty() {
1030             synchronized(mutex) {
1031                 return backingList.isEmpty();
1032             }
1033         }
1034 
1035         @Override
1036         public boolean contains(Object o) {
1037             synchronized(mutex) {
1038                 return backingList.contains(o);
1039             }
1040         }
1041 
1042         @Override
1043         public Iterator&lt;T&gt; iterator() {
1044             return backingList.iterator();
1045         }
1046 
1047         @Override
1048         public Object[] toArray() {
1049             synchronized(mutex)  {
1050                 return backingList.toArray();
1051             }
1052         }
1053 
1054         @Override
1055         public &lt;T&gt; T[] toArray(T[] a) {
1056             synchronized(mutex) {
1057                 return backingList.toArray(a);
1058             }
1059         }
1060 
1061         @Override
1062         public boolean add(T e) {
1063             synchronized(mutex) {
1064                 return backingList.add(e);
1065             }
1066         }
1067 
1068         @Override
1069         public boolean remove(Object o) {
1070             synchronized(mutex) {
1071                 return backingList.remove(o);
1072             }
1073         }
1074 
1075         @Override
1076         public boolean containsAll(Collection&lt;?&gt; c) {
1077             synchronized(mutex) {
1078                 return backingList.containsAll(c);
1079             }
1080         }
1081 
1082         @Override
1083         public boolean addAll(Collection&lt;? extends T&gt; c) {
1084             synchronized(mutex) {
1085                 return backingList.addAll(c);
1086             }
1087         }
1088 
1089         @Override
1090         public boolean addAll(int index, Collection&lt;? extends T&gt; c) {
1091             synchronized(mutex) {
1092                 return backingList.addAll(index, c);
1093 
1094             }
1095         }
1096 
1097         @Override
1098         public boolean removeAll(Collection&lt;?&gt; c) {
1099             synchronized(mutex) {
1100                 return backingList.removeAll(c);
1101             }
1102         }
1103 
1104         @Override
1105         public boolean retainAll(Collection&lt;?&gt; c) {
1106             synchronized(mutex) {
1107                 return backingList.retainAll(c);
1108             }
1109         }
1110 
1111         @Override
1112         public void clear() {
1113             synchronized(mutex) {
1114                 backingList.clear();
1115             }
1116         }
1117 
1118         @Override
1119         public T get(int index) {
1120             synchronized(mutex) {
1121                 return backingList.get(index);
1122             }
1123         }
1124 
1125         @Override
1126         public T set(int index, T element) {
1127             synchronized(mutex) {
1128                 return backingList.set(index, element);
1129             }
1130         }
1131 
1132         @Override
1133         public void add(int index, T element) {
1134             synchronized(mutex) {
1135                 backingList.add(index, element);
1136             }
1137         }
1138 
1139         @Override
1140         public T remove(int index) {
1141             synchronized(mutex) {
1142                 return backingList.remove(index);
1143             }
1144         }
1145 
1146         @Override
1147         public int indexOf(Object o) {
1148             synchronized(mutex) {
1149                 return backingList.indexOf(o);
1150             }
1151         }
1152 
1153         @Override
1154         public int lastIndexOf(Object o) {
1155             synchronized(mutex) {
1156                 return backingList.lastIndexOf(o);
1157             }
1158         }
1159 
1160         @Override
1161         public ListIterator&lt;T&gt; listIterator() {
1162             return backingList.listIterator();
1163         }
1164 
1165         @Override
1166         public ListIterator&lt;T&gt; listIterator(int index) {
1167             synchronized(mutex) {
1168                 return backingList.listIterator(index);
1169             }
1170         }
1171 
1172         @Override
1173         public List&lt;T&gt; subList(int fromIndex, int toIndex) {
1174             synchronized(mutex) {
1175                 return new SynchronizedList&lt;T&gt;(backingList.subList(fromIndex, toIndex),
1176                         mutex);
1177             }
1178         }
1179 
1180         @Override
1181         public String toString() {
1182             synchronized(mutex) {
1183                 return backingList.toString();
1184             }
1185         }
1186 
1187         @Override
1188         public int hashCode() {
1189             synchronized(mutex) {
1190                 return backingList.hashCode();
1191             }
1192         }
1193 
1194         @Override
1195         public boolean equals(Object o) {
1196             synchronized(mutex) {
1197                 return backingList.equals(o);
1198             }
1199         }
1200 
1201     }
1202 
1203     private static class SynchronizedObservableList&lt;T&gt; extends SynchronizedList&lt;T&gt; implements ObservableList&lt;T&gt; {
1204 
1205         private ListListenerHelper helper;
1206 
1207         private final ObservableList&lt;T&gt; backingList;
1208         private final ListChangeListener&lt;T&gt; listener;
1209 
1210         SynchronizedObservableList(ObservableList&lt;T&gt; seq) {
1211             super(seq);
1212             this.backingList = seq;
1213             listener = c -&gt; {
1214                 ListListenerHelper.fireValueChangedEvent(helper, new SourceAdapterChange&lt;T&gt;(SynchronizedObservableList.this, c));
1215             };
1216             backingList.addListener(new WeakListChangeListener&lt;T&gt;(listener));
1217         }
1218 
1219         @Override
1220         public boolean addAll(T... elements) {
1221             synchronized(mutex) {
1222                 return backingList.addAll(elements);
1223             }
1224         }
1225 
1226         @Override
1227         public boolean setAll(T... elements) {
1228             synchronized(mutex) {
1229                 return backingList.setAll(elements);
1230             }
1231         }
1232 
1233         @Override
1234         public boolean removeAll(T... elements) {
1235             synchronized(mutex) {
1236                 return backingList.removeAll(elements);
1237             }
1238         }
1239 
1240         @Override
1241         public boolean retainAll(T... elements) {
1242             synchronized(mutex) {
1243                 return backingList.retainAll(elements);
1244             }
1245         }
1246 
1247         @Override
1248         public void remove(int from, int to) {
1249             synchronized(mutex) {
1250                 backingList.remove(from, to);
1251             }
1252         }
1253 
1254         @Override
1255         public boolean setAll(Collection&lt;? extends T&gt; col) {
1256             synchronized(mutex) {
1257                 return backingList.setAll(col);
1258             }
1259         }
1260 
1261         @Override
1262         public final void addListener(InvalidationListener listener) {
1263             synchronized (mutex) {
1264                 helper = ListListenerHelper.addListener(helper, listener);
1265             }
1266         }
1267 
1268         @Override
1269         public final void removeListener(InvalidationListener listener) {
1270             synchronized (mutex) {
1271                 helper = ListListenerHelper.removeListener(helper, listener);
1272             }
1273         }
1274 
1275         @Override
1276         public void addListener(ListChangeListener&lt;? super T&gt; listener) {
1277             synchronized (mutex) {
1278                 helper = ListListenerHelper.addListener(helper, listener);
1279             }
1280         }
1281 
1282         @Override
1283         public void removeListener(ListChangeListener&lt;? super T&gt; listener) {
1284             synchronized (mutex) {
1285                 helper = ListListenerHelper.removeListener(helper, listener);
1286             }
1287         }
1288 
1289 
1290     }
1291 
1292     private static class CheckedObservableList&lt;T&gt; extends ObservableListBase&lt;T&gt; implements ObservableList&lt;T&gt; {
1293 
1294         private final ObservableList&lt;T&gt; list;
1295         private final Class&lt;T&gt; type;
1296         private final ListChangeListener&lt;T&gt; listener;
1297 
1298         CheckedObservableList(ObservableList&lt;T&gt; list, Class&lt;T&gt; type) {
1299             if (list == null || type == null) {
1300                 throw new NullPointerException();
1301             }
1302             this.list = list;
1303             this.type = type;
1304             listener = c -&gt; {
1305                 fireChange(new SourceAdapterChange&lt;T&gt;(CheckedObservableList.this, c));
1306             };
1307             list.addListener(new WeakListChangeListener&lt;T&gt;(listener));
1308         }
1309 
1310         void typeCheck(Object o) {
1311             if (o != null &amp;&amp; !type.isInstance(o)) {
1312                 throw new ClassCastException(&quot;Attempt to insert &quot;
1313                         + o.getClass() + &quot; element into collection with element type &quot;
1314                         + type);
1315             }
1316         }
1317 
1318         @Override
1319         public int size() {
1320             return list.size();
1321         }
1322 
1323         @Override
1324         public boolean isEmpty() {
1325             return list.isEmpty();
1326         }
1327 
1328         @Override
1329         public boolean contains(Object o) {
1330             return list.contains(o);
1331         }
1332 
1333         @Override
1334         public Object[] toArray() {
1335             return list.toArray();
1336         }
1337 
1338         @Override
1339         public &lt;T&gt; T[] toArray(T[] a) {
1340             return list.toArray(a);
1341         }
1342 
1343         @Override
1344         public String toString() {
1345             return list.toString();
1346         }
1347 
1348         @Override
1349         public boolean remove(Object o) {
1350             return list.remove(o);
1351         }
1352 
1353         @Override
1354         public boolean containsAll(Collection&lt;?&gt; coll) {
1355             return list.containsAll(coll);
1356         }
1357 
1358         @Override
1359         public boolean removeAll(Collection&lt;?&gt; coll) {
1360             return list.removeAll(coll);
1361         }
1362 
1363         @Override
1364         public boolean retainAll(Collection&lt;?&gt; coll) {
1365             return list.retainAll(coll);
1366         }
1367 
1368         @Override
1369         public boolean removeAll(T... elements) {
1370             return list.removeAll(elements);
1371         }
1372 
1373         @Override
1374         public boolean retainAll(T... elements) {
1375             return list.retainAll(elements);
1376         }
1377 
1378         @Override
1379         public void remove(int from, int to) {
1380             list.remove(from, to);
1381         }
1382 
1383         @Override
1384         public void clear() {
1385             list.clear();
1386         }
1387 
1388         @Override
1389         public boolean equals(Object o) {
1390             return o == this || list.equals(o);
1391         }
1392 
1393         @Override
1394         public int hashCode() {
1395             return list.hashCode();
1396         }
1397 
1398         @Override
1399         public T get(int index) {
1400             return list.get(index);
1401         }
1402 
1403         @Override
1404         public T remove(int index) {
1405             return list.remove(index);
1406         }
1407 
1408         @Override
1409         public int indexOf(Object o) {
1410             return list.indexOf(o);
1411         }
1412 
1413         @Override
1414         public int lastIndexOf(Object o) {
1415             return list.lastIndexOf(o);
1416         }
1417 
1418         @Override
1419         public T set(int index, T element) {
1420             typeCheck(element);
1421             return list.set(index, element);
1422         }
1423 
1424         @Override
1425         public void add(int index, T element) {
1426             typeCheck(element);
1427             list.add(index, element);
1428         }
1429 
1430         @Override
1431         @SuppressWarnings(&quot;unchecked&quot;)
1432         public boolean addAll(int index, Collection&lt;? extends T&gt; c) {
1433             T[] a = null;
1434             try {
1435                 a = c.toArray((T[]) Array.newInstance(type, 0));
1436             } catch (ArrayStoreException e) {
1437                 throw new ClassCastException();
1438             }
1439 
1440             return this.list.addAll(index, Arrays.asList(a));
1441         }
1442 
1443         @Override
1444         @SuppressWarnings(&quot;unchecked&quot;)
1445         public boolean addAll(Collection&lt;? extends T&gt; coll) {
1446             T[] a = null;
1447             try {
1448                 a = coll.toArray((T[]) Array.newInstance(type, 0));
1449             } catch (ArrayStoreException e) {
1450                 throw new ClassCastException();
1451             }
1452 
1453             return this.list.addAll(Arrays.asList(a));
1454         }
1455 
1456         @Override
1457         public ListIterator&lt;T&gt; listIterator() {
1458             return listIterator(0);
1459         }
1460 
1461         @Override
1462         public ListIterator&lt;T&gt; listIterator(final int index) {
1463             return new ListIterator&lt;T&gt;() {
1464 
1465                 ListIterator&lt;T&gt; i = list.listIterator(index);
1466 
1467                 @Override
1468                 public boolean hasNext() {
1469                     return i.hasNext();
1470                 }
1471 
1472                 @Override
1473                 public T next() {
1474                     return i.next();
1475                 }
1476 
1477                 @Override
1478                 public boolean hasPrevious() {
1479                     return i.hasPrevious();
1480                 }
1481 
1482                 @Override
1483                 public T previous() {
1484                     return i.previous();
1485                 }
1486 
1487                 @Override
1488                 public int nextIndex() {
1489                     return i.nextIndex();
1490                 }
1491 
1492                 @Override
1493                 public int previousIndex() {
1494                     return i.previousIndex();
1495                 }
1496 
1497                 @Override
1498                 public void remove() {
1499                     i.remove();
1500                 }
1501 
1502                 @Override
1503                 public void set(T e) {
1504                     typeCheck(e);
1505                     i.set(e);
1506                 }
1507 
1508                 @Override
1509                 public void add(T e) {
1510                     typeCheck(e);
1511                     i.add(e);
1512                 }
1513             };
1514         }
1515 
1516         @Override
1517         public Iterator&lt;T&gt; iterator() {
1518             return new Iterator&lt;T&gt;() {
1519 
1520                 private final Iterator&lt;T&gt; it = list.iterator();
1521 
1522                 @Override
1523                 public boolean hasNext() {
1524                     return it.hasNext();
1525                 }
1526 
1527                 @Override
1528                 public T next() {
1529                     return it.next();
1530                 }
1531 
1532                 @Override
1533                 public void remove() {
1534                     it.remove();
1535                 }
1536             };
1537         }
1538 
1539         @Override
1540         public boolean add(T e) {
1541             typeCheck(e);
1542             return list.add(e);
1543         }
1544 
1545         @Override
1546         public List&lt;T&gt; subList(int fromIndex, int toIndex) {
1547             return Collections.checkedList(list.subList(fromIndex, toIndex), type);
1548         }
1549 
1550         @Override
1551         @SuppressWarnings(&quot;unchecked&quot;)
1552         public boolean addAll(T... elements) {
1553             try {
1554                 T[] array = (T[]) Array.newInstance(type, elements.length);
1555                 System.arraycopy(elements, 0, array, 0, elements.length);
1556                 return list.addAll(array);
1557             } catch (ArrayStoreException e) {
1558                 throw new ClassCastException();
1559             }
1560         }
1561 
1562         @Override
1563         @SuppressWarnings(&quot;unchecked&quot;)
1564         public boolean setAll(T... elements) {
1565             try {
1566                 T[] array = (T[]) Array.newInstance(type, elements.length);
1567                 System.arraycopy(elements, 0, array, 0, elements.length);
1568                 return list.setAll(array);
1569             } catch (ArrayStoreException e) {
1570                 throw new ClassCastException();
1571             }
1572         }
1573 
1574         @Override
1575         @SuppressWarnings(&quot;unchecked&quot;)
1576         public boolean setAll(Collection&lt;? extends T&gt; col) {
1577             T[] a = null;
1578             try {
1579                 a = col.toArray((T[]) Array.newInstance(type, 0));
1580             } catch (ArrayStoreException e) {
1581                 throw new ClassCastException();
1582             }
1583 
1584             return list.setAll(Arrays.asList(a));
1585         }
1586     }
1587 
1588     private static class EmptyObservableSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements ObservableSet&lt;E&gt; {
1589 
1590         public EmptyObservableSet() {
1591         }
1592 
1593         @Override
1594         public void addListener(InvalidationListener listener) {
1595         }
1596 
1597         @Override
1598         public void removeListener(InvalidationListener listener) {
1599         }
1600 
1601         @Override
1602         public void addListener(SetChangeListener&lt;? super E&gt; listener) {
1603         }
1604 
1605         @Override
1606         public void removeListener(SetChangeListener&lt;? super E&gt; listener) {
1607         }
1608 
1609         @Override
1610         public int size() {
1611             return 0;
1612         }
1613 
1614         @Override
1615         public boolean isEmpty() {
1616             return true;
1617         }
1618 
1619         @Override
1620         public boolean contains(Object obj) {
1621             return false;
1622         }
1623 
1624         @Override
1625         public boolean containsAll(Collection&lt;?&gt; c) {
1626             return c.isEmpty();
1627         }
1628 
1629         @Override
1630         public Object[] toArray() {
1631             return new Object[0];
1632         }
1633 
1634         @Override
1635         public &lt;E&gt; E[] toArray(E[] a) {
1636             if (a.length &gt; 0)
1637                 a[0] = null;
1638             return a;
1639         }
1640 
1641         @Override
1642         public Iterator&lt;E&gt; iterator() {
1643             return new Iterator() {
1644 
1645                 @Override
1646                 public boolean hasNext() {
1647                     return false;
1648                 }
1649 
1650                 @Override
1651                 public Object next() {
1652                     throw new NoSuchElementException();
1653                 }
1654 
1655                 @Override
1656                 public void remove() {
1657                     throw new UnsupportedOperationException();
1658                 }
1659             };
1660         }
1661 
1662     }
1663 
1664     private static class UnmodifiableObservableSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements ObservableSet&lt;E&gt; {
1665 
1666         private final ObservableSet&lt;E&gt; backingSet;
1667         private SetListenerHelper&lt;E&gt; listenerHelper;
1668         private SetChangeListener&lt;E&gt; listener;
1669 
1670         public UnmodifiableObservableSet(ObservableSet&lt;E&gt; backingSet) {
1671             this.backingSet = backingSet;
1672             this.listener = null;
1673         }
1674 
1675         private void initListener() {
1676             if (listener == null) {
1677                 listener = c -&gt; {
1678                     callObservers(new SetAdapterChange&lt;E&gt;(UnmodifiableObservableSet.this, c));
1679                 };
1680                 this.backingSet.addListener(new WeakSetChangeListener&lt;E&gt;(listener));
1681             }
1682         }
1683 
1684         private void callObservers(SetChangeListener.Change&lt;? extends E&gt; change) {
1685             SetListenerHelper.fireValueChangedEvent(listenerHelper, change);
1686         }
1687 
1688         @Override
1689         public Iterator&lt;E&gt; iterator() {
1690             return new Iterator&lt;E&gt;() {
1691                 private final Iterator&lt;? extends E&gt; i = backingSet.iterator();
1692 
1693                 @Override
1694                 public boolean hasNext() {
1695                     return i.hasNext();
1696                 }
1697 
1698                 @Override
1699                 public E next() {
1700                     return i.next();
1701                 }
1702             };
1703         }
1704 
1705         @Override
1706         public int size() {
1707             return backingSet.size();
1708         }
1709 
1710         @Override
1711         public boolean isEmpty() {
1712             return backingSet.isEmpty();
1713         }
1714 
1715         @Override
1716         public boolean contains(Object o) {
1717             return backingSet.contains(o);
1718         }
1719 
1720         @Override
1721         public void addListener(InvalidationListener listener) {
1722             initListener();
1723             listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1724         }
1725 
1726         @Override
1727         public void removeListener(InvalidationListener listener) {
1728             listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1729         }
1730 
1731         @Override
1732         public void addListener(SetChangeListener&lt;? super E&gt; listener) {
1733             initListener();
1734             listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1735         }
1736 
1737         @Override
1738         public void removeListener(SetChangeListener&lt;? super E&gt; listener) {
1739             listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1740         }
1741 
1742         @Override
1743         public boolean add(E e) {
1744             throw new UnsupportedOperationException();
1745         }
1746 
1747         @Override
1748         public boolean remove(Object o) {
1749             throw new UnsupportedOperationException();
1750         }
1751 
1752         @Override
1753         public boolean addAll(Collection&lt;? extends E&gt; c) {
1754             throw new UnsupportedOperationException();
1755         }
1756 
1757         @Override
1758         public boolean retainAll(Collection&lt;?&gt; c) {
1759             throw new UnsupportedOperationException();
1760         }
1761 
1762         @Override
1763         public boolean removeAll(Collection&lt;?&gt; c) {
1764             throw new UnsupportedOperationException();
1765         }
1766 
1767         @Override
1768         public void clear() {
1769             throw new UnsupportedOperationException();
1770         }
1771     }
1772 
1773     private static class SynchronizedSet&lt;E&gt; implements Set&lt;E&gt; {
1774         final Object mutex;
1775         private final Set&lt;E&gt; backingSet;
1776 
1777         SynchronizedSet(Set&lt;E&gt; set, Object mutex) {
1778             this.backingSet = set;
1779             this.mutex = mutex;
1780         }
1781 
1782         SynchronizedSet(Set&lt;E&gt; set) {
1783             this.backingSet = set;
1784             this.mutex = this;
1785         }
1786 
1787         @Override
1788         public int size() {
1789             synchronized(mutex) {
1790                 return backingSet.size();
1791             }
1792         }
1793 
1794         @Override
1795         public boolean isEmpty() {
1796             synchronized(mutex) {
1797                 return backingSet.isEmpty();
1798             }
1799         }
1800 
1801         @Override
1802         public boolean contains(Object o) {
1803             synchronized(mutex) {
1804                 return backingSet.contains(o);
1805             }
1806         }
1807 
1808         @Override
1809         public Iterator&lt;E&gt; iterator() {
1810             return backingSet.iterator();
1811         }
1812 
1813         @Override
1814         public Object[] toArray() {
1815             synchronized(mutex) {
1816                 return backingSet.toArray();
1817             }
1818         }
1819 
1820         @Override
1821         public &lt;E&gt; E[] toArray(E[] a) {
1822             synchronized(mutex) {
1823                 return backingSet.toArray(a);
1824             }
1825         }
1826 
1827         @Override
1828         public boolean add(E e) {
1829             synchronized(mutex) {
1830                 return backingSet.add(e);
1831             }
1832         }
1833 
1834         @Override
1835         public boolean remove(Object o) {
1836             synchronized(mutex) {
1837                 return backingSet.remove(o);
1838             }
1839         }
1840 
1841         @Override
1842         public boolean containsAll(Collection&lt;?&gt; c) {
1843             synchronized(mutex) {
1844                 return backingSet.containsAll(c);
1845             }
1846         }
1847 
1848         @Override
1849         public boolean addAll(Collection&lt;? extends E&gt; c) {
1850             synchronized(mutex) {
1851                 return backingSet.addAll(c);
1852             }
1853         }
1854 
1855         @Override
1856         public boolean retainAll(Collection&lt;?&gt; c) {
1857             synchronized(mutex) {
1858                 return backingSet.retainAll(c);
1859             }
1860         }
1861 
1862         @Override
1863         public boolean removeAll(Collection&lt;?&gt; c) {
1864             synchronized(mutex) {
1865                 return backingSet.removeAll(c);
1866             }
1867         }
1868 
1869         @Override
1870         public void clear() {
1871             synchronized(mutex) {
1872                 backingSet.clear();
1873             }
1874         }
1875 
1876         @Override
1877         public boolean equals(Object o) {
1878             if (o == this) {
1879                 return true;
1880             }
1881             synchronized(mutex) {
1882                 return backingSet.equals(o);
1883             }
1884         }
1885 
1886         @Override
1887         public int hashCode() {
1888             synchronized (mutex) {
1889                 return backingSet.hashCode();
1890             }
1891         }
1892     }
1893 
1894     private static class SynchronizedObservableSet&lt;E&gt; extends SynchronizedSet&lt;E&gt; implements ObservableSet&lt;E&gt; {
1895 
1896         private final ObservableSet&lt;E&gt; backingSet;
1897         private SetListenerHelper listenerHelper;
1898         private final SetChangeListener&lt;E&gt; listener;
1899 
1900         SynchronizedObservableSet(ObservableSet&lt;E&gt; set) {
1901             super(set);
1902             backingSet = set;
1903             listener = c -&gt; {
1904                 SetListenerHelper.fireValueChangedEvent(listenerHelper, new SetAdapterChange&lt;E&gt;(SynchronizedObservableSet.this, c));
1905             };
1906             backingSet.addListener(new WeakSetChangeListener&lt;E&gt;(listener));
1907         }
1908 
1909         @Override
1910         public void addListener(InvalidationListener listener) {
1911             synchronized (mutex) {
1912                 listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1913             }
1914         }
1915 
1916         @Override
1917         public void removeListener(InvalidationListener listener) {
1918             synchronized (mutex) {
1919                 listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1920             }
1921         }
1922         @Override
1923         public void addListener(SetChangeListener&lt;? super E&gt; listener) {
1924             synchronized (mutex) {
1925                 listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1926             }
1927         }
1928 
1929         @Override
1930         public void removeListener(SetChangeListener&lt;? super E&gt; listener) {
1931             synchronized (mutex) {
1932                 listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1933             }
1934         }
1935     }
1936 
1937     private static class CheckedObservableSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements ObservableSet&lt;E&gt; {
1938 
1939         private final ObservableSet&lt;E&gt; backingSet;
1940         private final Class&lt;E&gt; type;
1941         private SetListenerHelper listenerHelper;
1942         private final SetChangeListener&lt;E&gt; listener;
1943 
1944         CheckedObservableSet(ObservableSet&lt;E&gt; set, Class&lt;E&gt; type) {
1945             if (set == null || type == null) {
1946                 throw new NullPointerException();
1947             }
1948             backingSet = set;
1949             this.type = type;
1950             listener = c -&gt; {
1951                 callObservers(new SetAdapterChange&lt;E&gt;(CheckedObservableSet.this, c));
1952             };
1953             backingSet.addListener(new WeakSetChangeListener&lt;E&gt;(listener));
1954         }
1955 
1956         private void callObservers(SetChangeListener.Change&lt;? extends E&gt; c) {
1957             SetListenerHelper.fireValueChangedEvent(listenerHelper, c);
1958         }
1959 
1960         void typeCheck(Object o) {
1961             if (o != null &amp;&amp; !type.isInstance(o)) {
1962                 throw new ClassCastException(&quot;Attempt to insert &quot;
1963                         + o.getClass() + &quot; element into collection with element type &quot;
1964                         + type);
1965             }
1966         }
1967 
1968         @Override
1969         public void addListener(InvalidationListener listener) {
1970             listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1971         }
1972 
1973         @Override
1974         public void removeListener(InvalidationListener listener) {
1975             listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1976         }
1977 
1978         @Override
1979         public void addListener(SetChangeListener&lt;? super E&gt; listener) {
1980             listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
1981         }
1982 
1983         @Override
1984         public void removeListener(SetChangeListener&lt;? super E&gt; listener) {
1985             listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
1986         }
1987 
1988         @Override
1989         public int size() {
1990             return backingSet.size();
1991         }
1992 
1993         @Override
1994         public boolean isEmpty() {
1995             return backingSet.isEmpty();
1996         }
1997 
1998         @Override
1999         public boolean contains(Object o) {
2000             return backingSet.contains(o);
2001         }
2002 
2003         @Override
2004         public Object[] toArray() {
2005             return backingSet.toArray();
2006         }
2007 
2008         @Override
2009         public &lt;T&gt; T[] toArray(T[] a) {
2010             return backingSet.toArray(a);
2011         }
2012 
2013         @Override
2014         public boolean add(E e) {
2015             typeCheck(e);
2016             return backingSet.add(e);
2017         }
2018 
2019         @Override
2020         public boolean remove(Object o) {
2021             return backingSet.remove(o);
2022         }
2023 
2024         @Override
2025         public boolean containsAll(Collection&lt;?&gt; c) {
2026             return backingSet.containsAll(c);
2027         }
2028 
2029         @Override
2030         @SuppressWarnings(&quot;unchecked&quot;)
2031         public boolean addAll(Collection&lt;? extends E&gt; c) {
2032             E[] a = null;
2033             try {
2034                 a = c.toArray((E[]) Array.newInstance(type, 0));
2035             } catch (ArrayStoreException e) {
2036                 throw new ClassCastException();
2037             }
2038 
2039             return backingSet.addAll(Arrays.asList(a));
2040         }
2041 
2042         @Override
2043         public boolean retainAll(Collection&lt;?&gt; c) {
2044             return backingSet.retainAll(c);
2045         }
2046 
2047         @Override
2048         public boolean removeAll(Collection&lt;?&gt; c) {
2049             return backingSet.removeAll(c);
2050         }
2051 
2052         @Override
2053         public void clear() {
2054             backingSet.clear();
2055         }
2056 
2057         @Override
2058         public boolean equals(Object o) {
2059             return o == this || backingSet.equals(o);
2060         }
2061 
2062         @Override
2063         public int hashCode() {
2064             return backingSet.hashCode();
2065         }
2066 
2067         @Override
2068         public Iterator&lt;E&gt; iterator() {
2069             final Iterator&lt;E&gt; it = backingSet.iterator();
2070 
2071             return new Iterator&lt;E&gt;() {
2072                 @Override
2073                 public boolean hasNext() {
2074                     return it.hasNext();
2075                 }
2076 
2077                 @Override
2078                 public E next() {
2079                     return it.next();
2080                 }
2081 
2082                 @Override
2083                 public void remove() {
2084                     it.remove();
2085                 }
2086             };
2087         }
2088 
2089     }
2090 
2091     private static class EmptyObservableMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements ObservableMap&lt;K, V&gt; {
2092 
2093         public EmptyObservableMap() {
2094         }
2095 
2096         @Override
2097         public void addListener(InvalidationListener listener) {
2098         }
2099 
2100         @Override
2101         public void removeListener(InvalidationListener listener) {
2102         }
2103 
2104         @Override
2105         public void addListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2106         }
2107 
2108         @Override
2109         public void removeListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2110         }
2111 
2112         @Override
2113         public int size() {
2114             return 0;
2115         }
2116 
2117         @Override
2118         public boolean isEmpty() {
2119             return true;
2120         }
2121 
2122         @Override
2123         public boolean containsKey(Object key) {
2124             return false;
2125         }
2126 
2127         @Override
2128         public boolean containsValue(Object value) {
2129             return false;
2130         }
2131 
2132         @Override
2133         public V get(Object key) {
2134             return null;
2135         }
2136 
2137         @Override
2138         public Set&lt;K&gt; keySet() {
2139             return emptyObservableSet();
2140         }
2141 
2142         @Override
2143         public Collection&lt;V&gt; values() {
2144             return emptyObservableSet();
2145         }
2146 
2147         @Override
2148         public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
2149             return emptyObservableSet();
2150         }
2151 
2152         @Override
2153         public boolean equals(Object o) {
2154             return (o instanceof Map) &amp;&amp; ((Map&lt;?,?&gt;)o).isEmpty();
2155         }
2156 
2157         @Override
2158         public int hashCode() {
2159             return 0;
2160         }
2161     }
2162 
2163     private static class CheckedObservableMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements ObservableMap&lt;K, V&gt; {
2164 
2165         private final ObservableMap&lt;K, V&gt; backingMap;
2166         private final Class&lt;K&gt; keyType;
2167         private final Class&lt;V&gt; valueType;
2168         private MapListenerHelper listenerHelper;
2169         private final MapChangeListener&lt;K, V&gt; listener;
2170 
2171         CheckedObservableMap(ObservableMap&lt;K, V&gt; map, Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) {
2172             backingMap = map;
2173             this.keyType = keyType;
2174             this.valueType = valueType;
2175             listener = c -&gt; {
2176                 callObservers(new MapAdapterChange&lt;K, V&gt;(CheckedObservableMap.this, c));
2177             };
2178             backingMap.addListener(new WeakMapChangeListener&lt;K, V&gt;(listener));
2179         }
2180 
2181         private void callObservers(MapChangeListener.Change&lt;? extends K, ? extends V&gt; c) {
2182             MapListenerHelper.fireValueChangedEvent(listenerHelper, c);
2183         }
2184 
2185         void typeCheck(Object key, Object value) {
2186             if (key != null &amp;&amp; !keyType.isInstance(key)) {
2187                 throw new ClassCastException(&quot;Attempt to insert &quot;
2188                         + key.getClass() + &quot; key into map with key type &quot;
2189                         + keyType);
2190             }
2191 
2192             if (value != null &amp;&amp; !valueType.isInstance(value)) {
2193                 throw new ClassCastException(&quot;Attempt to insert &quot;
2194                         + value.getClass() + &quot; value into map with value type &quot;
2195                         + valueType);
2196             }
2197         }
2198 
2199         @Override
2200         public void addListener(InvalidationListener listener) {
2201             listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
2202         }
2203 
2204         @Override
2205         public void removeListener(InvalidationListener listener) {
2206             listenerHelper = MapListenerHelper.removeListener(listenerHelper, listener);
2207         }
2208 
2209         @Override
2210         public void addListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2211             listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
2212         }
2213 
2214         @Override
2215         public void removeListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2216             listenerHelper = MapListenerHelper.removeListener(listenerHelper, listener);
2217         }
2218 
2219         @Override
2220         public int size() {
2221             return backingMap.size();
2222         }
2223 
2224         @Override
2225         public boolean isEmpty() {
2226             return backingMap.isEmpty();
2227         }
2228 
2229         @Override
2230         public boolean containsKey(Object key) {
2231             return backingMap.containsKey(key);
2232         }
2233 
2234         @Override
2235         public boolean containsValue(Object value) {
2236             return backingMap.containsValue(value);
2237         }
2238 
2239         @Override
2240         public V get(Object key) {
2241             return backingMap.get(key);
2242         }
2243 
2244         @Override
2245         public V put(K key, V value) {
2246             typeCheck(key, value);
2247             return backingMap.put(key, value);
2248         }
2249 
2250         @Override
2251         public V remove(Object key) {
2252             return backingMap.remove(key);
2253         }
2254 
2255         @Override
2256         @SuppressWarnings(&quot;unchecked&quot;)
2257         public void putAll(Map t) {
2258             // Satisfy the following goals:
2259             // - good diagnostics in case of type mismatch
2260             // - all-or-nothing semantics
2261             // - protection from malicious t
2262             // - correct behavior if t is a concurrent map
2263             Object[] entries = t.entrySet().toArray();
2264             List&lt;Map.Entry&lt;K,V&gt;&gt; checked =
2265                 new ArrayList&lt;Map.Entry&lt;K,V&gt;&gt;(entries.length);
2266             for (Object o : entries) {
2267                 Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;
2268                 Object k = e.getKey();
2269                 Object v = e.getValue();
2270                 typeCheck(k, v);
2271                 checked.add(
2272                     new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;((K) k, (V) v));
2273             }
2274             for (Map.Entry&lt;K,V&gt; e : checked)
2275                 backingMap.put(e.getKey(), e.getValue());
2276         }
2277 
2278         @Override
2279         public void clear() {
2280             backingMap.clear();
2281         }
2282 
2283         @Override
2284         public Set&lt;K&gt; keySet() {
2285             return backingMap.keySet();
2286         }
2287 
2288         @Override
2289         public Collection&lt;V&gt; values() {
2290             return backingMap.values();
2291         }
2292 
2293         private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;
2294 
2295         @Override
2296         public Set entrySet() {
2297             if (entrySet==null)
2298                 entrySet = new CheckedEntrySet&lt;K,V&gt;(backingMap.entrySet(), valueType);
2299             return entrySet;
2300         }
2301 
2302         @Override
2303         public boolean equals(Object o) {
2304             return o == this || backingMap.equals(o);
2305         }
2306 
2307         @Override
2308         public int hashCode() {
2309             return backingMap.hashCode();
2310         }
2311 
2312         static class CheckedEntrySet&lt;K,V&gt; implements Set&lt;Map.Entry&lt;K,V&gt;&gt; {
2313             private final Set&lt;Map.Entry&lt;K,V&gt;&gt; s;
2314             private final Class&lt;V&gt; valueType;
2315 
2316             CheckedEntrySet(Set&lt;Map.Entry&lt;K, V&gt;&gt; s, Class&lt;V&gt; valueType) {
2317                 this.s = s;
2318                 this.valueType = valueType;
2319             }
2320 
2321             @Override
2322             public int size() {
2323                 return s.size();
2324             }
2325 
2326             @Override
2327             public boolean isEmpty() {
2328                 return s.isEmpty();
2329             }
2330 
2331             @Override
2332             public String toString() {
2333                 return s.toString();
2334             }
2335 
2336             @Override
2337             public int hashCode() {
2338                 return s.hashCode();
2339             }
2340 
2341             @Override
2342             public void clear() {
2343                 s.clear();
2344             }
2345 
2346             @Override
2347             public boolean add(Map.Entry&lt;K, V&gt; e) {
2348                 throw new UnsupportedOperationException();
2349             }
2350 
2351             @Override
2352             public boolean addAll(Collection&lt;? extends Map.Entry&lt;K, V&gt;&gt; coll) {
2353                 throw new UnsupportedOperationException();
2354             }
2355 
2356             @Override
2357             public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
2358                 final Iterator&lt;Map.Entry&lt;K, V&gt;&gt; i = s.iterator();
2359                 final Class&lt;V&gt; valueType = this.valueType;
2360 
2361                 return new Iterator&lt;Map.Entry&lt;K,V&gt;&gt;() {
2362                     @Override
2363                     public boolean hasNext() {
2364                         return i.hasNext();
2365                     }
2366 
2367                     @Override
2368                     public void remove() {
2369                         i.remove();
2370                     }
2371 
2372                     @Override
2373                     public Map.Entry&lt;K,V&gt; next() {
2374                         return checkedEntry(i.next(), valueType);
2375                     }
2376                 };
2377             }
2378 
2379             @Override
2380             @SuppressWarnings(&quot;unchecked&quot;)
2381             public Object[] toArray() {
2382                 Object[] source = s.toArray();
2383 
2384                 /*
2385                  * Ensure that we don&#39;t get an ArrayStoreException even if
2386                  * s.toArray returns an array of something other than Object
2387                  */
2388                 Object[] dest = (CheckedEntry.class.isInstance(
2389                     source.getClass().getComponentType()) ? source :
2390                                  new Object[source.length]);
2391 
2392                 for (int i = 0; i &lt; source.length; i++)
2393                     dest[i] = checkedEntry((Map.Entry&lt;K,V&gt;)source[i],
2394                                            valueType);
2395                 return dest;
2396             }
2397 
2398             @Override
2399             @SuppressWarnings(&quot;unchecked&quot;)
2400             public &lt;T&gt; T[] toArray(T[] a) {
2401                 // We don&#39;t pass a to s.toArray, to avoid window of
2402                 // vulnerability wherein an unscrupulous multithreaded client
2403                 // could get his hands on raw (unwrapped) Entries from s.
2404                 T[] arr = s.toArray(a.length==0 ? a : Arrays.copyOf(a, 0));
2405 
2406                 for (int i=0; i&lt;arr.length; i++)
2407                     arr[i] = (T) checkedEntry((Map.Entry&lt;K,V&gt;)arr[i],
2408                                               valueType);
2409                 if (arr.length &gt; a.length)
2410                     return arr;
2411 
2412                 System.arraycopy(arr, 0, a, 0, arr.length);
2413                 if (a.length &gt; arr.length)
2414                     a[arr.length] = null;
2415                 return a;
2416             }
2417 
2418             /**
2419              * This method is overridden to protect the backing set against
2420              * an object with a nefarious equals function that senses
2421              * that the equality-candidate is Map.Entry and calls its
2422              * setValue method.
2423              */
2424             @Override
2425             public boolean contains(Object o) {
2426                 if (!(o instanceof Map.Entry))
2427                     return false;
2428                 Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;
2429                 return s.contains(
2430                     (e instanceof CheckedEntry) ? e : checkedEntry(e, valueType));
2431             }
2432 
2433             /**
2434              * The bulk collection methods are overridden to protect
2435              * against an unscrupulous collection whose contains(Object o)
2436              * method senses when o is a Map.Entry, and calls o.setValue.
2437              */
2438             @Override
2439             public boolean containsAll(Collection&lt;?&gt; c) {
2440                 for (Object o : c)
2441                     if (!contains(o)) // Invokes safe contains() above
2442                         return false;
2443                 return true;
2444             }
2445 
2446             @Override
2447             public boolean remove(Object o) {
2448                 if (!(o instanceof Map.Entry))
2449                     return false;
2450                 return s.remove(new AbstractMap.SimpleImmutableEntry
2451                                 &lt;Object, Object&gt;((Map.Entry&lt;?,?&gt;)o));
2452             }
2453 
2454             @Override
2455             public boolean removeAll(Collection&lt;?&gt; c) {
2456                 return batchRemove(c, false);
2457             }
2458 
2459             @Override
2460             public boolean retainAll(Collection&lt;?&gt; c) {
2461                 return batchRemove(c, true);
2462             }
2463 
2464             private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {
2465                 boolean modified = false;
2466                 Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = iterator();
2467                 while (it.hasNext()) {
2468                     if (c.contains(it.next()) != complement) {
2469                         it.remove();
2470                         modified = true;
2471                     }
2472                 }
2473                 return modified;
2474             }
2475 
2476             @Override
2477             public boolean equals(Object o) {
2478                 if (o == this)
2479                     return true;
2480                 if (!(o instanceof Set))
2481                     return false;
2482                 Set&lt;?&gt; that = (Set&lt;?&gt;) o;
2483                 return that.size() == s.size()
2484                     &amp;&amp; containsAll(that); // Invokes safe containsAll() above
2485             }
2486 
2487             static &lt;K,V,T&gt; CheckedEntry&lt;K,V,T&gt; checkedEntry(Map.Entry&lt;K,V&gt; e,
2488                                                             Class&lt;T&gt; valueType) {
2489                 return new CheckedEntry&lt;K,V,T&gt;(e, valueType);
2490             }
2491 
2492             /**
2493              * This &quot;wrapper class&quot; serves two purposes: it prevents
2494              * the client from modifying the backing Map, by short-circuiting
2495              * the setValue method, and it protects the backing Map against
2496              * an ill-behaved Map.Entry that attempts to modify another
2497              * Map.Entry when asked to perform an equality check.
2498              */
2499             private static class CheckedEntry&lt;K,V,T&gt; implements Map.Entry&lt;K,V&gt; {
2500                 private final Map.Entry&lt;K, V&gt; e;
2501                 private final Class&lt;T&gt; valueType;
2502 
2503                 CheckedEntry(Map.Entry&lt;K, V&gt; e, Class&lt;T&gt; valueType) {
2504                     this.e = e;
2505                     this.valueType = valueType;
2506                 }
2507 
2508                 @Override
2509                 public K getKey() {
2510                     return e.getKey();
2511                 }
2512 
2513                 @Override
2514                 public V getValue() {
2515                     return e.getValue();
2516                 }
2517 
2518                 @Override
2519                 public int hashCode() {
2520                     return e.hashCode();
2521                 }
2522 
2523                 @Override
2524                 public String toString() {
2525                     return e.toString();
2526                 }
2527 
2528                 @Override
2529                 public V setValue(V value) {
2530                     if (value != null &amp;&amp; !valueType.isInstance(value))
2531                         throw new ClassCastException(badValueMsg(value));
2532                     return e.setValue(value);
2533                 }
2534 
2535                 private String badValueMsg(Object value) {
2536                     return &quot;Attempt to insert &quot; + value.getClass() +
2537                         &quot; value into map with value type &quot; + valueType;
2538                 }
2539 
2540                 @Override
2541                 public boolean equals(Object o) {
2542                     if (o == this)
2543                         return true;
2544                     if (!(o instanceof Map.Entry))
2545                         return false;
2546                     return e.equals(new AbstractMap.SimpleImmutableEntry
2547                                     &lt;Object, Object&gt;((Map.Entry&lt;?,?&gt;)o));
2548                 }
2549             }
2550         }
2551 
2552     }
2553 
2554     private static class SynchronizedMap&lt;K, V&gt; implements Map&lt;K, V&gt; {
2555         final Object mutex;
2556         private final Map&lt;K, V&gt; backingMap;
2557 
2558         SynchronizedMap(Map&lt;K, V&gt; map) {
2559             backingMap = map;
2560             this.mutex = this;
2561         }
2562 
2563         @Override
2564         public int size() {
2565             synchronized (mutex) {
2566                 return backingMap.size();
2567             }
2568         }
2569 
2570         @Override
2571         public boolean isEmpty() {
2572             synchronized (mutex) {
2573                 return backingMap.isEmpty();
2574             }
2575         }
2576 
2577         @Override
2578         public boolean containsKey(Object key) {
2579             synchronized (mutex) {
2580                 return backingMap.containsKey(key);
2581             }
2582         }
2583 
2584         @Override
2585         public boolean containsValue(Object value) {
2586             synchronized (mutex) {
2587                 return backingMap.containsValue(value);
2588             }
2589         }
2590 
2591         @Override
2592         public V get(Object key) {
2593             synchronized (mutex) {
2594                 return backingMap.get(key);
2595             }
2596         }
2597 
2598         @Override
2599         public V put(K key, V value) {
2600             synchronized (mutex) {
2601                 return backingMap.put(key, value);
2602             }
2603         }
2604 
2605         @Override
2606         public V remove(Object key) {
2607             synchronized (mutex) {
2608                 return backingMap.remove(key);
2609             }
2610         }
2611 
2612         @Override
2613         public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
2614             synchronized (mutex) {
2615                 backingMap.putAll(m);
2616             }
2617         }
2618 
2619         @Override
2620         public void clear() {
2621             synchronized (mutex) {
2622                 backingMap.clear();
2623             }
2624         }
2625 
2626         private transient Set&lt;K&gt; keySet = null;
2627         private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;
2628         private transient Collection&lt;V&gt; values = null;
2629 
2630         @Override
2631         public Set&lt;K&gt; keySet() {
2632             synchronized(mutex) {
2633                 if (keySet==null)
2634                     keySet = new SynchronizedSet&lt;K&gt;(backingMap.keySet(), mutex);
2635                 return keySet;
2636             }
2637         }
2638 
2639         @Override
2640         public Collection&lt;V&gt; values() {
2641             synchronized(mutex) {
2642                 if (values==null)
2643                     values = new SynchronizedCollection&lt;V&gt;(backingMap.values(), mutex);
2644                 return values;
2645             }
2646         }
2647 
2648         @Override
2649         public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {
2650             synchronized(mutex) {
2651                 if (entrySet==null)
2652                     entrySet = new SynchronizedSet&lt;Map.Entry&lt;K,V&gt;&gt;(backingMap.entrySet(), mutex);
2653                 return entrySet;
2654             }
2655         }
2656 
2657         @Override
2658         public boolean equals(Object o) {
2659             if (o == this) {
2660                 return true;
2661             }
2662             synchronized(mutex) {
2663                 return backingMap.equals(o);
2664             }
2665         }
2666 
2667         @Override
2668         public int hashCode() {
2669             synchronized(mutex) {
2670                 return backingMap.hashCode();
2671             }
2672         }
2673 
2674     }
2675 
2676     private static class SynchronizedCollection&lt;E&gt; implements Collection&lt;E&gt; {
2677 
2678         private final Collection&lt;E&gt; backingCollection;
2679         final Object mutex;
2680 
2681         SynchronizedCollection(Collection&lt;E&gt; c, Object mutex) {
2682             backingCollection = c;
2683             this.mutex = mutex;
2684         }
2685 
2686         SynchronizedCollection(Collection&lt;E&gt; c) {
2687             this(c, new Object());
2688         }
2689 
2690         @Override
2691         public int size() {
2692             synchronized (mutex) {
2693                 return backingCollection.size();
2694             }
2695         }
2696 
2697         @Override
2698         public boolean isEmpty() {
2699             synchronized (mutex) {
2700                 return backingCollection.isEmpty();
2701             }
2702         }
2703 
2704         @Override
2705         public boolean contains(Object o) {
2706             synchronized (mutex) {
2707                 return backingCollection.contains(o);
2708             }
2709         }
2710 
2711         @Override
2712         public Iterator&lt;E&gt; iterator() {
2713             return backingCollection.iterator();
2714         }
2715 
2716         @Override
2717         public Object[] toArray() {
2718             synchronized (mutex) {
2719                 return backingCollection.toArray();
2720             }
2721         }
2722 
2723         @Override
2724         public &lt;T&gt; T[] toArray(T[] a) {
2725             synchronized (mutex) {
2726                 return backingCollection.toArray(a);
2727             }
2728         }
2729 
2730         @Override
2731         public boolean add(E e) {
2732             synchronized (mutex) {
2733                 return backingCollection.add(e);
2734             }
2735         }
2736 
2737         @Override
2738         public boolean remove(Object o) {
2739             synchronized (mutex) {
2740                 return backingCollection.remove(o);
2741             }
2742         }
2743 
2744         @Override
2745         public boolean containsAll(Collection&lt;?&gt; c) {
2746             synchronized (mutex) {
2747                 return backingCollection.containsAll(c);
2748             }
2749         }
2750 
2751         @Override
2752         public boolean addAll(Collection&lt;? extends E&gt; c) {
2753             synchronized (mutex) {
2754                 return backingCollection.addAll(c);
2755             }
2756         }
2757 
2758         @Override
2759         public boolean removeAll(Collection&lt;?&gt; c) {
2760             synchronized (mutex) {
2761                 return backingCollection.removeAll(c);
2762             }
2763         }
2764 
2765         @Override
2766         public boolean retainAll(Collection&lt;?&gt; c) {
2767             synchronized (mutex) {
2768                 return backingCollection.retainAll(c);
2769             }
2770         }
2771 
2772         @Override
2773         public void clear() {
2774             synchronized (mutex) {
2775                 backingCollection.clear();
2776             }
2777         }
2778     }
2779 
2780     private static class SynchronizedObservableMap&lt;K, V&gt; extends SynchronizedMap&lt;K, V&gt; implements ObservableMap&lt;K, V&gt; {
2781 
2782         private final ObservableMap&lt;K, V&gt; backingMap;
2783         private MapListenerHelper listenerHelper;
2784         private final MapChangeListener&lt;K, V&gt; listener;
2785 
2786         SynchronizedObservableMap(ObservableMap&lt;K, V&gt; map) {
2787             super(map);
2788             backingMap = map;
2789             listener = c -&gt; {
2790                 MapListenerHelper.fireValueChangedEvent(listenerHelper, new MapAdapterChange&lt;K, V&gt;(SynchronizedObservableMap.this, c));
2791             };
2792             backingMap.addListener(new WeakMapChangeListener&lt;K, V&gt;(listener));
2793         }
2794 
2795         @Override
2796         public void addListener(InvalidationListener listener) {
2797             synchronized (mutex) {
2798                 listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
2799             }
2800         }
2801 
2802         @Override
2803         public void removeListener(InvalidationListener listener) {
2804             synchronized (mutex) {
2805                 listenerHelper = MapListenerHelper.removeListener(listenerHelper, listener);
2806             }
2807         }
2808 
2809         @Override
2810         public void addListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2811             synchronized (mutex) {
2812                 listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
2813             }
2814         }
2815 
2816         @Override
2817         public void removeListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
2818             synchronized (mutex) {
2819                 listenerHelper = MapListenerHelper.removeListener(listenerHelper, listener);
2820             }
2821         }
2822 
2823     }
2824 
2825 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>