<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/test/java/test/javafx/scene/control/ListViewTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package test.javafx.scene.control;
  27 
  28 import com.sun.javafx.scene.control.VirtualScrollBar;
  29 import com.sun.javafx.scene.control.behavior.FocusTraversalInputMap;
  30 import com.sun.javafx.scene.control.behavior.ListCellBehavior;
  31 import com.sun.javafx.scene.control.behavior.ListViewBehavior;
  32 import com.sun.javafx.scene.control.inputmap.InputMap;
  33 import com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;
  34 import com.sun.javafx.scene.control.inputmap.KeyBinding;
  35 import com.sun.javafx.tk.Toolkit;
  36 import java.lang.ref.WeakReference;
  37 import java.util.ArrayList;
  38 import java.util.Arrays;
  39 import java.util.Collections;
  40 import java.util.List;
  41 import java.util.ListIterator;
  42 import java.util.NoSuchElementException;
  43 import javafx.application.Platform;
  44 import javafx.beans.binding.Bindings;
  45 import javafx.beans.property.ObjectProperty;
  46 import javafx.beans.property.ReadOnlyBooleanWrapper;
  47 import javafx.beans.property.SimpleObjectProperty;
  48 import javafx.collections.FXCollections;
  49 import javafx.collections.ListChangeListener;
  50 import javafx.collections.ObservableList;
  51 import javafx.collections.transformation.SortedList;
  52 import javafx.scene.control.Button;
  53 import javafx.scene.control.FocusModel;
  54 import javafx.scene.control.IndexedCell;
  55 import javafx.scene.control.ListCell;
  56 import javafx.scene.control.ListCellShim;
  57 import javafx.scene.control.ListView;
  58 import javafx.scene.control.ListViewShim;
  59 import javafx.scene.control.MultipleSelectionModel;
  60 import javafx.scene.control.SelectionMode;
  61 import javafx.scene.control.SelectionModel;
  62 import javafx.scene.control.TextField;
  63 import javafx.scene.control.cell.CheckBoxListCell;
  64 import javafx.scene.control.cell.ComboBoxListCell;
  65 import javafx.scene.control.cell.TextFieldListCell;
  66 import javafx.scene.image.ImageView;
  67 import javafx.scene.input.KeyCode;
  68 import javafx.scene.layout.VBox;
  69 import javafx.scene.paint.Color;
  70 import javafx.scene.shape.Rectangle;
  71 import javafx.util.Callback;
  72 import static org.junit.Assert.assertArrayEquals;
  73 import static org.junit.Assert.assertEquals;
  74 import static org.junit.Assert.assertFalse;
  75 import static org.junit.Assert.assertNotNull;
  76 import static org.junit.Assert.assertNull;
  77 import static org.junit.Assert.assertSame;
  78 import static org.junit.Assert.assertTrue;
  79 import static org.junit.Assert.fail;
  80 import org.junit.Before;
  81 import org.junit.Test;
  82 import static test.com.sun.javafx.scene.control.infrastructure.ControlTestUtils.assertStyleClassContains;
  83 
  84 import test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory;
  85 import test.com.sun.javafx.scene.control.infrastructure.KeyEventFirer;
  86 import test.com.sun.javafx.scene.control.infrastructure.KeyModifier;
  87 import test.com.sun.javafx.scene.control.infrastructure.StageLoader;
  88 import test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils;
  89 import test.com.sun.javafx.scene.control.test.Person;
  90 import test.com.sun.javafx.scene.control.test.RT_22463_Person;
  91 
  92 public class ListViewTest {
  93     private ListView&lt;String&gt; listView;
  94     private MultipleSelectionModel&lt;String&gt; sm;
  95     private FocusModel&lt;String&gt; fm;
  96 
  97     @Before public void setup() {
  98         listView = new ListView&lt;&gt;();
  99         sm = listView.getSelectionModel();
 100         fm = listView.getFocusModel();
 101     }
 102 
 103 
 104     /*********************************************************************
 105      * Tests for the constructors                                        *
 106      ********************************************************************/
 107 
 108     @Test public void noArgConstructorSetsTheStyleClass() {
 109         assertStyleClassContains(listView, &quot;list-view&quot;);
 110     }
 111 
 112     @Test public void noArgConstructorSetsNonNullSelectionModel() {
 113         assertNotNull(sm);
 114     }
 115 
 116     @Test public void noArgConstructorSetsNonNullItems() {
 117         assertNotNull(listView.getItems());
 118     }
 119 
 120     @Test public void noArgConstructor_selectedItemIsNull() {
 121         assertNull(sm.getSelectedItem());
 122     }
 123 
 124     @Test public void noArgConstructor_selectedIndexIsNegativeOne() {
 125         assertEquals(-1, sm.getSelectedIndex());
 126     }
 127 
 128     @Test public void singleArgConstructorSetsTheStyleClass() {
 129         final ListView&lt;String&gt; b2 = new ListView&lt;&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 130         assertStyleClassContains(b2, &quot;list-view&quot;);
 131     }
 132 
 133     @Test public void singleArgConstructorSetsNonNullSelectionModel() {
 134         final ListView&lt;String&gt; b2 = new ListView&lt;&gt;(FXCollections.&lt;String&gt;observableArrayList(&quot;Hi&quot;));
 135         assertNotNull(b2.getSelectionModel());
 136     }
 137 
 138     @Test public void singleArgConstructorAllowsNullItems() {
 139         final ListView&lt;String&gt; b2 = new ListView&lt;String&gt;(null);
 140         assertNull(b2.getItems());
 141     }
 142 
 143     @Test public void singleArgConstructorTakesItems() {
 144         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;Hi&quot;);
 145         final ListView&lt;String&gt; b2 = new ListView&lt;&gt;(items);
 146         assertSame(items, b2.getItems());
 147     }
 148 
 149     @Test public void singleArgConstructor_selectedItemIsNull() {
 150         final ListView&lt;String&gt; b2 = new ListView&lt;&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 151         assertNull(b2.getSelectionModel().getSelectedItem());
 152     }
 153 
 154     @Test public void singleArgConstructor_selectedIndexIsNegativeOne() {
 155         final ListView&lt;String&gt; b2 = new ListView&lt;&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 156         assertEquals(-1, b2.getSelectionModel().getSelectedIndex());
 157     }
 158 
 159     /*********************************************************************
 160      * Tests for selection model                                         *
 161      ********************************************************************/
 162 
 163     @Test public void selectionModelCanBeNull() {
 164         listView.setSelectionModel(null);
 165         assertNull(listView.getSelectionModel());
 166     }
 167 
 168     @Test public void selectionModelCanBeBound() {
 169         MultipleSelectionModel&lt;String&gt; sm = ListViewShim.&lt;String&gt;getListViewBitSetSelectionModel(listView);
 170         ObjectProperty&lt;MultipleSelectionModel&lt;String&gt;&gt; other = new SimpleObjectProperty&lt;MultipleSelectionModel&lt;String&gt;&gt;(sm);
 171         listView.selectionModelProperty().bind(other);
 172         assertSame(sm, sm);
 173     }
 174 
 175     @Test public void selectionModelCanBeChanged() {
 176         MultipleSelectionModel&lt;String&gt; sm = ListViewShim.&lt;String&gt;getListViewBitSetSelectionModel(listView);
 177         listView.setSelectionModel(sm);
 178         assertSame(sm, sm);
 179     }
 180 
<a name="1" id="anc1"></a><span class="line-modified"> 181     @Test public void test_SwitchingSelectionModel() {</span>
 182         ListView&lt;String&gt; listView = new ListView&lt;&gt;();
 183         listView.getItems().addAll(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
 184 
 185         MultipleSelectionModel&lt;String&gt; sm;
 186         StageLoader sl = new StageLoader(listView);
 187         KeyEventFirer keyboard = new KeyEventFirer(listView);
 188 
 189         MultipleSelectionModel&lt;String&gt; smMultiple = ListViewShim.&lt;String&gt;getListViewBitSetSelectionModel(listView);
 190         smMultiple.setSelectionMode(SelectionMode.MULTIPLE);
 191         MultipleSelectionModel&lt;String&gt; smSingle = ListViewShim.&lt;String&gt;getListViewBitSetSelectionModel(listView);
 192         smSingle.setSelectionMode(SelectionMode.SINGLE);
 193 
 194         listView.setSelectionModel(smMultiple);
 195         sm = listView.getSelectionModel();
 196 
 197         assertEquals(0, sm.getSelectedItems().size());
 198         sm.clearAndSelect(0);
 199         assertEquals(1, sm.getSelectedItems().size());
 200         keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
 201         assertEquals(4, sm.getSelectedItems().size());
 202 
 203         listView.setSelectionModel(smSingle);
 204         sm = listView.getSelectionModel();
 205 
 206         assertEquals(0, sm.getSelectedItems().size());
 207         sm.clearAndSelect(0);
 208         assertEquals(1, sm.getSelectedItems().size());
 209         keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
 210         assertEquals(1, sm.getSelectedItems().size());
 211 
 212         sl.dispose();
 213     }
 214 
 215     @Test public void canSetSelectedItemToAnItemEvenWhenThereAreNoItems() {
 216         final String randomString = new String(&quot;I AM A CRAZY RANDOM STRING&quot;);
 217         sm.select(randomString);
 218         assertEquals(-1, sm.getSelectedIndex());
 219         assertSame(randomString, sm.getSelectedItem());
 220     }
 221 
 222     @Test public void canSetSelectedItemToAnItemNotInTheDataModel() {
 223         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 224         final String randomString = new String(&quot;I AM A CRAZY RANDOM STRING&quot;);
 225         sm.select(randomString);
 226         assertEquals(-1, sm.getSelectedIndex());
 227         assertSame(randomString, sm.getSelectedItem());
 228     }
 229 
 230     @Test public void settingTheSelectedItemToAnItemInItemsResultsInTheCorrectSelectedIndex() {
 231         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 232         sm.select(&quot;Orange&quot;);
 233         assertEquals(1, sm.getSelectedIndex());
 234         assertSame(&quot;Orange&quot;, sm.getSelectedItem());
 235     }
 236 
 237     @Test public void settingTheSelectedItemToANonexistantItemAndThenSettingItemsWhichContainsItResultsInCorrectSelectedIndex() {
 238         sm.select(&quot;Orange&quot;);
 239         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 240         assertEquals(1, sm.getSelectedIndex());
 241         assertSame(&quot;Orange&quot;, sm.getSelectedItem());
 242     }
 243 
 244     @Test public void ensureSelectionClearsWhenAllItemsAreRemoved_selectIndex0() {
 245         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 246         sm.select(0);
 247         listView.getItems().clear();
 248         assertEquals(-1, sm.getSelectedIndex());
 249         assertEquals(null, sm.getSelectedItem());
 250     }
 251 
 252     @Test public void ensureSelectionClearsWhenAllItemsAreRemoved_selectIndex2() {
 253         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 254         sm.select(2);
 255         listView.getItems().clear();
 256         assertEquals(-1, sm.getSelectedIndex());
 257         assertEquals(null, sm.getSelectedItem());
 258     }
 259 
 260     @Test public void ensureSelectedItemRemainsAccurateWhenItemsAreCleared() {
 261         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 262         sm.select(2);
 263         listView.getItems().clear();
 264         assertNull(sm.getSelectedItem());
 265         assertEquals(-1, sm.getSelectedIndex());
 266 
 267         listView.getItems().addAll(&quot;Kiwifruit&quot;, &quot;Mandarin&quot;, &quot;Pineapple&quot;);
 268         sm.select(2);
 269         assertEquals(&quot;Pineapple&quot;, sm.getSelectedItem());
 270     }
 271 
 272     @Test public void ensureSelectionShiftsDownWhenOneNewItemIsAdded() {
 273         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 274         sm.select(1);
 275         assertEquals(1, sm.getSelectedIndex());
 276         assertEquals(&quot;Orange&quot;, sm.getSelectedItem());
 277 
 278         listView.getItems().add(0, &quot;Kiwifruit&quot;);
 279         assertEquals(2, sm.getSelectedIndex());
 280         assertEquals(&quot;Orange&quot;, sm.getSelectedItem());
 281     }
 282 
 283     @Test public void ensureSelectionShiftsDownWhenMultipleNewItemAreAdded() {
 284         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 285         sm.select(1);
 286         assertEquals(1, sm.getSelectedIndex());
 287         assertEquals(&quot;Orange&quot;, sm.getSelectedItem());
 288 
 289         listView.getItems().addAll(0, Arrays.asList(&quot;Kiwifruit&quot;, &quot;Pineapple&quot;, &quot;Mandarin&quot;));
 290         assertEquals(&quot;Orange&quot;, sm.getSelectedItem());
 291         assertEquals(4, sm.getSelectedIndex());
 292     }
 293 
 294     @Test public void ensureSelectionShiftsUpWhenOneItemIsRemoved() {
 295         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 296         sm.select(1);
 297         assertEquals(1, sm.getSelectedIndex());
 298         assertEquals(&quot;Orange&quot;, sm.getSelectedItem());
 299 
 300         listView.getItems().remove(&quot;Apple&quot;);
 301         assertEquals(0, sm.getSelectedIndex());
 302         assertEquals(&quot;Orange&quot;, sm.getSelectedItem());
 303     }
 304 
 305     @Test public void ensureSelectionShiftsUpWheMultipleItemsAreRemoved() {
 306         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 307         sm.select(2);
 308         assertEquals(2, sm.getSelectedIndex());
 309         assertEquals(&quot;Banana&quot;, sm.getSelectedItem());
 310 
 311         listView.getItems().removeAll(Arrays.asList(&quot;Apple&quot;, &quot;Orange&quot;));
 312         assertEquals(0, sm.getSelectedIndex());
 313         assertEquals(&quot;Banana&quot;, sm.getSelectedItem());
 314     }
 315 
 316     @Test public void ensureSelectionIsCorrectWhenItemsChange() {
 317         listView.setItems(FXCollections.observableArrayList(&quot;Item 1&quot;));
 318         sm.select(0);
 319         assertEquals(&quot;Item 1&quot;, sm.getSelectedItem());
 320 
 321         listView.setItems(FXCollections.observableArrayList(&quot;Item 2&quot;));
 322         assertEquals(-1, sm.getSelectedIndex());
 323         assertNull(sm.getSelectedItem());
 324         assertEquals(0, fm.getFocusedIndex());
 325         assertEquals(&quot;Item 2&quot;, fm.getFocusedItem());
 326     }
 327 
 328     @Test public void test_rt15793() {
 329         // ListView selectedIndex is 0 although the items list is empty
 330         final ListView lv = new ListView();
 331         final ObservableList list = FXCollections.observableArrayList();
 332         lv.setItems(list);
 333         list.add(&quot;toto&quot;);
 334         lv.getSelectionModel().select(0);
 335         assertEquals(0, lv.getSelectionModel().getSelectedIndex());
 336         list.remove(0);
 337         assertEquals(-1, lv.getSelectionModel().getSelectedIndex());
 338     }
 339 
 340     @Test public void test_rt17522_focusShouldMoveWhenItemAddedAtFocusIndex() {
 341         final ListView lv = new ListView();
 342         FocusModel fm = lv.getFocusModel();
 343         lv.getItems().add(&quot;row1&quot;);
 344         fm.focus(0);
 345         assertTrue(fm.isFocused(0));
 346 
 347         lv.getItems().add(0, &quot;row0&quot;);
 348         assertTrue(fm.isFocused(1));
 349     }
 350 
 351     @Test public void test_rt17522_focusShouldMoveWhenItemAddedBeforeFocusIndex() {
 352         final ListView lv = new ListView();
 353         FocusModel fm = lv.getFocusModel();
 354         lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 355         fm.focus(1);
 356         assertTrue(fm.isFocused(1));
 357         assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 358 
 359         lv.getItems().add(1, &quot;row0&quot;);
 360         assertTrue(fm.isFocused(2));
 361         assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 362         assertFalse(fm.isFocused(1));
 363     }
 364 
 365     @Test public void test_rt17522_focusShouldNotMoveWhenItemAddedAfterFocusIndex() {
 366         final ListView lv = new ListView();
 367         FocusModel fm = lv.getFocusModel();
 368         lv.getItems().addAll(&quot;row1&quot;);
 369         fm.focus(0);
 370         assertTrue(fm.isFocused(0));
 371         assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 372 
 373         lv.getItems().add(1, &quot;row2&quot;);
 374         assertTrue(fm.isFocused(0));
 375         assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 376         assertFalse(fm.isFocused(1));
 377     }
 378 
 379     @Test public void test_rt17522_focusShouldBeResetWhenFocusedItemIsRemoved() {
 380         final ListView lv = new ListView();
 381         FocusModel fm = lv.getFocusModel();
 382         lv.getItems().add(&quot;row1&quot;);
 383         fm.focus(0);
 384         assertTrue(fm.isFocused(0));
 385 
 386         lv.getItems().remove(&quot;row1&quot;);
 387         assertTrue(fm.getFocusedIndex() == -1);
 388         assertNull(fm.getFocusedItem());
 389     }
 390 
 391     @Test public void test_rt17522_focusShouldMoveWhenItemRemovedBeforeFocusIndex() {
 392         final ListView lv = new ListView();
 393         FocusModel fm = lv.getFocusModel();
 394         lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 395         fm.focus(1);
 396         assertTrue(fm.isFocused(1));
 397         assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 398 
 399         lv.getItems().remove(&quot;row1&quot;);
 400         assertTrue(fm.isFocused(0));
 401         assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 402     }
 403 
 404     @Test public void test_rt17522_focusShouldNotMoveWhenItemRemovedAfterFocusIndex() {
 405         final ListView lv = new ListView();
 406         FocusModel fm = lv.getFocusModel();
 407         lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 408         fm.focus(0);
 409         assertTrue(fm.isFocused(0));
 410         assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 411 
 412         lv.getItems().remove(&quot;row2&quot;);
 413         assertTrue(fm.isFocused(0));
 414         assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 415     }
 416 
 417     @Test public void test_rt18385() {
 418         listView.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;);
 419         sm.select(1);
 420         listView.getItems().add(&quot;Another Row&quot;);
 421         assertEquals(1, sm.getSelectedIndices().size());
 422         assertEquals(1, sm.getSelectedItems().size());
 423     }
 424 
 425     @Test public void test_rt18339_onlyEditWhenListViewIsEditable_editableIsFalse() {
 426         listView.setEditable(false);
 427         listView.edit(1);
 428         assertEquals(-1, listView.getEditingIndex());
 429     }
 430 
 431     @Test public void test_rt18339_onlyEditWhenListViewIsEditable_editableIsTrue() {
 432         listView.setEditable(true);
 433         listView.edit(1);
 434         assertEquals(1, listView.getEditingIndex());
 435     }
 436 
 437     @Test public void test_rt14451() {
 438         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 439         sm.setSelectionMode(SelectionMode.MULTIPLE);
 440         sm.selectRange(0, 2); // select from 0 (inclusive) to 2 (exclusive)
 441         assertEquals(2, sm.getSelectedIndices().size());
 442     }
 443 
 444     private int rt_18969_hitCount = 0;
 445     @Test public void test_rt18969() {
 446         rt_18969_hitCount = 0;
 447         ObservableList&lt;String&gt; emptyModel = FXCollections.observableArrayList();
 448         listView.setItems(emptyModel);
 449         assertTrue(listView.getItems().isEmpty());
 450 
 451         sm.selectedItemProperty().addListener((observable, oldValue, newValue) -&gt; {
 452             rt_18969_hitCount++;
 453         });
 454 
 455         ObservableList&lt;String&gt; mod = FXCollections.observableArrayList();
 456         mod.add(System.currentTimeMillis()+&quot;&quot;);
 457         listView.getItems().setAll(mod);
 458 
 459         sm.select(0);
 460         assertTrue(sm.isSelected(0));
 461         assertEquals(1, rt_18969_hitCount);
 462 
 463         // sleep for 100ms so that the currentTimeMillis is guaranteed to be
 464         // a different value than the first one
 465         try {
 466             Thread.sleep(100);
 467         } catch (InterruptedException ex) {
 468             ex.printStackTrace();
 469         }
 470 
 471         // the list is totally changing (it is being cleared), so we should
 472         // be nulling out the selection model state
 473         mod = FXCollections.observableArrayList();
 474         mod.add(System.currentTimeMillis()+&quot;&quot;);
 475         listView.getItems().setAll(mod);
 476 
 477         // it should be two, as there is no null event in between (although there
 478         // used to be, so the test used to be for three hits)
 479         assertEquals(2, rt_18969_hitCount);
 480     }
 481 
 482     @Test public void test_rt21586() {
 483         listView.getItems().setAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 484         listView.getSelectionModel().select(1);
 485         assertEquals(1, listView.getSelectionModel().getSelectedIndex());
 486         assertEquals(&quot;Orange&quot;, listView.getSelectionModel().getSelectedItem());
 487 
 488         listView.getItems().setAll(&quot;Kiwifruit&quot;, &quot;Pineapple&quot;, &quot;Grape&quot;);
 489         assertEquals(-1, listView.getSelectionModel().getSelectedIndex());
 490         assertNull(listView.getSelectionModel().getSelectedItem());
 491     }
 492 
 493     @Test public void test_rt27820_1() {
 494         listView.getItems().setAll(&quot;Apple&quot;, &quot;Orange&quot;);
 495         listView.getSelectionModel().select(0);
 496         assertEquals(1, listView.getSelectionModel().getSelectedItems().size());
 497         assertEquals(&quot;Apple&quot;, listView.getSelectionModel().getSelectedItem());
 498 
 499         listView.getItems().clear();
 500         assertEquals(0, listView.getSelectionModel().getSelectedItems().size());
 501         assertNull(listView.getSelectionModel().getSelectedItem());
 502     }
 503 
 504     @Test public void test_rt27820_2() {
 505         listView.getItems().setAll(&quot;Apple&quot;, &quot;Orange&quot;);
 506         listView.getSelectionModel().select(1);
 507         assertEquals(1, listView.getSelectionModel().getSelectedItems().size());
 508         assertEquals(&quot;Orange&quot;, listView.getSelectionModel().getSelectedItem());
 509 
 510         listView.getItems().clear();
 511         assertEquals(0, listView.getSelectionModel().getSelectedItems().size());
 512         assertNull(listView.getSelectionModel().getSelectedItem());
 513     }
 514 
 515     @Test public void test_rt28534() {
 516         ListView&lt;Person&gt; list = new ListView&lt;Person&gt;();
 517         list.setItems(FXCollections.observableArrayList(
 518                 new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;),
 519                 new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;),
 520                 new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;),
 521                 new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;),
 522                 new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
 523 
 524         VirtualFlowTestUtils.assertRowsNotEmpty(list, 0, 5); // rows 0 - 5 should be filled
 525         VirtualFlowTestUtils.assertRowsEmpty(list, 5, -1); // rows 5+ should be empty
 526 
 527         // now we replace the data and expect the cells that have no data
 528         // to be empty
 529         list.setItems(FXCollections.observableArrayList(
 530                 new Person(&quot;*_*Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;),
 531                 new Person(&quot;_Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
 532 
 533         VirtualFlowTestUtils.assertRowsNotEmpty(list, 0, 2); // rows 0 - 2 should be filled
 534         VirtualFlowTestUtils.assertRowsEmpty(list, 2, -1); // rows 2+ should be empty
 535     }
 536 
 537     @Test public void test_rt22463() {
 538         final ListView&lt;RT_22463_Person&gt; list = new ListView&lt;RT_22463_Person&gt;();
 539 
 540         // before the change things display fine
 541         RT_22463_Person p1 = new RT_22463_Person();
 542         p1.setId(1l);
 543         p1.setName(&quot;name1&quot;);
 544         RT_22463_Person p2 = new RT_22463_Person();
 545         p2.setId(2l);
 546         p2.setName(&quot;name2&quot;);
 547         list.setItems(FXCollections.observableArrayList(p1, p2));
 548         VirtualFlowTestUtils.assertCellTextEquals(list, 0, &quot;name1&quot;);
 549         VirtualFlowTestUtils.assertCellTextEquals(list, 1, &quot;name2&quot;);
 550 
 551         // now we change the persons but they are still equal as the ID&#39;s don&#39;t
 552         // change - but the items list is cleared so the cells should update
 553         RT_22463_Person new_p1 = new RT_22463_Person();
 554         new_p1.setId(1l);
 555         new_p1.setName(&quot;updated name1&quot;);
 556         RT_22463_Person new_p2 = new RT_22463_Person();
 557         new_p2.setId(2l);
 558         new_p2.setName(&quot;updated name2&quot;);
 559         list.getItems().clear();
 560         list.setItems(FXCollections.observableArrayList(new_p1, new_p2));
 561         VirtualFlowTestUtils.assertCellTextEquals(list, 0, &quot;updated name1&quot;);
 562         VirtualFlowTestUtils.assertCellTextEquals(list, 1, &quot;updated name2&quot;);
 563     }
 564 
 565     @Test public void test_rt28637() {
 566         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;String1&quot;, &quot;String2&quot;, &quot;String3&quot;, &quot;String4&quot;);
 567 
 568         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;();
 569         listView.setItems(items);
 570 
 571         listView.getSelectionModel().select(0);
 572         assertEquals(&quot;String1&quot;, listView.getSelectionModel().getSelectedItem());
 573         assertEquals(&quot;String1&quot;, listView.getSelectionModel().getSelectedItems().get(0));
 574         assertEquals(0, listView.getSelectionModel().getSelectedIndex());
 575 
 576         items.remove(listView.getSelectionModel().getSelectedItem());
 577         assertEquals(&quot;String2&quot;, listView.getSelectionModel().getSelectedItem());
 578         assertEquals(&quot;String2&quot;, listView.getSelectionModel().getSelectedItems().get(0));
 579         assertEquals(0, listView.getSelectionModel().getSelectedIndex());
 580     }
 581 
 582     @Test public void test_rt28819_1() {
 583         ObservableList&lt;String&gt; emptyModel = FXCollections.observableArrayList();
 584 
 585         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;();
 586         listView.setItems(emptyModel);
 587         VirtualFlowTestUtils.assertRowsEmpty(listView, 0, 5);
 588 
 589         ObservableList&lt;String&gt; mod = FXCollections.observableArrayList();
 590         String value = System.currentTimeMillis()+&quot;&quot;;
 591         mod.add(value);
 592         listView.setItems(mod);
 593         VirtualFlowTestUtils.assertCellCount(listView, 1);
 594         VirtualFlowTestUtils.assertCellTextEquals(listView, 0, value);
 595     }
 596 
 597     @Test public void test_rt28819_2() {
 598         ObservableList&lt;String&gt; emptyModel = FXCollections.observableArrayList();
 599 
 600         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;();
 601         listView.setItems(emptyModel);
 602         VirtualFlowTestUtils.assertRowsEmpty(listView, 0, 5);
 603 
 604         ObservableList&lt;String&gt; mod1 = FXCollections.observableArrayList();
 605         String value1 = System.currentTimeMillis()+&quot;&quot;;
 606         mod1.add(value1);
 607         listView.getItems().setAll(mod1);
 608         VirtualFlowTestUtils.assertCellCount(listView, 1);
 609         VirtualFlowTestUtils.assertCellTextEquals(listView, 0, value1);
 610     }
 611 
 612     @Test public void test_rt29390() {
 613         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(
 614                 &quot;String1&quot;, &quot;String2&quot;, &quot;String3&quot;, &quot;String4&quot;,
 615                 &quot;String1&quot;, &quot;String2&quot;, &quot;String3&quot;, &quot;String4&quot;,
 616                 &quot;String1&quot;, &quot;String2&quot;, &quot;String3&quot;, &quot;String4&quot;,
 617                 &quot;String1&quot;, &quot;String2&quot;, &quot;String3&quot;, &quot;String4&quot;
 618         );
 619 
 620         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;(items);
 621         listView.setMaxHeight(50);
 622         listView.setPrefHeight(50);
 623 
 624         // we want the vertical scrollbar
 625         VirtualScrollBar scrollBar = VirtualFlowTestUtils.getVirtualFlowVerticalScrollbar(listView);
 626 
 627         assertNotNull(scrollBar);
 628         assertTrue(scrollBar.isVisible());
 629         assertTrue(scrollBar.getVisibleAmount() &gt; 0.0);
 630         assertTrue(scrollBar.getVisibleAmount() &lt; 1.0);
 631 
 632         // this next test is likely to be brittle, but we&#39;ll see...If it is the
 633         // cause of failure then it can be commented out
 634         assertEquals(0.125, scrollBar.getVisibleAmount(), 0.0);
 635     }
 636 
 637     @Test public void test_rt30400() {
 638         // create a listview that&#39;ll render cells using the check box cell factory
 639         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;String1&quot;);
 640         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;(items);
 641         listView.setMinHeight(100);
 642         listView.setPrefHeight(100);
 643         listView.setCellFactory(CheckBoxListCell.forListView(param -&gt; new ReadOnlyBooleanWrapper(true)));
 644 
 645         // because only the first row has data, all other rows should be
 646         // empty (and not contain check boxes - we just check the first four here)
 647         VirtualFlowTestUtils.assertRowsNotEmpty(listView, 0, 1);
 648         VirtualFlowTestUtils.assertCellNotEmpty(VirtualFlowTestUtils.getCell(listView, 0));
 649         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(listView, 1));
 650         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(listView, 2));
 651         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(listView, 3));
 652     }
 653 
 654     @Test public void test_rt29420() {
 655         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;();
 656 
 657         VBox vbox = new VBox(listView);
 658         StageLoader sl = new StageLoader(vbox);
 659 
 660         // the initial width of a ListView should be the golden rectangle where
 661         // the height is hardcoded to be 400
 662         final double initialWidth = listView.prefWidth(-1);
 663         assertEquals(400 * 0.618033987, initialWidth, 0.00);
 664 
 665         // add in some items, and re-measure - seeing as the items are narrow,
 666         // the width shouldn&#39;t change
 667         listView.getItems().addAll(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;);
 668         Toolkit.getToolkit().firePulse();
 669         final double withContentWidth = listView.prefWidth(-1);
 670         assertEquals(initialWidth, withContentWidth, 0.00);
 671 
 672         // remove the items - and the width should remain the same
 673         listView.getItems().clear();
 674         Toolkit.getToolkit().firePulse();
 675         final double afterEmptiedWidth = listView.prefWidth(-1);
 676         assertEquals(initialWidth, afterEmptiedWidth, 0.00);
 677 
 678         sl.dispose();
 679     }
 680 
 681     @Test public void test_rt31165() {
 682         final ObservableList names = FXCollections.observableArrayList(&quot;Adam&quot;, &quot;Alex&quot;, &quot;Alfred&quot;, &quot;Albert&quot;);
 683         final ObservableList data = FXCollections.observableArrayList();
 684         for (int i = 0; i &lt; 18; i++) {
 685             data.add(&quot;&quot;+i);
 686         }
 687 
 688         final ListView listView = new ListView(data);
 689         listView.setPrefSize(200, 250);
 690         listView.setEditable(true);
 691         listView.setCellFactory(ComboBoxListCell.forListView(names));
 692 
 693         IndexedCell cell = VirtualFlowTestUtils.getCell(listView, 1);
 694         assertEquals(&quot;1&quot;, cell.getText());
 695         assertFalse(cell.isEditing());
 696 
 697         listView.edit(1);
 698 
 699         assertEquals(1, listView.getEditingIndex());
 700         assertTrue(cell.isEditing());
 701 
 702         VirtualFlowTestUtils.getVirtualFlow(listView).requestLayout();
 703         Toolkit.getToolkit().firePulse();
 704 
 705         assertEquals(1, listView.getEditingIndex());
 706         assertTrue(cell.isEditing());
 707     }
 708 
 709     @Test public void test_rt31471() {
 710         final ObservableList names = FXCollections.observableArrayList(&quot;Adam&quot;, &quot;Alex&quot;, &quot;Alfred&quot;, &quot;Albert&quot;);
 711         final ListView listView = new ListView(names);
 712 
 713         IndexedCell cell = VirtualFlowTestUtils.getCell(listView, 0);
 714         assertEquals(&quot;Adam&quot;, cell.getItem());
 715 
 716         listView.setFixedCellSize(50);
 717 
 718         VirtualFlowTestUtils.getVirtualFlow(listView).requestLayout();
 719         Toolkit.getToolkit().firePulse();
 720 
 721         assertEquals(&quot;Adam&quot;, cell.getItem());
 722         assertEquals(50, cell.getHeight(), 0.00);
 723     }
 724 
 725     private int rt_31200_count = 0;
 726     @Test public void test_rt_31200() {
 727         final ListView listView = new ListView();
 728         listView.setCellFactory(new Callback&lt;ListView&lt;String&gt;, ListCell&lt;String&gt;&gt;() {
 729             @Override
 730             public ListCell&lt;String&gt; call(ListView&lt;String&gt; param) {
 731                 return new ListCellShim&lt;String&gt;() {
 732                     ImageView view = new ImageView();
 733                     { setGraphic(view); };
 734 
 735                     @Override
 736                     public void updateItem(String item, boolean empty) {
 737                         if (getItem() == null ? item == null : getItem().equals(item)) {
 738                             rt_31200_count++;
 739                         }
 740                         super.updateItem(item, empty);
 741                         if (item == null || empty) {
 742                             view.setImage(null);
 743                             setText(null);
 744                         } else {
 745                             setText(item);
 746                         }
 747                     }
 748                 };
 749             }
 750         });
 751         listView.getItems().setAll(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;);
 752 
 753         StageLoader sl = new StageLoader(listView);
 754 
 755         assertEquals(24, rt_31200_count);
 756 
 757         // resize the stage
 758         sl.getStage().setHeight(250);
 759         Toolkit.getToolkit().firePulse();
 760         sl.getStage().setHeight(50);
 761         Toolkit.getToolkit().firePulse();
 762         assertEquals(24, rt_31200_count);
 763 
 764         sl.dispose();
 765     }
 766 
 767     @Test public void test_rt_30484() {
 768         final ListView listView = new ListView();
 769         listView.setCellFactory(new Callback&lt;ListView&lt;String&gt;, ListCell&lt;String&gt;&gt;() {
 770             @Override public ListCell&lt;String&gt; call(ListView&lt;String&gt; param) {
 771                 return new ListCellShim&lt;String&gt;() {
 772                     Rectangle graphic = new Rectangle(10, 10, Color.RED);
 773                     { setGraphic(graphic); };
 774 
 775                     @Override public void updateItem(String item, boolean empty) {
 776                         super.updateItem(item, empty);
 777                         if (item == null || empty) {
 778                             graphic.setVisible(false);
 779                             setText(null);
 780                         } else {
 781                             graphic.setVisible(true);
 782                             setText(item);
 783                         }
 784                     }
 785                 };
 786             }
 787         });
 788 
 789         // First two rows have content, so the graphic should show.
 790         // All other rows have no content, so graphic should not show.
 791         listView.getItems().setAll(&quot;one&quot;, &quot;two&quot;);
 792 
 793         VirtualFlowTestUtils.assertGraphicIsVisible(listView, 0);
 794         VirtualFlowTestUtils.assertGraphicIsVisible(listView, 1);
 795         VirtualFlowTestUtils.assertGraphicIsNotVisible(listView, 2);
 796         VirtualFlowTestUtils.assertGraphicIsNotVisible(listView, 3);
 797         VirtualFlowTestUtils.assertGraphicIsNotVisible(listView, 4);
 798         VirtualFlowTestUtils.assertGraphicIsNotVisible(listView, 5);
 799     }
 800 
 801     private int rt_29650_start_count = 0;
 802     private int rt_29650_commit_count = 0;
 803     private int rt_29650_cancel_count = 0;
 804     @Test public void test_rt_29650() {
 805         listView.setOnEditStart(t -&gt; {
 806             rt_29650_start_count++;
 807         });
 808         listView.setOnEditCommit(t -&gt; {
 809             rt_29650_commit_count++;
 810         });
 811         listView.setOnEditCancel(t -&gt; {
 812             rt_29650_cancel_count++;
 813         });
 814 
 815         listView.getItems().setAll(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;);
 816         listView.setEditable(true);
 817         listView.setCellFactory(TextFieldListCell.forListView());
 818 
 819         StageLoader sl = new StageLoader(listView);
 820 
 821         listView.edit(0);
 822 
 823         Toolkit.getToolkit().firePulse();
 824 
 825         ListCell rootCell = (ListCell) VirtualFlowTestUtils.getCell(listView, 0);
 826         TextField textField = (TextField) rootCell.getGraphic();
 827         textField.setText(&quot;Testing!&quot;);
 828         KeyEventFirer keyboard = new KeyEventFirer(textField);
 829         keyboard.doKeyPress(KeyCode.ENTER);
 830 
 831         // TODO should the following assert be enabled?
 832 //        assertEquals(&quot;Testing!&quot;, listView.getItems().get(0));
 833         assertEquals(1, rt_29650_start_count);
 834         assertEquals(1, rt_29650_commit_count);
 835         assertEquals(0, rt_29650_cancel_count);
 836 
 837         sl.dispose();
 838     }
 839 
 840     @Test public void test_rt35039() {
 841         final List&lt;String&gt; data = new ArrayList&lt;&gt;();
 842         data.add(&quot;aabbaa&quot;);
 843         data.add(&quot;bbc&quot;);
 844 
 845         final ListView&lt;String&gt; listView = new ListView&lt;&gt;();
 846         listView.setItems(FXCollections.observableArrayList(data));
 847 
 848         StageLoader sl = new StageLoader(listView);
 849 
 850         // selection starts off on row -1
 851         assertNull(listView.getSelectionModel().getSelectedItem());
 852 
 853         // select &quot;bbc&quot; and ensure everything is set to that
 854         listView.getSelectionModel().select(1);
 855         assertEquals(&quot;bbc&quot;, listView.getSelectionModel().getSelectedItem());
 856 
 857         // change the items list - but retain the same content. We expect
 858         // that &quot;bbc&quot; remains selected as it is still in the list
 859         listView.setItems(FXCollections.observableArrayList(data));
 860         assertEquals(&quot;bbc&quot;, listView.getSelectionModel().getSelectedItem());
 861 
 862         sl.dispose();
 863     }
 864 
 865     @Test public void test_rt35857() {
 866         ObservableList&lt;String&gt; fxList = FXCollections.observableArrayList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);
 867         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;(fxList);
 868 
 869         listView.getSelectionModel().select(0);
 870 
 871         ObservableList&lt;String&gt; selectedItems = listView.getSelectionModel().getSelectedItems();
 872         assertEquals(1, selectedItems.size());
 873         assertEquals(&quot;A&quot;, selectedItems.get(0));
 874 
 875         listView.getItems().removeAll(selectedItems);
 876         assertEquals(2, fxList.size());
 877         assertEquals(&quot;B&quot;, fxList.get(0));
 878         assertEquals(&quot;C&quot;, fxList.get(1));
 879     }
 880 
 881     private int rt_35889_cancel_count = 0;
 882     @Test public void test_rt35889() {
 883         final ListView&lt;String&gt; textFieldListView = new ListView&lt;String&gt;();
 884         textFieldListView.setItems(FXCollections.observableArrayList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;));
 885         textFieldListView.setEditable(true);
 886         textFieldListView.setCellFactory(TextFieldListCell.forListView());
 887         textFieldListView.setOnEditCancel(t -&gt; {
 888             rt_35889_cancel_count++;
 889             System.out.println(&quot;On Edit Cancel: &quot; + t);
 890         });
 891 
 892         ListCell cell0 = (ListCell) VirtualFlowTestUtils.getCell(textFieldListView, 0);
 893         assertNull(cell0.getGraphic());
 894         assertEquals(&quot;A&quot;, cell0.getText());
 895 
 896         textFieldListView.edit(0);
 897         TextField textField = (TextField) cell0.getGraphic();
 898         assertNotNull(textField);
 899 
 900         assertEquals(0, rt_35889_cancel_count);
 901 
 902         textField.setText(&quot;Z&quot;);
 903         KeyEventFirer keyboard = new KeyEventFirer(textField);
 904         keyboard.doKeyPress(KeyCode.ENTER);
 905 
 906         assertEquals(0, rt_35889_cancel_count);
 907     }
 908 
 909     @Test public void test_rt25679() {
 910         Button focusBtn = new Button(&quot;Focus here&quot;);
 911 
 912         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;();
 913         SelectionModel sm = listView.getSelectionModel();
 914         listView.setItems(FXCollections.observableArrayList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;));
 915 
 916         VBox vbox = new VBox(focusBtn, listView);
 917 
 918         StageLoader sl = new StageLoader(vbox);
 919         sl.getStage().requestFocus();
 920         focusBtn.requestFocus();
 921         Toolkit.getToolkit().firePulse();
 922 
 923         // test initial state
 924         assertEquals(sl.getStage().getScene().getFocusOwner(), focusBtn);
 925         assertTrue(focusBtn.isFocused());
 926         assertEquals(-1, sm.getSelectedIndex());
 927         assertNull(sm.getSelectedItem());
 928 
 929         // move focus to the listview
 930         listView.requestFocus();
 931 
 932         // ensure that there is a selection (where previously there was not one)
 933         assertEquals(sl.getStage().getScene().getFocusOwner(), listView);
 934         assertTrue(listView.isFocused());
 935         assertEquals(-1, sm.getSelectedIndex());
 936         assertNull(sm.getSelectedItem());
 937 
 938         sl.dispose();
 939     }
 940 
 941     private int rt_37061_index_counter = 0;
 942     private int rt_37061_item_counter = 0;
 943     @Test public void test_rt_37061() {
 944         ListView&lt;Integer&gt; tv = new ListView&lt;&gt;();
 945         tv.getItems().add(1);
 946         tv.getSelectionModel().select(0);
 947 
 948         // note we add the listeners after the selection is made, so the counters
 949         // at this point are still both at zero.
 950         tv.getSelectionModel().selectedIndexProperty().addListener((observable, oldValue, newValue) -&gt; {
 951             rt_37061_index_counter++;
 952         });
 953 
 954         tv.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -&gt; {
 955             rt_37061_item_counter++;
 956         });
 957 
 958         // add a new item. This does not impact the selected index or selected item
 959         // so the counters should remain at zero.
 960         tv.getItems().add(2);
 961         assertEquals(0, rt_37061_index_counter);
 962         assertEquals(0, rt_37061_item_counter);
 963     }
 964 
 965     private int rt_37538_count = 0;
 966     @Test public void test_rt_37538_noCNextCall() {
 967         test_rt_37538(false, false);
 968     }
 969 
 970     @Test public void test_rt_37538_callCNextOnce() {
 971         test_rt_37538(true, false);
 972     }
 973 
 974     @Test public void test_rt_37538_callCNextInLoop() {
 975         test_rt_37538(false, true);
 976     }
 977 
 978     private void test_rt_37538(boolean callCNextOnce, boolean callCNextInLoop) {
 979         ListView&lt;Integer&gt; list = new ListView&lt;&gt;();
 980         for ( int i = 1; i &lt;= 50; i++ ) {
 981             list.getItems().add(i);
 982         }
 983 
 984         list.getSelectionModel().getSelectedItems().addListener((ListChangeListener.Change&lt;? extends Integer&gt; c) -&gt; {
 985             if (callCNextOnce) {
 986                 c.next();
 987             } else if (callCNextInLoop) {
 988                 while (c.next()) {
 989                     // no-op
 990                 }
 991             }
 992 
 993             if (rt_37538_count &gt;= 1) {
 994                 Thread.dumpStack();
 995                 fail(&quot;This method should only be called once&quot;);
 996             }
 997 
 998             rt_37538_count++;
 999         });
1000 
1001         StageLoader sl = new StageLoader(list);
1002         assertEquals(0, rt_37538_count);
1003         list.getSelectionModel().select(0);
1004         assertEquals(1, rt_37538_count);
1005         sl.dispose();
1006     }
1007 
1008     @Test
1009     public void test_rt_35395_fixedCellSize() {
1010         test_rt_35395(true);
1011     }
1012 
1013     @Test
1014     public void test_rt_35395_notFixedCellSize() {
1015         test_rt_35395(false);
1016     }
1017 
1018     private int rt_35395_counter;
1019 
1020     private void test_rt_35395(boolean useFixedCellSize) {
1021         rt_35395_counter = 0;
1022 
1023         ObservableList&lt;String&gt; items = FXCollections.observableArrayList();
1024         for (int i = 0; i &lt; 20; ++i) {
1025             items.addAll(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;purple&quot;);
1026         }
1027 
1028         ListView&lt;String&gt; listView = new ListView&lt;&gt;(items);
1029         if (useFixedCellSize) {
1030             listView.setFixedCellSize(24);
1031         }
1032         listView.setCellFactory(lv -&gt; new ListCellShim&lt;String&gt;() {
1033             @Override
1034             public void updateItem(String color, boolean empty) {
1035                 rt_35395_counter += 1;
1036                 super.updateItem(color, empty);
1037                 setText(null);
1038                 if (empty) {
1039                     setGraphic(null);
1040                 } else {
1041                     Rectangle rect = new Rectangle(16, 16);
1042                     rect.setStyle(&quot;-fx-fill: &quot; + color);
1043                     setGraphic(rect);
1044                 }
1045             }
1046         });
1047 
1048         StageLoader sl = new StageLoader(listView);
1049 
1050         Platform.runLater(() -&gt; {
1051             rt_35395_counter = 0;
1052             items.set(10, &quot;yellow&quot;);
1053             Platform.runLater(() -&gt; {
1054                 Toolkit.getToolkit().firePulse();
1055                 assertEquals(1, rt_35395_counter);
1056                 rt_35395_counter = 0;
1057                 items.set(30, &quot;yellow&quot;);
1058                 Platform.runLater(() -&gt; {
1059                     Toolkit.getToolkit().firePulse();
1060                     assertEquals(0, rt_35395_counter);
1061                     rt_35395_counter = 0;
1062                     items.remove(12);
1063                     Platform.runLater(() -&gt; {
1064                         Toolkit.getToolkit().firePulse();
1065                         assertEquals(useFixedCellSize ? 39 : 45, rt_35395_counter);
1066                         rt_35395_counter = 0;
1067                         items.add(12, &quot;yellow&quot;);
1068                         Platform.runLater(() -&gt; {
1069                             Toolkit.getToolkit().firePulse();
1070                             assertEquals(useFixedCellSize ? 39 : 45, rt_35395_counter);
1071                             rt_35395_counter = 0;
1072                             listView.scrollTo(5);
1073                             Platform.runLater(() -&gt; {
1074                                 Toolkit.getToolkit().firePulse();
1075                                 assertEquals(5, rt_35395_counter);
1076                                 rt_35395_counter = 0;
1077                                 listView.scrollTo(55);
1078                                 Platform.runLater(() -&gt; {
1079                                     Toolkit.getToolkit().firePulse();
1080                                     assertEquals(useFixedCellSize ? 17 : 53, rt_35395_counter);
1081                                     sl.dispose();
1082                                 });
1083                             });
1084                         });
1085                     });
1086                 });
1087             });
1088         });
1089     }
1090 
1091     @Test public void test_rt_37632() {
1092         final ObservableList&lt;String&gt; listOne = FXCollections.observableArrayList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);
1093         final ObservableList&lt;String&gt; listTwo = FXCollections.observableArrayList(&quot;C&quot;);
1094 
1095         final ListView&lt;String&gt; listView = new ListView&lt;&gt;();
1096         MultipleSelectionModel&lt;String&gt; sm = listView.getSelectionModel();
1097         listView.setItems(listOne);
1098         listView.getSelectionModel().selectFirst();
1099 
1100         assertEquals(0, sm.getSelectedIndex());
1101         assertEquals(&quot;A&quot;, sm.getSelectedItem());
1102         assertEquals(1, sm.getSelectedIndices().size());
1103         assertEquals(0, (int) sm.getSelectedIndices().get(0));
1104         assertEquals(1, sm.getSelectedItems().size());
1105         assertEquals(&quot;A&quot;, sm.getSelectedItems().get(0));
1106 
1107         listView.setItems(listTwo);
1108 
1109         assertEquals(-1, sm.getSelectedIndex());
1110         assertNull(sm.getSelectedItem());
1111         assertEquals(0, sm.getSelectedIndices().size());
1112         assertEquals(0, sm.getSelectedItems().size());
1113     }
1114 
1115     private int rt_37853_cancelCount;
1116     private int rt_37853_commitCount;
1117     @Test public void test_rt_37853() {
1118         listView.setCellFactory(TextFieldListCell.forListView());
1119         listView.setEditable(true);
1120 
1121         for (int i = 0; i &lt; 10; i++) {
1122             listView.getItems().add(&quot;&quot; + i);
1123         }
1124 
1125         StageLoader sl = new StageLoader(listView);
1126 
1127         listView.setOnEditCancel(editEvent -&gt; rt_37853_cancelCount++);
1128         listView.setOnEditCommit(editEvent -&gt; rt_37853_commitCount++);
1129 
1130         assertEquals(0, rt_37853_cancelCount);
1131         assertEquals(0, rt_37853_commitCount);
1132 
1133         listView.edit(1);
1134         assertNotNull(listView.getEditingIndex());
1135 
1136         listView.getItems().clear();
1137         assertEquals(1, rt_37853_cancelCount);
1138         assertEquals(0, rt_37853_commitCount);
1139 
1140         sl.dispose();
1141     }
1142 
1143     @Test public void test_rt_38787_remove_b() {
1144         // selection moves to &quot;a&quot;
1145         test_rt_38787(&quot;a&quot;, 0, &quot;b&quot;);
1146     }
1147 
1148     @Test public void test_rt_38787_remove_b_c() {
1149         // selection moves to &quot;a&quot;
1150         test_rt_38787(&quot;a&quot;, 0, &quot;b&quot;, &quot;c&quot;);
1151     }
1152 
1153     @Test public void test_rt_38787_remove_c_d() {
1154         // selection moves to &quot;b&quot;
1155         test_rt_38787(&quot;b&quot;, 1, &quot;c&quot;, &quot;d&quot;);
1156     }
1157 
1158     @Test public void test_rt_38787_remove_a() {
1159         // selection moves to &quot;b&quot;, now in index 0
1160         test_rt_38787(&quot;b&quot;, 0, &quot;a&quot;);
1161     }
1162 
1163     @Test public void test_rt_38787_remove_z() {
1164         // selection shouldn&#39;t move as &#39;z&#39; doesn&#39;t exist
1165         test_rt_38787(&quot;b&quot;, 1, &quot;z&quot;);
1166     }
1167 
1168     private void test_rt_38787(String expectedItem, int expectedIndex, String... itemsToRemove) {
1169         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1170         stringListView.getItems().addAll(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;);
1171 
1172         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1173         sm.select(&quot;b&quot;);
1174 
1175         // test pre-conditions
1176         assertEquals(1, sm.getSelectedIndex());
1177         assertEquals(1, (int)sm.getSelectedIndices().get(0));
1178         assertEquals(&quot;b&quot;, sm.getSelectedItem());
1179         assertEquals(&quot;b&quot;, sm.getSelectedItems().get(0));
1180         assertFalse(sm.isSelected(0));
1181         assertTrue(sm.isSelected(1));
1182         assertFalse(sm.isSelected(2));
1183 
1184         // removing items
1185         stringListView.getItems().removeAll(itemsToRemove);
1186 
1187         // testing against expectations
1188         assertEquals(expectedIndex, sm.getSelectedIndex());
1189         assertEquals(expectedIndex, (int)sm.getSelectedIndices().get(0));
1190         assertEquals(expectedItem, sm.getSelectedItem());
1191         assertEquals(expectedItem, sm.getSelectedItems().get(0));
1192     }
1193 
1194     private int rt_38341_indices_count = 0;
1195     private int rt_38341_items_count = 0;
1196     @Test public void test_rt_38341() {
1197         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1198         stringListView.getItems().addAll(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;);
1199 
1200         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1201         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) c -&gt; rt_38341_indices_count++);
1202         sm.getSelectedItems().addListener((ListChangeListener&lt;String&gt;) c -&gt; rt_38341_items_count++);
1203 
1204         assertEquals(0, rt_38341_indices_count);
1205         assertEquals(0, rt_38341_items_count);
1206 
1207         // expand the first child of root, and select it (note: root isn&#39;t visible)
1208         sm.select(1);
1209         assertEquals(1, sm.getSelectedIndex());
1210         assertEquals(1, sm.getSelectedIndices().size());
1211         assertEquals(1, (int)sm.getSelectedIndices().get(0));
1212         assertEquals(1, sm.getSelectedItems().size());
1213         assertEquals(&quot;b&quot;, sm.getSelectedItem());
1214         assertEquals(&quot;b&quot;, sm.getSelectedItems().get(0));
1215 
1216         assertEquals(1, rt_38341_indices_count);
1217         assertEquals(1, rt_38341_items_count);
1218 
1219         // now delete it
1220         stringListView.getItems().remove(1);
1221 
1222         // selection should move to the childs parent in index 0
1223         assertEquals(0, sm.getSelectedIndex());
1224         assertEquals(1, sm.getSelectedIndices().size());
1225         assertEquals(0, (int)sm.getSelectedIndices().get(0));
1226         assertEquals(1, sm.getSelectedItems().size());
1227         assertEquals(&quot;a&quot;, sm.getSelectedItem());
1228         assertEquals(&quot;a&quot;, sm.getSelectedItems().get(0));
1229 
1230         // we also expect there to be an event in the selection model for
1231         // selected indices and selected items
1232         assertEquals(sm.getSelectedIndices() +&quot;&quot;, 2, rt_38341_indices_count);
1233         assertEquals(2, rt_38341_items_count);
1234     }
1235 
1236     @Test public void test_rt_39132() {
1237         ObservableList items = FXCollections.observableArrayList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);
1238         ListView listView = new ListView&lt;&gt;();
1239         listView.setItems(items);
1240 
1241         MultipleSelectionModel sm = listView.getSelectionModel();
1242         sm.select(0);
1243 
1244         assertEquals(0, sm.getSelectedIndex());
1245         assertEquals(&quot;one&quot;, sm.getSelectedItem());
1246 
1247         items.add(0, &quot;new item&quot;);
1248         assertEquals(1, sm.getSelectedIndex());
1249         assertEquals(&quot;one&quot;, sm.getSelectedItem());
1250     }
1251 
1252     private int rt_38943_index_count = 0;
1253     private int rt_38943_item_count = 0;
1254     @Test public void test_rt_38943() {
1255         ListView&lt;String&gt; listView = new ListView&lt;&gt;(FXCollections.observableArrayList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;));
1256 
1257         MultipleSelectionModel sm = listView.getSelectionModel();
1258 
1259         sm.selectedIndexProperty().addListener((observable, oldValue, newValue) -&gt; rt_38943_index_count++);
1260         sm.selectedItemProperty().addListener((observable, oldValue, newValue) -&gt; rt_38943_item_count++);
1261 
1262         assertEquals(-1, sm.getSelectedIndex());
1263         assertNull(sm.getSelectedItem());
1264         assertEquals(0, rt_38943_index_count);
1265         assertEquals(0, rt_38943_item_count);
1266 
1267         sm.select(0);
1268         assertEquals(0, sm.getSelectedIndex());
1269         assertEquals(&quot;one&quot;, sm.getSelectedItem());
1270         assertEquals(1, rt_38943_index_count);
1271         assertEquals(1, rt_38943_item_count);
1272 
1273         sm.clearSelection(0);
1274         assertEquals(-1, sm.getSelectedIndex());
1275         assertNull(sm.getSelectedItem());
1276         assertEquals(2, rt_38943_index_count);
1277         assertEquals(2, rt_38943_item_count);
1278     }
1279 
1280     @Test public void test_rt_38884() {
1281         ListView&lt;String&gt; listView = new ListView&lt;&gt;();
1282         ObservableList&lt;String&gt; items = listView.getItems();
1283 
1284         listView.getSelectionModel().getSelectedItems().addListener((ListChangeListener.Change&lt;? extends String&gt; c) -&gt; {
1285             while (c.next()) {
1286                 if (c.wasRemoved()) {
1287                     assertTrue(c.getRemovedSize() &gt; 0);
1288 
1289                     List&lt;? extends String&gt; removed = c.getRemoved();
1290                     String removedItem = null;
1291                     try {
1292                         removedItem = removed.get(0);
1293                     } catch (Exception e) {
1294                         fail();
1295                     }
1296 
1297                     assertEquals(&quot;foo&quot;, removedItem);
1298                 }
1299             }
1300         });
1301 
1302         items.add(&quot;foo&quot;);
1303         listView.getSelectionModel().select(0);
1304         items.clear();
1305     }
1306 
1307     private int rt_37360_add_count = 0;
1308     private int rt_37360_remove_count = 0;
1309     @Test public void test_rt_37360() {
1310         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1311         stringListView.getItems().addAll(&quot;a&quot;, &quot;b&quot;);
1312 
1313         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1314         sm.setSelectionMode(SelectionMode.MULTIPLE);
1315         sm.getSelectedItems().addListener((ListChangeListener&lt;String&gt;) c -&gt; {
1316             while (c.next()) {
1317                 if (c.wasAdded()) {
1318                     rt_37360_add_count += c.getAddedSize();
1319                 }
1320                 if (c.wasRemoved()) {
1321                     rt_37360_remove_count += c.getRemovedSize();
1322                 }
1323             }
1324         });
1325 
1326         assertEquals(0, sm.getSelectedItems().size());
1327         assertEquals(0, rt_37360_add_count);
1328         assertEquals(0, rt_37360_remove_count);
1329 
1330         sm.select(0);
1331         assertEquals(1, sm.getSelectedItems().size());
1332         assertEquals(1, rt_37360_add_count);
1333         assertEquals(0, rt_37360_remove_count);
1334 
1335         sm.select(1);
1336         assertEquals(2, sm.getSelectedItems().size());
1337         assertEquals(2, rt_37360_add_count);
1338         assertEquals(0, rt_37360_remove_count);
1339 
1340         sm.clearAndSelect(1);
1341         assertEquals(1, sm.getSelectedItems().size());
1342         assertEquals(2, rt_37360_add_count);
1343         assertEquals(1, rt_37360_remove_count);
1344     }
1345 
1346     @Test public void test_rt_38491() {
1347         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1348         stringListView.getItems().addAll(&quot;a&quot;, &quot;b&quot;);
1349 
1350         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1351         sm.setSelectionMode(SelectionMode.MULTIPLE);
1352 
1353         FocusModel&lt;String&gt; fm = stringListView.getFocusModel();
1354 
1355         // click on row 0
1356         VirtualFlowTestUtils.clickOnRow(stringListView, 0);
1357         assertTrue(sm.isSelected(0));
1358         assertEquals(&quot;a&quot;, sm.getSelectedItem());
1359         assertTrue(fm.isFocused(0));
1360         assertEquals(&quot;a&quot;, fm.getFocusedItem());
1361         assertEquals(0, fm.getFocusedIndex());
1362 
1363         int anchor = ListCellBehavior.getAnchor(stringListView, -1);
1364         assertTrue(ListCellBehavior.hasNonDefaultAnchor(stringListView));
1365         assertEquals(0, anchor);
1366 
1367         // now add a new item at row 0. This has the effect of pushing down
1368         // the selected item into row 1.
1369         stringListView.getItems().add(0, &quot;z&quot;);
1370 
1371         // The first bug was that selection and focus were not moving down to
1372         // be on row 1, so we test that now
1373         assertFalse(sm.isSelected(0));
1374         assertFalse(fm.isFocused(0));
1375         assertTrue(sm.isSelected(1));
1376         assertEquals(&quot;a&quot;, sm.getSelectedItem());
1377         assertTrue(fm.isFocused(1));
1378         assertEquals(&quot;a&quot;, fm.getFocusedItem());
1379         assertEquals(1, fm.getFocusedIndex());
1380 
1381         // The second bug was that the anchor was not being pushed down as well
1382         // (when it should).
1383         anchor = ListCellBehavior.getAnchor(stringListView, -1);
1384         assertTrue(ListCellBehavior.hasNonDefaultAnchor(stringListView));
1385         assertEquals(1, anchor);
1386     }
1387 
1388     private final ObservableList&lt;String&gt; rt_39256_list = FXCollections.observableArrayList();
1389     @Test public void test_rt_39256() {
1390         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1391         stringListView.getItems().addAll(&quot;a&quot;,&quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
1392 
1393         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1394         sm.setSelectionMode(SelectionMode.MULTIPLE);
1395 
1396 //        rt_39256_list.addListener((ListChangeListener&lt;String&gt;) change -&gt; {
1397 //            while (change.next()) {
1398 //                System.err.println(&quot;number of selected persons (in bound list): &quot; + change.getList().size());
1399 //            }
1400 //        });
1401 
1402         Bindings.bindContent(rt_39256_list, sm.getSelectedItems());
1403 
1404         assertEquals(0, sm.getSelectedItems().size());
1405         assertEquals(0, rt_39256_list.size());
1406 
1407         sm.selectAll();
1408         assertEquals(4, sm.getSelectedItems().size());
1409         assertEquals(4, rt_39256_list.size());
1410 
1411         sm.selectAll();
1412         assertEquals(4, sm.getSelectedItems().size());
1413         assertEquals(4, rt_39256_list.size());
1414 
1415         sm.selectAll();
1416         assertEquals(4, sm.getSelectedItems().size());
1417         assertEquals(4, rt_39256_list.size());
1418     }
1419 
1420     private final ObservableList&lt;String&gt; rt_39482_list = FXCollections.observableArrayList();
1421     @Test public void test_rt_39482() {
1422         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1423         stringListView.getItems().addAll(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
1424 
1425         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1426         sm.setSelectionMode(SelectionMode.MULTIPLE);
1427 
1428         sm.getSelectedItems().addListener((ListChangeListener&lt;String&gt;) change -&gt; {
1429             while (change.next()) {
1430                 System.out.println(&quot;sm.getSelectedItems(): &quot; + change.getList());
1431             }
1432         });
1433 
1434         rt_39482_list.addListener((ListChangeListener&lt;String&gt;) change -&gt; {
1435             while (change.next()) {
1436                 System.out.println(&quot;rt_39482_list: &quot; + change.getList());
1437             }
1438         });
1439 
1440         Bindings.bindContent(rt_39482_list, sm.getSelectedItems());
1441 
1442         assertEquals(0, sm.getSelectedItems().size());
1443         assertEquals(0, rt_39482_list.size());
1444 
1445         test_rt_39482_selectRow(&quot;a&quot;, sm, 0);
1446         test_rt_39482_selectRow(&quot;b&quot;, sm, 1);
1447         test_rt_39482_selectRow(&quot;c&quot;, sm, 2);
1448         test_rt_39482_selectRow(&quot;d&quot;, sm, 3);
1449     }
1450 
1451     private void test_rt_39482_selectRow(String expectedString,
1452                                          MultipleSelectionModel&lt;String&gt; sm,
1453                                          int rowToSelect) {
1454         System.out.println(&quot;\nSelect row &quot; + rowToSelect);
1455         sm.selectAll();
1456         assertEquals(4, sm.getSelectedIndices().size());
1457         assertEquals(4, sm.getSelectedItems().size());
1458         assertEquals(4, rt_39482_list.size());
1459 
1460         sm.clearAndSelect(rowToSelect);
1461         assertEquals(1, sm.getSelectedIndices().size());
1462         assertEquals(1, sm.getSelectedItems().size());
1463         assertEquals(expectedString, sm.getSelectedItem());
1464         assertEquals(expectedString, rt_39482_list.get(0));
1465         assertEquals(1, rt_39482_list.size());
1466     }
1467 
1468     @Test public void test_rt_39559_useSM_selectAll() {
1469         test_rt_39559(true);
1470     }
1471 
1472     @Test public void test_rt_39559_useKeyboard_selectAll() {
1473         test_rt_39559(false);
1474     }
1475 
1476     private void test_rt_39559(boolean useSMSelectAll) {
1477         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1478         stringListView.getItems().addAll(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
1479 
1480         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1481         sm.setSelectionMode(SelectionMode.MULTIPLE);
1482 
1483         StageLoader sl = new StageLoader(stringListView);
1484         KeyEventFirer keyboard = new KeyEventFirer(stringListView);
1485 
1486         assertEquals(0, sm.getSelectedItems().size());
1487 
1488         sm.clearAndSelect(0);
1489 
1490         if (useSMSelectAll) {
1491             sm.selectAll();
1492         } else {
1493             keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
1494         }
1495 
1496         assertEquals(4, sm.getSelectedItems().size());
1497         assertEquals(0, (int) ListCellBehavior.getAnchor(stringListView, -1));
1498 
1499         keyboard.doKeyPress(KeyCode.DOWN, KeyModifier.SHIFT);
1500 
1501         assertEquals(0, (int) ListCellBehavior.getAnchor(stringListView, -1));
1502         assertEquals(2, sm.getSelectedItems().size());
1503         assertEquals(&quot;a&quot;, sm.getSelectedItems().get(0));
1504         assertEquals(&quot;b&quot;, sm.getSelectedItems().get(1));
1505 
1506         sl.dispose();
1507     }
1508 
<a name="2" id="anc2"></a><span class="line-modified">1509     @Test public void test_switchingSelectionMode() {</span>
1510         ListView&lt;String&gt; listView = new ListView&lt;&gt;();
1511         listView.getItems().addAll(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
1512 
1513         MultipleSelectionModel&lt;String&gt; sm = listView.getSelectionModel();
1514         StageLoader sl = new StageLoader(listView);
1515         KeyEventFirer keyboard = new KeyEventFirer(listView);
1516 
1517         assertEquals(0, sm.getSelectedItems().size());
1518         sm.clearAndSelect(0);
1519         assertEquals(1, sm.getSelectedItems().size());
1520         keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
1521         assertEquals(1, sm.getSelectedItems().size());
1522 
1523         sm.setSelectionMode(SelectionMode.MULTIPLE);
<a name="3" id="anc3"></a>
1524         keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
1525         assertEquals(4, sm.getSelectedItems().size());
1526 
1527         sm.setSelectionMode(SelectionMode.SINGLE);
1528         assertEquals(1, sm.getSelectedItems().size());
1529         keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
1530         assertEquals(1, sm.getSelectedItems().size());
1531 
<a name="4" id="anc4"></a><span class="line-removed">1532         sm.setSelectionMode(SelectionMode.MULTIPLE);</span>
<span class="line-removed">1533         assertEquals(1, sm.getSelectedItems().size());</span>
<span class="line-removed">1534         keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());</span>
<span class="line-removed">1535         assertEquals(4, sm.getSelectedItems().size());</span>
<span class="line-removed">1536 </span>
1537         sl.dispose();
1538     }
1539 
1540     @Test public void test_rt_16068_firstElement_selectAndRemoveSameRow() {
1541         // select and then remove the &#39;a&#39; item, selection and focus should both
1542         // stay at the first row, now &#39;b&#39;
1543         test_rt_16068(0, 0, 0);
1544     }
1545 
1546     @Test public void test_rt_16068_firstElement_selectRowAndRemoveLaterSibling() {
1547         // select row &#39;a&#39;, and remove row &#39;c&#39;, selection and focus should not change
1548         test_rt_16068(0, 2, 0);
1549     }
1550 
1551     @Test public void test_rt_16068_middleElement_selectAndRemoveSameRow() {
1552         // select and then remove the &#39;b&#39; item, selection and focus should both
1553         // move up one row to the &#39;a&#39; item
1554         test_rt_16068(1, 1, 0);
1555     }
1556 
1557     @Test public void test_rt_16068_middleElement_selectRowAndRemoveLaterSibling() {
1558         // select row &#39;b&#39;, and remove row &#39;c&#39;, selection and focus should not change
1559         test_rt_16068(1, 2, 1);
1560     }
1561 
1562     @Test public void test_rt_16068_middleElement_selectRowAndRemoveEarlierSibling() {
1563         // select row &#39;b&#39;, and remove row &#39;a&#39;, selection and focus should move up
1564         // one row, remaining on &#39;b&#39;
1565         test_rt_16068(1, 0, 0);
1566     }
1567 
1568     @Test public void test_rt_16068_lastElement_selectAndRemoveSameRow() {
1569         // select and then remove the &#39;d&#39; item, selection and focus should both
1570         // move up one row to the &#39;c&#39; item
1571         test_rt_16068(3, 3, 2);
1572     }
1573 
1574     @Test public void test_rt_16068_lastElement_selectRowAndRemoveEarlierSibling() {
1575         // select row &#39;d&#39;, and remove row &#39;a&#39;, selection and focus should move up
1576         // one row, remaining on &#39;d&#39;
1577         test_rt_16068(3, 0, 2);
1578     }
1579 
1580     private void test_rt_16068(int indexToSelect, int indexToRemove, int expectedIndex) {
1581         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1582         stringListView.getItems().addAll(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
1583 
1584         MultipleSelectionModel&lt;?&gt; sm = stringListView.getSelectionModel();
1585         FocusModel&lt;?&gt; fm = stringListView.getFocusModel();
1586 
1587         sm.select(indexToSelect);
1588         assertEquals(indexToSelect, sm.getSelectedIndex());
1589         assertEquals(stringListView.getItems().get(indexToSelect), sm.getSelectedItem());
1590         assertEquals(indexToSelect, fm.getFocusedIndex());
1591         assertEquals(stringListView.getItems().get(indexToSelect), fm.getFocusedItem());
1592 
1593         stringListView.getItems().remove(indexToRemove);
1594         assertEquals(expectedIndex, sm.getSelectedIndex());
1595         assertEquals(stringListView.getItems().get(expectedIndex), sm.getSelectedItem());
1596         assertEquals(expectedIndex, fm.getFocusedIndex());
1597         assertEquals(stringListView.getItems().get(expectedIndex), fm.getFocusedItem());
1598     }
1599 
1600     @Test public void test_rt_22599() {
1601         ObservableList&lt;RT22599_DataType&gt; initialData = FXCollections.observableArrayList(
1602                 new RT22599_DataType(1, &quot;row1&quot;),
1603                 new RT22599_DataType(2, &quot;row2&quot;),
1604                 new RT22599_DataType(3, &quot;row3&quot;)
1605         );
1606 
1607         ListView&lt;RT22599_DataType&gt; listView = new ListView&lt;&gt;();
1608         listView.setItems(initialData);
1609 
1610         StageLoader sl = new StageLoader(listView);
1611 
1612         // testing initial state
1613         assertNotNull(listView.getSkin());
1614         assertEquals(&quot;row1&quot;, VirtualFlowTestUtils.getCell(listView, 0).getText());
1615         assertEquals(&quot;row2&quot;, VirtualFlowTestUtils.getCell(listView, 1).getText());
1616         assertEquals(&quot;row3&quot;, VirtualFlowTestUtils.getCell(listView, 2).getText());
1617 
1618         // change row 0 (where &quot;row1&quot; currently resides), keeping same id.
1619         // Because &#39;set&#39; is called, the control should update to the new content
1620         // without any user interaction
1621         RT22599_DataType data;
1622         initialData.set(0, data = new RT22599_DataType(0, &quot;row1a&quot;));
1623         Toolkit.getToolkit().firePulse();
1624         assertEquals(&quot;row1a&quot;, VirtualFlowTestUtils.getCell(listView, 0).getText());
1625 
1626         // change the row 0 (where we currently have &quot;row1a&quot;) value directly.
1627         // Because there is no associated property, this won&#39;t be observed, so
1628         // the control should still show &quot;row1a&quot; rather than &quot;row1b&quot;
1629         data.text = &quot;row1b&quot;;
1630         Toolkit.getToolkit().firePulse();
1631         assertEquals(&quot;row1a&quot;, VirtualFlowTestUtils.getCell(listView, 0).getText());
1632 
1633         // call refresh() to force a refresh of all visible cells
1634         listView.refresh();
1635         Toolkit.getToolkit().firePulse();
1636         assertEquals(&quot;row1b&quot;, VirtualFlowTestUtils.getCell(listView, 0).getText());
1637 
1638         sl.dispose();
1639     }
1640 
1641     private static class RT22599_DataType {
1642         public int id = 0;
1643         public String text = &quot;&quot;;
1644 
1645         public RT22599_DataType(int id, String text) {
1646             this.id = id;
1647             this.text = text;
1648         }
1649 
1650         @Override public String toString() {
1651             return text;
1652         }
1653 
1654         @Override public boolean equals(Object obj) {
1655             if (obj == null) return false;
1656             return id == ((RT22599_DataType)obj).id;
1657         }
1658     }
1659 
1660     private int rt_39966_count = 0;
1661     @Test public void test_rt_39966() {
1662         ObservableList&lt;String&gt; list = FXCollections.observableArrayList(&quot;Hello World&quot;);
1663         ListView&lt;String&gt; listView = new ListView&lt;&gt;(list);
1664 
1665         StageLoader sl = new StageLoader(listView);
1666 
1667         // initially there is no selection
1668         assertTrue(listView.getSelectionModel().isEmpty());
1669 
1670         listView.getSelectionModel().selectedItemProperty().addListener((value, s1, s2) -&gt; {
1671             if (rt_39966_count == 0) {
1672                 rt_39966_count++;
1673                 assertFalse(listView.getSelectionModel().isEmpty());
1674             } else {
1675                 assertTrue(listView.getSelectionModel().isEmpty());
1676             }
1677         });
1678 
1679         // our assertion two lines down always succeeds. What fails is our
1680         // assertion above within the listener.
1681         listView.getSelectionModel().select(0);
1682         assertFalse(listView.getSelectionModel().isEmpty());
1683 
1684         list.remove(0);
1685         assertTrue(listView.getSelectionModel().isEmpty());
1686 
1687         sl.dispose();
1688     }
1689 
1690     /**
1691      * Bullet 1: selected index must be updated
1692      * Corner case: last selected. Fails for core
1693      */
1694     @Test public void test_rt_40012_selectedAtLastOnDisjointRemoveItemsAbove() {
1695         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);
1696         ListView&lt;String&gt; listView = new ListView&lt;&gt;(items);
1697         SelectionModel sm = listView.getSelectionModel();
1698 
1699         int last = items.size() - 1;
1700 
1701         // selecting item &quot;5&quot;
1702         sm.select(last);
1703 
1704         // disjoint remove of 2 elements above the last selected
1705         // Removing &quot;1&quot; and &quot;3&quot;
1706         items.removeAll(items.get(1), items.get(3));
1707 
1708         // selection should move up two places such that it remains on item &quot;5&quot;,
1709         // but in index (last - 2).
1710         int expected = last - 2;
1711         assertEquals(&quot;5&quot;, sm.getSelectedItem());
1712         assertEquals(&quot;selected index after disjoint removes above&quot;, expected, sm.getSelectedIndex());
1713     }
1714 
1715     /**
1716      * Variant of 1: if selectedIndex is not updated,
1717      * the old index is no longer valid
1718      * for accessing the items.
1719      */
1720     @Test public void test_rt_40012_accessSelectedAtLastOnDisjointRemoveItemsAbove() {
1721         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);
1722         ListView&lt;String&gt; listView = new ListView&lt;&gt;(items);
1723         SelectionModel sm = listView.getSelectionModel();
1724 
1725         int last = items.size() - 1;
1726 
1727         // selecting item &quot;5&quot;
1728         sm.select(last);
1729 
1730         // disjoint remove of 2 elements above the last selected
1731         items.removeAll(items.get(1), items.get(3));
1732         int selected = sm.getSelectedIndex();
1733         if (selected &gt; -1) {
1734             items.get(selected);
1735         }
1736     }
1737 
1738     /**
1739      * Bullet 2: selectedIndex notification count
1740      *
1741      * Note that we don&#39;t use the corner case of having the last index selected
1742      * (which fails already on updating the index)
1743      */
1744     private int rt_40012_count = 0;
1745     @Test public void test_rt_40012_selectedIndexNotificationOnDisjointRemovesAbove() {
1746         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);
1747         ListView&lt;String&gt; listView = new ListView&lt;&gt;(items);
1748         SelectionModel sm = listView.getSelectionModel();
1749 
1750         int last = items.size() - 2;
1751         sm.select(last);
1752         assertEquals(last, sm.getSelectedIndex());
1753 
1754         rt_40012_count = 0;
1755         sm.selectedIndexProperty().addListener(o -&gt; rt_40012_count++);
1756 
1757         // disjoint remove of 2 elements above the last selected
1758         items.removeAll(items.get(1), items.get(3));
1759         assertEquals(&quot;sanity: selectedIndex must be shifted by -2&quot;, last - 2, sm.getSelectedIndex());
1760         assertEquals(&quot;must fire single event on removes above&quot;, 1, rt_40012_count);
1761     }
1762 
1763     /**
1764      * Bullet 3: unchanged selectedItem must not fire change
1765      */
1766     @Test
1767     public void test_rt_40012_selectedItemNotificationOnDisjointRemovesAbove() {
1768         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);
1769         ListView&lt;String&gt; listView = new ListView&lt;&gt;(items);
1770         SelectionModel sm = listView.getSelectionModel();
1771 
1772         int last = items.size() - 2;
1773         Object lastItem = items.get(last);
1774         sm.select(last);
1775         assertEquals(lastItem, sm.getSelectedItem());
1776 
1777         rt_40012_count = 0;
1778         sm.selectedItemProperty().addListener(o -&gt; rt_40012_count++);
1779 
1780         // disjoint remove of 2 elements above the last selected
1781         items.removeAll(items.get(1), items.get(3));
1782         assertEquals(&quot;sanity: selectedItem unchanged&quot;, lastItem, sm.getSelectedItem());
1783         assertEquals(&quot;must not fire on unchanged selected item&quot;, 0, rt_40012_count);
1784     }
1785 
1786     @Test public void test_rt_40185() {
1787         final ListView&lt;String&gt; lv = new ListView&lt;&gt;();
1788         final ArrayList&lt;Integer&gt; expected = new ArrayList&lt;&gt;();
1789         Collections.addAll(expected, 1, 2);
1790 
1791         lv.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
1792         lv.getSelectionModel().getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) change -&gt; {
1793             while (change.next()) {
1794                 if (change.wasRemoved()) {
1795                     assertEquals(expected, change.getRemoved());
1796                 }
1797             }
1798         });
1799 
1800         lv.getItems().addAll(&quot;-0-&quot;,&quot;-1-&quot;,&quot;-2-&quot;);
1801         lv.getSelectionModel().selectIndices(1, 2);
1802         lv.getSelectionModel().clearSelection();
1803     }
1804 
1805     /**
1806      * ClearAndSelect fires invalid change event if selectedIndex is unchanged.
1807      */
1808     private int rt_40212_count = 0;
1809     @Test public void test_rt_40212() {
1810         final ListView&lt;Integer&gt; lv = new ListView&lt;&gt;();
1811         for (int i = 0; i &lt; 10; i++) {
1812             lv.getItems().add(i);
1813         }
1814 
1815         MultipleSelectionModel&lt;Integer&gt; sm = lv.getSelectionModel();
1816         sm.setSelectionMode(SelectionMode.MULTIPLE);
1817 
1818         sm.selectRange(3, 5);
1819         int selected = sm.getSelectedIndex();
1820 
1821         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) change -&gt; {
1822             assertEquals(&quot;sanity: selectedIndex unchanged&quot;, selected, sm.getSelectedIndex());
1823             while(change.next()) {
1824                 assertEquals(&quot;single event on clearAndSelect already selected&quot;, 1, ++rt_40212_count);
1825 
1826                 boolean type = change.wasAdded() || change.wasRemoved() || change.wasPermutated() || change.wasUpdated();
1827                 assertTrue(&quot;at least one of the change types must be true&quot;, type);
1828             }
1829         });
1830 
1831         sm.clearAndSelect(selected);
1832     }
1833 
1834     @Test public void test_rt_40280() {
1835         final ListView&lt;String&gt; view = new ListView&lt;&gt;();
1836         StageLoader sl = new StageLoader(view);
1837         view.getFocusModel().getFocusedIndex();
1838         sl.dispose();
1839     }
1840 
1841     /**
1842      * Test list change of selectedIndices on setIndices. Fails for core ..
1843      */
1844     @Test public void test_rt_40263() {
1845         final ListView&lt;Integer&gt; lv = new ListView&lt;&gt;();
1846         for (int i = 0; i &lt; 10; i++) {
1847             lv.getItems().add(i);
1848         }
1849 
1850         MultipleSelectionModel&lt;Integer&gt; sm = lv.getSelectionModel();
1851         sm.setSelectionMode(SelectionMode.MULTIPLE);
1852 
1853         int[] indices = new int[]{2, 5, 7};
1854         ListChangeListener&lt;Integer&gt; l = c -&gt; {
1855             // firstly, we expect only one change
1856             int subChanges = 0;
1857             while(c.next()) {
1858                 subChanges++;
1859             }
1860             assertEquals(1, subChanges);
1861 
1862             // secondly, we expect the added size to be three, as that is the
1863             // number of items selected
1864             c.reset();
1865             c.next();
1866             System.out.println(&quot;Added items: &quot; + c.getAddedSubList());
1867             assertEquals(indices.length, c.getAddedSize());
1868             assertArrayEquals(indices, c.getAddedSubList().stream().mapToInt(i -&gt; i).toArray());
1869         };
1870         sm.getSelectedIndices().addListener(l);
1871         sm.selectIndices(indices[0], indices);
1872     }
1873 
1874     @Test public void test_jdk8141124() {
1875         ListView&lt;String&gt; listView = new ListView&lt;&gt;();
1876         ObservableList&lt;String&gt; items = FXCollections.observableArrayList();
1877         SortedList&lt;String&gt; sortedItems = new SortedList&lt;&gt;(items);
1878         sortedItems.setComparator(String::compareTo);
1879         listView.setItems(sortedItems);
1880 
1881         MultipleSelectionModel&lt;String&gt; sm = listView.getSelectionModel();
1882 
1883         items.add(&quot;2&quot;);
1884         listView.getSelectionModel().selectFirst();
1885         assertEquals(&quot;2&quot;, sm.getSelectedItem());
1886         assertEquals(0, sm.getSelectedIndex());
1887         assertEquals(0, (int) sm.getSelectedIndices().get(0));
1888         assertEquals(&quot;2&quot;, sm.getSelectedItems().get(0));
1889 
1890         items.addAll(&quot;1&quot;, &quot;3&quot;);
1891         assertEquals(&quot;2&quot;, sm.getSelectedItem());
1892         assertEquals(1, sm.getSelectedIndex());
1893         assertEquals(1, (int) sm.getSelectedIndices().get(0));
1894         assertEquals(&quot;2&quot;, sm.getSelectedItems().get(0));
1895     }
1896 
1897     @Test public void test_jdk_8143594() {
1898         MultipleSelectionModel model = listView.getSelectionModel();
1899         model.setSelectionMode(SelectionMode.MULTIPLE);
1900 
1901         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, null);
1902 
1903         model.select(0);
1904         model.clearAndSelect(2);
1905         model.clearAndSelect(0);
1906         model.clearAndSelect(2);
1907     }
1908 
1909     @Test public void test_jdk_8145887_selectedIndices_ListIterator() {
1910         int selectIndices[] = { 4, 7, 9 };
1911         ListView&lt;Integer&gt; lv = new ListView&lt;&gt;();
1912         for (int i = 0; i &lt; 10; ++i) {
1913             lv.getItems().add(i);
1914         }
1915 
1916         MultipleSelectionModel msm = lv.getSelectionModel();
1917         msm.setSelectionMode(SelectionMode.MULTIPLE);
1918         for (int i = 0 ; i &lt; selectIndices.length; ++i) {
1919             msm.select(selectIndices[i]);
1920         }
1921 
1922         ListIterator iter = lv.getSelectionModel().getSelectedIndices().listIterator();
1923 
1924         // Step 1. Initial values
1925         assertEquals(0, iter.nextIndex());
1926         assertEquals(-1, iter.previousIndex());
1927         assertEquals(true, iter.hasNext());
1928         assertEquals(false, iter.hasPrevious());
1929 
1930         // Step 2. Iterate forward.
1931         assertEquals(4, iter.next());
1932         assertEquals(1, iter.nextIndex());
1933         assertEquals(0, iter.previousIndex());
1934         assertEquals(true, iter.hasNext());
1935         assertEquals(true, iter.hasPrevious());
1936 
1937         // Step 3. Iterate forward.
1938         // Values would be at similar state of Step 2.
1939         assertEquals(7, iter.next());
1940 
1941         // Step 4. Iterate forward to Last element.
1942         assertEquals(9, iter.next());
1943         assertEquals(3, iter.nextIndex());
1944         assertEquals(2, iter.previousIndex());
1945         assertEquals(false, iter.hasNext());
1946         assertEquals(true, iter.hasPrevious());
1947 
1948         // Step 5. Verify NoSuchElementException by next()
1949         try {
1950             iter.next();
1951         } catch (Exception e) {
1952             assert(e instanceof NoSuchElementException);
1953         }
1954 
1955         // Step 6. Iterate backward to Last element.
1956         assertEquals(9, iter.previous());
1957         assertEquals(2, iter.nextIndex());
1958         assertEquals(1, iter.previousIndex());
1959         assertEquals(true, iter.hasNext());
1960         assertEquals(true, iter.hasPrevious());
1961 
1962         // Step 7. Iterate forward to Last element.
1963         assertEquals(9, iter.next());
1964         assertEquals(3, iter.nextIndex());
1965         assertEquals(2, iter.previousIndex());
1966         assertEquals(false, iter.hasNext());
1967         assertEquals(true, iter.hasPrevious());
1968 
1969         // Step 8. Iterate forward to last element.
1970         // Values would be at Same state of Step 2.
1971         assertEquals(9, iter.previous());
1972 
1973         // Step 9. Iterate backward.
1974         assertEquals(7, iter.previous());
1975         assertEquals(1, iter.nextIndex());
1976         assertEquals(0, iter.previousIndex());
1977         assertEquals(true, iter.hasNext());
1978         assertEquals(true, iter.hasPrevious());
1979 
1980         // Step 10. Iterate back to first element.
1981         assertEquals(4, iter.previous());
1982         assertEquals(0, iter.nextIndex());
1983         assertEquals(-1, iter.previousIndex());
1984         assertEquals(true, iter.hasNext());
1985         assertEquals(false, iter.hasPrevious());
1986 
1987         // Step 11. Verify NoSuchElementException by previous()
1988         try {
1989             iter.previous();
1990         } catch (Exception e) {
1991             assert(e instanceof NoSuchElementException);
1992         }
1993     }
1994 
1995     @Test public void testListEditStartOnCellStandalone_JDK8187432() {
1996         ListView&lt;String&gt; control = new ListView&lt;&gt;(FXCollections
1997                 .observableArrayList(&quot;Item1&quot;, &quot;Item2&quot;, &quot;Item3&quot;, &quot;Item4&quot;));
1998         control.setEditable(true);
1999         control.setCellFactory(TextFieldListCell.forListView());
2000         StageLoader sl = new StageLoader(control);
2001         int editIndex = 2;
2002 
2003         IndexedCell cell = VirtualFlowTestUtils.getCell(control, editIndex);
2004         ObjectProperty&lt;ListView.EditEvent&gt; editEvent = new SimpleObjectProperty&lt;&gt;();
2005         control.addEventHandler(ListView.editStartEvent(), e -&gt; editEvent.set(e));
2006 
2007         // start edit on cell
2008         cell.startEdit();
2009 
2010         // test cell state
2011         assertTrue(cell.isEditing());
2012         assertEquals(editIndex, cell.getIndex());
2013 
2014         // test editEvent
2015         assertNotNull(editEvent.get());
2016         assertEquals(&quot;type is startEdit&quot;,
2017                      ListView.editStartEvent(), editEvent.get().getEventType());
2018         assertEquals(&quot;index on start event&quot;,
2019                      editIndex, editEvent.get().getIndex());
2020 
2021         sl.dispose();
2022     }
2023 
2024     @Test
2025     public void testEventIndicesOnSelectRange() {
2026         ObservableList&lt;String&gt; listItems = FXCollections.observableArrayList(&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;);
2027         final ListView&lt;String&gt; lv = new ListView&lt;&gt;();
2028         lv.setItems(listItems);
2029         MultipleSelectionModel&lt;String&gt; sm = lv.getSelectionModel();
2030 
2031         int selected = 1;
2032         sm.setSelectionMode(SelectionMode.MULTIPLE);
2033         sm.select(selected);
2034         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) ch -&gt; {
2035             if (ch.next()) {
2036                 assertEquals(&quot;Two items should be selected.&quot;, 2, ch.getList().size());
2037                 assertEquals(&quot;Selection range should be from index 1 &quot;, 1, ch.getFrom());
2038                 assertEquals(&quot;Selection range should be till index 2 &quot;, 2, ch.getTo());
2039             } else {
2040                 fail(&quot;Change event is expected when selection is changed.&quot;);
2041             }
2042         });
2043         int focus = lv.getFocusModel().getFocusedIndex();
2044         assertEquals(&quot;Selected item should be focused.&quot;, selected, focus);
2045         // Select the next element
2046         sm.selectRange(selected, focus + 2);
2047         assertEquals(&quot;Two items should be selected.&quot;, 2, sm.getSelectedIndices().size());
2048         assertEquals(&quot;List item at index 1 should be selected&quot;, 1, (int) sm.getSelectedIndices().get(0));
2049         assertEquals(&quot;List item at index 2 should be selected&quot;, 2, (int) sm.getSelectedIndices().get(1));
2050     }
2051 
2052     @Test public void testExcludeKeyMappingsForComboBoxEditor() {
2053         ListView&lt;String&gt; listView = new ListView&lt;&gt;(FXCollections
2054                 .observableArrayList(&quot;Item1&quot;, &quot;Item2&quot;));
<a name="5" id="anc5"></a><span class="line-removed">2055         listView.setCellFactory(TextFieldListCell.forListView());</span>
2056         StageLoader sl = new StageLoader(listView);
2057 
2058         ListViewBehavior lvBehavior = (ListViewBehavior) ControlSkinFactory.getBehavior(listView.getSkin());
2059         InputMap&lt;ListView&lt;?&gt;&gt; lvInputMap = lvBehavior.getInputMap();
2060         // In ListViewBehavior KeyMappings for vertical orientation are added under 3rd child InputMap
2061         InputMap&lt;ListView&lt;?&gt;&gt; verticalInputMap = lvInputMap.getChildInputMaps().get(2);
2062 
2063         // Verify FocusTraversalInputMap
2064         for(InputMap.Mapping&lt;?&gt; mapping : FocusTraversalInputMap.getFocusTraversalMappings()) {
2065             assertTrue(lvInputMap.getMappings().contains(mapping));
2066         }
2067 
2068         // Verify default InputMap
2069         assertTrue(lvInputMap.getMappings().contains(
2070                 new KeyMapping(new KeyBinding(KeyCode.HOME), null)));
2071         assertTrue(lvInputMap.getMappings().contains(
2072                 new KeyMapping(new KeyBinding(KeyCode.END), null)));
2073         assertTrue(lvInputMap.getMappings().contains(
2074                 new KeyMapping(new KeyBinding(KeyCode.HOME).shift(), null)));
2075         assertTrue(lvInputMap.getMappings().contains(
2076                 new KeyMapping(new KeyBinding(KeyCode.END).shift(), null)));
2077         assertTrue(lvInputMap.getMappings().contains(
2078                 new KeyMapping(new KeyBinding(KeyCode.HOME).shortcut(), null)));
2079         assertTrue(lvInputMap.getMappings().contains(
2080                 new KeyMapping(new KeyBinding(KeyCode.END).shortcut(), null)));
2081         assertTrue(lvInputMap.getMappings().contains(
2082                 new KeyMapping(new KeyBinding(KeyCode.A).shortcut(), null)));
2083 
2084         // Verify vertical child InputMap
2085         assertTrue(verticalInputMap.getMappings().contains(
2086                 new KeyMapping(new KeyBinding(KeyCode.HOME).shortcut().shift(), null)));
2087         assertTrue(verticalInputMap.getMappings().contains(
2088                 new KeyMapping(new KeyBinding(KeyCode.END).shortcut().shift(), null)));
2089 
2090         sl.dispose();
2091     }
2092 
2093     @Test
2094     public void testListViewLeak() {
2095         ObservableList&lt;String&gt; items = FXCollections.observableArrayList();
2096         WeakReference&lt;ListView&lt;String&gt;&gt; listViewRef = new WeakReference&lt;&gt;(new ListView&lt;&gt;(items));
2097         attemptGC(listViewRef, 10);
2098         assertNull(&quot;ListView is not GCed.&quot;, listViewRef.get());
2099     }
2100 
2101     @Test
2102     public void testItemLeak() {
2103         WeakReference&lt;String&gt; itemRef = new WeakReference&lt;&gt;(new String(&quot;Leak Item&quot;));
2104         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(itemRef.get());
2105         ListView&lt;String&gt; listView = new ListView&lt;&gt;(items);
2106         items.clear();
2107         attemptGC(itemRef, 10);
2108         assertNull(&quot;ListView item is not GCed.&quot;, itemRef.get());
2109     }
2110 
2111     private void attemptGC(WeakReference&lt;? extends Object&gt; weakRef, int n) {
2112         for (int i = 0; i &lt; n; i++) {
2113             System.gc();
2114             System.runFinalization();
2115 
2116             if (weakRef.get() == null) {
2117                 break;
2118             }
2119             try {
2120                 Thread.sleep(50);
2121             } catch (InterruptedException e) {
2122                 fail(&quot;InterruptedException occurred during Thread.sleep()&quot;);
2123             }
2124         }
2125     }
2126 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>