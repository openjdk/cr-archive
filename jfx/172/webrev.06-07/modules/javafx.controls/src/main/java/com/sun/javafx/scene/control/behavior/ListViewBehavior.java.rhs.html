<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/behavior/ListViewBehavior.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package com.sun.javafx.scene.control.behavior;
 26 
 27 import com.sun.javafx.PlatformUtil;
 28 import com.sun.javafx.scene.control.skin.Utils;
<a name="1" id="anc1"></a><span class="line-added"> 29 import javafx.beans.InvalidationListener;</span>
<span class="line-added"> 30 import javafx.beans.WeakInvalidationListener;</span>
 31 import javafx.beans.value.ChangeListener;
 32 import javafx.beans.value.ObservableValue;
 33 import javafx.beans.value.WeakChangeListener;
 34 import javafx.collections.ListChangeListener;
 35 import javafx.collections.ObservableList;
 36 import javafx.collections.WeakListChangeListener;
 37 import javafx.event.EventHandler;
 38 import javafx.geometry.Orientation;
 39 import javafx.scene.control.FocusModel;
 40 import javafx.scene.control.ListView;
 41 import javafx.scene.control.MultipleSelectionModel;
 42 import javafx.scene.control.SelectionMode;
 43 import com.sun.javafx.scene.control.inputmap.InputMap;
 44 import com.sun.javafx.scene.control.inputmap.KeyBinding;
 45 import javafx.scene.input.KeyEvent;
 46 import javafx.scene.input.MouseEvent;
 47 import javafx.util.Callback;
 48 
 49 import java.util.ArrayList;
 50 import java.util.List;
 51 
 52 import static com.sun.javafx.scene.control.inputmap.InputMap.*;
 53 import static javafx.scene.input.KeyCode.*;
 54 
 55 public class ListViewBehavior&lt;T&gt; extends BehaviorBase&lt;ListView&lt;T&gt;&gt; {
 56     private final InputMap&lt;ListView&lt;T&gt;&gt; listViewInputMap;
 57 
 58     private final EventHandler&lt;KeyEvent&gt; keyEventListener = e -&gt; {
 59         if (!e.isConsumed()) {
 60             // RT-12751: we want to keep an eye on the user holding down the shift key,
 61             // so that we know when they enter/leave multiple selection mode. This
 62             // changes what happens when certain key combinations are pressed.
 63             isShiftDown = e.getEventType() == KeyEvent.KEY_PRESSED &amp;&amp; e.isShiftDown();
 64             isShortcutDown = e.getEventType() == KeyEvent.KEY_PRESSED &amp;&amp; e.isShortcutDown();
 65         }
 66     };
 67 
 68 
 69 
 70     /***************************************************************************
 71      *                                                                         *
 72      * Constructors                                                            *
 73      *                                                                         *
 74      **************************************************************************/
 75 
 76     public ListViewBehavior(ListView&lt;T&gt; control) {
 77         super(control);
 78 
 79         // create a map for listView-specific mappings
 80         listViewInputMap = createInputMap();
 81         // add focus traversal mappings
 82         addDefaultMapping(listViewInputMap,
 83             new KeyMapping(new KeyBinding(PAGE_UP).shift(), e -&gt; selectAllPageUp()),
 84             new KeyMapping(new KeyBinding(PAGE_DOWN).shift(), e -&gt; selectAllPageDown()),
 85 
 86             new KeyMapping(new KeyBinding(SPACE).shift(), e -&gt; selectAllToFocus(false)),
 87             new KeyMapping(new KeyBinding(SPACE).shortcut().shift(), e -&gt; selectAllToFocus(true)),
 88 
 89             new KeyMapping(PAGE_UP, e -&gt; scrollPageUp()),
 90             new KeyMapping(PAGE_DOWN, e -&gt; scrollPageDown()),
 91 
 92             new KeyMapping(ENTER, e -&gt; activate()),
 93             new KeyMapping(SPACE, e -&gt; activate()),
 94             new KeyMapping(F2, e -&gt; activate()),
 95             new KeyMapping(ESCAPE, e -&gt; cancelEdit()),
 96 
 97             new KeyMapping(new KeyBinding(PAGE_UP).shortcut(), e -&gt; focusPageUp()),
 98             new KeyMapping(new KeyBinding(PAGE_DOWN).shortcut(), e -&gt; focusPageDown()),
 99 
100             new KeyMapping(new KeyBinding(BACK_SLASH).shortcut(), e -&gt; clearSelection()),
101 
102             new MouseMapping(MouseEvent.MOUSE_PRESSED, this::mousePressed)
103         );
104 
105         // create OS-specific child mappings
106         // --- mac OS
107         InputMap&lt;ListView&lt;T&gt;&gt; macInputMap = new InputMap&lt;&gt;(control);
108         macInputMap.setInterceptor(event -&gt; !PlatformUtil.isMac());
109         addDefaultMapping(macInputMap, new KeyMapping(new KeyBinding(SPACE).shortcut().ctrl(), e -&gt; toggleFocusOwnerSelection()));
110         addDefaultChildMap(listViewInputMap, macInputMap);
111 
112         // --- all other platforms
113         InputMap&lt;ListView&lt;T&gt;&gt; otherOsInputMap = new InputMap&lt;&gt;(control);
114         otherOsInputMap.setInterceptor(event -&gt; PlatformUtil.isMac());
115         addDefaultMapping(otherOsInputMap, new KeyMapping(new KeyBinding(SPACE).ctrl(), e -&gt; toggleFocusOwnerSelection()));
116         addDefaultChildMap(listViewInputMap, otherOsInputMap);
117 
118         // create two more child maps, one for vertical listview and one for horizontal listview
119         // --- vertical listview
120         InputMap&lt;ListView&lt;T&gt;&gt; verticalListInputMap = new InputMap&lt;&gt;(control);
121         verticalListInputMap.setInterceptor(event -&gt; control.getOrientation() != Orientation.VERTICAL);
122 
123         addDefaultMapping(verticalListInputMap,
124             new KeyMapping(UP, e -&gt; selectPreviousRow()),
125             new KeyMapping(KP_UP, e -&gt; selectPreviousRow()),
126             new KeyMapping(DOWN, e -&gt; selectNextRow()),
127             new KeyMapping(KP_DOWN, e -&gt; selectNextRow()),
128 
129             new KeyMapping(new KeyBinding(UP).shift(), e -&gt; alsoSelectPreviousRow()),
130             new KeyMapping(new KeyBinding(KP_UP).shift(), e -&gt; alsoSelectPreviousRow()),
131             new KeyMapping(new KeyBinding(DOWN).shift(), e -&gt; alsoSelectNextRow()),
132             new KeyMapping(new KeyBinding(KP_DOWN).shift(), e -&gt; alsoSelectNextRow()),
133 
134             new KeyMapping(new KeyBinding(UP).shortcut(), e -&gt; focusPreviousRow()),
135             new KeyMapping(new KeyBinding(DOWN).shortcut(), e -&gt; focusNextRow()),
136 
137             new KeyMapping(new KeyBinding(UP).shortcut().shift(), e -&gt; discontinuousSelectPreviousRow()),
138             new KeyMapping(new KeyBinding(DOWN).shortcut().shift(), e -&gt; discontinuousSelectNextRow()),
139             new KeyMapping(new KeyBinding(PAGE_UP).shortcut().shift(), e -&gt; discontinuousSelectPageUp()),
140             new KeyMapping(new KeyBinding(PAGE_DOWN).shortcut().shift(), e -&gt; discontinuousSelectPageDown())
141         );
142 
<a name="2" id="anc2"></a><span class="line-modified">143         if (Boolean.FALSE.equals(control.getProperties().containsKey(&quot;excludeKeyMappingsForComboBoxEditor&quot;))) {</span>
<span class="line-added">144             // This is not ComboBox&#39;s ListView</span>
145             addDefaultMapping(listViewInputMap, FocusTraversalInputMap.getFocusTraversalMappings());
146             addDefaultMapping(listViewInputMap,
147                     new KeyMapping(HOME, e -&gt; selectFirstRow()),
148                     new KeyMapping(END, e -&gt; selectLastRow()),
149                     new KeyMapping(new KeyBinding(HOME).shift(), e -&gt; selectAllToFirstRow()),
150                     new KeyMapping(new KeyBinding(END).shift(), e -&gt; selectAllToLastRow()),
151                     new KeyMapping(new KeyBinding(HOME).shortcut(), e -&gt; focusFirstRow()),
152                     new KeyMapping(new KeyBinding(END).shortcut(), e -&gt; focusLastRow()),
153                     new KeyMapping(new KeyBinding(A).shortcut(), e -&gt; selectAll())
154             );
155 
156             addDefaultMapping(verticalListInputMap,
157                     new KeyMapping(new KeyBinding(HOME).shortcut().shift(), e -&gt; discontinuousSelectAllToFirstRow()),
158                     new KeyMapping(new KeyBinding(END).shortcut().shift(), e -&gt; discontinuousSelectAllToLastRow())
159             );
<a name="3" id="anc3"></a><span class="line-added">160         } else {</span>
<span class="line-added">161             // This is ComboBox&#39;s ListView</span>
<span class="line-added">162             if (Boolean.FALSE.equals(control.getProperties().get(&quot;editableComboBoxEditor&quot;))) {</span>
<span class="line-added">163                 // ComboBox is not editable</span>
<span class="line-added">164                 addDefaultMapping(listViewInputMap,</span>
<span class="line-added">165                         new KeyMapping(HOME, e -&gt; selectFirstRow()),</span>
<span class="line-added">166                         new KeyMapping(END, e -&gt; selectLastRow())</span>
<span class="line-added">167                 );</span>
<span class="line-added">168             }</span>
169         }
<a name="4" id="anc4"></a><span class="line-added">170         control.getProperties().addListener(weakPropertiesListener);</span>
171 
172         addDefaultChildMap(listViewInputMap, verticalListInputMap);
173 
174         // --- horizontal listview
175         InputMap&lt;ListView&lt;T&gt;&gt; horizontalListInputMap = new InputMap&lt;&gt;(control);
176         horizontalListInputMap.setInterceptor(event -&gt; control.getOrientation() != Orientation.HORIZONTAL);
177 
178         addDefaultMapping(horizontalListInputMap,
179             new KeyMapping(LEFT, e -&gt; selectPreviousRow()),
180             new KeyMapping(KP_LEFT, e -&gt; selectPreviousRow()),
181             new KeyMapping(RIGHT, e -&gt; selectNextRow()),
182             new KeyMapping(KP_RIGHT, e -&gt; selectNextRow()),
183 
184             new KeyMapping(new KeyBinding(LEFT).shift(), e -&gt; alsoSelectPreviousRow()),
185             new KeyMapping(new KeyBinding(KP_LEFT).shift(), e -&gt; alsoSelectPreviousRow()),
186             new KeyMapping(new KeyBinding(RIGHT).shift(), e -&gt; alsoSelectNextRow()),
187             new KeyMapping(new KeyBinding(KP_RIGHT).shift(), e -&gt; alsoSelectNextRow()),
188 
189             new KeyMapping(new KeyBinding(LEFT).shortcut(), e -&gt; focusPreviousRow()),
190             new KeyMapping(new KeyBinding(RIGHT).shortcut(), e -&gt; focusNextRow()),
191 
192             new KeyMapping(new KeyBinding(LEFT).shortcut().shift(), e -&gt; discontinuousSelectPreviousRow()),
193             new KeyMapping(new KeyBinding(RIGHT).shortcut().shift(), e -&gt; discontinuousSelectNextRow())
194         );
195 
196         addDefaultChildMap(listViewInputMap, horizontalListInputMap);
197 
198         // set up other listeners
199         // We make this an event _filter_ so that we can determine the state
200         // of the shift key before the event handlers get a shot at the event.
201         control.addEventFilter(KeyEvent.ANY, keyEventListener);
202 
203         control.itemsProperty().addListener(weakItemsListener);
204         if (control.getItems() != null) {
205             control.getItems().addListener(weakItemsListListener);
206         }
207 
208         // Fix for RT-16565
209         control.selectionModelProperty().addListener(weakSelectionModelListener);
210         if (control.getSelectionModel() != null) {
211             control.getSelectionModel().getSelectedIndices().addListener(weakSelectedIndicesListener);
212         }
213 
214         // Only add this if we&#39;re on an embedded platform that supports 5-button navigation
215         if (Utils.isTwoLevelFocus()) {
216             tlFocus = new TwoLevelFocusListBehavior(control); // needs to be last.
217         }
218     }
219 
220 
221     /***************************************************************************
222      *                                                                         *
223      * Implementation of BehaviorBase API                                      *
224      *                                                                         *
225      **************************************************************************/
226 
227     @Override public InputMap&lt;ListView&lt;T&gt;&gt; getInputMap() {
228         return listViewInputMap;
229     }
230 
231     @Override public void dispose() {
232         ListView&lt;T&gt; control = getNode();
233 
234         ListCellBehavior.removeAnchor(control);
<a name="5" id="anc5"></a><span class="line-added">235         control.getProperties().removeListener(weakPropertiesListener);</span>
236         control.selectionModelProperty().removeListener(weakSelectionModelListener);
237         if (control.getSelectionModel() != null) {
238             control.getSelectionModel().getSelectedIndices().removeListener(weakSelectedIndicesListener);
239         }
240         control.itemsProperty().removeListener(weakItemsListener);
241         if (control.getItems() != null) {
242             control.getItems().removeListener(weakItemsListListener);
243         }
244 
245         if (tlFocus != null) tlFocus.dispose();
246         control.removeEventFilter(KeyEvent.ANY, keyEventListener);
247         super.dispose();
248     }
249 
250     /**************************************************************************
251      *                         State and Functions                            *
252      *************************************************************************/
253 
254     private boolean isShiftDown = false;
255     private boolean isShortcutDown = false;
256 
257     private Callback&lt;Boolean, Integer&gt; onScrollPageUp;
258     private Callback&lt;Boolean, Integer&gt; onScrollPageDown;
259     private Runnable onFocusPreviousRow;
260     private Runnable onFocusNextRow;
261     private Runnable onSelectPreviousRow;
262     private Runnable onSelectNextRow;
263     private Runnable onMoveToFirstCell;
264     private Runnable onMoveToLastCell;
265 
266     public void setOnScrollPageUp(Callback&lt;Boolean, Integer&gt; c) { onScrollPageUp = c; }
267     public void setOnScrollPageDown(Callback&lt;Boolean, Integer&gt; c) { onScrollPageDown = c; }
268     public void setOnFocusPreviousRow(Runnable r) { onFocusPreviousRow = r; }
269     public void setOnFocusNextRow(Runnable r) { onFocusNextRow = r; }
270     public void setOnSelectPreviousRow(Runnable r) { onSelectPreviousRow = r; }
271     public void setOnSelectNextRow(Runnable r) { onSelectNextRow = r; }
272     public void setOnMoveToFirstCell(Runnable r) { onMoveToFirstCell = r; }
273     public void setOnMoveToLastCell(Runnable r) { onMoveToLastCell = r; }
274 
275     private boolean selectionChanging = false;
276 
277     private final ListChangeListener&lt;Integer&gt; selectedIndicesListener = c -&gt; {
278         int newAnchor = getAnchor();
279 
280         while (c.next()) {
281             if (c.wasReplaced()) {
282                 if (ListCellBehavior.hasDefaultAnchor(getNode())) {
283                     ListCellBehavior.removeAnchor(getNode());
284                     continue;
285                 }
286             }
287 
288             final int shift = c.wasPermutated() ? c.getTo() - c.getFrom() : 0;
289 
290             MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
291 
292             // there are no selected items, so lets clear out the anchor
293             if (! selectionChanging) {
294                 if (sm.isEmpty()) {
295                     newAnchor = -1;
296                 } else if (hasAnchor() &amp;&amp; ! sm.isSelected(getAnchor() + shift)) {
297                     newAnchor = -1;
298                 }
299             }
300 
301             // we care about the situation where the selection changes, and there is no anchor. In this
302             // case, we set a new anchor to be the selected index
303             if (newAnchor == -1) {
304                 int addedSize = c.getAddedSize();
305                 newAnchor = addedSize &gt; 0 ? c.getAddedSubList().get(addedSize - 1) : newAnchor;
306             }
307         }
308 
309         if (newAnchor &gt; -1) {
310             setAnchor(newAnchor);
311         }
312     };
313 
314     private final ListChangeListener&lt;T&gt; itemsListListener = c -&gt; {
315         while (c.next()) {
316             if (!hasAnchor()) continue;
317 
318             int newAnchor = (hasAnchor() ? getAnchor() : 0);
319 
320             if (c.wasAdded() &amp;&amp; c.getFrom() &lt;= newAnchor) {
321                 newAnchor += c.getAddedSize();
322             } else if (c.wasRemoved() &amp;&amp; c.getFrom() &lt;= newAnchor) {
323                 newAnchor -= c.getRemovedSize();
324             }
325 
326             setAnchor(newAnchor &lt; 0 ? 0 : newAnchor);
327         }
328     };
329 
330     private final ChangeListener&lt;ObservableList&lt;T&gt;&gt; itemsListener = new ChangeListener&lt;ObservableList&lt;T&gt;&gt;() {
331         @Override
332         public void changed(
333                 ObservableValue&lt;? extends ObservableList&lt;T&gt;&gt; observable,
334                 ObservableList&lt;T&gt; oldValue, ObservableList&lt;T&gt; newValue) {
335             if (oldValue != null) {
336                 oldValue.removeListener(weakItemsListListener);
337             } if (newValue != null) {
338                 newValue.addListener(weakItemsListListener);
339             }
340         }
341     };
342 
343     private final ChangeListener&lt;MultipleSelectionModel&lt;T&gt;&gt; selectionModelListener = new ChangeListener&lt;MultipleSelectionModel&lt;T&gt;&gt;() {
344         @Override public void changed(
345                 ObservableValue&lt;? extends MultipleSelectionModel&lt;T&gt;&gt; observable,
346                 MultipleSelectionModel&lt;T&gt; oldValue,
347                 MultipleSelectionModel&lt;T&gt; newValue) {
348             if (oldValue != null) {
349                 oldValue.getSelectedIndices().removeListener(weakSelectedIndicesListener);
350             }
351             if (newValue != null) {
352                 newValue.getSelectedIndices().addListener(weakSelectedIndicesListener);
353             }
354         }
355     };
356 
<a name="6" id="anc6"></a><span class="line-added">357     private final InvalidationListener propertiesListener = inv -&gt; {</span>
<span class="line-added">358         Boolean isComboBoxEditable = (Boolean)getNode().getProperties().get(&quot;editableComboBoxEditor&quot;);</span>
<span class="line-added">359         if (isComboBoxEditable != null) {</span>
<span class="line-added">360             // This is ComboBox&#39;s ListView</span>
<span class="line-added">361             if (isComboBoxEditable) {</span>
<span class="line-added">362                 // ComboBox is editable.</span>
<span class="line-added">363                 removeMapping(new KeyBinding(HOME));</span>
<span class="line-added">364                 removeMapping(new KeyBinding(END));</span>
<span class="line-added">365             } else {</span>
<span class="line-added">366                 // ComboBox is not editable</span>
<span class="line-added">367                 addDefaultMapping(getInputMap(),</span>
<span class="line-added">368                         new KeyMapping(HOME, e -&gt; selectFirstRow()),</span>
<span class="line-added">369                         new KeyMapping(END, e -&gt; selectLastRow())</span>
<span class="line-added">370                 );</span>
<span class="line-added">371             }</span>
<span class="line-added">372         }</span>
<span class="line-added">373     };</span>
<span class="line-added">374 </span>
<span class="line-added">375     private final WeakInvalidationListener weakPropertiesListener =</span>
<span class="line-added">376             new WeakInvalidationListener(propertiesListener);</span>
377     private final WeakChangeListener&lt;ObservableList&lt;T&gt;&gt; weakItemsListener =
378             new WeakChangeListener&lt;ObservableList&lt;T&gt;&gt;(itemsListener);
379     private final WeakListChangeListener&lt;Integer&gt; weakSelectedIndicesListener =
380             new WeakListChangeListener&lt;Integer&gt;(selectedIndicesListener);
381     private final WeakListChangeListener&lt;T&gt; weakItemsListListener =
382             new WeakListChangeListener&lt;&gt;(itemsListListener);
383     private final WeakChangeListener&lt;MultipleSelectionModel&lt;T&gt;&gt; weakSelectionModelListener =
384             new WeakChangeListener&lt;MultipleSelectionModel&lt;T&gt;&gt;(selectionModelListener);
385 
386     private TwoLevelFocusListBehavior tlFocus;
387 
388     private void setAnchor(int anchor) {
389         ListCellBehavior.setAnchor(getNode(), anchor &lt; 0 ? null : anchor, false);
390     }
391 
392     private int getAnchor() {
393         return ListCellBehavior.getAnchor(getNode(), getNode().getFocusModel().getFocusedIndex());
394     }
395 
396     private boolean hasAnchor() {
397         return ListCellBehavior.hasNonDefaultAnchor(getNode());
398     }
399 
400     private void mousePressed(MouseEvent e) {
401         if (! e.isShiftDown() &amp;&amp; ! e.isSynthesized()) {
402             int index = getNode().getSelectionModel().getSelectedIndex();
403             setAnchor(index);
404         }
405 
406         if (! getNode().isFocused() &amp;&amp; getNode().isFocusTraversable()) {
407             getNode().requestFocus();
408         }
409     }
410 
411     private int getRowCount() {
412         return getNode().getItems() == null ? 0 : getNode().getItems().size();
413     }
414 
415     private void clearSelection() {
416         getNode().getSelectionModel().clearSelection();
417     }
418 
419     private void scrollPageUp() {
420         int newSelectedIndex = -1;
421         if (onScrollPageUp != null) {
422             newSelectedIndex = onScrollPageUp.call(false);
423         }
424         if (newSelectedIndex == -1) return;
425 
426         MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
427         if (sm == null) return;
428         sm.clearAndSelect(newSelectedIndex);
429     }
430 
431     private void scrollPageDown() {
432         int newSelectedIndex = -1;
433         if (onScrollPageDown != null) {
434             newSelectedIndex = onScrollPageDown.call(false);
435         }
436         if (newSelectedIndex == -1) return;
437 
438         MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
439         if (sm == null) return;
440         sm.clearAndSelect(newSelectedIndex);
441     }
442 
443     private void focusFirstRow() {
444         FocusModel&lt;T&gt; fm = getNode().getFocusModel();
445         if (fm == null) return;
446         fm.focus(0);
447 
448         if (onMoveToFirstCell != null) onMoveToFirstCell.run();
449     }
450 
451     private void focusLastRow() {
452         FocusModel&lt;T&gt; fm = getNode().getFocusModel();
453         if (fm == null) return;
454         fm.focus(getRowCount() - 1);
455 
456         if (onMoveToLastCell != null) onMoveToLastCell.run();
457     }
458 
459     private void focusPreviousRow() {
460         FocusModel&lt;T&gt; fm = getNode().getFocusModel();
461         if (fm == null) return;
462 
463         MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
464         if (sm == null) return;
465 
466         fm.focusPrevious();
467 
468         if (! isShortcutDown || getAnchor() == -1) {
469             setAnchor(fm.getFocusedIndex());
470         }
471 
472         if (onFocusPreviousRow != null) onFocusPreviousRow.run();
473     }
474 
475     private void focusNextRow() {
476         FocusModel&lt;T&gt; fm = getNode().getFocusModel();
477         if (fm == null) return;
478 
479         MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
480         if (sm == null) return;
481 
482         fm.focusNext();
483 
484         if (! isShortcutDown || getAnchor() == -1) {
485             setAnchor(fm.getFocusedIndex());
486         }
487 
488         if (onFocusNextRow != null) onFocusNextRow.run();
489     }
490 
491     private void focusPageUp() {
492         int newFocusIndex = onScrollPageUp.call(true);
493 
494         FocusModel&lt;T&gt; fm = getNode().getFocusModel();
495         if (fm == null) return;
496         fm.focus(newFocusIndex);
497     }
498 
499     private void focusPageDown() {
500         int newFocusIndex = onScrollPageDown.call(true);
501 
502         FocusModel&lt;T&gt; fm = getNode().getFocusModel();
503         if (fm == null) return;
504         fm.focus(newFocusIndex);
505     }
506 
507     private void alsoSelectPreviousRow() {
508         FocusModel&lt;T&gt; fm = getNode().getFocusModel();
509         if (fm == null) return;
510 
511         MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
512         if (sm == null) return;
513 
514         if (isShiftDown &amp;&amp; getAnchor() != -1) {
515             int newRow = fm.getFocusedIndex() - 1;
516             if (newRow &lt; 0) return;
517 
518             int anchor = getAnchor();
519 
520             if (! hasAnchor()) {
521                 setAnchor(fm.getFocusedIndex());
522             }
523 
524             if (sm.getSelectedIndices().size() &gt; 1) {
525                 clearSelectionOutsideRange(anchor, newRow);
526             }
527 
528             if (anchor &gt; newRow) {
529                 sm.selectRange(anchor, newRow - 1);
530             } else {
531                 sm.selectRange(anchor, newRow + 1);
532             }
533         } else {
534             sm.selectPrevious();
535         }
536 
537         onSelectPreviousRow.run();
538     }
539 
540     private void alsoSelectNextRow() {
541         FocusModel&lt;T&gt; fm = getNode().getFocusModel();
542         if (fm == null) return;
543 
544         MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
545         if (sm == null) return;
546 
547         if (isShiftDown &amp;&amp; getAnchor() != -1) {
548             int newRow = fm.getFocusedIndex() + 1;
549             int anchor = getAnchor();
550 
551             if (! hasAnchor()) {
552                 setAnchor(fm.getFocusedIndex());
553             }
554 
555             if (sm.getSelectedIndices().size() &gt; 1) {
556                 clearSelectionOutsideRange(anchor, newRow);
557             }
558 
559             if (anchor &gt; newRow) {
560                 sm.selectRange(anchor, newRow - 1);
561             } else {
562                 sm.selectRange(anchor, newRow + 1);
563             }
564         } else {
565             sm.selectNext();
566         }
567 
568         onSelectNextRow.run();
569     }
570 
571     private void clearSelectionOutsideRange(int start, int end) {
572         MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
573         if (sm == null) return;
574 
575         int min = Math.min(start, end);
576         int max = Math.max(start, end);
577 
578         List&lt;Integer&gt; indices = new ArrayList&lt;&gt;(sm.getSelectedIndices());
579 
580         selectionChanging = true;
581         for (int i = 0; i &lt; indices.size(); i++) {
582             int index = indices.get(i);
583             if (index &lt; min || index &gt; max) {
584                 sm.clearSelection(index);
585             }
586         }
587         selectionChanging = false;
588     }
589 
590     private void selectPreviousRow() {
591         FocusModel&lt;T&gt; fm = getNode().getFocusModel();
592         if (fm == null) return;
593 
594         int focusIndex = fm.getFocusedIndex();
595         if (focusIndex &lt;= 0) {
596             return;
597         }
598 
599         setAnchor(focusIndex - 1);
600         getNode().getSelectionModel().clearAndSelect(focusIndex - 1);
601         onSelectPreviousRow.run();
602     }
603 
604     private void selectNextRow() {
605         ListView&lt;T&gt; listView = getNode();
606         FocusModel&lt;T&gt; fm = listView.getFocusModel();
607         if (fm == null) return;
608 
609         int focusIndex = fm.getFocusedIndex();
610         if (focusIndex == getRowCount() - 1) {
611             return;
612         }
613 
614         MultipleSelectionModel&lt;T&gt; sm = listView.getSelectionModel();
615         if (sm == null) return;
616 
617         setAnchor(focusIndex + 1);
618         sm.clearAndSelect(focusIndex + 1);
619         if (onSelectNextRow != null) onSelectNextRow.run();
620     }
621 
622     private void selectFirstRow() {
623         if (getRowCount() &gt; 0) {
624             getNode().getSelectionModel().clearAndSelect(0);
625             if (onMoveToFirstCell != null) onMoveToFirstCell.run();
626         }
627     }
628 
629     private void selectLastRow() {
630         getNode().getSelectionModel().clearAndSelect(getRowCount() - 1);
631         if (onMoveToLastCell != null) onMoveToLastCell.run();
632     }
633 
634     private void selectAllPageUp() {
635         FocusModel&lt;T&gt; fm = getNode().getFocusModel();
636         if (fm == null) return;
637 
638         int leadIndex = fm.getFocusedIndex();
639         if (isShiftDown) {
640             leadIndex = getAnchor() == -1 ? leadIndex : getAnchor();
641             setAnchor(leadIndex);
642         }
643 
644         int leadSelectedIndex = onScrollPageUp.call(false);
645 
646         // fix for RT-34407
647         int adjust = leadIndex &lt; leadSelectedIndex ? 1 : -1;
648 
649         MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
650         if (sm == null) return;
651 
652         selectionChanging = true;
653         if (sm.getSelectionMode() == SelectionMode.SINGLE) {
654             sm.select(leadSelectedIndex);
655         } else {
656             sm.clearSelection();
657             sm.selectRange(leadIndex, leadSelectedIndex + adjust);
658         }
659         selectionChanging = false;
660     }
661 
662     private void selectAllPageDown() {
663         FocusModel&lt;T&gt; fm = getNode().getFocusModel();
664         if (fm == null) return;
665 
666         int leadIndex = fm.getFocusedIndex();
667         if (isShiftDown) {
668             leadIndex = getAnchor() == -1 ? leadIndex : getAnchor();
669             setAnchor(leadIndex);
670         }
671 
672         int leadSelectedIndex = onScrollPageDown.call(false);
673 
674         // fix for RT-34407
675         int adjust = leadIndex &lt; leadSelectedIndex ? 1 : -1;
676 
677         MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
678         if (sm == null) return;
679 
680         selectionChanging = true;
681         if (sm.getSelectionMode() == SelectionMode.SINGLE) {
682             sm.select(leadSelectedIndex);
683         } else {
684             sm.clearSelection();
685             sm.selectRange(leadIndex, leadSelectedIndex + adjust);
686         }
687         selectionChanging = false;
688     }
689 
690     private void selectAllToFirstRow() {
691         MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
692         if (sm == null) return;
693 
694         FocusModel&lt;T&gt; fm = getNode().getFocusModel();
695         if (fm == null) return;
696 
697         int leadIndex = fm.getFocusedIndex();
698 
699         if (isShiftDown) {
700             leadIndex = hasAnchor() ? getAnchor() : leadIndex;
701         }
702 
703         sm.clearSelection();
704         sm.selectRange(leadIndex, -1);
705 
706         // RT-18413: Focus must go to first row
707         fm.focus(0);
708 
709         if (isShiftDown) {
710             setAnchor(leadIndex);
711         }
712 
713         if (onMoveToFirstCell != null) onMoveToFirstCell.run();
714     }
715 
716     private void selectAllToLastRow() {
717         MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
718         if (sm == null) return;
719 
720         FocusModel&lt;T&gt; fm = getNode().getFocusModel();
721         if (fm == null) return;
722 
723         int leadIndex = fm.getFocusedIndex();
724 
725         if (isShiftDown) {
726             leadIndex = hasAnchor() ? getAnchor() : leadIndex;
727         }
728 
729         sm.clearSelection();
730         sm.selectRange(leadIndex, getRowCount());
731 
732         if (isShiftDown) {
733             setAnchor(leadIndex);
734         }
735 
736         if (onMoveToLastCell != null) onMoveToLastCell.run();
737     }
738 
739     private void selectAll() {
740         MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
741         if (sm == null) return;
742         sm.selectAll();
743     }
744 
745     private void selectAllToFocus(boolean setAnchorToFocusIndex) {
746         // Fix for RT-31241
747         final ListView&lt;T&gt; listView = getNode();
748         if (listView.getEditingIndex() &gt;= 0) return;
749 
750         MultipleSelectionModel&lt;T&gt; sm = listView.getSelectionModel();
751         if (sm == null) return;
752 
753         FocusModel&lt;T&gt; fm = listView.getFocusModel();
754         if (fm == null) return;
755 
756         int focusIndex = fm.getFocusedIndex();
757         int anchor = getAnchor();
758 
759         sm.clearSelection();
760         int startPos = anchor;
761         int endPos = anchor &gt; focusIndex ? focusIndex - 1 : focusIndex + 1;
762         sm.selectRange(startPos, endPos);
763         setAnchor(setAnchorToFocusIndex ? focusIndex : anchor);
764     }
765 
766     private void cancelEdit() {
767         getNode().edit(-1);
768     }
769 
770     private void activate() {
771         int focusedIndex = getNode().getFocusModel().getFocusedIndex();
772         getNode().getSelectionModel().select(focusedIndex);
773         setAnchor(focusedIndex);
774 
775         // edit this row also
776         if (focusedIndex &gt;= 0) {
777             getNode().edit(focusedIndex);
778         }
779     }
780 
781     private void toggleFocusOwnerSelection() {
782         MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
783         if (sm == null) return;
784 
785         FocusModel&lt;T&gt; fm = getNode().getFocusModel();
786         if (fm == null) return;
787 
788         int focusedIndex = fm.getFocusedIndex();
789 
790         if (sm.isSelected(focusedIndex)) {
791             sm.clearSelection(focusedIndex);
792             fm.focus(focusedIndex);
793         } else {
794             sm.select(focusedIndex);
795         }
796 
797         setAnchor(focusedIndex);
798     }
799 
800     /**************************************************************************
801      * Discontinuous Selection                                                *
802      *************************************************************************/
803 
804     private void discontinuousSelectPreviousRow() {
805         MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
806         if (sm == null) return;
807 
808         if (sm.getSelectionMode() != SelectionMode.MULTIPLE) {
809             selectPreviousRow();
810             return;
811         }
812 
813         FocusModel&lt;T&gt; fm = getNode().getFocusModel();
814         if (fm == null) return;
815 
816         int focusIndex = fm.getFocusedIndex();
817         final int newFocusIndex = focusIndex - 1;
818         if (newFocusIndex &lt; 0) return;
819 
820         int startIndex = focusIndex;
821         if (isShiftDown) {
822             startIndex = getAnchor() == -1 ? focusIndex : getAnchor();
823         }
824 
825         sm.selectRange(newFocusIndex, startIndex + 1);
826         fm.focus(newFocusIndex);
827 
828         if (onFocusPreviousRow != null) onFocusPreviousRow.run();
829     }
830 
831     private void discontinuousSelectNextRow() {
832         MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
833         if (sm == null) return;
834 
835         if (sm.getSelectionMode() != SelectionMode.MULTIPLE) {
836             selectNextRow();
837             return;
838         }
839 
840         FocusModel&lt;T&gt; fm = getNode().getFocusModel();
841         if (fm == null) return;
842 
843         int focusIndex = fm.getFocusedIndex();
844         final int newFocusIndex = focusIndex + 1;
845         if (newFocusIndex &gt;= getRowCount()) return;
846 
847         int startIndex = focusIndex;
848         if (isShiftDown) {
849             startIndex = getAnchor() == -1 ? focusIndex : getAnchor();
850         }
851 
852         sm.selectRange(startIndex, newFocusIndex + 1);
853         fm.focus(newFocusIndex);
854 
855         if (onFocusNextRow != null) onFocusNextRow.run();
856     }
857 
858     private void discontinuousSelectPageUp() {
859         MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
860         if (sm == null) return;
861 
862         FocusModel&lt;T&gt; fm = getNode().getFocusModel();
863         if (fm == null) return;
864 
865         int anchor = getAnchor();
866         int leadSelectedIndex = onScrollPageUp.call(false);
867         sm.selectRange(anchor, leadSelectedIndex - 1);
868     }
869 
870     private void discontinuousSelectPageDown() {
871         MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
872         if (sm == null) return;
873 
874         FocusModel&lt;T&gt; fm = getNode().getFocusModel();
875         if (fm == null) return;
876 
877         int anchor = getAnchor();
878         int leadSelectedIndex = onScrollPageDown.call(false);
879         sm.selectRange(anchor, leadSelectedIndex + 1);
880     }
881 
882     private void discontinuousSelectAllToFirstRow() {
883         MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
884         if (sm == null) return;
885 
886         FocusModel&lt;T&gt; fm = getNode().getFocusModel();
887         if (fm == null) return;
888 
889         int index = fm.getFocusedIndex();
890         sm.selectRange(0, index);
891         fm.focus(0);
892 
893         if (onMoveToFirstCell != null) onMoveToFirstCell.run();
894     }
895 
896     private void discontinuousSelectAllToLastRow() {
897         MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
898         if (sm == null) return;
899 
900         FocusModel&lt;T&gt; fm = getNode().getFocusModel();
901         if (fm == null) return;
902 
903         int index = fm.getFocusedIndex() + 1;
904         sm.selectRange(index, getRowCount());
905 
906         if (onMoveToLastCell != null) onMoveToLastCell.run();
907     }
908 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>