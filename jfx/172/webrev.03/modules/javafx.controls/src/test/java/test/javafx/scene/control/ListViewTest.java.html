<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.controls/src/test/java/test/javafx/scene/control/ListViewTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package test.javafx.scene.control;
  27 
  28 import com.sun.javafx.scene.control.VirtualScrollBar;
  29 import com.sun.javafx.scene.control.behavior.ListCellBehavior;
  30 import com.sun.javafx.tk.Toolkit;
  31 import java.lang.ref.WeakReference;
  32 import java.util.ArrayList;
  33 import java.util.Arrays;
  34 import java.util.Collections;
  35 import java.util.List;
  36 import java.util.ListIterator;
  37 import java.util.NoSuchElementException;
  38 import javafx.application.Platform;
  39 import javafx.beans.binding.Bindings;
  40 import javafx.beans.property.ObjectProperty;
  41 import javafx.beans.property.ReadOnlyBooleanWrapper;
  42 import javafx.beans.property.SimpleObjectProperty;
  43 import javafx.collections.FXCollections;
  44 import javafx.collections.ListChangeListener;
  45 import javafx.collections.ObservableList;
  46 import javafx.collections.transformation.SortedList;
  47 import javafx.scene.control.Button;
  48 import javafx.scene.control.FocusModel;
  49 import javafx.scene.control.IndexedCell;
  50 import javafx.scene.control.ListCell;
  51 import javafx.scene.control.ListCellShim;
  52 import javafx.scene.control.ListView;
  53 import javafx.scene.control.ListViewShim;
  54 import javafx.scene.control.MultipleSelectionModel;
  55 import javafx.scene.control.SelectionMode;
  56 import javafx.scene.control.SelectionModel;
  57 import javafx.scene.control.TextField;
  58 import javafx.scene.control.cell.CheckBoxListCell;
  59 import javafx.scene.control.cell.ComboBoxListCell;
  60 import javafx.scene.control.cell.TextFieldListCell;
  61 import javafx.scene.image.ImageView;
  62 import javafx.scene.input.KeyCode;
  63 import javafx.scene.layout.VBox;
  64 import javafx.scene.paint.Color;
  65 import javafx.scene.shape.Rectangle;
  66 import javafx.util.Callback;
  67 import static org.junit.Assert.assertArrayEquals;
  68 import static org.junit.Assert.assertEquals;
  69 import static org.junit.Assert.assertFalse;
  70 import static org.junit.Assert.assertNotNull;
  71 import static org.junit.Assert.assertNull;
  72 import static org.junit.Assert.assertSame;
  73 import static org.junit.Assert.assertTrue;
  74 import static org.junit.Assert.fail;
  75 import org.junit.Before;
  76 import org.junit.Test;
  77 import static test.com.sun.javafx.scene.control.infrastructure.ControlTestUtils.assertStyleClassContains;
  78 import test.com.sun.javafx.scene.control.infrastructure.KeyEventFirer;
  79 import test.com.sun.javafx.scene.control.infrastructure.KeyModifier;
  80 import test.com.sun.javafx.scene.control.infrastructure.StageLoader;
  81 import test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils;
  82 import test.com.sun.javafx.scene.control.test.Person;
  83 import test.com.sun.javafx.scene.control.test.RT_22463_Person;
  84 
  85 public class ListViewTest {
  86     private ListView&lt;String&gt; listView;
  87     private MultipleSelectionModel&lt;String&gt; sm;
  88     private FocusModel&lt;String&gt; fm;
  89 
  90     @Before public void setup() {
  91         listView = new ListView&lt;&gt;();
  92         sm = listView.getSelectionModel();
  93         fm = listView.getFocusModel();
  94     }
  95 
  96 
  97     /*********************************************************************
  98      * Tests for the constructors                                        *
  99      ********************************************************************/
 100 
 101     @Test public void noArgConstructorSetsTheStyleClass() {
 102         assertStyleClassContains(listView, &quot;list-view&quot;);
 103     }
 104 
 105     @Test public void noArgConstructorSetsNonNullSelectionModel() {
 106         assertNotNull(sm);
 107     }
 108 
 109     @Test public void noArgConstructorSetsNonNullItems() {
 110         assertNotNull(listView.getItems());
 111     }
 112 
 113     @Test public void noArgConstructor_selectedItemIsNull() {
 114         assertNull(sm.getSelectedItem());
 115     }
 116 
 117     @Test public void noArgConstructor_selectedIndexIsNegativeOne() {
 118         assertEquals(-1, sm.getSelectedIndex());
 119     }
 120 
 121     @Test public void singleArgConstructorSetsTheStyleClass() {
 122         final ListView&lt;String&gt; b2 = new ListView&lt;&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 123         assertStyleClassContains(b2, &quot;list-view&quot;);
 124     }
 125 
 126     @Test public void singleArgConstructorSetsNonNullSelectionModel() {
 127         final ListView&lt;String&gt; b2 = new ListView&lt;&gt;(FXCollections.&lt;String&gt;observableArrayList(&quot;Hi&quot;));
 128         assertNotNull(b2.getSelectionModel());
 129     }
 130 
 131     @Test public void singleArgConstructorAllowsNullItems() {
 132         final ListView&lt;String&gt; b2 = new ListView&lt;String&gt;(null);
 133         assertNull(b2.getItems());
 134     }
 135 
 136     @Test public void singleArgConstructorTakesItems() {
 137         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;Hi&quot;);
 138         final ListView&lt;String&gt; b2 = new ListView&lt;&gt;(items);
 139         assertSame(items, b2.getItems());
 140     }
 141 
 142     @Test public void singleArgConstructor_selectedItemIsNull() {
 143         final ListView&lt;String&gt; b2 = new ListView&lt;&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 144         assertNull(b2.getSelectionModel().getSelectedItem());
 145     }
 146 
 147     @Test public void singleArgConstructor_selectedIndexIsNegativeOne() {
 148         final ListView&lt;String&gt; b2 = new ListView&lt;&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 149         assertEquals(-1, b2.getSelectionModel().getSelectedIndex());
 150     }
 151 
 152     /*********************************************************************
 153      * Tests for selection model                                         *
 154      ********************************************************************/
 155 
 156     @Test public void selectionModelCanBeNull() {
 157         listView.setSelectionModel(null);
 158         assertNull(listView.getSelectionModel());
 159     }
 160 
 161     @Test public void selectionModelCanBeBound() {
 162         MultipleSelectionModel&lt;String&gt; sm = ListViewShim.&lt;String&gt;getListViewBitSetSelectionModel(listView);
 163         ObjectProperty&lt;MultipleSelectionModel&lt;String&gt;&gt; other = new SimpleObjectProperty&lt;MultipleSelectionModel&lt;String&gt;&gt;(sm);
 164         listView.selectionModelProperty().bind(other);
 165         assertSame(sm, sm);
 166     }
 167 
 168     @Test public void selectionModelCanBeChanged() {
 169         MultipleSelectionModel&lt;String&gt; sm = ListViewShim.&lt;String&gt;getListViewBitSetSelectionModel(listView);
 170         listView.setSelectionModel(sm);
 171         assertSame(sm, sm);
 172     }
 173 
 174     @Test public void test_SwitchingSelectionModel() {
 175         ListView&lt;String&gt; listView = new ListView&lt;&gt;();
 176         listView.getItems().addAll(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
 177 
 178         MultipleSelectionModel&lt;String&gt; sm;
 179         StageLoader sl = new StageLoader(listView);
 180         KeyEventFirer keyboard = new KeyEventFirer(listView);
 181 
 182         MultipleSelectionModel&lt;String&gt; smMultiple = ListViewShim.&lt;String&gt;getListViewBitSetSelectionModel(listView);
 183         smMultiple.setSelectionMode(SelectionMode.MULTIPLE);
 184         MultipleSelectionModel&lt;String&gt; smSingle = ListViewShim.&lt;String&gt;getListViewBitSetSelectionModel(listView);
 185         smSingle.setSelectionMode(SelectionMode.SINGLE);
 186 
 187         listView.setSelectionModel(smMultiple);
 188         sm = listView.getSelectionModel();
 189 
 190         assertEquals(0, sm.getSelectedItems().size());
 191         sm.clearAndSelect(0);
 192         assertEquals(1, sm.getSelectedItems().size());
 193         keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
 194         assertEquals(4, sm.getSelectedItems().size());
 195 
 196         listView.setSelectionModel(smSingle);
 197         sm = listView.getSelectionModel();
 198 
 199         assertEquals(0, sm.getSelectedItems().size());
 200         sm.clearAndSelect(0);
 201         assertEquals(1, sm.getSelectedItems().size());
 202         keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
 203         assertEquals(1, sm.getSelectedItems().size());
 204 
 205         sl.dispose();
 206     }
 207 
 208     @Test public void canSetSelectedItemToAnItemEvenWhenThereAreNoItems() {
 209         final String randomString = new String(&quot;I AM A CRAZY RANDOM STRING&quot;);
 210         sm.select(randomString);
 211         assertEquals(-1, sm.getSelectedIndex());
 212         assertSame(randomString, sm.getSelectedItem());
 213     }
 214 
 215     @Test public void canSetSelectedItemToAnItemNotInTheDataModel() {
 216         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 217         final String randomString = new String(&quot;I AM A CRAZY RANDOM STRING&quot;);
 218         sm.select(randomString);
 219         assertEquals(-1, sm.getSelectedIndex());
 220         assertSame(randomString, sm.getSelectedItem());
 221     }
 222 
 223     @Test public void settingTheSelectedItemToAnItemInItemsResultsInTheCorrectSelectedIndex() {
 224         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 225         sm.select(&quot;Orange&quot;);
 226         assertEquals(1, sm.getSelectedIndex());
 227         assertSame(&quot;Orange&quot;, sm.getSelectedItem());
 228     }
 229 
 230     @Test public void settingTheSelectedItemToANonexistantItemAndThenSettingItemsWhichContainsItResultsInCorrectSelectedIndex() {
 231         sm.select(&quot;Orange&quot;);
 232         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 233         assertEquals(1, sm.getSelectedIndex());
 234         assertSame(&quot;Orange&quot;, sm.getSelectedItem());
 235     }
 236 
 237     @Test public void ensureSelectionClearsWhenAllItemsAreRemoved_selectIndex0() {
 238         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 239         sm.select(0);
 240         listView.getItems().clear();
 241         assertEquals(-1, sm.getSelectedIndex());
 242         assertEquals(null, sm.getSelectedItem());
 243     }
 244 
 245     @Test public void ensureSelectionClearsWhenAllItemsAreRemoved_selectIndex2() {
 246         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 247         sm.select(2);
 248         listView.getItems().clear();
 249         assertEquals(-1, sm.getSelectedIndex());
 250         assertEquals(null, sm.getSelectedItem());
 251     }
 252 
 253     @Test public void ensureSelectedItemRemainsAccurateWhenItemsAreCleared() {
 254         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 255         sm.select(2);
 256         listView.getItems().clear();
 257         assertNull(sm.getSelectedItem());
 258         assertEquals(-1, sm.getSelectedIndex());
 259 
 260         listView.getItems().addAll(&quot;Kiwifruit&quot;, &quot;Mandarin&quot;, &quot;Pineapple&quot;);
 261         sm.select(2);
 262         assertEquals(&quot;Pineapple&quot;, sm.getSelectedItem());
 263     }
 264 
 265     @Test public void ensureSelectionShiftsDownWhenOneNewItemIsAdded() {
 266         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 267         sm.select(1);
 268         assertEquals(1, sm.getSelectedIndex());
 269         assertEquals(&quot;Orange&quot;, sm.getSelectedItem());
 270 
 271         listView.getItems().add(0, &quot;Kiwifruit&quot;);
 272         assertEquals(2, sm.getSelectedIndex());
 273         assertEquals(&quot;Orange&quot;, sm.getSelectedItem());
 274     }
 275 
 276     @Test public void ensureSelectionShiftsDownWhenMultipleNewItemAreAdded() {
 277         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 278         sm.select(1);
 279         assertEquals(1, sm.getSelectedIndex());
 280         assertEquals(&quot;Orange&quot;, sm.getSelectedItem());
 281 
 282         listView.getItems().addAll(0, Arrays.asList(&quot;Kiwifruit&quot;, &quot;Pineapple&quot;, &quot;Mandarin&quot;));
 283         assertEquals(&quot;Orange&quot;, sm.getSelectedItem());
 284         assertEquals(4, sm.getSelectedIndex());
 285     }
 286 
 287     @Test public void ensureSelectionShiftsUpWhenOneItemIsRemoved() {
 288         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 289         sm.select(1);
 290         assertEquals(1, sm.getSelectedIndex());
 291         assertEquals(&quot;Orange&quot;, sm.getSelectedItem());
 292 
 293         listView.getItems().remove(&quot;Apple&quot;);
 294         assertEquals(0, sm.getSelectedIndex());
 295         assertEquals(&quot;Orange&quot;, sm.getSelectedItem());
 296     }
 297 
 298     @Test public void ensureSelectionShiftsUpWheMultipleItemsAreRemoved() {
 299         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 300         sm.select(2);
 301         assertEquals(2, sm.getSelectedIndex());
 302         assertEquals(&quot;Banana&quot;, sm.getSelectedItem());
 303 
 304         listView.getItems().removeAll(Arrays.asList(&quot;Apple&quot;, &quot;Orange&quot;));
 305         assertEquals(0, sm.getSelectedIndex());
 306         assertEquals(&quot;Banana&quot;, sm.getSelectedItem());
 307     }
 308 
 309     @Test public void ensureSelectionIsCorrectWhenItemsChange() {
 310         listView.setItems(FXCollections.observableArrayList(&quot;Item 1&quot;));
 311         sm.select(0);
 312         assertEquals(&quot;Item 1&quot;, sm.getSelectedItem());
 313 
 314         listView.setItems(FXCollections.observableArrayList(&quot;Item 2&quot;));
 315         assertEquals(-1, sm.getSelectedIndex());
 316         assertNull(sm.getSelectedItem());
 317         assertEquals(0, fm.getFocusedIndex());
 318         assertEquals(&quot;Item 2&quot;, fm.getFocusedItem());
 319     }
 320 
 321     @Test public void test_rt15793() {
 322         // ListView selectedIndex is 0 although the items list is empty
 323         final ListView lv = new ListView();
 324         final ObservableList list = FXCollections.observableArrayList();
 325         lv.setItems(list);
 326         list.add(&quot;toto&quot;);
 327         lv.getSelectionModel().select(0);
 328         assertEquals(0, lv.getSelectionModel().getSelectedIndex());
 329         list.remove(0);
 330         assertEquals(-1, lv.getSelectionModel().getSelectedIndex());
 331     }
 332 
 333     @Test public void test_rt17522_focusShouldMoveWhenItemAddedAtFocusIndex() {
 334         final ListView lv = new ListView();
 335         FocusModel fm = lv.getFocusModel();
 336         lv.getItems().add(&quot;row1&quot;);
 337         fm.focus(0);
 338         assertTrue(fm.isFocused(0));
 339 
 340         lv.getItems().add(0, &quot;row0&quot;);
 341         assertTrue(fm.isFocused(1));
 342     }
 343 
 344     @Test public void test_rt17522_focusShouldMoveWhenItemAddedBeforeFocusIndex() {
 345         final ListView lv = new ListView();
 346         FocusModel fm = lv.getFocusModel();
 347         lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 348         fm.focus(1);
 349         assertTrue(fm.isFocused(1));
 350         assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 351 
 352         lv.getItems().add(1, &quot;row0&quot;);
 353         assertTrue(fm.isFocused(2));
 354         assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 355         assertFalse(fm.isFocused(1));
 356     }
 357 
 358     @Test public void test_rt17522_focusShouldNotMoveWhenItemAddedAfterFocusIndex() {
 359         final ListView lv = new ListView();
 360         FocusModel fm = lv.getFocusModel();
 361         lv.getItems().addAll(&quot;row1&quot;);
 362         fm.focus(0);
 363         assertTrue(fm.isFocused(0));
 364         assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 365 
 366         lv.getItems().add(1, &quot;row2&quot;);
 367         assertTrue(fm.isFocused(0));
 368         assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 369         assertFalse(fm.isFocused(1));
 370     }
 371 
 372     @Test public void test_rt17522_focusShouldBeResetWhenFocusedItemIsRemoved() {
 373         final ListView lv = new ListView();
 374         FocusModel fm = lv.getFocusModel();
 375         lv.getItems().add(&quot;row1&quot;);
 376         fm.focus(0);
 377         assertTrue(fm.isFocused(0));
 378 
 379         lv.getItems().remove(&quot;row1&quot;);
 380         assertTrue(fm.getFocusedIndex() == -1);
 381         assertNull(fm.getFocusedItem());
 382     }
 383 
 384     @Test public void test_rt17522_focusShouldMoveWhenItemRemovedBeforeFocusIndex() {
 385         final ListView lv = new ListView();
 386         FocusModel fm = lv.getFocusModel();
 387         lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 388         fm.focus(1);
 389         assertTrue(fm.isFocused(1));
 390         assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 391 
 392         lv.getItems().remove(&quot;row1&quot;);
 393         assertTrue(fm.isFocused(0));
 394         assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 395     }
 396 
 397     @Test public void test_rt17522_focusShouldNotMoveWhenItemRemovedAfterFocusIndex() {
 398         final ListView lv = new ListView();
 399         FocusModel fm = lv.getFocusModel();
 400         lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 401         fm.focus(0);
 402         assertTrue(fm.isFocused(0));
 403         assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 404 
 405         lv.getItems().remove(&quot;row2&quot;);
 406         assertTrue(fm.isFocused(0));
 407         assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 408     }
 409 
 410     @Test public void test_rt18385() {
 411         listView.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;);
 412         sm.select(1);
 413         listView.getItems().add(&quot;Another Row&quot;);
 414         assertEquals(1, sm.getSelectedIndices().size());
 415         assertEquals(1, sm.getSelectedItems().size());
 416     }
 417 
 418     @Test public void test_rt18339_onlyEditWhenListViewIsEditable_editableIsFalse() {
 419         listView.setEditable(false);
 420         listView.edit(1);
 421         assertEquals(-1, listView.getEditingIndex());
 422     }
 423 
 424     @Test public void test_rt18339_onlyEditWhenListViewIsEditable_editableIsTrue() {
 425         listView.setEditable(true);
 426         listView.edit(1);
 427         assertEquals(1, listView.getEditingIndex());
 428     }
 429 
 430     @Test public void test_rt14451() {
 431         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 432         sm.setSelectionMode(SelectionMode.MULTIPLE);
 433         sm.selectRange(0, 2); // select from 0 (inclusive) to 2 (exclusive)
 434         assertEquals(2, sm.getSelectedIndices().size());
 435     }
 436 
 437     private int rt_18969_hitCount = 0;
 438     @Test public void test_rt18969() {
 439         rt_18969_hitCount = 0;
 440         ObservableList&lt;String&gt; emptyModel = FXCollections.observableArrayList();
 441         listView.setItems(emptyModel);
 442         assertTrue(listView.getItems().isEmpty());
 443 
 444         sm.selectedItemProperty().addListener((observable, oldValue, newValue) -&gt; {
 445             rt_18969_hitCount++;
 446         });
 447 
 448         ObservableList&lt;String&gt; mod = FXCollections.observableArrayList();
 449         mod.add(System.currentTimeMillis()+&quot;&quot;);
 450         listView.getItems().setAll(mod);
 451 
 452         sm.select(0);
 453         assertTrue(sm.isSelected(0));
 454         assertEquals(1, rt_18969_hitCount);
 455 
 456         // sleep for 100ms so that the currentTimeMillis is guaranteed to be
 457         // a different value than the first one
 458         try {
 459             Thread.sleep(100);
 460         } catch (InterruptedException ex) {
 461             ex.printStackTrace();
 462         }
 463 
 464         // the list is totally changing (it is being cleared), so we should
 465         // be nulling out the selection model state
 466         mod = FXCollections.observableArrayList();
 467         mod.add(System.currentTimeMillis()+&quot;&quot;);
 468         listView.getItems().setAll(mod);
 469 
 470         // it should be two, as there is no null event in between (although there
 471         // used to be, so the test used to be for three hits)
 472         assertEquals(2, rt_18969_hitCount);
 473     }
 474 
 475     @Test public void test_rt21586() {
 476         listView.getItems().setAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 477         listView.getSelectionModel().select(1);
 478         assertEquals(1, listView.getSelectionModel().getSelectedIndex());
 479         assertEquals(&quot;Orange&quot;, listView.getSelectionModel().getSelectedItem());
 480 
 481         listView.getItems().setAll(&quot;Kiwifruit&quot;, &quot;Pineapple&quot;, &quot;Grape&quot;);
 482         assertEquals(-1, listView.getSelectionModel().getSelectedIndex());
 483         assertNull(listView.getSelectionModel().getSelectedItem());
 484     }
 485 
 486     @Test public void test_rt27820_1() {
 487         listView.getItems().setAll(&quot;Apple&quot;, &quot;Orange&quot;);
 488         listView.getSelectionModel().select(0);
 489         assertEquals(1, listView.getSelectionModel().getSelectedItems().size());
 490         assertEquals(&quot;Apple&quot;, listView.getSelectionModel().getSelectedItem());
 491 
 492         listView.getItems().clear();
 493         assertEquals(0, listView.getSelectionModel().getSelectedItems().size());
 494         assertNull(listView.getSelectionModel().getSelectedItem());
 495     }
 496 
 497     @Test public void test_rt27820_2() {
 498         listView.getItems().setAll(&quot;Apple&quot;, &quot;Orange&quot;);
 499         listView.getSelectionModel().select(1);
 500         assertEquals(1, listView.getSelectionModel().getSelectedItems().size());
 501         assertEquals(&quot;Orange&quot;, listView.getSelectionModel().getSelectedItem());
 502 
 503         listView.getItems().clear();
 504         assertEquals(0, listView.getSelectionModel().getSelectedItems().size());
 505         assertNull(listView.getSelectionModel().getSelectedItem());
 506     }
 507 
 508     @Test public void test_rt28534() {
 509         ListView&lt;Person&gt; list = new ListView&lt;Person&gt;();
 510         list.setItems(FXCollections.observableArrayList(
 511                 new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;),
 512                 new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;),
 513                 new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;),
 514                 new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;),
 515                 new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
 516 
 517         VirtualFlowTestUtils.assertRowsNotEmpty(list, 0, 5); // rows 0 - 5 should be filled
 518         VirtualFlowTestUtils.assertRowsEmpty(list, 5, -1); // rows 5+ should be empty
 519 
 520         // now we replace the data and expect the cells that have no data
 521         // to be empty
 522         list.setItems(FXCollections.observableArrayList(
 523                 new Person(&quot;*_*Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;),
 524                 new Person(&quot;_Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
 525 
 526         VirtualFlowTestUtils.assertRowsNotEmpty(list, 0, 2); // rows 0 - 2 should be filled
 527         VirtualFlowTestUtils.assertRowsEmpty(list, 2, -1); // rows 2+ should be empty
 528     }
 529 
 530     @Test public void test_rt22463() {
 531         final ListView&lt;RT_22463_Person&gt; list = new ListView&lt;RT_22463_Person&gt;();
 532 
 533         // before the change things display fine
 534         RT_22463_Person p1 = new RT_22463_Person();
 535         p1.setId(1l);
 536         p1.setName(&quot;name1&quot;);
 537         RT_22463_Person p2 = new RT_22463_Person();
 538         p2.setId(2l);
 539         p2.setName(&quot;name2&quot;);
 540         list.setItems(FXCollections.observableArrayList(p1, p2));
 541         VirtualFlowTestUtils.assertCellTextEquals(list, 0, &quot;name1&quot;);
 542         VirtualFlowTestUtils.assertCellTextEquals(list, 1, &quot;name2&quot;);
 543 
 544         // now we change the persons but they are still equal as the ID&#39;s don&#39;t
 545         // change - but the items list is cleared so the cells should update
 546         RT_22463_Person new_p1 = new RT_22463_Person();
 547         new_p1.setId(1l);
 548         new_p1.setName(&quot;updated name1&quot;);
 549         RT_22463_Person new_p2 = new RT_22463_Person();
 550         new_p2.setId(2l);
 551         new_p2.setName(&quot;updated name2&quot;);
 552         list.getItems().clear();
 553         list.setItems(FXCollections.observableArrayList(new_p1, new_p2));
 554         VirtualFlowTestUtils.assertCellTextEquals(list, 0, &quot;updated name1&quot;);
 555         VirtualFlowTestUtils.assertCellTextEquals(list, 1, &quot;updated name2&quot;);
 556     }
 557 
 558     @Test public void test_rt28637() {
 559         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;String1&quot;, &quot;String2&quot;, &quot;String3&quot;, &quot;String4&quot;);
 560 
 561         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;();
 562         listView.setItems(items);
 563 
 564         listView.getSelectionModel().select(0);
 565         assertEquals(&quot;String1&quot;, listView.getSelectionModel().getSelectedItem());
 566         assertEquals(&quot;String1&quot;, listView.getSelectionModel().getSelectedItems().get(0));
 567         assertEquals(0, listView.getSelectionModel().getSelectedIndex());
 568 
 569         items.remove(listView.getSelectionModel().getSelectedItem());
 570         assertEquals(&quot;String2&quot;, listView.getSelectionModel().getSelectedItem());
 571         assertEquals(&quot;String2&quot;, listView.getSelectionModel().getSelectedItems().get(0));
 572         assertEquals(0, listView.getSelectionModel().getSelectedIndex());
 573     }
 574 
 575     @Test public void test_rt28819_1() {
 576         ObservableList&lt;String&gt; emptyModel = FXCollections.observableArrayList();
 577 
 578         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;();
 579         listView.setItems(emptyModel);
 580         VirtualFlowTestUtils.assertRowsEmpty(listView, 0, 5);
 581 
 582         ObservableList&lt;String&gt; mod = FXCollections.observableArrayList();
 583         String value = System.currentTimeMillis()+&quot;&quot;;
 584         mod.add(value);
 585         listView.setItems(mod);
 586         VirtualFlowTestUtils.assertCellCount(listView, 1);
 587         VirtualFlowTestUtils.assertCellTextEquals(listView, 0, value);
 588     }
 589 
 590     @Test public void test_rt28819_2() {
 591         ObservableList&lt;String&gt; emptyModel = FXCollections.observableArrayList();
 592 
 593         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;();
 594         listView.setItems(emptyModel);
 595         VirtualFlowTestUtils.assertRowsEmpty(listView, 0, 5);
 596 
 597         ObservableList&lt;String&gt; mod1 = FXCollections.observableArrayList();
 598         String value1 = System.currentTimeMillis()+&quot;&quot;;
 599         mod1.add(value1);
 600         listView.getItems().setAll(mod1);
 601         VirtualFlowTestUtils.assertCellCount(listView, 1);
 602         VirtualFlowTestUtils.assertCellTextEquals(listView, 0, value1);
 603     }
 604 
 605     @Test public void test_rt29390() {
 606         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(
 607                 &quot;String1&quot;, &quot;String2&quot;, &quot;String3&quot;, &quot;String4&quot;,
 608                 &quot;String1&quot;, &quot;String2&quot;, &quot;String3&quot;, &quot;String4&quot;,
 609                 &quot;String1&quot;, &quot;String2&quot;, &quot;String3&quot;, &quot;String4&quot;,
 610                 &quot;String1&quot;, &quot;String2&quot;, &quot;String3&quot;, &quot;String4&quot;
 611         );
 612 
 613         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;(items);
 614         listView.setMaxHeight(50);
 615         listView.setPrefHeight(50);
 616 
 617         // we want the vertical scrollbar
 618         VirtualScrollBar scrollBar = VirtualFlowTestUtils.getVirtualFlowVerticalScrollbar(listView);
 619 
 620         assertNotNull(scrollBar);
 621         assertTrue(scrollBar.isVisible());
 622         assertTrue(scrollBar.getVisibleAmount() &gt; 0.0);
 623         assertTrue(scrollBar.getVisibleAmount() &lt; 1.0);
 624 
 625         // this next test is likely to be brittle, but we&#39;ll see...If it is the
 626         // cause of failure then it can be commented out
 627         assertEquals(0.125, scrollBar.getVisibleAmount(), 0.0);
 628     }
 629 
 630     @Test public void test_rt30400() {
 631         // create a listview that&#39;ll render cells using the check box cell factory
 632         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;String1&quot;);
 633         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;(items);
 634         listView.setMinHeight(100);
 635         listView.setPrefHeight(100);
 636         listView.setCellFactory(CheckBoxListCell.forListView(param -&gt; new ReadOnlyBooleanWrapper(true)));
 637 
 638         // because only the first row has data, all other rows should be
 639         // empty (and not contain check boxes - we just check the first four here)
 640         VirtualFlowTestUtils.assertRowsNotEmpty(listView, 0, 1);
 641         VirtualFlowTestUtils.assertCellNotEmpty(VirtualFlowTestUtils.getCell(listView, 0));
 642         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(listView, 1));
 643         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(listView, 2));
 644         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(listView, 3));
 645     }
 646 
 647     @Test public void test_rt29420() {
 648         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;();
 649 
 650         VBox vbox = new VBox(listView);
 651         StageLoader sl = new StageLoader(vbox);
 652 
 653         // the initial width of a ListView should be the golden rectangle where
 654         // the height is hardcoded to be 400
 655         final double initialWidth = listView.prefWidth(-1);
 656         assertEquals(400 * 0.618033987, initialWidth, 0.00);
 657 
 658         // add in some items, and re-measure - seeing as the items are narrow,
 659         // the width shouldn&#39;t change
 660         listView.getItems().addAll(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;);
 661         Toolkit.getToolkit().firePulse();
 662         final double withContentWidth = listView.prefWidth(-1);
 663         assertEquals(initialWidth, withContentWidth, 0.00);
 664 
 665         // remove the items - and the width should remain the same
 666         listView.getItems().clear();
 667         Toolkit.getToolkit().firePulse();
 668         final double afterEmptiedWidth = listView.prefWidth(-1);
 669         assertEquals(initialWidth, afterEmptiedWidth, 0.00);
 670 
 671         sl.dispose();
 672     }
 673 
 674     @Test public void test_rt31165() {
 675         final ObservableList names = FXCollections.observableArrayList(&quot;Adam&quot;, &quot;Alex&quot;, &quot;Alfred&quot;, &quot;Albert&quot;);
 676         final ObservableList data = FXCollections.observableArrayList();
 677         for (int i = 0; i &lt; 18; i++) {
 678             data.add(&quot;&quot;+i);
 679         }
 680 
 681         final ListView listView = new ListView(data);
 682         listView.setPrefSize(200, 250);
 683         listView.setEditable(true);
 684         listView.setCellFactory(ComboBoxListCell.forListView(names));
 685 
 686         IndexedCell cell = VirtualFlowTestUtils.getCell(listView, 1);
 687         assertEquals(&quot;1&quot;, cell.getText());
 688         assertFalse(cell.isEditing());
 689 
 690         listView.edit(1);
 691 
 692         assertEquals(1, listView.getEditingIndex());
 693         assertTrue(cell.isEditing());
 694 
 695         VirtualFlowTestUtils.getVirtualFlow(listView).requestLayout();
 696         Toolkit.getToolkit().firePulse();
 697 
 698         assertEquals(1, listView.getEditingIndex());
 699         assertTrue(cell.isEditing());
 700     }
 701 
 702     @Test public void test_rt31471() {
 703         final ObservableList names = FXCollections.observableArrayList(&quot;Adam&quot;, &quot;Alex&quot;, &quot;Alfred&quot;, &quot;Albert&quot;);
 704         final ListView listView = new ListView(names);
 705 
 706         IndexedCell cell = VirtualFlowTestUtils.getCell(listView, 0);
 707         assertEquals(&quot;Adam&quot;, cell.getItem());
 708 
 709         listView.setFixedCellSize(50);
 710 
 711         VirtualFlowTestUtils.getVirtualFlow(listView).requestLayout();
 712         Toolkit.getToolkit().firePulse();
 713 
 714         assertEquals(&quot;Adam&quot;, cell.getItem());
 715         assertEquals(50, cell.getHeight(), 0.00);
 716     }
 717 
 718     private int rt_31200_count = 0;
 719     @Test public void test_rt_31200() {
 720         final ListView listView = new ListView();
 721         listView.setCellFactory(new Callback&lt;ListView&lt;String&gt;, ListCell&lt;String&gt;&gt;() {
 722             @Override
 723             public ListCell&lt;String&gt; call(ListView&lt;String&gt; param) {
 724                 return new ListCellShim&lt;String&gt;() {
 725                     ImageView view = new ImageView();
 726                     { setGraphic(view); };
 727 
 728                     @Override
 729                     public void updateItem(String item, boolean empty) {
 730                         if (getItem() == null ? item == null : getItem().equals(item)) {
 731                             rt_31200_count++;
 732                         }
 733                         super.updateItem(item, empty);
 734                         if (item == null || empty) {
 735                             view.setImage(null);
 736                             setText(null);
 737                         } else {
 738                             setText(item);
 739                         }
 740                     }
 741                 };
 742             }
 743         });
 744         listView.getItems().setAll(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;);
 745 
 746         StageLoader sl = new StageLoader(listView);
 747 
 748         assertEquals(24, rt_31200_count);
 749 
 750         // resize the stage
 751         sl.getStage().setHeight(250);
 752         Toolkit.getToolkit().firePulse();
 753         sl.getStage().setHeight(50);
 754         Toolkit.getToolkit().firePulse();
 755         assertEquals(24, rt_31200_count);
 756 
 757         sl.dispose();
 758     }
 759 
 760     @Test public void test_rt_30484() {
 761         final ListView listView = new ListView();
 762         listView.setCellFactory(new Callback&lt;ListView&lt;String&gt;, ListCell&lt;String&gt;&gt;() {
 763             @Override public ListCell&lt;String&gt; call(ListView&lt;String&gt; param) {
 764                 return new ListCellShim&lt;String&gt;() {
 765                     Rectangle graphic = new Rectangle(10, 10, Color.RED);
 766                     { setGraphic(graphic); };
 767 
 768                     @Override public void updateItem(String item, boolean empty) {
 769                         super.updateItem(item, empty);
 770                         if (item == null || empty) {
 771                             graphic.setVisible(false);
 772                             setText(null);
 773                         } else {
 774                             graphic.setVisible(true);
 775                             setText(item);
 776                         }
 777                     }
 778                 };
 779             }
 780         });
 781 
 782         // First two rows have content, so the graphic should show.
 783         // All other rows have no content, so graphic should not show.
 784         listView.getItems().setAll(&quot;one&quot;, &quot;two&quot;);
 785 
 786         VirtualFlowTestUtils.assertGraphicIsVisible(listView, 0);
 787         VirtualFlowTestUtils.assertGraphicIsVisible(listView, 1);
 788         VirtualFlowTestUtils.assertGraphicIsNotVisible(listView, 2);
 789         VirtualFlowTestUtils.assertGraphicIsNotVisible(listView, 3);
 790         VirtualFlowTestUtils.assertGraphicIsNotVisible(listView, 4);
 791         VirtualFlowTestUtils.assertGraphicIsNotVisible(listView, 5);
 792     }
 793 
 794     private int rt_29650_start_count = 0;
 795     private int rt_29650_commit_count = 0;
 796     private int rt_29650_cancel_count = 0;
 797     @Test public void test_rt_29650() {
 798         listView.setOnEditStart(t -&gt; {
 799             rt_29650_start_count++;
 800         });
 801         listView.setOnEditCommit(t -&gt; {
 802             rt_29650_commit_count++;
 803         });
 804         listView.setOnEditCancel(t -&gt; {
 805             rt_29650_cancel_count++;
 806         });
 807 
 808         listView.getItems().setAll(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;);
 809         listView.setEditable(true);
 810         listView.setCellFactory(TextFieldListCell.forListView());
 811 
 812         StageLoader sl = new StageLoader(listView);
 813 
 814         listView.edit(0);
 815 
 816         Toolkit.getToolkit().firePulse();
 817 
 818         ListCell rootCell = (ListCell) VirtualFlowTestUtils.getCell(listView, 0);
 819         TextField textField = (TextField) rootCell.getGraphic();
 820         textField.setText(&quot;Testing!&quot;);
 821         KeyEventFirer keyboard = new KeyEventFirer(textField);
 822         keyboard.doKeyPress(KeyCode.ENTER);
 823 
 824         // TODO should the following assert be enabled?
 825 //        assertEquals(&quot;Testing!&quot;, listView.getItems().get(0));
 826         assertEquals(1, rt_29650_start_count);
 827         assertEquals(1, rt_29650_commit_count);
 828         assertEquals(0, rt_29650_cancel_count);
 829 
 830         sl.dispose();
 831     }
 832 
 833     @Test public void test_rt35039() {
 834         final List&lt;String&gt; data = new ArrayList&lt;&gt;();
 835         data.add(&quot;aabbaa&quot;);
 836         data.add(&quot;bbc&quot;);
 837 
 838         final ListView&lt;String&gt; listView = new ListView&lt;&gt;();
 839         listView.setItems(FXCollections.observableArrayList(data));
 840 
 841         StageLoader sl = new StageLoader(listView);
 842 
 843         // selection starts off on row -1
 844         assertNull(listView.getSelectionModel().getSelectedItem());
 845 
 846         // select &quot;bbc&quot; and ensure everything is set to that
 847         listView.getSelectionModel().select(1);
 848         assertEquals(&quot;bbc&quot;, listView.getSelectionModel().getSelectedItem());
 849 
 850         // change the items list - but retain the same content. We expect
 851         // that &quot;bbc&quot; remains selected as it is still in the list
 852         listView.setItems(FXCollections.observableArrayList(data));
 853         assertEquals(&quot;bbc&quot;, listView.getSelectionModel().getSelectedItem());
 854 
 855         sl.dispose();
 856     }
 857 
 858     @Test public void test_rt35857() {
 859         ObservableList&lt;String&gt; fxList = FXCollections.observableArrayList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);
 860         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;(fxList);
 861 
 862         listView.getSelectionModel().select(0);
 863 
 864         ObservableList&lt;String&gt; selectedItems = listView.getSelectionModel().getSelectedItems();
 865         assertEquals(1, selectedItems.size());
 866         assertEquals(&quot;A&quot;, selectedItems.get(0));
 867 
 868         listView.getItems().removeAll(selectedItems);
 869         assertEquals(2, fxList.size());
 870         assertEquals(&quot;B&quot;, fxList.get(0));
 871         assertEquals(&quot;C&quot;, fxList.get(1));
 872     }
 873 
 874     private int rt_35889_cancel_count = 0;
 875     @Test public void test_rt35889() {
 876         final ListView&lt;String&gt; textFieldListView = new ListView&lt;String&gt;();
 877         textFieldListView.setItems(FXCollections.observableArrayList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;));
 878         textFieldListView.setEditable(true);
 879         textFieldListView.setCellFactory(TextFieldListCell.forListView());
 880         textFieldListView.setOnEditCancel(t -&gt; {
 881             rt_35889_cancel_count++;
 882             System.out.println(&quot;On Edit Cancel: &quot; + t);
 883         });
 884 
 885         ListCell cell0 = (ListCell) VirtualFlowTestUtils.getCell(textFieldListView, 0);
 886         assertNull(cell0.getGraphic());
 887         assertEquals(&quot;A&quot;, cell0.getText());
 888 
 889         textFieldListView.edit(0);
 890         TextField textField = (TextField) cell0.getGraphic();
 891         assertNotNull(textField);
 892 
 893         assertEquals(0, rt_35889_cancel_count);
 894 
 895         textField.setText(&quot;Z&quot;);
 896         KeyEventFirer keyboard = new KeyEventFirer(textField);
 897         keyboard.doKeyPress(KeyCode.ENTER);
 898 
 899         assertEquals(0, rt_35889_cancel_count);
 900     }
 901 
 902     @Test public void test_rt25679() {
 903         Button focusBtn = new Button(&quot;Focus here&quot;);
 904 
 905         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;();
 906         SelectionModel sm = listView.getSelectionModel();
 907         listView.setItems(FXCollections.observableArrayList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;));
 908 
 909         VBox vbox = new VBox(focusBtn, listView);
 910 
 911         StageLoader sl = new StageLoader(vbox);
 912         sl.getStage().requestFocus();
 913         focusBtn.requestFocus();
 914         Toolkit.getToolkit().firePulse();
 915 
 916         // test initial state
 917         assertEquals(sl.getStage().getScene().getFocusOwner(), focusBtn);
 918         assertTrue(focusBtn.isFocused());
 919         assertEquals(-1, sm.getSelectedIndex());
 920         assertNull(sm.getSelectedItem());
 921 
 922         // move focus to the listview
 923         listView.requestFocus();
 924 
 925         // ensure that there is a selection (where previously there was not one)
 926         assertEquals(sl.getStage().getScene().getFocusOwner(), listView);
 927         assertTrue(listView.isFocused());
 928         assertEquals(-1, sm.getSelectedIndex());
 929         assertNull(sm.getSelectedItem());
 930 
 931         sl.dispose();
 932     }
 933 
 934     private int rt_37061_index_counter = 0;
 935     private int rt_37061_item_counter = 0;
 936     @Test public void test_rt_37061() {
 937         ListView&lt;Integer&gt; tv = new ListView&lt;&gt;();
 938         tv.getItems().add(1);
 939         tv.getSelectionModel().select(0);
 940 
 941         // note we add the listeners after the selection is made, so the counters
 942         // at this point are still both at zero.
 943         tv.getSelectionModel().selectedIndexProperty().addListener((observable, oldValue, newValue) -&gt; {
 944             rt_37061_index_counter++;
 945         });
 946 
 947         tv.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -&gt; {
 948             rt_37061_item_counter++;
 949         });
 950 
 951         // add a new item. This does not impact the selected index or selected item
 952         // so the counters should remain at zero.
 953         tv.getItems().add(2);
 954         assertEquals(0, rt_37061_index_counter);
 955         assertEquals(0, rt_37061_item_counter);
 956     }
 957 
 958     private int rt_37538_count = 0;
 959     @Test public void test_rt_37538_noCNextCall() {
 960         test_rt_37538(false, false);
 961     }
 962 
 963     @Test public void test_rt_37538_callCNextOnce() {
 964         test_rt_37538(true, false);
 965     }
 966 
 967     @Test public void test_rt_37538_callCNextInLoop() {
 968         test_rt_37538(false, true);
 969     }
 970 
 971     private void test_rt_37538(boolean callCNextOnce, boolean callCNextInLoop) {
 972         ListView&lt;Integer&gt; list = new ListView&lt;&gt;();
 973         for ( int i = 1; i &lt;= 50; i++ ) {
 974             list.getItems().add(i);
 975         }
 976 
 977         list.getSelectionModel().getSelectedItems().addListener((ListChangeListener.Change&lt;? extends Integer&gt; c) -&gt; {
 978             if (callCNextOnce) {
 979                 c.next();
 980             } else if (callCNextInLoop) {
 981                 while (c.next()) {
 982                     // no-op
 983                 }
 984             }
 985 
 986             if (rt_37538_count &gt;= 1) {
 987                 Thread.dumpStack();
 988                 fail(&quot;This method should only be called once&quot;);
 989             }
 990 
 991             rt_37538_count++;
 992         });
 993 
 994         StageLoader sl = new StageLoader(list);
 995         assertEquals(0, rt_37538_count);
 996         list.getSelectionModel().select(0);
 997         assertEquals(1, rt_37538_count);
 998         sl.dispose();
 999     }
1000 
1001     @Test
1002     public void test_rt_35395_fixedCellSize() {
1003         test_rt_35395(true);
1004     }
1005 
1006     @Test
1007     public void test_rt_35395_notFixedCellSize() {
1008         test_rt_35395(false);
1009     }
1010 
1011     private int rt_35395_counter;
1012 
1013     private void test_rt_35395(boolean useFixedCellSize) {
1014         rt_35395_counter = 0;
1015 
1016         ObservableList&lt;String&gt; items = FXCollections.observableArrayList();
1017         for (int i = 0; i &lt; 20; ++i) {
1018             items.addAll(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;purple&quot;);
1019         }
1020 
1021         ListView&lt;String&gt; listView = new ListView&lt;&gt;(items);
1022         if (useFixedCellSize) {
1023             listView.setFixedCellSize(24);
1024         }
1025         listView.setCellFactory(lv -&gt; new ListCellShim&lt;String&gt;() {
1026             @Override
1027             public void updateItem(String color, boolean empty) {
1028                 rt_35395_counter += 1;
1029                 super.updateItem(color, empty);
1030                 setText(null);
1031                 if (empty) {
1032                     setGraphic(null);
1033                 } else {
1034                     Rectangle rect = new Rectangle(16, 16);
1035                     rect.setStyle(&quot;-fx-fill: &quot; + color);
1036                     setGraphic(rect);
1037                 }
1038             }
1039         });
1040 
1041         StageLoader sl = new StageLoader(listView);
1042 
1043         Platform.runLater(() -&gt; {
1044             rt_35395_counter = 0;
1045             items.set(10, &quot;yellow&quot;);
1046             Platform.runLater(() -&gt; {
1047                 Toolkit.getToolkit().firePulse();
1048                 assertEquals(1, rt_35395_counter);
1049                 rt_35395_counter = 0;
1050                 items.set(30, &quot;yellow&quot;);
1051                 Platform.runLater(() -&gt; {
1052                     Toolkit.getToolkit().firePulse();
1053                     assertEquals(0, rt_35395_counter);
1054                     rt_35395_counter = 0;
1055                     items.remove(12);
1056                     Platform.runLater(() -&gt; {
1057                         Toolkit.getToolkit().firePulse();
1058                         assertEquals(useFixedCellSize ? 39 : 45, rt_35395_counter);
1059                         rt_35395_counter = 0;
1060                         items.add(12, &quot;yellow&quot;);
1061                         Platform.runLater(() -&gt; {
1062                             Toolkit.getToolkit().firePulse();
1063                             assertEquals(useFixedCellSize ? 39 : 45, rt_35395_counter);
1064                             rt_35395_counter = 0;
1065                             listView.scrollTo(5);
1066                             Platform.runLater(() -&gt; {
1067                                 Toolkit.getToolkit().firePulse();
1068                                 assertEquals(5, rt_35395_counter);
1069                                 rt_35395_counter = 0;
1070                                 listView.scrollTo(55);
1071                                 Platform.runLater(() -&gt; {
1072                                     Toolkit.getToolkit().firePulse();
1073                                     assertEquals(useFixedCellSize ? 17 : 53, rt_35395_counter);
1074                                     sl.dispose();
1075                                 });
1076                             });
1077                         });
1078                     });
1079                 });
1080             });
1081         });
1082     }
1083 
1084     @Test public void test_rt_37632() {
1085         final ObservableList&lt;String&gt; listOne = FXCollections.observableArrayList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);
1086         final ObservableList&lt;String&gt; listTwo = FXCollections.observableArrayList(&quot;C&quot;);
1087 
1088         final ListView&lt;String&gt; listView = new ListView&lt;&gt;();
1089         MultipleSelectionModel&lt;String&gt; sm = listView.getSelectionModel();
1090         listView.setItems(listOne);
1091         listView.getSelectionModel().selectFirst();
1092 
1093         assertEquals(0, sm.getSelectedIndex());
1094         assertEquals(&quot;A&quot;, sm.getSelectedItem());
1095         assertEquals(1, sm.getSelectedIndices().size());
1096         assertEquals(0, (int) sm.getSelectedIndices().get(0));
1097         assertEquals(1, sm.getSelectedItems().size());
1098         assertEquals(&quot;A&quot;, sm.getSelectedItems().get(0));
1099 
1100         listView.setItems(listTwo);
1101 
1102         assertEquals(-1, sm.getSelectedIndex());
1103         assertNull(sm.getSelectedItem());
1104         assertEquals(0, sm.getSelectedIndices().size());
1105         assertEquals(0, sm.getSelectedItems().size());
1106     }
1107 
1108     private int rt_37853_cancelCount;
1109     private int rt_37853_commitCount;
1110     @Test public void test_rt_37853() {
1111         listView.setCellFactory(TextFieldListCell.forListView());
1112         listView.setEditable(true);
1113 
1114         for (int i = 0; i &lt; 10; i++) {
1115             listView.getItems().add(&quot;&quot; + i);
1116         }
1117 
1118         StageLoader sl = new StageLoader(listView);
1119 
1120         listView.setOnEditCancel(editEvent -&gt; rt_37853_cancelCount++);
1121         listView.setOnEditCommit(editEvent -&gt; rt_37853_commitCount++);
1122 
1123         assertEquals(0, rt_37853_cancelCount);
1124         assertEquals(0, rt_37853_commitCount);
1125 
1126         listView.edit(1);
1127         assertNotNull(listView.getEditingIndex());
1128 
1129         listView.getItems().clear();
1130         assertEquals(1, rt_37853_cancelCount);
1131         assertEquals(0, rt_37853_commitCount);
1132 
1133         sl.dispose();
1134     }
1135 
1136     @Test public void test_rt_38787_remove_b() {
1137         // selection moves to &quot;a&quot;
1138         test_rt_38787(&quot;a&quot;, 0, &quot;b&quot;);
1139     }
1140 
1141     @Test public void test_rt_38787_remove_b_c() {
1142         // selection moves to &quot;a&quot;
1143         test_rt_38787(&quot;a&quot;, 0, &quot;b&quot;, &quot;c&quot;);
1144     }
1145 
1146     @Test public void test_rt_38787_remove_c_d() {
1147         // selection moves to &quot;b&quot;
1148         test_rt_38787(&quot;b&quot;, 1, &quot;c&quot;, &quot;d&quot;);
1149     }
1150 
1151     @Test public void test_rt_38787_remove_a() {
1152         // selection moves to &quot;b&quot;, now in index 0
1153         test_rt_38787(&quot;b&quot;, 0, &quot;a&quot;);
1154     }
1155 
1156     @Test public void test_rt_38787_remove_z() {
1157         // selection shouldn&#39;t move as &#39;z&#39; doesn&#39;t exist
1158         test_rt_38787(&quot;b&quot;, 1, &quot;z&quot;);
1159     }
1160 
1161     private void test_rt_38787(String expectedItem, int expectedIndex, String... itemsToRemove) {
1162         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1163         stringListView.getItems().addAll(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;);
1164 
1165         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1166         sm.select(&quot;b&quot;);
1167 
1168         // test pre-conditions
1169         assertEquals(1, sm.getSelectedIndex());
1170         assertEquals(1, (int)sm.getSelectedIndices().get(0));
1171         assertEquals(&quot;b&quot;, sm.getSelectedItem());
1172         assertEquals(&quot;b&quot;, sm.getSelectedItems().get(0));
1173         assertFalse(sm.isSelected(0));
1174         assertTrue(sm.isSelected(1));
1175         assertFalse(sm.isSelected(2));
1176 
1177         // removing items
1178         stringListView.getItems().removeAll(itemsToRemove);
1179 
1180         // testing against expectations
1181         assertEquals(expectedIndex, sm.getSelectedIndex());
1182         assertEquals(expectedIndex, (int)sm.getSelectedIndices().get(0));
1183         assertEquals(expectedItem, sm.getSelectedItem());
1184         assertEquals(expectedItem, sm.getSelectedItems().get(0));
1185     }
1186 
1187     private int rt_38341_indices_count = 0;
1188     private int rt_38341_items_count = 0;
1189     @Test public void test_rt_38341() {
1190         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1191         stringListView.getItems().addAll(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;);
1192 
1193         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1194         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) c -&gt; rt_38341_indices_count++);
1195         sm.getSelectedItems().addListener((ListChangeListener&lt;String&gt;) c -&gt; rt_38341_items_count++);
1196 
1197         assertEquals(0, rt_38341_indices_count);
1198         assertEquals(0, rt_38341_items_count);
1199 
1200         // expand the first child of root, and select it (note: root isn&#39;t visible)
1201         sm.select(1);
1202         assertEquals(1, sm.getSelectedIndex());
1203         assertEquals(1, sm.getSelectedIndices().size());
1204         assertEquals(1, (int)sm.getSelectedIndices().get(0));
1205         assertEquals(1, sm.getSelectedItems().size());
1206         assertEquals(&quot;b&quot;, sm.getSelectedItem());
1207         assertEquals(&quot;b&quot;, sm.getSelectedItems().get(0));
1208 
1209         assertEquals(1, rt_38341_indices_count);
1210         assertEquals(1, rt_38341_items_count);
1211 
1212         // now delete it
1213         stringListView.getItems().remove(1);
1214 
1215         // selection should move to the childs parent in index 0
1216         assertEquals(0, sm.getSelectedIndex());
1217         assertEquals(1, sm.getSelectedIndices().size());
1218         assertEquals(0, (int)sm.getSelectedIndices().get(0));
1219         assertEquals(1, sm.getSelectedItems().size());
1220         assertEquals(&quot;a&quot;, sm.getSelectedItem());
1221         assertEquals(&quot;a&quot;, sm.getSelectedItems().get(0));
1222 
1223         // we also expect there to be an event in the selection model for
1224         // selected indices and selected items
1225         assertEquals(sm.getSelectedIndices() +&quot;&quot;, 2, rt_38341_indices_count);
1226         assertEquals(2, rt_38341_items_count);
1227     }
1228 
1229     @Test public void test_rt_39132() {
1230         ObservableList items = FXCollections.observableArrayList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);
1231         ListView listView = new ListView&lt;&gt;();
1232         listView.setItems(items);
1233 
1234         MultipleSelectionModel sm = listView.getSelectionModel();
1235         sm.select(0);
1236 
1237         assertEquals(0, sm.getSelectedIndex());
1238         assertEquals(&quot;one&quot;, sm.getSelectedItem());
1239 
1240         items.add(0, &quot;new item&quot;);
1241         assertEquals(1, sm.getSelectedIndex());
1242         assertEquals(&quot;one&quot;, sm.getSelectedItem());
1243     }
1244 
1245     private int rt_38943_index_count = 0;
1246     private int rt_38943_item_count = 0;
1247     @Test public void test_rt_38943() {
1248         ListView&lt;String&gt; listView = new ListView&lt;&gt;(FXCollections.observableArrayList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;));
1249 
1250         MultipleSelectionModel sm = listView.getSelectionModel();
1251 
1252         sm.selectedIndexProperty().addListener((observable, oldValue, newValue) -&gt; rt_38943_index_count++);
1253         sm.selectedItemProperty().addListener((observable, oldValue, newValue) -&gt; rt_38943_item_count++);
1254 
1255         assertEquals(-1, sm.getSelectedIndex());
1256         assertNull(sm.getSelectedItem());
1257         assertEquals(0, rt_38943_index_count);
1258         assertEquals(0, rt_38943_item_count);
1259 
1260         sm.select(0);
1261         assertEquals(0, sm.getSelectedIndex());
1262         assertEquals(&quot;one&quot;, sm.getSelectedItem());
1263         assertEquals(1, rt_38943_index_count);
1264         assertEquals(1, rt_38943_item_count);
1265 
1266         sm.clearSelection(0);
1267         assertEquals(-1, sm.getSelectedIndex());
1268         assertNull(sm.getSelectedItem());
1269         assertEquals(2, rt_38943_index_count);
1270         assertEquals(2, rt_38943_item_count);
1271     }
1272 
1273     @Test public void test_rt_38884() {
1274         ListView&lt;String&gt; listView = new ListView&lt;&gt;();
1275         ObservableList&lt;String&gt; items = listView.getItems();
1276 
1277         listView.getSelectionModel().getSelectedItems().addListener((ListChangeListener.Change&lt;? extends String&gt; c) -&gt; {
1278             while (c.next()) {
1279                 if (c.wasRemoved()) {
1280                     assertTrue(c.getRemovedSize() &gt; 0);
1281 
1282                     List&lt;? extends String&gt; removed = c.getRemoved();
1283                     String removedItem = null;
1284                     try {
1285                         removedItem = removed.get(0);
1286                     } catch (Exception e) {
1287                         fail();
1288                     }
1289 
1290                     assertEquals(&quot;foo&quot;, removedItem);
1291                 }
1292             }
1293         });
1294 
1295         items.add(&quot;foo&quot;);
1296         listView.getSelectionModel().select(0);
1297         items.clear();
1298     }
1299 
1300     private int rt_37360_add_count = 0;
1301     private int rt_37360_remove_count = 0;
1302     @Test public void test_rt_37360() {
1303         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1304         stringListView.getItems().addAll(&quot;a&quot;, &quot;b&quot;);
1305 
1306         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1307         sm.setSelectionMode(SelectionMode.MULTIPLE);
1308         sm.getSelectedItems().addListener((ListChangeListener&lt;String&gt;) c -&gt; {
1309             while (c.next()) {
1310                 if (c.wasAdded()) {
1311                     rt_37360_add_count += c.getAddedSize();
1312                 }
1313                 if (c.wasRemoved()) {
1314                     rt_37360_remove_count += c.getRemovedSize();
1315                 }
1316             }
1317         });
1318 
1319         assertEquals(0, sm.getSelectedItems().size());
1320         assertEquals(0, rt_37360_add_count);
1321         assertEquals(0, rt_37360_remove_count);
1322 
1323         sm.select(0);
1324         assertEquals(1, sm.getSelectedItems().size());
1325         assertEquals(1, rt_37360_add_count);
1326         assertEquals(0, rt_37360_remove_count);
1327 
1328         sm.select(1);
1329         assertEquals(2, sm.getSelectedItems().size());
1330         assertEquals(2, rt_37360_add_count);
1331         assertEquals(0, rt_37360_remove_count);
1332 
1333         sm.clearAndSelect(1);
1334         assertEquals(1, sm.getSelectedItems().size());
1335         assertEquals(2, rt_37360_add_count);
1336         assertEquals(1, rt_37360_remove_count);
1337     }
1338 
1339     @Test public void test_rt_38491() {
1340         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1341         stringListView.getItems().addAll(&quot;a&quot;, &quot;b&quot;);
1342 
1343         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1344         sm.setSelectionMode(SelectionMode.MULTIPLE);
1345 
1346         FocusModel&lt;String&gt; fm = stringListView.getFocusModel();
1347 
1348         // click on row 0
1349         VirtualFlowTestUtils.clickOnRow(stringListView, 0);
1350         assertTrue(sm.isSelected(0));
1351         assertEquals(&quot;a&quot;, sm.getSelectedItem());
1352         assertTrue(fm.isFocused(0));
1353         assertEquals(&quot;a&quot;, fm.getFocusedItem());
1354         assertEquals(0, fm.getFocusedIndex());
1355 
1356         int anchor = ListCellBehavior.getAnchor(stringListView, -1);
1357         assertTrue(ListCellBehavior.hasNonDefaultAnchor(stringListView));
1358         assertEquals(0, anchor);
1359 
1360         // now add a new item at row 0. This has the effect of pushing down
1361         // the selected item into row 1.
1362         stringListView.getItems().add(0, &quot;z&quot;);
1363 
1364         // The first bug was that selection and focus were not moving down to
1365         // be on row 1, so we test that now
1366         assertFalse(sm.isSelected(0));
1367         assertFalse(fm.isFocused(0));
1368         assertTrue(sm.isSelected(1));
1369         assertEquals(&quot;a&quot;, sm.getSelectedItem());
1370         assertTrue(fm.isFocused(1));
1371         assertEquals(&quot;a&quot;, fm.getFocusedItem());
1372         assertEquals(1, fm.getFocusedIndex());
1373 
1374         // The second bug was that the anchor was not being pushed down as well
1375         // (when it should).
1376         anchor = ListCellBehavior.getAnchor(stringListView, -1);
1377         assertTrue(ListCellBehavior.hasNonDefaultAnchor(stringListView));
1378         assertEquals(1, anchor);
1379     }
1380 
1381     private final ObservableList&lt;String&gt; rt_39256_list = FXCollections.observableArrayList();
1382     @Test public void test_rt_39256() {
1383         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1384         stringListView.getItems().addAll(&quot;a&quot;,&quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
1385 
1386         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1387         sm.setSelectionMode(SelectionMode.MULTIPLE);
1388 
1389 //        rt_39256_list.addListener((ListChangeListener&lt;String&gt;) change -&gt; {
1390 //            while (change.next()) {
1391 //                System.err.println(&quot;number of selected persons (in bound list): &quot; + change.getList().size());
1392 //            }
1393 //        });
1394 
1395         Bindings.bindContent(rt_39256_list, sm.getSelectedItems());
1396 
1397         assertEquals(0, sm.getSelectedItems().size());
1398         assertEquals(0, rt_39256_list.size());
1399 
1400         sm.selectAll();
1401         assertEquals(4, sm.getSelectedItems().size());
1402         assertEquals(4, rt_39256_list.size());
1403 
1404         sm.selectAll();
1405         assertEquals(4, sm.getSelectedItems().size());
1406         assertEquals(4, rt_39256_list.size());
1407 
1408         sm.selectAll();
1409         assertEquals(4, sm.getSelectedItems().size());
1410         assertEquals(4, rt_39256_list.size());
1411     }
1412 
1413     private final ObservableList&lt;String&gt; rt_39482_list = FXCollections.observableArrayList();
1414     @Test public void test_rt_39482() {
1415         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1416         stringListView.getItems().addAll(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
1417 
1418         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1419         sm.setSelectionMode(SelectionMode.MULTIPLE);
1420 
1421         sm.getSelectedItems().addListener((ListChangeListener&lt;String&gt;) change -&gt; {
1422             while (change.next()) {
1423                 System.out.println(&quot;sm.getSelectedItems(): &quot; + change.getList());
1424             }
1425         });
1426 
1427         rt_39482_list.addListener((ListChangeListener&lt;String&gt;) change -&gt; {
1428             while (change.next()) {
1429                 System.out.println(&quot;rt_39482_list: &quot; + change.getList());
1430             }
1431         });
1432 
1433         Bindings.bindContent(rt_39482_list, sm.getSelectedItems());
1434 
1435         assertEquals(0, sm.getSelectedItems().size());
1436         assertEquals(0, rt_39482_list.size());
1437 
1438         test_rt_39482_selectRow(&quot;a&quot;, sm, 0);
1439         test_rt_39482_selectRow(&quot;b&quot;, sm, 1);
1440         test_rt_39482_selectRow(&quot;c&quot;, sm, 2);
1441         test_rt_39482_selectRow(&quot;d&quot;, sm, 3);
1442     }
1443 
1444     private void test_rt_39482_selectRow(String expectedString,
1445                                          MultipleSelectionModel&lt;String&gt; sm,
1446                                          int rowToSelect) {
1447         System.out.println(&quot;\nSelect row &quot; + rowToSelect);
1448         sm.selectAll();
1449         assertEquals(4, sm.getSelectedIndices().size());
1450         assertEquals(4, sm.getSelectedItems().size());
1451         assertEquals(4, rt_39482_list.size());
1452 
1453         sm.clearAndSelect(rowToSelect);
1454         assertEquals(1, sm.getSelectedIndices().size());
1455         assertEquals(1, sm.getSelectedItems().size());
1456         assertEquals(expectedString, sm.getSelectedItem());
1457         assertEquals(expectedString, rt_39482_list.get(0));
1458         assertEquals(1, rt_39482_list.size());
1459     }
1460 
1461     @Test public void test_rt_39559_useSM_selectAll() {
1462         test_rt_39559(true);
1463     }
1464 
1465     @Test public void test_rt_39559_useKeyboard_selectAll() {
1466         test_rt_39559(false);
1467     }
1468 
1469     private void test_rt_39559(boolean useSMSelectAll) {
1470         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1471         stringListView.getItems().addAll(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
1472 
1473         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1474         sm.setSelectionMode(SelectionMode.MULTIPLE);
1475 
1476         StageLoader sl = new StageLoader(stringListView);
1477         KeyEventFirer keyboard = new KeyEventFirer(stringListView);
1478 
1479         assertEquals(0, sm.getSelectedItems().size());
1480 
1481         sm.clearAndSelect(0);
1482 
1483         if (useSMSelectAll) {
1484             sm.selectAll();
1485         } else {
1486             keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
1487         }
1488 
1489         assertEquals(4, sm.getSelectedItems().size());
1490         assertEquals(0, (int) ListCellBehavior.getAnchor(stringListView, -1));
1491 
1492         keyboard.doKeyPress(KeyCode.DOWN, KeyModifier.SHIFT);
1493 
1494         assertEquals(0, (int) ListCellBehavior.getAnchor(stringListView, -1));
1495         assertEquals(2, sm.getSelectedItems().size());
1496         assertEquals(&quot;a&quot;, sm.getSelectedItems().get(0));
1497         assertEquals(&quot;b&quot;, sm.getSelectedItems().get(1));
1498 
1499         sl.dispose();
1500     }
1501 
1502     @Test public void test_switchingSelectionMode() {
1503         ListView&lt;String&gt; listView = new ListView&lt;&gt;();
1504         listView.getItems().addAll(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
1505 
1506         MultipleSelectionModel&lt;String&gt; sm = listView.getSelectionModel();
1507         StageLoader sl = new StageLoader(listView);
1508         KeyEventFirer keyboard = new KeyEventFirer(listView);
1509 
1510         assertEquals(0, sm.getSelectedItems().size());
1511         sm.clearAndSelect(0);
1512         assertEquals(1, sm.getSelectedItems().size());
1513         keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
1514         assertEquals(1, sm.getSelectedItems().size());
1515 
1516         sm.setSelectionMode(SelectionMode.MULTIPLE);
1517         keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
1518         assertEquals(4, sm.getSelectedItems().size());
1519 
1520         sm.setSelectionMode(SelectionMode.SINGLE);
1521         assertEquals(1, sm.getSelectedItems().size());
1522         keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
1523         assertEquals(1, sm.getSelectedItems().size());
1524 
1525         sm.setSelectionMode(SelectionMode.MULTIPLE);
1526         assertEquals(1, sm.getSelectedItems().size());
1527         keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
1528         assertEquals(4, sm.getSelectedItems().size());
1529 
1530         sl.dispose();
1531     }
1532 
1533     @Test public void test_rt_16068_firstElement_selectAndRemoveSameRow() {
1534         // select and then remove the &#39;a&#39; item, selection and focus should both
1535         // stay at the first row, now &#39;b&#39;
1536         test_rt_16068(0, 0, 0);
1537     }
1538 
1539     @Test public void test_rt_16068_firstElement_selectRowAndRemoveLaterSibling() {
1540         // select row &#39;a&#39;, and remove row &#39;c&#39;, selection and focus should not change
1541         test_rt_16068(0, 2, 0);
1542     }
1543 
1544     @Test public void test_rt_16068_middleElement_selectAndRemoveSameRow() {
1545         // select and then remove the &#39;b&#39; item, selection and focus should both
1546         // move up one row to the &#39;a&#39; item
1547         test_rt_16068(1, 1, 0);
1548     }
1549 
1550     @Test public void test_rt_16068_middleElement_selectRowAndRemoveLaterSibling() {
1551         // select row &#39;b&#39;, and remove row &#39;c&#39;, selection and focus should not change
1552         test_rt_16068(1, 2, 1);
1553     }
1554 
1555     @Test public void test_rt_16068_middleElement_selectRowAndRemoveEarlierSibling() {
1556         // select row &#39;b&#39;, and remove row &#39;a&#39;, selection and focus should move up
1557         // one row, remaining on &#39;b&#39;
1558         test_rt_16068(1, 0, 0);
1559     }
1560 
1561     @Test public void test_rt_16068_lastElement_selectAndRemoveSameRow() {
1562         // select and then remove the &#39;d&#39; item, selection and focus should both
1563         // move up one row to the &#39;c&#39; item
1564         test_rt_16068(3, 3, 2);
1565     }
1566 
1567     @Test public void test_rt_16068_lastElement_selectRowAndRemoveEarlierSibling() {
1568         // select row &#39;d&#39;, and remove row &#39;a&#39;, selection and focus should move up
1569         // one row, remaining on &#39;d&#39;
1570         test_rt_16068(3, 0, 2);
1571     }
1572 
1573     private void test_rt_16068(int indexToSelect, int indexToRemove, int expectedIndex) {
1574         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1575         stringListView.getItems().addAll(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
1576 
1577         MultipleSelectionModel&lt;?&gt; sm = stringListView.getSelectionModel();
1578         FocusModel&lt;?&gt; fm = stringListView.getFocusModel();
1579 
1580         sm.select(indexToSelect);
1581         assertEquals(indexToSelect, sm.getSelectedIndex());
1582         assertEquals(stringListView.getItems().get(indexToSelect), sm.getSelectedItem());
1583         assertEquals(indexToSelect, fm.getFocusedIndex());
1584         assertEquals(stringListView.getItems().get(indexToSelect), fm.getFocusedItem());
1585 
1586         stringListView.getItems().remove(indexToRemove);
1587         assertEquals(expectedIndex, sm.getSelectedIndex());
1588         assertEquals(stringListView.getItems().get(expectedIndex), sm.getSelectedItem());
1589         assertEquals(expectedIndex, fm.getFocusedIndex());
1590         assertEquals(stringListView.getItems().get(expectedIndex), fm.getFocusedItem());
1591     }
1592 
1593     @Test public void test_rt_22599() {
1594         ObservableList&lt;RT22599_DataType&gt; initialData = FXCollections.observableArrayList(
1595                 new RT22599_DataType(1, &quot;row1&quot;),
1596                 new RT22599_DataType(2, &quot;row2&quot;),
1597                 new RT22599_DataType(3, &quot;row3&quot;)
1598         );
1599 
1600         ListView&lt;RT22599_DataType&gt; listView = new ListView&lt;&gt;();
1601         listView.setItems(initialData);
1602 
1603         StageLoader sl = new StageLoader(listView);
1604 
1605         // testing initial state
1606         assertNotNull(listView.getSkin());
1607         assertEquals(&quot;row1&quot;, VirtualFlowTestUtils.getCell(listView, 0).getText());
1608         assertEquals(&quot;row2&quot;, VirtualFlowTestUtils.getCell(listView, 1).getText());
1609         assertEquals(&quot;row3&quot;, VirtualFlowTestUtils.getCell(listView, 2).getText());
1610 
1611         // change row 0 (where &quot;row1&quot; currently resides), keeping same id.
1612         // Because &#39;set&#39; is called, the control should update to the new content
1613         // without any user interaction
1614         RT22599_DataType data;
1615         initialData.set(0, data = new RT22599_DataType(0, &quot;row1a&quot;));
1616         Toolkit.getToolkit().firePulse();
1617         assertEquals(&quot;row1a&quot;, VirtualFlowTestUtils.getCell(listView, 0).getText());
1618 
1619         // change the row 0 (where we currently have &quot;row1a&quot;) value directly.
1620         // Because there is no associated property, this won&#39;t be observed, so
1621         // the control should still show &quot;row1a&quot; rather than &quot;row1b&quot;
1622         data.text = &quot;row1b&quot;;
1623         Toolkit.getToolkit().firePulse();
1624         assertEquals(&quot;row1a&quot;, VirtualFlowTestUtils.getCell(listView, 0).getText());
1625 
1626         // call refresh() to force a refresh of all visible cells
1627         listView.refresh();
1628         Toolkit.getToolkit().firePulse();
1629         assertEquals(&quot;row1b&quot;, VirtualFlowTestUtils.getCell(listView, 0).getText());
1630 
1631         sl.dispose();
1632     }
1633 
1634     private static class RT22599_DataType {
1635         public int id = 0;
1636         public String text = &quot;&quot;;
1637 
1638         public RT22599_DataType(int id, String text) {
1639             this.id = id;
1640             this.text = text;
1641         }
1642 
1643         @Override public String toString() {
1644             return text;
1645         }
1646 
1647         @Override public boolean equals(Object obj) {
1648             if (obj == null) return false;
1649             return id == ((RT22599_DataType)obj).id;
1650         }
1651     }
1652 
1653     private int rt_39966_count = 0;
1654     @Test public void test_rt_39966() {
1655         ObservableList&lt;String&gt; list = FXCollections.observableArrayList(&quot;Hello World&quot;);
1656         ListView&lt;String&gt; listView = new ListView&lt;&gt;(list);
1657 
1658         StageLoader sl = new StageLoader(listView);
1659 
1660         // initially there is no selection
1661         assertTrue(listView.getSelectionModel().isEmpty());
1662 
1663         listView.getSelectionModel().selectedItemProperty().addListener((value, s1, s2) -&gt; {
1664             if (rt_39966_count == 0) {
1665                 rt_39966_count++;
1666                 assertFalse(listView.getSelectionModel().isEmpty());
1667             } else {
1668                 assertTrue(listView.getSelectionModel().isEmpty());
1669             }
1670         });
1671 
1672         // our assertion two lines down always succeeds. What fails is our
1673         // assertion above within the listener.
1674         listView.getSelectionModel().select(0);
1675         assertFalse(listView.getSelectionModel().isEmpty());
1676 
1677         list.remove(0);
1678         assertTrue(listView.getSelectionModel().isEmpty());
1679 
1680         sl.dispose();
1681     }
1682 
1683     /**
1684      * Bullet 1: selected index must be updated
1685      * Corner case: last selected. Fails for core
1686      */
1687     @Test public void test_rt_40012_selectedAtLastOnDisjointRemoveItemsAbove() {
1688         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);
1689         ListView&lt;String&gt; listView = new ListView&lt;&gt;(items);
1690         SelectionModel sm = listView.getSelectionModel();
1691 
1692         int last = items.size() - 1;
1693 
1694         // selecting item &quot;5&quot;
1695         sm.select(last);
1696 
1697         // disjoint remove of 2 elements above the last selected
1698         // Removing &quot;1&quot; and &quot;3&quot;
1699         items.removeAll(items.get(1), items.get(3));
1700 
1701         // selection should move up two places such that it remains on item &quot;5&quot;,
1702         // but in index (last - 2).
1703         int expected = last - 2;
1704         assertEquals(&quot;5&quot;, sm.getSelectedItem());
1705         assertEquals(&quot;selected index after disjoint removes above&quot;, expected, sm.getSelectedIndex());
1706     }
1707 
1708     /**
1709      * Variant of 1: if selectedIndex is not updated,
1710      * the old index is no longer valid
1711      * for accessing the items.
1712      */
1713     @Test public void test_rt_40012_accessSelectedAtLastOnDisjointRemoveItemsAbove() {
1714         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);
1715         ListView&lt;String&gt; listView = new ListView&lt;&gt;(items);
1716         SelectionModel sm = listView.getSelectionModel();
1717 
1718         int last = items.size() - 1;
1719 
1720         // selecting item &quot;5&quot;
1721         sm.select(last);
1722 
1723         // disjoint remove of 2 elements above the last selected
1724         items.removeAll(items.get(1), items.get(3));
1725         int selected = sm.getSelectedIndex();
1726         if (selected &gt; -1) {
1727             items.get(selected);
1728         }
1729     }
1730 
1731     /**
1732      * Bullet 2: selectedIndex notification count
1733      *
1734      * Note that we don&#39;t use the corner case of having the last index selected
1735      * (which fails already on updating the index)
1736      */
1737     private int rt_40012_count = 0;
1738     @Test public void test_rt_40012_selectedIndexNotificationOnDisjointRemovesAbove() {
1739         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);
1740         ListView&lt;String&gt; listView = new ListView&lt;&gt;(items);
1741         SelectionModel sm = listView.getSelectionModel();
1742 
1743         int last = items.size() - 2;
1744         sm.select(last);
1745         assertEquals(last, sm.getSelectedIndex());
1746 
1747         rt_40012_count = 0;
1748         sm.selectedIndexProperty().addListener(o -&gt; rt_40012_count++);
1749 
1750         // disjoint remove of 2 elements above the last selected
1751         items.removeAll(items.get(1), items.get(3));
1752         assertEquals(&quot;sanity: selectedIndex must be shifted by -2&quot;, last - 2, sm.getSelectedIndex());
1753         assertEquals(&quot;must fire single event on removes above&quot;, 1, rt_40012_count);
1754     }
1755 
1756     /**
1757      * Bullet 3: unchanged selectedItem must not fire change
1758      */
1759     @Test
1760     public void test_rt_40012_selectedItemNotificationOnDisjointRemovesAbove() {
1761         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);
1762         ListView&lt;String&gt; listView = new ListView&lt;&gt;(items);
1763         SelectionModel sm = listView.getSelectionModel();
1764 
1765         int last = items.size() - 2;
1766         Object lastItem = items.get(last);
1767         sm.select(last);
1768         assertEquals(lastItem, sm.getSelectedItem());
1769 
1770         rt_40012_count = 0;
1771         sm.selectedItemProperty().addListener(o -&gt; rt_40012_count++);
1772 
1773         // disjoint remove of 2 elements above the last selected
1774         items.removeAll(items.get(1), items.get(3));
1775         assertEquals(&quot;sanity: selectedItem unchanged&quot;, lastItem, sm.getSelectedItem());
1776         assertEquals(&quot;must not fire on unchanged selected item&quot;, 0, rt_40012_count);
1777     }
1778 
1779     @Test public void test_rt_40185() {
1780         final ListView&lt;String&gt; lv = new ListView&lt;&gt;();
1781         final ArrayList&lt;Integer&gt; expected = new ArrayList&lt;&gt;();
1782         Collections.addAll(expected, 1, 2);
1783 
1784         lv.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
1785         lv.getSelectionModel().getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) change -&gt; {
1786             while (change.next()) {
1787                 if (change.wasRemoved()) {
1788                     assertEquals(expected, change.getRemoved());
1789                 }
1790             }
1791         });
1792 
1793         lv.getItems().addAll(&quot;-0-&quot;,&quot;-1-&quot;,&quot;-2-&quot;);
1794         lv.getSelectionModel().selectIndices(1, 2);
1795         lv.getSelectionModel().clearSelection();
1796     }
1797 
1798     /**
1799      * ClearAndSelect fires invalid change event if selectedIndex is unchanged.
1800      */
1801     private int rt_40212_count = 0;
1802     @Test public void test_rt_40212() {
1803         final ListView&lt;Integer&gt; lv = new ListView&lt;&gt;();
1804         for (int i = 0; i &lt; 10; i++) {
1805             lv.getItems().add(i);
1806         }
1807 
1808         MultipleSelectionModel&lt;Integer&gt; sm = lv.getSelectionModel();
1809         sm.setSelectionMode(SelectionMode.MULTIPLE);
1810 
1811         sm.selectRange(3, 5);
1812         int selected = sm.getSelectedIndex();
1813 
1814         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) change -&gt; {
1815             assertEquals(&quot;sanity: selectedIndex unchanged&quot;, selected, sm.getSelectedIndex());
1816             while(change.next()) {
1817                 assertEquals(&quot;single event on clearAndSelect already selected&quot;, 1, ++rt_40212_count);
1818 
1819                 boolean type = change.wasAdded() || change.wasRemoved() || change.wasPermutated() || change.wasUpdated();
1820                 assertTrue(&quot;at least one of the change types must be true&quot;, type);
1821             }
1822         });
1823 
1824         sm.clearAndSelect(selected);
1825     }
1826 
1827     @Test public void test_rt_40280() {
1828         final ListView&lt;String&gt; view = new ListView&lt;&gt;();
1829         StageLoader sl = new StageLoader(view);
1830         view.getFocusModel().getFocusedIndex();
1831         sl.dispose();
1832     }
1833 
1834     /**
1835      * Test list change of selectedIndices on setIndices. Fails for core ..
1836      */
1837     @Test public void test_rt_40263() {
1838         final ListView&lt;Integer&gt; lv = new ListView&lt;&gt;();
1839         for (int i = 0; i &lt; 10; i++) {
1840             lv.getItems().add(i);
1841         }
1842 
1843         MultipleSelectionModel&lt;Integer&gt; sm = lv.getSelectionModel();
1844         sm.setSelectionMode(SelectionMode.MULTIPLE);
1845 
1846         int[] indices = new int[]{2, 5, 7};
1847         ListChangeListener&lt;Integer&gt; l = c -&gt; {
1848             // firstly, we expect only one change
1849             int subChanges = 0;
1850             while(c.next()) {
1851                 subChanges++;
1852             }
1853             assertEquals(1, subChanges);
1854 
1855             // secondly, we expect the added size to be three, as that is the
1856             // number of items selected
1857             c.reset();
1858             c.next();
1859             System.out.println(&quot;Added items: &quot; + c.getAddedSubList());
1860             assertEquals(indices.length, c.getAddedSize());
1861             assertArrayEquals(indices, c.getAddedSubList().stream().mapToInt(i -&gt; i).toArray());
1862         };
1863         sm.getSelectedIndices().addListener(l);
1864         sm.selectIndices(indices[0], indices);
1865     }
1866 
1867     @Test public void test_jdk8141124() {
1868         ListView&lt;String&gt; listView = new ListView&lt;&gt;();
1869         ObservableList&lt;String&gt; items = FXCollections.observableArrayList();
1870         SortedList&lt;String&gt; sortedItems = new SortedList&lt;&gt;(items);
1871         sortedItems.setComparator(String::compareTo);
1872         listView.setItems(sortedItems);
1873 
1874         MultipleSelectionModel&lt;String&gt; sm = listView.getSelectionModel();
1875 
1876         items.add(&quot;2&quot;);
1877         listView.getSelectionModel().selectFirst();
1878         assertEquals(&quot;2&quot;, sm.getSelectedItem());
1879         assertEquals(0, sm.getSelectedIndex());
1880         assertEquals(0, (int) sm.getSelectedIndices().get(0));
1881         assertEquals(&quot;2&quot;, sm.getSelectedItems().get(0));
1882 
1883         items.addAll(&quot;1&quot;, &quot;3&quot;);
1884         assertEquals(&quot;2&quot;, sm.getSelectedItem());
1885         assertEquals(1, sm.getSelectedIndex());
1886         assertEquals(1, (int) sm.getSelectedIndices().get(0));
1887         assertEquals(&quot;2&quot;, sm.getSelectedItems().get(0));
1888     }
1889 
1890     @Test public void test_jdk_8143594() {
1891         MultipleSelectionModel model = listView.getSelectionModel();
1892         model.setSelectionMode(SelectionMode.MULTIPLE);
1893 
1894         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, null);
1895 
1896         model.select(0);
1897         model.clearAndSelect(2);
1898         model.clearAndSelect(0);
1899         model.clearAndSelect(2);
1900     }
1901 
1902     @Test public void test_jdk_8145887_selectedIndices_ListIterator() {
1903         int selectIndices[] = { 4, 7, 9 };
1904         ListView&lt;Integer&gt; lv = new ListView&lt;&gt;();
1905         for (int i = 0; i &lt; 10; ++i) {
1906             lv.getItems().add(i);
1907         }
1908 
1909         MultipleSelectionModel msm = lv.getSelectionModel();
1910         msm.setSelectionMode(SelectionMode.MULTIPLE);
1911         for (int i = 0 ; i &lt; selectIndices.length; ++i) {
1912             msm.select(selectIndices[i]);
1913         }
1914 
1915         ListIterator iter = lv.getSelectionModel().getSelectedIndices().listIterator();
1916 
1917         // Step 1. Initial values
1918         assertEquals(0, iter.nextIndex());
1919         assertEquals(-1, iter.previousIndex());
1920         assertEquals(true, iter.hasNext());
1921         assertEquals(false, iter.hasPrevious());
1922 
1923         // Step 2. Iterate forward.
1924         assertEquals(4, iter.next());
1925         assertEquals(1, iter.nextIndex());
1926         assertEquals(0, iter.previousIndex());
1927         assertEquals(true, iter.hasNext());
1928         assertEquals(true, iter.hasPrevious());
1929 
1930         // Step 3. Iterate forward.
1931         // Values would be at similar state of Step 2.
1932         assertEquals(7, iter.next());
1933 
1934         // Step 4. Iterate forward to Last element.
1935         assertEquals(9, iter.next());
1936         assertEquals(3, iter.nextIndex());
1937         assertEquals(2, iter.previousIndex());
1938         assertEquals(false, iter.hasNext());
1939         assertEquals(true, iter.hasPrevious());
1940 
1941         // Step 5. Verify NoSuchElementException by next()
1942         try {
1943             iter.next();
1944         } catch (Exception e) {
1945             assert(e instanceof NoSuchElementException);
1946         }
1947 
1948         // Step 6. Iterate backward to Last element.
1949         assertEquals(9, iter.previous());
1950         assertEquals(2, iter.nextIndex());
1951         assertEquals(1, iter.previousIndex());
1952         assertEquals(true, iter.hasNext());
1953         assertEquals(true, iter.hasPrevious());
1954 
1955         // Step 7. Iterate forward to Last element.
1956         assertEquals(9, iter.next());
1957         assertEquals(3, iter.nextIndex());
1958         assertEquals(2, iter.previousIndex());
1959         assertEquals(false, iter.hasNext());
1960         assertEquals(true, iter.hasPrevious());
1961 
1962         // Step 8. Iterate forward to last element.
1963         // Values would be at Same state of Step 2.
1964         assertEquals(9, iter.previous());
1965 
1966         // Step 9. Iterate backward.
1967         assertEquals(7, iter.previous());
1968         assertEquals(1, iter.nextIndex());
1969         assertEquals(0, iter.previousIndex());
1970         assertEquals(true, iter.hasNext());
1971         assertEquals(true, iter.hasPrevious());
1972 
1973         // Step 10. Iterate back to first element.
1974         assertEquals(4, iter.previous());
1975         assertEquals(0, iter.nextIndex());
1976         assertEquals(-1, iter.previousIndex());
1977         assertEquals(true, iter.hasNext());
1978         assertEquals(false, iter.hasPrevious());
1979 
1980         // Step 11. Verify NoSuchElementException by previous()
1981         try {
1982             iter.previous();
1983         } catch (Exception e) {
1984             assert(e instanceof NoSuchElementException);
1985         }
1986     }
1987 
1988     @Test public void testListEditStartOnCellStandalone_JDK8187432() {
1989         ListView&lt;String&gt; control = new ListView&lt;&gt;(FXCollections
1990                 .observableArrayList(&quot;Item1&quot;, &quot;Item2&quot;, &quot;Item3&quot;, &quot;Item4&quot;));
1991         control.setEditable(true);
1992         control.setCellFactory(TextFieldListCell.forListView());
1993         StageLoader sl = new StageLoader(control);
1994         int editIndex = 2;
1995 
1996         IndexedCell cell = VirtualFlowTestUtils.getCell(control, editIndex);
1997         ObjectProperty&lt;ListView.EditEvent&gt; editEvent = new SimpleObjectProperty&lt;&gt;();
1998         control.addEventHandler(ListView.editStartEvent(), e -&gt; editEvent.set(e));
1999 
2000         // start edit on cell
2001         cell.startEdit();
2002 
2003         // test cell state
2004         assertTrue(cell.isEditing());
2005         assertEquals(editIndex, cell.getIndex());
2006 
2007         // test editEvent
2008         assertNotNull(editEvent.get());
2009         assertEquals(&quot;type is startEdit&quot;,
2010                      ListView.editStartEvent(), editEvent.get().getEventType());
2011         assertEquals(&quot;index on start event&quot;,
2012                      editIndex, editEvent.get().getIndex());
2013 
2014         sl.dispose();
2015     }
2016 
2017     @Test
2018     public void testEventIndicesOnSelectRange() {
2019         ObservableList&lt;String&gt; listItems = FXCollections.observableArrayList(&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;);
2020         final ListView&lt;String&gt; lv = new ListView&lt;&gt;();
2021         lv.setItems(listItems);
2022         MultipleSelectionModel&lt;String&gt; sm = lv.getSelectionModel();
2023 
2024         int selected = 1;
2025         sm.setSelectionMode(SelectionMode.MULTIPLE);
2026         sm.select(selected);
2027         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) ch -&gt; {
2028             if (ch.next()) {
2029                 assertEquals(&quot;Two items should be selected.&quot;, 2, ch.getList().size());
2030                 assertEquals(&quot;Selection range should be from index 1 &quot;, 1, ch.getFrom());
2031                 assertEquals(&quot;Selection range should be till index 2 &quot;, 2, ch.getTo());
2032             } else {
2033                 fail(&quot;Change event is expected when selection is changed.&quot;);
2034             }
2035         });
2036         int focus = lv.getFocusModel().getFocusedIndex();
2037         assertEquals(&quot;Selected item should be focused.&quot;, selected, focus);
2038         // Select the next element
2039         sm.selectRange(selected, focus + 2);
2040         assertEquals(&quot;Two items should be selected.&quot;, 2, sm.getSelectedIndices().size());
2041         assertEquals(&quot;List item at index 1 should be selected&quot;, 1, (int) sm.getSelectedIndices().get(0));
2042         assertEquals(&quot;List item at index 2 should be selected&quot;, 2, (int) sm.getSelectedIndices().get(1));
2043     }
2044 
2045     @Test
2046     public void testListViewLeak() {
2047         ObservableList&lt;String&gt; items = FXCollections.observableArrayList();
2048         WeakReference&lt;ListView&lt;String&gt;&gt; listViewRef = new WeakReference&lt;&gt;(new ListView&lt;&gt;(items));
2049         attemptGC(listViewRef, 10);
2050         assertNull(&quot;ListView is not GCed.&quot;, listViewRef.get());
2051     }
2052 
2053     @Test
2054     public void testItemLeak() {
2055         WeakReference&lt;String&gt; itemRef = new WeakReference&lt;&gt;(new String(&quot;Leak Item&quot;));
2056         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(itemRef.get());
2057         ListView&lt;String&gt; listView = new ListView&lt;&gt;(items);
2058         items.clear();
2059         attemptGC(itemRef, 10);
2060         assertNull(&quot;ListView item is not GCed.&quot;, itemRef.get());
2061     }
2062 
2063     private void attemptGC(WeakReference&lt;? extends Object&gt; weakRef, int n) {
2064         for (int i = 0; i &lt; n; i++) {
2065             System.gc();
2066             System.runFinalization();
2067 
2068             if (weakRef.get() == null) {
2069                 break;
2070             }
2071             try {
2072                 Thread.sleep(50);
2073             } catch (InterruptedException e) {
2074                 fail(&quot;InterruptedException occurred during Thread.sleep()&quot;);
2075             }
2076         }
2077     }
2078 }
    </pre>
  </body>
</html>