<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/java/com/sun/javafx/webkit/prism/WCGraphicsPrismContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.javafx.webkit.prism;
  27 
  28 import com.sun.glass.ui.Screen;
  29 import com.sun.javafx.font.FontStrike;
  30 import com.sun.javafx.font.Metrics;
  31 import com.sun.javafx.font.PGFont;
  32 import com.sun.javafx.geom.*;
  33 import com.sun.javafx.geom.transform.Affine2D;
  34 import com.sun.javafx.geom.transform.Affine3D;
  35 import com.sun.javafx.geom.transform.BaseTransform;
  36 import com.sun.javafx.geom.transform.GeneralTransform3D;
  37 import com.sun.javafx.logging.PlatformLogger;
  38 import com.sun.javafx.logging.PlatformLogger.Level;
  39 import com.sun.javafx.scene.text.GlyphList;
  40 import com.sun.javafx.scene.text.TextLayout;
  41 import com.sun.javafx.sg.prism.*;
  42 import com.sun.javafx.text.TextRun;
  43 import com.sun.prism.*;
  44 import com.sun.prism.paint.Color;
  45 import com.sun.prism.paint.Gradient;
  46 import com.sun.prism.paint.ImagePattern;
  47 import com.sun.prism.paint.Paint;
  48 import com.sun.scenario.effect.*;
  49 import com.sun.scenario.effect.impl.prism.PrDrawable;
  50 import com.sun.scenario.effect.impl.prism.PrEffectHelper;
  51 import com.sun.scenario.effect.impl.prism.PrFilterContext;
  52 import com.sun.webkit.graphics.*;
  53 
  54 import java.nio.ByteBuffer;
  55 import java.nio.ByteOrder;
  56 import java.security.AccessController;
  57 import java.security.PrivilegedAction;
  58 import java.util.ArrayList;
  59 import java.util.List;
  60 
  61 import static com.sun.scenario.effect.Blend.Mode.*;
  62 import com.sun.scenario.effect.impl.Renderer;
  63 import com.sun.scenario.effect.impl.prism.PrRenderer;
  64 
  65 class WCGraphicsPrismContext extends WCGraphicsContext {
  66 
  67     public enum Type {
  68         /**
  69          * Base context associated with the topmost page buffer.
  70          * Created and disposed during a single render pass.
  71          */
  72         PRIMARY,
  73 
  74         /**
  75          * A context associated with a dedicated buffer representing
  76          * a separate render target like canvas, buffered image etc.
  77          * Its life cycle is not limited to a single render pass.
  78          */
  79         DEDICATED
  80     }
  81 
  82     private final static PlatformLogger log =
  83             PlatformLogger.getLogger(WCGraphicsPrismContext.class.getName());
  84     private final static boolean DEBUG_DRAW_CLIP_SHAPE = Boolean.valueOf(
  85             AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt;
  86             System.getProperty(&quot;com.sun.webkit.debugDrawClipShape&quot;, &quot;false&quot;)));
  87 
  88     Graphics baseGraphics;
  89     private BaseTransform baseTransform;
  90 
  91     private final List&lt;ContextState&gt; states = new ArrayList&lt;ContextState&gt;();
  92 
  93     private ContextState state = new ContextState();
  94 
  95     // Cache for getPlatformGraphics
  96     private Graphics cachedGraphics = null;
  97 
  98     private int fontSmoothingType;
  99     private boolean isRootLayerValid = false;
 100 
 101     WCGraphicsPrismContext(Graphics g) {
 102         state.setClip(g.getClipRect());
 103         state.setAlpha(g.getExtraAlpha());
 104         baseGraphics = g;
 105         initBaseTransform(g.getTransformNoClone());
 106     }
 107 
 108     WCGraphicsPrismContext() {
 109     }
 110 
 111     public Type type() {
 112         return Type.PRIMARY;
 113     }
 114 
 115     final void initBaseTransform(BaseTransform t) {
 116         baseTransform = new Affine3D(t);
 117         state.setTransform((Affine3D)baseTransform);
 118     }
 119 
 120     private void resetCachedGraphics() {
 121         cachedGraphics = null;
 122     }
 123 
 124     @Override
 125     public Object getPlatformGraphics() {
 126         return getGraphics(false);
 127     }
 128 
 129     Graphics getGraphics(boolean checkClip) {
 130         if (cachedGraphics == null) {
 131             Layer l = state.getLayerNoClone();
 132             cachedGraphics = (l != null)
 133                     ? l.getGraphics()
 134                     : baseGraphics;
 135 
 136             state.apply(cachedGraphics);
 137 
 138             if (log.isLoggable(Level.FINE)) {
 139                 log.fine(&quot;getPlatformGraphics for &quot; + this + &quot; : &quot; +
 140                          cachedGraphics);
 141             }
 142         }
 143 
 144         Rectangle clip = cachedGraphics.getClipRectNoClone();
 145         return (checkClip &amp;&amp; clip!=null &amp;&amp; clip.isEmpty())
 146             ? null
 147             : cachedGraphics;
 148     }
 149 
 150     public void saveState()
 151     {
 152         state.markAsRestorePoint();
 153         saveStateInternal();
 154     }
 155 
 156     private void saveStateInternal()
 157     {
 158         states.add(state);
 159         state = state.clone();
 160     }
 161 
 162     private void startNewLayer(Layer layer) {
 163         saveStateInternal();
 164 
 165         // layer has the same bounds as clip, so we have to translate
 166         Rectangle clip = state.getClipNoClone();
 167 
 168         //left-side (post-) translate.
 169         //NB! an order of transforms is essential!
 170         Affine3D newTr = new Affine3D(BaseTransform.getTranslateInstance(
 171                 -clip.x,
 172                 -clip.y));
 173         newTr.concatenate(state.getTransformNoClone());
 174 
 175         //move clip to (0, 0) - start of texture
 176         clip.x = 0;
 177         clip.y = 0;
 178         //no-clone - no-set!
 179 
 180         Graphics g = getGraphics(true);
 181         if (g != null &amp;&amp; g != baseGraphics) {
 182             layer.init(g);
 183         }
 184 
 185         state.setTransform(newTr);
 186         state.setLayer(layer);
 187 
 188         resetCachedGraphics();
 189     }
 190 
 191     private void renderLayer(final Layer layer) {
 192         WCTransform cur = getTransform();
 193 
 194         //translate to (layer.getX(), layer.getY())
 195         setTransform(new WCTransform(
 196             1.0, 0.0,
 197             0.0, 1.0,
 198             layer.getX(), layer.getY()));
 199 
 200         // composite drawing delegated to the layer rendering
 201         Graphics g = getGraphics(true);
 202         if (g != null) {
 203             layer.render(g);
 204         }
 205 
 206         //restore transform
 207         setTransform(cur);
 208     }
 209 
 210     private void restoreStateInternal() {
 211         int size = states.size();
 212         if (size == 0) {
 213             assert false: &quot;Unbalanced restoreState&quot;;
 214             return;
 215         }
 216 
 217         Layer layer = state.getLayerNoClone();
 218         state = states.remove(size - 1);
 219         if (layer != state.getLayerNoClone()) {
 220             renderLayer(layer);
 221             layer.dispose();
 222             if (log.isLoggable(Level.FINE)) {
 223                 log.fine(&quot;Popped layer &quot; + layer);
 224             }
 225         } else {
 226             resetCachedGraphics();
 227         }
 228     }
 229 
 230     public void restoreState()
 231     {
 232         log.fine(&quot;restoring state&quot;);
 233         do {
 234             restoreStateInternal();
 235         } while ( !state.isRestorePoint() );
 236     }
 237 
 238     /**
 239      *  Renders all layers to the underlaying Graphics, but preserves the
 240      *  current state and the states stack
 241      */
 242     private void flushAllLayers() {
 243         if (state == null) {
 244             // context disposed
 245             return;
 246         }
 247 
 248         if (isRootLayerValid) {
 249             log.fine(&quot;FlushAllLayers: root layer is valid, skipping&quot;);
 250             return;
 251         }
 252 
 253         if (log.isLoggable(Level.FINE)) {
 254             log.fine(&quot;FlushAllLayers&quot;);
 255         }
 256 
 257         ContextState currentState = state;
 258 
 259         for (int i = states.size() - 1; i &gt;=0; i--) {
 260             Layer layer = state.getLayerNoClone();
 261             state = states.get(i);
 262             if (layer != state.getLayerNoClone()) {
 263                 renderLayer(layer);
 264             } else {
 265                 resetCachedGraphics();
 266             }
 267         }
 268 
 269         Layer layer = state.getLayerNoClone();
 270         if (layer != null) {
 271             renderLayer(layer);
 272         }
 273 
 274         state = currentState;
 275         isRootLayerValid = true;
 276     }
 277 
 278 
 279     public void dispose() {
 280         if (!states.isEmpty()) {
 281             log.fine(&quot;Unbalanced saveState/restoreState&quot;);
 282         }
 283         for (ContextState state: states) {
 284             if (state.getLayerNoClone() != null) {
 285                 state.getLayerNoClone().dispose();
 286             }
 287         }
 288         states.clear();
 289 
 290         if (state != null &amp;&amp; state.getLayerNoClone() != null) {
 291             state.getLayerNoClone().dispose();
 292         }
 293         state = null;
 294     }
 295 
 296 
 297     public void setClip(WCPath path, boolean isOut) {
 298         Affine3D tr = new Affine3D(state.getTransformNoClone());
 299         path.transform(
 300                 tr.getMxx(), tr.getMyx(),
 301                 tr.getMxy(), tr.getMyy(),
 302                 tr.getMxt(), tr.getMyt());
 303         //path now is in node coordinates, as well as clip
 304 
 305         if (!isOut) {
 306             WCRectangle pathBounds = path.getBounds();
 307 
 308             // path bounds could be fractional so &#39;inclusive&#39; rounding
 309             // is used for determining clip rectangle
 310             int pixelX = (int) Math.floor(pathBounds.getX());
 311             int pixelY = (int) Math.floor(pathBounds.getY());
 312             int pixelW = (int) Math.ceil(pathBounds.getMaxX()) - pixelX;
 313             int pixelH = (int) Math.ceil(pathBounds.getMaxY()) - pixelY;
 314 
 315             state.clip(new Rectangle(pixelX, pixelY, pixelW, pixelH));
 316         }
 317 
 318         Rectangle clip = state.getClipNoClone();
 319 
 320         if (isOut) {
 321             path.addRect(clip.x, clip.y, clip.width, clip.height);
 322             //Out clip path is always EVENODD.
 323         }
 324 
 325         path.translate(-clip.x, -clip.y);
 326 
 327         Layer layer = new ClipLayer(
 328             getGraphics(false), clip, path, type() == Type.DEDICATED);
 329 
 330         startNewLayer(layer);
 331 
 332         if (log.isLoggable(Level.FINE)) {
 333             log.fine(&quot;setClip(WCPath &quot; + path.getID() + &quot;)&quot;);
 334             log.fine(&quot;Pushed layer &quot; + layer);
 335         }
 336     }
 337 
 338     private Rectangle transformClip(Rectangle localClip) {
 339         if (localClip==null) {
 340             return null;
 341         }
 342 
 343         float[] points = new float[] {
 344             localClip.x, localClip.y,
 345             localClip.x + localClip.width, localClip.y,
 346             localClip.x, localClip.y + localClip.height,
 347             localClip.x  + localClip.width, localClip.y + localClip.height};
 348         state.getTransformNoClone().transform(points, 0, points, 0, 4);
 349         float minX = Math.min(
 350                points[0], Math.min(
 351                points[2], Math.min(
 352                points[4], points[6])));
 353         float maxX = Math.max(
 354                points[0], Math.max(
 355                points[2], Math.max(
 356                points[4], points[6])));
 357         float minY = Math.min(
 358                points[1], Math.min(
 359                points[3], Math.min(
 360                points[5], points[7])));
 361         float maxY = Math.max(
 362                points[1], Math.max(
 363                points[3], Math.max(
 364                points[5], points[7])));
 365         return new Rectangle(new RectBounds(minX, minY, maxX, maxY));
 366 
 367 /* #1 loose rotate
 368         state.getTransformNoClone().transform(localClip, localClip);
 369 */
 370 /* #2 problem with negative coordinates
 371         RectBounds rb = TransformedShape.transformedShape(
 372             new RoundRectangle2D(localClip.x, localClip.y, localClip.width, localClip.height, 0, 0),
 373             state.getTransformNoClone()).getBounds();
 374         return rb.isEmpty()
 375             ? null
 376             : new Rectangle(rb);
 377  */
 378     }
 379 
 380     private void setClip(Rectangle shape) {
 381         Affine3D tr = state.getTransformNoClone();
 382         if (tr.getMxy() == 0 &amp;&amp; tr.getMxz() == 0
 383          &amp;&amp; tr.getMyx() == 0 &amp;&amp; tr.getMyz() == 0
 384          &amp;&amp; tr.getMzx() == 0 &amp;&amp; tr.getMzy() == 0) {
 385             //There is no rotation here: scale + translation.
 386             //Fast &amp; easy!
 387             state.clip(transformClip(shape));
 388             if (log.isLoggable(Level.FINE)) {
 389                 log.fine(&quot;setClip({0})&quot;, shape);
 390             }
 391             if (DEBUG_DRAW_CLIP_SHAPE) {
 392                 //Draw clip shape
 393                 Rectangle rc = state.getClipNoClone();
 394                 if (rc != null &amp;&amp; rc.width &gt;= 2 &amp;&amp; rc.height &gt;= 2) {
 395                     WCTransform cur = getTransform();
 396                     //translate to (layer.getX(), layer.getY())
 397                     setTransform(new WCTransform(
 398                         1.0, 0.0,
 399                         0.0, 1.0,
 400                         0.0, 0.0));
 401 
 402                     Graphics g2d = getGraphics(true);
 403                     if (g2d != null) {
 404                         float fbase = (float)Math.random();
 405                         g2d.setPaint(new Color(
 406                                 fbase,
 407                                 1f - fbase,
 408                                 0.5f,
 409                                 0.1f));
 410                         g2d.setStroke(new BasicStroke());
 411                         g2d.fillRect(rc.x, rc.y, rc.width, rc.height);
 412 
 413                         g2d.setPaint(new Color(
 414                                 1f - fbase,
 415                                 fbase,
 416                                 0.5f,
 417                                 1f));
 418                         g2d.drawRect(rc.x, rc.y, rc.width, rc.height);
 419                     }
 420                     //restore transform
 421                     setTransform(cur);
 422                     state.clip(new Rectangle(rc.x+1, rc.y+1, rc.width-2, rc.height-2));
 423                 }
 424             }
 425             if (cachedGraphics != null) {
 426                 cachedGraphics.setClipRect(state.getClipNoClone());
 427             }
 428         } else {
 429             //twisted axis set
 430             WCPath path = new WCPathImpl();
 431             path.addRect(shape.x, shape.y, shape.width, shape.height);
 432             setClip(path, false);
 433         }
 434     }
 435 
 436     public void setClip(int cx, int cy, int cw, int ch) {
 437         setClip(new Rectangle(cx, cy, cw, ch));
 438     }
 439 
 440     public void setClip(WCRectangle c) {
 441         setClip(new Rectangle((int)c.getX(), (int)c.getY(),
 442                               (int)c.getWidth(), (int)c.getHeight()));
 443     }
 444 
<a name="1" id="anc1"></a><span class="line-added"> 445     public void setClip(int cx, int cy, int cw, int ch, WCImage maskImage) {</span>
<span class="line-added"> 446         setClip(new Rectangle(cx, cy, cw, ch));</span>
<span class="line-added"> 447         state.setClipMaskImage(maskImage);</span>
<span class="line-added"> 448     }</span>
<span class="line-added"> 449 </span>
 450     public WCRectangle getClip() {
 451         Rectangle r = state.getClipNoClone();
 452         return r == null ? null : new WCRectangle(r.x, r.y, r.width, r.height);
 453     }
 454 
 455     protected Rectangle getClipRectNoClone() {
 456         return state.getClipNoClone();
 457     }
 458 
 459     protected Affine3D getTransformNoClone() {
 460         return state.getTransformNoClone();
 461     }
 462 
 463     public void translate(float x, float y) {
 464         if (log.isLoggable(Level.FINE)) {
 465             log.fine(&quot;translate({0},{1})&quot;, new Object[] {x, y});
 466         }
 467         state.translate(x, y);
 468         if (cachedGraphics != null) {
 469             cachedGraphics.translate(x, y);
 470         }
 471     }
 472 
 473     public void scale(float sx, float sy) {
 474         if (log.isLoggable(Level.FINE)) {
 475             log.fine(&quot;scale(&quot; + sx + &quot; &quot; + sy + &quot;)&quot;);
 476         }
 477         state.scale(sx, sy);
 478         if (cachedGraphics != null) {
 479             cachedGraphics.scale(sx, sy);
 480         }
 481     }
 482 
 483     public void rotate(float radians) {
 484         if (log.isLoggable(Level.FINE)) {
 485             log.fine(&quot;rotate(&quot; + radians + &quot;)&quot;);
 486         }
 487         state.rotate(radians);
 488         if (cachedGraphics != null) {
 489             cachedGraphics.setTransform(state.getTransformNoClone());
 490         }
 491     }
 492 
 493     // overriden in WCBufferedContext
 494     protected boolean shouldRenderRect(float x, float y, float w, float h,
 495                                        DropShadow shadow, BasicStroke stroke)
 496     {
 497         return true;
 498     }
 499 
 500     // overriden in WCBufferedContext
 501     protected boolean shouldRenderShape(Shape shape, DropShadow shadow, BasicStroke stroke) {
 502         return true;
 503     }
 504 
 505     // overriden in WCBufferedContext
 506     protected boolean shouldCalculateIntersection() {
 507         return false;
 508     }
 509 
 510     @Override
 511     public void fillRect(final float x, final float y, final float w, final float h, final Integer rgba) {
 512         if (log.isLoggable(Level.FINE)) {
 513             String format = (rgba != null)
 514                     ? &quot;fillRect(%f, %f, %f, %f, 0x%x)&quot;
 515                     : &quot;fillRect(%f, %f, %f, %f, null)&quot;;
 516             log.fine(String.format(format, x, y, w, h, rgba));
 517         }
 518         if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
 519             return;
 520         }
 521         new Composite() {
 522             @Override void doPaint(Graphics g) {
 523                 Paint paint = (rgba != null) ? createColor(rgba) : state.getPaintNoClone();
 524                 DropShadow shadow = state.getShadowNoClone();
 525                 // TextureMapperJava::drawSolidColor calls fillRect with perspective
 526                 // projection.
 527                 if (shadow != null || !state.getPerspectiveTransformNoClone().isIdentity()) {
 528                     final NGRectangle node = new NGRectangle();
 529                     node.updateRectangle(x, y, w, h, 0, 0);
 530                     render(g, shadow, paint, null, node);
<a name="2" id="anc2"></a><span class="line-added"> 531                 } else if (state.getClipMaskImageNoClone() != null) {</span>
<span class="line-added"> 532                     Rectangle clipRectangle = getClipRectNoClone();</span>
<span class="line-added"> 533                     RTTexture paintRtTexture = g.getResourceFactory().createRTTexture(</span>
<span class="line-added"> 534                             clipRectangle.width, clipRectangle.height, Texture.WrapMode.CLAMP_NOT_NEEDED);</span>
<span class="line-added"> 535                     Graphics g1 = paintRtTexture.createGraphics();</span>
<span class="line-added"> 536                     g1.setPaint(paint);</span>
<span class="line-added"> 537                     g1.fillRect(0, 0, clipRectangle.width, clipRectangle.height);</span>
<span class="line-added"> 538 </span>
<span class="line-added"> 539                     RTImage maskImage = (RTImage) (state.getClipMaskImageNoClone());</span>
<span class="line-added"> 540                     Image nativeMaskImage = Image.fromByteBgraPreData(maskImage.getPixelBuffer(), maskImage.getWidth(),</span>
<span class="line-added"> 541                             maskImage.getHeight(), 0, maskImage.getPixelScale());</span>
<span class="line-added"> 542                     Texture maskTexture = g.getResourceFactory().createTexture(PixelFormat.BYTE_BGRA_PRE,</span>
<span class="line-added"> 543                             Texture.Usage.STATIC, Texture.WrapMode.CLAMP_NOT_NEEDED,</span>
<span class="line-added"> 544                             nativeMaskImage.getWidth(), nativeMaskImage.getHeight());</span>
<span class="line-added"> 545                     maskTexture.update(nativeMaskImage, 0, 0, nativeMaskImage.getWidth(),</span>
<span class="line-added"> 546                             nativeMaskImage.getHeight());</span>
<span class="line-added"> 547                     RTTexture maskRtTexture = g.getResourceFactory().createRTTexture(clipRectangle.width,</span>
<span class="line-added"> 548                             clipRectangle.height, Texture.WrapMode.CLAMP_NOT_NEEDED);</span>
<span class="line-added"> 549                     Graphics g2 = maskRtTexture.createGraphics();</span>
<span class="line-added"> 550                     g2.drawTexture(maskTexture, 0, 0, clipRectangle.width, clipRectangle.height,</span>
<span class="line-added"> 551                             0, 0, nativeMaskImage.getWidth(), nativeMaskImage.getHeight());</span>
<span class="line-added"> 552                     maskTexture.dispose();</span>
<span class="line-added"> 553                     FilterContext filterContext = getFilterContext(g);</span>
<span class="line-added"> 554                     PrDrawable imagePrDrawable = PrDrawable.create(filterContext, paintRtTexture);</span>
<span class="line-added"> 555                     PrDrawable maskPrDrawable = PrDrawable.create(filterContext, maskRtTexture);</span>
<span class="line-added"> 556                     Blend blend = new Blend(Blend.Mode.SRC_IN,</span>
<span class="line-added"> 557                             new PassThrough(maskPrDrawable, nativeMaskImage.getWidth(), nativeMaskImage.getHeight()),</span>
<span class="line-added"> 558                             new PassThrough(imagePrDrawable, clipRectangle.width, clipRectangle.height));</span>
<span class="line-added"> 559                     Affine3D tx = new Affine3D(g.getTransformNoClone());</span>
<span class="line-added"> 560                     g.setTransform(BaseTransform.IDENTITY_TRANSFORM);</span>
<span class="line-added"> 561                     PrEffectHelper.render(blend, g, clipRectangle.x, clipRectangle.y, null);</span>
<span class="line-added"> 562                     g.setTransform(tx);</span>
<span class="line-added"> 563                     paintRtTexture.dispose();</span>
<span class="line-added"> 564                     maskRtTexture.dispose();</span>
 565                 } else {
 566                     g.setPaint(paint);
 567                     g.fillRect(x, y, w, h);
 568                 }
 569             }
 570         }.paint();
 571     }
 572 
 573     @Override
 574     public void fillRoundedRect(final float x, final float y, final float w, final float h,
 575         final float topLeftW, final float topLeftH, final float topRightW, final float topRightH,
 576         final float bottomLeftW, final float bottomLeftH, final float bottomRightW, final float bottomRightH,
 577         final int rgba)
 578     {
 579         if (log.isLoggable(Level.FINE)) {
 580             log.fine(String.format(&quot;fillRoundedRect(%f, %f, %f, %f, &quot;
 581                     + &quot;%f, %f, %f, %f, %f, %f, %f, %f, 0x%x)&quot;,
 582                     x, y, w, h, topLeftW, topLeftH, topRightW, topRightH,
 583                     bottomLeftW, bottomLeftH, bottomRightW, bottomRightH, rgba));
 584         }
 585         if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
 586             return;
 587         }
 588         new Composite() {
 589             @Override void doPaint(Graphics g) {
 590                 // Prism only supports single arcWidth/Height.
 591                 // We work around by calculating average width and height here
 592 
 593                 float arcW = (topLeftW + topRightW + bottomLeftW + bottomRightW) / 2;
 594                 float arcH = (topLeftH + topRightH + bottomLeftH + bottomRightH) / 2;
 595 
 596                 Paint paint = createColor(rgba);
 597                 DropShadow shadow = state.getShadowNoClone();
 598                 if (shadow != null) {
 599                     final NGRectangle node = new NGRectangle();
 600                     node.updateRectangle(x, y, w, h, arcW, arcH);
 601                     render(g, shadow, paint, null, node);
 602                 } else {
 603                     g.setPaint(paint);
 604                     g.fillRoundRect(x, y, w, h, arcW, arcH);
 605                 }
 606             }
 607         }.paint();
 608     }
 609 
 610     @Override
 611     public void clearRect(final float x, final float y, final float w, final float h) {
 612         if (log.isLoggable(Level.FINE)) {
 613             log.fine(String.format(&quot;clearRect(%f, %f, %f, %f)&quot;, x, y, w, h));
 614         }
 615         if (shouldCalculateIntersection()) {
 616             // No intersection is applicable for clearRect.
 617             return;
 618         }
 619         new Composite() {
 620             @Override void doPaint(Graphics g) {
 621                 g.clearQuad(x, y, x + w, y + h);
 622             }
 623         }.paint();
 624     }
 625 
 626     @Override
 627     public void setFillColor(int rgba) {
 628         if (log.isLoggable(Level.FINE)) {
 629             log.fine(String.format(&quot;setFillColor(0x%x)&quot;, rgba));
 630         }
 631         state.setPaint(createColor(rgba));
 632     }
 633 
 634     @Override
 635     public void setFillGradient(WCGradient gradient) {
 636         if (log.isLoggable(Level.FINE)) {
 637             log.fine(&quot;setFillGradient(&quot; + gradient + &quot;)&quot;);
 638         }
 639         state.setPaint((Gradient) gradient.getPlatformGradient());
 640     }
 641 
 642     @Override
 643     public void setTextMode(boolean fill, boolean stroke, boolean clip) {
 644         if (log.isLoggable(Level.FINE)) {
 645             log.fine(&quot;setTextMode(fill:&quot; + fill + &quot;,stroke:&quot; + stroke + &quot;,clip:&quot; + clip + &quot;)&quot;);
 646         }
 647         state.setTextMode(fill, stroke, clip);
 648     }
 649 
 650     @Override
 651     public void setFontSmoothingType(int fontSmoothingType) {
 652         this.fontSmoothingType = fontSmoothingType;
 653     }
 654 
 655     @Override
 656     public int getFontSmoothingType() {
 657         return fontSmoothingType;
 658     }
 659 
 660     @Override
 661     public void setStrokeStyle(int style) {
 662         if (log.isLoggable(Level.FINE)) {
 663             log.fine(&quot;setStrokeStyle({0})&quot;, style);
 664         }
 665         state.getStrokeNoClone().setStyle(style);
 666     }
 667 
 668     @Override
 669     public void setStrokeColor(int rgba) {
 670         if (log.isLoggable(Level.FINE)) {
 671             log.fine(String.format(&quot;setStrokeColor(0x%x)&quot;, rgba));
 672         }
 673         state.getStrokeNoClone().setPaint(createColor(rgba));
 674     }
 675 
 676     @Override
 677     public void setStrokeWidth(float width) {
 678         if (log.isLoggable(Level.FINE)) {
 679             log.fine(&quot;setStrokeWidth({0})&quot;, new Object[] { width });
 680         }
 681         state.getStrokeNoClone().setThickness(width);
 682     }
 683 
 684     @Override
 685     public void setStrokeGradient(WCGradient gradient) {
 686         if (log.isLoggable(Level.FINE)) {
 687             log.fine(&quot;setStrokeGradient(&quot; + gradient + &quot;)&quot;);
 688         }
 689         state.getStrokeNoClone().setPaint((Gradient) gradient.getPlatformGradient());
 690     }
 691 
 692     @Override
 693     public void setLineDash(float offset, float... sizes) {
 694         if (log.isLoggable(Level.FINE)) {
 695             StringBuilder s = new StringBuilder(&quot;[&quot;);
 696             for (int i=0; i &lt; sizes.length; i++) {
 697                 s.append(sizes[i]).append(&#39;,&#39;);
 698             }
 699             s.append(&#39;]&#39;);
 700             log.fine(&quot;setLineDash({0},{1}&quot;, new Object[] {offset, s});
 701         }
 702         state.getStrokeNoClone().setDashOffset(offset);
 703         if (sizes != null) {
 704             boolean allZero = true;
 705             for (int i = 0; i &lt; sizes.length; i++) {
 706                 if (sizes[i] != 0) {
 707                     allZero = false;
 708                     break;
 709                 }
 710             }
 711             if (allZero) {
 712                 sizes = null;
 713             }
 714         }
 715         state.getStrokeNoClone().setDashSizes(sizes);
 716     }
 717 
 718     @Override
 719     public void setLineCap(int lineCap) {
 720         if (log.isLoggable(Level.FINE)) {
 721             log.fine(&quot;setLineCap(&quot; + lineCap + &quot;)&quot;);
 722         }
 723         state.getStrokeNoClone().setLineCap(lineCap);
 724     }
 725 
 726     @Override
 727     public void setLineJoin(int lineJoin) {
 728         if (log.isLoggable(Level.FINE)) {
 729             log.fine(&quot;setLineJoin(&quot; + lineJoin + &quot;)&quot;);
 730         }
 731         state.getStrokeNoClone().setLineJoin(lineJoin);
 732     }
 733 
 734     @Override
 735     public void setMiterLimit(float miterLimit) {
 736         if (log.isLoggable(Level.FINE)) {
 737             log.fine(&quot;setMiterLimit(&quot; + miterLimit + &quot;)&quot;);
 738         }
 739         state.getStrokeNoClone().setMiterLimit(miterLimit);
 740     }
 741 
 742     @Override
 743     public void setShadow(float dx, float dy, float blur, int rgba) {
 744         if (log.isLoggable(Level.FINE)) {
 745             String format = &quot;setShadow(%f, %f, %f, 0x%x)&quot;;
 746             log.fine(String.format(format, dx, dy, blur, rgba));
 747         }
 748         state.setShadow(createShadow(dx, dy, blur, rgba));
 749     }
 750 
 751     @Override
 752     public void drawPolygon(final WCPath path, final boolean shouldAntialias) {
 753         if (log.isLoggable(Level.FINE)) {
 754             log.fine(&quot;drawPolygon({0})&quot;,
 755                     new Object[] {shouldAntialias});
 756         }
 757         if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(), null,
 758                                 state.getStrokeNoClone().getPlatformStroke()))
 759         {
 760             return;
 761         }
 762         new Composite() {
 763             @Override void doPaint(Graphics g) {
 764                 Path2D p2d = (Path2D) path.getPlatformPath();
 765                 g.setPaint(state.getPaintNoClone());
 766                 g.fill(p2d);
 767                 if (state.getStrokeNoClone().apply(g)) {
 768                     g.draw(p2d);
 769                 }
 770             }
 771         }.paint();
 772     }
 773 
 774     @Override
 775     public void drawLine(final int x0, final int y0, final int x1, final int y1) {
 776         if (log.isLoggable(Level.FINE)) {
 777             log.fine(&quot;drawLine({0}, {1}, {2}, {3})&quot;,
 778                     new Object[] {x0, y0, x1, y1});
 779         }
 780         Line2D line = new Line2D(x0, y0, x1, y1);
 781         if (!shouldRenderShape(line, null, state.getStrokeNoClone().getPlatformStroke())) {
 782             return;
 783         }
 784         new Composite() {
 785             @Override void doPaint(Graphics g) {
 786                 if (state.getStrokeNoClone().apply(g)) {
 787                     g.drawLine(x0, y0, x1, y1);
 788                 }
 789             }
 790         }.paint();
 791     }
 792 
 793     @Override
 794     public void drawPattern(
 795         final WCImage texture,
 796         final WCRectangle srcRect,
 797         final WCTransform patternTransform,
 798         final WCPoint phase,
 799         final WCRectangle destRect)
 800     {
 801         if (log.isLoggable(Level.FINE)) {
 802             log.fine(&quot;drawPattern({0}, {1}, {2}, {3})&quot;,
 803                     new Object[] {destRect.getIntX(), destRect.getIntY(),
 804                                   destRect.getIntWidth(),
 805                                   destRect.getIntHeight()});
 806         }
 807         if (!shouldRenderRect(destRect.getX(), destRect.getY(),
 808                               destRect.getWidth(), destRect.getHeight(), null, null))
 809         {
 810             return;
 811         }
 812         if (texture != null) {
 813             new Composite() {
 814                 @Override void doPaint(Graphics g) {
 815                     // The handling of pattern transform is modeled after the WebKit
 816                     // ImageCG.cpp&#39;s Image::drawPattern()
 817                     float adjustedX = phase.getX()
 818                             + srcRect.getX() * (float) patternTransform.getMatrix()[0];
 819                     float adjustedY = phase.getY()
 820                             + srcRect.getY() * (float) patternTransform.getMatrix()[3];
 821                     float scaledTileWidth =
 822                             srcRect.getWidth() * (float) patternTransform.getMatrix()[0];
 823                     float scaledTileHeight =
 824                             srcRect.getHeight() * (float) patternTransform.getMatrix()[3];
 825 
 826                     Image img = ((PrismImage)texture).getImage();
 827 
 828                     // Create subImage only if srcRect doesn&#39;t fit the texture bounds. See RT-20193.
 829                     if (!srcRect.contains(new WCRectangle(0, 0, texture.getWidth(), texture.getHeight()))) {
 830 
 831                         img = img.createSubImage(srcRect.getIntX(),
 832                                                  srcRect.getIntY(),
 833                                                  (int)Math.ceil(srcRect.getWidth()),
 834                                                  (int)Math.ceil(srcRect.getHeight()));
 835                     }
 836                     g.setPaint(new ImagePattern(
 837                                img,
 838                                adjustedX, adjustedY,
 839                                scaledTileWidth, scaledTileHeight,
 840                                false, false));
 841 
 842                     g.fillRect(destRect.getX(), destRect.getY(),
 843                                destRect.getWidth(), destRect.getHeight());
 844                 }
 845             }.paint();
 846         }
 847     }
 848 
 849     @Override
 850     public void drawImage(final WCImage img,
 851                           final float dstx, final float dsty, final float dstw, final float dsth,
 852                           final float srcx, final float srcy, final float srcw, final float srch)
 853     {
 854         if (log.isLoggable(Level.FINE)){
 855             log.fine(&quot;drawImage(img, dst({0},{1},{2},{3}), &quot; +
 856                     &quot;src({4},{5},{6},{7}))&quot;,
 857                     new Object[] {dstx, dsty, dstw, dsth,
 858                                   srcx, srcy, srcw, srch});
 859         }
 860         if (!shouldRenderRect(dstx, dsty, dstw, dsth, state.getShadowNoClone(), null)) {
 861             return;
 862         }
 863         if (img instanceof PrismImage) {
 864             new Composite() {
 865                 @Override void doPaint(Graphics g) {
 866                     PrismImage pi = (PrismImage) img;
 867                     DropShadow shadow = state.getShadowNoClone();
 868                     if (shadow != null) {
 869                         NGImageView node = new NGImageView();
 870                         node.setImage(pi.getImage());
 871                         node.setX(dstx);
 872                         node.setY(dsty);
 873                         node.setViewport(srcx, srcy, srcw, srch, dstw, dsth);
 874                         node.setContentBounds(new RectBounds(dstx, dsty, dstx + dstw, dsty + dsth));
 875                         render(g, shadow, null, null, node);
 876                     } else {
 877                         pi.draw(g,
 878                                 (int) dstx, (int) dsty,
 879                                 (int) (dstx + dstw), (int) (dsty + dsth),
 880                                 (int) srcx, (int) srcy,
 881                                 (int) (srcx + srcw), (int) (srcy + srch));
 882                     }
 883                 }
 884             }.paint();
 885         }
 886     }
 887 
 888     @Override
 889     public void drawBitmapImage(final ByteBuffer image, final int x, final int y, final int w, final int h) {
 890         if (!shouldRenderRect(x, y, w, h, null, null)) {
 891             return;
 892         }
 893         new Composite() {
 894             @Override void doPaint(Graphics g) {
 895                 image.order(ByteOrder.nativeOrder());
 896                 Image img = Image.fromByteBgraPreData(image, w, h);
 897                 ResourceFactory rf = g.getResourceFactory();
 898                 Texture txt = rf.createTexture(img, Texture.Usage.STATIC, Texture.WrapMode.REPEAT);
 899                 g.drawTexture(txt, x, y, x + w, y + h, 0, 0, w, h);
 900                 txt.dispose();
 901             }
 902         }.paint();
 903     }
 904 
 905     @Override
 906     public void drawIcon(WCIcon icon, int x, int y) {
 907         if (log.isLoggable(Level.FINE)) {
 908             log.fine(&quot;UNIMPLEMENTED drawIcon ({0}, {1})&quot;,
 909                     new Object[] {x, y});
 910         }
 911     }
 912 
 913     @Override
 914     public void drawRect(final int x, final int y, final int w, final int h) {
 915         if (log.isLoggable(Level.FINE)) {
 916             log.fine(&quot;drawRect({0}, {1}, {2}, {3})&quot;,
 917                     new Object[]{x, y, w, h});
 918         }
 919         if (!shouldRenderRect(x, y, w, h,
 920                               null, state.getStrokeNoClone().getPlatformStroke()))
 921         {
 922             return;
 923         }
 924         new Composite() {
 925             @Override void doPaint(Graphics g) {
 926                 Paint c = state.getPaintNoClone();
 927                 if (c != null &amp;&amp; c.isOpaque()) {
 928                     g.setPaint(c);
 929                     g.fillRect(x, y, w, h);
 930                 }
 931 
 932                 if (state.getStrokeNoClone().apply(g)) {
 933                     g.drawRect(x, y, w, h);
 934                 }
 935             }
 936         }.paint();
 937     }
 938 
 939     @Override
 940     public void drawString(final WCFont f, final int[] glyphs,
 941                            final float[] advances, final float x, final float y)
 942     {
 943         if (log.isLoggable(Level.FINE)) {
 944             log.fine(String.format(
 945                     &quot;Drawing %d glyphs @(%.1f, %.1f)&quot;,
 946                     glyphs.length, x, y));
 947         }
 948         PGFont font = (PGFont)f.getPlatformFont();
 949         TextRun gl = TextUtilities.createGlyphList(glyphs, advances, x, y);
 950 
 951         DropShadow shadow = state.getShadowNoClone();
 952         BasicStroke stroke = state.isTextStroke()
 953                 ? state.getStrokeNoClone().getPlatformStroke()
 954                 : null;
 955 
 956         final FontStrike strike = font.getStrike(getTransformNoClone(), getFontSmoothingType());
 957         if (shouldCalculateIntersection()) {
 958             Metrics m = strike.getMetrics();
 959             gl.setMetrics(m.getAscent(), m.getDescent(), m.getLineGap());
 960             if (!shouldRenderRect(x, y, gl.getWidth(), gl.getHeight(), shadow, stroke)) {
 961                 return;
 962             }
 963         }
 964         new Composite() {
 965             @Override void doPaint(Graphics g) {
 966                 Paint paint = state.isTextFill()
 967                         ? state.getPaintNoClone()
 968                         : null;
 969                 if (shadow != null) {
 970                     final NGText span = new NGText();
 971                     span.setGlyphs(new GlyphList[] {gl});
 972                     span.setFont(font);
 973                     span.setFontSmoothingType(fontSmoothingType);
 974                     render(g, shadow, paint, stroke, span);
 975                 } else {
 976                     if (paint != null) {
 977                         g.setPaint(paint);
 978                         g.drawString(gl, strike, x, y, null, 0, 0);
 979                     }
 980                     if (stroke != null) {
 981                         paint = state.getStrokeNoClone().getPaint();
 982                         if (paint != null) {
 983                             g.setPaint(paint);
 984                             g.setStroke(stroke);
 985                             g.draw(strike.getOutline(gl, BaseTransform.getTranslateInstance(x, y)));
 986                         }
 987                     }
 988                 }
 989             }
 990         }.paint();
 991     }
 992 
 993     @Override public void drawString(WCFont f, String str, boolean rtl,
 994             int from, int to, float x, float y)
 995     {
 996         if (log.isLoggable(Level.FINE)) {
 997             log.fine(String.format(
 998                     &quot;str=&#39;%s&#39; (length=%d), from=%d, to=%d, rtl=%b, @(%.1f, %.1f)&quot;,
 999                     str, str.length(), from, to, rtl, x, y));
1000         }
1001         TextLayout layout = TextUtilities.createLayout(
1002                 str.substring(from, to), f.getPlatformFont());
1003         int count = 0;
1004         GlyphList[] runs = layout.getRuns();
1005         for (GlyphList run: runs) {
1006             count += run.getGlyphCount();
1007         }
1008 
1009         int[] glyphs = new int[count];
1010         float[] adv = new float[count];
1011         count = 0;
1012         for (GlyphList run: layout.getRuns()) {
1013             int gc = run.getGlyphCount();
1014             for (int i = 0; i &lt; gc; i++) {
1015                 glyphs[count] = run.getGlyphCode(i);
1016                 adv[count] = run.getPosX(i + 1) - run.getPosX(i);
1017                 count++;
1018             }
1019         }
1020 
1021         // adjust x coordinate (see RT-29908)
1022         if (rtl) {
1023             x += (TextUtilities.getLayoutWidth(str.substring(from), f.getPlatformFont()) -
1024                   layout.getBounds().getWidth());
1025         } else {
1026             x += TextUtilities.getLayoutWidth(str.substring(0, from), f.getPlatformFont());
1027         }
1028         drawString(f, glyphs, adv, x, y);
1029     }
1030 
1031     @Override
1032     public void setComposite(int composite) {
1033         log.fine(&quot;setComposite({0})&quot;, composite);
1034         state.setCompositeOperation(composite);
1035     }
1036 
1037     @Override
1038     public void drawEllipse(final int x, final int y, final int w, final int h) {
1039         if (log.isLoggable(Level.FINE)) {
1040             log.fine(&quot;drawEllipse({0}, {1}, {2}, {3})&quot;,
1041                     new Object[] { x, y, w, h});
1042         }
1043         if (!shouldRenderRect(x, y, w, h,
1044                               null, state.getStrokeNoClone().getPlatformStroke()))
1045         {
1046             return;
1047         }
1048         new Composite() {
1049             @Override void doPaint(Graphics g) {
1050                 g.setPaint(state.getPaintNoClone());
1051                 g.fillEllipse(x, y, w, h);
1052                 if (state.getStrokeNoClone().apply(g)) {
1053                     g.drawEllipse(x, y, w, h);
1054                 }
1055             }
1056         }.paint();
1057     }
1058 
1059     private final static BasicStroke focusRingStroke =
1060         new BasicStroke(1.1f, BasicStroke.CAP_BUTT,
1061                          BasicStroke.JOIN_ROUND, 0.0f,
1062                          new float[] {1.0f}, 0.0f);
1063 
1064     @Override
1065     public void drawFocusRing(final int x, final int y, final int w, final int h, final int rgba) {
1066         if (log.isLoggable(Level.FINE)) {
1067             log.fine(String.format(&quot;drawFocusRing: %d, %d, %d, %d, 0x%x&quot;, x, y, w, h, rgba));
1068         }
1069         if (!shouldRenderRect(x, y, w, h, null, focusRingStroke)) {
1070             return;
1071         }
1072         new Composite() {
1073             @Override void doPaint(Graphics g) {
1074                 g.setPaint(createColor(rgba));
1075                 BasicStroke stroke = g.getStroke();
1076                 g.setStroke(focusRingStroke);
1077                 g.drawRoundRect(x, y, w, h, 4, 4);
1078                 g.setStroke(stroke);
1079             }
1080         }.paint();
1081     }
1082 
1083     public void setAlpha(float alpha) {
1084         log.fine(&quot;setAlpha({0})&quot;, alpha);
1085 
1086         state.setAlpha(alpha);
1087 
1088         if (null != cachedGraphics) {
1089             cachedGraphics.setExtraAlpha(state.getAlpha());
1090         }
1091     }
1092 
1093     public float getAlpha() {
1094         return state.getAlpha();
1095     }
1096 
1097     @Override public void beginTransparencyLayer(float opacity) {
1098         TransparencyLayer layer = new TransparencyLayer(
1099                 getGraphics(false), state.getClipNoClone(), opacity);
1100 
1101         if (log.isLoggable(Level.FINE)) {
1102             log.fine(String.format(&quot;beginTransparencyLayer(%s)&quot;, layer));
1103         }
1104 
1105         //[saveStateIntertal] will work as [saveState]
1106         state.markAsRestorePoint();
1107 
1108         startNewLayer(layer);
1109     }
1110 
1111     @Override public void endTransparencyLayer() {
1112         if (log.isLoggable(Level.FINE)) {
1113             log.fine(String.format(&quot;endTransparencyLayer(%s)&quot;, state.getLayerNoClone()));
1114         }
1115 
1116         //pair to [startNewLayer] that works as [saveState] call
1117         restoreState();
1118     }
1119 
1120     @Override
1121     public void drawWidget(final RenderTheme theme, final Ref widget, final int x, final int y) {
1122         WCSize s = theme.getWidgetSize(widget);
1123         if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
1124             return;
1125         }
1126         new Composite() {
1127             @Override void doPaint(Graphics g) {
1128                 theme.drawWidget(WCGraphicsPrismContext.this, widget, x, y);
1129             }
1130         }.paint();
1131     }
1132 
1133     @Override
1134     public void drawScrollbar(final ScrollBarTheme theme, final Ref widget, int x, int y,
1135                               int pressedPart, int hoveredPart)
1136     {
1137         if (log.isLoggable(Level.FINE)) {
1138             log.fine(String.format(&quot;drawScrollbar(%s, %s, x = %d, y = %d)&quot;, theme, widget, x, y));
1139         }
1140 
1141         WCSize s = theme.getWidgetSize(widget);
1142         if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
1143             return;
1144         }
1145         new Composite() {
1146             @Override void doPaint(Graphics g) {
1147                 theme.paint(WCGraphicsPrismContext.this, widget, x, y, pressedPart, hoveredPart);
1148             }
1149         }.paint();
1150     }
1151 
1152     private static Rectangle intersect(Rectangle what, Rectangle with) {
1153         if (what == null) {
1154             return with;
1155         }
1156         RectBounds b = what.toRectBounds();
1157         b.intersectWith(with);
1158         what.setBounds(b);
1159         return what;
1160     }
1161 
1162     static Color createColor(int rgba) {
1163         float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
1164         float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
1165         float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
1166         float b = (0xFF &amp; (rgba)) / 255.0f;
1167         return new Color(r, g, b, a);
1168     }
1169 
1170     private static Color4f createColor4f(int rgba) {
1171         float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
1172         float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
1173         float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
1174         float b = (0xFF &amp; (rgba)) / 255.0f;
1175         return new Color4f(r, g, b, a);
1176     }
1177 
1178     private DropShadow createShadow(float dx, float dy, float blur, int rgba) {
1179         if (dx == 0f &amp;&amp; dy == 0f &amp;&amp; blur == 0f) {
1180             return null;
1181         }
1182         DropShadow shadow = new DropShadow();
1183         shadow.setOffsetX((int) dx);
1184         shadow.setOffsetY((int) dy);
1185         shadow.setRadius((blur &lt; 0f) ? 0f : (blur &gt; 127f) ? 127f : blur);
1186         shadow.setColor(createColor4f(rgba));
1187         return shadow;
1188     }
1189 
1190     private void render(Graphics g, Effect effect, Paint paint, BasicStroke stroke, NGNode node) {
1191         if (node instanceof NGShape) {
1192             NGShape shape = (NGShape) node;
1193             Shape realShape = shape.getShape();
1194             Paint strokePaint = state.getStrokeNoClone().getPaint();
1195             if ((stroke != null) &amp;&amp; (strokePaint != null)) {
1196                 realShape = stroke.createStrokedShape(realShape);
1197                 shape.setDrawStroke(stroke);
1198                 shape.setDrawPaint(strokePaint);
1199                 shape.setMode((paint == null) ? NGShape.Mode.STROKE : NGShape.Mode.STROKE_FILL);
1200             } else {
1201                 shape.setMode((paint == null) ? NGShape.Mode.EMPTY : NGShape.Mode.FILL);
1202             }
1203             shape.setFillPaint(paint);
1204             shape.setContentBounds(realShape.getBounds());
1205         }
1206         boolean culling = g.hasPreCullingBits();
1207         g.setHasPreCullingBits(false);
1208         node.setEffect(effect);
1209         node.render(g);
1210         g.setHasPreCullingBits(culling);
1211     }
1212 
1213     private static final class ContextState {
1214         private final WCStrokeImpl stroke = new WCStrokeImpl();
1215         private Rectangle clip;
1216         private Paint paint;
1217         private float alpha;
1218 
1219         private boolean textFill = true;
1220         private boolean textStroke = false;
1221         private boolean textClip = false;
1222         private boolean restorePoint = false;
1223 
1224         private DropShadow shadow;
1225         private Affine3D xform;
1226         private GeneralTransform3D perspectiveTransform;
1227         private Layer layer;
1228         private int compositeOperation;
<a name="3" id="anc3"></a><span class="line-added">1229         private WCImage clipMaskImage;</span>
1230 
1231         private ContextState() {
1232             clip = null;
1233             paint = Color.BLACK;
1234             stroke.setPaint(Color.BLACK);
1235             alpha = 1.0f;
1236             xform = new Affine3D();
1237             perspectiveTransform = new GeneralTransform3D();
1238             compositeOperation = COMPOSITE_SOURCE_OVER;
1239         }
1240 
1241         private ContextState(ContextState state) {
1242             stroke.copyFrom(state.getStrokeNoClone());
1243             setPaint(state.getPaintNoClone());
1244             clip = state.getClipNoClone();
1245             if (clip != null) {
1246                 clip = new Rectangle(clip);
1247             }
1248             xform = new Affine3D(state.getTransformNoClone());
1249             perspectiveTransform = new GeneralTransform3D().set(state.getPerspectiveTransformNoClone());
1250             setShadow(state.getShadowNoClone());
1251             setLayer(state.getLayerNoClone());
1252             setAlpha(state.getAlpha());
1253             setTextMode(state.isTextFill(), state.isTextStroke(), state.isTextClip());
1254             setCompositeOperation(state.getCompositeOperation());
<a name="4" id="anc4"></a><span class="line-added">1255             setClipMaskImage(state.getClipMaskImageNoClone());</span>
1256         }
1257 
1258         @Override
1259         protected ContextState clone() {
1260             return new ContextState(this);
1261         }
1262 
1263         private void apply(Graphics g) {
1264             g.setTransform(getTransformNoClone());
1265             g.setPerspectiveTransform(getPerspectiveTransformNoClone());
1266             g.setClipRect(getClipNoClone());
1267             g.setExtraAlpha(getAlpha());
1268         }
1269 
1270         private int getCompositeOperation() {
1271             return compositeOperation;
1272         }
1273 
1274         private void setCompositeOperation(int compositeOperation) {
1275             this.compositeOperation = compositeOperation;
1276         }
1277 
1278         private WCStrokeImpl getStrokeNoClone() {
1279             return stroke;
1280         }
1281 
1282         private Paint getPaintNoClone() {
1283             return paint;
1284         }
1285 
1286         private void setPaint(Paint paint) {
1287             this.paint = paint;
1288         }
1289 
<a name="5" id="anc5"></a><span class="line-added">1290         private void setClipMaskImage(WCImage image) {</span>
<span class="line-added">1291             this.clipMaskImage = image;</span>
<span class="line-added">1292         }</span>
<span class="line-added">1293 </span>
<span class="line-added">1294         private WCImage getClipMaskImageNoClone() {</span>
<span class="line-added">1295             return clipMaskImage;</span>
<span class="line-added">1296         }</span>
<span class="line-added">1297 </span>
1298         private Rectangle getClipNoClone() {
1299             return clip;
1300         }
1301 
1302         private Layer getLayerNoClone() {
1303             return layer;
1304         }
1305 
1306         private void setLayer(Layer layer) {
1307             this.layer = layer;
1308         }
1309 
1310         private void setClip(Rectangle area) {
1311             clip = area;
1312         }
1313 
1314         private void clip(Rectangle area) {
1315             if (null == clip) {
1316                 clip = area;
1317             } else {
1318                 clip.intersectWith(area);
1319             }
1320         }
1321 
1322         private void setAlpha(float alpha) {
1323             this.alpha = alpha;
1324         }
1325 
1326         private float getAlpha() {
1327             return alpha;
1328         }
1329 
1330         private void setTextMode(boolean fill, boolean stroke, boolean clip) {
1331             textFill = fill;
1332             textStroke = stroke;
1333             textClip = clip;
1334         }
1335 
1336         private boolean isTextFill() {
1337             return textFill;
1338         }
1339 
1340         private boolean isTextStroke() {
1341             return textStroke;
1342         }
1343 
1344         private boolean isTextClip() {
1345             return textClip;
1346         }
1347 
1348         private void markAsRestorePoint() {
1349             restorePoint = true;
1350         }
1351 
1352         private boolean isRestorePoint() {
1353             return restorePoint;
1354         }
1355 
1356         private void setShadow(DropShadow shadow) {
1357             this.shadow = shadow;
1358         }
1359 
1360         private DropShadow getShadowNoClone() {
1361             return shadow;
1362         }
1363 
1364         private Affine3D getTransformNoClone() {
1365             return xform;
1366         }
1367 
1368         private GeneralTransform3D getPerspectiveTransformNoClone() {
1369             return perspectiveTransform;
1370         }
1371 
1372         private void setTransform(final Affine3D at) {
1373             this.xform.setTransform(at);
1374         }
1375 
1376         private void setPerspectiveTransform(final GeneralTransform3D gt) {
1377             this.perspectiveTransform.set(gt);
1378         }
1379 
1380         private void concatTransform(Affine3D at) {
1381             xform.concatenate(at);
1382         }
1383 
1384         private void translate(double dx, double dy) {
1385             xform.translate(dx, dy);
1386         }
1387 
1388         private void scale(double sx, double sy) {
1389             xform.scale(sx,sy);
1390         }
1391 
1392         private void rotate(double radians) {
1393             xform.rotate(radians);
1394         }
1395     }
1396 
1397     private abstract static class Layer {
1398         FilterContext fctx;
1399         PrDrawable buffer;
1400         Graphics graphics;
1401         final Rectangle bounds;
1402         boolean permanent;
1403 
1404         Layer(Graphics g, Rectangle bounds, boolean permanent) {
1405             this.bounds = new Rectangle(bounds);
1406             this.permanent = permanent;
1407 
1408             // avoid creating zero-size drawable, see also RT-21410
1409             int w = Math.max(bounds.width, 1);
1410             int h = Math.max(bounds.height, 1);
1411             fctx = getFilterContext(g);
1412             if (permanent) {
1413                 ResourceFactory f = GraphicsPipeline.getDefaultResourceFactory();
1414                 RTTexture rtt = f.createRTTexture(w, h, Texture.WrapMode.CLAMP_NOT_NEEDED);
1415                 rtt.makePermanent();
1416                 buffer = ((PrRenderer)Renderer.getRenderer(fctx)).createDrawable(rtt);
1417             } else {
1418                 buffer = (PrDrawable) Effect.getCompatibleImage(fctx, w, h);
1419             }
1420         }
1421 
1422         Graphics getGraphics() {
1423             if (graphics == null) {
1424                 graphics = buffer.createGraphics();
1425             }
1426             return graphics;
1427         }
1428 
1429         abstract void init(Graphics g);
1430 
1431         abstract void render(Graphics g);
1432 
1433         private void dispose() {
1434             if (buffer != null) {
1435                 if (permanent) {
1436                     buffer.flush(); // releases the resource
1437                 } else {
1438                     Effect.releaseCompatibleImage(fctx, buffer);
1439                 }
1440                 fctx = null;
1441                 buffer = null;
1442             }
1443         }
1444 
1445         private double getX() { return (double) bounds.x; }
1446         private double getY() { return (double) bounds.y; }
1447     }
1448 
1449     private final class TransparencyLayer extends Layer {
1450         private final float opacity;
1451 
1452         private TransparencyLayer(Graphics g, Rectangle bounds, float opacity) {
1453             super(g, bounds, false);
1454             this.opacity = opacity;
1455         }
1456 
1457         @Override void init(Graphics g) {
1458             state.setCompositeOperation(COMPOSITE_SOURCE_OVER);
1459         }
1460 
1461         @Override void render(Graphics g) {
1462             new Composite() {
1463                 @Override void doPaint(Graphics g) {
1464                     float op = g.getExtraAlpha();
1465                     g.setExtraAlpha(opacity);
1466                     Affine3D tx = new Affine3D(g.getTransformNoClone());
1467                     g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
1468                     g.drawTexture(buffer.getTextureObject(),
1469                             bounds.x, bounds.y, bounds.width, bounds.height);
1470                     g.setTransform(tx);
1471                     g.setExtraAlpha(op);
1472                 }
1473             }.paint(g);
1474         }
1475 
1476         @Override public String toString() {
1477             return String.format(&quot;TransparencyLayer[%d,%d + %dx%d, opacity %.2f]&quot;,
1478                 bounds.x, bounds.y, bounds.width, bounds.height, opacity);
1479         }
1480     }
1481 
1482     private static final class ClipLayer extends Layer {
1483         private final WCPath normalizedToClipPath;
1484         private boolean srcover;
1485 
1486         private ClipLayer(Graphics g, Rectangle bounds, WCPath normalizedToClipPath,
1487                           boolean permanent)
1488         {
1489             super(g, bounds, permanent);
1490             this.normalizedToClipPath = normalizedToClipPath;
1491             srcover = true;
1492         }
1493 
1494         @Override void init(Graphics g) {
1495             RTTexture texture = null;
1496             ReadbackGraphics readbackGraphics = null;
1497             try {
1498                 readbackGraphics = (ReadbackGraphics) g;
1499                 texture = readbackGraphics.readBack(bounds);
1500                 getGraphics().drawTexture(texture, 0, 0, bounds.width, bounds.height);
1501             } finally {
1502                 if (readbackGraphics != null &amp;&amp; texture != null) {
1503                     readbackGraphics.releaseReadBackBuffer(texture);
1504                 }
1505             }
1506             srcover = false;
1507         }
1508 
1509         @Override void render(Graphics g) {
1510             Path2D p2d = ((WCPathImpl)normalizedToClipPath).getPlatformPath();
1511 
1512             // render normalizedToClipPath to a drawable
1513             PrDrawable bufferImg = (PrDrawable) Effect.getCompatibleImage(
1514                     fctx, bounds.width, bounds.height);
1515             Graphics bufferGraphics = bufferImg.createGraphics();
1516 
1517             bufferGraphics.setPaint(Color.BLACK);
1518             bufferGraphics.fill(p2d);
1519 
1520             // blend buffer and clipImg onto |g|
1521             if (g instanceof MaskTextureGraphics &amp;&amp; ! (g instanceof PrinterGraphics)) {
1522                 MaskTextureGraphics mg = (MaskTextureGraphics) g;
1523                 if (srcover) {
1524                     mg.drawPixelsMasked(buffer.getTextureObject(),
1525                                         bufferImg.getTextureObject(),
1526                                         bounds.x, bounds.y, bounds.width, bounds.height,
1527                                         0, 0, 0, 0);
1528                 } else {
1529                     mg.maskInterpolatePixels(buffer.getTextureObject(),
1530                                              bufferImg.getTextureObject(),
1531                                              bounds.x, bounds.y, bounds.width, bounds.height,
1532                                              0, 0, 0, 0);
1533                 }
1534             } else {
1535                 Blend blend = new Blend(Blend.Mode.SRC_IN,
1536                         new PassThrough(bufferImg, bounds.width, bounds.height),
1537                         new PassThrough(buffer, bounds.width, bounds.height));
1538                 Affine3D tx = new Affine3D(g.getTransformNoClone());
1539                 g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
1540                 PrEffectHelper.render(blend, g, bounds.x, bounds.y, null);
1541                 g.setTransform(tx);
1542             }
1543 
1544             Effect.releaseCompatibleImage(fctx, bufferImg);
1545         }
1546 
1547         @Override public String toString() {
1548             return String.format(&quot;ClipLayer[%d,%d + %dx%d, path %s]&quot;,
1549                     bounds.x, bounds.y, bounds.width, bounds.height,
1550                     normalizedToClipPath);
1551         }
1552     }
1553 
1554     private abstract class Composite {
1555         abstract void doPaint(Graphics g);
1556 
1557         void paint() {
1558             paint(getGraphics(true));
1559         }
1560 
1561         void paint(Graphics g) {
1562             if (g != null) {
1563                 CompositeMode oldCompositeMode = g.getCompositeMode();
1564                 switch (state.getCompositeOperation()) {
1565                     // decode operations that don&#39;t require Blend first
1566                     case COMPOSITE_COPY:
1567                         g.setCompositeMode(CompositeMode.SRC);
1568                         doPaint(g);
1569                         g.setCompositeMode(oldCompositeMode);
1570                         break;
1571                     case COMPOSITE_SOURCE_OVER:
1572                         g.setCompositeMode(CompositeMode.SRC_OVER);
1573                         doPaint(g);
1574                         g.setCompositeMode(oldCompositeMode);
1575                         break;
1576                     default:
1577                         // other operations require usage of Blend
1578                         blend(g);
1579                         break;
1580                 }
1581                 isRootLayerValid = false;
1582             }
1583         }
1584 
1585         private void blend(Graphics g) {
1586             FilterContext fctx = getFilterContext(g);
1587             PrDrawable dstImg = null;
1588             PrDrawable srcImg = null;
1589             ReadbackGraphics readBackGraphics = null;
1590             RTTexture texture = null;
1591             Rectangle clip = state.getClipNoClone();
1592             WCImage image = getImage();
1593             try {
1594                 if (image != null &amp;&amp; image instanceof PrismImage) {
1595                     // blending on canvas
1596                     dstImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
1597                     Graphics dstG = dstImg.createGraphics();
1598                     ((PrismImage) image).draw(dstG,
1599                             0, 0, clip.width, clip.height,
1600                             clip.x, clip.y, clip.width, clip.height);
1601                 } else {
1602                     // blending on page
1603                     readBackGraphics = (ReadbackGraphics) g;
1604                     texture = readBackGraphics.readBack(clip);
1605                     dstImg = PrDrawable.create(fctx, texture);
1606                 }
1607 
1608                 srcImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
1609                 Graphics srcG = srcImg.createGraphics();
1610                 state.apply(srcG);
1611                 doPaint(srcG);
1612 
1613                 g.clear();
1614                 PrEffectHelper.render(createEffect(dstImg, srcImg, clip.width, clip.height), g, 0, 0, null);
1615 
1616             } finally {
1617                 if (srcImg != null) {
1618                     Effect.releaseCompatibleImage(fctx, srcImg);
1619                 }
1620                 if (dstImg != null) {
1621                     if (readBackGraphics != null &amp;&amp; texture != null) {
1622                         readBackGraphics.releaseReadBackBuffer(texture);
1623                     } else {
1624                         Effect.releaseCompatibleImage(fctx, dstImg);
1625                     }
1626                 }
1627             }
1628         }
1629 
1630         // provides some syntax sugar for createEffect()
1631         private Effect createBlend(Blend.Mode mode,
1632                                    PrDrawable dstImg,
1633                                    PrDrawable srcImg,
1634                                    int width,
1635                                    int height)
1636         {
1637             return new Blend(
1638                     mode,
1639                     new PassThrough(dstImg, width, height),
1640                     new PassThrough(srcImg, width, height));
1641         }
1642 
1643         private Effect createEffect(PrDrawable dstImg,
1644                                     PrDrawable srcImg,
1645                                     int width,
1646                                     int height)
1647         {
1648             switch (state.getCompositeOperation()) {
1649                 case COMPOSITE_CLEAR: // same as xor
1650                 case COMPOSITE_XOR:
1651                     return new Blend(
1652                             SRC_OVER,
1653                             createBlend(SRC_OUT, dstImg, srcImg, width, height),
1654                             createBlend(SRC_OUT, srcImg, dstImg, width, height)
1655                     );
1656                 case COMPOSITE_SOURCE_IN:
1657                     return createBlend(SRC_IN, dstImg, srcImg, width, height);
1658                 case COMPOSITE_SOURCE_OUT:
1659                     return createBlend(SRC_OUT, dstImg, srcImg, width, height);
1660                 case COMPOSITE_SOURCE_ATOP:
1661                     return createBlend(SRC_ATOP, dstImg, srcImg, width, height);
1662                 case COMPOSITE_DESTINATION_OVER:
1663                     return createBlend(SRC_OVER, srcImg, dstImg, width, height);
1664                 case COMPOSITE_DESTINATION_IN:
1665                     return createBlend(SRC_IN, srcImg, dstImg, width, height);
1666                 case COMPOSITE_DESTINATION_OUT:
1667                     return createBlend(SRC_OUT, srcImg, dstImg, width, height);
1668                 case COMPOSITE_DESTINATION_ATOP:
1669                     return createBlend(SRC_ATOP, srcImg, dstImg, width, height);
1670                 case COMPOSITE_HIGHLIGHT:
1671                     return createBlend(ADD, dstImg, srcImg, width, height);
1672                 default:
1673                     return createBlend(SRC_OVER, dstImg, srcImg, width, height);
1674             }
1675         }
1676     }
1677 
1678     private static final class PassThrough extends Effect {
1679         private final PrDrawable img;
1680         private final int width;
1681         private final int height;
1682 
1683         private PassThrough(PrDrawable img, int width, int height) {
1684             this.img = img;
1685             this.width = width;
1686             this.height = height;
1687         }
1688 
1689         @Override public ImageData filter(
1690                 FilterContext fctx,
1691                 BaseTransform transform,
1692                 Rectangle outputClip,
1693                 Object renderHelper,
1694                 Effect defaultInput) {
1695             // We have an unpaired lock() here, because unlocking is done
1696             // internally by ImageData. See RT-33625 for details.
1697             img.lock();
1698             ImageData imgData = new ImageData(fctx, img, new Rectangle(
1699                                               (int) transform.getMxt(),
1700                                               (int) transform.getMyt(),
1701                                               width, height));
1702             imgData.setReusable(true);
1703             return imgData;
1704         }
1705 
1706         @Override public RectBounds getBounds(
1707                 BaseTransform transform,
1708                 Effect defaultInput) {
1709             return null;
1710         }
1711 
1712         @Override public AccelType getAccelType(FilterContext fctx) {
1713             return AccelType.INTRINSIC;
1714         }
1715 
1716         @Override
1717         public boolean reducesOpaquePixels() {
1718             return false;
1719         }
1720 
1721         @Override
1722         public DirtyRegionContainer getDirtyRegions(Effect defaultInput, DirtyRegionPool regionPool) {
1723             return null;
1724         }
1725     }
1726 
1727     private static FilterContext getFilterContext(Graphics g) {
1728         Screen screen = g.getAssociatedScreen();
1729         if (screen == null) {
1730             ResourceFactory factory = g.getResourceFactory();
1731             return PrFilterContext.getPrinterContext(factory);
1732         } else {
1733             return PrFilterContext.getInstance(screen);
1734         }
1735     }
1736 
1737     @Override
1738     public void strokeArc(final int x, final int y, final int w, final int h,
1739                           final int startAngle, final int angleSpan)
1740     {
1741         if (log.isLoggable(Level.FINE)) {
1742             log.fine(String.format(&quot;strokeArc(%d, %d, %d, %d, %d, %d)&quot;,
1743                                    x, y, w, h, startAngle, angleSpan));
1744         }
1745         Arc2D arc = new Arc2D(x, y, w, h, startAngle, angleSpan, Arc2D.OPEN);
1746         if (state.getStrokeNoClone().isApplicable() &amp;&amp;
1747             !shouldRenderShape(arc, null, state.getStrokeNoClone().getPlatformStroke()))
1748         {
1749             return;
1750         }
1751         new Composite() {
1752             @Override void doPaint(Graphics g) {
1753                 if (state.getStrokeNoClone().apply(g)) {
1754                     g.draw(arc);
1755                 }
1756             }
1757         }.paint();
1758     }
1759 
1760     @Override
1761     public WCImage getImage() {
1762         return null;
1763     }
1764 
1765     @Override
1766     public void strokeRect(final float x, final float y, final float w, final float h,
1767                            final float lineWidth) {
1768         if (log.isLoggable(Level.FINE)) {
1769             log.fine(String.format(&quot;strokeRect_FFFFF(%f, %f, %f, %f, %f)&quot;,
1770                                    x, y, w, h, lineWidth));
1771         }
1772         BasicStroke stroke = new BasicStroke(
1773             lineWidth,
1774             BasicStroke.CAP_BUTT,
1775             BasicStroke.JOIN_MITER,
1776             Math.max(1.0f, lineWidth),
1777             state.getStrokeNoClone().getDashSizes(),
1778             state.getStrokeNoClone().getDashOffset());
1779 
1780         if (!shouldRenderRect(x, y, w, h, null, stroke)) {
1781             return;
1782         }
1783         new Composite() {
1784             @Override void doPaint(Graphics g) {
1785                 g.setStroke(stroke);
1786                 Paint paint = state.getStrokeNoClone().getPaint();
1787                 if (paint == null) {
1788                     paint = state.getPaintNoClone();
1789                 }
1790                 g.setPaint(paint);
1791                 g.drawRect(x, y, w, h);
1792             }
1793         }.paint();
1794     }
1795 
1796     @Override
1797     public void strokePath(final WCPath path) {
1798         log.fine(&quot;strokePath&quot;);
1799         if (path != null) {
1800             final BasicStroke stroke = state.getStrokeNoClone().getPlatformStroke();
1801             final DropShadow shadow = state.getShadowNoClone();
1802             final Path2D p2d = (Path2D)path.getPlatformPath();
1803 
1804             if ((stroke == null &amp;&amp; shadow == null) ||
1805                 !shouldRenderShape(p2d, shadow, stroke))
1806             {
1807                 return;
1808             }
1809             new Composite() {
1810                 @Override void doPaint(Graphics g) {
1811                     if (shadow != null) {
1812                         final NGPath node = new NGPath();
1813                         node.updateWithPath2d(p2d);
1814                         render(g, shadow, null, stroke, node);
1815                     } else if (stroke != null) {
1816                         Paint paint = state.getStrokeNoClone().getPaint();
1817                         if (paint == null) {
1818                             paint = state.getPaintNoClone();
1819                         }
1820                         g.setPaint(paint);
1821                         g.setStroke(stroke);
1822                         g.draw(p2d);
1823                     }
1824                 }
1825             }.paint();
1826         }
1827     }
1828 
1829     @Override
1830     public void fillPath(final WCPath path) {
1831         log.fine(&quot;fillPath&quot;);
1832         if (path != null) {
1833             if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(),
1834                                    state.getShadowNoClone(), null))
1835             {
1836                 return;
1837             }
1838             new Composite() {
1839                 @Override void doPaint(Graphics g) {
1840                     Path2D p2d = (Path2D) path.getPlatformPath();
1841                     Paint paint = state.getPaintNoClone();
1842                     DropShadow shadow = state.getShadowNoClone();
1843                     if (shadow != null) {
1844                         final NGPath node = new NGPath();
1845                         node.updateWithPath2d(p2d);
1846                         render(g, shadow, paint, null, node);
1847                     } else {
1848                         g.setPaint(paint);
1849                         g.fill(p2d);
1850                     }
1851                 }
1852             }.paint();
1853         }
1854     }
1855 
1856     public void setPerspectiveTransform(WCTransform tm) {
1857         final GeneralTransform3D at = new GeneralTransform3D().set(tm.getMatrix());
1858         state.setPerspectiveTransform(at);
1859         resetCachedGraphics();
1860     }
1861 
1862     public void setTransform(WCTransform tm) {
1863         final double m[] = tm.getMatrix();
1864         final Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
1865         if (state.getLayerNoClone() == null) {
1866             at.preConcatenate(baseTransform);
1867         }
1868         state.setTransform(at);
1869         resetCachedGraphics();
1870     }
1871 
1872     public WCTransform getTransform() {
1873         Affine3D xf = state.getTransformNoClone();
1874         return new WCTransform(xf.getMxx(), xf.getMyx(),
1875                                xf.getMxy(), xf.getMyy(),
1876                                xf.getMxt(), xf.getMyt());
1877     }
1878 
1879     public void concatTransform(WCTransform tm) {
1880         double m[] = tm.getMatrix();
1881         Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
1882         state.concatTransform(at);
1883         resetCachedGraphics();
1884     }
1885 
1886     @Override
1887     public void flush() {
1888         flushAllLayers();
1889     }
1890 
1891     @Override
1892     public WCGradient createLinearGradient(WCPoint p1, WCPoint p2) {
1893         return new WCLinearGradient(p1, p2);
1894     }
1895 
1896     @Override
1897     public WCGradient createRadialGradient(WCPoint p1, float r1, WCPoint p2, float r2) {
1898         return new WCRadialGradient(p1, r1, p2, r2);
1899     }
1900 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>