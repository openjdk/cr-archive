<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/loader/FrameLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2006-2018 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
   4  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   5  * Copyright (C) 2008 Alp Toker &lt;alp@atoker.com&gt;
   6  * Copyright (C) Research In Motion Limited 2009. All rights reserved.
   7  * Copyright (C) 2011 Kris Jordan &lt;krisjordan@gmail.com&gt;
   8  * Copyright (C) 2011 Google Inc. All rights reserved.
   9  *
  10  * Redistribution and use in source and binary forms, with or without
  11  * modification, are permitted provided that the following conditions
  12  * are met:
  13  *
  14  * 1.  Redistributions of source code must retain the above copyright
  15  *     notice, this list of conditions and the following disclaimer.
  16  * 2.  Redistributions in binary form must reproduce the above copyright
  17  *     notice, this list of conditions and the following disclaimer in the
  18  *     documentation and/or other materials provided with the distribution.
  19  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  20  *     its contributors may be used to endorse or promote products derived
  21  *     from this software without specific prior written permission.
  22  *
  23  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  24  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  27  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  30  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  32  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33  */
  34 
  35 #include &quot;config.h&quot;
  36 #include &quot;FrameLoader.h&quot;
  37 
  38 #include &quot;AXObjectCache.h&quot;
  39 #include &quot;ApplicationCacheHost.h&quot;
  40 #include &quot;BackForwardCache.h&quot;
  41 #include &quot;BackForwardController.h&quot;
  42 #include &quot;BeforeUnloadEvent.h&quot;
  43 #include &quot;CachedPage.h&quot;
  44 #include &quot;CachedResourceLoader.h&quot;
  45 #include &quot;Chrome.h&quot;
  46 #include &quot;ChromeClient.h&quot;
  47 #include &quot;CommonVM.h&quot;
  48 #include &quot;ContentFilter.h&quot;
  49 #include &quot;ContentRuleListResults.h&quot;
  50 #include &quot;ContentSecurityPolicy.h&quot;
  51 #include &quot;CustomHeaderFields.h&quot;
  52 #include &quot;DOMWindow.h&quot;
  53 #include &quot;DatabaseManager.h&quot;
  54 #include &quot;DiagnosticLoggingClient.h&quot;
  55 #include &quot;DiagnosticLoggingKeys.h&quot;
  56 #include &quot;Document.h&quot;
  57 #include &quot;DocumentLoader.h&quot;
  58 #include &quot;Editor.h&quot;
  59 #include &quot;EditorClient.h&quot;
  60 #include &quot;Element.h&quot;
  61 #include &quot;Event.h&quot;
  62 #include &quot;EventHandler.h&quot;
  63 #include &quot;EventNames.h&quot;
  64 #include &quot;FloatRect.h&quot;
  65 #include &quot;FormState.h&quot;
  66 #include &quot;FormSubmission.h&quot;
  67 #include &quot;Frame.h&quot;
  68 #include &quot;FrameLoadRequest.h&quot;
  69 #include &quot;FrameLoaderClient.h&quot;
  70 #include &quot;FrameNetworkingContext.h&quot;
  71 #include &quot;FrameTree.h&quot;
  72 #include &quot;FrameView.h&quot;
  73 #include &quot;GCController.h&quot;
  74 #include &quot;HTMLFormElement.h&quot;
  75 #include &quot;HTMLInputElement.h&quot;
  76 #include &quot;HTMLNames.h&quot;
  77 #include &quot;HTMLObjectElement.h&quot;
  78 #include &quot;HTMLParserIdioms.h&quot;
  79 #include &quot;HTTPHeaderNames.h&quot;
  80 #include &quot;HTTPHeaderValues.h&quot;
  81 #include &quot;HTTPParsers.h&quot;
  82 #include &quot;HistoryController.h&quot;
  83 #include &quot;HistoryItem.h&quot;
  84 #include &quot;IgnoreOpensDuringUnloadCountIncrementer.h&quot;
  85 #include &quot;InspectorController.h&quot;
  86 #include &quot;InspectorInstrumentation.h&quot;
  87 #include &quot;LinkLoader.h&quot;
  88 #include &quot;LoadTiming.h&quot;
  89 #include &quot;LoaderStrategy.h&quot;
  90 #include &quot;Logging.h&quot;
  91 #include &quot;MemoryCache.h&quot;
  92 #include &quot;MemoryRelease.h&quot;
  93 #include &quot;NavigationDisabler.h&quot;
  94 #include &quot;NavigationScheduler.h&quot;
  95 #include &quot;Node.h&quot;
  96 #include &quot;Page.h&quot;
  97 #include &quot;PageTransitionEvent.h&quot;
  98 #include &quot;PerformanceLogging.h&quot;
  99 #include &quot;PlatformStrategies.h&quot;
 100 #include &quot;PluginData.h&quot;
 101 #include &quot;PluginDocument.h&quot;
 102 #include &quot;PolicyChecker.h&quot;
 103 #include &quot;ProgressTracker.h&quot;
 104 #include &quot;ResourceHandle.h&quot;
 105 #include &quot;ResourceLoadInfo.h&quot;
 106 #include &quot;ResourceLoadObserver.h&quot;
 107 #include &quot;ResourceRequest.h&quot;
 108 #include &quot;SVGDocument.h&quot;
 109 #include &quot;SVGLocatable.h&quot;
 110 #include &quot;SVGNames.h&quot;
 111 #include &quot;SVGViewElement.h&quot;
 112 #include &quot;SVGViewSpec.h&quot;
 113 #include &quot;ScriptController.h&quot;
 114 #include &quot;ScriptSourceCode.h&quot;
 115 #include &quot;ScrollAnimator.h&quot;
 116 #include &quot;SecurityOrigin.h&quot;
 117 #include &quot;SecurityPolicy.h&quot;
 118 #include &quot;SegmentedString.h&quot;
 119 #include &quot;SerializedScriptValue.h&quot;
 120 #include &quot;Settings.h&quot;
 121 #include &quot;ShouldTreatAsContinuingLoad.h&quot;
 122 #include &quot;StyleTreeResolver.h&quot;
 123 #include &quot;SubframeLoader.h&quot;
 124 #include &quot;SubresourceLoader.h&quot;
 125 #include &quot;TextResourceDecoder.h&quot;
 126 #include &quot;UserContentController.h&quot;
 127 #include &quot;UserGestureIndicator.h&quot;
 128 #include &quot;WindowFeatures.h&quot;
 129 #include &quot;XMLDocumentParser.h&quot;
 130 #include &lt;dom/ScriptDisallowedScope.h&gt;
 131 #include &lt;wtf/CompletionHandler.h&gt;
 132 #include &lt;wtf/URL.h&gt;
 133 #include &lt;wtf/Ref.h&gt;
 134 #include &lt;wtf/SetForScope.h&gt;
 135 #include &lt;wtf/StdLibExtras.h&gt;
 136 #include &lt;wtf/SystemTracing.h&gt;
 137 #include &lt;wtf/text/CString.h&gt;
 138 #include &lt;wtf/text/WTFString.h&gt;
 139 
 140 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 141 #include &quot;Archive.h&quot;
 142 #endif
 143 
 144 #if ENABLE(DATA_DETECTION)
 145 #include &quot;DataDetection.h&quot;
 146 #endif
 147 
 148 #if PLATFORM(IOS_FAMILY)
 149 #include &quot;DocumentType.h&quot;
 150 #include &quot;ResourceLoader.h&quot;
 151 #include &quot;RuntimeApplicationChecks.h&quot;
 152 #endif
 153 
 154 #define FRAMELOADER_RELEASE_LOG(channel, fmt, ...) RELEASE_LOG(channel, &quot;%p - [frame=%p, main=%d] FrameLoader::&quot; fmt, this, &amp;m_frame, m_frame.isMainFrame(), ##__VA_ARGS__)
 155 #define FRAMELOADER_RELEASE_LOG_ERROR(channel, fmt, ...) RELEASE_LOG(channel, &quot;%p - [frame=%p, main=%d] FrameLoader::&quot; fmt, this, &amp;m_frame, m_frame.isMainFrame(), ##__VA_ARGS__)
 156 #define FRAMELOADER_RELEASE_LOG_IF_ALLOWED(channel, fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), channel, &quot;%p - [frame=%p, main=%d] FrameLoader::&quot; fmt, this, &amp;m_frame, m_frame.isMainFrame(), ##__VA_ARGS__)
 157 #define FRAMELOADER_RELEASE_LOG_ERROR_IF_ALLOWED(channel, fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), channel, &quot;%p - [frame=%p, main=%d] FrameLoader::&quot; fmt, this, &amp;m_frame, m_frame.isMainFrame(), ##__VA_ARGS__)
 158 
 159 namespace WebCore {
 160 
 161 using namespace HTMLNames;
 162 using namespace SVGNames;
 163 
 164 static const char defaultAcceptHeader[] = &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;;
 165 
 166 bool isBackForwardLoadType(FrameLoadType type)
 167 {
 168     switch (type) {
 169     case FrameLoadType::Standard:
 170     case FrameLoadType::Reload:
 171     case FrameLoadType::ReloadFromOrigin:
 172     case FrameLoadType::ReloadExpiredOnly:
 173     case FrameLoadType::Same:
 174     case FrameLoadType::RedirectWithLockedBackForwardList:
 175     case FrameLoadType::Replace:
 176         return false;
 177     case FrameLoadType::Back:
 178     case FrameLoadType::Forward:
 179     case FrameLoadType::IndexedBackForward:
 180         return true;
 181     }
 182     ASSERT_NOT_REACHED();
 183     return false;
 184 }
 185 
 186 bool isReload(FrameLoadType type)
 187 {
 188     switch (type) {
 189     case FrameLoadType::Reload:
 190     case FrameLoadType::ReloadFromOrigin:
 191     case FrameLoadType::ReloadExpiredOnly:
 192         return true;
 193     case FrameLoadType::Standard:
 194     case FrameLoadType::Same:
 195     case FrameLoadType::RedirectWithLockedBackForwardList:
 196     case FrameLoadType::Replace:
 197     case FrameLoadType::Back:
 198     case FrameLoadType::Forward:
 199     case FrameLoadType::IndexedBackForward:
 200         return false;
 201     }
 202     ASSERT_NOT_REACHED();
 203     return false;
 204 }
 205 
 206 // This is not in the FrameLoader class to emphasize that it does not depend on
 207 // private FrameLoader data, and to avoid increasing the number of public functions
 208 // with access to private data.  Since only this .cpp file needs it, making it
 209 // non-member lets us exclude it from the header file, thus keeping FrameLoader.h&#39;s
 210 // API simpler.
 211 //
 212 static bool isDocumentSandboxed(Frame&amp; frame, SandboxFlags mask)
 213 {
 214     return frame.document() &amp;&amp; frame.document()-&gt;isSandboxed(mask);
 215 }
 216 
 217 class PageLevelForbidScope {
 218 protected:
 219     explicit PageLevelForbidScope(Page* page)
 220         : m_page(makeWeakPtr(page))
 221     {
 222     }
 223 
 224     ~PageLevelForbidScope() = default;
 225 
 226     WeakPtr&lt;Page&gt; m_page;
 227 };
 228 
 229 struct ForbidPromptsScope : public PageLevelForbidScope {
 230     explicit ForbidPromptsScope(Page* page)
 231         : PageLevelForbidScope(page)
 232     {
 233         if (m_page)
 234             m_page-&gt;forbidPrompts();
 235     }
 236 
 237     ~ForbidPromptsScope()
 238     {
 239         if (m_page)
 240             m_page-&gt;allowPrompts();
 241     }
 242 };
 243 
 244 struct ForbidSynchronousLoadsScope : public PageLevelForbidScope {
 245     explicit ForbidSynchronousLoadsScope(Page* page)
 246         : PageLevelForbidScope(page)
 247     {
 248         if (m_page)
 249             m_page-&gt;forbidSynchronousLoads();
 250     }
 251 
 252     ~ForbidSynchronousLoadsScope()
 253     {
 254         if (m_page)
 255             m_page-&gt;allowSynchronousLoads();
 256     }
 257 };
 258 
 259 class FrameLoader::FrameProgressTracker {
 260     WTF_MAKE_FAST_ALLOCATED;
 261 public:
 262     explicit FrameProgressTracker(Frame&amp; frame)
 263         : m_frame(frame)
 264         , m_inProgress(false)
 265     {
 266     }
 267 
 268     ~FrameProgressTracker()
 269     {
 270         if (m_inProgress &amp;&amp; m_frame.page())
 271             m_frame.page()-&gt;progress().progressCompleted(m_frame);
 272     }
 273 
 274     void progressStarted()
 275     {
 276         ASSERT(m_frame.page());
 277         if (!m_inProgress)
 278             m_frame.page()-&gt;progress().progressStarted(m_frame);
 279         m_inProgress = true;
 280     }
 281 
 282     void progressCompleted()
 283     {
 284         ASSERT(m_inProgress);
 285         ASSERT(m_frame.page());
 286         m_inProgress = false;
 287         m_frame.page()-&gt;progress().progressCompleted(m_frame);
 288         platformStrategies()-&gt;loaderStrategy()-&gt;pageLoadCompleted(*m_frame.page());
 289     }
 290 
 291 private:
 292     Frame&amp; m_frame;
 293     bool m_inProgress;
 294 };
 295 
 296 FrameLoader::FrameLoader(Frame&amp; frame, FrameLoaderClient&amp; client)
 297     : m_frame(frame)
 298     , m_client(client)
 299     , m_policyChecker(makeUnique&lt;PolicyChecker&gt;(frame))
 300     , m_history(makeUnique&lt;HistoryController&gt;(frame))
 301     , m_notifier(frame)
 302     , m_subframeLoader(makeUnique&lt;SubframeLoader&gt;(frame))
 303     , m_mixedContentChecker(frame)
 304     , m_state(FrameStateProvisional)
 305     , m_loadType(FrameLoadType::Standard)
 306     , m_quickRedirectComing(false)
 307     , m_sentRedirectNotification(false)
 308     , m_inStopAllLoaders(false)
 309     , m_isExecutingJavaScriptFormAction(false)
 310     , m_didCallImplicitClose(true)
 311     , m_wasUnloadEventEmitted(false)
 312     , m_isComplete(false)
 313     , m_needsClear(false)
 314     , m_checkTimer(*this, &amp;FrameLoader::checkTimerFired)
 315     , m_shouldCallCheckCompleted(false)
 316     , m_shouldCallCheckLoadComplete(false)
 317     , m_opener(nullptr)
 318     , m_loadingFromCachedPage(false)
 319     , m_currentNavigationHasShownBeforeUnloadConfirmPanel(false)
 320     , m_loadsSynchronously(false)
 321     , m_forcedSandboxFlags(SandboxNone)
 322 {
 323 }
 324 
 325 FrameLoader::~FrameLoader()
 326 {
 327     setOpener(nullptr);
 328     detachFromAllOpenedFrames();
 329 
 330     m_client.frameLoaderDestroyed();
 331 
 332     if (m_networkingContext)
 333         m_networkingContext-&gt;invalidate();
 334 }
 335 
 336 void FrameLoader::detachFromAllOpenedFrames()
 337 {
 338     for (auto&amp; frame : m_openedFrames)
 339         frame-&gt;loader().m_opener = nullptr;
 340     m_openedFrames.clear();
 341 }
 342 
 343 void FrameLoader::init()
 344 {
 345     // This somewhat odd set of steps gives the frame an initial empty document.
 346     setPolicyDocumentLoader(m_client.createDocumentLoader(ResourceRequest(URL({ }, emptyString())), SubstituteData()).ptr());
 347     setProvisionalDocumentLoader(m_policyDocumentLoader.get());
 348     m_provisionalDocumentLoader-&gt;startLoadingMainResource();
 349 
 350     Ref&lt;Frame&gt; protect(m_frame);
 351     m_frame.document()-&gt;cancelParsing();
 352     m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocument);
 353 
 354     m_networkingContext = m_client.createNetworkingContext();
 355     m_progressTracker = makeUnique&lt;FrameProgressTracker&gt;(m_frame);
 356 }
 357 
 358 void FrameLoader::initForSynthesizedDocument(const URL&amp;)
 359 {
 360     // FIXME: We need to initialize the document URL to the specified URL. Currently the URL is empty and hence
 361     // FrameLoader::checkCompleted() will overwrite the URL of the document to be activeDocumentLoader()-&gt;documentURL().
 362 
 363     auto loader = m_client.createDocumentLoader(ResourceRequest(URL({ }, emptyString())), SubstituteData());
 364     loader-&gt;attachToFrame(m_frame);
 365     loader-&gt;setResponse(ResourceResponse(URL(), &quot;text/html&quot;_s, 0, String()));
 366     loader-&gt;setCommitted(true);
 367     setDocumentLoader(loader.ptr());
 368 
 369     m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocument);
 370     m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocumentPostCommit);
 371     m_stateMachine.advanceTo(FrameLoaderStateMachine::CommittedFirstRealLoad);
 372     m_client.transitionToCommittedForNewPage();
 373 
 374     m_didCallImplicitClose = true;
 375     m_isComplete = true;
 376     m_state = FrameStateComplete;
 377     m_needsClear = true;
 378 
 379     m_networkingContext = m_client.createNetworkingContext();
 380     m_progressTracker = makeUnique&lt;FrameProgressTracker&gt;(m_frame);
 381 }
 382 
 383 void FrameLoader::setDefersLoading(bool defers)
 384 {
 385     if (m_documentLoader)
 386         m_documentLoader-&gt;setDefersLoading(defers);
 387     if (m_provisionalDocumentLoader)
 388         m_provisionalDocumentLoader-&gt;setDefersLoading(defers);
 389     if (m_policyDocumentLoader)
 390         m_policyDocumentLoader-&gt;setDefersLoading(defers);
 391     history().setDefersLoading(defers);
 392 
 393     if (!defers) {
 394         m_frame.navigationScheduler().startTimer();
 395         startCheckCompleteTimer();
 396     }
 397 }
 398 
 399 void FrameLoader::checkContentPolicy(const ResourceResponse&amp; response, PolicyCheckIdentifier identifier, ContentPolicyDecisionFunction&amp;&amp; function)
 400 {
 401     if (!activeDocumentLoader()) {
 402         // Load was cancelled
 403         function(PolicyAction::Ignore, identifier);
 404         return;
 405     }
 406 
 407     // FIXME: Validate the policy check identifier.
 408     client().dispatchDecidePolicyForResponse(response, activeDocumentLoader()-&gt;request(), identifier, activeDocumentLoader()-&gt;downloadAttribute(), WTFMove(function));
 409 }
 410 
 411 void FrameLoader::changeLocation(FrameLoadRequest&amp;&amp; request)
 412 {
 413     urlSelected(WTFMove(request), nullptr);
 414 }
 415 
 416 void FrameLoader::urlSelected(const URL&amp; url, const String&amp; passedTarget, Event* triggeringEvent, LockHistory lockHistory, LockBackForwardList lockBackForwardList, ShouldSendReferrer shouldSendReferrer, ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy, Optional&lt;NewFrameOpenerPolicy&gt; openerPolicy, const AtomString&amp; downloadAttribute, const SystemPreviewInfo&amp; systemPreviewInfo, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)
 417 {
 418     auto* frame = lexicalFrameFromCommonVM();
 419     auto initiatedByMainFrame = frame &amp;&amp; frame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
 420 
 421     NewFrameOpenerPolicy newFrameOpenerPolicy = openerPolicy.valueOr(shouldSendReferrer == NeverSendReferrer ? NewFrameOpenerPolicy::Suppress : NewFrameOpenerPolicy::Allow);
 422     urlSelected(FrameLoadRequest(*m_frame.document(), m_frame.document()-&gt;securityOrigin(), { url }, passedTarget, lockHistory, lockBackForwardList, shouldSendReferrer, AllowNavigationToInvalidURL::Yes, newFrameOpenerPolicy, shouldOpenExternalURLsPolicy, initiatedByMainFrame, DoNotReplaceDocumentIfJavaScriptURL, downloadAttribute, systemPreviewInfo), triggeringEvent, WTFMove(adClickAttribution));
 423 }
 424 
 425 void FrameLoader::urlSelected(FrameLoadRequest&amp;&amp; frameRequest, Event* triggeringEvent, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)
 426 {
 427     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;urlSelected: frame load started&quot;);
 428 
 429     Ref&lt;Frame&gt; protect(m_frame);
 430 
 431     if (m_frame.script().executeIfJavaScriptURL(frameRequest.resourceRequest().url(), &amp;frameRequest.requester().securityOrigin(), frameRequest.shouldReplaceDocumentIfJavaScriptURL())) {
 432         m_quickRedirectComing = false;
 433         return;
 434     }
 435 
 436     if (frameRequest.frameName().isEmpty())
 437         frameRequest.setFrameName(m_frame.document()-&gt;baseTarget());
 438 
 439     addHTTPOriginIfNeeded(frameRequest.resourceRequest(), outgoingOrigin());
 440     m_frame.document()-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(frameRequest.resourceRequest(), ContentSecurityPolicy::InsecureRequestType::Navigation);
 441 
 442     loadFrameRequest(WTFMove(frameRequest), triggeringEvent, { }, WTFMove(adClickAttribution));
 443 }
 444 
 445 void FrameLoader::submitForm(Ref&lt;FormSubmission&gt;&amp;&amp; submission)
 446 {
 447     ASSERT(submission-&gt;method() == FormSubmission::Method::Post || submission-&gt;method() == FormSubmission::Method::Get);
 448 
 449     // FIXME: Find a good spot for these.
 450     ASSERT(!submission-&gt;state().sourceDocument().frame() || submission-&gt;state().sourceDocument().frame() == &amp;m_frame);
 451 
 452     if (!m_frame.page())
 453         return;
 454 
 455     if (submission-&gt;action().isEmpty())
 456         return;
 457 
 458     if (isDocumentSandboxed(m_frame, SandboxForms)) {
 459         // FIXME: This message should be moved off the console once a solution to https://bugs.webkit.org/show_bug.cgi?id=103274 exists.
 460         m_frame.document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Blocked form submission to &#39;&quot; + submission-&gt;action().stringCenterEllipsizedToLength() + &quot;&#39; because the form&#39;s frame is sandboxed and the &#39;allow-forms&#39; permission is not set.&quot;);
 461         return;
 462     }
 463 
 464     if (WTF::protocolIsJavaScript(submission-&gt;action())) {
 465         if (!m_frame.document()-&gt;contentSecurityPolicy()-&gt;allowFormAction(URL(submission-&gt;action())))
 466             return;
 467         m_isExecutingJavaScriptFormAction = true;
 468         Ref&lt;Frame&gt; protect(m_frame);
 469         m_frame.script().executeIfJavaScriptURL(submission-&gt;action(), nullptr, DoNotReplaceDocumentIfJavaScriptURL);
 470         m_isExecutingJavaScriptFormAction = false;
 471         return;
 472     }
 473 
 474     Frame* targetFrame = findFrameForNavigation(submission-&gt;target(), &amp;submission-&gt;state().sourceDocument());
 475     if (!targetFrame) {
 476         if (!DOMWindow::allowPopUp(m_frame) &amp;&amp; !UserGestureIndicator::processingUserGesture())
 477             return;
 478 
 479         // FIXME: targetFrame can be null for two distinct reasons:
 480         // 1. The frame was not found by name, so we should try opening a new window.
 481         // 2. The frame was found, but navigating it was not allowed, e.g. by HTML5 sandbox or by origin checks.
 482         // Continuing form submission makes no sense in the latter case.
 483         // There is a repeat check after timer fires, so this is not a correctness issue.
 484 
 485         targetFrame = &amp;m_frame;
 486     } else
 487         submission-&gt;clearTarget();
 488 
 489     if (!targetFrame-&gt;page())
 490         return;
 491 
 492     if (m_frame.tree().isDescendantOf(targetFrame))
 493         m_submittedFormURL = submission-&gt;requestURL();
 494 
 495     submission-&gt;setReferrer(outgoingReferrer());
 496     submission-&gt;setOrigin(outgoingOrigin());
 497 
 498     targetFrame-&gt;navigationScheduler().scheduleFormSubmission(WTFMove(submission));
 499 }
 500 
 501 void FrameLoader::stopLoading(UnloadEventPolicy unloadEventPolicy)
 502 {
 503     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;parser())
 504         m_frame.document()-&gt;parser()-&gt;stopParsing();
 505 
 506     if (unloadEventPolicy != UnloadEventPolicyNone)
 507         dispatchUnloadEvents(unloadEventPolicy);
 508 
 509     m_isComplete = true; // to avoid calling completed() in finishedParsing()
 510     m_didCallImplicitClose = true; // don&#39;t want that one either
 511 
 512     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;parsing()) {
 513         finishedParsing();
 514         m_frame.document()-&gt;setParsing(false);
 515     }
 516 
 517     if (auto* document = m_frame.document()) {
 518         // FIXME: Should the DatabaseManager watch for something like ActiveDOMObject::stop() rather than being special-cased here?
 519         DatabaseManager::singleton().stopDatabases(*document, nullptr);
 520     }
 521 
 522     policyChecker().stopCheck();
 523 
 524     // FIXME: This will cancel redirection timer, which really needs to be restarted when restoring the frame from b/f cache.
 525     m_frame.navigationScheduler().cancel();
 526 }
 527 
 528 void FrameLoader::stop()
 529 {
 530     // http://bugs.webkit.org/show_bug.cgi?id=10854
 531     // The frame&#39;s last ref may be removed and it will be deleted by checkCompleted().
 532     Ref&lt;Frame&gt; protect(m_frame);
 533 
 534     if (DocumentParser* parser = m_frame.document()-&gt;parser()) {
 535         parser-&gt;stopParsing();
 536         parser-&gt;finish();
 537     }
 538 }
 539 
 540 void FrameLoader::willTransitionToCommitted()
 541 {
 542     // This function is called when a frame is still fully in place (not cached, not detached), but will be replaced.
 543 
 544     if (m_frame.editor().hasComposition()) {
 545         // The text was already present in DOM, so it&#39;s better to confirm than to cancel the composition.
 546         m_frame.editor().confirmComposition();
 547         if (EditorClient* editorClient = m_frame.editor().client()) {
 548             editorClient-&gt;respondToChangedSelection(&amp;m_frame);
 549             editorClient-&gt;discardedComposition(&amp;m_frame);
 550         }
 551     }
 552 }
 553 
 554 bool FrameLoader::closeURL()
 555 {
 556     history().saveDocumentState();
 557 
 558     Document* currentDocument = m_frame.document();
 559     UnloadEventPolicy unloadEventPolicy;
 560     if (m_frame.page() &amp;&amp; m_frame.page()-&gt;chrome().client().isSVGImageChromeClient()) {
 561         // If this is the SVGDocument of an SVGImage, no need to dispatch events or recalcStyle.
 562         unloadEventPolicy = UnloadEventPolicyNone;
 563     } else {
 564         // Should only send the pagehide event here if the current document exists and has not been placed in the back/forward cache.
 565         unloadEventPolicy = currentDocument &amp;&amp; currentDocument-&gt;backForwardCacheState() == Document::NotInBackForwardCache ? UnloadEventPolicyUnloadAndPageHide : UnloadEventPolicyUnloadOnly;
 566     }
 567 
 568     stopLoading(unloadEventPolicy);
 569 
 570     m_frame.editor().clearUndoRedoOperations();
 571     return true;
 572 }
 573 
 574 bool FrameLoader::didOpenURL()
 575 {
 576     if (m_frame.navigationScheduler().redirectScheduledDuringLoad()) {
 577         // A redirect was scheduled before the document was created.
 578         // This can happen when one frame changes another frame&#39;s location.
 579         return false;
 580     }
 581 
 582     m_frame.navigationScheduler().cancel();
 583     m_frame.editor().clearLastEditCommand();
 584 
 585     m_isComplete = false;
 586     m_didCallImplicitClose = false;
 587 
 588     // If we are still in the process of initializing an empty document then
 589     // its frame is not in a consistent state for rendering, so avoid setJSStatusBarText
 590     // since it may cause clients to attempt to render the frame.
 591     if (!m_stateMachine.creatingInitialEmptyDocument()) {
 592         DOMWindow* window = m_frame.document()-&gt;domWindow();
 593         window-&gt;setStatus(String());
 594         window-&gt;setDefaultStatus(String());
 595     }
 596 
 597     started();
 598 
 599     return true;
 600 }
 601 
 602 void FrameLoader::didExplicitOpen()
 603 {
 604     m_isComplete = false;
 605     m_didCallImplicitClose = false;
 606 
 607     // Calling document.open counts as committing the first real document load.
 608     if (!m_stateMachine.committedFirstRealDocumentLoad())
 609         m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocumentPostCommit);
 610 
 611     if (auto* document = m_frame.document())
 612         m_client.dispatchDidExplicitOpen(document-&gt;url(), document-&gt;contentType());
 613 
 614     // Prevent window.open(url) -- eg window.open(&quot;about:blank&quot;) -- from blowing away results
 615     // from a subsequent window.document.open / window.document.write call.
 616     // Canceling redirection here works for all cases because document.open
 617     // implicitly precedes document.write.
 618     m_frame.navigationScheduler().cancel();
 619 }
 620 
 621 
 622 void FrameLoader::cancelAndClear()
 623 {
 624     m_frame.navigationScheduler().cancel();
 625 
 626     if (!m_isComplete)
 627         closeURL();
 628 
 629     clear(m_frame.document(), false);
 630     m_frame.script().updatePlatformScriptObjects();
 631 }
 632 
 633 static inline bool shouldClearWindowName(const Frame&amp; frame, const Document&amp; newDocument)
 634 {
 635     if (!frame.isMainFrame())
 636         return false;
 637 
 638     if (frame.loader().opener())
 639         return false;
 640 
 641     return !newDocument.securityOrigin().isSameOriginAs(frame.document()-&gt;securityOrigin());
 642 }
 643 
 644 void FrameLoader::clear(Document* newDocument, bool clearWindowProperties, bool clearScriptObjects, bool clearFrameView, WTF::Function&lt;void()&gt;&amp;&amp; handleDOMWindowCreation)
 645 {
 646     m_frame.editor().clear();
 647 
 648     bool neededClear = m_needsClear;
 649     m_needsClear = false;
 650 
 651     if (neededClear &amp;&amp; m_frame.document()-&gt;backForwardCacheState() != Document::InBackForwardCache) {
 652         m_frame.document()-&gt;cancelParsing();
 653         m_frame.document()-&gt;stopActiveDOMObjects();
 654         bool hadLivingRenderTree = m_frame.document()-&gt;hasLivingRenderTree();
 655         m_frame.document()-&gt;prepareForDestruction();
 656         if (hadLivingRenderTree)
 657             m_frame.document()-&gt;adjustFocusedNodeOnNodeRemoval(*m_frame.document());
 658     }
 659 
 660     if (handleDOMWindowCreation)
 661         handleDOMWindowCreation();
 662 
 663     if (!neededClear)
 664         return;
 665 
 666     // Do this after detaching the document so that the unload event works.
 667     if (clearWindowProperties) {
 668         InspectorInstrumentation::frameWindowDiscarded(m_frame, m_frame.document()-&gt;domWindow());
 669         m_frame.document()-&gt;domWindow()-&gt;resetUnlessSuspendedForDocumentSuspension();
 670         m_frame.windowProxy().clearJSWindowProxiesNotMatchingDOMWindow(newDocument-&gt;domWindow(), m_frame.document()-&gt;backForwardCacheState() == Document::AboutToEnterBackForwardCache);
 671 
 672         if (shouldClearWindowName(m_frame, *newDocument))
 673             m_frame.tree().setName(nullAtom());
 674     }
 675 
 676     m_frame.selection().prepareForDestruction();
 677     m_frame.eventHandler().clear();
 678 
 679     if (clearFrameView &amp;&amp; m_frame.view())
 680         m_frame.view()-&gt;clear();
 681 
 682     // Do not drop the document before the ScriptController and view are cleared
 683     // as some destructors might still try to access the document.
 684     m_frame.setDocument(nullptr);
 685 
 686     subframeLoader().clear();
 687 
 688     if (clearWindowProperties)
 689         m_frame.windowProxy().setDOMWindow(newDocument-&gt;domWindow());
 690 
 691     if (clearScriptObjects)
 692         m_frame.script().clearScriptObjects();
 693 
 694     m_frame.script().enableEval();
 695 
 696     m_frame.navigationScheduler().clear();
 697 
 698     m_checkTimer.stop();
 699     m_shouldCallCheckCompleted = false;
 700     m_shouldCallCheckLoadComplete = false;
 701 
 702     if (m_stateMachine.isDisplayingInitialEmptyDocument() &amp;&amp; m_stateMachine.committedFirstRealDocumentLoad())
 703         m_stateMachine.advanceTo(FrameLoaderStateMachine::CommittedFirstRealLoad);
 704 }
 705 
 706 void FrameLoader::receivedFirstData()
 707 {
 708     dispatchDidCommitLoad(WTF::nullopt);
 709     dispatchDidClearWindowObjectsInAllWorlds();
 710     dispatchGlobalObjectAvailableInAllWorlds();
 711 
 712     if (!m_documentLoader)
 713         return;
 714 
 715     auto&amp; documentLoader = *m_documentLoader;
 716     auto&amp; title = documentLoader.title();
 717     if (!title.string.isNull())
 718         m_client.dispatchDidReceiveTitle(title);
 719 
 720     ASSERT(m_frame.document());
 721     auto&amp; document = *m_frame.document();
 722 
 723     LinkLoader::loadLinksFromHeader(documentLoader.response().httpHeaderField(HTTPHeaderName::Link), document.url(), document, LinkLoader::MediaAttributeCheck::MediaAttributeEmpty);
 724 
 725     double delay;
 726     String urlString;
 727     if (!parseMetaHTTPEquivRefresh(documentLoader.response().httpHeaderField(HTTPHeaderName::Refresh), delay, urlString))
 728         return;
 729     auto completedURL = urlString.isEmpty() ? document.url() : document.completeURL(urlString);
 730     if (!WTF::protocolIsJavaScript(completedURL))
 731         m_frame.navigationScheduler().scheduleRedirect(document, delay, completedURL);
 732     else {
 733         auto message = &quot;Refused to refresh &quot; + document.url().stringCenterEllipsizedToLength() + &quot; to a javascript: URL&quot;;
 734         document.addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
 735     }
 736 }
 737 
 738 void FrameLoader::setOutgoingReferrer(const URL&amp; url)
 739 {
 740     m_outgoingReferrer = url.strippedForUseAsReferrer();
 741 }
 742 
 743 void FrameLoader::didBeginDocument(bool dispatch)
 744 {
 745     m_needsClear = true;
 746     m_isComplete = false;
 747     m_didCallImplicitClose = false;
 748     m_frame.document()-&gt;setReadyState(Document::Loading);
 749 
 750     if (m_pendingStateObject) {
 751         m_frame.document()-&gt;statePopped(*m_pendingStateObject);
 752         m_pendingStateObject = nullptr;
 753     }
 754 
 755     if (dispatch)
 756         dispatchDidClearWindowObjectsInAllWorlds();
 757 
 758     updateFirstPartyForCookies();
 759     m_frame.document()-&gt;initContentSecurityPolicy();
 760 
 761     const Settings&amp; settings = m_frame.settings();
 762     m_frame.document()-&gt;cachedResourceLoader().setImagesEnabled(settings.areImagesEnabled());
 763     m_frame.document()-&gt;cachedResourceLoader().setAutoLoadImages(settings.loadsImagesAutomatically());
 764 
 765     if (m_documentLoader) {
 766         String dnsPrefetchControl = m_documentLoader-&gt;response().httpHeaderField(HTTPHeaderName::XDNSPrefetchControl);
 767         if (!dnsPrefetchControl.isEmpty())
 768             m_frame.document()-&gt;parseDNSPrefetchControlHeader(dnsPrefetchControl);
 769 
 770         m_frame.document()-&gt;contentSecurityPolicy()-&gt;didReceiveHeaders(ContentSecurityPolicyResponseHeaders(m_documentLoader-&gt;response()), referrer(), ContentSecurityPolicy::ReportParsingErrors::No);
 771 
 772         String referrerPolicy = m_documentLoader-&gt;response().httpHeaderField(HTTPHeaderName::ReferrerPolicy);
 773         if (!referrerPolicy.isNull())
 774             m_frame.document()-&gt;processReferrerPolicy(referrerPolicy, ReferrerPolicySource::HTTPHeader);
 775 
 776         String headerContentLanguage = m_documentLoader-&gt;response().httpHeaderField(HTTPHeaderName::ContentLanguage);
 777         if (!headerContentLanguage.isEmpty()) {
 778             size_t commaIndex = headerContentLanguage.find(&#39;,&#39;);
 779             headerContentLanguage.truncate(commaIndex); // notFound == -1 == don&#39;t truncate
 780             headerContentLanguage = stripLeadingAndTrailingHTMLSpaces(headerContentLanguage);
 781             if (!headerContentLanguage.isEmpty())
 782                 m_frame.document()-&gt;setContentLanguage(headerContentLanguage);
 783         }
 784     }
 785 
 786     history().restoreDocumentState();
 787 }
 788 
 789 void FrameLoader::finishedParsing()
 790 {
 791     LOG(Loading, &quot;WebCoreLoading %s: Finished parsing&quot;, m_frame.tree().uniqueName().string().utf8().data());
 792 
 793     m_frame.injectUserScripts(InjectAtDocumentEnd);
 794 
 795     if (m_stateMachine.creatingInitialEmptyDocument())
 796         return;
 797 
 798     // This can be called from the Frame&#39;s destructor, in which case we shouldn&#39;t protect ourselves
 799     // because doing so will cause us to re-enter the destructor when protector goes out of scope.
 800     // Null-checking the FrameView indicates whether or not we&#39;re in the destructor.
 801     RefPtr&lt;Frame&gt; protector = m_frame.view() ? &amp;m_frame : 0;
 802 
 803     m_client.dispatchDidFinishDocumentLoad();
 804 
 805     scrollToFragmentWithParentBoundary(m_frame.document()-&gt;url());
 806 
 807     checkCompleted();
 808 
 809     if (!m_frame.view())
 810         return; // We are being destroyed by something checkCompleted called.
 811 
 812     // Check if the scrollbars are really needed for the content.
 813     // If not, remove them, relayout, and repaint.
 814     m_frame.view()-&gt;restoreScrollbar();
 815 }
 816 
 817 void FrameLoader::loadDone(LoadCompletionType type)
 818 {
 819     if (type == LoadCompletionType::Finish)
 820         checkCompleted();
 821     else
 822         scheduleCheckCompleted();
 823 }
 824 
 825 void FrameLoader::subresourceLoadDone(LoadCompletionType type)
 826 {
 827     if (type == LoadCompletionType::Finish)
 828         checkLoadComplete();
 829     else
 830         scheduleCheckLoadComplete();
 831 }
 832 
 833 bool FrameLoader::allChildrenAreComplete() const
 834 {
 835     for (Frame* child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling()) {
 836         if (!child-&gt;loader().m_isComplete)
 837             return false;
 838     }
 839     return true;
 840 }
 841 
 842 bool FrameLoader::allAncestorsAreComplete() const
 843 {
 844     for (Frame* ancestor = &amp;m_frame; ancestor; ancestor = ancestor-&gt;tree().parent()) {
 845         if (!ancestor-&gt;loader().m_isComplete)
 846             return false;
 847     }
 848     return true;
 849 }
 850 
 851 void FrameLoader::checkCompleted()
 852 {
 853     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
 854     m_shouldCallCheckCompleted = false;
 855 
 856     // Have we completed before?
 857     if (m_isComplete)
 858         return;
 859 
 860     // FIXME: It would be better if resource loads were kicked off after render tree update (or didn&#39;t complete synchronously).
 861     //        https://bugs.webkit.org/show_bug.cgi?id=171729
 862     if (m_frame.document()-&gt;inRenderTreeUpdate()) {
 863         scheduleCheckCompleted();
 864         return;
 865     }
 866 
 867     // Are we still parsing?
 868     if (m_frame.document()-&gt;parsing())
 869         return;
 870 
 871     // Still waiting for images/scripts?
 872     if (m_frame.document()-&gt;cachedResourceLoader().requestCount())
 873         return;
 874 
 875     // Still waiting for elements that don&#39;t go through a FrameLoader?
 876     if (m_frame.document()-&gt;isDelayingLoadEvent())
 877         return;
 878 
 879     auto* scriptableParser = m_frame.document()-&gt;scriptableDocumentParser();
 880     if (scriptableParser &amp;&amp; scriptableParser-&gt;hasScriptsWaitingForStylesheets())
 881         return;
 882 
 883     // Any frame that hasn&#39;t completed yet?
 884     if (!allChildrenAreComplete())
 885         return;
 886 
 887     // Important not to protect earlier in this function, because earlier parts
 888     // of this function can be called in the frame&#39;s destructor, and it&#39;s not legal
 889     // to ref an object while it&#39;s being destroyed.
 890     Ref&lt;Frame&gt; protect(m_frame);
 891 
 892     // OK, completed.
 893     m_isComplete = true;
 894     m_requestedHistoryItem = nullptr;
 895     m_frame.document()-&gt;setReadyState(Document::Complete);
 896 
 897     checkCallImplicitClose(); // if we didn&#39;t do it before
 898 
 899     m_frame.navigationScheduler().startTimer();
 900 
 901     completed();
 902     if (m_frame.page())
 903         checkLoadComplete();
 904 }
 905 
 906 void FrameLoader::checkTimerFired()
 907 {
 908     checkCompletenessNow();
 909 }
 910 
 911 void FrameLoader::checkCompletenessNow()
 912 {
 913     Ref&lt;Frame&gt; protect(m_frame);
 914 
 915     if (Page* page = m_frame.page()) {
 916         if (page-&gt;defersLoading())
 917             return;
 918     }
 919     if (m_shouldCallCheckCompleted)
 920         checkCompleted();
 921     if (m_shouldCallCheckLoadComplete)
 922         checkLoadComplete();
 923 }
 924 
 925 void FrameLoader::startCheckCompleteTimer()
 926 {
 927     if (!(m_shouldCallCheckCompleted || m_shouldCallCheckLoadComplete))
 928         return;
 929     if (m_checkTimer.isActive())
 930         return;
 931     m_checkTimer.startOneShot(0_s);
 932 }
 933 
 934 void FrameLoader::scheduleCheckCompleted()
 935 {
 936     m_shouldCallCheckCompleted = true;
 937     startCheckCompleteTimer();
 938 }
 939 
 940 void FrameLoader::scheduleCheckLoadComplete()
 941 {
 942     m_shouldCallCheckLoadComplete = true;
 943     startCheckCompleteTimer();
 944 }
 945 
 946 void FrameLoader::checkCallImplicitClose()
 947 {
 948     if (m_didCallImplicitClose || m_frame.document()-&gt;parsing() || m_frame.document()-&gt;isDelayingLoadEvent())
 949         return;
 950 
 951     if (!allChildrenAreComplete())
 952         return; // still got a frame running -&gt; too early
 953 
 954     m_didCallImplicitClose = true;
 955     m_wasUnloadEventEmitted = false;
 956     m_frame.document()-&gt;implicitClose();
 957 }
 958 
 959 void FrameLoader::loadURLIntoChildFrame(const URL&amp; url, const String&amp; referer, Frame* childFrame)
 960 {
 961     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadURLIntoChildFrame: frame load started&quot;);
 962 
 963     ASSERT(childFrame);
 964 
 965 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 966     if (auto activeLoader = activeDocumentLoader()) {
 967         if (auto subframeArchive = activeLoader-&gt;popArchiveForSubframe(childFrame-&gt;tree().uniqueName(), url)) {
 968             childFrame-&gt;loader().loadArchive(RefPtr&lt;Archive&gt; { subframeArchive }.releaseNonNull());
 969             return;
 970         }
 971     }
 972 #endif
 973 
 974     // If we&#39;re moving in the back/forward list, we might want to replace the content
 975     // of this child frame with whatever was there at that point.
 976     auto* parentItem = history().currentItem();
 977     if (parentItem &amp;&amp; parentItem-&gt;children().size() &amp;&amp; isBackForwardLoadType(loadType()) &amp;&amp; !m_frame.document()-&gt;loadEventFinished()) {
 978         if (auto* childItem = parentItem-&gt;childItemWithTarget(childFrame-&gt;tree().uniqueName())) {
 979             childFrame-&gt;loader().m_requestedHistoryItem = childItem;
 980             childFrame-&gt;loader().loadDifferentDocumentItem(*childItem, nullptr, loadType(), MayAttemptCacheOnlyLoadForFormSubmissionItem, ShouldTreatAsContinuingLoad::No);
 981             return;
 982         }
 983     }
 984 
 985     auto* lexicalFrame = lexicalFrameFromCommonVM();
 986     auto initiatedByMainFrame = lexicalFrame &amp;&amp; lexicalFrame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
 987 
 988     FrameLoadRequest frameLoadRequest { *m_frame.document(), m_frame.document()-&gt;securityOrigin(), { url }, &quot;_self&quot;_s, LockHistory::No, LockBackForwardList::Yes, ShouldSendReferrer::MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Suppress, ShouldOpenExternalURLsPolicy::ShouldNotAllow, initiatedByMainFrame };
 989     childFrame-&gt;loader().loadURL(WTFMove(frameLoadRequest), referer, FrameLoadType::RedirectWithLockedBackForwardList, nullptr, { }, WTF::nullopt, [] { });
 990 }
 991 
 992 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 993 
 994 void FrameLoader::loadArchive(Ref&lt;Archive&gt;&amp;&amp; archive)
 995 {
 996     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadArchive: frame load started&quot;);
 997 
 998     ArchiveResource* mainResource = archive-&gt;mainResource();
 999     ASSERT(mainResource);
1000     if (!mainResource)
1001         return;
1002 
1003     ResourceResponse response(URL(), mainResource-&gt;mimeType(), mainResource-&gt;data().size(), mainResource-&gt;textEncoding());
1004     SubstituteData substituteData(&amp;mainResource-&gt;data(), URL(), response, SubstituteData::SessionHistoryVisibility::Hidden);
1005 
1006     ResourceRequest request(mainResource-&gt;url());
1007 
1008     auto documentLoader = m_client.createDocumentLoader(request, substituteData);
1009     documentLoader-&gt;setArchive(WTFMove(archive));
1010     load(documentLoader.get());
1011 }
1012 
1013 #endif // ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1014 
1015 String FrameLoader::outgoingReferrer() const
1016 {
1017     // See http://www.whatwg.org/specs/web-apps/current-work/#fetching-resources
1018     // for why we walk the parent chain for srcdoc documents.
1019     Frame* frame = &amp;m_frame;
1020     while (frame &amp;&amp; frame-&gt;document()-&gt;isSrcdocDocument()) {
1021         frame = frame-&gt;tree().parent();
1022         // Srcdoc documents cannot be top-level documents, by definition,
1023         // because they need to be contained in iframes with the srcdoc.
1024         ASSERT(frame);
1025     }
1026     if (!frame)
1027         return emptyString();
1028     return frame-&gt;loader().m_outgoingReferrer;
1029 }
1030 
1031 String FrameLoader::outgoingOrigin() const
1032 {
1033     return m_frame.document()-&gt;securityOrigin().toString();
1034 }
1035 
1036 bool FrameLoader::checkIfFormActionAllowedByCSP(const URL&amp; url, bool didReceiveRedirectResponse) const
1037 {
1038     if (m_submittedFormURL.isEmpty())
1039         return true;
1040 
1041     auto redirectResponseReceived = didReceiveRedirectResponse ? ContentSecurityPolicy::RedirectResponseReceived::Yes : ContentSecurityPolicy::RedirectResponseReceived::No;
1042     return m_frame.document()-&gt;contentSecurityPolicy()-&gt;allowFormAction(url, redirectResponseReceived);
1043 }
1044 
1045 Frame* FrameLoader::opener()
1046 {
1047     return m_opener;
1048 }
1049 
1050 void FrameLoader::setOpener(Frame* opener)
1051 {
1052     if (m_opener &amp;&amp; !opener)
1053         m_client.didDisownOpener();
1054 
1055     if (m_opener) {
1056         // When setOpener is called in ~FrameLoader, opener&#39;s m_frameLoader is already cleared.
1057         auto&amp; openerFrameLoader = m_opener == &amp;m_frame ? *this : m_opener-&gt;loader();
1058         openerFrameLoader.m_openedFrames.remove(&amp;m_frame);
1059     }
1060     if (opener) {
1061         opener-&gt;loader().m_openedFrames.add(&amp;m_frame);
1062         if (auto* page = m_frame.page())
1063             page-&gt;setOpenedByDOMWithOpener();
1064     }
1065     m_opener = opener;
1066 
1067     if (m_frame.document())
1068         m_frame.document()-&gt;initSecurityContext();
1069 }
1070 
1071 // FIXME: This does not belong in FrameLoader!
1072 void FrameLoader::handleFallbackContent()
1073 {
1074     HTMLFrameOwnerElement* owner = m_frame.ownerElement();
1075     if (!is&lt;HTMLObjectElement&gt;(owner))
1076         return;
1077     downcast&lt;HTMLObjectElement&gt;(*owner).renderFallbackContent();
1078 }
1079 
1080 void FrameLoader::provisionalLoadStarted()
1081 {
1082     if (m_stateMachine.firstLayoutDone())
1083         m_stateMachine.advanceTo(FrameLoaderStateMachine::CommittedFirstRealLoad);
1084     m_frame.navigationScheduler().cancel(NewLoadInProgress::Yes);
1085     m_client.provisionalLoadStarted();
1086 
1087     if (m_frame.isMainFrame()) {
1088         tracePoint(MainResourceLoadDidStartProvisional);
1089 
1090         if (auto* page = m_frame.page())
1091             page-&gt;didStartProvisionalLoad();
1092     }
1093 }
1094 
1095 void FrameLoader::resetMultipleFormSubmissionProtection()
1096 {
1097     m_submittedFormURL = URL();
1098 }
1099 
1100 void FrameLoader::updateFirstPartyForCookies()
1101 {
1102     if (m_frame.tree().parent())
1103         setFirstPartyForCookies(m_frame.tree().parent()-&gt;document()-&gt;firstPartyForCookies());
1104     else
1105         setFirstPartyForCookies(m_frame.document()-&gt;url());
1106 }
1107 
1108 void FrameLoader::setFirstPartyForCookies(const URL&amp; url)
1109 {
1110     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame))
1111         frame-&gt;document()-&gt;setFirstPartyForCookies(url);
1112 
1113     RegistrableDomain registrableDomain(url);
1114     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame)) {
1115         if (SecurityPolicy::shouldInheritSecurityOriginFromOwner(frame-&gt;document()-&gt;url()) || registrableDomain.matches(frame-&gt;document()-&gt;url()))
1116             frame-&gt;document()-&gt;setSiteForCookies(url);
1117     }
1118 }
1119 
1120 // This does the same kind of work that didOpenURL does, except it relies on the fact
1121 // that a higher level already checked that the URLs match and the scrolling is the right thing to do.
1122 void FrameLoader::loadInSameDocument(const URL&amp; url, SerializedScriptValue* stateObject, bool isNewNavigation)
1123 {
1124     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadInSameDocument: frame load started&quot;);
1125 
1126     // If we have a state object, we cannot also be a new navigation.
1127     ASSERT(!stateObject || (stateObject &amp;&amp; !isNewNavigation));
1128 
1129     // Update the data source&#39;s request with the new URL to fake the URL change
1130     URL oldURL = m_frame.document()-&gt;url();
1131     m_frame.document()-&gt;setURL(url);
1132     setOutgoingReferrer(url);
1133     documentLoader()-&gt;replaceRequestURLForSameDocumentNavigation(url);
1134     if (isNewNavigation &amp;&amp; !shouldTreatURLAsSameAsCurrent(url) &amp;&amp; !stateObject) {
1135         // NB: must happen after replaceRequestURLForSameDocumentNavigation(), since we add
1136         // based on the current request. Must also happen before we openURL and displace the
1137         // scroll position, since adding the BF item will save away scroll state.
1138 
1139         // NB2: If we were loading a long, slow doc, and the user fragment navigated before
1140         // it was done, currItem is now set the that slow doc, and prevItem is whatever was
1141         // before it.  Adding the b/f item will bump the slow doc down to prevItem, even
1142         // though its load is not yet done.  I think this all works out OK, for one because
1143         // we have already saved away the scroll and doc state for the long slow load,
1144         // but it&#39;s not an obvious case.
1145 
1146         history().updateBackForwardListForFragmentScroll();
1147     }
1148 
1149     bool hashChange = equalIgnoringFragmentIdentifier(url, oldURL) &amp;&amp; url.fragmentIdentifier() != oldURL.fragmentIdentifier();
1150 
1151     history().updateForSameDocumentNavigation();
1152 
1153     // If we were in the autoscroll/panScroll mode we want to stop it before following the link to the anchor
1154     if (hashChange)
1155         m_frame.eventHandler().stopAutoscrollTimer();
1156 
1157     // It&#39;s important to model this as a load that starts and immediately finishes.
1158     // Otherwise, the parent frame may think we never finished loading.
1159     started();
1160 
1161     if (auto* ownerElement = m_frame.ownerElement()) {
1162         auto* ownerRenderer = ownerElement-&gt;renderer();
1163         auto* view = m_frame.view();
1164         if (is&lt;RenderWidget&gt;(ownerRenderer) &amp;&amp; view)
1165             downcast&lt;RenderWidget&gt;(*ownerRenderer).setWidget(view);
1166     }
1167 
1168     // We need to scroll to the fragment whether or not a hash change occurred, since
1169     // the user might have scrolled since the previous navigation.
1170     scrollToFragmentWithParentBoundary(url, isNewNavigation);
1171 
1172     m_isComplete = false;
1173     checkCompleted();
1174 
1175     if (isNewNavigation) {
1176         // This will clear previousItem from the rest of the frame tree that didn&#39;t
1177         // doing any loading. We need to make a pass on this now, since for fragment
1178         // navigation we&#39;ll not go through a real load and reach Completed state.
1179         checkLoadComplete();
1180     }
1181 
1182     m_client.dispatchDidNavigateWithinPage();
1183 
1184     m_frame.document()-&gt;statePopped(stateObject ? Ref&lt;SerializedScriptValue&gt; { *stateObject } : SerializedScriptValue::nullValue());
1185     m_client.dispatchDidPopStateWithinPage();
1186 
1187     if (hashChange) {
1188         m_frame.document()-&gt;enqueueHashchangeEvent(oldURL, url);
1189         m_client.dispatchDidChangeLocationWithinPage();
1190     }
1191 
1192     // FrameLoaderClient::didFinishLoad() tells the internal load delegate the load finished with no error
1193     m_client.didFinishLoad();
1194 }
1195 
1196 bool FrameLoader::isComplete() const
1197 {
1198     return m_isComplete;
1199 }
1200 
1201 void FrameLoader::completed()
1202 {
1203     Ref&lt;Frame&gt; protect(m_frame);
1204 
1205     for (Frame* descendant = m_frame.tree().traverseNext(&amp;m_frame); descendant; descendant = descendant-&gt;tree().traverseNext(&amp;m_frame))
1206         descendant-&gt;navigationScheduler().startTimer();
1207 
1208     if (Frame* parent = m_frame.tree().parent())
1209         parent-&gt;loader().checkCompleted();
1210 
1211     if (m_frame.view())
1212         m_frame.view()-&gt;maintainScrollPositionAtAnchor(nullptr);
1213 }
1214 
1215 void FrameLoader::started()
1216 {
1217     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().parent())
1218         frame-&gt;loader().m_isComplete = false;
1219 }
1220 
1221 void FrameLoader::prepareForLoadStart()
1222 {
1223     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;prepareForLoadStart: Starting frame load&quot;);
1224 
1225     m_progressTracker-&gt;progressStarted();
1226     m_client.dispatchDidStartProvisionalLoad();
1227 
1228     if (AXObjectCache::accessibilityEnabled()) {
1229         if (AXObjectCache* cache = m_frame.document()-&gt;existingAXObjectCache()) {
1230             AXObjectCache::AXLoadingEvent loadingEvent = loadType() == FrameLoadType::Reload ? AXObjectCache::AXLoadingReloaded : AXObjectCache::AXLoadingStarted;
1231             cache-&gt;frameLoadingEventNotification(&amp;m_frame, loadingEvent);
1232         }
1233     }
1234 }
1235 
1236 void FrameLoader::setupForReplace()
1237 {
1238     m_client.revertToProvisionalState(m_documentLoader.get());
1239     setState(FrameStateProvisional);
1240     m_provisionalDocumentLoader = m_documentLoader;
1241     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;setupForReplace: Setting provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());
1242     m_documentLoader = nullptr;
1243     detachChildren();
1244 }
1245 
1246 void FrameLoader::loadFrameRequest(FrameLoadRequest&amp;&amp; request, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)
1247 {
1248     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadFrameRequest: frame load started&quot;);
1249 
1250     // Protect frame from getting blown away inside dispatchBeforeLoadEvent in loadWithDocumentLoader.
1251     auto protectFrame = makeRef(m_frame);
1252 
1253     URL url = request.resourceRequest().url();
1254 
1255     ASSERT(m_frame.document());
1256     if (!request.requesterSecurityOrigin().canDisplay(url)) {
1257         reportLocalLoadFailed(&amp;m_frame, url.stringCenterEllipsizedToLength());
1258         return;
1259     }
1260 
1261     String argsReferrer = request.resourceRequest().httpReferrer();
1262     if (argsReferrer.isEmpty())
1263         argsReferrer = outgoingReferrer();
1264 
1265     String referrer = SecurityPolicy::generateReferrerHeader(m_frame.document()-&gt;referrerPolicy(), url, argsReferrer);
1266     if (request.shouldSendReferrer() == NeverSendReferrer)
1267         referrer = String();
1268 
1269     FrameLoadType loadType;
1270     if (request.resourceRequest().cachePolicy() == ResourceRequestCachePolicy::ReloadIgnoringCacheData)
1271         loadType = FrameLoadType::Reload;
1272     else if (request.lockBackForwardList() == LockBackForwardList::Yes)
1273         loadType = FrameLoadType::RedirectWithLockedBackForwardList;
1274     else
1275         loadType = FrameLoadType::Standard;
1276 
1277     auto completionHandler = [this, protectedFrame = makeRef(m_frame), formState = makeWeakPtr(formState.get()), frameName = request.frameName()] {
1278         // FIXME: It&#39;s possible this targetFrame will not be the same frame that was targeted by the actual
1279         // load if frame names have changed.
1280         Frame* sourceFrame = formState ? formState-&gt;sourceDocument().frame() : &amp;m_frame;
1281         if (!sourceFrame)
1282             sourceFrame = &amp;m_frame;
1283         Frame* targetFrame = sourceFrame-&gt;loader().findFrameForNavigation(frameName);
1284         if (targetFrame &amp;&amp; targetFrame != sourceFrame) {
1285             if (Page* page = targetFrame-&gt;page())
1286                 page-&gt;chrome().focus();
1287         }
1288     };
1289 
1290     if (request.resourceRequest().httpMethod() == &quot;POST&quot;)
1291         loadPostRequest(WTFMove(request), referrer, loadType, event, WTFMove(formState), WTFMove(completionHandler));
1292     else
1293         loadURL(WTFMove(request), referrer, loadType, event, WTFMove(formState), WTFMove(adClickAttribution), WTFMove(completionHandler));
1294 }
1295 
1296 static ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicyToApply(Frame&amp; currentFrame, InitiatedByMainFrame initiatedByMainFrame, ShouldOpenExternalURLsPolicy propagatedPolicy)
1297 {
1298     if (UserGestureIndicator::processingUserGesture())
1299         return ShouldOpenExternalURLsPolicy::ShouldAllow;
1300 
1301     if (initiatedByMainFrame == InitiatedByMainFrame::Yes)
1302         return propagatedPolicy;
1303 
1304     if (!currentFrame.isMainFrame())
1305         return ShouldOpenExternalURLsPolicy::ShouldNotAllow;
1306 
1307     return propagatedPolicy;
1308 }
1309 
1310 static ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicyToApply(Frame&amp; currentFrame, const FrameLoadRequest&amp; frameLoadRequest)
1311 {
1312     return shouldOpenExternalURLsPolicyToApply(currentFrame, frameLoadRequest.initiatedByMainFrame(), frameLoadRequest.shouldOpenExternalURLsPolicy());
1313 }
1314 
1315 static void applyShouldOpenExternalURLsPolicyToNewDocumentLoader(Frame&amp; frame, DocumentLoader&amp; documentLoader, InitiatedByMainFrame initiatedByMainFrame, ShouldOpenExternalURLsPolicy propagatedPolicy)
1316 {
1317     documentLoader.setShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(frame, initiatedByMainFrame, propagatedPolicy));
1318 }
1319 
1320 static void applyShouldOpenExternalURLsPolicyToNewDocumentLoader(Frame&amp; frame, DocumentLoader&amp; documentLoader, const FrameLoadRequest&amp; frameLoadRequest)
1321 {
1322     documentLoader.setShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(frame, frameLoadRequest));
1323 }
1324 
1325 bool FrameLoader::isNavigationAllowed() const
1326 {
1327     return m_pageDismissalEventBeingDispatched == PageDismissalType::None &amp;&amp; !m_frame.script().willReplaceWithResultOfExecutingJavascriptURL() &amp;&amp; NavigationDisabler::isNavigationAllowed(m_frame);
1328 }
1329 
1330 bool FrameLoader::isStopLoadingAllowed() const
1331 {
1332     return m_pageDismissalEventBeingDispatched == PageDismissalType::None;
1333 }
1334 
1335 void FrameLoader::loadURL(FrameLoadRequest&amp;&amp; frameLoadRequest, const String&amp; referrer, FrameLoadType newLoadType, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
1336 {
1337     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadURL: frame load started&quot;);
1338 
1339     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
1340     if (m_inStopAllLoaders || m_inClearProvisionalLoadForPolicyCheck)
1341         return;
1342 
1343     Ref&lt;Frame&gt; protect(m_frame);
1344 
1345     // Anchor target is ignored when the download attribute is set since it will download the hyperlink rather than follow it.
1346     String effectiveFrameName = frameLoadRequest.downloadAttribute().isNull() ? frameLoadRequest.frameName() : String();
1347     AllowNavigationToInvalidURL allowNavigationToInvalidURL = frameLoadRequest.allowNavigationToInvalidURL();
1348     NewFrameOpenerPolicy openerPolicy = frameLoadRequest.newFrameOpenerPolicy();
1349     LockHistory lockHistory = frameLoadRequest.lockHistory();
1350     bool isFormSubmission = formState;
1351 
1352     const URL&amp; newURL = frameLoadRequest.resourceRequest().url();
1353     ResourceRequest request(newURL);
1354     if (!referrer.isEmpty()) {
1355         request.setHTTPReferrer(referrer);
1356         auto referrerOrigin = SecurityOrigin::createFromString(referrer);
1357         addHTTPOriginIfNeeded(request, referrerOrigin-&gt;toString());
1358     }
1359     if (&amp;m_frame.tree().top() != &amp;m_frame)
1360         request.setDomainForCachePartition(m_frame.tree().top().document()-&gt;domainForCachePartition());
1361 
1362     addExtraFieldsToRequest(request, newLoadType, true);
1363     if (isReload(newLoadType))
1364         request.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
1365 
1366     ASSERT(newLoadType != FrameLoadType::Same);
1367 
1368     // The search for a target frame is done earlier in the case of form submission.
1369     Frame* targetFrame = isFormSubmission ? nullptr : findFrameForNavigation(effectiveFrameName);
1370     if (targetFrame &amp;&amp; targetFrame != &amp;m_frame) {
1371         frameLoadRequest.setFrameName(&quot;_self&quot;);
1372         targetFrame-&gt;loader().loadURL(WTFMove(frameLoadRequest), referrer, newLoadType, event, WTFMove(formState), WTFMove(adClickAttribution), completionHandlerCaller.release());
1373         return;
1374     }
1375 
1376     if (!isNavigationAllowed())
1377         return;
1378 
1379     NavigationAction action { frameLoadRequest.requester(), request, frameLoadRequest.initiatedByMainFrame(), newLoadType, isFormSubmission, event, frameLoadRequest.shouldOpenExternalURLsPolicy(), frameLoadRequest.downloadAttribute() };
1380     action.setLockHistory(lockHistory);
1381     action.setLockBackForwardList(frameLoadRequest.lockBackForwardList());
1382     if (adClickAttribution &amp;&amp; m_frame.isMainFrame())
1383         action.setAdClickAttribution(WTFMove(*adClickAttribution));
1384 
1385     if (!targetFrame &amp;&amp; !effectiveFrameName.isEmpty()) {
1386         action = action.copyWithShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(m_frame, frameLoadRequest));
1387         policyChecker().checkNewWindowPolicy(WTFMove(action), WTFMove(request), WTFMove(formState), effectiveFrameName, [this, allowNavigationToInvalidURL, openerPolicy, completionHandler = completionHandlerCaller.release()] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, const NavigationAction&amp; action, PolicyChecker::ShouldContinue shouldContinue) mutable {
1388             continueLoadAfterNewWindowPolicy(request, formState.get(), frameName, action, shouldContinue, allowNavigationToInvalidURL, openerPolicy);
1389             completionHandler();
1390         });
1391         return;
1392     }
1393 
1394     RefPtr&lt;DocumentLoader&gt; oldDocumentLoader = m_documentLoader;
1395 
1396     bool sameURL = shouldTreatURLAsSameAsCurrent(newURL);
1397     const String&amp; httpMethod = request.httpMethod();
1398 
1399     // Make sure to do scroll to fragment processing even if the URL is
1400     // exactly the same so pages with &#39;#&#39; links and DHTML side effects
1401     // work properly.
1402     if (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, newLoadType, newURL)) {
1403         oldDocumentLoader-&gt;setTriggeringAction(WTFMove(action));
1404         oldDocumentLoader-&gt;setLastCheckedRequest(ResourceRequest());
1405         policyChecker().stopCheck();
1406         policyChecker().setLoadType(newLoadType);
1407         RELEASE_ASSERT(!isBackForwardLoadType(newLoadType) || history().provisionalItem());
1408         policyChecker().checkNavigationPolicy(WTFMove(request), ResourceResponse { } /* redirectResponse */, oldDocumentLoader.get(), WTFMove(formState), [this, protectedFrame = makeRef(m_frame)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp;, NavigationPolicyDecision navigationPolicyDecision) {
1409             continueFragmentScrollAfterNavigationPolicy(request, navigationPolicyDecision == NavigationPolicyDecision::ContinueLoad);
1410         }, PolicyDecisionMode::Synchronous);
1411         return;
1412     }
1413 
1414     // Must grab this now, since this load may stop the previous load and clear this flag.
1415     bool isRedirect = m_quickRedirectComing;
1416 #if USE(SYSTEM_PREVIEW)
1417     bool isSystemPreview = frameLoadRequest.isSystemPreview();
1418     if (isSystemPreview)
1419         request.setSystemPreviewInfo(frameLoadRequest.systemPreviewInfo());
1420 #endif
1421     loadWithNavigationAction(request, WTFMove(action), lockHistory, newLoadType, WTFMove(formState), allowNavigationToInvalidURL, frameLoadRequest.downloadAttribute(), [this, isRedirect, sameURL, newLoadType, protectedFrame = makeRef(m_frame), completionHandler = completionHandlerCaller.release()] () mutable {
1422         if (isRedirect) {
1423             m_quickRedirectComing = false;
1424             if (m_provisionalDocumentLoader)
1425                 m_provisionalDocumentLoader-&gt;setIsClientRedirect(true);
1426             else if (m_policyDocumentLoader)
1427                 m_policyDocumentLoader-&gt;setIsClientRedirect(true);
1428         } else if (sameURL &amp;&amp; !isReload(newLoadType)) {
1429             // Example of this case are sites that reload the same URL with a different cookie
1430             // driving the generated content, or a master frame with links that drive a target
1431             // frame, where the user has clicked on the same link repeatedly.
1432             m_loadType = FrameLoadType::Same;
1433         }
1434         completionHandler();
1435     });
1436 }
1437 
1438 SubstituteData FrameLoader::defaultSubstituteDataForURL(const URL&amp; url)
1439 {
1440     if (!shouldTreatURLAsSrcdocDocument(url))
1441         return SubstituteData();
1442     auto&amp; srcdoc = m_frame.ownerElement()-&gt;attributeWithoutSynchronization(srcdocAttr);
1443     ASSERT(!srcdoc.isNull());
1444     CString encodedSrcdoc = srcdoc.string().utf8();
1445 
1446     ResourceResponse response(URL(), &quot;text/html&quot;_s, encodedSrcdoc.length(), &quot;UTF-8&quot;_s);
1447     return SubstituteData(SharedBuffer::create(encodedSrcdoc.data(), encodedSrcdoc.length()), URL(), response, SubstituteData::SessionHistoryVisibility::Hidden);
1448 }
1449 
1450 void FrameLoader::load(FrameLoadRequest&amp;&amp; request)
1451 {
1452     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;load (FrameLoadRequest): frame load started&quot;);
1453 
1454     if (m_inStopAllLoaders || m_inClearProvisionalLoadForPolicyCheck)
1455         return;
1456 
1457     if (!request.frameName().isEmpty()) {
1458         Frame* frame = findFrameForNavigation(request.frameName());
1459         if (frame) {
1460             request.setShouldCheckNewWindowPolicy(false);
1461             if (&amp;frame-&gt;loader() != this) {
1462                 frame-&gt;loader().load(WTFMove(request));
1463                 return;
1464             }
1465         }
1466     }
1467 
1468     if (request.shouldCheckNewWindowPolicy()) {
1469         NavigationAction action { request.requester(), request.resourceRequest(), InitiatedByMainFrame::Unknown, NavigationType::Other, request.shouldOpenExternalURLsPolicy() };
1470         policyChecker().checkNewWindowPolicy(WTFMove(action), WTFMove(request.resourceRequest()), { }, request.frameName(), [this] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, const NavigationAction&amp; action, PolicyChecker::ShouldContinue shouldContinue) {
1471             continueLoadAfterNewWindowPolicy(request, formState.get(), frameName, action, shouldContinue, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Suppress);
1472         });
1473 
1474         return;
1475     }
1476 
1477     if (!request.hasSubstituteData())
1478         request.setSubstituteData(defaultSubstituteDataForURL(request.resourceRequest().url()));
1479 
1480     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request.resourceRequest(), request.substituteData());
1481     loader-&gt;setAllowsWebArchiveForMainFrame(request.isRequestFromClientOrUserInput());
1482     loader-&gt;setAllowsDataURLsForMainFrame(request.isRequestFromClientOrUserInput());
1483     addSameSiteInfoToRequestIfNeeded(loader-&gt;request());
1484     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, request);
1485 
1486     if (request.shouldTreatAsContinuingLoad()) {
1487         loader-&gt;setClientRedirectSourceForHistory(request.clientRedirectSourceForHistory());
1488         if (request.lockBackForwardList() == LockBackForwardList::Yes) {
1489             loader-&gt;setIsClientRedirect(true);
1490             m_loadType = FrameLoadType::RedirectWithLockedBackForwardList;
1491         }
1492     }
1493 
1494     SetForScope&lt;LoadContinuingState&gt; continuingLoadGuard(m_currentLoadContinuingState, request.shouldTreatAsContinuingLoad() ? LoadContinuingState::ContinuingWithRequest : LoadContinuingState::NotContinuing);
1495     load(loader.get());
1496 }
1497 
1498 void FrameLoader::loadWithNavigationAction(const ResourceRequest&amp; request, NavigationAction&amp;&amp; action, LockHistory lockHistory, FrameLoadType type, RefPtr&lt;FormState&gt;&amp;&amp; formState, AllowNavigationToInvalidURL allowNavigationToInvalidURL, const String&amp; downloadAttribute, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
1499 {
1500     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadWithNavigationAction: frame load started&quot;);
1501 
1502     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request, defaultSubstituteDataForURL(request.url()));
1503     loader-&gt;setDownloadAttribute(downloadAttribute);
1504     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, action.initiatedByMainFrame(), action.shouldOpenExternalURLsPolicy());
1505 
1506     if (lockHistory == LockHistory::Yes &amp;&amp; m_documentLoader)
1507         loader-&gt;setClientRedirectSourceForHistory(m_documentLoader-&gt;didCreateGlobalHistoryEntry() ? m_documentLoader-&gt;urlForHistory().string() : m_documentLoader-&gt;clientRedirectSourceForHistory());
1508 
1509     loader-&gt;setTriggeringAction(WTFMove(action));
1510     if (m_documentLoader)
1511         loader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1512 
1513     loadWithDocumentLoader(loader.ptr(), type, WTFMove(formState), allowNavigationToInvalidURL, ShouldTreatAsContinuingLoad::No, WTFMove(completionHandler));
1514 }
1515 
1516 void FrameLoader::load(DocumentLoader&amp; newDocumentLoader)
1517 {
1518     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;load (DocumentLoader): frame load started&quot;);
1519 
1520     ResourceRequest&amp; r = newDocumentLoader.request();
1521     addExtraFieldsToMainResourceRequest(r);
1522     FrameLoadType type;
1523 
1524     if (shouldTreatURLAsSameAsCurrent(newDocumentLoader.originalRequest().url())) {
1525         r.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
1526         type = FrameLoadType::Same;
1527     } else if (shouldTreatURLAsSameAsCurrent(newDocumentLoader.unreachableURL()) &amp;&amp; isReload(m_loadType))
1528         type = m_loadType;
1529     else if (m_loadType == FrameLoadType::RedirectWithLockedBackForwardList &amp;&amp; ((!newDocumentLoader.unreachableURL().isEmpty() &amp;&amp; newDocumentLoader.substituteData().isValid()) || shouldTreatCurrentLoadAsContinuingLoad()))
1530         type = FrameLoadType::RedirectWithLockedBackForwardList;
1531     else
1532         type = FrameLoadType::Standard;
1533 
1534     if (m_documentLoader)
1535         newDocumentLoader.setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1536 
1537     // When we loading alternate content for an unreachable URL that we&#39;re
1538     // visiting in the history list, we treat it as a reload so the history list
1539     // is appropriately maintained.
1540     //
1541     // FIXME: This seems like a dangerous overloading of the meaning of &quot;FrameLoadType::Reload&quot; ...
1542     // shouldn&#39;t a more explicit type of reload be defined, that means roughly
1543     // &quot;load without affecting history&quot; ?
1544     if (shouldReloadToHandleUnreachableURL(newDocumentLoader)) {
1545         // shouldReloadToHandleUnreachableURL returns true only when the original load type is back-forward.
1546         // In this case we should save the document state now. Otherwise the state can be lost because load type is
1547         // changed and updateForBackForwardNavigation() will not be called when loading is committed.
1548         history().saveDocumentAndScrollState();
1549 
1550         ASSERT(type == FrameLoadType::Standard);
1551         type = FrameLoadType::Reload;
1552     }
1553 
1554     loadWithDocumentLoader(&amp;newDocumentLoader, type, nullptr, AllowNavigationToInvalidURL::Yes, ShouldTreatAsContinuingLoad::No);
1555 }
1556 
1557 void FrameLoader::loadWithDocumentLoader(DocumentLoader* loader, FrameLoadType type, RefPtr&lt;FormState&gt;&amp;&amp; formState, AllowNavigationToInvalidURL allowNavigationToInvalidURL, ShouldTreatAsContinuingLoad, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
1558 {
1559     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadWithDocumentLoader: frame load started&quot;);
1560 
1561     // Retain because dispatchBeforeLoadEvent may release the last reference to it.
1562     Ref&lt;Frame&gt; protect(m_frame);
1563 
1564     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
1565 
1566     ASSERT(m_client.hasWebView());
1567 
1568     // Unfortunately the view must be non-nil, this is ultimately due
1569     // to parser requiring a FrameView.  We should fix this dependency.
1570 
1571     ASSERT(m_frame.view());
1572 
1573     if (!isNavigationAllowed())
1574         return;
1575 
1576     if (m_frame.document())
1577         m_previousURL = m_frame.document()-&gt;url();
1578 
1579     const URL&amp; newURL = loader-&gt;request().url();
1580 
1581     // Only the first iframe navigation or the first iframe navigation after about:blank should be reported.
1582     // https://www.w3.org/TR/resource-timing-2/#resources-included-in-the-performanceresourcetiming-interface
1583     if (m_shouldReportResourceTimingToParentFrame &amp;&amp; !m_previousURL.isNull() &amp;&amp; m_previousURL != WTF::blankURL())
1584         m_shouldReportResourceTimingToParentFrame = false;
1585 
1586     // Log main frame navigation types.
1587     if (m_frame.isMainFrame()) {
1588         if (auto* page = m_frame.page()) {
1589             FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadWithDocumentLoader: main frame load started&quot;);
1590             page-&gt;mainFrameLoadStarted(newURL, type);
1591             page-&gt;performanceLogging().didReachPointOfInterest(PerformanceLogging::MainFrameLoadStarted);
1592         }
1593     }
1594 
1595     policyChecker().setLoadType(type);
1596     RELEASE_ASSERT(!isBackForwardLoadType(type) || history().provisionalItem());
1597     bool isFormSubmission = formState;
1598 
1599     const String&amp; httpMethod = loader-&gt;request().httpMethod();
1600 
1601     if (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, policyChecker().loadType(), newURL)) {
1602         RefPtr&lt;DocumentLoader&gt; oldDocumentLoader = m_documentLoader;
1603         NavigationAction action { *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission };
1604 
1605         oldDocumentLoader-&gt;setTriggeringAction(WTFMove(action));
1606         oldDocumentLoader-&gt;setLastCheckedRequest(ResourceRequest());
1607         policyChecker().stopCheck();
1608         RELEASE_ASSERT(!isBackForwardLoadType(policyChecker().loadType()) || history().provisionalItem());
1609         policyChecker().checkNavigationPolicy(ResourceRequest(loader-&gt;request()), ResourceResponse { }  /* redirectResponse */, oldDocumentLoader.get(), WTFMove(formState), [this, protectedFrame = makeRef(m_frame)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp;, NavigationPolicyDecision navigationPolicyDecision) {
1610             continueFragmentScrollAfterNavigationPolicy(request, navigationPolicyDecision == NavigationPolicyDecision::ContinueLoad);
1611         }, PolicyDecisionMode::Synchronous);
1612         return;
1613     }
1614 
1615     if (Frame* parent = m_frame.tree().parent())
1616         loader-&gt;setOverrideEncoding(parent-&gt;loader().documentLoader()-&gt;overrideEncoding());
1617 
1618     policyChecker().stopCheck();
1619     setPolicyDocumentLoader(loader);
1620     if (loader-&gt;triggeringAction().isEmpty())
1621         loader-&gt;setTriggeringAction({ *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission });
1622 
1623     if (Element* ownerElement = m_frame.ownerElement()) {
1624         // We skip dispatching the beforeload event if we&#39;ve already
1625         // committed a real document load because the event would leak
1626         // subsequent activity by the frame which the parent frame isn&#39;t
1627         // supposed to learn. For example, if the child frame navigated to
1628         // a new URL, the parent frame shouldn&#39;t learn the URL.
1629         if (!m_stateMachine.committedFirstRealDocumentLoad()
1630             &amp;&amp; !ownerElement-&gt;dispatchBeforeLoadEvent(loader-&gt;request().url().string())) {
1631             continueLoadAfterNavigationPolicy(loader-&gt;request(), formState.get(), NavigationPolicyDecision::IgnoreLoad, allowNavigationToInvalidURL);
1632             return;
1633         }
1634     }
1635 
1636     m_frame.navigationScheduler().cancel(NewLoadInProgress::Yes);
1637 
1638     if (shouldTreatCurrentLoadAsContinuingLoad()) {
1639         continueLoadAfterNavigationPolicy(loader-&gt;request(), formState.get(), NavigationPolicyDecision::ContinueLoad, allowNavigationToInvalidURL);
1640         return;
1641     }
1642 
1643     RELEASE_ASSERT(!isBackForwardLoadType(policyChecker().loadType()) || history().provisionalItem());
1644     policyChecker().checkNavigationPolicy(ResourceRequest(loader-&gt;request()), ResourceResponse { } /* redirectResponse */, loader, WTFMove(formState), [this, protectedFrame = makeRef(m_frame), allowNavigationToInvalidURL, completionHandler = completionHandlerCaller.release()] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, NavigationPolicyDecision navigationPolicyDecision) mutable {
1645         continueLoadAfterNavigationPolicy(request, formState.get(), navigationPolicyDecision, allowNavigationToInvalidURL);
1646         completionHandler();
1647     }, PolicyDecisionMode::Asynchronous);
1648 }
1649 
1650 void FrameLoader::clearProvisionalLoadForPolicyCheck()
1651 {
1652     if (!m_policyDocumentLoader || !m_provisionalDocumentLoader || m_inClearProvisionalLoadForPolicyCheck)
1653         return;
1654 
1655     SetForScope&lt;bool&gt; change(m_inClearProvisionalLoadForPolicyCheck, true);
1656     m_provisionalDocumentLoader-&gt;stopLoading();
1657     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;clearProvisionalLoadForPolicyCheck: Clearing provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());
1658     setProvisionalDocumentLoader(nullptr);
1659 }
1660 
1661 void FrameLoader::reportLocalLoadFailed(Frame* frame, const String&amp; url)
1662 {
1663     ASSERT(!url.isEmpty());
1664     if (!frame)
1665         return;
1666 
1667     frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Not allowed to load local resource: &quot; + url);
1668 }
1669 
1670 void FrameLoader::reportBlockedPortFailed(Frame* frame, const String&amp; url)
1671 {
1672     ASSERT(!url.isEmpty());
1673     if (!frame)
1674         return;
1675 
1676     frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Not allowed to use restricted network port: &quot; + url);
1677 }
1678 
1679 void FrameLoader::reportAuthenticationChallengeBlocked(Frame* frame, const URL&amp; url, const String&amp; reason)
1680 {
1681     if (!frame)
1682         return;
1683 
1684     frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, makeString(&quot;Blocked &quot;, url.stringCenterEllipsizedToLength(), &quot; from asking for credentials because &quot;, reason, &#39;.&#39;));
1685 }
1686 
1687 const ResourceRequest&amp; FrameLoader::initialRequest() const
1688 {
1689     return activeDocumentLoader()-&gt;originalRequest();
1690 }
1691 
1692 bool FrameLoader::willLoadMediaElementURL(URL&amp; url, Node&amp; initiatorNode)
1693 {
1694 #if PLATFORM(IOS_FAMILY)
1695     // MobileStore depends on the iOS 4.0 era client delegate method because webView:resource:willSendRequest:redirectResponse:fromDataSource
1696     // doesn&#39;t let them tell when a load request is coming from a media element. See &lt;rdar://problem/8266916&gt; for more details.
1697     if (IOSApplication::isMobileStore())
1698         return m_client.shouldLoadMediaElementURL(url);
1699 #endif
1700 
1701     ResourceRequest request(url);
1702     request.setInspectorInitiatorNodeIdentifier(InspectorInstrumentation::identifierForNode(initiatorNode));
1703 
1704     unsigned long identifier;
1705     ResourceError error;
1706     requestFromDelegate(request, identifier, error);
1707     notifier().sendRemainingDelegateMessages(m_documentLoader.get(), identifier, request, ResourceResponse(url, String(), -1, String()), 0, -1, -1, error);
1708 
1709     url = request.url();
1710 
1711     return error.isNull();
1712 }
1713 
1714 bool FrameLoader::shouldReloadToHandleUnreachableURL(DocumentLoader&amp; docLoader)
1715 {
1716     URL unreachableURL = docLoader.unreachableURL();
1717 
1718     if (unreachableURL.isEmpty())
1719         return false;
1720 
1721     if (!isBackForwardLoadType(policyChecker().loadType()))
1722         return false;
1723 
1724     // We only treat unreachableURLs specially during the delegate callbacks
1725     // for provisional load errors and navigation policy decisions. The former
1726     // case handles well-formed URLs that can&#39;t be loaded, and the latter
1727     // case handles malformed URLs and unknown schemes. Loading alternate content
1728     // at other times behaves like a standard load.
1729     if (policyChecker().delegateIsDecidingNavigationPolicy() || policyChecker().delegateIsHandlingUnimplementablePolicy())
1730         return m_policyDocumentLoader &amp;&amp; unreachableURL == m_policyDocumentLoader-&gt;request().url();
1731 
1732     return unreachableURL == m_provisionalLoadErrorBeingHandledURL;
1733 }
1734 
1735 void FrameLoader::reloadWithOverrideEncoding(const String&amp; encoding)
1736 {
1737     if (!m_documentLoader)
1738         return;
1739 
1740     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;reloadWithOverrideEncoding: frame load started&quot;);
1741 
1742     ResourceRequest request = m_documentLoader-&gt;request();
1743     URL unreachableURL = m_documentLoader-&gt;unreachableURL();
1744     if (!unreachableURL.isEmpty())
1745         request.setURL(unreachableURL);
1746 
1747     // FIXME: If the resource is a result of form submission and is not cached, the form will be silently resubmitted.
1748     // We should ask the user for confirmation in this case.
1749     request.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataElseLoad);
1750 
1751     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request, defaultSubstituteDataForURL(request.url()));
1752     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, InitiatedByMainFrame::Unknown, m_documentLoader-&gt;shouldOpenExternalURLsPolicyToPropagate());
1753 
1754     setPolicyDocumentLoader(loader.ptr());
1755 
1756     loader-&gt;setOverrideEncoding(encoding);
1757 
1758     loadWithDocumentLoader(loader.ptr(), FrameLoadType::Reload, { }, AllowNavigationToInvalidURL::Yes, ShouldTreatAsContinuingLoad::No);
1759 }
1760 
1761 void FrameLoader::reload(OptionSet&lt;ReloadOption&gt; options)
1762 {
1763     if (!m_documentLoader)
1764         return;
1765 
1766     // If a window is created by javascript, its main frame can have an empty but non-nil URL.
1767     // Reloading in this case will lose the current contents (see 4151001).
1768     if (m_documentLoader-&gt;request().url().isEmpty())
1769         return;
1770 
1771     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;reload: frame load started&quot;);
1772 
1773     // Replace error-page URL with the URL we were trying to reach.
1774     ResourceRequest initialRequest = m_documentLoader-&gt;request();
1775     URL unreachableURL = m_documentLoader-&gt;unreachableURL();
1776     if (!unreachableURL.isEmpty())
1777         initialRequest.setURL(unreachableURL);
1778 
1779     // Create a new document loader for the reload, this will become m_documentLoader eventually,
1780     // but first it has to be the &quot;policy&quot; document loader, and then the &quot;provisional&quot; document loader.
1781     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(initialRequest, defaultSubstituteDataForURL(initialRequest.url()));
1782     loader-&gt;setAllowsWebArchiveForMainFrame(m_documentLoader-&gt;allowsWebArchiveForMainFrame());
1783     loader-&gt;setAllowsDataURLsForMainFrame(m_documentLoader-&gt;allowsDataURLsForMainFrame());
1784     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, InitiatedByMainFrame::Unknown, m_documentLoader-&gt;shouldOpenExternalURLsPolicyToPropagate());
1785 
1786     loader-&gt;setUserContentExtensionsEnabled(!options.contains(ReloadOption::DisableContentBlockers));
1787 
1788     ResourceRequest&amp; request = loader-&gt;request();
1789 
1790     // FIXME: We don&#39;t have a mechanism to revalidate the main resource without reloading at the moment.
1791     request.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
1792 
1793     addSameSiteInfoToRequestIfNeeded(request);
1794 
1795     // If we&#39;re about to re-post, set up action so the application can warn the user.
1796     if (request.httpMethod() == &quot;POST&quot;)
1797         loader-&gt;setTriggeringAction({ *m_frame.document(), request, InitiatedByMainFrame::Unknown, NavigationType::FormResubmitted });
1798 
1799     loader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1800 
1801     auto frameLoadTypeForReloadOptions = [] (auto options) {
1802         if (options &amp; ReloadOption::FromOrigin)
1803             return FrameLoadType::ReloadFromOrigin;
1804         if (options &amp; ReloadOption::ExpiredOnly)
1805             return FrameLoadType::ReloadExpiredOnly;
1806         return FrameLoadType::Reload;
1807     };
1808 
1809     loadWithDocumentLoader(loader.ptr(), frameLoadTypeForReloadOptions(options), { }, AllowNavigationToInvalidURL::Yes, ShouldTreatAsContinuingLoad::No);
1810 }
1811 
1812 void FrameLoader::stopAllLoaders(ClearProvisionalItemPolicy clearProvisionalItemPolicy, StopLoadingPolicy stopLoadingPolicy)
1813 {
1814     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;backForwardCacheState() == Document::InBackForwardCache)
1815         return;
1816 
1817     if (stopLoadingPolicy == StopLoadingPolicy::PreventDuringUnloadEvents &amp;&amp; !isStopLoadingAllowed())
1818         return;
1819 
1820     // If this method is called from within this method, infinite recursion can occur (3442218). Avoid this.
1821     if (m_inStopAllLoaders)
1822         return;
1823 
1824     // This method might dispatch events.
1825     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
1826 
1827     // Calling stopLoading() on the provisional document loader can blow away
1828     // the frame from underneath.
1829     Ref&lt;Frame&gt; protect(m_frame);
1830 
1831     m_inStopAllLoaders = true;
1832 
1833     policyChecker().stopCheck();
1834 
1835     // If no new load is in progress, we should clear the provisional item from history
1836     // before we call stopLoading.
1837     if (clearProvisionalItemPolicy == ShouldClearProvisionalItem)
1838         history().setProvisionalItem(nullptr);
1839 
1840     for (RefPtr&lt;Frame&gt; child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())
1841         child-&gt;loader().stopAllLoaders(clearProvisionalItemPolicy);
1842     if (m_provisionalDocumentLoader)
1843         m_provisionalDocumentLoader-&gt;stopLoading();
1844     if (m_documentLoader)
1845         m_documentLoader-&gt;stopLoading();
1846 
1847     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;stopAllLoaders: Clearing provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());
1848     setProvisionalDocumentLoader(nullptr);
1849 
1850     m_inStopAllLoaders = false;
1851 }
1852 
1853 void FrameLoader::stopForBackForwardCache()
1854 {
1855     // Stop provisional loads in subframes (The one in the main frame is about to be committed).
1856     if (!m_frame.isMainFrame()) {
1857         if (m_provisionalDocumentLoader)
1858             m_provisionalDocumentLoader-&gt;stopLoading();
1859         FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;stopForBackForwardCache: Clearing provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());
1860         setProvisionalDocumentLoader(nullptr);
1861     }
1862 
1863     // Stop current loads.
1864     if (m_documentLoader)
1865         m_documentLoader-&gt;stopLoading();
1866 
1867     for (RefPtr&lt;Frame&gt; child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())
1868         child-&gt;loader().stopForBackForwardCache();
1869 
1870     // We cancel pending navigations &amp; policy checks *after* cancelling loads because cancelling loads might end up
1871     // running script, which could schedule new navigations.
1872     policyChecker().stopCheck();
1873     m_frame.navigationScheduler().cancel();
1874 }
1875 
1876 void FrameLoader::stopAllLoadersAndCheckCompleteness()
1877 {
1878     stopAllLoaders();
1879 
1880     if (!m_checkTimer.isActive())
1881         return;
1882 
1883     m_checkTimer.stop();
1884     m_checkingLoadCompleteForDetachment = true;
1885     checkCompletenessNow();
1886     m_checkingLoadCompleteForDetachment = false;
1887 }
1888 
1889 void FrameLoader::stopForUserCancel(bool deferCheckLoadComplete)
1890 {
1891     // Calling stopAllLoaders can cause the frame to be deallocated, including the frame loader.
1892     Ref&lt;Frame&gt; protectedFrame(m_frame);
1893 
1894     stopAllLoaders();
1895 
1896 #if PLATFORM(IOS_FAMILY)
1897     // Lay out immediately when stopping to immediately clear the old page if we just committed this one
1898     // but haven&#39;t laid out/painted yet.
1899     // FIXME: Is this behavior specific to iOS? Or should we expose a setting to toggle this behavior?
1900     if (m_frame.view() &amp;&amp; !m_frame.view()-&gt;didFirstLayout())
1901         m_frame.view()-&gt;layoutContext().layout();
1902 #endif
1903 
1904     if (deferCheckLoadComplete)
1905         scheduleCheckLoadComplete();
1906     else if (m_frame.page())
1907         checkLoadComplete();
1908 }
1909 
1910 DocumentLoader* FrameLoader::activeDocumentLoader() const
1911 {
1912     if (m_state == FrameStateProvisional)
1913         return m_provisionalDocumentLoader.get();
1914     return m_documentLoader.get();
1915 }
1916 
1917 bool FrameLoader::isLoading() const
1918 {
1919     DocumentLoader* docLoader = activeDocumentLoader();
1920     if (!docLoader)
1921         return false;
1922     return docLoader-&gt;isLoading();
1923 }
1924 
1925 bool FrameLoader::frameHasLoaded() const
1926 {
1927     return m_stateMachine.committedFirstRealDocumentLoad() || (m_provisionalDocumentLoader &amp;&amp; !m_stateMachine.creatingInitialEmptyDocument());
1928 }
1929 
1930 void FrameLoader::setDocumentLoader(DocumentLoader* loader)
1931 {
1932     if (!loader &amp;&amp; !m_documentLoader)
1933         return;
1934 
1935     if (loader == m_documentLoader)
1936         return;
1937 
1938     ASSERT(loader != m_documentLoader);
1939     ASSERT(!loader || loader-&gt;frameLoader() == this);
1940 
1941     m_client.prepareForDataSourceReplacement();
1942     detachChildren();
1943 
1944     // detachChildren() can trigger this frame&#39;s unload event, and therefore
1945     // script can run and do just about anything. For example, an unload event that calls
1946     // document.write(&quot;&quot;) on its parent frame can lead to a recursive detachChildren()
1947     // invocation for this frame. In that case, we can end up at this point with a
1948     // loader that hasn&#39;t been deleted but has been detached from its frame. Such a
1949     // DocumentLoader has been sufficiently detached that we&#39;ll end up in an inconsistent
1950     // state if we try to use it.
1951     if (loader &amp;&amp; !loader-&gt;frame())
1952         return;
1953 
1954     if (m_documentLoader)
1955         m_documentLoader-&gt;detachFromFrame();
1956 
1957     m_documentLoader = loader;
1958 }
1959 
1960 void FrameLoader::setPolicyDocumentLoader(DocumentLoader* loader)
1961 {
1962     if (m_policyDocumentLoader == loader)
1963         return;
1964 
1965     if (loader)
1966         loader-&gt;attachToFrame(m_frame);
1967     if (m_policyDocumentLoader
1968             &amp;&amp; m_policyDocumentLoader != m_provisionalDocumentLoader
1969             &amp;&amp; m_policyDocumentLoader != m_documentLoader)
1970         m_policyDocumentLoader-&gt;detachFromFrame();
1971 
1972     m_policyDocumentLoader = loader;
1973 }
1974 
1975 void FrameLoader::setProvisionalDocumentLoader(DocumentLoader* loader)
1976 {
1977     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;setProvisionalDocumentLoader: Setting provisional document loader (m_provisionalDocumentLoader=%p)&quot;, loader);
1978 
1979     ASSERT(!loader || !m_provisionalDocumentLoader);
1980     ASSERT(!loader || loader-&gt;frameLoader() == this);
1981 
1982     if (m_provisionalDocumentLoader &amp;&amp; m_provisionalDocumentLoader != m_documentLoader)
1983         m_provisionalDocumentLoader-&gt;detachFromFrame();
1984 
1985     m_provisionalDocumentLoader = loader;
1986 }
1987 
1988 void FrameLoader::setState(FrameState newState)
1989 {
1990     FrameState oldState = m_state;
1991     m_state = newState;
1992 
1993     if (newState == FrameStateProvisional)
1994         provisionalLoadStarted();
1995     else if (newState == FrameStateComplete) {
1996         frameLoadCompleted();
1997         if (m_documentLoader)
1998             m_documentLoader-&gt;stopRecordingResponses();
1999         if (m_frame.isMainFrame() &amp;&amp; oldState != newState) {
2000             FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;setState: main frame load completed&quot;);
2001             m_frame.page()-&gt;performanceLogging().didReachPointOfInterest(PerformanceLogging::MainFrameLoadCompleted);
2002         }
2003     }
2004 }
2005 
2006 void FrameLoader::clearProvisionalLoad()
2007 {
2008     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;clearProvisionalLoad: Clearing provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());
2009     setProvisionalDocumentLoader(nullptr);
2010     m_progressTracker-&gt;progressCompleted();
2011     setState(FrameStateComplete);
2012 }
2013 
2014 void FrameLoader::commitProvisionalLoad()
2015 {
2016     RefPtr&lt;DocumentLoader&gt; pdl = m_provisionalDocumentLoader;
2017     Ref&lt;Frame&gt; protect(m_frame);
2018 
2019     std::unique_ptr&lt;CachedPage&gt; cachedPage;
2020     if (m_loadingFromCachedPage &amp;&amp; history().provisionalItem())
2021         cachedPage = BackForwardCache::singleton().take(*history().provisionalItem(), m_frame.page());
2022 
2023     LOG(BackForwardCache, &quot;WebCoreLoading %s: About to commit provisional load from previous URL &#39;%s&#39; to new URL &#39;%s&#39; with cached page %p&quot;, m_frame.tree().uniqueName().string().utf8().data(),
2024         m_frame.document() ? m_frame.document()-&gt;url().stringCenterEllipsizedToLength().utf8().data() : &quot;&quot;,
2025         pdl ? pdl-&gt;url().stringCenterEllipsizedToLength().utf8().data() : &quot;&lt;no provisional DocumentLoader&gt;&quot;, cachedPage.get());
2026 
2027     willTransitionToCommitted();
2028 
2029     if (!m_frame.tree().parent() &amp;&amp; history().currentItem() &amp;&amp; history().currentItem() != history().provisionalItem()) {
2030         // Check to see if we need to cache the page we are navigating away from into the back/forward cache.
2031         // We are doing this here because we know for sure that a new page is about to be loaded.
2032         BackForwardCache::singleton().addIfCacheable(*history().currentItem(), m_frame.page());
2033 
2034         WebCore::jettisonExpensiveObjectsOnTopLevelNavigation();
2035     }
2036 
2037     if (m_loadType != FrameLoadType::Replace)
2038         closeOldDataSources();
2039 
2040     if (!cachedPage &amp;&amp; !m_stateMachine.creatingInitialEmptyDocument())
2041         m_client.makeRepresentation(pdl.get());
2042 
2043     transitionToCommitted(cachedPage.get());
2044 
2045     if (pdl &amp;&amp; m_documentLoader) {
2046         // Check if the destination page is allowed to access the previous page&#39;s timing information.
2047         Ref&lt;SecurityOrigin&gt; securityOrigin(SecurityOrigin::create(pdl-&gt;request().url()));
2048         m_documentLoader-&gt;timing().setHasSameOriginAsPreviousDocument(securityOrigin.get().canRequest(m_previousURL));
2049     }
2050 
2051     // Call clientRedirectCancelledOrFinished() here so that the frame load delegate is notified that the redirect&#39;s
2052     // status has changed, if there was a redirect.  The frame load delegate may have saved some state about
2053     // the redirect in its -webView:willPerformClientRedirectToURL:delay:fireDate:forFrame:.  Since we are
2054     // just about to commit a new page, there cannot possibly be a pending redirect at this point.
2055     if (m_sentRedirectNotification)
2056         clientRedirectCancelledOrFinished(NewLoadInProgress::No);
2057 
2058     if (cachedPage &amp;&amp; cachedPage-&gt;document()) {
2059 #if PLATFORM(IOS_FAMILY)
2060         // FIXME: CachedPage::restore() would dispatch viewport change notification. However UIKit expects load
2061         // commit to happen before any changes to viewport arguments and dealing with this there is difficult.
2062         m_frame.page()-&gt;chrome().setDispatchViewportDataDidChangeSuppressed(true);
2063 #endif
2064         willRestoreFromCachedPage();
2065 
2066         // Start request for the main resource and dispatch didReceiveResponse before the load is committed for
2067         // consistency with all other loads. See https://bugs.webkit.org/show_bug.cgi?id=150927.
2068         ResourceError mainResouceError;
2069         unsigned long mainResourceIdentifier;
2070         ResourceRequest mainResourceRequest(cachedPage-&gt;documentLoader()-&gt;request());
2071         requestFromDelegate(mainResourceRequest, mainResourceIdentifier, mainResouceError);
2072         notifier().dispatchDidReceiveResponse(cachedPage-&gt;documentLoader(), mainResourceIdentifier, cachedPage-&gt;documentLoader()-&gt;response());
2073 
2074         Optional&lt;HasInsecureContent&gt; hasInsecureContent = cachedPage-&gt;cachedMainFrame()-&gt;hasInsecureContent();
2075 
2076         dispatchDidCommitLoad(hasInsecureContent);
2077 
2078         // FIXME: This API should be turned around so that we ground CachedPage into the Page.
2079         cachedPage-&gt;restore(*m_frame.page());
2080 
2081 #if PLATFORM(IOS_FAMILY)
2082         m_frame.page()-&gt;chrome().setDispatchViewportDataDidChangeSuppressed(false);
2083         m_frame.page()-&gt;chrome().dispatchViewportPropertiesDidChange(m_frame.page()-&gt;viewportArguments());
2084 #endif
2085         m_frame.page()-&gt;chrome().dispatchDisabledAdaptationsDidChange(m_frame.page()-&gt;disabledAdaptations());
2086 
2087         auto&amp; title = m_documentLoader-&gt;title();
2088         if (!title.string.isNull())
2089             m_client.dispatchDidReceiveTitle(title);
2090 
2091         // Send remaining notifications for the main resource.
2092         notifier().sendRemainingDelegateMessages(m_documentLoader.get(), mainResourceIdentifier, mainResourceRequest, ResourceResponse(),
2093             nullptr, static_cast&lt;int&gt;(m_documentLoader-&gt;response().expectedContentLength()), 0, mainResouceError);
2094 
2095         checkCompleted();
2096     } else
2097         didOpenURL();
2098 
2099     LOG(Loading, &quot;WebCoreLoading %s: Finished committing provisional load to URL %s&quot;, m_frame.tree().uniqueName().string().utf8().data(),
2100         m_frame.document() ? m_frame.document()-&gt;url().stringCenterEllipsizedToLength().utf8().data() : &quot;&quot;);
2101 
2102     if (m_loadType == FrameLoadType::Standard &amp;&amp; m_documentLoader &amp;&amp; m_documentLoader-&gt;isClientRedirect())
2103         history().updateForClientRedirect();
2104 
2105     if (m_loadingFromCachedPage) {
2106         // Note, didReceiveDocType is expected to be called for cached pages. See &lt;rdar://problem/5906758&gt; for more details.
2107         if (auto* page = m_frame.page())
2108             page-&gt;chrome().didReceiveDocType(m_frame);
2109         m_frame.document()-&gt;resume(ReasonForSuspension::BackForwardCache);
2110 
2111         // Force a layout to update view size and thereby update scrollbars.
2112 #if PLATFORM(IOS_FAMILY)
2113         if (!m_client.forceLayoutOnRestoreFromBackForwardCache())
2114             m_frame.view()-&gt;forceLayout();
2115 #else
2116         m_frame.view()-&gt;forceLayout();
2117 #endif
2118 
2119         // Main resource delegates were already sent, so we skip the first response here.
2120         for (unsigned i = 1; i &lt; m_documentLoader-&gt;responses().size(); ++i) {
2121             const auto&amp; response = m_documentLoader-&gt;responses()[i];
2122             // FIXME: If the WebKit client changes or cancels the request, this is not respected.
2123             ResourceError error;
2124             unsigned long identifier;
2125             ResourceRequest request(response.url());
2126             requestFromDelegate(request, identifier, error);
2127             // FIXME: If we get a resource with more than 2B bytes, this code won&#39;t do the right thing.
2128             // However, with today&#39;s computers and networking speeds, this won&#39;t happen in practice.
2129             // Could be an issue with a giant local file.
2130             notifier().sendRemainingDelegateMessages(m_documentLoader.get(), identifier, request, response, 0, static_cast&lt;int&gt;(response.expectedContentLength()), 0, error);
2131         }
2132 
2133         // FIXME: Why only this frame and not parent frames?
2134         checkLoadCompleteForThisFrame();
2135     }
2136 }
2137 
2138 void FrameLoader::transitionToCommitted(CachedPage* cachedPage)
2139 {
2140     ASSERT(m_client.hasWebView());
2141     ASSERT(m_state == FrameStateProvisional);
2142 
2143     if (m_state != FrameStateProvisional)
2144         return;
2145 
2146     if (FrameView* view = m_frame.view()) {
2147         if (ScrollAnimator* scrollAnimator = view-&gt;existingScrollAnimator())
2148             scrollAnimator-&gt;cancelAnimations();
2149     }
2150 
2151     m_client.setCopiesOnScroll();
2152     history().updateForCommit();
2153 
2154     // The call to closeURL() invokes the unload event handler, which can execute arbitrary
2155     // JavaScript. If the script initiates a new load, we need to abandon the current load,
2156     // or the two will stomp each other.
2157     DocumentLoader* pdl = m_provisionalDocumentLoader.get();
2158     if (m_documentLoader)
2159         closeURL();
2160     if (pdl != m_provisionalDocumentLoader)
2161         return;
2162 
2163     if (m_documentLoader)
2164         m_documentLoader-&gt;stopLoadingSubresources();
2165     if (m_documentLoader)
2166         m_documentLoader-&gt;stopLoadingPlugIns();
2167 
2168     // Setting our document loader invokes the unload event handler of our child frames.
2169     // Script can do anything. If the script initiates a new load, we need to abandon the
2170     // current load or the two will stomp each other.
2171     setDocumentLoader(m_provisionalDocumentLoader.get());
2172     if (pdl != m_provisionalDocumentLoader)
2173         return;
2174     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;transitionToCommitted: Clearing provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());
2175     setProvisionalDocumentLoader(nullptr);
2176 
2177     // Nothing else can interrupt this commit - set the Provisional-&gt;Committed transition in stone
2178     setState(FrameStateCommittedPage);
2179 
2180     // Handle adding the URL to the back/forward list.
2181     DocumentLoader* dl = m_documentLoader.get();
2182 
2183     switch (m_loadType) {
2184     case FrameLoadType::Forward:
2185     case FrameLoadType::Back:
2186     case FrameLoadType::IndexedBackForward:
2187         if (m_frame.page()) {
2188             // If the first load within a frame is a navigation within a back/forward list that was attached
2189             // without any of the items being loaded then we need to update the history in a similar manner as
2190             // for a standard load with the exception of updating the back/forward list (&lt;rdar://problem/8091103&gt;).
2191             if (!m_stateMachine.committedFirstRealDocumentLoad() &amp;&amp; m_frame.isMainFrame())
2192                 history().updateForStandardLoad(HistoryController::UpdateAllExceptBackForwardList);
2193 
2194             history().updateForBackForwardNavigation();
2195 
2196             // For cached pages, CachedFrame::restore will take care of firing the popstate event with the history item&#39;s state object
2197             if (history().currentItem() &amp;&amp; !cachedPage)
2198                 m_pendingStateObject = history().currentItem()-&gt;stateObject();
2199 
2200             // Create a document view for this document, or used the cached view.
2201             if (cachedPage) {
2202                 DocumentLoader* cachedDocumentLoader = cachedPage-&gt;documentLoader();
2203                 ASSERT(cachedDocumentLoader);
2204                 cachedDocumentLoader-&gt;attachToFrame(m_frame);
2205                 m_client.transitionToCommittedFromCachedFrame(cachedPage-&gt;cachedMainFrame());
2206             } else
2207                 m_client.transitionToCommittedForNewPage();
2208         }
2209         break;
2210 
2211     case FrameLoadType::Reload:
2212     case FrameLoadType::ReloadFromOrigin:
2213     case FrameLoadType::ReloadExpiredOnly:
2214     case FrameLoadType::Same:
2215     case FrameLoadType::Replace:
2216         history().updateForReload();
2217         m_client.transitionToCommittedForNewPage();
2218         break;
2219 
2220     case FrameLoadType::Standard:
2221         history().updateForStandardLoad();
2222         if (m_frame.view())
2223             m_frame.view()-&gt;setScrollbarsSuppressed(true);
2224         m_client.transitionToCommittedForNewPage();
2225         break;
2226 
2227     case FrameLoadType::RedirectWithLockedBackForwardList:
2228         history().updateForRedirectWithLockedBackForwardList();
2229         m_client.transitionToCommittedForNewPage();
2230         break;
2231     }
2232 
2233     m_documentLoader-&gt;writer().setMIMEType(dl-&gt;responseMIMEType());
2234 
2235     // Tell the client we&#39;ve committed this URL.
2236     ASSERT(m_frame.view());
2237 
2238     if (m_stateMachine.creatingInitialEmptyDocument())
2239         return;
2240 
2241     if (!m_stateMachine.committedFirstRealDocumentLoad())
2242         m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocumentPostCommit);
2243 }
2244 
2245 void FrameLoader::clientRedirectCancelledOrFinished(NewLoadInProgress newLoadInProgress)
2246 {
2247     // Note that -webView:didCancelClientRedirectForFrame: is called on the frame load delegate even if
2248     // the redirect succeeded.  We should either rename this API, or add a new method, like
2249     // -webView:didFinishClientRedirectForFrame:
2250     m_client.dispatchDidCancelClientRedirect();
2251 
2252     if (newLoadInProgress == NewLoadInProgress::No)
2253         m_quickRedirectComing = false;
2254 
2255     m_sentRedirectNotification = false;
2256 }
2257 
2258 void FrameLoader::clientRedirected(const URL&amp; url, double seconds, WallTime fireDate, LockBackForwardList lockBackForwardList)
2259 {
2260     m_client.dispatchWillPerformClientRedirect(url, seconds, fireDate, lockBackForwardList);
2261 
2262     // Remember that we sent a redirect notification to the frame load delegate so that when we commit
2263     // the next provisional load, we can send a corresponding -webView:didCancelClientRedirectForFrame:
2264     m_sentRedirectNotification = true;
2265 
2266     // If a &quot;quick&quot; redirect comes in, we set a special mode so we treat the next
2267     // load as part of the original navigation. If we don&#39;t have a document loader, we have
2268     // no &quot;original&quot; load on which to base a redirect, so we treat the redirect as a normal load.
2269     // Loads triggered by JavaScript form submissions never count as quick redirects.
2270     m_quickRedirectComing = (lockBackForwardList == LockBackForwardList::Yes || history().currentItemShouldBeReplaced()) &amp;&amp; m_documentLoader &amp;&amp; !m_isExecutingJavaScriptFormAction;
2271 }
2272 
2273 bool FrameLoader::shouldReload(const URL&amp; currentURL, const URL&amp; destinationURL)
2274 {
2275     // This function implements the rule: &quot;Don&#39;t reload if navigating by fragment within
2276     // the same URL, but do reload if going to a new URL or to the same URL with no
2277     // fragment identifier at all.&quot;
2278     if (!destinationURL.hasFragmentIdentifier())
2279         return true;
2280     return !equalIgnoringFragmentIdentifier(currentURL, destinationURL);
2281 }
2282 
2283 void FrameLoader::closeOldDataSources()
2284 {
2285     // FIXME: Is it important for this traversal to be postorder instead of preorder?
2286     // If so, add helpers for postorder traversal, and use them. If not, then lets not
2287     // use a recursive algorithm here.
2288     for (Frame* child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())
2289         child-&gt;loader().closeOldDataSources();
2290 
2291     if (m_documentLoader)
2292         m_client.dispatchWillClose();
2293 
2294     m_client.setMainFrameDocumentReady(false); // stop giving out the actual DOMDocument to observers
2295 }
2296 
2297 void FrameLoader::willRestoreFromCachedPage()
2298 {
2299     ASSERT(!m_frame.tree().parent());
2300     ASSERT(m_frame.page());
2301     ASSERT(m_frame.isMainFrame());
2302 
2303     m_frame.navigationScheduler().cancel();
2304 
2305     // We still have to close the previous part page.
2306     closeURL();
2307 
2308     // Delete old status bar messages (if it _was_ activated on last URL).
2309     if (m_frame.script().canExecuteScripts(NotAboutToExecuteScript)) {
2310         DOMWindow* window = m_frame.document()-&gt;domWindow();
2311         window-&gt;setStatus(String());
2312         window-&gt;setDefaultStatus(String());
2313     }
2314 }
2315 
2316 void FrameLoader::open(CachedFrameBase&amp; cachedFrame)
2317 {
2318     m_isComplete = false;
2319 
2320     // Don&#39;t re-emit the load event.
2321     m_didCallImplicitClose = true;
2322 
2323     URL url = cachedFrame.url();
2324 
2325     // FIXME: I suspect this block of code doesn&#39;t do anything.
2326     if (url.protocolIsInHTTPFamily() &amp;&amp; !url.host().isEmpty() &amp;&amp; url.path().isEmpty())
2327         url.setPath(&quot;/&quot;);
2328 
2329     started();
2330     auto document = makeRef(*cachedFrame.document());
2331     ASSERT(document-&gt;domWindow());
2332 
2333     clear(document.ptr(), true, true, cachedFrame.isMainFrame());
2334 
2335     document-&gt;attachToCachedFrame(cachedFrame);
2336     document-&gt;setBackForwardCacheState(Document::NotInBackForwardCache);
2337 
2338     m_needsClear = true;
2339     m_isComplete = false;
2340     m_didCallImplicitClose = false;
2341     setOutgoingReferrer(url);
2342 
2343     FrameView* view = cachedFrame.view();
2344 
2345     // When navigating to a CachedFrame its FrameView should never be null.  If it is we&#39;ll crash in creative ways downstream.
2346     ASSERT(view);
2347     view-&gt;setWasScrolledByUser(false);
2348 
2349     Optional&lt;IntRect&gt; previousViewFrameRect = m_frame.view() ?  m_frame.view()-&gt;frameRect() : Optional&lt;IntRect&gt;(WTF::nullopt);
2350     m_frame.setView(view);
2351 
2352     // Use the previous ScrollView&#39;s frame rect.
2353     if (previousViewFrameRect)
2354         view-&gt;setFrameRect(previousViewFrameRect.value());
2355 
2356 
2357     // Setting the document builds the render tree and runs post style resolution callbacks that can do anything,
2358     // including loading a child frame before its been re-attached to the frame tree as part of this restore.
2359     // For example, the HTML object element may load its content into a frame in a post style resolution callback.
2360     Style::PostResolutionCallbackDisabler disabler(document.get());
2361     WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
2362     NavigationDisabler disableNavigation { &amp;m_frame };
2363 
2364     m_frame.setDocument(document.copyRef());
2365 
2366     document-&gt;domWindow()-&gt;resumeFromBackForwardCache();
2367 
2368     updateFirstPartyForCookies();
2369 
2370     cachedFrame.restore();
2371 }
2372 
2373 bool FrameLoader::isHostedByObjectElement() const
2374 {
2375     HTMLFrameOwnerElement* owner = m_frame.ownerElement();
2376     return owner &amp;&amp; owner-&gt;hasTagName(objectTag);
2377 }
2378 
2379 bool FrameLoader::isReplacing() const
2380 {
2381     return m_loadType == FrameLoadType::Replace;
2382 }
2383 
2384 void FrameLoader::setReplacing()
2385 {
2386     m_loadType = FrameLoadType::Replace;
2387 }
2388 
2389 bool FrameLoader::subframeIsLoading() const
2390 {
2391     // It&#39;s most likely that the last added frame is the last to load so we walk backwards.
2392     for (Frame* child = m_frame.tree().lastChild(); child; child = child-&gt;tree().previousSibling()) {
2393         FrameLoader&amp; childLoader = child-&gt;loader();
2394         DocumentLoader* documentLoader = childLoader.documentLoader();
2395         if (documentLoader &amp;&amp; documentLoader-&gt;isLoadingInAPISense())
2396             return true;
2397         documentLoader = childLoader.provisionalDocumentLoader();
2398         if (documentLoader &amp;&amp; documentLoader-&gt;isLoadingInAPISense())
2399             return true;
2400         documentLoader = childLoader.policyDocumentLoader();
2401         if (documentLoader)
2402             return true;
2403     }
2404     return false;
2405 }
2406 
2407 void FrameLoader::willChangeTitle(DocumentLoader* loader)
2408 {
2409     m_client.willChangeTitle(loader);
2410 }
2411 
2412 FrameLoadType FrameLoader::loadType() const
2413 {
2414     return m_loadType;
2415 }
2416 
2417 CachePolicy FrameLoader::subresourceCachePolicy(const URL&amp; url) const
2418 {
2419     if (Page* page = m_frame.page()) {
2420         if (page-&gt;isResourceCachingDisabledByWebInspector())
2421             return CachePolicyReload;
2422     }
2423 
2424     if (m_isComplete)
2425         return CachePolicyVerify;
2426 
2427     if (m_loadType == FrameLoadType::ReloadFromOrigin)
2428         return CachePolicyReload;
2429 
2430     if (Frame* parentFrame = m_frame.tree().parent()) {
2431         CachePolicy parentCachePolicy = parentFrame-&gt;loader().subresourceCachePolicy(url);
2432         if (parentCachePolicy != CachePolicyVerify)
2433             return parentCachePolicy;
2434     }
2435 
2436     switch (m_loadType) {
2437     case FrameLoadType::Reload:
2438         return CachePolicyRevalidate;
2439     case FrameLoadType::Back:
2440     case FrameLoadType::Forward:
2441     case FrameLoadType::IndexedBackForward:
2442         return CachePolicyHistoryBuffer;
2443     case FrameLoadType::ReloadFromOrigin:
2444         ASSERT_NOT_REACHED(); // Already handled above.
2445         return CachePolicyReload;
2446     case FrameLoadType::RedirectWithLockedBackForwardList:
2447     case FrameLoadType::Replace:
2448     case FrameLoadType::Same:
2449     case FrameLoadType::Standard:
2450         return CachePolicyVerify;
2451     case FrameLoadType::ReloadExpiredOnly:
2452         // We know about expiration for HTTP and data. Do a normal reload otherwise.
2453         if (!url.protocolIsInHTTPFamily() &amp;&amp; !url.protocolIsData())
2454             return CachePolicyReload;
2455         return CachePolicyVerify;
2456     }
2457 
2458     RELEASE_ASSERT_NOT_REACHED();
2459     return CachePolicyVerify;
2460 }
2461 
2462 void FrameLoader::dispatchDidFailProvisionalLoad(DocumentLoader&amp; provisionalDocumentLoader, const ResourceError&amp; error)
2463 {
2464     m_provisionalLoadErrorBeingHandledURL = provisionalDocumentLoader.url();
2465 
2466 #if ENABLE(CONTENT_FILTERING)
2467     auto contentFilter = provisionalDocumentLoader.contentFilter();
2468     auto contentFilterWillContinueLoading = false;
2469 #endif
2470 
2471     auto willContinueLoading = WillContinueLoading::No;
2472     if (history().provisionalItem())
2473         willContinueLoading = WillContinueLoading::Yes;
2474 #if ENABLE(CONTENT_FILTERING)
2475     if (contentFilter &amp;&amp; contentFilter-&gt;willHandleProvisionalLoadFailure(error)) {
2476         willContinueLoading = WillContinueLoading::Yes;
2477         contentFilterWillContinueLoading = true;
2478     }
2479 #endif
2480 
2481     m_client.dispatchDidFailProvisionalLoad(error, willContinueLoading);
2482 
2483 #if ENABLE(CONTENT_FILTERING)
2484     if (contentFilterWillContinueLoading)
2485         contentFilter-&gt;handleProvisionalLoadFailure(error);
2486 #endif
2487 
2488     m_provisionalLoadErrorBeingHandledURL = { };
2489 }
2490 
2491 void FrameLoader::checkLoadCompleteForThisFrame()
2492 {
2493     ASSERT(m_client.hasWebView());
2494 
2495     // FIXME: Should this check be done in checkLoadComplete instead of here?
2496     // FIXME: Why does this one check need to be repeated here, and not the many others from checkCompleted?
2497     if (m_frame.document()-&gt;isDelayingLoadEvent())
2498         return;
2499 
2500     switch (m_state) {
2501         case FrameStateProvisional: {
2502             // FIXME: Prohibiting any provisional load failures from being sent to clients
2503             // while handling provisional load failures is too heavy. For example, the current
2504             // load will fail to cancel another ongoing load. That might prevent clients&#39; page
2505             // load state being handled properly.
2506             if (!m_provisionalLoadErrorBeingHandledURL.isEmpty())
2507                 return;
2508 
2509             RefPtr&lt;DocumentLoader&gt; pdl = m_provisionalDocumentLoader;
2510             if (!pdl)
2511                 return;
2512 
2513             // If we&#39;ve received any errors we may be stuck in the provisional state and actually complete.
2514             const ResourceError&amp; error = pdl-&gt;mainDocumentError();
2515             if (error.isNull())
2516                 return;
2517 
2518             // Check all children first.
2519             RefPtr&lt;HistoryItem&gt; item;
2520             if (Page* page = m_frame.page())
2521                 if (isBackForwardLoadType(loadType()))
2522                     // Reset the back forward list to the last committed history item at the top level.
2523                     item = page-&gt;mainFrame().loader().history().currentItem();
2524 
2525             // Only reset if we aren&#39;t already going to a new provisional item.
2526             bool shouldReset = !history().provisionalItem();
2527             if (!pdl-&gt;isLoadingInAPISense() || pdl-&gt;isStopping()) {
2528                 FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;checkLoadCompleteForThisFrame: Failed provisional load (isTimeout = %d, isCancellation = %d, errorCode = %d)&quot;, error.isTimeout(), error.isCancellation(), error.errorCode());
2529 
2530                 dispatchDidFailProvisionalLoad(*pdl, error);
2531                 ASSERT(!pdl-&gt;isLoading());
2532 
2533                 // If we&#39;re in the middle of loading multipart data, we need to restore the document loader.
2534                 if (isReplacing() &amp;&amp; !m_documentLoader.get())
2535                     setDocumentLoader(m_provisionalDocumentLoader.get());
2536 
2537                 // Finish resetting the load state, but only if another load hasn&#39;t been started by the
2538                 // delegate callback.
2539                 if (pdl == m_provisionalDocumentLoader)
2540                     clearProvisionalLoad();
2541                 else if (activeDocumentLoader()) {
2542                     URL unreachableURL = activeDocumentLoader()-&gt;unreachableURL();
2543                     if (!unreachableURL.isEmpty() &amp;&amp; unreachableURL == pdl-&gt;request().url())
2544                         shouldReset = false;
2545                 }
2546             }
2547             if (shouldReset &amp;&amp; item)
2548                 if (Page* page = m_frame.page()) {
2549                     page-&gt;backForward().setCurrentItem(*item);
2550                 }
2551             return;
2552         }
2553 
2554         case FrameStateCommittedPage: {
2555             if (!m_documentLoader)
2556                 return;
2557             if (m_documentLoader-&gt;isLoadingInAPISense() &amp;&amp; !m_documentLoader-&gt;isStopping() &amp;&amp; !m_checkingLoadCompleteForDetachment)
2558                 return;
2559 
2560             setState(FrameStateComplete);
2561 
2562             // FIXME: Is this subsequent work important if we already navigated away?
2563             // Maybe there are bugs because of that, or extra work we can skip because
2564             // the new page is ready.
2565 
2566             m_client.forceLayoutForNonHTML();
2567 
2568             // If the user had a scroll point, scroll to it, overriding the anchor point if any.
2569             if (m_frame.page()) {
2570                 if (isBackForwardLoadType(m_loadType) || isReload(m_loadType))
2571                     history().restoreScrollPositionAndViewState();
2572             }
2573 
2574             if (m_stateMachine.creatingInitialEmptyDocument() || !m_stateMachine.committedFirstRealDocumentLoad())
2575                 return;
2576 
2577             m_progressTracker-&gt;progressCompleted();
2578             Page* page = m_frame.page();
2579             if (page) {
2580                 if (m_frame.isMainFrame()) {
2581                     tracePoint(MainResourceLoadDidEnd);
2582                     page-&gt;didFinishLoad();
2583                 }
2584             }
2585 
2586             const ResourceError&amp; error = m_documentLoader-&gt;mainDocumentError();
2587 
2588             AXObjectCache::AXLoadingEvent loadingEvent;
2589             if (!error.isNull()) {
2590                 FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;checkLoadCompleteForThisFrame: Finished frame load with error (isTimeout = %d, isCancellation = %d, errorCode = %d)&quot;, error.isTimeout(), error.isCancellation(), error.errorCode());
2591                 m_client.dispatchDidFailLoad(error);
2592                 loadingEvent = AXObjectCache::AXLoadingFailed;
2593             } else {
2594                 FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;checkLoadCompleteForThisFrame: Finished frame load&quot;);
2595 #if ENABLE(DATA_DETECTION)
2596                 auto* document = m_frame.document();
2597                 if (m_frame.settings().dataDetectorTypes() != DataDetectorTypeNone &amp;&amp; document) {
2598                     if (auto* documentElement = document-&gt;documentElement()) {
2599                         RefPtr&lt;Range&gt; documentRange = makeRange(firstPositionInNode(documentElement), lastPositionInNode(documentElement));
2600                         m_frame.setDataDetectionResults(DataDetection::detectContentInRange(documentRange, m_frame.settings().dataDetectorTypes(), m_client.dataDetectionContext()));
2601                         if (m_frame.isMainFrame())
2602                             m_client.dispatchDidFinishDataDetection(m_frame.dataDetectionResults());
2603                     }
2604                 }
2605 #endif
2606                 m_client.dispatchDidFinishLoad();
2607                 loadingEvent = AXObjectCache::AXLoadingFinished;
2608             }
2609 
2610             // Notify accessibility.
2611             if (auto* document = m_frame.document()) {
2612                 if (AXObjectCache* cache = document-&gt;existingAXObjectCache())
2613                     cache-&gt;frameLoadingEventNotification(&amp;m_frame, loadingEvent);
2614             }
2615 
2616             // The above calls to dispatchDidFinishLoad() might have detached the Frame
2617             // from its Page and also might have caused Page to be deleted.
2618             // Don&#39;t assume &#39;page&#39; is still available to use.
2619             if (m_frame.isMainFrame() &amp;&amp; m_frame.page()) {
2620                 ASSERT(&amp;m_frame.page()-&gt;mainFrame() == &amp;m_frame);
2621                 m_frame.page()-&gt;diagnosticLoggingClient().logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageLoadedKey(), emptyString(), error.isNull() ? DiagnosticLoggingResultPass : DiagnosticLoggingResultFail, ShouldSample::Yes);
2622             }
2623 
2624             return;
2625         }
2626 
2627         case FrameStateComplete:
2628             m_loadType = FrameLoadType::Standard;
2629             frameLoadCompleted();
2630             return;
2631     }
2632 
2633     ASSERT_NOT_REACHED();
2634 }
2635 
2636 void FrameLoader::setOriginalURLForDownloadRequest(ResourceRequest&amp; request)
2637 {
2638     // FIXME: Rename firstPartyForCookies back to mainDocumentURL. It was a mistake to think that it was only used for cookies.
2639     // The originalURL is defined as the URL of the page where the download was initiated.
2640     URL originalURL;
2641     auto* initiator = m_frame.document();
2642     if (initiator) {
2643         originalURL = initiator-&gt;firstPartyForCookies();
2644         // If there is no main document URL, it means that this document is newly opened and just for download purpose.
2645         // In this case, we need to set the originalURL to this document&#39;s opener&#39;s main document URL.
2646         if (originalURL.isEmpty() &amp;&amp; opener() &amp;&amp; opener()-&gt;document()) {
2647             originalURL = opener()-&gt;document()-&gt;firstPartyForCookies();
2648             initiator = opener()-&gt;document();
2649         }
2650     }
2651     // If the originalURL is the same as the requested URL, we are processing a download
2652     // initiated directly without a page and do not need to specify the originalURL.
2653     if (originalURL == request.url())
2654         request.setFirstPartyForCookies(URL());
2655     else
2656         request.setFirstPartyForCookies(originalURL);
2657     addSameSiteInfoToRequestIfNeeded(request, initiator);
2658 }
2659 
2660 void FrameLoader::didReachLayoutMilestone(OptionSet&lt;LayoutMilestone&gt; milestones)
2661 {
2662     ASSERT(m_frame.isMainFrame());
2663 
2664     m_client.dispatchDidReachLayoutMilestone(milestones);
2665 }
2666 
2667 void FrameLoader::didFirstLayout()
2668 {
2669 #if PLATFORM(IOS_FAMILY)
2670     // Only send layout-related delegate callbacks synchronously for the main frame to
2671     // avoid reentering layout for the main frame while delivering a layout-related delegate
2672     // callback for a subframe.
2673     if (&amp;m_frame != &amp;m_frame.page()-&gt;mainFrame())
2674         return;
2675 #endif
2676     if (m_frame.page() &amp;&amp; isBackForwardLoadType(m_loadType))
2677         history().restoreScrollPositionAndViewState();
2678 
2679     if (m_stateMachine.committedFirstRealDocumentLoad() &amp;&amp; !m_stateMachine.isDisplayingInitialEmptyDocument() &amp;&amp; !m_stateMachine.firstLayoutDone())
2680         m_stateMachine.advanceTo(FrameLoaderStateMachine::FirstLayoutDone);
2681 }
2682 
2683 void FrameLoader::frameLoadCompleted()
2684 {
2685     // Note: Can be called multiple times.
2686 
2687     m_client.frameLoadCompleted();
2688 
2689     history().updateForFrameLoadCompleted();
2690 
2691     // After a canceled provisional load, firstLayoutDone is false.
2692     // Reset it to true if we&#39;re displaying a page.
2693     if (m_documentLoader &amp;&amp; m_stateMachine.committedFirstRealDocumentLoad() &amp;&amp; !m_stateMachine.isDisplayingInitialEmptyDocument() &amp;&amp; !m_stateMachine.firstLayoutDone())
2694         m_stateMachine.advanceTo(FrameLoaderStateMachine::FirstLayoutDone);
2695 }
2696 
2697 void FrameLoader::detachChildren()
2698 {
2699     // detachChildren() will fire the unload event in each subframe and the
2700     // HTML specification states that the parent document&#39;s ignore-opens-during-unload counter while
2701     // this event is being fired in its subframes:
2702     // https://html.spec.whatwg.org/multipage/browsers.html#unload-a-document
2703     IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(m_frame.document());
2704 
2705     // detachChildren() will fire the unload event in each subframe and the
2706     // HTML specification states that navigations should be prevented during the prompt to unload algorithm:
2707     // https://html.spec.whatwg.org/multipage/browsing-the-web.html#navigate
2708     std::unique_ptr&lt;NavigationDisabler&gt; navigationDisabler;
2709     if (m_frame.isMainFrame())
2710         navigationDisabler = makeUnique&lt;NavigationDisabler&gt;(&amp;m_frame);
2711 
2712     // Any subframe inserted by unload event handlers executed in the loop below will not get unloaded
2713     // because we create a copy of the subframes list before looping. Therefore, it would be unsafe to
2714     // allow loading of subframes at this point.
2715     SubframeLoadingDisabler subframeLoadingDisabler(m_frame.document());
2716 
2717     Vector&lt;Ref&lt;Frame&gt;, 16&gt; childrenToDetach;
2718     childrenToDetach.reserveInitialCapacity(m_frame.tree().childCount());
2719     for (Frame* child = m_frame.tree().lastChild(); child; child = child-&gt;tree().previousSibling())
2720         childrenToDetach.uncheckedAppend(*child);
2721     for (auto&amp; child : childrenToDetach)
2722         child-&gt;loader().detachFromParent();
2723 }
2724 
2725 void FrameLoader::closeAndRemoveChild(Frame&amp; child)
2726 {
2727     child.tree().detachFromParent();
2728 
2729     child.setView(nullptr);
2730     if (child.ownerElement() &amp;&amp; child.page())
2731         child.page()-&gt;decrementSubframeCount();
2732     child.willDetachPage();
2733     child.detachFromPage();
2734 
2735     m_frame.tree().removeChild(child);
2736 }
2737 
2738 // Called every time a resource is completely loaded or an error is received.
2739 void FrameLoader::checkLoadComplete()
2740 {
2741     m_shouldCallCheckLoadComplete = false;
2742 
2743     if (!m_frame.page())
2744         return;
2745 
2746     ASSERT(m_client.hasWebView());
2747 
2748     // FIXME: Always traversing the entire frame tree is a bit inefficient, but
2749     // is currently needed in order to null out the previous history item for all frames.
2750     Vector&lt;Ref&lt;Frame&gt;, 16&gt; frames;
2751     for (Frame* frame = &amp;m_frame.mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
2752         frames.append(*frame);
2753 
2754     // To process children before their parents, iterate the vector backwards.
2755     for (auto frame = frames.rbegin(); frame != frames.rend(); ++frame) {
2756         if ((*frame)-&gt;page())
2757             (*frame)-&gt;loader().checkLoadCompleteForThisFrame();
2758     }
2759 }
2760 
2761 int FrameLoader::numPendingOrLoadingRequests(bool recurse) const
2762 {
2763     if (!recurse)
2764         return m_frame.document()-&gt;cachedResourceLoader().requestCount();
2765 
2766     int count = 0;
2767     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame))
2768         count += frame-&gt;document()-&gt;cachedResourceLoader().requestCount();
2769     return count;
2770 }
2771 
2772 String FrameLoader::userAgent(const URL&amp; url) const
2773 {
2774     String userAgent;
2775 
2776     if (auto* documentLoader = m_frame.mainFrame().loader().activeDocumentLoader()) {
2777         if (m_frame.settings().needsSiteSpecificQuirks())
2778             userAgent = documentLoader-&gt;customUserAgentAsSiteSpecificQuirks();
2779         if (userAgent.isEmpty())
2780             userAgent = documentLoader-&gt;customUserAgent();
2781     }
2782 
2783     InspectorInstrumentation::applyUserAgentOverride(m_frame, userAgent);
2784 
2785     if (!userAgent.isEmpty())
2786         return userAgent;
2787 
2788     return m_client.userAgent(url);
2789 }
2790 
2791 String FrameLoader::navigatorPlatform() const
2792 {
2793     if (auto* documentLoader = m_frame.mainFrame().loader().activeDocumentLoader()) {
2794         auto&amp; customNavigatorPlatform = documentLoader-&gt;customNavigatorPlatform();
2795         if (!customNavigatorPlatform.isEmpty())
2796             return customNavigatorPlatform;
2797     }
2798     return String();
2799 }
2800 
2801 void FrameLoader::dispatchOnloadEvents()
2802 {
2803     m_client.dispatchDidDispatchOnloadEvents();
2804 
2805     if (documentLoader())
2806         documentLoader()-&gt;dispatchOnloadEvents();
2807 }
2808 
2809 void FrameLoader::frameDetached()
2810 {
2811     // Calling stopAllLoadersAndCheckCompleteness() can cause the frame to be deallocated, including the frame loader.
2812     Ref&lt;Frame&gt; protectedFrame(m_frame);
2813 
2814     if (m_checkTimer.isActive()) {
2815         m_checkTimer.stop();
2816         checkCompletenessNow();
2817     }
2818 
2819     if (m_frame.document()-&gt;backForwardCacheState() != Document::InBackForwardCache) {
2820         stopAllLoadersAndCheckCompleteness();
2821         m_frame.document()-&gt;stopActiveDOMObjects();
2822     }
2823 
2824     detachFromParent();
2825 }
2826 
2827 void FrameLoader::detachFromParent()
2828 {
2829     // Calling stopAllLoaders() can cause the frame to be deallocated, including the frame loader.
2830     Ref&lt;Frame&gt; protect(m_frame);
2831 
2832     closeURL();
2833     history().saveScrollPositionAndViewStateToItem(history().currentItem());
2834     detachChildren();
2835     if (m_frame.document()-&gt;backForwardCacheState() != Document::InBackForwardCache) {
2836         // stopAllLoaders() needs to be called after detachChildren() if the document is not in the back/forward cache,
2837         // because detachedChildren() will trigger the unload event handlers of any child frames, and those event
2838         // handlers might start a new subresource load in this frame.
2839         stopAllLoaders(ShouldClearProvisionalItem, StopLoadingPolicy::AlwaysStopLoading);
2840     }
2841 
2842     InspectorInstrumentation::frameDetachedFromParent(m_frame);
2843 
2844     detachViewsAndDocumentLoader();
2845 
2846     m_progressTracker = nullptr;
2847 
2848     if (Frame* parent = m_frame.tree().parent()) {
2849         parent-&gt;loader().closeAndRemoveChild(m_frame);
2850         parent-&gt;loader().scheduleCheckCompleted();
2851         parent-&gt;loader().scheduleCheckLoadComplete();
2852     } else {
2853         m_frame.setView(nullptr);
2854         m_frame.willDetachPage();
2855         m_frame.detachFromPage();
2856     }
2857 }
2858 
2859 void FrameLoader::detachViewsAndDocumentLoader()
2860 {
2861     m_client.detachedFromParent2();
2862     setDocumentLoader(nullptr);
2863     m_client.detachedFromParent3();
2864 }
2865 
2866 void FrameLoader::addExtraFieldsToSubresourceRequest(ResourceRequest&amp; request)
2867 {
2868     addExtraFieldsToRequest(request, m_loadType, false);
2869 }
2870 
2871 void FrameLoader::addExtraFieldsToMainResourceRequest(ResourceRequest&amp; request)
2872 {
2873     // FIXME: Using m_loadType seems wrong for some callers.
2874     // If we are only preparing to load the main resource, that is previous load&#39;s load type!
2875     addExtraFieldsToRequest(request, m_loadType, true);
2876 
2877     // Upgrade-Insecure-Requests should only be added to main resource requests
2878     addHTTPUpgradeInsecureRequestsIfNeeded(request);
2879 }
2880 
2881 ResourceRequestCachePolicy FrameLoader::defaultRequestCachingPolicy(const ResourceRequest&amp; request, FrameLoadType loadType, bool isMainResource)
2882 {
2883     if (m_overrideCachePolicyForTesting)
2884         return m_overrideCachePolicyForTesting.value();
2885 
2886     if (isMainResource) {
2887         if (isReload(loadType) || request.isConditional())
2888             return ResourceRequestCachePolicy::ReloadIgnoringCacheData;
2889 
2890         return ResourceRequestCachePolicy::UseProtocolCachePolicy;
2891     }
2892 
2893     if (request.isConditional())
2894         return ResourceRequestCachePolicy::ReloadIgnoringCacheData;
2895 
2896     if (documentLoader()-&gt;isLoadingInAPISense()) {
2897         // If we inherit cache policy from a main resource, we use the DocumentLoader&#39;s
2898         // original request cache policy for two reasons:
2899         // 1. For POST requests, we mutate the cache policy for the main resource,
2900         //    but we do not want this to apply to subresources
2901         // 2. Delegates that modify the cache policy using willSendRequest: should
2902         //    not affect any other resources. Such changes need to be done
2903         //    per request.
2904         ResourceRequestCachePolicy mainDocumentOriginalCachePolicy = documentLoader()-&gt;originalRequest().cachePolicy();
2905         // Back-forward navigations try to load main resource from cache only to avoid re-submitting form data, and start over (with a warning dialog) if that fails.
2906         // This policy is set on initial request too, but should not be inherited.
2907         return (mainDocumentOriginalCachePolicy == ResourceRequestCachePolicy::ReturnCacheDataDontLoad) ? ResourceRequestCachePolicy::ReturnCacheDataElseLoad : mainDocumentOriginalCachePolicy;
2908     }
2909 
2910     return ResourceRequestCachePolicy::UseProtocolCachePolicy;
2911 }
2912 
2913 void FrameLoader::addExtraFieldsToRequest(ResourceRequest&amp; request, FrameLoadType loadType, bool isMainResource)
2914 {
2915     // If the request came from a previous process due to process-swap-on-navigation then we should not modify the request.
2916     if (m_currentLoadContinuingState == LoadContinuingState::ContinuingWithRequest)
2917         return;
2918 
2919     // Don&#39;t set the cookie policy URL if it&#39;s already been set.
2920     // But make sure to set it on all requests regardless of protocol, as it has significance beyond the cookie policy (&lt;rdar://problem/6616664&gt;).
2921     bool isMainFrameMainResource = isMainResource &amp;&amp; m_frame.isMainFrame();
2922     if (request.firstPartyForCookies().isEmpty()) {
2923         if (isMainFrameMainResource)
2924             request.setFirstPartyForCookies(request.url());
2925         else if (Document* document = m_frame.document())
2926             request.setFirstPartyForCookies(document-&gt;firstPartyForCookies());
2927     }
2928 
2929     if (request.isSameSiteUnspecified()) {
2930         auto* initiator = m_frame.document();
2931         if (isMainResource) {
2932             auto* ownerFrame = m_frame.tree().parent();
2933             if (!ownerFrame &amp;&amp; m_stateMachine.isDisplayingInitialEmptyDocument())
2934                 ownerFrame = m_opener;
2935             if (ownerFrame)
2936                 initiator = ownerFrame-&gt;document();
2937             ASSERT(ownerFrame || m_frame.isMainFrame());
2938         }
2939         addSameSiteInfoToRequestIfNeeded(request, initiator);
2940     }
2941     request.setIsTopSite(isMainFrameMainResource);
2942 
2943     Page* page = frame().page();
2944     bool hasSpecificCachePolicy = request.cachePolicy() != ResourceRequestCachePolicy::UseProtocolCachePolicy;
2945 
2946     if (page &amp;&amp; page-&gt;isResourceCachingDisabledByWebInspector()) {
2947         request.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
2948         loadType = FrameLoadType::ReloadFromOrigin;
2949     } else if (!hasSpecificCachePolicy)
2950         request.setCachePolicy(defaultRequestCachingPolicy(request, loadType, isMainResource));
2951 
2952     // The remaining modifications are only necessary for HTTP and HTTPS.
2953     if (!request.url().isEmpty() &amp;&amp; !request.url().protocolIsInHTTPFamily())
2954         return;
2955 
2956     if (!hasSpecificCachePolicy &amp;&amp; request.cachePolicy() == ResourceRequestCachePolicy::ReloadIgnoringCacheData) {
2957         if (loadType == FrameLoadType::Reload)
2958             request.setHTTPHeaderField(HTTPHeaderName::CacheControl, HTTPHeaderValues::maxAge0());
2959         else if (loadType == FrameLoadType::ReloadFromOrigin) {
2960             request.setHTTPHeaderField(HTTPHeaderName::CacheControl, HTTPHeaderValues::noCache());
2961             request.setHTTPHeaderField(HTTPHeaderName::Pragma, HTTPHeaderValues::noCache());
2962         }
2963     }
2964 
2965     if (m_overrideResourceLoadPriorityForTesting)
2966         request.setPriority(m_overrideResourceLoadPriorityForTesting.value());
2967 
2968     applyUserAgentIfNeeded(request);
2969 
2970     if (isMainResource)
2971         request.setHTTPAccept(defaultAcceptHeader);
2972 
2973     // Make sure we send the Origin header.
2974     addHTTPOriginIfNeeded(request, String());
2975 
2976     // Only set fallback array if it&#39;s still empty (later attempts may be incorrect, see bug 117818).
2977     if (request.responseContentDispositionEncodingFallbackArray().isEmpty()) {
2978         // Always try UTF-8. If that fails, try frame encoding (if any) and then the default.
2979         request.setResponseContentDispositionEncodingFallbackArray(&quot;UTF-8&quot;, m_frame.document()-&gt;encoding(), m_frame.settings().defaultTextEncodingName());
2980     }
2981 }
2982 
2983 void FrameLoader::addHTTPOriginIfNeeded(ResourceRequest&amp; request, const String&amp; origin)
2984 {
2985     if (!request.httpOrigin().isEmpty())
2986         return;  // Request already has an Origin header.
2987 
2988     // Don&#39;t send an Origin header for GET or HEAD to avoid privacy issues.
2989     // For example, if an intranet page has a hyperlink to an external web
2990     // site, we don&#39;t want to include the Origin of the request because it
2991     // will leak the internal host name. Similar privacy concerns have lead
2992     // to the widespread suppression of the Referer header at the network
2993     // layer.
2994     if (request.httpMethod() == &quot;GET&quot; || request.httpMethod() == &quot;HEAD&quot;)
2995         return;
2996 
2997     // For non-GET and non-HEAD methods, always send an Origin header so the
2998     // server knows we support this feature.
2999 
3000     if (origin.isEmpty()) {
3001         // If we don&#39;t know what origin header to attach, we attach the value
3002         // for an empty origin.
3003         request.setHTTPOrigin(SecurityOrigin::createUnique()-&gt;toString());
3004         return;
3005     }
3006 
3007     request.setHTTPOrigin(origin);
3008 }
3009 
3010 // Implements the &quot;&#39;Same-site&#39; and &#39;cross-site&#39; Requests&quot; algorithm from &lt;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00#section-2.1&gt;.
3011 // The algorithm is ammended to treat URLs that inherit their security origin from their owner (e.g. about:blank)
3012 // as same-site. This matches the behavior of Chrome and Firefox.
3013 void FrameLoader::addSameSiteInfoToRequestIfNeeded(ResourceRequest&amp; request, const Document* initiator)
3014 {
3015     if (!request.isSameSiteUnspecified())
3016         return;
3017     if (!initiator) {
3018         request.setIsSameSite(true);
3019         return;
3020     }
3021     if (SecurityPolicy::shouldInheritSecurityOriginFromOwner(request.url())) {
3022         request.setIsSameSite(true);
3023         return;
3024     }
3025     request.setIsSameSite(areRegistrableDomainsEqual(initiator-&gt;siteForCookies(), request.url()));
3026 }
3027 
3028 void FrameLoader::addHTTPUpgradeInsecureRequestsIfNeeded(ResourceRequest&amp; request)
3029 {
3030     if (request.url().protocolIs(&quot;https&quot;)) {
3031         // FIXME: Identify HSTS cases and avoid adding the header. &lt;https://bugs.webkit.org/show_bug.cgi?id=157885&gt;
3032         return;
3033     }
3034 
3035     request.setHTTPHeaderField(HTTPHeaderName::UpgradeInsecureRequests, &quot;1&quot;_s);
3036 }
3037 
3038 void FrameLoader::loadPostRequest(FrameLoadRequest&amp;&amp; request, const String&amp; referrer, FrameLoadType loadType, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
3039 {
3040     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadPostRequest: frame load started&quot;);
3041 
3042     String frameName = request.frameName();
3043     LockHistory lockHistory = request.lockHistory();
3044     AllowNavigationToInvalidURL allowNavigationToInvalidURL = request.allowNavigationToInvalidURL();
3045     NewFrameOpenerPolicy openerPolicy = request.newFrameOpenerPolicy();
3046 
3047     const ResourceRequest&amp; inRequest = request.resourceRequest();
3048     const URL&amp; url = inRequest.url();
3049     const String&amp; contentType = inRequest.httpContentType();
3050     String origin = inRequest.httpOrigin();
3051 
3052     ResourceRequest workingResourceRequest(url);
3053 
3054     if (!referrer.isEmpty())
3055         workingResourceRequest.setHTTPReferrer(referrer);
3056     workingResourceRequest.setHTTPOrigin(origin);
3057     workingResourceRequest.setHTTPMethod(&quot;POST&quot;);
3058     workingResourceRequest.setHTTPBody(inRequest.httpBody());
3059     workingResourceRequest.setHTTPContentType(contentType);
3060     addExtraFieldsToRequest(workingResourceRequest, loadType, true);
3061 
3062     if (Document* document = m_frame.document())
3063         document-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(workingResourceRequest, ContentSecurityPolicy::InsecureRequestType::Load);
3064 
3065     NavigationAction action { request.requester(), workingResourceRequest, request.initiatedByMainFrame(), loadType, true, event, request.shouldOpenExternalURLsPolicy(), request.downloadAttribute() };
3066 
3067     if (!frameName.isEmpty()) {
3068         // The search for a target frame is done earlier in the case of form submission.
3069         if (auto* targetFrame = formState ? nullptr : findFrameForNavigation(frameName)) {
3070             targetFrame-&gt;loader().loadWithNavigationAction(workingResourceRequest, WTFMove(action), lockHistory, loadType, WTFMove(formState), allowNavigationToInvalidURL, { }, WTFMove(completionHandler));
3071             return;
3072         }
3073 
3074         policyChecker().checkNewWindowPolicy(WTFMove(action), WTFMove(workingResourceRequest), WTFMove(formState), frameName, [this, allowNavigationToInvalidURL, openerPolicy, completionHandler = WTFMove(completionHandler)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, const NavigationAction&amp; action, PolicyChecker::ShouldContinue shouldContinue) mutable {
3075             continueLoadAfterNewWindowPolicy(request, formState.get(), frameName, action, shouldContinue, allowNavigationToInvalidURL, openerPolicy);
3076             completionHandler();
3077         });
3078         return;
3079     }
3080 
3081     // must grab this now, since this load may stop the previous load and clear this flag
3082     bool isRedirect = m_quickRedirectComing;
3083     loadWithNavigationAction(workingResourceRequest, WTFMove(action), lockHistory, loadType, WTFMove(formState), allowNavigationToInvalidURL, { }, [this, isRedirect, protectedFrame = makeRef(m_frame), completionHandler = WTFMove(completionHandler)] () mutable {
3084         if (isRedirect) {
3085             m_quickRedirectComing = false;
3086             if (m_provisionalDocumentLoader)
3087                 m_provisionalDocumentLoader-&gt;setIsClientRedirect(true);
3088             else if (m_policyDocumentLoader)
3089                 m_policyDocumentLoader-&gt;setIsClientRedirect(true);
3090         }
3091         completionHandler();
3092     });
3093 }
3094 
3095 unsigned long FrameLoader::loadResourceSynchronously(const ResourceRequest&amp; request, ClientCredentialPolicy clientCredentialPolicy, const FetchOptions&amp; options, const HTTPHeaderMap&amp; originalRequestHeaders, ResourceError&amp; error, ResourceResponse&amp; response, RefPtr&lt;SharedBuffer&gt;&amp; data)
3096 {
3097     ASSERT(m_frame.document());
3098     String referrer = SecurityPolicy::generateReferrerHeader(m_frame.document()-&gt;referrerPolicy(), request.url(), outgoingReferrer());
3099 
3100     ResourceRequest initialRequest = request;
3101     initialRequest.setTimeoutInterval(10);
3102 
3103     if (!referrer.isEmpty())
3104         initialRequest.setHTTPReferrer(referrer);
3105     addHTTPOriginIfNeeded(initialRequest, outgoingOrigin());
3106 
3107     initialRequest.setFirstPartyForCookies(m_frame.mainFrame().loader().documentLoader()-&gt;request().url());
3108 
3109     addExtraFieldsToSubresourceRequest(initialRequest);
3110 
3111     unsigned long identifier = 0;
3112     ResourceRequest newRequest(initialRequest);
3113     requestFromDelegate(newRequest, identifier, error);
3114 
3115 #if ENABLE(CONTENT_EXTENSIONS)
3116     if (error.isNull()) {
3117         if (auto* page = m_frame.page()) {
3118             if (m_documentLoader) {
3119                 auto results = page-&gt;userContentProvider().processContentRuleListsForLoad(newRequest.url(), ContentExtensions::ResourceType::Raw, *m_documentLoader);
3120                 bool blockedLoad = results.summary.blockedLoad;
3121                 ContentExtensions::applyResultsToRequest(WTFMove(results), page, newRequest);
3122                 if (blockedLoad) {
3123                     newRequest = { };
3124                     error = ResourceError(errorDomainWebKitInternal, 0, initialRequest.url(), emptyString());
3125                     response = { };
3126                     data = nullptr;
3127                 }
3128             }
3129         }
3130     }
3131 #endif
3132 
3133     m_frame.document()-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(newRequest, ContentSecurityPolicy::InsecureRequestType::Load);
3134 
3135     if (error.isNull()) {
3136         ASSERT(!newRequest.isNull());
3137 
3138         if (!documentLoader()-&gt;applicationCacheHost().maybeLoadSynchronously(newRequest, error, response, data)) {
3139             Vector&lt;char&gt; buffer;
3140             platformStrategies()-&gt;loaderStrategy()-&gt;loadResourceSynchronously(*this, identifier, newRequest, clientCredentialPolicy, options, originalRequestHeaders, error, response, buffer);
3141             data = SharedBuffer::create(WTFMove(buffer));
3142             documentLoader()-&gt;applicationCacheHost().maybeLoadFallbackSynchronously(newRequest, error, response, data);
3143             ResourceLoadObserver::shared().logSubresourceLoading(&amp;m_frame, newRequest, response,
3144                 (isScriptLikeDestination(options.destination) ? ResourceLoadObserver::FetchDestinationIsScriptLike::Yes : ResourceLoadObserver::FetchDestinationIsScriptLike::No));
3145         }
3146     }
3147     notifier().sendRemainingDelegateMessages(m_documentLoader.get(), identifier, request, response, data ? data-&gt;data() : nullptr, data ? data-&gt;size() : 0, -1, error);
3148     return identifier;
3149 }
3150 
3151 const ResourceRequest&amp; FrameLoader::originalRequest() const
3152 {
3153     return activeDocumentLoader()-&gt;originalRequestCopy();
3154 }
3155 
3156 void FrameLoader::receivedMainResourceError(const ResourceError&amp; error)
3157 {
3158     // Retain because the stop may release the last reference to it.
3159     Ref&lt;Frame&gt; protect(m_frame);
3160 
3161     RefPtr&lt;DocumentLoader&gt; loader = activeDocumentLoader();
3162     // FIXME: Don&#39;t want to do this if an entirely new load is going, so should check
3163     // that both data sources on the frame are either this or nil.
3164     stop();
3165     if (m_client.shouldFallBack(error))
3166         handleFallbackContent();
3167 
3168     if (m_state == FrameStateProvisional &amp;&amp; m_provisionalDocumentLoader) {
3169         if (m_submittedFormURL == m_provisionalDocumentLoader-&gt;originalRequestCopy().url())
3170             m_submittedFormURL = URL();
3171 
3172         // We might have made a back/forward cache item, but now we&#39;re bailing out due to an error before we ever
3173         // transitioned to the new page (before WebFrameState == commit).  The goal here is to restore any state
3174         // so that the existing view (that wenever got far enough to replace) can continue being used.
3175         history().invalidateCurrentItemCachedPage();
3176 
3177         // Call clientRedirectCancelledOrFinished here so that the frame load delegate is notified that the redirect&#39;s
3178         // status has changed, if there was a redirect. The frame load delegate may have saved some state about
3179         // the redirect in its -webView:willPerformClientRedirectToURL:delay:fireDate:forFrame:. Since we are definitely
3180         // not going to use this provisional resource, as it was cancelled, notify the frame load delegate that the redirect
3181         // has ended.
3182         if (m_sentRedirectNotification)
3183             clientRedirectCancelledOrFinished(NewLoadInProgress::No);
3184     }
3185 
3186     checkCompleted();
3187     if (m_frame.page())
3188         checkLoadComplete();
3189 }
3190 
3191 void FrameLoader::continueFragmentScrollAfterNavigationPolicy(const ResourceRequest&amp; request, bool shouldContinue)
3192 {
3193     m_quickRedirectComing = false;
3194 
3195     if (!shouldContinue)
3196         return;
3197 
3198     // Calling stopLoading() on the provisional document loader can cause the underlying
3199     // frame to be deallocated.
3200     Ref&lt;Frame&gt; protectedFrame(m_frame);
3201 
3202     // If we have a provisional request for a different document, a fragment scroll should cancel it.
3203     if (m_provisionalDocumentLoader &amp;&amp; !equalIgnoringFragmentIdentifier(m_provisionalDocumentLoader-&gt;request().url(), request.url())) {
3204         m_provisionalDocumentLoader-&gt;stopLoading();
3205         FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueFragmentScrollAfterNavigationPolicy: Clearing provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());
3206         setProvisionalDocumentLoader(nullptr);
3207     }
3208 
3209     bool isRedirect = m_quickRedirectComing || policyChecker().loadType() == FrameLoadType::RedirectWithLockedBackForwardList;
3210     loadInSameDocument(request.url(), 0, !isRedirect);
3211 }
3212 
3213 bool FrameLoader::shouldPerformFragmentNavigation(bool isFormSubmission, const String&amp; httpMethod, FrameLoadType loadType, const URL&amp; url)
3214 {
3215     // We don&#39;t do this if we are submitting a form with method other than &quot;GET&quot;, explicitly reloading,
3216     // currently displaying a frameset, or if the URL does not have a fragment.
3217     // These rules were originally based on what KHTML was doing in KHTMLPart::openURL.
3218 
3219     // FIXME: What about load types other than Standard and Reload?
3220 
3221     return (!isFormSubmission || equalLettersIgnoringASCIICase(httpMethod, &quot;get&quot;))
3222         &amp;&amp; !isReload(loadType)
3223         &amp;&amp; loadType != FrameLoadType::Same
3224         &amp;&amp; m_frame.document()-&gt;backForwardCacheState() != Document::InBackForwardCache
3225         &amp;&amp; !shouldReload(m_frame.document()-&gt;url(), url)
3226         // We don&#39;t want to just scroll if a link from within a
3227         // frameset is trying to reload the frameset into _top.
3228         &amp;&amp; !m_frame.document()-&gt;isFrameSet();
3229 }
3230 
3231 static bool itemAllowsScrollRestoration(HistoryItem* historyItem)
3232 {
3233     return !historyItem || historyItem-&gt;shouldRestoreScrollPosition();
3234 }
3235 
3236 static bool isSameDocumentReload(bool isNewNavigation, FrameLoadType loadType)
3237 {
3238     return !isNewNavigation &amp;&amp; !isBackForwardLoadType(loadType);
3239 }
3240 
3241 void FrameLoader::scrollToFragmentWithParentBoundary(const URL&amp; url, bool isNewNavigation)
3242 {
3243     auto view = makeRefPtr(m_frame.view());
3244     auto document = makeRefPtr(m_frame.document());
3245     if (!view || !document)
3246         return;
3247 
3248     if (isSameDocumentReload(isNewNavigation, m_loadType) || itemAllowsScrollRestoration(history().currentItem())) {
3249         // https://html.spec.whatwg.org/multipage/browsing-the-web.html#try-to-scroll-to-the-fragment
3250         if (!document-&gt;haveStylesheetsLoaded())
3251             document-&gt;setGotoAnchorNeededAfterStylesheetsLoad(true);
3252         else
3253             view-&gt;scrollToFragment(url);
3254     }
3255 
3256 }
3257 
3258 bool FrameLoader::shouldClose()
3259 {
3260     Page* page = m_frame.page();
3261     if (!page)
3262         return true;
3263     if (!page-&gt;chrome().canRunBeforeUnloadConfirmPanel())
3264         return true;
3265 
3266     // Store all references to each subframe in advance since beforeunload&#39;s event handler may modify frame
3267     Vector&lt;Ref&lt;Frame&gt;, 16&gt; targetFrames;
3268     targetFrames.append(m_frame);
3269     for (Frame* child = m_frame.tree().firstChild(); child; child = child-&gt;tree().traverseNext(&amp;m_frame))
3270         targetFrames.append(*child);
3271 
3272     bool shouldClose = false;
3273     {
3274         NavigationDisabler navigationDisabler(&amp;m_frame);
3275         IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(m_frame.document());
3276         size_t i;
3277 
3278         for (i = 0; i &lt; targetFrames.size(); i++) {
3279             if (!targetFrames[i]-&gt;tree().isDescendantOf(&amp;m_frame))
3280                 continue;
3281             if (!targetFrames[i]-&gt;loader().dispatchBeforeUnloadEvent(page-&gt;chrome(), this))
3282                 break;
3283         }
3284 
3285         if (i == targetFrames.size())
3286             shouldClose = true;
3287     }
3288 
3289     if (!shouldClose)
3290         m_submittedFormURL = URL();
3291 
3292     m_currentNavigationHasShownBeforeUnloadConfirmPanel = false;
3293     return shouldClose;
3294 }
3295 
3296 void FrameLoader::dispatchUnloadEvents(UnloadEventPolicy unloadEventPolicy)
3297 {
3298     if (!m_frame.document())
3299         return;
3300 
3301     if (m_pageDismissalEventBeingDispatched != PageDismissalType::None)
3302         return;
3303 
3304     // We store the frame&#39;s page in a local variable because the frame might get detached inside dispatchEvent.
3305     ForbidPromptsScope forbidPrompts(m_frame.page());
3306     ForbidSynchronousLoadsScope forbidSynchronousLoads(m_frame.page());
3307     IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(m_frame.document());
3308 
3309     if (m_didCallImplicitClose &amp;&amp; !m_wasUnloadEventEmitted) {
3310         auto* currentFocusedElement = m_frame.document()-&gt;focusedElement();
3311         if (is&lt;HTMLInputElement&gt;(currentFocusedElement))
3312             downcast&lt;HTMLInputElement&gt;(*currentFocusedElement).endEditing();
3313         if (m_pageDismissalEventBeingDispatched == PageDismissalType::None) {
3314             if (unloadEventPolicy == UnloadEventPolicyUnloadAndPageHide) {
3315                 m_pageDismissalEventBeingDispatched = PageDismissalType::PageHide;
3316                 m_frame.document()-&gt;domWindow()-&gt;dispatchEvent(PageTransitionEvent::create(eventNames().pagehideEvent, m_frame.document()-&gt;backForwardCacheState() == Document::AboutToEnterBackForwardCache), m_frame.document());
3317             }
3318 
3319             // FIXME: update Page Visibility state here.
3320             // https://bugs.webkit.org/show_bug.cgi?id=116770
3321 
3322             if (m_frame.document()-&gt;backForwardCacheState() == Document::NotInBackForwardCache) {
3323                 Ref&lt;Event&gt; unloadEvent(Event::create(eventNames().unloadEvent, Event::CanBubble::No, Event::IsCancelable::No));
3324                 // The DocumentLoader (and thus its LoadTiming) might get destroyed
3325                 // while dispatching the event, so protect it to prevent writing the end
3326                 // time into freed memory.
3327                 RefPtr&lt;DocumentLoader&gt; documentLoader = m_provisionalDocumentLoader;
3328                 m_pageDismissalEventBeingDispatched = PageDismissalType::Unload;
3329                 if (documentLoader &amp;&amp; documentLoader-&gt;timing().startTime() &amp;&amp; !documentLoader-&gt;timing().unloadEventStart() &amp;&amp; !documentLoader-&gt;timing().unloadEventEnd()) {
3330                     auto&amp; timing = documentLoader-&gt;timing();
3331                     timing.markUnloadEventStart();
3332                     m_frame.document()-&gt;domWindow()-&gt;dispatchEvent(unloadEvent, m_frame.document());
3333                     timing.markUnloadEventEnd();
3334                 } else
3335                     m_frame.document()-&gt;domWindow()-&gt;dispatchEvent(unloadEvent, m_frame.document());
3336             }
3337         }
3338         m_pageDismissalEventBeingDispatched = PageDismissalType::None;
3339         m_wasUnloadEventEmitted = true;
3340     }
3341 
3342     // Dispatching the unload event could have made m_frame.document() null.
3343     if (!m_frame.document())
3344         return;
3345 
3346     if (m_frame.document()-&gt;backForwardCacheState() != Document::NotInBackForwardCache)
3347         return;
3348 
3349     // Don&#39;t remove event listeners from a transitional empty document (see bug 28716 for more information).
3350     bool keepEventListeners = m_stateMachine.isDisplayingInitialEmptyDocument() &amp;&amp; m_provisionalDocumentLoader
3351         &amp;&amp; m_frame.document()-&gt;isSecureTransitionTo(m_provisionalDocumentLoader-&gt;url());
3352 
3353     if (!keepEventListeners)
3354         m_frame.document()-&gt;removeAllEventListeners();
3355 }
3356 
3357 static bool shouldAskForNavigationConfirmation(Document&amp; document, const BeforeUnloadEvent&amp; event)
3358 {
3359     // Confirmation dialog should not be displayed when the allow-modals flag is not set.
3360     if (document.isSandboxed(SandboxModals))
3361         return false;
3362 
3363     bool userDidInteractWithPage = document.topDocument().userDidInteractWithPage();
3364     // Web pages can request we ask for confirmation before navigating by:
3365     // - Cancelling the BeforeUnloadEvent (modern way)
3366     // - Setting the returnValue attribute on the BeforeUnloadEvent to a non-empty string.
3367     // - Returning a non-empty string from the event handler, which is then set as returnValue
3368     //   attribute on the BeforeUnloadEvent.
3369     return userDidInteractWithPage &amp;&amp; (event.defaultPrevented() || !event.returnValue().isEmpty());
3370 }
3371 
3372 bool FrameLoader::dispatchBeforeUnloadEvent(Chrome&amp; chrome, FrameLoader* frameLoaderBeingNavigated)
3373 {
3374     DOMWindow* domWindow = m_frame.document()-&gt;domWindow();
3375     if (!domWindow)
3376         return true;
3377 
3378     RefPtr&lt;Document&gt; document = m_frame.document();
3379     if (!document-&gt;bodyOrFrameset())
3380         return true;
3381 
3382     Ref&lt;BeforeUnloadEvent&gt; beforeUnloadEvent = BeforeUnloadEvent::create();
3383 
3384     {
3385         SetForScope&lt;PageDismissalType&gt; change(m_pageDismissalEventBeingDispatched, PageDismissalType::BeforeUnload);
3386         ForbidPromptsScope forbidPrompts(m_frame.page());
3387         ForbidSynchronousLoadsScope forbidSynchronousLoads(m_frame.page());
3388         domWindow-&gt;dispatchEvent(beforeUnloadEvent, domWindow-&gt;document());
3389     }
3390 
3391     if (!beforeUnloadEvent-&gt;defaultPrevented())
3392         document-&gt;defaultEventHandler(beforeUnloadEvent.get());
3393 
3394     if (!shouldAskForNavigationConfirmation(*document, beforeUnloadEvent))
3395         return true;
3396 
3397     // If the navigating FrameLoader has already shown a beforeunload confirmation panel for the current navigation attempt,
3398     // this frame is not allowed to cause another one to be shown.
3399     if (frameLoaderBeingNavigated-&gt;m_currentNavigationHasShownBeforeUnloadConfirmPanel) {
3400         document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Blocked attempt to show multiple beforeunload confirmation dialogs for the same navigation.&quot;_s);
3401         return true;
3402     }
3403 
3404     // We should only display the beforeunload dialog for an iframe if its SecurityOrigin matches all
3405     // ancestor frame SecurityOrigins up through the navigating FrameLoader.
3406     if (frameLoaderBeingNavigated != this) {
3407         Frame* parentFrame = m_frame.tree().parent();
3408         while (parentFrame) {
3409             Document* parentDocument = parentFrame-&gt;document();
3410             if (!parentDocument)
3411                 return true;
3412             if (!m_frame.document() || !m_frame.document()-&gt;securityOrigin().canAccess(parentDocument-&gt;securityOrigin())) {
3413                 document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Blocked attempt to show beforeunload confirmation dialog on behalf of a frame with different security origin. Protocols, domains, and ports must match.&quot;_s);
3414                 return true;
3415             }
3416 
3417             if (&amp;parentFrame-&gt;loader() == frameLoaderBeingNavigated)
3418                 break;
3419 
3420             parentFrame = parentFrame-&gt;tree().parent();
3421         }
3422 
3423         // The navigatingFrameLoader should always be in our ancestory.
3424         ASSERT(parentFrame);
3425         ASSERT(&amp;parentFrame-&gt;loader() == frameLoaderBeingNavigated);
3426     }
3427 
3428     frameLoaderBeingNavigated-&gt;m_currentNavigationHasShownBeforeUnloadConfirmPanel = true;
3429 
3430     String text = document-&gt;displayStringModifiedByEncoding(beforeUnloadEvent-&gt;returnValue());
3431     return chrome.runBeforeUnloadConfirmPanel(text, m_frame);
3432 }
3433 
3434 void FrameLoader::continueLoadAfterNavigationPolicy(const ResourceRequest&amp; request, FormState* formState, NavigationPolicyDecision navigationPolicyDecision, AllowNavigationToInvalidURL allowNavigationToInvalidURL)
3435 {
3436     // If we loaded an alternate page to replace an unreachableURL, we&#39;ll get in here with a
3437     // nil policyDataSource because loading the alternate page will have passed
3438     // through this method already, nested; otherwise, policyDataSource should still be set.
3439     ASSERT(m_policyDocumentLoader || !m_provisionalDocumentLoader-&gt;unreachableURL().isEmpty());
3440 
3441     bool isTargetItem = history().provisionalItem() ? history().provisionalItem()-&gt;isTargetItem() : false;
3442 
3443     bool urlIsDisallowed = allowNavigationToInvalidURL == AllowNavigationToInvalidURL::No &amp;&amp; !request.url().isValid();
3444     bool canContinue = navigationPolicyDecision == NavigationPolicyDecision::ContinueLoad &amp;&amp; shouldClose() &amp;&amp; !urlIsDisallowed;
3445 
3446     if (!canContinue) {
3447         FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame due to the following reasons (&quot;
3448             &quot;allowNavigationToInvalidURL = %d, &quot;
3449             &quot;requestURLIsValid = %d, &quot;
3450             &quot;navigationPolicyDecision = %d)&quot;,
3451             static_cast&lt;int&gt;(allowNavigationToInvalidURL),
3452             request.url().isValid(),
3453             static_cast&lt;int&gt;(navigationPolicyDecision));
3454 
3455         // If we were waiting for a quick redirect, but the policy delegate decided to ignore it, then we
3456         // need to report that the client redirect was cancelled.
3457         // FIXME: The client should be told about ignored non-quick redirects, too.
3458         if (m_quickRedirectComing)
3459             clientRedirectCancelledOrFinished(NewLoadInProgress::No);
3460 
3461         if (navigationPolicyDecision == NavigationPolicyDecision::StopAllLoads) {
3462             stopAllLoaders();
3463             m_checkTimer.stop();
3464         }
3465 
3466         setPolicyDocumentLoader(nullptr);
3467         checkCompleted();
3468 
3469         if (navigationPolicyDecision != NavigationPolicyDecision::StopAllLoads)
3470             checkLoadComplete();
3471 
3472         // If the navigation request came from the back/forward menu, and we punt on it, we have the
3473         // problem that we have optimistically moved the b/f cursor already, so move it back. For sanity,
3474         // we only do this when punting a navigation for the target frame or top-level frame.
3475         if ((isTargetItem || m_frame.isMainFrame()) &amp;&amp; isBackForwardLoadType(policyChecker().loadType())) {
3476             if (Page* page = m_frame.page()) {
3477                 if (HistoryItem* resetItem = m_frame.mainFrame().loader().history().currentItem())
3478                     page-&gt;backForward().setCurrentItem(*resetItem);
3479             }
3480         }
3481         return;
3482     }
3483 
3484     FrameLoadType type = policyChecker().loadType();
3485     // A new navigation is in progress, so don&#39;t clear the history&#39;s provisional item.
3486     stopAllLoaders(ShouldNotClearProvisionalItem);
3487 
3488     // &lt;rdar://problem/6250856&gt; - In certain circumstances on pages with multiple frames, stopAllLoaders()
3489     // might detach the current FrameLoader, in which case we should bail on this newly defunct load.
3490     if (!m_frame.page()) {
3491         FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame because it became defunct&quot;);
3492         return;
3493     }
3494 
3495     setProvisionalDocumentLoader(m_policyDocumentLoader.get());
3496     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy: Setting provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());
3497     m_loadType = type;
3498     setState(FrameStateProvisional);
3499 
3500     setPolicyDocumentLoader(nullptr);
3501 
3502     if (isBackForwardLoadType(type)) {
3503         auto&amp; diagnosticLoggingClient = m_frame.page()-&gt;diagnosticLoggingClient();
3504         if (history().provisionalItem() &amp;&amp; history().provisionalItem()-&gt;isInBackForwardCache()) {
3505             diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::backForwardCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultPass, ShouldSample::Yes);
3506             loadProvisionalItemFromCachedPage();
3507             FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame because it will be loaded from cache&quot;);
3508             return;
3509         }
3510         diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::backForwardCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultFail, ShouldSample::Yes);
3511     }
3512 
3513     CompletionHandler&lt;void()&gt; completionHandler = [this, protectedFrame = makeRef(m_frame)] () mutable {
3514         if (!m_provisionalDocumentLoader) {
3515             FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy (completionHandler): Frame load canceled - no provisional document loader before prepareForLoadStart&quot;);
3516             return;
3517         }
3518 
3519         prepareForLoadStart();
3520 
3521         // The load might be cancelled inside of prepareForLoadStart(), nulling out the m_provisionalDocumentLoader,
3522         // so we need to null check it again.
3523         if (!m_provisionalDocumentLoader) {
3524             FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy (completionHandler): Frame load canceled - no provisional document loader after prepareForLoadStart&quot;);
3525             return;
3526         }
3527 
3528         DocumentLoader* activeDocLoader = activeDocumentLoader();
3529         if (activeDocLoader &amp;&amp; activeDocLoader-&gt;isLoadingMainResource()) {
3530             FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy (completionHandler): Main frame already being loaded&quot;);
3531             return;
3532         }
3533 
3534         m_loadingFromCachedPage = false;
3535 
3536         m_provisionalDocumentLoader-&gt;startLoadingMainResource();
3537     };
3538 
3539     if (!formState) {
3540         completionHandler();
3541         return;
3542     }
3543 
3544     m_client.dispatchWillSubmitForm(*formState, WTFMove(completionHandler));
3545 }
3546 
3547 void FrameLoader::continueLoadAfterNewWindowPolicy(const ResourceRequest&amp; request,
3548     FormState* formState, const String&amp; frameName, const NavigationAction&amp; action, PolicyChecker::ShouldContinue shouldContinue, AllowNavigationToInvalidURL allowNavigationToInvalidURL, NewFrameOpenerPolicy openerPolicy)
3549 {
3550     if (shouldContinue != PolicyChecker::ShouldContinue::Yes)
3551         return;
3552 
3553     Ref&lt;Frame&gt; frame(m_frame);
3554     RefPtr&lt;Frame&gt; mainFrame = m_client.dispatchCreatePage(action);
3555     if (!mainFrame)
3556         return;
3557 
3558     SandboxFlags sandboxFlags = frame-&gt;loader().effectiveSandboxFlags();
3559     if (sandboxFlags &amp; SandboxPropagatesToAuxiliaryBrowsingContexts)
3560         mainFrame-&gt;loader().forceSandboxFlags(sandboxFlags);
3561 
3562     if (!equalIgnoringASCIICase(frameName, &quot;_blank&quot;))
3563         mainFrame-&gt;tree().setName(frameName);
3564 
3565     mainFrame-&gt;page()-&gt;setOpenedByDOM();
3566     mainFrame-&gt;loader().m_client.dispatchShow();
3567     if (openerPolicy == NewFrameOpenerPolicy::Allow) {
3568         mainFrame-&gt;loader().setOpener(frame.ptr());
3569         mainFrame-&gt;document()-&gt;setReferrerPolicy(frame-&gt;document()-&gt;referrerPolicy());
3570     }
3571 
3572     NavigationAction newAction { *frame-&gt;document(), request, InitiatedByMainFrame::Unknown, NavigationType::Other, action.shouldOpenExternalURLsPolicy(), nullptr, action.downloadAttribute() };
3573     mainFrame-&gt;loader().loadWithNavigationAction(request, WTFMove(newAction), LockHistory::No, FrameLoadType::Standard, formState, allowNavigationToInvalidURL);
3574 }
3575 
3576 void FrameLoader::requestFromDelegate(ResourceRequest&amp; request, unsigned long&amp; identifier, ResourceError&amp; error)
3577 {
3578     ASSERT(!request.isNull());
3579 
3580     identifier = 0;
3581     if (Page* page = m_frame.page()) {
3582         identifier = page-&gt;progress().createUniqueIdentifier();
3583         notifier().assignIdentifierToInitialRequest(identifier, m_documentLoader.get(), request);
3584     }
3585 
3586     ResourceRequest newRequest(request);
3587     notifier().dispatchWillSendRequest(m_documentLoader.get(), identifier, newRequest, ResourceResponse());
3588 
3589     if (newRequest.isNull())
3590         error = cancelledError(request);
3591     else
3592         error = ResourceError();
3593 
3594     request = newRequest;
3595 }
3596 
3597 void FrameLoader::loadedResourceFromMemoryCache(CachedResource&amp; resource, ResourceRequest&amp; newRequest, ResourceError&amp; error)
3598 {
3599     Page* page = m_frame.page();
3600     if (!page)
3601         return;
3602 
3603     if (!resource.shouldSendResourceLoadCallbacks() || m_documentLoader-&gt;haveToldClientAboutLoad(resource.url()))
3604         return;
3605 
3606     // Main resource delegate messages are synthesized in MainResourceLoader, so we must not send them here.
3607     if (resource.type() == CachedResource::Type::MainResource)
3608         return;
3609 
3610     if (!page-&gt;areMemoryCacheClientCallsEnabled()) {
3611         InspectorInstrumentation::didLoadResourceFromMemoryCache(*page, m_documentLoader.get(), &amp;resource);
3612         m_documentLoader-&gt;recordMemoryCacheLoadForFutureClientNotification(resource.resourceRequest());
3613         m_documentLoader-&gt;didTellClientAboutLoad(resource.url());
3614         return;
3615     }
3616 
3617     if (m_client.dispatchDidLoadResourceFromMemoryCache(m_documentLoader.get(), newRequest, resource.response(), resource.encodedSize())) {
3618         InspectorInstrumentation::didLoadResourceFromMemoryCache(*page, m_documentLoader.get(), &amp;resource);
3619         m_documentLoader-&gt;didTellClientAboutLoad(resource.url());
3620         return;
3621     }
3622 
3623     unsigned long identifier;
3624     requestFromDelegate(newRequest, identifier, error);
3625 
3626     ResourceResponse response = resource.response();
3627     response.setSource(ResourceResponse::Source::MemoryCache);
3628     notifier().sendRemainingDelegateMessages(m_documentLoader.get(), identifier, newRequest, response, 0, resource.encodedSize(), 0, error);
3629 }
3630 
3631 void FrameLoader::applyUserAgentIfNeeded(ResourceRequest&amp; request)
3632 {
3633     if (!request.hasHTTPHeaderField(HTTPHeaderName::UserAgent)) {
3634         String userAgent = this-&gt;userAgent(request.url());
3635         ASSERT(!userAgent.isNull());
3636         request.setHTTPUserAgent(userAgent);
3637     }
3638 }
3639 
3640 bool FrameLoader::shouldInterruptLoadForXFrameOptions(const String&amp; content, const URL&amp; url, unsigned long requestIdentifier)
3641 {
3642     Frame&amp; topFrame = m_frame.tree().top();
3643     if (&amp;m_frame == &amp;topFrame)
3644         return false;
3645 
3646     XFrameOptionsDisposition disposition = parseXFrameOptionsHeader(content);
3647 
3648     switch (disposition) {
3649     case XFrameOptionsSameOrigin: {
3650         auto origin = SecurityOrigin::create(url);
3651         if (!origin-&gt;isSameSchemeHostPort(topFrame.document()-&gt;securityOrigin()))
3652             return true;
3653         for (Frame* frame = m_frame.tree().parent(); frame; frame = frame-&gt;tree().parent()) {
3654             if (!origin-&gt;isSameSchemeHostPort(frame-&gt;document()-&gt;securityOrigin()))
3655                 return true;
3656         }
3657         return false;
3658     }
3659     case XFrameOptionsDeny:
3660         return true;
3661     case XFrameOptionsAllowAll:
3662         return false;
3663     case XFrameOptionsConflict:
3664         m_frame.document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Multiple &#39;X-Frame-Options&#39; headers with conflicting values (&#39;&quot; + content + &quot;&#39;) encountered when loading &#39;&quot; + url.stringCenterEllipsizedToLength() + &quot;&#39;. Falling back to &#39;DENY&#39;.&quot;, requestIdentifier);
3665         return true;
3666     case XFrameOptionsInvalid:
3667         m_frame.document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Invalid &#39;X-Frame-Options&#39; header encountered when loading &#39;&quot; + url.stringCenterEllipsizedToLength() + &quot;&#39;: &#39;&quot; + content + &quot;&#39; is not a recognized directive. The header will be ignored.&quot;, requestIdentifier);
3668         return false;
3669     case XFrameOptionsNone:
3670         return false;
3671     }
3672     ASSERT_NOT_REACHED();
3673     return false;
3674 }
3675 
3676 void FrameLoader::loadProvisionalItemFromCachedPage()
3677 {
3678     DocumentLoader* provisionalLoader = provisionalDocumentLoader();
3679     LOG(BackForwardCache, &quot;FrameLoader::loadProvisionalItemFromCachedPage Loading provisional DocumentLoader %p with URL &#39;%s&#39; from CachedPage&quot;, provisionalDocumentLoader(), provisionalDocumentLoader()-&gt;url().stringCenterEllipsizedToLength().utf8().data());
3680 
3681     prepareForLoadStart();
3682 
3683     m_loadingFromCachedPage = true;
3684 
3685     // Should have timing data from previous time(s) the page was shown.
3686     ASSERT(provisionalLoader-&gt;timing().startTime());
3687     provisionalLoader-&gt;resetTiming();
3688     provisionalLoader-&gt;timing().markStartTime();
3689 
3690     provisionalLoader-&gt;setCommitted(true);
3691     commitProvisionalLoad();
3692 }
3693 
3694 bool FrameLoader::shouldTreatURLAsSameAsCurrent(const URL&amp; url) const
3695 {
3696     if (!history().currentItem())
3697         return false;
3698     return url == history().currentItem()-&gt;url() || url == history().currentItem()-&gt;originalURL();
3699 }
3700 
3701 bool FrameLoader::shouldTreatURLAsSrcdocDocument(const URL&amp; url) const
3702 {
3703     if (!equalLettersIgnoringASCIICase(url.string(), &quot;about:srcdoc&quot;))
3704         return false;
3705     HTMLFrameOwnerElement* ownerElement = m_frame.ownerElement();
3706     if (!ownerElement)
3707         return false;
3708     if (!ownerElement-&gt;hasTagName(iframeTag))
3709         return false;
3710     return ownerElement-&gt;hasAttributeWithoutSynchronization(srcdocAttr);
3711 }
3712 
3713 Frame* FrameLoader::findFrameForNavigation(const AtomString&amp; name, Document* activeDocument)
3714 {
3715     // FIXME: Eventually all callers should supply the actual activeDocument so we can call canNavigate with the right document.
3716     if (!activeDocument)
3717         activeDocument = m_frame.document();
3718 
3719     auto* frame = m_frame.tree().find(name, activeDocument-&gt;frame() ? *activeDocument-&gt;frame() : m_frame);
3720 
3721     if (!activeDocument-&gt;canNavigate(frame))
3722         return nullptr;
3723 
3724     return frame;
3725 }
3726 
3727 void FrameLoader::loadSameDocumentItem(HistoryItem&amp; item)
3728 {
3729     ASSERT(item.documentSequenceNumber() == history().currentItem()-&gt;documentSequenceNumber());
3730 
3731     Ref&lt;Frame&gt; protect(m_frame);
3732 
3733     // Save user view state to the current history item here since we don&#39;t do a normal load.
3734     // FIXME: Does form state need to be saved here too?
3735     history().saveScrollPositionAndViewStateToItem(history().currentItem());
3736     if (FrameView* view = m_frame.view())
3737         view-&gt;setWasScrolledByUser(false);
3738 
3739     history().setCurrentItem(item);
3740 
3741     // loadInSameDocument() actually changes the URL and notifies load delegates of a &quot;fake&quot; load
3742     loadInSameDocument(item.url(), item.stateObject(), false);
3743 
3744     // Restore user view state from the current history item here since we don&#39;t do a normal load.
3745     history().restoreScrollPositionAndViewState();
3746 }
3747 
3748 // FIXME: This function should really be split into a couple pieces, some of
3749 // which should be methods of HistoryController and some of which should be
3750 // methods of FrameLoader.
3751 void FrameLoader::loadDifferentDocumentItem(HistoryItem&amp; item, HistoryItem* fromItem, FrameLoadType loadType, FormSubmissionCacheLoadPolicy cacheLoadPolicy, ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad)
3752 {
3753     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadDifferentDocumentItem: frame load started&quot;);
3754 
3755     Ref&lt;Frame&gt; protectedFrame(m_frame);
3756 
3757     // History items should not be reported to the parent.
3758     m_shouldReportResourceTimingToParentFrame = false;
3759 
3760     // Remember this item so we can traverse any child items as child frames load
3761     history().setProvisionalItem(&amp;item);
3762 
3763     auto initiatedByMainFrame = InitiatedByMainFrame::Unknown;
3764 
3765     SetForScope&lt;LoadContinuingState&gt; continuingLoadGuard(m_currentLoadContinuingState, shouldTreatAsContinuingLoad == ShouldTreatAsContinuingLoad::Yes ? LoadContinuingState::ContinuingWithHistoryItem : LoadContinuingState::NotContinuing);
3766 
3767     if (CachedPage* cachedPage = BackForwardCache::singleton().get(item, m_frame.page())) {
3768         auto documentLoader = cachedPage-&gt;documentLoader();
3769         m_client.updateCachedDocumentLoader(*documentLoader);
3770 
3771         auto action = NavigationAction { *m_frame.document(), documentLoader-&gt;request(), initiatedByMainFrame, loadType, false };
3772         action.setTargetBackForwardItem(item);
3773         action.setSourceBackForwardItem(fromItem);
3774         documentLoader-&gt;setTriggeringAction(WTFMove(action));
3775 
3776         documentLoader-&gt;setLastCheckedRequest(ResourceRequest());
3777         loadWithDocumentLoader(documentLoader, loadType, { }, AllowNavigationToInvalidURL::Yes, shouldTreatAsContinuingLoad);
3778         return;
3779     }
3780 
3781     URL itemURL = item.url();
3782     URL itemOriginalURL = item.originalURL();
3783     URL currentURL;
3784     if (documentLoader())
3785         currentURL = documentLoader()-&gt;url();
3786     RefPtr&lt;FormData&gt; formData = item.formData();
3787 
3788     ResourceRequest request(itemURL);
3789 
3790     if (!item.referrer().isNull())
3791         request.setHTTPReferrer(item.referrer());
3792 
3793     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy = shouldOpenExternalURLsPolicyToApply(m_frame, initiatedByMainFrame, item.shouldOpenExternalURLsPolicy());
3794     bool isFormSubmission = false;
3795     Event* event = nullptr;
3796 
3797     // If this was a repost that failed the page cache, we might try to repost the form.
3798     NavigationAction action;
3799     if (formData) {
3800         request.setHTTPMethod(&quot;POST&quot;);
3801         request.setHTTPBody(WTFMove(formData));
3802         request.setHTTPContentType(item.formContentType());
3803         auto securityOrigin = SecurityOrigin::createFromString(item.referrer());
3804         addHTTPOriginIfNeeded(request, securityOrigin-&gt;toString());
3805         addHTTPUpgradeInsecureRequestsIfNeeded(request);
3806 
3807         // Make sure to add extra fields to the request after the Origin header is added for the FormData case.
3808         // See https://bugs.webkit.org/show_bug.cgi?id=22194 for more discussion.
3809         addExtraFieldsToRequest(request, loadType, true);
3810 
3811         // FIXME: Slight hack to test if the NSURL cache contains the page we&#39;re going to.
3812         // We want to know this before talking to the policy delegate, since it affects whether
3813         // we show the DoYouReallyWantToRepost nag.
3814         //
3815         // This trick has a small bug (3123893) where we might find a cache hit, but then
3816         // have the item vanish when we try to use it in the ensuing nav.  This should be
3817         // extremely rare, but in that case the user will get an error on the navigation.
3818 
3819         if (cacheLoadPolicy == MayAttemptCacheOnlyLoadForFormSubmissionItem) {
3820             request.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataDontLoad);
3821             action = { *m_frame.document(), request, initiatedByMainFrame, loadType, isFormSubmission, event, shouldOpenExternalURLsPolicy };
3822         } else {
3823             request.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataElseLoad);
3824             action = { *m_frame.document(), request, initiatedByMainFrame, NavigationType::FormResubmitted, shouldOpenExternalURLsPolicy, event };
3825         }
3826     } else {
3827         switch (loadType) {
3828         case FrameLoadType::Reload:
3829         case FrameLoadType::ReloadFromOrigin:
3830         case FrameLoadType::ReloadExpiredOnly:
3831             request.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
3832             break;
3833         case FrameLoadType::Back:
3834         case FrameLoadType::Forward:
3835         case FrameLoadType::IndexedBackForward: {
3836 #if PLATFORM(COCOA)
3837             bool allowStaleData = true;
3838 #else
3839             bool allowStaleData = !item.wasRestoredFromSession();
3840 #endif
3841             if (allowStaleData)
3842                 request.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataElseLoad);
3843             item.setWasRestoredFromSession(false);
3844             break;
3845         }
3846         case FrameLoadType::Standard:
3847         case FrameLoadType::RedirectWithLockedBackForwardList:
3848             break;
3849         case FrameLoadType::Same:
3850         case FrameLoadType::Replace:
3851             ASSERT_NOT_REACHED();
3852         }
3853 
3854         addExtraFieldsToRequest(request, loadType, true);
3855 
3856         ResourceRequest requestForOriginalURL(request);
3857         requestForOriginalURL.setURL(itemOriginalURL);
3858         action = { *m_frame.document(), requestForOriginalURL, initiatedByMainFrame, loadType, isFormSubmission, event, shouldOpenExternalURLsPolicy };
3859     }
3860 
3861     action.setTargetBackForwardItem(item);
3862     action.setSourceBackForwardItem(fromItem);
3863 
3864     loadWithNavigationAction(request, WTFMove(action), LockHistory::No, loadType, { }, AllowNavigationToInvalidURL::Yes);
3865 }
3866 
3867 // Loads content into this frame, as specified by history item
3868 void FrameLoader::loadItem(HistoryItem&amp; item, HistoryItem* fromItem, FrameLoadType loadType, ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad)
3869 {
3870     m_requestedHistoryItem = &amp;item;
3871     HistoryItem* currentItem = history().currentItem();
3872     bool sameDocumentNavigation = currentItem &amp;&amp; item.shouldDoSameDocumentNavigationTo(*currentItem);
3873 
3874     if (sameDocumentNavigation)
3875         loadSameDocumentItem(item);
3876     else
3877         loadDifferentDocumentItem(item, fromItem, loadType, MayAttemptCacheOnlyLoadForFormSubmissionItem, shouldTreatAsContinuingLoad);
3878 }
3879 
3880 void FrameLoader::retryAfterFailedCacheOnlyMainResourceLoad()
3881 {
3882     ASSERT(m_state == FrameStateProvisional);
3883     ASSERT(!m_loadingFromCachedPage);
3884     ASSERT(history().provisionalItem());
3885     ASSERT(history().provisionalItem()-&gt;formData());
3886     ASSERT(history().provisionalItem() == m_requestedHistoryItem.get());
3887 
3888     FrameLoadType loadType = m_loadType;
3889     HistoryItem* item = history().provisionalItem();
3890 
3891     stopAllLoaders(ShouldNotClearProvisionalItem);
3892     if (item)
3893         loadDifferentDocumentItem(*item, history().currentItem(), loadType, MayNotAttemptCacheOnlyLoadForFormSubmissionItem, ShouldTreatAsContinuingLoad::No);
3894     else {
3895         ASSERT_NOT_REACHED();
3896         FRAMELOADER_RELEASE_LOG_ERROR(ResourceLoading, &quot;retryAfterFailedCacheOnlyMainResourceLoad: Retrying load after failed cache-only main resource load failed because there is no provisional history item.&quot;);
3897     }
3898 }
3899 
3900 ResourceError FrameLoader::cancelledError(const ResourceRequest&amp; request) const
3901 {
3902     ResourceError error = m_client.cancelledError(request);
3903     error.setType(ResourceError::Type::Cancellation);
3904     return error;
3905 }
3906 
3907 ResourceError FrameLoader::blockedByContentBlockerError(const ResourceRequest&amp; request) const
3908 {
3909     return m_client.blockedByContentBlockerError(request);
3910 }
3911 
3912 ResourceError FrameLoader::blockedError(const ResourceRequest&amp; request) const
3913 {
3914     ResourceError error = m_client.blockedError(request);
3915     error.setType(ResourceError::Type::Cancellation);
3916     return error;
3917 }
3918 
3919 #if ENABLE(CONTENT_FILTERING)
3920 ResourceError FrameLoader::blockedByContentFilterError(const ResourceRequest&amp; request) const
3921 {
3922     ResourceError error = m_client.blockedByContentFilterError(request);
3923     error.setType(ResourceError::Type::General);
3924     return error;
3925 }
3926 #endif
3927 
3928 #if PLATFORM(IOS_FAMILY)
3929 RetainPtr&lt;CFDictionaryRef&gt; FrameLoader::connectionProperties(ResourceLoader* loader)
3930 {
3931     return m_client.connectionProperties(loader-&gt;documentLoader(), loader-&gt;identifier());
3932 }
3933 #endif
3934 
3935 ReferrerPolicy FrameLoader::effectiveReferrerPolicy() const
3936 {
3937     if (auto* parentFrame = m_frame.tree().parent())
3938         return parentFrame-&gt;document()-&gt;referrerPolicy();
3939     if (m_opener)
3940         return m_opener-&gt;document()-&gt;referrerPolicy();
3941     return ReferrerPolicy::NoReferrerWhenDowngrade;
3942 }
3943 
3944 String FrameLoader::referrer() const
3945 {
3946     return m_documentLoader ? m_documentLoader-&gt;request().httpReferrer() : emptyString();
3947 }
3948 
3949 void FrameLoader::dispatchDidClearWindowObjectsInAllWorlds()
3950 {
3951     if (!m_frame.script().canExecuteScripts(NotAboutToExecuteScript))
3952         return;
3953 
3954     Vector&lt;Ref&lt;DOMWrapperWorld&gt;&gt; worlds;
3955     ScriptController::getAllWorlds(worlds);
3956     for (auto&amp; world : worlds)
3957         dispatchDidClearWindowObjectInWorld(world);
3958 }
3959 
3960 void FrameLoader::dispatchDidClearWindowObjectInWorld(DOMWrapperWorld&amp; world)
3961 {
3962     if (!m_frame.script().canExecuteScripts(NotAboutToExecuteScript) || !m_frame.windowProxy().existingJSWindowProxy(world))
3963         return;
3964 
3965     m_client.dispatchDidClearWindowObjectInWorld(world);
3966 
3967     if (Page* page = m_frame.page())
3968         page-&gt;inspectorController().didClearWindowObjectInWorld(m_frame, world);
3969 
3970     InspectorInstrumentation::didClearWindowObjectInWorld(m_frame, world);
3971 }
3972 
3973 void FrameLoader::dispatchGlobalObjectAvailableInAllWorlds()
3974 {
3975     Vector&lt;Ref&lt;DOMWrapperWorld&gt;&gt; worlds;
3976     ScriptController::getAllWorlds(worlds);
3977     for (auto&amp; world : worlds)
3978         m_client.dispatchGlobalObjectAvailable(world);
3979 }
3980 
3981 SandboxFlags FrameLoader::effectiveSandboxFlags() const
3982 {
3983     SandboxFlags flags = m_forcedSandboxFlags;
3984     if (Frame* parentFrame = m_frame.tree().parent())
3985         flags |= parentFrame-&gt;document()-&gt;sandboxFlags();
3986     if (HTMLFrameOwnerElement* ownerElement = m_frame.ownerElement())
3987         flags |= ownerElement-&gt;sandboxFlags();
3988     return flags;
3989 }
3990 
3991 void FrameLoader::didChangeTitle(DocumentLoader* loader)
3992 {
3993     m_client.didChangeTitle(loader);
3994 
3995     if (loader == m_documentLoader) {
3996         // Must update the entries in the back-forward list too.
3997         history().setCurrentItemTitle(loader-&gt;title());
3998         // This must go through the WebFrame because it has the right notion of the current b/f item.
3999         m_client.setTitle(loader-&gt;title(), loader-&gt;urlForHistory());
4000         m_client.setMainFrameDocumentReady(true); // update observers with new DOMDocument
4001         m_client.dispatchDidReceiveTitle(loader-&gt;title());
4002     }
4003 
4004 #if ENABLE(REMOTE_INSPECTOR)
4005     if (m_frame.isMainFrame())
4006         m_frame.page()-&gt;remoteInspectorInformationDidChange();
4007 #endif
4008 }
4009 
4010 void FrameLoader::dispatchDidCommitLoad(Optional&lt;HasInsecureContent&gt; initialHasInsecureContent)
4011 {
4012     if (m_stateMachine.creatingInitialEmptyDocument())
4013         return;
4014 
4015     m_client.dispatchDidCommitLoad(initialHasInsecureContent);
4016 
4017     if (m_frame.isMainFrame()) {
4018         m_frame.page()-&gt;resetSeenPlugins();
4019         m_frame.page()-&gt;resetSeenMediaEngines();
4020     }
4021 
4022     InspectorInstrumentation::didCommitLoad(m_frame, m_documentLoader.get());
4023 
4024 #if ENABLE(REMOTE_INSPECTOR)
4025     if (m_frame.isMainFrame())
4026         m_frame.page()-&gt;remoteInspectorInformationDidChange();
4027 #endif
4028 }
4029 
4030 void FrameLoader::tellClientAboutPastMemoryCacheLoads()
4031 {
4032     ASSERT(m_frame.page());
4033     ASSERT(m_frame.page()-&gt;areMemoryCacheClientCallsEnabled());
4034 
4035     if (!m_documentLoader)
4036         return;
4037 
4038     Vector&lt;ResourceRequest&gt; pastLoads;
4039     m_documentLoader-&gt;takeMemoryCacheLoadsForClientNotification(pastLoads);
4040 
4041     for (auto&amp; pastLoad : pastLoads) {
4042         CachedResource* resource = MemoryCache::singleton().resourceForRequest(pastLoad, m_frame.page()-&gt;sessionID());
4043 
4044         // FIXME: These loads, loaded from cache, but now gone from the cache by the time
4045         // Page::setMemoryCacheClientCallsEnabled(true) is called, will not be seen by the client.
4046         // Consider if there&#39;s some efficient way of remembering enough to deliver this client call.
4047         // We have the URL, but not the rest of the response or the length.
4048         if (!resource)
4049             continue;
4050 
4051         ResourceRequest request(resource-&gt;url());
4052         m_client.dispatchDidLoadResourceFromMemoryCache(m_documentLoader.get(), request, resource-&gt;response(), resource-&gt;encodedSize());
4053     }
4054 }
4055 
4056 NetworkingContext* FrameLoader::networkingContext() const
4057 {
4058     return m_networkingContext.get();
4059 }
4060 
4061 void FrameLoader::loadProgressingStatusChanged()
4062 {
4063     if (auto* view = m_frame.mainFrame().view())
4064         view-&gt;loadProgressingStatusChanged();
4065 }
4066 
4067 void FrameLoader::forcePageTransitionIfNeeded()
4068 {
4069     m_client.forcePageTransitionIfNeeded();
4070 }
4071 
4072 void FrameLoader::clearTestingOverrides()
4073 {
4074     m_overrideCachePolicyForTesting = WTF::nullopt;
4075     m_overrideResourceLoadPriorityForTesting = WTF::nullopt;
4076     m_isStrictRawResourceValidationPolicyDisabledForTesting = false;
4077 }
4078 
4079 bool FrameLoader::isAlwaysOnLoggingAllowed() const
4080 {
4081     return frame().isAlwaysOnLoggingAllowed();
4082 }
4083 
4084 bool FrameLoaderClient::hasHTMLView() const
4085 {
4086     return true;
4087 }
4088 
4089 RefPtr&lt;Frame&gt; createWindow(Frame&amp; openerFrame, Frame&amp; lookupFrame, FrameLoadRequest&amp;&amp; request, const WindowFeatures&amp; features, bool&amp; created)
4090 {
4091     ASSERT(!features.dialog || request.frameName().isEmpty());
4092 
4093     created = false;
4094 
4095     // FIXME: Provide line number information with respect to the opener&#39;s document.
4096     if (WTF::protocolIsJavaScript(request.resourceRequest().url()) &amp;&amp; !openerFrame.document()-&gt;contentSecurityPolicy()-&gt;allowJavaScriptURLs(openerFrame.document()-&gt;url(), { }))
4097         return nullptr;
4098 
4099     if (!request.frameName().isEmpty() &amp;&amp; !equalIgnoringASCIICase(request.frameName(), &quot;_blank&quot;)) {
4100         if (RefPtr&lt;Frame&gt; frame = lookupFrame.loader().findFrameForNavigation(request.frameName(), openerFrame.document())) {
4101             if (!equalIgnoringASCIICase(request.frameName(), &quot;_self&quot;)) {
4102                 if (Page* page = frame-&gt;page())
4103                     page-&gt;chrome().focus();
4104             }
4105             return frame;
4106         }
4107     }
4108 
4109     // Sandboxed frames cannot open new auxiliary browsing contexts.
4110     if (isDocumentSandboxed(openerFrame, SandboxPopups)) {
4111         // FIXME: This message should be moved off the console once a solution to https://bugs.webkit.org/show_bug.cgi?id=103274 exists.
4112         openerFrame.document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Blocked opening &#39;&quot; + request.resourceRequest().url().stringCenterEllipsizedToLength() + &quot;&#39; in a new window because the request was made in a sandboxed frame whose &#39;allow-popups&#39; permission is not set.&quot;);
4113         return nullptr;
4114     }
4115 
4116     // FIXME: Setting the referrer should be the caller&#39;s responsibility.
4117     String referrer = SecurityPolicy::generateReferrerHeader(openerFrame.document()-&gt;referrerPolicy(), request.resourceRequest().url(), openerFrame.loader().outgoingReferrer());
4118     if (!referrer.isEmpty())
4119         request.resourceRequest().setHTTPReferrer(referrer);
4120     FrameLoader::addHTTPOriginIfNeeded(request.resourceRequest(), openerFrame.loader().outgoingOrigin());
4121     FrameLoader::addHTTPUpgradeInsecureRequestsIfNeeded(request.resourceRequest());
4122     FrameLoader::addSameSiteInfoToRequestIfNeeded(request.resourceRequest(), openerFrame.document());
4123 
4124     Page* oldPage = openerFrame.page();
4125     if (!oldPage)
4126         return nullptr;
4127 
4128     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy = shouldOpenExternalURLsPolicyToApply(openerFrame, request);
4129     NavigationAction action { request.requester(), request.resourceRequest(), request.initiatedByMainFrame(), NavigationType::Other, shouldOpenExternalURLsPolicy };
4130     Page* page = oldPage-&gt;chrome().createWindow(openerFrame, request, features, action);
4131     if (!page)
4132         return nullptr;
4133 
4134     RefPtr&lt;Frame&gt; frame = &amp;page-&gt;mainFrame();
4135 
4136     if (isDocumentSandboxed(openerFrame, SandboxPropagatesToAuxiliaryBrowsingContexts))
4137         frame-&gt;loader().forceSandboxFlags(openerFrame.document()-&gt;sandboxFlags());
4138 
4139     if (!equalIgnoringASCIICase(request.frameName(), &quot;_blank&quot;))
4140         frame-&gt;tree().setName(request.frameName());
4141 
4142     page-&gt;chrome().setToolbarsVisible(features.toolBarVisible || features.locationBarVisible);
4143 
4144     if (!frame-&gt;page())
4145         return nullptr;
4146     page-&gt;chrome().setStatusbarVisible(features.statusBarVisible);
4147 
4148     if (!frame-&gt;page())
4149         return nullptr;
4150     page-&gt;chrome().setScrollbarsVisible(features.scrollbarsVisible);
4151 
4152     if (!frame-&gt;page())
4153         return nullptr;
4154     page-&gt;chrome().setMenubarVisible(features.menuBarVisible);
4155 
4156     if (!frame-&gt;page())
4157         return nullptr;
4158     page-&gt;chrome().setResizable(features.resizable);
4159 
4160     // &#39;x&#39; and &#39;y&#39; specify the location of the window, while &#39;width&#39; and &#39;height&#39;
4161     // specify the size of the viewport. We can only resize the window, so adjust
4162     // for the difference between the window size and the viewport size.
4163 
4164     // FIXME: We should reconcile the initialization of viewport arguments between iOS and non-IOS.
4165 #if !PLATFORM(IOS_FAMILY)
4166     FloatSize viewportSize = page-&gt;chrome().pageRect().size();
4167     FloatRect windowRect = page-&gt;chrome().windowRect();
4168     if (features.x)
4169         windowRect.setX(*features.x);
4170     if (features.y)
4171         windowRect.setY(*features.y);
4172     // Zero width and height mean using default size, not minimum one.
4173     if (features.width &amp;&amp; *features.width)
4174         windowRect.setWidth(*features.width + (windowRect.width() - viewportSize.width()));
4175     if (features.height &amp;&amp; *features.height)
4176         windowRect.setHeight(*features.height + (windowRect.height() - viewportSize.height()));
4177 
4178 #if PLATFORM(GTK)
4179     FloatRect oldWindowRect = oldPage-&gt;chrome().windowRect();
4180     // Use the size of the previous window if there is no default size.
4181     if (!windowRect.width())
4182         windowRect.setWidth(oldWindowRect.width());
4183     if (!windowRect.height())
4184         windowRect.setHeight(oldWindowRect.height());
4185 #endif
4186 
4187     // Ensure non-NaN values, minimum size as well as being within valid screen area.
4188     FloatRect newWindowRect = DOMWindow::adjustWindowRect(*page, windowRect);
4189 
4190     if (!frame-&gt;page())
4191         return nullptr;
4192     page-&gt;chrome().setWindowRect(newWindowRect);
4193 #else
4194     // On iOS, width and height refer to the viewport dimensions.
4195     ViewportArguments arguments;
4196     // Zero width and height mean using default size, not minimum one.
4197     if (features.width &amp;&amp; *features.width)
4198         arguments.width = *features.width;
4199     if (features.height &amp;&amp; *features.height)
4200         arguments.height = *features.height;
4201     frame-&gt;setViewportArguments(arguments);
4202 #endif
4203 
4204     if (!frame-&gt;page())
4205         return nullptr;
4206     page-&gt;chrome().show();
4207 
4208     created = true;
4209     return frame;
4210 }
4211 
4212 bool FrameLoader::shouldSuppressTextInputFromEditing() const
4213 {
4214     return m_frame.settings().shouldSuppressTextInputFromEditingDuringProvisionalNavigation() &amp;&amp; m_state == FrameStateProvisional;
4215 }
4216 
4217 } // namespace WebCore
    </pre>
  </body>
</html>