<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/Document.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
   5  *           (C) 2006 Alexey Proskuryakov (ap@webkit.org)
   6  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   7  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   8  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
   9  * Copyright (C) 2011 Google Inc. All rights reserved.
  10  *
  11  * This library is free software; you can redistribute it and/or
  12  * modify it under the terms of the GNU Library General Public
  13  * License as published by the Free Software Foundation; either
  14  * version 2 of the License, or (at your option) any later version.
  15  *
  16  * This library is distributed in the hope that it will be useful,
  17  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  18  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  19  * Library General Public License for more details.
  20  *
  21  * You should have received a copy of the GNU Library General Public License
  22  * along with this library; see the file COPYING.LIB.  If not, write to
  23  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  24  * Boston, MA 02110-1301, USA.
  25  *
  26  */
  27 
  28 #pragma once
  29 
  30 #include &quot;CSSRegisteredCustomProperty.h&quot;
  31 #include &quot;Color.h&quot;
  32 #include &quot;ContainerNode.h&quot;
  33 #include &quot;DisabledAdaptations.h&quot;
  34 #include &quot;DocumentIdentifier.h&quot;
  35 #include &quot;DocumentTiming.h&quot;
  36 #include &quot;ElementIdentifier.h&quot;
  37 #include &quot;FocusDirection.h&quot;
  38 #include &quot;FontSelectorClient.h&quot;
  39 #include &quot;FrameDestructionObserver.h&quot;
  40 #include &quot;FrameLoaderTypes.h&quot;
  41 #include &quot;GenericTaskQueue.h&quot;
  42 #include &quot;GraphicsTypes.h&quot;
  43 #include &quot;MediaProducer.h&quot;
  44 #include &quot;MutationObserver.h&quot;
  45 #include &quot;OrientationNotifier.h&quot;
  46 #include &quot;PageIdentifier.h&quot;
  47 #include &quot;PlatformEvent.h&quot;
  48 #include &quot;ReferrerPolicy.h&quot;
  49 #include &quot;Region.h&quot;
  50 #include &quot;RegistrableDomain.h&quot;
  51 #include &quot;RenderPtr.h&quot;
  52 #include &quot;ScriptExecutionContext.h&quot;
  53 #include &quot;SecurityPolicyViolationEvent.h&quot;
  54 #include &quot;StringWithDirection.h&quot;
  55 #include &quot;StyleColor.h&quot;
  56 #include &quot;Supplementable.h&quot;
  57 #include &quot;TextResourceDecoder.h&quot;
  58 #include &quot;Timer.h&quot;
  59 #include &quot;TreeScope.h&quot;
  60 #include &quot;UserActionElementSet.h&quot;
  61 #include &quot;ViewportArguments.h&quot;
  62 #include &quot;VisibilityState.h&quot;
  63 #include &lt;pal/SessionID.h&gt;
  64 #include &lt;wtf/Deque.h&gt;
  65 #include &lt;wtf/Forward.h&gt;
  66 #include &lt;wtf/HashCountedSet.h&gt;
  67 #include &lt;wtf/HashSet.h&gt;
  68 #include &lt;wtf/Logger.h&gt;
  69 #include &lt;wtf/ObjectIdentifier.h&gt;
  70 #include &lt;wtf/UniqueRef.h&gt;
  71 #include &lt;wtf/WeakHashSet.h&gt;
  72 #include &lt;wtf/WeakPtr.h&gt;
  73 #include &lt;wtf/text/AtomStringHash.h&gt;
  74 
  75 #if PLATFORM(IOS_FAMILY)
  76 #include &quot;EventTrackingRegions.h&quot;
  77 #endif
  78 
  79 #if ENABLE(IOS_TOUCH_EVENTS)
  80 #include &lt;wtf/ThreadingPrimitives.h&gt;
  81 #endif
  82 
  83 namespace JSC {
  84 class CallFrame;
  85 class InputCursor;
  86 }
  87 
  88 namespace WebCore {
  89 
  90 class AXObjectCache;
  91 class Attr;
  92 class CDATASection;
  93 class CSSCustomPropertyValue;
  94 class CSSFontSelector;
  95 class CSSStyleDeclaration;
  96 class CSSStyleSheet;
  97 class CachedCSSStyleSheet;
  98 class CachedFrameBase;
  99 class CachedResourceLoader;
 100 class CachedScript;
 101 class CanvasRenderingContext2D;
 102 class CharacterData;
 103 class Comment;
 104 class ConstantPropertyMap;
 105 class ContentChangeObserver;
 106 class DOMImplementation;
 107 class DOMSelection;
 108 class DOMTimerHoldingTank;
 109 class DOMWindow;
 110 class DOMWrapperWorld;
 111 class Database;
 112 class DatabaseThread;
 113 class DocumentFragment;
 114 class DocumentLoader;
 115 class DocumentMarkerController;
 116 class DocumentParser;
 117 class DocumentSharedObjectPool;
 118 class DocumentTimeline;
 119 class DocumentType;
 120 class EditingBehavior;
 121 class EventLoop;
 122 class EventLoopTaskGroup;
 123 class ExtensionStyleSheets;
 124 class FloatQuad;
 125 class FloatRect;
 126 class FontFaceSet;
 127 class FormController;
 128 class Frame;
 129 class FrameView;
 130 class FullscreenManager;
 131 class GPUCanvasContext;
 132 class HTMLAllCollection;
 133 class HTMLBodyElement;
 134 class HTMLCanvasElement;
 135 class HTMLCollection;
 136 class HTMLDocument;
 137 class HTMLElement;
 138 class HTMLFrameOwnerElement;
 139 class HTMLHeadElement;
 140 class HTMLIFrameElement;
 141 class HTMLImageElement;
 142 class HTMLMapElement;
 143 class HTMLMediaElement;
 144 class HTMLVideoElement;
 145 class HTMLScriptElement;
 146 class HighlightMap;
 147 class HitTestLocation;
 148 class HitTestRequest;
 149 class HitTestResult;
 150 class IdleCallbackController;
 151 class IdleRequestCallback;
 152 class ImageBitmapRenderingContext;
 153 class IntPoint;
 154 class JSNode;
 155 class LayoutPoint;
 156 class LayoutRect;
 157 class LiveNodeList;
 158 class Locale;
 159 class Location;
 160 class MediaCanStartListener;
 161 class MediaPlaybackTarget;
 162 class MediaPlaybackTargetClient;
 163 class MediaQueryList;
 164 class MediaQueryMatcher;
 165 class MessagePortChannelProvider;
 166 class MouseEventWithHitTestResults;
 167 class NodeFilter;
 168 class NodeIterator;
 169 class Page;
 170 class PaintWorkletGlobalScope;
 171 class PlatformMouseEvent;
 172 class ProcessingInstruction;
 173 class QualifiedName;
 174 class Quirks;
 175 class Range;
 176 class RenderTreeBuilder;
 177 class RenderView;
 178 class RequestAnimationFrameCallback;
 179 class SVGDocumentExtensions;
 180 class SVGSVGElement;
 181 class SVGUseElement;
 182 class SWClientConnection;
 183 class ScriptElementData;
 184 class ScriptModuleLoader;
 185 class ScriptRunner;
 186 class ScriptableDocumentParser;
 187 class ScriptedAnimationController;
 188 class SecurityOrigin;
 189 class SegmentedString;
 190 class SelectorQuery;
 191 class SelectorQueryCache;
 192 class SerializedScriptValue;
 193 class Settings;
 194 class StringCallback;
 195 class StyleSheet;
 196 class StyleSheetContents;
 197 class StyleSheetList;
 198 class Text;
 199 class TextManipulationController;
 200 class TextResourceDecoder;
 201 class TreeWalker;
 202 class UndoManager;
 203 class VisibilityChangeClient;
 204 class VisitedLinkState;
 205 class WebAnimation;
 206 class WebGL2RenderingContext;
 207 class WebGLRenderingContext;
 208 class WindowEventLoop;
 209 class WindowProxy;
 210 class Worklet;
 211 class XPathEvaluator;
 212 class XPathExpression;
 213 class XPathNSResolver;
 214 class XPathResult;
 215 
 216 template&lt;typename&gt; class ExceptionOr;
 217 
 218 enum CollectionType;
 219 
 220 enum class RouteSharingPolicy : uint8_t;
 221 enum class ShouldOpenExternalURLsPolicy : uint8_t;
 222 
 223 using PlatformDisplayID = uint32_t;
 224 
 225 #if ENABLE(XSLT)
 226 class TransformSource;
 227 #endif
 228 
 229 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
 230 class DeviceMotionClient;
 231 class DeviceMotionController;
 232 class DeviceOrientationClient;
 233 class DeviceOrientationController;
 234 #endif
 235 
 236 #if ENABLE(DEVICE_ORIENTATION)
 237 class DeviceOrientationAndMotionAccessController;
 238 #endif
 239 
 240 #if ENABLE(TEXT_AUTOSIZING)
 241 class TextAutoSizing;
 242 #endif
 243 
 244 #if ENABLE(MEDIA_SESSION)
 245 class MediaSession;
 246 #endif
 247 
 248 #if ENABLE(ATTACHMENT_ELEMENT)
 249 class HTMLAttachmentElement;
 250 #endif
 251 
 252 #if ENABLE(INTERSECTION_OBSERVER)
 253 class IntersectionObserver;
 254 #endif
 255 
 256 #if ENABLE(RESIZE_OBSERVER)
 257 class ResizeObserver;
 258 #endif
 259 
 260 namespace Style {
 261 class Resolver;
 262 class Scope;
 263 };
 264 
 265 const uint64_t HTMLMediaElementInvalidID = 0;
 266 
 267 enum PageshowEventPersistence { PageshowEventNotPersisted, PageshowEventPersisted };
 268 
 269 enum NodeListInvalidationType {
 270     DoNotInvalidateOnAttributeChanges,
 271     InvalidateOnClassAttrChange,
 272     InvalidateOnIdNameAttrChange,
 273     InvalidateOnNameAttrChange,
 274     InvalidateOnForTypeAttrChange,
 275     InvalidateForFormControls,
 276     InvalidateOnHRefAttrChange,
 277     InvalidateOnAnyAttrChange,
 278 };
 279 const int numNodeListInvalidationTypes = InvalidateOnAnyAttrChange + 1;
 280 
 281 enum class EventHandlerRemoval { One, All };
 282 typedef HashCountedSet&lt;Node*&gt; EventTargetSet;
 283 
 284 enum DocumentClass {
 285     DefaultDocumentClass = 0,
 286     HTMLDocumentClass = 1,
 287     XHTMLDocumentClass = 1 &lt;&lt; 1,
 288     ImageDocumentClass = 1 &lt;&lt; 2,
 289     PluginDocumentClass = 1 &lt;&lt; 3,
 290     MediaDocumentClass = 1 &lt;&lt; 4,
 291     SVGDocumentClass = 1 &lt;&lt; 5,
 292     TextDocumentClass = 1 &lt;&lt; 6,
 293     XMLDocumentClass = 1 &lt;&lt; 7,
 294 };
 295 typedef unsigned char DocumentClassFlags;
 296 
 297 enum class DocumentCompatibilityMode : unsigned char {
 298     NoQuirksMode = 1,
 299     QuirksMode = 1 &lt;&lt; 1,
 300     LimitedQuirksMode = 1 &lt;&lt; 2
 301 };
 302 
 303 enum DimensionsCheck { WidthDimensionsCheck = 1 &lt;&lt; 0, HeightDimensionsCheck = 1 &lt;&lt; 1, AllDimensionsCheck = 1 &lt;&lt; 2 };
 304 
 305 enum class SelectionRestorationMode { Restore, SetDefault };
 306 
 307 enum class HttpEquivPolicy {
 308     Enabled,
 309     DisabledBySettings,
 310     DisabledByContentDispositionAttachmentSandbox
 311 };
 312 
 313 enum class CustomElementNameValidationStatus {
 314     Valid,
 315     FirstCharacterIsNotLowercaseASCIILetter,
 316     ContainsNoHyphen,
 317     ContainsUppercaseASCIILetter,
 318     ContainsDisallowedCharacter,
 319     ConflictsWithStandardElementName
 320 };
 321 
 322 using RenderingContext = Variant&lt;
 323 #if ENABLE(WEBGL)
 324     RefPtr&lt;WebGLRenderingContext&gt;,
 325 #endif
 326 #if ENABLE(WEBGL2)
 327     RefPtr&lt;WebGL2RenderingContext&gt;,
 328 #endif
 329 #if ENABLE(WEBGPU)
 330     RefPtr&lt;GPUCanvasContext&gt;,
 331 #endif
 332     RefPtr&lt;ImageBitmapRenderingContext&gt;,
 333     RefPtr&lt;CanvasRenderingContext2D&gt;
 334 &gt;;
 335 
 336 class DocumentParserYieldToken {
 337     WTF_MAKE_FAST_ALLOCATED;
 338 public:
 339     WEBCORE_EXPORT DocumentParserYieldToken(Document&amp;);
 340     WEBCORE_EXPORT ~DocumentParserYieldToken();
 341 
 342 private:
 343     WeakPtr&lt;Document&gt; m_document;
 344 };
 345 
 346 class Document
 347     : public ContainerNode
 348     , public TreeScope
 349     , public ScriptExecutionContext
 350     , public FontSelectorClient
 351     , public FrameDestructionObserver
 352     , public Supplementable&lt;Document&gt;
 353     , public Logger::Observer {
 354     WTF_MAKE_ISO_ALLOCATED(Document);
 355 public:
 356     static Ref&lt;Document&gt; create(const URL&amp;);
 357     static Ref&lt;Document&gt; createNonRenderedPlaceholder(Frame&amp;, const URL&amp;);
 358     static Ref&lt;Document&gt; create(Document&amp;);
 359 
 360     virtual ~Document();
 361 
 362     // Nodes belonging to this document increase referencingNodeCount -
 363     // these are enough to keep the document from being destroyed, but
 364     // not enough to keep it from removing its children. This allows a
 365     // node that outlives its document to still have a valid document
 366     // pointer without introducing reference cycles.
 367     void incrementReferencingNodeCount()
 368     {
 369         ASSERT(!m_deletionHasBegun);
 370         ++m_referencingNodeCount;
 371     }
 372 
 373     void decrementReferencingNodeCount()
 374     {
 375         ASSERT(!m_deletionHasBegun || !m_referencingNodeCount);
 376         --m_referencingNodeCount;
 377         if (!m_referencingNodeCount &amp;&amp; !refCount()) {
 378 #if ASSERT_ENABLED
 379             m_deletionHasBegun = true;
 380 #endif
 381             m_refCountAndParentBit = s_refCountIncrement; // Avoid double destruction through use of Ref&lt;T&gt;/RefPtr&lt;T&gt;. (This is a security mitigation in case of programmer error. It will ASSERT in debug builds.)
 382             delete this;
 383         }
 384     }
 385 
 386     unsigned referencingNodeCount() const { return m_referencingNodeCount; }
 387 
 388     void removedLastRef();
 389 
 390     DocumentIdentifier identifier() const { return m_identifier; }
 391 
 392     using DocumentsMap = HashMap&lt;DocumentIdentifier, Document*&gt;;
 393     WEBCORE_EXPORT static DocumentsMap::ValuesIteratorRange allDocuments();
 394     WEBCORE_EXPORT static DocumentsMap&amp; allDocumentsMap();
 395 
 396     WEBCORE_EXPORT ElementIdentifier identifierForElement(Element&amp;);
 397     WEBCORE_EXPORT Element* searchForElementByIdentifier(const ElementIdentifier&amp;);
 398     void identifiedElementWasRemovedFromDocument(Element&amp;);
 399 
 400     MediaQueryMatcher&amp; mediaQueryMatcher();
 401 
 402     using ContainerNode::ref;
 403     using ContainerNode::deref;
 404     using TreeScope::rootNode;
 405 
 406     bool canContainRangeEndPoint() const final { return true; }
 407 
 408     Element* elementForAccessKey(const String&amp; key);
 409     void invalidateAccessKeyCache();
 410 
 411     ExceptionOr&lt;SelectorQuery&amp;&gt; selectorQueryForString(const String&amp;);
 412     void clearSelectorQueryCache();
 413 
 414     void setViewportArguments(const ViewportArguments&amp; viewportArguments) { m_viewportArguments = viewportArguments; }
 415     WEBCORE_EXPORT ViewportArguments viewportArguments() const;
 416 
 417     OptionSet&lt;DisabledAdaptations&gt; disabledAdaptations() const { return m_disabledAdaptations; }
 418 #if ASSERT_ENABLED
 419     bool didDispatchViewportPropertiesChanged() const { return m_didDispatchViewportPropertiesChanged; }
 420 #endif
 421 
 422     void setReferrerPolicy(ReferrerPolicy);
 423     ReferrerPolicy referrerPolicy() const final { return m_referrerPolicy.valueOr(ReferrerPolicy::NoReferrerWhenDowngrade); }
 424 
 425     WEBCORE_EXPORT DocumentType* doctype() const;
 426 
 427     WEBCORE_EXPORT DOMImplementation&amp; implementation();
 428 
 429     Element* documentElement() const { return m_documentElement.get(); }
 430     static ptrdiff_t documentElementMemoryOffset() { return OBJECT_OFFSETOF(Document, m_documentElement); }
 431 
 432     WEBCORE_EXPORT Element* activeElement();
 433     WEBCORE_EXPORT bool hasFocus() const;
 434 
 435     bool hasManifest() const;
 436 
 437     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Element&gt;&gt; createElementForBindings(const AtomString&amp; tagName);
 438     WEBCORE_EXPORT Ref&lt;DocumentFragment&gt; createDocumentFragment();
 439     WEBCORE_EXPORT Ref&lt;Text&gt; createTextNode(const String&amp; data);
 440     WEBCORE_EXPORT Ref&lt;Comment&gt; createComment(const String&amp; data);
 441     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;CDATASection&gt;&gt; createCDATASection(const String&amp; data);
 442     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;ProcessingInstruction&gt;&gt; createProcessingInstruction(const String&amp; target, const String&amp; data);
 443     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Attr&gt;&gt; createAttribute(const String&amp; name);
 444     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Attr&gt;&gt; createAttributeNS(const AtomString&amp; namespaceURI, const String&amp; qualifiedName, bool shouldIgnoreNamespaceChecks = false);
 445     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Node&gt;&gt; importNode(Node&amp; nodeToImport, bool deep);
 446     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Element&gt;&gt; createElementNS(const AtomString&amp; namespaceURI, const String&amp; qualifiedName);
 447     WEBCORE_EXPORT Ref&lt;Element&gt; createElement(const QualifiedName&amp;, bool createdByParser);
 448 
 449     static CustomElementNameValidationStatus validateCustomElementName(const AtomString&amp;);
 450 
 451     WEBCORE_EXPORT RefPtr&lt;Range&gt; caretRangeFromPoint(int x, int y);
 452     RefPtr&lt;Range&gt; caretRangeFromPoint(const LayoutPoint&amp; clientPoint);
 453 
 454     WEBCORE_EXPORT Element* scrollingElementForAPI();
 455     Element* scrollingElement();
 456 
 457     enum ReadyState { Loading, Interactive,  Complete };
 458     ReadyState readyState() const { return m_readyState; }
 459 
 460     WEBCORE_EXPORT String defaultCharsetForLegacyBindings() const;
 461 
 462     String charset() const { return Document::encoding(); }
 463     WEBCORE_EXPORT String characterSetWithUTF8Fallback() const;
 464     TextEncoding textEncoding() const;
 465 
 466     AtomString encoding() const { return textEncoding().domName(); }
 467 
 468     WEBCORE_EXPORT void setCharset(const String&amp;); // Used by ObjC / GOBject bindings only.
 469 
 470     void setContent(const String&amp;);
 471 
 472     String suggestedMIMEType() const;
 473 
 474     void overrideMIMEType(const String&amp;);
 475     WEBCORE_EXPORT String contentType() const;
 476 
 477     String contentLanguage() const { return m_contentLanguage; }
 478     void setContentLanguage(const String&amp;);
 479 
 480     String xmlEncoding() const { return m_xmlEncoding; }
 481     String xmlVersion() const { return m_xmlVersion; }
 482     enum class StandaloneStatus : uint8_t { Unspecified, Standalone, NotStandalone };
 483     bool xmlStandalone() const { return m_xmlStandalone == StandaloneStatus::Standalone; }
 484     StandaloneStatus xmlStandaloneStatus() const { return m_xmlStandalone; }
 485     bool hasXMLDeclaration() const { return m_hasXMLDeclaration; }
 486 
 487     bool shouldPreventEnteringBackForwardCacheForTesting() const { return m_shouldPreventEnteringBackForwardCacheForTesting; }
 488     void preventEnteringBackForwardCacheForTesting() { m_shouldPreventEnteringBackForwardCacheForTesting = true; }
 489 
 490     void setXMLEncoding(const String&amp; encoding) { m_xmlEncoding = encoding; } // read-only property, only to be set from XMLDocumentParser
 491     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setXMLVersion(const String&amp;);
 492     WEBCORE_EXPORT void setXMLStandalone(bool);
 493     void setHasXMLDeclaration(bool hasXMLDeclaration) { m_hasXMLDeclaration = hasXMLDeclaration; }
 494 
 495     String documentURI() const { return m_documentURI; }
 496     WEBCORE_EXPORT void setDocumentURI(const String&amp;);
 497 
 498     WEBCORE_EXPORT VisibilityState visibilityState() const;
 499     void visibilityStateChanged();
 500     WEBCORE_EXPORT bool hidden() const;
 501 
 502     void setTimerThrottlingEnabled(bool);
 503     bool isTimerThrottlingEnabled() const { return m_isTimerThrottlingEnabled; }
 504 
 505     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Node&gt;&gt; adoptNode(Node&amp; source);
 506 
 507     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; images();
 508     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; embeds();
 509     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; plugins(); // an alias for embeds() required for the JS DOM bindings.
 510     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; applets();
 511     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; links();
 512     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; forms();
 513     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; anchors();
 514     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; scripts();
 515     Ref&lt;HTMLCollection&gt; all();
 516     Ref&lt;HTMLCollection&gt; allFilteredByName(const AtomString&amp;);
 517 
 518     Ref&lt;HTMLCollection&gt; windowNamedItems(const AtomString&amp;);
 519     Ref&lt;HTMLCollection&gt; documentNamedItems(const AtomString&amp;);
 520 
 521     // Other methods (not part of DOM)
 522     bool isSynthesized() const { return m_isSynthesized; }
 523     bool isHTMLDocument() const { return m_documentClasses &amp; HTMLDocumentClass; }
 524     bool isXHTMLDocument() const { return m_documentClasses &amp; XHTMLDocumentClass; }
 525     bool isXMLDocument() const { return m_documentClasses &amp; XMLDocumentClass; }
 526     bool isImageDocument() const { return m_documentClasses &amp; ImageDocumentClass; }
 527     bool isSVGDocument() const { return m_documentClasses &amp; SVGDocumentClass; }
 528     bool isPluginDocument() const { return m_documentClasses &amp; PluginDocumentClass; }
 529     bool isMediaDocument() const { return m_documentClasses &amp; MediaDocumentClass; }
 530     bool isTextDocument() const { return m_documentClasses &amp; TextDocumentClass; }
 531     bool hasSVGRootNode() const;
 532     virtual bool isFrameSet() const { return false; }
 533 
 534     static ptrdiff_t documentClassesMemoryOffset() { return OBJECT_OFFSETOF(Document, m_documentClasses); }
 535     static uint32_t isHTMLDocumentClassFlag() { return HTMLDocumentClass; }
 536 
 537     bool isSrcdocDocument() const { return m_isSrcdocDocument; }
 538 
 539     bool sawElementsInKnownNamespaces() const { return m_sawElementsInKnownNamespaces; }
 540 
 541     Style::Resolver&amp; userAgentShadowTreeStyleResolver();
 542 
 543     CSSFontSelector&amp; fontSelector() { return m_fontSelector; }
 544     const CSSFontSelector&amp; fontSelector() const { return m_fontSelector; }
 545 
 546     WEBCORE_EXPORT bool haveStylesheetsLoaded() const;
 547     bool isIgnoringPendingStylesheets() const { return m_ignorePendingStylesheets; }
 548 
 549     WEBCORE_EXPORT StyleSheetList&amp; styleSheets();
 550 
 551     Style::Scope&amp; styleScope() { return *m_styleScope; }
 552     const Style::Scope&amp; styleScope() const { return *m_styleScope; }
 553     ExtensionStyleSheets&amp; extensionStyleSheets() { return *m_extensionStyleSheets; }
 554     const ExtensionStyleSheets&amp; extensionStyleSheets() const { return *m_extensionStyleSheets; }
 555 
 556     bool gotoAnchorNeededAfterStylesheetsLoad() { return m_gotoAnchorNeededAfterStylesheetsLoad; }
 557     void setGotoAnchorNeededAfterStylesheetsLoad(bool b) { m_gotoAnchorNeededAfterStylesheetsLoad = b; }
 558 
 559     void updateElementsAffectedByMediaQueries();
 560     void evaluateMediaQueriesAndReportChanges();
 561 
 562     FormController&amp; formController();
 563     Vector&lt;String&gt; formElementsState() const;
 564     void setStateForNewFormElements(const Vector&lt;String&gt;&amp;);
 565 
 566     WEBCORE_EXPORT FrameView* view() const; // Can be null.
 567     WEBCORE_EXPORT Page* page() const; // Can be null.
 568     const Settings&amp; settings() const { return m_settings.get(); }
 569     Settings&amp; mutableSettings() { return m_settings.get(); }
 570     EditingBehavior editingBehavior() const;
 571 
 572     const Quirks&amp; quirks() const { return m_quirks; }
 573 
 574     float deviceScaleFactor() const;
 575 
 576     WEBCORE_EXPORT bool useSystemAppearance() const;
 577     WEBCORE_EXPORT bool useElevatedUserInterfaceLevel() const;
 578     WEBCORE_EXPORT bool useDarkAppearance(const RenderStyle*) const;
 579 
 580     OptionSet&lt;StyleColor::Options&gt; styleColorOptions(const RenderStyle*) const;
 581     CompositeOperator compositeOperatorForBackgroundColor(const Color&amp;, const RenderObject&amp;) const;
 582 
 583     WEBCORE_EXPORT Ref&lt;Range&gt; createRange();
 584 
 585     // The last bool parameter is for ObjC bindings.
 586     WEBCORE_EXPORT Ref&lt;NodeIterator&gt; createNodeIterator(Node&amp; root, unsigned long whatToShow = 0xFFFFFFFF, RefPtr&lt;NodeFilter&gt;&amp;&amp; = nullptr, bool = false);
 587 
 588     // The last bool parameter is for ObjC bindings.
 589     WEBCORE_EXPORT Ref&lt;TreeWalker&gt; createTreeWalker(Node&amp; root, unsigned long whatToShow = 0xFFFFFFFF, RefPtr&lt;NodeFilter&gt;&amp;&amp; = nullptr, bool = false);
 590 
 591     // Special support for editing
 592     WEBCORE_EXPORT Ref&lt;CSSStyleDeclaration&gt; createCSSStyleDeclaration();
 593     Ref&lt;Text&gt; createEditingTextNode(const String&amp;);
 594 
 595     enum class ResolveStyleType { Normal, Rebuild };
 596     void resolveStyle(ResolveStyleType = ResolveStyleType::Normal);
 597     WEBCORE_EXPORT bool updateStyleIfNeeded();
 598     bool needsStyleRecalc() const;
 599     unsigned lastStyleUpdateSizeForTesting() const { return m_lastStyleUpdateSizeForTesting; }
 600 
 601     WEBCORE_EXPORT void updateLayout();
 602 
 603     // updateLayoutIgnorePendingStylesheets() forces layout even if we are waiting for pending stylesheet loads,
 604     // so calling this may cause a flash of unstyled content (FOUC).
 605     enum class RunPostLayoutTasks { Asynchronously, Synchronously };
 606     WEBCORE_EXPORT void updateLayoutIgnorePendingStylesheets(RunPostLayoutTasks = RunPostLayoutTasks::Asynchronously);
 607 
 608     std::unique_ptr&lt;RenderStyle&gt; styleForElementIgnoringPendingStylesheets(Element&amp;, const RenderStyle* parentStyle, PseudoId = PseudoId::None);
 609 
 610     // Returns true if page box (margin boxes and page borders) is visible.
 611     WEBCORE_EXPORT bool isPageBoxVisible(int pageIndex);
 612 
 613     // Returns the preferred page size and margins in pixels, assuming 96
 614     // pixels per inch. pageSize, marginTop, marginRight, marginBottom,
 615     // marginLeft must be initialized to the default values that are used if
 616     // auto is specified.
 617     WEBCORE_EXPORT void pageSizeAndMarginsInPixels(int pageIndex, IntSize&amp; pageSize, int&amp; marginTop, int&amp; marginRight, int&amp; marginBottom, int&amp; marginLeft);
 618 
 619     CachedResourceLoader&amp; cachedResourceLoader() { return m_cachedResourceLoader; }
 620 
 621     void didBecomeCurrentDocumentInFrame();
 622     void destroyRenderTree();
 623     void prepareForDestruction();
 624 
 625     // Override ScriptExecutionContext methods to do additional work
 626     WEBCORE_EXPORT bool shouldBypassMainWorldContentSecurityPolicy() const final;
 627     void suspendActiveDOMObjects(ReasonForSuspension) final;
 628     void resumeActiveDOMObjects(ReasonForSuspension) final;
 629     void stopActiveDOMObjects() final;
 630 
 631     void suspendDeviceMotionAndOrientationUpdates();
 632     void resumeDeviceMotionAndOrientationUpdates();
 633 
 634     RenderView* renderView() const { return m_renderView.get(); }
 635 
 636     bool renderTreeBeingDestroyed() const { return m_renderTreeBeingDestroyed; }
 637     bool hasLivingRenderTree() const { return renderView() &amp;&amp; !renderTreeBeingDestroyed(); }
 638 
 639     bool updateLayoutIfDimensionsOutOfDate(Element&amp;, DimensionsCheck = AllDimensionsCheck);
 640 
 641     AXObjectCache* existingAXObjectCache() const;
 642     WEBCORE_EXPORT AXObjectCache* axObjectCache() const;
 643     void clearAXObjectCache();
 644 
 645     WEBCORE_EXPORT Optional&lt;PageIdentifier&gt; pageID() const;
 646     // to get visually ordered hebrew and arabic pages right
 647     void setVisuallyOrdered();
 648     bool visuallyOrdered() const { return m_visuallyOrdered; }
 649 
 650     WEBCORE_EXPORT DocumentLoader* loader() const;
 651 
 652     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; openForBindings(DOMWindow&amp; activeWindow, DOMWindow&amp; firstDOMWindow, const String&amp; url, const AtomString&amp; name, const String&amp; features);
 653     WEBCORE_EXPORT ExceptionOr&lt;Document&amp;&gt; openForBindings(Document* responsibleDocument, const String&amp;, const String&amp;);
 654 
 655     // FIXME: We should rename this at some point and give back the name &#39;open&#39; to the HTML specified ones.
 656     WEBCORE_EXPORT ExceptionOr&lt;void&gt; open(Document* responsibleDocument = nullptr);
 657     void implicitOpen();
 658 
 659     WEBCORE_EXPORT ExceptionOr&lt;void&gt; closeForBindings();
 660 
 661     // FIXME: We should rename this at some point and give back the name &#39;close&#39; to the HTML specified one.
 662     WEBCORE_EXPORT void close();
 663     // In some situations (see the code), we ignore document.close().
 664     // explicitClose() bypass these checks and actually tries to close the
 665     // input stream.
 666     void explicitClose();
 667     // implicitClose() actually does the work of closing the input stream.
 668     void implicitClose();
 669 
 670     void cancelParsing();
 671 
 672     ExceptionOr&lt;void&gt; write(Document* responsibleDocument, SegmentedString&amp;&amp;);
 673     WEBCORE_EXPORT ExceptionOr&lt;void&gt; write(Document* responsibleDocument, Vector&lt;String&gt;&amp;&amp;);
 674     WEBCORE_EXPORT ExceptionOr&lt;void&gt; writeln(Document* responsibleDocument, Vector&lt;String&gt;&amp;&amp;);
 675 
 676     bool wellFormed() const { return m_wellFormed; }
 677 
 678     const URL&amp; url() const final { return m_url; }
 679     void setURL(const URL&amp;);
 680     const URL&amp; urlForBindings() const { return m_url.isEmpty() ? WTF::blankURL() : m_url; }
 681 
 682     // To understand how these concepts relate to one another, please see the
 683     // comments surrounding their declaration.
 684     const URL&amp; baseURL() const { return m_baseURL; }
 685     void setBaseURLOverride(const URL&amp;);
 686     const URL&amp; baseURLOverride() const { return m_baseURLOverride; }
 687     const URL&amp; baseElementURL() const { return m_baseElementURL; }
 688     const String&amp; baseTarget() const { return m_baseTarget; }
 689     void processBaseElement();
 690 
 691     WEBCORE_EXPORT URL completeURL(const String&amp;, ForceUTF8 = ForceUTF8::No) const final;
 692     URL completeURL(const String&amp;, const URL&amp; baseURLOverride, ForceUTF8 = ForceUTF8::No) const;
 693 
 694     String userAgent(const URL&amp;) const final;
 695 
 696     void disableEval(const String&amp; errorMessage) final;
 697     void disableWebAssembly(const String&amp; errorMessage) final;
 698 
 699 #if ENABLE(INDEXED_DATABASE)
 700     IDBClient::IDBConnectionProxy* idbConnectionProxy() final;
 701 #endif
 702     SocketProvider* socketProvider() final;
 703 
 704     bool canNavigate(Frame* targetFrame, const URL&amp; destinationURL = URL());
 705 
 706     bool usesStyleBasedEditability() const;
 707     void setHasElementUsingStyleBasedEditability();
 708 
 709     virtual Ref&lt;DocumentParser&gt; createParser();
 710     DocumentParser* parser() const { return m_parser.get(); }
 711     ScriptableDocumentParser* scriptableDocumentParser() const;
 712 
 713     bool printing() const { return m_printing; }
 714     void setPrinting(bool p) { m_printing = p; }
 715 
 716     bool paginatedForScreen() const { return m_paginatedForScreen; }
 717     void setPaginatedForScreen(bool p) { m_paginatedForScreen = p; }
 718 
 719     bool paginated() const { return printing() || paginatedForScreen(); }
 720 
 721     void setCompatibilityMode(DocumentCompatibilityMode);
 722     void lockCompatibilityMode() { m_compatibilityModeLocked = true; }
 723     static ptrdiff_t compatibilityModeMemoryOffset() { return OBJECT_OFFSETOF(Document, m_compatibilityMode); }
 724 
 725     WEBCORE_EXPORT String compatMode() const;
 726 
 727     bool inQuirksMode() const { return m_compatibilityMode == DocumentCompatibilityMode::QuirksMode; }
 728     bool inLimitedQuirksMode() const { return m_compatibilityMode == DocumentCompatibilityMode::LimitedQuirksMode; }
 729     bool inNoQuirksMode() const { return m_compatibilityMode == DocumentCompatibilityMode::NoQuirksMode; }
 730 
 731     void setReadyState(ReadyState);
 732     void setParsing(bool);
 733     bool parsing() const { return m_bParsing; }
 734     Seconds minimumLayoutDelay();
 735 
 736     bool shouldScheduleLayout();
 737     bool isLayoutTimerActive();
 738     Seconds timeSinceDocumentCreation() const;
 739 
 740     void setTextColor(const Color&amp; color) { m_textColor = color; }
 741     const Color&amp; textColor() const { return m_textColor; }
 742 
 743     const Color&amp; linkColor() const { return m_linkColor; }
 744     const Color&amp; visitedLinkColor() const { return m_visitedLinkColor; }
 745     const Color&amp; activeLinkColor() const { return m_activeLinkColor; }
 746     void setLinkColor(const Color&amp; c) { m_linkColor = c; }
 747     void setVisitedLinkColor(const Color&amp; c) { m_visitedLinkColor = c; }
 748     void setActiveLinkColor(const Color&amp; c) { m_activeLinkColor = c; }
 749     void resetLinkColor();
 750     void resetVisitedLinkColor();
 751     void resetActiveLinkColor();
 752     VisitedLinkState&amp; visitedLinkState() const { return *m_visitedLinkState; }
 753 
 754     MouseEventWithHitTestResults prepareMouseEvent(const HitTestRequest&amp;, const LayoutPoint&amp;, const PlatformMouseEvent&amp;);
 755 
 756     enum class FocusRemovalEventsMode { Dispatch, DoNotDispatch };
 757     WEBCORE_EXPORT bool setFocusedElement(Element*, FocusDirection = FocusDirectionNone,
 758         FocusRemovalEventsMode = FocusRemovalEventsMode::Dispatch);
 759     Element* focusedElement() const { return m_focusedElement.get(); }
 760     UserActionElementSet&amp; userActionElements()  { return m_userActionElements; }
 761     const UserActionElementSet&amp; userActionElements() const { return m_userActionElements; }
 762 
 763     void setFocusNavigationStartingNode(Node*);
 764     Element* focusNavigationStartingNode(FocusDirection) const;
 765 
 766     void didRejectSyncXHRDuringPageDismissal();
 767     bool shouldIgnoreSyncXHRs() const;
 768 
 769     enum class NodeRemoval { Node, ChildrenOfNode };
 770     void adjustFocusedNodeOnNodeRemoval(Node&amp;, NodeRemoval = NodeRemoval::Node);
 771     void adjustFocusNavigationNodeOnNodeRemoval(Node&amp;, NodeRemoval = NodeRemoval::Node);
 772 
 773     void hoveredElementDidDetach(Element&amp;);
 774     void elementInActiveChainDidDetach(Element&amp;);
 775 
 776     enum class CaptureChange : uint8_t { Yes, No };
 777     void updateHoverActiveState(const HitTestRequest&amp;, Element*, CaptureChange = CaptureChange::No);
 778 
 779     // Updates for :target (CSS3 selector).
 780     void setCSSTarget(Element*);
 781     Element* cssTarget() const { return m_cssTarget; }
 782     static ptrdiff_t cssTargetMemoryOffset() { return OBJECT_OFFSETOF(Document, m_cssTarget); }
 783 
 784     WEBCORE_EXPORT void scheduleFullStyleRebuild();
 785     void scheduleStyleRecalc();
 786     void unscheduleStyleRecalc();
 787     bool hasPendingStyleRecalc() const;
 788     bool hasPendingFullStyleRebuild() const;
 789 
 790     void registerNodeListForInvalidation(LiveNodeList&amp;);
 791     void unregisterNodeListForInvalidation(LiveNodeList&amp;);
 792     WEBCORE_EXPORT void registerCollection(HTMLCollection&amp;);
 793     void unregisterCollection(HTMLCollection&amp;);
 794     void collectionCachedIdNameMap(const HTMLCollection&amp;);
 795     void collectionWillClearIdNameMap(const HTMLCollection&amp;);
 796     bool shouldInvalidateNodeListAndCollectionCaches() const;
 797     bool shouldInvalidateNodeListAndCollectionCachesForAttribute(const QualifiedName&amp; attrName) const;
 798 
 799     template &lt;typename InvalidationFunction&gt;
 800     void invalidateNodeListAndCollectionCaches(InvalidationFunction);
 801 
 802     void attachNodeIterator(NodeIterator&amp;);
 803     void detachNodeIterator(NodeIterator&amp;);
 804     void moveNodeIteratorsToNewDocument(Node&amp; node, Document&amp; newDocument)
 805     {
 806         if (!m_nodeIterators.isEmpty())
 807             moveNodeIteratorsToNewDocumentSlowCase(node, newDocument);
 808     }
 809 
 810     void attachRange(Range&amp;);
 811     void detachRange(Range&amp;);
 812 
 813     void updateRangesAfterChildrenChanged(ContainerNode&amp;);
 814     // nodeChildrenWillBeRemoved is used when removing all node children at once.
 815     void nodeChildrenWillBeRemoved(ContainerNode&amp;);
 816     // nodeWillBeRemoved is only safe when removing one node at a time.
 817     void nodeWillBeRemoved(Node&amp;);
<a name="1" id="anc1"></a><span class="line-added"> 818     void parentlessNodeMovedToNewDocument(Node&amp;);</span>
 819 
 820     enum class AcceptChildOperation { Replace, InsertOrAdd };
 821     bool canAcceptChild(const Node&amp; newChild, const Node* refChild, AcceptChildOperation) const;
 822 
 823     void textInserted(Node&amp;, unsigned offset, unsigned length);
 824     void textRemoved(Node&amp;, unsigned offset, unsigned length);
 825     void textNodesMerged(Text&amp; oldNode, unsigned offset);
 826     void textNodeSplit(Text&amp; oldNode);
 827 
 828     void createDOMWindow();
 829     void takeDOMWindowFrom(Document&amp;);
 830 
 831     DOMWindow* domWindow() const { return m_domWindow.get(); }
 832     // In DOM Level 2, the Document&#39;s DOMWindow is called the defaultView.
 833     WEBCORE_EXPORT WindowProxy* windowProxy() const;
 834 
 835     bool hasBrowsingContext() const { return !!frame(); }
 836 
 837     Document&amp; contextDocument() const;
 838     void setContextDocument(Document&amp; document) { m_contextDocument = makeWeakPtr(document); }
 839 
 840     // Helper functions for forwarding DOMWindow event related tasks to the DOMWindow if it exists.
 841     void setWindowAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; value, DOMWrapperWorld&amp;);
 842     void setWindowAttributeEventListener(const AtomString&amp; eventType, RefPtr&lt;EventListener&gt;&amp;&amp;, DOMWrapperWorld&amp;);
 843     EventListener* getWindowAttributeEventListener(const AtomString&amp; eventType, DOMWrapperWorld&amp;);
 844     WEBCORE_EXPORT void dispatchWindowEvent(Event&amp;, EventTarget* = nullptr);
 845     void dispatchWindowLoadEvent();
 846 
 847     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Event&gt;&gt; createEvent(const String&amp; eventType);
 848 
 849     // keep track of what types of event listeners are registered, so we don&#39;t
 850     // dispatch events unnecessarily
 851     enum ListenerType {
 852         DOMSUBTREEMODIFIED_LISTENER          = 1,
 853         DOMNODEINSERTED_LISTENER             = 1 &lt;&lt; 1,
 854         DOMNODEREMOVED_LISTENER              = 1 &lt;&lt; 2,
 855         DOMNODEREMOVEDFROMDOCUMENT_LISTENER  = 1 &lt;&lt; 3,
 856         DOMNODEINSERTEDINTODOCUMENT_LISTENER = 1 &lt;&lt; 4,
 857         DOMCHARACTERDATAMODIFIED_LISTENER    = 1 &lt;&lt; 5,
 858         OVERFLOWCHANGED_LISTENER             = 1 &lt;&lt; 6,
 859         ANIMATIONEND_LISTENER                = 1 &lt;&lt; 7,
 860         ANIMATIONSTART_LISTENER              = 1 &lt;&lt; 8,
 861         ANIMATIONITERATION_LISTENER          = 1 &lt;&lt; 9,
 862         TRANSITIONEND_LISTENER               = 1 &lt;&lt; 10,
 863         BEFORELOAD_LISTENER                  = 1 &lt;&lt; 11,
 864         SCROLL_LISTENER                      = 1 &lt;&lt; 12,
 865         FORCEWILLBEGIN_LISTENER              = 1 &lt;&lt; 13,
 866         FORCECHANGED_LISTENER                = 1 &lt;&lt; 14,
 867         FORCEDOWN_LISTENER                   = 1 &lt;&lt; 15,
 868         FORCEUP_LISTENER                     = 1 &lt;&lt; 16,
 869         RESIZE_LISTENER                      = 1 &lt;&lt; 17
 870     };
 871 
 872     bool hasListenerType(ListenerType listenerType) const { return (m_listenerTypes &amp; listenerType); }
 873     bool hasListenerTypeForEventType(PlatformEvent::Type) const;
 874     void addListenerTypeIfNeeded(const AtomString&amp; eventType);
 875 
 876     bool hasMutationObserversOfType(MutationObserver::MutationType type) const
 877     {
 878         return m_mutationObserverTypes &amp; type;
 879     }
 880     bool hasMutationObservers() const { return m_mutationObserverTypes; }
 881     void addMutationObserverTypes(MutationObserverOptions types) { m_mutationObserverTypes |= types; }
 882 
 883     CSSStyleDeclaration* getOverrideStyle(Element*, const String&amp;) { return nullptr; }
 884 
 885     // Handles an HTTP header equivalent set by a meta tag using &lt;meta http-equiv=&quot;...&quot; content=&quot;...&quot;&gt;. This is called
 886     // when a meta tag is encountered during document parsing, and also when a script dynamically changes or adds a meta
 887     // tag. This enables scripts to use meta tags to perform refreshes and set expiry dates in addition to them being
 888     // specified in an HTML file.
 889     void processHttpEquiv(const String&amp; equiv, const String&amp; content, bool isInDocumentHead);
 890 
 891 #if PLATFORM(IOS_FAMILY)
 892     void processFormatDetection(const String&amp;);
 893 
 894     // Called when &lt;meta name=&quot;apple-mobile-web-app-orientations&quot;&gt; changes.
 895     void processWebAppOrientations();
 896 
 897     WEBCORE_EXPORT ContentChangeObserver&amp; contentChangeObserver();
 898 
 899     DOMTimerHoldingTank* domTimerHoldingTankIfExists() { return m_domTimerHoldingTank.get(); }
 900     DOMTimerHoldingTank&amp; domTimerHoldingTank();
 901 #endif
 902 
 903     void processViewport(const String&amp; features, ViewportArguments::Type origin);
 904     void processDisabledAdaptations(const String&amp; adaptations);
 905     void updateViewportArguments();
 906     void processReferrerPolicy(const String&amp; policy, ReferrerPolicySource);
 907 
 908 #if ENABLE(DARK_MODE_CSS)
 909     void processColorScheme(const String&amp; colorScheme);
 910 #endif
 911 
 912     // Returns the owning element in the parent document.
 913     // Returns nullptr if this is the top level document.
 914     HTMLFrameOwnerElement* ownerElement() const;
 915 
 916     // Used by DOM bindings; no direction known.
 917     const String&amp; title() const { return m_title.string; }
 918     WEBCORE_EXPORT void setTitle(const String&amp;);
 919 
 920     WEBCORE_EXPORT const AtomString&amp; dir() const;
 921     WEBCORE_EXPORT void setDir(const AtomString&amp;);
 922 
 923     void titleElementAdded(Element&amp; titleElement);
 924     void titleElementRemoved(Element&amp; titleElement);
 925     void titleElementTextChanged(Element&amp; titleElement);
 926 
 927     WEBCORE_EXPORT ExceptionOr&lt;String&gt; cookie();
 928     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setCookie(const String&amp;);
 929 
 930     WEBCORE_EXPORT String referrer();
 931 
 932     WEBCORE_EXPORT String domain() const;
 933     ExceptionOr&lt;void&gt; setDomain(const String&amp; newDomain);
 934 
 935     void overrideLastModified(const Optional&lt;WallTime&gt;&amp;);
 936     WEBCORE_EXPORT String lastModified() const;
 937 
 938     // The cookieURL is used to query the cookie database for this document&#39;s
 939     // cookies. For example, if the cookie URL is http://example.com, we&#39;ll
 940     // use the non-Secure cookies for example.com when computing
 941     // document.cookie.
 942     //
 943     // Q: How is the cookieURL different from the document&#39;s URL?
 944     // A: The two URLs are the same almost all the time.  However, if one
 945     //    document inherits the security context of another document, it
 946     //    inherits its cookieURL but not its URL.
 947     //
 948     const URL&amp; cookieURL() const { return m_cookieURL; }
 949     void setCookieURL(const URL&amp;);
 950 
 951     // The firstPartyForCookies is used to compute whether this document
 952     // appears in a &quot;third-party&quot; context for the purpose of third-party
 953     // cookie blocking.  The document is in a third-party context if the
 954     // cookieURL and the firstPartyForCookies are from different hosts.
 955     //
 956     // Note: Some ports (including possibly Apple&#39;s) only consider the
 957     //       document in a third-party context if the cookieURL and the
 958     //       firstPartyForCookies have a different registry-controlled
 959     //       domain.
 960     //
 961     const URL&amp; firstPartyForCookies() const { return m_firstPartyForCookies; }
 962     void setFirstPartyForCookies(const URL&amp; url) { m_firstPartyForCookies = url; }
 963 
 964     bool isFullyActive() const;
 965 
 966     // The full URL corresponding to the &quot;site for cookies&quot; in the Same-Site Cookies spec.,
 967     // &lt;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00&gt;. It is either
 968     // the URL of the top-level document or the null URL depending on whether the registrable
 969     // domain of this document&#39;s URL matches the registrable domain of its parent&#39;s/opener&#39;s
 970     // URL. For the top-level document, it is set to the document&#39;s URL.
 971     const URL&amp; siteForCookies() const { return m_siteForCookies; }
 972     void setSiteForCookies(const URL&amp; url) { m_siteForCookies = url; }
 973 
 974     // The following implements the rule from HTML 4 for what valid names are.
 975     // To get this right for all the XML cases, we probably have to improve this or move it
 976     // and make it sensitive to the type of document.
 977     static bool isValidName(const String&amp;);
 978 
 979     // The following breaks a qualified name into a prefix and a local name.
 980     // It also does a validity check, and returns an error if the qualified name is invalid.
 981     static ExceptionOr&lt;std::pair&lt;AtomString, AtomString&gt;&gt; parseQualifiedName(const String&amp; qualifiedName);
 982     static ExceptionOr&lt;QualifiedName&gt; parseQualifiedName(const AtomString&amp; namespaceURI, const String&amp; qualifiedName);
 983 
 984     // Checks to make sure prefix and namespace do not conflict (per DOM Core 3)
 985     static bool hasValidNamespaceForElements(const QualifiedName&amp;);
 986     static bool hasValidNamespaceForAttributes(const QualifiedName&amp;);
 987 
 988     // This is the &quot;HTML body element&quot; as defined by CSSOM View spec, the first body child of the
 989     // document element. See http://dev.w3.org/csswg/cssom-view/#the-html-body-element.
 990     WEBCORE_EXPORT HTMLBodyElement* body() const;
 991 
 992     // This is the &quot;body element&quot; as defined by HTML5, the first body or frameset child of the
 993     // document element. See https://html.spec.whatwg.org/multipage/dom.html#the-body-element-2.
 994     WEBCORE_EXPORT HTMLElement* bodyOrFrameset() const;
 995     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setBodyOrFrameset(RefPtr&lt;HTMLElement&gt;&amp;&amp;);
 996 
 997     Location* location() const;
 998 
 999     WEBCORE_EXPORT HTMLHeadElement* head();
1000 
1001     DocumentMarkerController&amp; markers() const { return *m_markers; }
1002 
1003     WEBCORE_EXPORT bool execCommand(const String&amp; command, bool userInterface = false, const String&amp; value = String());
1004     WEBCORE_EXPORT bool queryCommandEnabled(const String&amp; command);
1005     WEBCORE_EXPORT bool queryCommandIndeterm(const String&amp; command);
1006     WEBCORE_EXPORT bool queryCommandState(const String&amp; command);
1007     WEBCORE_EXPORT bool queryCommandSupported(const String&amp; command);
1008     WEBCORE_EXPORT String queryCommandValue(const String&amp; command);
1009 
1010     UndoManager&amp; undoManager() const { return m_undoManager.get(); }
1011 
1012     // designMode support
1013     enum InheritedBool { off = false, on = true, inherit };
1014     void setDesignMode(InheritedBool value);
1015     InheritedBool getDesignMode() const;
1016     bool inDesignMode() const;
1017     WEBCORE_EXPORT String designMode() const;
1018     WEBCORE_EXPORT void setDesignMode(const String&amp;);
1019 
1020     Document* parentDocument() const;
1021     WEBCORE_EXPORT Document&amp; topDocument() const;
1022 
1023     ScriptRunner&amp; scriptRunner() { return *m_scriptRunner; }
1024     ScriptModuleLoader&amp; moduleLoader() { return *m_moduleLoader; }
1025 
1026     HTMLScriptElement* currentScript() const { return !m_currentScriptStack.isEmpty() ? m_currentScriptStack.last().get() : nullptr; }
1027     void pushCurrentScript(HTMLScriptElement*);
1028     void popCurrentScript();
1029 
1030     bool shouldDeferAsynchronousScriptsUntilParsingFinishes() const;
1031 
1032 #if ENABLE(XSLT)
1033     void scheduleToApplyXSLTransforms();
1034     void applyPendingXSLTransformsNowIfScheduled();
1035     RefPtr&lt;Document&gt; transformSourceDocument() { return m_transformSourceDocument; }
1036     void setTransformSourceDocument(Document* document) { m_transformSourceDocument = document; }
1037 
1038     void setTransformSource(std::unique_ptr&lt;TransformSource&gt;);
1039     TransformSource* transformSource() const { return m_transformSource.get(); }
1040 #endif
1041 
1042     void incDOMTreeVersion() { m_domTreeVersion = ++s_globalTreeVersion; }
1043     uint64_t domTreeVersion() const { return m_domTreeVersion; }
1044 
1045     WEBCORE_EXPORT String originIdentifierForPasteboard() const;
1046 
1047     // XPathEvaluator methods
1048     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;XPathExpression&gt;&gt; createExpression(const String&amp; expression, RefPtr&lt;XPathNSResolver&gt;&amp;&amp;);
1049     WEBCORE_EXPORT Ref&lt;XPathNSResolver&gt; createNSResolver(Node&amp; nodeResolver);
1050     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;XPathResult&gt;&gt; evaluate(const String&amp; expression, Node&amp; contextNode, RefPtr&lt;XPathNSResolver&gt;&amp;&amp;, unsigned short type, XPathResult*);
1051 
1052     bool hasNodesWithNonFinalStyle() const { return m_hasNodesWithNonFinalStyle; }
1053     void setHasNodesWithNonFinalStyle() { m_hasNodesWithNonFinalStyle = true; }
1054     bool hasNodesWithMissingStyle() const { return m_hasNodesWithMissingStyle; }
1055     void setHasNodesWithMissingStyle() { m_hasNodesWithMissingStyle = true; }
1056 
1057     // Extension for manipulating canvas drawing contexts for use in CSS
1058     Optional&lt;RenderingContext&gt; getCSSCanvasContext(const String&amp; type, const String&amp; name, int width, int height);
1059     HTMLCanvasElement* getCSSCanvasElement(const String&amp; name);
1060     String nameForCSSCanvasElement(const HTMLCanvasElement&amp;) const;
1061 
1062     bool isDNSPrefetchEnabled() const { return m_isDNSPrefetchEnabled; }
1063     void parseDNSPrefetchControlHeader(const String&amp;);
1064 
1065     WEBCORE_EXPORT void postTask(Task&amp;&amp;) final; // Executes the task on context&#39;s thread asynchronously.
1066 
1067     EventLoopTaskGroup&amp; eventLoop() final;
1068     WindowEventLoop&amp; windowEventLoop();
1069 
1070     ScriptedAnimationController* scriptedAnimationController() { return m_scriptedAnimationController.get(); }
1071     void suspendScriptedAnimationControllerCallbacks();
1072     void resumeScriptedAnimationControllerCallbacks();
1073 
1074     void updateAnimationsAndSendEvents(DOMHighResTimeStamp);
1075     void serviceRequestAnimationFrameCallbacks(DOMHighResTimeStamp);
1076 
1077     void windowScreenDidChange(PlatformDisplayID);
1078 
1079     void finishedParsing();
1080 
1081     enum BackForwardCacheState { NotInBackForwardCache, AboutToEnterBackForwardCache, InBackForwardCache };
1082 
1083     BackForwardCacheState backForwardCacheState() const { return m_backForwardCacheState; }
1084     void setBackForwardCacheState(BackForwardCacheState);
1085 
1086     void registerForDocumentSuspensionCallbacks(Element&amp;);
1087     void unregisterForDocumentSuspensionCallbacks(Element&amp;);
1088 
1089     void documentWillBecomeInactive();
1090     void suspend(ReasonForSuspension);
1091     void resume(ReasonForSuspension);
1092 
1093     void registerMediaElement(HTMLMediaElement&amp;);
1094     void unregisterMediaElement(HTMLMediaElement&amp;);
1095 
1096     bool audioPlaybackRequiresUserGesture() const;
1097     bool videoPlaybackRequiresUserGesture() const;
1098     bool mediaDataLoadsAutomatically() const;
1099 
1100 #if ENABLE(MEDIA_SESSION)
1101     MediaSession&amp; defaultMediaSession();
1102 #endif
1103 
1104     void privateBrowsingStateDidChange(PAL::SessionID);
1105 
1106     void storageBlockingStateDidChange();
1107 
1108 #if ENABLE(VIDEO_TRACK)
1109     void registerForCaptionPreferencesChangedCallbacks(HTMLMediaElement&amp;);
1110     void unregisterForCaptionPreferencesChangedCallbacks(HTMLMediaElement&amp;);
1111     void captionPreferencesChanged();
1112 #endif
1113 
1114     void registerForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp;);
1115     void unregisterForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp;);
1116 
1117 #if ENABLE(VIDEO)
1118     void stopAllMediaPlayback();
1119     void suspendAllMediaPlayback();
1120     void resumeAllMediaPlayback();
1121     void suspendAllMediaBuffering();
1122     void resumeAllMediaBuffering();
1123 #endif
1124 
1125     WEBCORE_EXPORT void setShouldCreateRenderers(bool);
1126     bool shouldCreateRenderers();
1127 
1128     void setDecoder(RefPtr&lt;TextResourceDecoder&gt;&amp;&amp;);
1129     TextResourceDecoder* decoder() const { return m_decoder.get(); }
1130 
1131     WEBCORE_EXPORT String displayStringModifiedByEncoding(const String&amp;) const;
1132 
1133     void invalidateRenderingDependentRegions();
1134 
1135     void removeAllEventListeners() final;
1136 
1137     WEBCORE_EXPORT const SVGDocumentExtensions* svgExtensions();
1138     WEBCORE_EXPORT SVGDocumentExtensions&amp; accessSVGExtensions();
1139 
1140     void addSVGUseElement(SVGUseElement&amp;);
1141     void removeSVGUseElement(SVGUseElement&amp;);
1142     HashSet&lt;SVGUseElement*&gt; const svgUseElements() const { return m_svgUseElements; }
1143 
1144     void initSecurityContext();
1145     void initContentSecurityPolicy();
1146 
1147     void updateURLForPushOrReplaceState(const URL&amp;);
1148     void statePopped(Ref&lt;SerializedScriptValue&gt;&amp;&amp;);
1149 
1150     bool processingLoadEvent() const { return m_processingLoadEvent; }
1151     bool loadEventFinished() const { return m_loadEventFinished; }
1152 
1153     bool isContextThread() const final;
1154     bool isSecureContext() const final;
1155     bool isJSExecutionForbidden() const final { return false; }
1156 
1157     void queueTaskToDispatchEvent(TaskSource, Ref&lt;Event&gt;&amp;&amp;);
1158     void queueTaskToDispatchEventOnWindow(TaskSource, Ref&lt;Event&gt;&amp;&amp;);
1159     void enqueueOverflowEvent(Ref&lt;Event&gt;&amp;&amp;);
1160     void dispatchPageshowEvent(PageshowEventPersistence);
1161     WEBCORE_EXPORT void enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp;);
1162     void enqueueHashchangeEvent(const String&amp; oldURL, const String&amp; newURL);
1163     void dispatchPopstateEvent(RefPtr&lt;SerializedScriptValue&gt;&amp;&amp; stateObject);
1164 
1165     WEBCORE_EXPORT void addMediaCanStartListener(MediaCanStartListener&amp;);
1166     WEBCORE_EXPORT void removeMediaCanStartListener(MediaCanStartListener&amp;);
1167     MediaCanStartListener* takeAnyMediaCanStartListener();
1168 
1169 #if ENABLE(FULLSCREEN_API)
1170     FullscreenManager&amp; fullscreenManager() { return m_fullscreenManager; }
1171     const FullscreenManager&amp; fullscreenManager() const { return m_fullscreenManager; }
1172 #endif
1173 
1174 #if ENABLE(POINTER_LOCK)
1175     WEBCORE_EXPORT void exitPointerLock();
1176 #endif
1177 
1178     // Used to allow element that loads data without going through a FrameLoader to delay the &#39;load&#39; event.
1179     void incrementLoadEventDelayCount() { ++m_loadEventDelayCount; }
1180     void decrementLoadEventDelayCount();
1181     bool isDelayingLoadEvent() const { return m_loadEventDelayCount; }
1182     void checkCompleted();
1183 
1184 #if ENABLE(IOS_TOUCH_EVENTS)
1185 #include &lt;WebKitAdditions/DocumentIOS.h&gt;
1186 #endif
1187 
1188 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
1189     DeviceMotionController&amp; deviceMotionController() const;
1190     DeviceOrientationController&amp; deviceOrientationController() const;
1191     WEBCORE_EXPORT void simulateDeviceOrientationChange(double alpha, double beta, double gamma);
1192 #endif
1193 
1194 #if ENABLE(DEVICE_ORIENTATION)
1195     DeviceOrientationAndMotionAccessController&amp; deviceOrientationAndMotionAccessController();
1196 #endif
1197 
1198     const DocumentTiming&amp; timing() const { return m_documentTiming; }
1199 
1200     WEBCORE_EXPORT double monotonicTimestamp() const;
1201 
1202     int requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp;);
1203     void cancelAnimationFrame(int id);
1204 
1205     int requestIdleCallback(Ref&lt;IdleRequestCallback&gt;&amp;&amp;, Seconds timeout);
1206     void cancelIdleCallback(int id);
1207     IdleCallbackController* idleCallbackController() { return m_idleCallbackController.get(); }
1208 
1209     EventTarget* errorEventTarget() final;
1210     void logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;) final;
1211 
1212     void initDNSPrefetch();
1213 
1214     void didAddWheelEventHandler(Node&amp;);
1215     void didRemoveWheelEventHandler(Node&amp;, EventHandlerRemoval = EventHandlerRemoval::One);
1216 
1217     MonotonicTime lastHandledUserGestureTimestamp() const { return m_lastHandledUserGestureTimestamp; }
1218     bool hasHadUserInteraction() const { return static_cast&lt;bool&gt;(m_lastHandledUserGestureTimestamp); }
1219     void updateLastHandledUserGestureTimestamp(MonotonicTime);
1220     bool processingUserGestureForMedia() const;
1221     void userActivatedMediaFinishedPlaying() { m_userActivatedMediaFinishedPlayingTimestamp = MonotonicTime::now(); }
1222 
1223     void setUserDidInteractWithPage(bool userDidInteractWithPage) { ASSERT(&amp;topDocument() == this); m_userDidInteractWithPage = userDidInteractWithPage; }
1224     bool userDidInteractWithPage() const { ASSERT(&amp;topDocument() == this); return m_userDidInteractWithPage; }
1225 
1226     // Used for testing. Count handlers in the main document, and one per frame which contains handlers.
1227     WEBCORE_EXPORT unsigned wheelEventHandlerCount() const;
1228     WEBCORE_EXPORT unsigned touchEventHandlerCount() const;
1229 
1230     WEBCORE_EXPORT void startTrackingStyleRecalcs();
1231     WEBCORE_EXPORT unsigned styleRecalcCount() const;
1232 
1233 #if ENABLE(TOUCH_EVENTS)
1234     bool hasTouchEventHandlers() const { return (m_touchEventTargets.get()) ? m_touchEventTargets-&gt;size() : false; }
1235     bool touchEventTargetsContain(Node&amp; node) const { return m_touchEventTargets ? m_touchEventTargets-&gt;contains(&amp;node) : false; }
1236 #else
1237     bool hasTouchEventHandlers() const { return false; }
1238     bool touchEventTargetsContain(Node&amp;) const { return false; }
1239 #endif
1240 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(POINTER_EVENTS)
1241     bool mayHaveElementsWithNonAutoTouchAction() const { return m_mayHaveElementsWithNonAutoTouchAction; }
1242     void setMayHaveElementsWithNonAutoTouchAction() { m_mayHaveElementsWithNonAutoTouchAction = true; }
1243 #endif
1244 
1245     void didAddTouchEventHandler(Node&amp;);
1246     void didRemoveTouchEventHandler(Node&amp;, EventHandlerRemoval = EventHandlerRemoval::One);
1247 
1248     void didRemoveEventTargetNode(Node&amp;);
1249 
1250     const EventTargetSet* touchEventTargets() const
1251     {
1252 #if ENABLE(TOUCH_EVENTS)
1253         return m_touchEventTargets.get();
1254 #else
1255         return nullptr;
1256 #endif
1257     }
1258 
1259     const EventTargetSet* wheelEventTargets() const { return m_wheelEventTargets.get(); }
1260 
1261     typedef std::pair&lt;Region, bool&gt; RegionFixedPair;
1262     RegionFixedPair absoluteEventRegionForNode(Node&amp;);
1263     RegionFixedPair absoluteRegionForEventTargets(const EventTargetSet*);
1264 
1265     LayoutRect absoluteEventHandlerBounds(bool&amp;) final;
1266 
1267     bool visualUpdatesAllowed() const { return m_visualUpdatesAllowed; }
1268 
1269     bool isInDocumentWrite() { return m_writeRecursionDepth &gt; 0; }
1270 
1271     void suspendScheduledTasks(ReasonForSuspension);
1272     void resumeScheduledTasks(ReasonForSuspension);
1273 
1274 #if ENABLE(CSS_DEVICE_ADAPTATION)
1275     IntSize initialViewportSize() const;
1276 #endif
1277 
1278     void convertAbsoluteToClientQuads(Vector&lt;FloatQuad&gt;&amp;, const RenderStyle&amp;);
1279     void convertAbsoluteToClientRects(Vector&lt;FloatRect&gt;&amp;, const RenderStyle&amp;);
1280     void convertAbsoluteToClientRect(FloatRect&amp;, const RenderStyle&amp;);
1281 
1282     bool hasActiveParser();
1283     void incrementActiveParserCount() { ++m_activeParserCount; }
1284     void decrementActiveParserCount();
1285 
1286     std::unique_ptr&lt;DocumentParserYieldToken&gt; createParserYieldToken()
1287     {
1288         return makeUnique&lt;DocumentParserYieldToken&gt;(*this);
1289     }
1290 
1291     bool hasActiveParserYieldToken() const { return m_parserYieldTokenCount; }
1292 
1293     DocumentSharedObjectPool* sharedObjectPool() { return m_sharedObjectPool.get(); }
1294 
1295     void invalidateMatchedPropertiesCacheAndForceStyleRecalc();
1296 
1297     void didRemoveAllPendingStylesheet();
1298     void didClearStyleResolver();
1299 
1300     bool inStyleRecalc() const { return m_inStyleRecalc; }
1301     bool inRenderTreeUpdate() const { return m_inRenderTreeUpdate; }
1302     bool isResolvingTreeStyle() const { return m_isResolvingTreeStyle; }
1303     void setIsResolvingTreeStyle(bool);
1304 
1305     void updateTextRenderer(Text&amp;, unsigned offsetOfReplacedText, unsigned lengthOfReplacedText);
1306 
1307     // Return a Locale for the default locale if the argument is null or empty.
1308     Locale&amp; getCachedLocale(const AtomString&amp; locale = nullAtom());
1309 
1310     const Document* templateDocument() const;
1311     Document&amp; ensureTemplateDocument();
1312     void setTemplateDocumentHost(Document* templateDocumentHost) { m_templateDocumentHost = makeWeakPtr(templateDocumentHost); }
1313     Document* templateDocumentHost() { return m_templateDocumentHost.get(); }
1314 
1315     void didAssociateFormControl(Element&amp;);
1316     bool hasDisabledFieldsetElement() const { return m_disabledFieldsetElementsCount; }
1317     void addDisabledFieldsetElement() { m_disabledFieldsetElementsCount++; }
1318     void removeDisabledFieldsetElement() { ASSERT(m_disabledFieldsetElementsCount); m_disabledFieldsetElementsCount--; }
1319 
1320     void getParserLocation(String&amp; url, unsigned&amp; line, unsigned&amp; column) const;
1321 
1322     WEBCORE_EXPORT void addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp;) final;
1323 
1324     // The following addConsoleMessage function is deprecated.
1325     // Callers should try to create the ConsoleMessage themselves.
1326     WEBCORE_EXPORT void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, unsigned long requestIdentifier = 0) final;
1327 
1328     // The following addMessage function is deprecated.
1329     // Callers should try to create the ConsoleMessage themselves.
1330     void addMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, JSC::JSGlobalObject* = nullptr, unsigned long requestIdentifier = 0) final;
1331 
1332     SecurityOrigin&amp; securityOrigin() const { return *SecurityContext::securityOrigin(); }
1333     SecurityOrigin&amp; topOrigin() const final { return topDocument().securityOrigin(); }
1334 
1335     void willLoadScriptElement(const URL&amp;);
1336     void willLoadFrameElement(const URL&amp;);
1337 
1338     Ref&lt;FontFaceSet&gt; fonts();
1339 
1340     void ensurePlugInsInjectedScript(DOMWrapperWorld&amp;);
1341 
1342     void setVisualUpdatesAllowedByClient(bool);
1343 
1344 #if ENABLE(WEB_CRYPTO)
1345     bool wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey) final;
1346     bool unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key) final;
1347 #endif
1348 
1349     void setHasStyleWithViewportUnits() { m_hasStyleWithViewportUnits = true; }
1350     bool hasStyleWithViewportUnits() const { return m_hasStyleWithViewportUnits; }
1351     void updateViewportUnitsOnResize();
1352 
1353     void setNeedsDOMWindowResizeEvent();
1354     void setNeedsVisualViewportResize();
1355     void runResizeSteps();
1356 
1357     void addPendingScrollEventTarget(ContainerNode&amp;);
1358     void setNeedsVisualViewportScrollEvent();
1359     void runScrollSteps();
1360 
1361     WEBCORE_EXPORT void addAudioProducer(MediaProducer&amp;);
1362     WEBCORE_EXPORT void removeAudioProducer(MediaProducer&amp;);
1363     MediaProducer::MediaStateFlags mediaState() const { return m_mediaState; }
1364     void noteUserInteractionWithMediaElement();
1365     bool isCapturing() const { return MediaProducer::isCapturing(m_mediaState); }
1366     WEBCORE_EXPORT void updateIsPlayingMedia(uint64_t = HTMLMediaElementInvalidID);
1367     void pageMutedStateDidChange();
1368 
1369 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
1370     void addPlaybackTargetPickerClient(MediaPlaybackTargetClient&amp;);
1371     void removePlaybackTargetPickerClient(MediaPlaybackTargetClient&amp;);
1372     void showPlaybackTargetPicker(MediaPlaybackTargetClient&amp;, bool, RouteSharingPolicy, const String&amp;);
1373     void playbackTargetPickerClientStateDidChange(MediaPlaybackTargetClient&amp;, MediaProducer::MediaStateFlags);
1374 
1375     void setPlaybackTarget(uint64_t, Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;);
1376     void playbackTargetAvailabilityDidChange(uint64_t, bool);
1377     void setShouldPlayToPlaybackTarget(uint64_t, bool);
1378     void playbackTargetPickerWasDismissed(uint64_t);
1379 #endif
1380 
1381     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicyToPropagate() const;
1382     bool shouldEnforceContentDispositionAttachmentSandbox() const;
1383     void applyContentDispositionAttachmentSandbox();
1384 
1385     void addDynamicMediaQueryDependentImage(HTMLImageElement&amp;);
1386     void removeDynamicMediaQueryDependentImage(HTMLImageElement&amp;);
1387 
1388     void scheduleTimedRenderingUpdate();
1389 
1390 #if ENABLE(INTERSECTION_OBSERVER)
1391     void addIntersectionObserver(IntersectionObserver&amp;);
1392     void removeIntersectionObserver(IntersectionObserver&amp;);
1393     unsigned numberOfIntersectionObservers() const { return m_intersectionObservers.size(); }
1394     void updateIntersectionObservations();
1395     void scheduleInitialIntersectionObservationUpdate();
1396 #endif
1397 
1398 #if ENABLE(RESIZE_OBSERVER)
1399     void addResizeObserver(ResizeObserver&amp;);
1400     void removeResizeObserver(ResizeObserver&amp;);
1401     bool hasResizeObservers();
1402     // Return the minDepth of the active observations.
1403     size_t gatherResizeObservations(size_t deeperThan);
1404     void deliverResizeObservations();
1405     bool hasSkippedResizeObservations() const;
1406     void setHasSkippedResizeObservations(bool);
1407     void updateResizeObservations(Page&amp;);
1408 #endif
1409 
1410 #if ENABLE(MEDIA_STREAM)
1411     void setHasCaptureMediaStreamTrack() { m_hasHadCaptureMediaStreamTrack = true; }
1412     bool hasHadCaptureMediaStreamTrack() const { return m_hasHadCaptureMediaStreamTrack; }
1413     void setDeviceIDHashSalt(const String&amp;);
1414     String deviceIDHashSalt() const { return m_idHashSalt; }
1415     void stopMediaCapture();
1416     void mediaStreamCaptureStateChanged();
1417 #endif
1418 
1419 // FIXME: Find a better place for this functionality.
1420 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
1421     // These functions provide a two-level setting:
1422     //    - A user-settable wantsTelephoneNumberParsing (at the Page / WebView level)
1423     //    - A read-only telephoneNumberParsingAllowed which is set by the
1424     //      document if it has the appropriate meta tag.
1425     //    - isTelephoneNumberParsingEnabled() == isTelephoneNumberParsingAllowed() &amp;&amp; page()-&gt;settings()-&gt;isTelephoneNumberParsingEnabled()
1426     WEBCORE_EXPORT bool isTelephoneNumberParsingAllowed() const;
1427     WEBCORE_EXPORT bool isTelephoneNumberParsingEnabled() const;
1428 #endif
1429 
1430     using ContainerNode::setAttributeEventListener;
1431     void setAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; value, DOMWrapperWorld&amp; isolatedWorld);
1432 
1433     DOMSelection* getSelection();
1434 
1435     void didInsertInDocumentShadowRoot(ShadowRoot&amp;);
1436     void didRemoveInDocumentShadowRoot(ShadowRoot&amp;);
1437     const HashSet&lt;ShadowRoot*&gt;&amp; inDocumentShadowRoots() const { return m_inDocumentShadowRoots; }
1438 
1439     void attachToCachedFrame(CachedFrameBase&amp;);
1440     void detachFromCachedFrame(CachedFrameBase&amp;);
1441 
1442     ConstantPropertyMap&amp; constantProperties() const { return *m_constantPropertyMap; }
1443 
1444     void orientationChanged(int orientation);
1445     OrientationNotifier&amp; orientationNotifier() { return m_orientationNotifier; }
1446 
1447     WEBCORE_EXPORT const AtomString&amp; bgColor() const;
1448     WEBCORE_EXPORT void setBgColor(const String&amp;);
1449     WEBCORE_EXPORT const AtomString&amp; fgColor() const;
1450     WEBCORE_EXPORT void setFgColor(const String&amp;);
1451     WEBCORE_EXPORT const AtomString&amp; alinkColor() const;
1452     WEBCORE_EXPORT void setAlinkColor(const String&amp;);
1453     WEBCORE_EXPORT const AtomString&amp; linkColorForBindings() const;
1454     WEBCORE_EXPORT void setLinkColorForBindings(const String&amp;);
1455     WEBCORE_EXPORT const AtomString&amp; vlinkColor() const;
1456     WEBCORE_EXPORT void setVlinkColor(const String&amp;);
1457 
1458     // Per https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-clear, this method does nothing.
1459     void clear() { }
1460     // Per https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-captureevents, this method does nothing.
1461     void captureEvents() { }
1462     // Per https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-releaseevents, this method does nothing.
1463     void releaseEvents() { }
1464 
1465 #if ENABLE(TEXT_AUTOSIZING)
1466     TextAutoSizing&amp; textAutoSizing();
1467 #endif
1468 
1469     // For debugging rdar://problem/49877867.
1470     void setMayBeDetachedFromFrame(bool mayBeDetachedFromFrame) { m_mayBeDetachedFromFrame = mayBeDetachedFromFrame; }
1471 
1472     Logger&amp; logger();
1473 
1474     WEBCORE_EXPORT void setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp;); // For testing.
1475 
1476     void addTimeline(DocumentTimeline&amp;);
1477     void removeTimeline(DocumentTimeline&amp;);
1478     WEBCORE_EXPORT DocumentTimeline&amp; timeline();
1479     DocumentTimeline* existingTimeline() const { return m_timeline.get(); }
1480     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; getAnimations();
1481 
1482 #if ENABLE(ATTACHMENT_ELEMENT)
1483     void registerAttachmentIdentifier(const String&amp;);
1484     void didInsertAttachmentElement(HTMLAttachmentElement&amp;);
1485     void didRemoveAttachmentElement(HTMLAttachmentElement&amp;);
1486     WEBCORE_EXPORT RefPtr&lt;HTMLAttachmentElement&gt; attachmentForIdentifier(const String&amp;) const;
1487     const HashMap&lt;String, Ref&lt;HTMLAttachmentElement&gt;&gt;&amp; attachmentElementsByIdentifier() const { return m_attachmentIdentifierToElementMap; }
1488 #endif
1489 
1490 #if ENABLE(SERVICE_WORKER)
1491     void setServiceWorkerConnection(SWClientConnection*);
1492 #endif
1493 
1494 #if ENABLE(VIDEO)
1495     void forEachMediaElement(const Function&lt;void(HTMLMediaElement&amp;)&gt;&amp;);
1496 #endif
1497 
1498 #if ENABLE(IOS_TOUCH_EVENTS)
1499     bool handlingTouchEvent() const { return m_handlingTouchEvent; }
1500 #endif
1501 
1502 #if ENABLE(RESOURCE_LOAD_STATISTICS)
1503     WEBCORE_EXPORT bool hasRequestedPageSpecificStorageAccessWithUserInteraction(const RegistrableDomain&amp;);
1504     WEBCORE_EXPORT void setHasRequestedPageSpecificStorageAccessWithUserInteraction(const RegistrableDomain&amp;);
1505     WEBCORE_EXPORT void wasLoadedWithDataTransferFromPrevalentResource();
1506     void downgradeReferrerToRegistrableDomain();
1507 #endif
1508 
1509     String signedPublicKeyAndChallengeString(unsigned keySizeIndex, const String&amp; challengeString, const URL&amp;);
1510 
1511     void registerArticleElement(Element&amp;);
1512     void unregisterArticleElement(Element&amp;);
1513     void updateMainArticleElementAfterLayout();
1514     bool hasMainArticleElement() const { return !!m_mainArticleElement; }
1515 
1516     const CSSRegisteredCustomPropertySet&amp; getCSSRegisteredCustomPropertySet() const { return m_CSSRegisteredPropertySet; }
1517     bool registerCSSProperty(CSSRegisteredCustomProperty&amp;&amp;);
1518 
1519 #if ENABLE(CSS_PAINTING_API)
1520     Worklet&amp; ensurePaintWorklet();
1521     PaintWorkletGlobalScope* paintWorkletGlobalScopeForName(const String&amp; name);
1522     void setPaintWorkletGlobalScopeForName(const String&amp; name, Ref&lt;PaintWorkletGlobalScope&gt;&amp;&amp;);
1523 #endif
1524 
1525     WEBCORE_EXPORT bool hasEvaluatedUserAgentScripts() const;
1526     WEBCORE_EXPORT bool isRunningUserScripts() const;
1527     WEBCORE_EXPORT void setAsRunningUserScripts();
1528     void setHasEvaluatedUserAgentScripts();
1529 #if ENABLE(APPLE_PAY)
1530     WEBCORE_EXPORT bool isApplePayActive() const;
1531     WEBCORE_EXPORT void setApplePayIsActive();
1532 #endif
1533 
1534     void frameWasDisconnectedFromOwner();
1535 
1536     WEBCORE_EXPORT bool hitTest(const HitTestRequest&amp;, HitTestResult&amp;);
1537     bool hitTest(const HitTestRequest&amp;, const HitTestLocation&amp;, HitTestResult&amp;);
1538 #if ASSERT_ENABLED
1539     bool inHitTesting() const { return m_inHitTesting; }
1540 #endif
1541 
1542     MessagePortChannelProvider&amp; messagePortChannelProvider();
1543 
1544 #if USE(SYSTEM_PREVIEW)
1545     WEBCORE_EXPORT void dispatchSystemPreviewActionEvent(const SystemPreviewInfo&amp;, const String&amp; message);
1546 #endif
1547 
1548 #if ENABLE(PICTURE_IN_PICTURE_API)
1549     HTMLVideoElement* pictureInPictureElement() const;
1550     void setPictureInPictureElement(HTMLVideoElement*);
1551 #endif
1552 
1553     WEBCORE_EXPORT TextManipulationController&amp; textManipulationController();
1554     TextManipulationController* textManipulationControllerIfExists() { return m_textManipulationController.get(); }
1555 
1556     HighlightMap&amp; highlightMap();
1557     void updateHighlightPositions();
1558 
1559 protected:
1560     enum ConstructionFlags { Synthesized = 1, NonRenderedPlaceholder = 1 &lt;&lt; 1 };
1561     Document(Frame*, const URL&amp;, unsigned = DefaultDocumentClass, unsigned constructionFlags = 0);
1562 
1563     void clearXMLVersion() { m_xmlVersion = String(); }
1564 
1565     virtual Ref&lt;Document&gt; cloneDocumentWithoutChildren() const;
1566 
1567 private:
1568     friend class DocumentParserYieldToken;
1569     friend class Node;
1570     friend class ThrowOnDynamicMarkupInsertionCountIncrementer;
1571     friend class IgnoreOpensDuringUnloadCountIncrementer;
1572     friend class IgnoreDestructiveWriteCountIncrementer;
1573 
1574     void updateTitleElement(Element&amp; changingTitleElement);
1575     void willDetachPage() final;
1576     void frameDestroyed() final;
1577 
1578     void commonTeardown();
1579 
1580     RenderObject* renderer() const = delete;
1581     void setRenderer(RenderObject*) = delete;
1582 
1583     void createRenderTree();
1584     void detachParser();
1585 
1586     // FontSelectorClient
1587     void fontsNeedUpdate(FontSelector&amp;) final;
1588 
1589     bool isDocument() const final { return true; }
1590 
1591     void childrenChanged(const ChildChange&amp;) final;
1592 
1593     String nodeName() const final;
1594     NodeType nodeType() const final;
1595     bool childTypeAllowed(NodeType) const final;
1596     Ref&lt;Node&gt; cloneNodeInternal(Document&amp;, CloningOperation) final;
1597     void cloneDataFromDocument(const Document&amp;);
1598 
1599     void refScriptExecutionContext() final { ref(); }
1600     void derefScriptExecutionContext() final { deref(); }
1601 
1602     Seconds minimumDOMTimerInterval() const final;
1603 
1604     Seconds domTimerAlignmentInterval(bool hasReachedMaxNestingLevel) const final;
1605 
1606     void updateTitleFromTitleElement();
1607     void updateTitle(const StringWithDirection&amp;);
1608     void updateBaseURL();
1609 
1610     void invalidateAccessKeyCacheSlowCase();
1611     void buildAccessKeyCache();
1612 
1613     void moveNodeIteratorsToNewDocumentSlowCase(Node&amp;, Document&amp;);
1614 
1615     void loadEventDelayTimerFired();
1616 
1617     void pendingTasksTimerFired();
1618     bool isCookieAverse() const;
1619 
1620     void detachFromFrame();
1621 
1622     template&lt;CollectionType&gt; Ref&lt;HTMLCollection&gt; ensureCachedCollection();
1623 
1624     void dispatchDisabledAdaptationsDidChangeForMainFrame();
1625 
1626     void setVisualUpdatesAllowed(ReadyState);
1627     void setVisualUpdatesAllowed(bool);
1628     void visualUpdatesSuppressionTimerFired();
1629 
1630     void addListenerType(ListenerType listenerType) { m_listenerTypes |= listenerType; }
1631 
1632     void didAssociateFormControlsTimerFired();
1633 
1634     void wheelEventHandlersChanged();
1635 
1636     HttpEquivPolicy httpEquivPolicy() const;
1637     AXObjectCache* existingAXObjectCacheSlow() const;
1638 
1639     // DOM Cookies caching.
1640     const String&amp; cachedDOMCookies() const { return m_cachedDOMCookies; }
1641     void setCachedDOMCookies(const String&amp;);
1642     bool isDOMCookieCacheValid() const { return m_cookieCacheExpiryTimer.isActive(); }
1643     void invalidateDOMCookieCache();
1644     void didLoadResourceSynchronously() final;
1645 
1646     bool canNavigateInternal(Frame&amp; targetFrame);
1647     bool isNavigationBlockedByThirdPartyIFrameRedirectBlocking(Frame&amp; targetFrame, const URL&amp; destinationURL);
1648 
1649 #if ENABLE(INTERSECTION_OBSERVER)
1650     void notifyIntersectionObserversTimerFired();
1651 #endif
1652 
1653 #if USE(QUICK_LOOK)
1654     bool shouldEnforceQuickLookSandbox() const;
1655     void applyQuickLookSandbox();
1656 #endif
1657 
1658     bool shouldEnforceHTTP09Sandbox() const;
1659 
1660     void platformSuspendOrStopActiveDOMObjects();
1661 
1662     bool isBodyPotentiallyScrollable(HTMLBodyElement&amp;);
1663 
1664     void didLogMessage(const WTFLogChannel&amp;, WTFLogLevel, Vector&lt;JSONLogValue&gt;&amp;&amp;) final;
1665 
1666     const Ref&lt;Settings&gt; m_settings;
1667 
1668     UniqueRef&lt;Quirks&gt; m_quirks;
1669 
1670     std::unique_ptr&lt;Style::Resolver&gt; m_userAgentShadowTreeStyleResolver;
1671 
1672     RefPtr&lt;DOMWindow&gt; m_domWindow;
1673     WeakPtr&lt;Document&gt; m_contextDocument;
1674 
1675     Ref&lt;CachedResourceLoader&gt; m_cachedResourceLoader;
1676     RefPtr&lt;DocumentParser&gt; m_parser;
1677 
1678     unsigned m_parserYieldTokenCount { 0 };
1679 
1680     // Document URLs.
1681     URL m_url; // Document.URL: The URL from which this document was retrieved.
1682     URL m_baseURL; // Node.baseURI: The URL to use when resolving relative URLs.
1683     URL m_baseURLOverride; // An alternative base URL that takes precedence over m_baseURL (but not m_baseElementURL).
1684     URL m_baseElementURL; // The URL set by the &lt;base&gt; element.
1685     URL m_cookieURL; // The URL to use for cookie access.
1686     URL m_firstPartyForCookies; // The policy URL for third-party cookie blocking.
1687     URL m_siteForCookies; // The policy URL for Same-Site cookies.
1688 
1689     // Document.documentURI:
1690     // Although URL-like, Document.documentURI can actually be set to any
1691     // string by content.  Document.documentURI affects m_baseURL unless the
1692     // document contains a &lt;base&gt; element, in which case the &lt;base&gt; element
1693     // takes precedence.
1694     //
1695     // This property is read-only from JavaScript, but writable from Objective C.
1696     String m_documentURI;
1697 
1698     String m_baseTarget;
1699 
1700     // MIME type of the document in case it was cloned or created by XHR.
1701     String m_overriddenMIMEType;
1702 
1703     std::unique_ptr&lt;DOMImplementation&gt; m_implementation;
1704 
1705     RefPtr&lt;Node&gt; m_focusNavigationStartingNode;
1706     RefPtr&lt;Element&gt; m_focusedElement;
1707     RefPtr&lt;Element&gt; m_hoveredElement;
1708     RefPtr&lt;Element&gt; m_activeElement;
1709     RefPtr&lt;Element&gt; m_documentElement;
1710     UserActionElementSet m_userActionElements;
1711 
1712     uint64_t m_domTreeVersion;
1713     static uint64_t s_globalTreeVersion;
1714 
1715     mutable String m_uniqueIdentifier;
1716 
1717     HashSet&lt;NodeIterator*&gt; m_nodeIterators;
1718     HashSet&lt;Range*&gt; m_ranges;
1719 
1720     std::unique_ptr&lt;Style::Scope&gt; m_styleScope;
1721     std::unique_ptr&lt;ExtensionStyleSheets&gt; m_extensionStyleSheets;
1722     RefPtr&lt;StyleSheetList&gt; m_styleSheetList;
1723 
1724     std::unique_ptr&lt;FormController&gt; m_formController;
1725 
1726     Color m_textColor { Color::black };
1727     Color m_linkColor;
1728     Color m_visitedLinkColor;
1729     Color m_activeLinkColor;
1730     const std::unique_ptr&lt;VisitedLinkState&gt; m_visitedLinkState;
1731 
1732     StringWithDirection m_title;
1733     StringWithDirection m_rawTitle;
1734     RefPtr&lt;Element&gt; m_titleElement;
1735 
1736     std::unique_ptr&lt;AXObjectCache&gt; m_axObjectCache;
1737     const std::unique_ptr&lt;DocumentMarkerController&gt; m_markers;
1738 
1739     Timer m_styleRecalcTimer;
1740 
1741     Element* m_cssTarget { nullptr };
1742 
1743     RefPtr&lt;SerializedScriptValue&gt; m_pendingStateObject;
1744     MonotonicTime m_documentCreationTime;
1745     bool m_overMinimumLayoutThreshold { false };
1746 
1747     std::unique_ptr&lt;ScriptRunner&gt; m_scriptRunner;
1748     std::unique_ptr&lt;ScriptModuleLoader&gt; m_moduleLoader;
1749 
1750     Vector&lt;RefPtr&lt;HTMLScriptElement&gt;&gt; m_currentScriptStack;
1751 
1752 #if ENABLE(XSLT)
1753     void applyPendingXSLTransformsTimerFired();
1754 
1755     std::unique_ptr&lt;TransformSource&gt; m_transformSource;
1756     RefPtr&lt;Document&gt; m_transformSourceDocument;
1757     Timer m_applyPendingXSLTransformsTimer;
1758     bool m_hasPendingXSLTransforms { false };
1759 #endif
1760 
1761     String m_xmlEncoding;
1762     String m_xmlVersion;
1763     StandaloneStatus m_xmlStandalone { StandaloneStatus::Unspecified };
1764     bool m_hasXMLDeclaration { false };
1765 
1766     String m_contentLanguage;
1767 
1768     RefPtr&lt;TextResourceDecoder&gt; m_decoder;
1769 
1770     HashSet&lt;LiveNodeList*&gt; m_listsInvalidatedAtDocument;
1771     HashSet&lt;HTMLCollection*&gt; m_collectionsInvalidatedAtDocument;
1772     unsigned m_nodeListAndCollectionCounts[numNodeListInvalidationTypes];
1773 
1774     RefPtr&lt;XPathEvaluator&gt; m_xpathEvaluator;
1775 
1776     std::unique_ptr&lt;SVGDocumentExtensions&gt; m_svgExtensions;
1777     HashSet&lt;SVGUseElement*&gt; m_svgUseElements;
1778 
1779 #if ENABLE(DARK_MODE_CSS)
1780     OptionSet&lt;ColorScheme&gt; m_colorScheme;
1781     bool m_allowsColorSchemeTransformations { true };
1782 #endif
1783 
1784     HashMap&lt;String, RefPtr&lt;HTMLCanvasElement&gt;&gt; m_cssCanvasElements;
1785 
1786     HashSet&lt;Element*&gt; m_documentSuspensionCallbackElements;
1787 
1788 #if ENABLE(VIDEO)
1789     HashSet&lt;HTMLMediaElement*&gt; m_mediaElements;
1790 #endif
1791 
1792 #if ENABLE(VIDEO_TRACK)
1793     HashSet&lt;HTMLMediaElement*&gt; m_captionPreferencesChangedElements;
1794 #endif
1795 
1796     Element* m_mainArticleElement { nullptr };
1797     HashSet&lt;Element*&gt; m_articleElements;
1798 
1799     HashSet&lt;VisibilityChangeClient*&gt; m_visibilityStateCallbackClients;
1800 
1801     std::unique_ptr&lt;HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt;&gt; m_accessKeyCache;
1802 
1803     std::unique_ptr&lt;ConstantPropertyMap&gt; m_constantPropertyMap;
1804 
1805     std::unique_ptr&lt;SelectorQueryCache&gt; m_selectorQueryCache;
1806 
1807     DocumentClassFlags m_documentClasses;
1808 
1809     RenderPtr&lt;RenderView&gt; m_renderView;
1810 
1811     HashSet&lt;MediaCanStartListener*&gt; m_mediaCanStartListeners;
1812 
1813 #if ENABLE(FULLSCREEN_API)
1814     UniqueRef&lt;FullscreenManager&gt; m_fullscreenManager;
1815 #endif
1816 
1817     WeakHashSet&lt;HTMLImageElement&gt; m_dynamicMediaQueryDependentImages;
1818 
1819 #if ENABLE(INTERSECTION_OBSERVER)
1820     Vector&lt;WeakPtr&lt;IntersectionObserver&gt;&gt; m_intersectionObservers;
1821     Vector&lt;WeakPtr&lt;IntersectionObserver&gt;&gt; m_intersectionObserversWithPendingNotifications;
1822     Timer m_intersectionObserversNotifyTimer;
1823     Timer m_intersectionObserversInitialUpdateTimer;
1824 #endif
1825 
1826 #if ENABLE(RESIZE_OBSERVER)
1827     Vector&lt;WeakPtr&lt;ResizeObserver&gt;&gt; m_resizeObservers;
1828 #endif
1829 
1830     Timer m_loadEventDelayTimer;
1831 
1832     ViewportArguments m_viewportArguments;
1833     OptionSet&lt;DisabledAdaptations&gt; m_disabledAdaptations;
1834 
1835     DocumentTiming m_documentTiming;
1836 
1837     RefPtr&lt;MediaQueryMatcher&gt; m_mediaQueryMatcher;
1838 
1839 #if ENABLE(TOUCH_EVENTS)
1840     std::unique_ptr&lt;EventTargetSet&gt; m_touchEventTargets;
1841 #endif
1842 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(POINTER_EVENTS)
1843     bool m_mayHaveElementsWithNonAutoTouchAction { false };
1844 #endif
1845     std::unique_ptr&lt;EventTargetSet&gt; m_wheelEventTargets;
1846 
1847     MonotonicTime m_lastHandledUserGestureTimestamp;
1848     MonotonicTime m_userActivatedMediaFinishedPlayingTimestamp;
1849 
1850     void clearScriptedAnimationController();
1851     RefPtr&lt;ScriptedAnimationController&gt; m_scriptedAnimationController;
1852 
1853     std::unique_ptr&lt;IdleCallbackController&gt; m_idleCallbackController;
1854 
1855 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
1856     std::unique_ptr&lt;DeviceMotionClient&gt; m_deviceMotionClient;
1857     std::unique_ptr&lt;DeviceMotionController&gt; m_deviceMotionController;
1858     std::unique_ptr&lt;DeviceOrientationClient&gt; m_deviceOrientationClient;
1859     std::unique_ptr&lt;DeviceOrientationController&gt; m_deviceOrientationController;
1860 #endif
1861 
1862 #if ENABLE(DEVICE_ORIENTATION)
1863     std::unique_ptr&lt;DeviceOrientationAndMotionAccessController&gt; m_deviceOrientationAndMotionAccessController;
1864 #endif
1865 
1866     GenericTaskQueue&lt;Timer&gt; m_logMessageTaskQueue;
1867 
1868     Timer m_pendingTasksTimer;
1869     Vector&lt;Task&gt; m_pendingTasks;
1870 
1871 #if ENABLE(TEXT_AUTOSIZING)
1872     std::unique_ptr&lt;TextAutoSizing&gt; m_textAutoSizing;
1873 #endif
1874 
1875     RefPtr&lt;HighlightMap&gt; m_highlightMap;
1876 
1877     Timer m_visualUpdatesSuppressionTimer;
1878 
1879     void clearSharedObjectPool();
1880     Timer m_sharedObjectPoolClearTimer;
1881 
1882     std::unique_ptr&lt;DocumentSharedObjectPool&gt; m_sharedObjectPool;
1883 
1884     typedef HashMap&lt;AtomString, std::unique_ptr&lt;Locale&gt;&gt; LocaleIdentifierToLocaleMap;
1885     LocaleIdentifierToLocaleMap m_localeCache;
1886 
1887     RefPtr&lt;Document&gt; m_templateDocument;
1888     WeakPtr&lt;Document&gt; m_templateDocumentHost; // Manually managed weakref (backpointer from m_templateDocument).
1889 
1890     Ref&lt;CSSFontSelector&gt; m_fontSelector;
1891 
1892     WeakHashSet&lt;MediaProducer&gt; m_audioProducers;
1893 
1894     HashSet&lt;ShadowRoot*&gt; m_inDocumentShadowRoots;
1895 
1896 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
1897     typedef HashMap&lt;uint64_t, WebCore::MediaPlaybackTargetClient*&gt; TargetIdToClientMap;
1898     TargetIdToClientMap m_idToClientMap;
1899     typedef HashMap&lt;WebCore::MediaPlaybackTargetClient*, uint64_t&gt; TargetClientToIdMap;
1900     TargetClientToIdMap m_clientToIDMap;
1901 #endif
1902 
1903 #if ENABLE(MEDIA_SESSION)
1904     RefPtr&lt;MediaSession&gt; m_defaultMediaSession;
1905 #endif
1906 
1907 #if ENABLE(INDEXED_DATABASE)
1908     RefPtr&lt;IDBClient::IDBConnectionProxy&gt; m_idbConnectionProxy;
1909 #endif
1910 
1911 #if ENABLE(ATTACHMENT_ELEMENT)
1912     HashMap&lt;String, Ref&lt;HTMLAttachmentElement&gt;&gt; m_attachmentIdentifierToElementMap;
1913 #endif
1914 
1915     Timer m_didAssociateFormControlsTimer;
1916     Timer m_cookieCacheExpiryTimer;
1917 
1918     RefPtr&lt;SocketProvider&gt; m_socketProvider;
1919 
1920     String m_cachedDOMCookies;
1921 
1922     Optional&lt;WallTime&gt; m_overrideLastModified;
1923 
1924     HashSet&lt;RefPtr&lt;Element&gt;&gt; m_associatedFormControls;
1925     unsigned m_disabledFieldsetElementsCount { 0 };
1926 
1927     unsigned m_listenerTypes { 0 };
1928     unsigned m_referencingNodeCount { 0 };
1929     int m_loadEventDelayCount { 0 };
1930     unsigned m_lastStyleUpdateSizeForTesting { 0 };
1931 
1932     // https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#throw-on-dynamic-markup-insertion-counter
1933     unsigned m_throwOnDynamicMarkupInsertionCount { 0 };
1934 
1935     // https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#ignore-opens-during-unload-counter
1936     unsigned m_ignoreOpensDuringUnloadCount { 0 };
1937 
1938     // https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#ignore-destructive-writes-counter
1939     unsigned m_ignoreDestructiveWriteCount { 0 };
1940 
1941     unsigned m_activeParserCount { 0 };
1942     unsigned m_styleRecalcCount { 0 };
1943 
1944     unsigned m_writeRecursionDepth { 0 };
1945 
1946     InheritedBool m_designMode { inherit };
1947     MediaProducer::MediaStateFlags m_mediaState { MediaProducer::IsNotPlaying };
1948     bool m_userHasInteractedWithMediaElement { false };
1949     BackForwardCacheState m_backForwardCacheState { NotInBackForwardCache };
1950     Optional&lt;ReferrerPolicy&gt; m_referrerPolicy;
1951     ReadyState m_readyState { Complete };
1952 
1953     MutationObserverOptions m_mutationObserverTypes { 0 };
1954 
1955     bool m_activeParserWasAborted { false };
1956     bool m_writeRecursionIsTooDeep { false };
1957     bool m_wellFormed { false };
1958     bool m_createRenderers { true };
1959 
1960     bool m_hasNodesWithNonFinalStyle { false };
1961     bool m_hasNodesWithMissingStyle { false };
1962     // But sometimes you need to ignore pending stylesheet count to
1963     // force an immediate layout when requested by JS.
1964     bool m_ignorePendingStylesheets { false };
1965 
1966     bool m_hasElementUsingStyleBasedEditability { false };
1967     bool m_focusNavigationStartingNodeIsRemoved { false };
1968 
1969     bool m_printing { false };
1970     bool m_paginatedForScreen { false };
1971 
1972     DocumentCompatibilityMode m_compatibilityMode { DocumentCompatibilityMode::NoQuirksMode };
1973     bool m_compatibilityModeLocked { false }; // This is cheaper than making setCompatibilityMode virtual.
1974 
1975     // FIXME: Merge these 2 variables into an enum. Also, FrameLoader::m_didCallImplicitClose
1976     // is almost a duplication of this data, so that should probably get merged in too.
1977     // FIXME: Document::m_processingLoadEvent and DocumentLoader::m_wasOnloadDispatched are roughly the same
1978     // and should be merged.
1979     bool m_processingLoadEvent { false };
1980     bool m_loadEventFinished { false };
1981 
1982     bool m_visuallyOrdered { false };
1983     bool m_bParsing { false }; // FIXME: rename
1984 
1985     bool m_needsFullStyleRebuild { false };
1986     bool m_inStyleRecalc { false };
1987     bool m_inRenderTreeUpdate { false };
1988     bool m_isResolvingTreeStyle { false };
1989 
1990     bool m_gotoAnchorNeededAfterStylesheetsLoad { false };
1991     bool m_isDNSPrefetchEnabled { false };
1992     bool m_haveExplicitlyDisabledDNSPrefetch { false };
1993 
1994     bool m_isSynthesized { false };
1995     bool m_isNonRenderedPlaceholder { false };
1996 
1997     bool m_sawElementsInKnownNamespaces { false };
1998     bool m_isSrcdocDocument { false };
1999 
2000     bool m_hasInjectedPlugInsScript { false };
2001     bool m_renderTreeBeingDestroyed { false };
2002     bool m_hasPreparedForDestruction { false };
2003 
2004     bool m_hasStyleWithViewportUnits { false };
2005     bool m_needsDOMWindowResizeEvent { false };
2006     bool m_needsVisualViewportResizeEvent { false };
2007     bool m_needsVisualViewportScrollEvent { false };
2008     bool m_isTimerThrottlingEnabled { false };
2009     bool m_isSuspended { false };
2010 
2011     bool m_scheduledTasksAreSuspended { false };
2012     bool m_visualUpdatesAllowed { true };
2013 
2014     bool m_areDeviceMotionAndOrientationUpdatesSuspended { false };
2015     bool m_userDidInteractWithPage { false };
2016 #if ASSERT_ENABLED
2017     bool m_inHitTesting { false };
2018 #endif
2019 
2020 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
2021     bool m_isTelephoneNumberParsingAllowed { true };
2022 #endif
2023 
2024     struct PendingScrollEventTargetList;
2025     std::unique_ptr&lt;PendingScrollEventTargetList&gt; m_pendingScrollEventTargetList;
2026 
2027 #if ENABLE(MEDIA_STREAM)
2028     HashSet&lt;HTMLMediaElement*&gt; m_mediaStreamStateChangeElements;
2029     String m_idHashSalt;
2030     bool m_hasHadCaptureMediaStreamTrack { false };
2031 #endif
2032 
2033 #if ASSERT_ENABLED
2034     bool m_didDispatchViewportPropertiesChanged { false };
2035 #endif
2036 
2037     OrientationNotifier m_orientationNotifier;
2038     mutable RefPtr&lt;Logger&gt; m_logger;
2039     RefPtr&lt;StringCallback&gt; m_consoleMessageListener;
2040 
2041     static bool hasEverCreatedAnAXObjectCache;
2042 
2043     RefPtr&lt;DocumentTimeline&gt; m_timeline;
2044     WeakHashSet&lt;DocumentTimeline&gt; m_timelines;
2045 
2046     DocumentIdentifier m_identifier;
2047 
2048     RefPtr&lt;WindowEventLoop&gt; m_eventLoop;
2049     std::unique_ptr&lt;EventLoopTaskGroup&gt; m_documentTaskGroup;
2050 
2051 #if ENABLE(SERVICE_WORKER)
2052     RefPtr&lt;SWClientConnection&gt; m_serviceWorkerConnection;
2053 #endif
2054 
2055 #if ENABLE(RESOURCE_LOAD_STATISTICS)
2056     RegistrableDomain m_registrableDomainRequestedPageSpecificStorageAccessWithUserInteraction { };
2057     String m_referrerOverride;
2058 #endif
2059 
2060     CSSRegisteredCustomPropertySet m_CSSRegisteredPropertySet;
2061 
2062 #if ENABLE(CSS_PAINTING_API)
2063     RefPtr&lt;Worklet&gt; m_paintWorklet;
2064     HashMap&lt;String, Ref&lt;PaintWorkletGlobalScope&gt;&gt; m_paintWorkletGlobalScopes;
2065 #endif
2066     unsigned m_numberOfRejectedSyncXHRs { 0 };
2067     bool m_hasEvaluatedUserAgentScripts { false };
2068     bool m_isRunningUserScripts { false };
2069     bool m_mayBeDetachedFromFrame { true };
2070     bool m_shouldPreventEnteringBackForwardCacheForTesting { false };
2071     bool m_hasLoadedThirdPartyScript { false };
2072     bool m_hasLoadedThirdPartyFrame { false };
2073 #if ENABLE(APPLE_PAY)
2074     bool m_hasStartedApplePaySession { false };
2075 #endif
2076 
2077     Ref&lt;UndoManager&gt; m_undoManager;
2078 #if PLATFORM(IOS_FAMILY)
2079     std::unique_ptr&lt;ContentChangeObserver&gt; m_contentChangeObserver;
2080     std::unique_ptr&lt;DOMTimerHoldingTank&gt; m_domTimerHoldingTank;
2081 #endif
2082 
2083 #if ENABLE(PICTURE_IN_PICTURE_API)
2084     WeakPtr&lt;HTMLVideoElement&gt; m_pictureInPictureElement;
2085 #endif
2086 
2087     std::unique_ptr&lt;TextManipulationController&gt; m_textManipulationController;
2088 
2089     HashMap&lt;Element*, ElementIdentifier&gt; m_identifiedElementsMap;
2090 };
2091 
2092 Element* eventTargetElementForDocument(Document*);
2093 
2094 inline TextEncoding Document::textEncoding() const
2095 {
2096     if (auto* decoder = this-&gt;decoder())
2097         return decoder-&gt;encoding();
2098     return TextEncoding();
2099 }
2100 
2101 inline const Document* Document::templateDocument() const
2102 {
2103     return m_templateDocumentHost ? this : m_templateDocument.get();
2104 }
2105 
2106 inline AXObjectCache* Document::existingAXObjectCache() const
2107 {
2108     if (!hasEverCreatedAnAXObjectCache)
2109         return nullptr;
2110     return existingAXObjectCacheSlow();
2111 }
2112 
2113 inline Ref&lt;Document&gt; Document::create(const URL&amp; url)
2114 {
2115     return adoptRef(*new Document(nullptr, url));
2116 }
2117 
2118 inline void Document::invalidateAccessKeyCache()
2119 {
2120     if (UNLIKELY(m_accessKeyCache))
2121         invalidateAccessKeyCacheSlowCase();
2122 }
2123 
2124 // These functions are here because they require the Document class definition and we want to inline them.
2125 
2126 inline ScriptExecutionContext* Node::scriptExecutionContext() const
2127 {
2128     return &amp;document().contextDocument();
2129 }
2130 
2131 } // namespace WebCore
2132 
2133 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::Document)
2134     static bool isType(const WebCore::ScriptExecutionContext&amp; context) { return context.isDocument(); }
2135     static bool isType(const WebCore::Node&amp; node) { return node.isDocumentNode(); }
2136 SPECIALIZE_TYPE_TRAITS_END()
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>