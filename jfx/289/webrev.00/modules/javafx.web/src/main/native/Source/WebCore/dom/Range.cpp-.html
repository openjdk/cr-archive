<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/dom/Range.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * (C) 1999 Lars Knoll (knoll@kde.org)
   3  * (C) 2000 Gunnstein Lye (gunnstein@netcom.no)
   4  * (C) 2000 Frederik Holljen (frederik.holljen@hig.no)
   5  * (C) 2001 Peter Kelly (pmk@post.com)
   6  * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Apple Inc. All rights reserved.
   7  * Copyright (C) 2011 Motorola Mobility. All rights reserved.
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Library General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public License
  20  * along with this library; see the file COPYING.LIB.  If not, write to
  21  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;Range.h&quot;
  27 
  28 #include &quot;Comment.h&quot;
  29 #include &quot;DOMRect.h&quot;
  30 #include &quot;DOMRectList.h&quot;
  31 #include &quot;DocumentFragment.h&quot;
  32 #include &quot;Editing.h&quot;
  33 #include &quot;Event.h&quot;
  34 #include &quot;Frame.h&quot;
  35 #include &quot;FrameView.h&quot;
  36 #include &quot;HTMLBodyElement.h&quot;
  37 #include &quot;HTMLElement.h&quot;
  38 #include &quot;HTMLHtmlElement.h&quot;
  39 #include &quot;HTMLNames.h&quot;
  40 #include &quot;NodeTraversal.h&quot;
  41 #include &quot;NodeWithIndex.h&quot;
  42 #include &quot;ProcessingInstruction.h&quot;
  43 #include &quot;RenderBlock.h&quot;
  44 #include &quot;RenderBoxModelObject.h&quot;
  45 #include &quot;RenderText.h&quot;
  46 #include &quot;RenderView.h&quot;
  47 #include &quot;ScopedEventQueue.h&quot;
  48 #include &quot;TextIterator.h&quot;
  49 #include &quot;VisiblePosition.h&quot;
  50 #include &quot;VisibleUnits.h&quot;
  51 #include &quot;markup.h&quot;
  52 #include &lt;stdio.h&gt;
  53 #include &lt;wtf/RefCountedLeakCounter.h&gt;
  54 #include &lt;wtf/text/CString.h&gt;
  55 #include &lt;wtf/text/StringBuilder.h&gt;
  56 
  57 #if PLATFORM(IOS_FAMILY)
  58 #include &quot;SelectionRect.h&quot;
  59 #endif
  60 
  61 namespace WebCore {
  62 
  63 using namespace HTMLNames;
  64 
  65 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, rangeCounter, (&quot;Range&quot;));
  66 
  67 enum ContentsProcessDirection { ProcessContentsForward, ProcessContentsBackward };
  68 enum class CoordinateSpace { Absolute, Client };
  69 
  70 static ExceptionOr&lt;void&gt; processNodes(Range::ActionType, Vector&lt;Ref&lt;Node&gt;&gt;&amp;, Node* oldContainer, RefPtr&lt;Node&gt; newContainer);
  71 static ExceptionOr&lt;RefPtr&lt;Node&gt;&gt; processContentsBetweenOffsets(Range::ActionType, RefPtr&lt;DocumentFragment&gt;, RefPtr&lt;Node&gt; container, unsigned startOffset, unsigned endOffset);
  72 static ExceptionOr&lt;RefPtr&lt;Node&gt;&gt; processAncestorsAndTheirSiblings(Range::ActionType, Node* container, ContentsProcessDirection, ExceptionOr&lt;RefPtr&lt;Node&gt;&gt;&amp;&amp; passedClonedContainer, Node* commonRoot);
  73 
  74 inline Range::Range(Document&amp; ownerDocument)
  75     : m_ownerDocument(ownerDocument)
  76     , m_start(&amp;ownerDocument)
  77     , m_end(&amp;ownerDocument)
  78 {
  79 #ifndef NDEBUG
  80     rangeCounter.increment();
  81 #endif
  82 
  83     m_ownerDocument-&gt;attachRange(*this);
  84 }
  85 
  86 Ref&lt;Range&gt; Range::create(Document&amp; ownerDocument)
  87 {
  88     return adoptRef(*new Range(ownerDocument));
  89 }
  90 
  91 inline Range::Range(Document&amp; ownerDocument, Node* startContainer, int startOffset, Node* endContainer, int endOffset)
  92     : m_ownerDocument(ownerDocument)
  93     , m_start(&amp;ownerDocument)
  94     , m_end(&amp;ownerDocument)
  95 {
  96 #ifndef NDEBUG
  97     rangeCounter.increment();
  98 #endif
  99 
 100     m_ownerDocument-&gt;attachRange(*this);
 101 
 102     // Simply setting the containers and offsets directly would not do any of the checking
 103     // that setStart and setEnd do, so we call those functions.
 104     if (startContainer)
 105         setStart(*startContainer, startOffset);
 106     if (endContainer)
 107         setEnd(*endContainer, endOffset);
 108 }
 109 
 110 Ref&lt;Range&gt; Range::create(Document&amp; ownerDocument, RefPtr&lt;Node&gt;&amp;&amp; startContainer, int startOffset, RefPtr&lt;Node&gt;&amp;&amp; endContainer, int endOffset)
 111 {
 112     return adoptRef(*new Range(ownerDocument, startContainer.get(), startOffset, endContainer.get(), endOffset));
 113 }
 114 
 115 Ref&lt;Range&gt; Range::create(Document&amp; ownerDocument, const Position&amp; start, const Position&amp; end)
 116 {
 117     return adoptRef(*new Range(ownerDocument, start.containerNode(), start.computeOffsetInContainerNode(), end.containerNode(), end.computeOffsetInContainerNode()));
 118 }
 119 
 120 Ref&lt;Range&gt; Range::create(Document&amp; ownerDocument, const VisiblePosition&amp; visibleStart, const VisiblePosition&amp; visibleEnd)
 121 {
 122     Position start = visibleStart.deepEquivalent().parentAnchoredEquivalent();
 123     Position end = visibleEnd.deepEquivalent().parentAnchoredEquivalent();
 124     return adoptRef(*new Range(ownerDocument, start.anchorNode(), start.deprecatedEditingOffset(), end.anchorNode(), end.deprecatedEditingOffset()));
 125 }
 126 
 127 Range::~Range()
 128 {
 129     m_ownerDocument-&gt;detachRange(*this);
 130 
 131 #ifndef NDEBUG
 132     rangeCounter.decrement();
 133 #endif
 134 }
 135 
 136 void Range::setDocument(Document&amp; document)
 137 {
 138     ASSERT(m_ownerDocument.ptr() != &amp;document);
 139     m_ownerDocument-&gt;detachRange(*this);
 140     m_ownerDocument = document;
 141     m_start.setToStartOfNode(document);
 142     m_end.setToStartOfNode(document);
 143     m_ownerDocument-&gt;attachRange(*this);
 144 }
 145 
 146 Node* Range::commonAncestorContainer(Node* containerA, Node* containerB)
 147 {
 148     for (Node* parentA = containerA; parentA; parentA = parentA-&gt;parentNode()) {
 149         for (Node* parentB = containerB; parentB; parentB = parentB-&gt;parentNode()) {
 150             if (parentA == parentB)
 151                 return parentA;
 152         }
 153     }
 154     return nullptr;
 155 }
 156 
 157 static inline bool checkForDifferentRootContainer(const RangeBoundaryPoint&amp; start, const RangeBoundaryPoint&amp; end)
 158 {
 159     Node* endRootContainer = end.container();
 160     while (endRootContainer-&gt;parentNode())
 161         endRootContainer = endRootContainer-&gt;parentNode();
 162     Node* startRootContainer = start.container();
 163     while (startRootContainer-&gt;parentNode())
 164         startRootContainer = startRootContainer-&gt;parentNode();
 165 
 166     return startRootContainer != endRootContainer || Range::compareBoundaryPoints(start, end).releaseReturnValue() &gt; 0;
 167 }
 168 
 169 ExceptionOr&lt;void&gt; Range::setStart(Ref&lt;Node&gt;&amp;&amp; refNode, unsigned offset)
 170 {
 171     bool didMoveDocument = false;
 172     if (&amp;refNode-&gt;document() != &amp;ownerDocument()) {
 173         setDocument(refNode-&gt;document());
 174         didMoveDocument = true;
 175     }
 176 
 177     auto childNode = checkNodeWOffset(refNode, offset);
 178     if (childNode.hasException())
 179         return childNode.releaseException();
 180 
 181     m_start.set(WTFMove(refNode), offset, childNode.releaseReturnValue());
 182 
 183     if (didMoveDocument || checkForDifferentRootContainer(m_start, m_end))
 184         collapse(true);
 185 
 186     return { };
 187 }
 188 
 189 ExceptionOr&lt;void&gt; Range::setEnd(Ref&lt;Node&gt;&amp;&amp; refNode, unsigned offset)
 190 {
 191     bool didMoveDocument = false;
 192     if (&amp;refNode-&gt;document() != &amp;ownerDocument()) {
 193         setDocument(refNode-&gt;document());
 194         didMoveDocument = true;
 195     }
 196 
 197     auto childNode = checkNodeWOffset(refNode, offset);
 198     if (childNode.hasException())
 199         return childNode.releaseException();
 200 
 201     m_end.set(WTFMove(refNode), offset, childNode.releaseReturnValue());
 202 
 203     if (didMoveDocument || checkForDifferentRootContainer(m_start, m_end))
 204         collapse(false);
 205 
 206     return { };
 207 }
 208 
 209 ExceptionOr&lt;void&gt; Range::setStart(const Position&amp; start)
 210 {
 211     Position parentAnchored = start.parentAnchoredEquivalent();
 212     if (!parentAnchored.containerNode())
 213         return Exception { TypeError };
 214     return setStart(*parentAnchored.containerNode(), parentAnchored.offsetInContainerNode());
 215 }
 216 
 217 ExceptionOr&lt;void&gt; Range::setEnd(const Position&amp; end)
 218 {
 219     Position parentAnchored = end.parentAnchoredEquivalent();
 220     if (!parentAnchored.containerNode())
 221         return Exception { TypeError };
 222     return setEnd(*parentAnchored.containerNode(), parentAnchored.offsetInContainerNode());
 223 }
 224 
 225 void Range::collapse(bool toStart)
 226 {
 227     if (toStart)
 228         m_end = m_start;
 229     else
 230         m_start = m_end;
 231 }
 232 
 233 ExceptionOr&lt;bool&gt; Range::isPointInRange(Node&amp; refNode, unsigned offset)
 234 {
 235     if (&amp;refNode.document() != &amp;ownerDocument())
 236         return false;
 237 
 238     auto checkNodeResult = checkNodeWOffset(refNode, offset);
 239     if (checkNodeResult.hasException()) {
 240         // DOM4 spec requires us to check whether refNode and start container have the same root first
 241         // but we do it in the reverse order to avoid O(n) operation here in common case.
 242         if (!commonAncestorContainer(&amp;refNode, &amp;startContainer()))
 243             return false;
 244         return checkNodeResult.releaseException();
 245     }
 246 
 247     auto startCompareResult = compareBoundaryPoints(&amp;refNode, offset, &amp;startContainer(), m_start.offset());
 248     if (!(!startCompareResult.hasException() &amp;&amp; startCompareResult.releaseReturnValue() &gt;= 0))
 249         return false;
 250     auto endCompareResult = compareBoundaryPoints(&amp;refNode, offset, &amp;endContainer(), m_end.offset());
 251     return !endCompareResult.hasException() &amp;&amp; endCompareResult.releaseReturnValue() &lt;= 0;
 252 }
 253 
 254 ExceptionOr&lt;short&gt; Range::comparePoint(Node&amp; refNode, unsigned offset) const
 255 {
 256     // http://developer.mozilla.org/en/docs/DOM:range.comparePoint
 257     // This method returns -1, 0 or 1 depending on if the point described by the
 258     // refNode node and an offset within the node is before, same as, or after the range respectively.
 259     if (&amp;refNode.document() != &amp;ownerDocument())
 260         return Exception { WrongDocumentError };
 261 
 262     auto checkNodeResult = checkNodeWOffset(refNode, offset);
 263     if (checkNodeResult.hasException()) {
 264         // DOM4 spec requires us to check whether refNode and start container have the same root first
 265         // but we do it in the reverse order to avoid O(n) operation here in common case.
 266         if (!refNode.isConnected() &amp;&amp; !commonAncestorContainer(&amp;refNode, &amp;startContainer()))
 267             return Exception { WrongDocumentError };
 268         return checkNodeResult.releaseException();
 269     }
 270 
 271     // compare to start, and point comes before
 272     auto startCompareResult = compareBoundaryPoints(&amp;refNode, offset, &amp;startContainer(), m_start.offset());
 273     if (startCompareResult.hasException())
 274         return startCompareResult.releaseException();
 275     if (startCompareResult.releaseReturnValue() &lt; 0)
 276         return -1;
 277 
 278     // compare to end, and point comes after
 279     auto endCompareResult = compareBoundaryPoints(&amp;refNode, offset, &amp;endContainer(), m_end.offset());
 280     if (endCompareResult.hasException())
 281         return endCompareResult.releaseException();
 282     if (endCompareResult.releaseReturnValue() &gt; 0)
 283         return 1;
 284 
 285     // point is in the middle of this range, or on the boundary points
 286     return 0;
 287 }
 288 
 289 ExceptionOr&lt;Range::CompareResults&gt; Range::compareNode(Node&amp; refNode) const
 290 {
 291     // http://developer.mozilla.org/en/docs/DOM:range.compareNode
 292     // This method returns 0, 1, 2, or 3 based on if the node is before, after,
 293     // before and after(surrounds), or inside the range, respectively
 294 
 295     if (!refNode.isConnected()) {
 296         // Firefox doesn&#39;t throw an exception for this case; it returns 0.
 297         return NODE_BEFORE;
 298     }
 299 
 300     if (&amp;refNode.document() != &amp;ownerDocument()) {
 301         // Firefox doesn&#39;t throw an exception for this case; it returns 0.
 302         return NODE_BEFORE;
 303     }
 304 
 305     auto* parentNode = refNode.parentNode();
 306     if (!parentNode) {
 307         // If the node is the top of the tree we should return NODE_BEFORE_AND_AFTER,
 308         // but we throw to match firefox behavior.
 309         return Exception { NotFoundError };
 310     }
 311     auto nodeIndex = refNode.computeNodeIndex();
 312 
 313     auto nodeStartCompareResult = comparePoint(*parentNode, nodeIndex);
 314     if (nodeStartCompareResult.hasException())
 315         return nodeStartCompareResult.releaseException();
 316     auto nodeEndCompareResult = comparePoint(*parentNode, nodeIndex + 1);
 317     if (nodeEndCompareResult.hasException())
 318         return nodeEndCompareResult.releaseException();
 319 
 320     bool nodeStartsBeforeRange = nodeStartCompareResult.releaseReturnValue() &lt; 0;
 321     bool nodeEndsAfterRange = nodeEndCompareResult.releaseReturnValue() &gt; 0;
 322 
 323     return nodeStartsBeforeRange
 324         ? (nodeEndsAfterRange ? NODE_BEFORE_AND_AFTER : NODE_BEFORE)
 325         : (nodeEndsAfterRange ? NODE_AFTER : NODE_INSIDE);
 326 }
 327 
 328 static inline Node* top(Node&amp; node)
 329 {
 330     auto* top = &amp;node;
 331     while (auto* parent = top-&gt;parentNode())
 332         top = parent;
 333     return top;
 334 }
 335 
 336 ExceptionOr&lt;short&gt; Range::compareBoundaryPoints(CompareHow how, const Range&amp; sourceRange) const
 337 {
 338     auto* thisContainer = commonAncestorContainer();
 339     auto* sourceContainer = sourceRange.commonAncestorContainer();
 340     if (!thisContainer || !sourceContainer || &amp;thisContainer-&gt;document() != &amp;sourceContainer-&gt;document() || top(*thisContainer) != top(*sourceContainer))
 341         return Exception { WrongDocumentError };
 342 
 343     switch (how) {
 344     case START_TO_START:
 345         return compareBoundaryPoints(m_start, sourceRange.m_start);
 346     case START_TO_END:
 347         return compareBoundaryPoints(m_end, sourceRange.m_start);
 348     case END_TO_END:
 349         return compareBoundaryPoints(m_end, sourceRange.m_end);
 350     case END_TO_START:
 351         return compareBoundaryPoints(m_start, sourceRange.m_end);
 352     }
 353 
 354     return Exception { SyntaxError };
 355 }
 356 
 357 ExceptionOr&lt;short&gt; Range::compareBoundaryPointsForBindings(unsigned short how, const Range&amp; sourceRange) const
 358 {
 359     switch (how) {
 360     case START_TO_START:
 361     case START_TO_END:
 362     case END_TO_END:
 363     case END_TO_START:
 364         return compareBoundaryPoints(static_cast&lt;CompareHow&gt;(how), sourceRange);
 365     }
 366     return Exception { NotSupportedError };
 367 }
 368 
 369 ExceptionOr&lt;short&gt; Range::compareBoundaryPoints(Node* containerA, unsigned offsetA, Node* containerB, unsigned offsetB)
 370 {
 371     ASSERT(containerA);
 372     ASSERT(containerB);
 373 
 374     if (!containerA)
 375         return -1;
 376     if (!containerB)
 377         return 1;
 378 
 379     // see DOM2 traversal &amp; range section 2.5
 380 
 381     // case 1: both points have the same container
 382     if (containerA == containerB) {
 383         if (offsetA == offsetB)
 384             return 0; // A is equal to B
 385         if (offsetA &lt; offsetB)
 386             return -1; // A is before B
 387         return 1; // A is after B
 388     }
 389 
 390     // case 2: node C (container B or an ancestor) is a child node of A
 391     Node* c = containerB;
 392     while (c &amp;&amp; c-&gt;parentNode() != containerA)
 393         c = c-&gt;parentNode();
 394     if (c) {
 395         unsigned offsetC = 0;
 396         Node* n = containerA-&gt;firstChild();
 397         while (n != c &amp;&amp; offsetC &lt; offsetA) {
 398             offsetC++;
 399             n = n-&gt;nextSibling();
 400         }
 401         if (offsetA &lt;= offsetC)
 402             return -1; // A is before B
 403         return 1; // A is after B
 404     }
 405 
 406     // case 3: node C (container A or an ancestor) is a child node of B
 407     c = containerA;
 408     while (c &amp;&amp; c-&gt;parentNode() != containerB)
 409         c = c-&gt;parentNode();
 410     if (c) {
 411         unsigned offsetC = 0;
 412         Node* n = containerB-&gt;firstChild();
 413         while (n != c &amp;&amp; offsetC &lt; offsetB) {
 414             offsetC++;
 415             n = n-&gt;nextSibling();
 416         }
 417         if (offsetC &lt; offsetB)
 418             return -1; // A is before B
 419         return 1; // A is after B
 420     }
 421 
 422     // case 4: containers A &amp; B are siblings, or children of siblings
 423     // ### we need to do a traversal here instead
 424     auto* commonAncestor = commonAncestorContainer(containerA, containerB);
 425     if (!commonAncestor)
 426         return Exception { WrongDocumentError };
 427     Node* childA = containerA;
 428     while (childA &amp;&amp; childA-&gt;parentNode() != commonAncestor)
 429         childA = childA-&gt;parentNode();
 430     if (!childA)
 431         childA = commonAncestor;
 432     Node* childB = containerB;
 433     while (childB &amp;&amp; childB-&gt;parentNode() != commonAncestor)
 434         childB = childB-&gt;parentNode();
 435     if (!childB)
 436         childB = commonAncestor;
 437 
 438     if (childA == childB)
 439         return 0; // A is equal to B
 440 
 441     Node* n = commonAncestor-&gt;firstChild();
 442     while (n) {
 443         if (n == childA)
 444             return -1; // A is before B
 445         if (n == childB)
 446             return 1; // A is after B
 447         n = n-&gt;nextSibling();
 448     }
 449 
 450     // Should never reach this point.
 451     ASSERT_NOT_REACHED();
 452     return 0;
 453 }
 454 
 455 ExceptionOr&lt;short&gt; Range::compareBoundaryPoints(const RangeBoundaryPoint&amp; boundaryA, const RangeBoundaryPoint&amp; boundaryB)
 456 {
 457     return compareBoundaryPoints(boundaryA.container(), boundaryA.offset(), boundaryB.container(), boundaryB.offset());
 458 }
 459 
 460 bool Range::boundaryPointsValid() const
 461 {
 462     auto result = compareBoundaryPoints(m_start, m_end);
 463     return !result.hasException() &amp;&amp; result.releaseReturnValue() &lt;= 0;
 464 }
 465 
 466 ExceptionOr&lt;void&gt; Range::deleteContents()
 467 {
 468     auto result = processContents(Delete);
 469     if (result.hasException())
 470         return result.releaseException();
 471     return { };
 472 }
 473 
 474 ExceptionOr&lt;bool&gt; Range::intersectsNode(Node&amp; refNode) const
 475 {
 476     if (!refNode.isConnected() || &amp;refNode.document() != &amp;ownerDocument())
 477         return false;
 478 
 479     auto* parentNode = refNode.parentNode();
 480     if (!parentNode)
 481         return true;
 482 
 483     unsigned nodeIndex = refNode.computeNodeIndex();
 484 
 485     // If (parentNode, nodeIndex) is before end and (parentNode, nodeIndex + 1) is after start, return true.
 486     // Otherwise, return false.
 487     auto compareEndResult = compareBoundaryPoints(parentNode, nodeIndex, m_end.container(), m_end.offset());
 488     if (compareEndResult.hasException())
 489         return compareEndResult.releaseException();
 490     auto compareStartResult = compareBoundaryPoints(parentNode, nodeIndex + 1, m_start.container(), m_start.offset());
 491     if (compareStartResult.hasException())
 492         return compareStartResult.releaseException();
 493     return compareEndResult.returnValue() == -1 &amp;&amp; compareStartResult.returnValue() == 1;
 494 }
 495 
 496 static inline Node* highestAncestorUnderCommonRoot(Node* node, Node* commonRoot)
 497 {
 498     if (node == commonRoot)
 499         return 0;
 500 
 501     ASSERT(commonRoot-&gt;contains(node));
 502 
 503     while (node-&gt;parentNode() != commonRoot)
 504         node = node-&gt;parentNode();
 505 
 506     return node;
 507 }
 508 
 509 static inline Node* childOfCommonRootBeforeOffset(Node* container, unsigned offset, Node* commonRoot)
 510 {
 511     ASSERT(container);
 512     ASSERT(commonRoot);
 513 
 514     if (!commonRoot-&gt;contains(container))
 515         return 0;
 516 
 517     if (container == commonRoot) {
 518         container = container-&gt;firstChild();
 519         for (unsigned i = 0; container &amp;&amp; i &lt; offset; i++)
 520             container = container-&gt;nextSibling();
 521     } else {
 522         while (container-&gt;parentNode() != commonRoot)
 523             container = container-&gt;parentNode();
 524     }
 525 
 526     return container;
 527 }
 528 
 529 static inline unsigned lengthOfContentsInNode(Node&amp; node)
 530 {
 531     // This switch statement must be consistent with that of Range::processContentsBetweenOffsets.
 532     switch (node.nodeType()) {
 533     case Node::DOCUMENT_TYPE_NODE:
 534     case Node::ATTRIBUTE_NODE:
 535         return 0;
 536     case Node::TEXT_NODE:
 537     case Node::CDATA_SECTION_NODE:
 538     case Node::COMMENT_NODE:
 539     case Node::PROCESSING_INSTRUCTION_NODE:
 540         return downcast&lt;CharacterData&gt;(node).length();
 541     case Node::ELEMENT_NODE:
 542     case Node::DOCUMENT_NODE:
 543     case Node::DOCUMENT_FRAGMENT_NODE:
 544         return downcast&lt;ContainerNode&gt;(node).countChildNodes();
 545     }
 546     ASSERT_NOT_REACHED();
 547     return 0;
 548 }
 549 
 550 ExceptionOr&lt;RefPtr&lt;DocumentFragment&gt;&gt; Range::processContents(ActionType action)
 551 {
 552     RefPtr&lt;DocumentFragment&gt; fragment;
 553     if (action == Extract || action == Clone)
 554         fragment = DocumentFragment::create(ownerDocument());
 555 
 556     if (collapsed())
 557         return fragment;
 558 
 559     RefPtr&lt;Node&gt; commonRoot = commonAncestorContainer();
 560     ASSERT(commonRoot);
 561 
 562     if (&amp;startContainer() == &amp;endContainer()) {
 563         auto result = processContentsBetweenOffsets(action, fragment, &amp;startContainer(), m_start.offset(), m_end.offset());
 564         if (result.hasException())
 565             return result.releaseException();
 566         return fragment;
 567     }
 568 
 569     // Since mutation events can modify the range during the process, the boundary points need to be saved.
 570     RangeBoundaryPoint originalStart(m_start);
 571     RangeBoundaryPoint originalEnd(m_end);
 572 
 573     // what is the highest node that partially selects the start / end of the range?
 574     RefPtr&lt;Node&gt; partialStart = highestAncestorUnderCommonRoot(originalStart.container(), commonRoot.get());
 575     RefPtr&lt;Node&gt; partialEnd = highestAncestorUnderCommonRoot(originalEnd.container(), commonRoot.get());
 576 
 577     // Start and end containers are different.
 578     // There are three possibilities here:
 579     // 1. Start container == commonRoot (End container must be a descendant)
 580     // 2. End container == commonRoot (Start container must be a descendant)
 581     // 3. Neither is commonRoot, they are both descendants
 582     //
 583     // In case 3, we grab everything after the start (up until a direct child
 584     // of commonRoot) into leftContents, and everything before the end (up until
 585     // a direct child of commonRoot) into rightContents. Then we process all
 586     // commonRoot children between leftContents and rightContents
 587     //
 588     // In case 1 or 2, we skip either processing of leftContents or rightContents,
 589     // in which case the last lot of nodes either goes from the first or last
 590     // child of commonRoot.
 591     //
 592     // These are deleted, cloned, or extracted (i.e. both) depending on action.
 593 
 594     // Note that we are verifying that our common root hierarchy is still intact
 595     // after any DOM mutation event, at various stages below. See webkit bug 60350.
 596 
 597     RefPtr&lt;Node&gt; leftContents;
 598     if (originalStart.container() != commonRoot &amp;&amp; commonRoot-&gt;contains(originalStart.container())) {
 599         auto firstResult = processContentsBetweenOffsets(action, nullptr, originalStart.container(), originalStart.offset(), lengthOfContentsInNode(*originalStart.container()));
 600         auto secondResult = processAncestorsAndTheirSiblings(action, originalStart.container(), ProcessContentsForward, WTFMove(firstResult), commonRoot.get());
 601         // FIXME: A bit peculiar that we silently ignore the exception here, but we do have at least some regression tests that rely on this behavior.
 602         if (!secondResult.hasException())
 603             leftContents = secondResult.releaseReturnValue();
 604     }
 605 
 606     RefPtr&lt;Node&gt; rightContents;
 607     if (&amp;endContainer() != commonRoot &amp;&amp; commonRoot-&gt;contains(originalEnd.container())) {
 608         auto firstResult = processContentsBetweenOffsets(action, nullptr, originalEnd.container(), 0, originalEnd.offset());
 609         auto secondResult = processAncestorsAndTheirSiblings(action, originalEnd.container(), ProcessContentsBackward, WTFMove(firstResult), commonRoot.get());
 610         // FIXME: A bit peculiar that we silently ignore the exception here, but we do have at least some regression tests that rely on this behavior.
 611         if (!secondResult.hasException())
 612             rightContents = secondResult.releaseReturnValue();
 613     }
 614 
 615     // delete all children of commonRoot between the start and end container
 616     RefPtr&lt;Node&gt; processStart = childOfCommonRootBeforeOffset(originalStart.container(), originalStart.offset(), commonRoot.get());
 617     if (processStart &amp;&amp; originalStart.container() != commonRoot) // processStart contains nodes before m_start.
 618         processStart = processStart-&gt;nextSibling();
 619     RefPtr&lt;Node&gt; processEnd = childOfCommonRootBeforeOffset(originalEnd.container(), originalEnd.offset(), commonRoot.get());
 620 
 621     // Collapse the range, making sure that the result is not within a node that was partially selected.
 622     if (action == Extract || action == Delete) {
 623         if (partialStart &amp;&amp; commonRoot-&gt;contains(partialStart.get())) {
 624             auto result = setStart(*partialStart-&gt;parentNode(), partialStart-&gt;computeNodeIndex() + 1);
 625             if (result.hasException())
 626                 return result.releaseException();
 627         } else if (partialEnd &amp;&amp; commonRoot-&gt;contains(partialEnd.get())) {
 628             auto result = setStart(*partialEnd-&gt;parentNode(), partialEnd-&gt;computeNodeIndex());
 629             if (result.hasException())
 630                 return result.releaseException();
 631         }
 632         m_end = m_start;
 633     }
 634 
 635     // Now add leftContents, stuff in between, and rightContents to the fragment
 636     // (or just delete the stuff in between)
 637 
 638     if ((action == Extract || action == Clone) &amp;&amp; leftContents) {
 639         auto result = fragment-&gt;appendChild(*leftContents);
 640         if (result.hasException())
 641             return result.releaseException();
 642     }
 643 
 644     if (processStart) {
 645         Vector&lt;Ref&lt;Node&gt;&gt; nodes;
 646         for (Node* node = processStart.get(); node &amp;&amp; node != processEnd; node = node-&gt;nextSibling())
 647             nodes.append(*node);
 648         auto result = processNodes(action, nodes, commonRoot.get(), fragment.get());
 649         if (result.hasException())
 650             return result.releaseException();
 651     }
 652 
 653     if ((action == Extract || action == Clone) &amp;&amp; rightContents) {
 654         auto result = fragment-&gt;appendChild(*rightContents);
 655         if (result.hasException())
 656             return result.releaseException();
 657     }
 658 
 659     return fragment;
 660 }
 661 
 662 static inline ExceptionOr&lt;void&gt; deleteCharacterData(CharacterData&amp; data, unsigned startOffset, unsigned endOffset)
 663 {
 664     if (data.length() - endOffset) {
 665         auto result = data.deleteData(endOffset, data.length() - endOffset);
 666         if (result.hasException())
 667             return result.releaseException();
 668     }
 669     if (startOffset) {
 670         auto result = data.deleteData(0, startOffset);
 671         if (result.hasException())
 672             return result.releaseException();
 673     }
 674     return { };
 675 }
 676 
 677 static ExceptionOr&lt;RefPtr&lt;Node&gt;&gt; processContentsBetweenOffsets(Range::ActionType action, RefPtr&lt;DocumentFragment&gt; fragment, RefPtr&lt;Node&gt; container, unsigned startOffset, unsigned endOffset)
 678 {
 679     ASSERT(container);
 680     ASSERT(startOffset &lt;= endOffset);
 681 
 682     RefPtr&lt;Node&gt; result;
 683 
 684     // This switch statement must be consistent with that of lengthOfContentsInNode.
 685     switch (container-&gt;nodeType()) {
 686     case Node::TEXT_NODE:
 687     case Node::CDATA_SECTION_NODE:
 688     case Node::COMMENT_NODE:
 689         endOffset = std::min(endOffset, downcast&lt;CharacterData&gt;(*container).length());
 690         startOffset = std::min(startOffset, endOffset);
 691         if (action == Range::Extract || action == Range::Clone) {
 692             Ref&lt;CharacterData&gt; characters = downcast&lt;CharacterData&gt;(container-&gt;cloneNode(true).get());
 693             auto deleteResult = deleteCharacterData(characters, startOffset, endOffset);
 694             if (deleteResult.hasException())
 695                 return deleteResult.releaseException();
 696             if (fragment) {
 697                 result = fragment;
 698                 auto appendResult = result-&gt;appendChild(characters);
 699                 if (appendResult.hasException())
 700                     return appendResult.releaseException();
 701             } else
 702                 result = WTFMove(characters);
 703         }
 704         if (action == Range::Extract || action == Range::Delete) {
 705             auto deleteResult = downcast&lt;CharacterData&gt;(*container).deleteData(startOffset, endOffset - startOffset);
 706             if (deleteResult.hasException())
 707                 return deleteResult.releaseException();
 708         }
 709         break;
 710     case Node::PROCESSING_INSTRUCTION_NODE: {
 711         auto&amp; instruction = downcast&lt;ProcessingInstruction&gt;(*container);
 712         endOffset = std::min(endOffset, downcast&lt;ProcessingInstruction&gt;(*container).data().length());
 713         startOffset = std::min(startOffset, endOffset);
 714         if (action == Range::Extract || action == Range::Clone) {
 715             Ref&lt;ProcessingInstruction&gt; processingInstruction = downcast&lt;ProcessingInstruction&gt;(container-&gt;cloneNode(true).get());
 716             processingInstruction-&gt;setData(processingInstruction-&gt;data().substring(startOffset, endOffset - startOffset));
 717             if (fragment) {
 718                 result = fragment;
 719                 auto appendResult = result-&gt;appendChild(processingInstruction);
 720                 if (appendResult.hasException())
 721                     return appendResult.releaseException();
 722             } else
 723                 result = WTFMove(processingInstruction);
 724         }
 725         if (action == Range::Extract || action == Range::Delete) {
 726             String data { instruction.data() };
 727             data.remove(startOffset, endOffset - startOffset);
 728             instruction.setData(data);
 729         }
 730         break;
 731     }
 732     case Node::ELEMENT_NODE:
 733     case Node::ATTRIBUTE_NODE:
 734     case Node::DOCUMENT_NODE:
 735     case Node::DOCUMENT_TYPE_NODE:
 736     case Node::DOCUMENT_FRAGMENT_NODE:
 737         // FIXME: Should we assert that some nodes never appear here?
 738         if (action == Range::Extract || action == Range::Clone) {
 739             if (fragment)
 740                 result = fragment;
 741             else
 742                 result = container-&gt;cloneNode(false);
 743         }
 744         Vector&lt;Ref&lt;Node&gt;&gt; nodes;
 745         Node* n = container-&gt;firstChild();
 746         for (unsigned i = startOffset; n &amp;&amp; i; i--)
 747             n = n-&gt;nextSibling();
 748         for (unsigned i = startOffset; n &amp;&amp; i &lt; endOffset; i++, n = n-&gt;nextSibling()) {
 749             if (action != Range::Delete &amp;&amp; n-&gt;isDocumentTypeNode()) {
 750                 return Exception { HierarchyRequestError };
 751             }
 752             nodes.append(*n);
 753         }
 754         auto processResult = processNodes(action, nodes, container.get(), result);
 755         if (processResult.hasException())
 756             return processResult.releaseException();
 757         break;
 758     }
 759 
 760     return result;
 761 }
 762 
 763 static ExceptionOr&lt;void&gt; processNodes(Range::ActionType action, Vector&lt;Ref&lt;Node&gt;&gt;&amp; nodes, Node* oldContainer, RefPtr&lt;Node&gt; newContainer)
 764 {
 765     for (auto&amp; node : nodes) {
 766         switch (action) {
 767         case Range::Delete: {
 768             auto result = oldContainer-&gt;removeChild(node);
 769             if (result.hasException())
 770                 return result.releaseException();
 771             break;
 772         }
 773         case Range::Extract: {
 774             auto result = newContainer-&gt;appendChild(node); // will remove node from its parent
 775             if (result.hasException())
 776                 return result.releaseException();
 777             break;
 778         }
 779         case Range::Clone: {
 780             auto result = newContainer-&gt;appendChild(node-&gt;cloneNode(true));
 781             if (result.hasException())
 782                 return result.releaseException();
 783             break;
 784         }
 785         }
 786     }
 787     return { };
 788 }
 789 
 790 ExceptionOr&lt;RefPtr&lt;Node&gt;&gt; processAncestorsAndTheirSiblings(Range::ActionType action, Node* container, ContentsProcessDirection direction, ExceptionOr&lt;RefPtr&lt;Node&gt;&gt;&amp;&amp; passedClonedContainer, Node* commonRoot)
 791 {
 792     if (passedClonedContainer.hasException())
 793         return WTFMove(passedClonedContainer);
 794 
 795     RefPtr&lt;Node&gt; clonedContainer = passedClonedContainer.releaseReturnValue();
 796 
 797     Vector&lt;Ref&lt;ContainerNode&gt;&gt; ancestors;
 798     for (ContainerNode* ancestor = container-&gt;parentNode(); ancestor &amp;&amp; ancestor != commonRoot; ancestor = ancestor-&gt;parentNode())
 799         ancestors.append(*ancestor);
 800 
 801     RefPtr&lt;Node&gt; firstChildInAncestorToProcess = direction == ProcessContentsForward ? container-&gt;nextSibling() : container-&gt;previousSibling();
 802     for (auto&amp; ancestor : ancestors) {
 803         if (action == Range::Extract || action == Range::Clone) {
 804             auto clonedAncestor = ancestor-&gt;cloneNode(false); // Might have been removed already during mutation event.
 805             if (clonedContainer) {
 806                 auto result = clonedAncestor-&gt;appendChild(*clonedContainer);
 807                 if (result.hasException())
 808                     return result.releaseException();
 809             }
 810             clonedContainer = WTFMove(clonedAncestor);
 811         }
 812 
 813         // Copy siblings of an ancestor of start/end containers
 814         // FIXME: This assertion may fail if DOM is modified during mutation event
 815         // FIXME: Share code with Range::processNodes
 816         ASSERT(!firstChildInAncestorToProcess || firstChildInAncestorToProcess-&gt;parentNode() == ancestor.ptr());
 817 
 818         Vector&lt;Ref&lt;Node&gt;&gt; nodes;
 819         for (Node* child = firstChildInAncestorToProcess.get(); child;
 820             child = (direction == ProcessContentsForward) ? child-&gt;nextSibling() : child-&gt;previousSibling())
 821             nodes.append(*child);
 822 
 823         for (auto&amp; child : nodes) {
 824             switch (action) {
 825             case Range::Delete: {
 826                 auto result = ancestor-&gt;removeChild(child);
 827                 if (result.hasException())
 828                     return result.releaseException();
 829                 break;
 830             }
 831             case Range::Extract: // will remove child from ancestor
 832                 if (direction == ProcessContentsForward) {
 833                     auto result = clonedContainer-&gt;appendChild(child);
 834                     if (result.hasException())
 835                         return result.releaseException();
 836                 } else {
 837                     auto result = clonedContainer-&gt;insertBefore(child, clonedContainer-&gt;firstChild());
 838                     if (result.hasException())
 839                         return result.releaseException();
 840                 }
 841                 break;
 842             case Range::Clone:
 843                 if (direction == ProcessContentsForward) {
 844                     auto result = clonedContainer-&gt;appendChild(child-&gt;cloneNode(true));
 845                     if (result.hasException())
 846                         return result.releaseException();
 847                 } else {
 848                     auto result = clonedContainer-&gt;insertBefore(child-&gt;cloneNode(true), clonedContainer-&gt;firstChild());
 849                     if (result.hasException())
 850                         return result.releaseException();
 851                 }
 852                 break;
 853             }
 854         }
 855         firstChildInAncestorToProcess = direction == ProcessContentsForward ? ancestor-&gt;nextSibling() : ancestor-&gt;previousSibling();
 856     }
 857 
 858     return clonedContainer;
 859 }
 860 
 861 ExceptionOr&lt;Ref&lt;DocumentFragment&gt;&gt; Range::extractContents()
 862 {
 863     auto result = processContents(Extract);
 864     if (result.hasException())
 865         return result.releaseException();
 866     return result.releaseReturnValue().releaseNonNull();
 867 }
 868 
 869 ExceptionOr&lt;Ref&lt;DocumentFragment&gt;&gt; Range::cloneContents()
 870 {
 871     auto result = processContents(Clone);
 872     if (result.hasException())
 873         return result.releaseException();
 874     return result.releaseReturnValue().releaseNonNull();
 875 }
 876 
 877 ExceptionOr&lt;void&gt; Range::insertNode(Ref&lt;Node&gt;&amp;&amp; node)
 878 {
 879     auto startContainerNodeType = startContainer().nodeType();
 880 
 881     if (startContainerNodeType == Node::COMMENT_NODE || startContainerNodeType == Node::PROCESSING_INSTRUCTION_NODE)
 882         return Exception { HierarchyRequestError };
 883     bool startIsText = startContainerNodeType == Node::TEXT_NODE;
 884     if (startIsText &amp;&amp; !startContainer().parentNode())
 885         return Exception { HierarchyRequestError };
 886     if (node.ptr() == &amp;startContainer())
 887         return Exception { HierarchyRequestError };
 888 
 889     RefPtr&lt;Node&gt; referenceNode = startIsText ? &amp;startContainer() : startContainer().traverseToChildAt(startOffset());
 890     Node* parentNode = referenceNode ? referenceNode-&gt;parentNode() : &amp;startContainer();
 891     if (!is&lt;ContainerNode&gt;(parentNode))
 892         return Exception { HierarchyRequestError };
 893 
 894     Ref&lt;ContainerNode&gt; parent = downcast&lt;ContainerNode&gt;(*parentNode);
 895 
 896     auto result = parent-&gt;ensurePreInsertionValidity(node, referenceNode.get());
 897     if (result.hasException())
 898         return result.releaseException();
 899 
 900     EventQueueScope scope;
 901     if (startIsText) {
 902         auto result = downcast&lt;Text&gt;(startContainer()).splitText(startOffset());
 903         if (result.hasException())
 904             return result.releaseException();
 905         referenceNode = result.releaseReturnValue();
 906     }
 907 
 908     if (referenceNode == node.ptr())
 909         referenceNode = referenceNode-&gt;nextSibling();
 910 
 911     auto removeResult = node-&gt;remove();
 912     if (removeResult.hasException())
 913         return removeResult.releaseException();
 914 
 915     unsigned newOffset = referenceNode ? referenceNode-&gt;computeNodeIndex() : parent-&gt;countChildNodes();
 916     if (is&lt;DocumentFragment&gt;(node))
 917         newOffset += downcast&lt;DocumentFragment&gt;(node.get()).countChildNodes();
 918     else
 919         ++newOffset;
 920 
 921     auto insertResult = parent-&gt;insertBefore(node, referenceNode.get());
 922     if (insertResult.hasException())
 923         return insertResult.releaseException();
 924 
 925     if (collapsed())
 926         return setEnd(WTFMove(parent), newOffset);
 927 
 928     return { };
 929 }
 930 
 931 String Range::toString() const
 932 {
 933     StringBuilder builder;
 934 
 935     Node* pastLast = pastLastNode();
 936     for (Node* node = firstNode(); node != pastLast; node = NodeTraversal::next(*node)) {
 937         auto type = node-&gt;nodeType();
 938         if (type == Node::TEXT_NODE || type == Node::CDATA_SECTION_NODE) {
 939             unsigned start = node == &amp;startContainer() ? m_start.offset() : 0U;
 940             unsigned end = node == &amp;endContainer() ? std::max(start, m_end.offset()) : std::numeric_limits&lt;unsigned&gt;::max();
 941             builder.appendSubstring(downcast&lt;CharacterData&gt;(*node).data(), start, end - start);
 942         }
 943     }
 944 
 945     return builder.toString();
 946 }
 947 
 948 String Range::text() const
 949 {
 950     // We need to update layout, since plainText uses line boxes in the render tree.
 951     // FIXME: As with innerText, we&#39;d like this to work even if there are no render objects.
 952     startContainer().document().updateLayout();
 953 
 954     return plainText(this);
 955 }
 956 
 957 // https://w3c.github.io/DOM-Parsing/#widl-Range-createContextualFragment-DocumentFragment-DOMString-fragment
 958 ExceptionOr&lt;Ref&lt;DocumentFragment&gt;&gt; Range::createContextualFragment(const String&amp; markup)
 959 {
 960     Node&amp; node = startContainer();
 961     RefPtr&lt;Element&gt; element;
 962     if (is&lt;Document&gt;(node) || is&lt;DocumentFragment&gt;(node))
 963         element = nullptr;
 964     else if (is&lt;Element&gt;(node))
 965         element = &amp;downcast&lt;Element&gt;(node);
 966     else
 967         element = node.parentElement();
 968     if (!element || (element-&gt;document().isHTMLDocument() &amp;&amp; is&lt;HTMLHtmlElement&gt;(*element)))
 969         element = HTMLBodyElement::create(node.document());
 970     return WebCore::createContextualFragment(*element, markup, AllowScriptingContentAndDoNotMarkAlreadyStarted);
 971 }
 972 
 973 void Range::detach()
 974 {
 975     // This is now a no-op as per the DOM specification.
 976 }
 977 
 978 ExceptionOr&lt;Node*&gt; Range::checkNodeWOffset(Node&amp; node, unsigned offset) const
 979 {
 980     switch (node.nodeType()) {
 981         case Node::DOCUMENT_TYPE_NODE:
 982             return Exception { InvalidNodeTypeError };
 983         case Node::CDATA_SECTION_NODE:
 984         case Node::COMMENT_NODE:
 985         case Node::TEXT_NODE:
 986         case Node::PROCESSING_INSTRUCTION_NODE:
 987             if (offset &gt; downcast&lt;CharacterData&gt;(node).length())
 988                 return Exception { IndexSizeError };
 989             return nullptr;
 990         case Node::ATTRIBUTE_NODE:
 991         case Node::DOCUMENT_FRAGMENT_NODE:
 992         case Node::DOCUMENT_NODE:
 993         case Node::ELEMENT_NODE: {
 994             if (!offset)
 995                 return nullptr;
 996             Node* childBefore = node.traverseToChildAt(offset - 1);
 997             if (!childBefore)
 998                 return Exception { IndexSizeError };
 999             return childBefore;
1000         }
1001     }
1002     ASSERT_NOT_REACHED();
1003     return Exception { InvalidNodeTypeError };
1004 }
1005 
1006 Ref&lt;Range&gt; Range::cloneRange() const
1007 {
1008     return Range::create(ownerDocument(), &amp;startContainer(), m_start.offset(), &amp;endContainer(), m_end.offset());
1009 }
1010 
1011 ExceptionOr&lt;void&gt; Range::setStartAfter(Node&amp; refNode)
1012 {
1013     if (!refNode.parentNode())
1014         return Exception { InvalidNodeTypeError };
1015     return setStart(*refNode.parentNode(), refNode.computeNodeIndex() + 1);
1016 }
1017 
1018 ExceptionOr&lt;void&gt; Range::setEndBefore(Node&amp; refNode)
1019 {
1020     if (!refNode.parentNode())
1021         return Exception { InvalidNodeTypeError };
1022     return setEnd(*refNode.parentNode(), refNode.computeNodeIndex());
1023 }
1024 
1025 ExceptionOr&lt;void&gt; Range::setEndAfter(Node&amp; refNode)
1026 {
1027     if (!refNode.parentNode())
1028         return Exception { InvalidNodeTypeError };
1029     return setEnd(*refNode.parentNode(), refNode.computeNodeIndex() + 1);
1030 }
1031 
1032 ExceptionOr&lt;void&gt; Range::selectNode(Node&amp; refNode)
1033 {
1034     if (!refNode.parentNode())
1035         return Exception { InvalidNodeTypeError };
1036 
1037     if (&amp;ownerDocument() != &amp;refNode.document())
1038         setDocument(refNode.document());
1039 
1040     unsigned index = refNode.computeNodeIndex();
1041     auto result = setStart(*refNode.parentNode(), index);
1042     if (result.hasException())
1043         return result.releaseException();
1044     return setEnd(*refNode.parentNode(), index + 1);
1045 }
1046 
1047 ExceptionOr&lt;void&gt; Range::selectNodeContents(Node&amp; refNode)
1048 {
1049     if (refNode.isDocumentTypeNode())
1050         return Exception { InvalidNodeTypeError };
1051 
1052     if (&amp;ownerDocument() != &amp;refNode.document())
1053         setDocument(refNode.document());
1054 
1055     m_start.setToStartOfNode(refNode);
1056     m_end.setToEndOfNode(refNode);
1057 
1058     return { };
1059 }
1060 
1061 // https://dom.spec.whatwg.org/#dom-range-surroundcontents
1062 ExceptionOr&lt;void&gt; Range::surroundContents(Node&amp; newParent)
1063 {
1064     Ref&lt;Node&gt; protectedNewParent(newParent);
1065 
1066     // Step 1: If a non-Text node is partially contained in the context object, then throw an InvalidStateError.
1067     Node* startNonTextContainer = &amp;startContainer();
1068     if (startNonTextContainer-&gt;nodeType() == Node::TEXT_NODE)
1069         startNonTextContainer = startNonTextContainer-&gt;parentNode();
1070     Node* endNonTextContainer = &amp;endContainer();
1071     if (endNonTextContainer-&gt;nodeType() == Node::TEXT_NODE)
1072         endNonTextContainer = endNonTextContainer-&gt;parentNode();
1073     if (startNonTextContainer != endNonTextContainer)
1074         return Exception { InvalidStateError };
1075 
1076     // Step 2: If newParent is a Document, DocumentType, or DocumentFragment node, then throw an InvalidNodeTypeError.
1077     switch (newParent.nodeType()) {
1078         case Node::ATTRIBUTE_NODE:
1079         case Node::DOCUMENT_FRAGMENT_NODE:
1080         case Node::DOCUMENT_NODE:
1081         case Node::DOCUMENT_TYPE_NODE:
1082             return Exception { InvalidNodeTypeError };
1083         case Node::CDATA_SECTION_NODE:
1084         case Node::COMMENT_NODE:
1085         case Node::ELEMENT_NODE:
1086         case Node::PROCESSING_INSTRUCTION_NODE:
1087         case Node::TEXT_NODE:
1088             break;
1089     }
1090 
1091     // Step 3: Let fragment be the result of extracting context object.
1092     auto fragment = extractContents();
1093     if (fragment.hasException())
1094         return fragment.releaseException();
1095 
1096     // Step 4: If newParent has children, replace all with null within newParent.
1097     if (newParent.hasChildNodes())
1098         downcast&lt;ContainerNode&gt;(newParent).replaceAllChildren(nullptr);
1099 
1100     // Step 5: Insert newParent into context object.
1101     auto insertResult = insertNode(newParent);
1102     if (insertResult.hasException())
1103         return insertResult.releaseException();
1104 
1105     // Step 6: Append fragment to newParent.
1106     auto appendResult = newParent.appendChild(fragment.releaseReturnValue());
1107     if (appendResult.hasException())
1108         return appendResult.releaseException();
1109 
1110     // Step 7: Select newParent within context object.
1111     return selectNode(newParent);
1112 }
1113 
1114 ExceptionOr&lt;void&gt; Range::setStartBefore(Node&amp; refNode)
1115 {
1116     if (!refNode.parentNode())
1117         return Exception { InvalidNodeTypeError };
1118     return setStart(*refNode.parentNode(), refNode.computeNodeIndex());
1119 }
1120 
1121 Node* Range::firstNode() const
1122 {
1123     if (startContainer().isCharacterDataNode())
1124         return &amp;startContainer();
1125     if (Node* child = startContainer().traverseToChildAt(m_start.offset()))
1126         return child;
1127     if (!m_start.offset())
1128         return &amp;startContainer();
1129     return NodeTraversal::nextSkippingChildren(startContainer());
1130 }
1131 
1132 ShadowRoot* Range::shadowRoot() const
1133 {
1134     return startContainer().containingShadowRoot();
1135 }
1136 
1137 Node* Range::pastLastNode() const
1138 {
1139     if (endContainer().isCharacterDataNode())
1140         return NodeTraversal::nextSkippingChildren(endContainer());
1141     if (Node* child = endContainer().traverseToChildAt(m_end.offset()))
1142         return child;
1143     return NodeTraversal::nextSkippingChildren(endContainer());
1144 }
1145 
1146 IntRect Range::absoluteBoundingBox(OptionSet&lt;BoundingRectBehavior&gt; rectOptions) const
1147 {
1148     IntRect result;
1149     Vector&lt;IntRect&gt; rects;
1150     bool useSelectionHeight = false;
1151     RangeInFixedPosition* inFixed = nullptr;
1152     absoluteTextRects(rects, useSelectionHeight, inFixed, rectOptions);
1153     for (auto&amp; rect : rects)
1154         result.unite(rect);
1155     return result;
1156 }
1157 
1158 Vector&lt;FloatRect&gt; Range::absoluteRectsForRangeInText(Node* node, RenderText&amp; renderText, bool useSelectionHeight, bool&amp; isFixed, OptionSet&lt;BoundingRectBehavior&gt; rectOptions) const
1159 {
1160     unsigned startOffset = node == &amp;startContainer() ? m_start.offset() : 0;
1161     unsigned endOffset = node == &amp;endContainer() ? m_end.offset() : std::numeric_limits&lt;unsigned&gt;::max();
1162 
1163     auto textQuads = renderText.absoluteQuadsForRange(startOffset, endOffset, useSelectionHeight, rectOptions.contains(BoundingRectBehavior::IgnoreEmptyTextSelections), &amp;isFixed);
1164 
1165     if (rectOptions.contains(BoundingRectBehavior::RespectClipping)) {
1166         Vector&lt;FloatRect&gt; clippedRects;
1167         clippedRects.reserveInitialCapacity(textQuads.size());
1168 
1169         auto absoluteClippedOverflowRect = renderText.absoluteClippedOverflowRect();
1170 
1171         for (auto&amp; quad : textQuads) {
1172             auto clippedRect = intersection(quad.boundingBox(), absoluteClippedOverflowRect);
1173             if (!clippedRect.isEmpty())
1174                 clippedRects.uncheckedAppend(clippedRect);
1175         }
1176 
1177         return clippedRects;
1178     }
1179 
1180     Vector&lt;FloatRect&gt; floatRects;
1181     floatRects.reserveInitialCapacity(textQuads.size());
1182     for (auto&amp; quad : textQuads)
1183         floatRects.uncheckedAppend(quad.boundingBox());
1184     return floatRects;
1185 }
1186 
1187 void Range::absoluteTextRects(Vector&lt;IntRect&gt;&amp; rects, bool useSelectionHeight, RangeInFixedPosition* inFixed, OptionSet&lt;BoundingRectBehavior&gt; rectOptions) const
1188 {
1189     // FIXME: This function should probably return FloatRects.
1190 
1191     bool allFixed = true;
1192     bool someFixed = false;
1193 
1194     Node* stopNode = pastLastNode();
1195     for (Node* node = firstNode(); node != stopNode; node = NodeTraversal::next(*node)) {
1196         RenderObject* renderer = node-&gt;renderer();
1197         if (!renderer)
1198             continue;
1199         bool isFixed = false;
1200         if (renderer-&gt;isBR())
1201             renderer-&gt;absoluteRects(rects, flooredLayoutPoint(renderer-&gt;localToAbsolute()));
1202         else if (is&lt;RenderText&gt;(*renderer)) {
1203             auto rectsForRenderer = absoluteRectsForRangeInText(node, downcast&lt;RenderText&gt;(*renderer), useSelectionHeight, isFixed, rectOptions);
1204             for (auto&amp; rect : rectsForRenderer)
1205                 rects.append(enclosingIntRect(rect));
1206         } else
1207             continue;
1208         allFixed &amp;= isFixed;
1209         someFixed |= isFixed;
1210     }
1211 
1212     if (inFixed)
1213         *inFixed = allFixed ? EntirelyFixedPosition : (someFixed ? PartiallyFixedPosition : NotFixedPosition);
1214 }
1215 
1216 void Range::absoluteTextQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool useSelectionHeight, RangeInFixedPosition* inFixed) const
1217 {
1218     bool allFixed = true;
1219     bool someFixed = false;
1220 
1221     Node* stopNode = pastLastNode();
1222     for (Node* node = firstNode(); node != stopNode; node = NodeTraversal::next(*node)) {
1223         RenderObject* renderer = node-&gt;renderer();
1224         if (!renderer)
1225             continue;
1226         bool isFixed = false;
1227         if (renderer-&gt;isBR())
1228             renderer-&gt;absoluteQuads(quads, &amp;isFixed);
1229         else if (is&lt;RenderText&gt;(*renderer)) {
1230             unsigned startOffset = node == &amp;startContainer() ? m_start.offset() : 0;
1231             unsigned endOffset = node == &amp;endContainer() ? m_end.offset() : std::numeric_limits&lt;unsigned&gt;::max();
1232             quads.appendVector(downcast&lt;RenderText&gt;(*renderer).absoluteQuadsForRange(startOffset, endOffset, useSelectionHeight, false /* ignoreEmptyTextSelections */, &amp;isFixed));
1233         } else
1234             continue;
1235         allFixed &amp;= isFixed;
1236         someFixed |= isFixed;
1237     }
1238 
1239     if (inFixed)
1240         *inFixed = allFixed ? EntirelyFixedPosition : (someFixed ? PartiallyFixedPosition : NotFixedPosition);
1241 }
1242 
1243 #if PLATFORM(IOS_FAMILY)
1244 static bool intervalsSufficientlyOverlap(int startA, int endA, int startB, int endB)
1245 {
1246     if (endA &lt;= startA || endB &lt;= startB)
1247         return false;
1248 
1249     const float sufficientOverlap = .75;
1250 
1251     int lengthA = endA - startA;
1252     int lengthB = endB - startB;
1253 
1254     int maxStart = std::max(startA, startB);
1255     int minEnd = std::min(endA, endB);
1256 
1257     if (maxStart &gt; minEnd)
1258         return false;
1259 
1260     return minEnd - maxStart &gt;= sufficientOverlap * std::min(lengthA, lengthB);
1261 }
1262 
1263 static inline void adjustLineHeightOfSelectionRects(Vector&lt;SelectionRect&gt;&amp; rects, size_t numberOfRects, int lineNumber, int lineTop, int lineHeight)
1264 {
1265     ASSERT(rects.size() &gt;= numberOfRects);
1266     for (size_t i = numberOfRects; i; ) {
1267         --i;
1268         if (rects[i].lineNumber())
1269             break;
1270         rects[i].setLineNumber(lineNumber);
1271         rects[i].setLogicalTop(lineTop);
1272         rects[i].setLogicalHeight(lineHeight);
1273     }
1274 }
1275 
1276 static SelectionRect coalesceSelectionRects(const SelectionRect&amp; original, const SelectionRect&amp; previous)
1277 {
1278     SelectionRect result(unionRect(previous.rect(), original.rect()), original.isHorizontal(), original.pageNumber());
1279     result.setDirection(original.containsStart() || original.containsEnd() ? original.direction() : previous.direction());
1280     result.setContainsStart(previous.containsStart() || original.containsStart());
1281     result.setContainsEnd(previous.containsEnd() || original.containsEnd());
1282     result.setIsFirstOnLine(previous.isFirstOnLine() || original.isFirstOnLine());
1283     result.setIsLastOnLine(previous.isLastOnLine() || original.isLastOnLine());
1284     return result;
1285 }
1286 
1287 // This function is similar in spirit to addLineBoxRects, but annotates the returned rectangles
1288 // with additional state which helps iOS draw selections in its unique way.
1289 int Range::collectSelectionRectsWithoutUnionInteriorLines(Vector&lt;SelectionRect&gt;&amp; rects) const
1290 {
1291     auto&amp; startContainer = this-&gt;startContainer();
1292     auto&amp; endContainer = this-&gt;endContainer();
1293     int startOffset = m_start.offset();
1294     int endOffset = m_end.offset();
1295 
1296     Vector&lt;SelectionRect&gt; newRects;
1297     Node* stopNode = pastLastNode();
1298     bool hasFlippedWritingMode = startContainer.renderer() &amp;&amp; startContainer.renderer()-&gt;style().isFlippedBlocksWritingMode();
1299     bool containsDifferentWritingModes = false;
1300     for (Node* node = firstNode(); node &amp;&amp; node != stopNode; node = NodeTraversal::next(*node)) {
1301         RenderObject* renderer = node-&gt;renderer();
1302         // Only ask leaf render objects for their line box rects.
1303         if (renderer &amp;&amp; !renderer-&gt;firstChildSlow() &amp;&amp; renderer-&gt;style().userSelect() != UserSelect::None) {
1304             bool isStartNode = renderer-&gt;node() == &amp;startContainer;
1305             bool isEndNode = renderer-&gt;node() == &amp;endContainer;
1306             if (hasFlippedWritingMode != renderer-&gt;style().isFlippedBlocksWritingMode())
1307                 containsDifferentWritingModes = true;
1308             // FIXME: Sending 0 for the startOffset is a weird way of telling the renderer that the selection
1309             // doesn&#39;t start inside it, since we&#39;ll also send 0 if the selection *does* start in it, at offset 0.
1310             //
1311             // FIXME: Selection endpoints aren&#39;t always inside leaves, and we only build SelectionRects for leaves,
1312             // so we can&#39;t accurately determine which SelectionRects contain the selection start and end using
1313             // only the offsets of the start and end. We need to pass the whole Range.
1314             int beginSelectionOffset = isStartNode ? startOffset : 0;
1315             int endSelectionOffset = isEndNode ? endOffset : std::numeric_limits&lt;int&gt;::max();
1316             renderer-&gt;collectSelectionRects(newRects, beginSelectionOffset, endSelectionOffset);
1317             for (auto&amp; selectionRect : newRects) {
1318                 if (selectionRect.containsStart() &amp;&amp; !isStartNode)
1319                     selectionRect.setContainsStart(false);
1320                 if (selectionRect.containsEnd() &amp;&amp; !isEndNode)
1321                     selectionRect.setContainsEnd(false);
1322                 if (selectionRect.logicalWidth() || selectionRect.logicalHeight())
1323                     rects.append(selectionRect);
1324             }
1325             newRects.shrink(0);
1326         }
1327     }
1328 
1329     // The range could span over nodes with different writing modes.
1330     // If this is the case, we use the writing mode of the common ancestor.
1331     if (containsDifferentWritingModes) {
1332         if (Node* ancestor = commonAncestorContainer(&amp;startContainer, &amp;endContainer))
1333             hasFlippedWritingMode = ancestor-&gt;renderer()-&gt;style().isFlippedBlocksWritingMode();
1334     }
1335 
1336     const size_t numberOfRects = rects.size();
1337 
1338     // If the selection ends in a BR, then add the line break bit to the last
1339     // rect we have. This will cause its selection rect to extend to the
1340     // end of the line.
1341     if (stopNode &amp;&amp; stopNode-&gt;hasTagName(HTMLNames::brTag) &amp;&amp; numberOfRects) {
1342         // Only set the line break bit if the end of the range actually
1343         // extends all the way to include the &lt;br&gt;. VisiblePosition helps to
1344         // figure this out.
1345         VisiblePosition endPosition(createLegacyEditingPosition(&amp;endContainer, endOffset), VP_DEFAULT_AFFINITY);
1346         VisiblePosition brPosition(createLegacyEditingPosition(stopNode, 0), VP_DEFAULT_AFFINITY);
1347         if (endPosition == brPosition)
1348             rects.last().setIsLineBreak(true);
1349     }
1350 
1351     int lineTop = std::numeric_limits&lt;int&gt;::max();
1352     int lineBottom = std::numeric_limits&lt;int&gt;::min();
1353     int lastLineTop = lineTop;
1354     int lastLineBottom = lineBottom;
1355     int lineNumber = 0;
1356 
1357     for (size_t i = 0; i &lt; numberOfRects; ++i) {
1358         int currentRectTop = rects[i].logicalTop();
1359         int currentRectBottom = currentRectTop + rects[i].logicalHeight();
1360 
1361         // We don&#39;t want to count the ruby text as a separate line.
1362         if (intervalsSufficientlyOverlap(currentRectTop, currentRectBottom, lineTop, lineBottom) || (i &amp;&amp; rects[i].isRubyText())) {
1363             // Grow the current line bounds.
1364             lineTop = std::min(lineTop, currentRectTop);
1365             lineBottom = std::max(lineBottom, currentRectBottom);
1366             // Avoid overlap with the previous line.
1367             if (!hasFlippedWritingMode)
1368                 lineTop = std::max(lastLineBottom, lineTop);
1369             else
1370                 lineBottom = std::min(lastLineTop, lineBottom);
1371         } else {
1372             adjustLineHeightOfSelectionRects(rects, i, lineNumber, lineTop, lineBottom - lineTop);
1373             if (!hasFlippedWritingMode) {
1374                 lastLineTop = lineTop;
1375                 if (currentRectBottom &gt;= lastLineTop) {
1376                     lastLineBottom = lineBottom;
1377                     lineTop = lastLineBottom;
1378                 } else {
1379                     lineTop = currentRectTop;
1380                     lastLineBottom = std::numeric_limits&lt;int&gt;::min();
1381                 }
1382                 lineBottom = currentRectBottom;
1383             } else {
1384                 lastLineBottom = lineBottom;
1385                 if (currentRectTop &lt;= lastLineBottom &amp;&amp; i &amp;&amp; rects[i].pageNumber() == rects[i - 1].pageNumber()) {
1386                     lastLineTop = lineTop;
1387                     lineBottom = lastLineTop;
1388                 } else {
1389                     lastLineTop = std::numeric_limits&lt;int&gt;::max();
1390                     lineBottom = currentRectBottom;
1391                 }
1392                 lineTop = currentRectTop;
1393             }
1394             ++lineNumber;
1395         }
1396     }
1397 
1398     // Adjust line height.
1399     adjustLineHeightOfSelectionRects(rects, numberOfRects, lineNumber, lineTop, lineBottom - lineTop);
1400 
1401     // Sort the rectangles and make sure there are no gaps. The rectangles could be unsorted when
1402     // there is ruby text and we could have gaps on the line when adjacent elements on the line
1403     // have a different orientation.
1404     size_t firstRectWithCurrentLineNumber = 0;
1405     for (size_t currentRect = 1; currentRect &lt; numberOfRects; ++currentRect) {
1406         if (rects[currentRect].lineNumber() != rects[currentRect - 1].lineNumber()) {
1407             firstRectWithCurrentLineNumber = currentRect;
1408             continue;
1409         }
1410         if (rects[currentRect].logicalLeft() &gt;= rects[currentRect - 1].logicalLeft())
1411             continue;
1412 
1413         SelectionRect selectionRect = rects[currentRect];
1414         size_t i;
1415         for (i = currentRect; i &gt; firstRectWithCurrentLineNumber &amp;&amp; selectionRect.logicalLeft() &lt; rects[i - 1].logicalLeft(); --i)
1416             rects[i] = rects[i - 1];
1417         rects[i] = selectionRect;
1418     }
1419 
1420     for (size_t j = 1; j &lt; numberOfRects; ++j) {
1421         if (rects[j].lineNumber() != rects[j - 1].lineNumber())
1422             continue;
1423         SelectionRect&amp; previousRect = rects[j - 1];
1424         bool previousRectMayNotReachRightEdge = (previousRect.direction() == TextDirection::LTR &amp;&amp; previousRect.containsEnd()) || (previousRect.direction() == TextDirection::RTL &amp;&amp; previousRect.containsStart());
1425         if (previousRectMayNotReachRightEdge)
1426             continue;
1427         int adjustedWidth = rects[j].logicalLeft() - previousRect.logicalLeft();
1428         if (adjustedWidth &gt; previousRect.logicalWidth())
1429             previousRect.setLogicalWidth(adjustedWidth);
1430     }
1431 
1432     int maxLineNumber = lineNumber;
1433 
1434     // Extend rects out to edges as needed.
1435     for (size_t i = 0; i &lt; numberOfRects; ++i) {
1436         SelectionRect&amp; selectionRect = rects[i];
1437         if (!selectionRect.isLineBreak() &amp;&amp; selectionRect.lineNumber() &gt;= maxLineNumber)
1438             continue;
1439         if (selectionRect.direction() == TextDirection::RTL &amp;&amp; selectionRect.isFirstOnLine()) {
1440             selectionRect.setLogicalWidth(selectionRect.logicalWidth() + selectionRect.logicalLeft() - selectionRect.minX());
1441             selectionRect.setLogicalLeft(selectionRect.minX());
1442         } else if (selectionRect.direction() == TextDirection::LTR &amp;&amp; selectionRect.isLastOnLine())
1443             selectionRect.setLogicalWidth(selectionRect.maxX() - selectionRect.logicalLeft());
1444     }
1445 
1446     return maxLineNumber;
1447 }
1448 
1449 void Range::collectSelectionRects(Vector&lt;SelectionRect&gt;&amp; rects) const
1450 {
1451     int maxLineNumber = collectSelectionRectsWithoutUnionInteriorLines(rects);
1452     const size_t numberOfRects = rects.size();
1453 
1454     // Union all the rectangles on interior lines (i.e. not first or last).
1455     // On first and last lines, just avoid having overlaps by merging intersecting rectangles.
1456     Vector&lt;SelectionRect&gt; unionedRects;
1457     IntRect interiorUnionRect;
1458     for (size_t i = 0; i &lt; numberOfRects; ++i) {
1459         SelectionRect&amp; currentRect = rects[i];
1460         if (currentRect.lineNumber() == 1) {
1461             ASSERT(interiorUnionRect.isEmpty());
1462             if (!unionedRects.isEmpty()) {
1463                 SelectionRect&amp; previousRect = unionedRects.last();
1464                 if (previousRect.rect().intersects(currentRect.rect())) {
1465                     previousRect = coalesceSelectionRects(currentRect, previousRect);
1466                     continue;
1467                 }
1468             }
1469             // Couldn&#39;t merge with previous rect, so just appending.
1470             unionedRects.append(currentRect);
1471         } else if (currentRect.lineNumber() &lt; maxLineNumber) {
1472             if (interiorUnionRect.isEmpty()) {
1473                 // Start collecting interior rects.
1474                 interiorUnionRect = currentRect.rect();
1475             } else if (interiorUnionRect.intersects(currentRect.rect())
1476                 || interiorUnionRect.maxX() == currentRect.rect().x()
1477                 || interiorUnionRect.maxY() == currentRect.rect().y()
1478                 || interiorUnionRect.x() == currentRect.rect().maxX()
1479                 || interiorUnionRect.y() == currentRect.rect().maxY()) {
1480                 // Only union the lines that are attached.
1481                 // For iBooks, the interior lines may cross multiple horizontal pages.
1482                 interiorUnionRect.unite(currentRect.rect());
1483             } else {
1484                 unionedRects.append(SelectionRect(interiorUnionRect, currentRect.isHorizontal(), currentRect.pageNumber()));
1485                 interiorUnionRect = currentRect.rect();
1486             }
1487         } else {
1488             // Processing last line.
1489             if (!interiorUnionRect.isEmpty()) {
1490                 unionedRects.append(SelectionRect(interiorUnionRect, currentRect.isHorizontal(), currentRect.pageNumber()));
1491                 interiorUnionRect = IntRect();
1492             }
1493 
1494             ASSERT(!unionedRects.isEmpty());
1495             SelectionRect&amp; previousRect = unionedRects.last();
1496             if (previousRect.logicalTop() == currentRect.logicalTop() &amp;&amp; previousRect.rect().intersects(currentRect.rect())) {
1497                 // previousRect is also on the last line, and intersects the current one.
1498                 previousRect = coalesceSelectionRects(currentRect, previousRect);
1499                 continue;
1500             }
1501             // Couldn&#39;t merge with previous rect, so just appending.
1502             unionedRects.append(currentRect);
1503         }
1504     }
1505 
1506     rects.swap(unionedRects);
1507 }
1508 #endif
1509 
1510 #if ENABLE(TREE_DEBUGGING)
1511 void Range::formatForDebugger(char* buffer, unsigned length) const
1512 {
1513     StringBuilder result;
1514 
1515     const int FormatBufferSize = 1024;
1516     char s[FormatBufferSize];
1517     result.appendLiteral(&quot;from offset &quot;);
1518     result.appendNumber(m_start.offset());
1519     result.appendLiteral(&quot; of &quot;);
1520     startContainer().formatForDebugger(s, FormatBufferSize);
1521     result.append(s);
1522     result.appendLiteral(&quot; to offset &quot;);
1523     result.appendNumber(m_end.offset());
1524     result.appendLiteral(&quot; of &quot;);
1525     endContainer().formatForDebugger(s, FormatBufferSize);
1526     result.append(s);
1527 
1528     strncpy(buffer, result.toString().utf8().data(), length - 1);
1529 }
1530 #endif
1531 
1532 bool Range::contains(const Range&amp; other) const
1533 {
1534     if (commonAncestorContainer()-&gt;ownerDocument() != other.commonAncestorContainer()-&gt;ownerDocument())
1535         return false;
1536 
1537     auto startToStart = compareBoundaryPoints(Range::START_TO_START, other);
1538     if (startToStart.hasException() || startToStart.releaseReturnValue() &gt; 0)
1539         return false;
1540 
1541     auto endToEnd = compareBoundaryPoints(Range::END_TO_END, other);
1542     return !endToEnd.hasException() &amp;&amp; endToEnd.releaseReturnValue() &gt;= 0;
1543 }
1544 
1545 bool Range::contains(const VisiblePosition&amp; position) const
1546 {
1547     RefPtr&lt;Range&gt; positionRange = makeRange(position, position);
1548     if (!positionRange)
1549         return false;
1550     return contains(*positionRange);
1551 }
1552 
1553 bool areRangesEqual(const Range* a, const Range* b)
1554 {
1555     if (a == b)
1556         return true;
1557     if (!a || !b)
1558         return false;
1559     return a-&gt;startPosition() == b-&gt;startPosition() &amp;&amp; a-&gt;endPosition() == b-&gt;endPosition();
1560 }
1561 
1562 bool rangesOverlap(const Range* a, const Range* b)
1563 {
1564     if (!a || !b)
1565         return false;
1566 
1567     if (a == b)
1568         return true;
1569 
1570     if (!areNodesConnectedInSameTreeScope(a-&gt;commonAncestorContainer(), b-&gt;commonAncestorContainer()))
1571         return false;
1572 
1573     short startToStart = a-&gt;compareBoundaryPoints(Range::START_TO_START, *b).releaseReturnValue();
1574     short endToEnd = a-&gt;compareBoundaryPoints(Range::END_TO_END, *b).releaseReturnValue();
1575 
1576     // First range contains the second range.
1577     if (startToStart &lt;= 0 &amp;&amp; endToEnd &gt;= 0)
1578         return true;
1579 
1580     // End of first range is inside second range.
1581     if (a-&gt;compareBoundaryPoints(Range::START_TO_END, *b).releaseReturnValue() &gt;= 0 &amp;&amp; endToEnd &lt;= 0)
1582         return true;
1583 
1584     // Start of first range is inside second range.
1585     if (startToStart &gt;= 0 &amp;&amp; a-&gt;compareBoundaryPoints(Range::END_TO_START, *b).releaseReturnValue() &lt;= 0)
1586         return true;
1587 
1588     return false;
1589 }
1590 
1591 Ref&lt;Range&gt; rangeOfContents(Node&amp; node)
1592 {
1593     auto range = Range::create(node.document());
1594     range-&gt;selectNodeContents(node);
1595     return range;
1596 }
1597 
1598 static inline void boundaryNodeChildrenChanged(RangeBoundaryPoint&amp; boundary, ContainerNode&amp; container)
1599 {
1600     if (!boundary.childBefore())
1601         return;
1602     if (boundary.container() != &amp;container)
1603         return;
1604     boundary.invalidateOffset();
1605 }
1606 
1607 void Range::nodeChildrenChanged(ContainerNode&amp; container)
1608 {
1609     ASSERT(&amp;container.document() == &amp;ownerDocument());
1610     boundaryNodeChildrenChanged(m_start, container);
1611     boundaryNodeChildrenChanged(m_end, container);
1612 }
1613 
1614 static inline void boundaryNodeChildrenWillBeRemoved(RangeBoundaryPoint&amp; boundary, ContainerNode&amp; container)
1615 {
1616     for (Node* nodeToBeRemoved = container.firstChild(); nodeToBeRemoved; nodeToBeRemoved = nodeToBeRemoved-&gt;nextSibling()) {
1617         if (boundary.childBefore() == nodeToBeRemoved) {
1618             boundary.setToStartOfNode(container);
1619             return;
1620         }
1621 
1622         for (Node* n = boundary.container(); n; n = n-&gt;parentNode()) {
1623             if (n == nodeToBeRemoved) {
1624                 boundary.setToStartOfNode(container);
1625                 return;
1626             }
1627         }
1628     }
1629 }
1630 
1631 void Range::nodeChildrenWillBeRemoved(ContainerNode&amp; container)
1632 {
1633     ASSERT(&amp;container.document() == &amp;ownerDocument());
1634     boundaryNodeChildrenWillBeRemoved(m_start, container);
1635     boundaryNodeChildrenWillBeRemoved(m_end, container);
1636 }
1637 
1638 static inline void boundaryNodeWillBeRemoved(RangeBoundaryPoint&amp; boundary, Node&amp; nodeToBeRemoved)
1639 {
1640     if (boundary.childBefore() == &amp;nodeToBeRemoved) {
1641         boundary.childBeforeWillBeRemoved();
1642         return;
1643     }
1644 
1645     for (Node* n = boundary.container(); n; n = n-&gt;parentNode()) {
1646         if (n == &amp;nodeToBeRemoved) {
1647             boundary.setToBeforeChild(nodeToBeRemoved);
1648             return;
1649         }
1650     }
1651 }
1652 
1653 void Range::nodeWillBeRemoved(Node&amp; node)
1654 {
1655     ASSERT(&amp;node.document() == &amp;ownerDocument());
1656     ASSERT(&amp;node != &amp;ownerDocument());
1657     ASSERT(node.parentNode());
1658     boundaryNodeWillBeRemoved(m_start, node);
1659     boundaryNodeWillBeRemoved(m_end, node);
1660 }
1661 
1662 static inline void boundaryTextInserted(RangeBoundaryPoint&amp; boundary, Node&amp; text, unsigned offset, unsigned length)
1663 {
1664     if (boundary.container() != &amp;text)
1665         return;
1666     unsigned boundaryOffset = boundary.offset();
1667     if (offset &gt;= boundaryOffset)
1668         return;
1669     boundary.setOffset(boundaryOffset + length);
1670 }
1671 
1672 void Range::textInserted(Node&amp; text, unsigned offset, unsigned length)
1673 {
1674     ASSERT(&amp;text.document() == &amp;ownerDocument());
1675     boundaryTextInserted(m_start, text, offset, length);
1676     boundaryTextInserted(m_end, text, offset, length);
1677 }
1678 
1679 static inline void boundaryTextRemoved(RangeBoundaryPoint&amp; boundary, Node&amp; text, unsigned offset, unsigned length)
1680 {
1681     if (boundary.container() != &amp;text)
1682         return;
1683     unsigned boundaryOffset = boundary.offset();
1684     if (offset &gt;= boundaryOffset)
1685         return;
1686     if (offset + length &gt;= boundaryOffset)
1687         boundary.setOffset(offset);
1688     else
1689         boundary.setOffset(boundaryOffset - length);
1690 }
1691 
1692 void Range::textRemoved(Node&amp; text, unsigned offset, unsigned length)
1693 {
1694     ASSERT(&amp;text.document() == &amp;ownerDocument());
1695     boundaryTextRemoved(m_start, text, offset, length);
1696     boundaryTextRemoved(m_end, text, offset, length);
1697 }
1698 
1699 static inline void boundaryTextNodesMerged(RangeBoundaryPoint&amp; boundary, NodeWithIndex&amp; oldNode, unsigned offset)
1700 {
1701     if (boundary.container() == oldNode.node())
1702         boundary.set(*oldNode.node()-&gt;previousSibling(), boundary.offset() + offset, 0);
1703     else if (boundary.container() == oldNode.node()-&gt;parentNode() &amp;&amp; static_cast&lt;int&gt;(boundary.offset()) == oldNode.index())
1704         boundary.set(*oldNode.node()-&gt;previousSibling(), offset, 0);
1705 }
1706 
1707 void Range::textNodesMerged(NodeWithIndex&amp; oldNode, unsigned offset)
1708 {
1709     ASSERT(oldNode.node());
1710     ASSERT(&amp;oldNode.node()-&gt;document() == &amp;ownerDocument());
1711     ASSERT(oldNode.node()-&gt;parentNode());
1712     ASSERT(oldNode.node()-&gt;isTextNode());
1713     ASSERT(oldNode.node()-&gt;previousSibling());
1714     ASSERT(oldNode.node()-&gt;previousSibling()-&gt;isTextNode());
1715     boundaryTextNodesMerged(m_start, oldNode, offset);
1716     boundaryTextNodesMerged(m_end, oldNode, offset);
1717 }
1718 
1719 static inline void boundaryTextNodesSplit(RangeBoundaryPoint&amp; boundary, Text&amp; oldNode)
1720 {
1721     auto* parent = oldNode.parentNode();
1722     if (boundary.container() == &amp;oldNode) {
1723         unsigned splitOffset = oldNode.length();
1724         unsigned boundaryOffset = boundary.offset();
1725         if (boundaryOffset &gt; splitOffset) {
1726             if (parent)
1727                 boundary.set(*oldNode.nextSibling(), boundaryOffset - splitOffset, 0);
1728             else
1729                 boundary.setOffset(splitOffset);
1730         }
1731         return;
1732     }
1733     if (!parent)
1734         return;
1735     if (boundary.container() == parent &amp;&amp; boundary.childBefore() == &amp;oldNode) {
1736         auto* newChild = oldNode.nextSibling();
1737         ASSERT(newChild);
1738         boundary.setToAfterChild(*newChild);
1739     }
1740 }
1741 
1742 void Range::textNodeSplit(Text&amp; oldNode)
1743 {
1744     ASSERT(&amp;oldNode.document() == &amp;ownerDocument());
1745     ASSERT(!oldNode.parentNode() || oldNode.nextSibling());
1746     ASSERT(!oldNode.parentNode() || oldNode.nextSibling()-&gt;isTextNode());
1747     boundaryTextNodesSplit(m_start, oldNode);
1748     boundaryTextNodesSplit(m_end, oldNode);
1749 }
1750 
1751 ExceptionOr&lt;void&gt; Range::expand(const String&amp; unit)
1752 {
1753     VisiblePosition start { startPosition() };
1754     VisiblePosition end { endPosition() };
1755     if (unit == &quot;word&quot;) {
1756         start = startOfWord(start);
1757         end = endOfWord(end);
1758     } else if (unit == &quot;sentence&quot;) {
1759         start = startOfSentence(start);
1760         end = endOfSentence(end);
1761     } else if (unit == &quot;block&quot;) {
1762         start = startOfParagraph(start);
1763         end = endOfParagraph(end);
1764     } else if (unit == &quot;document&quot;) {
1765         start = startOfDocument(start);
1766         end = endOfDocument(end);
1767     } else
1768         return { };
1769 
1770     auto* startContainer = start.deepEquivalent().containerNode();
1771     if (!startContainer)
1772         return Exception { TypeError };
1773     auto result = setStart(*startContainer, start.deepEquivalent().computeOffsetInContainerNode());
1774     if (result.hasException())
1775         return result.releaseException();
1776     auto* endContainer = end.deepEquivalent().containerNode();
1777     if (!endContainer)
1778         return Exception { TypeError };
1779     return setEnd(*endContainer, end.deepEquivalent().computeOffsetInContainerNode());
1780 }
1781 
1782 Ref&lt;DOMRectList&gt; Range::getClientRects() const
1783 {
1784     return DOMRectList::create(borderAndTextRects(CoordinateSpace::Client));
1785 }
1786 
1787 Ref&lt;DOMRect&gt; Range::getBoundingClientRect() const
1788 {
1789     return DOMRect::create(boundingRect(CoordinateSpace::Client));
1790 }
1791 
1792 Vector&lt;FloatRect&gt; Range::borderAndTextRects(CoordinateSpace space, OptionSet&lt;BoundingRectBehavior&gt; rectOptions) const
1793 {
1794     Vector&lt;FloatRect&gt; rects;
1795 
1796     ownerDocument().updateLayoutIgnorePendingStylesheets();
1797 
1798     Node* stopNode = pastLastNode();
1799     bool useVisibleBounds = rectOptions.contains(BoundingRectBehavior::UseVisibleBounds);
1800 
1801     HashSet&lt;Node*&gt; selectedElementsSet;
1802     for (Node* node = firstNode(); node != stopNode; node = NodeTraversal::next(*node)) {
1803         if (is&lt;Element&gt;(*node))
1804             selectedElementsSet.add(node);
1805     }
1806 
1807     // Don&#39;t include elements that are only partially selected.
1808     Node* lastNode = m_end.childBefore() ? m_end.childBefore() : &amp;endContainer();
1809     for (Node* parent = lastNode-&gt;parentNode(); parent; parent = parent-&gt;parentNode())
1810         selectedElementsSet.remove(parent);
1811 
1812     OptionSet&lt;RenderObject::VisibleRectContextOption&gt; visibleRectOptions = { RenderObject::VisibleRectContextOption::UseEdgeInclusiveIntersection, RenderObject::VisibleRectContextOption::ApplyCompositedClips, RenderObject::VisibleRectContextOption::ApplyCompositedContainerScrolls };
1813 
1814     for (Node* node = firstNode(); node != stopNode; node = NodeTraversal::next(*node)) {
1815         if (is&lt;Element&gt;(*node) &amp;&amp; selectedElementsSet.contains(node) &amp;&amp; (useVisibleBounds || !node-&gt;parentNode() || !selectedElementsSet.contains(node-&gt;parentNode()))) {
1816             if (auto* renderer = downcast&lt;Element&gt;(*node).renderBoxModelObject()) {
1817                 if (useVisibleBounds) {
1818                     auto localBounds = renderer-&gt;borderBoundingBox();
1819                     auto rootClippedBounds = renderer-&gt;computeVisibleRectInContainer(localBounds, &amp;renderer-&gt;view(), { false, false, visibleRectOptions });
1820                     if (!rootClippedBounds)
1821                         continue;
1822                     auto snappedBounds = snapRectToDevicePixels(*rootClippedBounds, node-&gt;document().deviceScaleFactor());
1823                     if (space == CoordinateSpace::Client)
1824                         node-&gt;document().convertAbsoluteToClientRect(snappedBounds, renderer-&gt;style());
1825                     rects.append(snappedBounds);
1826 
1827                     continue;
1828                 }
1829 
1830                 Vector&lt;FloatQuad&gt; elementQuads;
1831                 renderer-&gt;absoluteQuads(elementQuads);
1832                 if (space == CoordinateSpace::Client)
1833                     node-&gt;document().convertAbsoluteToClientQuads(elementQuads, renderer-&gt;style());
1834 
1835                 for (auto&amp; quad : elementQuads)
1836                     rects.append(quad.boundingBox());
1837             }
1838         } else if (is&lt;Text&gt;(*node)) {
1839             if (auto* renderer = downcast&lt;Text&gt;(*node).renderer()) {
1840                 bool isFixed;
1841                 auto clippedRects = absoluteRectsForRangeInText(node, *renderer, false, isFixed, rectOptions);
1842                 if (space == CoordinateSpace::Client)
1843                     node-&gt;document().convertAbsoluteToClientRects(clippedRects, renderer-&gt;style());
1844 
1845                 rects.appendVector(clippedRects);
1846             }
1847         }
1848     }
1849 
1850     if (rectOptions.contains(BoundingRectBehavior::IgnoreTinyRects)) {
1851         rects.removeAllMatching([&amp;] (const FloatRect&amp; rect) -&gt; bool {
1852             return rect.area() &lt;= 1;
1853         });
1854     }
1855 
1856     return rects;
1857 }
1858 
1859 FloatRect Range::boundingRect(CoordinateSpace space, OptionSet&lt;BoundingRectBehavior&gt; rectOptions) const
1860 {
1861     FloatRect result;
1862     for (auto&amp; rect : borderAndTextRects(space, rectOptions))
1863         result.uniteIfNonZero(rect);
1864     return result;
1865 }
1866 
1867 FloatRect Range::absoluteBoundingRect(OptionSet&lt;BoundingRectBehavior&gt; rectOptions) const
1868 {
1869     return boundingRect(CoordinateSpace::Absolute, rectOptions);
1870 }
1871 
1872 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp; ts, const RangeBoundaryPoint&amp; r)
1873 {
1874     return ts &lt;&lt; r.toPosition();
1875 }
1876 
1877 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp; ts, const Range&amp; r)
1878 {
1879     return ts &lt;&lt; &quot;Range: &quot; &lt;&lt; &quot;start: &quot; &lt;&lt; r.startPosition() &lt;&lt; &quot; end: &quot; &lt;&lt; r.endPosition();
1880 }
1881 
1882 } // namespace WebCore
1883 
1884 #if ENABLE(TREE_DEBUGGING)
1885 
1886 void showTree(const WebCore::Range* range)
1887 {
1888     if (range &amp;&amp; range-&gt;boundaryPointsValid()) {
1889         range-&gt;startContainer().showTreeAndMark(&amp;range-&gt;startContainer(), &quot;S&quot;, &amp;range-&gt;endContainer(), &quot;E&quot;);
1890         fprintf(stderr, &quot;start offset: %d, end offset: %d\n&quot;, range-&gt;startOffset(), range-&gt;endOffset());
1891     }
1892 }
1893 
1894 #endif
    </pre>
  </body>
</html>