<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/Node.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
   5  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
   6  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
   7  * Copyright (C) 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Library General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public License
  20  * along with this library; see the file COPYING.LIB.  If not, write to
  21  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;Node.h&quot;
  27 
  28 #include &quot;AXObjectCache.h&quot;
  29 #include &quot;Attr.h&quot;
  30 #include &quot;BeforeLoadEvent.h&quot;
  31 #include &quot;ChildListMutationScope.h&quot;
  32 #include &quot;CommonVM.h&quot;
  33 #include &quot;ComposedTreeAncestorIterator.h&quot;
  34 #include &quot;ContainerNodeAlgorithms.h&quot;
  35 #if PLATFORM(IOS_FAMILY)
  36 #include &quot;ContentChangeObserver.h&quot;
  37 #endif
  38 #include &quot;ContextMenuController.h&quot;
  39 #include &quot;DOMWindow.h&quot;
  40 #include &quot;DataTransfer.h&quot;
  41 #include &quot;DocumentType.h&quot;
  42 #include &quot;ElementIterator.h&quot;
  43 #include &quot;ElementRareData.h&quot;
  44 #include &quot;ElementTraversal.h&quot;
  45 #include &quot;EventDispatcher.h&quot;
  46 #include &quot;EventHandler.h&quot;
  47 #include &quot;FrameView.h&quot;
  48 #include &quot;HTMLAreaElement.h&quot;
  49 #include &quot;HTMLBodyElement.h&quot;
  50 #include &quot;HTMLCollection.h&quot;
  51 #include &quot;HTMLElement.h&quot;
  52 #include &quot;HTMLImageElement.h&quot;
  53 #include &quot;HTMLSlotElement.h&quot;
  54 #include &quot;HTMLStyleElement.h&quot;
  55 #include &quot;InputEvent.h&quot;
  56 #include &quot;InspectorController.h&quot;
  57 #include &quot;KeyboardEvent.h&quot;
  58 #include &quot;Logging.h&quot;
  59 #include &quot;MutationEvent.h&quot;
  60 #include &quot;NodeRenderStyle.h&quot;
  61 #include &quot;ProcessingInstruction.h&quot;
  62 #include &quot;ProgressEvent.h&quot;
  63 #include &quot;Range.h&quot;
  64 #include &quot;RenderBlock.h&quot;
  65 #include &quot;RenderBox.h&quot;
  66 #include &quot;RenderTextControl.h&quot;
  67 #include &quot;RenderView.h&quot;
  68 #include &quot;SVGElement.h&quot;
  69 #include &quot;ScopedEventQueue.h&quot;
  70 #include &quot;ScriptDisallowedScope.h&quot;
  71 #include &quot;StorageEvent.h&quot;
  72 #include &quot;StyleResolver.h&quot;
  73 #include &quot;StyleSheetContents.h&quot;
  74 #include &quot;TemplateContentDocumentFragment.h&quot;
  75 #include &quot;TextEvent.h&quot;
  76 #include &quot;TouchEvent.h&quot;
  77 #include &quot;WheelEvent.h&quot;
  78 #include &quot;XMLNSNames.h&quot;
  79 #include &quot;XMLNames.h&quot;
  80 #include &lt;JavaScriptCore/HeapInlines.h&gt;
  81 #include &lt;wtf/IsoMallocInlines.h&gt;
  82 #include &lt;wtf/RefCountedLeakCounter.h&gt;
  83 #include &lt;wtf/SHA1.h&gt;
  84 #include &lt;wtf/Variant.h&gt;
  85 #include &lt;wtf/text/CString.h&gt;
  86 #include &lt;wtf/text/StringBuilder.h&gt;
  87 
  88 namespace WebCore {
  89 
  90 WTF_MAKE_ISO_ALLOCATED_IMPL(Node);
  91 
  92 using namespace HTMLNames;
  93 
  94 #if DUMP_NODE_STATISTICS
  95 static HashSet&lt;Node*&gt;&amp; liveNodeSet()
  96 {
  97     static NeverDestroyed&lt;HashSet&lt;Node*&gt;&gt; liveNodes;
  98     return liveNodes;
  99 }
 100 
 101 static const char* stringForRareDataUseType(NodeRareData::UseType useType)
 102 {
 103     switch (useType) {
 104     case NodeRareData::UseType::ConnectedFrameCount:
 105         return &quot;ConnectedFrameCount&quot;;
 106     case NodeRareData::UseType::NodeList:
 107         return &quot;NodeList&quot;;
 108     case NodeRareData::UseType::MutationObserver:
 109         return &quot;MutationObserver&quot;;
 110     case NodeRareData::UseType::TabIndex:
 111         return &quot;TabIndex&quot;;
 112     case NodeRareData::UseType::MinimumSize:
 113         return &quot;MinimumSize&quot;;
 114     case NodeRareData::UseType::ScrollingPosition:
 115         return &quot;ScrollingPosition&quot;;
 116     case NodeRareData::UseType::ComputedStyle:
 117         return &quot;ComputedStyle&quot;;
 118     case NodeRareData::UseType::Dataset:
 119         return &quot;Dataset&quot;;
 120     case NodeRareData::UseType::ClassList:
 121         return &quot;ClassList&quot;;
 122     case NodeRareData::UseType::ShadowRoot:
 123         return &quot;ShadowRoot&quot;;
 124     case NodeRareData::UseType::CustomElementQueue:
 125         return &quot;CustomElementQueue&quot;;
 126     case NodeRareData::UseType::AttributeMap:
 127         return &quot;AttributeMap&quot;;
 128     case NodeRareData::UseType::InteractionObserver:
 129         return &quot;InteractionObserver&quot;;
 130     case NodeRareData::UseType::PseudoElements:
 131         return &quot;PseudoElements&quot;;
 132     }
 133     return nullptr;
 134 }
 135 
 136 #endif
 137 
 138 void Node::dumpStatistics()
 139 {
 140 #if DUMP_NODE_STATISTICS
 141     size_t nodesWithRareData = 0;
 142 
 143     size_t elementNodes = 0;
 144     size_t attrNodes = 0;
 145     size_t textNodes = 0;
 146     size_t cdataNodes = 0;
 147     size_t commentNodes = 0;
 148     size_t piNodes = 0;
 149     size_t documentNodes = 0;
 150     size_t docTypeNodes = 0;
 151     size_t fragmentNodes = 0;
 152     size_t shadowRootNodes = 0;
 153 
 154     HashMap&lt;String, size_t&gt; perTagCount;
 155 
 156     size_t attributes = 0;
 157     size_t attributesWithAttr = 0;
 158     size_t elementsWithAttributeStorage = 0;
 159     size_t elementsWithRareData = 0;
 160     size_t elementsWithNamedNodeMap = 0;
 161 
 162     HashMap&lt;uint16_t, size_t&gt; rareDataSingleUseTypeCounts;
 163     size_t mixedRareDataUseCount = 0;
 164 
 165     for (auto* node : liveNodeSet()) {
 166         if (node-&gt;hasRareData()) {
 167             ++nodesWithRareData;
 168             if (is&lt;Element&gt;(*node)) {
 169                 ++elementsWithRareData;
 170                 if (downcast&lt;Element&gt;(*node).hasNamedNodeMap())
 171                     ++elementsWithNamedNodeMap;
 172             }
 173             auto* rareData = node-&gt;rareData();
 174             auto useTypes = is&lt;Element&gt;(node) ? static_cast&lt;ElementRareData*&gt;(rareData)-&gt;useTypes() : rareData-&gt;useTypes();
 175             unsigned useTypeCount = 0;
 176             for (auto type : useTypes) {
 177                 UNUSED_PARAM(type);
 178                 useTypeCount++;
 179             }
 180             if (useTypeCount == 1) {
 181                 auto result = rareDataSingleUseTypeCounts.add(static_cast&lt;uint16_t&gt;(*useTypes.begin()), 0);
 182                 result.iterator-&gt;value++;
 183             } else
 184                 mixedRareDataUseCount++;
 185         }
 186 
 187         switch (node-&gt;nodeType()) {
 188             case ELEMENT_NODE: {
 189                 ++elementNodes;
 190 
 191                 // Tag stats
 192                 Element&amp; element = downcast&lt;Element&gt;(*node);
 193                 HashMap&lt;String, size_t&gt;::AddResult result = perTagCount.add(element.tagName(), 1);
 194                 if (!result.isNewEntry)
 195                     result.iterator-&gt;value++;
 196 
 197                 if (const ElementData* elementData = element.elementData()) {
 198                     unsigned length = elementData-&gt;length();
 199                     attributes += length;
 200                     ++elementsWithAttributeStorage;
 201                     for (unsigned i = 0; i &lt; length; ++i) {
 202                         const Attribute&amp; attr = elementData-&gt;attributeAt(i);
 203                         if (element.attrIfExists(attr.name()))
 204                             ++attributesWithAttr;
 205                     }
 206                 }
 207                 break;
 208             }
 209             case ATTRIBUTE_NODE: {
 210                 ++attrNodes;
 211                 break;
 212             }
 213             case TEXT_NODE: {
 214                 ++textNodes;
 215                 break;
 216             }
 217             case CDATA_SECTION_NODE: {
 218                 ++cdataNodes;
 219                 break;
 220             }
 221             case PROCESSING_INSTRUCTION_NODE: {
 222                 ++piNodes;
 223                 break;
 224             }
 225             case COMMENT_NODE: {
 226                 ++commentNodes;
 227                 break;
 228             }
 229             case DOCUMENT_NODE: {
 230                 ++documentNodes;
 231                 break;
 232             }
 233             case DOCUMENT_TYPE_NODE: {
 234                 ++docTypeNodes;
 235                 break;
 236             }
 237             case DOCUMENT_FRAGMENT_NODE: {
 238                 if (node-&gt;isShadowRoot())
 239                     ++shadowRootNodes;
 240                 else
 241                     ++fragmentNodes;
 242                 break;
 243             }
 244         }
 245     }
 246 
 247     printf(&quot;Number of Nodes: %d\n\n&quot;, liveNodeSet().size());
 248     printf(&quot;Number of Nodes with RareData: %zu\n&quot;, nodesWithRareData);
 249     printf(&quot;  Mixed use: %zu\n&quot;, mixedRareDataUseCount);
 250     for (auto it : rareDataSingleUseTypeCounts)
 251         printf(&quot;  %s: %zu\n&quot;, stringForRareDataUseType(static_cast&lt;NodeRareData::UseType&gt;(it.key)), it.value);
 252     printf(&quot;\n&quot;);
 253 
 254 
 255     printf(&quot;NodeType distribution:\n&quot;);
 256     printf(&quot;  Number of Element nodes: %zu\n&quot;, elementNodes);
 257     printf(&quot;  Number of Attribute nodes: %zu\n&quot;, attrNodes);
 258     printf(&quot;  Number of Text nodes: %zu\n&quot;, textNodes);
 259     printf(&quot;  Number of CDATASection nodes: %zu\n&quot;, cdataNodes);
 260     printf(&quot;  Number of Comment nodes: %zu\n&quot;, commentNodes);
 261     printf(&quot;  Number of ProcessingInstruction nodes: %zu\n&quot;, piNodes);
 262     printf(&quot;  Number of Document nodes: %zu\n&quot;, documentNodes);
 263     printf(&quot;  Number of DocumentType nodes: %zu\n&quot;, docTypeNodes);
 264     printf(&quot;  Number of DocumentFragment nodes: %zu\n&quot;, fragmentNodes);
 265     printf(&quot;  Number of ShadowRoot nodes: %zu\n&quot;, shadowRootNodes);
 266 
 267     printf(&quot;Element tag name distibution:\n&quot;);
 268     for (auto&amp; stringSizePair : perTagCount)
 269         printf(&quot;  Number of &lt;%s&gt; tags: %zu\n&quot;, stringSizePair.key.utf8().data(), stringSizePair.value);
 270 
 271     printf(&quot;Attributes:\n&quot;);
 272     printf(&quot;  Number of Attributes (non-Node and Node): %zu [%zu]\n&quot;, attributes, sizeof(Attribute));
 273     printf(&quot;  Number of Attributes with an Attr: %zu\n&quot;, attributesWithAttr);
 274     printf(&quot;  Number of Elements with attribute storage: %zu [%zu]\n&quot;, elementsWithAttributeStorage, sizeof(ElementData));
 275     printf(&quot;  Number of Elements with RareData: %zu\n&quot;, elementsWithRareData);
 276     printf(&quot;  Number of Elements with NamedNodeMap: %zu [%zu]\n&quot;, elementsWithNamedNodeMap, sizeof(NamedNodeMap));
 277 #endif
 278 }
 279 
 280 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, nodeCounter, (&quot;WebCoreNode&quot;));
 281 
 282 #ifndef NDEBUG
 283 static bool shouldIgnoreLeaks = false;
 284 
 285 static HashSet&lt;Node*&gt;&amp; ignoreSet()
 286 {
 287     static NeverDestroyed&lt;HashSet&lt;Node*&gt;&gt; ignore;
 288 
 289     return ignore;
 290 }
 291 
 292 #endif
 293 
 294 void Node::startIgnoringLeaks()
 295 {
 296 #ifndef NDEBUG
 297     shouldIgnoreLeaks = true;
 298 #endif
 299 }
 300 
 301 void Node::stopIgnoringLeaks()
 302 {
 303 #ifndef NDEBUG
 304     shouldIgnoreLeaks = false;
 305 #endif
 306 }
 307 
 308 void Node::trackForDebugging()
 309 {
 310 #ifndef NDEBUG
 311     if (shouldIgnoreLeaks)
 312         ignoreSet().add(this);
 313     else
 314         nodeCounter.increment();
 315 #endif
 316 
 317 #if DUMP_NODE_STATISTICS
 318     liveNodeSet().add(this);
 319 #endif
 320 }
 321 
 322 Node::Node(Document&amp; document, ConstructionType type)
 323     : m_nodeFlags(type)
 324     , m_treeScope(&amp;document)
 325 {
 326     ASSERT(isMainThread());
 327 
 328     document.incrementReferencingNodeCount();
 329 
 330 #if !defined(NDEBUG) || (defined(DUMP_NODE_STATISTICS) &amp;&amp; DUMP_NODE_STATISTICS)
 331     trackForDebugging();
 332 #endif
 333 }
 334 
 335 Node::~Node()
 336 {
 337     ASSERT(isMainThread());
 338     ASSERT(m_refCountAndParentBit == s_refCountIncrement);
 339     ASSERT(m_deletionHasBegun);
 340     ASSERT(!m_adoptionIsRequired);
 341 
 342 #ifndef NDEBUG
 343     if (!ignoreSet().remove(this))
 344         nodeCounter.decrement();
 345 #endif
 346 
 347 #if DUMP_NODE_STATISTICS
 348     liveNodeSet().remove(this);
 349 #endif
 350 
 351     RELEASE_ASSERT(!renderer());
 352     ASSERT(!parentNode());
 353     ASSERT(!m_previous);
 354     ASSERT(!m_next);
 355 
 356     if (hasRareData())
 357         clearRareData();
 358 
 359     if (!isContainerNode())
 360         willBeDeletedFrom(document());
 361 
 362     if (hasEventTargetData())
 363         clearEventTargetData();
 364 
 365     document().decrementReferencingNodeCount();
 366 
 367 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY) &amp;&amp; (ASSERT_ENABLED || ENABLE(SECURITY_ASSERTIONS))
 368     for (auto* document : Document::allDocuments()) {
 369         ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventListenersContain(*this));
 370         ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventHandlersContain(*this));
 371         ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventTargetsContain(*this));
 372     }
 373 #endif
 374 }
 375 
 376 void Node::willBeDeletedFrom(Document&amp; document)
 377 {
 378     if (hasEventTargetData()) {
 379         document.didRemoveWheelEventHandler(*this, EventHandlerRemoval::All);
 380 #if ENABLE(TOUCH_EVENTS)
 381 #if PLATFORM(IOS_FAMILY)
 382         document.removeTouchEventListener(*this, EventHandlerRemoval::All);
 383 #endif
 384         document.didRemoveTouchEventHandler(*this, EventHandlerRemoval::All);
 385 #endif
 386     }
 387 
 388 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
 389     document.removeTouchEventHandler(*this, EventHandlerRemoval::All);
 390 #endif
 391 
 392     if (auto* cache = document.existingAXObjectCache())
 393         cache-&gt;remove(*this);
 394 }
 395 
 396 void Node::materializeRareData()
 397 {
 398     if (is&lt;Element&gt;(*this))
 399         m_rareData = std::unique_ptr&lt;NodeRareData, NodeRareDataDeleter&gt;(new ElementRareData);
 400     else
 401         m_rareData = std::unique_ptr&lt;NodeRareData, NodeRareDataDeleter&gt;(new NodeRareData);
 402 }
 403 
 404 inline void Node::NodeRareDataDeleter::operator()(NodeRareData* rareData) const
 405 {
 406     if (rareData-&gt;isElementRareData())
 407         delete static_cast&lt;ElementRareData*&gt;(rareData);
 408     else
 409         delete static_cast&lt;NodeRareData*&gt;(rareData);
 410 }
 411 
 412 void Node::clearRareData()
 413 {
 414     ASSERT(hasRareData());
 415     ASSERT(!transientMutationObserverRegistry() || transientMutationObserverRegistry()-&gt;isEmpty());
 416 
 417     m_rareData = nullptr;
 418 }
 419 
 420 bool Node::isNode() const
 421 {
 422     return true;
 423 }
 424 
 425 String Node::nodeValue() const
 426 {
 427     return String();
 428 }
 429 
 430 ExceptionOr&lt;void&gt; Node::setNodeValue(const String&amp;)
 431 {
 432     // By default, setting nodeValue has no effect.
 433     return { };
 434 }
 435 
 436 RefPtr&lt;NodeList&gt; Node::childNodes()
 437 {
 438     if (is&lt;ContainerNode&gt;(*this))
 439         return ensureRareData().ensureNodeLists().ensureChildNodeList(downcast&lt;ContainerNode&gt;(*this));
 440     return ensureRareData().ensureNodeLists().ensureEmptyChildNodeList(*this);
 441 }
 442 
 443 Node *Node::lastDescendant() const
 444 {
 445     Node *n = const_cast&lt;Node *&gt;(this);
 446     while (n &amp;&amp; n-&gt;lastChild())
 447         n = n-&gt;lastChild();
 448     return n;
 449 }
 450 
 451 Node* Node::firstDescendant() const
 452 {
 453     Node *n = const_cast&lt;Node *&gt;(this);
 454     while (n &amp;&amp; n-&gt;firstChild())
 455         n = n-&gt;firstChild();
 456     return n;
 457 }
 458 
 459 Element* Node::previousElementSibling() const
 460 {
 461     return ElementTraversal::previousSibling(*this);
 462 }
 463 
 464 Element* Node::nextElementSibling() const
 465 {
 466     return ElementTraversal::nextSibling(*this);
 467 }
 468 
 469 ExceptionOr&lt;void&gt; Node::insertBefore(Node&amp; newChild, Node* refChild)
 470 {
 471     if (!is&lt;ContainerNode&gt;(*this))
 472         return Exception { HierarchyRequestError };
 473     return downcast&lt;ContainerNode&gt;(*this).insertBefore(newChild, refChild);
 474 }
 475 
 476 ExceptionOr&lt;void&gt; Node::replaceChild(Node&amp; newChild, Node&amp; oldChild)
 477 {
 478     if (!is&lt;ContainerNode&gt;(*this))
 479         return Exception { HierarchyRequestError };
 480     return downcast&lt;ContainerNode&gt;(*this).replaceChild(newChild, oldChild);
 481 }
 482 
 483 ExceptionOr&lt;void&gt; Node::removeChild(Node&amp; oldChild)
 484 {
 485     if (!is&lt;ContainerNode&gt;(*this))
 486         return Exception { NotFoundError };
 487     return downcast&lt;ContainerNode&gt;(*this).removeChild(oldChild);
 488 }
 489 
 490 ExceptionOr&lt;void&gt; Node::appendChild(Node&amp; newChild)
 491 {
 492     if (!is&lt;ContainerNode&gt;(*this))
 493         return Exception { HierarchyRequestError };
 494     return downcast&lt;ContainerNode&gt;(*this).appendChild(newChild);
 495 }
 496 
 497 static HashSet&lt;RefPtr&lt;Node&gt;&gt; nodeSetPreTransformedFromNodeOrStringVector(const Vector&lt;NodeOrString&gt;&amp; vector)
 498 {
 499     HashSet&lt;RefPtr&lt;Node&gt;&gt; nodeSet;
 500     for (const auto&amp; variant : vector) {
 501         WTF::switchOn(variant,
 502             [&amp;] (const RefPtr&lt;Node&gt;&amp; node) { nodeSet.add(const_cast&lt;Node*&gt;(node.get())); },
 503             [] (const String&amp;) { }
 504         );
 505     }
 506     return nodeSet;
 507 }
 508 
 509 static RefPtr&lt;Node&gt; firstPrecedingSiblingNotInNodeSet(Node&amp; context, const HashSet&lt;RefPtr&lt;Node&gt;&gt;&amp; nodeSet)
 510 {
 511     for (auto* sibling = context.previousSibling(); sibling; sibling = sibling-&gt;previousSibling()) {
 512         if (!nodeSet.contains(sibling))
 513             return sibling;
 514     }
 515     return nullptr;
 516 }
 517 
 518 static RefPtr&lt;Node&gt; firstFollowingSiblingNotInNodeSet(Node&amp; context, const HashSet&lt;RefPtr&lt;Node&gt;&gt;&amp; nodeSet)
 519 {
 520     for (auto* sibling = context.nextSibling(); sibling; sibling = sibling-&gt;nextSibling()) {
 521         if (!nodeSet.contains(sibling))
 522             return sibling;
 523     }
 524     return nullptr;
 525 }
 526 
 527 ExceptionOr&lt;RefPtr&lt;Node&gt;&gt; Node::convertNodesOrStringsIntoNode(Vector&lt;NodeOrString&gt;&amp;&amp; nodeOrStringVector)
 528 {
 529     if (nodeOrStringVector.isEmpty())
 530         return nullptr;
 531 
 532     Vector&lt;Ref&lt;Node&gt;&gt; nodes;
 533     nodes.reserveInitialCapacity(nodeOrStringVector.size());
 534     for (auto&amp; variant : nodeOrStringVector) {
 535         WTF::switchOn(variant,
 536             [&amp;](RefPtr&lt;Node&gt;&amp; node) { nodes.uncheckedAppend(*node.get()); },
 537             [&amp;](String&amp; string) { nodes.uncheckedAppend(Text::create(document(), string)); }
 538         );
 539     }
 540 
 541     if (nodes.size() == 1)
 542         return RefPtr&lt;Node&gt; { WTFMove(nodes.first()) };
 543 
 544     auto nodeToReturn = DocumentFragment::create(document());
 545     for (auto&amp; node : nodes) {
 546         auto appendResult = nodeToReturn-&gt;appendChild(node);
 547         if (appendResult.hasException())
 548             return appendResult.releaseException();
 549     }
 550     return RefPtr&lt;Node&gt; { WTFMove(nodeToReturn) };
 551 }
 552 
 553 ExceptionOr&lt;void&gt; Node::before(Vector&lt;NodeOrString&gt;&amp;&amp; nodeOrStringVector)
 554 {
 555     RefPtr&lt;ContainerNode&gt; parent = parentNode();
 556     if (!parent)
 557         return { };
 558 
 559     auto nodeSet = nodeSetPreTransformedFromNodeOrStringVector(nodeOrStringVector);
 560     auto viablePreviousSibling = firstPrecedingSiblingNotInNodeSet(*this, nodeSet);
 561 
 562     auto result = convertNodesOrStringsIntoNode(WTFMove(nodeOrStringVector));
 563     if (result.hasException())
 564         return result.releaseException();
 565     auto node = result.releaseReturnValue();
 566     if (!node)
 567         return { };
 568 
 569     if (viablePreviousSibling)
 570         viablePreviousSibling = viablePreviousSibling-&gt;nextSibling();
 571     else
 572         viablePreviousSibling = parent-&gt;firstChild();
 573 
 574     return parent-&gt;insertBefore(*node, viablePreviousSibling.get());
 575 }
 576 
 577 ExceptionOr&lt;void&gt; Node::after(Vector&lt;NodeOrString&gt;&amp;&amp; nodeOrStringVector)
 578 {
 579     RefPtr&lt;ContainerNode&gt; parent = parentNode();
 580     if (!parent)
 581         return { };
 582 
 583     auto nodeSet = nodeSetPreTransformedFromNodeOrStringVector(nodeOrStringVector);
 584     auto viableNextSibling = firstFollowingSiblingNotInNodeSet(*this, nodeSet);
 585 
 586     auto result = convertNodesOrStringsIntoNode(WTFMove(nodeOrStringVector));
 587     if (result.hasException())
 588         return result.releaseException();
 589     auto node = result.releaseReturnValue();
 590     if (!node)
 591         return { };
 592 
 593     return parent-&gt;insertBefore(*node, viableNextSibling.get());
 594 }
 595 
 596 ExceptionOr&lt;void&gt; Node::replaceWith(Vector&lt;NodeOrString&gt;&amp;&amp; nodeOrStringVector)
 597 {
 598     RefPtr&lt;ContainerNode&gt; parent = parentNode();
 599     if (!parent)
 600         return { };
 601 
 602     auto nodeSet = nodeSetPreTransformedFromNodeOrStringVector(nodeOrStringVector);
 603     auto viableNextSibling = firstFollowingSiblingNotInNodeSet(*this, nodeSet);
 604 
 605     auto result = convertNodesOrStringsIntoNode(WTFMove(nodeOrStringVector));
 606     if (result.hasException())
 607         return result.releaseException();
 608 
 609     if (parentNode() == parent) {
 610         if (auto node = result.releaseReturnValue())
 611             return parent-&gt;replaceChild(*node, *this);
 612         return parent-&gt;removeChild(*this);
 613     }
 614 
 615     if (auto node = result.releaseReturnValue())
 616         return parent-&gt;insertBefore(*node, viableNextSibling.get());
 617     return { };
 618 }
 619 
 620 ExceptionOr&lt;void&gt; Node::remove()
 621 {
 622     auto* parent = parentNode();
 623     if (!parent)
 624         return { };
 625     return parent-&gt;removeChild(*this);
 626 }
 627 
 628 void Node::normalize()
 629 {
 630     // Go through the subtree beneath us, normalizing all nodes. This means that
 631     // any two adjacent text nodes are merged and any empty text nodes are removed.
 632 
 633     RefPtr&lt;Node&gt; node = this;
 634     while (Node* firstChild = node-&gt;firstChild())
 635         node = firstChild;
 636     while (node) {
 637         NodeType type = node-&gt;nodeType();
 638         if (type == ELEMENT_NODE)
 639             downcast&lt;Element&gt;(*node).normalizeAttributes();
 640 
 641         if (node == this)
 642             break;
 643 
 644         if (type != TEXT_NODE) {
 645             node = NodeTraversal::nextPostOrder(*node);
 646             continue;
 647         }
 648 
 649         RefPtr&lt;Text&gt; text = downcast&lt;Text&gt;(node.get());
 650 
 651         // Remove empty text nodes.
 652         if (!text-&gt;length()) {
 653             // Care must be taken to get the next node before removing the current node.
 654             node = NodeTraversal::nextPostOrder(*node);
 655             text-&gt;remove();
 656             continue;
 657         }
 658 
 659         // Merge text nodes.
 660         while (Node* nextSibling = node-&gt;nextSibling()) {
 661             if (nextSibling-&gt;nodeType() != TEXT_NODE)
 662                 break;
 663             Ref&lt;Text&gt; nextText = downcast&lt;Text&gt;(*nextSibling);
 664 
 665             // Remove empty text nodes.
 666             if (!nextText-&gt;length()) {
 667                 nextText-&gt;remove();
 668                 continue;
 669             }
 670 
 671             // Both non-empty text nodes. Merge them.
 672             unsigned offset = text-&gt;length();
 673 
 674             // Update start/end for any affected Ranges before appendData since modifying contents might trigger mutation events that modify ordering.
 675             document().textNodesMerged(nextText, offset);
 676 
 677             // FIXME: DOM spec requires contents to be replaced all at once (see https://dom.spec.whatwg.org/#dom-node-normalize).
 678             // Appending once per sibling may trigger mutation events too many times.
 679             text-&gt;appendData(nextText-&gt;data());
 680             nextText-&gt;remove();
 681         }
 682 
 683         node = NodeTraversal::nextPostOrder(*node);
 684     }
 685 }
 686 
 687 ExceptionOr&lt;Ref&lt;Node&gt;&gt; Node::cloneNodeForBindings(bool deep)
 688 {
 689     if (UNLIKELY(isShadowRoot()))
 690         return Exception { NotSupportedError };
 691     return cloneNode(deep);
 692 }
 693 
 694 const AtomString&amp; Node::prefix() const
 695 {
 696     // For nodes other than elements and attributes, the prefix is always null
 697     return nullAtom();
 698 }
 699 
 700 ExceptionOr&lt;void&gt; Node::setPrefix(const AtomString&amp;)
 701 {
 702     // The spec says that for nodes other than elements and attributes, prefix is always null.
 703     // It does not say what to do when the user tries to set the prefix on another type of
 704     // node, however Mozilla throws a NamespaceError exception.
 705     return Exception { NamespaceError };
 706 }
 707 
 708 const AtomString&amp; Node::localName() const
 709 {
 710     return nullAtom();
 711 }
 712 
 713 const AtomString&amp; Node::namespaceURI() const
 714 {
 715     return nullAtom();
 716 }
 717 
 718 bool Node::isContentEditable()
 719 {
 720     return computeEditability(UserSelectAllDoesNotAffectEditability, ShouldUpdateStyle::Update) != Editability::ReadOnly;
 721 }
 722 
 723 bool Node::isContentRichlyEditable()
 724 {
 725     return computeEditability(UserSelectAllIsAlwaysNonEditable, ShouldUpdateStyle::Update) == Editability::CanEditRichly;
 726 }
 727 
 728 void Node::inspect()
 729 {
 730     if (document().page())
 731         document().page()-&gt;inspectorController().inspect(this);
 732 }
 733 
 734 static Node::Editability computeEditabilityFromComputedStyle(const Node&amp; startNode, Node::UserSelectAllTreatment treatment)
 735 {
 736     // Ideally we&#39;d call ASSERT(!needsStyleRecalc()) here, but
 737     // ContainerNode::setFocus() calls invalidateStyleForSubtree(), so the assertion
 738     // would fire in the middle of Document::setFocusedElement().
 739 
 740     for (const Node* node = &amp;startNode; node; node = node-&gt;parentNode()) {
 741         auto* style = node-&gt;isDocumentNode() ? node-&gt;renderStyle() : const_cast&lt;Node*&gt;(node)-&gt;computedStyle();
 742         if (!style)
 743             continue;
 744         if (style-&gt;display() == DisplayType::None)
 745             continue;
 746 #if ENABLE(USERSELECT_ALL)
 747         // Elements with user-select: all style are considered atomic
 748         // therefore non editable.
 749         if (treatment == Node::UserSelectAllIsAlwaysNonEditable &amp;&amp; style-&gt;userSelect() == UserSelect::All)
 750             return Node::Editability::ReadOnly;
 751 #else
 752         UNUSED_PARAM(treatment);
 753 #endif
 754         switch (style-&gt;userModify()) {
 755         case UserModify::ReadOnly:
 756             return Node::Editability::ReadOnly;
 757         case UserModify::ReadWrite:
 758             return Node::Editability::CanEditRichly;
 759         case UserModify::ReadWritePlaintextOnly:
 760             return Node::Editability::CanEditPlainText;
 761         }
 762         ASSERT_NOT_REACHED();
 763         return Node::Editability::ReadOnly;
 764     }
 765     return Node::Editability::ReadOnly;
 766 }
 767 
 768 Node::Editability Node::computeEditability(UserSelectAllTreatment treatment, ShouldUpdateStyle shouldUpdateStyle) const
 769 {
 770     if (!document().hasLivingRenderTree() || isPseudoElement())
 771         return Editability::ReadOnly;
 772 
 773     if (isInShadowTree())
 774         return HTMLElement::editabilityFromContentEditableAttr(*this);
 775 
 776     if (document().frame() &amp;&amp; document().frame()-&gt;page() &amp;&amp; document().frame()-&gt;page()-&gt;isEditable())
 777         return Editability::CanEditRichly;
 778 
 779     if (shouldUpdateStyle == ShouldUpdateStyle::Update &amp;&amp; document().needsStyleRecalc()) {
 780         if (!document().usesStyleBasedEditability())
 781             return HTMLElement::editabilityFromContentEditableAttr(*this);
 782         document().updateStyleIfNeeded();
 783     }
 784     return computeEditabilityFromComputedStyle(*this, treatment);
 785 }
 786 
 787 RenderBox* Node::renderBox() const
 788 {
 789     RenderObject* renderer = this-&gt;renderer();
 790     return is&lt;RenderBox&gt;(renderer) ? downcast&lt;RenderBox&gt;(renderer) : nullptr;
 791 }
 792 
 793 RenderBoxModelObject* Node::renderBoxModelObject() const
 794 {
 795     RenderObject* renderer = this-&gt;renderer();
 796     return is&lt;RenderBoxModelObject&gt;(renderer) ? downcast&lt;RenderBoxModelObject&gt;(renderer) : nullptr;
 797 }
 798 
 799 LayoutRect Node::renderRect(bool* isReplaced)
 800 {
 801     RenderObject* hitRenderer = this-&gt;renderer();
 802     if (!hitRenderer &amp;&amp; is&lt;HTMLAreaElement&gt;(*this)) {
 803         auto&amp; area = downcast&lt;HTMLAreaElement&gt;(*this);
 804         if (auto* imageElement = area.imageElement())
 805             hitRenderer = imageElement-&gt;renderer();
 806     }
 807     RenderObject* renderer = hitRenderer;
 808     while (renderer &amp;&amp; !renderer-&gt;isBody() &amp;&amp; !renderer-&gt;isDocumentElementRenderer()) {
 809         if (renderer-&gt;isRenderBlock() || renderer-&gt;isInlineBlockOrInlineTable() || renderer-&gt;isReplaced()) {
 810             *isReplaced = renderer-&gt;isReplaced();
 811             return renderer-&gt;absoluteBoundingBoxRect();
 812         }
 813         renderer = renderer-&gt;parent();
 814     }
 815     return LayoutRect();
 816 }
 817 
 818 void Node::refEventTarget()
 819 {
 820     ref();
 821 }
 822 
 823 void Node::derefEventTarget()
 824 {
 825     deref();
 826 }
 827 
 828 void Node::adjustStyleValidity(Style::Validity validity, Style::InvalidationMode mode)
 829 {
 830     if (validity &gt; styleValidity()) {
 831         m_nodeFlags &amp;= ~StyleValidityMask;
 832         m_nodeFlags |= static_cast&lt;unsigned&gt;(validity) &lt;&lt; StyleValidityShift;
 833     }
 834     if (mode == Style::InvalidationMode::RecompositeLayer)
 835         setFlag(StyleResolutionShouldRecompositeLayerFlag);
 836 }
 837 
 838 inline void Node::updateAncestorsForStyleRecalc()
 839 {
 840     auto composedAncestors = composedTreeAncestors(*this);
 841     auto it = composedAncestors.begin();
 842     auto end = composedAncestors.end();
 843     if (it != end) {
 844         it-&gt;setDirectChildNeedsStyleRecalc();
 845 
 846         for (; it != end; ++it) {
 847             // Iterator skips over shadow roots.
 848             if (auto* shadowRoot = it-&gt;shadowRoot())
 849                 shadowRoot-&gt;setChildNeedsStyleRecalc();
 850             if (it-&gt;childNeedsStyleRecalc())
 851                 break;
 852             it-&gt;setChildNeedsStyleRecalc();
 853         }
 854     }
 855 
 856     auto* documentElement = document().documentElement();
 857     if (!documentElement)
 858         return;
 859     if (!documentElement-&gt;childNeedsStyleRecalc() &amp;&amp; !documentElement-&gt;needsStyleRecalc())
 860         return;
 861     document().setChildNeedsStyleRecalc();
 862     document().scheduleStyleRecalc();
 863 }
 864 
 865 void Node::invalidateStyle(Style::Validity validity, Style::InvalidationMode mode)
 866 {
 867     ASSERT(validity != Style::Validity::Valid);
 868     if (!inRenderedDocument())
 869         return;
 870 
 871     // FIXME: This should eventually be an ASSERT.
 872     if (document().inRenderTreeUpdate())
 873         return;
 874 
 875     // FIXME: Why the second condition?
 876     bool markAncestors = styleValidity() == Style::Validity::Valid || validity == Style::Validity::SubtreeAndRenderersInvalid;
 877 
 878     adjustStyleValidity(validity, mode);
 879 
 880     if (markAncestors)
 881         updateAncestorsForStyleRecalc();
 882 }
 883 
 884 unsigned Node::computeNodeIndex() const
 885 {
 886     unsigned count = 0;
 887     for (Node* sibling = previousSibling(); sibling; sibling = sibling-&gt;previousSibling())
 888         ++count;
 889     return count;
 890 }
 891 
 892 template&lt;unsigned type&gt;
 893 bool shouldInvalidateNodeListCachesForAttr(const unsigned nodeListCounts[], const QualifiedName&amp; attrName)
 894 {
 895     if (nodeListCounts[type] &amp;&amp; shouldInvalidateTypeOnAttributeChange(static_cast&lt;NodeListInvalidationType&gt;(type), attrName))
 896         return true;
 897     return shouldInvalidateNodeListCachesForAttr&lt;type + 1&gt;(nodeListCounts, attrName);
 898 }
 899 
 900 template&lt;&gt;
 901 bool shouldInvalidateNodeListCachesForAttr&lt;numNodeListInvalidationTypes&gt;(const unsigned[], const QualifiedName&amp;)
 902 {
 903     return false;
 904 }
 905 
 906 inline bool Document::shouldInvalidateNodeListAndCollectionCaches() const
 907 {
 908     for (int type = 0; type &lt; numNodeListInvalidationTypes; ++type) {
 909         if (m_nodeListAndCollectionCounts[type])
 910             return true;
 911     }
 912     return false;
 913 }
 914 
 915 inline bool Document::shouldInvalidateNodeListAndCollectionCachesForAttribute(const QualifiedName&amp; attrName) const
 916 {
 917     return shouldInvalidateNodeListCachesForAttr&lt;DoNotInvalidateOnAttributeChanges + 1&gt;(m_nodeListAndCollectionCounts, attrName);
 918 }
 919 
 920 template &lt;typename InvalidationFunction&gt;
 921 void Document::invalidateNodeListAndCollectionCaches(InvalidationFunction invalidate)
 922 {
 923     for (auto* list : copyToVectorSpecialization&lt;Vector&lt;LiveNodeList*, 8&gt;&gt;(m_listsInvalidatedAtDocument))
 924         invalidate(*list);
 925 
 926     for (auto* collection : copyToVectorSpecialization&lt;Vector&lt;HTMLCollection*, 8&gt;&gt;(m_collectionsInvalidatedAtDocument))
 927         invalidate(*collection);
 928 }
 929 
 930 void Node::invalidateNodeListAndCollectionCachesInAncestors()
 931 {
 932     if (hasRareData()) {
 933         if (auto* lists = rareData()-&gt;nodeLists())
 934             lists-&gt;clearChildNodeListCache();
 935     }
 936 
 937     if (!document().shouldInvalidateNodeListAndCollectionCaches())
 938         return;
 939 
 940     document().invalidateNodeListAndCollectionCaches([](auto&amp; list) {
 941         list.invalidateCache();
 942     });
 943 
 944     for (auto* node = this; node; node = node-&gt;parentNode()) {
 945         if (!node-&gt;hasRareData())
 946             continue;
 947 
 948         if (auto* lists = node-&gt;rareData()-&gt;nodeLists())
 949             lists-&gt;invalidateCaches();
 950     }
 951 }
 952 
 953 void Node::invalidateNodeListAndCollectionCachesInAncestorsForAttribute(const QualifiedName&amp; attrName)
 954 {
 955     ASSERT(is&lt;Element&gt;(*this));
 956 
 957     if (!document().shouldInvalidateNodeListAndCollectionCachesForAttribute(attrName))
 958         return;
 959 
 960     document().invalidateNodeListAndCollectionCaches([&amp;attrName](auto&amp; list) {
 961         list.invalidateCacheForAttribute(attrName);
 962     });
 963 
 964     for (auto* node = this; node; node = node-&gt;parentNode()) {
 965         if (!node-&gt;hasRareData())
 966             continue;
 967 
 968         if (auto* lists = node-&gt;rareData()-&gt;nodeLists())
 969             lists-&gt;invalidateCachesForAttribute(attrName);
 970     }
 971 }
 972 
 973 NodeListsNodeData* Node::nodeLists()
 974 {
 975     return hasRareData() ? rareData()-&gt;nodeLists() : nullptr;
 976 }
 977 
 978 void Node::clearNodeLists()
 979 {
 980     rareData()-&gt;clearNodeLists();
 981 }
 982 
 983 ExceptionOr&lt;void&gt; Node::checkSetPrefix(const AtomString&amp; prefix)
 984 {
 985     // Perform error checking as required by spec for setting Node.prefix. Used by
 986     // Element::setPrefix() and Attr::setPrefix()
 987 
 988     if (!prefix.isEmpty() &amp;&amp; !Document::isValidName(prefix))
 989         return Exception { InvalidCharacterError };
 990 
 991     // FIXME: Raise NamespaceError if prefix is malformed per the Namespaces in XML specification.
 992 
 993     auto&amp; namespaceURI = this-&gt;namespaceURI();
 994     if (namespaceURI.isEmpty() &amp;&amp; !prefix.isEmpty())
 995         return Exception { NamespaceError };
 996     if (prefix == xmlAtom() &amp;&amp; namespaceURI != XMLNames::xmlNamespaceURI)
 997         return Exception { NamespaceError };
 998 
 999     // Attribute-specific checks are in Attr::setPrefix().
1000 
1001     return { };
1002 }
1003 
1004 bool Node::isDescendantOf(const Node&amp; other) const
1005 {
1006     // Return true if other is an ancestor of this, otherwise false
1007     if (!other.hasChildNodes() || isConnected() != other.isConnected())
1008         return false;
1009     if (other.isDocumentNode())
1010         return &amp;document() == &amp;other &amp;&amp; !isDocumentNode() &amp;&amp; isConnected();
1011     for (const auto* ancestor = parentNode(); ancestor; ancestor = ancestor-&gt;parentNode()) {
1012         if (ancestor == &amp;other)
1013             return true;
1014     }
1015     return false;
1016 }
1017 
1018 bool Node::isDescendantOrShadowDescendantOf(const Node* other) const
1019 {
1020     // FIXME: This element&#39;s shadow tree&#39;s host could be inside another shadow tree.
1021     // This function doesn&#39;t handle that case correctly. Maybe share code with
1022     // the containsIncludingShadowDOM function?
1023     return other &amp;&amp; (isDescendantOf(*other) || other-&gt;contains(shadowHost()));
1024 }
1025 
1026 bool Node::contains(const Node* node) const
1027 {
1028     return this == node || (node &amp;&amp; node-&gt;isDescendantOf(*this));
1029 }
1030 
1031 bool Node::containsIncludingShadowDOM(const Node* node) const
1032 {
1033     for (; node; node = node-&gt;parentOrShadowHostNode()) {
1034         if (node == this)
1035             return true;
1036     }
1037     return false;
1038 }
1039 
1040 Node* Node::pseudoAwarePreviousSibling() const
1041 {
1042     Element* parentOrHost = is&lt;PseudoElement&gt;(*this) ? downcast&lt;PseudoElement&gt;(*this).hostElement() : parentElement();
1043     if (parentOrHost &amp;&amp; !previousSibling()) {
1044         if (isAfterPseudoElement() &amp;&amp; parentOrHost-&gt;lastChild())
1045             return parentOrHost-&gt;lastChild();
1046         if (!isBeforePseudoElement())
1047             return parentOrHost-&gt;beforePseudoElement();
1048     }
1049     return previousSibling();
1050 }
1051 
1052 Node* Node::pseudoAwareNextSibling() const
1053 {
1054     Element* parentOrHost = is&lt;PseudoElement&gt;(*this) ? downcast&lt;PseudoElement&gt;(*this).hostElement() : parentElement();
1055     if (parentOrHost &amp;&amp; !nextSibling()) {
1056         if (isBeforePseudoElement() &amp;&amp; parentOrHost-&gt;firstChild())
1057             return parentOrHost-&gt;firstChild();
1058         if (!isAfterPseudoElement())
1059             return parentOrHost-&gt;afterPseudoElement();
1060     }
1061     return nextSibling();
1062 }
1063 
1064 Node* Node::pseudoAwareFirstChild() const
1065 {
1066     if (is&lt;Element&gt;(*this)) {
1067         const Element&amp; currentElement = downcast&lt;Element&gt;(*this);
1068         Node* first = currentElement.beforePseudoElement();
1069         if (first)
1070             return first;
1071         first = currentElement.firstChild();
1072         if (!first)
1073             first = currentElement.afterPseudoElement();
1074         return first;
1075     }
1076     return firstChild();
1077 }
1078 
1079 Node* Node::pseudoAwareLastChild() const
1080 {
1081     if (is&lt;Element&gt;(*this)) {
1082         const Element&amp; currentElement = downcast&lt;Element&gt;(*this);
1083         Node* last = currentElement.afterPseudoElement();
1084         if (last)
1085             return last;
1086         last = currentElement.lastChild();
1087         if (!last)
1088             last = currentElement.beforePseudoElement();
1089         return last;
1090     }
1091     return lastChild();
1092 }
1093 
1094 const RenderStyle* Node::computedStyle(PseudoId pseudoElementSpecifier)
1095 {
1096     auto* composedParent = composedTreeAncestors(*this).first();
1097     if (!composedParent)
1098         return nullptr;
1099     return composedParent-&gt;computedStyle(pseudoElementSpecifier);
1100 }
1101 
1102 int Node::maxCharacterOffset() const
1103 {
1104     ASSERT_NOT_REACHED();
1105     return 0;
1106 }
1107 
1108 // FIXME: Shouldn&#39;t these functions be in the editing code?  Code that asks questions about HTML in the core DOM class
1109 // is obviously misplaced.
1110 bool Node::canStartSelection() const
1111 {
1112     if (hasEditableStyle())
1113         return true;
1114 
1115     if (renderer()) {
1116         const RenderStyle&amp; style = renderer()-&gt;style();
1117         // We allow selections to begin within an element that has -webkit-user-select: none set,
1118         // but if the element is draggable then dragging should take priority over selection.
1119         if (style.userDrag() == UserDrag::Element &amp;&amp; style.userSelect() == UserSelect::None)
1120             return false;
1121     }
1122     return parentOrShadowHostNode() ? parentOrShadowHostNode()-&gt;canStartSelection() : true;
1123 }
1124 
1125 Element* Node::shadowHost() const
1126 {
1127     if (ShadowRoot* root = containingShadowRoot())
1128         return root-&gt;host();
1129     return nullptr;
1130 }
1131 
1132 ShadowRoot* Node::containingShadowRoot() const
1133 {
1134     ContainerNode&amp; root = treeScope().rootNode();
1135     return is&lt;ShadowRoot&gt;(root) ? downcast&lt;ShadowRoot&gt;(&amp;root) : nullptr;
1136 }
1137 
1138 #if ASSERT_ENABLED
1139 // https://dom.spec.whatwg.org/#concept-closed-shadow-hidden
1140 static bool isClosedShadowHiddenUsingSpecDefinition(const Node&amp; A, const Node&amp; B)
1141 {
1142     return A.isInShadowTree()
1143         &amp;&amp; !A.rootNode().containsIncludingShadowDOM(&amp;B)
1144         &amp;&amp; (A.containingShadowRoot()-&gt;mode() != ShadowRootMode::Open || isClosedShadowHiddenUsingSpecDefinition(*A.shadowHost(), B));
1145 }
1146 #endif
1147 
1148 // http://w3c.github.io/webcomponents/spec/shadow/#dfn-unclosed-node
1149 bool Node::isClosedShadowHidden(const Node&amp; otherNode) const
1150 {
1151     // Use Vector instead of HashSet since we expect the number of ancestor tree scopes to be small.
1152     Vector&lt;TreeScope*, 8&gt; ancestorScopesOfThisNode;
1153 
1154     for (auto* scope = &amp;treeScope(); scope; scope = scope-&gt;parentTreeScope())
1155         ancestorScopesOfThisNode.append(scope);
1156 
1157     for (auto* treeScopeThatCanAccessOtherNode = &amp;otherNode.treeScope(); treeScopeThatCanAccessOtherNode; treeScopeThatCanAccessOtherNode = treeScopeThatCanAccessOtherNode-&gt;parentTreeScope()) {
1158         for (auto* scope : ancestorScopesOfThisNode) {
1159             if (scope == treeScopeThatCanAccessOtherNode) {
1160                 ASSERT(!isClosedShadowHiddenUsingSpecDefinition(otherNode, *this));
1161                 return false; // treeScopeThatCanAccessOtherNode is a shadow-including inclusive ancestor of this node.
1162             }
1163         }
1164         auto&amp; root = treeScopeThatCanAccessOtherNode-&gt;rootNode();
1165         if (is&lt;ShadowRoot&gt;(root) &amp;&amp; downcast&lt;ShadowRoot&gt;(root).mode() != ShadowRootMode::Open)
1166             break;
1167     }
1168 
1169     ASSERT(isClosedShadowHiddenUsingSpecDefinition(otherNode, *this));
1170     return true;
1171 }
1172 
1173 static inline ShadowRoot* parentShadowRoot(const Node&amp; node)
1174 {
1175     if (auto* parent = node.parentElement())
1176         return parent-&gt;shadowRoot();
1177     return nullptr;
1178 }
1179 
1180 HTMLSlotElement* Node::assignedSlot() const
1181 {
1182     if (auto* shadowRoot = parentShadowRoot(*this))
1183         return shadowRoot-&gt;findAssignedSlot(*this);
1184     return nullptr;
1185 }
1186 
1187 HTMLSlotElement* Node::assignedSlotForBindings() const
1188 {
1189     auto* shadowRoot = parentShadowRoot(*this);
1190     if (shadowRoot &amp;&amp; shadowRoot-&gt;mode() == ShadowRootMode::Open)
1191         return shadowRoot-&gt;findAssignedSlot(*this);
1192     return nullptr;
1193 }
1194 
1195 ContainerNode* Node::parentInComposedTree() const
1196 {
1197     ASSERT(isMainThreadOrGCThread());
1198     if (auto* slot = assignedSlot())
1199         return slot;
1200     if (is&lt;ShadowRoot&gt;(*this))
1201         return downcast&lt;ShadowRoot&gt;(*this).host();
1202     return parentNode();
1203 }
1204 
1205 Element* Node::parentElementInComposedTree() const
1206 {
1207     if (auto* slot = assignedSlot())
1208         return slot;
1209     if (is&lt;PseudoElement&gt;(*this))
1210         return downcast&lt;PseudoElement&gt;(*this).hostElement();
1211     if (auto* parent = parentNode()) {
1212         if (is&lt;ShadowRoot&gt;(*parent))
1213             return downcast&lt;ShadowRoot&gt;(*parent).host();
1214         if (is&lt;Element&gt;(*parent))
1215             return downcast&lt;Element&gt;(parent);
1216     }
1217     return nullptr;
1218 }
1219 
1220 bool Node::isInUserAgentShadowTree() const
1221 {
1222     auto* shadowRoot = containingShadowRoot();
1223     return shadowRoot &amp;&amp; shadowRoot-&gt;mode() == ShadowRootMode::UserAgent;
1224 }
1225 
1226 Node* Node::nonBoundaryShadowTreeRootNode()
1227 {
1228     ASSERT(!isShadowRoot());
1229     Node* root = this;
1230     while (root) {
1231         if (root-&gt;isShadowRoot())
1232             return root;
1233         Node* parent = root-&gt;parentNodeGuaranteedHostFree();
1234         if (parent &amp;&amp; parent-&gt;isShadowRoot())
1235             return root;
1236         root = parent;
1237     }
1238     return 0;
1239 }
1240 
1241 ContainerNode* Node::nonShadowBoundaryParentNode() const
1242 {
1243     ContainerNode* parent = parentNode();
1244     return parent &amp;&amp; !parent-&gt;isShadowRoot() ? parent : nullptr;
1245 }
1246 
1247 Element* Node::parentOrShadowHostElement() const
1248 {
1249     ContainerNode* parent = parentOrShadowHostNode();
1250     if (!parent)
1251         return nullptr;
1252 
1253     if (is&lt;ShadowRoot&gt;(*parent))
1254         return downcast&lt;ShadowRoot&gt;(*parent).host();
1255 
1256     if (!is&lt;Element&gt;(*parent))
1257         return nullptr;
1258 
1259     return downcast&lt;Element&gt;(parent);
1260 }
1261 
1262 Node&amp; Node::traverseToRootNode() const
1263 {
1264     Node* node = const_cast&lt;Node*&gt;(this);
1265     Node* highest = node;
1266     for (; node; node = node-&gt;parentNode())
1267         highest = node;
1268     return *highest;
1269 }
1270 
1271 // https://dom.spec.whatwg.org/#concept-shadow-including-root
1272 Node&amp; Node::shadowIncludingRoot() const
1273 {
1274     auto&amp; root = rootNode();
1275     if (!is&lt;ShadowRoot&gt;(root))
1276         return root;
1277     auto* host = downcast&lt;ShadowRoot&gt;(root).host();
1278     return host ? host-&gt;shadowIncludingRoot() : root;
1279 }
1280 
1281 Node&amp; Node::getRootNode(const GetRootNodeOptions&amp; options) const
1282 {
1283     return options.composed ? shadowIncludingRoot() : rootNode();
1284 }
1285 
1286 Node::InsertedIntoAncestorResult Node::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
1287 {
1288     if (insertionType.connectedToDocument)
1289         setFlag(IsConnectedFlag);
1290     if (parentOfInsertedTree.isInShadowTree())
1291         setFlag(IsInShadowTreeFlag);
1292 
1293     invalidateStyle(Style::Validity::SubtreeAndRenderersInvalid);
1294 
1295     return InsertedIntoAncestorResult::Done;
1296 }
1297 
1298 void Node::removedFromAncestor(RemovalType removalType, ContainerNode&amp;)
1299 {
1300     if (removalType.disconnectedFromDocument)
1301         clearFlag(IsConnectedFlag);
1302     if (isInShadowTree() &amp;&amp; !treeScope().rootNode().isShadowRoot())
1303         clearFlag(IsInShadowTreeFlag);
1304 }
1305 
1306 bool Node::isRootEditableElement() const
1307 {
1308     return hasEditableStyle() &amp;&amp; isElementNode() &amp;&amp; (!parentNode() || !parentNode()-&gt;hasEditableStyle()
1309         || !parentNode()-&gt;isElementNode() || hasTagName(bodyTag));
1310 }
1311 
1312 Element* Node::rootEditableElement() const
1313 {
1314     Element* result = nullptr;
1315     for (Node* node = const_cast&lt;Node*&gt;(this); node &amp;&amp; node-&gt;hasEditableStyle(); node = node-&gt;parentNode()) {
1316         if (is&lt;Element&gt;(*node))
1317             result = downcast&lt;Element&gt;(node);
1318         if (is&lt;HTMLBodyElement&gt;(*node))
1319             break;
1320     }
1321     return result;
1322 }
1323 
1324 // FIXME: End of obviously misplaced HTML editing functions.  Try to move these out of Node.
1325 
1326 Document* Node::ownerDocument() const
1327 {
1328     Document* document = &amp;this-&gt;document();
1329     return document == this ? nullptr : document;
1330 }
1331 
1332 const URL&amp; Node::baseURI() const
1333 {
1334     auto&amp; url = document().baseURL();
1335     return url.isNull() ? WTF::blankURL() : url;
1336 }
1337 
1338 bool Node::isEqualNode(Node* other) const
1339 {
1340     if (!other)
1341         return false;
1342 
1343     NodeType nodeType = this-&gt;nodeType();
1344     if (nodeType != other-&gt;nodeType())
1345         return false;
1346 
1347     switch (nodeType) {
1348     case Node::DOCUMENT_TYPE_NODE: {
1349         auto&amp; thisDocType = downcast&lt;DocumentType&gt;(*this);
1350         auto&amp; otherDocType = downcast&lt;DocumentType&gt;(*other);
1351         if (thisDocType.name() != otherDocType.name())
1352             return false;
1353         if (thisDocType.publicId() != otherDocType.publicId())
1354             return false;
1355         if (thisDocType.systemId() != otherDocType.systemId())
1356             return false;
1357         break;
1358         }
1359     case Node::ELEMENT_NODE: {
1360         auto&amp; thisElement = downcast&lt;Element&gt;(*this);
1361         auto&amp; otherElement = downcast&lt;Element&gt;(*other);
1362         if (thisElement.tagQName() != otherElement.tagQName())
1363             return false;
1364         if (!thisElement.hasEquivalentAttributes(otherElement))
1365             return false;
1366         break;
1367         }
1368     case Node::PROCESSING_INSTRUCTION_NODE: {
1369         auto&amp; thisProcessingInstruction = downcast&lt;ProcessingInstruction&gt;(*this);
1370         auto&amp; otherProcessingInstruction = downcast&lt;ProcessingInstruction&gt;(*other);
1371         if (thisProcessingInstruction.target() != otherProcessingInstruction.target())
1372             return false;
1373         if (thisProcessingInstruction.data() != otherProcessingInstruction.data())
1374             return false;
1375         break;
1376         }
1377     case Node::CDATA_SECTION_NODE:
1378     case Node::TEXT_NODE:
1379     case Node::COMMENT_NODE: {
1380         auto&amp; thisCharacterData = downcast&lt;CharacterData&gt;(*this);
1381         auto&amp; otherCharacterData = downcast&lt;CharacterData&gt;(*other);
1382         if (thisCharacterData.data() != otherCharacterData.data())
1383             return false;
1384         break;
1385         }
1386     case Node::ATTRIBUTE_NODE: {
1387         auto&amp; thisAttribute = downcast&lt;Attr&gt;(*this);
1388         auto&amp; otherAttribute = downcast&lt;Attr&gt;(*other);
1389         if (thisAttribute.qualifiedName() != otherAttribute.qualifiedName())
1390             return false;
1391         if (thisAttribute.value() != otherAttribute.value())
1392             return false;
1393         break;
1394         }
1395     case Node::DOCUMENT_NODE:
1396     case Node::DOCUMENT_FRAGMENT_NODE:
1397         break;
1398     }
1399 
1400     Node* child = firstChild();
1401     Node* otherChild = other-&gt;firstChild();
1402 
1403     while (child) {
1404         if (!child-&gt;isEqualNode(otherChild))
1405             return false;
1406 
1407         child = child-&gt;nextSibling();
1408         otherChild = otherChild-&gt;nextSibling();
1409     }
1410 
1411     if (otherChild)
1412         return false;
1413 
1414     return true;
1415 }
1416 
1417 // https://dom.spec.whatwg.org/#locate-a-namespace
1418 static const AtomString&amp; locateDefaultNamespace(const Node&amp; node, const AtomString&amp; prefix)
1419 {
1420     switch (node.nodeType()) {
1421     case Node::ELEMENT_NODE: {
1422         auto&amp; element = downcast&lt;Element&gt;(node);
1423         auto&amp; namespaceURI = element.namespaceURI();
1424         if (!namespaceURI.isNull() &amp;&amp; element.prefix() == prefix)
1425             return namespaceURI;
1426 
1427         if (element.hasAttributes()) {
1428             for (auto&amp; attribute : element.attributesIterator()) {
1429                 if (attribute.namespaceURI() != XMLNSNames::xmlnsNamespaceURI)
1430                     continue;
1431 
1432                 if ((prefix.isNull() &amp;&amp; attribute.prefix().isNull() &amp;&amp; attribute.localName() == xmlnsAtom()) || (attribute.prefix() == xmlnsAtom() &amp;&amp; attribute.localName() == prefix)) {
1433                     auto&amp; result = attribute.value();
1434                     return result.isEmpty() ? nullAtom() : result;
1435                 }
1436             }
1437         }
1438         auto* parent = node.parentElement();
1439         return parent ? locateDefaultNamespace(*parent, prefix) : nullAtom();
1440     }
1441     case Node::DOCUMENT_NODE:
1442         if (auto* documentElement = downcast&lt;Document&gt;(node).documentElement())
1443             return locateDefaultNamespace(*documentElement, prefix);
1444         return nullAtom();
1445     case Node::DOCUMENT_TYPE_NODE:
1446     case Node::DOCUMENT_FRAGMENT_NODE:
1447         return nullAtom();
1448     case Node::ATTRIBUTE_NODE:
1449         if (auto* ownerElement = downcast&lt;Attr&gt;(node).ownerElement())
1450             return locateDefaultNamespace(*ownerElement, prefix);
1451         return nullAtom();
1452     default:
1453         if (auto* parent = node.parentElement())
1454             return locateDefaultNamespace(*parent, prefix);
1455         return nullAtom();
1456     }
1457 }
1458 
1459 // https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace
1460 bool Node::isDefaultNamespace(const AtomString&amp; potentiallyEmptyNamespace) const
1461 {
1462     const AtomString&amp; namespaceURI = potentiallyEmptyNamespace.isEmpty() ? nullAtom() : potentiallyEmptyNamespace;
1463     return locateDefaultNamespace(*this, nullAtom()) == namespaceURI;
1464 }
1465 
1466 // https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri
1467 const AtomString&amp; Node::lookupNamespaceURI(const AtomString&amp; potentiallyEmptyPrefix) const
1468 {
1469     const AtomString&amp; prefix = potentiallyEmptyPrefix.isEmpty() ? nullAtom() : potentiallyEmptyPrefix;
1470     return locateDefaultNamespace(*this, prefix);
1471 }
1472 
1473 // https://dom.spec.whatwg.org/#locate-a-namespace-prefix
1474 static const AtomString&amp; locateNamespacePrefix(const Element&amp; element, const AtomString&amp; namespaceURI)
1475 {
1476     if (element.namespaceURI() == namespaceURI)
1477         return element.prefix();
1478 
1479     if (element.hasAttributes()) {
1480         for (auto&amp; attribute : element.attributesIterator()) {
1481             if (attribute.prefix() == xmlnsAtom() &amp;&amp; attribute.value() == namespaceURI)
1482                 return attribute.localName();
1483         }
1484     }
1485     auto* parent = element.parentElement();
1486     return parent ? locateNamespacePrefix(*parent, namespaceURI) : nullAtom();
1487 }
1488 
1489 // https://dom.spec.whatwg.org/#dom-node-lookupprefix
1490 const AtomString&amp; Node::lookupPrefix(const AtomString&amp; namespaceURI) const
1491 {
1492     if (namespaceURI.isEmpty())
1493         return nullAtom();
1494 
1495     switch (nodeType()) {
1496     case ELEMENT_NODE:
1497         return locateNamespacePrefix(downcast&lt;Element&gt;(*this), namespaceURI);
1498     case DOCUMENT_NODE:
1499         if (auto* documentElement = downcast&lt;Document&gt;(*this).documentElement())
1500             return locateNamespacePrefix(*documentElement, namespaceURI);
1501         return nullAtom();
1502     case DOCUMENT_FRAGMENT_NODE:
1503     case DOCUMENT_TYPE_NODE:
1504         return nullAtom();
1505     case ATTRIBUTE_NODE:
1506         if (auto* ownerElement = downcast&lt;Attr&gt;(*this).ownerElement())
1507             return locateNamespacePrefix(*ownerElement, namespaceURI);
1508         return nullAtom();
1509     default:
1510         if (auto* parent = parentElement())
1511             return locateNamespacePrefix(*parent, namespaceURI);
1512         return nullAtom();
1513     }
1514 }
1515 
1516 static void appendTextContent(const Node* node, bool convertBRsToNewlines, bool&amp; isNullString, StringBuilder&amp; content)
1517 {
1518     switch (node-&gt;nodeType()) {
1519     case Node::TEXT_NODE:
1520     case Node::CDATA_SECTION_NODE:
1521     case Node::COMMENT_NODE:
1522         isNullString = false;
1523         content.append(downcast&lt;CharacterData&gt;(*node).data());
1524         break;
1525 
1526     case Node::PROCESSING_INSTRUCTION_NODE:
1527         isNullString = false;
1528         content.append(downcast&lt;ProcessingInstruction&gt;(*node).data());
1529         break;
1530 
1531     case Node::ATTRIBUTE_NODE:
1532         isNullString = false;
1533         content.append(downcast&lt;Attr&gt;(*node).value());
1534         break;
1535 
1536     case Node::ELEMENT_NODE:
1537         if (node-&gt;hasTagName(brTag) &amp;&amp; convertBRsToNewlines) {
1538             isNullString = false;
1539             content.append(&#39;\n&#39;);
1540             break;
1541         }
1542         FALLTHROUGH;
1543     case Node::DOCUMENT_FRAGMENT_NODE:
1544         isNullString = false;
1545         for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling()) {
1546             if (child-&gt;nodeType() == Node::COMMENT_NODE || child-&gt;nodeType() == Node::PROCESSING_INSTRUCTION_NODE)
1547                 continue;
1548             appendTextContent(child, convertBRsToNewlines, isNullString, content);
1549         }
1550         break;
1551 
1552     case Node::DOCUMENT_NODE:
1553     case Node::DOCUMENT_TYPE_NODE:
1554         break;
1555     }
1556 }
1557 
1558 String Node::textContent(bool convertBRsToNewlines) const
1559 {
1560     StringBuilder content;
1561     bool isNullString = true;
1562     appendTextContent(this, convertBRsToNewlines, isNullString, content);
1563     return isNullString ? String() : content.toString();
1564 }
1565 
1566 ExceptionOr&lt;void&gt; Node::setTextContent(const String&amp; text)
1567 {
1568     switch (nodeType()) {
1569     case ATTRIBUTE_NODE:
1570     case TEXT_NODE:
1571     case CDATA_SECTION_NODE:
1572     case COMMENT_NODE:
1573     case PROCESSING_INSTRUCTION_NODE:
1574         return setNodeValue(text);
1575     case ELEMENT_NODE:
1576     case DOCUMENT_FRAGMENT_NODE: {
1577         auto&amp; container = downcast&lt;ContainerNode&gt;(*this);
1578         if (text.isEmpty())
1579             container.replaceAllChildren(nullptr);
1580         else
1581             container.replaceAllChildren(document().createTextNode(text));
1582         return { };
1583     }
1584     case DOCUMENT_NODE:
1585     case DOCUMENT_TYPE_NODE:
1586         // Do nothing.
1587         return { };
1588     }
1589     ASSERT_NOT_REACHED();
1590     return { };
1591 }
1592 
1593 static SHA1::Digest hashPointer(void* pointer)
1594 {
1595     SHA1 sha1;
1596     sha1.addBytes(reinterpret_cast&lt;const uint8_t*&gt;(&amp;pointer), sizeof(pointer));
1597     SHA1::Digest digest;
1598     sha1.computeHash(digest);
1599     return digest;
1600 }
1601 
1602 static inline unsigned short compareDetachedElementsPosition(Node&amp; firstNode, Node&amp; secondNode)
1603 {
1604     // If the 2 nodes are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,
1605     // DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or
1606     // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent. Whether to return
1607     // DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING is implemented by comparing cryptographic
1608     // hashes of Node pointers.
1609     // See step 3 in https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
1610     SHA1::Digest firstHash = hashPointer(&amp;firstNode);
1611     SHA1::Digest secondHash = hashPointer(&amp;secondNode);
1612 
1613     unsigned short direction = memcmp(firstHash.data(), secondHash.data(), SHA1::hashSize) &gt; 0 ? Node::DOCUMENT_POSITION_PRECEDING : Node::DOCUMENT_POSITION_FOLLOWING;
1614 
1615     return Node::DOCUMENT_POSITION_DISCONNECTED | Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | direction;
1616 }
1617 
1618 bool areNodesConnectedInSameTreeScope(const Node* a, const Node* b)
1619 {
1620     if (!a || !b)
1621         return false;
1622     // Note that we avoid comparing Attr nodes here, since they return false from isConnected() all the time (which seems like a bug).
1623     return a-&gt;isConnected() == b-&gt;isConnected() &amp;&amp; &amp;a-&gt;treeScope() == &amp;b-&gt;treeScope();
1624 }
1625 
1626 unsigned short Node::compareDocumentPosition(Node&amp; otherNode)
1627 {
1628     if (&amp;otherNode == this)
1629         return DOCUMENT_POSITION_EQUIVALENT;
1630 
1631     Attr* attr1 = is&lt;Attr&gt;(*this) ? downcast&lt;Attr&gt;(this) : nullptr;
1632     Attr* attr2 = is&lt;Attr&gt;(otherNode) ? &amp;downcast&lt;Attr&gt;(otherNode) : nullptr;
1633 
1634     Node* start1 = attr1 ? attr1-&gt;ownerElement() : this;
1635     Node* start2 = attr2 ? attr2-&gt;ownerElement() : &amp;otherNode;
1636 
1637     // If either of start1 or start2 is null, then we are disconnected, since one of the nodes is
1638     // an orphaned attribute node.
1639     if (!start1 || !start2)
1640         return compareDetachedElementsPosition(*this, otherNode);
1641 
1642     Vector&lt;Node*, 16&gt; chain1;
1643     Vector&lt;Node*, 16&gt; chain2;
1644     if (attr1)
1645         chain1.append(attr1);
1646     if (attr2)
1647         chain2.append(attr2);
1648 
1649     if (attr1 &amp;&amp; attr2 &amp;&amp; start1 == start2 &amp;&amp; start1) {
1650         // We are comparing two attributes on the same node. Crawl our attribute map and see which one we hit first.
1651         Element* owner1 = attr1-&gt;ownerElement();
1652         owner1-&gt;synchronizeAllAttributes();
1653         for (const Attribute&amp; attribute : owner1-&gt;attributesIterator()) {
1654             // If neither of the two determining nodes is a child node and nodeType is the same for both determining nodes, then an
1655             // implementation-dependent order between the determining nodes is returned. This order is stable as long as no nodes of
1656             // the same nodeType are inserted into or removed from the direct container. This would be the case, for example,
1657             // when comparing two attributes of the same element, and inserting or removing additional attributes might change
1658             // the order between existing attributes.
1659             if (attr1-&gt;qualifiedName() == attribute.name())
1660                 return DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | DOCUMENT_POSITION_FOLLOWING;
1661             if (attr2-&gt;qualifiedName() == attribute.name())
1662                 return DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | DOCUMENT_POSITION_PRECEDING;
1663         }
1664 
1665         ASSERT_NOT_REACHED();
1666         return DOCUMENT_POSITION_DISCONNECTED;
1667     }
1668 
1669     // If one node is in the document and the other is not, we must be disconnected.
1670     // If the nodes have different owning documents, they must be disconnected.
1671     if (!areNodesConnectedInSameTreeScope(start1, start2))
1672         return compareDetachedElementsPosition(*this, otherNode);
1673 
1674     // We need to find a common ancestor container, and then compare the indices of the two immediate children.
1675     Node* current;
1676     for (current = start1; current; current = current-&gt;parentNode())
1677         chain1.append(current);
1678     for (current = start2; current; current = current-&gt;parentNode())
1679         chain2.append(current);
1680 
1681     unsigned index1 = chain1.size();
1682     unsigned index2 = chain2.size();
1683 
1684     // If the two elements don&#39;t have a common root, they&#39;re not in the same tree.
1685     if (chain1[index1 - 1] != chain2[index2 - 1])
1686         return compareDetachedElementsPosition(*this, otherNode);
1687 
1688     // Walk the two chains backwards and look for the first difference.
1689     for (unsigned i = std::min(index1, index2); i; --i) {
1690         Node* child1 = chain1[--index1];
1691         Node* child2 = chain2[--index2];
1692         if (child1 != child2) {
1693             // If one of the children is an attribute, it wins.
1694             if (child1-&gt;nodeType() == ATTRIBUTE_NODE)
1695                 return DOCUMENT_POSITION_FOLLOWING;
1696             if (child2-&gt;nodeType() == ATTRIBUTE_NODE)
1697                 return DOCUMENT_POSITION_PRECEDING;
1698 
1699             if (!child2-&gt;nextSibling())
1700                 return DOCUMENT_POSITION_FOLLOWING;
1701             if (!child1-&gt;nextSibling())
1702                 return DOCUMENT_POSITION_PRECEDING;
1703 
1704             // Otherwise we need to see which node occurs first.  Crawl backwards from child2 looking for child1.
1705             for (Node* child = child2-&gt;previousSibling(); child; child = child-&gt;previousSibling()) {
1706                 if (child == child1)
1707                     return DOCUMENT_POSITION_FOLLOWING;
1708             }
1709             return DOCUMENT_POSITION_PRECEDING;
1710         }
1711     }
1712 
1713     // There was no difference between the two parent chains, i.e., one was a subset of the other.  The shorter
1714     // chain is the ancestor.
1715     return index1 &lt; index2 ?
1716                DOCUMENT_POSITION_FOLLOWING | DOCUMENT_POSITION_CONTAINED_BY :
1717                DOCUMENT_POSITION_PRECEDING | DOCUMENT_POSITION_CONTAINS;
1718 }
1719 
1720 FloatPoint Node::convertToPage(const FloatPoint&amp; p) const
1721 {
1722     // If there is a renderer, just ask it to do the conversion
1723     if (renderer())
1724         return renderer()-&gt;localToAbsolute(p, UseTransforms);
1725 
1726     // Otherwise go up the tree looking for a renderer
1727     if (auto* parent = parentElement())
1728         return parent-&gt;convertToPage(p);
1729 
1730     // No parent - no conversion needed
1731     return p;
1732 }
1733 
1734 FloatPoint Node::convertFromPage(const FloatPoint&amp; p) const
1735 {
1736     // If there is a renderer, just ask it to do the conversion
1737     if (renderer())
1738         return renderer()-&gt;absoluteToLocal(p, UseTransforms);
1739 
1740     // Otherwise go up the tree looking for a renderer
1741     if (auto* parent = parentElement())
1742         return parent-&gt;convertFromPage(p);
1743 
1744     // No parent - no conversion needed
1745     return p;
1746 }
1747 
1748 #if ENABLE(TREE_DEBUGGING)
1749 
1750 static void appendAttributeDesc(const Node* node, StringBuilder&amp; stringBuilder, const QualifiedName&amp; name, const char* attrDesc)
1751 {
1752     if (!is&lt;Element&gt;(*node))
1753         return;
1754 
1755     const AtomString&amp; attr = downcast&lt;Element&gt;(*node).getAttribute(name);
1756     if (attr.isEmpty())
1757         return;
1758 
1759     stringBuilder.append(attrDesc);
1760     stringBuilder.append(attr);
1761 }
1762 
1763 void Node::showNode(const char* prefix) const
1764 {
1765     if (!prefix)
1766         prefix = &quot;&quot;;
1767     if (isTextNode()) {
1768         String value = nodeValue();
1769         value.replaceWithLiteral(&#39;\\&#39;, &quot;\\\\&quot;);
1770         value.replaceWithLiteral(&#39;\n&#39;, &quot;\\n&quot;);
1771         fprintf(stderr, &quot;%s%s\t%p \&quot;%s\&quot;\n&quot;, prefix, nodeName().utf8().data(), this, value.utf8().data());
1772     } else {
1773         StringBuilder attrs;
1774         appendAttributeDesc(this, attrs, classAttr, &quot; CLASS=&quot;);
1775         appendAttributeDesc(this, attrs, styleAttr, &quot; STYLE=&quot;);
1776         fprintf(stderr, &quot;%s%s\t%p (renderer %p) %s%s%s\n&quot;, prefix, nodeName().utf8().data(), this, renderer(), attrs.toString().utf8().data(), needsStyleRecalc() ? &quot; (needs style recalc)&quot; : &quot;&quot;, childNeedsStyleRecalc() ? &quot; (child needs style recalc)&quot; : &quot;&quot;);
1777     }
1778 }
1779 
1780 void Node::showTreeForThis() const
1781 {
1782     showTreeAndMark(this, &quot;*&quot;);
1783 }
1784 
1785 void Node::showNodePathForThis() const
1786 {
1787     Vector&lt;const Node*, 16&gt; chain;
1788     const Node* node = this;
1789     while (node-&gt;parentOrShadowHostNode()) {
1790         chain.append(node);
1791         node = node-&gt;parentOrShadowHostNode();
1792     }
1793     for (unsigned index = chain.size(); index &gt; 0; --index) {
1794         const Node* node = chain[index - 1];
1795         if (is&lt;ShadowRoot&gt;(*node)) {
1796             int count = 0;
1797             for (const ShadowRoot* shadowRoot = downcast&lt;ShadowRoot&gt;(node); shadowRoot &amp;&amp; shadowRoot != node; shadowRoot = shadowRoot-&gt;shadowRoot())
1798                 ++count;
1799             fprintf(stderr, &quot;/#shadow-root[%d]&quot;, count);
1800             continue;
1801         }
1802 
1803         switch (node-&gt;nodeType()) {
1804         case ELEMENT_NODE: {
1805             fprintf(stderr, &quot;/%s&quot;, node-&gt;nodeName().utf8().data());
1806 
1807             const Element&amp; element = downcast&lt;Element&gt;(*node);
1808             const AtomString&amp; idattr = element.getIdAttribute();
1809             bool hasIdAttr = !idattr.isNull() &amp;&amp; !idattr.isEmpty();
1810             if (node-&gt;previousSibling() || node-&gt;nextSibling()) {
1811                 int count = 0;
1812                 for (Node* previous = node-&gt;previousSibling(); previous; previous = previous-&gt;previousSibling())
1813                     if (previous-&gt;nodeName() == node-&gt;nodeName())
1814                         ++count;
1815                 if (hasIdAttr)
1816                     fprintf(stderr, &quot;[@id=\&quot;%s\&quot; and position()=%d]&quot;, idattr.string().utf8().data(), count);
1817                 else
1818                     fprintf(stderr, &quot;[%d]&quot;, count);
1819             } else if (hasIdAttr)
1820                 fprintf(stderr, &quot;[@id=\&quot;%s\&quot;]&quot;, idattr.string().utf8().data());
1821             break;
1822         }
1823         case TEXT_NODE:
1824             fprintf(stderr, &quot;/text()&quot;);
1825             break;
1826         case ATTRIBUTE_NODE:
1827             fprintf(stderr, &quot;/@%s&quot;, node-&gt;nodeName().utf8().data());
1828             break;
1829         default:
1830             break;
1831         }
1832     }
1833     fprintf(stderr, &quot;\n&quot;);
1834 }
1835 
1836 static void traverseTreeAndMark(const String&amp; baseIndent, const Node* rootNode, const Node* markedNode1, const char* markedLabel1, const Node* markedNode2, const char* markedLabel2)
1837 {
1838     for (const Node* node = rootNode; node; node = NodeTraversal::next(*node)) {
1839         if (node == markedNode1)
1840             fprintf(stderr, &quot;%s&quot;, markedLabel1);
1841         if (node == markedNode2)
1842             fprintf(stderr, &quot;%s&quot;, markedLabel2);
1843 
1844         StringBuilder indent;
1845         indent.append(baseIndent);
1846         for (const Node* tmpNode = node; tmpNode &amp;&amp; tmpNode != rootNode; tmpNode = tmpNode-&gt;parentOrShadowHostNode())
1847             indent.append(&#39;\t&#39;);
1848         fprintf(stderr, &quot;%s&quot;, indent.toString().utf8().data());
1849         node-&gt;showNode();
1850         indent.append(&#39;\t&#39;);
1851         if (!node-&gt;isShadowRoot()) {
1852             if (ShadowRoot* shadowRoot = node-&gt;shadowRoot())
1853                 traverseTreeAndMark(indent.toString(), shadowRoot, markedNode1, markedLabel1, markedNode2, markedLabel2);
1854         }
1855     }
1856 }
1857 
1858 void Node::showTreeAndMark(const Node* markedNode1, const char* markedLabel1, const Node* markedNode2, const char* markedLabel2) const
1859 {
1860     const Node* rootNode;
1861     const Node* node = this;
1862     while (node-&gt;parentOrShadowHostNode() &amp;&amp; !node-&gt;hasTagName(bodyTag))
1863         node = node-&gt;parentOrShadowHostNode();
1864     rootNode = node;
1865 
1866     String startingIndent;
1867     traverseTreeAndMark(startingIndent, rootNode, markedNode1, markedLabel1, markedNode2, markedLabel2);
1868 }
1869 
1870 void Node::formatForDebugger(char* buffer, unsigned length) const
1871 {
1872     String result;
1873     String s;
1874 
1875     s = nodeName();
1876     if (s.isEmpty())
1877         result = &quot;&lt;none&gt;&quot;;
1878     else
1879         result = s;
1880 
1881     strncpy(buffer, result.utf8().data(), length - 1);
1882 }
1883 
1884 static ContainerNode* parentOrShadowHostOrFrameOwner(const Node* node)
1885 {
1886     ContainerNode* parent = node-&gt;parentOrShadowHostNode();
1887     if (!parent &amp;&amp; node-&gt;document().frame())
1888         parent = node-&gt;document().frame()-&gt;ownerElement();
1889     return parent;
1890 }
1891 
1892 static void showSubTreeAcrossFrame(const Node* node, const Node* markedNode, const String&amp; indent)
1893 {
1894     if (node == markedNode)
1895         fputs(&quot;*&quot;, stderr);
1896     fputs(indent.utf8().data(), stderr);
1897     node-&gt;showNode();
1898     if (!node-&gt;isShadowRoot()) {
1899         if (node-&gt;isFrameOwnerElement())
1900             showSubTreeAcrossFrame(static_cast&lt;const HTMLFrameOwnerElement*&gt;(node)-&gt;contentDocument(), markedNode, indent + &quot;\t&quot;);
1901         if (ShadowRoot* shadowRoot = node-&gt;shadowRoot())
1902             showSubTreeAcrossFrame(shadowRoot, markedNode, indent + &quot;\t&quot;);
1903     }
1904     for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling())
1905         showSubTreeAcrossFrame(child, markedNode, indent + &quot;\t&quot;);
1906 }
1907 
1908 void Node::showTreeForThisAcrossFrame() const
1909 {
1910     Node* rootNode = const_cast&lt;Node*&gt;(this);
1911     while (parentOrShadowHostOrFrameOwner(rootNode))
1912         rootNode = parentOrShadowHostOrFrameOwner(rootNode);
1913     showSubTreeAcrossFrame(rootNode, this, &quot;&quot;);
1914 }
1915 
1916 #endif // ENABLE(TREE_DEBUGGING)
1917 
1918 // --------
1919 
1920 void NodeListsNodeData::invalidateCaches()
1921 {
1922     for (auto&amp; atomName : m_atomNameCaches)
1923         atomName.value-&gt;invalidateCache();
1924 
1925     for (auto&amp; collection : m_cachedCollections)
1926         collection.value-&gt;invalidateCache();
1927 
1928     for (auto&amp; tagCollection : m_tagCollectionNSCache)
1929         tagCollection.value-&gt;invalidateCache();
1930 }
1931 
1932 void NodeListsNodeData::invalidateCachesForAttribute(const QualifiedName&amp; attrName)
1933 {
1934     for (auto&amp; atomName : m_atomNameCaches)
1935         atomName.value-&gt;invalidateCacheForAttribute(attrName);
1936 
1937     for (auto&amp; collection : m_cachedCollections)
1938         collection.value-&gt;invalidateCacheForAttribute(attrName);
1939 }
1940 
1941 void Node::getSubresourceURLs(ListHashSet&lt;URL&gt;&amp; urls) const
1942 {
1943     addSubresourceAttributeURLs(urls);
1944 }
1945 
1946 Element* Node::enclosingLinkEventParentOrSelf()
1947 {
1948     for (Node* node = this; node; node = node-&gt;parentInComposedTree()) {
1949         // For imagemaps, the enclosing link element is the associated area element not the image itself.
1950         // So we don&#39;t let images be the enclosing link element, even though isLink sometimes returns
1951         // true for them.
1952         if (node-&gt;isLink() &amp;&amp; !is&lt;HTMLImageElement&gt;(*node))
1953             return downcast&lt;Element&gt;(node);
1954     }
1955 
1956     return nullptr;
1957 }
1958 
1959 EventTargetInterface Node::eventTargetInterface() const
1960 {
1961     return NodeEventTargetInterfaceType;
1962 }
1963 
1964 template &lt;typename MoveNodeFunction, typename MoveShadowRootFunction&gt;
1965 static void traverseSubtreeToUpdateTreeScope(Node&amp; root, MoveNodeFunction moveNode, MoveShadowRootFunction moveShadowRoot)
1966 {
1967     for (Node* node = &amp;root; node; node = NodeTraversal::next(*node, &amp;root)) {
1968         moveNode(*node);
1969 
1970         if (!is&lt;Element&gt;(*node))
1971             continue;
1972         Element&amp; element = downcast&lt;Element&gt;(*node);
1973 
1974         if (element.hasSyntheticAttrChildNodes()) {
1975             for (auto&amp; attr : element.attrNodeList())
1976                 moveNode(*attr);
1977         }
1978 
1979         if (auto* shadow = element.shadowRoot())
1980             moveShadowRoot(*shadow);
1981     }
1982 }
1983 
1984 inline void Node::moveShadowTreeToNewDocument(ShadowRoot&amp; shadowRoot, Document&amp; oldDocument, Document&amp; newDocument)
1985 {
1986     traverseSubtreeToUpdateTreeScope(shadowRoot, [&amp;oldDocument, &amp;newDocument](Node&amp; node) {
1987         node.moveNodeToNewDocument(oldDocument, newDocument);
1988     }, [&amp;oldDocument, &amp;newDocument](ShadowRoot&amp; innerShadowRoot) {
1989         RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(&amp;innerShadowRoot.document() == &amp;oldDocument);
1990         innerShadowRoot.moveShadowRootToNewDocument(newDocument);
1991         moveShadowTreeToNewDocument(innerShadowRoot, oldDocument, newDocument);
1992     });
1993 }
1994 
1995 void Node::moveTreeToNewScope(Node&amp; root, TreeScope&amp; oldScope, TreeScope&amp; newScope)
1996 {
1997     ASSERT(&amp;oldScope != &amp;newScope);
1998 
1999     Document&amp; oldDocument = oldScope.documentScope();
2000     Document&amp; newDocument = newScope.documentScope();
2001     if (&amp;oldDocument != &amp;newDocument) {
2002         oldDocument.incrementReferencingNodeCount();
2003         traverseSubtreeToUpdateTreeScope(root, [&amp;](Node&amp; node) {
2004             ASSERT(!node.isTreeScope());
2005             RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(&amp;node.treeScope() == &amp;oldScope);
2006             node.setTreeScope(newScope);
2007             node.moveNodeToNewDocument(oldDocument, newDocument);
2008         }, [&amp;](ShadowRoot&amp; shadowRoot) {
2009             ASSERT_WITH_SECURITY_IMPLICATION(&amp;shadowRoot.document() == &amp;oldDocument);
2010             shadowRoot.moveShadowRootToNewParentScope(newScope, newDocument);
2011             moveShadowTreeToNewDocument(shadowRoot, oldDocument, newDocument);
2012         });
2013         RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(&amp;oldScope.documentScope() == &amp;oldDocument &amp;&amp; &amp;newScope.documentScope() == &amp;newDocument);
2014         oldDocument.decrementReferencingNodeCount();
2015     } else {
2016         traverseSubtreeToUpdateTreeScope(root, [&amp;](Node&amp; node) {
2017             ASSERT(!node.isTreeScope());
2018             RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(&amp;node.treeScope() == &amp;oldScope);
2019             node.setTreeScope(newScope);
2020             if (UNLIKELY(!node.hasRareData()))
2021                 return;
2022             if (auto* nodeLists = node.rareData()-&gt;nodeLists())
2023                 nodeLists-&gt;adoptTreeScope();
2024         }, [&amp;newScope](ShadowRoot&amp; shadowRoot) {
2025             shadowRoot.setParentTreeScope(newScope);
2026         });
2027     }
2028 }
2029 
2030 void Node::moveNodeToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
2031 {
2032     newDocument.incrementReferencingNodeCount();
2033     oldDocument.decrementReferencingNodeCount();
2034 
2035     if (hasRareData()) {
2036         if (auto* nodeLists = rareData()-&gt;nodeLists())
2037             nodeLists-&gt;adoptDocument(oldDocument, newDocument);
2038         if (auto* registry = mutationObserverRegistry()) {
2039             for (auto&amp; registration : *registry)
2040                 newDocument.addMutationObserverTypes(registration-&gt;mutationTypes());
2041         }
2042         if (auto* transientRegistry = transientMutationObserverRegistry()) {
2043             for (auto&amp; registration : *transientRegistry)
2044                 newDocument.addMutationObserverTypes(registration-&gt;mutationTypes());
2045         }
2046     } else {
2047         ASSERT(!mutationObserverRegistry());
2048         ASSERT(!transientMutationObserverRegistry());
2049     }
2050 
2051     oldDocument.moveNodeIteratorsToNewDocument(*this, newDocument);
2052 
<a name="1" id="anc1"></a><span class="line-added">2053     if (!parentNode())</span>
<span class="line-added">2054         oldDocument.parentlessNodeMovedToNewDocument(*this);</span>
<span class="line-added">2055 </span>
2056     if (AXObjectCache::accessibilityEnabled()) {
2057         if (auto* cache = oldDocument.existingAXObjectCache())
2058             cache-&gt;remove(*this);
2059     }
2060 
2061     if (auto* eventTargetData = this-&gt;eventTargetData()) {
2062         if (!eventTargetData-&gt;eventListenerMap.isEmpty()) {
2063             for (auto&amp; type : eventTargetData-&gt;eventListenerMap.eventTypes())
2064                 newDocument.addListenerTypeIfNeeded(type);
2065         }
2066 
2067         unsigned numWheelEventHandlers = eventListeners(eventNames().mousewheelEvent).size() + eventListeners(eventNames().wheelEvent).size();
2068         for (unsigned i = 0; i &lt; numWheelEventHandlers; ++i) {
2069             oldDocument.didRemoveWheelEventHandler(*this);
2070             newDocument.didAddWheelEventHandler(*this);
2071         }
2072 
2073         unsigned numTouchEventListeners = 0;
2074 #if ENABLE(TOUCH_EVENTS)
2075         if (newDocument.quirks().shouldDispatchSimulatedMouseEvents()) {
2076             for (auto&amp; name : eventNames().extendedTouchRelatedEventNames())
2077                 numTouchEventListeners += eventListeners(name).size();
2078         } else {
2079 #endif
2080             for (auto&amp; name : eventNames().touchRelatedEventNames())
2081                 numTouchEventListeners += eventListeners(name).size();
2082 #if ENABLE(TOUCH_EVENTS)
2083         }
2084 #endif
2085 
2086         for (unsigned i = 0; i &lt; numTouchEventListeners; ++i) {
2087             oldDocument.didRemoveTouchEventHandler(*this);
2088             newDocument.didAddTouchEventHandler(*this);
2089 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
2090             oldDocument.removeTouchEventListener(*this);
2091             newDocument.addTouchEventListener(*this);
2092 #endif
2093         }
2094 
2095 #if ENABLE(TOUCH_EVENTS) &amp;&amp; ENABLE(IOS_GESTURE_EVENTS)
2096         unsigned numGestureEventListeners = 0;
2097         for (auto&amp; name : eventNames().gestureEventNames())
2098             numGestureEventListeners += eventListeners(name).size();
2099 
2100         for (unsigned i = 0; i &lt; numGestureEventListeners; ++i) {
2101             oldDocument.removeTouchEventHandler(*this);
2102             newDocument.addTouchEventHandler(*this);
2103         }
2104 #endif
2105     }
2106 
2107 #if ASSERT_ENABLED || ENABLE(SECURITY_ASSERTIONS)
2108 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
2109     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventListenersContain(*this));
2110     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventHandlersContain(*this));
2111 #endif
2112 #if ENABLE(TOUCH_EVENTS) &amp;&amp; ENABLE(IOS_GESTURE_EVENTS)
2113     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventTargetsContain(*this));
2114 #endif
2115 #endif
2116 
2117     if (is&lt;Element&gt;(*this))
2118         downcast&lt;Element&gt;(*this).didMoveToNewDocument(oldDocument, newDocument);
2119 }
2120 
2121 static inline bool tryAddEventListener(Node* targetNode, const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const EventTarget::AddEventListenerOptions&amp; options)
2122 {
2123     if (!targetNode-&gt;EventTarget::addEventListener(eventType, listener.copyRef(), options))
2124         return false;
2125 
2126     targetNode-&gt;document().addListenerTypeIfNeeded(eventType);
2127     if (eventNames().isWheelEventType(eventType))
2128         targetNode-&gt;document().didAddWheelEventHandler(*targetNode);
2129     else if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
2130         targetNode-&gt;document().didAddTouchEventHandler(*targetNode);
2131 
2132 #if PLATFORM(IOS_FAMILY)
2133     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent) {
2134         if (auto* window = targetNode-&gt;document().domWindow())
2135             window-&gt;incrementScrollEventListenersCount();
2136     }
2137 
2138 #if ENABLE(TOUCH_EVENTS)
2139     if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
2140         targetNode-&gt;document().addTouchEventListener(*targetNode);
2141 #endif
2142 #endif // PLATFORM(IOS_FAMILY)
2143 
2144 #if ENABLE(IOS_GESTURE_EVENTS) &amp;&amp; ENABLE(TOUCH_EVENTS)
2145     if (eventNames().isGestureEventType(eventType))
2146         targetNode-&gt;document().addTouchEventHandler(*targetNode);
2147 #endif
2148 
2149     return true;
2150 }
2151 
2152 bool Node::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)
2153 {
2154     return tryAddEventListener(this, eventType, WTFMove(listener), options);
2155 }
2156 
2157 static inline bool tryRemoveEventListener(Node* targetNode, const AtomString&amp; eventType, EventListener&amp; listener, const EventTarget::ListenerOptions&amp; options)
2158 {
2159     if (!targetNode-&gt;EventTarget::removeEventListener(eventType, listener, options))
2160         return false;
2161 
2162     // FIXME: Notify Document that the listener has vanished. We need to keep track of a number of
2163     // listeners for each type, not just a bool - see https://bugs.webkit.org/show_bug.cgi?id=33861
2164     if (eventNames().isWheelEventType(eventType))
2165         targetNode-&gt;document().didRemoveWheelEventHandler(*targetNode);
2166     else if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
2167         targetNode-&gt;document().didRemoveTouchEventHandler(*targetNode);
2168 
2169 #if PLATFORM(IOS_FAMILY)
2170     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent) {
2171         if (auto* window = targetNode-&gt;document().domWindow())
2172             window-&gt;decrementScrollEventListenersCount();
2173     }
2174 
2175 #if ENABLE(TOUCH_EVENTS)
2176     if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
2177         targetNode-&gt;document().removeTouchEventListener(*targetNode);
2178 #endif
2179 #endif // PLATFORM(IOS_FAMILY)
2180 
2181 #if ENABLE(IOS_GESTURE_EVENTS) &amp;&amp; ENABLE(TOUCH_EVENTS)
2182     if (eventNames().isGestureEventType(eventType))
2183         targetNode-&gt;document().removeTouchEventHandler(*targetNode);
2184 #endif
2185 
2186     return true;
2187 }
2188 
2189 bool Node::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)
2190 {
2191     return tryRemoveEventListener(this, eventType, listener, options);
2192 }
2193 
2194 typedef HashMap&lt;Node*, std::unique_ptr&lt;EventTargetData&gt;&gt; EventTargetDataMap;
2195 
2196 static EventTargetDataMap&amp; eventTargetDataMap()
2197 {
2198     static NeverDestroyed&lt;EventTargetDataMap&gt; map;
2199 
2200     return map;
2201 }
2202 
2203 static Lock s_eventTargetDataMapLock;
2204 
2205 EventTargetData* Node::eventTargetData()
2206 {
2207     return hasEventTargetData() ? eventTargetDataMap().get(this) : nullptr;
2208 }
2209 
2210 EventTargetData* Node::eventTargetDataConcurrently()
2211 {
2212     // Not holding the lock when the world is stopped accelerates parallel constraint solving, which
2213     // calls this function from many threads. Parallel constraint solving can happen with the world
2214     // running or stopped, but if we do it with a running world, then we&#39;re usually mixing constraint
2215     // solving with other work. Therefore, the most likely time for contention on this lock is when the
2216     // world is stopped. We don&#39;t have to hold the lock when the world is stopped, because a stopped world
2217     // means that we will never mutate the event target data map.
2218     JSC::VM* vm = commonVMOrNull();
2219     auto locker = holdLockIf(s_eventTargetDataMapLock, vm &amp;&amp; vm-&gt;heap.worldIsRunning());
2220     return hasEventTargetData() ? eventTargetDataMap().get(this) : nullptr;
2221 }
2222 
2223 EventTargetData&amp; Node::ensureEventTargetData()
2224 {
2225     if (hasEventTargetData())
2226         return *eventTargetDataMap().get(this);
2227 
2228     JSC::VM* vm = commonVMOrNull();
2229     RELEASE_ASSERT(!vm || vm-&gt;heap.worldIsRunning());
2230 
2231     auto locker = holdLock(s_eventTargetDataMapLock);
2232     setHasEventTargetData(true);
2233     return *eventTargetDataMap().add(this, makeUnique&lt;EventTargetData&gt;()).iterator-&gt;value;
2234 }
2235 
2236 void Node::clearEventTargetData()
2237 {
2238     JSC::VM* vm = commonVMOrNull();
2239     RELEASE_ASSERT(!vm || vm-&gt;heap.worldIsRunning());
2240     auto locker = holdLock(s_eventTargetDataMapLock);
2241     eventTargetDataMap().remove(this);
2242 }
2243 
2244 Vector&lt;std::unique_ptr&lt;MutationObserverRegistration&gt;&gt;* Node::mutationObserverRegistry()
2245 {
2246     if (!hasRareData())
2247         return nullptr;
2248     auto* data = rareData()-&gt;mutationObserverData();
2249     if (!data)
2250         return nullptr;
2251     return &amp;data-&gt;registry;
2252 }
2253 
2254 HashSet&lt;MutationObserverRegistration*&gt;* Node::transientMutationObserverRegistry()
2255 {
2256     if (!hasRareData())
2257         return nullptr;
2258     auto* data = rareData()-&gt;mutationObserverData();
2259     if (!data)
2260         return nullptr;
2261     return &amp;data-&gt;transientRegistry;
2262 }
2263 
2264 template&lt;typename Registry&gt; static inline void collectMatchingObserversForMutation(HashMap&lt;Ref&lt;MutationObserver&gt;, MutationRecordDeliveryOptions&gt;&amp; observers, Registry* registry, Node&amp; target, MutationObserver::MutationType type, const QualifiedName* attributeName)
2265 {
2266     if (!registry)
2267         return;
2268 
2269     for (auto&amp; registration : *registry) {
2270         if (registration-&gt;shouldReceiveMutationFrom(target, type, attributeName)) {
2271             auto deliveryOptions = registration-&gt;deliveryOptions();
2272             auto result = observers.add(registration-&gt;observer(), deliveryOptions);
2273             if (!result.isNewEntry)
2274                 result.iterator-&gt;value |= deliveryOptions;
2275         }
2276     }
2277 }
2278 
2279 HashMap&lt;Ref&lt;MutationObserver&gt;, MutationRecordDeliveryOptions&gt; Node::registeredMutationObservers(MutationObserver::MutationType type, const QualifiedName* attributeName)
2280 {
2281     HashMap&lt;Ref&lt;MutationObserver&gt;, MutationRecordDeliveryOptions&gt; result;
2282     ASSERT((type == MutationObserver::Attributes &amp;&amp; attributeName) || !attributeName);
2283     collectMatchingObserversForMutation(result, mutationObserverRegistry(), *this, type, attributeName);
2284     collectMatchingObserversForMutation(result, transientMutationObserverRegistry(), *this, type, attributeName);
2285     for (Node* node = parentNode(); node; node = node-&gt;parentNode()) {
2286         collectMatchingObserversForMutation(result, node-&gt;mutationObserverRegistry(), *this, type, attributeName);
2287         collectMatchingObserversForMutation(result, node-&gt;transientMutationObserverRegistry(), *this, type, attributeName);
2288     }
2289     return result;
2290 }
2291 
2292 void Node::registerMutationObserver(MutationObserver&amp; observer, MutationObserverOptions options, const HashSet&lt;AtomString&gt;&amp; attributeFilter)
2293 {
2294     MutationObserverRegistration* registration = nullptr;
2295     auto&amp; registry = ensureRareData().ensureMutationObserverData().registry;
2296 
2297     for (auto&amp; candidateRegistration : registry) {
2298         if (&amp;candidateRegistration-&gt;observer() == &amp;observer) {
2299             registration = candidateRegistration.get();
2300             registration-&gt;resetObservation(options, attributeFilter);
2301         }
2302     }
2303 
2304     if (!registration) {
2305         registry.append(makeUnique&lt;MutationObserverRegistration&gt;(observer, *this, options, attributeFilter));
2306         registration = registry.last().get();
2307     }
2308 
2309     document().addMutationObserverTypes(registration-&gt;mutationTypes());
2310 }
2311 
2312 void Node::unregisterMutationObserver(MutationObserverRegistration&amp; registration)
2313 {
2314     auto* registry = mutationObserverRegistry();
2315     ASSERT(registry);
2316     if (!registry)
2317         return;
2318 
2319     registry-&gt;removeFirstMatching([&amp;registration] (auto&amp; current) {
2320         return current.get() == &amp;registration;
2321     });
2322 }
2323 
2324 void Node::registerTransientMutationObserver(MutationObserverRegistration&amp; registration)
2325 {
2326     ensureRareData().ensureMutationObserverData().transientRegistry.add(&amp;registration);
2327 }
2328 
2329 void Node::unregisterTransientMutationObserver(MutationObserverRegistration&amp; registration)
2330 {
2331     auto* transientRegistry = transientMutationObserverRegistry();
2332     ASSERT(transientRegistry);
2333     if (!transientRegistry)
2334         return;
2335 
2336     ASSERT(transientRegistry-&gt;contains(&amp;registration));
2337     transientRegistry-&gt;remove(&amp;registration);
2338 }
2339 
2340 void Node::notifyMutationObserversNodeWillDetach()
2341 {
2342     if (!document().hasMutationObservers())
2343         return;
2344 
2345     for (Node* node = parentNode(); node; node = node-&gt;parentNode()) {
2346         if (auto* registry = node-&gt;mutationObserverRegistry()) {
2347             for (auto&amp; registration : *registry)
2348                 registration-&gt;observedSubtreeNodeWillDetach(*this);
2349         }
2350         if (auto* transientRegistry = node-&gt;transientMutationObserverRegistry()) {
2351             for (auto* registration : *transientRegistry)
2352                 registration-&gt;observedSubtreeNodeWillDetach(*this);
2353         }
2354     }
2355 }
2356 
2357 void Node::handleLocalEvents(Event&amp; event, EventInvokePhase phase)
2358 {
2359     if (!hasEventTargetData())
2360         return;
2361 
2362     // FIXME: Should we deliver wheel events to disabled form controls or not?
2363     if (is&lt;Element&gt;(*this) &amp;&amp; downcast&lt;Element&gt;(*this).isDisabledFormControl() &amp;&amp; event.isMouseEvent() &amp;&amp; !event.isWheelEvent())
2364         return;
2365 
2366     fireEventListeners(event, phase);
2367 }
2368 
2369 void Node::dispatchScopedEvent(Event&amp; event)
2370 {
2371     EventDispatcher::dispatchScopedEvent(*this, event);
2372 }
2373 
2374 void Node::dispatchEvent(Event&amp; event)
2375 {
2376     EventDispatcher::dispatchEvent(*this, event);
2377 }
2378 
2379 void Node::dispatchSubtreeModifiedEvent()
2380 {
2381     if (isInShadowTree())
2382         return;
2383 
2384     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isEventDispatchAllowedInSubtree(*this));
2385 
2386     if (!document().hasListenerType(Document::DOMSUBTREEMODIFIED_LISTENER))
2387         return;
2388     const AtomString&amp; subtreeModifiedEventName = eventNames().DOMSubtreeModifiedEvent;
2389     if (!parentNode() &amp;&amp; !hasEventListeners(subtreeModifiedEventName))
2390         return;
2391 
2392     dispatchScopedEvent(MutationEvent::create(subtreeModifiedEventName, Event::CanBubble::Yes));
2393 }
2394 
2395 void Node::dispatchDOMActivateEvent(Event&amp; underlyingClickEvent)
2396 {
2397     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
2398     int detail = is&lt;UIEvent&gt;(underlyingClickEvent) ? downcast&lt;UIEvent&gt;(underlyingClickEvent).detail() : 0;
2399     auto event = UIEvent::create(eventNames().DOMActivateEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes, Event::IsComposed::Yes, document().windowProxy(), detail);
2400     event-&gt;setUnderlyingEvent(&amp;underlyingClickEvent);
2401     dispatchScopedEvent(event);
2402     if (event-&gt;defaultHandled())
2403         underlyingClickEvent.setDefaultHandled();
2404 }
2405 
2406 bool Node::dispatchBeforeLoadEvent(const String&amp; sourceURL)
2407 {
2408     if (!document().hasListenerType(Document::BEFORELOAD_LISTENER))
2409         return true;
2410 
2411     Ref&lt;Node&gt; protectedThis(*this);
2412     auto event = BeforeLoadEvent::create(sourceURL);
2413     dispatchEvent(event);
2414     return !event-&gt;defaultPrevented();
2415 }
2416 
2417 void Node::dispatchInputEvent()
2418 {
2419     dispatchScopedEvent(Event::create(eventNames().inputEvent, Event::CanBubble::Yes, Event::IsCancelable::No, Event::IsComposed::Yes));
2420 }
2421 
2422 void Node::defaultEventHandler(Event&amp; event)
2423 {
2424     if (event.target() != this)
2425         return;
2426     const AtomString&amp; eventType = event.type();
2427     if (eventType == eventNames().keydownEvent || eventType == eventNames().keypressEvent) {
2428         if (is&lt;KeyboardEvent&gt;(event)) {
2429             if (Frame* frame = document().frame())
2430                 frame-&gt;eventHandler().defaultKeyboardEventHandler(downcast&lt;KeyboardEvent&gt;(event));
2431         }
2432     } else if (eventType == eventNames().clickEvent) {
2433         dispatchDOMActivateEvent(event);
2434 #if ENABLE(CONTEXT_MENUS)
2435     } else if (eventType == eventNames().contextmenuEvent) {
2436         if (Frame* frame = document().frame())
2437             if (Page* page = frame-&gt;page())
2438                 page-&gt;contextMenuController().handleContextMenuEvent(event);
2439 #endif
2440     } else if (eventType == eventNames().textInputEvent) {
2441         if (is&lt;TextEvent&gt;(event)) {
2442             if (Frame* frame = document().frame())
2443                 frame-&gt;eventHandler().defaultTextInputEventHandler(downcast&lt;TextEvent&gt;(event));
2444         }
2445 #if ENABLE(PAN_SCROLLING)
2446     } else if (eventType == eventNames().mousedownEvent &amp;&amp; is&lt;MouseEvent&gt;(event)) {
2447         if (downcast&lt;MouseEvent&gt;(event).button() == MiddleButton) {
2448             if (enclosingLinkEventParentOrSelf())
2449                 return;
2450 
2451             // Avoid that canBeScrolledAndHasScrollableArea changes render tree
2452             // structure.
2453             // FIXME: We should avoid synchronous layout if possible. We can
2454             // remove this synchronous layout if we avoid synchronous layout in
2455             // RenderTextControlSingleLine::scrollHeight
2456             document().updateLayoutIgnorePendingStylesheets();
2457             RenderObject* renderer = this-&gt;renderer();
2458             while (renderer &amp;&amp; (!is&lt;RenderBox&gt;(*renderer) || !downcast&lt;RenderBox&gt;(*renderer).canBeScrolledAndHasScrollableArea()))
2459                 renderer = renderer-&gt;parent();
2460 
2461             if (renderer) {
2462                 if (Frame* frame = document().frame())
2463                     frame-&gt;eventHandler().startPanScrolling(downcast&lt;RenderBox&gt;(*renderer));
2464             }
2465         }
2466 #endif
2467     } else if (eventNames().isWheelEventType(eventType) &amp;&amp; is&lt;WheelEvent&gt;(event)) {
2468         // If we don&#39;t have a renderer, send the wheel event to the first node we find with a renderer.
2469         // This is needed for &lt;option&gt; and &lt;optgroup&gt; elements so that &lt;select&gt;s get a wheel scroll.
2470         Node* startNode = this;
2471         while (startNode &amp;&amp; !startNode-&gt;renderer())
2472             startNode = startNode-&gt;parentOrShadowHostNode();
2473 
2474         if (startNode &amp;&amp; startNode-&gt;renderer())
2475             if (Frame* frame = document().frame())
2476                 frame-&gt;eventHandler().defaultWheelEventHandler(startNode, downcast&lt;WheelEvent&gt;(event));
2477 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
2478     } else if (is&lt;TouchEvent&gt;(event) &amp;&amp; eventNames().isTouchRelatedEventType(document(), eventType)) {
2479         // Capture the target node&#39;s visibility state before dispatching touchStart.
2480         if (is&lt;Element&gt;(*this) &amp;&amp; eventType == eventNames().touchstartEvent) {
2481             auto&amp; contentChangeObserver = document().contentChangeObserver();
2482             if (ContentChangeObserver::isVisuallyHidden(*this))
2483                 contentChangeObserver.setHiddenTouchTarget(downcast&lt;Element&gt;(*this));
2484             else
2485                 contentChangeObserver.resetHiddenTouchTarget();
2486         }
2487 
2488         RenderObject* renderer = this-&gt;renderer();
2489         while (renderer &amp;&amp; (!is&lt;RenderBox&gt;(*renderer) || !downcast&lt;RenderBox&gt;(*renderer).canBeScrolledAndHasScrollableArea()))
2490             renderer = renderer-&gt;parent();
2491 
2492         if (renderer &amp;&amp; renderer-&gt;node()) {
2493             if (Frame* frame = document().frame())
2494                 frame-&gt;eventHandler().defaultTouchEventHandler(*renderer-&gt;node(), downcast&lt;TouchEvent&gt;(event));
2495         }
2496 #endif
2497     }
2498 }
2499 
2500 bool Node::willRespondToMouseMoveEvents()
2501 {
2502     // FIXME: Why is the iOS code path different from the non-iOS code path?
2503 #if !PLATFORM(IOS_FAMILY)
2504     if (!is&lt;Element&gt;(*this))
2505         return false;
2506     if (downcast&lt;Element&gt;(*this).isDisabledFormControl())
2507         return false;
2508 #endif
2509     return hasEventListeners(eventNames().mousemoveEvent) || hasEventListeners(eventNames().mouseoverEvent) || hasEventListeners(eventNames().mouseoutEvent);
2510 }
2511 
2512 bool Node::willRespondToMouseClickEvents()
2513 {
2514     // FIXME: Why is the iOS code path different from the non-iOS code path?
2515 #if PLATFORM(IOS_FAMILY)
2516     return isContentEditable() || hasEventListeners(eventNames().mouseupEvent) || hasEventListeners(eventNames().mousedownEvent) || hasEventListeners(eventNames().clickEvent);
2517 #else
2518     if (!is&lt;Element&gt;(*this))
2519         return false;
2520     if (downcast&lt;Element&gt;(*this).isDisabledFormControl())
2521         return false;
2522     return computeEditability(UserSelectAllIsAlwaysNonEditable, ShouldUpdateStyle::Update) != Editability::ReadOnly
2523         || hasEventListeners(eventNames().mouseupEvent) || hasEventListeners(eventNames().mousedownEvent) || hasEventListeners(eventNames().clickEvent) || hasEventListeners(eventNames().DOMActivateEvent);
2524 #endif
2525 }
2526 
2527 bool Node::willRespondToMouseWheelEvents()
2528 {
2529     return hasEventListeners(eventNames().mousewheelEvent);
2530 }
2531 
2532 // It&#39;s important not to inline removedLastRef, because we don&#39;t want to inline the code to
2533 // delete a Node at each deref call site.
2534 void Node::removedLastRef()
2535 {
2536     ASSERT(m_refCountAndParentBit == s_refCountIncrement);
2537 
2538     // An explicit check for Document here is better than a virtual function since it is
2539     // faster for non-Document nodes, and because the call to removedLastRef that is inlined
2540     // at all deref call sites is smaller if it&#39;s a non-virtual function.
2541     if (is&lt;Document&gt;(*this)) {
2542         downcast&lt;Document&gt;(*this).removedLastRef();
2543         return;
2544     }
2545 
2546     // Now it is time to detach the SVGElement from all its properties. These properties
2547     // may outlive the SVGElement. The only difference after the detach is no commit will
2548     // be carried out unless these properties are attached to another owner.
2549     if (is&lt;SVGElement&gt;(*this))
2550         downcast&lt;SVGElement&gt;(*this).detachAllProperties();
2551 
2552 #if ASSERT_ENABLED
2553     m_deletionHasBegun = true;
2554 #endif
2555     delete this;
2556 }
2557 
2558 void Node::textRects(Vector&lt;IntRect&gt;&amp; rects) const
2559 {
2560     auto range = Range::create(document());
2561     range-&gt;selectNodeContents(const_cast&lt;Node&amp;&gt;(*this));
2562     range-&gt;absoluteTextRects(rects);
2563 }
2564 
2565 unsigned Node::connectedSubframeCount() const
2566 {
2567     return hasRareData() ? rareData()-&gt;connectedSubframeCount() : 0;
2568 }
2569 
2570 void Node::incrementConnectedSubframeCount(unsigned amount)
2571 {
2572     ASSERT(isContainerNode());
2573     ensureRareData().incrementConnectedSubframeCount(amount);
2574 }
2575 
2576 void Node::decrementConnectedSubframeCount(unsigned amount)
2577 {
2578     ASSERT(rareData());
2579     if (!hasRareData())
2580         return; // Defend against type confusion when the above assertion fails. See webkit.org/b/200300.
2581     rareData()-&gt;decrementConnectedSubframeCount(amount);
2582 }
2583 
2584 void Node::updateAncestorConnectedSubframeCountForRemoval() const
2585 {
2586     unsigned count = connectedSubframeCount();
2587 
2588     if (!count)
2589         return;
2590 
2591     for (Node* node = parentOrShadowHostNode(); node; node = node-&gt;parentOrShadowHostNode())
2592         node-&gt;decrementConnectedSubframeCount(count);
2593 }
2594 
2595 void Node::updateAncestorConnectedSubframeCountForInsertion() const
2596 {
2597     unsigned count = connectedSubframeCount();
2598 
2599     if (!count)
2600         return;
2601 
2602     for (Node* node = parentOrShadowHostNode(); node; node = node-&gt;parentOrShadowHostNode())
2603         node-&gt;incrementConnectedSubframeCount(count);
2604 }
2605 
2606 bool Node::inRenderedDocument() const
2607 {
2608     return isConnected() &amp;&amp; document().hasLivingRenderTree();
2609 }
2610 
2611 void* Node::opaqueRootSlow() const
2612 {
2613     const Node* node = this;
2614     for (;;) {
2615         const Node* nextNode = node-&gt;parentOrShadowHostNode();
2616         if (!nextNode)
2617             break;
2618         node = nextNode;
2619     }
2620     return const_cast&lt;void*&gt;(static_cast&lt;const void*&gt;(node));
2621 }
2622 
2623 } // namespace WebCore
2624 
2625 #if ENABLE(TREE_DEBUGGING)
2626 
2627 void showTree(const WebCore::Node* node)
2628 {
2629     if (node)
2630         node-&gt;showTreeForThis();
2631 }
2632 
2633 void showNodePath(const WebCore::Node* node)
2634 {
2635     if (node)
2636         node-&gt;showNodePathForThis();
2637 }
2638 
2639 #endif // ENABLE(TREE_DEBUGGING)
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>