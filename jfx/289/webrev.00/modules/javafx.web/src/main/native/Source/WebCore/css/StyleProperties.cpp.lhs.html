<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/css/StyleProperties.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * (C) 1999-2003 Lars Knoll (knoll@kde.org)
   3  * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012, 2013 Apple Inc. All rights reserved.
   4  * Copyright (C) 2011 Research In Motion Limited. All rights reserved.
   5  * Copyright (C) 2013 Intel Corporation. All rights reserved.
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public License
  18  * along with this library; see the file COPYING.LIB.  If not, write to
  19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;StyleProperties.h&quot;
  25 
  26 #include &quot;CSSComputedStyleDeclaration.h&quot;
  27 #include &quot;CSSCustomPropertyValue.h&quot;
  28 #include &quot;CSSDeferredParser.h&quot;
  29 #include &quot;CSSParser.h&quot;
  30 #include &quot;CSSPendingSubstitutionValue.h&quot;
  31 #include &quot;CSSPropertyParser.h&quot;
  32 #include &quot;CSSTokenizer.h&quot;
  33 #include &quot;CSSValueKeywords.h&quot;
  34 #include &quot;CSSValueList.h&quot;
  35 #include &quot;CSSValuePool.h&quot;
  36 #include &quot;Color.h&quot;
  37 #include &quot;Document.h&quot;
  38 #include &quot;PropertySetCSSStyleDeclaration.h&quot;
  39 #include &quot;StylePropertyShorthand.h&quot;
  40 #include &quot;StylePropertyShorthandFunctions.h&quot;
  41 #include &quot;StyleSheetContents.h&quot;
  42 #include &lt;bitset&gt;
  43 #include &lt;wtf/text/StringBuilder.h&gt;
  44 
  45 #ifndef NDEBUG
  46 #include &lt;stdio.h&gt;
  47 #include &lt;wtf/text/CString.h&gt;
  48 #endif
  49 
  50 namespace WebCore {
  51 
  52 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StyleProperties);
  53 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ImmutableStyleProperties);
  54 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(MutableStyleProperties);
  55 
  56 static size_t sizeForImmutableStylePropertiesWithPropertyCount(unsigned count)
  57 {
  58     return sizeof(ImmutableStyleProperties) - sizeof(void*) + sizeof(StylePropertyMetadata) * count + sizeof(PackedPtr&lt;const CSSValue&gt;) * count;
  59 }
  60 
  61 static bool isInitialOrInherit(const String&amp; value)
  62 {
  63     return value.length() == 7 &amp;&amp; (value == &quot;initial&quot; || value == &quot;inherit&quot;);
  64 }
  65 
  66 Ref&lt;ImmutableStyleProperties&gt; ImmutableStyleProperties::create(const CSSProperty* properties, unsigned count, CSSParserMode cssParserMode)
  67 {
  68     void* slot = ImmutableStylePropertiesMalloc::malloc(sizeForImmutableStylePropertiesWithPropertyCount(count));
  69     return adoptRef(*new (NotNull, slot) ImmutableStyleProperties(properties, count, cssParserMode));
  70 }
  71 
  72 Ref&lt;ImmutableStyleProperties&gt; StyleProperties::immutableCopyIfNeeded() const
  73 {
  74     if (is&lt;ImmutableStyleProperties&gt;(*this))
  75         return downcast&lt;ImmutableStyleProperties&gt;(const_cast&lt;StyleProperties&amp;&gt;(*this));
  76     const MutableStyleProperties&amp; mutableThis = downcast&lt;MutableStyleProperties&gt;(*this);
  77     return ImmutableStyleProperties::create(mutableThis.m_propertyVector.data(), mutableThis.m_propertyVector.size(), cssParserMode());
  78 }
  79 
  80 MutableStyleProperties::MutableStyleProperties(CSSParserMode cssParserMode)
  81     : StyleProperties(cssParserMode, MutablePropertiesType)
  82 {
  83 }
  84 
  85 MutableStyleProperties::MutableStyleProperties(Vector&lt;CSSProperty&gt;&amp;&amp; properties)
  86     : StyleProperties(HTMLStandardMode, MutablePropertiesType)
  87     , m_propertyVector(WTFMove(properties))
  88 {
  89 }
  90 
  91 MutableStyleProperties::~MutableStyleProperties() = default;
  92 
  93 ImmutableStyleProperties::ImmutableStyleProperties(const CSSProperty* properties, unsigned length, CSSParserMode cssParserMode)
  94     : StyleProperties(cssParserMode, length)
  95 {
  96     StylePropertyMetadata* metadataArray = const_cast&lt;StylePropertyMetadata*&gt;(this-&gt;metadataArray());
  97     PackedPtr&lt;CSSValue&gt;* valueArray = bitwise_cast&lt;PackedPtr&lt;CSSValue&gt;*&gt;(this-&gt;valueArray());
  98     for (unsigned i = 0; i &lt; length; ++i) {
  99         metadataArray[i] = properties[i].metadata();
 100         auto* value = properties[i].value();
 101         valueArray[i] = value;
 102         value-&gt;ref();
 103     }
 104 }
 105 
 106 ImmutableStyleProperties::~ImmutableStyleProperties()
 107 {
 108     PackedPtr&lt;CSSValue&gt;* valueArray = bitwise_cast&lt;PackedPtr&lt;CSSValue&gt;*&gt;(this-&gt;valueArray());
 109     for (unsigned i = 0; i &lt; m_arraySize; ++i)
 110         valueArray[i]-&gt;deref();
 111 }
 112 
 113 MutableStyleProperties::MutableStyleProperties(const StyleProperties&amp; other)
 114     : StyleProperties(other.cssParserMode(), MutablePropertiesType)
 115 {
 116     ASSERT(other.type() != DeferredPropertiesType);
 117     if (is&lt;MutableStyleProperties&gt;(other))
 118         m_propertyVector = downcast&lt;MutableStyleProperties&gt;(other).m_propertyVector;
 119     else {
 120         const auto&amp; immutableOther = downcast&lt;ImmutableStyleProperties&gt;(other);
 121         unsigned propertyCount = immutableOther.propertyCount();
 122         m_propertyVector.reserveInitialCapacity(propertyCount);
 123         for (unsigned i = 0; i &lt; propertyCount; ++i)
 124             m_propertyVector.uncheckedAppend(immutableOther.propertyAt(i).toCSSProperty());
 125     }
 126 }
 127 
 128 String StyleProperties::getPropertyValue(CSSPropertyID propertyID) const
 129 {
 130     RefPtr&lt;CSSValue&gt; value = getPropertyCSSValue(propertyID);
 131     if (value) {
 132         switch (propertyID) {
 133         case CSSPropertyFillOpacity:
 134         case CSSPropertyFloodOpacity:
 135         case CSSPropertyOpacity:
 136         case CSSPropertyStopOpacity:
 137         case CSSPropertyStrokeOpacity:
 138             // Opacity values always serializes as a number.
 139             if (value-&gt;isPrimitiveValue() &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value.get())-&gt;isPercentage()) {
 140                 auto doubleValue = downcast&lt;CSSPrimitiveValue&gt;(value.get())-&gt;doubleValue();
 141                 return makeString(doubleValue / 100.0);
 142             }
 143             FALLTHROUGH;
 144         default:
 145             return value-&gt;cssText();
 146         }
 147     }
 148 
 149     const StylePropertyShorthand&amp; shorthand = shorthandForProperty(propertyID);
 150     if (shorthand.length()) {
 151         RefPtr&lt;CSSValue&gt; value = getPropertyCSSValueInternal(shorthand.properties()[0]);
 152         if (!value || value-&gt;isPendingSubstitutionValue())
 153             return String();
 154     // FIXME: If all longhands are the same css-generic keyword(e.g. initial or inherit),
 155     // then the shorthand should be serialized to that keyword.
 156     // It seems to be needed to handle this in a single function commonly for all the shorthands,
 157     // not in each of the shorthand serialization function.
 158     // We could call that function here.
 159     }
 160 
 161     // Shorthand and 4-values properties
 162     switch (propertyID) {
 163     case CSSPropertyAll:
 164         return getCommonValue(allShorthand());
 165     case CSSPropertyAnimation:
 166         return getLayeredShorthandValue(animationShorthand());
 167     case CSSPropertyBorderSpacing:
 168         return borderSpacingValue(borderSpacingShorthand());
 169     case CSSPropertyBackgroundPosition:
 170         return getLayeredShorthandValue(backgroundPositionShorthand());
 171     case CSSPropertyBackgroundRepeat:
 172         return getLayeredShorthandValue(backgroundRepeatShorthand());
 173     case CSSPropertyBackground:
 174         return getLayeredShorthandValue(backgroundShorthand());
 175     case CSSPropertyBorder:
 176         return borderPropertyValue(borderWidthShorthand(), borderStyleShorthand(), borderColorShorthand());
 177     case CSSPropertyBorderTop:
 178         return getShorthandValue(borderTopShorthand());
 179     case CSSPropertyBorderRight:
 180         return getShorthandValue(borderRightShorthand());
 181     case CSSPropertyBorderBottom:
 182         return getShorthandValue(borderBottomShorthand());
 183     case CSSPropertyBorderLeft:
 184         return getShorthandValue(borderLeftShorthand());
 185     case CSSPropertyBorderBlock:
 186         return borderPropertyValue(borderBlockWidthShorthand(), borderBlockStyleShorthand(), borderBlockColorShorthand());
 187     case CSSPropertyBorderBlockColor:
 188         return get2Values(borderBlockColorShorthand());
 189     case CSSPropertyBorderBlockStyle:
 190         return get2Values(borderBlockStyleShorthand());
 191     case CSSPropertyBorderBlockWidth:
 192         return get2Values(borderBlockWidthShorthand());
 193     case CSSPropertyBorderBlockStart:
 194         return getShorthandValue(borderBlockStartShorthand());
 195     case CSSPropertyBorderBlockEnd:
 196         return getShorthandValue(borderBlockEndShorthand());
 197     case CSSPropertyBorderInline:
 198         return borderPropertyValue(borderInlineWidthShorthand(), borderInlineStyleShorthand(), borderInlineColorShorthand());
 199     case CSSPropertyBorderInlineColor:
 200         return get2Values(borderInlineColorShorthand());
 201     case CSSPropertyBorderInlineStyle:
 202         return get2Values(borderInlineStyleShorthand());
 203     case CSSPropertyBorderInlineWidth:
 204         return get2Values(borderInlineWidthShorthand());
 205     case CSSPropertyBorderInlineStart:
 206         return getShorthandValue(borderInlineStartShorthand());
 207     case CSSPropertyBorderInlineEnd:
 208         return getShorthandValue(borderInlineEndShorthand());
 209     case CSSPropertyOutline:
 210         return getShorthandValue(outlineShorthand());
 211     case CSSPropertyBorderColor:
 212         return get4Values(borderColorShorthand());
 213     case CSSPropertyBorderWidth:
 214         return get4Values(borderWidthShorthand());
 215     case CSSPropertyBorderStyle:
 216         return get4Values(borderStyleShorthand());
 217     case CSSPropertyColumnRule:
 218         return getShorthandValue(columnRuleShorthand());
 219     case CSSPropertyColumns:
 220         return getShorthandValue(columnsShorthand());
 221     case CSSPropertyFlex:
 222         return getShorthandValue(flexShorthand());
 223     case CSSPropertyFlexFlow:
 224         return getShorthandValue(flexFlowShorthand());
 225     case CSSPropertyGridArea:
 226         return getGridShorthandValue(gridAreaShorthand());
 227     case CSSPropertyGridTemplate:
 228         return getGridShorthandValue(gridTemplateShorthand());
 229     case CSSPropertyGrid:
 230         return getGridShorthandValue(gridShorthand());
 231     case CSSPropertyGridColumn:
 232         return getGridShorthandValue(gridColumnShorthand());
 233     case CSSPropertyGridRow:
 234         return getGridShorthandValue(gridRowShorthand());
 235     case CSSPropertyPageBreakAfter:
 236         return pageBreakPropertyValue(pageBreakAfterShorthand());
 237     case CSSPropertyPageBreakBefore:
 238         return pageBreakPropertyValue(pageBreakBeforeShorthand());
 239     case CSSPropertyPageBreakInside:
 240         return pageBreakPropertyValue(pageBreakInsideShorthand());
 241     case CSSPropertyPlaceContent:
 242         return getAlignmentShorthandValue(placeContentShorthand());
 243     case CSSPropertyPlaceItems:
 244         return getAlignmentShorthandValue(placeItemsShorthand());
 245     case CSSPropertyPlaceSelf:
 246         return getAlignmentShorthandValue(placeSelfShorthand());
 247     case CSSPropertyFont:
 248         return fontValue();
 249     case CSSPropertyInset:
 250         return get4Values(insetShorthand());
 251     case CSSPropertyInsetBlock:
 252         return get2Values(insetBlockShorthand());
 253     case CSSPropertyInsetInline:
 254         return get2Values(insetInlineShorthand());
 255     case CSSPropertyMargin:
 256         return get4Values(marginShorthand());
 257     case CSSPropertyMarginBlock:
 258         return get2Values(marginBlockShorthand());
 259     case CSSPropertyMarginInline:
 260         return get2Values(marginInlineShorthand());
 261     case CSSPropertyWebkitMarginCollapse:
 262         return getShorthandValue(webkitMarginCollapseShorthand());
 263     case CSSPropertyOverflow:
 264         return get2Values(overflowShorthand());
 265     case CSSPropertyPadding:
 266         return get4Values(paddingShorthand());
 267     case CSSPropertyPaddingBlock:
 268         return get2Values(paddingBlockShorthand());
 269     case CSSPropertyPaddingInline:
 270         return get2Values(paddingInlineShorthand());
 271     case CSSPropertyTransition:
 272         return getLayeredShorthandValue(transitionShorthand());
 273     case CSSPropertyListStyle:
 274         return getShorthandValue(listStyleShorthand());
 275     case CSSPropertyWebkitMaskPosition:
 276         return getLayeredShorthandValue(webkitMaskPositionShorthand());
 277     case CSSPropertyWebkitMaskRepeat:
 278         return getLayeredShorthandValue(webkitMaskRepeatShorthand());
 279     case CSSPropertyWebkitMask:
 280         return getLayeredShorthandValue(webkitMaskShorthand());
 281     case CSSPropertyWebkitTextEmphasis:
 282         return getShorthandValue(webkitTextEmphasisShorthand());
 283     case CSSPropertyWebkitTextStroke:
 284         return getShorthandValue(webkitTextStrokeShorthand());
 285     case CSSPropertyPerspectiveOrigin:
 286         return getShorthandValue(perspectiveOriginShorthand());
 287     case CSSPropertyTransformOrigin:
 288         return getShorthandValue(transformOriginShorthand());
 289     case CSSPropertyMarker: {
 290         RefPtr&lt;CSSValue&gt; value = getPropertyCSSValueInternal(CSSPropertyMarkerStart);
 291         if (value)
 292             return value-&gt;cssText();
 293         return String();
 294     }
 295     case CSSPropertyBorderRadius:
 296         return get4Values(borderRadiusShorthand());
 297 #if ENABLE(CSS_SCROLL_SNAP)
 298     case CSSPropertyScrollSnapMargin:
 299         return get4Values(scrollSnapMarginShorthand());
 300     case CSSPropertyScrollPadding:
 301         return get4Values(scrollPaddingShorthand());
 302 #endif
 303     default:
 304         return String();
 305     }
 306 }
 307 
 308 Optional&lt;Color&gt; StyleProperties::propertyAsColor(CSSPropertyID property) const
 309 {
 310     auto colorValue = getPropertyCSSValue(property);
 311     if (!is&lt;CSSPrimitiveValue&gt;(colorValue))
 312         return WTF::nullopt;
 313 
 314     auto&amp; primitiveColor = downcast&lt;CSSPrimitiveValue&gt;(*colorValue);
 315     return primitiveColor.isRGBColor() ? primitiveColor.color() : CSSParser::parseColor(colorValue-&gt;cssText());
 316 }
 317 
 318 CSSValueID StyleProperties::propertyAsValueID(CSSPropertyID property) const
 319 {
 320     auto cssValue = getPropertyCSSValue(property);
 321     return is&lt;CSSPrimitiveValue&gt;(cssValue) ? downcast&lt;CSSPrimitiveValue&gt;(*cssValue).valueID() : CSSValueInvalid;
 322 }
 323 
 324 String StyleProperties::getCustomPropertyValue(const String&amp; propertyName) const
 325 {
 326     RefPtr&lt;CSSValue&gt; value = getCustomPropertyCSSValue(propertyName);
 327     if (value)
 328         return value-&gt;cssText();
 329     return String();
 330 }
 331 
 332 String StyleProperties::borderSpacingValue(const StylePropertyShorthand&amp; shorthand) const
 333 {
 334     RefPtr&lt;CSSValue&gt; horizontalValue = getPropertyCSSValueInternal(shorthand.properties()[0]);
 335     RefPtr&lt;CSSValue&gt; verticalValue = getPropertyCSSValueInternal(shorthand.properties()[1]);
 336 
 337     // While standard border-spacing property does not allow specifying border-spacing-vertical without
 338     // specifying border-spacing-horizontal &lt;http://www.w3.org/TR/CSS21/tables.html#separated-borders&gt;,
 339     // -webkit-border-spacing-vertical can be set without -webkit-border-spacing-horizontal.
 340     if (!horizontalValue || !verticalValue)
 341         return String();
 342 
 343     String horizontalValueCSSText = horizontalValue-&gt;cssText();
 344     String verticalValueCSSText = verticalValue-&gt;cssText();
 345     if (horizontalValueCSSText == verticalValueCSSText)
 346         return horizontalValueCSSText;
 347     return horizontalValueCSSText + &#39; &#39; + verticalValueCSSText;
 348 }
 349 
 350 void StyleProperties::appendFontLonghandValueIfExplicit(CSSPropertyID propertyID, StringBuilder&amp; result, String&amp; commonValue) const
 351 {
 352     int foundPropertyIndex = findPropertyIndex(propertyID);
 353     if (foundPropertyIndex == -1)
 354         return; // All longhands must have at least implicit values if &quot;font&quot; is specified.
 355 
 356     if (propertyAt(foundPropertyIndex).isImplicit()) {
 357         commonValue = String();
 358         return;
 359     }
 360 
 361     char prefix = &#39;\0&#39;;
 362     switch (propertyID) {
 363     case CSSPropertyFontStyle:
 364         break; // No prefix.
 365     case CSSPropertyFontFamily:
 366     case CSSPropertyFontVariantCaps:
 367     case CSSPropertyFontWeight:
 368     case CSSPropertyFontStretch:
 369         prefix = &#39; &#39;;
 370         break;
 371     case CSSPropertyLineHeight:
 372         prefix = &#39;/&#39;;
 373         break;
 374     default:
 375         ASSERT_NOT_REACHED();
 376     }
 377 
 378     if (prefix &amp;&amp; !result.isEmpty())
 379         result.append(prefix);
 380     String value = propertyAt(foundPropertyIndex).value()-&gt;cssText();
 381     result.append(value);
 382     if (!commonValue.isNull() &amp;&amp; commonValue != value)
 383         commonValue = String();
 384 }
 385 
 386 String StyleProperties::fontValue() const
 387 {
 388     int fontSizePropertyIndex = findPropertyIndex(CSSPropertyFontSize);
 389     int fontFamilyPropertyIndex = findPropertyIndex(CSSPropertyFontFamily);
 390     if (fontSizePropertyIndex == -1 || fontFamilyPropertyIndex == -1)
 391         return emptyString();
 392 
 393     PropertyReference fontSizeProperty = propertyAt(fontSizePropertyIndex);
 394     PropertyReference fontFamilyProperty = propertyAt(fontFamilyPropertyIndex);
 395     if (fontSizeProperty.isImplicit() || fontFamilyProperty.isImplicit())
 396         return emptyString();
 397 
 398     String commonValue = fontSizeProperty.value()-&gt;cssText();
 399     StringBuilder result;
 400     appendFontLonghandValueIfExplicit(CSSPropertyFontStyle, result, commonValue);
 401     appendFontLonghandValueIfExplicit(CSSPropertyFontVariantCaps, result, commonValue);
 402     appendFontLonghandValueIfExplicit(CSSPropertyFontWeight, result, commonValue);
 403     appendFontLonghandValueIfExplicit(CSSPropertyFontStretch, result, commonValue);
 404     if (!result.isEmpty())
 405         result.append(&#39; &#39;);
 406     result.append(fontSizeProperty.value()-&gt;cssText());
 407     appendFontLonghandValueIfExplicit(CSSPropertyLineHeight, result, commonValue);
 408     if (!result.isEmpty())
 409         result.append(&#39; &#39;);
 410     result.append(fontFamilyProperty.value()-&gt;cssText());
 411     if (isInitialOrInherit(commonValue))
 412         return commonValue;
 413     return result.toString();
 414 }
 415 
 416 String StyleProperties::get2Values(const StylePropertyShorthand&amp; shorthand) const
 417 {
 418     // Assume the properties are in the usual order start, end.
 419     int startValueIndex = findPropertyIndex(shorthand.properties()[0]);
 420     int endValueIndex = findPropertyIndex(shorthand.properties()[1]);
 421 
 422     if (startValueIndex == -1 || endValueIndex == -1)
 423         return { };
 424 
 425     auto start = propertyAt(startValueIndex);
 426     auto end = propertyAt(endValueIndex);
 427 
 428     // All 2 properties must be specified.
 429     if (!start.value() || !end.value())
 430         return { };
 431 
 432     // Important flags must be the same
 433     if (start.isImportant() != end.isImportant())
 434         return { };
 435 
 436     if (start.isInherited() &amp;&amp; end.isInherited())
 437         return getValueName(CSSValueInherit);
 438 
 439     if (start.value()-&gt;isInitialValue() || end.value()-&gt;isInitialValue()) {
 440         if (start.value()-&gt;isInitialValue() &amp;&amp; end.value()-&gt;isInitialValue() &amp;&amp; !start.isImplicit())
 441             return getValueName(CSSValueInitial);
 442         return { };
 443     }
 444 
 445     StringBuilder result;
 446     result.append(start.value()-&gt;cssText());
 447     if (!start.value()-&gt;equals(*end.value())) {
 448         result.append(&#39; &#39;);
 449         result.append(end.value()-&gt;cssText());
 450     }
 451     return result.toString();
 452 }
 453 
 454 String StyleProperties::get4Values(const StylePropertyShorthand&amp; shorthand) const
 455 {
 456     // Assume the properties are in the usual order top, right, bottom, left.
 457     int topValueIndex = findPropertyIndex(shorthand.properties()[0]);
 458     int rightValueIndex = findPropertyIndex(shorthand.properties()[1]);
 459     int bottomValueIndex = findPropertyIndex(shorthand.properties()[2]);
 460     int leftValueIndex = findPropertyIndex(shorthand.properties()[3]);
 461 
 462     if (topValueIndex == -1 || rightValueIndex == -1 || bottomValueIndex == -1 || leftValueIndex == -1)
 463         return String();
 464 
 465     PropertyReference top = propertyAt(topValueIndex);
 466     PropertyReference right = propertyAt(rightValueIndex);
 467     PropertyReference bottom = propertyAt(bottomValueIndex);
 468     PropertyReference left = propertyAt(leftValueIndex);
 469 
 470     // All 4 properties must be specified.
 471     if (!top.value() || !right.value() || !bottom.value() || !left.value())
 472         return String();
 473 
 474     // Important flags must be the same
 475     if (top.isImportant() != right.isImportant() || right.isImportant() != bottom.isImportant() || bottom.isImportant() != left.isImportant())
 476         return String();
 477 
 478     if (top.isInherited() &amp;&amp; right.isInherited() &amp;&amp; bottom.isInherited() &amp;&amp; left.isInherited())
 479         return getValueName(CSSValueInherit);
 480 
 481     if (top.value()-&gt;isInitialValue() || right.value()-&gt;isInitialValue() || bottom.value()-&gt;isInitialValue() || left.value()-&gt;isInitialValue()) {
 482         if (top.value()-&gt;isInitialValue() &amp;&amp; right.value()-&gt;isInitialValue() &amp;&amp; bottom.value()-&gt;isInitialValue() &amp;&amp; left.value()-&gt;isInitialValue() &amp;&amp; !top.isImplicit()) {
 483             // All components are &quot;initial&quot; and &quot;top&quot; is not implicit.
 484             return getValueName(CSSValueInitial);
 485         }
 486         return String();
 487     }
 488 
 489     bool showLeft = !right.value()-&gt;equals(*left.value());
 490     bool showBottom = !top.value()-&gt;equals(*bottom.value()) || showLeft;
 491     bool showRight = !top.value()-&gt;equals(*right.value()) || showBottom;
 492 
 493     StringBuilder result;
 494     result.append(top.value()-&gt;cssText());
 495     if (showRight) {
 496         result.append(&#39; &#39;);
 497         result.append(right.value()-&gt;cssText());
 498     }
 499     if (showBottom) {
 500         result.append(&#39; &#39;);
 501         result.append(bottom.value()-&gt;cssText());
 502     }
 503     if (showLeft) {
 504         result.append(&#39; &#39;);
 505         result.append(left.value()-&gt;cssText());
 506     }
 507     return result.toString();
 508 }
 509 
 510 String StyleProperties::getLayeredShorthandValue(const StylePropertyShorthand&amp; shorthand) const
 511 {
 512     StringBuilder result;
 513 
 514     const unsigned size = shorthand.length();
 515     // Begin by collecting the properties into an array.
 516     Vector&lt; RefPtr&lt;CSSValue&gt;&gt; values(size);
 517     size_t numLayers = 0;
 518 
 519     for (unsigned i = 0; i &lt; size; ++i) {
 520         values[i] = getPropertyCSSValueInternal(shorthand.properties()[i]);
 521         if (!values[i]) {
 522             // We don&#39;t have all longhand properties defined as required for the shorthand
 523             // property and thus should not serialize to a shorthand value. See spec at
 524             // http://www.w3.org/TR/cssom-1/#serialize-a-css-declaration-block.
 525             return String();
 526         }
 527         if (values[i]-&gt;isBaseValueList())
 528             numLayers = std::max(downcast&lt;CSSValueList&gt;(*values[i]).length(), numLayers);
 529         else
 530             numLayers = std::max&lt;size_t&gt;(1U, numLayers);
 531     }
 532 
 533     String commonValue;
 534     bool commonValueInitialized = false;
 535 
 536     // Now stitch the properties together. Implicit initial values are flagged as such and
 537     // can safely be omitted.
 538     for (size_t i = 0; i &lt; numLayers; i++) {
 539         StringBuilder layerResult;
 540         bool useRepeatXShorthand = false;
 541         bool useRepeatYShorthand = false;
 542         bool useSingleWordShorthand = false;
 543         bool foundPositionYCSSProperty = false;
 544         for (unsigned j = 0; j &lt; size; j++) {
 545             RefPtr&lt;CSSValue&gt; value;
 546             if (values[j]) {
 547                 if (values[j]-&gt;isBaseValueList())
 548                     value = downcast&lt;CSSValueList&gt;(*values[j]).item(i);
 549                 else {
 550                     value = values[j];
 551 
 552                     // Color only belongs in the last layer.
 553                     if (shorthand.properties()[j] == CSSPropertyBackgroundColor) {
 554                         if (i != numLayers - 1)
 555                             value = nullptr;
 556                     } else if (i) // Other singletons only belong in the first layer.
 557                         value = nullptr;
 558                 }
 559             }
 560 
 561             // We need to report background-repeat as it was written in the CSS. If the property is implicit,
 562             // then it was written with only one value. Here we figure out which value that was so we can
 563             // report back correctly.
 564             if ((shorthand.properties()[j] == CSSPropertyBackgroundRepeatX &amp;&amp; isPropertyImplicit(shorthand.properties()[j]))
 565                 || (shorthand.properties()[j] == CSSPropertyWebkitMaskRepeatX &amp;&amp; isPropertyImplicit(shorthand.properties()[j]))) {
 566 
 567                 // BUG 49055: make sure the value was not reset in the layer check just above.
 568                 if ((j &lt; size - 1 &amp;&amp; shorthand.properties()[j + 1] == CSSPropertyBackgroundRepeatY &amp;&amp; value)
 569                     || (j &lt; size - 1 &amp;&amp; shorthand.properties()[j + 1] == CSSPropertyWebkitMaskRepeatY &amp;&amp; value)) {
 570                     RefPtr&lt;CSSValue&gt; yValue;
 571                     RefPtr&lt;CSSValue&gt; nextValue = values[j + 1];
 572                     if (nextValue) {
 573                         if (is&lt;CSSValueList&gt;(*nextValue))
 574                             yValue = downcast&lt;CSSValueList&gt;(*nextValue).itemWithoutBoundsCheck(i);
 575                         else
 576                             yValue = nextValue;
 577 
 578                         if (!is&lt;CSSPrimitiveValue&gt;(*value) || !is&lt;CSSPrimitiveValue&gt;(*yValue))
 579                             continue;
 580 
 581                         CSSValueID xId = downcast&lt;CSSPrimitiveValue&gt;(*value).valueID();
 582                         CSSValueID yId = downcast&lt;CSSPrimitiveValue&gt;(*yValue).valueID();
 583                         if (xId != yId) {
 584                             if (xId == CSSValueRepeat &amp;&amp; yId == CSSValueNoRepeat) {
 585                                 useRepeatXShorthand = true;
 586                                 ++j;
 587                             } else if (xId == CSSValueNoRepeat &amp;&amp; yId == CSSValueRepeat) {
 588                                 useRepeatYShorthand = true;
 589                                 continue;
 590                             }
 591                         } else {
 592                             useSingleWordShorthand = true;
 593                             ++j;
 594                         }
 595                     }
 596                 }
 597             }
 598 
 599             String valueText;
 600             if (value &amp;&amp; !value-&gt;isImplicitInitialValue()) {
 601                 if (!layerResult.isEmpty())
 602                     layerResult.append(&#39; &#39;);
 603                 if (foundPositionYCSSProperty
 604                     &amp;&amp; (shorthand.properties()[j] == CSSPropertyBackgroundSize || shorthand.properties()[j] == CSSPropertyWebkitMaskSize))
 605                     layerResult.appendLiteral(&quot;/ &quot;);
 606                 if (!foundPositionYCSSProperty
 607                     &amp;&amp; (shorthand.properties()[j] == CSSPropertyBackgroundSize || shorthand.properties()[j] == CSSPropertyWebkitMaskSize))
 608                     continue;
 609 
 610                 if (useRepeatXShorthand) {
 611                     useRepeatXShorthand = false;
 612                     layerResult.append(getValueName(CSSValueRepeatX));
 613                 } else if (useRepeatYShorthand) {
 614                     useRepeatYShorthand = false;
 615                     layerResult.append(getValueName(CSSValueRepeatY));
 616                 } else {
 617                     if (useSingleWordShorthand)
 618                         useSingleWordShorthand = false;
 619                     valueText = value-&gt;cssText();
 620                     layerResult.append(valueText);
 621                 }
 622 
 623                 if (shorthand.properties()[j] == CSSPropertyBackgroundPositionY
 624                     || shorthand.properties()[j] == CSSPropertyWebkitMaskPositionY) {
 625                     foundPositionYCSSProperty = true;
 626 
 627                     // background-position is a special case: if only the first offset is specified,
 628                     // the second one defaults to &quot;center&quot;, not the same value.
 629                     if (commonValueInitialized &amp;&amp; commonValue != &quot;initial&quot; &amp;&amp; commonValue != &quot;inherit&quot;)
 630                         commonValue = String();
 631                 }
 632             }
 633 
 634             if (!commonValueInitialized) {
 635                 commonValue = valueText;
 636                 commonValueInitialized = true;
 637             } else if (!commonValue.isNull() &amp;&amp; commonValue != valueText)
 638                 commonValue = String();
 639         }
 640 
 641         if (!layerResult.isEmpty()) {
 642             if (!result.isEmpty())
 643                 result.appendLiteral(&quot;, &quot;);
 644             result.append(layerResult);
 645         }
 646     }
 647 
 648     if (isInitialOrInherit(commonValue))
 649         return commonValue;
 650 
 651     if (result.isEmpty())
 652         return String();
 653     return result.toString();
 654 }
 655 
 656 String StyleProperties::getGridShorthandValue(const StylePropertyShorthand&amp; shorthand) const
 657 {
 658     return getShorthandValue(shorthand, &quot; / &quot;);
 659 }
 660 
 661 String StyleProperties::getShorthandValue(const StylePropertyShorthand&amp; shorthand, const char* separator) const
 662 {
 663     String commonValue;
 664     StringBuilder result;
 665     for (unsigned i = 0; i &lt; shorthand.length(); ++i) {
 666         if (!isPropertyImplicit(shorthand.properties()[i])) {
 667             RefPtr&lt;CSSValue&gt; value = getPropertyCSSValueInternal(shorthand.properties()[i]);
 668             if (!value)
 669                 return String();
 670             String valueText = value-&gt;cssText();
 671             if (!i)
 672                 commonValue = valueText;
 673             else if (!commonValue.isNull() &amp;&amp; commonValue != valueText)
 674                 commonValue = String();
 675             if (value-&gt;isInitialValue())
 676                 continue;
 677             if (!result.isEmpty())
 678                 result.append(separator);
 679             result.append(valueText);
 680         } else
 681             commonValue = String();
 682     }
 683     if (isInitialOrInherit(commonValue))
 684         return commonValue;
 685     if (result.isEmpty())
 686         return String();
 687     return result.toString();
 688 }
 689 
 690 // only returns a non-null value if all properties have the same, non-null value
 691 String StyleProperties::getCommonValue(const StylePropertyShorthand&amp; shorthand) const
 692 {
 693     String res;
 694     bool lastPropertyWasImportant = false;
 695     for (unsigned i = 0; i &lt; shorthand.length(); ++i) {
 696         RefPtr&lt;CSSValue&gt; value = getPropertyCSSValueInternal(shorthand.properties()[i]);
 697         if (!value)
 698             return String();
 699         // FIXME: CSSInitialValue::cssText should generate the right value.
 700         String text = value-&gt;cssText();
 701         if (text.isNull())
 702             return String();
 703         if (res.isNull())
 704             res = text;
 705         else if (res != text)
 706             return String();
 707 
 708         bool currentPropertyIsImportant = propertyIsImportant(shorthand.properties()[i]);
 709         if (i &amp;&amp; lastPropertyWasImportant != currentPropertyIsImportant)
 710             return String();
 711         lastPropertyWasImportant = currentPropertyIsImportant;
 712     }
 713     return res;
 714 }
 715 
 716 String StyleProperties::getAlignmentShorthandValue(const StylePropertyShorthand&amp; shorthand) const
 717 {
 718     String value = getCommonValue(shorthand);
 719     if (value.isNull() || value.isEmpty())
 720         return getShorthandValue(shorthand);
 721     return value;
 722 }
 723 
 724 String StyleProperties::borderPropertyValue(const StylePropertyShorthand&amp; width, const StylePropertyShorthand&amp; style, const StylePropertyShorthand&amp; color) const
 725 {
 726     const StylePropertyShorthand properties[3] = { width, style, color };
 727     String commonValue;
 728     StringBuilder result;
 729     for (size_t i = 0; i &lt; WTF_ARRAY_LENGTH(properties); ++i) {
 730         String value = getCommonValue(properties[i]);
 731         if (value.isNull())
 732             return String();
 733         if (!i)
 734             commonValue = value;
 735         else if (commonValue != value)
 736             commonValue = String();
 737         if (value == &quot;initial&quot;)
 738             continue;
 739         if (!result.isEmpty())
 740             result.append(&#39; &#39;);
 741         result.append(value);
 742     }
 743     if (isInitialOrInherit(commonValue))
 744         return commonValue;
 745     return result.toString();
 746 }
 747 
 748 String StyleProperties::pageBreakPropertyValue(const StylePropertyShorthand&amp; shorthand) const
 749 {
 750     RefPtr&lt;CSSValue&gt; value = getPropertyCSSValueInternal(shorthand.properties()[0]);
 751     // FIXME: Remove this isGlobalKeyword check after we do this consistently for all shorthands in getPropertyValue.
 752     if (value-&gt;isGlobalKeyword())
 753         return value-&gt;cssText();
<a name="1" id="anc1"></a>



 754     CSSValueID valueId = downcast&lt;CSSPrimitiveValue&gt;(*value).valueID();
 755     switch (valueId) {
 756     case CSSValuePage:
 757         return &quot;always&quot;_s;
 758     case CSSValueAuto:
 759     case CSSValueAvoid:
 760     case CSSValueLeft:
 761     case CSSValueRight:
 762         return value-&gt;cssText();
 763     default:
 764         return String();
 765     }
 766 }
 767 
 768 RefPtr&lt;CSSValue&gt; StyleProperties::getPropertyCSSValue(CSSPropertyID propertyID) const
 769 {
 770     return getPropertyCSSValueInternal(propertyID);
 771 }
 772 
 773 RefPtr&lt;CSSValue&gt; StyleProperties::getPropertyCSSValueInternal(CSSPropertyID propertyID) const
 774 {
 775     int foundPropertyIndex = findPropertyIndex(propertyID);
 776     if (foundPropertyIndex == -1)
 777         return nullptr;
 778     return propertyAt(foundPropertyIndex).value();
 779 }
 780 
 781 RefPtr&lt;CSSValue&gt; StyleProperties::getCustomPropertyCSSValue(const String&amp; propertyName) const
 782 {
 783     int foundPropertyIndex = findCustomPropertyIndex(propertyName);
 784     if (foundPropertyIndex == -1)
 785         return nullptr;
 786     return propertyAt(foundPropertyIndex).value();
 787 }
 788 
 789 bool MutableStyleProperties::removeShorthandProperty(CSSPropertyID propertyID)
 790 {
 791     StylePropertyShorthand shorthand = shorthandForProperty(propertyID);
 792     if (!shorthand.length())
 793         return false;
 794 
 795     return removePropertiesInSet(shorthand.properties(), shorthand.length());
 796 }
 797 
 798 bool MutableStyleProperties::removeProperty(CSSPropertyID propertyID, String* returnText)
 799 {
 800     if (removeShorthandProperty(propertyID)) {
 801         // FIXME: Return an equivalent shorthand when possible.
 802         if (returnText)
 803             *returnText = emptyString();
 804         return true;
 805     }
 806 
 807     int foundPropertyIndex = findPropertyIndex(propertyID);
 808     if (foundPropertyIndex == -1) {
 809         if (returnText)
 810             *returnText = emptyString();
 811         return false;
 812     }
 813 
 814     if (returnText)
 815         *returnText = propertyAt(foundPropertyIndex).value()-&gt;cssText();
 816 
 817     // A more efficient removal strategy would involve marking entries as empty
 818     // and sweeping them when the vector grows too big.
 819     m_propertyVector.remove(foundPropertyIndex);
 820 
 821     return true;
 822 }
 823 
 824 bool MutableStyleProperties::removeCustomProperty(const String&amp; propertyName, String* returnText)
 825 {
 826     int foundPropertyIndex = findCustomPropertyIndex(propertyName);
 827     if (foundPropertyIndex == -1) {
 828         if (returnText)
 829             *returnText = emptyString();
 830         return false;
 831     }
 832 
 833     if (returnText)
 834         *returnText = propertyAt(foundPropertyIndex).value()-&gt;cssText();
 835 
 836     // A more efficient removal strategy would involve marking entries as empty
 837     // and sweeping them when the vector grows too big.
 838     m_propertyVector.remove(foundPropertyIndex);
 839 
 840     return true;
 841 }
 842 
 843 bool StyleProperties::propertyIsImportant(CSSPropertyID propertyID) const
 844 {
 845     int foundPropertyIndex = findPropertyIndex(propertyID);
 846     if (foundPropertyIndex != -1)
 847         return propertyAt(foundPropertyIndex).isImportant();
 848 
 849     StylePropertyShorthand shorthand = shorthandForProperty(propertyID);
 850     if (!shorthand.length())
 851         return false;
 852 
 853     for (unsigned i = 0; i &lt; shorthand.length(); ++i) {
 854         if (!propertyIsImportant(shorthand.properties()[i]))
 855             return false;
 856     }
 857     return true;
 858 }
 859 
 860 bool StyleProperties::customPropertyIsImportant(const String&amp; propertyName) const
 861 {
 862     int foundPropertyIndex = findCustomPropertyIndex(propertyName);
 863     if (foundPropertyIndex != -1)
 864         return propertyAt(foundPropertyIndex).isImportant();
 865     return false;
 866 }
 867 
 868 String StyleProperties::getPropertyShorthand(CSSPropertyID propertyID) const
 869 {
 870     int foundPropertyIndex = findPropertyIndex(propertyID);
 871     if (foundPropertyIndex == -1)
 872         return String();
 873     return getPropertyNameString(propertyAt(foundPropertyIndex).shorthandID());
 874 }
 875 
 876 bool StyleProperties::isPropertyImplicit(CSSPropertyID propertyID) const
 877 {
 878     int foundPropertyIndex = findPropertyIndex(propertyID);
 879     if (foundPropertyIndex == -1)
 880         return false;
 881     return propertyAt(foundPropertyIndex).isImplicit();
 882 }
 883 
 884 bool MutableStyleProperties::setProperty(CSSPropertyID propertyID, const String&amp; value, bool important, CSSParserContext parserContext)
 885 {
 886     if (!isEnabledCSSProperty(propertyID))
 887         return false;
 888 
 889     // Setting the value to an empty string just removes the property in both IE and Gecko.
 890     // Setting it to null seems to produce less consistent results, but we treat it just the same.
 891     if (value.isEmpty())
 892         return removeProperty(propertyID);
 893 
 894     parserContext.mode = cssParserMode();
 895 
 896     // When replacing an existing property value, this moves the property to the end of the list.
 897     // Firefox preserves the position, and MSIE moves the property to the beginning.
 898     return CSSParser::parseValue(*this, propertyID, value, important, parserContext) == CSSParser::ParseResult::Changed;
 899 }
 900 
 901 bool MutableStyleProperties::setProperty(CSSPropertyID propertyID, const String&amp; value, bool important)
 902 {
 903     CSSParserContext parserContext(cssParserMode());
 904     return setProperty(propertyID, value, important, parserContext);
 905 }
 906 
 907 bool MutableStyleProperties::setCustomProperty(const Document* document, const String&amp; propertyName, const String&amp; value, bool important, CSSParserContext parserContext)
 908 {
 909     // Setting the value to an empty string just removes the property in both IE and Gecko.
 910     // Setting it to null seems to produce less consistent results, but we treat it just the same.
 911     if (value.isEmpty())
 912         return removeCustomProperty(propertyName);
 913 
 914     parserContext.mode = cssParserMode();
 915 
 916     String syntax = &quot;*&quot;;
 917     auto* registered = document ? document-&gt;getCSSRegisteredCustomPropertySet().get(propertyName) : nullptr;
 918 
 919     if (registered)
 920         syntax = registered-&gt;syntax;
 921 
 922     CSSTokenizer tokenizer(value);
 923     if (!CSSPropertyParser::canParseTypedCustomPropertyValue(syntax, tokenizer.tokenRange(), parserContext))
 924         return false;
 925 
 926     // When replacing an existing property value, this moves the property to the end of the list.
 927     // Firefox preserves the position, and MSIE moves the property to the beginning.
 928     return CSSParser::parseCustomPropertyValue(*this, propertyName, value, important, parserContext) == CSSParser::ParseResult::Changed;
 929 }
 930 
 931 void MutableStyleProperties::setProperty(CSSPropertyID propertyID, RefPtr&lt;CSSValue&gt;&amp;&amp; value, bool important)
 932 {
 933     StylePropertyShorthand shorthand = shorthandForProperty(propertyID);
 934     if (!shorthand.length()) {
 935         setProperty(CSSProperty(propertyID, WTFMove(value), important));
 936         return;
 937     }
 938 
 939     removePropertiesInSet(shorthand.properties(), shorthand.length());
 940 
 941     for (unsigned i = 0; i &lt; shorthand.length(); ++i)
 942         m_propertyVector.append(CSSProperty(shorthand.properties()[i], value.copyRef(), important));
 943 }
 944 
 945 bool MutableStyleProperties::setProperty(const CSSProperty&amp; property, CSSProperty* slot)
 946 {
 947     if (!removeShorthandProperty(property.id())) {
 948         CSSProperty* toReplace = slot;
 949         if (!slot) {
 950             if (property.id() == CSSPropertyCustom) {
 951                 if (property.value())
 952                     toReplace = findCustomCSSPropertyWithName(downcast&lt;CSSCustomPropertyValue&gt;(*property.value()).name());
 953             } else
 954                 toReplace = findCSSPropertyWithID(property.id());
 955         }
 956 
 957         if (toReplace) {
 958             if (*toReplace == property)
 959                 return false;
 960 
 961             *toReplace = property;
 962             return true;
 963         }
 964     }
 965 
 966     m_propertyVector.append(property);
 967     return true;
 968 }
 969 
 970 bool MutableStyleProperties::setProperty(CSSPropertyID propertyID, CSSValueID identifier, bool important)
 971 {
 972     return setProperty(CSSProperty(propertyID, CSSValuePool::singleton().createIdentifierValue(identifier), important));
 973 }
 974 
 975 bool MutableStyleProperties::setProperty(CSSPropertyID propertyID, CSSPropertyID identifier, bool important)
 976 {
 977     return setProperty(CSSProperty(propertyID, CSSValuePool::singleton().createIdentifierValue(identifier), important));
 978 }
 979 
 980 bool MutableStyleProperties::parseDeclaration(const String&amp; styleDeclaration, CSSParserContext context)
 981 {
 982     auto oldProperties = WTFMove(m_propertyVector);
 983     m_propertyVector.clear();
 984 
 985     context.mode = cssParserMode();
 986 
 987     CSSParser parser(context);
 988     parser.parseDeclaration(*this, styleDeclaration);
 989 
 990     // We could do better. Just changing property order does not require style invalidation.
 991     return oldProperties != m_propertyVector;
 992 }
 993 
 994 bool MutableStyleProperties::addParsedProperties(const ParsedPropertyVector&amp; properties)
 995 {
 996     bool anyChanged = false;
 997     m_propertyVector.reserveCapacity(m_propertyVector.size() + properties.size());
 998     for (const auto&amp; property : properties) {
 999         if (addParsedProperty(property))
1000             anyChanged = true;
1001     }
1002 
1003     return anyChanged;
1004 }
1005 
1006 bool MutableStyleProperties::addParsedProperty(const CSSProperty&amp; property)
1007 {
1008     if (property.id() == CSSPropertyCustom) {
1009         if ((property.value() &amp;&amp; !customPropertyIsImportant(downcast&lt;CSSCustomPropertyValue&gt;(*property.value()).name())) || property.isImportant())
1010             return setProperty(property);
1011         return false;
1012     }
1013     return setProperty(property);
1014 }
1015 
1016 String StyleProperties::asText() const
1017 {
1018     StringBuilder result;
1019 
1020     int positionXPropertyIndex = -1;
1021     int positionYPropertyIndex = -1;
1022     int repeatXPropertyIndex = -1;
1023     int repeatYPropertyIndex = -1;
1024 
1025     std::bitset&lt;numCSSProperties&gt; shorthandPropertyUsed;
1026     std::bitset&lt;numCSSProperties&gt; shorthandPropertyAppeared;
1027 
1028     unsigned size = propertyCount();
1029     unsigned numDecls = 0;
1030     for (unsigned n = 0; n &lt; size; ++n) {
1031         PropertyReference property = propertyAt(n);
1032         CSSPropertyID propertyID = property.id();
1033         CSSPropertyID shorthandPropertyID = CSSPropertyInvalid;
1034         CSSPropertyID borderFallbackShorthandProperty = CSSPropertyInvalid;
1035         CSSPropertyID borderBlockFallbackShorthandProperty = CSSPropertyInvalid;
1036         CSSPropertyID borderInlineFallbackShorthandProperty = CSSPropertyInvalid;
1037         String value;
1038         auto serializeBorderShorthand = [&amp;] (const CSSPropertyID borderProperty, const CSSPropertyID fallbackProperty) {
1039             // FIXME: Deal with cases where only some of border sides are specified.
1040             ASSERT(borderProperty - firstCSSProperty &lt; static_cast&lt;CSSPropertyID&gt;(shorthandPropertyAppeared.size()));
1041             if (!shorthandPropertyAppeared[borderProperty - firstCSSProperty] &amp;&amp; isEnabledCSSProperty(borderProperty)) {
1042                 value = getPropertyValue(borderProperty);
1043                 if (value.isNull())
1044                     shorthandPropertyAppeared.set(borderProperty - firstCSSProperty);
1045                 else
1046                     shorthandPropertyID = borderProperty;
1047             } else if (shorthandPropertyUsed[borderProperty - firstCSSProperty])
1048                 shorthandPropertyID = borderProperty;
1049             if (!shorthandPropertyID)
1050                 shorthandPropertyID = fallbackProperty;
1051         };
1052 
1053         if (property.value() &amp;&amp; property.value()-&gt;isPendingSubstitutionValue()) {
1054             auto&amp; substitutionValue = downcast&lt;CSSPendingSubstitutionValue&gt;(*property.value());
1055             shorthandPropertyID = substitutionValue.shorthandPropertyId();
1056             value = substitutionValue.shorthandValue()-&gt;cssText();
1057         } else {
1058             switch (propertyID) {
1059             case CSSPropertyAnimationName:
1060             case CSSPropertyAnimationDuration:
1061             case CSSPropertyAnimationTimingFunction:
1062             case CSSPropertyAnimationDelay:
1063             case CSSPropertyAnimationIterationCount:
1064             case CSSPropertyAnimationDirection:
1065             case CSSPropertyAnimationFillMode:
1066             case CSSPropertyAnimationPlayState:
1067                 shorthandPropertyID = CSSPropertyAnimation;
1068                 break;
1069             case CSSPropertyBackgroundPositionX:
1070                 positionXPropertyIndex = n;
1071                 continue;
1072             case CSSPropertyBackgroundPositionY:
1073                 positionYPropertyIndex = n;
1074                 continue;
1075             case CSSPropertyBackgroundRepeatX:
1076                 repeatXPropertyIndex = n;
1077                 continue;
1078             case CSSPropertyBackgroundRepeatY:
1079                 repeatYPropertyIndex = n;
1080                 continue;
1081             case CSSPropertyBorderTopWidth:
1082             case CSSPropertyBorderRightWidth:
1083             case CSSPropertyBorderBottomWidth:
1084             case CSSPropertyBorderLeftWidth:
1085                 if (!borderFallbackShorthandProperty)
1086                     borderFallbackShorthandProperty = CSSPropertyBorderWidth;
1087                 FALLTHROUGH;
1088             case CSSPropertyBorderTopStyle:
1089             case CSSPropertyBorderRightStyle:
1090             case CSSPropertyBorderBottomStyle:
1091             case CSSPropertyBorderLeftStyle:
1092                 if (!borderFallbackShorthandProperty)
1093                     borderFallbackShorthandProperty = CSSPropertyBorderStyle;
1094                 FALLTHROUGH;
1095             case CSSPropertyBorderTopColor:
1096             case CSSPropertyBorderRightColor:
1097             case CSSPropertyBorderBottomColor:
1098             case CSSPropertyBorderLeftColor:
1099                 if (!borderFallbackShorthandProperty)
1100                     borderFallbackShorthandProperty = CSSPropertyBorderColor;
1101                 serializeBorderShorthand(CSSPropertyBorder, borderFallbackShorthandProperty);
1102                 break;
1103             case CSSPropertyBorderBlockStartWidth:
1104             case CSSPropertyBorderBlockEndWidth:
1105                 if (!borderBlockFallbackShorthandProperty)
1106                     borderBlockFallbackShorthandProperty = CSSPropertyBorderBlockWidth;
1107                 FALLTHROUGH;
1108             case CSSPropertyBorderBlockStartStyle:
1109             case CSSPropertyBorderBlockEndStyle:
1110                 if (!borderBlockFallbackShorthandProperty)
1111                     borderBlockFallbackShorthandProperty = CSSPropertyBorderBlockStyle;
1112                 FALLTHROUGH;
1113             case CSSPropertyBorderBlockStartColor:
1114             case CSSPropertyBorderBlockEndColor:
1115                 if (!borderBlockFallbackShorthandProperty)
1116                     borderBlockFallbackShorthandProperty = CSSPropertyBorderBlockColor;
1117                 serializeBorderShorthand(CSSPropertyBorderBlock, borderBlockFallbackShorthandProperty);
1118                 break;
1119             case CSSPropertyBorderInlineStartWidth:
1120             case CSSPropertyBorderInlineEndWidth:
1121                 if (!borderInlineFallbackShorthandProperty)
1122                     borderInlineFallbackShorthandProperty = CSSPropertyBorderInlineWidth;
1123                 FALLTHROUGH;
1124             case CSSPropertyBorderInlineStartStyle:
1125             case CSSPropertyBorderInlineEndStyle:
1126                 if (!borderInlineFallbackShorthandProperty)
1127                     borderInlineFallbackShorthandProperty = CSSPropertyBorderInlineStyle;
1128                 FALLTHROUGH;
1129             case CSSPropertyBorderInlineStartColor:
1130             case CSSPropertyBorderInlineEndColor:
1131                 if (!borderInlineFallbackShorthandProperty)
1132                     borderInlineFallbackShorthandProperty = CSSPropertyBorderInlineColor;
1133                 serializeBorderShorthand(CSSPropertyBorderInline, borderInlineFallbackShorthandProperty);
1134                 break;
1135             case CSSPropertyWebkitBorderHorizontalSpacing:
1136             case CSSPropertyWebkitBorderVerticalSpacing:
1137                 shorthandPropertyID = CSSPropertyBorderSpacing;
1138                 break;
1139             case CSSPropertyFontFamily:
1140             case CSSPropertyLineHeight:
1141             case CSSPropertyFontSize:
1142             case CSSPropertyFontStyle:
1143             case CSSPropertyFontVariantCaps:
1144             case CSSPropertyFontWeight:
1145                 // Don&#39;t use CSSPropertyFont because old UAs can&#39;t recognize them but are important for editing.
1146                 break;
1147             case CSSPropertyTop:
1148             case CSSPropertyRight:
1149             case CSSPropertyBottom:
1150             case CSSPropertyLeft:
1151                 shorthandPropertyID = CSSPropertyInset;
1152                 break;
1153             case CSSPropertyInsetBlockStart:
1154             case CSSPropertyInsetBlockEnd:
1155                 shorthandPropertyID = CSSPropertyInsetBlock;
1156                 break;
1157             case CSSPropertyInsetInlineStart:
1158             case CSSPropertyInsetInlineEnd:
1159                 shorthandPropertyID = CSSPropertyInsetInline;
1160                 break;
1161             case CSSPropertyListStyleType:
1162             case CSSPropertyListStylePosition:
1163             case CSSPropertyListStyleImage:
1164                 shorthandPropertyID = CSSPropertyListStyle;
1165                 break;
1166             case CSSPropertyMarginTop:
1167             case CSSPropertyMarginRight:
1168             case CSSPropertyMarginBottom:
1169             case CSSPropertyMarginLeft:
1170                 shorthandPropertyID = CSSPropertyMargin;
1171                 break;
1172             case CSSPropertyMarginBlockStart:
1173             case CSSPropertyMarginBlockEnd:
1174                 shorthandPropertyID = CSSPropertyMarginBlock;
1175                 break;
1176             case CSSPropertyMarginInlineStart:
1177             case CSSPropertyMarginInlineEnd:
1178                 shorthandPropertyID = CSSPropertyMarginInline;
1179                 break;
1180             case CSSPropertyOutlineWidth:
1181             case CSSPropertyOutlineStyle:
1182             case CSSPropertyOutlineColor:
1183                 shorthandPropertyID = CSSPropertyOutline;
1184                 break;
1185             case CSSPropertyOverflowX:
1186             case CSSPropertyOverflowY:
1187                 shorthandPropertyID = CSSPropertyOverflow;
1188                 break;
1189             case CSSPropertyPaddingTop:
1190             case CSSPropertyPaddingRight:
1191             case CSSPropertyPaddingBottom:
1192             case CSSPropertyPaddingLeft:
1193                 shorthandPropertyID = CSSPropertyPadding;
1194                 break;
1195             case CSSPropertyPaddingBlockStart:
1196             case CSSPropertyPaddingBlockEnd:
1197                 shorthandPropertyID = CSSPropertyPaddingBlock;
1198                 break;
1199             case CSSPropertyPaddingInlineStart:
1200             case CSSPropertyPaddingInlineEnd:
1201                 shorthandPropertyID = CSSPropertyPaddingInline;
1202                 break;
1203 #if ENABLE(CSS_SCROLL_SNAP)
1204             case CSSPropertyScrollPaddingTop:
1205             case CSSPropertyScrollPaddingRight:
1206             case CSSPropertyScrollPaddingBottom:
1207             case CSSPropertyScrollPaddingLeft:
1208                 shorthandPropertyID = CSSPropertyScrollPadding;
1209                 break;
1210             case CSSPropertyScrollSnapMarginTop:
1211             case CSSPropertyScrollSnapMarginRight:
1212             case CSSPropertyScrollSnapMarginBottom:
1213             case CSSPropertyScrollSnapMarginLeft:
1214                 shorthandPropertyID = CSSPropertyScrollSnapMargin;
1215                 break;
1216 #endif
1217             case CSSPropertyTransitionProperty:
1218             case CSSPropertyTransitionDuration:
1219             case CSSPropertyTransitionTimingFunction:
1220             case CSSPropertyTransitionDelay:
1221                 shorthandPropertyID = CSSPropertyTransition;
1222                 break;
1223             case CSSPropertyFlexDirection:
1224             case CSSPropertyFlexWrap:
1225                 shorthandPropertyID = CSSPropertyFlexFlow;
1226                 break;
1227             case CSSPropertyFlexBasis:
1228             case CSSPropertyFlexGrow:
1229             case CSSPropertyFlexShrink:
1230                 shorthandPropertyID = CSSPropertyFlex;
1231                 break;
1232             case CSSPropertyWebkitMaskPositionX:
1233             case CSSPropertyWebkitMaskPositionY:
1234             case CSSPropertyWebkitMaskRepeatX:
1235             case CSSPropertyWebkitMaskRepeatY:
1236             case CSSPropertyWebkitMaskImage:
1237             case CSSPropertyWebkitMaskRepeat:
1238             case CSSPropertyWebkitMaskPosition:
1239             case CSSPropertyWebkitMaskClip:
1240             case CSSPropertyWebkitMaskOrigin:
1241                 shorthandPropertyID = CSSPropertyWebkitMask;
1242                 break;
1243             case CSSPropertyPerspectiveOriginX:
1244             case CSSPropertyPerspectiveOriginY:
1245                 shorthandPropertyID = CSSPropertyPerspectiveOrigin;
1246                 break;
1247             case CSSPropertyTransformOriginX:
1248             case CSSPropertyTransformOriginY:
1249             case CSSPropertyTransformOriginZ:
1250                 shorthandPropertyID = CSSPropertyTransformOrigin;
1251                 break;
1252             default:
1253                 break;
1254             }
1255         }
1256 
1257         unsigned shortPropertyIndex = shorthandPropertyID - firstCSSProperty;
1258         if (shorthandPropertyID &amp;&amp; isEnabledCSSProperty(shorthandPropertyID)) {
1259             ASSERT(shortPropertyIndex &lt; shorthandPropertyUsed.size());
1260             if (shorthandPropertyUsed[shortPropertyIndex])
1261                 continue;
1262             if (!shorthandPropertyAppeared[shortPropertyIndex] &amp;&amp; value.isNull())
1263                 value = getPropertyValue(shorthandPropertyID);
1264             shorthandPropertyAppeared.set(shortPropertyIndex);
1265         }
1266 
1267         if (!value.isNull()) {
1268             propertyID = shorthandPropertyID;
1269             shorthandPropertyUsed.set(shortPropertyIndex);
1270         } else
1271             value = property.value()-&gt;cssText();
1272 
1273         if (propertyID != CSSPropertyCustom &amp;&amp; value == &quot;initial&quot; &amp;&amp; !CSSProperty::isInheritedProperty(propertyID))
1274             continue;
1275 
1276         if (numDecls++)
1277             result.append(&#39; &#39;);
1278 
1279         if (propertyID == CSSPropertyCustom)
1280             result.append(downcast&lt;CSSCustomPropertyValue&gt;(*property.value()).name());
1281         else
1282             result.append(getPropertyName(propertyID));
1283 
1284         result.appendLiteral(&quot;: &quot;);
1285         result.append(value);
1286         if (property.isImportant())
1287             result.appendLiteral(&quot; !important&quot;);
1288         result.append(&#39;;&#39;);
1289     }
1290 
1291     // FIXME: This is a not-so-nice way to turn x/y positions into single background-position in output.
1292     // It is required because background-position-x/y are non-standard properties and WebKit generated output
1293     // would not work in Firefox (&lt;rdar://problem/5143183&gt;)
1294     // It would be a better solution if background-position was CSSUnitType::CSS_PAIR.
1295     if (positionXPropertyIndex != -1 &amp;&amp; positionYPropertyIndex != -1 &amp;&amp; propertyAt(positionXPropertyIndex).isImportant() == propertyAt(positionYPropertyIndex).isImportant()) {
1296         PropertyReference positionXProperty = propertyAt(positionXPropertyIndex);
1297         PropertyReference positionYProperty = propertyAt(positionYPropertyIndex);
1298 
1299         if (numDecls++)
1300             result.append(&#39; &#39;);
1301         result.appendLiteral(&quot;background-position: &quot;);
1302         if (positionXProperty.value()-&gt;isValueList() || positionYProperty.value()-&gt;isValueList())
1303             result.append(getLayeredShorthandValue(backgroundPositionShorthand()));
1304         else {
1305             result.append(positionXProperty.value()-&gt;cssText());
1306             result.append(&#39; &#39;);
1307             result.append(positionYProperty.value()-&gt;cssText());
1308         }
1309         if (positionXProperty.isImportant())
1310             result.appendLiteral(&quot; !important&quot;);
1311         result.append(&#39;;&#39;);
1312     } else {
1313         if (positionXPropertyIndex != -1) {
1314             if (numDecls++)
1315                 result.append(&#39; &#39;);
1316             result.append(propertyAt(positionXPropertyIndex).cssText());
1317         }
1318         if (positionYPropertyIndex != -1) {
1319             if (numDecls++)
1320                 result.append(&#39; &#39;);
1321             result.append(propertyAt(positionYPropertyIndex).cssText());
1322         }
1323     }
1324 
1325     // FIXME: We need to do the same for background-repeat.
1326     if (repeatXPropertyIndex != -1 &amp;&amp; repeatYPropertyIndex != -1 &amp;&amp; propertyAt(repeatXPropertyIndex).isImportant() == propertyAt(repeatYPropertyIndex).isImportant()) {
1327         PropertyReference repeatXProperty = propertyAt(repeatXPropertyIndex);
1328         PropertyReference repeatYProperty = propertyAt(repeatYPropertyIndex);
1329 
1330         if (numDecls++)
1331             result.append(&#39; &#39;);
1332         result.appendLiteral(&quot;background-repeat: &quot;);
1333         if (repeatXProperty.value()-&gt;isValueList() || repeatYProperty.value()-&gt;isValueList())
1334             result.append(getLayeredShorthandValue(backgroundRepeatShorthand()));
1335         else {
1336             result.append(repeatXProperty.value()-&gt;cssText());
1337             result.append(&#39; &#39;);
1338             result.append(repeatYProperty.value()-&gt;cssText());
1339         }
1340         if (repeatXProperty.isImportant())
1341             result.appendLiteral(&quot; !important&quot;);
1342         result.append(&#39;;&#39;);
1343     } else {
1344         if (repeatXPropertyIndex != -1) {
1345             if (numDecls++)
1346                 result.append(&#39; &#39;);
1347             result.append(propertyAt(repeatXPropertyIndex).cssText());
1348         }
1349         if (repeatYPropertyIndex != -1) {
1350             if (numDecls++)
1351                 result.append(&#39; &#39;);
1352             result.append(propertyAt(repeatYPropertyIndex).cssText());
1353         }
1354     }
1355 
1356     ASSERT(!numDecls ^ !result.isEmpty());
1357     return result.toString();
1358 }
1359 
1360 bool StyleProperties::hasCSSOMWrapper() const
1361 {
1362     return is&lt;MutableStyleProperties&gt;(*this) &amp;&amp; downcast&lt;MutableStyleProperties&gt;(*this).m_cssomWrapper;
1363 }
1364 
1365 void MutableStyleProperties::mergeAndOverrideOnConflict(const StyleProperties&amp; other)
1366 {
1367     unsigned size = other.propertyCount();
1368     for (unsigned i = 0; i &lt; size; ++i)
1369         addParsedProperty(other.propertyAt(i).toCSSProperty());
1370 }
1371 
1372 bool StyleProperties::traverseSubresources(const WTF::Function&lt;bool (const CachedResource&amp;)&gt;&amp; handler) const
1373 {
1374     unsigned size = propertyCount();
1375     for (unsigned i = 0; i &lt; size; ++i) {
1376         if (propertyAt(i).value()-&gt;traverseSubresources(handler))
1377             return true;
1378     }
1379     return false;
1380 }
1381 
1382 // This is the list of properties we want to copy in the copyBlockProperties() function.
1383 // It is the list of CSS properties that apply specially to block-level elements.
1384 static const CSSPropertyID blockProperties[] = {
1385     CSSPropertyOrphans,
1386     CSSPropertyOverflow, // This can be also be applied to replaced elements
1387     CSSPropertyWebkitAspectRatio,
1388     CSSPropertyColumnCount,
1389     CSSPropertyColumnGap,
1390     CSSPropertyRowGap,
1391     CSSPropertyColumnRuleColor,
1392     CSSPropertyColumnRuleStyle,
1393     CSSPropertyColumnRuleWidth,
1394     CSSPropertyWebkitColumnBreakBefore,
1395     CSSPropertyWebkitColumnBreakAfter,
1396     CSSPropertyWebkitColumnBreakInside,
1397     CSSPropertyColumnWidth,
1398     CSSPropertyPageBreakAfter,
1399     CSSPropertyPageBreakBefore,
1400     CSSPropertyPageBreakInside,
1401     CSSPropertyTextAlign,
1402 #if ENABLE(CSS3_TEXT)
1403     CSSPropertyWebkitTextAlignLast,
1404     CSSPropertyWebkitTextJustify,
1405 #endif // CSS3_TEXT
1406     CSSPropertyTextIndent,
1407     CSSPropertyWidows
1408 };
1409 
1410 void MutableStyleProperties::clear()
1411 {
1412     m_propertyVector.clear();
1413 }
1414 
1415 const unsigned numBlockProperties = WTF_ARRAY_LENGTH(blockProperties);
1416 
1417 Ref&lt;MutableStyleProperties&gt; StyleProperties::copyBlockProperties() const
1418 {
1419     return copyPropertiesInSet(blockProperties, numBlockProperties);
1420 }
1421 
1422 void MutableStyleProperties::removeBlockProperties()
1423 {
1424     removePropertiesInSet(blockProperties, numBlockProperties);
1425 }
1426 
1427 bool MutableStyleProperties::removePropertiesInSet(const CSSPropertyID* set, unsigned length)
1428 {
1429     if (m_propertyVector.isEmpty())
1430         return false;
1431 
1432     // FIXME: This is always used with static sets and in that case constructing the hash repeatedly is pretty pointless.
1433     HashSet&lt;CSSPropertyID&gt; toRemove;
1434     for (unsigned i = 0; i &lt; length; ++i)
1435         toRemove.add(set[i]);
1436 
1437     return m_propertyVector.removeAllMatching([&amp;toRemove] (const CSSProperty&amp; property) {
1438         return toRemove.contains(property.id());
1439     }) &gt; 0;
1440 }
1441 
1442 int ImmutableStyleProperties::findPropertyIndex(CSSPropertyID propertyID) const
1443 {
1444     // Convert here propertyID into an uint16_t to compare it with the metadata&#39;s m_propertyID to avoid
1445     // the compiler converting it to an int multiple times in the loop.
1446     uint16_t id = static_cast&lt;uint16_t&gt;(propertyID);
1447     for (int n = m_arraySize - 1 ; n &gt;= 0; --n) {
1448         if (metadataArray()[n].m_propertyID == id)
1449             return n;
1450     }
1451 
1452     return -1;
1453 }
1454 
1455 int MutableStyleProperties::findPropertyIndex(CSSPropertyID propertyID) const
1456 {
1457     // Convert here propertyID into an uint16_t to compare it with the metadata&#39;s m_propertyID to avoid
1458     // the compiler converting it to an int multiple times in the loop.
1459     uint16_t id = static_cast&lt;uint16_t&gt;(propertyID);
1460     for (int n = m_propertyVector.size() - 1 ; n &gt;= 0; --n) {
1461         if (m_propertyVector.at(n).metadata().m_propertyID == id)
1462             return n;
1463     }
1464 
1465     return -1;
1466 }
1467 
1468 int ImmutableStyleProperties::findCustomPropertyIndex(const String&amp; propertyName) const
1469 {
1470     // Convert the propertyID into an uint16_t to compare it with the metadata&#39;s m_propertyID to avoid
1471     // the compiler converting it to an int multiple times in the loop.
1472     for (int n = m_arraySize - 1 ; n &gt;= 0; --n) {
1473         if (metadataArray()[n].m_propertyID == CSSPropertyCustom) {
1474             // We found a custom property. See if the name matches.
1475             auto* value = valueArray()[n].get();
1476             if (!value)
1477                 continue;
1478             if (downcast&lt;CSSCustomPropertyValue&gt;(*value).name() == propertyName)
1479                 return n;
1480         }
1481     }
1482 
1483     return -1;
1484 }
1485 
1486 int MutableStyleProperties::findCustomPropertyIndex(const String&amp; propertyName) const
1487 {
1488     // Convert the propertyID into an uint16_t to compare it with the metadata&#39;s m_propertyID to avoid
1489     // the compiler converting it to an int multiple times in the loop.
1490     for (int n = m_propertyVector.size() - 1 ; n &gt;= 0; --n) {
1491         if (m_propertyVector.at(n).metadata().m_propertyID == CSSPropertyCustom) {
1492             // We found a custom property. See if the name matches.
1493             if (!m_propertyVector.at(n).value())
1494                 continue;
1495             if (downcast&lt;CSSCustomPropertyValue&gt;(*m_propertyVector.at(n).value()).name() == propertyName)
1496                 return n;
1497         }
1498     }
1499 
1500     return -1;
1501 }
1502 
1503 CSSProperty* MutableStyleProperties::findCSSPropertyWithID(CSSPropertyID propertyID)
1504 {
1505     int foundPropertyIndex = findPropertyIndex(propertyID);
1506     if (foundPropertyIndex == -1)
1507         return 0;
1508     return &amp;m_propertyVector.at(foundPropertyIndex);
1509 }
1510 
1511 CSSProperty* MutableStyleProperties::findCustomCSSPropertyWithName(const String&amp; propertyName)
1512 {
1513     int foundPropertyIndex = findCustomPropertyIndex(propertyName);
1514     if (foundPropertyIndex == -1)
1515         return 0;
1516     return &amp;m_propertyVector.at(foundPropertyIndex);
1517 }
1518 
1519 bool StyleProperties::propertyMatches(CSSPropertyID propertyID, const CSSValue* propertyValue) const
1520 {
1521     int foundPropertyIndex = findPropertyIndex(propertyID);
1522     if (foundPropertyIndex == -1)
1523         return false;
1524     return propertyAt(foundPropertyIndex).value()-&gt;equals(*propertyValue);
1525 }
1526 
1527 Ref&lt;MutableStyleProperties&gt; StyleProperties::mutableCopy() const
1528 {
1529     return adoptRef(*new MutableStyleProperties(*this));
1530 }
1531 
1532 Ref&lt;MutableStyleProperties&gt; StyleProperties::copyPropertiesInSet(const CSSPropertyID* set, unsigned length) const
1533 {
1534     Vector&lt;CSSProperty&gt; list;
1535     list.reserveInitialCapacity(length);
1536     for (unsigned i = 0; i &lt; length; ++i) {
1537         if (auto value = getPropertyCSSValueInternal(set[i]))
1538             list.uncheckedAppend(CSSProperty(set[i], WTFMove(value), false));
1539     }
1540     return MutableStyleProperties::create(WTFMove(list));
1541 }
1542 
1543 PropertySetCSSStyleDeclaration* MutableStyleProperties::cssStyleDeclaration()
1544 {
1545     return m_cssomWrapper.get();
1546 }
1547 
1548 CSSStyleDeclaration&amp; MutableStyleProperties::ensureCSSStyleDeclaration()
1549 {
1550     if (m_cssomWrapper) {
1551         ASSERT(!static_cast&lt;CSSStyleDeclaration*&gt;(m_cssomWrapper.get())-&gt;parentRule());
1552         ASSERT(!m_cssomWrapper-&gt;parentElement());
1553         return *m_cssomWrapper;
1554     }
1555     m_cssomWrapper = makeUnique&lt;PropertySetCSSStyleDeclaration&gt;(*this);
1556     return *m_cssomWrapper;
1557 }
1558 
1559 CSSStyleDeclaration&amp; MutableStyleProperties::ensureInlineCSSStyleDeclaration(StyledElement&amp; parentElement)
1560 {
1561     if (m_cssomWrapper) {
1562         ASSERT(m_cssomWrapper-&gt;parentElement() == &amp;parentElement);
1563         return *m_cssomWrapper;
1564     }
1565     m_cssomWrapper = makeUnique&lt;InlineCSSStyleDeclaration&gt;(*this, parentElement);
1566     return *m_cssomWrapper;
1567 }
1568 
1569 unsigned StyleProperties::averageSizeInBytes()
1570 {
1571     // Please update this if the storage scheme changes so that this longer reflects the actual size.
1572     return sizeForImmutableStylePropertiesWithPropertyCount(4);
1573 }
1574 
1575 // See the function above if you need to update this.
1576 struct SameSizeAsStyleProperties : public RefCounted&lt;SameSizeAsStyleProperties&gt; {
1577     unsigned bitfield;
1578 };
1579 COMPILE_ASSERT(sizeof(StyleProperties) == sizeof(SameSizeAsStyleProperties), style_property_set_should_stay_small);
1580 
1581 #ifndef NDEBUG
1582 void StyleProperties::showStyle()
1583 {
1584     fprintf(stderr, &quot;%s\n&quot;, asText().ascii().data());
1585 }
1586 #endif
1587 
1588 Ref&lt;MutableStyleProperties&gt; MutableStyleProperties::create(CSSParserMode cssParserMode)
1589 {
1590     return adoptRef(*new MutableStyleProperties(cssParserMode));
1591 }
1592 
1593 Ref&lt;MutableStyleProperties&gt; MutableStyleProperties::create(Vector&lt;CSSProperty&gt;&amp;&amp; properties)
1594 {
1595     return adoptRef(*new MutableStyleProperties(WTFMove(properties)));
1596 }
1597 
1598 String StyleProperties::PropertyReference::cssName() const
1599 {
1600     if (id() == CSSPropertyCustom)
1601         return downcast&lt;CSSCustomPropertyValue&gt;(*value()).name();
1602     return getPropertyNameString(id());
1603 }
1604 
1605 String StyleProperties::PropertyReference::cssText() const
1606 {
1607     StringBuilder result;
1608     result.append(cssName());
1609     result.appendLiteral(&quot;: &quot;);
1610     result.append(m_value-&gt;cssText());
1611     if (isImportant())
1612         result.appendLiteral(&quot; !important&quot;);
1613     result.append(&#39;;&#39;);
1614     return result.toString();
1615 }
1616 
1617 Ref&lt;DeferredStyleProperties&gt; DeferredStyleProperties::create(const CSSParserTokenRange&amp; tokenRange, CSSDeferredParser&amp; parser)
1618 {
1619     return adoptRef(*new DeferredStyleProperties(tokenRange, parser));
1620 }
1621 
1622 DeferredStyleProperties::DeferredStyleProperties(const CSSParserTokenRange&amp; range, CSSDeferredParser&amp; parser)
1623     : StylePropertiesBase(parser.mode(), DeferredPropertiesType)
1624     , m_parser(parser)
1625 {
1626     size_t length = range.end() - range.begin();
1627     m_tokens.reserveCapacity(length);
1628     m_tokens.append(range.begin(), length);
1629 }
1630 
1631 DeferredStyleProperties::~DeferredStyleProperties() = default;
1632 
1633 Ref&lt;ImmutableStyleProperties&gt; DeferredStyleProperties::parseDeferredProperties()
1634 {
1635     return m_parser-&gt;parseDeclaration(m_tokens);
1636 }
1637 
1638 } // namespace WebCore
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>