<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/loader/FrameLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2006-2020 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
   4  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   5  * Copyright (C) 2008 Alp Toker &lt;alp@atoker.com&gt;
   6  * Copyright (C) Research In Motion Limited 2009. All rights reserved.
   7  * Copyright (C) 2011 Kris Jordan &lt;krisjordan@gmail.com&gt;
   8  * Copyright (C) 2011 Google Inc. All rights reserved.
   9  *
  10  * Redistribution and use in source and binary forms, with or without
  11  * modification, are permitted provided that the following conditions
  12  * are met:
  13  *
  14  * 1.  Redistributions of source code must retain the above copyright
  15  *     notice, this list of conditions and the following disclaimer.
  16  * 2.  Redistributions in binary form must reproduce the above copyright
  17  *     notice, this list of conditions and the following disclaimer in the
  18  *     documentation and/or other materials provided with the distribution.
  19  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  20  *     its contributors may be used to endorse or promote products derived
  21  *     from this software without specific prior written permission.
  22  *
  23  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  24  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  27  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  30  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  32  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33  */
  34 
  35 #include &quot;config.h&quot;
  36 #include &quot;FrameLoader.h&quot;
  37 
  38 #include &quot;AXObjectCache.h&quot;
  39 #include &quot;ApplicationCacheHost.h&quot;
  40 #include &quot;BackForwardCache.h&quot;
  41 #include &quot;BackForwardController.h&quot;
  42 #include &quot;BeforeUnloadEvent.h&quot;
  43 #include &quot;CachedPage.h&quot;
  44 #include &quot;CachedResourceLoader.h&quot;
  45 #include &quot;Chrome.h&quot;
  46 #include &quot;ChromeClient.h&quot;
  47 #include &quot;CommonVM.h&quot;
  48 #include &quot;ContentFilter.h&quot;
  49 #include &quot;ContentRuleListResults.h&quot;
  50 #include &quot;ContentSecurityPolicy.h&quot;
  51 #include &quot;CustomHeaderFields.h&quot;
  52 #include &quot;DOMWindow.h&quot;
  53 #include &quot;DatabaseManager.h&quot;
  54 #include &quot;DiagnosticLoggingClient.h&quot;
  55 #include &quot;DiagnosticLoggingKeys.h&quot;
  56 #include &quot;Document.h&quot;
  57 #include &quot;DocumentLoader.h&quot;
  58 #include &quot;Editor.h&quot;
  59 #include &quot;EditorClient.h&quot;
  60 #include &quot;Element.h&quot;
  61 #include &quot;Event.h&quot;
  62 #include &quot;EventHandler.h&quot;
  63 #include &quot;EventNames.h&quot;
  64 #include &quot;FloatRect.h&quot;
  65 #include &quot;FormState.h&quot;
  66 #include &quot;FormSubmission.h&quot;
  67 #include &quot;Frame.h&quot;
  68 #include &quot;FrameLoadRequest.h&quot;
  69 #include &quot;FrameLoaderClient.h&quot;
  70 #include &quot;FrameNetworkingContext.h&quot;
  71 #include &quot;FrameTree.h&quot;
  72 #include &quot;FrameView.h&quot;
  73 #include &quot;GCController.h&quot;
  74 #include &quot;HTMLFormElement.h&quot;
  75 #include &quot;HTMLInputElement.h&quot;
  76 #include &quot;HTMLNames.h&quot;
  77 #include &quot;HTMLObjectElement.h&quot;
  78 #include &quot;HTMLParserIdioms.h&quot;
  79 #include &quot;HTTPHeaderNames.h&quot;
  80 #include &quot;HTTPHeaderValues.h&quot;
  81 #include &quot;HTTPParsers.h&quot;
  82 #include &quot;HistoryController.h&quot;
  83 #include &quot;HistoryItem.h&quot;
  84 #include &quot;IgnoreOpensDuringUnloadCountIncrementer.h&quot;
  85 #include &quot;InspectorController.h&quot;
  86 #include &quot;InspectorInstrumentation.h&quot;
  87 #include &quot;LinkLoader.h&quot;
  88 #include &quot;LoadTiming.h&quot;
  89 #include &quot;LoaderStrategy.h&quot;
  90 #include &quot;Logging.h&quot;
  91 #include &quot;MemoryCache.h&quot;
  92 #include &quot;MemoryRelease.h&quot;
  93 #include &quot;NavigationDisabler.h&quot;
  94 #include &quot;NavigationScheduler.h&quot;
  95 #include &quot;Node.h&quot;
  96 #include &quot;Page.h&quot;
  97 #include &quot;PageTransitionEvent.h&quot;
  98 #include &quot;PerformanceLogging.h&quot;
  99 #include &quot;PlatformStrategies.h&quot;
 100 #include &quot;PluginData.h&quot;
 101 #include &quot;PluginDocument.h&quot;
 102 #include &quot;PolicyChecker.h&quot;
 103 #include &quot;ProgressTracker.h&quot;
 104 #include &quot;ResourceHandle.h&quot;
 105 #include &quot;ResourceLoadInfo.h&quot;
 106 #include &quot;ResourceLoadObserver.h&quot;
 107 #include &quot;ResourceRequest.h&quot;
 108 #include &quot;SVGDocument.h&quot;
 109 #include &quot;SVGLocatable.h&quot;
 110 #include &quot;SVGNames.h&quot;
 111 #include &quot;SVGViewElement.h&quot;
 112 #include &quot;SVGViewSpec.h&quot;
 113 #include &quot;ScriptController.h&quot;
 114 #include &quot;ScriptSourceCode.h&quot;
 115 #include &quot;ScrollAnimator.h&quot;
 116 #include &quot;SecurityOrigin.h&quot;
 117 #include &quot;SecurityPolicy.h&quot;
 118 #include &quot;SegmentedString.h&quot;
 119 #include &quot;SerializedScriptValue.h&quot;
 120 #include &quot;Settings.h&quot;
 121 #include &quot;ShouldTreatAsContinuingLoad.h&quot;
 122 #include &quot;StyleTreeResolver.h&quot;
 123 #include &quot;SubframeLoader.h&quot;
 124 #include &quot;SubresourceLoader.h&quot;
 125 #include &quot;TextResourceDecoder.h&quot;
 126 #include &quot;UserContentController.h&quot;
 127 #include &quot;UserGestureIndicator.h&quot;
 128 #include &quot;WindowFeatures.h&quot;
 129 #include &quot;XMLDocumentParser.h&quot;
 130 #include &lt;dom/ScriptDisallowedScope.h&gt;
 131 #include &lt;wtf/CompletionHandler.h&gt;
 132 #include &lt;wtf/URL.h&gt;
 133 #include &lt;wtf/Ref.h&gt;
 134 #include &lt;wtf/SetForScope.h&gt;
 135 #include &lt;wtf/StdLibExtras.h&gt;
 136 #include &lt;wtf/SystemTracing.h&gt;
 137 #include &lt;wtf/text/CString.h&gt;
 138 #include &lt;wtf/text/WTFString.h&gt;
 139 
 140 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 141 #include &quot;Archive.h&quot;
 142 #endif
 143 
 144 #if ENABLE(DATA_DETECTION)
 145 #include &quot;DataDetection.h&quot;
 146 #endif
 147 
 148 #if PLATFORM(IOS_FAMILY)
 149 #include &quot;DocumentType.h&quot;
 150 #include &quot;ResourceLoader.h&quot;
 151 #include &quot;RuntimeApplicationChecks.h&quot;
 152 #endif
 153 
 154 #define FRAMELOADER_RELEASE_LOG(channel, fmt, ...) RELEASE_LOG(channel, &quot;%p - [frame=%p, main=%d] FrameLoader::&quot; fmt, this, &amp;m_frame, m_frame.isMainFrame(), ##__VA_ARGS__)
 155 #define FRAMELOADER_RELEASE_LOG_ERROR(channel, fmt, ...) RELEASE_LOG(channel, &quot;%p - [frame=%p, main=%d] FrameLoader::&quot; fmt, this, &amp;m_frame, m_frame.isMainFrame(), ##__VA_ARGS__)
 156 #define FRAMELOADER_RELEASE_LOG_IF_ALLOWED(channel, fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), channel, &quot;%p - [frame=%p, main=%d] FrameLoader::&quot; fmt, this, &amp;m_frame, m_frame.isMainFrame(), ##__VA_ARGS__)
 157 #define FRAMELOADER_RELEASE_LOG_ERROR_IF_ALLOWED(channel, fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), channel, &quot;%p - [frame=%p, main=%d] FrameLoader::&quot; fmt, this, &amp;m_frame, m_frame.isMainFrame(), ##__VA_ARGS__)
 158 
 159 namespace WebCore {
 160 
 161 using namespace HTMLNames;
 162 using namespace SVGNames;
 163 
 164 static const char defaultAcceptHeader[] = &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;;
 165 
 166 bool isBackForwardLoadType(FrameLoadType type)
 167 {
 168     switch (type) {
 169     case FrameLoadType::Standard:
 170     case FrameLoadType::Reload:
 171     case FrameLoadType::ReloadFromOrigin:
 172     case FrameLoadType::ReloadExpiredOnly:
 173     case FrameLoadType::Same:
 174     case FrameLoadType::RedirectWithLockedBackForwardList:
 175     case FrameLoadType::Replace:
 176         return false;
 177     case FrameLoadType::Back:
 178     case FrameLoadType::Forward:
 179     case FrameLoadType::IndexedBackForward:
 180         return true;
 181     }
 182     ASSERT_NOT_REACHED();
 183     return false;
 184 }
 185 
 186 bool isReload(FrameLoadType type)
 187 {
 188     switch (type) {
 189     case FrameLoadType::Reload:
 190     case FrameLoadType::ReloadFromOrigin:
 191     case FrameLoadType::ReloadExpiredOnly:
 192         return true;
 193     case FrameLoadType::Standard:
 194     case FrameLoadType::Same:
 195     case FrameLoadType::RedirectWithLockedBackForwardList:
 196     case FrameLoadType::Replace:
 197     case FrameLoadType::Back:
 198     case FrameLoadType::Forward:
 199     case FrameLoadType::IndexedBackForward:
 200         return false;
 201     }
 202     ASSERT_NOT_REACHED();
 203     return false;
 204 }
 205 
 206 // This is not in the FrameLoader class to emphasize that it does not depend on
 207 // private FrameLoader data, and to avoid increasing the number of public functions
 208 // with access to private data.  Since only this .cpp file needs it, making it
 209 // non-member lets us exclude it from the header file, thus keeping FrameLoader.h&#39;s
 210 // API simpler.
 211 //
 212 static bool isDocumentSandboxed(Frame&amp; frame, SandboxFlags mask)
 213 {
 214     return frame.document() &amp;&amp; frame.document()-&gt;isSandboxed(mask);
 215 }
 216 
 217 class PageLevelForbidScope {
 218 protected:
 219     explicit PageLevelForbidScope(Page* page)
 220         : m_page(makeWeakPtr(page))
 221     {
 222     }
 223 
 224     ~PageLevelForbidScope() = default;
 225 
 226     WeakPtr&lt;Page&gt; m_page;
 227 };
 228 
 229 struct ForbidPromptsScope : public PageLevelForbidScope {
 230     explicit ForbidPromptsScope(Page* page)
 231         : PageLevelForbidScope(page)
 232     {
 233         if (m_page)
 234             m_page-&gt;forbidPrompts();
 235     }
 236 
 237     ~ForbidPromptsScope()
 238     {
 239         if (m_page)
 240             m_page-&gt;allowPrompts();
 241     }
 242 };
 243 
 244 struct ForbidSynchronousLoadsScope : public PageLevelForbidScope {
 245     explicit ForbidSynchronousLoadsScope(Page* page)
 246         : PageLevelForbidScope(page)
 247     {
 248         if (m_page)
 249             m_page-&gt;forbidSynchronousLoads();
 250     }
 251 
 252     ~ForbidSynchronousLoadsScope()
 253     {
 254         if (m_page)
 255             m_page-&gt;allowSynchronousLoads();
 256     }
 257 };
 258 
 259 class FrameLoader::FrameProgressTracker {
 260     WTF_MAKE_FAST_ALLOCATED;
 261 public:
 262     explicit FrameProgressTracker(Frame&amp; frame)
 263         : m_frame(frame)
 264         , m_inProgress(false)
 265     {
 266     }
 267 
 268     ~FrameProgressTracker()
 269     {
 270         if (m_inProgress &amp;&amp; m_frame.page())
 271             m_frame.page()-&gt;progress().progressCompleted(m_frame);
 272     }
 273 
 274     void progressStarted()
 275     {
 276         ASSERT(m_frame.page());
 277         if (!m_inProgress)
 278             m_frame.page()-&gt;progress().progressStarted(m_frame);
 279         m_inProgress = true;
 280     }
 281 
 282     void progressCompleted()
 283     {
 284         ASSERT(m_inProgress);
 285         ASSERT(m_frame.page());
 286         m_inProgress = false;
 287         m_frame.page()-&gt;progress().progressCompleted(m_frame);
 288         platformStrategies()-&gt;loaderStrategy()-&gt;pageLoadCompleted(*m_frame.page());
 289     }
 290 
 291 private:
 292     Frame&amp; m_frame;
 293     bool m_inProgress;
 294 };
 295 
 296 FrameLoader::FrameLoader(Frame&amp; frame, FrameLoaderClient&amp; client)
 297     : m_frame(frame)
 298     , m_client(client)
 299     , m_policyChecker(makeUnique&lt;PolicyChecker&gt;(frame))
 300     , m_history(makeUnique&lt;HistoryController&gt;(frame))
 301     , m_notifier(frame)
 302     , m_subframeLoader(makeUnique&lt;SubframeLoader&gt;(frame))
 303     , m_mixedContentChecker(frame)
 304     , m_state(FrameStateProvisional)
 305     , m_loadType(FrameLoadType::Standard)
 306     , m_quickRedirectComing(false)
 307     , m_sentRedirectNotification(false)
 308     , m_inStopAllLoaders(false)
 309     , m_isExecutingJavaScriptFormAction(false)
 310     , m_didCallImplicitClose(true)
 311     , m_wasUnloadEventEmitted(false)
 312     , m_isComplete(false)
 313     , m_needsClear(false)
 314     , m_checkTimer(*this, &amp;FrameLoader::checkTimerFired)
 315     , m_shouldCallCheckCompleted(false)
 316     , m_shouldCallCheckLoadComplete(false)
 317     , m_opener(nullptr)
 318     , m_loadingFromCachedPage(false)
 319     , m_currentNavigationHasShownBeforeUnloadConfirmPanel(false)
 320     , m_loadsSynchronously(false)
 321     , m_forcedSandboxFlags(SandboxNone)
 322 {
 323 }
 324 
 325 FrameLoader::~FrameLoader()
 326 {
 327     setOpener(nullptr);
 328     detachFromAllOpenedFrames();
 329 
 330     m_client.frameLoaderDestroyed();
 331 
 332     if (m_networkingContext)
 333         m_networkingContext-&gt;invalidate();
 334 }
 335 
 336 void FrameLoader::detachFromAllOpenedFrames()
 337 {
 338     for (auto&amp; frame : m_openedFrames)
 339         frame-&gt;loader().m_opener = nullptr;
 340     m_openedFrames.clear();
 341 }
 342 
 343 void FrameLoader::init()
 344 {
 345     // This somewhat odd set of steps gives the frame an initial empty document.
 346     setPolicyDocumentLoader(m_client.createDocumentLoader(ResourceRequest(URL({ }, emptyString())), SubstituteData()).ptr());
 347     setProvisionalDocumentLoader(m_policyDocumentLoader.get());
 348     m_provisionalDocumentLoader-&gt;startLoadingMainResource();
 349 
 350     Ref&lt;Frame&gt; protect(m_frame);
 351     m_frame.document()-&gt;cancelParsing();
 352     m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocument);
 353 
 354     m_networkingContext = m_client.createNetworkingContext();
 355     m_progressTracker = makeUnique&lt;FrameProgressTracker&gt;(m_frame);
 356 }
 357 
 358 void FrameLoader::initForSynthesizedDocument(const URL&amp;)
 359 {
 360     // FIXME: We need to initialize the document URL to the specified URL. Currently the URL is empty and hence
 361     // FrameLoader::checkCompleted() will overwrite the URL of the document to be activeDocumentLoader()-&gt;documentURL().
 362 
 363     auto loader = m_client.createDocumentLoader(ResourceRequest(URL({ }, emptyString())), SubstituteData());
 364     loader-&gt;attachToFrame(m_frame);
 365     loader-&gt;setResponse(ResourceResponse(URL(), &quot;text/html&quot;_s, 0, String()));
 366     loader-&gt;setCommitted(true);
 367     setDocumentLoader(loader.ptr());
 368 
 369     m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocument);
 370     m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocumentPostCommit);
 371     m_stateMachine.advanceTo(FrameLoaderStateMachine::CommittedFirstRealLoad);
 372     m_client.transitionToCommittedForNewPage();
 373 
 374     m_didCallImplicitClose = true;
 375     m_isComplete = true;
 376     m_state = FrameStateComplete;
 377     m_needsClear = true;
 378 
 379     m_networkingContext = m_client.createNetworkingContext();
 380     m_progressTracker = makeUnique&lt;FrameProgressTracker&gt;(m_frame);
 381 }
 382 
 383 void FrameLoader::setDefersLoading(bool defers)
 384 {
 385     if (m_documentLoader)
 386         m_documentLoader-&gt;setDefersLoading(defers);
 387     if (m_provisionalDocumentLoader)
 388         m_provisionalDocumentLoader-&gt;setDefersLoading(defers);
 389     if (m_policyDocumentLoader)
 390         m_policyDocumentLoader-&gt;setDefersLoading(defers);
 391     history().setDefersLoading(defers);
 392 
 393     if (!defers) {
 394         m_frame.navigationScheduler().startTimer();
 395         startCheckCompleteTimer();
 396     }
 397 }
 398 
 399 void FrameLoader::checkContentPolicy(const ResourceResponse&amp; response, PolicyCheckIdentifier identifier, ContentPolicyDecisionFunction&amp;&amp; function)
 400 {
 401     if (!activeDocumentLoader()) {
 402         // Load was cancelled
 403         function(PolicyAction::Ignore, identifier);
 404         return;
 405     }
 406 
 407     // FIXME: Validate the policy check identifier.
 408     client().dispatchDecidePolicyForResponse(response, activeDocumentLoader()-&gt;request(), identifier, activeDocumentLoader()-&gt;downloadAttribute(), WTFMove(function));
 409 }
 410 
 411 void FrameLoader::changeLocation(FrameLoadRequest&amp;&amp; request)
 412 {
 413     urlSelected(WTFMove(request), nullptr);
 414 }
 415 
 416 void FrameLoader::urlSelected(const URL&amp; url, const String&amp; passedTarget, Event* triggeringEvent, LockHistory lockHistory, LockBackForwardList lockBackForwardList, ShouldSendReferrer shouldSendReferrer, ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy, Optional&lt;NewFrameOpenerPolicy&gt; openerPolicy, const AtomString&amp; downloadAttribute, const SystemPreviewInfo&amp; systemPreviewInfo, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)
 417 {
 418     auto* frame = lexicalFrameFromCommonVM();
 419     auto initiatedByMainFrame = frame &amp;&amp; frame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
 420 
 421     NewFrameOpenerPolicy newFrameOpenerPolicy = openerPolicy.valueOr(shouldSendReferrer == NeverSendReferrer ? NewFrameOpenerPolicy::Suppress : NewFrameOpenerPolicy::Allow);
 422     urlSelected(FrameLoadRequest(*m_frame.document(), m_frame.document()-&gt;securityOrigin(), { url }, passedTarget, lockHistory, lockBackForwardList, shouldSendReferrer, AllowNavigationToInvalidURL::Yes, newFrameOpenerPolicy, shouldOpenExternalURLsPolicy, initiatedByMainFrame, DoNotReplaceDocumentIfJavaScriptURL, downloadAttribute, systemPreviewInfo), triggeringEvent, WTFMove(adClickAttribution));
 423 }
 424 
 425 void FrameLoader::urlSelected(FrameLoadRequest&amp;&amp; frameRequest, Event* triggeringEvent, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)
 426 {
 427     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;urlSelected: frame load started&quot;);
 428 
 429     Ref&lt;Frame&gt; protect(m_frame);
 430 
 431     if (m_frame.script().executeIfJavaScriptURL(frameRequest.resourceRequest().url(), &amp;frameRequest.requester().securityOrigin(), frameRequest.shouldReplaceDocumentIfJavaScriptURL())) {
 432         m_quickRedirectComing = false;
 433         return;
 434     }
 435 
 436     if (frameRequest.frameName().isEmpty())
 437         frameRequest.setFrameName(m_frame.document()-&gt;baseTarget());
 438 
 439     addHTTPOriginIfNeeded(frameRequest.resourceRequest(), outgoingOrigin());
 440     m_frame.document()-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(frameRequest.resourceRequest(), ContentSecurityPolicy::InsecureRequestType::Navigation);
 441 
 442     loadFrameRequest(WTFMove(frameRequest), triggeringEvent, { }, WTFMove(adClickAttribution));
 443 }
 444 
 445 void FrameLoader::submitForm(Ref&lt;FormSubmission&gt;&amp;&amp; submission)
 446 {
 447     ASSERT(submission-&gt;method() == FormSubmission::Method::Post || submission-&gt;method() == FormSubmission::Method::Get);
 448 
 449     // FIXME: Find a good spot for these.
 450     ASSERT(!submission-&gt;state().sourceDocument().frame() || submission-&gt;state().sourceDocument().frame() == &amp;m_frame);
 451 
 452     if (!m_frame.page())
 453         return;
 454 
 455     if (submission-&gt;action().isEmpty())
 456         return;
 457 
 458     if (isDocumentSandboxed(m_frame, SandboxForms)) {
 459         // FIXME: This message should be moved off the console once a solution to https://bugs.webkit.org/show_bug.cgi?id=103274 exists.
 460         m_frame.document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Blocked form submission to &#39;&quot; + submission-&gt;action().stringCenterEllipsizedToLength() + &quot;&#39; because the form&#39;s frame is sandboxed and the &#39;allow-forms&#39; permission is not set.&quot;);
 461         return;
 462     }
 463 
<a name="2" id="anc2"></a><span class="line-modified"> 464     URL formAction = submission-&gt;action();</span>
<span class="line-modified"> 465     if (!m_frame.document()-&gt;contentSecurityPolicy()-&gt;allowFormAction(formAction))</span>
<span class="line-modified"> 466         return;</span>
<span class="line-added"> 467 </span>
<span class="line-added"> 468     if (WTF::protocolIsJavaScript(formAction)) {</span>
 469         m_isExecutingJavaScriptFormAction = true;
 470         Ref&lt;Frame&gt; protect(m_frame);
 471         m_frame.script().executeIfJavaScriptURL(submission-&gt;action(), nullptr, DoNotReplaceDocumentIfJavaScriptURL);
 472         m_isExecutingJavaScriptFormAction = false;
 473         return;
 474     }
 475 
 476     Frame* targetFrame = findFrameForNavigation(submission-&gt;target(), &amp;submission-&gt;state().sourceDocument());
 477     if (!targetFrame) {
 478         if (!DOMWindow::allowPopUp(m_frame) &amp;&amp; !UserGestureIndicator::processingUserGesture())
 479             return;
 480 
 481         // FIXME: targetFrame can be null for two distinct reasons:
 482         // 1. The frame was not found by name, so we should try opening a new window.
 483         // 2. The frame was found, but navigating it was not allowed, e.g. by HTML5 sandbox or by origin checks.
 484         // Continuing form submission makes no sense in the latter case.
 485         // There is a repeat check after timer fires, so this is not a correctness issue.
 486 
 487         targetFrame = &amp;m_frame;
 488     } else
 489         submission-&gt;clearTarget();
 490 
 491     if (!targetFrame-&gt;page())
 492         return;
 493 
 494     if (m_frame.tree().isDescendantOf(targetFrame))
 495         m_submittedFormURL = submission-&gt;requestURL();
 496 
 497     submission-&gt;setReferrer(outgoingReferrer());
 498     submission-&gt;setOrigin(outgoingOrigin());
 499 
 500     targetFrame-&gt;navigationScheduler().scheduleFormSubmission(WTFMove(submission));
 501 }
 502 
 503 void FrameLoader::stopLoading(UnloadEventPolicy unloadEventPolicy)
 504 {
 505     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;parser())
 506         m_frame.document()-&gt;parser()-&gt;stopParsing();
 507 
 508     if (unloadEventPolicy != UnloadEventPolicyNone)
 509         dispatchUnloadEvents(unloadEventPolicy);
 510 
 511     m_isComplete = true; // to avoid calling completed() in finishedParsing()
 512     m_didCallImplicitClose = true; // don&#39;t want that one either
 513 
 514     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;parsing()) {
 515         finishedParsing();
 516         m_frame.document()-&gt;setParsing(false);
 517     }
 518 
 519     if (auto* document = m_frame.document()) {
 520         // FIXME: Should the DatabaseManager watch for something like ActiveDOMObject::stop() rather than being special-cased here?
 521         DatabaseManager::singleton().stopDatabases(*document, nullptr);
 522     }
 523 
 524     policyChecker().stopCheck();
 525 
 526     // FIXME: This will cancel redirection timer, which really needs to be restarted when restoring the frame from b/f cache.
 527     m_frame.navigationScheduler().cancel();
 528 }
 529 
 530 void FrameLoader::stop()
 531 {
 532     // http://bugs.webkit.org/show_bug.cgi?id=10854
 533     // The frame&#39;s last ref may be removed and it will be deleted by checkCompleted().
 534     Ref&lt;Frame&gt; protect(m_frame);
 535 
 536     if (DocumentParser* parser = m_frame.document()-&gt;parser()) {
 537         parser-&gt;stopParsing();
 538         parser-&gt;finish();
 539     }
 540 }
 541 
 542 void FrameLoader::willTransitionToCommitted()
 543 {
 544     // This function is called when a frame is still fully in place (not cached, not detached), but will be replaced.
 545 
 546     if (m_frame.editor().hasComposition()) {
 547         // The text was already present in DOM, so it&#39;s better to confirm than to cancel the composition.
 548         m_frame.editor().confirmComposition();
 549         if (EditorClient* editorClient = m_frame.editor().client()) {
 550             editorClient-&gt;respondToChangedSelection(&amp;m_frame);
 551             editorClient-&gt;discardedComposition(&amp;m_frame);
 552         }
 553     }
 554 }
 555 
 556 bool FrameLoader::closeURL()
 557 {
 558     history().saveDocumentState();
 559 
 560     Document* currentDocument = m_frame.document();
 561     UnloadEventPolicy unloadEventPolicy;
 562     if (m_frame.page() &amp;&amp; m_frame.page()-&gt;chrome().client().isSVGImageChromeClient()) {
 563         // If this is the SVGDocument of an SVGImage, no need to dispatch events or recalcStyle.
 564         unloadEventPolicy = UnloadEventPolicyNone;
 565     } else {
 566         // Should only send the pagehide event here if the current document exists and has not been placed in the back/forward cache.
 567         unloadEventPolicy = currentDocument &amp;&amp; currentDocument-&gt;backForwardCacheState() == Document::NotInBackForwardCache ? UnloadEventPolicyUnloadAndPageHide : UnloadEventPolicyUnloadOnly;
 568     }
 569 
 570     stopLoading(unloadEventPolicy);
 571 
 572     m_frame.editor().clearUndoRedoOperations();
 573     return true;
 574 }
 575 
 576 bool FrameLoader::didOpenURL()
 577 {
 578     if (m_frame.navigationScheduler().redirectScheduledDuringLoad()) {
 579         // A redirect was scheduled before the document was created.
 580         // This can happen when one frame changes another frame&#39;s location.
 581         return false;
 582     }
 583 
 584     m_frame.navigationScheduler().cancel();
 585     m_frame.editor().clearLastEditCommand();
 586 
 587     m_isComplete = false;
 588     m_didCallImplicitClose = false;
 589 
 590     // If we are still in the process of initializing an empty document then
 591     // its frame is not in a consistent state for rendering, so avoid setJSStatusBarText
 592     // since it may cause clients to attempt to render the frame.
 593     if (!m_stateMachine.creatingInitialEmptyDocument()) {
 594         DOMWindow* window = m_frame.document()-&gt;domWindow();
 595         window-&gt;setStatus(String());
 596         window-&gt;setDefaultStatus(String());
 597     }
 598 
 599     started();
 600 
 601     return true;
 602 }
 603 
 604 void FrameLoader::didExplicitOpen()
 605 {
 606     m_isComplete = false;
 607     m_didCallImplicitClose = false;
 608 
 609     // Calling document.open counts as committing the first real document load.
 610     if (!m_stateMachine.committedFirstRealDocumentLoad())
 611         m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocumentPostCommit);
 612 
 613     if (auto* document = m_frame.document())
 614         m_client.dispatchDidExplicitOpen(document-&gt;url(), document-&gt;contentType());
 615 
 616     // Prevent window.open(url) -- eg window.open(&quot;about:blank&quot;) -- from blowing away results
 617     // from a subsequent window.document.open / window.document.write call.
 618     // Canceling redirection here works for all cases because document.open
 619     // implicitly precedes document.write.
 620     m_frame.navigationScheduler().cancel();
 621 }
 622 
 623 
 624 void FrameLoader::cancelAndClear()
 625 {
 626     m_frame.navigationScheduler().cancel();
 627 
 628     if (!m_isComplete)
 629         closeURL();
 630 
 631     clear(m_frame.document(), false);
 632     m_frame.script().updatePlatformScriptObjects();
 633 }
 634 
 635 static inline bool shouldClearWindowName(const Frame&amp; frame, const Document&amp; newDocument)
 636 {
 637     if (!frame.isMainFrame())
 638         return false;
 639 
 640     if (frame.loader().opener())
 641         return false;
 642 
 643     return !newDocument.securityOrigin().isSameOriginAs(frame.document()-&gt;securityOrigin());
 644 }
 645 
 646 void FrameLoader::clear(Document* newDocument, bool clearWindowProperties, bool clearScriptObjects, bool clearFrameView, WTF::Function&lt;void()&gt;&amp;&amp; handleDOMWindowCreation)
 647 {
 648     m_frame.editor().clear();
 649 
 650     bool neededClear = m_needsClear;
 651     m_needsClear = false;
 652 
 653     if (neededClear &amp;&amp; m_frame.document()-&gt;backForwardCacheState() != Document::InBackForwardCache) {
 654         m_frame.document()-&gt;cancelParsing();
 655         m_frame.document()-&gt;stopActiveDOMObjects();
 656         bool hadLivingRenderTree = m_frame.document()-&gt;hasLivingRenderTree();
 657         m_frame.document()-&gt;prepareForDestruction();
 658         if (hadLivingRenderTree)
 659             m_frame.document()-&gt;adjustFocusedNodeOnNodeRemoval(*m_frame.document());
 660     }
 661 
 662     if (handleDOMWindowCreation)
 663         handleDOMWindowCreation();
 664 
 665     if (!neededClear)
 666         return;
 667 
 668     // Do this after detaching the document so that the unload event works.
 669     if (clearWindowProperties) {
 670         InspectorInstrumentation::frameWindowDiscarded(m_frame, m_frame.document()-&gt;domWindow());
 671         m_frame.document()-&gt;domWindow()-&gt;resetUnlessSuspendedForDocumentSuspension();
 672         m_frame.windowProxy().clearJSWindowProxiesNotMatchingDOMWindow(newDocument-&gt;domWindow(), m_frame.document()-&gt;backForwardCacheState() == Document::AboutToEnterBackForwardCache);
 673 
 674         if (shouldClearWindowName(m_frame, *newDocument))
 675             m_frame.tree().setName(nullAtom());
 676     }
 677 
 678     m_frame.selection().prepareForDestruction();
 679     m_frame.eventHandler().clear();
 680 
 681     if (clearFrameView &amp;&amp; m_frame.view())
 682         m_frame.view()-&gt;clear();
 683 
 684     // Do not drop the document before the ScriptController and view are cleared
 685     // as some destructors might still try to access the document.
 686     m_frame.setDocument(nullptr);
 687 
 688     subframeLoader().clear();
 689 
 690     if (clearWindowProperties)
 691         m_frame.windowProxy().setDOMWindow(newDocument-&gt;domWindow());
 692 
 693     if (clearScriptObjects)
 694         m_frame.script().clearScriptObjects();
 695 
 696     m_frame.script().enableEval();
 697 
 698     m_frame.navigationScheduler().clear();
 699 
 700     m_checkTimer.stop();
 701     m_shouldCallCheckCompleted = false;
 702     m_shouldCallCheckLoadComplete = false;
 703 
 704     if (m_stateMachine.isDisplayingInitialEmptyDocument() &amp;&amp; m_stateMachine.committedFirstRealDocumentLoad())
 705         m_stateMachine.advanceTo(FrameLoaderStateMachine::CommittedFirstRealLoad);
 706 }
 707 
 708 void FrameLoader::receivedFirstData()
 709 {
 710     dispatchDidCommitLoad(WTF::nullopt);
 711     dispatchDidClearWindowObjectsInAllWorlds();
 712     dispatchGlobalObjectAvailableInAllWorlds();
 713 
 714     if (!m_documentLoader)
 715         return;
 716 
 717     auto&amp; documentLoader = *m_documentLoader;
 718     auto&amp; title = documentLoader.title();
 719     if (!title.string.isNull())
 720         m_client.dispatchDidReceiveTitle(title);
 721 
 722     ASSERT(m_frame.document());
 723     auto&amp; document = *m_frame.document();
 724 
 725     LinkLoader::loadLinksFromHeader(documentLoader.response().httpHeaderField(HTTPHeaderName::Link), document.url(), document, LinkLoader::MediaAttributeCheck::MediaAttributeEmpty);
 726 
 727     double delay;
 728     String urlString;
 729     if (!parseMetaHTTPEquivRefresh(documentLoader.response().httpHeaderField(HTTPHeaderName::Refresh), delay, urlString))
 730         return;
 731     auto completedURL = urlString.isEmpty() ? document.url() : document.completeURL(urlString);
 732     if (!WTF::protocolIsJavaScript(completedURL))
 733         m_frame.navigationScheduler().scheduleRedirect(document, delay, completedURL);
 734     else {
 735         auto message = &quot;Refused to refresh &quot; + document.url().stringCenterEllipsizedToLength() + &quot; to a javascript: URL&quot;;
 736         document.addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
 737     }
 738 }
 739 
 740 void FrameLoader::setOutgoingReferrer(const URL&amp; url)
 741 {
 742     m_outgoingReferrer = url.strippedForUseAsReferrer();
 743 }
 744 
 745 void FrameLoader::didBeginDocument(bool dispatch)
 746 {
 747     m_needsClear = true;
 748     m_isComplete = false;
 749     m_didCallImplicitClose = false;
 750     m_frame.document()-&gt;setReadyState(Document::Loading);
 751 
 752     if (m_pendingStateObject) {
 753         m_frame.document()-&gt;statePopped(*m_pendingStateObject);
 754         m_pendingStateObject = nullptr;
 755     }
 756 
 757     if (dispatch)
 758         dispatchDidClearWindowObjectsInAllWorlds();
 759 
 760     updateFirstPartyForCookies();
 761     m_frame.document()-&gt;initContentSecurityPolicy();
 762 
 763     const Settings&amp; settings = m_frame.settings();
 764     m_frame.document()-&gt;cachedResourceLoader().setImagesEnabled(settings.areImagesEnabled());
 765     m_frame.document()-&gt;cachedResourceLoader().setAutoLoadImages(settings.loadsImagesAutomatically());
 766 
 767     if (m_documentLoader) {
 768         String dnsPrefetchControl = m_documentLoader-&gt;response().httpHeaderField(HTTPHeaderName::XDNSPrefetchControl);
 769         if (!dnsPrefetchControl.isEmpty())
 770             m_frame.document()-&gt;parseDNSPrefetchControlHeader(dnsPrefetchControl);
 771 
 772         m_frame.document()-&gt;contentSecurityPolicy()-&gt;didReceiveHeaders(ContentSecurityPolicyResponseHeaders(m_documentLoader-&gt;response()), referrer(), ContentSecurityPolicy::ReportParsingErrors::No);
 773 
 774         String referrerPolicy = m_documentLoader-&gt;response().httpHeaderField(HTTPHeaderName::ReferrerPolicy);
 775         if (!referrerPolicy.isNull())
 776             m_frame.document()-&gt;processReferrerPolicy(referrerPolicy, ReferrerPolicySource::HTTPHeader);
 777 
 778         String headerContentLanguage = m_documentLoader-&gt;response().httpHeaderField(HTTPHeaderName::ContentLanguage);
 779         if (!headerContentLanguage.isEmpty()) {
 780             size_t commaIndex = headerContentLanguage.find(&#39;,&#39;);
 781             headerContentLanguage.truncate(commaIndex); // notFound == -1 == don&#39;t truncate
 782             headerContentLanguage = stripLeadingAndTrailingHTMLSpaces(headerContentLanguage);
 783             if (!headerContentLanguage.isEmpty())
 784                 m_frame.document()-&gt;setContentLanguage(headerContentLanguage);
 785         }
 786     }
 787 
 788     history().restoreDocumentState();
 789 }
 790 
 791 void FrameLoader::finishedParsing()
 792 {
 793     LOG(Loading, &quot;WebCoreLoading %s: Finished parsing&quot;, m_frame.tree().uniqueName().string().utf8().data());
 794 
 795     m_frame.injectUserScripts(InjectAtDocumentEnd);
 796 
 797     if (m_stateMachine.creatingInitialEmptyDocument())
 798         return;
 799 
 800     // This can be called from the Frame&#39;s destructor, in which case we shouldn&#39;t protect ourselves
 801     // because doing so will cause us to re-enter the destructor when protector goes out of scope.
 802     // Null-checking the FrameView indicates whether or not we&#39;re in the destructor.
 803     RefPtr&lt;Frame&gt; protector = m_frame.view() ? &amp;m_frame : 0;
 804 
 805     m_client.dispatchDidFinishDocumentLoad();
 806 
 807     scrollToFragmentWithParentBoundary(m_frame.document()-&gt;url());
 808 
 809     checkCompleted();
 810 
 811     if (!m_frame.view())
 812         return; // We are being destroyed by something checkCompleted called.
 813 
 814     // Check if the scrollbars are really needed for the content.
 815     // If not, remove them, relayout, and repaint.
 816     m_frame.view()-&gt;restoreScrollbar();
 817 }
 818 
 819 void FrameLoader::loadDone(LoadCompletionType type)
 820 {
 821     if (type == LoadCompletionType::Finish)
 822         checkCompleted();
 823     else
 824         scheduleCheckCompleted();
 825 }
 826 
 827 void FrameLoader::subresourceLoadDone(LoadCompletionType type)
 828 {
 829     if (type == LoadCompletionType::Finish)
 830         checkLoadComplete();
 831     else
 832         scheduleCheckLoadComplete();
 833 }
 834 
 835 bool FrameLoader::allChildrenAreComplete() const
 836 {
 837     for (Frame* child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling()) {
 838         if (!child-&gt;loader().m_isComplete)
 839             return false;
 840     }
 841     return true;
 842 }
 843 
 844 bool FrameLoader::allAncestorsAreComplete() const
 845 {
 846     for (Frame* ancestor = &amp;m_frame; ancestor; ancestor = ancestor-&gt;tree().parent()) {
 847         if (!ancestor-&gt;loader().m_isComplete)
 848             return false;
 849     }
 850     return true;
 851 }
 852 
 853 void FrameLoader::checkCompleted()
 854 {
 855     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
 856     m_shouldCallCheckCompleted = false;
 857 
 858     // Have we completed before?
 859     if (m_isComplete)
 860         return;
 861 
 862     // FIXME: It would be better if resource loads were kicked off after render tree update (or didn&#39;t complete synchronously).
 863     //        https://bugs.webkit.org/show_bug.cgi?id=171729
 864     if (m_frame.document()-&gt;inRenderTreeUpdate()) {
 865         scheduleCheckCompleted();
 866         return;
 867     }
 868 
 869     // Are we still parsing?
 870     if (m_frame.document()-&gt;parsing())
 871         return;
 872 
 873     // Still waiting for images/scripts?
 874     if (m_frame.document()-&gt;cachedResourceLoader().requestCount())
 875         return;
 876 
 877     // Still waiting for elements that don&#39;t go through a FrameLoader?
 878     if (m_frame.document()-&gt;isDelayingLoadEvent())
 879         return;
 880 
 881     auto* scriptableParser = m_frame.document()-&gt;scriptableDocumentParser();
 882     if (scriptableParser &amp;&amp; scriptableParser-&gt;hasScriptsWaitingForStylesheets())
 883         return;
 884 
 885     // Any frame that hasn&#39;t completed yet?
 886     if (!allChildrenAreComplete())
 887         return;
 888 
 889     // Important not to protect earlier in this function, because earlier parts
 890     // of this function can be called in the frame&#39;s destructor, and it&#39;s not legal
 891     // to ref an object while it&#39;s being destroyed.
 892     Ref&lt;Frame&gt; protect(m_frame);
 893 
 894     // OK, completed.
 895     m_isComplete = true;
 896     m_requestedHistoryItem = nullptr;
 897     m_frame.document()-&gt;setReadyState(Document::Complete);
 898 
 899     checkCallImplicitClose(); // if we didn&#39;t do it before
 900 
 901     m_frame.navigationScheduler().startTimer();
 902 
 903     completed();
 904     if (m_frame.page())
 905         checkLoadComplete();
 906 }
 907 
 908 void FrameLoader::checkTimerFired()
 909 {
 910     checkCompletenessNow();
 911 }
 912 
 913 void FrameLoader::checkCompletenessNow()
 914 {
 915     Ref&lt;Frame&gt; protect(m_frame);
 916 
 917     if (Page* page = m_frame.page()) {
 918         if (page-&gt;defersLoading())
 919             return;
 920     }
 921     if (m_shouldCallCheckCompleted)
 922         checkCompleted();
 923     if (m_shouldCallCheckLoadComplete)
 924         checkLoadComplete();
 925 }
 926 
 927 void FrameLoader::startCheckCompleteTimer()
 928 {
 929     if (!(m_shouldCallCheckCompleted || m_shouldCallCheckLoadComplete))
 930         return;
 931     if (m_checkTimer.isActive())
 932         return;
 933     m_checkTimer.startOneShot(0_s);
 934 }
 935 
 936 void FrameLoader::scheduleCheckCompleted()
 937 {
 938     m_shouldCallCheckCompleted = true;
 939     startCheckCompleteTimer();
 940 }
 941 
 942 void FrameLoader::scheduleCheckLoadComplete()
 943 {
 944     m_shouldCallCheckLoadComplete = true;
 945     startCheckCompleteTimer();
 946 }
 947 
 948 void FrameLoader::checkCallImplicitClose()
 949 {
 950     if (m_didCallImplicitClose || m_frame.document()-&gt;parsing() || m_frame.document()-&gt;isDelayingLoadEvent())
 951         return;
 952 
 953     if (!allChildrenAreComplete())
 954         return; // still got a frame running -&gt; too early
 955 
 956     m_didCallImplicitClose = true;
 957     m_wasUnloadEventEmitted = false;
 958     m_frame.document()-&gt;implicitClose();
 959 }
 960 
 961 void FrameLoader::loadURLIntoChildFrame(const URL&amp; url, const String&amp; referer, Frame* childFrame)
 962 {
 963     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadURLIntoChildFrame: frame load started&quot;);
 964 
 965     ASSERT(childFrame);
 966 
 967 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 968     if (auto activeLoader = activeDocumentLoader()) {
 969         if (auto subframeArchive = activeLoader-&gt;popArchiveForSubframe(childFrame-&gt;tree().uniqueName(), url)) {
 970             childFrame-&gt;loader().loadArchive(RefPtr&lt;Archive&gt; { subframeArchive }.releaseNonNull());
 971             return;
 972         }
 973     }
 974 #endif
 975 
 976     // If we&#39;re moving in the back/forward list, we might want to replace the content
 977     // of this child frame with whatever was there at that point.
 978     auto* parentItem = history().currentItem();
 979     if (parentItem &amp;&amp; parentItem-&gt;children().size() &amp;&amp; isBackForwardLoadType(loadType()) &amp;&amp; !m_frame.document()-&gt;loadEventFinished()) {
 980         if (auto* childItem = parentItem-&gt;childItemWithTarget(childFrame-&gt;tree().uniqueName())) {
 981             childFrame-&gt;loader().m_requestedHistoryItem = childItem;
 982             childFrame-&gt;loader().loadDifferentDocumentItem(*childItem, nullptr, loadType(), MayAttemptCacheOnlyLoadForFormSubmissionItem, ShouldTreatAsContinuingLoad::No);
 983             return;
 984         }
 985     }
 986 
 987     auto* lexicalFrame = lexicalFrameFromCommonVM();
 988     auto initiatedByMainFrame = lexicalFrame &amp;&amp; lexicalFrame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
 989 
 990     FrameLoadRequest frameLoadRequest { *m_frame.document(), m_frame.document()-&gt;securityOrigin(), { url }, &quot;_self&quot;_s, LockHistory::No, LockBackForwardList::Yes, ShouldSendReferrer::MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Suppress, ShouldOpenExternalURLsPolicy::ShouldNotAllow, initiatedByMainFrame };
 991     childFrame-&gt;loader().loadURL(WTFMove(frameLoadRequest), referer, FrameLoadType::RedirectWithLockedBackForwardList, nullptr, { }, WTF::nullopt, [] { });
 992 }
 993 
 994 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 995 
 996 void FrameLoader::loadArchive(Ref&lt;Archive&gt;&amp;&amp; archive)
 997 {
 998     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadArchive: frame load started&quot;);
 999 
1000     ArchiveResource* mainResource = archive-&gt;mainResource();
1001     ASSERT(mainResource);
1002     if (!mainResource)
1003         return;
1004 
1005     ResourceResponse response(URL(), mainResource-&gt;mimeType(), mainResource-&gt;data().size(), mainResource-&gt;textEncoding());
1006     SubstituteData substituteData(&amp;mainResource-&gt;data(), URL(), response, SubstituteData::SessionHistoryVisibility::Hidden);
1007 
1008     ResourceRequest request(mainResource-&gt;url());
1009 
1010     auto documentLoader = m_client.createDocumentLoader(request, substituteData);
1011     documentLoader-&gt;setArchive(WTFMove(archive));
1012     load(documentLoader.get());
1013 }
1014 
1015 #endif // ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1016 
1017 String FrameLoader::outgoingReferrer() const
1018 {
1019     // See http://www.whatwg.org/specs/web-apps/current-work/#fetching-resources
1020     // for why we walk the parent chain for srcdoc documents.
1021     Frame* frame = &amp;m_frame;
1022     while (frame &amp;&amp; frame-&gt;document()-&gt;isSrcdocDocument()) {
1023         frame = frame-&gt;tree().parent();
1024         // Srcdoc documents cannot be top-level documents, by definition,
1025         // because they need to be contained in iframes with the srcdoc.
1026         ASSERT(frame);
1027     }
1028     if (!frame)
1029         return emptyString();
1030     return frame-&gt;loader().m_outgoingReferrer;
1031 }
1032 
1033 String FrameLoader::outgoingOrigin() const
1034 {
1035     return m_frame.document()-&gt;securityOrigin().toString();
1036 }
1037 
1038 bool FrameLoader::checkIfFormActionAllowedByCSP(const URL&amp; url, bool didReceiveRedirectResponse) const
1039 {
1040     if (m_submittedFormURL.isEmpty())
1041         return true;
1042 
1043     auto redirectResponseReceived = didReceiveRedirectResponse ? ContentSecurityPolicy::RedirectResponseReceived::Yes : ContentSecurityPolicy::RedirectResponseReceived::No;
1044     return m_frame.document()-&gt;contentSecurityPolicy()-&gt;allowFormAction(url, redirectResponseReceived);
1045 }
1046 
1047 Frame* FrameLoader::opener()
1048 {
1049     return m_opener;
1050 }
1051 
1052 void FrameLoader::setOpener(Frame* opener)
1053 {
1054     if (m_opener &amp;&amp; !opener)
1055         m_client.didDisownOpener();
1056 
1057     if (m_opener) {
1058         // When setOpener is called in ~FrameLoader, opener&#39;s m_frameLoader is already cleared.
1059         auto&amp; openerFrameLoader = m_opener == &amp;m_frame ? *this : m_opener-&gt;loader();
1060         openerFrameLoader.m_openedFrames.remove(&amp;m_frame);
1061     }
1062     if (opener) {
1063         opener-&gt;loader().m_openedFrames.add(&amp;m_frame);
1064         if (auto* page = m_frame.page())
1065             page-&gt;setOpenedByDOMWithOpener();
1066     }
1067     m_opener = opener;
1068 
1069     if (m_frame.document())
1070         m_frame.document()-&gt;initSecurityContext();
1071 }
1072 
1073 // FIXME: This does not belong in FrameLoader!
1074 void FrameLoader::handleFallbackContent()
1075 {
1076     HTMLFrameOwnerElement* owner = m_frame.ownerElement();
1077     if (!is&lt;HTMLObjectElement&gt;(owner))
1078         return;
1079     downcast&lt;HTMLObjectElement&gt;(*owner).renderFallbackContent();
1080 }
1081 
1082 void FrameLoader::provisionalLoadStarted()
1083 {
1084     if (m_stateMachine.firstLayoutDone())
1085         m_stateMachine.advanceTo(FrameLoaderStateMachine::CommittedFirstRealLoad);
1086     m_frame.navigationScheduler().cancel(NewLoadInProgress::Yes);
1087     m_client.provisionalLoadStarted();
1088 
1089     if (m_frame.isMainFrame()) {
1090         tracePoint(MainResourceLoadDidStartProvisional);
1091 
1092         if (auto* page = m_frame.page())
1093             page-&gt;didStartProvisionalLoad();
1094     }
1095 }
1096 
1097 void FrameLoader::resetMultipleFormSubmissionProtection()
1098 {
1099     m_submittedFormURL = URL();
1100 }
1101 
1102 void FrameLoader::updateFirstPartyForCookies()
1103 {
1104     if (m_frame.tree().parent())
1105         setFirstPartyForCookies(m_frame.tree().parent()-&gt;document()-&gt;firstPartyForCookies());
1106     else
1107         setFirstPartyForCookies(m_frame.document()-&gt;url());
1108 }
1109 
1110 void FrameLoader::setFirstPartyForCookies(const URL&amp; url)
1111 {
1112     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame))
1113         frame-&gt;document()-&gt;setFirstPartyForCookies(url);
1114 
1115     RegistrableDomain registrableDomain(url);
1116     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame)) {
1117         if (SecurityPolicy::shouldInheritSecurityOriginFromOwner(frame-&gt;document()-&gt;url()) || registrableDomain.matches(frame-&gt;document()-&gt;url()))
1118             frame-&gt;document()-&gt;setSiteForCookies(url);
1119     }
1120 }
1121 
1122 // This does the same kind of work that didOpenURL does, except it relies on the fact
1123 // that a higher level already checked that the URLs match and the scrolling is the right thing to do.
1124 void FrameLoader::loadInSameDocument(const URL&amp; url, SerializedScriptValue* stateObject, bool isNewNavigation)
1125 {
1126     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadInSameDocument: frame load started&quot;);
1127 
1128     // If we have a state object, we cannot also be a new navigation.
1129     ASSERT(!stateObject || (stateObject &amp;&amp; !isNewNavigation));
1130 
1131     // Update the data source&#39;s request with the new URL to fake the URL change
1132     URL oldURL = m_frame.document()-&gt;url();
1133     m_frame.document()-&gt;setURL(url);
1134     setOutgoingReferrer(url);
1135     documentLoader()-&gt;replaceRequestURLForSameDocumentNavigation(url);
1136     if (isNewNavigation &amp;&amp; !shouldTreatURLAsSameAsCurrent(url) &amp;&amp; !stateObject) {
1137         // NB: must happen after replaceRequestURLForSameDocumentNavigation(), since we add
1138         // based on the current request. Must also happen before we openURL and displace the
1139         // scroll position, since adding the BF item will save away scroll state.
1140 
1141         // NB2: If we were loading a long, slow doc, and the user fragment navigated before
1142         // it was done, currItem is now set the that slow doc, and prevItem is whatever was
1143         // before it.  Adding the b/f item will bump the slow doc down to prevItem, even
1144         // though its load is not yet done.  I think this all works out OK, for one because
1145         // we have already saved away the scroll and doc state for the long slow load,
1146         // but it&#39;s not an obvious case.
1147 
1148         history().updateBackForwardListForFragmentScroll();
1149     }
1150 
1151     bool hashChange = equalIgnoringFragmentIdentifier(url, oldURL) &amp;&amp; url.fragmentIdentifier() != oldURL.fragmentIdentifier();
1152 
1153     history().updateForSameDocumentNavigation();
1154 
1155     // If we were in the autoscroll/panScroll mode we want to stop it before following the link to the anchor
1156     if (hashChange)
1157         m_frame.eventHandler().stopAutoscrollTimer();
1158 
1159     // It&#39;s important to model this as a load that starts and immediately finishes.
1160     // Otherwise, the parent frame may think we never finished loading.
1161     started();
1162 
1163     if (auto* ownerElement = m_frame.ownerElement()) {
1164         auto* ownerRenderer = ownerElement-&gt;renderer();
1165         auto* view = m_frame.view();
1166         if (is&lt;RenderWidget&gt;(ownerRenderer) &amp;&amp; view)
1167             downcast&lt;RenderWidget&gt;(*ownerRenderer).setWidget(view);
1168     }
1169 
1170     // We need to scroll to the fragment whether or not a hash change occurred, since
1171     // the user might have scrolled since the previous navigation.
1172     scrollToFragmentWithParentBoundary(url, isNewNavigation);
1173 
1174     m_isComplete = false;
1175     checkCompleted();
1176 
1177     if (isNewNavigation) {
1178         // This will clear previousItem from the rest of the frame tree that didn&#39;t
1179         // doing any loading. We need to make a pass on this now, since for fragment
1180         // navigation we&#39;ll not go through a real load and reach Completed state.
1181         checkLoadComplete();
1182     }
1183 
1184     m_client.dispatchDidNavigateWithinPage();
1185 
1186     m_frame.document()-&gt;statePopped(stateObject ? Ref&lt;SerializedScriptValue&gt; { *stateObject } : SerializedScriptValue::nullValue());
1187     m_client.dispatchDidPopStateWithinPage();
1188 
1189     if (hashChange) {
1190         m_frame.document()-&gt;enqueueHashchangeEvent(oldURL, url);
1191         m_client.dispatchDidChangeLocationWithinPage();
1192     }
1193 
1194     // FrameLoaderClient::didFinishLoad() tells the internal load delegate the load finished with no error
1195     m_client.didFinishLoad();
1196 }
1197 
1198 bool FrameLoader::isComplete() const
1199 {
1200     return m_isComplete;
1201 }
1202 
1203 void FrameLoader::completed()
1204 {
1205     Ref&lt;Frame&gt; protect(m_frame);
1206 
1207     for (Frame* descendant = m_frame.tree().traverseNext(&amp;m_frame); descendant; descendant = descendant-&gt;tree().traverseNext(&amp;m_frame))
1208         descendant-&gt;navigationScheduler().startTimer();
1209 
1210     if (Frame* parent = m_frame.tree().parent())
1211         parent-&gt;loader().checkCompleted();
1212 
1213     if (m_frame.view())
1214         m_frame.view()-&gt;maintainScrollPositionAtAnchor(nullptr);
1215 }
1216 
1217 void FrameLoader::started()
1218 {
1219     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().parent())
1220         frame-&gt;loader().m_isComplete = false;
1221 }
1222 
1223 void FrameLoader::prepareForLoadStart()
1224 {
1225     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;prepareForLoadStart: Starting frame load&quot;);
1226 
1227     m_progressTracker-&gt;progressStarted();
1228     m_client.dispatchDidStartProvisionalLoad();
1229 
1230     if (AXObjectCache::accessibilityEnabled()) {
1231         if (AXObjectCache* cache = m_frame.document()-&gt;existingAXObjectCache()) {
1232             AXObjectCache::AXLoadingEvent loadingEvent = loadType() == FrameLoadType::Reload ? AXObjectCache::AXLoadingReloaded : AXObjectCache::AXLoadingStarted;
1233             cache-&gt;frameLoadingEventNotification(&amp;m_frame, loadingEvent);
1234         }
1235     }
1236 }
1237 
1238 void FrameLoader::setupForReplace()
1239 {
1240     m_client.revertToProvisionalState(m_documentLoader.get());
1241     setState(FrameStateProvisional);
1242     m_provisionalDocumentLoader = m_documentLoader;
1243     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;setupForReplace: Setting provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());
1244     m_documentLoader = nullptr;
1245     detachChildren();
1246 }
1247 
1248 void FrameLoader::loadFrameRequest(FrameLoadRequest&amp;&amp; request, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)
1249 {
1250     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadFrameRequest: frame load started&quot;);
1251 
1252     // Protect frame from getting blown away inside dispatchBeforeLoadEvent in loadWithDocumentLoader.
1253     auto protectFrame = makeRef(m_frame);
1254 
1255     URL url = request.resourceRequest().url();
1256 
1257     ASSERT(m_frame.document());
1258     if (!request.requesterSecurityOrigin().canDisplay(url)) {
1259         reportLocalLoadFailed(&amp;m_frame, url.stringCenterEllipsizedToLength());
1260         return;
1261     }
1262 
1263     String argsReferrer = request.resourceRequest().httpReferrer();
1264     if (argsReferrer.isEmpty())
1265         argsReferrer = outgoingReferrer();
1266 
1267     String referrer = SecurityPolicy::generateReferrerHeader(m_frame.document()-&gt;referrerPolicy(), url, argsReferrer);
1268     if (request.shouldSendReferrer() == NeverSendReferrer)
1269         referrer = String();
1270 
1271     FrameLoadType loadType;
1272     if (request.resourceRequest().cachePolicy() == ResourceRequestCachePolicy::ReloadIgnoringCacheData)
1273         loadType = FrameLoadType::Reload;
1274     else if (request.lockBackForwardList() == LockBackForwardList::Yes)
1275         loadType = FrameLoadType::RedirectWithLockedBackForwardList;
1276     else
1277         loadType = FrameLoadType::Standard;
1278 
1279     auto completionHandler = [this, protectedFrame = makeRef(m_frame), formState = makeWeakPtr(formState.get()), frameName = request.frameName()] {
1280         // FIXME: It&#39;s possible this targetFrame will not be the same frame that was targeted by the actual
1281         // load if frame names have changed.
1282         Frame* sourceFrame = formState ? formState-&gt;sourceDocument().frame() : &amp;m_frame;
1283         if (!sourceFrame)
1284             sourceFrame = &amp;m_frame;
1285         Frame* targetFrame = sourceFrame-&gt;loader().findFrameForNavigation(frameName);
1286         if (targetFrame &amp;&amp; targetFrame != sourceFrame) {
1287             if (Page* page = targetFrame-&gt;page())
1288                 page-&gt;chrome().focus();
1289         }
1290     };
1291 
1292     if (request.resourceRequest().httpMethod() == &quot;POST&quot;)
1293         loadPostRequest(WTFMove(request), referrer, loadType, event, WTFMove(formState), WTFMove(completionHandler));
1294     else
1295         loadURL(WTFMove(request), referrer, loadType, event, WTFMove(formState), WTFMove(adClickAttribution), WTFMove(completionHandler));
1296 }
1297 
1298 static ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicyToApply(Frame&amp; currentFrame, InitiatedByMainFrame initiatedByMainFrame, ShouldOpenExternalURLsPolicy propagatedPolicy)
1299 {
1300     if (UserGestureIndicator::processingUserGesture())
1301         return ShouldOpenExternalURLsPolicy::ShouldAllow;
1302 
1303     if (initiatedByMainFrame == InitiatedByMainFrame::Yes)
1304         return propagatedPolicy;
1305 
1306     if (!currentFrame.isMainFrame())
1307         return ShouldOpenExternalURLsPolicy::ShouldNotAllow;
1308 
1309     return propagatedPolicy;
1310 }
1311 
1312 static ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicyToApply(Frame&amp; currentFrame, const FrameLoadRequest&amp; frameLoadRequest)
1313 {
1314     return shouldOpenExternalURLsPolicyToApply(currentFrame, frameLoadRequest.initiatedByMainFrame(), frameLoadRequest.shouldOpenExternalURLsPolicy());
1315 }
1316 
1317 static void applyShouldOpenExternalURLsPolicyToNewDocumentLoader(Frame&amp; frame, DocumentLoader&amp; documentLoader, InitiatedByMainFrame initiatedByMainFrame, ShouldOpenExternalURLsPolicy propagatedPolicy)
1318 {
1319     documentLoader.setShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(frame, initiatedByMainFrame, propagatedPolicy));
1320 }
1321 
1322 static void applyShouldOpenExternalURLsPolicyToNewDocumentLoader(Frame&amp; frame, DocumentLoader&amp; documentLoader, const FrameLoadRequest&amp; frameLoadRequest)
1323 {
1324     documentLoader.setShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(frame, frameLoadRequest));
1325 }
1326 
1327 bool FrameLoader::isNavigationAllowed() const
1328 {
1329     return m_pageDismissalEventBeingDispatched == PageDismissalType::None &amp;&amp; !m_frame.script().willReplaceWithResultOfExecutingJavascriptURL() &amp;&amp; NavigationDisabler::isNavigationAllowed(m_frame);
1330 }
1331 
1332 bool FrameLoader::isStopLoadingAllowed() const
1333 {
1334     return m_pageDismissalEventBeingDispatched == PageDismissalType::None;
1335 }
1336 
1337 void FrameLoader::loadURL(FrameLoadRequest&amp;&amp; frameLoadRequest, const String&amp; referrer, FrameLoadType newLoadType, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
1338 {
1339     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadURL: frame load started&quot;);
1340 
1341     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
1342     if (m_inStopAllLoaders || m_inClearProvisionalLoadForPolicyCheck)
1343         return;
1344 
1345     Ref&lt;Frame&gt; protect(m_frame);
1346 
1347     // Anchor target is ignored when the download attribute is set since it will download the hyperlink rather than follow it.
1348     String effectiveFrameName = frameLoadRequest.downloadAttribute().isNull() ? frameLoadRequest.frameName() : String();
1349     AllowNavigationToInvalidURL allowNavigationToInvalidURL = frameLoadRequest.allowNavigationToInvalidURL();
1350     NewFrameOpenerPolicy openerPolicy = frameLoadRequest.newFrameOpenerPolicy();
1351     LockHistory lockHistory = frameLoadRequest.lockHistory();
1352     bool isFormSubmission = formState;
1353 
1354     const URL&amp; newURL = frameLoadRequest.resourceRequest().url();
1355     ResourceRequest request(newURL);
1356     if (!referrer.isEmpty()) {
1357         request.setHTTPReferrer(referrer);
1358         auto referrerOrigin = SecurityOrigin::createFromString(referrer);
1359         addHTTPOriginIfNeeded(request, referrerOrigin-&gt;toString());
1360     }
1361     if (&amp;m_frame.tree().top() != &amp;m_frame)
1362         request.setDomainForCachePartition(m_frame.tree().top().document()-&gt;domainForCachePartition());
1363 
1364     addExtraFieldsToRequest(request, newLoadType, true);
1365     if (isReload(newLoadType))
1366         request.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
1367 
1368     ASSERT(newLoadType != FrameLoadType::Same);
1369 
1370     // The search for a target frame is done earlier in the case of form submission.
1371     Frame* targetFrame = isFormSubmission ? nullptr : findFrameForNavigation(effectiveFrameName);
1372     if (targetFrame &amp;&amp; targetFrame != &amp;m_frame) {
1373         frameLoadRequest.setFrameName(&quot;_self&quot;);
1374         targetFrame-&gt;loader().loadURL(WTFMove(frameLoadRequest), referrer, newLoadType, event, WTFMove(formState), WTFMove(adClickAttribution), completionHandlerCaller.release());
1375         return;
1376     }
1377 
1378     if (!isNavigationAllowed())
1379         return;
1380 
1381     NavigationAction action { frameLoadRequest.requester(), request, frameLoadRequest.initiatedByMainFrame(), newLoadType, isFormSubmission, event, frameLoadRequest.shouldOpenExternalURLsPolicy(), frameLoadRequest.downloadAttribute() };
1382     action.setLockHistory(lockHistory);
1383     action.setLockBackForwardList(frameLoadRequest.lockBackForwardList());
1384     if (adClickAttribution &amp;&amp; m_frame.isMainFrame())
1385         action.setAdClickAttribution(WTFMove(*adClickAttribution));
1386 
1387     if (!targetFrame &amp;&amp; !effectiveFrameName.isEmpty()) {
1388         action = action.copyWithShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(m_frame, frameLoadRequest));
1389         policyChecker().checkNewWindowPolicy(WTFMove(action), WTFMove(request), WTFMove(formState), effectiveFrameName, [this, allowNavigationToInvalidURL, openerPolicy, completionHandler = completionHandlerCaller.release()] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, const NavigationAction&amp; action, PolicyChecker::ShouldContinue shouldContinue) mutable {
1390             continueLoadAfterNewWindowPolicy(request, formState.get(), frameName, action, shouldContinue, allowNavigationToInvalidURL, openerPolicy);
1391             completionHandler();
1392         });
1393         return;
1394     }
1395 
1396     RefPtr&lt;DocumentLoader&gt; oldDocumentLoader = m_documentLoader;
1397 
1398     bool sameURL = shouldTreatURLAsSameAsCurrent(newURL);
1399     const String&amp; httpMethod = request.httpMethod();
1400 
1401     // Make sure to do scroll to fragment processing even if the URL is
1402     // exactly the same so pages with &#39;#&#39; links and DHTML side effects
1403     // work properly.
1404     if (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, newLoadType, newURL)) {
1405         oldDocumentLoader-&gt;setTriggeringAction(WTFMove(action));
1406         oldDocumentLoader-&gt;setLastCheckedRequest(ResourceRequest());
1407         policyChecker().stopCheck();
1408         policyChecker().setLoadType(newLoadType);
1409         RELEASE_ASSERT(!isBackForwardLoadType(newLoadType) || history().provisionalItem());
1410         policyChecker().checkNavigationPolicy(WTFMove(request), ResourceResponse { } /* redirectResponse */, oldDocumentLoader.get(), WTFMove(formState), [this, protectedFrame = makeRef(m_frame)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp;, NavigationPolicyDecision navigationPolicyDecision) {
1411             continueFragmentScrollAfterNavigationPolicy(request, navigationPolicyDecision == NavigationPolicyDecision::ContinueLoad);
1412         }, PolicyDecisionMode::Synchronous);
1413         return;
1414     }
1415 
1416     // Must grab this now, since this load may stop the previous load and clear this flag.
1417     bool isRedirect = m_quickRedirectComing;
1418 #if USE(SYSTEM_PREVIEW)
1419     bool isSystemPreview = frameLoadRequest.isSystemPreview();
1420     if (isSystemPreview)
1421         request.setSystemPreviewInfo(frameLoadRequest.systemPreviewInfo());
1422 #endif
1423     loadWithNavigationAction(request, WTFMove(action), lockHistory, newLoadType, WTFMove(formState), allowNavigationToInvalidURL, frameLoadRequest.downloadAttribute(), [this, isRedirect, sameURL, newLoadType, protectedFrame = makeRef(m_frame), completionHandler = completionHandlerCaller.release()] () mutable {
1424         if (isRedirect) {
1425             m_quickRedirectComing = false;
1426             if (m_provisionalDocumentLoader)
1427                 m_provisionalDocumentLoader-&gt;setIsClientRedirect(true);
1428             else if (m_policyDocumentLoader)
1429                 m_policyDocumentLoader-&gt;setIsClientRedirect(true);
1430         } else if (sameURL &amp;&amp; !isReload(newLoadType)) {
1431             // Example of this case are sites that reload the same URL with a different cookie
1432             // driving the generated content, or a master frame with links that drive a target
1433             // frame, where the user has clicked on the same link repeatedly.
1434             m_loadType = FrameLoadType::Same;
1435         }
1436         completionHandler();
1437     });
1438 }
1439 
1440 SubstituteData FrameLoader::defaultSubstituteDataForURL(const URL&amp; url)
1441 {
1442     if (!shouldTreatURLAsSrcdocDocument(url))
1443         return SubstituteData();
1444     auto&amp; srcdoc = m_frame.ownerElement()-&gt;attributeWithoutSynchronization(srcdocAttr);
1445     ASSERT(!srcdoc.isNull());
1446     CString encodedSrcdoc = srcdoc.string().utf8();
1447 
1448     ResourceResponse response(URL(), &quot;text/html&quot;_s, encodedSrcdoc.length(), &quot;UTF-8&quot;_s);
1449     return SubstituteData(SharedBuffer::create(encodedSrcdoc.data(), encodedSrcdoc.length()), URL(), response, SubstituteData::SessionHistoryVisibility::Hidden);
1450 }
1451 
1452 void FrameLoader::load(FrameLoadRequest&amp;&amp; request)
1453 {
1454     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;load (FrameLoadRequest): frame load started&quot;);
1455 
1456     if (m_inStopAllLoaders || m_inClearProvisionalLoadForPolicyCheck)
1457         return;
1458 
1459     if (!request.frameName().isEmpty()) {
1460         Frame* frame = findFrameForNavigation(request.frameName());
1461         if (frame) {
1462             request.setShouldCheckNewWindowPolicy(false);
1463             if (&amp;frame-&gt;loader() != this) {
1464                 frame-&gt;loader().load(WTFMove(request));
1465                 return;
1466             }
1467         }
1468     }
1469 
1470     if (request.shouldCheckNewWindowPolicy()) {
1471         NavigationAction action { request.requester(), request.resourceRequest(), InitiatedByMainFrame::Unknown, NavigationType::Other, request.shouldOpenExternalURLsPolicy() };
1472         policyChecker().checkNewWindowPolicy(WTFMove(action), WTFMove(request.resourceRequest()), { }, request.frameName(), [this] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, const NavigationAction&amp; action, PolicyChecker::ShouldContinue shouldContinue) {
1473             continueLoadAfterNewWindowPolicy(request, formState.get(), frameName, action, shouldContinue, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Suppress);
1474         });
1475 
1476         return;
1477     }
1478 
1479     if (!request.hasSubstituteData())
1480         request.setSubstituteData(defaultSubstituteDataForURL(request.resourceRequest().url()));
1481 
1482     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request.resourceRequest(), request.substituteData());
1483     loader-&gt;setAllowsWebArchiveForMainFrame(request.isRequestFromClientOrUserInput());
1484     loader-&gt;setAllowsDataURLsForMainFrame(request.isRequestFromClientOrUserInput());
1485     addSameSiteInfoToRequestIfNeeded(loader-&gt;request());
1486     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, request);
1487 
1488     if (request.shouldTreatAsContinuingLoad()) {
1489         loader-&gt;setClientRedirectSourceForHistory(request.clientRedirectSourceForHistory());
1490         if (request.lockBackForwardList() == LockBackForwardList::Yes) {
1491             loader-&gt;setIsClientRedirect(true);
1492             m_loadType = FrameLoadType::RedirectWithLockedBackForwardList;
1493         }
1494     }
1495 
1496     SetForScope&lt;LoadContinuingState&gt; continuingLoadGuard(m_currentLoadContinuingState, request.shouldTreatAsContinuingLoad() ? LoadContinuingState::ContinuingWithRequest : LoadContinuingState::NotContinuing);
1497     load(loader.get());
1498 }
1499 
1500 void FrameLoader::loadWithNavigationAction(const ResourceRequest&amp; request, NavigationAction&amp;&amp; action, LockHistory lockHistory, FrameLoadType type, RefPtr&lt;FormState&gt;&amp;&amp; formState, AllowNavigationToInvalidURL allowNavigationToInvalidURL, const String&amp; downloadAttribute, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
1501 {
1502     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadWithNavigationAction: frame load started&quot;);
1503 
1504     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request, defaultSubstituteDataForURL(request.url()));
1505     loader-&gt;setDownloadAttribute(downloadAttribute);
1506     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, action.initiatedByMainFrame(), action.shouldOpenExternalURLsPolicy());
1507 
1508     if (lockHistory == LockHistory::Yes &amp;&amp; m_documentLoader)
1509         loader-&gt;setClientRedirectSourceForHistory(m_documentLoader-&gt;didCreateGlobalHistoryEntry() ? m_documentLoader-&gt;urlForHistory().string() : m_documentLoader-&gt;clientRedirectSourceForHistory());
1510 
1511     loader-&gt;setTriggeringAction(WTFMove(action));
1512     if (m_documentLoader)
1513         loader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1514 
1515     loadWithDocumentLoader(loader.ptr(), type, WTFMove(formState), allowNavigationToInvalidURL, ShouldTreatAsContinuingLoad::No, WTFMove(completionHandler));
1516 }
1517 
1518 void FrameLoader::load(DocumentLoader&amp; newDocumentLoader)
1519 {
1520     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;load (DocumentLoader): frame load started&quot;);
1521 
1522     ResourceRequest&amp; r = newDocumentLoader.request();
1523     addExtraFieldsToMainResourceRequest(r);
1524     FrameLoadType type;
1525 
1526     if (shouldTreatURLAsSameAsCurrent(newDocumentLoader.originalRequest().url())) {
1527         r.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
1528         type = FrameLoadType::Same;
1529     } else if (shouldTreatURLAsSameAsCurrent(newDocumentLoader.unreachableURL()) &amp;&amp; isReload(m_loadType))
1530         type = m_loadType;
1531     else if (m_loadType == FrameLoadType::RedirectWithLockedBackForwardList &amp;&amp; ((!newDocumentLoader.unreachableURL().isEmpty() &amp;&amp; newDocumentLoader.substituteData().isValid()) || shouldTreatCurrentLoadAsContinuingLoad()))
1532         type = FrameLoadType::RedirectWithLockedBackForwardList;
1533     else
1534         type = FrameLoadType::Standard;
1535 
1536     if (m_documentLoader)
1537         newDocumentLoader.setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1538 
1539     // When we loading alternate content for an unreachable URL that we&#39;re
1540     // visiting in the history list, we treat it as a reload so the history list
1541     // is appropriately maintained.
1542     //
1543     // FIXME: This seems like a dangerous overloading of the meaning of &quot;FrameLoadType::Reload&quot; ...
1544     // shouldn&#39;t a more explicit type of reload be defined, that means roughly
1545     // &quot;load without affecting history&quot; ?
1546     if (shouldReloadToHandleUnreachableURL(newDocumentLoader)) {
1547         // shouldReloadToHandleUnreachableURL returns true only when the original load type is back-forward.
1548         // In this case we should save the document state now. Otherwise the state can be lost because load type is
1549         // changed and updateForBackForwardNavigation() will not be called when loading is committed.
1550         history().saveDocumentAndScrollState();
1551 
1552         ASSERT(type == FrameLoadType::Standard);
1553         type = FrameLoadType::Reload;
1554     }
1555 
1556     loadWithDocumentLoader(&amp;newDocumentLoader, type, nullptr, AllowNavigationToInvalidURL::Yes, ShouldTreatAsContinuingLoad::No);
1557 }
1558 
1559 void FrameLoader::loadWithDocumentLoader(DocumentLoader* loader, FrameLoadType type, RefPtr&lt;FormState&gt;&amp;&amp; formState, AllowNavigationToInvalidURL allowNavigationToInvalidURL, ShouldTreatAsContinuingLoad, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
1560 {
1561     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadWithDocumentLoader: frame load started&quot;);
1562 
1563     // Retain because dispatchBeforeLoadEvent may release the last reference to it.
1564     Ref&lt;Frame&gt; protect(m_frame);
1565 
1566     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
1567 
1568     ASSERT(m_client.hasWebView());
1569 
1570     // Unfortunately the view must be non-nil, this is ultimately due
1571     // to parser requiring a FrameView.  We should fix this dependency.
1572 
1573     ASSERT(m_frame.view());
1574 
1575     if (!isNavigationAllowed())
1576         return;
1577 
1578     if (m_frame.document())
1579         m_previousURL = m_frame.document()-&gt;url();
1580 
1581     const URL&amp; newURL = loader-&gt;request().url();
1582 
1583     // Only the first iframe navigation or the first iframe navigation after about:blank should be reported.
1584     // https://www.w3.org/TR/resource-timing-2/#resources-included-in-the-performanceresourcetiming-interface
1585     if (m_shouldReportResourceTimingToParentFrame &amp;&amp; !m_previousURL.isNull() &amp;&amp; m_previousURL != WTF::blankURL())
1586         m_shouldReportResourceTimingToParentFrame = false;
1587 
1588     // Log main frame navigation types.
1589     if (m_frame.isMainFrame()) {
1590         if (auto* page = m_frame.page()) {
1591             FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadWithDocumentLoader: main frame load started&quot;);
1592             page-&gt;mainFrameLoadStarted(newURL, type);
1593             page-&gt;performanceLogging().didReachPointOfInterest(PerformanceLogging::MainFrameLoadStarted);
1594         }
1595     }
1596 
1597     policyChecker().setLoadType(type);
1598     RELEASE_ASSERT(!isBackForwardLoadType(type) || history().provisionalItem());
1599     bool isFormSubmission = formState;
1600 
1601     const String&amp; httpMethod = loader-&gt;request().httpMethod();
1602 
1603     if (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, policyChecker().loadType(), newURL)) {
1604         RefPtr&lt;DocumentLoader&gt; oldDocumentLoader = m_documentLoader;
1605         NavigationAction action { *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission };
1606 
1607         oldDocumentLoader-&gt;setTriggeringAction(WTFMove(action));
1608         oldDocumentLoader-&gt;setLastCheckedRequest(ResourceRequest());
1609         policyChecker().stopCheck();
1610         RELEASE_ASSERT(!isBackForwardLoadType(policyChecker().loadType()) || history().provisionalItem());
1611         policyChecker().checkNavigationPolicy(ResourceRequest(loader-&gt;request()), ResourceResponse { }  /* redirectResponse */, oldDocumentLoader.get(), WTFMove(formState), [this, protectedFrame = makeRef(m_frame)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp;, NavigationPolicyDecision navigationPolicyDecision) {
1612             continueFragmentScrollAfterNavigationPolicy(request, navigationPolicyDecision == NavigationPolicyDecision::ContinueLoad);
1613         }, PolicyDecisionMode::Synchronous);
1614         return;
1615     }
1616 
1617     if (Frame* parent = m_frame.tree().parent())
1618         loader-&gt;setOverrideEncoding(parent-&gt;loader().documentLoader()-&gt;overrideEncoding());
1619 
1620     policyChecker().stopCheck();
1621     setPolicyDocumentLoader(loader);
1622     if (loader-&gt;triggeringAction().isEmpty())
1623         loader-&gt;setTriggeringAction({ *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission });
1624 
1625     if (Element* ownerElement = m_frame.ownerElement()) {
1626         // We skip dispatching the beforeload event if we&#39;ve already
1627         // committed a real document load because the event would leak
1628         // subsequent activity by the frame which the parent frame isn&#39;t
1629         // supposed to learn. For example, if the child frame navigated to
1630         // a new URL, the parent frame shouldn&#39;t learn the URL.
1631         if (!m_stateMachine.committedFirstRealDocumentLoad()
1632             &amp;&amp; !ownerElement-&gt;dispatchBeforeLoadEvent(loader-&gt;request().url().string())) {
1633             continueLoadAfterNavigationPolicy(loader-&gt;request(), formState.get(), NavigationPolicyDecision::IgnoreLoad, allowNavigationToInvalidURL);
1634             return;
1635         }
1636     }
1637 
1638     m_frame.navigationScheduler().cancel(NewLoadInProgress::Yes);
1639 
1640     if (shouldTreatCurrentLoadAsContinuingLoad()) {
1641         continueLoadAfterNavigationPolicy(loader-&gt;request(), formState.get(), NavigationPolicyDecision::ContinueLoad, allowNavigationToInvalidURL);
1642         return;
1643     }
1644 
1645     RELEASE_ASSERT(!isBackForwardLoadType(policyChecker().loadType()) || history().provisionalItem());
1646     policyChecker().checkNavigationPolicy(ResourceRequest(loader-&gt;request()), ResourceResponse { } /* redirectResponse */, loader, WTFMove(formState), [this, protectedFrame = makeRef(m_frame), allowNavigationToInvalidURL, completionHandler = completionHandlerCaller.release()] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, NavigationPolicyDecision navigationPolicyDecision) mutable {
1647         continueLoadAfterNavigationPolicy(request, formState.get(), navigationPolicyDecision, allowNavigationToInvalidURL);
1648         completionHandler();
1649     }, PolicyDecisionMode::Asynchronous);
1650 }
1651 
1652 void FrameLoader::clearProvisionalLoadForPolicyCheck()
1653 {
1654     if (!m_policyDocumentLoader || !m_provisionalDocumentLoader || m_inClearProvisionalLoadForPolicyCheck)
1655         return;
1656 
1657     SetForScope&lt;bool&gt; change(m_inClearProvisionalLoadForPolicyCheck, true);
1658     m_provisionalDocumentLoader-&gt;stopLoading();
1659     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;clearProvisionalLoadForPolicyCheck: Clearing provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());
1660     setProvisionalDocumentLoader(nullptr);
1661 }
1662 
1663 void FrameLoader::reportLocalLoadFailed(Frame* frame, const String&amp; url)
1664 {
1665     ASSERT(!url.isEmpty());
1666     if (!frame)
1667         return;
1668 
1669     frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Not allowed to load local resource: &quot; + url);
1670 }
1671 
1672 void FrameLoader::reportBlockedPortFailed(Frame* frame, const String&amp; url)
1673 {
1674     ASSERT(!url.isEmpty());
1675     if (!frame)
1676         return;
1677 
1678     frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Not allowed to use restricted network port: &quot; + url);
1679 }
1680 
1681 void FrameLoader::reportAuthenticationChallengeBlocked(Frame* frame, const URL&amp; url, const String&amp; reason)
1682 {
1683     if (!frame)
1684         return;
1685 
1686     frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, makeString(&quot;Blocked &quot;, url.stringCenterEllipsizedToLength(), &quot; from asking for credentials because &quot;, reason, &#39;.&#39;));
1687 }
1688 
1689 const ResourceRequest&amp; FrameLoader::initialRequest() const
1690 {
1691     return activeDocumentLoader()-&gt;originalRequest();
1692 }
1693 
1694 bool FrameLoader::willLoadMediaElementURL(URL&amp; url, Node&amp; initiatorNode)
1695 {
1696 #if PLATFORM(IOS_FAMILY)
1697     // MobileStore depends on the iOS 4.0 era client delegate method because webView:resource:willSendRequest:redirectResponse:fromDataSource
1698     // doesn&#39;t let them tell when a load request is coming from a media element. See &lt;rdar://problem/8266916&gt; for more details.
1699     if (IOSApplication::isMobileStore())
1700         return m_client.shouldLoadMediaElementURL(url);
1701 #endif
1702 
1703     ResourceRequest request(url);
1704     request.setInspectorInitiatorNodeIdentifier(InspectorInstrumentation::identifierForNode(initiatorNode));
1705 
1706     unsigned long identifier;
1707     ResourceError error;
1708     requestFromDelegate(request, identifier, error);
1709     notifier().sendRemainingDelegateMessages(m_documentLoader.get(), identifier, request, ResourceResponse(url, String(), -1, String()), 0, -1, -1, error);
1710 
1711     url = request.url();
1712 
1713     return error.isNull();
1714 }
1715 
1716 bool FrameLoader::shouldReloadToHandleUnreachableURL(DocumentLoader&amp; docLoader)
1717 {
1718     URL unreachableURL = docLoader.unreachableURL();
1719 
1720     if (unreachableURL.isEmpty())
1721         return false;
1722 
1723     if (!isBackForwardLoadType(policyChecker().loadType()))
1724         return false;
1725 
1726     // We only treat unreachableURLs specially during the delegate callbacks
1727     // for provisional load errors and navigation policy decisions. The former
1728     // case handles well-formed URLs that can&#39;t be loaded, and the latter
1729     // case handles malformed URLs and unknown schemes. Loading alternate content
1730     // at other times behaves like a standard load.
1731     if (policyChecker().delegateIsDecidingNavigationPolicy() || policyChecker().delegateIsHandlingUnimplementablePolicy())
1732         return m_policyDocumentLoader &amp;&amp; unreachableURL == m_policyDocumentLoader-&gt;request().url();
1733 
1734     return unreachableURL == m_provisionalLoadErrorBeingHandledURL;
1735 }
1736 
1737 void FrameLoader::reloadWithOverrideEncoding(const String&amp; encoding)
1738 {
1739     if (!m_documentLoader)
1740         return;
1741 
1742     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;reloadWithOverrideEncoding: frame load started&quot;);
1743 
1744     ResourceRequest request = m_documentLoader-&gt;request();
1745     URL unreachableURL = m_documentLoader-&gt;unreachableURL();
1746     if (!unreachableURL.isEmpty())
1747         request.setURL(unreachableURL);
1748 
1749     // FIXME: If the resource is a result of form submission and is not cached, the form will be silently resubmitted.
1750     // We should ask the user for confirmation in this case.
1751     request.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataElseLoad);
1752 
1753     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request, defaultSubstituteDataForURL(request.url()));
1754     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, InitiatedByMainFrame::Unknown, m_documentLoader-&gt;shouldOpenExternalURLsPolicyToPropagate());
1755 
1756     setPolicyDocumentLoader(loader.ptr());
1757 
1758     loader-&gt;setOverrideEncoding(encoding);
1759 
1760     loadWithDocumentLoader(loader.ptr(), FrameLoadType::Reload, { }, AllowNavigationToInvalidURL::Yes, ShouldTreatAsContinuingLoad::No);
1761 }
1762 
1763 void FrameLoader::reload(OptionSet&lt;ReloadOption&gt; options)
1764 {
1765     if (!m_documentLoader)
1766         return;
1767 
1768     // If a window is created by javascript, its main frame can have an empty but non-nil URL.
1769     // Reloading in this case will lose the current contents (see 4151001).
1770     if (m_documentLoader-&gt;request().url().isEmpty())
1771         return;
1772 
1773     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;reload: frame load started&quot;);
1774 
1775     // Replace error-page URL with the URL we were trying to reach.
1776     ResourceRequest initialRequest = m_documentLoader-&gt;request();
1777     URL unreachableURL = m_documentLoader-&gt;unreachableURL();
1778     if (!unreachableURL.isEmpty())
1779         initialRequest.setURL(unreachableURL);
1780 
1781     // Create a new document loader for the reload, this will become m_documentLoader eventually,
1782     // but first it has to be the &quot;policy&quot; document loader, and then the &quot;provisional&quot; document loader.
1783     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(initialRequest, defaultSubstituteDataForURL(initialRequest.url()));
1784     loader-&gt;setAllowsWebArchiveForMainFrame(m_documentLoader-&gt;allowsWebArchiveForMainFrame());
1785     loader-&gt;setAllowsDataURLsForMainFrame(m_documentLoader-&gt;allowsDataURLsForMainFrame());
1786     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, InitiatedByMainFrame::Unknown, m_documentLoader-&gt;shouldOpenExternalURLsPolicyToPropagate());
1787 
1788     loader-&gt;setUserContentExtensionsEnabled(!options.contains(ReloadOption::DisableContentBlockers));
1789 
1790     ResourceRequest&amp; request = loader-&gt;request();
1791 
1792     // FIXME: We don&#39;t have a mechanism to revalidate the main resource without reloading at the moment.
1793     request.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
1794 
1795     addSameSiteInfoToRequestIfNeeded(request);
1796 
1797     // If we&#39;re about to re-post, set up action so the application can warn the user.
1798     if (request.httpMethod() == &quot;POST&quot;)
1799         loader-&gt;setTriggeringAction({ *m_frame.document(), request, InitiatedByMainFrame::Unknown, NavigationType::FormResubmitted });
1800 
1801     loader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1802 
1803     auto frameLoadTypeForReloadOptions = [] (auto options) {
1804         if (options &amp; ReloadOption::FromOrigin)
1805             return FrameLoadType::ReloadFromOrigin;
1806         if (options &amp; ReloadOption::ExpiredOnly)
1807             return FrameLoadType::ReloadExpiredOnly;
1808         return FrameLoadType::Reload;
1809     };
1810 
1811     loadWithDocumentLoader(loader.ptr(), frameLoadTypeForReloadOptions(options), { }, AllowNavigationToInvalidURL::Yes, ShouldTreatAsContinuingLoad::No);
1812 }
1813 
1814 void FrameLoader::stopAllLoaders(ClearProvisionalItemPolicy clearProvisionalItemPolicy, StopLoadingPolicy stopLoadingPolicy)
1815 {
1816     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;backForwardCacheState() == Document::InBackForwardCache)
1817         return;
1818 
1819     if (stopLoadingPolicy == StopLoadingPolicy::PreventDuringUnloadEvents &amp;&amp; !isStopLoadingAllowed())
1820         return;
1821 
1822     // If this method is called from within this method, infinite recursion can occur (3442218). Avoid this.
1823     if (m_inStopAllLoaders)
1824         return;
1825 
1826     // This method might dispatch events.
1827     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
1828 
1829     // Calling stopLoading() on the provisional document loader can blow away
1830     // the frame from underneath.
1831     Ref&lt;Frame&gt; protect(m_frame);
1832 
1833     m_inStopAllLoaders = true;
1834 
1835     policyChecker().stopCheck();
1836 
1837     // If no new load is in progress, we should clear the provisional item from history
1838     // before we call stopLoading.
1839     if (clearProvisionalItemPolicy == ShouldClearProvisionalItem)
1840         history().setProvisionalItem(nullptr);
1841 
1842     for (RefPtr&lt;Frame&gt; child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())
1843         child-&gt;loader().stopAllLoaders(clearProvisionalItemPolicy);
1844     if (m_provisionalDocumentLoader)
1845         m_provisionalDocumentLoader-&gt;stopLoading();
1846     if (m_documentLoader)
1847         m_documentLoader-&gt;stopLoading();
1848 
1849     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;stopAllLoaders: Clearing provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());
1850     setProvisionalDocumentLoader(nullptr);
1851 
1852     m_inStopAllLoaders = false;
1853 }
1854 
1855 void FrameLoader::stopForBackForwardCache()
1856 {
1857     // Stop provisional loads in subframes (The one in the main frame is about to be committed).
1858     if (!m_frame.isMainFrame()) {
1859         if (m_provisionalDocumentLoader)
1860             m_provisionalDocumentLoader-&gt;stopLoading();
1861         FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;stopForBackForwardCache: Clearing provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());
1862         setProvisionalDocumentLoader(nullptr);
1863     }
1864 
1865     // Stop current loads.
1866     if (m_documentLoader)
1867         m_documentLoader-&gt;stopLoading();
1868 
1869     for (RefPtr&lt;Frame&gt; child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())
1870         child-&gt;loader().stopForBackForwardCache();
1871 
1872     // We cancel pending navigations &amp; policy checks *after* cancelling loads because cancelling loads might end up
1873     // running script, which could schedule new navigations.
1874     policyChecker().stopCheck();
1875     m_frame.navigationScheduler().cancel();
1876 }
1877 
1878 void FrameLoader::stopAllLoadersAndCheckCompleteness()
1879 {
1880     stopAllLoaders();
1881 
1882     if (!m_checkTimer.isActive())
1883         return;
1884 
1885     m_checkTimer.stop();
1886     m_checkingLoadCompleteForDetachment = true;
1887     checkCompletenessNow();
1888     m_checkingLoadCompleteForDetachment = false;
1889 }
1890 
1891 void FrameLoader::stopForUserCancel(bool deferCheckLoadComplete)
1892 {
1893     // Calling stopAllLoaders can cause the frame to be deallocated, including the frame loader.
1894     Ref&lt;Frame&gt; protectedFrame(m_frame);
1895 
1896     stopAllLoaders();
1897 
1898 #if PLATFORM(IOS_FAMILY)
1899     // Lay out immediately when stopping to immediately clear the old page if we just committed this one
1900     // but haven&#39;t laid out/painted yet.
1901     // FIXME: Is this behavior specific to iOS? Or should we expose a setting to toggle this behavior?
1902     if (m_frame.view() &amp;&amp; !m_frame.view()-&gt;didFirstLayout())
1903         m_frame.view()-&gt;layoutContext().layout();
1904 #endif
1905 
1906     if (deferCheckLoadComplete)
1907         scheduleCheckLoadComplete();
1908     else if (m_frame.page())
1909         checkLoadComplete();
1910 }
1911 
1912 DocumentLoader* FrameLoader::activeDocumentLoader() const
1913 {
1914     if (m_state == FrameStateProvisional)
1915         return m_provisionalDocumentLoader.get();
1916     return m_documentLoader.get();
1917 }
1918 
1919 bool FrameLoader::isLoading() const
1920 {
1921     DocumentLoader* docLoader = activeDocumentLoader();
1922     if (!docLoader)
1923         return false;
1924     return docLoader-&gt;isLoading();
1925 }
1926 
1927 bool FrameLoader::frameHasLoaded() const
1928 {
1929     return m_stateMachine.committedFirstRealDocumentLoad() || (m_provisionalDocumentLoader &amp;&amp; !m_stateMachine.creatingInitialEmptyDocument());
1930 }
1931 
1932 void FrameLoader::setDocumentLoader(DocumentLoader* loader)
1933 {
1934     if (!loader &amp;&amp; !m_documentLoader)
1935         return;
1936 
1937     if (loader == m_documentLoader)
1938         return;
1939 
1940     ASSERT(loader != m_documentLoader);
1941     ASSERT(!loader || loader-&gt;frameLoader() == this);
1942 
1943     m_client.prepareForDataSourceReplacement();
1944     detachChildren();
1945 
1946     // detachChildren() can trigger this frame&#39;s unload event, and therefore
1947     // script can run and do just about anything. For example, an unload event that calls
1948     // document.write(&quot;&quot;) on its parent frame can lead to a recursive detachChildren()
1949     // invocation for this frame. In that case, we can end up at this point with a
1950     // loader that hasn&#39;t been deleted but has been detached from its frame. Such a
1951     // DocumentLoader has been sufficiently detached that we&#39;ll end up in an inconsistent
1952     // state if we try to use it.
1953     if (loader &amp;&amp; !loader-&gt;frame())
1954         return;
1955 
1956     if (m_documentLoader)
1957         m_documentLoader-&gt;detachFromFrame();
1958 
1959     m_documentLoader = loader;
1960 }
1961 
1962 void FrameLoader::setPolicyDocumentLoader(DocumentLoader* loader)
1963 {
1964     if (m_policyDocumentLoader == loader)
1965         return;
1966 
1967     if (loader)
1968         loader-&gt;attachToFrame(m_frame);
1969     if (m_policyDocumentLoader
1970             &amp;&amp; m_policyDocumentLoader != m_provisionalDocumentLoader
1971             &amp;&amp; m_policyDocumentLoader != m_documentLoader)
1972         m_policyDocumentLoader-&gt;detachFromFrame();
1973 
1974     m_policyDocumentLoader = loader;
1975 }
1976 
1977 void FrameLoader::setProvisionalDocumentLoader(DocumentLoader* loader)
1978 {
1979     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;setProvisionalDocumentLoader: Setting provisional document loader (m_provisionalDocumentLoader=%p)&quot;, loader);
1980 
1981     ASSERT(!loader || !m_provisionalDocumentLoader);
1982     ASSERT(!loader || loader-&gt;frameLoader() == this);
1983 
1984     if (m_provisionalDocumentLoader &amp;&amp; m_provisionalDocumentLoader != m_documentLoader)
1985         m_provisionalDocumentLoader-&gt;detachFromFrame();
1986 
1987     m_provisionalDocumentLoader = loader;
1988 }
1989 
1990 void FrameLoader::setState(FrameState newState)
1991 {
1992     FrameState oldState = m_state;
1993     m_state = newState;
1994 
1995     if (newState == FrameStateProvisional)
1996         provisionalLoadStarted();
1997     else if (newState == FrameStateComplete) {
1998         frameLoadCompleted();
1999         if (m_documentLoader)
2000             m_documentLoader-&gt;stopRecordingResponses();
2001         if (m_frame.isMainFrame() &amp;&amp; oldState != newState) {
2002             FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;setState: main frame load completed&quot;);
2003             m_frame.page()-&gt;performanceLogging().didReachPointOfInterest(PerformanceLogging::MainFrameLoadCompleted);
2004         }
2005     }
2006 }
2007 
2008 void FrameLoader::clearProvisionalLoad()
2009 {
2010     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;clearProvisionalLoad: Clearing provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());
2011     setProvisionalDocumentLoader(nullptr);
2012     m_progressTracker-&gt;progressCompleted();
2013     setState(FrameStateComplete);
2014 }
2015 
2016 void FrameLoader::commitProvisionalLoad()
2017 {
2018     RefPtr&lt;DocumentLoader&gt; pdl = m_provisionalDocumentLoader;
2019     Ref&lt;Frame&gt; protect(m_frame);
2020 
2021     std::unique_ptr&lt;CachedPage&gt; cachedPage;
2022     if (m_loadingFromCachedPage &amp;&amp; history().provisionalItem())
2023         cachedPage = BackForwardCache::singleton().take(*history().provisionalItem(), m_frame.page());
2024 
2025     LOG(BackForwardCache, &quot;WebCoreLoading %s: About to commit provisional load from previous URL &#39;%s&#39; to new URL &#39;%s&#39; with cached page %p&quot;, m_frame.tree().uniqueName().string().utf8().data(),
2026         m_frame.document() ? m_frame.document()-&gt;url().stringCenterEllipsizedToLength().utf8().data() : &quot;&quot;,
2027         pdl ? pdl-&gt;url().stringCenterEllipsizedToLength().utf8().data() : &quot;&lt;no provisional DocumentLoader&gt;&quot;, cachedPage.get());
2028 
2029     willTransitionToCommitted();
2030 
2031     if (!m_frame.tree().parent() &amp;&amp; history().currentItem() &amp;&amp; history().currentItem() != history().provisionalItem()) {
2032         // Check to see if we need to cache the page we are navigating away from into the back/forward cache.
2033         // We are doing this here because we know for sure that a new page is about to be loaded.
2034         BackForwardCache::singleton().addIfCacheable(*history().currentItem(), m_frame.page());
2035 
2036         WebCore::jettisonExpensiveObjectsOnTopLevelNavigation();
2037     }
2038 
2039     if (m_loadType != FrameLoadType::Replace)
2040         closeOldDataSources();
2041 
2042     if (!cachedPage &amp;&amp; !m_stateMachine.creatingInitialEmptyDocument())
2043         m_client.makeRepresentation(pdl.get());
2044 
2045     transitionToCommitted(cachedPage.get());
2046 
2047     if (pdl &amp;&amp; m_documentLoader) {
2048         // Check if the destination page is allowed to access the previous page&#39;s timing information.
2049         Ref&lt;SecurityOrigin&gt; securityOrigin(SecurityOrigin::create(pdl-&gt;request().url()));
2050         m_documentLoader-&gt;timing().setHasSameOriginAsPreviousDocument(securityOrigin.get().canRequest(m_previousURL));
2051     }
2052 
2053     // Call clientRedirectCancelledOrFinished() here so that the frame load delegate is notified that the redirect&#39;s
2054     // status has changed, if there was a redirect.  The frame load delegate may have saved some state about
2055     // the redirect in its -webView:willPerformClientRedirectToURL:delay:fireDate:forFrame:.  Since we are
2056     // just about to commit a new page, there cannot possibly be a pending redirect at this point.
2057     if (m_sentRedirectNotification)
2058         clientRedirectCancelledOrFinished(NewLoadInProgress::No);
2059 
2060     if (cachedPage &amp;&amp; cachedPage-&gt;document()) {
2061 #if PLATFORM(IOS_FAMILY)
2062         // FIXME: CachedPage::restore() would dispatch viewport change notification. However UIKit expects load
2063         // commit to happen before any changes to viewport arguments and dealing with this there is difficult.
2064         m_frame.page()-&gt;chrome().setDispatchViewportDataDidChangeSuppressed(true);
2065 #endif
2066         willRestoreFromCachedPage();
2067 
2068         // Start request for the main resource and dispatch didReceiveResponse before the load is committed for
2069         // consistency with all other loads. See https://bugs.webkit.org/show_bug.cgi?id=150927.
2070         ResourceError mainResouceError;
2071         unsigned long mainResourceIdentifier;
2072         ResourceRequest mainResourceRequest(cachedPage-&gt;documentLoader()-&gt;request());
2073         requestFromDelegate(mainResourceRequest, mainResourceIdentifier, mainResouceError);
2074         notifier().dispatchDidReceiveResponse(cachedPage-&gt;documentLoader(), mainResourceIdentifier, cachedPage-&gt;documentLoader()-&gt;response());
2075 
2076         Optional&lt;HasInsecureContent&gt; hasInsecureContent = cachedPage-&gt;cachedMainFrame()-&gt;hasInsecureContent();
2077 
2078         dispatchDidCommitLoad(hasInsecureContent);
2079 
2080         // FIXME: This API should be turned around so that we ground CachedPage into the Page.
2081         cachedPage-&gt;restore(*m_frame.page());
2082 
2083 #if PLATFORM(IOS_FAMILY)
2084         m_frame.page()-&gt;chrome().setDispatchViewportDataDidChangeSuppressed(false);
2085         m_frame.page()-&gt;chrome().dispatchViewportPropertiesDidChange(m_frame.page()-&gt;viewportArguments());
2086 #endif
2087         m_frame.page()-&gt;chrome().dispatchDisabledAdaptationsDidChange(m_frame.page()-&gt;disabledAdaptations());
2088 
2089         auto&amp; title = m_documentLoader-&gt;title();
2090         if (!title.string.isNull())
2091             m_client.dispatchDidReceiveTitle(title);
2092 
2093         // Send remaining notifications for the main resource.
2094         notifier().sendRemainingDelegateMessages(m_documentLoader.get(), mainResourceIdentifier, mainResourceRequest, ResourceResponse(),
2095             nullptr, static_cast&lt;int&gt;(m_documentLoader-&gt;response().expectedContentLength()), 0, mainResouceError);
2096 
2097         checkCompleted();
2098     } else
2099         didOpenURL();
2100 
2101     LOG(Loading, &quot;WebCoreLoading %s: Finished committing provisional load to URL %s&quot;, m_frame.tree().uniqueName().string().utf8().data(),
2102         m_frame.document() ? m_frame.document()-&gt;url().stringCenterEllipsizedToLength().utf8().data() : &quot;&quot;);
2103 
2104     if (m_loadType == FrameLoadType::Standard &amp;&amp; m_documentLoader &amp;&amp; m_documentLoader-&gt;isClientRedirect())
2105         history().updateForClientRedirect();
2106 
2107     if (m_loadingFromCachedPage) {
2108         // Note, didReceiveDocType is expected to be called for cached pages. See &lt;rdar://problem/5906758&gt; for more details.
2109         if (auto* page = m_frame.page())
2110             page-&gt;chrome().didReceiveDocType(m_frame);
2111         m_frame.document()-&gt;resume(ReasonForSuspension::BackForwardCache);
2112 
2113         // Force a layout to update view size and thereby update scrollbars.
2114 #if PLATFORM(IOS_FAMILY)
2115         if (!m_client.forceLayoutOnRestoreFromBackForwardCache())
2116             m_frame.view()-&gt;forceLayout();
2117 #else
2118         m_frame.view()-&gt;forceLayout();
2119 #endif
2120 
2121         // Main resource delegates were already sent, so we skip the first response here.
2122         for (unsigned i = 1; i &lt; m_documentLoader-&gt;responses().size(); ++i) {
2123             const auto&amp; response = m_documentLoader-&gt;responses()[i];
2124             // FIXME: If the WebKit client changes or cancels the request, this is not respected.
2125             ResourceError error;
2126             unsigned long identifier;
2127             ResourceRequest request(response.url());
2128             requestFromDelegate(request, identifier, error);
2129             // FIXME: If we get a resource with more than 2B bytes, this code won&#39;t do the right thing.
2130             // However, with today&#39;s computers and networking speeds, this won&#39;t happen in practice.
2131             // Could be an issue with a giant local file.
2132             notifier().sendRemainingDelegateMessages(m_documentLoader.get(), identifier, request, response, 0, static_cast&lt;int&gt;(response.expectedContentLength()), 0, error);
2133         }
2134 
2135         // FIXME: Why only this frame and not parent frames?
2136         checkLoadCompleteForThisFrame();
2137     }
2138 }
2139 
2140 void FrameLoader::transitionToCommitted(CachedPage* cachedPage)
2141 {
2142     ASSERT(m_client.hasWebView());
2143     ASSERT(m_state == FrameStateProvisional);
2144 
2145     if (m_state != FrameStateProvisional)
2146         return;
2147 
2148     if (FrameView* view = m_frame.view()) {
2149         if (ScrollAnimator* scrollAnimator = view-&gt;existingScrollAnimator())
2150             scrollAnimator-&gt;cancelAnimations();
2151     }
2152 
2153     m_client.setCopiesOnScroll();
2154     history().updateForCommit();
2155 
2156     // The call to closeURL() invokes the unload event handler, which can execute arbitrary
2157     // JavaScript. If the script initiates a new load, we need to abandon the current load,
2158     // or the two will stomp each other.
2159     DocumentLoader* pdl = m_provisionalDocumentLoader.get();
2160     if (m_documentLoader)
2161         closeURL();
2162     if (pdl != m_provisionalDocumentLoader)
2163         return;
2164 
2165     if (m_documentLoader)
2166         m_documentLoader-&gt;stopLoadingSubresources();
2167     if (m_documentLoader)
2168         m_documentLoader-&gt;stopLoadingPlugIns();
2169 
2170     // Setting our document loader invokes the unload event handler of our child frames.
2171     // Script can do anything. If the script initiates a new load, we need to abandon the
2172     // current load or the two will stomp each other.
2173     setDocumentLoader(m_provisionalDocumentLoader.get());
2174     if (pdl != m_provisionalDocumentLoader)
2175         return;
2176     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;transitionToCommitted: Clearing provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());
2177     setProvisionalDocumentLoader(nullptr);
2178 
2179     // Nothing else can interrupt this commit - set the Provisional-&gt;Committed transition in stone
2180     setState(FrameStateCommittedPage);
2181 
2182     // Handle adding the URL to the back/forward list.
2183     DocumentLoader* dl = m_documentLoader.get();
2184 
2185     switch (m_loadType) {
2186     case FrameLoadType::Forward:
2187     case FrameLoadType::Back:
2188     case FrameLoadType::IndexedBackForward:
2189         if (m_frame.page()) {
2190             // If the first load within a frame is a navigation within a back/forward list that was attached
2191             // without any of the items being loaded then we need to update the history in a similar manner as
2192             // for a standard load with the exception of updating the back/forward list (&lt;rdar://problem/8091103&gt;).
2193             if (!m_stateMachine.committedFirstRealDocumentLoad() &amp;&amp; m_frame.isMainFrame())
2194                 history().updateForStandardLoad(HistoryController::UpdateAllExceptBackForwardList);
2195 
2196             history().updateForBackForwardNavigation();
2197 
2198             // For cached pages, CachedFrame::restore will take care of firing the popstate event with the history item&#39;s state object
2199             if (history().currentItem() &amp;&amp; !cachedPage)
2200                 m_pendingStateObject = history().currentItem()-&gt;stateObject();
2201 
2202             // Create a document view for this document, or used the cached view.
2203             if (cachedPage) {
2204                 DocumentLoader* cachedDocumentLoader = cachedPage-&gt;documentLoader();
2205                 ASSERT(cachedDocumentLoader);
2206                 cachedDocumentLoader-&gt;attachToFrame(m_frame);
2207                 m_client.transitionToCommittedFromCachedFrame(cachedPage-&gt;cachedMainFrame());
2208             } else
2209                 m_client.transitionToCommittedForNewPage();
2210         }
2211         break;
2212 
2213     case FrameLoadType::Reload:
2214     case FrameLoadType::ReloadFromOrigin:
2215     case FrameLoadType::ReloadExpiredOnly:
2216     case FrameLoadType::Same:
2217     case FrameLoadType::Replace:
2218         history().updateForReload();
2219         m_client.transitionToCommittedForNewPage();
2220         break;
2221 
2222     case FrameLoadType::Standard:
2223         history().updateForStandardLoad();
2224         if (m_frame.view())
2225             m_frame.view()-&gt;setScrollbarsSuppressed(true);
2226         m_client.transitionToCommittedForNewPage();
2227         break;
2228 
2229     case FrameLoadType::RedirectWithLockedBackForwardList:
2230         history().updateForRedirectWithLockedBackForwardList();
2231         m_client.transitionToCommittedForNewPage();
2232         break;
2233     }
2234 
2235     m_documentLoader-&gt;writer().setMIMEType(dl-&gt;responseMIMEType());
2236 
2237     // Tell the client we&#39;ve committed this URL.
2238     ASSERT(m_frame.view());
2239 
2240     if (m_stateMachine.creatingInitialEmptyDocument())
2241         return;
2242 
2243     if (!m_stateMachine.committedFirstRealDocumentLoad())
2244         m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocumentPostCommit);
2245 }
2246 
2247 void FrameLoader::clientRedirectCancelledOrFinished(NewLoadInProgress newLoadInProgress)
2248 {
2249     // Note that -webView:didCancelClientRedirectForFrame: is called on the frame load delegate even if
2250     // the redirect succeeded.  We should either rename this API, or add a new method, like
2251     // -webView:didFinishClientRedirectForFrame:
2252     m_client.dispatchDidCancelClientRedirect();
2253 
2254     if (newLoadInProgress == NewLoadInProgress::No)
2255         m_quickRedirectComing = false;
2256 
2257     m_sentRedirectNotification = false;
2258 }
2259 
2260 void FrameLoader::clientRedirected(const URL&amp; url, double seconds, WallTime fireDate, LockBackForwardList lockBackForwardList)
2261 {
2262     m_client.dispatchWillPerformClientRedirect(url, seconds, fireDate, lockBackForwardList);
2263 
2264     // Remember that we sent a redirect notification to the frame load delegate so that when we commit
2265     // the next provisional load, we can send a corresponding -webView:didCancelClientRedirectForFrame:
2266     m_sentRedirectNotification = true;
2267 
2268     // If a &quot;quick&quot; redirect comes in, we set a special mode so we treat the next
2269     // load as part of the original navigation. If we don&#39;t have a document loader, we have
2270     // no &quot;original&quot; load on which to base a redirect, so we treat the redirect as a normal load.
2271     // Loads triggered by JavaScript form submissions never count as quick redirects.
2272     m_quickRedirectComing = (lockBackForwardList == LockBackForwardList::Yes || history().currentItemShouldBeReplaced()) &amp;&amp; m_documentLoader &amp;&amp; !m_isExecutingJavaScriptFormAction;
2273 }
2274 
2275 bool FrameLoader::shouldReload(const URL&amp; currentURL, const URL&amp; destinationURL)
2276 {
2277     // This function implements the rule: &quot;Don&#39;t reload if navigating by fragment within
2278     // the same URL, but do reload if going to a new URL or to the same URL with no
2279     // fragment identifier at all.&quot;
2280     if (!destinationURL.hasFragmentIdentifier())
2281         return true;
2282     return !equalIgnoringFragmentIdentifier(currentURL, destinationURL);
2283 }
2284 
2285 void FrameLoader::closeOldDataSources()
2286 {
2287     // FIXME: Is it important for this traversal to be postorder instead of preorder?
2288     // If so, add helpers for postorder traversal, and use them. If not, then lets not
2289     // use a recursive algorithm here.
2290     for (Frame* child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())
2291         child-&gt;loader().closeOldDataSources();
2292 
2293     if (m_documentLoader)
2294         m_client.dispatchWillClose();
2295 
2296     m_client.setMainFrameDocumentReady(false); // stop giving out the actual DOMDocument to observers
2297 }
2298 
2299 void FrameLoader::willRestoreFromCachedPage()
2300 {
2301     ASSERT(!m_frame.tree().parent());
2302     ASSERT(m_frame.page());
2303     ASSERT(m_frame.isMainFrame());
2304 
2305     m_frame.navigationScheduler().cancel();
2306 
2307     // We still have to close the previous part page.
2308     closeURL();
2309 
2310     // Delete old status bar messages (if it _was_ activated on last URL).
2311     if (m_frame.script().canExecuteScripts(NotAboutToExecuteScript)) {
2312         DOMWindow* window = m_frame.document()-&gt;domWindow();
2313         window-&gt;setStatus(String());
2314         window-&gt;setDefaultStatus(String());
2315     }
2316 }
2317 
2318 void FrameLoader::open(CachedFrameBase&amp; cachedFrame)
2319 {
2320     m_isComplete = false;
2321 
2322     // Don&#39;t re-emit the load event.
2323     m_didCallImplicitClose = true;
2324 
2325     URL url = cachedFrame.url();
2326 
2327     // FIXME: I suspect this block of code doesn&#39;t do anything.
2328     if (url.protocolIsInHTTPFamily() &amp;&amp; !url.host().isEmpty() &amp;&amp; url.path().isEmpty())
2329         url.setPath(&quot;/&quot;);
2330 
2331     started();
2332     auto document = makeRef(*cachedFrame.document());
2333     ASSERT(document-&gt;domWindow());
2334 
2335     clear(document.ptr(), true, true, cachedFrame.isMainFrame());
2336 
2337     document-&gt;attachToCachedFrame(cachedFrame);
2338     document-&gt;setBackForwardCacheState(Document::NotInBackForwardCache);
2339 
2340     m_needsClear = true;
2341     m_isComplete = false;
2342     m_didCallImplicitClose = false;
2343     setOutgoingReferrer(url);
2344 
2345     FrameView* view = cachedFrame.view();
2346 
2347     // When navigating to a CachedFrame its FrameView should never be null.  If it is we&#39;ll crash in creative ways downstream.
2348     ASSERT(view);
2349     view-&gt;setWasScrolledByUser(false);
2350 
2351     Optional&lt;IntRect&gt; previousViewFrameRect = m_frame.view() ?  m_frame.view()-&gt;frameRect() : Optional&lt;IntRect&gt;(WTF::nullopt);
2352     m_frame.setView(view);
2353 
2354     // Use the previous ScrollView&#39;s frame rect.
2355     if (previousViewFrameRect)
2356         view-&gt;setFrameRect(previousViewFrameRect.value());
2357 
2358 
2359     // Setting the document builds the render tree and runs post style resolution callbacks that can do anything,
2360     // including loading a child frame before its been re-attached to the frame tree as part of this restore.
2361     // For example, the HTML object element may load its content into a frame in a post style resolution callback.
2362     Style::PostResolutionCallbackDisabler disabler(document.get());
2363     WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
2364     NavigationDisabler disableNavigation { &amp;m_frame };
2365 
2366     m_frame.setDocument(document.copyRef());
2367 
2368     document-&gt;domWindow()-&gt;resumeFromBackForwardCache();
2369 
2370     updateFirstPartyForCookies();
2371 
2372     cachedFrame.restore();
2373 }
2374 
2375 bool FrameLoader::isHostedByObjectElement() const
2376 {
2377     HTMLFrameOwnerElement* owner = m_frame.ownerElement();
2378     return owner &amp;&amp; owner-&gt;hasTagName(objectTag);
2379 }
2380 
2381 bool FrameLoader::isReplacing() const
2382 {
2383     return m_loadType == FrameLoadType::Replace;
2384 }
2385 
2386 void FrameLoader::setReplacing()
2387 {
2388     m_loadType = FrameLoadType::Replace;
2389 }
2390 
2391 bool FrameLoader::subframeIsLoading() const
2392 {
2393     // It&#39;s most likely that the last added frame is the last to load so we walk backwards.
2394     for (Frame* child = m_frame.tree().lastChild(); child; child = child-&gt;tree().previousSibling()) {
2395         FrameLoader&amp; childLoader = child-&gt;loader();
2396         DocumentLoader* documentLoader = childLoader.documentLoader();
2397         if (documentLoader &amp;&amp; documentLoader-&gt;isLoadingInAPISense())
2398             return true;
2399         documentLoader = childLoader.provisionalDocumentLoader();
2400         if (documentLoader &amp;&amp; documentLoader-&gt;isLoadingInAPISense())
2401             return true;
2402         documentLoader = childLoader.policyDocumentLoader();
2403         if (documentLoader)
2404             return true;
2405     }
2406     return false;
2407 }
2408 
2409 void FrameLoader::willChangeTitle(DocumentLoader* loader)
2410 {
2411     m_client.willChangeTitle(loader);
2412 }
2413 
2414 FrameLoadType FrameLoader::loadType() const
2415 {
2416     return m_loadType;
2417 }
2418 
2419 CachePolicy FrameLoader::subresourceCachePolicy(const URL&amp; url) const
2420 {
2421     if (Page* page = m_frame.page()) {
2422         if (page-&gt;isResourceCachingDisabledByWebInspector())
2423             return CachePolicyReload;
2424     }
2425 
2426     if (m_isComplete)
2427         return CachePolicyVerify;
2428 
2429     if (m_loadType == FrameLoadType::ReloadFromOrigin)
2430         return CachePolicyReload;
2431 
2432     if (Frame* parentFrame = m_frame.tree().parent()) {
2433         CachePolicy parentCachePolicy = parentFrame-&gt;loader().subresourceCachePolicy(url);
2434         if (parentCachePolicy != CachePolicyVerify)
2435             return parentCachePolicy;
2436     }
2437 
2438     switch (m_loadType) {
2439     case FrameLoadType::Reload:
2440         return CachePolicyRevalidate;
2441     case FrameLoadType::Back:
2442     case FrameLoadType::Forward:
2443     case FrameLoadType::IndexedBackForward:
2444         return CachePolicyHistoryBuffer;
2445     case FrameLoadType::ReloadFromOrigin:
2446         ASSERT_NOT_REACHED(); // Already handled above.
2447         return CachePolicyReload;
2448     case FrameLoadType::RedirectWithLockedBackForwardList:
2449     case FrameLoadType::Replace:
2450     case FrameLoadType::Same:
2451     case FrameLoadType::Standard:
2452         return CachePolicyVerify;
2453     case FrameLoadType::ReloadExpiredOnly:
2454         // We know about expiration for HTTP and data. Do a normal reload otherwise.
2455         if (!url.protocolIsInHTTPFamily() &amp;&amp; !url.protocolIsData())
2456             return CachePolicyReload;
2457         return CachePolicyVerify;
2458     }
2459 
2460     RELEASE_ASSERT_NOT_REACHED();
2461     return CachePolicyVerify;
2462 }
2463 
2464 void FrameLoader::dispatchDidFailProvisionalLoad(DocumentLoader&amp; provisionalDocumentLoader, const ResourceError&amp; error)
2465 {
2466     m_provisionalLoadErrorBeingHandledURL = provisionalDocumentLoader.url();
2467 
2468 #if ENABLE(CONTENT_FILTERING)
2469     auto contentFilter = provisionalDocumentLoader.contentFilter();
2470     auto contentFilterWillContinueLoading = false;
2471 #endif
2472 
2473     auto willContinueLoading = WillContinueLoading::No;
2474     if (history().provisionalItem())
2475         willContinueLoading = WillContinueLoading::Yes;
2476 #if ENABLE(CONTENT_FILTERING)
2477     if (contentFilter &amp;&amp; contentFilter-&gt;willHandleProvisionalLoadFailure(error)) {
2478         willContinueLoading = WillContinueLoading::Yes;
2479         contentFilterWillContinueLoading = true;
2480     }
2481 #endif
2482 
2483     m_client.dispatchDidFailProvisionalLoad(error, willContinueLoading);
2484 
2485 #if ENABLE(CONTENT_FILTERING)
2486     if (contentFilterWillContinueLoading)
2487         contentFilter-&gt;handleProvisionalLoadFailure(error);
2488 #endif
2489 
2490     m_provisionalLoadErrorBeingHandledURL = { };
2491 }
2492 
2493 void FrameLoader::checkLoadCompleteForThisFrame()
2494 {
2495     ASSERT(m_client.hasWebView());
2496 
2497     // FIXME: Should this check be done in checkLoadComplete instead of here?
2498     // FIXME: Why does this one check need to be repeated here, and not the many others from checkCompleted?
2499     if (m_frame.document()-&gt;isDelayingLoadEvent())
2500         return;
2501 
2502     switch (m_state) {
2503         case FrameStateProvisional: {
2504             // FIXME: Prohibiting any provisional load failures from being sent to clients
2505             // while handling provisional load failures is too heavy. For example, the current
2506             // load will fail to cancel another ongoing load. That might prevent clients&#39; page
2507             // load state being handled properly.
2508             if (!m_provisionalLoadErrorBeingHandledURL.isEmpty())
2509                 return;
2510 
2511             RefPtr&lt;DocumentLoader&gt; pdl = m_provisionalDocumentLoader;
2512             if (!pdl)
2513                 return;
2514 
2515             // If we&#39;ve received any errors we may be stuck in the provisional state and actually complete.
2516             const ResourceError&amp; error = pdl-&gt;mainDocumentError();
2517             if (error.isNull())
2518                 return;
2519 
2520             // Check all children first.
2521             RefPtr&lt;HistoryItem&gt; item;
2522             if (Page* page = m_frame.page())
2523                 if (isBackForwardLoadType(loadType()))
2524                     // Reset the back forward list to the last committed history item at the top level.
2525                     item = page-&gt;mainFrame().loader().history().currentItem();
2526 
2527             // Only reset if we aren&#39;t already going to a new provisional item.
2528             bool shouldReset = !history().provisionalItem();
2529             if (!pdl-&gt;isLoadingInAPISense() || pdl-&gt;isStopping()) {
2530                 FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;checkLoadCompleteForThisFrame: Failed provisional load (isTimeout = %d, isCancellation = %d, errorCode = %d)&quot;, error.isTimeout(), error.isCancellation(), error.errorCode());
2531 
2532                 dispatchDidFailProvisionalLoad(*pdl, error);
2533                 ASSERT(!pdl-&gt;isLoading());
2534 
2535                 // If we&#39;re in the middle of loading multipart data, we need to restore the document loader.
2536                 if (isReplacing() &amp;&amp; !m_documentLoader.get())
2537                     setDocumentLoader(m_provisionalDocumentLoader.get());
2538 
2539                 // Finish resetting the load state, but only if another load hasn&#39;t been started by the
2540                 // delegate callback.
2541                 if (pdl == m_provisionalDocumentLoader)
2542                     clearProvisionalLoad();
2543                 else if (activeDocumentLoader()) {
2544                     URL unreachableURL = activeDocumentLoader()-&gt;unreachableURL();
2545                     if (!unreachableURL.isEmpty() &amp;&amp; unreachableURL == pdl-&gt;request().url())
2546                         shouldReset = false;
2547                 }
2548             }
2549             if (shouldReset &amp;&amp; item)
2550                 if (Page* page = m_frame.page()) {
2551                     page-&gt;backForward().setCurrentItem(*item);
2552                 }
2553             return;
2554         }
2555 
2556         case FrameStateCommittedPage: {
2557             if (!m_documentLoader)
2558                 return;
2559             if (m_documentLoader-&gt;isLoadingInAPISense() &amp;&amp; !m_documentLoader-&gt;isStopping() &amp;&amp; !m_checkingLoadCompleteForDetachment)
2560                 return;
2561 
2562             setState(FrameStateComplete);
2563 
2564             // FIXME: Is this subsequent work important if we already navigated away?
2565             // Maybe there are bugs because of that, or extra work we can skip because
2566             // the new page is ready.
2567 
2568             m_client.forceLayoutForNonHTML();
2569 
2570             // If the user had a scroll point, scroll to it, overriding the anchor point if any.
2571             if (m_frame.page()) {
2572                 if (isBackForwardLoadType(m_loadType) || isReload(m_loadType))
2573                     history().restoreScrollPositionAndViewState();
2574             }
2575 
2576             if (m_stateMachine.creatingInitialEmptyDocument() || !m_stateMachine.committedFirstRealDocumentLoad())
2577                 return;
2578 
2579             m_progressTracker-&gt;progressCompleted();
2580             Page* page = m_frame.page();
2581             if (page) {
2582                 if (m_frame.isMainFrame()) {
2583                     tracePoint(MainResourceLoadDidEnd);
2584                     page-&gt;didFinishLoad();
2585                 }
2586             }
2587 
2588             const ResourceError&amp; error = m_documentLoader-&gt;mainDocumentError();
2589 
2590             AXObjectCache::AXLoadingEvent loadingEvent;
2591             if (!error.isNull()) {
2592                 FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;checkLoadCompleteForThisFrame: Finished frame load with error (isTimeout = %d, isCancellation = %d, errorCode = %d)&quot;, error.isTimeout(), error.isCancellation(), error.errorCode());
2593                 m_client.dispatchDidFailLoad(error);
2594                 loadingEvent = AXObjectCache::AXLoadingFailed;
2595             } else {
2596                 FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;checkLoadCompleteForThisFrame: Finished frame load&quot;);
2597 #if ENABLE(DATA_DETECTION)
2598                 auto* document = m_frame.document();
2599                 if (m_frame.settings().dataDetectorTypes() != DataDetectorTypeNone &amp;&amp; document) {
2600                     if (auto* documentElement = document-&gt;documentElement()) {
2601                         RefPtr&lt;Range&gt; documentRange = makeRange(firstPositionInNode(documentElement), lastPositionInNode(documentElement));
2602                         m_frame.setDataDetectionResults(DataDetection::detectContentInRange(documentRange, m_frame.settings().dataDetectorTypes(), m_client.dataDetectionContext()));
2603                         if (m_frame.isMainFrame())
2604                             m_client.dispatchDidFinishDataDetection(m_frame.dataDetectionResults());
2605                     }
2606                 }
2607 #endif
2608                 m_client.dispatchDidFinishLoad();
2609                 loadingEvent = AXObjectCache::AXLoadingFinished;
2610             }
2611 
2612             // Notify accessibility.
2613             if (auto* document = m_frame.document()) {
2614                 if (AXObjectCache* cache = document-&gt;existingAXObjectCache())
2615                     cache-&gt;frameLoadingEventNotification(&amp;m_frame, loadingEvent);
2616             }
2617 
2618             // The above calls to dispatchDidFinishLoad() might have detached the Frame
2619             // from its Page and also might have caused Page to be deleted.
2620             // Don&#39;t assume &#39;page&#39; is still available to use.
2621             if (m_frame.isMainFrame() &amp;&amp; m_frame.page()) {
2622                 ASSERT(&amp;m_frame.page()-&gt;mainFrame() == &amp;m_frame);
2623                 m_frame.page()-&gt;diagnosticLoggingClient().logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageLoadedKey(), emptyString(), error.isNull() ? DiagnosticLoggingResultPass : DiagnosticLoggingResultFail, ShouldSample::Yes);
2624             }
2625 
2626             return;
2627         }
2628 
2629         case FrameStateComplete:
2630             m_loadType = FrameLoadType::Standard;
2631             frameLoadCompleted();
2632             return;
2633     }
2634 
2635     ASSERT_NOT_REACHED();
2636 }
2637 
2638 void FrameLoader::setOriginalURLForDownloadRequest(ResourceRequest&amp; request)
2639 {
2640     // FIXME: Rename firstPartyForCookies back to mainDocumentURL. It was a mistake to think that it was only used for cookies.
2641     // The originalURL is defined as the URL of the page where the download was initiated.
2642     URL originalURL;
2643     auto* initiator = m_frame.document();
2644     if (initiator) {
2645         originalURL = initiator-&gt;firstPartyForCookies();
2646         // If there is no main document URL, it means that this document is newly opened and just for download purpose.
2647         // In this case, we need to set the originalURL to this document&#39;s opener&#39;s main document URL.
2648         if (originalURL.isEmpty() &amp;&amp; opener() &amp;&amp; opener()-&gt;document()) {
2649             originalURL = opener()-&gt;document()-&gt;firstPartyForCookies();
2650             initiator = opener()-&gt;document();
2651         }
2652     }
2653     // If the originalURL is the same as the requested URL, we are processing a download
2654     // initiated directly without a page and do not need to specify the originalURL.
2655     if (originalURL == request.url())
2656         request.setFirstPartyForCookies(URL());
2657     else
2658         request.setFirstPartyForCookies(originalURL);
2659     addSameSiteInfoToRequestIfNeeded(request, initiator);
2660 }
2661 
2662 void FrameLoader::didReachLayoutMilestone(OptionSet&lt;LayoutMilestone&gt; milestones)
2663 {
2664     ASSERT(m_frame.isMainFrame());
2665 
2666     m_client.dispatchDidReachLayoutMilestone(milestones);
2667 }
2668 
2669 void FrameLoader::didFirstLayout()
2670 {
2671 #if PLATFORM(IOS_FAMILY)
2672     // Only send layout-related delegate callbacks synchronously for the main frame to
2673     // avoid reentering layout for the main frame while delivering a layout-related delegate
2674     // callback for a subframe.
2675     if (&amp;m_frame != &amp;m_frame.page()-&gt;mainFrame())
2676         return;
2677 #endif
2678     if (m_frame.page() &amp;&amp; isBackForwardLoadType(m_loadType))
2679         history().restoreScrollPositionAndViewState();
2680 
2681     if (m_stateMachine.committedFirstRealDocumentLoad() &amp;&amp; !m_stateMachine.isDisplayingInitialEmptyDocument() &amp;&amp; !m_stateMachine.firstLayoutDone())
2682         m_stateMachine.advanceTo(FrameLoaderStateMachine::FirstLayoutDone);
2683 }
2684 
2685 void FrameLoader::frameLoadCompleted()
2686 {
2687     // Note: Can be called multiple times.
2688 
2689     m_client.frameLoadCompleted();
2690 
2691     history().updateForFrameLoadCompleted();
2692 
2693     // After a canceled provisional load, firstLayoutDone is false.
2694     // Reset it to true if we&#39;re displaying a page.
2695     if (m_documentLoader &amp;&amp; m_stateMachine.committedFirstRealDocumentLoad() &amp;&amp; !m_stateMachine.isDisplayingInitialEmptyDocument() &amp;&amp; !m_stateMachine.firstLayoutDone())
2696         m_stateMachine.advanceTo(FrameLoaderStateMachine::FirstLayoutDone);
2697 }
2698 
2699 void FrameLoader::detachChildren()
2700 {
2701     // detachChildren() will fire the unload event in each subframe and the
2702     // HTML specification states that the parent document&#39;s ignore-opens-during-unload counter while
2703     // this event is being fired in its subframes:
2704     // https://html.spec.whatwg.org/multipage/browsers.html#unload-a-document
2705     IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(m_frame.document());
2706 
2707     // detachChildren() will fire the unload event in each subframe and the
2708     // HTML specification states that navigations should be prevented during the prompt to unload algorithm:
2709     // https://html.spec.whatwg.org/multipage/browsing-the-web.html#navigate
2710     std::unique_ptr&lt;NavigationDisabler&gt; navigationDisabler;
2711     if (m_frame.isMainFrame())
2712         navigationDisabler = makeUnique&lt;NavigationDisabler&gt;(&amp;m_frame);
2713 
2714     // Any subframe inserted by unload event handlers executed in the loop below will not get unloaded
2715     // because we create a copy of the subframes list before looping. Therefore, it would be unsafe to
2716     // allow loading of subframes at this point.
2717     SubframeLoadingDisabler subframeLoadingDisabler(m_frame.document());
2718 
2719     Vector&lt;Ref&lt;Frame&gt;, 16&gt; childrenToDetach;
2720     childrenToDetach.reserveInitialCapacity(m_frame.tree().childCount());
2721     for (Frame* child = m_frame.tree().lastChild(); child; child = child-&gt;tree().previousSibling())
2722         childrenToDetach.uncheckedAppend(*child);
2723     for (auto&amp; child : childrenToDetach)
2724         child-&gt;loader().detachFromParent();
2725 }
2726 
2727 void FrameLoader::closeAndRemoveChild(Frame&amp; child)
2728 {
2729     child.tree().detachFromParent();
2730 
2731     child.setView(nullptr);
2732     if (child.ownerElement() &amp;&amp; child.page())
2733         child.page()-&gt;decrementSubframeCount();
2734     child.willDetachPage();
2735     child.detachFromPage();
2736 
2737     m_frame.tree().removeChild(child);
2738 }
2739 
2740 // Called every time a resource is completely loaded or an error is received.
2741 void FrameLoader::checkLoadComplete()
2742 {
2743     m_shouldCallCheckLoadComplete = false;
2744 
2745     if (!m_frame.page())
2746         return;
2747 
2748     ASSERT(m_client.hasWebView());
2749 
2750     // FIXME: Always traversing the entire frame tree is a bit inefficient, but
2751     // is currently needed in order to null out the previous history item for all frames.
2752     Vector&lt;Ref&lt;Frame&gt;, 16&gt; frames;
2753     for (Frame* frame = &amp;m_frame.mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
2754         frames.append(*frame);
2755 
2756     // To process children before their parents, iterate the vector backwards.
2757     for (auto frame = frames.rbegin(); frame != frames.rend(); ++frame) {
2758         if ((*frame)-&gt;page())
2759             (*frame)-&gt;loader().checkLoadCompleteForThisFrame();
2760     }
2761 }
2762 
2763 int FrameLoader::numPendingOrLoadingRequests(bool recurse) const
2764 {
2765     if (!recurse)
2766         return m_frame.document()-&gt;cachedResourceLoader().requestCount();
2767 
2768     int count = 0;
2769     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame))
2770         count += frame-&gt;document()-&gt;cachedResourceLoader().requestCount();
2771     return count;
2772 }
2773 
2774 String FrameLoader::userAgent(const URL&amp; url) const
2775 {
2776     String userAgent;
2777 
2778     if (auto* documentLoader = m_frame.mainFrame().loader().activeDocumentLoader()) {
2779         if (m_frame.settings().needsSiteSpecificQuirks())
2780             userAgent = documentLoader-&gt;customUserAgentAsSiteSpecificQuirks();
2781         if (userAgent.isEmpty())
2782             userAgent = documentLoader-&gt;customUserAgent();
2783     }
2784 
2785     InspectorInstrumentation::applyUserAgentOverride(m_frame, userAgent);
2786 
2787     if (!userAgent.isEmpty())
2788         return userAgent;
2789 
2790     return m_client.userAgent(url);
2791 }
2792 
2793 String FrameLoader::navigatorPlatform() const
2794 {
2795     if (auto* documentLoader = m_frame.mainFrame().loader().activeDocumentLoader()) {
2796         auto&amp; customNavigatorPlatform = documentLoader-&gt;customNavigatorPlatform();
2797         if (!customNavigatorPlatform.isEmpty())
2798             return customNavigatorPlatform;
2799     }
2800     return String();
2801 }
2802 
2803 void FrameLoader::dispatchOnloadEvents()
2804 {
2805     m_client.dispatchDidDispatchOnloadEvents();
2806 
2807     if (documentLoader())
2808         documentLoader()-&gt;dispatchOnloadEvents();
2809 }
2810 
2811 void FrameLoader::frameDetached()
2812 {
2813     // Calling stopAllLoadersAndCheckCompleteness() can cause the frame to be deallocated, including the frame loader.
2814     Ref&lt;Frame&gt; protectedFrame(m_frame);
2815 
2816     if (m_checkTimer.isActive()) {
2817         m_checkTimer.stop();
2818         checkCompletenessNow();
2819     }
2820 
2821     if (m_frame.document()-&gt;backForwardCacheState() != Document::InBackForwardCache) {
2822         stopAllLoadersAndCheckCompleteness();
2823         m_frame.document()-&gt;stopActiveDOMObjects();
2824     }
2825 
2826     detachFromParent();
2827 }
2828 
2829 void FrameLoader::detachFromParent()
2830 {
2831     // Calling stopAllLoaders() can cause the frame to be deallocated, including the frame loader.
2832     Ref&lt;Frame&gt; protect(m_frame);
2833 
2834     closeURL();
2835     history().saveScrollPositionAndViewStateToItem(history().currentItem());
2836     detachChildren();
2837     if (m_frame.document()-&gt;backForwardCacheState() != Document::InBackForwardCache) {
2838         // stopAllLoaders() needs to be called after detachChildren() if the document is not in the back/forward cache,
2839         // because detachedChildren() will trigger the unload event handlers of any child frames, and those event
2840         // handlers might start a new subresource load in this frame.
2841         stopAllLoaders(ShouldClearProvisionalItem, StopLoadingPolicy::AlwaysStopLoading);
2842     }
2843 
2844     InspectorInstrumentation::frameDetachedFromParent(m_frame);
2845 
2846     detachViewsAndDocumentLoader();
2847 
2848     m_progressTracker = nullptr;
2849 
2850     if (Frame* parent = m_frame.tree().parent()) {
2851         parent-&gt;loader().closeAndRemoveChild(m_frame);
2852         parent-&gt;loader().scheduleCheckCompleted();
2853         parent-&gt;loader().scheduleCheckLoadComplete();
2854     } else {
2855         m_frame.setView(nullptr);
2856         m_frame.willDetachPage();
2857         m_frame.detachFromPage();
2858     }
2859 }
2860 
2861 void FrameLoader::detachViewsAndDocumentLoader()
2862 {
2863     m_client.detachedFromParent2();
2864     setDocumentLoader(nullptr);
2865     m_client.detachedFromParent3();
2866 }
2867 
2868 void FrameLoader::addExtraFieldsToSubresourceRequest(ResourceRequest&amp; request)
2869 {
2870     addExtraFieldsToRequest(request, m_loadType, false);
2871 }
2872 
2873 void FrameLoader::addExtraFieldsToMainResourceRequest(ResourceRequest&amp; request)
2874 {
2875     // FIXME: Using m_loadType seems wrong for some callers.
2876     // If we are only preparing to load the main resource, that is previous load&#39;s load type!
2877     addExtraFieldsToRequest(request, m_loadType, true);
2878 
2879     // Upgrade-Insecure-Requests should only be added to main resource requests
2880     addHTTPUpgradeInsecureRequestsIfNeeded(request);
2881 }
2882 
2883 ResourceRequestCachePolicy FrameLoader::defaultRequestCachingPolicy(const ResourceRequest&amp; request, FrameLoadType loadType, bool isMainResource)
2884 {
2885     if (m_overrideCachePolicyForTesting)
2886         return m_overrideCachePolicyForTesting.value();
2887 
2888     if (isMainResource) {
2889         if (isReload(loadType) || request.isConditional())
2890             return ResourceRequestCachePolicy::ReloadIgnoringCacheData;
2891 
2892         return ResourceRequestCachePolicy::UseProtocolCachePolicy;
2893     }
2894 
2895     if (request.isConditional())
2896         return ResourceRequestCachePolicy::ReloadIgnoringCacheData;
2897 
2898     if (documentLoader()-&gt;isLoadingInAPISense()) {
2899         // If we inherit cache policy from a main resource, we use the DocumentLoader&#39;s
2900         // original request cache policy for two reasons:
2901         // 1. For POST requests, we mutate the cache policy for the main resource,
2902         //    but we do not want this to apply to subresources
2903         // 2. Delegates that modify the cache policy using willSendRequest: should
2904         //    not affect any other resources. Such changes need to be done
2905         //    per request.
2906         ResourceRequestCachePolicy mainDocumentOriginalCachePolicy = documentLoader()-&gt;originalRequest().cachePolicy();
2907         // Back-forward navigations try to load main resource from cache only to avoid re-submitting form data, and start over (with a warning dialog) if that fails.
2908         // This policy is set on initial request too, but should not be inherited.
2909         return (mainDocumentOriginalCachePolicy == ResourceRequestCachePolicy::ReturnCacheDataDontLoad) ? ResourceRequestCachePolicy::ReturnCacheDataElseLoad : mainDocumentOriginalCachePolicy;
2910     }
2911 
2912     return ResourceRequestCachePolicy::UseProtocolCachePolicy;
2913 }
2914 
2915 void FrameLoader::addExtraFieldsToRequest(ResourceRequest&amp; request, FrameLoadType loadType, bool isMainResource)
2916 {
2917     // If the request came from a previous process due to process-swap-on-navigation then we should not modify the request.
2918     if (m_currentLoadContinuingState == LoadContinuingState::ContinuingWithRequest)
2919         return;
2920 
2921     // Don&#39;t set the cookie policy URL if it&#39;s already been set.
2922     // But make sure to set it on all requests regardless of protocol, as it has significance beyond the cookie policy (&lt;rdar://problem/6616664&gt;).
2923     bool isMainFrameMainResource = isMainResource &amp;&amp; m_frame.isMainFrame();
2924     if (request.firstPartyForCookies().isEmpty()) {
2925         if (isMainFrameMainResource)
2926             request.setFirstPartyForCookies(request.url());
2927         else if (Document* document = m_frame.document())
2928             request.setFirstPartyForCookies(document-&gt;firstPartyForCookies());
2929     }
2930 
2931     if (request.isSameSiteUnspecified()) {
2932         auto* initiator = m_frame.document();
2933         if (isMainResource) {
2934             auto* ownerFrame = m_frame.tree().parent();
2935             if (!ownerFrame &amp;&amp; m_stateMachine.isDisplayingInitialEmptyDocument())
2936                 ownerFrame = m_opener;
2937             if (ownerFrame)
2938                 initiator = ownerFrame-&gt;document();
2939             ASSERT(ownerFrame || m_frame.isMainFrame());
2940         }
2941         addSameSiteInfoToRequestIfNeeded(request, initiator);
2942     }
2943     request.setIsTopSite(isMainFrameMainResource);
2944 
2945     Page* page = frame().page();
2946     bool hasSpecificCachePolicy = request.cachePolicy() != ResourceRequestCachePolicy::UseProtocolCachePolicy;
2947 
2948     if (page &amp;&amp; page-&gt;isResourceCachingDisabledByWebInspector()) {
2949         request.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
2950         loadType = FrameLoadType::ReloadFromOrigin;
2951     } else if (!hasSpecificCachePolicy)
2952         request.setCachePolicy(defaultRequestCachingPolicy(request, loadType, isMainResource));
2953 
2954     // The remaining modifications are only necessary for HTTP and HTTPS.
2955     if (!request.url().isEmpty() &amp;&amp; !request.url().protocolIsInHTTPFamily())
2956         return;
2957 
2958     if (!hasSpecificCachePolicy &amp;&amp; request.cachePolicy() == ResourceRequestCachePolicy::ReloadIgnoringCacheData) {
2959         if (loadType == FrameLoadType::Reload)
2960             request.setHTTPHeaderField(HTTPHeaderName::CacheControl, HTTPHeaderValues::maxAge0());
2961         else if (loadType == FrameLoadType::ReloadFromOrigin) {
2962             request.setHTTPHeaderField(HTTPHeaderName::CacheControl, HTTPHeaderValues::noCache());
2963             request.setHTTPHeaderField(HTTPHeaderName::Pragma, HTTPHeaderValues::noCache());
2964         }
2965     }
2966 
2967     if (m_overrideResourceLoadPriorityForTesting)
2968         request.setPriority(m_overrideResourceLoadPriorityForTesting.value());
2969 
2970     applyUserAgentIfNeeded(request);
2971 
2972     if (isMainResource)
2973         request.setHTTPAccept(defaultAcceptHeader);
2974 
2975     // Make sure we send the Origin header.
2976     addHTTPOriginIfNeeded(request, String());
2977 
2978     // Only set fallback array if it&#39;s still empty (later attempts may be incorrect, see bug 117818).
2979     if (request.responseContentDispositionEncodingFallbackArray().isEmpty()) {
2980         // Always try UTF-8. If that fails, try frame encoding (if any) and then the default.
2981         request.setResponseContentDispositionEncodingFallbackArray(&quot;UTF-8&quot;, m_frame.document()-&gt;encoding(), m_frame.settings().defaultTextEncodingName());
2982     }
2983 }
2984 
2985 void FrameLoader::addHTTPOriginIfNeeded(ResourceRequest&amp; request, const String&amp; origin)
2986 {
2987     if (!request.httpOrigin().isEmpty())
2988         return;  // Request already has an Origin header.
2989 
2990     // Don&#39;t send an Origin header for GET or HEAD to avoid privacy issues.
2991     // For example, if an intranet page has a hyperlink to an external web
2992     // site, we don&#39;t want to include the Origin of the request because it
2993     // will leak the internal host name. Similar privacy concerns have lead
2994     // to the widespread suppression of the Referer header at the network
2995     // layer.
2996     if (request.httpMethod() == &quot;GET&quot; || request.httpMethod() == &quot;HEAD&quot;)
2997         return;
2998 
2999     // For non-GET and non-HEAD methods, always send an Origin header so the
3000     // server knows we support this feature.
3001 
3002     if (origin.isEmpty()) {
3003         // If we don&#39;t know what origin header to attach, we attach the value
3004         // for an empty origin.
3005         request.setHTTPOrigin(SecurityOrigin::createUnique()-&gt;toString());
3006         return;
3007     }
3008 
3009     request.setHTTPOrigin(origin);
3010 }
3011 
3012 // Implements the &quot;&#39;Same-site&#39; and &#39;cross-site&#39; Requests&quot; algorithm from &lt;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00#section-2.1&gt;.
3013 // The algorithm is ammended to treat URLs that inherit their security origin from their owner (e.g. about:blank)
3014 // as same-site. This matches the behavior of Chrome and Firefox.
3015 void FrameLoader::addSameSiteInfoToRequestIfNeeded(ResourceRequest&amp; request, const Document* initiator)
3016 {
3017     if (!request.isSameSiteUnspecified())
3018         return;
3019     if (!initiator) {
3020         request.setIsSameSite(true);
3021         return;
3022     }
3023     if (SecurityPolicy::shouldInheritSecurityOriginFromOwner(request.url())) {
3024         request.setIsSameSite(true);
3025         return;
3026     }
3027     request.setIsSameSite(areRegistrableDomainsEqual(initiator-&gt;siteForCookies(), request.url()));
3028 }
3029 
3030 void FrameLoader::addHTTPUpgradeInsecureRequestsIfNeeded(ResourceRequest&amp; request)
3031 {
3032     if (request.url().protocolIs(&quot;https&quot;)) {
3033         // FIXME: Identify HSTS cases and avoid adding the header. &lt;https://bugs.webkit.org/show_bug.cgi?id=157885&gt;
3034         return;
3035     }
3036 
3037     request.setHTTPHeaderField(HTTPHeaderName::UpgradeInsecureRequests, &quot;1&quot;_s);
3038 }
3039 
3040 void FrameLoader::loadPostRequest(FrameLoadRequest&amp;&amp; request, const String&amp; referrer, FrameLoadType loadType, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
3041 {
3042     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadPostRequest: frame load started&quot;);
3043 
3044     String frameName = request.frameName();
3045     LockHistory lockHistory = request.lockHistory();
3046     AllowNavigationToInvalidURL allowNavigationToInvalidURL = request.allowNavigationToInvalidURL();
3047     NewFrameOpenerPolicy openerPolicy = request.newFrameOpenerPolicy();
3048 
3049     const ResourceRequest&amp; inRequest = request.resourceRequest();
3050     const URL&amp; url = inRequest.url();
3051     const String&amp; contentType = inRequest.httpContentType();
3052     String origin = inRequest.httpOrigin();
3053 
3054     ResourceRequest workingResourceRequest(url);
3055 
3056     if (!referrer.isEmpty())
3057         workingResourceRequest.setHTTPReferrer(referrer);
3058     workingResourceRequest.setHTTPOrigin(origin);
3059     workingResourceRequest.setHTTPMethod(&quot;POST&quot;);
3060     workingResourceRequest.setHTTPBody(inRequest.httpBody());
3061     workingResourceRequest.setHTTPContentType(contentType);
3062     addExtraFieldsToRequest(workingResourceRequest, loadType, true);
3063 
3064     if (Document* document = m_frame.document())
3065         document-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(workingResourceRequest, ContentSecurityPolicy::InsecureRequestType::Load);
3066 
3067     NavigationAction action { request.requester(), workingResourceRequest, request.initiatedByMainFrame(), loadType, true, event, request.shouldOpenExternalURLsPolicy(), request.downloadAttribute() };
3068 
3069     if (!frameName.isEmpty()) {
3070         // The search for a target frame is done earlier in the case of form submission.
3071         if (auto* targetFrame = formState ? nullptr : findFrameForNavigation(frameName)) {
3072             targetFrame-&gt;loader().loadWithNavigationAction(workingResourceRequest, WTFMove(action), lockHistory, loadType, WTFMove(formState), allowNavigationToInvalidURL, { }, WTFMove(completionHandler));
3073             return;
3074         }
3075 
3076         policyChecker().checkNewWindowPolicy(WTFMove(action), WTFMove(workingResourceRequest), WTFMove(formState), frameName, [this, allowNavigationToInvalidURL, openerPolicy, completionHandler = WTFMove(completionHandler)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, const NavigationAction&amp; action, PolicyChecker::ShouldContinue shouldContinue) mutable {
3077             continueLoadAfterNewWindowPolicy(request, formState.get(), frameName, action, shouldContinue, allowNavigationToInvalidURL, openerPolicy);
3078             completionHandler();
3079         });
3080         return;
3081     }
3082 
3083     // must grab this now, since this load may stop the previous load and clear this flag
3084     bool isRedirect = m_quickRedirectComing;
3085     loadWithNavigationAction(workingResourceRequest, WTFMove(action), lockHistory, loadType, WTFMove(formState), allowNavigationToInvalidURL, { }, [this, isRedirect, protectedFrame = makeRef(m_frame), completionHandler = WTFMove(completionHandler)] () mutable {
3086         if (isRedirect) {
3087             m_quickRedirectComing = false;
3088             if (m_provisionalDocumentLoader)
3089                 m_provisionalDocumentLoader-&gt;setIsClientRedirect(true);
3090             else if (m_policyDocumentLoader)
3091                 m_policyDocumentLoader-&gt;setIsClientRedirect(true);
3092         }
3093         completionHandler();
3094     });
3095 }
3096 
3097 unsigned long FrameLoader::loadResourceSynchronously(const ResourceRequest&amp; request, ClientCredentialPolicy clientCredentialPolicy, const FetchOptions&amp; options, const HTTPHeaderMap&amp; originalRequestHeaders, ResourceError&amp; error, ResourceResponse&amp; response, RefPtr&lt;SharedBuffer&gt;&amp; data)
3098 {
3099     ASSERT(m_frame.document());
3100     String referrer = SecurityPolicy::generateReferrerHeader(m_frame.document()-&gt;referrerPolicy(), request.url(), outgoingReferrer());
3101 
3102     ResourceRequest initialRequest = request;
3103     initialRequest.setTimeoutInterval(10);
3104 
3105     if (!referrer.isEmpty())
3106         initialRequest.setHTTPReferrer(referrer);
3107     addHTTPOriginIfNeeded(initialRequest, outgoingOrigin());
3108 
3109     initialRequest.setFirstPartyForCookies(m_frame.mainFrame().loader().documentLoader()-&gt;request().url());
3110 
3111     addExtraFieldsToSubresourceRequest(initialRequest);
3112 
3113     unsigned long identifier = 0;
3114     ResourceRequest newRequest(initialRequest);
3115     requestFromDelegate(newRequest, identifier, error);
3116 
3117 #if ENABLE(CONTENT_EXTENSIONS)
3118     if (error.isNull()) {
3119         if (auto* page = m_frame.page()) {
3120             if (m_documentLoader) {
3121                 auto results = page-&gt;userContentProvider().processContentRuleListsForLoad(newRequest.url(), ContentExtensions::ResourceType::Raw, *m_documentLoader);
3122                 bool blockedLoad = results.summary.blockedLoad;
3123                 ContentExtensions::applyResultsToRequest(WTFMove(results), page, newRequest);
3124                 if (blockedLoad) {
3125                     newRequest = { };
3126                     error = ResourceError(errorDomainWebKitInternal, 0, initialRequest.url(), emptyString());
3127                     response = { };
3128                     data = nullptr;
3129                 }
3130             }
3131         }
3132     }
3133 #endif
3134 
3135     m_frame.document()-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(newRequest, ContentSecurityPolicy::InsecureRequestType::Load);
3136 
3137     if (error.isNull()) {
3138         ASSERT(!newRequest.isNull());
3139 
3140         if (!documentLoader()-&gt;applicationCacheHost().maybeLoadSynchronously(newRequest, error, response, data)) {
3141             Vector&lt;char&gt; buffer;
3142             platformStrategies()-&gt;loaderStrategy()-&gt;loadResourceSynchronously(*this, identifier, newRequest, clientCredentialPolicy, options, originalRequestHeaders, error, response, buffer);
3143             data = SharedBuffer::create(WTFMove(buffer));
3144             documentLoader()-&gt;applicationCacheHost().maybeLoadFallbackSynchronously(newRequest, error, response, data);
3145             ResourceLoadObserver::shared().logSubresourceLoading(&amp;m_frame, newRequest, response,
3146                 (isScriptLikeDestination(options.destination) ? ResourceLoadObserver::FetchDestinationIsScriptLike::Yes : ResourceLoadObserver::FetchDestinationIsScriptLike::No));
3147         }
3148     }
3149     notifier().sendRemainingDelegateMessages(m_documentLoader.get(), identifier, request, response, data ? data-&gt;data() : nullptr, data ? data-&gt;size() : 0, -1, error);
3150     return identifier;
3151 }
3152 
3153 const ResourceRequest&amp; FrameLoader::originalRequest() const
3154 {
3155     return activeDocumentLoader()-&gt;originalRequestCopy();
3156 }
3157 
3158 void FrameLoader::receivedMainResourceError(const ResourceError&amp; error)
3159 {
3160     // Retain because the stop may release the last reference to it.
3161     Ref&lt;Frame&gt; protect(m_frame);
3162 
3163     RefPtr&lt;DocumentLoader&gt; loader = activeDocumentLoader();
3164     // FIXME: Don&#39;t want to do this if an entirely new load is going, so should check
3165     // that both data sources on the frame are either this or nil.
3166     stop();
3167     if (m_client.shouldFallBack(error))
3168         handleFallbackContent();
3169 
3170     if (m_state == FrameStateProvisional &amp;&amp; m_provisionalDocumentLoader) {
3171         if (m_submittedFormURL == m_provisionalDocumentLoader-&gt;originalRequestCopy().url())
3172             m_submittedFormURL = URL();
3173 
3174         // We might have made a back/forward cache item, but now we&#39;re bailing out due to an error before we ever
3175         // transitioned to the new page (before WebFrameState == commit).  The goal here is to restore any state
3176         // so that the existing view (that wenever got far enough to replace) can continue being used.
3177         history().invalidateCurrentItemCachedPage();
3178 
3179         // Call clientRedirectCancelledOrFinished here so that the frame load delegate is notified that the redirect&#39;s
3180         // status has changed, if there was a redirect. The frame load delegate may have saved some state about
3181         // the redirect in its -webView:willPerformClientRedirectToURL:delay:fireDate:forFrame:. Since we are definitely
3182         // not going to use this provisional resource, as it was cancelled, notify the frame load delegate that the redirect
3183         // has ended.
3184         if (m_sentRedirectNotification)
3185             clientRedirectCancelledOrFinished(NewLoadInProgress::No);
3186     }
3187 
3188     checkCompleted();
3189     if (m_frame.page())
3190         checkLoadComplete();
3191 }
3192 
3193 void FrameLoader::continueFragmentScrollAfterNavigationPolicy(const ResourceRequest&amp; request, bool shouldContinue)
3194 {
3195     m_quickRedirectComing = false;
3196 
3197     if (!shouldContinue)
3198         return;
3199 
3200     // Calling stopLoading() on the provisional document loader can cause the underlying
3201     // frame to be deallocated.
3202     Ref&lt;Frame&gt; protectedFrame(m_frame);
3203 
3204     // If we have a provisional request for a different document, a fragment scroll should cancel it.
3205     if (m_provisionalDocumentLoader &amp;&amp; !equalIgnoringFragmentIdentifier(m_provisionalDocumentLoader-&gt;request().url(), request.url())) {
3206         m_provisionalDocumentLoader-&gt;stopLoading();
3207         FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueFragmentScrollAfterNavigationPolicy: Clearing provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());
3208         setProvisionalDocumentLoader(nullptr);
3209     }
3210 
3211     bool isRedirect = m_quickRedirectComing || policyChecker().loadType() == FrameLoadType::RedirectWithLockedBackForwardList;
3212     loadInSameDocument(request.url(), 0, !isRedirect);
3213 }
3214 
3215 bool FrameLoader::shouldPerformFragmentNavigation(bool isFormSubmission, const String&amp; httpMethod, FrameLoadType loadType, const URL&amp; url)
3216 {
3217     // We don&#39;t do this if we are submitting a form with method other than &quot;GET&quot;, explicitly reloading,
3218     // currently displaying a frameset, or if the URL does not have a fragment.
3219     // These rules were originally based on what KHTML was doing in KHTMLPart::openURL.
3220 
3221     // FIXME: What about load types other than Standard and Reload?
3222 
3223     return (!isFormSubmission || equalLettersIgnoringASCIICase(httpMethod, &quot;get&quot;))
3224         &amp;&amp; !isReload(loadType)
3225         &amp;&amp; loadType != FrameLoadType::Same
3226         &amp;&amp; m_frame.document()-&gt;backForwardCacheState() != Document::InBackForwardCache
3227         &amp;&amp; !shouldReload(m_frame.document()-&gt;url(), url)
3228         // We don&#39;t want to just scroll if a link from within a
3229         // frameset is trying to reload the frameset into _top.
3230         &amp;&amp; !m_frame.document()-&gt;isFrameSet();
3231 }
3232 
3233 static bool itemAllowsScrollRestoration(HistoryItem* historyItem)
3234 {
3235     return !historyItem || historyItem-&gt;shouldRestoreScrollPosition();
3236 }
3237 
3238 static bool isSameDocumentReload(bool isNewNavigation, FrameLoadType loadType)
3239 {
3240     return !isNewNavigation &amp;&amp; !isBackForwardLoadType(loadType);
3241 }
3242 
3243 void FrameLoader::scrollToFragmentWithParentBoundary(const URL&amp; url, bool isNewNavigation)
3244 {
3245     auto view = makeRefPtr(m_frame.view());
3246     auto document = makeRefPtr(m_frame.document());
3247     if (!view || !document)
3248         return;
3249 
3250     if (isSameDocumentReload(isNewNavigation, m_loadType) || itemAllowsScrollRestoration(history().currentItem())) {
3251         // https://html.spec.whatwg.org/multipage/browsing-the-web.html#try-to-scroll-to-the-fragment
3252         if (!document-&gt;haveStylesheetsLoaded())
3253             document-&gt;setGotoAnchorNeededAfterStylesheetsLoad(true);
3254         else
3255             view-&gt;scrollToFragment(url);
3256     }
3257 
3258 }
3259 
3260 bool FrameLoader::shouldClose()
3261 {
3262     Page* page = m_frame.page();
3263     if (!page)
3264         return true;
3265     if (!page-&gt;chrome().canRunBeforeUnloadConfirmPanel())
3266         return true;
3267 
3268     // Store all references to each subframe in advance since beforeunload&#39;s event handler may modify frame
3269     Vector&lt;Ref&lt;Frame&gt;, 16&gt; targetFrames;
3270     targetFrames.append(m_frame);
3271     for (Frame* child = m_frame.tree().firstChild(); child; child = child-&gt;tree().traverseNext(&amp;m_frame))
3272         targetFrames.append(*child);
3273 
3274     bool shouldClose = false;
3275     {
3276         NavigationDisabler navigationDisabler(&amp;m_frame);
3277         IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(m_frame.document());
3278         size_t i;
3279 
3280         for (i = 0; i &lt; targetFrames.size(); i++) {
3281             if (!targetFrames[i]-&gt;tree().isDescendantOf(&amp;m_frame))
3282                 continue;
3283             if (!targetFrames[i]-&gt;loader().dispatchBeforeUnloadEvent(page-&gt;chrome(), this))
3284                 break;
3285         }
3286 
3287         if (i == targetFrames.size())
3288             shouldClose = true;
3289     }
3290 
3291     if (!shouldClose)
3292         m_submittedFormURL = URL();
3293 
3294     m_currentNavigationHasShownBeforeUnloadConfirmPanel = false;
3295     return shouldClose;
3296 }
3297 
3298 void FrameLoader::dispatchUnloadEvents(UnloadEventPolicy unloadEventPolicy)
3299 {
3300     if (!m_frame.document())
3301         return;
3302 
3303     if (m_pageDismissalEventBeingDispatched != PageDismissalType::None)
3304         return;
3305 
3306     // We store the frame&#39;s page in a local variable because the frame might get detached inside dispatchEvent.
3307     ForbidPromptsScope forbidPrompts(m_frame.page());
3308     ForbidSynchronousLoadsScope forbidSynchronousLoads(m_frame.page());
3309     IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(m_frame.document());
3310 
3311     if (m_didCallImplicitClose &amp;&amp; !m_wasUnloadEventEmitted) {
3312         auto* currentFocusedElement = m_frame.document()-&gt;focusedElement();
3313         if (is&lt;HTMLInputElement&gt;(currentFocusedElement))
3314             downcast&lt;HTMLInputElement&gt;(*currentFocusedElement).endEditing();
3315         if (m_pageDismissalEventBeingDispatched == PageDismissalType::None) {
3316             if (unloadEventPolicy == UnloadEventPolicyUnloadAndPageHide) {
3317                 m_pageDismissalEventBeingDispatched = PageDismissalType::PageHide;
3318                 m_frame.document()-&gt;domWindow()-&gt;dispatchEvent(PageTransitionEvent::create(eventNames().pagehideEvent, m_frame.document()-&gt;backForwardCacheState() == Document::AboutToEnterBackForwardCache), m_frame.document());
3319             }
3320 
3321             // FIXME: update Page Visibility state here.
3322             // https://bugs.webkit.org/show_bug.cgi?id=116770
3323 
3324             if (m_frame.document()-&gt;backForwardCacheState() == Document::NotInBackForwardCache) {
3325                 Ref&lt;Event&gt; unloadEvent(Event::create(eventNames().unloadEvent, Event::CanBubble::No, Event::IsCancelable::No));
3326                 // The DocumentLoader (and thus its LoadTiming) might get destroyed
3327                 // while dispatching the event, so protect it to prevent writing the end
3328                 // time into freed memory.
3329                 RefPtr&lt;DocumentLoader&gt; documentLoader = m_provisionalDocumentLoader;
3330                 m_pageDismissalEventBeingDispatched = PageDismissalType::Unload;
3331                 if (documentLoader &amp;&amp; documentLoader-&gt;timing().startTime() &amp;&amp; !documentLoader-&gt;timing().unloadEventStart() &amp;&amp; !documentLoader-&gt;timing().unloadEventEnd()) {
3332                     auto&amp; timing = documentLoader-&gt;timing();
3333                     timing.markUnloadEventStart();
3334                     m_frame.document()-&gt;domWindow()-&gt;dispatchEvent(unloadEvent, m_frame.document());
3335                     timing.markUnloadEventEnd();
3336                 } else
3337                     m_frame.document()-&gt;domWindow()-&gt;dispatchEvent(unloadEvent, m_frame.document());
3338             }
3339         }
3340         m_pageDismissalEventBeingDispatched = PageDismissalType::None;
3341         m_wasUnloadEventEmitted = true;
3342     }
3343 
3344     // Dispatching the unload event could have made m_frame.document() null.
3345     if (!m_frame.document())
3346         return;
3347 
3348     if (m_frame.document()-&gt;backForwardCacheState() != Document::NotInBackForwardCache)
3349         return;
3350 
3351     // Don&#39;t remove event listeners from a transitional empty document (see bug 28716 for more information).
3352     bool keepEventListeners = m_stateMachine.isDisplayingInitialEmptyDocument() &amp;&amp; m_provisionalDocumentLoader
3353         &amp;&amp; m_frame.document()-&gt;isSecureTransitionTo(m_provisionalDocumentLoader-&gt;url());
3354 
3355     if (!keepEventListeners)
3356         m_frame.document()-&gt;removeAllEventListeners();
3357 }
3358 
3359 static bool shouldAskForNavigationConfirmation(Document&amp; document, const BeforeUnloadEvent&amp; event)
3360 {
3361     // Confirmation dialog should not be displayed when the allow-modals flag is not set.
3362     if (document.isSandboxed(SandboxModals))
3363         return false;
3364 
3365     bool userDidInteractWithPage = document.topDocument().userDidInteractWithPage();
3366     // Web pages can request we ask for confirmation before navigating by:
3367     // - Cancelling the BeforeUnloadEvent (modern way)
3368     // - Setting the returnValue attribute on the BeforeUnloadEvent to a non-empty string.
3369     // - Returning a non-empty string from the event handler, which is then set as returnValue
3370     //   attribute on the BeforeUnloadEvent.
3371     return userDidInteractWithPage &amp;&amp; (event.defaultPrevented() || !event.returnValue().isEmpty());
3372 }
3373 
3374 bool FrameLoader::dispatchBeforeUnloadEvent(Chrome&amp; chrome, FrameLoader* frameLoaderBeingNavigated)
3375 {
3376     DOMWindow* domWindow = m_frame.document()-&gt;domWindow();
3377     if (!domWindow)
3378         return true;
3379 
3380     RefPtr&lt;Document&gt; document = m_frame.document();
3381     if (!document-&gt;bodyOrFrameset())
3382         return true;
3383 
3384     Ref&lt;BeforeUnloadEvent&gt; beforeUnloadEvent = BeforeUnloadEvent::create();
3385 
3386     {
3387         SetForScope&lt;PageDismissalType&gt; change(m_pageDismissalEventBeingDispatched, PageDismissalType::BeforeUnload);
3388         ForbidPromptsScope forbidPrompts(m_frame.page());
3389         ForbidSynchronousLoadsScope forbidSynchronousLoads(m_frame.page());
3390         domWindow-&gt;dispatchEvent(beforeUnloadEvent, domWindow-&gt;document());
3391     }
3392 
3393     if (!beforeUnloadEvent-&gt;defaultPrevented())
3394         document-&gt;defaultEventHandler(beforeUnloadEvent.get());
3395 
3396     if (!shouldAskForNavigationConfirmation(*document, beforeUnloadEvent))
3397         return true;
3398 
3399     // If the navigating FrameLoader has already shown a beforeunload confirmation panel for the current navigation attempt,
3400     // this frame is not allowed to cause another one to be shown.
3401     if (frameLoaderBeingNavigated-&gt;m_currentNavigationHasShownBeforeUnloadConfirmPanel) {
3402         document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Blocked attempt to show multiple beforeunload confirmation dialogs for the same navigation.&quot;_s);
3403         return true;
3404     }
3405 
3406     // We should only display the beforeunload dialog for an iframe if its SecurityOrigin matches all
3407     // ancestor frame SecurityOrigins up through the navigating FrameLoader.
3408     if (frameLoaderBeingNavigated != this) {
3409         Frame* parentFrame = m_frame.tree().parent();
3410         while (parentFrame) {
3411             Document* parentDocument = parentFrame-&gt;document();
3412             if (!parentDocument)
3413                 return true;
3414             if (!m_frame.document() || !m_frame.document()-&gt;securityOrigin().canAccess(parentDocument-&gt;securityOrigin())) {
3415                 document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Blocked attempt to show beforeunload confirmation dialog on behalf of a frame with different security origin. Protocols, domains, and ports must match.&quot;_s);
3416                 return true;
3417             }
3418 
3419             if (&amp;parentFrame-&gt;loader() == frameLoaderBeingNavigated)
3420                 break;
3421 
3422             parentFrame = parentFrame-&gt;tree().parent();
3423         }
3424 
3425         // The navigatingFrameLoader should always be in our ancestory.
3426         ASSERT(parentFrame);
3427         ASSERT(&amp;parentFrame-&gt;loader() == frameLoaderBeingNavigated);
3428     }
3429 
3430     frameLoaderBeingNavigated-&gt;m_currentNavigationHasShownBeforeUnloadConfirmPanel = true;
3431 
3432     String text = document-&gt;displayStringModifiedByEncoding(beforeUnloadEvent-&gt;returnValue());
3433     return chrome.runBeforeUnloadConfirmPanel(text, m_frame);
3434 }
3435 
3436 void FrameLoader::continueLoadAfterNavigationPolicy(const ResourceRequest&amp; request, FormState* formState, NavigationPolicyDecision navigationPolicyDecision, AllowNavigationToInvalidURL allowNavigationToInvalidURL)
3437 {
3438     // If we loaded an alternate page to replace an unreachableURL, we&#39;ll get in here with a
3439     // nil policyDataSource because loading the alternate page will have passed
3440     // through this method already, nested; otherwise, policyDataSource should still be set.
3441     ASSERT(m_policyDocumentLoader || !m_provisionalDocumentLoader-&gt;unreachableURL().isEmpty());
3442 
3443     bool isTargetItem = history().provisionalItem() ? history().provisionalItem()-&gt;isTargetItem() : false;
3444 
3445     bool urlIsDisallowed = allowNavigationToInvalidURL == AllowNavigationToInvalidURL::No &amp;&amp; !request.url().isValid();
3446     bool canContinue = navigationPolicyDecision == NavigationPolicyDecision::ContinueLoad &amp;&amp; shouldClose() &amp;&amp; !urlIsDisallowed;
3447 
3448     if (!canContinue) {
3449         FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame due to the following reasons (&quot;
3450             &quot;allowNavigationToInvalidURL = %d, &quot;
3451             &quot;requestURLIsValid = %d, &quot;
3452             &quot;navigationPolicyDecision = %d)&quot;,
3453             static_cast&lt;int&gt;(allowNavigationToInvalidURL),
3454             request.url().isValid(),
3455             static_cast&lt;int&gt;(navigationPolicyDecision));
3456 
3457         // If we were waiting for a quick redirect, but the policy delegate decided to ignore it, then we
3458         // need to report that the client redirect was cancelled.
3459         // FIXME: The client should be told about ignored non-quick redirects, too.
3460         if (m_quickRedirectComing)
3461             clientRedirectCancelledOrFinished(NewLoadInProgress::No);
3462 
3463         if (navigationPolicyDecision == NavigationPolicyDecision::StopAllLoads) {
3464             stopAllLoaders();
3465             m_checkTimer.stop();
3466         }
3467 
3468         setPolicyDocumentLoader(nullptr);
3469         checkCompleted();
3470 
3471         if (navigationPolicyDecision != NavigationPolicyDecision::StopAllLoads)
3472             checkLoadComplete();
3473 
3474         // If the navigation request came from the back/forward menu, and we punt on it, we have the
3475         // problem that we have optimistically moved the b/f cursor already, so move it back. For sanity,
3476         // we only do this when punting a navigation for the target frame or top-level frame.
3477         if ((isTargetItem || m_frame.isMainFrame()) &amp;&amp; isBackForwardLoadType(policyChecker().loadType())) {
3478             if (Page* page = m_frame.page()) {
3479                 if (HistoryItem* resetItem = m_frame.mainFrame().loader().history().currentItem())
3480                     page-&gt;backForward().setCurrentItem(*resetItem);
3481             }
3482         }
3483         return;
3484     }
3485 
3486     FrameLoadType type = policyChecker().loadType();
3487     // A new navigation is in progress, so don&#39;t clear the history&#39;s provisional item.
3488     stopAllLoaders(ShouldNotClearProvisionalItem);
3489 
3490     // &lt;rdar://problem/6250856&gt; - In certain circumstances on pages with multiple frames, stopAllLoaders()
3491     // might detach the current FrameLoader, in which case we should bail on this newly defunct load.
3492     if (!m_frame.page()) {
3493         FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame because it became defunct&quot;);
3494         return;
3495     }
3496 
3497     setProvisionalDocumentLoader(m_policyDocumentLoader.get());
3498     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy: Setting provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());
3499     m_loadType = type;
3500     setState(FrameStateProvisional);
3501 
3502     setPolicyDocumentLoader(nullptr);
3503 
3504     if (isBackForwardLoadType(type)) {
3505         auto&amp; diagnosticLoggingClient = m_frame.page()-&gt;diagnosticLoggingClient();
3506         if (history().provisionalItem() &amp;&amp; history().provisionalItem()-&gt;isInBackForwardCache()) {
3507             diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::backForwardCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultPass, ShouldSample::Yes);
3508             loadProvisionalItemFromCachedPage();
3509             FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame because it will be loaded from cache&quot;);
3510             return;
3511         }
3512         diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::backForwardCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultFail, ShouldSample::Yes);
3513     }
3514 
3515     CompletionHandler&lt;void()&gt; completionHandler = [this, protectedFrame = makeRef(m_frame)] () mutable {
3516         if (!m_provisionalDocumentLoader) {
3517             FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy (completionHandler): Frame load canceled - no provisional document loader before prepareForLoadStart&quot;);
3518             return;
3519         }
3520 
3521         prepareForLoadStart();
3522 
3523         // The load might be cancelled inside of prepareForLoadStart(), nulling out the m_provisionalDocumentLoader,
3524         // so we need to null check it again.
3525         if (!m_provisionalDocumentLoader) {
3526             FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy (completionHandler): Frame load canceled - no provisional document loader after prepareForLoadStart&quot;);
3527             return;
3528         }
3529 
3530         DocumentLoader* activeDocLoader = activeDocumentLoader();
3531         if (activeDocLoader &amp;&amp; activeDocLoader-&gt;isLoadingMainResource()) {
3532             FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy (completionHandler): Main frame already being loaded&quot;);
3533             return;
3534         }
3535 
3536         m_loadingFromCachedPage = false;
3537 
3538         m_provisionalDocumentLoader-&gt;startLoadingMainResource();
3539     };
3540 
3541     if (!formState) {
3542         completionHandler();
3543         return;
3544     }
3545 
3546     m_client.dispatchWillSubmitForm(*formState, WTFMove(completionHandler));
3547 }
3548 
3549 void FrameLoader::continueLoadAfterNewWindowPolicy(const ResourceRequest&amp; request,
3550     FormState* formState, const String&amp; frameName, const NavigationAction&amp; action, PolicyChecker::ShouldContinue shouldContinue, AllowNavigationToInvalidURL allowNavigationToInvalidURL, NewFrameOpenerPolicy openerPolicy)
3551 {
3552     if (shouldContinue != PolicyChecker::ShouldContinue::Yes)
3553         return;
3554 
3555     Ref&lt;Frame&gt; frame(m_frame);
3556     RefPtr&lt;Frame&gt; mainFrame = m_client.dispatchCreatePage(action);
3557     if (!mainFrame)
3558         return;
3559 
3560     SandboxFlags sandboxFlags = frame-&gt;loader().effectiveSandboxFlags();
3561     if (sandboxFlags &amp; SandboxPropagatesToAuxiliaryBrowsingContexts)
3562         mainFrame-&gt;loader().forceSandboxFlags(sandboxFlags);
3563 
3564     if (!equalIgnoringASCIICase(frameName, &quot;_blank&quot;))
3565         mainFrame-&gt;tree().setName(frameName);
3566 
3567     mainFrame-&gt;page()-&gt;setOpenedByDOM();
3568     mainFrame-&gt;loader().m_client.dispatchShow();
3569     if (openerPolicy == NewFrameOpenerPolicy::Allow) {
3570         mainFrame-&gt;loader().setOpener(frame.ptr());
3571         mainFrame-&gt;document()-&gt;setReferrerPolicy(frame-&gt;document()-&gt;referrerPolicy());
3572     }
3573 
3574     NavigationAction newAction { *frame-&gt;document(), request, InitiatedByMainFrame::Unknown, NavigationType::Other, action.shouldOpenExternalURLsPolicy(), nullptr, action.downloadAttribute() };
3575     mainFrame-&gt;loader().loadWithNavigationAction(request, WTFMove(newAction), LockHistory::No, FrameLoadType::Standard, formState, allowNavigationToInvalidURL);
3576 }
3577 
3578 void FrameLoader::requestFromDelegate(ResourceRequest&amp; request, unsigned long&amp; identifier, ResourceError&amp; error)
3579 {
3580     ASSERT(!request.isNull());
3581 
3582     identifier = 0;
3583     if (Page* page = m_frame.page()) {
3584         identifier = page-&gt;progress().createUniqueIdentifier();
3585         notifier().assignIdentifierToInitialRequest(identifier, m_documentLoader.get(), request);
3586     }
3587 
3588     ResourceRequest newRequest(request);
3589     notifier().dispatchWillSendRequest(m_documentLoader.get(), identifier, newRequest, ResourceResponse());
3590 
3591     if (newRequest.isNull())
3592         error = cancelledError(request);
3593     else
3594         error = ResourceError();
3595 
3596     request = newRequest;
3597 }
3598 
3599 void FrameLoader::loadedResourceFromMemoryCache(CachedResource&amp; resource, ResourceRequest&amp; newRequest, ResourceError&amp; error)
3600 {
3601     Page* page = m_frame.page();
3602     if (!page)
3603         return;
3604 
3605     if (!resource.shouldSendResourceLoadCallbacks() || m_documentLoader-&gt;haveToldClientAboutLoad(resource.url()))
3606         return;
3607 
3608     // Main resource delegate messages are synthesized in MainResourceLoader, so we must not send them here.
3609     if (resource.type() == CachedResource::Type::MainResource)
3610         return;
3611 
3612     if (!page-&gt;areMemoryCacheClientCallsEnabled()) {
3613         InspectorInstrumentation::didLoadResourceFromMemoryCache(*page, m_documentLoader.get(), &amp;resource);
3614         m_documentLoader-&gt;recordMemoryCacheLoadForFutureClientNotification(resource.resourceRequest());
3615         m_documentLoader-&gt;didTellClientAboutLoad(resource.url());
3616         return;
3617     }
3618 
3619     if (m_client.dispatchDidLoadResourceFromMemoryCache(m_documentLoader.get(), newRequest, resource.response(), resource.encodedSize())) {
3620         InspectorInstrumentation::didLoadResourceFromMemoryCache(*page, m_documentLoader.get(), &amp;resource);
3621         m_documentLoader-&gt;didTellClientAboutLoad(resource.url());
3622         return;
3623     }
3624 
3625     unsigned long identifier;
3626     requestFromDelegate(newRequest, identifier, error);
3627 
3628     ResourceResponse response = resource.response();
3629     response.setSource(ResourceResponse::Source::MemoryCache);
3630     notifier().sendRemainingDelegateMessages(m_documentLoader.get(), identifier, newRequest, response, 0, resource.encodedSize(), 0, error);
3631 }
3632 
3633 void FrameLoader::applyUserAgentIfNeeded(ResourceRequest&amp; request)
3634 {
3635     if (!request.hasHTTPHeaderField(HTTPHeaderName::UserAgent)) {
3636         String userAgent = this-&gt;userAgent(request.url());
3637         ASSERT(!userAgent.isNull());
3638         request.setHTTPUserAgent(userAgent);
3639     }
3640 }
3641 
3642 bool FrameLoader::shouldInterruptLoadForXFrameOptions(const String&amp; content, const URL&amp; url, unsigned long requestIdentifier)
3643 {
3644     Frame&amp; topFrame = m_frame.tree().top();
3645     if (&amp;m_frame == &amp;topFrame)
3646         return false;
3647 
3648     XFrameOptionsDisposition disposition = parseXFrameOptionsHeader(content);
3649 
3650     switch (disposition) {
3651     case XFrameOptionsSameOrigin: {
3652         auto origin = SecurityOrigin::create(url);
3653         if (!origin-&gt;isSameSchemeHostPort(topFrame.document()-&gt;securityOrigin()))
3654             return true;
3655         for (Frame* frame = m_frame.tree().parent(); frame; frame = frame-&gt;tree().parent()) {
3656             if (!origin-&gt;isSameSchemeHostPort(frame-&gt;document()-&gt;securityOrigin()))
3657                 return true;
3658         }
3659         return false;
3660     }
3661     case XFrameOptionsDeny:
3662         return true;
3663     case XFrameOptionsAllowAll:
3664         return false;
3665     case XFrameOptionsConflict:
3666         m_frame.document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Multiple &#39;X-Frame-Options&#39; headers with conflicting values (&#39;&quot; + content + &quot;&#39;) encountered when loading &#39;&quot; + url.stringCenterEllipsizedToLength() + &quot;&#39;. Falling back to &#39;DENY&#39;.&quot;, requestIdentifier);
3667         return true;
3668     case XFrameOptionsInvalid:
3669         m_frame.document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Invalid &#39;X-Frame-Options&#39; header encountered when loading &#39;&quot; + url.stringCenterEllipsizedToLength() + &quot;&#39;: &#39;&quot; + content + &quot;&#39; is not a recognized directive. The header will be ignored.&quot;, requestIdentifier);
3670         return false;
3671     case XFrameOptionsNone:
3672         return false;
3673     }
3674     ASSERT_NOT_REACHED();
3675     return false;
3676 }
3677 
3678 void FrameLoader::loadProvisionalItemFromCachedPage()
3679 {
3680     DocumentLoader* provisionalLoader = provisionalDocumentLoader();
3681     LOG(BackForwardCache, &quot;FrameLoader::loadProvisionalItemFromCachedPage Loading provisional DocumentLoader %p with URL &#39;%s&#39; from CachedPage&quot;, provisionalDocumentLoader(), provisionalDocumentLoader()-&gt;url().stringCenterEllipsizedToLength().utf8().data());
3682 
3683     prepareForLoadStart();
3684 
3685     m_loadingFromCachedPage = true;
3686 
3687     // Should have timing data from previous time(s) the page was shown.
3688     ASSERT(provisionalLoader-&gt;timing().startTime());
3689     provisionalLoader-&gt;resetTiming();
3690     provisionalLoader-&gt;timing().markStartTime();
3691 
3692     provisionalLoader-&gt;setCommitted(true);
3693     commitProvisionalLoad();
3694 }
3695 
3696 bool FrameLoader::shouldTreatURLAsSameAsCurrent(const URL&amp; url) const
3697 {
3698     if (!history().currentItem())
3699         return false;
3700     return url == history().currentItem()-&gt;url() || url == history().currentItem()-&gt;originalURL();
3701 }
3702 
3703 bool FrameLoader::shouldTreatURLAsSrcdocDocument(const URL&amp; url) const
3704 {
3705     if (!equalLettersIgnoringASCIICase(url.string(), &quot;about:srcdoc&quot;))
3706         return false;
3707     HTMLFrameOwnerElement* ownerElement = m_frame.ownerElement();
3708     if (!ownerElement)
3709         return false;
3710     if (!ownerElement-&gt;hasTagName(iframeTag))
3711         return false;
3712     return ownerElement-&gt;hasAttributeWithoutSynchronization(srcdocAttr);
3713 }
3714 
3715 Frame* FrameLoader::findFrameForNavigation(const AtomString&amp; name, Document* activeDocument)
3716 {
3717     // FIXME: Eventually all callers should supply the actual activeDocument so we can call canNavigate with the right document.
3718     if (!activeDocument)
3719         activeDocument = m_frame.document();
3720 
3721     auto* frame = m_frame.tree().find(name, activeDocument-&gt;frame() ? *activeDocument-&gt;frame() : m_frame);
3722 
3723     if (!activeDocument-&gt;canNavigate(frame))
3724         return nullptr;
3725 
3726     return frame;
3727 }
3728 
3729 void FrameLoader::loadSameDocumentItem(HistoryItem&amp; item)
3730 {
3731     ASSERT(item.documentSequenceNumber() == history().currentItem()-&gt;documentSequenceNumber());
3732 
3733     Ref&lt;Frame&gt; protect(m_frame);
3734 
3735     // Save user view state to the current history item here since we don&#39;t do a normal load.
3736     // FIXME: Does form state need to be saved here too?
3737     history().saveScrollPositionAndViewStateToItem(history().currentItem());
3738     if (FrameView* view = m_frame.view())
3739         view-&gt;setWasScrolledByUser(false);
3740 
3741     history().setCurrentItem(item);
3742 
3743     // loadInSameDocument() actually changes the URL and notifies load delegates of a &quot;fake&quot; load
3744     loadInSameDocument(item.url(), item.stateObject(), false);
3745 
3746     // Restore user view state from the current history item here since we don&#39;t do a normal load.
3747     history().restoreScrollPositionAndViewState();
3748 }
3749 
3750 // FIXME: This function should really be split into a couple pieces, some of
3751 // which should be methods of HistoryController and some of which should be
3752 // methods of FrameLoader.
3753 void FrameLoader::loadDifferentDocumentItem(HistoryItem&amp; item, HistoryItem* fromItem, FrameLoadType loadType, FormSubmissionCacheLoadPolicy cacheLoadPolicy, ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad)
3754 {
3755     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadDifferentDocumentItem: frame load started&quot;);
3756 
3757     Ref&lt;Frame&gt; protectedFrame(m_frame);
3758 
3759     // History items should not be reported to the parent.
3760     m_shouldReportResourceTimingToParentFrame = false;
3761 
3762     // Remember this item so we can traverse any child items as child frames load
3763     history().setProvisionalItem(&amp;item);
3764 
3765     auto initiatedByMainFrame = InitiatedByMainFrame::Unknown;
3766 
3767     SetForScope&lt;LoadContinuingState&gt; continuingLoadGuard(m_currentLoadContinuingState, shouldTreatAsContinuingLoad == ShouldTreatAsContinuingLoad::Yes ? LoadContinuingState::ContinuingWithHistoryItem : LoadContinuingState::NotContinuing);
3768 
3769     if (CachedPage* cachedPage = BackForwardCache::singleton().get(item, m_frame.page())) {
3770         auto documentLoader = cachedPage-&gt;documentLoader();
3771         m_client.updateCachedDocumentLoader(*documentLoader);
3772 
3773         auto action = NavigationAction { *m_frame.document(), documentLoader-&gt;request(), initiatedByMainFrame, loadType, false };
3774         action.setTargetBackForwardItem(item);
3775         action.setSourceBackForwardItem(fromItem);
3776         documentLoader-&gt;setTriggeringAction(WTFMove(action));
3777 
3778         documentLoader-&gt;setLastCheckedRequest(ResourceRequest());
3779         loadWithDocumentLoader(documentLoader, loadType, { }, AllowNavigationToInvalidURL::Yes, shouldTreatAsContinuingLoad);
3780         return;
3781     }
3782 
3783     URL itemURL = item.url();
3784     URL itemOriginalURL = item.originalURL();
3785     URL currentURL;
3786     if (documentLoader())
3787         currentURL = documentLoader()-&gt;url();
3788     RefPtr&lt;FormData&gt; formData = item.formData();
3789 
3790     ResourceRequest request(itemURL);
3791 
3792     if (!item.referrer().isNull())
3793         request.setHTTPReferrer(item.referrer());
3794 
3795     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy = shouldOpenExternalURLsPolicyToApply(m_frame, initiatedByMainFrame, item.shouldOpenExternalURLsPolicy());
3796     bool isFormSubmission = false;
3797     Event* event = nullptr;
3798 
3799     // If this was a repost that failed the page cache, we might try to repost the form.
3800     NavigationAction action;
3801     if (formData) {
3802         request.setHTTPMethod(&quot;POST&quot;);
3803         request.setHTTPBody(WTFMove(formData));
3804         request.setHTTPContentType(item.formContentType());
3805         auto securityOrigin = SecurityOrigin::createFromString(item.referrer());
3806         addHTTPOriginIfNeeded(request, securityOrigin-&gt;toString());
3807         addHTTPUpgradeInsecureRequestsIfNeeded(request);
3808 
3809         // Make sure to add extra fields to the request after the Origin header is added for the FormData case.
3810         // See https://bugs.webkit.org/show_bug.cgi?id=22194 for more discussion.
3811         addExtraFieldsToRequest(request, loadType, true);
3812 
3813         // FIXME: Slight hack to test if the NSURL cache contains the page we&#39;re going to.
3814         // We want to know this before talking to the policy delegate, since it affects whether
3815         // we show the DoYouReallyWantToRepost nag.
3816         //
3817         // This trick has a small bug (3123893) where we might find a cache hit, but then
3818         // have the item vanish when we try to use it in the ensuing nav.  This should be
3819         // extremely rare, but in that case the user will get an error on the navigation.
3820 
3821         if (cacheLoadPolicy == MayAttemptCacheOnlyLoadForFormSubmissionItem) {
3822             request.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataDontLoad);
3823             action = { *m_frame.document(), request, initiatedByMainFrame, loadType, isFormSubmission, event, shouldOpenExternalURLsPolicy };
3824         } else {
3825             request.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataElseLoad);
3826             action = { *m_frame.document(), request, initiatedByMainFrame, NavigationType::FormResubmitted, shouldOpenExternalURLsPolicy, event };
3827         }
3828     } else {
3829         switch (loadType) {
3830         case FrameLoadType::Reload:
3831         case FrameLoadType::ReloadFromOrigin:
3832         case FrameLoadType::ReloadExpiredOnly:
3833             request.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
3834             break;
3835         case FrameLoadType::Back:
3836         case FrameLoadType::Forward:
3837         case FrameLoadType::IndexedBackForward: {
3838 #if PLATFORM(COCOA)
3839             bool allowStaleData = true;
3840 #else
3841             bool allowStaleData = !item.wasRestoredFromSession();
3842 #endif
3843             if (allowStaleData)
3844                 request.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataElseLoad);
3845             item.setWasRestoredFromSession(false);
3846             break;
3847         }
3848         case FrameLoadType::Standard:
3849         case FrameLoadType::RedirectWithLockedBackForwardList:
3850             break;
3851         case FrameLoadType::Same:
3852         case FrameLoadType::Replace:
3853             ASSERT_NOT_REACHED();
3854         }
3855 
3856         addExtraFieldsToRequest(request, loadType, true);
3857 
3858         ResourceRequest requestForOriginalURL(request);
3859         requestForOriginalURL.setURL(itemOriginalURL);
3860         action = { *m_frame.document(), requestForOriginalURL, initiatedByMainFrame, loadType, isFormSubmission, event, shouldOpenExternalURLsPolicy };
3861     }
3862 
3863     action.setTargetBackForwardItem(item);
3864     action.setSourceBackForwardItem(fromItem);
3865 
3866     loadWithNavigationAction(request, WTFMove(action), LockHistory::No, loadType, { }, AllowNavigationToInvalidURL::Yes);
3867 }
3868 
3869 // Loads content into this frame, as specified by history item
3870 void FrameLoader::loadItem(HistoryItem&amp; item, HistoryItem* fromItem, FrameLoadType loadType, ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad)
3871 {
3872     m_requestedHistoryItem = &amp;item;
3873     HistoryItem* currentItem = history().currentItem();
3874     bool sameDocumentNavigation = currentItem &amp;&amp; item.shouldDoSameDocumentNavigationTo(*currentItem);
3875 
3876     if (sameDocumentNavigation)
3877         loadSameDocumentItem(item);
3878     else
3879         loadDifferentDocumentItem(item, fromItem, loadType, MayAttemptCacheOnlyLoadForFormSubmissionItem, shouldTreatAsContinuingLoad);
3880 }
3881 
3882 void FrameLoader::retryAfterFailedCacheOnlyMainResourceLoad()
3883 {
3884     ASSERT(m_state == FrameStateProvisional);
3885     ASSERT(!m_loadingFromCachedPage);
3886     ASSERT(history().provisionalItem());
3887     ASSERT(history().provisionalItem()-&gt;formData());
3888     ASSERT(history().provisionalItem() == m_requestedHistoryItem.get());
3889 
3890     FrameLoadType loadType = m_loadType;
3891     HistoryItem* item = history().provisionalItem();
3892 
3893     stopAllLoaders(ShouldNotClearProvisionalItem);
3894     if (item)
3895         loadDifferentDocumentItem(*item, history().currentItem(), loadType, MayNotAttemptCacheOnlyLoadForFormSubmissionItem, ShouldTreatAsContinuingLoad::No);
3896     else {
3897         ASSERT_NOT_REACHED();
3898         FRAMELOADER_RELEASE_LOG_ERROR(ResourceLoading, &quot;retryAfterFailedCacheOnlyMainResourceLoad: Retrying load after failed cache-only main resource load failed because there is no provisional history item.&quot;);
3899     }
3900 }
3901 
3902 ResourceError FrameLoader::cancelledError(const ResourceRequest&amp; request) const
3903 {
3904     ResourceError error = m_client.cancelledError(request);
3905     error.setType(ResourceError::Type::Cancellation);
3906     return error;
3907 }
3908 
3909 ResourceError FrameLoader::blockedByContentBlockerError(const ResourceRequest&amp; request) const
3910 {
3911     return m_client.blockedByContentBlockerError(request);
3912 }
3913 
3914 ResourceError FrameLoader::blockedError(const ResourceRequest&amp; request) const
3915 {
3916     ResourceError error = m_client.blockedError(request);
3917     error.setType(ResourceError::Type::Cancellation);
3918     return error;
3919 }
3920 
3921 #if ENABLE(CONTENT_FILTERING)
3922 ResourceError FrameLoader::blockedByContentFilterError(const ResourceRequest&amp; request) const
3923 {
3924     ResourceError error = m_client.blockedByContentFilterError(request);
3925     error.setType(ResourceError::Type::General);
3926     return error;
3927 }
3928 #endif
3929 
3930 #if PLATFORM(IOS_FAMILY)
3931 RetainPtr&lt;CFDictionaryRef&gt; FrameLoader::connectionProperties(ResourceLoader* loader)
3932 {
3933     return m_client.connectionProperties(loader-&gt;documentLoader(), loader-&gt;identifier());
3934 }
3935 #endif
3936 
3937 ReferrerPolicy FrameLoader::effectiveReferrerPolicy() const
3938 {
3939     if (auto* parentFrame = m_frame.tree().parent())
3940         return parentFrame-&gt;document()-&gt;referrerPolicy();
3941     if (m_opener)
3942         return m_opener-&gt;document()-&gt;referrerPolicy();
3943     return ReferrerPolicy::NoReferrerWhenDowngrade;
3944 }
3945 
3946 String FrameLoader::referrer() const
3947 {
3948     return m_documentLoader ? m_documentLoader-&gt;request().httpReferrer() : emptyString();
3949 }
3950 
3951 void FrameLoader::dispatchDidClearWindowObjectsInAllWorlds()
3952 {
3953     if (!m_frame.script().canExecuteScripts(NotAboutToExecuteScript))
3954         return;
3955 
3956     Vector&lt;Ref&lt;DOMWrapperWorld&gt;&gt; worlds;
3957     ScriptController::getAllWorlds(worlds);
3958     for (auto&amp; world : worlds)
3959         dispatchDidClearWindowObjectInWorld(world);
3960 }
3961 
3962 void FrameLoader::dispatchDidClearWindowObjectInWorld(DOMWrapperWorld&amp; world)
3963 {
3964     if (!m_frame.script().canExecuteScripts(NotAboutToExecuteScript) || !m_frame.windowProxy().existingJSWindowProxy(world))
3965         return;
3966 
3967     m_client.dispatchDidClearWindowObjectInWorld(world);
3968 
3969     if (Page* page = m_frame.page())
3970         page-&gt;inspectorController().didClearWindowObjectInWorld(m_frame, world);
3971 
3972     InspectorInstrumentation::didClearWindowObjectInWorld(m_frame, world);
3973 }
3974 
3975 void FrameLoader::dispatchGlobalObjectAvailableInAllWorlds()
3976 {
3977     Vector&lt;Ref&lt;DOMWrapperWorld&gt;&gt; worlds;
3978     ScriptController::getAllWorlds(worlds);
3979     for (auto&amp; world : worlds)
3980         m_client.dispatchGlobalObjectAvailable(world);
3981 }
3982 
3983 SandboxFlags FrameLoader::effectiveSandboxFlags() const
3984 {
3985     SandboxFlags flags = m_forcedSandboxFlags;
3986     if (Frame* parentFrame = m_frame.tree().parent())
3987         flags |= parentFrame-&gt;document()-&gt;sandboxFlags();
3988     if (HTMLFrameOwnerElement* ownerElement = m_frame.ownerElement())
3989         flags |= ownerElement-&gt;sandboxFlags();
3990     return flags;
3991 }
3992 
3993 void FrameLoader::didChangeTitle(DocumentLoader* loader)
3994 {
3995     m_client.didChangeTitle(loader);
3996 
3997     if (loader == m_documentLoader) {
3998         // Must update the entries in the back-forward list too.
3999         history().setCurrentItemTitle(loader-&gt;title());
4000         // This must go through the WebFrame because it has the right notion of the current b/f item.
4001         m_client.setTitle(loader-&gt;title(), loader-&gt;urlForHistory());
4002         m_client.setMainFrameDocumentReady(true); // update observers with new DOMDocument
4003         m_client.dispatchDidReceiveTitle(loader-&gt;title());
4004     }
4005 
4006 #if ENABLE(REMOTE_INSPECTOR)
4007     if (m_frame.isMainFrame())
4008         m_frame.page()-&gt;remoteInspectorInformationDidChange();
4009 #endif
4010 }
4011 
4012 void FrameLoader::dispatchDidCommitLoad(Optional&lt;HasInsecureContent&gt; initialHasInsecureContent)
4013 {
4014     if (m_stateMachine.creatingInitialEmptyDocument())
4015         return;
4016 
4017     m_client.dispatchDidCommitLoad(initialHasInsecureContent);
4018 
4019     if (m_frame.isMainFrame()) {
4020         m_frame.page()-&gt;resetSeenPlugins();
4021         m_frame.page()-&gt;resetSeenMediaEngines();
4022     }
4023 
4024     InspectorInstrumentation::didCommitLoad(m_frame, m_documentLoader.get());
4025 
4026 #if ENABLE(REMOTE_INSPECTOR)
4027     if (m_frame.isMainFrame())
4028         m_frame.page()-&gt;remoteInspectorInformationDidChange();
4029 #endif
4030 }
4031 
4032 void FrameLoader::tellClientAboutPastMemoryCacheLoads()
4033 {
4034     ASSERT(m_frame.page());
4035     ASSERT(m_frame.page()-&gt;areMemoryCacheClientCallsEnabled());
4036 
4037     if (!m_documentLoader)
4038         return;
4039 
4040     Vector&lt;ResourceRequest&gt; pastLoads;
4041     m_documentLoader-&gt;takeMemoryCacheLoadsForClientNotification(pastLoads);
4042 
4043     for (auto&amp; pastLoad : pastLoads) {
4044         CachedResource* resource = MemoryCache::singleton().resourceForRequest(pastLoad, m_frame.page()-&gt;sessionID());
4045 
4046         // FIXME: These loads, loaded from cache, but now gone from the cache by the time
4047         // Page::setMemoryCacheClientCallsEnabled(true) is called, will not be seen by the client.
4048         // Consider if there&#39;s some efficient way of remembering enough to deliver this client call.
4049         // We have the URL, but not the rest of the response or the length.
4050         if (!resource)
4051             continue;
4052 
4053         ResourceRequest request(resource-&gt;url());
4054         m_client.dispatchDidLoadResourceFromMemoryCache(m_documentLoader.get(), request, resource-&gt;response(), resource-&gt;encodedSize());
4055     }
4056 }
4057 
4058 NetworkingContext* FrameLoader::networkingContext() const
4059 {
4060     return m_networkingContext.get();
4061 }
4062 
4063 void FrameLoader::loadProgressingStatusChanged()
4064 {
4065     if (auto* view = m_frame.mainFrame().view())
4066         view-&gt;loadProgressingStatusChanged();
4067 }
4068 
4069 void FrameLoader::forcePageTransitionIfNeeded()
4070 {
4071     m_client.forcePageTransitionIfNeeded();
4072 }
4073 
4074 void FrameLoader::clearTestingOverrides()
4075 {
4076     m_overrideCachePolicyForTesting = WTF::nullopt;
4077     m_overrideResourceLoadPriorityForTesting = WTF::nullopt;
4078     m_isStrictRawResourceValidationPolicyDisabledForTesting = false;
4079 }
4080 
4081 bool FrameLoader::isAlwaysOnLoggingAllowed() const
4082 {
4083     return frame().isAlwaysOnLoggingAllowed();
4084 }
4085 
4086 bool FrameLoaderClient::hasHTMLView() const
4087 {
4088     return true;
4089 }
4090 
4091 RefPtr&lt;Frame&gt; createWindow(Frame&amp; openerFrame, Frame&amp; lookupFrame, FrameLoadRequest&amp;&amp; request, const WindowFeatures&amp; features, bool&amp; created)
4092 {
4093     ASSERT(!features.dialog || request.frameName().isEmpty());
4094 
4095     created = false;
4096 
4097     // FIXME: Provide line number information with respect to the opener&#39;s document.
4098     if (WTF::protocolIsJavaScript(request.resourceRequest().url()) &amp;&amp; !openerFrame.document()-&gt;contentSecurityPolicy()-&gt;allowJavaScriptURLs(openerFrame.document()-&gt;url(), { }))
4099         return nullptr;
4100 
4101     if (!request.frameName().isEmpty() &amp;&amp; !equalIgnoringASCIICase(request.frameName(), &quot;_blank&quot;)) {
4102         if (RefPtr&lt;Frame&gt; frame = lookupFrame.loader().findFrameForNavigation(request.frameName(), openerFrame.document())) {
4103             if (!equalIgnoringASCIICase(request.frameName(), &quot;_self&quot;)) {
4104                 if (Page* page = frame-&gt;page())
4105                     page-&gt;chrome().focus();
4106             }
4107             return frame;
4108         }
4109     }
4110 
4111     // Sandboxed frames cannot open new auxiliary browsing contexts.
4112     if (isDocumentSandboxed(openerFrame, SandboxPopups)) {
4113         // FIXME: This message should be moved off the console once a solution to https://bugs.webkit.org/show_bug.cgi?id=103274 exists.
4114         openerFrame.document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Blocked opening &#39;&quot; + request.resourceRequest().url().stringCenterEllipsizedToLength() + &quot;&#39; in a new window because the request was made in a sandboxed frame whose &#39;allow-popups&#39; permission is not set.&quot;);
4115         return nullptr;
4116     }
4117 
4118     // FIXME: Setting the referrer should be the caller&#39;s responsibility.
4119     String referrer = SecurityPolicy::generateReferrerHeader(openerFrame.document()-&gt;referrerPolicy(), request.resourceRequest().url(), openerFrame.loader().outgoingReferrer());
4120     if (!referrer.isEmpty())
4121         request.resourceRequest().setHTTPReferrer(referrer);
4122     FrameLoader::addHTTPOriginIfNeeded(request.resourceRequest(), openerFrame.loader().outgoingOrigin());
4123     FrameLoader::addHTTPUpgradeInsecureRequestsIfNeeded(request.resourceRequest());
4124     FrameLoader::addSameSiteInfoToRequestIfNeeded(request.resourceRequest(), openerFrame.document());
4125 
4126     Page* oldPage = openerFrame.page();
4127     if (!oldPage)
4128         return nullptr;
4129 
4130     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy = shouldOpenExternalURLsPolicyToApply(openerFrame, request);
4131     NavigationAction action { request.requester(), request.resourceRequest(), request.initiatedByMainFrame(), NavigationType::Other, shouldOpenExternalURLsPolicy };
4132     Page* page = oldPage-&gt;chrome().createWindow(openerFrame, request, features, action);
4133     if (!page)
4134         return nullptr;
4135 
4136     RefPtr&lt;Frame&gt; frame = &amp;page-&gt;mainFrame();
4137 
4138     if (isDocumentSandboxed(openerFrame, SandboxPropagatesToAuxiliaryBrowsingContexts))
4139         frame-&gt;loader().forceSandboxFlags(openerFrame.document()-&gt;sandboxFlags());
4140 
4141     if (!equalIgnoringASCIICase(request.frameName(), &quot;_blank&quot;))
4142         frame-&gt;tree().setName(request.frameName());
4143 
4144     page-&gt;chrome().setToolbarsVisible(features.toolBarVisible || features.locationBarVisible);
4145 
4146     if (!frame-&gt;page())
4147         return nullptr;
4148     page-&gt;chrome().setStatusbarVisible(features.statusBarVisible);
4149 
4150     if (!frame-&gt;page())
4151         return nullptr;
4152     page-&gt;chrome().setScrollbarsVisible(features.scrollbarsVisible);
4153 
4154     if (!frame-&gt;page())
4155         return nullptr;
4156     page-&gt;chrome().setMenubarVisible(features.menuBarVisible);
4157 
4158     if (!frame-&gt;page())
4159         return nullptr;
4160     page-&gt;chrome().setResizable(features.resizable);
4161 
4162     // &#39;x&#39; and &#39;y&#39; specify the location of the window, while &#39;width&#39; and &#39;height&#39;
4163     // specify the size of the viewport. We can only resize the window, so adjust
4164     // for the difference between the window size and the viewport size.
4165 
4166     // FIXME: We should reconcile the initialization of viewport arguments between iOS and non-IOS.
4167 #if !PLATFORM(IOS_FAMILY)
4168     FloatSize viewportSize = page-&gt;chrome().pageRect().size();
4169     FloatRect windowRect = page-&gt;chrome().windowRect();
4170     if (features.x)
4171         windowRect.setX(*features.x);
4172     if (features.y)
4173         windowRect.setY(*features.y);
4174     // Zero width and height mean using default size, not minimum one.
4175     if (features.width &amp;&amp; *features.width)
4176         windowRect.setWidth(*features.width + (windowRect.width() - viewportSize.width()));
4177     if (features.height &amp;&amp; *features.height)
4178         windowRect.setHeight(*features.height + (windowRect.height() - viewportSize.height()));
4179 
4180 #if PLATFORM(GTK)
4181     FloatRect oldWindowRect = oldPage-&gt;chrome().windowRect();
4182     // Use the size of the previous window if there is no default size.
4183     if (!windowRect.width())
4184         windowRect.setWidth(oldWindowRect.width());
4185     if (!windowRect.height())
4186         windowRect.setHeight(oldWindowRect.height());
4187 #endif
4188 
4189     // Ensure non-NaN values, minimum size as well as being within valid screen area.
4190     FloatRect newWindowRect = DOMWindow::adjustWindowRect(*page, windowRect);
4191 
4192     if (!frame-&gt;page())
4193         return nullptr;
4194     page-&gt;chrome().setWindowRect(newWindowRect);
4195 #else
4196     // On iOS, width and height refer to the viewport dimensions.
4197     ViewportArguments arguments;
4198     // Zero width and height mean using default size, not minimum one.
4199     if (features.width &amp;&amp; *features.width)
4200         arguments.width = *features.width;
4201     if (features.height &amp;&amp; *features.height)
4202         arguments.height = *features.height;
4203     frame-&gt;setViewportArguments(arguments);
4204 #endif
4205 
4206     if (!frame-&gt;page())
4207         return nullptr;
4208     page-&gt;chrome().show();
4209 
4210     created = true;
4211     return frame;
4212 }
4213 
4214 bool FrameLoader::shouldSuppressTextInputFromEditing() const
4215 {
4216     return m_frame.settings().shouldSuppressTextInputFromEditingDuringProvisionalNavigation() &amp;&amp; m_state == FrameStateProvisional;
4217 }
4218 
4219 } // namespace WebCore
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>