<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/dom/Document.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
   5  *           (C) 2006 Alexey Proskuryakov (ap@webkit.org)
   6  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   7  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   8  * Copyright (C) 2008, 2009, 2011, 2012 Google Inc. All rights reserved.
   9  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
  10  * Copyright (C) Research In Motion Limited 2010-2011. All rights reserved.
  11  *
  12  * This library is free software; you can redistribute it and/or
  13  * modify it under the terms of the GNU Library General Public
  14  * License as published by the Free Software Foundation; either
  15  * version 2 of the License, or (at your option) any later version.
  16  *
  17  * This library is distributed in the hope that it will be useful,
  18  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  19  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  20  * Library General Public License for more details.
  21  *
  22  * You should have received a copy of the GNU Library General Public License
  23  * along with this library; see the file COPYING.LIB.  If not, write to
  24  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  25  * Boston, MA 02110-1301, USA.
  26  */
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;Document.h&quot;
  30 
  31 #include &quot;AXObjectCache.h&quot;
  32 #include &quot;Attr.h&quot;
  33 #include &quot;BeforeUnloadEvent.h&quot;
  34 #include &quot;CDATASection.h&quot;
  35 #include &quot;CSSAnimationController.h&quot;
  36 #include &quot;CSSFontSelector.h&quot;
  37 #include &quot;CSSStyleDeclaration.h&quot;
  38 #include &quot;CSSStyleSheet.h&quot;
  39 #include &quot;CachedCSSStyleSheet.h&quot;
  40 #include &quot;CachedFrame.h&quot;
  41 #include &quot;CachedResourceLoader.h&quot;
  42 #include &quot;CanvasRenderingContext2D.h&quot;
  43 #include &quot;Chrome.h&quot;
  44 #include &quot;ChromeClient.h&quot;
  45 #include &quot;Comment.h&quot;
  46 #include &quot;CommonVM.h&quot;
  47 #include &quot;ComposedTreeIterator.h&quot;
  48 #include &quot;CompositionEvent.h&quot;
  49 #include &quot;ConstantPropertyMap.h&quot;
  50 #include &quot;ContentSecurityPolicy.h&quot;
  51 #include &quot;CookieJar.h&quot;
  52 #include &quot;CustomElementReactionQueue.h&quot;
  53 #include &quot;CustomElementRegistry.h&quot;
  54 #include &quot;CustomEvent.h&quot;
  55 #include &quot;CustomHeaderFields.h&quot;
  56 #include &quot;DOMImplementation.h&quot;
  57 #include &quot;DOMWindow.h&quot;
  58 #include &quot;DateComponents.h&quot;
  59 #include &quot;DebugPageOverlays.h&quot;
  60 #include &quot;DeprecatedGlobalSettings.h&quot;
  61 #include &quot;DocumentLoader.h&quot;
  62 #include &quot;DocumentMarkerController.h&quot;
  63 #include &quot;DocumentSharedObjectPool.h&quot;
  64 #include &quot;DocumentTimeline.h&quot;
  65 #include &quot;DocumentType.h&quot;
  66 #include &quot;DragEvent.h&quot;
  67 #include &quot;Editing.h&quot;
  68 #include &quot;Editor.h&quot;
  69 #include &quot;ElementIterator.h&quot;
  70 #include &quot;EventHandler.h&quot;
  71 #include &quot;ExtensionStyleSheets.h&quot;
  72 #include &quot;FocusController.h&quot;
  73 #include &quot;FocusEvent.h&quot;
  74 #include &quot;FontFaceSet.h&quot;
  75 #include &quot;FormController.h&quot;
  76 #include &quot;Frame.h&quot;
  77 #include &quot;FrameLoader.h&quot;
  78 #include &quot;FrameLoaderClient.h&quot;
  79 #include &quot;FrameView.h&quot;
  80 #include &quot;FullscreenManager.h&quot;
  81 #include &quot;GCReachableRef.h&quot;
  82 #include &quot;GenericCachedHTMLCollection.h&quot;
  83 #include &quot;HTMLAllCollection.h&quot;
  84 #include &quot;HTMLAnchorElement.h&quot;
  85 #include &quot;HTMLAttachmentElement.h&quot;
  86 #include &quot;HTMLBaseElement.h&quot;
  87 #include &quot;HTMLBodyElement.h&quot;
  88 #include &quot;HTMLCanvasElement.h&quot;
  89 #include &quot;HTMLDocument.h&quot;
  90 #include &quot;HTMLElementFactory.h&quot;
  91 #include &quot;HTMLFormControlElement.h&quot;
  92 #include &quot;HTMLFrameOwnerElement.h&quot;
  93 #include &quot;HTMLFrameSetElement.h&quot;
  94 #include &quot;HTMLHeadElement.h&quot;
  95 #include &quot;HTMLHtmlElement.h&quot;
  96 #include &quot;HTMLImageElement.h&quot;
  97 #include &quot;HTMLInputElement.h&quot;
  98 #include &quot;HTMLLinkElement.h&quot;
  99 #include &quot;HTMLMediaElement.h&quot;
 100 #include &quot;HTMLNameCollection.h&quot;
 101 #include &quot;HTMLParserIdioms.h&quot;
 102 #include &quot;HTMLPictureElement.h&quot;
 103 #include &quot;HTMLPlugInElement.h&quot;
 104 #include &quot;HTMLScriptElement.h&quot;
 105 #include &quot;HTMLStyleElement.h&quot;
 106 #include &quot;HTMLTitleElement.h&quot;
 107 #include &quot;HTMLUnknownElement.h&quot;
 108 #include &quot;HTTPHeaderNames.h&quot;
 109 #include &quot;HTTPParsers.h&quot;
 110 #include &quot;HashChangeEvent.h&quot;
 111 #include &quot;HighlightMap.h&quot;
 112 #include &quot;History.h&quot;
 113 #include &quot;HitTestResult.h&quot;
 114 #include &quot;IdleCallbackController.h&quot;
 115 #include &quot;ImageBitmapRenderingContext.h&quot;
 116 #include &quot;ImageLoader.h&quot;
 117 #include &quot;InspectorInstrumentation.h&quot;
 118 #include &quot;IntersectionObserver.h&quot;
 119 #include &quot;JSCustomElementInterface.h&quot;
 120 #include &quot;JSLazyEventListener.h&quot;
 121 #include &quot;KeyboardEvent.h&quot;
 122 #include &quot;KeyframeEffect.h&quot;
 123 #include &quot;LayoutDisallowedScope.h&quot;
 124 #include &quot;LegacySchemeRegistry.h&quot;
 125 #include &quot;LibWebRTCProvider.h&quot;
 126 #include &quot;LoaderStrategy.h&quot;
 127 #include &quot;Logging.h&quot;
 128 #include &quot;MediaCanStartListener.h&quot;
 129 #include &quot;MediaProducer.h&quot;
 130 #include &quot;MediaQueryList.h&quot;
 131 #include &quot;MediaQueryMatcher.h&quot;
 132 #include &quot;MediaStream.h&quot;
 133 #include &quot;MessageEvent.h&quot;
 134 #include &quot;MouseEventWithHitTestResults.h&quot;
 135 #include &quot;MutationEvent.h&quot;
 136 #include &quot;NameNodeList.h&quot;
 137 #include &quot;NavigationDisabler.h&quot;
 138 #include &quot;NavigationScheduler.h&quot;
 139 #include &quot;NestingLevelIncrementer.h&quot;
 140 #include &quot;NodeIterator.h&quot;
 141 #include &quot;NodeRareData.h&quot;
 142 #include &quot;NodeWithIndex.h&quot;
 143 #include &quot;OverflowEvent.h&quot;
 144 #include &quot;PageConsoleClient.h&quot;
 145 #include &quot;PageGroup.h&quot;
 146 #include &quot;PageTransitionEvent.h&quot;
 147 #include &quot;PaintWorkletGlobalScope.h&quot;
 148 #include &quot;PlatformLocale.h&quot;
 149 #include &quot;PlatformMediaSessionManager.h&quot;
 150 #include &quot;PlatformScreen.h&quot;
 151 #include &quot;PlatformStrategies.h&quot;
 152 #include &quot;PlugInsResources.h&quot;
 153 #include &quot;PluginDocument.h&quot;
 154 #include &quot;PointerLockController.h&quot;
 155 #include &quot;PolicyChecker.h&quot;
 156 #include &quot;PopStateEvent.h&quot;
 157 #include &quot;ProcessingInstruction.h&quot;
 158 #include &quot;PublicSuffix.h&quot;
 159 #include &quot;Quirks.h&quot;
 160 #include &quot;RealtimeMediaSourceCenter.h&quot;
 161 #include &quot;RenderChildIterator.h&quot;
 162 #include &quot;RenderInline.h&quot;
 163 #include &quot;RenderLayerCompositor.h&quot;
 164 #include &quot;RenderLineBreak.h&quot;
 165 #include &quot;RenderTreeUpdater.h&quot;
 166 #include &quot;RenderView.h&quot;
 167 #include &quot;RenderWidget.h&quot;
 168 #include &quot;RequestAnimationFrameCallback.h&quot;
 169 #include &quot;ResizeObserver.h&quot;
 170 #include &quot;ResourceLoadObserver.h&quot;
 171 #include &quot;RuntimeApplicationChecks.h&quot;
 172 #include &quot;RuntimeEnabledFeatures.h&quot;
 173 #include &quot;SVGDocumentExtensions.h&quot;
 174 #include &quot;SVGElement.h&quot;
 175 #include &quot;SVGElementFactory.h&quot;
 176 #include &quot;SVGNames.h&quot;
 177 #include &quot;SVGSVGElement.h&quot;
 178 #include &quot;SVGTitleElement.h&quot;
 179 #include &quot;SVGUseElement.h&quot;
 180 #include &quot;SVGZoomEvent.h&quot;
 181 #include &quot;SWClientConnection.h&quot;
 182 #include &quot;ScopedEventQueue.h&quot;
 183 #include &quot;ScriptController.h&quot;
 184 #include &quot;ScriptDisallowedScope.h&quot;
 185 #include &quot;ScriptModuleLoader.h&quot;
 186 #include &quot;ScriptRunner.h&quot;
 187 #include &quot;ScriptSourceCode.h&quot;
 188 #include &quot;ScriptState.h&quot;
 189 #include &quot;ScriptedAnimationController.h&quot;
 190 #include &quot;ScrollbarTheme.h&quot;
 191 #include &quot;ScrollingCoordinator.h&quot;
 192 #include &quot;SecurityOrigin.h&quot;
 193 #include &quot;SecurityOriginData.h&quot;
 194 #include &quot;SecurityOriginPolicy.h&quot;
 195 #include &quot;SecurityPolicy.h&quot;
 196 #include &quot;SegmentedString.h&quot;
 197 #include &quot;SelectorQuery.h&quot;
 198 #include &quot;ServiceWorkerClientData.h&quot;
 199 #include &quot;ServiceWorkerContainer.h&quot;
 200 #include &quot;ServiceWorkerProvider.h&quot;
 201 #include &quot;Settings.h&quot;
 202 #include &quot;ShadowRoot.h&quot;
 203 #include &quot;SocketProvider.h&quot;
 204 #include &quot;StorageEvent.h&quot;
 205 #include &quot;StringCallback.h&quot;
 206 #include &quot;StyleColor.h&quot;
 207 #include &quot;StyleProperties.h&quot;
 208 #include &quot;StyleResolveForDocument.h&quot;
 209 #include &quot;StyleResolver.h&quot;
 210 #include &quot;StyleScope.h&quot;
 211 #include &quot;StyleSheetContents.h&quot;
 212 #include &quot;StyleSheetList.h&quot;
 213 #include &quot;StyleTreeResolver.h&quot;
 214 #include &quot;SubresourceLoader.h&quot;
 215 #include &quot;TextAutoSizing.h&quot;
 216 #include &quot;TextEvent.h&quot;
 217 #include &quot;TextManipulationController.h&quot;
 218 #include &quot;TextNodeTraversal.h&quot;
 219 #include &quot;TouchAction.h&quot;
 220 #include &quot;TransformSource.h&quot;
 221 #include &quot;TreeWalker.h&quot;
 222 #include &quot;UndoManager.h&quot;
 223 #include &quot;UserGestureIndicator.h&quot;
 224 #include &quot;ValidationMessageClient.h&quot;
 225 #include &quot;VisibilityChangeClient.h&quot;
 226 #include &quot;VisitedLinkState.h&quot;
 227 #include &quot;VisualViewport.h&quot;
 228 #include &quot;WebAnimation.h&quot;
 229 #include &quot;WheelEvent.h&quot;
 230 #include &quot;WindowEventLoop.h&quot;
 231 #include &quot;WindowFeatures.h&quot;
 232 #include &quot;Worklet.h&quot;
 233 #include &quot;XMLDocument.h&quot;
 234 #include &quot;XMLDocumentParser.h&quot;
 235 #include &quot;XMLNSNames.h&quot;
 236 #include &quot;XMLNames.h&quot;
 237 #include &quot;XPathEvaluator.h&quot;
 238 #include &quot;XPathExpression.h&quot;
 239 #include &quot;XPathNSResolver.h&quot;
 240 #include &quot;XPathResult.h&quot;
 241 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
 242 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 243 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 244 #include &lt;JavaScriptCore/VM.h&gt;
 245 #include &lt;ctime&gt;
 246 #include &lt;wtf/IsoMallocInlines.h&gt;
 247 #include &lt;wtf/Language.h&gt;
 248 #include &lt;wtf/NeverDestroyed.h&gt;
 249 #include &lt;wtf/SetForScope.h&gt;
 250 #include &lt;wtf/SystemTracing.h&gt;
 251 #include &lt;wtf/UUID.h&gt;
 252 #include &lt;wtf/text/StringBuffer.h&gt;
 253 #include &lt;wtf/text/TextStream.h&gt;
 254 
 255 #if PLATFORM(JAVA)
 256 #include &lt;wtf/unicode/java/UnicodeJava.h&gt;
 257 #endif
 258 
 259 #if ENABLE(DEVICE_ORIENTATION)
 260 #include &quot;DeviceMotionEvent.h&quot;
 261 #include &quot;DeviceOrientationAndMotionAccessController.h&quot;
 262 #include &quot;DeviceOrientationEvent.h&quot;
 263 #endif
 264 
 265 #if ENABLE(FULLSCREEN_API)
 266 #include &quot;RenderFullScreen.h&quot;
 267 #endif
 268 
 269 #if ENABLE(INDEXED_DATABASE)
 270 #include &quot;IDBConnectionProxy.h&quot;
 271 #include &quot;IDBOpenDBRequest.h&quot;
 272 #endif
 273 
 274 #if PLATFORM(IOS_FAMILY)
 275 #include &quot;ContentChangeObserver.h&quot;
 276 #include &quot;CSSFontSelector.h&quot;
 277 #include &quot;DOMTimerHoldingTank.h&quot;
 278 #include &quot;DeviceMotionClientIOS.h&quot;
 279 #include &quot;DeviceMotionController.h&quot;
 280 #include &quot;DeviceOrientationClientIOS.h&quot;
 281 #include &quot;DeviceOrientationController.h&quot;
 282 #include &quot;Geolocation.h&quot;
 283 #include &quot;Navigator.h&quot;
 284 #include &quot;NavigatorGeolocation.h&quot;
 285 #endif
 286 
 287 #if ENABLE(IOS_GESTURE_EVENTS)
 288 #include &quot;GestureEvent.h&quot;
 289 #endif
 290 
 291 #if ENABLE(MATHML)
 292 #include &quot;MathMLElement.h&quot;
 293 #include &quot;MathMLElementFactory.h&quot;
 294 #include &quot;MathMLNames.h&quot;
 295 #endif
 296 
 297 #if ENABLE(MEDIA_SESSION)
 298 #include &quot;MediaSession.h&quot;
 299 #endif
 300 
 301 #if USE(QUICK_LOOK)
 302 #include &quot;QuickLook.h&quot;
 303 #endif
 304 
 305 #if ENABLE(TOUCH_EVENTS)
 306 #include &quot;TouchEvent.h&quot;
 307 #endif
 308 
 309 #if ENABLE(VIDEO_TRACK)
 310 #include &quot;CaptionUserPreferences.h&quot;
 311 #endif
 312 
 313 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 314 #include &quot;MediaPlaybackTargetClient.h&quot;
 315 #endif
 316 
 317 #if ENABLE(XSLT)
 318 #include &quot;XSLTProcessor.h&quot;
 319 #endif
 320 
 321 #if ENABLE(WEBGL)
 322 #include &quot;WebGLRenderingContext.h&quot;
 323 #endif
 324 #if ENABLE(WEBGL2)
 325 #include &quot;WebGL2RenderingContext.h&quot;
 326 #endif
 327 #if ENABLE(WEBGPU)
 328 #include &quot;GPUCanvasContext.h&quot;
 329 #endif
 330 
 331 #if ENABLE(POINTER_EVENTS)
 332 #include &quot;PointerCaptureController.h&quot;
 333 #endif
 334 
 335 #if ENABLE(PICTURE_IN_PICTURE_API)
 336 #include &quot;HTMLVideoElement.h&quot;
 337 #endif
 338 
 339 namespace WebCore {
 340 
 341 WTF_MAKE_ISO_ALLOCATED_IMPL(Document);
 342 
 343 using namespace HTMLNames;
 344 using namespace PAL;
 345 using namespace WTF::Unicode;
 346 
 347 static const unsigned cMaxWriteRecursionDepth = 21;
 348 bool Document::hasEverCreatedAnAXObjectCache = false;
 349 static const Seconds maxIntervalForUserGestureForwardingAfterMediaFinishesPlaying { 1_s };
 350 
 351 struct FrameFlatteningLayoutDisallower {
 352     FrameFlatteningLayoutDisallower(FrameView&amp; frameView)
 353         : m_frameView(frameView)
 354         , m_disallowLayout(frameView.effectiveFrameFlattening() != FrameFlattening::Disabled)
 355     {
 356         if (m_disallowLayout)
 357             m_frameView.startDisallowingLayout();
 358     }
 359 
 360     ~FrameFlatteningLayoutDisallower()
 361     {
 362         if (m_disallowLayout)
 363             m_frameView.endDisallowingLayout();
 364     }
 365 
 366 private:
 367     FrameView&amp; m_frameView;
 368     bool m_disallowLayout { false };
 369 };
 370 
 371 // Defined here to avoid including GCReachableRef.h in Document.h
 372 struct Document::PendingScrollEventTargetList {
 373     WTF_MAKE_FAST_ALLOCATED;
 374 
 375 public:
 376     Vector&lt;GCReachableRef&lt;ContainerNode&gt;&gt; targets;
 377 };
 378 
 379 #if ENABLE(INTERSECTION_OBSERVER)
 380 static const Seconds intersectionObserversInitialUpdateDelay { 2000_ms };
 381 #endif
 382 
 383 // DOM Level 2 says (letters added):
 384 //
 385 // a) Name start characters must have one of the categories Ll, Lu, Lo, Lt, Nl.
 386 // b) Name characters other than Name-start characters must have one of the categories Mc, Me, Mn, Lm, or Nd.
 387 // c) Characters in the compatibility area (i.e. with character code greater than #xF900 and less than #xFFFE) are not allowed in XML names.
 388 // d) Characters which have a font or compatibility decomposition (i.e. those with a &quot;compatibility formatting tag&quot; in field 5 of the database -- marked by field 5 beginning with a &quot;&lt;&quot;) are not allowed.
 389 // e) The following characters are treated as name-start characters rather than name characters, because the property file classifies them as Alphabetic: [#x02BB-#x02C1], #x0559, #x06E5, #x06E6.
 390 // f) Characters #x20DD-#x20E0 are excluded (in accordance with Unicode, section 5.14).
 391 // g) Character #x00B7 is classified as an extender, because the property list so identifies it.
 392 // h) Character #x0387 is added as a name character, because #x00B7 is its canonical equivalent.
 393 // i) Characters &#39;:&#39; and &#39;_&#39; are allowed as name-start characters.
 394 // j) Characters &#39;-&#39; and &#39;.&#39; are allowed as name characters.
 395 //
 396 // It also contains complete tables. If we decide it&#39;s better, we could include those instead of the following code.
 397 
 398 static inline bool isValidNameStart(UChar32 c)
 399 {
 400     // rule (e) above
 401     if ((c &gt;= 0x02BB &amp;&amp; c &lt;= 0x02C1) || c == 0x559 || c == 0x6E5 || c == 0x6E6)
 402         return true;
 403 
 404     // rule (i) above
 405     if (c == &#39;:&#39; || c == &#39;_&#39;)
 406         return true;
 407 
 408     // rules (a) and (f) above
 409     if (!(U_GET_GC_MASK(c) &amp; (U_GC_LL_MASK | U_GC_LU_MASK | U_GC_LO_MASK | U_GC_LT_MASK | U_GC_NL_MASK)))
 410         return false;
 411 
 412     // rule (c) above
 413     if (c &gt;= 0xF900 &amp;&amp; c &lt; 0xFFFE)
 414         return false;
 415 
 416     // rule (d) above
 417 #if PLATFORM(JAVA) // todo tav old code not using icu
 418     DecompositionType decompType = decompositionType(c);
 419     if (decompType == DecompositionFont || decompType == DecompositionCompat)
 420         return false;
 421 #else
 422     int type = u_getIntPropertyValue(c, UCHAR_DECOMPOSITION_TYPE);
 423     if (type == U_DT_FONT || type == U_DT_COMPAT)
 424         return false;
 425 #endif
 426 
 427     return true;
 428 }
 429 
 430 static inline bool isValidNamePart(UChar32 c)
 431 {
 432     // rules (a), (e), and (i) above
 433     if (isValidNameStart(c))
 434         return true;
 435 
 436     // rules (g) and (h) above
 437     if (c == 0x00B7 || c == 0x0387)
 438         return true;
 439 
 440     // rule (j) above
 441     if (c == &#39;-&#39; || c == &#39;.&#39;)
 442         return true;
 443 
 444     // rules (b) and (f) above
 445     if (!(U_GET_GC_MASK(c) &amp; (U_GC_M_MASK | U_GC_LM_MASK | U_GC_ND_MASK)))
 446         return false;
 447 
 448     // rule (c) above
 449     if (c &gt;= 0xF900 &amp;&amp; c &lt; 0xFFFE)
 450         return false;
 451 
 452     // rule (d) above
 453 #if PLATFORM(JAVA) // todo tav old code not using icu
 454     DecompositionType decompType = decompositionType(c);
 455     if (decompType == DecompositionFont || decompType == DecompositionCompat)
 456         return false;
 457 #else
 458     int type = u_getIntPropertyValue(c, UCHAR_DECOMPOSITION_TYPE);
 459     if (type == U_DT_FONT || type == U_DT_COMPAT)
 460         return false;
 461 #endif
 462 
 463     return true;
 464 }
 465 
 466 static Widget* widgetForElement(Element* focusedElement)
 467 {
 468     if (!focusedElement)
 469         return nullptr;
 470     auto* renderer = focusedElement-&gt;renderer();
 471     if (!is&lt;RenderWidget&gt;(renderer))
 472         return nullptr;
 473     return downcast&lt;RenderWidget&gt;(*renderer).widget();
 474 }
 475 
 476 static bool acceptsEditingFocus(const Element&amp; element)
 477 {
 478     ASSERT(element.hasEditableStyle());
 479 
 480     auto* root = element.rootEditableElement();
 481     Frame* frame = element.document().frame();
 482     if (!frame || !root)
 483         return false;
 484 
 485     return frame-&gt;editor().shouldBeginEditing(rangeOfContents(*root).ptr());
 486 }
 487 
 488 static bool canAccessAncestor(const SecurityOrigin&amp; activeSecurityOrigin, Frame* targetFrame)
 489 {
 490     // targetFrame can be 0 when we&#39;re trying to navigate a top-level frame
 491     // that has a 0 opener.
 492     if (!targetFrame)
 493         return false;
 494 
 495     const bool isLocalActiveOrigin = activeSecurityOrigin.isLocal();
 496     for (Frame* ancestorFrame = targetFrame; ancestorFrame; ancestorFrame = ancestorFrame-&gt;tree().parent()) {
 497         Document* ancestorDocument = ancestorFrame-&gt;document();
 498         // FIXME: Should be an ASSERT? Frames should alway have documents.
 499         if (!ancestorDocument)
 500             return true;
 501 
 502         const SecurityOrigin&amp; ancestorSecurityOrigin = ancestorDocument-&gt;securityOrigin();
 503         if (activeSecurityOrigin.canAccess(ancestorSecurityOrigin))
 504             return true;
 505 
 506         // Allow file URL descendant navigation even when allowFileAccessFromFileURLs is false.
 507         // FIXME: It&#39;s a bit strange to special-case local origins here. Should we be doing
 508         // something more general instead?
 509         if (isLocalActiveOrigin &amp;&amp; ancestorSecurityOrigin.isLocal())
 510             return true;
 511     }
 512 
 513     return false;
 514 }
 515 
 516 static void printNavigationErrorMessage(Frame&amp; frame, const URL&amp; activeURL, const char* reason)
 517 {
 518     String message = &quot;Unsafe JavaScript attempt to initiate navigation for frame with URL &#39;&quot; + frame.document()-&gt;url().string() + &quot;&#39; from frame with URL &#39;&quot; + activeURL.string() + &quot;&#39;. &quot; + reason + &quot;\n&quot;;
 519 
 520     // FIXME: should we print to the console of the document performing the navigation instead?
 521     frame.document()-&gt;domWindow()-&gt;printErrorMessage(message);
 522 }
 523 
 524 uint64_t Document::s_globalTreeVersion = 0;
 525 
 526 auto Document::allDocumentsMap() -&gt; DocumentsMap&amp;
 527 {
 528     static NeverDestroyed&lt;DocumentsMap&gt; documents;
 529     return documents;
 530 }
 531 
 532 auto Document::allDocuments() -&gt; DocumentsMap::ValuesIteratorRange
 533 {
 534     return allDocumentsMap().values();
 535 }
 536 
 537 static inline int currentOrientation(Frame* frame)
 538 {
 539 #if ENABLE(ORIENTATION_EVENTS)
 540     if (frame)
 541         return frame-&gt;orientation();
 542 #else
 543     UNUSED_PARAM(frame);
 544 #endif
 545     return 0;
 546 }
 547 
 548 Document::Document(Frame* frame, const URL&amp; url, unsigned documentClasses, unsigned constructionFlags)
 549     : ContainerNode(*this, CreateDocument)
 550     , TreeScope(*this)
 551     , FrameDestructionObserver(frame)
 552 #if ENABLE(IOS_TOUCH_EVENTS)
 553     , m_touchEventsChangedTimer(*this, &amp;Document::touchEventsChangedTimerFired)
 554 #endif
 555     , m_settings(frame ? Ref&lt;Settings&gt;(frame-&gt;settings()) : Settings::create(nullptr))
 556     , m_quirks(makeUniqueRef&lt;Quirks&gt;(*this))
 557     , m_cachedResourceLoader(m_frame ? Ref&lt;CachedResourceLoader&gt;(m_frame-&gt;loader().activeDocumentLoader()-&gt;cachedResourceLoader()) : CachedResourceLoader::create(nullptr))
 558     , m_domTreeVersion(++s_globalTreeVersion)
 559     , m_styleScope(makeUnique&lt;Style::Scope&gt;(*this))
 560     , m_extensionStyleSheets(makeUnique&lt;ExtensionStyleSheets&gt;(*this))
 561     , m_visitedLinkState(makeUnique&lt;VisitedLinkState&gt;(*this))
 562     , m_markers(makeUnique&lt;DocumentMarkerController&gt;(*this))
 563     , m_styleRecalcTimer([this] { updateStyleIfNeeded(); })
 564     , m_documentCreationTime(MonotonicTime::now())
 565     , m_scriptRunner(makeUnique&lt;ScriptRunner&gt;(*this))
 566     , m_moduleLoader(makeUnique&lt;ScriptModuleLoader&gt;(*this))
 567 #if ENABLE(XSLT)
 568     , m_applyPendingXSLTransformsTimer(*this, &amp;Document::applyPendingXSLTransformsTimerFired)
 569 #endif
 570     , m_xmlVersion(&quot;1.0&quot;_s)
 571     , m_constantPropertyMap(makeUnique&lt;ConstantPropertyMap&gt;(*this))
 572     , m_documentClasses(documentClasses)
 573 #if ENABLE(FULLSCREEN_API)
 574     , m_fullscreenManager { makeUniqueRef&lt;FullscreenManager&gt;(*this) }
 575 #endif
 576 #if ENABLE(INTERSECTION_OBSERVER)
 577     , m_intersectionObserversNotifyTimer(*this, &amp;Document::notifyIntersectionObserversTimerFired)
 578     , m_intersectionObserversInitialUpdateTimer(*this, &amp;Document::scheduleTimedRenderingUpdate)
 579 #endif
 580     , m_loadEventDelayTimer(*this, &amp;Document::loadEventDelayTimerFired)
 581 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(DEVICE_ORIENTATION)
 582     , m_deviceMotionClient(makeUnique&lt;DeviceMotionClientIOS&gt;(page() ? page()-&gt;deviceOrientationUpdateProvider() : nullptr))
 583     , m_deviceMotionController(makeUnique&lt;DeviceMotionController&gt;(*m_deviceMotionClient))
 584     , m_deviceOrientationClient(makeUnique&lt;DeviceOrientationClientIOS&gt;(page() ? page()-&gt;deviceOrientationUpdateProvider() : nullptr))
 585     , m_deviceOrientationController(makeUnique&lt;DeviceOrientationController&gt;(*m_deviceOrientationClient))
 586 #endif
 587     , m_pendingTasksTimer(*this, &amp;Document::pendingTasksTimerFired)
 588     , m_visualUpdatesSuppressionTimer(*this, &amp;Document::visualUpdatesSuppressionTimerFired)
 589     , m_sharedObjectPoolClearTimer(*this, &amp;Document::clearSharedObjectPool)
 590     , m_fontSelector(CSSFontSelector::create(*this))
 591     , m_didAssociateFormControlsTimer(*this, &amp;Document::didAssociateFormControlsTimerFired)
 592     , m_cookieCacheExpiryTimer(*this, &amp;Document::invalidateDOMCookieCache)
 593     , m_socketProvider(page() ? &amp;page()-&gt;socketProvider() : nullptr)
 594     , m_isSynthesized(constructionFlags &amp; Synthesized)
 595     , m_isNonRenderedPlaceholder(constructionFlags &amp; NonRenderedPlaceholder)
 596     , m_orientationNotifier(currentOrientation(frame))
 597     , m_identifier(DocumentIdentifier::generate())
 598     , m_undoManager(UndoManager::create(*this))
 599 {
 600     auto addResult = allDocumentsMap().add(m_identifier, this);
 601     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 602 
 603     // We depend on the url getting immediately set in subframes, but we
 604     // also depend on the url NOT getting immediately set in opened windows.
 605     // See fast/dom/early-frame-url.html
 606     // and fast/dom/location-new-window-no-crash.html, respectively.
 607     // FIXME: Can/should we unify this behavior?
 608     if ((frame &amp;&amp; frame-&gt;ownerElement()) || !url.isEmpty())
 609         setURL(url);
 610 
 611     m_cachedResourceLoader-&gt;setDocument(this);
 612 
 613     resetLinkColor();
 614     resetVisitedLinkColor();
 615     resetActiveLinkColor();
 616 
 617     initSecurityContext();
 618     initDNSPrefetch();
 619 
 620     m_fontSelector-&gt;registerForInvalidationCallbacks(*this);
 621 
 622     for (auto&amp; nodeListAndCollectionCount : m_nodeListAndCollectionCounts)
 623         nodeListAndCollectionCount = 0;
 624 
 625     InspectorInstrumentation::addEventListenersToNode(*this);
 626 #if ENABLE(MEDIA_STREAM)
 627     m_settings-&gt;setLegacyGetUserMediaEnabled(quirks().shouldEnableLegacyGetUserMedia());
 628 #endif
 629 }
 630 
 631 Ref&lt;Document&gt; Document::create(Document&amp; contextDocument)
 632 {
 633     auto document = adoptRef(*new Document(nullptr, URL()));
 634     document-&gt;setContextDocument(contextDocument);
 635     document-&gt;setSecurityOriginPolicy(contextDocument.securityOriginPolicy());
 636     return document;
 637 }
 638 
 639 Ref&lt;Document&gt; Document::createNonRenderedPlaceholder(Frame&amp; frame, const URL&amp; url)
 640 {
 641     return adoptRef(*new Document(&amp;frame, url, DefaultDocumentClass, NonRenderedPlaceholder));
 642 }
 643 
 644 Document::~Document()
 645 {
 646     ASSERT(activeDOMObjectsAreStopped());
 647 
 648     if (m_logger)
 649         m_logger-&gt;removeObserver(*this);
 650 
 651     ASSERT(allDocumentsMap().contains(m_identifier));
 652     allDocumentsMap().remove(m_identifier);
 653     // We need to remove from the contexts map very early in the destructor so that calling postTask() on this Document from another thread is safe.
 654     removeFromContextsMap();
 655 
 656     ASSERT(!renderView());
 657     ASSERT(m_backForwardCacheState != InBackForwardCache);
 658     ASSERT(m_ranges.isEmpty());
 659     ASSERT(!m_parentTreeScope);
 660     ASSERT(!m_disabledFieldsetElementsCount);
 661     ASSERT(m_inDocumentShadowRoots.isEmpty());
 662 
 663 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
 664     m_deviceMotionClient-&gt;deviceMotionControllerDestroyed();
 665     m_deviceOrientationClient-&gt;deviceOrientationControllerDestroyed();
 666 #endif
 667 
 668     if (m_templateDocument)
 669         m_templateDocument-&gt;setTemplateDocumentHost(nullptr); // balanced in templateDocument().
 670 
 671     // FIXME: Should we reset m_domWindow when we detach from the Frame?
 672     if (m_domWindow)
 673         m_domWindow-&gt;resetUnlessSuspendedForDocumentSuspension();
 674 
 675     m_scriptRunner = nullptr;
 676     m_moduleLoader = nullptr;
 677 
 678     removeAllEventListeners();
 679 
 680     // Currently we believe that Document can never outlive the parser.
 681     // Although the Document may be replaced synchronously, DocumentParsers
 682     // generally keep at least one reference to an Element which would in turn
 683     // has a reference to the Document.  If you hit this ASSERT, then that
 684     // assumption is wrong.  DocumentParser::detach() should ensure that even
 685     // if the DocumentParser outlives the Document it won&#39;t cause badness.
 686     ASSERT(!m_parser || m_parser-&gt;refCount() == 1);
 687     detachParser();
 688 
 689     if (this == &amp;topDocument())
 690         clearAXObjectCache();
 691 
 692     m_decoder = nullptr;
 693 
 694     if (m_styleSheetList)
 695         m_styleSheetList-&gt;detach();
 696 
 697     extensionStyleSheets().detachFromDocument();
 698 
 699     styleScope().clearResolver(); // We need to destroy CSSFontSelector before destroying m_cachedResourceLoader.
 700     m_fontSelector-&gt;clearDocument();
 701     m_fontSelector-&gt;unregisterForInvalidationCallbacks(*this);
 702 
 703     // It&#39;s possible for multiple Documents to end up referencing the same CachedResourceLoader (e.g., SVGImages
 704     // load the initial empty document and the SVGDocument with the same DocumentLoader).
 705     if (m_cachedResourceLoader-&gt;document() == this)
 706         m_cachedResourceLoader-&gt;setDocument(nullptr);
 707 
 708 #if ENABLE(VIDEO)
 709     stopAllMediaPlayback();
 710 #endif
 711 
 712     // We must call clearRareData() here since a Document class inherits TreeScope
 713     // as well as Node. See a comment on TreeScope.h for the reason.
 714     if (hasRareData())
 715         clearRareData();
 716 
 717     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(m_listsInvalidatedAtDocument.isEmpty());
 718     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(m_collectionsInvalidatedAtDocument.isEmpty());
 719     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(m_svgUseElements.isEmpty());
 720 
 721     for (unsigned count : m_nodeListAndCollectionCounts)
 722         ASSERT_UNUSED(count, !count);
 723 }
 724 
 725 void Document::removedLastRef()
 726 {
 727     ASSERT(!m_deletionHasBegun);
 728     if (m_referencingNodeCount) {
 729         // Node::removedLastRef doesn&#39;t set refCount() to zero because it&#39;s not observable.
 730         // But we need to remember that our refCount reached zero in subsequent calls to decrementReferencingNodeCount().
 731         m_refCountAndParentBit = 0;
 732 
 733         // If removing a child removes the last node reference, we don&#39;t want the scope to be destroyed
 734         // until after removeDetachedChildren returns, so we protect ourselves.
 735         incrementReferencingNodeCount();
 736 
 737         RELEASE_ASSERT(!hasLivingRenderTree());
 738         // We must make sure not to be retaining any of our children through
 739         // these extra pointers or we will create a reference cycle.
 740         m_focusedElement = nullptr;
 741         m_hoveredElement = nullptr;
 742         m_activeElement = nullptr;
 743         m_titleElement = nullptr;
 744         m_documentElement = nullptr;
 745         m_focusNavigationStartingNode = nullptr;
 746         m_userActionElements.clear();
 747 #if ENABLE(FULLSCREEN_API)
 748         m_fullscreenManager-&gt;clear();
 749 #endif
 750         m_associatedFormControls.clear();
 751 
 752         m_fontSelector-&gt;clearDocument();
 753         m_fontSelector-&gt;unregisterForInvalidationCallbacks(*this);
 754 
 755         detachParser();
 756 
 757         // removeDetachedChildren() doesn&#39;t always unregister IDs,
 758         // so tear down scope information up front to avoid having
 759         // stale references in the map.
 760 
 761         destroyTreeScopeData();
 762         removeDetachedChildren();
 763         m_formController = nullptr;
 764 
 765         m_markers-&gt;detach();
 766 
 767         m_cssCanvasElements.clear();
 768 
 769         commonTeardown();
 770 
 771 #ifndef NDEBUG
 772         // We need to do this right now since selfOnlyDeref() can delete this.
 773         m_inRemovedLastRefFunction = false;
 774 #endif
 775         decrementReferencingNodeCount();
 776     } else {
 777         stopActiveDOMObjects();
 778 #ifndef NDEBUG
 779         m_inRemovedLastRefFunction = false;
 780         m_deletionHasBegun = true;
 781 #endif
 782         delete this;
 783     }
 784 }
 785 
 786 void Document::commonTeardown()
 787 {
 788     stopActiveDOMObjects();
 789 
 790 #if ENABLE(FULLSCREEN_API)
 791     m_fullscreenManager-&gt;emptyEventQueue();
 792 #endif
 793 
 794     if (svgExtensions())
 795         accessSVGExtensions().pauseAnimations();
 796 
 797     clearScriptedAnimationController();
 798 
 799     if (m_highlightMap)
 800         m_highlightMap-&gt;clear();
 801 
 802     m_pendingScrollEventTargetList = nullptr;
 803 }
 804 
 805 Element* Document::elementForAccessKey(const String&amp; key)
 806 {
 807     if (key.isEmpty())
 808         return nullptr;
 809     if (!m_accessKeyCache)
 810         buildAccessKeyCache();
 811     return m_accessKeyCache-&gt;get(key);
 812 }
 813 
 814 void Document::buildAccessKeyCache()
 815 {
 816     m_accessKeyCache = makeUnique&lt;HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt;&gt;([this] {
 817         HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt; map;
 818         for (auto&amp; node : composedTreeDescendants(*this)) {
 819             if (!is&lt;Element&gt;(node))
 820                 continue;
 821             auto&amp; element = downcast&lt;Element&gt;(node);
 822             auto&amp; key = element.attributeWithoutSynchronization(accesskeyAttr);
 823             if (key.isEmpty())
 824                 continue;
 825             map.add(key, &amp;element);
 826         }
 827         return map;
 828     }());
 829 }
 830 
 831 void Document::invalidateAccessKeyCacheSlowCase()
 832 {
 833     m_accessKeyCache = nullptr;
 834 }
 835 
 836 ExceptionOr&lt;SelectorQuery&amp;&gt; Document::selectorQueryForString(const String&amp; selectorString)
 837 {
 838     if (selectorString.isEmpty())
 839         return Exception { SyntaxError };
 840     if (!m_selectorQueryCache)
 841         m_selectorQueryCache = makeUnique&lt;SelectorQueryCache&gt;();
 842     return m_selectorQueryCache-&gt;add(selectorString, *this);
 843 }
 844 
 845 void Document::clearSelectorQueryCache()
 846 {
 847     m_selectorQueryCache = nullptr;
 848 }
 849 
 850 void Document::setReferrerPolicy(ReferrerPolicy referrerPolicy)
 851 {
 852     // Do not override existing referrer policy with the &quot;empty string&quot; one as the &quot;empty string&quot; means we should use
 853     // the policy defined elsewhere.
 854     if (m_referrerPolicy &amp;&amp; referrerPolicy == ReferrerPolicy::EmptyString)
 855         return;
 856 
 857     m_referrerPolicy = referrerPolicy;
 858 }
 859 
 860 MediaQueryMatcher&amp; Document::mediaQueryMatcher()
 861 {
 862     if (!m_mediaQueryMatcher)
 863         m_mediaQueryMatcher = MediaQueryMatcher::create(*this);
 864     return *m_mediaQueryMatcher;
 865 }
 866 
 867 void Document::setCompatibilityMode(DocumentCompatibilityMode mode)
 868 {
 869     if (m_compatibilityModeLocked || mode == m_compatibilityMode)
 870         return;
 871     bool wasInQuirksMode = inQuirksMode();
 872     m_compatibilityMode = mode;
 873 
 874     clearSelectorQueryCache();
 875 
 876     if (inQuirksMode() != wasInQuirksMode) {
 877         // All user stylesheets have to reparse using the different mode.
 878         extensionStyleSheets().clearPageUserSheet();
 879         extensionStyleSheets().invalidateInjectedStyleSheetCache();
 880     }
 881 }
 882 
 883 String Document::compatMode() const
 884 {
 885     return inQuirksMode() ? &quot;BackCompat&quot; : &quot;CSS1Compat&quot;;
 886 }
 887 
 888 void Document::resetLinkColor()
 889 {
 890     m_linkColor = StyleColor::colorFromKeyword(CSSValueWebkitLink, styleColorOptions(nullptr));
 891 }
 892 
 893 void Document::resetVisitedLinkColor()
 894 {
 895     m_visitedLinkColor = StyleColor::colorFromKeyword(CSSValueWebkitLink, styleColorOptions(nullptr) | StyleColor::Options::ForVisitedLink);
 896 }
 897 
 898 void Document::resetActiveLinkColor()
 899 {
 900     m_activeLinkColor = StyleColor::colorFromKeyword(CSSValueWebkitActivelink, styleColorOptions(nullptr));
 901 }
 902 
 903 DOMImplementation&amp; Document::implementation()
 904 {
 905     if (!m_implementation)
 906         m_implementation = makeUnique&lt;DOMImplementation&gt;(*this);
 907     return *m_implementation;
 908 }
 909 
 910 bool Document::hasManifest() const
 911 {
 912     return documentElement() &amp;&amp; documentElement()-&gt;hasTagName(htmlTag) &amp;&amp; documentElement()-&gt;hasAttributeWithoutSynchronization(manifestAttr);
 913 }
 914 
 915 DocumentType* Document::doctype() const
 916 {
 917     for (Node* node = firstChild(); node; node = node-&gt;nextSibling()) {
 918         if (is&lt;DocumentType&gt;(node))
 919             return downcast&lt;DocumentType&gt;(node);
 920     }
 921     return nullptr;
 922 }
 923 
 924 void Document::childrenChanged(const ChildChange&amp; change)
 925 {
 926     ContainerNode::childrenChanged(change);
 927 
 928     // FIXME: Chrome::didReceiveDocType() used to be called only when the doctype changed. We need to check the
 929     // impact of calling this systematically. If the overhead is negligible, we need to rename didReceiveDocType,
 930     // otherwise, we need to detect the doc type changes before updating the viewport.
 931     if (Page* page = this-&gt;page())
 932         page-&gt;chrome().didReceiveDocType(*frame());
 933 
 934     Element* newDocumentElement = childrenOfType&lt;Element&gt;(*this).first();
 935     if (newDocumentElement == m_documentElement)
 936         return;
 937     m_documentElement = newDocumentElement;
 938     // The root style used for media query matching depends on the document element.
 939     styleScope().clearResolver();
 940 }
 941 
 942 static ALWAYS_INLINE Ref&lt;HTMLElement&gt; createUpgradeCandidateElement(Document&amp; document, const QualifiedName&amp; name)
 943 {
 944     if (!RuntimeEnabledFeatures::sharedFeatures().customElementsEnabled()
 945         || Document::validateCustomElementName(name.localName()) != CustomElementNameValidationStatus::Valid)
 946         return HTMLUnknownElement::create(name, document);
 947 
 948     auto element = HTMLElement::create(name, document);
 949     element-&gt;setIsCustomElementUpgradeCandidate();
 950     return element;
 951 }
 952 
 953 static ALWAYS_INLINE Ref&lt;HTMLElement&gt; createUpgradeCandidateElement(Document&amp; document, const AtomString&amp; localName)
 954 {
 955     return createUpgradeCandidateElement(document, QualifiedName { nullAtom(), localName, xhtmlNamespaceURI });
 956 }
 957 
 958 static inline bool isValidHTMLElementName(const AtomString&amp; localName)
 959 {
 960     return Document::isValidName(localName);
 961 }
 962 
 963 static inline bool isValidHTMLElementName(const QualifiedName&amp; name)
 964 {
 965     return Document::isValidName(name.localName());
 966 }
 967 
 968 template&lt;typename NameType&gt;
 969 static ExceptionOr&lt;Ref&lt;Element&gt;&gt; createHTMLElementWithNameValidation(Document&amp; document, const NameType&amp; name)
 970 {
 971     auto element = HTMLElementFactory::createKnownElement(name, document);
 972     if (LIKELY(element))
 973         return Ref&lt;Element&gt; { element.releaseNonNull() };
 974 
 975     if (auto* window = document.domWindow()) {
 976         auto* registry = window-&gt;customElementRegistry();
 977         if (UNLIKELY(registry)) {
 978             if (auto* elementInterface = registry-&gt;findInterface(name))
 979                 return elementInterface-&gt;constructElementWithFallback(document, name);
 980         }
 981     }
 982 
 983     if (UNLIKELY(!isValidHTMLElementName(name)))
 984         return Exception { InvalidCharacterError };
 985 
 986     return Ref&lt;Element&gt; { createUpgradeCandidateElement(document, name) };
 987 }
 988 
 989 ExceptionOr&lt;Ref&lt;Element&gt;&gt; Document::createElementForBindings(const AtomString&amp; name)
 990 {
 991     if (isHTMLDocument())
 992         return createHTMLElementWithNameValidation(*this, name.convertToASCIILowercase());
 993 
 994     if (isXHTMLDocument())
 995         return createHTMLElementWithNameValidation(*this, name);
 996 
 997     if (!isValidName(name))
 998         return Exception { InvalidCharacterError };
 999 
1000     return createElement(QualifiedName(nullAtom(), name, nullAtom()), false);
1001 }
1002 
1003 Ref&lt;DocumentFragment&gt; Document::createDocumentFragment()
1004 {
1005     return DocumentFragment::create(document());
1006 }
1007 
1008 Ref&lt;Text&gt; Document::createTextNode(const String&amp; data)
1009 {
1010     return Text::create(*this, data);
1011 }
1012 
1013 Ref&lt;Comment&gt; Document::createComment(const String&amp; data)
1014 {
1015     return Comment::create(*this, data);
1016 }
1017 
1018 ExceptionOr&lt;Ref&lt;CDATASection&gt;&gt; Document::createCDATASection(const String&amp; data)
1019 {
1020     if (isHTMLDocument())
1021         return Exception { NotSupportedError };
1022     return CDATASection::create(*this, data);
1023 }
1024 
1025 ExceptionOr&lt;Ref&lt;ProcessingInstruction&gt;&gt; Document::createProcessingInstruction(const String&amp; target, const String&amp; data)
1026 {
1027     if (!isValidName(target))
1028         return Exception { InvalidCharacterError };
1029 
1030     if (data.contains(&quot;?&gt;&quot;))
1031         return Exception { InvalidCharacterError };
1032 
1033     return ProcessingInstruction::create(*this, target, data);
1034 }
1035 
1036 Ref&lt;Text&gt; Document::createEditingTextNode(const String&amp; text)
1037 {
1038     return Text::createEditingText(*this, text);
1039 }
1040 
1041 Ref&lt;CSSStyleDeclaration&gt; Document::createCSSStyleDeclaration()
1042 {
1043     Ref&lt;MutableStyleProperties&gt; propertySet(MutableStyleProperties::create());
1044     return propertySet-&gt;ensureCSSStyleDeclaration();
1045 }
1046 
1047 ExceptionOr&lt;Ref&lt;Node&gt;&gt; Document::importNode(Node&amp; nodeToImport, bool deep)
1048 {
1049     switch (nodeToImport.nodeType()) {
1050     case DOCUMENT_FRAGMENT_NODE:
1051         if (nodeToImport.isShadowRoot())
1052             break;
1053         FALLTHROUGH;
1054     case ELEMENT_NODE:
1055     case TEXT_NODE:
1056     case CDATA_SECTION_NODE:
1057     case PROCESSING_INSTRUCTION_NODE:
1058     case COMMENT_NODE:
1059         return nodeToImport.cloneNodeInternal(document(), deep ? CloningOperation::Everything : CloningOperation::OnlySelf);
1060 
1061     case ATTRIBUTE_NODE: {
1062         auto&amp; attribute = downcast&lt;Attr&gt;(nodeToImport);
1063         return Ref&lt;Node&gt; { Attr::create(*this, attribute.qualifiedName(), attribute.value()) };
1064     }
1065     case DOCUMENT_NODE: // Can&#39;t import a document into another document.
1066     case DOCUMENT_TYPE_NODE: // FIXME: Support cloning a DocumentType node per DOM4.
1067         break;
1068     }
1069 
1070     return Exception { NotSupportedError };
1071 }
1072 
1073 
1074 ExceptionOr&lt;Ref&lt;Node&gt;&gt; Document::adoptNode(Node&amp; source)
1075 {
1076     EventQueueScope scope;
1077 
1078     switch (source.nodeType()) {
1079     case DOCUMENT_NODE:
1080         return Exception { NotSupportedError };
1081     case ATTRIBUTE_NODE: {
1082         auto&amp; attr = downcast&lt;Attr&gt;(source);
1083         if (auto* element = attr.ownerElement()) {
1084             auto result = element-&gt;removeAttributeNode(attr);
1085             if (result.hasException())
1086                 return result.releaseException();
1087         }
1088         break;
1089     }
1090     default:
1091         if (source.isShadowRoot()) {
1092             // ShadowRoot cannot disconnect itself from the host node.
1093             return Exception { HierarchyRequestError };
1094         }
1095         if (is&lt;HTMLFrameOwnerElement&gt;(source)) {
1096             auto&amp; frameOwnerElement = downcast&lt;HTMLFrameOwnerElement&gt;(source);
1097             if (frame() &amp;&amp; frame()-&gt;tree().isDescendantOf(frameOwnerElement.contentFrame()))
1098                 return Exception { HierarchyRequestError };
1099         }
1100         auto result = source.remove();
1101         if (result.hasException())
1102             return result.releaseException();
1103         RELEASE_ASSERT(!source.isConnected());
1104         RELEASE_ASSERT(!source.parentNode());
1105     }
1106 
1107     source.setTreeScopeRecursively(*this);
1108 
1109     return Ref&lt;Node&gt; { source };
1110 }
1111 
1112 bool Document::hasValidNamespaceForElements(const QualifiedName&amp; qName)
1113 {
1114     // These checks are from DOM Core Level 2, createElementNS
1115     // http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-DocCrElNS
1116     if (!qName.prefix().isEmpty() &amp;&amp; qName.namespaceURI().isNull()) // createElementNS(null, &quot;html:div&quot;)
1117         return false;
1118     if (qName.prefix() == xmlAtom() &amp;&amp; qName.namespaceURI() != XMLNames::xmlNamespaceURI) // createElementNS(&quot;http://www.example.com&quot;, &quot;xml:lang&quot;)
1119         return false;
1120 
1121     // Required by DOM Level 3 Core and unspecified by DOM Level 2 Core:
1122     // http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-DocCrElNS
1123     // createElementNS(&quot;http://www.w3.org/2000/xmlns/&quot;, &quot;foo:bar&quot;), createElementNS(null, &quot;xmlns:bar&quot;), createElementNS(null, &quot;xmlns&quot;)
1124     if (qName.prefix() == xmlnsAtom() || (qName.prefix().isEmpty() &amp;&amp; qName.localName() == xmlnsAtom()))
1125         return qName.namespaceURI() == XMLNSNames::xmlnsNamespaceURI;
1126     return qName.namespaceURI() != XMLNSNames::xmlnsNamespaceURI;
1127 }
1128 
1129 bool Document::hasValidNamespaceForAttributes(const QualifiedName&amp; qName)
1130 {
1131     return hasValidNamespaceForElements(qName);
1132 }
1133 
1134 static Ref&lt;HTMLElement&gt; createFallbackHTMLElement(Document&amp; document, const QualifiedName&amp; name)
1135 {
1136     if (auto* window = document.domWindow()) {
1137         auto* registry = window-&gt;customElementRegistry();
1138         if (UNLIKELY(registry)) {
1139             if (auto* elementInterface = registry-&gt;findInterface(name)) {
1140                 auto element = HTMLElement::create(name, document);
1141                 element-&gt;enqueueToUpgrade(*elementInterface);
1142                 return element;
1143             }
1144         }
1145     }
1146     // FIXME: Should we also check the equality of prefix between the custom element and name?
1147     return createUpgradeCandidateElement(document, name);
1148 }
1149 
1150 // FIXME: This should really be in a possible ElementFactory class.
1151 Ref&lt;Element&gt; Document::createElement(const QualifiedName&amp; name, bool createdByParser)
1152 {
1153     RefPtr&lt;Element&gt; element;
1154 
1155     // FIXME: Use registered namespaces and look up in a hash to find the right factory.
1156     if (name.namespaceURI() == xhtmlNamespaceURI) {
1157         element = HTMLElementFactory::createKnownElement(name, *this, nullptr, createdByParser);
1158         if (UNLIKELY(!element))
1159             element = createFallbackHTMLElement(*this, name);
1160     } else if (name.namespaceURI() == SVGNames::svgNamespaceURI)
1161         element = SVGElementFactory::createElement(name, *this, createdByParser);
1162 #if ENABLE(MATHML)
1163     else if (name.namespaceURI() == MathMLNames::mathmlNamespaceURI)
1164         element = MathMLElementFactory::createElement(name, *this, createdByParser);
1165 #endif
1166 
1167     if (element)
1168         m_sawElementsInKnownNamespaces = true;
1169     else
1170         element = Element::create(name, document());
1171 
1172     // &lt;image&gt; uses imgTag so we need a special rule.
1173     ASSERT((name.matches(imageTag) &amp;&amp; element-&gt;tagQName().matches(imgTag) &amp;&amp; element-&gt;tagQName().prefix() == name.prefix()) || name == element-&gt;tagQName());
1174 
1175     return element.releaseNonNull();
1176 }
1177 
1178 // https://html.spec.whatwg.org/#valid-custom-element-name
1179 
1180 struct UnicodeCodePointRange {
1181     UChar32 minimum;
1182     UChar32 maximum;
1183 };
1184 
1185 #if ASSERT_ENABLED
1186 
1187 static inline bool operator&lt;(const UnicodeCodePointRange&amp; a, const UnicodeCodePointRange&amp; b)
1188 {
1189     ASSERT(a.minimum &lt;= a.maximum);
1190     ASSERT(b.minimum &lt;= b.maximum);
1191     return a.maximum &lt; b.minimum;
1192 }
1193 
1194 #endif // ASSERT_ENABLED
1195 
1196 static inline bool operator&lt;(const UnicodeCodePointRange&amp; a, UChar32 b)
1197 {
1198     ASSERT(a.minimum &lt;= a.maximum);
1199     return a.maximum &lt; b;
1200 }
1201 
1202 static inline bool operator&lt;(UChar32 a, const UnicodeCodePointRange&amp; b)
1203 {
1204     ASSERT(b.minimum &lt;= b.maximum);
1205     return a &lt; b.minimum;
1206 }
1207 
1208 static inline bool isPotentialCustomElementNameCharacter(UChar32 character)
1209 {
1210     static const UnicodeCodePointRange ranges[] = {
1211         { &#39;-&#39;, &#39;.&#39; },
1212         { &#39;0&#39;, &#39;9&#39; },
1213         { &#39;_&#39;, &#39;_&#39; },
1214         { &#39;a&#39;, &#39;z&#39; },
1215         { 0xB7, 0xB7 },
1216         { 0xC0, 0xD6 },
1217         { 0xD8, 0xF6 },
1218         { 0xF8, 0x37D },
1219         { 0x37F, 0x1FFF },
1220         { 0x200C, 0x200D },
1221         { 0x203F, 0x2040 },
1222         { 0x2070, 0x218F },
1223         { 0x2C00, 0x2FEF },
1224         { 0x3001, 0xD7FF },
1225         { 0xF900, 0xFDCF },
1226         { 0xFDF0, 0xFFFD },
1227         { 0x10000, 0xEFFFF },
1228     };
1229 
1230     ASSERT(std::is_sorted(std::begin(ranges), std::end(ranges)));
1231     return std::binary_search(std::begin(ranges), std::end(ranges), character);
1232 }
1233 
1234 CustomElementNameValidationStatus Document::validateCustomElementName(const AtomString&amp; localName)
1235 {
1236     if (!isASCIILower(localName[0]))
1237         return CustomElementNameValidationStatus::FirstCharacterIsNotLowercaseASCIILetter;
1238 
1239     bool containsHyphen = false;
1240     for (auto character : StringView(localName).codePoints()) {
1241         if (isASCIIUpper(character))
1242             return CustomElementNameValidationStatus::ContainsUppercaseASCIILetter;
1243         if (!isPotentialCustomElementNameCharacter(character))
1244             return CustomElementNameValidationStatus::ContainsDisallowedCharacter;
1245         if (character == &#39;-&#39;)
1246             containsHyphen = true;
1247     }
1248 
1249     if (!containsHyphen)
1250         return CustomElementNameValidationStatus::ContainsNoHyphen;
1251 
1252 #if ENABLE(MATHML)
1253     const auto&amp; annotationXmlLocalName = MathMLNames::annotation_xmlTag-&gt;localName();
1254 #else
1255     static NeverDestroyed&lt;const AtomString&gt; annotationXmlLocalName(&quot;annotation-xml&quot;, AtomString::ConstructFromLiteral);
1256 #endif
1257 
1258     if (localName == SVGNames::color_profileTag-&gt;localName()
1259         || localName == SVGNames::font_faceTag-&gt;localName()
1260         || localName == SVGNames::font_face_formatTag-&gt;localName()
1261         || localName == SVGNames::font_face_nameTag-&gt;localName()
1262         || localName == SVGNames::font_face_srcTag-&gt;localName()
1263         || localName == SVGNames::font_face_uriTag-&gt;localName()
1264         || localName == SVGNames::missing_glyphTag-&gt;localName()
1265         || localName == annotationXmlLocalName)
1266         return CustomElementNameValidationStatus::ConflictsWithStandardElementName;
1267 
1268     return CustomElementNameValidationStatus::Valid;
1269 }
1270 
1271 ExceptionOr&lt;Ref&lt;Element&gt;&gt; Document::createElementNS(const AtomString&amp; namespaceURI, const String&amp; qualifiedName)
1272 {
1273     auto parseResult = parseQualifiedName(namespaceURI, qualifiedName);
1274     if (parseResult.hasException())
1275         return parseResult.releaseException();
1276     QualifiedName parsedName { parseResult.releaseReturnValue() };
1277     if (!hasValidNamespaceForElements(parsedName))
1278         return Exception { NamespaceError };
1279 
1280     if (parsedName.namespaceURI() == xhtmlNamespaceURI)
1281         return createHTMLElementWithNameValidation(*this, parsedName);
1282 
1283     return createElement(parsedName, false);
1284 }
1285 
1286 void Document::setReadyState(ReadyState readyState)
1287 {
1288     if (readyState == m_readyState)
1289         return;
1290 
1291     switch (readyState) {
1292     case Loading:
1293         if (!m_documentTiming.domLoading)
1294             m_documentTiming.domLoading = MonotonicTime::now();
1295         break;
1296     case Interactive:
1297         if (!m_documentTiming.domInteractive)
1298             m_documentTiming.domInteractive = MonotonicTime::now();
1299         break;
1300     case Complete:
1301         if (!m_documentTiming.domComplete)
1302             m_documentTiming.domComplete = MonotonicTime::now();
1303         break;
1304     }
1305 
1306     m_readyState = readyState;
1307     dispatchEvent(Event::create(eventNames().readystatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
1308 
1309     if (settings().suppressesIncrementalRendering())
1310         setVisualUpdatesAllowed(readyState);
1311 }
1312 
1313 void Document::setVisualUpdatesAllowed(ReadyState readyState)
1314 {
1315     ASSERT(settings().suppressesIncrementalRendering());
1316     switch (readyState) {
1317     case Loading:
1318         ASSERT(!m_visualUpdatesSuppressionTimer.isActive());
1319         ASSERT(m_visualUpdatesAllowed);
1320         setVisualUpdatesAllowed(false);
1321         break;
1322     case Interactive:
1323         ASSERT(m_visualUpdatesSuppressionTimer.isActive() || m_visualUpdatesAllowed);
1324         break;
1325     case Complete:
1326         if (m_visualUpdatesSuppressionTimer.isActive()) {
1327             ASSERT(!m_visualUpdatesAllowed);
1328 
1329             if (view() &amp;&amp; !view()-&gt;visualUpdatesAllowedByClient())
1330                 return;
1331 
1332             setVisualUpdatesAllowed(true);
1333         } else
1334             ASSERT(m_visualUpdatesAllowed);
1335         break;
1336     }
1337 }
1338 
1339 void Document::setVisualUpdatesAllowed(bool visualUpdatesAllowed)
1340 {
1341     if (m_visualUpdatesAllowed == visualUpdatesAllowed)
1342         return;
1343 
1344     m_visualUpdatesAllowed = visualUpdatesAllowed;
1345 
1346     if (visualUpdatesAllowed)
1347         m_visualUpdatesSuppressionTimer.stop();
1348     else
1349         m_visualUpdatesSuppressionTimer.startOneShot(1_s * settings().incrementalRenderingSuppressionTimeoutInSeconds());
1350 
1351     if (!visualUpdatesAllowed)
1352         return;
1353 
1354     RefPtr&lt;FrameView&gt; frameView = view();
1355     bool needsLayout = frameView &amp;&amp; renderView() &amp;&amp; (frameView-&gt;layoutContext().isLayoutPending() || renderView()-&gt;needsLayout());
1356     if (needsLayout)
1357         updateLayout();
1358 
1359     if (Page* page = this-&gt;page()) {
1360         if (frame()-&gt;isMainFrame()) {
1361             frameView-&gt;addPaintPendingMilestones(DidFirstPaintAfterSuppressedIncrementalRendering);
1362             if (page-&gt;requestedLayoutMilestones() &amp; DidFirstLayoutAfterSuppressedIncrementalRendering)
1363                 frame()-&gt;loader().didReachLayoutMilestone(DidFirstLayoutAfterSuppressedIncrementalRendering);
1364         }
1365     }
1366 
1367     if (frameView)
1368         frameView-&gt;updateCompositingLayersAfterLayout();
1369 
1370     if (RenderView* renderView = this-&gt;renderView())
1371         renderView-&gt;repaintViewAndCompositedLayers();
1372 
1373     if (Frame* frame = this-&gt;frame())
1374         frame-&gt;loader().forcePageTransitionIfNeeded();
1375 }
1376 
1377 void Document::visualUpdatesSuppressionTimerFired()
1378 {
1379     ASSERT(!m_visualUpdatesAllowed);
1380 
1381     // If the client is extending the visual update suppression period explicitly, the
1382     // watchdog should not re-enable visual updates itself, but should wait for the client.
1383     if (view() &amp;&amp; !view()-&gt;visualUpdatesAllowedByClient())
1384         return;
1385 
1386     setVisualUpdatesAllowed(true);
1387 }
1388 
1389 void Document::setVisualUpdatesAllowedByClient(bool visualUpdatesAllowedByClient)
1390 {
1391     // We should only re-enable visual updates if ReadyState is Completed or the watchdog timer has fired,
1392     // both of which we can determine by looking at the timer.
1393 
1394     if (visualUpdatesAllowedByClient &amp;&amp; !m_visualUpdatesSuppressionTimer.isActive() &amp;&amp; !visualUpdatesAllowed())
1395         setVisualUpdatesAllowed(true);
1396 }
1397 
1398 String Document::characterSetWithUTF8Fallback() const
1399 {
1400     AtomString name = encoding();
1401     if (!name.isNull())
1402         return name;
1403     return UTF8Encoding().domName();
1404 }
1405 
1406 String Document::defaultCharsetForLegacyBindings() const
1407 {
1408     if (!frame())
1409         UTF8Encoding().domName();
1410     return settings().defaultTextEncodingName();
1411 }
1412 
1413 void Document::setCharset(const String&amp; charset)
1414 {
1415     if (!decoder())
1416         return;
1417     decoder()-&gt;setEncoding(charset, TextResourceDecoder::UserChosenEncoding);
1418 }
1419 
1420 void Document::setContentLanguage(const String&amp; language)
1421 {
1422     if (m_contentLanguage == language)
1423         return;
1424     m_contentLanguage = language;
1425 
1426     // Recalculate style so language is used when selecting the initial font.
1427     m_styleScope-&gt;didChangeStyleSheetEnvironment();
1428 }
1429 
1430 ExceptionOr&lt;void&gt; Document::setXMLVersion(const String&amp; version)
1431 {
1432     if (!XMLDocumentParser::supportsXMLVersion(version))
1433         return Exception { NotSupportedError };
1434 
1435     m_xmlVersion = version;
1436     return { };
1437 }
1438 
1439 void Document::setXMLStandalone(bool standalone)
1440 {
1441     m_xmlStandalone = standalone ? StandaloneStatus::Standalone : StandaloneStatus::NotStandalone;
1442 }
1443 
1444 void Document::setDocumentURI(const String&amp; uri)
1445 {
1446     // This property is read-only from JavaScript, but writable from Objective-C.
1447     m_documentURI = uri;
1448     updateBaseURL();
1449 }
1450 
1451 void Document::setContent(const String&amp; content)
1452 {
1453     open();
1454     // FIXME: This should probably use insert(), but that&#39;s (intentionally)
1455     // not implemented for the XML parser as it&#39;s normally synonymous with
1456     // document.write(). append() will end up yielding, but close() will
1457     // pump the tokenizer syncrhonously and finish the parse.
1458     m_parser-&gt;append(content.impl());
1459     close();
1460 }
1461 
1462 String Document::suggestedMIMEType() const
1463 {
1464     if (isXHTMLDocument())
1465         return &quot;application/xhtml+xml&quot;_s;
1466     if (isSVGDocument())
1467         return &quot;image/svg+xml&quot;_s;
1468     if (xmlStandalone())
1469         return &quot;text/xml&quot;_s;
1470     if (isHTMLDocument())
1471         return &quot;text/html&quot;_s;
1472     if (DocumentLoader* loader = this-&gt;loader())
1473         return loader-&gt;responseMIMEType();
1474     return String();
1475 }
1476 
1477 void Document::overrideMIMEType(const String&amp; mimeType)
1478 {
1479     m_overriddenMIMEType = mimeType;
1480 }
1481 
1482 String Document::contentType() const
1483 {
1484     if (!m_overriddenMIMEType.isNull())
1485         return m_overriddenMIMEType;
1486 
1487     if (DocumentLoader* documentLoader = loader())
1488         return documentLoader-&gt;currentContentType();
1489 
1490     String mimeType = suggestedMIMEType();
1491     if (!mimeType.isNull())
1492         return mimeType;
1493 
1494     return &quot;application/xml&quot;_s;
1495 }
1496 
1497 RefPtr&lt;Range&gt; Document::caretRangeFromPoint(int x, int y)
1498 {
1499     return caretRangeFromPoint(LayoutPoint(x, y));
1500 }
1501 
1502 RefPtr&lt;Range&gt; Document::caretRangeFromPoint(const LayoutPoint&amp; clientPoint)
1503 {
1504     if (!hasLivingRenderTree())
1505         return nullptr;
1506 
1507     LayoutPoint localPoint;
1508     Node* node = nodeFromPoint(clientPoint, &amp;localPoint);
1509     if (!node)
1510         return nullptr;
1511 
1512     RenderObject* renderer = node-&gt;renderer();
1513     if (!renderer)
1514         return nullptr;
1515     Position rangeCompliantPosition = renderer-&gt;positionForPoint(localPoint).parentAnchoredEquivalent();
1516     if (rangeCompliantPosition.isNull())
1517         return nullptr;
1518 
1519     unsigned offset = rangeCompliantPosition.offsetInContainerNode();
1520     node = &amp;retargetToScope(*rangeCompliantPosition.containerNode());
1521     if (node != rangeCompliantPosition.containerNode())
1522         offset = 0;
1523 
1524     return Range::create(*this, node, offset, node, offset);
1525 }
1526 
1527 bool Document::isBodyPotentiallyScrollable(HTMLBodyElement&amp; body)
1528 {
1529     // See https://www.w3.org/TR/cssom-view-1/#potentially-scrollable.
1530     // An element is potentially scrollable if all of the following conditions are true:
1531     // - The element has an associated CSS layout box.
1532     // - The element is not the HTML body element, or it is and the root element&#39;s used value of the
1533     //   overflow-x or overflow-y properties is not visible.
1534     // - The element&#39;s used value of the overflow-x or overflow-y properties is not visible.
1535     //
1536     // FIXME: We should use RenderObject::hasOverflowClip() instead of Element::computedStyle() but
1537     // the used values are currently not correctly updated. See https://webkit.org/b/182292.
1538     return body.renderer()
1539         &amp;&amp; documentElement()-&gt;computedStyle()
1540         &amp;&amp; !documentElement()-&gt;computedStyle()-&gt;isOverflowVisible()
1541         &amp;&amp; body.computedStyle()
1542         &amp;&amp; !body.computedStyle()-&gt;isOverflowVisible();
1543 }
1544 
1545 Element* Document::scrollingElementForAPI()
1546 {
1547     if (inQuirksMode() &amp;&amp; settings().CSSOMViewScrollingAPIEnabled())
1548         updateLayoutIgnorePendingStylesheets();
1549     return scrollingElement();
1550 }
1551 
1552 Element* Document::scrollingElement()
1553 {
1554     if (settings().CSSOMViewScrollingAPIEnabled()) {
1555         // See https://drafts.csswg.org/cssom-view/#dom-document-scrollingelement.
1556         // The scrollingElement attribute, on getting, must run these steps:
1557         // 1. If the Document is in quirks mode, follow these substeps:
1558         if (inQuirksMode()) {
1559             auto* firstBody = body();
1560             // 1. If the HTML body element exists, and it is not potentially scrollable, return the
1561             // HTML body element and abort these steps.
1562             if (firstBody &amp;&amp; !isBodyPotentiallyScrollable(*firstBody))
1563                 return firstBody;
1564 
1565             // 2. Return null and abort these steps.
1566             return nullptr;
1567         }
1568 
1569         // 2. If there is a root element, return the root element and abort these steps.
1570         // 3. Return null.
1571         return documentElement();
1572     }
1573 
1574     return body();
1575 }
1576 
1577 static String canonicalizedTitle(Document&amp; document, const String&amp; title)
1578 {
1579     // Collapse runs of HTML spaces into single space characters.
1580     // Strip leading and trailing spaces.
1581     // Replace backslashes with currency symbols.
1582 
1583     StringBuilder builder;
1584 
1585     auto* decoder = document.decoder();
1586     auto backslashAsCurrencySymbol = decoder ? decoder-&gt;encoding().backslashAsCurrencySymbol() : &#39;\\&#39;;
1587 
1588     bool previousCharacterWasHTMLSpace = false;
1589     for (auto character : StringView { title }.codeUnits()) {
1590         if (isHTMLSpace(character))
1591             previousCharacterWasHTMLSpace = true;
1592         else {
1593             if (character == &#39;\\&#39;)
1594                 character = backslashAsCurrencySymbol;
1595             if (previousCharacterWasHTMLSpace &amp;&amp; !builder.isEmpty())
1596                 builder.append(&#39; &#39;);
1597             builder.append(character);
1598             previousCharacterWasHTMLSpace = false;
1599         }
1600     }
1601 
1602     return builder == title ? title : builder.toString();
1603 }
1604 
1605 void Document::updateTitle(const StringWithDirection&amp; title)
1606 {
1607     if (m_rawTitle == title)
1608         return;
1609 
1610     m_rawTitle = title;
1611 
1612     m_title.string = canonicalizedTitle(*this, title.string);
1613     m_title.direction = title.direction;
1614 
1615     if (auto* loader = this-&gt;loader())
1616         loader-&gt;setTitle(m_title);
1617 }
1618 
1619 void Document::updateTitleFromTitleElement()
1620 {
1621     if (!m_titleElement) {
1622         updateTitle({ });
1623         return;
1624     }
1625 
1626     if (is&lt;HTMLTitleElement&gt;(*m_titleElement))
1627         updateTitle(downcast&lt;HTMLTitleElement&gt;(*m_titleElement).textWithDirection());
1628     else if (is&lt;SVGTitleElement&gt;(*m_titleElement)) {
1629         // FIXME: Does the SVG title element have a text direction?
1630         updateTitle({ downcast&lt;SVGTitleElement&gt;(*m_titleElement).textContent(), TextDirection::LTR });
1631     }
1632 }
1633 
1634 void Document::setTitle(const String&amp; title)
1635 {
1636     auto* element = documentElement();
1637     if (is&lt;SVGSVGElement&gt;(element)) {
1638         if (!m_titleElement) {
1639             m_titleElement = SVGTitleElement::create(SVGNames::titleTag, *this);
1640             element-&gt;insertBefore(*m_titleElement, element-&gt;firstChild());
1641         }
1642         // insertBefore above may have ran scripts which removed m_titleElement.
1643         if (m_titleElement)
1644             m_titleElement-&gt;setTextContent(title);
1645     } else if (is&lt;HTMLElement&gt;(element)) {
1646         if (!m_titleElement) {
1647             auto* headElement = head();
1648             if (!headElement)
1649                 return;
1650             m_titleElement = HTMLTitleElement::create(HTMLNames::titleTag, *this);
1651             headElement-&gt;appendChild(*m_titleElement);
1652         }
1653         // appendChild above may have ran scripts which removed m_titleElement.
1654         if (m_titleElement)
1655             m_titleElement-&gt;setTextContent(title);
1656     }
1657 }
1658 
1659 template&lt;typename&gt; struct TitleTraits;
1660 
1661 template&lt;&gt; struct TitleTraits&lt;HTMLTitleElement&gt; {
1662     static bool isInEligibleLocation(HTMLTitleElement&amp; element) { return element.isConnected() &amp;&amp; !element.isInShadowTree(); }
1663     static HTMLTitleElement* findTitleElement(Document&amp; document) { return descendantsOfType&lt;HTMLTitleElement&gt;(document).first(); }
1664 };
1665 
1666 template&lt;&gt; struct TitleTraits&lt;SVGTitleElement&gt; {
1667     static bool isInEligibleLocation(SVGTitleElement&amp; element) { return element.parentNode() == element.document().documentElement(); }
1668     static SVGTitleElement* findTitleElement(Document&amp; document) { return childrenOfType&lt;SVGTitleElement&gt;(*document.documentElement()).first(); }
1669 };
1670 
1671 template&lt;typename TitleElement&gt; Element* selectNewTitleElement(Document&amp; document, Element* oldTitleElement, Element&amp; changingTitleElement)
1672 {
1673     using Traits = TitleTraits&lt;TitleElement&gt;;
1674 
1675     if (!is&lt;TitleElement&gt;(changingTitleElement)) {
1676         ASSERT(oldTitleElement == Traits::findTitleElement(document));
1677         return oldTitleElement;
1678     }
1679 
1680     if (oldTitleElement)
1681         return Traits::findTitleElement(document);
1682 
1683     // Optimized common case: We have no title element yet.
1684     // We can figure out which title element should be used without searching.
1685     bool isEligible = Traits::isInEligibleLocation(downcast&lt;TitleElement&gt;(changingTitleElement));
1686     auto* newTitleElement = isEligible ? &amp;changingTitleElement : nullptr;
1687     ASSERT(newTitleElement == Traits::findTitleElement(document));
1688     return newTitleElement;
1689 }
1690 
1691 void Document::updateTitleElement(Element&amp; changingTitleElement)
1692 {
1693     // Most documents use HTML title rules.
1694     // Documents with SVG document elements use SVG title rules.
1695     auto selectTitleElement = is&lt;SVGSVGElement&gt;(documentElement())
1696         ? selectNewTitleElement&lt;SVGTitleElement&gt; : selectNewTitleElement&lt;HTMLTitleElement&gt;;
1697     auto newTitleElement = selectTitleElement(*this, m_titleElement.get(), changingTitleElement);
1698     if (m_titleElement == newTitleElement)
1699         return;
1700     m_titleElement = newTitleElement;
1701     updateTitleFromTitleElement();
1702 }
1703 
1704 void Document::titleElementAdded(Element&amp; titleElement)
1705 {
1706     if (m_titleElement == &amp;titleElement)
1707         return;
1708 
1709     updateTitleElement(titleElement);
1710 }
1711 
1712 void Document::titleElementRemoved(Element&amp; titleElement)
1713 {
1714     if (m_titleElement != &amp;titleElement)
1715         return;
1716 
1717     updateTitleElement(titleElement);
1718 }
1719 
1720 void Document::titleElementTextChanged(Element&amp; titleElement)
1721 {
1722     if (m_titleElement != &amp;titleElement)
1723         return;
1724 
1725     updateTitleFromTitleElement();
1726 }
1727 
1728 void Document::registerForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp; client)
1729 {
1730     m_visibilityStateCallbackClients.add(&amp;client);
1731 }
1732 
1733 void Document::unregisterForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp; client)
1734 {
1735     m_visibilityStateCallbackClients.remove(&amp;client);
1736 }
1737 
1738 void Document::visibilityStateChanged()
1739 {
1740     // // https://w3c.github.io/page-visibility/#reacting-to-visibilitychange-changes
1741     queueTaskToDispatchEvent(TaskSource::UserInteraction, Event::create(eventNames().visibilitychangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
1742     for (auto* client : m_visibilityStateCallbackClients)
1743         client-&gt;visibilityStateChanged();
1744 
1745 #if ENABLE(MEDIA_STREAM)
1746     if (auto* page = this-&gt;page())
1747         RealtimeMediaSourceCenter::singleton().setCapturePageState(hidden(), page-&gt;isMediaCaptureMuted());
1748 #endif
1749 }
1750 
1751 VisibilityState Document::visibilityState() const
1752 {
1753     // The visibility of the document is inherited from the visibility of the
1754     // page. If there is no page associated with the document, we will assume
1755     // that the page is hidden, as specified by the spec:
1756     // http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/PageVisibility/Overview.html#dom-document-hidden
1757     if (!m_frame || !m_frame-&gt;page())
1758         return VisibilityState::Hidden;
1759     return m_frame-&gt;page()-&gt;visibilityState();
1760 }
1761 
1762 bool Document::hidden() const
1763 {
1764     return visibilityState() != VisibilityState::Visible;
1765 }
1766 
1767 #if ENABLE(VIDEO)
1768 
1769 void Document::registerMediaElement(HTMLMediaElement&amp; element)
1770 {
1771     m_mediaElements.add(&amp;element);
1772 }
1773 
1774 void Document::unregisterMediaElement(HTMLMediaElement&amp; element)
1775 {
1776     m_mediaElements.remove(&amp;element);
1777 }
1778 
1779 void Document::forEachMediaElement(const Function&lt;void(HTMLMediaElement&amp;)&gt;&amp; function)
1780 {
1781     Vector&lt;Ref&lt;HTMLMediaElement&gt;&gt; elements;
1782     for (auto* element : m_mediaElements)
1783         elements.append(*element);
1784     for (auto&amp; element : elements)
1785         function(element);
1786 }
1787 
1788 void Document::stopAllMediaPlayback()
1789 {
1790     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1791         platformMediaSessionManager-&gt;stopAllMediaPlaybackForDocument(*this);
1792 }
1793 
1794 void Document::suspendAllMediaPlayback()
1795 {
1796     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1797         platformMediaSessionManager-&gt;suspendAllMediaPlaybackForDocument(*this);
1798 }
1799 
1800 void Document::resumeAllMediaPlayback()
1801 {
1802     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1803         platformMediaSessionManager-&gt;resumeAllMediaPlaybackForDocument(*this);
1804 }
1805 
1806 void Document::suspendAllMediaBuffering()
1807 {
1808     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1809         platformMediaSessionManager-&gt;suspendAllMediaBufferingForDocument(*this);
1810 }
1811 
1812 void Document::resumeAllMediaBuffering()
1813 {
1814     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1815         platformMediaSessionManager-&gt;resumeAllMediaBufferingForDocument(*this);
1816 }
1817 
1818 #endif
1819 
1820 String Document::nodeName() const
1821 {
1822     return &quot;#document&quot;_s;
1823 }
1824 
1825 Node::NodeType Document::nodeType() const
1826 {
1827     return DOCUMENT_NODE;
1828 }
1829 
1830 FormController&amp; Document::formController()
1831 {
1832     if (!m_formController)
1833         m_formController = makeUnique&lt;FormController&gt;();
1834     return *m_formController;
1835 }
1836 
1837 Vector&lt;String&gt; Document::formElementsState() const
1838 {
1839     if (!m_formController)
1840         return Vector&lt;String&gt;();
1841     return m_formController-&gt;formElementsState();
1842 }
1843 
1844 void Document::setStateForNewFormElements(const Vector&lt;String&gt;&amp; stateVector)
1845 {
1846     if (!stateVector.size() &amp;&amp; !m_formController)
1847         return;
1848     formController().setStateForNewFormElements(stateVector);
1849 }
1850 
1851 FrameView* Document::view() const
1852 {
1853     return m_frame ? m_frame-&gt;view() : nullptr;
1854 }
1855 
1856 Page* Document::page() const
1857 {
1858     return m_frame ? m_frame-&gt;page() : nullptr;
1859 }
1860 
1861 Ref&lt;Range&gt; Document::createRange()
1862 {
1863     return Range::create(*this);
1864 }
1865 
1866 Ref&lt;NodeIterator&gt; Document::createNodeIterator(Node&amp; root, unsigned long whatToShow, RefPtr&lt;NodeFilter&gt;&amp;&amp; filter, bool)
1867 {
1868     return NodeIterator::create(root, whatToShow, WTFMove(filter));
1869 }
1870 
1871 Ref&lt;TreeWalker&gt; Document::createTreeWalker(Node&amp; root, unsigned long whatToShow, RefPtr&lt;NodeFilter&gt;&amp;&amp; filter, bool)
1872 {
1873     return TreeWalker::create(root, whatToShow, WTFMove(filter));
1874 }
1875 
1876 void Document::scheduleFullStyleRebuild()
1877 {
1878     m_needsFullStyleRebuild = true;
1879     scheduleStyleRecalc();
1880 }
1881 
1882 void Document::scheduleStyleRecalc()
1883 {
1884     ASSERT(!m_renderView || !inHitTesting());
1885 
1886     if (m_styleRecalcTimer.isActive() || backForwardCacheState() != NotInBackForwardCache)
1887         return;
1888 
1889     ASSERT(childNeedsStyleRecalc() || m_needsFullStyleRebuild);
1890     auto shouldThrottleStyleRecalc = [&amp;] {
1891         if (!view() || !view()-&gt;isVisuallyNonEmpty())
1892             return false;
1893         if (!page() || !page()-&gt;chrome().client().layerFlushThrottlingIsActive())
1894             return false;
1895         return true;
1896     };
1897 
1898     if (shouldThrottleStyleRecalc())
1899         return;
1900 
1901     m_styleRecalcTimer.startOneShot(0_s);
1902 
1903     InspectorInstrumentation::didScheduleStyleRecalculation(*this);
1904 }
1905 
1906 void Document::unscheduleStyleRecalc()
1907 {
1908     ASSERT(!childNeedsStyleRecalc());
1909 
1910     m_styleRecalcTimer.stop();
1911     m_needsFullStyleRebuild = false;
1912 }
1913 
1914 bool Document::hasPendingStyleRecalc() const
1915 {
1916     return needsStyleRecalc() &amp;&amp; !m_inStyleRecalc;
1917 }
1918 
1919 bool Document::hasPendingFullStyleRebuild() const
1920 {
1921     return hasPendingStyleRecalc() &amp;&amp; m_needsFullStyleRebuild;
1922 }
1923 
1924 void Document::resolveStyle(ResolveStyleType type)
1925 {
1926     ASSERT(!view() || !view()-&gt;isPainting());
1927 
1928     // NOTE: XSL code seems to be the only client stumbling in here without a RenderView.
1929     if (!m_renderView)
1930         return;
1931 
1932     FrameView&amp; frameView = m_renderView-&gt;frameView();
1933     Ref&lt;FrameView&gt; protect(frameView);
1934     if (frameView.isPainting())
1935         return;
1936 
1937     if (m_inStyleRecalc)
1938         return; // Guard against re-entrancy. -dwh
1939 
1940     TraceScope tracingScope(StyleRecalcStart, StyleRecalcEnd);
1941 
1942     RenderView::RepaintRegionAccumulator repaintRegionAccumulator(renderView());
1943     AnimationUpdateBlock animationUpdateBlock(&amp;m_frame-&gt;animation());
1944 
1945     // FIXME: Do this update per tree scope.
1946     {
1947         auto elements = copyToVectorOf&lt;RefPtr&lt;SVGUseElement&gt;&gt;(m_svgUseElements);
1948         // We can&#39;t clear m_svgUseElements here because updateShadowTree may end up executing arbitrary scripts
1949         // which may insert new SVG use elements or remove existing ones inside sync IPC via ImageLoader::updateFromElement.
1950         for (auto&amp; element : elements)
1951             element-&gt;updateShadowTree();
1952     }
1953 
1954     // FIXME: We should update style on our ancestor chain before proceeding, however doing so at
1955     // the time this comment was originally written caused several tests to crash.
1956 
1957     {
1958         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
1959         styleScope().flushPendingUpdate();
1960         frameView.willRecalcStyle();
1961     }
1962 
1963     InspectorInstrumentation::willRecalculateStyle(*this);
1964 
1965     bool updatedCompositingLayers = false;
1966     {
1967         Style::PostResolutionCallbackDisabler disabler(*this);
1968         WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
1969         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
1970 
1971         m_inStyleRecalc = true;
1972 
1973         if (m_needsFullStyleRebuild)
1974             type = ResolveStyleType::Rebuild;
1975 
1976         if (type == ResolveStyleType::Rebuild) {
1977             // This may get set again during style resolve.
1978             m_hasNodesWithNonFinalStyle = false;
1979             m_hasNodesWithMissingStyle = false;
1980 
1981             auto documentStyle = Style::resolveForDocument(*this);
1982 
1983             // Inserting the pictograph font at the end of the font fallback list is done by the
1984             // font selector, so set a font selector if needed.
1985             if (settings().fontFallbackPrefersPictographs())
1986                 documentStyle.fontCascade().update(&amp;fontSelector());
1987 
1988             auto documentChange = Style::determineChange(documentStyle, m_renderView-&gt;style());
1989             if (documentChange != Style::NoChange)
1990                 renderView()-&gt;setStyle(WTFMove(documentStyle));
1991 
1992             if (auto* documentElement = this-&gt;documentElement())
1993                 documentElement-&gt;invalidateStyleForSubtree();
1994         }
1995 
1996         Style::TreeResolver resolver(*this);
1997         auto styleUpdate = resolver.resolve();
1998 
1999         m_lastStyleUpdateSizeForTesting = styleUpdate ? styleUpdate-&gt;size() : 0;
2000 
2001         setHasValidStyle();
2002         clearChildNeedsStyleRecalc();
2003         unscheduleStyleRecalc();
2004 
2005         m_inStyleRecalc = false;
2006 
2007         if (styleUpdate) {
2008             SetForScope&lt;bool&gt; inRenderTreeUpdate(m_inRenderTreeUpdate, true);
2009 
2010             RenderTreeUpdater updater(*this);
2011             updater.commit(WTFMove(styleUpdate));
2012 
2013             frameView.styleDidChange();
2014         }
2015 
2016         updatedCompositingLayers = frameView.updateCompositingLayersAfterStyleChange();
2017 
2018         if (m_renderView-&gt;needsLayout())
2019             frameView.layoutContext().scheduleLayout();
2020 
2021         // Usually this is handled by post-layout.
2022         if (!frameView.needsLayout())
2023             frameView.frame().selection().scheduleAppearanceUpdateAfterStyleChange();
2024 
2025         // As a result of the style recalculation, the currently hovered element might have been
2026         // detached (for example, by setting display:none in the :hover style), schedule another mouseMove event
2027         // to check if any other elements ended up under the mouse pointer due to re-layout.
2028         if (m_hoveredElement &amp;&amp; !m_hoveredElement-&gt;renderer())
2029             frameView.frame().mainFrame().eventHandler().dispatchFakeMouseMoveEventSoon();
2030 
2031         ++m_styleRecalcCount;
2032         // FIXME: Assert ASSERT(!needsStyleRecalc()) here. Do we still have some cases where it&#39;s not true?
2033     }
2034 
2035     InspectorInstrumentation::didRecalculateStyle(*this);
2036 
2037     // Some animated images may now be inside the viewport due to style recalc,
2038     // resume them if necessary if there is no layout pending. Otherwise, we&#39;ll
2039     // check if they need to be resumed after layout.
2040     if (updatedCompositingLayers &amp;&amp; !frameView.needsLayout())
2041         frameView.viewportContentsChanged();
2042 }
2043 
2044 void Document::updateTextRenderer(Text&amp; text, unsigned offsetOfReplacedText, unsigned lengthOfReplacedText)
2045 {
2046     ASSERT(!m_inRenderTreeUpdate);
2047     SetForScope&lt;bool&gt; inRenderTreeUpdate(m_inRenderTreeUpdate, true);
2048 
2049     auto textUpdate = makeUnique&lt;Style::Update&gt;(*this);
2050     textUpdate-&gt;addText(text, { offsetOfReplacedText, lengthOfReplacedText, WTF::nullopt });
2051 
2052     RenderTreeUpdater renderTreeUpdater(*this);
2053     renderTreeUpdater.commit(WTFMove(textUpdate));
2054 }
2055 
2056 bool Document::needsStyleRecalc() const
2057 {
2058     if (backForwardCacheState() != NotInBackForwardCache)
2059         return false;
2060 
2061     if (m_needsFullStyleRebuild)
2062         return true;
2063 
2064     if (childNeedsStyleRecalc())
2065         return true;
2066 
2067     if (styleScope().hasPendingUpdate())
2068         return true;
2069 
2070     return false;
2071 }
2072 
2073 static bool isSafeToUpdateStyleOrLayout(const Document&amp; document)
2074 {
2075     bool isSafeToExecuteScript = ScriptDisallowedScope::InMainThread::isScriptAllowed();
2076     auto* frameView = document.view();
2077     bool isInFrameFlattening = frameView &amp;&amp; frameView-&gt;isInChildFrameWithFrameFlattening();
2078     return isSafeToExecuteScript || isInFrameFlattening || !isInWebProcess();
2079 }
2080 
2081 bool Document::updateStyleIfNeeded()
2082 {
2083     RefPtr&lt;FrameView&gt; frameView = view();
2084     {
2085         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2086         ASSERT(isMainThread());
2087         ASSERT(!frameView || !frameView-&gt;isPainting());
2088 
2089         if (!frameView || frameView-&gt;layoutContext().isInRenderTreeLayout())
2090             return false;
2091 
2092         styleScope().flushPendingUpdate();
2093 
2094         if (!needsStyleRecalc())
2095             return false;
2096     }
2097 
2098 #if PLATFORM(IOS_FAMILY)
2099     ContentChangeObserver::StyleRecalcScope observingScope(*this);
2100 #endif
2101     // The early exit above for !needsStyleRecalc() is needed when updateWidgetPositions() is called in runOrScheduleAsynchronousTasks().
2102     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(isSafeToUpdateStyleOrLayout(*this));
2103     resolveStyle();
2104     return true;
2105 }
2106 
2107 void Document::updateLayout()
2108 {
2109     ASSERT(isMainThread());
2110 
2111     RefPtr&lt;FrameView&gt; frameView = view();
2112     if (frameView &amp;&amp; frameView-&gt;layoutContext().isInRenderTreeLayout()) {
2113         // View layout should not be re-entrant.
2114         ASSERT_NOT_REACHED();
2115         return;
2116     }
2117     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(isSafeToUpdateStyleOrLayout(*this));
2118 
2119     RenderView::RepaintRegionAccumulator repaintRegionAccumulator(renderView());
2120 
2121     if (HTMLFrameOwnerElement* owner = ownerElement())
2122         owner-&gt;document().updateLayout();
2123 
2124     updateStyleIfNeeded();
2125 
2126     StackStats::LayoutCheckPoint layoutCheckPoint;
2127 
2128     // Only do a layout if changes have occurred that make it necessary.
2129     if (frameView &amp;&amp; renderView() &amp;&amp; (frameView-&gt;layoutContext().isLayoutPending() || renderView()-&gt;needsLayout()))
2130         frameView-&gt;layoutContext().layout();
2131 }
2132 
2133 void Document::updateLayoutIgnorePendingStylesheets(Document::RunPostLayoutTasks runPostLayoutTasks)
2134 {
2135     bool oldIgnore = m_ignorePendingStylesheets;
2136 
2137     if (!haveStylesheetsLoaded()) {
2138         m_ignorePendingStylesheets = true;
2139         // FIXME: This should just invalidate elements with missing styles.
2140         if (m_hasNodesWithMissingStyle)
2141             scheduleFullStyleRebuild();
2142     }
2143 
2144     updateLayout();
2145 
2146     if (runPostLayoutTasks == RunPostLayoutTasks::Synchronously &amp;&amp; view())
2147         view()-&gt;flushAnyPendingPostLayoutTasks();
2148 
2149     m_ignorePendingStylesheets = oldIgnore;
2150 }
2151 
2152 std::unique_ptr&lt;RenderStyle&gt; Document::styleForElementIgnoringPendingStylesheets(Element&amp; element, const RenderStyle* parentStyle, PseudoId pseudoElementSpecifier)
2153 {
2154     ASSERT(&amp;element.document() == this);
2155     ASSERT(!element.isPseudoElement() || pseudoElementSpecifier == PseudoId::None);
2156     ASSERT(pseudoElementSpecifier == PseudoId::None || parentStyle);
2157 
2158     // On iOS request delegates called during styleForElement may result in re-entering WebKit and killing the style resolver.
2159     Style::PostResolutionCallbackDisabler disabler(*this, Style::PostResolutionCallbackDisabler::DrainCallbacks::No);
2160 
2161     SetForScope&lt;bool&gt; change(m_ignorePendingStylesheets, true);
2162     auto&amp; resolver = element.styleResolver();
2163 
2164     if (pseudoElementSpecifier != PseudoId::None)
2165         return resolver.pseudoStyleForElement(element, { pseudoElementSpecifier }, *parentStyle);
2166 
2167     auto elementStyle = resolver.styleForElement(element, parentStyle);
2168     if (elementStyle.relations) {
2169         Style::Update emptyUpdate(*this);
2170         Style::commitRelations(WTFMove(elementStyle.relations), emptyUpdate);
2171     }
2172 
2173     return WTFMove(elementStyle.renderStyle);
2174 }
2175 
2176 bool Document::updateLayoutIfDimensionsOutOfDate(Element&amp; element, DimensionsCheck dimensionsCheck)
2177 {
2178     ASSERT(isMainThread());
2179 
2180     // If the stylesheets haven&#39;t loaded, just give up and do a full layout ignoring pending stylesheets.
2181     if (!haveStylesheetsLoaded()) {
2182         updateLayoutIgnorePendingStylesheets();
2183         return true;
2184     }
2185 
2186     // Check for re-entrancy and assert (same code that is in updateLayout()).
2187     RefPtr&lt;FrameView&gt; frameView = view();
2188     if (frameView &amp;&amp; frameView-&gt;layoutContext().isInRenderTreeLayout()) {
2189         // View layout should not be re-entrant.
2190         ASSERT_NOT_REACHED();
2191         return true;
2192     }
2193 
2194     RenderView::RepaintRegionAccumulator repaintRegionAccumulator(renderView());
2195 
2196     // Mimic the structure of updateLayout(), but at each step, see if we have been forced into doing a full
2197     // layout.
2198     bool requireFullLayout = false;
2199     if (HTMLFrameOwnerElement* owner = ownerElement()) {
2200         if (owner-&gt;document().updateLayoutIfDimensionsOutOfDate(*owner))
2201             requireFullLayout = true;
2202     }
2203 
2204     updateStyleIfNeeded();
2205 
2206     RenderObject* renderer = element.renderer();
2207     if (!renderer || renderer-&gt;needsLayout()) {
2208         // If we don&#39;t have a renderer or if the renderer needs layout for any reason, give up.
2209         requireFullLayout = true;
2210     }
2211 
2212     // Turn off this optimization for input elements with shadow content.
2213     if (is&lt;HTMLInputElement&gt;(element))
2214         requireFullLayout = true;
2215 
2216     bool isVertical = renderer &amp;&amp; !renderer-&gt;isHorizontalWritingMode();
2217     bool checkingLogicalWidth = ((dimensionsCheck &amp; WidthDimensionsCheck) &amp;&amp; !isVertical) || ((dimensionsCheck &amp; HeightDimensionsCheck) &amp;&amp; isVertical);
2218     bool checkingLogicalHeight = ((dimensionsCheck &amp; HeightDimensionsCheck) &amp;&amp; !isVertical) || ((dimensionsCheck &amp; WidthDimensionsCheck) &amp;&amp; isVertical);
2219     bool hasSpecifiedLogicalHeight = renderer &amp;&amp; renderer-&gt;style().logicalMinHeight() == Length(0, Fixed) &amp;&amp; renderer-&gt;style().logicalHeight().isFixed() &amp;&amp; renderer-&gt;style().logicalMaxHeight().isAuto();
2220 
2221     if (!requireFullLayout) {
2222         RenderBox* previousBox = nullptr;
2223         RenderBox* currentBox = nullptr;
2224 
2225         // Check our containing block chain. If anything in the chain needs a layout, then require a full layout.
2226         for (RenderObject* currRenderer = element.renderer(); currRenderer &amp;&amp; !currRenderer-&gt;isRenderView(); currRenderer = currRenderer-&gt;container()) {
2227 
2228             // Require the entire container chain to be boxes.
2229             if (!is&lt;RenderBox&gt;(currRenderer)) {
2230                 requireFullLayout = true;
2231                 break;
2232             }
2233 
2234             previousBox = currentBox;
2235             currentBox = downcast&lt;RenderBox&gt;(currRenderer);
2236 
2237             // If a box needs layout for itself or if a box has changed children and sizes its width to
2238             // its content, then require a full layout.
2239             if (currentBox-&gt;selfNeedsLayout() ||
2240                 (checkingLogicalWidth &amp;&amp; currRenderer-&gt;needsLayout() &amp;&amp; currentBox-&gt;sizesLogicalWidthToFitContent(MainOrPreferredSize))) {
2241                 requireFullLayout = true;
2242                 break;
2243             }
2244 
2245             // If a block contains floats and the child&#39;s height isn&#39;t specified, then
2246             // give up also, since our height could end up being influenced by the floats.
2247             if (checkingLogicalHeight &amp;&amp; !hasSpecifiedLogicalHeight &amp;&amp; currentBox-&gt;isRenderBlockFlow()) {
2248                 RenderBlockFlow* currentBlockFlow = downcast&lt;RenderBlockFlow&gt;(currentBox);
2249                 if (currentBlockFlow-&gt;containsFloats() &amp;&amp; previousBox &amp;&amp; !previousBox-&gt;isFloatingOrOutOfFlowPositioned()) {
2250                     requireFullLayout = true;
2251                     break;
2252                 }
2253             }
2254 
2255             if (!currentBox-&gt;isRenderBlockFlow() || currentBox-&gt;enclosingFragmentedFlow() || currentBox-&gt;isWritingModeRoot()) {
2256                 // FIXME: For now require only block flows all the way back to the root. This limits the optimization
2257                 // for now, and we&#39;ll expand it in future patches to apply to more and more scenarios.
2258                 // Disallow columns from having the optimization.
2259                 // Give up if the writing mode changes at all in the containing block chain.
2260                 requireFullLayout = true;
2261                 break;
2262             }
2263 
2264             if (currRenderer == frameView-&gt;layoutContext().subtreeLayoutRoot())
2265                 break;
2266         }
2267     }
2268 
2269     StackStats::LayoutCheckPoint layoutCheckPoint;
2270 
2271     // Only do a layout if changes have occurred that make it necessary.
2272     if (requireFullLayout &amp;&amp; frameView &amp;&amp; renderView() &amp;&amp; (frameView-&gt;layoutContext().isLayoutPending() || renderView()-&gt;needsLayout()))
2273         frameView-&gt;layoutContext().layout();
2274 
2275     return requireFullLayout;
2276 }
2277 
2278 bool Document::isPageBoxVisible(int pageIndex)
2279 {
2280     updateStyleIfNeeded();
2281     std::unique_ptr&lt;RenderStyle&gt; pageStyle(styleScope().resolver().styleForPage(pageIndex));
2282     return pageStyle-&gt;visibility() != Visibility::Hidden; // display property doesn&#39;t apply to @page.
2283 }
2284 
2285 void Document::pageSizeAndMarginsInPixels(int pageIndex, IntSize&amp; pageSize, int&amp; marginTop, int&amp; marginRight, int&amp; marginBottom, int&amp; marginLeft)
2286 {
2287     updateStyleIfNeeded();
2288     auto style = styleScope().resolver().styleForPage(pageIndex);
2289 
2290     int width = pageSize.width();
2291     int height = pageSize.height();
2292     switch (style-&gt;pageSizeType()) {
2293     case PAGE_SIZE_AUTO:
2294         break;
2295     case PAGE_SIZE_AUTO_LANDSCAPE:
2296         if (width &lt; height)
2297             std::swap(width, height);
2298         break;
2299     case PAGE_SIZE_AUTO_PORTRAIT:
2300         if (width &gt; height)
2301             std::swap(width, height);
2302         break;
2303     case PAGE_SIZE_RESOLVED: {
2304         auto&amp; size = style-&gt;pageSize();
2305         ASSERT(size.width.isFixed());
2306         ASSERT(size.height.isFixed());
2307         width = valueForLength(size.width, 0);
2308         height = valueForLength(size.height, 0);
2309         break;
2310     }
2311     default:
2312         ASSERT_NOT_REACHED();
2313     }
2314     pageSize = IntSize(width, height);
2315 
2316     // The percentage is calculated with respect to the width even for margin top and bottom.
2317     // http://www.w3.org/TR/CSS2/box.html#margin-properties
2318     marginTop = style-&gt;marginTop().isAuto() ? marginTop : intValueForLength(style-&gt;marginTop(), width);
2319     marginRight = style-&gt;marginRight().isAuto() ? marginRight : intValueForLength(style-&gt;marginRight(), width);
2320     marginBottom = style-&gt;marginBottom().isAuto() ? marginBottom : intValueForLength(style-&gt;marginBottom(), width);
2321     marginLeft = style-&gt;marginLeft().isAuto() ? marginLeft : intValueForLength(style-&gt;marginLeft(), width);
2322 }
2323 
2324 Style::Resolver&amp; Document::userAgentShadowTreeStyleResolver()
2325 {
2326     if (!m_userAgentShadowTreeStyleResolver)
2327         m_userAgentShadowTreeStyleResolver = makeUnique&lt;Style::Resolver&gt;(*this);
2328     return *m_userAgentShadowTreeStyleResolver;
2329 }
2330 
2331 void Document::fontsNeedUpdate(FontSelector&amp;)
2332 {
2333     invalidateMatchedPropertiesCacheAndForceStyleRecalc();
2334 }
2335 
2336 void Document::invalidateMatchedPropertiesCacheAndForceStyleRecalc()
2337 {
2338     styleScope().invalidateMatchedDeclarationsCache();
2339 
2340     if (backForwardCacheState() != NotInBackForwardCache || !renderView())
2341         return;
2342     scheduleFullStyleRebuild();
2343 }
2344 
2345 void Document::didClearStyleResolver()
2346 {
2347     m_userAgentShadowTreeStyleResolver = nullptr;
2348 }
2349 
2350 void Document::setIsResolvingTreeStyle(bool value)
2351 {
2352     RELEASE_ASSERT(value != m_isResolvingTreeStyle);
2353     m_isResolvingTreeStyle = value;
2354 }
2355 
2356 void Document::createRenderTree()
2357 {
2358     ASSERT(!renderView());
2359     ASSERT(m_backForwardCacheState != InBackForwardCache);
2360     ASSERT(!m_axObjectCache || this != &amp;topDocument());
2361 
2362     if (m_isNonRenderedPlaceholder)
2363         return;
2364 
2365     // FIXME: It would be better if we could pass the resolved document style directly here.
2366     m_renderView = createRenderer&lt;RenderView&gt;(*this, RenderStyle::create());
2367     Node::setRenderer(m_renderView.get());
2368 
2369     renderView()-&gt;setIsInWindow(true);
2370 
2371     resolveStyle(ResolveStyleType::Rebuild);
2372 }
2373 
2374 void Document::didBecomeCurrentDocumentInFrame()
2375 {
2376     // FIXME: Are there cases where the document can be dislodged from the frame during the event handling below?
2377     // If so, then m_frame could become 0, and we need to do something about that.
2378 
2379     m_frame-&gt;script().updateDocument();
2380 
2381     if (!hasLivingRenderTree())
2382         createRenderTree();
2383 
2384     dispatchDisabledAdaptationsDidChangeForMainFrame();
2385     updateViewportArguments();
2386 
2387     // FIXME: Doing this only for the main frame is insufficient.
2388     // Changing a subframe can also change the wheel event handler count.
2389     // FIXME: Doing this only when a document goes into the frame is insufficient.
2390     // Removing a document can also change the wheel event handler count.
2391     // FIXME: Doing this every time is a waste. If the current document and its
2392     // subframes&#39; documents have no wheel event handlers, then the count did not change,
2393     // unless the documents they are replacing had wheel event handlers.
2394     if (page() &amp;&amp; m_frame-&gt;isMainFrame())
2395         wheelEventHandlersChanged();
2396 
2397     // Ensure that the scheduled task state of the document matches the DOM suspension state of the frame. It can
2398     // be out of sync if the DOM suspension state changed while the document was not in the frame (possibly in the
2399     // back/forward cache, or simply newly created).
2400     if (m_frame-&gt;activeDOMObjectsAndAnimationsSuspended()) {
2401         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
2402             if (auto* timeline = existingTimeline())
2403                 timeline-&gt;suspendAnimations();
2404         } else
2405             m_frame-&gt;animation().suspendAnimationsForDocument(this);
2406         suspendScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
2407     } else {
2408         resumeScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
2409         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
2410             if (auto* timeline = existingTimeline())
2411                 timeline-&gt;resumeAnimations();
2412         } else
2413             m_frame-&gt;animation().resumeAnimationsForDocument(this);
2414     }
2415 }
2416 
2417 void Document::frameDestroyed()
2418 {
2419     // detachFromFrame() must be called before destroying the Frame.
2420     RELEASE_ASSERT(!m_frame);
2421 
2422     if (auto* window = domWindow())
2423         window-&gt;frameDestroyed();
2424 
2425     FrameDestructionObserver::frameDestroyed();
2426 }
2427 
2428 void Document::willDetachPage()
2429 {
2430     FrameDestructionObserver::willDetachPage();
2431 #if PLATFORM(IOS_FAMILY)
2432     contentChangeObserver().willDetachPage();
2433 #endif
2434     if (domWindow() &amp;&amp; frame())
2435         InspectorInstrumentation::frameWindowDiscarded(*frame(), domWindow());
2436 }
2437 
2438 void Document::attachToCachedFrame(CachedFrameBase&amp; cachedFrame)
2439 {
2440     RELEASE_ASSERT(cachedFrame.document() == this);
2441     ASSERT(cachedFrame.view());
2442     ASSERT(m_backForwardCacheState == Document::InBackForwardCache);
2443     observeFrame(&amp;cachedFrame.view()-&gt;frame());
2444 }
2445 
2446 void Document::detachFromCachedFrame(CachedFrameBase&amp; cachedFrame)
2447 {
2448     ASSERT_UNUSED(cachedFrame, cachedFrame.view());
2449     RELEASE_ASSERT(cachedFrame.document() == this);
2450     ASSERT(m_frame == &amp;cachedFrame.view()-&gt;frame());
2451     ASSERT(m_backForwardCacheState == Document::InBackForwardCache);
2452     detachFromFrame();
2453 }
2454 
2455 void Document::destroyRenderTree()
2456 {
2457     ASSERT(hasLivingRenderTree());
2458     ASSERT(frame());
2459     ASSERT(frame()-&gt;document() == this);
2460     ASSERT(page());
2461 
2462     // Prevent Widget tree changes from committing until the RenderView is dead and gone.
2463     WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
2464 
2465     SetForScope&lt;bool&gt; change(m_renderTreeBeingDestroyed, true);
2466 
2467     if (this == &amp;topDocument())
2468         clearAXObjectCache();
2469 
2470     documentWillBecomeInactive();
2471 
2472     if (view())
2473         view()-&gt;willDestroyRenderTree();
2474 
2475     if (m_documentElement)
2476         RenderTreeUpdater::tearDownRenderers(*m_documentElement);
2477 
2478     clearChildNeedsStyleRecalc();
2479 
2480     unscheduleStyleRecalc();
2481 
2482     // FIXME: RenderObject::view() uses m_renderView and we can&#39;t null it before destruction is completed
2483     {
2484         RenderTreeBuilder builder(*m_renderView);
2485         // FIXME: This is a workaround for leftover content (see webkit.org/b/182547).
2486         while (m_renderView-&gt;firstChild())
2487             builder.destroy(*m_renderView-&gt;firstChild());
2488         m_renderView-&gt;destroy();
2489     }
2490     m_renderView.release();
2491 
2492     Node::setRenderer(nullptr);
2493 
2494 #if ENABLE(TEXT_AUTOSIZING)
2495     m_textAutoSizing = nullptr;
2496 #endif
2497 
2498     if (view())
2499         view()-&gt;didDestroyRenderTree();
2500 }
2501 
2502 void Document::prepareForDestruction()
2503 {
2504     if (m_hasPreparedForDestruction)
2505         return;
2506 
2507     if (m_frame)
2508         m_frame-&gt;animation().detachFromDocument(this);
2509 
2510 #if USE(LIBWEBRTC)
2511     // FIXME: This should be moved to Modules/mediastream.
2512     if (LibWebRTCProvider::webRTCAvailable()) {
2513         if (auto* page = this-&gt;page())
2514             page-&gt;libWebRTCProvider().unregisterMDNSNames(identifier().toUInt64());
2515     }
2516 #endif
2517 
2518 #if ENABLE(SERVICE_WORKER)
2519     setActiveServiceWorker(nullptr);
2520     setServiceWorkerConnection(nullptr);
2521 #endif
2522 
2523 #if ENABLE(IOS_TOUCH_EVENTS)
2524     clearTouchEventHandlersAndListeners();
2525 #endif
2526 
2527     m_undoManager-&gt;removeAllItems();
2528 
2529     m_textManipulationController = nullptr; // Free nodes kept alive by TextManipulationController.
2530 
2531 #if ENABLE(ACCESSIBILITY)
2532     if (this != &amp;topDocument()) {
2533         // Let the ax cache know that this subframe goes out of scope.
2534         if (auto* cache = existingAXObjectCache())
2535             cache-&gt;prepareForDocumentDestruction(*this);
2536     }
2537 #endif
2538 
2539     {
2540         NavigationDisabler navigationDisabler(m_frame);
2541         disconnectDescendantFrames();
2542     }
2543     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!m_frame || !m_frame-&gt;tree().childCount());
2544 
2545     if (m_domWindow &amp;&amp; m_frame)
2546         m_domWindow-&gt;willDetachDocumentFromFrame();
2547 
2548     styleScope().clearResolver();
2549 
2550     if (hasLivingRenderTree())
2551         destroyRenderTree();
2552 
2553     if (is&lt;PluginDocument&gt;(*this))
2554         downcast&lt;PluginDocument&gt;(*this).detachFromPluginElement();
2555 
2556 #if ENABLE(POINTER_LOCK)
2557     if (page())
2558         page()-&gt;pointerLockController().documentDetached(*this);
2559 #endif
2560 
2561     if (auto* page = this-&gt;page()) {
2562         if (auto* validationMessageClient = page-&gt;validationMessageClient())
2563             validationMessageClient-&gt;documentDetached(*this);
2564     }
2565 
2566     InspectorInstrumentation::documentDetached(*this);
2567 
2568     commonTeardown();
2569 
2570 #if ENABLE(TOUCH_EVENTS)
2571     if (m_touchEventTargets &amp;&amp; m_touchEventTargets-&gt;size() &amp;&amp; parentDocument())
2572         parentDocument()-&gt;didRemoveEventTargetNode(*this);
2573 #endif
2574 
2575     if (m_wheelEventTargets &amp;&amp; m_wheelEventTargets-&gt;size() &amp;&amp; parentDocument())
2576         parentDocument()-&gt;didRemoveEventTargetNode(*this);
2577 
2578     if (m_mediaQueryMatcher)
2579         m_mediaQueryMatcher-&gt;documentDestroyed();
2580 
2581 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
2582     if (!m_clientToIDMap.isEmpty() &amp;&amp; page()) {
2583         for (auto* client : copyToVector(m_clientToIDMap.keys()))
2584             removePlaybackTargetPickerClient(*client);
2585     }
2586 #endif
2587 
2588     m_cachedResourceLoader-&gt;stopUnusedPreloadsTimer();
2589 
2590     if (page() &amp;&amp; m_mediaState != MediaProducer::IsNotPlaying) {
2591         m_mediaState = MediaProducer::IsNotPlaying;
2592         page()-&gt;updateIsPlayingMedia(HTMLMediaElementInvalidID);
2593     }
2594 
2595     detachFromFrame();
2596 
2597     while (!m_timelines.computesEmpty())
2598         m_timelines.begin()-&gt;detachFromDocument();
2599     m_timeline = nullptr;
2600 
2601 #if ENABLE(CSS_PAINTING_API)
2602     for (auto&amp; scope : m_paintWorkletGlobalScopes.values())
2603         scope-&gt;prepareForDestruction();
2604     m_paintWorkletGlobalScopes.clear();
2605 #endif
2606 
2607     m_hasPreparedForDestruction = true;
2608 
2609     // Note that m_backForwardCacheState can be Document::AboutToEnterBackForwardCache if our frame
2610     // was removed in an onpagehide event handler fired when the top-level frame is
2611     // about to enter the back/forward cache.
2612     RELEASE_ASSERT(m_backForwardCacheState != Document::InBackForwardCache);
2613 }
2614 
2615 void Document::removeAllEventListeners()
2616 {
2617     EventTarget::removeAllEventListeners();
2618 
2619     if (m_domWindow)
2620         m_domWindow-&gt;removeAllEventListeners();
2621 
2622 #if ENABLE(IOS_TOUCH_EVENTS)
2623     clearTouchEventHandlersAndListeners();
2624 #endif
2625     for (Node* node = firstChild(); node; node = NodeTraversal::next(*node))
2626         node-&gt;removeAllEventListeners();
2627 
2628 #if ENABLE(TOUCH_EVENTS)
2629     m_touchEventTargets = nullptr;
2630 #endif
2631     m_wheelEventTargets = nullptr;
2632 }
2633 
2634 void Document::suspendDeviceMotionAndOrientationUpdates()
2635 {
2636     if (m_areDeviceMotionAndOrientationUpdatesSuspended)
2637         return;
2638     m_areDeviceMotionAndOrientationUpdatesSuspended = true;
2639 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
2640     if (m_deviceMotionController)
2641         m_deviceMotionController-&gt;suspendUpdates();
2642     if (m_deviceOrientationController)
2643         m_deviceOrientationController-&gt;suspendUpdates();
2644 #endif
2645 }
2646 
2647 void Document::resumeDeviceMotionAndOrientationUpdates()
2648 {
2649     if (!m_areDeviceMotionAndOrientationUpdatesSuspended)
2650         return;
2651     m_areDeviceMotionAndOrientationUpdatesSuspended = false;
2652 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
2653     if (m_deviceMotionController)
2654         m_deviceMotionController-&gt;resumeUpdates();
2655     if (m_deviceOrientationController)
2656         m_deviceOrientationController-&gt;resumeUpdates();
2657 #endif
2658 }
2659 
2660 bool Document::shouldBypassMainWorldContentSecurityPolicy() const
2661 {
2662     // Bypass this policy when the world is known, and it not the normal world.
2663     JSC::VM&amp; vm = commonVM();
2664     auto&amp; callFrame = *vm.topCallFrame;
2665     return &amp;callFrame != JSC::CallFrame::noCaller() &amp;&amp; !currentWorld(*callFrame.lexicalGlobalObject(vm)).isNormal();
2666 }
2667 
2668 void Document::platformSuspendOrStopActiveDOMObjects()
2669 {
2670 #if PLATFORM(IOS_FAMILY)
2671     contentChangeObserver().didSuspendActiveDOMObjects();
2672 #endif
2673 }
2674 
2675 void Document::suspendActiveDOMObjects(ReasonForSuspension why)
2676 {
2677     if (m_documentTaskGroup)
2678         m_documentTaskGroup-&gt;suspend();
2679     ScriptExecutionContext::suspendActiveDOMObjects(why);
2680     suspendDeviceMotionAndOrientationUpdates();
2681     platformSuspendOrStopActiveDOMObjects();
2682 }
2683 
2684 void Document::resumeActiveDOMObjects(ReasonForSuspension why)
2685 {
2686     if (m_documentTaskGroup)
2687         m_documentTaskGroup-&gt;resume();
2688     ScriptExecutionContext::resumeActiveDOMObjects(why);
2689     resumeDeviceMotionAndOrientationUpdates();
2690     // FIXME: For iOS, do we need to add content change observers that were removed in Document::suspendActiveDOMObjects()?
2691 }
2692 
2693 void Document::stopActiveDOMObjects()
2694 {
2695     if (m_documentTaskGroup)
2696         m_documentTaskGroup-&gt;stopAndDiscardAllTasks();
2697     ScriptExecutionContext::stopActiveDOMObjects();
2698     platformSuspendOrStopActiveDOMObjects();
2699 }
2700 
2701 void Document::clearAXObjectCache()
2702 {
2703     ASSERT(&amp;topDocument() == this);
2704     // Clear the cache member variable before calling delete because attempts
2705     // are made to access it during destruction.
2706     m_axObjectCache = nullptr;
2707 }
2708 
2709 AXObjectCache* Document::existingAXObjectCacheSlow() const
2710 {
2711     ASSERT(hasEverCreatedAnAXObjectCache);
2712     return topDocument().m_axObjectCache.get();
2713 }
2714 
2715 AXObjectCache* Document::axObjectCache() const
2716 {
2717     if (!AXObjectCache::accessibilityEnabled())
2718         return nullptr;
2719 
2720     // The only document that actually has a AXObjectCache is the top-level
2721     // document.  This is because we need to be able to get from any WebCoreAXObject
2722     // to any other WebCoreAXObject on the same page.  Using a single cache allows
2723     // lookups across nested webareas (i.e. multiple documents).
2724     Document&amp; topDocument = this-&gt;topDocument();
2725 
2726     // If the document has already been detached, do not make a new axObjectCache.
2727     if (!topDocument.hasLivingRenderTree())
2728         return nullptr;
2729 
2730     ASSERT(&amp;topDocument == this || !m_axObjectCache);
2731     if (!topDocument.m_axObjectCache) {
2732         topDocument.m_axObjectCache = makeUnique&lt;AXObjectCache&gt;(topDocument);
2733         hasEverCreatedAnAXObjectCache = true;
2734     }
2735     return topDocument.m_axObjectCache.get();
2736 }
2737 
2738 void Document::setVisuallyOrdered()
2739 {
2740     m_visuallyOrdered = true;
2741     if (renderView())
2742         renderView()-&gt;mutableStyle().setRTLOrdering(Order::Visual);
2743 }
2744 
2745 Ref&lt;DocumentParser&gt; Document::createParser()
2746 {
2747     // FIXME: this should probably pass the frame instead
2748     return XMLDocumentParser::create(*this, view());
2749 }
2750 
2751 HighlightMap&amp; Document::highlightMap()
2752 {
2753     if (!m_highlightMap)
2754         m_highlightMap = HighlightMap::create();
2755     return *m_highlightMap;
2756 }
2757 
2758 void Document::updateHighlightPositions()
2759 {
2760     Vector&lt;WeakPtr&lt;HighlightRangeData&gt;&gt; rangesData;
2761     if (m_highlightMap) {
2762         for (auto&amp; highlight : m_highlightMap-&gt;map()) {
2763             for (auto&amp; rangeData : highlight.value-&gt;rangesData()) {
2764                 if (rangeData-&gt;startPosition &amp;&amp; rangeData-&gt;endPosition)
2765                     continue;
2766                 if (&amp;rangeData-&gt;range-&gt;startContainer()-&gt;treeScope() != &amp;rangeData-&gt;range-&gt;endContainer()-&gt;treeScope())
2767                     continue;
2768                 rangesData.append(makeWeakPtr(rangeData.ptr()));
2769             }
2770         }
2771     }
2772 
2773     for (auto&amp; weakRangeData : rangesData) {
2774         if (auto* rangeData = weakRangeData.get()) {
2775             VisibleSelection visibleSelection(rangeData-&gt;range);
2776             Position startPosition;
2777             Position endPosition;
2778             if (!rangeData-&gt;startPosition.hasValue())
2779                 startPosition = visibleSelection.visibleStart().deepEquivalent();
2780             if (!rangeData-&gt;endPosition.hasValue())
2781                 endPosition = visibleSelection.visibleEnd().deepEquivalent(); // &lt;MMG&gt; switch to END
2782             if (!weakRangeData.get())
2783                 continue;
2784 
2785             rangeData-&gt;startPosition = startPosition;
2786             rangeData-&gt;endPosition = endPosition;
2787         }
2788     }
2789 }
2790 
2791 ScriptableDocumentParser* Document::scriptableDocumentParser() const
2792 {
2793     return parser() ? parser()-&gt;asScriptableDocumentParser() : nullptr;
2794 }
2795 
2796 ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; Document::openForBindings(DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const String&amp; url, const AtomString&amp; name, const String&amp; features)
2797 {
2798     if (!m_domWindow)
2799         return Exception { InvalidAccessError };
2800 
2801     return m_domWindow-&gt;open(activeWindow, firstWindow, url, name, features);
2802 }
2803 
2804 ExceptionOr&lt;Document&amp;&gt; Document::openForBindings(Document* responsibleDocument, const String&amp;, const String&amp;)
2805 {
2806     if (!isHTMLDocument() || m_throwOnDynamicMarkupInsertionCount)
2807         return Exception { InvalidStateError };
2808 
2809     auto result = open(responsibleDocument);
2810     if (UNLIKELY(result.hasException()))
2811         return result.releaseException();
2812 
2813     return *this;
2814 }
2815 
2816 ExceptionOr&lt;void&gt; Document::open(Document* responsibleDocument)
2817 {
2818     if (responsibleDocument &amp;&amp; !responsibleDocument-&gt;securityOrigin().isSameOriginAs(securityOrigin()))
2819         return Exception { SecurityError };
2820 
2821     if (m_ignoreOpensDuringUnloadCount)
2822         return { };
2823 
2824     if (m_activeParserWasAborted)
2825         return { };
2826 
2827     if (m_frame) {
2828         if (ScriptableDocumentParser* parser = scriptableDocumentParser()) {
2829             if (parser-&gt;isParsing()) {
2830                 // FIXME: HTML5 doesn&#39;t tell us to check this, it might not be correct.
2831                 if (parser-&gt;isExecutingScript())
2832                     return { };
2833 
2834                 if (!parser-&gt;wasCreatedByScript() &amp;&amp; parser-&gt;hasInsertionPoint())
2835                     return { };
2836             }
2837         }
2838 
2839         if (m_frame-&gt;loader().policyChecker().delegateIsDecidingNavigationPolicy())
2840             m_frame-&gt;loader().policyChecker().stopCheck();
2841         if (m_frame &amp;&amp; m_frame-&gt;loader().state() == FrameStateProvisional)
2842             m_frame-&gt;loader().stopAllLoaders();
2843     }
2844 
2845     removeAllEventListeners();
2846 
2847     if (responsibleDocument &amp;&amp; isFullyActive()) {
2848         auto newURL = responsibleDocument-&gt;url();
2849         if (responsibleDocument != this)
2850             newURL.removeFragmentIdentifier();
2851         setURL(newURL);
2852         auto newCookieURL = responsibleDocument-&gt;cookieURL();
2853         if (responsibleDocument != this)
2854             newCookieURL.removeFragmentIdentifier();
2855         setCookieURL(newCookieURL);
2856         setSecurityOriginPolicy(responsibleDocument-&gt;securityOriginPolicy());
2857     }
2858 
2859     implicitOpen();
2860     if (ScriptableDocumentParser* parser = scriptableDocumentParser())
2861         parser-&gt;setWasCreatedByScript(true);
2862 
2863     if (m_frame)
2864         m_frame-&gt;loader().didExplicitOpen();
2865 
2866     return { };
2867 }
2868 
2869 // https://html.spec.whatwg.org/#fully-active
2870 bool Document::isFullyActive() const
2871 {
2872     auto* frame = this-&gt;frame();
2873     if (!frame || frame-&gt;document() != this)
2874         return false;
2875 
2876     if (frame-&gt;isMainFrame())
2877         return true;
2878 
2879     auto* parentFrame = frame-&gt;tree().parent();
2880     return parentFrame &amp;&amp; parentFrame-&gt;document() &amp;&amp; parentFrame-&gt;document()-&gt;isFullyActive();
2881 }
2882 
2883 void Document::detachParser()
2884 {
2885     if (!m_parser)
2886         return;
2887     m_parser-&gt;detach();
2888     m_parser = nullptr;
2889 }
2890 
2891 void Document::cancelParsing()
2892 {
2893     if (!m_parser)
2894         return;
2895 
2896     if (m_parser-&gt;processingData())
2897         m_activeParserWasAborted = true;
2898 
2899     // We have to clear the parser to avoid possibly triggering
2900     // the onload handler when closing as a side effect of a cancel-style
2901     // change, such as opening a new document or closing the window while
2902     // still parsing
2903     detachParser();
2904     explicitClose();
2905 }
2906 
2907 void Document::implicitOpen()
2908 {
2909     removeChildren();
2910 
2911     setCompatibilityMode(DocumentCompatibilityMode::NoQuirksMode);
2912 
2913     detachParser();
2914     m_parser = createParser();
2915 
2916     if (hasActiveParserYieldToken())
2917         m_parser-&gt;didBeginYieldingParser();
2918 
2919     setParsing(true);
2920     setReadyState(Loading);
2921 }
2922 
2923 HTMLBodyElement* Document::body() const
2924 {
2925     auto* element = documentElement();
2926     if (!is&lt;HTMLHtmlElement&gt;(element))
2927         return nullptr;
2928     return childrenOfType&lt;HTMLBodyElement&gt;(*element).first();
2929 }
2930 
2931 HTMLElement* Document::bodyOrFrameset() const
2932 {
2933     // Return the first body or frameset child of the html element.
2934     auto* element = documentElement();
2935     if (!is&lt;HTMLHtmlElement&gt;(element))
2936         return nullptr;
2937     for (auto&amp; child : childrenOfType&lt;HTMLElement&gt;(*element)) {
2938         if (is&lt;HTMLBodyElement&gt;(child) || is&lt;HTMLFrameSetElement&gt;(child))
2939             return &amp;child;
2940     }
2941     return nullptr;
2942 }
2943 
2944 ExceptionOr&lt;void&gt; Document::setBodyOrFrameset(RefPtr&lt;HTMLElement&gt;&amp;&amp; newBody)
2945 {
2946     if (!is&lt;HTMLBodyElement&gt;(newBody) &amp;&amp; !is&lt;HTMLFrameSetElement&gt;(newBody))
2947         return Exception { HierarchyRequestError };
2948 
2949     auto* currentBody = bodyOrFrameset();
2950     if (newBody == currentBody)
2951         return { };
2952 
2953     if (!m_documentElement)
2954         return Exception { HierarchyRequestError };
2955 
2956     if (currentBody)
2957         return m_documentElement-&gt;replaceChild(*newBody, *currentBody);
2958     return m_documentElement-&gt;appendChild(*newBody);
2959 }
2960 
2961 Location* Document::location() const
2962 {
2963     auto* window = domWindow();
2964     return window ? &amp;window-&gt;location() : nullptr;
2965 }
2966 
2967 HTMLHeadElement* Document::head()
2968 {
2969     if (auto element = documentElement())
2970         return childrenOfType&lt;HTMLHeadElement&gt;(*element).first();
2971     return nullptr;
2972 }
2973 
2974 ExceptionOr&lt;void&gt; Document::closeForBindings()
2975 {
2976     // FIXME: We should follow the specification more closely:
2977     //        http://www.whatwg.org/specs/web-apps/current-work/#dom-document-close
2978 
2979     if (!isHTMLDocument() || m_throwOnDynamicMarkupInsertionCount)
2980         return Exception { InvalidStateError };
2981 
2982     close();
2983     return { };
2984 }
2985 
2986 void Document::close()
2987 {
2988     if (!scriptableDocumentParser() || !scriptableDocumentParser()-&gt;wasCreatedByScript() || !scriptableDocumentParser()-&gt;isParsing())
2989         return;
2990 
2991     explicitClose();
2992 }
2993 
2994 void Document::explicitClose()
2995 {
2996     if (RefPtr&lt;DocumentParser&gt; parser = m_parser)
2997         parser-&gt;finish();
2998 
2999     if (!m_frame) {
3000         // Because we have no frame, we don&#39;t know if all loading has completed,
3001         // so we just call implicitClose() immediately. FIXME: This might fire
3002         // the load event prematurely &lt;http://bugs.webkit.org/show_bug.cgi?id=14568&gt;.
3003         implicitClose();
3004         return;
3005     }
3006 
3007     checkCompleted();
3008 }
3009 
3010 void Document::implicitClose()
3011 {
3012     RELEASE_ASSERT(!m_inStyleRecalc);
3013     bool wasLocationChangePending = frame() &amp;&amp; frame()-&gt;navigationScheduler().locationChangePending();
3014     bool doload = !parsing() &amp;&amp; m_parser &amp;&amp; !m_processingLoadEvent &amp;&amp; !wasLocationChangePending;
3015 
3016     if (!doload)
3017         return;
3018 
3019     // Call to dispatchWindowLoadEvent can blow us from underneath.
3020     Ref&lt;Document&gt; protectedThis(*this);
3021 
3022     m_processingLoadEvent = true;
3023 
3024     ScriptableDocumentParser* parser = scriptableDocumentParser();
3025     m_wellFormed = parser &amp;&amp; parser-&gt;wellFormed();
3026 
3027     // We have to clear the parser, in case someone document.write()s from the
3028     // onLoad event handler, as in Radar 3206524.
3029     detachParser();
3030 
3031     // FIXME: We kick off the icon loader when the Document is done parsing.
3032     // There are earlier opportunities we could start it:
3033     //  -When the &lt;head&gt; finishes parsing
3034     //  -When any new HTMLLinkElement is inserted into the document
3035     // But those add a dynamic component to the favicon that has UI
3036     // ramifications, and we need to decide what is the Right Thing To Do(tm)
3037     RefPtr&lt;Frame&gt; f = frame();
3038     if (f) {
3039 #if ENABLE(XSLT)
3040         // Apply XSL transforms before load events so that event handlers can access the transformed DOM tree.
3041         applyPendingXSLTransformsNowIfScheduled();
3042 #endif
3043 
3044         if (auto* documentLoader = loader())
3045             documentLoader-&gt;startIconLoading();
3046 
3047         f-&gt;animation().startAnimationsIfNotSuspended(this);
3048 
3049         // FIXME: We shouldn&#39;t be dispatching pending events globally on all Documents here.
3050         // For now, only do this when there is a Frame, otherwise this could cause JS reentrancy
3051         // below SVG font parsing, for example. &lt;https://webkit.org/b/136269&gt;
3052         ImageLoader::dispatchPendingBeforeLoadEvents();
3053         ImageLoader::dispatchPendingLoadEvents();
3054         ImageLoader::dispatchPendingErrorEvents();
3055         HTMLLinkElement::dispatchPendingLoadEvents();
3056         HTMLStyleElement::dispatchPendingLoadEvents();
3057 
3058         if (svgExtensions())
3059             accessSVGExtensions().dispatchLoadEventToOutermostSVGElements();
3060     }
3061 
3062     dispatchWindowLoadEvent();
3063     dispatchPageshowEvent(PageshowEventNotPersisted);
3064     if (m_pendingStateObject)
3065         dispatchPopstateEvent(WTFMove(m_pendingStateObject));
3066 
3067     if (f)
3068         f-&gt;loader().dispatchOnloadEvents();
3069 
3070     // An event handler may have removed the frame
3071     if (!frame()) {
3072         m_processingLoadEvent = false;
3073         return;
3074     }
3075 
3076     // Make sure both the initial layout and reflow happen after the onload
3077     // fires. This will improve onload scores, and other browsers do it.
3078     // If they wanna cheat, we can too. -dwh
3079 
3080     if (frame()-&gt;navigationScheduler().locationChangePending() &amp;&amp; timeSinceDocumentCreation() &lt; settings().layoutInterval()) {
3081         // Just bail out. Before or during the onload we were shifted to another page.
3082         // The old i-Bench suite does this. When this happens don&#39;t bother painting or laying out.
3083         m_processingLoadEvent = false;
3084         view()-&gt;layoutContext().unscheduleLayout();
3085         return;
3086     }
3087 
3088     frame()-&gt;loader().checkCallImplicitClose();
3089 
3090     // We used to force a synchronous display and flush here.  This really isn&#39;t
3091     // necessary and can in fact be actively harmful if pages are loading at a rate of &gt; 60fps
3092     // (if your platform is syncing flushes and limiting them to 60fps).
3093     m_overMinimumLayoutThreshold = true;
3094     if (!ownerElement() || (ownerElement()-&gt;renderer() &amp;&amp; !ownerElement()-&gt;renderer()-&gt;needsLayout())) {
3095         updateStyleIfNeeded();
3096 
3097         // Always do a layout after loading if needed.
3098         if (view() &amp;&amp; renderView() &amp;&amp; (!renderView()-&gt;firstChild() || renderView()-&gt;needsLayout()))
3099             view()-&gt;layoutContext().layout();
3100     }
3101 
3102     m_processingLoadEvent = false;
3103 
3104     if (auto fontFaceSet = makeRefPtr(fontSelector().fontFaceSetIfExists()))
3105         fontFaceSet-&gt;documentDidFinishLoading();
3106 
3107 #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
3108     if (f &amp;&amp; hasLivingRenderTree() &amp;&amp; AXObjectCache::accessibilityEnabled()) {
3109         // The AX cache may have been cleared at this point, but we need to make sure it contains an
3110         // AX object to send the notification to. getOrCreate will make sure that an valid AX object
3111         // exists in the cache (we ignore the return value because we don&#39;t need it here). This is
3112         // only safe to call when a layout is not in progress, so it can not be used in postNotification.
3113         //
3114         // This notification is now called AXNewDocumentLoadComplete because there are other handlers that will
3115         // catch new AND page history loads, and that uses AXLoadComplete
3116 
3117         axObjectCache()-&gt;getOrCreate(renderView());
3118         if (this == &amp;topDocument())
3119             axObjectCache()-&gt;postNotification(renderView(), AXObjectCache::AXNewDocumentLoadComplete);
3120         else {
3121             // AXLoadComplete can only be posted on the top document, so if it&#39;s a document
3122             // in an iframe that just finished loading, post AXLayoutComplete instead.
3123             axObjectCache()-&gt;postNotification(renderView(), AXObjectCache::AXLayoutComplete);
3124         }
3125     }
3126 #endif
3127 
3128     if (svgExtensions())
3129         accessSVGExtensions().startAnimations();
3130 }
3131 
3132 void Document::setParsing(bool b)
3133 {
3134     m_bParsing = b;
3135 
3136     if (m_bParsing &amp;&amp; !m_sharedObjectPool)
3137         m_sharedObjectPool = makeUnique&lt;DocumentSharedObjectPool&gt;();
3138 
3139     if (!m_bParsing &amp;&amp; view() &amp;&amp; !view()-&gt;needsLayout())
3140         view()-&gt;fireLayoutRelatedMilestonesIfNeeded();
3141 }
3142 
3143 bool Document::shouldScheduleLayout()
3144 {
3145     if (!documentElement())
3146         return false;
3147     if (!is&lt;HTMLHtmlElement&gt;(*documentElement()))
3148         return true;
3149     if (!bodyOrFrameset())
3150         return false;
3151     if (styleScope().hasPendingSheetsBeforeBody())
3152         return false;
3153     if (page() &amp;&amp; page()-&gt;chrome().client().layerFlushThrottlingIsActive() &amp;&amp; view() &amp;&amp; view()-&gt;isVisuallyNonEmpty())
3154         return false;
3155 
3156     return true;
3157 }
3158 
3159 bool Document::isLayoutTimerActive()
3160 {
3161     return view() &amp;&amp; view()-&gt;layoutContext().isLayoutPending() &amp;&amp; !minimumLayoutDelay();
3162 }
3163 
3164 Seconds Document::minimumLayoutDelay()
3165 {
3166     if (m_overMinimumLayoutThreshold)
3167         return 0_s;
3168 
3169     auto elapsed = timeSinceDocumentCreation();
3170     m_overMinimumLayoutThreshold = elapsed &gt; settings().layoutInterval();
3171 
3172     // We&#39;ll want to schedule the timer to fire at the minimum layout threshold.
3173     return std::max(0_s, settings().layoutInterval() - elapsed);
3174 }
3175 
3176 Seconds Document::timeSinceDocumentCreation() const
3177 {
3178     return MonotonicTime::now() - m_documentCreationTime;
3179 }
3180 
3181 ExceptionOr&lt;void&gt; Document::write(Document* responsibleDocument, SegmentedString&amp;&amp; text)
3182 {
3183     if (m_activeParserWasAborted)
3184         return { };
3185 
3186     NestingLevelIncrementer nestingLevelIncrementer(m_writeRecursionDepth);
3187 
3188     m_writeRecursionIsTooDeep = (m_writeRecursionDepth &gt; 1) &amp;&amp; m_writeRecursionIsTooDeep;
3189     m_writeRecursionIsTooDeep = (m_writeRecursionDepth &gt; cMaxWriteRecursionDepth) || m_writeRecursionIsTooDeep;
3190 
3191     if (m_writeRecursionIsTooDeep)
3192         return { };
3193 
3194     bool hasInsertionPoint = m_parser &amp;&amp; m_parser-&gt;hasInsertionPoint();
3195     if (!hasInsertionPoint &amp;&amp; (m_ignoreOpensDuringUnloadCount || m_ignoreDestructiveWriteCount))
3196         return { };
3197 
3198     if (!hasInsertionPoint) {
3199         auto result = open(responsibleDocument);
3200         if (UNLIKELY(result.hasException()))
3201             return result.releaseException();
3202     }
3203 
3204     ASSERT(m_parser);
3205     m_parser-&gt;insert(WTFMove(text));
3206     return { };
3207 }
3208 
3209 ExceptionOr&lt;void&gt; Document::write(Document* responsibleDocument, Vector&lt;String&gt;&amp;&amp; strings)
3210 {
3211     if (!isHTMLDocument() || m_throwOnDynamicMarkupInsertionCount)
3212         return Exception { InvalidStateError };
3213 
3214     SegmentedString text;
3215     for (auto&amp; string : strings)
3216         text.append(WTFMove(string));
3217 
3218     return write(responsibleDocument, WTFMove(text));
3219 }
3220 
3221 ExceptionOr&lt;void&gt; Document::writeln(Document* responsibleDocument, Vector&lt;String&gt;&amp;&amp; strings)
3222 {
3223     if (!isHTMLDocument() || m_throwOnDynamicMarkupInsertionCount)
3224         return Exception { InvalidStateError };
3225 
3226     SegmentedString text;
3227     for (auto&amp; string : strings)
3228         text.append(WTFMove(string));
3229 
3230     text.append(&quot;\n&quot;_s);
3231     return write(responsibleDocument, WTFMove(text));
3232 }
3233 
3234 Seconds Document::minimumDOMTimerInterval() const
3235 {
3236     auto* page = this-&gt;page();
3237     if (!page)
3238         return ScriptExecutionContext::minimumDOMTimerInterval();
3239     return page-&gt;settings().minimumDOMTimerInterval();
3240 }
3241 
3242 void Document::setTimerThrottlingEnabled(bool shouldThrottle)
3243 {
3244     if (m_isTimerThrottlingEnabled == shouldThrottle)
3245         return;
3246 
3247     m_isTimerThrottlingEnabled = shouldThrottle;
3248     didChangeTimerAlignmentInterval();
3249 }
3250 
3251 Seconds Document::domTimerAlignmentInterval(bool hasReachedMaxNestingLevel) const
3252 {
3253     auto alignmentInterval = ScriptExecutionContext::domTimerAlignmentInterval(hasReachedMaxNestingLevel);
3254     if (!hasReachedMaxNestingLevel)
3255         return alignmentInterval;
3256 
3257     // Apply Document-level DOMTimer throttling only if timers have reached their maximum nesting level as the Page may still be visible.
3258     if (m_isTimerThrottlingEnabled)
3259         alignmentInterval = std::max(alignmentInterval, DOMTimer::hiddenPageAlignmentInterval());
3260 
3261     if (Page* page = this-&gt;page())
3262         alignmentInterval = std::max(alignmentInterval, page-&gt;domTimerAlignmentInterval());
3263 
3264     if (!topOrigin().canAccess(securityOrigin()) &amp;&amp; !hasHadUserInteraction())
3265         alignmentInterval = std::max(alignmentInterval, DOMTimer::nonInteractedCrossOriginFrameAlignmentInterval());
3266 
3267     return alignmentInterval;
3268 }
3269 
3270 EventTarget* Document::errorEventTarget()
3271 {
3272     return m_domWindow.get();
3273 }
3274 
3275 void Document::logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp; callStack)
3276 {
3277     addMessage(MessageSource::JS, MessageLevel::Error, errorMessage, sourceURL, lineNumber, columnNumber, WTFMove(callStack));
3278 }
3279 
3280 void Document::setURL(const URL&amp; url)
3281 {
3282     const URL&amp; newURL = url.isEmpty() ? WTF::blankURL() : url;
3283     if (newURL == m_url)
3284         return;
3285 
3286     m_url = newURL;
3287     if (SecurityOrigin::shouldIgnoreHost(m_url))
3288         m_url.removeHostAndPort();
3289 
3290     m_documentURI = m_url.string();
3291     updateBaseURL();
3292 }
3293 
3294 void Document::updateBaseURL()
3295 {
3296     URL oldBaseURL = m_baseURL;
3297     // DOM 3 Core: When the Document supports the feature &quot;HTML&quot; [DOM Level 2 HTML], the base URI is computed using
3298     // first the value of the href attribute of the HTML BASE element if any, and the value of the documentURI attribute
3299     // from the Document interface otherwise.
3300     if (!m_baseElementURL.isEmpty())
3301         m_baseURL = m_baseElementURL;
3302     else if (!m_baseURLOverride.isEmpty())
3303         m_baseURL = m_baseURLOverride;
3304     else {
3305         // The documentURI attribute is read-only from JavaScript, but writable from Objective C, so we need to retain
3306         // this fallback behavior. We use a null base URL, since the documentURI attribute is an arbitrary string
3307         // and DOM 3 Core does not specify how it should be resolved.
3308         m_baseURL = URL({ }, documentURI());
3309     }
3310 
3311     clearSelectorQueryCache();
3312 
3313     if (!m_baseURL.isValid())
3314         m_baseURL = URL();
3315 }
3316 
3317 void Document::setBaseURLOverride(const URL&amp; url)
3318 {
3319     m_baseURLOverride = url;
3320     updateBaseURL();
3321 }
3322 
3323 void Document::processBaseElement()
3324 {
3325     // Find the first href attribute in a base element and the first target attribute in a base element.
3326     const AtomString* href = nullptr;
3327     const AtomString* target = nullptr;
3328     auto baseDescendants = descendantsOfType&lt;HTMLBaseElement&gt;(*this);
3329     for (auto&amp; base : baseDescendants) {
3330         if (!href) {
3331             const AtomString&amp; value = base.attributeWithoutSynchronization(hrefAttr);
3332             if (!value.isNull()) {
3333                 href = &amp;value;
3334                 if (target)
3335                     break;
3336             }
3337         }
3338         if (!target) {
3339             const AtomString&amp; value = base.attributeWithoutSynchronization(targetAttr);
3340             if (!value.isNull()) {
3341                 target = &amp;value;
3342                 if (href)
3343                     break;
3344             }
3345         }
3346     }
3347 
3348     // FIXME: Since this doesn&#39;t share code with completeURL it may not handle encodings correctly.
3349     URL baseElementURL;
3350     if (href) {
3351         String strippedHref = stripLeadingAndTrailingHTMLSpaces(*href);
3352         if (!strippedHref.isEmpty())
3353             baseElementURL = URL(url(), strippedHref);
3354     }
3355     if (m_baseElementURL != baseElementURL &amp;&amp; contentSecurityPolicy()-&gt;allowBaseURI(baseElementURL)) {
3356         if (settings().shouldRestrictBaseURLSchemes() &amp;&amp; !SecurityPolicy::isBaseURLSchemeAllowed(baseElementURL))
3357             addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Blocked setting &quot; + baseElementURL.stringCenterEllipsizedToLength() + &quot; as the base URL because it does not have an allowed scheme.&quot;);
3358         else {
3359             m_baseElementURL = baseElementURL;
3360             updateBaseURL();
3361         }
3362     }
3363 
3364     m_baseTarget = target ? *target : nullAtom();
3365 }
3366 
3367 String Document::userAgent(const URL&amp; url) const
3368 {
3369     return frame() ? frame()-&gt;loader().userAgent(url) : String();
3370 }
3371 
3372 void Document::disableEval(const String&amp; errorMessage)
3373 {
3374     if (!frame())
3375         return;
3376 
3377     frame()-&gt;script().disableEval(errorMessage);
3378 }
3379 
3380 void Document::disableWebAssembly(const String&amp; errorMessage)
3381 {
3382     if (!frame())
3383         return;
3384 
3385     frame()-&gt;script().disableWebAssembly(errorMessage);
3386 }
3387 
3388 #if ENABLE(INDEXED_DATABASE)
3389 IDBClient::IDBConnectionProxy* Document::idbConnectionProxy()
3390 {
3391     if (!m_idbConnectionProxy) {
3392         Page* currentPage = page();
3393         if (!currentPage)
3394             return nullptr;
3395         m_idbConnectionProxy = &amp;currentPage-&gt;idbConnection().proxy();
3396     }
3397     return m_idbConnectionProxy.get();
3398 }
3399 #endif
3400 
3401 SocketProvider* Document::socketProvider()
3402 {
3403     return m_socketProvider.get();
3404 }
3405 
3406 bool Document::canNavigate(Frame* targetFrame, const URL&amp; destinationURL)
3407 {
3408     if (!m_frame)
3409         return false;
3410 
3411     // FIXME: We shouldn&#39;t call this function without a target frame, but
3412     // fast/forms/submit-to-blank-multiple-times.html depends on this function
3413     // returning true when supplied with a 0 targetFrame.
3414     if (!targetFrame)
3415         return true;
3416 
3417     if (!canNavigateInternal(*targetFrame))
3418         return false;
3419 
3420     if (isNavigationBlockedByThirdPartyIFrameRedirectBlocking(*targetFrame, destinationURL)) {
3421         printNavigationErrorMessage(*targetFrame, url(), &quot;The frame attempting navigation of the top-level window is cross-origin or untrusted and the user has never interacted with the frame.&quot;_s);
3422         return false;
3423     }
3424 
3425     return true;
3426 }
3427 
3428 bool Document::canNavigateInternal(Frame&amp; targetFrame)
3429 {
3430     ASSERT(m_frame);
3431 
3432     // Cases (i), (ii) and (iii) pass the tests from the specifications but might not pass the &quot;security origin&quot; tests.
3433 
3434     // i. A frame can navigate its top ancestor when its &#39;allow-top-navigation&#39; flag is set (sometimes known as &#39;frame-busting&#39;).
3435     if (!isSandboxed(SandboxTopNavigation) &amp;&amp; &amp;targetFrame == &amp;m_frame-&gt;tree().top())
3436         return true;
3437 
3438     // ii. A frame can navigate its top ancestor when its &#39;allow-top-navigation-by-user-activation&#39; flag is set and navigation is triggered by user activation.
3439     if (!isSandboxed(SandboxTopNavigationByUserActivation) &amp;&amp; UserGestureIndicator::processingUserGesture() &amp;&amp; &amp;targetFrame == &amp;m_frame-&gt;tree().top())
3440         return true;
3441 
3442     // iii. A sandboxed frame can always navigate its descendants.
3443     if (isSandboxed(SandboxNavigation) &amp;&amp; targetFrame.tree().isDescendantOf(m_frame))
3444         return true;
3445 
3446     // From https://html.spec.whatwg.org/multipage/browsers.html#allowed-to-navigate.
3447     // 1. If A is not the same browsing context as B, and A is not one of the ancestor browsing contexts of B, and B is not a top-level browsing context, and A&#39;s active document&#39;s active sandboxing
3448     // flag set has its sandboxed navigation browsing context flag set, then abort these steps negatively.
3449     if (m_frame != &amp;targetFrame &amp;&amp; isSandboxed(SandboxNavigation) &amp;&amp; targetFrame.tree().parent() &amp;&amp; !targetFrame.tree().isDescendantOf(m_frame)) {
3450         printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation is sandboxed, and is therefore disallowed from navigating its ancestors.&quot;_s);
3451         return false;
3452     }
3453 
3454     // 2. Otherwise, if B is a top-level browsing context, and is one of the ancestor browsing contexts of A, then:
3455     if (m_frame != &amp;targetFrame &amp;&amp; &amp;targetFrame == &amp;m_frame-&gt;tree().top()) {
3456         bool triggeredByUserActivation = UserGestureIndicator::processingUserGesture();
3457         // 1. If this algorithm is triggered by user activation and A&#39;s active document&#39;s active sandboxing flag set has its sandboxed top-level navigation with user activation browsing context flag set, then abort these steps negatively.
3458         if (triggeredByUserActivation &amp;&amp; isSandboxed(SandboxTopNavigationByUserActivation)) {
3459             printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation of the top-level window is sandboxed, but the &#39;allow-top-navigation-by-user-activation&#39; flag is not set and navigation is not triggered by user activation.&quot;_s);
3460             return false;
3461         }
3462         // 2. Otherwise, If this algorithm is not triggered by user activation and A&#39;s active document&#39;s active sandboxing flag set has its sandboxed top-level navigation without user activation browsing context flag set, then abort these steps negatively.
3463         if (!triggeredByUserActivation &amp;&amp; isSandboxed(SandboxTopNavigation)) {
3464             printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation of the top-level window is sandboxed, but the &#39;allow-top-navigation&#39; flag is not set.&quot;_s);
3465             return false;
3466         }
3467     }
3468 
3469     // 3. Otherwise, if B is a top-level browsing context, and is neither A nor one of the ancestor browsing contexts of A, and A&#39;s Document&#39;s active sandboxing flag set has its
3470     // sandboxed navigation browsing context flag set, and A is not the one permitted sandboxed navigator of B, then abort these steps negatively.
3471     if (!targetFrame.tree().parent() &amp;&amp; m_frame != &amp;targetFrame &amp;&amp; &amp;targetFrame != &amp;m_frame-&gt;tree().top() &amp;&amp; isSandboxed(SandboxNavigation) &amp;&amp; targetFrame.loader().opener() != m_frame) {
3472         printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation is sandboxed, and is not allowed to navigate this popup.&quot;_s);
3473         return false;
3474     }
3475 
3476     // 4. Otherwise, terminate positively!
3477 
3478     // This is the normal case. A document can navigate its descendant frames,
3479     // or, more generally, a document can navigate a frame if the document is
3480     // in the same origin as any of that frame&#39;s ancestors (in the frame
3481     // hierarchy).
3482     //
3483     // See http://www.adambarth.com/papers/2008/barth-jackson-mitchell.pdf for
3484     // historical information about this security check.
3485     if (canAccessAncestor(securityOrigin(), &amp;targetFrame))
3486         return true;
3487 
3488     // Top-level frames are easier to navigate than other frames because they
3489     // display their URLs in the address bar (in most browsers). However, there
3490     // are still some restrictions on navigation to avoid nuisance attacks.
3491     // Specifically, a document can navigate a top-level frame if that frame
3492     // opened the document or if the document is the same-origin with any of
3493     // the top-level frame&#39;s opener&#39;s ancestors (in the frame hierarchy).
3494     //
3495     // In both of these cases, the document performing the navigation is in
3496     // some way related to the frame being navigate (e.g., by the &quot;opener&quot;
3497     // and/or &quot;parent&quot; relation). Requiring some sort of relation prevents a
3498     // document from navigating arbitrary, unrelated top-level frames.
3499     if (!targetFrame.tree().parent()) {
3500         if (&amp;targetFrame == m_frame-&gt;loader().opener())
3501             return true;
3502 
3503         if (canAccessAncestor(securityOrigin(), targetFrame.loader().opener()))
3504             return true;
3505     }
3506 
3507     printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation is neither same-origin with the target, nor is it the target&#39;s parent or opener.&quot;);
3508     return false;
3509 }
3510 
3511 void Document::willLoadScriptElement(const URL&amp; scriptURL)
3512 {
3513     m_hasLoadedThirdPartyScript = m_hasLoadedThirdPartyScript || !securityOrigin().isSameOriginAs(SecurityOrigin::create(scriptURL));
3514 }
3515 
3516 void Document::willLoadFrameElement(const URL&amp; frameURL)
3517 {
3518     m_hasLoadedThirdPartyFrame = m_hasLoadedThirdPartyFrame || !securityOrigin().isSameOriginAs(SecurityOrigin::create(frameURL));
3519 }
3520 
3521 // Prevent cross-site top-level redirects from third-party iframes unless the user has ever interacted with the frame.
3522 bool Document::isNavigationBlockedByThirdPartyIFrameRedirectBlocking(Frame&amp; targetFrame, const URL&amp; destinationURL)
3523 {
3524     if (!settings().thirdPartyIframeRedirectBlockingEnabled())
3525         return false;
3526 
3527     // Only prevent top frame navigations by subframes.
3528     if (m_frame == &amp;targetFrame || &amp;targetFrame != &amp;m_frame-&gt;tree().top())
3529         return false;
3530 
3531     // Only prevent navigations by subframes that the user has not interacted with.
3532     if (m_frame-&gt;hasHadUserInteraction())
3533         return false;
3534 
3535     // Only prevent navigations by unsandboxed iframes. Such navigations by unsandboxed iframes would have already been blocked unless
3536     // &quot;allow-top-navigation&quot; / &quot;allow-top-navigation-by-user-activation&quot; was explicitly specified.
3537     if (sandboxFlags() != SandboxNone)
3538         return false;
3539 
3540     // Only prevent navigations by third-party iframes or untrusted first-party iframes.
3541     bool isUntrustedIframe = m_hasLoadedThirdPartyScript &amp;&amp; m_hasLoadedThirdPartyFrame;
3542     if (canAccessAncestor(securityOrigin(), &amp;targetFrame) &amp;&amp; !isUntrustedIframe)
3543         return false;
3544 
3545     // Only prevent cross-site navigations.
3546     auto* targetDocument = targetFrame.document();
3547     if (targetDocument &amp;&amp; (targetDocument-&gt;securityOrigin().canAccess(SecurityOrigin::create(destinationURL)) || areRegistrableDomainsEqual(targetDocument-&gt;url(), destinationURL)))
3548         return false;
3549 
3550     return true;
3551 }
3552 
3553 void Document::didRemoveAllPendingStylesheet()
3554 {
3555     if (auto* parser = scriptableDocumentParser())
3556         parser-&gt;executeScriptsWaitingForStylesheetsSoon();
3557 
3558     if (m_gotoAnchorNeededAfterStylesheetsLoad) {
3559         // https://html.spec.whatwg.org/multipage/browsing-the-web.html#try-to-scroll-to-the-fragment
3560         eventLoop().queueTask(TaskSource::Networking, [protectedThis = makeRef(*this), this] {
3561             auto frameView = makeRefPtr(view());
3562             if (!frameView)
3563                 return;
3564             if (!haveStylesheetsLoaded()) {
3565                 m_gotoAnchorNeededAfterStylesheetsLoad = true;
3566                 return;
3567             }
3568             frameView-&gt;scrollToFragment(m_url);
3569         });
3570     }
3571 }
3572 
3573 bool Document::usesStyleBasedEditability() const
3574 {
3575     if (m_hasElementUsingStyleBasedEditability)
3576         return true;
3577 
3578     ASSERT(!m_renderView || !m_renderView-&gt;frameView().isPainting());
3579     ASSERT(!m_inStyleRecalc);
3580 
3581     auto&amp; styleScope = const_cast&lt;Style::Scope&amp;&gt;(this-&gt;styleScope());
3582     styleScope.flushPendingUpdate();
3583     return styleScope.usesStyleBasedEditability();
3584 }
3585 
3586 void Document::setHasElementUsingStyleBasedEditability()
3587 {
3588     m_hasElementUsingStyleBasedEditability = true;
3589 }
3590 
3591 void Document::processHttpEquiv(const String&amp; equiv, const String&amp; content, bool isInDocumentHead)
3592 {
3593     ASSERT(!equiv.isNull());
3594     ASSERT(!content.isNull());
3595 
3596     HttpEquivPolicy policy = httpEquivPolicy();
3597     if (policy != HttpEquivPolicy::Enabled) {
3598         String reason;
3599         switch (policy) {
3600         case HttpEquivPolicy::Enabled:
3601             ASSERT_NOT_REACHED();
3602             break;
3603         case HttpEquivPolicy::DisabledBySettings:
3604             reason = &quot;by the embedder.&quot;;
3605             break;
3606         case HttpEquivPolicy::DisabledByContentDispositionAttachmentSandbox:
3607             reason = &quot;for documents with Content-Disposition: attachment.&quot;;
3608             break;
3609         }
3610         String message = &quot;http-equiv &#39;&quot; + equiv + &quot;&#39; is disabled &quot; + reason;
3611         addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
3612         return;
3613     }
3614 
3615     Frame* frame = this-&gt;frame();
3616     auto* documentLoader = frame ? frame-&gt;loader().documentLoader() : nullptr;
3617     auto httpStatusCode = documentLoader ? documentLoader-&gt;response().httpStatusCode() : 0;
3618 
3619     HTTPHeaderName headerName;
3620     if (!findHTTPHeaderName(equiv, headerName))
3621         return;
3622 
3623     switch (headerName) {
3624     case HTTPHeaderName::DefaultStyle:
3625         // The preferred style set has been overridden as per section
3626         // 14.3.2 of the HTML4.0 specification.  We need to update the
3627         // sheet used variable and then update our style selector.
3628         // For more info, see the test at:
3629         // http://www.hixie.ch/tests/evil/css/import/main/preferred.html
3630         // -dwh
3631         styleScope().setPreferredStylesheetSetName(content);
3632         break;
3633 
3634     case HTTPHeaderName::Refresh: {
3635         double delay = 0;
3636         String urlString;
3637         if (frame &amp;&amp; parseMetaHTTPEquivRefresh(content, delay, urlString)) {
3638             URL completedURL;
3639             if (urlString.isEmpty())
3640                 completedURL = m_url;
3641             else
3642                 completedURL = completeURL(urlString);
3643             if (!WTF::protocolIsJavaScript(completedURL))
3644                 frame-&gt;navigationScheduler().scheduleRedirect(*this, delay, completedURL);
3645             else {
3646                 String message = &quot;Refused to refresh &quot; + m_url.stringCenterEllipsizedToLength() + &quot; to a javascript: URL&quot;;
3647                 addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
3648             }
3649         }
3650 
3651         break;
3652     }
3653 
3654     case HTTPHeaderName::SetCookie:
3655         if (isHTMLDocument())
3656             addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;The Set-Cookie meta tag is obsolete and was ignored. Use the HTTP header Set-Cookie or document.cookie instead.&quot;_s);
3657         break;
3658 
3659     case HTTPHeaderName::ContentLanguage:
3660         setContentLanguage(content);
3661         break;
3662 
3663     case HTTPHeaderName::XDNSPrefetchControl:
3664         parseDNSPrefetchControlHeader(content);
3665         break;
3666 
3667     case HTTPHeaderName::XFrameOptions:
3668         if (frame) {
3669             FrameLoader&amp; frameLoader = frame-&gt;loader();
3670             unsigned long requestIdentifier = 0;
3671             if (frameLoader.activeDocumentLoader() &amp;&amp; frameLoader.activeDocumentLoader()-&gt;mainResourceLoader())
3672                 requestIdentifier = frameLoader.activeDocumentLoader()-&gt;mainResourceLoader()-&gt;identifier();
3673 
3674             String message = &quot;The X-Frame-Option &#39;&quot; + content + &quot;&#39; supplied in a &lt;meta&gt; element was ignored. X-Frame-Options may only be provided by an HTTP header sent with the document.&quot;;
3675             addConsoleMessage(MessageSource::Security, MessageLevel::Error, message, requestIdentifier);
3676         }
3677         break;
3678 
3679     case HTTPHeaderName::ContentSecurityPolicy:
3680         if (isInDocumentHead)
3681             contentSecurityPolicy()-&gt;didReceiveHeader(content, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::HTTPEquivMeta, referrer(), httpStatusCode);
3682         break;
3683 
3684     case HTTPHeaderName::XWebKitCSP:
3685         if (isInDocumentHead)
3686             contentSecurityPolicy()-&gt;didReceiveHeader(content, ContentSecurityPolicyHeaderType::PrefixedEnforce, ContentSecurityPolicy::PolicyFrom::HTTPEquivMeta, referrer(), httpStatusCode);
3687         break;
3688 
3689     default:
3690         break;
3691     }
3692 }
3693 
3694 void Document::processDisabledAdaptations(const String&amp; disabledAdaptationsString)
3695 {
3696     auto disabledAdaptations = parseDisabledAdaptations(disabledAdaptationsString);
3697     if (m_disabledAdaptations == disabledAdaptations)
3698         return;
3699 
3700     m_disabledAdaptations = disabledAdaptations;
3701     dispatchDisabledAdaptationsDidChangeForMainFrame();
3702 }
3703 
3704 void Document::dispatchDisabledAdaptationsDidChangeForMainFrame()
3705 {
3706     if (!frame()-&gt;isMainFrame())
3707         return;
3708 
3709     if (!page())
3710         return;
3711 
3712     page()-&gt;chrome().dispatchDisabledAdaptationsDidChange(m_disabledAdaptations);
3713 }
3714 
3715 void Document::processViewport(const String&amp; features, ViewportArguments::Type origin)
3716 {
3717     ASSERT(!features.isNull());
3718 
3719     LOG_WITH_STREAM(Viewports, stream &lt;&lt; &quot;Document::processViewport &quot; &lt;&lt; features);
3720 
3721     if (origin &lt; m_viewportArguments.type)
3722         return;
3723 
3724     m_viewportArguments = ViewportArguments(origin);
3725 
3726     LOG_WITH_STREAM(Viewports, stream  &lt;&lt; &quot; resolved to &quot; &lt;&lt; m_viewportArguments);
3727 
3728     processFeaturesString(features, FeatureMode::Viewport, [this](StringView key, StringView value) {
3729         setViewportFeature(m_viewportArguments, *this, key, value);
3730     });
3731 
3732     updateViewportArguments();
3733 }
3734 
3735 ViewportArguments Document::viewportArguments() const
3736 {
3737     auto* page = this-&gt;page();
3738     if (!page)
3739         return m_viewportArguments;
3740     return page-&gt;overrideViewportArguments().valueOr(m_viewportArguments);
3741 }
3742 
3743 void Document::updateViewportArguments()
3744 {
3745     if (page() &amp;&amp; frame()-&gt;isMainFrame()) {
3746 #if ASSERT_ENABLED
3747         m_didDispatchViewportPropertiesChanged = true;
3748 #endif
3749         page()-&gt;chrome().dispatchViewportPropertiesDidChange(viewportArguments());
3750         page()-&gt;chrome().didReceiveDocType(*frame());
3751     }
3752 }
3753 
3754 #if ENABLE(DARK_MODE_CSS)
3755 static void processColorSchemeString(StringView colorScheme, const WTF::Function&lt;void(StringView key)&gt;&amp; callback)
3756 {
3757     unsigned length = colorScheme.length();
3758     for (unsigned i = 0; i &lt; length; ) {
3759         // Skip to first non-separator.
3760         while (i &lt; length &amp;&amp; isHTMLSpace(colorScheme[i]))
3761             ++i;
3762         unsigned keyBegin = i;
3763 
3764         // Skip to first separator.
3765         while (i &lt; length &amp;&amp; !isHTMLSpace(colorScheme[i]))
3766             ++i;
3767         unsigned keyEnd = i;
3768 
3769         if (keyBegin == keyEnd)
3770             continue;
3771 
3772         callback(colorScheme.substring(keyBegin, keyEnd - keyBegin));
3773     }
3774 }
3775 
3776 void Document::processColorScheme(const String&amp; colorSchemeString)
3777 {
3778     OptionSet&lt;ColorScheme&gt; colorScheme;
3779     bool allowsTransformations = true;
3780     bool autoEncountered = false;
3781 
3782     processColorSchemeString(colorSchemeString, [&amp;] (StringView key) {
3783         if (equalLettersIgnoringASCIICase(key, &quot;auto&quot;)) {
3784             colorScheme = { };
3785             allowsTransformations = true;
3786             autoEncountered = true;
3787             return;
3788         }
3789 
3790         if (autoEncountered)
3791             return;
3792 
3793         if (equalLettersIgnoringASCIICase(key, &quot;light&quot;))
3794             colorScheme.add(ColorScheme::Light);
3795         else if (equalLettersIgnoringASCIICase(key, &quot;dark&quot;))
3796             colorScheme.add(ColorScheme::Dark);
3797         else if (equalLettersIgnoringASCIICase(key, &quot;only&quot;))
3798             allowsTransformations = false;
3799     });
3800 
3801     // If the value was just &quot;only&quot;, that is synonymous for &quot;only light&quot;.
3802     if (colorScheme.isEmpty() &amp;&amp; !allowsTransformations)
3803         colorScheme.add(ColorScheme::Light);
3804 
3805     m_colorScheme = colorScheme;
3806     m_allowsColorSchemeTransformations = allowsTransformations;
3807 
3808     if (auto* frameView = view())
3809         frameView-&gt;recalculateBaseBackgroundColor();
3810 
3811     if (auto* page = this-&gt;page())
3812         page-&gt;updateStyleAfterChangeInEnvironment();
3813 }
3814 #endif
3815 
3816 #if PLATFORM(IOS_FAMILY)
3817 
3818 void Document::processFormatDetection(const String&amp; features)
3819 {
3820     // FIXME: Find a better place for this function.
3821     processFeaturesString(features, FeatureMode::Viewport, [this](StringView key, StringView value) {
3822         if (equalLettersIgnoringASCIICase(key, &quot;telephone&quot;) &amp;&amp; equalLettersIgnoringASCIICase(value, &quot;no&quot;))
3823             m_isTelephoneNumberParsingAllowed = false;
3824     });
3825 }
3826 
3827 void Document::processWebAppOrientations()
3828 {
3829     if (Page* page = this-&gt;page())
3830         page-&gt;chrome().client().webAppOrientationsUpdated();
3831 }
3832 
3833 #endif
3834 
3835 void Document::processReferrerPolicy(const String&amp; policy, ReferrerPolicySource source)
3836 {
3837     ASSERT(!policy.isNull());
3838 
3839     // Documents in a Content-Disposition: attachment sandbox should never send a Referer header,
3840     // even if the document has a meta tag saying otherwise.
3841     if (shouldEnforceContentDispositionAttachmentSandbox())
3842         return;
3843 
3844 #if USE(QUICK_LOOK)
3845     if (shouldEnforceQuickLookSandbox())
3846         return;
3847 #endif
3848 
3849     auto referrerPolicy = parseReferrerPolicy(policy, source);
3850     if (!referrerPolicy) {
3851         // Unknown policy values are ignored (https://w3c.github.io/webappsec-referrer-policy/#unknown-policy-values).
3852         addConsoleMessage(MessageSource::Rendering, MessageLevel::Error, &quot;Failed to set referrer policy: The value &#39;&quot; + policy + &quot;&#39; is not one of &#39;no-referrer&#39;, &#39;no-referrer-when-downgrade&#39;, &#39;same-origin&#39;, &#39;origin&#39;, &#39;strict-origin&#39;, &#39;origin-when-cross-origin&#39;, &#39;strict-origin-when-cross-origin&#39; or &#39;unsafe-url&#39;.&quot;);
3853         return;
3854     }
3855     setReferrerPolicy(referrerPolicy.value());
3856 }
3857 
3858 MouseEventWithHitTestResults Document::prepareMouseEvent(const HitTestRequest&amp; request, const LayoutPoint&amp; documentPoint, const PlatformMouseEvent&amp; event)
3859 {
3860     if (!hasLivingRenderTree())
3861         return MouseEventWithHitTestResults(event, HitTestResult(LayoutPoint()));
3862 
3863     HitTestResult result(documentPoint);
3864     hitTest(request, result);
3865 
3866     auto captureElementChanged = CaptureChange::No;
3867     if (!request.readOnly()) {
3868         auto targetElement = makeRefPtr(result.targetElement());
3869 #if ENABLE(POINTER_EVENTS)
3870         if (auto* page = this-&gt;page()) {
3871             // Before we dispatch a new mouse event, we must run the Process Pending Capture Element steps as defined
3872             // in https://w3c.github.io/pointerevents/#process-pending-pointer-capture.
3873             auto&amp; pointerCaptureController = page-&gt;pointerCaptureController();
3874             auto* previousCaptureElement = pointerCaptureController.pointerCaptureElement(this, event.pointerId());
3875             pointerCaptureController.processPendingPointerCapture(event.pointerId());
3876             auto* captureElement = pointerCaptureController.pointerCaptureElement(this, event.pointerId());
3877             // If the capture element has changed while running the Process Pending Capture Element steps then
3878             // we need to indicate that when calling updateHoverActiveState to be sure that the :active and :hover
3879             // element chains are updated.
3880             if (previousCaptureElement != captureElement)
3881                 captureElementChanged = CaptureChange::Yes;
3882             // If we have a capture element, we must target it instead of what would normally hit-test for this event.
3883             if (captureElement)
3884                 targetElement = captureElement;
3885         }
3886 #endif
3887         updateHoverActiveState(request, targetElement.get(), captureElementChanged);
3888     }
3889 
3890     return MouseEventWithHitTestResults(event, result);
3891 }
3892 
3893 // DOM Section 1.1.1
3894 bool Document::childTypeAllowed(NodeType type) const
3895 {
3896     switch (type) {
3897     case ATTRIBUTE_NODE:
3898     case CDATA_SECTION_NODE:
3899     case DOCUMENT_FRAGMENT_NODE:
3900     case DOCUMENT_NODE:
3901     case TEXT_NODE:
3902         return false;
3903     case COMMENT_NODE:
3904     case PROCESSING_INSTRUCTION_NODE:
3905         return true;
3906     case DOCUMENT_TYPE_NODE:
3907     case ELEMENT_NODE:
3908         // Documents may contain no more than one of each of these.
3909         // (One Element and one DocumentType.)
3910         for (Node* c = firstChild(); c; c = c-&gt;nextSibling())
3911             if (c-&gt;nodeType() == type)
3912                 return false;
3913         return true;
3914     }
3915     return false;
3916 }
3917 
3918 bool Document::canAcceptChild(const Node&amp; newChild, const Node* refChild, AcceptChildOperation operation) const
3919 {
3920     if (operation == AcceptChildOperation::Replace &amp;&amp; refChild-&gt;nodeType() == newChild.nodeType())
3921         return true;
3922 
3923     switch (newChild.nodeType()) {
3924     case ATTRIBUTE_NODE:
3925     case CDATA_SECTION_NODE:
3926     case DOCUMENT_NODE:
3927     case TEXT_NODE:
3928         return false;
3929     case COMMENT_NODE:
3930     case PROCESSING_INSTRUCTION_NODE:
3931         return true;
3932     case DOCUMENT_FRAGMENT_NODE: {
3933         bool hasSeenElementChild = false;
3934         for (auto* node = downcast&lt;DocumentFragment&gt;(newChild).firstChild(); node; node = node-&gt;nextSibling()) {
3935             if (is&lt;Element&gt;(*node)) {
3936                 if (hasSeenElementChild)
3937                     return false;
3938                 hasSeenElementChild = true;
3939             }
3940             if (!canAcceptChild(*node, refChild, operation))
3941                 return false;
3942         }
3943         break;
3944     }
3945     case DOCUMENT_TYPE_NODE: {
3946         auto* existingDocType = childrenOfType&lt;DocumentType&gt;(*this).first();
3947         if (operation == AcceptChildOperation::Replace) {
3948             //  parent has a doctype child that is not child, or an element is preceding child.
3949             if (existingDocType &amp;&amp; existingDocType != refChild)
3950                 return false;
3951             if (refChild-&gt;previousElementSibling())
3952                 return false;
3953         } else {
3954             ASSERT(operation == AcceptChildOperation::InsertOrAdd);
3955             if (existingDocType)
3956                 return false;
3957             if ((refChild &amp;&amp; refChild-&gt;previousElementSibling()) || (!refChild &amp;&amp; firstElementChild()))
3958                 return false;
3959         }
3960         break;
3961     }
3962     case ELEMENT_NODE: {
3963         auto* existingElementChild = firstElementChild();
3964         if (operation == AcceptChildOperation::Replace) {
3965             if (existingElementChild &amp;&amp; existingElementChild != refChild)
3966                 return false;
3967             for (auto* child = refChild-&gt;nextSibling(); child; child = child-&gt;nextSibling()) {
3968                 if (is&lt;DocumentType&gt;(*child))
3969                     return false;
3970             }
3971         } else {
3972             ASSERT(operation == AcceptChildOperation::InsertOrAdd);
3973             if (existingElementChild)
3974                 return false;
3975             for (auto* child = refChild; child; child = child-&gt;nextSibling()) {
3976                 if (is&lt;DocumentType&gt;(*child))
3977                     return false;
3978             }
3979         }
3980         break;
3981     }
3982     }
3983     return true;
3984 }
3985 
3986 Ref&lt;Node&gt; Document::cloneNodeInternal(Document&amp;, CloningOperation type)
3987 {
3988     Ref&lt;Document&gt; clone = cloneDocumentWithoutChildren();
3989     clone-&gt;cloneDataFromDocument(*this);
3990     switch (type) {
3991     case CloningOperation::OnlySelf:
3992     case CloningOperation::SelfWithTemplateContent:
3993         break;
3994     case CloningOperation::Everything:
3995         cloneChildNodes(clone);
3996         break;
3997     }
3998     return clone;
3999 }
4000 
4001 Ref&lt;Document&gt; Document::cloneDocumentWithoutChildren() const
4002 {
4003     if (isXMLDocument()) {
4004         if (isXHTMLDocument())
4005             return XMLDocument::createXHTML(nullptr, url());
4006         return XMLDocument::create(nullptr, url());
4007     }
4008     return create(url());
4009 }
4010 
4011 void Document::cloneDataFromDocument(const Document&amp; other)
4012 {
4013     ASSERT(m_url == other.url());
4014     m_baseURL = other.baseURL();
4015     m_baseURLOverride = other.baseURLOverride();
4016     m_documentURI = other.documentURI();
4017 
4018     setCompatibilityMode(other.m_compatibilityMode);
4019     setContextDocument(other.contextDocument());
4020     setSecurityOriginPolicy(other.securityOriginPolicy());
4021     overrideMIMEType(other.contentType());
4022     setDecoder(other.decoder());
4023 }
4024 
4025 StyleSheetList&amp; Document::styleSheets()
4026 {
4027     if (!m_styleSheetList)
4028         m_styleSheetList = StyleSheetList::create(*this);
4029     return *m_styleSheetList;
4030 }
4031 
4032 void Document::updateElementsAffectedByMediaQueries()
4033 {
4034     ScriptDisallowedScope::InMainThread scriptDisallowedScope;
4035 
4036     // FIXME: copyToVector doesn&#39;t work with WeakHashSet
4037     Vector&lt;Ref&lt;HTMLImageElement&gt;&gt; images;
4038     images.reserveInitialCapacity(m_dynamicMediaQueryDependentImages.computeSize());
4039     for (auto&amp; image : m_dynamicMediaQueryDependentImages)
4040         images.append(image);
4041 
4042     for (auto&amp; image : images)
4043         image-&gt;evaluateDynamicMediaQueryDependencies();
4044 }
4045 
4046 void Document::evaluateMediaQueriesAndReportChanges()
4047 {
4048     if (!m_mediaQueryMatcher)
4049         return;
4050 
4051     m_mediaQueryMatcher-&gt;evaluateAll();
4052 }
4053 
4054 void Document::updateViewportUnitsOnResize()
4055 {
4056     if (!hasStyleWithViewportUnits())
4057         return;
4058 
4059     styleScope().resolver().clearCachedDeclarationsAffectedByViewportUnits();
4060 
4061     // FIXME: Ideally, we should save the list of elements that have viewport units and only iterate over those.
4062     for (Element* element = ElementTraversal::firstWithin(rootNode()); element; element = ElementTraversal::nextIncludingPseudo(*element)) {
4063         auto* renderer = element-&gt;renderer();
4064         if (renderer &amp;&amp; renderer-&gt;style().hasViewportUnits())
4065             element-&gt;invalidateStyle();
4066     }
4067 }
4068 
4069 void Document::setNeedsDOMWindowResizeEvent()
4070 {
4071     m_needsDOMWindowResizeEvent = true;
4072     scheduleTimedRenderingUpdate();
4073 }
4074 
4075 void Document::setNeedsVisualViewportResize()
4076 {
4077     m_needsVisualViewportResizeEvent = true;
4078     scheduleTimedRenderingUpdate();
4079 }
4080 
4081 // https://drafts.csswg.org/cssom-view/#run-the-resize-steps
4082 void Document::runResizeSteps()
4083 {
4084     // FIXME: The order of dispatching is not specified: https://github.com/WICG/visual-viewport/issues/65.
4085     if (m_needsDOMWindowResizeEvent) {
4086         LOG_WITH_STREAM(Events, stream &lt;&lt; &quot;Document&quot; &lt;&lt; this &lt;&lt; &quot;sending resize events to window&quot;);
4087         m_needsDOMWindowResizeEvent = false;
4088         dispatchWindowEvent(Event::create(eventNames().resizeEvent, Event::CanBubble::No, Event::IsCancelable::No));
4089     }
4090     if (m_needsVisualViewportResizeEvent) {
4091         LOG_WITH_STREAM(Events, stream &lt;&lt; &quot;Document&quot; &lt;&lt; this &lt;&lt; &quot;sending resize events to visualViewport&quot;);
4092         m_needsVisualViewportResizeEvent = false;
4093         if (auto* window = domWindow())
4094             window-&gt;visualViewport().dispatchEvent(Event::create(eventNames().resizeEvent, Event::CanBubble::No, Event::IsCancelable::No));
4095     }
4096 }
4097 
4098 void Document::addPendingScrollEventTarget(ContainerNode&amp; target)
4099 {
4100     if (!m_pendingScrollEventTargetList)
4101         m_pendingScrollEventTargetList = makeUnique&lt;PendingScrollEventTargetList&gt;();
4102 
4103     auto&amp; targets = m_pendingScrollEventTargetList-&gt;targets;
4104     if (targets.findMatching([&amp;] (auto&amp; entry) { return entry.ptr() == &amp;target; }) != notFound)
4105         return;
4106 
4107     if (targets.isEmpty())
4108         scheduleTimedRenderingUpdate();
4109 
4110     targets.append(target);
4111 }
4112 
4113 void Document::setNeedsVisualViewportScrollEvent()
4114 {
4115     if (!m_needsVisualViewportScrollEvent)
4116         scheduleTimedRenderingUpdate();
4117     m_needsVisualViewportScrollEvent = true;
4118 }
4119 
4120 // https://drafts.csswg.org/cssom-view/#run-the-scroll-steps
4121 void Document::runScrollSteps()
4122 {
4123     // FIXME: The order of dispatching is not specified: https://github.com/WICG/visual-viewport/issues/66.
4124     if (m_pendingScrollEventTargetList &amp;&amp; !m_pendingScrollEventTargetList-&gt;targets.isEmpty()) {
4125         LOG_WITH_STREAM(Events, stream &lt;&lt; &quot;Document&quot; &lt;&lt; this &lt;&lt; &quot;sending scroll events to pending scroll event targets&quot;);
4126         auto currentTargets = WTFMove(m_pendingScrollEventTargetList-&gt;targets);
4127         for (auto&amp; target : currentTargets) {
4128             auto bubbles = target-&gt;isDocumentNode() ? Event::CanBubble::Yes : Event::CanBubble::No;
4129             target-&gt;dispatchEvent(Event::create(eventNames().scrollEvent, bubbles, Event::IsCancelable::No));
4130         }
4131     }
4132     if (m_needsVisualViewportScrollEvent) {
4133         LOG_WITH_STREAM(Events, stream &lt;&lt; &quot;Document&quot; &lt;&lt; this &lt;&lt; &quot;sending scroll events to visualViewport&quot;);
4134         m_needsVisualViewportResizeEvent = false;
4135         if (auto* window = domWindow())
4136             window-&gt;visualViewport().dispatchEvent(Event::create(eventNames().scrollEvent, Event::CanBubble::No, Event::IsCancelable::No));
4137     }
4138 }
4139 
4140 void Document::addAudioProducer(MediaProducer&amp; audioProducer)
4141 {
4142     m_audioProducers.add(audioProducer);
4143     updateIsPlayingMedia();
4144 }
4145 
4146 void Document::removeAudioProducer(MediaProducer&amp; audioProducer)
4147 {
4148     RELEASE_ASSERT(isMainThread());
4149     m_audioProducers.remove(audioProducer);
4150     updateIsPlayingMedia();
4151 }
4152 
4153 void Document::noteUserInteractionWithMediaElement()
4154 {
4155     if (m_userHasInteractedWithMediaElement)
4156         return;
4157 
4158     if (!topDocument().userDidInteractWithPage())
4159         return;
4160 
4161     m_userHasInteractedWithMediaElement = true;
4162     updateIsPlayingMedia();
4163 }
4164 
4165 void Document::updateIsPlayingMedia(uint64_t sourceElementID)
4166 {
4167     ASSERT(!m_audioProducers.hasNullReferences());
4168     MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
4169     for (auto&amp; audioProducer : m_audioProducers)
4170         state |= audioProducer.mediaState();
4171 
4172 #if ENABLE(MEDIA_STREAM)
4173     state |= MediaStreamTrack::captureState(*this);
4174 #endif
4175 
4176 #if ENABLE(MEDIA_SESSION)
4177     if (HTMLMediaElement* sourceElement = HTMLMediaElement::elementWithID(sourceElementID)) {
4178         if (sourceElement-&gt;isPlaying())
4179             state |= MediaProducer::IsSourceElementPlaying;
4180 
4181         if (auto* session = sourceElement-&gt;session()) {
4182             if (auto* controls = session-&gt;controls()) {
4183                 if (controls-&gt;previousTrackEnabled())
4184                     state |= MediaProducer::IsPreviousTrackControlEnabled;
4185                 if (controls-&gt;nextTrackEnabled())
4186                     state |= MediaProducer::IsNextTrackControlEnabled;
4187             }
4188         }
4189     }
4190 #endif
4191 
4192     if (m_userHasInteractedWithMediaElement)
4193         state |= MediaProducer::HasUserInteractedWithMediaElement;
4194 
4195     if (state == m_mediaState)
4196         return;
4197 
4198 #if ENABLE(MEDIA_STREAM)
4199     bool captureStateChanged = MediaProducer::isCapturing(m_mediaState) != MediaProducer::isCapturing(state);
4200 #endif
4201 
4202     m_mediaState = state;
4203 
4204     if (page())
4205         page()-&gt;updateIsPlayingMedia(sourceElementID);
4206 
4207 #if ENABLE(MEDIA_STREAM)
4208     if (captureStateChanged)
4209         mediaStreamCaptureStateChanged();
4210 #endif
4211 }
4212 
4213 void Document::pageMutedStateDidChange()
4214 {
4215     for (auto&amp; audioProducer : m_audioProducers)
4216         audioProducer.pageMutedStateDidChange();
4217 
4218 #if ENABLE(MEDIA_STREAM)
4219     MediaStreamTrack::updateCaptureAccordingToMutedState(*this);
4220 #endif
4221 }
4222 
4223 static bool isNodeInSubtree(Node&amp; node, Node&amp; container, Document::NodeRemoval nodeRemoval)
4224 {
4225     if (nodeRemoval == Document::NodeRemoval::ChildrenOfNode)
4226         return node.isDescendantOf(container);
4227 
4228     return &amp;node == &amp;container || node.isDescendantOf(container);
4229 }
4230 
4231 void Document::adjustFocusedNodeOnNodeRemoval(Node&amp; node, NodeRemoval nodeRemoval)
4232 {
4233     if (!m_focusedElement || backForwardCacheState() != NotInBackForwardCache) // If the document is in the back/forward cache, then we don&#39;t need to clear out the focused node.
4234         return;
4235 
4236     Element* focusedElement = node.treeScope().focusedElementInScope();
4237     if (!focusedElement)
4238         return;
4239 
4240     if (isNodeInSubtree(*focusedElement, node, nodeRemoval)) {
4241         // FIXME: We should avoid synchronously updating the style inside setFocusedElement.
4242         // FIXME: Object elements should avoid loading a frame synchronously in a post style recalc callback.
4243         SubframeLoadingDisabler disabler(is&lt;ContainerNode&gt;(node) ? &amp;downcast&lt;ContainerNode&gt;(node) : nullptr);
4244         setFocusedElement(nullptr, FocusDirectionNone, FocusRemovalEventsMode::DoNotDispatch);
4245         // Set the focus navigation starting node to the previous focused element so that
4246         // we can fallback to the siblings or parent node for the next search.
4247         // Also we need to call removeFocusNavigationNodeOfSubtree after this function because
4248         // setFocusedElement(nullptr) will reset m_focusNavigationStartingNode.
4249         setFocusNavigationStartingNode(focusedElement);
4250     }
4251 }
4252 
4253 void Document::hoveredElementDidDetach(Element&amp; element)
4254 {
4255     if (!m_hoveredElement || &amp;element != m_hoveredElement)
4256         return;
4257 
4258     m_hoveredElement = element.parentElement();
4259     while (m_hoveredElement &amp;&amp; !m_hoveredElement-&gt;renderer())
4260         m_hoveredElement = m_hoveredElement-&gt;parentElement();
4261     if (frame())
4262         frame()-&gt;eventHandler().scheduleHoverStateUpdate();
4263 }
4264 
4265 void Document::elementInActiveChainDidDetach(Element&amp; element)
4266 {
4267     if (!m_activeElement || &amp;element != m_activeElement)
4268         return;
4269 
4270     m_activeElement = element.parentElement();
4271     while (m_activeElement &amp;&amp; !m_activeElement-&gt;renderer())
4272         m_activeElement = m_activeElement-&gt;parentElement();
4273 }
4274 
4275 void Document::invalidateRenderingDependentRegions()
4276 {
4277 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(TOUCH_EVENTS)
4278     setTouchEventRegionsNeedUpdate();
4279 #endif
4280 
4281 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(POINTER_EVENTS)
4282     if (auto* page = this-&gt;page()) {
4283         if (auto* frameView = view()) {
4284             if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
4285                 scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);
4286         }
4287     }
4288 #endif
4289 }
4290 
4291 bool Document::setFocusedElement(Element* element, FocusDirection direction, FocusRemovalEventsMode eventsMode)
4292 {
4293     RefPtr&lt;Element&gt; newFocusedElement = element;
4294     // Make sure newFocusedElement is actually in this document
4295     if (newFocusedElement &amp;&amp; (&amp;newFocusedElement-&gt;document() != this))
4296         return true;
4297 
4298     if (m_focusedElement == newFocusedElement)
4299         return true;
4300 
4301     if (backForwardCacheState() != NotInBackForwardCache)
4302         return false;
4303 
4304     bool focusChangeBlocked = false;
4305     RefPtr&lt;Element&gt; oldFocusedElement = WTFMove(m_focusedElement);
4306 
4307     // Remove focus from the existing focus node (if any)
4308     if (oldFocusedElement) {
4309         oldFocusedElement-&gt;setFocus(false);
4310         setFocusNavigationStartingNode(nullptr);
4311 
4312         if (eventsMode == FocusRemovalEventsMode::Dispatch) {
4313             // Dispatch a change event for form control elements that have been edited.
4314             if (is&lt;HTMLFormControlElement&gt;(*oldFocusedElement)) {
4315                 HTMLFormControlElement&amp; formControlElement = downcast&lt;HTMLFormControlElement&gt;(*oldFocusedElement);
4316                 if (formControlElement.wasChangedSinceLastFormControlChangeEvent())
4317                     formControlElement.dispatchFormControlChangeEvent();
4318             }
4319 
4320             // Dispatch the blur event and let the node do any other blur related activities (important for text fields)
4321             oldFocusedElement-&gt;dispatchBlurEvent(newFocusedElement.copyRef());
4322 
4323             if (m_focusedElement) {
4324                 // handler shifted focus
4325                 focusChangeBlocked = true;
4326                 newFocusedElement = nullptr;
4327             }
4328 
4329             oldFocusedElement-&gt;dispatchFocusOutEvent(eventNames().focusoutEvent, newFocusedElement.copyRef()); // DOM level 3 name for the bubbling blur event.
4330             // FIXME: We should remove firing DOMFocusOutEvent event when we are sure no content depends
4331             // on it, probably when &lt;rdar://problem/8503958&gt; is resolved.
4332             oldFocusedElement-&gt;dispatchFocusOutEvent(eventNames().DOMFocusOutEvent, newFocusedElement.copyRef()); // DOM level 2 name for compatibility.
4333 
4334             if (m_focusedElement) {
4335                 // handler shifted focus
4336                 focusChangeBlocked = true;
4337                 newFocusedElement = nullptr;
4338             }
4339         } else {
4340             // Match the order in HTMLTextFormControlElement::dispatchBlurEvent.
4341             if (is&lt;HTMLInputElement&gt;(*oldFocusedElement))
4342                 downcast&lt;HTMLInputElement&gt;(*oldFocusedElement).endEditing();
4343             if (page())
4344                 page()-&gt;chrome().client().elementDidBlur(*oldFocusedElement);
4345             ASSERT(!m_focusedElement);
4346         }
4347 
4348         if (oldFocusedElement-&gt;isRootEditableElement())
4349             frame()-&gt;editor().didEndEditing();
4350 
4351         if (view()) {
4352             if (Widget* oldWidget = widgetForElement(oldFocusedElement.get()))
4353                 oldWidget-&gt;setFocus(false);
4354             else
4355                 view()-&gt;setFocus(false);
4356         }
4357 
4358         if (is&lt;HTMLInputElement&gt;(oldFocusedElement)) {
4359             // HTMLInputElement::didBlur just scrolls text fields back to the beginning.
4360             // FIXME: This could be done asynchronusly.
4361             // Updating style may dispatch events due to PostResolutionCallback
4362             if (eventsMode == FocusRemovalEventsMode::Dispatch)
4363                 updateStyleIfNeeded();
4364             downcast&lt;HTMLInputElement&gt;(*oldFocusedElement).didBlur();
4365         }
4366     }
4367 
4368     if (newFocusedElement &amp;&amp; newFocusedElement-&gt;isFocusable()) {
4369         if (&amp;newFocusedElement-&gt;document() != this) {
4370             // Bluring oldFocusedElement may have moved newFocusedElement across documents.
4371             focusChangeBlocked = true;
4372             goto SetFocusedNodeDone;
4373         }
4374         if (newFocusedElement-&gt;isRootEditableElement() &amp;&amp; !acceptsEditingFocus(*newFocusedElement)) {
4375             // delegate blocks focus change
4376             focusChangeBlocked = true;
4377             goto SetFocusedNodeDone;
4378         }
4379         // Set focus on the new node
4380         m_focusedElement = newFocusedElement;
4381         setFocusNavigationStartingNode(m_focusedElement.get());
4382 
4383         // Dispatch the focus event and let the node do any other focus related activities (important for text fields)
4384         m_focusedElement-&gt;dispatchFocusEvent(oldFocusedElement.copyRef(), direction);
4385 
4386         if (m_focusedElement != newFocusedElement) {
4387             // handler shifted focus
4388             focusChangeBlocked = true;
4389             goto SetFocusedNodeDone;
4390         }
4391 
4392         m_focusedElement-&gt;dispatchFocusInEvent(eventNames().focusinEvent, oldFocusedElement.copyRef()); // DOM level 3 bubbling focus event.
4393 
4394         if (m_focusedElement != newFocusedElement) {
4395             // handler shifted focus
4396             focusChangeBlocked = true;
4397             goto SetFocusedNodeDone;
4398         }
4399 
4400         // FIXME: We should remove firing DOMFocusInEvent event when we are sure no content depends
4401         // on it, probably when &lt;rdar://problem/8503958&gt; is m.
4402         m_focusedElement-&gt;dispatchFocusInEvent(eventNames().DOMFocusInEvent, oldFocusedElement.copyRef()); // DOM level 2 for compatibility.
4403 
4404         if (m_focusedElement != newFocusedElement) {
4405             // handler shifted focus
4406             focusChangeBlocked = true;
4407             goto SetFocusedNodeDone;
4408         }
4409 
4410         m_focusedElement-&gt;setFocus(true);
4411 
4412         // The setFocus call triggers a blur and a focus event. Event handlers could cause the focused element to be cleared.
4413         if (m_focusedElement != newFocusedElement) {
4414             // handler shifted focus
4415             focusChangeBlocked = true;
4416             goto SetFocusedNodeDone;
4417         }
4418 
4419         if (m_focusedElement-&gt;isRootEditableElement())
4420             frame()-&gt;editor().didBeginEditing();
4421 
4422         // eww, I suck. set the qt focus correctly
4423         // ### find a better place in the code for this
4424         if (view()) {
4425             Widget* focusWidget = widgetForElement(m_focusedElement.get());
4426             if (focusWidget) {
4427                 // Make sure a widget has the right size before giving it focus.
4428                 // Otherwise, we are testing edge cases of the Widget code.
4429                 // Specifically, in WebCore this does not work well for text fields.
4430                 updateLayout();
4431                 // Re-get the widget in case updating the layout changed things.
4432                 focusWidget = widgetForElement(m_focusedElement.get());
4433             }
4434             if (focusWidget)
4435                 focusWidget-&gt;setFocus(true);
4436             else if (auto* frameView = view())
4437                 frameView-&gt;setFocus(true);
4438         }
4439     }
4440 
4441     if (!focusChangeBlocked &amp;&amp; m_focusedElement) {
4442         // Create the AXObject cache in a focus change because GTK relies on it.
4443         if (AXObjectCache* cache = axObjectCache())
4444             cache-&gt;deferFocusedUIElementChangeIfNeeded(oldFocusedElement.get(), newFocusedElement.get());
4445     }
4446 
4447     if (!focusChangeBlocked &amp;&amp; page())
4448         page()-&gt;chrome().focusedElementChanged(m_focusedElement.get());
4449 
4450 SetFocusedNodeDone:
4451     // Updating style may dispatch events due to PostResolutionCallback
4452     // FIXME: Why is synchronous style update needed here at all?
4453     if (eventsMode == FocusRemovalEventsMode::Dispatch)
4454         updateStyleIfNeeded();
4455     return !focusChangeBlocked;
4456 }
4457 
4458 static bool shouldResetFocusNavigationStartingNode(Node&amp; node)
4459 {
4460     // Setting focus navigation starting node to the following nodes means that we should start
4461     // the search from the beginning of the document.
4462     return is&lt;HTMLHtmlElement&gt;(node) || is&lt;HTMLDocument&gt;(node);
4463 }
4464 
4465 void Document::setFocusNavigationStartingNode(Node* node)
4466 {
4467     if (!m_frame)
4468         return;
4469 
4470     m_focusNavigationStartingNodeIsRemoved = false;
4471     if (!node || shouldResetFocusNavigationStartingNode(*node)) {
4472         m_focusNavigationStartingNode = nullptr;
4473         return;
4474     }
4475 
4476     ASSERT(!node || node != this);
4477     m_focusNavigationStartingNode = node;
4478 }
4479 
4480 Element* Document::focusNavigationStartingNode(FocusDirection direction) const
4481 {
4482     if (m_focusedElement) {
4483         if (!m_focusNavigationStartingNode || !m_focusNavigationStartingNode-&gt;isDescendantOf(m_focusedElement.get()))
4484             return m_focusedElement.get();
4485     }
4486 
4487     if (!m_focusNavigationStartingNode)
4488         return nullptr;
4489 
4490     Node* node = m_focusNavigationStartingNode.get();
4491 
4492     // When the node was removed from the document tree. This case is not specified in the spec:
4493     // https://html.spec.whatwg.org/multipage/interaction.html#sequential-focus-navigation-starting-point
4494     // Current behaivor is to move the sequential navigation node to / after (based on the focus direction)
4495     // the previous sibling of the removed node.
4496     if (m_focusNavigationStartingNodeIsRemoved) {
4497         Node* nextNode = NodeTraversal::next(*node);
4498         if (!nextNode)
4499             nextNode = node;
4500         if (direction == FocusDirectionForward)
4501             return ElementTraversal::previous(*nextNode);
4502         if (is&lt;Element&gt;(*nextNode))
4503             return downcast&lt;Element&gt;(nextNode);
4504         return ElementTraversal::next(*nextNode);
4505     }
4506 
4507     if (is&lt;Element&gt;(*node))
4508         return downcast&lt;Element&gt;(node);
4509     if (Element* elementBeforeNextFocusableElement = direction == FocusDirectionForward ? ElementTraversal::previous(*node) : ElementTraversal::next(*node))
4510         return elementBeforeNextFocusableElement;
4511     return node-&gt;parentOrShadowHostElement();
4512 }
4513 
4514 void Document::setCSSTarget(Element* targetNode)
4515 {
4516     if (m_cssTarget)
4517         m_cssTarget-&gt;invalidateStyleForSubtree();
4518     m_cssTarget = targetNode;
4519     if (targetNode)
4520         targetNode-&gt;invalidateStyleForSubtree();
4521 }
4522 
4523 void Document::registerNodeListForInvalidation(LiveNodeList&amp; list)
4524 {
4525     m_nodeListAndCollectionCounts[list.invalidationType()]++;
4526     if (!list.isRootedAtDocument())
4527         return;
4528     ASSERT(!list.isRegisteredForInvalidationAtDocument());
4529     list.setRegisteredForInvalidationAtDocument(true);
4530     m_listsInvalidatedAtDocument.add(&amp;list);
4531 }
4532 
4533 void Document::unregisterNodeListForInvalidation(LiveNodeList&amp; list)
4534 {
4535     m_nodeListAndCollectionCounts[list.invalidationType()]--;
4536     if (!list.isRegisteredForInvalidationAtDocument())
4537         return;
4538 
4539     list.setRegisteredForInvalidationAtDocument(false);
4540     ASSERT(m_listsInvalidatedAtDocument.contains(&amp;list));
4541     m_listsInvalidatedAtDocument.remove(&amp;list);
4542 }
4543 
4544 void Document::registerCollection(HTMLCollection&amp; collection)
4545 {
4546     m_nodeListAndCollectionCounts[collection.invalidationType()]++;
4547     if (collection.isRootedAtDocument())
4548         m_collectionsInvalidatedAtDocument.add(&amp;collection);
4549 }
4550 
4551 void Document::unregisterCollection(HTMLCollection&amp; collection)
4552 {
4553     ASSERT(m_nodeListAndCollectionCounts[collection.invalidationType()]);
4554     m_nodeListAndCollectionCounts[collection.invalidationType()]--;
4555     if (!collection.isRootedAtDocument())
4556         return;
4557 
4558     m_collectionsInvalidatedAtDocument.remove(&amp;collection);
4559 }
4560 
4561 void Document::collectionCachedIdNameMap(const HTMLCollection&amp; collection)
4562 {
4563     ASSERT_UNUSED(collection, collection.hasNamedElementCache());
4564     m_nodeListAndCollectionCounts[InvalidateOnIdNameAttrChange]++;
4565 }
4566 
4567 void Document::collectionWillClearIdNameMap(const HTMLCollection&amp; collection)
4568 {
4569     ASSERT_UNUSED(collection, collection.hasNamedElementCache());
4570     ASSERT(m_nodeListAndCollectionCounts[InvalidateOnIdNameAttrChange]);
4571     m_nodeListAndCollectionCounts[InvalidateOnIdNameAttrChange]--;
4572 }
4573 
4574 void Document::attachNodeIterator(NodeIterator&amp; iterator)
4575 {
4576     m_nodeIterators.add(&amp;iterator);
4577 }
4578 
4579 void Document::detachNodeIterator(NodeIterator&amp; iterator)
4580 {
4581     // The node iterator can be detached without having been attached if its root node didn&#39;t have a document
4582     // when the iterator was created, but has it now.
4583     m_nodeIterators.remove(&amp;iterator);
4584 }
4585 
4586 void Document::moveNodeIteratorsToNewDocumentSlowCase(Node&amp; node, Document&amp; newDocument)
4587 {
4588     ASSERT(!m_nodeIterators.isEmpty());
4589     for (auto* iterator : copyToVector(m_nodeIterators)) {
4590         if (&amp;iterator-&gt;root() == &amp;node) {
4591             detachNodeIterator(*iterator);
4592             newDocument.attachNodeIterator(*iterator);
4593         }
4594     }
4595 }
4596 
4597 void Document::updateRangesAfterChildrenChanged(ContainerNode&amp; container)
4598 {
4599     for (auto* range : m_ranges)
4600         range-&gt;nodeChildrenChanged(container);
4601 }
4602 
4603 void Document::nodeChildrenWillBeRemoved(ContainerNode&amp; container)
4604 {
4605     ASSERT(ScriptDisallowedScope::InMainThread::hasDisallowedScope());
4606 
4607     adjustFocusedNodeOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);
4608     adjustFocusNavigationNodeOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);
4609 
4610 #if ENABLE(FULLSCREEN_API)
4611     m_fullscreenManager-&gt;adjustFullscreenElementOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);
4612 #endif
4613 
4614     for (auto* range : m_ranges)
4615         range-&gt;nodeChildrenWillBeRemoved(container);
4616 
4617     for (auto* it : m_nodeIterators) {
4618         for (Node* n = container.firstChild(); n; n = n-&gt;nextSibling())
4619             it-&gt;nodeWillBeRemoved(*n);
4620     }
4621 
4622     if (RefPtr&lt;Frame&gt; frame = this-&gt;frame()) {
4623         for (Node* n = container.firstChild(); n; n = n-&gt;nextSibling()) {
4624             frame-&gt;eventHandler().nodeWillBeRemoved(*n);
4625             frame-&gt;selection().nodeWillBeRemoved(*n);
4626             frame-&gt;page()-&gt;dragCaretController().nodeWillBeRemoved(*n);
4627         }
4628     }
4629 
4630     if (m_markers-&gt;hasMarkers()) {
4631         for (Text* textNode = TextNodeTraversal::firstChild(container); textNode; textNode = TextNodeTraversal::nextSibling(*textNode))
4632             m_markers-&gt;removeMarkers(*textNode);
4633     }
4634 }
4635 
4636 void Document::nodeWillBeRemoved(Node&amp; node)
4637 {
4638     ASSERT(ScriptDisallowedScope::InMainThread::hasDisallowedScope());
4639 
4640     adjustFocusedNodeOnNodeRemoval(node);
4641     adjustFocusNavigationNodeOnNodeRemoval(node);
4642 
4643 #if ENABLE(FULLSCREEN_API)
4644     m_fullscreenManager-&gt;adjustFullscreenElementOnNodeRemoval(node, NodeRemoval::Node);
4645 #endif
4646 
4647     for (auto* it : m_nodeIterators)
4648         it-&gt;nodeWillBeRemoved(node);
4649 
4650     for (auto* range : m_ranges)
4651         range-&gt;nodeWillBeRemoved(node);
4652 
4653     if (RefPtr&lt;Frame&gt; frame = this-&gt;frame()) {
4654         frame-&gt;eventHandler().nodeWillBeRemoved(node);
4655         frame-&gt;selection().nodeWillBeRemoved(node);
4656         frame-&gt;page()-&gt;dragCaretController().nodeWillBeRemoved(node);
4657     }
4658 
4659     if (is&lt;Text&gt;(node))
4660         m_markers-&gt;removeMarkers(node);
4661 }
4662 
4663 void Document::parentlessNodeMovedToNewDocument(Node&amp; node)
4664 {
4665     Vector&lt;Range*, 5&gt; rangesAffected;
4666 
4667     for (auto* range : m_ranges) {
4668         if (range-&gt;parentlessNodeMovedToNewDocumentAffectsRange(node))
4669             rangesAffected.append(range);
4670     }
4671 
4672     for (auto* range : rangesAffected)
4673         range-&gt;updateRangeForParentlessNodeMovedToNewDocument(node);
4674 }
4675 
4676 static Node* fallbackFocusNavigationStartingNodeAfterRemoval(Node&amp; node)
4677 {
4678     return node.previousSibling() ? node.previousSibling() : node.parentNode();
4679 }
4680 
4681 void Document::adjustFocusNavigationNodeOnNodeRemoval(Node&amp; node, NodeRemoval nodeRemoval)
4682 {
4683     if (!m_focusNavigationStartingNode)
4684         return;
4685 
4686     if (isNodeInSubtree(*m_focusNavigationStartingNode, node, nodeRemoval)) {
4687         auto* newNode = (nodeRemoval == NodeRemoval::ChildrenOfNode) ? &amp;node : fallbackFocusNavigationStartingNodeAfterRemoval(node);
4688         m_focusNavigationStartingNode = (newNode != this) ? newNode : nullptr;
4689         m_focusNavigationStartingNodeIsRemoved = true;
4690     }
4691 }
4692 
4693 void Document::textInserted(Node&amp; text, unsigned offset, unsigned length)
4694 {
4695     if (!m_ranges.isEmpty()) {
4696         for (auto* range : m_ranges)
4697             range-&gt;textInserted(text, offset, length);
4698     }
4699 
4700     // Update the markers for spelling and grammar checking.
4701     m_markers-&gt;shiftMarkers(text, offset, length);
4702 
4703 #if ENABLE(PLATFORM_DRIVEN_TEXT_CHECKING)
4704     // Freshly inserted text is expected to not inherit PlatformTextChecking markers.
4705     m_markers-&gt;removeMarkers(text, offset, length, DocumentMarker::PlatformTextChecking);
4706 #endif
4707 }
4708 
4709 void Document::textRemoved(Node&amp; text, unsigned offset, unsigned length)
4710 {
4711     if (!m_ranges.isEmpty()) {
4712         for (auto* range : m_ranges)
4713             range-&gt;textRemoved(text, offset, length);
4714     }
4715 
4716     // Update the markers for spelling and grammar checking.
4717     m_markers-&gt;removeMarkers(text, offset, length);
4718     m_markers-&gt;shiftMarkers(text, offset + length, 0 - length);
4719 }
4720 
4721 void Document::textNodesMerged(Text&amp; oldNode, unsigned offset)
4722 {
4723     if (!m_ranges.isEmpty()) {
4724         NodeWithIndex oldNodeWithIndex(&amp;oldNode);
4725         for (auto* range : m_ranges)
4726             range-&gt;textNodesMerged(oldNodeWithIndex, offset);
4727     }
4728 
4729     // FIXME: This should update markers for spelling and grammar checking.
4730 }
4731 
4732 void Document::textNodeSplit(Text&amp; oldNode)
4733 {
4734     for (auto* range : m_ranges)
4735         range-&gt;textNodeSplit(oldNode);
4736 
4737     // FIXME: This should update markers for spelling and grammar checking.
4738 }
4739 
4740 void Document::createDOMWindow()
4741 {
4742     ASSERT(m_frame);
4743     ASSERT(!m_domWindow);
4744 
4745     m_domWindow = DOMWindow::create(*this);
4746 
4747     ASSERT(m_domWindow-&gt;document() == this);
4748     ASSERT(m_domWindow-&gt;frame() == m_frame);
4749 
4750     m_frame-&gt;loader().client().didCreateWindow(*m_domWindow);
4751 }
4752 
4753 void Document::takeDOMWindowFrom(Document&amp; document)
4754 {
4755     ASSERT(m_frame);
4756     ASSERT(!m_domWindow);
4757     ASSERT(document.m_domWindow);
4758     // A valid DOMWindow is needed by CachedFrame for its documents.
4759     ASSERT(backForwardCacheState() == NotInBackForwardCache);
4760 
4761     m_domWindow = WTFMove(document.m_domWindow);
4762     m_domWindow-&gt;didSecureTransitionTo(*this);
4763 
4764     ASSERT(m_domWindow-&gt;document() == this);
4765     ASSERT(m_domWindow-&gt;frame() == m_frame);
4766 }
4767 
4768 WindowProxy* Document::windowProxy() const
4769 {
4770     if (!m_frame)
4771         return nullptr;
4772     return &amp;m_frame-&gt;windowProxy();
4773 }
4774 
4775 Document&amp; Document::contextDocument() const
4776 {
4777     if (m_contextDocument)
4778         return *m_contextDocument.get();
4779     return const_cast&lt;Document&amp;&gt;(*this);
4780 }
4781 
4782 void Document::setAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)
4783 {
4784     setAttributeEventListener(eventType, JSLazyEventListener::create(*this, attributeName, attributeValue), isolatedWorld);
4785 }
4786 
4787 void Document::setWindowAttributeEventListener(const AtomString&amp; eventType, RefPtr&lt;EventListener&gt;&amp;&amp; listener, DOMWrapperWorld&amp; isolatedWorld)
4788 {
4789     if (!m_domWindow)
4790         return;
4791     m_domWindow-&gt;setAttributeEventListener(eventType, WTFMove(listener), isolatedWorld);
4792 }
4793 
4794 void Document::setWindowAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)
4795 {
4796     if (!m_domWindow)
4797         return;
4798     if (!m_domWindow-&gt;frame())
4799         return;
4800     setWindowAttributeEventListener(eventType, JSLazyEventListener::create(*m_domWindow, attributeName, attributeValue), isolatedWorld);
4801 }
4802 
4803 EventListener* Document::getWindowAttributeEventListener(const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
4804 {
4805     if (!m_domWindow)
4806         return nullptr;
4807     return m_domWindow-&gt;attributeEventListener(eventType, isolatedWorld);
4808 }
4809 
4810 void Document::dispatchWindowEvent(Event&amp; event, EventTarget* target)
4811 {
4812     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
4813     if (!m_domWindow)
4814         return;
4815     m_domWindow-&gt;dispatchEvent(event, target);
4816 }
4817 
4818 void Document::dispatchWindowLoadEvent()
4819 {
4820     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
4821     if (!m_domWindow)
4822         return;
4823     m_domWindow-&gt;dispatchLoadEvent();
4824     m_loadEventFinished = true;
4825     m_cachedResourceLoader-&gt;documentDidFinishLoadEvent();
4826 }
4827 
4828 void Document::queueTaskToDispatchEvent(TaskSource source, Ref&lt;Event&gt;&amp;&amp; event)
4829 {
4830     eventLoop().queueTask(source, [document = makeRef(*this), event = WTFMove(event)] {
4831         document-&gt;dispatchEvent(event);
4832     });
4833 }
4834 
4835 void Document::queueTaskToDispatchEventOnWindow(TaskSource source, Ref&lt;Event&gt;&amp;&amp; event)
4836 {
4837     eventLoop().queueTask(source, [this, protectedThis = makeRef(*this), event = WTFMove(event)] {
4838         if (!m_domWindow)
4839             return;
4840         m_domWindow-&gt;dispatchEvent(event);
4841     });
4842 }
4843 
4844 void Document::enqueueOverflowEvent(Ref&lt;Event&gt;&amp;&amp; event)
4845 {
4846     // https://developer.mozilla.org/en-US/docs/Web/API/Element/overflow_event
4847     // FIXME: This event is totally unspecified.
4848     auto* target = event-&gt;target();
4849     RELEASE_ASSERT(target);
4850     RELEASE_ASSERT(is&lt;Node&gt;(target));
4851     eventLoop().queueTask(TaskSource::DOMManipulation, [protectedTarget = GCReachableRef&lt;Node&gt;(downcast&lt;Node&gt;(*target)), event = WTFMove(event)] {
4852         protectedTarget-&gt;dispatchEvent(event);
4853     });
4854 }
4855 
4856 ExceptionOr&lt;Ref&lt;Event&gt;&gt; Document::createEvent(const String&amp; type)
4857 {
4858     // Please do *not* add new event classes to this function unless they are required
4859     // for compatibility with the DOM specification or some actual legacy web content.
4860 
4861     // This mechanism is superceded by use of event constructors.
4862     // That is what we should use for any new event classes.
4863 
4864     // The following strings are the ones from the DOM specification
4865     // &lt;https://dom.spec.whatwg.org/#dom-document-createevent&gt;.
4866 
4867     if (equalLettersIgnoringASCIICase(type, &quot;beforeunloadevent&quot;))
4868         return Ref&lt;Event&gt; { BeforeUnloadEvent::createForBindings() };
4869     if (equalLettersIgnoringASCIICase(type, &quot;compositionevent&quot;))
4870         return Ref&lt;Event&gt; { CompositionEvent::createForBindings() };
4871     if (equalLettersIgnoringASCIICase(type, &quot;customevent&quot;))
4872         return Ref&lt;Event&gt; { CustomEvent::create() };
4873     if (equalLettersIgnoringASCIICase(type, &quot;dragevent&quot;))
4874         return Ref&lt;Event&gt; { DragEvent::createForBindings() };
4875     if (equalLettersIgnoringASCIICase(type, &quot;event&quot;) || equalLettersIgnoringASCIICase(type, &quot;events&quot;) || equalLettersIgnoringASCIICase(type, &quot;htmlevents&quot;) || equalLettersIgnoringASCIICase(type, &quot;svgevents&quot;))
4876         return Event::createForBindings();
4877     if (equalLettersIgnoringASCIICase(type, &quot;focusevent&quot;))
4878         return Ref&lt;Event&gt; { FocusEvent::createForBindings() };
4879     if (equalLettersIgnoringASCIICase(type, &quot;hashchangeevent&quot;))
4880         return Ref&lt;Event&gt; { HashChangeEvent::createForBindings() };
4881     if (equalLettersIgnoringASCIICase(type, &quot;keyboardevent&quot;))
4882         return Ref&lt;Event&gt; { KeyboardEvent::createForBindings() };
4883     if (equalLettersIgnoringASCIICase(type, &quot;messageevent&quot;))
4884         return Ref&lt;Event&gt; { MessageEvent::createForBindings() };
4885     if (equalLettersIgnoringASCIICase(type, &quot;storageevent&quot;))
4886         return Ref&lt;Event&gt; { StorageEvent::createForBindings() };
4887     if (equalLettersIgnoringASCIICase(type, &quot;mouseevent&quot;) || equalLettersIgnoringASCIICase(type, &quot;mouseevents&quot;))
4888         return Ref&lt;Event&gt; { MouseEvent::createForBindings() };
4889     if (equalLettersIgnoringASCIICase(type, &quot;textevent&quot;))
4890         return Ref&lt;Event&gt; { TextEvent::createForBindings() }; // FIXME: HTML specification says this should create a CompositionEvent, not a TextEvent.
4891     if (equalLettersIgnoringASCIICase(type, &quot;uievent&quot;) || equalLettersIgnoringASCIICase(type, &quot;uievents&quot;))
4892         return Ref&lt;Event&gt; { UIEvent::createForBindings() };
4893 
4894     // FIXME: Consider including support for these event classes even when device orientation
4895     // support is not enabled.
4896 #if ENABLE(DEVICE_ORIENTATION)
4897     if (equalLettersIgnoringASCIICase(type, &quot;devicemotionevent&quot;))
4898         return Ref&lt;Event&gt; { DeviceMotionEvent::createForBindings() };
4899     if (equalLettersIgnoringASCIICase(type, &quot;deviceorientationevent&quot;))
4900         return Ref&lt;Event&gt; { DeviceOrientationEvent::createForBindings() };
4901 #endif
4902 
4903 #if ENABLE(TOUCH_EVENTS)
4904     if (equalLettersIgnoringASCIICase(type, &quot;touchevent&quot;))
4905         return Ref&lt;Event&gt; { TouchEvent::createForBindings() };
4906 #endif
4907 
4908     // FIXME: Add support for &quot;dragevent&quot;, which the DOM specification calls for.
4909 
4910     // The following string comes from the SVG specification
4911     // &lt;http://www.w3.org/TR/SVG/script.html#InterfaceSVGZoomEvent&gt;
4912     // However, since there is no provision for initializing the event once it is created,
4913     // there is no practical value in this feature.
4914     // FIXME: Confirm there is no content depending on this and remove it.
4915 
4916     if (equalLettersIgnoringASCIICase(type, &quot;svgzoomevents&quot;))
4917         return Ref&lt;Event&gt; { SVGZoomEvent::createForBindings() };
4918 
4919     // The following strings are not part of the DOM specification and we would like to eliminate them.
4920     // However, we currently include them until we resolve any issues with backward compatibility.
4921     // FIXME: For each of the strings below, confirm that there is no content depending on it and remove
4922     // the string, remove the createForBindings function, and also consider removing the corresponding
4923     // init function for that class.
4924 
4925     if (equalLettersIgnoringASCIICase(type, &quot;keyboardevents&quot;))
4926         return Ref&lt;Event&gt; { KeyboardEvent::createForBindings() };
4927     if (equalLettersIgnoringASCIICase(type, &quot;mutationevent&quot;) || equalLettersIgnoringASCIICase(type, &quot;mutationevents&quot;))
4928         return Ref&lt;Event&gt; { MutationEvent::createForBindings() };
4929     if (equalLettersIgnoringASCIICase(type, &quot;overflowevent&quot;))
4930         return Ref&lt;Event&gt; { OverflowEvent::createForBindings() };
4931     if (equalLettersIgnoringASCIICase(type, &quot;popstateevent&quot;))
4932         return Ref&lt;Event&gt; { PopStateEvent::createForBindings() };
4933     if (equalLettersIgnoringASCIICase(type, &quot;wheelevent&quot;))
4934         return Ref&lt;Event&gt; { WheelEvent::createForBindings() };
4935 
4936     return Exception { NotSupportedError };
4937 }
4938 
4939 bool Document::hasListenerTypeForEventType(PlatformEvent::Type eventType) const
4940 {
4941     switch (eventType) {
4942     case PlatformEvent::MouseForceChanged:
4943         return m_listenerTypes &amp; Document::FORCECHANGED_LISTENER;
4944     case PlatformEvent::MouseForceDown:
4945         return m_listenerTypes &amp; Document::FORCEDOWN_LISTENER;
4946     case PlatformEvent::MouseForceUp:
4947         return m_listenerTypes &amp; Document::FORCEUP_LISTENER;
4948     case PlatformEvent::MouseScroll:
4949         return m_listenerTypes &amp; Document::SCROLL_LISTENER;
4950     default:
4951         return false;
4952     }
4953 }
4954 
4955 void Document::addListenerTypeIfNeeded(const AtomString&amp; eventType)
4956 {
4957     if (eventType == eventNames().DOMSubtreeModifiedEvent)
4958         addListenerType(DOMSUBTREEMODIFIED_LISTENER);
4959     else if (eventType == eventNames().DOMNodeInsertedEvent)
4960         addListenerType(DOMNODEINSERTED_LISTENER);
4961     else if (eventType == eventNames().DOMNodeRemovedEvent)
4962         addListenerType(DOMNODEREMOVED_LISTENER);
4963     else if (eventType == eventNames().DOMNodeRemovedFromDocumentEvent)
4964         addListenerType(DOMNODEREMOVEDFROMDOCUMENT_LISTENER);
4965     else if (eventType == eventNames().DOMNodeInsertedIntoDocumentEvent)
4966         addListenerType(DOMNODEINSERTEDINTODOCUMENT_LISTENER);
4967     else if (eventType == eventNames().DOMCharacterDataModifiedEvent)
4968         addListenerType(DOMCHARACTERDATAMODIFIED_LISTENER);
4969     else if (eventType == eventNames().overflowchangedEvent)
4970         addListenerType(OVERFLOWCHANGED_LISTENER);
4971     else if (eventType == eventNames().webkitAnimationStartEvent || eventType == eventNames().animationstartEvent)
4972         addListenerType(ANIMATIONSTART_LISTENER);
4973     else if (eventType == eventNames().webkitAnimationEndEvent || eventType == eventNames().animationendEvent)
4974         addListenerType(ANIMATIONEND_LISTENER);
4975     else if (eventType == eventNames().webkitAnimationIterationEvent || eventType == eventNames().animationiterationEvent)
4976         addListenerType(ANIMATIONITERATION_LISTENER);
4977     else if (eventType == eventNames().webkitTransitionEndEvent || eventType == eventNames().transitionendEvent)
4978         addListenerType(TRANSITIONEND_LISTENER);
4979     else if (eventType == eventNames().beforeloadEvent)
4980         addListenerType(BEFORELOAD_LISTENER);
4981     else if (eventType == eventNames().scrollEvent)
4982         addListenerType(SCROLL_LISTENER);
4983     else if (eventType == eventNames().webkitmouseforcewillbeginEvent)
4984         addListenerType(FORCEWILLBEGIN_LISTENER);
4985     else if (eventType == eventNames().webkitmouseforcechangedEvent)
4986         addListenerType(FORCECHANGED_LISTENER);
4987     else if (eventType == eventNames().webkitmouseforcedownEvent)
4988         addListenerType(FORCEDOWN_LISTENER);
4989     else if (eventType == eventNames().webkitmouseforceupEvent)
4990         addListenerType(FORCEUP_LISTENER);
4991     else if (eventType == eventNames().resizeEvent)
4992         addListenerType(RESIZE_LISTENER);
4993 }
4994 
4995 HTMLFrameOwnerElement* Document::ownerElement() const
4996 {
4997     if (!frame())
4998         return nullptr;
4999     return frame()-&gt;ownerElement();
5000 }
5001 
5002 // https://html.spec.whatwg.org/#cookie-averse-document-object
5003 bool Document::isCookieAverse() const
5004 {
5005     // A Document that has no browsing context is cookie-averse.
5006     if (!frame())
5007         return true;
5008 
5009     URL cookieURL = this-&gt;cookieURL();
5010 
5011     // This is not part of the specification but we have historically allowed cookies over file protocol
5012     // and some developers rely on this for testing.
5013     if (cookieURL.isLocalFile())
5014         return false;
5015 
5016     // A Document whose URL&#39;s scheme is not a network scheme is cookie-averse (https://fetch.spec.whatwg.org/#network-scheme).
5017     return !cookieURL.protocolIsInHTTPFamily() &amp;&amp; !cookieURL.protocolIs(&quot;ftp&quot;);
5018 }
5019 
5020 ExceptionOr&lt;String&gt; Document::cookie()
5021 {
5022     if (page() &amp;&amp; !page()-&gt;settings().cookieEnabled())
5023         return String();
5024 
5025     if (isCookieAverse())
5026         return String();
5027 
5028     if (!securityOrigin().canAccessCookies())
5029         return Exception { SecurityError };
5030 
5031     URL cookieURL = this-&gt;cookieURL();
5032     if (cookieURL.isEmpty())
5033         return String();
5034 
5035     if (!isDOMCookieCacheValid() &amp;&amp; page())
5036         setCachedDOMCookies(page()-&gt;cookieJar().cookies(*this, cookieURL));
5037 
5038     return String { cachedDOMCookies() };
5039 }
5040 
5041 ExceptionOr&lt;void&gt; Document::setCookie(const String&amp; value)
5042 {
5043     if (page() &amp;&amp; !page()-&gt;settings().cookieEnabled())
5044         return { };
5045 
5046     if (isCookieAverse())
5047         return { };
5048 
5049     if (!securityOrigin().canAccessCookies())
5050         return Exception { SecurityError };
5051 
5052     URL cookieURL = this-&gt;cookieURL();
5053     if (cookieURL.isEmpty())
5054         return { };
5055 
5056     invalidateDOMCookieCache();
5057     if (page())
5058         page()-&gt;cookieJar().setCookies(*this, cookieURL, value);
5059     return { };
5060 }
5061 
5062 String Document::referrer()
5063 {
5064 #if ENABLE(RESOURCE_LOAD_STATISTICS)
5065     if (!m_referrerOverride.isEmpty())
5066         return m_referrerOverride;
5067     if (DeprecatedGlobalSettings::resourceLoadStatisticsEnabled() &amp;&amp; frame()) {
5068         auto referrerStr = frame()-&gt;loader().referrer();
5069         if (!referrerStr.isEmpty()) {
5070             URL referrerURL { URL(), referrerStr };
5071             RegistrableDomain referrerRegistrableDomain { referrerURL };
5072             if (!referrerRegistrableDomain.matches(securityOrigin().data())) {
5073                 m_referrerOverride = referrerURL.protocolHostAndPort();
5074                 return m_referrerOverride;
5075             }
5076         }
5077     }
5078 #endif
5079     if (frame())
5080         return frame()-&gt;loader().referrer();
5081     return String();
5082 }
5083 
5084 String Document::domain() const
5085 {
5086     return securityOrigin().domain();
5087 }
5088 
5089 ExceptionOr&lt;void&gt; Document::setDomain(const String&amp; newDomain)
5090 {
5091     if (!frame())
5092         return Exception { SecurityError, &quot;A browsing context is required to set a domain.&quot; };
5093 
5094     if (isSandboxed(SandboxDocumentDomain))
5095         return Exception { SecurityError, &quot;Assignment is forbidden for sandboxed iframes.&quot; };
5096 
5097     if (LegacySchemeRegistry::isDomainRelaxationForbiddenForURLScheme(securityOrigin().protocol()))
5098         return Exception { SecurityError };
5099 
5100     // FIXME: We should add logging indicating why a domain was not allowed.
5101 
5102     const String&amp; effectiveDomain = domain();
5103     if (effectiveDomain.isEmpty())
5104         return Exception { SecurityError, &quot;The document has a null effectiveDomain.&quot; };
5105 
5106     if (!securityOrigin().isMatchingRegistrableDomainSuffix(newDomain, settings().treatIPAddressAsDomain()))
5107         return Exception { SecurityError, &quot;Attempted to use a non-registrable domain.&quot; };
5108 
5109     securityOrigin().setDomainFromDOM(newDomain);
5110     return { };
5111 }
5112 
5113 void Document::overrideLastModified(const Optional&lt;WallTime&gt;&amp; lastModified)
5114 {
5115     m_overrideLastModified = lastModified;
5116 }
5117 
5118 // http://www.whatwg.org/specs/web-apps/current-work/#dom-document-lastmodified
5119 String Document::lastModified() const
5120 {
5121     Optional&lt;WallTime&gt; dateTime;
5122     if (m_overrideLastModified)
5123         dateTime = m_overrideLastModified;
5124     else if (loader())
5125         dateTime = loader()-&gt;response().lastModified();
5126 
5127     // FIXME: If this document came from the file system, the HTML specification tells
5128     // us to read the last modification date from the file system.
5129     if (!dateTime)
5130         dateTime = WallTime::now();
5131 
5132     auto ctime = dateTime.value().secondsSinceEpoch().secondsAs&lt;time_t&gt;();
5133     auto localDateTime = std::localtime(&amp;ctime);
5134     return makeString(pad(&#39;0&#39;, 2, localDateTime-&gt;tm_mon + 1), &#39;/&#39;,
5135         pad(&#39;0&#39;, 2, localDateTime-&gt;tm_mday), &#39;/&#39;,
5136         pad(&#39;0&#39;, 4, 1900 + localDateTime-&gt;tm_year), &#39; &#39;,
5137         pad(&#39;0&#39;, 2, localDateTime-&gt;tm_hour), &#39;:&#39;,
5138         pad(&#39;0&#39;, 2, localDateTime-&gt;tm_min), &#39;:&#39;,
5139         pad(&#39;0&#39;, 2, localDateTime-&gt;tm_sec));
5140 }
5141 
5142 void Document::setCookieURL(const URL&amp; url)
5143 {
5144     if (m_cookieURL == url)
5145         return;
5146     m_cookieURL = url;
5147     invalidateDOMCookieCache();
5148 }
5149 
5150 static bool isValidNameNonASCII(const LChar* characters, unsigned length)
5151 {
5152     if (!isValidNameStart(characters[0]))
5153         return false;
5154 
5155     for (unsigned i = 1; i &lt; length; ++i) {
5156         if (!isValidNamePart(characters[i]))
5157             return false;
5158     }
5159 
5160     return true;
5161 }
5162 
5163 static bool isValidNameNonASCII(const UChar* characters, unsigned length)
5164 {
5165     unsigned i = 0;
5166 
5167     UChar32 c;
5168     U16_NEXT(characters, i, length, c);
5169     if (!isValidNameStart(c))
5170         return false;
5171 
5172     while (i &lt; length) {
5173         U16_NEXT(characters, i, length, c);
5174         if (!isValidNamePart(c))
5175             return false;
5176     }
5177 
5178     return true;
5179 }
5180 
5181 template&lt;typename CharType&gt;
5182 static inline bool isValidNameASCII(const CharType* characters, unsigned length)
5183 {
5184     CharType c = characters[0];
5185     if (!(isASCIIAlpha(c) || c == &#39;:&#39; || c == &#39;_&#39;))
5186         return false;
5187 
5188     for (unsigned i = 1; i &lt; length; ++i) {
5189         c = characters[i];
5190         if (!(isASCIIAlphanumeric(c) || c == &#39;:&#39; || c == &#39;_&#39; || c == &#39;-&#39; || c == &#39;.&#39;))
5191             return false;
5192     }
5193 
5194     return true;
5195 }
5196 
5197 bool Document::isValidName(const String&amp; name)
5198 {
5199     unsigned length = name.length();
5200     if (!length)
5201         return false;
5202 
5203     if (name.is8Bit()) {
5204         const LChar* characters = name.characters8();
5205 
5206         if (isValidNameASCII(characters, length))
5207             return true;
5208 
5209         return isValidNameNonASCII(characters, length);
5210     }
5211 
5212     const UChar* characters = name.characters16();
5213 
5214     if (isValidNameASCII(characters, length))
5215         return true;
5216 
5217     return isValidNameNonASCII(characters, length);
5218 }
5219 
5220 ExceptionOr&lt;std::pair&lt;AtomString, AtomString&gt;&gt; Document::parseQualifiedName(const String&amp; qualifiedName)
5221 {
5222     unsigned length = qualifiedName.length();
5223 
5224     if (!length)
5225         return Exception { InvalidCharacterError };
5226 
5227     bool nameStart = true;
5228     bool sawColon = false;
5229     unsigned colonPosition = 0;
5230 
5231     for (unsigned i = 0; i &lt; length; ) {
5232         UChar32 c;
5233         U16_NEXT(qualifiedName, i, length, c);
5234         if (c == &#39;:&#39;) {
5235             if (sawColon)
5236                 return Exception { InvalidCharacterError };
5237             nameStart = true;
5238             sawColon = true;
5239             colonPosition = i - 1;
5240         } else if (nameStart) {
5241             if (!isValidNameStart(c))
5242                 return Exception { InvalidCharacterError };
5243             nameStart = false;
5244         } else {
5245             if (!isValidNamePart(c))
5246                 return Exception { InvalidCharacterError };
5247         }
5248     }
5249 
5250     if (!sawColon)
5251         return std::pair&lt;AtomString, AtomString&gt; { { }, { qualifiedName } };
5252 
5253     if (!colonPosition || length - colonPosition &lt;= 1)
5254         return Exception { InvalidCharacterError };
5255 
5256     return std::pair&lt;AtomString, AtomString&gt; { StringView { qualifiedName }.substring(0, colonPosition).toAtomString(), StringView { qualifiedName }.substring(colonPosition + 1).toAtomString() };
5257 }
5258 
5259 ExceptionOr&lt;QualifiedName&gt; Document::parseQualifiedName(const AtomString&amp; namespaceURI, const String&amp; qualifiedName)
5260 {
5261     auto parseResult = parseQualifiedName(qualifiedName);
5262     if (parseResult.hasException())
5263         return parseResult.releaseException();
5264     auto parsedPieces = parseResult.releaseReturnValue();
5265     return QualifiedName { parsedPieces.first, parsedPieces.second, namespaceURI };
5266 }
5267 
5268 void Document::setDecoder(RefPtr&lt;TextResourceDecoder&gt;&amp;&amp; decoder)
5269 {
5270     m_decoder = WTFMove(decoder);
5271 }
5272 
5273 URL Document::completeURL(const String&amp; url, const URL&amp; baseURLOverride, ForceUTF8 forceUTF8) const
5274 {
5275     // Always return a null URL when passed a null string.
5276     // FIXME: Should we change the URL constructor to have this behavior?
5277     // See also [CSS]StyleSheet::completeURL(const String&amp;)
5278     if (url.isNull())
5279         return URL();
5280     const URL&amp; baseURL = ((baseURLOverride.isEmpty() || baseURLOverride == WTF::blankURL()) &amp;&amp; parentDocument()) ? parentDocument()-&gt;baseURL() : baseURLOverride;
5281     if (!m_decoder || forceUTF8 == ForceUTF8::Yes)
5282         return URL(baseURL, url);
5283     return URL(baseURL, url, m_decoder-&gt;encodingForURLParsing());
5284 }
5285 
5286 URL Document::completeURL(const String&amp; url, ForceUTF8 forceUTF8) const
5287 {
5288     return completeURL(url, m_baseURL, forceUTF8);
5289 }
5290 
5291 void Document::setBackForwardCacheState(BackForwardCacheState state)
5292 {
5293     if (m_backForwardCacheState == state)
5294         return;
5295 
5296     m_backForwardCacheState = state;
5297 
5298     FrameView* v = view();
5299     Page* page = this-&gt;page();
5300 
5301     switch (state) {
5302     case InBackForwardCache:
5303         if (v) {
5304             // FIXME: There is some scrolling related work that needs to happen whenever a page goes into the
5305             // back/forward cache and similar work that needs to occur when it comes out. This is where we do the work
5306             // that needs to happen when we enter, and the work that needs to happen when we exit is in
5307             // HistoryController::restoreScrollPositionAndViewState(). It can&#39;t be here because this function is
5308             // called too early on in the process of a page exiting the cache for that work to be possible in this
5309             // function. It would be nice if there was more symmetry here.
5310             // https://bugs.webkit.org/show_bug.cgi?id=98698
5311             v-&gt;cacheCurrentScrollPosition();
5312             if (page &amp;&amp; m_frame-&gt;isMainFrame()) {
5313                 v-&gt;resetScrollbarsAndClearContentsSize();
5314                 if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
5315                     scrollingCoordinator-&gt;clearAllNodes();
5316             }
5317         }
5318 
5319 #if ENABLE(POINTER_LOCK)
5320         exitPointerLock();
5321 #endif
5322 
5323         styleScope().clearResolver();
5324         clearSelectorQueryCache();
5325         m_styleRecalcTimer.stop();
5326 
5327         clearSharedObjectPool();
5328 
5329 #if ENABLE(INDEXED_DATABASE)
5330         if (m_idbConnectionProxy)
5331             m_idbConnectionProxy-&gt;setContextSuspended(*scriptExecutionContext(), true);
5332 #endif
5333         break;
5334     case NotInBackForwardCache:
5335         if (childNeedsStyleRecalc())
5336             scheduleStyleRecalc();
5337 #if ENABLE(INDEXED_DATABASE)
5338         if (m_idbConnectionProxy)
5339             m_idbConnectionProxy-&gt;setContextSuspended(*scriptExecutionContext(), false);
5340 #endif
5341         break;
5342     case AboutToEnterBackForwardCache:
5343         break;
5344     }
5345 }
5346 
5347 void Document::documentWillBecomeInactive()
5348 {
5349     if (renderView())
5350         renderView()-&gt;setIsInWindow(false);
5351 }
5352 
5353 void Document::suspend(ReasonForSuspension reason)
5354 {
5355     if (m_isSuspended)
5356         return;
5357 
5358     documentWillBecomeInactive();
5359 
5360     for (auto* element : m_documentSuspensionCallbackElements)
5361         element-&gt;prepareForDocumentSuspension();
5362 
5363 #if ASSERT_ENABLED
5364     // Clear the update flag to be able to check if the viewport arguments update
5365     // is dispatched, after the document is restored from the back/forward cache.
5366     m_didDispatchViewportPropertiesChanged = false;
5367 #endif
5368 
5369     ASSERT(page());
5370     page()-&gt;lockAllOverlayScrollbarsToHidden(true);
5371 
5372     if (RenderView* view = renderView()) {
5373         if (view-&gt;usesCompositing())
5374             view-&gt;compositor().cancelCompositingLayerUpdate();
5375     }
5376 
5377 #if USE(LIBWEBRTC)
5378     // FIXME: This should be moved to Modules/mediastream.
5379     if (LibWebRTCProvider::webRTCAvailable()) {
5380         if (auto* page = this-&gt;page())
5381             page-&gt;libWebRTCProvider().unregisterMDNSNames(identifier().toUInt64());
5382     }
5383 #endif
5384 
5385 #if ENABLE(SERVICE_WORKER)
5386     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; reason == ReasonForSuspension::BackForwardCache)
5387         setServiceWorkerConnection(nullptr);
5388 #endif
5389 
5390     suspendScheduledTasks(reason);
5391 
5392     ASSERT(m_frame);
5393     m_frame-&gt;clearTimers();
5394 
5395     m_visualUpdatesAllowed = false;
5396     m_visualUpdatesSuppressionTimer.stop();
5397 
5398     m_isSuspended = true;
5399 }
5400 
5401 void Document::resume(ReasonForSuspension reason)
5402 {
5403     if (!m_isSuspended)
5404         return;
5405 
5406     for (auto* element : copyToVector(m_documentSuspensionCallbackElements))
5407         element-&gt;resumeFromDocumentSuspension();
5408 
5409     if (renderView())
5410         renderView()-&gt;setIsInWindow(true);
5411 
5412     ASSERT(page());
5413     page()-&gt;lockAllOverlayScrollbarsToHidden(false);
5414 
5415     ASSERT(m_frame);
5416     m_frame-&gt;loader().client().dispatchDidBecomeFrameset(isFrameSet());
5417 
5418     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
5419         if (auto* timeline = existingTimeline())
5420             timeline-&gt;resumeAnimations();
5421     } else
5422         m_frame-&gt;animation().resumeAnimationsForDocument(this);
5423 
5424     resumeScheduledTasks(reason);
5425 
5426     m_visualUpdatesAllowed = true;
5427 
5428     m_isSuspended = false;
5429 
5430 #if ENABLE(SERVICE_WORKER)
5431     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; reason == ReasonForSuspension::BackForwardCache)
5432         setServiceWorkerConnection(&amp;ServiceWorkerProvider::singleton().serviceWorkerConnection());
5433 #endif
5434 }
5435 
5436 void Document::registerForDocumentSuspensionCallbacks(Element&amp; element)
5437 {
5438     m_documentSuspensionCallbackElements.add(&amp;element);
5439 }
5440 
5441 void Document::unregisterForDocumentSuspensionCallbacks(Element&amp; element)
5442 {
5443     m_documentSuspensionCallbackElements.remove(&amp;element);
5444 }
5445 
5446 bool Document::audioPlaybackRequiresUserGesture() const
5447 {
5448     if (DocumentLoader* loader = this-&gt;loader()) {
5449         // If an audio playback policy was set during navigation, use it. If not, use the global settings.
5450         AutoplayPolicy policy = loader-&gt;autoplayPolicy();
5451         if (policy != AutoplayPolicy::Default)
5452             return policy == AutoplayPolicy::AllowWithoutSound || policy == AutoplayPolicy::Deny;
5453     }
5454 
5455     return settings().audioPlaybackRequiresUserGesture();
5456 }
5457 
5458 bool Document::videoPlaybackRequiresUserGesture() const
5459 {
5460     if (DocumentLoader* loader = this-&gt;loader()) {
5461         // If a video playback policy was set during navigation, use it. If not, use the global settings.
5462         AutoplayPolicy policy = loader-&gt;autoplayPolicy();
5463         if (policy != AutoplayPolicy::Default)
5464             return policy == AutoplayPolicy::Deny;
5465     }
5466 
5467     return settings().videoPlaybackRequiresUserGesture();
5468 }
5469 
5470 bool Document::mediaDataLoadsAutomatically() const
5471 {
5472     if (auto* loader = this-&gt;loader()) {
5473         AutoplayPolicy policy = loader-&gt;autoplayPolicy();
5474         if (policy != AutoplayPolicy::Default)
5475             return policy != AutoplayPolicy::Deny;
5476     }
5477 
5478     return settings().mediaDataLoadsAutomatically();
5479 }
5480 
5481 void Document::storageBlockingStateDidChange()
5482 {
5483     securityOrigin().setStorageBlockingPolicy(settings().storageBlockingPolicy());
5484 }
5485 
5486 // Used only by WebKitLegacy.
5487 void Document::privateBrowsingStateDidChange(PAL::SessionID sessionID)
5488 {
5489     if (m_logger)
5490         m_logger-&gt;setEnabled(this, sessionID.isAlwaysOnLoggingAllowed());
5491 
5492 #if ENABLE(VIDEO)
5493     forEachMediaElement([sessionID] (HTMLMediaElement&amp; element) {
5494         element.privateBrowsingStateDidChange(sessionID);
5495     });
5496 #endif
5497 }
5498 
5499 #if ENABLE(VIDEO_TRACK)
5500 
5501 void Document::registerForCaptionPreferencesChangedCallbacks(HTMLMediaElement&amp; element)
5502 {
5503     if (page())
5504         page()-&gt;group().captionPreferences().setInterestedInCaptionPreferenceChanges();
5505 
5506     m_captionPreferencesChangedElements.add(&amp;element);
5507 }
5508 
5509 void Document::unregisterForCaptionPreferencesChangedCallbacks(HTMLMediaElement&amp; element)
5510 {
5511     m_captionPreferencesChangedElements.remove(&amp;element);
5512 }
5513 
5514 void Document::captionPreferencesChanged()
5515 {
5516     for (auto* element : m_captionPreferencesChangedElements)
5517         element-&gt;captionPreferencesChanged();
5518 }
5519 
5520 #endif
5521 
5522 void Document::setShouldCreateRenderers(bool f)
5523 {
5524     m_createRenderers = f;
5525 }
5526 
5527 bool Document::shouldCreateRenderers()
5528 {
5529     return m_createRenderers;
5530 }
5531 
5532 // Support for Javascript execCommand, and related methods
5533 
5534 static Editor::Command command(Document* document, const String&amp; commandName, bool userInterface = false)
5535 {
5536     auto protectedDocument = makeRef(*document);
5537 
5538     document-&gt;updateStyleIfNeeded();
5539 
5540     auto frame = makeRefPtr(document-&gt;frame());
5541 
5542     if (!frame || frame-&gt;document() != document)
5543         return Editor::Command();
5544 
5545     return frame-&gt;editor().command(commandName,
5546         userInterface ? CommandFromDOMWithUserInterface : CommandFromDOM);
5547 }
5548 
5549 bool Document::execCommand(const String&amp; commandName, bool userInterface, const String&amp; value)
5550 {
5551     EventQueueScope eventQueueScope;
5552     return command(this, commandName, userInterface).execute(value);
5553 }
5554 
5555 bool Document::queryCommandEnabled(const String&amp; commandName)
5556 {
5557     return command(this, commandName).isEnabled();
5558 }
5559 
5560 bool Document::queryCommandIndeterm(const String&amp; commandName)
5561 {
5562     return command(this, commandName).state() == MixedTriState;
5563 }
5564 
5565 bool Document::queryCommandState(const String&amp; commandName)
5566 {
5567     return command(this, commandName).state() == TrueTriState;
5568 }
5569 
5570 bool Document::queryCommandSupported(const String&amp; commandName)
5571 {
5572     return command(this, commandName).isSupported();
5573 }
5574 
5575 String Document::queryCommandValue(const String&amp; commandName)
5576 {
5577     return command(this, commandName).value();
5578 }
5579 
5580 void Document::pushCurrentScript(HTMLScriptElement* newCurrentScript)
5581 {
5582     m_currentScriptStack.append(newCurrentScript);
5583 }
5584 
5585 void Document::popCurrentScript()
5586 {
5587     ASSERT(!m_currentScriptStack.isEmpty());
5588     m_currentScriptStack.removeLast();
5589 }
5590 
5591 bool Document::shouldDeferAsynchronousScriptsUntilParsingFinishes() const
5592 {
5593     return parsing() &amp;&amp; settings().shouldDeferAsynchronousScriptsUntilAfterDocumentLoad();
5594 }
5595 
5596 #if ENABLE(XSLT)
5597 
5598 void Document::scheduleToApplyXSLTransforms()
5599 {
5600     m_hasPendingXSLTransforms = true;
5601     if (!m_applyPendingXSLTransformsTimer.isActive())
5602         m_applyPendingXSLTransformsTimer.startOneShot(0_s);
5603 }
5604 
5605 void Document::applyPendingXSLTransformsNowIfScheduled()
5606 {
5607     if (!m_hasPendingXSLTransforms)
5608         return;
5609     m_applyPendingXSLTransformsTimer.stop();
5610     applyPendingXSLTransformsTimerFired();
5611 }
5612 
5613 void Document::applyPendingXSLTransformsTimerFired()
5614 {
5615     if (parsing())
5616         return;
5617 
5618     m_hasPendingXSLTransforms = false;
5619     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
5620     for (auto&amp; processingInstruction : styleScope().collectXSLTransforms()) {
5621         ASSERT(processingInstruction-&gt;isXSL());
5622 
5623         // Don&#39;t apply XSL transforms to already transformed documents -- &lt;rdar://problem/4132806&gt;
5624         if (transformSourceDocument() || !processingInstruction-&gt;sheet())
5625             return;
5626 
5627         // If the Document has already been detached from the frame, or the frame is currently in the process of
5628         // changing to a new document, don&#39;t attempt to create a new Document from the XSLT.
5629         if (!frame() || frame()-&gt;documentIsBeingReplaced())
5630             return;
5631 
5632         auto processor = XSLTProcessor::create();
5633         processor-&gt;setXSLStyleSheet(downcast&lt;XSLStyleSheet&gt;(processingInstruction-&gt;sheet()));
5634         String resultMIMEType;
5635         String newSource;
5636         String resultEncoding;
5637         if (!processor-&gt;transformToString(*this, resultMIMEType, newSource, resultEncoding))
5638             continue;
5639         // FIXME: If the transform failed we should probably report an error (like Mozilla does).
5640         processor-&gt;createDocumentFromSource(newSource, resultEncoding, resultMIMEType, this, frame());
5641     }
5642 }
5643 
5644 void Document::setTransformSource(std::unique_ptr&lt;TransformSource&gt; source)
5645 {
5646     m_transformSource = WTFMove(source);
5647 }
5648 
5649 #endif
5650 
5651 void Document::setDesignMode(InheritedBool value)
5652 {
5653     m_designMode = value;
5654     for (Frame* frame = m_frame; frame &amp;&amp; frame-&gt;document(); frame = frame-&gt;tree().traverseNext(m_frame))
5655         frame-&gt;document()-&gt;scheduleFullStyleRebuild();
5656 }
5657 
5658 String Document::designMode() const
5659 {
5660     return inDesignMode() ? &quot;on&quot;_s : &quot;off&quot;_s;
5661 }
5662 
5663 void Document::setDesignMode(const String&amp; value)
5664 {
5665     InheritedBool mode;
5666     if (equalLettersIgnoringASCIICase(value, &quot;on&quot;))
5667         mode = on;
5668     else if (equalLettersIgnoringASCIICase(value, &quot;off&quot;))
5669         mode = off;
5670     else
5671         mode = inherit;
5672     setDesignMode(mode);
5673 }
5674 
5675 auto Document::getDesignMode() const -&gt; InheritedBool
5676 {
5677     return m_designMode;
5678 }
5679 
5680 bool Document::inDesignMode() const
5681 {
5682     for (const Document* d = this; d; d = d-&gt;parentDocument()) {
5683         if (d-&gt;m_designMode != inherit)
5684             return d-&gt;m_designMode;
5685     }
5686     return false;
5687 }
5688 
5689 Document* Document::parentDocument() const
5690 {
5691     if (!m_frame)
5692         return nullptr;
5693     Frame* parent = m_frame-&gt;tree().parent();
5694     if (!parent)
5695         return nullptr;
5696     return parent-&gt;document();
5697 }
5698 
5699 Document&amp; Document::topDocument() const
5700 {
5701     // FIXME: This special-casing avoids incorrectly determined top documents during the process
5702     // of AXObjectCache teardown or notification posting for cached or being-destroyed documents.
5703     if (backForwardCacheState() == NotInBackForwardCache &amp;&amp; !m_renderTreeBeingDestroyed) {
5704         if (!m_frame)
5705             return const_cast&lt;Document&amp;&gt;(*this);
5706         // This should always be non-null.
5707         Document* mainFrameDocument = m_frame-&gt;mainFrame().document();
5708         return mainFrameDocument ? *mainFrameDocument : const_cast&lt;Document&amp;&gt;(*this);
5709     }
5710 
5711     Document* document = const_cast&lt;Document*&gt;(this);
5712     while (HTMLFrameOwnerElement* element = document-&gt;ownerElement())
5713         document = &amp;element-&gt;document();
5714     return *document;
5715 }
5716 
5717 ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttribute(const String&amp; localName)
5718 {
5719     if (!isValidName(localName))
5720         return Exception { InvalidCharacterError };
5721     return Attr::create(*this, QualifiedName { nullAtom(), isHTMLDocument() ? localName.convertToASCIILowercase() : localName, nullAtom() }, emptyString());
5722 }
5723 
5724 ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttributeNS(const AtomString&amp; namespaceURI, const String&amp; qualifiedName, bool shouldIgnoreNamespaceChecks)
5725 {
5726     auto parseResult = parseQualifiedName(namespaceURI, qualifiedName);
5727     if (parseResult.hasException())
5728         return parseResult.releaseException();
5729     QualifiedName parsedName { parseResult.releaseReturnValue() };
5730     if (!shouldIgnoreNamespaceChecks &amp;&amp; !hasValidNamespaceForAttributes(parsedName))
5731         return Exception { NamespaceError };
5732     return Attr::create(*this, parsedName, emptyString());
5733 }
5734 
5735 const SVGDocumentExtensions* Document::svgExtensions()
5736 {
5737     return m_svgExtensions.get();
5738 }
5739 
5740 SVGDocumentExtensions&amp; Document::accessSVGExtensions()
5741 {
5742     if (!m_svgExtensions)
5743         m_svgExtensions = makeUnique&lt;SVGDocumentExtensions&gt;(*this);
5744     return *m_svgExtensions;
5745 }
5746 
5747 void Document::addSVGUseElement(SVGUseElement&amp; element)
5748 {
5749     auto result = m_svgUseElements.add(&amp;element);
5750     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(result.isNewEntry);
5751 }
5752 
5753 void Document::removeSVGUseElement(SVGUseElement&amp; element)
5754 {
5755     m_svgUseElements.remove(&amp;element);
5756     // FIXME: Assert that element was in m_svgUseElements once re-entrancy to update style and layout have been removed.
5757 }
5758 
5759 bool Document::hasSVGRootNode() const
5760 {
5761     return documentElement() &amp;&amp; documentElement()-&gt;hasTagName(SVGNames::svgTag);
5762 }
5763 
5764 template &lt;CollectionType collectionType&gt;
5765 Ref&lt;HTMLCollection&gt; Document::ensureCachedCollection()
5766 {
5767     return ensureRareData().ensureNodeLists().addCachedCollection&lt;GenericCachedHTMLCollection&lt;CollectionTypeTraits&lt;collectionType&gt;::traversalType&gt;&gt;(*this, collectionType);
5768 }
5769 
5770 Ref&lt;HTMLCollection&gt; Document::images()
5771 {
5772     return ensureCachedCollection&lt;DocImages&gt;();
5773 }
5774 
5775 Ref&lt;HTMLCollection&gt; Document::applets()
5776 {
5777     return ensureCachedCollection&lt;DocApplets&gt;();
5778 }
5779 
5780 Ref&lt;HTMLCollection&gt; Document::embeds()
5781 {
5782     return ensureCachedCollection&lt;DocEmbeds&gt;();
5783 }
5784 
5785 Ref&lt;HTMLCollection&gt; Document::plugins()
5786 {
5787     // This is an alias for embeds() required for the JS DOM bindings.
5788     return ensureCachedCollection&lt;DocEmbeds&gt;();
5789 }
5790 
5791 Ref&lt;HTMLCollection&gt; Document::scripts()
5792 {
5793     return ensureCachedCollection&lt;DocScripts&gt;();
5794 }
5795 
5796 Ref&lt;HTMLCollection&gt; Document::links()
5797 {
5798     return ensureCachedCollection&lt;DocLinks&gt;();
5799 }
5800 
5801 Ref&lt;HTMLCollection&gt; Document::forms()
5802 {
5803     return ensureCachedCollection&lt;DocForms&gt;();
5804 }
5805 
5806 Ref&lt;HTMLCollection&gt; Document::anchors()
5807 {
5808     return ensureCachedCollection&lt;DocAnchors&gt;();
5809 }
5810 
5811 Ref&lt;HTMLCollection&gt; Document::all()
5812 {
5813     return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLAllCollection&gt;(*this, DocAll);
5814 }
5815 
5816 Ref&lt;HTMLCollection&gt; Document::allFilteredByName(const AtomString&amp; name)
5817 {
5818     return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLAllNamedSubCollection&gt;(*this, DocumentAllNamedItems, name);
5819 }
5820 
5821 Ref&lt;HTMLCollection&gt; Document::windowNamedItems(const AtomString&amp; name)
5822 {
5823     return ensureRareData().ensureNodeLists().addCachedCollection&lt;WindowNameCollection&gt;(*this, WindowNamedItems, name);
5824 }
5825 
5826 Ref&lt;HTMLCollection&gt; Document::documentNamedItems(const AtomString&amp; name)
5827 {
5828     return ensureRareData().ensureNodeLists().addCachedCollection&lt;DocumentNameCollection&gt;(*this, DocumentNamedItems, name);
5829 }
5830 
5831 void Document::finishedParsing()
5832 {
5833     ASSERT(!scriptableDocumentParser() || !m_parser-&gt;isParsing());
5834     ASSERT(!scriptableDocumentParser() || m_readyState != Loading);
5835     setParsing(false);
5836 
5837     Ref&lt;Document&gt; protectedThis(*this);
5838 
5839     scriptRunner().documentFinishedParsing();
5840 
5841     if (!m_documentTiming.domContentLoadedEventStart)
5842         m_documentTiming.domContentLoadedEventStart = MonotonicTime::now();
5843 
5844     // FIXME: Schedule a task to fire DOMContentLoaded event instead. See webkit.org/b/82931
5845     eventLoop().performMicrotaskCheckpoint();
5846     dispatchEvent(Event::create(eventNames().DOMContentLoadedEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
5847 
5848     if (!m_documentTiming.domContentLoadedEventEnd)
5849         m_documentTiming.domContentLoadedEventEnd = MonotonicTime::now();
5850 
5851     if (RefPtr&lt;Frame&gt; frame = this-&gt;frame()) {
5852 #if ENABLE(XSLT)
5853         applyPendingXSLTransformsNowIfScheduled();
5854 #endif
5855 
5856         // FrameLoader::finishedParsing() might end up calling Document::implicitClose() if all
5857         // resource loads are complete. HTMLObjectElements can start loading their resources from
5858         // post attach callbacks triggered by resolveStyle(). This means if we parse out an &lt;object&gt;
5859         // tag and then reach the end of the document without updating styles, we might not have yet
5860         // started the resource load and might fire the window load event too early. To avoid this
5861         // we force the styles to be up to date before calling FrameLoader::finishedParsing().
5862         // See https://bugs.webkit.org/show_bug.cgi?id=36864 starting around comment 35.
5863         updateStyleIfNeeded();
5864 
5865         frame-&gt;loader().finishedParsing();
5866         InspectorInstrumentation::domContentLoadedEventFired(*frame);
5867     }
5868 
5869     // Schedule dropping of the DocumentSharedObjectPool. We keep it alive for a while after parsing finishes
5870     // so that dynamically inserted content can also benefit from sharing optimizations.
5871     // Note that we don&#39;t refresh the timer on pool access since that could lead to huge caches being kept
5872     // alive indefinitely by something innocuous like JS setting .innerHTML repeatedly on a timer.
5873     static const Seconds timeToKeepSharedObjectPoolAliveAfterParsingFinished { 10_s };
5874     m_sharedObjectPoolClearTimer.startOneShot(timeToKeepSharedObjectPoolAliveAfterParsingFinished);
5875 
5876     // Parser should have picked up all speculative preloads by now
5877     m_cachedResourceLoader-&gt;clearPreloads(CachedResourceLoader::ClearPreloadsMode::ClearSpeculativePreloads);
5878 
5879 #if ENABLE(SERVICE_WORKER)
5880     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled()) {
5881         // Stop queuing service worker client messages now that the DOMContentLoaded event has been fired.
5882         if (auto* serviceWorkerContainer = this-&gt;serviceWorkerContainer())
5883             serviceWorkerContainer-&gt;startMessages();
5884     }
5885 #endif
5886 }
5887 
5888 void Document::clearSharedObjectPool()
5889 {
5890     m_sharedObjectPool = nullptr;
5891     m_sharedObjectPoolClearTimer.stop();
5892 }
5893 
5894 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
5895 
5896 // FIXME: Find a better place for this code.
5897 
5898 bool Document::isTelephoneNumberParsingEnabled() const
5899 {
5900     return settings().telephoneNumberParsingEnabled() &amp;&amp; m_isTelephoneNumberParsingAllowed;
5901 }
5902 
5903 bool Document::isTelephoneNumberParsingAllowed() const
5904 {
5905     return m_isTelephoneNumberParsingAllowed;
5906 }
5907 
5908 #endif
5909 
5910 String Document::originIdentifierForPasteboard() const
5911 {
5912     auto origin = securityOrigin().toString();
5913     if (origin != &quot;null&quot;)
5914         return origin;
5915     if (!m_uniqueIdentifier)
5916         m_uniqueIdentifier = &quot;null:&quot; + createCanonicalUUIDString();
5917     return m_uniqueIdentifier;
5918 }
5919 
5920 ExceptionOr&lt;Ref&lt;XPathExpression&gt;&gt; Document::createExpression(const String&amp; expression, RefPtr&lt;XPathNSResolver&gt;&amp;&amp; resolver)
5921 {
5922     if (!m_xpathEvaluator)
5923         m_xpathEvaluator = XPathEvaluator::create();
5924     return m_xpathEvaluator-&gt;createExpression(expression, WTFMove(resolver));
5925 }
5926 
5927 Ref&lt;XPathNSResolver&gt; Document::createNSResolver(Node&amp; nodeResolver)
5928 {
5929     if (!m_xpathEvaluator)
5930         m_xpathEvaluator = XPathEvaluator::create();
5931     return m_xpathEvaluator-&gt;createNSResolver(nodeResolver);
5932 }
5933 
5934 ExceptionOr&lt;Ref&lt;XPathResult&gt;&gt; Document::evaluate(const String&amp; expression, Node&amp; contextNode, RefPtr&lt;XPathNSResolver&gt;&amp;&amp; resolver, unsigned short type, XPathResult* result)
5935 {
5936     if (!m_xpathEvaluator)
5937         m_xpathEvaluator = XPathEvaluator::create();
5938     return m_xpathEvaluator-&gt;evaluate(expression, contextNode, WTFMove(resolver), type, result);
5939 }
5940 
5941 void Document::initSecurityContext()
5942 {
5943     if (haveInitializedSecurityOrigin()) {
5944         ASSERT(SecurityContext::securityOrigin());
5945         return;
5946     }
5947 
5948     if (!m_frame) {
5949         // No source for a security context.
5950         // This can occur via document.implementation.createDocument().
5951         setCookieURL(URL({ }, emptyString()));
5952         setSecurityOriginPolicy(SecurityOriginPolicy::create(SecurityOrigin::createUnique()));
5953         setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { { }, emptyString() }, *this));
5954         return;
5955     }
5956 
5957     // In the common case, create the security context from the currently
5958     // loading URL with a fresh content security policy.
5959     setCookieURL(m_url);
5960     enforceSandboxFlags(m_frame-&gt;loader().effectiveSandboxFlags());
5961     setReferrerPolicy(m_frame-&gt;loader().effectiveReferrerPolicy());
5962 
5963     if (shouldEnforceContentDispositionAttachmentSandbox())
5964         applyContentDispositionAttachmentSandbox();
5965 
5966     auto* documentLoader = m_frame-&gt;loader().documentLoader();
5967     bool isSecurityOriginUnique = isSandboxed(SandboxOrigin);
5968     if (!isSecurityOriginUnique)
5969         isSecurityOriginUnique = documentLoader &amp;&amp; documentLoader-&gt;response().tainting() == ResourceResponse::Tainting::Opaque;
5970 
5971     setSecurityOriginPolicy(SecurityOriginPolicy::create(isSecurityOriginUnique ? SecurityOrigin::createUnique() : SecurityOrigin::create(m_url)));
5972     setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { m_url }, *this));
5973 
5974     if (SecurityPolicy::allowSubstituteDataAccessToLocal()) {
5975         // If this document was loaded with substituteData, then the document can
5976         // load local resources.  See https://bugs.webkit.org/show_bug.cgi?id=16756
5977         // and https://bugs.webkit.org/show_bug.cgi?id=19760 for further
5978         // discussion.
5979 
5980         // RT-17330: Need to use &quot;m_frame-&gt;loader()-&gt;documentLoader()&quot; instead
5981         // of &quot;loader()&quot; as the latter returns NULL while the document is being
5982         // constructed
5983         // DocumentLoader* documentLoader = loader();
5984         DocumentLoader* documentLoader = m_frame-&gt;loader().documentLoader();
5985         if (documentLoader &amp;&amp; documentLoader-&gt;substituteData().isValid())
5986             securityOrigin().grantLoadLocalResources();
5987     }
5988 
5989     String overrideContentSecurityPolicy = m_frame-&gt;loader().client().overrideContentSecurityPolicy();
5990     if (!overrideContentSecurityPolicy.isNull())
5991         contentSecurityPolicy()-&gt;didReceiveHeader(overrideContentSecurityPolicy, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::API, referrer(), documentLoader ? documentLoader-&gt;response().httpStatusCode() : 0);
5992 
5993 #if USE(QUICK_LOOK)
5994     if (shouldEnforceQuickLookSandbox())
5995         applyQuickLookSandbox();
5996 #endif
5997 
5998     if (shouldEnforceHTTP09Sandbox()) {
5999         String message = makeString(&quot;Sandboxing &#39;&quot;, m_url.stringCenterEllipsizedToLength(), &quot;&#39; because it is using HTTP/0.9.&quot;);
6000         addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
6001         enforceSandboxFlags(SandboxScripts | SandboxPlugins);
6002     }
6003 
6004     if (settings().needsStorageAccessFromFileURLsQuirk())
6005         securityOrigin().grantStorageAccessFromFileURLsQuirk();
6006     if (!settings().webSecurityEnabled()) {
6007         // Web security is turned off. We should let this document access every other document. This is used primary by testing
6008         // harnesses for web sites.
6009         securityOrigin().grantUniversalAccess();
6010     } else if (securityOrigin().isLocal()) {
6011         if (settings().allowUniversalAccessFromFileURLs() || m_frame-&gt;loader().client().shouldForceUniversalAccessFromLocalURL(m_url)) {
6012             // Some clients want local URLs to have universal access, but that setting is dangerous for other clients.
6013             securityOrigin().grantUniversalAccess();
6014         } else if (!settings().allowFileAccessFromFileURLs()) {
6015             // Some clients want local URLs to have even tighter restrictions by default, and not be able to access other local files.
6016             // FIXME 81578: The naming of this is confusing. Files with restricted access to other local files
6017             // still can have other privileges that can be remembered, thereby not making them unique origins.
6018             securityOrigin().setEnforcesFilePathSeparation();
6019         }
6020     }
6021     securityOrigin().setStorageBlockingPolicy(settings().storageBlockingPolicy());
6022 
6023     Document* parentDocument = ownerElement() ? &amp;ownerElement()-&gt;document() : nullptr;
6024     if (parentDocument &amp;&amp; m_frame-&gt;loader().shouldTreatURLAsSrcdocDocument(url())) {
6025         m_isSrcdocDocument = true;
6026         setBaseURLOverride(parentDocument-&gt;baseURL());
6027     }
6028     if (parentDocument)
6029         setStrictMixedContentMode(parentDocument-&gt;isStrictMixedContentMode());
6030 
6031     if (!SecurityPolicy::shouldInheritSecurityOriginFromOwner(m_url))
6032         return;
6033 
6034     // If we do not obtain a meaningful origin from the URL, then we try to
6035     // find one via the frame hierarchy.
6036     Frame* parentFrame = m_frame-&gt;tree().parent();
6037     Frame* openerFrame = m_frame-&gt;loader().opener();
6038 
6039     Frame* ownerFrame = parentFrame;
6040     if (!ownerFrame)
6041         ownerFrame = openerFrame;
6042 
6043     if (!ownerFrame) {
6044         didFailToInitializeSecurityOrigin();
6045         return;
6046     }
6047 
6048     contentSecurityPolicy()-&gt;copyStateFrom(ownerFrame-&gt;document()-&gt;contentSecurityPolicy());
6049     contentSecurityPolicy()-&gt;updateSourceSelf(ownerFrame-&gt;document()-&gt;securityOrigin());
6050 
6051     // Per &lt;http://www.w3.org/TR/upgrade-insecure-requests/&gt;, new browsing contexts must inherit from an
6052     // ongoing set of upgraded requests. When opening a new browsing context, we need to capture its
6053     // existing upgrade request. Nested browsing contexts are handled during DocumentWriter::begin.
6054     if (auto* openerDocument = openerFrame ? openerFrame-&gt;document() : nullptr)
6055         contentSecurityPolicy()-&gt;inheritInsecureNavigationRequestsToUpgradeFromOpener(*openerDocument-&gt;contentSecurityPolicy());
6056 
6057     if (isSandboxed(SandboxOrigin)) {
6058         // If we&#39;re supposed to inherit our security origin from our owner,
6059         // but we&#39;re also sandboxed, the only thing we inherit is the ability
6060         // to load local resources. This lets about:blank iframes in file://
6061         // URL documents load images and other resources from the file system.
6062         if (ownerFrame-&gt;document()-&gt;securityOrigin().canLoadLocalResources())
6063             securityOrigin().grantLoadLocalResources();
6064         return;
6065     }
6066 
6067     setCookieURL(ownerFrame-&gt;document()-&gt;cookieURL());
6068     // We alias the SecurityOrigins to match Firefox, see Bug 15313
6069     // https://bugs.webkit.org/show_bug.cgi?id=15313
6070     setSecurityOriginPolicy(ownerFrame-&gt;document()-&gt;securityOriginPolicy());
6071 }
6072 
6073 void Document::initContentSecurityPolicy()
6074 {
6075     auto* parentFrame = m_frame-&gt;tree().parent();
6076     if (parentFrame)
6077         contentSecurityPolicy()-&gt;copyUpgradeInsecureRequestStateFrom(*parentFrame-&gt;document()-&gt;contentSecurityPolicy());
6078 
6079     // FIXME: Remove this special plugin document logic. We are stricter than the CSP 3 spec. with regards to plugins: we prefer to
6080     // inherit the full policy unless the plugin document is opened in a new window. The CSP 3 spec. implies that only plugin documents
6081     // delivered with a local scheme (e.g. blob, file, data) should inherit a policy.
6082     if (!isPluginDocument())
6083         return;
6084     auto* openerFrame = m_frame-&gt;loader().opener();
6085     bool shouldInhert = parentFrame || (openerFrame &amp;&amp; openerFrame-&gt;document()-&gt;securityOrigin().canAccess(securityOrigin()));
6086     if (!shouldInhert)
6087         return;
6088     setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { m_url }, *this));
6089     if (openerFrame)
6090         contentSecurityPolicy()-&gt;createPolicyForPluginDocumentFrom(*openerFrame-&gt;document()-&gt;contentSecurityPolicy());
6091     else
6092         contentSecurityPolicy()-&gt;copyStateFrom(parentFrame-&gt;document()-&gt;contentSecurityPolicy());
6093 }
6094 
6095 bool Document::isContextThread() const
6096 {
6097     return isMainThread();
6098 }
6099 
6100 bool Document::isSecureContext() const
6101 {
6102     if (!m_frame)
6103         return true;
6104     if (!RuntimeEnabledFeatures::sharedFeatures().secureContextChecksEnabled())
6105         return true;
6106     if (!securityOrigin().isPotentiallyTrustworthy())
6107         return false;
6108     for (auto* frame = m_frame-&gt;tree().parent(); frame; frame = frame-&gt;tree().parent()) {
6109         if (!frame-&gt;document()-&gt;securityOrigin().isPotentiallyTrustworthy())
6110             return false;
6111     }
6112     if (topOrigin().isUnique())
6113         return false;
6114     return true;
6115 }
6116 
6117 void Document::updateURLForPushOrReplaceState(const URL&amp; url)
6118 {
6119     Frame* f = frame();
6120     if (!f)
6121         return;
6122 
6123     setURL(url);
6124     f-&gt;loader().setOutgoingReferrer(url);
6125 
6126     if (DocumentLoader* documentLoader = loader())
6127         documentLoader-&gt;replaceRequestURLForSameDocumentNavigation(url);
6128 }
6129 
6130 void Document::statePopped(Ref&lt;SerializedScriptValue&gt;&amp;&amp; stateObject)
6131 {
6132     if (!frame())
6133         return;
6134 
6135     // Per step 11 of section 6.5.9 (history traversal) of the HTML5 spec, we
6136     // defer firing of popstate until we&#39;re in the complete state.
6137     if (m_readyState == Complete)
6138         dispatchPopstateEvent(WTFMove(stateObject));
6139     else
6140         m_pendingStateObject = WTFMove(stateObject);
6141 }
6142 
6143 void Document::attachRange(Range&amp; range)
6144 {
6145     ASSERT(!m_ranges.contains(&amp;range));
6146     m_ranges.add(&amp;range);
6147 }
6148 
6149 void Document::detachRange(Range&amp; range)
6150 {
6151     // We don&#39;t ASSERT m_ranges.contains(&amp;range) to allow us to call this
6152     // unconditionally to fix: https://bugs.webkit.org/show_bug.cgi?id=26044
6153     m_ranges.remove(&amp;range);
6154 }
6155 
6156 Optional&lt;RenderingContext&gt; Document::getCSSCanvasContext(const String&amp; type, const String&amp; name, int width, int height)
6157 {
6158     HTMLCanvasElement* element = getCSSCanvasElement(name);
6159     if (!element)
6160         return WTF::nullopt;
6161     element-&gt;setSize({ width, height });
6162     auto context = element-&gt;getContext(type);
6163     if (!context)
6164         return WTF::nullopt;
6165 
6166 #if ENABLE(WEBGL)
6167     if (is&lt;WebGLRenderingContext&gt;(*context))
6168         return RenderingContext { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*context) } };
6169 #endif
6170 #if ENABLE(WEBGL2)
6171     if (is&lt;WebGL2RenderingContext&gt;(*context))
6172         return RenderingContext { RefPtr&lt;WebGL2RenderingContext&gt; { &amp;downcast&lt;WebGL2RenderingContext&gt;(*context) } };
6173 #endif
6174 #if ENABLE(WEBGPU)
6175     if (is&lt;GPUCanvasContext&gt;(*context))
6176         return RenderingContext { RefPtr&lt;GPUCanvasContext&gt; { &amp;downcast&lt;GPUCanvasContext&gt;(*context) } };
6177 #endif
6178 
6179     return RenderingContext { RefPtr&lt;CanvasRenderingContext2D&gt; { &amp;downcast&lt;CanvasRenderingContext2D&gt;(*context) } };
6180 }
6181 
6182 HTMLCanvasElement* Document::getCSSCanvasElement(const String&amp; name)
6183 {
6184     RefPtr&lt;HTMLCanvasElement&gt;&amp; element = m_cssCanvasElements.add(name, nullptr).iterator-&gt;value;
6185     if (!element)
6186         element = HTMLCanvasElement::create(*this);
6187     return element.get();
6188 }
6189 
6190 String Document::nameForCSSCanvasElement(const HTMLCanvasElement&amp; canvasElement) const
6191 {
6192     for (const auto&amp; entry : m_cssCanvasElements) {
6193         if (entry.value.get() == &amp;canvasElement)
6194             return entry.key;
6195     }
6196     return String();
6197 }
6198 
6199 #if ENABLE(TEXT_AUTOSIZING)
6200 TextAutoSizing&amp; Document::textAutoSizing()
6201 {
6202     if (!m_textAutoSizing)
6203         m_textAutoSizing = makeUnique&lt;TextAutoSizing&gt;();
6204     return *m_textAutoSizing;
6205 }
6206 #endif // ENABLE(TEXT_AUTOSIZING)
6207 
6208 void Document::initDNSPrefetch()
6209 {
6210     m_haveExplicitlyDisabledDNSPrefetch = false;
6211     m_isDNSPrefetchEnabled = settings().dnsPrefetchingEnabled() &amp;&amp; securityOrigin().protocol() == &quot;http&quot;;
6212 
6213     // Inherit DNS prefetch opt-out from parent frame
6214     if (Document* parent = parentDocument()) {
6215         if (!parent-&gt;isDNSPrefetchEnabled())
6216             m_isDNSPrefetchEnabled = false;
6217     }
6218 }
6219 
6220 void Document::parseDNSPrefetchControlHeader(const String&amp; dnsPrefetchControl)
6221 {
6222     if (!settings().dnsPrefetchingEnabled())
6223         return;
6224 
6225     if (equalLettersIgnoringASCIICase(dnsPrefetchControl, &quot;on&quot;) &amp;&amp; !m_haveExplicitlyDisabledDNSPrefetch) {
6226         m_isDNSPrefetchEnabled = true;
6227         return;
6228     }
6229 
6230     m_isDNSPrefetchEnabled = false;
6231     m_haveExplicitlyDisabledDNSPrefetch = true;
6232 }
6233 
6234 void Document::getParserLocation(String&amp; completedURL, unsigned&amp; line, unsigned&amp; column) const
6235 {
6236     // We definitely cannot associate the message with a location being parsed if we are not even parsing.
6237     if (!parsing())
6238         return;
6239 
6240     ScriptableDocumentParser* parser = scriptableDocumentParser();
6241     if (!parser)
6242         return;
6243 
6244     // When the parser waits for scripts, any messages must be coming from some other source, and are not related to the location of the script element that made the parser wait.
6245     if (!parser-&gt;shouldAssociateConsoleMessagesWithTextPosition())
6246         return;
6247 
6248     completedURL = url().string();
6249     TextPosition position = parser-&gt;textPosition();
6250     line = position.m_line.oneBasedInt();
6251     column = position.m_column.oneBasedInt();
6252 }
6253 
6254 void Document::addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp; consoleMessage)
6255 {
6256     if (!isContextThread()) {
6257         postTask(AddConsoleMessageTask(WTFMove(consoleMessage)));
6258         return;
6259     }
6260 
6261     if (Page* page = this-&gt;page())
6262         page-&gt;console().addMessage(WTFMove(consoleMessage));
6263 }
6264 
6265 void Document::addConsoleMessage(MessageSource source, MessageLevel level, const String&amp; message, unsigned long requestIdentifier)
6266 {
6267     if (!isContextThread()) {
6268         postTask(AddConsoleMessageTask(source, level, message));
6269         return;
6270     }
6271 
6272     if (Page* page = this-&gt;page())
6273         page-&gt;console().addMessage(source, level, message, requestIdentifier, this);
6274 
6275     if (m_consoleMessageListener)
6276         m_consoleMessageListener-&gt;scheduleCallback(*this, message);
6277 }
6278 
6279 void Document::addMessage(MessageSource source, MessageLevel level, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp; callStack, JSC::JSGlobalObject* state, unsigned long requestIdentifier)
6280 {
6281     if (!isContextThread()) {
6282         postTask(AddConsoleMessageTask(source, level, message));
6283         return;
6284     }
6285 
6286     if (Page* page = this-&gt;page())
6287         page-&gt;console().addMessage(source, level, message, sourceURL, lineNumber, columnNumber, WTFMove(callStack), state, requestIdentifier);
6288 }
6289 
6290 void Document::postTask(Task&amp;&amp; task)
6291 {
6292     callOnMainThread([documentID = identifier(), task = WTFMove(task)]() mutable {
6293         ASSERT(isMainThread());
6294 
6295         auto* document = allDocumentsMap().get(documentID);
6296         if (!document)
6297             return;
6298 
6299         Page* page = document-&gt;page();
6300         if ((page &amp;&amp; page-&gt;defersLoading() &amp;&amp; document-&gt;activeDOMObjectsAreSuspended()) || !document-&gt;m_pendingTasks.isEmpty())
6301             document-&gt;m_pendingTasks.append(WTFMove(task));
6302         else
6303             task.performTask(*document);
6304     });
6305 }
6306 
6307 void Document::pendingTasksTimerFired()
6308 {
6309     Vector&lt;Task&gt; pendingTasks = WTFMove(m_pendingTasks);
6310     for (auto&amp; task : pendingTasks)
6311         task.performTask(*this);
6312 }
6313 
6314 EventLoopTaskGroup&amp; Document::eventLoop()
6315 {
6316     ASSERT(isMainThread());
6317     if (UNLIKELY(!m_documentTaskGroup)) {
6318         m_documentTaskGroup = makeUnique&lt;EventLoopTaskGroup&gt;(windowEventLoop());
6319         if (activeDOMObjectsAreStopped())
6320             m_documentTaskGroup-&gt;stopAndDiscardAllTasks();
6321         else if (activeDOMObjectsAreSuspended())
6322             m_documentTaskGroup-&gt;suspend();
6323     }
6324     return *m_documentTaskGroup;
6325 }
6326 
6327 WindowEventLoop&amp; Document::windowEventLoop()
6328 {
6329     ASSERT(isMainThread());
6330     if (UNLIKELY(!m_eventLoop))
6331         m_eventLoop = WindowEventLoop::eventLoopForSecurityOrigin(securityOrigin());
6332     return *m_eventLoop;
6333 }
6334 
6335 void Document::suspendScheduledTasks(ReasonForSuspension reason)
6336 {
6337     if (m_scheduledTasksAreSuspended) {
6338         // A page may subsequently suspend DOM objects, say as part of handling a scroll or zoom gesture, after the
6339         // embedding client requested the page be suspended. We ignore such requests so long as the embedding client
6340         // requested the suspension first. See &lt;rdar://problem/13754896&gt; for more details.
6341         ASSERT(reasonForSuspendingActiveDOMObjects() == ReasonForSuspension::PageWillBeSuspended);
6342         return;
6343     }
6344 
6345     suspendScriptedAnimationControllerCallbacks();
6346     suspendActiveDOMObjects(reason);
6347     scriptRunner().suspend();
6348     m_pendingTasksTimer.stop();
6349 
6350 #if ENABLE(XSLT)
6351     m_applyPendingXSLTransformsTimer.stop();
6352 #endif
6353 
6354     // Deferring loading and suspending parser is necessary when we need to prevent re-entrant JavaScript execution
6355     // (e.g. while displaying an alert).
6356     // It is not currently possible to suspend parser unless loading is deferred, because new data arriving from network
6357     // will trigger parsing, and leave the scheduler in an inconsistent state where it doesn&#39;t know whether it&#39;s suspended or not.
6358     if (reason == ReasonForSuspension::WillDeferLoading &amp;&amp; m_parser)
6359         m_parser-&gt;suspendScheduledTasks();
6360 
6361     m_scheduledTasksAreSuspended = true;
6362 }
6363 
6364 void Document::resumeScheduledTasks(ReasonForSuspension reason)
6365 {
6366     if (reasonForSuspendingActiveDOMObjects() != reason)
6367         return;
6368 
6369     ASSERT(m_scheduledTasksAreSuspended);
6370 
6371     if (reason == ReasonForSuspension::WillDeferLoading &amp;&amp; m_parser)
6372         m_parser-&gt;resumeScheduledTasks();
6373 
6374 #if ENABLE(XSLT)
6375     if (m_hasPendingXSLTransforms)
6376         m_applyPendingXSLTransformsTimer.startOneShot(0_s);
6377 #endif
6378 
6379     if (!m_pendingTasks.isEmpty())
6380         m_pendingTasksTimer.startOneShot(0_s);
6381     scriptRunner().resume();
6382     resumeActiveDOMObjects(reason);
6383     resumeScriptedAnimationControllerCallbacks();
6384 
6385     m_scheduledTasksAreSuspended = false;
6386 }
6387 
6388 void Document::suspendScriptedAnimationControllerCallbacks()
6389 {
6390     if (m_scriptedAnimationController)
6391         m_scriptedAnimationController-&gt;suspend();
6392 }
6393 
6394 void Document::resumeScriptedAnimationControllerCallbacks()
6395 {
6396     if (m_scriptedAnimationController)
6397         m_scriptedAnimationController-&gt;resume();
6398 }
6399 
6400 void Document::updateAnimationsAndSendEvents(DOMHighResTimeStamp timestamp)
6401 {
6402     ASSERT(!m_timelines.hasNullReferences());
6403 
6404     // We need to copy m_timelines before iterating over its members since calling updateAnimationsAndSendEvents() may mutate m_timelines.
6405     Vector&lt;RefPtr&lt;DocumentTimeline&gt;&gt; timelines;
6406     bool shouldUpdateAnimations = false;
6407     for (auto&amp; timeline : m_timelines) {
6408         if (!shouldUpdateAnimations &amp;&amp; timeline.scheduledUpdate())
6409             shouldUpdateAnimations = true;
6410         timelines.append(&amp;timeline);
6411     }
6412 
6413     for (auto&amp; timeline : timelines) {
6414         timeline-&gt;updateCurrentTime(timestamp);
6415         if (shouldUpdateAnimations)
6416             timeline-&gt;updateAnimationsAndSendEvents();
6417     }
6418 }
6419 
6420 void Document::serviceRequestAnimationFrameCallbacks(DOMHighResTimeStamp timestamp)
6421 {
6422     if (m_scriptedAnimationController)
6423         m_scriptedAnimationController-&gt;serviceRequestAnimationFrameCallbacks(timestamp);
6424 }
6425 
6426 void Document::windowScreenDidChange(PlatformDisplayID displayID)
6427 {
6428     if (RenderView* view = renderView()) {
6429         if (view-&gt;usesCompositing())
6430             view-&gt;compositor().windowScreenDidChange(displayID);
6431     }
6432 }
6433 
6434 String Document::displayStringModifiedByEncoding(const String&amp; string) const
6435 {
6436     if (!m_decoder)
6437         return string;
6438     return String { string }.replace(&#39;\\&#39;, m_decoder-&gt;encoding().backslashAsCurrencySymbol());
6439 }
6440 
6441 void Document::dispatchPageshowEvent(PageshowEventPersistence persisted)
6442 {
6443     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=36334 Pageshow event needs to fire asynchronously.
6444     dispatchWindowEvent(PageTransitionEvent::create(eventNames().pageshowEvent, persisted), this);
6445 }
6446 
6447 void Document::enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp; eventInit)
6448 {
6449     queueTaskToDispatchEvent(TaskSource::DOMManipulation, SecurityPolicyViolationEvent::create(eventNames().securitypolicyviolationEvent, WTFMove(eventInit), Event::IsTrusted::Yes));
6450 }
6451 
6452 void Document::enqueueHashchangeEvent(const String&amp; oldURL, const String&amp; newURL)
6453 {
6454     // FIXME: popstate event and hashchange event are supposed to fire in a single task.
6455     queueTaskToDispatchEventOnWindow(TaskSource::DOMManipulation, HashChangeEvent::create(oldURL, newURL));
6456 }
6457 
6458 void Document::dispatchPopstateEvent(RefPtr&lt;SerializedScriptValue&gt;&amp;&amp; stateObject)
6459 {
6460     dispatchWindowEvent(PopStateEvent::create(WTFMove(stateObject), m_domWindow ? &amp;m_domWindow-&gt;history() : nullptr));
6461 }
6462 
6463 void Document::addMediaCanStartListener(MediaCanStartListener&amp; listener)
6464 {
6465     ASSERT(!m_mediaCanStartListeners.contains(&amp;listener));
6466     m_mediaCanStartListeners.add(&amp;listener);
6467 }
6468 
6469 void Document::removeMediaCanStartListener(MediaCanStartListener&amp; listener)
6470 {
6471     ASSERT(m_mediaCanStartListeners.contains(&amp;listener));
6472     m_mediaCanStartListeners.remove(&amp;listener);
6473 }
6474 
6475 MediaCanStartListener* Document::takeAnyMediaCanStartListener()
6476 {
6477     return m_mediaCanStartListeners.takeAny();
6478 }
6479 
6480 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
6481 
6482 DeviceMotionController&amp; Document::deviceMotionController() const
6483 {
6484     return *m_deviceMotionController;
6485 }
6486 
6487 DeviceOrientationController&amp; Document::deviceOrientationController() const
6488 {
6489     return *m_deviceOrientationController;
6490 }
6491 
6492 void Document::simulateDeviceOrientationChange(double alpha, double beta, double gamma)
6493 {
6494     auto orientation = DeviceOrientationData::create(alpha, beta, gamma, WTF::nullopt, WTF::nullopt);
6495     deviceOrientationController().didChangeDeviceOrientation(orientation.ptr());
6496 }
6497 
6498 #endif
6499 
6500 #if ENABLE(POINTER_LOCK)
6501 
6502 void Document::exitPointerLock()
6503 {
6504     Page* page = this-&gt;page();
6505     if (!page)
6506         return;
6507     if (auto* target = page-&gt;pointerLockController().element()) {
6508         if (&amp;target-&gt;document() != this)
6509             return;
6510     }
6511     page-&gt;pointerLockController().requestPointerUnlock();
6512 }
6513 
6514 #endif
6515 
6516 void Document::decrementLoadEventDelayCount()
6517 {
6518     ASSERT(m_loadEventDelayCount);
6519     --m_loadEventDelayCount;
6520 
6521     if (frame() &amp;&amp; !m_loadEventDelayCount &amp;&amp; !m_loadEventDelayTimer.isActive())
6522         m_loadEventDelayTimer.startOneShot(0_s);
6523 }
6524 
6525 void Document::loadEventDelayTimerFired()
6526 {
6527     // FIXME: Should the call to FrameLoader::checkLoadComplete be moved inside Document::checkCompleted?
6528     // FIXME: Should this also call DocumentLoader::checkLoadComplete?
6529     // FIXME: Not obvious why checkCompleted needs to go first. The order these are called is
6530     // visible to WebKit clients, but it&#39;s more like a race than a well-defined relationship.
6531     Ref&lt;Document&gt; protectedThis(*this);
6532     checkCompleted();
6533     if (auto* frame = this-&gt;frame())
6534         frame-&gt;loader().checkLoadComplete();
6535 }
6536 
6537 void Document::checkCompleted()
6538 {
6539     if (auto* frame = this-&gt;frame())
6540         frame-&gt;loader().checkCompleted();
6541 }
6542 
6543 double Document::monotonicTimestamp() const
6544 {
6545     auto* loader = this-&gt;loader();
6546     if (!loader)
6547         return 0;
6548 
6549     return loader-&gt;timing().secondsSinceStartTime(MonotonicTime::now()).seconds();
6550 }
6551 
6552 int Document::requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp; callback)
6553 {
6554     if (!m_scriptedAnimationController) {
6555         m_scriptedAnimationController = ScriptedAnimationController::create(*this);
6556 
6557         // It&#39;s possible that the Page may have suspended scripted animations before
6558         // we were created. We need to make sure that we don&#39;t start up the animation
6559         // controller on a background tab, for example.
6560         if (!page() || page()-&gt;scriptedAnimationsSuspended())
6561             m_scriptedAnimationController-&gt;suspend();
6562 
6563         if (page() &amp;&amp; page()-&gt;isLowPowerModeEnabled())
6564             m_scriptedAnimationController-&gt;addThrottlingReason(ScriptedAnimationController::ThrottlingReason::LowPowerMode);
6565 
6566         if (!topOrigin().canAccess(securityOrigin()) &amp;&amp; !hasHadUserInteraction())
6567             m_scriptedAnimationController-&gt;addThrottlingReason(ScriptedAnimationController::ThrottlingReason::NonInteractedCrossOriginFrame);
6568     }
6569 
6570     return m_scriptedAnimationController-&gt;registerCallback(WTFMove(callback));
6571 }
6572 
6573 void Document::cancelAnimationFrame(int id)
6574 {
6575     if (!m_scriptedAnimationController)
6576         return;
6577     m_scriptedAnimationController-&gt;cancelCallback(id);
6578 }
6579 
6580 void Document::clearScriptedAnimationController()
6581 {
6582     // FIXME: consider using ActiveDOMObject.
6583     if (m_scriptedAnimationController)
6584         m_scriptedAnimationController-&gt;clearDocumentPointer();
6585     m_scriptedAnimationController = nullptr;
6586 }
6587 
6588 int Document::requestIdleCallback(Ref&lt;IdleRequestCallback&gt;&amp;&amp; callback, Seconds timeout)
6589 {
6590     if (!m_idleCallbackController)
6591         m_idleCallbackController = makeUnique&lt;IdleCallbackController&gt;(*this);
6592     return m_idleCallbackController-&gt;queueIdleCallback(WTFMove(callback), timeout);
6593 }
6594 
6595 void Document::cancelIdleCallback(int id)
6596 {
6597     if (!m_idleCallbackController)
6598         return;
6599     m_idleCallbackController-&gt;removeIdleCallback(id);
6600 }
6601 
6602 void Document::wheelEventHandlersChanged()
6603 {
6604     Page* page = this-&gt;page();
6605     if (!page)
6606         return;
6607 
6608     if (FrameView* frameView = view()) {
6609         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
6610             scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);
6611     }
6612 
6613     bool haveHandlers = m_wheelEventTargets &amp;&amp; !m_wheelEventTargets-&gt;isEmpty();
6614     page-&gt;chrome().client().wheelEventHandlersChanged(haveHandlers);
6615 }
6616 
6617 void Document::didAddWheelEventHandler(Node&amp; node)
6618 {
6619     if (!m_wheelEventTargets)
6620         m_wheelEventTargets = makeUnique&lt;EventTargetSet&gt;();
6621 
6622     m_wheelEventTargets-&gt;add(&amp;node);
6623 
6624     wheelEventHandlersChanged();
6625 
6626     if (Frame* frame = this-&gt;frame())
6627         DebugPageOverlays::didChangeEventHandlers(*frame);
6628 }
6629 
6630 HttpEquivPolicy Document::httpEquivPolicy() const
6631 {
6632     if (shouldEnforceContentDispositionAttachmentSandbox())
6633         return HttpEquivPolicy::DisabledByContentDispositionAttachmentSandbox;
6634     if (page() &amp;&amp; !page()-&gt;settings().httpEquivEnabled())
6635         return HttpEquivPolicy::DisabledBySettings;
6636     return HttpEquivPolicy::Enabled;
6637 }
6638 
6639 static bool removeHandlerFromSet(EventTargetSet&amp; handlerSet, Node&amp; node, EventHandlerRemoval removal)
6640 {
6641     switch (removal) {
6642     case EventHandlerRemoval::One:
6643         return handlerSet.remove(&amp;node);
6644     case EventHandlerRemoval::All:
6645         return handlerSet.removeAll(&amp;node);
6646     }
6647     return false;
6648 }
6649 
6650 void Document::didRemoveWheelEventHandler(Node&amp; node, EventHandlerRemoval removal)
6651 {
6652     if (!m_wheelEventTargets)
6653         return;
6654 
6655     if (!removeHandlerFromSet(*m_wheelEventTargets, node, removal))
6656         return;
6657 
6658     wheelEventHandlersChanged();
6659 
6660     if (Frame* frame = this-&gt;frame())
6661         DebugPageOverlays::didChangeEventHandlers(*frame);
6662 }
6663 
6664 unsigned Document::wheelEventHandlerCount() const
6665 {
6666     if (!m_wheelEventTargets)
6667         return 0;
6668 
6669     unsigned count = 0;
6670     for (auto&amp; handler : *m_wheelEventTargets)
6671         count += handler.value;
6672 
6673     return count;
6674 }
6675 
6676 void Document::didAddTouchEventHandler(Node&amp; handler)
6677 {
6678 #if ENABLE(TOUCH_EVENTS)
6679     if (!m_touchEventTargets)
6680         m_touchEventTargets = makeUnique&lt;EventTargetSet&gt;();
6681 
6682     m_touchEventTargets-&gt;add(&amp;handler);
6683 
6684     if (Document* parent = parentDocument()) {
6685         parent-&gt;didAddTouchEventHandler(*this);
6686         return;
6687     }
6688 #else
6689     UNUSED_PARAM(handler);
6690 #endif
6691 }
6692 
6693 void Document::didRemoveTouchEventHandler(Node&amp; handler, EventHandlerRemoval removal)
6694 {
6695 #if ENABLE(TOUCH_EVENTS)
6696     if (!m_touchEventTargets)
6697         return;
6698 
6699     removeHandlerFromSet(*m_touchEventTargets, handler, removal);
6700 
6701     if (Document* parent = parentDocument())
6702         parent-&gt;didRemoveTouchEventHandler(*this);
6703 #else
6704     UNUSED_PARAM(handler);
6705     UNUSED_PARAM(removal);
6706 #endif
6707 }
6708 
6709 void Document::didRemoveEventTargetNode(Node&amp; handler)
6710 {
6711 #if ENABLE(TOUCH_EVENTS)
6712     if (m_touchEventTargets) {
6713         m_touchEventTargets-&gt;removeAll(&amp;handler);
6714         if ((&amp;handler == this || m_touchEventTargets-&gt;isEmpty()) &amp;&amp; parentDocument())
6715             parentDocument()-&gt;didRemoveEventTargetNode(*this);
6716     }
6717 #endif
6718 
6719     if (m_wheelEventTargets) {
6720         m_wheelEventTargets-&gt;removeAll(&amp;handler);
6721         if ((&amp;handler == this || m_wheelEventTargets-&gt;isEmpty()) &amp;&amp; parentDocument())
6722             parentDocument()-&gt;didRemoveEventTargetNode(*this);
6723     }
6724 }
6725 
6726 unsigned Document::touchEventHandlerCount() const
6727 {
6728 #if ENABLE(TOUCH_EVENTS)
6729     if (!m_touchEventTargets)
6730         return 0;
6731 
6732     unsigned count = 0;
6733     for (auto&amp; handler : *m_touchEventTargets)
6734         count += handler.value;
6735 
6736     return count;
6737 #else
6738     return 0;
6739 #endif
6740 }
6741 
6742 LayoutRect Document::absoluteEventHandlerBounds(bool&amp; includesFixedPositionElements)
6743 {
6744     includesFixedPositionElements = false;
6745     if (RenderView* renderView = this-&gt;renderView())
6746         return renderView-&gt;documentRect();
6747 
6748     return LayoutRect();
6749 }
6750 
6751 Document::RegionFixedPair Document::absoluteEventRegionForNode(Node&amp; node)
6752 {
6753     Region region;
6754     LayoutRect rootRelativeBounds;
6755     bool insideFixedPosition = false;
6756 
6757     if (is&lt;Document&gt;(node)) {
6758         auto&amp; document = downcast&lt;Document&gt;(node);
6759         if (&amp;document == this)
6760             rootRelativeBounds = absoluteEventHandlerBounds(insideFixedPosition);
6761         else if (Element* element = document.ownerElement())
6762             rootRelativeBounds = element-&gt;absoluteEventHandlerBounds(insideFixedPosition);
6763     } else if (is&lt;Element&gt;(node)) {
6764         auto&amp; element = downcast&lt;Element&gt;(node);
6765         if (is&lt;HTMLBodyElement&gt;(element)) {
6766             // For the body, just use the document bounds.
6767             // The body may not cover this whole area, but it&#39;s OK for this region to be an overestimate.
6768             rootRelativeBounds = absoluteEventHandlerBounds(insideFixedPosition);
6769         } else
6770             rootRelativeBounds = element.absoluteEventHandlerBounds(insideFixedPosition);
6771     }
6772 
6773     if (!rootRelativeBounds.isEmpty())
6774         region.unite(Region(enclosingIntRect(rootRelativeBounds)));
6775 
6776     return RegionFixedPair(region, insideFixedPosition);
6777 }
6778 
6779 Document::RegionFixedPair Document::absoluteRegionForEventTargets(const EventTargetSet* targets)
6780 {
6781     LayoutDisallowedScope layoutDisallowedScope(LayoutDisallowedScope::Reason::ReentrancyAvoidance);
6782 
6783     if (!targets)
6784         return RegionFixedPair(Region(), false);
6785 
6786     Region targetRegion;
6787     bool insideFixedPosition = false;
6788 
6789     for (auto&amp; keyValuePair : *targets) {
6790         if (auto* node = keyValuePair.key) {
6791             auto targetRegionFixedPair = absoluteEventRegionForNode(*node);
6792             targetRegion.unite(targetRegionFixedPair.first);
6793             insideFixedPosition |= targetRegionFixedPair.second;
6794         }
6795     }
6796 
6797     return RegionFixedPair(targetRegion, insideFixedPosition);
6798 }
6799 
6800 void Document::updateLastHandledUserGestureTimestamp(MonotonicTime time)
6801 {
6802     m_lastHandledUserGestureTimestamp = time;
6803 
6804     if (static_cast&lt;bool&gt;(time) &amp;&amp; m_scriptedAnimationController) {
6805         // It&#39;s OK to always remove NonInteractedCrossOriginFrame even if this frame isn&#39;t cross-origin.
6806         m_scriptedAnimationController-&gt;removeThrottlingReason(ScriptedAnimationController::ThrottlingReason::NonInteractedCrossOriginFrame);
6807     }
6808 
6809     // DOM Timer alignment may depend on the user having interacted with the document.
6810     didChangeTimerAlignmentInterval();
6811 
6812     if (HTMLFrameOwnerElement* element = ownerElement())
6813         element-&gt;document().updateLastHandledUserGestureTimestamp(time);
6814 }
6815 
6816 bool Document::processingUserGestureForMedia() const
6817 {
6818     if (UserGestureIndicator::processingUserGestureForMedia())
6819         return true;
6820 
6821     if (m_userActivatedMediaFinishedPlayingTimestamp + maxIntervalForUserGestureForwardingAfterMediaFinishesPlaying &gt;= MonotonicTime::now())
6822         return true;
6823 
6824     if (settings().mediaUserGestureInheritsFromDocument())
6825         return topDocument().hasHadUserInteraction();
6826 
6827     auto* loader = this-&gt;loader();
6828     if (loader &amp;&amp; loader-&gt;allowedAutoplayQuirks().contains(AutoplayQuirk::InheritedUserGestures))
6829         return topDocument().hasHadUserInteraction();
6830 
6831     return false;
6832 }
6833 
6834 void Document::startTrackingStyleRecalcs()
6835 {
6836     m_styleRecalcCount = 0;
6837 }
6838 
6839 unsigned Document::styleRecalcCount() const
6840 {
6841     return m_styleRecalcCount;
6842 }
6843 
6844 DocumentLoader* Document::loader() const
6845 {
6846     if (!m_frame)
6847         return nullptr;
6848 
6849     DocumentLoader* loader = m_frame-&gt;loader().documentLoader();
6850     if (!loader)
6851         return nullptr;
6852 
6853     if (m_frame-&gt;document() != this)
6854         return nullptr;
6855 
6856     return loader;
6857 }
6858 
6859 #if ENABLE(CSS_DEVICE_ADAPTATION)
6860 
6861 IntSize Document::initialViewportSize() const
6862 {
6863     if (!view())
6864         return IntSize();
6865     return view()-&gt;initialViewportSize();
6866 }
6867 
6868 #endif
6869 
6870 Element* eventTargetElementForDocument(Document* document)
6871 {
6872     if (!document)
6873         return nullptr;
6874     Element* element = document-&gt;focusedElement();
6875     if (!element &amp;&amp; is&lt;PluginDocument&gt;(*document))
6876         element = downcast&lt;PluginDocument&gt;(*document).pluginElement();
6877     if (!element &amp;&amp; document-&gt;isHTMLDocument())
6878         element = document-&gt;bodyOrFrameset();
6879     if (!element)
6880         element = document-&gt;documentElement();
6881     return element;
6882 }
6883 
6884 void Document::convertAbsoluteToClientQuads(Vector&lt;FloatQuad&gt;&amp; quads, const RenderStyle&amp; style)
6885 {
6886     if (!view())
6887         return;
6888 
6889     const auto&amp; frameView = *view();
6890     float inverseFrameScale = frameView.absoluteToDocumentScaleFactor(style.effectiveZoom());
6891     auto documentToClientOffset = frameView.documentToClientOffset();
6892 
6893     for (auto&amp; quad : quads) {
6894         if (inverseFrameScale != 1)
6895             quad.scale(inverseFrameScale);
6896 
6897         quad.move(documentToClientOffset);
6898     }
6899 }
6900 
6901 void Document::convertAbsoluteToClientRects(Vector&lt;FloatRect&gt;&amp; rects, const RenderStyle&amp; style)
6902 {
6903     if (!view())
6904         return;
6905 
6906     auto&amp; frameView = *view();
6907     float inverseFrameScale = frameView.absoluteToDocumentScaleFactor(style.effectiveZoom());
6908     auto documentToClientOffset = frameView.documentToClientOffset();
6909 
6910     for (auto&amp; rect : rects) {
6911         if (inverseFrameScale != 1)
6912             rect.scale(inverseFrameScale);
6913 
6914         rect.move(documentToClientOffset);
6915     }
6916 }
6917 
6918 void Document::convertAbsoluteToClientRect(FloatRect&amp; rect, const RenderStyle&amp; style)
6919 {
6920     if (!view())
6921         return;
6922 
6923     const auto&amp; frameView = *view();
6924     rect = frameView.absoluteToDocumentRect(rect, style.effectiveZoom());
6925     rect = frameView.documentToClientRect(rect);
6926 }
6927 
6928 bool Document::hasActiveParser()
6929 {
6930     return m_activeParserCount || (m_parser &amp;&amp; m_parser-&gt;processingData());
6931 }
6932 
6933 void Document::decrementActiveParserCount()
6934 {
6935     --m_activeParserCount;
6936     if (!frame())
6937         return;
6938 
6939     // FIXME: We should call DocumentLoader::checkLoadComplete as well here,
6940     // but it seems to cause http/tests/security/feed-urls-from-remote.html
6941     // to timeout on Mac WK1; see http://webkit.org/b/110554 and http://webkit.org/b/110401.
6942     frame()-&gt;loader().checkLoadComplete();
6943 }
6944 
6945 DocumentParserYieldToken::DocumentParserYieldToken(Document&amp; document)
6946     : m_document(makeWeakPtr(document))
6947 {
6948     if (++document.m_parserYieldTokenCount != 1)
6949         return;
6950 
6951     document.scriptRunner().didBeginYieldingParser();
6952     if (auto* parser = document.parser())
6953         parser-&gt;didBeginYieldingParser();
6954 }
6955 
6956 DocumentParserYieldToken::~DocumentParserYieldToken()
6957 {
6958     if (!m_document)
6959         return;
6960 
6961     ASSERT(m_document-&gt;m_parserYieldTokenCount);
6962     if (--m_document-&gt;m_parserYieldTokenCount)
6963         return;
6964 
6965     m_document-&gt;scriptRunner().didEndYieldingParser();
6966     if (auto* parser = m_document-&gt;parser())
6967         parser-&gt;didEndYieldingParser();
6968 }
6969 
6970 static Element* findNearestCommonComposedAncestor(Element* elementA, Element* elementB)
6971 {
6972     if (!elementA || !elementB)
6973         return nullptr;
6974 
6975     if (elementA == elementB)
6976         return elementA;
6977 
6978     HashSet&lt;Element*&gt; ancestorChain;
6979     for (auto* element = elementA; element; element = element-&gt;parentElementInComposedTree())
6980         ancestorChain.add(element);
6981 
6982     for (auto* element = elementB; element; element = element-&gt;parentElementInComposedTree()) {
6983         if (ancestorChain.contains(element))
6984             return element;
6985     }
6986     return nullptr;
6987 }
6988 
6989 void Document::updateHoverActiveState(const HitTestRequest&amp; request, Element* innerElement, CaptureChange captureElementChanged)
6990 {
6991     ASSERT(!request.readOnly());
6992 
6993     Element* innerElementInDocument = innerElement;
6994     while (innerElementInDocument &amp;&amp; &amp;innerElementInDocument-&gt;document() != this) {
6995         innerElementInDocument-&gt;document().updateHoverActiveState(request, innerElementInDocument);
6996         innerElementInDocument = innerElementInDocument-&gt;document().ownerElement();
6997     }
6998 
6999     Element* oldActiveElement = m_activeElement.get();
7000     if (oldActiveElement &amp;&amp; !request.active()) {
7001         // We are clearing the :active chain because the mouse has been released.
7002         for (Element* currentElement = oldActiveElement; currentElement; currentElement = currentElement-&gt;parentElementInComposedTree()) {
7003             currentElement-&gt;setActive(false);
7004             m_userActionElements.setInActiveChain(*currentElement, false);
7005         }
7006         m_activeElement = nullptr;
7007     } else {
7008         Element* newActiveElement = innerElementInDocument;
7009         if (!oldActiveElement &amp;&amp; newActiveElement &amp;&amp; request.active() &amp;&amp; !request.touchMove()) {
7010             // We are setting the :active chain and freezing it. If future moves happen, they
7011             // will need to reference this chain.
7012             for (RenderElement* curr = newActiveElement-&gt;renderer(); curr; curr = curr-&gt;parent()) {
7013                 Element* element = curr-&gt;element();
7014                 if (!element || curr-&gt;isTextOrLineBreak())
7015                     continue;
7016                 m_userActionElements.setInActiveChain(*element, true);
7017             }
7018 
7019             m_activeElement = newActiveElement;
7020         }
7021     }
7022     // If the mouse has just been pressed, set :active on the chain. Those (and only those)
7023     // nodes should remain :active until the mouse is released.
7024     bool allowActiveChanges = !oldActiveElement &amp;&amp; m_activeElement;
7025 
7026     // If the mouse is down and if this is a mouse move event, we want to restrict changes in
7027     // :hover/:active to only apply to elements that are in the :active chain that we froze
7028     // at the time the mouse went down, unless the capture element changed.
7029     bool mustBeInActiveChain = request.active() &amp;&amp; request.move() &amp;&amp; captureElementChanged == CaptureChange::No;
7030 
7031     RefPtr&lt;Element&gt; oldHoveredElement = WTFMove(m_hoveredElement);
7032 
7033     // A touch release does not set a new hover target; clearing the element we&#39;re working with
7034     // will clear the chain of hovered elements all the way to the top of the tree.
7035     if (request.touchRelease())
7036         innerElementInDocument = nullptr;
7037 
7038     // Check to see if the hovered Element has changed.
7039     // If it hasn&#39;t, we do not need to do anything.
7040     Element* newHoveredElement = innerElementInDocument;
7041     while (newHoveredElement &amp;&amp; !newHoveredElement-&gt;renderer())
7042         newHoveredElement = newHoveredElement-&gt;parentElementInComposedTree();
7043 
7044     m_hoveredElement = newHoveredElement;
7045 
7046     auto* commonAncestor = findNearestCommonComposedAncestor(oldHoveredElement.get(), newHoveredElement);
7047 
7048     Vector&lt;RefPtr&lt;Element&gt;, 32&gt; elementsToRemoveFromChain;
7049     Vector&lt;RefPtr&lt;Element&gt;, 32&gt; elementsToAddToChain;
7050 
7051     if (oldHoveredElement != newHoveredElement) {
7052         for (auto* element = oldHoveredElement.get(); element; element = element-&gt;parentElementInComposedTree()) {
7053             if (element == commonAncestor)
7054                 break;
7055             if (!mustBeInActiveChain || element-&gt;isInActiveChain())
7056                 elementsToRemoveFromChain.append(element);
7057         }
7058         // Unset hovered nodes in sub frame documents if the old hovered node was a frame owner.
7059         if (is&lt;HTMLFrameOwnerElement&gt;(oldHoveredElement)) {
7060             if (auto* contentDocument = downcast&lt;HTMLFrameOwnerElement&gt;(*oldHoveredElement).contentDocument())
7061                 contentDocument-&gt;updateHoverActiveState(request, nullptr);
7062         }
7063     }
7064 
7065     for (auto* element = newHoveredElement; element; element = element-&gt;parentElementInComposedTree()) {
7066         if (!mustBeInActiveChain || element-&gt;isInActiveChain())
7067             elementsToAddToChain.append(element);
7068     }
7069 
7070     for (auto&amp; element : elementsToRemoveFromChain)
7071         element-&gt;setHovered(false);
7072 
7073     bool sawCommonAncestor = false;
7074     for (auto&amp; element : elementsToAddToChain) {
7075         if (allowActiveChanges)
7076             element-&gt;setActive(true);
7077         if (element == commonAncestor)
7078             sawCommonAncestor = true;
7079         if (!sawCommonAncestor) {
7080             // Elements after the common hover ancestor does not change hover state, but are iterated over because they may change active state.
7081             element-&gt;setHovered(true);
7082         }
7083     }
7084 }
7085 
7086 bool Document::haveStylesheetsLoaded() const
7087 {
7088     return !styleScope().hasPendingSheets() || m_ignorePendingStylesheets;
7089 }
7090 
7091 Locale&amp; Document::getCachedLocale(const AtomString&amp; locale)
7092 {
7093     AtomString localeKey = locale;
7094     if (locale.isEmpty() || !settings().langAttributeAwareFormControlUIEnabled())
7095         localeKey = defaultLanguage();
7096     LocaleIdentifierToLocaleMap::AddResult result = m_localeCache.add(localeKey, nullptr);
7097     if (result.isNewEntry)
7098         result.iterator-&gt;value = Locale::create(localeKey);
7099     return *(result.iterator-&gt;value);
7100 }
7101 
7102 Document&amp; Document::ensureTemplateDocument()
7103 {
7104     if (const Document* document = templateDocument())
7105         return const_cast&lt;Document&amp;&gt;(*document);
7106 
7107     if (isHTMLDocument())
7108         m_templateDocument = HTMLDocument::create(nullptr, WTF::blankURL());
7109     else
7110         m_templateDocument = create(WTF::blankURL());
7111 
7112     m_templateDocument-&gt;setContextDocument(contextDocument());
7113     m_templateDocument-&gt;setTemplateDocumentHost(this); // balanced in dtor.
7114 
7115     return *m_templateDocument;
7116 }
7117 
7118 Ref&lt;FontFaceSet&gt; Document::fonts()
7119 {
7120     updateStyleIfNeeded();
7121     return fontSelector().fontFaceSet();
7122 }
7123 
7124 EditingBehavior Document::editingBehavior() const
7125 {
7126     return EditingBehavior { settings().editingBehaviorType() };
7127 }
7128 
7129 float Document::deviceScaleFactor() const
7130 {
7131     float deviceScaleFactor = 1.0;
7132     if (Page* documentPage = page())
7133         deviceScaleFactor = documentPage-&gt;deviceScaleFactor();
7134     return deviceScaleFactor;
7135 }
7136 
7137 bool Document::useSystemAppearance() const
7138 {
7139     if (auto* documentPage = page())
7140         return documentPage-&gt;useSystemAppearance();
7141     return false;
7142 }
7143 
7144 bool Document::useDarkAppearance(const RenderStyle* style) const
7145 {
7146 #if ENABLE(DARK_MODE_CSS)
7147     OptionSet&lt;ColorScheme&gt; colorScheme;
7148 
7149     // Use the style&#39;s supported color schemes, if supplied.
7150     if (style)
7151         colorScheme = style-&gt;colorScheme().colorScheme();
7152 
7153     // Fallback to the document&#39;s supported color schemes if style was empty (auto).
7154     if (colorScheme.isEmpty())
7155         colorScheme = m_colorScheme;
7156 
7157     if (colorScheme.contains(ColorScheme::Dark) &amp;&amp; !colorScheme.contains(ColorScheme::Light))
7158         return true;
7159 #else
7160     UNUSED_PARAM(style);
7161 #endif
7162 
7163     bool pageUsesDarkAppearance = false;
7164     if (Page* documentPage = page())
7165         pageUsesDarkAppearance = documentPage-&gt;useDarkAppearance();
7166 
7167     if (useSystemAppearance())
7168         return pageUsesDarkAppearance;
7169 
7170 #if ENABLE(DARK_MODE_CSS)
7171     if (colorScheme.contains(ColorScheme::Dark))
7172         return pageUsesDarkAppearance;
7173 #endif
7174 
7175     return false;
7176 }
7177 
7178 bool Document::useElevatedUserInterfaceLevel() const
7179 {
7180     if (auto* documentPage = page())
7181         return documentPage-&gt;useElevatedUserInterfaceLevel();
7182     return false;
7183 }
7184 
7185 OptionSet&lt;StyleColor::Options&gt; Document::styleColorOptions(const RenderStyle* style) const
7186 {
7187     OptionSet&lt;StyleColor::Options&gt; options;
7188     if (useSystemAppearance())
7189         options.add(StyleColor::Options::UseSystemAppearance);
7190     if (useDarkAppearance(style))
7191         options.add(StyleColor::Options::UseDarkAppearance);
7192     if (useElevatedUserInterfaceLevel())
7193         options.add(StyleColor::Options::UseElevatedUserInterfaceLevel);
7194     return options;
7195 }
7196 
7197 CompositeOperator Document::compositeOperatorForBackgroundColor(const Color&amp; color, const RenderObject&amp; renderer) const
7198 {
7199     if (LIKELY(!settings().punchOutWhiteBackgroundsInDarkMode() || !Color::isWhiteColor(color) || !renderer.useDarkAppearance()))
7200         return CompositeOperator::SourceOver;
7201 
7202     auto* frameView = view();
7203     if (!frameView)
7204         return CompositeOperator::SourceOver;
7205 
7206     // Mail on macOS uses a transparent view, and on iOS it is an opaque view. We need to
7207     // use different composite modes to get the right results in this case.
7208     return frameView-&gt;isTransparent() ? CompositeOperator::DestinationOut : CompositeOperator::DestinationIn;
7209 }
7210 
7211 void Document::didAssociateFormControl(Element&amp; element)
7212 {
7213     auto* page = this-&gt;page();
7214     if (!page || !page-&gt;chrome().client().shouldNotifyOnFormChanges())
7215         return;
7216     m_associatedFormControls.add(&amp;element);
7217     if (!m_didAssociateFormControlsTimer.isActive())
7218         m_didAssociateFormControlsTimer.startOneShot(0_s);
7219 }
7220 
7221 void Document::didAssociateFormControlsTimerFired()
7222 {
7223     auto vector = copyToVector(m_associatedFormControls);
7224     m_associatedFormControls.clear();
7225     if (auto* page = this-&gt;page()) {
7226         ASSERT(m_frame);
7227         page-&gt;chrome().client().didAssociateFormControls(vector, *m_frame);
7228     }
7229 }
7230 
7231 void Document::setCachedDOMCookies(const String&amp; cookies)
7232 {
7233     ASSERT(!isDOMCookieCacheValid());
7234     m_cachedDOMCookies = cookies;
7235     // The cookie cache is valid at most until we go back to the event loop.
7236     m_cookieCacheExpiryTimer.startOneShot(0_s);
7237 }
7238 
7239 void Document::invalidateDOMCookieCache()
7240 {
7241     m_cookieCacheExpiryTimer.stop();
7242     m_cachedDOMCookies = String();
7243 }
7244 
7245 void Document::didLoadResourceSynchronously()
7246 {
7247     // Synchronous resources loading can set cookies so we invalidate the cookies cache
7248     // in this case, to be safe.
7249     invalidateDOMCookieCache();
7250 }
7251 
7252 void Document::ensurePlugInsInjectedScript(DOMWrapperWorld&amp; world)
7253 {
7254     if (m_hasInjectedPlugInsScript)
7255         return;
7256 
7257     auto&amp; scriptController = frame()-&gt;script();
7258 
7259     // Use the JS file provided by the Chrome client, or fallback to the default one.
7260     String jsString = page()-&gt;chrome().client().plugInExtraScript();
7261     if (!jsString || !scriptController.shouldAllowUserAgentScripts(*this))
7262         jsString = String(plugInsJavaScript, sizeof(plugInsJavaScript));
7263 
7264     setHasEvaluatedUserAgentScripts();
7265     scriptController.evaluateInWorldIgnoringException(ScriptSourceCode(jsString), world);
7266 
7267     m_hasInjectedPlugInsScript = true;
7268 }
7269 
7270 #if ENABLE(WEB_CRYPTO)
7271 
7272 bool Document::wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey)
7273 {
7274     Page* page = this-&gt;page();
7275     if (!page)
7276         return false;
7277     return page-&gt;chrome().client().wrapCryptoKey(key, wrappedKey);
7278 }
7279 
7280 bool Document::unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key)
7281 {
7282     Page* page = this-&gt;page();
7283     if (!page)
7284         return false;
7285     return page-&gt;chrome().client().unwrapCryptoKey(wrappedKey, key);
7286 }
7287 
7288 #endif // ENABLE(WEB_CRYPTO)
7289 
7290 Element* Document::activeElement()
7291 {
7292     if (Element* element = treeScope().focusedElementInScope())
7293         return element;
7294     return bodyOrFrameset();
7295 }
7296 
7297 bool Document::hasFocus() const
7298 {
7299     Page* page = this-&gt;page();
7300     if (!page || !page-&gt;focusController().isActive())
7301         return false;
7302     if (Frame* focusedFrame = page-&gt;focusController().focusedFrame()) {
7303         if (focusedFrame-&gt;tree().isDescendantOf(frame()))
7304             return true;
7305     }
7306     return false;
7307 }
7308 
7309 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7310 
7311 static uint64_t nextPlaybackTargetClientContextId()
7312 {
7313     static uint64_t contextId = 0;
7314     return ++contextId;
7315 }
7316 
7317 void Document::addPlaybackTargetPickerClient(MediaPlaybackTargetClient&amp; client)
7318 {
7319     Page* page = this-&gt;page();
7320     if (!page)
7321         return;
7322 
7323     // FIXME: change this back to an ASSERT once https://webkit.org/b/144970 is fixed.
7324     if (m_clientToIDMap.contains(&amp;client))
7325         return;
7326 
7327     uint64_t contextId = nextPlaybackTargetClientContextId();
7328     m_clientToIDMap.add(&amp;client, contextId);
7329     m_idToClientMap.add(contextId, &amp;client);
7330     page-&gt;addPlaybackTargetPickerClient(contextId);
7331 }
7332 
7333 void Document::removePlaybackTargetPickerClient(MediaPlaybackTargetClient&amp; client)
7334 {
7335     auto it = m_clientToIDMap.find(&amp;client);
7336     if (it == m_clientToIDMap.end())
7337         return;
7338 
7339     uint64_t clientId = it-&gt;value;
7340     m_idToClientMap.remove(clientId);
7341     m_clientToIDMap.remove(it);
7342 
7343     Page* page = this-&gt;page();
7344     if (!page)
7345         return;
7346     page-&gt;removePlaybackTargetPickerClient(clientId);
7347 }
7348 
7349 void Document::showPlaybackTargetPicker(MediaPlaybackTargetClient&amp; client, bool isVideo, RouteSharingPolicy routeSharingPolicy, const String&amp; routingContextUID)
7350 {
7351     Page* page = this-&gt;page();
7352     if (!page)
7353         return;
7354 
7355     auto it = m_clientToIDMap.find(&amp;client);
7356     if (it == m_clientToIDMap.end())
7357         return;
7358 
7359     page-&gt;showPlaybackTargetPicker(it-&gt;value, view()-&gt;lastKnownMousePosition(), isVideo, routeSharingPolicy, routingContextUID);
7360 }
7361 
7362 void Document::playbackTargetPickerClientStateDidChange(MediaPlaybackTargetClient&amp; client, MediaProducer::MediaStateFlags state)
7363 {
7364     Page* page = this-&gt;page();
7365     if (!page)
7366         return;
7367 
7368     auto it = m_clientToIDMap.find(&amp;client);
7369     if (it == m_clientToIDMap.end())
7370         return;
7371 
7372     page-&gt;playbackTargetPickerClientStateDidChange(it-&gt;value, state);
7373 }
7374 
7375 void Document::playbackTargetAvailabilityDidChange(uint64_t clientId, bool available)
7376 {
7377     auto it = m_idToClientMap.find(clientId);
7378     if (it == m_idToClientMap.end())
7379         return;
7380 
7381     it-&gt;value-&gt;externalOutputDeviceAvailableDidChange(available);
7382 }
7383 
7384 void Document::setPlaybackTarget(uint64_t clientId, Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; target)
7385 {
7386     auto it = m_idToClientMap.find(clientId);
7387     if (it == m_idToClientMap.end())
7388         return;
7389 
7390     it-&gt;value-&gt;setPlaybackTarget(target.copyRef());
7391 }
7392 
7393 void Document::setShouldPlayToPlaybackTarget(uint64_t clientId, bool shouldPlay)
7394 {
7395     auto it = m_idToClientMap.find(clientId);
7396     if (it == m_idToClientMap.end())
7397         return;
7398 
7399     it-&gt;value-&gt;setShouldPlayToPlaybackTarget(shouldPlay);
7400 }
7401 
7402 void Document::playbackTargetPickerWasDismissed(uint64_t clientId)
7403 {
7404     auto it = m_idToClientMap.find(clientId);
7405     if (it == m_idToClientMap.end())
7406         return;
7407 
7408     it-&gt;value-&gt;playbackTargetPickerWasDismissed();
7409 }
7410 
7411 #endif // ENABLE(WIRELESS_PLAYBACK_TARGET)
7412 
7413 #if ENABLE(MEDIA_SESSION)
7414 
7415 MediaSession&amp; Document::defaultMediaSession()
7416 {
7417     if (!m_defaultMediaSession)
7418         m_defaultMediaSession = MediaSession::create(*scriptExecutionContext());
7419     return *m_defaultMediaSession;
7420 }
7421 
7422 #endif
7423 
7424 ShouldOpenExternalURLsPolicy Document::shouldOpenExternalURLsPolicyToPropagate() const
7425 {
7426     if (DocumentLoader* documentLoader = loader())
7427         return documentLoader-&gt;shouldOpenExternalURLsPolicyToPropagate();
7428 
7429     return ShouldOpenExternalURLsPolicy::ShouldNotAllow;
7430 }
7431 
7432 bool Document::shouldEnforceHTTP09Sandbox() const
7433 {
7434     if (m_isSynthesized || !m_frame)
7435         return false;
7436     DocumentLoader* documentLoader = m_frame-&gt;loader().activeDocumentLoader();
7437     return documentLoader &amp;&amp; documentLoader-&gt;response().isHTTP09();
7438 }
7439 
7440 #if USE(QUICK_LOOK)
7441 
7442 bool Document::shouldEnforceQuickLookSandbox() const
7443 {
7444     if (m_isSynthesized || !m_frame)
7445         return false;
7446     DocumentLoader* documentLoader = m_frame-&gt;loader().activeDocumentLoader();
7447     return documentLoader &amp;&amp; documentLoader-&gt;response().isQuickLook();
7448 }
7449 
7450 void Document::applyQuickLookSandbox()
7451 {
7452     auto&amp; documentLoader = *m_frame-&gt;loader().activeDocumentLoader();
7453     auto documentURL = documentLoader.documentURL();
7454     auto&amp; responseURL = documentLoader.responseURL();
7455     ASSERT(!documentURL.protocolIs(QLPreviewProtocol));
7456     ASSERT(responseURL.protocolIs(QLPreviewProtocol));
7457 
7458     auto securityOrigin = SecurityOrigin::createNonLocalWithAllowedFilePath(responseURL, documentURL.fileSystemPath());
7459     securityOrigin-&gt;setStorageBlockingPolicy(SecurityOrigin::BlockAllStorage);
7460     setSecurityOriginPolicy(SecurityOriginPolicy::create(WTFMove(securityOrigin)));
7461 
7462     static NeverDestroyed&lt;String&gt; quickLookCSP = makeString(&quot;default-src &quot;, QLPreviewProtocol, &quot;: &#39;unsafe-inline&#39;; base-uri &#39;none&#39;; sandbox allow-same-origin allow-scripts&quot;);
7463     RELEASE_ASSERT(contentSecurityPolicy());
7464     // The sandbox directive is only allowed if the policy is from an HTTP header.
7465     contentSecurityPolicy()-&gt;didReceiveHeader(quickLookCSP, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::HTTPHeader, referrer());
7466 
7467     disableSandboxFlags(SandboxNavigation);
7468 
7469     setReferrerPolicy(ReferrerPolicy::NoReferrer);
7470 }
7471 
7472 #endif
7473 
7474 bool Document::shouldEnforceContentDispositionAttachmentSandbox() const
7475 {
7476     if (!settings().contentDispositionAttachmentSandboxEnabled())
7477         return false;
7478 
7479     if (m_isSynthesized)
7480         return false;
7481 
7482     if (auto* documentLoader = m_frame ? m_frame-&gt;loader().activeDocumentLoader() : nullptr)
7483         return documentLoader-&gt;response().isAttachment();
7484     return false;
7485 }
7486 
7487 void Document::applyContentDispositionAttachmentSandbox()
7488 {
7489     ASSERT(shouldEnforceContentDispositionAttachmentSandbox());
7490 
7491     setReferrerPolicy(ReferrerPolicy::NoReferrer);
7492     if (!isMediaDocument())
7493         enforceSandboxFlags(SandboxAll);
7494     else
7495         enforceSandboxFlags(SandboxOrigin);
7496 }
7497 
7498 void Document::addDynamicMediaQueryDependentImage(HTMLImageElement&amp; element)
7499 {
7500     m_dynamicMediaQueryDependentImages.add(element);
7501 }
7502 
7503 void Document::removeDynamicMediaQueryDependentImage(HTMLImageElement&amp; element)
7504 {
7505     m_dynamicMediaQueryDependentImages.remove(element);
7506 }
7507 
7508 void Document::scheduleTimedRenderingUpdate()
7509 {
7510 #if ENABLE(INTERSECTION_OBSERVER)
7511     m_intersectionObserversInitialUpdateTimer.stop();
7512 #endif
7513     if (auto page = this-&gt;page())
7514         page-&gt;renderingUpdateScheduler().scheduleTimedRenderingUpdate();
7515 }
7516 
7517 #if ENABLE(INTERSECTION_OBSERVER)
7518 
7519 void Document::addIntersectionObserver(IntersectionObserver&amp; observer)
7520 {
7521     ASSERT(m_intersectionObservers.find(&amp;observer) == notFound);
7522     m_intersectionObservers.append(makeWeakPtr(&amp;observer));
7523 }
7524 
7525 void Document::removeIntersectionObserver(IntersectionObserver&amp; observer)
7526 {
7527     m_intersectionObservers.removeFirst(&amp;observer);
7528 }
7529 
7530 static void expandRootBoundsWithRootMargin(FloatRect&amp; localRootBounds, const LengthBox&amp; rootMargin)
7531 {
7532     FloatBoxExtent rootMarginFloatBox(
7533         floatValueForLength(rootMargin.top(), localRootBounds.height()),
7534         floatValueForLength(rootMargin.right(), localRootBounds.width()),
7535         floatValueForLength(rootMargin.bottom(), localRootBounds.height()),
7536         floatValueForLength(rootMargin.left(), localRootBounds.width())
7537     );
7538 
7539     localRootBounds.expand(rootMarginFloatBox);
7540 }
7541 
7542 static Optional&lt;LayoutRect&gt; computeClippedRectInRootContentsSpace(const LayoutRect&amp; rect, const RenderElement* renderer)
7543 {
7544     OptionSet&lt;RenderObject::VisibleRectContextOption&gt; visibleRectOptions = { RenderObject::VisibleRectContextOption::UseEdgeInclusiveIntersection, RenderObject::VisibleRectContextOption::ApplyCompositedClips, RenderObject::VisibleRectContextOption::ApplyCompositedContainerScrolls };
7545     Optional&lt;LayoutRect&gt; rectInFrameAbsoluteSpace = renderer-&gt;computeVisibleRectInContainer(rect, &amp;renderer-&gt;view(),  {false /* hasPositionFixedDescendant */, false /* dirtyRectIsFlipped */, visibleRectOptions });
7546     if (!rectInFrameAbsoluteSpace || renderer-&gt;frame().isMainFrame())
7547         return rectInFrameAbsoluteSpace;
7548 
7549     bool intersects = rectInFrameAbsoluteSpace-&gt;edgeInclusiveIntersect(renderer-&gt;view().frameView().layoutViewportRect());
7550     if (!intersects)
7551         return WTF::nullopt;
7552 
7553     LayoutRect rectInFrameViewSpace(renderer-&gt;view().frameView().contentsToView(snappedIntRect(*rectInFrameAbsoluteSpace)));
7554     auto* ownerRenderer = renderer-&gt;frame().ownerRenderer();
7555     if (!ownerRenderer)
7556         return WTF::nullopt;
7557 
7558     rectInFrameViewSpace.moveBy(ownerRenderer-&gt;contentBoxLocation());
7559     return computeClippedRectInRootContentsSpace(rectInFrameViewSpace, ownerRenderer);
7560 }
7561 
7562 struct IntersectionObservationState {
7563     FloatRect absoluteTargetRect;
7564     FloatRect absoluteRootBounds;
7565     FloatRect absoluteIntersectionRect;
7566     bool isIntersecting { false };
7567 };
7568 
7569 static Optional&lt;IntersectionObservationState&gt; computeIntersectionState(FrameView&amp; frameView, const IntersectionObserver&amp; observer, Element&amp; target, bool applyRootMargin)
7570 {
7571     auto* targetRenderer = target.renderer();
7572     if (!targetRenderer)
7573         return WTF::nullopt;
7574 
7575     FloatRect localRootBounds;
7576     RenderBlock* rootRenderer;
7577     if (observer.root()) {
7578         if (observer.trackingDocument() != &amp;target.document())
7579             return WTF::nullopt;
7580 
7581         if (!observer.root()-&gt;renderer() || !is&lt;RenderBlock&gt;(observer.root()-&gt;renderer()))
7582             return WTF::nullopt;
7583 
7584         rootRenderer = downcast&lt;RenderBlock&gt;(observer.root()-&gt;renderer());
7585         if (!rootRenderer-&gt;isContainingBlockAncestorFor(*targetRenderer))
7586             return WTF::nullopt;
7587 
7588         if (rootRenderer-&gt;hasOverflowClip())
7589             localRootBounds = rootRenderer-&gt;contentBoxRect();
7590         else
7591             localRootBounds = { FloatPoint(), rootRenderer-&gt;size() };
7592     } else {
7593         ASSERT(frameView.frame().isMainFrame());
7594         // FIXME: Handle the case of an implicit-root observer that has a target in a different frame tree.
7595         if (&amp;targetRenderer-&gt;frame().mainFrame() != &amp;frameView.frame())
7596             return WTF::nullopt;
7597         rootRenderer = frameView.renderView();
7598         localRootBounds = frameView.layoutViewportRect();
7599     }
7600 
7601     if (applyRootMargin)
7602         expandRootBoundsWithRootMargin(localRootBounds, observer.rootMarginBox());
7603 
7604     LayoutRect localTargetBounds;
7605     if (is&lt;RenderBox&gt;(*targetRenderer))
7606         localTargetBounds = downcast&lt;RenderBox&gt;(targetRenderer)-&gt;borderBoundingBox();
7607     else if (is&lt;RenderInline&gt;(targetRenderer)) {
7608         auto pair = target.boundingAbsoluteRectWithoutLayout();
7609         if (pair) {
7610             FloatRect absoluteTargetBounds = pair-&gt;second;
7611             localTargetBounds = enclosingLayoutRect(targetRenderer-&gt;absoluteToLocalQuad(absoluteTargetBounds).boundingBox());
7612         }
7613     } else if (is&lt;RenderLineBreak&gt;(targetRenderer))
7614         localTargetBounds = downcast&lt;RenderLineBreak&gt;(targetRenderer)-&gt;linesBoundingBox();
7615 
7616     Optional&lt;LayoutRect&gt; rootLocalTargetRect;
7617     if (observer.root()) {
7618         OptionSet&lt;RenderObject::VisibleRectContextOption&gt; visibleRectOptions = { RenderObject::VisibleRectContextOption::UseEdgeInclusiveIntersection, RenderObject::VisibleRectContextOption::ApplyCompositedClips, RenderObject::VisibleRectContextOption::ApplyCompositedContainerScrolls };
7619         rootLocalTargetRect = targetRenderer-&gt;computeVisibleRectInContainer(localTargetBounds, rootRenderer, { false /* hasPositionFixedDescendant */, false /* dirtyRectIsFlipped */, visibleRectOptions });
7620     } else
7621         rootLocalTargetRect = computeClippedRectInRootContentsSpace(localTargetBounds, targetRenderer);
7622 
7623     FloatRect rootLocalIntersectionRect = localRootBounds;
7624 
7625     IntersectionObservationState intersectionState;
7626     intersectionState.isIntersecting = rootLocalTargetRect &amp;&amp; rootLocalIntersectionRect.edgeInclusiveIntersect(*rootLocalTargetRect);
7627     intersectionState.absoluteTargetRect = targetRenderer-&gt;localToAbsoluteQuad(FloatRect(localTargetBounds)).boundingBox();
7628     intersectionState.absoluteRootBounds = rootRenderer-&gt;localToAbsoluteQuad(localRootBounds).boundingBox();
7629 
7630     if (intersectionState.isIntersecting) {
7631         FloatRect rootAbsoluteIntersectionRect = rootRenderer-&gt;localToAbsoluteQuad(rootLocalIntersectionRect).boundingBox();
7632         if (&amp;targetRenderer-&gt;frame() == &amp;rootRenderer-&gt;frame())
7633             intersectionState.absoluteIntersectionRect = rootAbsoluteIntersectionRect;
7634         else {
7635             FloatRect rootViewIntersectionRect = frameView.contentsToView(rootAbsoluteIntersectionRect);
7636             intersectionState.absoluteIntersectionRect = targetRenderer-&gt;view().frameView().rootViewToContents(rootViewIntersectionRect);
7637         }
7638         intersectionState.isIntersecting = intersectionState.absoluteIntersectionRect.edgeInclusiveIntersect(intersectionState.absoluteTargetRect);
7639     }
7640 
7641     return intersectionState;
7642 }
7643 
7644 void Document::updateIntersectionObservations()
7645 {
7646     auto* frameView = view();
7647     if (!frameView)
7648         return;
7649 
7650     m_intersectionObserversInitialUpdateTimer.stop();
7651 
7652     bool needsLayout = frameView-&gt;layoutContext().isLayoutPending() || (renderView() &amp;&amp; renderView()-&gt;needsLayout());
7653     if (needsLayout || hasPendingStyleRecalc())
7654         return;
7655 
7656     for (const auto&amp; observer : m_intersectionObservers) {
7657         bool needNotify = false;
7658         DOMHighResTimeStamp timestamp;
7659         if (!observer-&gt;createTimestamp(timestamp))
7660             continue;
7661         for (Element* target : observer-&gt;observationTargets()) {
7662             auto&amp; targetRegistrations = target-&gt;intersectionObserverData()-&gt;registrations;
7663             auto index = targetRegistrations.findMatching([observer](auto&amp; registration) {
7664                 return registration.observer.get() == observer;
7665             });
7666             ASSERT(index != notFound);
7667             auto&amp; registration = targetRegistrations[index];
7668 
7669             bool isSameOriginObservation = &amp;target-&gt;document() == this || target-&gt;document().securityOrigin().canAccess(securityOrigin());
7670             auto intersectionState = computeIntersectionState(*frameView, *observer, *target, isSameOriginObservation);
7671 
7672             float intersectionRatio = 0;
7673             size_t thresholdIndex = 0;
7674             if (intersectionState) {
7675                 if (intersectionState-&gt;isIntersecting) {
7676                     float absTargetArea = intersectionState-&gt;absoluteTargetRect.area();
7677                     if (absTargetArea)
7678                         intersectionRatio = intersectionState-&gt;absoluteIntersectionRect.area() / absTargetArea;
7679                     else
7680                         intersectionRatio = 1;
7681 
7682                     auto&amp; thresholds = observer-&gt;thresholds();
7683                     while (thresholdIndex &lt; thresholds.size() &amp;&amp; thresholds[thresholdIndex] &lt;= intersectionRatio)
7684                         ++thresholdIndex;
7685                 }
7686             }
7687 
7688             if (!registration.previousThresholdIndex || thresholdIndex != registration.previousThresholdIndex) {
7689                 FloatRect targetBoundingClientRect;
7690                 FloatRect clientIntersectionRect;
7691                 FloatRect clientRootBounds;
7692                 if (intersectionState) {
7693                     auto* targetFrameView = target-&gt;document().view();
7694                     targetBoundingClientRect = targetFrameView-&gt;absoluteToClientRect(intersectionState-&gt;absoluteTargetRect, target-&gt;renderer()-&gt;style().effectiveZoom());
7695                     auto* rootRenderer = observer-&gt;root() ? observer-&gt;root()-&gt;renderer() : frameView-&gt;renderView();
7696                     clientRootBounds = frameView-&gt;absoluteToClientRect(intersectionState-&gt;absoluteRootBounds, rootRenderer-&gt;style().effectiveZoom());
7697                     if (intersectionState-&gt;isIntersecting)
7698                         clientIntersectionRect = targetFrameView-&gt;absoluteToClientRect(intersectionState-&gt;absoluteIntersectionRect, target-&gt;renderer()-&gt;style().effectiveZoom());
7699                 }
7700 
7701                 Optional&lt;DOMRectInit&gt; reportedRootBounds;
7702                 if (isSameOriginObservation) {
7703                     reportedRootBounds = DOMRectInit({
7704                         clientRootBounds.x(),
7705                         clientRootBounds.y(),
7706                         clientRootBounds.width(),
7707                         clientRootBounds.height()
7708                     });
7709                 }
7710 
7711                 observer-&gt;appendQueuedEntry(IntersectionObserverEntry::create({
7712                     timestamp,
7713                     reportedRootBounds,
7714                     { targetBoundingClientRect.x(), targetBoundingClientRect.y(), targetBoundingClientRect.width(), targetBoundingClientRect.height() },
7715                     { clientIntersectionRect.x(), clientIntersectionRect.y(), clientIntersectionRect.width(), clientIntersectionRect.height() },
7716                     intersectionRatio,
7717                     target,
7718                     thresholdIndex &gt; 0,
7719                 }));
7720                 needNotify = true;
7721                 registration.previousThresholdIndex = thresholdIndex;
7722             }
7723         }
7724         if (needNotify)
7725             m_intersectionObserversWithPendingNotifications.append(makeWeakPtr(observer.get()));
7726     }
7727 
7728     if (m_intersectionObserversWithPendingNotifications.size())
7729         m_intersectionObserversNotifyTimer.startOneShot(0_s);
7730 }
7731 
7732 void Document::notifyIntersectionObserversTimerFired()
7733 {
7734     for (const auto&amp; observer : m_intersectionObserversWithPendingNotifications) {
7735         if (observer)
7736             observer-&gt;notify();
7737     }
7738     m_intersectionObserversWithPendingNotifications.clear();
7739 }
7740 
7741 void Document::scheduleInitialIntersectionObservationUpdate()
7742 {
7743     if (m_readyState == Complete)
7744         scheduleTimedRenderingUpdate();
7745     else if (!m_intersectionObserversInitialUpdateTimer.isActive())
7746         m_intersectionObserversInitialUpdateTimer.startOneShot(intersectionObserversInitialUpdateDelay);
7747 }
7748 
7749 #endif
7750 
7751 #if ENABLE(RESIZE_OBSERVER)
7752 
7753 void Document::addResizeObserver(ResizeObserver&amp; observer)
7754 {
7755     if (!m_resizeObservers.contains(&amp;observer))
7756         m_resizeObservers.append(makeWeakPtr(&amp;observer));
7757 }
7758 
7759 void Document::removeResizeObserver(ResizeObserver&amp; observer)
7760 {
7761     m_resizeObservers.removeFirst(&amp;observer);
7762 }
7763 
7764 bool Document::hasResizeObservers()
7765 {
7766     return !m_resizeObservers.isEmpty();
7767 }
7768 
7769 size_t Document::gatherResizeObservations(size_t deeperThan)
7770 {
7771     size_t minDepth = ResizeObserver::maxElementDepth();
7772     for (const auto&amp; observer : m_resizeObservers) {
7773         if (!observer-&gt;hasObservations())
7774             continue;
7775         auto depth = observer-&gt;gatherObservations(deeperThan);
7776         minDepth = std::min(minDepth, depth);
7777     }
7778     return minDepth;
7779 }
7780 
7781 void Document::deliverResizeObservations()
7782 {
7783     auto observersToNotify = m_resizeObservers;
7784     for (const auto&amp; observer : observersToNotify) {
7785         if (!observer || !observer-&gt;hasActiveObservations())
7786             continue;
7787         observer-&gt;deliverObservations();
7788     }
7789 }
7790 
7791 bool Document::hasSkippedResizeObservations() const
7792 {
7793     for (const auto&amp; observer : m_resizeObservers) {
7794         if (observer-&gt;hasSkippedObservations())
7795             return true;
7796     }
7797     return false;
7798 }
7799 
7800 void Document::setHasSkippedResizeObservations(bool skipped)
7801 {
7802     for (const auto&amp; observer : m_resizeObservers)
7803         observer-&gt;setHasSkippedObservations(skipped);
7804 }
7805 
7806 void Document::updateResizeObservations(Page&amp; page)
7807 {
7808     if (!hasResizeObservers())
7809         return;
7810 
7811     // We need layout the whole frame tree here. Because ResizeObserver could observe element in other frame,
7812     // and it could change other frame in deliverResizeObservations().
7813     page.layoutIfNeeded();
7814 
7815     // Start check resize obervers;
7816     for (size_t depth = gatherResizeObservations(0); depth != ResizeObserver::maxElementDepth(); depth = gatherResizeObservations(depth)) {
7817         deliverResizeObservations();
7818         page.layoutIfNeeded();
7819     }
7820 
7821     if (hasSkippedResizeObservations()) {
7822         setHasSkippedResizeObservations(false);
7823         String url;
7824         unsigned line = 0;
7825         unsigned column = 0;
7826         getParserLocation(url, line, column);
7827         reportException(&quot;ResizeObserver loop completed with undelivered notifications.&quot;, line, column, url, nullptr, nullptr);
7828         // Starting a new schedule the next round of notify.
7829         scheduleTimedRenderingUpdate();
7830     }
7831 }
7832 
7833 #endif
7834 
7835 const AtomString&amp; Document::dir() const
7836 {
7837     auto* documentElement = this-&gt;documentElement();
7838     if (!is&lt;HTMLHtmlElement&gt;(documentElement))
7839         return nullAtom();
7840     return downcast&lt;HTMLHtmlElement&gt;(*documentElement).dir();
7841 }
7842 
7843 void Document::setDir(const AtomString&amp; value)
7844 {
7845     auto* documentElement = this-&gt;documentElement();
7846     if (is&lt;HTMLHtmlElement&gt;(documentElement))
7847         downcast&lt;HTMLHtmlElement&gt;(*documentElement).setDir(value);
7848 }
7849 
7850 DOMSelection* Document::getSelection()
7851 {
7852     return m_domWindow ? m_domWindow-&gt;getSelection() : nullptr;
7853 }
7854 
7855 void Document::didInsertInDocumentShadowRoot(ShadowRoot&amp; shadowRoot)
7856 {
7857     ASSERT(shadowRoot.isConnected());
7858     ASSERT(!m_inDocumentShadowRoots.contains(&amp;shadowRoot));
7859     m_inDocumentShadowRoots.add(&amp;shadowRoot);
7860 }
7861 
7862 void Document::didRemoveInDocumentShadowRoot(ShadowRoot&amp; shadowRoot)
7863 {
7864     ASSERT(m_inDocumentShadowRoots.contains(&amp;shadowRoot));
7865     m_inDocumentShadowRoots.remove(&amp;shadowRoot);
7866 }
7867 
7868 void Document::orientationChanged(int orientation)
7869 {
7870     LOG(Events, &quot;Document %p orientationChanged - orientation %d&quot;, this, orientation);
7871     dispatchWindowEvent(Event::create(eventNames().orientationchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
7872     m_orientationNotifier.orientationChanged(orientation);
7873 }
7874 
7875 #if ENABLE(MEDIA_STREAM)
7876 
7877 void Document::stopMediaCapture()
7878 {
7879     MediaStreamTrack::endCapture(*this);
7880 }
7881 
7882 void Document::mediaStreamCaptureStateChanged()
7883 {
7884     if (!MediaProducer::isCapturing(m_mediaState))
7885         return;
7886 
7887     forEachMediaElement([] (HTMLMediaElement&amp; element) {
7888         element.mediaStreamCaptureStarted();
7889     });
7890 }
7891 
7892 void Document::setDeviceIDHashSalt(const String&amp; salt)
7893 {
7894     ASSERT(m_idHashSalt.isEmpty() || m_idHashSalt == salt);
7895     m_idHashSalt = salt;
7896 }
7897 
7898 #endif
7899 
7900 const AtomString&amp; Document::bgColor() const
7901 {
7902     auto* bodyElement = body();
7903     if (!bodyElement)
7904         return emptyAtom();
7905     return bodyElement-&gt;attributeWithoutSynchronization(bgcolorAttr);
7906 }
7907 
7908 void Document::setBgColor(const String&amp; value)
7909 {
7910     if (auto* bodyElement = body())
7911         bodyElement-&gt;setAttributeWithoutSynchronization(bgcolorAttr, value);
7912 }
7913 
7914 const AtomString&amp; Document::fgColor() const
7915 {
7916     auto* bodyElement = body();
7917     if (!bodyElement)
7918         return emptyAtom();
7919     return bodyElement-&gt;attributeWithoutSynchronization(textAttr);
7920 }
7921 
7922 void Document::setFgColor(const String&amp; value)
7923 {
7924     if (auto* bodyElement = body())
7925         bodyElement-&gt;setAttributeWithoutSynchronization(textAttr, value);
7926 }
7927 
7928 const AtomString&amp; Document::alinkColor() const
7929 {
7930     auto* bodyElement = body();
7931     if (!bodyElement)
7932         return emptyAtom();
7933     return bodyElement-&gt;attributeWithoutSynchronization(alinkAttr);
7934 }
7935 
7936 void Document::setAlinkColor(const String&amp; value)
7937 {
7938     if (auto* bodyElement = body())
7939         bodyElement-&gt;setAttributeWithoutSynchronization(alinkAttr, value);
7940 }
7941 
7942 const AtomString&amp; Document::linkColorForBindings() const
7943 {
7944     auto* bodyElement = body();
7945     if (!bodyElement)
7946         return emptyAtom();
7947     return bodyElement-&gt;attributeWithoutSynchronization(linkAttr);
7948 }
7949 
7950 void Document::setLinkColorForBindings(const String&amp; value)
7951 {
7952     if (auto* bodyElement = body())
7953         bodyElement-&gt;setAttributeWithoutSynchronization(linkAttr, value);
7954 }
7955 
7956 const AtomString&amp; Document::vlinkColor() const
7957 {
7958     auto* bodyElement = body();
7959     if (!bodyElement)
7960         return emptyAtom();
7961     return bodyElement-&gt;attributeWithoutSynchronization(vlinkAttr);
7962 }
7963 
7964 void Document::setVlinkColor(const String&amp; value)
7965 {
7966     if (auto* bodyElement = body())
7967         bodyElement-&gt;setAttributeWithoutSynchronization(vlinkAttr, value);
7968 }
7969 
7970 Logger&amp; Document::logger()
7971 {
7972     if (!m_logger) {
7973         m_logger = Logger::create(this);
7974         auto* page = this-&gt;page();
7975         m_logger-&gt;setEnabled(this, page &amp;&amp; page-&gt;sessionID().isAlwaysOnLoggingAllowed());
7976         m_logger-&gt;addObserver(*this);
7977     }
7978 
7979     return *m_logger;
7980 }
7981 
7982 Optional&lt;PageIdentifier&gt; Document::pageID() const
7983 {
7984     return m_frame-&gt;loader().client().pageID();
7985 }
7986 
7987 void Document::registerArticleElement(Element&amp; article)
7988 {
7989     m_articleElements.add(&amp;article);
7990 }
7991 
7992 void Document::unregisterArticleElement(Element&amp; article)
7993 {
7994     m_articleElements.remove(&amp;article);
7995     if (m_mainArticleElement == &amp;article)
7996         m_mainArticleElement = nullptr;
7997 }
7998 
7999 void Document::updateMainArticleElementAfterLayout()
8000 {
8001     ASSERT(page() &amp;&amp; page()-&gt;requestedLayoutMilestones().contains(DidRenderSignificantAmountOfText));
8002 
8003     // If there are too many article elements on the page, don&#39;t consider any one of them to be &quot;main content&quot;.
8004     const unsigned maxNumberOfArticlesBeforeIgnoringMainContentArticle = 10;
8005 
8006     // We consider an article to be main content if it is either:
8007     // 1. The only article element in the document.
8008     // 2. Much taller than the next tallest article, and also much larger than the viewport.
8009     const float minimumSecondTallestArticleHeightFactor = 4;
8010     const float minimumViewportAreaFactor = 5;
8011 
8012     m_mainArticleElement = nullptr;
8013 
8014     auto numberOfArticles = m_articleElements.size();
8015     if (!numberOfArticles || numberOfArticles &gt; maxNumberOfArticlesBeforeIgnoringMainContentArticle)
8016         return;
8017 
8018     Element* tallestArticle = nullptr;
8019     float tallestArticleHeight = 0;
8020     float tallestArticleWidth = 0;
8021     float secondTallestArticleHeight = 0;
8022 
8023     for (auto* article : m_articleElements) {
8024         auto* box = article-&gt;renderBox();
8025         float height = box ? box-&gt;height().toFloat() : 0;
8026         if (height &gt;= tallestArticleHeight) {
8027             secondTallestArticleHeight = tallestArticleHeight;
8028             tallestArticleHeight = height;
8029             tallestArticleWidth = box ? box-&gt;width().toFloat() : 0;
8030             tallestArticle = article;
8031         } else if (height &gt;= secondTallestArticleHeight)
8032             secondTallestArticleHeight = height;
8033     }
8034 
8035     if (numberOfArticles == 1) {
8036         m_mainArticleElement = tallestArticle;
8037         return;
8038     }
8039 
8040     if (tallestArticleHeight &lt; minimumSecondTallestArticleHeightFactor * secondTallestArticleHeight)
8041         return;
8042 
8043     if (!view())
8044         return;
8045 
8046     auto viewportSize = view()-&gt;layoutViewportRect().size();
8047     if (tallestArticleWidth * tallestArticleHeight &lt; minimumViewportAreaFactor * (viewportSize.width() * viewportSize.height()).toFloat())
8048         return;
8049 
8050     m_mainArticleElement = tallestArticle;
8051 }
8052 
8053 #if ENABLE(RESOURCE_LOAD_STATISTICS)
8054 bool Document::hasRequestedPageSpecificStorageAccessWithUserInteraction(const RegistrableDomain&amp; domain)
8055 {
8056     return m_registrableDomainRequestedPageSpecificStorageAccessWithUserInteraction == domain;
8057 }
8058 
8059 void Document::setHasRequestedPageSpecificStorageAccessWithUserInteraction(const RegistrableDomain&amp; domain)
8060 {
8061     m_registrableDomainRequestedPageSpecificStorageAccessWithUserInteraction = domain;
8062 }
8063 
8064 void Document::wasLoadedWithDataTransferFromPrevalentResource()
8065 {
8066     downgradeReferrerToRegistrableDomain();
8067 }
8068 
8069 void Document::downgradeReferrerToRegistrableDomain()
8070 {
8071     auto referrerStr = referrer();
8072     if (referrerStr.isEmpty())
8073         return;
8074 
8075     URL referrerURL { URL(), referrerStr };
8076     auto referrerPort = referrerURL.port();
8077     RegistrableDomain referrerRegistrableDomain { referrerURL };
8078     auto referrerRegistrableDomainStr = referrerRegistrableDomain.string();
8079     if (referrerRegistrableDomainStr.isEmpty())
8080         return;
8081 
8082     StringBuilder builder;
8083     builder.append(referrerURL.protocol());
8084     builder.appendLiteral(&quot;://&quot;);
8085     builder.append(referrerRegistrableDomainStr);
8086     if (referrerPort) {
8087         builder.append(&#39;:&#39;);
8088         builder.appendNumber(*referrerPort);
8089     }
8090     builder.append(&#39;/&#39;);
8091 
8092     m_referrerOverride = builder.toString();
8093 }
8094 #endif
8095 
8096 void Document::setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp; listener)
8097 {
8098     m_consoleMessageListener = listener;
8099 }
8100 
8101 void Document::addTimeline(DocumentTimeline&amp; timeline)
8102 {
8103     m_timelines.add(timeline);
8104 }
8105 
8106 void Document::removeTimeline(DocumentTimeline&amp; timeline)
8107 {
8108     m_timelines.remove(timeline);
8109 }
8110 
8111 DocumentTimeline&amp; Document::timeline()
8112 {
8113     if (!m_timeline)
8114         m_timeline = DocumentTimeline::create(*this);
8115 
8116     return *m_timeline;
8117 }
8118 
8119 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; Document::getAnimations()
8120 {
8121     // For the list of animations to be current, we need to account for any pending CSS changes,
8122     // such as updates to CSS Animations and CSS Transitions.
8123     updateStyleIfNeeded();
8124 
8125     if (m_timeline)
8126         return m_timeline-&gt;getAnimations();
8127     return { };
8128 }
8129 
8130 #if ENABLE(ATTACHMENT_ELEMENT)
8131 
8132 void Document::registerAttachmentIdentifier(const String&amp; identifier)
8133 {
8134     if (auto* frame = this-&gt;frame())
8135         frame-&gt;editor().registerAttachmentIdentifier(identifier);
8136 }
8137 
8138 void Document::didInsertAttachmentElement(HTMLAttachmentElement&amp; attachment)
8139 {
8140     auto identifier = attachment.uniqueIdentifier();
8141     auto previousIdentifier = identifier;
8142     bool previousIdentifierIsNotUnique = !previousIdentifier.isEmpty() &amp;&amp; m_attachmentIdentifierToElementMap.contains(previousIdentifier);
8143     if (identifier.isEmpty() || previousIdentifierIsNotUnique) {
8144         previousIdentifier = identifier;
8145         identifier = createCanonicalUUIDString();
8146         attachment.setUniqueIdentifier(identifier);
8147     }
8148 
8149     m_attachmentIdentifierToElementMap.set(identifier, attachment);
8150 
8151     if (auto* frame = this-&gt;frame()) {
8152         if (previousIdentifierIsNotUnique)
8153             frame-&gt;editor().cloneAttachmentData(previousIdentifier, identifier);
8154         frame-&gt;editor().didInsertAttachmentElement(attachment);
8155     }
8156 }
8157 
8158 void Document::didRemoveAttachmentElement(HTMLAttachmentElement&amp; attachment)
8159 {
8160     auto identifier = attachment.uniqueIdentifier();
8161     if (!identifier)
8162         return;
8163 
8164     m_attachmentIdentifierToElementMap.remove(identifier);
8165 
8166     if (frame())
8167         frame()-&gt;editor().didRemoveAttachmentElement(attachment);
8168 }
8169 
8170 RefPtr&lt;HTMLAttachmentElement&gt; Document::attachmentForIdentifier(const String&amp; identifier) const
8171 {
8172     return m_attachmentIdentifierToElementMap.get(identifier);
8173 }
8174 
8175 #endif // ENABLE(ATTACHMENT_ELEMENT)
8176 
8177 static MessageSource messageSourceForWTFLogChannel(const WTFLogChannel&amp; channel)
8178 {
8179     static const NeverDestroyed&lt;String&gt; mediaChannel = MAKE_STATIC_STRING_IMPL(&quot;media&quot;);
8180     static const NeverDestroyed&lt;String&gt; webrtcChannel = MAKE_STATIC_STRING_IMPL(&quot;webrtc&quot;);
8181     static const NeverDestroyed&lt;String&gt; mediaSourceChannel = MAKE_STATIC_STRING_IMPL(&quot;mediasource&quot;);
8182 
8183     if (equalIgnoringASCIICase(mediaChannel, channel.name))
8184         return MessageSource::Media;
8185 
8186     if (equalIgnoringASCIICase(webrtcChannel, channel.name))
8187         return MessageSource::WebRTC;
8188 
8189     if (equalIgnoringASCIICase(mediaSourceChannel, channel.name))
8190         return MessageSource::MediaSource;
8191 
8192     return MessageSource::Other;
8193 }
8194 
8195 static MessageLevel messageLevelFromWTFLogLevel(WTFLogLevel level)
8196 {
8197     switch (level) {
8198     case WTFLogLevel::Always:
8199         return MessageLevel::Log;
8200     case WTFLogLevel::Error:
8201         return MessageLevel::Error;
8202         break;
8203     case WTFLogLevel::Warning:
8204         return MessageLevel::Warning;
8205         break;
8206     case WTFLogLevel::Info:
8207         return MessageLevel::Info;
8208         break;
8209     case WTFLogLevel::Debug:
8210         return MessageLevel::Debug;
8211         break;
8212     }
8213 
8214     ASSERT_NOT_REACHED();
8215     return MessageLevel::Log;
8216 }
8217 
8218 static inline Vector&lt;JSONLogValue&gt; crossThreadCopy(Vector&lt;JSONLogValue&gt;&amp;&amp; source)
8219 {
8220     auto values = WTFMove(source);
8221     for (auto&amp; value : values)
8222         value.value = crossThreadCopy(WTFMove(value.value));
8223     return values;
8224 }
8225 
8226 void Document::didLogMessage(const WTFLogChannel&amp; channel, WTFLogLevel level, Vector&lt;JSONLogValue&gt;&amp;&amp; logMessages)
8227 {
8228     if (!isMainThread()) {
8229         postTask([this, channel, level, logMessages = crossThreadCopy(WTFMove(logMessages))](auto&amp;) mutable {
8230             didLogMessage(channel, level, WTFMove(logMessages));
8231         });
8232         return;
8233     }
8234     auto* page = this-&gt;page();
8235     if (!page)
8236         return;
8237 
8238     ASSERT(page-&gt;sessionID().isAlwaysOnLoggingAllowed());
8239 
8240     auto messageSource = messageSourceForWTFLogChannel(channel);
8241     if (messageSource == MessageSource::Other)
8242         return;
8243 
8244     m_logMessageTaskQueue.enqueueTask([this, level, messageSource, logMessages = WTFMove(logMessages)]() mutable {
8245         if (!this-&gt;page())
8246             return;
8247 
8248         auto messageLevel = messageLevelFromWTFLogLevel(level);
8249         auto message = makeUnique&lt;Inspector::ConsoleMessage&gt;(messageSource, MessageType::Log, messageLevel, WTFMove(logMessages), mainWorldExecState(frame()));
8250 
8251         addConsoleMessage(WTFMove(message));
8252     });
8253 }
8254 
8255 #if ENABLE(SERVICE_WORKER)
8256 void Document::setServiceWorkerConnection(SWClientConnection* serviceWorkerConnection)
8257 {
8258     if (m_serviceWorkerConnection == serviceWorkerConnection || m_hasPreparedForDestruction || m_isSuspended)
8259         return;
8260 
8261     if (m_serviceWorkerConnection)
8262         m_serviceWorkerConnection-&gt;unregisterServiceWorkerClient(identifier());
8263 
8264     m_serviceWorkerConnection = serviceWorkerConnection;
8265 
8266     if (!m_serviceWorkerConnection)
8267         return;
8268 
8269     auto controllingServiceWorkerRegistrationIdentifier = activeServiceWorker() ? makeOptional&lt;ServiceWorkerRegistrationIdentifier&gt;(activeServiceWorker()-&gt;registrationIdentifier()) : WTF::nullopt;
8270     m_serviceWorkerConnection-&gt;registerServiceWorkerClient(topOrigin(), ServiceWorkerClientData::from(*this, *serviceWorkerConnection), controllingServiceWorkerRegistrationIdentifier, userAgent(url()));
8271 }
8272 #endif
8273 
8274 String Document::signedPublicKeyAndChallengeString(unsigned keySizeIndex, const String&amp; challengeString, const URL&amp; url)
8275 {
8276     Page* page = this-&gt;page();
8277     if (!page)
8278         return emptyString();
8279     return page-&gt;chrome().client().signedPublicKeyAndChallengeString(keySizeIndex, challengeString, url);
8280 }
8281 
8282 bool Document::registerCSSProperty(CSSRegisteredCustomProperty&amp;&amp; prop)
8283 {
8284     return m_CSSRegisteredPropertySet.add(prop.name, makeUnique&lt;CSSRegisteredCustomProperty&gt;(WTFMove(prop))).isNewEntry;
8285 }
8286 
8287 void Document::detachFromFrame()
8288 {
8289     // Assertion to help pinpint rdar://problem/49877867. If this hits, the crash trace should tell us
8290     // which piece of code is detaching the document from its frame while constructing the CachedFrames.
8291     RELEASE_ASSERT(m_mayBeDetachedFromFrame);
8292 
8293     observeFrame(nullptr);
8294 }
8295 
8296 void Document::frameWasDisconnectedFromOwner()
8297 {
8298     if (!frame())
8299         return;
8300 
8301     if (auto* window = domWindow())
8302         window-&gt;willDetachDocumentFromFrame();
8303 
8304     detachFromFrame();
8305 }
8306 
8307 bool Document::hitTest(const HitTestRequest&amp; request, HitTestResult&amp; result)
8308 {
8309     return hitTest(request, result.hitTestLocation(), result);
8310 }
8311 
8312 bool Document::hitTest(const HitTestRequest&amp; request, const HitTestLocation&amp; location, HitTestResult&amp; result)
8313 {
8314     Ref&lt;Document&gt; protectedThis(*this);
8315     updateLayout();
8316     if (!renderView())
8317         return false;
8318 
8319 #if ASSERT_ENABLED
8320     SetForScope&lt;bool&gt; hitTestRestorer { m_inHitTesting, true };
8321 #endif
8322 
8323     auto&amp; frameView = renderView()-&gt;frameView();
8324     Ref&lt;FrameView&gt; protector(frameView);
8325 
8326     FrameFlatteningLayoutDisallower disallower(frameView);
8327 
8328     bool resultLayer = renderView()-&gt;layer()-&gt;hitTest(request, location, result);
8329 
8330     // ScrollView scrollbars are not the same as RenderLayer scrollbars tested by RenderLayer::hitTestOverflowControls,
8331     // so we need to test ScrollView scrollbars separately here. In case of using overlay scrollbars, the layer hit test
8332     // will always work so we need to check the ScrollView scrollbars in that case too.
8333     if (!resultLayer || ScrollbarTheme::theme().usesOverlayScrollbars()) {
8334         // FIXME: Consider if this test should be done unconditionally.
8335         if (request.allowsFrameScrollbars()) {
8336             IntPoint windowPoint = frameView.contentsToWindow(location.roundedPoint());
8337             if (auto* frameScrollbar = frameView.scrollbarAtPoint(windowPoint)) {
8338                 result.setScrollbar(frameScrollbar);
8339                 return true;
8340             }
8341         }
8342     }
8343     return resultLayer;
8344 }
8345 
8346 ElementIdentifier Document::identifierForElement(Element&amp; element)
8347 {
8348     ASSERT(&amp;element.document() == this);
8349     auto result = m_identifiedElementsMap.ensure(&amp;element, [&amp;] {
8350         return element.createElementIdentifier();
8351     });
8352     return result.iterator-&gt;value;
8353 }
8354 
8355 Element* Document::searchForElementByIdentifier(const ElementIdentifier&amp; identifier)
8356 {
8357     for (auto it = m_identifiedElementsMap.begin(); it != m_identifiedElementsMap.end(); ++it) {
8358         if (it-&gt;value == identifier)
8359             return it-&gt;key;
8360     }
8361 
8362     return nullptr;
8363 }
8364 
8365 void Document::identifiedElementWasRemovedFromDocument(Element&amp; element)
8366 {
8367     m_identifiedElementsMap.remove(&amp;element);
8368 }
8369 
8370 #if ENABLE(DEVICE_ORIENTATION)
8371 
8372 DeviceOrientationAndMotionAccessController&amp; Document::deviceOrientationAndMotionAccessController()
8373 {
8374     if (&amp;topDocument() != this)
8375         return topDocument().deviceOrientationAndMotionAccessController();
8376 
8377     if (!m_deviceOrientationAndMotionAccessController)
8378         m_deviceOrientationAndMotionAccessController = makeUnique&lt;DeviceOrientationAndMotionAccessController&gt;(*this);
8379     return *m_deviceOrientationAndMotionAccessController;
8380 }
8381 
8382 #endif
8383 
8384 #if ENABLE(CSS_PAINTING_API)
8385 Worklet&amp; Document::ensurePaintWorklet()
8386 {
8387     if (!m_paintWorklet)
8388         m_paintWorklet = Worklet::create();
8389     return *m_paintWorklet;
8390 }
8391 
8392 PaintWorkletGlobalScope* Document::paintWorkletGlobalScopeForName(const String&amp; name)
8393 {
8394     return m_paintWorkletGlobalScopes.get(name);
8395 }
8396 
8397 void Document::setPaintWorkletGlobalScopeForName(const String&amp; name, Ref&lt;PaintWorkletGlobalScope&gt;&amp;&amp; scope)
8398 {
8399     auto addResult = m_paintWorkletGlobalScopes.add(name, WTFMove(scope));
8400     ASSERT_UNUSED(addResult, addResult);
8401 }
8402 #endif
8403 
8404 #if PLATFORM(IOS_FAMILY)
8405 
8406 ContentChangeObserver&amp; Document::contentChangeObserver()
8407 {
8408     if (!m_contentChangeObserver)
8409         m_contentChangeObserver = makeUnique&lt;ContentChangeObserver&gt;(*this);
8410     return *m_contentChangeObserver;
8411 }
8412 
8413 DOMTimerHoldingTank&amp; Document::domTimerHoldingTank()
8414 {
8415     if (m_domTimerHoldingTank)
8416         return *m_domTimerHoldingTank;
8417     m_domTimerHoldingTank = makeUnique&lt;DOMTimerHoldingTank&gt;();
8418     return *m_domTimerHoldingTank;
8419 }
8420 
8421 #endif
8422 
8423 bool Document::hasEvaluatedUserAgentScripts() const
8424 {
8425     auto&amp; top = topDocument();
8426     return this == &amp;top ? m_hasEvaluatedUserAgentScripts : top.hasEvaluatedUserAgentScripts();
8427 }
8428 
8429 bool Document::isRunningUserScripts() const
8430 {
8431     auto&amp; top = topDocument();
8432     return this == &amp;top ? m_isRunningUserScripts : top.isRunningUserScripts();
8433 }
8434 
8435 void Document::setAsRunningUserScripts()
8436 {
8437     auto&amp; top = topDocument();
8438     if (this == &amp;top)
8439         m_isRunningUserScripts = true;
8440     else
8441         top.setAsRunningUserScripts();
8442 }
8443 
8444 void Document::setHasEvaluatedUserAgentScripts()
8445 {
8446     auto&amp; top = topDocument();
8447     if (this == &amp;top)
8448         m_hasEvaluatedUserAgentScripts = true;
8449     else
8450         top.setHasEvaluatedUserAgentScripts();
8451 }
8452 
8453 void Document::didRejectSyncXHRDuringPageDismissal()
8454 {
8455     ++m_numberOfRejectedSyncXHRs;
8456     if (m_numberOfRejectedSyncXHRs &gt; 1)
8457         return;
8458 
8459     postTask([this, weakThis = makeWeakPtr(*this)](auto&amp;) mutable {
8460         if (weakThis)
8461             m_numberOfRejectedSyncXHRs = 0;
8462     });
8463 }
8464 
8465 bool Document::shouldIgnoreSyncXHRs() const
8466 {
8467     const unsigned maxRejectedSyncXHRsPerEventLoopIteration = 5;
8468     return m_numberOfRejectedSyncXHRs &gt; maxRejectedSyncXHRsPerEventLoopIteration;
8469 }
8470 
8471 #if ENABLE(APPLE_PAY)
8472 
8473 bool Document::isApplePayActive() const
8474 {
8475     auto&amp; top = topDocument();
8476     return this == &amp;top ? m_hasStartedApplePaySession : top.isApplePayActive();
8477 }
8478 
8479 void Document::setApplePayIsActive()
8480 {
8481     auto&amp; top = topDocument();
8482     if (this == &amp;top)
8483         m_hasStartedApplePaySession = true;
8484     else
8485         top.setApplePayIsActive();
8486 }
8487 
8488 #endif
8489 
8490 MessagePortChannelProvider&amp; Document::messagePortChannelProvider()
8491 {
8492     return MessagePortChannelProvider::singleton();
8493 }
8494 
8495 #if USE(SYSTEM_PREVIEW)
8496 void Document::dispatchSystemPreviewActionEvent(const SystemPreviewInfo&amp; systemPreviewInfo, const String&amp; message)
8497 {
8498     auto* element = searchForElementByIdentifier(systemPreviewInfo.element.elementIdentifier);
8499     if (!element)
8500         return;
8501 
8502     if (!is&lt;HTMLAnchorElement&gt;(element))
8503         return;
8504 
8505     auto event = MessageEvent::create(message, securityOrigin().toString());
8506     UserGestureIndicator gestureIndicator(ProcessingUserGesture, this);
8507     element-&gt;dispatchEvent(event);
8508 }
8509 #endif
8510 
8511 #if ENABLE(PICTURE_IN_PICTURE_API)
8512 HTMLVideoElement* Document::pictureInPictureElement() const
8513 {
8514     return m_pictureInPictureElement.get();
8515 };
8516 
8517 void Document::setPictureInPictureElement(HTMLVideoElement* element)
8518 {
8519     m_pictureInPictureElement = makeWeakPtr(element);
8520 }
8521 #endif
8522 
8523 TextManipulationController&amp; Document::textManipulationController()
8524 {
8525     if (!m_textManipulationController)
8526         m_textManipulationController = makeUnique&lt;TextManipulationController&gt;(*this);
8527     return *m_textManipulationController;
8528 }
8529 
8530 } // namespace WebCore
    </pre>
  </body>
</html>