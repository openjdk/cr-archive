<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/css/StyleProperties.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * (C) 1999-2003 Lars Knoll (knoll@kde.org)
   3  * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012, 2013 Apple Inc. All rights reserved.
   4  * Copyright (C) 2011 Research In Motion Limited. All rights reserved.
   5  * Copyright (C) 2013 Intel Corporation. All rights reserved.
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public License
  18  * along with this library; see the file COPYING.LIB.  If not, write to
  19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;StyleProperties.h&quot;
  25 
  26 #include &quot;CSSComputedStyleDeclaration.h&quot;
  27 #include &quot;CSSCustomPropertyValue.h&quot;
  28 #include &quot;CSSDeferredParser.h&quot;
  29 #include &quot;CSSParser.h&quot;
  30 #include &quot;CSSPendingSubstitutionValue.h&quot;
  31 #include &quot;CSSPropertyParser.h&quot;
  32 #include &quot;CSSTokenizer.h&quot;
  33 #include &quot;CSSValueKeywords.h&quot;
  34 #include &quot;CSSValueList.h&quot;
  35 #include &quot;CSSValuePool.h&quot;
  36 #include &quot;Color.h&quot;
  37 #include &quot;Document.h&quot;
  38 #include &quot;PropertySetCSSStyleDeclaration.h&quot;
  39 #include &quot;StylePropertyShorthand.h&quot;
  40 #include &quot;StylePropertyShorthandFunctions.h&quot;
  41 #include &quot;StyleSheetContents.h&quot;
  42 #include &lt;bitset&gt;
  43 #include &lt;wtf/text/StringBuilder.h&gt;
  44 
  45 #ifndef NDEBUG
  46 #include &lt;stdio.h&gt;
  47 #include &lt;wtf/text/CString.h&gt;
  48 #endif
  49 
  50 namespace WebCore {
  51 
  52 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StyleProperties);
  53 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ImmutableStyleProperties);
  54 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(MutableStyleProperties);
  55 
  56 static size_t sizeForImmutableStylePropertiesWithPropertyCount(unsigned count)
  57 {
  58     return sizeof(ImmutableStyleProperties) - sizeof(void*) + sizeof(StylePropertyMetadata) * count + sizeof(PackedPtr&lt;const CSSValue&gt;) * count;
  59 }
  60 
  61 static bool isInitialOrInherit(const String&amp; value)
  62 {
  63     return value.length() == 7 &amp;&amp; (value == &quot;initial&quot; || value == &quot;inherit&quot;);
  64 }
  65 
  66 Ref&lt;ImmutableStyleProperties&gt; ImmutableStyleProperties::create(const CSSProperty* properties, unsigned count, CSSParserMode cssParserMode)
  67 {
  68     void* slot = ImmutableStylePropertiesMalloc::malloc(sizeForImmutableStylePropertiesWithPropertyCount(count));
  69     return adoptRef(*new (NotNull, slot) ImmutableStyleProperties(properties, count, cssParserMode));
  70 }
  71 
  72 Ref&lt;ImmutableStyleProperties&gt; StyleProperties::immutableCopyIfNeeded() const
  73 {
  74     if (is&lt;ImmutableStyleProperties&gt;(*this))
  75         return downcast&lt;ImmutableStyleProperties&gt;(const_cast&lt;StyleProperties&amp;&gt;(*this));
  76     const MutableStyleProperties&amp; mutableThis = downcast&lt;MutableStyleProperties&gt;(*this);
  77     return ImmutableStyleProperties::create(mutableThis.m_propertyVector.data(), mutableThis.m_propertyVector.size(), cssParserMode());
  78 }
  79 
  80 MutableStyleProperties::MutableStyleProperties(CSSParserMode cssParserMode)
  81     : StyleProperties(cssParserMode, MutablePropertiesType)
  82 {
  83 }
  84 
  85 MutableStyleProperties::MutableStyleProperties(Vector&lt;CSSProperty&gt;&amp;&amp; properties)
  86     : StyleProperties(HTMLStandardMode, MutablePropertiesType)
  87     , m_propertyVector(WTFMove(properties))
  88 {
  89 }
  90 
  91 MutableStyleProperties::~MutableStyleProperties() = default;
  92 
  93 ImmutableStyleProperties::ImmutableStyleProperties(const CSSProperty* properties, unsigned length, CSSParserMode cssParserMode)
  94     : StyleProperties(cssParserMode, length)
  95 {
  96     StylePropertyMetadata* metadataArray = const_cast&lt;StylePropertyMetadata*&gt;(this-&gt;metadataArray());
  97     PackedPtr&lt;CSSValue&gt;* valueArray = bitwise_cast&lt;PackedPtr&lt;CSSValue&gt;*&gt;(this-&gt;valueArray());
  98     for (unsigned i = 0; i &lt; length; ++i) {
  99         metadataArray[i] = properties[i].metadata();
 100         auto* value = properties[i].value();
 101         valueArray[i] = value;
 102         value-&gt;ref();
 103     }
 104 }
 105 
 106 ImmutableStyleProperties::~ImmutableStyleProperties()
 107 {
 108     PackedPtr&lt;CSSValue&gt;* valueArray = bitwise_cast&lt;PackedPtr&lt;CSSValue&gt;*&gt;(this-&gt;valueArray());
 109     for (unsigned i = 0; i &lt; m_arraySize; ++i)
 110         valueArray[i]-&gt;deref();
 111 }
 112 
 113 MutableStyleProperties::MutableStyleProperties(const StyleProperties&amp; other)
 114     : StyleProperties(other.cssParserMode(), MutablePropertiesType)
 115 {
 116     ASSERT(other.type() != DeferredPropertiesType);
 117     if (is&lt;MutableStyleProperties&gt;(other))
 118         m_propertyVector = downcast&lt;MutableStyleProperties&gt;(other).m_propertyVector;
 119     else {
 120         const auto&amp; immutableOther = downcast&lt;ImmutableStyleProperties&gt;(other);
 121         unsigned propertyCount = immutableOther.propertyCount();
 122         m_propertyVector.reserveInitialCapacity(propertyCount);
 123         for (unsigned i = 0; i &lt; propertyCount; ++i)
 124             m_propertyVector.uncheckedAppend(immutableOther.propertyAt(i).toCSSProperty());
 125     }
 126 }
 127 
 128 String StyleProperties::getPropertyValue(CSSPropertyID propertyID) const
 129 {
 130     RefPtr&lt;CSSValue&gt; value = getPropertyCSSValue(propertyID);
 131     if (value) {
 132         switch (propertyID) {
 133         case CSSPropertyFillOpacity:
 134         case CSSPropertyFloodOpacity:
 135         case CSSPropertyOpacity:
 136         case CSSPropertyStopOpacity:
 137         case CSSPropertyStrokeOpacity:
 138             // Opacity values always serializes as a number.
 139             if (value-&gt;isPrimitiveValue() &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value.get())-&gt;isPercentage()) {
 140                 auto doubleValue = downcast&lt;CSSPrimitiveValue&gt;(value.get())-&gt;doubleValue();
 141                 return makeString(doubleValue / 100.0);
 142             }
 143             FALLTHROUGH;
 144         default:
 145             return value-&gt;cssText();
 146         }
 147     }
 148 
 149     const StylePropertyShorthand&amp; shorthand = shorthandForProperty(propertyID);
 150     if (shorthand.length()) {
 151         RefPtr&lt;CSSValue&gt; value = getPropertyCSSValueInternal(shorthand.properties()[0]);
 152         if (!value || value-&gt;isPendingSubstitutionValue())
 153             return String();
 154     // FIXME: If all longhands are the same css-generic keyword(e.g. initial or inherit),
 155     // then the shorthand should be serialized to that keyword.
 156     // It seems to be needed to handle this in a single function commonly for all the shorthands,
 157     // not in each of the shorthand serialization function.
 158     // We could call that function here.
 159     }
 160 
 161     // Shorthand and 4-values properties
 162     switch (propertyID) {
 163     case CSSPropertyAll:
 164         return getCommonValue(allShorthand());
 165     case CSSPropertyAnimation:
 166         return getLayeredShorthandValue(animationShorthand());
 167     case CSSPropertyBorderSpacing:
 168         return borderSpacingValue(borderSpacingShorthand());
 169     case CSSPropertyBackgroundPosition:
 170         return getLayeredShorthandValue(backgroundPositionShorthand());
 171     case CSSPropertyBackgroundRepeat:
 172         return getLayeredShorthandValue(backgroundRepeatShorthand());
 173     case CSSPropertyBackground:
 174         return getLayeredShorthandValue(backgroundShorthand());
 175     case CSSPropertyBorder:
 176         return borderPropertyValue(borderWidthShorthand(), borderStyleShorthand(), borderColorShorthand());
 177     case CSSPropertyBorderTop:
 178         return getShorthandValue(borderTopShorthand());
 179     case CSSPropertyBorderRight:
 180         return getShorthandValue(borderRightShorthand());
 181     case CSSPropertyBorderBottom:
 182         return getShorthandValue(borderBottomShorthand());
 183     case CSSPropertyBorderLeft:
 184         return getShorthandValue(borderLeftShorthand());
 185     case CSSPropertyBorderBlock:
 186         return borderPropertyValue(borderBlockWidthShorthand(), borderBlockStyleShorthand(), borderBlockColorShorthand());
 187     case CSSPropertyBorderBlockColor:
 188         return get2Values(borderBlockColorShorthand());
 189     case CSSPropertyBorderBlockStyle:
 190         return get2Values(borderBlockStyleShorthand());
 191     case CSSPropertyBorderBlockWidth:
 192         return get2Values(borderBlockWidthShorthand());
 193     case CSSPropertyBorderBlockStart:
 194         return getShorthandValue(borderBlockStartShorthand());
 195     case CSSPropertyBorderBlockEnd:
 196         return getShorthandValue(borderBlockEndShorthand());
 197     case CSSPropertyBorderInline:
 198         return borderPropertyValue(borderInlineWidthShorthand(), borderInlineStyleShorthand(), borderInlineColorShorthand());
 199     case CSSPropertyBorderInlineColor:
 200         return get2Values(borderInlineColorShorthand());
 201     case CSSPropertyBorderInlineStyle:
 202         return get2Values(borderInlineStyleShorthand());
 203     case CSSPropertyBorderInlineWidth:
 204         return get2Values(borderInlineWidthShorthand());
 205     case CSSPropertyBorderInlineStart:
 206         return getShorthandValue(borderInlineStartShorthand());
 207     case CSSPropertyBorderInlineEnd:
 208         return getShorthandValue(borderInlineEndShorthand());
 209     case CSSPropertyOutline:
 210         return getShorthandValue(outlineShorthand());
 211     case CSSPropertyBorderColor:
 212         return get4Values(borderColorShorthand());
 213     case CSSPropertyBorderWidth:
 214         return get4Values(borderWidthShorthand());
 215     case CSSPropertyBorderStyle:
 216         return get4Values(borderStyleShorthand());
 217     case CSSPropertyColumnRule:
 218         return getShorthandValue(columnRuleShorthand());
 219     case CSSPropertyColumns:
 220         return getShorthandValue(columnsShorthand());
 221     case CSSPropertyFlex:
 222         return getShorthandValue(flexShorthand());
 223     case CSSPropertyFlexFlow:
 224         return getShorthandValue(flexFlowShorthand());
 225     case CSSPropertyGridArea:
 226         return getGridShorthandValue(gridAreaShorthand());
 227     case CSSPropertyGridTemplate:
 228         return getGridShorthandValue(gridTemplateShorthand());
 229     case CSSPropertyGrid:
 230         return getGridShorthandValue(gridShorthand());
 231     case CSSPropertyGridColumn:
 232         return getGridShorthandValue(gridColumnShorthand());
 233     case CSSPropertyGridRow:
 234         return getGridShorthandValue(gridRowShorthand());
 235     case CSSPropertyPageBreakAfter:
 236         return pageBreakPropertyValue(pageBreakAfterShorthand());
 237     case CSSPropertyPageBreakBefore:
 238         return pageBreakPropertyValue(pageBreakBeforeShorthand());
 239     case CSSPropertyPageBreakInside:
 240         return pageBreakPropertyValue(pageBreakInsideShorthand());
 241     case CSSPropertyPlaceContent:
 242         return getAlignmentShorthandValue(placeContentShorthand());
 243     case CSSPropertyPlaceItems:
 244         return getAlignmentShorthandValue(placeItemsShorthand());
 245     case CSSPropertyPlaceSelf:
 246         return getAlignmentShorthandValue(placeSelfShorthand());
 247     case CSSPropertyFont:
 248         return fontValue();
 249     case CSSPropertyInset:
 250         return get4Values(insetShorthand());
 251     case CSSPropertyInsetBlock:
 252         return get2Values(insetBlockShorthand());
 253     case CSSPropertyInsetInline:
 254         return get2Values(insetInlineShorthand());
 255     case CSSPropertyMargin:
 256         return get4Values(marginShorthand());
 257     case CSSPropertyMarginBlock:
 258         return get2Values(marginBlockShorthand());
 259     case CSSPropertyMarginInline:
 260         return get2Values(marginInlineShorthand());
 261     case CSSPropertyWebkitMarginCollapse:
 262         return getShorthandValue(webkitMarginCollapseShorthand());
 263     case CSSPropertyOverflow:
 264         return get2Values(overflowShorthand());
 265     case CSSPropertyPadding:
 266         return get4Values(paddingShorthand());
 267     case CSSPropertyPaddingBlock:
 268         return get2Values(paddingBlockShorthand());
 269     case CSSPropertyPaddingInline:
 270         return get2Values(paddingInlineShorthand());
 271     case CSSPropertyTransition:
 272         return getLayeredShorthandValue(transitionShorthand());
 273     case CSSPropertyListStyle:
 274         return getShorthandValue(listStyleShorthand());
 275     case CSSPropertyWebkitMaskPosition:
 276         return getLayeredShorthandValue(webkitMaskPositionShorthand());
 277     case CSSPropertyWebkitMaskRepeat:
 278         return getLayeredShorthandValue(webkitMaskRepeatShorthand());
 279     case CSSPropertyWebkitMask:
 280         return getLayeredShorthandValue(webkitMaskShorthand());
 281     case CSSPropertyWebkitTextEmphasis:
 282         return getShorthandValue(webkitTextEmphasisShorthand());
 283     case CSSPropertyWebkitTextStroke:
 284         return getShorthandValue(webkitTextStrokeShorthand());
 285     case CSSPropertyPerspectiveOrigin:
 286         return getShorthandValue(perspectiveOriginShorthand());
 287     case CSSPropertyTransformOrigin:
 288         return getShorthandValue(transformOriginShorthand());
 289     case CSSPropertyMarker: {
 290         RefPtr&lt;CSSValue&gt; value = getPropertyCSSValueInternal(CSSPropertyMarkerStart);
 291         if (value)
 292             return value-&gt;cssText();
 293         return String();
 294     }
 295     case CSSPropertyBorderRadius:
 296         return get4Values(borderRadiusShorthand());
 297 #if ENABLE(CSS_SCROLL_SNAP)
 298     case CSSPropertyScrollSnapMargin:
 299         return get4Values(scrollSnapMarginShorthand());
 300     case CSSPropertyScrollPadding:
 301         return get4Values(scrollPaddingShorthand());
 302 #endif
 303     default:
 304         return String();
 305     }
 306 }
 307 
 308 Optional&lt;Color&gt; StyleProperties::propertyAsColor(CSSPropertyID property) const
 309 {
 310     auto colorValue = getPropertyCSSValue(property);
 311     if (!is&lt;CSSPrimitiveValue&gt;(colorValue))
 312         return WTF::nullopt;
 313 
 314     auto&amp; primitiveColor = downcast&lt;CSSPrimitiveValue&gt;(*colorValue);
 315     return primitiveColor.isRGBColor() ? primitiveColor.color() : CSSParser::parseColor(colorValue-&gt;cssText());
 316 }
 317 
 318 CSSValueID StyleProperties::propertyAsValueID(CSSPropertyID property) const
 319 {
 320     auto cssValue = getPropertyCSSValue(property);
 321     return is&lt;CSSPrimitiveValue&gt;(cssValue) ? downcast&lt;CSSPrimitiveValue&gt;(*cssValue).valueID() : CSSValueInvalid;
 322 }
 323 
 324 String StyleProperties::getCustomPropertyValue(const String&amp; propertyName) const
 325 {
 326     RefPtr&lt;CSSValue&gt; value = getCustomPropertyCSSValue(propertyName);
 327     if (value)
 328         return value-&gt;cssText();
 329     return String();
 330 }
 331 
 332 String StyleProperties::borderSpacingValue(const StylePropertyShorthand&amp; shorthand) const
 333 {
 334     RefPtr&lt;CSSValue&gt; horizontalValue = getPropertyCSSValueInternal(shorthand.properties()[0]);
 335     RefPtr&lt;CSSValue&gt; verticalValue = getPropertyCSSValueInternal(shorthand.properties()[1]);
 336 
 337     // While standard border-spacing property does not allow specifying border-spacing-vertical without
 338     // specifying border-spacing-horizontal &lt;http://www.w3.org/TR/CSS21/tables.html#separated-borders&gt;,
 339     // -webkit-border-spacing-vertical can be set without -webkit-border-spacing-horizontal.
 340     if (!horizontalValue || !verticalValue)
 341         return String();
 342 
 343     String horizontalValueCSSText = horizontalValue-&gt;cssText();
 344     String verticalValueCSSText = verticalValue-&gt;cssText();
 345     if (horizontalValueCSSText == verticalValueCSSText)
 346         return horizontalValueCSSText;
 347     return horizontalValueCSSText + &#39; &#39; + verticalValueCSSText;
 348 }
 349 
 350 void StyleProperties::appendFontLonghandValueIfExplicit(CSSPropertyID propertyID, StringBuilder&amp; result, String&amp; commonValue) const
 351 {
 352     int foundPropertyIndex = findPropertyIndex(propertyID);
 353     if (foundPropertyIndex == -1)
 354         return; // All longhands must have at least implicit values if &quot;font&quot; is specified.
 355 
 356     if (propertyAt(foundPropertyIndex).isImplicit()) {
 357         commonValue = String();
 358         return;
 359     }
 360 
 361     char prefix = &#39;\0&#39;;
 362     switch (propertyID) {
 363     case CSSPropertyFontStyle:
 364         break; // No prefix.
 365     case CSSPropertyFontFamily:
 366     case CSSPropertyFontVariantCaps:
 367     case CSSPropertyFontWeight:
 368     case CSSPropertyFontStretch:
 369         prefix = &#39; &#39;;
 370         break;
 371     case CSSPropertyLineHeight:
 372         prefix = &#39;/&#39;;
 373         break;
 374     default:
 375         ASSERT_NOT_REACHED();
 376     }
 377 
 378     if (prefix &amp;&amp; !result.isEmpty())
 379         result.append(prefix);
 380     String value = propertyAt(foundPropertyIndex).value()-&gt;cssText();
 381     result.append(value);
 382     if (!commonValue.isNull() &amp;&amp; commonValue != value)
 383         commonValue = String();
 384 }
 385 
 386 String StyleProperties::fontValue() const
 387 {
 388     int fontSizePropertyIndex = findPropertyIndex(CSSPropertyFontSize);
 389     int fontFamilyPropertyIndex = findPropertyIndex(CSSPropertyFontFamily);
 390     if (fontSizePropertyIndex == -1 || fontFamilyPropertyIndex == -1)
 391         return emptyString();
 392 
 393     PropertyReference fontSizeProperty = propertyAt(fontSizePropertyIndex);
 394     PropertyReference fontFamilyProperty = propertyAt(fontFamilyPropertyIndex);
 395     if (fontSizeProperty.isImplicit() || fontFamilyProperty.isImplicit())
 396         return emptyString();
 397 
 398     String commonValue = fontSizeProperty.value()-&gt;cssText();
 399     StringBuilder result;
 400     appendFontLonghandValueIfExplicit(CSSPropertyFontStyle, result, commonValue);
 401     appendFontLonghandValueIfExplicit(CSSPropertyFontVariantCaps, result, commonValue);
 402     appendFontLonghandValueIfExplicit(CSSPropertyFontWeight, result, commonValue);
 403     appendFontLonghandValueIfExplicit(CSSPropertyFontStretch, result, commonValue);
 404     if (!result.isEmpty())
 405         result.append(&#39; &#39;);
 406     result.append(fontSizeProperty.value()-&gt;cssText());
 407     appendFontLonghandValueIfExplicit(CSSPropertyLineHeight, result, commonValue);
 408     if (!result.isEmpty())
 409         result.append(&#39; &#39;);
 410     result.append(fontFamilyProperty.value()-&gt;cssText());
 411     if (isInitialOrInherit(commonValue))
 412         return commonValue;
 413     return result.toString();
 414 }
 415 
 416 String StyleProperties::get2Values(const StylePropertyShorthand&amp; shorthand) const
 417 {
 418     // Assume the properties are in the usual order start, end.
 419     int startValueIndex = findPropertyIndex(shorthand.properties()[0]);
 420     int endValueIndex = findPropertyIndex(shorthand.properties()[1]);
 421 
 422     if (startValueIndex == -1 || endValueIndex == -1)
 423         return { };
 424 
 425     auto start = propertyAt(startValueIndex);
 426     auto end = propertyAt(endValueIndex);
 427 
 428     // All 2 properties must be specified.
 429     if (!start.value() || !end.value())
 430         return { };
 431 
 432     // Important flags must be the same
 433     if (start.isImportant() != end.isImportant())
 434         return { };
 435 
 436     if (start.isInherited() &amp;&amp; end.isInherited())
 437         return getValueName(CSSValueInherit);
 438 
 439     if (start.value()-&gt;isInitialValue() || end.value()-&gt;isInitialValue()) {
 440         if (start.value()-&gt;isInitialValue() &amp;&amp; end.value()-&gt;isInitialValue() &amp;&amp; !start.isImplicit())
 441             return getValueName(CSSValueInitial);
 442         return { };
 443     }
 444 
 445     StringBuilder result;
 446     result.append(start.value()-&gt;cssText());
 447     if (!start.value()-&gt;equals(*end.value())) {
 448         result.append(&#39; &#39;);
 449         result.append(end.value()-&gt;cssText());
 450     }
 451     return result.toString();
 452 }
 453 
 454 String StyleProperties::get4Values(const StylePropertyShorthand&amp; shorthand) const
 455 {
 456     // Assume the properties are in the usual order top, right, bottom, left.
 457     int topValueIndex = findPropertyIndex(shorthand.properties()[0]);
 458     int rightValueIndex = findPropertyIndex(shorthand.properties()[1]);
 459     int bottomValueIndex = findPropertyIndex(shorthand.properties()[2]);
 460     int leftValueIndex = findPropertyIndex(shorthand.properties()[3]);
 461 
 462     if (topValueIndex == -1 || rightValueIndex == -1 || bottomValueIndex == -1 || leftValueIndex == -1)
 463         return String();
 464 
 465     PropertyReference top = propertyAt(topValueIndex);
 466     PropertyReference right = propertyAt(rightValueIndex);
 467     PropertyReference bottom = propertyAt(bottomValueIndex);
 468     PropertyReference left = propertyAt(leftValueIndex);
 469 
 470     // All 4 properties must be specified.
 471     if (!top.value() || !right.value() || !bottom.value() || !left.value())
 472         return String();
 473 
 474     // Important flags must be the same
 475     if (top.isImportant() != right.isImportant() || right.isImportant() != bottom.isImportant() || bottom.isImportant() != left.isImportant())
 476         return String();
 477 
 478     if (top.isInherited() &amp;&amp; right.isInherited() &amp;&amp; bottom.isInherited() &amp;&amp; left.isInherited())
 479         return getValueName(CSSValueInherit);
 480 
 481     if (top.value()-&gt;isInitialValue() || right.value()-&gt;isInitialValue() || bottom.value()-&gt;isInitialValue() || left.value()-&gt;isInitialValue()) {
 482         if (top.value()-&gt;isInitialValue() &amp;&amp; right.value()-&gt;isInitialValue() &amp;&amp; bottom.value()-&gt;isInitialValue() &amp;&amp; left.value()-&gt;isInitialValue() &amp;&amp; !top.isImplicit()) {
 483             // All components are &quot;initial&quot; and &quot;top&quot; is not implicit.
 484             return getValueName(CSSValueInitial);
 485         }
 486         return String();
 487     }
 488 
 489     bool showLeft = !right.value()-&gt;equals(*left.value());
 490     bool showBottom = !top.value()-&gt;equals(*bottom.value()) || showLeft;
 491     bool showRight = !top.value()-&gt;equals(*right.value()) || showBottom;
 492 
 493     StringBuilder result;
 494     result.append(top.value()-&gt;cssText());
 495     if (showRight) {
 496         result.append(&#39; &#39;);
 497         result.append(right.value()-&gt;cssText());
 498     }
 499     if (showBottom) {
 500         result.append(&#39; &#39;);
 501         result.append(bottom.value()-&gt;cssText());
 502     }
 503     if (showLeft) {
 504         result.append(&#39; &#39;);
 505         result.append(left.value()-&gt;cssText());
 506     }
 507     return result.toString();
 508 }
 509 
 510 String StyleProperties::getLayeredShorthandValue(const StylePropertyShorthand&amp; shorthand) const
 511 {
 512     StringBuilder result;
 513 
 514     const unsigned size = shorthand.length();
 515     // Begin by collecting the properties into an array.
 516     Vector&lt; RefPtr&lt;CSSValue&gt;&gt; values(size);
 517     size_t numLayers = 0;
 518 
 519     for (unsigned i = 0; i &lt; size; ++i) {
 520         values[i] = getPropertyCSSValueInternal(shorthand.properties()[i]);
 521         if (!values[i]) {
 522             // We don&#39;t have all longhand properties defined as required for the shorthand
 523             // property and thus should not serialize to a shorthand value. See spec at
 524             // http://www.w3.org/TR/cssom-1/#serialize-a-css-declaration-block.
 525             return String();
 526         }
 527         if (values[i]-&gt;isBaseValueList())
 528             numLayers = std::max(downcast&lt;CSSValueList&gt;(*values[i]).length(), numLayers);
 529         else
 530             numLayers = std::max&lt;size_t&gt;(1U, numLayers);
 531     }
 532 
 533     String commonValue;
 534     bool commonValueInitialized = false;
 535 
 536     // Now stitch the properties together. Implicit initial values are flagged as such and
 537     // can safely be omitted.
 538     for (size_t i = 0; i &lt; numLayers; i++) {
 539         StringBuilder layerResult;
 540         bool useRepeatXShorthand = false;
 541         bool useRepeatYShorthand = false;
 542         bool useSingleWordShorthand = false;
 543         bool foundPositionYCSSProperty = false;
 544         for (unsigned j = 0; j &lt; size; j++) {
 545             RefPtr&lt;CSSValue&gt; value;
 546             if (values[j]) {
 547                 if (values[j]-&gt;isBaseValueList())
 548                     value = downcast&lt;CSSValueList&gt;(*values[j]).item(i);
 549                 else {
 550                     value = values[j];
 551 
 552                     // Color only belongs in the last layer.
 553                     if (shorthand.properties()[j] == CSSPropertyBackgroundColor) {
 554                         if (i != numLayers - 1)
 555                             value = nullptr;
 556                     } else if (i) // Other singletons only belong in the first layer.
 557                         value = nullptr;
 558                 }
 559             }
 560 
 561             // We need to report background-repeat as it was written in the CSS. If the property is implicit,
 562             // then it was written with only one value. Here we figure out which value that was so we can
 563             // report back correctly.
 564             if ((shorthand.properties()[j] == CSSPropertyBackgroundRepeatX &amp;&amp; isPropertyImplicit(shorthand.properties()[j]))
 565                 || (shorthand.properties()[j] == CSSPropertyWebkitMaskRepeatX &amp;&amp; isPropertyImplicit(shorthand.properties()[j]))) {
 566 
 567                 // BUG 49055: make sure the value was not reset in the layer check just above.
 568                 if ((j &lt; size - 1 &amp;&amp; shorthand.properties()[j + 1] == CSSPropertyBackgroundRepeatY &amp;&amp; value)
 569                     || (j &lt; size - 1 &amp;&amp; shorthand.properties()[j + 1] == CSSPropertyWebkitMaskRepeatY &amp;&amp; value)) {
 570                     RefPtr&lt;CSSValue&gt; yValue;
 571                     RefPtr&lt;CSSValue&gt; nextValue = values[j + 1];
 572                     if (nextValue) {
 573                         if (is&lt;CSSValueList&gt;(*nextValue))
 574                             yValue = downcast&lt;CSSValueList&gt;(*nextValue).itemWithoutBoundsCheck(i);
 575                         else
 576                             yValue = nextValue;
 577 
 578                         if (!is&lt;CSSPrimitiveValue&gt;(*value) || !is&lt;CSSPrimitiveValue&gt;(*yValue))
 579                             continue;
 580 
 581                         CSSValueID xId = downcast&lt;CSSPrimitiveValue&gt;(*value).valueID();
 582                         CSSValueID yId = downcast&lt;CSSPrimitiveValue&gt;(*yValue).valueID();
 583                         if (xId != yId) {
 584                             if (xId == CSSValueRepeat &amp;&amp; yId == CSSValueNoRepeat) {
 585                                 useRepeatXShorthand = true;
 586                                 ++j;
 587                             } else if (xId == CSSValueNoRepeat &amp;&amp; yId == CSSValueRepeat) {
 588                                 useRepeatYShorthand = true;
 589                                 continue;
 590                             }
 591                         } else {
 592                             useSingleWordShorthand = true;
 593                             ++j;
 594                         }
 595                     }
 596                 }
 597             }
 598 
 599             String valueText;
 600             if (value &amp;&amp; !value-&gt;isImplicitInitialValue()) {
 601                 if (!layerResult.isEmpty())
 602                     layerResult.append(&#39; &#39;);
 603                 if (foundPositionYCSSProperty
 604                     &amp;&amp; (shorthand.properties()[j] == CSSPropertyBackgroundSize || shorthand.properties()[j] == CSSPropertyWebkitMaskSize))
 605                     layerResult.appendLiteral(&quot;/ &quot;);
 606                 if (!foundPositionYCSSProperty
 607                     &amp;&amp; (shorthand.properties()[j] == CSSPropertyBackgroundSize || shorthand.properties()[j] == CSSPropertyWebkitMaskSize))
 608                     continue;
 609 
 610                 if (useRepeatXShorthand) {
 611                     useRepeatXShorthand = false;
 612                     layerResult.append(getValueName(CSSValueRepeatX));
 613                 } else if (useRepeatYShorthand) {
 614                     useRepeatYShorthand = false;
 615                     layerResult.append(getValueName(CSSValueRepeatY));
 616                 } else {
 617                     if (useSingleWordShorthand)
 618                         useSingleWordShorthand = false;
 619                     valueText = value-&gt;cssText();
 620                     layerResult.append(valueText);
 621                 }
 622 
 623                 if (shorthand.properties()[j] == CSSPropertyBackgroundPositionY
 624                     || shorthand.properties()[j] == CSSPropertyWebkitMaskPositionY) {
 625                     foundPositionYCSSProperty = true;
 626 
 627                     // background-position is a special case: if only the first offset is specified,
 628                     // the second one defaults to &quot;center&quot;, not the same value.
 629                     if (commonValueInitialized &amp;&amp; commonValue != &quot;initial&quot; &amp;&amp; commonValue != &quot;inherit&quot;)
 630                         commonValue = String();
 631                 }
 632             }
 633 
 634             if (!commonValueInitialized) {
 635                 commonValue = valueText;
 636                 commonValueInitialized = true;
 637             } else if (!commonValue.isNull() &amp;&amp; commonValue != valueText)
 638                 commonValue = String();
 639         }
 640 
 641         if (!layerResult.isEmpty()) {
 642             if (!result.isEmpty())
 643                 result.appendLiteral(&quot;, &quot;);
 644             result.append(layerResult);
 645         }
 646     }
 647 
 648     if (isInitialOrInherit(commonValue))
 649         return commonValue;
 650 
 651     if (result.isEmpty())
 652         return String();
 653     return result.toString();
 654 }
 655 
 656 String StyleProperties::getGridShorthandValue(const StylePropertyShorthand&amp; shorthand) const
 657 {
 658     return getShorthandValue(shorthand, &quot; / &quot;);
 659 }
 660 
 661 String StyleProperties::getShorthandValue(const StylePropertyShorthand&amp; shorthand, const char* separator) const
 662 {
 663     String commonValue;
 664     StringBuilder result;
 665     for (unsigned i = 0; i &lt; shorthand.length(); ++i) {
 666         if (!isPropertyImplicit(shorthand.properties()[i])) {
 667             RefPtr&lt;CSSValue&gt; value = getPropertyCSSValueInternal(shorthand.properties()[i]);
 668             if (!value)
 669                 return String();
 670             String valueText = value-&gt;cssText();
 671             if (!i)
 672                 commonValue = valueText;
 673             else if (!commonValue.isNull() &amp;&amp; commonValue != valueText)
 674                 commonValue = String();
 675             if (value-&gt;isInitialValue())
 676                 continue;
 677             if (!result.isEmpty())
 678                 result.append(separator);
 679             result.append(valueText);
 680         } else
 681             commonValue = String();
 682     }
 683     if (isInitialOrInherit(commonValue))
 684         return commonValue;
 685     if (result.isEmpty())
 686         return String();
 687     return result.toString();
 688 }
 689 
 690 // only returns a non-null value if all properties have the same, non-null value
 691 String StyleProperties::getCommonValue(const StylePropertyShorthand&amp; shorthand) const
 692 {
 693     String res;
 694     bool lastPropertyWasImportant = false;
 695     for (unsigned i = 0; i &lt; shorthand.length(); ++i) {
 696         RefPtr&lt;CSSValue&gt; value = getPropertyCSSValueInternal(shorthand.properties()[i]);
 697         if (!value)
 698             return String();
 699         // FIXME: CSSInitialValue::cssText should generate the right value.
 700         String text = value-&gt;cssText();
 701         if (text.isNull())
 702             return String();
 703         if (res.isNull())
 704             res = text;
 705         else if (res != text)
 706             return String();
 707 
 708         bool currentPropertyIsImportant = propertyIsImportant(shorthand.properties()[i]);
 709         if (i &amp;&amp; lastPropertyWasImportant != currentPropertyIsImportant)
 710             return String();
 711         lastPropertyWasImportant = currentPropertyIsImportant;
 712     }
 713     return res;
 714 }
 715 
 716 String StyleProperties::getAlignmentShorthandValue(const StylePropertyShorthand&amp; shorthand) const
 717 {
 718     String value = getCommonValue(shorthand);
 719     if (value.isNull() || value.isEmpty())
 720         return getShorthandValue(shorthand);
 721     return value;
 722 }
 723 
 724 String StyleProperties::borderPropertyValue(const StylePropertyShorthand&amp; width, const StylePropertyShorthand&amp; style, const StylePropertyShorthand&amp; color) const
 725 {
 726     const StylePropertyShorthand properties[3] = { width, style, color };
 727     String commonValue;
 728     StringBuilder result;
 729     for (size_t i = 0; i &lt; WTF_ARRAY_LENGTH(properties); ++i) {
 730         String value = getCommonValue(properties[i]);
 731         if (value.isNull())
 732             return String();
 733         if (!i)
 734             commonValue = value;
 735         else if (commonValue != value)
 736             commonValue = String();
 737         if (value == &quot;initial&quot;)
 738             continue;
 739         if (!result.isEmpty())
 740             result.append(&#39; &#39;);
 741         result.append(value);
 742     }
 743     if (isInitialOrInherit(commonValue))
 744         return commonValue;
 745     return result.toString();
 746 }
 747 
 748 String StyleProperties::pageBreakPropertyValue(const StylePropertyShorthand&amp; shorthand) const
 749 {
 750     RefPtr&lt;CSSValue&gt; value = getPropertyCSSValueInternal(shorthand.properties()[0]);
 751     // FIXME: Remove this isGlobalKeyword check after we do this consistently for all shorthands in getPropertyValue.
 752     if (value-&gt;isGlobalKeyword())
 753         return value-&gt;cssText();
<a name="1" id="anc1"></a><span class="line-added"> 754 </span>
<span class="line-added"> 755     if (!is&lt;CSSPrimitiveValue&gt;(*value))</span>
<span class="line-added"> 756         return String();</span>
<span class="line-added"> 757 </span>
 758     CSSValueID valueId = downcast&lt;CSSPrimitiveValue&gt;(*value).valueID();
 759     switch (valueId) {
 760     case CSSValuePage:
 761         return &quot;always&quot;_s;
 762     case CSSValueAuto:
 763     case CSSValueAvoid:
 764     case CSSValueLeft:
 765     case CSSValueRight:
 766         return value-&gt;cssText();
 767     default:
 768         return String();
 769     }
 770 }
 771 
 772 RefPtr&lt;CSSValue&gt; StyleProperties::getPropertyCSSValue(CSSPropertyID propertyID) const
 773 {
 774     return getPropertyCSSValueInternal(propertyID);
 775 }
 776 
 777 RefPtr&lt;CSSValue&gt; StyleProperties::getPropertyCSSValueInternal(CSSPropertyID propertyID) const
 778 {
 779     int foundPropertyIndex = findPropertyIndex(propertyID);
 780     if (foundPropertyIndex == -1)
 781         return nullptr;
 782     return propertyAt(foundPropertyIndex).value();
 783 }
 784 
 785 RefPtr&lt;CSSValue&gt; StyleProperties::getCustomPropertyCSSValue(const String&amp; propertyName) const
 786 {
 787     int foundPropertyIndex = findCustomPropertyIndex(propertyName);
 788     if (foundPropertyIndex == -1)
 789         return nullptr;
 790     return propertyAt(foundPropertyIndex).value();
 791 }
 792 
 793 bool MutableStyleProperties::removeShorthandProperty(CSSPropertyID propertyID)
 794 {
 795     StylePropertyShorthand shorthand = shorthandForProperty(propertyID);
 796     if (!shorthand.length())
 797         return false;
 798 
 799     return removePropertiesInSet(shorthand.properties(), shorthand.length());
 800 }
 801 
 802 bool MutableStyleProperties::removeProperty(CSSPropertyID propertyID, String* returnText)
 803 {
 804     if (removeShorthandProperty(propertyID)) {
 805         // FIXME: Return an equivalent shorthand when possible.
 806         if (returnText)
 807             *returnText = emptyString();
 808         return true;
 809     }
 810 
 811     int foundPropertyIndex = findPropertyIndex(propertyID);
 812     if (foundPropertyIndex == -1) {
 813         if (returnText)
 814             *returnText = emptyString();
 815         return false;
 816     }
 817 
 818     if (returnText)
 819         *returnText = propertyAt(foundPropertyIndex).value()-&gt;cssText();
 820 
 821     // A more efficient removal strategy would involve marking entries as empty
 822     // and sweeping them when the vector grows too big.
 823     m_propertyVector.remove(foundPropertyIndex);
 824 
 825     return true;
 826 }
 827 
 828 bool MutableStyleProperties::removeCustomProperty(const String&amp; propertyName, String* returnText)
 829 {
 830     int foundPropertyIndex = findCustomPropertyIndex(propertyName);
 831     if (foundPropertyIndex == -1) {
 832         if (returnText)
 833             *returnText = emptyString();
 834         return false;
 835     }
 836 
 837     if (returnText)
 838         *returnText = propertyAt(foundPropertyIndex).value()-&gt;cssText();
 839 
 840     // A more efficient removal strategy would involve marking entries as empty
 841     // and sweeping them when the vector grows too big.
 842     m_propertyVector.remove(foundPropertyIndex);
 843 
 844     return true;
 845 }
 846 
 847 bool StyleProperties::propertyIsImportant(CSSPropertyID propertyID) const
 848 {
 849     int foundPropertyIndex = findPropertyIndex(propertyID);
 850     if (foundPropertyIndex != -1)
 851         return propertyAt(foundPropertyIndex).isImportant();
 852 
 853     StylePropertyShorthand shorthand = shorthandForProperty(propertyID);
 854     if (!shorthand.length())
 855         return false;
 856 
 857     for (unsigned i = 0; i &lt; shorthand.length(); ++i) {
 858         if (!propertyIsImportant(shorthand.properties()[i]))
 859             return false;
 860     }
 861     return true;
 862 }
 863 
 864 bool StyleProperties::customPropertyIsImportant(const String&amp; propertyName) const
 865 {
 866     int foundPropertyIndex = findCustomPropertyIndex(propertyName);
 867     if (foundPropertyIndex != -1)
 868         return propertyAt(foundPropertyIndex).isImportant();
 869     return false;
 870 }
 871 
 872 String StyleProperties::getPropertyShorthand(CSSPropertyID propertyID) const
 873 {
 874     int foundPropertyIndex = findPropertyIndex(propertyID);
 875     if (foundPropertyIndex == -1)
 876         return String();
 877     return getPropertyNameString(propertyAt(foundPropertyIndex).shorthandID());
 878 }
 879 
 880 bool StyleProperties::isPropertyImplicit(CSSPropertyID propertyID) const
 881 {
 882     int foundPropertyIndex = findPropertyIndex(propertyID);
 883     if (foundPropertyIndex == -1)
 884         return false;
 885     return propertyAt(foundPropertyIndex).isImplicit();
 886 }
 887 
 888 bool MutableStyleProperties::setProperty(CSSPropertyID propertyID, const String&amp; value, bool important, CSSParserContext parserContext)
 889 {
 890     if (!isEnabledCSSProperty(propertyID))
 891         return false;
 892 
 893     // Setting the value to an empty string just removes the property in both IE and Gecko.
 894     // Setting it to null seems to produce less consistent results, but we treat it just the same.
 895     if (value.isEmpty())
 896         return removeProperty(propertyID);
 897 
 898     parserContext.mode = cssParserMode();
 899 
 900     // When replacing an existing property value, this moves the property to the end of the list.
 901     // Firefox preserves the position, and MSIE moves the property to the beginning.
 902     return CSSParser::parseValue(*this, propertyID, value, important, parserContext) == CSSParser::ParseResult::Changed;
 903 }
 904 
 905 bool MutableStyleProperties::setProperty(CSSPropertyID propertyID, const String&amp; value, bool important)
 906 {
 907     CSSParserContext parserContext(cssParserMode());
 908     return setProperty(propertyID, value, important, parserContext);
 909 }
 910 
 911 bool MutableStyleProperties::setCustomProperty(const Document* document, const String&amp; propertyName, const String&amp; value, bool important, CSSParserContext parserContext)
 912 {
 913     // Setting the value to an empty string just removes the property in both IE and Gecko.
 914     // Setting it to null seems to produce less consistent results, but we treat it just the same.
 915     if (value.isEmpty())
 916         return removeCustomProperty(propertyName);
 917 
 918     parserContext.mode = cssParserMode();
 919 
 920     String syntax = &quot;*&quot;;
 921     auto* registered = document ? document-&gt;getCSSRegisteredCustomPropertySet().get(propertyName) : nullptr;
 922 
 923     if (registered)
 924         syntax = registered-&gt;syntax;
 925 
 926     CSSTokenizer tokenizer(value);
 927     if (!CSSPropertyParser::canParseTypedCustomPropertyValue(syntax, tokenizer.tokenRange(), parserContext))
 928         return false;
 929 
 930     // When replacing an existing property value, this moves the property to the end of the list.
 931     // Firefox preserves the position, and MSIE moves the property to the beginning.
 932     return CSSParser::parseCustomPropertyValue(*this, propertyName, value, important, parserContext) == CSSParser::ParseResult::Changed;
 933 }
 934 
 935 void MutableStyleProperties::setProperty(CSSPropertyID propertyID, RefPtr&lt;CSSValue&gt;&amp;&amp; value, bool important)
 936 {
 937     StylePropertyShorthand shorthand = shorthandForProperty(propertyID);
 938     if (!shorthand.length()) {
 939         setProperty(CSSProperty(propertyID, WTFMove(value), important));
 940         return;
 941     }
 942 
 943     removePropertiesInSet(shorthand.properties(), shorthand.length());
 944 
 945     for (unsigned i = 0; i &lt; shorthand.length(); ++i)
 946         m_propertyVector.append(CSSProperty(shorthand.properties()[i], value.copyRef(), important));
 947 }
 948 
 949 bool MutableStyleProperties::setProperty(const CSSProperty&amp; property, CSSProperty* slot)
 950 {
 951     if (!removeShorthandProperty(property.id())) {
 952         CSSProperty* toReplace = slot;
 953         if (!slot) {
 954             if (property.id() == CSSPropertyCustom) {
 955                 if (property.value())
 956                     toReplace = findCustomCSSPropertyWithName(downcast&lt;CSSCustomPropertyValue&gt;(*property.value()).name());
 957             } else
 958                 toReplace = findCSSPropertyWithID(property.id());
 959         }
 960 
 961         if (toReplace) {
 962             if (*toReplace == property)
 963                 return false;
 964 
 965             *toReplace = property;
 966             return true;
 967         }
 968     }
 969 
 970     m_propertyVector.append(property);
 971     return true;
 972 }
 973 
 974 bool MutableStyleProperties::setProperty(CSSPropertyID propertyID, CSSValueID identifier, bool important)
 975 {
 976     return setProperty(CSSProperty(propertyID, CSSValuePool::singleton().createIdentifierValue(identifier), important));
 977 }
 978 
 979 bool MutableStyleProperties::setProperty(CSSPropertyID propertyID, CSSPropertyID identifier, bool important)
 980 {
 981     return setProperty(CSSProperty(propertyID, CSSValuePool::singleton().createIdentifierValue(identifier), important));
 982 }
 983 
 984 bool MutableStyleProperties::parseDeclaration(const String&amp; styleDeclaration, CSSParserContext context)
 985 {
 986     auto oldProperties = WTFMove(m_propertyVector);
 987     m_propertyVector.clear();
 988 
 989     context.mode = cssParserMode();
 990 
 991     CSSParser parser(context);
 992     parser.parseDeclaration(*this, styleDeclaration);
 993 
 994     // We could do better. Just changing property order does not require style invalidation.
 995     return oldProperties != m_propertyVector;
 996 }
 997 
 998 bool MutableStyleProperties::addParsedProperties(const ParsedPropertyVector&amp; properties)
 999 {
1000     bool anyChanged = false;
1001     m_propertyVector.reserveCapacity(m_propertyVector.size() + properties.size());
1002     for (const auto&amp; property : properties) {
1003         if (addParsedProperty(property))
1004             anyChanged = true;
1005     }
1006 
1007     return anyChanged;
1008 }
1009 
1010 bool MutableStyleProperties::addParsedProperty(const CSSProperty&amp; property)
1011 {
1012     if (property.id() == CSSPropertyCustom) {
1013         if ((property.value() &amp;&amp; !customPropertyIsImportant(downcast&lt;CSSCustomPropertyValue&gt;(*property.value()).name())) || property.isImportant())
1014             return setProperty(property);
1015         return false;
1016     }
1017     return setProperty(property);
1018 }
1019 
1020 String StyleProperties::asText() const
1021 {
1022     StringBuilder result;
1023 
1024     int positionXPropertyIndex = -1;
1025     int positionYPropertyIndex = -1;
1026     int repeatXPropertyIndex = -1;
1027     int repeatYPropertyIndex = -1;
1028 
1029     std::bitset&lt;numCSSProperties&gt; shorthandPropertyUsed;
1030     std::bitset&lt;numCSSProperties&gt; shorthandPropertyAppeared;
1031 
1032     unsigned size = propertyCount();
1033     unsigned numDecls = 0;
1034     for (unsigned n = 0; n &lt; size; ++n) {
1035         PropertyReference property = propertyAt(n);
1036         CSSPropertyID propertyID = property.id();
1037         CSSPropertyID shorthandPropertyID = CSSPropertyInvalid;
1038         CSSPropertyID borderFallbackShorthandProperty = CSSPropertyInvalid;
1039         CSSPropertyID borderBlockFallbackShorthandProperty = CSSPropertyInvalid;
1040         CSSPropertyID borderInlineFallbackShorthandProperty = CSSPropertyInvalid;
1041         String value;
1042         auto serializeBorderShorthand = [&amp;] (const CSSPropertyID borderProperty, const CSSPropertyID fallbackProperty) {
1043             // FIXME: Deal with cases where only some of border sides are specified.
1044             ASSERT(borderProperty - firstCSSProperty &lt; static_cast&lt;CSSPropertyID&gt;(shorthandPropertyAppeared.size()));
1045             if (!shorthandPropertyAppeared[borderProperty - firstCSSProperty] &amp;&amp; isEnabledCSSProperty(borderProperty)) {
1046                 value = getPropertyValue(borderProperty);
1047                 if (value.isNull())
1048                     shorthandPropertyAppeared.set(borderProperty - firstCSSProperty);
1049                 else
1050                     shorthandPropertyID = borderProperty;
1051             } else if (shorthandPropertyUsed[borderProperty - firstCSSProperty])
1052                 shorthandPropertyID = borderProperty;
1053             if (!shorthandPropertyID)
1054                 shorthandPropertyID = fallbackProperty;
1055         };
1056 
1057         if (property.value() &amp;&amp; property.value()-&gt;isPendingSubstitutionValue()) {
1058             auto&amp; substitutionValue = downcast&lt;CSSPendingSubstitutionValue&gt;(*property.value());
1059             shorthandPropertyID = substitutionValue.shorthandPropertyId();
1060             value = substitutionValue.shorthandValue()-&gt;cssText();
1061         } else {
1062             switch (propertyID) {
1063             case CSSPropertyAnimationName:
1064             case CSSPropertyAnimationDuration:
1065             case CSSPropertyAnimationTimingFunction:
1066             case CSSPropertyAnimationDelay:
1067             case CSSPropertyAnimationIterationCount:
1068             case CSSPropertyAnimationDirection:
1069             case CSSPropertyAnimationFillMode:
1070             case CSSPropertyAnimationPlayState:
1071                 shorthandPropertyID = CSSPropertyAnimation;
1072                 break;
1073             case CSSPropertyBackgroundPositionX:
1074                 positionXPropertyIndex = n;
1075                 continue;
1076             case CSSPropertyBackgroundPositionY:
1077                 positionYPropertyIndex = n;
1078                 continue;
1079             case CSSPropertyBackgroundRepeatX:
1080                 repeatXPropertyIndex = n;
1081                 continue;
1082             case CSSPropertyBackgroundRepeatY:
1083                 repeatYPropertyIndex = n;
1084                 continue;
1085             case CSSPropertyBorderTopWidth:
1086             case CSSPropertyBorderRightWidth:
1087             case CSSPropertyBorderBottomWidth:
1088             case CSSPropertyBorderLeftWidth:
1089                 if (!borderFallbackShorthandProperty)
1090                     borderFallbackShorthandProperty = CSSPropertyBorderWidth;
1091                 FALLTHROUGH;
1092             case CSSPropertyBorderTopStyle:
1093             case CSSPropertyBorderRightStyle:
1094             case CSSPropertyBorderBottomStyle:
1095             case CSSPropertyBorderLeftStyle:
1096                 if (!borderFallbackShorthandProperty)
1097                     borderFallbackShorthandProperty = CSSPropertyBorderStyle;
1098                 FALLTHROUGH;
1099             case CSSPropertyBorderTopColor:
1100             case CSSPropertyBorderRightColor:
1101             case CSSPropertyBorderBottomColor:
1102             case CSSPropertyBorderLeftColor:
1103                 if (!borderFallbackShorthandProperty)
1104                     borderFallbackShorthandProperty = CSSPropertyBorderColor;
1105                 serializeBorderShorthand(CSSPropertyBorder, borderFallbackShorthandProperty);
1106                 break;
1107             case CSSPropertyBorderBlockStartWidth:
1108             case CSSPropertyBorderBlockEndWidth:
1109                 if (!borderBlockFallbackShorthandProperty)
1110                     borderBlockFallbackShorthandProperty = CSSPropertyBorderBlockWidth;
1111                 FALLTHROUGH;
1112             case CSSPropertyBorderBlockStartStyle:
1113             case CSSPropertyBorderBlockEndStyle:
1114                 if (!borderBlockFallbackShorthandProperty)
1115                     borderBlockFallbackShorthandProperty = CSSPropertyBorderBlockStyle;
1116                 FALLTHROUGH;
1117             case CSSPropertyBorderBlockStartColor:
1118             case CSSPropertyBorderBlockEndColor:
1119                 if (!borderBlockFallbackShorthandProperty)
1120                     borderBlockFallbackShorthandProperty = CSSPropertyBorderBlockColor;
1121                 serializeBorderShorthand(CSSPropertyBorderBlock, borderBlockFallbackShorthandProperty);
1122                 break;
1123             case CSSPropertyBorderInlineStartWidth:
1124             case CSSPropertyBorderInlineEndWidth:
1125                 if (!borderInlineFallbackShorthandProperty)
1126                     borderInlineFallbackShorthandProperty = CSSPropertyBorderInlineWidth;
1127                 FALLTHROUGH;
1128             case CSSPropertyBorderInlineStartStyle:
1129             case CSSPropertyBorderInlineEndStyle:
1130                 if (!borderInlineFallbackShorthandProperty)
1131                     borderInlineFallbackShorthandProperty = CSSPropertyBorderInlineStyle;
1132                 FALLTHROUGH;
1133             case CSSPropertyBorderInlineStartColor:
1134             case CSSPropertyBorderInlineEndColor:
1135                 if (!borderInlineFallbackShorthandProperty)
1136                     borderInlineFallbackShorthandProperty = CSSPropertyBorderInlineColor;
1137                 serializeBorderShorthand(CSSPropertyBorderInline, borderInlineFallbackShorthandProperty);
1138                 break;
1139             case CSSPropertyWebkitBorderHorizontalSpacing:
1140             case CSSPropertyWebkitBorderVerticalSpacing:
1141                 shorthandPropertyID = CSSPropertyBorderSpacing;
1142                 break;
1143             case CSSPropertyFontFamily:
1144             case CSSPropertyLineHeight:
1145             case CSSPropertyFontSize:
1146             case CSSPropertyFontStyle:
1147             case CSSPropertyFontVariantCaps:
1148             case CSSPropertyFontWeight:
1149                 // Don&#39;t use CSSPropertyFont because old UAs can&#39;t recognize them but are important for editing.
1150                 break;
1151             case CSSPropertyTop:
1152             case CSSPropertyRight:
1153             case CSSPropertyBottom:
1154             case CSSPropertyLeft:
1155                 shorthandPropertyID = CSSPropertyInset;
1156                 break;
1157             case CSSPropertyInsetBlockStart:
1158             case CSSPropertyInsetBlockEnd:
1159                 shorthandPropertyID = CSSPropertyInsetBlock;
1160                 break;
1161             case CSSPropertyInsetInlineStart:
1162             case CSSPropertyInsetInlineEnd:
1163                 shorthandPropertyID = CSSPropertyInsetInline;
1164                 break;
1165             case CSSPropertyListStyleType:
1166             case CSSPropertyListStylePosition:
1167             case CSSPropertyListStyleImage:
1168                 shorthandPropertyID = CSSPropertyListStyle;
1169                 break;
1170             case CSSPropertyMarginTop:
1171             case CSSPropertyMarginRight:
1172             case CSSPropertyMarginBottom:
1173             case CSSPropertyMarginLeft:
1174                 shorthandPropertyID = CSSPropertyMargin;
1175                 break;
1176             case CSSPropertyMarginBlockStart:
1177             case CSSPropertyMarginBlockEnd:
1178                 shorthandPropertyID = CSSPropertyMarginBlock;
1179                 break;
1180             case CSSPropertyMarginInlineStart:
1181             case CSSPropertyMarginInlineEnd:
1182                 shorthandPropertyID = CSSPropertyMarginInline;
1183                 break;
1184             case CSSPropertyOutlineWidth:
1185             case CSSPropertyOutlineStyle:
1186             case CSSPropertyOutlineColor:
1187                 shorthandPropertyID = CSSPropertyOutline;
1188                 break;
1189             case CSSPropertyOverflowX:
1190             case CSSPropertyOverflowY:
1191                 shorthandPropertyID = CSSPropertyOverflow;
1192                 break;
1193             case CSSPropertyPaddingTop:
1194             case CSSPropertyPaddingRight:
1195             case CSSPropertyPaddingBottom:
1196             case CSSPropertyPaddingLeft:
1197                 shorthandPropertyID = CSSPropertyPadding;
1198                 break;
1199             case CSSPropertyPaddingBlockStart:
1200             case CSSPropertyPaddingBlockEnd:
1201                 shorthandPropertyID = CSSPropertyPaddingBlock;
1202                 break;
1203             case CSSPropertyPaddingInlineStart:
1204             case CSSPropertyPaddingInlineEnd:
1205                 shorthandPropertyID = CSSPropertyPaddingInline;
1206                 break;
1207 #if ENABLE(CSS_SCROLL_SNAP)
1208             case CSSPropertyScrollPaddingTop:
1209             case CSSPropertyScrollPaddingRight:
1210             case CSSPropertyScrollPaddingBottom:
1211             case CSSPropertyScrollPaddingLeft:
1212                 shorthandPropertyID = CSSPropertyScrollPadding;
1213                 break;
1214             case CSSPropertyScrollSnapMarginTop:
1215             case CSSPropertyScrollSnapMarginRight:
1216             case CSSPropertyScrollSnapMarginBottom:
1217             case CSSPropertyScrollSnapMarginLeft:
1218                 shorthandPropertyID = CSSPropertyScrollSnapMargin;
1219                 break;
1220 #endif
1221             case CSSPropertyTransitionProperty:
1222             case CSSPropertyTransitionDuration:
1223             case CSSPropertyTransitionTimingFunction:
1224             case CSSPropertyTransitionDelay:
1225                 shorthandPropertyID = CSSPropertyTransition;
1226                 break;
1227             case CSSPropertyFlexDirection:
1228             case CSSPropertyFlexWrap:
1229                 shorthandPropertyID = CSSPropertyFlexFlow;
1230                 break;
1231             case CSSPropertyFlexBasis:
1232             case CSSPropertyFlexGrow:
1233             case CSSPropertyFlexShrink:
1234                 shorthandPropertyID = CSSPropertyFlex;
1235                 break;
1236             case CSSPropertyWebkitMaskPositionX:
1237             case CSSPropertyWebkitMaskPositionY:
1238             case CSSPropertyWebkitMaskRepeatX:
1239             case CSSPropertyWebkitMaskRepeatY:
1240             case CSSPropertyWebkitMaskImage:
1241             case CSSPropertyWebkitMaskRepeat:
1242             case CSSPropertyWebkitMaskPosition:
1243             case CSSPropertyWebkitMaskClip:
1244             case CSSPropertyWebkitMaskOrigin:
1245                 shorthandPropertyID = CSSPropertyWebkitMask;
1246                 break;
1247             case CSSPropertyPerspectiveOriginX:
1248             case CSSPropertyPerspectiveOriginY:
1249                 shorthandPropertyID = CSSPropertyPerspectiveOrigin;
1250                 break;
1251             case CSSPropertyTransformOriginX:
1252             case CSSPropertyTransformOriginY:
1253             case CSSPropertyTransformOriginZ:
1254                 shorthandPropertyID = CSSPropertyTransformOrigin;
1255                 break;
1256             default:
1257                 break;
1258             }
1259         }
1260 
1261         unsigned shortPropertyIndex = shorthandPropertyID - firstCSSProperty;
1262         if (shorthandPropertyID &amp;&amp; isEnabledCSSProperty(shorthandPropertyID)) {
1263             ASSERT(shortPropertyIndex &lt; shorthandPropertyUsed.size());
1264             if (shorthandPropertyUsed[shortPropertyIndex])
1265                 continue;
1266             if (!shorthandPropertyAppeared[shortPropertyIndex] &amp;&amp; value.isNull())
1267                 value = getPropertyValue(shorthandPropertyID);
1268             shorthandPropertyAppeared.set(shortPropertyIndex);
1269         }
1270 
1271         if (!value.isNull()) {
1272             propertyID = shorthandPropertyID;
1273             shorthandPropertyUsed.set(shortPropertyIndex);
1274         } else
1275             value = property.value()-&gt;cssText();
1276 
1277         if (propertyID != CSSPropertyCustom &amp;&amp; value == &quot;initial&quot; &amp;&amp; !CSSProperty::isInheritedProperty(propertyID))
1278             continue;
1279 
1280         if (numDecls++)
1281             result.append(&#39; &#39;);
1282 
1283         if (propertyID == CSSPropertyCustom)
1284             result.append(downcast&lt;CSSCustomPropertyValue&gt;(*property.value()).name());
1285         else
1286             result.append(getPropertyName(propertyID));
1287 
1288         result.appendLiteral(&quot;: &quot;);
1289         result.append(value);
1290         if (property.isImportant())
1291             result.appendLiteral(&quot; !important&quot;);
1292         result.append(&#39;;&#39;);
1293     }
1294 
1295     // FIXME: This is a not-so-nice way to turn x/y positions into single background-position in output.
1296     // It is required because background-position-x/y are non-standard properties and WebKit generated output
1297     // would not work in Firefox (&lt;rdar://problem/5143183&gt;)
1298     // It would be a better solution if background-position was CSSUnitType::CSS_PAIR.
1299     if (positionXPropertyIndex != -1 &amp;&amp; positionYPropertyIndex != -1 &amp;&amp; propertyAt(positionXPropertyIndex).isImportant() == propertyAt(positionYPropertyIndex).isImportant()) {
1300         PropertyReference positionXProperty = propertyAt(positionXPropertyIndex);
1301         PropertyReference positionYProperty = propertyAt(positionYPropertyIndex);
1302 
1303         if (numDecls++)
1304             result.append(&#39; &#39;);
1305         result.appendLiteral(&quot;background-position: &quot;);
1306         if (positionXProperty.value()-&gt;isValueList() || positionYProperty.value()-&gt;isValueList())
1307             result.append(getLayeredShorthandValue(backgroundPositionShorthand()));
1308         else {
1309             result.append(positionXProperty.value()-&gt;cssText());
1310             result.append(&#39; &#39;);
1311             result.append(positionYProperty.value()-&gt;cssText());
1312         }
1313         if (positionXProperty.isImportant())
1314             result.appendLiteral(&quot; !important&quot;);
1315         result.append(&#39;;&#39;);
1316     } else {
1317         if (positionXPropertyIndex != -1) {
1318             if (numDecls++)
1319                 result.append(&#39; &#39;);
1320             result.append(propertyAt(positionXPropertyIndex).cssText());
1321         }
1322         if (positionYPropertyIndex != -1) {
1323             if (numDecls++)
1324                 result.append(&#39; &#39;);
1325             result.append(propertyAt(positionYPropertyIndex).cssText());
1326         }
1327     }
1328 
1329     // FIXME: We need to do the same for background-repeat.
1330     if (repeatXPropertyIndex != -1 &amp;&amp; repeatYPropertyIndex != -1 &amp;&amp; propertyAt(repeatXPropertyIndex).isImportant() == propertyAt(repeatYPropertyIndex).isImportant()) {
1331         PropertyReference repeatXProperty = propertyAt(repeatXPropertyIndex);
1332         PropertyReference repeatYProperty = propertyAt(repeatYPropertyIndex);
1333 
1334         if (numDecls++)
1335             result.append(&#39; &#39;);
1336         result.appendLiteral(&quot;background-repeat: &quot;);
1337         if (repeatXProperty.value()-&gt;isValueList() || repeatYProperty.value()-&gt;isValueList())
1338             result.append(getLayeredShorthandValue(backgroundRepeatShorthand()));
1339         else {
1340             result.append(repeatXProperty.value()-&gt;cssText());
1341             result.append(&#39; &#39;);
1342             result.append(repeatYProperty.value()-&gt;cssText());
1343         }
1344         if (repeatXProperty.isImportant())
1345             result.appendLiteral(&quot; !important&quot;);
1346         result.append(&#39;;&#39;);
1347     } else {
1348         if (repeatXPropertyIndex != -1) {
1349             if (numDecls++)
1350                 result.append(&#39; &#39;);
1351             result.append(propertyAt(repeatXPropertyIndex).cssText());
1352         }
1353         if (repeatYPropertyIndex != -1) {
1354             if (numDecls++)
1355                 result.append(&#39; &#39;);
1356             result.append(propertyAt(repeatYPropertyIndex).cssText());
1357         }
1358     }
1359 
1360     ASSERT(!numDecls ^ !result.isEmpty());
1361     return result.toString();
1362 }
1363 
1364 bool StyleProperties::hasCSSOMWrapper() const
1365 {
1366     return is&lt;MutableStyleProperties&gt;(*this) &amp;&amp; downcast&lt;MutableStyleProperties&gt;(*this).m_cssomWrapper;
1367 }
1368 
1369 void MutableStyleProperties::mergeAndOverrideOnConflict(const StyleProperties&amp; other)
1370 {
1371     unsigned size = other.propertyCount();
1372     for (unsigned i = 0; i &lt; size; ++i)
1373         addParsedProperty(other.propertyAt(i).toCSSProperty());
1374 }
1375 
1376 bool StyleProperties::traverseSubresources(const WTF::Function&lt;bool (const CachedResource&amp;)&gt;&amp; handler) const
1377 {
1378     unsigned size = propertyCount();
1379     for (unsigned i = 0; i &lt; size; ++i) {
1380         if (propertyAt(i).value()-&gt;traverseSubresources(handler))
1381             return true;
1382     }
1383     return false;
1384 }
1385 
1386 // This is the list of properties we want to copy in the copyBlockProperties() function.
1387 // It is the list of CSS properties that apply specially to block-level elements.
1388 static const CSSPropertyID blockProperties[] = {
1389     CSSPropertyOrphans,
1390     CSSPropertyOverflow, // This can be also be applied to replaced elements
1391     CSSPropertyWebkitAspectRatio,
1392     CSSPropertyColumnCount,
1393     CSSPropertyColumnGap,
1394     CSSPropertyRowGap,
1395     CSSPropertyColumnRuleColor,
1396     CSSPropertyColumnRuleStyle,
1397     CSSPropertyColumnRuleWidth,
1398     CSSPropertyWebkitColumnBreakBefore,
1399     CSSPropertyWebkitColumnBreakAfter,
1400     CSSPropertyWebkitColumnBreakInside,
1401     CSSPropertyColumnWidth,
1402     CSSPropertyPageBreakAfter,
1403     CSSPropertyPageBreakBefore,
1404     CSSPropertyPageBreakInside,
1405     CSSPropertyTextAlign,
1406 #if ENABLE(CSS3_TEXT)
1407     CSSPropertyWebkitTextAlignLast,
1408     CSSPropertyWebkitTextJustify,
1409 #endif // CSS3_TEXT
1410     CSSPropertyTextIndent,
1411     CSSPropertyWidows
1412 };
1413 
1414 void MutableStyleProperties::clear()
1415 {
1416     m_propertyVector.clear();
1417 }
1418 
1419 const unsigned numBlockProperties = WTF_ARRAY_LENGTH(blockProperties);
1420 
1421 Ref&lt;MutableStyleProperties&gt; StyleProperties::copyBlockProperties() const
1422 {
1423     return copyPropertiesInSet(blockProperties, numBlockProperties);
1424 }
1425 
1426 void MutableStyleProperties::removeBlockProperties()
1427 {
1428     removePropertiesInSet(blockProperties, numBlockProperties);
1429 }
1430 
1431 bool MutableStyleProperties::removePropertiesInSet(const CSSPropertyID* set, unsigned length)
1432 {
1433     if (m_propertyVector.isEmpty())
1434         return false;
1435 
1436     // FIXME: This is always used with static sets and in that case constructing the hash repeatedly is pretty pointless.
1437     HashSet&lt;CSSPropertyID&gt; toRemove;
1438     for (unsigned i = 0; i &lt; length; ++i)
1439         toRemove.add(set[i]);
1440 
1441     return m_propertyVector.removeAllMatching([&amp;toRemove] (const CSSProperty&amp; property) {
1442         return toRemove.contains(property.id());
1443     }) &gt; 0;
1444 }
1445 
1446 int ImmutableStyleProperties::findPropertyIndex(CSSPropertyID propertyID) const
1447 {
1448     // Convert here propertyID into an uint16_t to compare it with the metadata&#39;s m_propertyID to avoid
1449     // the compiler converting it to an int multiple times in the loop.
1450     uint16_t id = static_cast&lt;uint16_t&gt;(propertyID);
1451     for (int n = m_arraySize - 1 ; n &gt;= 0; --n) {
1452         if (metadataArray()[n].m_propertyID == id)
1453             return n;
1454     }
1455 
1456     return -1;
1457 }
1458 
1459 int MutableStyleProperties::findPropertyIndex(CSSPropertyID propertyID) const
1460 {
1461     // Convert here propertyID into an uint16_t to compare it with the metadata&#39;s m_propertyID to avoid
1462     // the compiler converting it to an int multiple times in the loop.
1463     uint16_t id = static_cast&lt;uint16_t&gt;(propertyID);
1464     for (int n = m_propertyVector.size() - 1 ; n &gt;= 0; --n) {
1465         if (m_propertyVector.at(n).metadata().m_propertyID == id)
1466             return n;
1467     }
1468 
1469     return -1;
1470 }
1471 
1472 int ImmutableStyleProperties::findCustomPropertyIndex(const String&amp; propertyName) const
1473 {
1474     // Convert the propertyID into an uint16_t to compare it with the metadata&#39;s m_propertyID to avoid
1475     // the compiler converting it to an int multiple times in the loop.
1476     for (int n = m_arraySize - 1 ; n &gt;= 0; --n) {
1477         if (metadataArray()[n].m_propertyID == CSSPropertyCustom) {
1478             // We found a custom property. See if the name matches.
1479             auto* value = valueArray()[n].get();
1480             if (!value)
1481                 continue;
1482             if (downcast&lt;CSSCustomPropertyValue&gt;(*value).name() == propertyName)
1483                 return n;
1484         }
1485     }
1486 
1487     return -1;
1488 }
1489 
1490 int MutableStyleProperties::findCustomPropertyIndex(const String&amp; propertyName) const
1491 {
1492     // Convert the propertyID into an uint16_t to compare it with the metadata&#39;s m_propertyID to avoid
1493     // the compiler converting it to an int multiple times in the loop.
1494     for (int n = m_propertyVector.size() - 1 ; n &gt;= 0; --n) {
1495         if (m_propertyVector.at(n).metadata().m_propertyID == CSSPropertyCustom) {
1496             // We found a custom property. See if the name matches.
1497             if (!m_propertyVector.at(n).value())
1498                 continue;
1499             if (downcast&lt;CSSCustomPropertyValue&gt;(*m_propertyVector.at(n).value()).name() == propertyName)
1500                 return n;
1501         }
1502     }
1503 
1504     return -1;
1505 }
1506 
1507 CSSProperty* MutableStyleProperties::findCSSPropertyWithID(CSSPropertyID propertyID)
1508 {
1509     int foundPropertyIndex = findPropertyIndex(propertyID);
1510     if (foundPropertyIndex == -1)
1511         return 0;
1512     return &amp;m_propertyVector.at(foundPropertyIndex);
1513 }
1514 
1515 CSSProperty* MutableStyleProperties::findCustomCSSPropertyWithName(const String&amp; propertyName)
1516 {
1517     int foundPropertyIndex = findCustomPropertyIndex(propertyName);
1518     if (foundPropertyIndex == -1)
1519         return 0;
1520     return &amp;m_propertyVector.at(foundPropertyIndex);
1521 }
1522 
1523 bool StyleProperties::propertyMatches(CSSPropertyID propertyID, const CSSValue* propertyValue) const
1524 {
1525     int foundPropertyIndex = findPropertyIndex(propertyID);
1526     if (foundPropertyIndex == -1)
1527         return false;
1528     return propertyAt(foundPropertyIndex).value()-&gt;equals(*propertyValue);
1529 }
1530 
1531 Ref&lt;MutableStyleProperties&gt; StyleProperties::mutableCopy() const
1532 {
1533     return adoptRef(*new MutableStyleProperties(*this));
1534 }
1535 
1536 Ref&lt;MutableStyleProperties&gt; StyleProperties::copyPropertiesInSet(const CSSPropertyID* set, unsigned length) const
1537 {
1538     Vector&lt;CSSProperty&gt; list;
1539     list.reserveInitialCapacity(length);
1540     for (unsigned i = 0; i &lt; length; ++i) {
1541         if (auto value = getPropertyCSSValueInternal(set[i]))
1542             list.uncheckedAppend(CSSProperty(set[i], WTFMove(value), false));
1543     }
1544     return MutableStyleProperties::create(WTFMove(list));
1545 }
1546 
1547 PropertySetCSSStyleDeclaration* MutableStyleProperties::cssStyleDeclaration()
1548 {
1549     return m_cssomWrapper.get();
1550 }
1551 
1552 CSSStyleDeclaration&amp; MutableStyleProperties::ensureCSSStyleDeclaration()
1553 {
1554     if (m_cssomWrapper) {
1555         ASSERT(!static_cast&lt;CSSStyleDeclaration*&gt;(m_cssomWrapper.get())-&gt;parentRule());
1556         ASSERT(!m_cssomWrapper-&gt;parentElement());
1557         return *m_cssomWrapper;
1558     }
1559     m_cssomWrapper = makeUnique&lt;PropertySetCSSStyleDeclaration&gt;(*this);
1560     return *m_cssomWrapper;
1561 }
1562 
1563 CSSStyleDeclaration&amp; MutableStyleProperties::ensureInlineCSSStyleDeclaration(StyledElement&amp; parentElement)
1564 {
1565     if (m_cssomWrapper) {
1566         ASSERT(m_cssomWrapper-&gt;parentElement() == &amp;parentElement);
1567         return *m_cssomWrapper;
1568     }
1569     m_cssomWrapper = makeUnique&lt;InlineCSSStyleDeclaration&gt;(*this, parentElement);
1570     return *m_cssomWrapper;
1571 }
1572 
1573 unsigned StyleProperties::averageSizeInBytes()
1574 {
1575     // Please update this if the storage scheme changes so that this longer reflects the actual size.
1576     return sizeForImmutableStylePropertiesWithPropertyCount(4);
1577 }
1578 
1579 // See the function above if you need to update this.
1580 struct SameSizeAsStyleProperties : public RefCounted&lt;SameSizeAsStyleProperties&gt; {
1581     unsigned bitfield;
1582 };
1583 COMPILE_ASSERT(sizeof(StyleProperties) == sizeof(SameSizeAsStyleProperties), style_property_set_should_stay_small);
1584 
1585 #ifndef NDEBUG
1586 void StyleProperties::showStyle()
1587 {
1588     fprintf(stderr, &quot;%s\n&quot;, asText().ascii().data());
1589 }
1590 #endif
1591 
1592 Ref&lt;MutableStyleProperties&gt; MutableStyleProperties::create(CSSParserMode cssParserMode)
1593 {
1594     return adoptRef(*new MutableStyleProperties(cssParserMode));
1595 }
1596 
1597 Ref&lt;MutableStyleProperties&gt; MutableStyleProperties::create(Vector&lt;CSSProperty&gt;&amp;&amp; properties)
1598 {
1599     return adoptRef(*new MutableStyleProperties(WTFMove(properties)));
1600 }
1601 
1602 String StyleProperties::PropertyReference::cssName() const
1603 {
1604     if (id() == CSSPropertyCustom)
1605         return downcast&lt;CSSCustomPropertyValue&gt;(*value()).name();
1606     return getPropertyNameString(id());
1607 }
1608 
1609 String StyleProperties::PropertyReference::cssText() const
1610 {
1611     StringBuilder result;
1612     result.append(cssName());
1613     result.appendLiteral(&quot;: &quot;);
1614     result.append(m_value-&gt;cssText());
1615     if (isImportant())
1616         result.appendLiteral(&quot; !important&quot;);
1617     result.append(&#39;;&#39;);
1618     return result.toString();
1619 }
1620 
1621 Ref&lt;DeferredStyleProperties&gt; DeferredStyleProperties::create(const CSSParserTokenRange&amp; tokenRange, CSSDeferredParser&amp; parser)
1622 {
1623     return adoptRef(*new DeferredStyleProperties(tokenRange, parser));
1624 }
1625 
1626 DeferredStyleProperties::DeferredStyleProperties(const CSSParserTokenRange&amp; range, CSSDeferredParser&amp; parser)
1627     : StylePropertiesBase(parser.mode(), DeferredPropertiesType)
1628     , m_parser(parser)
1629 {
1630     size_t length = range.end() - range.begin();
1631     m_tokens.reserveCapacity(length);
1632     m_tokens.append(range.begin(), length);
1633 }
1634 
1635 DeferredStyleProperties::~DeferredStyleProperties() = default;
1636 
1637 Ref&lt;ImmutableStyleProperties&gt; DeferredStyleProperties::parseDeferredProperties()
1638 {
1639     return m_parser-&gt;parseDeclaration(m_tokens);
1640 }
1641 
1642 } // namespace WebCore
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>