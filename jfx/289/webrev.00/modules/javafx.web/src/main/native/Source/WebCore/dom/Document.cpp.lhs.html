<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/Document.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
   5  *           (C) 2006 Alexey Proskuryakov (ap@webkit.org)
   6  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   7  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   8  * Copyright (C) 2008, 2009, 2011, 2012 Google Inc. All rights reserved.
   9  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
  10  * Copyright (C) Research In Motion Limited 2010-2011. All rights reserved.
  11  *
  12  * This library is free software; you can redistribute it and/or
  13  * modify it under the terms of the GNU Library General Public
  14  * License as published by the Free Software Foundation; either
  15  * version 2 of the License, or (at your option) any later version.
  16  *
  17  * This library is distributed in the hope that it will be useful,
  18  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  19  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  20  * Library General Public License for more details.
  21  *
  22  * You should have received a copy of the GNU Library General Public License
  23  * along with this library; see the file COPYING.LIB.  If not, write to
  24  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  25  * Boston, MA 02110-1301, USA.
  26  */
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;Document.h&quot;
  30 
  31 #include &quot;AXObjectCache.h&quot;
  32 #include &quot;Attr.h&quot;
  33 #include &quot;BeforeUnloadEvent.h&quot;
  34 #include &quot;CDATASection.h&quot;
  35 #include &quot;CSSAnimationController.h&quot;
  36 #include &quot;CSSFontSelector.h&quot;
  37 #include &quot;CSSStyleDeclaration.h&quot;
  38 #include &quot;CSSStyleSheet.h&quot;
  39 #include &quot;CachedCSSStyleSheet.h&quot;
  40 #include &quot;CachedFrame.h&quot;
  41 #include &quot;CachedResourceLoader.h&quot;
  42 #include &quot;CanvasRenderingContext2D.h&quot;
  43 #include &quot;Chrome.h&quot;
  44 #include &quot;ChromeClient.h&quot;
  45 #include &quot;Comment.h&quot;
  46 #include &quot;CommonVM.h&quot;
  47 #include &quot;ComposedTreeIterator.h&quot;
  48 #include &quot;CompositionEvent.h&quot;
  49 #include &quot;ConstantPropertyMap.h&quot;
  50 #include &quot;ContentSecurityPolicy.h&quot;
  51 #include &quot;CookieJar.h&quot;
  52 #include &quot;CustomElementReactionQueue.h&quot;
  53 #include &quot;CustomElementRegistry.h&quot;
  54 #include &quot;CustomEvent.h&quot;
  55 #include &quot;CustomHeaderFields.h&quot;
  56 #include &quot;DOMImplementation.h&quot;
  57 #include &quot;DOMWindow.h&quot;
  58 #include &quot;DateComponents.h&quot;
  59 #include &quot;DebugPageOverlays.h&quot;
  60 #include &quot;DeprecatedGlobalSettings.h&quot;
  61 #include &quot;DocumentLoader.h&quot;
  62 #include &quot;DocumentMarkerController.h&quot;
  63 #include &quot;DocumentSharedObjectPool.h&quot;
  64 #include &quot;DocumentTimeline.h&quot;
  65 #include &quot;DocumentType.h&quot;
  66 #include &quot;DragEvent.h&quot;
  67 #include &quot;Editing.h&quot;
  68 #include &quot;Editor.h&quot;
  69 #include &quot;ElementIterator.h&quot;
  70 #include &quot;EventHandler.h&quot;
  71 #include &quot;ExtensionStyleSheets.h&quot;
  72 #include &quot;FocusController.h&quot;
  73 #include &quot;FocusEvent.h&quot;
  74 #include &quot;FontFaceSet.h&quot;
  75 #include &quot;FormController.h&quot;
  76 #include &quot;Frame.h&quot;
  77 #include &quot;FrameLoader.h&quot;
  78 #include &quot;FrameLoaderClient.h&quot;
  79 #include &quot;FrameView.h&quot;
  80 #include &quot;FullscreenManager.h&quot;
  81 #include &quot;GCReachableRef.h&quot;
  82 #include &quot;GenericCachedHTMLCollection.h&quot;
  83 #include &quot;HTMLAllCollection.h&quot;
  84 #include &quot;HTMLAnchorElement.h&quot;
  85 #include &quot;HTMLAttachmentElement.h&quot;
  86 #include &quot;HTMLBaseElement.h&quot;
  87 #include &quot;HTMLBodyElement.h&quot;
  88 #include &quot;HTMLCanvasElement.h&quot;
  89 #include &quot;HTMLDocument.h&quot;
  90 #include &quot;HTMLElementFactory.h&quot;
  91 #include &quot;HTMLFormControlElement.h&quot;
  92 #include &quot;HTMLFrameOwnerElement.h&quot;
  93 #include &quot;HTMLFrameSetElement.h&quot;
  94 #include &quot;HTMLHeadElement.h&quot;
  95 #include &quot;HTMLHtmlElement.h&quot;
  96 #include &quot;HTMLImageElement.h&quot;
  97 #include &quot;HTMLInputElement.h&quot;
  98 #include &quot;HTMLLinkElement.h&quot;
  99 #include &quot;HTMLMediaElement.h&quot;
 100 #include &quot;HTMLNameCollection.h&quot;
 101 #include &quot;HTMLParserIdioms.h&quot;
 102 #include &quot;HTMLPictureElement.h&quot;
 103 #include &quot;HTMLPlugInElement.h&quot;
 104 #include &quot;HTMLScriptElement.h&quot;
 105 #include &quot;HTMLStyleElement.h&quot;
 106 #include &quot;HTMLTitleElement.h&quot;
 107 #include &quot;HTMLUnknownElement.h&quot;
 108 #include &quot;HTTPHeaderNames.h&quot;
 109 #include &quot;HTTPParsers.h&quot;
 110 #include &quot;HashChangeEvent.h&quot;
 111 #include &quot;HighlightMap.h&quot;
 112 #include &quot;History.h&quot;
 113 #include &quot;HitTestResult.h&quot;
 114 #include &quot;IdleCallbackController.h&quot;
 115 #include &quot;ImageBitmapRenderingContext.h&quot;
 116 #include &quot;ImageLoader.h&quot;
 117 #include &quot;InspectorInstrumentation.h&quot;
 118 #include &quot;IntersectionObserver.h&quot;
 119 #include &quot;JSCustomElementInterface.h&quot;
 120 #include &quot;JSLazyEventListener.h&quot;
 121 #include &quot;KeyboardEvent.h&quot;
 122 #include &quot;KeyframeEffect.h&quot;
 123 #include &quot;LayoutDisallowedScope.h&quot;
 124 #include &quot;LegacySchemeRegistry.h&quot;
 125 #include &quot;LibWebRTCProvider.h&quot;
 126 #include &quot;LoaderStrategy.h&quot;
 127 #include &quot;Logging.h&quot;
 128 #include &quot;MediaCanStartListener.h&quot;
 129 #include &quot;MediaProducer.h&quot;
 130 #include &quot;MediaQueryList.h&quot;
 131 #include &quot;MediaQueryMatcher.h&quot;
 132 #include &quot;MediaStream.h&quot;
 133 #include &quot;MessageEvent.h&quot;
 134 #include &quot;MouseEventWithHitTestResults.h&quot;
 135 #include &quot;MutationEvent.h&quot;
 136 #include &quot;NameNodeList.h&quot;
 137 #include &quot;NavigationDisabler.h&quot;
 138 #include &quot;NavigationScheduler.h&quot;
 139 #include &quot;NestingLevelIncrementer.h&quot;
 140 #include &quot;NodeIterator.h&quot;
 141 #include &quot;NodeRareData.h&quot;
 142 #include &quot;NodeWithIndex.h&quot;
 143 #include &quot;OverflowEvent.h&quot;
 144 #include &quot;PageConsoleClient.h&quot;
 145 #include &quot;PageGroup.h&quot;
 146 #include &quot;PageTransitionEvent.h&quot;
 147 #include &quot;PaintWorkletGlobalScope.h&quot;
 148 #include &quot;PlatformLocale.h&quot;
 149 #include &quot;PlatformMediaSessionManager.h&quot;
 150 #include &quot;PlatformScreen.h&quot;
 151 #include &quot;PlatformStrategies.h&quot;
 152 #include &quot;PlugInsResources.h&quot;
 153 #include &quot;PluginDocument.h&quot;
 154 #include &quot;PointerLockController.h&quot;
 155 #include &quot;PolicyChecker.h&quot;
 156 #include &quot;PopStateEvent.h&quot;
 157 #include &quot;ProcessingInstruction.h&quot;
 158 #include &quot;PublicSuffix.h&quot;
 159 #include &quot;Quirks.h&quot;
 160 #include &quot;RealtimeMediaSourceCenter.h&quot;
 161 #include &quot;RenderChildIterator.h&quot;
 162 #include &quot;RenderInline.h&quot;
 163 #include &quot;RenderLayerCompositor.h&quot;
 164 #include &quot;RenderLineBreak.h&quot;
 165 #include &quot;RenderTreeUpdater.h&quot;
 166 #include &quot;RenderView.h&quot;
 167 #include &quot;RenderWidget.h&quot;
 168 #include &quot;RequestAnimationFrameCallback.h&quot;
 169 #include &quot;ResizeObserver.h&quot;
 170 #include &quot;ResourceLoadObserver.h&quot;
 171 #include &quot;RuntimeApplicationChecks.h&quot;
 172 #include &quot;RuntimeEnabledFeatures.h&quot;
 173 #include &quot;SVGDocumentExtensions.h&quot;
 174 #include &quot;SVGElement.h&quot;
 175 #include &quot;SVGElementFactory.h&quot;
 176 #include &quot;SVGNames.h&quot;
 177 #include &quot;SVGSVGElement.h&quot;
 178 #include &quot;SVGTitleElement.h&quot;
 179 #include &quot;SVGUseElement.h&quot;
 180 #include &quot;SVGZoomEvent.h&quot;
 181 #include &quot;SWClientConnection.h&quot;
 182 #include &quot;ScopedEventQueue.h&quot;
 183 #include &quot;ScriptController.h&quot;
 184 #include &quot;ScriptDisallowedScope.h&quot;
 185 #include &quot;ScriptModuleLoader.h&quot;
 186 #include &quot;ScriptRunner.h&quot;
 187 #include &quot;ScriptSourceCode.h&quot;
 188 #include &quot;ScriptState.h&quot;
 189 #include &quot;ScriptedAnimationController.h&quot;
 190 #include &quot;ScrollbarTheme.h&quot;
 191 #include &quot;ScrollingCoordinator.h&quot;
 192 #include &quot;SecurityOrigin.h&quot;
 193 #include &quot;SecurityOriginData.h&quot;
 194 #include &quot;SecurityOriginPolicy.h&quot;
 195 #include &quot;SecurityPolicy.h&quot;
 196 #include &quot;SegmentedString.h&quot;
 197 #include &quot;SelectorQuery.h&quot;
 198 #include &quot;ServiceWorkerClientData.h&quot;
 199 #include &quot;ServiceWorkerContainer.h&quot;
 200 #include &quot;ServiceWorkerProvider.h&quot;
 201 #include &quot;Settings.h&quot;
 202 #include &quot;ShadowRoot.h&quot;
 203 #include &quot;SocketProvider.h&quot;
 204 #include &quot;StorageEvent.h&quot;
 205 #include &quot;StringCallback.h&quot;
 206 #include &quot;StyleColor.h&quot;
 207 #include &quot;StyleProperties.h&quot;
 208 #include &quot;StyleResolveForDocument.h&quot;
 209 #include &quot;StyleResolver.h&quot;
 210 #include &quot;StyleScope.h&quot;
 211 #include &quot;StyleSheetContents.h&quot;
 212 #include &quot;StyleSheetList.h&quot;
 213 #include &quot;StyleTreeResolver.h&quot;
 214 #include &quot;SubresourceLoader.h&quot;
 215 #include &quot;TextAutoSizing.h&quot;
 216 #include &quot;TextEvent.h&quot;
 217 #include &quot;TextManipulationController.h&quot;
 218 #include &quot;TextNodeTraversal.h&quot;
 219 #include &quot;TouchAction.h&quot;
 220 #include &quot;TransformSource.h&quot;
 221 #include &quot;TreeWalker.h&quot;
 222 #include &quot;UndoManager.h&quot;
 223 #include &quot;UserGestureIndicator.h&quot;
 224 #include &quot;ValidationMessageClient.h&quot;
 225 #include &quot;VisibilityChangeClient.h&quot;
 226 #include &quot;VisitedLinkState.h&quot;
 227 #include &quot;VisualViewport.h&quot;
 228 #include &quot;WebAnimation.h&quot;
 229 #include &quot;WheelEvent.h&quot;
 230 #include &quot;WindowEventLoop.h&quot;
 231 #include &quot;WindowFeatures.h&quot;
 232 #include &quot;Worklet.h&quot;
 233 #include &quot;XMLDocument.h&quot;
 234 #include &quot;XMLDocumentParser.h&quot;
 235 #include &quot;XMLNSNames.h&quot;
 236 #include &quot;XMLNames.h&quot;
 237 #include &quot;XPathEvaluator.h&quot;
 238 #include &quot;XPathExpression.h&quot;
 239 #include &quot;XPathNSResolver.h&quot;
 240 #include &quot;XPathResult.h&quot;
 241 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
 242 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 243 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 244 #include &lt;JavaScriptCore/VM.h&gt;
 245 #include &lt;ctime&gt;
 246 #include &lt;wtf/IsoMallocInlines.h&gt;
 247 #include &lt;wtf/Language.h&gt;
 248 #include &lt;wtf/NeverDestroyed.h&gt;
 249 #include &lt;wtf/SetForScope.h&gt;
 250 #include &lt;wtf/SystemTracing.h&gt;
 251 #include &lt;wtf/UUID.h&gt;
 252 #include &lt;wtf/text/StringBuffer.h&gt;
 253 #include &lt;wtf/text/TextStream.h&gt;
 254 
 255 #if PLATFORM(JAVA)
 256 #include &lt;wtf/unicode/java/UnicodeJava.h&gt;
 257 #endif
 258 
 259 #if ENABLE(DEVICE_ORIENTATION)
 260 #include &quot;DeviceMotionEvent.h&quot;
 261 #include &quot;DeviceOrientationAndMotionAccessController.h&quot;
 262 #include &quot;DeviceOrientationEvent.h&quot;
 263 #endif
 264 
 265 #if ENABLE(FULLSCREEN_API)
 266 #include &quot;RenderFullScreen.h&quot;
 267 #endif
 268 
 269 #if ENABLE(INDEXED_DATABASE)
 270 #include &quot;IDBConnectionProxy.h&quot;
 271 #include &quot;IDBOpenDBRequest.h&quot;
 272 #endif
 273 
 274 #if PLATFORM(IOS_FAMILY)
 275 #include &quot;ContentChangeObserver.h&quot;
 276 #include &quot;CSSFontSelector.h&quot;
 277 #include &quot;DOMTimerHoldingTank.h&quot;
 278 #include &quot;DeviceMotionClientIOS.h&quot;
 279 #include &quot;DeviceMotionController.h&quot;
 280 #include &quot;DeviceOrientationClientIOS.h&quot;
 281 #include &quot;DeviceOrientationController.h&quot;
 282 #include &quot;Geolocation.h&quot;
 283 #include &quot;Navigator.h&quot;
 284 #include &quot;NavigatorGeolocation.h&quot;
 285 #endif
 286 
 287 #if ENABLE(IOS_GESTURE_EVENTS)
 288 #include &quot;GestureEvent.h&quot;
 289 #endif
 290 
 291 #if ENABLE(MATHML)
 292 #include &quot;MathMLElement.h&quot;
 293 #include &quot;MathMLElementFactory.h&quot;
 294 #include &quot;MathMLNames.h&quot;
 295 #endif
 296 
 297 #if ENABLE(MEDIA_SESSION)
 298 #include &quot;MediaSession.h&quot;
 299 #endif
 300 
 301 #if USE(QUICK_LOOK)
 302 #include &quot;QuickLook.h&quot;
 303 #endif
 304 
 305 #if ENABLE(TOUCH_EVENTS)
 306 #include &quot;TouchEvent.h&quot;
 307 #endif
 308 
 309 #if ENABLE(VIDEO_TRACK)
 310 #include &quot;CaptionUserPreferences.h&quot;
 311 #endif
 312 
 313 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 314 #include &quot;MediaPlaybackTargetClient.h&quot;
 315 #endif
 316 
 317 #if ENABLE(XSLT)
 318 #include &quot;XSLTProcessor.h&quot;
 319 #endif
 320 
 321 #if ENABLE(WEBGL)
 322 #include &quot;WebGLRenderingContext.h&quot;
 323 #endif
 324 #if ENABLE(WEBGL2)
 325 #include &quot;WebGL2RenderingContext.h&quot;
 326 #endif
 327 #if ENABLE(WEBGPU)
 328 #include &quot;GPUCanvasContext.h&quot;
 329 #endif
 330 
 331 #if ENABLE(POINTER_EVENTS)
 332 #include &quot;PointerCaptureController.h&quot;
 333 #endif
 334 
 335 #if ENABLE(PICTURE_IN_PICTURE_API)
 336 #include &quot;HTMLVideoElement.h&quot;
 337 #endif
 338 
 339 namespace WebCore {
 340 
 341 WTF_MAKE_ISO_ALLOCATED_IMPL(Document);
 342 
 343 using namespace HTMLNames;
 344 using namespace PAL;
 345 using namespace WTF::Unicode;
 346 
 347 static const unsigned cMaxWriteRecursionDepth = 21;
 348 bool Document::hasEverCreatedAnAXObjectCache = false;
 349 static const Seconds maxIntervalForUserGestureForwardingAfterMediaFinishesPlaying { 1_s };
 350 
 351 struct FrameFlatteningLayoutDisallower {
 352     FrameFlatteningLayoutDisallower(FrameView&amp; frameView)
 353         : m_frameView(frameView)
 354         , m_disallowLayout(frameView.effectiveFrameFlattening() != FrameFlattening::Disabled)
 355     {
 356         if (m_disallowLayout)
 357             m_frameView.startDisallowingLayout();
 358     }
 359 
 360     ~FrameFlatteningLayoutDisallower()
 361     {
 362         if (m_disallowLayout)
 363             m_frameView.endDisallowingLayout();
 364     }
 365 
 366 private:
 367     FrameView&amp; m_frameView;
 368     bool m_disallowLayout { false };
 369 };
 370 
 371 // Defined here to avoid including GCReachableRef.h in Document.h
 372 struct Document::PendingScrollEventTargetList {
 373     WTF_MAKE_FAST_ALLOCATED;
 374 
 375 public:
 376     Vector&lt;GCReachableRef&lt;ContainerNode&gt;&gt; targets;
 377 };
 378 
 379 #if ENABLE(INTERSECTION_OBSERVER)
 380 static const Seconds intersectionObserversInitialUpdateDelay { 2000_ms };
 381 #endif
 382 
 383 // DOM Level 2 says (letters added):
 384 //
 385 // a) Name start characters must have one of the categories Ll, Lu, Lo, Lt, Nl.
 386 // b) Name characters other than Name-start characters must have one of the categories Mc, Me, Mn, Lm, or Nd.
 387 // c) Characters in the compatibility area (i.e. with character code greater than #xF900 and less than #xFFFE) are not allowed in XML names.
 388 // d) Characters which have a font or compatibility decomposition (i.e. those with a &quot;compatibility formatting tag&quot; in field 5 of the database -- marked by field 5 beginning with a &quot;&lt;&quot;) are not allowed.
 389 // e) The following characters are treated as name-start characters rather than name characters, because the property file classifies them as Alphabetic: [#x02BB-#x02C1], #x0559, #x06E5, #x06E6.
 390 // f) Characters #x20DD-#x20E0 are excluded (in accordance with Unicode, section 5.14).
 391 // g) Character #x00B7 is classified as an extender, because the property list so identifies it.
 392 // h) Character #x0387 is added as a name character, because #x00B7 is its canonical equivalent.
 393 // i) Characters &#39;:&#39; and &#39;_&#39; are allowed as name-start characters.
 394 // j) Characters &#39;-&#39; and &#39;.&#39; are allowed as name characters.
 395 //
 396 // It also contains complete tables. If we decide it&#39;s better, we could include those instead of the following code.
 397 
 398 static inline bool isValidNameStart(UChar32 c)
 399 {
 400     // rule (e) above
 401     if ((c &gt;= 0x02BB &amp;&amp; c &lt;= 0x02C1) || c == 0x559 || c == 0x6E5 || c == 0x6E6)
 402         return true;
 403 
 404     // rule (i) above
 405     if (c == &#39;:&#39; || c == &#39;_&#39;)
 406         return true;
 407 
 408     // rules (a) and (f) above
 409     if (!(U_GET_GC_MASK(c) &amp; (U_GC_LL_MASK | U_GC_LU_MASK | U_GC_LO_MASK | U_GC_LT_MASK | U_GC_NL_MASK)))
 410         return false;
 411 
 412     // rule (c) above
 413     if (c &gt;= 0xF900 &amp;&amp; c &lt; 0xFFFE)
 414         return false;
 415 
 416     // rule (d) above
 417 #if PLATFORM(JAVA) // todo tav old code not using icu
 418     DecompositionType decompType = decompositionType(c);
 419     if (decompType == DecompositionFont || decompType == DecompositionCompat)
 420         return false;
 421 #else
 422     int type = u_getIntPropertyValue(c, UCHAR_DECOMPOSITION_TYPE);
 423     if (type == U_DT_FONT || type == U_DT_COMPAT)
 424         return false;
 425 #endif
 426 
 427     return true;
 428 }
 429 
 430 static inline bool isValidNamePart(UChar32 c)
 431 {
 432     // rules (a), (e), and (i) above
 433     if (isValidNameStart(c))
 434         return true;
 435 
 436     // rules (g) and (h) above
 437     if (c == 0x00B7 || c == 0x0387)
 438         return true;
 439 
 440     // rule (j) above
 441     if (c == &#39;-&#39; || c == &#39;.&#39;)
 442         return true;
 443 
 444     // rules (b) and (f) above
 445     if (!(U_GET_GC_MASK(c) &amp; (U_GC_M_MASK | U_GC_LM_MASK | U_GC_ND_MASK)))
 446         return false;
 447 
 448     // rule (c) above
 449     if (c &gt;= 0xF900 &amp;&amp; c &lt; 0xFFFE)
 450         return false;
 451 
 452     // rule (d) above
 453 #if PLATFORM(JAVA) // todo tav old code not using icu
 454     DecompositionType decompType = decompositionType(c);
 455     if (decompType == DecompositionFont || decompType == DecompositionCompat)
 456         return false;
 457 #else
 458     int type = u_getIntPropertyValue(c, UCHAR_DECOMPOSITION_TYPE);
 459     if (type == U_DT_FONT || type == U_DT_COMPAT)
 460         return false;
 461 #endif
 462 
 463     return true;
 464 }
 465 
 466 static Widget* widgetForElement(Element* focusedElement)
 467 {
 468     if (!focusedElement)
 469         return nullptr;
 470     auto* renderer = focusedElement-&gt;renderer();
 471     if (!is&lt;RenderWidget&gt;(renderer))
 472         return nullptr;
 473     return downcast&lt;RenderWidget&gt;(*renderer).widget();
 474 }
 475 
 476 static bool acceptsEditingFocus(const Element&amp; element)
 477 {
 478     ASSERT(element.hasEditableStyle());
 479 
 480     auto* root = element.rootEditableElement();
 481     Frame* frame = element.document().frame();
 482     if (!frame || !root)
 483         return false;
 484 
 485     return frame-&gt;editor().shouldBeginEditing(rangeOfContents(*root).ptr());
 486 }
 487 
 488 static bool canAccessAncestor(const SecurityOrigin&amp; activeSecurityOrigin, Frame* targetFrame)
 489 {
 490     // targetFrame can be 0 when we&#39;re trying to navigate a top-level frame
 491     // that has a 0 opener.
 492     if (!targetFrame)
 493         return false;
 494 
 495     const bool isLocalActiveOrigin = activeSecurityOrigin.isLocal();
 496     for (Frame* ancestorFrame = targetFrame; ancestorFrame; ancestorFrame = ancestorFrame-&gt;tree().parent()) {
 497         Document* ancestorDocument = ancestorFrame-&gt;document();
 498         // FIXME: Should be an ASSERT? Frames should alway have documents.
 499         if (!ancestorDocument)
 500             return true;
 501 
 502         const SecurityOrigin&amp; ancestorSecurityOrigin = ancestorDocument-&gt;securityOrigin();
 503         if (activeSecurityOrigin.canAccess(ancestorSecurityOrigin))
 504             return true;
 505 
 506         // Allow file URL descendant navigation even when allowFileAccessFromFileURLs is false.
 507         // FIXME: It&#39;s a bit strange to special-case local origins here. Should we be doing
 508         // something more general instead?
 509         if (isLocalActiveOrigin &amp;&amp; ancestorSecurityOrigin.isLocal())
 510             return true;
 511     }
 512 
 513     return false;
 514 }
 515 
 516 static void printNavigationErrorMessage(Frame&amp; frame, const URL&amp; activeURL, const char* reason)
 517 {
 518     String message = &quot;Unsafe JavaScript attempt to initiate navigation for frame with URL &#39;&quot; + frame.document()-&gt;url().string() + &quot;&#39; from frame with URL &#39;&quot; + activeURL.string() + &quot;&#39;. &quot; + reason + &quot;\n&quot;;
 519 
 520     // FIXME: should we print to the console of the document performing the navigation instead?
 521     frame.document()-&gt;domWindow()-&gt;printErrorMessage(message);
 522 }
 523 
 524 uint64_t Document::s_globalTreeVersion = 0;
 525 
 526 auto Document::allDocumentsMap() -&gt; DocumentsMap&amp;
 527 {
 528     static NeverDestroyed&lt;DocumentsMap&gt; documents;
 529     return documents;
 530 }
 531 
 532 auto Document::allDocuments() -&gt; DocumentsMap::ValuesIteratorRange
 533 {
 534     return allDocumentsMap().values();
 535 }
 536 
 537 static inline int currentOrientation(Frame* frame)
 538 {
 539 #if ENABLE(ORIENTATION_EVENTS)
 540     if (frame)
 541         return frame-&gt;orientation();
 542 #else
 543     UNUSED_PARAM(frame);
 544 #endif
 545     return 0;
 546 }
 547 
 548 Document::Document(Frame* frame, const URL&amp; url, unsigned documentClasses, unsigned constructionFlags)
 549     : ContainerNode(*this, CreateDocument)
 550     , TreeScope(*this)
 551     , FrameDestructionObserver(frame)
 552 #if ENABLE(IOS_TOUCH_EVENTS)
 553     , m_touchEventsChangedTimer(*this, &amp;Document::touchEventsChangedTimerFired)
 554 #endif
 555     , m_settings(frame ? Ref&lt;Settings&gt;(frame-&gt;settings()) : Settings::create(nullptr))
 556     , m_quirks(makeUniqueRef&lt;Quirks&gt;(*this))
 557     , m_cachedResourceLoader(m_frame ? Ref&lt;CachedResourceLoader&gt;(m_frame-&gt;loader().activeDocumentLoader()-&gt;cachedResourceLoader()) : CachedResourceLoader::create(nullptr))
 558     , m_domTreeVersion(++s_globalTreeVersion)
 559     , m_styleScope(makeUnique&lt;Style::Scope&gt;(*this))
 560     , m_extensionStyleSheets(makeUnique&lt;ExtensionStyleSheets&gt;(*this))
 561     , m_visitedLinkState(makeUnique&lt;VisitedLinkState&gt;(*this))
 562     , m_markers(makeUnique&lt;DocumentMarkerController&gt;(*this))
 563     , m_styleRecalcTimer([this] { updateStyleIfNeeded(); })
 564     , m_documentCreationTime(MonotonicTime::now())
 565     , m_scriptRunner(makeUnique&lt;ScriptRunner&gt;(*this))
 566     , m_moduleLoader(makeUnique&lt;ScriptModuleLoader&gt;(*this))
 567 #if ENABLE(XSLT)
 568     , m_applyPendingXSLTransformsTimer(*this, &amp;Document::applyPendingXSLTransformsTimerFired)
 569 #endif
 570     , m_xmlVersion(&quot;1.0&quot;_s)
 571     , m_constantPropertyMap(makeUnique&lt;ConstantPropertyMap&gt;(*this))
 572     , m_documentClasses(documentClasses)
 573 #if ENABLE(FULLSCREEN_API)
 574     , m_fullscreenManager { makeUniqueRef&lt;FullscreenManager&gt;(*this) }
 575 #endif
 576 #if ENABLE(INTERSECTION_OBSERVER)
 577     , m_intersectionObserversNotifyTimer(*this, &amp;Document::notifyIntersectionObserversTimerFired)
 578     , m_intersectionObserversInitialUpdateTimer(*this, &amp;Document::scheduleTimedRenderingUpdate)
 579 #endif
 580     , m_loadEventDelayTimer(*this, &amp;Document::loadEventDelayTimerFired)
 581 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(DEVICE_ORIENTATION)
 582     , m_deviceMotionClient(makeUnique&lt;DeviceMotionClientIOS&gt;(page() ? page()-&gt;deviceOrientationUpdateProvider() : nullptr))
 583     , m_deviceMotionController(makeUnique&lt;DeviceMotionController&gt;(*m_deviceMotionClient))
 584     , m_deviceOrientationClient(makeUnique&lt;DeviceOrientationClientIOS&gt;(page() ? page()-&gt;deviceOrientationUpdateProvider() : nullptr))
 585     , m_deviceOrientationController(makeUnique&lt;DeviceOrientationController&gt;(*m_deviceOrientationClient))
 586 #endif
 587     , m_pendingTasksTimer(*this, &amp;Document::pendingTasksTimerFired)
 588     , m_visualUpdatesSuppressionTimer(*this, &amp;Document::visualUpdatesSuppressionTimerFired)
 589     , m_sharedObjectPoolClearTimer(*this, &amp;Document::clearSharedObjectPool)
 590     , m_fontSelector(CSSFontSelector::create(*this))
 591     , m_didAssociateFormControlsTimer(*this, &amp;Document::didAssociateFormControlsTimerFired)
 592     , m_cookieCacheExpiryTimer(*this, &amp;Document::invalidateDOMCookieCache)
 593     , m_socketProvider(page() ? &amp;page()-&gt;socketProvider() : nullptr)
 594     , m_isSynthesized(constructionFlags &amp; Synthesized)
 595     , m_isNonRenderedPlaceholder(constructionFlags &amp; NonRenderedPlaceholder)
 596     , m_orientationNotifier(currentOrientation(frame))
 597     , m_identifier(DocumentIdentifier::generate())
 598     , m_undoManager(UndoManager::create(*this))
 599 {
 600     auto addResult = allDocumentsMap().add(m_identifier, this);
 601     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 602 
 603     // We depend on the url getting immediately set in subframes, but we
 604     // also depend on the url NOT getting immediately set in opened windows.
 605     // See fast/dom/early-frame-url.html
 606     // and fast/dom/location-new-window-no-crash.html, respectively.
 607     // FIXME: Can/should we unify this behavior?
 608     if ((frame &amp;&amp; frame-&gt;ownerElement()) || !url.isEmpty())
 609         setURL(url);
 610 
 611     m_cachedResourceLoader-&gt;setDocument(this);
 612 
 613     resetLinkColor();
 614     resetVisitedLinkColor();
 615     resetActiveLinkColor();
 616 
 617     initSecurityContext();
 618     initDNSPrefetch();
 619 
 620     m_fontSelector-&gt;registerForInvalidationCallbacks(*this);
 621 
 622     for (auto&amp; nodeListAndCollectionCount : m_nodeListAndCollectionCounts)
 623         nodeListAndCollectionCount = 0;
 624 
 625     InspectorInstrumentation::addEventListenersToNode(*this);
 626 #if ENABLE(MEDIA_STREAM)
 627     m_settings-&gt;setLegacyGetUserMediaEnabled(quirks().shouldEnableLegacyGetUserMedia());
 628 #endif
 629 }
 630 
 631 Ref&lt;Document&gt; Document::create(Document&amp; contextDocument)
 632 {
 633     auto document = adoptRef(*new Document(nullptr, URL()));
 634     document-&gt;setContextDocument(contextDocument);
 635     document-&gt;setSecurityOriginPolicy(contextDocument.securityOriginPolicy());
 636     return document;
 637 }
 638 
 639 Ref&lt;Document&gt; Document::createNonRenderedPlaceholder(Frame&amp; frame, const URL&amp; url)
 640 {
 641     return adoptRef(*new Document(&amp;frame, url, DefaultDocumentClass, NonRenderedPlaceholder));
 642 }
 643 
 644 Document::~Document()
 645 {
 646     ASSERT(activeDOMObjectsAreStopped());
 647 
 648     if (m_logger)
 649         m_logger-&gt;removeObserver(*this);
 650 
 651     ASSERT(allDocumentsMap().contains(m_identifier));
 652     allDocumentsMap().remove(m_identifier);
 653     // We need to remove from the contexts map very early in the destructor so that calling postTask() on this Document from another thread is safe.
 654     removeFromContextsMap();
 655 
 656     ASSERT(!renderView());
 657     ASSERT(m_backForwardCacheState != InBackForwardCache);
 658     ASSERT(m_ranges.isEmpty());
 659     ASSERT(!m_parentTreeScope);
 660     ASSERT(!m_disabledFieldsetElementsCount);
 661     ASSERT(m_inDocumentShadowRoots.isEmpty());
 662 
 663 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
 664     m_deviceMotionClient-&gt;deviceMotionControllerDestroyed();
 665     m_deviceOrientationClient-&gt;deviceOrientationControllerDestroyed();
 666 #endif
 667 
 668     if (m_templateDocument)
 669         m_templateDocument-&gt;setTemplateDocumentHost(nullptr); // balanced in templateDocument().
 670 
 671     // FIXME: Should we reset m_domWindow when we detach from the Frame?
 672     if (m_domWindow)
 673         m_domWindow-&gt;resetUnlessSuspendedForDocumentSuspension();
 674 
 675     m_scriptRunner = nullptr;
 676     m_moduleLoader = nullptr;
 677 
 678     removeAllEventListeners();
 679 
 680     // Currently we believe that Document can never outlive the parser.
 681     // Although the Document may be replaced synchronously, DocumentParsers
 682     // generally keep at least one reference to an Element which would in turn
 683     // has a reference to the Document.  If you hit this ASSERT, then that
 684     // assumption is wrong.  DocumentParser::detach() should ensure that even
 685     // if the DocumentParser outlives the Document it won&#39;t cause badness.
 686     ASSERT(!m_parser || m_parser-&gt;refCount() == 1);
 687     detachParser();
 688 
 689     if (this == &amp;topDocument())
 690         clearAXObjectCache();
 691 
 692     m_decoder = nullptr;
 693 
 694     if (m_styleSheetList)
 695         m_styleSheetList-&gt;detach();
 696 
 697     extensionStyleSheets().detachFromDocument();
 698 
 699     styleScope().clearResolver(); // We need to destroy CSSFontSelector before destroying m_cachedResourceLoader.
 700     m_fontSelector-&gt;clearDocument();
 701     m_fontSelector-&gt;unregisterForInvalidationCallbacks(*this);
 702 
 703     // It&#39;s possible for multiple Documents to end up referencing the same CachedResourceLoader (e.g., SVGImages
 704     // load the initial empty document and the SVGDocument with the same DocumentLoader).
 705     if (m_cachedResourceLoader-&gt;document() == this)
 706         m_cachedResourceLoader-&gt;setDocument(nullptr);
 707 
 708 #if ENABLE(VIDEO)
 709     stopAllMediaPlayback();
 710 #endif
 711 
 712     // We must call clearRareData() here since a Document class inherits TreeScope
 713     // as well as Node. See a comment on TreeScope.h for the reason.
 714     if (hasRareData())
 715         clearRareData();
 716 
 717     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(m_listsInvalidatedAtDocument.isEmpty());
 718     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(m_collectionsInvalidatedAtDocument.isEmpty());
 719     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(m_svgUseElements.isEmpty());
 720 
 721     for (unsigned count : m_nodeListAndCollectionCounts)
 722         ASSERT_UNUSED(count, !count);
 723 }
 724 
 725 void Document::removedLastRef()
 726 {
 727     ASSERT(!m_deletionHasBegun);
 728     if (m_referencingNodeCount) {
 729         // Node::removedLastRef doesn&#39;t set refCount() to zero because it&#39;s not observable.
 730         // But we need to remember that our refCount reached zero in subsequent calls to decrementReferencingNodeCount().
 731         m_refCountAndParentBit = 0;
 732 
 733         // If removing a child removes the last node reference, we don&#39;t want the scope to be destroyed
 734         // until after removeDetachedChildren returns, so we protect ourselves.
 735         incrementReferencingNodeCount();
 736 
 737         RELEASE_ASSERT(!hasLivingRenderTree());
 738         // We must make sure not to be retaining any of our children through
 739         // these extra pointers or we will create a reference cycle.
 740         m_focusedElement = nullptr;
 741         m_hoveredElement = nullptr;
 742         m_activeElement = nullptr;
 743         m_titleElement = nullptr;
 744         m_documentElement = nullptr;
 745         m_focusNavigationStartingNode = nullptr;
 746         m_userActionElements.clear();
 747 #if ENABLE(FULLSCREEN_API)
 748         m_fullscreenManager-&gt;clear();
 749 #endif
 750         m_associatedFormControls.clear();
 751 
 752         m_fontSelector-&gt;clearDocument();
 753         m_fontSelector-&gt;unregisterForInvalidationCallbacks(*this);
 754 
 755         detachParser();
 756 
 757         // removeDetachedChildren() doesn&#39;t always unregister IDs,
 758         // so tear down scope information up front to avoid having
 759         // stale references in the map.
 760 
 761         destroyTreeScopeData();
 762         removeDetachedChildren();
 763         m_formController = nullptr;
 764 
 765         m_markers-&gt;detach();
 766 
 767         m_cssCanvasElements.clear();
 768 
 769         commonTeardown();
 770 
 771 #ifndef NDEBUG
 772         // We need to do this right now since selfOnlyDeref() can delete this.
 773         m_inRemovedLastRefFunction = false;
 774 #endif
 775         decrementReferencingNodeCount();
 776     } else {
 777         stopActiveDOMObjects();
 778 #ifndef NDEBUG
 779         m_inRemovedLastRefFunction = false;
 780         m_deletionHasBegun = true;
 781 #endif
 782         delete this;
 783     }
 784 }
 785 
 786 void Document::commonTeardown()
 787 {
 788     stopActiveDOMObjects();
 789 
 790 #if ENABLE(FULLSCREEN_API)
 791     m_fullscreenManager-&gt;emptyEventQueue();
 792 #endif
 793 
 794     if (svgExtensions())
 795         accessSVGExtensions().pauseAnimations();
 796 
 797     clearScriptedAnimationController();
 798 
 799     if (m_highlightMap)
 800         m_highlightMap-&gt;clear();
 801 
 802     m_pendingScrollEventTargetList = nullptr;
 803 }
 804 
 805 Element* Document::elementForAccessKey(const String&amp; key)
 806 {
 807     if (key.isEmpty())
 808         return nullptr;
 809     if (!m_accessKeyCache)
 810         buildAccessKeyCache();
 811     return m_accessKeyCache-&gt;get(key);
 812 }
 813 
 814 void Document::buildAccessKeyCache()
 815 {
 816     m_accessKeyCache = makeUnique&lt;HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt;&gt;([this] {
 817         HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt; map;
 818         for (auto&amp; node : composedTreeDescendants(*this)) {
 819             if (!is&lt;Element&gt;(node))
 820                 continue;
 821             auto&amp; element = downcast&lt;Element&gt;(node);
 822             auto&amp; key = element.attributeWithoutSynchronization(accesskeyAttr);
 823             if (key.isEmpty())
 824                 continue;
 825             map.add(key, &amp;element);
 826         }
 827         return map;
 828     }());
 829 }
 830 
 831 void Document::invalidateAccessKeyCacheSlowCase()
 832 {
 833     m_accessKeyCache = nullptr;
 834 }
 835 
 836 ExceptionOr&lt;SelectorQuery&amp;&gt; Document::selectorQueryForString(const String&amp; selectorString)
 837 {
 838     if (selectorString.isEmpty())
 839         return Exception { SyntaxError };
 840     if (!m_selectorQueryCache)
 841         m_selectorQueryCache = makeUnique&lt;SelectorQueryCache&gt;();
 842     return m_selectorQueryCache-&gt;add(selectorString, *this);
 843 }
 844 
 845 void Document::clearSelectorQueryCache()
 846 {
 847     m_selectorQueryCache = nullptr;
 848 }
 849 
 850 void Document::setReferrerPolicy(ReferrerPolicy referrerPolicy)
 851 {
 852     // Do not override existing referrer policy with the &quot;empty string&quot; one as the &quot;empty string&quot; means we should use
 853     // the policy defined elsewhere.
 854     if (m_referrerPolicy &amp;&amp; referrerPolicy == ReferrerPolicy::EmptyString)
 855         return;
 856 
 857     m_referrerPolicy = referrerPolicy;
 858 }
 859 
 860 MediaQueryMatcher&amp; Document::mediaQueryMatcher()
 861 {
 862     if (!m_mediaQueryMatcher)
 863         m_mediaQueryMatcher = MediaQueryMatcher::create(*this);
 864     return *m_mediaQueryMatcher;
 865 }
 866 
 867 void Document::setCompatibilityMode(DocumentCompatibilityMode mode)
 868 {
 869     if (m_compatibilityModeLocked || mode == m_compatibilityMode)
 870         return;
 871     bool wasInQuirksMode = inQuirksMode();
 872     m_compatibilityMode = mode;
 873 
 874     clearSelectorQueryCache();
 875 
 876     if (inQuirksMode() != wasInQuirksMode) {
 877         // All user stylesheets have to reparse using the different mode.
 878         extensionStyleSheets().clearPageUserSheet();
 879         extensionStyleSheets().invalidateInjectedStyleSheetCache();
 880     }
 881 }
 882 
 883 String Document::compatMode() const
 884 {
 885     return inQuirksMode() ? &quot;BackCompat&quot; : &quot;CSS1Compat&quot;;
 886 }
 887 
 888 void Document::resetLinkColor()
 889 {
 890     m_linkColor = StyleColor::colorFromKeyword(CSSValueWebkitLink, styleColorOptions(nullptr));
 891 }
 892 
 893 void Document::resetVisitedLinkColor()
 894 {
 895     m_visitedLinkColor = StyleColor::colorFromKeyword(CSSValueWebkitLink, styleColorOptions(nullptr) | StyleColor::Options::ForVisitedLink);
 896 }
 897 
 898 void Document::resetActiveLinkColor()
 899 {
 900     m_activeLinkColor = StyleColor::colorFromKeyword(CSSValueWebkitActivelink, styleColorOptions(nullptr));
 901 }
 902 
 903 DOMImplementation&amp; Document::implementation()
 904 {
 905     if (!m_implementation)
 906         m_implementation = makeUnique&lt;DOMImplementation&gt;(*this);
 907     return *m_implementation;
 908 }
 909 
 910 bool Document::hasManifest() const
 911 {
 912     return documentElement() &amp;&amp; documentElement()-&gt;hasTagName(htmlTag) &amp;&amp; documentElement()-&gt;hasAttributeWithoutSynchronization(manifestAttr);
 913 }
 914 
 915 DocumentType* Document::doctype() const
 916 {
 917     for (Node* node = firstChild(); node; node = node-&gt;nextSibling()) {
 918         if (is&lt;DocumentType&gt;(node))
 919             return downcast&lt;DocumentType&gt;(node);
 920     }
 921     return nullptr;
 922 }
 923 
 924 void Document::childrenChanged(const ChildChange&amp; change)
 925 {
 926     ContainerNode::childrenChanged(change);
 927 
 928     // FIXME: Chrome::didReceiveDocType() used to be called only when the doctype changed. We need to check the
 929     // impact of calling this systematically. If the overhead is negligible, we need to rename didReceiveDocType,
 930     // otherwise, we need to detect the doc type changes before updating the viewport.
 931     if (Page* page = this-&gt;page())
 932         page-&gt;chrome().didReceiveDocType(*frame());
 933 
 934     Element* newDocumentElement = childrenOfType&lt;Element&gt;(*this).first();
 935     if (newDocumentElement == m_documentElement)
 936         return;
 937     m_documentElement = newDocumentElement;
 938     // The root style used for media query matching depends on the document element.
 939     styleScope().clearResolver();
 940 }
 941 
 942 static ALWAYS_INLINE Ref&lt;HTMLElement&gt; createUpgradeCandidateElement(Document&amp; document, const QualifiedName&amp; name)
 943 {
 944     if (!RuntimeEnabledFeatures::sharedFeatures().customElementsEnabled()
 945         || Document::validateCustomElementName(name.localName()) != CustomElementNameValidationStatus::Valid)
 946         return HTMLUnknownElement::create(name, document);
 947 
 948     auto element = HTMLElement::create(name, document);
 949     element-&gt;setIsCustomElementUpgradeCandidate();
 950     return element;
 951 }
 952 
 953 static ALWAYS_INLINE Ref&lt;HTMLElement&gt; createUpgradeCandidateElement(Document&amp; document, const AtomString&amp; localName)
 954 {
 955     return createUpgradeCandidateElement(document, QualifiedName { nullAtom(), localName, xhtmlNamespaceURI });
 956 }
 957 
 958 static inline bool isValidHTMLElementName(const AtomString&amp; localName)
 959 {
 960     return Document::isValidName(localName);
 961 }
 962 
 963 static inline bool isValidHTMLElementName(const QualifiedName&amp; name)
 964 {
 965     return Document::isValidName(name.localName());
 966 }
 967 
 968 template&lt;typename NameType&gt;
 969 static ExceptionOr&lt;Ref&lt;Element&gt;&gt; createHTMLElementWithNameValidation(Document&amp; document, const NameType&amp; name)
 970 {
 971     auto element = HTMLElementFactory::createKnownElement(name, document);
 972     if (LIKELY(element))
 973         return Ref&lt;Element&gt; { element.releaseNonNull() };
 974 
 975     if (auto* window = document.domWindow()) {
 976         auto* registry = window-&gt;customElementRegistry();
 977         if (UNLIKELY(registry)) {
 978             if (auto* elementInterface = registry-&gt;findInterface(name))
 979                 return elementInterface-&gt;constructElementWithFallback(document, name);
 980         }
 981     }
 982 
 983     if (UNLIKELY(!isValidHTMLElementName(name)))
 984         return Exception { InvalidCharacterError };
 985 
 986     return Ref&lt;Element&gt; { createUpgradeCandidateElement(document, name) };
 987 }
 988 
 989 ExceptionOr&lt;Ref&lt;Element&gt;&gt; Document::createElementForBindings(const AtomString&amp; name)
 990 {
 991     if (isHTMLDocument())
 992         return createHTMLElementWithNameValidation(*this, name.convertToASCIILowercase());
 993 
 994     if (isXHTMLDocument())
 995         return createHTMLElementWithNameValidation(*this, name);
 996 
 997     if (!isValidName(name))
 998         return Exception { InvalidCharacterError };
 999 
1000     return createElement(QualifiedName(nullAtom(), name, nullAtom()), false);
1001 }
1002 
1003 Ref&lt;DocumentFragment&gt; Document::createDocumentFragment()
1004 {
1005     return DocumentFragment::create(document());
1006 }
1007 
1008 Ref&lt;Text&gt; Document::createTextNode(const String&amp; data)
1009 {
1010     return Text::create(*this, data);
1011 }
1012 
1013 Ref&lt;Comment&gt; Document::createComment(const String&amp; data)
1014 {
1015     return Comment::create(*this, data);
1016 }
1017 
1018 ExceptionOr&lt;Ref&lt;CDATASection&gt;&gt; Document::createCDATASection(const String&amp; data)
1019 {
1020     if (isHTMLDocument())
1021         return Exception { NotSupportedError };
1022     return CDATASection::create(*this, data);
1023 }
1024 
1025 ExceptionOr&lt;Ref&lt;ProcessingInstruction&gt;&gt; Document::createProcessingInstruction(const String&amp; target, const String&amp; data)
1026 {
1027     if (!isValidName(target))
1028         return Exception { InvalidCharacterError };
1029 
1030     if (data.contains(&quot;?&gt;&quot;))
1031         return Exception { InvalidCharacterError };
1032 
1033     return ProcessingInstruction::create(*this, target, data);
1034 }
1035 
1036 Ref&lt;Text&gt; Document::createEditingTextNode(const String&amp; text)
1037 {
1038     return Text::createEditingText(*this, text);
1039 }
1040 
1041 Ref&lt;CSSStyleDeclaration&gt; Document::createCSSStyleDeclaration()
1042 {
1043     Ref&lt;MutableStyleProperties&gt; propertySet(MutableStyleProperties::create());
1044     return propertySet-&gt;ensureCSSStyleDeclaration();
1045 }
1046 
1047 ExceptionOr&lt;Ref&lt;Node&gt;&gt; Document::importNode(Node&amp; nodeToImport, bool deep)
1048 {
1049     switch (nodeToImport.nodeType()) {
1050     case DOCUMENT_FRAGMENT_NODE:
1051         if (nodeToImport.isShadowRoot())
1052             break;
1053         FALLTHROUGH;
1054     case ELEMENT_NODE:
1055     case TEXT_NODE:
1056     case CDATA_SECTION_NODE:
1057     case PROCESSING_INSTRUCTION_NODE:
1058     case COMMENT_NODE:
1059         return nodeToImport.cloneNodeInternal(document(), deep ? CloningOperation::Everything : CloningOperation::OnlySelf);
1060 
1061     case ATTRIBUTE_NODE: {
1062         auto&amp; attribute = downcast&lt;Attr&gt;(nodeToImport);
1063         return Ref&lt;Node&gt; { Attr::create(*this, attribute.qualifiedName(), attribute.value()) };
1064     }
1065     case DOCUMENT_NODE: // Can&#39;t import a document into another document.
1066     case DOCUMENT_TYPE_NODE: // FIXME: Support cloning a DocumentType node per DOM4.
1067         break;
1068     }
1069 
1070     return Exception { NotSupportedError };
1071 }
1072 
1073 
1074 ExceptionOr&lt;Ref&lt;Node&gt;&gt; Document::adoptNode(Node&amp; source)
1075 {
1076     EventQueueScope scope;
1077 
1078     switch (source.nodeType()) {
1079     case DOCUMENT_NODE:
1080         return Exception { NotSupportedError };
1081     case ATTRIBUTE_NODE: {
1082         auto&amp; attr = downcast&lt;Attr&gt;(source);
1083         if (auto* element = attr.ownerElement()) {
1084             auto result = element-&gt;removeAttributeNode(attr);
1085             if (result.hasException())
1086                 return result.releaseException();
1087         }
1088         break;
1089     }
1090     default:
1091         if (source.isShadowRoot()) {
1092             // ShadowRoot cannot disconnect itself from the host node.
1093             return Exception { HierarchyRequestError };
1094         }
1095         if (is&lt;HTMLFrameOwnerElement&gt;(source)) {
1096             auto&amp; frameOwnerElement = downcast&lt;HTMLFrameOwnerElement&gt;(source);
1097             if (frame() &amp;&amp; frame()-&gt;tree().isDescendantOf(frameOwnerElement.contentFrame()))
1098                 return Exception { HierarchyRequestError };
1099         }
1100         auto result = source.remove();
1101         if (result.hasException())
1102             return result.releaseException();
1103         RELEASE_ASSERT(!source.isConnected());
1104         RELEASE_ASSERT(!source.parentNode());
1105     }
1106 
1107     source.setTreeScopeRecursively(*this);
1108 
1109     return Ref&lt;Node&gt; { source };
1110 }
1111 
1112 bool Document::hasValidNamespaceForElements(const QualifiedName&amp; qName)
1113 {
1114     // These checks are from DOM Core Level 2, createElementNS
1115     // http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-DocCrElNS
1116     if (!qName.prefix().isEmpty() &amp;&amp; qName.namespaceURI().isNull()) // createElementNS(null, &quot;html:div&quot;)
1117         return false;
1118     if (qName.prefix() == xmlAtom() &amp;&amp; qName.namespaceURI() != XMLNames::xmlNamespaceURI) // createElementNS(&quot;http://www.example.com&quot;, &quot;xml:lang&quot;)
1119         return false;
1120 
1121     // Required by DOM Level 3 Core and unspecified by DOM Level 2 Core:
1122     // http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-DocCrElNS
1123     // createElementNS(&quot;http://www.w3.org/2000/xmlns/&quot;, &quot;foo:bar&quot;), createElementNS(null, &quot;xmlns:bar&quot;), createElementNS(null, &quot;xmlns&quot;)
1124     if (qName.prefix() == xmlnsAtom() || (qName.prefix().isEmpty() &amp;&amp; qName.localName() == xmlnsAtom()))
1125         return qName.namespaceURI() == XMLNSNames::xmlnsNamespaceURI;
1126     return qName.namespaceURI() != XMLNSNames::xmlnsNamespaceURI;
1127 }
1128 
1129 bool Document::hasValidNamespaceForAttributes(const QualifiedName&amp; qName)
1130 {
1131     return hasValidNamespaceForElements(qName);
1132 }
1133 
1134 static Ref&lt;HTMLElement&gt; createFallbackHTMLElement(Document&amp; document, const QualifiedName&amp; name)
1135 {
1136     if (auto* window = document.domWindow()) {
1137         auto* registry = window-&gt;customElementRegistry();
1138         if (UNLIKELY(registry)) {
1139             if (auto* elementInterface = registry-&gt;findInterface(name)) {
1140                 auto element = HTMLElement::create(name, document);
1141                 element-&gt;enqueueToUpgrade(*elementInterface);
1142                 return element;
1143             }
1144         }
1145     }
1146     // FIXME: Should we also check the equality of prefix between the custom element and name?
1147     return createUpgradeCandidateElement(document, name);
1148 }
1149 
1150 // FIXME: This should really be in a possible ElementFactory class.
1151 Ref&lt;Element&gt; Document::createElement(const QualifiedName&amp; name, bool createdByParser)
1152 {
1153     RefPtr&lt;Element&gt; element;
1154 
1155     // FIXME: Use registered namespaces and look up in a hash to find the right factory.
1156     if (name.namespaceURI() == xhtmlNamespaceURI) {
1157         element = HTMLElementFactory::createKnownElement(name, *this, nullptr, createdByParser);
1158         if (UNLIKELY(!element))
1159             element = createFallbackHTMLElement(*this, name);
1160     } else if (name.namespaceURI() == SVGNames::svgNamespaceURI)
1161         element = SVGElementFactory::createElement(name, *this, createdByParser);
1162 #if ENABLE(MATHML)
1163     else if (name.namespaceURI() == MathMLNames::mathmlNamespaceURI)
1164         element = MathMLElementFactory::createElement(name, *this, createdByParser);
1165 #endif
1166 
1167     if (element)
1168         m_sawElementsInKnownNamespaces = true;
1169     else
1170         element = Element::create(name, document());
1171 
1172     // &lt;image&gt; uses imgTag so we need a special rule.
1173     ASSERT((name.matches(imageTag) &amp;&amp; element-&gt;tagQName().matches(imgTag) &amp;&amp; element-&gt;tagQName().prefix() == name.prefix()) || name == element-&gt;tagQName());
1174 
1175     return element.releaseNonNull();
1176 }
1177 
1178 // https://html.spec.whatwg.org/#valid-custom-element-name
1179 
1180 struct UnicodeCodePointRange {
1181     UChar32 minimum;
1182     UChar32 maximum;
1183 };
1184 
1185 #if ASSERT_ENABLED
1186 
1187 static inline bool operator&lt;(const UnicodeCodePointRange&amp; a, const UnicodeCodePointRange&amp; b)
1188 {
1189     ASSERT(a.minimum &lt;= a.maximum);
1190     ASSERT(b.minimum &lt;= b.maximum);
1191     return a.maximum &lt; b.minimum;
1192 }
1193 
1194 #endif // ASSERT_ENABLED
1195 
1196 static inline bool operator&lt;(const UnicodeCodePointRange&amp; a, UChar32 b)
1197 {
1198     ASSERT(a.minimum &lt;= a.maximum);
1199     return a.maximum &lt; b;
1200 }
1201 
1202 static inline bool operator&lt;(UChar32 a, const UnicodeCodePointRange&amp; b)
1203 {
1204     ASSERT(b.minimum &lt;= b.maximum);
1205     return a &lt; b.minimum;
1206 }
1207 
1208 static inline bool isPotentialCustomElementNameCharacter(UChar32 character)
1209 {
1210     static const UnicodeCodePointRange ranges[] = {
1211         { &#39;-&#39;, &#39;.&#39; },
1212         { &#39;0&#39;, &#39;9&#39; },
1213         { &#39;_&#39;, &#39;_&#39; },
1214         { &#39;a&#39;, &#39;z&#39; },
1215         { 0xB7, 0xB7 },
1216         { 0xC0, 0xD6 },
1217         { 0xD8, 0xF6 },
1218         { 0xF8, 0x37D },
1219         { 0x37F, 0x1FFF },
1220         { 0x200C, 0x200D },
1221         { 0x203F, 0x2040 },
1222         { 0x2070, 0x218F },
1223         { 0x2C00, 0x2FEF },
1224         { 0x3001, 0xD7FF },
1225         { 0xF900, 0xFDCF },
1226         { 0xFDF0, 0xFFFD },
1227         { 0x10000, 0xEFFFF },
1228     };
1229 
1230     ASSERT(std::is_sorted(std::begin(ranges), std::end(ranges)));
1231     return std::binary_search(std::begin(ranges), std::end(ranges), character);
1232 }
1233 
1234 CustomElementNameValidationStatus Document::validateCustomElementName(const AtomString&amp; localName)
1235 {
1236     if (!isASCIILower(localName[0]))
1237         return CustomElementNameValidationStatus::FirstCharacterIsNotLowercaseASCIILetter;
1238 
1239     bool containsHyphen = false;
1240     for (auto character : StringView(localName).codePoints()) {
1241         if (isASCIIUpper(character))
1242             return CustomElementNameValidationStatus::ContainsUppercaseASCIILetter;
1243         if (!isPotentialCustomElementNameCharacter(character))
1244             return CustomElementNameValidationStatus::ContainsDisallowedCharacter;
1245         if (character == &#39;-&#39;)
1246             containsHyphen = true;
1247     }
1248 
1249     if (!containsHyphen)
1250         return CustomElementNameValidationStatus::ContainsNoHyphen;
1251 
1252 #if ENABLE(MATHML)
1253     const auto&amp; annotationXmlLocalName = MathMLNames::annotation_xmlTag-&gt;localName();
1254 #else
1255     static NeverDestroyed&lt;const AtomString&gt; annotationXmlLocalName(&quot;annotation-xml&quot;, AtomString::ConstructFromLiteral);
1256 #endif
1257 
1258     if (localName == SVGNames::color_profileTag-&gt;localName()
1259         || localName == SVGNames::font_faceTag-&gt;localName()
1260         || localName == SVGNames::font_face_formatTag-&gt;localName()
1261         || localName == SVGNames::font_face_nameTag-&gt;localName()
1262         || localName == SVGNames::font_face_srcTag-&gt;localName()
1263         || localName == SVGNames::font_face_uriTag-&gt;localName()
1264         || localName == SVGNames::missing_glyphTag-&gt;localName()
1265         || localName == annotationXmlLocalName)
1266         return CustomElementNameValidationStatus::ConflictsWithStandardElementName;
1267 
1268     return CustomElementNameValidationStatus::Valid;
1269 }
1270 
1271 ExceptionOr&lt;Ref&lt;Element&gt;&gt; Document::createElementNS(const AtomString&amp; namespaceURI, const String&amp; qualifiedName)
1272 {
1273     auto parseResult = parseQualifiedName(namespaceURI, qualifiedName);
1274     if (parseResult.hasException())
1275         return parseResult.releaseException();
1276     QualifiedName parsedName { parseResult.releaseReturnValue() };
1277     if (!hasValidNamespaceForElements(parsedName))
1278         return Exception { NamespaceError };
1279 
1280     if (parsedName.namespaceURI() == xhtmlNamespaceURI)
1281         return createHTMLElementWithNameValidation(*this, parsedName);
1282 
1283     return createElement(parsedName, false);
1284 }
1285 
1286 void Document::setReadyState(ReadyState readyState)
1287 {
1288     if (readyState == m_readyState)
1289         return;
1290 
1291     switch (readyState) {
1292     case Loading:
1293         if (!m_documentTiming.domLoading)
1294             m_documentTiming.domLoading = MonotonicTime::now();
1295         break;
1296     case Interactive:
1297         if (!m_documentTiming.domInteractive)
1298             m_documentTiming.domInteractive = MonotonicTime::now();
1299         break;
1300     case Complete:
1301         if (!m_documentTiming.domComplete)
1302             m_documentTiming.domComplete = MonotonicTime::now();
1303         break;
1304     }
1305 
1306     m_readyState = readyState;
1307     dispatchEvent(Event::create(eventNames().readystatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
1308 
1309     if (settings().suppressesIncrementalRendering())
1310         setVisualUpdatesAllowed(readyState);
1311 }
1312 
1313 void Document::setVisualUpdatesAllowed(ReadyState readyState)
1314 {
1315     ASSERT(settings().suppressesIncrementalRendering());
1316     switch (readyState) {
1317     case Loading:
1318         ASSERT(!m_visualUpdatesSuppressionTimer.isActive());
1319         ASSERT(m_visualUpdatesAllowed);
1320         setVisualUpdatesAllowed(false);
1321         break;
1322     case Interactive:
1323         ASSERT(m_visualUpdatesSuppressionTimer.isActive() || m_visualUpdatesAllowed);
1324         break;
1325     case Complete:
1326         if (m_visualUpdatesSuppressionTimer.isActive()) {
1327             ASSERT(!m_visualUpdatesAllowed);
1328 
1329             if (view() &amp;&amp; !view()-&gt;visualUpdatesAllowedByClient())
1330                 return;
1331 
1332             setVisualUpdatesAllowed(true);
1333         } else
1334             ASSERT(m_visualUpdatesAllowed);
1335         break;
1336     }
1337 }
1338 
1339 void Document::setVisualUpdatesAllowed(bool visualUpdatesAllowed)
1340 {
1341     if (m_visualUpdatesAllowed == visualUpdatesAllowed)
1342         return;
1343 
1344     m_visualUpdatesAllowed = visualUpdatesAllowed;
1345 
1346     if (visualUpdatesAllowed)
1347         m_visualUpdatesSuppressionTimer.stop();
1348     else
1349         m_visualUpdatesSuppressionTimer.startOneShot(1_s * settings().incrementalRenderingSuppressionTimeoutInSeconds());
1350 
1351     if (!visualUpdatesAllowed)
1352         return;
1353 
1354     RefPtr&lt;FrameView&gt; frameView = view();
1355     bool needsLayout = frameView &amp;&amp; renderView() &amp;&amp; (frameView-&gt;layoutContext().isLayoutPending() || renderView()-&gt;needsLayout());
1356     if (needsLayout)
1357         updateLayout();
1358 
1359     if (Page* page = this-&gt;page()) {
1360         if (frame()-&gt;isMainFrame()) {
1361             frameView-&gt;addPaintPendingMilestones(DidFirstPaintAfterSuppressedIncrementalRendering);
1362             if (page-&gt;requestedLayoutMilestones() &amp; DidFirstLayoutAfterSuppressedIncrementalRendering)
1363                 frame()-&gt;loader().didReachLayoutMilestone(DidFirstLayoutAfterSuppressedIncrementalRendering);
1364         }
1365     }
1366 
1367     if (frameView)
1368         frameView-&gt;updateCompositingLayersAfterLayout();
1369 
1370     if (RenderView* renderView = this-&gt;renderView())
1371         renderView-&gt;repaintViewAndCompositedLayers();
1372 
1373     if (Frame* frame = this-&gt;frame())
1374         frame-&gt;loader().forcePageTransitionIfNeeded();
1375 }
1376 
1377 void Document::visualUpdatesSuppressionTimerFired()
1378 {
1379     ASSERT(!m_visualUpdatesAllowed);
1380 
1381     // If the client is extending the visual update suppression period explicitly, the
1382     // watchdog should not re-enable visual updates itself, but should wait for the client.
1383     if (view() &amp;&amp; !view()-&gt;visualUpdatesAllowedByClient())
1384         return;
1385 
1386     setVisualUpdatesAllowed(true);
1387 }
1388 
1389 void Document::setVisualUpdatesAllowedByClient(bool visualUpdatesAllowedByClient)
1390 {
1391     // We should only re-enable visual updates if ReadyState is Completed or the watchdog timer has fired,
1392     // both of which we can determine by looking at the timer.
1393 
1394     if (visualUpdatesAllowedByClient &amp;&amp; !m_visualUpdatesSuppressionTimer.isActive() &amp;&amp; !visualUpdatesAllowed())
1395         setVisualUpdatesAllowed(true);
1396 }
1397 
1398 String Document::characterSetWithUTF8Fallback() const
1399 {
1400     AtomString name = encoding();
1401     if (!name.isNull())
1402         return name;
1403     return UTF8Encoding().domName();
1404 }
1405 
1406 String Document::defaultCharsetForLegacyBindings() const
1407 {
1408     if (!frame())
1409         UTF8Encoding().domName();
1410     return settings().defaultTextEncodingName();
1411 }
1412 
1413 void Document::setCharset(const String&amp; charset)
1414 {
1415     if (!decoder())
1416         return;
1417     decoder()-&gt;setEncoding(charset, TextResourceDecoder::UserChosenEncoding);
1418 }
1419 
1420 void Document::setContentLanguage(const String&amp; language)
1421 {
1422     if (m_contentLanguage == language)
1423         return;
1424     m_contentLanguage = language;
1425 
1426     // Recalculate style so language is used when selecting the initial font.
1427     m_styleScope-&gt;didChangeStyleSheetEnvironment();
1428 }
1429 
1430 ExceptionOr&lt;void&gt; Document::setXMLVersion(const String&amp; version)
1431 {
1432     if (!XMLDocumentParser::supportsXMLVersion(version))
1433         return Exception { NotSupportedError };
1434 
1435     m_xmlVersion = version;
1436     return { };
1437 }
1438 
1439 void Document::setXMLStandalone(bool standalone)
1440 {
1441     m_xmlStandalone = standalone ? StandaloneStatus::Standalone : StandaloneStatus::NotStandalone;
1442 }
1443 
1444 void Document::setDocumentURI(const String&amp; uri)
1445 {
1446     // This property is read-only from JavaScript, but writable from Objective-C.
1447     m_documentURI = uri;
1448     updateBaseURL();
1449 }
1450 
1451 void Document::setContent(const String&amp; content)
1452 {
1453     open();
1454     // FIXME: This should probably use insert(), but that&#39;s (intentionally)
1455     // not implemented for the XML parser as it&#39;s normally synonymous with
1456     // document.write(). append() will end up yielding, but close() will
1457     // pump the tokenizer syncrhonously and finish the parse.
1458     m_parser-&gt;append(content.impl());
1459     close();
1460 }
1461 
1462 String Document::suggestedMIMEType() const
1463 {
1464     if (isXHTMLDocument())
1465         return &quot;application/xhtml+xml&quot;_s;
1466     if (isSVGDocument())
1467         return &quot;image/svg+xml&quot;_s;
1468     if (xmlStandalone())
1469         return &quot;text/xml&quot;_s;
1470     if (isHTMLDocument())
1471         return &quot;text/html&quot;_s;
1472     if (DocumentLoader* loader = this-&gt;loader())
1473         return loader-&gt;responseMIMEType();
1474     return String();
1475 }
1476 
1477 void Document::overrideMIMEType(const String&amp; mimeType)
1478 {
1479     m_overriddenMIMEType = mimeType;
1480 }
1481 
1482 String Document::contentType() const
1483 {
1484     if (!m_overriddenMIMEType.isNull())
1485         return m_overriddenMIMEType;
1486 
1487     if (DocumentLoader* documentLoader = loader())
1488         return documentLoader-&gt;currentContentType();
1489 
1490     String mimeType = suggestedMIMEType();
1491     if (!mimeType.isNull())
1492         return mimeType;
1493 
1494     return &quot;application/xml&quot;_s;
1495 }
1496 
1497 RefPtr&lt;Range&gt; Document::caretRangeFromPoint(int x, int y)
1498 {
1499     return caretRangeFromPoint(LayoutPoint(x, y));
1500 }
1501 
1502 RefPtr&lt;Range&gt; Document::caretRangeFromPoint(const LayoutPoint&amp; clientPoint)
1503 {
1504     if (!hasLivingRenderTree())
1505         return nullptr;
1506 
1507     LayoutPoint localPoint;
1508     Node* node = nodeFromPoint(clientPoint, &amp;localPoint);
1509     if (!node)
1510         return nullptr;
1511 
1512     RenderObject* renderer = node-&gt;renderer();
1513     if (!renderer)
1514         return nullptr;
1515     Position rangeCompliantPosition = renderer-&gt;positionForPoint(localPoint).parentAnchoredEquivalent();
1516     if (rangeCompliantPosition.isNull())
1517         return nullptr;
1518 
1519     unsigned offset = rangeCompliantPosition.offsetInContainerNode();
1520     node = &amp;retargetToScope(*rangeCompliantPosition.containerNode());
1521     if (node != rangeCompliantPosition.containerNode())
1522         offset = 0;
1523 
1524     return Range::create(*this, node, offset, node, offset);
1525 }
1526 
1527 bool Document::isBodyPotentiallyScrollable(HTMLBodyElement&amp; body)
1528 {
1529     // See https://www.w3.org/TR/cssom-view-1/#potentially-scrollable.
1530     // An element is potentially scrollable if all of the following conditions are true:
1531     // - The element has an associated CSS layout box.
1532     // - The element is not the HTML body element, or it is and the root element&#39;s used value of the
1533     //   overflow-x or overflow-y properties is not visible.
1534     // - The element&#39;s used value of the overflow-x or overflow-y properties is not visible.
1535     //
1536     // FIXME: We should use RenderObject::hasOverflowClip() instead of Element::computedStyle() but
1537     // the used values are currently not correctly updated. See https://webkit.org/b/182292.
1538     return body.renderer()
1539         &amp;&amp; documentElement()-&gt;computedStyle()
1540         &amp;&amp; !documentElement()-&gt;computedStyle()-&gt;isOverflowVisible()
1541         &amp;&amp; body.computedStyle()
1542         &amp;&amp; !body.computedStyle()-&gt;isOverflowVisible();
1543 }
1544 
1545 Element* Document::scrollingElementForAPI()
1546 {
1547     if (inQuirksMode() &amp;&amp; settings().CSSOMViewScrollingAPIEnabled())
1548         updateLayoutIgnorePendingStylesheets();
1549     return scrollingElement();
1550 }
1551 
1552 Element* Document::scrollingElement()
1553 {
1554     if (settings().CSSOMViewScrollingAPIEnabled()) {
1555         // See https://drafts.csswg.org/cssom-view/#dom-document-scrollingelement.
1556         // The scrollingElement attribute, on getting, must run these steps:
1557         // 1. If the Document is in quirks mode, follow these substeps:
1558         if (inQuirksMode()) {
1559             auto* firstBody = body();
1560             // 1. If the HTML body element exists, and it is not potentially scrollable, return the
1561             // HTML body element and abort these steps.
1562             if (firstBody &amp;&amp; !isBodyPotentiallyScrollable(*firstBody))
1563                 return firstBody;
1564 
1565             // 2. Return null and abort these steps.
1566             return nullptr;
1567         }
1568 
1569         // 2. If there is a root element, return the root element and abort these steps.
1570         // 3. Return null.
1571         return documentElement();
1572     }
1573 
1574     return body();
1575 }
1576 
1577 static String canonicalizedTitle(Document&amp; document, const String&amp; title)
1578 {
1579     // Collapse runs of HTML spaces into single space characters.
1580     // Strip leading and trailing spaces.
1581     // Replace backslashes with currency symbols.
1582 
1583     StringBuilder builder;
1584 
1585     auto* decoder = document.decoder();
1586     auto backslashAsCurrencySymbol = decoder ? decoder-&gt;encoding().backslashAsCurrencySymbol() : &#39;\\&#39;;
1587 
1588     bool previousCharacterWasHTMLSpace = false;
1589     for (auto character : StringView { title }.codeUnits()) {
1590         if (isHTMLSpace(character))
1591             previousCharacterWasHTMLSpace = true;
1592         else {
1593             if (character == &#39;\\&#39;)
1594                 character = backslashAsCurrencySymbol;
1595             if (previousCharacterWasHTMLSpace &amp;&amp; !builder.isEmpty())
1596                 builder.append(&#39; &#39;);
1597             builder.append(character);
1598             previousCharacterWasHTMLSpace = false;
1599         }
1600     }
1601 
1602     return builder == title ? title : builder.toString();
1603 }
1604 
1605 void Document::updateTitle(const StringWithDirection&amp; title)
1606 {
1607     if (m_rawTitle == title)
1608         return;
1609 
1610     m_rawTitle = title;
1611 
1612     m_title.string = canonicalizedTitle(*this, title.string);
1613     m_title.direction = title.direction;
1614 
1615     if (auto* loader = this-&gt;loader())
1616         loader-&gt;setTitle(m_title);
1617 }
1618 
1619 void Document::updateTitleFromTitleElement()
1620 {
1621     if (!m_titleElement) {
1622         updateTitle({ });
1623         return;
1624     }
1625 
1626     if (is&lt;HTMLTitleElement&gt;(*m_titleElement))
1627         updateTitle(downcast&lt;HTMLTitleElement&gt;(*m_titleElement).textWithDirection());
1628     else if (is&lt;SVGTitleElement&gt;(*m_titleElement)) {
1629         // FIXME: Does the SVG title element have a text direction?
1630         updateTitle({ downcast&lt;SVGTitleElement&gt;(*m_titleElement).textContent(), TextDirection::LTR });
1631     }
1632 }
1633 
1634 void Document::setTitle(const String&amp; title)
1635 {
1636     auto* element = documentElement();
1637     if (is&lt;SVGSVGElement&gt;(element)) {
1638         if (!m_titleElement) {
1639             m_titleElement = SVGTitleElement::create(SVGNames::titleTag, *this);
1640             element-&gt;insertBefore(*m_titleElement, element-&gt;firstChild());
1641         }
1642         // insertBefore above may have ran scripts which removed m_titleElement.
1643         if (m_titleElement)
1644             m_titleElement-&gt;setTextContent(title);
1645     } else if (is&lt;HTMLElement&gt;(element)) {
1646         if (!m_titleElement) {
1647             auto* headElement = head();
1648             if (!headElement)
1649                 return;
1650             m_titleElement = HTMLTitleElement::create(HTMLNames::titleTag, *this);
1651             headElement-&gt;appendChild(*m_titleElement);
1652         }
1653         // appendChild above may have ran scripts which removed m_titleElement.
1654         if (m_titleElement)
1655             m_titleElement-&gt;setTextContent(title);
1656     }
1657 }
1658 
1659 template&lt;typename&gt; struct TitleTraits;
1660 
1661 template&lt;&gt; struct TitleTraits&lt;HTMLTitleElement&gt; {
1662     static bool isInEligibleLocation(HTMLTitleElement&amp; element) { return element.isConnected() &amp;&amp; !element.isInShadowTree(); }
1663     static HTMLTitleElement* findTitleElement(Document&amp; document) { return descendantsOfType&lt;HTMLTitleElement&gt;(document).first(); }
1664 };
1665 
1666 template&lt;&gt; struct TitleTraits&lt;SVGTitleElement&gt; {
1667     static bool isInEligibleLocation(SVGTitleElement&amp; element) { return element.parentNode() == element.document().documentElement(); }
1668     static SVGTitleElement* findTitleElement(Document&amp; document) { return childrenOfType&lt;SVGTitleElement&gt;(*document.documentElement()).first(); }
1669 };
1670 
1671 template&lt;typename TitleElement&gt; Element* selectNewTitleElement(Document&amp; document, Element* oldTitleElement, Element&amp; changingTitleElement)
1672 {
1673     using Traits = TitleTraits&lt;TitleElement&gt;;
1674 
1675     if (!is&lt;TitleElement&gt;(changingTitleElement)) {
1676         ASSERT(oldTitleElement == Traits::findTitleElement(document));
1677         return oldTitleElement;
1678     }
1679 
1680     if (oldTitleElement)
1681         return Traits::findTitleElement(document);
1682 
1683     // Optimized common case: We have no title element yet.
1684     // We can figure out which title element should be used without searching.
1685     bool isEligible = Traits::isInEligibleLocation(downcast&lt;TitleElement&gt;(changingTitleElement));
1686     auto* newTitleElement = isEligible ? &amp;changingTitleElement : nullptr;
1687     ASSERT(newTitleElement == Traits::findTitleElement(document));
1688     return newTitleElement;
1689 }
1690 
1691 void Document::updateTitleElement(Element&amp; changingTitleElement)
1692 {
1693     // Most documents use HTML title rules.
1694     // Documents with SVG document elements use SVG title rules.
1695     auto selectTitleElement = is&lt;SVGSVGElement&gt;(documentElement())
1696         ? selectNewTitleElement&lt;SVGTitleElement&gt; : selectNewTitleElement&lt;HTMLTitleElement&gt;;
1697     auto newTitleElement = selectTitleElement(*this, m_titleElement.get(), changingTitleElement);
1698     if (m_titleElement == newTitleElement)
1699         return;
1700     m_titleElement = newTitleElement;
1701     updateTitleFromTitleElement();
1702 }
1703 
1704 void Document::titleElementAdded(Element&amp; titleElement)
1705 {
1706     if (m_titleElement == &amp;titleElement)
1707         return;
1708 
1709     updateTitleElement(titleElement);
1710 }
1711 
1712 void Document::titleElementRemoved(Element&amp; titleElement)
1713 {
1714     if (m_titleElement != &amp;titleElement)
1715         return;
1716 
1717     updateTitleElement(titleElement);
1718 }
1719 
1720 void Document::titleElementTextChanged(Element&amp; titleElement)
1721 {
1722     if (m_titleElement != &amp;titleElement)
1723         return;
1724 
1725     updateTitleFromTitleElement();
1726 }
1727 
1728 void Document::registerForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp; client)
1729 {
1730     m_visibilityStateCallbackClients.add(&amp;client);
1731 }
1732 
1733 void Document::unregisterForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp; client)
1734 {
1735     m_visibilityStateCallbackClients.remove(&amp;client);
1736 }
1737 
1738 void Document::visibilityStateChanged()
1739 {
1740     // // https://w3c.github.io/page-visibility/#reacting-to-visibilitychange-changes
1741     queueTaskToDispatchEvent(TaskSource::UserInteraction, Event::create(eventNames().visibilitychangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
1742     for (auto* client : m_visibilityStateCallbackClients)
1743         client-&gt;visibilityStateChanged();
1744 
1745 #if ENABLE(MEDIA_STREAM)
1746     if (auto* page = this-&gt;page())
1747         RealtimeMediaSourceCenter::singleton().setCapturePageState(hidden(), page-&gt;isMediaCaptureMuted());
1748 #endif
1749 }
1750 
1751 VisibilityState Document::visibilityState() const
1752 {
1753     // The visibility of the document is inherited from the visibility of the
1754     // page. If there is no page associated with the document, we will assume
1755     // that the page is hidden, as specified by the spec:
1756     // http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/PageVisibility/Overview.html#dom-document-hidden
1757     if (!m_frame || !m_frame-&gt;page())
1758         return VisibilityState::Hidden;
1759     return m_frame-&gt;page()-&gt;visibilityState();
1760 }
1761 
1762 bool Document::hidden() const
1763 {
1764     return visibilityState() != VisibilityState::Visible;
1765 }
1766 
1767 #if ENABLE(VIDEO)
1768 
1769 void Document::registerMediaElement(HTMLMediaElement&amp; element)
1770 {
1771     m_mediaElements.add(&amp;element);
1772 }
1773 
1774 void Document::unregisterMediaElement(HTMLMediaElement&amp; element)
1775 {
1776     m_mediaElements.remove(&amp;element);
1777 }
1778 
1779 void Document::forEachMediaElement(const Function&lt;void(HTMLMediaElement&amp;)&gt;&amp; function)
1780 {
1781     Vector&lt;Ref&lt;HTMLMediaElement&gt;&gt; elements;
1782     for (auto* element : m_mediaElements)
1783         elements.append(*element);
1784     for (auto&amp; element : elements)
1785         function(element);
1786 }
1787 
1788 void Document::stopAllMediaPlayback()
1789 {
1790     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1791         platformMediaSessionManager-&gt;stopAllMediaPlaybackForDocument(*this);
1792 }
1793 
1794 void Document::suspendAllMediaPlayback()
1795 {
1796     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1797         platformMediaSessionManager-&gt;suspendAllMediaPlaybackForDocument(*this);
1798 }
1799 
1800 void Document::resumeAllMediaPlayback()
1801 {
1802     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1803         platformMediaSessionManager-&gt;resumeAllMediaPlaybackForDocument(*this);
1804 }
1805 
1806 void Document::suspendAllMediaBuffering()
1807 {
1808     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1809         platformMediaSessionManager-&gt;suspendAllMediaBufferingForDocument(*this);
1810 }
1811 
1812 void Document::resumeAllMediaBuffering()
1813 {
1814     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1815         platformMediaSessionManager-&gt;resumeAllMediaBufferingForDocument(*this);
1816 }
1817 
1818 #endif
1819 
1820 String Document::nodeName() const
1821 {
1822     return &quot;#document&quot;_s;
1823 }
1824 
1825 Node::NodeType Document::nodeType() const
1826 {
1827     return DOCUMENT_NODE;
1828 }
1829 
1830 FormController&amp; Document::formController()
1831 {
1832     if (!m_formController)
1833         m_formController = makeUnique&lt;FormController&gt;();
1834     return *m_formController;
1835 }
1836 
1837 Vector&lt;String&gt; Document::formElementsState() const
1838 {
1839     if (!m_formController)
1840         return Vector&lt;String&gt;();
1841     return m_formController-&gt;formElementsState();
1842 }
1843 
1844 void Document::setStateForNewFormElements(const Vector&lt;String&gt;&amp; stateVector)
1845 {
1846     if (!stateVector.size() &amp;&amp; !m_formController)
1847         return;
1848     formController().setStateForNewFormElements(stateVector);
1849 }
1850 
1851 FrameView* Document::view() const
1852 {
1853     return m_frame ? m_frame-&gt;view() : nullptr;
1854 }
1855 
1856 Page* Document::page() const
1857 {
1858     return m_frame ? m_frame-&gt;page() : nullptr;
1859 }
1860 
1861 Ref&lt;Range&gt; Document::createRange()
1862 {
1863     return Range::create(*this);
1864 }
1865 
1866 Ref&lt;NodeIterator&gt; Document::createNodeIterator(Node&amp; root, unsigned long whatToShow, RefPtr&lt;NodeFilter&gt;&amp;&amp; filter, bool)
1867 {
1868     return NodeIterator::create(root, whatToShow, WTFMove(filter));
1869 }
1870 
1871 Ref&lt;TreeWalker&gt; Document::createTreeWalker(Node&amp; root, unsigned long whatToShow, RefPtr&lt;NodeFilter&gt;&amp;&amp; filter, bool)
1872 {
1873     return TreeWalker::create(root, whatToShow, WTFMove(filter));
1874 }
1875 
1876 void Document::scheduleFullStyleRebuild()
1877 {
1878     m_needsFullStyleRebuild = true;
1879     scheduleStyleRecalc();
1880 }
1881 
1882 void Document::scheduleStyleRecalc()
1883 {
1884     ASSERT(!m_renderView || !inHitTesting());
1885 
1886     if (m_styleRecalcTimer.isActive() || backForwardCacheState() != NotInBackForwardCache)
1887         return;
1888 
1889     ASSERT(childNeedsStyleRecalc() || m_needsFullStyleRebuild);
1890     auto shouldThrottleStyleRecalc = [&amp;] {
1891         if (!view() || !view()-&gt;isVisuallyNonEmpty())
1892             return false;
1893         if (!page() || !page()-&gt;chrome().client().layerFlushThrottlingIsActive())
1894             return false;
1895         return true;
1896     };
1897 
1898     if (shouldThrottleStyleRecalc())
1899         return;
1900 
1901     m_styleRecalcTimer.startOneShot(0_s);
1902 
1903     InspectorInstrumentation::didScheduleStyleRecalculation(*this);
1904 }
1905 
1906 void Document::unscheduleStyleRecalc()
1907 {
1908     ASSERT(!childNeedsStyleRecalc());
1909 
1910     m_styleRecalcTimer.stop();
1911     m_needsFullStyleRebuild = false;
1912 }
1913 
1914 bool Document::hasPendingStyleRecalc() const
1915 {
1916     return needsStyleRecalc() &amp;&amp; !m_inStyleRecalc;
1917 }
1918 
1919 bool Document::hasPendingFullStyleRebuild() const
1920 {
1921     return hasPendingStyleRecalc() &amp;&amp; m_needsFullStyleRebuild;
1922 }
1923 
1924 void Document::resolveStyle(ResolveStyleType type)
1925 {
1926     ASSERT(!view() || !view()-&gt;isPainting());
1927 
1928     // NOTE: XSL code seems to be the only client stumbling in here without a RenderView.
1929     if (!m_renderView)
1930         return;
1931 
1932     FrameView&amp; frameView = m_renderView-&gt;frameView();
1933     Ref&lt;FrameView&gt; protect(frameView);
1934     if (frameView.isPainting())
1935         return;
1936 
1937     if (m_inStyleRecalc)
1938         return; // Guard against re-entrancy. -dwh
1939 
1940     TraceScope tracingScope(StyleRecalcStart, StyleRecalcEnd);
1941 
1942     RenderView::RepaintRegionAccumulator repaintRegionAccumulator(renderView());
1943     AnimationUpdateBlock animationUpdateBlock(&amp;m_frame-&gt;animation());
1944 
1945     // FIXME: Do this update per tree scope.
1946     {
1947         auto elements = copyToVectorOf&lt;RefPtr&lt;SVGUseElement&gt;&gt;(m_svgUseElements);
1948         // We can&#39;t clear m_svgUseElements here because updateShadowTree may end up executing arbitrary scripts
1949         // which may insert new SVG use elements or remove existing ones inside sync IPC via ImageLoader::updateFromElement.
1950         for (auto&amp; element : elements)
1951             element-&gt;updateShadowTree();
1952     }
1953 
1954     // FIXME: We should update style on our ancestor chain before proceeding, however doing so at
1955     // the time this comment was originally written caused several tests to crash.
1956 
1957     {
1958         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
1959         styleScope().flushPendingUpdate();
1960         frameView.willRecalcStyle();
1961     }
1962 
1963     InspectorInstrumentation::willRecalculateStyle(*this);
1964 
1965     bool updatedCompositingLayers = false;
1966     {
1967         Style::PostResolutionCallbackDisabler disabler(*this);
1968         WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
1969         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
1970 
1971         m_inStyleRecalc = true;
1972 
1973         if (m_needsFullStyleRebuild)
1974             type = ResolveStyleType::Rebuild;
1975 
1976         if (type == ResolveStyleType::Rebuild) {
1977             // This may get set again during style resolve.
1978             m_hasNodesWithNonFinalStyle = false;
1979             m_hasNodesWithMissingStyle = false;
1980 
1981             auto documentStyle = Style::resolveForDocument(*this);
1982 
1983             // Inserting the pictograph font at the end of the font fallback list is done by the
1984             // font selector, so set a font selector if needed.
1985             if (settings().fontFallbackPrefersPictographs())
1986                 documentStyle.fontCascade().update(&amp;fontSelector());
1987 
1988             auto documentChange = Style::determineChange(documentStyle, m_renderView-&gt;style());
1989             if (documentChange != Style::NoChange)
1990                 renderView()-&gt;setStyle(WTFMove(documentStyle));
1991 
1992             if (auto* documentElement = this-&gt;documentElement())
1993                 documentElement-&gt;invalidateStyleForSubtree();
1994         }
1995 
1996         Style::TreeResolver resolver(*this);
1997         auto styleUpdate = resolver.resolve();
1998 
1999         m_lastStyleUpdateSizeForTesting = styleUpdate ? styleUpdate-&gt;size() : 0;
2000 
2001         setHasValidStyle();
2002         clearChildNeedsStyleRecalc();
2003         unscheduleStyleRecalc();
2004 
2005         m_inStyleRecalc = false;
2006 
2007         if (styleUpdate) {
2008             SetForScope&lt;bool&gt; inRenderTreeUpdate(m_inRenderTreeUpdate, true);
2009 
2010             RenderTreeUpdater updater(*this);
2011             updater.commit(WTFMove(styleUpdate));
2012 
2013             frameView.styleDidChange();
2014         }
2015 
2016         updatedCompositingLayers = frameView.updateCompositingLayersAfterStyleChange();
2017 
2018         if (m_renderView-&gt;needsLayout())
2019             frameView.layoutContext().scheduleLayout();
2020 
2021         // Usually this is handled by post-layout.
2022         if (!frameView.needsLayout())
2023             frameView.frame().selection().scheduleAppearanceUpdateAfterStyleChange();
2024 
2025         // As a result of the style recalculation, the currently hovered element might have been
2026         // detached (for example, by setting display:none in the :hover style), schedule another mouseMove event
2027         // to check if any other elements ended up under the mouse pointer due to re-layout.
2028         if (m_hoveredElement &amp;&amp; !m_hoveredElement-&gt;renderer())
2029             frameView.frame().mainFrame().eventHandler().dispatchFakeMouseMoveEventSoon();
2030 
2031         ++m_styleRecalcCount;
2032         // FIXME: Assert ASSERT(!needsStyleRecalc()) here. Do we still have some cases where it&#39;s not true?
2033     }
2034 
2035     InspectorInstrumentation::didRecalculateStyle(*this);
2036 
2037     // Some animated images may now be inside the viewport due to style recalc,
2038     // resume them if necessary if there is no layout pending. Otherwise, we&#39;ll
2039     // check if they need to be resumed after layout.
2040     if (updatedCompositingLayers &amp;&amp; !frameView.needsLayout())
2041         frameView.viewportContentsChanged();
2042 }
2043 
2044 void Document::updateTextRenderer(Text&amp; text, unsigned offsetOfReplacedText, unsigned lengthOfReplacedText)
2045 {
2046     ASSERT(!m_inRenderTreeUpdate);
2047     SetForScope&lt;bool&gt; inRenderTreeUpdate(m_inRenderTreeUpdate, true);
2048 
2049     auto textUpdate = makeUnique&lt;Style::Update&gt;(*this);
2050     textUpdate-&gt;addText(text, { offsetOfReplacedText, lengthOfReplacedText, WTF::nullopt });
2051 
2052     RenderTreeUpdater renderTreeUpdater(*this);
2053     renderTreeUpdater.commit(WTFMove(textUpdate));
2054 }
2055 
2056 bool Document::needsStyleRecalc() const
2057 {
2058     if (backForwardCacheState() != NotInBackForwardCache)
2059         return false;
2060 
2061     if (m_needsFullStyleRebuild)
2062         return true;
2063 
2064     if (childNeedsStyleRecalc())
2065         return true;
2066 
2067     if (styleScope().hasPendingUpdate())
2068         return true;
2069 
2070     return false;
2071 }
2072 
2073 static bool isSafeToUpdateStyleOrLayout(const Document&amp; document)
2074 {
2075     bool isSafeToExecuteScript = ScriptDisallowedScope::InMainThread::isScriptAllowed();
2076     auto* frameView = document.view();
2077     bool isInFrameFlattening = frameView &amp;&amp; frameView-&gt;isInChildFrameWithFrameFlattening();
2078     return isSafeToExecuteScript || isInFrameFlattening || !isInWebProcess();
2079 }
2080 
2081 bool Document::updateStyleIfNeeded()
2082 {
2083     RefPtr&lt;FrameView&gt; frameView = view();
2084     {
2085         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2086         ASSERT(isMainThread());
2087         ASSERT(!frameView || !frameView-&gt;isPainting());
2088 
2089         if (!frameView || frameView-&gt;layoutContext().isInRenderTreeLayout())
2090             return false;
2091 
2092         styleScope().flushPendingUpdate();
2093 
2094         if (!needsStyleRecalc())
2095             return false;
2096     }
2097 
2098 #if PLATFORM(IOS_FAMILY)
2099     ContentChangeObserver::StyleRecalcScope observingScope(*this);
2100 #endif
2101     // The early exit above for !needsStyleRecalc() is needed when updateWidgetPositions() is called in runOrScheduleAsynchronousTasks().
2102     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(isSafeToUpdateStyleOrLayout(*this));
2103     resolveStyle();
2104     return true;
2105 }
2106 
2107 void Document::updateLayout()
2108 {
2109     ASSERT(isMainThread());
2110 
2111     RefPtr&lt;FrameView&gt; frameView = view();
2112     if (frameView &amp;&amp; frameView-&gt;layoutContext().isInRenderTreeLayout()) {
2113         // View layout should not be re-entrant.
2114         ASSERT_NOT_REACHED();
2115         return;
2116     }
2117     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(isSafeToUpdateStyleOrLayout(*this));
2118 
2119     RenderView::RepaintRegionAccumulator repaintRegionAccumulator(renderView());
2120 
2121     if (HTMLFrameOwnerElement* owner = ownerElement())
2122         owner-&gt;document().updateLayout();
2123 
2124     updateStyleIfNeeded();
2125 
2126     StackStats::LayoutCheckPoint layoutCheckPoint;
2127 
2128     // Only do a layout if changes have occurred that make it necessary.
2129     if (frameView &amp;&amp; renderView() &amp;&amp; (frameView-&gt;layoutContext().isLayoutPending() || renderView()-&gt;needsLayout()))
2130         frameView-&gt;layoutContext().layout();
2131 }
2132 
2133 void Document::updateLayoutIgnorePendingStylesheets(Document::RunPostLayoutTasks runPostLayoutTasks)
2134 {
2135     bool oldIgnore = m_ignorePendingStylesheets;
2136 
2137     if (!haveStylesheetsLoaded()) {
2138         m_ignorePendingStylesheets = true;
2139         // FIXME: This should just invalidate elements with missing styles.
2140         if (m_hasNodesWithMissingStyle)
2141             scheduleFullStyleRebuild();
2142     }
2143 
2144     updateLayout();
2145 
2146     if (runPostLayoutTasks == RunPostLayoutTasks::Synchronously &amp;&amp; view())
2147         view()-&gt;flushAnyPendingPostLayoutTasks();
2148 
2149     m_ignorePendingStylesheets = oldIgnore;
2150 }
2151 
2152 std::unique_ptr&lt;RenderStyle&gt; Document::styleForElementIgnoringPendingStylesheets(Element&amp; element, const RenderStyle* parentStyle, PseudoId pseudoElementSpecifier)
2153 {
2154     ASSERT(&amp;element.document() == this);
2155     ASSERT(!element.isPseudoElement() || pseudoElementSpecifier == PseudoId::None);
2156     ASSERT(pseudoElementSpecifier == PseudoId::None || parentStyle);
2157 
2158     // On iOS request delegates called during styleForElement may result in re-entering WebKit and killing the style resolver.
2159     Style::PostResolutionCallbackDisabler disabler(*this, Style::PostResolutionCallbackDisabler::DrainCallbacks::No);
2160 
2161     SetForScope&lt;bool&gt; change(m_ignorePendingStylesheets, true);
2162     auto&amp; resolver = element.styleResolver();
2163 
2164     if (pseudoElementSpecifier != PseudoId::None)
2165         return resolver.pseudoStyleForElement(element, { pseudoElementSpecifier }, *parentStyle);
2166 
2167     auto elementStyle = resolver.styleForElement(element, parentStyle);
2168     if (elementStyle.relations) {
2169         Style::Update emptyUpdate(*this);
2170         Style::commitRelations(WTFMove(elementStyle.relations), emptyUpdate);
2171     }
2172 
2173     return WTFMove(elementStyle.renderStyle);
2174 }
2175 
2176 bool Document::updateLayoutIfDimensionsOutOfDate(Element&amp; element, DimensionsCheck dimensionsCheck)
2177 {
2178     ASSERT(isMainThread());
2179 
2180     // If the stylesheets haven&#39;t loaded, just give up and do a full layout ignoring pending stylesheets.
2181     if (!haveStylesheetsLoaded()) {
2182         updateLayoutIgnorePendingStylesheets();
2183         return true;
2184     }
2185 
2186     // Check for re-entrancy and assert (same code that is in updateLayout()).
2187     RefPtr&lt;FrameView&gt; frameView = view();
2188     if (frameView &amp;&amp; frameView-&gt;layoutContext().isInRenderTreeLayout()) {
2189         // View layout should not be re-entrant.
2190         ASSERT_NOT_REACHED();
2191         return true;
2192     }
2193 
2194     RenderView::RepaintRegionAccumulator repaintRegionAccumulator(renderView());
2195 
2196     // Mimic the structure of updateLayout(), but at each step, see if we have been forced into doing a full
2197     // layout.
2198     bool requireFullLayout = false;
2199     if (HTMLFrameOwnerElement* owner = ownerElement()) {
2200         if (owner-&gt;document().updateLayoutIfDimensionsOutOfDate(*owner))
2201             requireFullLayout = true;
2202     }
2203 
2204     updateStyleIfNeeded();
2205 
2206     RenderObject* renderer = element.renderer();
2207     if (!renderer || renderer-&gt;needsLayout()) {
2208         // If we don&#39;t have a renderer or if the renderer needs layout for any reason, give up.
2209         requireFullLayout = true;
2210     }
2211 
2212     // Turn off this optimization for input elements with shadow content.
2213     if (is&lt;HTMLInputElement&gt;(element))
2214         requireFullLayout = true;
2215 
2216     bool isVertical = renderer &amp;&amp; !renderer-&gt;isHorizontalWritingMode();
2217     bool checkingLogicalWidth = ((dimensionsCheck &amp; WidthDimensionsCheck) &amp;&amp; !isVertical) || ((dimensionsCheck &amp; HeightDimensionsCheck) &amp;&amp; isVertical);
2218     bool checkingLogicalHeight = ((dimensionsCheck &amp; HeightDimensionsCheck) &amp;&amp; !isVertical) || ((dimensionsCheck &amp; WidthDimensionsCheck) &amp;&amp; isVertical);
2219     bool hasSpecifiedLogicalHeight = renderer &amp;&amp; renderer-&gt;style().logicalMinHeight() == Length(0, Fixed) &amp;&amp; renderer-&gt;style().logicalHeight().isFixed() &amp;&amp; renderer-&gt;style().logicalMaxHeight().isAuto();
2220 
2221     if (!requireFullLayout) {
2222         RenderBox* previousBox = nullptr;
2223         RenderBox* currentBox = nullptr;
2224 
2225         // Check our containing block chain. If anything in the chain needs a layout, then require a full layout.
2226         for (RenderObject* currRenderer = element.renderer(); currRenderer &amp;&amp; !currRenderer-&gt;isRenderView(); currRenderer = currRenderer-&gt;container()) {
2227 
2228             // Require the entire container chain to be boxes.
2229             if (!is&lt;RenderBox&gt;(currRenderer)) {
2230                 requireFullLayout = true;
2231                 break;
2232             }
2233 
2234             previousBox = currentBox;
2235             currentBox = downcast&lt;RenderBox&gt;(currRenderer);
2236 
2237             // If a box needs layout for itself or if a box has changed children and sizes its width to
2238             // its content, then require a full layout.
2239             if (currentBox-&gt;selfNeedsLayout() ||
2240                 (checkingLogicalWidth &amp;&amp; currRenderer-&gt;needsLayout() &amp;&amp; currentBox-&gt;sizesLogicalWidthToFitContent(MainOrPreferredSize))) {
2241                 requireFullLayout = true;
2242                 break;
2243             }
2244 
2245             // If a block contains floats and the child&#39;s height isn&#39;t specified, then
2246             // give up also, since our height could end up being influenced by the floats.
2247             if (checkingLogicalHeight &amp;&amp; !hasSpecifiedLogicalHeight &amp;&amp; currentBox-&gt;isRenderBlockFlow()) {
2248                 RenderBlockFlow* currentBlockFlow = downcast&lt;RenderBlockFlow&gt;(currentBox);
2249                 if (currentBlockFlow-&gt;containsFloats() &amp;&amp; previousBox &amp;&amp; !previousBox-&gt;isFloatingOrOutOfFlowPositioned()) {
2250                     requireFullLayout = true;
2251                     break;
2252                 }
2253             }
2254 
2255             if (!currentBox-&gt;isRenderBlockFlow() || currentBox-&gt;enclosingFragmentedFlow() || currentBox-&gt;isWritingModeRoot()) {
2256                 // FIXME: For now require only block flows all the way back to the root. This limits the optimization
2257                 // for now, and we&#39;ll expand it in future patches to apply to more and more scenarios.
2258                 // Disallow columns from having the optimization.
2259                 // Give up if the writing mode changes at all in the containing block chain.
2260                 requireFullLayout = true;
2261                 break;
2262             }
2263 
2264             if (currRenderer == frameView-&gt;layoutContext().subtreeLayoutRoot())
2265                 break;
2266         }
2267     }
2268 
2269     StackStats::LayoutCheckPoint layoutCheckPoint;
2270 
2271     // Only do a layout if changes have occurred that make it necessary.
2272     if (requireFullLayout &amp;&amp; frameView &amp;&amp; renderView() &amp;&amp; (frameView-&gt;layoutContext().isLayoutPending() || renderView()-&gt;needsLayout()))
2273         frameView-&gt;layoutContext().layout();
2274 
2275     return requireFullLayout;
2276 }
2277 
2278 bool Document::isPageBoxVisible(int pageIndex)
2279 {
2280     updateStyleIfNeeded();
2281     std::unique_ptr&lt;RenderStyle&gt; pageStyle(styleScope().resolver().styleForPage(pageIndex));
2282     return pageStyle-&gt;visibility() != Visibility::Hidden; // display property doesn&#39;t apply to @page.
2283 }
2284 
2285 void Document::pageSizeAndMarginsInPixels(int pageIndex, IntSize&amp; pageSize, int&amp; marginTop, int&amp; marginRight, int&amp; marginBottom, int&amp; marginLeft)
2286 {
2287     updateStyleIfNeeded();
2288     auto style = styleScope().resolver().styleForPage(pageIndex);
2289 
2290     int width = pageSize.width();
2291     int height = pageSize.height();
2292     switch (style-&gt;pageSizeType()) {
2293     case PAGE_SIZE_AUTO:
2294         break;
2295     case PAGE_SIZE_AUTO_LANDSCAPE:
2296         if (width &lt; height)
2297             std::swap(width, height);
2298         break;
2299     case PAGE_SIZE_AUTO_PORTRAIT:
2300         if (width &gt; height)
2301             std::swap(width, height);
2302         break;
2303     case PAGE_SIZE_RESOLVED: {
2304         auto&amp; size = style-&gt;pageSize();
2305         ASSERT(size.width.isFixed());
2306         ASSERT(size.height.isFixed());
2307         width = valueForLength(size.width, 0);
2308         height = valueForLength(size.height, 0);
2309         break;
2310     }
2311     default:
2312         ASSERT_NOT_REACHED();
2313     }
2314     pageSize = IntSize(width, height);
2315 
2316     // The percentage is calculated with respect to the width even for margin top and bottom.
2317     // http://www.w3.org/TR/CSS2/box.html#margin-properties
2318     marginTop = style-&gt;marginTop().isAuto() ? marginTop : intValueForLength(style-&gt;marginTop(), width);
2319     marginRight = style-&gt;marginRight().isAuto() ? marginRight : intValueForLength(style-&gt;marginRight(), width);
2320     marginBottom = style-&gt;marginBottom().isAuto() ? marginBottom : intValueForLength(style-&gt;marginBottom(), width);
2321     marginLeft = style-&gt;marginLeft().isAuto() ? marginLeft : intValueForLength(style-&gt;marginLeft(), width);
2322 }
2323 
2324 Style::Resolver&amp; Document::userAgentShadowTreeStyleResolver()
2325 {
2326     if (!m_userAgentShadowTreeStyleResolver)
2327         m_userAgentShadowTreeStyleResolver = makeUnique&lt;Style::Resolver&gt;(*this);
2328     return *m_userAgentShadowTreeStyleResolver;
2329 }
2330 
2331 void Document::fontsNeedUpdate(FontSelector&amp;)
2332 {
2333     invalidateMatchedPropertiesCacheAndForceStyleRecalc();
2334 }
2335 
2336 void Document::invalidateMatchedPropertiesCacheAndForceStyleRecalc()
2337 {
2338     styleScope().invalidateMatchedDeclarationsCache();
2339 
2340     if (backForwardCacheState() != NotInBackForwardCache || !renderView())
2341         return;
2342     scheduleFullStyleRebuild();
2343 }
2344 
2345 void Document::didClearStyleResolver()
2346 {
2347     m_userAgentShadowTreeStyleResolver = nullptr;
2348 }
2349 
2350 void Document::setIsResolvingTreeStyle(bool value)
2351 {
2352     RELEASE_ASSERT(value != m_isResolvingTreeStyle);
2353     m_isResolvingTreeStyle = value;
2354 }
2355 
2356 void Document::createRenderTree()
2357 {
2358     ASSERT(!renderView());
2359     ASSERT(m_backForwardCacheState != InBackForwardCache);
2360     ASSERT(!m_axObjectCache || this != &amp;topDocument());
2361 
2362     if (m_isNonRenderedPlaceholder)
2363         return;
2364 
2365     // FIXME: It would be better if we could pass the resolved document style directly here.
2366     m_renderView = createRenderer&lt;RenderView&gt;(*this, RenderStyle::create());
2367     Node::setRenderer(m_renderView.get());
2368 
2369     renderView()-&gt;setIsInWindow(true);
2370 
2371     resolveStyle(ResolveStyleType::Rebuild);
2372 }
2373 
2374 void Document::didBecomeCurrentDocumentInFrame()
2375 {
2376     // FIXME: Are there cases where the document can be dislodged from the frame during the event handling below?
2377     // If so, then m_frame could become 0, and we need to do something about that.
2378 
2379     m_frame-&gt;script().updateDocument();
2380 
2381     if (!hasLivingRenderTree())
2382         createRenderTree();
2383 
2384     dispatchDisabledAdaptationsDidChangeForMainFrame();
2385     updateViewportArguments();
2386 
2387     // FIXME: Doing this only for the main frame is insufficient.
2388     // Changing a subframe can also change the wheel event handler count.
2389     // FIXME: Doing this only when a document goes into the frame is insufficient.
2390     // Removing a document can also change the wheel event handler count.
2391     // FIXME: Doing this every time is a waste. If the current document and its
2392     // subframes&#39; documents have no wheel event handlers, then the count did not change,
2393     // unless the documents they are replacing had wheel event handlers.
2394     if (page() &amp;&amp; m_frame-&gt;isMainFrame())
2395         wheelEventHandlersChanged();
2396 
2397     // Ensure that the scheduled task state of the document matches the DOM suspension state of the frame. It can
2398     // be out of sync if the DOM suspension state changed while the document was not in the frame (possibly in the
2399     // back/forward cache, or simply newly created).
2400     if (m_frame-&gt;activeDOMObjectsAndAnimationsSuspended()) {
2401         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
2402             if (auto* timeline = existingTimeline())
2403                 timeline-&gt;suspendAnimations();
2404         } else
2405             m_frame-&gt;animation().suspendAnimationsForDocument(this);
2406         suspendScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
2407     } else {
2408         resumeScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
2409         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
2410             if (auto* timeline = existingTimeline())
2411                 timeline-&gt;resumeAnimations();
2412         } else
2413             m_frame-&gt;animation().resumeAnimationsForDocument(this);
2414     }
2415 }
2416 
2417 void Document::frameDestroyed()
2418 {
2419     // detachFromFrame() must be called before destroying the Frame.
2420     RELEASE_ASSERT(!m_frame);
2421 
2422     if (auto* window = domWindow())
2423         window-&gt;frameDestroyed();
2424 
2425     FrameDestructionObserver::frameDestroyed();
2426 }
2427 
2428 void Document::willDetachPage()
2429 {
2430     FrameDestructionObserver::willDetachPage();
2431 #if PLATFORM(IOS_FAMILY)
2432     contentChangeObserver().willDetachPage();
2433 #endif
2434     if (domWindow() &amp;&amp; frame())
2435         InspectorInstrumentation::frameWindowDiscarded(*frame(), domWindow());
2436 }
2437 
2438 void Document::attachToCachedFrame(CachedFrameBase&amp; cachedFrame)
2439 {
2440     RELEASE_ASSERT(cachedFrame.document() == this);
2441     ASSERT(cachedFrame.view());
2442     ASSERT(m_backForwardCacheState == Document::InBackForwardCache);
2443     observeFrame(&amp;cachedFrame.view()-&gt;frame());
2444 }
2445 
2446 void Document::detachFromCachedFrame(CachedFrameBase&amp; cachedFrame)
2447 {
2448     ASSERT_UNUSED(cachedFrame, cachedFrame.view());
2449     RELEASE_ASSERT(cachedFrame.document() == this);
2450     ASSERT(m_frame == &amp;cachedFrame.view()-&gt;frame());
2451     ASSERT(m_backForwardCacheState == Document::InBackForwardCache);
2452     detachFromFrame();
2453 }
2454 
2455 void Document::destroyRenderTree()
2456 {
2457     ASSERT(hasLivingRenderTree());
2458     ASSERT(frame());
2459     ASSERT(frame()-&gt;document() == this);
2460     ASSERT(page());
2461 
2462     // Prevent Widget tree changes from committing until the RenderView is dead and gone.
2463     WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
2464 
2465     SetForScope&lt;bool&gt; change(m_renderTreeBeingDestroyed, true);
2466 
2467     if (this == &amp;topDocument())
2468         clearAXObjectCache();
2469 
2470     documentWillBecomeInactive();
2471 
2472     if (view())
2473         view()-&gt;willDestroyRenderTree();
2474 
2475     if (m_documentElement)
2476         RenderTreeUpdater::tearDownRenderers(*m_documentElement);
2477 
2478     clearChildNeedsStyleRecalc();
2479 
2480     unscheduleStyleRecalc();
2481 
2482     // FIXME: RenderObject::view() uses m_renderView and we can&#39;t null it before destruction is completed
2483     {
2484         RenderTreeBuilder builder(*m_renderView);
2485         // FIXME: This is a workaround for leftover content (see webkit.org/b/182547).
2486         while (m_renderView-&gt;firstChild())
2487             builder.destroy(*m_renderView-&gt;firstChild());
2488         m_renderView-&gt;destroy();
2489     }
2490     m_renderView.release();
2491 
2492     Node::setRenderer(nullptr);
2493 
2494 #if ENABLE(TEXT_AUTOSIZING)
2495     m_textAutoSizing = nullptr;
2496 #endif
2497 
2498     if (view())
2499         view()-&gt;didDestroyRenderTree();
2500 }
2501 
2502 void Document::prepareForDestruction()
2503 {
2504     if (m_hasPreparedForDestruction)
2505         return;
2506 
2507     if (m_frame)
2508         m_frame-&gt;animation().detachFromDocument(this);
2509 
2510 #if USE(LIBWEBRTC)
2511     // FIXME: This should be moved to Modules/mediastream.
2512     if (LibWebRTCProvider::webRTCAvailable()) {
2513         if (auto* page = this-&gt;page())
2514             page-&gt;libWebRTCProvider().unregisterMDNSNames(identifier().toUInt64());
2515     }
2516 #endif
2517 
2518 #if ENABLE(SERVICE_WORKER)
2519     setActiveServiceWorker(nullptr);
2520     setServiceWorkerConnection(nullptr);
2521 #endif
2522 
2523 #if ENABLE(IOS_TOUCH_EVENTS)
2524     clearTouchEventHandlersAndListeners();
2525 #endif
2526 
2527     m_undoManager-&gt;removeAllItems();
2528 
2529     m_textManipulationController = nullptr; // Free nodes kept alive by TextManipulationController.
2530 
2531 #if ENABLE(ACCESSIBILITY)
2532     if (this != &amp;topDocument()) {
2533         // Let the ax cache know that this subframe goes out of scope.
2534         if (auto* cache = existingAXObjectCache())
2535             cache-&gt;prepareForDocumentDestruction(*this);
2536     }
2537 #endif
2538 
2539     {
2540         NavigationDisabler navigationDisabler(m_frame);
2541         disconnectDescendantFrames();
2542     }
2543     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!m_frame || !m_frame-&gt;tree().childCount());
2544 
2545     if (m_domWindow &amp;&amp; m_frame)
2546         m_domWindow-&gt;willDetachDocumentFromFrame();
2547 
2548     styleScope().clearResolver();
2549 
2550     if (hasLivingRenderTree())
2551         destroyRenderTree();
2552 
2553     if (is&lt;PluginDocument&gt;(*this))
2554         downcast&lt;PluginDocument&gt;(*this).detachFromPluginElement();
2555 
2556 #if ENABLE(POINTER_LOCK)
2557     if (page())
2558         page()-&gt;pointerLockController().documentDetached(*this);
2559 #endif
2560 
2561     if (auto* page = this-&gt;page()) {
2562         if (auto* validationMessageClient = page-&gt;validationMessageClient())
2563             validationMessageClient-&gt;documentDetached(*this);
2564     }
2565 
2566     InspectorInstrumentation::documentDetached(*this);
2567 
2568     commonTeardown();
2569 
2570 #if ENABLE(TOUCH_EVENTS)
2571     if (m_touchEventTargets &amp;&amp; m_touchEventTargets-&gt;size() &amp;&amp; parentDocument())
2572         parentDocument()-&gt;didRemoveEventTargetNode(*this);
2573 #endif
2574 
2575     if (m_wheelEventTargets &amp;&amp; m_wheelEventTargets-&gt;size() &amp;&amp; parentDocument())
2576         parentDocument()-&gt;didRemoveEventTargetNode(*this);
2577 
2578     if (m_mediaQueryMatcher)
2579         m_mediaQueryMatcher-&gt;documentDestroyed();
2580 
2581 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
2582     if (!m_clientToIDMap.isEmpty() &amp;&amp; page()) {
2583         for (auto* client : copyToVector(m_clientToIDMap.keys()))
2584             removePlaybackTargetPickerClient(*client);
2585     }
2586 #endif
2587 
2588     m_cachedResourceLoader-&gt;stopUnusedPreloadsTimer();
2589 
2590     if (page() &amp;&amp; m_mediaState != MediaProducer::IsNotPlaying) {
2591         m_mediaState = MediaProducer::IsNotPlaying;
2592         page()-&gt;updateIsPlayingMedia(HTMLMediaElementInvalidID);
2593     }
2594 
2595     detachFromFrame();
2596 
2597     while (!m_timelines.computesEmpty())
2598         m_timelines.begin()-&gt;detachFromDocument();
2599     m_timeline = nullptr;
2600 
2601 #if ENABLE(CSS_PAINTING_API)
2602     for (auto&amp; scope : m_paintWorkletGlobalScopes.values())
2603         scope-&gt;prepareForDestruction();
2604     m_paintWorkletGlobalScopes.clear();
2605 #endif
2606 
2607     m_hasPreparedForDestruction = true;
2608 
2609     // Note that m_backForwardCacheState can be Document::AboutToEnterBackForwardCache if our frame
2610     // was removed in an onpagehide event handler fired when the top-level frame is
2611     // about to enter the back/forward cache.
2612     RELEASE_ASSERT(m_backForwardCacheState != Document::InBackForwardCache);
2613 }
2614 
2615 void Document::removeAllEventListeners()
2616 {
2617     EventTarget::removeAllEventListeners();
2618 
2619     if (m_domWindow)
2620         m_domWindow-&gt;removeAllEventListeners();
2621 
2622 #if ENABLE(IOS_TOUCH_EVENTS)
2623     clearTouchEventHandlersAndListeners();
2624 #endif
2625     for (Node* node = firstChild(); node; node = NodeTraversal::next(*node))
2626         node-&gt;removeAllEventListeners();
2627 
2628 #if ENABLE(TOUCH_EVENTS)
2629     m_touchEventTargets = nullptr;
2630 #endif
2631     m_wheelEventTargets = nullptr;
2632 }
2633 
2634 void Document::suspendDeviceMotionAndOrientationUpdates()
2635 {
2636     if (m_areDeviceMotionAndOrientationUpdatesSuspended)
2637         return;
2638     m_areDeviceMotionAndOrientationUpdatesSuspended = true;
2639 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
2640     if (m_deviceMotionController)
2641         m_deviceMotionController-&gt;suspendUpdates();
2642     if (m_deviceOrientationController)
2643         m_deviceOrientationController-&gt;suspendUpdates();
2644 #endif
2645 }
2646 
2647 void Document::resumeDeviceMotionAndOrientationUpdates()
2648 {
2649     if (!m_areDeviceMotionAndOrientationUpdatesSuspended)
2650         return;
2651     m_areDeviceMotionAndOrientationUpdatesSuspended = false;
2652 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
2653     if (m_deviceMotionController)
2654         m_deviceMotionController-&gt;resumeUpdates();
2655     if (m_deviceOrientationController)
2656         m_deviceOrientationController-&gt;resumeUpdates();
2657 #endif
2658 }
2659 
2660 bool Document::shouldBypassMainWorldContentSecurityPolicy() const
2661 {
2662     // Bypass this policy when the world is known, and it not the normal world.
2663     JSC::VM&amp; vm = commonVM();
2664     auto&amp; callFrame = *vm.topCallFrame;
2665     return &amp;callFrame != JSC::CallFrame::noCaller() &amp;&amp; !currentWorld(*callFrame.lexicalGlobalObject(vm)).isNormal();
2666 }
2667 
2668 void Document::platformSuspendOrStopActiveDOMObjects()
2669 {
2670 #if PLATFORM(IOS_FAMILY)
2671     contentChangeObserver().didSuspendActiveDOMObjects();
2672 #endif
2673 }
2674 
2675 void Document::suspendActiveDOMObjects(ReasonForSuspension why)
2676 {
2677     if (m_documentTaskGroup)
2678         m_documentTaskGroup-&gt;suspend();
2679     ScriptExecutionContext::suspendActiveDOMObjects(why);
2680     suspendDeviceMotionAndOrientationUpdates();
2681     platformSuspendOrStopActiveDOMObjects();
2682 }
2683 
2684 void Document::resumeActiveDOMObjects(ReasonForSuspension why)
2685 {
2686     if (m_documentTaskGroup)
2687         m_documentTaskGroup-&gt;resume();
2688     ScriptExecutionContext::resumeActiveDOMObjects(why);
2689     resumeDeviceMotionAndOrientationUpdates();
2690     // FIXME: For iOS, do we need to add content change observers that were removed in Document::suspendActiveDOMObjects()?
2691 }
2692 
2693 void Document::stopActiveDOMObjects()
2694 {
2695     if (m_documentTaskGroup)
2696         m_documentTaskGroup-&gt;stopAndDiscardAllTasks();
2697     ScriptExecutionContext::stopActiveDOMObjects();
2698     platformSuspendOrStopActiveDOMObjects();
2699 }
2700 
2701 void Document::clearAXObjectCache()
2702 {
2703     ASSERT(&amp;topDocument() == this);
2704     // Clear the cache member variable before calling delete because attempts
2705     // are made to access it during destruction.
2706     m_axObjectCache = nullptr;
2707 }
2708 
2709 AXObjectCache* Document::existingAXObjectCacheSlow() const
2710 {
2711     ASSERT(hasEverCreatedAnAXObjectCache);
2712     return topDocument().m_axObjectCache.get();
2713 }
2714 
2715 AXObjectCache* Document::axObjectCache() const
2716 {
2717     if (!AXObjectCache::accessibilityEnabled())
2718         return nullptr;
2719 
2720     // The only document that actually has a AXObjectCache is the top-level
2721     // document.  This is because we need to be able to get from any WebCoreAXObject
2722     // to any other WebCoreAXObject on the same page.  Using a single cache allows
2723     // lookups across nested webareas (i.e. multiple documents).
2724     Document&amp; topDocument = this-&gt;topDocument();
2725 
2726     // If the document has already been detached, do not make a new axObjectCache.
2727     if (!topDocument.hasLivingRenderTree())
2728         return nullptr;
2729 
2730     ASSERT(&amp;topDocument == this || !m_axObjectCache);
2731     if (!topDocument.m_axObjectCache) {
2732         topDocument.m_axObjectCache = makeUnique&lt;AXObjectCache&gt;(topDocument);
2733         hasEverCreatedAnAXObjectCache = true;
2734     }
2735     return topDocument.m_axObjectCache.get();
2736 }
2737 
2738 void Document::setVisuallyOrdered()
2739 {
2740     m_visuallyOrdered = true;
2741     if (renderView())
2742         renderView()-&gt;mutableStyle().setRTLOrdering(Order::Visual);
2743 }
2744 
2745 Ref&lt;DocumentParser&gt; Document::createParser()
2746 {
2747     // FIXME: this should probably pass the frame instead
2748     return XMLDocumentParser::create(*this, view());
2749 }
2750 
2751 HighlightMap&amp; Document::highlightMap()
2752 {
2753     if (!m_highlightMap)
2754         m_highlightMap = HighlightMap::create();
2755     return *m_highlightMap;
2756 }
2757 
2758 void Document::updateHighlightPositions()
2759 {
2760     Vector&lt;WeakPtr&lt;HighlightRangeData&gt;&gt; rangesData;
2761     if (m_highlightMap) {
2762         for (auto&amp; highlight : m_highlightMap-&gt;map()) {
2763             for (auto&amp; rangeData : highlight.value-&gt;rangesData()) {
2764                 if (rangeData-&gt;startPosition &amp;&amp; rangeData-&gt;endPosition)
2765                     continue;
2766                 if (&amp;rangeData-&gt;range-&gt;startContainer()-&gt;treeScope() != &amp;rangeData-&gt;range-&gt;endContainer()-&gt;treeScope())
2767                     continue;
2768                 rangesData.append(makeWeakPtr(rangeData.ptr()));
2769             }
2770         }
2771     }
2772 
2773     for (auto&amp; weakRangeData : rangesData) {
2774         if (auto* rangeData = weakRangeData.get()) {
2775             VisibleSelection visibleSelection(rangeData-&gt;range);
2776             Position startPosition;
2777             Position endPosition;
2778             if (!rangeData-&gt;startPosition.hasValue())
2779                 startPosition = visibleSelection.visibleStart().deepEquivalent();
2780             if (!rangeData-&gt;endPosition.hasValue())
2781                 endPosition = visibleSelection.visibleEnd().deepEquivalent(); // &lt;MMG&gt; switch to END
2782             if (!weakRangeData.get())
2783                 continue;
2784 
2785             rangeData-&gt;startPosition = startPosition;
2786             rangeData-&gt;endPosition = endPosition;
2787         }
2788     }
2789 }
2790 
2791 ScriptableDocumentParser* Document::scriptableDocumentParser() const
2792 {
2793     return parser() ? parser()-&gt;asScriptableDocumentParser() : nullptr;
2794 }
2795 
2796 ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; Document::openForBindings(DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const String&amp; url, const AtomString&amp; name, const String&amp; features)
2797 {
2798     if (!m_domWindow)
2799         return Exception { InvalidAccessError };
2800 
2801     return m_domWindow-&gt;open(activeWindow, firstWindow, url, name, features);
2802 }
2803 
2804 ExceptionOr&lt;Document&amp;&gt; Document::openForBindings(Document* responsibleDocument, const String&amp;, const String&amp;)
2805 {
2806     if (!isHTMLDocument() || m_throwOnDynamicMarkupInsertionCount)
2807         return Exception { InvalidStateError };
2808 
2809     auto result = open(responsibleDocument);
2810     if (UNLIKELY(result.hasException()))
2811         return result.releaseException();
2812 
2813     return *this;
2814 }
2815 
2816 ExceptionOr&lt;void&gt; Document::open(Document* responsibleDocument)
2817 {
2818     if (responsibleDocument &amp;&amp; !responsibleDocument-&gt;securityOrigin().isSameOriginAs(securityOrigin()))
2819         return Exception { SecurityError };
2820 
2821     if (m_ignoreOpensDuringUnloadCount)
2822         return { };
2823 
2824     if (m_activeParserWasAborted)
2825         return { };
2826 
2827     if (m_frame) {
2828         if (ScriptableDocumentParser* parser = scriptableDocumentParser()) {
2829             if (parser-&gt;isParsing()) {
2830                 // FIXME: HTML5 doesn&#39;t tell us to check this, it might not be correct.
2831                 if (parser-&gt;isExecutingScript())
2832                     return { };
2833 
2834                 if (!parser-&gt;wasCreatedByScript() &amp;&amp; parser-&gt;hasInsertionPoint())
2835                     return { };
2836             }
2837         }
2838 
2839         if (m_frame-&gt;loader().policyChecker().delegateIsDecidingNavigationPolicy())
2840             m_frame-&gt;loader().policyChecker().stopCheck();
2841         if (m_frame &amp;&amp; m_frame-&gt;loader().state() == FrameStateProvisional)
2842             m_frame-&gt;loader().stopAllLoaders();
2843     }
2844 
2845     removeAllEventListeners();
2846 
2847     if (responsibleDocument &amp;&amp; isFullyActive()) {
2848         auto newURL = responsibleDocument-&gt;url();
2849         if (responsibleDocument != this)
2850             newURL.removeFragmentIdentifier();
2851         setURL(newURL);
2852         auto newCookieURL = responsibleDocument-&gt;cookieURL();
2853         if (responsibleDocument != this)
2854             newCookieURL.removeFragmentIdentifier();
2855         setCookieURL(newCookieURL);
2856         setSecurityOriginPolicy(responsibleDocument-&gt;securityOriginPolicy());
2857     }
2858 
2859     implicitOpen();
2860     if (ScriptableDocumentParser* parser = scriptableDocumentParser())
2861         parser-&gt;setWasCreatedByScript(true);
2862 
2863     if (m_frame)
2864         m_frame-&gt;loader().didExplicitOpen();
2865 
2866     return { };
2867 }
2868 
2869 // https://html.spec.whatwg.org/#fully-active
2870 bool Document::isFullyActive() const
2871 {
2872     auto* frame = this-&gt;frame();
2873     if (!frame || frame-&gt;document() != this)
2874         return false;
2875 
2876     if (frame-&gt;isMainFrame())
2877         return true;
2878 
2879     auto* parentFrame = frame-&gt;tree().parent();
2880     return parentFrame &amp;&amp; parentFrame-&gt;document() &amp;&amp; parentFrame-&gt;document()-&gt;isFullyActive();
2881 }
2882 
2883 void Document::detachParser()
2884 {
2885     if (!m_parser)
2886         return;
2887     m_parser-&gt;detach();
2888     m_parser = nullptr;
2889 }
2890 
2891 void Document::cancelParsing()
2892 {
2893     if (!m_parser)
2894         return;
2895 
2896     if (m_parser-&gt;processingData())
2897         m_activeParserWasAborted = true;
2898 
2899     // We have to clear the parser to avoid possibly triggering
2900     // the onload handler when closing as a side effect of a cancel-style
2901     // change, such as opening a new document or closing the window while
2902     // still parsing
2903     detachParser();
2904     explicitClose();
2905 }
2906 
2907 void Document::implicitOpen()
2908 {
2909     removeChildren();
2910 
2911     setCompatibilityMode(DocumentCompatibilityMode::NoQuirksMode);
2912 
2913     detachParser();
2914     m_parser = createParser();
2915 
2916     if (hasActiveParserYieldToken())
2917         m_parser-&gt;didBeginYieldingParser();
2918 
2919     setParsing(true);
2920     setReadyState(Loading);
2921 }
2922 
2923 HTMLBodyElement* Document::body() const
2924 {
2925     auto* element = documentElement();
2926     if (!is&lt;HTMLHtmlElement&gt;(element))
2927         return nullptr;
2928     return childrenOfType&lt;HTMLBodyElement&gt;(*element).first();
2929 }
2930 
2931 HTMLElement* Document::bodyOrFrameset() const
2932 {
2933     // Return the first body or frameset child of the html element.
2934     auto* element = documentElement();
2935     if (!is&lt;HTMLHtmlElement&gt;(element))
2936         return nullptr;
2937     for (auto&amp; child : childrenOfType&lt;HTMLElement&gt;(*element)) {
2938         if (is&lt;HTMLBodyElement&gt;(child) || is&lt;HTMLFrameSetElement&gt;(child))
2939             return &amp;child;
2940     }
2941     return nullptr;
2942 }
2943 
2944 ExceptionOr&lt;void&gt; Document::setBodyOrFrameset(RefPtr&lt;HTMLElement&gt;&amp;&amp; newBody)
2945 {
2946     if (!is&lt;HTMLBodyElement&gt;(newBody) &amp;&amp; !is&lt;HTMLFrameSetElement&gt;(newBody))
2947         return Exception { HierarchyRequestError };
2948 
2949     auto* currentBody = bodyOrFrameset();
2950     if (newBody == currentBody)
2951         return { };
2952 
2953     if (!m_documentElement)
2954         return Exception { HierarchyRequestError };
2955 
2956     if (currentBody)
2957         return m_documentElement-&gt;replaceChild(*newBody, *currentBody);
2958     return m_documentElement-&gt;appendChild(*newBody);
2959 }
2960 
2961 Location* Document::location() const
2962 {
2963     auto* window = domWindow();
2964     return window ? &amp;window-&gt;location() : nullptr;
2965 }
2966 
2967 HTMLHeadElement* Document::head()
2968 {
2969     if (auto element = documentElement())
2970         return childrenOfType&lt;HTMLHeadElement&gt;(*element).first();
2971     return nullptr;
2972 }
2973 
2974 ExceptionOr&lt;void&gt; Document::closeForBindings()
2975 {
2976     // FIXME: We should follow the specification more closely:
2977     //        http://www.whatwg.org/specs/web-apps/current-work/#dom-document-close
2978 
2979     if (!isHTMLDocument() || m_throwOnDynamicMarkupInsertionCount)
2980         return Exception { InvalidStateError };
2981 
2982     close();
2983     return { };
2984 }
2985 
2986 void Document::close()
2987 {
2988     if (!scriptableDocumentParser() || !scriptableDocumentParser()-&gt;wasCreatedByScript() || !scriptableDocumentParser()-&gt;isParsing())
2989         return;
2990 
2991     explicitClose();
2992 }
2993 
2994 void Document::explicitClose()
2995 {
2996     if (RefPtr&lt;DocumentParser&gt; parser = m_parser)
2997         parser-&gt;finish();
2998 
2999     if (!m_frame) {
3000         // Because we have no frame, we don&#39;t know if all loading has completed,
3001         // so we just call implicitClose() immediately. FIXME: This might fire
3002         // the load event prematurely &lt;http://bugs.webkit.org/show_bug.cgi?id=14568&gt;.
3003         implicitClose();
3004         return;
3005     }
3006 
3007     checkCompleted();
3008 }
3009 
3010 void Document::implicitClose()
3011 {
3012     RELEASE_ASSERT(!m_inStyleRecalc);
3013     bool wasLocationChangePending = frame() &amp;&amp; frame()-&gt;navigationScheduler().locationChangePending();
3014     bool doload = !parsing() &amp;&amp; m_parser &amp;&amp; !m_processingLoadEvent &amp;&amp; !wasLocationChangePending;
3015 
3016     if (!doload)
3017         return;
3018 
3019     // Call to dispatchWindowLoadEvent can blow us from underneath.
3020     Ref&lt;Document&gt; protectedThis(*this);
3021 
3022     m_processingLoadEvent = true;
3023 
3024     ScriptableDocumentParser* parser = scriptableDocumentParser();
3025     m_wellFormed = parser &amp;&amp; parser-&gt;wellFormed();
3026 
3027     // We have to clear the parser, in case someone document.write()s from the
3028     // onLoad event handler, as in Radar 3206524.
3029     detachParser();
3030 
3031     // FIXME: We kick off the icon loader when the Document is done parsing.
3032     // There are earlier opportunities we could start it:
3033     //  -When the &lt;head&gt; finishes parsing
3034     //  -When any new HTMLLinkElement is inserted into the document
3035     // But those add a dynamic component to the favicon that has UI
3036     // ramifications, and we need to decide what is the Right Thing To Do(tm)
3037     RefPtr&lt;Frame&gt; f = frame();
3038     if (f) {
3039 #if ENABLE(XSLT)
3040         // Apply XSL transforms before load events so that event handlers can access the transformed DOM tree.
3041         applyPendingXSLTransformsNowIfScheduled();
3042 #endif
3043 
3044         if (auto* documentLoader = loader())
3045             documentLoader-&gt;startIconLoading();
3046 
3047         f-&gt;animation().startAnimationsIfNotSuspended(this);
3048 
3049         // FIXME: We shouldn&#39;t be dispatching pending events globally on all Documents here.
3050         // For now, only do this when there is a Frame, otherwise this could cause JS reentrancy
3051         // below SVG font parsing, for example. &lt;https://webkit.org/b/136269&gt;
3052         ImageLoader::dispatchPendingBeforeLoadEvents();
3053         ImageLoader::dispatchPendingLoadEvents();
3054         ImageLoader::dispatchPendingErrorEvents();
3055         HTMLLinkElement::dispatchPendingLoadEvents();
3056         HTMLStyleElement::dispatchPendingLoadEvents();
3057 
3058         if (svgExtensions())
3059             accessSVGExtensions().dispatchLoadEventToOutermostSVGElements();
3060     }
3061 
3062     dispatchWindowLoadEvent();
3063     dispatchPageshowEvent(PageshowEventNotPersisted);
3064     if (m_pendingStateObject)
3065         dispatchPopstateEvent(WTFMove(m_pendingStateObject));
3066 
3067     if (f)
3068         f-&gt;loader().dispatchOnloadEvents();
3069 
3070     // An event handler may have removed the frame
3071     if (!frame()) {
3072         m_processingLoadEvent = false;
3073         return;
3074     }
3075 
3076     // Make sure both the initial layout and reflow happen after the onload
3077     // fires. This will improve onload scores, and other browsers do it.
3078     // If they wanna cheat, we can too. -dwh
3079 
3080     if (frame()-&gt;navigationScheduler().locationChangePending() &amp;&amp; timeSinceDocumentCreation() &lt; settings().layoutInterval()) {
3081         // Just bail out. Before or during the onload we were shifted to another page.
3082         // The old i-Bench suite does this. When this happens don&#39;t bother painting or laying out.
3083         m_processingLoadEvent = false;
3084         view()-&gt;layoutContext().unscheduleLayout();
3085         return;
3086     }
3087 
3088     frame()-&gt;loader().checkCallImplicitClose();
3089 
3090     // We used to force a synchronous display and flush here.  This really isn&#39;t
3091     // necessary and can in fact be actively harmful if pages are loading at a rate of &gt; 60fps
3092     // (if your platform is syncing flushes and limiting them to 60fps).
3093     m_overMinimumLayoutThreshold = true;
3094     if (!ownerElement() || (ownerElement()-&gt;renderer() &amp;&amp; !ownerElement()-&gt;renderer()-&gt;needsLayout())) {
3095         updateStyleIfNeeded();
3096 
3097         // Always do a layout after loading if needed.
3098         if (view() &amp;&amp; renderView() &amp;&amp; (!renderView()-&gt;firstChild() || renderView()-&gt;needsLayout()))
3099             view()-&gt;layoutContext().layout();
3100     }
3101 
3102     m_processingLoadEvent = false;
3103 
3104     if (auto fontFaceSet = makeRefPtr(fontSelector().fontFaceSetIfExists()))
3105         fontFaceSet-&gt;documentDidFinishLoading();
3106 
3107 #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
3108     if (f &amp;&amp; hasLivingRenderTree() &amp;&amp; AXObjectCache::accessibilityEnabled()) {
3109         // The AX cache may have been cleared at this point, but we need to make sure it contains an
3110         // AX object to send the notification to. getOrCreate will make sure that an valid AX object
3111         // exists in the cache (we ignore the return value because we don&#39;t need it here). This is
3112         // only safe to call when a layout is not in progress, so it can not be used in postNotification.
3113         //
3114         // This notification is now called AXNewDocumentLoadComplete because there are other handlers that will
3115         // catch new AND page history loads, and that uses AXLoadComplete
3116 
3117         axObjectCache()-&gt;getOrCreate(renderView());
3118         if (this == &amp;topDocument())
3119             axObjectCache()-&gt;postNotification(renderView(), AXObjectCache::AXNewDocumentLoadComplete);
3120         else {
3121             // AXLoadComplete can only be posted on the top document, so if it&#39;s a document
3122             // in an iframe that just finished loading, post AXLayoutComplete instead.
3123             axObjectCache()-&gt;postNotification(renderView(), AXObjectCache::AXLayoutComplete);
3124         }
3125     }
3126 #endif
3127 
3128     if (svgExtensions())
3129         accessSVGExtensions().startAnimations();
3130 }
3131 
3132 void Document::setParsing(bool b)
3133 {
3134     m_bParsing = b;
3135 
3136     if (m_bParsing &amp;&amp; !m_sharedObjectPool)
3137         m_sharedObjectPool = makeUnique&lt;DocumentSharedObjectPool&gt;();
3138 
3139     if (!m_bParsing &amp;&amp; view() &amp;&amp; !view()-&gt;needsLayout())
3140         view()-&gt;fireLayoutRelatedMilestonesIfNeeded();
3141 }
3142 
3143 bool Document::shouldScheduleLayout()
3144 {
3145     if (!documentElement())
3146         return false;
3147     if (!is&lt;HTMLHtmlElement&gt;(*documentElement()))
3148         return true;
3149     if (!bodyOrFrameset())
3150         return false;
3151     if (styleScope().hasPendingSheetsBeforeBody())
3152         return false;
3153     if (page() &amp;&amp; page()-&gt;chrome().client().layerFlushThrottlingIsActive() &amp;&amp; view() &amp;&amp; view()-&gt;isVisuallyNonEmpty())
3154         return false;
3155 
3156     return true;
3157 }
3158 
3159 bool Document::isLayoutTimerActive()
3160 {
3161     return view() &amp;&amp; view()-&gt;layoutContext().isLayoutPending() &amp;&amp; !minimumLayoutDelay();
3162 }
3163 
3164 Seconds Document::minimumLayoutDelay()
3165 {
3166     if (m_overMinimumLayoutThreshold)
3167         return 0_s;
3168 
3169     auto elapsed = timeSinceDocumentCreation();
3170     m_overMinimumLayoutThreshold = elapsed &gt; settings().layoutInterval();
3171 
3172     // We&#39;ll want to schedule the timer to fire at the minimum layout threshold.
3173     return std::max(0_s, settings().layoutInterval() - elapsed);
3174 }
3175 
3176 Seconds Document::timeSinceDocumentCreation() const
3177 {
3178     return MonotonicTime::now() - m_documentCreationTime;
3179 }
3180 
3181 ExceptionOr&lt;void&gt; Document::write(Document* responsibleDocument, SegmentedString&amp;&amp; text)
3182 {
3183     if (m_activeParserWasAborted)
3184         return { };
3185 
3186     NestingLevelIncrementer nestingLevelIncrementer(m_writeRecursionDepth);
3187 
3188     m_writeRecursionIsTooDeep = (m_writeRecursionDepth &gt; 1) &amp;&amp; m_writeRecursionIsTooDeep;
3189     m_writeRecursionIsTooDeep = (m_writeRecursionDepth &gt; cMaxWriteRecursionDepth) || m_writeRecursionIsTooDeep;
3190 
3191     if (m_writeRecursionIsTooDeep)
3192         return { };
3193 
3194     bool hasInsertionPoint = m_parser &amp;&amp; m_parser-&gt;hasInsertionPoint();
3195     if (!hasInsertionPoint &amp;&amp; (m_ignoreOpensDuringUnloadCount || m_ignoreDestructiveWriteCount))
3196         return { };
3197 
3198     if (!hasInsertionPoint) {
3199         auto result = open(responsibleDocument);
3200         if (UNLIKELY(result.hasException()))
3201             return result.releaseException();
3202     }
3203 
3204     ASSERT(m_parser);
3205     m_parser-&gt;insert(WTFMove(text));
3206     return { };
3207 }
3208 
3209 ExceptionOr&lt;void&gt; Document::write(Document* responsibleDocument, Vector&lt;String&gt;&amp;&amp; strings)
3210 {
3211     if (!isHTMLDocument() || m_throwOnDynamicMarkupInsertionCount)
3212         return Exception { InvalidStateError };
3213 
3214     SegmentedString text;
3215     for (auto&amp; string : strings)
3216         text.append(WTFMove(string));
3217 
3218     return write(responsibleDocument, WTFMove(text));
3219 }
3220 
3221 ExceptionOr&lt;void&gt; Document::writeln(Document* responsibleDocument, Vector&lt;String&gt;&amp;&amp; strings)
3222 {
3223     if (!isHTMLDocument() || m_throwOnDynamicMarkupInsertionCount)
3224         return Exception { InvalidStateError };
3225 
3226     SegmentedString text;
3227     for (auto&amp; string : strings)
3228         text.append(WTFMove(string));
3229 
3230     text.append(&quot;\n&quot;_s);
3231     return write(responsibleDocument, WTFMove(text));
3232 }
3233 
3234 Seconds Document::minimumDOMTimerInterval() const
3235 {
3236     auto* page = this-&gt;page();
3237     if (!page)
3238         return ScriptExecutionContext::minimumDOMTimerInterval();
3239     return page-&gt;settings().minimumDOMTimerInterval();
3240 }
3241 
3242 void Document::setTimerThrottlingEnabled(bool shouldThrottle)
3243 {
3244     if (m_isTimerThrottlingEnabled == shouldThrottle)
3245         return;
3246 
3247     m_isTimerThrottlingEnabled = shouldThrottle;
3248     didChangeTimerAlignmentInterval();
3249 }
3250 
3251 Seconds Document::domTimerAlignmentInterval(bool hasReachedMaxNestingLevel) const
3252 {
3253     auto alignmentInterval = ScriptExecutionContext::domTimerAlignmentInterval(hasReachedMaxNestingLevel);
3254     if (!hasReachedMaxNestingLevel)
3255         return alignmentInterval;
3256 
3257     // Apply Document-level DOMTimer throttling only if timers have reached their maximum nesting level as the Page may still be visible.
3258     if (m_isTimerThrottlingEnabled)
3259         alignmentInterval = std::max(alignmentInterval, DOMTimer::hiddenPageAlignmentInterval());
3260 
3261     if (Page* page = this-&gt;page())
3262         alignmentInterval = std::max(alignmentInterval, page-&gt;domTimerAlignmentInterval());
3263 
3264     if (!topOrigin().canAccess(securityOrigin()) &amp;&amp; !hasHadUserInteraction())
3265         alignmentInterval = std::max(alignmentInterval, DOMTimer::nonInteractedCrossOriginFrameAlignmentInterval());
3266 
3267     return alignmentInterval;
3268 }
3269 
3270 EventTarget* Document::errorEventTarget()
3271 {
3272     return m_domWindow.get();
3273 }
3274 
3275 void Document::logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp; callStack)
3276 {
3277     addMessage(MessageSource::JS, MessageLevel::Error, errorMessage, sourceURL, lineNumber, columnNumber, WTFMove(callStack));
3278 }
3279 
3280 void Document::setURL(const URL&amp; url)
3281 {
3282     const URL&amp; newURL = url.isEmpty() ? WTF::blankURL() : url;
3283     if (newURL == m_url)
3284         return;
3285 
3286     m_url = newURL;
3287     if (SecurityOrigin::shouldIgnoreHost(m_url))
3288         m_url.removeHostAndPort();
3289 
3290     m_documentURI = m_url.string();
3291     updateBaseURL();
3292 }
3293 
3294 void Document::updateBaseURL()
3295 {
3296     URL oldBaseURL = m_baseURL;
3297     // DOM 3 Core: When the Document supports the feature &quot;HTML&quot; [DOM Level 2 HTML], the base URI is computed using
3298     // first the value of the href attribute of the HTML BASE element if any, and the value of the documentURI attribute
3299     // from the Document interface otherwise.
3300     if (!m_baseElementURL.isEmpty())
3301         m_baseURL = m_baseElementURL;
3302     else if (!m_baseURLOverride.isEmpty())
3303         m_baseURL = m_baseURLOverride;
3304     else {
3305         // The documentURI attribute is read-only from JavaScript, but writable from Objective C, so we need to retain
3306         // this fallback behavior. We use a null base URL, since the documentURI attribute is an arbitrary string
3307         // and DOM 3 Core does not specify how it should be resolved.
3308         m_baseURL = URL({ }, documentURI());
3309     }
3310 
3311     clearSelectorQueryCache();
3312 
3313     if (!m_baseURL.isValid())
3314         m_baseURL = URL();
3315 }
3316 
3317 void Document::setBaseURLOverride(const URL&amp; url)
3318 {
3319     m_baseURLOverride = url;
3320     updateBaseURL();
3321 }
3322 
3323 void Document::processBaseElement()
3324 {
3325     // Find the first href attribute in a base element and the first target attribute in a base element.
3326     const AtomString* href = nullptr;
3327     const AtomString* target = nullptr;
3328     auto baseDescendants = descendantsOfType&lt;HTMLBaseElement&gt;(*this);
3329     for (auto&amp; base : baseDescendants) {
3330         if (!href) {
3331             const AtomString&amp; value = base.attributeWithoutSynchronization(hrefAttr);
3332             if (!value.isNull()) {
3333                 href = &amp;value;
3334                 if (target)
3335                     break;
3336             }
3337         }
3338         if (!target) {
3339             const AtomString&amp; value = base.attributeWithoutSynchronization(targetAttr);
3340             if (!value.isNull()) {
3341                 target = &amp;value;
3342                 if (href)
3343                     break;
3344             }
3345         }
3346     }
3347 
3348     // FIXME: Since this doesn&#39;t share code with completeURL it may not handle encodings correctly.
3349     URL baseElementURL;
3350     if (href) {
3351         String strippedHref = stripLeadingAndTrailingHTMLSpaces(*href);
3352         if (!strippedHref.isEmpty())
3353             baseElementURL = URL(url(), strippedHref);
3354     }
3355     if (m_baseElementURL != baseElementURL &amp;&amp; contentSecurityPolicy()-&gt;allowBaseURI(baseElementURL)) {
3356         if (settings().shouldRestrictBaseURLSchemes() &amp;&amp; !SecurityPolicy::isBaseURLSchemeAllowed(baseElementURL))
3357             addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Blocked setting &quot; + baseElementURL.stringCenterEllipsizedToLength() + &quot; as the base URL because it does not have an allowed scheme.&quot;);
3358         else {
3359             m_baseElementURL = baseElementURL;
3360             updateBaseURL();
3361         }
3362     }
3363 
3364     m_baseTarget = target ? *target : nullAtom();
3365 }
3366 
3367 String Document::userAgent(const URL&amp; url) const
3368 {
3369     return frame() ? frame()-&gt;loader().userAgent(url) : String();
3370 }
3371 
3372 void Document::disableEval(const String&amp; errorMessage)
3373 {
3374     if (!frame())
3375         return;
3376 
3377     frame()-&gt;script().disableEval(errorMessage);
3378 }
3379 
3380 void Document::disableWebAssembly(const String&amp; errorMessage)
3381 {
3382     if (!frame())
3383         return;
3384 
3385     frame()-&gt;script().disableWebAssembly(errorMessage);
3386 }
3387 
3388 #if ENABLE(INDEXED_DATABASE)
3389 IDBClient::IDBConnectionProxy* Document::idbConnectionProxy()
3390 {
3391     if (!m_idbConnectionProxy) {
3392         Page* currentPage = page();
3393         if (!currentPage)
3394             return nullptr;
3395         m_idbConnectionProxy = &amp;currentPage-&gt;idbConnection().proxy();
3396     }
3397     return m_idbConnectionProxy.get();
3398 }
3399 #endif
3400 
3401 SocketProvider* Document::socketProvider()
3402 {
3403     return m_socketProvider.get();
3404 }
3405 
3406 bool Document::canNavigate(Frame* targetFrame, const URL&amp; destinationURL)
3407 {
3408     if (!m_frame)
3409         return false;
3410 
3411     // FIXME: We shouldn&#39;t call this function without a target frame, but
3412     // fast/forms/submit-to-blank-multiple-times.html depends on this function
3413     // returning true when supplied with a 0 targetFrame.
3414     if (!targetFrame)
3415         return true;
3416 
3417     if (!canNavigateInternal(*targetFrame))
3418         return false;
3419 
3420     if (isNavigationBlockedByThirdPartyIFrameRedirectBlocking(*targetFrame, destinationURL)) {
3421         printNavigationErrorMessage(*targetFrame, url(), &quot;The frame attempting navigation of the top-level window is cross-origin or untrusted and the user has never interacted with the frame.&quot;_s);
3422         return false;
3423     }
3424 
3425     return true;
3426 }
3427 
3428 bool Document::canNavigateInternal(Frame&amp; targetFrame)
3429 {
3430     ASSERT(m_frame);
3431 
3432     // Cases (i), (ii) and (iii) pass the tests from the specifications but might not pass the &quot;security origin&quot; tests.
3433 
3434     // i. A frame can navigate its top ancestor when its &#39;allow-top-navigation&#39; flag is set (sometimes known as &#39;frame-busting&#39;).
3435     if (!isSandboxed(SandboxTopNavigation) &amp;&amp; &amp;targetFrame == &amp;m_frame-&gt;tree().top())
3436         return true;
3437 
3438     // ii. A frame can navigate its top ancestor when its &#39;allow-top-navigation-by-user-activation&#39; flag is set and navigation is triggered by user activation.
3439     if (!isSandboxed(SandboxTopNavigationByUserActivation) &amp;&amp; UserGestureIndicator::processingUserGesture() &amp;&amp; &amp;targetFrame == &amp;m_frame-&gt;tree().top())
3440         return true;
3441 
3442     // iii. A sandboxed frame can always navigate its descendants.
3443     if (isSandboxed(SandboxNavigation) &amp;&amp; targetFrame.tree().isDescendantOf(m_frame))
3444         return true;
3445 
3446     // From https://html.spec.whatwg.org/multipage/browsers.html#allowed-to-navigate.
3447     // 1. If A is not the same browsing context as B, and A is not one of the ancestor browsing contexts of B, and B is not a top-level browsing context, and A&#39;s active document&#39;s active sandboxing
3448     // flag set has its sandboxed navigation browsing context flag set, then abort these steps negatively.
3449     if (m_frame != &amp;targetFrame &amp;&amp; isSandboxed(SandboxNavigation) &amp;&amp; targetFrame.tree().parent() &amp;&amp; !targetFrame.tree().isDescendantOf(m_frame)) {
3450         printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation is sandboxed, and is therefore disallowed from navigating its ancestors.&quot;_s);
3451         return false;
3452     }
3453 
3454     // 2. Otherwise, if B is a top-level browsing context, and is one of the ancestor browsing contexts of A, then:
3455     if (m_frame != &amp;targetFrame &amp;&amp; &amp;targetFrame == &amp;m_frame-&gt;tree().top()) {
3456         bool triggeredByUserActivation = UserGestureIndicator::processingUserGesture();
3457         // 1. If this algorithm is triggered by user activation and A&#39;s active document&#39;s active sandboxing flag set has its sandboxed top-level navigation with user activation browsing context flag set, then abort these steps negatively.
3458         if (triggeredByUserActivation &amp;&amp; isSandboxed(SandboxTopNavigationByUserActivation)) {
3459             printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation of the top-level window is sandboxed, but the &#39;allow-top-navigation-by-user-activation&#39; flag is not set and navigation is not triggered by user activation.&quot;_s);
3460             return false;
3461         }
3462         // 2. Otherwise, If this algorithm is not triggered by user activation and A&#39;s active document&#39;s active sandboxing flag set has its sandboxed top-level navigation without user activation browsing context flag set, then abort these steps negatively.
3463         if (!triggeredByUserActivation &amp;&amp; isSandboxed(SandboxTopNavigation)) {
3464             printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation of the top-level window is sandboxed, but the &#39;allow-top-navigation&#39; flag is not set.&quot;_s);
3465             return false;
3466         }
3467     }
3468 
3469     // 3. Otherwise, if B is a top-level browsing context, and is neither A nor one of the ancestor browsing contexts of A, and A&#39;s Document&#39;s active sandboxing flag set has its
3470     // sandboxed navigation browsing context flag set, and A is not the one permitted sandboxed navigator of B, then abort these steps negatively.
3471     if (!targetFrame.tree().parent() &amp;&amp; m_frame != &amp;targetFrame &amp;&amp; &amp;targetFrame != &amp;m_frame-&gt;tree().top() &amp;&amp; isSandboxed(SandboxNavigation) &amp;&amp; targetFrame.loader().opener() != m_frame) {
3472         printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation is sandboxed, and is not allowed to navigate this popup.&quot;_s);
3473         return false;
3474     }
3475 
3476     // 4. Otherwise, terminate positively!
3477 
3478     // This is the normal case. A document can navigate its descendant frames,
3479     // or, more generally, a document can navigate a frame if the document is
3480     // in the same origin as any of that frame&#39;s ancestors (in the frame
3481     // hierarchy).
3482     //
3483     // See http://www.adambarth.com/papers/2008/barth-jackson-mitchell.pdf for
3484     // historical information about this security check.
3485     if (canAccessAncestor(securityOrigin(), &amp;targetFrame))
3486         return true;
3487 
3488     // Top-level frames are easier to navigate than other frames because they
3489     // display their URLs in the address bar (in most browsers). However, there
3490     // are still some restrictions on navigation to avoid nuisance attacks.
3491     // Specifically, a document can navigate a top-level frame if that frame
3492     // opened the document or if the document is the same-origin with any of
3493     // the top-level frame&#39;s opener&#39;s ancestors (in the frame hierarchy).
3494     //
3495     // In both of these cases, the document performing the navigation is in
3496     // some way related to the frame being navigate (e.g., by the &quot;opener&quot;
3497     // and/or &quot;parent&quot; relation). Requiring some sort of relation prevents a
3498     // document from navigating arbitrary, unrelated top-level frames.
3499     if (!targetFrame.tree().parent()) {
3500         if (&amp;targetFrame == m_frame-&gt;loader().opener())
3501             return true;
3502 
3503         if (canAccessAncestor(securityOrigin(), targetFrame.loader().opener()))
3504             return true;
3505     }
3506 
3507     printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation is neither same-origin with the target, nor is it the target&#39;s parent or opener.&quot;);
3508     return false;
3509 }
3510 
3511 void Document::willLoadScriptElement(const URL&amp; scriptURL)
3512 {
3513     m_hasLoadedThirdPartyScript = m_hasLoadedThirdPartyScript || !securityOrigin().isSameOriginAs(SecurityOrigin::create(scriptURL));
3514 }
3515 
3516 void Document::willLoadFrameElement(const URL&amp; frameURL)
3517 {
3518     m_hasLoadedThirdPartyFrame = m_hasLoadedThirdPartyFrame || !securityOrigin().isSameOriginAs(SecurityOrigin::create(frameURL));
3519 }
3520 
3521 // Prevent cross-site top-level redirects from third-party iframes unless the user has ever interacted with the frame.
3522 bool Document::isNavigationBlockedByThirdPartyIFrameRedirectBlocking(Frame&amp; targetFrame, const URL&amp; destinationURL)
3523 {
3524     if (!settings().thirdPartyIframeRedirectBlockingEnabled())
3525         return false;
3526 
3527     // Only prevent top frame navigations by subframes.
3528     if (m_frame == &amp;targetFrame || &amp;targetFrame != &amp;m_frame-&gt;tree().top())
3529         return false;
3530 
3531     // Only prevent navigations by subframes that the user has not interacted with.
3532     if (m_frame-&gt;hasHadUserInteraction())
3533         return false;
3534 
3535     // Only prevent navigations by unsandboxed iframes. Such navigations by unsandboxed iframes would have already been blocked unless
3536     // &quot;allow-top-navigation&quot; / &quot;allow-top-navigation-by-user-activation&quot; was explicitly specified.
3537     if (sandboxFlags() != SandboxNone)
3538         return false;
3539 
3540     // Only prevent navigations by third-party iframes or untrusted first-party iframes.
3541     bool isUntrustedIframe = m_hasLoadedThirdPartyScript &amp;&amp; m_hasLoadedThirdPartyFrame;
3542     if (canAccessAncestor(securityOrigin(), &amp;targetFrame) &amp;&amp; !isUntrustedIframe)
3543         return false;
3544 
3545     // Only prevent cross-site navigations.
3546     auto* targetDocument = targetFrame.document();
3547     if (targetDocument &amp;&amp; (targetDocument-&gt;securityOrigin().canAccess(SecurityOrigin::create(destinationURL)) || areRegistrableDomainsEqual(targetDocument-&gt;url(), destinationURL)))
3548         return false;
3549 
3550     return true;
3551 }
3552 
3553 void Document::didRemoveAllPendingStylesheet()
3554 {
3555     if (auto* parser = scriptableDocumentParser())
3556         parser-&gt;executeScriptsWaitingForStylesheetsSoon();
3557 
3558     if (m_gotoAnchorNeededAfterStylesheetsLoad) {
3559         // https://html.spec.whatwg.org/multipage/browsing-the-web.html#try-to-scroll-to-the-fragment
3560         eventLoop().queueTask(TaskSource::Networking, [protectedThis = makeRef(*this), this] {
3561             auto frameView = makeRefPtr(view());
3562             if (!frameView)
3563                 return;
3564             if (!haveStylesheetsLoaded()) {
3565                 m_gotoAnchorNeededAfterStylesheetsLoad = true;
3566                 return;
3567             }
3568             frameView-&gt;scrollToFragment(m_url);
3569         });
3570     }
3571 }
3572 
3573 bool Document::usesStyleBasedEditability() const
3574 {
3575     if (m_hasElementUsingStyleBasedEditability)
3576         return true;
3577 
3578     ASSERT(!m_renderView || !m_renderView-&gt;frameView().isPainting());
3579     ASSERT(!m_inStyleRecalc);
3580 
3581     auto&amp; styleScope = const_cast&lt;Style::Scope&amp;&gt;(this-&gt;styleScope());
3582     styleScope.flushPendingUpdate();
3583     return styleScope.usesStyleBasedEditability();
3584 }
3585 
3586 void Document::setHasElementUsingStyleBasedEditability()
3587 {
3588     m_hasElementUsingStyleBasedEditability = true;
3589 }
3590 
3591 void Document::processHttpEquiv(const String&amp; equiv, const String&amp; content, bool isInDocumentHead)
3592 {
3593     ASSERT(!equiv.isNull());
3594     ASSERT(!content.isNull());
3595 
3596     HttpEquivPolicy policy = httpEquivPolicy();
3597     if (policy != HttpEquivPolicy::Enabled) {
3598         String reason;
3599         switch (policy) {
3600         case HttpEquivPolicy::Enabled:
3601             ASSERT_NOT_REACHED();
3602             break;
3603         case HttpEquivPolicy::DisabledBySettings:
3604             reason = &quot;by the embedder.&quot;;
3605             break;
3606         case HttpEquivPolicy::DisabledByContentDispositionAttachmentSandbox:
3607             reason = &quot;for documents with Content-Disposition: attachment.&quot;;
3608             break;
3609         }
3610         String message = &quot;http-equiv &#39;&quot; + equiv + &quot;&#39; is disabled &quot; + reason;
3611         addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
3612         return;
3613     }
3614 
3615     Frame* frame = this-&gt;frame();
3616     auto* documentLoader = frame ? frame-&gt;loader().documentLoader() : nullptr;
3617     auto httpStatusCode = documentLoader ? documentLoader-&gt;response().httpStatusCode() : 0;
3618 
3619     HTTPHeaderName headerName;
3620     if (!findHTTPHeaderName(equiv, headerName))
3621         return;
3622 
3623     switch (headerName) {
3624     case HTTPHeaderName::DefaultStyle:
3625         // The preferred style set has been overridden as per section
3626         // 14.3.2 of the HTML4.0 specification.  We need to update the
3627         // sheet used variable and then update our style selector.
3628         // For more info, see the test at:
3629         // http://www.hixie.ch/tests/evil/css/import/main/preferred.html
3630         // -dwh
3631         styleScope().setPreferredStylesheetSetName(content);
3632         break;
3633 
3634     case HTTPHeaderName::Refresh: {
3635         double delay = 0;
3636         String urlString;
3637         if (frame &amp;&amp; parseMetaHTTPEquivRefresh(content, delay, urlString)) {
3638             URL completedURL;
3639             if (urlString.isEmpty())
3640                 completedURL = m_url;
3641             else
3642                 completedURL = completeURL(urlString);
3643             if (!WTF::protocolIsJavaScript(completedURL))
3644                 frame-&gt;navigationScheduler().scheduleRedirect(*this, delay, completedURL);
3645             else {
3646                 String message = &quot;Refused to refresh &quot; + m_url.stringCenterEllipsizedToLength() + &quot; to a javascript: URL&quot;;
3647                 addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
3648             }
3649         }
3650 
3651         break;
3652     }
3653 
3654     case HTTPHeaderName::SetCookie:
3655         if (isHTMLDocument())
3656             addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;The Set-Cookie meta tag is obsolete and was ignored. Use the HTTP header Set-Cookie or document.cookie instead.&quot;_s);
3657         break;
3658 
3659     case HTTPHeaderName::ContentLanguage:
3660         setContentLanguage(content);
3661         break;
3662 
3663     case HTTPHeaderName::XDNSPrefetchControl:
3664         parseDNSPrefetchControlHeader(content);
3665         break;
3666 
3667     case HTTPHeaderName::XFrameOptions:
3668         if (frame) {
3669             FrameLoader&amp; frameLoader = frame-&gt;loader();
3670             unsigned long requestIdentifier = 0;
3671             if (frameLoader.activeDocumentLoader() &amp;&amp; frameLoader.activeDocumentLoader()-&gt;mainResourceLoader())
3672                 requestIdentifier = frameLoader.activeDocumentLoader()-&gt;mainResourceLoader()-&gt;identifier();
3673 
3674             String message = &quot;The X-Frame-Option &#39;&quot; + content + &quot;&#39; supplied in a &lt;meta&gt; element was ignored. X-Frame-Options may only be provided by an HTTP header sent with the document.&quot;;
3675             addConsoleMessage(MessageSource::Security, MessageLevel::Error, message, requestIdentifier);
3676         }
3677         break;
3678 
3679     case HTTPHeaderName::ContentSecurityPolicy:
3680         if (isInDocumentHead)
3681             contentSecurityPolicy()-&gt;didReceiveHeader(content, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::HTTPEquivMeta, referrer(), httpStatusCode);
3682         break;
3683 
3684     case HTTPHeaderName::XWebKitCSP:
3685         if (isInDocumentHead)
3686             contentSecurityPolicy()-&gt;didReceiveHeader(content, ContentSecurityPolicyHeaderType::PrefixedEnforce, ContentSecurityPolicy::PolicyFrom::HTTPEquivMeta, referrer(), httpStatusCode);
3687         break;
3688 
3689     default:
3690         break;
3691     }
3692 }
3693 
3694 void Document::processDisabledAdaptations(const String&amp; disabledAdaptationsString)
3695 {
3696     auto disabledAdaptations = parseDisabledAdaptations(disabledAdaptationsString);
3697     if (m_disabledAdaptations == disabledAdaptations)
3698         return;
3699 
3700     m_disabledAdaptations = disabledAdaptations;
3701     dispatchDisabledAdaptationsDidChangeForMainFrame();
3702 }
3703 
3704 void Document::dispatchDisabledAdaptationsDidChangeForMainFrame()
3705 {
3706     if (!frame()-&gt;isMainFrame())
3707         return;
3708 
3709     if (!page())
3710         return;
3711 
3712     page()-&gt;chrome().dispatchDisabledAdaptationsDidChange(m_disabledAdaptations);
3713 }
3714 
3715 void Document::processViewport(const String&amp; features, ViewportArguments::Type origin)
3716 {
3717     ASSERT(!features.isNull());
3718 
3719     LOG_WITH_STREAM(Viewports, stream &lt;&lt; &quot;Document::processViewport &quot; &lt;&lt; features);
3720 
3721     if (origin &lt; m_viewportArguments.type)
3722         return;
3723 
3724     m_viewportArguments = ViewportArguments(origin);
3725 
3726     LOG_WITH_STREAM(Viewports, stream  &lt;&lt; &quot; resolved to &quot; &lt;&lt; m_viewportArguments);
3727 
3728     processFeaturesString(features, FeatureMode::Viewport, [this](StringView key, StringView value) {
3729         setViewportFeature(m_viewportArguments, *this, key, value);
3730     });
3731 
3732     updateViewportArguments();
3733 }
3734 
3735 ViewportArguments Document::viewportArguments() const
3736 {
3737     auto* page = this-&gt;page();
3738     if (!page)
3739         return m_viewportArguments;
3740     return page-&gt;overrideViewportArguments().valueOr(m_viewportArguments);
3741 }
3742 
3743 void Document::updateViewportArguments()
3744 {
3745     if (page() &amp;&amp; frame()-&gt;isMainFrame()) {
3746 #if ASSERT_ENABLED
3747         m_didDispatchViewportPropertiesChanged = true;
3748 #endif
3749         page()-&gt;chrome().dispatchViewportPropertiesDidChange(viewportArguments());
3750         page()-&gt;chrome().didReceiveDocType(*frame());
3751     }
3752 }
3753 
3754 #if ENABLE(DARK_MODE_CSS)
3755 static void processColorSchemeString(StringView colorScheme, const WTF::Function&lt;void(StringView key)&gt;&amp; callback)
3756 {
3757     unsigned length = colorScheme.length();
3758     for (unsigned i = 0; i &lt; length; ) {
3759         // Skip to first non-separator.
3760         while (i &lt; length &amp;&amp; isHTMLSpace(colorScheme[i]))
3761             ++i;
3762         unsigned keyBegin = i;
3763 
3764         // Skip to first separator.
3765         while (i &lt; length &amp;&amp; !isHTMLSpace(colorScheme[i]))
3766             ++i;
3767         unsigned keyEnd = i;
3768 
3769         if (keyBegin == keyEnd)
3770             continue;
3771 
3772         callback(colorScheme.substring(keyBegin, keyEnd - keyBegin));
3773     }
3774 }
3775 
3776 void Document::processColorScheme(const String&amp; colorSchemeString)
3777 {
3778     OptionSet&lt;ColorScheme&gt; colorScheme;
3779     bool allowsTransformations = true;
3780     bool autoEncountered = false;
3781 
3782     processColorSchemeString(colorSchemeString, [&amp;] (StringView key) {
3783         if (equalLettersIgnoringASCIICase(key, &quot;auto&quot;)) {
3784             colorScheme = { };
3785             allowsTransformations = true;
3786             autoEncountered = true;
3787             return;
3788         }
3789 
3790         if (autoEncountered)
3791             return;
3792 
3793         if (equalLettersIgnoringASCIICase(key, &quot;light&quot;))
3794             colorScheme.add(ColorScheme::Light);
3795         else if (equalLettersIgnoringASCIICase(key, &quot;dark&quot;))
3796             colorScheme.add(ColorScheme::Dark);
3797         else if (equalLettersIgnoringASCIICase(key, &quot;only&quot;))
3798             allowsTransformations = false;
3799     });
3800 
3801     // If the value was just &quot;only&quot;, that is synonymous for &quot;only light&quot;.
3802     if (colorScheme.isEmpty() &amp;&amp; !allowsTransformations)
3803         colorScheme.add(ColorScheme::Light);
3804 
3805     m_colorScheme = colorScheme;
3806     m_allowsColorSchemeTransformations = allowsTransformations;
3807 
3808     if (auto* frameView = view())
3809         frameView-&gt;recalculateBaseBackgroundColor();
3810 
3811     if (auto* page = this-&gt;page())
3812         page-&gt;updateStyleAfterChangeInEnvironment();
3813 }
3814 #endif
3815 
3816 #if PLATFORM(IOS_FAMILY)
3817 
3818 void Document::processFormatDetection(const String&amp; features)
3819 {
3820     // FIXME: Find a better place for this function.
3821     processFeaturesString(features, FeatureMode::Viewport, [this](StringView key, StringView value) {
3822         if (equalLettersIgnoringASCIICase(key, &quot;telephone&quot;) &amp;&amp; equalLettersIgnoringASCIICase(value, &quot;no&quot;))
3823             m_isTelephoneNumberParsingAllowed = false;
3824     });
3825 }
3826 
3827 void Document::processWebAppOrientations()
3828 {
3829     if (Page* page = this-&gt;page())
3830         page-&gt;chrome().client().webAppOrientationsUpdated();
3831 }
3832 
3833 #endif
3834 
3835 void Document::processReferrerPolicy(const String&amp; policy, ReferrerPolicySource source)
3836 {
3837     ASSERT(!policy.isNull());
3838 
3839     // Documents in a Content-Disposition: attachment sandbox should never send a Referer header,
3840     // even if the document has a meta tag saying otherwise.
3841     if (shouldEnforceContentDispositionAttachmentSandbox())
3842         return;
3843 
3844 #if USE(QUICK_LOOK)
3845     if (shouldEnforceQuickLookSandbox())
3846         return;
3847 #endif
3848 
3849     auto referrerPolicy = parseReferrerPolicy(policy, source);
3850     if (!referrerPolicy) {
3851         // Unknown policy values are ignored (https://w3c.github.io/webappsec-referrer-policy/#unknown-policy-values).
3852         addConsoleMessage(MessageSource::Rendering, MessageLevel::Error, &quot;Failed to set referrer policy: The value &#39;&quot; + policy + &quot;&#39; is not one of &#39;no-referrer&#39;, &#39;no-referrer-when-downgrade&#39;, &#39;same-origin&#39;, &#39;origin&#39;, &#39;strict-origin&#39;, &#39;origin-when-cross-origin&#39;, &#39;strict-origin-when-cross-origin&#39; or &#39;unsafe-url&#39;.&quot;);
3853         return;
3854     }
3855     setReferrerPolicy(referrerPolicy.value());
3856 }
3857 
3858 MouseEventWithHitTestResults Document::prepareMouseEvent(const HitTestRequest&amp; request, const LayoutPoint&amp; documentPoint, const PlatformMouseEvent&amp; event)
3859 {
3860     if (!hasLivingRenderTree())
3861         return MouseEventWithHitTestResults(event, HitTestResult(LayoutPoint()));
3862 
3863     HitTestResult result(documentPoint);
3864     hitTest(request, result);
3865 
3866     auto captureElementChanged = CaptureChange::No;
3867     if (!request.readOnly()) {
3868         auto targetElement = makeRefPtr(result.targetElement());
3869 #if ENABLE(POINTER_EVENTS)
3870         if (auto* page = this-&gt;page()) {
3871             // Before we dispatch a new mouse event, we must run the Process Pending Capture Element steps as defined
3872             // in https://w3c.github.io/pointerevents/#process-pending-pointer-capture.
3873             auto&amp; pointerCaptureController = page-&gt;pointerCaptureController();
3874             auto* previousCaptureElement = pointerCaptureController.pointerCaptureElement(this, event.pointerId());
3875             pointerCaptureController.processPendingPointerCapture(event.pointerId());
3876             auto* captureElement = pointerCaptureController.pointerCaptureElement(this, event.pointerId());
3877             // If the capture element has changed while running the Process Pending Capture Element steps then
3878             // we need to indicate that when calling updateHoverActiveState to be sure that the :active and :hover
3879             // element chains are updated.
3880             if (previousCaptureElement != captureElement)
3881                 captureElementChanged = CaptureChange::Yes;
3882             // If we have a capture element, we must target it instead of what would normally hit-test for this event.
3883             if (captureElement)
3884                 targetElement = captureElement;
3885         }
3886 #endif
3887         updateHoverActiveState(request, targetElement.get(), captureElementChanged);
3888     }
3889 
3890     return MouseEventWithHitTestResults(event, result);
3891 }
3892 
3893 // DOM Section 1.1.1
3894 bool Document::childTypeAllowed(NodeType type) const
3895 {
3896     switch (type) {
3897     case ATTRIBUTE_NODE:
3898     case CDATA_SECTION_NODE:
3899     case DOCUMENT_FRAGMENT_NODE:
3900     case DOCUMENT_NODE:
3901     case TEXT_NODE:
3902         return false;
3903     case COMMENT_NODE:
3904     case PROCESSING_INSTRUCTION_NODE:
3905         return true;
3906     case DOCUMENT_TYPE_NODE:
3907     case ELEMENT_NODE:
3908         // Documents may contain no more than one of each of these.
3909         // (One Element and one DocumentType.)
3910         for (Node* c = firstChild(); c; c = c-&gt;nextSibling())
3911             if (c-&gt;nodeType() == type)
3912                 return false;
3913         return true;
3914     }
3915     return false;
3916 }
3917 
3918 bool Document::canAcceptChild(const Node&amp; newChild, const Node* refChild, AcceptChildOperation operation) const
3919 {
3920     if (operation == AcceptChildOperation::Replace &amp;&amp; refChild-&gt;nodeType() == newChild.nodeType())
3921         return true;
3922 
3923     switch (newChild.nodeType()) {
3924     case ATTRIBUTE_NODE:
3925     case CDATA_SECTION_NODE:
3926     case DOCUMENT_NODE:
3927     case TEXT_NODE:
3928         return false;
3929     case COMMENT_NODE:
3930     case PROCESSING_INSTRUCTION_NODE:
3931         return true;
3932     case DOCUMENT_FRAGMENT_NODE: {
3933         bool hasSeenElementChild = false;
3934         for (auto* node = downcast&lt;DocumentFragment&gt;(newChild).firstChild(); node; node = node-&gt;nextSibling()) {
3935             if (is&lt;Element&gt;(*node)) {
3936                 if (hasSeenElementChild)
3937                     return false;
3938                 hasSeenElementChild = true;
3939             }
3940             if (!canAcceptChild(*node, refChild, operation))
3941                 return false;
3942         }
3943         break;
3944     }
3945     case DOCUMENT_TYPE_NODE: {
3946         auto* existingDocType = childrenOfType&lt;DocumentType&gt;(*this).first();
3947         if (operation == AcceptChildOperation::Replace) {
3948             //  parent has a doctype child that is not child, or an element is preceding child.
3949             if (existingDocType &amp;&amp; existingDocType != refChild)
3950                 return false;
3951             if (refChild-&gt;previousElementSibling())
3952                 return false;
3953         } else {
3954             ASSERT(operation == AcceptChildOperation::InsertOrAdd);
3955             if (existingDocType)
3956                 return false;
3957             if ((refChild &amp;&amp; refChild-&gt;previousElementSibling()) || (!refChild &amp;&amp; firstElementChild()))
3958                 return false;
3959         }
3960         break;
3961     }
3962     case ELEMENT_NODE: {
3963         auto* existingElementChild = firstElementChild();
3964         if (operation == AcceptChildOperation::Replace) {
3965             if (existingElementChild &amp;&amp; existingElementChild != refChild)
3966                 return false;
3967             for (auto* child = refChild-&gt;nextSibling(); child; child = child-&gt;nextSibling()) {
3968                 if (is&lt;DocumentType&gt;(*child))
3969                     return false;
3970             }
3971         } else {
3972             ASSERT(operation == AcceptChildOperation::InsertOrAdd);
3973             if (existingElementChild)
3974                 return false;
3975             for (auto* child = refChild; child; child = child-&gt;nextSibling()) {
3976                 if (is&lt;DocumentType&gt;(*child))
3977                     return false;
3978             }
3979         }
3980         break;
3981     }
3982     }
3983     return true;
3984 }
3985 
3986 Ref&lt;Node&gt; Document::cloneNodeInternal(Document&amp;, CloningOperation type)
3987 {
3988     Ref&lt;Document&gt; clone = cloneDocumentWithoutChildren();
3989     clone-&gt;cloneDataFromDocument(*this);
3990     switch (type) {
3991     case CloningOperation::OnlySelf:
3992     case CloningOperation::SelfWithTemplateContent:
3993         break;
3994     case CloningOperation::Everything:
3995         cloneChildNodes(clone);
3996         break;
3997     }
3998     return clone;
3999 }
4000 
4001 Ref&lt;Document&gt; Document::cloneDocumentWithoutChildren() const
4002 {
4003     if (isXMLDocument()) {
4004         if (isXHTMLDocument())
4005             return XMLDocument::createXHTML(nullptr, url());
4006         return XMLDocument::create(nullptr, url());
4007     }
4008     return create(url());
4009 }
4010 
4011 void Document::cloneDataFromDocument(const Document&amp; other)
4012 {
4013     ASSERT(m_url == other.url());
4014     m_baseURL = other.baseURL();
4015     m_baseURLOverride = other.baseURLOverride();
4016     m_documentURI = other.documentURI();
4017 
4018     setCompatibilityMode(other.m_compatibilityMode);
4019     setContextDocument(other.contextDocument());
4020     setSecurityOriginPolicy(other.securityOriginPolicy());
4021     overrideMIMEType(other.contentType());
4022     setDecoder(other.decoder());
4023 }
4024 
4025 StyleSheetList&amp; Document::styleSheets()
4026 {
4027     if (!m_styleSheetList)
4028         m_styleSheetList = StyleSheetList::create(*this);
4029     return *m_styleSheetList;
4030 }
4031 
4032 void Document::updateElementsAffectedByMediaQueries()
4033 {
4034     ScriptDisallowedScope::InMainThread scriptDisallowedScope;
4035 
4036     // FIXME: copyToVector doesn&#39;t work with WeakHashSet
4037     Vector&lt;Ref&lt;HTMLImageElement&gt;&gt; images;
4038     images.reserveInitialCapacity(m_dynamicMediaQueryDependentImages.computeSize());
4039     for (auto&amp; image : m_dynamicMediaQueryDependentImages)
4040         images.append(image);
4041 
4042     for (auto&amp; image : images)
4043         image-&gt;evaluateDynamicMediaQueryDependencies();
4044 }
4045 
4046 void Document::evaluateMediaQueriesAndReportChanges()
4047 {
4048     if (!m_mediaQueryMatcher)
4049         return;
4050 
4051     m_mediaQueryMatcher-&gt;evaluateAll();
4052 }
4053 
4054 void Document::updateViewportUnitsOnResize()
4055 {
4056     if (!hasStyleWithViewportUnits())
4057         return;
4058 
4059     styleScope().resolver().clearCachedDeclarationsAffectedByViewportUnits();
4060 
4061     // FIXME: Ideally, we should save the list of elements that have viewport units and only iterate over those.
4062     for (Element* element = ElementTraversal::firstWithin(rootNode()); element; element = ElementTraversal::nextIncludingPseudo(*element)) {
4063         auto* renderer = element-&gt;renderer();
4064         if (renderer &amp;&amp; renderer-&gt;style().hasViewportUnits())
4065             element-&gt;invalidateStyle();
4066     }
4067 }
4068 
4069 void Document::setNeedsDOMWindowResizeEvent()
4070 {
4071     m_needsDOMWindowResizeEvent = true;
4072     scheduleTimedRenderingUpdate();
4073 }
4074 
4075 void Document::setNeedsVisualViewportResize()
4076 {
4077     m_needsVisualViewportResizeEvent = true;
4078     scheduleTimedRenderingUpdate();
4079 }
4080 
4081 // https://drafts.csswg.org/cssom-view/#run-the-resize-steps
4082 void Document::runResizeSteps()
4083 {
4084     // FIXME: The order of dispatching is not specified: https://github.com/WICG/visual-viewport/issues/65.
4085     if (m_needsDOMWindowResizeEvent) {
4086         LOG_WITH_STREAM(Events, stream &lt;&lt; &quot;Document&quot; &lt;&lt; this &lt;&lt; &quot;sending resize events to window&quot;);
4087         m_needsDOMWindowResizeEvent = false;
4088         dispatchWindowEvent(Event::create(eventNames().resizeEvent, Event::CanBubble::No, Event::IsCancelable::No));
4089     }
4090     if (m_needsVisualViewportResizeEvent) {
4091         LOG_WITH_STREAM(Events, stream &lt;&lt; &quot;Document&quot; &lt;&lt; this &lt;&lt; &quot;sending resize events to visualViewport&quot;);
4092         m_needsVisualViewportResizeEvent = false;
4093         if (auto* window = domWindow())
4094             window-&gt;visualViewport().dispatchEvent(Event::create(eventNames().resizeEvent, Event::CanBubble::No, Event::IsCancelable::No));
4095     }
4096 }
4097 
4098 void Document::addPendingScrollEventTarget(ContainerNode&amp; target)
4099 {
4100     if (!m_pendingScrollEventTargetList)
4101         m_pendingScrollEventTargetList = makeUnique&lt;PendingScrollEventTargetList&gt;();
4102 
4103     auto&amp; targets = m_pendingScrollEventTargetList-&gt;targets;
4104     if (targets.findMatching([&amp;] (auto&amp; entry) { return entry.ptr() == &amp;target; }) != notFound)
4105         return;
4106 
4107     if (targets.isEmpty())
4108         scheduleTimedRenderingUpdate();
4109 
4110     targets.append(target);
4111 }
4112 
4113 void Document::setNeedsVisualViewportScrollEvent()
4114 {
4115     if (!m_needsVisualViewportScrollEvent)
4116         scheduleTimedRenderingUpdate();
4117     m_needsVisualViewportScrollEvent = true;
4118 }
4119 
4120 // https://drafts.csswg.org/cssom-view/#run-the-scroll-steps
4121 void Document::runScrollSteps()
4122 {
4123     // FIXME: The order of dispatching is not specified: https://github.com/WICG/visual-viewport/issues/66.
4124     if (m_pendingScrollEventTargetList &amp;&amp; !m_pendingScrollEventTargetList-&gt;targets.isEmpty()) {
4125         LOG_WITH_STREAM(Events, stream &lt;&lt; &quot;Document&quot; &lt;&lt; this &lt;&lt; &quot;sending scroll events to pending scroll event targets&quot;);
4126         auto currentTargets = WTFMove(m_pendingScrollEventTargetList-&gt;targets);
4127         for (auto&amp; target : currentTargets) {
4128             auto bubbles = target-&gt;isDocumentNode() ? Event::CanBubble::Yes : Event::CanBubble::No;
4129             target-&gt;dispatchEvent(Event::create(eventNames().scrollEvent, bubbles, Event::IsCancelable::No));
4130         }
4131     }
4132     if (m_needsVisualViewportScrollEvent) {
4133         LOG_WITH_STREAM(Events, stream &lt;&lt; &quot;Document&quot; &lt;&lt; this &lt;&lt; &quot;sending scroll events to visualViewport&quot;);
4134         m_needsVisualViewportResizeEvent = false;
4135         if (auto* window = domWindow())
4136             window-&gt;visualViewport().dispatchEvent(Event::create(eventNames().scrollEvent, Event::CanBubble::No, Event::IsCancelable::No));
4137     }
4138 }
4139 
4140 void Document::addAudioProducer(MediaProducer&amp; audioProducer)
4141 {
4142     m_audioProducers.add(audioProducer);
4143     updateIsPlayingMedia();
4144 }
4145 
4146 void Document::removeAudioProducer(MediaProducer&amp; audioProducer)
4147 {
4148     RELEASE_ASSERT(isMainThread());
4149     m_audioProducers.remove(audioProducer);
4150     updateIsPlayingMedia();
4151 }
4152 
4153 void Document::noteUserInteractionWithMediaElement()
4154 {
4155     if (m_userHasInteractedWithMediaElement)
4156         return;
4157 
4158     if (!topDocument().userDidInteractWithPage())
4159         return;
4160 
4161     m_userHasInteractedWithMediaElement = true;
4162     updateIsPlayingMedia();
4163 }
4164 
4165 void Document::updateIsPlayingMedia(uint64_t sourceElementID)
4166 {
4167     ASSERT(!m_audioProducers.hasNullReferences());
4168     MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
4169     for (auto&amp; audioProducer : m_audioProducers)
4170         state |= audioProducer.mediaState();
4171 
4172 #if ENABLE(MEDIA_STREAM)
4173     state |= MediaStreamTrack::captureState(*this);
4174 #endif
4175 
4176 #if ENABLE(MEDIA_SESSION)
4177     if (HTMLMediaElement* sourceElement = HTMLMediaElement::elementWithID(sourceElementID)) {
4178         if (sourceElement-&gt;isPlaying())
4179             state |= MediaProducer::IsSourceElementPlaying;
4180 
4181         if (auto* session = sourceElement-&gt;session()) {
4182             if (auto* controls = session-&gt;controls()) {
4183                 if (controls-&gt;previousTrackEnabled())
4184                     state |= MediaProducer::IsPreviousTrackControlEnabled;
4185                 if (controls-&gt;nextTrackEnabled())
4186                     state |= MediaProducer::IsNextTrackControlEnabled;
4187             }
4188         }
4189     }
4190 #endif
4191 
4192     if (m_userHasInteractedWithMediaElement)
4193         state |= MediaProducer::HasUserInteractedWithMediaElement;
4194 
4195     if (state == m_mediaState)
4196         return;
4197 
4198 #if ENABLE(MEDIA_STREAM)
4199     bool captureStateChanged = MediaProducer::isCapturing(m_mediaState) != MediaProducer::isCapturing(state);
4200 #endif
4201 
4202     m_mediaState = state;
4203 
4204     if (page())
4205         page()-&gt;updateIsPlayingMedia(sourceElementID);
4206 
4207 #if ENABLE(MEDIA_STREAM)
4208     if (captureStateChanged)
4209         mediaStreamCaptureStateChanged();
4210 #endif
4211 }
4212 
4213 void Document::pageMutedStateDidChange()
4214 {
4215     for (auto&amp; audioProducer : m_audioProducers)
4216         audioProducer.pageMutedStateDidChange();
4217 
4218 #if ENABLE(MEDIA_STREAM)
4219     MediaStreamTrack::updateCaptureAccordingToMutedState(*this);
4220 #endif
4221 }
4222 
4223 static bool isNodeInSubtree(Node&amp; node, Node&amp; container, Document::NodeRemoval nodeRemoval)
4224 {
4225     if (nodeRemoval == Document::NodeRemoval::ChildrenOfNode)
4226         return node.isDescendantOf(container);
4227 
4228     return &amp;node == &amp;container || node.isDescendantOf(container);
4229 }
4230 
4231 void Document::adjustFocusedNodeOnNodeRemoval(Node&amp; node, NodeRemoval nodeRemoval)
4232 {
4233     if (!m_focusedElement || backForwardCacheState() != NotInBackForwardCache) // If the document is in the back/forward cache, then we don&#39;t need to clear out the focused node.
4234         return;
4235 
4236     Element* focusedElement = node.treeScope().focusedElementInScope();
4237     if (!focusedElement)
4238         return;
4239 
4240     if (isNodeInSubtree(*focusedElement, node, nodeRemoval)) {
4241         // FIXME: We should avoid synchronously updating the style inside setFocusedElement.
4242         // FIXME: Object elements should avoid loading a frame synchronously in a post style recalc callback.
4243         SubframeLoadingDisabler disabler(is&lt;ContainerNode&gt;(node) ? &amp;downcast&lt;ContainerNode&gt;(node) : nullptr);
4244         setFocusedElement(nullptr, FocusDirectionNone, FocusRemovalEventsMode::DoNotDispatch);
4245         // Set the focus navigation starting node to the previous focused element so that
4246         // we can fallback to the siblings or parent node for the next search.
4247         // Also we need to call removeFocusNavigationNodeOfSubtree after this function because
4248         // setFocusedElement(nullptr) will reset m_focusNavigationStartingNode.
4249         setFocusNavigationStartingNode(focusedElement);
4250     }
4251 }
4252 
4253 void Document::hoveredElementDidDetach(Element&amp; element)
4254 {
4255     if (!m_hoveredElement || &amp;element != m_hoveredElement)
4256         return;
4257 
4258     m_hoveredElement = element.parentElement();
4259     while (m_hoveredElement &amp;&amp; !m_hoveredElement-&gt;renderer())
4260         m_hoveredElement = m_hoveredElement-&gt;parentElement();
4261     if (frame())
4262         frame()-&gt;eventHandler().scheduleHoverStateUpdate();
4263 }
4264 
4265 void Document::elementInActiveChainDidDetach(Element&amp; element)
4266 {
4267     if (!m_activeElement || &amp;element != m_activeElement)
4268         return;
4269 
4270     m_activeElement = element.parentElement();
4271     while (m_activeElement &amp;&amp; !m_activeElement-&gt;renderer())
4272         m_activeElement = m_activeElement-&gt;parentElement();
4273 }
4274 
4275 void Document::invalidateRenderingDependentRegions()
4276 {
4277 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(TOUCH_EVENTS)
4278     setTouchEventRegionsNeedUpdate();
4279 #endif
4280 
4281 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(POINTER_EVENTS)
4282     if (auto* page = this-&gt;page()) {
4283         if (auto* frameView = view()) {
4284             if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
4285                 scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);
4286         }
4287     }
4288 #endif
4289 }
4290 
4291 bool Document::setFocusedElement(Element* element, FocusDirection direction, FocusRemovalEventsMode eventsMode)
4292 {
4293     RefPtr&lt;Element&gt; newFocusedElement = element;
4294     // Make sure newFocusedElement is actually in this document
4295     if (newFocusedElement &amp;&amp; (&amp;newFocusedElement-&gt;document() != this))
4296         return true;
4297 
4298     if (m_focusedElement == newFocusedElement)
4299         return true;
4300 
4301     if (backForwardCacheState() != NotInBackForwardCache)
4302         return false;
4303 
4304     bool focusChangeBlocked = false;
4305     RefPtr&lt;Element&gt; oldFocusedElement = WTFMove(m_focusedElement);
4306 
4307     // Remove focus from the existing focus node (if any)
4308     if (oldFocusedElement) {
4309         oldFocusedElement-&gt;setFocus(false);
4310         setFocusNavigationStartingNode(nullptr);
4311 
4312         if (eventsMode == FocusRemovalEventsMode::Dispatch) {
4313             // Dispatch a change event for form control elements that have been edited.
4314             if (is&lt;HTMLFormControlElement&gt;(*oldFocusedElement)) {
4315                 HTMLFormControlElement&amp; formControlElement = downcast&lt;HTMLFormControlElement&gt;(*oldFocusedElement);
4316                 if (formControlElement.wasChangedSinceLastFormControlChangeEvent())
4317                     formControlElement.dispatchFormControlChangeEvent();
4318             }
4319 
4320             // Dispatch the blur event and let the node do any other blur related activities (important for text fields)
4321             oldFocusedElement-&gt;dispatchBlurEvent(newFocusedElement.copyRef());
4322 
4323             if (m_focusedElement) {
4324                 // handler shifted focus
4325                 focusChangeBlocked = true;
4326                 newFocusedElement = nullptr;
4327             }
4328 
4329             oldFocusedElement-&gt;dispatchFocusOutEvent(eventNames().focusoutEvent, newFocusedElement.copyRef()); // DOM level 3 name for the bubbling blur event.
4330             // FIXME: We should remove firing DOMFocusOutEvent event when we are sure no content depends
4331             // on it, probably when &lt;rdar://problem/8503958&gt; is resolved.
4332             oldFocusedElement-&gt;dispatchFocusOutEvent(eventNames().DOMFocusOutEvent, newFocusedElement.copyRef()); // DOM level 2 name for compatibility.
4333 
4334             if (m_focusedElement) {
4335                 // handler shifted focus
4336                 focusChangeBlocked = true;
4337                 newFocusedElement = nullptr;
4338             }
4339         } else {
4340             // Match the order in HTMLTextFormControlElement::dispatchBlurEvent.
4341             if (is&lt;HTMLInputElement&gt;(*oldFocusedElement))
4342                 downcast&lt;HTMLInputElement&gt;(*oldFocusedElement).endEditing();
4343             if (page())
4344                 page()-&gt;chrome().client().elementDidBlur(*oldFocusedElement);
4345             ASSERT(!m_focusedElement);
4346         }
4347 
4348         if (oldFocusedElement-&gt;isRootEditableElement())
4349             frame()-&gt;editor().didEndEditing();
4350 
4351         if (view()) {
4352             if (Widget* oldWidget = widgetForElement(oldFocusedElement.get()))
4353                 oldWidget-&gt;setFocus(false);
4354             else
4355                 view()-&gt;setFocus(false);
4356         }
4357 
4358         if (is&lt;HTMLInputElement&gt;(oldFocusedElement)) {
4359             // HTMLInputElement::didBlur just scrolls text fields back to the beginning.
4360             // FIXME: This could be done asynchronusly.
4361             // Updating style may dispatch events due to PostResolutionCallback
4362             if (eventsMode == FocusRemovalEventsMode::Dispatch)
4363                 updateStyleIfNeeded();
4364             downcast&lt;HTMLInputElement&gt;(*oldFocusedElement).didBlur();
4365         }
4366     }
4367 
4368     if (newFocusedElement &amp;&amp; newFocusedElement-&gt;isFocusable()) {
4369         if (&amp;newFocusedElement-&gt;document() != this) {
4370             // Bluring oldFocusedElement may have moved newFocusedElement across documents.
4371             focusChangeBlocked = true;
4372             goto SetFocusedNodeDone;
4373         }
4374         if (newFocusedElement-&gt;isRootEditableElement() &amp;&amp; !acceptsEditingFocus(*newFocusedElement)) {
4375             // delegate blocks focus change
4376             focusChangeBlocked = true;
4377             goto SetFocusedNodeDone;
4378         }
4379         // Set focus on the new node
4380         m_focusedElement = newFocusedElement;
4381         setFocusNavigationStartingNode(m_focusedElement.get());
4382 
4383         // Dispatch the focus event and let the node do any other focus related activities (important for text fields)
4384         m_focusedElement-&gt;dispatchFocusEvent(oldFocusedElement.copyRef(), direction);
4385 
4386         if (m_focusedElement != newFocusedElement) {
4387             // handler shifted focus
4388             focusChangeBlocked = true;
4389             goto SetFocusedNodeDone;
4390         }
4391 
4392         m_focusedElement-&gt;dispatchFocusInEvent(eventNames().focusinEvent, oldFocusedElement.copyRef()); // DOM level 3 bubbling focus event.
4393 
4394         if (m_focusedElement != newFocusedElement) {
4395             // handler shifted focus
4396             focusChangeBlocked = true;
4397             goto SetFocusedNodeDone;
4398         }
4399 
4400         // FIXME: We should remove firing DOMFocusInEvent event when we are sure no content depends
4401         // on it, probably when &lt;rdar://problem/8503958&gt; is m.
4402         m_focusedElement-&gt;dispatchFocusInEvent(eventNames().DOMFocusInEvent, oldFocusedElement.copyRef()); // DOM level 2 for compatibility.
4403 
4404         if (m_focusedElement != newFocusedElement) {
4405             // handler shifted focus
4406             focusChangeBlocked = true;
4407             goto SetFocusedNodeDone;
4408         }
4409 
4410         m_focusedElement-&gt;setFocus(true);
4411 
4412         // The setFocus call triggers a blur and a focus event. Event handlers could cause the focused element to be cleared.
4413         if (m_focusedElement != newFocusedElement) {
4414             // handler shifted focus
4415             focusChangeBlocked = true;
4416             goto SetFocusedNodeDone;
4417         }
4418 
4419         if (m_focusedElement-&gt;isRootEditableElement())
4420             frame()-&gt;editor().didBeginEditing();
4421 
4422         // eww, I suck. set the qt focus correctly
4423         // ### find a better place in the code for this
4424         if (view()) {
4425             Widget* focusWidget = widgetForElement(m_focusedElement.get());
4426             if (focusWidget) {
4427                 // Make sure a widget has the right size before giving it focus.
4428                 // Otherwise, we are testing edge cases of the Widget code.
4429                 // Specifically, in WebCore this does not work well for text fields.
4430                 updateLayout();
4431                 // Re-get the widget in case updating the layout changed things.
4432                 focusWidget = widgetForElement(m_focusedElement.get());
4433             }
4434             if (focusWidget)
4435                 focusWidget-&gt;setFocus(true);
4436             else if (auto* frameView = view())
4437                 frameView-&gt;setFocus(true);
4438         }
4439     }
4440 
4441     if (!focusChangeBlocked &amp;&amp; m_focusedElement) {
4442         // Create the AXObject cache in a focus change because GTK relies on it.
4443         if (AXObjectCache* cache = axObjectCache())
4444             cache-&gt;deferFocusedUIElementChangeIfNeeded(oldFocusedElement.get(), newFocusedElement.get());
4445     }
4446 
4447     if (!focusChangeBlocked &amp;&amp; page())
4448         page()-&gt;chrome().focusedElementChanged(m_focusedElement.get());
4449 
4450 SetFocusedNodeDone:
4451     // Updating style may dispatch events due to PostResolutionCallback
4452     // FIXME: Why is synchronous style update needed here at all?
4453     if (eventsMode == FocusRemovalEventsMode::Dispatch)
4454         updateStyleIfNeeded();
4455     return !focusChangeBlocked;
4456 }
4457 
4458 static bool shouldResetFocusNavigationStartingNode(Node&amp; node)
4459 {
4460     // Setting focus navigation starting node to the following nodes means that we should start
4461     // the search from the beginning of the document.
4462     return is&lt;HTMLHtmlElement&gt;(node) || is&lt;HTMLDocument&gt;(node);
4463 }
4464 
4465 void Document::setFocusNavigationStartingNode(Node* node)
4466 {
4467     if (!m_frame)
4468         return;
4469 
4470     m_focusNavigationStartingNodeIsRemoved = false;
4471     if (!node || shouldResetFocusNavigationStartingNode(*node)) {
4472         m_focusNavigationStartingNode = nullptr;
4473         return;
4474     }
4475 
4476     ASSERT(!node || node != this);
4477     m_focusNavigationStartingNode = node;
4478 }
4479 
4480 Element* Document::focusNavigationStartingNode(FocusDirection direction) const
4481 {
4482     if (m_focusedElement) {
4483         if (!m_focusNavigationStartingNode || !m_focusNavigationStartingNode-&gt;isDescendantOf(m_focusedElement.get()))
4484             return m_focusedElement.get();
4485     }
4486 
4487     if (!m_focusNavigationStartingNode)
4488         return nullptr;
4489 
4490     Node* node = m_focusNavigationStartingNode.get();
4491 
4492     // When the node was removed from the document tree. This case is not specified in the spec:
4493     // https://html.spec.whatwg.org/multipage/interaction.html#sequential-focus-navigation-starting-point
4494     // Current behaivor is to move the sequential navigation node to / after (based on the focus direction)
4495     // the previous sibling of the removed node.
4496     if (m_focusNavigationStartingNodeIsRemoved) {
4497         Node* nextNode = NodeTraversal::next(*node);
4498         if (!nextNode)
4499             nextNode = node;
4500         if (direction == FocusDirectionForward)
4501             return ElementTraversal::previous(*nextNode);
4502         if (is&lt;Element&gt;(*nextNode))
4503             return downcast&lt;Element&gt;(nextNode);
4504         return ElementTraversal::next(*nextNode);
4505     }
4506 
4507     if (is&lt;Element&gt;(*node))
4508         return downcast&lt;Element&gt;(node);
4509     if (Element* elementBeforeNextFocusableElement = direction == FocusDirectionForward ? ElementTraversal::previous(*node) : ElementTraversal::next(*node))
4510         return elementBeforeNextFocusableElement;
4511     return node-&gt;parentOrShadowHostElement();
4512 }
4513 
4514 void Document::setCSSTarget(Element* targetNode)
4515 {
4516     if (m_cssTarget)
4517         m_cssTarget-&gt;invalidateStyleForSubtree();
4518     m_cssTarget = targetNode;
4519     if (targetNode)
4520         targetNode-&gt;invalidateStyleForSubtree();
4521 }
4522 
4523 void Document::registerNodeListForInvalidation(LiveNodeList&amp; list)
4524 {
4525     m_nodeListAndCollectionCounts[list.invalidationType()]++;
4526     if (!list.isRootedAtDocument())
4527         return;
4528     ASSERT(!list.isRegisteredForInvalidationAtDocument());
4529     list.setRegisteredForInvalidationAtDocument(true);
4530     m_listsInvalidatedAtDocument.add(&amp;list);
4531 }
4532 
4533 void Document::unregisterNodeListForInvalidation(LiveNodeList&amp; list)
4534 {
4535     m_nodeListAndCollectionCounts[list.invalidationType()]--;
4536     if (!list.isRegisteredForInvalidationAtDocument())
4537         return;
4538 
4539     list.setRegisteredForInvalidationAtDocument(false);
4540     ASSERT(m_listsInvalidatedAtDocument.contains(&amp;list));
4541     m_listsInvalidatedAtDocument.remove(&amp;list);
4542 }
4543 
4544 void Document::registerCollection(HTMLCollection&amp; collection)
4545 {
4546     m_nodeListAndCollectionCounts[collection.invalidationType()]++;
4547     if (collection.isRootedAtDocument())
4548         m_collectionsInvalidatedAtDocument.add(&amp;collection);
4549 }
4550 
4551 void Document::unregisterCollection(HTMLCollection&amp; collection)
4552 {
4553     ASSERT(m_nodeListAndCollectionCounts[collection.invalidationType()]);
4554     m_nodeListAndCollectionCounts[collection.invalidationType()]--;
4555     if (!collection.isRootedAtDocument())
4556         return;
4557 
4558     m_collectionsInvalidatedAtDocument.remove(&amp;collection);
4559 }
4560 
4561 void Document::collectionCachedIdNameMap(const HTMLCollection&amp; collection)
4562 {
4563     ASSERT_UNUSED(collection, collection.hasNamedElementCache());
4564     m_nodeListAndCollectionCounts[InvalidateOnIdNameAttrChange]++;
4565 }
4566 
4567 void Document::collectionWillClearIdNameMap(const HTMLCollection&amp; collection)
4568 {
4569     ASSERT_UNUSED(collection, collection.hasNamedElementCache());
4570     ASSERT(m_nodeListAndCollectionCounts[InvalidateOnIdNameAttrChange]);
4571     m_nodeListAndCollectionCounts[InvalidateOnIdNameAttrChange]--;
4572 }
4573 
4574 void Document::attachNodeIterator(NodeIterator&amp; iterator)
4575 {
4576     m_nodeIterators.add(&amp;iterator);
4577 }
4578 
4579 void Document::detachNodeIterator(NodeIterator&amp; iterator)
4580 {
4581     // The node iterator can be detached without having been attached if its root node didn&#39;t have a document
4582     // when the iterator was created, but has it now.
4583     m_nodeIterators.remove(&amp;iterator);
4584 }
4585 
4586 void Document::moveNodeIteratorsToNewDocumentSlowCase(Node&amp; node, Document&amp; newDocument)
4587 {
4588     ASSERT(!m_nodeIterators.isEmpty());
4589     for (auto* iterator : copyToVector(m_nodeIterators)) {
4590         if (&amp;iterator-&gt;root() == &amp;node) {
4591             detachNodeIterator(*iterator);
4592             newDocument.attachNodeIterator(*iterator);
4593         }
4594     }
4595 }
4596 
4597 void Document::updateRangesAfterChildrenChanged(ContainerNode&amp; container)
4598 {
4599     for (auto* range : m_ranges)
4600         range-&gt;nodeChildrenChanged(container);
4601 }
4602 
4603 void Document::nodeChildrenWillBeRemoved(ContainerNode&amp; container)
4604 {
4605     ASSERT(ScriptDisallowedScope::InMainThread::hasDisallowedScope());
4606 
4607     adjustFocusedNodeOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);
4608     adjustFocusNavigationNodeOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);
4609 
4610 #if ENABLE(FULLSCREEN_API)
4611     m_fullscreenManager-&gt;adjustFullscreenElementOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);
4612 #endif
4613 
4614     for (auto* range : m_ranges)
4615         range-&gt;nodeChildrenWillBeRemoved(container);
4616 
4617     for (auto* it : m_nodeIterators) {
4618         for (Node* n = container.firstChild(); n; n = n-&gt;nextSibling())
4619             it-&gt;nodeWillBeRemoved(*n);
4620     }
4621 
4622     if (RefPtr&lt;Frame&gt; frame = this-&gt;frame()) {
4623         for (Node* n = container.firstChild(); n; n = n-&gt;nextSibling()) {
4624             frame-&gt;eventHandler().nodeWillBeRemoved(*n);
4625             frame-&gt;selection().nodeWillBeRemoved(*n);
4626             frame-&gt;page()-&gt;dragCaretController().nodeWillBeRemoved(*n);
4627         }
4628     }
4629 
4630     if (m_markers-&gt;hasMarkers()) {
4631         for (Text* textNode = TextNodeTraversal::firstChild(container); textNode; textNode = TextNodeTraversal::nextSibling(*textNode))
4632             m_markers-&gt;removeMarkers(*textNode);
4633     }
4634 }
4635 
4636 void Document::nodeWillBeRemoved(Node&amp; node)
4637 {
4638     ASSERT(ScriptDisallowedScope::InMainThread::hasDisallowedScope());
4639 
4640     adjustFocusedNodeOnNodeRemoval(node);
4641     adjustFocusNavigationNodeOnNodeRemoval(node);
4642 
4643 #if ENABLE(FULLSCREEN_API)
4644     m_fullscreenManager-&gt;adjustFullscreenElementOnNodeRemoval(node, NodeRemoval::Node);
4645 #endif
4646 
4647     for (auto* it : m_nodeIterators)
4648         it-&gt;nodeWillBeRemoved(node);
4649 
4650     for (auto* range : m_ranges)
4651         range-&gt;nodeWillBeRemoved(node);
4652 
4653     if (RefPtr&lt;Frame&gt; frame = this-&gt;frame()) {
4654         frame-&gt;eventHandler().nodeWillBeRemoved(node);
4655         frame-&gt;selection().nodeWillBeRemoved(node);
4656         frame-&gt;page()-&gt;dragCaretController().nodeWillBeRemoved(node);
4657     }
4658 
4659     if (is&lt;Text&gt;(node))
4660         m_markers-&gt;removeMarkers(node);
4661 }
4662 
<a name="1" id="anc1"></a>












4663 static Node* fallbackFocusNavigationStartingNodeAfterRemoval(Node&amp; node)
4664 {
4665     return node.previousSibling() ? node.previousSibling() : node.parentNode();
4666 }
4667 
4668 void Document::adjustFocusNavigationNodeOnNodeRemoval(Node&amp; node, NodeRemoval nodeRemoval)
4669 {
4670     if (!m_focusNavigationStartingNode)
4671         return;
4672 
4673     if (isNodeInSubtree(*m_focusNavigationStartingNode, node, nodeRemoval)) {
4674         auto* newNode = (nodeRemoval == NodeRemoval::ChildrenOfNode) ? &amp;node : fallbackFocusNavigationStartingNodeAfterRemoval(node);
4675         m_focusNavigationStartingNode = (newNode != this) ? newNode : nullptr;
4676         m_focusNavigationStartingNodeIsRemoved = true;
4677     }
4678 }
4679 
4680 void Document::textInserted(Node&amp; text, unsigned offset, unsigned length)
4681 {
4682     if (!m_ranges.isEmpty()) {
4683         for (auto* range : m_ranges)
4684             range-&gt;textInserted(text, offset, length);
4685     }
4686 
4687     // Update the markers for spelling and grammar checking.
4688     m_markers-&gt;shiftMarkers(text, offset, length);
4689 
4690 #if ENABLE(PLATFORM_DRIVEN_TEXT_CHECKING)
4691     // Freshly inserted text is expected to not inherit PlatformTextChecking markers.
4692     m_markers-&gt;removeMarkers(text, offset, length, DocumentMarker::PlatformTextChecking);
4693 #endif
4694 }
4695 
4696 void Document::textRemoved(Node&amp; text, unsigned offset, unsigned length)
4697 {
4698     if (!m_ranges.isEmpty()) {
4699         for (auto* range : m_ranges)
4700             range-&gt;textRemoved(text, offset, length);
4701     }
4702 
4703     // Update the markers for spelling and grammar checking.
4704     m_markers-&gt;removeMarkers(text, offset, length);
4705     m_markers-&gt;shiftMarkers(text, offset + length, 0 - length);
4706 }
4707 
4708 void Document::textNodesMerged(Text&amp; oldNode, unsigned offset)
4709 {
4710     if (!m_ranges.isEmpty()) {
4711         NodeWithIndex oldNodeWithIndex(&amp;oldNode);
4712         for (auto* range : m_ranges)
4713             range-&gt;textNodesMerged(oldNodeWithIndex, offset);
4714     }
4715 
4716     // FIXME: This should update markers for spelling and grammar checking.
4717 }
4718 
4719 void Document::textNodeSplit(Text&amp; oldNode)
4720 {
4721     for (auto* range : m_ranges)
4722         range-&gt;textNodeSplit(oldNode);
4723 
4724     // FIXME: This should update markers for spelling and grammar checking.
4725 }
4726 
4727 void Document::createDOMWindow()
4728 {
4729     ASSERT(m_frame);
4730     ASSERT(!m_domWindow);
4731 
4732     m_domWindow = DOMWindow::create(*this);
4733 
4734     ASSERT(m_domWindow-&gt;document() == this);
4735     ASSERT(m_domWindow-&gt;frame() == m_frame);
4736 
4737     m_frame-&gt;loader().client().didCreateWindow(*m_domWindow);
4738 }
4739 
4740 void Document::takeDOMWindowFrom(Document&amp; document)
4741 {
4742     ASSERT(m_frame);
4743     ASSERT(!m_domWindow);
4744     ASSERT(document.m_domWindow);
4745     // A valid DOMWindow is needed by CachedFrame for its documents.
4746     ASSERT(backForwardCacheState() == NotInBackForwardCache);
4747 
4748     m_domWindow = WTFMove(document.m_domWindow);
4749     m_domWindow-&gt;didSecureTransitionTo(*this);
4750 
4751     ASSERT(m_domWindow-&gt;document() == this);
4752     ASSERT(m_domWindow-&gt;frame() == m_frame);
4753 }
4754 
4755 WindowProxy* Document::windowProxy() const
4756 {
4757     if (!m_frame)
4758         return nullptr;
4759     return &amp;m_frame-&gt;windowProxy();
4760 }
4761 
4762 Document&amp; Document::contextDocument() const
4763 {
4764     if (m_contextDocument)
4765         return *m_contextDocument.get();
4766     return const_cast&lt;Document&amp;&gt;(*this);
4767 }
4768 
4769 void Document::setAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)
4770 {
4771     setAttributeEventListener(eventType, JSLazyEventListener::create(*this, attributeName, attributeValue), isolatedWorld);
4772 }
4773 
4774 void Document::setWindowAttributeEventListener(const AtomString&amp; eventType, RefPtr&lt;EventListener&gt;&amp;&amp; listener, DOMWrapperWorld&amp; isolatedWorld)
4775 {
4776     if (!m_domWindow)
4777         return;
4778     m_domWindow-&gt;setAttributeEventListener(eventType, WTFMove(listener), isolatedWorld);
4779 }
4780 
4781 void Document::setWindowAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)
4782 {
4783     if (!m_domWindow)
4784         return;
4785     if (!m_domWindow-&gt;frame())
4786         return;
4787     setWindowAttributeEventListener(eventType, JSLazyEventListener::create(*m_domWindow, attributeName, attributeValue), isolatedWorld);
4788 }
4789 
4790 EventListener* Document::getWindowAttributeEventListener(const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
4791 {
4792     if (!m_domWindow)
4793         return nullptr;
4794     return m_domWindow-&gt;attributeEventListener(eventType, isolatedWorld);
4795 }
4796 
4797 void Document::dispatchWindowEvent(Event&amp; event, EventTarget* target)
4798 {
4799     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
4800     if (!m_domWindow)
4801         return;
4802     m_domWindow-&gt;dispatchEvent(event, target);
4803 }
4804 
4805 void Document::dispatchWindowLoadEvent()
4806 {
4807     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
4808     if (!m_domWindow)
4809         return;
4810     m_domWindow-&gt;dispatchLoadEvent();
4811     m_loadEventFinished = true;
4812     m_cachedResourceLoader-&gt;documentDidFinishLoadEvent();
4813 }
4814 
4815 void Document::queueTaskToDispatchEvent(TaskSource source, Ref&lt;Event&gt;&amp;&amp; event)
4816 {
4817     eventLoop().queueTask(source, [document = makeRef(*this), event = WTFMove(event)] {
4818         document-&gt;dispatchEvent(event);
4819     });
4820 }
4821 
4822 void Document::queueTaskToDispatchEventOnWindow(TaskSource source, Ref&lt;Event&gt;&amp;&amp; event)
4823 {
4824     eventLoop().queueTask(source, [this, protectedThis = makeRef(*this), event = WTFMove(event)] {
4825         if (!m_domWindow)
4826             return;
4827         m_domWindow-&gt;dispatchEvent(event);
4828     });
4829 }
4830 
4831 void Document::enqueueOverflowEvent(Ref&lt;Event&gt;&amp;&amp; event)
4832 {
4833     // https://developer.mozilla.org/en-US/docs/Web/API/Element/overflow_event
4834     // FIXME: This event is totally unspecified.
4835     auto* target = event-&gt;target();
4836     RELEASE_ASSERT(target);
4837     RELEASE_ASSERT(is&lt;Node&gt;(target));
4838     eventLoop().queueTask(TaskSource::DOMManipulation, [protectedTarget = GCReachableRef&lt;Node&gt;(downcast&lt;Node&gt;(*target)), event = WTFMove(event)] {
4839         protectedTarget-&gt;dispatchEvent(event);
4840     });
4841 }
4842 
4843 ExceptionOr&lt;Ref&lt;Event&gt;&gt; Document::createEvent(const String&amp; type)
4844 {
4845     // Please do *not* add new event classes to this function unless they are required
4846     // for compatibility with the DOM specification or some actual legacy web content.
4847 
4848     // This mechanism is superceded by use of event constructors.
4849     // That is what we should use for any new event classes.
4850 
4851     // The following strings are the ones from the DOM specification
4852     // &lt;https://dom.spec.whatwg.org/#dom-document-createevent&gt;.
4853 
4854     if (equalLettersIgnoringASCIICase(type, &quot;beforeunloadevent&quot;))
4855         return Ref&lt;Event&gt; { BeforeUnloadEvent::createForBindings() };
4856     if (equalLettersIgnoringASCIICase(type, &quot;compositionevent&quot;))
4857         return Ref&lt;Event&gt; { CompositionEvent::createForBindings() };
4858     if (equalLettersIgnoringASCIICase(type, &quot;customevent&quot;))
4859         return Ref&lt;Event&gt; { CustomEvent::create() };
4860     if (equalLettersIgnoringASCIICase(type, &quot;dragevent&quot;))
4861         return Ref&lt;Event&gt; { DragEvent::createForBindings() };
4862     if (equalLettersIgnoringASCIICase(type, &quot;event&quot;) || equalLettersIgnoringASCIICase(type, &quot;events&quot;) || equalLettersIgnoringASCIICase(type, &quot;htmlevents&quot;) || equalLettersIgnoringASCIICase(type, &quot;svgevents&quot;))
4863         return Event::createForBindings();
4864     if (equalLettersIgnoringASCIICase(type, &quot;focusevent&quot;))
4865         return Ref&lt;Event&gt; { FocusEvent::createForBindings() };
4866     if (equalLettersIgnoringASCIICase(type, &quot;hashchangeevent&quot;))
4867         return Ref&lt;Event&gt; { HashChangeEvent::createForBindings() };
4868     if (equalLettersIgnoringASCIICase(type, &quot;keyboardevent&quot;))
4869         return Ref&lt;Event&gt; { KeyboardEvent::createForBindings() };
4870     if (equalLettersIgnoringASCIICase(type, &quot;messageevent&quot;))
4871         return Ref&lt;Event&gt; { MessageEvent::createForBindings() };
4872     if (equalLettersIgnoringASCIICase(type, &quot;storageevent&quot;))
4873         return Ref&lt;Event&gt; { StorageEvent::createForBindings() };
4874     if (equalLettersIgnoringASCIICase(type, &quot;mouseevent&quot;) || equalLettersIgnoringASCIICase(type, &quot;mouseevents&quot;))
4875         return Ref&lt;Event&gt; { MouseEvent::createForBindings() };
4876     if (equalLettersIgnoringASCIICase(type, &quot;textevent&quot;))
4877         return Ref&lt;Event&gt; { TextEvent::createForBindings() }; // FIXME: HTML specification says this should create a CompositionEvent, not a TextEvent.
4878     if (equalLettersIgnoringASCIICase(type, &quot;uievent&quot;) || equalLettersIgnoringASCIICase(type, &quot;uievents&quot;))
4879         return Ref&lt;Event&gt; { UIEvent::createForBindings() };
4880 
4881     // FIXME: Consider including support for these event classes even when device orientation
4882     // support is not enabled.
4883 #if ENABLE(DEVICE_ORIENTATION)
4884     if (equalLettersIgnoringASCIICase(type, &quot;devicemotionevent&quot;))
4885         return Ref&lt;Event&gt; { DeviceMotionEvent::createForBindings() };
4886     if (equalLettersIgnoringASCIICase(type, &quot;deviceorientationevent&quot;))
4887         return Ref&lt;Event&gt; { DeviceOrientationEvent::createForBindings() };
4888 #endif
4889 
4890 #if ENABLE(TOUCH_EVENTS)
4891     if (equalLettersIgnoringASCIICase(type, &quot;touchevent&quot;))
4892         return Ref&lt;Event&gt; { TouchEvent::createForBindings() };
4893 #endif
4894 
4895     // FIXME: Add support for &quot;dragevent&quot;, which the DOM specification calls for.
4896 
4897     // The following string comes from the SVG specification
4898     // &lt;http://www.w3.org/TR/SVG/script.html#InterfaceSVGZoomEvent&gt;
4899     // However, since there is no provision for initializing the event once it is created,
4900     // there is no practical value in this feature.
4901     // FIXME: Confirm there is no content depending on this and remove it.
4902 
4903     if (equalLettersIgnoringASCIICase(type, &quot;svgzoomevents&quot;))
4904         return Ref&lt;Event&gt; { SVGZoomEvent::createForBindings() };
4905 
4906     // The following strings are not part of the DOM specification and we would like to eliminate them.
4907     // However, we currently include them until we resolve any issues with backward compatibility.
4908     // FIXME: For each of the strings below, confirm that there is no content depending on it and remove
4909     // the string, remove the createForBindings function, and also consider removing the corresponding
4910     // init function for that class.
4911 
4912     if (equalLettersIgnoringASCIICase(type, &quot;keyboardevents&quot;))
4913         return Ref&lt;Event&gt; { KeyboardEvent::createForBindings() };
4914     if (equalLettersIgnoringASCIICase(type, &quot;mutationevent&quot;) || equalLettersIgnoringASCIICase(type, &quot;mutationevents&quot;))
4915         return Ref&lt;Event&gt; { MutationEvent::createForBindings() };
4916     if (equalLettersIgnoringASCIICase(type, &quot;overflowevent&quot;))
4917         return Ref&lt;Event&gt; { OverflowEvent::createForBindings() };
4918     if (equalLettersIgnoringASCIICase(type, &quot;popstateevent&quot;))
4919         return Ref&lt;Event&gt; { PopStateEvent::createForBindings() };
4920     if (equalLettersIgnoringASCIICase(type, &quot;wheelevent&quot;))
4921         return Ref&lt;Event&gt; { WheelEvent::createForBindings() };
4922 
4923     return Exception { NotSupportedError };
4924 }
4925 
4926 bool Document::hasListenerTypeForEventType(PlatformEvent::Type eventType) const
4927 {
4928     switch (eventType) {
4929     case PlatformEvent::MouseForceChanged:
4930         return m_listenerTypes &amp; Document::FORCECHANGED_LISTENER;
4931     case PlatformEvent::MouseForceDown:
4932         return m_listenerTypes &amp; Document::FORCEDOWN_LISTENER;
4933     case PlatformEvent::MouseForceUp:
4934         return m_listenerTypes &amp; Document::FORCEUP_LISTENER;
4935     case PlatformEvent::MouseScroll:
4936         return m_listenerTypes &amp; Document::SCROLL_LISTENER;
4937     default:
4938         return false;
4939     }
4940 }
4941 
4942 void Document::addListenerTypeIfNeeded(const AtomString&amp; eventType)
4943 {
4944     if (eventType == eventNames().DOMSubtreeModifiedEvent)
4945         addListenerType(DOMSUBTREEMODIFIED_LISTENER);
4946     else if (eventType == eventNames().DOMNodeInsertedEvent)
4947         addListenerType(DOMNODEINSERTED_LISTENER);
4948     else if (eventType == eventNames().DOMNodeRemovedEvent)
4949         addListenerType(DOMNODEREMOVED_LISTENER);
4950     else if (eventType == eventNames().DOMNodeRemovedFromDocumentEvent)
4951         addListenerType(DOMNODEREMOVEDFROMDOCUMENT_LISTENER);
4952     else if (eventType == eventNames().DOMNodeInsertedIntoDocumentEvent)
4953         addListenerType(DOMNODEINSERTEDINTODOCUMENT_LISTENER);
4954     else if (eventType == eventNames().DOMCharacterDataModifiedEvent)
4955         addListenerType(DOMCHARACTERDATAMODIFIED_LISTENER);
4956     else if (eventType == eventNames().overflowchangedEvent)
4957         addListenerType(OVERFLOWCHANGED_LISTENER);
4958     else if (eventType == eventNames().webkitAnimationStartEvent || eventType == eventNames().animationstartEvent)
4959         addListenerType(ANIMATIONSTART_LISTENER);
4960     else if (eventType == eventNames().webkitAnimationEndEvent || eventType == eventNames().animationendEvent)
4961         addListenerType(ANIMATIONEND_LISTENER);
4962     else if (eventType == eventNames().webkitAnimationIterationEvent || eventType == eventNames().animationiterationEvent)
4963         addListenerType(ANIMATIONITERATION_LISTENER);
4964     else if (eventType == eventNames().webkitTransitionEndEvent || eventType == eventNames().transitionendEvent)
4965         addListenerType(TRANSITIONEND_LISTENER);
4966     else if (eventType == eventNames().beforeloadEvent)
4967         addListenerType(BEFORELOAD_LISTENER);
4968     else if (eventType == eventNames().scrollEvent)
4969         addListenerType(SCROLL_LISTENER);
4970     else if (eventType == eventNames().webkitmouseforcewillbeginEvent)
4971         addListenerType(FORCEWILLBEGIN_LISTENER);
4972     else if (eventType == eventNames().webkitmouseforcechangedEvent)
4973         addListenerType(FORCECHANGED_LISTENER);
4974     else if (eventType == eventNames().webkitmouseforcedownEvent)
4975         addListenerType(FORCEDOWN_LISTENER);
4976     else if (eventType == eventNames().webkitmouseforceupEvent)
4977         addListenerType(FORCEUP_LISTENER);
4978     else if (eventType == eventNames().resizeEvent)
4979         addListenerType(RESIZE_LISTENER);
4980 }
4981 
4982 HTMLFrameOwnerElement* Document::ownerElement() const
4983 {
4984     if (!frame())
4985         return nullptr;
4986     return frame()-&gt;ownerElement();
4987 }
4988 
4989 // https://html.spec.whatwg.org/#cookie-averse-document-object
4990 bool Document::isCookieAverse() const
4991 {
4992     // A Document that has no browsing context is cookie-averse.
4993     if (!frame())
4994         return true;
4995 
4996     URL cookieURL = this-&gt;cookieURL();
4997 
4998     // This is not part of the specification but we have historically allowed cookies over file protocol
4999     // and some developers rely on this for testing.
5000     if (cookieURL.isLocalFile())
5001         return false;
5002 
5003     // A Document whose URL&#39;s scheme is not a network scheme is cookie-averse (https://fetch.spec.whatwg.org/#network-scheme).
5004     return !cookieURL.protocolIsInHTTPFamily() &amp;&amp; !cookieURL.protocolIs(&quot;ftp&quot;);
5005 }
5006 
5007 ExceptionOr&lt;String&gt; Document::cookie()
5008 {
5009     if (page() &amp;&amp; !page()-&gt;settings().cookieEnabled())
5010         return String();
5011 
5012     if (isCookieAverse())
5013         return String();
5014 
5015     if (!securityOrigin().canAccessCookies())
5016         return Exception { SecurityError };
5017 
5018     URL cookieURL = this-&gt;cookieURL();
5019     if (cookieURL.isEmpty())
5020         return String();
5021 
5022     if (!isDOMCookieCacheValid() &amp;&amp; page())
5023         setCachedDOMCookies(page()-&gt;cookieJar().cookies(*this, cookieURL));
5024 
5025     return String { cachedDOMCookies() };
5026 }
5027 
5028 ExceptionOr&lt;void&gt; Document::setCookie(const String&amp; value)
5029 {
5030     if (page() &amp;&amp; !page()-&gt;settings().cookieEnabled())
5031         return { };
5032 
5033     if (isCookieAverse())
5034         return { };
5035 
5036     if (!securityOrigin().canAccessCookies())
5037         return Exception { SecurityError };
5038 
5039     URL cookieURL = this-&gt;cookieURL();
5040     if (cookieURL.isEmpty())
5041         return { };
5042 
5043     invalidateDOMCookieCache();
5044     if (page())
5045         page()-&gt;cookieJar().setCookies(*this, cookieURL, value);
5046     return { };
5047 }
5048 
5049 String Document::referrer()
5050 {
5051 #if ENABLE(RESOURCE_LOAD_STATISTICS)
5052     if (!m_referrerOverride.isEmpty())
5053         return m_referrerOverride;
5054     if (DeprecatedGlobalSettings::resourceLoadStatisticsEnabled() &amp;&amp; frame()) {
5055         auto referrerStr = frame()-&gt;loader().referrer();
5056         if (!referrerStr.isEmpty()) {
5057             URL referrerURL { URL(), referrerStr };
5058             RegistrableDomain referrerRegistrableDomain { referrerURL };
5059             if (!referrerRegistrableDomain.matches(securityOrigin().data())) {
5060                 m_referrerOverride = referrerURL.protocolHostAndPort();
5061                 return m_referrerOverride;
5062             }
5063         }
5064     }
5065 #endif
5066     if (frame())
5067         return frame()-&gt;loader().referrer();
5068     return String();
5069 }
5070 
5071 String Document::domain() const
5072 {
5073     return securityOrigin().domain();
5074 }
5075 
5076 ExceptionOr&lt;void&gt; Document::setDomain(const String&amp; newDomain)
5077 {
5078     if (!frame())
5079         return Exception { SecurityError, &quot;A browsing context is required to set a domain.&quot; };
5080 
5081     if (isSandboxed(SandboxDocumentDomain))
5082         return Exception { SecurityError, &quot;Assignment is forbidden for sandboxed iframes.&quot; };
5083 
5084     if (LegacySchemeRegistry::isDomainRelaxationForbiddenForURLScheme(securityOrigin().protocol()))
5085         return Exception { SecurityError };
5086 
5087     // FIXME: We should add logging indicating why a domain was not allowed.
5088 
5089     const String&amp; effectiveDomain = domain();
5090     if (effectiveDomain.isEmpty())
5091         return Exception { SecurityError, &quot;The document has a null effectiveDomain.&quot; };
5092 
5093     if (!securityOrigin().isMatchingRegistrableDomainSuffix(newDomain, settings().treatIPAddressAsDomain()))
5094         return Exception { SecurityError, &quot;Attempted to use a non-registrable domain.&quot; };
5095 
5096     securityOrigin().setDomainFromDOM(newDomain);
5097     return { };
5098 }
5099 
5100 void Document::overrideLastModified(const Optional&lt;WallTime&gt;&amp; lastModified)
5101 {
5102     m_overrideLastModified = lastModified;
5103 }
5104 
5105 // http://www.whatwg.org/specs/web-apps/current-work/#dom-document-lastmodified
5106 String Document::lastModified() const
5107 {
5108     Optional&lt;WallTime&gt; dateTime;
5109     if (m_overrideLastModified)
5110         dateTime = m_overrideLastModified;
5111     else if (loader())
5112         dateTime = loader()-&gt;response().lastModified();
5113 
5114     // FIXME: If this document came from the file system, the HTML specification tells
5115     // us to read the last modification date from the file system.
5116     if (!dateTime)
5117         dateTime = WallTime::now();
5118 
5119     auto ctime = dateTime.value().secondsSinceEpoch().secondsAs&lt;time_t&gt;();
5120     auto localDateTime = std::localtime(&amp;ctime);
5121     return makeString(pad(&#39;0&#39;, 2, localDateTime-&gt;tm_mon + 1), &#39;/&#39;,
5122         pad(&#39;0&#39;, 2, localDateTime-&gt;tm_mday), &#39;/&#39;,
5123         pad(&#39;0&#39;, 4, 1900 + localDateTime-&gt;tm_year), &#39; &#39;,
5124         pad(&#39;0&#39;, 2, localDateTime-&gt;tm_hour), &#39;:&#39;,
5125         pad(&#39;0&#39;, 2, localDateTime-&gt;tm_min), &#39;:&#39;,
5126         pad(&#39;0&#39;, 2, localDateTime-&gt;tm_sec));
5127 }
5128 
5129 void Document::setCookieURL(const URL&amp; url)
5130 {
5131     if (m_cookieURL == url)
5132         return;
5133     m_cookieURL = url;
5134     invalidateDOMCookieCache();
5135 }
5136 
5137 static bool isValidNameNonASCII(const LChar* characters, unsigned length)
5138 {
5139     if (!isValidNameStart(characters[0]))
5140         return false;
5141 
5142     for (unsigned i = 1; i &lt; length; ++i) {
5143         if (!isValidNamePart(characters[i]))
5144             return false;
5145     }
5146 
5147     return true;
5148 }
5149 
5150 static bool isValidNameNonASCII(const UChar* characters, unsigned length)
5151 {
5152     unsigned i = 0;
5153 
5154     UChar32 c;
5155     U16_NEXT(characters, i, length, c);
5156     if (!isValidNameStart(c))
5157         return false;
5158 
5159     while (i &lt; length) {
5160         U16_NEXT(characters, i, length, c);
5161         if (!isValidNamePart(c))
5162             return false;
5163     }
5164 
5165     return true;
5166 }
5167 
5168 template&lt;typename CharType&gt;
5169 static inline bool isValidNameASCII(const CharType* characters, unsigned length)
5170 {
5171     CharType c = characters[0];
5172     if (!(isASCIIAlpha(c) || c == &#39;:&#39; || c == &#39;_&#39;))
5173         return false;
5174 
5175     for (unsigned i = 1; i &lt; length; ++i) {
5176         c = characters[i];
5177         if (!(isASCIIAlphanumeric(c) || c == &#39;:&#39; || c == &#39;_&#39; || c == &#39;-&#39; || c == &#39;.&#39;))
5178             return false;
5179     }
5180 
5181     return true;
5182 }
5183 
5184 bool Document::isValidName(const String&amp; name)
5185 {
5186     unsigned length = name.length();
5187     if (!length)
5188         return false;
5189 
5190     if (name.is8Bit()) {
5191         const LChar* characters = name.characters8();
5192 
5193         if (isValidNameASCII(characters, length))
5194             return true;
5195 
5196         return isValidNameNonASCII(characters, length);
5197     }
5198 
5199     const UChar* characters = name.characters16();
5200 
5201     if (isValidNameASCII(characters, length))
5202         return true;
5203 
5204     return isValidNameNonASCII(characters, length);
5205 }
5206 
5207 ExceptionOr&lt;std::pair&lt;AtomString, AtomString&gt;&gt; Document::parseQualifiedName(const String&amp; qualifiedName)
5208 {
5209     unsigned length = qualifiedName.length();
5210 
5211     if (!length)
5212         return Exception { InvalidCharacterError };
5213 
5214     bool nameStart = true;
5215     bool sawColon = false;
5216     unsigned colonPosition = 0;
5217 
5218     for (unsigned i = 0; i &lt; length; ) {
5219         UChar32 c;
5220         U16_NEXT(qualifiedName, i, length, c);
5221         if (c == &#39;:&#39;) {
5222             if (sawColon)
5223                 return Exception { InvalidCharacterError };
5224             nameStart = true;
5225             sawColon = true;
5226             colonPosition = i - 1;
5227         } else if (nameStart) {
5228             if (!isValidNameStart(c))
5229                 return Exception { InvalidCharacterError };
5230             nameStart = false;
5231         } else {
5232             if (!isValidNamePart(c))
5233                 return Exception { InvalidCharacterError };
5234         }
5235     }
5236 
5237     if (!sawColon)
5238         return std::pair&lt;AtomString, AtomString&gt; { { }, { qualifiedName } };
5239 
5240     if (!colonPosition || length - colonPosition &lt;= 1)
5241         return Exception { InvalidCharacterError };
5242 
5243     return std::pair&lt;AtomString, AtomString&gt; { StringView { qualifiedName }.substring(0, colonPosition).toAtomString(), StringView { qualifiedName }.substring(colonPosition + 1).toAtomString() };
5244 }
5245 
5246 ExceptionOr&lt;QualifiedName&gt; Document::parseQualifiedName(const AtomString&amp; namespaceURI, const String&amp; qualifiedName)
5247 {
5248     auto parseResult = parseQualifiedName(qualifiedName);
5249     if (parseResult.hasException())
5250         return parseResult.releaseException();
5251     auto parsedPieces = parseResult.releaseReturnValue();
5252     return QualifiedName { parsedPieces.first, parsedPieces.second, namespaceURI };
5253 }
5254 
5255 void Document::setDecoder(RefPtr&lt;TextResourceDecoder&gt;&amp;&amp; decoder)
5256 {
5257     m_decoder = WTFMove(decoder);
5258 }
5259 
5260 URL Document::completeURL(const String&amp; url, const URL&amp; baseURLOverride, ForceUTF8 forceUTF8) const
5261 {
5262     // Always return a null URL when passed a null string.
5263     // FIXME: Should we change the URL constructor to have this behavior?
5264     // See also [CSS]StyleSheet::completeURL(const String&amp;)
5265     if (url.isNull())
5266         return URL();
5267     const URL&amp; baseURL = ((baseURLOverride.isEmpty() || baseURLOverride == WTF::blankURL()) &amp;&amp; parentDocument()) ? parentDocument()-&gt;baseURL() : baseURLOverride;
5268     if (!m_decoder || forceUTF8 == ForceUTF8::Yes)
5269         return URL(baseURL, url);
5270     return URL(baseURL, url, m_decoder-&gt;encodingForURLParsing());
5271 }
5272 
5273 URL Document::completeURL(const String&amp; url, ForceUTF8 forceUTF8) const
5274 {
5275     return completeURL(url, m_baseURL, forceUTF8);
5276 }
5277 
5278 void Document::setBackForwardCacheState(BackForwardCacheState state)
5279 {
5280     if (m_backForwardCacheState == state)
5281         return;
5282 
5283     m_backForwardCacheState = state;
5284 
5285     FrameView* v = view();
5286     Page* page = this-&gt;page();
5287 
5288     switch (state) {
5289     case InBackForwardCache:
5290         if (v) {
5291             // FIXME: There is some scrolling related work that needs to happen whenever a page goes into the
5292             // back/forward cache and similar work that needs to occur when it comes out. This is where we do the work
5293             // that needs to happen when we enter, and the work that needs to happen when we exit is in
5294             // HistoryController::restoreScrollPositionAndViewState(). It can&#39;t be here because this function is
5295             // called too early on in the process of a page exiting the cache for that work to be possible in this
5296             // function. It would be nice if there was more symmetry here.
5297             // https://bugs.webkit.org/show_bug.cgi?id=98698
5298             v-&gt;cacheCurrentScrollPosition();
5299             if (page &amp;&amp; m_frame-&gt;isMainFrame()) {
5300                 v-&gt;resetScrollbarsAndClearContentsSize();
5301                 if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
5302                     scrollingCoordinator-&gt;clearAllNodes();
5303             }
5304         }
5305 
5306 #if ENABLE(POINTER_LOCK)
5307         exitPointerLock();
5308 #endif
5309 
5310         styleScope().clearResolver();
5311         clearSelectorQueryCache();
5312         m_styleRecalcTimer.stop();
5313 
5314         clearSharedObjectPool();
5315 
5316 #if ENABLE(INDEXED_DATABASE)
5317         if (m_idbConnectionProxy)
5318             m_idbConnectionProxy-&gt;setContextSuspended(*scriptExecutionContext(), true);
5319 #endif
5320         break;
5321     case NotInBackForwardCache:
5322         if (childNeedsStyleRecalc())
5323             scheduleStyleRecalc();
5324 #if ENABLE(INDEXED_DATABASE)
5325         if (m_idbConnectionProxy)
5326             m_idbConnectionProxy-&gt;setContextSuspended(*scriptExecutionContext(), false);
5327 #endif
5328         break;
5329     case AboutToEnterBackForwardCache:
5330         break;
5331     }
5332 }
5333 
5334 void Document::documentWillBecomeInactive()
5335 {
5336     if (renderView())
5337         renderView()-&gt;setIsInWindow(false);
5338 }
5339 
5340 void Document::suspend(ReasonForSuspension reason)
5341 {
5342     if (m_isSuspended)
5343         return;
5344 
5345     documentWillBecomeInactive();
5346 
5347     for (auto* element : m_documentSuspensionCallbackElements)
5348         element-&gt;prepareForDocumentSuspension();
5349 
5350 #if ASSERT_ENABLED
5351     // Clear the update flag to be able to check if the viewport arguments update
5352     // is dispatched, after the document is restored from the back/forward cache.
5353     m_didDispatchViewportPropertiesChanged = false;
5354 #endif
5355 
5356     ASSERT(page());
5357     page()-&gt;lockAllOverlayScrollbarsToHidden(true);
5358 
5359     if (RenderView* view = renderView()) {
5360         if (view-&gt;usesCompositing())
5361             view-&gt;compositor().cancelCompositingLayerUpdate();
5362     }
5363 
5364 #if USE(LIBWEBRTC)
5365     // FIXME: This should be moved to Modules/mediastream.
5366     if (LibWebRTCProvider::webRTCAvailable()) {
5367         if (auto* page = this-&gt;page())
5368             page-&gt;libWebRTCProvider().unregisterMDNSNames(identifier().toUInt64());
5369     }
5370 #endif
5371 
5372 #if ENABLE(SERVICE_WORKER)
5373     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; reason == ReasonForSuspension::BackForwardCache)
5374         setServiceWorkerConnection(nullptr);
5375 #endif
5376 
5377     suspendScheduledTasks(reason);
5378 
5379     ASSERT(m_frame);
5380     m_frame-&gt;clearTimers();
5381 
5382     m_visualUpdatesAllowed = false;
5383     m_visualUpdatesSuppressionTimer.stop();
5384 
5385     m_isSuspended = true;
5386 }
5387 
5388 void Document::resume(ReasonForSuspension reason)
5389 {
5390     if (!m_isSuspended)
5391         return;
5392 
5393     for (auto* element : copyToVector(m_documentSuspensionCallbackElements))
5394         element-&gt;resumeFromDocumentSuspension();
5395 
5396     if (renderView())
5397         renderView()-&gt;setIsInWindow(true);
5398 
5399     ASSERT(page());
5400     page()-&gt;lockAllOverlayScrollbarsToHidden(false);
5401 
5402     ASSERT(m_frame);
5403     m_frame-&gt;loader().client().dispatchDidBecomeFrameset(isFrameSet());
5404 
5405     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
5406         if (auto* timeline = existingTimeline())
5407             timeline-&gt;resumeAnimations();
5408     } else
5409         m_frame-&gt;animation().resumeAnimationsForDocument(this);
5410 
5411     resumeScheduledTasks(reason);
5412 
5413     m_visualUpdatesAllowed = true;
5414 
5415     m_isSuspended = false;
5416 
5417 #if ENABLE(SERVICE_WORKER)
5418     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; reason == ReasonForSuspension::BackForwardCache)
5419         setServiceWorkerConnection(&amp;ServiceWorkerProvider::singleton().serviceWorkerConnection());
5420 #endif
5421 }
5422 
5423 void Document::registerForDocumentSuspensionCallbacks(Element&amp; element)
5424 {
5425     m_documentSuspensionCallbackElements.add(&amp;element);
5426 }
5427 
5428 void Document::unregisterForDocumentSuspensionCallbacks(Element&amp; element)
5429 {
5430     m_documentSuspensionCallbackElements.remove(&amp;element);
5431 }
5432 
5433 bool Document::audioPlaybackRequiresUserGesture() const
5434 {
5435     if (DocumentLoader* loader = this-&gt;loader()) {
5436         // If an audio playback policy was set during navigation, use it. If not, use the global settings.
5437         AutoplayPolicy policy = loader-&gt;autoplayPolicy();
5438         if (policy != AutoplayPolicy::Default)
5439             return policy == AutoplayPolicy::AllowWithoutSound || policy == AutoplayPolicy::Deny;
5440     }
5441 
5442     return settings().audioPlaybackRequiresUserGesture();
5443 }
5444 
5445 bool Document::videoPlaybackRequiresUserGesture() const
5446 {
5447     if (DocumentLoader* loader = this-&gt;loader()) {
5448         // If a video playback policy was set during navigation, use it. If not, use the global settings.
5449         AutoplayPolicy policy = loader-&gt;autoplayPolicy();
5450         if (policy != AutoplayPolicy::Default)
5451             return policy == AutoplayPolicy::Deny;
5452     }
5453 
5454     return settings().videoPlaybackRequiresUserGesture();
5455 }
5456 
5457 bool Document::mediaDataLoadsAutomatically() const
5458 {
5459     if (auto* loader = this-&gt;loader()) {
5460         AutoplayPolicy policy = loader-&gt;autoplayPolicy();
5461         if (policy != AutoplayPolicy::Default)
5462             return policy != AutoplayPolicy::Deny;
5463     }
5464 
5465     return settings().mediaDataLoadsAutomatically();
5466 }
5467 
5468 void Document::storageBlockingStateDidChange()
5469 {
5470     securityOrigin().setStorageBlockingPolicy(settings().storageBlockingPolicy());
5471 }
5472 
5473 // Used only by WebKitLegacy.
5474 void Document::privateBrowsingStateDidChange(PAL::SessionID sessionID)
5475 {
5476     if (m_logger)
5477         m_logger-&gt;setEnabled(this, sessionID.isAlwaysOnLoggingAllowed());
5478 
5479 #if ENABLE(VIDEO)
5480     forEachMediaElement([sessionID] (HTMLMediaElement&amp; element) {
5481         element.privateBrowsingStateDidChange(sessionID);
5482     });
5483 #endif
5484 }
5485 
5486 #if ENABLE(VIDEO_TRACK)
5487 
5488 void Document::registerForCaptionPreferencesChangedCallbacks(HTMLMediaElement&amp; element)
5489 {
5490     if (page())
5491         page()-&gt;group().captionPreferences().setInterestedInCaptionPreferenceChanges();
5492 
5493     m_captionPreferencesChangedElements.add(&amp;element);
5494 }
5495 
5496 void Document::unregisterForCaptionPreferencesChangedCallbacks(HTMLMediaElement&amp; element)
5497 {
5498     m_captionPreferencesChangedElements.remove(&amp;element);
5499 }
5500 
5501 void Document::captionPreferencesChanged()
5502 {
5503     for (auto* element : m_captionPreferencesChangedElements)
5504         element-&gt;captionPreferencesChanged();
5505 }
5506 
5507 #endif
5508 
5509 void Document::setShouldCreateRenderers(bool f)
5510 {
5511     m_createRenderers = f;
5512 }
5513 
5514 bool Document::shouldCreateRenderers()
5515 {
5516     return m_createRenderers;
5517 }
5518 
5519 // Support for Javascript execCommand, and related methods
5520 
5521 static Editor::Command command(Document* document, const String&amp; commandName, bool userInterface = false)
5522 {
5523     auto protectedDocument = makeRef(*document);
5524 
5525     document-&gt;updateStyleIfNeeded();
5526 
5527     auto frame = makeRefPtr(document-&gt;frame());
5528 
5529     if (!frame || frame-&gt;document() != document)
5530         return Editor::Command();
5531 
5532     return frame-&gt;editor().command(commandName,
5533         userInterface ? CommandFromDOMWithUserInterface : CommandFromDOM);
5534 }
5535 
5536 bool Document::execCommand(const String&amp; commandName, bool userInterface, const String&amp; value)
5537 {
5538     EventQueueScope eventQueueScope;
5539     return command(this, commandName, userInterface).execute(value);
5540 }
5541 
5542 bool Document::queryCommandEnabled(const String&amp; commandName)
5543 {
5544     return command(this, commandName).isEnabled();
5545 }
5546 
5547 bool Document::queryCommandIndeterm(const String&amp; commandName)
5548 {
5549     return command(this, commandName).state() == MixedTriState;
5550 }
5551 
5552 bool Document::queryCommandState(const String&amp; commandName)
5553 {
5554     return command(this, commandName).state() == TrueTriState;
5555 }
5556 
5557 bool Document::queryCommandSupported(const String&amp; commandName)
5558 {
5559     return command(this, commandName).isSupported();
5560 }
5561 
5562 String Document::queryCommandValue(const String&amp; commandName)
5563 {
5564     return command(this, commandName).value();
5565 }
5566 
5567 void Document::pushCurrentScript(HTMLScriptElement* newCurrentScript)
5568 {
5569     m_currentScriptStack.append(newCurrentScript);
5570 }
5571 
5572 void Document::popCurrentScript()
5573 {
5574     ASSERT(!m_currentScriptStack.isEmpty());
5575     m_currentScriptStack.removeLast();
5576 }
5577 
5578 bool Document::shouldDeferAsynchronousScriptsUntilParsingFinishes() const
5579 {
5580     return parsing() &amp;&amp; settings().shouldDeferAsynchronousScriptsUntilAfterDocumentLoad();
5581 }
5582 
5583 #if ENABLE(XSLT)
5584 
5585 void Document::scheduleToApplyXSLTransforms()
5586 {
5587     m_hasPendingXSLTransforms = true;
5588     if (!m_applyPendingXSLTransformsTimer.isActive())
5589         m_applyPendingXSLTransformsTimer.startOneShot(0_s);
5590 }
5591 
5592 void Document::applyPendingXSLTransformsNowIfScheduled()
5593 {
5594     if (!m_hasPendingXSLTransforms)
5595         return;
5596     m_applyPendingXSLTransformsTimer.stop();
5597     applyPendingXSLTransformsTimerFired();
5598 }
5599 
5600 void Document::applyPendingXSLTransformsTimerFired()
5601 {
5602     if (parsing())
5603         return;
5604 
5605     m_hasPendingXSLTransforms = false;
5606     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
5607     for (auto&amp; processingInstruction : styleScope().collectXSLTransforms()) {
5608         ASSERT(processingInstruction-&gt;isXSL());
5609 
5610         // Don&#39;t apply XSL transforms to already transformed documents -- &lt;rdar://problem/4132806&gt;
5611         if (transformSourceDocument() || !processingInstruction-&gt;sheet())
5612             return;
5613 
5614         // If the Document has already been detached from the frame, or the frame is currently in the process of
5615         // changing to a new document, don&#39;t attempt to create a new Document from the XSLT.
5616         if (!frame() || frame()-&gt;documentIsBeingReplaced())
5617             return;
5618 
5619         auto processor = XSLTProcessor::create();
5620         processor-&gt;setXSLStyleSheet(downcast&lt;XSLStyleSheet&gt;(processingInstruction-&gt;sheet()));
5621         String resultMIMEType;
5622         String newSource;
5623         String resultEncoding;
5624         if (!processor-&gt;transformToString(*this, resultMIMEType, newSource, resultEncoding))
5625             continue;
5626         // FIXME: If the transform failed we should probably report an error (like Mozilla does).
5627         processor-&gt;createDocumentFromSource(newSource, resultEncoding, resultMIMEType, this, frame());
5628     }
5629 }
5630 
5631 void Document::setTransformSource(std::unique_ptr&lt;TransformSource&gt; source)
5632 {
5633     m_transformSource = WTFMove(source);
5634 }
5635 
5636 #endif
5637 
5638 void Document::setDesignMode(InheritedBool value)
5639 {
5640     m_designMode = value;
5641     for (Frame* frame = m_frame; frame &amp;&amp; frame-&gt;document(); frame = frame-&gt;tree().traverseNext(m_frame))
5642         frame-&gt;document()-&gt;scheduleFullStyleRebuild();
5643 }
5644 
5645 String Document::designMode() const
5646 {
5647     return inDesignMode() ? &quot;on&quot;_s : &quot;off&quot;_s;
5648 }
5649 
5650 void Document::setDesignMode(const String&amp; value)
5651 {
5652     InheritedBool mode;
5653     if (equalLettersIgnoringASCIICase(value, &quot;on&quot;))
5654         mode = on;
5655     else if (equalLettersIgnoringASCIICase(value, &quot;off&quot;))
5656         mode = off;
5657     else
5658         mode = inherit;
5659     setDesignMode(mode);
5660 }
5661 
5662 auto Document::getDesignMode() const -&gt; InheritedBool
5663 {
5664     return m_designMode;
5665 }
5666 
5667 bool Document::inDesignMode() const
5668 {
5669     for (const Document* d = this; d; d = d-&gt;parentDocument()) {
5670         if (d-&gt;m_designMode != inherit)
5671             return d-&gt;m_designMode;
5672     }
5673     return false;
5674 }
5675 
5676 Document* Document::parentDocument() const
5677 {
5678     if (!m_frame)
5679         return nullptr;
5680     Frame* parent = m_frame-&gt;tree().parent();
5681     if (!parent)
5682         return nullptr;
5683     return parent-&gt;document();
5684 }
5685 
5686 Document&amp; Document::topDocument() const
5687 {
5688     // FIXME: This special-casing avoids incorrectly determined top documents during the process
5689     // of AXObjectCache teardown or notification posting for cached or being-destroyed documents.
5690     if (backForwardCacheState() == NotInBackForwardCache &amp;&amp; !m_renderTreeBeingDestroyed) {
5691         if (!m_frame)
5692             return const_cast&lt;Document&amp;&gt;(*this);
5693         // This should always be non-null.
5694         Document* mainFrameDocument = m_frame-&gt;mainFrame().document();
5695         return mainFrameDocument ? *mainFrameDocument : const_cast&lt;Document&amp;&gt;(*this);
5696     }
5697 
5698     Document* document = const_cast&lt;Document*&gt;(this);
5699     while (HTMLFrameOwnerElement* element = document-&gt;ownerElement())
5700         document = &amp;element-&gt;document();
5701     return *document;
5702 }
5703 
5704 ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttribute(const String&amp; localName)
5705 {
5706     if (!isValidName(localName))
5707         return Exception { InvalidCharacterError };
5708     return Attr::create(*this, QualifiedName { nullAtom(), isHTMLDocument() ? localName.convertToASCIILowercase() : localName, nullAtom() }, emptyString());
5709 }
5710 
5711 ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttributeNS(const AtomString&amp; namespaceURI, const String&amp; qualifiedName, bool shouldIgnoreNamespaceChecks)
5712 {
5713     auto parseResult = parseQualifiedName(namespaceURI, qualifiedName);
5714     if (parseResult.hasException())
5715         return parseResult.releaseException();
5716     QualifiedName parsedName { parseResult.releaseReturnValue() };
5717     if (!shouldIgnoreNamespaceChecks &amp;&amp; !hasValidNamespaceForAttributes(parsedName))
5718         return Exception { NamespaceError };
5719     return Attr::create(*this, parsedName, emptyString());
5720 }
5721 
5722 const SVGDocumentExtensions* Document::svgExtensions()
5723 {
5724     return m_svgExtensions.get();
5725 }
5726 
5727 SVGDocumentExtensions&amp; Document::accessSVGExtensions()
5728 {
5729     if (!m_svgExtensions)
5730         m_svgExtensions = makeUnique&lt;SVGDocumentExtensions&gt;(*this);
5731     return *m_svgExtensions;
5732 }
5733 
5734 void Document::addSVGUseElement(SVGUseElement&amp; element)
5735 {
5736     auto result = m_svgUseElements.add(&amp;element);
5737     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(result.isNewEntry);
5738 }
5739 
5740 void Document::removeSVGUseElement(SVGUseElement&amp; element)
5741 {
5742     m_svgUseElements.remove(&amp;element);
5743     // FIXME: Assert that element was in m_svgUseElements once re-entrancy to update style and layout have been removed.
5744 }
5745 
5746 bool Document::hasSVGRootNode() const
5747 {
5748     return documentElement() &amp;&amp; documentElement()-&gt;hasTagName(SVGNames::svgTag);
5749 }
5750 
5751 template &lt;CollectionType collectionType&gt;
5752 Ref&lt;HTMLCollection&gt; Document::ensureCachedCollection()
5753 {
5754     return ensureRareData().ensureNodeLists().addCachedCollection&lt;GenericCachedHTMLCollection&lt;CollectionTypeTraits&lt;collectionType&gt;::traversalType&gt;&gt;(*this, collectionType);
5755 }
5756 
5757 Ref&lt;HTMLCollection&gt; Document::images()
5758 {
5759     return ensureCachedCollection&lt;DocImages&gt;();
5760 }
5761 
5762 Ref&lt;HTMLCollection&gt; Document::applets()
5763 {
5764     return ensureCachedCollection&lt;DocApplets&gt;();
5765 }
5766 
5767 Ref&lt;HTMLCollection&gt; Document::embeds()
5768 {
5769     return ensureCachedCollection&lt;DocEmbeds&gt;();
5770 }
5771 
5772 Ref&lt;HTMLCollection&gt; Document::plugins()
5773 {
5774     // This is an alias for embeds() required for the JS DOM bindings.
5775     return ensureCachedCollection&lt;DocEmbeds&gt;();
5776 }
5777 
5778 Ref&lt;HTMLCollection&gt; Document::scripts()
5779 {
5780     return ensureCachedCollection&lt;DocScripts&gt;();
5781 }
5782 
5783 Ref&lt;HTMLCollection&gt; Document::links()
5784 {
5785     return ensureCachedCollection&lt;DocLinks&gt;();
5786 }
5787 
5788 Ref&lt;HTMLCollection&gt; Document::forms()
5789 {
5790     return ensureCachedCollection&lt;DocForms&gt;();
5791 }
5792 
5793 Ref&lt;HTMLCollection&gt; Document::anchors()
5794 {
5795     return ensureCachedCollection&lt;DocAnchors&gt;();
5796 }
5797 
5798 Ref&lt;HTMLCollection&gt; Document::all()
5799 {
5800     return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLAllCollection&gt;(*this, DocAll);
5801 }
5802 
5803 Ref&lt;HTMLCollection&gt; Document::allFilteredByName(const AtomString&amp; name)
5804 {
5805     return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLAllNamedSubCollection&gt;(*this, DocumentAllNamedItems, name);
5806 }
5807 
5808 Ref&lt;HTMLCollection&gt; Document::windowNamedItems(const AtomString&amp; name)
5809 {
5810     return ensureRareData().ensureNodeLists().addCachedCollection&lt;WindowNameCollection&gt;(*this, WindowNamedItems, name);
5811 }
5812 
5813 Ref&lt;HTMLCollection&gt; Document::documentNamedItems(const AtomString&amp; name)
5814 {
5815     return ensureRareData().ensureNodeLists().addCachedCollection&lt;DocumentNameCollection&gt;(*this, DocumentNamedItems, name);
5816 }
5817 
5818 void Document::finishedParsing()
5819 {
5820     ASSERT(!scriptableDocumentParser() || !m_parser-&gt;isParsing());
5821     ASSERT(!scriptableDocumentParser() || m_readyState != Loading);
5822     setParsing(false);
5823 
5824     Ref&lt;Document&gt; protectedThis(*this);
5825 
5826     scriptRunner().documentFinishedParsing();
5827 
5828     if (!m_documentTiming.domContentLoadedEventStart)
5829         m_documentTiming.domContentLoadedEventStart = MonotonicTime::now();
5830 
5831     // FIXME: Schedule a task to fire DOMContentLoaded event instead. See webkit.org/b/82931
5832     eventLoop().performMicrotaskCheckpoint();
5833     dispatchEvent(Event::create(eventNames().DOMContentLoadedEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
5834 
5835     if (!m_documentTiming.domContentLoadedEventEnd)
5836         m_documentTiming.domContentLoadedEventEnd = MonotonicTime::now();
5837 
5838     if (RefPtr&lt;Frame&gt; frame = this-&gt;frame()) {
5839 #if ENABLE(XSLT)
5840         applyPendingXSLTransformsNowIfScheduled();
5841 #endif
5842 
5843         // FrameLoader::finishedParsing() might end up calling Document::implicitClose() if all
5844         // resource loads are complete. HTMLObjectElements can start loading their resources from
5845         // post attach callbacks triggered by resolveStyle(). This means if we parse out an &lt;object&gt;
5846         // tag and then reach the end of the document without updating styles, we might not have yet
5847         // started the resource load and might fire the window load event too early. To avoid this
5848         // we force the styles to be up to date before calling FrameLoader::finishedParsing().
5849         // See https://bugs.webkit.org/show_bug.cgi?id=36864 starting around comment 35.
5850         updateStyleIfNeeded();
5851 
5852         frame-&gt;loader().finishedParsing();
5853         InspectorInstrumentation::domContentLoadedEventFired(*frame);
5854     }
5855 
5856     // Schedule dropping of the DocumentSharedObjectPool. We keep it alive for a while after parsing finishes
5857     // so that dynamically inserted content can also benefit from sharing optimizations.
5858     // Note that we don&#39;t refresh the timer on pool access since that could lead to huge caches being kept
5859     // alive indefinitely by something innocuous like JS setting .innerHTML repeatedly on a timer.
5860     static const Seconds timeToKeepSharedObjectPoolAliveAfterParsingFinished { 10_s };
5861     m_sharedObjectPoolClearTimer.startOneShot(timeToKeepSharedObjectPoolAliveAfterParsingFinished);
5862 
5863     // Parser should have picked up all speculative preloads by now
5864     m_cachedResourceLoader-&gt;clearPreloads(CachedResourceLoader::ClearPreloadsMode::ClearSpeculativePreloads);
5865 
5866 #if ENABLE(SERVICE_WORKER)
5867     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled()) {
5868         // Stop queuing service worker client messages now that the DOMContentLoaded event has been fired.
5869         if (auto* serviceWorkerContainer = this-&gt;serviceWorkerContainer())
5870             serviceWorkerContainer-&gt;startMessages();
5871     }
5872 #endif
5873 }
5874 
5875 void Document::clearSharedObjectPool()
5876 {
5877     m_sharedObjectPool = nullptr;
5878     m_sharedObjectPoolClearTimer.stop();
5879 }
5880 
5881 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
5882 
5883 // FIXME: Find a better place for this code.
5884 
5885 bool Document::isTelephoneNumberParsingEnabled() const
5886 {
5887     return settings().telephoneNumberParsingEnabled() &amp;&amp; m_isTelephoneNumberParsingAllowed;
5888 }
5889 
5890 bool Document::isTelephoneNumberParsingAllowed() const
5891 {
5892     return m_isTelephoneNumberParsingAllowed;
5893 }
5894 
5895 #endif
5896 
5897 String Document::originIdentifierForPasteboard() const
5898 {
5899     auto origin = securityOrigin().toString();
5900     if (origin != &quot;null&quot;)
5901         return origin;
5902     if (!m_uniqueIdentifier)
5903         m_uniqueIdentifier = &quot;null:&quot; + createCanonicalUUIDString();
5904     return m_uniqueIdentifier;
5905 }
5906 
5907 ExceptionOr&lt;Ref&lt;XPathExpression&gt;&gt; Document::createExpression(const String&amp; expression, RefPtr&lt;XPathNSResolver&gt;&amp;&amp; resolver)
5908 {
5909     if (!m_xpathEvaluator)
5910         m_xpathEvaluator = XPathEvaluator::create();
5911     return m_xpathEvaluator-&gt;createExpression(expression, WTFMove(resolver));
5912 }
5913 
5914 Ref&lt;XPathNSResolver&gt; Document::createNSResolver(Node&amp; nodeResolver)
5915 {
5916     if (!m_xpathEvaluator)
5917         m_xpathEvaluator = XPathEvaluator::create();
5918     return m_xpathEvaluator-&gt;createNSResolver(nodeResolver);
5919 }
5920 
5921 ExceptionOr&lt;Ref&lt;XPathResult&gt;&gt; Document::evaluate(const String&amp; expression, Node&amp; contextNode, RefPtr&lt;XPathNSResolver&gt;&amp;&amp; resolver, unsigned short type, XPathResult* result)
5922 {
5923     if (!m_xpathEvaluator)
5924         m_xpathEvaluator = XPathEvaluator::create();
5925     return m_xpathEvaluator-&gt;evaluate(expression, contextNode, WTFMove(resolver), type, result);
5926 }
5927 
5928 void Document::initSecurityContext()
5929 {
5930     if (haveInitializedSecurityOrigin()) {
5931         ASSERT(SecurityContext::securityOrigin());
5932         return;
5933     }
5934 
5935     if (!m_frame) {
5936         // No source for a security context.
5937         // This can occur via document.implementation.createDocument().
5938         setCookieURL(URL({ }, emptyString()));
5939         setSecurityOriginPolicy(SecurityOriginPolicy::create(SecurityOrigin::createUnique()));
5940         setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { { }, emptyString() }, *this));
5941         return;
5942     }
5943 
5944     // In the common case, create the security context from the currently
5945     // loading URL with a fresh content security policy.
5946     setCookieURL(m_url);
5947     enforceSandboxFlags(m_frame-&gt;loader().effectiveSandboxFlags());
5948     setReferrerPolicy(m_frame-&gt;loader().effectiveReferrerPolicy());
5949 
5950     if (shouldEnforceContentDispositionAttachmentSandbox())
5951         applyContentDispositionAttachmentSandbox();
5952 
5953     auto* documentLoader = m_frame-&gt;loader().documentLoader();
5954     bool isSecurityOriginUnique = isSandboxed(SandboxOrigin);
5955     if (!isSecurityOriginUnique)
5956         isSecurityOriginUnique = documentLoader &amp;&amp; documentLoader-&gt;response().tainting() == ResourceResponse::Tainting::Opaque;
5957 
5958     setSecurityOriginPolicy(SecurityOriginPolicy::create(isSecurityOriginUnique ? SecurityOrigin::createUnique() : SecurityOrigin::create(m_url)));
5959     setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { m_url }, *this));
5960 
5961     if (SecurityPolicy::allowSubstituteDataAccessToLocal()) {
5962         // If this document was loaded with substituteData, then the document can
5963         // load local resources.  See https://bugs.webkit.org/show_bug.cgi?id=16756
5964         // and https://bugs.webkit.org/show_bug.cgi?id=19760 for further
5965         // discussion.
5966 
5967         // RT-17330: Need to use &quot;m_frame-&gt;loader()-&gt;documentLoader()&quot; instead
5968         // of &quot;loader()&quot; as the latter returns NULL while the document is being
5969         // constructed
5970         // DocumentLoader* documentLoader = loader();
5971         DocumentLoader* documentLoader = m_frame-&gt;loader().documentLoader();
5972         if (documentLoader &amp;&amp; documentLoader-&gt;substituteData().isValid())
5973             securityOrigin().grantLoadLocalResources();
5974     }
5975 
5976     String overrideContentSecurityPolicy = m_frame-&gt;loader().client().overrideContentSecurityPolicy();
5977     if (!overrideContentSecurityPolicy.isNull())
5978         contentSecurityPolicy()-&gt;didReceiveHeader(overrideContentSecurityPolicy, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::API, referrer(), documentLoader ? documentLoader-&gt;response().httpStatusCode() : 0);
5979 
5980 #if USE(QUICK_LOOK)
5981     if (shouldEnforceQuickLookSandbox())
5982         applyQuickLookSandbox();
5983 #endif
5984 
5985     if (shouldEnforceHTTP09Sandbox()) {
5986         String message = makeString(&quot;Sandboxing &#39;&quot;, m_url.stringCenterEllipsizedToLength(), &quot;&#39; because it is using HTTP/0.9.&quot;);
5987         addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
5988         enforceSandboxFlags(SandboxScripts | SandboxPlugins);
5989     }
5990 
5991     if (settings().needsStorageAccessFromFileURLsQuirk())
5992         securityOrigin().grantStorageAccessFromFileURLsQuirk();
5993     if (!settings().webSecurityEnabled()) {
5994         // Web security is turned off. We should let this document access every other document. This is used primary by testing
5995         // harnesses for web sites.
5996         securityOrigin().grantUniversalAccess();
5997     } else if (securityOrigin().isLocal()) {
5998         if (settings().allowUniversalAccessFromFileURLs() || m_frame-&gt;loader().client().shouldForceUniversalAccessFromLocalURL(m_url)) {
5999             // Some clients want local URLs to have universal access, but that setting is dangerous for other clients.
6000             securityOrigin().grantUniversalAccess();
6001         } else if (!settings().allowFileAccessFromFileURLs()) {
6002             // Some clients want local URLs to have even tighter restrictions by default, and not be able to access other local files.
6003             // FIXME 81578: The naming of this is confusing. Files with restricted access to other local files
6004             // still can have other privileges that can be remembered, thereby not making them unique origins.
6005             securityOrigin().setEnforcesFilePathSeparation();
6006         }
6007     }
6008     securityOrigin().setStorageBlockingPolicy(settings().storageBlockingPolicy());
6009 
6010     Document* parentDocument = ownerElement() ? &amp;ownerElement()-&gt;document() : nullptr;
6011     if (parentDocument &amp;&amp; m_frame-&gt;loader().shouldTreatURLAsSrcdocDocument(url())) {
6012         m_isSrcdocDocument = true;
6013         setBaseURLOverride(parentDocument-&gt;baseURL());
6014     }
6015     if (parentDocument)
6016         setStrictMixedContentMode(parentDocument-&gt;isStrictMixedContentMode());
6017 
6018     if (!SecurityPolicy::shouldInheritSecurityOriginFromOwner(m_url))
6019         return;
6020 
6021     // If we do not obtain a meaningful origin from the URL, then we try to
6022     // find one via the frame hierarchy.
6023     Frame* parentFrame = m_frame-&gt;tree().parent();
6024     Frame* openerFrame = m_frame-&gt;loader().opener();
6025 
6026     Frame* ownerFrame = parentFrame;
6027     if (!ownerFrame)
6028         ownerFrame = openerFrame;
6029 
6030     if (!ownerFrame) {
6031         didFailToInitializeSecurityOrigin();
6032         return;
6033     }
6034 
6035     contentSecurityPolicy()-&gt;copyStateFrom(ownerFrame-&gt;document()-&gt;contentSecurityPolicy());
6036     contentSecurityPolicy()-&gt;updateSourceSelf(ownerFrame-&gt;document()-&gt;securityOrigin());
6037 
6038     // Per &lt;http://www.w3.org/TR/upgrade-insecure-requests/&gt;, new browsing contexts must inherit from an
6039     // ongoing set of upgraded requests. When opening a new browsing context, we need to capture its
6040     // existing upgrade request. Nested browsing contexts are handled during DocumentWriter::begin.
6041     if (auto* openerDocument = openerFrame ? openerFrame-&gt;document() : nullptr)
6042         contentSecurityPolicy()-&gt;inheritInsecureNavigationRequestsToUpgradeFromOpener(*openerDocument-&gt;contentSecurityPolicy());
6043 
6044     if (isSandboxed(SandboxOrigin)) {
6045         // If we&#39;re supposed to inherit our security origin from our owner,
6046         // but we&#39;re also sandboxed, the only thing we inherit is the ability
6047         // to load local resources. This lets about:blank iframes in file://
6048         // URL documents load images and other resources from the file system.
6049         if (ownerFrame-&gt;document()-&gt;securityOrigin().canLoadLocalResources())
6050             securityOrigin().grantLoadLocalResources();
6051         return;
6052     }
6053 
6054     setCookieURL(ownerFrame-&gt;document()-&gt;cookieURL());
6055     // We alias the SecurityOrigins to match Firefox, see Bug 15313
6056     // https://bugs.webkit.org/show_bug.cgi?id=15313
6057     setSecurityOriginPolicy(ownerFrame-&gt;document()-&gt;securityOriginPolicy());
6058 }
6059 
6060 void Document::initContentSecurityPolicy()
6061 {
6062     auto* parentFrame = m_frame-&gt;tree().parent();
6063     if (parentFrame)
6064         contentSecurityPolicy()-&gt;copyUpgradeInsecureRequestStateFrom(*parentFrame-&gt;document()-&gt;contentSecurityPolicy());
6065 
6066     // FIXME: Remove this special plugin document logic. We are stricter than the CSP 3 spec. with regards to plugins: we prefer to
6067     // inherit the full policy unless the plugin document is opened in a new window. The CSP 3 spec. implies that only plugin documents
6068     // delivered with a local scheme (e.g. blob, file, data) should inherit a policy.
6069     if (!isPluginDocument())
6070         return;
6071     auto* openerFrame = m_frame-&gt;loader().opener();
6072     bool shouldInhert = parentFrame || (openerFrame &amp;&amp; openerFrame-&gt;document()-&gt;securityOrigin().canAccess(securityOrigin()));
6073     if (!shouldInhert)
6074         return;
6075     setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { m_url }, *this));
6076     if (openerFrame)
6077         contentSecurityPolicy()-&gt;createPolicyForPluginDocumentFrom(*openerFrame-&gt;document()-&gt;contentSecurityPolicy());
6078     else
6079         contentSecurityPolicy()-&gt;copyStateFrom(parentFrame-&gt;document()-&gt;contentSecurityPolicy());
6080 }
6081 
6082 bool Document::isContextThread() const
6083 {
6084     return isMainThread();
6085 }
6086 
6087 bool Document::isSecureContext() const
6088 {
6089     if (!m_frame)
6090         return true;
6091     if (!RuntimeEnabledFeatures::sharedFeatures().secureContextChecksEnabled())
6092         return true;
6093     if (!securityOrigin().isPotentiallyTrustworthy())
6094         return false;
6095     for (auto* frame = m_frame-&gt;tree().parent(); frame; frame = frame-&gt;tree().parent()) {
6096         if (!frame-&gt;document()-&gt;securityOrigin().isPotentiallyTrustworthy())
6097             return false;
6098     }
6099     if (topOrigin().isUnique())
6100         return false;
6101     return true;
6102 }
6103 
6104 void Document::updateURLForPushOrReplaceState(const URL&amp; url)
6105 {
6106     Frame* f = frame();
6107     if (!f)
6108         return;
6109 
6110     setURL(url);
6111     f-&gt;loader().setOutgoingReferrer(url);
6112 
6113     if (DocumentLoader* documentLoader = loader())
6114         documentLoader-&gt;replaceRequestURLForSameDocumentNavigation(url);
6115 }
6116 
6117 void Document::statePopped(Ref&lt;SerializedScriptValue&gt;&amp;&amp; stateObject)
6118 {
6119     if (!frame())
6120         return;
6121 
6122     // Per step 11 of section 6.5.9 (history traversal) of the HTML5 spec, we
6123     // defer firing of popstate until we&#39;re in the complete state.
6124     if (m_readyState == Complete)
6125         dispatchPopstateEvent(WTFMove(stateObject));
6126     else
6127         m_pendingStateObject = WTFMove(stateObject);
6128 }
6129 
6130 void Document::attachRange(Range&amp; range)
6131 {
6132     ASSERT(!m_ranges.contains(&amp;range));
6133     m_ranges.add(&amp;range);
6134 }
6135 
6136 void Document::detachRange(Range&amp; range)
6137 {
6138     // We don&#39;t ASSERT m_ranges.contains(&amp;range) to allow us to call this
6139     // unconditionally to fix: https://bugs.webkit.org/show_bug.cgi?id=26044
6140     m_ranges.remove(&amp;range);
6141 }
6142 
6143 Optional&lt;RenderingContext&gt; Document::getCSSCanvasContext(const String&amp; type, const String&amp; name, int width, int height)
6144 {
6145     HTMLCanvasElement* element = getCSSCanvasElement(name);
6146     if (!element)
6147         return WTF::nullopt;
6148     element-&gt;setSize({ width, height });
6149     auto context = element-&gt;getContext(type);
6150     if (!context)
6151         return WTF::nullopt;
6152 
6153 #if ENABLE(WEBGL)
6154     if (is&lt;WebGLRenderingContext&gt;(*context))
6155         return RenderingContext { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*context) } };
6156 #endif
6157 #if ENABLE(WEBGL2)
6158     if (is&lt;WebGL2RenderingContext&gt;(*context))
6159         return RenderingContext { RefPtr&lt;WebGL2RenderingContext&gt; { &amp;downcast&lt;WebGL2RenderingContext&gt;(*context) } };
6160 #endif
6161 #if ENABLE(WEBGPU)
6162     if (is&lt;GPUCanvasContext&gt;(*context))
6163         return RenderingContext { RefPtr&lt;GPUCanvasContext&gt; { &amp;downcast&lt;GPUCanvasContext&gt;(*context) } };
6164 #endif
6165 
6166     return RenderingContext { RefPtr&lt;CanvasRenderingContext2D&gt; { &amp;downcast&lt;CanvasRenderingContext2D&gt;(*context) } };
6167 }
6168 
6169 HTMLCanvasElement* Document::getCSSCanvasElement(const String&amp; name)
6170 {
6171     RefPtr&lt;HTMLCanvasElement&gt;&amp; element = m_cssCanvasElements.add(name, nullptr).iterator-&gt;value;
6172     if (!element)
6173         element = HTMLCanvasElement::create(*this);
6174     return element.get();
6175 }
6176 
6177 String Document::nameForCSSCanvasElement(const HTMLCanvasElement&amp; canvasElement) const
6178 {
6179     for (const auto&amp; entry : m_cssCanvasElements) {
6180         if (entry.value.get() == &amp;canvasElement)
6181             return entry.key;
6182     }
6183     return String();
6184 }
6185 
6186 #if ENABLE(TEXT_AUTOSIZING)
6187 TextAutoSizing&amp; Document::textAutoSizing()
6188 {
6189     if (!m_textAutoSizing)
6190         m_textAutoSizing = makeUnique&lt;TextAutoSizing&gt;();
6191     return *m_textAutoSizing;
6192 }
6193 #endif // ENABLE(TEXT_AUTOSIZING)
6194 
6195 void Document::initDNSPrefetch()
6196 {
6197     m_haveExplicitlyDisabledDNSPrefetch = false;
6198     m_isDNSPrefetchEnabled = settings().dnsPrefetchingEnabled() &amp;&amp; securityOrigin().protocol() == &quot;http&quot;;
6199 
6200     // Inherit DNS prefetch opt-out from parent frame
6201     if (Document* parent = parentDocument()) {
6202         if (!parent-&gt;isDNSPrefetchEnabled())
6203             m_isDNSPrefetchEnabled = false;
6204     }
6205 }
6206 
6207 void Document::parseDNSPrefetchControlHeader(const String&amp; dnsPrefetchControl)
6208 {
6209     if (!settings().dnsPrefetchingEnabled())
6210         return;
6211 
6212     if (equalLettersIgnoringASCIICase(dnsPrefetchControl, &quot;on&quot;) &amp;&amp; !m_haveExplicitlyDisabledDNSPrefetch) {
6213         m_isDNSPrefetchEnabled = true;
6214         return;
6215     }
6216 
6217     m_isDNSPrefetchEnabled = false;
6218     m_haveExplicitlyDisabledDNSPrefetch = true;
6219 }
6220 
6221 void Document::getParserLocation(String&amp; completedURL, unsigned&amp; line, unsigned&amp; column) const
6222 {
6223     // We definitely cannot associate the message with a location being parsed if we are not even parsing.
6224     if (!parsing())
6225         return;
6226 
6227     ScriptableDocumentParser* parser = scriptableDocumentParser();
6228     if (!parser)
6229         return;
6230 
6231     // When the parser waits for scripts, any messages must be coming from some other source, and are not related to the location of the script element that made the parser wait.
6232     if (!parser-&gt;shouldAssociateConsoleMessagesWithTextPosition())
6233         return;
6234 
6235     completedURL = url().string();
6236     TextPosition position = parser-&gt;textPosition();
6237     line = position.m_line.oneBasedInt();
6238     column = position.m_column.oneBasedInt();
6239 }
6240 
6241 void Document::addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp; consoleMessage)
6242 {
6243     if (!isContextThread()) {
6244         postTask(AddConsoleMessageTask(WTFMove(consoleMessage)));
6245         return;
6246     }
6247 
6248     if (Page* page = this-&gt;page())
6249         page-&gt;console().addMessage(WTFMove(consoleMessage));
6250 }
6251 
6252 void Document::addConsoleMessage(MessageSource source, MessageLevel level, const String&amp; message, unsigned long requestIdentifier)
6253 {
6254     if (!isContextThread()) {
6255         postTask(AddConsoleMessageTask(source, level, message));
6256         return;
6257     }
6258 
6259     if (Page* page = this-&gt;page())
6260         page-&gt;console().addMessage(source, level, message, requestIdentifier, this);
6261 
6262     if (m_consoleMessageListener)
6263         m_consoleMessageListener-&gt;scheduleCallback(*this, message);
6264 }
6265 
6266 void Document::addMessage(MessageSource source, MessageLevel level, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp; callStack, JSC::JSGlobalObject* state, unsigned long requestIdentifier)
6267 {
6268     if (!isContextThread()) {
6269         postTask(AddConsoleMessageTask(source, level, message));
6270         return;
6271     }
6272 
6273     if (Page* page = this-&gt;page())
6274         page-&gt;console().addMessage(source, level, message, sourceURL, lineNumber, columnNumber, WTFMove(callStack), state, requestIdentifier);
6275 }
6276 
6277 void Document::postTask(Task&amp;&amp; task)
6278 {
6279     callOnMainThread([documentID = identifier(), task = WTFMove(task)]() mutable {
6280         ASSERT(isMainThread());
6281 
6282         auto* document = allDocumentsMap().get(documentID);
6283         if (!document)
6284             return;
6285 
6286         Page* page = document-&gt;page();
6287         if ((page &amp;&amp; page-&gt;defersLoading() &amp;&amp; document-&gt;activeDOMObjectsAreSuspended()) || !document-&gt;m_pendingTasks.isEmpty())
6288             document-&gt;m_pendingTasks.append(WTFMove(task));
6289         else
6290             task.performTask(*document);
6291     });
6292 }
6293 
6294 void Document::pendingTasksTimerFired()
6295 {
6296     Vector&lt;Task&gt; pendingTasks = WTFMove(m_pendingTasks);
6297     for (auto&amp; task : pendingTasks)
6298         task.performTask(*this);
6299 }
6300 
6301 EventLoopTaskGroup&amp; Document::eventLoop()
6302 {
6303     ASSERT(isMainThread());
6304     if (UNLIKELY(!m_documentTaskGroup)) {
6305         m_documentTaskGroup = makeUnique&lt;EventLoopTaskGroup&gt;(windowEventLoop());
6306         if (activeDOMObjectsAreStopped())
6307             m_documentTaskGroup-&gt;stopAndDiscardAllTasks();
6308         else if (activeDOMObjectsAreSuspended())
6309             m_documentTaskGroup-&gt;suspend();
6310     }
6311     return *m_documentTaskGroup;
6312 }
6313 
6314 WindowEventLoop&amp; Document::windowEventLoop()
6315 {
6316     ASSERT(isMainThread());
6317     if (UNLIKELY(!m_eventLoop))
6318         m_eventLoop = WindowEventLoop::eventLoopForSecurityOrigin(securityOrigin());
6319     return *m_eventLoop;
6320 }
6321 
6322 void Document::suspendScheduledTasks(ReasonForSuspension reason)
6323 {
6324     if (m_scheduledTasksAreSuspended) {
6325         // A page may subsequently suspend DOM objects, say as part of handling a scroll or zoom gesture, after the
6326         // embedding client requested the page be suspended. We ignore such requests so long as the embedding client
6327         // requested the suspension first. See &lt;rdar://problem/13754896&gt; for more details.
6328         ASSERT(reasonForSuspendingActiveDOMObjects() == ReasonForSuspension::PageWillBeSuspended);
6329         return;
6330     }
6331 
6332     suspendScriptedAnimationControllerCallbacks();
6333     suspendActiveDOMObjects(reason);
6334     scriptRunner().suspend();
6335     m_pendingTasksTimer.stop();
6336 
6337 #if ENABLE(XSLT)
6338     m_applyPendingXSLTransformsTimer.stop();
6339 #endif
6340 
6341     // Deferring loading and suspending parser is necessary when we need to prevent re-entrant JavaScript execution
6342     // (e.g. while displaying an alert).
6343     // It is not currently possible to suspend parser unless loading is deferred, because new data arriving from network
6344     // will trigger parsing, and leave the scheduler in an inconsistent state where it doesn&#39;t know whether it&#39;s suspended or not.
6345     if (reason == ReasonForSuspension::WillDeferLoading &amp;&amp; m_parser)
6346         m_parser-&gt;suspendScheduledTasks();
6347 
6348     m_scheduledTasksAreSuspended = true;
6349 }
6350 
6351 void Document::resumeScheduledTasks(ReasonForSuspension reason)
6352 {
6353     if (reasonForSuspendingActiveDOMObjects() != reason)
6354         return;
6355 
6356     ASSERT(m_scheduledTasksAreSuspended);
6357 
6358     if (reason == ReasonForSuspension::WillDeferLoading &amp;&amp; m_parser)
6359         m_parser-&gt;resumeScheduledTasks();
6360 
6361 #if ENABLE(XSLT)
6362     if (m_hasPendingXSLTransforms)
6363         m_applyPendingXSLTransformsTimer.startOneShot(0_s);
6364 #endif
6365 
6366     if (!m_pendingTasks.isEmpty())
6367         m_pendingTasksTimer.startOneShot(0_s);
6368     scriptRunner().resume();
6369     resumeActiveDOMObjects(reason);
6370     resumeScriptedAnimationControllerCallbacks();
6371 
6372     m_scheduledTasksAreSuspended = false;
6373 }
6374 
6375 void Document::suspendScriptedAnimationControllerCallbacks()
6376 {
6377     if (m_scriptedAnimationController)
6378         m_scriptedAnimationController-&gt;suspend();
6379 }
6380 
6381 void Document::resumeScriptedAnimationControllerCallbacks()
6382 {
6383     if (m_scriptedAnimationController)
6384         m_scriptedAnimationController-&gt;resume();
6385 }
6386 
6387 void Document::updateAnimationsAndSendEvents(DOMHighResTimeStamp timestamp)
6388 {
6389     ASSERT(!m_timelines.hasNullReferences());
6390 
6391     // We need to copy m_timelines before iterating over its members since calling updateAnimationsAndSendEvents() may mutate m_timelines.
6392     Vector&lt;RefPtr&lt;DocumentTimeline&gt;&gt; timelines;
6393     bool shouldUpdateAnimations = false;
6394     for (auto&amp; timeline : m_timelines) {
6395         if (!shouldUpdateAnimations &amp;&amp; timeline.scheduledUpdate())
6396             shouldUpdateAnimations = true;
6397         timelines.append(&amp;timeline);
6398     }
6399 
6400     for (auto&amp; timeline : timelines) {
6401         timeline-&gt;updateCurrentTime(timestamp);
6402         if (shouldUpdateAnimations)
6403             timeline-&gt;updateAnimationsAndSendEvents();
6404     }
6405 }
6406 
6407 void Document::serviceRequestAnimationFrameCallbacks(DOMHighResTimeStamp timestamp)
6408 {
6409     if (m_scriptedAnimationController)
6410         m_scriptedAnimationController-&gt;serviceRequestAnimationFrameCallbacks(timestamp);
6411 }
6412 
6413 void Document::windowScreenDidChange(PlatformDisplayID displayID)
6414 {
6415     if (RenderView* view = renderView()) {
6416         if (view-&gt;usesCompositing())
6417             view-&gt;compositor().windowScreenDidChange(displayID);
6418     }
6419 }
6420 
6421 String Document::displayStringModifiedByEncoding(const String&amp; string) const
6422 {
6423     if (!m_decoder)
6424         return string;
6425     return String { string }.replace(&#39;\\&#39;, m_decoder-&gt;encoding().backslashAsCurrencySymbol());
6426 }
6427 
6428 void Document::dispatchPageshowEvent(PageshowEventPersistence persisted)
6429 {
6430     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=36334 Pageshow event needs to fire asynchronously.
6431     dispatchWindowEvent(PageTransitionEvent::create(eventNames().pageshowEvent, persisted), this);
6432 }
6433 
6434 void Document::enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp; eventInit)
6435 {
6436     queueTaskToDispatchEvent(TaskSource::DOMManipulation, SecurityPolicyViolationEvent::create(eventNames().securitypolicyviolationEvent, WTFMove(eventInit), Event::IsTrusted::Yes));
6437 }
6438 
6439 void Document::enqueueHashchangeEvent(const String&amp; oldURL, const String&amp; newURL)
6440 {
6441     // FIXME: popstate event and hashchange event are supposed to fire in a single task.
6442     queueTaskToDispatchEventOnWindow(TaskSource::DOMManipulation, HashChangeEvent::create(oldURL, newURL));
6443 }
6444 
6445 void Document::dispatchPopstateEvent(RefPtr&lt;SerializedScriptValue&gt;&amp;&amp; stateObject)
6446 {
6447     dispatchWindowEvent(PopStateEvent::create(WTFMove(stateObject), m_domWindow ? &amp;m_domWindow-&gt;history() : nullptr));
6448 }
6449 
6450 void Document::addMediaCanStartListener(MediaCanStartListener&amp; listener)
6451 {
6452     ASSERT(!m_mediaCanStartListeners.contains(&amp;listener));
6453     m_mediaCanStartListeners.add(&amp;listener);
6454 }
6455 
6456 void Document::removeMediaCanStartListener(MediaCanStartListener&amp; listener)
6457 {
6458     ASSERT(m_mediaCanStartListeners.contains(&amp;listener));
6459     m_mediaCanStartListeners.remove(&amp;listener);
6460 }
6461 
6462 MediaCanStartListener* Document::takeAnyMediaCanStartListener()
6463 {
6464     return m_mediaCanStartListeners.takeAny();
6465 }
6466 
6467 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
6468 
6469 DeviceMotionController&amp; Document::deviceMotionController() const
6470 {
6471     return *m_deviceMotionController;
6472 }
6473 
6474 DeviceOrientationController&amp; Document::deviceOrientationController() const
6475 {
6476     return *m_deviceOrientationController;
6477 }
6478 
6479 void Document::simulateDeviceOrientationChange(double alpha, double beta, double gamma)
6480 {
6481     auto orientation = DeviceOrientationData::create(alpha, beta, gamma, WTF::nullopt, WTF::nullopt);
6482     deviceOrientationController().didChangeDeviceOrientation(orientation.ptr());
6483 }
6484 
6485 #endif
6486 
6487 #if ENABLE(POINTER_LOCK)
6488 
6489 void Document::exitPointerLock()
6490 {
6491     Page* page = this-&gt;page();
6492     if (!page)
6493         return;
6494     if (auto* target = page-&gt;pointerLockController().element()) {
6495         if (&amp;target-&gt;document() != this)
6496             return;
6497     }
6498     page-&gt;pointerLockController().requestPointerUnlock();
6499 }
6500 
6501 #endif
6502 
6503 void Document::decrementLoadEventDelayCount()
6504 {
6505     ASSERT(m_loadEventDelayCount);
6506     --m_loadEventDelayCount;
6507 
6508     if (frame() &amp;&amp; !m_loadEventDelayCount &amp;&amp; !m_loadEventDelayTimer.isActive())
6509         m_loadEventDelayTimer.startOneShot(0_s);
6510 }
6511 
6512 void Document::loadEventDelayTimerFired()
6513 {
6514     // FIXME: Should the call to FrameLoader::checkLoadComplete be moved inside Document::checkCompleted?
6515     // FIXME: Should this also call DocumentLoader::checkLoadComplete?
6516     // FIXME: Not obvious why checkCompleted needs to go first. The order these are called is
6517     // visible to WebKit clients, but it&#39;s more like a race than a well-defined relationship.
6518     Ref&lt;Document&gt; protectedThis(*this);
6519     checkCompleted();
6520     if (auto* frame = this-&gt;frame())
6521         frame-&gt;loader().checkLoadComplete();
6522 }
6523 
6524 void Document::checkCompleted()
6525 {
6526     if (auto* frame = this-&gt;frame())
6527         frame-&gt;loader().checkCompleted();
6528 }
6529 
6530 double Document::monotonicTimestamp() const
6531 {
6532     auto* loader = this-&gt;loader();
6533     if (!loader)
6534         return 0;
6535 
6536     return loader-&gt;timing().secondsSinceStartTime(MonotonicTime::now()).seconds();
6537 }
6538 
6539 int Document::requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp; callback)
6540 {
6541     if (!m_scriptedAnimationController) {
6542         m_scriptedAnimationController = ScriptedAnimationController::create(*this);
6543 
6544         // It&#39;s possible that the Page may have suspended scripted animations before
6545         // we were created. We need to make sure that we don&#39;t start up the animation
6546         // controller on a background tab, for example.
6547         if (!page() || page()-&gt;scriptedAnimationsSuspended())
6548             m_scriptedAnimationController-&gt;suspend();
6549 
6550         if (page() &amp;&amp; page()-&gt;isLowPowerModeEnabled())
6551             m_scriptedAnimationController-&gt;addThrottlingReason(ScriptedAnimationController::ThrottlingReason::LowPowerMode);
6552 
6553         if (!topOrigin().canAccess(securityOrigin()) &amp;&amp; !hasHadUserInteraction())
6554             m_scriptedAnimationController-&gt;addThrottlingReason(ScriptedAnimationController::ThrottlingReason::NonInteractedCrossOriginFrame);
6555     }
6556 
6557     return m_scriptedAnimationController-&gt;registerCallback(WTFMove(callback));
6558 }
6559 
6560 void Document::cancelAnimationFrame(int id)
6561 {
6562     if (!m_scriptedAnimationController)
6563         return;
6564     m_scriptedAnimationController-&gt;cancelCallback(id);
6565 }
6566 
6567 void Document::clearScriptedAnimationController()
6568 {
6569     // FIXME: consider using ActiveDOMObject.
6570     if (m_scriptedAnimationController)
6571         m_scriptedAnimationController-&gt;clearDocumentPointer();
6572     m_scriptedAnimationController = nullptr;
6573 }
6574 
6575 int Document::requestIdleCallback(Ref&lt;IdleRequestCallback&gt;&amp;&amp; callback, Seconds timeout)
6576 {
6577     if (!m_idleCallbackController)
6578         m_idleCallbackController = makeUnique&lt;IdleCallbackController&gt;(*this);
6579     return m_idleCallbackController-&gt;queueIdleCallback(WTFMove(callback), timeout);
6580 }
6581 
6582 void Document::cancelIdleCallback(int id)
6583 {
6584     if (!m_idleCallbackController)
6585         return;
6586     m_idleCallbackController-&gt;removeIdleCallback(id);
6587 }
6588 
6589 void Document::wheelEventHandlersChanged()
6590 {
6591     Page* page = this-&gt;page();
6592     if (!page)
6593         return;
6594 
6595     if (FrameView* frameView = view()) {
6596         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
6597             scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);
6598     }
6599 
6600     bool haveHandlers = m_wheelEventTargets &amp;&amp; !m_wheelEventTargets-&gt;isEmpty();
6601     page-&gt;chrome().client().wheelEventHandlersChanged(haveHandlers);
6602 }
6603 
6604 void Document::didAddWheelEventHandler(Node&amp; node)
6605 {
6606     if (!m_wheelEventTargets)
6607         m_wheelEventTargets = makeUnique&lt;EventTargetSet&gt;();
6608 
6609     m_wheelEventTargets-&gt;add(&amp;node);
6610 
6611     wheelEventHandlersChanged();
6612 
6613     if (Frame* frame = this-&gt;frame())
6614         DebugPageOverlays::didChangeEventHandlers(*frame);
6615 }
6616 
6617 HttpEquivPolicy Document::httpEquivPolicy() const
6618 {
6619     if (shouldEnforceContentDispositionAttachmentSandbox())
6620         return HttpEquivPolicy::DisabledByContentDispositionAttachmentSandbox;
6621     if (page() &amp;&amp; !page()-&gt;settings().httpEquivEnabled())
6622         return HttpEquivPolicy::DisabledBySettings;
6623     return HttpEquivPolicy::Enabled;
6624 }
6625 
6626 static bool removeHandlerFromSet(EventTargetSet&amp; handlerSet, Node&amp; node, EventHandlerRemoval removal)
6627 {
6628     switch (removal) {
6629     case EventHandlerRemoval::One:
6630         return handlerSet.remove(&amp;node);
6631     case EventHandlerRemoval::All:
6632         return handlerSet.removeAll(&amp;node);
6633     }
6634     return false;
6635 }
6636 
6637 void Document::didRemoveWheelEventHandler(Node&amp; node, EventHandlerRemoval removal)
6638 {
6639     if (!m_wheelEventTargets)
6640         return;
6641 
6642     if (!removeHandlerFromSet(*m_wheelEventTargets, node, removal))
6643         return;
6644 
6645     wheelEventHandlersChanged();
6646 
6647     if (Frame* frame = this-&gt;frame())
6648         DebugPageOverlays::didChangeEventHandlers(*frame);
6649 }
6650 
6651 unsigned Document::wheelEventHandlerCount() const
6652 {
6653     if (!m_wheelEventTargets)
6654         return 0;
6655 
6656     unsigned count = 0;
6657     for (auto&amp; handler : *m_wheelEventTargets)
6658         count += handler.value;
6659 
6660     return count;
6661 }
6662 
6663 void Document::didAddTouchEventHandler(Node&amp; handler)
6664 {
6665 #if ENABLE(TOUCH_EVENTS)
6666     if (!m_touchEventTargets)
6667         m_touchEventTargets = makeUnique&lt;EventTargetSet&gt;();
6668 
6669     m_touchEventTargets-&gt;add(&amp;handler);
6670 
6671     if (Document* parent = parentDocument()) {
6672         parent-&gt;didAddTouchEventHandler(*this);
6673         return;
6674     }
6675 #else
6676     UNUSED_PARAM(handler);
6677 #endif
6678 }
6679 
6680 void Document::didRemoveTouchEventHandler(Node&amp; handler, EventHandlerRemoval removal)
6681 {
6682 #if ENABLE(TOUCH_EVENTS)
6683     if (!m_touchEventTargets)
6684         return;
6685 
6686     removeHandlerFromSet(*m_touchEventTargets, handler, removal);
6687 
6688     if (Document* parent = parentDocument())
6689         parent-&gt;didRemoveTouchEventHandler(*this);
6690 #else
6691     UNUSED_PARAM(handler);
6692     UNUSED_PARAM(removal);
6693 #endif
6694 }
6695 
6696 void Document::didRemoveEventTargetNode(Node&amp; handler)
6697 {
6698 #if ENABLE(TOUCH_EVENTS)
6699     if (m_touchEventTargets) {
6700         m_touchEventTargets-&gt;removeAll(&amp;handler);
6701         if ((&amp;handler == this || m_touchEventTargets-&gt;isEmpty()) &amp;&amp; parentDocument())
6702             parentDocument()-&gt;didRemoveEventTargetNode(*this);
6703     }
6704 #endif
6705 
6706     if (m_wheelEventTargets) {
6707         m_wheelEventTargets-&gt;removeAll(&amp;handler);
6708         if ((&amp;handler == this || m_wheelEventTargets-&gt;isEmpty()) &amp;&amp; parentDocument())
6709             parentDocument()-&gt;didRemoveEventTargetNode(*this);
6710     }
6711 }
6712 
6713 unsigned Document::touchEventHandlerCount() const
6714 {
6715 #if ENABLE(TOUCH_EVENTS)
6716     if (!m_touchEventTargets)
6717         return 0;
6718 
6719     unsigned count = 0;
6720     for (auto&amp; handler : *m_touchEventTargets)
6721         count += handler.value;
6722 
6723     return count;
6724 #else
6725     return 0;
6726 #endif
6727 }
6728 
6729 LayoutRect Document::absoluteEventHandlerBounds(bool&amp; includesFixedPositionElements)
6730 {
6731     includesFixedPositionElements = false;
6732     if (RenderView* renderView = this-&gt;renderView())
6733         return renderView-&gt;documentRect();
6734 
6735     return LayoutRect();
6736 }
6737 
6738 Document::RegionFixedPair Document::absoluteEventRegionForNode(Node&amp; node)
6739 {
6740     Region region;
6741     LayoutRect rootRelativeBounds;
6742     bool insideFixedPosition = false;
6743 
6744     if (is&lt;Document&gt;(node)) {
6745         auto&amp; document = downcast&lt;Document&gt;(node);
6746         if (&amp;document == this)
6747             rootRelativeBounds = absoluteEventHandlerBounds(insideFixedPosition);
6748         else if (Element* element = document.ownerElement())
6749             rootRelativeBounds = element-&gt;absoluteEventHandlerBounds(insideFixedPosition);
6750     } else if (is&lt;Element&gt;(node)) {
6751         auto&amp; element = downcast&lt;Element&gt;(node);
6752         if (is&lt;HTMLBodyElement&gt;(element)) {
6753             // For the body, just use the document bounds.
6754             // The body may not cover this whole area, but it&#39;s OK for this region to be an overestimate.
6755             rootRelativeBounds = absoluteEventHandlerBounds(insideFixedPosition);
6756         } else
6757             rootRelativeBounds = element.absoluteEventHandlerBounds(insideFixedPosition);
6758     }
6759 
6760     if (!rootRelativeBounds.isEmpty())
6761         region.unite(Region(enclosingIntRect(rootRelativeBounds)));
6762 
6763     return RegionFixedPair(region, insideFixedPosition);
6764 }
6765 
6766 Document::RegionFixedPair Document::absoluteRegionForEventTargets(const EventTargetSet* targets)
6767 {
6768     LayoutDisallowedScope layoutDisallowedScope(LayoutDisallowedScope::Reason::ReentrancyAvoidance);
6769 
6770     if (!targets)
6771         return RegionFixedPair(Region(), false);
6772 
6773     Region targetRegion;
6774     bool insideFixedPosition = false;
6775 
6776     for (auto&amp; keyValuePair : *targets) {
6777         if (auto* node = keyValuePair.key) {
6778             auto targetRegionFixedPair = absoluteEventRegionForNode(*node);
6779             targetRegion.unite(targetRegionFixedPair.first);
6780             insideFixedPosition |= targetRegionFixedPair.second;
6781         }
6782     }
6783 
6784     return RegionFixedPair(targetRegion, insideFixedPosition);
6785 }
6786 
6787 void Document::updateLastHandledUserGestureTimestamp(MonotonicTime time)
6788 {
6789     m_lastHandledUserGestureTimestamp = time;
6790 
6791     if (static_cast&lt;bool&gt;(time) &amp;&amp; m_scriptedAnimationController) {
6792         // It&#39;s OK to always remove NonInteractedCrossOriginFrame even if this frame isn&#39;t cross-origin.
6793         m_scriptedAnimationController-&gt;removeThrottlingReason(ScriptedAnimationController::ThrottlingReason::NonInteractedCrossOriginFrame);
6794     }
6795 
6796     // DOM Timer alignment may depend on the user having interacted with the document.
6797     didChangeTimerAlignmentInterval();
6798 
6799     if (HTMLFrameOwnerElement* element = ownerElement())
6800         element-&gt;document().updateLastHandledUserGestureTimestamp(time);
6801 }
6802 
6803 bool Document::processingUserGestureForMedia() const
6804 {
6805     if (UserGestureIndicator::processingUserGestureForMedia())
6806         return true;
6807 
6808     if (m_userActivatedMediaFinishedPlayingTimestamp + maxIntervalForUserGestureForwardingAfterMediaFinishesPlaying &gt;= MonotonicTime::now())
6809         return true;
6810 
6811     if (settings().mediaUserGestureInheritsFromDocument())
6812         return topDocument().hasHadUserInteraction();
6813 
6814     auto* loader = this-&gt;loader();
6815     if (loader &amp;&amp; loader-&gt;allowedAutoplayQuirks().contains(AutoplayQuirk::InheritedUserGestures))
6816         return topDocument().hasHadUserInteraction();
6817 
6818     return false;
6819 }
6820 
6821 void Document::startTrackingStyleRecalcs()
6822 {
6823     m_styleRecalcCount = 0;
6824 }
6825 
6826 unsigned Document::styleRecalcCount() const
6827 {
6828     return m_styleRecalcCount;
6829 }
6830 
6831 DocumentLoader* Document::loader() const
6832 {
6833     if (!m_frame)
6834         return nullptr;
6835 
6836     DocumentLoader* loader = m_frame-&gt;loader().documentLoader();
6837     if (!loader)
6838         return nullptr;
6839 
6840     if (m_frame-&gt;document() != this)
6841         return nullptr;
6842 
6843     return loader;
6844 }
6845 
6846 #if ENABLE(CSS_DEVICE_ADAPTATION)
6847 
6848 IntSize Document::initialViewportSize() const
6849 {
6850     if (!view())
6851         return IntSize();
6852     return view()-&gt;initialViewportSize();
6853 }
6854 
6855 #endif
6856 
6857 Element* eventTargetElementForDocument(Document* document)
6858 {
6859     if (!document)
6860         return nullptr;
6861     Element* element = document-&gt;focusedElement();
6862     if (!element &amp;&amp; is&lt;PluginDocument&gt;(*document))
6863         element = downcast&lt;PluginDocument&gt;(*document).pluginElement();
6864     if (!element &amp;&amp; document-&gt;isHTMLDocument())
6865         element = document-&gt;bodyOrFrameset();
6866     if (!element)
6867         element = document-&gt;documentElement();
6868     return element;
6869 }
6870 
6871 void Document::convertAbsoluteToClientQuads(Vector&lt;FloatQuad&gt;&amp; quads, const RenderStyle&amp; style)
6872 {
6873     if (!view())
6874         return;
6875 
6876     const auto&amp; frameView = *view();
6877     float inverseFrameScale = frameView.absoluteToDocumentScaleFactor(style.effectiveZoom());
6878     auto documentToClientOffset = frameView.documentToClientOffset();
6879 
6880     for (auto&amp; quad : quads) {
6881         if (inverseFrameScale != 1)
6882             quad.scale(inverseFrameScale);
6883 
6884         quad.move(documentToClientOffset);
6885     }
6886 }
6887 
6888 void Document::convertAbsoluteToClientRects(Vector&lt;FloatRect&gt;&amp; rects, const RenderStyle&amp; style)
6889 {
6890     if (!view())
6891         return;
6892 
6893     auto&amp; frameView = *view();
6894     float inverseFrameScale = frameView.absoluteToDocumentScaleFactor(style.effectiveZoom());
6895     auto documentToClientOffset = frameView.documentToClientOffset();
6896 
6897     for (auto&amp; rect : rects) {
6898         if (inverseFrameScale != 1)
6899             rect.scale(inverseFrameScale);
6900 
6901         rect.move(documentToClientOffset);
6902     }
6903 }
6904 
6905 void Document::convertAbsoluteToClientRect(FloatRect&amp; rect, const RenderStyle&amp; style)
6906 {
6907     if (!view())
6908         return;
6909 
6910     const auto&amp; frameView = *view();
6911     rect = frameView.absoluteToDocumentRect(rect, style.effectiveZoom());
6912     rect = frameView.documentToClientRect(rect);
6913 }
6914 
6915 bool Document::hasActiveParser()
6916 {
6917     return m_activeParserCount || (m_parser &amp;&amp; m_parser-&gt;processingData());
6918 }
6919 
6920 void Document::decrementActiveParserCount()
6921 {
6922     --m_activeParserCount;
6923     if (!frame())
6924         return;
6925 
6926     // FIXME: We should call DocumentLoader::checkLoadComplete as well here,
6927     // but it seems to cause http/tests/security/feed-urls-from-remote.html
6928     // to timeout on Mac WK1; see http://webkit.org/b/110554 and http://webkit.org/b/110401.
6929     frame()-&gt;loader().checkLoadComplete();
6930 }
6931 
6932 DocumentParserYieldToken::DocumentParserYieldToken(Document&amp; document)
6933     : m_document(makeWeakPtr(document))
6934 {
6935     if (++document.m_parserYieldTokenCount != 1)
6936         return;
6937 
6938     document.scriptRunner().didBeginYieldingParser();
6939     if (auto* parser = document.parser())
6940         parser-&gt;didBeginYieldingParser();
6941 }
6942 
6943 DocumentParserYieldToken::~DocumentParserYieldToken()
6944 {
6945     if (!m_document)
6946         return;
6947 
6948     ASSERT(m_document-&gt;m_parserYieldTokenCount);
6949     if (--m_document-&gt;m_parserYieldTokenCount)
6950         return;
6951 
6952     m_document-&gt;scriptRunner().didEndYieldingParser();
6953     if (auto* parser = m_document-&gt;parser())
6954         parser-&gt;didEndYieldingParser();
6955 }
6956 
6957 static Element* findNearestCommonComposedAncestor(Element* elementA, Element* elementB)
6958 {
6959     if (!elementA || !elementB)
6960         return nullptr;
6961 
6962     if (elementA == elementB)
6963         return elementA;
6964 
6965     HashSet&lt;Element*&gt; ancestorChain;
6966     for (auto* element = elementA; element; element = element-&gt;parentElementInComposedTree())
6967         ancestorChain.add(element);
6968 
6969     for (auto* element = elementB; element; element = element-&gt;parentElementInComposedTree()) {
6970         if (ancestorChain.contains(element))
6971             return element;
6972     }
6973     return nullptr;
6974 }
6975 
6976 void Document::updateHoverActiveState(const HitTestRequest&amp; request, Element* innerElement, CaptureChange captureElementChanged)
6977 {
6978     ASSERT(!request.readOnly());
6979 
6980     Element* innerElementInDocument = innerElement;
6981     while (innerElementInDocument &amp;&amp; &amp;innerElementInDocument-&gt;document() != this) {
6982         innerElementInDocument-&gt;document().updateHoverActiveState(request, innerElementInDocument);
6983         innerElementInDocument = innerElementInDocument-&gt;document().ownerElement();
6984     }
6985 
6986     Element* oldActiveElement = m_activeElement.get();
6987     if (oldActiveElement &amp;&amp; !request.active()) {
6988         // We are clearing the :active chain because the mouse has been released.
6989         for (Element* currentElement = oldActiveElement; currentElement; currentElement = currentElement-&gt;parentElementInComposedTree()) {
6990             currentElement-&gt;setActive(false);
6991             m_userActionElements.setInActiveChain(*currentElement, false);
6992         }
6993         m_activeElement = nullptr;
6994     } else {
6995         Element* newActiveElement = innerElementInDocument;
6996         if (!oldActiveElement &amp;&amp; newActiveElement &amp;&amp; request.active() &amp;&amp; !request.touchMove()) {
6997             // We are setting the :active chain and freezing it. If future moves happen, they
6998             // will need to reference this chain.
6999             for (RenderElement* curr = newActiveElement-&gt;renderer(); curr; curr = curr-&gt;parent()) {
7000                 Element* element = curr-&gt;element();
7001                 if (!element || curr-&gt;isTextOrLineBreak())
7002                     continue;
7003                 m_userActionElements.setInActiveChain(*element, true);
7004             }
7005 
7006             m_activeElement = newActiveElement;
7007         }
7008     }
7009     // If the mouse has just been pressed, set :active on the chain. Those (and only those)
7010     // nodes should remain :active until the mouse is released.
7011     bool allowActiveChanges = !oldActiveElement &amp;&amp; m_activeElement;
7012 
7013     // If the mouse is down and if this is a mouse move event, we want to restrict changes in
7014     // :hover/:active to only apply to elements that are in the :active chain that we froze
7015     // at the time the mouse went down, unless the capture element changed.
7016     bool mustBeInActiveChain = request.active() &amp;&amp; request.move() &amp;&amp; captureElementChanged == CaptureChange::No;
7017 
7018     RefPtr&lt;Element&gt; oldHoveredElement = WTFMove(m_hoveredElement);
7019 
7020     // A touch release does not set a new hover target; clearing the element we&#39;re working with
7021     // will clear the chain of hovered elements all the way to the top of the tree.
7022     if (request.touchRelease())
7023         innerElementInDocument = nullptr;
7024 
7025     // Check to see if the hovered Element has changed.
7026     // If it hasn&#39;t, we do not need to do anything.
7027     Element* newHoveredElement = innerElementInDocument;
7028     while (newHoveredElement &amp;&amp; !newHoveredElement-&gt;renderer())
7029         newHoveredElement = newHoveredElement-&gt;parentElementInComposedTree();
7030 
7031     m_hoveredElement = newHoveredElement;
7032 
7033     auto* commonAncestor = findNearestCommonComposedAncestor(oldHoveredElement.get(), newHoveredElement);
7034 
7035     Vector&lt;RefPtr&lt;Element&gt;, 32&gt; elementsToRemoveFromChain;
7036     Vector&lt;RefPtr&lt;Element&gt;, 32&gt; elementsToAddToChain;
7037 
7038     if (oldHoveredElement != newHoveredElement) {
7039         for (auto* element = oldHoveredElement.get(); element; element = element-&gt;parentElementInComposedTree()) {
7040             if (element == commonAncestor)
7041                 break;
7042             if (!mustBeInActiveChain || element-&gt;isInActiveChain())
7043                 elementsToRemoveFromChain.append(element);
7044         }
7045         // Unset hovered nodes in sub frame documents if the old hovered node was a frame owner.
7046         if (is&lt;HTMLFrameOwnerElement&gt;(oldHoveredElement)) {
7047             if (auto* contentDocument = downcast&lt;HTMLFrameOwnerElement&gt;(*oldHoveredElement).contentDocument())
7048                 contentDocument-&gt;updateHoverActiveState(request, nullptr);
7049         }
7050     }
7051 
7052     for (auto* element = newHoveredElement; element; element = element-&gt;parentElementInComposedTree()) {
7053         if (!mustBeInActiveChain || element-&gt;isInActiveChain())
7054             elementsToAddToChain.append(element);
7055     }
7056 
7057     for (auto&amp; element : elementsToRemoveFromChain)
7058         element-&gt;setHovered(false);
7059 
7060     bool sawCommonAncestor = false;
7061     for (auto&amp; element : elementsToAddToChain) {
7062         if (allowActiveChanges)
7063             element-&gt;setActive(true);
7064         if (element == commonAncestor)
7065             sawCommonAncestor = true;
7066         if (!sawCommonAncestor) {
7067             // Elements after the common hover ancestor does not change hover state, but are iterated over because they may change active state.
7068             element-&gt;setHovered(true);
7069         }
7070     }
7071 }
7072 
7073 bool Document::haveStylesheetsLoaded() const
7074 {
7075     return !styleScope().hasPendingSheets() || m_ignorePendingStylesheets;
7076 }
7077 
7078 Locale&amp; Document::getCachedLocale(const AtomString&amp; locale)
7079 {
7080     AtomString localeKey = locale;
7081     if (locale.isEmpty() || !settings().langAttributeAwareFormControlUIEnabled())
7082         localeKey = defaultLanguage();
7083     LocaleIdentifierToLocaleMap::AddResult result = m_localeCache.add(localeKey, nullptr);
7084     if (result.isNewEntry)
7085         result.iterator-&gt;value = Locale::create(localeKey);
7086     return *(result.iterator-&gt;value);
7087 }
7088 
7089 Document&amp; Document::ensureTemplateDocument()
7090 {
7091     if (const Document* document = templateDocument())
7092         return const_cast&lt;Document&amp;&gt;(*document);
7093 
7094     if (isHTMLDocument())
7095         m_templateDocument = HTMLDocument::create(nullptr, WTF::blankURL());
7096     else
7097         m_templateDocument = create(WTF::blankURL());
7098 
7099     m_templateDocument-&gt;setContextDocument(contextDocument());
7100     m_templateDocument-&gt;setTemplateDocumentHost(this); // balanced in dtor.
7101 
7102     return *m_templateDocument;
7103 }
7104 
7105 Ref&lt;FontFaceSet&gt; Document::fonts()
7106 {
7107     updateStyleIfNeeded();
7108     return fontSelector().fontFaceSet();
7109 }
7110 
7111 EditingBehavior Document::editingBehavior() const
7112 {
7113     return EditingBehavior { settings().editingBehaviorType() };
7114 }
7115 
7116 float Document::deviceScaleFactor() const
7117 {
7118     float deviceScaleFactor = 1.0;
7119     if (Page* documentPage = page())
7120         deviceScaleFactor = documentPage-&gt;deviceScaleFactor();
7121     return deviceScaleFactor;
7122 }
7123 
7124 bool Document::useSystemAppearance() const
7125 {
7126     if (auto* documentPage = page())
7127         return documentPage-&gt;useSystemAppearance();
7128     return false;
7129 }
7130 
7131 bool Document::useDarkAppearance(const RenderStyle* style) const
7132 {
7133 #if ENABLE(DARK_MODE_CSS)
7134     OptionSet&lt;ColorScheme&gt; colorScheme;
7135 
7136     // Use the style&#39;s supported color schemes, if supplied.
7137     if (style)
7138         colorScheme = style-&gt;colorScheme().colorScheme();
7139 
7140     // Fallback to the document&#39;s supported color schemes if style was empty (auto).
7141     if (colorScheme.isEmpty())
7142         colorScheme = m_colorScheme;
7143 
7144     if (colorScheme.contains(ColorScheme::Dark) &amp;&amp; !colorScheme.contains(ColorScheme::Light))
7145         return true;
7146 #else
7147     UNUSED_PARAM(style);
7148 #endif
7149 
7150     bool pageUsesDarkAppearance = false;
7151     if (Page* documentPage = page())
7152         pageUsesDarkAppearance = documentPage-&gt;useDarkAppearance();
7153 
7154     if (useSystemAppearance())
7155         return pageUsesDarkAppearance;
7156 
7157 #if ENABLE(DARK_MODE_CSS)
7158     if (colorScheme.contains(ColorScheme::Dark))
7159         return pageUsesDarkAppearance;
7160 #endif
7161 
7162     return false;
7163 }
7164 
7165 bool Document::useElevatedUserInterfaceLevel() const
7166 {
7167     if (auto* documentPage = page())
7168         return documentPage-&gt;useElevatedUserInterfaceLevel();
7169     return false;
7170 }
7171 
7172 OptionSet&lt;StyleColor::Options&gt; Document::styleColorOptions(const RenderStyle* style) const
7173 {
7174     OptionSet&lt;StyleColor::Options&gt; options;
7175     if (useSystemAppearance())
7176         options.add(StyleColor::Options::UseSystemAppearance);
7177     if (useDarkAppearance(style))
7178         options.add(StyleColor::Options::UseDarkAppearance);
7179     if (useElevatedUserInterfaceLevel())
7180         options.add(StyleColor::Options::UseElevatedUserInterfaceLevel);
7181     return options;
7182 }
7183 
7184 CompositeOperator Document::compositeOperatorForBackgroundColor(const Color&amp; color, const RenderObject&amp; renderer) const
7185 {
7186     if (LIKELY(!settings().punchOutWhiteBackgroundsInDarkMode() || !Color::isWhiteColor(color) || !renderer.useDarkAppearance()))
7187         return CompositeOperator::SourceOver;
7188 
7189     auto* frameView = view();
7190     if (!frameView)
7191         return CompositeOperator::SourceOver;
7192 
7193     // Mail on macOS uses a transparent view, and on iOS it is an opaque view. We need to
7194     // use different composite modes to get the right results in this case.
7195     return frameView-&gt;isTransparent() ? CompositeOperator::DestinationOut : CompositeOperator::DestinationIn;
7196 }
7197 
7198 void Document::didAssociateFormControl(Element&amp; element)
7199 {
7200     auto* page = this-&gt;page();
7201     if (!page || !page-&gt;chrome().client().shouldNotifyOnFormChanges())
7202         return;
7203     m_associatedFormControls.add(&amp;element);
7204     if (!m_didAssociateFormControlsTimer.isActive())
7205         m_didAssociateFormControlsTimer.startOneShot(0_s);
7206 }
7207 
7208 void Document::didAssociateFormControlsTimerFired()
7209 {
7210     auto vector = copyToVector(m_associatedFormControls);
7211     m_associatedFormControls.clear();
7212     if (auto* page = this-&gt;page()) {
7213         ASSERT(m_frame);
7214         page-&gt;chrome().client().didAssociateFormControls(vector, *m_frame);
7215     }
7216 }
7217 
7218 void Document::setCachedDOMCookies(const String&amp; cookies)
7219 {
7220     ASSERT(!isDOMCookieCacheValid());
7221     m_cachedDOMCookies = cookies;
7222     // The cookie cache is valid at most until we go back to the event loop.
7223     m_cookieCacheExpiryTimer.startOneShot(0_s);
7224 }
7225 
7226 void Document::invalidateDOMCookieCache()
7227 {
7228     m_cookieCacheExpiryTimer.stop();
7229     m_cachedDOMCookies = String();
7230 }
7231 
7232 void Document::didLoadResourceSynchronously()
7233 {
7234     // Synchronous resources loading can set cookies so we invalidate the cookies cache
7235     // in this case, to be safe.
7236     invalidateDOMCookieCache();
7237 }
7238 
7239 void Document::ensurePlugInsInjectedScript(DOMWrapperWorld&amp; world)
7240 {
7241     if (m_hasInjectedPlugInsScript)
7242         return;
7243 
7244     auto&amp; scriptController = frame()-&gt;script();
7245 
7246     // Use the JS file provided by the Chrome client, or fallback to the default one.
7247     String jsString = page()-&gt;chrome().client().plugInExtraScript();
7248     if (!jsString || !scriptController.shouldAllowUserAgentScripts(*this))
7249         jsString = String(plugInsJavaScript, sizeof(plugInsJavaScript));
7250 
7251     setHasEvaluatedUserAgentScripts();
7252     scriptController.evaluateInWorldIgnoringException(ScriptSourceCode(jsString), world);
7253 
7254     m_hasInjectedPlugInsScript = true;
7255 }
7256 
7257 #if ENABLE(WEB_CRYPTO)
7258 
7259 bool Document::wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey)
7260 {
7261     Page* page = this-&gt;page();
7262     if (!page)
7263         return false;
7264     return page-&gt;chrome().client().wrapCryptoKey(key, wrappedKey);
7265 }
7266 
7267 bool Document::unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key)
7268 {
7269     Page* page = this-&gt;page();
7270     if (!page)
7271         return false;
7272     return page-&gt;chrome().client().unwrapCryptoKey(wrappedKey, key);
7273 }
7274 
7275 #endif // ENABLE(WEB_CRYPTO)
7276 
7277 Element* Document::activeElement()
7278 {
7279     if (Element* element = treeScope().focusedElementInScope())
7280         return element;
7281     return bodyOrFrameset();
7282 }
7283 
7284 bool Document::hasFocus() const
7285 {
7286     Page* page = this-&gt;page();
7287     if (!page || !page-&gt;focusController().isActive())
7288         return false;
7289     if (Frame* focusedFrame = page-&gt;focusController().focusedFrame()) {
7290         if (focusedFrame-&gt;tree().isDescendantOf(frame()))
7291             return true;
7292     }
7293     return false;
7294 }
7295 
7296 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7297 
7298 static uint64_t nextPlaybackTargetClientContextId()
7299 {
7300     static uint64_t contextId = 0;
7301     return ++contextId;
7302 }
7303 
7304 void Document::addPlaybackTargetPickerClient(MediaPlaybackTargetClient&amp; client)
7305 {
7306     Page* page = this-&gt;page();
7307     if (!page)
7308         return;
7309 
7310     // FIXME: change this back to an ASSERT once https://webkit.org/b/144970 is fixed.
7311     if (m_clientToIDMap.contains(&amp;client))
7312         return;
7313 
7314     uint64_t contextId = nextPlaybackTargetClientContextId();
7315     m_clientToIDMap.add(&amp;client, contextId);
7316     m_idToClientMap.add(contextId, &amp;client);
7317     page-&gt;addPlaybackTargetPickerClient(contextId);
7318 }
7319 
7320 void Document::removePlaybackTargetPickerClient(MediaPlaybackTargetClient&amp; client)
7321 {
7322     auto it = m_clientToIDMap.find(&amp;client);
7323     if (it == m_clientToIDMap.end())
7324         return;
7325 
7326     uint64_t clientId = it-&gt;value;
7327     m_idToClientMap.remove(clientId);
7328     m_clientToIDMap.remove(it);
7329 
7330     Page* page = this-&gt;page();
7331     if (!page)
7332         return;
7333     page-&gt;removePlaybackTargetPickerClient(clientId);
7334 }
7335 
7336 void Document::showPlaybackTargetPicker(MediaPlaybackTargetClient&amp; client, bool isVideo, RouteSharingPolicy routeSharingPolicy, const String&amp; routingContextUID)
7337 {
7338     Page* page = this-&gt;page();
7339     if (!page)
7340         return;
7341 
7342     auto it = m_clientToIDMap.find(&amp;client);
7343     if (it == m_clientToIDMap.end())
7344         return;
7345 
7346     page-&gt;showPlaybackTargetPicker(it-&gt;value, view()-&gt;lastKnownMousePosition(), isVideo, routeSharingPolicy, routingContextUID);
7347 }
7348 
7349 void Document::playbackTargetPickerClientStateDidChange(MediaPlaybackTargetClient&amp; client, MediaProducer::MediaStateFlags state)
7350 {
7351     Page* page = this-&gt;page();
7352     if (!page)
7353         return;
7354 
7355     auto it = m_clientToIDMap.find(&amp;client);
7356     if (it == m_clientToIDMap.end())
7357         return;
7358 
7359     page-&gt;playbackTargetPickerClientStateDidChange(it-&gt;value, state);
7360 }
7361 
7362 void Document::playbackTargetAvailabilityDidChange(uint64_t clientId, bool available)
7363 {
7364     auto it = m_idToClientMap.find(clientId);
7365     if (it == m_idToClientMap.end())
7366         return;
7367 
7368     it-&gt;value-&gt;externalOutputDeviceAvailableDidChange(available);
7369 }
7370 
7371 void Document::setPlaybackTarget(uint64_t clientId, Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; target)
7372 {
7373     auto it = m_idToClientMap.find(clientId);
7374     if (it == m_idToClientMap.end())
7375         return;
7376 
7377     it-&gt;value-&gt;setPlaybackTarget(target.copyRef());
7378 }
7379 
7380 void Document::setShouldPlayToPlaybackTarget(uint64_t clientId, bool shouldPlay)
7381 {
7382     auto it = m_idToClientMap.find(clientId);
7383     if (it == m_idToClientMap.end())
7384         return;
7385 
7386     it-&gt;value-&gt;setShouldPlayToPlaybackTarget(shouldPlay);
7387 }
7388 
7389 void Document::playbackTargetPickerWasDismissed(uint64_t clientId)
7390 {
7391     auto it = m_idToClientMap.find(clientId);
7392     if (it == m_idToClientMap.end())
7393         return;
7394 
7395     it-&gt;value-&gt;playbackTargetPickerWasDismissed();
7396 }
7397 
7398 #endif // ENABLE(WIRELESS_PLAYBACK_TARGET)
7399 
7400 #if ENABLE(MEDIA_SESSION)
7401 
7402 MediaSession&amp; Document::defaultMediaSession()
7403 {
7404     if (!m_defaultMediaSession)
7405         m_defaultMediaSession = MediaSession::create(*scriptExecutionContext());
7406     return *m_defaultMediaSession;
7407 }
7408 
7409 #endif
7410 
7411 ShouldOpenExternalURLsPolicy Document::shouldOpenExternalURLsPolicyToPropagate() const
7412 {
7413     if (DocumentLoader* documentLoader = loader())
7414         return documentLoader-&gt;shouldOpenExternalURLsPolicyToPropagate();
7415 
7416     return ShouldOpenExternalURLsPolicy::ShouldNotAllow;
7417 }
7418 
7419 bool Document::shouldEnforceHTTP09Sandbox() const
7420 {
7421     if (m_isSynthesized || !m_frame)
7422         return false;
7423     DocumentLoader* documentLoader = m_frame-&gt;loader().activeDocumentLoader();
7424     return documentLoader &amp;&amp; documentLoader-&gt;response().isHTTP09();
7425 }
7426 
7427 #if USE(QUICK_LOOK)
7428 
7429 bool Document::shouldEnforceQuickLookSandbox() const
7430 {
7431     if (m_isSynthesized || !m_frame)
7432         return false;
7433     DocumentLoader* documentLoader = m_frame-&gt;loader().activeDocumentLoader();
7434     return documentLoader &amp;&amp; documentLoader-&gt;response().isQuickLook();
7435 }
7436 
7437 void Document::applyQuickLookSandbox()
7438 {
7439     auto&amp; documentLoader = *m_frame-&gt;loader().activeDocumentLoader();
7440     auto documentURL = documentLoader.documentURL();
7441     auto&amp; responseURL = documentLoader.responseURL();
7442     ASSERT(!documentURL.protocolIs(QLPreviewProtocol));
7443     ASSERT(responseURL.protocolIs(QLPreviewProtocol));
7444 
7445     auto securityOrigin = SecurityOrigin::createNonLocalWithAllowedFilePath(responseURL, documentURL.fileSystemPath());
7446     securityOrigin-&gt;setStorageBlockingPolicy(SecurityOrigin::BlockAllStorage);
7447     setSecurityOriginPolicy(SecurityOriginPolicy::create(WTFMove(securityOrigin)));
7448 
7449     static NeverDestroyed&lt;String&gt; quickLookCSP = makeString(&quot;default-src &quot;, QLPreviewProtocol, &quot;: &#39;unsafe-inline&#39;; base-uri &#39;none&#39;; sandbox allow-same-origin allow-scripts&quot;);
7450     RELEASE_ASSERT(contentSecurityPolicy());
7451     // The sandbox directive is only allowed if the policy is from an HTTP header.
7452     contentSecurityPolicy()-&gt;didReceiveHeader(quickLookCSP, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::HTTPHeader, referrer());
7453 
7454     disableSandboxFlags(SandboxNavigation);
7455 
7456     setReferrerPolicy(ReferrerPolicy::NoReferrer);
7457 }
7458 
7459 #endif
7460 
7461 bool Document::shouldEnforceContentDispositionAttachmentSandbox() const
7462 {
7463     if (!settings().contentDispositionAttachmentSandboxEnabled())
7464         return false;
7465 
7466     if (m_isSynthesized)
7467         return false;
7468 
7469     if (auto* documentLoader = m_frame ? m_frame-&gt;loader().activeDocumentLoader() : nullptr)
7470         return documentLoader-&gt;response().isAttachment();
7471     return false;
7472 }
7473 
7474 void Document::applyContentDispositionAttachmentSandbox()
7475 {
7476     ASSERT(shouldEnforceContentDispositionAttachmentSandbox());
7477 
7478     setReferrerPolicy(ReferrerPolicy::NoReferrer);
7479     if (!isMediaDocument())
7480         enforceSandboxFlags(SandboxAll);
7481     else
7482         enforceSandboxFlags(SandboxOrigin);
7483 }
7484 
7485 void Document::addDynamicMediaQueryDependentImage(HTMLImageElement&amp; element)
7486 {
7487     m_dynamicMediaQueryDependentImages.add(element);
7488 }
7489 
7490 void Document::removeDynamicMediaQueryDependentImage(HTMLImageElement&amp; element)
7491 {
7492     m_dynamicMediaQueryDependentImages.remove(element);
7493 }
7494 
7495 void Document::scheduleTimedRenderingUpdate()
7496 {
7497 #if ENABLE(INTERSECTION_OBSERVER)
7498     m_intersectionObserversInitialUpdateTimer.stop();
7499 #endif
7500     if (auto page = this-&gt;page())
7501         page-&gt;renderingUpdateScheduler().scheduleTimedRenderingUpdate();
7502 }
7503 
7504 #if ENABLE(INTERSECTION_OBSERVER)
7505 
7506 void Document::addIntersectionObserver(IntersectionObserver&amp; observer)
7507 {
7508     ASSERT(m_intersectionObservers.find(&amp;observer) == notFound);
7509     m_intersectionObservers.append(makeWeakPtr(&amp;observer));
7510 }
7511 
7512 void Document::removeIntersectionObserver(IntersectionObserver&amp; observer)
7513 {
7514     m_intersectionObservers.removeFirst(&amp;observer);
7515 }
7516 
7517 static void expandRootBoundsWithRootMargin(FloatRect&amp; localRootBounds, const LengthBox&amp; rootMargin)
7518 {
7519     FloatBoxExtent rootMarginFloatBox(
7520         floatValueForLength(rootMargin.top(), localRootBounds.height()),
7521         floatValueForLength(rootMargin.right(), localRootBounds.width()),
7522         floatValueForLength(rootMargin.bottom(), localRootBounds.height()),
7523         floatValueForLength(rootMargin.left(), localRootBounds.width())
7524     );
7525 
7526     localRootBounds.expand(rootMarginFloatBox);
7527 }
7528 
7529 static Optional&lt;LayoutRect&gt; computeClippedRectInRootContentsSpace(const LayoutRect&amp; rect, const RenderElement* renderer)
7530 {
7531     OptionSet&lt;RenderObject::VisibleRectContextOption&gt; visibleRectOptions = { RenderObject::VisibleRectContextOption::UseEdgeInclusiveIntersection, RenderObject::VisibleRectContextOption::ApplyCompositedClips, RenderObject::VisibleRectContextOption::ApplyCompositedContainerScrolls };
7532     Optional&lt;LayoutRect&gt; rectInFrameAbsoluteSpace = renderer-&gt;computeVisibleRectInContainer(rect, &amp;renderer-&gt;view(),  {false /* hasPositionFixedDescendant */, false /* dirtyRectIsFlipped */, visibleRectOptions });
7533     if (!rectInFrameAbsoluteSpace || renderer-&gt;frame().isMainFrame())
7534         return rectInFrameAbsoluteSpace;
7535 
7536     bool intersects = rectInFrameAbsoluteSpace-&gt;edgeInclusiveIntersect(renderer-&gt;view().frameView().layoutViewportRect());
7537     if (!intersects)
7538         return WTF::nullopt;
7539 
7540     LayoutRect rectInFrameViewSpace(renderer-&gt;view().frameView().contentsToView(snappedIntRect(*rectInFrameAbsoluteSpace)));
7541     auto* ownerRenderer = renderer-&gt;frame().ownerRenderer();
7542     if (!ownerRenderer)
7543         return WTF::nullopt;
7544 
7545     rectInFrameViewSpace.moveBy(ownerRenderer-&gt;contentBoxLocation());
7546     return computeClippedRectInRootContentsSpace(rectInFrameViewSpace, ownerRenderer);
7547 }
7548 
7549 struct IntersectionObservationState {
7550     FloatRect absoluteTargetRect;
7551     FloatRect absoluteRootBounds;
7552     FloatRect absoluteIntersectionRect;
7553     bool isIntersecting { false };
7554 };
7555 
7556 static Optional&lt;IntersectionObservationState&gt; computeIntersectionState(FrameView&amp; frameView, const IntersectionObserver&amp; observer, Element&amp; target, bool applyRootMargin)
7557 {
7558     auto* targetRenderer = target.renderer();
7559     if (!targetRenderer)
7560         return WTF::nullopt;
7561 
7562     FloatRect localRootBounds;
7563     RenderBlock* rootRenderer;
7564     if (observer.root()) {
7565         if (observer.trackingDocument() != &amp;target.document())
7566             return WTF::nullopt;
7567 
7568         if (!observer.root()-&gt;renderer() || !is&lt;RenderBlock&gt;(observer.root()-&gt;renderer()))
7569             return WTF::nullopt;
7570 
7571         rootRenderer = downcast&lt;RenderBlock&gt;(observer.root()-&gt;renderer());
7572         if (!rootRenderer-&gt;isContainingBlockAncestorFor(*targetRenderer))
7573             return WTF::nullopt;
7574 
7575         if (rootRenderer-&gt;hasOverflowClip())
7576             localRootBounds = rootRenderer-&gt;contentBoxRect();
7577         else
7578             localRootBounds = { FloatPoint(), rootRenderer-&gt;size() };
7579     } else {
7580         ASSERT(frameView.frame().isMainFrame());
7581         // FIXME: Handle the case of an implicit-root observer that has a target in a different frame tree.
7582         if (&amp;targetRenderer-&gt;frame().mainFrame() != &amp;frameView.frame())
7583             return WTF::nullopt;
7584         rootRenderer = frameView.renderView();
7585         localRootBounds = frameView.layoutViewportRect();
7586     }
7587 
7588     if (applyRootMargin)
7589         expandRootBoundsWithRootMargin(localRootBounds, observer.rootMarginBox());
7590 
7591     LayoutRect localTargetBounds;
7592     if (is&lt;RenderBox&gt;(*targetRenderer))
7593         localTargetBounds = downcast&lt;RenderBox&gt;(targetRenderer)-&gt;borderBoundingBox();
7594     else if (is&lt;RenderInline&gt;(targetRenderer)) {
7595         auto pair = target.boundingAbsoluteRectWithoutLayout();
7596         if (pair) {
7597             FloatRect absoluteTargetBounds = pair-&gt;second;
7598             localTargetBounds = enclosingLayoutRect(targetRenderer-&gt;absoluteToLocalQuad(absoluteTargetBounds).boundingBox());
7599         }
7600     } else if (is&lt;RenderLineBreak&gt;(targetRenderer))
7601         localTargetBounds = downcast&lt;RenderLineBreak&gt;(targetRenderer)-&gt;linesBoundingBox();
7602 
7603     Optional&lt;LayoutRect&gt; rootLocalTargetRect;
7604     if (observer.root()) {
7605         OptionSet&lt;RenderObject::VisibleRectContextOption&gt; visibleRectOptions = { RenderObject::VisibleRectContextOption::UseEdgeInclusiveIntersection, RenderObject::VisibleRectContextOption::ApplyCompositedClips, RenderObject::VisibleRectContextOption::ApplyCompositedContainerScrolls };
7606         rootLocalTargetRect = targetRenderer-&gt;computeVisibleRectInContainer(localTargetBounds, rootRenderer, { false /* hasPositionFixedDescendant */, false /* dirtyRectIsFlipped */, visibleRectOptions });
7607     } else
7608         rootLocalTargetRect = computeClippedRectInRootContentsSpace(localTargetBounds, targetRenderer);
7609 
7610     FloatRect rootLocalIntersectionRect = localRootBounds;
7611 
7612     IntersectionObservationState intersectionState;
7613     intersectionState.isIntersecting = rootLocalTargetRect &amp;&amp; rootLocalIntersectionRect.edgeInclusiveIntersect(*rootLocalTargetRect);
7614     intersectionState.absoluteTargetRect = targetRenderer-&gt;localToAbsoluteQuad(FloatRect(localTargetBounds)).boundingBox();
7615     intersectionState.absoluteRootBounds = rootRenderer-&gt;localToAbsoluteQuad(localRootBounds).boundingBox();
7616 
7617     if (intersectionState.isIntersecting) {
7618         FloatRect rootAbsoluteIntersectionRect = rootRenderer-&gt;localToAbsoluteQuad(rootLocalIntersectionRect).boundingBox();
7619         if (&amp;targetRenderer-&gt;frame() == &amp;rootRenderer-&gt;frame())
7620             intersectionState.absoluteIntersectionRect = rootAbsoluteIntersectionRect;
7621         else {
7622             FloatRect rootViewIntersectionRect = frameView.contentsToView(rootAbsoluteIntersectionRect);
7623             intersectionState.absoluteIntersectionRect = targetRenderer-&gt;view().frameView().rootViewToContents(rootViewIntersectionRect);
7624         }
7625         intersectionState.isIntersecting = intersectionState.absoluteIntersectionRect.edgeInclusiveIntersect(intersectionState.absoluteTargetRect);
7626     }
7627 
7628     return intersectionState;
7629 }
7630 
7631 void Document::updateIntersectionObservations()
7632 {
7633     auto* frameView = view();
7634     if (!frameView)
7635         return;
7636 
7637     m_intersectionObserversInitialUpdateTimer.stop();
7638 
7639     bool needsLayout = frameView-&gt;layoutContext().isLayoutPending() || (renderView() &amp;&amp; renderView()-&gt;needsLayout());
7640     if (needsLayout || hasPendingStyleRecalc())
7641         return;
7642 
7643     for (const auto&amp; observer : m_intersectionObservers) {
7644         bool needNotify = false;
7645         DOMHighResTimeStamp timestamp;
7646         if (!observer-&gt;createTimestamp(timestamp))
7647             continue;
7648         for (Element* target : observer-&gt;observationTargets()) {
7649             auto&amp; targetRegistrations = target-&gt;intersectionObserverData()-&gt;registrations;
7650             auto index = targetRegistrations.findMatching([observer](auto&amp; registration) {
7651                 return registration.observer.get() == observer;
7652             });
7653             ASSERT(index != notFound);
7654             auto&amp; registration = targetRegistrations[index];
7655 
7656             bool isSameOriginObservation = &amp;target-&gt;document() == this || target-&gt;document().securityOrigin().canAccess(securityOrigin());
7657             auto intersectionState = computeIntersectionState(*frameView, *observer, *target, isSameOriginObservation);
7658 
7659             float intersectionRatio = 0;
7660             size_t thresholdIndex = 0;
7661             if (intersectionState) {
7662                 if (intersectionState-&gt;isIntersecting) {
7663                     float absTargetArea = intersectionState-&gt;absoluteTargetRect.area();
7664                     if (absTargetArea)
7665                         intersectionRatio = intersectionState-&gt;absoluteIntersectionRect.area() / absTargetArea;
7666                     else
7667                         intersectionRatio = 1;
7668 
7669                     auto&amp; thresholds = observer-&gt;thresholds();
7670                     while (thresholdIndex &lt; thresholds.size() &amp;&amp; thresholds[thresholdIndex] &lt;= intersectionRatio)
7671                         ++thresholdIndex;
7672                 }
7673             }
7674 
7675             if (!registration.previousThresholdIndex || thresholdIndex != registration.previousThresholdIndex) {
7676                 FloatRect targetBoundingClientRect;
7677                 FloatRect clientIntersectionRect;
7678                 FloatRect clientRootBounds;
7679                 if (intersectionState) {
7680                     auto* targetFrameView = target-&gt;document().view();
7681                     targetBoundingClientRect = targetFrameView-&gt;absoluteToClientRect(intersectionState-&gt;absoluteTargetRect, target-&gt;renderer()-&gt;style().effectiveZoom());
7682                     auto* rootRenderer = observer-&gt;root() ? observer-&gt;root()-&gt;renderer() : frameView-&gt;renderView();
7683                     clientRootBounds = frameView-&gt;absoluteToClientRect(intersectionState-&gt;absoluteRootBounds, rootRenderer-&gt;style().effectiveZoom());
7684                     if (intersectionState-&gt;isIntersecting)
7685                         clientIntersectionRect = targetFrameView-&gt;absoluteToClientRect(intersectionState-&gt;absoluteIntersectionRect, target-&gt;renderer()-&gt;style().effectiveZoom());
7686                 }
7687 
7688                 Optional&lt;DOMRectInit&gt; reportedRootBounds;
7689                 if (isSameOriginObservation) {
7690                     reportedRootBounds = DOMRectInit({
7691                         clientRootBounds.x(),
7692                         clientRootBounds.y(),
7693                         clientRootBounds.width(),
7694                         clientRootBounds.height()
7695                     });
7696                 }
7697 
7698                 observer-&gt;appendQueuedEntry(IntersectionObserverEntry::create({
7699                     timestamp,
7700                     reportedRootBounds,
7701                     { targetBoundingClientRect.x(), targetBoundingClientRect.y(), targetBoundingClientRect.width(), targetBoundingClientRect.height() },
7702                     { clientIntersectionRect.x(), clientIntersectionRect.y(), clientIntersectionRect.width(), clientIntersectionRect.height() },
7703                     intersectionRatio,
7704                     target,
7705                     thresholdIndex &gt; 0,
7706                 }));
7707                 needNotify = true;
7708                 registration.previousThresholdIndex = thresholdIndex;
7709             }
7710         }
7711         if (needNotify)
7712             m_intersectionObserversWithPendingNotifications.append(makeWeakPtr(observer.get()));
7713     }
7714 
7715     if (m_intersectionObserversWithPendingNotifications.size())
7716         m_intersectionObserversNotifyTimer.startOneShot(0_s);
7717 }
7718 
7719 void Document::notifyIntersectionObserversTimerFired()
7720 {
7721     for (const auto&amp; observer : m_intersectionObserversWithPendingNotifications) {
7722         if (observer)
7723             observer-&gt;notify();
7724     }
7725     m_intersectionObserversWithPendingNotifications.clear();
7726 }
7727 
7728 void Document::scheduleInitialIntersectionObservationUpdate()
7729 {
7730     if (m_readyState == Complete)
7731         scheduleTimedRenderingUpdate();
7732     else if (!m_intersectionObserversInitialUpdateTimer.isActive())
7733         m_intersectionObserversInitialUpdateTimer.startOneShot(intersectionObserversInitialUpdateDelay);
7734 }
7735 
7736 #endif
7737 
7738 #if ENABLE(RESIZE_OBSERVER)
7739 
7740 void Document::addResizeObserver(ResizeObserver&amp; observer)
7741 {
7742     if (!m_resizeObservers.contains(&amp;observer))
7743         m_resizeObservers.append(makeWeakPtr(&amp;observer));
7744 }
7745 
7746 void Document::removeResizeObserver(ResizeObserver&amp; observer)
7747 {
7748     m_resizeObservers.removeFirst(&amp;observer);
7749 }
7750 
7751 bool Document::hasResizeObservers()
7752 {
7753     return !m_resizeObservers.isEmpty();
7754 }
7755 
7756 size_t Document::gatherResizeObservations(size_t deeperThan)
7757 {
7758     size_t minDepth = ResizeObserver::maxElementDepth();
7759     for (const auto&amp; observer : m_resizeObservers) {
7760         if (!observer-&gt;hasObservations())
7761             continue;
7762         auto depth = observer-&gt;gatherObservations(deeperThan);
7763         minDepth = std::min(minDepth, depth);
7764     }
7765     return minDepth;
7766 }
7767 
7768 void Document::deliverResizeObservations()
7769 {
7770     auto observersToNotify = m_resizeObservers;
7771     for (const auto&amp; observer : observersToNotify) {
7772         if (!observer || !observer-&gt;hasActiveObservations())
7773             continue;
7774         observer-&gt;deliverObservations();
7775     }
7776 }
7777 
7778 bool Document::hasSkippedResizeObservations() const
7779 {
7780     for (const auto&amp; observer : m_resizeObservers) {
7781         if (observer-&gt;hasSkippedObservations())
7782             return true;
7783     }
7784     return false;
7785 }
7786 
7787 void Document::setHasSkippedResizeObservations(bool skipped)
7788 {
7789     for (const auto&amp; observer : m_resizeObservers)
7790         observer-&gt;setHasSkippedObservations(skipped);
7791 }
7792 
7793 void Document::updateResizeObservations(Page&amp; page)
7794 {
7795     if (!hasResizeObservers())
7796         return;
7797 
7798     // We need layout the whole frame tree here. Because ResizeObserver could observe element in other frame,
7799     // and it could change other frame in deliverResizeObservations().
7800     page.layoutIfNeeded();
7801 
7802     // Start check resize obervers;
7803     for (size_t depth = gatherResizeObservations(0); depth != ResizeObserver::maxElementDepth(); depth = gatherResizeObservations(depth)) {
7804         deliverResizeObservations();
7805         page.layoutIfNeeded();
7806     }
7807 
7808     if (hasSkippedResizeObservations()) {
7809         setHasSkippedResizeObservations(false);
7810         String url;
7811         unsigned line = 0;
7812         unsigned column = 0;
7813         getParserLocation(url, line, column);
7814         reportException(&quot;ResizeObserver loop completed with undelivered notifications.&quot;, line, column, url, nullptr, nullptr);
7815         // Starting a new schedule the next round of notify.
7816         scheduleTimedRenderingUpdate();
7817     }
7818 }
7819 
7820 #endif
7821 
7822 const AtomString&amp; Document::dir() const
7823 {
7824     auto* documentElement = this-&gt;documentElement();
7825     if (!is&lt;HTMLHtmlElement&gt;(documentElement))
7826         return nullAtom();
7827     return downcast&lt;HTMLHtmlElement&gt;(*documentElement).dir();
7828 }
7829 
7830 void Document::setDir(const AtomString&amp; value)
7831 {
7832     auto* documentElement = this-&gt;documentElement();
7833     if (is&lt;HTMLHtmlElement&gt;(documentElement))
7834         downcast&lt;HTMLHtmlElement&gt;(*documentElement).setDir(value);
7835 }
7836 
7837 DOMSelection* Document::getSelection()
7838 {
7839     return m_domWindow ? m_domWindow-&gt;getSelection() : nullptr;
7840 }
7841 
7842 void Document::didInsertInDocumentShadowRoot(ShadowRoot&amp; shadowRoot)
7843 {
7844     ASSERT(shadowRoot.isConnected());
7845     ASSERT(!m_inDocumentShadowRoots.contains(&amp;shadowRoot));
7846     m_inDocumentShadowRoots.add(&amp;shadowRoot);
7847 }
7848 
7849 void Document::didRemoveInDocumentShadowRoot(ShadowRoot&amp; shadowRoot)
7850 {
7851     ASSERT(m_inDocumentShadowRoots.contains(&amp;shadowRoot));
7852     m_inDocumentShadowRoots.remove(&amp;shadowRoot);
7853 }
7854 
7855 void Document::orientationChanged(int orientation)
7856 {
7857     LOG(Events, &quot;Document %p orientationChanged - orientation %d&quot;, this, orientation);
7858     dispatchWindowEvent(Event::create(eventNames().orientationchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
7859     m_orientationNotifier.orientationChanged(orientation);
7860 }
7861 
7862 #if ENABLE(MEDIA_STREAM)
7863 
7864 void Document::stopMediaCapture()
7865 {
7866     MediaStreamTrack::endCapture(*this);
7867 }
7868 
7869 void Document::mediaStreamCaptureStateChanged()
7870 {
7871     if (!MediaProducer::isCapturing(m_mediaState))
7872         return;
7873 
7874     forEachMediaElement([] (HTMLMediaElement&amp; element) {
7875         element.mediaStreamCaptureStarted();
7876     });
7877 }
7878 
7879 void Document::setDeviceIDHashSalt(const String&amp; salt)
7880 {
7881     ASSERT(m_idHashSalt.isEmpty() || m_idHashSalt == salt);
7882     m_idHashSalt = salt;
7883 }
7884 
7885 #endif
7886 
7887 const AtomString&amp; Document::bgColor() const
7888 {
7889     auto* bodyElement = body();
7890     if (!bodyElement)
7891         return emptyAtom();
7892     return bodyElement-&gt;attributeWithoutSynchronization(bgcolorAttr);
7893 }
7894 
7895 void Document::setBgColor(const String&amp; value)
7896 {
7897     if (auto* bodyElement = body())
7898         bodyElement-&gt;setAttributeWithoutSynchronization(bgcolorAttr, value);
7899 }
7900 
7901 const AtomString&amp; Document::fgColor() const
7902 {
7903     auto* bodyElement = body();
7904     if (!bodyElement)
7905         return emptyAtom();
7906     return bodyElement-&gt;attributeWithoutSynchronization(textAttr);
7907 }
7908 
7909 void Document::setFgColor(const String&amp; value)
7910 {
7911     if (auto* bodyElement = body())
7912         bodyElement-&gt;setAttributeWithoutSynchronization(textAttr, value);
7913 }
7914 
7915 const AtomString&amp; Document::alinkColor() const
7916 {
7917     auto* bodyElement = body();
7918     if (!bodyElement)
7919         return emptyAtom();
7920     return bodyElement-&gt;attributeWithoutSynchronization(alinkAttr);
7921 }
7922 
7923 void Document::setAlinkColor(const String&amp; value)
7924 {
7925     if (auto* bodyElement = body())
7926         bodyElement-&gt;setAttributeWithoutSynchronization(alinkAttr, value);
7927 }
7928 
7929 const AtomString&amp; Document::linkColorForBindings() const
7930 {
7931     auto* bodyElement = body();
7932     if (!bodyElement)
7933         return emptyAtom();
7934     return bodyElement-&gt;attributeWithoutSynchronization(linkAttr);
7935 }
7936 
7937 void Document::setLinkColorForBindings(const String&amp; value)
7938 {
7939     if (auto* bodyElement = body())
7940         bodyElement-&gt;setAttributeWithoutSynchronization(linkAttr, value);
7941 }
7942 
7943 const AtomString&amp; Document::vlinkColor() const
7944 {
7945     auto* bodyElement = body();
7946     if (!bodyElement)
7947         return emptyAtom();
7948     return bodyElement-&gt;attributeWithoutSynchronization(vlinkAttr);
7949 }
7950 
7951 void Document::setVlinkColor(const String&amp; value)
7952 {
7953     if (auto* bodyElement = body())
7954         bodyElement-&gt;setAttributeWithoutSynchronization(vlinkAttr, value);
7955 }
7956 
7957 Logger&amp; Document::logger()
7958 {
7959     if (!m_logger) {
7960         m_logger = Logger::create(this);
7961         auto* page = this-&gt;page();
7962         m_logger-&gt;setEnabled(this, page &amp;&amp; page-&gt;sessionID().isAlwaysOnLoggingAllowed());
7963         m_logger-&gt;addObserver(*this);
7964     }
7965 
7966     return *m_logger;
7967 }
7968 
7969 Optional&lt;PageIdentifier&gt; Document::pageID() const
7970 {
7971     return m_frame-&gt;loader().client().pageID();
7972 }
7973 
7974 void Document::registerArticleElement(Element&amp; article)
7975 {
7976     m_articleElements.add(&amp;article);
7977 }
7978 
7979 void Document::unregisterArticleElement(Element&amp; article)
7980 {
7981     m_articleElements.remove(&amp;article);
7982     if (m_mainArticleElement == &amp;article)
7983         m_mainArticleElement = nullptr;
7984 }
7985 
7986 void Document::updateMainArticleElementAfterLayout()
7987 {
7988     ASSERT(page() &amp;&amp; page()-&gt;requestedLayoutMilestones().contains(DidRenderSignificantAmountOfText));
7989 
7990     // If there are too many article elements on the page, don&#39;t consider any one of them to be &quot;main content&quot;.
7991     const unsigned maxNumberOfArticlesBeforeIgnoringMainContentArticle = 10;
7992 
7993     // We consider an article to be main content if it is either:
7994     // 1. The only article element in the document.
7995     // 2. Much taller than the next tallest article, and also much larger than the viewport.
7996     const float minimumSecondTallestArticleHeightFactor = 4;
7997     const float minimumViewportAreaFactor = 5;
7998 
7999     m_mainArticleElement = nullptr;
8000 
8001     auto numberOfArticles = m_articleElements.size();
8002     if (!numberOfArticles || numberOfArticles &gt; maxNumberOfArticlesBeforeIgnoringMainContentArticle)
8003         return;
8004 
8005     Element* tallestArticle = nullptr;
8006     float tallestArticleHeight = 0;
8007     float tallestArticleWidth = 0;
8008     float secondTallestArticleHeight = 0;
8009 
8010     for (auto* article : m_articleElements) {
8011         auto* box = article-&gt;renderBox();
8012         float height = box ? box-&gt;height().toFloat() : 0;
8013         if (height &gt;= tallestArticleHeight) {
8014             secondTallestArticleHeight = tallestArticleHeight;
8015             tallestArticleHeight = height;
8016             tallestArticleWidth = box ? box-&gt;width().toFloat() : 0;
8017             tallestArticle = article;
8018         } else if (height &gt;= secondTallestArticleHeight)
8019             secondTallestArticleHeight = height;
8020     }
8021 
8022     if (numberOfArticles == 1) {
8023         m_mainArticleElement = tallestArticle;
8024         return;
8025     }
8026 
8027     if (tallestArticleHeight &lt; minimumSecondTallestArticleHeightFactor * secondTallestArticleHeight)
8028         return;
8029 
8030     if (!view())
8031         return;
8032 
8033     auto viewportSize = view()-&gt;layoutViewportRect().size();
8034     if (tallestArticleWidth * tallestArticleHeight &lt; minimumViewportAreaFactor * (viewportSize.width() * viewportSize.height()).toFloat())
8035         return;
8036 
8037     m_mainArticleElement = tallestArticle;
8038 }
8039 
8040 #if ENABLE(RESOURCE_LOAD_STATISTICS)
8041 bool Document::hasRequestedPageSpecificStorageAccessWithUserInteraction(const RegistrableDomain&amp; domain)
8042 {
8043     return m_registrableDomainRequestedPageSpecificStorageAccessWithUserInteraction == domain;
8044 }
8045 
8046 void Document::setHasRequestedPageSpecificStorageAccessWithUserInteraction(const RegistrableDomain&amp; domain)
8047 {
8048     m_registrableDomainRequestedPageSpecificStorageAccessWithUserInteraction = domain;
8049 }
8050 
8051 void Document::wasLoadedWithDataTransferFromPrevalentResource()
8052 {
8053     downgradeReferrerToRegistrableDomain();
8054 }
8055 
8056 void Document::downgradeReferrerToRegistrableDomain()
8057 {
8058     auto referrerStr = referrer();
8059     if (referrerStr.isEmpty())
8060         return;
8061 
8062     URL referrerURL { URL(), referrerStr };
8063     auto referrerPort = referrerURL.port();
8064     RegistrableDomain referrerRegistrableDomain { referrerURL };
8065     auto referrerRegistrableDomainStr = referrerRegistrableDomain.string();
8066     if (referrerRegistrableDomainStr.isEmpty())
8067         return;
8068 
8069     StringBuilder builder;
8070     builder.append(referrerURL.protocol());
8071     builder.appendLiteral(&quot;://&quot;);
8072     builder.append(referrerRegistrableDomainStr);
8073     if (referrerPort) {
8074         builder.append(&#39;:&#39;);
8075         builder.appendNumber(*referrerPort);
8076     }
8077     builder.append(&#39;/&#39;);
8078 
8079     m_referrerOverride = builder.toString();
8080 }
8081 #endif
8082 
8083 void Document::setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp; listener)
8084 {
8085     m_consoleMessageListener = listener;
8086 }
8087 
8088 void Document::addTimeline(DocumentTimeline&amp; timeline)
8089 {
8090     m_timelines.add(timeline);
8091 }
8092 
8093 void Document::removeTimeline(DocumentTimeline&amp; timeline)
8094 {
8095     m_timelines.remove(timeline);
8096 }
8097 
8098 DocumentTimeline&amp; Document::timeline()
8099 {
8100     if (!m_timeline)
8101         m_timeline = DocumentTimeline::create(*this);
8102 
8103     return *m_timeline;
8104 }
8105 
8106 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; Document::getAnimations()
8107 {
8108     // For the list of animations to be current, we need to account for any pending CSS changes,
8109     // such as updates to CSS Animations and CSS Transitions.
8110     updateStyleIfNeeded();
8111 
8112     if (m_timeline)
8113         return m_timeline-&gt;getAnimations();
8114     return { };
8115 }
8116 
8117 #if ENABLE(ATTACHMENT_ELEMENT)
8118 
8119 void Document::registerAttachmentIdentifier(const String&amp; identifier)
8120 {
8121     if (auto* frame = this-&gt;frame())
8122         frame-&gt;editor().registerAttachmentIdentifier(identifier);
8123 }
8124 
8125 void Document::didInsertAttachmentElement(HTMLAttachmentElement&amp; attachment)
8126 {
8127     auto identifier = attachment.uniqueIdentifier();
8128     auto previousIdentifier = identifier;
8129     bool previousIdentifierIsNotUnique = !previousIdentifier.isEmpty() &amp;&amp; m_attachmentIdentifierToElementMap.contains(previousIdentifier);
8130     if (identifier.isEmpty() || previousIdentifierIsNotUnique) {
8131         previousIdentifier = identifier;
8132         identifier = createCanonicalUUIDString();
8133         attachment.setUniqueIdentifier(identifier);
8134     }
8135 
8136     m_attachmentIdentifierToElementMap.set(identifier, attachment);
8137 
8138     if (auto* frame = this-&gt;frame()) {
8139         if (previousIdentifierIsNotUnique)
8140             frame-&gt;editor().cloneAttachmentData(previousIdentifier, identifier);
8141         frame-&gt;editor().didInsertAttachmentElement(attachment);
8142     }
8143 }
8144 
8145 void Document::didRemoveAttachmentElement(HTMLAttachmentElement&amp; attachment)
8146 {
8147     auto identifier = attachment.uniqueIdentifier();
8148     if (!identifier)
8149         return;
8150 
8151     m_attachmentIdentifierToElementMap.remove(identifier);
8152 
8153     if (frame())
8154         frame()-&gt;editor().didRemoveAttachmentElement(attachment);
8155 }
8156 
8157 RefPtr&lt;HTMLAttachmentElement&gt; Document::attachmentForIdentifier(const String&amp; identifier) const
8158 {
8159     return m_attachmentIdentifierToElementMap.get(identifier);
8160 }
8161 
8162 #endif // ENABLE(ATTACHMENT_ELEMENT)
8163 
8164 static MessageSource messageSourceForWTFLogChannel(const WTFLogChannel&amp; channel)
8165 {
8166     static const NeverDestroyed&lt;String&gt; mediaChannel = MAKE_STATIC_STRING_IMPL(&quot;media&quot;);
8167     static const NeverDestroyed&lt;String&gt; webrtcChannel = MAKE_STATIC_STRING_IMPL(&quot;webrtc&quot;);
8168     static const NeverDestroyed&lt;String&gt; mediaSourceChannel = MAKE_STATIC_STRING_IMPL(&quot;mediasource&quot;);
8169 
8170     if (equalIgnoringASCIICase(mediaChannel, channel.name))
8171         return MessageSource::Media;
8172 
8173     if (equalIgnoringASCIICase(webrtcChannel, channel.name))
8174         return MessageSource::WebRTC;
8175 
8176     if (equalIgnoringASCIICase(mediaSourceChannel, channel.name))
8177         return MessageSource::MediaSource;
8178 
8179     return MessageSource::Other;
8180 }
8181 
8182 static MessageLevel messageLevelFromWTFLogLevel(WTFLogLevel level)
8183 {
8184     switch (level) {
8185     case WTFLogLevel::Always:
8186         return MessageLevel::Log;
8187     case WTFLogLevel::Error:
8188         return MessageLevel::Error;
8189         break;
8190     case WTFLogLevel::Warning:
8191         return MessageLevel::Warning;
8192         break;
8193     case WTFLogLevel::Info:
8194         return MessageLevel::Info;
8195         break;
8196     case WTFLogLevel::Debug:
8197         return MessageLevel::Debug;
8198         break;
8199     }
8200 
8201     ASSERT_NOT_REACHED();
8202     return MessageLevel::Log;
8203 }
8204 
8205 static inline Vector&lt;JSONLogValue&gt; crossThreadCopy(Vector&lt;JSONLogValue&gt;&amp;&amp; source)
8206 {
8207     auto values = WTFMove(source);
8208     for (auto&amp; value : values)
8209         value.value = crossThreadCopy(WTFMove(value.value));
8210     return values;
8211 }
8212 
8213 void Document::didLogMessage(const WTFLogChannel&amp; channel, WTFLogLevel level, Vector&lt;JSONLogValue&gt;&amp;&amp; logMessages)
8214 {
8215     if (!isMainThread()) {
8216         postTask([this, channel, level, logMessages = crossThreadCopy(WTFMove(logMessages))](auto&amp;) mutable {
8217             didLogMessage(channel, level, WTFMove(logMessages));
8218         });
8219         return;
8220     }
8221     auto* page = this-&gt;page();
8222     if (!page)
8223         return;
8224 
8225     ASSERT(page-&gt;sessionID().isAlwaysOnLoggingAllowed());
8226 
8227     auto messageSource = messageSourceForWTFLogChannel(channel);
8228     if (messageSource == MessageSource::Other)
8229         return;
8230 
8231     m_logMessageTaskQueue.enqueueTask([this, level, messageSource, logMessages = WTFMove(logMessages)]() mutable {
8232         if (!this-&gt;page())
8233             return;
8234 
8235         auto messageLevel = messageLevelFromWTFLogLevel(level);
8236         auto message = makeUnique&lt;Inspector::ConsoleMessage&gt;(messageSource, MessageType::Log, messageLevel, WTFMove(logMessages), mainWorldExecState(frame()));
8237 
8238         addConsoleMessage(WTFMove(message));
8239     });
8240 }
8241 
8242 #if ENABLE(SERVICE_WORKER)
8243 void Document::setServiceWorkerConnection(SWClientConnection* serviceWorkerConnection)
8244 {
8245     if (m_serviceWorkerConnection == serviceWorkerConnection || m_hasPreparedForDestruction || m_isSuspended)
8246         return;
8247 
8248     if (m_serviceWorkerConnection)
8249         m_serviceWorkerConnection-&gt;unregisterServiceWorkerClient(identifier());
8250 
8251     m_serviceWorkerConnection = serviceWorkerConnection;
8252 
8253     if (!m_serviceWorkerConnection)
8254         return;
8255 
8256     auto controllingServiceWorkerRegistrationIdentifier = activeServiceWorker() ? makeOptional&lt;ServiceWorkerRegistrationIdentifier&gt;(activeServiceWorker()-&gt;registrationIdentifier()) : WTF::nullopt;
8257     m_serviceWorkerConnection-&gt;registerServiceWorkerClient(topOrigin(), ServiceWorkerClientData::from(*this, *serviceWorkerConnection), controllingServiceWorkerRegistrationIdentifier, userAgent(url()));
8258 }
8259 #endif
8260 
8261 String Document::signedPublicKeyAndChallengeString(unsigned keySizeIndex, const String&amp; challengeString, const URL&amp; url)
8262 {
8263     Page* page = this-&gt;page();
8264     if (!page)
8265         return emptyString();
8266     return page-&gt;chrome().client().signedPublicKeyAndChallengeString(keySizeIndex, challengeString, url);
8267 }
8268 
8269 bool Document::registerCSSProperty(CSSRegisteredCustomProperty&amp;&amp; prop)
8270 {
8271     return m_CSSRegisteredPropertySet.add(prop.name, makeUnique&lt;CSSRegisteredCustomProperty&gt;(WTFMove(prop))).isNewEntry;
8272 }
8273 
8274 void Document::detachFromFrame()
8275 {
8276     // Assertion to help pinpint rdar://problem/49877867. If this hits, the crash trace should tell us
8277     // which piece of code is detaching the document from its frame while constructing the CachedFrames.
8278     RELEASE_ASSERT(m_mayBeDetachedFromFrame);
8279 
8280     observeFrame(nullptr);
8281 }
8282 
8283 void Document::frameWasDisconnectedFromOwner()
8284 {
8285     if (!frame())
8286         return;
8287 
8288     if (auto* window = domWindow())
8289         window-&gt;willDetachDocumentFromFrame();
8290 
8291     detachFromFrame();
8292 }
8293 
8294 bool Document::hitTest(const HitTestRequest&amp; request, HitTestResult&amp; result)
8295 {
8296     return hitTest(request, result.hitTestLocation(), result);
8297 }
8298 
8299 bool Document::hitTest(const HitTestRequest&amp; request, const HitTestLocation&amp; location, HitTestResult&amp; result)
8300 {
8301     Ref&lt;Document&gt; protectedThis(*this);
8302     updateLayout();
8303     if (!renderView())
8304         return false;
8305 
8306 #if ASSERT_ENABLED
8307     SetForScope&lt;bool&gt; hitTestRestorer { m_inHitTesting, true };
8308 #endif
8309 
8310     auto&amp; frameView = renderView()-&gt;frameView();
8311     Ref&lt;FrameView&gt; protector(frameView);
8312 
8313     FrameFlatteningLayoutDisallower disallower(frameView);
8314 
8315     bool resultLayer = renderView()-&gt;layer()-&gt;hitTest(request, location, result);
8316 
8317     // ScrollView scrollbars are not the same as RenderLayer scrollbars tested by RenderLayer::hitTestOverflowControls,
8318     // so we need to test ScrollView scrollbars separately here. In case of using overlay scrollbars, the layer hit test
8319     // will always work so we need to check the ScrollView scrollbars in that case too.
8320     if (!resultLayer || ScrollbarTheme::theme().usesOverlayScrollbars()) {
8321         // FIXME: Consider if this test should be done unconditionally.
8322         if (request.allowsFrameScrollbars()) {
8323             IntPoint windowPoint = frameView.contentsToWindow(location.roundedPoint());
8324             if (auto* frameScrollbar = frameView.scrollbarAtPoint(windowPoint)) {
8325                 result.setScrollbar(frameScrollbar);
8326                 return true;
8327             }
8328         }
8329     }
8330     return resultLayer;
8331 }
8332 
8333 ElementIdentifier Document::identifierForElement(Element&amp; element)
8334 {
8335     ASSERT(&amp;element.document() == this);
8336     auto result = m_identifiedElementsMap.ensure(&amp;element, [&amp;] {
8337         return element.createElementIdentifier();
8338     });
8339     return result.iterator-&gt;value;
8340 }
8341 
8342 Element* Document::searchForElementByIdentifier(const ElementIdentifier&amp; identifier)
8343 {
8344     for (auto it = m_identifiedElementsMap.begin(); it != m_identifiedElementsMap.end(); ++it) {
8345         if (it-&gt;value == identifier)
8346             return it-&gt;key;
8347     }
8348 
8349     return nullptr;
8350 }
8351 
8352 void Document::identifiedElementWasRemovedFromDocument(Element&amp; element)
8353 {
8354     m_identifiedElementsMap.remove(&amp;element);
8355 }
8356 
8357 #if ENABLE(DEVICE_ORIENTATION)
8358 
8359 DeviceOrientationAndMotionAccessController&amp; Document::deviceOrientationAndMotionAccessController()
8360 {
8361     if (&amp;topDocument() != this)
8362         return topDocument().deviceOrientationAndMotionAccessController();
8363 
8364     if (!m_deviceOrientationAndMotionAccessController)
8365         m_deviceOrientationAndMotionAccessController = makeUnique&lt;DeviceOrientationAndMotionAccessController&gt;(*this);
8366     return *m_deviceOrientationAndMotionAccessController;
8367 }
8368 
8369 #endif
8370 
8371 #if ENABLE(CSS_PAINTING_API)
8372 Worklet&amp; Document::ensurePaintWorklet()
8373 {
8374     if (!m_paintWorklet)
8375         m_paintWorklet = Worklet::create();
8376     return *m_paintWorklet;
8377 }
8378 
8379 PaintWorkletGlobalScope* Document::paintWorkletGlobalScopeForName(const String&amp; name)
8380 {
8381     return m_paintWorkletGlobalScopes.get(name);
8382 }
8383 
8384 void Document::setPaintWorkletGlobalScopeForName(const String&amp; name, Ref&lt;PaintWorkletGlobalScope&gt;&amp;&amp; scope)
8385 {
8386     auto addResult = m_paintWorkletGlobalScopes.add(name, WTFMove(scope));
8387     ASSERT_UNUSED(addResult, addResult);
8388 }
8389 #endif
8390 
8391 #if PLATFORM(IOS_FAMILY)
8392 
8393 ContentChangeObserver&amp; Document::contentChangeObserver()
8394 {
8395     if (!m_contentChangeObserver)
8396         m_contentChangeObserver = makeUnique&lt;ContentChangeObserver&gt;(*this);
8397     return *m_contentChangeObserver;
8398 }
8399 
8400 DOMTimerHoldingTank&amp; Document::domTimerHoldingTank()
8401 {
8402     if (m_domTimerHoldingTank)
8403         return *m_domTimerHoldingTank;
8404     m_domTimerHoldingTank = makeUnique&lt;DOMTimerHoldingTank&gt;();
8405     return *m_domTimerHoldingTank;
8406 }
8407 
8408 #endif
8409 
8410 bool Document::hasEvaluatedUserAgentScripts() const
8411 {
8412     auto&amp; top = topDocument();
8413     return this == &amp;top ? m_hasEvaluatedUserAgentScripts : top.hasEvaluatedUserAgentScripts();
8414 }
8415 
8416 bool Document::isRunningUserScripts() const
8417 {
8418     auto&amp; top = topDocument();
8419     return this == &amp;top ? m_isRunningUserScripts : top.isRunningUserScripts();
8420 }
8421 
8422 void Document::setAsRunningUserScripts()
8423 {
8424     auto&amp; top = topDocument();
8425     if (this == &amp;top)
8426         m_isRunningUserScripts = true;
8427     else
8428         top.setAsRunningUserScripts();
8429 }
8430 
8431 void Document::setHasEvaluatedUserAgentScripts()
8432 {
8433     auto&amp; top = topDocument();
8434     if (this == &amp;top)
8435         m_hasEvaluatedUserAgentScripts = true;
8436     else
8437         top.setHasEvaluatedUserAgentScripts();
8438 }
8439 
8440 void Document::didRejectSyncXHRDuringPageDismissal()
8441 {
8442     ++m_numberOfRejectedSyncXHRs;
8443     if (m_numberOfRejectedSyncXHRs &gt; 1)
8444         return;
8445 
8446     postTask([this, weakThis = makeWeakPtr(*this)](auto&amp;) mutable {
8447         if (weakThis)
8448             m_numberOfRejectedSyncXHRs = 0;
8449     });
8450 }
8451 
8452 bool Document::shouldIgnoreSyncXHRs() const
8453 {
8454     const unsigned maxRejectedSyncXHRsPerEventLoopIteration = 5;
8455     return m_numberOfRejectedSyncXHRs &gt; maxRejectedSyncXHRsPerEventLoopIteration;
8456 }
8457 
8458 #if ENABLE(APPLE_PAY)
8459 
8460 bool Document::isApplePayActive() const
8461 {
8462     auto&amp; top = topDocument();
8463     return this == &amp;top ? m_hasStartedApplePaySession : top.isApplePayActive();
8464 }
8465 
8466 void Document::setApplePayIsActive()
8467 {
8468     auto&amp; top = topDocument();
8469     if (this == &amp;top)
8470         m_hasStartedApplePaySession = true;
8471     else
8472         top.setApplePayIsActive();
8473 }
8474 
8475 #endif
8476 
8477 MessagePortChannelProvider&amp; Document::messagePortChannelProvider()
8478 {
8479     return MessagePortChannelProvider::singleton();
8480 }
8481 
8482 #if USE(SYSTEM_PREVIEW)
8483 void Document::dispatchSystemPreviewActionEvent(const SystemPreviewInfo&amp; systemPreviewInfo, const String&amp; message)
8484 {
8485     auto* element = searchForElementByIdentifier(systemPreviewInfo.element.elementIdentifier);
8486     if (!element)
8487         return;
8488 
8489     if (!is&lt;HTMLAnchorElement&gt;(element))
8490         return;
8491 
8492     auto event = MessageEvent::create(message, securityOrigin().toString());
8493     UserGestureIndicator gestureIndicator(ProcessingUserGesture, this);
8494     element-&gt;dispatchEvent(event);
8495 }
8496 #endif
8497 
8498 #if ENABLE(PICTURE_IN_PICTURE_API)
8499 HTMLVideoElement* Document::pictureInPictureElement() const
8500 {
8501     return m_pictureInPictureElement.get();
8502 };
8503 
8504 void Document::setPictureInPictureElement(HTMLVideoElement* element)
8505 {
8506     m_pictureInPictureElement = makeWeakPtr(element);
8507 }
8508 #endif
8509 
8510 TextManipulationController&amp; Document::textManipulationController()
8511 {
8512     if (!m_textManipulationController)
8513         m_textManipulationController = makeUnique&lt;TextManipulationController&gt;(*this);
8514     return *m_textManipulationController;
8515 }
8516 
8517 } // namespace WebCore
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>