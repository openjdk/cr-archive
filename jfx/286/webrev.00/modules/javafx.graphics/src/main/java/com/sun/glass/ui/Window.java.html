<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.graphics/src/main/java/com/sun/glass/ui/Window.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package com.sun.glass.ui;
  26 
  27 import com.sun.glass.events.MouseEvent;
  28 import com.sun.glass.events.WindowEvent;
  29 import com.sun.prism.impl.PrismSettings;
  30 
  31 import java.lang.annotation.Native;
  32 
  33 import java.util.Collections;
  34 import java.util.LinkedList;
  35 import java.util.List;
  36 import java.util.Map;
  37 
  38 public abstract class Window {
  39 
  40     public static class EventHandler {
  41         public void handleWindowEvent(Window window, long time, int type) {
  42         }
  43 
  44         /**
  45          * Notifies a listener that the screen object for this Window instance
  46          * has been updated.
  47          *
  48          * Note that while the old and new screen objects may be different,
  49          * they can still represent the same physical screen. This can happen
  50          * if e.g. only a certain parameter of the screen has been updated such
  51          * as its scale factor.
  52          *
  53          * On some platforms when a window is moved to another physical screen
  54          * an app can receive this event twice. One representing the physical
  55          * screen change, and another - the display&#39;s parameters change. Note
  56          * that sending two events instead of just one is platform-specific.
  57          *
  58          * The event handler can use the {@link Screen#getNativeScreen} method
  59          * to determine if this is the same physical screen or not. If the
  60          * native system always creates new native screen instances, there&#39;s no
  61          * way for the app to distinguish between a real move to another screen
  62          * or jsut a parameters update event. Since this is a somewhat rare
  63          * event, an app is advised to always process it the same way.
  64          *
  65          * @see Window#getScreen
  66          */
  67         public void handleScreenChangedEvent(Window window, long time, Screen oldScreen, Screen newScreen) {
  68         }
  69 
  70         /**
  71          * Notifies the listener that the window level has changed. The Level should be one of
  72          * {@link com.sun.glass.ui.Window.Level#NORMAL}, {@link com.sun.glass.ui.Window.Level#FLOATING},
  73          * {@link com.sun.glass.ui.Window.Level#TOPMOST}.
  74          * @param level Level from {@link com.sun.glass.ui.Window.Level} class
  75          */
  76         public void handleLevelEvent(int level) {
  77         }
  78     }
  79 
  80     // Native object handle (HWND, or NSWindow*, etc.)
  81     private long ptr;
  82 
  83     // &#39;Delegate window&#39; ptr. Used in e.g. the Full Screen mode.
  84     private volatile long delegatePtr = 0L;
  85 
  86     // window list
  87     static private final LinkedList&lt;Window&gt; visibleWindows = new LinkedList&lt;Window&gt;();
  88      // Return a list of all visible windows.  Note that on platforms without a native window manager,
  89      // this list will be sorted in proper z-order
  90     static public synchronized List&lt;Window&gt; getWindows() {
  91         Application.checkEventThread();
  92         return Collections.unmodifiableList(Window.visibleWindows);
  93     }
  94 
  95     static public List&lt;Window&gt; getWindowsClone() {
  96         Application.checkEventThread();
  97         return (List&lt;Window&gt;)visibleWindows.clone();
  98     }
  99 
 100     // used by Lens Native
 101     static protected void add(Window window) {
 102         visibleWindows.add(window);
 103     }
 104 
 105     static protected void addFirst(Window window) {
 106         visibleWindows.addFirst(window);
 107     }
 108 
 109     // used by Lens Native
 110     static protected void remove(Window window) {
 111         visibleWindows.remove(window);
 112     }
 113 
 114     // window style mask
 115 
 116     // visual kind: mutually exclusive
 117     public static final int UNTITLED        = 0;
 118     public static final int TITLED          = 1 &lt;&lt; 0;
 119     public static final int TRANSPARENT     = 1 &lt;&lt; 1;
 120 
 121     // functional type: mutually exclusive
 122     /**
 123      * Normal window.
 124      *
 125      * Usual top-level window.
 126      */
 127     public static final int NORMAL          = 0;
 128     /**
 129      * An utility window.
 130      *
 131      * Often used for floating toolbars. It has smaller than usual decorations
 132      * and doesn&#39;t display a taskbar button.
 133      */
 134     @Native public static final int UTILITY         = 1 &lt;&lt; 2;
 135     /**
 136      * A popup window.
 137      *
 138      * Used to display popups (tooltips, popup menus, etc.) Note that by
 139      * default it may display a task-bar button. To hide it the window must be
 140      * owned.
 141      */
 142     @Native public static final int POPUP           = 1 &lt;&lt; 3;
 143 
 144     // These affect window decorations as well as system menu actions,
 145     // so applicable to both decorated and undecorated windows
 146     @Native public static final int CLOSABLE        = 1 &lt;&lt; 4;
 147     @Native public static final int MINIMIZABLE     = 1 &lt;&lt; 5;
 148     @Native public static final int MAXIMIZABLE     = 1 &lt;&lt; 6;
 149 
 150     /**
 151      * Indicates that the window trim will draw from right to left.
 152      */
 153     @Native public static final int RIGHT_TO_LEFT     = 1 &lt;&lt; 7;
 154 
 155     /**
 156      * Indicates that a window will have a client area textured the same way as the platform decorations
 157      * and will not have a border between decorations and the client area.
 158      * This is supported not on all platforms, the client should check if the feature is supported by using
 159      * {@link com.sun.glass.ui.Application#supportsUnifiedWindows()}
 160      */
 161     @Native public static final int UNIFIED = 1 &lt;&lt; 8;
 162 
 163     /**
 164      * Indicates that the window is modal which affects whether the window is minimizable.
 165      */
 166     @Native public static final int MODAL = 1 &lt;&lt; 9;
 167 
 168     final static public class State {
 169         @Native public static final int NORMAL = 1;
 170         @Native public static final int MINIMIZED = 2;
 171         @Native public static final int MAXIMIZED = 3;
 172     }
 173 
 174     /**
 175      * Available window levels.
 176      *
 177      * Note that on some platforms both {@code FLOATING} and {@code TOPMOST}
 178      * may represent the same window level.
 179      *
 180      * @see #setLevel
 181      */
 182     public static final class Level {
 183         @Native private static final int _MIN = 1;
 184 
 185         /** Normal window level. */
 186         @Native public static final int NORMAL = 1;
 187 
 188         /** A window level that is above all other NORMAL windows. */
 189         @Native public static final int FLOATING = 2;
 190 
 191         /** A very topmost window level. May cover system UI elements such as dock, taskbar, etc. */
 192         @Native public static final int TOPMOST = 3;
 193 
 194         @Native private static final int _MAX = 3;
 195     }
 196 
 197     private final Window owner;
 198     private final long parent;
 199     private final int styleMask;
 200     private final boolean isDecorated;
 201     private boolean shouldStartUndecoratedMove = false;
 202 
 203     protected View view = null;
 204     protected Screen screen = null;
 205     private MenuBar menubar = null;
 206     private String title = &quot;&quot;;
 207     private UndecoratedMoveResizeHelper helper = null;
 208 
 209     private int state = State.NORMAL;
 210     private int level = Level.NORMAL;
 211     protected int x = 0;
 212     protected int y = 0;
 213     protected int width = 0;
 214     protected int height = 0;
 215     private float alpha = 1.0f;
 216     protected float platformScaleX = 1.0f;
 217     protected float platformScaleY = 1.0f;
 218     private float outputScaleX = 1.0f;
 219     private float outputScaleY = 1.0f;
 220     private float renderScaleX = 1.0f;
 221     private float renderScaleY = 1.0f;
 222     private boolean appletMode = false;
 223 
 224     // This is a workaround for RT-15970: as for embedded windows we don&#39;t
 225     // receive any MOVE notifications from the native platform, we poll
 226     // the window location on screen from timer and post synthetic events
 227     // if it has changed
 228     private Timer embeddedLocationTimer = null;
 229     private int lastKnownEmbeddedX = 0;
 230     private int lastKnownEmbeddedY = 0;
 231 
 232     private volatile boolean isResizable = false;
 233     private volatile boolean isVisible = false;
 234     private volatile boolean isFocused = false;
 235     private volatile boolean isFocusable = true;
 236     private volatile boolean isModal = false;
 237 
 238     // Indicates how many times setEnabled(false) has been called.
 239     // A value of 0 means the window is enabled.
 240     private volatile int disableCount = 0;
 241 
 242     private int minimumWidth = 0, minimumHeight = 0;
 243     private int maximumWidth = Integer.MAX_VALUE, maximumHeight = Integer.MAX_VALUE;
 244 
 245     private EventHandler eventHandler;
 246 
 247     protected abstract long _createWindow(long ownerPtr, long screenPtr, int mask);
 248     protected Window(Window owner, Screen screen, int styleMask) {
 249         Application.checkEventThread();
 250         switch (styleMask &amp; (TITLED | TRANSPARENT)) {
 251             case UNTITLED:
 252             case TITLED:
 253             case TRANSPARENT:
 254                 break;
 255             default:
 256                 throw new RuntimeException(&quot;The visual kind should be UNTITLED, TITLED, or TRANSPARENT, but not a combination of these&quot;);
 257         }
 258         switch (styleMask &amp; (POPUP | UTILITY)) {
 259             case NORMAL:
 260             case POPUP:
 261             case UTILITY:
 262                 break;
 263             default:
 264                 throw new RuntimeException(&quot;The functional type should be NORMAL, POPUP, or UTILITY, but not a combination of these&quot;);
 265         }
 266 
 267         if (((styleMask &amp; UNIFIED) != 0)
 268                 &amp;&amp; !Application.GetApplication().supportsUnifiedWindows()) {
 269            styleMask &amp;= ~UNIFIED;
 270         }
 271 
 272         if (((styleMask &amp; TRANSPARENT) != 0)
 273                 &amp;&amp; !Application.GetApplication().supportsTransparentWindows()) {
 274             styleMask &amp;= ~TRANSPARENT;
 275         }
 276 
 277 
 278         this.owner = owner;
 279         this.parent = 0L;
 280         this.styleMask = styleMask;
 281         this.isDecorated = (this.styleMask &amp; Window.TITLED) != 0;
 282 
 283         this.screen = screen != null ? screen : Screen.getMainScreen();
 284         if (PrismSettings.allowHiDPIScaling) {
 285             this.platformScaleX = this.screen.getPlatformScaleX();
 286             this.platformScaleY = this.screen.getPlatformScaleY();
 287             this.outputScaleX = this.screen.getRecommendedOutputScaleX();
 288             this.outputScaleY = this.screen.getRecommendedOutputScaleY();
 289         }
 290 
 291         this.ptr = _createWindow(owner != null ? owner.getNativeHandle() : 0L,
 292                 this.screen.getNativeScreen(), this.styleMask);
 293         if (this.ptr == 0L) {
 294             throw new RuntimeException(&quot;could not create platform window&quot;);
 295         }
 296     }
 297 
 298     protected abstract long _createChildWindow(long parent);
 299     /**
 300      * Constructs a child window of the specified native parent window.
 301      */
 302     protected Window(long parent) {
 303         Application.checkEventThread();
 304         this.owner = null;
 305         this.parent = parent;
 306         this.styleMask = Window.UNTITLED;
 307         this.isDecorated = false;
 308 
 309         // Note: we can&#39;t always catch screen changes when parent is moved...
 310         this.screen = null; // should infer from the parent
 311 
 312         this.ptr = _createChildWindow(parent);
 313         if (this.ptr == 0L) {
 314             throw new RuntimeException(&quot;could not create platform window&quot;);
 315         }
 316 
 317         if (screen == null) {
 318             screen = Screen.getMainScreen(); // start with a default
 319 
 320             if (PrismSettings.allowHiDPIScaling) {
 321                 this.platformScaleX = this.screen.getPlatformScaleX();
 322                 this.platformScaleY = this.screen.getPlatformScaleY();
 323                 this.outputScaleX = this.screen.getRecommendedOutputScaleX();
 324                 this.outputScaleY = this.screen.getRecommendedOutputScaleY();
 325             }
 326         }
 327     }
 328 
 329     public boolean isClosed() {
 330         Application.checkEventThread();
 331         return this.ptr == 0L;
 332     }
 333 
 334     private void checkNotClosed() {
 335         if (this.ptr == 0L) {
 336             throw new IllegalStateException(&quot;The window has already been closed&quot;);
 337         }
 338     }
 339 
 340     protected abstract boolean _close(long ptr);
 341     public void close() {
 342         Application.checkEventThread();
 343         if (this.view != null) {
 344             if (this.ptr != 0L) {
 345                 _setView(this.ptr, null);
 346             }
 347             this.view.setWindow(null);
 348             this.view.close();
 349             this.view = null;
 350         }
 351         if (this.ptr != 0L) {
 352             _close(this.ptr);
 353         }
 354     }
 355 
 356     private boolean isChild() {
 357         Application.checkEventThread();
 358         return this.parent != 0L;
 359     }
 360 
 361     /** This method returns &quot;lowest-level&quot; native window handle
 362      * (HWND on Windows, NSWindow on Mac, X11 Window handle on linux-gtk etc.)
 363      */
 364     public long getNativeWindow() {
 365         Application.checkEventThread();
 366         checkNotClosed();
 367         return this.delegatePtr != 0L ? this.delegatePtr : this.ptr;
 368     }
 369 
 370     /**
 371      * This method returns &quot;higher-level&quot; native window handle.
 372      * glass-mat-lib-gtk GtkWindow.java returns GtkWindow pointer for example.
 373      */
 374     public long getNativeHandle() {
 375         Application.checkEventThread();
 376         return this.delegatePtr != 0L ? this.delegatePtr : this.ptr;
 377     }
 378 
 379     /**
 380      * return the &quot;raw&#39; pointer needed by subclasses to pass to native routines
 381      * @return the native pointer.
 382      */
 383     public long getRawHandle() {
 384         return ptr;
 385     }
 386 
 387     public Window getOwner() {
 388         Application.checkEventThread();
 389         return this.owner;
 390     }
 391 
 392     public View getView() {
 393         Application.checkEventThread();
 394         return this.view;
 395     }
 396 
 397     protected abstract boolean _setView(long ptr, View view);
 398     public void setView(final View view) {
 399         Application.checkEventThread();
 400         checkNotClosed();
 401         View oldView = getView();
 402         if (oldView == view) {
 403             return;
 404         }
 405 
 406         if (oldView != null) {
 407             oldView.setWindow(null);
 408         }
 409         if (view != null) {
 410             Window host = view.getWindow();
 411             if (host != null) {
 412                 host.setView(null);
 413             }
 414         }
 415 
 416         if (view != null &amp;&amp; _setView(this.ptr, view)) {
 417             this.view = view;
 418             this.view.setWindow(this);
 419             if (this.isDecorated == false) {
 420                 this.helper = new UndecoratedMoveResizeHelper();
 421             }
 422         } else {
 423             _setView(this.ptr, null);
 424             this.view = null;
 425         }
 426     }
 427 
 428     public Screen getScreen() {
 429         Application.checkEventThread();
 430         return this.screen;
 431     }
 432 
 433     protected void setScreen(Screen screen) {
 434         Application.checkEventThread();
 435 
 436         final Screen old = this.screen;
 437         this.screen = screen;
 438 
 439         if (this.eventHandler != null) {
 440             if ((old == null &amp;&amp; this.screen != null) ||
 441                 (old != null &amp;&amp; !old.equals(this.screen))) {
 442                 this.eventHandler.handleScreenChangedEvent(this, System.nanoTime(), old, this.screen);
 443             }
 444         }
 445     }
 446 
 447     public int getStyleMask() {
 448         Application.checkEventThread();
 449         return this.styleMask;
 450     }
 451 
 452     public MenuBar getMenuBar() {
 453         Application.checkEventThread();
 454         return this.menubar;
 455     }
 456 
 457     protected abstract boolean _setMenubar(long ptr, long menubarPtr);
 458     public void setMenuBar(final MenuBar menubar) {
 459         Application.checkEventThread();
 460         checkNotClosed();
 461         if (_setMenubar(this.ptr, menubar.getNativeMenu())) {
 462             this.menubar = menubar;
 463         }
 464     }
 465 
 466     public boolean isDecorated() {
 467         Application.checkEventThread();
 468         return this.isDecorated;
 469     }
 470 
 471     public boolean isMinimized() {
 472         Application.checkEventThread();
 473         return (this.state == State.MINIMIZED);
 474     }
 475 
 476     protected abstract boolean _minimize(long ptr, boolean minimize);
 477     public boolean minimize(final boolean minimize) {
 478         Application.checkEventThread();
 479         checkNotClosed();
 480         _minimize(this.ptr, minimize);
 481         //XXX: this is synchronous? On X11 this may not work
 482         return isMinimized();
 483     }
 484 
 485     public boolean isMaximized() {
 486         Application.checkEventThread();
 487         return (this.state == State.MAXIMIZED);
 488     }
 489 
 490     protected abstract boolean _maximize(long ptr, boolean maximize, boolean wasMaximized);
 491     public boolean maximize(final boolean maximize) {
 492         Application.checkEventThread();
 493         checkNotClosed();
 494         _maximize(ptr, maximize, isMaximized());
 495         return isMaximized();
 496     }
 497 
 498     protected void notifyScaleChanged(float platformScaleX, float platformScaleY,
 499                                       float outputScaleX, float outputScaleY)
 500     {
 501         if (!PrismSettings.allowHiDPIScaling) return;
 502         this.platformScaleX = platformScaleX;
 503         this.platformScaleY = platformScaleY;
 504         this.outputScaleX = outputScaleX;
 505         this.outputScaleY = outputScaleY;
 506         notifyRescale();
 507     }
 508 
 509     /**
 510      * Return the horizontal scale used to communicate window locations,
 511      * sizes, and event coordinates to/from the platform.
 512      * @return the horizontal platform scaling for screen locations
 513      */
 514     public final float getPlatformScaleX() {
 515         return platformScaleX;
 516     }
 517 
 518     /**
 519      * Return the vertical scale used to communicate window locations,
 520      * sizes, and event coordinates to/from the platform.
 521      * @return the vertical platform scaling for screen locations
 522      */
 523     public final float getPlatformScaleY() {
 524         return platformScaleY;
 525     }
 526 
 527     public void setRenderScaleX(float renderScaleX) {
 528         if (!PrismSettings.allowHiDPIScaling) return;
 529         this.renderScaleX = renderScaleX;
 530     }
 531 
 532     public void setRenderScaleY(float renderScaleY) {
 533         if (!PrismSettings.allowHiDPIScaling) return;
 534         this.renderScaleY = renderScaleY;
 535     }
 536 
 537     /**
 538      * Return the horizontal scale used for rendering the back buffer.
 539      * @return the horizontal scaling for rendering
 540      */
 541     public final float getRenderScaleX() {
 542         return renderScaleX;
 543     }
 544 
 545     /**
 546      * Return the vertical scale used for rendering to the back buffer.
 547      * @return the vertical scaling for rendering
 548      */
 549     public final float getRenderScaleY() {
 550         return renderScaleY;
 551     }
 552 
 553     public float getOutputScaleX() {
 554         return outputScaleX;
 555     }
 556 
 557     public float getOutputScaleY() {
 558         return outputScaleY;
 559     }
 560 
 561     protected abstract int _getEmbeddedX(long ptr);
 562     protected abstract int _getEmbeddedY(long ptr);
 563 
 564     private void checkScreenLocation() {
 565         this.x = _getEmbeddedX(ptr);
 566         this.y = _getEmbeddedY(ptr);
 567         if ((this.x != lastKnownEmbeddedX) || (this.y != lastKnownEmbeddedY)) {
 568             lastKnownEmbeddedX = this.x;
 569             lastKnownEmbeddedY = this.y;
 570             handleWindowEvent(System.nanoTime(), WindowEvent.MOVE);
 571         }
 572     }
 573 
 574     public int getX() {
 575         Application.checkEventThread();
 576         return this.x;
 577     }
 578 
 579     public int getY() {
 580         Application.checkEventThread();
 581         return this.y;
 582     }
 583 
 584     public int getWidth() {
 585         Application.checkEventThread();
 586         return this.width;
 587     }
 588 
 589     public int getHeight() {
 590         Application.checkEventThread();
 591         return this.height;
 592     }
 593 
 594     protected abstract void _setBounds(long ptr, int x, int y, boolean xSet, boolean ySet,
 595                                        int w, int h, int cw, int ch,
 596                                        float xGravity, float yGravity);
 597 
 598     /**
 599      * Sets the window bounds to the specified values.
 600      *
 601      * Gravity values specify how to correct window location if only its size
 602      * changes (for example when stage decorations are added). User initiated
 603      * resizing should be ignored and must not influence window location through
 604      * this mechanism.
 605      *
 606      * The corresponding correction formulas are:
 607      *
 608      * {@code x -= xGravity * deltaW}
 609      * {@code y -= yGravity * deltaH}
 610      *
 611      * @param x the new window horizontal position, ignored if xSet is set to
 612      *          false
 613      * @param y the new window vertical position, ignored if ySet is set to
 614      *          false
 615      * @param xSet indicates whether the x parameter is valid
 616      * @param ySet indicates whether the y parameter is valid
 617      * @param w the new window width, ignored if set to -1
 618      * @param h the new window height, ignored if set to -1
 619      * @param cw the new window content width, ignored if set to -1
 620      * @param ch the new window content height, ignored if set to -1
 621      * @param xGravity the xGravity coefficient
 622      * @param yGravity the yGravity coefficient
 623      */
 624     public void setBounds(float x, float y, boolean xSet, boolean ySet,
 625                           float w, float h, float cw, float ch,
 626                           float xGravity, float yGravity)
 627     {
 628         Application.checkEventThread();
 629         checkNotClosed();
 630         float pScaleX = platformScaleX;
 631         float pScaleY = platformScaleY;
 632         int px = screen.getPlatformX() + Math.round((x - screen.getX()) * pScaleX);
 633         int py = screen.getPlatformY() + Math.round((y - screen.getY()) * pScaleY);
 634         int pw = (int) (w &gt; 0 ? Math.ceil(w * pScaleX) : w);
 635         int ph = (int) (h &gt; 0 ? Math.ceil(h * pScaleY) : h);
 636         int pcw = (int) (cw &gt; 0 ? Math.ceil(cw * pScaleX) : cw);
 637         int pch = (int) (ch &gt; 0 ? Math.ceil(ch * pScaleY) : ch);
 638         _setBounds(ptr, px, py, xSet, ySet, pw, ph, pcw, pch, xGravity, yGravity);
 639     }
 640 
 641     public void setPosition(int x, int y) {
 642         Application.checkEventThread();
 643         checkNotClosed();
 644         _setBounds(ptr, x, y, true, true, 0, 0, 0, 0, 0, 0);
 645     }
 646 
 647     public void setSize(int w, int h) {
 648         Application.checkEventThread();
 649         checkNotClosed();
 650         _setBounds(ptr, 0, 0, false, false, w, h, 0, 0, 0, 0);
 651     }
 652 
 653     public void setContentSize(int cw, int ch) {
 654         Application.checkEventThread();
 655         checkNotClosed();
 656         _setBounds(ptr, 0, 0, false, false, 0, 0, cw, ch, 0, 0);
 657     }
 658 
 659     public boolean isVisible() {
 660         Application.checkEventThread();
 661         return this.isVisible;
 662     }
 663 
 664     /**
 665      * Generates a ViewEvent.MOVE aka insets (might have) changed.
 666      */
 667     private void synthesizeViewMoveEvent() {
 668         final View view = getView();
 669         if (view != null) {
 670             view.notifyView(com.sun.glass.events.ViewEvent.MOVE);
 671         }
 672     }
 673 
 674     protected abstract boolean _setVisible(long ptr, boolean visible);
 675     public void setVisible(final boolean visible) {
 676         Application.checkEventThread();
 677         if (this.isVisible != visible) {
 678             if (!visible) {
 679                 if (getView() != null) {
 680                     getView().setVisible(visible);
 681                 }
 682                 // Avoid native call if the window has been closed already
 683                 if (this.ptr != 0L) {
 684                     this.isVisible = _setVisible(this.ptr, visible);
 685                 } else {
 686                     this.isVisible = visible;
 687                 }
 688                 remove(this);
 689                 if (parent != 0) {
 690                     embeddedLocationTimer.stop();
 691                 }
 692             } else {
 693                 checkNotClosed();
 694                 this.isVisible = _setVisible(this.ptr, visible);
 695 
 696                 if (getView() != null) {
 697                     getView().setVisible(this.isVisible);
 698                 }
 699                 add(this);
 700                 if (parent != 0) {
 701                     final Runnable checkRunnable = () -&gt; checkScreenLocation();
 702                     final Runnable timerRunnable = () -&gt; Application.invokeLater(checkRunnable);
 703                     embeddedLocationTimer =
 704                            Application.GetApplication().createTimer(timerRunnable);
 705                     embeddedLocationTimer.start(16);
 706                 }
 707 
 708                 synthesizeViewMoveEvent();
 709             }
 710         }
 711     }
 712 
 713     protected abstract boolean _setResizable(long ptr, boolean resizable);
 714     public boolean setResizable(final boolean resizable) {
 715         Application.checkEventThread();
 716         checkNotClosed();
 717         if (this.isResizable != resizable) {
 718             if (_setResizable(this.ptr, resizable)) {
 719                 this.isResizable = resizable;
 720                 synthesizeViewMoveEvent();
 721             }
 722         }
 723         return isResizable;
 724     }
 725 
 726     public boolean isResizable() {
 727         Application.checkEventThread();
 728         return this.isResizable;
 729     }
 730 
 731     public boolean isUnifiedWindow() {
 732         //The UNIFIED flag is set only if it is supported
 733         return (this.styleMask &amp; Window.UNIFIED) != 0;
 734     }
 735 
 736     public boolean isTransparentWindow() {
 737         //The TRANSPARENT flag is set only if it is supported
 738         return (this.styleMask &amp; Window.TRANSPARENT) != 0;
 739     }
 740 
 741     public boolean isFocused() {
 742         Application.checkEventThread();
 743         return this.isFocused;
 744     }
 745 
 746     protected abstract boolean _requestFocus(long ptr, int event);
 747     /**
 748      * Requests or resigns focus on this window.
 749      *
 750      * If this is a top-level window (owned or not), then the only possible
 751      * value for the {@code event} argument is WindowEvent.FOCUS_GAINED.
 752      * Otherwise, if the window is a child window, the argument may be
 753      * WindowEvent.FOCUS_LOST, FOCUS_GAINED, FOCUS_GAINED_FORWARD, or
 754      * FOCUS_GAINED_BACKWARD.
 755      *
 756      * @param event one of WindowEvent.FOCUS_LOST, FOCUS_GAINED, FOCUS_GAINED_FORWARD, FOCUS_GAINED_BACKWARD
 757      *
 758      * @throws IllegalArgumentException if the argument value is invalid for this window
 759      *
 760      * @return {@code true} if the operation succeeded
 761      */
 762     public boolean requestFocus(int event) {
 763         Application.checkEventThread();
 764         checkNotClosed();
 765 
 766         if (!isChild() &amp;&amp; event != WindowEvent.FOCUS_GAINED) {
 767             throw new IllegalArgumentException(&quot;Invalid focus event ID for top-level window&quot;);
 768         }
 769 
 770         if (isChild() &amp;&amp; (event &lt; WindowEvent._FOCUS_MIN || event &gt; WindowEvent._FOCUS_MAX)) {
 771             throw new IllegalArgumentException(&quot;Invalid focus event ID for child window&quot;);
 772         }
 773 
 774         if (event == WindowEvent.FOCUS_LOST &amp;&amp; !isFocused()) {
 775             // Already unfocused, nothing to do
 776             return true;
 777         }
 778 
 779         // At this point either A) the user requests focus for a focused or unfocused window,
 780         // or B) the window is focused and the user requests FOCUS_LOST
 781         if (!this.isFocusable) {
 782             // It&#39;s obviously A). Fail.
 783             return false;
 784         }
 785 
 786         return _requestFocus(this.ptr, event);
 787     }
 788 
 789     public boolean requestFocus() {
 790         Application.checkEventThread();
 791         return requestFocus(WindowEvent.FOCUS_GAINED);
 792     }
 793 
 794     protected abstract void _setFocusable(long ptr, boolean isFocusable);
 795     /**
 796      * Sets whether this window is focusable.
 797      *
 798      * Clicking an unfocusable window doesn&#39;t activate it.
 799      */
 800     public void setFocusable(final boolean isFocusable) {
 801         Application.checkEventThread();
 802         checkNotClosed();
 803         this.isFocusable = isFocusable;
 804         if (isEnabled()) {
 805             _setFocusable(this.ptr, isFocusable);
 806         }
 807     }
 808 
 809     protected abstract boolean _grabFocus(long ptr);
 810     protected abstract void _ungrabFocus(long ptr);
 811     /**
 812      * Grabs focus on this window.
 813      *
 814      * All mouse clicks that occur in this window&#39;s client area or client-areas
 815      * of any of its unfocusable owned windows are delivered as usual. Whenever
 816      * a click occurs on another app&#39;s window (not related via the ownership
 817      * relation with this one, or a focusable owned window), or on non-client
 818      * area of any window (titlebar, etc.), or any third-party app&#39;s window, or
 819      * native OS GUI (e.g. a taskbar), the grab is automatically reset, and the
 820      * window that held the grab receives the FOCUS_UNGRAB event.
 821      *
 822      * Note that for this functionality to work correctly, the window must have
 823      * a focus upon calling this method. All owned popup windows that should be
 824      * operable during the grabbed focus state (e.g. nested popup menus) must
 825      * be unfocusable (see {@link #setFocusable}). Clicking a focusable owned
 826      * window will reset the grab due to a focus transfer.
 827      *
 828      * The click that occurs in another window and causes resetting of the grab
 829      * may or may not be delivered to that other window depending on the native
 830      * OS behavior.
 831      *
 832      * If any of the application&#39;s windows already holds the grab, it is reset
 833      * prior to grabbing the focus for this window. The method may be called
 834      * multiple times for one window. Subsequent calls do not affect the grab
 835      * status unless it is reset between the calls, in which case the focus
 836      * is grabbed again.
 837      *
 838      * Note that grabbing the focus on an application window may prevent
 839      * delivering certain events to other applications until the grab is reset.
 840      * Therefore, if the application has finished showing popup windows based
 841      * on a user action (e.g. clicking a menu item), and doesn&#39;t require the
 842      * grab any more, it should call the {@link #ungrabFocus} method. The
 843      * FOCUS_UNGRAB event signals that the grab has been reset.
 844      *
 845      * A user event handler associated with a menu item must be invoked after
 846      * resetting the grab. Otherwise, if a developer debugs the application and
 847      * has installed a breakpoint in the event handler, the debugger may become
 848      * unoperable due to events blocking for other applications on some
 849      * platforms.
 850      *
 851      * @return {@code true} if the operation is successful
 852      * @throws IllegalStateException if the window isn&#39;t focused currently
 853      */
 854     public boolean grabFocus() {
 855         Application.checkEventThread();
 856         checkNotClosed();
 857 
 858         if (!isFocused()) {
 859             throw new IllegalStateException(&quot;The window must be focused when calling grabFocus()&quot;);
 860         }
 861 
 862         return _grabFocus(this.ptr);
 863     }
 864 
 865     /**
 866      * Manually ungrabs focus grabbed on this window previously.
 867      *
 868      * This method resets the grab, and forces sending of the FOCUS_UNGRAB
 869      * event. It should be used when popup windows (such as menus) should be
 870      * dismissed manually, e.g. when a user clicks a menu item which usually
 871      * causes the menus to hide.
 872      *
 873      * @see #grabFocus
 874      */
 875     public void ungrabFocus() {
 876         Application.checkEventThread();
 877         checkNotClosed();
 878         _ungrabFocus(this.ptr);
 879     }
 880 
 881     public String getTitle() {
 882         Application.checkEventThread();
 883         return this.title;
 884     }
 885 
 886     protected abstract boolean _setTitle(long ptr, String title);
 887     public void setTitle(String title) {
 888         Application.checkEventThread();
 889         checkNotClosed();
 890         if (title == null) {
 891             title = &quot;&quot;;
 892         }
 893         if (!title.equals(this.title)) {
 894             if (_setTitle(this.ptr, title)) {
 895                 this.title = title;
 896             }
 897         }
 898     }
 899 
 900     protected abstract void _setLevel(long ptr, int level);
 901     /**
 902      * Set the level of this window in the z-order.
 903      *
 904      * @param level one of the constants from {@link Window.Level}
 905      * @see Window.Level
 906      */
 907     public void setLevel(final int level) {
 908         Application.checkEventThread();
 909         checkNotClosed();
 910         if (level &lt; Level._MIN || level &gt; Level._MAX) {
 911             throw new IllegalArgumentException(&quot;Level should be in the range [&quot; + Level._MIN + &quot;..&quot; + Level._MAX + &quot;]&quot;);
 912         }
 913         if (this.level != level) {
 914             _setLevel(this.ptr, level);
 915             this.level = level;
 916         }
 917     }
 918 
 919     public int getLevel() {
 920         Application.checkEventThread();
 921         return this.level;
 922     }
 923 
 924     private boolean isInFullscreen() {
 925         final View view = getView();
 926         return view == null ? false : view.isInFullscreen();
 927     }
 928 
 929     // Invoked from the View class before sending FULLSCREEN_ to the View.EventHandler
 930     void notifyFullscreen(boolean entered) {
 931         final float alpha = getAlpha();
 932         if (alpha &lt; 1f) {
 933             if (entered) {
 934                 // Reset alpha at native level
 935                 _setAlpha(this.ptr, 1f);
 936             } else {
 937                 // restore the current opacity level
 938                 setAlpha(alpha);
 939             }
 940         }
 941     }
 942 
 943     protected abstract void _setAlpha(long ptr, float alpha);
 944     /**
 945      * Sets the uniform translucency level for this window.
 946      *
 947      * In the full screen mode the native window is always fully opaque.
 948      * The requested opacity level is applied upon exiting the full screen
 949      * mode only.
 950      *
 951      * @param alpha a value in the range [0..1f] (transparent..fully-opaque)
 952      */
 953     public void setAlpha(final float alpha) {
 954         Application.checkEventThread();
 955         checkNotClosed();
 956         if (alpha &lt; 0f || alpha &gt; 1f) {
 957             throw new IllegalArgumentException(&quot;Alpha should be in the range [0f..1f]&quot;);
 958         }
 959 
 960         this.alpha = alpha;
 961 
 962         if (alpha &lt; 1f &amp;&amp; isInFullscreen()) {
 963             return;
 964         }
 965 
 966         _setAlpha(this.ptr, this.alpha);
 967     }
 968 
 969     public float getAlpha() {
 970         Application.checkEventThread();
 971         return this.alpha;
 972     }
 973 
 974     public boolean getAppletMode() {
 975         return appletMode;
 976     }
 977 
 978     public void setAppletMode(boolean appletMode) {
 979         this.appletMode = appletMode;
 980     }
 981 
 982     protected abstract boolean _setBackground(long ptr, float r, float g, float b);
 983     /**
 984      * Set the background of the window.
 985      *
 986      * In most cases the View covers the whole window, so the background color
 987      * of the window is never seen by the user. However, a window w/o a view
 988      * does display the background color in its content area.
 989      *
 990      * On some platforms setting the background color may produce flickering
 991      * when painting the content area of the View (even though the View covers
 992      * the whole window).  Therefore it is recommended to set the background
 993      * color to windows w/o views only.
 994      */
 995     public boolean setBackground(final float r, final float g, final float b) {
 996         Application.checkEventThread();
 997         checkNotClosed();
 998         return _setBackground(this.ptr, r, g, b);
 999     }
1000 
1001     public boolean isEnabled() {
1002         Application.checkEventThread();
1003         return this.disableCount == 0;
1004     }
1005 
1006     protected abstract void _setEnabled(long ptr, boolean enabled);
1007     /**
1008      * Enables or disables the window.
1009      *
1010      * A disabled window is unfocusable by definition.
1011      * Also, key or mouse events aren&#39;t generated for disabled windows.
1012      *
1013      * When a user tries to activate a disabled window, or the window gets
1014      * accidentally brought to the top of the stacking order, the window
1015      * generates the FOCUS_DISABLED window event. A Glass client should react
1016      * to this event and bring the currently active modal blocker of the
1017      * disabled window to top by calling blocker&#39;s minimize(false), toFront(),
1018      * and requestFocus() methods. It may also &#39;blink&#39; the blocker window to
1019      * further attract user&#39;s attention.
1020      *
1021      * It&#39;s strongly recommended to process the FOCUS_DISABLED event
1022      * synchronously and as fast as possible to avoid any possible visual and
1023      * behavioral artifacts. Note that a disabled window may by no means gain
1024      * the input focus. The purpose of this event is to make sure that the
1025      * current modal blocker window is always visible to the user, and the user
1026      * understands why he can&#39;t interact with a disabled window.
1027      *
1028      * The method supports nested calls. If you disable the window twice
1029      * with two calls to setEnabled(false), you must call setEnabled(true)
1030      * twice as well in order to enable it afterwards. This is to support
1031      * &#39;nested&#39; modal dialogs when one modal dialog opens another one.
1032      */
1033     public void setEnabled(boolean enabled) {
1034         Application.checkEventThread();
1035         checkNotClosed();
1036         if (!enabled) {
1037             if (++this.disableCount &gt; 1) {
1038                 // already disabled
1039                 return;
1040             }
1041         } else {
1042             if (this.disableCount == 0) {
1043                 //should report a warning about an extra enable call ?
1044                 return;
1045             }
1046             if (--this.disableCount &gt; 0) {
1047                 // not yet enabled
1048                 return;
1049             }
1050         }
1051 
1052         //TODO: on Windows _setFocusable(this.ptr, isEnabled() ? this.isFocusable : false);
1053         _setEnabled(this.ptr, isEnabled());
1054     }
1055 
1056     public int getMinimumWidth() {
1057         Application.checkEventThread();
1058         return this.minimumWidth;
1059     }
1060 
1061     public int getMinimumHeight() {
1062         Application.checkEventThread();
1063         return this.minimumHeight;
1064     }
1065 
1066     public int getMaximumWidth() {
1067         Application.checkEventThread();
1068         return this.maximumWidth;
1069     }
1070 
1071     public int getMaximumHeight() {
1072         Application.checkEventThread();
1073         return this.maximumHeight;
1074     }
1075 
1076     protected abstract boolean _setMinimumSize(long ptr, int width, int height);
1077     /**
1078      * Sets the minimum size for this window.
1079      * A value of zero indicates no restriction.
1080      * If the native platform is unable to apply the constraints,
1081      * the values returned by getMinimumWidth()/Height() won&#39;t change.
1082      *
1083      * @throws IllegalArgumentException if width or height &lt; 0
1084      */
1085     public void setMinimumSize(int width, int height) {
1086         Application.checkEventThread();
1087         if (width &lt; 0 || height &lt; 0) {
1088             throw new IllegalArgumentException(&quot;The width and height must be &gt;= 0. Got: width=&quot; + width + &quot;; height=&quot; + height);
1089         }
1090         checkNotClosed();
1091         if (_setMinimumSize(this.ptr, width, height)) {
1092             this.minimumWidth = width;
1093             this.minimumHeight = height;
1094         }
1095     }
1096 
1097     protected abstract boolean _setMaximumSize(long ptr, int width, int height);
1098     /**
1099      * Sets the maximum size for this window.
1100      * A value of {@code Integer.MAX_VALUE} indicates no restriction.
1101      * If the native platform is unable to apply the constraints,
1102      * the values returned by getMaximumWidth()/Height() won&#39;t change.
1103      *
1104      * @throws IllegalArgumentException if width or height &lt; 0
1105      */
1106     public void setMaximumSize(int width, int height) {
1107         Application.checkEventThread();
1108         if (width &lt; 0 || height &lt; 0) {
1109             throw new IllegalArgumentException(&quot;The width and height must be &gt;= 0. Got: width=&quot; + width + &quot;; height=&quot; + height);
1110         }
1111         checkNotClosed();
1112         if (_setMaximumSize(this.ptr,
1113                     // for easier handling in native:
1114                     width == Integer.MAX_VALUE ? -1 : width,
1115                     height == Integer.MAX_VALUE ? -1 : height))
1116         {
1117             this.maximumWidth = width;
1118             this.maximumHeight = height;
1119         }
1120     }
1121 
1122 
1123     protected abstract void _setIcon(long ptr, Pixels pixels);
1124 
1125     // In the future we may want to pass a collection of Pixels, so that
1126     // the native platform could pick up the icon with the best dimensions
1127     public void setIcon(final Pixels pixels) {
1128         Application.checkEventThread();
1129         checkNotClosed();
1130         _setIcon(this.ptr, pixels);
1131     }
1132 
1133     protected abstract void _setCursor(long ptr, Cursor cursor);
1134 
1135     /**
1136      * Sets given cursor as the cursor for this window.
1137      * If the cursor is NONE, it is automatically hidden,
1138      * otherwise it is automatically shown.
1139      * @see Cursor#setVisible(boolean)
1140      */
1141     public void setCursor(Cursor cursor) {
1142         Application.checkEventThread();
1143         _setCursor(this.ptr, cursor);
1144     }
1145 
1146     protected abstract void _toFront(long ptr);
1147     /**
1148      * Bring the window to front in the z-order.
1149      * This method DOES NOT activate the window. To make it active use
1150      * the requestFocus() method right after calling toFront().
1151      */
1152     public void toFront() {
1153         Application.checkEventThread();
1154         checkNotClosed();
1155         _toFront(ptr);
1156     }
1157 
1158     protected abstract void _toBack(long ptr);
1159     /**
1160      * Send the window to the bottom of the stacking order.
1161      * This method may or may not de-focus this window
1162      * depending on the native platform. To make sure some other
1163      * window is activated, call requestFocus() on that other window.
1164      */
1165     public void toBack() {
1166         Application.checkEventThread();
1167         checkNotClosed();
1168         _toBack(this.ptr);
1169     }
1170 
1171     // *****************************************************
1172     // modality (prototype using native platform feature)
1173     // *****************************************************
1174     protected abstract void _enterModal(long ptr);
1175     /**
1176      * Enter modal state blocking everything except our window.
1177      */
1178     public void enterModal() {
1179         checkNotClosed();
1180         if (this.isModal == false) {
1181             this.isModal = true;
1182             _enterModal(this.ptr);
1183         }
1184     }
1185 
1186     protected abstract void _enterModalWithWindow(long dialog, long window);
1187     /**
1188      * Enter modal state only blocking the given window.
1189      * On Mac OS X this is done using a dialog sheet.
1190      */
1191     public void enterModal(final Window window) {
1192         checkNotClosed();
1193         if (this.isModal == false) {
1194             this.isModal = true;
1195             _enterModalWithWindow(this.ptr, window.getNativeHandle());
1196         }
1197     }
1198 
1199     protected abstract void _exitModal(long ptr);
1200     public void exitModal() {
1201         checkNotClosed();
1202         if (this.isModal == true) {
1203             _exitModal(this.ptr);
1204             this.isModal = false;
1205         }
1206     }
1207 
1208     public boolean isModal() {
1209         return this.isModal;
1210     }
1211 
1212     /** Only used on Mac when run inside a plugin */
1213     public void dispatchNpapiEvent(Map eventInfo) {
1214         Application.checkEventThread();
1215         throw new RuntimeException(&quot;This operation is not supported on this platform&quot;);
1216     }
1217 
1218     public EventHandler getEventHandler() {
1219         Application.checkEventThread();
1220         return eventHandler;
1221     }
1222 
1223     public void setEventHandler(EventHandler eventHandler) {
1224         Application.checkEventThread();
1225         this.eventHandler = eventHandler;
1226     }
1227 
1228     /**
1229      * Enables unconditional start of window move operation when
1230      * mouse is dragged in the client area.
1231      */
1232     public void setShouldStartUndecoratedMove(boolean v) {
1233         Application.checkEventThread();
1234         this.shouldStartUndecoratedMove = v;
1235     }
1236 
1237     // *****************************************************
1238     // notification callbacks
1239     // *****************************************************
1240     protected void notifyClose() {
1241         handleWindowEvent(System.nanoTime(), WindowEvent.CLOSE);
1242     }
1243 
1244     protected void notifyDestroy() {
1245         // Mac is known to send multiple WillClose notifications for some reason
1246         if (this.ptr == 0) {
1247             return;
1248         }
1249 
1250         handleWindowEvent(System.nanoTime(), WindowEvent.DESTROY);
1251 
1252         this.ptr = 0;
1253 
1254         // Do this after setting ptr to 0 to avoid a call to _setVisible()
1255         setVisible(false);
1256     }
1257 
1258     protected void notifyMove(final int x, final int y) {
1259         this.x = x;
1260         this.y = y;
1261         handleWindowEvent(System.nanoTime(), WindowEvent.MOVE);
1262     }
1263 
1264     protected void notifyRescale() {
1265         handleWindowEvent(System.nanoTime(), WindowEvent.RESCALE);
1266     }
1267 
1268     protected void notifyMoveToAnotherScreen(Screen newScreen) {
1269         setScreen(newScreen);
1270     }
1271 
1272     protected void setState(int state) {
1273         this.state = state;
1274     }
1275 
1276     /**
1277      * type values:
1278      *   - WindowEvent.RESIZE
1279      *   - WindowEvent.MINIMIZE
1280      *   - WindowEvent.MAXIMIZE
1281      *   - WindowEvent.RESTORE
1282      */
1283     protected void notifyResize(final int type, final int width, final int height) {
1284         if (type == WindowEvent.MINIMIZE) {
1285             this.state = State.MINIMIZED;
1286         } else {
1287             if (type == WindowEvent.MAXIMIZE) {
1288                 this.state = State.MAXIMIZED;
1289             } else { // WindowEvent.RESIZE or WindowEvent.RESTORE
1290                 this.state = State.NORMAL;
1291             }
1292             this.width = width;
1293             this.height = height;
1294 
1295             // update moveRect/resizeRect
1296             if (this.helper != null){
1297                 this.helper.updateRectangles();
1298             }
1299         }
1300         handleWindowEvent(System.nanoTime(), type);
1301 
1302         /*
1303          * Send RESIZE notification as MAXIMIZE and RESTORE change the window size
1304          */
1305         if (type == WindowEvent.MAXIMIZE || type == WindowEvent.RESTORE) {
1306             handleWindowEvent(System.nanoTime(), WindowEvent.RESIZE);
1307         }
1308     }
1309 
1310     protected void notifyFocus(int event) {
1311         final boolean focused = event != WindowEvent.FOCUS_LOST;
1312 
1313         if (this.isFocused != focused) {
1314             this.isFocused = focused;
1315             handleWindowEvent(System.nanoTime(), event);
1316         }
1317     }
1318 
1319     protected void notifyFocusDisabled() {
1320         handleWindowEvent(System.nanoTime(), WindowEvent.FOCUS_DISABLED);
1321     }
1322 
1323     protected void notifyFocusUngrab() {
1324         handleWindowEvent(System.nanoTime(), WindowEvent.FOCUS_UNGRAB);
1325     }
1326 
1327     protected void notifyDelegatePtr(long ptr) {
1328         this.delegatePtr = ptr;
1329     }
1330 
1331     // *****************************************************
1332     // window event handlers
1333     // *****************************************************
1334     protected void handleWindowEvent(long time, int type) {
1335         if (this.eventHandler != null) {
1336             this.eventHandler.handleWindowEvent(this, time, type);
1337         }
1338     }
1339 
1340     // *****************************************************
1341     // programmatical move/resize
1342     // *****************************************************
1343     /** Sets &quot;programmatical move&quot; rectangle.
1344      * The rectangle is measured from top of the View:
1345      * width is View.width, height is size.
1346      *
1347      * throws RuntimeException for decorated window.
1348      */
1349     public void setUndecoratedMoveRectangle(int size) {
1350         Application.checkEventThread();
1351         if (this.isDecorated == true) {
1352             //throw new RuntimeException(&quot;setUndecoratedMoveRectangle is only valid for Undecorated Window&quot;);
1353             System.err.println(&quot;Glass Window.setUndecoratedMoveRectangle is only valid for Undecorated Window. In the future this will be hard error.&quot;);
1354             Thread.dumpStack();
1355             return;
1356         }
1357 
1358         if (this.helper != null) {
1359             this.helper.setMoveRectangle(size);
1360         }
1361     }
1362     /** The method called only for undecorated windows
1363      * x, y: mouse coordinates (in View space).
1364      *
1365      * throws RuntimeException for decorated window.
1366      */
1367     public boolean shouldStartUndecoratedMove(final int x, final int y) {
1368         Application.checkEventThread();
1369         if (this.shouldStartUndecoratedMove == true) {
1370             return true;
1371         }
1372         if (this.isDecorated == true) {
1373             return false;
1374         }
1375 
1376         if (this.helper != null) {
1377             return this.helper.shouldStartMove(x, y);
1378         } else {
1379             return false;
1380         }
1381     }
1382 
1383     /** Sets &quot;programmatical resize&quot; rectangle.
1384      * The rectangle is measured from top of the View:
1385      * width is View.width, height is size.
1386      *
1387      * throws RuntimeException for decorated window.
1388      */
1389     public void setUndecoratedResizeRectangle(int size) {
1390         Application.checkEventThread();
1391         if ((this.isDecorated == true) || (this.isResizable == false)) {
1392             //throw new RuntimeException(&quot;setUndecoratedMoveRectangle is only valid for Undecorated Resizable Window&quot;);
1393             System.err.println(&quot;Glass Window.setUndecoratedResizeRectangle is only valid for Undecorated Resizable Window. In the future this will be hard error.&quot;);
1394             Thread.dumpStack();
1395             return;
1396         }
1397 
1398         if (this.helper != null) {
1399             this.helper.setResizeRectangle(size);
1400         }
1401     }
1402 
1403     /** The method called only for undecorated windows
1404      * x, y: mouse coordinates (in View space).
1405      *
1406      * throws RuntimeException for decorated window.
1407      */
1408     public boolean shouldStartUndecoratedResize(final int x, final int y) {
1409         Application.checkEventThread();
1410         if ((this.isDecorated == true) || (this.isResizable == false)) {
1411             return false;
1412         }
1413 
1414         if (this.helper != null) {
1415             return this.helper.shouldStartResize(x, y);
1416         }  else {
1417             return false;
1418         }
1419     }
1420 
1421     /** Mouse event handler for processing programmatical resize/move
1422      * (for undecorated windows only).
1423      * Must be called by View.
1424      * x &amp; y are View coordinates.
1425      * NOTE: it&#39;s package private!
1426      * @return true if the event is processed by the window,
1427      *         false if it has to be delivered to the app
1428      */
1429     boolean handleMouseEvent(int type, int button, int x, int y, int xAbs, int yAbs) {
1430         if (this.isDecorated == false) {
1431             return this.helper.handleMouseEvent(type, button, x, y, xAbs, yAbs);
1432         }
1433         return false;
1434     }
1435 
1436     @Override
1437     public String toString() {
1438         Application.checkEventThread();
1439         return  &quot;Window:&quot;+&quot;\n&quot;
1440                 + &quot;    ptr: &quot; + getNativeWindow() + &quot;\n&quot;
1441                 + &quot;    screen ptr: &quot; + (screen != null ? screen.getNativeScreen() : &quot;null&quot;) + &quot;\n&quot;
1442                 + &quot;    isDecorated: &quot; + isDecorated() + &quot;\n&quot;
1443                 + &quot;    title: &quot; + getTitle() + &quot;\n&quot;
1444                 + &quot;    visible: &quot; + isVisible() + &quot;\n&quot;
1445                 + &quot;    focused: &quot; + isFocused() + &quot;\n&quot;
1446                 + &quot;    modal: &quot; + isModal() + &quot;\n&quot;
1447                 + &quot;    state: &quot; + state + &quot;\n&quot;
1448                 + &quot;    x: &quot; + getX() + &quot;, y: &quot; + getY() + &quot;, w: &quot; + getWidth() + &quot;, h: &quot; + getHeight() + &quot;\n&quot;
1449                 + &quot;&quot;;
1450     }
1451 
1452     // &quot;programmical&quot; move/resize support for undecorated windows
1453 
1454     static private class TrackingRectangle {
1455         int size = 0;
1456         int x = 0, y = 0, width = 0, height = 0;
1457         boolean contains(final int x, final int y) {
1458             return ((size &gt; 0) &amp;&amp;
1459                     (x &gt;= this.x) &amp;&amp; (x &lt; (this.x + this.width)) &amp;&amp;
1460                         (y &gt;= this.y) &amp;&amp; (y &lt; (this.y + this.height)));
1461         }
1462     }
1463 
1464     protected void notifyLevelChanged(int level) {
1465         this.level = level;
1466         if (this.eventHandler != null) {
1467             this.eventHandler.handleLevelEvent(level);
1468         }
1469     }
1470 
1471     private class UndecoratedMoveResizeHelper {
1472         TrackingRectangle moveRect = null;
1473         TrackingRectangle resizeRect = null;
1474 
1475         boolean inMove = false;         // we are in &quot;move&quot; mode
1476         boolean inResize = false;       // we are in &quot;resize&quot; mode
1477 
1478         int startMouseX, startMouseY;   // start mouse coords
1479         int startX, startY;             // start window location (for move)
1480         int startWidth, startHeight;    // start window size (for resize)
1481 
1482         UndecoratedMoveResizeHelper() {
1483             this.moveRect = new TrackingRectangle();
1484             this.resizeRect = new TrackingRectangle();
1485         }
1486 
1487         void setMoveRectangle(final int size) {
1488             this.moveRect.size = size;
1489 
1490             this.moveRect.x = 0;
1491             this.moveRect.y = 0;
1492             this.moveRect.width = getWidth();
1493             this.moveRect.height = this.moveRect.size;
1494         }
1495 
1496         boolean shouldStartMove(final int x, final int y) {
1497             return this.moveRect.contains(x, y);
1498         }
1499 
1500         boolean inMove() {
1501             return this.inMove;
1502         }
1503 
1504         void startMove(final int x, final int y) {
1505             this.inMove = true;
1506 
1507             this.startMouseX = x;
1508             this.startMouseY = y;
1509 
1510             this.startX = getX();
1511             this.startY = getY();
1512         }
1513 
1514         void deltaMove(final int x, final int y) {
1515             int deltaX = x - this.startMouseX;
1516             int deltaY = y - this.startMouseY;
1517 
1518             setPosition(this.startX + deltaX, this.startY + deltaY);
1519         }
1520 
1521         void stopMove() {
1522             this.inMove = false;
1523         }
1524 
1525         void setResizeRectangle(final int size) {
1526             this.resizeRect.size = size;
1527 
1528             // set the rect (bottom right corner of the Window)
1529             this.resizeRect.x = getWidth() - this.resizeRect.size;
1530             this.resizeRect.y = getHeight() - this.resizeRect.size;
1531             this.resizeRect.width = this.resizeRect.size;
1532             this.resizeRect.height = this.resizeRect.size;
1533         }
1534 
1535         boolean shouldStartResize(final int x, final int y) {
1536             return this.resizeRect.contains(x, y);
1537         }
1538 
1539         boolean inResize() {
1540             return this.inResize;
1541         }
1542 
1543         void startResize(final int x, final int y) {
1544             this.inResize = true;
1545 
1546             this.startMouseX = x;
1547             this.startMouseY = y;
1548 
1549             this.startWidth = getWidth();
1550             this.startHeight = getHeight();
1551         }
1552 
1553         void deltaResize(final int x, final int y) {
1554             int deltaX = x - this.startMouseX;
1555             int deltaY = y - this.startMouseY;
1556 
1557             setSize(this.startWidth + deltaX, this.startHeight + deltaY);
1558         }
1559 
1560         protected void stopResize() {
1561             this.inResize = false;
1562         }
1563 
1564         void updateRectangles() {
1565             if (this.moveRect.size &gt; 0) {
1566                 setMoveRectangle(this.moveRect.size);
1567             }
1568             if (this.resizeRect.size &gt; 0) {
1569                 setResizeRectangle(this.resizeRect.size);
1570             }
1571         }
1572 
1573         boolean handleMouseEvent(final int type, final int button, final int x, final int y, final int xAbs, final int yAbs) {
1574             switch (type) {
1575                 case MouseEvent.DOWN:
1576                     if (button == MouseEvent.BUTTON_LEFT) {
1577                         if (shouldStartUndecoratedMove(x, y) == true) {
1578                             startMove(xAbs, yAbs);
1579                             return true;
1580                         } else if (shouldStartUndecoratedResize(x, y) == true) {
1581                             startResize(xAbs, yAbs);
1582                             return true;
1583                         }
1584                     }
1585                     break;
1586 
1587                 case MouseEvent.MOVE:
1588                 case MouseEvent.DRAG:
1589                     if (inMove() == true) {
1590                         deltaMove(xAbs, yAbs);
1591                         return true;
1592                     } else if (inResize() == true) {
1593                         deltaResize(xAbs, yAbs);
1594                         return true;
1595                     }
1596                     break;
1597 
1598                 case MouseEvent.UP:
1599                     boolean wasProcessed = inMove() || inResize();
1600                     stopResize();
1601                     stopMove();
1602                     return wasProcessed;
1603             }
1604             return false;
1605         }
1606     }
1607 
1608     /**
1609      * Requests text input in form of native keyboard for text component
1610      * contained by this Window. Native text input component is drawn on the place
1611      * of JavaFX component to cover it completely and to provide native text editing
1612      * techniques. Any change of text is immediately reflected in JavaFX text component.
1613      *
1614      * @param text text to be shown in the native text input component
1615      * @param type type of text input component @see com.sun.javafx.scene.control.behavior.TextInputTypes
1616      * @param width width of JavaFX text input component
1617      * @param height height of JavaFX text input component
1618      * @param M standard transformation matrix for drawing the native text component derived from JavaFX component
1619      */
1620     public void requestInput(String text, int type, double width, double height,
1621                                 double Mxx, double Mxy, double Mxz, double Mxt,
1622                                 double Myx, double Myy, double Myz, double Myt,
1623                                 double Mzx, double Mzy, double Mzz, double Mzt) {
1624         Application.checkEventThread();
1625         _requestInput(this.ptr, text, type, width, height,
1626                         Mxx, Mxy, Mxz, Mxt,
1627                         Myx, Myy, Myz, Myt,
1628                         Mzx, Mzy, Mzz, Mzt);
1629     }
1630 
1631     /**
1632      * Native keyboard for text input is no longer necessary.
1633      * Keyboard will be hidden and native text input component too.
1634      */
1635     public void releaseInput() {
1636         Application.checkEventThread();
1637         _releaseInput(this.ptr);
1638     }
1639 
1640     protected abstract void _requestInput(long ptr, String text, int type, double width, double height,
1641                                             double Mxx, double Mxy, double Mxz, double Mxt,
1642                                             double Myx, double Myy, double Myz, double Myt,
1643                                             double Mzx, double Mzy, double Mzz, double Mzt);
1644 
1645     protected abstract void _releaseInput(long ptr);
1646 
1647 }
    </pre>
  </body>
</html>