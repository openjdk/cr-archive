<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/com/sun/glass/ui/Window.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package com.sun.glass.ui;
  26 
  27 import com.sun.glass.events.MouseEvent;
  28 import com.sun.glass.events.WindowEvent;
  29 import com.sun.prism.impl.PrismSettings;
  30 
  31 import java.lang.annotation.Native;
  32 
  33 import java.util.Collections;
  34 import java.util.LinkedList;
  35 import java.util.List;
  36 import java.util.Map;
  37 
  38 public abstract class Window {
  39 
  40     public static class EventHandler {
  41         public void handleWindowEvent(Window window, long time, int type) {
  42         }
  43 
  44         /**
  45          * Notifies a listener that the screen object for this Window instance
  46          * has been updated.
  47          *
  48          * Note that while the old and new screen objects may be different,
  49          * they can still represent the same physical screen. This can happen
  50          * if e.g. only a certain parameter of the screen has been updated such
  51          * as its scale factor.
  52          *
  53          * On some platforms when a window is moved to another physical screen
  54          * an app can receive this event twice. One representing the physical
  55          * screen change, and another - the display&#39;s parameters change. Note
  56          * that sending two events instead of just one is platform-specific.
  57          *
  58          * The event handler can use the {@link Screen#getNativeScreen} method
  59          * to determine if this is the same physical screen or not. If the
  60          * native system always creates new native screen instances, there&#39;s no
  61          * way for the app to distinguish between a real move to another screen
  62          * or jsut a parameters update event. Since this is a somewhat rare
  63          * event, an app is advised to always process it the same way.
  64          *
  65          * @see Window#getScreen
  66          */
  67         public void handleScreenChangedEvent(Window window, long time, Screen oldScreen, Screen newScreen) {
  68         }
  69 
  70         /**
  71          * Notifies the listener that the window level has changed. The Level should be one of
  72          * {@link com.sun.glass.ui.Window.Level#NORMAL}, {@link com.sun.glass.ui.Window.Level#FLOATING},
  73          * {@link com.sun.glass.ui.Window.Level#TOPMOST}.
  74          * @param level Level from {@link com.sun.glass.ui.Window.Level} class
  75          */
  76         public void handleLevelEvent(int level) {
  77         }
  78     }
  79 
  80     // Native object handle (HWND, or NSWindow*, etc.)
  81     private long ptr;
  82 
  83     // &#39;Delegate window&#39; ptr. Used in e.g. the Full Screen mode.
  84     private volatile long delegatePtr = 0L;
  85 
  86     // window list
  87     static private final LinkedList&lt;Window&gt; visibleWindows = new LinkedList&lt;Window&gt;();
  88      // Return a list of all visible windows.  Note that on platforms without a native window manager,
  89      // this list will be sorted in proper z-order
  90     static public synchronized List&lt;Window&gt; getWindows() {
  91         Application.checkEventThread();
  92         return Collections.unmodifiableList(Window.visibleWindows);
  93     }
  94 
  95     static public List&lt;Window&gt; getWindowsClone() {
  96         Application.checkEventThread();
  97         return (List&lt;Window&gt;)visibleWindows.clone();
  98     }
  99 
 100     // used by Lens Native
 101     static protected void add(Window window) {
 102         visibleWindows.add(window);
 103     }
 104 
 105     static protected void addFirst(Window window) {
 106         visibleWindows.addFirst(window);
 107     }
 108 
 109     // used by Lens Native
 110     static protected void remove(Window window) {
 111         visibleWindows.remove(window);
 112     }
 113 
 114     // window style mask
 115 
 116     // visual kind: mutually exclusive
 117     public static final int UNTITLED        = 0;
 118     public static final int TITLED          = 1 &lt;&lt; 0;
 119     public static final int TRANSPARENT     = 1 &lt;&lt; 1;
 120 
 121     // functional type: mutually exclusive
 122     /**
 123      * Normal window.
 124      *
 125      * Usual top-level window.
 126      */
 127     public static final int NORMAL          = 0;
 128     /**
 129      * An utility window.
 130      *
 131      * Often used for floating toolbars. It has smaller than usual decorations
 132      * and doesn&#39;t display a taskbar button.
 133      */
 134     @Native public static final int UTILITY         = 1 &lt;&lt; 2;
 135     /**
 136      * A popup window.
 137      *
 138      * Used to display popups (tooltips, popup menus, etc.) Note that by
 139      * default it may display a task-bar button. To hide it the window must be
 140      * owned.
 141      */
 142     @Native public static final int POPUP           = 1 &lt;&lt; 3;
 143 
 144     // These affect window decorations as well as system menu actions,
 145     // so applicable to both decorated and undecorated windows
 146     @Native public static final int CLOSABLE        = 1 &lt;&lt; 4;
 147     @Native public static final int MINIMIZABLE     = 1 &lt;&lt; 5;
 148     @Native public static final int MAXIMIZABLE     = 1 &lt;&lt; 6;
 149 
 150     /**
 151      * Indicates that the window trim will draw from right to left.
 152      */
 153     @Native public static final int RIGHT_TO_LEFT     = 1 &lt;&lt; 7;
 154 
 155     /**
 156      * Indicates that a window will have a client area textured the same way as the platform decorations
 157      * and will not have a border between decorations and the client area.
 158      * This is supported not on all platforms, the client should check if the feature is supported by using
 159      * {@link com.sun.glass.ui.Application#supportsUnifiedWindows()}
 160      */
 161     @Native public static final int UNIFIED = 1 &lt;&lt; 8;
 162 
 163     /**
 164      * Indicates that the window is modal which affects whether the window is minimizable.
 165      */
 166     @Native public static final int MODAL = 1 &lt;&lt; 9;
 167 
 168     final static public class State {
 169         @Native public static final int NORMAL = 1;
 170         @Native public static final int MINIMIZED = 2;
 171         @Native public static final int MAXIMIZED = 3;
 172     }
 173 
 174     /**
 175      * Available window levels.
 176      *
 177      * Note that on some platforms both {@code FLOATING} and {@code TOPMOST}
 178      * may represent the same window level.
 179      *
 180      * @see #setLevel
 181      */
 182     public static final class Level {
 183         @Native private static final int _MIN = 1;
 184 
 185         /** Normal window level. */
 186         @Native public static final int NORMAL = 1;
 187 
 188         /** A window level that is above all other NORMAL windows. */
 189         @Native public static final int FLOATING = 2;
 190 
 191         /** A very topmost window level. May cover system UI elements such as dock, taskbar, etc. */
 192         @Native public static final int TOPMOST = 3;
 193 
 194         @Native private static final int _MAX = 3;
 195     }
 196 
 197     private final Window owner;
 198     private final long parent;
 199     private final int styleMask;
 200     private final boolean isDecorated;
 201     private boolean shouldStartUndecoratedMove = false;
 202 
 203     protected View view = null;
 204     protected Screen screen = null;
 205     private MenuBar menubar = null;
 206     private String title = &quot;&quot;;
 207     private UndecoratedMoveResizeHelper helper = null;
 208 
 209     private int state = State.NORMAL;
 210     private int level = Level.NORMAL;
 211     protected int x = 0;
 212     protected int y = 0;
 213     protected int width = 0;
 214     protected int height = 0;
 215     private float alpha = 1.0f;
 216     protected float platformScaleX = 1.0f;
 217     protected float platformScaleY = 1.0f;
 218     private float outputScaleX = 1.0f;
 219     private float outputScaleY = 1.0f;
 220     private float renderScaleX = 1.0f;
 221     private float renderScaleY = 1.0f;
 222     private boolean appletMode = false;
 223 
 224     // This is a workaround for RT-15970: as for embedded windows we don&#39;t
 225     // receive any MOVE notifications from the native platform, we poll
 226     // the window location on screen from timer and post synthetic events
 227     // if it has changed
 228     private Timer embeddedLocationTimer = null;
 229     private int lastKnownEmbeddedX = 0;
 230     private int lastKnownEmbeddedY = 0;
 231 
 232     private volatile boolean isResizable = false;
 233     private volatile boolean isVisible = false;
 234     private volatile boolean isFocused = false;
 235     private volatile boolean isFocusable = true;
 236     private volatile boolean isModal = false;
 237 
 238     // Indicates how many times setEnabled(false) has been called.
 239     // A value of 0 means the window is enabled.
 240     private volatile int disableCount = 0;
 241 
 242     private int minimumWidth = 0, minimumHeight = 0;
 243     private int maximumWidth = Integer.MAX_VALUE, maximumHeight = Integer.MAX_VALUE;
 244 
 245     private EventHandler eventHandler;
 246 
 247     protected abstract long _createWindow(long ownerPtr, long screenPtr, int mask);
 248     protected Window(Window owner, Screen screen, int styleMask) {
 249         Application.checkEventThread();
 250         switch (styleMask &amp; (TITLED | TRANSPARENT)) {
 251             case UNTITLED:
 252             case TITLED:
 253             case TRANSPARENT:
 254                 break;
 255             default:
 256                 throw new RuntimeException(&quot;The visual kind should be UNTITLED, TITLED, or TRANSPARENT, but not a combination of these&quot;);
 257         }
 258         switch (styleMask &amp; (POPUP | UTILITY)) {
 259             case NORMAL:
 260             case POPUP:
 261             case UTILITY:
 262                 break;
 263             default:
 264                 throw new RuntimeException(&quot;The functional type should be NORMAL, POPUP, or UTILITY, but not a combination of these&quot;);
 265         }
 266 
 267         if (((styleMask &amp; UNIFIED) != 0)
 268                 &amp;&amp; !Application.GetApplication().supportsUnifiedWindows()) {
 269            styleMask &amp;= ~UNIFIED;
 270         }
 271 
 272         if (((styleMask &amp; TRANSPARENT) != 0)
 273                 &amp;&amp; !Application.GetApplication().supportsTransparentWindows()) {
 274             styleMask &amp;= ~TRANSPARENT;
 275         }
 276 
 277 
 278         this.owner = owner;
 279         this.parent = 0L;
 280         this.styleMask = styleMask;
 281         this.isDecorated = (this.styleMask &amp; Window.TITLED) != 0;
 282 
 283         this.screen = screen != null ? screen : Screen.getMainScreen();
 284         if (PrismSettings.allowHiDPIScaling) {
 285             this.platformScaleX = this.screen.getPlatformScaleX();
 286             this.platformScaleY = this.screen.getPlatformScaleY();
 287             this.outputScaleX = this.screen.getRecommendedOutputScaleX();
 288             this.outputScaleY = this.screen.getRecommendedOutputScaleY();
 289         }
 290 
 291         this.ptr = _createWindow(owner != null ? owner.getNativeHandle() : 0L,
 292                 this.screen.getNativeScreen(), this.styleMask);
 293         if (this.ptr == 0L) {
 294             throw new RuntimeException(&quot;could not create platform window&quot;);
 295         }
 296     }
 297 
 298     protected abstract long _createChildWindow(long parent);
 299     /**
 300      * Constructs a child window of the specified native parent window.
 301      */
 302     protected Window(long parent) {
 303         Application.checkEventThread();
 304         this.owner = null;
 305         this.parent = parent;
 306         this.styleMask = Window.UNTITLED;
 307         this.isDecorated = false;
 308 
 309         // Note: we can&#39;t always catch screen changes when parent is moved...
 310         this.screen = null; // should infer from the parent
 311 
 312         this.ptr = _createChildWindow(parent);
 313         if (this.ptr == 0L) {
 314             throw new RuntimeException(&quot;could not create platform window&quot;);
 315         }
 316 
 317         if (screen == null) {
 318             screen = Screen.getMainScreen(); // start with a default
 319 
 320             if (PrismSettings.allowHiDPIScaling) {
 321                 this.platformScaleX = this.screen.getPlatformScaleX();
 322                 this.platformScaleY = this.screen.getPlatformScaleY();
 323                 this.outputScaleX = this.screen.getRecommendedOutputScaleX();
 324                 this.outputScaleY = this.screen.getRecommendedOutputScaleY();
 325             }
 326         }
 327     }
 328 
 329     public boolean isClosed() {
 330         Application.checkEventThread();
 331         return this.ptr == 0L;
 332     }
 333 
 334     private void checkNotClosed() {
 335         if (this.ptr == 0L) {
 336             throw new IllegalStateException(&quot;The window has already been closed&quot;);
 337         }
 338     }
 339 
 340     protected abstract boolean _close(long ptr);
 341     public void close() {
 342         Application.checkEventThread();
 343         if (this.view != null) {
 344             if (this.ptr != 0L) {
 345                 _setView(this.ptr, null);
 346             }
 347             this.view.setWindow(null);
 348             this.view.close();
 349             this.view = null;
 350         }
 351         if (this.ptr != 0L) {
 352             _close(this.ptr);
 353         }
 354     }
 355 
 356     private boolean isChild() {
 357         Application.checkEventThread();
 358         return this.parent != 0L;
 359     }
 360 
 361     /** This method returns &quot;lowest-level&quot; native window handle
 362      * (HWND on Windows, NSWindow on Mac, X11 Window handle on linux-gtk etc.)
 363      */
 364     public long getNativeWindow() {
 365         Application.checkEventThread();
 366         checkNotClosed();
 367         return this.delegatePtr != 0L ? this.delegatePtr : this.ptr;
 368     }
 369 
 370     /**
 371      * This method returns &quot;higher-level&quot; native window handle.
 372      * glass-mat-lib-gtk GtkWindow.java returns GtkWindow pointer for example.
 373      */
 374     public long getNativeHandle() {
 375         Application.checkEventThread();
 376         return this.delegatePtr != 0L ? this.delegatePtr : this.ptr;
 377     }
 378 
 379     /**
 380      * return the &quot;raw&#39; pointer needed by subclasses to pass to native routines
 381      * @return the native pointer.
 382      */
 383     public long getRawHandle() {
 384         return ptr;
 385     }
 386 
 387     public Window getOwner() {
 388         Application.checkEventThread();
 389         return this.owner;
 390     }
 391 
 392     public View getView() {
 393         Application.checkEventThread();
 394         return this.view;
 395     }
 396 
 397     protected abstract boolean _setView(long ptr, View view);
 398     public void setView(final View view) {
 399         Application.checkEventThread();
 400         checkNotClosed();
 401         View oldView = getView();
 402         if (oldView == view) {
 403             return;
 404         }
 405 
 406         if (oldView != null) {
 407             oldView.setWindow(null);
 408         }
 409         if (view != null) {
 410             Window host = view.getWindow();
 411             if (host != null) {
 412                 host.setView(null);
 413             }
 414         }
 415 
 416         if (view != null &amp;&amp; _setView(this.ptr, view)) {
 417             this.view = view;
 418             this.view.setWindow(this);
 419             if (this.isDecorated == false) {
 420                 this.helper = new UndecoratedMoveResizeHelper();
 421             }
 422         } else {
 423             _setView(this.ptr, null);
 424             this.view = null;
 425         }
 426     }
 427 
 428     public Screen getScreen() {
 429         Application.checkEventThread();
 430         return this.screen;
 431     }
 432 
 433     protected void setScreen(Screen screen) {
 434         Application.checkEventThread();
 435 
 436         final Screen old = this.screen;
 437         this.screen = screen;
 438 
 439         if (this.eventHandler != null) {
 440             if ((old == null &amp;&amp; this.screen != null) ||
 441                 (old != null &amp;&amp; !old.equals(this.screen))) {
 442                 this.eventHandler.handleScreenChangedEvent(this, System.nanoTime(), old, this.screen);
 443             }
 444         }
 445     }
 446 
 447     public int getStyleMask() {
 448         Application.checkEventThread();
 449         return this.styleMask;
 450     }
 451 
 452     public MenuBar getMenuBar() {
 453         Application.checkEventThread();
 454         return this.menubar;
 455     }
 456 
 457     protected abstract boolean _setMenubar(long ptr, long menubarPtr);
 458     public void setMenuBar(final MenuBar menubar) {
 459         Application.checkEventThread();
 460         checkNotClosed();
 461         if (_setMenubar(this.ptr, menubar.getNativeMenu())) {
 462             this.menubar = menubar;
 463         }
 464     }
 465 
 466     public boolean isDecorated() {
 467         Application.checkEventThread();
 468         return this.isDecorated;
 469     }
 470 
 471     public boolean isMinimized() {
 472         Application.checkEventThread();
 473         return (this.state == State.MINIMIZED);
 474     }
 475 
 476     protected abstract boolean _minimize(long ptr, boolean minimize);
 477     public boolean minimize(final boolean minimize) {
 478         Application.checkEventThread();
 479         checkNotClosed();
 480         _minimize(this.ptr, minimize);
 481         //XXX: this is synchronous? On X11 this may not work
 482         return isMinimized();
 483     }
 484 
 485     public boolean isMaximized() {
 486         Application.checkEventThread();
 487         return (this.state == State.MAXIMIZED);
 488     }
 489 
 490     protected abstract boolean _maximize(long ptr, boolean maximize, boolean wasMaximized);
 491     public boolean maximize(final boolean maximize) {
 492         Application.checkEventThread();
 493         checkNotClosed();
 494         _maximize(ptr, maximize, isMaximized());
 495         return isMaximized();
 496     }
 497 
 498     protected void notifyScaleChanged(float platformScaleX, float platformScaleY,
 499                                       float outputScaleX, float outputScaleY)
 500     {
 501         if (!PrismSettings.allowHiDPIScaling) return;
 502         this.platformScaleX = platformScaleX;
 503         this.platformScaleY = platformScaleY;
 504         this.outputScaleX = outputScaleX;
 505         this.outputScaleY = outputScaleY;
 506         notifyRescale();
 507     }
 508 
 509     /**
 510      * Return the horizontal scale used to communicate window locations,
 511      * sizes, and event coordinates to/from the platform.
 512      * @return the horizontal platform scaling for screen locations
 513      */
 514     public final float getPlatformScaleX() {
 515         return platformScaleX;
 516     }
 517 
 518     /**
 519      * Return the vertical scale used to communicate window locations,
 520      * sizes, and event coordinates to/from the platform.
 521      * @return the vertical platform scaling for screen locations
 522      */
 523     public final float getPlatformScaleY() {
 524         return platformScaleY;
 525     }
 526 
 527     public void setRenderScaleX(float renderScaleX) {
 528         if (!PrismSettings.allowHiDPIScaling) return;
 529         this.renderScaleX = renderScaleX;
 530     }
 531 
 532     public void setRenderScaleY(float renderScaleY) {
 533         if (!PrismSettings.allowHiDPIScaling) return;
 534         this.renderScaleY = renderScaleY;
 535     }
 536 
 537     /**
 538      * Return the horizontal scale used for rendering the back buffer.
 539      * @return the horizontal scaling for rendering
 540      */
 541     public final float getRenderScaleX() {
 542         return renderScaleX;
 543     }
 544 
 545     /**
 546      * Return the vertical scale used for rendering to the back buffer.
 547      * @return the vertical scaling for rendering
 548      */
 549     public final float getRenderScaleY() {
 550         return renderScaleY;
 551     }
 552 
 553     public float getOutputScaleX() {
 554         return outputScaleX;
 555     }
 556 
 557     public float getOutputScaleY() {
 558         return outputScaleY;
 559     }
 560 
 561     protected abstract int _getEmbeddedX(long ptr);
 562     protected abstract int _getEmbeddedY(long ptr);
 563 
 564     private void checkScreenLocation() {
 565         this.x = _getEmbeddedX(ptr);
 566         this.y = _getEmbeddedY(ptr);
 567         if ((this.x != lastKnownEmbeddedX) || (this.y != lastKnownEmbeddedY)) {
 568             lastKnownEmbeddedX = this.x;
 569             lastKnownEmbeddedY = this.y;
 570             handleWindowEvent(System.nanoTime(), WindowEvent.MOVE);
 571         }
 572     }
 573 
 574     public int getX() {
 575         Application.checkEventThread();
 576         return this.x;
 577     }
 578 
 579     public int getY() {
 580         Application.checkEventThread();
 581         return this.y;
 582     }
 583 
 584     public int getWidth() {
 585         Application.checkEventThread();
 586         return this.width;
 587     }
 588 
 589     public int getHeight() {
 590         Application.checkEventThread();
 591         return this.height;
 592     }
 593 
 594     protected abstract void _setBounds(long ptr, int x, int y, boolean xSet, boolean ySet,
 595                                        int w, int h, int cw, int ch,
 596                                        float xGravity, float yGravity);
 597 
 598     /**
 599      * Sets the window bounds to the specified values.
 600      *
 601      * Gravity values specify how to correct window location if only its size
 602      * changes (for example when stage decorations are added). User initiated
 603      * resizing should be ignored and must not influence window location through
 604      * this mechanism.
 605      *
 606      * The corresponding correction formulas are:
 607      *
 608      * {@code x -= xGravity * deltaW}
 609      * {@code y -= yGravity * deltaH}
 610      *
 611      * @param x the new window horizontal position, ignored if xSet is set to
 612      *          false
 613      * @param y the new window vertical position, ignored if ySet is set to
 614      *          false
 615      * @param xSet indicates whether the x parameter is valid
 616      * @param ySet indicates whether the y parameter is valid
 617      * @param w the new window width, ignored if set to -1
 618      * @param h the new window height, ignored if set to -1
 619      * @param cw the new window content width, ignored if set to -1
 620      * @param ch the new window content height, ignored if set to -1
 621      * @param xGravity the xGravity coefficient
 622      * @param yGravity the yGravity coefficient
 623      */
 624     public void setBounds(float x, float y, boolean xSet, boolean ySet,
 625                           float w, float h, float cw, float ch,
 626                           float xGravity, float yGravity)
 627     {
 628         Application.checkEventThread();
 629         checkNotClosed();
 630         float pScaleX = platformScaleX;
 631         float pScaleY = platformScaleY;
 632         int px = screen.getPlatformX() + Math.round((x - screen.getX()) * pScaleX);
 633         int py = screen.getPlatformY() + Math.round((y - screen.getY()) * pScaleY);
 634         int pw = (int) (w &gt; 0 ? Math.ceil(w * pScaleX) : w);
 635         int ph = (int) (h &gt; 0 ? Math.ceil(h * pScaleY) : h);
 636         int pcw = (int) (cw &gt; 0 ? Math.ceil(cw * pScaleX) : cw);
 637         int pch = (int) (ch &gt; 0 ? Math.ceil(ch * pScaleY) : ch);
 638         _setBounds(ptr, px, py, xSet, ySet, pw, ph, pcw, pch, xGravity, yGravity);
 639     }
 640 
 641     public void setPosition(int x, int y) {
 642         Application.checkEventThread();
 643         checkNotClosed();
 644         _setBounds(ptr, x, y, true, true, 0, 0, 0, 0, 0, 0);
 645     }
 646 
 647     public void setSize(int w, int h) {
 648         Application.checkEventThread();
 649         checkNotClosed();
 650         _setBounds(ptr, 0, 0, false, false, w, h, 0, 0, 0, 0);
 651     }
 652 
 653     public void setContentSize(int cw, int ch) {
 654         Application.checkEventThread();
 655         checkNotClosed();
 656         _setBounds(ptr, 0, 0, false, false, 0, 0, cw, ch, 0, 0);
 657     }
 658 
 659     public boolean isVisible() {
 660         Application.checkEventThread();
 661         return this.isVisible;
 662     }
 663 
 664     /**
 665      * Generates a ViewEvent.MOVE aka insets (might have) changed.
 666      */
 667     private void synthesizeViewMoveEvent() {
 668         final View view = getView();
 669         if (view != null) {
 670             view.notifyView(com.sun.glass.events.ViewEvent.MOVE);
 671         }
 672     }
 673 
 674     protected abstract boolean _setVisible(long ptr, boolean visible);
 675     public void setVisible(final boolean visible) {
 676         Application.checkEventThread();
 677         if (this.isVisible != visible) {
 678             if (!visible) {
 679                 if (getView() != null) {
 680                     getView().setVisible(visible);
 681                 }
 682                 // Avoid native call if the window has been closed already
 683                 if (this.ptr != 0L) {
 684                     this.isVisible = _setVisible(this.ptr, visible);
 685                 } else {
 686                     this.isVisible = visible;
 687                 }
 688                 remove(this);
 689                 if (parent != 0) {
 690                     embeddedLocationTimer.stop();
 691                 }
 692             } else {
 693                 checkNotClosed();
 694                 this.isVisible = _setVisible(this.ptr, visible);
 695 
 696                 if (getView() != null) {
 697                     getView().setVisible(this.isVisible);
 698                 }
 699                 add(this);
 700                 if (parent != 0) {
 701                     final Runnable checkRunnable = () -&gt; checkScreenLocation();
 702                     final Runnable timerRunnable = () -&gt; Application.invokeLater(checkRunnable);
 703                     embeddedLocationTimer =
 704                            Application.GetApplication().createTimer(timerRunnable);
 705                     embeddedLocationTimer.start(16);
 706                 }
 707 
 708                 synthesizeViewMoveEvent();
 709             }
 710         }
 711     }
 712 
 713     protected abstract boolean _setResizable(long ptr, boolean resizable);
 714     public boolean setResizable(final boolean resizable) {
 715         Application.checkEventThread();
 716         checkNotClosed();
 717         if (this.isResizable != resizable) {
 718             if (_setResizable(this.ptr, resizable)) {
 719                 this.isResizable = resizable;
 720                 synthesizeViewMoveEvent();
 721             }
 722         }
 723         return isResizable;
 724     }
 725 
 726     public boolean isResizable() {
 727         Application.checkEventThread();
 728         return this.isResizable;
 729     }
 730 
 731     public boolean isUnifiedWindow() {
 732         //The UNIFIED flag is set only if it is supported
 733         return (this.styleMask &amp; Window.UNIFIED) != 0;
 734     }
 735 
 736     public boolean isTransparentWindow() {
 737         //The TRANSPARENT flag is set only if it is supported
 738         return (this.styleMask &amp; Window.TRANSPARENT) != 0;
 739     }
 740 
 741     private static volatile Window focusedWindow = null;
 742     public static Window getFocusedWindow() {
 743         Application.checkEventThread();
 744         return Window.focusedWindow;
 745     }
 746 
 747     private static void setFocusedWindow(final Window window) {
 748         Window.focusedWindow = window;
 749     }
 750 
 751     public boolean isFocused() {
 752         Application.checkEventThread();
 753         return this.isFocused;
 754     }
 755 
 756     protected abstract boolean _requestFocus(long ptr, int event);
 757     /**
 758      * Requests or resigns focus on this window.
 759      *
 760      * If this is a top-level window (owned or not), then the only possible
 761      * value for the {@code event} argument is WindowEvent.FOCUS_GAINED.
 762      * Otherwise, if the window is a child window, the argument may be
 763      * WindowEvent.FOCUS_LOST, FOCUS_GAINED, FOCUS_GAINED_FORWARD, or
 764      * FOCUS_GAINED_BACKWARD.
 765      *
 766      * @param event one of WindowEvent.FOCUS_LOST, FOCUS_GAINED, FOCUS_GAINED_FORWARD, FOCUS_GAINED_BACKWARD
 767      *
 768      * @throws IllegalArgumentException if the argument value is invalid for this window
 769      *
 770      * @return {@code true} if the operation succeeded
 771      */
 772     public boolean requestFocus(int event) {
 773         Application.checkEventThread();
 774         checkNotClosed();
 775 
 776         if (!isChild() &amp;&amp; event != WindowEvent.FOCUS_GAINED) {
 777             throw new IllegalArgumentException(&quot;Invalid focus event ID for top-level window&quot;);
 778         }
 779 
 780         if (isChild() &amp;&amp; (event &lt; WindowEvent._FOCUS_MIN || event &gt; WindowEvent._FOCUS_MAX)) {
 781             throw new IllegalArgumentException(&quot;Invalid focus event ID for child window&quot;);
 782         }
 783 
 784         if (event == WindowEvent.FOCUS_LOST &amp;&amp; !isFocused()) {
 785             // Already unfocused, nothing to do
 786             return true;
 787         }
 788 
 789         // At this point either A) the user requests focus for a focused or unfocused window,
 790         // or B) the window is focused and the user requests FOCUS_LOST
 791         if (!this.isFocusable) {
 792             // It&#39;s obviously A). Fail.
 793             return false;
 794         }
 795 
 796         return _requestFocus(this.ptr, event);
 797     }
 798 
 799     public boolean requestFocus() {
 800         Application.checkEventThread();
 801         return requestFocus(WindowEvent.FOCUS_GAINED);
 802     }
 803 
 804     protected abstract void _setFocusable(long ptr, boolean isFocusable);
 805     /**
 806      * Sets whether this window is focusable.
 807      *
 808      * Clicking an unfocusable window doesn&#39;t activate it.
 809      */
 810     public void setFocusable(final boolean isFocusable) {
 811         Application.checkEventThread();
 812         checkNotClosed();
 813         this.isFocusable = isFocusable;
 814         if (isEnabled()) {
 815             _setFocusable(this.ptr, isFocusable);
 816         }
 817     }
 818 
 819     protected abstract boolean _grabFocus(long ptr);
 820     protected abstract void _ungrabFocus(long ptr);
 821     /**
 822      * Grabs focus on this window.
 823      *
 824      * All mouse clicks that occur in this window&#39;s client area or client-areas
 825      * of any of its unfocusable owned windows are delivered as usual. Whenever
 826      * a click occurs on another app&#39;s window (not related via the ownership
 827      * relation with this one, or a focusable owned window), or on non-client
 828      * area of any window (titlebar, etc.), or any third-party app&#39;s window, or
 829      * native OS GUI (e.g. a taskbar), the grab is automatically reset, and the
 830      * window that held the grab receives the FOCUS_UNGRAB event.
 831      *
 832      * Note that for this functionality to work correctly, the window must have
 833      * a focus upon calling this method. All owned popup windows that should be
 834      * operable during the grabbed focus state (e.g. nested popup menus) must
 835      * be unfocusable (see {@link #setFocusable}). Clicking a focusable owned
 836      * window will reset the grab due to a focus transfer.
 837      *
 838      * The click that occurs in another window and causes resetting of the grab
 839      * may or may not be delivered to that other window depending on the native
 840      * OS behavior.
 841      *
 842      * If any of the application&#39;s windows already holds the grab, it is reset
 843      * prior to grabbing the focus for this window. The method may be called
 844      * multiple times for one window. Subsequent calls do not affect the grab
 845      * status unless it is reset between the calls, in which case the focus
 846      * is grabbed again.
 847      *
 848      * Note that grabbing the focus on an application window may prevent
 849      * delivering certain events to other applications until the grab is reset.
 850      * Therefore, if the application has finished showing popup windows based
 851      * on a user action (e.g. clicking a menu item), and doesn&#39;t require the
 852      * grab any more, it should call the {@link #ungrabFocus} method. The
 853      * FOCUS_UNGRAB event signals that the grab has been reset.
 854      *
 855      * A user event handler associated with a menu item must be invoked after
 856      * resetting the grab. Otherwise, if a developer debugs the application and
 857      * has installed a breakpoint in the event handler, the debugger may become
 858      * unoperable due to events blocking for other applications on some
 859      * platforms.
 860      *
 861      * @return {@code true} if the operation is successful
 862      * @throws IllegalStateException if the window isn&#39;t focused currently
 863      */
 864     public boolean grabFocus() {
 865         Application.checkEventThread();
 866         checkNotClosed();
 867 
 868         if (!isFocused()) {
 869             throw new IllegalStateException(&quot;The window must be focused when calling grabFocus()&quot;);
 870         }
 871 
 872         return _grabFocus(this.ptr);
 873     }
 874 
 875     /**
 876      * Manually ungrabs focus grabbed on this window previously.
 877      *
 878      * This method resets the grab, and forces sending of the FOCUS_UNGRAB
 879      * event. It should be used when popup windows (such as menus) should be
 880      * dismissed manually, e.g. when a user clicks a menu item which usually
 881      * causes the menus to hide.
 882      *
 883      * @see #grabFocus
 884      */
 885     public void ungrabFocus() {
 886         Application.checkEventThread();
 887         checkNotClosed();
 888         _ungrabFocus(this.ptr);
 889     }
 890 
 891     public String getTitle() {
 892         Application.checkEventThread();
 893         return this.title;
 894     }
 895 
 896     protected abstract boolean _setTitle(long ptr, String title);
 897     public void setTitle(String title) {
 898         Application.checkEventThread();
 899         checkNotClosed();
 900         if (title == null) {
 901             title = &quot;&quot;;
 902         }
 903         if (!title.equals(this.title)) {
 904             if (_setTitle(this.ptr, title)) {
 905                 this.title = title;
 906             }
 907         }
 908     }
 909 
 910     protected abstract void _setLevel(long ptr, int level);
 911     /**
 912      * Set the level of this window in the z-order.
 913      *
 914      * @param level one of the constants from {@link Window.Level}
 915      * @see Window.Level
 916      */
 917     public void setLevel(final int level) {
 918         Application.checkEventThread();
 919         checkNotClosed();
 920         if (level &lt; Level._MIN || level &gt; Level._MAX) {
 921             throw new IllegalArgumentException(&quot;Level should be in the range [&quot; + Level._MIN + &quot;..&quot; + Level._MAX + &quot;]&quot;);
 922         }
 923         if (this.level != level) {
 924             _setLevel(this.ptr, level);
 925             this.level = level;
 926         }
 927     }
 928 
 929     public int getLevel() {
 930         Application.checkEventThread();
 931         return this.level;
 932     }
 933 
 934     private boolean isInFullscreen() {
 935         final View view = getView();
 936         return view == null ? false : view.isInFullscreen();
 937     }
 938 
 939     // Invoked from the View class before sending FULLSCREEN_ to the View.EventHandler
 940     void notifyFullscreen(boolean entered) {
 941         final float alpha = getAlpha();
 942         if (alpha &lt; 1f) {
 943             if (entered) {
 944                 // Reset alpha at native level
 945                 _setAlpha(this.ptr, 1f);
 946             } else {
 947                 // restore the current opacity level
 948                 setAlpha(alpha);
 949             }
 950         }
 951     }
 952 
 953     protected abstract void _setAlpha(long ptr, float alpha);
 954     /**
 955      * Sets the uniform translucency level for this window.
 956      *
 957      * In the full screen mode the native window is always fully opaque.
 958      * The requested opacity level is applied upon exiting the full screen
 959      * mode only.
 960      *
 961      * @param alpha a value in the range [0..1f] (transparent..fully-opaque)
 962      */
 963     public void setAlpha(final float alpha) {
 964         Application.checkEventThread();
 965         checkNotClosed();
 966         if (alpha &lt; 0f || alpha &gt; 1f) {
 967             throw new IllegalArgumentException(&quot;Alpha should be in the range [0f..1f]&quot;);
 968         }
 969 
 970         this.alpha = alpha;
 971 
 972         if (alpha &lt; 1f &amp;&amp; isInFullscreen()) {
 973             return;
 974         }
 975 
 976         _setAlpha(this.ptr, this.alpha);
 977     }
 978 
 979     public float getAlpha() {
 980         Application.checkEventThread();
 981         return this.alpha;
 982     }
 983 
 984     public boolean getAppletMode() {
 985         return appletMode;
 986     }
 987 
 988     public void setAppletMode(boolean appletMode) {
 989         this.appletMode = appletMode;
 990     }
 991 
 992     protected abstract boolean _setBackground(long ptr, float r, float g, float b);
 993     /**
 994      * Set the background of the window.
 995      *
 996      * In most cases the View covers the whole window, so the background color
 997      * of the window is never seen by the user. However, a window w/o a view
 998      * does display the background color in its content area.
 999      *
1000      * On some platforms setting the background color may produce flickering
1001      * when painting the content area of the View (even though the View covers
1002      * the whole window).  Therefore it is recommended to set the background
1003      * color to windows w/o views only.
1004      */
1005     public boolean setBackground(final float r, final float g, final float b) {
1006         Application.checkEventThread();
1007         checkNotClosed();
1008         return _setBackground(this.ptr, r, g, b);
1009     }
1010 
1011     public boolean isEnabled() {
1012         Application.checkEventThread();
1013         return this.disableCount == 0;
1014     }
1015 
1016     protected abstract void _setEnabled(long ptr, boolean enabled);
1017     /**
1018      * Enables or disables the window.
1019      *
1020      * A disabled window is unfocusable by definition.
1021      * Also, key or mouse events aren&#39;t generated for disabled windows.
1022      *
1023      * When a user tries to activate a disabled window, or the window gets
1024      * accidentally brought to the top of the stacking order, the window
1025      * generates the FOCUS_DISABLED window event. A Glass client should react
1026      * to this event and bring the currently active modal blocker of the
1027      * disabled window to top by calling blocker&#39;s minimize(false), toFront(),
1028      * and requestFocus() methods. It may also &#39;blink&#39; the blocker window to
1029      * further attract user&#39;s attention.
1030      *
1031      * It&#39;s strongly recommended to process the FOCUS_DISABLED event
1032      * synchronously and as fast as possible to avoid any possible visual and
1033      * behavioral artifacts. Note that a disabled window may by no means gain
1034      * the input focus. The purpose of this event is to make sure that the
1035      * current modal blocker window is always visible to the user, and the user
1036      * understands why he can&#39;t interact with a disabled window.
1037      *
1038      * The method supports nested calls. If you disable the window twice
1039      * with two calls to setEnabled(false), you must call setEnabled(true)
1040      * twice as well in order to enable it afterwards. This is to support
1041      * &#39;nested&#39; modal dialogs when one modal dialog opens another one.
1042      */
1043     public void setEnabled(boolean enabled) {
1044         Application.checkEventThread();
1045         checkNotClosed();
1046         if (!enabled) {
1047             if (++this.disableCount &gt; 1) {
1048                 // already disabled
1049                 return;
1050             }
1051         } else {
1052             if (this.disableCount == 0) {
1053                 //should report a warning about an extra enable call ?
1054                 return;
1055             }
1056             if (--this.disableCount &gt; 0) {
1057                 // not yet enabled
1058                 return;
1059             }
1060         }
1061 
1062         //TODO: on Windows _setFocusable(this.ptr, isEnabled() ? this.isFocusable : false);
1063         _setEnabled(this.ptr, isEnabled());
1064     }
1065 
1066     public int getMinimumWidth() {
1067         Application.checkEventThread();
1068         return this.minimumWidth;
1069     }
1070 
1071     public int getMinimumHeight() {
1072         Application.checkEventThread();
1073         return this.minimumHeight;
1074     }
1075 
1076     public int getMaximumWidth() {
1077         Application.checkEventThread();
1078         return this.maximumWidth;
1079     }
1080 
1081     public int getMaximumHeight() {
1082         Application.checkEventThread();
1083         return this.maximumHeight;
1084     }
1085 
1086     protected abstract boolean _setMinimumSize(long ptr, int width, int height);
1087     /**
1088      * Sets the minimum size for this window.
1089      * A value of zero indicates no restriction.
1090      * If the native platform is unable to apply the constraints,
1091      * the values returned by getMinimumWidth()/Height() won&#39;t change.
1092      *
1093      * @throws IllegalArgumentException if width or height &lt; 0
1094      */
1095     public void setMinimumSize(int width, int height) {
1096         Application.checkEventThread();
1097         if (width &lt; 0 || height &lt; 0) {
1098             throw new IllegalArgumentException(&quot;The width and height must be &gt;= 0. Got: width=&quot; + width + &quot;; height=&quot; + height);
1099         }
1100         checkNotClosed();
1101         if (_setMinimumSize(this.ptr, width, height)) {
1102             this.minimumWidth = width;
1103             this.minimumHeight = height;
1104         }
1105     }
1106 
1107     protected abstract boolean _setMaximumSize(long ptr, int width, int height);
1108     /**
1109      * Sets the maximum size for this window.
1110      * A value of {@code Integer.MAX_VALUE} indicates no restriction.
1111      * If the native platform is unable to apply the constraints,
1112      * the values returned by getMaximumWidth()/Height() won&#39;t change.
1113      *
1114      * @throws IllegalArgumentException if width or height &lt; 0
1115      */
1116     public void setMaximumSize(int width, int height) {
1117         Application.checkEventThread();
1118         if (width &lt; 0 || height &lt; 0) {
1119             throw new IllegalArgumentException(&quot;The width and height must be &gt;= 0. Got: width=&quot; + width + &quot;; height=&quot; + height);
1120         }
1121         checkNotClosed();
1122         if (_setMaximumSize(this.ptr,
1123                     // for easier handling in native:
1124                     width == Integer.MAX_VALUE ? -1 : width,
1125                     height == Integer.MAX_VALUE ? -1 : height))
1126         {
1127             this.maximumWidth = width;
1128             this.maximumHeight = height;
1129         }
1130     }
1131 
1132 
1133     protected abstract void _setIcon(long ptr, Pixels pixels);
1134 
1135     // In the future we may want to pass a collection of Pixels, so that
1136     // the native platform could pick up the icon with the best dimensions
1137     public void setIcon(final Pixels pixels) {
1138         Application.checkEventThread();
1139         checkNotClosed();
1140         _setIcon(this.ptr, pixels);
1141     }
1142 
1143     protected abstract void _setCursor(long ptr, Cursor cursor);
1144 
1145     /**
1146      * Sets given cursor as the cursor for this window.
1147      * If the cursor is NONE, it is automatically hidden,
1148      * otherwise it is automatically shown.
1149      * @see Cursor#setVisible(boolean)
1150      */
1151     public void setCursor(Cursor cursor) {
1152         Application.checkEventThread();
1153         _setCursor(this.ptr, cursor);
1154     }
1155 
1156     protected abstract void _toFront(long ptr);
1157     /**
1158      * Bring the window to front in the z-order.
1159      * This method DOES NOT activate the window. To make it active use
1160      * the requestFocus() method right after calling toFront().
1161      */
1162     public void toFront() {
1163         Application.checkEventThread();
1164         checkNotClosed();
1165         _toFront(ptr);
1166     }
1167 
1168     protected abstract void _toBack(long ptr);
1169     /**
1170      * Send the window to the bottom of the stacking order.
1171      * This method may or may not de-focus this window
1172      * depending on the native platform. To make sure some other
1173      * window is activated, call requestFocus() on that other window.
1174      */
1175     public void toBack() {
1176         Application.checkEventThread();
1177         checkNotClosed();
1178         _toBack(this.ptr);
1179     }
1180 
1181     // *****************************************************
1182     // modality (prototype using native platform feature)
1183     // *****************************************************
1184     protected abstract void _enterModal(long ptr);
1185     /**
1186      * Enter modal state blocking everything except our window.
1187      */
1188     public void enterModal() {
1189         checkNotClosed();
1190         if (this.isModal == false) {
1191             this.isModal = true;
1192             _enterModal(this.ptr);
1193         }
1194     }
1195 
1196     protected abstract void _enterModalWithWindow(long dialog, long window);
1197     /**
1198      * Enter modal state only blocking the given window.
1199      * On Mac OS X this is done using a dialog sheet.
1200      */
1201     public void enterModal(final Window window) {
1202         checkNotClosed();
1203         if (this.isModal == false) {
1204             this.isModal = true;
1205             _enterModalWithWindow(this.ptr, window.getNativeHandle());
1206         }
1207     }
1208 
1209     protected abstract void _exitModal(long ptr);
1210     public void exitModal() {
1211         checkNotClosed();
1212         if (this.isModal == true) {
1213             _exitModal(this.ptr);
1214             this.isModal = false;
1215         }
1216     }
1217 
1218     public boolean isModal() {
1219         return this.isModal;
1220     }
1221 
1222     /** Only used on Mac when run inside a plugin */
1223     public void dispatchNpapiEvent(Map eventInfo) {
1224         Application.checkEventThread();
1225         throw new RuntimeException(&quot;This operation is not supported on this platform&quot;);
1226     }
1227 
1228     public EventHandler getEventHandler() {
1229         Application.checkEventThread();
1230         return eventHandler;
1231     }
1232 
1233     public void setEventHandler(EventHandler eventHandler) {
1234         Application.checkEventThread();
1235         this.eventHandler = eventHandler;
1236     }
1237 
1238     /**
1239      * Enables unconditional start of window move operation when
1240      * mouse is dragged in the client area.
1241      */
1242     public void setShouldStartUndecoratedMove(boolean v) {
1243         Application.checkEventThread();
1244         this.shouldStartUndecoratedMove = v;
1245     }
1246 
1247     // *****************************************************
1248     // notification callbacks
1249     // *****************************************************
1250     protected void notifyClose() {
1251         handleWindowEvent(System.nanoTime(), WindowEvent.CLOSE);
1252     }
1253 
1254     protected void notifyDestroy() {
1255         // Mac is known to send multiple WillClose notifications for some reason
1256         if (this.ptr == 0) {
1257             return;
1258         }
1259 
1260         handleWindowEvent(System.nanoTime(), WindowEvent.DESTROY);
1261 
1262         this.ptr = 0;
1263 
1264         // Do this after setting ptr to 0 to avoid a call to _setVisible()
1265         setVisible(false);
1266     }
1267 
1268     protected void notifyMove(final int x, final int y) {
1269         this.x = x;
1270         this.y = y;
1271         handleWindowEvent(System.nanoTime(), WindowEvent.MOVE);
1272     }
1273 
1274     protected void notifyRescale() {
1275         handleWindowEvent(System.nanoTime(), WindowEvent.RESCALE);
1276     }
1277 
1278     protected void notifyMoveToAnotherScreen(Screen newScreen) {
1279         setScreen(newScreen);
1280     }
1281 
1282     protected void setState(int state) {
1283         this.state = state;
1284     }
1285 
1286     /**
1287      * type values:
1288      *   - WindowEvent.RESIZE
1289      *   - WindowEvent.MINIMIZE
1290      *   - WindowEvent.MAXIMIZE
1291      *   - WindowEvent.RESTORE
1292      */
1293     protected void notifyResize(final int type, final int width, final int height) {
1294         if (type == WindowEvent.MINIMIZE) {
1295             this.state = State.MINIMIZED;
1296         } else {
1297             if (type == WindowEvent.MAXIMIZE) {
1298                 this.state = State.MAXIMIZED;
1299             } else { // WindowEvent.RESIZE or WindowEvent.RESTORE
1300                 this.state = State.NORMAL;
1301             }
1302             this.width = width;
1303             this.height = height;
1304 
1305             // update moveRect/resizeRect
1306             if (this.helper != null){
1307                 this.helper.updateRectangles();
1308             }
1309         }
1310         handleWindowEvent(System.nanoTime(), type);
1311 
1312         /*
1313          * Send RESIZE notification as MAXIMIZE and RESTORE change the window size
1314          */
1315         if (type == WindowEvent.MAXIMIZE || type == WindowEvent.RESTORE) {
1316             handleWindowEvent(System.nanoTime(), WindowEvent.RESIZE);
1317         }
1318     }
1319 
1320     protected void notifyFocus(int event) {
1321         final boolean focused = event != WindowEvent.FOCUS_LOST;
1322 
1323         if (this.isFocused != focused) {
1324             this.isFocused = focused;
<a name="1" id="anc1"></a><span class="line-modified">1325             if (this.isFocused &amp;&amp; this.isVisible) {</span>
1326                 setFocusedWindow(this);
1327             } else {
1328                 setFocusedWindow(null);
1329             }
1330             handleWindowEvent(System.nanoTime(), event);
1331         }
1332     }
1333 
1334     protected void notifyFocusDisabled() {
1335         handleWindowEvent(System.nanoTime(), WindowEvent.FOCUS_DISABLED);
1336     }
1337 
1338     protected void notifyFocusUngrab() {
1339         handleWindowEvent(System.nanoTime(), WindowEvent.FOCUS_UNGRAB);
1340     }
1341 
1342     protected void notifyDelegatePtr(long ptr) {
1343         this.delegatePtr = ptr;
1344     }
1345 
1346     // *****************************************************
1347     // window event handlers
1348     // *****************************************************
1349     protected void handleWindowEvent(long time, int type) {
1350         if (this.eventHandler != null) {
1351             this.eventHandler.handleWindowEvent(this, time, type);
1352         }
1353     }
1354 
1355     // *****************************************************
1356     // programmatical move/resize
1357     // *****************************************************
1358     /** Sets &quot;programmatical move&quot; rectangle.
1359      * The rectangle is measured from top of the View:
1360      * width is View.width, height is size.
1361      *
1362      * throws RuntimeException for decorated window.
1363      */
1364     public void setUndecoratedMoveRectangle(int size) {
1365         Application.checkEventThread();
1366         if (this.isDecorated == true) {
1367             //throw new RuntimeException(&quot;setUndecoratedMoveRectangle is only valid for Undecorated Window&quot;);
1368             System.err.println(&quot;Glass Window.setUndecoratedMoveRectangle is only valid for Undecorated Window. In the future this will be hard error.&quot;);
1369             Thread.dumpStack();
1370             return;
1371         }
1372 
1373         if (this.helper != null) {
1374             this.helper.setMoveRectangle(size);
1375         }
1376     }
1377     /** The method called only for undecorated windows
1378      * x, y: mouse coordinates (in View space).
1379      *
1380      * throws RuntimeException for decorated window.
1381      */
1382     public boolean shouldStartUndecoratedMove(final int x, final int y) {
1383         Application.checkEventThread();
1384         if (this.shouldStartUndecoratedMove == true) {
1385             return true;
1386         }
1387         if (this.isDecorated == true) {
1388             return false;
1389         }
1390 
1391         if (this.helper != null) {
1392             return this.helper.shouldStartMove(x, y);
1393         } else {
1394             return false;
1395         }
1396     }
1397 
1398     /** Sets &quot;programmatical resize&quot; rectangle.
1399      * The rectangle is measured from top of the View:
1400      * width is View.width, height is size.
1401      *
1402      * throws RuntimeException for decorated window.
1403      */
1404     public void setUndecoratedResizeRectangle(int size) {
1405         Application.checkEventThread();
1406         if ((this.isDecorated == true) || (this.isResizable == false)) {
1407             //throw new RuntimeException(&quot;setUndecoratedMoveRectangle is only valid for Undecorated Resizable Window&quot;);
1408             System.err.println(&quot;Glass Window.setUndecoratedResizeRectangle is only valid for Undecorated Resizable Window. In the future this will be hard error.&quot;);
1409             Thread.dumpStack();
1410             return;
1411         }
1412 
1413         if (this.helper != null) {
1414             this.helper.setResizeRectangle(size);
1415         }
1416     }
1417 
1418     /** The method called only for undecorated windows
1419      * x, y: mouse coordinates (in View space).
1420      *
1421      * throws RuntimeException for decorated window.
1422      */
1423     public boolean shouldStartUndecoratedResize(final int x, final int y) {
1424         Application.checkEventThread();
1425         if ((this.isDecorated == true) || (this.isResizable == false)) {
1426             return false;
1427         }
1428 
1429         if (this.helper != null) {
1430             return this.helper.shouldStartResize(x, y);
1431         }  else {
1432             return false;
1433         }
1434     }
1435 
1436     /** Mouse event handler for processing programmatical resize/move
1437      * (for undecorated windows only).
1438      * Must be called by View.
1439      * x &amp; y are View coordinates.
1440      * NOTE: it&#39;s package private!
1441      * @return true if the event is processed by the window,
1442      *         false if it has to be delivered to the app
1443      */
1444     boolean handleMouseEvent(int type, int button, int x, int y, int xAbs, int yAbs) {
1445         if (this.isDecorated == false) {
1446             return this.helper.handleMouseEvent(type, button, x, y, xAbs, yAbs);
1447         }
1448         return false;
1449     }
1450 
1451     @Override
1452     public String toString() {
1453         Application.checkEventThread();
1454         return  &quot;Window:&quot;+&quot;\n&quot;
1455                 + &quot;    ptr: &quot; + getNativeWindow() + &quot;\n&quot;
1456                 + &quot;    screen ptr: &quot; + (screen != null ? screen.getNativeScreen() : &quot;null&quot;) + &quot;\n&quot;
1457                 + &quot;    isDecorated: &quot; + isDecorated() + &quot;\n&quot;
1458                 + &quot;    title: &quot; + getTitle() + &quot;\n&quot;
1459                 + &quot;    visible: &quot; + isVisible() + &quot;\n&quot;
1460                 + &quot;    focused: &quot; + isFocused() + &quot;\n&quot;
1461                 + &quot;    modal: &quot; + isModal() + &quot;\n&quot;
1462                 + &quot;    state: &quot; + state + &quot;\n&quot;
1463                 + &quot;    x: &quot; + getX() + &quot;, y: &quot; + getY() + &quot;, w: &quot; + getWidth() + &quot;, h: &quot; + getHeight() + &quot;\n&quot;
1464                 + &quot;&quot;;
1465     }
1466 
1467     // &quot;programmical&quot; move/resize support for undecorated windows
1468 
1469     static private class TrackingRectangle {
1470         int size = 0;
1471         int x = 0, y = 0, width = 0, height = 0;
1472         boolean contains(final int x, final int y) {
1473             return ((size &gt; 0) &amp;&amp;
1474                     (x &gt;= this.x) &amp;&amp; (x &lt; (this.x + this.width)) &amp;&amp;
1475                         (y &gt;= this.y) &amp;&amp; (y &lt; (this.y + this.height)));
1476         }
1477     }
1478 
1479     protected void notifyLevelChanged(int level) {
1480         this.level = level;
1481         if (this.eventHandler != null) {
1482             this.eventHandler.handleLevelEvent(level);
1483         }
1484     }
1485 
1486     private class UndecoratedMoveResizeHelper {
1487         TrackingRectangle moveRect = null;
1488         TrackingRectangle resizeRect = null;
1489 
1490         boolean inMove = false;         // we are in &quot;move&quot; mode
1491         boolean inResize = false;       // we are in &quot;resize&quot; mode
1492 
1493         int startMouseX, startMouseY;   // start mouse coords
1494         int startX, startY;             // start window location (for move)
1495         int startWidth, startHeight;    // start window size (for resize)
1496 
1497         UndecoratedMoveResizeHelper() {
1498             this.moveRect = new TrackingRectangle();
1499             this.resizeRect = new TrackingRectangle();
1500         }
1501 
1502         void setMoveRectangle(final int size) {
1503             this.moveRect.size = size;
1504 
1505             this.moveRect.x = 0;
1506             this.moveRect.y = 0;
1507             this.moveRect.width = getWidth();
1508             this.moveRect.height = this.moveRect.size;
1509         }
1510 
1511         boolean shouldStartMove(final int x, final int y) {
1512             return this.moveRect.contains(x, y);
1513         }
1514 
1515         boolean inMove() {
1516             return this.inMove;
1517         }
1518 
1519         void startMove(final int x, final int y) {
1520             this.inMove = true;
1521 
1522             this.startMouseX = x;
1523             this.startMouseY = y;
1524 
1525             this.startX = getX();
1526             this.startY = getY();
1527         }
1528 
1529         void deltaMove(final int x, final int y) {
1530             int deltaX = x - this.startMouseX;
1531             int deltaY = y - this.startMouseY;
1532 
1533             setPosition(this.startX + deltaX, this.startY + deltaY);
1534         }
1535 
1536         void stopMove() {
1537             this.inMove = false;
1538         }
1539 
1540         void setResizeRectangle(final int size) {
1541             this.resizeRect.size = size;
1542 
1543             // set the rect (bottom right corner of the Window)
1544             this.resizeRect.x = getWidth() - this.resizeRect.size;
1545             this.resizeRect.y = getHeight() - this.resizeRect.size;
1546             this.resizeRect.width = this.resizeRect.size;
1547             this.resizeRect.height = this.resizeRect.size;
1548         }
1549 
1550         boolean shouldStartResize(final int x, final int y) {
1551             return this.resizeRect.contains(x, y);
1552         }
1553 
1554         boolean inResize() {
1555             return this.inResize;
1556         }
1557 
1558         void startResize(final int x, final int y) {
1559             this.inResize = true;
1560 
1561             this.startMouseX = x;
1562             this.startMouseY = y;
1563 
1564             this.startWidth = getWidth();
1565             this.startHeight = getHeight();
1566         }
1567 
1568         void deltaResize(final int x, final int y) {
1569             int deltaX = x - this.startMouseX;
1570             int deltaY = y - this.startMouseY;
1571 
1572             setSize(this.startWidth + deltaX, this.startHeight + deltaY);
1573         }
1574 
1575         protected void stopResize() {
1576             this.inResize = false;
1577         }
1578 
1579         void updateRectangles() {
1580             if (this.moveRect.size &gt; 0) {
1581                 setMoveRectangle(this.moveRect.size);
1582             }
1583             if (this.resizeRect.size &gt; 0) {
1584                 setResizeRectangle(this.resizeRect.size);
1585             }
1586         }
1587 
1588         boolean handleMouseEvent(final int type, final int button, final int x, final int y, final int xAbs, final int yAbs) {
1589             switch (type) {
1590                 case MouseEvent.DOWN:
1591                     if (button == MouseEvent.BUTTON_LEFT) {
1592                         if (shouldStartUndecoratedMove(x, y) == true) {
1593                             startMove(xAbs, yAbs);
1594                             return true;
1595                         } else if (shouldStartUndecoratedResize(x, y) == true) {
1596                             startResize(xAbs, yAbs);
1597                             return true;
1598                         }
1599                     }
1600                     break;
1601 
1602                 case MouseEvent.MOVE:
1603                 case MouseEvent.DRAG:
1604                     if (inMove() == true) {
1605                         deltaMove(xAbs, yAbs);
1606                         return true;
1607                     } else if (inResize() == true) {
1608                         deltaResize(xAbs, yAbs);
1609                         return true;
1610                     }
1611                     break;
1612 
1613                 case MouseEvent.UP:
1614                     boolean wasProcessed = inMove() || inResize();
1615                     stopResize();
1616                     stopMove();
1617                     return wasProcessed;
1618             }
1619             return false;
1620         }
1621     }
1622 
1623     /**
1624      * Requests text input in form of native keyboard for text component
1625      * contained by this Window. Native text input component is drawn on the place
1626      * of JavaFX component to cover it completely and to provide native text editing
1627      * techniques. Any change of text is immediately reflected in JavaFX text component.
1628      *
1629      * @param text text to be shown in the native text input component
1630      * @param type type of text input component @see com.sun.javafx.scene.control.behavior.TextInputTypes
1631      * @param width width of JavaFX text input component
1632      * @param height height of JavaFX text input component
1633      * @param M standard transformation matrix for drawing the native text component derived from JavaFX component
1634      */
1635     public void requestInput(String text, int type, double width, double height,
1636                                 double Mxx, double Mxy, double Mxz, double Mxt,
1637                                 double Myx, double Myy, double Myz, double Myt,
1638                                 double Mzx, double Mzy, double Mzz, double Mzt) {
1639         Application.checkEventThread();
1640         _requestInput(this.ptr, text, type, width, height,
1641                         Mxx, Mxy, Mxz, Mxt,
1642                         Myx, Myy, Myz, Myt,
1643                         Mzx, Mzy, Mzz, Mzt);
1644     }
1645 
1646     /**
1647      * Native keyboard for text input is no longer necessary.
1648      * Keyboard will be hidden and native text input component too.
1649      */
1650     public void releaseInput() {
1651         Application.checkEventThread();
1652         _releaseInput(this.ptr);
1653     }
1654 
1655     protected abstract void _requestInput(long ptr, String text, int type, double width, double height,
1656                                             double Mxx, double Mxy, double Mxz, double Mxt,
1657                                             double Myx, double Myy, double Myz, double Myt,
1658                                             double Mzx, double Mzy, double Mzz, double Mzt);
1659 
1660     protected abstract void _releaseInput(long ptr);
1661 
1662 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>