<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/native-prism-d3d/D3DContext.cc</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;iostream&gt;
  27 
  28 #include &quot;D3DPipeline.h&quot;
  29 #include &quot;D3DContext.h&quot;
  30 #include &quot;D3DPipelineManager.h&quot;
  31 #include &quot;PassThroughVS.h&quot;
  32 
  33 #include &quot;com_sun_prism_d3d_D3DContext.h&quot;
  34 #include &quot;D3DLight.h&quot;
  35 #include &quot;D3DMesh.h&quot;
  36 #include &quot;D3DMeshView.h&quot;
  37 #include &quot;D3DPhongMaterial.h&quot;
  38 using std::cout;
  39 using std::endl;
  40 /**
  41  * Note: this method assumes that r is different from a, b!
  42  */
  43 inline void D3DUtils_MatrixMultTransposed(D3DMATRIX&amp; r, const D3DMATRIX&amp; a, const D3DMATRIX&amp; b) {
  44     for (int i=0; i&lt;4; i++) {
  45         for (int j=0; j&lt;4; j++) {
  46             float t = 0;
  47             for (int k=0; k&lt;4; k++) {
  48                 // transpose on the fly
  49                 t += a.m[i][k] * b.m[k][j];
  50             }
  51             r.m[j][i] = t;
  52         }
  53     }
  54 }
  55 
  56 inline void D3DUtils_MatrixTransposed(D3DMATRIX&amp; r, const D3DMATRIX&amp; a) {
  57     for (int i=0; i&lt;4; i++) {
  58         for (int j=0; j&lt;4; j++) {
  59             r.m[j][i] = a.m[i][j];
  60         }
  61     }
  62 }
  63 
  64 inline void D3DUtils_SetIdentityMatrix(D3DMATRIX *m) {
  65     m-&gt;_12 = m-&gt;_13 = m-&gt;_14 = m-&gt;_21 = m-&gt;_23 = m-&gt;_24 = 0.0f;
  66     m-&gt;_31 = m-&gt;_32 = m-&gt;_34 = m-&gt;_41 = m-&gt;_42 = m-&gt;_43 = 0.0f;
  67     m-&gt;_11 = m-&gt;_22 = m-&gt;_33 = m-&gt;_44 = 1.0f;
  68 }
  69 
  70 // static
  71 HRESULT
  72 D3DContext::CreateInstance(IDirect3D9 *pd3d9, IDirect3D9Ex *pd3d9Ex, UINT adapter, bool isVsyncEnabled, D3DContext **ppCtx)
  73 {
  74     HRESULT res;
  75     *ppCtx = new D3DContext(pd3d9, pd3d9Ex, adapter);
  76     if (FAILED(res = (*ppCtx)-&gt;InitContext(isVsyncEnabled))) {
  77         delete *ppCtx;
  78         *ppCtx = NULL;
  79     }
  80     return res;
  81 }
  82 
  83 D3DContext::D3DContext(IDirect3D9 *pd3d, IDirect3D9Ex *pd3dEx, UINT adapter)
  84 {
  85     TraceLn(NWT_TRACE_INFO, &quot;D3DContext::D3DContext&quot;);
  86     TraceLn1(NWT_TRACE_VERBOSE, &quot;  pd3d=0x%x&quot;, pd3d);
  87     pd3dObject = pd3d;
  88     pd3dObjectEx = pd3dEx;
  89     pd3dDevice = NULL;
  90     pd3dDeviceEx = NULL;
  91     adapterOrdinal = adapter;
  92     defaulResourcePool = D3DPOOL_SYSTEMMEM;
  93 
  94     pResourceMgr = NULL;
  95 
  96     pPassThroughVS = NULL;
  97     pVertexDecl = NULL;
  98     pIndices = NULL;
  99     pVertexBufferRes = NULL;
 100 
 101     bBeginScenePending = FALSE;
 102     phongShader = NULL;
 103 
 104     ZeroMemory(&amp;devCaps, sizeof(D3DCAPS9));
 105     ZeroMemory(&amp;curParams, sizeof(curParams));
 106     ZeroMemory(textureCache, sizeof(textureCache));
 107 }
 108 
 109 /**
 110  * This method releases context resources either from the default pool only
 111  * (basically from vram) or all of them, depending on the passed argument.
 112  *
 113  * Note that some resources are still not under ResourceManager control so we
 114  * have to handle them separately. Ideally we&#39;d move every allocated resource
 115  * under RM control.
 116  *
 117  * The reason we have single method instead of a pair of methods (one for
 118  * default only and one for everything) is to reduce code duplication. It is
 119  * possible to call ReleaseDefPoolResources from ReleaseContextResources but
 120  * then we&#39;d traverse the resources list twice (may not be a big deal).
 121  */
 122 void D3DContext::ReleaseContextResources(int releaseType)
 123 {
 124     TraceLn2(NWT_TRACE_INFO,
 125              &quot;D3DContext::ReleaseContextResources: %d pd3dDevice = 0x%x&quot;,
 126              releaseType, pd3dDevice);
 127 
 128     if (releaseType != RELEASE_ALL &amp;&amp; releaseType != RELEASE_DEFAULT) {
 129         TraceLn1(NWT_TRACE_ERROR,
 130                 &quot;D3DContext::ReleaseContextResources unknown type: %d&quot;,
 131                 releaseType);
 132         return;
 133     }
 134 
 135     EndScene();
 136 
 137     if (releaseType == RELEASE_DEFAULT) {
 138         if (pVertexBufferRes != NULL &amp;&amp; pVertexBufferRes-&gt;IsDefaultPool()) {
 139             // if VB is in the default pool it will be released by the RM
 140             pVertexBufferRes = NULL;
 141         }
 142         pResourceMgr-&gt;ReleaseDefPoolResources();
 143     } else if (releaseType == RELEASE_ALL){
 144         // will be released with the resource manager
 145         pVertexBufferRes = NULL;
 146         SAFE_RELEASE(pVertexDecl);
 147         SAFE_RELEASE(pIndices);
 148         SAFE_RELEASE(pPassThroughVS);
 149         SAFE_DELETE(pResourceMgr);
 150     }
 151 }
 152 
 153 D3DContext::~D3DContext() {}
 154 
 155 int D3DContext::release() {
 156 
 157     TraceLn2(NWT_TRACE_INFO,
 158                 &quot;~D3DContext: pd3dDevice=0x%x, pd3dObject =0x%x&quot;,
 159                 pd3dDevice, pd3dObject);
 160     ReleaseContextResources(RELEASE_ALL);
 161     for (int i = 0; i &lt; NUM_TEXTURE_CACHE; i++) {
 162         SAFE_RELEASE(textureCache[i].surface);
 163         SAFE_RELEASE(textureCache[i].texture);
 164     }
 165     SAFE_RELEASE(pd3dDevice);
 166     SAFE_RELEASE(pd3dDeviceEx);
 167 
 168     if (phongShader) {
 169         delete phongShader;
 170         phongShader = NULL;
 171     }
 172 
 173     delete this;
 174     return 0;
 175 }
 176 
 177 /*
 178  * Class:     com_sun_prism_d3d_D3DContext
 179  * Method:    nCreateD3DMesh
 180  * Signature: (J)J
 181  */
 182 JNIEXPORT jlong JNICALL Java_com_sun_prism_d3d_D3DContext_nCreateD3DMesh
 183   (JNIEnv *env, jclass, jlong ctx)
 184 {
 185     TraceLn(NWT_TRACE_INFO, &quot;D3DContext_nCreateD3DMesh&quot;);
 186     D3DContext *pCtx = (D3DContext*) jlong_to_ptr(ctx);
 187     RETURN_STATUS_IF_NULL(pCtx, 0L);
 188 
 189     D3DMesh *mesh = new D3DMesh(pCtx);
 190     return ptr_to_jlong(mesh);
 191 }
 192 
 193 /*
 194  * Class:     com_sun_prism_d3d_D3DContext
 195  * Method:    nReleaseD3DMesh
 196  * Signature: (JJ)V
 197  */
 198 JNIEXPORT void JNICALL Java_com_sun_prism_d3d_D3DContext_nReleaseD3DMesh
 199   (JNIEnv *env, jclass, jlong ctx, jlong nativeMesh)
 200 {
 201     TraceLn(NWT_TRACE_INFO, &quot;D3DContext_nReleaseD3DMesh&quot;);
 202     D3DMesh *mesh = (D3DMesh *) jlong_to_ptr(nativeMesh);
 203     if (mesh) {
 204         delete mesh;
 205     }
 206 }
 207 
 208 /*
 209  * Class:     com_sun_prism_d3d_D3DContext
 210  * Method:    nBuildNativeGeometryShort
 211  * Signature: (JJ[FI[SI)Z
 212  */
 213 JNIEXPORT jboolean JNICALL Java_com_sun_prism_d3d_D3DContext_nBuildNativeGeometryShort
 214   (JNIEnv *env, jclass, jlong ctx, jlong nativeMesh, jfloatArray vb, jint vbSize, jshortArray ib, jint ibSize)
 215 {
 216     TraceLn(NWT_TRACE_INFO, &quot;D3DContext_nBuildNativeGeometryShort&quot;);
 217     D3DMesh *mesh = (D3DMesh *) jlong_to_ptr(nativeMesh);
 218     RETURN_STATUS_IF_NULL(mesh, JNI_FALSE);
 219 
 220     if (vbSize &lt; 0 || ibSize &lt; 0) {
 221         return JNI_FALSE;
 222     }
 223 
 224     UINT uvbSize = (UINT) vbSize;
 225     UINT uibSize = (UINT) ibSize;
 226     UINT vertexBufferSize = env-&gt;GetArrayLength(vb);
 227     UINT indexBufferSize = env-&gt;GetArrayLength(ib);
 228 
 229     if (uvbSize &gt; vertexBufferSize || uibSize &gt; indexBufferSize) {
 230         return JNI_FALSE;
 231     }
 232 
 233     float *vertexBuffer = (float *) (env-&gt;GetPrimitiveArrayCritical(vb, NULL));
 234     if (vertexBuffer == NULL) {
 235         return JNI_FALSE;
 236     }
 237 
 238     USHORT *indexBuffer = (USHORT *) (env-&gt;GetPrimitiveArrayCritical(ib, NULL));
 239     if (indexBuffer == NULL) {
 240         env-&gt;ReleasePrimitiveArrayCritical(vb, vertexBuffer, 0);
 241         return JNI_FALSE;
 242     }
 243 
 244     boolean result = mesh-&gt;buildBuffers(vertexBuffer, uvbSize, indexBuffer, uibSize);
 245     env-&gt;ReleasePrimitiveArrayCritical(ib, indexBuffer, 0);
 246     env-&gt;ReleasePrimitiveArrayCritical(vb, vertexBuffer, 0);
 247 
 248     return result;
 249 }
 250 
 251 /*
 252  * Class:     com_sun_prism_d3d_D3DContext
 253  * Method:    nBuildNativeGeometryInt
 254  * Signature: (JJ[FI[II)Z
 255  */
 256 JNIEXPORT jboolean JNICALL Java_com_sun_prism_d3d_D3DContext_nBuildNativeGeometryInt
 257   (JNIEnv *env, jclass, jlong ctx, jlong nativeMesh, jfloatArray vb, jint vbSize, jintArray ib, jint ibSize)
 258 {
 259     TraceLn(NWT_TRACE_INFO, &quot;D3DContext_nBuildNativeGeometryInt&quot;);
 260     D3DMesh *mesh = (D3DMesh *) jlong_to_ptr(nativeMesh);
 261     RETURN_STATUS_IF_NULL(mesh, JNI_FALSE);
 262 
 263     if (vbSize &lt; 0 || ibSize &lt; 0) {
 264         return JNI_FALSE;
 265     }
 266 
 267     UINT uvbSize = (UINT) vbSize;
 268     UINT uibSize = (UINT) ibSize;
 269     UINT vertexBufferSize = env-&gt;GetArrayLength(vb);
 270     UINT indexBufferSize = env-&gt;GetArrayLength(ib);
 271     if (uvbSize &gt; vertexBufferSize || uibSize &gt; indexBufferSize) {
 272         return JNI_FALSE;
 273     }
 274 
 275     float *vertexBuffer = (float *) (env-&gt;GetPrimitiveArrayCritical(vb, NULL));
 276     if (vertexBuffer == NULL) {
 277         return JNI_FALSE;
 278     }
 279 
 280     UINT *indexBuffer = (UINT *) (env-&gt;GetPrimitiveArrayCritical(ib, NULL));
 281     if (indexBuffer == NULL) {
 282         env-&gt;ReleasePrimitiveArrayCritical(vb, vertexBuffer, 0);
 283         return JNI_FALSE;
 284     }
 285 
 286     boolean result = mesh-&gt;buildBuffers(vertexBuffer, uvbSize, indexBuffer, uibSize);
 287     env-&gt;ReleasePrimitiveArrayCritical(ib, indexBuffer, 0);
 288     env-&gt;ReleasePrimitiveArrayCritical(vb, vertexBuffer, 0);
 289 
 290     return result;
 291 }
 292 
 293 /*
 294  * Class:     com_sun_prism_d3d_D3DContext
 295  * Method:    nCreateD3DPhongMaterial
 296  * Signature: (J)J
 297  */
 298 JNIEXPORT jlong JNICALL Java_com_sun_prism_d3d_D3DContext_nCreateD3DPhongMaterial
 299   (JNIEnv *env, jclass, jlong ctx)
 300 {
 301     TraceLn(NWT_TRACE_INFO, &quot;D3DContext_nCreateD3DPhongMaterial&quot;);
 302     D3DContext *pCtx = (D3DContext*) jlong_to_ptr(ctx);
 303     RETURN_STATUS_IF_NULL(pCtx, 0L);
 304 
 305     D3DPhongMaterial *phongMaterial = new D3DPhongMaterial(pCtx);
 306     return ptr_to_jlong(phongMaterial);
 307 }
 308 
 309 /*
 310  * Class:     com_sun_prism_d3d_D3DContext
 311  * Method:    nReleaseD3DPhongMaterial
 312  * Signature: (JJ)V
 313  */
 314 JNIEXPORT void JNICALL Java_com_sun_prism_d3d_D3DContext_nReleaseD3DPhongMaterial
 315   (JNIEnv *env, jclass, jlong ctx, jlong nativePhongMaterial)
 316 {
 317     TraceLn(NWT_TRACE_INFO, &quot;D3DContext_nReleaseD3DPhongMaterial&quot;);
 318     D3DPhongMaterial *phongMaterial = (D3DPhongMaterial *) jlong_to_ptr(nativePhongMaterial);
 319     if (phongMaterial) {
 320         delete phongMaterial;
 321     }
 322 }
 323 
 324 /*
 325  * Class:     com_sun_prism_d3d_D3DContext
 326  * Method:    nSetDiffuseColor
 327  * Signature: (JJFFFF)V
 328  */
 329 JNIEXPORT void JNICALL Java_com_sun_prism_d3d_D3DContext_nSetDiffuseColor
 330   (JNIEnv *env, jclass, jlong ctx, jlong nativePhongMaterial,
 331         jfloat r, jfloat g, jfloat b, jfloat a)
 332 {
 333     TraceLn(NWT_TRACE_INFO, &quot;D3DContext_nSetDiffuseColor&quot;);
 334     D3DPhongMaterial *phongMaterial = (D3DPhongMaterial *) jlong_to_ptr(nativePhongMaterial);
 335     RETURN_IF_NULL(phongMaterial);
 336 
 337     phongMaterial-&gt;setDiffuseColor(r, g, b, a);
 338 }
 339 
 340 /*
 341  * Class:     com_sun_prism_d3d_D3DContext
 342  * Method:    nSetSpecularColor
 343  * Signature: (JJZFFFF)V
 344  */
 345 JNIEXPORT void JNICALL Java_com_sun_prism_d3d_D3DContext_nSetSpecularColor
 346   (JNIEnv *env, jclass, jlong ctx, jlong nativePhongMaterial,
 347         jboolean set, jfloat r, jfloat g, jfloat b, jfloat a)
 348 {
 349     TraceLn(NWT_TRACE_INFO, &quot;D3DContext_nSetSpecularColor&quot;);
 350     D3DPhongMaterial *phongMaterial = (D3DPhongMaterial *) jlong_to_ptr(nativePhongMaterial);
 351     RETURN_IF_NULL(phongMaterial);
 352 
 353     phongMaterial-&gt;setSpecularColor(set ? true : false, r, g, b, a);
 354 }
 355 /*
 356  * Class:     com_sun_prism_d3d_D3DContext
 357  * Method:    nSetMap
 358  * Signature: (JJIJ)V
 359  */
 360 JNIEXPORT void JNICALL Java_com_sun_prism_d3d_D3DContext_nSetMap
 361   (JNIEnv *env, jclass, jlong ctx, jlong nativePhongMaterial,
 362         jint mapType, jlong nativeTexture)
 363 {
 364     TraceLn(NWT_TRACE_INFO, &quot;D3DContext_nSetMap&quot;);
 365     D3DPhongMaterial *phongMaterial = (D3DPhongMaterial *) jlong_to_ptr(nativePhongMaterial);
 366     IDirect3DBaseTexture9 *texMap = (IDirect3DBaseTexture9 *)  jlong_to_ptr(nativeTexture);
 367     RETURN_IF_NULL(phongMaterial);
 368 
 369     phongMaterial-&gt;setMap(mapType, texMap);
 370 }
 371 
 372 /*
 373  * Class:     com_sun_prism_d3d_D3DContext
 374  * Method:    nCreateD3DMeshView
 375  * Signature: (JJ)J
 376  */
 377 JNIEXPORT jlong JNICALL Java_com_sun_prism_d3d_D3DContext_nCreateD3DMeshView
 378   (JNIEnv *env, jclass, jlong ctx, jlong nativeMesh)
 379 {
 380     TraceLn(NWT_TRACE_INFO, &quot;D3DContext_nCreateD3DMeshView&quot;);
 381     D3DContext *pCtx = (D3DContext*) jlong_to_ptr(ctx);
 382     RETURN_STATUS_IF_NULL(pCtx, 0L);
 383 
 384     D3DMesh *mesh = (D3DMesh *) jlong_to_ptr(nativeMesh);
 385     RETURN_STATUS_IF_NULL(mesh, 0L);
 386 
 387     D3DMeshView *meshView = new D3DMeshView(pCtx, mesh);
 388     return ptr_to_jlong(meshView);
 389 }
 390 
 391 /*
 392  * Class:     com_sun_prism_d3d_D3DContext
 393  * Method:    nReleaseD3DMeshView
 394  * Signature: (JJ)V
 395  */
 396 JNIEXPORT void JNICALL Java_com_sun_prism_d3d_D3DContext_nReleaseD3DMeshView
 397   (JNIEnv *env, jclass, jlong ctx, jlong nativeMeshView)
 398 {
 399     TraceLn(NWT_TRACE_INFO, &quot;D3DContext_nReleaseD3DMeshView&quot;);
 400     D3DMeshView *meshView = (D3DMeshView *) jlong_to_ptr(nativeMeshView);
 401     if (meshView) {
 402         delete meshView;
 403     }
 404 }
 405 
 406 /*
 407  * Class:     com_sun_prism_d3d_D3DContext
 408  * Method:    nSetCullingMode
 409  * Signature: (JJI)V
 410  */
 411 JNIEXPORT void JNICALL Java_com_sun_prism_d3d_D3DContext_nSetCullingMode
 412   (JNIEnv *env, jclass, jlong ctx, jlong nativeMeshView, jint cullMode)
 413 {
 414     TraceLn(NWT_TRACE_INFO, &quot;D3DContext_nSetCullingMode&quot;);
 415     D3DMeshView *meshView = (D3DMeshView *) jlong_to_ptr(nativeMeshView);
 416     RETURN_IF_NULL(meshView);
 417 
 418     switch (cullMode) {
 419         case com_sun_prism_d3d_D3DContext_CULL_BACK:
 420             cullMode = D3DCULL_CW;
 421             break;
 422         case com_sun_prism_d3d_D3DContext_CULL_FRONT:
 423             cullMode = D3DCULL_CCW;
 424             break;
 425         case com_sun_prism_d3d_D3DContext_CULL_NONE:
 426             cullMode = D3DCULL_NONE;
 427             break;
 428     }
 429     meshView-&gt;setCullingMode(cullMode);
 430 }
 431 
 432 /*
 433  * Class:     com_sun_prism_d3d_D3DContext
 434  * Method:    nBlit
 435  * Signature: (JJJIIIIIIII)V
 436  */
 437 JNIEXPORT void JNICALL Java_com_sun_prism_d3d_D3DContext_nBlit
 438   (JNIEnv *env, jclass, jlong ctx, jlong nSrcRTT, jlong nDstRTT,
 439             jint srcX0, jint srcY0, jint srcX1, jint srcY1,
 440             jint dstX0, jint dstY0, jint dstX1, jint dstY1)
 441 {
 442     TraceLn(NWT_TRACE_INFO, &quot;D3DContext_nBlit&quot;);
 443     D3DContext *pCtx = (D3DContext*) jlong_to_ptr(ctx);
 444     RETURN_IF_NULL(pCtx);
 445 
 446     D3DResource *srcRes = (D3DResource*) jlong_to_ptr(nSrcRTT);
 447     if (srcRes == NULL) {
 448         TraceLn(NWT_TRACE_INFO, &quot;   error srcRes is NULL&quot;);
 449         return;
 450     }
 451 
 452     IDirect3DSurface9 *pSrcSurface = srcRes-&gt;GetSurface();
 453     if (pSrcSurface == NULL) {
 454         TraceLn(NWT_TRACE_INFO, &quot;   error pSrcSurface is NULL&quot;);
 455         return;
 456     }
 457 
 458     D3DResource *dstRes = (D3DResource*) jlong_to_ptr(nDstRTT);
 459     IDirect3DSurface9 *pDstSurface = (dstRes == NULL) ? NULL : dstRes-&gt;GetSurface();
 460 
 461     pCtx-&gt;stretchRect(pSrcSurface, srcX0, srcY0, srcX1, srcY1,
 462                       pDstSurface, dstX0, dstY0, dstX1, dstY1);
 463 }
 464 
 465 /*
 466  * Class:     com_sun_prism_d3d_D3DContext
 467  * Method:    nSetMaterial
 468  * Signature: (JJJ)V
 469  */
 470 JNIEXPORT void JNICALL Java_com_sun_prism_d3d_D3DContext_nSetMaterial
 471   (JNIEnv *env, jclass, jlong ctx, jlong nativeMeshView, jlong nativePhongMaterial)
 472 {
 473     TraceLn(NWT_TRACE_INFO, &quot;D3DContext_nSetMaterial&quot;);
 474     D3DMeshView *meshView = (D3DMeshView *) jlong_to_ptr(nativeMeshView);
 475     RETURN_IF_NULL(meshView);
 476 
 477     D3DPhongMaterial *phongMaterial = (D3DPhongMaterial *) jlong_to_ptr(nativePhongMaterial);
 478     meshView-&gt;setMaterial(phongMaterial);
 479 }
 480 
 481 /*
 482  * Class:     com_sun_prism_d3d_D3DContext
 483  * Method:    nSetWireframe
 484  * Signature: (JJZ)V
 485  */
 486 JNIEXPORT void JNICALL Java_com_sun_prism_d3d_D3DContext_nSetWireframe
 487   (JNIEnv *env, jclass, jlong ctx, jlong nativeMeshView, jboolean wireframe)
 488 {
 489     TraceLn(NWT_TRACE_INFO, &quot;D3DContext_nSetWireframe&quot;);
 490     D3DMeshView *meshView = (D3DMeshView *) jlong_to_ptr(nativeMeshView);
 491     RETURN_IF_NULL(meshView);
 492 
 493     meshView-&gt;setWireframe(wireframe ? true : false);
 494 }
 495 
 496 /*
 497  * Class:     com_sun_prism_d3d_D3DContext
 498  * Method:    nSetAmbientLight
 499  * Signature: (JJFFF)V
 500  */
 501 JNIEXPORT void JNICALL Java_com_sun_prism_d3d_D3DContext_nSetAmbientLight
 502   (JNIEnv *env, jclass, jlong ctx, jlong nativeMeshView,
 503         jfloat r, jfloat g, jfloat b)
 504 {
 505     TraceLn(NWT_TRACE_INFO, &quot;D3DContext_nSetAmbientLight&quot;);
 506     D3DMeshView *meshView = (D3DMeshView *) jlong_to_ptr(nativeMeshView);
 507     RETURN_IF_NULL(meshView);
 508 
 509     meshView-&gt;setAmbientLight(r, g, b);
 510 }
 511 
 512 /*
 513  * Class:     com_sun_prism_d3d_D3DContext
 514  * Method:    nSetPointLight
 515  * Signature: (JJIFFFFFFF)V
 516  */
 517 JNIEXPORT void JNICALL Java_com_sun_prism_d3d_D3DContext_nSetPointLight
 518   (JNIEnv *env, jclass, jlong ctx, jlong nativeMeshView, jint index,
<a name="2" id="anc2"></a><span class="line-modified"> 519         jfloat x, jfloat y, jfloat z, jfloat r, jfloat g, jfloat b, jfloat w)</span>

 520 {
 521     TraceLn(NWT_TRACE_INFO, &quot;D3DContext_nSetPointLight&quot;);
 522     D3DMeshView *meshView = (D3DMeshView *) jlong_to_ptr(nativeMeshView);
 523     RETURN_IF_NULL(meshView);
<a name="3" id="anc3"></a><span class="line-modified"> 524 </span>
<span class="line-removed"> 525     meshView-&gt;setPointLight(index, x, y, z, r, g, b, w);</span>
 526 }
 527 
 528 /*
 529  * Class:     com_sun_prism_d3d_D3DContext
 530  * Method:    nRenderMeshView
 531  * Signature: (JJ)V
 532  */
 533 JNIEXPORT void JNICALL Java_com_sun_prism_d3d_D3DContext_nRenderMeshView
 534   (JNIEnv *env, jclass, jlong ctx, jlong nativeMeshView)
 535 {
 536     TraceLn(NWT_TRACE_INFO, &quot;D3DContext_nRenderMeshView&quot;);
 537     D3DMeshView *meshView = (D3DMeshView *) jlong_to_ptr(nativeMeshView);
 538     RETURN_IF_NULL(meshView);
 539 
 540     meshView-&gt;render();
 541 }
 542 
 543 /*
 544  * Class:     com_sun_prism_d3d_D3DContext
 545  * Method:    nSetDeviceParametersFor2D
 546  */
 547 
 548 JNIEXPORT jint JNICALL Java_com_sun_prism_d3d_D3DContext_nSetDeviceParametersFor2D
 549   (JNIEnv *, jclass, jlong ctx)
 550 {
 551     TraceLn(NWT_TRACE_INFO, &quot;D3DContext_nSetDeviceParametersFor2D&quot;);
 552     D3DContext *pCtx = (D3DContext*)jlong_to_ptr(ctx);
 553     RETURN_STATUS_IF_NULL(pCtx, S_FALSE);
 554 
 555     return pCtx-&gt;setDeviceParametersFor2D();
 556 }
 557 
 558 HRESULT D3DContext::setDeviceParametersFor2D() {
 559 
 560     RETURN_STATUS_IF_NULL(pd3dDevice, S_FALSE);
 561 
 562     HRESULT res = S_OK;
 563 
 564     IDirect3DVertexBuffer9 *vb = pVertexBufferRes-&gt;GetVertexBuffer();
 565 
 566     SUCCEEDED(res = pd3dDevice-&gt;SetVertexDeclaration(pVertexDecl)) &amp;&amp;
 567     SUCCEEDED(res = pd3dDevice-&gt;SetIndices(pIndices)) &amp;&amp;
 568     SUCCEEDED(res = pd3dDevice-&gt;SetVertexShader(pPassThroughVS)) &amp;&amp;
 569     SUCCEEDED(res = pd3dDevice-&gt;SetStreamSource(0, vb, 0, sizeof (PRISM_VERTEX_2D)));
 570 
 571     if (res == S_OK) {
 572         // Note: No need to restore blend and scissor states as the 2D states were
 573         //       invalidated on the Java side.
 574         SUCCEEDED(res = pd3dDevice-&gt;SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE)) &amp;&amp;
 575         SUCCEEDED(res = pd3dDevice-&gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID)) &amp;&amp;
 576         SUCCEEDED(res = pd3dDevice-&gt;SetRenderState(D3DRS_LIGHTING, FALSE));
 577     }
 578     return res;
 579 }
 580 
 581 /*
 582  * Class:     com_sun_prism_d3d_D3DContext
 583  * Method:    nSetDeviceParametersFor3D
 584  */
 585 
 586 JNIEXPORT jint JNICALL Java_com_sun_prism_d3d_D3DContext_nSetDeviceParametersFor3D
 587   (JNIEnv *, jclass, jlong ctx)
 588 {
 589     TraceLn(NWT_TRACE_INFO, &quot;D3DContext_nSet3DVShaderAndVertexBuffer&quot;);
 590     D3DContext *pCtx = (D3DContext*)jlong_to_ptr(ctx);
 591     RETURN_STATUS_IF_NULL(pCtx, S_FALSE);
 592 
 593     return pCtx-&gt;setDeviceParametersFor3D();
 594 }
 595 
 596 HRESULT D3DContext::setDeviceParametersFor3D() {
 597 
 598     RETURN_STATUS_IF_NULL(pd3dDevice, S_FALSE);
 599 
 600     HRESULT res = S_OK;
 601 
 602     if (!phongShader) {
 603         phongShader = new D3DPhongShader(pd3dDevice);
 604     }
 605 
 606     // Reset 3D states
 607     state.wireframe = false;
 608     state.cullMode = D3DCULL_NONE;
 609     if (res == S_OK) {
 610         SUCCEEDED(res = pd3dDevice-&gt;SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE)) &amp;&amp;
 611         SUCCEEDED(res = pd3dDevice-&gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID)) &amp;&amp;
 612         // This setting matches 2D ((1,1-alpha); premultiplied alpha case.
 613         // Will need to evaluate when support proper 3D blending (alpha,1-alpha).
 614         SUCCEEDED(res = pd3dDevice-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE)) &amp;&amp;
 615         SUCCEEDED(res = pd3dDevice-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA)) &amp;&amp;
 616         SUCCEEDED(res = pd3dDevice-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE)) &amp;&amp;
 617         SUCCEEDED(res = pd3dDevice-&gt;SetRenderState(D3DRS_SCISSORTESTENABLE, FALSE)) &amp;&amp;
 618         SUCCEEDED(res = pd3dDevice-&gt;SetRenderState(D3DRS_LIGHTING, TRUE)) &amp;&amp;
 619         // TODO: 3D - RT-34415: [D3D 3D] Need a robust 3D states management for texture
 620         // Set texture unit 0 to its default texture addressing mode for Prism
 621         SUCCEEDED(res = pd3dDevice-&gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP)) &amp;&amp;
 622         SUCCEEDED(res = pd3dDevice-&gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP)) &amp;&amp;
 623         // Set texture filter to bilinear for 3D rendering
 624         SUCCEEDED(res = pd3dDevice-&gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR)) &amp;&amp;
 625         SUCCEEDED(res = pd3dDevice-&gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR));
 626     }
 627     return res;
 628 }
 629 
 630 /*
 631  * Note: this method assumes that pIndices is not null
 632  */
 633 static HRESULT fillQuadIndices(IDirect3DIndexBuffer9 *pIndices, int maxQuads) {
 634     short * data = 0;
 635     HRESULT hr = pIndices-&gt;Lock(0, maxQuads * 6 * sizeof(short), (void **)&amp;data, 0);
 636     if (SUCCEEDED(hr) &amp;&amp; data) {
 637         for (int i = 0; i != maxQuads; ++i) {
 638             int vtx = i * 4;
 639             int idx = i * 6;
 640             data[idx + 0] = vtx + 0;
 641             data[idx + 1] = vtx + 1;
 642             data[idx + 2] = vtx + 2;
 643             data[idx + 3] = vtx + 2;
 644             data[idx + 4] = vtx + 1;
 645             data[idx + 5] = vtx + 3;
 646         }
 647         hr = pIndices-&gt;Unlock();
 648     }
 649     return hr;
 650 }
 651 
 652 HRESULT D3DContext::InitDevice(IDirect3DDevice9 *pd3dDevice)
 653 {
 654 #if defined PERF_COUNTERS
 655     stats.clear();
 656 #endif
 657 
 658     RETURN_STATUS_IF_NULL(pd3dDevice, S_FALSE);
 659 
 660     HRESULT res = S_OK;
 661 
 662     pd3dDevice-&gt;GetDeviceCaps(&amp;devCaps);
 663 
 664     RlsTraceLn1(NWT_TRACE_INFO,
 665                    &quot;D3DContext::InitDevice: device %d&quot;, adapterOrdinal);
 666 
 667     // disable some of the unneeded and costly d3d functionality
 668     pd3dDevice-&gt;SetRenderState(D3DRS_SPECULARENABLE, FALSE);
 669     pd3dDevice-&gt;SetRenderState(D3DRS_LIGHTING,  FALSE);
 670     pd3dDevice-&gt;SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
 671     pd3dDevice-&gt;SetRenderState(D3DRS_ZWRITEENABLE, D3DZB_FALSE);
 672     pd3dDevice-&gt;SetRenderState(D3DRS_COLORVERTEX, FALSE);
 673     pd3dDevice-&gt;SetRenderState(D3DRS_STENCILENABLE, FALSE);
 674 
 675     // set clipping to true inorder support near and far clipping
 676     pd3dDevice-&gt;SetRenderState(D3DRS_CLIPPING,  TRUE);
 677 
 678     pd3dDevice-&gt;SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
 679     pd3dDevice-&gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
 680     state.wireframe = false;
 681     state.cullMode = D3DCULL_NONE;
 682 
 683     if (pResourceMgr == NULL) {
 684         pResourceMgr = D3DResourceManager::CreateInstance(this);
 685     }
 686 
 687     D3DUtils_SetIdentityMatrix(&amp;world);
 688     D3DUtils_SetIdentityMatrix(&amp;projection);
 689     depthTest = FALSE;
 690     pixadjustx = pixadjusty = 0.0f;
 691 
 692     if (pVertexDecl == NULL) {
 693         res = pd3dDevice-&gt;CreateVertexDeclaration(PrismVDecl, &amp;pVertexDecl);
 694         RETURN_STATUS_IF_FAILED(res);
 695     }
 696 //    res = pd3dDevice-&gt;SetVertexDeclaration(pVertexDecl);
 697 //    RETURN_STATUS_IF_FAILED(res);
 698 
 699     if (pIndices == NULL) {
 700         res = pd3dDevice-&gt;CreateIndexBuffer(sizeof(short) * 6 * MAX_BATCH_QUADS,
 701             D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, getResourcePool(), &amp;pIndices, 0);
 702         if (pIndices) {
 703             res = fillQuadIndices(pIndices, MAX_BATCH_QUADS);
 704         }
 705         RETURN_STATUS_IF_FAILED(res);
 706     }
 707 //    res = pd3dDevice-&gt;SetIndices(pIndices);
 708 //    RETURN_STATUS_IF_FAILED(res);
 709 
 710     if (pPassThroughVS == NULL) {
 711         res = pd3dDevice-&gt;CreateVertexShader((DWORD*)g_vs30_passThrough, &amp;pPassThroughVS);
 712         RETURN_STATUS_IF_FAILED(res);
 713     }
 714 //    res = pd3dDevice-&gt;SetVertexShader(pPassThroughVS);
 715 //    RETURN_STATUS_IF_FAILED(res);
 716 
 717     if (pVertexBufferRes == NULL) {
 718         res = GetResourceManager()-&gt;CreateVertexBuffer(&amp;pVertexBufferRes);
 719         RETURN_STATUS_IF_FAILED(res);
 720     }
 721 //    res = pd3dDevice-&gt;SetStreamSource(0, pVertexBufferRes-&gt;GetVertexBuffer(),
 722 //                                      0, sizeof(PRISM_VERTEX_2D));
 723 //    RETURN_STATUS_IF_FAILED(res);
 724 
 725     bBeginScenePending = FALSE;
 726 
 727     RlsTraceLn1(NWT_TRACE_INFO,
 728                    &quot;D3DContext::InitDevice: successfully initialized device %d&quot;,
 729                    adapterOrdinal);
 730 
 731     return res;
 732 }
 733 
 734 HRESULT
 735 D3DContext::TestCooperativeLevel()
 736 {
 737     TraceLn(NWT_TRACE_INFO, &quot;D3DContext::testCooperativeLevel&quot;);
 738 
 739     RETURN_STATUS_IF_NULL(pd3dDevice, E_FAIL);
 740 
 741     //TODO: call CheckDeviceState only if Present fails
 742     HRESULT res = pd3dDeviceEx ?
 743         pd3dDeviceEx-&gt;CheckDeviceState(NULL) :
 744         pd3dDevice-&gt;TestCooperativeLevel();
 745 
 746     switch (res) {
 747     case S_OK: break;
 748     case D3DERR_DEVICELOST:
 749         TraceLn1(NWT_TRACE_VERBOSE, &quot;  device %d is still lost&quot;,
 750             adapterOrdinal);
 751         break;
 752     case D3DERR_DEVICENOTRESET:
 753         TraceLn1(NWT_TRACE_VERBOSE, &quot;  device %d needs to be reset&quot;,
 754             adapterOrdinal);
 755         break;
 756     case S_PRESENT_OCCLUDED:
 757         break;
 758     case S_PRESENT_MODE_CHANGED:
 759         break;
 760     case E_FAIL:
 761         TraceLn(NWT_TRACE_VERBOSE, &quot;  null device&quot;);
 762         break;
 763     default:
 764         TraceLn1(NWT_TRACE_ERROR, &quot;D3DContext::testCooperativeLevel: &quot;\
 765             &quot;unknown error %x from TestCooperativeLevel&quot;, res);
 766     }
 767 
 768     return res;
 769 }
 770 
 771 HRESULT
 772 D3DContext::Clear(DWORD colorArgbPre, BOOL clearDepth, BOOL ignoreScissor)
 773 {
 774     RETURN_STATUS_IF_NULL(pd3dDevice, E_FAIL);
 775 
 776     HRESULT res;
 777     DWORD bSE = FALSE;
 778     DWORD bDE = FALSE;
 779     DWORD flags = D3DCLEAR_TARGET;
 780 
 781     if (ignoreScissor) {
 782         // scissor test affects Clear so it needs to be disabled first
 783         pd3dDevice-&gt;GetRenderState(D3DRS_SCISSORTESTENABLE, &amp;bSE);
 784         if (bSE) {
 785             pd3dDevice-&gt;SetRenderState(D3DRS_SCISSORTESTENABLE, FALSE);
 786         }
 787     }
 788     if (clearDepth) {
 789         // Must ensure that there is a depth buffer before attempting to clear it
 790         IDirect3DSurface9 *pCurrentDepth = NULL;
 791         pd3dDevice-&gt;GetDepthStencilSurface(&amp;pCurrentDepth);
 792         clearDepth = pCurrentDepth == NULL ? FALSE : clearDepth;
 793         SAFE_RELEASE(pCurrentDepth);
 794     }
 795     if (clearDepth) {
 796         flags |= D3DCLEAR_ZBUFFER;
 797         // also make sure depth writes are enabled for the clear operation
 798         pd3dDevice-&gt;GetRenderState(D3DRS_ZWRITEENABLE, &amp;bDE);
 799         if (!bDE) {
 800             pd3dDevice-&gt;SetRenderState(D3DRS_ZWRITEENABLE, D3DZB_TRUE);
 801         }
 802     }
 803 
 804     res = pd3dDevice-&gt;Clear(0, NULL, flags, colorArgbPre, 1.0f, 0x0L);
 805 
 806     // restore previous state
 807     if (ignoreScissor &amp;&amp; bSE) {
 808         pd3dDevice-&gt;SetRenderState(D3DRS_SCISSORTESTENABLE, TRUE);
 809     }
 810     if (clearDepth &amp;&amp; !bDE) {
 811         pd3dDevice-&gt;SetRenderState(D3DRS_ZWRITEENABLE, D3DZB_FALSE);
 812     }
 813     return res;
 814 }
 815 
 816 BOOL D3DContext::IsDepthStencilBufferOk(D3DSURFACE_DESC *pTargetDesc, IDirect3DSurface9 *pTargetDepth)
 817 {
 818     TraceLn(NWT_TRACE_INFO, &quot;D3DContext::IsDepthStencilBufferOk&quot;);
 819 
 820     RETURN_STATUS_IF_NULL(pTargetDepth, true);
 821     RETURN_STATUS_IF_NULL(pd3dDevice, false);
 822     RETURN_STATUS_IF_NULL(pd3dObject, false);
 823 
 824     D3DSURFACE_DESC descStencil;
 825     pTargetDepth-&gt;GetDesc(&amp;descStencil);
 826 
 827     D3DDISPLAYMODE dm;
 828     return
 829         (SUCCEEDED(pd3dDevice-&gt;GetDisplayMode(0, &amp;dm)) &amp;&amp;
 830          pTargetDesc-&gt;Width &lt;= descStencil.Width &amp;&amp;
 831          pTargetDesc-&gt;Height &lt;= descStencil.Height &amp;&amp;
 832          pTargetDesc-&gt;MultiSampleType == descStencil.MultiSampleType &amp;&amp;
 833          pTargetDesc-&gt;MultiSampleQuality == descStencil.MultiSampleQuality &amp;&amp;
 834          SUCCEEDED(pd3dObject-&gt;CheckDepthStencilMatch(
 835                adapterOrdinal,
 836                devCaps.DeviceType,
 837                dm.Format, pTargetDesc-&gt;Format,
 838                descStencil.Format)));
 839 }
 840 
 841 HRESULT
 842 D3DContext::InitDepthStencilBuffer(D3DSURFACE_DESC *pTargetDesc, IDirect3DSurface9 **ppDepthSSurface)
 843 {
 844     TraceLn(NWT_TRACE_INFO, &quot;D3DContext::InitDepthStencilBuffer&quot;);
 845 
 846     RETURN_STATUS_IF_NULL(pd3dDevice, E_FAIL);
 847     RETURN_STATUS_IF_NULL(pTargetDesc, E_FAIL);
 848 
 849     HRESULT res;
 850     D3DDISPLAYMODE dm;
 851     if (FAILED(res = pd3dDevice-&gt;GetDisplayMode(0, &amp;dm))) {
 852         return res;
 853     }
 854 
 855     D3DFORMAT newFormat =
 856         D3DPipelineManager::GetInstance()-&gt;GetMatchingDepthStencilFormat(
 857             adapterOrdinal, dm.Format, pTargetDesc-&gt;Format);
 858 
 859     res = pd3dDevice-&gt;CreateDepthStencilSurface(
 860         pTargetDesc-&gt;Width, pTargetDesc-&gt;Height, newFormat,
 861         pTargetDesc-&gt;MultiSampleType, pTargetDesc-&gt;MultiSampleQuality, false, ppDepthSSurface, 0);
 862 
 863     return res;
 864 }
 865 
 866 HRESULT
 867 D3DContext::UpdateVertexShaderTX()
 868 {
 869     TraceLn(NWT_TRACE_INFO, &quot;D3DContext::UpdateVertexShaderTX&quot;);
 870 
 871     RETURN_STATUS_IF_NULL(pd3dDevice, E_FAIL);
 872 
 873     D3DMATRIX wvp;
 874     // create the WorldViewProj matrix
 875     // wvp = T(w * v * p);
 876     // since view is currently included in the projection matrix, wvp = T(w * p)
 877     D3DUtils_MatrixMultTransposed(wvp, world, projection);
 878     // Apply the pixel adjustment values for the current render target.
 879     // These values adjust our default (identity) coordinates so that the
 880     // pixel edges are at integer coordinate locations.
 881     wvp._14 += pixadjustx;
 882     wvp._24 += pixadjusty;
 883 
 884 //    fprintf(stderr, &quot;UpdateVertexShaderTX:\n&quot;);
 885 //    fprintf(stderr, &quot;  %5f %5f %5f %5f\n&quot;, wvp._11, wvp._12, wvp._13, wvp._14);
 886 //    fprintf(stderr, &quot;  %5f %5f %5f %5f\n&quot;, wvp._21, wvp._22, wvp._23, wvp._24);
 887 //    fprintf(stderr, &quot;  %5f %5f %5f %5f\n&quot;, wvp._31, wvp._32, wvp._33, wvp._34);
 888 //    fprintf(stderr, &quot;  %5f %5f %5f %5f\n&quot;, wvp._41, wvp._42, wvp._43, wvp._44);
 889 
 890     return pd3dDevice-&gt;SetVertexShaderConstantF(0, (float*)wvp.m, 4);
 891 }
 892 
 893 HRESULT
 894 D3DContext::SetRenderTarget(IDirect3DSurface9 *pSurface,
 895         IDirect3DSurface9 **ppTargetDepthSurface,
 896         BOOL depthBuffer, BOOL msaa)
 897 {
 898     TraceLn1(NWT_TRACE_INFO,
 899                 &quot;D3DContext::SetRenderTarget: pSurface=0x%x&quot;,
 900                 pSurface);
 901 
 902     RETURN_STATUS_IF_NULL(pd3dDevice, E_FAIL);
 903     RETURN_STATUS_IF_NULL(pSurface, E_FAIL);
 904 
 905     HRESULT res;
 906     D3DSURFACE_DESC descNew;
 907     IDirect3DSurface9 *pCurrentTarget;
 908     bool renderTargetChanged = false;
 909 
 910     pSurface-&gt;GetDesc(&amp;descNew);
 911 
 912     if (SUCCEEDED(res = pd3dDevice-&gt;GetRenderTarget(0, &amp;pCurrentTarget))) {
 913         if (pCurrentTarget != pSurface) {
 914             renderTargetChanged = true;
 915 #if defined PERF_COUNTERS
 916             getStats().numRenderTargetSwitch++;
 917 #endif
 918 
 919             if (FAILED(res = pd3dDevice-&gt;SetRenderTarget(0, pSurface))) {
 920                 DebugPrintD3DError(res, &quot;D3DContext::SetRenderTarget: &quot;\
 921                                         &quot;error setting render target&quot;);
 922                 SAFE_RELEASE(pCurrentTarget);
 923                 return res;
 924             }
 925 
 926             currentSurface = pSurface;
 927         }
 928         SAFE_RELEASE(pCurrentTarget);
 929 
 930         IDirect3DSurface9 *pCurrentDepth;
 931         res = pd3dDevice-&gt;GetDepthStencilSurface(&amp;pCurrentDepth);
 932         if (res == D3DERR_NOTFOUND) {
 933             pCurrentDepth = NULL;
 934             res = D3D_OK;
 935         } else if (FAILED(res)) {
 936             return res;
 937         }
 938 
 939         if (!IsDepthStencilBufferOk(&amp;descNew, *ppTargetDepthSurface)) {
 940             *ppTargetDepthSurface = NULL;
 941         }
 942         bool depthIsNew = false;
 943         if (depthBuffer &amp;&amp; (*ppTargetDepthSurface) == NULL) {
 944             if (FAILED(res = InitDepthStencilBuffer(&amp;descNew, ppTargetDepthSurface))) {
 945                 DebugPrintD3DError(res, &quot;D3DContext::SetRenderTarget: error creating new depth buffer&quot;);
 946                 return res;
 947             }
 948             depthIsNew = true;
 949         }
 950         if (pCurrentDepth != (*ppTargetDepthSurface)) {
 951             res = pd3dDevice-&gt;SetDepthStencilSurface(*ppTargetDepthSurface);
 952             if ((*ppTargetDepthSurface) != NULL &amp;&amp; depthIsNew) {
 953                 // Depth buffer must be cleared after it is created, also
 954                 // if depth buffer was not attached when render target was
 955                 // cleared, then the depth buffer will contain garbage
 956                 pd3dDevice-&gt;SetRenderState(D3DRS_ZWRITEENABLE, D3DZB_TRUE);
 957                 res = pd3dDevice-&gt;Clear(0, NULL, D3DCLEAR_ZBUFFER, NULL , 1.0f, 0x0L);
 958                 if (FAILED(res)) {
 959                     DebugPrintD3DError(res,
 960                             &quot;D3DContext::SetRenderTarget: error clearing depth buffer&quot;);
 961                 }
 962             }
 963         } else if (!renderTargetChanged) {
 964             SAFE_RELEASE(pCurrentDepth);
 965             return S_FALSE; // Indicates that call succeeded, but render target was not changed
 966         }
 967         SAFE_RELEASE(pCurrentDepth);
 968         pd3dDevice-&gt;SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, msaa);
 969     }
 970     // NOTE PRISM: changed to only recalculate the matrix if current target is
 971     // different for now
 972 
 973     // we set the transform even if the render target didn&#39;t change;
 974     // this is because in some cases (fs mode) we use the default SwapChain of
 975     // the device, and its render target will be the same as the device&#39;s, and
 976     // we have to set the matrix correctly. This shouldn&#39;t be a performance
 977     // issue as render target changes are relatively rare
 978 
 979     // By default D3D has integer device coordinates at the center of pixels
 980     // but we want integer device coordinates to be at the edges of pixels.
 981     // Additionally, its default viewport is set so that coordinates on a
 982     // surface map onto (-1, +1) -&gt; (+1, -1) as one moves from the upper left
 983     // corner to the lower right corner.  We need to move the values towards
 984     // -X and +Y by half a pixel using the following adjustment values:
 985     // half of (((+1) - (-1)) / dim), or half of (2 / dim) == (1 / dim).
 986     pixadjustx = -1.0f / descNew.Width;
 987     pixadjusty = +1.0f / descNew.Height;
 988     TraceLn1(NWT_TRACE_VERBOSE, &quot;  current render target=0x%x&quot;, pSurface);
 989     TraceLn2(NWT_TRACE_VERBOSE, &quot;      pixel adjustments=%f, %f&quot;, pixadjustx, pixadjusty);
 990     if (SUCCEEDED(res) &amp;&amp; !renderTargetChanged)
 991         return S_FALSE; // Indicates that call succeeded, but render target was not changed
 992     return res;
 993 }
 994 
 995 HRESULT
 996 D3DContext::SetCameraPosition(jdouble camPosX, jdouble camPosY, jdouble camPosZ)
 997 {
 998     float cPos[4];
 999     HRESULT res = S_OK;
1000     TraceLn(NWT_TRACE_INFO, &quot;D3DContext::SetCameraPosition&quot;);
1001 
1002     RETURN_STATUS_IF_NULL(pd3dDevice, E_FAIL);
1003 
1004     cPos[0] = (float) camPosX;
1005     cPos[1] = (float) camPosY;
1006     cPos[2] = (float) camPosZ;
1007     cPos[3] = 0;
1008 
1009     if (phongShader) {
1010         //    std::cerr &lt;&lt; &quot;Camera Position: &quot; &lt;&lt; cPos[0] &lt;&lt; &quot;, &quot; &lt;&lt; cPos[1] &lt;&lt; &quot;, &quot; &lt;&lt; cPos[2] &lt;&lt; std::endl;
1011         SUCCEEDED(res = pd3dDevice-&gt;SetVertexShaderConstantF(VSR_CAMERAPOS, cPos, 1));
1012     }
1013     return res;
1014 }
1015 
1016 HRESULT
1017 D3DContext::SetProjViewMatrix(BOOL depthTest,
1018                               jdouble m00, jdouble m01, jdouble m02, jdouble m03,
1019                               jdouble m10, jdouble m11, jdouble m12, jdouble m13,
1020                               jdouble m20, jdouble m21, jdouble m22, jdouble m23,
1021                               jdouble m30, jdouble m31, jdouble m32, jdouble m33)
1022 {
1023     D3DMATRIX mat;
1024     HRESULT res = S_OK;
1025 
1026     TraceLn(NWT_TRACE_INFO, &quot;D3DContext::SetProjViewMatrix&quot;);
1027     TraceLn1(NWT_TRACE_VERBOSE, &quot;  depthTest=%d&quot;, depthTest);
1028 
1029     RETURN_STATUS_IF_NULL(pd3dDevice, E_FAIL);
1030 
1031     projection._11 = (float)m00;    // Scale X
1032     projection._12 = (float)m10;    // Shear Y
1033     projection._13 = (float)m20;
1034     projection._14 = (float)m30;
1035 
1036     projection._21 = (float)m01;    // Shear X
1037     projection._22 = (float)m11;    // Scale Y
1038     projection._23 = (float)m21;
1039     projection._24 = (float)m31;
1040 
1041     projection._31 = (float)m02;
1042     projection._32 = (float)m12;
1043     projection._33 = (float)m22;
1044     projection._34 = (float)m32;
1045 
1046     projection._41 = (float)m03;    // Translate X
1047     projection._42 = (float)m13;    // Translate Y
1048     projection._43 = (float)m23;
1049     projection._44 = (float)m33;    // 1.0f;
1050 
1051     TraceLn4(NWT_TRACE_VERBOSE,
1052                 &quot;  %5f %5f %5f %5f&quot;, projection._11, projection._12, projection._13, projection._14);
1053     TraceLn4(NWT_TRACE_VERBOSE,
1054                 &quot;  %5f %5f %5f %5f&quot;, projection._21, projection._22, projection._23, projection._24);
1055     TraceLn4(NWT_TRACE_VERBOSE,
1056                 &quot;  %5f %5f %5f %5f&quot;, projection._31, projection._32, projection._33, projection._34);
1057     TraceLn4(NWT_TRACE_VERBOSE,
1058                 &quot;  %5f %5f %5f %5f&quot;, projection._41, projection._42, projection._43, projection._44);
1059 
1060 //    fprintf(stderr, &quot;SetProjViewMatrix: depthTest =  %d\n&quot;, depthTest);
1061 //    fprintf(stderr, &quot;  %5f %5f %5f %5f\n&quot;, projection._11, projection._12, projection._13, projection._14);
1062 //    fprintf(stderr, &quot;  %5f %5f %5f %5f\n&quot;, projection._21, projection._22, projection._23, projection._24);
1063 //    fprintf(stderr, &quot;  %5f %5f %5f %5f\n&quot;, projection._31, projection._32, projection._33, projection._34);
1064 //    fprintf(stderr, &quot;  %5f %5f %5f %5f\n&quot;, projection._41, projection._42, projection._43, projection._44);
1065 
1066     if (depthTest &amp;&amp; !this-&gt;depthTest) {
1067         pd3dDevice-&gt;SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
1068         pd3dDevice-&gt;SetRenderState(D3DRS_ZWRITEENABLE, D3DZB_TRUE);
1069         pd3dDevice-&gt;SetRenderState(D3DRS_ZFUNC, D3DCMP_LESSEQUAL);
1070     } else if (!depthTest &amp;&amp; this-&gt;depthTest) {
1071         pd3dDevice-&gt;SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
1072         pd3dDevice-&gt;SetRenderState(D3DRS_ZWRITEENABLE, D3DZB_FALSE);
1073     }
1074     this-&gt;depthTest = depthTest;
1075 
1076     if (phongShader) {
1077         D3DUtils_MatrixTransposed(mat, projection);
1078         SUCCEEDED(res = pd3dDevice-&gt;SetVertexShaderConstantF(VSR_VIEWPROJMATRIX, (float*) mat.m, 4));
1079     }
1080 
1081     return res;
1082 }
1083 
1084 void
1085 D3DContext::setWorldTransformIndentity() {
1086     TraceLn(NWT_TRACE_INFO, &quot;D3DContext::setWorldTransformIndentity&quot;);
1087 
1088     RETURN_IF_NULL(pd3dDevice);
1089 
1090     D3DUtils_SetIdentityMatrix(&amp;world);
1091 }
1092 
1093 void
1094 setWorldTx(D3DMATRIX &amp;mat, jdouble m00, jdouble m01, jdouble m02, jdouble m03,
1095             jdouble m10, jdouble m11, jdouble m12, jdouble m13,
1096             jdouble m20, jdouble m21, jdouble m22, jdouble m23,
1097             jdouble m30, jdouble m31, jdouble m32, jdouble m33) {
1098 
1099     mat._11 = (float)m00;     // Scale X
1100     mat._12 = (float)m10;     // Shear Y
1101     mat._13 = (float)m20;
1102     mat._14 = (float)m30;
1103 
1104     mat._21 = (float)m01;    // Shear X
1105     mat._22 = (float)m11;    // Scale Y
1106     mat._23 = (float)m21;
1107     mat._24 = (float)m31;
1108 
1109     mat._31 = (float)m02;
1110     mat._32 = (float)m12;
1111     mat._33 = (float)m22;
1112     mat._34 = (float)m32;
1113 
1114     mat._41 = (float)m03;    // Translate X
1115     mat._42 = (float)m13;    // Translate Y
1116     mat._43 = (float)m23;
1117     mat._44 = (float)m33;    // 1.0f;
1118 
1119     TraceLn4(NWT_TRACE_VERBOSE,
1120                 &quot;  %5f %5f %5f %5f&quot;, mat._11, mat._12, mat._13, mat._14);
1121     TraceLn4(NWT_TRACE_VERBOSE,
1122                 &quot;  %5f %5f %5f %5f&quot;, mat._21, mat._22, mat._23, mat._24);
1123     TraceLn4(NWT_TRACE_VERBOSE,
1124                 &quot;  %5f %5f %5f %5f&quot;, mat._31, mat._32, mat._33, mat._34);
1125     TraceLn4(NWT_TRACE_VERBOSE,
1126                 &quot;  %5f %5f %5f %5f&quot;, mat._41, mat._42, mat._43, mat._44);
1127 
1128 //    fprintf(stderr, &quot;World Matrix:\n&quot;);
1129 //    fprintf(stderr, &quot;  %5f %5f %5f %5f\n&quot;, mat._11, mat._12, mat._13, mat._14);
1130 //    fprintf(stderr, &quot;  %5f %5f %5f %5f\n&quot;, mat._21, mat._22, mat._23, mat._24);
1131 //    fprintf(stderr, &quot;  %5f %5f %5f %5f\n&quot;, mat._31, mat._32, mat._33, mat._34);
1132 //    fprintf(stderr, &quot;  %5f %5f %5f %5f\n&quot;, mat._41, mat._42, mat._43, mat._44);
1133 }
1134 
1135 void
1136 D3DContext::setWorldTransform(jdouble m00, jdouble m01, jdouble m02, jdouble m03,
1137             jdouble m10, jdouble m11, jdouble m12, jdouble m13,
1138             jdouble m20, jdouble m21, jdouble m22, jdouble m23,
1139             jdouble m30, jdouble m31, jdouble m32, jdouble m33) {
1140 
1141 //    std::cerr &lt;&lt; &quot;D3DContext::setWorldTransform&quot; &lt;&lt; std::endl;
1142     TraceLn(NWT_TRACE_INFO, &quot;D3DContext::setWorldTransform&quot;);
1143 
1144     RETURN_IF_NULL(pd3dDevice);
1145 
1146     setWorldTx(world,
1147             m00, m01, m02, m03,
1148             m10, m11, m12, m13,
1149             m20, m21, m22, m23,
1150             m30, m31, m32, m33);
1151 }
1152 
1153 HRESULT
1154 D3DContext::ResetTransform()
1155 {
1156     TraceLn(NWT_TRACE_INFO, &quot;D3DContext::ResetTransform&quot;);
1157 
1158     RETURN_STATUS_IF_NULL(pd3dDevice, E_FAIL);
1159 
1160     D3DUtils_SetIdentityMatrix(&amp;world);
1161     return UpdateVertexShaderTX();
1162 }
1163 
1164 HRESULT
1165 D3DContext::SetTransform(jdouble m00, jdouble m01, jdouble m02, jdouble m03,
1166                          jdouble m10, jdouble m11, jdouble m12, jdouble m13,
1167                          jdouble m20, jdouble m21, jdouble m22, jdouble m23,
1168                          jdouble m30, jdouble m31, jdouble m32, jdouble m33)
1169 
1170 {
1171 
1172 //    std::cerr &lt;&lt; &quot;D3DContext::SetTransform&quot; &lt;&lt; std::endl;
1173     TraceLn(NWT_TRACE_INFO, &quot;D3DContext::SetTransform&quot;);
1174 
1175     RETURN_STATUS_IF_NULL(pd3dDevice, E_FAIL);
1176 
1177     setWorldTx(world,
1178             m00, m01, m02, m03,
1179             m10, m11, m12, m13,
1180             m20, m21, m22, m23,
1181             m30, m31, m32, m33);
1182 
1183     return UpdateVertexShaderTX();
1184 }
1185 
1186 HRESULT
1187 D3DContext::SetRectClip(int x1, int y1, int x2, int y2)
1188 {
1189     TraceLn(NWT_TRACE_INFO, &quot;D3DContext::SetRectClip&quot;);
1190     TraceLn4(NWT_TRACE_VERBOSE,
1191                 &quot;  x1=%-4d y1=%-4d x2=%-4d y2=%-4d&quot;,
1192                 x1, y1, x2, y2);
1193 
1194     RETURN_STATUS_IF_NULL(pd3dDevice, E_FAIL);
1195 
1196     IDirect3DSurface9 *pCurrentTarget;
1197     HRESULT res = pd3dDevice-&gt;GetRenderTarget(0, &amp;pCurrentTarget);
1198     RETURN_STATUS_IF_FAILED(res);
1199 
1200     D3DSURFACE_DESC desc;
1201     pCurrentTarget-&gt;GetDesc(&amp;desc);
1202     SAFE_RELEASE(pCurrentTarget);
1203 
1204     if (x1 &lt;= 0 &amp;&amp; y1 &lt;= 0 &amp;&amp;
1205         (UINT)x2 &gt;= desc.Width &amp;&amp; (UINT)y2 &gt;= desc.Height)
1206     {
1207         TraceLn(NWT_TRACE_VERBOSE,
1208                    &quot;  disabling clip (== render target dimensions)&quot;);
1209         return pd3dDevice-&gt;SetRenderState(D3DRS_SCISSORTESTENABLE, FALSE);
1210     }
1211 
1212     // clip to the dimensions of the target surface, otherwise
1213     // SetScissorRect will fail
1214     if (x1 &lt; 0)                 x1 = 0;
1215     if (y1 &lt; 0)                 y1 = 0;
1216     if ((UINT)x2 &gt; desc.Width)  x2 = desc.Width;
1217     if ((UINT)y2 &gt; desc.Height) y2 = desc.Height;
1218     if (x1 &gt; x2)                x2 = x1 = 0;
1219     if (y1 &gt; y2)                y2 = y1 = 0;
1220     RECT newRect = { x1, y1, x2, y2 };
1221     if (SUCCEEDED(res = pd3dDevice-&gt;SetScissorRect(&amp;newRect))) {
1222         res = pd3dDevice-&gt;SetRenderState(D3DRS_SCISSORTESTENABLE, TRUE);
1223     } else {
1224         DebugPrintD3DError(res, &quot;Error setting scissor rect&quot;);
1225         RlsTraceLn4(NWT_TRACE_ERROR,
1226                        &quot;  x1=%-4d y1=%-4d x2=%-4d y2=%-4d&quot;,
1227                        x1, y1, x2, y2);
1228     }
1229 
1230     return res;
1231 }
1232 
1233 HRESULT
1234 D3DContext::ResetClip()
1235 {
1236     TraceLn(NWT_TRACE_INFO, &quot;D3DContext::ResetClip&quot;);
1237 
1238     RETURN_STATUS_IF_NULL(pd3dDevice, E_FAIL);
1239 
1240     return pd3dDevice-&gt;SetRenderState(D3DRS_SCISSORTESTENABLE, FALSE);
1241 }
1242 
1243 HRESULT D3DContext::BeginScene()
1244 {
1245     RETURN_STATUS_IF_NULL(pd3dDevice, E_FAIL);
1246 
1247     if (!bBeginScenePending) {
1248         bBeginScenePending = TRUE;
1249         HRESULT res = pd3dDevice-&gt;BeginScene();
1250         TraceLn(NWT_TRACE_INFO, &quot;D3DContext::BeginScene&quot;);
1251         return res;
1252     }
1253     return S_OK;
1254 }
1255 
1256 HRESULT D3DContext::EndScene()
1257 {
1258     if (bBeginScenePending) {
1259         bBeginScenePending = FALSE;
1260         TraceLn(NWT_TRACE_INFO, &quot;D3DContext::EndScene&quot;);
1261         return pd3dDevice-&gt;EndScene();
1262     }
1263     return S_OK;
1264 }
1265 
1266 HRESULT D3DContext::InitContextCaps() {
1267     if (!IsPow2TexturesOnly()) {
1268         RlsTraceLn(NWT_TRACE_VERBOSE, &quot;  CAPS_TEXNONPOW2&quot;);
1269     }
1270     if (!IsSquareTexturesOnly()) {
1271         RlsTraceLn(NWT_TRACE_VERBOSE, &quot;  CAPS_TEXNONSQUARE&quot;);
1272     }
1273     return S_OK;
1274 }
1275 
1276 IDirect3DTexture9 *createTexture(D3DFORMAT format, int w, int h, IDirect3DSurface9 **pSurface, IDirect3DDevice9 *dev) {
1277     IDirect3DTexture9 *texture;
1278     HRESULT hr = dev-&gt;CreateTexture(w, h, 1, D3DUSAGE_DYNAMIC, format, D3DPOOL_SYSTEMMEM, &amp;texture, 0);
1279     if (FAILED(hr)) {
1280         RlsTraceLn1(NWT_TRACE_ERROR, &quot;Failed to create system memory texture for update operation: %08X&quot;, hr);
1281         return NULL;
1282     }
1283     TraceLn3(NWT_TRACE_VERBOSE, &quot;Created system memory texture for update operation: %dx%d, format = %d&quot;, w, h, format);
1284     if (pSurface) {
1285         hr = texture-&gt;GetSurfaceLevel(0, pSurface);
1286         if (FAILED(hr)) {
1287             RlsTraceLn1(NWT_TRACE_ERROR, &quot;Failed to get surface for update operation: %08X&quot;, hr);
1288             SAFE_RELEASE(texture);
1289             return NULL;
1290         }
1291     }
1292     return texture;
1293 }
1294 
1295 IDirect3DTexture9 *D3DContext::TextureUpdateCache::getTexture(
1296     D3DFORMAT format, int w, int h, IDirect3DSurface9 **pSurface, IDirect3DDevice9 *dev)
1297 {
1298     if (w &lt;= width &amp;&amp; h &lt;= height &amp;&amp; texture != NULL) {
1299         if (pSurface) *pSurface = surface;
1300         return texture;
1301     }
1302     // grow the cache texture so that the new texture is
1303     // at least as large as the previous one
1304     if (w &lt; width)  w = width;
1305     if (h &lt; height) h = height;
1306     SAFE_RELEASE(surface);
1307     SAFE_RELEASE(texture);
1308     texture = createTexture(format, w, h, &amp;surface, dev);
1309     if (texture == NULL) {
1310         return NULL;
1311     }
1312     width = w;
1313     height = h;
1314     if (pSurface) *pSurface = surface;
1315     return texture;
1316 }
1317 
1318 IDirect3DTexture9 *D3DContext::getTextureCache(int formatIndex, D3DFORMAT format, int width, int height, IDirect3DSurface9 **pSurface) {
1319     if (formatIndex &lt; 0 || formatIndex &gt;= NUM_TEXTURE_CACHE) {
1320         return createTexture(format, width, height, pSurface, pd3dDevice);
1321     }
1322     TextureUpdateCache &amp;cache = textureCache[formatIndex];
1323     return cache.getTexture(format, width, height, pSurface, pd3dDevice);
1324 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>