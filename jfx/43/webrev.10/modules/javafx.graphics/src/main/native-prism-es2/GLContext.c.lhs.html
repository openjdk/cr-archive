<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/native-prism-es2/GLContext.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;jni.h&gt;
  27 #include &lt;stdlib.h&gt;
  28 #include &lt;assert.h&gt;
  29 #include &lt;stdio.h&gt;
  30 #include &lt;string.h&gt;
  31 #include &lt;math.h&gt;
  32 
  33 #include &quot;PrismES2Defs.h&quot;
  34 
  35 extern char *strJavaToC(JNIEnv *env, jstring str);
  36 
  37 void printGLError(GLenum errCode) {
  38     char const glCString[] = &quot;*** GLError Code = &quot;;
  39     switch (errCode) {
  40         case GL_NO_ERROR:
  41             //fprintf(stderr, &quot;%sGL_NO_ERROR\n&quot;, glCString);
  42             break;
  43         case GL_INVALID_ENUM:
  44             fprintf(stderr, &quot;%sGL_INVALID_ENUM\n&quot;, glCString);
  45             break;
  46         case GL_INVALID_VALUE:
  47             fprintf(stderr, &quot;%sGL_INVALID_VALUE\n&quot;, glCString);
  48             break;
  49         case GL_INVALID_OPERATION:
  50             fprintf(stderr, &quot;%sGL_INVALID_OPERATION\n&quot;, glCString);
  51             break;
  52         case GL_STACK_OVERFLOW:
  53             fprintf(stderr, &quot;%sGL_STACK_OVERFLOW\n&quot;, glCString);
  54             break;
  55         case GL_STACK_UNDERFLOW:
  56             fprintf(stderr, &quot;%sGL_STACK_UNDERFLOW\n&quot;, glCString);
  57             break;
  58         case GL_OUT_OF_MEMORY:
  59             fprintf(stderr, &quot;%sGL_OUT_OF_MEMORY\n&quot;, glCString);
  60             break;
  61         default:
  62             fprintf(stderr, &quot;%s*** UNKNOWN ERROR CODE ***\n&quot;, glCString);
  63     }
  64 }
  65 
  66 void initializeCtxInfo(ContextInfo *ctxInfo) {
  67     if (ctxInfo == NULL) {
  68         return;
  69     }
  70     // Initialize structure to all zeros
  71     memset(ctxInfo, 0, sizeof (ContextInfo));
  72 }
  73 
  74 void deleteCtxInfo(ContextInfo *ctxInfo) {
  75     if (ctxInfo == NULL) {
  76         return;
  77     }
  78 
  79     if (ctxInfo-&gt;versionStr != NULL) {
  80         free(ctxInfo-&gt;versionStr);
  81     }
  82     if (ctxInfo-&gt;vendorStr != NULL) {
  83         free(ctxInfo-&gt;vendorStr);
  84     }
  85     if (ctxInfo-&gt;rendererStr != NULL) {
  86         free(ctxInfo-&gt;rendererStr);
  87     }
  88     if (ctxInfo-&gt;glExtensionStr != NULL) {
  89         free(ctxInfo-&gt;glExtensionStr);
  90     }
  91 
  92 #ifdef WIN32 /* WIN32 */
  93     if (ctxInfo-&gt;wglExtensionStr != NULL) {
  94         free(ctxInfo-&gt;wglExtensionStr);
  95     }
  96     if (ctxInfo-&gt;hglrc != NULL) {
  97         wglDeleteContext(ctxInfo-&gt;hglrc);
  98         ctxInfo-&gt;hglrc = NULL;
  99     }
 100 #endif
 101 
 102 #ifdef UNIX
 103     if (ctxInfo-&gt;glxExtensionStr != NULL) {
 104         free(ctxInfo-&gt;glxExtensionStr);
 105     }
 106     if (ctxInfo-&gt;context != NULL) {
 107 #if defined(IS_GLX)
 108         glXDestroyContext(ctxInfo-&gt;display, ctxInfo-&gt;context);
 109 #endif
 110 #ifdef IS_EGL
 111         eglDestroyContext(ctxInfo-&gt;display, ctxInfo-&gt;context);
 112 #endif
 113     }
 114 #endif
 115     // Initialize structure to all zeros
 116     memset(ctxInfo, 0, sizeof (ContextInfo));
 117 }
 118 
 119 void initState(ContextInfo *ctxInfo) {
 120     if (ctxInfo == NULL) {
 121         return;
 122     }
 123 
 124     glEnable(GL_BLEND);
 125     glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
 126 
 127     // initialize states and properties to
 128     // match cached states and properties
 129 
 130     // depthtest is set to false
 131     // Note: This state is cached in GLContext.java
 132     ctxInfo-&gt;state.depthWritesEnabled = JNI_FALSE;
 133     glDepthMask(ctxInfo-&gt;state.depthWritesEnabled);
 134     glDisable(GL_DEPTH_TEST);
 135 
 136     if (ctxInfo-&gt;state.scissorEnabled) {
 137         ctxInfo-&gt;state.scissorEnabled = JNI_FALSE;
 138         glDisable(GL_SCISSOR_TEST);
 139     }
 140 
 141     ctxInfo-&gt;state.clearColor[0] = 0.0;
 142     ctxInfo-&gt;state.clearColor[1] = 0.0;
 143     ctxInfo-&gt;state.clearColor[2] = 0.0;
 144     ctxInfo-&gt;state.clearColor[3] = 0.0;
 145     glClearColor(ctxInfo-&gt;state.clearColor[0], ctxInfo-&gt;state.clearColor[1],
 146             ctxInfo-&gt;state.clearColor[2], ctxInfo-&gt;state.clearColor[3]);
 147 
 148     ctxInfo-&gt;vbFloatData = NULL;
 149     ctxInfo-&gt;vbByteData = NULL;
 150     ctxInfo-&gt;state.fillMode = GL_FILL;
 151     ctxInfo-&gt;state.cullEnable = JNI_FALSE;
 152     ctxInfo-&gt;state.cullMode = GL_BACK;
 153     ctxInfo-&gt;state.fbo = 0;
 154 }
 155 
 156 void clearBuffers(ContextInfo *ctxInfo,
 157         GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha,
 158         jboolean clearColor, jboolean clearDepth, jboolean ignoreScissor) {
 159     GLbitfield clearBIT = 0;
 160 
 161     if (ctxInfo == NULL) {
 162         return;
 163     }
 164 
 165     if (ignoreScissor &amp;&amp; ctxInfo-&gt;state.scissorEnabled) {
 166         // glClear() honors the current scissor, so disable it
 167         // temporarily if ignoreScissor is true
 168         glDisable(GL_SCISSOR_TEST);
 169     }
 170 
 171     if (clearColor) {
 172         clearBIT = GL_COLOR_BUFFER_BIT;
 173         if ((ctxInfo-&gt;state.clearColor[0] != red)
 174                 || (ctxInfo-&gt;state.clearColor[1] != green)
 175                 || (ctxInfo-&gt;state.clearColor[2] != blue)
 176                 || (ctxInfo-&gt;state.clearColor[3] != alpha)) {
 177             glClearColor(red, green, blue, alpha);
 178             ctxInfo-&gt;state.clearColor[0] = red;
 179             ctxInfo-&gt;state.clearColor[1] = green;
 180             ctxInfo-&gt;state.clearColor[2] = blue;
 181             ctxInfo-&gt;state.clearColor[3] = alpha;
 182         }
 183     }
 184 
 185     if (clearDepth) {
 186         clearBIT |= GL_DEPTH_BUFFER_BIT;
 187         // also make sure depth writes are enabled for the clear operation
 188         if (!ctxInfo-&gt;state.depthWritesEnabled) {
 189             glDepthMask(GL_TRUE);
 190         }
 191         glClear(clearBIT);
 192         if (!ctxInfo-&gt;state.depthWritesEnabled) {
 193             glDepthMask(GL_FALSE);
 194         }
 195     } else {
 196         glClear(clearBIT);
 197     }
 198 
 199     // restore previous state
 200     if (ignoreScissor &amp;&amp; ctxInfo-&gt;state.scissorEnabled) {
 201         glEnable(GL_SCISSOR_TEST);
 202     }
 203 }
 204 
 205 void bindFBO(ContextInfo *ctxInfo, GLuint fboId) {
 206     if ((ctxInfo == NULL) || (ctxInfo-&gt;glBindFramebuffer == NULL)) {
 207         return;
 208     }
 209     ctxInfo-&gt;glBindFramebuffer(GL_FRAMEBUFFER, fboId);
 210     ctxInfo-&gt;state.fbo = fboId;
 211 }
 212 
 213 /*
 214  * Class:     com_sun_prism_es2_GLContext
 215  * Method:    nActiveTexture
 216  * Signature: (JI)V
 217  */
 218 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nActiveTexture
 219 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint texUnit) {
 220     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
 221     if ((ctxInfo == NULL) || (ctxInfo-&gt;glActiveTexture == NULL)) {
 222         return;
 223     }
 224     ctxInfo-&gt;glActiveTexture(GL_TEXTURE0 + texUnit);
 225 }
 226 
 227 /*
 228  * Class:     com_sun_prism_es2_GLContext
 229  * Method:    nBindFBO
 230  * Signature: (JI)V
 231  */
 232 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nBindFBO
 233 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint fboId) {
 234     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
 235     bindFBO(ctxInfo, (GLuint)fboId);
 236 }
 237 
 238 /*
 239  * Class:     com_sun_prism_es2_GLContext
 240  * Method:    nBindTexture
 241  * Signature: (JI)V
 242  */
 243 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nBindTexture
 244 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint texID) {
 245     glBindTexture(GL_TEXTURE_2D, texID);
 246 }
 247 
 248 GLenum translateScaleFactor(jint scaleFactor) {
 249     switch (scaleFactor) {
 250         case com_sun_prism_es2_GLContext_GL_ZERO:
 251             return GL_ZERO;
 252         case com_sun_prism_es2_GLContext_GL_ONE:
 253             return GL_ONE;
 254         case com_sun_prism_es2_GLContext_GL_SRC_COLOR:
 255             return GL_SRC_COLOR;
 256         case com_sun_prism_es2_GLContext_GL_ONE_MINUS_SRC_COLOR:
 257             return GL_ONE_MINUS_SRC_COLOR;
 258         case com_sun_prism_es2_GLContext_GL_DST_COLOR:
 259             return GL_DST_COLOR;
 260         case com_sun_prism_es2_GLContext_GL_ONE_MINUS_DST_COLOR:
 261             return GL_ONE_MINUS_DST_COLOR;
 262         case com_sun_prism_es2_GLContext_GL_SRC_ALPHA:
 263             return GL_SRC_ALPHA;
 264         case com_sun_prism_es2_GLContext_GL_ONE_MINUS_SRC_ALPHA:
 265             return GL_ONE_MINUS_SRC_ALPHA;
 266         case com_sun_prism_es2_GLContext_GL_DST_ALPHA:
 267             return GL_DST_ALPHA;
 268         case com_sun_prism_es2_GLContext_GL_ONE_MINUS_DST_ALPHA:
 269             return GL_ONE_MINUS_DST_ALPHA;
 270         case com_sun_prism_es2_GLContext_GL_CONSTANT_COLOR:
 271             return GL_CONSTANT_COLOR;
 272         case com_sun_prism_es2_GLContext_GL_ONE_MINUS_CONSTANT_COLOR:
 273             return GL_ONE_MINUS_CONSTANT_COLOR;
 274         case com_sun_prism_es2_GLContext_GL_CONSTANT_ALPHA:
 275             return GL_CONSTANT_ALPHA;
 276         case com_sun_prism_es2_GLContext_GL_ONE_MINUS_CONSTANT_ALPHA:
 277             return GL_ONE_MINUS_CONSTANT_ALPHA;
 278         case com_sun_prism_es2_GLContext_GL_SRC_ALPHA_SATURATE:
 279             return GL_SRC_ALPHA_SATURATE;
 280         default:
 281             fprintf(stderr, &quot;Error: Unknown scale factor. Returning GL_ZERO (default)\n&quot;);
 282     }
 283     return GL_ZERO;
 284 }
 285 
 286 /*
 287  * Class:     com_sun_prism_es2_GLContext
 288  * Method:    nBlendFunc
 289  * Signature: (II)V
 290  */
 291 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nBlendFunc
 292 (JNIEnv *env, jclass class, jint sFactor, jint dFactor) {
 293     glBlendFunc(translateScaleFactor(sFactor), translateScaleFactor(dFactor));
 294 }
 295 
 296 /*
 297  * Class:     com_sun_prism_es2_GLContext
 298  * Method:    nClearBuffers
 299  * Signature: (JFFFFZZZ)V
 300  */
 301 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nClearBuffers
 302 (JNIEnv *env, jclass class, jlong nativeCtxInfo,
 303         jfloat red, jfloat green, jfloat blue, jfloat alpha,
 304         jboolean clearColor, jboolean clearDepth, jboolean ignoreScissor) {
 305     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
 306     if (ctxInfo == NULL) {
 307         return;
 308     }
 309 
 310     clearBuffers(ctxInfo,
 311             (GLclampf) red, (GLclampf) green, (GLclampf) blue, (GLclampf) alpha,
 312             clearColor, clearDepth, ignoreScissor);
 313 }
 314 
 315 int checkFramebufferStatus(ContextInfo *ctxInfo) {
 316     GLenum status;
 317     status = ctxInfo-&gt;glCheckFramebufferStatus(GL_FRAMEBUFFER);
 318     if (status != GL_FRAMEBUFFER_COMPLETE) {
 319         switch(status) {
 320             case GL_FRAMEBUFFER_COMPLETE:
 321                 return GL_FALSE;
 322                 break;
 323             case GL_FRAMEBUFFER_UNSUPPORTED:
 324             //Choose different formats
 325                 fprintf(stderr, &quot;Framebuffer object format is unsupported by the video hardware. (GL_FRAMEBUFFER_UNSUPPORTED)(FBO - 820)\n&quot;);
 326                 break;
 327             case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
 328                 fprintf(stderr, &quot;Incomplete attachment. (GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT)(FBO - 820)\n&quot;);
 329                 break;
 330             case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
 331                 fprintf(stderr, &quot;Incomplete missing attachment. (GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT)(FBO - 820)\n&quot;);
 332                 break;
 333             case GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT:
 334                 fprintf(stderr, &quot;Incomplete dimensions. (GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT)(FBO - 820)\n&quot;);
 335                 break;
 336             case GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT:
 337                 fprintf(stderr, &quot;Incomplete formats. (GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT)(FBO - 820)\n&quot;);
 338                 break;
 339             case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER:
 340                 fprintf(stderr, &quot;Incomplete draw buffer. (GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER)(FBO - 820)\n&quot;);
 341                 break;
 342             case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER:
 343                 fprintf(stderr, &quot;Incomplete read buffer. (GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER)(FBO - 820)\n&quot;);
 344                 break;
 345             case GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:
 346                 fprintf(stderr, &quot;Incomplete multisample buffer. (GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE)(FBO - 820)\n&quot;);
 347                 break;
 348             default:
 349                 //Programming error; will fail on all hardware
 350                 fprintf(stderr, &quot;Some video driver error or programming error occurred. Framebuffer object status is invalid. (FBO - 823)\n&quot;);
 351                 break;
 352         }
 353         return GL_TRUE;
 354     }
 355     return GL_FALSE;
 356 }
 357 
 358 /*
 359  * Class:     com_sun_prism_es2_GLContext
 360  * Method:    nBlit
 361  * Signature: (JIIIIIIIIII)V
 362  */
 363 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nBlit
 364 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint srcFBO, jint dstFBO,
 365             jint jsrcX0, jint jsrcY0, jint srcX1, jint srcY1,
 366             jint jdstX0, jint jdstY0, jint dstX1, jint dstY1) {
 367     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
 368     if ((ctxInfo == NULL) || (ctxInfo-&gt;glGenFramebuffers == NULL)
 369             || (ctxInfo-&gt;glBindFramebuffer == NULL)
 370             || (ctxInfo-&gt;glBlitFramebuffer == NULL)) {
 371         return;
 372     }
 373 
 374     // Temporarily disable scissor to avoid a problem with some GL drivers
 375     // that honor the scissor test if enabled
 376     if (ctxInfo-&gt;state.scissorEnabled) {
 377         glDisable(GL_SCISSOR_TEST);
 378     }
 379 
 380     if (dstFBO == 0) {
 381         dstFBO = ctxInfo-&gt;state.fbo;
 382     }
 383     //Bind the FBOs
 384     ctxInfo-&gt;glBindFramebuffer(GL_READ_FRAMEBUFFER, (GLuint)srcFBO);
 385     ctxInfo-&gt;glBindFramebuffer(GL_DRAW_FRAMEBUFFER, (GLuint)dstFBO);
 386     ctxInfo-&gt;glBlitFramebuffer(jsrcX0, jsrcY0, srcX1, srcY1,
 387                                jdstX0, jdstY0, dstX1, dstY1,
 388                                GL_COLOR_BUFFER_BIT, GL_LINEAR);
 389     /* TODO: iOS MSAA support:
 390      * We are using glBlitFramebuffer to &quot;resolve&quot; the mutlisample buffer,
 391      * to a color destination. iOS does things differently, it uses
 392      * glResolveMultisampleFramebufferAPPLE() in place of glBlit...
 393      * Problem is glResolve.. does not take arguments so we can&#39;t flip
 394      * coordinate system.
 395      */
 396 
 397     // Restore previous FBO
 398     ctxInfo-&gt;glBindFramebuffer(GL_FRAMEBUFFER, ctxInfo-&gt;state.fbo);
 399 
 400     // Restore previous scissor
 401     if (ctxInfo-&gt;state.scissorEnabled) {
 402         glEnable(GL_SCISSOR_TEST);
 403     }
 404 }
 405 
 406 GLuint attachRenderbuffer(ContextInfo *ctxInfo, GLuint rbID, GLenum attachment) {
 407     //GLenum status;
 408     ctxInfo-&gt;glFramebufferRenderbuffer(GL_FRAMEBUFFER, attachment,
 409             GL_RENDERBUFFER, rbID);
 410     ctxInfo-&gt;glBindRenderbuffer(GL_RENDERBUFFER, 0);
 411     //status = ctxInfo-&gt;glCheckFramebufferStatus(GL_FRAMEBUFFER);
 412     if (checkFramebufferStatus(ctxInfo)) {
 413         ctxInfo-&gt;glDeleteRenderbuffers(1, &amp;rbID);
 414         rbID = 0;
 415         fprintf(stderr, &quot;Error creating render buffer object %d\n&quot;, rbID);
 416     } else {
 417         // explicitly clear the render buffers, since it may contain
 418         // garbage after initialization
 419         clearBuffers(ctxInfo, 0, 0, 0, 0, JNI_FALSE, JNI_TRUE, JNI_TRUE);
 420     }
 421     return rbID;
 422 }
 423 
 424 GLuint createAndAttachRenderBuffer(ContextInfo *ctxInfo, GLsizei width, GLsizei height, GLsizei msaa, GLenum attachment) {
 425     GLuint rbID;
 426     GLenum internalFormat;
 427 
 428     if ((ctxInfo == NULL) || (ctxInfo-&gt;glGenRenderbuffers == NULL)
 429             || (ctxInfo-&gt;glBindRenderbuffer == NULL)
 430             || (ctxInfo-&gt;glRenderbufferStorage == NULL)
 431             || (ctxInfo-&gt;glFramebufferRenderbuffer == NULL)
 432 #ifndef IS_EGL
 433             || (ctxInfo-&gt;glRenderbufferStorageMultisample == NULL)
 434 #endif
 435             || (ctxInfo-&gt;glCheckFramebufferStatus == NULL)
 436             || (ctxInfo-&gt;glDeleteRenderbuffers == NULL)) {
 437         return 0;
 438     }
 439 
 440     if (attachment == GL_DEPTH_ATTACHMENT) {
 441 #ifdef IS_EGL
 442         internalFormat = GL_DEPTH_COMPONENT16;
 443 #else
 444         internalFormat = GL_DEPTH_COMPONENT;
 445 #endif
 446     } else {
 447         internalFormat = GL_RGBA8; //TODO verify format on RGBA or RGBA8
 448     }
 449     // create a depth buffer
 450     ctxInfo-&gt;glGenRenderbuffers(1, &amp;rbID);
 451     ctxInfo-&gt;glBindRenderbuffer(GL_RENDERBUFFER, rbID);
 452 #ifdef IS_EGL
 453     ctxInfo-&gt;glRenderbufferStorage(GL_RENDERBUFFER, internalFormat, width, height);
 454 #else
 455     if (msaa) {
 456         ctxInfo-&gt;glRenderbufferStorageMultisample(GL_RENDERBUFFER, msaa, internalFormat, width, height);
 457     } else {
 458         ctxInfo-&gt;glRenderbufferStorage(GL_RENDERBUFFER, internalFormat, width, height);
 459     }
 460 #endif
 461     return attachRenderbuffer(ctxInfo, rbID, attachment);
 462 }
 463 
 464 /*
 465  * Class:     com_sun_prism_es2_GLContext
 466  * Method:    nCreateDepthBuffer
 467  * Signature: (JIII)I
 468  */
 469 JNIEXPORT jint JNICALL Java_com_sun_prism_es2_GLContext_nCreateDepthBuffer
 470 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint width, jint height, jint msaa) {
 471     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
 472     return createAndAttachRenderBuffer(ctxInfo, width, height, msaa, GL_DEPTH_ATTACHMENT);
 473 }
 474 
 475 /*
 476  * Class:     com_sun_prism_es2_GLContext
 477  * Method:    nCreateRenderBuffer
 478  * Signature: (JIII)I
 479  */
 480 JNIEXPORT jint JNICALL Java_com_sun_prism_es2_GLContext_nCreateRenderBuffer
 481 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint width, jint height, jint msaa) {
 482     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
 483     return createAndAttachRenderBuffer(ctxInfo, width, height, msaa, GL_COLOR_ATTACHMENT0);
 484 }
 485 
 486 /*
 487  * Class:     com_sun_prism_es2_GLContext
 488  * Method:    nCreateFBO
 489  * Signature: (JI)I
 490  */
 491 JNIEXPORT jint JNICALL Java_com_sun_prism_es2_GLContext_nCreateFBO
 492 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint texID) {
 493     GLuint fboID;
 494 
 495     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
 496     if ((ctxInfo == NULL) || (ctxInfo-&gt;glGenFramebuffers == NULL)
 497             || (ctxInfo-&gt;glFramebufferTexture2D == NULL)
 498             || (ctxInfo-&gt;glCheckFramebufferStatus == NULL)
 499             || (ctxInfo-&gt;glDeleteFramebuffers == NULL)) {
 500         return 0;
 501     }
 502 
 503     // initialize framebuffer object
 504     ctxInfo-&gt;glGenFramebuffers(1, &amp;fboID);
 505     bindFBO(ctxInfo, fboID);
 506 
 507     if (texID) {
 508         // Attach color texture to framebuffer object
 509         ctxInfo-&gt;glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
 510                                         GL_TEXTURE_2D, (GLuint)texID, 0);
 511         // Can&#39;t check status of FBO until after a buffer is attached to it
 512         if (checkFramebufferStatus(ctxInfo)) {
 513             ctxInfo-&gt;glDeleteFramebuffers(1, &amp;fboID);
 514             fprintf(stderr,
 515                     &quot;Error creating framebuffer object with TexID %d)\n&quot;, (int) texID);
 516             return 0;
 517         }
 518         // explicitly clear the color buffer, since it may contain garbage
 519         // after initialization
 520         clearBuffers(ctxInfo, 0, 0, 0, 0, JNI_TRUE, JNI_FALSE, JNI_TRUE);
 521     }
 522 
 523     return (jint)fboID;
 524 }
 525 
 526 /*
 527  * Class:     com_sun_prism_es2_GLContext
 528  * Method:    nCreateProgram
 529  * Signature: (JI[II[Ljava/lang/String;[I)I
 530  */
 531 JNIEXPORT jint JNICALL Java_com_sun_prism_es2_GLContext_nCreateProgram
 532 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint vertID, jintArray fragIDArr,
 533         jint numAttrs, jobjectArray attrs, jintArray indexs) {
 534     GLuint shaderProgram;
 535     GLint success;
 536     int i;
 537     jstring attrName;
 538     jint *indexsPtr;
 539     char *attrNameString;
 540     jint *fragIDs;
 541     jsize length;
 542     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
 543     if ((ctxInfo == NULL) || (attrs == NULL) || (indexs == NULL)
 544             || (ctxInfo-&gt;glCreateProgram == NULL)
 545             || (ctxInfo-&gt;glAttachShader == NULL)
 546             || (ctxInfo-&gt;glBindAttribLocation == NULL)
 547             || (ctxInfo-&gt;glLinkProgram == NULL)
 548             || (ctxInfo-&gt;glGetProgramiv == NULL)
 549             || (ctxInfo-&gt;glGetProgramInfoLog == NULL)
 550             || (ctxInfo-&gt;glDetachShader == NULL)
 551             || (ctxInfo-&gt;glDeleteShader == NULL)
 552             || (ctxInfo-&gt;glDeleteProgram == NULL)) {
 553         return 0;
 554     }
 555 
 556     if (fragIDArr != NULL) {
 557         length = (*env)-&gt;GetArrayLength(env, fragIDArr);
 558         fragIDs = (*env)-&gt;GetIntArrayElements(env, fragIDArr, NULL);
 559     } else {
 560         return 0;
 561     }
 562     // create the program object and attach it to the shader
 563     shaderProgram = ctxInfo-&gt;glCreateProgram();
 564     ctxInfo-&gt;glAttachShader(shaderProgram, vertID);
 565     for (i = 0; i &lt; length; i++) {
 566         ctxInfo-&gt;glAttachShader(shaderProgram, fragIDs[i]);
 567     }
 568 
 569     // bind any user-defined index values to their corresponding names
 570     indexsPtr = (*env)-&gt;GetIntArrayElements(env, indexs, NULL);
 571     for (i = 0; i &lt; numAttrs; i++) {
 572         attrName = (*env)-&gt;GetObjectArrayElement(env, attrs, i);
 573         attrNameString = strJavaToC(env, attrName);
 574         ctxInfo-&gt;glBindAttribLocation(shaderProgram, indexsPtr[i], attrNameString);
 575         free(attrNameString);
 576     }
 577 
 578     // link the program
 579     ctxInfo-&gt;glLinkProgram(shaderProgram);
 580     ctxInfo-&gt;glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);
 581 
 582     if (success == GL_FALSE) {
 583         GLint  length;
 584 
 585         ctxInfo-&gt;glGetProgramiv(shaderProgram, GL_INFO_LOG_LENGTH, &amp;length);
 586         if (length) {
 587             char* msg  =  (char *) malloc(length * sizeof(char));
 588             ctxInfo-&gt;glGetProgramInfoLog(shaderProgram, length, NULL, msg);
 589             fprintf(stderr, &quot;Program link log: %.*s\n&quot;, length, msg);
 590             free(msg);
 591         } else {
 592             fprintf(stderr, &quot;glLinkProgram: GL_LINK_STATUS returns GL_FALSE but GL_INFO_LOG_LENGTH returns 0\n&quot;);
 593         }
 594 
 595         ctxInfo-&gt;glDetachShader(shaderProgram, vertID);
 596         ctxInfo-&gt;glDeleteShader(vertID);
 597         for(i = 0; i &lt; length; i++) {
 598             ctxInfo-&gt;glDetachShader(shaderProgram, fragIDs[i]);
 599             ctxInfo-&gt;glDeleteShader(fragIDs[i]);
 600         }
 601         ctxInfo-&gt;glDeleteProgram(shaderProgram);
 602         return 0;
 603     }
 604 
 605     (*env)-&gt;ReleaseIntArrayElements(env, fragIDArr, fragIDs, JNI_ABORT);
 606 
 607     return shaderProgram;
 608 }
 609 
 610 /*
 611  * Class:     com_sun_prism_es2_GLContext
 612  * Method:    nCompileShader
 613  * Signature: (JLjava/lang/String;Z)I
 614  */
 615 JNIEXPORT jint JNICALL Java_com_sun_prism_es2_GLContext_nCompileShader
 616 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jstring src, jboolean vertex) {
 617     GLenum shaderType;
 618     GLuint shaderID;
 619     GLint success;
 620 
 621     /* Null-terminated &quot;C&quot; strings */
 622     GLchar *shaderString = NULL;
 623     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
 624     if ((ctxInfo == NULL) || (src == NULL)
 625             || (ctxInfo-&gt;glCreateShader == NULL)
 626             || (ctxInfo-&gt;glShaderSource == NULL)
 627             || (ctxInfo-&gt;glCompileShader == NULL)
 628             || (ctxInfo-&gt;glGetShaderiv == NULL)
 629             || (ctxInfo-&gt;glGetShaderInfoLog == NULL)
 630             || (ctxInfo-&gt;glDeleteShader == NULL)) {
 631         return 0;
 632     }
 633 
 634     // create the shader object and compile the shader source code
 635     shaderType = vertex ? GL_VERTEX_SHADER : GL_FRAGMENT_SHADER;
 636     shaderID = ctxInfo-&gt;glCreateShader(shaderType);
 637     shaderString = (GLchar *) strJavaToC(env, src);
 638     if (shaderString == NULL) {
 639         /* Just return, since strJavaToC will throw OOM if it returns NULL */
 640         return 0;
 641     }
 642     ctxInfo-&gt;glShaderSource(shaderID, 1, (const GLchar **) &amp;shaderString, (GLint *) NULL);
 643     ctxInfo-&gt;glCompileShader(shaderID);
 644     ctxInfo-&gt;glGetShaderiv(shaderID, GL_COMPILE_STATUS, &amp;success);
 645 
 646     free(shaderString);
 647 
 648     if (success == GL_FALSE) {
 649         GLint  length;
 650 
 651         ctxInfo-&gt;glGetShaderiv(shaderID, GL_INFO_LOG_LENGTH, &amp;length);
 652         if (length) {
 653             char* msg = (char *) malloc(length * sizeof(char));
 654             ctxInfo-&gt;glGetShaderInfoLog(shaderID, length, NULL, msg);
 655             fprintf(stderr, &quot;Shader compile log: %.*s\n&quot;, length, msg);
 656             free(msg);
 657         } else {
 658             fprintf(stderr, &quot;glCompileShader: GL_COMPILE_STATUS returns GL_FALSE but GL_INFO_LOG_LENGTH returns 0\n&quot;);
 659         }
 660 
 661         ctxInfo-&gt;glDeleteShader(shaderID);
 662         return 0;
 663     }
 664 
 665     return shaderID;
 666 }
 667 
 668 /*
 669  * Class:     com_sun_prism_es2_GLContext
 670  * Method:    nCreateTexture
 671  * Signature: (JII)I
 672  */
 673 JNIEXPORT jint JNICALL Java_com_sun_prism_es2_GLContext_nCreateTexture
 674 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint width, jint height) {
 675     GLuint texID = 0;
 676     GLenum err;
 677 
 678     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
 679     if ((ctxInfo == NULL) || (ctxInfo-&gt;glActiveTexture == NULL)) {
 680         return 0;
 681     }
 682 
 683     glGenTextures(1, &amp;texID);
 684     if (texID == 0) {
 685         // fprintf(stderr, &quot;nCreateTexture: Failed to generate texture.\n&quot;);
 686         return (jint) texID;
 687     }
 688 
 689     glBindTexture(GL_TEXTURE_2D, texID);
 690 
 691     // Reset Error
 692     glGetError();
 693     glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height,
 694             0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
 695 
 696     err  = glGetError();
 697     // printGLError(err);
 698 
 699     if (err != GL_NO_ERROR) {
 700         glDeleteTextures(1, &amp;texID);
 701         texID = 0;
 702     } else {
 703         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 704         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
 705     }
 706     return (jint) texID;
 707 }
 708 
 709 /*
 710  * Class:     com_sun_prism_es2_GLContext
 711  * Method:    nDisposeShaders
 712  * Signature: (JII[I)V
 713  */
 714 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nDisposeShaders
 715 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint shaderProgram,
 716         jint vertID, jintArray fragIDArr) {
 717     jsize length;
 718     jint* fragIDs;
 719     int i;
 720     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
 721     if ((ctxInfo == NULL) || (ctxInfo-&gt;glDetachShader == NULL)
 722             || (ctxInfo-&gt;glDeleteShader == NULL)
 723             || (ctxInfo-&gt;glDeleteProgram == NULL)) {
 724         return;
 725     }
 726 
 727     if (vertID != 0) {
 728         ctxInfo-&gt;glDetachShader(shaderProgram, vertID);
 729         ctxInfo-&gt;glDeleteShader(vertID);
 730     }
 731 
 732     if (fragIDArr == NULL) {
 733         return;
 734     }
 735 
 736     length = (*env)-&gt;GetArrayLength(env, fragIDArr);
 737     fragIDs = (*env)-&gt;GetIntArrayElements(env, fragIDArr, NULL);
 738 
 739     for (i = 0; i &lt; length; i++) {
 740         if (fragIDs[i] != 0) {
 741             ctxInfo-&gt;glDetachShader(shaderProgram, fragIDs[i]);
 742             ctxInfo-&gt;glDeleteShader(fragIDs[i]);
 743         }
 744     }
 745 
 746     (*env)-&gt;ReleaseIntArrayElements(env, fragIDArr, fragIDs, JNI_ABORT);
 747 
 748     ctxInfo-&gt;glDeleteProgram(shaderProgram);
 749 }
 750 
 751 /*
 752  * Class:     com_sun_prism_es2_GLContext
 753  * Method:    nDeleteFBO
 754  * Signature: (JI)V
 755  */
 756 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nDeleteFBO
 757 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint fboID) {
 758     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
 759     if ((ctxInfo == NULL) || (ctxInfo-&gt;glDeleteFramebuffers == NULL)) {
 760         return;
 761     }
 762     if (fboID != 0) {
 763         ctxInfo-&gt;glDeleteFramebuffers(1, (GLuint *) &amp;fboID);
 764     }
 765 }
 766 
 767 /*
 768  * Class:     com_sun_prism_es2_GLContext
 769  * Method:    nDeleteRenderBuffer
 770  * Signature: (JI)V
 771  */
 772 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nDeleteRenderBuffer
 773 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint rbID) {
 774     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
 775     if ((ctxInfo == NULL) || (ctxInfo-&gt;glDeleteRenderbuffers == NULL)) {
 776         return;
 777     }
 778     if (rbID != 0) {
 779         ctxInfo-&gt;glDeleteRenderbuffers(1, (GLuint *) &amp;rbID);
 780     }
 781 }
 782 
 783 /*
 784  * Class:     com_sun_prism_es2_GLContext
 785  * Method:    nDeleteShader
 786  * Signature: (JI)V
 787  */
 788 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nDeleteShader
 789 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint shaderID) {
 790     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
 791     if ((ctxInfo == NULL) || (ctxInfo-&gt;glDeleteShader == NULL)) {
 792         return;
 793     }
 794     if (shaderID != 0) {
 795         ctxInfo-&gt;glDeleteShader(shaderID);
 796     }
 797 }
 798 
 799 /*
 800  * Class:     com_sun_prism_es2_GLContext
 801  * Method:    nDeleteTexture
 802  * Signature: (JI)V
 803  */
 804 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nDeleteTexture
 805 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint texID) {
 806     GLuint tID = (GLuint) texID;
 807     if (tID != 0) {
 808         glDeleteTextures(1, &amp;tID);
 809     }
 810 }
 811 
 812 /*
 813  * Class:     com_sun_prism_es2_GLContext
 814  * Method:    nFinish
 815  * Signature: ()V
 816  */
 817 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nFinish
 818 (JNIEnv *env, jclass class) {
 819     glFinish();
 820 }
 821 
 822 /*
 823  * Class:     com_sun_prism_es2_GLContext
 824  * Method:    nGenAndBindTexture
 825  * Signature: ()I
 826  */
 827 JNIEXPORT jint JNICALL Java_com_sun_prism_es2_GLContext_nGenAndBindTexture
 828 (JNIEnv *env, jclass class) {
 829     GLuint texID;
 830     glGenTextures(1, &amp;texID);
 831     glBindTexture(GL_TEXTURE_2D, texID);
 832     return texID;
 833 }
 834 
 835 /*
 836  * Class:     com_sun_prism_es2_GLContext
 837  * Method:    nGetFBO
 838  * Signature: ()I
 839  */
 840 JNIEXPORT jint JNICALL Java_com_sun_prism_es2_GLContext_nGetFBO
 841 (JNIEnv *env, jclass class) {
 842     GLint param;
 843     /* The caching logic has been done on Java side if
 844      * platform isn&#39;t MAC or IOS. On these platforms Glass
 845      * can change the FBO under us. We should be able to simplify the
 846      * logic in Java and remove this method once once Glass stop doing it.
 847      */
 848     glGetIntegerv(GL_FRAMEBUFFER_BINDING, &amp;param);
 849     return (jint) param;
 850 }
 851 
 852 /*
 853  * Class:     com_sun_prism_es2_GLContext
 854  * Method:    nGetMaxSampleSize
 855  * Signature: ()I
 856  */
 857 JNIEXPORT jint JNICALL Java_com_sun_prism_es2_GLContext_nGetMaxSampleSize
 858 (JNIEnv *env, jclass class) {
 859     GLint samples;
 860     glGetIntegerv(GL_MAX_SAMPLES, &amp;samples);
 861     return (jint)samples;
 862 }
 863 
 864 /*
 865  * Class:     com_sun_prism_es2_GLContext
 866  * Method:    nGetUniformLocation
 867  * Signature: (JILjava/lang/String;)I
 868  */
 869 JNIEXPORT jint JNICALL Java_com_sun_prism_es2_GLContext_nGetUniformLocation
 870 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint programID, jstring name) {
 871     GLint result;
 872     char *nameString;
 873     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
 874 
 875     if ((ctxInfo == NULL) || (name == NULL)
 876             || (ctxInfo-&gt;glGetUniformLocation == NULL)) {
 877         return 0;
 878     }
 879 
 880     nameString = strJavaToC(env, name);
 881     result = ctxInfo-&gt;glGetUniformLocation(programID, nameString);
 882     free(nameString);
 883     return result;
 884 }
 885 
 886 int translatePrismToGL(int value) {
 887     switch (value) {
 888         case com_sun_prism_es2_GLContext_GL_FLOAT:
 889             return GL_FLOAT;
 890         case com_sun_prism_es2_GLContext_GL_UNSIGNED_BYTE:
 891             return GL_UNSIGNED_BYTE;
 892         case com_sun_prism_es2_GLContext_GL_UNSIGNED_INT_8_8_8_8_REV:
 893             return GL_UNSIGNED_INT_8_8_8_8_REV;
 894         case com_sun_prism_es2_GLContext_GL_UNSIGNED_INT_8_8_8_8:
 895             return GL_UNSIGNED_INT_8_8_8_8;
 896         case com_sun_prism_es2_GLContext_GL_UNSIGNED_SHORT_8_8_APPLE:
 897             /* not using symbolic name may not be available on all platform - DrD*/
 898             return 0x85BA;
 899 
 900         case com_sun_prism_es2_GLContext_GL_RGBA:
 901             return GL_RGBA;
 902         case com_sun_prism_es2_GLContext_GL_BGRA:
 903             return GL_BGRA;
 904         case com_sun_prism_es2_GLContext_GL_RGB:
 905             return GL_RGB;
 906         case com_sun_prism_es2_GLContext_GL_LUMINANCE:
 907             return GL_LUMINANCE;
 908         case com_sun_prism_es2_GLContext_GL_ALPHA:
 909             return GL_ALPHA;
 910         case com_sun_prism_es2_GLContext_GL_RGBA32F:
 911             return GL_RGBA32F;
 912         case com_sun_prism_es2_GLContext_GL_YCBCR_422_APPLE:
 913             /* not using symbolic name may not be available on all platform - DrD*/
 914             return 0x85B9;
 915 
 916         case com_sun_prism_es2_GLContext_GL_TEXTURE_2D:
 917             return GL_TEXTURE_2D;
 918         case com_sun_prism_es2_GLContext_GL_TEXTURE_BINDING_2D:
 919             return GL_TEXTURE_BINDING_2D;
 920         case com_sun_prism_es2_GLContext_GL_NEAREST:
 921             return GL_NEAREST;
 922         case com_sun_prism_es2_GLContext_GL_LINEAR:
 923             return GL_LINEAR;
 924         case com_sun_prism_es2_GLContext_GL_NEAREST_MIPMAP_NEAREST:
 925             return GL_NEAREST_MIPMAP_NEAREST;
 926         case com_sun_prism_es2_GLContext_GL_LINEAR_MIPMAP_LINEAR:
 927             return GL_LINEAR_MIPMAP_LINEAR;
 928 
 929         case com_sun_prism_es2_GLContext_WRAPMODE_REPEAT:
 930             return GL_REPEAT;
 931         case com_sun_prism_es2_GLContext_WRAPMODE_CLAMP_TO_EDGE:
 932             return GL_CLAMP_TO_EDGE;
 933         case com_sun_prism_es2_GLContext_WRAPMODE_CLAMP_TO_BORDER:
 934             return GL_CLAMP_TO_BORDER;
 935 
 936         case com_sun_prism_es2_GLContext_GL_MAX_FRAGMENT_UNIFORM_COMPONENTS:
 937             return GL_MAX_FRAGMENT_UNIFORM_COMPONENTS;
 938         case com_sun_prism_es2_GLContext_GL_MAX_FRAGMENT_UNIFORM_VECTORS:
 939             return GL_MAX_FRAGMENT_UNIFORM_VECTORS;
 940         case com_sun_prism_es2_GLContext_GL_MAX_TEXTURE_IMAGE_UNITS:
 941             return GL_MAX_TEXTURE_IMAGE_UNITS;
 942         case com_sun_prism_es2_GLContext_GL_MAX_TEXTURE_SIZE:
 943             return GL_MAX_TEXTURE_SIZE;
 944         case com_sun_prism_es2_GLContext_GL_MAX_VARYING_COMPONENTS:
 945             return GL_MAX_VARYING_COMPONENTS;
 946         case com_sun_prism_es2_GLContext_GL_MAX_VARYING_VECTORS:
 947             return GL_MAX_VARYING_VECTORS;
 948         case com_sun_prism_es2_GLContext_GL_MAX_VERTEX_ATTRIBS:
 949             return GL_MAX_VERTEX_ATTRIBS;
 950         case com_sun_prism_es2_GLContext_GL_MAX_VERTEX_UNIFORM_COMPONENTS:
 951             return GL_MAX_VERTEX_UNIFORM_COMPONENTS;
 952         case com_sun_prism_es2_GLContext_GL_MAX_VERTEX_UNIFORM_VECTORS:
 953             return GL_MAX_VERTEX_UNIFORM_VECTORS;
 954         case com_sun_prism_es2_GLContext_GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS:
 955             return GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS;
 956 
 957         default:
 958             fprintf(stderr, &quot;warning: Unknown value. Returning value = %d\n&quot;, value);
 959     }
 960     return value;
 961 }
 962 
 963 GLint translatePixelStore(int pname) {
 964     switch (pname) {
 965             // Use by glPixelStorei
 966         case com_sun_prism_es2_GLContext_GL_UNPACK_ALIGNMENT:
 967             return GL_UNPACK_ALIGNMENT;
 968         case com_sun_prism_es2_GLContext_GL_UNPACK_ROW_LENGTH:
 969             return GL_UNPACK_ROW_LENGTH;
 970         case com_sun_prism_es2_GLContext_GL_UNPACK_SKIP_PIXELS:
 971             return GL_UNPACK_SKIP_PIXELS;
 972         case com_sun_prism_es2_GLContext_GL_UNPACK_SKIP_ROWS:
 973             return GL_UNPACK_SKIP_ROWS;
 974 
 975         default:
 976             fprintf(stderr, &quot;warning: Unknown pname. Returning pname = %d\n&quot;, pname);
 977     }
 978     return (GLint) pname;
 979 }
 980 
 981 /*
 982  * Class:     com_sun_prism_es2_GLContext
 983  * Method:    nGetIntParam
 984  * Signature: (I)I
 985  */
 986 JNIEXPORT jint JNICALL Java_com_sun_prism_es2_GLContext_nGetIntParam
 987 (JNIEnv *env, jclass class, jint pname) {
 988     GLint param;
 989 
 990     glGetIntegerv((GLenum) translatePrismToGL(pname), &amp;param);
 991     return (jint) param;
 992 }
 993 
 994 /*
 995  * Class:     com_sun_prism_es2_GLContext
 996  * Method:    nPixelStorei
 997  * Signature: (II)V
 998  */
 999 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nPixelStorei
1000 (JNIEnv *env, jclass class, jint pname, jint value) {
1001     glPixelStorei((GLenum) translatePixelStore(pname), (GLint) value);
1002 }
1003 
1004 jboolean doReadPixels(JNIEnv *env, jlong nativeCtxInfo, jint length, jobject buffer,
1005         jarray pixelArr, jint x, jint y, jint width, jint height) {
1006     GLvoid *ptr = NULL;
1007 
1008     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1009     if (ctxInfo == NULL) {
1010         fprintf(stderr, &quot;doReadPixels: ctxInfo is NULL\n&quot;);
1011         return JNI_FALSE;
1012     }
1013 
1014     // sanity check, do we have enough memory
1015     // length, width and height are non-negative
1016     if ((length / 4 / width) &lt; height) {
1017         fprintf(stderr, &quot;doReadPixels: pixel buffer too small - length = %d\n&quot;,
1018                 (int) length);
1019         return JNI_FALSE;
1020     }
1021 
1022     ptr = (GLvoid *) (pixelArr ?
1023             ((char *) (*env)-&gt;GetPrimitiveArrayCritical(env, pixelArr, NULL)) :
1024             ((char *) (*env)-&gt;GetDirectBufferAddress(env, buffer)));
1025 
1026     if (ptr == NULL) {
1027         fprintf(stderr, &quot;doReadPixels: pixel buffer is NULL\n&quot;);
1028         return JNI_FALSE;
1029     }
1030 
1031     if (ctxInfo-&gt;gl2) {
1032         glReadPixels((GLint) x, (GLint) y, (GLsizei) width, (GLsizei) height,
1033                     GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, ptr);
1034     } else {
1035         jint i;
1036         GLubyte* c = (GLubyte*) ptr;
1037         GLubyte temp;
1038         glReadPixels((GLint) x, (GLint) y, (GLsizei) width, (GLsizei) height,
1039                 GL_RGBA, GL_UNSIGNED_BYTE, ptr);
1040 
1041         for (i = 0; i &lt; width * height; i++) {
1042             temp = c[0];
1043             c[0] = c[2];
1044             c[2] = temp;
1045             c += 4;
1046         }
1047     }
1048 
1049     if (pixelArr != NULL) {
1050         (*env)-&gt;ReleasePrimitiveArrayCritical(env, pixelArr, ptr, 0);
1051     }
1052     return JNI_TRUE;
1053 }
1054 
1055 /*
1056  * Class:     com_sun_prism_es2_GLContext
1057  * Method:    nReadPixelsByte
1058  * Signature: (JILjava/nio/Buffer;[BIIII)Z
1059  */
1060 JNIEXPORT jboolean JNICALL Java_com_sun_prism_es2_GLContext_nReadPixelsByte
1061 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint length, jobject buffer,
1062         jbyteArray pixelArr, jint x, jint y, jint w, jint h) {
1063     return doReadPixels(env, nativeCtxInfo, length, buffer, pixelArr, x, y, w, h);
1064 }
1065 
1066 /*
1067  * Class:     com_sun_prism_es2_GLContext
1068  * Method:    nReadPixelsInt
1069  * Signature: (JILjava/nio/Buffer;[IIIII)Z
1070  */
1071 JNIEXPORT jboolean JNICALL Java_com_sun_prism_es2_GLContext_nReadPixelsInt
1072 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint length, jobject buffer,
1073         jintArray pixelArr, jint x, jint y, jint w, jint h) {
1074     return doReadPixels(env, nativeCtxInfo, length, buffer, pixelArr, x, y, w, h);
1075 }
1076 
1077 /*
1078  * Class:     com_sun_prism_es2_GLContext
1079  * Method:    nScissorTest
1080  * Signature: (JZIIII)V
1081  */
1082 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nScissorTest
1083 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jboolean enable,
1084         jint x, jint y, jint w, jint h) {
1085     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1086     if (ctxInfo == NULL) {
1087         return;
1088     }
1089 
1090     if (enable) {
1091         if (!ctxInfo-&gt;state.scissorEnabled) {
1092             glEnable(GL_SCISSOR_TEST);
1093             ctxInfo-&gt;state.scissorEnabled = JNI_TRUE;
1094         }
1095         glScissor(x, y, w, h);
1096     } else if (ctxInfo-&gt;state.scissorEnabled) {
1097         glDisable(GL_SCISSOR_TEST);
1098         ctxInfo-&gt;state.scissorEnabled = JNI_FALSE;
1099     }
1100 }
1101 
1102 /*
1103  * Class:     com_sun_prism_es2_GLContext
1104  * Method:    nTexParamsMinMax
1105  * Signature: (I)V
1106  */
1107 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nTexParamsMinMax
1108 (JNIEnv *env, jclass class, jint min, jint max) {
1109     GLenum param = translatePrismToGL(max);
1110     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, param);
1111     param = translatePrismToGL(min);
1112     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, param);
1113 }
1114 
1115 /*
1116  * Class:     com_sun_prism_es2_GLContext
1117  * Method:    nTexImage2D0
1118  * Signature: (IIIIIIIILjava/lang/Object;I)Z
1119  */
1120 JNIEXPORT jboolean JNICALL Java_com_sun_prism_es2_GLContext_nTexImage2D0
1121 (JNIEnv *env, jclass class, jint target, jint level, jint internalFormat,
1122         jint width, jint height, jint border, jint format, jint type,
1123         jobject pixels, jint pixelsByteOffset, jboolean useMipmap) {
1124     GLvoid *ptr = NULL;
1125     GLenum err;
1126 
1127     if (pixels != NULL) {
1128         ptr = (GLvoid *) (((char *) (*env)-&gt;GetDirectBufferAddress(env, pixels))
1129                 + pixelsByteOffset);
1130     }
1131 
1132     glGetError();
1133     if (useMipmap) {
1134         glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, GL_TRUE);
1135     }
1136     glTexImage2D((GLenum) translatePrismToGL(target), (GLint) level,
1137             (GLint) translatePrismToGL(internalFormat),
1138             (GLsizei) width, (GLsizei) height, (GLint) border,
1139             (GLenum) translatePrismToGL(format),
1140             (GLenum) translatePrismToGL(type), (GLvoid *) ptr);
1141     err  = glGetError();
1142 
1143     // printGLError(err);
1144     return err == GL_NO_ERROR ? JNI_TRUE : JNI_FALSE;
1145 }
1146 
1147 /*
1148  * Class:     com_sun_prism_es2_GLContext
1149  * Method:    nTexImage2D1
1150  * Signature: (IIIIIIIILjava/lang/Object;I)Z
1151  */
1152 JNIEXPORT jboolean JNICALL Java_com_sun_prism_es2_GLContext_nTexImage2D1
1153 (JNIEnv *env, jclass class, jint target, jint level, jint internalFormat,
1154         jint width, jint height, jint border, jint format, jint type,
1155         jobject pixels, jint pixelsByteOffset, jboolean useMipmap) {
1156     char *ptr = NULL;
1157     char *ptrPlusOffset = NULL;
1158     GLenum err;
1159 
1160     if (pixels != NULL) {
1161         ptr = (char *) (*env)-&gt;GetPrimitiveArrayCritical(env, pixels, NULL);
1162         if (ptr == NULL) {
1163             fprintf(stderr, &quot;nTexImage2D1: GetPrimitiveArrayCritical returns NULL: out of memory\n&quot;);
1164             return JNI_FALSE;
1165         }
1166         ptrPlusOffset = ptr + pixelsByteOffset;
1167     }
1168 
1169     glGetError();
1170     if (useMipmap) {
1171         glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, GL_TRUE);
1172     }
1173 
1174     // It is okay if ptrPlusOffset is null.
1175     // In this case, a call to glTexImage2D will cause texture memory to be allocated
1176     // to accommodate a texture of width and height.
1177     glTexImage2D((GLenum) translatePrismToGL(target), (GLint) level,
1178             (GLint) translatePrismToGL(internalFormat),
1179             (GLsizei) width, (GLsizei) height, (GLint) border,
1180             (GLenum) translatePrismToGL(format),
1181             (GLenum) translatePrismToGL(type), (GLvoid *) ptrPlusOffset);
1182 
1183     err  = glGetError();
1184 
1185     if (pixels != NULL) {
1186         (*env)-&gt;ReleasePrimitiveArrayCritical(env, pixels, ptr, 0);
1187     }
1188 
1189     // printGLError(err);
1190     return err == GL_NO_ERROR ? JNI_TRUE : JNI_FALSE;
1191 }
1192 
1193 /*
1194  * Class:     com_sun_prism_es2_GLContext
1195  * Method:    nTexSubImage2D0
1196  * Signature: (IIIIIIIILjava/lang/Object;I)V
1197  */
1198 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nTexSubImage2D0
1199 (JNIEnv *env, jclass class, jint target, jint level,
1200         jint xoffset, jint yoffset, jint width, jint height, jint format,
1201         jint type, jobject pixels, jint pixelsByteOffset) {
1202     GLvoid *ptr = NULL;
1203     if (pixels != NULL) {
1204         ptr = (GLvoid *) (((char *) (*env)-&gt;GetDirectBufferAddress(env, pixels))
1205                 + pixelsByteOffset);
1206     }
1207     glTexSubImage2D((GLenum) translatePrismToGL(target), (GLint) level,
1208             (GLint) xoffset, (GLint) yoffset,
1209             (GLsizei) width, (GLsizei) height, (GLenum) translatePrismToGL(format),
1210             (GLenum) translatePrismToGL(type), (GLvoid *) ptr);
1211 }
1212 
1213 /*
1214  * Class:     com_sun_prism_es2_GLContext
1215  * Method:    nTexSubImage2D1
1216  * Signature: (IIIIIIIILjava/lang/Object;I)V
1217  */
1218 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nTexSubImage2D1
1219 (JNIEnv *env, jclass class, jint target, jint level,
1220         jint xoffset, jint yoffset, jint width, jint height, jint format,
1221         jint type, jobject pixels, jint pixelsByteOffset) {
1222     char *ptr = NULL;
1223     char *ptrPlusOffset = NULL;
1224     if (pixels != NULL) {
1225         ptr = (char *) (*env)-&gt;GetPrimitiveArrayCritical(env, pixels, NULL);
1226         if (ptr == NULL) {
1227             fprintf(stderr, &quot;nTexSubImage2D1: GetPrimitiveArrayCritical returns NULL: out of memory\n&quot;);
1228             return;
1229         }
1230         ptrPlusOffset = ptr + pixelsByteOffset;
1231     }
1232     glTexSubImage2D((GLenum) translatePrismToGL(target), (GLint) level,
1233             (GLint) xoffset, (GLint) yoffset,
1234             (GLsizei) width, (GLsizei) height, (GLenum) translatePrismToGL(format),
1235             (GLenum) translatePrismToGL(type), (GLvoid *) ptrPlusOffset);
1236     if (pixels != NULL) {
1237         (*env)-&gt;ReleasePrimitiveArrayCritical(env, pixels, ptr, 0);
1238     }
1239 }
1240 
1241 /*
1242  * Class:     com_sun_prism_es2_GLContext
1243  * Method:    nUpdateViewport
1244  * Signature: (JIIII)V
1245  */
1246 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nUpdateViewport
1247 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint x, jint y,
1248         jint w, jint h) {
1249     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1250     if (ctxInfo == NULL) {
1251         return;
1252     }
1253 
1254     glViewport((GLint) x, (GLint) y, (GLsizei) w, (GLsizei) h);
1255 }
1256 
1257 /*
1258  * Class:     com_sun_prism_es2_GLContext
1259  * Method:    nSetMSAA
1260  * Signature: (JZ)V
1261  */
1262 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nSetMSAA
1263 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jboolean msaa) {
1264 #ifndef IS_EGL
1265     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1266     if (ctxInfo == NULL) {
1267         return;
1268     }
1269 
1270     if (msaa) {
1271         glEnable(GL_MULTISAMPLE);
1272     } else {
1273         glDisable(GL_MULTISAMPLE);
1274     }
1275 #endif
1276 }
1277 
1278 /*
1279  * Class:     com_sun_prism_es2_GLContext
1280  * Method:    nSetDepthTest
1281  * Signature: (JZ)V
1282  */
1283 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nSetDepthTest
1284 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jboolean depthTest) {
1285     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1286     if (ctxInfo == NULL) {
1287         return;
1288     }
1289 
1290     if (depthTest) {
1291         glEnable(GL_DEPTH_TEST);
1292         glDepthFunc(GL_LEQUAL);
1293         glDepthMask(GL_TRUE);
1294         ctxInfo-&gt;state.depthWritesEnabled = JNI_TRUE;
1295     } else {
1296         glDisable(GL_DEPTH_TEST);
1297         glDepthMask(GL_FALSE);
1298         ctxInfo-&gt;state.depthWritesEnabled = JNI_FALSE;
1299     }
1300 }
1301 
1302 /*
1303  * Class:     com_sun_prism_es2_GLContext
1304  * Method:    nUniform1f
1305  * Signature: (JIF)V
1306  */
1307 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nUniform1f
1308 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint location, jfloat v0) {
1309     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1310     if (ctxInfo == NULL) {
1311         return;
1312     }
1313     ctxInfo-&gt;glUniform1f(location, v0);
1314 }
1315 
1316 /*
1317  * Class:     com_sun_prism_es2_GLContext
1318  * Method:    nUniform2f
1319  * Signature: (JIFF)V
1320  */
1321 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nUniform2f
1322 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint location,
1323         jfloat v0, jfloat v1) {
1324     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1325     if (ctxInfo == NULL) {
1326         return;
1327     }
1328     ctxInfo-&gt;glUniform2f(location, v0, v1);
1329 }
1330 
1331 /*
1332  * Class:     com_sun_prism_es2_GLContext
1333  * Method:    nUniform3f
1334  * Signature: (JIFFF)V
1335  */
1336 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nUniform3f
1337 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint location,
1338         jfloat v0, jfloat v1, jfloat v2) {
1339     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1340     if (ctxInfo == NULL) {
1341         return;
1342     }
1343     ctxInfo-&gt;glUniform3f(location, v0, v1, v2);
1344 }
1345 
1346 /*
1347  * Class:     com_sun_prism_es2_GLContext
1348  * Method:    nUniform4f
1349  * Signature: (JIFFFF)V
1350  */
1351 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nUniform4f
1352 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint location,
1353         jfloat v0, jfloat v1, jfloat v2, jfloat v3) {
1354     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1355     if (ctxInfo == NULL) {
1356         return;
1357     }
1358     ctxInfo-&gt;glUniform4f(location, v0, v1, v2, v3);
1359 }
1360 
1361 /*
1362  * Class:     com_sun_prism_es2_GLContext
1363  * Method:    nUniform4fv0
1364  * Signature: (JIILjava/lang/Object;I)V
1365  */
1366 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nUniform4fv0
1367 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint location, jint count,
1368         jobject value, jint valueByteOffset) {
1369     GLfloat *_ptr2 = NULL;
1370     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1371     if ((env == NULL) || (ctxInfo == NULL)) {
1372         return;
1373     }
1374     if (value != NULL) {
1375         _ptr2 = (GLfloat *) (((char *) (*env)-&gt;GetDirectBufferAddress(env, value))
1376                 + valueByteOffset);
1377     }
1378     ctxInfo-&gt;glUniform4fv((GLint) location, (GLsizei) count, (GLfloat *) _ptr2);
1379 }
1380 
1381 /*
1382  * Class:     com_sun_prism_es2_GLContext
1383  * Method:    nUniform4fv1
1384  * Signature: (JIILjava/lang/Object;I)V
1385  */
1386 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nUniform4fv1
1387 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint location, jint count,
1388         jobject value, jint valueByteOffset) {
1389     char *ptr = NULL;
1390     char *ptrPlusOffset = NULL;
1391     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1392     if ((env == NULL) || (ctxInfo == NULL)) {
1393         return;
1394     }
1395     if (value != NULL) {
1396         ptr = (char *) (*env)-&gt;GetPrimitiveArrayCritical(env, value, NULL);
1397         if (ptr == NULL) {
1398             fprintf(stderr, &quot;nUniform4fv1: GetPrimitiveArrayCritical returns NULL: out of memory\n&quot;);
1399             return;
1400         }
1401         ptrPlusOffset = ptr + valueByteOffset;
1402 
1403     }
1404     ctxInfo-&gt;glUniform4fv((GLint) location, (GLsizei) count, (GLfloat *) ptrPlusOffset);
1405     if (value != NULL) {
1406         (*env)-&gt;ReleasePrimitiveArrayCritical(env, value, ptr, 0);
1407     }
1408 }
1409 
1410 /*
1411  * Class:     com_sun_prism_es2_GLContext
1412  * Method:    nUniform1i
1413  * Signature: (JII)V
1414  */
1415 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nUniform1i
1416 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint location, jint v0) {
1417     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1418     if ((ctxInfo == NULL) || (ctxInfo-&gt;glUniform1i == NULL)) {
1419         return;
1420     }
1421     ctxInfo-&gt;glUniform1i(location, v0);
1422 }
1423 
1424 /*
1425  * Class:     com_sun_prism_es2_GLContext
1426  * Method:    nUniform2i
1427  * Signature: (JIII)V
1428  */
1429 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nUniform2i
1430 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint location, jint v0, jint v1) {
1431     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1432     if ((ctxInfo == NULL) || (ctxInfo-&gt;glUniform2i == NULL)) {
1433         return;
1434     }
1435     ctxInfo-&gt;glUniform2i(location, v0, v1);
1436 }
1437 
1438 /*
1439  * Class:     com_sun_prism_es2_GLContext
1440  * Method:    nUniform3i
1441  * Signature: (JIIII)V
1442  */
1443 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nUniform3i
1444 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint location,
1445         jint v0, jint v1, jint v2) {
1446     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1447     if ((ctxInfo == NULL) || (ctxInfo-&gt;glUniform3i == NULL)) {
1448         return;
1449     }
1450     ctxInfo-&gt;glUniform3i(location, v0, v1, v2);
1451 }
1452 
1453 /*
1454  * Class:     com_sun_prism_es2_GLContext
1455  * Method:    nUniform4i
1456  * Signature: (JIIIII)V
1457  */
1458 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nUniform4i
1459 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint location,
1460         jint v0, jint v1, jint v2, jint v3) {
1461     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1462     if ((ctxInfo == NULL) || (ctxInfo-&gt;glUniform4i == NULL)) {
1463         return;
1464     }
1465     ctxInfo-&gt;glUniform4i(location, v0, v1, v2, v3);
1466 }
1467 
1468 /*
1469  * Class:     com_sun_prism_es2_GLContext
1470  * Method:    nUniform4iv0
1471  * Signature: (JIILjava/lang/Object;I)V
1472  */
1473 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nUniform4iv0
1474 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint location, jint count,
1475         jobject value, jint valueByteOffset) {
1476     GLint *_ptr2 = NULL;
1477     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1478     if ((ctxInfo == NULL) || (ctxInfo-&gt;glUniform4iv == NULL)) {
1479         return;
1480     }
1481 
1482     if (value != NULL) {
1483         _ptr2 = (GLint *) (((char *) (*env)-&gt;GetDirectBufferAddress(env, value))
1484                 + valueByteOffset);
1485     }
1486     ctxInfo-&gt;glUniform4iv((GLint) location, (GLsizei) count, (GLint *) _ptr2);
1487 }
1488 
1489 /*
1490  * Class:     com_sun_prism_es2_GLContext
1491  * Method:    nUniform4iv1
1492  * Signature: (JIILjava/lang/Object;I)V
1493  */
1494 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nUniform4iv1
1495 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint location, jint count,
1496         jobject value, jint valueByteOffset) {
1497     char *ptr = NULL;
1498     char *ptrPlusOffset = NULL;
1499     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1500     if ((ctxInfo == NULL) || (ctxInfo-&gt;glUniform4iv == NULL)) {
1501         return;
1502     }
1503 
1504     if (value != NULL) {
1505         ptr = (char *) (*env)-&gt;GetPrimitiveArrayCritical(env, value, NULL);
1506         if (ptr == NULL) {
1507             fprintf(stderr, &quot;nUniform4iv1: GetPrimitiveArrayCritical returns NULL: out of memory\n&quot;);
1508             return;
1509         }
1510         ptrPlusOffset = ptr + valueByteOffset;
1511     }
1512     ctxInfo-&gt;glUniform4iv((GLint) location, (GLsizei) count, (GLint *) ptrPlusOffset);
1513     if (value != NULL) {
1514         (*env)-&gt;ReleasePrimitiveArrayCritical(env, value, ptr, 0);
1515     }
1516 }
1517 
1518 /*
1519  * Class:     com_sun_prism_es2_GLContext
1520  * Method:    nUniformMatrix4fv0
1521  * Signature: (JIIZLjava/lang/Object;I)V
1522  */
1523 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nUniformMatrix4fv
1524 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint location,
1525         jboolean transpose, jfloatArray values) {
1526     GLfloat *_ptr = NULL;
1527     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1528     if ((ctxInfo == NULL) || (ctxInfo-&gt;glUniformMatrix4fv == NULL)) {
1529         return;
1530     }
1531 
1532     if (values != NULL) {
1533         _ptr = (float *)(*env)-&gt;GetPrimitiveArrayCritical(env, values, NULL);
1534         if (_ptr == NULL) {
1535             fprintf(stderr, &quot;nUniformMatrix4fv: GetPrimitiveArrayCritical returns NULL: out of memory\n&quot;);
1536             return;
1537         }
1538     }
1539     ctxInfo-&gt;glUniformMatrix4fv((GLint) location, 1, (GLboolean) transpose, _ptr);
1540 
1541     if (_ptr) (*env)-&gt;ReleasePrimitiveArrayCritical(env, values, _ptr, JNI_ABORT);
1542 }
1543 
1544 /*
1545  * Class:     com_sun_prism_es2_GLContext
1546  * Method:    nUpdateFilterState
1547  * Signature: (JIZ)V
1548  */
1549 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nUpdateFilterState
1550 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint texID, jboolean linearFiler) {
1551     int glFilter;
1552 
1553     glFilter = linearFiler ? GL_LINEAR : GL_NEAREST;
1554     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, glFilter);
1555     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, glFilter);
1556 }
1557 
1558 /*
1559  * Class:     com_sun_prism_es2_GLContext
1560  * Method:    nUpdateWrapState
1561  * Signature: (JII)V
1562  */
1563 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nUpdateWrapState
1564 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint texID, jint wrapMode) {
1565     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
1566             (GLenum) translatePrismToGL(wrapMode));
1567     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,
1568             (GLenum) translatePrismToGL(wrapMode));
1569 }
1570 
1571 /*
1572  * Class:     com_sun_prism_es2_GLContext
1573  * Method:    nUseProgram
1574  * Signature: (JI)V
1575  */
1576 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nUseProgram
1577 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint pID) {
1578     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1579     if ((ctxInfo == NULL) || (ctxInfo-&gt;glUseProgram == NULL)) {
1580         return;
1581     }
1582     ctxInfo-&gt;glUseProgram(pID);
1583 }
1584 
1585 /*
1586  * Class:     com_sun_prism_es2_GLContext
1587  * Method:    nDisableVertexAttributes
1588  * Signature: (J)V
1589  */
1590 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nDisableVertexAttributes
1591 (JNIEnv *env, jclass class, jlong nativeCtxInfo) {
1592     int i;
1593     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1594     if ((ctxInfo == NULL) || (ctxInfo-&gt;glDisableVertexAttribArray == NULL)) {
1595         return;
1596     }
1597 
1598     for (i = 0; i != 4; ++i) {
1599         ctxInfo-&gt;glDisableVertexAttribArray(i);
1600     }
1601 }
1602 
1603 /*
1604  * Class:     com_sun_prism_es2_GLContext
1605  * Method:    nEnableVertexAttributes
1606  * Signature: (J)V
1607  */
1608 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nEnableVertexAttributes
1609 (JNIEnv *env, jclass class, jlong nativeCtxInfo) {
1610     int i;
1611     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1612     if ((ctxInfo == NULL) || (ctxInfo-&gt;glEnableVertexAttribArray == NULL)) {
1613         return;
1614     }
1615 
1616     for (i = 0; i != 4; ++i) {
1617         ctxInfo-&gt;glEnableVertexAttribArray(i);
1618     }
1619 }
1620 
1621 #define FLOATS_PER_TC 2
1622 #define FLOATS_PER_VC 3
1623 #define FLOATS_PER_VERT (FLOATS_PER_TC * 2 + FLOATS_PER_VC)
1624 
1625 #define coordStride (sizeof(float) * FLOATS_PER_VERT)
1626 #define colorStride 4
1627 
1628 /* NOTE: the ctx-&gt;vbFloatData and ctx-&gt;vbByteData pointers must be updated
1629  * whenever calling glVertexAttribPointer. Failing to do this could leave
1630  * the pointers in an inconsistent state.
1631  */
1632 
1633 static void setVertexAttributePointers(ContextInfo *ctx, float *pFloat, char *pByte) {
1634     if (pFloat != ctx-&gt;vbFloatData) {
1635         ctx-&gt;glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, coordStride, pFloat);
1636         ctx-&gt;glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, coordStride,
1637             pFloat + FLOATS_PER_VC);
1638         ctx-&gt;glVertexAttribPointer(3, 2, GL_FLOAT, GL_FALSE, coordStride,
1639             pFloat + FLOATS_PER_VC + FLOATS_PER_TC);
1640         ctx-&gt;vbFloatData = pFloat;
1641     }
1642 
1643     if (pByte != ctx-&gt;vbByteData) {
1644         ctx-&gt;glVertexAttribPointer(1, 4, GL_UNSIGNED_BYTE, GL_TRUE, colorStride, pByte);
1645         ctx-&gt;vbByteData = pByte;
1646     }
1647 }
1648 /*
1649  * Class:     com_sun_prism_es2_GLContext
1650  * Method:    nDrawIndexedQuads
1651  * Signature: (JI[F[B)V
1652  */
1653 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nDrawIndexedQuads
1654   (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint numVertices,
1655    jfloatArray dataf, jbyteArray datab)
1656 {
1657     float *pFloat;
1658     char *pByte;
1659     int numQuads = numVertices / 4;
1660 
1661     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1662     if ((ctxInfo == NULL) || (ctxInfo-&gt;glVertexAttribPointer == NULL)) {
1663         return;
1664     }
1665 
1666     pFloat = (float *)(*env)-&gt;GetPrimitiveArrayCritical(env, dataf, NULL);
1667     pByte = (char *)(*env)-&gt;GetPrimitiveArrayCritical(env, datab, NULL);
1668 
1669     if (pFloat &amp;&amp; pByte) {
1670         setVertexAttributePointers(ctxInfo, pFloat, pByte);
1671         glDrawElements(GL_TRIANGLES, numQuads * 2 * 3, GL_UNSIGNED_SHORT, 0);
1672     }
1673 
1674     if (pByte)  (*env)-&gt;ReleasePrimitiveArrayCritical(env, datab, pByte, JNI_ABORT);
1675     if (pFloat) (*env)-&gt;ReleasePrimitiveArrayCritical(env, dataf, pFloat, JNI_ABORT);
1676 }
1677 
1678 /*
1679  * Class:     com_sun_prism_es2_GLContext
1680  * Method:    nCreateIndexBuffer16
1681  * Signature: (J[SI)I
1682  */
1683 JNIEXPORT jint JNICALL Java_com_sun_prism_es2_GLContext_nCreateIndexBuffer16
1684   (JNIEnv *env, jclass class, jlong nativeCtxInfo, jshortArray array, jint n)
1685 {
1686     GLuint id = 0;
1687     void *pData;
1688 
1689     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1690     if ((ctxInfo == NULL) || (ctxInfo-&gt;glBindBuffer == NULL) ||
1691             (ctxInfo-&gt;glBufferData == NULL) || (ctxInfo-&gt;glGenBuffers == NULL)) {
1692         return 0;
1693     }
1694 
1695     pData = (*env)-&gt;GetPrimitiveArrayCritical(env, array, NULL);
1696     if (pData) {
1697         ctxInfo-&gt;glGenBuffers(1, &amp;id);
1698         if (id) {
1699             ctxInfo-&gt;glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, id);
1700             ctxInfo-&gt;glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(short) * n, pData, GL_STATIC_DRAW);
1701         }
1702     }
1703     if (pData) (*env)-&gt;ReleasePrimitiveArrayCritical(env, array, pData, JNI_ABORT);
1704     return id;
1705 }
1706 
1707 /*
1708  * Class:     com_sun_prism_es2_GLContext
1709  * Method:    nSetIndexBuffer
1710  * Signature: (JI)V
1711  */
1712 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nSetIndexBuffer
1713   (JNIEnv *env, jclass class, jlong nativeCtxInfo, jint buffer)
1714 {
1715     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1716     if ((ctxInfo == NULL) || (ctxInfo-&gt;glBindBuffer == NULL)) {
1717         return;
1718     }
1719     ctxInfo-&gt;glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, buffer);
1720 }
1721 
1722 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nSetDeviceParametersFor2D
1723   (JNIEnv *env, jclass class, jlong nativeCtxInfo)
1724 {
1725     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1726     if ((ctxInfo == NULL) || (ctxInfo-&gt;glBindBuffer == NULL) ||
1727             (ctxInfo-&gt;glBufferData == NULL) ||
1728             (ctxInfo-&gt;glDisableVertexAttribArray == NULL)) {
1729         return;
1730     }
1731 
1732     // Disable 3D states
1733     ctxInfo-&gt;glBindBuffer(GL_ARRAY_BUFFER, 0);
1734     ctxInfo-&gt;glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
1735     ctxInfo-&gt;glDisableVertexAttribArray(VC_3D_INDEX);
1736     ctxInfo-&gt;glDisableVertexAttribArray(NC_3D_INDEX);
1737     ctxInfo-&gt;glDisableVertexAttribArray(TC_3D_INDEX);
1738 
1739     ctxInfo-&gt;vbFloatData = NULL;
1740     ctxInfo-&gt;vbByteData = NULL;
1741 
1742     glEnable(GL_BLEND);
1743     glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
1744 
1745     if (ctxInfo-&gt;state.scissorEnabled) {
1746         ctxInfo-&gt;state.scissorEnabled = JNI_FALSE;
1747         glDisable(GL_SCISSOR_TEST);
1748     }
1749 
1750     glCullFace(GL_BACK);
1751     ctxInfo-&gt;state.cullMode = GL_BACK;
1752     glDisable(GL_CULL_FACE);
1753     ctxInfo-&gt;state.cullEnable = JNI_FALSE;
1754 #ifndef IS_EGL
1755     glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
1756 #endif
1757     ctxInfo-&gt;state.fillMode = GL_FILL;
1758 }
1759 
1760 /*
1761  * Class:     com_sun_prism_es2_GLContext
1762  * Method:    nSetDeviceParametersFor3D
1763  * Signature: (J)V
1764  */
1765 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nSetDeviceParametersFor3D
1766   (JNIEnv *env, jclass class, jlong nativeCtxInfo)
1767 {
1768     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1769     if (ctxInfo == NULL) {
1770         return;
1771     }
1772     // Note: projViewTx and camPos are handled above in the Java layer
1773 
1774     // This setting matches 2D ((1,1-alpha); premultiplied alpha case.
1775     // Will need to evaluate when support proper 3D blending (alpha,1-alpha).
1776     glEnable(GL_BLEND);
1777     glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
1778 
1779     if (ctxInfo-&gt;state.scissorEnabled) {
1780         ctxInfo-&gt;state.scissorEnabled = JNI_FALSE;
1781         glDisable(GL_SCISSOR_TEST);
1782     }
1783 
1784     glEnable(GL_CULL_FACE);
1785     ctxInfo-&gt;state.cullEnable = GL_TRUE;
1786     glCullFace(GL_BACK);
1787     ctxInfo-&gt;state.cullMode = GL_BACK;
1788     glFrontFace(GL_CW); // set clockwise order as front-facing
1789 #ifndef IS_EGL
1790     glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
1791 #endif
1792     ctxInfo-&gt;state.fillMode = GL_FILL;
1793 
1794 }
1795 
1796 /*
1797  * Class:     com_sun_prism_es2_GLContext
1798  * Method:    nCreateES2Mesh
1799  * Signature: (J)J
1800  */
1801 JNIEXPORT jlong JNICALL Java_com_sun_prism_es2_GLContext_nCreateES2Mesh
1802   (JNIEnv *env, jclass class, jlong nativeCtxInfo)
1803 {
1804     MeshInfo *meshInfo = NULL;
1805     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1806     if ((ctxInfo == NULL) || (ctxInfo-&gt;glGenBuffers == NULL)) {
1807         return 0;
1808     }
1809 
1810     /* allocate the structure */
1811     meshInfo = (MeshInfo *) malloc(sizeof (MeshInfo));
1812     if (meshInfo == NULL) {
1813         fprintf(stderr, &quot;nCreateES2Mesh: Failed in malloc\n&quot;);
1814         return 0;
1815     }
1816 
1817     /* initialize the structure */
1818     meshInfo-&gt;vboIDArray[MESH_VERTEXBUFFER] = 0;
1819     meshInfo-&gt;vboIDArray[MESH_INDEXBUFFER] = 0;
1820     meshInfo-&gt;indexBufferSize = 0;
1821     meshInfo-&gt;indexBufferType = 0;
1822 
1823     /* create vbo ids */
1824     ctxInfo-&gt;glGenBuffers(MESH_MAX_BUFFERS, (meshInfo-&gt;vboIDArray));
1825 
1826     return ptr_to_jlong(meshInfo);
1827 }
1828 
1829 /*
1830  * Class:     com_sun_prism_es2_GLContext
1831  * Method:    nReleaseES2Mesh
1832  * Signature: (JJ)V
1833  */
1834 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nReleaseES2Mesh
1835   (JNIEnv *env, jclass class, jlong nativeCtxInfo, jlong nativeMeshInfo)
1836 {
1837     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1838     MeshInfo *meshInfo = (MeshInfo *) jlong_to_ptr(nativeMeshInfo);
1839     if ((ctxInfo == NULL) || (meshInfo == NULL) ||
1840             (ctxInfo-&gt;glDeleteBuffers == NULL)) {
1841         return;
1842     }
1843 
1844     // TODO: 3D - Native clean up. Need to determine do we have to free what
1845     //            is held by ES2MeshInfo.
1846     ctxInfo-&gt;glDeleteBuffers(MESH_MAX_BUFFERS, (GLuint *) (meshInfo-&gt;vboIDArray));
1847     free(meshInfo);
1848 }
1849 
1850 /*
1851  * Class:     com_sun_prism_es2_GLContext
1852  * Method:    nBuildNativeGeometryShort
1853  * Signature: (JJ[FI[SI)Z
1854  */
1855 JNIEXPORT jboolean JNICALL Java_com_sun_prism_es2_GLContext_nBuildNativeGeometryShort
1856   (JNIEnv *env, jclass class, jlong nativeCtxInfo, jlong nativeMeshInfo,
1857         jfloatArray vbArray, jint vbSize, jshortArray ibArray, jint ibSize)
1858 {
1859     GLuint vertexBufferSize;
1860     GLuint indexBufferSize;
1861     GLushort *indexBuffer;
1862     GLfloat *vertexBuffer;
1863     jboolean status = JNI_TRUE;
1864     GLuint uvbSize;
1865     GLuint uibSize;
1866 
1867     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1868     MeshInfo *meshInfo = (MeshInfo *) jlong_to_ptr(nativeMeshInfo);
1869     if ((ctxInfo == NULL) || (meshInfo == NULL) ||
1870             (vbArray == NULL) || (ibArray == NULL) ||
1871             (ctxInfo-&gt;glBindBuffer == NULL) ||
1872             (ctxInfo-&gt;glBufferData == NULL) ||
1873             (meshInfo-&gt;vboIDArray[MESH_VERTEXBUFFER] == 0)||
1874             (meshInfo-&gt;vboIDArray[MESH_INDEXBUFFER] == 0) ||
1875             vbSize &lt; 0 || ibSize &lt; 0) {
1876         return JNI_FALSE;
1877     }
1878 
1879     vertexBufferSize = (*env)-&gt;GetArrayLength(env, vbArray);
1880     indexBufferSize = (*env)-&gt;GetArrayLength(env, ibArray);
1881     vertexBuffer = (GLfloat *) ((*env)-&gt;GetPrimitiveArrayCritical(env, vbArray, NULL));
1882     indexBuffer = (GLushort *) ((*env)-&gt;GetPrimitiveArrayCritical(env, ibArray, NULL));
1883 
1884     uvbSize = (GLuint) vbSize;
1885     uibSize = (GLuint) ibSize;
1886     if (vertexBuffer == NULL || indexBuffer == NULL
1887             || uvbSize &gt; vertexBufferSize || uibSize &gt; indexBufferSize) {
1888         status = JNI_FALSE;
1889     }
1890 
1891     if (status) {
1892         // Initialize vertex buffer
1893         ctxInfo-&gt;glBindBuffer(GL_ARRAY_BUFFER, meshInfo-&gt;vboIDArray[MESH_VERTEXBUFFER]);
1894         ctxInfo-&gt;glBufferData(GL_ARRAY_BUFFER, uvbSize * sizeof (GLfloat),
1895                 vertexBuffer, GL_STATIC_DRAW);
1896 
1897         // Initialize index buffer
1898         ctxInfo-&gt;glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, meshInfo-&gt;vboIDArray[MESH_INDEXBUFFER]);
1899         ctxInfo-&gt;glBufferData(GL_ELEMENT_ARRAY_BUFFER, uibSize * sizeof (GLushort),
1900                 indexBuffer, GL_STATIC_DRAW);
1901         meshInfo-&gt;indexBufferSize = uibSize;
1902         meshInfo-&gt;indexBufferType = GL_UNSIGNED_SHORT;
1903 
1904         // Unbind VBOs
1905         ctxInfo-&gt;glBindBuffer(GL_ARRAY_BUFFER, 0);
1906         ctxInfo-&gt;glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
1907     }
1908 
1909     if (indexBuffer) {
1910         (*env)-&gt;ReleasePrimitiveArrayCritical(env, ibArray, indexBuffer, JNI_ABORT);
1911     }
1912     if (vertexBuffer) {
1913         (*env)-&gt;ReleasePrimitiveArrayCritical(env, vbArray, vertexBuffer, JNI_ABORT);
1914     }
1915 
1916     return status;
1917 }
1918 
1919 /*
1920  * Class:     com_sun_prism_es2_GLContext
1921  * Method:    nBuildNativeGeometryInt
1922  * Signature: (JJ[FI[II)Z
1923  */
1924 JNIEXPORT jboolean JNICALL Java_com_sun_prism_es2_GLContext_nBuildNativeGeometryInt
1925 (JNIEnv *env, jclass class, jlong nativeCtxInfo, jlong nativeMeshInfo,
1926         jfloatArray vbArray, jint vbSize, jintArray ibArray, jint ibSize)
1927 {
1928     GLuint vertexBufferSize;
1929     GLuint indexBufferSize;
1930     GLuint *indexBuffer;
1931     GLfloat *vertexBuffer;
1932     jboolean status = JNI_TRUE;
1933     GLuint uvbSize;
1934     GLuint uibSize;
1935 
1936     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1937     MeshInfo *meshInfo = (MeshInfo *) jlong_to_ptr(nativeMeshInfo);
1938     if ((ctxInfo == NULL) || (meshInfo == NULL) ||
1939             (vbArray == NULL) || (ibArray == NULL) ||
1940             (ctxInfo-&gt;glBindBuffer == NULL) ||
1941             (ctxInfo-&gt;glBufferData == NULL) ||
1942             (meshInfo-&gt;vboIDArray[MESH_VERTEXBUFFER] == 0)||
1943             (meshInfo-&gt;vboIDArray[MESH_INDEXBUFFER] == 0) ||
1944             vbSize &lt; 0 || ibSize &lt; 0) {
1945         return JNI_FALSE;
1946     }
1947 
1948     vertexBufferSize = (*env)-&gt;GetArrayLength(env, vbArray);
1949     indexBufferSize = (*env)-&gt;GetArrayLength(env, ibArray);
1950     vertexBuffer = (GLfloat *) ((*env)-&gt;GetPrimitiveArrayCritical(env, vbArray, NULL));
1951     indexBuffer = (GLuint *) ((*env)-&gt;GetPrimitiveArrayCritical(env, ibArray, NULL));
1952 
1953     uvbSize = (GLuint) vbSize;
1954     uibSize = (GLuint) ibSize;
1955     if (vertexBuffer == NULL || indexBuffer == NULL
1956             || uvbSize &gt; vertexBufferSize || uibSize &gt; indexBufferSize) {
1957         status = JNI_FALSE;
1958     }
1959 
1960     if (status) {
1961         // Initialize vertex buffer
1962         ctxInfo-&gt;glBindBuffer(GL_ARRAY_BUFFER, meshInfo-&gt;vboIDArray[MESH_VERTEXBUFFER]);
1963         ctxInfo-&gt;glBufferData(GL_ARRAY_BUFFER, uvbSize * sizeof (GLfloat),
1964                 vertexBuffer, GL_STATIC_DRAW);
1965 
1966         // Initialize index buffer
1967         ctxInfo-&gt;glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, meshInfo-&gt;vboIDArray[MESH_INDEXBUFFER]);
1968         ctxInfo-&gt;glBufferData(GL_ELEMENT_ARRAY_BUFFER, uibSize * sizeof (GLuint),
1969                 indexBuffer, GL_STATIC_DRAW);
1970         meshInfo-&gt;indexBufferSize = uibSize;
1971         meshInfo-&gt;indexBufferType = GL_UNSIGNED_INT;
1972 
1973         // Unbind VBOs
1974         ctxInfo-&gt;glBindBuffer(GL_ARRAY_BUFFER, 0);
1975         ctxInfo-&gt;glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
1976     }
1977 
1978     if (indexBuffer) {
1979         (*env)-&gt;ReleasePrimitiveArrayCritical(env, ibArray, indexBuffer, JNI_ABORT);
1980     }
1981     if (vertexBuffer) {
1982         (*env)-&gt;ReleasePrimitiveArrayCritical(env, vbArray, vertexBuffer, JNI_ABORT);
1983     }
1984 
1985     return status;
1986 }
1987 
1988 /*
1989  * Class:     com_sun_prism_es2_GLContext
1990  * Method:    nCreateES2PhongMaterial
1991  * Signature: (J)J
1992  */
1993 JNIEXPORT jlong JNICALL Java_com_sun_prism_es2_GLContext_nCreateES2PhongMaterial
1994   (JNIEnv *env, jclass class, jlong nativeCtxInfo)
1995 {
1996     PhongMaterialInfo *pmInfo = NULL;
1997     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
1998     if (ctxInfo == NULL) {
1999         return 0;
2000     }
2001 
2002     /* allocate the structure */
2003     pmInfo = (PhongMaterialInfo *) malloc(sizeof (PhongMaterialInfo));
2004     if (pmInfo == NULL) {
2005         fprintf(stderr, &quot;nCreateES2PhongMaterial: Failed in malloc\n&quot;);
2006         return 0;
2007     }
2008 
2009     /* initialize the structure */
2010     pmInfo-&gt;diffuseColor[0] = 0.0f;
2011     pmInfo-&gt;diffuseColor[1] = 0.0f;
2012     pmInfo-&gt;diffuseColor[2] = 0.0f;
2013     pmInfo-&gt;diffuseColor[3] = 0.0f;
2014     pmInfo-&gt;maps[0] = 0;
2015     pmInfo-&gt;maps[1] = 0;
2016     pmInfo-&gt;maps[2] = 0;
2017     pmInfo-&gt;maps[3] = 0;
2018     return ptr_to_jlong(pmInfo);
2019 }
2020 
2021 /*
2022  * Class:     com_sun_prism_es2_GLContext
2023  * Method:    nReleaseES2PhongMaterial
2024  * Signature: (JJ)V
2025  */
2026 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nReleaseES2PhongMaterial
2027   (JNIEnv *env, jclass class, jlong nativeCtxInfo, jlong nativePhongMaterialInfo)
2028 {
2029     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
2030     PhongMaterialInfo *pmInfo = (PhongMaterialInfo *) jlong_to_ptr(nativePhongMaterialInfo);
2031     if ((ctxInfo == NULL) || (pmInfo == NULL)) {
2032         return;
2033     }
2034 
2035     // We shouldn&#39;t free maps (texture) here. This freeing should be handled higher
2036     // in the Java layer in dealing with Texture object.
2037 
2038     free(pmInfo);
2039 }
2040 
2041 /*
2042  * Class:     com_sun_prism_es2_GLContext
2043  * Method:    nSetSolidColor
2044  * Signature: (JJFFFF)V
2045  */
2046 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nSetSolidColor
2047   (JNIEnv *env, jclass class, jlong nativeCtxInfo, jlong nativePhongMaterialInfo,
2048         jfloat r, jfloat g, jfloat b, jfloat a)
2049 {
2050     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
2051     PhongMaterialInfo *pmInfo = (PhongMaterialInfo *) jlong_to_ptr(nativePhongMaterialInfo);
2052     if ((ctxInfo == NULL) || (pmInfo == NULL)) {
2053         return;
2054     }
2055 
2056     pmInfo-&gt;diffuseColor[0] = r;
2057     pmInfo-&gt;diffuseColor[1] = g;
2058     pmInfo-&gt;diffuseColor[2] = b;
2059     pmInfo-&gt;diffuseColor[3] = a;
2060 }
2061 
2062 /*
2063  * Class:     com_sun_prism_es2_GLContext
2064  * Method:    nSetMap
2065  * Signature: (JJII)V
2066  */
2067 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nSetMap
2068   (JNIEnv *env, jclass class, jlong nativeCtxInfo, jlong nativePhongMaterialInfo,
2069         jint mapType, jint texID)
2070 {
2071     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
2072     PhongMaterialInfo *pmInfo = (PhongMaterialInfo *) jlong_to_ptr(nativePhongMaterialInfo);
2073     if ((ctxInfo == NULL) || (pmInfo == NULL)) {
2074         return;
2075     }
2076 
2077     // Must within the range of DIFFUSE, SPECULAR, BUMP, SELFILLUMINATION
2078     if ((mapType &lt; 0) || (mapType &gt; 3)) {
2079         fprintf(stderr, &quot;nSetMap: mapType is out of bounds\n&quot;);
2080         return;
2081     }
2082 
2083     pmInfo-&gt;maps[mapType] = texID;
2084 }
2085 
2086 /*
2087  * Class:     com_sun_prism_es2_GLContext
2088  * Method:    nCreateES2MeshView
2089  * Signature: (JJ)J
2090  */
2091 JNIEXPORT jlong JNICALL Java_com_sun_prism_es2_GLContext_nCreateES2MeshView
2092   (JNIEnv *env, jclass class, jlong nativeCtxInfo, jlong nativeMeshInfo)
2093 {
2094     MeshViewInfo *meshViewInfo;
2095     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
2096     MeshInfo *meshInfo = (MeshInfo *) jlong_to_ptr(nativeMeshInfo);
2097     if ((ctxInfo == NULL) || (meshInfo == NULL)) {
2098         return 0;
2099     }
2100 
2101     /* allocate the structure */
2102     meshViewInfo = (MeshViewInfo *) malloc(sizeof (MeshViewInfo));
2103     if (meshViewInfo == NULL) {
2104         fprintf(stderr, &quot;nCreateES2MeshView: Failed in malloc\n&quot;);
2105         return 0;
2106     }
2107 
2108     /* initialize the structure */
2109     meshViewInfo-&gt;meshInfo = meshInfo;
2110     meshViewInfo-&gt;phongMaterialInfo = NULL;
2111     meshViewInfo-&gt;cullEnable = GL_TRUE;
2112     meshViewInfo-&gt;cullMode = GL_BACK;
2113     meshViewInfo-&gt;fillMode = GL_FILL;
2114     meshViewInfo-&gt;ambientLightColor[0] = 0;
2115     meshViewInfo-&gt;ambientLightColor[1] = 0;
2116     meshViewInfo-&gt;ambientLightColor[2] = 0;
2117     meshViewInfo-&gt;pointLightIndex = 0;
2118     meshViewInfo-&gt;pointLightColor[0] = 0;
2119     meshViewInfo-&gt;pointLightColor[1] = 0;
2120     meshViewInfo-&gt;pointLightColor[2] = 0;
2121     meshViewInfo-&gt;pointLightPosition[0] = 0;
2122     meshViewInfo-&gt;pointLightPosition[1] = 0;
2123     meshViewInfo-&gt;pointLightPosition[2] = 0;
2124     meshViewInfo-&gt;pointLightWeight = 0;
<a name="2" id="anc2"></a>



2125 
2126     return ptr_to_jlong(meshViewInfo);
2127 }
2128 
2129 /*
2130  * Class:     com_sun_prism_es2_GLContext
2131  * Method:    nReleaseES2MeshView
2132  * Signature: (JJ)V
2133  */
2134 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nReleaseES2MeshView
2135   (JNIEnv *env, jclass class, jlong nativeCtxInfo, jlong nativeMeshInfo)
2136 {
2137     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
2138     MeshViewInfo *mvInfo = (MeshViewInfo *) jlong_to_ptr(nativeMeshInfo);
2139     if ((ctxInfo == NULL) || (mvInfo == NULL)) {
2140         return;
2141     }
2142 
2143     // TODO: 3D - Native clean up. Need to determine do we have to free what
2144     //            is held by ES2MeshViewInfo.
2145     free(mvInfo);
2146 }
2147 
2148 void setCullMode(ContextInfo *ctxInfo, MeshViewInfo *mvInfo) {
2149     if (mvInfo-&gt;cullEnable != ctxInfo-&gt;state.cullEnable) {
2150         if (mvInfo-&gt;cullEnable) {
2151             glEnable(GL_CULL_FACE);
2152         } else {
2153             glDisable(GL_CULL_FACE);
2154         }
2155         ctxInfo-&gt;state.cullEnable = mvInfo-&gt;cullEnable;
2156     }
2157 
2158     if (mvInfo-&gt;cullMode != ctxInfo-&gt;state.cullMode) {
2159         glCullFace(mvInfo-&gt;cullMode);
2160         ctxInfo-&gt;state.cullMode = mvInfo-&gt;cullMode;
2161     }
2162 }
2163 
2164 /*
2165  * Class:     com_sun_prism_es2_GLContext
2166  * Method:    nSetCullingMode
2167  * Signature: (JJI)V
2168  */
2169 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nSetCullingMode
2170   (JNIEnv *env, jclass class, jlong nativeCtxInfo, jlong nativeMeshViewInfo,
2171         jint cullMode)
2172 {
2173     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
2174     MeshViewInfo *meshViewInfo = (MeshViewInfo *) jlong_to_ptr(nativeMeshViewInfo);
2175     if ((ctxInfo == NULL) || (meshViewInfo == NULL)) {
2176         return;
2177     }
2178     switch (cullMode) {
2179         case com_sun_prism_es2_GLContext_GL_BACK:
2180             meshViewInfo-&gt;cullEnable = GL_TRUE;
2181             meshViewInfo-&gt;cullMode = GL_BACK;
2182             break;
2183         case com_sun_prism_es2_GLContext_GL_FRONT:
2184             meshViewInfo-&gt;cullEnable = GL_TRUE;
2185             meshViewInfo-&gt;cullMode = GL_FRONT;
2186             break;
2187         case com_sun_prism_es2_GLContext_GL_NONE:
2188             meshViewInfo-&gt;cullEnable = GL_FALSE;
2189             meshViewInfo-&gt;cullMode = GL_BACK;
2190             break;
2191     }
2192 }
2193 
2194 /*
2195  * Class:     com_sun_prism_es2_GLContext
2196  * Method:    nSetMaterial
2197  * Signature: (JJJ)V
2198  */
2199 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nSetMaterial
2200   (JNIEnv *env, jclass class, jlong nativeCtxInfo, jlong nativeMeshViewInfo,
2201         jlong nativePhongMaterialInfo)
2202 {
2203     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
2204     MeshViewInfo *mvInfo = (MeshViewInfo *) jlong_to_ptr(nativeMeshViewInfo);
2205     PhongMaterialInfo *pmInfo = (PhongMaterialInfo *) jlong_to_ptr(nativePhongMaterialInfo);
2206     if ((ctxInfo == NULL) || (mvInfo == NULL) || (pmInfo == NULL)) {
2207         return;
2208     }
2209     mvInfo-&gt;phongMaterialInfo = pmInfo;
2210 }
2211 
2212 void setPolyonMode(ContextInfo *ctxInfo, MeshViewInfo *mvInfo) {
2213 #ifndef IS_EGL
2214     if (mvInfo-&gt;fillMode != ctxInfo-&gt;state.fillMode) {
2215         glPolygonMode(GL_FRONT_AND_BACK, mvInfo-&gt;fillMode);
2216         ctxInfo-&gt;state.fillMode = mvInfo-&gt;fillMode;
2217     }
2218 #endif
2219 }
2220 
2221 /*
2222  * Class:     com_sun_prism_es2_GLContext
2223  * Method:    nSetWireframe
2224  * Signature: (JJZ)V
2225  */
2226 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nSetWireframe
2227   (JNIEnv *env, jclass class, jlong nativeCtxInfo, jlong nativeMeshViewInfo,
2228         jboolean wireframe)
2229 {
2230     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
2231     MeshViewInfo *meshViewInfo = (MeshViewInfo *) jlong_to_ptr(nativeMeshViewInfo);
2232     if ((ctxInfo == NULL) || (meshViewInfo == NULL)) {
2233         return;
2234     }
2235     if (wireframe) {
2236         meshViewInfo-&gt;fillMode = GL_LINE;
2237     } else {
2238         meshViewInfo-&gt;fillMode = GL_FILL;
2239     }
2240 }
2241 
2242 /*
2243  * Class:     com_sun_prism_es2_GLContext
2244  * Method:    nSetAmbientLight
2245  * Signature: (JJFFF)V
2246  */
2247 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nSetAmbientLight
2248   (JNIEnv *env, jclass class, jlong nativeCtxInfo, jlong nativeMeshViewInfo,
2249         jfloat r, jfloat g, jfloat b)
2250 {
2251     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
2252     MeshViewInfo *meshViewInfo = (MeshViewInfo *) jlong_to_ptr(nativeMeshViewInfo);
2253     if ((ctxInfo == NULL) || (meshViewInfo == NULL)) {
2254         return;
2255     }
2256     meshViewInfo-&gt;ambientLightColor[0] = r;
2257     meshViewInfo-&gt;ambientLightColor[1] = g;
2258     meshViewInfo-&gt;ambientLightColor[2] = b;
2259 }
2260 
2261 /*
2262  * Class:     com_sun_prism_es2_GLContext
2263  * Method:    nSetPointLight
2264  * Signature: (JJIFFFFFFF)V
2265  */
2266 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nSetPointLight
2267   (JNIEnv *env, jclass class, jlong nativeCtxInfo, jlong nativeMeshViewInfo,
<a name="3" id="anc3"></a><span class="line-modified">2268         jint index, jfloat x, jfloat y, jfloat z, jfloat r, jfloat g, jfloat b, jfloat w)</span>

2269 {
2270     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
2271     MeshViewInfo *meshViewInfo = (MeshViewInfo *) jlong_to_ptr(nativeMeshViewInfo);
2272     // NOTE: We only support up to 3 point lights at the present
2273     if ((ctxInfo == NULL) || (meshViewInfo == NULL) || (index &lt; 0) || (index &gt; 2)) {
2274         return;
2275     }
2276     meshViewInfo-&gt;pointLightIndex = index;
2277     meshViewInfo-&gt;pointLightPosition[0] = x;
2278     meshViewInfo-&gt;pointLightPosition[1] = y;
2279     meshViewInfo-&gt;pointLightPosition[2] = z;
2280     meshViewInfo-&gt;pointLightColor[0] = r;
2281     meshViewInfo-&gt;pointLightColor[1] = g;
2282     meshViewInfo-&gt;pointLightColor[2] = b;
2283     meshViewInfo-&gt;pointLightWeight = w;
<a name="4" id="anc4"></a>



2284 }
2285 
2286 /*
2287  * Class:     com_sun_prism_es2_GLContext
2288  * Method:    nRenderMeshView
2289  * Signature: (JJ)V
2290  */
2291 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nRenderMeshView
2292   (JNIEnv *env, jclass class, jlong nativeCtxInfo, jlong nativeMeshViewInfo)
2293 {
2294     GLuint offset = 0;
2295     MeshInfo *mInfo;
2296     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
2297     MeshViewInfo *mvInfo = (MeshViewInfo *) jlong_to_ptr(nativeMeshViewInfo);
2298     if ((ctxInfo == NULL) || (mvInfo == NULL) ||
2299             (ctxInfo-&gt;glBindBuffer == NULL) ||
2300             (ctxInfo-&gt;glBufferData == NULL) ||
2301             (ctxInfo-&gt;glDisableVertexAttribArray == NULL) ||
2302             (ctxInfo-&gt;glEnableVertexAttribArray == NULL) ||
2303             (ctxInfo-&gt;glVertexAttribPointer == NULL)) {
2304         return;
2305     }
2306 
2307     if ((mvInfo-&gt;phongMaterialInfo == NULL) || (mvInfo-&gt;meshInfo == NULL)) {
2308         return;
2309     }
2310 
2311     setCullMode(ctxInfo, mvInfo);
2312     setPolyonMode(ctxInfo, mvInfo);
2313 
2314     // Draw triangles ...
2315     mInfo = mvInfo-&gt;meshInfo;
2316     ctxInfo-&gt;glBindBuffer(GL_ARRAY_BUFFER, mInfo-&gt;vboIDArray[MESH_VERTEXBUFFER]);
2317     ctxInfo-&gt;glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mInfo-&gt;vboIDArray[MESH_INDEXBUFFER]);
2318 
2319     ctxInfo-&gt;glEnableVertexAttribArray(VC_3D_INDEX);
2320     ctxInfo-&gt;glEnableVertexAttribArray(TC_3D_INDEX);
2321     ctxInfo-&gt;glEnableVertexAttribArray(NC_3D_INDEX);
2322 
2323     ctxInfo-&gt;glVertexAttribPointer(VC_3D_INDEX, VC_3D_SIZE, GL_FLOAT, GL_FALSE,
2324             VERT_3D_STRIDE, (const GLvoid *) jlong_to_ptr((jlong) offset));
2325     offset += VC_3D_SIZE * sizeof(GLfloat);
2326     ctxInfo-&gt;glVertexAttribPointer(TC_3D_INDEX, TC_3D_SIZE, GL_FLOAT, GL_FALSE,
2327             VERT_3D_STRIDE, (const GLvoid *) jlong_to_ptr((jlong) offset));
2328     offset += TC_3D_SIZE * sizeof(GLfloat);
2329     ctxInfo-&gt;glVertexAttribPointer(NC_3D_INDEX, NC_3D_SIZE, GL_FLOAT, GL_FALSE,
2330             VERT_3D_STRIDE, (const GLvoid *) jlong_to_ptr((jlong) offset));
2331 
2332     glDrawElements(GL_TRIANGLES, mvInfo-&gt;meshInfo-&gt;indexBufferSize,
2333             mvInfo-&gt;meshInfo-&gt;indexBufferType, 0);
2334 
2335     // Reset states
2336     ctxInfo-&gt;glDisableVertexAttribArray(VC_3D_INDEX);
2337     ctxInfo-&gt;glDisableVertexAttribArray(NC_3D_INDEX);
2338     ctxInfo-&gt;glDisableVertexAttribArray(TC_3D_INDEX);
2339     ctxInfo-&gt;glBindBuffer(GL_ARRAY_BUFFER, 0);
2340     ctxInfo-&gt;glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
2341 }
2342 
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>