<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.swt/src/main/java/javafx/embed/swt/FXCanvas.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.embed.swt;
  27 
  28 import com.sun.glass.ui.Application;
  29 import com.sun.glass.ui.Pixels;
  30 import com.sun.javafx.cursor.CursorFrame;
  31 import com.sun.javafx.cursor.CursorType;
  32 import com.sun.javafx.embed.AbstractEvents;
  33 import com.sun.javafx.embed.EmbeddedSceneDSInterface;
  34 import com.sun.javafx.embed.EmbeddedSceneDTInterface;
  35 import com.sun.javafx.embed.EmbeddedSceneInterface;
  36 import com.sun.javafx.embed.EmbeddedStageInterface;
  37 import com.sun.javafx.embed.HostInterface;
  38 import com.sun.javafx.stage.EmbeddedWindow;
  39 
  40 import java.lang.reflect.Field;
  41 import java.lang.reflect.Method;
  42 import java.nio.ByteBuffer;
  43 import java.nio.IntBuffer;
  44 import java.security.AccessController;
  45 import java.security.PrivilegedAction;
  46 import java.util.ArrayList;
  47 import java.util.Arrays;
  48 import java.util.HashSet;
  49 import java.util.Set;
  50 import java.util.Stack;
  51 import java.util.concurrent.CountDownLatch;
  52 
  53 import javafx.application.Platform;
  54 import javafx.beans.NamedArg;
  55 import javafx.scene.Scene;
  56 import javafx.scene.input.TransferMode;
  57 import javafx.stage.Window;
  58 import javafx.util.FXPermission;
  59 
  60 import org.eclipse.swt.SWT;
  61 import org.eclipse.swt.dnd.DND;
  62 import org.eclipse.swt.dnd.DragSource;
  63 import org.eclipse.swt.dnd.DragSourceListener;
  64 import org.eclipse.swt.dnd.DropTarget;
  65 import org.eclipse.swt.dnd.DropTargetEvent;
  66 import org.eclipse.swt.dnd.DropTargetListener;
  67 import org.eclipse.swt.dnd.FileTransfer;
  68 import org.eclipse.swt.dnd.HTMLTransfer;
  69 import org.eclipse.swt.dnd.ImageTransfer;
  70 import org.eclipse.swt.dnd.RTFTransfer;
  71 import org.eclipse.swt.dnd.TextTransfer;
  72 import org.eclipse.swt.dnd.Transfer;
  73 import org.eclipse.swt.dnd.TransferData;
  74 import org.eclipse.swt.dnd.URLTransfer;
  75 import org.eclipse.swt.events.ControlEvent;
  76 import org.eclipse.swt.events.ControlListener;
  77 import org.eclipse.swt.events.DisposeEvent;
  78 import org.eclipse.swt.events.DisposeListener;
  79 import org.eclipse.swt.events.FocusEvent;
  80 import org.eclipse.swt.events.FocusListener;
  81 import org.eclipse.swt.events.GestureEvent;
  82 import org.eclipse.swt.events.KeyEvent;
  83 import org.eclipse.swt.events.KeyListener;
  84 import org.eclipse.swt.events.MenuDetectEvent;
  85 import org.eclipse.swt.events.MouseEvent;
  86 import org.eclipse.swt.events.MouseListener;
  87 import org.eclipse.swt.events.MouseTrackListener;
  88 import org.eclipse.swt.events.PaintEvent;
  89 import org.eclipse.swt.graphics.Image;
  90 import org.eclipse.swt.graphics.ImageData;
  91 import org.eclipse.swt.graphics.PaletteData;
  92 import org.eclipse.swt.graphics.Point;
  93 import org.eclipse.swt.graphics.RGB;
  94 import org.eclipse.swt.graphics.Rectangle;
  95 import org.eclipse.swt.widgets.Canvas;
  96 import org.eclipse.swt.widgets.Composite;
  97 import org.eclipse.swt.widgets.Control;
  98 import org.eclipse.swt.widgets.Display;
  99 import org.eclipse.swt.widgets.Event;
 100 import org.eclipse.swt.widgets.Listener;
 101 import org.eclipse.swt.widgets.Shell;
 102 
 103 /**
 104  * {@code FXCanvas} is a component to embed JavaFX content into
 105  * SWT applications. The content to be displayed is specified
 106  * with the {@link #setScene} method that accepts an instance of
 107  * JavaFX {@code Scene}. After the scene is attached, it gets
 108  * repainted automatically. All the input and focus events are
 109  * forwarded to the scene transparently to the developer.
 110  * &lt;p&gt;
 111  * Here is a typical pattern how {@code FXCanvas} can used:
 112  * &lt;pre&gt;
 113  *    public class Test {
 114  *        private static Scene createScene() {
 115  *            Group group = new Group();
 116  *            Scene scene = new Scene(group);
 117  *            Button button = new Button(&quot;JFX Button&quot;);
 118  *            group.getChildren().add(button);
 119  *            return scene;
 120  *        }
 121  *
 122  *        public static void main(String[] args) {
 123  *            Display display = new Display();
 124  *            Shell shell = new Shell(display);
 125  *            shell.setLayout(new FillLayout());
 126  *            FXCanvas canvas = new FXCanvas(shell, SWT.NONE);
 127  *            Scene scene = createScene();
 128  *            canvas.setScene(scene);
 129  *            shell.open();
 130  *            while (!shell.isDisposed()) {
 131  *                if (!display.readAndDispatch()) display.sleep();
 132  *            }
 133  *            display.dispose();
 134  *        }
 135  *    }
 136  * &lt;/pre&gt;
 137  *
 138  *
 139  * @since JavaFX 2.0
 140  */
 141 public class FXCanvas extends Canvas {
 142 
 143     // Internal permission used by FXCanvas (SWT interop)
 144     private static final FXPermission FXCANVAS_PERMISSION =
 145             new FXPermission(&quot;accessFXCanvasInternals&quot;);
 146 
 147     private HostContainer hostContainer;
 148     private volatile EmbeddedWindow stage;
 149     private volatile Scene scene;
 150     private EmbeddedStageInterface stagePeer;
 151     private EmbeddedSceneInterface scenePeer;
 152 
 153     private int pWidth = 0;
 154     private int pHeight = 0;
 155 
 156     private volatile int pPreferredWidth = -1;
 157     private volatile int pPreferredHeight = -1;
 158 
 159     private IntBuffer pixelsBuf = null;
 160 
 161     // This filter runs when any widget is moved
 162     Listener moveFilter = event -&gt; {
 163         // If a parent has moved, send a move event to FX
 164         Control control = FXCanvas.this;
 165         while (control != null) {
 166             if (control == event.widget) {
 167                 sendMoveEventToFX();
 168                 break;
 169             }
 170             control = control.getParent();
 171         };
 172     };
 173 
 174     private double getScaleFactor() {
 175         if (SWT.getPlatform().equals(&quot;cocoa&quot;)) {
 176             if (windowField == null || screenMethod == null || backingScaleFactorMethod == null) {
 177                 return 1.0;
 178             }
 179             try {
 180                 Object nsWindow = windowField.get(this.getShell());
 181                 Object nsScreen = screenMethod.invoke(nsWindow);
 182                 Object bsFactor = backingScaleFactorMethod.invoke(nsScreen);
 183                 return ((Double) bsFactor).doubleValue();
 184             } catch (Exception e) {
 185                 // FAIL silently should the reflection fail
 186             }
 187         } else if (SWT.getPlatform().equals(&quot;win32&quot;)) {
 188             if (swtDPIUtilMethod == null) {
 189                 return 1.0;
 190             }
 191             try {
 192                 Integer value = (Integer) swtDPIUtilMethod.invoke(null);
 193                 return value.intValue() / 100.0;
 194             } catch (Exception e) {
 195                 // FAIL silently should the reflection fail
 196             }
 197         }
 198         return 1.0;
 199     }
 200 
 201     private DropTarget dropTarget;
 202 
 203     static Transfer [] StandardTransfers = new Transfer [] {
 204         TextTransfer.getInstance(),
 205         RTFTransfer.getInstance(),
 206         HTMLTransfer.getInstance(),
 207         URLTransfer.getInstance(),
 208         ImageTransfer.getInstance(),
 209         FileTransfer.getInstance(),
 210     };
 211     static Transfer [] CustomTransfers = new Transfer [0];
 212 
 213     static Transfer [] getAllTransfers () {
 214         Transfer [] transfers = new Transfer[StandardTransfers.length + CustomTransfers.length];
 215         System.arraycopy(StandardTransfers, 0, transfers, 0, StandardTransfers.length);
 216         System.arraycopy(CustomTransfers, 0, transfers, StandardTransfers.length, CustomTransfers.length);
 217         return transfers;
 218     }
 219 
 220     static Transfer getCustomTransfer(String mime) {
 221         for (int i=0; i&lt;CustomTransfers.length; i++) {
 222             if (((CustomTransfer)CustomTransfers[i]).getMime().equals(mime)) {
 223                 return CustomTransfers[i];
 224             }
 225         }
 226         Transfer transfer = new CustomTransfer (mime, mime);
 227         Transfer [] newCustom = new Transfer [CustomTransfers.length + 1];
 228         System.arraycopy(CustomTransfers, 0, newCustom, 0, CustomTransfers.length);
 229         newCustom[CustomTransfers.length] = transfer;
 230         CustomTransfers = newCustom;
 231         return transfer;
 232     }
 233 
 234     private static Field windowField;
 235     private static Method windowMethod;
 236     private static Method screenMethod;
 237     private static Method backingScaleFactorMethod;
 238     private static Method swtDPIUtilMethod;
 239 
 240     static {
 241         if (SWT.getPlatform().equals(&quot;cocoa&quot;)) {
 242             try {
 243                 windowField = Shell.class.getDeclaredField(&quot;window&quot;);
 244                 windowField.setAccessible(true);
 245 
 246                 Class nsViewClass = Class.forName(&quot;org.eclipse.swt.internal.cocoa.NSView&quot;);
 247                 windowMethod = nsViewClass.getDeclaredMethod(&quot;window&quot;);
 248                 windowMethod.setAccessible(true);
 249 
 250                 Class nsWindowClass = Class.forName(&quot;org.eclipse.swt.internal.cocoa.NSWindow&quot;);
 251                 screenMethod = nsWindowClass.getDeclaredMethod(&quot;screen&quot;);
 252                 screenMethod.setAccessible(true);
 253 
 254                 Class nsScreenClass = Class.forName(&quot;org.eclipse.swt.internal.cocoa.NSScreen&quot;);
 255                 backingScaleFactorMethod = nsScreenClass.getDeclaredMethod(&quot;backingScaleFactor&quot;);
 256                 backingScaleFactorMethod.setAccessible(true);
 257             } catch (Exception e) {
 258                 //Fail silently.  If we can&#39;t get the methods, then the current version of SWT has no retina support
 259             }
 260         } else if (SWT.getPlatform().equals(&quot;win32&quot;)) {
 261             try {
 262                 String autoScale = AccessController.doPrivileged((PrivilegedAction&lt;String&gt;)() -&gt; System.getProperty(&quot;swt.autoScale&quot;));
 263                 if (autoScale == null || ! &quot;false&quot;.equalsIgnoreCase(autoScale)) {
 264                     Class dpiUtilClass = Class.forName(&quot;org.eclipse.swt.internal.DPIUtil&quot;);
 265                     swtDPIUtilMethod = dpiUtilClass.getMethod(&quot;getDeviceZoom&quot;);
 266                 }
 267             } catch (Exception e) {
 268                 //Fail silently.  If we can&#39;t get the methods, then the current version of SWT has no retina support
 269             }
 270         }
 271         initFx();
 272     }
 273 
 274     /**
 275      * @inheritDoc
 276      */
 277     public FXCanvas(@NamedArg(&quot;parent&quot;) Composite parent, @NamedArg(&quot;style&quot;) int style) {
 278         super(parent, style | SWT.NO_BACKGROUND);
 279         setApplicationName(Display.getAppName());
 280         hostContainer = new HostContainer();
 281         registerEventListeners();
 282         Display display = parent.getDisplay();
 283         display.addFilter(SWT.Move, moveFilter);
 284     }
 285 
 286     /**
 287      * Retrieves the {@code FXCanvas} embedding the given {@code Scene},
 288      * that is the {@code FXCanvas} to which the given {@code Scene} was
 289      * attached using {@link #setScene}.
 290      *
 291      * @param scene the {@code Scene} whose embedding {@code FXCanvas}
 292      *              instance is to be retrieved
 293      * @return the {@code FXCanvas} to which the given {@code Scene} is
 294      * attached, or null if the given {@code Scene} is not attached to an
 295      * {@code FXCanvas}.
 296      *
 297      * @since 9
 298      */
 299     public static FXCanvas getFXCanvas(Scene scene) {
 300         Window window = scene.getWindow();
 301         if (window != null &amp;&amp; window instanceof EmbeddedWindow) {
 302             HostInterface hostInterface = ((EmbeddedWindow) window).getHost();
 303             if (hostInterface instanceof HostContainer) {
 304                 // Obtain FXCanvas as the enclosing instance of the FXCanvas$HostContainer
 305                 // that is host of the embedded Scene&#39;s EmbeddedWindow.
 306                 return ((HostContainer)hostInterface).fxCanvas;
 307             }
 308         }
 309         return null;
 310     }
 311 
 312     private static void initFx() {
 313         // NOTE: no internal &quot;com.sun.*&quot; packages can be accessed until after
 314         // the JavaFX platform is initialized. The list of needed internal
 315         // packages is kept in the PlatformImpl class.
 316         long eventProc = 0;
 317         try {
 318             Field field = Display.class.getDeclaredField(&quot;eventProc&quot;);
 319             field.setAccessible(true);
 320             if (field.getType() == int.class) {
 321                 eventProc = field.getInt(Display.getDefault());
 322             } else {
 323                 if (field.getType() == long.class) {
 324                     eventProc = field.getLong(Display.getDefault());
 325                 }
 326             }
 327         } catch (Throwable th) {
 328             //Fail silently
 329         }
 330         final String eventProcStr = String.valueOf(eventProc);
 331 
 332         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 333             System.setProperty(&quot;com.sun.javafx.application.type&quot;, &quot;FXCanvas&quot;);
 334             System.setProperty(&quot;javafx.embed.isEventThread&quot;, &quot;true&quot;);
 335             if (swtDPIUtilMethod == null) {
 336                 System.setProperty(&quot;glass.win.uiScale&quot;, &quot;100%&quot;);
 337                 System.setProperty(&quot;glass.win.renderScale&quot;, &quot;100%&quot;);
 338             } else {
 339                 Integer scale = 100;
 340                 try {
 341                     scale = (Integer) swtDPIUtilMethod.invoke(null);
 342                 } catch (Exception e) {
 343                     //Fail silently
 344                 }
 345                 System.setProperty(&quot;glass.win.uiScale&quot;, scale + &quot;%&quot;);
 346                 System.setProperty(&quot;glass.win.renderScale&quot;, scale + &quot;%&quot;);
 347             }
 348             System.setProperty(&quot;javafx.embed.eventProc&quot;, eventProcStr);
 349             return null;
 350         });
 351 
 352         final CountDownLatch startupLatch = new CountDownLatch(1);
 353         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 354             Platform.startup(() -&gt; {
 355                 startupLatch.countDown();
 356             });
 357             return null;
 358         }, null, FXCANVAS_PERMISSION);
 359 
 360         try {
 361             startupLatch.await();
 362         } catch (InterruptedException ex) {
 363             throw new RuntimeException(ex);
 364         }
 365     }
 366 
 367     private void setApplicationName(String name) {
 368         Platform.runLater(()-&gt; Application.GetApplication().setName(name));
 369     }
 370 
 371     // Work around because SWT does not send reparent events but Control#setParent
 372     // calls reskin(SWT.ALL) so this implementation detail can be used to update
 373     // the current x/y position of the embedded stage
 374     //
 375     // There are other situations where reskin() is called but they are not frequent
 376     // and the only harm is that we potentially recompute the location although it did
 377     // not change in reality
 378     @Override
 379     public void reskin(int flags) {
 380         super.reskin(flags);
 381         if (flags == SWT.ALL) {
 382             sendMoveEventToFX();
 383         }
 384     }
 385 
 386     static ArrayList&lt;DropTarget&gt; targets = new ArrayList&lt;&gt;();
 387 
 388     DropTarget getDropTarget() {
 389         return dropTarget;
 390     }
 391 
 392     void setDropTarget(DropTarget newTarget) {
 393         if (dropTarget != null) {
 394             targets.remove(dropTarget);
 395             dropTarget.dispose();
 396         }
 397         dropTarget = newTarget;
 398         if (dropTarget != null) {
 399             targets.add(dropTarget);
 400         }
 401     }
 402 
 403     static void updateDropTarget() {
 404         // Update all drop targets rather than just this target
 405         //
 406         // In order for a drop target to recognise a custom format,
 407         // the format must be registered and the transfer type added
 408         // to the list of transfers that the target accepts.  This
 409         // must happen before the drag and drop operations starts
 410         // or the drop target will not accept the format.  Therefore,
 411         // set all transfers for all targets before any drag and drop
 412         // operation starts
 413         //
 414         for (DropTarget target : targets) {
 415             target.setTransfer(getAllTransfers());
 416         }
 417     }
 418 
 419     /**
 420      * {@inheritDoc}
 421      */
 422     public Point computeSize (int wHint, int hHint, boolean changed) {
 423         checkWidget();
 424         if (wHint == -1 &amp;&amp; hHint == -1) {
 425             if (pPreferredWidth != -1 &amp;&amp; pPreferredHeight != -1) {
 426                 return new Point (pPreferredWidth, pPreferredHeight);
 427             }
 428         }
 429         return super.computeSize(wHint, hHint, changed);
 430     }
 431 
 432     /**
 433      * Returns the JavaFX scene attached to this {@code FXCanvas}.
 434      *
 435      * @return the {@code Scene} attached to this {@code FXCanvas}
 436      */
 437     public Scene getScene() {
 438         checkWidget();
 439         return scene;
 440     }
 441 
 442     /**
 443      * Attaches a {@code Scene} object to display in this {@code
 444      * FXCanvas}. This method must called either on the JavaFX
 445      * JavaFX application thread (which is the same as the SWT
 446      * event dispatch thread).
 447      *
 448      * @param newScene a scene to display in this {@code FXCanvas}
 449      *
 450      * @see javafx.application.Platform#isFxApplicationThread()
 451      */
 452     public void setScene(final Scene newScene) {
 453         checkWidget();
 454 
 455         if ((stage == null) &amp;&amp; (newScene != null)) {
 456             stage = new EmbeddedWindow(hostContainer);
 457             stage.show();
 458         }
 459         scene = newScene;
 460         if (stage != null) {
 461             stage.setScene(newScene);
 462         }
 463         if ((stage != null) &amp;&amp; (newScene == null)) {
 464             stage.hide();
 465             stage = null;
 466         }
 467     }
 468 
 469     // Note that removing the listeners is unnecessary
 470     private void registerEventListeners() {
 471         addDisposeListener(new DisposeListener() {
 472             @Override
 473             public void widgetDisposed(DisposeEvent de) {
 474                 Display display = getDisplay();
 475                 display.removeFilter(SWT.Move, moveFilter);
 476                 FXCanvas.this.widgetDisposed(de);
 477             }
 478         });
 479 
 480         addPaintListener(pe -&gt; {
 481             FXCanvas.this.paintControl(pe);
 482         });
 483 
 484         addMouseListener(new MouseListener() {
 485             @Override
 486             public void mouseDoubleClick(MouseEvent me) {
 487                 // Clicks and double-clicks are handled in FX
 488             }
 489             @Override
 490             public void mouseDown(MouseEvent me) {
 491                 // FX only supports 5 buttons so don&#39;t send the event for other buttons
 492                 if (me.button &gt; 5) return;
 493                 FXCanvas.this.sendMouseEventToFX(me, AbstractEvents.MOUSEEVENT_PRESSED);
 494             }
 495             @Override
 496             public void mouseUp(MouseEvent me) {
 497                 // FX only supports 5 buttons so don&#39;t send the event for other buttons
 498                 if (me.button &gt; 5) return;
 499                 FXCanvas.this.sendMouseEventToFX(me, AbstractEvents.MOUSEEVENT_RELEASED);
 500             }
 501         });
 502 
 503         addMouseMoveListener(me -&gt; {
 504             if ((me.stateMask &amp; SWT.BUTTON_MASK) != 0) {
 505                 // FX only supports 5 buttons so don&#39;t send the event for other buttons
 506                 if ((me.stateMask &amp; (SWT.BUTTON1 | SWT.BUTTON2 | SWT.BUTTON3 | SWT.BUTTON4 | SWT.BUTTON5)) != 0) {
 507                     FXCanvas.this.sendMouseEventToFX(me, AbstractEvents.MOUSEEVENT_DRAGGED);
 508                 } else {
 509                     FXCanvas.this.sendMouseEventToFX(me, AbstractEvents.MOUSEEVENT_MOVED);
 510                 }
 511             } else {
 512                 FXCanvas.this.sendMouseEventToFX(me, AbstractEvents.MOUSEEVENT_MOVED);
 513             }
 514         });
 515 
 516         // SWT emulates mouse events from PAN gesture events.
 517         // We need to suppress them while a gesture is active or inertia events are still processed.
 518         addListener(SWT.MouseVerticalWheel, e -&gt; {
 519             if (!gestureActive &amp;&amp; (!panGestureInertiaActive || lastGestureEvent == null || e.time != lastGestureEvent.time)) {
 520                 FXCanvas.this.sendScrollEventToFX(AbstractEvents.MOUSEEVENT_VERTICAL_WHEEL,
 521                         0, SWTEvents.getWheelRotation(e), e.x, e.y, e.stateMask, false);
 522             }
 523         });
 524         addListener(SWT.MouseHorizontalWheel, e -&gt; {
 525             if (!gestureActive &amp;&amp; (!panGestureInertiaActive || lastGestureEvent == null || e.time != lastGestureEvent.time)) {
 526                 FXCanvas.this.sendScrollEventToFX(AbstractEvents.MOUSEEVENT_HORIZONTAL_WHEEL,
 527                         SWTEvents.getWheelRotation(e), 0, e.x, e.y, e.stateMask, false);
 528             }
 529         });
 530 
 531         addMouseTrackListener(new MouseTrackListener() {
 532             @Override
 533             public void mouseEnter(MouseEvent me) {
 534                 FXCanvas.this.sendMouseEventToFX(me, AbstractEvents.MOUSEEVENT_ENTERED);
 535             }
 536             @Override
 537             public void mouseExit(MouseEvent me) {
 538                 FXCanvas.this.sendMouseEventToFX(me, AbstractEvents.MOUSEEVENT_EXITED);
 539             }
 540             @Override
 541             public void mouseHover(MouseEvent me) {
 542                 // No mouse hovering in FX
 543             }
 544         });
 545 
 546         addControlListener(new ControlListener() {
 547             @Override
 548             public void controlMoved(ControlEvent ce) {
 549                 FXCanvas.this.sendMoveEventToFX();
 550             }
 551             @Override
 552             public void controlResized(ControlEvent ce) {
 553                 FXCanvas.this.sendResizeEventToFX();
 554             }
 555         });
 556 
 557         addFocusListener(new FocusListener() {
 558             @Override
 559             public void focusGained(FocusEvent fe) {
 560                 FXCanvas.this.sendFocusEventToFX(fe, true);
 561             }
 562             @Override
 563             public void focusLost(FocusEvent fe) {
 564                 FXCanvas.this.sendFocusEventToFX(fe, false);
 565             }
 566         });
 567 
 568         addKeyListener(new KeyListener() {
 569             @Override
 570             public void keyPressed(KeyEvent e) {
 571                 FXCanvas.this.sendKeyEventToFX(e, SWT.KeyDown);
 572 
 573             }
 574             @Override
 575             public void keyReleased(KeyEvent e) {
 576                 FXCanvas.this.sendKeyEventToFX(e, SWT.KeyUp);
 577             }
 578         });
 579 
 580         addGestureListener(ge -&gt; {
 581             FXCanvas.this.sendGestureEventToFX(ge);
 582         });
 583 
 584         addMenuDetectListener(e -&gt; {
 585             Runnable r = () -&gt; {
 586                 if (isDisposed()) return;
 587                 FXCanvas.this.sendMenuEventToFX(e);
 588             };
 589             // In SWT, MenuDetect comes before the equivalent mouse event
 590             // On Mac, the order is MenuDetect, MouseDown, MouseUp.  FX
 591             // does not expect this order and when it gets the MouseDown,
 592             // it closes the menu.  The fix is to defer the MenuDetect
 593             // notification until after the MouseDown is sent to FX.
 594             if (&quot;cocoa&quot;.equals(SWT.getPlatform())) {
 595                 getDisplay().asyncExec(r);
 596             } else {
 597                 r.run();
 598             }
 599         });
 600     }
 601 
 602     private void widgetDisposed(DisposeEvent de) {
 603         setDropTarget(null);
 604         if (stage != null) {
 605             stage.hide();
 606         }
 607     }
 608 
 609     double lastScaleFactor = 1.0;
 610     int lastWidth, lastHeight;
 611     IntBuffer lastPixelsBuf =  null;
 612     private void paintControl(PaintEvent pe) {
 613         if ((scenePeer == null) || (pixelsBuf == null)) {
 614             return;
 615         }
 616 
 617         double scaleFactor = getScaleFactor();
 618         if (lastScaleFactor != scaleFactor) {
 619             resizePixelBuffer(scaleFactor);
 620             lastScaleFactor = scaleFactor;
 621             scenePeer.setPixelScaleFactors((float)scaleFactor, (float)scaleFactor);
 622         }
 623 
 624         // if we can&#39;t get the pixels, draw the bits that were there before
 625         IntBuffer buffer = pixelsBuf;
 626         int width = pWidth, height = pHeight;
 627         if (scenePeer.getPixels(pixelsBuf, pWidth, pHeight)) {
 628             width = lastWidth = pWidth;
 629             height = lastHeight = pHeight;
 630             buffer = lastPixelsBuf = pixelsBuf;
 631         } else {
 632             if (lastPixelsBuf == null) return;
 633             width = lastWidth;
 634             height = lastHeight;
 635             buffer = lastPixelsBuf;
 636         }
 637         width = (int)Math.ceil(width * scaleFactor);
 638         height = (int)Math.ceil(height * scaleFactor);
 639 
 640         // Consider optimizing this
 641         ImageData imageData = null;
 642         if (&quot;win32&quot;.equals(SWT.getPlatform())) {
 643             PaletteData palette = new PaletteData(0xFF00, 0xFF0000, 0xFF000000);
 644             int scanline = width * 4;
 645             byte[] dstData = new byte[scanline * height];
 646             int[] srcData = buffer.array();
 647             int dp = 0, sp = 0;
 648             for (int y = 0; y &lt; height; y++) {
 649                 for (int x = 0; x &lt; width; x++) {
 650                     int p = srcData[sp++];
 651                     dstData[dp++] = (byte) (p &amp; 0xFF); //dst:blue
 652                     dstData[dp++] = (byte)((p &gt;&gt; 8) &amp; 0xFF); //dst:green
 653                     dstData[dp++] = (byte)((p &gt;&gt; 16) &amp; 0xFF); //dst:green
 654                     dstData[dp++] = (byte)0x00; //alpha
 655                 }
 656             }
 657             /*ImageData*/ imageData = new ImageData(width, height, 32, palette, 4, dstData);
 658         } else {
 659             if (width * height &gt; buffer.array().length) {
 660                 // We shouldn&#39;t be here...
 661                 System.err.println(&quot;FXCanvas.paintControl: scale mismatch!&quot;);
 662                 return;
 663             }
 664             PaletteData palette = new PaletteData(0x00ff0000, 0x0000ff00, 0x000000ff);
 665             /*ImageData*/  imageData = new ImageData(width, height, 32, palette);
 666             imageData.setPixels(0, 0,width * height, buffer.array(), 0);
 667         }
 668 
 669         Image image = new Image(Display.getDefault(), imageData);
 670         pe.gc.drawImage(image, 0, 0, width, height, 0, 0, pWidth, pHeight);
 671         image.dispose();
 672     }
 673 
 674     private void sendMoveEventToFX() {
 675         if ((stagePeer == null) /*|| !isShowing()*/) {
 676             return;
 677         }
 678         Rectangle rect = getClientArea();
 679         Point los = toDisplay(rect.x, rect.y);
 680         stagePeer.setLocation(los.x, los.y);
 681     }
 682 
 683     private void sendMouseEventToFX(MouseEvent me, int embedMouseType) {
 684         if (scenePeer == null) {
 685             return;
 686         }
 687 
 688         Point los = toDisplay(me.x, me.y);
 689         boolean primaryBtnDown = (me.stateMask &amp; SWT.BUTTON1) != 0;
 690         boolean middleBtnDown = (me.stateMask &amp; SWT.BUTTON2) != 0;
 691         boolean secondaryBtnDown = (me.stateMask &amp; SWT.BUTTON3) != 0;
 692         boolean backBtnDown = (me.stateMask &amp; SWT.BUTTON4) != 0;
 693         boolean forwardBtnDown = (me.stateMask &amp; SWT.BUTTON5) != 0;
 694         boolean shift = (me.stateMask &amp; SWT.SHIFT) != 0;
 695         boolean control = (me.stateMask &amp; SWT.CONTROL) != 0;
 696         boolean alt = (me.stateMask &amp; SWT.ALT) != 0;
 697         boolean meta = (me.stateMask &amp; SWT.COMMAND) != 0;
 698         int button = me.button;
 699         switch (embedMouseType) {
 700             case AbstractEvents.MOUSEEVENT_PRESSED:
 701                 primaryBtnDown |= me.button == 1;
 702                 middleBtnDown |= me.button == 2;
 703                 secondaryBtnDown |= me.button == 3;
 704                 backBtnDown |= me.button == 4;
 705                 forwardBtnDown |= me.button == 5;
 706                 break;
 707             case AbstractEvents.MOUSEEVENT_RELEASED:
 708                 primaryBtnDown &amp;= me.button != 1;
 709                 middleBtnDown &amp;= me.button != 2;
 710                 secondaryBtnDown &amp;= me.button != 3;
 711                 backBtnDown &amp;= me.button == 4;
 712                 forwardBtnDown &amp;= me.button == 5;
 713                 break;
 714             case AbstractEvents.MOUSEEVENT_CLICKED:
 715                 // Don&#39;t send click events to FX, as they are generated in Scene
 716                 return;
 717 
 718             case AbstractEvents.MOUSEEVENT_MOVED:
 719             case AbstractEvents.MOUSEEVENT_DRAGGED:
 720             case AbstractEvents.MOUSEEVENT_ENTERED:
 721             case AbstractEvents.MOUSEEVENT_EXITED:
 722                 // If this event was the result of mouse movement and has no
 723                 // button associated with it, then we look at the state to
 724                 // determine which button to report
 725                 if (button == 0) {
 726                     if ((me.stateMask &amp; SWT.BUTTON1) != 0) {
 727                         button = 1;
 728                     } else if ((me.stateMask &amp; SWT.BUTTON2) != 0) {
 729                         button = 2;
 730                     } else if ((me.stateMask &amp; SWT.BUTTON3) != 0) {
 731                         button = 3;
 732                     } else if ((me.stateMask &amp; SWT.BUTTON4) != 0) {
 733                         button = 4;
 734                     } else if ((me.stateMask &amp; SWT.BUTTON5) != 0) {
 735                         button = 5;
 736                     }
 737                 }
 738                 break;
 739 
 740             default:
 741                 break;
 742         }
 743 
 744         scenePeer.mouseEvent(
 745                 embedMouseType,
 746                 SWTEvents.mouseButtonToEmbedMouseButton(button, me.stateMask),
 747                 primaryBtnDown, middleBtnDown, secondaryBtnDown,
 748                 backBtnDown, forwardBtnDown,
 749                 me.x, me.y,
 750                 los.x, los.y,
 751                 shift, control, alt, meta,
 752                 false);  // RT-32990: popup trigger not implemented
 753     }
 754 
 755     double totalScrollX = 0;
 756     double totalScrollY = 0;
 757     private void sendScrollEventToFX(int type, double scrollX, double scrollY, int x, int y, int stateMask, boolean inertia) {
 758         if (scenePeer == null) {
 759             return;
 760         }
 761 
 762         double multiplier = 5.0;
 763         if (type == AbstractEvents.MOUSEEVENT_HORIZONTAL_WHEEL  || type == AbstractEvents.MOUSEEVENT_VERTICAL_WHEEL) {
 764             // granularity for mouse wheel scroll events is more coarse-grained than for pan gesture events
 765             multiplier = 40.0;
 766 
 767             // mouse wheel scroll events do not belong to a gesture,
 768             // so total scroll is not accumulated
 769             totalScrollX = scrollX;
 770             totalScrollY = scrollY;
 771         } else {
 772             // up to and including SWT 4.5, direction was inverted for pan gestures on the Mac
 773             // (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=481331)
 774             if (&quot;cocoa&quot;.equals(SWT.getPlatform()) &amp;&amp; SWT.getVersion() &lt; 4600) {
 775                 multiplier  *= -1.0;
 776             }
 777 
 778             if (type == AbstractEvents.SCROLLEVENT_STARTED) {
 779                 totalScrollX = 0;
 780                 totalScrollY = 0;
 781             } else if (inertia) {
 782                 // inertia events do not belong to the gesture,
 783                 // thus total scroll is not accumulated
 784                 totalScrollX = scrollX;
 785                 totalScrollY = scrollY;
 786             } else {
 787                 // accumulate total scroll as long as the gesture occurs
 788                 totalScrollX += scrollX;
 789                 totalScrollY += scrollY;
 790             }
 791         }
 792 
 793         Point los = toDisplay(x, y);
 794         scenePeer.scrollEvent(type,
 795                 scrollX, scrollY,
 796                 totalScrollX, totalScrollY,
 797                 multiplier, multiplier,
 798                 x, y,
 799                 los.x, los.y,
 800                 (stateMask &amp; SWT.SHIFT) != 0,
 801                 (stateMask &amp; SWT.CONTROL) != 0,
 802                 (stateMask &amp; SWT.ALT) != 0,
 803                 (stateMask &amp; SWT.COMMAND) != 0,
 804                 inertia);
 805     }
 806 
 807     private void sendKeyEventToFX(final KeyEvent e, int type) {
 808         if (scenePeer == null /*|| !isFxEnabled()*/) {
 809             return;
 810         }
 811         int stateMask = e.stateMask;
 812         if (type == SWT.KeyDown) {
 813             if (e.keyCode == SWT.SHIFT) stateMask |= SWT.SHIFT;
 814             if (e.keyCode == SWT.CONTROL) stateMask |= SWT.CONTROL;
 815             if (e.keyCode == SWT.ALT) stateMask |= SWT.ALT;
 816             if (e.keyCode == SWT.COMMAND) stateMask |= SWT.COMMAND;
 817         } else {
 818             if (e.keyCode == SWT.SHIFT) stateMask &amp;= ~SWT.SHIFT;
 819             if (e.keyCode == SWT.CONTROL) stateMask &amp;= ~SWT.CONTROL;
 820             if (e.keyCode == SWT.ALT) stateMask &amp;= ~SWT.ALT;
 821             if (e.keyCode == SWT.COMMAND) stateMask &amp;= ~SWT.COMMAND;
 822         }
 823         int keyCode = SWTEvents.keyCodeToEmbedKeyCode(e.keyCode);
 824         scenePeer.keyEvent(
 825                 SWTEvents.keyIDToEmbedKeyType(type),
 826                 keyCode, new char[0],
 827                 SWTEvents.keyModifiersToEmbedKeyModifiers(stateMask));
 828         if (e.character != &#39;\0&#39; &amp;&amp; type == SWT.KeyDown) {
 829             char[] chars = new char[] { e.character };
 830             scenePeer.keyEvent(
 831                     AbstractEvents.KEYEVENT_TYPED,
 832                     e.keyCode, chars,
 833                     SWTEvents.keyModifiersToEmbedKeyModifiers(stateMask));
 834         }
 835     }
 836 
 837     // true in between begin and end events of a (compound) gesture (not including inertia events)
 838     private boolean gestureActive = false;
 839     // true while inertia events of a pan gesture might be processed
 840     private boolean panGestureInertiaActive = false;
 841     // the last gesture event that was received (may also be an inertia event)
 842     private GestureEvent lastGestureEvent;
 843     // used to keep track of which (atomic) gestures are enclosed
 844     private Stack&lt;Integer&gt; nestedGestures = new Stack&lt;&gt;();
 845     // data used to compute inertia values for pan gesture events (as SWT does not provide these)
 846     private long inertiaTime = 0;
 847     private double inertiaXScroll = 0.0;
 848     private double inertiaYScroll = 0.0;
 849     private void sendGestureEventToFX(GestureEvent gestureEvent) {
 850         if (scenePeer == null) {
 851             return;
 852         }
 853 
 854         // An SWT gesture may be compound, comprising several MAGNIFY, PAN, and ROTATE events, which are enclosed by a
 855         // generic BEGIN and END event (while SWIPE events occur without being enclosed).
 856         // In JavaFX, such a compound gesture is represented through (possibly nested) atomic gestures, which all
 857         // (again excluding swipe) have their specific START and FINISH events.
 858         // While a complex SWT gesture is active, we therefore have to generate START events for atomic gestures as
 859         // needed, finishing them all when the compound SWT gesture ends (in the reverse order they were started),
 860         // after which we still process inertia events (that only seem to occur for PAN). SWIPE events may simply be
 861         // forwarded.
 862         switch (gestureEvent.detail) {
 863             case SWT.GESTURE_BEGIN:
 864                 // a (complex) gesture has started
 865                 gestureActive = true;
 866                 // we are within an active gesture, so no inertia processing now
 867                 panGestureInertiaActive = false;
 868                 break;
 869             case SWT.GESTURE_MAGNIFY:
 870                 // emulate the start of an atomic gesture
 871                 if (gestureActive &amp;&amp; !nestedGestures.contains(SWT.GESTURE_MAGNIFY)) {
 872                     sendZoomEventToFX(AbstractEvents.ZOOMEVENT_STARTED, gestureEvent);
 873                     nestedGestures.push(SWT.GESTURE_MAGNIFY);
 874                 }
 875                 sendZoomEventToFX(AbstractEvents.ZOOMEVENT_ZOOM, gestureEvent);
 876                 break;
 877             case SWT.GESTURE_PAN:
 878                 // emulate the start of an atomic gesture
 879                 if (gestureActive &amp;&amp; !nestedGestures.contains(SWT.GESTURE_PAN)) {
 880                     sendScrollEventToFX(AbstractEvents.SCROLLEVENT_STARTED, gestureEvent.xDirection, gestureEvent.yDirection,
 881                             gestureEvent.x, gestureEvent.y, gestureEvent.stateMask, false);
 882                     nestedGestures.push(SWT.GESTURE_PAN);
 883                 }
 884 
 885                 // SWT does not flag inertia events and does not allow to distinguish emulated PAN gesture events
 886                 // (resulting from mouse wheel interaction) from native ones (resulting from touch device interaction);
 887                 // as it will always send both, mouse wheel as well as PAN gesture events when using the touch device or
 888                 // the mouse wheel, we can identify native PAN gesture inertia events only based on their temporal relationship
 889                 // to the preceding gesture event.
 890                 if(panGestureInertiaActive &amp;&amp; gestureEvent.time &gt; lastGestureEvent.time + 250) {
 891                     panGestureInertiaActive = false;
 892                 }
 893 
 894                 if(gestureActive || panGestureInertiaActive) {
 895                     double xDirection = gestureEvent.xDirection;
 896                     double yDirection = gestureEvent.yDirection;
 897 
 898                     if (panGestureInertiaActive) {
 899                         // calculate inertia values for scrollX and scrollY, as SWT (at least on MacOSX) provides zero values
 900                         if (xDirection == 0 &amp;&amp; yDirection == 0) {
 901                             double delta = Math.max(0.0, Math.min(1.0, (gestureEvent.time - inertiaTime) / 1500.0));
 902                             xDirection = (1.0 - delta) * inertiaXScroll;
 903                             yDirection = (1.0 - delta) * inertiaYScroll;
 904                         }
 905                     }
 906 
 907                     sendScrollEventToFX(AbstractEvents.SCROLLEVENT_SCROLL, xDirection, yDirection,
 908                             gestureEvent.x, gestureEvent.y, gestureEvent.stateMask, panGestureInertiaActive);
 909                 }
 910                 break;
 911             case SWT.GESTURE_ROTATE:
 912                 // emulate the start of an atomic gesture
 913                 if(gestureActive &amp;&amp; !nestedGestures.contains(SWT.GESTURE_ROTATE)) {
 914                     sendRotateEventToFX(AbstractEvents.ROTATEEVENT_STARTED, gestureEvent);
 915                     nestedGestures.push(SWT.GESTURE_ROTATE);
 916                 }
 917                 sendRotateEventToFX(AbstractEvents.ROTATEEVENT_ROTATE, gestureEvent);
 918                 break;
 919             case SWT.GESTURE_SWIPE:
 920                 sendSwipeEventToFX(gestureEvent);
 921                 break;
 922             case SWT.GESTURE_END:
 923                 // finish atomic gesture(s) in reverse order of their start; SWIPE may be ignored,
 924                 // as JavaFX (like SWT) does not recognize it as a gesture
 925                 while (!nestedGestures.isEmpty()) {
 926                     switch (nestedGestures.pop()) {
 927                         case SWT.GESTURE_MAGNIFY:
 928                             sendZoomEventToFX(AbstractEvents.ZOOMEVENT_FINISHED, gestureEvent);
 929                             break;
 930                         case SWT.GESTURE_PAN:
 931                             sendScrollEventToFX(AbstractEvents.SCROLLEVENT_FINISHED, gestureEvent.xDirection, gestureEvent.yDirection,
 932                                     gestureEvent.x, gestureEvent.y, gestureEvent.stateMask, false);
 933                             // use the scroll values of the preceding scroll event to compute values for inertia events
 934                             inertiaXScroll = lastGestureEvent.xDirection;
 935                             inertiaYScroll = lastGestureEvent.yDirection;
 936                             inertiaTime = gestureEvent.time;
 937                             // from now on, inertia events may occur
 938                             panGestureInertiaActive = true;
 939                             break;
 940                         case SWT.GESTURE_ROTATE:
 941                             sendRotateEventToFX(AbstractEvents.ROTATEEVENT_FINISHED, gestureEvent);
 942                             break;
 943                     }
 944                 }
 945                 // compound SWT gesture has ended
 946                 gestureActive = false;
 947                 break;
 948             default:
 949                 // ignore
 950         }
 951         // keep track of currently received gesture event; this is needed to identify inertia events
 952         lastGestureEvent = gestureEvent;
 953     }
 954 
 955     // used to compute zoom deltas, which are not provided by SWT
 956     private double lastTotalZoom = 0.0;
 957     private void sendZoomEventToFX(int type, GestureEvent gestureEvent) {
 958         Point los = toDisplay(gestureEvent.x, gestureEvent.y);
 959 
 960         double totalZoom = gestureEvent.magnification;
 961         if (type == AbstractEvents.ZOOMEVENT_STARTED) {
 962             // ensure first event does not provide any zoom yet
 963             totalZoom = lastTotalZoom = 1.0;
 964         } else if (type == AbstractEvents.ZOOMEVENT_FINISHED) {
 965             // SWT uses 0.0 for final event, while JavaFX still provides a (total) zoom value
 966             totalZoom = lastTotalZoom;
 967         }
 968         double zoom = type == AbstractEvents.ZOOMEVENT_FINISHED ? 1.0 : totalZoom / lastTotalZoom;
 969         lastTotalZoom = totalZoom;
 970 
 971         scenePeer.zoomEvent(type, zoom, totalZoom,
 972                 gestureEvent.x, gestureEvent.y, los.x, los.y,
 973                 (gestureEvent.stateMask &amp; SWT.SHIFT) != 0,
 974                 (gestureEvent.stateMask &amp; SWT.CONTROL) != 0,
 975                 (gestureEvent.stateMask &amp; SWT.ALT) != 0,
 976                 (gestureEvent.stateMask &amp; SWT.COMMAND) != 0,
 977                 !gestureActive);
 978     }
 979 
 980     private double lastTotalAngle = 0.0;
 981     private void sendRotateEventToFX(int type, GestureEvent gestureEvent) {
 982         Point los = toDisplay(gestureEvent.x, gestureEvent.y);
 983 
 984         // SWT uses negative angle values to indicate clockwise rotation, while JavaFX uses positive ones.
 985         // We thus have to invert the values here
 986         double totalAngle = -gestureEvent.rotation;
 987         if (type == AbstractEvents.ROTATEEVENT_STARTED) {
 988             totalAngle = lastTotalAngle = 0.0;
 989         } else if (type == AbstractEvents.ROTATEEVENT_FINISHED) {
 990             // SWT uses 0.0 for final event, while JavaFX still provides a (total) rotation value
 991             totalAngle = lastTotalAngle;
 992         }
 993         double angle = type == AbstractEvents.ROTATEEVENT_FINISHED ? 0.0 : totalAngle - lastTotalAngle;
 994         lastTotalAngle = totalAngle;
 995 
 996         scenePeer.rotateEvent(type, angle, totalAngle,
 997                 gestureEvent.x, gestureEvent.y, los.x, los.y,
 998                 (gestureEvent.stateMask &amp; SWT.SHIFT) != 0,
 999                 (gestureEvent.stateMask &amp; SWT.CONTROL) != 0,
1000                 (gestureEvent.stateMask &amp; SWT.ALT) != 0,
1001                 (gestureEvent.stateMask &amp; SWT.COMMAND) != 0,
1002                 !gestureActive);
1003     }
1004 
1005     private void sendSwipeEventToFX(GestureEvent gestureEvent) {
1006         Point los = toDisplay(gestureEvent.x, gestureEvent.y);
1007         int type = -1;
1008         if(gestureEvent.yDirection &gt; 0) {
1009             type = AbstractEvents.SWIPEEVENT_DOWN;
1010         } else if(gestureEvent.yDirection &lt; 0) {
1011             type = AbstractEvents.SWIPEEVENT_UP;
1012         } else if(gestureEvent.xDirection &gt; 0) {
1013             type = AbstractEvents.SWIPEEVENT_RIGHT;
1014         } else if(gestureEvent.xDirection &lt; 0) {
1015             type = AbstractEvents.SWIPEEVENT_LEFT;
1016         }
1017         scenePeer.swipeEvent(type, gestureEvent.x, gestureEvent.y, los.x, los.y,
1018                 (gestureEvent.stateMask &amp; SWT.SHIFT) != 0,
1019                 (gestureEvent.stateMask &amp; SWT.CONTROL) != 0,
1020                 (gestureEvent.stateMask &amp; SWT.ALT) != 0,
1021                 (gestureEvent.stateMask &amp; SWT.COMMAND) != 0);
1022     }
1023 
1024     private void sendMenuEventToFX(MenuDetectEvent me) {
1025         if (scenePeer == null /*|| !isFxEnabled()*/) {
1026             return;
1027         }
1028         Point pt = toControl(me.x, me.y);
1029         scenePeer.menuEvent(pt.x, pt.y, me.x, me.y, false);
1030     }
1031 
1032     private void sendResizeEventToFX() {
1033 
1034         // force the panel to draw right away (avoid black rectangle)
1035         redraw();
1036         update();
1037 
1038         pWidth = getClientArea().width;
1039         pHeight = getClientArea().height;
1040 
1041         resizePixelBuffer(lastScaleFactor);
1042 
1043         if (scenePeer == null) {
1044             return;
1045         }
1046 
1047         stagePeer.setSize(pWidth, pHeight);
1048         scenePeer.setSize(pWidth, pHeight);
1049     }
1050 
1051     private void resizePixelBuffer(double newScaleFactor) {
1052         lastPixelsBuf = null;
1053         if ((pWidth &lt;= 0) || (pHeight &lt;= 0)) {
1054             pixelsBuf = null;
1055         } else {
1056             pixelsBuf = IntBuffer.allocate((int)Math.ceil(pWidth * newScaleFactor) *
1057                                            (int)Math.ceil(pHeight * newScaleFactor));
1058             // The bg color may show through on resize. See RT-34380.
1059             RGB rgb = getBackground().getRGB();
1060             Arrays.fill(pixelsBuf.array(), rgb.red &lt;&lt; 16 | rgb.green &lt;&lt; 8 | rgb.blue);
1061         }
1062     }
1063 
1064     private void sendFocusEventToFX(FocusEvent fe, boolean focused) {
1065         if ((stage == null) || (stagePeer == null)) {
1066             return;
1067         }
1068         int focusCause = (focused ?
1069                           AbstractEvents.FOCUSEVENT_ACTIVATED :
1070                           AbstractEvents.FOCUSEVENT_DEACTIVATED);
1071         stagePeer.setFocused(focused, focusCause);
1072     }
1073 
1074     private class HostContainer implements HostInterface {
1075 
1076         final FXCanvas fxCanvas = FXCanvas.this;
1077 
1078         @Override
1079         public void setEmbeddedStage(EmbeddedStageInterface embeddedStage) {
1080             stagePeer = embeddedStage;
1081             if (stagePeer == null) {
1082                 return;
1083             }
1084             if (pWidth &gt; 0 &amp;&amp; pHeight &gt; 0) {
1085                 stagePeer.setSize(pWidth, pHeight);
1086             }
1087             if (FXCanvas.this.isFocusControl()) {
1088                 stagePeer.setFocused(true, AbstractEvents.FOCUSEVENT_ACTIVATED);
1089             }
1090             sendMoveEventToFX();
1091             sendResizeEventToFX();
1092         }
1093 
1094         TransferMode getTransferMode(int bits) {
1095             switch (bits) {
1096                 case DND.DROP_COPY:
1097                     return TransferMode.COPY;
1098                 case DND.DROP_MOVE:
1099                 case DND.DROP_TARGET_MOVE:
1100                     return TransferMode.MOVE;
1101                 case DND.DROP_LINK:
1102                     return TransferMode.LINK;
1103                 default:
1104                    return null;
1105             }
1106         }
1107 
1108         Set&lt;TransferMode&gt; getTransferModes(int bits) {
1109             Set&lt;TransferMode&gt; set = new HashSet&lt;TransferMode&gt;();
1110             if ((bits &amp; DND.DROP_COPY) != 0) set.add(TransferMode.COPY);
1111             if ((bits &amp; DND.DROP_MOVE) != 0) set.add(TransferMode.MOVE);
1112             if ((bits &amp; DND.DROP_TARGET_MOVE) != 0) set.add(TransferMode.MOVE);
1113             if ((bits &amp; DND.DROP_LINK) != 0) set.add(TransferMode.LINK);
1114             return set;
1115         }
1116 
1117         ImageData createImageData(Pixels pixels) {
1118             if (pixels == null) return null;
1119             int width = pixels.getWidth();
1120             int height = pixels.getHeight();
1121             int bpr = width * 4;
1122             int dataSize = bpr * height;
1123             byte[] buffer = new byte[dataSize];
1124             byte[] alphaData = new byte[width * height];
1125             if (pixels.getBytesPerComponent() == 1) {
1126                 // ByteBgraPre
1127                 ByteBuffer pixbuf = (ByteBuffer) pixels.getPixels();
1128                 for (int y = 0, offset = 0, alphaOffset = 0; y &lt; height; y++) {
1129                     for (int x = 0; x &lt; width; x++, offset += 4) {
1130                         byte b = pixbuf.get();
1131                         byte g = pixbuf.get();
1132                         byte r = pixbuf.get();
1133                         byte a = pixbuf.get();
1134                         // non premultiplied ?
1135                         alphaData[alphaOffset++] = a;
1136                         buffer[offset] = b;
1137                         buffer[offset + 1] = g;
1138                         buffer[offset + 2] = r;
1139                         buffer[offset + 3] = 0;// alpha
1140                     }
1141                 }
1142             } else if (pixels.getBytesPerComponent() == 4) {
1143                 // IntArgbPre
1144                 IntBuffer pixbuf = (IntBuffer) pixels.getPixels();
1145                 for (int y = 0, offset = 0, alphaOffset = 0; y &lt; height; y++) {
1146                     for (int x = 0; x &lt; width; x++, offset += 4) {
1147                         int pixel = pixbuf.get();
1148                         byte b = (byte) (pixel &amp; 0xFF);
1149                         byte g = (byte) ((pixel &gt;&gt; 8) &amp; 0xFF);
1150                         byte r = (byte) ((pixel &gt;&gt; 16) &amp; 0xFF);
1151                         byte a = (byte) ((pixel &gt;&gt; 24) &amp; 0xFF);
1152                         // non premultiplied ?
1153                         alphaData[alphaOffset++] = a;
1154                         buffer[offset] = b;
1155                         buffer[offset + 1] = g;
1156                         buffer[offset + 2] = r;
1157                         buffer[offset + 3] = 0;// alpha
1158                     }
1159                 }
1160             } else {
1161                 return null;
1162             }
1163             PaletteData palette = new PaletteData(0xFF00, 0xFF0000, 0xFF000000);
1164             ImageData imageData = new ImageData(width, height, 32, palette, 4, buffer);
1165             imageData.alphaData = alphaData;
1166             return imageData;
1167         }
1168 
1169         // Consider using dragAction
1170         private DragSource createDragSource(final EmbeddedSceneDSInterface fxDragSource, TransferMode dragAction) {
1171             Transfer [] transfers = getTransferTypes(fxDragSource.getMimeTypes());
1172             if (transfers.length == 0) return null;
1173             int dragOperation = getDragActions(fxDragSource.getSupportedActions());
1174             final DragSource dragSource = new DragSource(FXCanvas.this, dragOperation);
1175             dragSource.setTransfer(transfers);
1176             dragSource.addDragListener(new DragSourceListener() {
1177                 public void dragFinished(org.eclipse.swt.dnd.DragSourceEvent event) {
1178                     dragSource.dispose();
1179                     fxDragSource.dragDropEnd(getTransferMode(event.detail));
1180                 }
1181                 public void dragSetData(org.eclipse.swt.dnd.DragSourceEvent event) {
1182                     Transfer [] transfers = dragSource.getTransfer();
1183                     for (int i=0; i&lt;transfers.length; i++) {
1184                         if (transfers[i].isSupportedType(event.dataType)) {
1185                             String mime = getMime(transfers[i]);
1186                             if (mime != null) {
1187                                 event.doit = true;
1188                                 event.data = fxDragSource.getData(mime);
1189                                 if (event.data instanceof Pixels) {
1190                                     event.data = createImageData((Pixels)event.data);
1191                                 }
1192                                 return;
1193                             }
1194                         }
1195                         event.doit = false;
1196                     }
1197                 }
1198                 public void dragStart(org.eclipse.swt.dnd.DragSourceEvent event) {
1199                 }
1200             });
1201             return dragSource;
1202         }
1203 
1204         int getDragAction(TransferMode tm) {
1205             if (tm == null) return DND.DROP_NONE;
1206             switch (tm) {
1207                 case COPY: return DND.DROP_COPY;
1208                 case MOVE: return DND.DROP_MOVE;
1209                 case LINK: return DND.DROP_LINK;
1210                 default:
1211                     throw new IllegalArgumentException(&quot;Invalid transfer mode&quot;);
1212             }
1213         }
1214 
1215         int getDragActions(Set&lt;TransferMode&gt; set) {
1216             int result = 0;
1217             for (TransferMode mode : set) {
1218                 result |= getDragAction(mode);
1219             }
1220             return result;
1221         }
1222 
1223         Transfer getTransferType(String mime) {
1224             if (mime.equals(&quot;text/plain&quot;)) return TextTransfer.getInstance();
1225             if (mime.equals(&quot;text/rtf&quot;)) return RTFTransfer.getInstance();
1226             if (mime.equals(&quot;text/html&quot;)) return HTMLTransfer.getInstance();
1227             if (mime.equals(&quot;text/uri-list&quot;)) return URLTransfer.getInstance();
1228             if (mime.equals(&quot;application/x-java-rawimage&quot;)) return ImageTransfer.getInstance();
1229             if (mime.equals(&quot;application/x-java-file-list&quot;) || mime.equals(&quot;java.file-list&quot;)) {
1230                 return FileTransfer.getInstance();
1231             }
1232             return getCustomTransfer(mime);
1233         }
1234 
1235         Transfer [] getTransferTypes(String [] mimeTypes) {
1236             int count= 0;
1237             Transfer [] transfers = new Transfer [mimeTypes.length];
1238             for (int i=0; i&lt;mimeTypes.length; i++) {
1239                 Transfer transfer = getTransferType(mimeTypes[i]);
1240                 if (transfer != null) transfers [count++] = transfer;
1241             }
1242             if (count != mimeTypes.length) {
1243                 Transfer [] newTransfers = new Transfer[count];
1244                 System.arraycopy(transfers, 0, newTransfers, 0, count);
1245                 transfers = newTransfers;
1246             }
1247             return transfers;
1248         }
1249 
1250         String getMime(Transfer transfer) {
1251             if (transfer.equals(TextTransfer.getInstance())) return &quot;text/plain&quot;;
1252             if (transfer.equals(RTFTransfer.getInstance())) return &quot;text/rtf&quot;; ;
1253             if (transfer.equals( HTMLTransfer.getInstance())) return &quot;text/html&quot;;
1254             if (transfer.equals(URLTransfer.getInstance())) return &quot;text/uri-list&quot;;
1255             if (transfer.equals( ImageTransfer.getInstance())) return &quot;application/x-java-rawimage&quot;;
1256             if (transfer.equals(FileTransfer.getInstance())) return &quot;application/x-java-file-list&quot;;
1257             if (transfer instanceof CustomTransfer) return ((CustomTransfer)transfer).getMime();
1258             return null;
1259         }
1260 
1261         String [] getMimes(Transfer [] transfers, TransferData data) {
1262             int count= 0;
1263             String [] result = new String [transfers.length];
1264             for (int i=0; i&lt;transfers.length; i++) {
1265                 if (transfers[i].isSupportedType(data)) {
1266                     result [count++] = getMime (transfers [i]);
1267                 }
1268             }
1269             if (count != result.length) {
1270                 String [] newResult = new String[count];
1271                 System.arraycopy(result, 0, newResult, 0, count);
1272                 result = newResult;
1273             }
1274             return result;
1275         }
1276 
1277         DropTarget createDropTarget(EmbeddedSceneInterface embeddedScene) {
1278             final DropTarget dropTarget = new DropTarget(FXCanvas.this, DND.DROP_COPY | DND.DROP_LINK | DND.DROP_MOVE);
1279             final EmbeddedSceneDTInterface fxDropTarget = embeddedScene.createDropTarget();
1280             dropTarget.setTransfer(getAllTransfers());
1281             dropTarget.addDropListener(new DropTargetListener() {
1282                 Object data;
1283                 // In SWT, the list of available types that the source can provide
1284                 // is part of the event.  FX queries this directly from the operating
1285                 // system and bypasses SWT.  This variable is commented out to remind
1286                 // us of this potential inconsistency.
1287                 //
1288                 //TransferData [] transferData;
1289                 TransferData currentTransferData;
1290                 boolean ignoreLeave;
1291                 int detail = DND.DROP_NONE, operations = DND.DROP_NONE;
1292                 EmbeddedSceneDSInterface fxDragSource = new EmbeddedSceneDSInterface() {
1293                     public Set&lt;TransferMode&gt; getSupportedActions() {
1294                         return getTransferModes(operations);
1295                     }
1296                     public Object getData(String mimeType) {
1297                         // NOTE: get the data for the requested mime type, not the default data
1298                         return data;
1299                     }
1300                     public String[] getMimeTypes() {
1301                         if (currentTransferData == null) return new String [0];
1302                         return getMimes(getAllTransfers(), currentTransferData);
1303                     }
1304                     public boolean isMimeTypeAvailable(String mimeType) {
1305                         String [] mimes = getMimeTypes();
1306                         for (int i=0; i&lt;mimes.length; i++) {
1307                             if (mimes[i].equals(mimeType)) return true;
1308                         }
1309                         return false;
1310                     }
1311                     public void dragDropEnd(TransferMode performedAction) {
1312                         data = null;
1313                         //transferData = null;
1314                         currentTransferData = null;
1315                     }
1316                 };
1317                 public void dragEnter(DropTargetEvent event) {
1318                     ignoreLeave = false;
1319                     dropTarget.setTransfer(getAllTransfers());
1320                     detail = event.detail;
1321                     operations = event.operations;
1322                     dragOver (event, true, detail);
1323                 }
1324                 public void dragLeave(DropTargetEvent event) {
1325                     detail = operations = DND.DROP_NONE;
1326                     data = null;
1327                     //transferData = null;
1328                     currentTransferData = null;
1329                     getDisplay().asyncExec(() -&gt; {
1330                         if (ignoreLeave) return;
1331                         fxDropTarget.handleDragLeave();
1332                     });
1333                 }
1334                 public void dragOperationChanged(DropTargetEvent event) {
1335                     detail = event.detail;
1336                     operations = event.operations;
1337                     dragOver(event, false, detail);
1338                 }
1339                 public void dragOver(DropTargetEvent event) {
1340                     operations = event.operations;
1341                     dragOver (event, false, detail);
1342                 }
1343                 public void dragOver(DropTargetEvent event, boolean enter, int detail) {
1344                     //transferData = event.dataTypes;
1345                     currentTransferData = event.currentDataType;
1346                     Point pt = toControl(event.x, event.y);
1347                     if (detail == DND.DROP_NONE) detail = DND.DROP_COPY;
1348                     TransferMode acceptedMode, recommendedMode = getTransferMode(detail);
1349                     if (enter) {
1350                         acceptedMode = fxDropTarget.handleDragEnter(pt.x, pt.y, event.x, event.y, recommendedMode, fxDragSource);
1351                     } else {
1352                         acceptedMode = fxDropTarget.handleDragOver(pt.x, pt.y, event.x, event.y, recommendedMode);
1353                     }
1354                     event.detail = getDragAction(acceptedMode);
1355                 }
1356                 public void drop(DropTargetEvent event) {
1357                     detail = event.detail;
1358                     operations = event.operations;
1359                     data = event.data;
1360                     //transferData = event.dataTypes;
1361                     currentTransferData = event.currentDataType;
1362                     Point pt = toControl(event.x, event.y);
1363                     TransferMode recommendedDropAction = getTransferMode(event.detail);
1364                     TransferMode acceptedMode = fxDropTarget.handleDragDrop(pt.x, pt.y, event.x, event.y, recommendedDropAction);
1365                     event.detail = getDragAction(acceptedMode);
1366                     data = null;
1367                     //transferData = null;
1368                     currentTransferData = null;
1369                 }
1370                 public void dropAccept(DropTargetEvent event) {
1371                     ignoreLeave = true;
1372                 }
1373             });
1374             return dropTarget;
1375         }
1376 
1377         @Override
1378         public void setEmbeddedScene(EmbeddedSceneInterface embeddedScene) {
1379             scenePeer = embeddedScene;
1380             if (scenePeer == null) {
1381                 return;
1382             }
1383             if (pWidth &gt; 0 &amp;&amp; pHeight &gt; 0) {
1384                 scenePeer.setSize(pWidth, pHeight);
1385             }
1386             double scaleFactor = getScaleFactor();
1387             resizePixelBuffer(scaleFactor);
1388             lastScaleFactor = scaleFactor;
1389             scenePeer.setPixelScaleFactors((float)scaleFactor, (float)scaleFactor);
1390             scenePeer.setDragStartListener((fxDragSource, dragAction) -&gt; {
1391                 Platform.runLater(() -&gt; {
1392                     DragSource dragSource = createDragSource(fxDragSource, dragAction);
1393                     if (dragSource == null) {
1394                         fxDragSource.dragDropEnd(null);
1395                     } else {
1396                         updateDropTarget();
1397                         FXCanvas.this.notifyListeners(SWT.DragDetect, null);
1398                     }
1399                 });
1400             });
1401             //Force the old drop target to be disposed before creating a new one
1402             setDropTarget(null);
1403             setDropTarget(createDropTarget(embeddedScene));
1404         }
1405 
1406         @Override
1407         public boolean requestFocus() {
1408             Display.getDefault().asyncExec(() -&gt; {
1409                 if (isDisposed()) return;
1410                 FXCanvas.this.forceFocus();
1411             });
1412             return true;
1413         }
1414 
1415         @Override
1416         public boolean traverseFocusOut(boolean bln) {
1417             // RT-18085: not implemented
1418             return true;
1419         }
1420 
1421         Object lock = new Object();
1422         boolean queued = false;
1423         public void repaint() {
1424             synchronized (lock) {
1425                 if (queued) return;
1426                 queued = true;
1427                 Display.getDefault().asyncExec(() -&gt; {
1428                     try {
1429                         if (isDisposed()) return;
1430                         FXCanvas.this.redraw();
1431                     } finally {
1432                         synchronized (lock) {
1433                             queued = false;
1434                         }
1435                     }
1436                 });
1437             }
1438         }
1439 
1440         @Override
1441         public void setPreferredSize(int width, int height) {
1442             FXCanvas.this.pPreferredWidth = width;
1443             FXCanvas.this.pPreferredHeight = height;
1444             //FXCanvas.this.getShell().layout(new Control []{FXCanvas.this}, SWT.DEFER);
1445         }
1446 
1447         @Override
1448         public void setEnabled(boolean bln) {
1449             FXCanvas.this.setEnabled(bln);
1450         }
1451 
1452         @Override
1453         public void setCursor(CursorFrame cursorFrame) {
1454             FXCanvas.this.setCursor(getPlatformCursor(cursorFrame));
1455         }
1456 
1457         private org.eclipse.swt.graphics.Cursor getPlatformCursor(final CursorFrame cursorFrame) {
1458             /*
1459              * On the Mac, setting the cursor during drag and drop clears the move
1460              * and link indicators.  The fix is to set the default cursor for the
1461              * control (which is null) when the FX explicitly requests the default
1462              * cursor.  This will preserve the drag and drop indicators.
1463              */
1464             if (cursorFrame.getCursorType() == CursorType.DEFAULT) {
1465                 return null;
1466             }
1467             final org.eclipse.swt.graphics.Cursor cachedPlatformCursor =
1468                     cursorFrame.getPlatformCursor(org.eclipse.swt.graphics.Cursor.class);
1469             if (cachedPlatformCursor != null) {
1470                 // platform cursor already cached
1471                 return cachedPlatformCursor;
1472             }
1473 
1474             // platform cursor not cached yet
1475             final org.eclipse.swt.graphics.Cursor platformCursor =
1476                     SWTCursors.embedCursorToCursor(cursorFrame);
1477             cursorFrame.setPlatforCursor(org.eclipse.swt.graphics.Cursor.class, platformCursor);
1478 
1479             return platformCursor;
1480         }
1481 
1482         @Override
1483         public boolean grabFocus() {
1484             // RT-27949: not implemented
1485             return true;
1486         }
1487 
1488         @Override
1489         public void ungrabFocus() {
1490             // RT-27949: not implemented
1491         }
1492     }
1493 }
    </pre>
  </body>
</html>