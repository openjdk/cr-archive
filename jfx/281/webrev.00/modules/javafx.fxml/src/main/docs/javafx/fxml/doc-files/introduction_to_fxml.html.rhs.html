<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.fxml/src/main/docs/javafx/fxml/doc-files/introduction_to_fxml.html</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 &lt;!doctype html&gt;
   2 
   3 &lt;!--
   4 /*
<a name="1" id="anc1"></a><span class="line-modified">   5  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   6  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   7  *
   8  * This code is free software; you can redistribute it and/or modify it
   9  * under the terms of the GNU General Public License version 2 only, as
  10  * published by the Free Software Foundation.  Oracle designates this
  11  * particular file as subject to the &quot;Classpath&quot; exception as provided
  12  * by Oracle in the LICENSE file that accompanied this code.
  13  *
  14  * This code is distributed in the hope that it will be useful, but WITHOUT
  15  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  16  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  17  * version 2 for more details (a copy is included in the LICENSE file that
  18  * accompanied this code).
  19  *
  20  * You should have received a copy of the GNU General Public License version
  21  * 2 along with this work; if not, write to the Free Software Foundation,
  22  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  23  *
  24  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  25  * or visit www.oracle.com if you need additional information or have any
  26  * questions.
  27  */
  28 --&gt;
  29 
  30 &lt;html lang=&quot;en&quot;&gt;
  31 &lt;head&gt;
  32 &lt;link href=&quot;fxml.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;/&gt;
  33 &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt;
  34 &lt;title&gt;Introduction to FXML | JavaFX @FXVERSION@&lt;/title&gt;
  35 &lt;meta name=&quot;description&quot; content=&quot;The document introduces FXML, an XML-based declarative markup language for defining user interfaces in JavaFX @FXVERSION@ applications.&quot;/&gt;
  36 &lt;meta name=&quot;keywords&quot; content=&quot;JavaFX, FXML, JavaFX GUI development, web development, Java application development, GUI applications, rich internet applications, RIA, expressive content&quot;/&gt;
  37 &lt;/head&gt;
  38 &lt;body&gt;
  39 
  40 &lt;div class=&quot;fx-code-header&quot;&gt;
  41 &lt;div class=&quot;version&quot;&gt;&lt;br/&gt;Release: JavaFX @FXVERSION@&lt;/div&gt;
  42 &lt;/div&gt;
  43 
  44 &lt;h1&gt;Introduction to FXML&lt;/h1&gt;
  45 &lt;p class=&quot;subtitle&quot;&gt;Last updated: 01 May 2017&lt;/p&gt;
  46 
  47 &lt;h2&gt;Contents&lt;/h2&gt;
  48 &lt;ul class=&quot;contents&quot;&gt;
  49 &lt;li&gt;&lt;a href=&quot;#overview&quot;&gt;Overview&lt;/a&gt;&lt;/li&gt;
  50 &lt;li&gt;
  51     &lt;a href=&quot;#elements&quot;&gt;Elements&lt;/a&gt;
  52     &lt;ul&gt;
  53     &lt;li&gt;
  54         &lt;a href=&quot;#class_instance_elements&quot;&gt;Class Instance Elements&lt;/a&gt;
  55         &lt;ul&gt;
  56         &lt;li&gt;&lt;a href=&quot;#instance_declaration_elements&quot;&gt;Instance Declarations&lt;/a&gt;&lt;/li&gt;
  57         &lt;li&gt;&lt;a href=&quot;#include_elements&quot;&gt;&amp;lt;fx:include&amp;gt;&lt;/a&gt;&lt;/li&gt;
  58         &lt;li&gt;&lt;a href=&quot;#constant_elements&quot;&gt;&amp;lt;fx:constant&amp;gt;&lt;/a&gt;&lt;/li&gt;
  59         &lt;li&gt;&lt;a href=&quot;#reference_elements&quot;&gt;&amp;lt;fx:reference&amp;gt;&lt;/a&gt;&lt;/li&gt;
  60         &lt;li&gt;&lt;a href=&quot;#copy_elements&quot;&gt;&amp;lt;fx:copy&amp;gt;&lt;/a&gt;&lt;/li&gt;
  61         &lt;li&gt;&lt;a href=&quot;#root_elements&quot;&gt;&amp;lt;fx:root&amp;gt;&lt;/a&gt;&lt;/li&gt;
  62         &lt;/ul&gt;
  63     &lt;/li&gt;
  64 
  65     &lt;li&gt;
  66         &lt;a href=&quot;#property_elements&quot;&gt;Property Elements&lt;/a&gt;
  67         &lt;ul&gt;
  68         &lt;li&gt;&lt;a href=&quot;#property_setter_elements&quot;&gt;Property Setters&lt;/a&gt;&lt;/li&gt;
  69         &lt;li&gt;&lt;a href=&quot;#read_only_list_property_elements&quot;&gt;Read-Only List Properties&lt;/a&gt;&lt;/li&gt;
  70         &lt;li&gt;&lt;a href=&quot;#read_only_map_property_elements&quot;&gt;Read-Only Map Properties&lt;/a&gt;&lt;/li&gt;
  71         &lt;li&gt;&lt;a href=&quot;#default_properties&quot;&gt;Default Properties&lt;/a&gt;&lt;/li&gt;
  72         &lt;/ul&gt;
  73     &lt;/li&gt;
  74 
  75     &lt;li&gt;&lt;a href=&quot;#static_property_elements&quot;&gt;Static Properties&lt;/a&gt;&lt;/li&gt;
  76     &lt;li&gt;&lt;a href=&quot;#define_elements&quot;&gt;Define Blocks&lt;/a&gt;&lt;/li&gt;
  77     &lt;/ul&gt;
  78 &lt;/li&gt;
  79 &lt;li&gt;
  80     &lt;a href=&quot;#attributes&quot;&gt;Attributes&lt;/a&gt;
  81     &lt;ul&gt;
  82     &lt;li&gt;
  83         &lt;a href=&quot;#instance_property_attributes&quot;&gt;Instance Properties&lt;/a&gt;
  84         &lt;ul&gt;
  85         &lt;li&gt;&lt;a href=&quot;#location_resolution&quot;&gt;Location Resolution&lt;/a&gt;&lt;/li&gt;
  86         &lt;li&gt;&lt;a href=&quot;#resource_resolution&quot;&gt;Resource Resolution&lt;/a&gt;&lt;/li&gt;
  87         &lt;li&gt;&lt;a href=&quot;#variable_resolution&quot;&gt;Variable Resolution&lt;/a&gt;&lt;/li&gt;
  88         &lt;li&gt;&lt;a href=&quot;#escape_sequences&quot;&gt;Escape Sequences&lt;/a&gt;&lt;/li&gt;
  89         &lt;li&gt;&lt;a href=&quot;#expression_binding&quot;&gt;Expression Binding&lt;/a&gt;&lt;/li&gt;
  90         &lt;/ul&gt;
  91     &lt;/li&gt;
  92 
  93     &lt;li&gt;&lt;a href=&quot;#static_property_attributes&quot;&gt;Static Properties&lt;/a&gt;&lt;/li&gt;
  94     &lt;li&gt;
  95         &lt;a href=&quot;#event_handler_attributes&quot;&gt;Event Handlers&lt;/a&gt;
  96         &lt;ul&gt;
  97         &lt;li&gt;&lt;a href=&quot;#script_event_handlers&quot;&gt;Script Event Handlers&lt;/a&gt;&lt;/li&gt;
  98         &lt;li&gt;&lt;a href=&quot;#controller_method_event_handlers&quot;&gt;Controller Method Event Handlers&lt;/a&gt;&lt;/li&gt;
  99         &lt;li&gt;&lt;a href=&quot;#expression_handlers&quot;&gt;Event handlers from expressions&lt;/a&gt;&lt;/li&gt;
 100         &lt;li&gt;&lt;a href=&quot;#collections_and_property_handlers&quot;&gt;Special handlers for collections and properties&lt;/a&gt;&lt;/li&gt;
 101         &lt;/ul&gt;
 102     &lt;/li&gt;
 103     &lt;/ul&gt;
 104 &lt;/li&gt;
 105 &lt;li&gt;&lt;a href=&quot;#scripting&quot;&gt;Scripting&lt;/a&gt;&lt;/li&gt;
 106 &lt;li&gt;
 107     &lt;a href=&quot;#controllers&quot;&gt;Controllers&lt;/a&gt;
 108     &lt;ul&gt;
 109     &lt;li&gt;&lt;a href=&quot;#fxml_annotation&quot;&gt;@FXML&lt;/a&gt;&lt;/li&gt;
 110     &lt;li&gt;&lt;a href=&quot;#nested_controllers&quot;&gt;Nested Controllers&lt;/a&gt;&lt;/li&gt;
 111     &lt;/ul&gt;
 112 &lt;/li&gt;
 113 &lt;li&gt;
 114     &lt;a href=&quot;#fxmlloader&quot;&gt;FXMLLoader&lt;/a&gt;
 115     &lt;ul&gt;
 116     &lt;li&gt;&lt;a href=&quot;#custom_components&quot;&gt;Custom Components&lt;/a&gt;&lt;/li&gt;
 117     &lt;/ul&gt;
 118 &lt;/li&gt;
 119 &lt;li&gt;&lt;a href=&quot;#deploy_as_module&quot;&gt;Deploying an Application as a Module&lt;/a&gt;&lt;/li&gt;
 120 &lt;/ul&gt;
 121 
 122 &lt;h2&gt;&lt;a id=&quot;overview&quot;&gt;Overview&lt;/a&gt;&lt;/h2&gt;
 123 &lt;p&gt;FXML is a scriptable, XML-based markup language for constructing Java object graphs. It provides a convenient alternative to constructing such graphs in procedural code, and is ideally suited to defining the user interface of a JavaFX application, since the hierarchical structure of an XML document closely parallels the structure of the JavaFX scene graph.&lt;/p&gt;
 124 
 125 &lt;p&gt;This document introduces the FXML markup language and explains how it can be used to simplify development of JavaFX applications.&lt;/p&gt;
 126 
 127 &lt;h2&gt;&lt;a id=&quot;elements&quot;&gt;Elements&lt;/a&gt;&lt;/h2&gt;
 128 &lt;p&gt;In FXML, an XML element represents one of the following:&lt;/p&gt;
 129 &lt;ul&gt;
 130 &lt;li&gt;A class instance&lt;/li&gt;
 131 &lt;li&gt;A property of a class instance&lt;/li&gt;
 132 &lt;li&gt;A &quot;static&quot; property&lt;/li&gt;
 133 &lt;li&gt;A &quot;define&quot; block&lt;/li&gt;
 134 &lt;li&gt;A block of script code&lt;/li&gt;
 135 &lt;/ul&gt;
 136 
 137 &lt;p&gt;Class instances, instance properties, static properties, and define blocks are discussed in this section below. Scripting is discussed in a later section.&lt;/p&gt;
 138 
 139 &lt;h3&gt;&lt;a id=&quot;class_instance_elements&quot;&gt;Class Instance Elements&lt;/a&gt;&lt;/h3&gt;
 140 &lt;p&gt;Class instances can be constructed in FXML in several ways. The most common is via instance declaration elements, which simply create a new instance of a class by name. Other ways of creating class instances include referencing existing values, copying existing values, and including external FXML files. Each is discussed in more detail below.&lt;/p&gt;
 141 
 142 &lt;h4&gt;&lt;a id=&quot;instance_declaration_elements&quot;&gt;Instance Declarations&lt;/a&gt;&lt;/h4&gt;
 143 &lt;p&gt;If an element&#39;s tag is considered an instance declaration if the tag begins with uppercase letter (and the class is imported) or, as in Java, it denotes a fully-qualified (including the package name) name of a class. When the FXML loader (also introduced later) encounters such an element, it creates an instance of that class.&lt;/p&gt;
 144 
 145 &lt;p&gt;Importing a class is done using the &quot;import&quot; processing instruction (PI). For example, the following PI imports the &lt;span class=&quot;code&quot;&gt;javafx.scene.control.Label&lt;/span&gt; class into the current FXML document&amp;#8217;s namespace:&lt;/p&gt;
 146 
 147 &lt;pre class=&quot;code&quot;&gt;
 148 &amp;lt;?import javafx.scene.control.Label?&amp;gt;
 149 &lt;/pre&gt;
 150 
 151 &lt;p&gt;This PI imports all classes from the javafx.scene.control package into the current namespace:&lt;/p&gt;
 152 
 153 &lt;pre class=&quot;code&quot;&gt;
 154 &amp;lt;?import javafx.scene.control.*?&amp;gt;
 155 &lt;/pre&gt;
 156 
 157 
 158 &lt;p&gt;Any class that adheres to JavaBean constructor and property naming conventions can be readily instantiated and configured using FXML. The following is a simple but complete example that creates an instance of &lt;span class=&quot;code&quot;&gt;javafx.scene.control.Label&lt;/span&gt; and sets its &quot;text&quot; property to &quot;Hello, World!&quot;:&lt;/p&gt;
 159 
 160 &lt;pre class=&quot;code&quot;&gt;
 161 &amp;lt;?import javafx.scene.control.Label?&amp;gt;
 162 &amp;lt;Label text=&quot;Hello, World!&quot;/&amp;gt;
 163 &lt;/pre&gt;
 164 
 165 &lt;p&gt;Note that the &lt;span class=&quot;code&quot;&gt;Label&lt;/span&gt;&amp;#8217;s &quot;text&quot; property in this example is set using an XML attribute. Properties can also be set using nested property elements. Property elements are discussed in more detail later in this section. Property attributes are discussed in a later section.&lt;/p&gt;
 166 
 167 &lt;p&gt;Classes that don&#39;t conform to Bean conventions can also be constructed in FXML, using an object called a &quot;builder&quot;. Builders are discussed in more detail later.&lt;/p&gt;
 168 
 169 &lt;h5&gt;Maps&lt;/h5&gt;
 170 &lt;p&gt;Internally, the FXML loader uses an instance of &lt;span class=&quot;code&quot;&gt;com.sun.javafx.fxml.BeanAdapter&lt;/span&gt; to wrap an instantiated object and invoke its setter methods. This (currently) private class implements the &lt;span class=&quot;code&quot;&gt;java.util.Map&lt;/span&gt; interface and allows a caller to get and set Bean property values as key/value pairs.&lt;/p&gt;
 171 
 172 &lt;p&gt;If an element represents a type that already implements &lt;span class=&quot;code&quot;&gt;Map&lt;/span&gt; (such as &lt;span class=&quot;code&quot;&gt;java.util.HashMap&lt;/span&gt;), it is not wrapped and its &lt;span class=&quot;code&quot;&gt;get()&lt;/span&gt; and &lt;span class=&quot;code&quot;&gt;put()&lt;/span&gt; methods are invoked directly. For example, the following FXML creates an instance of &lt;span class=&quot;code&quot;&gt;HashMap&lt;/span&gt; and sets its &quot;foo&quot; and &quot;bar&quot; values to &quot;123&quot; and &quot;456&quot;, respectively:
 173 
 174 &lt;pre class=&quot;code&quot;&gt;
 175 &amp;lt;HashMap foo=&quot;123&quot; bar=&quot;456&quot;/&amp;gt;
 176 &lt;/pre&gt;
 177 
 178 &lt;h5&gt;fx:value&lt;/h5&gt;
 179 &lt;p&gt;The &lt;span class=&quot;code&quot;&gt;fx:value&lt;/span&gt; attribute can be used to initialize an instance of a type that does not have a default constructor but provides a static &lt;span class=&quot;code&quot;&gt;valueOf(String)&lt;/span&gt; method. For example, &lt;span class=&quot;code&quot;&gt;java.lang.String&lt;/span&gt; as well as each of the primitive wrapper types define a &lt;span class=&quot;code&quot;&gt;valueOf()&lt;/span&gt; method and can be constructed in FXML as follows:&lt;/p&gt;
 180 
 181 &lt;pre class=&quot;code&quot;&gt;
 182 &amp;lt;String fx:value=&quot;Hello, World!&quot;/&amp;gt;
 183 &amp;lt;Double fx:value=&quot;1.0&quot;/&amp;gt;
 184 &amp;lt;Boolean fx:value=&quot;false&quot;/&amp;gt;
 185 &lt;/pre&gt;
 186 
 187 &lt;p&gt;Custom classes that define a static &lt;span class=&quot;code&quot;&gt;valueOf(String)&lt;/span&gt; method can also be constructed this way.&lt;/p&gt;
 188 
 189 &lt;h5&gt;fx:factory&lt;/h5&gt;
 190 &lt;p&gt;The &lt;span class=&quot;code&quot;&gt;fx:factory&lt;/span&gt; attribute is another means of creating objects whose classes do not have a default constructor. The value of the attribute is the name of a static, no-arg factory method for producing class instances. For example, the following markup creates an instance of an observable array list, populated with three string values:&lt;/p&gt;
 191 
 192 &lt;pre class=&quot;code&quot;&gt;
 193 &amp;lt;FXCollections fx:factory=&quot;observableArrayList&quot;&amp;gt;
 194     &amp;lt;String fx:value=&quot;A&quot;/&amp;gt;
 195     &amp;lt;String fx:value=&quot;B&quot;/&amp;gt;
 196     &amp;lt;String fx:value=&quot;C&quot;/&amp;gt;
 197 &amp;lt;/FXCollections&amp;gt;
 198 &lt;/pre&gt;
 199 
 200 &lt;h5&gt;Builders&lt;/h5&gt;
 201 &lt;p&gt;A third means of creating instances of classes that do not conform to Bean conventions (such as those representing immutable values) is a &quot;builder&quot;. The builder design pattern delegates object construction to a mutable helper class (called a &quot;builder&quot;) that is responsible for manufacturing instances of the immutable type.&lt;/p&gt;
 202 
 203 &lt;p&gt;Builder support in FXML is provided by two interfaces. The &lt;span class=&quot;code&quot;&gt;javafx.util.Builder&lt;/span&gt; interface defines a single method named &lt;span class=&quot;code&quot;&gt;build()&lt;/span&gt; which is responsible for constructing the actual object:&lt;/p&gt;
 204 
 205 &lt;pre class=&quot;code&quot;&gt;
 206 public interface Builder&amp;lt;T&amp;gt; {
 207     public T build();
 208 }
 209 &lt;/pre&gt;
 210 
 211 &lt;p&gt;A &lt;span class=&quot;code&quot;&gt;javafx.util.BuilderFactory&lt;/span&gt; is responsible for producing builders that are capable of instantiating a given type:&lt;/p&gt;
 212 
 213 &lt;pre class=&quot;code&quot;&gt;
 214 public interface BuilderFactory {
 215     public Builder&amp;lt;?&amp;gt; getBuilder(Class&amp;lt;?&amp;gt; type);
 216 }
 217 &lt;/pre&gt;
 218 
 219 &lt;p&gt;A default builder factory, &lt;span class=&quot;code&quot;&gt;JavaFXBuilderFactory&lt;/span&gt;, is provided in the &lt;span class=&quot;code&quot;&gt;javafx.fxml&lt;/span&gt; package. This factory is capable of creating and configuring most immutable JavaFX types. For example, the following markup uses the default builder to create an instance of the immutable &lt;span class=&quot;code&quot;&gt;javafx.scene.paint.Color&lt;/span&gt; class:
 220 
 221 &lt;pre class=&quot;code&quot;&gt;
 222 &amp;lt;Color red=&quot;1.0&quot; green=&quot;0.0&quot; blue=&quot;0.0&quot;/&amp;gt;
 223 &lt;/pre&gt;
 224 
 225 &lt;p&gt;Note that, unlike Bean types, which are constructed when the element&#39;s start tag is processed, objects constructed by a builder are not instantiated until the element&#39;s closing tag is reached. This is because all of the required arguments may not be available until the element has been fully processed. For example, the Color object in the preceding example could also be written as:&lt;/p&gt;
 226 
 227 &lt;pre class=&quot;code&quot;&gt;
 228 &amp;lt;Color&amp;gt;
 229     &amp;lt;red&amp;gt;1.0&amp;lt;/red&amp;gt;
 230     &amp;lt;green&amp;gt;0.0&amp;lt;/green&amp;gt;
 231     &amp;lt;blue&amp;gt;0.0&amp;lt;/blue&amp;gt;
 232 &amp;lt;/Color&amp;gt;
 233 &lt;/pre&gt;
 234 
 235 &lt;p&gt;The &lt;span class=&quot;code&quot;&gt;Color&lt;/span&gt; instance cannot be fully constructed until all three of the color components are known.&lt;/p&gt;
 236 
 237 &lt;p&gt;When processing markup for an object that will be constructed by a builder, the &lt;span class=&quot;code&quot;&gt;Builder&lt;/span&gt; instances are treated like value objects - if a &lt;span class=&quot;code&quot;&gt;Builder&lt;/span&gt; implements the &lt;span class=&quot;code&quot;&gt;Map&lt;/span&gt; interface, the &lt;span class=&quot;code&quot;&gt;put()&lt;/span&gt; method is used to set the builder&#39;s attribute values. Otherwise, the builder is wrapped in a &lt;span class=&quot;code&quot;&gt;BeanAdapter&lt;/span&gt; and its properties are assumed to be exposed via standard Bean setters.&lt;/p&gt;
 238 
 239 &lt;h4&gt;&lt;a id=&quot;include_elements&quot;&gt;&amp;lt;fx:include&amp;gt;&lt;/a&gt;&lt;/h4&gt;
 240 &lt;p&gt;The &lt;span class=&quot;code&quot;&gt;&amp;lt;fx:include&amp;gt;&lt;/span&gt; tag creates an object from FXML markup defined in another file. It is used as follows:&lt;/p&gt;
 241 
 242 &lt;pre class=&quot;code&quot;&gt;
 243 &amp;lt;fx:include source=&quot;&lt;span class=&quot;variable&quot;&gt;filename&lt;/span&gt;&quot;/&amp;gt;
 244 &lt;/pre&gt;
 245 
 246 &lt;p&gt;where &lt;span class=&quot;variable&quot;&gt;filename&lt;/span&gt; is the name of the FXML file to include. Values that begin with a leading slash character are treated as relative to the classpath. Values with no leading slash are considered relative to the path of the current document.&lt;/p&gt;
 247 
 248 &lt;p&gt;For example, given the following markup:&lt;/p&gt;
 249 
 250 &lt;pre class=&quot;code&quot;&gt;
 251 &amp;lt;?import javafx.scene.control.*?&amp;gt;
 252 &amp;lt;?import javafx.scene.layout.*?&amp;gt;
 253 &amp;lt;VBox xmlns:fx=&quot;http://javafx.com/fxml&quot;&amp;gt;
 254     &amp;lt;children&amp;gt;
 255         &amp;lt;fx:include source=&quot;my_button.fxml&quot;/&amp;gt;
 256     &amp;lt;/children&amp;gt;
 257 &amp;lt;/VBox&amp;gt;
 258 &lt;/pre&gt;
 259 
 260 &lt;p&gt;If &lt;span class=&quot;filename&quot;&gt;my_button.fxml&lt;/span&gt; contains the following:
 261 
 262 &lt;pre class=&quot;code&quot;&gt;
 263 &amp;lt;?import javafx.scene.control.*?&amp;gt;
 264 &amp;lt;Button text=&quot;My Button&quot;/&amp;gt;
 265 &lt;/pre&gt;
 266 
 267 &lt;p&gt;the resulting scene graph would contain a &lt;span class=&quot;code&quot;&gt;VBox&lt;/span&gt; as a root object with a single &lt;span class=&quot;code&quot;&gt;Button&lt;/span&gt; as a child node.&lt;/p&gt;
 268 
 269 &lt;p&gt;Note the use of the &quot;fx&quot; namespace prefix. This is a reserved prefix that defines a number of elements and attributes that are used for internal processing of an FXML source file. It is generally declared on the root element of a FXML document. Other features provided by the &quot;fx&quot; namespace are described in the following sections.&lt;/p&gt;
 270 
 271 &lt;p&gt;&lt;span class=&quot;code&quot;&gt;&amp;lt;fx:include&amp;gt;&lt;/span&gt; also supports attributes for specifying the name of the resource bundle that should be used to localize the included content, as well as the character set used to encode the source file. Resource resolution is discussed in a later section.&lt;/p&gt;
 272 
 273 &lt;pre class=&quot;code&quot;&gt;
 274 &amp;lt;fx:include source=&quot;&lt;span class=&quot;variable&quot;&gt;filename&lt;/span&gt;&quot; resources=&quot;&lt;span class=&quot;variable&quot;&gt;resource_file&lt;/span&gt;&quot; charset=&quot;utf-8&quot;/&amp;gt;
 275 &lt;/pre&gt;
 276 
 277 &lt;h4&gt;&lt;a id=&quot;constant_elements&quot;&gt;&amp;lt;fx:constant&amp;gt;&lt;/a&gt;&lt;/h4&gt;
 278 &lt;p&gt;The &lt;span class=&quot;code&quot;&gt;&amp;lt;fx:constant&amp;gt;&lt;/span&gt; element creates a reference to a class constant. For example, the following markup sets the value of the &quot;minWidth&quot; property of a&lt;span class=&quot;code&quot;&gt;Button&lt;/span&gt; instance to the value of the &lt;span class=&quot;code&quot;&gt;NEGATIVE_INFINITY&lt;/span&gt; constant defined by the &lt;span class=&quot;code&quot;&gt;java.lang.Double&lt;/span&gt; class:&lt;/p&gt;
 279 
 280 &lt;pre class=&quot;code&quot;&gt;
 281 &amp;lt;Button&amp;gt;
 282     &amp;lt;minHeight&amp;gt;&amp;lt;Double fx:constant=&quot;NEGATIVE_INFINITY&quot;/&amp;gt;&amp;lt;/minHeight&amp;gt;
 283 &amp;lt;/Button&amp;gt;
 284 &lt;/pre&gt;
 285 
 286 &lt;h4&gt;&lt;a id=&quot;reference_elements&quot;&gt;&amp;lt;fx:reference&amp;gt;&lt;/a&gt;&lt;/h4&gt;
 287 &lt;p&gt;The &lt;span class=&quot;code&quot;&gt;&amp;lt;fx:reference&amp;gt;&lt;/span&gt; element creates a new reference to an existing element. Wherever this tag appears, it will effectively be replaced by the value of the named element. It is used in conjunction with either the &lt;span class=&quot;code&quot;&gt;fx:id&lt;/span&gt; attribute or with a script variables, both of which are discussed in more detail in later sections. The &quot;source&quot; attribute of the &lt;span class=&quot;code&quot;&gt;&amp;lt;fx:reference&amp;gt;&lt;/span&gt; element specifies the name of the object to which the new element will refer.&lt;/p&gt;
 288 
 289 &lt;p&gt;For example, the following markup assigns a previously-defined &lt;span class=&quot;code&quot;&gt;Image&lt;/span&gt; instance named &quot;myImage&quot; to the &quot;image&quot; property of an &lt;span class=&quot;code&quot;&gt;ImageView&lt;/span&gt; control:&lt;/p&gt;
 290 
 291 &lt;pre class=&quot;code&quot;&gt;
 292 &amp;lt;ImageView&amp;gt;
 293     &amp;lt;image&amp;gt;
 294         &amp;lt;fx:reference source=&quot;myImage&quot;/&amp;gt;
 295     &amp;lt;/image&amp;gt;
 296 &amp;lt;/ImageView&amp;gt;
 297 &lt;/pre&gt;
 298 
 299 &lt;p&gt;Note that, since it is also possible to dereference a variable using the attribute variable resolution operator (discussed later in the &lt;a href=&quot;#attributes&quot;&gt;Attributes&lt;/a&gt; section), &lt;span class=&quot;code&quot;&gt;fx:reference&lt;/span&gt; is generally only used when a reference value must be specified as an element, such as when adding the reference to a collection:&lt;/p&gt;
 300 
 301 &lt;pre class=&quot;code&quot;&gt;
 302 &amp;lt;ArrayList&amp;gt;
 303     &amp;lt;fx:reference source=&quot;element1&quot;/&amp;gt;
 304     &amp;lt;fx:reference source=&quot;element2&quot;/&amp;gt;
 305     &amp;lt;fx:reference source=&quot;element3&quot;/&amp;gt;
 306 &amp;lt;/ArrayList&amp;gt;
 307 &lt;/pre&gt;
 308 
 309 &lt;p&gt;For most other cases, using an attribute is simpler and more concise.&lt;/p&gt;
 310 
 311 &lt;h4&gt;&lt;a id=&quot;copy_elements&quot;&gt;&amp;lt;fx:copy&amp;gt;&lt;/a&gt;&lt;/h4&gt;
 312 &lt;p&gt;The &lt;span class=&quot;code&quot;&gt;&amp;lt;fx:copy&amp;gt;&lt;/span&gt; element creates a copy of an existing element. Like &lt;span class=&quot;code&quot;&gt;&amp;lt;fx:reference&amp;gt;&lt;/span&gt;, it is used with the fx:id attribute or a script variable. The element&#39;s &quot;source&quot; attribute specifies the name of the object that will be copied. The source type must define a copy constructor that will be used to construct the copy from the source value.&lt;/p&gt;
 313 
 314 &lt;p&gt;At the moment, no JavaFX platform classes provide such a copy constructor, so this element is provided primarily for use by application developers. This may change in a future release.&lt;/p&gt;
 315 
 316 &lt;h4&gt;&lt;a id=&quot;root_elements&quot;&gt;&amp;lt;fx:root&amp;gt;&lt;/a&gt;&lt;/h4&gt;
 317 &lt;p&gt;The &lt;span class=&quot;code&quot;&gt;&amp;lt;fx:root&amp;gt;&lt;/span&gt; element creates a reference to a previously defined root element. It is only valid as the root node of an FXML document. &lt;span class=&quot;code&quot;&gt;&amp;lt;fx:root&amp;gt;&lt;/span&gt; is used primarily when creating custom controls that are backed by FXML markup. This is discussed in more detail in the &lt;a href=&quot;#fxmlloader&quot;&gt;FXMLLoader&lt;/a&gt; section.&lt;/p&gt;
 318 
 319 &lt;h3&gt;&lt;a id=&quot;property_elements&quot;&gt;Property Elements&lt;/a&gt;&lt;/h3&gt;
 320 &lt;p&gt;Elements whose tag names begin with a lowercase letter represent object properties. A property element may represent one of the following:&lt;/p&gt;
 321 
 322 &lt;ul&gt;
 323 &lt;li&gt;A property setter&lt;/li&gt;
 324 &lt;li&gt;A read-only list property&lt;/li&gt;
 325 &lt;li&gt;A read-only map property&lt;/li&gt;
 326 &lt;/ul&gt;
 327 
 328 &lt;h4&gt;&lt;a id=&quot;property_setter_elements&quot;&gt;Property Setters&lt;/a&gt;&lt;/h4&gt;
 329 &lt;p&gt;If an element represents a property setter, the contents of the element (which must be either a text node or a nested class instance element) are passed as the value to the setter for the property.&lt;/p&gt;
 330 
 331 &lt;p&gt;For example, the following FXML creates an instance of the &lt;span class=&quot;code&quot;&gt;Label&lt;/span&gt; class and sets the value of the label&#39;s &quot;text&quot; property to &quot;Hello, World!&quot;:&lt;/p&gt;
 332 
 333 &lt;pre class=&quot;code&quot;&gt;
 334 &amp;lt;?import javafx.scene.control.Label?&amp;gt;
 335 &amp;lt;Label&amp;gt;
 336     &amp;lt;text&amp;gt;Hello, World!&amp;lt;/text&amp;gt;
 337 &amp;lt;/Label&amp;gt;
 338 &lt;/pre&gt;
 339 
 340 &lt;p&gt;This produces the same result as the earlier example which used an attribute to set the &quot;text&quot; property:&lt;/p&gt;
 341 
 342 &lt;pre class=&quot;code&quot;&gt;
 343 &amp;lt;?import javafx.scene.control.Label?&amp;gt;
 344 &amp;lt;Label text=&quot;Hello, World!&quot;/&amp;gt;
 345 &lt;/pre&gt;
 346 
 347 &lt;p&gt;Property elements are generally used when the property value is a complex type that can&#39;t be represented using a simple string-based attribute value, or when the character length of the value is so long that specifying it as an attribute would have a negative impact on readability.&lt;/p&gt;
 348 
 349 &lt;h5&gt;Type Coercion&lt;/h5&gt;
 350 &lt;p&gt;FXML uses &quot;type coercion&quot; to convert property values to the appropriate type as needed. Type coercion is required because the only data types supported by XML are elements, text, and attributes (whose values are also text). However, Java supports a number of different data types including built-in primitive value types as well as extensible reference types.&lt;/p&gt;
 351 
 352 &lt;p&gt;The FXML loader uses the &lt;span class=&quot;code&quot;&gt;coerce()&lt;/span&gt; method of &lt;span class=&quot;code&quot;&gt;BeanAdapter&lt;/span&gt; to perform any required type conversions. This method is capable of performing basic primitive type conversions such as &lt;span class=&quot;code&quot;&gt;String&lt;/span&gt; to &lt;span class=&quot;code&quot;&gt;boolean&lt;/span&gt; or &lt;span class=&quot;code&quot;&gt;int&lt;/span&gt; to &lt;span class=&quot;code&quot;&gt;double&lt;/span&gt;, and will also convert &lt;span class=&quot;code&quot;&gt;String&lt;/span&gt; to &lt;span class=&quot;code&quot;&gt;Class&lt;/span&gt; or &lt;span class=&quot;code&quot;&gt;String&lt;/span&gt; to &lt;span class=&quot;code&quot;&gt;Enum&lt;/span&gt;. Additional conversions can be implemented by defining a static &lt;span class=&quot;code&quot;&gt;valueOf()&lt;/span&gt; method on the target type.&lt;/p&gt;
 353 
 354 &lt;h4&gt;&lt;a id=&quot;read_only_list_property_elements&quot;&gt;Read-Only List Properties&lt;/a&gt;&lt;/h4&gt;
 355 &lt;p&gt;A read-only list property is a Bean property whose getter returns an instance of &lt;span class=&quot;code&quot;&gt;java.util.List&lt;/span&gt; and has no corresponding setter method. The contents of a read-only list element are automatically added to the list as they are processed.&lt;/p&gt;
 356 
 357 &lt;p&gt;For example, the &quot;children&quot; property of &lt;span class=&quot;code&quot;&gt;javafx.scene.Group&lt;/span&gt; is a read-only list property representing the group&#39;s child nodes:&lt;/p&gt;
 358 
 359 &lt;pre class=&quot;code&quot;&gt;
 360 &amp;lt;?import javafx.scene.*?&amp;gt;
 361 &amp;lt;?import javafx.scene.shape.*?&amp;gt;
 362 &amp;lt;Group xmlns:fx=&quot;http://javafx.com/fxml&quot;&amp;gt;
 363     &amp;lt;children&amp;gt;
 364         &amp;lt;Rectangle fx:id=&quot;rectangle&quot; x=&quot;10&quot; y=&quot;10&quot; width=&quot;320&quot; height=&quot;240&quot;
 365             fill=&quot;#ff0000&quot;/&amp;gt;
 366         ...
 367     &amp;lt;/children&amp;gt;
 368 &amp;lt;/Group&amp;gt;
 369 &lt;/pre&gt;
 370 
 371 &lt;p&gt;As each sub-element of the &lt;span class=&quot;code&quot;&gt;&amp;lt;children&amp;gt;&lt;/span&gt; element is read, it is added to the list returned by &lt;span class=&quot;code&quot;&gt;Group#getChildren()&lt;/span&gt;.
 372 
 373 &lt;h4&gt;&lt;a id=&quot;read_only_map_property_elements&quot;&gt;Read-Only Map Properties&lt;/a&gt;&lt;/h4&gt;
 374 &lt;p&gt;A read-only map property is a bean property whose getter returns an instance of &lt;span class=&quot;code&quot;&gt;java.util.Map&lt;/span&gt; and has no corresponding setter method. The attributes of a read-only map element are applied to the map when the closing tag is processed.&lt;/p&gt;
 375 
 376 &lt;p&gt;The &quot;properties&quot; property of &lt;span class=&quot;code&quot;&gt;javafx.scene.Node&lt;/span&gt; is an example of a read-only map property. The following markup sets the &quot;foo&quot; and &quot;bar&quot; properties of a &lt;span class=&quot;code&quot;&gt;Label&lt;/span&gt; instance to &quot;123&quot; and &quot;456&quot;, respectively:&lt;/p&gt;
 377 
 378 &lt;pre class=&quot;code&quot;&gt;
 379 &amp;lt;?import javafx.scene.control.*?&amp;gt;
 380 &amp;lt;Button&amp;gt;
 381     &amp;lt;properties foo=&quot;123&quot; bar=&quot;456&quot;/&amp;gt;
 382 &amp;lt;/Button&amp;gt;
 383 &lt;/pre&gt;
 384 
 385 &lt;p&gt;Note that a read-only property whose type is neither a &lt;span class=&quot;code&quot;&gt;List&lt;/span&gt; nor a &lt;span class=&quot;code&quot;&gt;Map&lt;/span&gt; will be treated as if it were a read-only map. The return value of the getter method will be wrapped in a &lt;span class=&quot;code&quot;&gt;BeanAdapter&lt;/span&gt; and can be used in the same way as any other read-only map.&lt;/p&gt;
 386 
 387 &lt;h4&gt;&lt;a id=&quot;default_properties&quot;&gt;Default Properties&lt;/a&gt;&lt;/h4&gt;
 388 &lt;p&gt;A class may define a &quot;default property&quot; using the &lt;span class=&quot;code&quot;&gt;@DefaultProperty&lt;/span&gt; annotation defined in the &lt;span class=&quot;code&quot;&gt;javafx.beans&lt;/span&gt; package. If present, the sub-element representing the default property can be omitted from the markup.&lt;/p&gt;
 389 
 390 &lt;p&gt;For example, since &lt;span class=&quot;code&quot;&gt;javafx.scene.layout.Pane&lt;/span&gt; (the superclass of &lt;span class=&quot;code&quot;&gt;javafx.scene.layout.VBox&lt;/span&gt;) defines a default property of &quot;children&quot;, a &lt;span class=&quot;code&quot;&gt;&amp;lt;children&amp;gt;&lt;/span&gt; element is not required; the loader will automatically add the sub-elements of the &lt;span class=&quot;code&quot;&gt;VBox&lt;/span&gt; to the container&#39;s &quot;children&quot; collection:&lt;/p&gt;
 391 
 392 &lt;pre class=&quot;code&quot;&gt;
 393 &amp;lt;?import javafx.scene.*?&amp;gt;
 394 &amp;lt;?import javafx.scene.shape.*?&amp;gt;
 395 &amp;lt;VBox xmlns:fx=&quot;http://javafx.com/fxml&quot;&amp;gt;
 396     &amp;lt;Button text=&quot;Click Me!&quot;/&amp;gt;
 397     ...
 398 &amp;lt;/VBox&amp;gt;
 399 &lt;/pre&gt;
 400 
 401 &lt;p&gt;Note that default properties are not limited to collections. If an element&#39;s default property refers to a scalar value, any sub-element of that element will be set as the value of the property.&lt;/p&gt;
 402 
 403 &lt;p&gt;For example, since &lt;span class=&quot;code&quot;&gt;javafx.scene.control.ScrollPane&lt;/span&gt; defines a default property of &quot;content&quot;, a scroll pane containing a &lt;span class=&quot;code&quot;&gt;TextArea&lt;/span&gt; as its content can be specified as follows:
 404 
 405 &lt;pre class=&quot;code&quot;&gt;
 406 &amp;lt;ScrollPane&amp;gt;
 407     &amp;lt;TextArea text=&quot;Once upon a time...&quot;/&amp;gt;
 408 &amp;lt;/ScrollPane&amp;gt;
 409 &lt;/pre&gt;
 410 
 411 &lt;p&gt;Taking advantage of default properties can significantly reduce the verbosity of FXML markup.&lt;/p&gt;
 412 
 413 &lt;h3&gt;&lt;a id=&quot;static_property_elements&quot;&gt;Static Properties&lt;/a&gt;&lt;/h3&gt;
 414 &lt;p&gt;An element may also represent a &quot;static&quot; property (sometimes called an &quot;attached property&quot;). Static properties are properties that only make sense in a particular context. They are not intrinsic to the class to which they are applied, but are defined by another class (often, the parent container of a control).&lt;/p&gt;
 415 
 416 &lt;p&gt;Static properties are prefixed with the name of class that defines them. For example, The following FXML invokes the static setter for &lt;span class=&quot;code&quot;&gt;GridPane&lt;/span&gt;&#39;s &quot;rowIndex&quot; and &quot;columnIndex&quot; properties:&lt;/p&gt;
 417 
 418 &lt;pre class=&quot;code&quot;&gt;
 419 &amp;lt;GridPane&amp;gt;
 420     &amp;lt;children&amp;gt;
 421         &amp;lt;Label text=&quot;My Label&quot;&amp;gt;
 422             &amp;lt;GridPane.rowIndex&amp;gt;0&amp;lt;/GridPane.rowIndex&amp;gt;
 423        &amp;lt;GridPane.columnIndex&amp;gt;0&amp;lt;/GridPane.columnIndex&amp;gt;
 424         &amp;lt;/Label&amp;gt;
 425     &amp;lt;/children&amp;gt;
 426 &amp;lt;/TabPane&amp;gt;
 427 &lt;/pre&gt;
 428 
 429 &lt;p&gt;This translates roughly to the following in Java:&lt;/p&gt;
 430 
 431 &lt;pre class=&quot;code&quot;&gt;
 432 GridPane gridPane = new GridPane();
 433 
 434 Label label = new Label();
 435 label.setText(&quot;My Label&quot;);
 436 
 437 GridPane.setRowIndex(label, 0);
 438 GridPane.setColumnIndex(label, 0);
 439 
 440 gridPane.getChildren().add(label);
 441 &lt;/pre&gt;
 442 
 443 &lt;p&gt;
 444 The calls to &lt;span class=&quot;code&quot;&gt;GridPane#setRowIndex()&lt;/span&gt; and &lt;span class=&quot;code&quot;&gt;GridPane#setColumnIndex()&lt;/span&gt; &quot;attach&quot; the index data to the &lt;span class=&quot;code&quot;&gt;Label&lt;/span&gt; instance. &lt;span class=&quot;code&quot;&gt;GridPane&lt;/span&gt; then uses these during layout to arrange its children appropriately. Other containers, including &lt;span class=&quot;code&quot;&gt;AnchorPane&lt;/span&gt;, &lt;span class=&quot;code&quot;&gt;BorderPane&lt;/span&gt;, and &lt;span class=&quot;code&quot;&gt;StackPane&lt;/span&gt;, define similar properties.&lt;/p&gt;
 445 
 446 &lt;p&gt;As with instance properties, static property elements are generally used when the property value cannot be efficiently represented by an attribute value. Otherwise, static property attributes (discussed in a later section) will generally produce more concise and readable markup.&lt;/p&gt;
 447 
 448 &lt;h3&gt;&lt;a id=&quot;define_elements&quot;&gt;Define Blocks&lt;/a&gt;&lt;/h3&gt;
 449 &lt;p&gt;The &lt;span class=&quot;code&quot;&gt;&amp;lt;fx:define&amp;gt;&lt;/span&gt; element is used to create objects that exist outside of the object hierarchy but may need to be referred to elsewhere.&lt;/p&gt;
 450 
 451 &lt;p&gt;For example, when working with radio buttons, it is common to define a &lt;span class=&quot;code&quot;&gt;ToggleGroup&lt;/span&gt; that will manage the buttons&#39; selection state. This group is not part of the scene graph itself, so should not be added to the buttons&#39; parent. A define block can be used to create the button group without interfering with the overall structure of the document:&lt;/p&gt;
 452 
 453 &lt;pre class=&quot;code&quot;&gt;
 454 &amp;lt;VBox&amp;gt;
 455     &amp;lt;fx:define&amp;gt;
 456         &amp;lt;ToggleGroup fx:id=&quot;myToggleGroup&quot;/&amp;gt;
 457     &amp;lt;/fx:define&amp;gt;
 458     &amp;lt;children&amp;gt;
 459         &amp;lt;RadioButton text=&quot;A&quot; toggleGroup=&quot;$myToggleGroup&quot;/&amp;gt;
 460         &amp;lt;RadioButton text=&quot;B&quot; toggleGroup=&quot;$myToggleGroup&quot;/&amp;gt;
 461         &amp;lt;RadioButton text=&quot;C&quot; toggleGroup=&quot;$myToggleGroup&quot;/&amp;gt;
 462     &amp;lt;/children&amp;gt;
 463 &amp;lt;/VBox&amp;gt;
 464 &lt;/pre&gt;
 465 
 466 &lt;p&gt;Elements in define blocks are usually assigned an ID that can be used to refer to the element&#39;s value later. IDs are discussed in more detail in later sections.&lt;/p&gt;
 467 
 468 &lt;h2&gt;&lt;a id=&quot;attributes&quot;&gt;Attributes&lt;/a&gt;&lt;/h2&gt;
 469 &lt;p&gt;An attribute in FXML may represent one of the following:&lt;/p&gt;
 470 &lt;ul&gt;
 471 &lt;li&gt;A property of a class instance&lt;/li&gt;
 472 &lt;li&gt;A &quot;static&quot; property&lt;/li&gt;
 473 &lt;li&gt;An event handler&lt;/li&gt;
 474 &lt;/ul&gt;
 475 
 476 &lt;p&gt;Each are discussed in more detail in the following sections.&lt;/p&gt;
 477 
 478 &lt;h3&gt;&lt;a id=&quot;instance_property_attributes&quot;&gt;Instance Properties&lt;/a&gt;&lt;/h3&gt;
 479 &lt;p&gt;Like property elements, attributes can also be used to configure the properties of a class instance. For example, the following markup creates a &lt;span class=&quot;code&quot;&gt;Button&lt;/span&gt; whose text reads &quot;Click Me!&quot;:&lt;/p&gt;
 480 
 481 &lt;pre class=&quot;code&quot;&gt;
 482 &amp;lt;?import javafx.scene.control.*?&amp;gt;
 483 &amp;lt;Button text=&quot;Click Me!&quot;/&amp;gt;
 484 &lt;/pre&gt;
 485 
 486 &lt;p&gt;As with property elements, property attributes support type coercion. When the following markup is processed, the &quot;x&quot;, &quot;y&quot;, &quot;width&quot;, and &quot;height&quot; values will be converted to doubles, and the &quot;fill&quot; value will be converted to a &lt;span class=&quot;code&quot;&gt;Color&lt;/span&gt;:&lt;/p&gt;
 487 
 488 &lt;pre class=&quot;code&quot;&gt;
 489 &amp;lt;Rectangle fx:id=&quot;rectangle&quot; x=&quot;10&quot; y=&quot;10&quot; width=&quot;320&quot; height=&quot;240&quot;
 490     fill=&quot;#ff0000&quot;/&amp;gt;
 491 &lt;/pre&gt;
 492 
 493 &lt;p&gt;Unlike property elements, which are applied as they are processed, property attributes are not applied until the closing tag of their respective element is reached. This is done primarily to facilitate the case where an attribute value depends on some information that won&#39;t be available until after the element&#39;s content has been completely processed (for example, the selected index of a &lt;span class=&quot;code&quot;&gt;TabPane&lt;/span&gt; control, which can&#39;t be set until all of the tabs have been added).&lt;/p&gt;
 494 
 495 &lt;p&gt;Another key difference between property attributes and property elements in FXML is that attributes support a number of &quot;resolution operators&quot; that extend their functionality. The following operators are supported and are discussed in more detail below:&lt;/p&gt;
 496 
 497 &lt;ul&gt;
 498 &lt;li&gt;Location resolution&lt;/li&gt;
 499 &lt;li&gt;Resource resolution&lt;/li&gt;
 500 &lt;li&gt;Variable resolution&lt;/li&gt;
 501 &lt;/ul&gt;
 502 
 503 &lt;h4&gt;&lt;a id=&quot;location_resolution&quot;&gt;Location Resolution&lt;/a&gt;&lt;/h4&gt;
 504 &lt;p&gt;As strings, XML attributes cannot natively represent typed location information such as a URL. However, it is often necessary to specify such locations in markup; for example, the source of an image resource. The location resolution operator (represented by an &quot;@&quot; prefix to the attribute value) is used to specify that an attribute value should be treated as a location relative to the current file rather than a simple string.&lt;/p&gt;
 505 
 506 &lt;p&gt;For example, the following markup creates an ImageView and populates it with image data from &lt;span class=&quot;filename&quot;&gt;my_image.png&lt;/span&gt;, which is assumed to be located at a path relative to the current FXML file:&lt;/p&gt;
 507 
 508 &lt;pre class=&quot;code&quot;&gt;
 509 &amp;lt;ImageView&amp;gt;
 510     &amp;lt;image&amp;gt;
 511         &amp;lt;Image url=&quot;@my_image.png&quot;/&amp;gt;
 512     &amp;lt;/image&amp;gt;
 513 &amp;lt;/ImageView&amp;gt;
 514 &lt;/pre&gt;
 515 
 516 &lt;p&gt;Since &lt;span class=&quot;code&quot;&gt;Image&lt;/span&gt; is an immutable object, a builder is required to construct it. Alternatively, if &lt;span class=&quot;code&quot;&gt;Image&lt;/span&gt; were to define a &lt;span class=&quot;code&quot;&gt;valueOf(URL)&lt;/span&gt; factory method, the image view could be populated as follows:&lt;/p&gt;
 517 
 518 &lt;pre class=&quot;code&quot;&gt;
 519 &amp;lt;ImageView image=&quot;@my_image.png&quot;/&amp;gt;
 520 &lt;/pre&gt;
 521 
 522 &lt;p&gt;The value of the &quot;image&quot; attribute would be converted to a URL by the FXML loader, then coerced to an &lt;span class=&quot;code&quot;&gt;Image&lt;/span&gt; using the &lt;span class=&quot;code&quot;&gt;valueOf()&lt;/span&gt; method.&lt;/p&gt;
 523 
 524 &lt;p&gt;Note that whitespace values in the URL must be encoded; for example, to refer to a file named &quot;My Image.png&quot;, the FXML document should contain the following:&lt;/p&gt;
 525 
 526 &lt;pre class=&quot;code&quot;&gt;
 527 &amp;lt;Image url=&quot;@My%20Image.png&quot;/&amp;gt;
 528 &lt;/pre&gt;
 529 
 530 &lt;p&gt;rather than:&lt;/p&gt;
 531 
 532 &lt;pre class=&quot;code&quot;&gt;
 533 &amp;lt;Image url=&quot;@My Image.png&quot;/&amp;gt;
 534 &lt;/pre&gt;
 535 
 536 &lt;h4&gt;&lt;a id=&quot;resource_resolution&quot;&gt;Resource Resolution&lt;/a&gt;&lt;/h4&gt;
 537 
 538 &lt;p&gt;In FXML, resource substitution can be performed at load time for localization purposes. When provided with an instance of &lt;span class=&quot;code&quot;&gt;java.util.ResourceBundle&lt;/span&gt;, the FXML loader will replace instances of resource names with their locale-specific values. Resource names are identified by a &quot;%&quot; prefix, as shown below:&lt;/p&gt;
 539 
 540 &lt;pre class=&quot;code&quot;&gt;
 541 &amp;lt;Label text=&quot;%myText&quot;/&amp;gt;
 542 &lt;/pre&gt;
 543 
 544 &lt;p&gt;If the loader is given a resource bundle defined as follows:&lt;/p&gt;
 545 
 546 &lt;pre class=&quot;code&quot;&gt;
 547 myText = This is the text!
 548 &lt;/pre&gt;
 549 
 550 
 551 &lt;p&gt;the output of the FXML loader would be a &lt;span class=&quot;code&quot;&gt;Label&lt;/span&gt; instance containing the text &quot;This is the text!&quot;.&lt;/p&gt;
 552 
 553 &lt;h4&gt;&lt;a id=&quot;variable_resolution&quot;&gt;Variable Resolution&lt;/a&gt;&lt;/h4&gt;
 554 &lt;p&gt;An FXML document defines a variable namespace in which named elements and script variables may be uniquely identified. The variable resolution operator allows a caller to replace an attribute value with an instance of a named object before the corresponding setter method is invoked. Variable references are identified by a &quot;$&quot; prefix, as shown below:&lt;/p&gt;
 555 
 556 &lt;pre class=&quot;code&quot;&gt;
 557 &amp;lt;fx:define&amp;gt;
 558     &amp;lt;ToggleGroup fx:id=&quot;myToggleGroup&quot;/&amp;gt;
 559 &amp;lt;/fx:define&amp;gt;
 560 ...
 561 &amp;lt;RadioButton text=&quot;A&quot; toggleGroup=&quot;$myToggleGroup&quot;/&amp;gt;
 562 &amp;lt;RadioButton text=&quot;B&quot; toggleGroup=&quot;$myToggleGroup&quot;/&amp;gt;
 563 &amp;lt;RadioButton text=&quot;C&quot; toggleGroup=&quot;$myToggleGroup&quot;/&amp;gt;
 564 &lt;/pre&gt;
 565 
 566 &lt;p&gt;Assigning an &lt;span class=&quot;code&quot;&gt;fx:id&lt;/span&gt; value to an element creates a variable in the document&#39;s namespace that can later be referred to by variable dereference attributes, such as the &quot;toggleGroup&quot; attribute shown above, or in script code, discussed in a later section. Additionally, if the object&#39;s type defines an &quot;id&quot; property, this value will also be passed to the objects &lt;span class=&quot;code&quot;&gt;setId()&lt;/span&gt; method.&lt;/p&gt;
 567 
 568 &lt;h4&gt;&lt;a id=&quot;escape_sequences&quot;&gt;Escape Sequences&lt;/a&gt;&lt;/h4&gt;
 569 
 570 &lt;p&gt;If the value of an attribute begins with one of the resource resolution prefixes, the character can be escaped by prepending it with a leading backslash (&quot;\&quot;) character. For example, the following markup creates a &lt;span class=&quot;code&quot;&gt;Label&lt;/span&gt; instance whose text reads &quot;$10.00&quot;:&lt;/p&gt;
 571 
 572 &lt;pre class=&quot;code&quot;&gt;
 573 &amp;lt;Label text=&quot;\$10.00&quot;/&amp;gt;
 574 &lt;/pre&gt;
 575 
 576 &lt;h4&gt;&lt;a id=&quot;expression_binding&quot;&gt;Expression Binding&lt;/a&gt;&lt;/h4&gt;
 577 &lt;p&gt;Attribute variables as shown above are resolved once at load time. Later updates to the variables value are not automatically reflected in any properties to which the value was assigned. In many cases, this is sufficient; however, it is often convenient to &quot;bind&quot; a property value to a variable or expression such that changes to the variable are automatically propagated to the target property. Expression bindings can be used for this purpose.&lt;/p&gt;
 578 
 579 &lt;p&gt;An expression binding also begins with the variable resolution operator, but is followed by a set of curly braces which wrap the expression value. For example, the following markup binds the value of a text input&#39;s &quot;text&quot; property to the &quot;text&quot; property of a &lt;span class=&quot;code&quot;&gt;Label&lt;/span&gt; instance:&lt;/p&gt;
 580 
 581 &lt;pre class=&quot;code&quot;&gt;
 582 &amp;lt;TextField fx:id=&quot;textField&quot;/&amp;gt;
 583 &amp;lt;Label text=&quot;${textField.text}&quot;/&amp;gt;
 584 &lt;/pre&gt;
 585 
 586 &lt;p&gt;As the user types in the text input, the label&#39;s text content will be automatically updated.&lt;/p&gt;
 587 
 588 &lt;p&gt;More complex expression are also supported. A list of supported constants and operators follows:&lt;/p&gt;
 589 
 590 &lt;table&gt;
 591  &lt;caption&gt;Constants and Operators Table&lt;/caption&gt;
 592  &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Constant / Operator&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
 593  &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;&quot;string&quot;&lt;br /&gt;&#39;string&#39;&lt;/th&gt;&lt;td&gt;A string constant&lt;/td&gt;&lt;/tr&gt;
 594  &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;true&lt;br /&gt;false&lt;/th&gt;&lt;td&gt;A boolean constant&lt;/td&gt;&lt;/tr&gt;
 595  &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;null&lt;/th&gt;&lt;td&gt;A constant representing the null value&lt;/td&gt;&lt;/tr&gt;
 596  &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;50.0&lt;br /&gt;3e5&lt;br /&gt;42&lt;/th&gt;&lt;td&gt;A numerical constant&lt;/td&gt;&lt;/tr&gt;
 597  &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;- &lt;br/&gt;(unary operator)&lt;/th&gt;&lt;td&gt;Unary minus operator, applied on a number&lt;/td&gt;
 598  &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;! &lt;br/&gt;(unary operator)&lt;/th&gt;&lt;td&gt;Unary negation of a boolean&lt;/td&gt;&lt;/tr&gt;
 599  &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;+ - &lt;br /&gt;
 600                         * /
 601                         %&lt;/th&gt; &lt;td&gt;Numerical binary operators&lt;/td&gt;&lt;/tr&gt;
 602  &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;&amp;amp;&amp;amp; ||&lt;/th&gt;&lt;td&gt;Boolean binary operators&lt;/td&gt;&lt;/tr&gt;
 603  &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;&amp;gt; &amp;gt;= &lt;br /&gt;
 604                    &amp;lt; &amp;lt;= &lt;br /&gt;
 605                    == !=&lt;/th&gt;
 606                    &lt;td&gt;Binary operators of comparison.&lt;br/&gt; Both arguments must be of type Comparable&lt;/td&gt;&lt;/tr&gt;
 607 &lt;/table&gt;
 608 
 609 &lt;h3&gt;&lt;a id=&quot;static_property_attributes&quot;&gt;Static Properties&lt;/a&gt;&lt;/h3&gt;
 610 &lt;p&gt;Attributes representing static properties are handled similarly to static property elements and use a similar syntax. For example, the earlier &lt;span class=&quot;code&quot;&gt;GridPane&lt;/span&gt; markup shown earlier to demonstrate static property elements could be rewritten as follows:&lt;/p&gt;
 611 
 612 &lt;pre class=&quot;code&quot;&gt;
 613 &amp;lt;GridPane&amp;gt;
 614     &amp;lt;children&amp;gt;
 615         &amp;lt;Label text=&quot;My Label&quot; GridPane.rowIndex=&quot;0&quot; GridPane.columnIndex=&quot;0&quot;/&amp;gt;
 616     &amp;lt;/children&amp;gt;
 617 &amp;lt;/TabPane&amp;gt;
 618 &lt;/pre&gt;
 619 
 620 &lt;p&gt;In addition to being more concise, static property attributes, like instance property attributes, support location, resource, and variable resolution operators, the only limitation being that it is not possible to create an expression binding to a static property.&lt;/p&gt;
 621 
 622 &lt;h3&gt;&lt;a id=&quot;event_handler_attributes&quot;&gt;Event Handlers&lt;/a&gt;&lt;/h3&gt;
 623 &lt;p&gt;Event handler attributes are a convenient means of attaching behaviors to document elements. Any class that defines a &lt;span class=&quot;code&quot;&gt;setOn&lt;span class=&quot;variable&quot;&gt;Event&lt;/span&gt;()&lt;/span&gt; method can be assigned an event handler in markup.&lt;/p&gt;
 624 
 625 &lt;p&gt;FXML supports three types of event handler attributes: script event handlers, controller method event handlers and expressions. Each are discussed below.&lt;/p&gt;
 626 
 627 &lt;h4&gt;&lt;a id=&quot;script_event_handlers&quot;&gt;Script Event Handlers&lt;/a&gt;&lt;/h4&gt;
 628 &lt;p&gt;A script event handler is an event handler that executes script code when the event is fired, similar to event handlers in HTML. For example, the following script-based handler for the button&#39;s &quot;onAction&quot; event uses JavaScript to write the text &quot;You clicked me!&quot; to the console when the user presses the button:&lt;/p&gt;
 629 
 630 &lt;pre class=&quot;code&quot;&gt;
 631 &amp;lt;?language javascript?&amp;gt;
 632 ...
 633 
 634 &amp;lt;VBox&amp;gt;
 635     &amp;lt;children&amp;gt;
 636         &amp;lt;Button text=&quot;Click Me!&quot;
 637             onAction=&quot;java.lang.System.out.println(&#39;You clicked me!&#39;);&quot;/&amp;gt;
 638     &amp;lt;/children&amp;gt;
 639 &amp;lt;/VBox&amp;gt;
 640 &lt;/pre&gt;
 641 
 642 &lt;p&gt;Note the use of the language processing instruction at the beginning of the code snippet. This PI tells the FXML loader which scripting language should be used to execute the event handler. A page language must be specified whenever inline script is used in an FXML document, and can only be specified once per document. However, this does not apply to external scripts, which may be implemented using any number of supported scripting languages. Scripting is discussed in more detail in the next section.&lt;/p&gt;
 643 
 644 &lt;p&gt;Note: to turn off automatic compilation of script code place the processing instruction &lt;span class=&quot;code&quot;&gt;&amp;lt;?compile false?&amp;gt;&lt;/span&gt; before the element that contains the script. To turn on compilation of script code again use the processing instruction &lt;span class=&quot;code&quot;&gt;&amp;lt;?compile true?&amp;gt;&lt;/span&gt; (or short: &lt;span class=&quot;code&quot;&gt;&amp;lt;?compile?&amp;gt;&lt;/span&gt;). The compile processing instruction can be used repeatedly to turn compilation of script code off and on.&lt;/p&gt;
 645 
 646 &lt;h4&gt;&lt;a id=&quot;controller_method_event_handlers&quot;&gt;Controller Method Event Handlers&lt;/a&gt;&lt;/h4&gt;
 647 &lt;p&gt;A controller method event handler is a method defined by a document&#39;s &quot;controller&quot;. A controller is an object that is associated with the deserialized contents of an FXML document and is responsible for coordinating the behaviors of the objects (often user interface elements) defined by the document.&lt;/p&gt;
 648 
 649 &lt;p&gt;A controller method event handler is specified by a leading hash symbol followed by the name of the handler method. For example:&lt;/p&gt;
 650 
 651 &lt;pre class=&quot;code&quot;&gt;
 652 &amp;lt;VBox fx:controller=&quot;com.foo.MyController&quot;
 653     xmlns:fx=&quot;http://javafx.com/fxml&quot;&amp;gt;
 654     &amp;lt;children&amp;gt;
 655         &amp;lt;Button text=&quot;Click Me!&quot; onAction=&quot;#handleButtonAction&quot;/&amp;gt;
 656     &amp;lt;/children&amp;gt;
 657 &amp;lt;/VBox&amp;gt;
 658 &lt;/pre&gt;
 659 
 660 &lt;p&gt;Note the use of the &lt;span class=&quot;code&quot;&gt;fx:controller&lt;/span&gt; attribute on the root element. This attribute is used to associate a controller class with the document. If &lt;span class=&quot;code&quot;&gt;MyController&lt;/span&gt; is defined as follows:&lt;/p&gt;
 661 
 662 &lt;pre class=&quot;code&quot;&gt;
 663 package com.foo;
 664 
 665 public class MyController {
 666     public void handleButtonAction(ActionEvent event) {
 667         System.out.println(&quot;You clicked me!&quot;);
 668     }
 669 }
 670 &lt;/pre&gt;
 671 
 672 &lt;p&gt;the &lt;span class=&quot;code&quot;&gt;handleButtonAction()&lt;/span&gt; will be called when the user presses the button, and the text &quot;You clicked me!&quot; will be written to the console.&lt;/p&gt;
 673 
 674 &lt;p&gt;In general, a handler method should conform to the signature of a standard event handler; that is, it should take a single argument of a type that extends &lt;span class=&quot;code&quot;&gt;javafx.event.Event&lt;/span&gt; and should return void (similar to an event delegate in C#). The event argument often carries important and useful information about the nature of the event; however, it is optional and may be omitted if desired.
 675 So this is also a valid handler:&lt;/p&gt;
 676 
 677 &lt;pre class=&quot;code&quot;&gt;
 678 package com.foo;
 679 
 680 public class MyController {
 681     public void handleButtonAction() {
 682         System.out.println(&quot;You clicked me!&quot;);
 683     }
 684 }
 685 &lt;/pre&gt;
 686 
 687 &lt;p&gt;Controllers are discussed in more detail in a later section.&lt;/p&gt;
 688 
 689 &lt;h4&gt;&lt;a id=&quot;expression_handlers&quot;&gt;Event handlers from expressions&lt;/a&gt;&lt;/h4&gt;
 690 &lt;p&gt;Any expression that point to a &lt;a href=&quot;#variable_resolution&quot;&gt;variable&lt;/a&gt; of javafx.event.EventHandler type
 691     can be used as an expression handler. &lt;/p&gt;
 692 &lt;p&gt;
 693 Previous example using an expression handler:
 694 &lt;/p&gt;
 695 &lt;pre class=&quot;code&quot;&gt;
 696 &amp;lt;VBox fx:controller=&quot;com.foo.MyController&quot;
 697     xmlns:fx=&quot;http://javafx.com/fxml&quot;&amp;gt;
 698     &amp;lt;children&amp;gt;
 699         &amp;lt;Button text=&quot;Click Me!&quot; onAction=&quot;$controller.onActionHandler&quot;/&amp;gt;
 700     &amp;lt;/children&amp;gt;
 701 &amp;lt;/VBox&amp;gt;
 702 &lt;/pre&gt;
 703 
 704 &lt;p&gt; With the controller that contains a field like this &lt;/p&gt;
 705 
 706 &lt;pre class=&quot;code&quot;&gt;
 707 public class MyController {
 708 
 709     &amp;#64;FXML
 710     public EventHandler&amp;lt;ActionEvent&amp;gt; onActionHandler = new EventHandler&amp;lt;&amp;gt;() { ... }
 711 
 712     ...
 713 }
 714 &lt;/pre&gt;
 715 
 716 &lt;p&gt; Note that other kinds of expressions, like &lt;a href=&quot;#expression_binding&quot;&gt;binding expressions&lt;/a&gt;
 717     are not supported in this context. &lt;/p&gt;
 718 
 719 &lt;h4&gt;&lt;a id=&quot;collections_and_property_handlers&quot;&gt;Special handlers for collections and properties&lt;/a&gt;&lt;/h4&gt;
 720 &lt;p&gt; Collections and object properties cannot be listen to using &lt;span class=&quot;code&quot;&gt;setOn&lt;span class=&quot;variable&quot;&gt;Event&lt;/span&gt;()&lt;/span&gt; methods.
 721     For these reason, special handler methods need to be used.
 722 &lt;span class=&quot;code&quot;&gt;ObservableList&lt;/span&gt;, &lt;span class=&quot;code&quot;&gt;ObservableMap&lt;/span&gt; or &lt;span class=&quot;code&quot;&gt;ObservableSet&lt;/span&gt;
 723  uses a special &lt;span class=&quot;code&quot;&gt;onChange&lt;/span&gt; attribute that points to a handler method with a &lt;span class=&quot;code&quot;&gt;ListChangeListener.Change&lt;/span&gt;, &lt;span class=&quot;code&quot;&gt;MapChangeListener.Change&lt;/span&gt; or &lt;span class=&quot;code&quot;&gt;SetChangeListener.Change&lt;/span&gt; parameter, respectively.
 724 &lt;/p&gt;
 725 &lt;pre class=&quot;code&quot;&gt;
 726 &amp;lt;VBox fx:controller=&quot;com.foo.MyController&quot;
 727     xmlns:fx=&quot;http://javafx.com/fxml&quot;&amp;gt;
 728     &amp;lt;children onChange=&quot;#handleChildrenChange&quot;/&amp;gt;
 729 &amp;lt;/VBox&amp;gt;
 730 &lt;/pre&gt;
 731 
 732 where the handler method looks like this:
 733 
 734 &lt;pre class=&quot;code&quot;&gt;
 735 package com.foo;
 736 
 737 import javafx.collections.ListChangeListener.Change;
 738 
 739 public class MyController {
 740     public void handleChildrenChange(ListChangeListener.Change c) {
 741         System.out.println(&quot;Children changed!&quot;);
 742     }
 743 }
 744 &lt;/pre&gt;
 745 
 746 &lt;p&gt;Similarly, the property handlers are methods that have the same parameters as changed method of ChangeListener :&lt;/p&gt;
 747 &lt;p&gt;&lt;span class=&quot;code&quot;&gt;changed(ObservableValue&amp;lt;? extends T&amp;gt; observable, T oldValue, T newValue)&lt;/span&gt;&lt;/p&gt;
 748 
 749 &lt;p&gt;A handler for parent property would look like this&lt;/p&gt;
 750 &lt;pre class=&quot;code&quot;&gt;
 751 public class MyController {
 752     public void handleParentChange(ObservableValue value, Parent oldValue, Parent newValue) {
 753         System.out.println(&quot;Parent changed!&quot;);
 754     }
 755 }
 756 &lt;/pre&gt;
 757 
 758 &lt;p&gt;For convenience, the first parameter can be a subclass of &lt;span class=&quot;code&quot;&gt;ObservableValue&lt;/span&gt;,
 759     e.g. &lt;span class=&quot;code&quot;&gt;Property&lt;/span&gt;&lt;/p&gt;
 760 
 761 &lt;p&gt;For registering to a property, a special &lt;span class=&quot;code&quot;&gt;on&amp;lt;propertyName&amp;gt;Change&lt;/span&gt;
 762 attribute must be used.&lt;/p&gt;
 763 
 764 &lt;pre class=&quot;code&quot;&gt;
 765 &amp;lt;VBox fx:controller=&quot;com.foo.MyController&quot;
 766     xmlns:fx=&quot;http://javafx.com/fxml&quot; onParentChange=&quot;#handleParentChange&quot;/&amp;gt;
 767 &lt;/pre&gt;
 768 
 769 &lt;p&gt;Note that collections and properties do not currently support scripting handlers.&lt;/p&gt;
 770 
 771 &lt;h2&gt;&lt;a id=&quot;scripting&quot;&gt;Scripting&lt;/a&gt;&lt;/h2&gt;
 772 &lt;p&gt;
 773 The &lt;span class=&quot;code&quot;&gt;&amp;lt;fx:script&amp;gt;&lt;/span&gt; tag allows a caller to import scripting code into or embed script within a FXML file. Any JVM scripting language can be used, including JavaScript, Groovy, and Clojure, among others. Script code is often used to define event handlers directly in markup or in an associated source file, since event handlers can often be written more concisely in more loosely-typed scripting languages than they can in a statically-typed language such as Java.&lt;/p&gt;
 774 
 775 &lt;p&gt;Scripts are compiled by default, when they are first loaded, if the &lt;span class=&quot;code&quot;&gt;ScriptEngine&lt;/span&gt; implements the &lt;span class=&quot;code&quot;&gt;javax.script.Compilable&lt;/span&gt; interface. If compilation fails, the &lt;span class=&quot;code&quot;&gt;FXMLLoader&lt;/span&gt; will fall back to interpreted mode.&lt;/p&gt;
 776 
 777 &lt;p&gt;Note: to turn off automatic compilation of script code place the processing instruction &lt;span class=&quot;code&quot;&gt;&amp;lt;?compile false?&amp;gt;&lt;/span&gt; before the script element. To turn on compilation of script code again use the processing instruction &lt;span class=&quot;code&quot;&gt;&amp;lt;?compile true?&amp;gt;&lt;/span&gt; (or short: &lt;span class=&quot;code&quot;&gt;&amp;lt;?compile?&amp;gt;&lt;/span&gt;). The compile processing instruction can be used repeatedly to turn compilation of script code off and on.&lt;/p&gt;
 778 
 779 &lt;p&gt;The following example markup defines a function called &lt;span class=&quot;code&quot;&gt;handleButtonAction()&lt;/span&gt; that is called by the action handler attached to the &lt;span class=&quot;code&quot;&gt;Button&lt;/span&gt; element:&lt;/p&gt;
 780 
 781 &lt;pre class=&quot;code&quot;&gt;
 782 &amp;lt;?language javascript?&amp;gt;
 783 
 784 &amp;lt;?import javafx.scene.control.*?&amp;gt;
 785 &amp;lt;?import javafx.scene.layout.*?&amp;gt;
 786 
 787 &amp;lt;VBox xmlns:fx=&quot;http://javafx.com/fxml&quot;&amp;gt;
 788     &amp;lt;fx:script&amp;gt;
 789 
 790     function handleButtonAction(event) {
 791        java.lang.System.out.println(&#39;You clicked me!&#39;);
 792     }
 793     &amp;lt;/fx:script&amp;gt;
 794 
 795     &amp;lt;children&amp;gt;
 796         &amp;lt;Button text=&quot;Click Me!&quot; onAction=&quot;handleButtonAction(event);&quot;/&amp;gt;
 797     &amp;lt;/children&amp;gt;
 798 &amp;lt;/VBox&amp;gt;
 799 &lt;/pre&gt;
 800 
 801 &lt;p&gt;Clicking the button triggers the event handler, which invokes the function, producing output identical to the previous examples.&lt;/p&gt;
 802 
 803 &lt;p&gt;Script code may also be defined in external files. The previous example could be split into an FXML file and a JavaScript source file with no difference in functionality:&lt;/p&gt;
 804 
 805 &lt;div class=&quot;caption&quot;&gt;example.fxml&lt;/div&gt;
 806 &lt;pre class=&quot;code&quot;&gt;
 807 &amp;lt;?language javascript?&amp;gt;
 808 
 809 &amp;lt;?import javafx.scene.control.*?&amp;gt;
 810 &amp;lt;?import javafx.scene.layout.*?&amp;gt;
 811 
 812 &amp;lt;VBox xmlns:fx=&quot;http://javafx.com/fxml&quot;&amp;gt;
 813     &amp;lt;fx:script source=&quot;example.js&quot; charset=&quot;cp1252&quot;/&amp;gt;
 814 
 815     &amp;lt;children&amp;gt;
 816         &amp;lt;Button text=&quot;Click Me!&quot; onAction=&quot;handleButtonAction(event);&quot;/&amp;gt;
 817     &amp;lt;/children&amp;gt;
 818 &amp;lt;/VBox&amp;gt;
 819 &lt;/pre&gt;
 820 
 821 &lt;div class=&quot;caption&quot;&gt;example.js&lt;/div&gt;
 822 &lt;pre class=&quot;code&quot;&gt;
 823 
 824 function handleButtonAction(event) {
 825    java.lang.System.out.println(&#39;You clicked me!&#39;);
 826 }
 827 &lt;/pre&gt;
 828 
 829 &lt;p&gt;It is often preferable to separate code from markup in this way, since many text editors support syntax highlighting for the various scripting languages supported by the JVM. It can also help improve readability of the source code and markup.&lt;/p&gt;
 830 
 831 
 832 &lt;p&gt;Note that script blocks are not limited to defining event handler functions. Script code is executed as it is processed, so it can also be used to dynamically configure the structure of the resulting output. As a simple example, the following FXML includes a script block that defines a variable named &quot;labelText&quot;. The value of this variable is used to populate the text property of a &lt;span class=&quot;code&quot;&gt;Label&lt;/span&gt; instance:&lt;/p&gt;
 833 
 834 &lt;pre class=&quot;code&quot;&gt;
 835 &amp;lt;fx:script&amp;gt;
 836 var myText = &quot;This is the text of my label.&quot;;
 837 &amp;lt;/fx:script&amp;gt;
 838 
 839 ...
 840 
 841 &amp;lt;Label text=&quot;$myText&quot;/&amp;gt;
 842 &lt;/pre&gt;
 843 
 844 &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; As of JavaFX 8, &lt;span class=&quot;code&quot;&gt;importClass()&lt;/span&gt; javascript function is no longer supported. You have to use fully qualified names as in the example above or load a nashorn compatibility script.&lt;/p&gt;
 845 
 846 &lt;pre class=&quot;code&quot;&gt;
 847 load(&quot;nashorn:mozilla_compat.js&quot;);
 848 importClass(java.lang.System);
 849 
 850 function handleButtonAction(event) {
 851    System.out.println(&#39;You clicked me!&#39;);
 852 }
 853 &lt;/pre&gt;
 854 
 855 &lt;h2&gt;&lt;a id=&quot;controllers&quot;&gt;Controllers&lt;/a&gt;&lt;/h2&gt;
 856 &lt;p&gt;While it can be convenient to write simple event handlers in script, either inline or defined in external files, it is often preferable to define more complex application logic in a compiled, strongly-typed language such as Java. As discussed earlier, the &lt;span class=&quot;code&quot;&gt;fx:controller&lt;/span&gt; attribute allows a caller to associate a &quot;controller&quot; class with an FXML document. A controller is a compiled class that implements the &quot;code behind&quot; the object hierarchy defined by the document.&lt;/p&gt;
 857 
 858 &lt;p&gt;As shown earlier, controllers are often used to implement event handlers for user interface elements defined in markup:&lt;/p&gt;
 859 
 860 &lt;pre class=&quot;code&quot;&gt;
 861 &amp;lt;VBox fx:controller=&quot;com.foo.MyController&quot;
 862     xmlns:fx=&quot;http://javafx.com/fxml&quot;&amp;gt;
 863     &amp;lt;children&amp;gt;
 864         &amp;lt;Button text=&quot;Click Me!&quot; onAction=&quot;#handleButtonAction&quot;/&amp;gt;
 865     &amp;lt;/children&amp;gt;
 866 &amp;lt;/VBox&amp;gt;
 867 &lt;/pre&gt;
 868 
 869 &lt;pre class=&quot;code&quot;&gt;
 870 package com.foo;
 871 
 872 public class MyController {
 873     public void handleButtonAction(ActionEvent event) {
 874         System.out.println(&quot;You clicked me!&quot;);
 875     }
 876 }
 877 &lt;/pre&gt;
 878 
 879 &lt;p&gt;In many cases, it is sufficient to simply declare event handlers in this manner. However, when more control over the behavior of the controller and the elements it manages is required, the controller can define an &lt;span class=&quot;code&quot;&gt;initialize()&lt;/span&gt; method, which will be called once on an implementing controller when the contents of its associated document have been completely loaded:&lt;/p&gt;
 880 
 881 &lt;pre class=&quot;code&quot;&gt;
 882 public void initialize();
 883 &lt;/pre&gt;
 884 
 885 &lt;p&gt;This allows the implementing class to perform any necessary post-processing on the content. It also provides the controller with access to the resources that were used to load the document and the location that was used to resolve relative paths within the document (commonly equivalent to the location of the document itself).&lt;/p&gt;
 886 
 887 &lt;p&gt;For example, the following code defines an &lt;span class=&quot;code&quot;&gt;initialize()&lt;/span&gt; method that attaches an action handler to a button in code rather than via an event handler attribute, as was done in the previous example. The button instance variable is injected by the loader as the document is read. The resulting application behavior is identical:&lt;/p&gt;
 888 
 889 &lt;pre class=&quot;code&quot;&gt;
 890 &amp;lt;VBox fx:controller=&quot;com.foo.MyController&quot;
 891     xmlns:fx=&quot;http://javafx.com/fxml&quot;&amp;gt;
 892     &amp;lt;children&amp;gt;
 893         &amp;lt;Button fx:id=&quot;button&quot; text=&quot;Click Me!&quot;/&amp;gt;
 894     &amp;lt;/children&amp;gt;
 895 &amp;lt;/VBox&amp;gt;
 896 &lt;/pre&gt;
 897 
 898 &lt;pre class=&quot;code&quot;&gt;
 899 package com.foo;
 900 
 901 public class MyController implements Initializable {
 902     public Button button;
 903 
 904     &amp;#64;Override
 905     public void initialize(URL location, Resources resources)
 906         button.setOnAction(new EventHandler&amp;lt;ActionEvent&amp;gt;() {
 907             &amp;#64;Override
 908             public void handle(ActionEvent event) {
 909                 System.out.println(&quot;You clicked me!&quot;);
 910             }
 911         });
 912     }
 913 }
 914 &lt;/pre&gt;
 915 
 916 &lt;h3&gt;&lt;a id=&quot;fxml_annotation&quot;&gt;@FXML&lt;/a&gt;&lt;/h3&gt;
 917 &lt;p&gt;Note
 918 that, in the previous examples, the controller member fields and
 919 event handler methods were declared as public so they can be set
 920 or invoked by the loader. In practice, this is not often
 921 an issue, since a controller is generally only visible to the FXML
 922 loader that creates it.
 923 However, for developers who prefer more restricted
 924 visibility for controller fields or handler methods, the &lt;span
 925 class=&quot;code&quot;&gt;javafx.fxml.FXML&lt;/span&gt; annotation can be used. This
 926 annotation marks a protected or private class member as accessible
 927 to FXML.
 928 If the class being annotated is in a named module, the
 929 module containing that class must &lt;span class=&quot;code&quot;&gt;open&lt;/span&gt;
 930 the containing package to at least
 931 the &lt;span class=&quot;code&quot;&gt;javafx.fxml&lt;/span&gt; module.&lt;/p&gt;
 932 
 933 &lt;p&gt;For example, the controllers from the previous examples could be rewritten as follows:&lt;/p&gt;
 934 
 935 &lt;pre class=&quot;code&quot;&gt;
 936 package com.foo;
 937 
 938 public class MyController {
 939     &amp;#64;FXML
 940     private void handleButtonAction(ActionEvent event) {
 941         System.out.println(&quot;You clicked me!&quot;);
 942     }
 943 }
 944 &lt;/pre&gt;
 945 
 946 &lt;pre class=&quot;code&quot;&gt;
 947 package com.foo;
 948 
 949 public class MyController implements Initializable {
 950     &amp;#64;FXML private Button button;
 951 
 952     &amp;#64;FXML
 953     protected void initialize()
 954         button.setOnAction(new EventHandler&amp;lt;ActionEvent&amp;gt;() {
 955             &amp;#64;Override
 956             public void handle(ActionEvent event) {
 957                 System.out.println(&quot;You clicked me!&quot;);
 958             }
 959         });
 960     }
 961 }
 962 &lt;/pre&gt;
 963 
 964 &lt;p&gt;In the first version, the &lt;span class=&quot;code&quot;&gt;handleButtonAction()&lt;/span&gt; is tagged with &lt;span class=&quot;code&quot;&gt;@FXML&lt;/span&gt; to allow markup defined in the controller&#39;s document to invoke it. In the second example, the button field is annotated to allow the loader to set its value. The &lt;span class=&quot;code&quot;&gt;initialize()&lt;/span&gt; method is similarly annotated.&lt;/p&gt;
 965 
 966 &lt;h3&gt;&lt;a id=&quot;nested_controllers&quot;&gt;Nested Controllers&lt;/a&gt;&lt;/h3&gt;
 967 &lt;p&gt;Controller instances for nested FXML documents loaded via the &lt;span class=&quot;code&quot;&gt;&amp;lt;fx:include&amp;gt;&lt;/span&gt; element are mapped directly to member fields of the including controller. This allows a developer to easily access functionality defined by an include (such as a dialog window presented by an application&#39;s main window controller). For example, given the following code:
 968 
 969 &lt;div class=&quot;caption&quot;&gt;main_window_content.fxml&lt;/div&gt;
 970 &lt;pre class=&quot;code&quot;&gt;
 971 &amp;lt;VBox fx:controller=&quot;com.foo.MainController&quot;&amp;gt;
 972    &amp;lt;fx:define&amp;gt;
 973       &amp;lt;fx:include fx:id=&quot;dialog&quot; source=&quot;dialog.fxml&quot;/&amp;gt;
 974    &amp;lt;/fx:define&amp;gt;
 975    ...
 976 &amp;lt;/VBox&amp;gt;
 977 &lt;/pre&gt;
 978 
 979 &lt;div class=&quot;caption&quot;&gt;MainController.java&lt;/div&gt;
 980 &lt;pre class=&quot;code&quot;&gt;
 981 public class MainController extends Controller {
 982     &amp;#64;FXML private Window dialog;
 983     &amp;#64;FXML private DialogController dialogController;
 984 
 985     ...
 986 }
 987 &lt;/pre&gt;
 988 
 989 &lt;p&gt;when the controller&#39;s &lt;span class=&quot;code&quot;&gt;initialize()&lt;/span&gt; method is called, the &lt;span class=&quot;code&quot;&gt;dialog&lt;/span&gt; field will contain the root element loaded from the &quot;dialog.fxml&quot; include, and the &lt;span class=&quot;code&quot;&gt;dialogController&lt;/span&gt; field will contain the include&#39;s controller. The main controller can then invoke methods on the included controller, to populate and show the dialog, for example. Note that as the content of the file referenced by fx:include otherwise would become part of the scene graph spanned from main_window_content.fxml, it is necessary to wrap fx:include by fx:define to separate the scene graphs of both windows.&lt;/p&gt;
 990 
 991 &lt;h2&gt;&lt;a id=&quot;fxmlloader&quot;&gt;FXMLLoader&lt;/a&gt;&lt;/h2&gt;
 992 &lt;p&gt;The &lt;span class=&quot;code&quot;&gt;FXMLLoader&lt;/span&gt; class is responsible for actually loading an FXML source file and returning the resulting object graph. For example, the following code loads an FXML file from a location on the classpath relative to the loading class and localizes it with a resource bundle named &quot;com.foo.example&quot;. The type of the root element is assumed to be a subclass of &lt;span class=&quot;code&quot;&gt;javafx.scene.layout.Pane&lt;/span&gt;, and the document is assumed to define a controller of type &lt;span class=&quot;code&quot;&gt;MyController&lt;/span&gt;:&lt;/p&gt;
 993 
 994 &lt;pre class=&quot;code&quot;&gt;
 995 URL location = getClass().getResource(&quot;example.fxml&quot;);
 996 ResourceBundle resources = ResourceBundle.getBundle(&quot;com.foo.example&quot;);
 997 FXMLLoader fxmlLoader = new FXMLLoader(location, resources);
 998 
 999 Pane root = (Pane)fxmlLoader.load();
1000 MyController controller = (MyController)fxmlLoader.getController();
1001 &lt;/pre&gt;
1002 
1003 &lt;p&gt;Note that the output of an &lt;span class=&quot;code&quot;&gt;FXMLLoader#load()&lt;/span&gt; operation is an instance hierarchy that reflects the actual named classes in the document, not &lt;span class=&quot;code&quot;&gt;org.w3c.dom&lt;/span&gt; nodes representing those classes. Internally, &lt;span class=&quot;code&quot;&gt;FXMLLoader&lt;/span&gt; uses the &lt;span class=&quot;code&quot;&gt;javax.xml.stream&lt;/span&gt; API (also known as the &lt;i&gt;Streaming API for XML&lt;/i&gt;, or &lt;i&gt;StAX&lt;/i&gt;) to load an FXML document. StAX is an extremely efficient event-based XML parsing API that is conceptually similar to its W3C predecessor, SAX. It allows an FXML document to be processed in a single pass, rather than loaded into an intermediate DOM structure and then post-processed.&lt;/p&gt;
1004 
1005 &lt;h3&gt;&lt;a id=&quot;custom_components&quot;&gt;Custom Components&lt;/a&gt;&lt;/h3&gt;
1006 &lt;p&gt;The &lt;span class=&quot;code&quot;&gt;setRoot()&lt;/span&gt; and &lt;span class=&quot;code&quot;&gt;setController()&lt;/span&gt; methods of &lt;span class=&quot;code&quot;&gt;FXMLLoader&lt;/span&gt; allow a caller to inject document root and controller values, respectively, into the document namespace, rather than delegating creation of these values to &lt;span class=&quot;code&quot;&gt;FXMLLoader&lt;/span&gt; itself. This allows a developer to easily create reusable controls that are internally implemented using markup, but (from an API perspective) appear identically to controls implemented programmatically.&lt;/p&gt;
1007 
1008 &lt;p&gt;For example, the following markup defines the structure of a simple custom control containing a &lt;span class=&quot;code&quot;&gt;TextField&lt;/span&gt; and a &lt;span class=&quot;code&quot;&gt;Button&lt;/span&gt; instance. The root container is defined as an instance of &lt;span class=&quot;code&quot;&gt;javafx.scene.layout.VBox&lt;/span&gt;:&lt;/p&gt;
1009 
1010 &lt;pre class=&quot;code&quot;&gt;
1011 &amp;lt;?import javafx.scene.*?&amp;gt;
1012 &amp;lt;?import javafx.scene.control.*?&amp;gt;
1013 &amp;lt;?import javafx.scene.layout.*?&amp;gt;
1014 
1015 &amp;lt;fx:root type=&quot;javafx.scene.layout.VBox&quot; xmlns:fx=&quot;http://javafx.com/fxml&quot;&amp;gt;
1016     &amp;lt;TextField fx:id=&quot;textField&quot;/&amp;gt;
1017     &amp;lt;Button text=&quot;Click Me&quot; onAction=&quot;#doSomething&quot;/&amp;gt;
1018 &amp;lt;/fx:root&amp;gt;
1019 &lt;/pre&gt;
1020 
1021 &lt;p&gt;As mentioned earlier, the &lt;span class=&quot;code&quot;&gt;&amp;lt;fx:root&amp;gt;&lt;/span&gt; tag creates a reference to a previously defined root element. The value of this element is obtained by calling the &lt;span class=&quot;code&quot;&gt;getRoot()&lt;/span&gt; method of &lt;span class=&quot;code&quot;&gt;FXMLLoader&lt;/span&gt;. Prior to calling &lt;span class=&quot;code&quot;&gt;load()&lt;/span&gt;, the caller must specify this value via a call to &lt;span class=&quot;code&quot;&gt;setRoot()&lt;/span&gt;. The caller may similarly provide a value for the document&#39;s controller by calling &lt;span class=&quot;code&quot;&gt;setController()&lt;/span&gt;, which sets the value that will be used as the document&#39;s controller when the document is read. These two methods are commonly used together when creating custom FXML-based components.&lt;/p&gt;
1022 
1023 &lt;p&gt;In the following example, the &lt;span class=&quot;code&quot;&gt;CustomControl&lt;/span&gt; class extends &lt;span class=&quot;code&quot;&gt;VBox&lt;/span&gt; (the type declared by the &lt;span class=&quot;code&quot;&gt;&amp;lt;fx:root&amp;gt;&lt;/span&gt; element), and sets itself as both the root and controller of the FXML document in its constructor. When the document is loaded, the contents of &lt;span class=&quot;code&quot;&gt;CustomControl&lt;/span&gt; will be populated with the contents of the previous FXML document:&lt;/p&gt;
1024 
1025 &lt;pre class=&quot;code&quot;&gt;
1026 package fxml;
1027 
1028 import java.io.IOException;
1029 
1030 import javafx.beans.property.StringProperty;
1031 import javafx.fxml.FXML;
1032 import javafx.fxml.FXMLLoader;
1033 import javafx.scene.control.TextField;
1034 import javafx.scene.layout.VBox;
1035 
1036 public class CustomControl extends VBox {
1037     &amp;#64;FXML private TextField textField;
1038 
1039     public CustomControl() {
1040         FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource(&quot;custom_control.fxml&quot;));
1041         fxmlLoader.setRoot(this);
1042         fxmlLoader.setController(this);
1043 
1044         try {
1045             fxmlLoader.load();
1046         } catch (IOException exception) {
1047             throw new RuntimeException(exception);
1048         }
1049     }
1050 
1051     public String getText() {
1052         return textProperty().get();
1053     }
1054 
1055     public void setText(String value) {
1056         textProperty().set(value);
1057     }
1058 
1059     public StringProperty textProperty() {
1060         return textField.textProperty();
1061     }
1062 
1063     &amp;#64;FXML
1064     protected void doSomething() {
1065         System.out.println(&quot;The button was clicked!&quot;);
1066     }
1067 }
1068 &lt;/pre&gt;
1069 
1070 &lt;p&gt;Now, callers can use instances of this control in code or in markup, just like any other control; e.g.:&lt;/p&gt;
1071 
1072 &lt;div class=&quot;caption&quot;&gt;Java&lt;/div&gt;
1073 &lt;pre class=&quot;code&quot;&gt;
1074 HBox hbox = new HBox();
1075 CustomControl customControl = new CustomControl();
1076 customControl.setText(&quot;Hello World!&quot;);
1077 hbox.getChildren().add(customControl);
1078 &lt;/pre&gt;
1079 
1080 &lt;div class=&quot;caption&quot;&gt;FXML&lt;/div&gt;
1081 &lt;pre class=&quot;code&quot;&gt;
1082 &amp;lt;HBox&amp;gt;
1083     &amp;lt;CustomControl text=&quot;Hello World!&quot;/&amp;gt;
1084 &amp;lt;/HBox&amp;gt;
1085 &lt;/pre&gt;
1086 
1087 &lt;h2&gt;&lt;a id=&quot;deploy_as_module&quot;&gt;Deploying an Application as a Module&lt;/a&gt;&lt;/h2&gt;
1088 &lt;p&gt;If &lt;span class=&quot;code&quot;&gt;FXMLLoader&lt;/span&gt; is used to load types in a named
1089 module, the application must ensure that all types that are referenced in the
1090 FXML files, including the controller class and any custom &lt;span class=&quot;code&quot;&gt;Node&lt;/span&gt;
1091 classes, are reflectively accessible to the &lt;span class=&quot;code&quot;&gt;javafx.fxml&lt;/span&gt;
1092 module. A type is reflectively accessible if the module
1093 &lt;span class=&quot;code&quot;&gt;opens&lt;/span&gt; the containing package to at least the
1094 &lt;span class=&quot;code&quot;&gt;javafx.fxml&lt;/span&gt; module.
1095 &lt;/p&gt;
1096 
1097 &lt;p&gt;For example, if &lt;span class=&quot;code&quot;&gt;com.foo.MyController&lt;/span&gt; is in the
1098 &lt;span class=&quot;code&quot;&gt;foo.app&lt;/span&gt; module, the
1099 &lt;span class=&quot;code&quot;&gt;module-info.java&lt;/span&gt; might look like this:
1100 &lt;/p&gt;
1101 &lt;pre&gt;&lt;span class=&quot;code&quot;&gt;module foo.app {
1102     opens com.foo to javafx.fxml;
1103 }&lt;/span&gt;&lt;/pre&gt;
1104 
1105 &lt;p&gt;Alternatively, a type is reflectively accessible if the module
1106 &lt;span class=&quot;code&quot;&gt;exports&lt;/span&gt; the containing package unconditionally.
1107 &lt;/p&gt;
1108 &lt;hr&gt;
1109 &lt;p&gt;
1110 &lt;small&gt;&lt;a href=&quot;http://bugreport.java.com/bugreport/&quot;&gt;Report a bug or suggest an enhancement&lt;/a&gt;&lt;br&gt; Copyright &amp;copy; 2008, 2020, Oracle and/or its affiliates. All rights reserved.&lt;/small&gt;
1111 &lt;/p&gt;
1112 &lt;/body&gt;
1113 &lt;/html&gt;
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>