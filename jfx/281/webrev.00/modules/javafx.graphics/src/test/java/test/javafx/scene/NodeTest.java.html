<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.graphics/src/test/java/test/javafx/scene/NodeTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package test.javafx.scene;
  27 
  28 import test.javafx.scene.shape.TestUtils;
  29 import test.javafx.scene.shape.CircleTest;
  30 import com.sun.javafx.geom.PickRay;
  31 import com.sun.javafx.geom.transform.Affine2D;
  32 import com.sun.javafx.geom.transform.Affine3D;
  33 import com.sun.javafx.geom.transform.BaseTransform;
  34 import com.sun.javafx.geom.transform.Translate2D;
  35 import test.com.sun.javafx.pgstub.StubToolkit;
  36 import com.sun.javafx.scene.DirtyBits;
  37 import com.sun.javafx.scene.NodeHelper;
  38 import com.sun.javafx.scene.input.PickResultChooser;
  39 import com.sun.javafx.scene.shape.RectangleHelper;
  40 import com.sun.javafx.sg.prism.NGGroup;
  41 import com.sun.javafx.sg.prism.NGNode;
  42 import com.sun.javafx.sg.prism.NGRectangle;
  43 import test.com.sun.javafx.test.objects.TestScene;
  44 import test.com.sun.javafx.test.objects.TestStage;
  45 import com.sun.javafx.tk.Toolkit;
  46 import com.sun.javafx.util.Utils;
  47 import javafx.beans.InvalidationListener;
  48 import javafx.beans.property.*;
  49 import javafx.collections.SetChangeListener;
  50 import javafx.css.PseudoClass;
  51 import javafx.geometry.BoundingBox;
  52 import javafx.geometry.Bounds;
  53 import javafx.geometry.NodeOrientation;
  54 import javafx.geometry.Point2D;
  55 import javafx.geometry.Point3D;
  56 import javafx.scene.effect.DropShadow;
  57 import javafx.scene.effect.Effect;
  58 import javafx.scene.shape.*;
  59 import javafx.scene.transform.Rotate;
  60 import javafx.scene.transform.Transform;
  61 import org.junit.Rule;
  62 import org.junit.Test;
  63 import org.junit.rules.ExpectedException;
  64 
  65 import java.lang.ref.WeakReference;
  66 import java.lang.reflect.Method;
  67 import java.util.Comparator;
  68 import java.util.Set;
  69 
  70 import javafx.scene.Group;
  71 import javafx.scene.GroupShim;
  72 import javafx.scene.Node;
  73 import javafx.scene.NodeShim;
  74 import javafx.scene.ParallelCamera;
  75 import javafx.scene.ParentShim;
  76 import javafx.scene.PerspectiveCamera;
  77 import javafx.scene.Scene;
  78 import javafx.scene.SceneShim;
  79 import javafx.scene.SubScene;
  80 import javafx.scene.layout.AnchorPane;
  81 import javafx.scene.transform.Affine;
  82 import javafx.scene.transform.Scale;
  83 import javafx.scene.transform.Shear;
  84 import javafx.scene.transform.Translate;
  85 import javafx.stage.Stage;
  86 
  87 import static org.junit.Assert.*;
  88 /**
  89  * Tests various aspects of Node.
  90  *
  91  */
  92 public class NodeTest {
  93     @Rule
  94     public ExpectedException thrown = ExpectedException.none();
  95 
  96     // Things to test:
  97         // When parent is changed, should cursor on toolkit change as well if
  98         // the current node has the mouse over it and didn&#39;t explicitly set a
  99         // cursor??
 100 
 101         // Test CSS integration
 102 
 103         // Events:
 104             // Events should *not* be delivered to invisible nodes as per the
 105             // specification for visible
 106 
 107         // A Node must lose focus when it is no longer visible
 108 
 109         // A node made invisible must cause the cursor to be updated
 110 
 111         // Setting the cursor should override the parent cursor when hover
 112         // (test that this happens both when the node already has hover set and
 113         // when hover is changed to true)
 114 
 115         // Setting the cursor to null should revert to parent cursor when hover
 116         // (test that this happens both when the node already has hover set and
 117         // when hover is changed to true)
 118 
 119         // Clip:
 120             // Test setting/clearing the clip affects the bounds
 121             // Test changing bounds / smooth / etc on clip updates bounds of clipped Node
 122 
 123         // Effect:
 124             // Test setting/clearing the effect affects the bounds
 125             // Test changing state on Effect updates bounds of Node
 126 
 127         // Test that a disabled Group affects the disabled property of child nodes
 128 
 129         // Test contains, intersects methods
 130         // Test parentToLocal/localToStage/etc
 131 
 132         // Test computeCompleteBounds
 133         // (other bounds test situtations explicitly tested in BoundsTest)
 134 
 135         // Test transforms end up setting the correct matrix on the peer
 136         // In particular, test that pivots are taken correctly into account
 137 
 138         // Test hover is updated when mouse enters
 139         // Test hover is updated when mouse exists
 140         // Test hover is updated when mouse was over but a higher node then
 141         // turns on blocks mouse
 142         // Test hover is updated when node moves out from under the cursor
 143         // TODO most of these cases cannot be handled until/unless we update
 144         // the list of nodes under the cursor on pulse events
 145 
 146         // Test pressed is updated when mouse is pressed
 147         // Test pressed is updated when mouse is released
 148         // TODO shoudl pressed obey the semantics of a button that is armed &amp; pressed?
 149         // Or should &quot;armed&quot; be put on Node? What to do here?
 150 
 151         // Test various onMouseXXX event handlers
 152 
 153         // Test onKeyXXX handlers
 154 
 155         // Test focused is updated?
 156         // Test nodes which are not focusable are not focused!
 157         // Test focus... (SHOULD NOT DEPEND ON KEY LISTENERS BEING INSTALLED!!)
 158 
 159         // Test that clip is taken into account for both &quot;contains&quot; and
 160         // &quot;intersects&quot;. See http://javafx-jira.kenai.com/browse/RT-646
 161 
 162 
 163 
 164     /***************************************************************************
 165      *                                                                         *
 166      *                              Basic Node Tests                           *
 167      *                                                                         *
 168      **************************************************************************/
 169 
 170     @Test
 171     public void testGetPseudoClassStatesShouldReturnSameSet() {
 172         Rectangle node = new Rectangle();
 173         Set&lt;PseudoClass&gt; set1 = node.getPseudoClassStates();
 174         Set&lt;PseudoClass&gt; set2 = node.getPseudoClassStates();
 175         assertSame(&quot;getPseudoClassStates() should always return the same instance&quot;,
 176                 set1, set2);
 177     }
 178 
 179     @Test(expected=UnsupportedOperationException.class)
 180     public void testPseudoClassStatesIsUnmodifiable() {
 181         Node node = new Rectangle();
 182         node.getPseudoClassStates().add(PseudoClass.getPseudoClass(&quot;dummy&quot;));
 183     }
 184 
 185     @Test
 186     public void testUnmodifiablePseudoClassStatesEqualsBackingStates() {
 187         Rectangle node = new Rectangle();
 188         PseudoClass pseudo = PseudoClass.getPseudoClass(&quot;Pseudo&quot;);
 189         node.pseudoClassStateChanged(pseudo, true);
 190         assertEquals(1, node.getPseudoClassStates().size());
 191         assertEquals(NodeShim.pseudoClassStates(node).size(), node.getPseudoClassStates().size());
 192         assertTrue(NodeShim.pseudoClassStates(node).contains(pseudo));
 193         assertTrue(node.getPseudoClassStates().contains(pseudo));
 194     }
 195 
 196     private boolean isInvalidationListenerInvoked;
 197     private boolean isChangeListenerInvoked;
 198     @Test
 199     public void testPseudoClassStatesListenersAreInvoked() {
 200         Rectangle node = new Rectangle();
 201         node.getPseudoClassStates().addListener((InvalidationListener) inv -&gt; {
 202             isInvalidationListenerInvoked = true;
 203         });
 204         node.getPseudoClassStates().addListener((SetChangeListener&lt;PseudoClass&gt;) c -&gt; {
 205             isChangeListenerInvoked = true;
 206         });
 207 
 208         PseudoClass pseudo = PseudoClass.getPseudoClass(&quot;Pseudo&quot;);
 209         node.pseudoClassStateChanged(pseudo, true);
 210         assertTrue(isInvalidationListenerInvoked);
 211         assertTrue(isChangeListenerInvoked);
 212     }
 213 
 214     @Test
 215     public void testPseudoClassStatesNotGCed() {
 216         Node node = new Rectangle();
 217         WeakReference&lt;Set&lt;?&gt;&gt; weakRef = new WeakReference&lt;&gt;(node.getPseudoClassStates());
 218         TestUtils.attemptGC(weakRef);
 219         assertNotNull(&quot;pseudoClassStates must not be gc&#39;ed&quot;, weakRef.get());
 220     }
 221 
 222 // TODO disable this because it depends on TestNode
 223 //    @Test public void testPeerNotifiedOfVisibilityChanges() {
 224 //        Rectangle rect = new Rectangle();
 225 //        Node peer = rect.impl_getPGNode();
 226 //        assertEquals(peer.visible, rect.visible);
 227 //
 228 //        rect.visible = false;
 229 //        assertEquals(peer.visible, rect.visible);
 230 //
 231 //        rect.visible = true;
 232 //        assertEquals(peer.visible, rect.visible);
 233 //    }
 234 
 235     /***************************************************************************
 236      *                                                                         *
 237      *                            Testing Node Bounds                          *
 238      *                                                                         *
 239      **************************************************************************/
 240 
 241 // TODO disable this because it depends on TestNode
 242 //     public function testContainsCallsPeer():Void {
 243 //         var rect = Rectangle { };
 244 //         var peer = rect.impl_getPGNode() as TestNode;
 245 //         peer.numTimesContainsCalled = 0;
 246 //
 247 //         rect.contains(0, 0);
 248 //         assertEquals(1, peer.numTimesContainsCalled);
 249 //
 250 //         rect.contains(Point2D { x:10, y:10 });
 251 //         assertEquals(2, peer.numTimesContainsCalled);
 252 //     }
 253 
 254 // TODO disable this because it depends on TestNode
 255 //     public function testIntersectsCallsPeer():Void {
 256 //         var rect = Rectangle { };
 257 //         var peer = rect.impl_getPGNode() as TestNode;
 258 //         peer.numTimesIntersectsCalled = 0;
 259 //
 260 //         rect.intersects(0, 0, 10, 10);
 261 //         assertEquals(1, peer.numTimesIntersectsCalled);
 262 //
 263 //         rect.intersects(BoundingBox { minX:10, minY:10, width:100, height:100 });
 264 //         assertEquals(2, peer.numTimesIntersectsCalled);
 265 //     }
 266 
 267     /***************************************************************************
 268      *                                                                         *
 269      *                          Testing Node transforms                        *
 270      *                                                                         *
 271      **************************************************************************/
 272 
 273     /**
 274      * Tests that the function which converts a com.sun.javafx.geom.Point2D
 275      * in parent coords to local coords works properly.
 276      */
 277     @Test public void testParentToLocalGeomPoint() {
 278         Rectangle rect = new Rectangle();
 279         rect.setTranslateX(10);
 280         rect.setTranslateY(10);
 281         rect.setWidth(100);
 282         rect.setHeight(100);
 283         rect.getTransforms().clear();
 284         rect.getTransforms().addAll(Transform.scale(2, 2), Transform.translate(30, 30));
 285 
 286         Point2D pt = new Point2D(0, 0);
 287         pt = rect.parentToLocal(pt);
 288         assertEquals(new Point2D(-35, -35), pt);
 289     }
 290 
 291     // TODO need to test with some observableArrayList of transforms which cannot be
 292     // cleanly inverted so that we can test that code path
 293 
 294     @Test public void testLocalToParentGeomPoint() {
 295         Rectangle rect = new Rectangle();
 296         rect.setTranslateX(10);
 297         rect.setTranslateY(10);
 298         rect.setWidth(100);
 299         rect.setHeight(100);
 300         rect.getTransforms().clear();
 301         rect.getTransforms().addAll(Transform.scale(2, 2), Transform.translate(30, 30));
 302 
 303         Point2D pt = new Point2D(0, 0);
 304         pt = rect.localToParent(pt);
 305         assertEquals(new Point2D(70, 70), pt);
 306     }
 307 
 308     @Test public void testPickingNodeDirectlyNoTransforms() {
 309         Rectangle rect = new Rectangle();
 310         rect.setX(10);
 311         rect.setY(10);
 312         rect.setWidth(100);
 313         rect.setHeight(100);
 314 
 315         // needed since picking doesn&#39;t work unless rooted in a scene and visible
 316         Scene scene = new Scene(new Group());
 317         ParentShim.getChildren(scene.getRoot()).add(rect);
 318 
 319         PickResultChooser res = new PickResultChooser();
 320         NodeHelper.pickNode(rect, new PickRay(50, 50, 1, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY), res);
 321         assertSame(rect, res.getIntersectedNode());
 322         res = new PickResultChooser();
 323         NodeHelper.pickNode(rect, new PickRay(0, 0, 1, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY), res);
 324         assertNull(res.getIntersectedNode());
 325     }
 326 
 327     @Test public void testPickingNodeDirectlyWithTransforms() {
 328         Rectangle rect = new Rectangle();
 329         rect.setTranslateX(10);
 330         rect.setTranslateY(10);
 331         rect.setWidth(100);
 332         rect.setHeight(100);
 333 
 334         // needed since picking doesn&#39;t work unless rooted in a scene and visible
 335         Scene scene = new Scene(new Group());
 336         ParentShim.getChildren(scene.getRoot()).add(rect);
 337 
 338         PickResultChooser res = new PickResultChooser();
 339         NodeHelper.pickNode(rect, new PickRay(50, 50, 1, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY), res);
 340         assertSame(rect, res.getIntersectedNode());
 341         res = new PickResultChooser();
 342         NodeHelper.pickNode(rect, new PickRay(0, 0, 1, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY), res);
 343         assertNull(res.getIntersectedNode());
 344     }
 345 
 346     @Test public void testEffectSharedOnNodes() {
 347         Effect effect = new DropShadow();
 348         Rectangle node = new Rectangle();
 349         node.setEffect(effect);
 350 
 351         Rectangle node2 = new Rectangle();
 352         node2.setEffect(effect);
 353 
 354         assertEquals(effect, node.getEffect());
 355         assertEquals(effect, node2.getEffect());
 356     }
 357 
 358     public static void testBooleanPropertyPropagation(
 359         final Node node,
 360         final String propertyName,
 361         final boolean initialValue,
 362         final boolean newValue) throws Exception {
 363 
 364         final StringBuilder propertyNameBuilder = new StringBuilder(propertyName);
 365         propertyNameBuilder.setCharAt(0, Character.toUpperCase(propertyName.charAt(0)));
 366         final String setterName = new StringBuilder(&quot;set&quot;).append(propertyNameBuilder).toString();
 367         final String getterName = new StringBuilder(&quot;is&quot;).append(propertyNameBuilder).toString();
 368 
 369         final Class&lt;? extends Node&gt; nodeClass = node.getClass();
 370         final Method setter = nodeClass.getMethod(setterName, boolean.class);
 371         final Method getter = nodeClass.getMethod(getterName);
 372 
 373         final NGNode peer = NodeHelper.getPeer(node);
 374         final Class&lt;? extends NGNode&gt; impl_class = peer.getClass();
 375         final Method impl_getter = impl_class.getMethod(getterName);
 376 
 377 
 378         // 1. Create test scene
 379         final Scene scene = new Scene(new Group());
 380         ParentShim.getChildren(scene.getRoot()).add(node);
 381 
 382         // 2. Initial setup
 383         setter.invoke(node, initialValue);
 384         NodeHelper.syncPeer(node);
 385         assertEquals(initialValue, getter.invoke(node));
 386         assertEquals(initialValue, impl_getter.invoke(peer));
 387 
 388         // 3. Change value of the property
 389         setter.invoke(node, newValue);
 390 
 391         // 4. Check that the property value has changed but has not propagated to PGNode
 392         assertEquals(newValue, getter.invoke(node));
 393         assertEquals(initialValue, impl_getter.invoke(peer));
 394 
 395         // 5. Propagate the property value to PGNode
 396         NodeHelper.syncPeer(node);
 397 
 398         // 6. Check that the value has been propagated to PGNode
 399         assertEquals(newValue, impl_getter.invoke(peer));
 400     }
 401 
 402 
 403     public static void testFloatPropertyPropagation(
 404         final Node node,
 405         final String propertyName,
 406         final float initialValue,
 407         final float newValue) throws Exception {
 408 
 409         testFloatPropertyPropagation(node, propertyName, propertyName, initialValue, newValue);
 410     }
 411 
 412     public static void syncNode(Node node) {
 413         NodeShim.updateBounds(node);
 414         NodeHelper.syncPeer(node);
 415     }
 416 
 417     public static void assertBooleanPropertySynced(
 418             final Node node,
 419             final String propertyName,
 420             final String pgPropertyName,
 421             final boolean value) throws Exception {
 422 
 423         final Scene scene = new Scene(new Group(), 500, 500);
 424 
 425         final StringBuilder propertyNameBuilder = new StringBuilder(propertyName);
 426         propertyNameBuilder.setCharAt(0, Character.toUpperCase(propertyName.charAt(0)));
 427         final String getterName = new StringBuilder(&quot;is&quot;).append(propertyNameBuilder).toString();
 428         Method getterMethod = node.getClass().getMethod(getterName, new Class[]{});
 429         Boolean defaultValue = (Boolean)getterMethod.invoke(node);
 430         BooleanProperty v = new SimpleBooleanProperty(defaultValue);
 431 
 432         Method modelMethod = node.getClass().getMethod(
 433                 propertyName + &quot;Property&quot;,
 434                 new Class[]{});
 435         BooleanProperty model = (BooleanProperty)modelMethod.invoke(node);
 436         model.bind(v);
 437 
 438         ParentShim.getChildren(scene.getRoot()).add(node);
 439 
 440         NodeTest.syncNode(node);
 441         assertEquals(defaultValue, TestUtils.getBooleanValue(node, pgPropertyName));
 442 
 443         v.set(value);
 444         NodeTest.syncNode(node);
 445         assertEquals(value, TestUtils.getBooleanValue(node, pgPropertyName));
 446     }
 447 
 448     public static void assertIntPropertySynced(
 449             final Node node,
 450             final String propertyName,
 451             final String pgPropertyName,
 452             final int value) throws Exception {
 453 
 454         final Scene scene = new Scene(new Group(), 500, 500);
 455 
 456         final StringBuilder propertyNameBuilder = new StringBuilder(propertyName);
 457         propertyNameBuilder.setCharAt(0, Character.toUpperCase(propertyName.charAt(0)));
 458         final String getterName = new StringBuilder(&quot;get&quot;).append(propertyNameBuilder).toString();
 459         Method getterMethod = node.getClass().getMethod(getterName, new Class[]{});
 460         Integer defaultValue = (Integer)getterMethod.invoke(node);
 461         IntegerProperty v = new SimpleIntegerProperty(defaultValue);
 462 
 463         Method modelMethod = node.getClass().getMethod(
 464                 propertyName + &quot;Property&quot;,
 465                 new Class[]{});
 466         IntegerProperty model = (IntegerProperty)modelMethod.invoke(node);
 467         model.bind(v);
 468 
 469         ParentShim.getChildren(scene.getRoot()).add(node);
 470 
 471         NodeTest.syncNode(node);
 472         assertTrue(numbersEquals(defaultValue,
 473                 (Number)TestUtils.getObjectValue(node, pgPropertyName)));
 474 
 475         v.set(value);
 476         NodeTest.syncNode(node);
 477         assertTrue(numbersEquals(new Integer(value),
 478                 (Number)TestUtils.getObjectValue(node, pgPropertyName)));
 479     }
 480 
 481     public static boolean numbersEquals(Number expected, Number value) {
 482         return numbersEquals(expected, value, 0.001);
 483     }
 484 
 485     public static boolean numbersEquals(Number expected, Number value, double delta) {
 486         boolean res = (Math.abs(expected.doubleValue() - value.doubleValue()) &lt; delta);
 487         if (!res) {
 488             System.err.println(&quot;expected=&quot; + expected + &quot;, value=&quot; + value);
 489         }
 490         return res;
 491     }
 492 
 493     public static void assertDoublePropertySynced(
 494             final Node node,
 495             final String propertyName,
 496             final String pgPropertyName,
 497             final double value) throws Exception {
 498 
 499         final Scene scene = new Scene(new Group(), 500, 500);
 500 
 501         final StringBuilder propertyNameBuilder = new StringBuilder(propertyName);
 502         propertyNameBuilder.setCharAt(0, Character.toUpperCase(propertyName.charAt(0)));
 503         final String getterName = new StringBuilder(&quot;get&quot;).append(propertyNameBuilder).toString();
 504         Method getterMethod = node.getClass().getMethod(getterName, new Class[]{});
 505         Double defaultValue = (Double)getterMethod.invoke(node);
 506         DoubleProperty v = new SimpleDoubleProperty(defaultValue);
 507 
 508         Method modelMethod = node.getClass().getMethod(
 509                 propertyName + &quot;Property&quot;,
 510                 new Class[]{});
 511         DoubleProperty model = (DoubleProperty)modelMethod.invoke(node);
 512         model.bind(v);
 513 
 514         ParentShim.getChildren(scene.getRoot()).add(node);
 515 
 516         NodeTest.syncNode(node);
 517         assertTrue(numbersEquals(defaultValue,
 518                 (Number)TestUtils.getObjectValue(node, pgPropertyName)));
 519 
 520         v.set(value);
 521         NodeTest.syncNode(node);
 522         assertTrue(numbersEquals(new Double(value),
 523                 (Number)TestUtils.getObjectValue(node, pgPropertyName)));
 524     }
 525 
 526 
 527     public static void assertObjectPropertySynced(
 528             final Node node,
 529             final String propertyName,
 530             final String pgPropertyName,
 531             final Object value) throws Exception {
 532 
 533         final Scene scene = new Scene(new Group(), 500, 500);
 534 
 535         final StringBuilder propertyNameBuilder = new StringBuilder(propertyName);
 536         propertyNameBuilder.setCharAt(0, Character.toUpperCase(propertyName.charAt(0)));
 537         final String getterName = new StringBuilder(&quot;get&quot;).append(propertyNameBuilder).toString();
 538         Method getterMethod = node.getClass().getMethod(getterName, new Class[]{});
 539         Object defaultValue = getterMethod.invoke(node);
 540         ObjectProperty v = new SimpleObjectProperty(defaultValue);
 541 
 542         Method modelMethod = node.getClass().getMethod(
 543                 propertyName + &quot;Property&quot;,
 544                 new Class[]{});
 545         ObjectProperty model = (ObjectProperty)modelMethod.invoke(node);
 546         model.bind(v);
 547 
 548         ParentShim.getChildren(scene.getRoot()).add(node);
 549 
 550         NodeTest.syncNode(node);
 551         // sometimes enum is used on node but int on PGNode
 552         Object result1 = TestUtils.getObjectValue(node, pgPropertyName);
 553         if (result1 instanceof Integer) {
 554             assertTrue(((Enum)defaultValue).ordinal() == ((Integer)result1).intValue());
 555         } else {
 556             assertEquals(defaultValue, TestUtils.getObjectValue(node, pgPropertyName));
 557         }
 558 
 559         v.set(value);
 560         NodeTest.syncNode(node);
 561 
 562         Object result2 = TestUtils.getObjectValue(node, pgPropertyName);
 563         if (result2 instanceof Integer) {
 564             assertTrue(((Enum)value).ordinal() == ((Integer)result2).intValue());
 565         } else {
 566             assertEquals(value, TestUtils.getObjectValue(node, pgPropertyName));
 567         }
 568     }
 569 
 570 
 571 
 572     public static void assertObjectProperty_AsStringSynced(
 573             final Node node,
 574             final String propertyName,
 575             final String pgPropertyName,
 576             final Object value) throws Exception {
 577 
 578         final Scene scene = new Scene(new Group(), 500, 500);
 579 
 580         final StringBuilder propertyNameBuilder = new StringBuilder(propertyName);
 581         propertyNameBuilder.setCharAt(0, Character.toUpperCase(propertyName.charAt(0)));
 582         final String getterName = new StringBuilder(&quot;get&quot;).append(propertyNameBuilder).toString();
 583         Method getterMethod = node.getClass().getMethod(getterName, new Class[]{});
 584         Object defaultValue = getterMethod.invoke(node);
 585         ObjectProperty v = new SimpleObjectProperty(defaultValue);
 586 
 587         Method modelMethod = node.getClass().getMethod(
 588                 propertyName + &quot;Property&quot;,
 589                 new Class[]{});
 590         ObjectProperty model = (ObjectProperty)modelMethod.invoke(node);
 591         model.bind(v);
 592 
 593         ParentShim.getChildren(scene.getRoot()).add(node);
 594 
 595         NodeTest.syncNode(node);
 596         assertEquals(
 597                 defaultValue.toString(),
 598                 TestUtils.getObjectValue(node, pgPropertyName).toString());
 599 
 600         v.set(value);
 601         NodeTest.syncNode(node);
 602 
 603         assertEquals(
 604                 value.toString(),
 605                 TestUtils.getObjectValue(node, pgPropertyName).toString());
 606     }
 607 
 608     public static void assertStringPropertySynced(
 609             final Node node,
 610             final String propertyName,
 611             final String pgPropertyName,
 612             final String value) throws Exception {
 613 
 614         final Scene scene = new Scene(new Group(), 500, 500);
 615 
 616         final StringBuilder propertyNameBuilder = new StringBuilder(propertyName);
 617         propertyNameBuilder.setCharAt(0, Character.toUpperCase(propertyName.charAt(0)));
 618         final String getterName = new StringBuilder(&quot;get&quot;).append(propertyNameBuilder).toString();
 619         Method getterMethod = node.getClass().getMethod(getterName, new Class[]{});
 620         String defaultValue = (String)getterMethod.invoke(node);
 621         StringProperty v = new SimpleStringProperty(defaultValue);
 622 
 623         Method modelMethod = node.getClass().getMethod(
 624                 propertyName + &quot;Property&quot;,
 625                 new Class[]{});
 626         StringProperty model = (StringProperty)modelMethod.invoke(node);
 627         model.bind(v);
 628 
 629         ParentShim.getChildren(scene.getRoot()).add(node);
 630 
 631         NodeTest.syncNode(node);
 632         assertEquals(
 633                 defaultValue,
 634                 TestUtils.getStringValue(node, pgPropertyName));
 635 
 636         v.set(value);
 637         NodeTest.syncNode(node);
 638 
 639         assertEquals(
 640                 value,
 641                 TestUtils.getStringValue(node, pgPropertyName));
 642     }
 643 
 644     public static void testFloatPropertyPropagation(
 645         final Node node,
 646         final String propertyName,
 647         final String pgPropertyName,
 648         final float initialValue,
 649         final float newValue) throws Exception {
 650 
 651         final StringBuilder propertyNameBuilder = new StringBuilder(propertyName);
 652         propertyNameBuilder.setCharAt(0, Character.toUpperCase(propertyName.charAt(0)));
 653 
 654         final StringBuilder pgPropertyNameBuilder = new StringBuilder(pgPropertyName);
 655         pgPropertyNameBuilder.setCharAt(0, Character.toUpperCase(pgPropertyName.charAt(0)));
 656 
 657         final String setterName = new StringBuilder(&quot;set&quot;).append(propertyNameBuilder).toString();
 658         final String getterName = new StringBuilder(&quot;get&quot;).append(propertyNameBuilder).toString();
 659         final String pgGetterName = new StringBuilder(&quot;get&quot;).append(pgPropertyNameBuilder).toString();
 660 
 661         final Class&lt;? extends Node&gt; nodeClass = node.getClass();
 662         final Method setter = nodeClass.getMethod(setterName, float.class);
 663         final Method getter = nodeClass.getMethod(getterName);
 664 
 665         final NGNode peer = NodeHelper.getPeer(node);
 666         final Class&lt;? extends NGNode&gt; impl_class = peer.getClass();
 667         final Method impl_getter = impl_class.getMethod(pgGetterName);
 668 
 669 
 670         // 1. Create test scene
 671         final Scene scene = new Scene(new Group());
 672         ParentShim.getChildren(scene.getRoot()).add(node);
 673 
 674         // 2. Initial setup
 675         setter.invoke(node, initialValue);
 676         NodeHelper.syncPeer(node);
 677         assertEquals(initialValue, (Float) getter.invoke(node), 1e-100);
 678         assertEquals(initialValue, (Float) impl_getter.invoke(peer), 1e-100);
 679 
 680         // 3. Change value of the property
 681         setter.invoke(node, newValue);
 682 
 683         // 4. Check that the property value has changed but has not propagated to PGNode
 684         assertEquals(newValue, (Float) getter.invoke(node), 1e-100);
 685         assertEquals(initialValue, (Float) impl_getter.invoke(peer), 1e-100);
 686 
 687         // 5. Propagate the property value to PGNode
 688         NodeHelper.syncPeer(node);
 689 
 690         // 6. Check that the value has been propagated to PGNode
 691         assertEquals(newValue, (Float) impl_getter.invoke(peer), 1e-100);
 692     }
 693 
 694     public static void testDoublePropertyPropagation(
 695         final Node node,
 696         final String propertyName,
 697         final double initialValue,
 698         final double newValue) throws Exception {
 699 
 700         testDoublePropertyPropagation(node, propertyName, propertyName, initialValue, newValue);
 701     }
 702 
 703 
 704     public static void testDoublePropertyPropagation(
 705         final Node node,
 706         final String propertyName,
 707         final String pgPropertyName,
 708         final double initialValue,
 709         final double newValue) throws Exception {
 710 
 711         final StringBuilder propertyNameBuilder = new StringBuilder(propertyName);
 712         propertyNameBuilder.setCharAt(0, Character.toUpperCase(propertyName.charAt(0)));
 713 
 714         final StringBuilder pgPropertyNameBuilder = new StringBuilder(pgPropertyName);
 715         pgPropertyNameBuilder.setCharAt(0, Character.toUpperCase(pgPropertyName.charAt(0)));
 716 
 717         final String setterName = new StringBuilder(&quot;set&quot;).append(propertyNameBuilder).toString();
 718         final String getterName = new StringBuilder(&quot;get&quot;).append(propertyNameBuilder).toString();
 719         final String pgGetterName = new StringBuilder(&quot;get&quot;).append(pgPropertyNameBuilder).toString();
 720 
 721         final Class&lt;? extends Node&gt; nodeClass = node.getClass();
 722         final Method setter = nodeClass.getMethod(setterName, double.class);
 723         final Method getter = nodeClass.getMethod(getterName);
 724 
 725         final NGNode peer = NodeHelper.getPeer(node);
 726         final Class&lt;? extends NGNode&gt; impl_class = peer.getClass();
 727         final Method impl_getter = impl_class.getMethod(pgGetterName);
 728 
 729 
 730         // 1. Create test scene
 731         final Scene scene = new Scene(new Group());
 732         ParentShim.getChildren(scene.getRoot()).add(node);
 733 
 734         // 2. Initial setup
 735         setter.invoke(node, initialValue);
 736         NodeHelper.syncPeer(node);
 737         assertEquals(initialValue, (Double) getter.invoke(node), 1e-100);
 738         assertEquals((float) initialValue, (Float) impl_getter.invoke(peer), 1e-100);
 739 
 740         // 3. Change value of the property
 741         setter.invoke(node, newValue);
 742 
 743         // 4. Check that the property value has changed but has not propagated to PGNode
 744         assertEquals(newValue, (Double) getter.invoke(node), 1e-100);
 745         assertEquals((float) initialValue, (Float) impl_getter.invoke(peer), 1e-100);
 746 
 747         // 5. Propagate the property value to PGNode
 748         NodeHelper.syncPeer(node);
 749 
 750         // 6. Check that the value has been propagated to PGNode
 751         assertEquals((float) newValue, (Float) impl_getter.invoke(peer), 1e-100);
 752     }
 753 
 754     public interface ObjectValueConvertor {
 755         Object toSg(Object pgValue);
 756     }
 757 
 758     public static final Comparator DEFAULT_OBJ_COMPARATOR =
 759             (sgValue, pgValue) -&gt; {
 760                 assertEquals(sgValue, pgValue);
 761                 return 0;
 762             };
 763 
 764     public static void testObjectPropertyPropagation(
 765         final Node node,
 766         final String propertyName,
 767         final Object initialValue,
 768         final Object newValue) throws Exception {
 769 
 770         testObjectPropertyPropagation(node, propertyName, propertyName, initialValue, newValue);
 771     }
 772 
 773     public static void testObjectPropertyPropagation(
 774             final Node node,
 775             final String propertyName,
 776             final String pgPropertyName,
 777             final Object initialValue,
 778             final Object newValue) throws Exception {
 779         testObjectPropertyPropagation(node, propertyName, pgPropertyName,
 780                 initialValue, newValue, DEFAULT_OBJ_COMPARATOR);
 781     }
 782 
 783     public static void testObjectPropertyPropagation(
 784             final Node node,
 785             final String propertyName,
 786             final String pgPropertyName,
 787             final Object initialValue,
 788             final Object newValue,
 789             final ObjectValueConvertor convertor) throws Exception {
 790         testObjectPropertyPropagation(
 791                 node, propertyName, pgPropertyName,
 792                 initialValue, newValue,
 793                 (sgValue, pgValue) -&gt; {
 794                     assertEquals(sgValue, convertor.toSg(pgValue));
 795                     return 0;
 796                 }
 797         );
 798     }
 799 
 800     public static void testObjectPropertyPropagation(
 801             final Node node,
 802             final String propertyName,
 803             final String pgPropertyName,
 804             final Object initialValue,
 805             final Object newValue,
 806             final Comparator comparator) throws Exception {
 807         final StringBuilder propertyNameBuilder = new StringBuilder(propertyName);
 808         propertyNameBuilder.setCharAt(0, Character.toUpperCase(propertyName.charAt(0)));
 809 
 810         final StringBuilder pgPropertyNameBuilder = new StringBuilder(pgPropertyName);
 811         pgPropertyNameBuilder.setCharAt(0, Character.toUpperCase(pgPropertyName.charAt(0)));
 812 
 813         final String setterName = new StringBuilder(&quot;set&quot;).append(propertyNameBuilder).toString();
 814         final String getterName = new StringBuilder(&quot;get&quot;).append(propertyNameBuilder).toString();
 815         final String pgGetterName = new StringBuilder(&quot;get&quot;).append(pgPropertyNameBuilder).toString();
 816 
 817         final Class&lt;? extends Node&gt; nodeClass = node.getClass();
 818         final Method getter = nodeClass.getMethod(getterName);
 819         final Method setter = nodeClass.getMethod(setterName, getter.getReturnType());
 820 
 821         final NGNode peer = NodeHelper.getPeer(node);
 822         final Class&lt;? extends NGNode&gt; impl_class = peer.getClass();
 823         final Method impl_getter = impl_class.getMethod(pgGetterName);
 824 
 825 
 826         // 1. Create test scene
 827         final Scene scene = new Scene(new Group());
 828         ParentShim.getChildren(scene.getRoot()).add(node);
 829 
 830         // 2. Initial setup
 831         setter.invoke(node, initialValue);
 832         NodeHelper.syncPeer(node);
 833         assertEquals(initialValue, getter.invoke(node));
 834         assertEquals(0, comparator.compare(initialValue,
 835                                            impl_getter.invoke(peer)));
 836 
 837         // 3. Change value of the property
 838         setter.invoke(node, newValue);
 839 
 840         // 4. Check that the property value has changed but has not propagated to PGNode
 841         assertEquals(newValue, getter.invoke(node));
 842         assertEquals(0, comparator.compare(initialValue,
 843                                            impl_getter.invoke(peer)));
 844 
 845         // 5. Propagate the property value to PGNode
 846         NodeHelper.syncPeer(node);
 847 
 848         // 6. Check that the value has been propagated to PGNode
 849         assertEquals(0, comparator.compare(newValue,
 850                                            impl_getter.invoke(peer)));
 851     }
 852 
 853 
 854     public static void testIntPropertyPropagation(
 855         final Node node,
 856         final String propertyName,
 857         final int initialValue,
 858         final int newValue) throws Exception {
 859 
 860         testIntPropertyPropagation(node, propertyName, propertyName, initialValue, newValue);
 861     }
 862 
 863 
 864     public static void testIntPropertyPropagation(
 865         final Node node,
 866         final String propertyName,
 867         final String pgPropertyName,
 868         final int initialValue,
 869         final int newValue) throws Exception {
 870 
 871         final StringBuilder propertyNameBuilder = new StringBuilder(propertyName);
 872         propertyNameBuilder.setCharAt(0, Character.toUpperCase(propertyName.charAt(0)));
 873 
 874         final StringBuilder pgPropertyNameBuilder = new StringBuilder(pgPropertyName);
 875         pgPropertyNameBuilder.setCharAt(0, Character.toUpperCase(pgPropertyName.charAt(0)));
 876 
 877         final String setterName = new StringBuilder(&quot;set&quot;).append(propertyNameBuilder).toString();
 878         final String getterName = new StringBuilder(&quot;get&quot;).append(propertyNameBuilder).toString();
 879         final String pgGetterName = new StringBuilder(&quot;get&quot;).append(pgPropertyNameBuilder).toString();
 880 
 881         final Class&lt;? extends Node&gt; nodeClass = node.getClass();
 882         final Method getter = nodeClass.getMethod(getterName);
 883         final Method setter = nodeClass.getMethod(setterName, getter.getReturnType());
 884 
 885         final NGNode peer = NodeHelper.getPeer(node);
 886         final Class&lt;? extends NGNode&gt; impl_class = peer.getClass();
 887         final Method impl_getter = impl_class.getMethod(pgGetterName);
 888 
 889 
 890         // 1. Create test scene
 891         final Scene scene = new Scene(new Group());
 892         ParentShim.getChildren(scene.getRoot()).add(node);
 893 
 894         // 2. Initial setup
 895         setter.invoke(node, initialValue);
 896         assertEquals(initialValue, getter.invoke(node));
 897         NodeHelper.syncPeer(node);
 898         assertEquals(initialValue, ((Number) impl_getter.invoke(peer)).intValue());
 899 
 900         // 3. Change value of the property
 901         setter.invoke(node, newValue);
 902 
 903         // 4. Check that the property value has changed but has not propagated to PGNode
 904         assertEquals(newValue, getter.invoke(node));
 905         assertEquals(initialValue, ((Number) impl_getter.invoke(peer)).intValue());
 906 
 907         // 5. Propagate the property value to PGNode
 908         NodeHelper.syncPeer(node);
 909 
 910         // 6. Check that the value has been propagated to PGNode
 911         assertEquals(newValue, ((Number) impl_getter.invoke(peer)).intValue());
 912     }
 913 
 914     public static void callSyncPGNode(final Node node) {
 915         NodeHelper.syncPeer(node);
 916     }
 917 
 918     @Test
 919     public void testToFront() {
 920         Rectangle rect1 = new Rectangle();
 921         Rectangle rect2 = new Rectangle();
 922         Group g = new Group();
 923 
 924         Scene scene = new Scene(g);
 925         ParentShim.getChildren(g).add(rect1);
 926         ParentShim.getChildren(g).add(rect2);
 927 
 928         rect1.toFront();
 929         rect2.toFront();
 930 
 931         // toFront should not remove rectangle from scene
 932         assertEquals(scene, rect2.getScene());
 933         assertEquals(scene, rect1.getScene());
 934         // test corect order of scene content
 935         assertEquals(rect2, ParentShim.getChildren(g).get(1));
 936         assertEquals(rect1, ParentShim.getChildren(g).get(0));
 937 
 938         rect1.toFront();
 939         assertEquals(scene, rect2.getScene());
 940         assertEquals(scene, rect1.getScene());
 941         assertEquals(rect1, ParentShim.getChildren(g).get(1));
 942         assertEquals(rect2, ParentShim.getChildren(g).get(0));
 943     }
 944 
 945     @Test
 946     public void testClip() {
 947         Rectangle rect1 = new Rectangle();
 948         Rectangle rect2 = new Rectangle();
 949         rect1.setClip(rect2);
 950 
 951         Scene scene = new Scene(new Group());
 952         ParentShim.getChildren(scene.getRoot()).add(rect1);
 953         assertEquals(rect2, rect1.getClip());
 954         assertEquals(scene, rect2.getScene());
 955 
 956     }
 957 
 958     @Test
 959     public void testInvalidClip() {
 960         Rectangle rectA = new Rectangle(300, 300);
 961         Rectangle clip1 = new Rectangle(10, 10);
 962         Rectangle clip2 = new Rectangle(100, 100);
 963         clip2.setClip(rectA);
 964         rectA.setClip(clip1);
 965         assertEquals(rectA.getClip(), clip1);
 966         thrown.expect(IllegalArgumentException.class);
 967         try {
 968             rectA.setClip(clip2);
 969         } catch (final IllegalArgumentException e) {
 970             assertNotSame(rectA.getClip(), clip2);
 971             throw e;
 972         }
 973     }
 974 
 975     @Test public void testProperties() {
 976         Rectangle node = new Rectangle();
 977         javafx.collections.ObservableMap&lt;Object, Object&gt; properties = node.getProperties();
 978 
 979         /* If we ask for it, we should get it.
 980          */
 981         assertNotNull(properties);
 982 
 983         /* What we put in, we should get out.
 984          */
 985         properties.put(&quot;MyKey&quot;, &quot;MyValue&quot;);
 986         assertEquals(&quot;MyValue&quot;, properties.get(&quot;MyKey&quot;));
 987 
 988         /* If we ask for it again, we should get the same thing.
 989          */
 990         javafx.collections.ObservableMap&lt;Object, Object&gt; properties2 = node.getProperties();
 991         assertEquals(properties2, properties);
 992 
 993         /* What we put in to the other one, we should get out of this one because
 994          * they should be the same thing.
 995          */
 996         assertEquals(&quot;MyValue&quot;, properties2.get(&quot;MyKey&quot;));
 997     }
 998 
 999     public static boolean isDirty(Node node, DirtyBits[] dbs) {
1000         for(DirtyBits db:dbs) {
1001             if (!NodeShim.isDirty(node, db)) {
1002                 System.out.printf(&quot;@NodeTest:check dirty: %s [%d]\n&quot;,db,db.ordinal());
1003                 return false;
1004             }
1005         }
1006         return true;
1007     }
1008 
1009     @Test
1010     public void testDefaultValueForViewOrderIsZeroWhenReadFromGetter() {
1011         final Node node = new Rectangle();
1012         assertEquals(0, node.getViewOrder(), .005);
1013     }
1014 
1015     @Test
1016     public void testDefaultValueForViewOrderIsZeroWhenReadFromProperty() {
1017         final Node node = new Rectangle();
1018         assertEquals(0, node.viewOrderProperty().get(), .005);
1019     }
1020 
1021     @Test
1022     public void settingViewOrderThroughSetterShouldAffectBothGetterAndProperty() {
1023         final Node node = new Rectangle();
1024         node.setViewOrder(.5);
1025         assertEquals(.5, node.getViewOrder(), .005);
1026         assertEquals(.5, node.viewOrderProperty().get(), .005);
1027     }
1028 
1029     @Test
1030     public void settingViewOrderThroughPropertyShouldAffectBothGetterAndProperty() {
1031         final Node node = new Rectangle();
1032         node.viewOrderProperty().set(.5);
1033         assertEquals(.5, node.getViewOrder(), .005);
1034         assertEquals(.5, node.viewOrderProperty().get(), .005);
1035     }
1036 
1037     @Test
1038     public void testDefaultValueForOpacityIsOneWhenReadFromGetter() {
1039         final Node node = new Rectangle();
1040         assertEquals(1, node.getOpacity(), .005);
1041     }
1042 
1043     @Test
1044     public void testDefaultValueForOpacityIsOneWhenReadFromProperty() {
1045         final Node node = new Rectangle();
1046         assertEquals(1, node.opacityProperty().get(), .005);
1047     }
1048 
1049     @Test
1050     public void settingOpacityThroughSetterShouldAffectBothGetterAndProperty() {
1051         final Node node = new Rectangle();
1052         node.setOpacity(.5);
1053         assertEquals(.5, node.getOpacity(), .005);
1054         assertEquals(.5, node.opacityProperty().get(), .005);
1055     }
1056 
1057     @Test
1058     public void settingOpacityThroughPropertyShouldAffectBothGetterAndProperty() {
1059         final Node node = new Rectangle();
1060         node.opacityProperty().set(.5);
1061         assertEquals(.5, node.getOpacity(), .005);
1062         assertEquals(.5, node.opacityProperty().get(), .005);
1063     }
1064 
1065     @Test
1066     public void testDefaultValueForVisibleIsTrueWhenReadFromGetter() {
1067         final Node node = new Rectangle();
1068         assertTrue(node.isVisible());
1069     }
1070 
1071     @Test
1072     public void testDefaultValueForVisibleIsTrueWhenReadFromProperty() {
1073         final Node node = new Rectangle();
1074         assertTrue(node.visibleProperty().get());
1075     }
1076 
1077     @Test
1078     public void settingVisibleThroughSetterShouldAffectBothGetterAndProperty() {
1079         final Node node = new Rectangle();
1080         node.setVisible(false);
1081         assertFalse(node.isVisible());
1082         assertFalse(node.visibleProperty().get());
1083     }
1084 
1085     @Test
1086     public void settingVisibleThroughPropertyShouldAffectBothGetterAndProperty() {
1087         final Node node = new Rectangle();
1088         node.visibleProperty().set(false);
1089         assertFalse(node.isVisible());
1090         assertFalse(node.visibleProperty().get());
1091     }
1092 
1093     @Test
1094     public void testDefaultStyleIsEmptyString() {
1095         final Node node = new Rectangle();
1096         assertEquals(&quot;&quot;, node.getStyle());
1097         assertEquals(&quot;&quot;, node.styleProperty().get());
1098         node.setStyle(null);
1099         assertEquals(&quot;&quot;, node.styleProperty().get());
1100         assertEquals(&quot;&quot;, node.getStyle());
1101     }
1102 
1103     @Test
1104     public void testSynchronizationOfInvisibleNodes() {
1105         final Group g = new Group();
1106         final Circle c = new CircleTest.StubCircle(50);
1107         final NGGroup sg = NodeHelper.getPeer(g);
1108         final CircleTest.StubNGCircle sc = NodeHelper.getPeer(c);
1109         ParentShim.getChildren(g).add(c);
1110 
1111         syncNode(g);
1112         syncNode(c);
1113         assertFalse(sg.getChildren().isEmpty());
1114         assertEquals(50.0, sc.getRadius(), 0.01);
1115 
1116         g.setVisible(false);
1117 
1118         syncNode(g);
1119         syncNode(c);
1120         assertFalse(sg.isVisible());
1121 
1122         final Rectangle r = new Rectangle();
1123         ParentShim.getChildren(g).add(r);
1124         c.setRadius(100);
1125 
1126         syncNode(g);
1127         syncNode(c);
1128         // Group with change in children will always be synced even if it is invisible
1129         assertEquals(2, sg.getChildren().size());
1130         assertEquals(50.0, sc.getRadius(), 0.01);
1131 
1132         g.setVisible(true);
1133 
1134         syncNode(g);
1135         syncNode(c);
1136         assertEquals(2, sg.getChildren().size());
1137         assertEquals(100.0, sc.getRadius(), 0.01);
1138 
1139     }
1140 
1141     @Test
1142     public void testIsTreeVisible() {
1143         final Group g = new Group();
1144         final Circle c = new CircleTest.StubCircle(50);
1145 
1146         ParentShim.getChildren(g).add(c);
1147 
1148         Scene s = new Scene(g);
1149         Stage st = new Stage();
1150 
1151         assertTrue(NodeHelper.isTreeVisible(g));
1152         assertTrue(NodeHelper.isTreeVisible(c));
1153         assertFalse(NodeHelper.isTreeShowing(g));
1154         assertFalse(NodeHelper.isTreeShowing(c));
1155 
1156         st.show();
1157         st.setScene(s);
1158 
1159         assertTrue(NodeHelper.isTreeVisible(g));
1160         assertTrue(NodeHelper.isTreeVisible(c));
1161         assertTrue(NodeHelper.isTreeShowing(g));
1162         assertTrue(NodeHelper.isTreeShowing(c));
1163 
1164         SceneShim.scenePulseListener_pulse(s);
1165 
1166         assertTrue(NodeHelper.isTreeVisible(g));
1167         assertTrue(NodeHelper.isTreeVisible(c));
1168         assertTrue(NodeHelper.isTreeShowing(g));
1169         assertTrue(NodeHelper.isTreeShowing(c));
1170 
1171         g.setVisible(false);
1172         SceneShim.scenePulseListener_pulse(s);
1173 
1174         assertFalse(NodeHelper.isTreeVisible(g));
1175         assertFalse(NodeHelper.isTreeVisible(c));
1176         assertFalse(NodeHelper.isTreeShowing(g));
1177         assertFalse(NodeHelper.isTreeShowing(c));
1178 
1179         g.setVisible(true);
1180         SceneShim.scenePulseListener_pulse(s);
1181 
1182         assertTrue(NodeHelper.isTreeVisible(g));
1183         assertTrue(NodeHelper.isTreeVisible(c));
1184         assertTrue(NodeHelper.isTreeShowing(g));
1185         assertTrue(NodeHelper.isTreeShowing(c));
1186 
1187         c.setVisible(false);
1188         SceneShim.scenePulseListener_pulse(s);
1189 
1190         assertTrue(NodeHelper.isTreeVisible(g));
1191         assertFalse(NodeHelper.isTreeVisible(c));
1192         assertTrue(NodeHelper.isTreeShowing(g));
1193         assertFalse(NodeHelper.isTreeShowing(c));
1194 
1195         c.setVisible(true);
1196         SceneShim.scenePulseListener_pulse(s);
1197 
1198         assertTrue(NodeHelper.isTreeVisible(g));
1199         assertTrue(NodeHelper.isTreeVisible(c));
1200         assertTrue(NodeHelper.isTreeShowing(g));
1201         assertTrue(NodeHelper.isTreeShowing(c));
1202 
1203         s.setRoot(new Group());
1204         SceneShim.scenePulseListener_pulse(s);
1205 
1206         assertTrue(NodeHelper.isTreeVisible(g));
1207         assertTrue(NodeHelper.isTreeVisible(c));
1208         assertFalse(NodeHelper.isTreeShowing(g));
1209         assertFalse(NodeHelper.isTreeShowing(c));
1210 
1211         s.setRoot(g);
1212         SceneShim.scenePulseListener_pulse(s);
1213 
1214         assertTrue(NodeHelper.isTreeVisible(g));
1215         assertTrue(NodeHelper.isTreeVisible(c));
1216         assertTrue(NodeHelper.isTreeShowing(g));
1217         assertTrue(NodeHelper.isTreeShowing(c));
1218 
1219         st.hide();
1220         SceneShim.scenePulseListener_pulse(s);
1221 
1222         assertTrue(NodeHelper.isTreeVisible(g));
1223         assertTrue(NodeHelper.isTreeVisible(c));
1224         assertFalse(NodeHelper.isTreeShowing(g));
1225         assertFalse(NodeHelper.isTreeShowing(c));
1226 
1227     }
1228 
1229     @Test
1230     public void testSynchronizationOfInvisibleNodes_2() {
1231         final Group g = new Group();
1232         final Circle c = new CircleTest.StubCircle(50);
1233 
1234         Scene s = new Scene(g);
1235         Stage st = new Stage();
1236         st.show();
1237         st.setScene(s);
1238 
1239         final NGGroup sg = NodeHelper.getPeer(g);
1240         final CircleTest.StubNGCircle sc = NodeHelper.getPeer(c);
1241 
1242         ParentShim.getChildren(g).add(c);
1243 
1244         SceneShim.scenePulseListener_pulse(s);
1245 
1246         g.setVisible(false);
1247 
1248         SceneShim.scenePulseListener_pulse(s);
1249 
1250         assertFalse(sg.isVisible());
1251         assertTrue(sc.isVisible());
1252 
1253         c.setCenterX(10);             // Make the circle dirty. It won&#39;t be synchronized as it is practically invisible (through the parent)
1254 
1255         SceneShim.scenePulseListener_pulse(s);
1256 
1257         c.setVisible(false);         // As circle is invisible and dirty, this won&#39;t trigger a synchronization
1258 
1259         SceneShim.scenePulseListener_pulse(s);
1260 
1261         assertFalse(sg.isVisible());
1262         assertTrue(sc.isVisible()); // This has not been synchronized, as it&#39;s not necessary
1263                                     // The rendering will stop at the Group, which is invisible
1264 
1265         g.setVisible(true);
1266 
1267         SceneShim.scenePulseListener_pulse(s);
1268 
1269         assertTrue(sg.isVisible());
1270         assertFalse(sc.isVisible()); // Now the group is visible again, we need to synchronize also
1271                                      // the Circle
1272     }
1273 
1274     @Test
1275     public void testSynchronizationOfInvisibleNodes_2_withClip() {
1276         final Group g = new Group();
1277         final Circle c = new CircleTest.StubCircle(50);
1278 
1279         Scene s = new Scene(g);
1280         Stage st = new Stage();
1281         st.show();
1282         st.setScene(s);
1283 
1284         final NGGroup sg = NodeHelper.getPeer(g);
1285         final CircleTest.StubNGCircle sc = NodeHelper.getPeer(c);
1286 
1287         g.setClip(c);
1288 
1289         SceneShim.scenePulseListener_pulse(s);
1290 
1291         g.setVisible(false);
1292 
1293         SceneShim.scenePulseListener_pulse(s);
1294 
1295         assertFalse(sg.isVisible());
1296         assertTrue(sc.isVisible());
1297 
1298         c.setCenterX(10);             // Make the circle dirty. It won&#39;t be synchronized as it is practically invisible (through the parent)
1299 
1300         SceneShim.scenePulseListener_pulse(s);
1301 
1302         c.setVisible(false);         // As circle is invisible and dirty, this won&#39;t trigger a synchronization
1303 
1304         SceneShim.scenePulseListener_pulse(s);
1305 
1306         assertFalse(sg.isVisible());
1307         assertTrue(sc.isVisible()); // This has not been synchronized, as it&#39;s not necessary
1308                                     // The rendering will stop at the Group, which is invisible
1309 
1310         g.setVisible(true);
1311 
1312         SceneShim.scenePulseListener_pulse(s);
1313 
1314         assertTrue(sg.isVisible());
1315         assertFalse(sc.isVisible()); // Now the group is visible again, we need to synchronize also
1316                                      // the Circle
1317     }
1318 
1319     @Test
1320     public void testLocalToScreen() {
1321         Rectangle rect = new Rectangle();
1322 
1323         rect.setTranslateX(10);
1324         rect.setTranslateY(20);
1325 
1326         TestScene scene = new TestScene(new Group(rect));
1327         final TestStage testStage = new TestStage(&quot;&quot;);
1328         testStage.setX(100);
1329         testStage.setY(200);
1330         scene.set_window(testStage);
1331         Point2D p = rect.localToScreen(new Point2D(1, 2));
1332         assertEquals(111.0, p.getX(), 0.0001);
1333         assertEquals(222.0, p.getY(), 0.0001);
1334         Bounds b = rect.localToScreen(new BoundingBox(1, 2, 3, 4));
1335         assertEquals(111.0, b.getMinX(), 0.0001);
1336         assertEquals(222.0, b.getMinY(), 0.0001);
1337         assertEquals(3.0, b.getWidth(), 0.0001);
1338         assertEquals(4.0, b.getHeight(), 0.0001);
1339     }
1340 
1341     @Test
1342     public void testLocalToScreen3D() {
1343         Box box = new Box(10, 10, 10);
1344 
1345         box.setTranslateX(10);
1346         box.setTranslateY(20);
1347 
1348         TestScene scene = new TestScene(new Group(box));
1349         scene.setCamera(new PerspectiveCamera());
1350         final TestStage testStage = new TestStage(&quot;&quot;);
1351         testStage.setX(100);
1352         testStage.setY(200);
1353         scene.set_window(testStage);
1354 
1355         Point2D p = box.localToScreen(new Point3D(1, 2, -5));
1356         assertEquals(111.42, p.getX(), 0.1);
1357         assertEquals(223.14, p.getY(), 0.1);
1358         Bounds b = box.localToScreen(new BoundingBox(1, 2, -5, 1, 2, 10));
1359         assertEquals(110.66, b.getMinX(), 0.1);
1360         assertEquals(221.08, b.getMinY(), 0.1);
1361         assertEquals(1.88, b.getWidth(), 0.1);
1362         assertEquals(4.3, b.getHeight(), 0.1);
1363         assertEquals(0.0, b.getDepth(), 0.0001);
1364     }
1365 
1366     @Test
1367     public void testScreenToLocal() {
1368         Rectangle rect = new Rectangle();
1369 
1370         rect.setTranslateX(10);
1371         rect.setTranslateY(20);
1372 
1373         TestScene scene = new TestScene(new Group(rect));
1374         final TestStage testStage = new TestStage(&quot;&quot;);
1375         testStage.setX(100);
1376         testStage.setY(200);
1377         scene.set_window(testStage);
1378 
1379         assertEquals(new Point2D(1, 2), rect.screenToLocal(new Point2D(111, 222)));
1380         assertEquals(new BoundingBox(1, 2, 3, 4), rect.screenToLocal(new BoundingBox(111, 222, 3, 4)));
1381     }
1382 
1383     @Test
1384     public void testLocalToScreenWithTranslatedCamera() {
1385         Rectangle rect = new Rectangle();
1386 
1387         rect.setTranslateX(10);
1388         rect.setTranslateY(20);
1389 
1390         ParallelCamera cam = new ParallelCamera();
1391         TestScene scene = new TestScene(new Group(rect, cam));
1392         scene.setCamera(cam);
1393         final TestStage testStage = new TestStage(&quot;&quot;);
1394         testStage.setX(100);
1395         testStage.setY(200);
1396         cam.setTranslateX(30);
1397         cam.setTranslateY(20);
1398         scene.set_window(testStage);
1399 
1400         Point2D p = rect.localToScreen(new Point2D(1, 2));
1401         assertEquals(81.0, p.getX(), 0.0001);
1402         assertEquals(202.0, p.getY(), 0.0001);
1403         Bounds b = rect.localToScreen(new BoundingBox(1, 2, 3, 4));
1404         assertEquals(81.0, b.getMinX(), 0.0001);
1405         assertEquals(202.0, b.getMinY(), 0.0001);
1406         assertEquals(3.0, b.getWidth(), 0.0001);
1407         assertEquals(4.0, b.getHeight(), 0.0001);
1408     }
1409 
1410     @Test
1411     public void testScreenToLocalWithTranslatedCamera() {
1412         Rectangle rect = new Rectangle();
1413 
1414         rect.setTranslateX(10);
1415         rect.setTranslateY(20);
1416 
1417         ParallelCamera cam = new ParallelCamera();
1418         TestScene scene = new TestScene(new Group(rect, cam));
1419         scene.setCamera(cam);
1420         final TestStage testStage = new TestStage(&quot;&quot;);
1421         testStage.setX(100);
1422         testStage.setY(200);
1423         cam.setTranslateX(30);
1424         cam.setTranslateY(20);
1425         scene.set_window(testStage);
1426 
1427         assertEquals(new Point2D(31, 22), rect.screenToLocal(new Point2D(111, 222)));
1428         assertEquals(new BoundingBox(31, 22, 3, 4), rect.screenToLocal(new BoundingBox(111, 222, 3, 4)));
1429     }
1430 
1431     @Test
1432     public void testLocalToScreenInsideSubScene() {
1433         Rectangle rect = new Rectangle();
1434         rect.setTranslateX(4);
1435         rect.setTranslateY(9);
1436         SubScene subScene = new SubScene(new Group(rect), 100, 100);
1437         subScene.setTranslateX(6);
1438         subScene.setTranslateY(11);
1439 
1440         TestScene scene = new TestScene(new Group(subScene));
1441         final TestStage testStage = new TestStage(&quot;&quot;);
1442         testStage.setX(100);
1443         testStage.setY(200);
1444         scene.set_window(testStage);
1445 
1446         Point2D p = rect.localToScreen(new Point2D(1, 2));
1447         assertEquals(111.0, p.getX(), 0.0001);
1448         assertEquals(222.0, p.getY(), 0.0001);
1449         Bounds b = rect.localToScreen(new BoundingBox(1, 2, 3, 4));
1450         assertEquals(111.0, b.getMinX(), 0.0001);
1451         assertEquals(222.0, b.getMinY(), 0.0001);
1452         assertEquals(3.0, b.getWidth(), 0.0001);
1453         assertEquals(4.0, b.getHeight(), 0.0001);
1454     }
1455 
1456     @Test
1457     public void testScreenToLocalInsideSubScene() {
1458         Rectangle rect = new Rectangle();
1459         rect.setTranslateX(4);
1460         rect.setTranslateY(9);
1461         SubScene subScene = new SubScene(new Group(rect), 100, 100);
1462         subScene.setTranslateX(6);
1463         subScene.setTranslateY(11);
1464 
1465         TestScene scene = new TestScene(new Group(subScene));
1466         final TestStage testStage = new TestStage(&quot;&quot;);
1467         testStage.setX(100);
1468         testStage.setY(200);
1469         scene.set_window(testStage);
1470 
1471         assertEquals(new Point2D(1, 2), rect.screenToLocal(new Point2D(111, 222)));
1472         assertEquals(new BoundingBox(1, 2, 3, 4), rect.screenToLocal(new BoundingBox(111, 222, 3, 4)));
1473     }
1474 
1475     @Test
1476     public void test2DLocalToScreenOn3DRotatedSubScene() {
1477         Rectangle rect = new Rectangle();
1478         rect.setTranslateX(5);
1479         rect.setTranslateY(10);
1480         SubScene subScene = new SubScene(new Group(rect), 100, 100);
1481         subScene.setTranslateX(5);
1482         subScene.setTranslateY(10);
1483         subScene.setRotationAxis(Rotate.Y_AXIS);
1484         subScene.setRotate(40);
1485 
1486         TestScene scene = new TestScene(new Group(subScene));
1487         scene.setCamera(new PerspectiveCamera());
1488         final TestStage testStage = new TestStage(&quot;&quot;);
1489         testStage.setX(100);
1490         testStage.setY(200);
1491         scene.set_window(testStage);
1492 
1493         Point2D p = rect.localToScreen(new Point2D(1, 2));
1494         assertEquals(124.36, p.getX(), 0.1);
1495         assertEquals(226.0, p.getY(), 0.1);
1496         Bounds b = rect.localToScreen(new BoundingBox(1, 2, 3, 4));
1497         assertEquals(124.36, b.getMinX(), 0.1);
1498         assertEquals(225.75, b.getMinY(), 0.1);
1499         assertEquals(1.85, b.getWidth(), 0.1);
1500         assertEquals(3.76, b.getHeight(), 0.1);
1501     }
1502 
1503     @Test
1504     public void test2DScreenToLocalTo3DRotatedSubScene() {
1505         Rectangle rect = new Rectangle();
1506         rect.setTranslateX(5);
1507         rect.setTranslateY(10);
1508         SubScene subScene = new SubScene(new Group(rect), 100, 100);
1509         subScene.setTranslateX(5);
1510         subScene.setTranslateY(10);
1511         subScene.setRotationAxis(Rotate.Y_AXIS);
1512         subScene.setRotate(40);
1513 
1514         TestScene scene = new TestScene(new Group(subScene));
1515         scene.setCamera(new PerspectiveCamera());
1516         final TestStage testStage = new TestStage(&quot;&quot;);
1517         testStage.setX(100);
1518         testStage.setY(200);
1519         scene.set_window(testStage);
1520 
1521         Point2D p = rect.screenToLocal(new Point2D(124.36, 226.0));
1522         assertEquals(1, p.getX(), 0.1);
1523         assertEquals(2, p.getY(), 0.1);
1524         Bounds b = rect.screenToLocal(new BoundingBox(124.36, 225.75, 1.85, 3.76));
1525         assertEquals(1, b.getMinX(), 0.1);
1526         assertEquals(1.72, b.getMinY(), 0.1);
1527         assertEquals(3, b.getWidth(), 0.1);
1528         assertEquals(4.52, b.getHeight(), 0.1);
1529     }
1530 
1531     @Test
1532     public void testScreenToLocalWithNonInvertibleTransform() {
1533         Rectangle rect = new Rectangle();
1534 
1535         rect.setScaleX(0.0);
1536 
1537         TestScene scene = new TestScene(new Group(rect));
1538         final TestStage testStage = new TestStage(&quot;&quot;);
1539         testStage.setX(100);
1540         testStage.setY(200);
1541         scene.set_window(testStage);
1542 
1543         assertNull(rect.screenToLocal(new Point2D(111, 222)));
1544         assertNull(rect.screenToLocal(new BoundingBox(111, 222, 3, 4)));
1545     }
1546 
1547     @Test
1548     public void testScreenToLocalInsideNonInvertibleSubScene() {
1549         Rectangle rect = new Rectangle();
1550         rect.setTranslateX(4);
1551         rect.setTranslateY(9);
1552         SubScene subScene = new SubScene(new Group(rect), 100, 100);
1553         subScene.setScaleX(0.0);
1554 
1555         TestScene scene = new TestScene(new Group(subScene));
1556         final TestStage testStage = new TestStage(&quot;&quot;);
1557         testStage.setX(100);
1558         testStage.setY(200);
1559         scene.set_window(testStage);
1560 
1561         assertNull(rect.screenToLocal(new Point2D(111, 222)));
1562         assertNull(rect.screenToLocal(new BoundingBox(111, 222, 3, 4)));
1563     }
1564 
1565     @Test
1566     public void testRootMirroringWithTranslate() {
1567         final Group rootGroup = new Group();
1568         rootGroup.setTranslateX(20);
1569         rootGroup.setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);
1570         final Scene scene = new Scene(rootGroup, 200, 200);
1571 
1572         final Point2D trPoint = scene.getRoot().localToScene(0, 0);
1573         assertEquals(180, trPoint.getX(), 0.1);
1574     }
1575 
1576 
1577     @Test
1578     public void testLayoutXYTriggersParentSizeChange() {
1579         final Group rootGroup = new Group();
1580         final Group subGroup = new Group();
1581         ParentShim.getChildren(rootGroup).add(subGroup);
1582 
1583         Rectangle r = new Rectangle(50,50);
1584         r.setManaged(false);
1585         Rectangle staticR = new Rectangle(1,1);
1586         ParentShim.getChildren(subGroup).addAll(r, staticR);
1587 
1588         assertEquals(50,subGroup.getLayoutBounds().getWidth(), 1e-10);
1589         assertEquals(50,subGroup.getLayoutBounds().getHeight(), 1e-10);
1590 
1591         r.setLayoutX(50);
1592 
1593         rootGroup.layout();
1594 
1595         assertEquals(100,subGroup.getLayoutBounds().getWidth(), 1e-10);
1596         assertEquals(50,subGroup.getLayoutBounds().getHeight(), 1e-10);
1597 
1598     }
1599 
1600     @Test
1601     public void testLayoutXYWontBreakLayout() {
1602         final Group rootGroup = new Group();
1603         final AnchorPane pane = new AnchorPane();
1604         ParentShim.getChildren(rootGroup).add(pane);
1605 
1606         Rectangle r = new Rectangle(50,50);
1607         ParentShim.getChildren(pane).add(r);
1608 
1609         AnchorPane.setLeftAnchor(r, 10d);
1610         AnchorPane.setTopAnchor(r, 10d);
1611 
1612         rootGroup.layout();
1613 
1614         assertEquals(10, r.getLayoutX(), 1e-10);
1615         assertEquals(10, r.getLayoutY(), 1e-10);
1616 
1617         r.setLayoutX(50);
1618 
1619         assertEquals(50, r.getLayoutX(), 1e-10);
1620         assertEquals(10, r.getLayoutY(), 1e-10);
1621 
1622         rootGroup.layout();
1623 
1624         assertEquals(10, r.getLayoutX(), 1e-10);
1625         assertEquals(10, r.getLayoutY(), 1e-10);
1626 
1627     }
1628 
1629     @Test
1630     public void clipShouldUpdateAfterParentVisibilityChange() {
1631 
1632         final Group root = new Group();
1633         Scene scene = new Scene(root, 300, 300);
1634 
1635         final Group parent = new Group();
1636         parent.setVisible(false);
1637 
1638         final Circle circle = new Circle(100, 100, 100);
1639         ParentShim.getChildren(parent).add(circle);
1640 
1641         final Rectangle clip = new StubRect(100, 100);
1642         circle.setClip(clip);
1643 
1644         ParentShim.getChildren(root).add(parent);
1645         parent.setVisible(true);
1646 
1647         Stage stage = new Stage();
1648         stage.setScene(scene);
1649         stage.show();
1650 
1651         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1652 
1653         clip.setWidth(300);
1654 
1655         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1656 
1657         assertEquals(300, ((MockNGRect) NodeHelper.getPeer(clip)).w, 1e-10);
1658     }
1659 
1660     @Test
1661     public void untransformedNodeShouldSyncIdentityTransform() {
1662         final Node node = createTestRect();
1663         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1664         assertSame(BaseTransform.IDENTITY_TRANSFORM,
1665                 ((MockNGRect) NodeHelper.getPeer(node)).t);
1666     }
1667 
1668     @Test
1669     public void nodeTransfomedByIdentitiesShouldSyncIdentityTransform() {
1670         final Node node = createTestRect();
1671         node.setRotationAxis(Rotate.X_AXIS);
1672         node.getTransforms().add(new Translate());
1673         node.getTransforms().add(new Scale());
1674         node.getTransforms().add(new Affine());
1675         node.getTransforms().add(new Rotate(0, Rotate.Y_AXIS));
1676         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1677         assertSame(BaseTransform.IDENTITY_TRANSFORM,
1678                 ((MockNGRect) NodeHelper.getPeer(node)).t);
1679     }
1680 
1681     @Test
1682     public void translatedNodeShouldSyncTranslateTransform1() {
1683         final Node node = createTestRect();
1684         node.setTranslateX(30);
1685         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1686         assertSame(Translate2D.class,
1687                 ((MockNGRect) NodeHelper.getPeer(node)).t.getClass());
1688     }
1689 
1690     @Test
1691     public void translatedNodeShouldSyncTranslateTransform2() {
1692         final Node node = createTestRect();
1693         node.getTransforms().add(new Translate(20, 10));
1694         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1695         assertSame(Translate2D.class,
1696                 ((MockNGRect) NodeHelper.getPeer(node)).t.getClass());
1697     }
1698 
1699     @Test
1700     public void multitranslatedNodeShouldSyncTranslateTransform() {
1701         final Node node = createTestRect();
1702         node.setTranslateX(30);
1703         node.getTransforms().add(new Translate(20, 10));
1704         node.getTransforms().add(new Translate(10, 20));
1705         node.getTransforms().add(new Translate(5, 5, 0));
1706         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1707         assertSame(Translate2D.class,
1708                 ((MockNGRect) NodeHelper.getPeer(node)).t.getClass());
1709     }
1710 
1711     @Test
1712     public void mirroringShouldSyncAffine2DTransform() {
1713         final Node node = createTestRect();
1714         node.setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);
1715         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1716         assertSame(Affine2D.class,
1717                 ((MockNGRect) NodeHelper.getPeer(node)).t.getClass());
1718     }
1719 
1720     @Test
1721     public void rotatedNodeShouldSyncAffine2DTransform1() {
1722         final Node node = createTestRect();
1723         node.setRotate(20);
1724         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1725         assertSame(Affine2D.class,
1726                 ((MockNGRect) NodeHelper.getPeer(node)).t.getClass());
1727     }
1728 
1729     @Test
1730     public void rotatedNodeShouldSyncAffine2DTransform2() {
1731         final Node node = createTestRect();
1732         node.getTransforms().add(new Rotate(20));
1733         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1734         assertSame(Affine2D.class,
1735                 ((MockNGRect) NodeHelper.getPeer(node)).t.getClass());
1736     }
1737 
1738     @Test
1739     public void multiRotatedNodeShouldSyncAffine2DTransform() {
1740         final Node node = createTestRect();
1741         node.setRotate(20);
1742         node.getTransforms().add(new Rotate(20));
1743         node.getTransforms().add(new Rotate(0, Rotate.X_AXIS));
1744         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1745         assertSame(Affine2D.class,
1746                 ((MockNGRect) NodeHelper.getPeer(node)).t.getClass());
1747     }
1748 
1749     @Test
1750     public void scaledNodeShouldSyncAffine2DTransform1() {
1751         final Node node = createTestRect();
1752         node.setScaleX(2);
1753         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1754         assertSame(Affine2D.class,
1755                 ((MockNGRect) NodeHelper.getPeer(node)).t.getClass());
1756     }
1757 
1758     @Test
1759     public void scaledNodeShouldSyncAffine2DTransform2() {
1760         final Node node = createTestRect();
1761         node.getTransforms().add(new Scale(2, 1));
1762         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1763         assertSame(Affine2D.class,
1764                 ((MockNGRect) NodeHelper.getPeer(node)).t.getClass());
1765     }
1766 
1767     @Test
1768     public void multiScaledNodeShouldSyncAffine2DTransform() {
1769         final Node node = createTestRect();
1770         node.setScaleX(20);
1771         node.getTransforms().add(new Scale(2, 1));
1772         node.getTransforms().add(new Scale(0.5, 2, 1));
1773         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1774         assertSame(Affine2D.class,
1775                 ((MockNGRect) NodeHelper.getPeer(node)).t.getClass());
1776     }
1777 
1778     @Test
1779     public void shearedNodeShouldSyncAffine2DTransform() {
1780         final Node node = createTestRect();
1781         node.getTransforms().add(new Shear(2, 1));
1782         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1783         assertSame(Affine2D.class,
1784                 ((MockNGRect) NodeHelper.getPeer(node)).t.getClass());
1785     }
1786 
1787     @Test
1788     public void ztranslatedNodeShouldSyncAffine3DTransform1() {
1789         final Node node = createTestRect();
1790         node.setTranslateZ(30);
1791         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1792         assertSame(Affine3D.class,
1793                 ((MockNGRect) NodeHelper.getPeer(node)).t.getClass());
1794     }
1795 
1796     @Test
1797     public void ztranslatedNodeShouldSyncAffine3DTransform2() {
1798         final Node node = createTestRect();
1799         node.getTransforms().add(new Translate(0, 0, 10));
1800         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1801         assertSame(Affine3D.class,
1802                 ((MockNGRect) NodeHelper.getPeer(node)).t.getClass());
1803     }
1804 
1805     @Test
1806     public void zscaledNodeShouldSyncAffine3DTransform1() {
1807         final Node node = createTestRect();
1808         node.setScaleZ(0.5);
1809         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1810         assertSame(Affine3D.class,
1811                 ((MockNGRect) NodeHelper.getPeer(node)).t.getClass());
1812     }
1813 
1814     @Test
1815     public void zscaledNodeShouldSyncAffine3DTransform2() {
1816         final Node node = createTestRect();
1817         node.getTransforms().add(new Scale(1, 1, 2));
1818         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1819         assertSame(Affine3D.class,
1820                 ((MockNGRect) NodeHelper.getPeer(node)).t.getClass());
1821     }
1822 
1823     @Test
1824     public void nonZRotatedNodeShouldSyncAffine3DTransform1() {
1825         final Node node = createTestRect();
1826         node.setRotationAxis(Rotate.Y_AXIS);
1827         node.setRotate(10);
1828         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1829         assertSame(Affine3D.class,
1830                 ((MockNGRect) NodeHelper.getPeer(node)).t.getClass());
1831     }
1832 
1833     @Test
1834     public void nonZRotatedNodeShouldSyncAffine3DTransform2() {
1835         final Node node = createTestRect();
1836         node.getTransforms().add(new Rotate(10, Rotate.X_AXIS));
1837         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1838         assertSame(Affine3D.class,
1839                 ((MockNGRect) NodeHelper.getPeer(node)).t.getClass());
1840     }
1841 
1842     @Test
1843     public void translateTransformShouldBeReusedWhenPossible() {
1844         final Node node = createTestRect();
1845         node.setTranslateX(10);
1846         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1847 
1848         BaseTransform t = ((MockNGRect) NodeHelper.getPeer(node)).t;
1849 
1850         ((MockNGRect) NodeHelper.getPeer(node)).t = null;
1851         node.setTranslateX(20);
1852         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1853 
1854         assertSame(t, ((MockNGRect) NodeHelper.getPeer(node)).t);
1855     }
1856 
1857     @Test
1858     public void affine2DTransformShouldBeReusedWhenPossible() {
1859         final Node node = createTestRect();
1860         node.setScaleX(10);
1861         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1862 
1863         BaseTransform t = ((MockNGRect) NodeHelper.getPeer(node)).t;
1864 
1865         ((MockNGRect) NodeHelper.getPeer(node)).t = null;
1866         node.setRotate(20);
1867         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1868 
1869         assertSame(t, ((MockNGRect) NodeHelper.getPeer(node)).t);
1870     }
1871 
1872     @Test
1873     public void affine3DTransformShouldBeReusedWhenPossible() {
1874         final Node node = createTestRect();
1875         node.setScaleZ(10);
1876         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1877 
1878         BaseTransform t = ((MockNGRect) NodeHelper.getPeer(node)).t;
1879 
1880         ((MockNGRect) NodeHelper.getPeer(node)).t = null;
1881         node.setRotate(20);
1882         ((StubToolkit) Toolkit.getToolkit()).firePulse();
1883 
1884         assertSame(t, ((MockNGRect) NodeHelper.getPeer(node)).t);
1885     }
1886 
1887     @Test
1888     public void rtlSceneSizeShouldBeComputedCorrectly() {
1889         Scene scene = new Scene(new Group(new Rectangle(100, 100)));
1890         scene.setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);
1891         Stage stage = new Stage();
1892         stage.setScene(scene);
1893         stage.show();
1894         assertEquals(100.0, scene.getWidth(), 0.00001);
1895     }
1896 
1897     private Node createTestRect() {
1898         final Rectangle rect = new StubRect();
1899         Scene scene = new Scene(new Group(rect));
1900         Stage stage = new Stage();
1901         stage.setScene(scene);
1902         stage.show();
1903         return rect;
1904     }
1905 
1906     private static class MockNGRect extends NGRectangle {
1907         double w = 0;
1908         BaseTransform t = null;
1909 
1910         @Override public void updateRectangle(float x, float y, float width,
1911                 float height, float arcWidth, float arcHeight) {
1912             w = width;
1913         }
1914 
1915         @Override
1916         public void setTransformMatrix(BaseTransform tx) {
1917             t = tx;
1918         }
1919     }
1920 
1921     static class StubRect extends Rectangle {
1922         static {
1923             StubRectHelper.setStubRectAccessor(new StubRectHelper.StubRectAccessor() {
1924                 @Override
1925                 public NGNode doCreatePeer(Node node) {
1926                     return ((StubRect) node).doCreatePeer();
1927                 }
1928             });
1929         }
1930 
1931         StubRect() {
1932             super();
1933             StubRectHelper.initHelper(this);
1934         }
1935 
1936         StubRect(double width, double height) {
1937             super(width, height);
1938             StubRectHelper.initHelper(this);
1939         }
1940 
1941         private NGNode doCreatePeer() {
1942             return new MockNGRect();
1943         }
1944     }
1945 
1946     public static class StubRectHelper extends RectangleHelper {
1947 
1948         private static final StubRectHelper theInstance;
1949         private static StubRectAccessor stubRectAccessor;
1950 
1951         static {
1952             theInstance = new StubRectHelper();
1953             Utils.forceInit(StubRect.class);
1954         }
1955 
1956         private static StubRectHelper getInstance() {
1957             return theInstance;
1958         }
1959 
1960         public static void initHelper(StubRect stubRect) {
1961             setHelper(stubRect, getInstance());
1962         }
1963 
1964         public static void setStubRectAccessor(final StubRectAccessor newAccessor) {
1965             if (stubRectAccessor != null) {
1966                 throw new IllegalStateException();
1967             }
1968 
1969             stubRectAccessor = newAccessor;
1970         }
1971 
1972         @Override
1973         protected NGNode createPeerImpl(Node node) {
1974             return stubRectAccessor.doCreatePeer(node);
1975         }
1976 
1977         public interface StubRectAccessor {
1978             NGNode doCreatePeer(Node node);
1979         }
1980 
1981     }
1982 }
    </pre>
  </body>
</html>