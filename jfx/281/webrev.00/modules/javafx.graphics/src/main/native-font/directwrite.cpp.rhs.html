<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/native-font/directwrite.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifdef WIN32
  27 
  28 #include &lt;windows.h&gt;
  29 #include &lt;dwrite.h&gt;
  30 #include &lt;d2d1.h&gt;
  31 #include &lt;wincodec.h&gt;
  32 #include &lt;vector&gt;
  33 #include &lt;new&gt;
  34 
  35 #include &lt;com_sun_javafx_font_directwrite_OS.h&gt;
  36 
  37 #define OS_NATIVE(func) Java_com_sun_javafx_font_directwrite_OS_##func
  38 
  39 /* DirectWrite is not available on all platforms. */
  40 typedef HRESULT (WINAPI*DWriteCreateFactoryProc)(
  41   DWRITE_FACTORY_TYPE factoryType,
  42   REFIID iid,
  43   IUnknown **factory
  44 );
  45 
  46 /* Direct2D is not available on all platforms. */
  47 typedef HRESULT (WINAPI*D2D1CreateFactoryProc)(
  48   D2D1_FACTORY_TYPE factoryType,
  49   REFIID iid,
  50   const D2D1_FACTORY_OPTIONS *pFactoryOptions,
  51   void **factory
  52 );
  53 
  54 static jboolean checkAndClearException(JNIEnv* env)
  55 {
  56     jthrowable t = env-&gt;ExceptionOccurred();
  57     if (!t) {
  58         return JNI_FALSE;
  59     }
  60     env-&gt;ExceptionClear();
  61     return JNI_TRUE;
  62 }
  63 
  64 /**************************************************************************/
  65 /*                                                                        */
  66 /*                            Structs                                     */
  67 /*                                                                        */
  68 /**************************************************************************/
  69 
  70 typedef struct DWRITE_GLYPH_METRICS_FID_CACHE {
  71     int cached;
  72     jclass clazz;
  73     jfieldID leftSideBearing, advanceWidth, rightSideBearing, topSideBearing, advanceHeight, bottomSideBearing, verticalOriginY;
  74     jmethodID init;
  75 } DWRITE_GLYPH_METRICS_FID_CACHE;
  76 
  77 DWRITE_GLYPH_METRICS_FID_CACHE DWRITE_GLYPH_METRICSFc;
  78 
  79 void cacheDWRITE_GLYPH_METRICSFields(JNIEnv *env)
  80 {
  81     if (DWRITE_GLYPH_METRICSFc.cached) return;
  82     jclass tmpClass = env-&gt;FindClass(&quot;com/sun/javafx/font/directwrite/DWRITE_GLYPH_METRICS&quot;);
  83     if (checkAndClearException(env) || !tmpClass) {
  84         fprintf(stderr, &quot;cacheDWRITE_GLYPH_METRICSFields error: JNI exception or tmpClass == NULL&quot;);
  85         return;
  86     }
  87     DWRITE_GLYPH_METRICSFc.clazz =  (jclass)env-&gt;NewGlobalRef(tmpClass);
  88     DWRITE_GLYPH_METRICSFc.leftSideBearing = env-&gt;GetFieldID(DWRITE_GLYPH_METRICSFc.clazz, &quot;leftSideBearing&quot;, &quot;I&quot;);
  89     if (checkAndClearException(env) || !DWRITE_GLYPH_METRICSFc.leftSideBearing) {
  90         fprintf(stderr, &quot;cacheDWRITE_GLYPH_METRICSFields error: JNI exception or leftSideBearing == NULL&quot;);
  91         return;
  92     }
  93     DWRITE_GLYPH_METRICSFc.advanceWidth = env-&gt;GetFieldID(DWRITE_GLYPH_METRICSFc.clazz, &quot;advanceWidth&quot;, &quot;I&quot;);
  94     if (checkAndClearException(env) || !DWRITE_GLYPH_METRICSFc.advanceWidth) {
  95         fprintf(stderr, &quot;cacheDWRITE_GLYPH_METRICSFields error: JNI exception or advanceWidth == NULL&quot;);
  96         return;
  97     }
  98     DWRITE_GLYPH_METRICSFc.rightSideBearing = env-&gt;GetFieldID(DWRITE_GLYPH_METRICSFc.clazz, &quot;rightSideBearing&quot;, &quot;I&quot;);
  99     if (checkAndClearException(env) || !DWRITE_GLYPH_METRICSFc.rightSideBearing) {
 100         fprintf(stderr, &quot;cacheDWRITE_GLYPH_METRICSFields error: JNI exception or rightSideBearing == NULL&quot;);
 101         return;
 102     }
 103     DWRITE_GLYPH_METRICSFc.topSideBearing = env-&gt;GetFieldID(DWRITE_GLYPH_METRICSFc.clazz, &quot;topSideBearing&quot;, &quot;I&quot;);
 104     if (checkAndClearException(env) || !DWRITE_GLYPH_METRICSFc.topSideBearing) {
 105         fprintf(stderr, &quot;cacheDWRITE_GLYPH_METRICSFields error: JNI exception or topSideBearing == NULL&quot;);
 106         return;
 107     }
 108     DWRITE_GLYPH_METRICSFc.advanceHeight = env-&gt;GetFieldID(DWRITE_GLYPH_METRICSFc.clazz, &quot;advanceHeight&quot;, &quot;I&quot;);
 109     if (checkAndClearException(env) || !DWRITE_GLYPH_METRICSFc.advanceHeight) {
 110         fprintf(stderr, &quot;cacheDWRITE_GLYPH_METRICSFields error: JNI exception or advanceHeight == NULL&quot;);
 111         return;
 112     }
 113     DWRITE_GLYPH_METRICSFc.bottomSideBearing = env-&gt;GetFieldID(DWRITE_GLYPH_METRICSFc.clazz, &quot;bottomSideBearing&quot;, &quot;I&quot;);
 114     if (checkAndClearException(env) || !DWRITE_GLYPH_METRICSFc.bottomSideBearing) {
 115         fprintf(stderr, &quot;cacheDWRITE_GLYPH_METRICSFields error: JNI exception or bottomSideBearing == NULL&quot;);
 116         return;
 117     }
 118     DWRITE_GLYPH_METRICSFc.verticalOriginY = env-&gt;GetFieldID(DWRITE_GLYPH_METRICSFc.clazz, &quot;verticalOriginY&quot;, &quot;I&quot;);
 119     if (checkAndClearException(env) || !DWRITE_GLYPH_METRICSFc.verticalOriginY) {
 120         fprintf(stderr, &quot;cacheDWRITE_GLYPH_METRICSFields error: JNI exception or verticalOriginY == NULL&quot;);
 121         return;
 122     }
 123     DWRITE_GLYPH_METRICSFc.init = env-&gt;GetMethodID(DWRITE_GLYPH_METRICSFc.clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 124     if (checkAndClearException(env) || !DWRITE_GLYPH_METRICSFc.init) {
 125         fprintf(stderr, &quot;cacheDWRITE_GLYPH_METRICSFields error: JNI exception or &lt;init&gt; == NULL&quot;);
 126         return;
 127     }
 128     DWRITE_GLYPH_METRICSFc.cached = 1;
 129 }
 130 
 131 DWRITE_GLYPH_METRICS *getDWRITE_GLYPH_METRICSFields(JNIEnv *env, jobject lpObject, DWRITE_GLYPH_METRICS *lpStruct)
 132 {
 133     if (!DWRITE_GLYPH_METRICSFc.cached) cacheDWRITE_GLYPH_METRICSFields(env);
 134     lpStruct-&gt;leftSideBearing = env-&gt;GetIntField(lpObject, DWRITE_GLYPH_METRICSFc.leftSideBearing);
 135     lpStruct-&gt;advanceWidth = env-&gt;GetIntField(lpObject, DWRITE_GLYPH_METRICSFc.advanceWidth);
 136     lpStruct-&gt;rightSideBearing = env-&gt;GetIntField(lpObject, DWRITE_GLYPH_METRICSFc.rightSideBearing);
 137     lpStruct-&gt;topSideBearing = env-&gt;GetIntField(lpObject, DWRITE_GLYPH_METRICSFc.topSideBearing);
 138     lpStruct-&gt;advanceHeight = env-&gt;GetIntField(lpObject, DWRITE_GLYPH_METRICSFc.advanceHeight);
 139     lpStruct-&gt;bottomSideBearing = env-&gt;GetIntField(lpObject, DWRITE_GLYPH_METRICSFc.bottomSideBearing);
 140     lpStruct-&gt;verticalOriginY = env-&gt;GetIntField(lpObject, DWRITE_GLYPH_METRICSFc.verticalOriginY);
 141     return lpStruct;
 142 }
 143 
 144 void setDWRITE_GLYPH_METRICSFields(JNIEnv *env, jobject lpObject, DWRITE_GLYPH_METRICS *lpStruct)
 145 {
 146     if (!DWRITE_GLYPH_METRICSFc.cached) cacheDWRITE_GLYPH_METRICSFields(env);
 147     env-&gt;SetIntField(lpObject, DWRITE_GLYPH_METRICSFc.leftSideBearing, (jint)lpStruct-&gt;leftSideBearing);
 148     env-&gt;SetIntField(lpObject, DWRITE_GLYPH_METRICSFc.advanceWidth, (jint)lpStruct-&gt;advanceWidth);
 149     env-&gt;SetIntField(lpObject, DWRITE_GLYPH_METRICSFc.rightSideBearing, (jint)lpStruct-&gt;rightSideBearing);
 150     env-&gt;SetIntField(lpObject, DWRITE_GLYPH_METRICSFc.topSideBearing, (jint)lpStruct-&gt;topSideBearing);
 151     env-&gt;SetIntField(lpObject, DWRITE_GLYPH_METRICSFc.advanceHeight, (jint)lpStruct-&gt;advanceHeight);
 152     env-&gt;SetIntField(lpObject, DWRITE_GLYPH_METRICSFc.bottomSideBearing, (jint)lpStruct-&gt;bottomSideBearing);
 153     env-&gt;SetIntField(lpObject, DWRITE_GLYPH_METRICSFc.verticalOriginY, (jint)lpStruct-&gt;verticalOriginY);
 154 }
 155 
 156 jobject newDWRITE_GLYPH_METRICS(JNIEnv *env, DWRITE_GLYPH_METRICS *lpStruct)
 157 {
 158     jobject lpObject = NULL;
 159     if (!DWRITE_GLYPH_METRICSFc.cached) cacheDWRITE_GLYPH_METRICSFields(env);
 160     lpObject = env-&gt;NewObject(DWRITE_GLYPH_METRICSFc.clazz, DWRITE_GLYPH_METRICSFc.init);
 161     if (lpObject &amp;&amp; lpStruct) setDWRITE_GLYPH_METRICSFields(env, lpObject, lpStruct);
 162     return lpObject;
 163 }
 164 
 165 typedef struct DWRITE_MATRIX_FID_CACHE {
 166     int cached;
 167     jclass clazz;
 168     jfieldID m11, m12, m21, m22, dx, dy;
 169     jmethodID init;
 170 } DWRITE_MATRIX_FID_CACHE;
 171 
 172 DWRITE_MATRIX_FID_CACHE DWRITE_MATRIXFc;
 173 
 174 void cacheDWRITE_MATRIXFields(JNIEnv *env)
 175 {
 176     if (DWRITE_MATRIXFc.cached) return;
 177     jclass tmpClass = env-&gt;FindClass(&quot;com/sun/javafx/font/directwrite/DWRITE_MATRIX&quot;);
 178     if (checkAndClearException(env) || !tmpClass) {
 179         fprintf(stderr, &quot;cacheDWRITE_MATRIXFields error: JNI exception or tmpClass == NULL&quot;);
 180         return;
 181     }
 182     DWRITE_MATRIXFc.clazz =  (jclass)env-&gt;NewGlobalRef(tmpClass);
 183     DWRITE_MATRIXFc.m11 = env-&gt;GetFieldID(DWRITE_MATRIXFc.clazz, &quot;m11&quot;, &quot;F&quot;);
 184     if (checkAndClearException(env) || !DWRITE_MATRIXFc.m11) {
 185         fprintf(stderr, &quot;cacheDWRITE_MATRIXFields error: JNI exception or m11 == NULL&quot;);
 186         return;
 187     }
 188     DWRITE_MATRIXFc.m12 = env-&gt;GetFieldID(DWRITE_MATRIXFc.clazz, &quot;m12&quot;, &quot;F&quot;);
 189     if (checkAndClearException(env) || !DWRITE_MATRIXFc.m12) {
 190         fprintf(stderr, &quot;cacheDWRITE_MATRIXFields error: JNI exception or m12 == NULL&quot;);
 191         return;
 192     }
 193     DWRITE_MATRIXFc.m21 = env-&gt;GetFieldID(DWRITE_MATRIXFc.clazz, &quot;m21&quot;, &quot;F&quot;);
 194     if (checkAndClearException(env) || !DWRITE_MATRIXFc.m21) {
 195         fprintf(stderr, &quot;cacheDWRITE_MATRIXFields error: JNI exception or m21 == NULL&quot;);
 196         return;
 197     }
 198     DWRITE_MATRIXFc.m22 = env-&gt;GetFieldID(DWRITE_MATRIXFc.clazz, &quot;m22&quot;, &quot;F&quot;);
 199     if (checkAndClearException(env) || !DWRITE_MATRIXFc.m22) {
 200         fprintf(stderr, &quot;cacheDWRITE_MATRIXFields error: JNI exception or m22 == NULL&quot;);
 201         return;
 202     }
 203     DWRITE_MATRIXFc.dx = env-&gt;GetFieldID(DWRITE_MATRIXFc.clazz, &quot;dx&quot;, &quot;F&quot;);
 204     if (checkAndClearException(env) || !DWRITE_MATRIXFc.dx) {
 205         fprintf(stderr, &quot;cacheDWRITE_MATRIXFields error: JNI exception or dx == NULL&quot;);
 206         return;
 207     }
 208     DWRITE_MATRIXFc.dy = env-&gt;GetFieldID(DWRITE_MATRIXFc.clazz, &quot;dy&quot;, &quot;F&quot;);
 209     if (checkAndClearException(env) || !DWRITE_MATRIXFc.dy) {
 210         fprintf(stderr, &quot;cacheDWRITE_MATRIXFields error: JNI exception or dy == NULL&quot;);
 211         return;
 212     }
 213     DWRITE_MATRIXFc.init = env-&gt;GetMethodID(DWRITE_MATRIXFc.clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 214     if (checkAndClearException(env) || !DWRITE_MATRIXFc.init) {
 215         fprintf(stderr, &quot;cacheDWRITE_MATRIXFields error: JNI exception or &lt;init&gt; == NULL&quot;);
 216         return;
 217     }
 218     DWRITE_MATRIXFc.cached = 1;
 219 }
 220 
 221 DWRITE_MATRIX *getDWRITE_MATRIXFields(JNIEnv *env, jobject lpObject, DWRITE_MATRIX *lpStruct)
 222 {
 223     if (!DWRITE_MATRIXFc.cached) cacheDWRITE_MATRIXFields(env);
 224     lpStruct-&gt;m11 = env-&gt;GetFloatField(lpObject, DWRITE_MATRIXFc.m11);
 225     lpStruct-&gt;m12 = env-&gt;GetFloatField(lpObject, DWRITE_MATRIXFc.m12);
 226     lpStruct-&gt;m21 = env-&gt;GetFloatField(lpObject, DWRITE_MATRIXFc.m21);
 227     lpStruct-&gt;m22 = env-&gt;GetFloatField(lpObject, DWRITE_MATRIXFc.m22);
 228     lpStruct-&gt;dx = env-&gt;GetFloatField(lpObject, DWRITE_MATRIXFc.dx);
 229     lpStruct-&gt;dy = env-&gt;GetFloatField(lpObject, DWRITE_MATRIXFc.dy);
 230     return lpStruct;
 231 }
 232 
 233 void setDWRITE_MATRIXFields(JNIEnv *env, jobject lpObject, DWRITE_MATRIX *lpStruct)
 234 {
 235     if (!DWRITE_MATRIXFc.cached) cacheDWRITE_MATRIXFields(env);
 236     env-&gt;SetFloatField(lpObject, DWRITE_MATRIXFc.m11, (jfloat)lpStruct-&gt;m11);
 237     env-&gt;SetFloatField(lpObject, DWRITE_MATRIXFc.m12, (jfloat)lpStruct-&gt;m12);
 238     env-&gt;SetFloatField(lpObject, DWRITE_MATRIXFc.m21, (jfloat)lpStruct-&gt;m21);
 239     env-&gt;SetFloatField(lpObject, DWRITE_MATRIXFc.m22, (jfloat)lpStruct-&gt;m22);
 240     env-&gt;SetFloatField(lpObject, DWRITE_MATRIXFc.dx, (jfloat)lpStruct-&gt;dx);
 241     env-&gt;SetFloatField(lpObject, DWRITE_MATRIXFc.dy, (jfloat)lpStruct-&gt;dy);
 242 }
 243 
 244 jobject newDWRITE_MATRIX(JNIEnv *env, DWRITE_MATRIX *lpStruct)
 245 {
 246     jobject lpObject = NULL;
 247     if (!DWRITE_MATRIXFc.cached) cacheDWRITE_MATRIXFields(env);
 248     lpObject = env-&gt;NewObject(DWRITE_MATRIXFc.clazz, DWRITE_MATRIXFc.init);
 249     if (lpObject &amp;&amp; lpStruct) setDWRITE_MATRIXFields(env, lpObject, lpStruct);
 250     return lpObject;
 251 }
 252 
 253 typedef struct DWRITE_GLYPH_RUN_FID_CACHE {
 254     int cached;
 255     jclass clazz;
 256     jfieldID fontFace, fontEmSize, glyphIndices, glyphAdvances, advanceOffset, ascenderOffset, isSideways, bidiLevel;
 257     jmethodID init;
 258 } DWRITE_GLYPH_RUN_FID_CACHE;
 259 
 260 DWRITE_GLYPH_RUN_FID_CACHE DWRITE_GLYPH_RUNFc;
 261 
 262 void cacheDWRITE_GLYPH_RUNFields(JNIEnv *env)
 263 {
 264     if (DWRITE_GLYPH_RUNFc.cached) return;
 265     jclass tmpClass = env-&gt;FindClass(&quot;com/sun/javafx/font/directwrite/DWRITE_GLYPH_RUN&quot;);
 266     if (checkAndClearException(env) || !tmpClass) {
 267         fprintf(stderr, &quot;cacheDWRITE_GLYPH_RUNFields error: JNI exception or tmpClass == NULL&quot;);
 268         return;
 269     }
 270     DWRITE_GLYPH_RUNFc.clazz =  (jclass)env-&gt;NewGlobalRef(tmpClass);
 271     DWRITE_GLYPH_RUNFc.fontFace = env-&gt;GetFieldID(DWRITE_GLYPH_RUNFc.clazz, &quot;fontFace&quot;, &quot;J&quot;);
 272     if (checkAndClearException(env) || !DWRITE_GLYPH_RUNFc.fontFace) {
 273         fprintf(stderr, &quot;cacheDWRITE_GLYPH_RUNFields error: JNI exception or fontFace == NULL&quot;);
 274         return;
 275     }
 276     DWRITE_GLYPH_RUNFc.fontEmSize = env-&gt;GetFieldID(DWRITE_GLYPH_RUNFc.clazz, &quot;fontEmSize&quot;, &quot;F&quot;);
 277     if (checkAndClearException(env) || !DWRITE_GLYPH_RUNFc.fontEmSize) {
 278         fprintf(stderr, &quot;cacheDWRITE_GLYPH_RUNFields error: JNI exception or fontEmSize == NULL&quot;);
 279         return;
 280     }
 281     DWRITE_GLYPH_RUNFc.glyphIndices = env-&gt;GetFieldID(DWRITE_GLYPH_RUNFc.clazz, &quot;glyphIndices&quot;, &quot;S&quot;);
 282     if (checkAndClearException(env) || !DWRITE_GLYPH_RUNFc.glyphIndices) {
 283         fprintf(stderr, &quot;cacheDWRITE_GLYPH_RUNFields error: JNI exception or glyphIndices == NULL&quot;);
 284         return;
 285     }
 286     DWRITE_GLYPH_RUNFc.glyphAdvances = env-&gt;GetFieldID(DWRITE_GLYPH_RUNFc.clazz, &quot;glyphAdvances&quot;, &quot;F&quot;);
 287     if (checkAndClearException(env) || !DWRITE_GLYPH_RUNFc.glyphAdvances) {
 288         fprintf(stderr, &quot;cacheDWRITE_GLYPH_RUNFields error: JNI exception or glyphAdvances == NULL&quot;);
 289         return;
 290     }
 291     DWRITE_GLYPH_RUNFc.advanceOffset = env-&gt;GetFieldID(DWRITE_GLYPH_RUNFc.clazz, &quot;advanceOffset&quot;, &quot;F&quot;);
 292     if (checkAndClearException(env) || !DWRITE_GLYPH_RUNFc.advanceOffset) {
 293         fprintf(stderr, &quot;cacheDWRITE_GLYPH_RUNFields error: JNI exception or advanceOffset == NULL&quot;);
 294         return;
 295     }
 296     DWRITE_GLYPH_RUNFc.ascenderOffset = env-&gt;GetFieldID(DWRITE_GLYPH_RUNFc.clazz, &quot;ascenderOffset&quot;, &quot;F&quot;);
 297     if (checkAndClearException(env) || !DWRITE_GLYPH_RUNFc.ascenderOffset) {
 298         fprintf(stderr, &quot;cacheDWRITE_GLYPH_RUNFields error: JNI exception or ascenderOffset == NULL&quot;);
 299         return;
 300     }
 301     DWRITE_GLYPH_RUNFc.isSideways = env-&gt;GetFieldID(DWRITE_GLYPH_RUNFc.clazz, &quot;isSideways&quot;, &quot;Z&quot;);
 302     if (checkAndClearException(env) || !DWRITE_GLYPH_RUNFc.isSideways) {
 303         fprintf(stderr, &quot;cacheDWRITE_GLYPH_RUNFields error: JNI exception or isSideways == NULL&quot;);
 304         return;
 305     }
 306     DWRITE_GLYPH_RUNFc.bidiLevel = env-&gt;GetFieldID(DWRITE_GLYPH_RUNFc.clazz, &quot;bidiLevel&quot;, &quot;I&quot;);
 307     if (checkAndClearException(env) || !DWRITE_GLYPH_RUNFc.bidiLevel) {
 308         fprintf(stderr, &quot;cacheDWRITE_GLYPH_RUNFields error: JNI exception or bidiLevel == NULL&quot;);
 309         return;
 310     }
 311     DWRITE_GLYPH_RUNFc.init = env-&gt;GetMethodID(DWRITE_GLYPH_RUNFc.clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 312     if (checkAndClearException(env) || !DWRITE_GLYPH_RUNFc.init) {
 313         fprintf(stderr, &quot;cacheDWRITE_GLYPH_RUNFields error: JNI exception or &lt;init&gt; == NULL&quot;);
 314         return;
 315     }
 316     DWRITE_GLYPH_RUNFc.cached = 1;
 317 }
 318 
 319 DWRITE_GLYPH_RUN *getDWRITE_GLYPH_RUNFields(JNIEnv *env, jobject lpObject, DWRITE_GLYPH_RUN *lpStruct)
 320 {
 321     if (!DWRITE_GLYPH_RUNFc.cached) cacheDWRITE_GLYPH_RUNFields(env);
 322     lpStruct-&gt;fontFace = (IDWriteFontFace *)env-&gt;GetLongField(lpObject, DWRITE_GLYPH_RUNFc.fontFace);
 323     lpStruct-&gt;fontEmSize = env-&gt;GetFloatField(lpObject, DWRITE_GLYPH_RUNFc.fontEmSize);
 324     ((jshort*)lpStruct-&gt;glyphIndices)[0] = env-&gt;GetShortField(lpObject, DWRITE_GLYPH_RUNFc.glyphIndices);
 325     ((float*)lpStruct-&gt;glyphAdvances)[0] = env-&gt;GetFloatField(lpObject, DWRITE_GLYPH_RUNFc.glyphAdvances);
 326     ((float)lpStruct-&gt;glyphOffsets[0].advanceOffset) = env-&gt;GetFloatField(lpObject, DWRITE_GLYPH_RUNFc.advanceOffset);
 327     ((float)lpStruct-&gt;glyphOffsets[0].ascenderOffset) = env-&gt;GetFloatField(lpObject, DWRITE_GLYPH_RUNFc.ascenderOffset);
 328     lpStruct-&gt;isSideways = env-&gt;GetBooleanField(lpObject, DWRITE_GLYPH_RUNFc.isSideways);
 329     lpStruct-&gt;bidiLevel = env-&gt;GetIntField(lpObject, DWRITE_GLYPH_RUNFc.bidiLevel);
 330     return lpStruct;
 331 }
 332 
 333 typedef struct DWRITE_SCRIPT_ANALYSIS_FID_CACHE {
 334     int cached;
 335     jclass clazz;
 336     jfieldID script, shapes;
 337     jmethodID init;
 338 } DWRITE_SCRIPT_ANALYSIS_FID_CACHE;
 339 
 340 DWRITE_SCRIPT_ANALYSIS_FID_CACHE DWRITE_SCRIPT_ANALYSISFc;
 341 
 342 void cacheDWRITE_SCRIPT_ANALYSISFields(JNIEnv *env)
 343 {
 344     if (DWRITE_SCRIPT_ANALYSISFc.cached) return;
 345     jclass tmpClass = env-&gt;FindClass(&quot;com/sun/javafx/font/directwrite/DWRITE_SCRIPT_ANALYSIS&quot;);
 346     if (checkAndClearException(env) || !tmpClass) {
 347         fprintf(stderr, &quot;cacheDWRITE_SCRIPT_ANALYSISFields error: JNI exception or tmpClass == NULL&quot;);
 348         return;
 349     }
 350     DWRITE_SCRIPT_ANALYSISFc.clazz =  (jclass)env-&gt;NewGlobalRef(tmpClass);
 351     DWRITE_SCRIPT_ANALYSISFc.script = env-&gt;GetFieldID(DWRITE_SCRIPT_ANALYSISFc.clazz, &quot;script&quot;, &quot;S&quot;);
 352     if (checkAndClearException(env) || !DWRITE_SCRIPT_ANALYSISFc.script) {
 353         fprintf(stderr, &quot;cacheDWRITE_SCRIPT_ANALYSISFields error: JNI exception or script == NULL&quot;);
 354         return;
 355     }
 356     DWRITE_SCRIPT_ANALYSISFc.shapes = env-&gt;GetFieldID(DWRITE_SCRIPT_ANALYSISFc.clazz, &quot;shapes&quot;, &quot;I&quot;);
 357     if (checkAndClearException(env) || !DWRITE_SCRIPT_ANALYSISFc.shapes) {
 358         fprintf(stderr, &quot;cacheDWRITE_SCRIPT_ANALYSISFields error: JNI exception or shapes == NULL&quot;);
 359         return;
 360     }
 361     DWRITE_SCRIPT_ANALYSISFc.init = env-&gt;GetMethodID(DWRITE_SCRIPT_ANALYSISFc.clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 362     if (checkAndClearException(env) || !DWRITE_SCRIPT_ANALYSISFc.init) {
 363         fprintf(stderr, &quot;cacheDWRITE_SCRIPT_ANALYSISFields error: JNI exception or init == NULL&quot;);
 364         return;
 365     }
 366     DWRITE_SCRIPT_ANALYSISFc.cached = 1;
 367 }
 368 
 369 DWRITE_SCRIPT_ANALYSIS *getDWRITE_SCRIPT_ANALYSISFields(JNIEnv *env, jobject lpObject, DWRITE_SCRIPT_ANALYSIS *lpStruct)
 370 {
 371     if (!DWRITE_SCRIPT_ANALYSISFc.cached) cacheDWRITE_SCRIPT_ANALYSISFields(env);
 372     lpStruct-&gt;script = env-&gt;GetShortField(lpObject, DWRITE_SCRIPT_ANALYSISFc.script);
 373     lpStruct-&gt;shapes = (DWRITE_SCRIPT_SHAPES)env-&gt;GetIntField(lpObject, DWRITE_SCRIPT_ANALYSISFc.shapes);
 374     return lpStruct;
 375 }
 376 
 377 void setDWRITE_SCRIPT_ANALYSISFields(JNIEnv *env, jobject lpObject, DWRITE_SCRIPT_ANALYSIS *lpStruct)
 378 {
 379     if (!DWRITE_SCRIPT_ANALYSISFc.cached) cacheDWRITE_SCRIPT_ANALYSISFields(env);
 380     env-&gt;SetShortField(lpObject, DWRITE_SCRIPT_ANALYSISFc.script, (jshort)lpStruct-&gt;script);
 381     env-&gt;SetIntField(lpObject, DWRITE_SCRIPT_ANALYSISFc.shapes, (jint)lpStruct-&gt;shapes);
 382 }
 383 
 384 jobject newDWRITE_SCRIPT_ANALYSIS(JNIEnv *env, DWRITE_SCRIPT_ANALYSIS *lpStruct)
 385 {
 386     jobject lpObject = NULL;
 387     if (!DWRITE_SCRIPT_ANALYSISFc.cached) cacheDWRITE_SCRIPT_ANALYSISFields(env);
 388     lpObject = env-&gt;NewObject(DWRITE_SCRIPT_ANALYSISFc.clazz, DWRITE_SCRIPT_ANALYSISFc.init);
 389     if (lpObject &amp;&amp; lpStruct) setDWRITE_SCRIPT_ANALYSISFields(env, lpObject, lpStruct);
 390     return lpObject;
 391 }
 392 
 393 typedef struct RECT_FID_CACHE {
 394     int cached;
 395     jclass clazz;
 396     jfieldID left, top, right, bottom;
 397     jmethodID init;
 398 } RECT_FID_CACHE;
 399 
 400 RECT_FID_CACHE RECTFc;
 401 
 402 void cacheRECTFields(JNIEnv *env)
 403 {
 404     if (RECTFc.cached) return;
 405     jclass tmpClass = env-&gt;FindClass(&quot;com/sun/javafx/font/directwrite/RECT&quot;);
 406     if (checkAndClearException(env) || !tmpClass) {
 407         fprintf(stderr, &quot;cacheRECTFields error: JNI exception or tmpClass == NULL&quot;);
 408         return;
 409     }
 410     RECTFc.clazz =  (jclass)env-&gt;NewGlobalRef(tmpClass);
 411     RECTFc.left = env-&gt;GetFieldID(RECTFc.clazz, &quot;left&quot;, &quot;I&quot;);
 412     if (checkAndClearException(env) || !RECTFc.left) {
 413         fprintf(stderr, &quot;cacheRECTFields error: JNI exception or left == NULL&quot;);
 414         return;
 415     }
 416     RECTFc.top = env-&gt;GetFieldID(RECTFc.clazz, &quot;top&quot;, &quot;I&quot;);
 417     if (checkAndClearException(env) || !RECTFc.top) {
 418         fprintf(stderr, &quot;cacheRECTFields error: JNI exception or top == NULL&quot;);
 419         return;
 420     }
 421     RECTFc.right = env-&gt;GetFieldID(RECTFc.clazz, &quot;right&quot;, &quot;I&quot;);
 422     if (checkAndClearException(env) || !RECTFc.right) {
 423         fprintf(stderr, &quot;cacheRECTFields error: JNI exception or right == NULL&quot;);
 424         return;
 425     }
 426     RECTFc.bottom = env-&gt;GetFieldID(RECTFc.clazz, &quot;bottom&quot;, &quot;I&quot;);
 427     if (checkAndClearException(env) || !RECTFc.bottom) {
 428         fprintf(stderr, &quot;cacheRECTFields error: JNI exception or bottom == NULL&quot;);
 429         return;
 430     }
 431     RECTFc.init = env-&gt;GetMethodID(RECTFc.clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 432     if (checkAndClearException(env) || !RECTFc.init) {
 433         fprintf(stderr, &quot;cacheRECTFields error: JNI exception or init == NULL&quot;);
 434         return;
 435     }
 436     RECTFc.cached = 1;
 437 }
 438 
 439 RECT *getRECTFields(JNIEnv *env, jobject lpObject, RECT *lpStruct)
 440 {
 441     if (!RECTFc.cached) cacheRECTFields(env);
 442     lpStruct-&gt;left = env-&gt;GetIntField(lpObject, RECTFc.left);
 443     lpStruct-&gt;top = env-&gt;GetIntField(lpObject, RECTFc.top);
 444     lpStruct-&gt;right = env-&gt;GetIntField(lpObject, RECTFc.right);
 445     lpStruct-&gt;bottom = env-&gt;GetIntField(lpObject, RECTFc.bottom);
 446     return lpStruct;
 447 }
 448 
 449 void setRECTFields(JNIEnv *env, jobject lpObject, RECT *lpStruct)
 450 {
 451     if (!RECTFc.cached) cacheRECTFields(env);
 452     env-&gt;SetIntField(lpObject, RECTFc.left, (jint)lpStruct-&gt;left);
 453     env-&gt;SetIntField(lpObject, RECTFc.top, (jint)lpStruct-&gt;top);
 454     env-&gt;SetIntField(lpObject, RECTFc.right, (jint)lpStruct-&gt;right);
 455     env-&gt;SetIntField(lpObject, RECTFc.bottom, (jint)lpStruct-&gt;bottom);
 456 }
 457 
 458 jobject newRECT(JNIEnv *env, RECT *lpStruct)
 459 {
 460     jobject lpObject = NULL;
 461     if (!RECTFc.cached) cacheRECTFields(env);
 462     lpObject = env-&gt;NewObject(RECTFc.clazz, RECTFc.init);
 463     if (lpObject &amp;&amp; lpStruct) setRECTFields(env, lpObject, lpStruct);
 464     return lpObject;
 465 }
 466 
 467 typedef struct D2D1_PIXEL_FORMAT_FID_CACHE {
 468     int cached;
 469     jclass clazz;
 470     jfieldID format, alphaMode;
 471     jmethodID init;
 472 } D2D1_PIXEL_FORMAT_FID_CACHE;
 473 
 474 D2D1_PIXEL_FORMAT_FID_CACHE D2D1_PIXEL_FORMATFc;
 475 
 476 void cacheD2D1_PIXEL_FORMATFields(JNIEnv *env)
 477 {
 478     if (D2D1_PIXEL_FORMATFc.cached) return;
 479     jclass tmpClass = env-&gt;FindClass(&quot;com/sun/javafx/font/directwrite/D2D1_PIXEL_FORMAT&quot;);
 480     if (checkAndClearException(env) || !tmpClass) {
 481         fprintf(stderr, &quot;cacheD2D1_PIXEL_FORMATFields error: JNI exception or tmpClass == NULL&quot;);
 482         return;
 483     }
 484     D2D1_PIXEL_FORMATFc.clazz =  (jclass)env-&gt;NewGlobalRef(tmpClass);
 485     D2D1_PIXEL_FORMATFc.format = env-&gt;GetFieldID(D2D1_PIXEL_FORMATFc.clazz, &quot;format&quot;, &quot;I&quot;);
 486     if (checkAndClearException(env) || !D2D1_PIXEL_FORMATFc.format) {
 487         fprintf(stderr, &quot;cacheD2D1_PIXEL_FORMATFields error: JNI exception or format == NULL&quot;);
 488         return;
 489     }
 490     D2D1_PIXEL_FORMATFc.alphaMode = env-&gt;GetFieldID(D2D1_PIXEL_FORMATFc.clazz, &quot;alphaMode&quot;, &quot;I&quot;);
 491     if (checkAndClearException(env) || !D2D1_PIXEL_FORMATFc.alphaMode) {
 492         fprintf(stderr, &quot;cacheD2D1_PIXEL_FORMATFields error: JNI exception or alphaMode == NULL&quot;);
 493         return;
 494     }
 495     D2D1_PIXEL_FORMATFc.init = env-&gt;GetMethodID(D2D1_PIXEL_FORMATFc.clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 496     if (checkAndClearException(env) || !D2D1_PIXEL_FORMATFc.init) {
 497         fprintf(stderr, &quot;cacheD2D1_PIXEL_FORMATFields error: JNI exception or init == NULL&quot;);
 498         return;
 499     }
 500     D2D1_PIXEL_FORMATFc.cached = 1;
 501 }
 502 
 503 D2D1_PIXEL_FORMAT *getD2D1_PIXEL_FORMATFields(JNIEnv *env, jobject lpObject, D2D1_PIXEL_FORMAT *lpStruct)
 504 {
 505     if (!D2D1_PIXEL_FORMATFc.cached) cacheD2D1_PIXEL_FORMATFields(env);
 506     lpStruct-&gt;format = (DXGI_FORMAT)env-&gt;GetIntField(lpObject, D2D1_PIXEL_FORMATFc.format);
 507     lpStruct-&gt;alphaMode = (D2D1_ALPHA_MODE)env-&gt;GetIntField(lpObject, D2D1_PIXEL_FORMATFc.alphaMode);
 508     return lpStruct;
 509 }
 510 
 511 void setD2D1_PIXEL_FORMATFields(JNIEnv *env, jobject lpObject, D2D1_PIXEL_FORMAT *lpStruct)
 512 {
 513     if (!D2D1_PIXEL_FORMATFc.cached) cacheD2D1_PIXEL_FORMATFields(env);
 514     env-&gt;SetIntField(lpObject, D2D1_PIXEL_FORMATFc.format, (jint)lpStruct-&gt;format);
 515     env-&gt;SetIntField(lpObject, D2D1_PIXEL_FORMATFc.alphaMode, (jint)lpStruct-&gt;alphaMode);
 516 }
 517 
 518 jobject newD2D1_PIXEL_FORMAT(JNIEnv *env, D2D1_PIXEL_FORMAT *lpStruct)
 519 {
 520     jobject lpObject = NULL;
 521     if (!D2D1_PIXEL_FORMATFc.cached) cacheD2D1_PIXEL_FORMATFields(env);
 522     lpObject = env-&gt;NewObject(D2D1_PIXEL_FORMATFc.clazz, D2D1_PIXEL_FORMATFc.init);
 523     if (lpObject &amp;&amp; lpStruct) setD2D1_PIXEL_FORMATFields(env, lpObject, lpStruct);
 524     return lpObject;
 525 }
 526 
 527 typedef struct D2D1_RENDER_TARGET_PROPERTIES_FID_CACHE {
 528     int cached;
 529     jclass clazz;
 530     jfieldID type, pixelFormat, dpiX, dpiY, usage, minLevel;
 531     jmethodID init;
 532 } D2D1_RENDER_TARGET_PROPERTIES_FID_CACHE;
 533 
 534 D2D1_RENDER_TARGET_PROPERTIES_FID_CACHE D2D1_RENDER_TARGET_PROPERTIESFc;
 535 
 536 void cacheD2D1_RENDER_TARGET_PROPERTIESFields(JNIEnv *env)
 537 {
 538     if (D2D1_RENDER_TARGET_PROPERTIESFc.cached) return;
 539     jclass tmpClass = env-&gt;FindClass(&quot;com/sun/javafx/font/directwrite/D2D1_RENDER_TARGET_PROPERTIES&quot;);
 540     if (checkAndClearException(env) || !tmpClass) {
 541         fprintf(stderr, &quot;cacheD2D1_RENDER_TARGET_PROPERTIESFields error: JNI exception or tmpClass == NULL&quot;);
 542         return;
 543     }
 544     D2D1_RENDER_TARGET_PROPERTIESFc.clazz =  (jclass)env-&gt;NewGlobalRef(tmpClass);
 545     D2D1_RENDER_TARGET_PROPERTIESFc.type = env-&gt;GetFieldID(D2D1_RENDER_TARGET_PROPERTIESFc.clazz, &quot;type&quot;, &quot;I&quot;);
 546     if (checkAndClearException(env) || !D2D1_RENDER_TARGET_PROPERTIESFc.type) {
 547         fprintf(stderr, &quot;cacheD2D1_RENDER_TARGET_PROPERTIESFields error: JNI exception or type == NULL&quot;);
 548         return;
 549     }
 550     D2D1_RENDER_TARGET_PROPERTIESFc.pixelFormat = env-&gt;GetFieldID(D2D1_RENDER_TARGET_PROPERTIESFc.clazz, &quot;pixelFormat&quot;, &quot;Lcom/sun/javafx/font/directwrite/D2D1_PIXEL_FORMAT;&quot;);
 551     if (checkAndClearException(env) || !D2D1_RENDER_TARGET_PROPERTIESFc.pixelFormat) {
 552         fprintf(stderr, &quot;cacheD2D1_RENDER_TARGET_PROPERTIESFields error: JNI exception or pixelFormat == NULL&quot;);
 553         return;
 554     }
 555     D2D1_RENDER_TARGET_PROPERTIESFc.dpiX = env-&gt;GetFieldID(D2D1_RENDER_TARGET_PROPERTIESFc.clazz, &quot;dpiX&quot;, &quot;F&quot;);
 556     if (checkAndClearException(env) || !D2D1_RENDER_TARGET_PROPERTIESFc.dpiX) {
 557         fprintf(stderr, &quot;cacheD2D1_RENDER_TARGET_PROPERTIESFields error: JNI exception or dpiX == NULL&quot;);
 558         return;
 559     }
 560     D2D1_RENDER_TARGET_PROPERTIESFc.dpiY = env-&gt;GetFieldID(D2D1_RENDER_TARGET_PROPERTIESFc.clazz, &quot;dpiY&quot;, &quot;F&quot;);
 561     if (checkAndClearException(env) || !D2D1_RENDER_TARGET_PROPERTIESFc.dpiY) {
 562         fprintf(stderr, &quot;cacheD2D1_RENDER_TARGET_PROPERTIESFields error: JNI exception or dpiY == NULL&quot;);
 563         return;
 564     }
 565     D2D1_RENDER_TARGET_PROPERTIESFc.usage = env-&gt;GetFieldID(D2D1_RENDER_TARGET_PROPERTIESFc.clazz, &quot;usage&quot;, &quot;I&quot;);
 566     if (checkAndClearException(env) || !D2D1_RENDER_TARGET_PROPERTIESFc.usage) {
 567         fprintf(stderr, &quot;cacheD2D1_RENDER_TARGET_PROPERTIESFields error: JNI exception or usage == NULL&quot;);
 568         return;
 569     }
 570     D2D1_RENDER_TARGET_PROPERTIESFc.minLevel = env-&gt;GetFieldID(D2D1_RENDER_TARGET_PROPERTIESFc.clazz, &quot;minLevel&quot;, &quot;I&quot;);
 571     if (checkAndClearException(env) || !D2D1_RENDER_TARGET_PROPERTIESFc.minLevel) {
 572         fprintf(stderr, &quot;cacheD2D1_RENDER_TARGET_PROPERTIESFields error: JNI exception or minLevel == NULL&quot;);
 573         return;
 574     }
 575     D2D1_RENDER_TARGET_PROPERTIESFc.init = env-&gt;GetMethodID(D2D1_RENDER_TARGET_PROPERTIESFc.clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 576     if (checkAndClearException(env) || !D2D1_RENDER_TARGET_PROPERTIESFc.init) {
 577         fprintf(stderr, &quot;cacheD2D1_RENDER_TARGET_PROPERTIESFields error: JNI exception or init == NULL&quot;);
 578         return;
 579     }
 580     D2D1_RENDER_TARGET_PROPERTIESFc.cached = 1;
 581 }
 582 
 583 D2D1_RENDER_TARGET_PROPERTIES *getD2D1_RENDER_TARGET_PROPERTIESFields(JNIEnv *env, jobject lpObject, D2D1_RENDER_TARGET_PROPERTIES *lpStruct)
 584 {
 585     if (!D2D1_RENDER_TARGET_PROPERTIESFc.cached) cacheD2D1_RENDER_TARGET_PROPERTIESFields(env);
 586     lpStruct-&gt;type = (D2D1_RENDER_TARGET_TYPE)env-&gt;GetIntField(lpObject, D2D1_RENDER_TARGET_PROPERTIESFc.type);
 587     {
 588     jobject lpObject1 = env-&gt;GetObjectField(lpObject, D2D1_RENDER_TARGET_PROPERTIESFc.pixelFormat);
 589     if (lpObject1 != NULL) getD2D1_PIXEL_FORMATFields(env, lpObject1, &amp;lpStruct-&gt;pixelFormat);
 590     }
 591     lpStruct-&gt;dpiX = env-&gt;GetFloatField(lpObject, D2D1_RENDER_TARGET_PROPERTIESFc.dpiX);
 592     lpStruct-&gt;dpiY = env-&gt;GetFloatField(lpObject, D2D1_RENDER_TARGET_PROPERTIESFc.dpiY);
 593     lpStruct-&gt;usage = (D2D1_RENDER_TARGET_USAGE)env-&gt;GetIntField(lpObject, D2D1_RENDER_TARGET_PROPERTIESFc.usage);
 594     lpStruct-&gt;minLevel = (D2D1_FEATURE_LEVEL)env-&gt;GetIntField(lpObject, D2D1_RENDER_TARGET_PROPERTIESFc.minLevel);
 595     return lpStruct;
 596 }
 597 
 598 void setD2D1_RENDER_TARGET_PROPERTIESFields(JNIEnv *env, jobject lpObject, D2D1_RENDER_TARGET_PROPERTIES *lpStruct)
 599 {
 600     if (!D2D1_RENDER_TARGET_PROPERTIESFc.cached) cacheD2D1_RENDER_TARGET_PROPERTIESFields(env);
 601     env-&gt;SetIntField(lpObject, D2D1_RENDER_TARGET_PROPERTIESFc.type, (jint)lpStruct-&gt;type);
 602     {
 603     jobject lpObject1 = env-&gt;GetObjectField(lpObject, D2D1_RENDER_TARGET_PROPERTIESFc.pixelFormat);
 604     if (lpObject1 != NULL) setD2D1_PIXEL_FORMATFields(env, lpObject1, &amp;lpStruct-&gt;pixelFormat);
 605     }
 606     env-&gt;SetFloatField(lpObject, D2D1_RENDER_TARGET_PROPERTIESFc.dpiX, (jfloat)lpStruct-&gt;dpiX);
 607     env-&gt;SetFloatField(lpObject, D2D1_RENDER_TARGET_PROPERTIESFc.dpiY, (jfloat)lpStruct-&gt;dpiY);
 608     env-&gt;SetIntField(lpObject, D2D1_RENDER_TARGET_PROPERTIESFc.usage, (jint)lpStruct-&gt;usage);
 609     env-&gt;SetIntField(lpObject, D2D1_RENDER_TARGET_PROPERTIESFc.minLevel, (jint)lpStruct-&gt;minLevel);
 610 }
 611 
 612 jobject newD2D1_RENDER_TARGET_PROPERTIES(JNIEnv *env, D2D1_RENDER_TARGET_PROPERTIES *lpStruct)
 613 {
 614     jobject lpObject = NULL;
 615     if (!D2D1_RENDER_TARGET_PROPERTIESFc.cached) cacheD2D1_RENDER_TARGET_PROPERTIESFields(env);
 616     lpObject = env-&gt;NewObject(D2D1_RENDER_TARGET_PROPERTIESFc.clazz, D2D1_RENDER_TARGET_PROPERTIESFc.init);
 617     if (lpObject &amp;&amp; lpStruct) setD2D1_RENDER_TARGET_PROPERTIESFields(env, lpObject, lpStruct);
 618     return lpObject;
 619 }
 620 
 621 typedef struct D2D1_COLOR_F_FID_CACHE {
 622     int cached;
 623     jclass clazz;
 624     jfieldID r, g, b, a;
 625     jmethodID init;
 626 } D2D1_COLOR_F_FID_CACHE;
 627 
 628 D2D1_COLOR_F_FID_CACHE D2D1_COLOR_FFc;
 629 
 630 void cacheD2D1_COLOR_FFields(JNIEnv *env)
 631 {
 632     if (D2D1_COLOR_FFc.cached) return;
 633     jclass tmpClass = env-&gt;FindClass(&quot;com/sun/javafx/font/directwrite/D2D1_COLOR_F&quot;);
 634     if (checkAndClearException(env) || !tmpClass) {
 635         fprintf(stderr, &quot;cacheD2D1_COLOR_FFields error: JNI exception or tmpClass == NULL&quot;);
 636         return;
 637     }
 638     D2D1_COLOR_FFc.clazz =  (jclass)env-&gt;NewGlobalRef(tmpClass);
 639     D2D1_COLOR_FFc.r = env-&gt;GetFieldID(D2D1_COLOR_FFc.clazz, &quot;r&quot;, &quot;F&quot;);
 640     if (checkAndClearException(env) || !D2D1_COLOR_FFc.r) {
 641         fprintf(stderr, &quot;cacheD2D1_COLOR_FFields error: JNI exception or r == NULL&quot;);
 642         return;
 643     }
 644     D2D1_COLOR_FFc.g = env-&gt;GetFieldID(D2D1_COLOR_FFc.clazz, &quot;g&quot;, &quot;F&quot;);
 645     if (checkAndClearException(env) || !D2D1_COLOR_FFc.g) {
 646         fprintf(stderr, &quot;cacheD2D1_COLOR_FFields error: JNI exception or g == NULL&quot;);
 647         return;
 648     }
 649     D2D1_COLOR_FFc.b = env-&gt;GetFieldID(D2D1_COLOR_FFc.clazz, &quot;b&quot;, &quot;F&quot;);
 650     if (checkAndClearException(env) || !D2D1_COLOR_FFc.b) {
 651         fprintf(stderr, &quot;cacheD2D1_COLOR_FFields error: JNI exception or b == NULL&quot;);
 652         return;
 653     }
 654     D2D1_COLOR_FFc.a = env-&gt;GetFieldID(D2D1_COLOR_FFc.clazz, &quot;a&quot;, &quot;F&quot;);
 655     if (checkAndClearException(env) || !D2D1_COLOR_FFc.a) {
 656         fprintf(stderr, &quot;cacheD2D1_COLOR_FFields error: JNI exception or a == NULL&quot;);
 657         return;
 658     }
 659     D2D1_COLOR_FFc.init = env-&gt;GetMethodID(D2D1_COLOR_FFc.clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 660     if (checkAndClearException(env) || !D2D1_COLOR_FFc.init) {
 661         fprintf(stderr, &quot;cacheD2D1_COLOR_FFields error: JNI exception or init == NULL&quot;);
 662         return;
 663     }
 664     D2D1_COLOR_FFc.cached = 1;
 665 }
 666 
 667 D2D1_COLOR_F *getD2D1_COLOR_FFields(JNIEnv *env, jobject lpObject, D2D1_COLOR_F *lpStruct)
 668 {
 669     if (!D2D1_COLOR_FFc.cached) cacheD2D1_COLOR_FFields(env);
 670     lpStruct-&gt;r = env-&gt;GetFloatField(lpObject, D2D1_COLOR_FFc.r);
 671     lpStruct-&gt;g = env-&gt;GetFloatField(lpObject, D2D1_COLOR_FFc.g);
 672     lpStruct-&gt;b = env-&gt;GetFloatField(lpObject, D2D1_COLOR_FFc.b);
 673     lpStruct-&gt;a = env-&gt;GetFloatField(lpObject, D2D1_COLOR_FFc.a);
 674     return lpStruct;
 675 }
 676 
 677 void setD2D1_COLOR_FFields(JNIEnv *env, jobject lpObject, D2D1_COLOR_F *lpStruct)
 678 {
 679     if (!D2D1_COLOR_FFc.cached) cacheD2D1_COLOR_FFields(env);
 680     env-&gt;SetFloatField(lpObject, D2D1_COLOR_FFc.r, (jfloat)lpStruct-&gt;r);
 681     env-&gt;SetFloatField(lpObject, D2D1_COLOR_FFc.g, (jfloat)lpStruct-&gt;g);
 682     env-&gt;SetFloatField(lpObject, D2D1_COLOR_FFc.b, (jfloat)lpStruct-&gt;b);
 683     env-&gt;SetFloatField(lpObject, D2D1_COLOR_FFc.a, (jfloat)lpStruct-&gt;a);
 684 }
 685 
 686 jobject newD2D1_COLOR_F(JNIEnv *env, D2D1_COLOR_F *lpStruct)
 687 {
 688     jobject lpObject = NULL;
 689     if (!D2D1_COLOR_FFc.cached) cacheD2D1_COLOR_FFields(env);
 690     lpObject = env-&gt;NewObject(D2D1_COLOR_FFc.clazz, D2D1_COLOR_FFc.init);
 691     if (lpObject &amp;&amp; lpStruct) setD2D1_COLOR_FFields(env, lpObject, lpStruct);
 692     return lpObject;
 693 }
 694 
 695 typedef struct D2D1_POINT_2F_FID_CACHE {
 696     int cached;
 697     jclass clazz;
 698     jfieldID x, y;
 699     jmethodID init;
 700 } D2D1_POINT_2F_FID_CACHE;
 701 
 702 D2D1_POINT_2F_FID_CACHE D2D1_POINT_2FFc;
 703 
 704 void cacheD2D1_POINT_2FFields(JNIEnv *env)
 705 {
 706     if (D2D1_POINT_2FFc.cached) return;
 707     jclass tmpClass = env-&gt;FindClass(&quot;com/sun/javafx/font/directwrite/D2D1_POINT_2F&quot;);
 708     if (checkAndClearException(env) || !tmpClass) {
 709         fprintf(stderr, &quot;cacheD2D1_POINT_2FFields error: JNI exception or tmpClass == NULL&quot;);
 710         return;
 711     }
 712     D2D1_POINT_2FFc.clazz =  (jclass)env-&gt;NewGlobalRef(tmpClass);
 713     D2D1_POINT_2FFc.x = env-&gt;GetFieldID(D2D1_POINT_2FFc.clazz, &quot;x&quot;, &quot;F&quot;);
 714     if (checkAndClearException(env) || !D2D1_POINT_2FFc.x) {
 715         fprintf(stderr, &quot;cacheD2D1_POINT_2FFields error: JNI exception or x == NULL&quot;);
 716         return;
 717     }
 718     D2D1_POINT_2FFc.y = env-&gt;GetFieldID(D2D1_POINT_2FFc.clazz, &quot;y&quot;, &quot;F&quot;);
 719     if (checkAndClearException(env) || !D2D1_POINT_2FFc.y) {
 720         fprintf(stderr, &quot;cacheD2D1_POINT_2FFields error: JNI exception or y == NULL&quot;);
 721         return;
 722     }
 723     D2D1_POINT_2FFc.init = env-&gt;GetMethodID(D2D1_POINT_2FFc.clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 724     if (checkAndClearException(env) || !D2D1_POINT_2FFc.init) {
 725         fprintf(stderr, &quot;cacheD2D1_POINT_2FFields error: JNI exception or init == NULL&quot;);
 726         return;
 727     }
 728     D2D1_POINT_2FFc.cached = 1;
 729 }
 730 
 731 D2D1_POINT_2F *getD2D1_POINT_2FFields(JNIEnv *env, jobject lpObject, D2D1_POINT_2F *lpStruct)
 732 {
 733     if (!D2D1_POINT_2FFc.cached) cacheD2D1_POINT_2FFields(env);
 734     lpStruct-&gt;x = env-&gt;GetFloatField(lpObject, D2D1_POINT_2FFc.x);
 735     lpStruct-&gt;y = env-&gt;GetFloatField(lpObject, D2D1_POINT_2FFc.y);
 736     return lpStruct;
 737 }
 738 
 739 void setD2D1_POINT_2FFields(JNIEnv *env, jobject lpObject, D2D1_POINT_2F *lpStruct)
 740 {
 741     if (!D2D1_POINT_2FFc.cached) cacheD2D1_POINT_2FFields(env);
 742     env-&gt;SetFloatField(lpObject, D2D1_POINT_2FFc.x, (jfloat)lpStruct-&gt;x);
 743     env-&gt;SetFloatField(lpObject, D2D1_POINT_2FFc.y, (jfloat)lpStruct-&gt;y);
 744 }
 745 
 746 jobject newD2D1_POINT_2F(JNIEnv *env, D2D1_POINT_2F *lpStruct)
 747 {
 748     jobject lpObject = NULL;
 749     if (!D2D1_POINT_2FFc.cached) cacheD2D1_POINT_2FFields(env);
 750     lpObject = env-&gt;NewObject(D2D1_POINT_2FFc.clazz, D2D1_POINT_2FFc.init);
 751     if (lpObject &amp;&amp; lpStruct) setD2D1_POINT_2FFields(env, lpObject, lpStruct);
 752     return lpObject;
 753 }
 754 
 755 typedef struct D2D1_MATRIX_3X2_F_FID_CACHE {
 756     int cached;
 757     jclass clazz;
 758     jfieldID _11, _12, _21, _22, _31, _32;
 759     jmethodID init;
 760 } D2D1_MATRIX_3X2_F_FID_CACHE;
 761 
 762 D2D1_MATRIX_3X2_F_FID_CACHE D2D1_MATRIX_3X2_FFc;
 763 
 764 void cacheD2D1_MATRIX_3X2_FFields(JNIEnv *env)
 765 {
 766     if (D2D1_MATRIX_3X2_FFc.cached) return;
 767     jclass tmpClass = env-&gt;FindClass(&quot;com/sun/javafx/font/directwrite/D2D1_MATRIX_3X2_F&quot;);
 768     if (checkAndClearException(env) || !tmpClass) {
 769         fprintf(stderr, &quot;cacheD2D1_MATRIX_3X2_FFields error: JNI exception or tmpClass == NULL&quot;);
 770         return;
 771     }
 772     D2D1_MATRIX_3X2_FFc.clazz =  (jclass)env-&gt;NewGlobalRef(tmpClass);
 773     D2D1_MATRIX_3X2_FFc._11 = env-&gt;GetFieldID(D2D1_MATRIX_3X2_FFc.clazz, &quot;_11&quot;, &quot;F&quot;);
 774     if (checkAndClearException(env) || !D2D1_MATRIX_3X2_FFc._11) {
 775         fprintf(stderr, &quot;cacheD2D1_MATRIX_3X2_FFields error: JNI exception or _11 == NULL&quot;);
 776         return;
 777     }
 778     D2D1_MATRIX_3X2_FFc._12 = env-&gt;GetFieldID(D2D1_MATRIX_3X2_FFc.clazz, &quot;_12&quot;, &quot;F&quot;);
 779     if (checkAndClearException(env) || !D2D1_MATRIX_3X2_FFc._12) {
 780         fprintf(stderr, &quot;cacheD2D1_MATRIX_3X2_FFields error: JNI exception or _12 == NULL&quot;);
 781         return;
 782     }
 783     D2D1_MATRIX_3X2_FFc._21 = env-&gt;GetFieldID(D2D1_MATRIX_3X2_FFc.clazz, &quot;_21&quot;, &quot;F&quot;);
 784     if (checkAndClearException(env) || !D2D1_MATRIX_3X2_FFc._21) {
 785         fprintf(stderr, &quot;cacheD2D1_MATRIX_3X2_FFields error: JNI exception or _21 == NULL&quot;);
 786         return;
 787     }
 788     D2D1_MATRIX_3X2_FFc._22 = env-&gt;GetFieldID(D2D1_MATRIX_3X2_FFc.clazz, &quot;_22&quot;, &quot;F&quot;);
 789     if (checkAndClearException(env) || !D2D1_MATRIX_3X2_FFc._22) {
 790         fprintf(stderr, &quot;cacheD2D1_MATRIX_3X2_FFields error: JNI exception or _22 == NULL&quot;);
 791         return;
 792     }
 793     D2D1_MATRIX_3X2_FFc._31 = env-&gt;GetFieldID(D2D1_MATRIX_3X2_FFc.clazz, &quot;_31&quot;, &quot;F&quot;);
 794     if (checkAndClearException(env) || !D2D1_MATRIX_3X2_FFc._31) {
 795         fprintf(stderr, &quot;cacheD2D1_MATRIX_3X2_FFields error: JNI exception or _31 == NULL&quot;);
 796         return;
 797     }
 798     D2D1_MATRIX_3X2_FFc._32 = env-&gt;GetFieldID(D2D1_MATRIX_3X2_FFc.clazz, &quot;_32&quot;, &quot;F&quot;);
 799     if (checkAndClearException(env) || !D2D1_MATRIX_3X2_FFc._32) {
 800         fprintf(stderr, &quot;cacheD2D1_MATRIX_3X2_FFields error: JNI exception or _32 == NULL&quot;);
 801         return;
 802     }
 803     D2D1_MATRIX_3X2_FFc.init = env-&gt;GetMethodID(D2D1_MATRIX_3X2_FFc.clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 804     if (checkAndClearException(env) || !D2D1_MATRIX_3X2_FFc.init) {
 805         fprintf(stderr, &quot;cacheD2D1_MATRIX_3X2_FFields error: JNI exception or init == NULL&quot;);
 806         return;
 807     }
 808     D2D1_MATRIX_3X2_FFc.cached = 1;
 809 }
 810 
 811 D2D1_MATRIX_3X2_F *getD2D1_MATRIX_3X2_FFields(JNIEnv *env, jobject lpObject, D2D1_MATRIX_3X2_F *lpStruct)
 812 {
 813     if (!D2D1_MATRIX_3X2_FFc.cached) cacheD2D1_MATRIX_3X2_FFields(env);
 814     lpStruct-&gt;_11 = env-&gt;GetFloatField(lpObject, D2D1_MATRIX_3X2_FFc._11);
 815     lpStruct-&gt;_12 = env-&gt;GetFloatField(lpObject, D2D1_MATRIX_3X2_FFc._12);
 816     lpStruct-&gt;_21 = env-&gt;GetFloatField(lpObject, D2D1_MATRIX_3X2_FFc._21);
 817     lpStruct-&gt;_22 = env-&gt;GetFloatField(lpObject, D2D1_MATRIX_3X2_FFc._22);
 818     lpStruct-&gt;_31 = env-&gt;GetFloatField(lpObject, D2D1_MATRIX_3X2_FFc._31);
 819     lpStruct-&gt;_32 = env-&gt;GetFloatField(lpObject, D2D1_MATRIX_3X2_FFc._32);
 820     return lpStruct;
 821 }
 822 
 823 void setD2D1_MATRIX_3X2_FFields(JNIEnv *env, jobject lpObject, D2D1_MATRIX_3X2_F *lpStruct)
 824 {
 825     if (!D2D1_MATRIX_3X2_FFc.cached) cacheD2D1_MATRIX_3X2_FFields(env);
 826     env-&gt;SetFloatField(lpObject, D2D1_MATRIX_3X2_FFc._11, (jfloat)lpStruct-&gt;_11);
 827     env-&gt;SetFloatField(lpObject, D2D1_MATRIX_3X2_FFc._12, (jfloat)lpStruct-&gt;_12);
 828     env-&gt;SetFloatField(lpObject, D2D1_MATRIX_3X2_FFc._21, (jfloat)lpStruct-&gt;_21);
 829     env-&gt;SetFloatField(lpObject, D2D1_MATRIX_3X2_FFc._22, (jfloat)lpStruct-&gt;_22);
 830     env-&gt;SetFloatField(lpObject, D2D1_MATRIX_3X2_FFc._31, (jfloat)lpStruct-&gt;_31);
 831     env-&gt;SetFloatField(lpObject, D2D1_MATRIX_3X2_FFc._32, (jfloat)lpStruct-&gt;_32);
 832 }
 833 
 834 jobject newD2D1_MATRIX_3X2_F(JNIEnv *env, D2D1_MATRIX_3X2_F *lpStruct)
 835 {
 836     jobject lpObject = NULL;
 837     if (!D2D1_MATRIX_3X2_FFc.cached) cacheD2D1_MATRIX_3X2_FFields(env);
 838     lpObject = env-&gt;NewObject(D2D1_MATRIX_3X2_FFc.clazz, D2D1_MATRIX_3X2_FFc.init);
 839     if (lpObject &amp;&amp; lpStruct) setD2D1_MATRIX_3X2_FFields(env, lpObject, lpStruct);
 840     return lpObject;
 841 }
 842 /**************************************************************************/
 843 /*                                                                        */
 844 /*                            Functions                                   */
 845 /*                                                                        */
 846 /**************************************************************************/
 847 
 848 JNIEXPORT jboolean JNICALL OS_NATIVE(CoInitializeEx)
 849     (JNIEnv *env, jclass that, jint arg0)
 850 {
 851     HRESULT hr = CoInitializeEx(NULL, (DWORD)arg0);
 852 
 853     /* This means COM has been initialized with a different concurrency model.
 854      * This should never happen. */
 855     if (hr == RPC_E_CHANGED_MODE) return JNI_FALSE;
 856 
 857     return JNI_TRUE;
 858 }
 859 
 860 JNIEXPORT void JNICALL OS_NATIVE(CoUninitialize)
 861     (JNIEnv *env, jclass that)
 862 {
 863     CoUninitialize();
 864 }
 865 
 866 JNIEXPORT jlong JNICALL OS_NATIVE(_1WICCreateImagingFactory)
 867     (JNIEnv *env, jclass that)
 868 {
 869     IWICImagingFactory* result = NULL;
 870     HRESULT hr = CoCreateInstance(
 871             CLSID_WICImagingFactory,
 872             NULL,
 873             CLSCTX_INPROC_SERVER,
 874             IID_PPV_ARGS(&amp;result)
 875             );
 876 
 877     return SUCCEEDED(hr) ? (jlong)result : NULL;
 878 }
 879 
 880 JNIEXPORT jlong JNICALL OS_NATIVE(_1D2D1CreateFactory)
 881     (JNIEnv *env, jclass that, jint arg0)
 882 {
 883     HRESULT hr = E_FAIL;
 884     ID2D1Factory* result = NULL;
 885     HMODULE module = LoadLibrary(TEXT(&quot;d2d1.dll&quot;));
 886     D2D1CreateFactoryProc createProc = NULL;
 887     if (module) {
 888         createProc = (D2D1CreateFactoryProc)GetProcAddress(module, &quot;D2D1CreateFactory&quot;);
 889     }
 890     if (createProc) {
 891         D2D1_FACTORY_OPTIONS options;
 892         options.debugLevel = D2D1_DEBUG_LEVEL_NONE;
 893         hr = createProc((D2D1_FACTORY_TYPE)arg0,
 894                         __uuidof(ID2D1Factory),
 895                         &amp;options,
 896                         reinterpret_cast&lt;void**&gt;(&amp;result));
 897     }
 898     return SUCCEEDED(hr) ? (jlong)result : NULL;
 899 }
 900 
 901 JNIEXPORT jlong JNICALL OS_NATIVE(_1DWriteCreateFactory)
 902     (JNIEnv *env, jclass that, jint arg0)
 903 {
 904     HRESULT hr = E_FAIL;
 905     IDWriteFactory* result = NULL;
 906     HMODULE module = LoadLibrary(TEXT(&quot;dwrite.dll&quot;));
 907     DWriteCreateFactoryProc createProc = NULL;
 908     if (module) {
 909         createProc = (DWriteCreateFactoryProc)GetProcAddress(module, &quot;DWriteCreateFactory&quot;);
 910     }
 911     if (createProc) {
 912         hr = createProc((DWRITE_FACTORY_TYPE)arg0,
 913                         __uuidof(IDWriteFactory),
 914                         reinterpret_cast&lt;IUnknown**&gt;(&amp;result));
 915     }
 916     return SUCCEEDED(hr) ? (jlong)result : NULL;
 917 }
 918 
 919 /* IUnknown */
 920 JNIEXPORT jint JNICALL OS_NATIVE(AddRef)
 921     (JNIEnv *env, jclass that, jlong arg0)
 922 {
 923     return ((IUnknown *)arg0)-&gt;AddRef();
 924 }
 925 
 926 JNIEXPORT jint JNICALL OS_NATIVE(Release)
 927     (JNIEnv *env, jclass that, jlong arg0)
 928 {
 929     return ((IUnknown *)arg0)-&gt;Release();
 930 }
 931 
 932 /***********************************************/
 933 /*         Text Source and Sink                */
 934 /***********************************************/
 935 
 936 class JFXTextAnalysisSink : public IDWriteTextAnalysisSink, public IDWriteTextAnalysisSource {
 937 public:
 938     JFXTextAnalysisSink(
 939         JNIEnv *env,
 940         jcharArray text,
 941         jint start,
 942         jint length,
 943         jcharArray locale,
 944         jint direction,
 945         jlong numberSubstitution
 946     );
 947     ~JFXTextAnalysisSink();
 948 
 949 /* IDWriteTextAnalysisSink */
 950 public:
 951     IFACEMETHOD (SetScriptAnalysis) (
 952         UINT32 textPosition,
 953         UINT32 textLength,
 954         DWRITE_SCRIPT_ANALYSIS const* scriptAnalysis);
 955 
 956     IFACEMETHOD (SetLineBreakpoints) (
 957         UINT32 textPosition,
 958         UINT32 textLength,
 959         const DWRITE_LINE_BREAKPOINT* lineBreakpoints);
 960 
 961     IFACEMETHOD (SetBidiLevel) (
 962         UINT32 textPosition,
 963         UINT32 textLength,
 964         UINT8 explicitLevel,
 965         UINT8 resolvedLevel);
 966 
 967     IFACEMETHOD (SetNumberSubstitution) (
 968         UINT32 textPosition,
 969         UINT32 textLength,
 970         IDWriteNumberSubstitution* numberSubstitution);
 971 
 972 /* IDWriteTextAnalysisSource */
 973     IFACEMETHOD (GetTextAtPosition) (
 974         UINT32 textPosition,
 975         OUT WCHAR const** textString,
 976         OUT UINT32* textLength);
 977 
 978     IFACEMETHOD (GetTextBeforePosition) (
 979         UINT32 textPosition,
 980         OUT WCHAR const** textString,
 981         OUT UINT32* textLength);
 982 
 983     IFACEMETHOD_(DWRITE_READING_DIRECTION, GetParagraphReadingDirection) ();
 984 
 985     IFACEMETHOD (GetLocaleName) (
 986         UINT32 textPosition,
 987         OUT UINT32* textLength,
 988         OUT WCHAR const** localeName);
 989 
 990     IFACEMETHOD (GetNumberSubstitution) (
 991         UINT32 textPosition,
 992         OUT UINT32* textLength,
 993         OUT IDWriteNumberSubstitution** numberSubstitution);
 994 
 995 /* IUnknown */
 996 public:
 997     IFACEMETHOD_(ULONG, AddRef) ();
 998     IFACEMETHOD_(ULONG,  Release) ();
 999     IFACEMETHOD(QueryInterface) (
1000                 IID const&amp; riid,
1001                 void** ppvObject);
1002 
1003 public:
1004     BOOL Next();
1005     UINT32 GetStart();
1006     UINT32 GetLength();
1007     DWRITE_SCRIPT_ANALYSIS* GetAnalysis();
1008 
1009 private:
1010     struct Run {
1011         UINT32 start;
1012         UINT32 length;
1013         DWRITE_SCRIPT_ANALYSIS analysis;
1014     };
1015     ULONG cRefCount_;
1016     UINT32 textLength_;
1017     const WCHAR* text_;
1018     const WCHAR* locale_;
1019     IDWriteNumberSubstitution* numberSubstitution_;
1020     DWRITE_READING_DIRECTION readingDirection_;
1021     std::vector&lt;Run&gt; runs_;
1022     INT32 position_;
1023 };
1024 
1025 JFXTextAnalysisSink::JFXTextAnalysisSink(
1026         JNIEnv *env,
1027         jcharArray text,
1028         jint start,
1029         jint length,
1030         jcharArray locale,
1031         jint direction,
1032         jlong numberSubstitution
1033     )
1034 :   cRefCount_(0),
1035     position_(-1),
1036     textLength_(length),
1037     numberSubstitution_((IDWriteNumberSubstitution*)numberSubstitution),
1038     readingDirection_((DWRITE_READING_DIRECTION)direction)
1039 {
1040     text_ = new (std::nothrow) WCHAR [textLength_];
1041     env-&gt;GetCharArrayRegion(text, start, textLength_, (jchar*)text_);
1042     UINT32 localeLength = env-&gt;GetArrayLength(locale);
1043     locale_ = new (std::nothrow) WCHAR [localeLength];
1044     env-&gt;GetCharArrayRegion(locale, 0, localeLength, (jchar*)locale_);
1045     if (numberSubstitution_) numberSubstitution_-&gt;AddRef();
1046 }
1047 
1048 JFXTextAnalysisSink::~JFXTextAnalysisSink() {
1049     delete [] text_;
1050     delete [] locale_;
1051     if (numberSubstitution_) {
1052         numberSubstitution_-&gt;Release();
1053     }
1054     text_ = NULL;
1055     locale_ = NULL;
1056     numberSubstitution_ = NULL;
1057 }
1058 
1059 /* IDWriteTextAnalysisSink */
1060 IFACEMETHODIMP JFXTextAnalysisSink::SetScriptAnalysis(
1061     UINT32 textPosition,
1062     UINT32 textLength,
1063     DWRITE_SCRIPT_ANALYSIS const* scriptAnalysis) {
1064     runs_.resize(runs_.size() + 1);
1065     Run&amp; run  = runs_.back();
1066     run.start = textPosition;
1067     run.length = textLength;
1068     run.analysis = *scriptAnalysis;
1069     return S_OK;
1070 }
1071 
1072 IFACEMETHODIMP JFXTextAnalysisSink::SetLineBreakpoints(
1073     UINT32 textPosition,
1074     UINT32 textLength,
1075     const DWRITE_LINE_BREAKPOINT* lineBreakpoints) {
1076     return S_OK;
1077 }
1078 
1079 IFACEMETHODIMP JFXTextAnalysisSink::SetBidiLevel(
1080     UINT32 textPosition,
1081     UINT32 textLength,
1082     UINT8 explicitLevel,
1083     UINT8 resolvedLevel) {
1084     return S_OK;
1085 }
1086 
1087 IFACEMETHODIMP JFXTextAnalysisSink::SetNumberSubstitution(
1088     UINT32 textPosition,
1089     UINT32 textLength,
1090     IDWriteNumberSubstitution* numberSubstitution) {
1091     return S_OK;
1092 }
1093 
1094 /* IDWriteTextAnalysisSource */
1095 IFACEMETHODIMP JFXTextAnalysisSink::GetTextAtPosition(
1096     UINT32 textPosition,
1097     WCHAR const** textString,
1098     UINT32* textLength) {
1099     if (textPosition &lt; textLength_) {
1100         *textString = &amp;text_[textPosition];
1101         *textLength = textLength_ - textPosition;
1102     } else {
1103         *textString = NULL;
1104         *textLength = 0;
1105     }
1106     return S_OK;
1107 }
1108 
1109 IFACEMETHODIMP JFXTextAnalysisSink::GetTextBeforePosition(
1110     UINT32 textPosition,
1111     OUT WCHAR const** textString,
1112     OUT UINT32* textLength) {
1113     if (textPosition == 0 || textPosition &gt; textLength_) {
1114         *textString = NULL;
1115         *textLength = 0;
1116     } else {
1117         *textString = text_;
1118         *textLength = textPosition;
1119     }
1120     return S_OK;
1121 }
1122 
1123 IFACEMETHODIMP_(DWRITE_READING_DIRECTION) JFXTextAnalysisSink::GetParagraphReadingDirection() {
1124     return readingDirection_;
1125 }
1126 
1127 IFACEMETHODIMP JFXTextAnalysisSink::GetLocaleName(
1128     UINT32 textPosition,
1129     OUT UINT32* textLength,
1130     OUT WCHAR const** localeName) {
1131     fflush(stdout);
1132     *localeName = locale_;
1133     *textLength = textLength_ - textPosition;
1134     return S_OK;
1135 }
1136 
1137 IFACEMETHODIMP JFXTextAnalysisSink::GetNumberSubstitution(
1138     UINT32 textPosition,
1139     OUT UINT32* textLength,
1140     OUT IDWriteNumberSubstitution** numberSubstitution) {
1141 
1142     if (numberSubstitution_ != NULL)
1143         numberSubstitution_-&gt;AddRef();
1144 
1145     *numberSubstitution = numberSubstitution_;
1146     *textLength = textLength_ - textPosition;
1147 
1148     return S_OK;
1149 }
1150 
1151 BOOL JFXTextAnalysisSink::Next() {
1152     position_++;
1153     return ((UINT32)position_) &lt; runs_.size();
1154 }
1155 
1156 UINT32 JFXTextAnalysisSink::GetStart() {
1157     if (((UINT32)position_) &gt;= runs_.size()) return 0;
1158     return runs_[position_].start;
1159 }
1160 
1161 UINT32 JFXTextAnalysisSink::GetLength() {
1162     if (((UINT32)position_) &gt;= runs_.size()) return 0;
1163     return runs_[position_].length;
1164 }
1165 
1166 DWRITE_SCRIPT_ANALYSIS* JFXTextAnalysisSink::GetAnalysis() {
1167     if (((UINT32)position_) &gt;= runs_.size()) return NULL;
1168     return &amp;runs_[position_].analysis;
1169 }
1170 
1171 /* IUnknown */
1172 IFACEMETHODIMP_(ULONG) JFXTextAnalysisSink::AddRef() {
1173     return InterlockedIncrement(&amp;cRefCount_);
1174 }
1175 
1176 IFACEMETHODIMP_(ULONG) JFXTextAnalysisSink::Release() {
1177     ULONG newCount = InterlockedDecrement(&amp;cRefCount_);
1178     if (newCount == 0) {
1179         delete this;
1180         return 0;
1181     }
1182     return newCount;
1183 }
1184 
1185 IFACEMETHODIMP JFXTextAnalysisSink::QueryInterface(IID const&amp; riid, void** ppvObject) {
1186     if (__uuidof(IDWriteTextAnalysisSink) == riid) {
1187         *ppvObject = this;
1188     } else if (__uuidof(IDWriteTextAnalysisSource) == riid) {
1189         *ppvObject = this;
1190     } else if (__uuidof(IUnknown) == riid) {
1191         *ppvObject = this;
1192     } else {
1193         *ppvObject = NULL;
1194         return E_FAIL;
1195     }
1196     this-&gt;AddRef();
1197     return S_OK;
1198 }
1199 
1200 JNIEXPORT jlong JNICALL OS_NATIVE(_1NewJFXTextAnalysisSink)
1201 (JNIEnv *env, jclass that, jcharArray arg0, jint arg1, jint arg2, jcharArray arg3, jint arg4, jlong arg5)
1202 {
1203     if (arg0 == NULL || arg3 == NULL) return 0L;
1204     return (jlong) new (std::nothrow) JFXTextAnalysisSink(env, arg0, arg1, arg2, arg3, arg4, arg5);
1205 }
1206 
1207 JNIEXPORT jboolean JNICALL OS_NATIVE(Next)
1208 (JNIEnv *env, jclass that, jlong arg0) {
1209     return ((JFXTextAnalysisSink*)arg0)-&gt;Next();
1210 }
1211 
1212 JNIEXPORT jint JNICALL OS_NATIVE(GetStart)
1213 (JNIEnv *env, jclass that, jlong arg0) {
1214     return ((JFXTextAnalysisSink*)arg0)-&gt;GetStart();
1215 }
1216 
1217 JNIEXPORT jint JNICALL OS_NATIVE(GetLength)
1218 (JNIEnv *env, jclass that, jlong arg0) {
1219     return ((JFXTextAnalysisSink*)arg0)-&gt;GetLength();
1220 }
1221 
1222 JNIEXPORT jobject JNICALL OS_NATIVE(GetAnalysis)
1223 (JNIEnv *env, jclass that, jlong arg0) {
1224     return newDWRITE_SCRIPT_ANALYSIS(env, ((JFXTextAnalysisSink*)arg0)-&gt;GetAnalysis());
1225 }
1226 
1227 /***********************************************/
1228 /*                Text Renderer                */
1229 /***********************************************/
1230 
1231 class JFXTextRenderer : public IDWriteTextRenderer
1232 {
1233 public:
1234     JFXTextRenderer();
1235     ~JFXTextRenderer();
1236 
1237 /* IDWriteTextRenderer */
1238 public:
1239     IFACEMETHOD(DrawGlyphRun)(
1240         void* clientDrawingContext,
1241         FLOAT baselineOriginX,
1242         FLOAT baselineOriginY,
1243         DWRITE_MEASURING_MODE measuringMode,
1244         DWRITE_GLYPH_RUN const* glyphRun,
1245         DWRITE_GLYPH_RUN_DESCRIPTION const* glyphRunDescription,
1246         IUnknown* clientDrawingEffect);
1247 
1248     IFACEMETHOD(DrawUnderline)(
1249         void* clientDrawingContext,
1250         FLOAT baselineOriginX,
1251         FLOAT baselineOriginY,
1252         DWRITE_UNDERLINE const* underline,
1253         IUnknown* clientDrawingEffect);
1254 
1255     IFACEMETHOD(DrawStrikethrough)(
1256         void* clientDrawingContext,
1257         FLOAT baselineOriginX,
1258         FLOAT baselineOriginY,
1259         DWRITE_STRIKETHROUGH const* strikethrough,
1260         IUnknown* clientDrawingEffect);
1261 
1262     IFACEMETHOD(DrawInlineObject)(
1263         void* clientDrawingContext,
1264         FLOAT originX,
1265         FLOAT originY,
1266         IDWriteInlineObject* inlineObject,
1267         BOOL isSideways,
1268         BOOL isRightToLeft,
1269         IUnknown* clientDrawingEffect);
1270 
1271 /* IDWritePixelSnapping */
1272 public:
1273     IFACEMETHOD(IsPixelSnappingDisabled)(
1274         void* clientDrawingContext,
1275         BOOL* isDisabled);
1276 
1277     IFACEMETHOD(GetCurrentTransform)(
1278         void* clientDrawingContext,
1279         DWRITE_MATRIX* transform);
1280 
1281     IFACEMETHOD(GetPixelsPerDip)(
1282         void* clientDrawingContext,
1283         FLOAT* pixelsPerDip);
1284 
1285 /* IUnknown */
1286 public:
1287     IFACEMETHOD_(ULONG, AddRef) ();
1288     IFACEMETHOD_(ULONG,  Release) ();
1289     IFACEMETHOD(QueryInterface) (
1290                 IID const&amp; riid,
1291                 void** ppvObject);
1292 
1293 public:
1294     BOOL Next();
1295     UINT32 GetStart();
1296     UINT32 GetLength();
1297     UINT32 GetGlyphCount();
1298     UINT32 GetTotalGlyphCount();
1299     IDWriteFontFace* GetFontFace();
1300     const UINT16* GetClusterMap();
1301     const UINT16* GetGlyphIndices();
1302     const FLOAT*  GetGlyphAdvances();
1303     const DWRITE_GLYPH_OFFSET* GetGlyphOffsets();
1304 
1305 private:
1306     ULONG cRefCount_;
1307     struct Run {
1308         DWRITE_GLYPH_RUN glyphRun;
1309         DWRITE_GLYPH_RUN_DESCRIPTION glyphRunDescription;
1310     };
1311     std::vector&lt;Run&gt; runs_;
1312     INT32 position_;
1313     INT32 totalGlyphCount_;
1314 };
1315 
1316 JFXTextRenderer::JFXTextRenderer()
1317 : cRefCount_(0),
1318   position_(-1),
1319   totalGlyphCount_(0) {
1320 }
1321 
1322 JFXTextRenderer::~JFXTextRenderer() {
1323 }
1324 
1325 /* IDWriteTextRenderer */
1326 IFACEMETHODIMP JFXTextRenderer::DrawGlyphRun (
1327         void* clientDrawingContext,
1328         FLOAT baselineOriginX,
1329         FLOAT baselineOriginY,
1330         DWRITE_MEASURING_MODE measuringMode,
1331         DWRITE_GLYPH_RUN const* glyphRun,
1332         DWRITE_GLYPH_RUN_DESCRIPTION const* glyphRunDescription,
1333         IUnknown* clientDrawingEffect)
1334 {
1335     runs_.resize(runs_.size() + 1);
1336     Run&amp; run  = runs_.back();
1337     run.glyphRun = *glyphRun;
1338     run.glyphRunDescription = *glyphRunDescription;
1339     totalGlyphCount_ += glyphRun-&gt;glyphCount;
1340     return S_OK;
1341 }
1342 
1343 IFACEMETHODIMP JFXTextRenderer::DrawUnderline (
1344         void* clientDrawingContext,
1345         FLOAT baselineOriginX,
1346         FLOAT baselineOriginY,
1347         DWRITE_UNDERLINE const* underline,
1348         IUnknown* clientDrawingEffect)
1349 {
1350     return S_OK;
1351 }
1352 
1353 IFACEMETHODIMP JFXTextRenderer::DrawStrikethrough (
1354         void* clientDrawingContext,
1355         FLOAT baselineOriginX,
1356         FLOAT baselineOriginY,
1357         DWRITE_STRIKETHROUGH const* strikethrough,
1358         IUnknown* clientDrawingEffect)
1359 {
1360     return S_OK;
1361 }
1362 
1363 IFACEMETHODIMP JFXTextRenderer::DrawInlineObject (
1364         void* clientDrawingContext,
1365         FLOAT originX,
1366         FLOAT originY,
1367         IDWriteInlineObject* inlineObject,
1368         BOOL isSideways,
1369         BOOL isRightToLeft,
1370         IUnknown* clientDrawingEffect)
1371 {
1372     return S_OK;
1373 }
1374 
1375 /* IDWritePixelSnapping */
1376 IFACEMETHODIMP JFXTextRenderer::IsPixelSnappingDisabled (
1377         void* clientDrawingContext,
1378         BOOL* isDisabled)
1379 {
1380     *isDisabled = FALSE;
1381     return S_OK;
1382 }
1383 
1384 IFACEMETHODIMP JFXTextRenderer::GetCurrentTransform (
1385         void* clientDrawingContext,
1386         DWRITE_MATRIX* transform)
1387 {
1388     const DWRITE_MATRIX ident = {1.0, 0.0, 0.0, 1.0, 0.0, 0.0};
1389     *transform = ident;
1390     return S_OK;
1391 }
1392 
1393 IFACEMETHODIMP JFXTextRenderer::GetPixelsPerDip (
1394         void* clientDrawingContext,
1395         FLOAT* pixelsPerDip)
1396 {
1397     *pixelsPerDip = 1.0f;
1398     return S_OK;
1399 }
1400 
1401 /* IUnknown */
1402 IFACEMETHODIMP_(ULONG) JFXTextRenderer::AddRef() {
1403     return InterlockedIncrement(&amp;cRefCount_);
1404 }
1405 
1406 IFACEMETHODIMP_(ULONG) JFXTextRenderer::Release() {
1407     ULONG newCount = InterlockedDecrement(&amp;cRefCount_);
1408     if (newCount == 0) {
1409         delete this;
1410         return 0;
1411     }
1412     return newCount;
1413 }
1414 
1415 IFACEMETHODIMP JFXTextRenderer::QueryInterface(IID const&amp; riid, void** ppvObject) {
1416     if (__uuidof(IDWriteTextRenderer) == riid) {
1417         *ppvObject = this;
1418     } else if (__uuidof(IDWritePixelSnapping) == riid) {
1419         *ppvObject = this;
1420     } else if (__uuidof(IUnknown) == riid) {
1421         *ppvObject = this;
1422     } else {
1423         *ppvObject = NULL;
1424         return E_FAIL;
1425     }
1426     this-&gt;AddRef();
1427     return S_OK;
1428 }
1429 
1430 BOOL JFXTextRenderer::Next() {
1431     position_++;
1432     return ((UINT32)position_) &lt; runs_.size();
1433 }
1434 
1435 UINT32 JFXTextRenderer::GetStart() {
1436     if (((UINT32)position_) &gt;= runs_.size()) return 0;
1437     return runs_[position_].glyphRunDescription.textPosition;
1438 }
1439 
1440 UINT32 JFXTextRenderer::GetLength() {
1441     if (((UINT32)position_) &gt;= runs_.size()) return 0;
1442     return runs_[position_].glyphRunDescription.stringLength;
1443 }
1444 
1445 UINT32 JFXTextRenderer::GetGlyphCount() {
1446     if (((UINT32)position_) &gt;= runs_.size()) return 0;
1447     return runs_[position_].glyphRun.glyphCount;
1448 }
1449 
1450 UINT32 JFXTextRenderer::GetTotalGlyphCount() {
1451     return totalGlyphCount_;
1452 }
1453 
1454 IDWriteFontFace* JFXTextRenderer::GetFontFace() {
1455     if (((UINT32)position_) &gt;= runs_.size()) return NULL;
1456     return runs_[position_].glyphRun.fontFace;
1457 }
1458 
1459 const FLOAT* JFXTextRenderer::GetGlyphAdvances() {
1460     if (((UINT32)position_) &gt;= runs_.size()) return NULL;
1461     return runs_[position_].glyphRun.glyphAdvances;
1462 }
1463 
1464 const DWRITE_GLYPH_OFFSET* JFXTextRenderer::GetGlyphOffsets() {
1465     if (((UINT32)position_) &gt;= runs_.size()) return NULL;
1466     return runs_[position_].glyphRun.glyphOffsets;
1467 }
1468 
1469 const UINT16* JFXTextRenderer::GetGlyphIndices() {
1470     if (((UINT32)position_) &gt;= runs_.size()) return NULL;
1471     return runs_[position_].glyphRun.glyphIndices;
1472 }
1473 
1474 const UINT16* JFXTextRenderer::GetClusterMap() {
1475     if (((UINT32)position_) &gt;= runs_.size()) return NULL;
1476     return runs_[position_].glyphRunDescription.clusterMap;
1477 }
1478 
1479 JNIEXPORT jlong JNICALL OS_NATIVE(_1NewJFXTextRenderer)
1480 (JNIEnv *env, jclass that)
1481 {
1482     return (jlong) new (std::nothrow) JFXTextRenderer();
1483 }
1484 
1485 JNIEXPORT jboolean JNICALL OS_NATIVE(JFXTextRendererNext)
1486 (JNIEnv *env, jclass that, jlong arg0) {
1487     return ((JFXTextRenderer*)arg0)-&gt;Next();
1488 }
1489 
1490 JNIEXPORT jint JNICALL OS_NATIVE(JFXTextRendererGetStart)
1491 (JNIEnv *env, jclass that, jlong arg0) {
1492     return ((JFXTextRenderer*)arg0)-&gt;GetStart();
1493 }
1494 
1495 JNIEXPORT jint JNICALL OS_NATIVE(JFXTextRendererGetLength)
1496 (JNIEnv *env, jclass that, jlong arg0) {
1497     return ((JFXTextRenderer*)arg0)-&gt;GetLength();
1498 }
1499 
1500 JNIEXPORT jint JNICALL OS_NATIVE(JFXTextRendererGetGlyphCount)
1501 (JNIEnv *env, jclass that, jlong arg0) {
1502     return ((JFXTextRenderer*)arg0)-&gt;GetGlyphCount();
1503 }
1504 
1505 JNIEXPORT jint JNICALL OS_NATIVE(JFXTextRendererGetTotalGlyphCount)
1506 (JNIEnv *env, jclass that, jlong arg0) {
1507     return ((JFXTextRenderer*)arg0)-&gt;GetTotalGlyphCount();
1508 }
1509 
1510 JNIEXPORT jlong JNICALL OS_NATIVE(JFXTextRendererGetFontFace)
1511 (JNIEnv *env, jclass that, jlong arg0) {
1512     return (jlong)((JFXTextRenderer*)arg0)-&gt;GetFontFace();
1513 }
1514 
1515 JNIEXPORT jint JNICALL OS_NATIVE(JFXTextRendererGetGlyphIndices)
1516 (JNIEnv *env, jclass that, jlong arg0, jintArray arg1, jint start, jint slot) {
1517     if (!arg1) return 0;
1518     jint* data = env-&gt;GetIntArrayElements(arg1, NULL);
1519     if (!data) return 0;
1520 
1521     JFXTextRenderer* renderer = (JFXTextRenderer*)arg0;
1522     // Type cast unsigned int to int. It is safe to assume that GetGlyphCount will never exceed max of jint
1523     jint glyphCount = (jint) renderer-&gt;GetGlyphCount();
1524     jint length = env-&gt;GetArrayLength(arg1);
1525     jint copiedCount = length - start &gt; glyphCount ? glyphCount : length - start;
1526 
1527     const UINT16* indices = renderer-&gt;GetGlyphIndices();
1528     UINT32 i;
1529     for (i = 0; i &lt; copiedCount; i++) {
1530         data[i + start] = (indices[i] | slot);
1531     }
1532     env-&gt;ReleaseIntArrayElements(arg1, data, NULL);
1533     return copiedCount;
1534 }
1535 
1536 JNIEXPORT jint JNICALL OS_NATIVE(JFXTextRendererGetGlyphAdvances)
1537 (JNIEnv *env, jclass that, jlong arg0, jfloatArray arg1, jint start) {
1538     if (!arg1) return 0;
1539     jfloat* data = env-&gt;GetFloatArrayElements(arg1, NULL);
1540     if (!data) return 0;
1541 
1542     JFXTextRenderer* renderer = (JFXTextRenderer*)arg0;
1543     // Type cast unsigned int to int. It is safe to assume that GetGlyphCount will never exceed max of jint
1544     jint glyphCount = (jint) renderer-&gt;GetGlyphCount();
1545     jint length = env-&gt;GetArrayLength(arg1);
1546     jint copiedCount = length - start &gt; glyphCount ? glyphCount : length - start;
1547 
1548     const FLOAT* advances = renderer-&gt;GetGlyphAdvances();
1549     UINT32 i;
1550     for (i = 0; i &lt; copiedCount; i++) {
1551         data[i + start] = advances[i];
1552     }
1553     env-&gt;ReleaseFloatArrayElements(arg1, data, NULL);
1554     return copiedCount;
1555 }
1556 
1557 JNIEXPORT jint JNICALL OS_NATIVE(JFXTextRendererGetGlyphOffsets)
1558 (JNIEnv *env, jclass that, jlong arg0, jfloatArray arg1, jint start) {
1559     if (!arg1) return 0;
1560     jfloat* data = env-&gt;GetFloatArrayElements(arg1, NULL);
1561     if (!data) return 0;
1562 
1563     JFXTextRenderer* renderer = (JFXTextRenderer*)arg0;
1564     // Type cast unsigned int to int. It is safe to assume the result will never exceed max of jint
1565     jint offsetCount = (jint) renderer-&gt;GetGlyphCount() * 2;
1566     jint length = env-&gt;GetArrayLength(arg1);
1567     jint copiedCount = length - start &gt; offsetCount ? offsetCount : length - start;
1568 
1569     const DWRITE_GLYPH_OFFSET* offsets = renderer-&gt;GetGlyphOffsets();
1570     UINT32 i = 0, j = 0;
1571     while (i &lt; copiedCount) {
1572         DWRITE_GLYPH_OFFSET offset = offsets[j++];
1573         data[start + i++] = offset.advanceOffset;
1574         data[start + i++] = offset.ascenderOffset;
1575     }
1576     env-&gt;ReleaseFloatArrayElements(arg1, data, NULL);
1577     return copiedCount;
1578 }
1579 
1580 JNIEXPORT jint JNICALL OS_NATIVE(JFXTextRendererGetClusterMap)
1581 (JNIEnv *env, jclass that, jlong arg0, jshortArray arg1, jint start, jint glyphStart) {
1582     if (!arg1) return 0;
1583     jshort* data = env-&gt;GetShortArrayElements(arg1, NULL);
1584     if (!data) return 0;
1585 
1586     JFXTextRenderer* renderer = (JFXTextRenderer*)arg0;
1587     // Type cast unsigned int to int. It is safe to assume that GetLength will never exceed max of jint
1588     jint textLength = (jint) renderer-&gt;GetLength();
1589     jint length = env-&gt;GetArrayLength(arg1);
1590     jint copiedCount = length - start &gt; textLength ? textLength : length - start;
1591 
1592     const UINT16* map = renderer-&gt;GetClusterMap();
1593     UINT32 i;
1594     /* Adding start to the result as in Java it needs the cluster map
1595      * relative to start of the TextRun and the cluster map computed
1596      * by DirectWrite has it relative to the DWRITE_GLYPH_RUN.
1597      */
1598     for (i = 0; i &lt; copiedCount; i++) {
1599         data[i + start] = map[i] + (jshort)glyphStart;
1600     }
1601     env-&gt;ReleaseShortArrayElements(arg1, data, NULL);
1602     return copiedCount;
1603 }
1604 
1605 /***********************************************/
1606 /*                Glyph Outline                */
1607 /***********************************************/
1608 
1609 class JFXGeometrySink : public IDWriteGeometrySink {
1610 public:
1611     JFXGeometrySink();
1612     ~JFXGeometrySink();
1613     int numTypes();
1614     int numCoords();
1615     jbyte* types();
1616     jfloat* coords();
1617 
1618 /* IDWriteGeometrySink */
1619 public:
1620     IFACEMETHOD_(void, SetFillMode)(
1621         D2D1_FILL_MODE fillMode);
1622 
1623     IFACEMETHOD_(void, SetSegmentFlags)(
1624         D2D1_PATH_SEGMENT vertexFlags);
1625 
1626     IFACEMETHOD_(void, BeginFigure)(
1627         D2D1_POINT_2F startPoint,
1628         D2D1_FIGURE_BEGIN figureBegin);
1629 
1630     IFACEMETHOD_(void, AddLines)(
1631         CONST D2D1_POINT_2F *points,
1632         UINT32 pointsCount);
1633 
1634     IFACEMETHOD_(void, AddBeziers)(
1635         CONST D2D1_BEZIER_SEGMENT *beziers,
1636         UINT32 beziersCount);
1637 
1638     IFACEMETHOD_(void, EndFigure)(
1639         D2D1_FIGURE_END figureEnd);
1640 
1641     IFACEMETHOD(Close)();
1642 
1643 /* IUnknown */
1644 public:
1645     IFACEMETHOD_(ULONG, AddRef) ();
1646     IFACEMETHOD_(ULONG, Release) ();
1647     IFACEMETHOD(QueryInterface) (
1648         IID const&amp; riid,
1649         void** ppvObject
1650     );
1651 
1652 private:
1653     ULONG cRefCount_;
1654     std::vector&lt;jbyte&gt; vtypes_;
1655     std::vector&lt;jfloat&gt; vcoords_;
1656 };
1657 
1658 JFXGeometrySink::JFXGeometrySink()
1659 : cRefCount_(0) {
1660 }
1661 
1662 JFXGeometrySink::~JFXGeometrySink() {
1663 }
1664 
1665 int JFXGeometrySink::numTypes() {
1666     return vtypes_.size();
1667 }
1668 
1669 int JFXGeometrySink::numCoords() {
1670     return vcoords_.size();
1671 }
1672 
1673 jbyte* JFXGeometrySink::types() {
1674     return vtypes_.data();
1675 }
1676 
1677 jfloat* JFXGeometrySink::coords() {
1678     return vcoords_.data();
1679 }
1680 
1681 /* IDWriteGeometrySink */
1682 IFACEMETHODIMP_(void) JFXGeometrySink::SetFillMode(D2D1_FILL_MODE fillMode) {
1683     /* ignored */
1684 }
1685 
1686 IFACEMETHODIMP_(void) JFXGeometrySink::SetSegmentFlags(D2D1_PATH_SEGMENT vertexFlags) {
1687     /* ignored */
1688 }
1689 
1690 IFACEMETHODIMP_(void) JFXGeometrySink::BeginFigure(D2D1_POINT_2F startPoint, D2D1_FIGURE_BEGIN figureBegin) {
1691     /* Handle as move to point, ignore figureBegin (hollow/filled) */
1692     vtypes_.push_back(0);
1693     vcoords_.push_back(startPoint.x);
1694     vcoords_.push_back(startPoint.y);
1695 }
1696 
1697 IFACEMETHODIMP_(void) JFXGeometrySink::AddLines(CONST D2D1_POINT_2F *points, UINT32 pointsCount) {
1698     UINT i;
1699     for (i = 0; i &lt; pointsCount; i++) {
1700         D2D1_POINT_2F pt = points[i];
1701         vtypes_.push_back(1);
1702         vcoords_.push_back(pt.x);
1703         vcoords_.push_back(pt.y);
1704     }
1705 }
1706 
1707 IFACEMETHODIMP_(void) JFXGeometrySink::AddBeziers(CONST D2D1_BEZIER_SEGMENT *beziers, UINT32 beziersCount) {
1708     UINT i;
1709     for (i = 0; i &lt; beziersCount; i++) {
1710         /* The API for simplified geometry sink does not have quad bezier curve (type2),
1711          * which I suspect is done using cubic bezier with point1==point2 */
1712         D2D1_BEZIER_SEGMENT b = beziers[i];
1713         vtypes_.push_back(3);
1714         vcoords_.push_back(b.point1.x);
1715         vcoords_.push_back(b.point1.y);
1716         vcoords_.push_back(b.point2.x);
1717         vcoords_.push_back(b.point2.y);
1718         vcoords_.push_back(b.point3.x);
1719         vcoords_.push_back(b.point3.y);
1720     }
1721 }
1722 
1723 IFACEMETHODIMP_(void) JFXGeometrySink::EndFigure (D2D1_FIGURE_END figureEnd) {
1724     /* Handle as close subpath */
1725     vtypes_.push_back(4);
1726 }
1727 
1728 IFACEMETHODIMP JFXGeometrySink::Close () {
1729     return S_OK;
1730 }
1731 
1732 /* IUnknown */
1733 IFACEMETHODIMP_(ULONG) JFXGeometrySink::AddRef() {
1734     return InterlockedIncrement(&amp;cRefCount_);
1735 }
1736 
1737 IFACEMETHODIMP_(ULONG) JFXGeometrySink::Release() {
1738     ULONG newCount = InterlockedDecrement(&amp;cRefCount_);
1739     if (newCount == 0) {
1740         delete this;
1741         return 0;
1742     }
1743     return newCount;
1744 }
1745 
1746 IFACEMETHODIMP JFXGeometrySink::QueryInterface(IID const&amp; riid, void** ppvObject) {
1747     if (__uuidof(IDWriteGeometrySink) == riid) {
1748         *ppvObject = this;
1749     } else if (__uuidof(ID2D1SimplifiedGeometrySink) == riid) {
1750         *ppvObject = this;
1751     } else if (__uuidof(IUnknown) == riid) {
1752         *ppvObject = this;
1753     } else {
1754         *ppvObject = NULL;
1755         return E_FAIL;
1756     }
1757     this-&gt;AddRef();
1758     return S_OK;
1759 }
1760 
1761 /* IDWriteFontFace */
1762 JNIEXPORT jobject JNICALL OS_NATIVE(GetGlyphRunOutline)
1763     (JNIEnv *env, jclass that, jlong arg0, jfloat arg1, jshort arg2, jboolean arg3)
1764 {
1765     HRESULT hr = E_FAIL;
1766     jobject result = NULL;
1767     const UINT32  glyphCount = 1;
1768     const UINT16 glyphIndices[glyphCount] = {arg2};
1769     JFXGeometrySink* sink = new (std::nothrow) JFXGeometrySink();
1770     if (sink == NULL) return NULL;
1771 
1772     hr = ((IDWriteFontFace *)arg0)-&gt;GetGlyphRunOutline(arg1, glyphIndices, NULL, NULL, glyphCount, arg3, FALSE, sink);
1773 
1774     static jclass path2DClass = NULL;
1775     static jmethodID path2DCtr = NULL;
1776     if (path2DClass == NULL) {
1777         jclass tmpClass = env-&gt;FindClass(&quot;com/sun/javafx/geom/Path2D&quot;);
1778         if (env-&gt;ExceptionOccurred() || !tmpClass) {
1779             fprintf(stderr, &quot;OS_NATIVE error: JNI exception or tmpClass == NULL&quot;);
1780             goto fail;
1781         }
1782         path2DClass = (jclass)env-&gt;NewGlobalRef(tmpClass);
1783         path2DCtr = env-&gt;GetMethodID(path2DClass, &quot;&lt;init&gt;&quot;, &quot;(I[BI[FI)V&quot;);
1784         if (env-&gt;ExceptionOccurred() || !path2DCtr) {
1785             fprintf(stderr, &quot;OS_NATIVE error: JNI exception or path2DCtr == NULL&quot;);
1786             goto fail;
1787         }
1788     }
1789 
1790     if (SUCCEEDED(hr)) {
1791         jbyteArray types = env-&gt;NewByteArray(sink-&gt;numTypes());
1792         jfloatArray coords = env-&gt;NewFloatArray(sink-&gt;numCoords());
1793         if (types &amp;&amp; coords) {
1794             env-&gt;SetByteArrayRegion(types, 0, sink-&gt;numTypes(), sink-&gt;types());
1795             env-&gt;SetFloatArrayRegion(coords, 0, sink-&gt;numCoords(), sink-&gt;coords());
1796             result = env-&gt;NewObject(path2DClass, path2DCtr,
1797                                     0 /*winding rule*/,
1798                                     types, sink-&gt;numTypes(),
1799                                     coords, sink-&gt;numCoords());
1800           }
1801     }
1802 fail:
1803     delete sink;
1804     return result;
1805 }
1806 
1807 JNIEXPORT jobject JNICALL OS_NATIVE(GetDesignGlyphMetrics)
1808     (JNIEnv *env, jclass that, jlong arg0, jshort arg1, jboolean arg2)
1809 {
1810     HRESULT hr = E_FAIL;
1811     jobject result = NULL;
1812     const UINT32  glyphCount = 1;
1813     const UINT16 glyphIndices[glyphCount] = {arg1};
1814     DWRITE_GLYPH_METRICS glyphMetrics[glyphCount];
1815 
1816     hr = ((IDWriteFontFace *)arg0)-&gt;GetDesignGlyphMetrics(glyphIndices, glyphCount, glyphMetrics, arg2);
1817     if (SUCCEEDED(hr)) {
1818         result = newDWRITE_GLYPH_METRICS(env, &amp;glyphMetrics[0]);
1819     }
1820     return result;
1821 }
1822 
1823 /* IDWriteFactory */
1824 JNIEXPORT jlong JNICALL OS_NATIVE(CreateTextAnalyzer)
1825     (JNIEnv *env, jclass that, jlong arg0)
1826 {
1827     IDWriteTextAnalyzer* result = NULL;
1828     HRESULT hr = ((IDWriteFactory *)arg0)-&gt;CreateTextAnalyzer(&amp;result);
1829     return SUCCEEDED(hr) ? (jlong)result : NULL;
1830 }
1831 
1832 JNIEXPORT jlong JNICALL OS_NATIVE(CreateTextFormat)
1833     (JNIEnv *env, jclass that, jlong arg0, jcharArray arg1, jlong arg2, jint arg3,
1834     jint arg4, jint arg5, jfloat arg6, jcharArray arg7)
1835 {
1836     HRESULT hr = E_FAIL;
1837     IDWriteTextFormat* result = NULL;
1838     jchar *lparg1 = NULL;
1839     jchar *lparg7 = NULL;
1840     if (arg1) if ((lparg1 = env-&gt;GetCharArrayElements(arg1, NULL)) == NULL) goto fail;
1841     if (arg7) if ((lparg7 = env-&gt;GetCharArrayElements(arg7, NULL)) == NULL) goto fail;
1842     hr = ((IDWriteFactory *)arg0)-&gt;CreateTextFormat((const WCHAR *)lparg1,
1843                                                     (IDWriteFontCollection *)arg2,
1844                                                     (DWRITE_FONT_WEIGHT)arg3,
1845                                                     (DWRITE_FONT_STYLE)arg4,
1846                                                     (DWRITE_FONT_STRETCH)arg5,
1847                                                     arg6,
1848                                                     (const WCHAR *)lparg7,
1849                                                     &amp;result);
1850 fail:
1851     if (arg1 &amp;&amp; lparg1) env-&gt;ReleaseCharArrayElements(arg1, lparg1, 0);
1852     if (arg7 &amp;&amp; lparg7) env-&gt;ReleaseCharArrayElements(arg7, lparg7, 0);
1853     return SUCCEEDED(hr) ? (jlong)result : NULL;
1854 }
1855 
1856 JNIEXPORT jlong JNICALL OS_NATIVE(CreateFontFileReference)
1857     (JNIEnv *env, jclass that, jlong arg0, jcharArray arg1)
1858 {
1859     HRESULT hr = E_FAIL;
1860     IDWriteFontFile* result = NULL;
1861     jchar *lparg1 = NULL;
1862     if (arg1) if ((lparg1 = env-&gt;GetCharArrayElements(arg1, NULL)) == NULL) goto fail;
1863     hr = ((IDWriteFactory *)arg0)-&gt;CreateFontFileReference((const WCHAR *)lparg1, NULL, &amp;result);
1864 fail:
1865     if (arg1 &amp;&amp; lparg1) env-&gt;ReleaseCharArrayElements(arg1, lparg1, 0);
1866     return SUCCEEDED(hr) ? (jlong)result : NULL;
1867 }
1868 
1869 JNIEXPORT jlong JNICALL OS_NATIVE(CreateFontFace__JIJII)
1870     (JNIEnv *env, jclass that, jlong arg0, jint arg1, jlong arg3, jint arg4, jint arg5)
1871 {
1872     IDWriteFontFace* result = NULL;
1873     const UINT32  numberOfFiles = 1;
1874     IDWriteFontFile* fontFileArray[numberOfFiles] = {(IDWriteFontFile*)arg3};
1875     HRESULT hr = ((IDWriteFactory *)arg0)-&gt;CreateFontFace((DWRITE_FONT_FACE_TYPE)arg1,
1876                                                           numberOfFiles,
1877                                                           fontFileArray,
1878                                                           (UINT32)arg4,
1879                                                           (DWRITE_FONT_SIMULATIONS)arg5,
1880                                                           &amp;result);
1881 
1882     return SUCCEEDED(hr) ? (jlong)result : NULL;
1883 }
1884 
1885 JNIEXPORT jlong JNICALL OS_NATIVE(CreateTextLayout)
1886     (JNIEnv *env, jclass that, jlong arg0, jcharArray arg1, jint start, jint count, jlong arg4,
1887     jfloat arg5, jfloat arg6)
1888 {
1889     HRESULT hr = E_FAIL;
1890     IDWriteTextLayout* result = NULL;
1891     jchar *lparg1 = NULL;
1892     if (arg1) if ((lparg1 = env-&gt;GetCharArrayElements(arg1, NULL)) == NULL) goto fail;
1893     if (start + count &gt; env-&gt;GetArrayLength(arg1)) goto fail;
1894 
1895     const WCHAR * text = (const WCHAR *)(lparg1 + start);
1896 
1897     hr = ((IDWriteFactory *)arg0)-&gt;CreateTextLayout(text,
1898                                                     (UINT32)count,
1899                                                     (IDWriteTextFormat *)arg4,
1900                                                     (FLOAT)arg5,
1901                                                     (FLOAT)arg6,
1902                                                     &amp;result);
1903 fail:
1904     if (arg1 &amp;&amp; lparg1) env-&gt;ReleaseCharArrayElements(arg1, lparg1, 0);
1905 
1906     return SUCCEEDED(hr) ? (jlong)result : NULL;
1907 }
1908 
1909 JNIEXPORT jlong JNICALL OS_NATIVE(GetSystemFontCollection)
1910     (JNIEnv *env, jclass that, jlong arg0, jboolean arg1)
1911 {
1912     IDWriteFontCollection* result = NULL;
1913     HRESULT hr = ((IDWriteFactory *)arg0)-&gt;GetSystemFontCollection(&amp;result, arg1);
1914     return SUCCEEDED(hr) ? (jlong)result : NULL;
1915 }
1916 
1917 JNIEXPORT jlong JNICALL OS_NATIVE(CreateGlyphRunAnalysis)
1918     (JNIEnv *env, jclass that, jlong arg0, jobject arg1, jfloat arg2, jobject arg3, jint arg4, jint arg5, jfloat arg6, jfloat arg7)
1919 {
1920     HRESULT hr = E_FAIL;
1921     IDWriteGlyphRunAnalysis* result = NULL;
1922     DWRITE_GLYPH_RUN _arg1, *lparg1 = NULL;
1923     DWRITE_MATRIX _arg3, *lparg3 = NULL;
1924     _arg1.glyphCount = 1;
1925     _arg1.glyphIndices = new (std::nothrow) UINT16 [1];
1926     _arg1.glyphAdvances = new (std::nothrow) FLOAT [1];
1927     _arg1.glyphOffsets = new (std::nothrow) DWRITE_GLYPH_OFFSET [1];
1928 
1929     /* In Only */
1930     if (arg1) if ((lparg1 = getDWRITE_GLYPH_RUNFields(env, arg1, &amp;_arg1)) == NULL) goto fail;
1931     if (arg3) if ((lparg3 = getDWRITE_MATRIXFields(env, arg3, &amp;_arg3)) == NULL) goto fail;
1932     hr = ((IDWriteFactory *)arg0)-&gt;CreateGlyphRunAnalysis(lparg1,
1933                                                           (FLOAT)arg2,
1934                                                           lparg3,
1935                                                           (DWRITE_RENDERING_MODE)arg4,
1936                                                           (DWRITE_MEASURING_MODE)arg5,
1937                                                           (FLOAT)arg6,
1938                                                           (FLOAT)arg7,
1939                                                           &amp;result);
1940 
1941 fail:
1942     delete [] _arg1.glyphIndices;
1943     delete [] _arg1.glyphAdvances;
1944     delete [] _arg1.glyphOffsets;
1945     return SUCCEEDED(hr) ? (jlong)result : NULL;
1946 }
1947 
1948 /* IDWriteFontFile */
1949 JNIEXPORT jint JNICALL OS_NATIVE(Analyze)
1950     (JNIEnv *env, jclass that, jlong arg0, jbooleanArray arg1, jintArray arg2, jintArray arg3, jintArray arg4)
1951 {
1952     if (arg0 == NULL) return E_FAIL;
1953     IDWriteFontFile* fontFile = (IDWriteFontFile*)arg0;
1954     BOOL isSupportedFontType;
1955     DWRITE_FONT_FILE_TYPE fontFileType;
1956     DWRITE_FONT_FACE_TYPE fontFaceType;
1957     UINT32 numberOfFaces;
1958     HRESULT hr = fontFile-&gt;Analyze(&amp;isSupportedFontType,
1959                                    &amp;fontFileType,
1960                                    &amp;fontFaceType,
1961                                    &amp;numberOfFaces);
1962 
1963     if (arg1 &amp;&amp; env-&gt;GetArrayLength(arg1) == 1) {
1964         jboolean *lparg1 = env-&gt;GetBooleanArrayElements(arg1, NULL);
1965         if (lparg1) {
1966             lparg1[0] = isSupportedFontType;
1967             env-&gt;ReleaseBooleanArrayElements(arg1, lparg1, 0);
1968         }
1969     }
1970     if (arg2 &amp;&amp; env-&gt;GetArrayLength(arg2) == 1) {
1971         jint *lparg2 = env-&gt;GetIntArrayElements(arg2, NULL);
1972         if (lparg2) {
1973             lparg2[0] = fontFileType;
1974             env-&gt;ReleaseIntArrayElements(arg2, lparg2, 0);
1975         }
1976     }
1977     if (arg3 &amp;&amp; env-&gt;GetArrayLength(arg3) == 1) {
1978         jint *lparg3 = env-&gt;GetIntArrayElements(arg3, NULL);
1979         if (lparg3) {
1980             lparg3[0] = fontFaceType;
1981             env-&gt;ReleaseIntArrayElements(arg3, lparg3, 0);
1982         }
1983     }
1984     if (arg4 &amp;&amp; env-&gt;GetArrayLength(arg4) == 1) {
1985         jint *lparg4 = env-&gt;GetIntArrayElements(arg4, NULL);
1986         if (lparg4) {
1987             lparg4[0] = numberOfFaces;
1988             env-&gt;ReleaseIntArrayElements(arg4, lparg4, 0);
1989         }
1990     }
1991     return hr;
1992 }
1993 
1994 /* IDWriteFont */
1995 JNIEXPORT jlong JNICALL OS_NATIVE(CreateFontFace__J)
1996     (JNIEnv *env, jclass that, jlong arg0)
1997 {
1998     IDWriteFontFace* result = NULL;
1999     HRESULT hr = ((IDWriteFont *)arg0)-&gt;CreateFontFace(&amp;result);
2000     return SUCCEEDED(hr) ? (jlong)result : NULL;
2001 }
2002 
2003 JNIEXPORT jlong JNICALL OS_NATIVE(GetFaceNames)
2004     (JNIEnv *env, jclass that, jlong arg0)
2005 {
2006     IDWriteLocalizedStrings* result = NULL;
2007     HRESULT hr = ((IDWriteFont *)arg0)-&gt;GetFaceNames(&amp;result);
2008     return SUCCEEDED(hr) ? (jlong)result : NULL;
2009 }
2010 
2011 JNIEXPORT jlong JNICALL OS_NATIVE(GetFontFamily__J)
2012     (JNIEnv *env, jclass that, jlong arg0)
2013 {
2014     IDWriteFontFamily* result = NULL;
2015     HRESULT hr = ((IDWriteFont *)arg0)-&gt;GetFontFamily(&amp;result);
2016     return SUCCEEDED(hr) ? (jlong)result : NULL;
2017 }
2018 
2019 JNIEXPORT jint JNICALL OS_NATIVE(GetStretch)
2020     (JNIEnv *env, jclass that, jlong arg0)
2021 {
2022     return (jint)((IDWriteFont *)arg0)-&gt;GetStretch();
2023 }
2024 JNIEXPORT jint JNICALL OS_NATIVE(GetStyle)
2025     (JNIEnv *env, jclass that, jlong arg0)
2026 {
2027     return (jint)((IDWriteFont *)arg0)-&gt;GetStyle();
2028 }
2029 
2030 JNIEXPORT jint JNICALL OS_NATIVE(GetWeight)
2031     (JNIEnv *env, jclass that, jlong arg0)
2032 {
2033     return (jint)((IDWriteFont *)arg0)-&gt;GetWeight();
2034 }
2035 
2036 JNIEXPORT jlong JNICALL OS_NATIVE(GetInformationalStrings)
2037     (JNIEnv *env, jclass that, jlong arg0, jint arg1)
2038 {
2039     IDWriteLocalizedStrings* result = NULL;
2040     BOOL exists = FALSE;
2041     HRESULT hr = ((IDWriteFont *)arg0)-&gt;GetInformationalStrings((DWRITE_INFORMATIONAL_STRING_ID)arg1,
2042                                                                 &amp;result,
2043                                                                 &amp;exists);
2044     return SUCCEEDED(hr) &amp;&amp; exists ? (jlong)result : NULL;
2045 }
2046 
2047 JNIEXPORT jint JNICALL OS_NATIVE(GetSimulations)
2048     (JNIEnv *env, jclass that, jlong arg0)
2049 {
2050     return (jint)((IDWriteFont *)arg0)-&gt;GetSimulations();
2051 }
2052 
2053 /* IDWriteFontList */
2054 JNIEXPORT jint JNICALL OS_NATIVE(GetFontCount)
2055     (JNIEnv *env, jclass that, jlong arg0)
2056 {
2057     return ((IDWriteFontList *)arg0)-&gt;GetFontCount();
2058 }
2059 
2060 JNIEXPORT jlong JNICALL OS_NATIVE(GetFont)
2061     (JNIEnv *env, jclass that, jlong arg0, jint arg1)
2062 {
2063     IDWriteFont* result = NULL;
2064     HRESULT hr = ((IDWriteFontList *)arg0)-&gt;GetFont(arg1, &amp;result);
2065     return SUCCEEDED(hr) ? (jlong)result : NULL;
2066 }
2067 
2068 /* IDWriteLocalizedStrings */
2069 JNIEXPORT jcharArray JNICALL OS_NATIVE(GetString)
2070     (JNIEnv *env, jclass that, jlong arg0, jint arg1, jint arg2)
2071 {
2072     jcharArray result = NULL;
2073     WCHAR* buffer = new (std::nothrow) WCHAR[arg2];
2074     HRESULT hr = ((IDWriteLocalizedStrings *)arg0)-&gt;GetString(arg1, buffer, arg2);
2075     if (SUCCEEDED(hr)) {
2076         result = env-&gt;NewCharArray(arg2);
2077         if (result) {
2078             env-&gt;SetCharArrayRegion(result, 0, arg2, (const jchar*)buffer);
2079         }
2080     }
2081     delete [] buffer;
2082     return result;
2083 }
2084 
2085 JNIEXPORT jint JNICALL OS_NATIVE(GetStringLength)
2086     (JNIEnv *env, jclass that, jlong arg0, jint arg1)
2087 {
2088     UINT32 result = 0;
2089     HRESULT hr = ((IDWriteLocalizedStrings *)arg0)-&gt;GetStringLength(arg1, &amp;result);
2090     return SUCCEEDED(hr) ? result : 0;
2091 }
2092 
2093 JNIEXPORT jint JNICALL OS_NATIVE(FindLocaleName)
2094     (JNIEnv *env, jclass that, jlong arg0, jcharArray arg1)
2095 {
2096     HRESULT hr = E_FAIL;
2097     jchar *lparg1 = NULL;
2098     UINT32 result = 0;
2099     BOOL exists = FALSE;
2100     if (arg1) if ((lparg1 = env-&gt;GetCharArrayElements(arg1, NULL)) == NULL) goto fail;
2101     hr = ((IDWriteLocalizedStrings *)arg0)-&gt;FindLocaleName((const WCHAR *) lparg1, &amp;result, &amp;exists);
2102 fail:
2103     if (arg1 &amp;&amp; lparg1) env-&gt;ReleaseCharArrayElements(arg1, lparg1, 0);
2104     return SUCCEEDED(hr) &amp;&amp; exists ? result : -1;
2105 }
2106 
2107 /* IDWriteFontFamily */
2108 JNIEXPORT jlong JNICALL OS_NATIVE(GetFamilyNames)
2109     (JNIEnv *env, jclass that, jlong arg0)
2110 {
2111     IDWriteLocalizedStrings* result = NULL;
2112     HRESULT hr = ((IDWriteFontFamily *)arg0)-&gt;GetFamilyNames(&amp;result);
2113     return SUCCEEDED(hr) ? (jlong)result : NULL;
2114 }
2115 
2116 JNIEXPORT jlong JNICALL OS_NATIVE(GetFirstMatchingFont)
2117     (JNIEnv *env, jclass that, jlong arg0, jint arg1, jint arg2, jint arg3)
2118 {
2119     IDWriteFont* result = NULL;
2120     HRESULT hr = ((IDWriteFontFamily *)arg0)-&gt;GetFirstMatchingFont((DWRITE_FONT_WEIGHT)arg1, (DWRITE_FONT_STRETCH)arg2, (DWRITE_FONT_STYLE)arg3, &amp;result);
2121     return SUCCEEDED(hr) ? (jlong)result : NULL;
2122 }
2123 
2124 /* IDWriteFontCollection */
2125 JNIEXPORT jint JNICALL OS_NATIVE(GetFontFamilyCount)
2126     (JNIEnv *env, jclass that, jlong arg0)
2127 {
2128     return ((IDWriteFontCollection *)arg0)-&gt;GetFontFamilyCount();
2129 }
2130 
2131 JNIEXPORT jlong JNICALL OS_NATIVE(GetFontFamily__JI)
2132     (JNIEnv *env, jclass that, jlong arg0, jint arg1)
2133 {
2134     IDWriteFontFamily* result = NULL;
2135     HRESULT hr = ((IDWriteFontCollection *)arg0)-&gt;GetFontFamily(arg1, &amp;result);
2136     return SUCCEEDED(hr) ? (jlong)result : NULL;
2137 }
2138 
2139 JNIEXPORT jint JNICALL OS_NATIVE(FindFamilyName)
2140     (JNIEnv *env, jclass that, jlong arg0, jcharArray arg1)
2141 {
2142     HRESULT hr = E_FAIL;
2143     jchar *lparg1 = NULL;
2144     UINT32 result = 0;
2145     BOOL exists = FALSE;
2146     if (arg1) if ((lparg1 = env-&gt;GetCharArrayElements(arg1, NULL)) == NULL) goto fail;
2147     hr = ((IDWriteFontCollection *)arg0)-&gt;FindFamilyName((const WCHAR *) lparg1, &amp;result, &amp;exists);
2148 fail:
2149     if (arg1 &amp;&amp; lparg1) env-&gt;ReleaseCharArrayElements(arg1, lparg1, 0);
2150     return SUCCEEDED(hr) &amp;&amp; exists ? result : -1;
2151 }
2152 
2153 JNIEXPORT jlong JNICALL OS_NATIVE(GetFontFromFontFace)
2154     (JNIEnv *env, jclass that, jlong arg0, jlong arg1)
2155 {
2156     IDWriteFont* result = NULL;
2157     HRESULT hr = ((IDWriteFontCollection *)arg0)-&gt;GetFontFromFontFace((IDWriteFontFace *)arg1, &amp;result);
2158     return SUCCEEDED(hr) ? (jlong)result : NULL;
2159 }
2160 
2161 /* IDWriteGlyphRunAnalysis */
2162 JNIEXPORT jbyteArray JNICALL OS_NATIVE(CreateAlphaTexture)
2163     (JNIEnv *env, jclass that, jlong arg0, jint arg1, jobject arg2)
2164 {
2165     jbyteArray result = NULL;
2166     RECT _arg2, *lparg2 = NULL;
2167     /* In Only */
2168     if (arg2) lparg2 = getRECTFields(env, arg2, &amp;_arg2);
2169     if (!lparg2) return NULL;
2170     DWRITE_TEXTURE_TYPE textureType = (DWRITE_TEXTURE_TYPE)arg1;
2171     UINT32 width = lparg2-&gt;right - lparg2-&gt;left;
2172     UINT32 height = lparg2-&gt;bottom - lparg2-&gt;top;
2173     UINT32 bpp = textureType == DWRITE_TEXTURE_CLEARTYPE_3x1 ? 3 : 1;
2174     UINT32 bufferSize = width * height * bpp;
2175     BYTE * buffer = new (std::nothrow) BYTE[bufferSize];
2176     HRESULT hr = ((IDWriteGlyphRunAnalysis *)arg0)-&gt;CreateAlphaTexture(textureType, lparg2, buffer, bufferSize);
2177     if (SUCCEEDED(hr)) {
2178         result = env-&gt;NewByteArray(bufferSize);
2179         if (result) {
2180             env-&gt;SetByteArrayRegion(result, 0, bufferSize, (jbyte*)buffer);
2181         }
2182     }
2183     delete [] buffer;
2184     return result;
2185 }
2186 
2187 JNIEXPORT jobject JNICALL OS_NATIVE(GetAlphaTextureBounds)
2188     (JNIEnv *env, jclass that, jlong arg0, jint arg1)
2189 {
2190     jobject result = NULL;
2191     RECT rect;
2192     HRESULT hr = ((IDWriteGlyphRunAnalysis *)arg0)-&gt;GetAlphaTextureBounds((DWRITE_TEXTURE_TYPE)arg1, &amp;rect);
2193     if (SUCCEEDED(hr)) {
2194         result = newRECT(env, &amp;rect);
2195     }
2196     return result;
2197 }
2198 
2199 /* IDWriteTextAnalyzer */
2200 JNIEXPORT jint JNICALL OS_NATIVE(AnalyzeScript)
2201     (JNIEnv *env, jclass that, jlong arg0, jlong arg1, jint arg2, jint arg3, jlong arg4)
2202 {
2203     JFXTextAnalysisSink* source = (JFXTextAnalysisSink *)arg1;
2204     JFXTextAnalysisSink* sink = (JFXTextAnalysisSink *)arg4;
2205     IDWriteTextAnalyzer* analyzer = (IDWriteTextAnalyzer *)arg0;
2206     return analyzer-&gt;AnalyzeScript(source, arg2, arg3, sink);
2207 }
2208 
2209 JNIEXPORT jint JNICALL OS_NATIVE(GetGlyphs)
2210     (JNIEnv *env, jclass that, jlong arg0, jcharArray arg1, jint textStart, jint arg2, jlong arg3, jboolean arg4,
2211     jboolean arg5, jobject arg6, jcharArray arg7, jlong arg8, jlongArray arg9, jintArray arg10,
2212     jint arg11, jint arg12, jshortArray arg13, jshortArray arg14, jshortArray arg15, jshortArray arg16, jintArray arg17)
2213 {
2214     HRESULT hr = E_FAIL;
2215     jchar *lparg1=NULL;
2216     DWRITE_SCRIPT_ANALYSIS _arg6, *lparg6=NULL;
2217     jchar *lparg7=NULL;
2218     jlong *lparg9=NULL;
2219     jint *lparg10=NULL;
2220     jshort *lparg13=NULL;
2221     jshort *lparg14=NULL;
2222     jshort *lparg15=NULL;
2223     jshort *lparg16=NULL;
2224     jint *lparg17=NULL;
2225 
2226     if (arg1) if ((lparg1 = env-&gt;GetCharArrayElements(arg1, NULL)) == NULL) goto fail;
2227     if (arg6) if ((lparg6 = getDWRITE_SCRIPT_ANALYSISFields(env, arg6, &amp;_arg6)) == NULL) goto fail;
2228     if (arg7) lparg7 = env-&gt;GetCharArrayElements(arg7, NULL); /*Optional*/
2229     if (arg9) if ((lparg9 = env-&gt;GetLongArrayElements(arg9, NULL)) == NULL) goto fail;
2230     if (arg10) if ((lparg10 = env-&gt;GetIntArrayElements(arg10, NULL)) == NULL) goto fail;
2231     if (arg13) if ((lparg13 = env-&gt;GetShortArrayElements(arg13, NULL)) == NULL) goto fail;
2232     if (arg14) if ((lparg14 = env-&gt;GetShortArrayElements(arg14, NULL)) == NULL) goto fail;
2233     if (arg15) if ((lparg15 = env-&gt;GetShortArrayElements(arg15, NULL)) == NULL) goto fail;
2234     if (arg16) if ((lparg16 = env-&gt;GetShortArrayElements(arg16, NULL)) == NULL) goto fail;
2235     if (arg17) if ((lparg17 = env-&gt;GetIntArrayElements(arg17, NULL)) == NULL) goto fail;
2236     const WCHAR* text = (const WCHAR*)(lparg1 + textStart);
2237 
2238     hr = ((IDWriteTextAnalyzer *)arg0)-&gt;GetGlyphs(text,
2239                                                   (UINT32)arg2,
2240                                                   (IDWriteFontFace *)arg3,
2241                                                   (BOOL)arg4,
2242                                                   (BOOL)arg5,
2243                                                   (const DWRITE_SCRIPT_ANALYSIS *)lparg6,
2244                                                   (const WCHAR *)lparg7,
2245                                                   (IDWriteNumberSubstitution *)arg8,
2246                                                   (const DWRITE_TYPOGRAPHIC_FEATURES **)lparg9,
2247                                                   (const UINT32 *)lparg10,
2248                                                   (UINT32)arg11,
2249                                                   (UINT32)arg12,
2250                                                   (UINT16 *)lparg13,
2251                                                   (DWRITE_SHAPING_TEXT_PROPERTIES *)lparg14,
2252                                                   (UINT16 *)lparg15,
2253                                                   (DWRITE_SHAPING_GLYPH_PROPERTIES *)lparg16,
2254                                                   (UINT32 *)lparg17);
2255 
2256 fail:
2257     if (arg1 &amp;&amp; lparg1) env-&gt;ReleaseCharArrayElements(arg1, lparg1, 0);
2258     if (arg7 &amp;&amp; lparg7) env-&gt;ReleaseCharArrayElements(arg7, lparg7, 0);
2259     if (arg9 &amp;&amp; lparg9) env-&gt;ReleaseLongArrayElements(arg9, lparg9, 0);
2260     if (arg10 &amp;&amp; lparg10) env-&gt;ReleaseIntArrayElements(arg10, lparg10, 0);
2261     if (arg13 &amp;&amp; lparg13) env-&gt;ReleaseShortArrayElements(arg13, lparg13, 0);
2262     if (arg14 &amp;&amp; lparg14) env-&gt;ReleaseShortArrayElements(arg14, lparg14, 0);
2263     if (arg15 &amp;&amp; lparg15) env-&gt;ReleaseShortArrayElements(arg15, lparg15, 0);
2264     if (arg16 &amp;&amp; lparg16) env-&gt;ReleaseShortArrayElements(arg16, lparg16, 0);
2265     if (arg17 &amp;&amp; lparg17) env-&gt;ReleaseIntArrayElements(arg17, lparg17, 0);
2266     return hr;
2267 }
2268 
2269 JNIEXPORT jint JNICALL OS_NATIVE(GetGlyphPlacements)
2270     (JNIEnv *env, jclass that, jlong arg0, jcharArray arg1, jshortArray arg2,
2271     jshortArray arg3, jint textStart, jint arg4, jshortArray arg5, jshortArray arg6, jint arg7,
2272     jlong arg8, jfloat arg9, jboolean arg10, jboolean arg11, jobject arg12,
2273     jcharArray arg13, jlongArray arg14, jintArray arg15, jint arg16,
2274     jfloatArray arg17, jfloatArray arg18) {
2275 
2276     HRESULT hr = E_FAIL;
2277     jchar *lparg1=NULL;
2278     jshort *lparg2=NULL;
2279     jshort *lparg3=NULL;
2280     jshort *lparg5=NULL;
2281     jshort *lparg6=NULL;
2282     DWRITE_SCRIPT_ANALYSIS _arg12, *lparg12=NULL;
2283     jchar *lparg13=NULL;
2284     jlong *lparg14=NULL;
2285     jint *lparg15=NULL;
2286     jfloat *lparg17=NULL;
2287     jfloat *lparg18=NULL;
2288 
2289     if (arg1) if ((lparg1 = env-&gt;GetCharArrayElements(arg1, NULL)) == NULL) goto fail;
2290     if (arg2) if ((lparg2 = env-&gt;GetShortArrayElements(arg2, NULL)) == NULL) goto fail;
2291     if (arg3) if ((lparg3 = env-&gt;GetShortArrayElements(arg3, NULL)) == NULL) goto fail;
2292     if (arg5) if ((lparg5 = env-&gt;GetShortArrayElements(arg5, NULL)) == NULL) goto fail;
2293     if (arg6) if ((lparg6 = env-&gt;GetShortArrayElements(arg6, NULL)) == NULL) goto fail;
2294     if (arg12) if ((lparg12 = getDWRITE_SCRIPT_ANALYSISFields(env, arg12, &amp;_arg12)) == NULL) goto fail;
2295     if (arg13) lparg13 = env-&gt;GetCharArrayElements(arg13, NULL); /* Optional */
2296     if (arg14) if ((lparg14 = env-&gt;GetLongArrayElements(arg14, NULL)) == NULL) goto fail;
2297     if (arg15) if ((lparg15 = env-&gt;GetIntArrayElements(arg15, NULL)) == NULL) goto fail;
2298     if (arg17) if ((lparg17 = env-&gt;GetFloatArrayElements(arg17, NULL)) == NULL) goto fail;
2299     if (arg18) if ((lparg18 = env-&gt;GetFloatArrayElements(arg18, NULL)) == NULL) goto fail;
2300     const WCHAR* text = (const WCHAR*)(lparg1 + textStart);
2301 
2302     hr = ((IDWriteTextAnalyzer *)arg0)-&gt;GetGlyphPlacements(text,
2303                                                            (const UINT16 *)lparg2,
2304                                                            (DWRITE_SHAPING_TEXT_PROPERTIES *)lparg3,
2305                                                            (UINT32)arg4,
2306                                                            (const UINT16 *)lparg5,
2307                                                            (const DWRITE_SHAPING_GLYPH_PROPERTIES *)lparg6,
2308                                                            (UINT32)arg7,
2309                                                            (IDWriteFontFace *)arg8,
2310                                                            (FLOAT)arg9,
2311                                                            (BOOL)arg10,
2312                                                            (BOOL)arg11,
2313                                                            (const DWRITE_SCRIPT_ANALYSIS *)lparg12,
2314                                                            (const WCHAR *)lparg13,
2315                                                            (const DWRITE_TYPOGRAPHIC_FEATURES **)lparg14,
2316                                                            (const UINT32 *)lparg15,
2317                                                            (UINT32)arg16,
2318                                                            (FLOAT *)lparg17,
2319                                                            (DWRITE_GLYPH_OFFSET *)lparg18);
2320 
2321 fail:
2322     if (arg1 &amp;&amp; lparg1) env-&gt;ReleaseCharArrayElements(arg1, lparg1, 0);
2323     if (arg2 &amp;&amp; lparg2) env-&gt;ReleaseShortArrayElements(arg2, lparg2, 0);
2324     if (arg3 &amp;&amp; lparg3) env-&gt;ReleaseShortArrayElements(arg3, lparg3, 0);
2325     if (arg5 &amp;&amp; lparg5) env-&gt;ReleaseShortArrayElements(arg5, lparg5, 0);
2326     if (arg6 &amp;&amp; lparg6) env-&gt;ReleaseShortArrayElements(arg6, lparg6, 0);
2327     if (arg13 &amp;&amp; lparg13) env-&gt;ReleaseCharArrayElements(arg13, lparg13, 0);
2328     if (arg14 &amp;&amp; lparg14) env-&gt;ReleaseLongArrayElements(arg14, lparg14, 0);
2329     if (arg15 &amp;&amp; lparg15) env-&gt;ReleaseIntArrayElements(arg15, lparg15, 0);
2330     if (arg17 &amp;&amp; lparg17) env-&gt;ReleaseFloatArrayElements(arg17, lparg17, 0);
2331     if (arg18 &amp;&amp; lparg18) env-&gt;ReleaseFloatArrayElements(arg18, lparg18, 0);
2332 
2333     return hr;
2334 }
2335 
2336 /*IDWriteTextLayout*/
2337 JNIEXPORT jint JNICALL OS_NATIVE(Draw)
2338     (JNIEnv *env, jclass that, jlong arg0, jlong arg1, jlong arg2, jfloat arg3, jfloat arg4)
2339 {
2340     return ((IDWriteTextLayout *)arg0)-&gt;Draw((void*) arg1, (IDWriteTextRenderer *)arg2, arg3, arg4);
2341 }
2342 
2343 /* IWICImagingFactory*/
2344 JNIEXPORT jlong JNICALL OS_NATIVE(CreateBitmap)
2345     (JNIEnv *env, jclass that, jlong arg0, jint arg1, jint arg2, jint arg3, jint arg4)
2346 {
2347 
2348     IWICBitmap* result = NULL;
2349     GUID pixelFormat;
2350     switch (arg3) {
2351     case com_sun_javafx_font_directwrite_OS_GUID_WICPixelFormat8bppGray:pixelFormat = GUID_WICPixelFormat8bppGray; break;
2352     case com_sun_javafx_font_directwrite_OS_GUID_WICPixelFormat8bppAlpha:pixelFormat = GUID_WICPixelFormat8bppAlpha; break;
2353     case com_sun_javafx_font_directwrite_OS_GUID_WICPixelFormat16bppGray: pixelFormat = GUID_WICPixelFormat16bppGray; break;
2354     case com_sun_javafx_font_directwrite_OS_GUID_WICPixelFormat24bppRGB: pixelFormat = GUID_WICPixelFormat24bppRGB; break;
2355     case com_sun_javafx_font_directwrite_OS_GUID_WICPixelFormat24bppBGR: pixelFormat = GUID_WICPixelFormat24bppBGR; break;
2356     case com_sun_javafx_font_directwrite_OS_GUID_WICPixelFormat32bppBGR: pixelFormat = GUID_WICPixelFormat32bppBGR; break;
2357     case com_sun_javafx_font_directwrite_OS_GUID_WICPixelFormat32bppBGRA: pixelFormat = GUID_WICPixelFormat32bppBGRA; break;
2358     case com_sun_javafx_font_directwrite_OS_GUID_WICPixelFormat32bppPBGRA: pixelFormat = GUID_WICPixelFormat32bppPBGRA; break;
2359     case com_sun_javafx_font_directwrite_OS_GUID_WICPixelFormat32bppGrayFloat: pixelFormat = GUID_WICPixelFormat32bppGrayFloat; break;
2360     case com_sun_javafx_font_directwrite_OS_GUID_WICPixelFormat32bppRGBA: pixelFormat = GUID_WICPixelFormat32bppRGBA; break;
2361     case com_sun_javafx_font_directwrite_OS_GUID_WICPixelFormat32bppPRGBA: pixelFormat = GUID_WICPixelFormat32bppPRGBA; break;
2362     }
2363     HRESULT hr = ((IWICImagingFactory *)arg0)-&gt;CreateBitmap(arg1, arg2, (REFWICPixelFormatGUID)pixelFormat, (WICBitmapCreateCacheOption)arg4, &amp;result);
2364     return SUCCEEDED(hr) ? (jlong)result : NULL;
2365 }
2366 
2367 /*IWICBitmap*/
2368 JNIEXPORT jlong JNICALL OS_NATIVE(Lock)
2369     (JNIEnv *env, jclass that, jlong arg0, jint arg1, jint arg2, jint arg3, jint arg4, jint arg5)
2370 {
2371     HRESULT hr = E_FAIL;
2372     IWICBitmapLock* result = NULL;
2373     const WICRect rcLock = {arg1, arg2, arg3, arg4};
2374     hr = ((IWICBitmap *)arg0)-&gt;Lock(&amp;rcLock, arg5, &amp;result);
2375     return SUCCEEDED(hr) ? (jlong)result : NULL;
2376 }
2377 
2378 /*IWICBitmapLock*/
2379 JNIEXPORT jbyteArray JNICALL OS_NATIVE(GetDataPointer)
2380     (JNIEnv *env, jclass that, jlong arg0)
2381 {
2382     jbyteArray result = NULL;
2383     UINT cbBufferSize = 0;
2384     BYTE *pv = NULL;
2385     HRESULT hr = ((IWICBitmapLock *)arg0)-&gt;GetDataPointer(&amp;cbBufferSize, &amp;pv);
2386     if (SUCCEEDED(hr)) {
2387         result = env-&gt;NewByteArray(cbBufferSize);
2388         if (result) {
2389             env-&gt;SetByteArrayRegion(result, 0, cbBufferSize, (const jbyte*)pv);
2390         }
2391     }
2392     return result;
2393 }
2394 
2395 JNIEXPORT jint JNICALL OS_NATIVE(GetStride)
2396     (JNIEnv *env, jclass that, jlong arg0)
2397 {
2398     UINT result = 0;
2399     HRESULT hr = ((IWICBitmapLock *)arg0)-&gt;GetStride(&amp;result);
2400     return SUCCEEDED(hr) ? result : NULL;
2401 }
2402 
2403 
2404 /*ID2D1Factory */
2405 JNIEXPORT jlong JNICALL OS_NATIVE(CreateWicBitmapRenderTarget)
2406     (JNIEnv *env, jclass that, jlong arg0, jlong arg1, jobject arg2)
2407 {
2408     HRESULT hr = E_FAIL;
2409     ID2D1RenderTarget* result = NULL;
2410     D2D1_RENDER_TARGET_PROPERTIES _arg2, *lparg2=NULL;
2411     if (arg2) if ((lparg2 = getD2D1_RENDER_TARGET_PROPERTIESFields(env, arg2, &amp;_arg2)) == NULL) goto fail;
2412     hr = ((ID2D1Factory *)arg0)-&gt;CreateWicBitmapRenderTarget((IWICBitmap *)arg1, lparg2, &amp;result);
2413 fail:
2414     return SUCCEEDED(hr) ? (jlong)result : NULL;
2415 }
2416 
2417 /*ID2D1RenderTarget*/
2418 JNIEXPORT void JNICALL OS_NATIVE(BeginDraw)
2419     (JNIEnv *env, jclass that, jlong arg0)
2420 {
2421     ((ID2D1RenderTarget *)arg0)-&gt;BeginDraw();
2422 }
2423 
2424 JNIEXPORT jint JNICALL OS_NATIVE(EndDraw)
2425     (JNIEnv *env, jclass that, jlong arg0)
2426 {
2427     return (jint) ((ID2D1RenderTarget *)arg0)-&gt;EndDraw();
2428 }
2429 
2430 JNIEXPORT void JNICALL OS_NATIVE(Clear)
2431     (JNIEnv *env, jclass that, jlong arg0, jobject arg1)
2432 {
2433     D2D1_COLOR_F _arg1, *lparg1=NULL;
2434     if (arg1) if ((lparg1 = getD2D1_COLOR_FFields(env, arg1, &amp;_arg1)) == NULL) return;
2435     ((ID2D1RenderTarget *)arg0)-&gt;Clear(lparg1);
2436 }
2437 
2438 JNIEXPORT void JNICALL OS_NATIVE(SetTextAntialiasMode)
2439     (JNIEnv *env, jclass that, jlong arg0, jint arg1)
2440 {
2441     ((ID2D1RenderTarget *)arg0)-&gt;SetTextAntialiasMode((D2D1_TEXT_ANTIALIAS_MODE)arg1);
2442 }
2443 
2444 JNIEXPORT void JNICALL OS_NATIVE(SetTransform)
2445     (JNIEnv *env, jclass that, jlong arg0, jobject arg1)
2446 {
2447     D2D1_MATRIX_3X2_F _arg1, *lparg1=NULL;
2448     if (arg1) if ((lparg1 = getD2D1_MATRIX_3X2_FFields(env, arg1, &amp;_arg1)) == NULL) return;
2449     ((ID2D1RenderTarget *)arg0)-&gt;SetTransform(lparg1);
2450 }
2451 
2452 JNIEXPORT void JNICALL OS_NATIVE(DrawGlyphRun)
2453     (JNIEnv *env, jclass that, jlong arg0, jobject arg1, jobject arg2, jlong arg3, jint arg4)
2454 {
2455     D2D1_POINT_2F _arg1, *lparg1=NULL;
2456     DWRITE_GLYPH_RUN _arg2, *lparg2=NULL;
2457     _arg2.glyphCount = 1;
2458     _arg2.glyphIndices = new (std::nothrow) UINT16 [1];
2459     _arg2.glyphAdvances = new (std::nothrow) FLOAT [1];
2460     _arg2.glyphOffsets = new (std::nothrow) DWRITE_GLYPH_OFFSET [1];
2461     if (arg1) if ((lparg1 = getD2D1_POINT_2FFields(env, arg1, &amp;_arg1)) == NULL) goto fail;
2462     if (arg2) if ((lparg2 = getDWRITE_GLYPH_RUNFields(env, arg2, &amp;_arg2)) == NULL) goto fail;
2463     ((ID2D1RenderTarget *)arg0)-&gt;DrawGlyphRun(_arg1, lparg2, (ID2D1Brush *)arg3, (DWRITE_MEASURING_MODE)arg4);
2464 fail:
2465     delete [] _arg2.glyphIndices;
2466     delete [] _arg2.glyphAdvances;
2467     delete [] _arg2.glyphOffsets;
2468 }
2469 
2470 JNIEXPORT jlong JNICALL OS_NATIVE(CreateSolidColorBrush)
2471     (JNIEnv *env, jclass that, jlong arg0, jobject arg1)
2472 {
2473     HRESULT hr = E_FAIL;
2474     ID2D1SolidColorBrush* result = NULL;
2475     D2D1_COLOR_F _arg1, *lparg1=NULL;
2476     if (arg1) if ((lparg1 = getD2D1_COLOR_FFields(env, arg1, &amp;_arg1)) == NULL) goto fail;
2477     hr = ((ID2D1RenderTarget *)arg0)-&gt;CreateSolidColorBrush(_arg1, &amp;result);
2478 fail:
2479     return SUCCEEDED(hr) ? (jlong)result : NULL;
2480 }
2481 
2482 #endif /* WIN32 */
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>