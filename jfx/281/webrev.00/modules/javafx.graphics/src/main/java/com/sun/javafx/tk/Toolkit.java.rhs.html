<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/com/sun/javafx/tk/Toolkit.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.javafx.tk;
 27 
 28 import javafx.application.ConditionalFeature;
 29 import javafx.beans.property.ReadOnlyObjectProperty;
 30 import javafx.geometry.Dimension2D;
 31 import javafx.scene.Scene;
 32 import javafx.scene.effect.BlurType;
 33 import javafx.scene.image.Image;
 34 import javafx.scene.image.PixelFormat;
 35 import javafx.scene.image.WritableImage;
 36 import javafx.scene.input.Dragboard;
 37 import javafx.scene.input.InputMethodRequests;
 38 import javafx.scene.input.KeyCode;
 39 import javafx.scene.input.KeyEvent;
 40 import javafx.scene.input.TransferMode;
 41 import javafx.scene.paint.Color;
 42 import javafx.scene.paint.ImagePattern;
 43 import javafx.scene.paint.LinearGradient;
 44 import javafx.scene.paint.Paint;
 45 import javafx.scene.paint.RadialGradient;
 46 import javafx.scene.paint.Stop;
 47 import javafx.scene.shape.PathElement;
 48 import javafx.scene.shape.SVGPath;
 49 import javafx.scene.shape.StrokeLineCap;
 50 import javafx.scene.shape.StrokeLineJoin;
 51 import javafx.scene.shape.StrokeType;
 52 import javafx.stage.FileChooser.ExtensionFilter;
 53 import javafx.stage.Modality;
 54 import javafx.stage.Stage;
 55 import javafx.stage.StageStyle;
 56 import javafx.stage.Window;
 57 import java.io.File;
 58 import java.io.IOException;
 59 import java.io.InputStream;
 60 import java.nio.ByteBuffer;
 61 import java.security.AccessControlContext;
 62 import java.security.AccessController;
 63 import java.security.PrivilegedAction;
 64 import java.util.ArrayList;
 65 import java.util.HashSet;
 66 import java.util.Iterator;
 67 import java.util.List;
 68 import java.util.Map;
 69 import java.util.Set;
 70 import java.util.WeakHashMap;
 71 import java.util.concurrent.CountDownLatch;
 72 import java.util.concurrent.Future;
 73 import com.sun.glass.ui.CommonDialogs.FileChooserResult;
 74 import com.sun.glass.ui.GlassRobot;
 75 import com.sun.glass.utils.NativeLibLoader;
 76 import com.sun.javafx.PlatformUtil;
 77 import com.sun.javafx.beans.event.AbstractNotifyListener;
 78 import com.sun.javafx.embed.HostInterface;
 79 import com.sun.javafx.geom.Path2D;
 80 import com.sun.javafx.geom.transform.BaseTransform;
 81 import com.sun.javafx.perf.PerformanceTracker;
 82 import com.sun.javafx.runtime.VersionInfo;
 83 import com.sun.javafx.runtime.async.AsyncOperation;
 84 import com.sun.javafx.runtime.async.AsyncOperationListener;
 85 import com.sun.javafx.scene.SceneHelper;
 86 import com.sun.javafx.scene.text.TextLayoutFactory;
 87 import com.sun.javafx.sg.prism.NGCamera;
 88 import com.sun.javafx.sg.prism.NGLightBase;
 89 import com.sun.javafx.sg.prism.NGNode;
 90 import com.sun.javafx.util.Utils;
 91 import com.sun.scenario.DelayedRunnable;
 92 import com.sun.scenario.animation.AbstractMasterTimer;
 93 import com.sun.scenario.effect.AbstractShadow.ShadowMode;
 94 import com.sun.scenario.effect.Color4f;
 95 import com.sun.scenario.effect.FilterContext;
 96 import com.sun.scenario.effect.Filterable;
 97 
 98 
 99 public abstract class Toolkit {
100     private static String tk;
101     private static Toolkit TOOLKIT;
102     private static Thread fxUserThread = null;
103 
104     private static final String QUANTUM_TOOLKIT     = &quot;com.sun.javafx.tk.quantum.QuantumToolkit&quot;;
105     private static final String DEFAULT_TOOLKIT     = QUANTUM_TOOLKIT;
106 
107     private static final Map gradientMap = new WeakHashMap();
108 
109     private static final boolean verbose = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.verbose&quot;));
110 
111     private static final String[] msLibNames = {
112         &quot;api-ms-win-core-console-l1-1-0&quot;,
113         &quot;api-ms-win-core-console-l1-2-0&quot;,
114         &quot;api-ms-win-core-datetime-l1-1-0&quot;,
115         &quot;api-ms-win-core-debug-l1-1-0&quot;,
116         &quot;api-ms-win-core-errorhandling-l1-1-0&quot;,
117         &quot;api-ms-win-core-file-l1-1-0&quot;,
118         &quot;api-ms-win-core-file-l1-2-0&quot;,
119         &quot;api-ms-win-core-file-l2-1-0&quot;,
120         &quot;api-ms-win-core-handle-l1-1-0&quot;,
121         &quot;api-ms-win-core-heap-l1-1-0&quot;,
122         &quot;api-ms-win-core-interlocked-l1-1-0&quot;,
123         &quot;api-ms-win-core-libraryloader-l1-1-0&quot;,
124         &quot;api-ms-win-core-localization-l1-2-0&quot;,
125         &quot;api-ms-win-core-memory-l1-1-0&quot;,
126         &quot;api-ms-win-core-namedpipe-l1-1-0&quot;,
127         &quot;api-ms-win-core-processenvironment-l1-1-0&quot;,
128         &quot;api-ms-win-core-processthreads-l1-1-0&quot;,
129         &quot;api-ms-win-core-processthreads-l1-1-1&quot;,
130         &quot;api-ms-win-core-profile-l1-1-0&quot;,
131         &quot;api-ms-win-core-rtlsupport-l1-1-0&quot;,
132         &quot;api-ms-win-core-string-l1-1-0&quot;,
133         &quot;api-ms-win-core-synch-l1-1-0&quot;,
134         &quot;api-ms-win-core-synch-l1-2-0&quot;,
135         &quot;api-ms-win-core-sysinfo-l1-1-0&quot;,
136         &quot;api-ms-win-core-timezone-l1-1-0&quot;,
137         &quot;api-ms-win-core-util-l1-1-0&quot;,
138         &quot;api-ms-win-crt-conio-l1-1-0&quot;,
139         &quot;api-ms-win-crt-convert-l1-1-0&quot;,
140         &quot;api-ms-win-crt-environment-l1-1-0&quot;,
141         &quot;api-ms-win-crt-filesystem-l1-1-0&quot;,
142         &quot;api-ms-win-crt-heap-l1-1-0&quot;,
143         &quot;api-ms-win-crt-locale-l1-1-0&quot;,
144         &quot;api-ms-win-crt-math-l1-1-0&quot;,
145         &quot;api-ms-win-crt-multibyte-l1-1-0&quot;,
146         &quot;api-ms-win-crt-private-l1-1-0&quot;,
147         &quot;api-ms-win-crt-process-l1-1-0&quot;,
148         &quot;api-ms-win-crt-runtime-l1-1-0&quot;,
149         &quot;api-ms-win-crt-stdio-l1-1-0&quot;,
150         &quot;api-ms-win-crt-string-l1-1-0&quot;,
151         &quot;api-ms-win-crt-time-l1-1-0&quot;,
152         &quot;api-ms-win-crt-utility-l1-1-0&quot;,
153         &quot;ucrtbase&quot;,
154 
155         // Finally load VS 2017 DLLs in the following order
156         &quot;vcruntime140&quot;,
157         &quot;vcruntime140_1&quot;,
158         &quot;msvcp140&quot;
159 };
160 
161     private static String lookupToolkitClass(String name) {
162         if (&quot;prism&quot;.equalsIgnoreCase(name)) {
163             return QUANTUM_TOOLKIT;
164         } else if (&quot;quantum&quot;.equalsIgnoreCase(name)) {
165             return QUANTUM_TOOLKIT;
166         }
167         return name;
168     }
169 
170     public static synchronized void loadMSWindowsLibraries() {
171         for (String libName : msLibNames) {
172             try {
173                 NativeLibLoader.loadLibrary(libName);
174             } catch (Throwable t) {
175                 if (verbose) {
176                     System.err.println(&quot;Error: failed to load &quot;
177                             + libName + &quot;.dll : &quot; + t);
178                 }
179             }
180         }
181     }
182 
183     private static String getDefaultToolkit() {
184         if (PlatformUtil.isWindows()) {
185             return DEFAULT_TOOLKIT;
186         } else if (PlatformUtil.isMac()) {
187             return DEFAULT_TOOLKIT;
188         } else if (PlatformUtil.isLinux()) {
189             return DEFAULT_TOOLKIT;
190         } else if (PlatformUtil.isIOS()) {
191             return DEFAULT_TOOLKIT;
192         } else if (PlatformUtil.isAndroid()) {
193            return DEFAULT_TOOLKIT;
194         }
195 
196         throw new UnsupportedOperationException(System.getProperty(&quot;os.name&quot;) + &quot; is not supported&quot;);
197     }
198 
199     public static synchronized Toolkit getToolkit() {
200         if (TOOLKIT != null) {
201             return TOOLKIT;
202         }
203 
204         AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
205             // Get the javafx.version and javafx.runtime.version from a preconstructed
206             // java class, VersionInfo, created at build time.
207             VersionInfo.setupSystemProperties();
208             return null;
209         });
210 
211         // Load required Microsoft runtime DLLs on Windows platforms
212         if (PlatformUtil.isWindows()) {
213             loadMSWindowsLibraries();
214         }
215 
216         boolean userSpecifiedToolkit = true;
217 
218         // Check a system property to see if there is a specific toolkit to use.
219         // This is not a doPriviledged check so that applets cannot use this.
220         String forcedToolkit = null;
221         try {
222             forcedToolkit = System.getProperty(&quot;javafx.toolkit&quot;);
223         } catch (SecurityException ex) {}
224 
225         if (forcedToolkit == null) {
226             forcedToolkit = tk;
227         }
228         if (forcedToolkit == null) {
229             userSpecifiedToolkit = false;
230             forcedToolkit = getDefaultToolkit();
231         }
232 
233         if (forcedToolkit.indexOf(&#39;.&#39;) == -1) {
234             // Turn a short name into a fully qualified classname
235             forcedToolkit = lookupToolkitClass(forcedToolkit);
236         }
237 
238         boolean printToolkit = verbose
239                 || (userSpecifiedToolkit &amp;&amp; !forcedToolkit.endsWith(&quot;StubToolkit&quot;));
240 
241         try {
242             Class clz = null;
243 
244             try {
245                 // try our priveledged loader first
246                 final ClassLoader loader = Toolkit.class.getClassLoader();
247                 clz = Class.forName(forcedToolkit, false, loader);
248             } catch (ClassNotFoundException e) {
249                 // fall back and try the application class loader
250                 final ClassLoader loader = Thread.currentThread().getContextClassLoader();
251                 clz = Class.forName(forcedToolkit, false, loader);
252             }
253 
254             // Check that clz is a subclass of Toolkit
255             if (!Toolkit.class.isAssignableFrom(clz)) {
256                 throw new IllegalArgumentException(&quot;Unrecognized FX Toolkit class: &quot;
257                         + forcedToolkit);
258             }
259 
260             TOOLKIT = (Toolkit)clz.newInstance();
261             if (TOOLKIT.init()) {
262                 if (printToolkit) {
263                     System.err.println(&quot;JavaFX: using &quot; + forcedToolkit);
264                 }
265                 return TOOLKIT;
266             }
267             TOOLKIT = null;
268         } catch (Exception any) {
269             TOOLKIT = null;
270             any.printStackTrace();
271         }
272 
273         throw new RuntimeException(&quot;No toolkit found&quot;);
274     }
275 
276     protected static Thread getFxUserThread() {
277         return fxUserThread;
278     }
279 
280     protected static void setFxUserThread(Thread t) {
281         if (fxUserThread != null) {
282             throw new IllegalStateException(&quot;Error: FX User Thread already initialized&quot;);
283         }
284 
285         fxUserThread = t;
286     }
287 
288     public void checkFxUserThread() {
289         // Throw exception if not on FX user thread
290         if (!isFxUserThread()) {
291             throw new IllegalStateException(&quot;Not on FX application thread; currentThread = &quot;
292                     + Thread.currentThread().getName());
293         }
294     }
295 
296     // Toolkit can override this if needed
297     public boolean isFxUserThread() {
298         return Thread.currentThread() == fxUserThread;
299     }
300 
301     protected Toolkit() {
302     }
303 
304     public abstract boolean init();
305 
306     /**
307      * Indicates whether or not a nested event loop can be started
308      * from the current thread in the current state. Note that a nested
309      * event loop is not allowed outside of an event handler.
310      *
311      * @return flag indicating whether a nested event loop can be started.
312      */
313     public abstract boolean canStartNestedEventLoop();
314 
315     /**
316      * Enter a nested event loop and block until the corresponding
317      * exitNestedEventLoop call is made.
318      * The key passed into this method is used to
319      * uniquely identify the matched enter/exit pair. This method creates a
320      * new nested event loop and blocks until the corresponding
321      * exitNestedEventLoop method is called with the same key.
322      * The return value of this method will be the {@code rval}
323      * object supplied to the exitNestedEventLoop method call that unblocks it.
324      *
325      * @param key the Object that identifies the nested event loop, which
326      * must not be null
327      *
328      * @throws IllegalArgumentException if the specified key is associated
329      * with a nested event loop that has not yet returned
330      *
331      * @throws NullPointerException if the key is null
332      *
333      * @throws IllegalStateException if this method is called on a thread
334      * other than the FX Application thread
335      *
336      * @return the value passed into the corresponding call to exitEventLoop
337      */
338     public abstract Object enterNestedEventLoop(Object key);
339 
340     /**
341      * Exit a nested event loop and unblock the caller of the
342      * corresponding enterNestedEventLoop.
343      * The key passed into this method is used to
344      * uniquely identify the matched enter/exit pair. This method causes the
345      * nested event loop that was previously created with the key to exit and
346      * return control to the caller. If the specified nested event loop is not
347      * the inner-most loop then it will not return until all other inner loops
348      * also exit.
349      *
350      * @param key the Object that identifies the nested event loop, which
351      * must not be null
352      *
353      * @param rval an Object that is returned to the caller of the
354      * corresponding enterNestedEventLoop. This may be null.
355      *
356      * @throws IllegalArgumentException if the specified key is not associated
357      * with an active nested event loop
358      *
359      * @throws NullPointerException if the key is null
360      *
361      * @throws IllegalStateException if this method is called on a thread
362      * other than the FX Application thread
363      */
364     public abstract void exitNestedEventLoop(Object key, Object rval);
365 
366     public abstract void exitAllNestedEventLoops();
367 
368     public abstract boolean isNestedLoopRunning();
369 
370     public abstract TKStage createTKStage(Window peerWindow, boolean securityDialog, StageStyle stageStyle, boolean primary, Modality modality, TKStage owner, boolean rtl, AccessControlContext acc);
371 
372     public abstract TKStage createTKPopupStage(Window peerWindow, StageStyle popupStyle, TKStage owner, AccessControlContext acc);
373     public abstract TKStage createTKEmbeddedStage(HostInterface host, AccessControlContext acc);
374 
375     /**
376      * Creates an AppletWindow using the provided window pointer as the parent
377      * window.
378      *
379      * @param parent the native parent which will contain the primary stage
380      * window(s). Used on Windows/Linux platforms.
381      *
382      * @param serverName the name of CARemoteLayerServer which
383      * will be used to register native layer. Used on Mac platform.
384      */
385     public abstract AppletWindow createAppletWindow(long parent, String serverName);
386 
387     /**
388      * Perform cleanup in preparation for applet termination, including closing
389      * the applet window.
390      */
391     public abstract void closeAppletWindow();
392 
393     private final Map&lt;TKPulseListener,AccessControlContext&gt; stagePulseListeners =
394             new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
395     private final Map&lt;TKPulseListener,AccessControlContext&gt; scenePulseListeners =
396             new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
397     private final Map&lt;TKPulseListener,AccessControlContext&gt; postScenePulseListeners =
398             new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
399     private final Map&lt;TKListener,AccessControlContext&gt; toolkitListeners =
400             new WeakHashMap&lt;TKListener,AccessControlContext&gt;();
401 
402     // The set of shutdown hooks is strongly held to avoid premature GC.
403     private final Set&lt;Runnable&gt; shutdownHooks = new HashSet&lt;Runnable&gt;();
404 
405     private void runPulse(final TKPulseListener listener,
406             final AccessControlContext acc) {
407 
408         if (acc == null) {
409             throw new IllegalStateException(&quot;Invalid AccessControlContext&quot;);
410         }
411 
412         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
413             listener.pulse();
414             return null;
415         }, acc);
416     }
417 
418     public void firePulse() {
419         // Stages need to be notified of pulses before scenes so the Stage can resized
420         // and those changes propogated to scene before it gets its pulse to update
421 
422         // Copy of listener map
423         final Map&lt;TKPulseListener,AccessControlContext&gt; stagePulseList =
424                 new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
425         final Map&lt;TKPulseListener,AccessControlContext&gt; scenePulseList =
426                 new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
427         final Map&lt;TKPulseListener,AccessControlContext&gt; postScenePulseList =
428                 new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
429 
430         synchronized (this) {
431             stagePulseList.putAll(stagePulseListeners);
432             scenePulseList.putAll(scenePulseListeners);
433             postScenePulseList.putAll(postScenePulseListeners);
434         }
435         for (Map.Entry&lt;TKPulseListener,AccessControlContext&gt; entry : stagePulseList.entrySet()) {
436             runPulse(entry.getKey(), entry.getValue());
437         }
438         for (Map.Entry&lt;TKPulseListener,AccessControlContext&gt; entry : scenePulseList.entrySet()) {
439             runPulse(entry.getKey(), entry.getValue());
440         }
441         for (Map.Entry&lt;TKPulseListener,AccessControlContext&gt; entry : postScenePulseList.entrySet()) {
442             runPulse(entry.getKey(), entry.getValue());
443         }
444 
445         if (lastTkPulseListener != null) {
446             runPulse(lastTkPulseListener, lastTkPulseAcc);
447         }
448     }
449     public void addStageTkPulseListener(TKPulseListener listener) {
450         if (listener == null) {
451             return;
452         }
453         synchronized (this) {
454             AccessControlContext acc = AccessController.getContext();
455             stagePulseListeners.put(listener, acc);
456         }
457     }
458     public void removeStageTkPulseListener(TKPulseListener listener) {
459         synchronized (this) {
460             stagePulseListeners.remove(listener);
461         }
462     }
463     public void addSceneTkPulseListener(TKPulseListener listener) {
464         if (listener == null) {
465             return;
466         }
467         synchronized (this) {
468             AccessControlContext acc = AccessController.getContext();
469             scenePulseListeners.put(listener, acc);
470         }
471     }
472     public void removeSceneTkPulseListener(TKPulseListener listener) {
473         synchronized (this) {
474             scenePulseListeners.remove(listener);
475         }
476     }
477     public void addPostSceneTkPulseListener(TKPulseListener listener) {
478         if (listener == null) {
479             return;
480         }
481         synchronized (this) {
482             AccessControlContext acc = AccessController.getContext();
483             postScenePulseListeners.put(listener, acc);
484         }
485     }
486     public void removePostSceneTkPulseListener(TKPulseListener listener) {
487         synchronized (this) {
488             postScenePulseListeners.remove(listener);
489         }
490     }
491 
492     public void addTkListener(TKListener listener) {
493         if (listener == null) {
494             return;
495         }
496         AccessControlContext acc = AccessController.getContext();
497         toolkitListeners.put(listener, acc);
498     }
499 
500     public void removeTkListener(TKListener listener) {
501         toolkitListeners.remove(listener);
502     }
503 
504     private TKPulseListener lastTkPulseListener = null;
505     private AccessControlContext lastTkPulseAcc = null;
506     public void setLastTkPulseListener(TKPulseListener listener) {
507         lastTkPulseAcc = AccessController.getContext();
508         lastTkPulseListener = listener;
509     }
510 
511     public void addShutdownHook(Runnable hook) {
512         if (hook == null) {
513             return;
514         }
515         synchronized (shutdownHooks) {
516             shutdownHooks.add(hook);
517         }
518     }
519 
520     public void removeShutdownHook(Runnable hook) {
521         synchronized (shutdownHooks) {
522             shutdownHooks.remove(hook);
523         }
524     }
525 
526     protected void notifyShutdownHooks() {
527         List&lt;Runnable&gt; hooks;
528         synchronized (shutdownHooks) {
529             hooks = new ArrayList&lt;Runnable&gt;(shutdownHooks);
530             shutdownHooks.clear();
531         }
532 
533         for (Runnable hook : hooks) {
534             hook.run();
535         }
536     }
537 
538     public void notifyWindowListeners(final List&lt;TKStage&gt; windows) {
539         for (Map.Entry&lt;TKListener,AccessControlContext&gt; entry : toolkitListeners.entrySet()) {
540             final TKListener listener = entry.getKey();
541             final AccessControlContext acc = entry.getValue();
542             if (acc == null) {
543                 throw new IllegalStateException(&quot;Invalid AccessControlContext&quot;);
544             }
545 
546             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
547                 listener.changedTopLevelWindows(windows);
548                 return null;
549             }, acc);
550         }
551     }
552 
553     public void notifyLastNestedLoopExited() {
554         for (TKListener listener: toolkitListeners.keySet()) {
555             listener.exitedLastNestedLoop();
556         }
557     }
558 
559     // notify the pulse timer code that we need the next pulse to happen
560     // this flag is cleared each cycle so subsequent pulses must be requested
561     public abstract void requestNextPulse();
562 
563     public abstract Future addRenderJob(RenderJob rj);
564 
565     public abstract ImageLoader loadImage(String url,
566                                           double width, double height,
567                                           boolean preserveRatio,
568                                           boolean smooth);
569     public abstract ImageLoader loadImage(InputStream stream,
570                                           double width, double height,
571                                           boolean preserveRatio,
572                                           boolean smooth);
573     public abstract AsyncOperation loadImageAsync(
574                                           AsyncOperationListener&lt;? extends ImageLoader&gt; listener,
575                                           String url,
576                                           double width, double height,
577                                           boolean preserveRatio,
578                                           boolean smooth);
579 
580     /*
581      * The loadPlatformImage method supports the following image types:
582      *   - an object returned by the renderToImage method
583      *   - an instance of com.sun.prism.Image (in case of prism)
584      *   - an instance of an external image object, which can be a BufferedImage
585      * If JavaFX Image had one more constructor Image(ImageLoader),
586      * we could introduce a different method for external image loading support.
587      */
588 
589     public abstract ImageLoader loadPlatformImage(Object platformImage);
590 
591     public abstract PlatformImage createPlatformImage(int w, int h);
592 
593     // Indicates the default state of smooth for ImageView and MediaView
594     // Subclasses may override this to provide a platform-specific default
595     public boolean getDefaultImageSmooth() { return true; }
596 
597     public abstract void startup(Runnable runnable);
598     public abstract void defer(Runnable runnable);
599     public void exit() {
600         fxUserThread = null;
601     }
602 
603     public abstract Map&lt;Object, Object&gt; getContextMap();
604     public abstract int getRefreshRate();
605     public abstract void setAnimationRunnable(DelayedRunnable animationRunnable);
606     public abstract PerformanceTracker getPerformanceTracker();
607     public abstract PerformanceTracker createPerformanceTracker();
608 
609     //to be used for testing only
610     public abstract void waitFor(Task t);
611 
612     private Object checkSingleColor(List&lt;Stop&gt; stops) {
613         if (stops.size() == 2) {
614             Color c = stops.get(0).getColor();
615             if (c.equals(stops.get(1).getColor())) {
616                 return Toolkit.getPaintAccessor().getPlatformPaint(c);
617             }
618         }
619         return null;
620     }
621 
622     private Object getPaint(LinearGradient paint) {
623         Object p = gradientMap.get(paint);
624         if (p != null) {
625             return p;
626         }
627         p = checkSingleColor(paint.getStops());
628         if (p == null) {
629             p = createLinearGradientPaint(paint);
630         }
631         gradientMap.put(paint, p);
632         return p;
633     }
634 
635     private Object getPaint(RadialGradient paint) {
636         Object p = gradientMap.get(paint);
637         if (p != null) {
638             return p;
639         }
640         p = checkSingleColor(paint.getStops());
641         if (p == null) {
642             p = createRadialGradientPaint(paint);
643         }
644         gradientMap.put(paint, p);
645         return p;
646     }
647 
648     public Object getPaint(Paint paint) {
649         if (paint instanceof Color) {
650             return createColorPaint((Color) paint);
651         }
652 
653         if (paint instanceof LinearGradient) {
654             return getPaint((LinearGradient) paint);
655         }
656 
657         if (paint instanceof RadialGradient) {
658             return getPaint((RadialGradient) paint);
659         }
660 
661         if (paint instanceof ImagePattern) {
662             return createImagePatternPaint((ImagePattern) paint);
663         }
664 
665         return null;
666     }
667 
668     protected static final double clampStopOffset(double offset) {
669         return (offset &gt; 1.0) ? 1.0 :
670                (offset &lt; 0.0) ? 0.0 : offset;
671     }
672 
673     protected abstract Object createColorPaint(Color paint);
674     protected abstract Object createLinearGradientPaint(LinearGradient paint);
675     protected abstract Object createRadialGradientPaint(RadialGradient paint);
676     protected abstract Object createImagePatternPaint(ImagePattern paint);
677 
678     public abstract void
679         accumulateStrokeBounds(com.sun.javafx.geom.Shape shape,
680                                float bbox[],
681                                StrokeType type,
682                                double strokewidth,
683                                StrokeLineCap cap,
684                                StrokeLineJoin join,
685                                float miterLimit,
686                                BaseTransform tx);
687 
688     public abstract boolean
689         strokeContains(com.sun.javafx.geom.Shape shape,
690                        double x, double y,
691                        StrokeType type,
692                        double strokewidth,
693                        StrokeLineCap cap,
694                        StrokeLineJoin join,
695                        float miterLimit);
696 
697     public abstract com.sun.javafx.geom.Shape
698         createStrokedShape(com.sun.javafx.geom.Shape shape,
699                            StrokeType type,
700                            double strokewidth,
701                            StrokeLineCap cap,
702                            StrokeLineJoin join,
703                            float miterLimit,
704                            float[] dashArray,
705                            float dashOffset);
706 
707     public abstract int getKeyCodeForChar(String character);
708     public abstract Dimension2D getBestCursorSize(int preferredWidth, int preferredHeight);
709     public abstract int getMaximumCursorColors();
710     public abstract PathElement[] convertShapeToFXPath(Object shape);
711 
712     public abstract Filterable toFilterable(Image img);
713     public abstract FilterContext getFilterContext(Object config);
714 
715     public abstract boolean isForwardTraversalKey(KeyEvent e);
716     public abstract boolean isBackwardTraversalKey(KeyEvent e);
717 
718     public abstract AbstractMasterTimer getMasterTimer();
719 
720     public abstract FontLoader getFontLoader();
721     public abstract TextLayoutFactory getTextLayoutFactory();
722 
723     public abstract Object createSVGPathObject(SVGPath svgpath);
724     public abstract Path2D createSVGPath2D(SVGPath svgpath);
725 
726     /**
727      * Tests whether the pixel on the given coordinates in the given image
728      * is non-empty (not fully transparent). Return value is not defined
729      * for pixels out of the image bounds.
730      */
731     public abstract boolean imageContains(Object image, float x, float y);
732 
733     public abstract TKClipboard getSystemClipboard();
734 
735     public TKClipboard createLocalClipboard() {
736         return new LocalClipboard();
737     }
738 
739     public abstract TKSystemMenu getSystemMenu();
740 
741     public abstract TKClipboard getNamedClipboard(String name);
742 
743     public boolean isSupported(ConditionalFeature feature) { return false; }
744 
745     public boolean isMSAASupported() { return false; }
746 
747     public abstract ScreenConfigurationAccessor setScreenConfigurationListener(TKScreenConfigurationListener listener);
748 
749     public abstract Object getPrimaryScreen();
750 
751     public abstract List&lt;?&gt; getScreens();
752 
753     public abstract ScreenConfigurationAccessor getScreenConfigurationAccessor();
754 
755     public abstract void registerDragGestureListener(TKScene s, Set&lt;TransferMode&gt; tm, TKDragGestureListener l);
756 
757     /**
758      * This function is called when a drag originates within a JavaFX application.
759      * This means that drags that originate in other applications / from the OS
760      * do not call this function.
761      * The argument o represents an object used to identify a scene on which
762      * the drag has started.
763      */
764     public abstract void startDrag(TKScene scene, Set&lt;TransferMode&gt; tm, TKDragSourceListener l, Dragboard dragboard);
765 
766     // template function which can be implemented by toolkit impls such that they
767     // can be informed when a drag and drop operation has completed. This allows
768     // for any cleanup that may need to be done.
769     public void stopDrag(Dragboard dragboard) {
770         // no-op
771     }
772 
773     public abstract void enableDrop(TKScene s, TKDropTargetListener l);
774 
775     public interface Task {
776         boolean isFinished();
777     }
778 
779     public Color4f toColor4f(Color color) {
780         return new Color4f((float)color.getRed(), (float)color.getGreen(), (float)color.getBlue(), (float)color.getOpacity());
781     }
782 
783 
784     public ShadowMode toShadowMode(BlurType blurType) {
785         switch (blurType) {
786             case ONE_PASS_BOX:
787                 return ShadowMode.ONE_PASS_BOX;
788             case TWO_PASS_BOX:
789                 return ShadowMode.TWO_PASS_BOX;
790             case THREE_PASS_BOX:
791                 return ShadowMode.THREE_PASS_BOX;
792             default:
793                 return ShadowMode.GAUSSIAN;
794         }
795     }
796 
797     public abstract void installInputMethodRequests(TKScene scene, InputMethodRequests requests);
798 
799     /*
800      * ImageRenderingContext holds the many parameters passed to
801      * the renderToImage method.
802      * The use of the parameters is specified by the renderToImage
803      * method.
804      * @see #renderToImage
805      */
806     public static class ImageRenderingContext {
807         // Node to be rendered
808         public NGNode root;
809 
810         // Viewport for rendering
811         public int x;
812         public int y;
813         public int width;
814         public int height;
815 
816         // Initial transform for root node
817         public BaseTransform transform;
818 
819         // Rendering parameters either from Scene or SnapShotParams
820         public boolean depthBuffer;
821         public Object platformPaint;
822         public NGCamera camera;
823         public NGLightBase[] lights;
824 
825         // PlatformImage into which to render or null
826         public Object platformImage;
827     }
828 
829     /*
830      * This method renders a PG-graph to a platform image object.
831      * The returned object can be turned into a useable
832      * scene graph image using the appropriate factor of the
833      * Image class.
834      * The scale specified in the params is used to scale the
835      * entire rendering before any transforms in the nodes are
836      * applied.
837      * The width and height specified in the params represent
838      * the user space dimensions to be rendered.  The returned
839      * image will be large enough to hold these dimensions
840      * scaled by the scale parameter.
841      * The depthBuffer specified in the params is used to determine
842      * with or without depthBuffer rendering should be performed.
843      * The root node is the root of a tree of toolkit-specific
844      * scene graph peer nodes to be rendered and should have
845      * been previously created by this toolkit.
846      * The platformPaint specified in the params must be
847      * generated by the appropriate Toolkit.createPaint method
848      * and is used to fill the background of the image before
849      * rendering the scene graph.
850      * The platformImage specified in the params may be non-null
851      * and should be a previous return value from this method.
852      * If it is non-null then it may be reused as the return value
853      * of this method if it is still valid and large enough to
854      * hold the requested size.
855      *
856      * @param context a ImageRenderingContext instance specifying
857      *               the various rendering parameters
858      * @return a platform specific image object
859      * @see Toolkit.getImageAccessor().fromPlatformImage
860      */
861 
862     public abstract Object renderToImage(ImageRenderingContext context);
863 
864     /**
865      * Returns the key code for the key which is commonly used on the
866      * corresponding platform as a modifier key in shortcuts. For example
867      * it is {@code KeyCode.CONTROL} on Windows (Ctrl + C, Ctrl + V ...) and
868      * {@code KeyCode.META} on MacOS (Cmd + C, Cmd + V ...).
869      *
870      * @return the key code for shortcut modifier key
871      */
872     public KeyCode getPlatformShortcutKey() {
873         return PlatformUtil.isMac() ? KeyCode.META : KeyCode.CONTROL;
874     }
875 
876     public abstract FileChooserResult showFileChooser(
877             TKStage ownerWindow,
878             String title,
879             File initialDirectory,
880             String initialFileName,
881             FileChooserType fileChooserType,
882             List&lt;ExtensionFilter&gt; extensionFilters,
883             ExtensionFilter selectedFilter);
884 
885     public abstract File showDirectoryChooser(
886             TKStage ownerWindow,
887             String title,
888             File initialDirectory);
889 
890     /*
891      * Methods for obtaining &quot;double-click&quot; speed value.
892      */
893     public abstract long getMultiClickTime();
894     public abstract int getMultiClickMaxX();
895     public abstract int getMultiClickMaxY();
896 
897     private CountDownLatch pauseScenesLatch = null;
898 
899     public interface WritableImageAccessor {
900         public void loadTkImage(WritableImage wimg, Object loader);
901         public Object getTkImageLoader(WritableImage wimg);
902     }
903 
904     private static WritableImageAccessor writableImageAccessor = null;
905 
906     public static void setWritableImageAccessor(WritableImageAccessor accessor) {
907         writableImageAccessor = accessor;
908     }
909 
910     public static WritableImageAccessor getWritableImageAccessor() {
911         return writableImageAccessor;
912     }
913 
914     public interface PaintAccessor {
915         public boolean isMutable(Paint paint);
916         public Object getPlatformPaint(Paint paint);
917         public void addListener(Paint paint, AbstractNotifyListener platformChangeListener);
918         public void removeListener(Paint paint, AbstractNotifyListener platformChangeListener);
919     }
920 
921     private static PaintAccessor paintAccessor = null;
922 
923     public static void setPaintAccessor(PaintAccessor accessor) {
924         paintAccessor = accessor;
925     }
926 
927     public static PaintAccessor getPaintAccessor() {
928         return paintAccessor;
929     }
930 
931     public interface ImageAccessor {
932         public boolean isAnimation(Image image);
933         public ReadOnlyObjectProperty&lt;PlatformImage&gt;getImageProperty(Image image);
934         public int[] getPreColors(PixelFormat&lt;ByteBuffer&gt; pf);
935         public int[] getNonPreColors(PixelFormat&lt;ByteBuffer&gt; pf);
936         public Object getPlatformImage(Image image);
937         public Image fromPlatformImage(Object image);
938     }
939 
940     private static ImageAccessor imageAccessor;
941 
942     static {
943         // Need to ensure that the Image class is loaded since Toolkit class
944         // is the provider of getImageAccessor method and sets the accessor.
945         Utils.forceInit(Image.class);
946     }
947 
948     public static void setImageAccessor(ImageAccessor accessor) {
949         imageAccessor = accessor;
950     }
951 
952     public static ImageAccessor getImageAccessor() {
953         return imageAccessor;
954     }
955 
956     public String getThemeName() {
957         return null;
958     }
959 
960     public abstract GlassRobot createRobot();
961 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>