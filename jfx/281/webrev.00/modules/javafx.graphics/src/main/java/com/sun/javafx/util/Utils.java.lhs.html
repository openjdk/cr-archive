<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/com/sun/javafx/util/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.javafx.util;
 27 
 28 import static com.sun.javafx.FXPermissions.ACCESS_WINDOW_LIST_PERMISSION;
 29 import javafx.geometry.BoundingBox;
 30 import javafx.geometry.Bounds;
 31 import javafx.geometry.HPos;
 32 import javafx.geometry.NodeOrientation;
 33 import javafx.geometry.Point2D;
 34 import javafx.geometry.Rectangle2D;
 35 import javafx.geometry.VPos;
 36 import javafx.scene.Node;
 37 import javafx.scene.Scene;
 38 import javafx.scene.paint.Color;
 39 import javafx.scene.paint.Stop;
 40 import javafx.stage.Screen;
 41 import javafx.stage.Stage;
 42 import javafx.stage.Window;
 43 import java.util.List;
 44 import com.sun.javafx.PlatformUtil;
 45 import java.security.AccessController;
 46 import java.security.PrivilegedAction;
 47 import com.sun.glass.utils.NativeLibLoader;
 48 import com.sun.prism.impl.PrismSettings;
 49 
 50 /**
 51  * Some basic utilities which need to be in java (for shifting operations or
 52  * other reasons), which are not toolkit dependent.
 53  *
 54  */
 55 public class Utils {
 56 
 57     /***************************************************************************
 58      *                                                                         *
 59      * Math-related utilities                                                  *
 60      *                                                                         *
 61      **************************************************************************/
 62 
 63     /**
 64      * Simple utility function which clamps the given value to be strictly
 65      * between the min and max values.
 66      */
 67     public static float clamp(float min, float value, float max) {
 68         if (value &lt; min) return min;
 69         if (value &gt; max) return max;
 70         return value;
 71     }
 72 
 73     /**
 74      * Simple utility function which clamps the given value to be strictly
 75      * between the min and max values.
 76      */
 77     public static int clamp(int min, int value, int max) {
 78         if (value &lt; min) return min;
 79         if (value &gt; max) return max;
 80         return value;
 81     }
 82 
 83     /**
 84      * Simple utility function which clamps the given value to be strictly
 85      * between the min and max values.
 86      */
 87     public static double clamp(double min, double value, double max) {
 88         if (value &lt; min) return min;
 89         if (value &gt; max) return max;
 90         return value;
 91     }
 92 
 93     /**
 94      * Simple utility function which clamps the given value to be strictly
 95      * between the min and max values.
 96      */
 97     public static long clamp(long min, long value, long max) {
 98         if (value &lt; min) return min;
 99         if (value &gt; max) return max;
100         return value;
101     }
102 
103     /**
104      * Simple utility function which clamps the given value to be strictly
105      * above the min value.
106      */
107     public static double clampMin(double value, double min) {
108         if (value &lt; min) return min;
109         return value;
110     }
111 
112     /**
113      * Simple utility function which clamps the given value to be strictly
114      * under the max value.
115      */
116     public static int clampMax(int value, int max) {
117         if (value &gt; max) return max;
118         return value;
119     }
120 
121     /**
122      * Utility function which returns either {@code less} or {@code more}
123      * depending on which {@code value} is closer to. If {@code value}
124      * is perfectly between them, then either may be returned.
125      */
126     public static double nearest(double less, double value, double more) {
127         double lessDiff = value - less;
128         double moreDiff = more - value;
129         if (lessDiff &lt; moreDiff) return less;
130         return more;
131     }
132 
133     /***************************************************************************
134      *                                                                         *
135      * String-related utilities                                                *
136      *                                                                         *
137      **************************************************************************/
138 
139     /**
140      * Helper to remove leading and trailing quotes from a string.
141      * Works with single or double quotes.
142      */
143     public static String stripQuotes(String str) {
144         if (str == null) return str;
145         if (str.length() == 0) return str;
146 
147         int beginIndex = 0;
148         final char openQuote = str.charAt(beginIndex);
149         if ( openQuote == &#39;\&quot;&#39; || openQuote==&#39;\&#39;&#39; ) beginIndex += 1;
150 
151         int endIndex = str.length();
152         final char closeQuote = str.charAt(endIndex - 1);
153         if ( closeQuote == &#39;\&quot;&#39; || closeQuote==&#39;\&#39;&#39; ) endIndex -= 1;
154 
155         if ((endIndex - beginIndex) &lt; 0) return str;
156 
157         // note that String.substring returns &quot;this&quot; if beginIndex == 0 &amp;&amp; endIndex == count
158         // or a new string that shares the character buffer with the original string.
159         return str.substring(beginIndex, endIndex);
160     }
161 
162     /**
163      * Because mobile doesn&#39;t have string.split(s) function, this function
164      * was written.
165      */
166     public static String[] split(String str, String separator) {
167         if (str == null || str.length() == 0) return new String[] { };
168         if (separator == null || separator.length() == 0) return new String[] { };
169         if (separator.length() &gt; str.length()) return new String[] { };
170 
171         java.util.List&lt;String&gt; result = new java.util.ArrayList&lt;String&gt;();
172 
173         int index = str.indexOf(separator);
174         while (index &gt;= 0) {
175             String newStr = str.substring(0, index);
176             if (newStr != null &amp;&amp; newStr.length() &gt; 0) {
177                 result.add(newStr);
178             }
179             str = str.substring(index + separator.length());
180             index = str.indexOf(separator);
181         }
182 
183         if (str != null &amp;&amp; str.length() &gt; 0) {
184             result.add(str);
185         }
186 
187         return result.toArray(new String[] { });
188     }
189 
190     /**
191      * Because mobile doesn&#39;t have string.contains(s) function, this function
192      * was written.
193      */
194     public static boolean contains(String src, String s) {
195         if (src == null || src.length() == 0) return false;
196         if (s == null || s.length() == 0) return false;
197         if (s.length() &gt; src.length()) return false;
198 
199         return src.indexOf(s) &gt; -1;
200     }
201 
202     /***************************************************************************
203      *                                                                         *
204      * Color-related utilities                                                 *
205      *                                                                         *
206      **************************************************************************/
207 
208     /**
209      * Calculates a perceptual brightness for a color between 0.0 black and 1.0 while
210      */
211     public static double calculateBrightness(Color color) {
212           return  (0.3*color.getRed()) + (0.59*color.getGreen()) + (0.11*color.getBlue());
213     }
214 
215     /**
216      * Derives a lighter or darker of a given color.
217      *
218      * @param c           The color to derive from
219      * @param brightness  The brightness difference for the new color -1.0 being 100% dark which is always black, 0.0 being
220      *                    no change and 1.0 being 100% lighter which is always white
221      */
222     public static Color deriveColor(Color c, double brightness) {
223         double baseBrightness = calculateBrightness(c);
224         double calcBrightness = brightness;
225         // Fine adjustments to colors in ranges of brightness to adjust the contrast for them
226         if (brightness &gt; 0) {
227             if (baseBrightness &gt; 0.85) {
228                 calcBrightness = calcBrightness * 1.6;
229             } else if (baseBrightness &gt; 0.6) {
230                 // no change
231             } else if (baseBrightness &gt; 0.5) {
232                 calcBrightness = calcBrightness * 0.9;
233             } else if (baseBrightness &gt; 0.4) {
234                 calcBrightness = calcBrightness * 0.8;
235             } else if (baseBrightness &gt; 0.3) {
236                 calcBrightness = calcBrightness * 0.7;
237             } else {
238                 calcBrightness = calcBrightness * 0.6;
239             }
240         } else {
241             if (baseBrightness &lt; 0.2) {
242                 calcBrightness = calcBrightness * 0.6;
243             }
244         }
245         // clamp brightness
246         if (calcBrightness &lt; -1) { calcBrightness = -1; } else if (calcBrightness &gt; 1) {calcBrightness = 1;}
247         // window two take the calculated brightness multiplyer and derive color based on source color
248         double[] hsb = RGBtoHSB(c.getRed(), c.getGreen(), c.getBlue());
249         // change brightness
250         if (calcBrightness &gt; 0) { // brighter
251             hsb[1] *= 1 - calcBrightness;
252             hsb[2] += (1 - hsb[2]) * calcBrightness;
253         } else { // darker
254             hsb[2] *=  calcBrightness + 1;
255         }
256         // clip saturation and brightness
257         if (hsb[1] &lt; 0) { hsb[1] = 0;} else if (hsb[1] &gt; 1) {hsb[1] = 1;}
258         if (hsb[2] &lt; 0) { hsb[2] = 0;} else if (hsb[2] &gt; 1) {hsb[2] = 1;}
259         // convert back to color
260         Color c2 = Color.hsb((int)hsb[0], hsb[1], hsb[2],c.getOpacity());
261         return Color.hsb((int)hsb[0], hsb[1], hsb[2],c.getOpacity());
262 
263      /*   var hsb:Number[] = RGBtoHSB(c.red,c.green,c.blue);
264         // change brightness
265         if (brightness &gt; 0) {
266             //var bright:Number = brightness * (1-calculateBrightness(c));
267             var bright:Number = if (calculateBrightness(c)&lt;0.65 and brightness &gt; 0.5) {
268                     if (calculateBrightness(c)&lt;0.2) then brightness * 0.55 else brightness * 0.7
269             } else brightness;
270             // brighter
271             hsb[1] *= 1 - bright;
272             hsb[2] += (1 - hsb[2]) * bright;
273         } else {
274             // darker
275             hsb[2] *= brightness+1;
276         }
277         // clip saturation and brightness
278         if (hsb[1] &lt; 0) { hsb[1] = 0;} else if (hsb[1] &gt; 1) {hsb[1] = 1}
279         if (hsb[2] &lt; 0) { hsb[2] = 0;} else if (hsb[2] &gt; 1) {hsb[2] = 1}
280         // convert back to color
281         return Color.hsb(hsb[0],hsb[1],hsb[2]) */
282     }
283 
284     /**
285      * interpolate at a set {@code position} between two colors {@code color1} and {@code color2}.
286      * The interpolation is done is linear RGB color space not the default sRGB color space.
287      */
288     private static Color interpolateLinear(double position, Color color1, Color color2) {
289         Color c1Linear = convertSRGBtoLinearRGB(color1);
290         Color c2Linear = convertSRGBtoLinearRGB(color2);
291         return convertLinearRGBtoSRGB(Color.color(
292             c1Linear.getRed()     + (c2Linear.getRed()     - c1Linear.getRed())     * position,
293             c1Linear.getGreen()   + (c2Linear.getGreen()   - c1Linear.getGreen())   * position,
294             c1Linear.getBlue()    + (c2Linear.getBlue()    - c1Linear.getBlue())    * position,
295             c1Linear.getOpacity() + (c2Linear.getOpacity() - c1Linear.getOpacity()) * position
296         ));
297     }
298 
299     /**
300      * Get the color at the give {@code position} in the ladder of color stops
301      */
302     private static Color ladder(final double position, final Stop[] stops) {
303         Stop prevStop = null;
304         for (int i=0; i&lt;stops.length; i++) {
305             Stop stop = stops[i];
306             if(position &lt;= stop.getOffset()){
307                 if (prevStop == null) {
308                     return stop.getColor();
309                 } else {
310                     return interpolateLinear((position-prevStop.getOffset())/(stop.getOffset()-prevStop.getOffset()), prevStop.getColor(), stop.getColor());
311                 }
312             }
313             prevStop = stop;
314         }
315         // position is greater than biggest stop, so will we biggest stop&#39;s color
316         return prevStop.getColor();
317     }
318 
319     /**
320      * Get the color at the give {@code position} in the ladder of color stops
321      */
322     public static Color ladder(final Color color, final Stop[] stops) {
323         return ladder(calculateBrightness(color), stops);
324     }
325 
326     public static double[] HSBtoRGB(double hue, double saturation, double brightness) {
327         // normalize the hue
328         double normalizedHue = ((hue % 360) + 360) % 360;
329         hue = normalizedHue/360;
330 
331         double r = 0, g = 0, b = 0;
332         if (saturation == 0) {
333             r = g = b = brightness;
334         } else {
335             double h = (hue - Math.floor(hue)) * 6.0;
336             double f = h - java.lang.Math.floor(h);
337             double p = brightness * (1.0 - saturation);
338             double q = brightness * (1.0 - saturation * f);
339             double t = brightness * (1.0 - (saturation * (1.0 - f)));
340             switch ((int) h) {
341                 case 0:
342                     r = brightness;
343                     g = t;
344                     b = p;
345                     break;
346                 case 1:
347                     r = q;
348                     g = brightness;
349                     b = p;
350                     break;
351                 case 2:
352                     r = p;
353                     g = brightness;
354                     b = t;
355                     break;
356                 case 3:
357                     r = p;
358                     g = q;
359                     b = brightness;
360                     break;
361                 case 4:
362                     r = t;
363                     g = p;
364                     b = brightness;
365                     break;
366                 case 5:
367                     r = brightness;
368                     g = p;
369                     b = q;
370                     break;
371             }
372         }
373         double[] f = new double[3];
374         f[0] = r;
375         f[1] = g;
376         f[2] = b;
377         return f;
378     }
379 
380     public static double[] RGBtoHSB(double r, double g, double b) {
381         double hue, saturation, brightness;
382         double[] hsbvals = new double[3];
383         double cmax = (r &gt; g) ? r : g;
384         if (b &gt; cmax) cmax = b;
385         double cmin = (r &lt; g) ? r : g;
386         if (b &lt; cmin) cmin = b;
387 
388         brightness = cmax;
389         if (cmax != 0)
390             saturation = (double) (cmax - cmin) / cmax;
391         else
392             saturation = 0;
393 
394         if (saturation == 0) {
395             hue = 0;
396         } else {
397             double redc = (cmax - r) / (cmax - cmin);
398             double greenc = (cmax - g) / (cmax - cmin);
399             double bluec = (cmax - b) / (cmax - cmin);
400             if (r == cmax)
401                 hue = bluec - greenc;
402             else if (g == cmax)
403                 hue = 2.0 + redc - bluec;
404             else
405                 hue = 4.0 + greenc - redc;
406             hue = hue / 6.0;
407             if (hue &lt; 0)
408                 hue = hue + 1.0;
409         }
410         hsbvals[0] = hue * 360;
411         hsbvals[1] = saturation;
412         hsbvals[2] = brightness;
413         return hsbvals;
414     }
415 
416     /**
417      * Helper function to convert a color in sRGB space to linear RGB space.
418      */
419     public static Color convertSRGBtoLinearRGB(Color color) {
420         double[] colors = new double[] { color.getRed(), color.getGreen(), color.getBlue() };
421         for (int i=0; i&lt;colors.length; i++) {
422             if (colors[i] &lt;= 0.04045) {
423                 colors[i] = colors[i] / 12.92;
424             } else {
425                 colors[i] = Math.pow((colors[i] + 0.055) / 1.055, 2.4);
426             }
427         }
428         return Color.color(colors[0], colors[1], colors[2], color.getOpacity());
429     }
430 
431     /**
432      * Helper function to convert a color in linear RGB space to SRGB space.
433      */
434     public static Color convertLinearRGBtoSRGB(Color color) {
435         double[] colors = new double[] { color.getRed(), color.getGreen(), color.getBlue() };
436         for (int i=0; i&lt;colors.length; i++) {
437             if (colors[i] &lt;= 0.0031308) {
438                 colors[i] = colors[i] * 12.92;
439             } else {
440                 colors[i] = (1.055 * Math.pow(colors[i], (1.0 / 2.4))) - 0.055;
441             }
442         }
443         return Color.color(colors[0], colors[1], colors[2], color.getOpacity());
444     }
445 
446     /** helper function for calculating the sum of a series of numbers */
447     public static double sum(double[] values) {
448         double sum = 0;
449         for (double v : values) sum = sum+v;
450         return sum / values.length;
451     }
452 
453     public static Point2D pointRelativeTo(Node parent, Node node, HPos hpos,
454             VPos vpos, double dx, double dy, boolean reposition)
455     {
456         final double nodeWidth = node.getLayoutBounds().getWidth();
457         final double nodeHeight = node.getLayoutBounds().getHeight();
458         return pointRelativeTo(parent, nodeWidth, nodeHeight, hpos, vpos, dx, dy, reposition);
459     }
460 
461     public static Point2D pointRelativeTo(Node parent, double anchorWidth,
462             double anchorHeight, HPos hpos, VPos vpos, double dx, double dy,
463             boolean reposition)
464     {
465         final Bounds parentBounds = getBounds(parent);
466         Scene scene = parent.getScene();
467         NodeOrientation orientation = parent.getEffectiveNodeOrientation();
468 
469         if (orientation == NodeOrientation.RIGHT_TO_LEFT) {
470             if (hpos == HPos.LEFT) {
471                 hpos = HPos.RIGHT;
472             } else if (hpos == HPos.RIGHT) {
473                 hpos = HPos.LEFT;
474             }
475             dx *= -1;
476         }
477 
478         double layoutX = positionX(parentBounds, anchorWidth, hpos) + dx;
479         final double layoutY = positionY(parentBounds, anchorHeight, vpos) + dy;
480 
481         if (orientation == NodeOrientation.RIGHT_TO_LEFT &amp;&amp; hpos == HPos.CENTER) {
482             //TODO - testing for an instance of Stage seems wrong but works for menus
483             if (scene.getWindow() instanceof Stage) {
484                 layoutX = layoutX + parentBounds.getWidth() - anchorWidth;
485             } else {
486                 layoutX = layoutX - parentBounds.getWidth() - anchorWidth;
487             }
488         }
489 
490         if (reposition) {
491             return pointRelativeTo(parent, anchorWidth, anchorHeight, layoutX, layoutY, hpos, vpos);
492         } else {
493             return new Point2D(layoutX, layoutY);
494         }
495     }
496 
497     /**
498      * This is the fallthrough function that most other functions fall into. It takes
499      * care specifically of the repositioning of the item such that it remains onscreen
500      * as best it can, given it&#39;s unique qualities.
501      *
502      * As will all other functions, this one returns a Point2D that represents an x,y
503      * location that should safely position the item onscreen as best as possible.
504      *
505      * Note that &lt;code&gt;width&lt;/code&gt; and &lt;height&gt; refer to the width and height of the
506      * node/popup that is needing to be repositioned, not of the parent.
507      *
508      * Don&#39;t use the BASELINE vpos, it doesn&#39;t make sense and would produce wrong result.
509      */
510     public static Point2D pointRelativeTo(Object parent, double width,
511             double height, double screenX, double screenY, HPos hpos, VPos vpos)
512     {
513         double finalScreenX = screenX;
514         double finalScreenY = screenY;
515         final Bounds parentBounds = getBounds(parent);
516 
517         // ...and then we get the bounds of this screen
518         final Screen currentScreen = getScreen(parent);
519         final Rectangle2D screenBounds =
520                 hasFullScreenStage(currentScreen)
521                         ? currentScreen.getBounds()
522                         : currentScreen.getVisualBounds();
523 
524         // test if this layout will force the node to appear outside
525         // of the screens bounds. If so, we must reposition the item to a better position.
526         // We firstly try to do this intelligently, so as to not overlap the parent if
527         // at all possible.
528         if (hpos != null) {
529             // Firstly we consider going off the right hand side
530             if ((finalScreenX + width) &gt; screenBounds.getMaxX()) {
531                 finalScreenX = positionX(parentBounds, width, getHPosOpposite(hpos, vpos));
532             }
533 
534             // don&#39;t let the node go off to the left of the current screen
535             if (finalScreenX &lt; screenBounds.getMinX()) {
536                 finalScreenX = positionX(parentBounds, width, getHPosOpposite(hpos, vpos));
537             }
538         }
539 
540         if (vpos != null) {
541             // don&#39;t let the node go off the bottom of the current screen
542             if ((finalScreenY + height) &gt; screenBounds.getMaxY()) {
543                 finalScreenY = positionY(parentBounds, height, getVPosOpposite(hpos,vpos));
544             }
545 
546             // don&#39;t let the node out of the top of the current screen
547             if (finalScreenY &lt; screenBounds.getMinY()) {
548                 finalScreenY = positionY(parentBounds, height, getVPosOpposite(hpos,vpos));
549             }
550         }
551 
552         // --- after all the moving around, we do one last check / rearrange.
553         // Unlike the check above, this time we are just fully committed to keeping
554         // the item on screen at all costs, regardless of whether or not that results
555         /// in overlapping the parent object.
556         if ((finalScreenX + width) &gt; screenBounds.getMaxX()) {
557             finalScreenX -= (finalScreenX + width - screenBounds.getMaxX());
558         }
559         if (finalScreenX &lt; screenBounds.getMinX()) {
560             finalScreenX = screenBounds.getMinX();
561         }
562         if ((finalScreenY + height) &gt; screenBounds.getMaxY()) {
563             finalScreenY -= (finalScreenY + height - screenBounds.getMaxY());
564         }
565         if (finalScreenY &lt; screenBounds.getMinY()) {
566             finalScreenY = screenBounds.getMinY();
567         }
568 
569         return new Point2D(finalScreenX, finalScreenY);
570     }
571 
572     /**
573      * Utility function that returns the x-axis position that an object should be positioned at,
574      * given the parents screen bounds, the width of the object, and
575      * the required HPos.
576      */
577     private static double positionX(Bounds parentBounds, double width, HPos hpos) {
578         if (hpos == HPos.CENTER) {
579             // this isn&#39;t right, but it is needed for root menus to show properly
580             return parentBounds.getMinX();
581         } else if (hpos == HPos.RIGHT) {
582             return parentBounds.getMaxX();
583         } else if (hpos == HPos.LEFT) {
584             return parentBounds.getMinX() - width;
585         } else {
586             return 0;
587         }
588     }
589 
590     /**
591      * Utility function that returns the y-axis position that an object should be positioned at,
592      * given the parents screen bounds, the height of the object, and
593      * the required VPos.
594      *
595      * The BASELINE vpos doesn&#39;t make sense here, 0 is returned for it.
596      */
597     private static double positionY(Bounds parentBounds, double height, VPos vpos) {
598         if (vpos == VPos.BOTTOM) {
599             return parentBounds.getMaxY();
600         } else if (vpos == VPos.CENTER) {
601             return parentBounds.getMinY();
602         } else if (vpos == VPos.TOP) {
603             return parentBounds.getMinY() - height;
604         } else {
605             return 0;
606         }
607     }
608 
609     /**
610      * To facilitate multiple types of parent object, we unfortunately must allow for
611      * Objects to be passed in. This method handles determining the bounds of the
612      * given Object. If the Object type is not supported, a default Bounds will be returned.
613      */
614     private static Bounds getBounds(Object obj) {
615         if (obj instanceof Node) {
616             final Node n = (Node)obj;
617             Bounds b = n.localToScreen(n.getLayoutBounds());
618             return b != null ? b : new BoundingBox(0, 0, 0, 0);
619         } else if (obj instanceof Window) {
620             final Window window = (Window)obj;
621             return new BoundingBox(window.getX(), window.getY(), window.getWidth(), window.getHeight());
622         } else {
623             return new BoundingBox(0, 0, 0, 0);
624         }
625     }
626 
627     /*
628      * Simple utitilty function to return the &#39;opposite&#39; value of a given HPos, taking
629      * into account the current VPos value. This is used to try and avoid overlapping.
630      */
631     private static HPos getHPosOpposite(HPos hpos, VPos vpos) {
632         if (vpos == VPos.CENTER) {
633             if (hpos == HPos.LEFT){
634                 return HPos.RIGHT;
635             } else if (hpos == HPos.RIGHT){
636                 return HPos.LEFT;
637             } else if (hpos == HPos.CENTER){
638                 return HPos.CENTER;
639             } else {
640                 // by default center for now
641                 return HPos.CENTER;
642             }
643         } else {
644             return HPos.CENTER;
645         }
646     }
647 
648     /*
649      * Simple utitilty function to return the &#39;opposite&#39; value of a given VPos, taking
650      * into account the current HPos value. This is used to try and avoid overlapping.
651      */
652     private static VPos getVPosOpposite(HPos hpos, VPos vpos) {
653         if (hpos == HPos.CENTER) {
654             if (vpos == VPos.BASELINE){
655                 return VPos.BASELINE;
656             } else if (vpos == VPos.BOTTOM){
657                 return VPos.TOP;
658             } else if (vpos == VPos.CENTER){
659                 return VPos.CENTER;
660             } else if (vpos == VPos.TOP){
661                 return VPos.BOTTOM;
662             } else {
663                 // by default center for now
664                 return VPos.CENTER;
665             }
666         } else {
667             return VPos.CENTER;
668         }
669     }
670 
671     public static boolean hasFullScreenStage(final Screen screen) {
672         final List&lt;Window&gt; allWindows = AccessController.doPrivileged(
673                 (PrivilegedAction&lt;List&lt;Window&gt;&gt;) () -&gt; Window.getWindows(),
674                 null,
675                 ACCESS_WINDOW_LIST_PERMISSION);
676 
677         for (final Window window : allWindows) {
678             if (window instanceof Stage) {
679                 final Stage stage = (Stage) window;
680                 if (stage.isFullScreen() &amp;&amp; (getScreen(stage) == screen)) {
681                     return true;
682                 }
683             }
684         }
685         return false;
686     }
687 
688     /*
689      * Returns true if the primary Screen has QVGA dimensions, in landscape or portrait mode.
690      */
691     public static boolean isQVGAScreen() {
692         Rectangle2D bounds = Screen.getPrimary().getBounds();
693         return ((bounds.getWidth() == 320 &amp;&amp; bounds.getHeight() == 240) ||
694                 (bounds.getWidth() == 240 &amp;&amp; bounds.getHeight() == 320));
695     }
696 
697     /**
698      * This function attempts to determine the best screen given the parent object
699      * from which we are wanting to position another item relative to. This is particularly
700      * important when we want to keep items from going off screen, and for handling
701      * multiple monitor support.
702      */
703     public static Screen getScreen(Object obj) {
704         final Bounds parentBounds = getBounds(obj);
705 
706         final Rectangle2D rect = new Rectangle2D(
707                 parentBounds.getMinX(),
708                 parentBounds.getMinY(),
709                 parentBounds.getWidth(),
710                 parentBounds.getHeight());
711 
712         return getScreenForRectangle(rect);
713     }
714 
715     public static Screen getScreenForRectangle(final Rectangle2D rect) {
716         final List&lt;Screen&gt; screens = Screen.getScreens();
717 
718         final double rectX0 = rect.getMinX();
719         final double rectX1 = rect.getMaxX();
720         final double rectY0 = rect.getMinY();
721         final double rectY1 = rect.getMaxY();
722 
723         Screen selectedScreen;
724 
725         selectedScreen = null;
726         double maxIntersection = 0;
727         for (final Screen screen: screens) {
728             final Rectangle2D screenBounds = screen.getBounds();
729             final double intersection =
730                     getIntersectionLength(rectX0, rectX1,
731                                           screenBounds.getMinX(),
732                                           screenBounds.getMaxX())
733                         * getIntersectionLength(rectY0, rectY1,
734                                                 screenBounds.getMinY(),
735                                                 screenBounds.getMaxY());
736 
737             if (maxIntersection &lt; intersection) {
738                 maxIntersection = intersection;
739                 selectedScreen = screen;
740             }
741         }
742 
743         if (selectedScreen != null) {
744             return selectedScreen;
745         }
746 
747         selectedScreen = Screen.getPrimary();
748         double minDistance = Double.MAX_VALUE;
749         for (final Screen screen: screens) {
750             final Rectangle2D screenBounds = screen.getBounds();
751             final double dx = getOuterDistance(rectX0, rectX1,
752                                                screenBounds.getMinX(),
753                                                screenBounds.getMaxX());
754             final double dy = getOuterDistance(rectY0, rectY1,
755                                                screenBounds.getMinY(),
756                                                screenBounds.getMaxY());
757             final double distance = dx * dx + dy * dy;
758 
759             if (minDistance &gt; distance) {
760                 minDistance = distance;
761                 selectedScreen = screen;
762             }
763         }
764 
765         return selectedScreen;
766     }
767 
768     public static Screen getScreenForPoint(final double x, final double y) {
769         final List&lt;Screen&gt; screens = Screen.getScreens();
770 
771         // first check whether the point is inside some screen
772         for (final Screen screen: screens) {
773             // can&#39;t use screen.bounds.contains, because it returns true for
774             // the min + width point
775             final Rectangle2D screenBounds = screen.getBounds();
776             if ((x &gt;= screenBounds.getMinX())
777                     &amp;&amp; (x &lt; screenBounds.getMaxX())
778                     &amp;&amp; (y &gt;= screenBounds.getMinY())
779                     &amp;&amp; (y &lt; screenBounds.getMaxY())) {
780                 return screen;
781             }
782         }
783 
784         // the point is not inside any screen, find the closest screen now
785         Screen selectedScreen = Screen.getPrimary();
786         double minDistance = Double.MAX_VALUE;
787         for (final Screen screen: screens) {
788             final Rectangle2D screenBounds = screen.getBounds();
789             final double dx = getOuterDistance(screenBounds.getMinX(),
790                                                screenBounds.getMaxX(),
791                                                x);
792             final double dy = getOuterDistance(screenBounds.getMinY(),
793                                                screenBounds.getMaxY(),
794                                                y);
795             final double distance = dx * dx + dy * dy;
796             if (minDistance &gt;= distance) {
797                 minDistance = distance;
798                 selectedScreen = screen;
799             }
800         }
801 
802         return selectedScreen;
803     }
804 
805     private static double getIntersectionLength(
806             final double a0, final double a1,
807             final double b0, final double b1) {
808         // (a0 &lt;= a1) &amp;&amp; (b0 &lt;= b1)
809         return (a0 &lt;= b0) ? getIntersectionLengthImpl(b0, b1, a1)
810                           : getIntersectionLengthImpl(a0, a1, b1);
811     }
812 
813     private static double getIntersectionLengthImpl(
814             final double v0, final double v1, final double v) {
815         // (v0 &lt;= v1)
816         if (v &lt;= v0) {
817             return 0;
818         }
819 
820         return (v &lt;= v1) ? v - v0 : v1 - v0;
821     }
822 
823     private static double getOuterDistance(
824             final double a0, final double a1,
825             final double b0, final double b1) {
826         // (a0 &lt;= a1) &amp;&amp; (b0 &lt;= b1)
827         if (a1 &lt;= b0) {
828             return b0 - a1;
829         }
830 
831         if (b1 &lt;= a0) {
832             return b1 - a0;
833         }
834 
835         return 0;
836     }
837 
838     private static double getOuterDistance(final double v0,
839                                            final double v1,
840                                            final double v) {
841         // (v0 &lt;= v1)
842         if (v &lt;= v0) {
843             return v0 - v;
844         }
845 
846         if (v &gt;= v1) {
847             return v - v1;
848         }
849 
850         return 0;
851     }
852 
853     /***************************************************************************
854      *                                                                         *
855      * Miscellaneous utilities                                                 *
856      *                                                                         *
857      **************************************************************************/
858 
859     /**
860      * To force initialization of a class
861      * @param classToInit
862      */
863     public static void forceInit(final Class&lt;?&gt; classToInit) {
864         try {
865             Class.forName(classToInit.getName(), true,
866                     classToInit.getClassLoader());
867         } catch (final ClassNotFoundException e) {
868             throw new AssertionError(e);  // Can&#39;t happen
869         }
870     }
871 
872     public static boolean assertionEnabled() {
873         boolean assertsEnabled = false;
874         assert assertsEnabled = true;  // Intentional side-effect !!!
875 
876         return assertsEnabled;
877     }
878 
879     /**
880      * Returns true if the operating system is a form of Windows.
881      */
882     public static boolean isWindows(){
883         return PlatformUtil.isWindows();
884     }
885 
886     /**
887      * Returns true if the operating system is a form of Mac OS.
888      */
889     public static boolean isMac(){
890         return PlatformUtil.isMac();
891     }
892 
893     /**
894      * Returns true if the operating system is a form of Unix, including Linux.
895      */
896     public static boolean isUnix(){
897         return PlatformUtil.isUnix();
898     }
899 
900     /***************************************************************************
901      *                                                                         *
902      * Unicode-related utilities                                               *
903      *                                                                         *
904      **************************************************************************/
905 
906     public static String convertUnicode(String src) {
907         /** The input buffer, index of next character to be read,
908          *  index of one past last character in buffer.
909          */
910         char[] buf;
911         int bp;
912         int buflen;
913 
914         /** The current character.
915          */
916         char ch;
917 
918         /** The buffer index of the last converted unicode character
919          */
920         int unicodeConversionBp = -1;
921 
922         buf = src.toCharArray();
923         buflen = buf.length;
924         bp = -1;
925 
926         char[] dst = new char[buflen];
927         int dstIndex = 0;
928 
929         while (bp &lt; buflen - 1) {
930             ch = buf[++bp];
931             if (ch == &#39;\\&#39;) {
932                 if (unicodeConversionBp != bp) {
933                     bp++; ch = buf[bp];
934                     if (ch == &#39;u&#39;) {
935                         do {
936                             bp++; ch = buf[bp];
937                         } while (ch == &#39;u&#39;);
938                         int limit = bp + 3;
939                         if (limit &lt; buflen) {
940                             char c = ch;
941                             int result = Character.digit(c, 16);
942                             if (result &gt;= 0 &amp;&amp; c &gt; 0x7f) {
943                                 //lexError(pos+1, &quot;illegal.nonascii.digit&quot;);
944                                 ch = &quot;0123456789abcdef&quot;.charAt(result);
945                             }
946                             int d = result;
947                             int code = d;
948                             while (bp &lt; limit &amp;&amp; d &gt;= 0) {
949                                 bp++; ch = buf[bp];
950                                 char c1 = ch;
951                                 int result1 = Character.digit(c1, 16);
952                                 if (result1 &gt;= 0 &amp;&amp; c1 &gt; 0x7f) {
953                                     //lexError(pos+1, &quot;illegal.nonascii.digit&quot;);
954                                     ch = &quot;0123456789abcdef&quot;.charAt(result1);
955                                 }
956                                 d = result1;
957                                 code = (code &lt;&lt; 4) + d;
958                             }
959                             if (d &gt;= 0) {
960                                 ch = (char)code;
961                                 unicodeConversionBp = bp;
962                             }
963                         }
964                         //lexError(bp, &quot;illegal.unicode.esc&quot;);
965                     } else {
966                         bp--;
967                         ch = &#39;\\&#39;;
968                     }
969                 }
970             }
971             dst[dstIndex++] = ch;
972         }
973 
974         return new String(dst, 0, dstIndex);
975     }
976 
977     public static synchronized void loadNativeSwingLibrary() {
978         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
979             String libName = &quot;prism_common&quot;;
980 
981             if (PrismSettings.verbose) {
982                 System.out.println(&quot;Loading Prism common native library ...&quot;);
983             }
984             NativeLibLoader.loadLibrary(libName);
985             if (PrismSettings.verbose) {
986                 System.out.println(&quot;\tsucceeded.&quot;);
987             }
988             return null;
989         });
990     }
991 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>