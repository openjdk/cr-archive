<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.controls/src/main/java/javafx/scene/control/TextInputControl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 
  28 import com.sun.javafx.scene.control.FormatterAccessor;
  29 import javafx.beans.DefaultProperty;
  30 import javafx.beans.InvalidationListener;
  31 import javafx.beans.Observable;
  32 import javafx.beans.binding.IntegerBinding;
  33 import javafx.beans.binding.StringBinding;
  34 import javafx.beans.property.BooleanProperty;
  35 import javafx.beans.property.ObjectProperty;
  36 import javafx.beans.property.ObjectPropertyBase;
  37 import javafx.beans.property.ReadOnlyBooleanProperty;
  38 import javafx.beans.property.ReadOnlyBooleanWrapper;
  39 import javafx.beans.property.ReadOnlyIntegerProperty;
  40 import javafx.beans.property.ReadOnlyIntegerWrapper;
  41 import javafx.beans.property.ReadOnlyObjectProperty;
  42 import javafx.beans.property.ReadOnlyObjectWrapper;
  43 import javafx.beans.property.ReadOnlyStringProperty;
  44 import javafx.beans.property.ReadOnlyStringWrapper;
  45 import javafx.beans.property.SimpleBooleanProperty;
  46 import javafx.beans.property.SimpleStringProperty;
  47 import javafx.beans.property.StringProperty;
  48 import javafx.beans.value.ChangeListener;
  49 import javafx.beans.value.ObservableStringValue;
  50 import javafx.beans.value.ObservableValue;
  51 import javafx.beans.value.WritableValue;
  52 import javafx.css.CssMetaData;
  53 import javafx.css.FontCssMetaData;
  54 import javafx.css.PseudoClass;
  55 import javafx.css.StyleOrigin;
  56 import javafx.css.Styleable;
  57 import javafx.css.StyleableObjectProperty;
  58 import javafx.css.StyleableProperty;
  59 import javafx.scene.AccessibleAction;
  60 import javafx.scene.AccessibleAttribute;
  61 import javafx.scene.input.Clipboard;
  62 import javafx.scene.input.ClipboardContent;
  63 import javafx.scene.text.Font;
  64 
  65 import java.text.BreakIterator;
  66 import java.util.ArrayList;
  67 import java.util.Collections;
  68 import java.util.List;
  69 
  70 import com.sun.javafx.util.Utils;
  71 import com.sun.javafx.binding.ExpressionHelper;
  72 import com.sun.javafx.scene.NodeHelper;
  73 import javafx.util.StringConverter;
  74 
  75 /**
  76  * Abstract base class for text input controls.
  77  * @since JavaFX 2.0
  78  */
  79 @DefaultProperty(&quot;text&quot;)
  80 public abstract class TextInputControl extends Control {
  81     /**
  82      * Interface representing a text input&#39;s content. Since it is an ObservableStringValue,
  83      * you can also bind to, or observe the content.
  84      * @since JavaFX 2.0
  85      */
  86     protected interface Content extends ObservableStringValue {
  87         /**
  88          * Retrieves a subset of the content.
  89          *
  90          * @param start the start
  91          * @param end the end
  92          * @return a subset of the content
  93          */
  94         public String get(int start, int end);
  95 
  96         /**
  97          * Inserts a sequence of characters into the content.
  98          *
  99          * @param index the index
 100          * @param text the text string
 101          * @param notifyListeners the notify listener flag
 102          * @since JavaFX 2.1
 103          */
 104         public void insert(int index, String text, boolean notifyListeners);
 105 
 106         /**
 107          * Removes a sequence of characters from the content.
 108          *
 109          * @param start the start
 110          * @param end the end
 111          * @param notifyListeners the notify listener flag
 112          * @since JavaFX 2.1
 113          */
 114         public void delete(int start, int end, boolean notifyListeners);
 115 
 116         /**
 117          * Returns the number of characters represented by the content.
 118          * @return the number of characters
 119          */
 120         public int length();
 121     }
 122 
 123     private boolean blockSelectedTextUpdate;
 124 
 125     /***************************************************************************
 126      *                                                                         *
 127      * Constructors                                                            *
 128      *                                                                         *
 129      **************************************************************************/
 130 
 131     /**
 132      * Creates a new TextInputControl. The content is an immutable property and
 133      * must be specified (as non-null) at the time of construction.
 134      *
 135      * @param content a non-null implementation of Content.
 136      */
 137     protected TextInputControl(final Content content) {
 138         this.content = content;
 139 
 140         // Add a listener so that whenever the Content is changed, we notify
 141         // listeners of the text property that it is invalid.
 142         content.addListener(observable -&gt; {
 143             if (content.length() &gt; 0) {
 144                 text.textIsNull = false;
 145             }
 146             text.controlContentHasChanged();
 147         });
 148 
 149         // Bind the length to be based on the length of the text property
 150         length.bind(new IntegerBinding() {
 151             { bind(text); }
 152             @Override protected int computeValue() {
 153                 String txt = text.get();
 154                 return txt == null ? 0 : txt.length();
 155             }
 156         });
 157 
 158         // Bind the selected text to be based on the selection and text properties
 159         selection.addListener((ob, o, n) -&gt; updateSelectedText());
 160         text.addListener((ob, o, n) -&gt; updateSelectedText());
 161 
 162         focusedProperty().addListener((ob, o, n) -&gt; {
 163             if (n) {
 164                 if (getTextFormatter() != null) {
 165                     updateText(getTextFormatter());
 166                 }
 167             } else {
 168                 commitValue();
 169             }
 170         });
 171 
 172         // Specify the default style class
 173         getStyleClass().add(&quot;text-input&quot;);
 174     }
 175 
 176     private void updateSelectedText() {
 177         if (!blockSelectedTextUpdate) {
 178             String txt = text.get();
 179             IndexRange sel = selection.get();
 180             if (txt == null || sel == null) {
 181                 selectedText.set(&quot;&quot;);
 182             } else {
 183                 int start = sel.getStart();
 184                 int end = sel.getEnd();
 185                 selectedText.set(txt.substring(start, end));
 186             }
 187         }
 188     }
 189 
 190     /***************************************************************************
 191      *                                                                         *
 192      * Properties                                                              *
 193      *                                                                         *
 194      **************************************************************************/
 195 
 196     /**
 197      * The default font to use for text in the TextInputControl. If the TextInputControl&#39;s text is
 198      * rich text then this font may or may not be used depending on the font
 199      * information embedded in the rich text, but in any case where a default
 200      * font is required, this font will be used.
 201      * @return the font property
 202      * @since JavaFX 8.0
 203      */
 204     public final ObjectProperty&lt;Font&gt; fontProperty() {
 205         if (font == null) {
 206             font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {
 207 
 208 
 209                 private boolean fontSetByCss = false;
 210 
 211                 @Override
 212                 public void applyStyle(StyleOrigin newOrigin, Font value) {
 213 
 214                     //
 215                     // RT-20727 - if CSS is setting the font, then make sure invalidate doesn&#39;t call NodeHelper.reapplyCSS
 216                     //
 217                     try {
 218                         // super.applyStyle calls set which might throw if value is bound.
 219                         // Have to make sure fontSetByCss is reset.
 220                         fontSetByCss = true;
 221                         super.applyStyle(newOrigin, value);
 222                     } catch(Exception e) {
 223                         throw e;
 224                     } finally {
 225                         fontSetByCss = false;
 226                     }
 227 
 228                 }
 229 
 230 
 231                 @Override
 232                 public void set(Font value) {
 233                     final Font oldValue = get();
 234                     if (value == null ? oldValue == null : value.equals(oldValue)) {
 235                         return;
 236                     }
 237                     super.set(value);
 238                 }
 239 
 240                 @Override
 241                 protected void invalidated() {
 242                     // RT-20727 - if font is changed by calling setFont, then
 243                     // css might need to be reapplied since font size affects
 244                     // calculated values for styles with relative values
 245                     if(fontSetByCss == false) {
 246                         NodeHelper.reapplyCSS(TextInputControl.this);
 247                     }
 248                 }
 249 
 250                 @Override
 251                 public CssMetaData&lt;TextInputControl,Font&gt; getCssMetaData() {
 252                     return StyleableProperties.FONT;
 253                 }
 254 
 255                 @Override
 256                 public Object getBean() {
 257                     return TextInputControl.this;
 258                 }
 259 
 260                 @Override
 261                 public String getName() {
 262                     return &quot;font&quot;;
 263                 }
 264             };
 265         }
 266         return font;
 267     }
 268 
 269     private ObjectProperty&lt;Font&gt; font;
 270     public final void setFont(Font value) { fontProperty().setValue(value); }
 271     public final Font getFont() { return font == null ? Font.getDefault() : font.getValue(); }
 272 
 273     /**
 274      * The prompt text to display in the {@code TextInputControl}. If set to null or an empty string, no
 275      * prompt text is displayed.
 276      *
 277      * @defaultValue An empty String
 278      * @since JavaFX 2.2
 279      */
 280     private StringProperty promptText = new SimpleStringProperty(this, &quot;promptText&quot;, &quot;&quot;) {
 281         @Override protected void invalidated() {
 282             // Strip out newlines
 283             String txt = get();
 284             if (txt != null &amp;&amp; txt.contains(&quot;\n&quot;)) {
 285                 txt = txt.replace(&quot;\n&quot;, &quot;&quot;);
 286                 set(txt);
 287             }
 288         }
 289     };
 290     public final StringProperty promptTextProperty() { return promptText; }
 291     public final String getPromptText() { return promptText.get(); }
 292     public final void setPromptText(String value) { promptText.set(value); }
 293 
 294 
 295     /**
 296      * The property contains currently attached {@link TextFormatter}.
 297      * Since the value is part of the {@code Formatter}, changing the TextFormatter will update the text based on the new textFormatter.
 298      *
 299      * @defaultValue null
 300      * @since JavaFX 8u40
 301      */
 302     private final ObjectProperty&lt;TextFormatter&lt;?&gt;&gt; textFormatter = new ObjectPropertyBase&lt;TextFormatter&lt;?&gt;&gt;() {
 303 
 304         private TextFormatter&lt;?&gt; oldFormatter = null;
 305 
 306         @Override
 307         public Object getBean() {
 308             return TextInputControl.this;
 309         }
 310 
 311         @Override
 312         public String getName() {
 313             return &quot;textFormatter&quot;;
 314         }
 315 
 316         @Override
 317         protected void invalidated() {
 318             final TextFormatter&lt;?&gt; formatter = get();
 319             try {
 320                 if (formatter != null) {
 321                     try {
 322                         formatter.bindToControl(f -&gt; updateText(f));
 323                     } catch (IllegalStateException e) {
 324                         if (isBound()) {
 325                             unbind();
 326                         }
 327                         set(null);
 328                         throw e;
 329                     }
 330                     if (!isFocused()) {
 331                         updateText(get());
 332                     }
 333                 }
 334 
 335                 if (oldFormatter != null) {
 336                     oldFormatter.unbindFromControl();
 337                 }
 338             } finally {
 339                 oldFormatter = formatter;
 340             }
 341         }
 342     };
 343     public final ObjectProperty&lt;TextFormatter&lt;?&gt;&gt; textFormatterProperty() { return textFormatter; }
 344     public final TextFormatter&lt;?&gt; getTextFormatter() { return textFormatter.get(); }
 345     public final void setTextFormatter(TextFormatter&lt;?&gt; value) { textFormatter.set(value); }
 346 
 347     private final Content content;
 348     /**
 349      * Returns the text input&#39;s content model.
 350      * @return the text input&#39;s content model
 351      */
 352     protected final Content getContent() {
 353         return content;
 354     }
 355 
 356     /**
 357      * The textual content of this TextInputControl.
 358      */
 359     private TextProperty text = new TextProperty();
 360     public final String getText() { return text.get(); }
 361     public final void setText(String value) { text.set(value); }
 362     public final StringProperty textProperty() { return text; }
 363 
 364     /**
 365      * The number of characters in the text input.
 366      */
 367     private ReadOnlyIntegerWrapper length = new ReadOnlyIntegerWrapper(this, &quot;length&quot;);
 368     public final int getLength() { return length.get(); }
 369     public final ReadOnlyIntegerProperty lengthProperty() { return length.getReadOnlyProperty(); }
 370 
 371     /**
 372      * Indicates whether this TextInputControl can be edited by the user.
 373      */
 374     private BooleanProperty editable = new SimpleBooleanProperty(this, &quot;editable&quot;, true) {
 375         @Override protected void invalidated() {
 376             pseudoClassStateChanged(PSEUDO_CLASS_READONLY, ! get());
 377         }
 378     };
 379     public final boolean isEditable() { return editable.getValue(); }
 380     public final void setEditable(boolean value) { editable.setValue(value); }
 381     public final BooleanProperty editableProperty() { return editable; }
 382 
 383     /**
 384      * The current selection.
 385      */
 386     private ReadOnlyObjectWrapper&lt;IndexRange&gt; selection = new ReadOnlyObjectWrapper&lt;IndexRange&gt;(this, &quot;selection&quot;, new IndexRange(0, 0));
 387     public final IndexRange getSelection() { return selection.getValue(); }
 388     public final ReadOnlyObjectProperty&lt;IndexRange&gt; selectionProperty() { return selection.getReadOnlyProperty(); }
 389 
 390     /**
 391      * Defines the characters in the TextInputControl which are selected
 392      */
 393     private ReadOnlyStringWrapper selectedText = new ReadOnlyStringWrapper(this, &quot;selectedText&quot;);
 394     public final String getSelectedText() { return selectedText.get(); }
 395     public final ReadOnlyStringProperty selectedTextProperty() { return selectedText.getReadOnlyProperty(); }
 396 
 397     /**
 398      * The &lt;code&gt;anchor&lt;/code&gt; of the text selection.
 399      * The &lt;code&gt;anchor&lt;/code&gt; and &lt;code&gt;caretPosition&lt;/code&gt; make up the selection
 400      * range. Selection must always be specified in terms of begin &amp;lt;= end, but
 401      * &lt;code&gt;anchor&lt;/code&gt; may be less than, equal to, or greater than the
 402      * &lt;code&gt;caretPosition&lt;/code&gt;. Depending on how the user selects text,
 403      * the anchor might represent the lower or upper bound of the selection.
 404      */
 405     private ReadOnlyIntegerWrapper anchor = new ReadOnlyIntegerWrapper(this, &quot;anchor&quot;, 0);
 406     public final int getAnchor() { return anchor.get(); }
 407     public final ReadOnlyIntegerProperty anchorProperty() { return anchor.getReadOnlyProperty(); }
 408 
 409     /**
 410      * The current position of the caret within the text.
 411      * The &lt;code&gt;anchor&lt;/code&gt; and &lt;code&gt;caretPosition&lt;/code&gt; make up the selection
 412      * range. Selection must always be specified in terms of begin &amp;lt;= end, but
 413      * &lt;code&gt;anchor&lt;/code&gt; may be less than, equal to, or greater than the
 414      * &lt;code&gt;caretPosition&lt;/code&gt;. Depending on how the user selects text,
 415      * the caretPosition might represent the lower or upper bound of the selection.
 416      */
 417     private ReadOnlyIntegerWrapper caretPosition = new ReadOnlyIntegerWrapper(this, &quot;caretPosition&quot;, 0);
 418     public final int getCaretPosition() { return caretPosition.get(); }
 419     public final ReadOnlyIntegerProperty caretPositionProperty() { return caretPosition.getReadOnlyProperty(); }
 420 
 421     private UndoRedoChange undoChangeHead = new UndoRedoChange();
 422     private UndoRedoChange undoChange = undoChangeHead;
 423     private boolean createNewUndoRecord = false;
 424 
 425     /**
 426      * The property describes if it&#39;s currently possible to undo the latest change of the content that was done.
 427      * @defaultValue false
 428      * @since JavaFX 8u40
 429      */
 430     private final ReadOnlyBooleanWrapper undoable = new ReadOnlyBooleanWrapper(this, &quot;undoable&quot;, false);
 431     public final boolean isUndoable() { return undoable.get(); }
 432     public final ReadOnlyBooleanProperty undoableProperty() { return undoable.getReadOnlyProperty(); }
 433 
 434 
 435     /**
 436      * The property describes if it&#39;s currently possible to redo the latest change of the content that was undone.
 437      * @defaultValue false
 438      * @since JavaFX 8u40
 439      */
 440     private final ReadOnlyBooleanWrapper redoable = new ReadOnlyBooleanWrapper(this, &quot;redoable&quot;, false);
 441     public final boolean isRedoable() { return redoable.get(); }
 442     public final ReadOnlyBooleanProperty redoableProperty() { return redoable.getReadOnlyProperty(); }
 443 
 444     /***************************************************************************
 445      *                                                                         *
 446      * Methods                                                                 *
 447      *                                                                         *
 448      **************************************************************************/
 449 
 450     /**
 451      * Returns a subset of the text input&#39;s content.
 452      *
 453      * @param start must be a value between 0 and end - 1.
 454      * @param end must be less than or equal to the length
 455      * @return the subset of the text input&#39;s content
 456      */
 457     public String getText(int start, int end) {
 458         if (start &gt; end) {
 459             throw new IllegalArgumentException(&quot;The start must be &lt;= the end&quot;);
 460         }
 461 
 462         if (start &lt; 0
 463             || end &gt; getLength()) {
 464             throw new IndexOutOfBoundsException();
 465         }
 466 
 467         return getContent().get(start, end);
 468     }
 469 
 470     /**
 471      * Appends a sequence of characters to the content.
 472      *
 473      * @param text a non null String
 474      */
 475     public void appendText(String text) {
 476         insertText(getLength(), text);
 477     }
 478 
 479     /**
 480      * Inserts a sequence of characters into the content.
 481      *
 482      * @param index The location to insert the text.
 483      * @param text The text to insert.
 484      */
 485     public void insertText(int index, String text) {
 486         replaceText(index, index, text);
 487     }
 488 
 489     /**
 490      * Removes a range of characters from the content.
 491      *
 492      * @param range The range of text to delete. The range object must not be null.
 493      *
 494      * @see #deleteText(int, int)
 495      */
 496     public void deleteText(IndexRange range) {
 497         replaceText(range, &quot;&quot;);
 498     }
 499 
 500     /**
 501      * Removes a range of characters from the content.
 502      *
 503      * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
 504      * @param end The ending index in the range, exclusive. This is one-past the last character to
 505      *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
 506      *            and &amp;lt;= the length of the text.
 507      */
 508     public void deleteText(int start, int end) {
 509         replaceText(start, end, &quot;&quot;);
 510     }
 511 
 512     /**
 513      * Replaces a range of characters with the given text.
 514      *
 515      * @param range The range of text to replace. The range object must not be null.
 516      * @param text The text that is to replace the range. This must not be null.
 517      *
 518      * @see #replaceText(int, int, String)
 519      */
 520     public void replaceText(IndexRange range, String text) {
 521         final int start = range.getStart();
 522         final int end = start + range.getLength();
 523         replaceText(start, end, text);
 524     }
 525 
 526     /**
 527      * Replaces a range of characters with the given text.
 528      *
 529      * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
 530      * @param end The ending index in the range, exclusive. This is one-past the last character to
 531      *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
 532      *            and &amp;lt;= the length of the text.
 533      * @param text The text that is to replace the range. This must not be null.
 534      */
 535     public void replaceText(final int start, final int end, final String text) {
 536         if (start &gt; end) {
 537             throw new IllegalArgumentException();
 538         }
 539 
 540         if (text == null) {
 541             throw new NullPointerException();
 542         }
 543 
 544         if (start &lt; 0
 545             || end &gt; getLength()) {
 546             throw new IndexOutOfBoundsException();
 547         }
 548 
 549         if (!this.text.isBound()) {
 550             final int oldLength = getLength();
 551             TextFormatter&lt;?&gt; formatter = getTextFormatter();
 552             TextFormatter.Change change;
 553             if (formatter != null &amp;&amp; formatter.getFilter() != null) {
 554                 change = new TextFormatter.Change(this, getFormatterAccessor(), start, end, text);
 555                 change = formatter.getFilter().apply(change);
 556                 if (change == null) {
 557                     return;
 558                 }
 559             } else {
 560                 change = new TextFormatter.Change(this, getFormatterAccessor(), start, end, filterInput(text));
 561             }
 562 
 563             // Update the content
 564             updateContent(change, oldLength == 0);
 565 
 566         }
 567     }
 568 
 569     private void updateContent(TextFormatter.Change change, boolean forceNewUndoRecord) {
 570         final boolean nonEmptySelection = getSelection().getLength() &gt; 0;
 571         String oldText = getText(change.start, change.end);
 572         int adjustmentAmount = replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition());
 573         String newText = getText(change.start, change.start + change.text.length() - adjustmentAmount);
 574         if (newText.equals(oldText)) {
 575             // Undo record not required as there is no change in the text.
 576             return;
 577         }
 578 
 579         /*
 580          * A new undo record is created, if
 581          * 1. createNewUndoRecord is true, currently it is set to true for paste operation
 582          * 2. Text is selected and a character is typed
 583          * 3. This is the first operation to be added to undo record
 584          * 4. forceNewUndoRecord is true, currently it is set to true if there is no text present
 585          * 5. Space character is typed
 586          * 6. 2500 milliseconds are elapsed since the undo record was created
 587          * 7. Cursor position is changed and a character is typed
 588          * 8. A range of text is replaced programmatically using replaceText()
 589          * Otherwise, the last undo record is updated or discarded.
 590          */
 591 
 592         int endOfUndoChange = undoChange == undoChangeHead ? -1 : undoChange.start + undoChange.newText.length();
 593         boolean isNewSpaceChar = false;
 594         if (newText.equals(&quot; &quot;)) {
 595             if (!UndoRedoChange.isSpaceCharSequence()) {
 596                 isNewSpaceChar = true;
 597                 UndoRedoChange.setSpaceCharSequence(true);
 598             }
 599         } else {
 600             UndoRedoChange.setSpaceCharSequence(false);
 601         }
 602         if (createNewUndoRecord || nonEmptySelection || endOfUndoChange == -1 || forceNewUndoRecord ||
 603                 isNewSpaceChar || UndoRedoChange.hasChangeDurationElapsed() ||
 604                 (endOfUndoChange != change.start &amp;&amp; endOfUndoChange != change.end) || change.end - change.start &gt; 0) {
 605             undoChange = undoChange.add(change.start, oldText, newText);
 606         } else if (change.start != change.end &amp;&amp; change.text.isEmpty()) {
 607             // I know I am deleting, and am located at the end of the range of the current undo record
 608             if (undoChange.newText.length() &gt; 0) {
 609                 undoChange.newText = undoChange.newText.substring(0, change.start - undoChange.start);
 610                 if (undoChange.newText.isEmpty()) {
 611                     // throw away this undo change record
 612                     undoChange = undoChange.discard();
 613                 }
 614             } else {
 615                 if (change.start == endOfUndoChange) {
 616                     undoChange.oldText += oldText;
 617                 } else { // end == endOfUndoChange
 618                     undoChange.oldText = oldText + undoChange.oldText;
 619                     undoChange.start--;
 620                 }
 621             }
 622         } else {
 623             // I know I am adding, and am located at the end of the range of the current undo record
 624             undoChange.newText += newText;
 625         }
 626         updateUndoRedoState();
 627     }
 628 
 629     /**
 630      * Transfers the currently selected range in the text to the clipboard,
 631      * removing the current selection.
 632      */
 633     public void cut() {
 634         copy();
 635         IndexRange selection = getSelection();
 636         deleteText(selection.getStart(), selection.getEnd());
 637     }
 638 
 639     /**
 640      * Transfers the currently selected range in the text to the clipboard,
 641      * leaving the current selection.
 642      */
 643      public void copy() {
 644         final String selectedText = getSelectedText();
 645         if (selectedText.length() &gt; 0) {
 646             final ClipboardContent content = new ClipboardContent();
 647             content.putString(selectedText);
 648             Clipboard.getSystemClipboard().setContent(content);
 649         }
 650     }
 651 
 652     /**
 653      * Transfers the contents in the clipboard into this text,
 654      * replacing the current selection.  If there is no selection, the contents
 655      * in the clipboard is inserted at the current caret position.
 656      */
 657     public void paste() {
 658         final Clipboard clipboard = Clipboard.getSystemClipboard();
 659         if (clipboard.hasString()) {
 660             final String text = clipboard.getString();
 661             if (text != null) {
 662                 createNewUndoRecord = true;
 663                 try {
 664                     replaceSelection(text);
 665                 } finally {
 666                     createNewUndoRecord = false;
 667                 }
 668             }
 669         }
 670     }
 671 
 672     /**
 673      * Moves the selection backward one char in the text. This may have the
 674      * effect of deselecting, depending on the location of the anchor relative
 675      * to the caretPosition. This function effectively just moves the caretPosition.
 676      */
 677     public void selectBackward() {
 678         if (getCaretPosition() &gt; 0 &amp;&amp; getLength() &gt; 0) {
 679             // because the anchor stays put, by moving the caret to the left
 680             // we ensure that a selection is registered and that it is correct
 681             if (charIterator == null) {
 682                 charIterator = BreakIterator.getCharacterInstance();
 683             }
 684             charIterator.setText(getText());
 685             selectRange(getAnchor(), charIterator.preceding(getCaretPosition()));
 686         }
 687     }
 688 
 689     /**
 690      * Moves the selection forward one char in the text. This may have the
 691      * effect of deselecting, depending on the location of the anchor relative
 692      * to the caretPosition. This function effectively just moves the caret forward.
 693      */
 694     public void selectForward() {
 695         final int textLength = getLength();
 696         if (textLength &gt; 0 &amp;&amp; getCaretPosition() &lt; textLength) {
 697             if (charIterator == null) {
 698                 charIterator = BreakIterator.getCharacterInstance();
 699             }
 700             charIterator.setText(getText());
 701             selectRange(getAnchor(), charIterator.following(getCaretPosition()));
 702         }
 703     }
 704 
 705     /**
 706      * The break iterator instances for navigation over words and complex characters.
 707      */
 708     private BreakIterator charIterator;
 709     private BreakIterator wordIterator;
 710 
 711     /**
 712      * Moves the caret to the beginning of previous word. This function
 713      * also has the effect of clearing the selection.
 714      */
 715     public void previousWord() {
 716         previousWord(false);
 717     }
 718 
 719     /**
 720      * Moves the caret to the beginning of next word. This function
 721      * also has the effect of clearing the selection.
 722      */
 723     public void nextWord() {
 724         nextWord(false);
 725     }
 726 
 727     /**
 728      * Moves the caret to the end of the next word. This function
 729      * also has the effect of clearing the selection.
 730      */
 731     public void endOfNextWord() {
 732         endOfNextWord(false);
 733     }
 734 
 735     /**
 736      * Moves the caret to the beginning of previous word. This does not cause
 737      * the selection to be cleared. Rather, the anchor stays put and the caretPosition is
 738      * moved to the beginning of previous word.
 739      */
 740     public void selectPreviousWord() {
 741         previousWord(true);
 742     }
 743 
 744     /**
 745      * Moves the caret to the beginning of next word. This does not cause
 746      * the selection to be cleared. Rather, the anchor stays put and the caretPosition is
 747      * moved to the beginning of next word.
 748      */
 749     public void selectNextWord() {
 750         nextWord(true);
 751     }
 752 
 753     /**
 754      * Moves the caret to the end of the next word. This does not cause
 755      * the selection to be cleared.
 756      */
 757     public void selectEndOfNextWord() {
 758         endOfNextWord(true);
 759     }
 760 
 761     private void previousWord(boolean select) {
 762         final int textLength = getLength();
 763         final String text = getText();
 764         if (textLength &lt;= 0) {
 765             return;
 766         }
 767 
 768         if (wordIterator == null) {
 769             wordIterator = BreakIterator.getWordInstance();
 770         }
 771         wordIterator.setText(text);
 772 
 773         int pos = wordIterator.preceding(Utils.clamp(0, getCaretPosition(), textLength));
 774 
 775         // Skip the non-word region, then move/select to the beginning of the word.
 776         while (pos != BreakIterator.DONE &amp;&amp;
 777                !Character.isLetterOrDigit(text.charAt(Utils.clamp(0, pos, textLength-1)))) {
 778             pos = wordIterator.preceding(Utils.clamp(0, pos, textLength));
 779         }
 780 
 781         // move/select
 782         selectRange(select ? getAnchor() : pos, pos);
 783     }
 784 
 785     private void nextWord(boolean select) {
 786         final int textLength = getLength();
 787         final String text = getText();
 788         if (textLength &lt;= 0) {
 789             return;
 790         }
 791 
 792         if (wordIterator == null) {
 793             wordIterator = BreakIterator.getWordInstance();
 794         }
 795         wordIterator.setText(text);
 796 
 797         int last = wordIterator.following(Utils.clamp(0, getCaretPosition(), textLength-1));
 798         int current = wordIterator.next();
 799 
 800         // Skip whitespace characters to the beginning of next word, but
 801         // stop at newline. Then move the caret or select a range.
 802         while (current != BreakIterator.DONE) {
 803             for (int p=last; p&lt;=current; p++) {
 804                 char ch = text.charAt(Utils.clamp(0, p, textLength-1));
 805                 // Avoid using Character.isSpaceChar() and Character.isWhitespace(),
 806                 // because they include LINE_SEPARATOR, PARAGRAPH_SEPARATOR, etc.
 807                 if (ch != &#39; &#39; &amp;&amp; ch != &#39;\t&#39;) {
 808                     if (select) {
 809                         selectRange(getAnchor(), p);
 810                     } else {
 811                         selectRange(p, p);
 812                     }
 813                     return;
 814                 }
 815             }
 816             last = current;
 817             current = wordIterator.next();
 818         }
 819 
 820         // move/select to the end
 821         if (select) {
 822             selectRange(getAnchor(), textLength);
 823         } else {
 824             end();
 825         }
 826     }
 827 
 828     private void endOfNextWord(boolean select) {
 829         final int textLength = getLength();
 830         final String text = getText();
 831         if (textLength &lt;= 0) {
 832             return;
 833         }
 834 
 835         if (wordIterator == null) {
 836             wordIterator = BreakIterator.getWordInstance();
 837         }
 838         wordIterator.setText(text);
 839 
 840         int last = wordIterator.following(Utils.clamp(0, getCaretPosition(), textLength));
 841         int current = wordIterator.next();
 842 
 843         // skip the non-word region, then move/select to the end of the word.
 844         while (current != BreakIterator.DONE) {
 845             for (int p=last; p&lt;=current; p++) {
 846                 if (!Character.isLetterOrDigit(text.charAt(Utils.clamp(0, p, textLength-1)))) {
 847                     if (select) {
 848                         selectRange(getAnchor(), p);
 849                     } else {
 850                         selectRange(p, p);
 851                     }
 852                     return;
 853                 }
 854             }
 855             last = current;
 856             current = wordIterator.next();
 857         }
 858 
 859         // move/select to the end
 860         if (select) {
 861             selectRange(getAnchor(), textLength);
 862         } else {
 863             end();
 864         }
 865     }
 866 
 867     /**
 868      * Selects all text in the text input.
 869      */
 870     public void selectAll() {
 871         selectRange(0, getLength());
 872     }
 873 
 874     /**
 875      * Moves the caret to before the first char of the text. This function
 876      * also has the effect of clearing the selection.
 877      */
 878     public void home() {
 879         // user wants to go to start
 880         selectRange(0, 0);
 881     }
 882 
 883     /**
 884      * Moves the caret to after the last char of the text. This function
 885      * also has the effect of clearing the selection.
 886      */
 887     public void end() {
 888         // user wants to go to end
 889         final int textLength = getLength();
 890         if (textLength &gt; 0) {
 891             selectRange(textLength, textLength);
 892         }
 893     }
 894 
 895     /**
 896      * Moves the caret to before the first char of text. This does not cause
 897      * the selection to be cleared. Rather, the anchor stays put and the
 898      * caretPosition is moved to before the first char.
 899      */
 900     public void selectHome() {
 901         selectRange(getAnchor(), 0);
 902     }
 903 
 904     /**
 905      * Moves the caret to after the last char of text. This does not cause
 906      * the selection to be cleared. Rather, the anchor stays put and the
 907      * caretPosition is moved to after the last char.
 908      */
 909     public void selectEnd() {
 910         final int textLength = getLength();
 911         if (textLength &gt; 0) selectRange(getAnchor(), textLength);
 912     }
 913 
 914     /**
 915      * Deletes the character that precedes the current caret position from the
 916      * text if there is no selection, or deletes the selection if there is one.
 917      * This function returns true if the deletion succeeded, false otherwise.
 918      * @return true if the deletion succeeded, false otherwise
 919      */
 920     public boolean deletePreviousChar() {
 921         boolean failed = true;
 922         if (isEditable() &amp;&amp; !isDisabled()) {
 923             final String text = getText();
 924             final int dot = getCaretPosition();
 925             final int mark = getAnchor();
 926             if (dot != mark) {
 927                 // there is a selection of text to remove
 928                 replaceSelection(&quot;&quot;);
 929                 failed = false;
 930             } else if (dot &gt; 0) {
 931                 // The caret is not at the beginning, so remove some characters.
 932                 // Typically you&#39;d only be removing a single character, but
 933                 // in some cases you must remove two depending on the unicode
 934                 // characters
 935                 // Note: Do not use charIterator here, because we do want to
 936                 // break up clusters when deleting backwards.
 937                 int p = Character.offsetByCodePoints(text, dot, -1);
 938                 deleteText(p, dot);
 939                 failed = false;
 940             }
 941         }
 942         return !failed;
 943     }
 944 
 945     /**
 946      * Deletes the character that follows the current caret position from the
 947      * text if there is no selection, or deletes the selection if there is one.
 948      * This function returns true if the deletion succeeded, false otherwise.
 949      * @return true if the deletion succeeded, false otherwise
 950      */
 951     public boolean deleteNextChar() {
 952         boolean failed = true;
 953         if (isEditable() &amp;&amp; !isDisabled()) {
 954             final int textLength = getLength();
 955             final String text = getText();
 956             final int dot = getCaretPosition();
 957             final int mark = getAnchor();
 958             if (dot != mark) {
 959                 // there is a selection of text to remove
 960                 replaceSelection(&quot;&quot;);
 961                 failed = false;
 962             } else if (textLength &gt; 0 &amp;&amp; dot &lt; textLength) {
 963                 // The caret is not at the end, so remove some characters.
 964                 // Typically you&#39;d only be removing a single character, but
 965                 // in some cases you must remove two depending on the unicode
 966                 // characters
 967                 if (charIterator == null) {
 968                     charIterator = BreakIterator.getCharacterInstance();
 969                 }
 970                 charIterator.setText(text);
 971                 int p = charIterator.following(dot);
 972                 deleteText(dot, p);
 973                 failed = false;
 974             }
 975         }
 976         return !failed;
 977     }
 978 
 979     /**
 980      * Moves the caret position forward. If there is no selection, then the
 981      * caret position is moved one character forward. If there is a selection,
 982      * then the caret position is moved to the end of the selection and
 983      * the selection cleared.
 984      */
 985     public void forward() {
 986         // user has moved caret to the right
 987         final int textLength = getLength();
 988         final int dot = getCaretPosition();
 989         final int mark = getAnchor();
 990         if (dot != mark) {
 991             int pos = Math.max(dot, mark);
 992             selectRange(pos, pos);
 993         } else if (dot &lt; textLength &amp;&amp; textLength &gt; 0) {
 994             if (charIterator == null) {
 995                 charIterator = BreakIterator.getCharacterInstance();
 996             }
 997             charIterator.setText(getText());
 998             int pos = charIterator.following(dot);
 999             selectRange(pos, pos);
1000         }
1001         deselect();
1002     }
1003 
1004     /**
1005      * Moves the caret position backward. If there is no selection, then the
1006      * caret position is moved one character backward. If there is a selection,
1007      * then the caret position is moved to the beginning of the selection and
1008      * the selection cleared.
1009      *
1010      * Note: This function is intended to be used by experts, primarily
1011      *       by those implementing new Skins or Behaviors. It is not common
1012      *       for developers or designers to access this function directly.
1013      */
1014     public void backward() {
1015         // user has moved caret to the left
1016         final int textLength = getLength();
1017         final int dot = getCaretPosition();
1018         final int mark = getAnchor();
1019         if (dot != mark) {
1020             int pos = Math.min(dot, mark);
1021             selectRange(pos, pos);
1022         } else if (dot &gt; 0 &amp;&amp; textLength &gt; 0) {
1023             if (charIterator == null) {
1024                 charIterator = BreakIterator.getCharacterInstance();
1025             }
1026             charIterator.setText(getText());
1027             int pos = charIterator.preceding(dot);
1028             selectRange(pos, pos);
1029         }
1030         deselect();
1031     }
1032 
1033     /**
1034      * Positions the caret to the position indicated by {@code pos}. This
1035      * function will also clear the selection.
1036      * @param pos the position
1037      */
1038     public void positionCaret(int pos) {
1039         final int p = Utils.clamp(0, pos, getLength());
1040         selectRange(p, p);
1041     }
1042 
1043     /**
1044      * Positions the caret to the position indicated by {@code pos} and extends
1045      * the selection, if there is one. If there is no selection, then a
1046      * selection is formed where the anchor is at the current caret position
1047      * and the caretPosition is moved to pos.
1048      * @param pos the position
1049      */
1050     public void selectPositionCaret(int pos) {
1051         selectRange(getAnchor(), Utils.clamp(0, pos, getLength()));
1052     }
1053 
1054     /**
1055      * Positions the anchor and caretPosition explicitly.
1056      * @param anchor the anchor
1057      * @param caretPosition the caretPosition
1058      */
1059     public void selectRange(int anchor, int caretPosition) {
1060         caretPosition = Utils.clamp(0, caretPosition, getLength());
1061         anchor = Utils.clamp(0, anchor, getLength());
1062 
1063         TextFormatter.Change change = new TextFormatter.Change(this, getFormatterAccessor(), anchor, caretPosition);
1064         TextFormatter&lt;?&gt; formatter = getTextFormatter();
1065         if (formatter != null &amp;&amp; formatter.getFilter() != null) {
1066             change = formatter.getFilter().apply(change);
1067             if (change == null) {
1068                 return;
1069             }
1070         }
1071 
1072         updateContent(change, false);
1073     }
1074 
1075     private void doSelectRange(int anchor, int caretPosition) {
1076         this.caretPosition.set(Utils.clamp(0, caretPosition, getLength()));
1077         this.anchor.set(Utils.clamp(0, anchor, getLength()));
1078         this.selection.set(IndexRange.normalize(getAnchor(), getCaretPosition()));
1079         notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_START);
1080     }
1081 
1082     /**
1083      * This function will extend the selection to include the specified pos.
1084      * This is different from selectPositionCaret in that it does not simply
1085      * move the caret. Rather, it will reposition the caret and anchor as necessary
1086      * to ensure that pos becomes the new caret and the far other end of the
1087      * selection becomes the anchor.
1088      * @param pos the position
1089      */
1090     public void extendSelection(int pos) {
1091         final int p = Utils.clamp(0, pos, getLength());
1092         final int dot = getCaretPosition();
1093         final int mark = getAnchor();
1094         int start = Math.min(dot, mark);
1095         int end = Math.max(dot, mark);
1096         if (p &lt; start) {
1097             selectRange(end, p);
1098         } else {
1099             selectRange(start, p);
1100         }
1101     }
1102 
1103     /**
1104      * Clears the text.
1105      */
1106     public void clear() {
1107         deselect();
1108         if (!text.isBound()) {
1109             setText(&quot;&quot;);
1110         }
1111     }
1112 
1113     /**
1114      * Clears the selection.
1115      */
1116     public void deselect() {
1117         // set the anchor equal to the caret position, which clears the selection
1118         // while also preserving the caret position
1119         selectRange(getCaretPosition(), getCaretPosition());
1120     }
1121 
1122     /**
1123      * Replaces the selection with the given replacement String. If there is
1124      * no selection, then the replacement text is simply inserted at the current
1125      * caret position. If there was a selection, then the selection is cleared
1126      * and the given replacement text inserted.
1127      * @param replacement the replacement string
1128      */
1129     public void replaceSelection(String replacement) {
1130         replaceText(getSelection(), replacement);
1131     }
1132 
1133     /**
1134      * If possible, undoes the last modification. If {@link #isUndoable()} returns
1135      * false, then calling this method has no effect.
1136      * @since JavaFX 8u40
1137      */
1138     public final void undo() {
1139         if (isUndoable()) {
1140             // Apply reverse change here
1141             final int start = undoChange.start;
1142             final String newText = undoChange.newText;
1143             final String oldText = undoChange.oldText;
1144 
1145             blockSelectedTextUpdate = true;
1146             try {
1147                 if (newText != null) {
1148                     getContent().delete(start, start + newText.length(), oldText.isEmpty());
1149                 }
1150 
1151                 if (oldText != null) {
1152                     getContent().insert(start, oldText, true);
1153                     doSelectRange(start, start + oldText.length());
1154                 } else {
1155                     doSelectRange(start, start + newText.length());
1156                 }
1157 
1158                 undoChange = undoChange.prev;
1159             } finally {
1160                 blockSelectedTextUpdate = false;
1161                 updateSelectedText();
1162             }
1163         }
1164         updateUndoRedoState();
1165     }
1166 
1167     /**
1168      * If possible, redoes the last undone modification. If {@link #isRedoable()} returns
1169      * false, then calling this method has no effect.
1170      * @since JavaFX 8u40
1171      */
1172     public final void redo() {
1173         if (isRedoable()) {
1174             // Apply change here
1175             undoChange = undoChange.next;
1176             final int start = undoChange.start;
1177             final String newText = undoChange.newText;
1178             final String oldText = undoChange.oldText;
1179 
1180             blockSelectedTextUpdate = true;
1181             try {
1182                 if (oldText != null) {
1183                     getContent().delete(start, start + oldText.length(), newText.isEmpty());
1184                 }
1185 
1186                 if (newText != null) {
1187                     getContent().insert(start, newText, true);
1188                     doSelectRange(start + newText.length(), start + newText.length());
1189                 } else {
1190                     doSelectRange(start, start);
1191                 }
1192             } finally {
1193                 blockSelectedTextUpdate = false;
1194                 updateSelectedText();
1195             }
1196         }
1197         updateUndoRedoState();
1198         // else beep ?
1199     }
1200 
1201     // Used by TextArea, although there are probably other better ways of
1202     // doing this.
1203     void textUpdated() { }
1204 
1205     private void resetUndoRedoState() {
1206         undoChange = undoChangeHead;
1207         undoChange.next = null;
1208         updateUndoRedoState();
1209     }
1210 
1211     private void updateUndoRedoState() {
1212         undoable.set(undoChange != undoChangeHead);
1213         redoable.set(undoChange.next != null);
1214     }
1215 
1216     private boolean filterAndSet(String value) {
1217         // Send the new value through the textFormatter, if one exists.
1218         TextFormatter&lt;?&gt; formatter = getTextFormatter();
1219         int length = content.length();
1220         if (formatter != null &amp;&amp; formatter.getFilter() != null &amp;&amp; !text.isBound()) {
1221             TextFormatter.Change change = new TextFormatter.Change(
1222                     TextInputControl.this, getFormatterAccessor(), 0, length, value, 0, 0);
1223             change = formatter.getFilter().apply(change);
1224             if (change == null) {
1225                 return false;
1226             }
1227             replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition());
1228         } else {
1229             replaceText(0, length, value, 0, 0);
1230         }
1231         return true;
1232     }
1233 
1234     /**
1235      * This is what is ultimately called by every code path that will update
1236      * the content (except for undo / redo). The input into this method has
1237      * already run through the textFormatter where appropriate.
1238      *
1239      * @param start            The start index into the existing text which
1240      *                         will be replaced by the new value
1241      * @param end              The end index into the existing text which will
1242      *                         be replaced by the new value. As with
1243      *                         String.replace this is a lastIndex+1 value
1244      * @param value            The new text value
1245      * @param anchor           The new selection anchor after the change is made
1246      * @param caretPosition    The new selection caretPosition after the change
1247      *                         is made.
1248      * @return The amount of adjustment made to the end / anchor / caretPosition to
1249      *         accommodate for subsequent filtering (such as the filtering of
1250      *         new lines by the TextField)
1251      */
1252     private int replaceText(int start, int end, String value, int anchor, int caretPosition) {
1253         // RT-16566: Need to take into account stripping of chars into the
1254         // final anchor &amp; caret position
1255         blockSelectedTextUpdate = true;
1256         try {
1257             int length = getLength();
1258             int adjustmentAmount = 0;
1259             if (end != start) {
1260                 getContent().delete(start, end, value.isEmpty());
1261                 length -= (end - start);
1262             }
1263             if (value != null) {
1264                 getContent().insert(start, value, true);
1265                 adjustmentAmount = value.length() - (getLength() - length);
1266                 anchor -= adjustmentAmount;
1267                 caretPosition -= adjustmentAmount;
1268             }
1269             doSelectRange(anchor, caretPosition);
1270             return adjustmentAmount;
1271         } finally {
1272             blockSelectedTextUpdate = false;
1273             updateSelectedText();
1274         }
1275     }
1276 
1277     private &lt;T&gt; void updateText(TextFormatter&lt;T&gt; formatter) {
1278         T value = formatter.getValue();
1279         StringConverter&lt;T&gt; converter = formatter.getValueConverter();
1280         if (converter != null) {
1281             String text = converter.toString(value);
1282             if (text == null) text = &quot;&quot;;
1283             replaceText(0, getLength(), text, text.length(), text.length());
1284         }
1285     }
1286 
1287     /**
1288      * Commit the current text and convert it to a value.
1289      * @since JavaFX 8u40
1290      */
1291     public final void commitValue() {
1292         if (getTextFormatter() != null) {
1293             getTextFormatter().updateValue(getText());
1294         }
1295     }
1296 
1297     /**
1298      * If the field is currently being edited, this call will set text to the last commited value.
1299      * @since JavaFX 8u40
1300      */
1301     public final void cancelEdit() {
1302         if (getTextFormatter() != null) {
1303             updateText(getTextFormatter());
1304         }
1305     }
1306 
1307     private FormatterAccessor accessor;
1308 
1309     private FormatterAccessor getFormatterAccessor() {
1310         if (accessor == null) {
1311             accessor = new TextInputControlFromatterAccessor();
1312         }
1313         return accessor;
1314     }
1315 
1316     String filterInput(String text) {
1317         // This method should be overridden by child classes.
1318         // It is overridden in TextField and TextArea as needed.
1319         return text;
1320     }
1321 
1322     /**
1323      * A little utility method for stripping out unwanted characters.
1324      *
1325      * @param txt
1326      * @param stripNewlines
1327      * @param stripTabs
1328      * @return The string after having the unwanted characters stripped out.
1329      */
1330     static String filterInput(String txt, boolean stripNewlines, boolean stripTabs) {
1331         // Most of the time, when text is inserted, there are no illegal
1332         // characters. So we&#39;ll do a &quot;cheap&quot; check for illegal characters.
1333         // If we find one, we&#39;ll do a longer replace algorithm. In the
1334         // case of illegal characters, this may at worst be an O(2n) solution.
1335         // Strip out any characters that are outside the printed range
1336         if (containsInvalidCharacters(txt, stripNewlines, stripTabs)) {
1337             StringBuilder s = new StringBuilder(txt.length());
1338             for (int i=0; i&lt;txt.length(); i++) {
1339                 final char c = txt.charAt(i);
1340                 if (!isInvalidCharacter(c, stripNewlines, stripTabs)) {
1341                     s.append(c);
1342                 }
1343             }
1344             txt = s.toString();
1345         }
1346         return txt;
1347     }
1348 
1349     static boolean containsInvalidCharacters(String txt, boolean newlineIllegal, boolean tabIllegal) {
1350         for (int i=0; i&lt;txt.length(); i++) {
1351             final char c = txt.charAt(i);
1352             if (isInvalidCharacter(c, newlineIllegal, tabIllegal)) return true;
1353         }
1354         return false;
1355     }
1356 
1357     private static boolean isInvalidCharacter(char c, boolean newlineIllegal, boolean tabIllegal) {
1358         if (c == 0x7F) return true;
1359         if (c == 0xA) return newlineIllegal;
1360         if (c == 0x9) return tabIllegal;
1361         if (c &lt; 0x20) return true;
1362         return false;
1363     }
1364 
1365     // It can be bound, in which case we will force it to be an eager
1366     // binding so that we update the content eagerly
1367     // It can be bidirectionally bound, which basically will just work
1368     // If somebody changes the content directly, it will be notified and
1369     // send an invalidation event.
1370     private class TextProperty extends StringProperty {
1371         // This is used only when the property is bound
1372         private ObservableValue&lt;? extends String&gt; observable = null;
1373         // Added to the observable when bound
1374         private InvalidationListener listener = null;
1375         // Used for event handling
1376         private ExpressionHelper&lt;String&gt; helper = null;
1377         // The developer my set the Text property to null. Although
1378         // the Content must be given an empty String, we must still
1379         // treat the value as though it were null, so that a subsequent
1380         // getText() will return null.
1381         private boolean textIsNull = false;
1382 
1383         @Override public String get() {
1384             // Since we force eager binding and content is always up to date,
1385             // we just need to get it from content and not through the binding
1386             return textIsNull ? null : content.get();
1387         }
1388 
1389         @Override public void set(String value) {
1390             if (isBound()) {
1391                 throw new java.lang.RuntimeException(&quot;A bound value cannot be set.&quot;);
1392             }
1393             doSet(value);
1394             markInvalid();
1395         }
1396 
1397         /**
1398          * Called whenever the content on the control has changed (as determined
1399          * by a listener on the content).
1400          */
1401         private void controlContentHasChanged() {
1402             markInvalid();
1403             notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);
1404         }
1405 
1406         @Override public void bind(ObservableValue&lt;? extends String&gt; observable) {
1407             if (observable == null) {
1408                 throw new NullPointerException(&quot;Cannot bind to null&quot;);
1409             }
1410             if (!observable.equals(this.observable)) {
1411                 unbind();
1412                 this.observable = observable;
1413                 if (listener == null) {
1414                     listener = new Listener();
1415                 }
1416                 this.observable.addListener(listener);
1417                 markInvalid();
1418                 doSet(observable.getValue());
1419             }
1420         }
1421 
1422         @Override public void unbind() {
1423             if (observable != null) {
1424                 doSet(observable.getValue());
1425                 observable.removeListener(listener);
1426                 observable = null;
1427             }
1428         }
1429 
1430         @Override public boolean isBound() {
1431             return observable != null;
1432         }
1433 
1434         @Override public void addListener(InvalidationListener listener) {
1435             helper = ExpressionHelper.addListener(helper, this, listener);
1436         }
1437 
1438         @Override public void removeListener(InvalidationListener listener) {
1439             helper = ExpressionHelper.removeListener(helper, listener);
1440         }
1441 
1442         @Override public void addListener(ChangeListener&lt;? super String&gt; listener) {
1443             helper = ExpressionHelper.addListener(helper, this, listener);
1444         }
1445 
1446         @Override public void removeListener(ChangeListener&lt;? super String&gt; listener) {
1447             helper = ExpressionHelper.removeListener(helper, listener);
1448         }
1449 
1450         @Override public Object getBean() {
1451             return TextInputControl.this;
1452         }
1453 
1454         @Override public String getName() {
1455             return &quot;text&quot;;
1456         }
1457 
1458         private void fireValueChangedEvent() {
1459             ExpressionHelper.fireValueChangedEvent(helper);
1460         }
1461 
1462         private void markInvalid() {
1463             fireValueChangedEvent();
1464         }
1465 
1466         /**
1467          * doSet is called whenever the setText() method was called directly
1468          * on the TextInputControl, or when the text property was bound,
1469          * unbound, or reacted to a binding invalidation. It is *not* called
1470          * when modifications to the content happened indirectly, such as
1471          * through the replaceText / replaceSelection methods.
1472          *
1473          * @param value The new value
1474          */
1475         private void doSet(String value) {
1476             // Guard against the null value.
1477             textIsNull = value == null;
1478             if (value == null) value = &quot;&quot;;
1479 
1480             if (!filterAndSet(value)) return;
1481 
1482             if (getTextFormatter() != null) {
1483                 getTextFormatter().updateValue(getText());
1484             }
1485 
1486             textUpdated();
1487 
1488             // If the programmer has directly manipulated the text property
1489             // or has it bound up, then we will clear out any modifications
1490             // from the undo manager as we must suppose that the control is
1491             // being reused, for example, between forms.
1492             resetUndoRedoState();
1493         }
1494 
1495         private class Listener implements InvalidationListener {
1496             @Override
1497             public void invalidated(Observable valueModel) {
1498                 // We now need to force it to be eagerly recomputed
1499                 // because we need to push these changes to the
1500                 // content model. Because changing the model ends
1501                 // up calling invalidate and markInvalid, the
1502                 // listeners will all be notified.
1503                 doSet(observable.getValue());
1504             }
1505         }
1506     }
1507 
1508     /**
1509      * Used to form a linked-list of Undo / Redo changes. Each UndoRedoChange
1510      * records the old and new text, and the start index. It also has
1511      * the links to the previous and next Changes in the chain. There
1512      * are two special UndoRedoChange objects in this chain representing the
1513      * head and the tail so we can have beforeFirst and afterLast
1514      * behavior as necessary.
1515      */
1516     static class UndoRedoChange {
1517         static long prevRecordTime;
1518         static final long CHANGE_DURATION = 2500; // milliseconds
1519         static boolean spaceCharSequence = false;
1520         int start;
1521         String oldText;
1522         String newText;
1523         UndoRedoChange prev;
1524         UndoRedoChange next;
1525 
1526         UndoRedoChange() { }
1527 
1528         public UndoRedoChange add(int start, String oldText, String newText) {
1529             UndoRedoChange c = new UndoRedoChange();
1530             c.start = start;
1531             c.oldText = oldText;
1532             c.newText = newText;
1533             c.prev = this;
1534             next = c;
1535             prevRecordTime = System.currentTimeMillis();
1536             return c;
1537         }
1538 
1539         static boolean hasChangeDurationElapsed() {
1540             return (System.currentTimeMillis() - prevRecordTime &gt; CHANGE_DURATION) ;
1541         }
1542 
1543         static void setSpaceCharSequence(boolean value) {
1544             spaceCharSequence = value;
1545         }
1546         static boolean isSpaceCharSequence() {
1547             return spaceCharSequence;
1548         }
1549 
1550         public UndoRedoChange discard() {
1551             prev.next = next;
1552             return prev;
1553         }
1554 
1555         // Handy to use when debugging, just put it in undo or redo
1556         // method or replaceText to see what is happening to the undo
1557         // history as it occurs.
1558         void debugPrint() {
1559             UndoRedoChange c = this;
1560             System.out.print(&quot;[&quot;);
1561             while (c != null) {
1562                 System.out.print(c.toString());
1563                 if (c.next != null) System.out.print(&quot;, &quot;);
1564                 c = c.next;
1565             }
1566             System.out.println(&quot;]&quot;);
1567         }
1568 
1569         @Override public String toString() {
1570             if (oldText == null &amp;&amp; newText == null) {
1571                 return &quot;head&quot;;
1572             }
1573             if (oldText.isEmpty() &amp;&amp; !newText.isEmpty()) {
1574                 return &quot;added &#39;&quot; + newText + &quot;&#39; at index &quot; + start;
1575             } else if (!oldText.isEmpty() &amp;&amp; !newText.isEmpty()) {
1576                 return &quot;replaced &#39;&quot; + oldText + &quot;&#39; with &#39;&quot; + newText + &quot;&#39; at index &quot; + start;
1577             } else {
1578                 return &quot;deleted &#39;&quot; + oldText + &quot;&#39; at index &quot; + start;
1579             }
1580         }
1581     }
1582 
1583     /***************************************************************************
1584      *                                                                         *
1585      * Stylesheet Handling                                                     *
1586      *                                                                         *
1587      **************************************************************************/
1588 
1589 
1590     private static final PseudoClass PSEUDO_CLASS_READONLY
1591             = PseudoClass.getPseudoClass(&quot;readonly&quot;);
1592 
1593     private static class StyleableProperties {
1594         private static final FontCssMetaData&lt;TextInputControl&gt; FONT =
1595             new FontCssMetaData&lt;TextInputControl&gt;(&quot;-fx-font&quot;, Font.getDefault()) {
1596 
1597             @Override
1598             public boolean isSettable(TextInputControl n) {
1599                 return n.font == null || !n.font.isBound();
1600             }
1601 
1602             @Override
1603             public StyleableProperty&lt;Font&gt; getStyleableProperty(TextInputControl n) {
1604                 return (StyleableProperty&lt;Font&gt;)(WritableValue&lt;Font&gt;)n.fontProperty();
1605             }
1606         };
1607 
1608         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1609         static {
1610             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1611                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
1612             styleables.add(FONT);
1613             STYLEABLES = Collections.unmodifiableList(styleables);
1614         }
1615     }
1616 
1617     /**
1618      * @return The CssMetaData associated with this class, which may include the
1619      * CssMetaData of its superclasses.
1620      * @since JavaFX 8.0
1621      */
1622     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1623         return StyleableProperties.STYLEABLES;
1624     }
1625 
1626     /**
1627      * {@inheritDoc}
1628      * @since JavaFX 8.0
1629      */
1630     @Override
1631     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
1632         return getClassCssMetaData();
1633     }
1634 
1635 
1636     /***************************************************************************
1637      *                                                                         *
1638      * Accessibility handling                                                  *
1639      *                                                                         *
1640      **************************************************************************/
1641 
1642     /** {@inheritDoc} */
1643     @Override
1644     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1645         switch (attribute) {
1646             case TEXT: {
1647                 String accText = getAccessibleText();
1648                 if (accText != null &amp;&amp; !accText.isEmpty()) return accText;
1649 
1650                 String text = getText();
1651                 if (text == null || text.isEmpty()) {
1652                     text = getPromptText();
1653                 }
1654                 return text;
1655             }
1656             case EDITABLE: return isEditable();
1657             case SELECTION_START: return getSelection().getStart();
1658             case SELECTION_END: return getSelection().getEnd();
1659             case CARET_OFFSET: return getCaretPosition();
1660             case FONT: return getFont();
1661             default: return super.queryAccessibleAttribute(attribute, parameters);
1662         }
1663     }
1664 
1665     /** {@inheritDoc} */
1666     @Override
1667     public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
1668         switch (action) {
1669             case SET_TEXT: {
1670                 String value = (String) parameters[0];
1671                 if (value != null) setText(value);
1672                 break;
1673             }
1674             case SET_TEXT_SELECTION: {
1675                 Integer start = (Integer) parameters[0];
1676                 Integer end = (Integer) parameters[1];
1677                 if (start != null &amp;&amp; end != null) {
1678                     selectRange(start,  end);
1679                 }
1680                 break;
1681             }
1682             default: super.executeAccessibleAction(action, parameters);
1683         }
1684     }
1685 
1686     private class TextInputControlFromatterAccessor implements FormatterAccessor {
1687         @Override
1688         public int getTextLength() {
1689             return TextInputControl.this.getLength();
1690         }
1691 
1692         @Override
1693         public String getText(int begin, int end) {
1694             return TextInputControl.this.getText(begin, end);
1695         }
1696 
1697         @Override
1698         public int getCaret() {
1699             return TextInputControl.this.getCaretPosition();
1700         }
1701 
1702         @Override
1703         public int getAnchor() {
1704             return TextInputControl.this.getAnchor();
1705         }
1706     }
1707 
1708 }
    </pre>
  </body>
</html>