<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/java/com/sun/prism/j2d/J2DPrismGraphics.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.prism.j2d;
  27 
  28 import java.awt.LinearGradientPaint;
  29 import java.awt.font.GlyphVector;
  30 import java.awt.geom.NoninvertibleTransformException;
  31 import java.awt.geom.Rectangle2D;
  32 import java.lang.ref.WeakReference;
  33 import java.util.List;
  34 import java.util.concurrent.ConcurrentHashMap;
  35 import com.sun.glass.ui.Screen;
  36 import com.sun.javafx.PlatformUtil;
  37 import com.sun.javafx.font.CompositeGlyphMapper;
  38 import com.sun.javafx.font.CompositeStrike;
  39 import com.sun.javafx.font.FontResource;
  40 import com.sun.javafx.font.FontStrike;
  41 import com.sun.javafx.font.Metrics;
  42 import com.sun.javafx.geom.PathIterator;
  43 import com.sun.javafx.geom.RectBounds;
  44 import com.sun.javafx.geom.Rectangle;
  45 import com.sun.javafx.geom.Shape;
  46 import com.sun.javafx.geom.transform.Affine2D;
  47 import com.sun.javafx.geom.transform.BaseTransform;
  48 import com.sun.javafx.geom.transform.GeneralTransform3D;
  49 import com.sun.javafx.scene.text.GlyphList;
  50 import com.sun.javafx.sg.prism.NGCamera;
  51 import com.sun.javafx.sg.prism.NGLightBase;
  52 import com.sun.javafx.sg.prism.NodePath;
  53 import com.sun.prism.BasicStroke;
  54 import com.sun.prism.CompositeMode;
  55 import com.sun.prism.MaskTextureGraphics;
  56 import com.sun.prism.RTTexture;
  57 import com.sun.prism.ReadbackGraphics;
  58 import com.sun.prism.RenderTarget;
  59 import com.sun.prism.ResourceFactory;
  60 import com.sun.prism.Texture;
  61 import com.sun.prism.Texture.WrapMode;
  62 import com.sun.prism.impl.PrismSettings;
  63 import com.sun.prism.j2d.paint.MultipleGradientPaint.ColorSpaceType;
  64 import com.sun.prism.j2d.paint.RadialGradientPaint;
  65 import com.sun.prism.paint.Color;
  66 import com.sun.prism.paint.Gradient;
  67 import com.sun.prism.paint.ImagePattern;
  68 import com.sun.prism.paint.LinearGradient;
  69 import com.sun.prism.paint.Paint;
  70 import com.sun.prism.paint.RadialGradient;
  71 import com.sun.prism.paint.Stop;
  72 import static java.awt.RenderingHints.KEY_ANTIALIASING;
  73 import static java.awt.RenderingHints.KEY_TEXT_ANTIALIASING;
  74 import static java.awt.RenderingHints.VALUE_ANTIALIAS_OFF;
  75 import static java.awt.RenderingHints.VALUE_ANTIALIAS_ON;
  76 import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB;
  77 import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON;
  78 
  79 public class J2DPrismGraphics
  80     // Do not subclass BaseGraphics without fixing drawTextureVO below...
  81     implements ReadbackGraphics, MaskTextureGraphics
  82     // Do not implement RectShadowGraphics without fixing RT-15016 (note that
  83     // BaseGraphics implements RectShadowGraphics).
  84 {
  85     static {
  86         // Assuming direct translation of BasicStroke enums:
  87         assert(com.sun.prism.BasicStroke.CAP_BUTT == java.awt.BasicStroke.CAP_BUTT);
  88         assert(com.sun.prism.BasicStroke.CAP_ROUND == java.awt.BasicStroke.CAP_ROUND);
  89         assert(com.sun.prism.BasicStroke.CAP_SQUARE == java.awt.BasicStroke.CAP_SQUARE);
  90         assert(com.sun.prism.BasicStroke.JOIN_BEVEL == java.awt.BasicStroke.JOIN_BEVEL);
  91         assert(com.sun.prism.BasicStroke.JOIN_MITER == java.awt.BasicStroke.JOIN_MITER);
  92         assert(com.sun.prism.BasicStroke.JOIN_ROUND == java.awt.BasicStroke.JOIN_ROUND);
  93         // Assuming direct translation of PathIterator enums:
  94         assert(com.sun.javafx.geom.PathIterator.WIND_EVEN_ODD == java.awt.geom.PathIterator.WIND_EVEN_ODD);
  95         assert(com.sun.javafx.geom.PathIterator.WIND_NON_ZERO == java.awt.geom.PathIterator.WIND_NON_ZERO);
  96         assert(com.sun.javafx.geom.PathIterator.SEG_MOVETO == java.awt.geom.PathIterator.SEG_MOVETO);
  97         assert(com.sun.javafx.geom.PathIterator.SEG_LINETO == java.awt.geom.PathIterator.SEG_LINETO);
  98         assert(com.sun.javafx.geom.PathIterator.SEG_QUADTO == java.awt.geom.PathIterator.SEG_QUADTO);
  99         assert(com.sun.javafx.geom.PathIterator.SEG_CUBICTO == java.awt.geom.PathIterator.SEG_CUBICTO);
 100         assert(com.sun.javafx.geom.PathIterator.SEG_CLOSE == java.awt.geom.PathIterator.SEG_CLOSE);
 101     }
 102     static final LinearGradientPaint.CycleMethod LGP_CYCLE_METHODS[] = {
 103         LinearGradientPaint.CycleMethod.NO_CYCLE,
 104         LinearGradientPaint.CycleMethod.REFLECT,
 105         LinearGradientPaint.CycleMethod.REPEAT,
 106     };
 107     static final RadialGradientPaint.CycleMethod RGP_CYCLE_METHODS[] = {
 108         RadialGradientPaint.CycleMethod.NO_CYCLE,
 109         RadialGradientPaint.CycleMethod.REFLECT,
 110         RadialGradientPaint.CycleMethod.REPEAT,
 111     };
 112 
 113     private static final BasicStroke DEFAULT_STROKE =
 114         new BasicStroke(1.0f, BasicStroke.CAP_SQUARE, BasicStroke.JOIN_MITER, 10.0f);
 115     private static final Paint DEFAULT_PAINT = Color.WHITE;
 116     static java.awt.geom.AffineTransform J2D_IDENTITY =
 117         new java.awt.geom.AffineTransform();
 118     private int clipRectIndex;
 119     private boolean hasPreCullingBits = false;
 120     private float pixelScaleX = 1.0f;
 121     private float pixelScaleY = 1.0f;
 122 
 123     static java.awt.Color toJ2DColor(Color c) {
 124         return new java.awt.Color(c.getRed(),
 125                                   c.getGreen(),
 126                                   c.getBlue(),
 127                                   c.getAlpha());
 128     }
 129 
 130     /*
 131      * Ensure that no fractions are equal
 132      *
 133      * Note that the J2D objects reject equal fractions, but the FX versions
 134      * allow them.
 135      *
 136      * The FX version treats values with equal fractions such that as you
 137      * approach the fractional value from below it interpolates to the
 138      * first color associated with that fraction and as you interpolate
 139      * away from it from above it interpolates the last such color.
 140      *
 141      * To get the J2D version to exhibit the FX behavior we collapse all
 142      * adjacent fractional values into a pair of values that are stored
 143      * with a pair of immediately adjacent floating point values.  This way
 144      * they have unique fractions, but no fractional value can be generated
 145      * which fits between them.  Yet, as you approach from below it will
 146      * interpolate to the first of the pair of colors and as you move away
 147      * above it, the second value will take precedence for interpolation.
 148      *
 149      * Math.ulp() is used to generate an &quot;immediately adjacent fp value&quot;.
 150      */
 151     static int fixFractions(float fractions[], java.awt.Color colors[]) {
 152         float fprev = fractions[0];
 153         int i = 1;  // index of next incoming color/fractions we will examine
 154         int n = 1;  // index of next outgoing color/fraction we will store
 155         while (i &lt; fractions.length) {
 156             float f = fractions[i];
 157             java.awt.Color c = colors[i++];
 158             if (f &lt;= fprev) {
 159                 // If we find any duplicates after we reach 1.0 we can
 160                 // just ignore the rest of the array.  Not only is there
 161                 // no more &quot;fraction room&quot; to assign them to, but we will
 162                 // never generate a fraction &gt;1.0 to access them anyway
 163                 if (f &gt;= 1.0f) break;
 164                 // Find all fractions that are either fprev or fprev+ulp
 165                 // and collapse them into two entries, the first at fprev
 166                 // which is already stored, and the last matching entry
 167                 // will be stored with fraction fprev+ulp
 168                 f = fprev + Math.ulp(fprev);
 169                 while (i &lt; fractions.length) {
 170                     if (fractions[i] &gt; f) break;
 171                     // We continue to remember the color of the last
 172                     // &quot;matching&quot; entry so it can be stored below
 173                     c = colors[i++];
 174                 }
 175             }
 176             fractions[n] = fprev = f;
 177             colors[n++] = c;
 178         }
 179         return n;
 180     }
 181 
 182     java.awt.Paint toJ2DPaint(Paint p, java.awt.geom.Rectangle2D b) {
 183         if (p instanceof Color) {
 184             return toJ2DColor((Color) p);
 185         } else if (p instanceof Gradient) {
 186             Gradient g = (Gradient) p;
 187             if (g.isProportional()) {
 188                 if (b == null) {
 189                     return null;
 190                 }
 191             }
 192             List&lt;Stop&gt; stops = g.getStops();
 193             int n = stops.size();
 194             float fractions[] = new float[n];
 195             java.awt.Color colors[] = new java.awt.Color[n];
 196             float prevf = -1f;
 197             boolean needsFix = false;
 198             for (int i = 0; i &lt; n; i++) {
 199                 Stop stop = stops.get(i);
 200                 float f = stop.getOffset();
 201                 needsFix = (needsFix || f &lt;= prevf);
 202                 fractions[i] = prevf = f;
 203                 colors[i] = toJ2DColor(stop.getColor());
 204             }
 205             if (needsFix) {
 206                 n = fixFractions(fractions, colors);
 207                 if (n &lt; fractions.length) {
 208                     float newf[] = new float[n];
 209                     System.arraycopy(fractions, 0, newf, 0, n);
 210                     fractions = newf;
 211                     java.awt.Color newc[] = new java.awt.Color[n];
 212                     System.arraycopy(colors, 0, newc, 0, n);
 213                     colors = newc;
 214                 }
 215             }
 216             if (g instanceof LinearGradient) {
 217                 LinearGradient lg = (LinearGradient) p;
 218                 float x1 = lg.getX1();
 219                 float y1 = lg.getY1();
 220                 float x2 = lg.getX2();
 221                 float y2 = lg.getY2();
 222                 if (g.isProportional()) {
 223                     float x = (float) b.getX();
 224                     float y = (float) b.getY();
 225                     float w = (float) b.getWidth();
 226                     float h = (float) b.getHeight();
 227                     x1 = x + w * x1;
 228                     y1 = y + h * y1;
 229                     x2 = x + w * x2;
 230                     y2 = y + h * y2;
 231                 }
 232                 if (x1 == x2 &amp;&amp; y1 == y2) {
 233                     // Hardware pipelines use an inverse transform of
 234                     // all zeros to choose colors when the start and end
 235                     // point are the same so that the first color is
 236                     // always chosen...
 237                     return colors[0];
 238                 }
 239                 java.awt.geom.Point2D p1 =
 240                     new java.awt.geom.Point2D.Float(x1, y1);
 241                 java.awt.geom.Point2D p2 =
 242                     new java.awt.geom.Point2D.Float(x2, y2);
 243                 LinearGradientPaint.CycleMethod method =
 244                     LGP_CYCLE_METHODS[g.getSpreadMethod()];
 245                 return new LinearGradientPaint(p1, p2, fractions, colors, method);
 246             } else if (g instanceof RadialGradient) {
 247                 RadialGradient rg = (RadialGradient) g;
 248                 float cx = rg.getCenterX();
 249                 float cy = rg.getCenterY();
 250                 float r = rg.getRadius();
 251                 double fa = Math.toRadians(rg.getFocusAngle());
 252                 float fd = rg.getFocusDistance();
 253                 java.awt.geom.AffineTransform at = J2D_IDENTITY;
 254                 if (g.isProportional()) {
 255                     float x = (float) b.getX();
 256                     float y = (float) b.getY();
 257                     float w = (float) b.getWidth();
 258                     float h = (float) b.getHeight();
 259                     float dim = Math.min(w, h);
 260                     float bcx = x + w * 0.5f;
 261                     float bcy = y + h * 0.5f;
 262                     cx = bcx + (cx - 0.5f) * dim;
 263                     cy = bcy + (cy - 0.5f) * dim;
 264                     r *= dim;
 265                     if (w != h &amp;&amp; w != 0.0 &amp;&amp; h != 0.0) {
 266                         at = java.awt.geom.AffineTransform.getTranslateInstance(bcx, bcy);
 267                         at.scale(w / dim, h / dim);
 268                         at.translate(-bcx, -bcy);
 269                     }
 270                 }
 271                 java.awt.geom.Point2D center =
 272                     new java.awt.geom.Point2D.Float(cx, cy);
 273                 float fx = (float) (cx + fd * r * Math.cos(fa));
 274                 float fy = (float) (cy + fd * r * Math.sin(fa));
 275                 java.awt.geom.Point2D focus =
 276                     new java.awt.geom.Point2D.Float(fx, fy);
 277                 RadialGradientPaint.CycleMethod method =
 278                     RGP_CYCLE_METHODS[g.getSpreadMethod()];
 279                 return new RadialGradientPaint(center, r, focus, fractions, colors,
 280                                                method, ColorSpaceType.SRGB, at);
 281             }
 282         } else if (p instanceof ImagePattern) {
 283             ImagePattern imgpat = (ImagePattern) p;
 284             float x = imgpat.getX();
 285             float y = imgpat.getY();
 286             float w = imgpat.getWidth();
 287             float h = imgpat.getHeight();
 288             if (p.isProportional()) {
 289                 if (b == null) {
 290                     return null;
 291                 }
 292                 float bx = (float) b.getX();
 293                 float by = (float) b.getY();
 294                 float bw = (float) b.getWidth();
 295                 float bh = (float) b.getHeight();
 296                 w += x;
 297                 h += y;
 298                 x = bx + x * bw;
 299                 y = by + y * bh;
 300                 w = bx + w * bw;
 301                 h = by + h * bh;
 302                 w -= x;
 303                 h -= y;
 304             }
 305             Texture tex =
 306                 getResourceFactory().getCachedTexture(imgpat.getImage(), WrapMode.REPEAT);
 307             java.awt.image.BufferedImage bimg = ((J2DTexture) tex).getBufferedImage();
 308             tex.unlock();
 309             return new java.awt.TexturePaint(bimg, tmpRect(x, y, w, h));
 310         }
 311         throw new UnsupportedOperationException(&quot;Paint &quot;+p+&quot; not supported yet.&quot;);
 312     }
 313 
 314     static java.awt.Stroke toJ2DStroke(BasicStroke stroke) {
 315         float lineWidth = stroke.getLineWidth();
 316         int type = stroke.getType();
 317         if (type != BasicStroke.TYPE_CENTERED) {
 318             lineWidth *= 2;
 319         }
 320         java.awt.BasicStroke bs =
 321                 new java.awt.BasicStroke(lineWidth,
 322                                          stroke.getEndCap(),
 323                                          stroke.getLineJoin(),
 324                                          stroke.getMiterLimit(),
 325                                          stroke.getDashArray(),
 326                                          stroke.getDashPhase());
 327         if (type == BasicStroke.TYPE_INNER) {
 328             return new InnerStroke(bs);
 329         } else if (type == BasicStroke.TYPE_OUTER) {
 330             return new OuterStroke(bs);
 331         } else {
 332             return bs;
 333         }
 334     }
 335 
 336     private static ConcurrentHashMap&lt;java.awt.Font,
 337                                      WeakReference&lt;java.awt.Font&gt;&gt;
 338         fontMap = new ConcurrentHashMap&lt;java.awt.Font,
 339                                         WeakReference&lt;java.awt.Font&gt;&gt;();
 340     private static volatile int cleared = 0;
 341 
 342     private static java.awt.Font toJ2DFont(FontStrike strike) {
 343         FontResource fr = strike.getFontResource();
 344         java.awt.Font j2dfont;
 345         Object peer = fr.getPeer();
 346         if (peer == null &amp;&amp; fr.isEmbeddedFont()) {
 347             J2DFontFactory.registerFont(fr);
 348             peer = fr.getPeer();
 349         }
 350         if (peer != null &amp;&amp; peer instanceof java.awt.Font) {
 351             j2dfont = (java.awt.Font)peer;
 352         } else {
 353             if (PlatformUtil.isMac()) {
 354                 // Looking up J2D fonts via full name is not reliable on the
 355                 // Mac, however using the PostScript font name is. The likely
 356                 // cause is Mac platform internals heavy reliance on PostScript
 357                 // names for font identification.
 358                 String psName = fr.getPSName();
 359                 // dummy size
 360                 j2dfont = new java.awt.Font(psName, java.awt.Font.PLAIN, 12);
 361 
 362                 // REMIND: Due to bugs in j2d font lookup, these two workarounds
 363                 // are required to ensure the correct font is used. Once fixed
 364                 // in the jdk these workarounds should be removed.
 365                 if (!j2dfont.getPSName().equals(psName)) {
 366                     // 1. Lookup font via family and style. This covers the
 367                     // case when the J2D PostScript name does not match psName
 368                     // in font file. For example &quot;HelveticaCYBold&quot; has the
 369                     // psName &quot;HelveticaCY-Bold&quot; in j2d.
 370                     int style = fr.isBold() ? java.awt.Font.BOLD : 0;
 371                     style = style | (fr.isItalic() ? java.awt.Font.ITALIC : 0);
 372                     j2dfont = new java.awt.Font(fr.getFamilyName(), style, 12);
 373 
 374                     if(!j2dfont.getPSName().equals(psName)) {
 375                         // 2. J2D seems to be unable to find a few fonts where
 376                         // psName == familyName.  Workaround is an exhaustive
 377                         // search of all fonts.
 378                         java.awt.Font[] allj2dFonts =
 379                                 java.awt.GraphicsEnvironment.
 380                                 getLocalGraphicsEnvironment().getAllFonts();
 381                         for (java.awt.Font f : allj2dFonts) {
 382                             if (f.getPSName().equals(psName)) {
 383                                 j2dfont = f;
 384                                 break;
 385                             }
 386                         }
 387                     }
 388                 }
 389             } else {
 390                 // dummy size
 391                 j2dfont = new java.awt.Font(fr.getFullName(),
 392                                             java.awt.Font.PLAIN, 12);
 393             }
 394 
 395             // Adding j2dfont as peer is OK since fr is a decomposed
 396             // FontResource. Thus preventing font lookup next time we render.
 397             fr.setPeer(j2dfont);
 398         }
 399         // deriveFont(...) still has a bug and will cause #2 problem to occur
 400         j2dfont = j2dfont.deriveFont(strike.getSize()); // exact float font size
 401         java.awt.Font compFont = null;
 402         WeakReference&lt;java.awt.Font&gt; ref = fontMap.get(j2dfont);
 403         if (ref != null) {
 404             compFont = ref.get();
 405             if (compFont == null) {
 406                 cleared++;
 407             }
 408         }
 409         if (compFont == null) {
 410             if (fontMap.size() &gt; 100 &amp;&amp; cleared &gt; 10) { // purge the map.
 411                 for (java.awt.Font key : fontMap.keySet()) {
 412                     ref = fontMap.get(key);
 413                     if (ref == null || ref.get() == null) {
 414                         fontMap.remove(key);
 415                     }
 416                 }
 417                 cleared = 0;
 418             }
 419             compFont = J2DFontFactory.getCompositeFont(j2dfont);
 420             ref = new WeakReference(compFont);
 421             fontMap.put(j2dfont, ref);
 422         }
 423         return compFont;
 424     }
 425 
 426     public static java.awt.geom.AffineTransform
 427         toJ2DTransform(BaseTransform t)
 428     {
 429         return new java.awt.geom.AffineTransform(t.getMxx(), t.getMyx(),
 430                                                  t.getMxy(), t.getMyy(),
 431                                                  t.getMxt(), t.getMyt());
 432     }
 433 
 434     private static java.awt.geom.AffineTransform tmpAT =
 435         new java.awt.geom.AffineTransform();
 436     static java.awt.geom.AffineTransform tmpJ2DTransform(BaseTransform t)
 437     {
 438         tmpAT.setTransform(t.getMxx(), t.getMyx(),
 439                            t.getMxy(), t.getMyy(),
 440                            t.getMxt(), t.getMyt());
 441         return tmpAT;
 442     }
 443 
 444     static BaseTransform toPrTransform(java.awt.geom.AffineTransform t)
 445     {
 446         return BaseTransform.getInstance(t.getScaleX(), t.getShearY(),
 447                                          t.getShearX(), t.getScaleY(),
 448                                          t.getTranslateX(), t.getTranslateY());
 449     }
 450 
 451     static Rectangle toPrRect(java.awt.Rectangle r)
 452     {
 453         return new Rectangle(r.x, r.y, r.width, r.height);
 454     }
 455 
 456     private static java.awt.geom.Path2D tmpQuadShape =
 457         new java.awt.geom.Path2D.Float();
 458     private static java.awt.Shape tmpQuad(float x1, float y1,
 459                                           float x2, float y2)
 460     {
 461         tmpQuadShape.reset();
 462         tmpQuadShape.moveTo(x1, y1);
 463         tmpQuadShape.lineTo(x2, y1);
 464         tmpQuadShape.lineTo(x2, y2);
 465         tmpQuadShape.lineTo(x1, y2);
 466         tmpQuadShape.closePath();
 467         return tmpQuadShape;
 468     }
 469 
 470     private static java.awt.geom.Rectangle2D.Float tmpRect =
 471         new java.awt.geom.Rectangle2D.Float();
 472     private static java.awt.geom.Rectangle2D tmpRect(float x, float y, float w, float h) {
 473         tmpRect.setRect(x, y, w, h);
 474         return tmpRect;
 475     }
 476 
 477     private static java.awt.geom.Ellipse2D tmpEllipse =
 478         new java.awt.geom.Ellipse2D.Float();
 479     private static java.awt.Shape tmpEllipse(float x, float y, float w, float h) {
 480         tmpEllipse.setFrame(x, y, w, h);
 481         return tmpEllipse;
 482     }
 483 
 484     private static java.awt.geom.RoundRectangle2D tmpRRect =
 485         new java.awt.geom.RoundRectangle2D.Float();
 486     private static java.awt.Shape tmpRRect(float x, float y, float w, float h,
 487                                            float aw, float ah)
 488     {
 489         tmpRRect.setRoundRect(x, y, w, h, aw, ah);
 490         return tmpRRect;
 491     }
 492 
 493     private static java.awt.geom.Line2D tmpLine =
 494         new java.awt.geom.Line2D.Float();
 495     private static java.awt.Shape tmpLine(float x1, float y1, float x2, float y2) {
 496         tmpLine.setLine(x1, y1, x2, y2);
 497         return tmpLine;
 498     }
 499 
 500     private static AdaptorShape tmpAdaptor = new AdaptorShape();
 501     private static java.awt.Shape tmpShape(Shape s) {
 502         tmpAdaptor.setShape(s);
 503         return tmpAdaptor;
 504     }
 505 
 506     private boolean antialiasedShape = true;
 507     J2DPresentable target;
 508     java.awt.Graphics2D g2d;
 509     Affine2D transform;
 510     Rectangle clipRect;
 511     RectBounds devClipRect;
 512     RectBounds finalClipRect;
 513     Paint paint;
 514     boolean paintWasProportional;
 515     BasicStroke stroke;
 516     boolean cull;
 517 
 518     J2DPrismGraphics(J2DPresentable target, java.awt.Graphics2D g2d) {
 519         this(g2d, target.getContentWidth(), target.getContentHeight());
 520         this.target = target;
 521     }
 522 
 523     J2DPrismGraphics(java.awt.Graphics2D g2d, int width, int height) {
 524         this.g2d = g2d;
 525         captureTransform(g2d);
 526         this.transform = new Affine2D();
 527         this.devClipRect = new RectBounds(0, 0, width, height);
 528         this.finalClipRect = new RectBounds(0, 0, width, height);
 529         this.cull = true;
 530 
 531         g2d.setRenderingHint(java.awt.RenderingHints.KEY_STROKE_CONTROL,
 532                              java.awt.RenderingHints.VALUE_STROKE_PURE);
 533         g2d.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING,
 534                               java.awt.RenderingHints.VALUE_ANTIALIAS_ON);
 535         g2d.setRenderingHint(java.awt.RenderingHints.KEY_INTERPOLATION,
 536                              java.awt.RenderingHints.VALUE_INTERPOLATION_BILINEAR);
 537         /* Set the text hints to those most equivalent to FX rendering.
 538          * Will need to revisit this since its unlikely to be sufficient.
 539          */
 540         g2d.setRenderingHint(java.awt.RenderingHints.KEY_FRACTIONALMETRICS,
 541                            java.awt.RenderingHints.VALUE_FRACTIONALMETRICS_ON);
 542         g2d.setRenderingHint(java.awt.RenderingHints.KEY_TEXT_ANTIALIASING,
 543                              java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
 544 
 545 
 546         setTransform(BaseTransform.IDENTITY_TRANSFORM);
 547         setPaint(DEFAULT_PAINT);
 548         setStroke(DEFAULT_STROKE);
 549     }
 550 
 551     public RenderTarget getRenderTarget() {
 552         return target;
 553     }
 554 
 555     public Screen getAssociatedScreen() {
 556         return target.getAssociatedScreen();
 557     }
 558 
 559     public ResourceFactory getResourceFactory() {
 560         return target.getResourceFactory();
 561     }
 562 
 563     public void reset() {
 564     }
 565 
 566     public Rectangle getClipRect() {
 567         return clipRect == null ? null : new Rectangle(clipRect);
 568     }
 569 
 570     public Rectangle getClipRectNoClone() {
 571         return clipRect;
 572     }
 573 
 574     public RectBounds getFinalClipNoClone() {
 575         return finalClipRect;
 576     }
 577 
 578     public void setClipRect(Rectangle clipRect) {
 579         this.finalClipRect.setBounds(devClipRect);
 580         if (clipRect == null) {
 581             this.clipRect = null;
 582             g2d.setClip(null);
 583         } else {
 584             this.clipRect = new Rectangle(clipRect);
 585             this.finalClipRect.intersectWith(clipRect);
 586             setTransformG2D(J2D_IDENTITY);
 587             g2d.setClip(clipRect.x, clipRect.y, clipRect.width, clipRect.height);
 588             setTransformG2D(tmpJ2DTransform(transform));
 589         }
 590     }
 591 
 592     private java.awt.AlphaComposite getAWTComposite() {
 593         return (java.awt.AlphaComposite) g2d.getComposite();
 594     }
 595 
 596     public float getExtraAlpha() {
 597         return getAWTComposite().getAlpha();
 598     }
 599 
 600     public void setExtraAlpha(float extraAlpha) {
 601         g2d.setComposite(getAWTComposite().derive(extraAlpha));
 602     }
 603 
 604     public CompositeMode getCompositeMode() {
 605         int rule = getAWTComposite().getRule();
 606         switch (rule) {
 607             case java.awt.AlphaComposite.CLEAR:
 608                 return CompositeMode.CLEAR;
 609             case java.awt.AlphaComposite.SRC:
 610                 return CompositeMode.SRC;
 611             case java.awt.AlphaComposite.SRC_OVER:
 612                 return CompositeMode.SRC_OVER;
 613             default:
 614                 throw new InternalError(&quot;Unrecognized AlphaCompsite rule: &quot;+rule);
 615         }
 616     }
 617 
 618     public void setCompositeMode(CompositeMode mode) {
 619         java.awt.AlphaComposite awtComp = getAWTComposite();
 620         switch (mode) {
 621             case CLEAR:
 622                 awtComp = awtComp.derive(java.awt.AlphaComposite.CLEAR);
 623                 break;
 624             case SRC:
 625                 awtComp = awtComp.derive(java.awt.AlphaComposite.SRC);
 626                 break;
 627             case SRC_OVER:
 628                 awtComp = awtComp.derive(java.awt.AlphaComposite.SRC_OVER);
 629                 break;
 630             default:
 631                 throw new InternalError(&quot;Unrecognized composite mode: &quot;+mode);
 632         }
 633         g2d.setComposite(awtComp);
 634     }
 635 
 636     public Paint getPaint() {
 637         return paint;
 638     }
 639 
 640     public void setPaint(Paint paint) {
 641         this.paint = paint;
 642         java.awt.Paint j2dpaint = toJ2DPaint(paint, null);
 643         if (j2dpaint == null) {
 644             paintWasProportional = true;
 645         } else {
 646             paintWasProportional = false;
 647             g2d.setPaint(j2dpaint);
 648         }
 649     }
 650 
 651     public BasicStroke getStroke() {
 652         return stroke;
 653     }
 654 
 655     public void setStroke(BasicStroke stroke) {
 656         this.stroke = stroke;
 657         g2d.setStroke(toJ2DStroke(stroke));
 658     }
 659 
 660     public BaseTransform getTransformNoClone() {
 661         return transform;
 662     }
 663 
 664     public void translate(float tx, float ty) {
 665         transform.translate(tx, ty);
 666         g2d.translate(tx, ty);
 667     }
 668 
 669     public void scale(float sx, float sy) {
 670         transform.scale(sx, sy);
 671         g2d.scale(sx, sy);
 672     }
 673 
 674     public void transform(BaseTransform xform) {
 675         if (!xform.is2D()) {
 676             // No-op until we support 3D
 677             return;
 678         }
 679         transform.concatenate(xform);
 680         setTransformG2D(tmpJ2DTransform(transform));
 681     }
 682 
 683     public void setTransform(BaseTransform xform) {
 684         // TODO: Modify PrEffectHelper to not pass a null... (RT-27384)
 685         if (xform == null) xform = BaseTransform.IDENTITY_TRANSFORM;
 686         transform.setTransform(xform);
 687         setTransformG2D(tmpJ2DTransform(transform));
 688     }
 689 
 690     public void setTransform(double m00, double m10,
 691                              double m01, double m11,
 692                              double m02, double m12)
 693     {
 694         transform.setTransform(m00, m10, m01, m11, m02, m12);
 695         setTransformG2D(tmpJ2DTransform(transform));
 696     }
 697 
 698     public void clear() {
 699         clear(Color.TRANSPARENT);
 700     }
 701 
 702     public void clear(Color color) {
 703         this.getRenderTarget().setOpaque(color.isOpaque());
 704         clear(toJ2DColor(color));
 705     }
 706 
 707     void clear(java.awt.Color c) {
 708         java.awt.Graphics2D gtmp = (java.awt.Graphics2D) g2d.create();
 709         gtmp.setTransform(J2D_IDENTITY);
 710         gtmp.setComposite(java.awt.AlphaComposite.Src);
 711         gtmp.setColor(c);
 712         gtmp.fillRect(0, 0, target.getContentWidth(), target.getContentHeight());
 713         gtmp.dispose();
 714     }
 715 
 716     public void clearQuad(float x1, float y1, float x2, float y2) {
 717         g2d.setComposite(java.awt.AlphaComposite.Clear);
 718         g2d.fill(tmpQuad(x1, y1, x2, y2));
 719     }
 720 
 721     void fill(java.awt.Shape shape) {
 722         if (paintWasProportional) {
 723             if (nodeBounds != null) {
 724                 g2d.setPaint(toJ2DPaint(paint, nodeBounds));
 725             } else {
 726                 g2d.setPaint(toJ2DPaint(paint, shape.getBounds2D()));
 727             }
 728         }
 729         if (this.paint.getType() == Paint.Type.IMAGE_PATTERN) {
 730             ImagePattern imgpat = (ImagePattern) this.paint;
 731             java.awt.geom.AffineTransform at = toJ2DTransform(imgpat.getPatternTransformNoClone());
 732 
 733             if (at.getType() != java.awt.geom.AffineTransform.TYPE_IDENTITY) {
 734                 g2d.setClip(shape);
 735                 g2d.transform(at);
 736                 tmpAT.setTransform(at);
 737                 try {
 738                     tmpAT.invert();
 739                 } catch (NoninvertibleTransformException e) {
 740                 }
 741 
 742                 g2d.fill(tmpAT.createTransformedShape(shape).getBounds2D());
 743                 setTransform(transform);
 744                 setClipRect(clipRect);
 745                 return;
 746             }
 747         }
 748         g2d.fill(shape);
 749     }
 750 
 751     public void fill(Shape shape) {
 752         fill(tmpShape(shape));
 753     }
 754 
 755     public void fillRect(float x, float y, float width, float height) {
 756         fill(tmpRect(x, y, width, height));
 757     }
 758 
 759     public void fillRoundRect(float x, float y, float width, float height,
 760                               float arcw, float arch)
 761     {
 762         fill(tmpRRect(x, y, width, height, arcw, arch));
 763     }
 764 
 765     public void fillEllipse(float x, float y, float width, float height) {
 766         fill(tmpEllipse(x, y, width, height));
 767     }
 768 
 769     public void fillQuad(float x1, float y1, float x2, float y2) {
 770         fill(tmpQuad(x1, y1, x2, y2));
 771     }
 772 
 773     void draw(java.awt.Shape shape) {
 774         if (paintWasProportional) {
 775             if (nodeBounds != null) {
 776                 g2d.setPaint(toJ2DPaint(paint, nodeBounds));
 777             } else {
 778                 g2d.setPaint(toJ2DPaint(paint, shape.getBounds2D()));
 779             }
 780         }
 781         try {
 782             g2d.draw(shape);
 783         } catch (Throwable t) {
 784             // Workaround for JDK bug 6670624
 785             // We may get a Ductus PRError (extends RuntimeException)
 786             // or we may get an InternalError (extends Error)
 787             // The only common superclass of the two is Throwable...
 788         }
 789     }
 790 
 791     public void draw(Shape shape) {
 792         draw(tmpShape(shape));
 793     }
 794 
 795     public void drawLine(float x1, float y1, float x2, float y2) {
 796         draw(tmpLine(x1, y1, x2, y2));
 797     }
 798 
 799     public void drawRect(float x, float y, float width, float height) {
 800         draw(tmpRect(x, y, width, height));
 801     }
 802 
 803     public void drawRoundRect(float x, float y, float width, float height, float arcw, float arch) {
 804         draw(tmpRRect(x, y, width, height, arcw, arch));
 805     }
 806 
 807     public void drawEllipse(float x, float y, float width, float height) {
 808         draw(tmpEllipse(x, y, width, height));
 809     }
 810 
 811     Rectangle2D nodeBounds = null;
 812 
 813     public void setNodeBounds(RectBounds bounds) {
 814         nodeBounds = bounds != null ?
 815                 new Rectangle2D.Float(bounds.getMinX(), bounds.getMinY(),
 816                                       bounds.getWidth(),bounds.getHeight()) :
 817                 null;
 818     }
 819 
 820     private void drawString(GlyphList gl, int start, int end,
 821                             FontStrike strike, float x, float y) {
 822         if (start == end) return;
 823         int count = end - start;
 824         int[] glyphs = new int[count];
 825         for (int i = 0; i &lt; count; i++) {
 826             glyphs[i] = gl.getGlyphCode(start + i) &amp; CompositeGlyphMapper.GLYPHMASK;
 827         }
 828         java.awt.Font j2dfont = toJ2DFont(strike);
 829         GlyphVector gv = j2dfont.createGlyphVector(g2d.getFontRenderContext(), glyphs);
 830         java.awt.geom.Point2D pt = new java.awt.geom.Point2D.Float();
 831         for (int i = 0; i &lt; count; i++) {
 832             pt.setLocation(gl.getPosX(start + i), gl.getPosY(start + i));
 833             gv.setGlyphPosition(i, pt);
 834         }
 835         g2d.drawGlyphVector(gv, x, y);
 836     }
 837 
 838     public void drawString(GlyphList gl, FontStrike strike, float x, float y,
 839                            Color selectColor, int start, int end) {
 840 
 841         int count = gl.getGlyphCount();
 842         if (count == 0) return;
 843 
 844         // In JDK6, setting graphics AA disables fast text loops
 845         g2d.setRenderingHint(KEY_ANTIALIASING, VALUE_ANTIALIAS_OFF);
 846 
 847         // If the surface has Alpha, JDK will ignore the LCD loops.
 848         // So for this to have any effect we need to fix JDK, or
 849         // ensure an opaque surface type.
 850         if (strike.getAAMode() == FontResource.AA_LCD) {
 851             g2d.setRenderingHint(KEY_TEXT_ANTIALIASING, VALUE_TEXT_ANTIALIAS_LCD_HRGB);
 852         }
 853 
 854         if (paintWasProportional) {
 855             Rectangle2D rectBounds = nodeBounds;
 856             if (rectBounds == null) {
 857                 Metrics m = strike.getMetrics();
 858                 rectBounds = new Rectangle2D.Float(0,
 859                                                    m.getAscent(),
 860                                                    gl.getWidth(),
 861                                                    m.getLineHeight());
 862             }
 863             g2d.setPaint(toJ2DPaint(paint, rectBounds));
 864         }
 865 
 866         CompositeStrike cStrike = null;
 867         int slot = 0;
 868         if (strike instanceof CompositeStrike) {
 869             cStrike = (CompositeStrike)strike;
 870             int glyphCode = gl.getGlyphCode(0);
 871             slot = cStrike.getStrikeSlotForGlyph(glyphCode);
 872         }
 873         java.awt.Color sColor = null;
 874         java.awt.Color tColor = null;
 875         boolean selected = false;
 876         if (selectColor != null) {
 877             sColor = toJ2DColor(selectColor);
 878             tColor = g2d.getColor();
 879             int offset = gl.getCharOffset(0);
 880             selected = start &lt;= offset &amp;&amp; offset &lt; end;
 881         }
 882         int index = 0;
 883         if (sColor != null || cStrike != null) {
 884             /* Draw a segment every time selection or font changes */
 885             for (int i = 1; i &lt; count; i++) {
 886                 if (sColor != null) {
 887                     int offset = gl.getCharOffset(i);
 888                     boolean glyphSelected = start &lt;= offset &amp;&amp; offset &lt; end;
 889                     if (selected != glyphSelected) {
 890                         if (cStrike != null) {
 891                             strike = cStrike.getStrikeSlot(slot);
 892                         }
 893                         g2d.setColor(selected ? sColor : tColor);
 894                         drawString(gl, index, i, strike, x, y);
 895                         index = i;
 896                         selected = glyphSelected;
 897                     }
 898                 }
 899                 if (cStrike != null) {
 900                     int glyphCode = gl.getGlyphCode(i);
 901                     int glyphSlot = cStrike.getStrikeSlotForGlyph(glyphCode);
 902                     if (slot != glyphSlot) {
 903                         strike = cStrike.getStrikeSlot(slot);
 904                         if (sColor != null) {
 905                             g2d.setColor(selected ? sColor : tColor);
 906                         }
 907                         drawString(gl, index, i, strike, x, y);
 908                         index = i;
 909                         slot = glyphSlot;
 910                     }
 911                 }
 912             }
 913 
 914             /* Set strike and color to draw the last segment */
 915             if (cStrike != null) {
 916                 strike = cStrike.getStrikeSlot(slot);
 917             }
 918             if (sColor != null) {
 919                 g2d.setColor(selected ? sColor : tColor);
 920             }
 921         }
 922         drawString(gl, index, count, strike, x, y);
 923 
 924         /* Always restore the graphics to its initial color */
 925         if (selectColor != null) {
 926             g2d.setColor(tColor);
 927         }
 928 
 929         // Set hints back to the default.
 930         g2d.setRenderingHint(KEY_TEXT_ANTIALIASING, VALUE_TEXT_ANTIALIAS_ON);
 931         g2d.setRenderingHint(KEY_ANTIALIASING, VALUE_ANTIALIAS_ON);
 932     }
 933 
 934     /**
 935      * Overridden by printing subclass to preserve the printer graphics
 936      * transform.
 937      */
 938     protected void setTransformG2D(java.awt.geom.AffineTransform tx) {
 939         g2d.setTransform(tx);
 940     }
 941 
 942     /**
 943      * Needed only by printing subclass, which over-rides it.
 944      */
 945     protected void captureTransform(java.awt.Graphics2D g2d) {
 946         return;
 947     }
 948 
 949     public void drawMappedTextureRaw(Texture tex,
 950                                      float dx1, float dy1, float dx2, float dy2,
 951                                      float tx11, float ty11, float tx21, float ty21,
 952                                      float tx12, float ty12, float tx22, float ty22)
 953     {
 954         java.awt.Image img = ((J2DTexture) tex).getBufferedImage();
 955         float mxx = tx21-tx11;
 956         float myx = ty21-ty11;
 957         float mxy = tx12-tx11;
 958         float myy = ty12-ty11;
 959 //        assert(Math.abs(mxx - (tx22-tx12)) &lt; .000001);
 960 //        assert(Math.abs(myx - (ty22-ty12)) &lt; .000001);
 961 //        assert(Math.abs(mxy - (tx22-tx21)) &lt; .000001);
 962 //        assert(Math.abs(myy - (ty22-ty21)) &lt; .000001);
 963         setTransformG2D(J2D_IDENTITY);
 964         tmpAT.setTransform(mxx, myx, mxy, myy, tx11, ty11);
 965         try {
 966             tmpAT.invert();
 967             g2d.translate(dx1, dy1);
 968             g2d.scale(dx2-dx1, dy2-dy1);
 969             g2d.transform(tmpAT);
 970             g2d.drawImage(img, 0, 0, 1, 1, null);
 971         } catch (NoninvertibleTransformException e) {
 972         }
 973         setTransform(transform);
 974     }
 975 
 976     public void drawTexture(Texture tex, float x, float y, float w, float h) {
 977         java.awt.Image img = ((J2DTexture) tex).getBufferedImage();
 978         g2d.drawImage(img, (int) x, (int) y, (int) (x+w), (int) (y+h), 0, 0, (int)w, (int) h, null);
 979     }
 980 
 981     public void drawTexture(Texture tex,
 982                             float dx1, float dy1, float dx2, float dy2,
 983                             float sx1, float sy1, float sx2, float sy2)
 984     {
 985         java.awt.Image img = ((J2DTexture) tex).getBufferedImage();
 986         // Simply casting the subimage coordinates to integers does not
 987         // produce the same behavior as the Prism hw pipelines (see RT-19270).
 988         g2d.drawImage(img,
 989                 (int) dx1, (int) dy1, (int) dx2, (int) dy2,
 990                 (int) sx1, (int) sy1, (int) sx2, (int) sy2,
 991                 null);
 992     }
 993 
 994     @Override
 995     public void drawTexture3SliceH(Texture tex,
 996                                    float dx1, float dy1, float dx2, float dy2,
 997                                    float sx1, float sy1, float sx2, float sy2,
 998                                    float dh1, float dh2, float sh1, float sh2)
 999     {
1000         // Workaround for problems in NGRegion which may pass zero-width
1001         // source image area.
1002         if (sh1 + 0.1f &gt; sh2) sh2 += 1;
1003         drawTexture(tex, dx1, dy1, dh1, dy2, sx1, sy1, sh1, sy2);
1004         drawTexture(tex, dh1, dy1, dh2, dy2, sh1, sy1, sh2, sy2);
1005         drawTexture(tex, dh2, dy1, dx2, dy2, sh2, sy1, sx2, sy2);
1006     }
1007 
1008     @Override
1009     public void drawTexture3SliceV(Texture tex,
1010                                    float dx1, float dy1, float dx2, float dy2,
1011                                    float sx1, float sy1, float sx2, float sy2,
1012                                    float dv1, float dv2, float sv1, float sv2)
1013     {
1014         // Workaround for problems in NGRegion which may pass zero-height
1015         // source image area.
1016         if (sv1 +0.1f &gt; sv2) sv2 += 1;
1017         drawTexture(tex, dx1, dy1, dx2, dv1, sx1, sy1, sx2, sv1);
1018         drawTexture(tex, dx1, dv1, dx2, dv2, sx1, sv1, sx2, sv2);
1019         drawTexture(tex, dx1, dv2, dx2, dy2, sx1, sv2, sx2, sy2);
1020     }
1021 
1022     @Override
1023     public void drawTexture9Slice(Texture tex,
1024                                   float dx1, float dy1, float dx2, float dy2,
1025                                   float sx1, float sy1, float sx2, float sy2,
1026                                   float dh1, float dv1, float dh2, float dv2,
1027                                   float sh1, float sv1, float sh2, float sv2)
1028     {
1029         // Workaround for problems in NGRegion which may pass zero-width
1030         // or zero height source image area.
1031         if (sh1 + 0.1f &gt; sh2) sh2 += 1;
1032         if (sv1 + 0.1f &gt; sv2) sv2 += 1;
1033         drawTexture(tex, dx1, dy1, dh1, dv1, sx1, sy1, sh1, sv1);
1034         drawTexture(tex, dh1, dy1, dh2, dv1, sh1, sy1, sh2, sv1);
1035         drawTexture(tex, dh2, dy1, dx2, dv1, sh2, sy1, sx2, sv1);
1036 
1037         drawTexture(tex, dx1, dv1, dh1, dv2, sx1, sv1, sh1, sv2);
1038         drawTexture(tex, dh1, dv1, dh2, dv2, sh1, sv1, sh2, sv2);
1039         drawTexture(tex, dh2, dv1, dx2, dv2, sh2, sv1, sx2, sv2);
1040 
1041         drawTexture(tex, dx1, dv2, dh1, dy2, sx1, sv2, sh1, sy2);
1042         drawTexture(tex, dh1, dv2, dh2, dy2, sh1, sv2, sh2, sy2);
1043         drawTexture(tex, dh2, dv2, dx2, dy2, sh2, sv2, sx2, sy2);
1044     }
1045 
1046     public void drawTextureRaw(Texture tex,
1047                                float dx1, float dy1, float dx2, float dy2,
1048                                float tx1, float ty1, float tx2, float ty2)
1049     {
1050         int w = tex.getContentWidth();
1051         int h = tex.getContentHeight();
1052         tx1 *= w;
1053         ty1 *= h;
1054         tx2 *= w;
1055         ty2 *= h;
1056         drawTexture(tex, dx1, dy1, dx2, dy2, tx1, ty1, tx2, ty2);
1057     }
1058 
1059     public void drawTextureVO(Texture tex,
1060                               float topopacity, float botopacity,
1061                               float dx1, float dy1, float dx2, float dy2,
1062                               float sx1, float sy1, float sx2, float sy2)
1063     {
1064         // assert(caller is PrReflectionPeer and buffer is cleared to transparent)
1065         // NOTE: the assert conditions are true because that is the only
1066         // place where this method is used (unless we subclass BaseGraphics),
1067         // but there is no code here to verify that information.
1068         // The workarounds to do this for the general case would cost a lot
1069         // because they would involve creating a temporary intermediate buffer,
1070         // doing the operations below into the buffer, and then applying the
1071         // buffer to the destination.  That is not hard, but it costs a lot
1072         // of buffer allocation (or caching) when it is not really necessary
1073         // given the way this method is called currently.
1074         // Note that isoEdgeMask is ignored here, but since this is only ever
1075         // called by PrReflectionPeer and that code always uses ISOLATE_NONE
1076         // then we would only need to support ISOLATE_NONE.  The code below
1077         // does not yet verify if the results will be compatible with
1078         // ISOLATE_NONE, but given that the source coordinates are rounded to
1079         // integers in drawTexture() there is not much it can do to get exact
1080         // edge condition behavior until that deficiency is fixed (see
1081         // RT-19270 and RT-19271).
1082         java.awt.Paint savepaint = g2d.getPaint();
1083         java.awt.Composite savecomp = g2d.getComposite();
1084         java.awt.Color c1 = new java.awt.Color(1f, 1f, 1f, topopacity);
1085         java.awt.Color c2 = new java.awt.Color(1f, 1f, 1f, botopacity);
1086         g2d.setPaint(new java.awt.GradientPaint(0f, dy1, c1, 0f, dy2, c2, true));
1087         g2d.setComposite(java.awt.AlphaComposite.Src);
1088         int x = (int) Math.floor(Math.min(dx1, dx2));
1089         int y = (int) Math.floor(Math.min(dy1, dy2));
1090         int w = (int) Math.ceil(Math.max(dx1, dx2)) - x;
1091         int h = (int) Math.ceil(Math.max(dy1, dy2)) - y;
1092         g2d.fillRect(x, y, w, h);
1093         g2d.setComposite(java.awt.AlphaComposite.SrcIn);
1094         drawTexture(tex, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2);
1095         g2d.setComposite(savecomp);
1096         g2d.setPaint(savepaint);
1097     }
1098 
1099     public void drawPixelsMasked(RTTexture imgtex, RTTexture masktex,
1100                                  int dx, int dy, int dw, int dh,
1101                                  int ix, int iy, int mx, int my)
1102     {
1103         doDrawMaskTexture((J2DRTTexture) imgtex, (J2DRTTexture) masktex,
1104                           dx, dy, dw, dh,
1105                           ix, iy, mx, my,
1106                           true);
1107     }
1108 
1109     public void maskInterpolatePixels(RTTexture imgtex, RTTexture masktex, int dx,
1110                                       int dy, int dw, int dh, int ix, int iy,
1111                                       int mx, int my) {
1112         doDrawMaskTexture((J2DRTTexture) imgtex, (J2DRTTexture) masktex,
1113                           dx, dy, dw, dh,
1114                           ix, iy, mx, my,
1115                           false);
1116     }
1117 
1118     private void doDrawMaskTexture(J2DRTTexture imgtex, J2DRTTexture masktex,
1119                                    int dx, int dy, int dw, int dh,
1120                                    int ix, int iy, int mx, int my,
1121                                    boolean srcover)
1122     {
1123         int cx0 = clipRect.x;
1124         int cy0 = clipRect.y;
1125         int cx1 = cx0 + clipRect.width;
1126         int cy1 = cy0 + clipRect.height;
1127 
1128         if (dw &lt;= 0 || dh &lt;= 0) return;
1129         if (dx &lt; cx0) {
1130             int bump = cx0 - dx;
1131             if ((dw -= bump) &lt;= 0) return;
1132             ix += bump;
1133             mx += bump;
1134             dx = cx0;
1135         }
1136         if (dy &lt; cy0) {
1137             int bump = cy0 - dy;
1138             if ((dh -= bump) &lt;= 0) return;
1139             iy += bump;
1140             my += bump;
1141             dy = cy0;
1142         }
1143         if (dx + dw &gt; cx1 &amp;&amp; (dw = cx1 - dx) &lt;= 0) return;
1144         if (dy + dh &gt; cy1 &amp;&amp; (dh = cy1 - dy) &lt;= 0) return;
1145 
1146         int iw = imgtex.getContentWidth();
1147         int ih = imgtex.getContentHeight();
1148         if (ix &lt; 0) {
1149             if ((dw += ix) &lt;= 0) return;
1150             dx -= ix;
1151             mx -= ix;
1152             ix = 0;
1153         }
1154         if (iy &lt; 0) {
1155             if ((dh += iy) &lt;= 0) return;
1156             dy -= iy;
1157             my -= iy;
1158             iy = 0;
1159         }
1160         if (ix + dw &gt; iw &amp;&amp; (dw = iw - ix) &lt;= 0) return;
1161         if (iy + dh &gt; ih &amp;&amp; (dh = ih - iy) &lt;= 0) return;
1162 
1163         int mw = masktex.getContentWidth();
1164         int mh = masktex.getContentHeight();
1165         if (mx &lt; 0) {
1166             if ((dw += mx) &lt;= 0) return;
1167             dx -= mx;
1168             ix -= mx;
1169             mx = 0;
1170         }
1171         if (my &lt; 0) {
1172             if ((dh += my) &lt;= 0) return;
1173             dy -= my;
1174             iy -= my;
1175             my = 0;
1176         }
1177         if (mx + dw &gt; mw &amp;&amp; (dw = mw - mx) &lt;= 0) return;
1178         if (my + dh &gt; mh &amp;&amp; (dh = mh - my) &lt;= 0) return;
1179 
1180         int imgbuf[] = imgtex.getPixels();
1181         int maskbuf[] = masktex.getPixels();
1182         java.awt.image.DataBuffer db = target.getBackBuffer().getRaster().getDataBuffer();
1183         int dstbuf[] = ((java.awt.image.DataBufferInt) db).getData();
1184         int iscan = imgtex.getBufferedImage().getWidth();
1185         int mscan = masktex.getBufferedImage().getWidth();
1186         int dscan = target.getBackBuffer().getWidth();
1187         int ioff = iy * iscan + ix;
1188         int moff = my * mscan + mx;
1189         int doff = dy * dscan + dx;
1190         if (srcover) {
1191             for (int y = 0; y &lt; dh; y++) {
1192                 for (int x = 0; x &lt; dw; x++) {
1193                     int a, r, g, b;
1194                     int maskalpha = maskbuf[moff+x] &gt;&gt;&gt; 24;
1195                     if (maskalpha == 0) continue;
1196                     int imgpix = imgbuf[ioff+x];
1197                     a = (imgpix &gt;&gt;&gt; 24);
1198                     if (a == 0) continue;
1199                     if (maskalpha &lt; 0xff) {
1200                         maskalpha += (maskalpha &gt;&gt; 7);
1201                         a *= maskalpha;
1202                         r = ((imgpix &gt;&gt;  16) &amp; 0xff) * maskalpha;
1203                         g = ((imgpix &gt;&gt;   8) &amp; 0xff) * maskalpha;
1204                         b = ((imgpix       ) &amp; 0xff) * maskalpha;
1205                     } else if (a &lt; 0xff) {
1206                         a &lt;&lt;= 8;
1207                         r = ((imgpix &gt;&gt;  16) &amp; 0xff) &lt;&lt; 8;
1208                         g = ((imgpix &gt;&gt;   8) &amp; 0xff) &lt;&lt; 8;
1209                         b = ((imgpix       ) &amp; 0xff) &lt;&lt; 8;
1210                     } else {
1211                         dstbuf[doff+x] = imgpix;
1212                         continue;
1213                     }
1214                     maskalpha = ((a + 128) &gt;&gt; 8);
1215                     maskalpha += (maskalpha &gt;&gt; 7);
1216                     maskalpha = 256 - maskalpha;
1217                     imgpix = dstbuf[doff+x];
1218                     a += ((imgpix &gt;&gt;&gt; 24)       ) * maskalpha + 128;
1219                     r += ((imgpix &gt;&gt;  16) &amp; 0xff) * maskalpha + 128;
1220                     g += ((imgpix &gt;&gt;   8) &amp; 0xff) * maskalpha + 128;
1221                     b += ((imgpix       ) &amp; 0xff) * maskalpha + 128;
1222                     imgpix = ((a &gt;&gt; 8) &lt;&lt; 24) +
1223                              ((r &gt;&gt; 8) &lt;&lt; 16) +
1224                              ((g &gt;&gt; 8) &lt;&lt;  8) +
1225                              ((b &gt;&gt; 8)      );
1226                     dstbuf[doff+x] = imgpix;
1227                 }
1228                 ioff += iscan;
1229                 moff += mscan;
1230                 doff += dscan;
1231             }
1232         } else {
1233             for (int y = 0; y &lt; dh; y++) {
1234                 for (int x = 0; x &lt; dw; x++) {
1235                     int maskalpha = maskbuf[moff+x] &gt;&gt;&gt; 24;
1236                     if (maskalpha == 0) continue;
1237                     int imgpix = imgbuf[ioff+x];
1238                     if (maskalpha &lt; 0xff) {
1239                         maskalpha += (maskalpha &gt;&gt; 7);
1240                         int a = ((imgpix &gt;&gt;&gt; 24)       ) * maskalpha;
1241                         int r = ((imgpix &gt;&gt;  16) &amp; 0xff) * maskalpha;
1242                         int g = ((imgpix &gt;&gt;   8) &amp; 0xff) * maskalpha;
1243                         int b = ((imgpix       ) &amp; 0xff) * maskalpha;
1244                         maskalpha = 256 - maskalpha;
1245                         imgpix = dstbuf[doff+x];
1246                         a += ((imgpix &gt;&gt;&gt; 24)       ) * maskalpha + 128;
1247                         r += ((imgpix &gt;&gt;  16) &amp; 0xff) * maskalpha + 128;
1248                         g += ((imgpix &gt;&gt;   8) &amp; 0xff) * maskalpha + 128;
1249                         b += ((imgpix       ) &amp; 0xff) * maskalpha + 128;
1250                         imgpix = ((a &gt;&gt; 8) &lt;&lt; 24) +
1251                                  ((r &gt;&gt; 8) &lt;&lt; 16) +
1252                                  ((g &gt;&gt; 8) &lt;&lt;  8) +
1253                                  ((b &gt;&gt; 8)      );
1254                     }
1255                     dstbuf[doff+x] = imgpix;
1256                 }
1257                 ioff += iscan;
1258                 moff += mscan;
1259                 doff += dscan;
1260             }
1261         }
1262     }
1263 
1264     public boolean canReadBack() {
1265         return true;
1266     }
1267 
1268     public RTTexture readBack(Rectangle view) {
1269         J2DRTTexture rtt = target.getReadbackBuffer();
1270         java.awt.Graphics2D rttg2d = rtt.createAWTGraphics2D();
1271         rttg2d.setComposite(java.awt.AlphaComposite.Src);
1272         int x0 = view.x;
1273         int y0 = view.y;
1274         int w = view.width;
1275         int h = view.height;
1276         int x1 = x0 + w;
1277         int y1 = y0 + h;
1278         rttg2d.drawImage(target.getBackBuffer(),
1279                           0,  0,  w,  h,
1280                          x0, y0, x1, y1, null);
1281         rttg2d.dispose();
1282         return rtt;
1283     }
1284 
1285     public void releaseReadBackBuffer(RTTexture view) {
1286         // This will be needed when we track LCD buffer locks and uses.
1287         // (See RT-29488)
1288 //        target.getReadbackBuffer().unlock();
1289     }
1290 
1291     public NGCamera getCameraNoClone() {
1292         throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
1293     }
1294 
1295     public void setPerspectiveTransform(GeneralTransform3D transform) {
1296     }
1297 
1298 
1299     public boolean isDepthBuffer() {
1300         return false;
1301     }
1302 
1303     public boolean isDepthTest() {
1304         return false;
1305     }
1306 
1307     public boolean isAlphaTestShader() {
1308         if (PrismSettings.verbose &amp;&amp; PrismSettings.forceAlphaTestShader) {
1309             System.out.println(&quot;J2D pipe doesn&#39;t support shader with alpha testing&quot;);
1310         }
1311         return false;
1312     }
1313 
1314     public void setAntialiasedShape(boolean aa) {
1315         antialiasedShape = aa;
1316         g2d.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING,
1317                 antialiasedShape ? java.awt.RenderingHints.VALUE_ANTIALIAS_ON
1318                         : java.awt.RenderingHints.VALUE_ANTIALIAS_OFF);
1319     }
1320 
1321     public boolean isAntialiasedShape() {
1322         return antialiasedShape;
1323     }
1324 
1325     public void scale(float sx, float sy, float sz) {
1326         throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
1327     }
1328 
1329     public void setTransform3D(double mxx, double mxy, double mxz, double mxt,
1330                                double myx, double myy, double myz, double myt,
1331                                double mzx, double mzy, double mzz, double mzt)
1332     {
1333         if (mxz != 0.0 || myz != 0.0 ||
1334             mzx != 0.0 || mzy != 0.0 || mzz != 1.0 || mzt != 0.0)
1335         {
1336             throw new UnsupportedOperationException(&quot;3D transforms not supported.&quot;);
1337         }
1338         setTransform(mxx, myx, mxy, myy, mxt, myt);
1339     }
1340 
1341     public void setCamera(NGCamera camera) {
1342         // No-op until we support 3D
1343         /*
1344         if (!(camera instanceof PrismParallelCameraImpl)) {
1345 
1346             throw new UnsupportedOperationException(camera+&quot; not supported.&quot;);
1347         }
1348         */
1349     }
1350 
1351     public void setDepthBuffer(boolean depthBuffer) {
1352         // No-op until we support 3D
1353     }
1354 
1355     public void setDepthTest(boolean depthTest) {
1356         // No-op until we support 3D
1357     }
1358 
1359     public void sync() {
1360     }
1361 
1362     public void translate(float tx, float ty, float tz) {
1363         throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
1364     }
1365 
1366     public void setCulling(boolean cull) {
1367         this.cull = cull;
1368     }
1369 
1370     public boolean isCulling() {
1371         return this.cull;
1372     }
1373 
1374  public void setClipRectIndex(int index) {
1375         this.clipRectIndex = index;
1376     }
1377     public int getClipRectIndex() {
1378         return this.clipRectIndex;
1379     }
1380 
1381     public void setHasPreCullingBits(boolean hasBits) {
1382         this.hasPreCullingBits = hasBits;
1383     }
1384 
1385     public boolean hasPreCullingBits() {
1386         return hasPreCullingBits;
1387     }
1388 
1389     private NodePath renderRoot;
1390     @Override
1391     public void setRenderRoot(NodePath root) {
1392         this.renderRoot = root;
1393     }
1394 
1395     @Override
1396     public NodePath getRenderRoot() {
1397         return renderRoot;
1398     }
1399 
1400     public void setState3D(boolean flag) {
1401     }
1402 
1403     public boolean isState3D() {
1404         return false;
1405     }
1406 
1407     public void setup3DRendering() {
1408     }
1409 
1410     @Override
1411     public void setPixelScaleFactors(float pixelScaleX, float pixelScaleY) {
1412         this.pixelScaleX = pixelScaleX;
1413         this.pixelScaleY = pixelScaleY;
1414     }
1415 
1416     @Override
1417     public float getPixelScaleFactorX() {
1418         return pixelScaleX;
1419     }
1420 
1421     @Override
1422     public float getPixelScaleFactorY() {
1423         return pixelScaleY;
1424     }
1425 
1426     @Override
1427     public void blit(RTTexture srcTex, RTTexture dstTex,
1428             int srcX0, int srcY0, int srcX1, int srcY1,
1429             int dstX0, int dstY0, int dstX1, int dstY1) {
1430         throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
1431     }
1432 
1433     private static class AdaptorShape implements java.awt.Shape {
1434         private Shape prshape;
1435 
1436         public void setShape(Shape prshape) {
1437             this.prshape = prshape;
1438         }
1439 
1440         public boolean contains(double x, double y) {
1441             return prshape.contains((float) x, (float) y);
1442         }
1443 
1444         public boolean contains(java.awt.geom.Point2D p) {
1445             return contains(p.getX(), p.getY());
1446         }
1447 
1448         public boolean contains(double x, double y, double w, double h) {
1449             return prshape.contains((float) x, (float) y, (float) w, (float) h);
1450         }
1451 
1452         public boolean contains(java.awt.geom.Rectangle2D r) {
1453             return contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());
1454         }
1455 
1456         public boolean intersects(double x, double y, double w, double h) {
1457             return prshape.intersects((float) x, (float) y, (float) w, (float) h);
1458         }
1459 
1460         public boolean intersects(java.awt.geom.Rectangle2D r) {
1461             return intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());
1462         }
1463 
1464         public java.awt.Rectangle getBounds() {
1465             return getBounds2D().getBounds();
1466         }
1467 
1468         public java.awt.geom.Rectangle2D getBounds2D() {
1469             RectBounds b = prshape.getBounds();
1470             java.awt.geom.Rectangle2D r2d =
1471                 new java.awt.geom.Rectangle2D.Float();
1472             r2d.setFrameFromDiagonal(b.getMinX(), b.getMinY(), b.getMaxX(), b.getMaxY());
1473             return r2d;
1474         }
1475 
1476         private static AdaptorPathIterator tmpAdaptor =
1477                 new AdaptorPathIterator();
1478         private static java.awt.geom.PathIterator tmpAdaptor(PathIterator pi) {
1479             tmpAdaptor.setIterator(pi);
1480             return tmpAdaptor;
1481         }
1482 
1483         public java.awt.geom.PathIterator
1484             getPathIterator(java.awt.geom.AffineTransform at)
1485         {
1486             BaseTransform tx = (at == null) ? null : toPrTransform(at);
1487             return tmpAdaptor(prshape.getPathIterator(tx));
1488         }
1489 
1490         public java.awt.geom.PathIterator
1491             getPathIterator(java.awt.geom.AffineTransform at,
1492                             double flatness)
1493         {
1494             BaseTransform tx = (at == null) ? null : toPrTransform(at);
1495             return tmpAdaptor(prshape.getPathIterator(tx, (float) flatness));
1496         }
1497     }
1498 
1499     private static class AdaptorPathIterator
1500         implements java.awt.geom.PathIterator
1501     {
1502         private static int NUM_COORDS[] = { 2, 2, 4, 6, 0 };
1503         PathIterator priterator;
1504         float tmpcoords[];
1505 
1506         public void setIterator(PathIterator priterator) {
1507             this.priterator = priterator;
1508         }
1509 
1510         public int currentSegment(float[] coords) {
1511             return priterator.currentSegment(coords);
1512         }
1513 
1514         public int currentSegment(double[] coords) {
1515             if (tmpcoords == null) {
1516                 tmpcoords = new float[6];
1517             }
1518             int ret = priterator.currentSegment(tmpcoords);
1519             for (int i = 0; i &lt; NUM_COORDS[ret]; i++) {
1520                 coords[i] = (double) tmpcoords[i];
1521             }
1522             return ret;
1523         }
1524 
1525         public int getWindingRule() {
1526             return priterator.getWindingRule();
1527         }
1528 
1529         public boolean isDone() {
1530             return priterator.isDone();
1531         }
1532 
1533         public void next() {
1534             priterator.next();
1535         }
1536     }
1537 
1538     static abstract class FilterStroke implements java.awt.Stroke {
1539         protected java.awt.BasicStroke stroke;
1540 
1541         FilterStroke(java.awt.BasicStroke stroke) {
1542             this.stroke = stroke;
1543         }
1544 
1545         abstract protected java.awt.Shape makeStrokedRect(java.awt.geom.Rectangle2D r);
1546         abstract protected java.awt.Shape makeStrokedShape(java.awt.Shape s);
1547 
1548         public java.awt.Shape createStrokedShape(java.awt.Shape p) {
1549             if (p instanceof java.awt.geom.Rectangle2D) {
1550                 java.awt.Shape s = makeStrokedRect((java.awt.geom.Rectangle2D) p);
1551                 if (s != null) {
1552                     return s;
1553                 }
1554             }
1555             return makeStrokedShape(p);
1556         }
1557 
1558         // ArcIterator.btan(Math.PI/2)
1559         static final double CtrlVal = 0.5522847498307933;
1560 
1561         static java.awt.geom.Point2D cornerArc(java.awt.geom.GeneralPath gp,
1562                                                       float x0, float y0,
1563                                                       float xc, float yc,
1564                                                       float x1, float y1)
1565         {
1566             return cornerArc(gp, x0, y0, xc, yc, x1, y1, 0.5f);
1567         }
1568 
1569         static java.awt.geom.Point2D cornerArc(java.awt.geom.GeneralPath gp,
1570                                                       float x0, float y0,
1571                                                       float xc, float yc,
1572                                                       float x1, float y1, float t)
1573         {
1574             float xc0 = (float) (x0 + CtrlVal * (xc - x0));
1575             float yc0 = (float) (y0 + CtrlVal * (yc - y0));
1576             float xc1 = (float) (x1 + CtrlVal * (xc - x1));
1577             float yc1 = (float) (y1 + CtrlVal * (yc - y1));
1578             gp.curveTo(xc0, yc0, xc1, yc1, x1, y1);
1579 
1580             return new java.awt.geom.Point2D.Float(eval(x0, xc0, xc1, x1, t),
1581                                                    eval(y0, yc0, yc1, y1, t));
1582         }
1583 
1584         static float eval(float c0, float c1, float c2, float c3, float t) {
1585             c0 = c0 + (c1-c0) * t;
1586             c1 = c1 + (c2-c1) * t;
1587             c2 = c2 + (c3-c2) * t;
1588             c0 = c0 + (c1-c0) * t;
1589             c1 = c1 + (c2-c1) * t;
1590             return c0 + (c1-c0) * t;
1591         }
1592     }
1593 
1594     static class InnerStroke extends FilterStroke {
1595         InnerStroke(java.awt.BasicStroke stroke) {
1596             super(stroke);
1597         }
1598 
1599         protected java.awt.Shape makeStrokedRect(java.awt.geom.Rectangle2D r) {
1600             if (stroke.getDashArray() != null) {
1601                 return null;
1602             }
1603             float pad = stroke.getLineWidth() / 2f;
1604             if (pad &gt;= r.getWidth() || pad &gt;= r.getHeight()) {
1605                 return r;
1606             }
1607             float rx0 = (float) r.getX();
1608             float ry0 = (float) r.getY();
1609             float rx1 = rx0 + (float) r.getWidth();
1610             float ry1 = ry0 + (float) r.getHeight();
1611             java.awt.geom.GeneralPath gp = new java.awt.geom.GeneralPath();
1612             gp.moveTo(rx0, ry0);
1613             gp.lineTo(rx1, ry0);
1614             gp.lineTo(rx1, ry1);
1615             gp.lineTo(rx0, ry1);
1616             gp.closePath();
1617             rx0 += pad;
1618             ry0 += pad;
1619             rx1 -= pad;
1620             ry1 -= pad;
1621             gp.moveTo(rx0, ry0);
1622             gp.lineTo(rx0, ry1);
1623             gp.lineTo(rx1, ry1);
1624             gp.lineTo(rx1, ry0);
1625             gp.closePath();
1626             return gp;
1627         }
1628 
1629         // NOTE: This is a work in progress, not used yet
1630         protected java.awt.Shape makeStrokedEllipse(java.awt.geom.Ellipse2D e) {
1631             if (stroke.getDashArray() != null) {
1632                 return null;
1633             }
1634             float pad = stroke.getLineWidth() / 2f;
1635             float w = (float) e.getWidth();
1636             float h = (float) e.getHeight();
1637             if (w - 2*pad &gt; h * 2 || h - 2*pad &gt; w * 2) {
1638                 // If the inner ellipse is too &quot;squashed&quot; then we can not
1639                 // approximate it with just a single cubic per quadrant.
1640                 // NOTE: measure so we can relax this restriction and
1641                 // also consider modifying the code below to insert
1642                 // more cubics in those cases.
1643                 return null;
1644             }
1645             if (pad &gt;= w || pad &gt;= h) {
1646                 return e;
1647             }
1648             float x0 = (float) e.getX();
1649             float y0 = (float) e.getY();
1650             float xc = x0 + w / 2f;
1651             float yc = y0 + h / 2f;
1652             float x1 = x0 + w;
1653             float y1 = y0 + h;
1654             java.awt.geom.GeneralPath gp = new java.awt.geom.GeneralPath();
1655             gp.moveTo(xc, y0);
1656             cornerArc(gp, xc, y0, x1, y0, x1, yc);
1657             cornerArc(gp, x1, yc, x1, y1, xc, y1);
1658             cornerArc(gp, xc, y1, x0, y1, x0, yc);
1659             cornerArc(gp, x0, yc, x0, y0, xc, y0);
1660             gp.closePath();
1661             x0 += pad;
1662             y0 += pad;
1663             x1 -= pad;
1664             y1 -= pad;
1665             gp.moveTo(xc, y0);
1666             cornerArc(gp, xc, y0, x0, y0, x0, yc);
1667             cornerArc(gp, x0, yc, x0, y1, xc, y1);
1668             cornerArc(gp, xc, y1, x1, y1, x1, yc);
1669             cornerArc(gp, x1, yc, x1, y0, xc, y0);
1670             gp.closePath();
1671             return gp;
1672         }
1673 
1674         @Override
1675         protected java.awt.Shape makeStrokedShape(java.awt.Shape s) {
1676             java.awt.Shape ss = stroke.createStrokedShape(s);
1677             java.awt.geom.Area b = new java.awt.geom.Area(ss);
1678             b.intersect(new java.awt.geom.Area(s));
1679             return b;
1680         }
1681     }
1682 
1683     static class OuterStroke extends FilterStroke {
1684         static double SQRT_2 = Math.sqrt(2);
1685 
1686         OuterStroke(java.awt.BasicStroke stroke) {
1687             super(stroke);
1688         }
1689 
1690         protected java.awt.Shape makeStrokedRect(java.awt.geom.Rectangle2D r) {
1691             if (stroke.getDashArray() != null) {
1692                 return null;
1693             }
1694             float pad = stroke.getLineWidth() / 2f;
1695             float rx0 = (float) r.getX();
1696             float ry0 = (float) r.getY();
1697             float rx1 = rx0 + (float) r.getWidth();
1698             float ry1 = ry0 + (float) r.getHeight();
1699             java.awt.geom.GeneralPath gp = new java.awt.geom.GeneralPath();
1700             // clockwise
1701             gp.moveTo(rx0, ry0);
1702             gp.lineTo(rx1, ry0);
1703             gp.lineTo(rx1, ry1);
1704             gp.lineTo(rx0, ry1);
1705             gp.closePath();
1706             float ox0 = rx0 - pad;
1707             float oy0 = ry0 - pad;
1708             float ox1 = rx1 + pad;
1709             float oy1 = ry1 + pad;
1710             switch (stroke.getLineJoin()) {
1711             case BasicStroke.JOIN_MITER:
1712                 // A miter limit of less than sqrt(2) bevels right angles...
1713                 if (stroke.getMiterLimit() &gt;= SQRT_2) {
1714                     // counter-clockwise
1715                     gp.moveTo(ox0, oy0);
1716                     gp.lineTo(ox0, oy1);
1717                     gp.lineTo(ox1, oy1);
1718                     gp.lineTo(ox1, oy0);
1719                     gp.closePath();
1720                     break;
1721                 }
1722                 // NO BREAK
1723             case BasicStroke.JOIN_BEVEL:
1724                 // counter-clockwise
1725                 gp.moveTo(ox0, ry0);
1726                 gp.lineTo(ox0, ry1);  // left edge
1727                 gp.lineTo(rx0, oy1);  // ll corner
1728                 gp.lineTo(rx1, oy1);  // bottom edge
1729                 gp.lineTo(ox1, ry1);  // lr corner
1730                 gp.lineTo(ox1, ry0);  // right edge
1731                 gp.lineTo(rx1, oy0);  // ur corner
1732                 gp.lineTo(rx0, oy0);  // top edge
1733                 gp.closePath();       // ul corner
1734                 break;
1735             case BasicStroke.JOIN_ROUND:
1736                 // counter-clockwise
1737                 gp.moveTo(ox0, ry0);
1738                 gp.lineTo(ox0, ry1);                          // left edge
1739                 cornerArc(gp, ox0, ry1, ox0, oy1, rx0, oy1);  // ll corner
1740                 gp.lineTo(rx1, oy1);                          // bottom edge
1741                 cornerArc(gp, rx1, oy1, ox1, oy1, ox1, ry1);  // lr corner
1742                 gp.lineTo(ox1, ry0);                          // right edge
1743                 cornerArc(gp, ox1, ry0, ox1, oy0, rx1, oy0);  // ur corner
1744                 gp.lineTo(rx0, oy0);                          // top edge
1745                 cornerArc(gp, rx0, oy0, ox0, oy0, ox0, ry0);  // ul corner
1746                 gp.closePath();
1747                 break;
1748             default:
1749                 throw new InternalError(&quot;Unrecognized line join style&quot;);
1750             }
1751             return gp;
1752         }
1753 
1754         // NOTE: This is a work in progress, not used yet
1755         protected java.awt.Shape makeStrokedEllipse(java.awt.geom.Ellipse2D e) {
1756             if (stroke.getDashArray() != null) {
1757                 return null;
1758             }
1759             float pad = stroke.getLineWidth() / 2f;
1760             float w = (float) e.getWidth();
1761             float h = (float) e.getHeight();
1762             if (w &gt; h * 2 || h &gt; w * 2) {
1763                 // If the inner ellipse is too &quot;squashed&quot; then we can not
1764                 // approximate it with just a single cubic per quadrant.
1765                 // NOTE: measure so we can relax this restriction and
1766                 // also consider modifying the code below to insert
1767                 // more cubics in those cases.
1768                 return null;
1769             }
1770             float x0 = (float) e.getX();
1771             float y0 = (float) e.getY();
1772             float xc = x0 + w / 2f;
1773             float yc = y0 + h / 2f;
1774             float x1 = x0 + w;
1775             float y1 = y0 + h;
1776             java.awt.geom.GeneralPath gp = new java.awt.geom.GeneralPath();
1777             gp.moveTo(xc, y0);
1778             cornerArc(gp, xc, y0, x1, y0, x1, yc);
1779             cornerArc(gp, x1, yc, x1, y1, xc, y1);
1780             cornerArc(gp, xc, y1, x0, y1, x0, yc);
1781             cornerArc(gp, x0, yc, x0, y0, xc, y0);
1782             gp.closePath();
1783             x0 -= pad;
1784             y0 -= pad;
1785             x1 += pad;
1786             y1 += pad;
1787             gp.moveTo(xc, y0);
1788             cornerArc(gp, xc, y0, x0, y0, x0, yc);
1789             cornerArc(gp, x0, yc, x0, y1, xc, y1);
1790             cornerArc(gp, xc, y1, x1, y1, x1, yc);
1791             cornerArc(gp, x1, yc, x1, y0, xc, y0);
1792             gp.closePath();
1793             return gp;
1794         }
1795 
1796         @Override
1797         protected java.awt.Shape makeStrokedShape(java.awt.Shape s) {
1798             java.awt.Shape ss = stroke.createStrokedShape(s);
1799             java.awt.geom.Area b = new java.awt.geom.Area(ss);
1800             b.subtract(new java.awt.geom.Area(s));
1801             return b;
1802         }
1803     }
1804 
1805     @Override
1806     public void setLights(NGLightBase[] lights) {
1807         // Light are not supported by J2d
1808     }
1809 
1810     @Override
1811     public NGLightBase[] getLights() {
1812         // Light are not supported by J2d
1813         return null;
1814     }
1815 }
    </pre>
  </body>
</html>