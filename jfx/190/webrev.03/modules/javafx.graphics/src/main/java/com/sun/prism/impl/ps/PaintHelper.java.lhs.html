<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/com/sun/prism/impl/ps/PaintHelper.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.prism.impl.ps;
 27 
 28 import java.nio.ByteBuffer;
 29 import java.nio.FloatBuffer;
 30 import java.util.List;
 31 import com.sun.javafx.geom.PickRay;
 32 import com.sun.javafx.geom.Point2D;
 33 import com.sun.javafx.geom.Vec3d;
 34 import com.sun.javafx.geom.transform.Affine2D;
 35 import com.sun.javafx.geom.transform.Affine3D;
 36 import com.sun.javafx.geom.transform.AffineBase;
 37 import com.sun.javafx.geom.transform.BaseTransform;
 38 import com.sun.javafx.geom.transform.NoninvertibleTransformException;
 39 import com.sun.javafx.sg.prism.NGCamera;
 40 import com.sun.javafx.sg.prism.NGPerspectiveCamera;
 41 import com.sun.prism.Image;
 42 import com.sun.prism.PixelFormat;
 43 import com.sun.prism.ResourceFactory;
 44 import com.sun.prism.Texture;
 45 import com.sun.prism.Texture.Usage;
 46 import com.sun.prism.Texture.WrapMode;
 47 import com.sun.prism.impl.BufferUtil;
 48 import com.sun.prism.paint.Color;
 49 import com.sun.prism.paint.Gradient;
 50 import com.sun.prism.paint.ImagePattern;
 51 import com.sun.prism.paint.LinearGradient;
 52 import com.sun.prism.paint.RadialGradient;
 53 import com.sun.prism.paint.Stop;
 54 import com.sun.prism.ps.Shader;
 55 import com.sun.prism.ps.ShaderGraphics;
 56 
 57 class PaintHelper {
 58 
 59 /****************** Shared MultipleGradientPaint support ********************/
 60 
 61     /**
 62      * The maximum number of gradient &quot;stops&quot; supported by our native
 63      * fragment shader implementations.
 64      *
 65      * This value has been empirically determined and capped to allow
 66      * our native shaders to run on all shader-level graphics hardware,
 67      * even on the older, more limited GPUs.  Even the oldest Nvidia
 68      * hardware could handle 16, or even 32 fractions without any problem.
 69      * But the first-generation boards from ATI would fall back into
 70      * software mode (which is unusably slow) for values larger than 12;
 71      * it appears that those boards do not have enough native registers
 72      * to support the number of array accesses required by our gradient
 73      * shaders.  So for now we will cap this value at 12, but we can
 74      * re-evaluate this in the future as hardware becomes more capable.
 75      */
 76     static final int MULTI_MAX_FRACTIONS = 12;
 77 
 78     /**
 79      * Make the texture width a power of two value larger
 80      * than MULTI_MAX_FRACTIONS.
 81      */
 82     private static final int MULTI_TEXTURE_SIZE = 16;
 83     private static final int MULTI_CACHE_SIZE = 256;
 84     private static final int GTEX_CLR_TABLE_SIZE = 101; // for every % from 0% to 100%
 85     private static final int GTEX_CLR_TABLE_MIRRORED_SIZE =
 86         GTEX_CLR_TABLE_SIZE * 2 - 1;
 87 
 88     private static final float FULL_TEXEL_Y = 1.0f / MULTI_CACHE_SIZE;
 89     private static final float HALF_TEXEL_Y = FULL_TEXEL_Y / 2.0f;
 90 
 91     private static final FloatBuffer stopVals =
 92         BufferUtil.newFloatBuffer(MULTI_MAX_FRACTIONS * 4);
 93     private static final ByteBuffer bgraColors =
 94         BufferUtil.newByteBuffer(MULTI_TEXTURE_SIZE*4);
 95     private static final Image colorsImg =
 96         Image.fromByteBgraPreData(bgraColors, MULTI_TEXTURE_SIZE, 1);
 97     private static final int[] previousColors = new int[MULTI_TEXTURE_SIZE];
 98 
 99     private static final byte gtexColors[] = new byte[GTEX_CLR_TABLE_MIRRORED_SIZE * 4];
100     private static final Image gtexImg =
101         Image.fromByteBgraPreData(ByteBuffer.wrap(gtexColors), GTEX_CLR_TABLE_MIRRORED_SIZE, 1);
102 
103     private static long cacheOffset = -1;
104 
105     private static Texture gradientCacheTexture = null;
106     private static Texture gtexCacheTexture = null;
107 
108     private static final Affine2D scratchXform2D = new Affine2D();
109     private static final Affine3D scratchXform3D = new Affine3D();
110 
111     private static float len(float dx, float dy) {
112         return ((dx == 0f) ? Math.abs(dy)
113                 : ((dy == 0f) ? Math.abs(dx)
114                    : (float)Math.sqrt(dx * dx + dy * dy)));
115     }
116 
117     static void initGradientTextures(ShaderGraphics g) {
118         gradientCacheTexture = g.getResourceFactory().createTexture(
119                 PixelFormat.BYTE_BGRA_PRE, Usage.DEFAULT, WrapMode.CLAMP_TO_EDGE,
120                 MULTI_TEXTURE_SIZE, MULTI_CACHE_SIZE);
121         gradientCacheTexture.setLinearFiltering(true);
122         // gradientCacheTexture remains permanently locked, useful, and permanent
123         // an additional lock is added when a caller calls getGreientTeture for
124         // them to unlock
125         gradientCacheTexture.contentsUseful();
126         gradientCacheTexture.makePermanent();
127 
128         gtexCacheTexture = g.getResourceFactory().createTexture(
129                 PixelFormat.BYTE_BGRA_PRE, Usage.DEFAULT, WrapMode.CLAMP_NOT_NEEDED,
130                 GTEX_CLR_TABLE_MIRRORED_SIZE, MULTI_CACHE_SIZE);
131         gtexCacheTexture.setLinearFiltering(true);
132         // gtexCacheTexture remains permanently locked, useful, and permanent
133         // an additional lock is added when a caller calls getWrapGreientTeture for
134         // them to unlock
135         gtexCacheTexture.contentsUseful();
136         gtexCacheTexture.makePermanent();
137     }
138 
139     static Texture getGradientTexture(ShaderGraphics g, Gradient paint) {
140         if (gradientCacheTexture == null) {
141             initGradientTextures(g);
142         }
143 
144         // gradientCacheTexture is left permanent and locked so it never
145         // goes away or needs to be checked for isSurfaceLost(), but we
146         // add a lock here so that the caller can unlock without knowing
147         // our inner implementation details
148         gradientCacheTexture.lock();
149         return gradientCacheTexture;
150     }
151 
152     static Texture getWrapGradientTexture(ShaderGraphics g) {
153         if (gtexCacheTexture == null) {
154             initGradientTextures(g);
155         }
156 
157         // gtexCacheTexture is left permanent and locked so it never
158         // goes away or needs to be checked for isSurfaceLost(), but we
159         // add a lock here so that the caller can unlock without knowing
160         // our inner implementation details
161         gtexCacheTexture.lock();
162         return gtexCacheTexture;
163     }
164 
165     private static void stopsToImage(List&lt;Stop&gt; stops, int numStops)
166     {
167         if (numStops &gt; MULTI_MAX_FRACTIONS) {
168             throw new RuntimeException(
169                 &quot;Maximum number of gradient stops exceeded &quot; +
170                 &quot;(paint uses &quot; + numStops +
171                 &quot; stops, but max is &quot; + MULTI_MAX_FRACTIONS + &quot;)&quot;);
172         }
173 
174         bgraColors.clear();
175         Color lastColor = null;
176         for (int i = 0; i &lt; MULTI_TEXTURE_SIZE; i++) {
177             Color c;
178             if (i &lt; numStops) {
179                 c = stops.get(i).getColor();
180                 lastColor = c;
181             } else {
182                 // repeat the last color for the remaining slots so that
183                 // we can simply reference the last pixel of the texture when
184                 // dealing with edge conditions
185                 c = lastColor;
186             }
187             c.putBgraPreBytes(bgraColors);
188 
189             // optimization: keep track of colors used each time so that
190             // we can skip updating the texture if the colors are same as
191             // the last time
192             int argb = c.getIntArgbPre();
193             if (argb != previousColors[i]) {
194                 previousColors[i] = argb;
195             }
196         }
197         bgraColors.rewind();
198     }
199 
200     private static void insertInterpColor(byte colors[], int index,
201                                           Color c0, Color c1, float t)
202     {
203         t *= 255.0f;
204         float u = 255.0f - t;
205         index *= 4;
206         colors[index + 0] = (byte) (c0.getBluePremult()  * u + c1.getBluePremult()  * t + 0.5f);
207         colors[index + 1] = (byte) (c0.getGreenPremult() * u + c1.getGreenPremult() * t + 0.5f);
208         colors[index + 2] = (byte) (c0.getRedPremult()   * u + c1.getRedPremult()   * t + 0.5f);
209         colors[index + 3] = (byte) (c0.getAlpha()        * u + c1.getAlpha()        * t + 0.5f);
210     }
211 
212     private static Color PINK = new Color(1.0f, 0.078431375f, 0.5764706f, 1.0f);
213 
214     private static void stopsToGtexImage(List&lt;Stop&gt; stops, int numStops) {
215         Color lastColor = stops.get(0).getColor();
216         float offset = stops.get(0).getOffset();
217         int lastIndex = (int) (offset * (GTEX_CLR_TABLE_SIZE - 1) + 0.5f);
218         insertInterpColor(gtexColors, 0, lastColor, lastColor, 0.0f);
219         for (int i = 1; i &lt; numStops; i++) {
220             Color color = stops.get(i).getColor();
221             offset = stops.get(i).getOffset();
222             int index = (int) (offset * (GTEX_CLR_TABLE_SIZE - 1) + 0.5f);
223             if (index == lastIndex) {
224                 insertInterpColor(gtexColors, index, lastColor, color, 0.5f);
225             } else {
226                 for (int j = lastIndex+1; j &lt;= index; j++) {
227                     float t = j - lastIndex;
228                     t /= (index - lastIndex);
229                     insertInterpColor(gtexColors, j, lastColor, color, t);
230                 }
231             }
232             lastIndex = index;
233             lastColor = color;
234         }
235         // assert (lastIndex = GTEX_CLR_TABLE_SIZE);
236         // now mirror the list for fast REFLECT calculations
237         // mirroring is around index = (GTEX_CLR_TABLE_SIZE-1) which is
238         // where the last color for fract=1.0 should have been stored
239         for (int i = 1; i &lt; GTEX_CLR_TABLE_SIZE; i++) {
240             int j = (GTEX_CLR_TABLE_SIZE - 1 + i) * 4;
241             int k = (GTEX_CLR_TABLE_SIZE - 1 - i) * 4;
242             gtexColors[j + 0] = gtexColors[k + 0];
243             gtexColors[j + 1] = gtexColors[k + 1];
244             gtexColors[j + 2] = gtexColors[k + 2];
245             gtexColors[j + 3] = gtexColors[k + 3];
246         }
247     }
248 
249     // Uses a least recently allocated algorithm for caching Gradient colors.
250     // This could be optimized so that we never use the same color twice.
251     // We always increment the cacheOffset (long) and keep the gradients stored
252     // the cache in the range [cacheOffset - cacheSize + 1, cacheOffset]..
253     public static int initGradient(Gradient paint) {
254         long offset = paint.getGradientOffset();
255         if (offset &gt;= 0 &amp;&amp; (offset &gt; cacheOffset - MULTI_CACHE_SIZE)) {
256             return (int) (offset % MULTI_CACHE_SIZE);
257         } else {
258             List&lt;Stop&gt; stops = paint.getStops();
259             int numStops = paint.getNumStops();
260             stopsToImage(stops,numStops);
261             stopsToGtexImage(stops, numStops);
262             long nextOffset = ++cacheOffset;
263             paint.setGradientOffset(nextOffset);
264             int cacheIdx = (int)(nextOffset % MULTI_CACHE_SIZE);
265             // both gradientCacheTexture and gtexCacheTexture should be
266             // left permanent and locked so we can always call update on
267             // either or both of them here.
268             gradientCacheTexture.update(colorsImg, 0, cacheIdx);
269             gtexCacheTexture.update(gtexImg, 0, cacheIdx);
270             return cacheIdx;
271         }
272     }
273 
274     private static void setMultiGradient(Shader shader,
275                                          Gradient paint)
276     {
277         List&lt;Stop&gt; stops = paint.getStops();
278         int numStops = paint.getNumStops();
279 
280         stopVals.clear();
281         for (int i = 0; i &lt; MULTI_MAX_FRACTIONS; i++) {
282             // TODO: optimize this... (RT-27377)
283             stopVals.put((i &lt; numStops)   ?
284                          stops.get(i).getOffset() : 0f);
285             stopVals.put((i &lt; numStops-1) ?
286                          1f / (stops.get(i+1).getOffset() - stops.get(i).getOffset()) : 0f);
287             stopVals.put(0f); // unused
288             stopVals.put(0f); // unused
289         }
290         stopVals.rewind();
291         shader.setConstants(&quot;fractions&quot;, stopVals, 0, MULTI_MAX_FRACTIONS);
292         float index_y = initGradient(paint);
293         shader.setConstant(&quot;offset&quot;, index_y / (float)MULTI_CACHE_SIZE + HALF_TEXEL_Y);
294 
295         // Note that the colors image/texture has already been updated
296         // in BaseShaderContext.validatePaintOp()...
297     }
298 
299     private static void setTextureGradient(Shader shader,
300                                            Gradient paint)
301     {
302         float cy = initGradient(paint) + 0.5f;
303         float cx = 0.5f;
304         float fractmul = 0.0f, clampmul = 0.0f;
305         switch (paint.getSpreadMethod()) {
306             case Gradient.PAD:
307                 // distance from 0.5 texels to TABLE_SIZE - 0.5 texels
308                 clampmul = GTEX_CLR_TABLE_SIZE - 1.0f;
309                 break;
310             case Gradient.REPEAT:
311                 // distance from 0.5 texels to TABLE_SIZE - 0.5 texels
312                 fractmul = GTEX_CLR_TABLE_SIZE - 1.0f;
313                 break;
314             case Gradient.REFLECT:
315                 // distance from 0.5 texels to MIRROR_TABLE_SIZE - 0.5 texels
316                 fractmul = GTEX_CLR_TABLE_MIRRORED_SIZE - 1.0f;
317                 break;
318         }
319         float xscale = 1.0f / gtexCacheTexture.getPhysicalWidth();
320         float yscale = 1.0f / gtexCacheTexture.getPhysicalHeight();
321         cx *= xscale;
322         cy *= yscale;
323         fractmul *= xscale;
324         clampmul *= xscale;
325         shader.setConstant(&quot;content&quot;, cx, cy, fractmul, clampmul);
326 
327         // Note that the colors image/texture has already been updated
328         // in BaseShaderContext.validatePaintOp()...
329     }
330 
331 /********************** LinearGradientPaint support *************************/
332 
333     /**
334      * This method uses techniques that are nearly identical to those
335      * employed in setGradientPaint() above.  The primary difference
336      * is that at the native level we use a fragment shader to manually
337      * apply the plane equation constants to the current fragment position
338      * to calculate the gradient position in the range [0,1] (the native
339      * code for GradientPaint does the same, except that it uses OpenGL&#39;s
340      * automatic texture coordinate generation facilities). We Also, project
341      * in the 3D case to create a perspective vector which is used in the
342      * fragment shader.
343      *
344      * One other minor difference worth mentioning is that
345      * setGradientPaint() calculates the plane equation constants
346      * such that the gradient end points are positioned at 0.25 and 0.75
347      * (for reasons discussed in the comments for that method).  In
348      * contrast, for LinearGradientPaint we setup the equation constants
349      * such that the gradient end points fall at 0.0 and 1.0.  The
350      * reason for this difference is that in the fragment shader we
351      * have more control over how the gradient values are interpreted
352      * (depending on the paint&#39;s CycleMethod).
353      */
354     static void setLinearGradient(ShaderGraphics g,
355                                   Shader shader,
356                                   LinearGradient paint,
357                                   float rx, float ry, float rw, float rh)
358     {
359         BaseTransform paintXform = paint.getGradientTransformNoClone();
360         Affine3D at = scratchXform3D;
361         g.getPaintShaderTransform(at);
362 
363         if (paintXform != null) {
364             at.concatenate(paintXform);
365         }
366 
367         float x1 = rx + (paint.getX1() * rw);
368         float y1 = ry + (paint.getY1() * rh);
369         float x2 = rx + (paint.getX2() * rw);
370         float y2 = ry + (paint.getY2() * rh);
371 
372         // calculate plane equation constants
373         float x = x1;
374         float y = y1;
375         at.translate(x, y);
376         // now gradient point 1 is at the origin
377         x = x2 - x;
378         y = y2 - y;
379         double len = len(x, y);
380 
381         at.rotate(Math.atan2(y, x));
382         // now gradient point 2 is on the positive x-axis
383         at.scale(len, 1);
384         // now gradient point 1 is at (0.0, 0), point 2 is at (1.0, 0)
385 
386         double p0, p1, p2;
387 
388         if (!at.is2D()) {
389             BaseTransform inv;
390             try {
391                 inv = at.createInverse();
392             } catch (NoninvertibleTransformException e) {
393                 at.setToScale(0, 0, 0);
394                 inv = at;
395             }
396 
397             NGCamera cam = g.getCameraNoClone();
398             Vec3d tmpVec = new Vec3d();
399             PickRay tmpvec = new PickRay();
400 
401             PickRay ray00 = project(0,0,cam,inv,tmpvec,tmpVec,null);
402             PickRay ray10 = project(1,0,cam,inv,tmpvec,tmpVec,null);
403             PickRay ray01 = project(0,1,cam,inv,tmpvec,tmpVec,null);
404 
405             p0 = ray10.getDirectionNoClone().x - ray00.getDirectionNoClone().x;
406             p1 = ray01.getDirectionNoClone().x - ray00.getDirectionNoClone().x;
407             p2 = ray00.getDirectionNoClone().x;
408 
409             p0 *= -ray00.getOriginNoClone().z;
410             p1 *= -ray00.getOriginNoClone().z;
411             p2 *= -ray00.getOriginNoClone().z;
412 
413             double wv0 = ray10.getDirectionNoClone().z - ray00.getDirectionNoClone().z;
414             double wv1 = ray01.getDirectionNoClone().z - ray00.getDirectionNoClone().z;
415             double wv2 = ray00.getDirectionNoClone().z;
416 
417             shader.setConstant(&quot;gradParams&quot;, (float)p0, (float)p1, (float)p2, (float)ray00.getOriginNoClone().x);
418             shader.setConstant(&quot;perspVec&quot;, (float)wv0, (float)wv1, (float)wv2);
419         } else {
420             try {
421                 at.invert();
422             } catch (NoninvertibleTransformException ex) {
423                 at.setToScale(0, 0, 0);
424             }
425             p0 = (float)at.getMxx();
426             p1 = (float)at.getMxy();
427             p2 = (float)at.getMxt();
428             shader.setConstant(&quot;gradParams&quot;, (float)p0, (float)p1, (float)p2, 0.0f);
429             shader.setConstant(&quot;perspVec&quot;, 0.0f, 0.0f, 1.0f);
430         }
431 
432         setMultiGradient(shader, paint);
433     }
434 
435     static AffineBase getLinearGradientTx(LinearGradient paint,
436                                           Shader shader,
437                                           BaseTransform renderTx,
438                                           float rx, float ry, float rw, float rh)
439     {
440         AffineBase ret;
441 
442         float x1 = paint.getX1();
443         float y1 = paint.getY1();
444         float x2 = paint.getX2();
445         float y2 = paint.getY2();
446         if (paint.isProportional()) {
447             x1 = rx + x1 * rw;
448             y1 = ry + y1 * rh;
449             x2 = rx + x2 * rw;
450             y2 = ry + y2 * rh;
451         }
452         float dx = x2 - x1;
453         float dy = y2 - y1;
454         float len = len(dx, dy);
455         if (paint.getSpreadMethod() == Gradient.REFLECT) {
456             len *= 2.0f;
457         }
458 
459         BaseTransform paintXform = paint.getGradientTransformNoClone();
460         if (paintXform.isIdentity() &amp;&amp; renderTx.isIdentity()) {
461             Affine2D at = scratchXform2D;
462 
463             // calculate plane equation constants
464             at.setToTranslation(x1, y1);
465             // now gradient point 1 is at the origin
466             at.rotate(dx, dy);
467             // now gradient point 2 is on the positive x-axis
468             at.scale(len, 1);
469             // now 0,0 maps to gradient point 1 and 1,0 maps to point 2
470 
471             ret = at;
472         } else {
473             Affine3D at = scratchXform3D;
474             at.setTransform(renderTx);
475             at.concatenate(paintXform);
476 
477             // calculate plane equation constants
478             at.translate(x1, y1);
479             // now gradient point 1 is at the origin
480             at.rotate(Math.atan2(dy, dx));
481             // now gradient point 2 is on the positive x-axis
482             at.scale(len, 1);
483             // now 0,0 maps to gradient point 1 and 1,0 maps to point 2
484 
485             ret = at;
486         }
487 
488         try {
489             ret.invert();
490         } catch (NoninvertibleTransformException e) {
491             scratchXform2D.setToScale(0, 0);
492             ret = scratchXform2D;
493         }
494 
495         setTextureGradient(shader, paint);
496 
497         return ret;
498     }
499 
500 /********************** RadialGradientPaint support *************************/
501 
502     /**
503      * This method calculates six m** values and a focus adjustment value that
504      * are used by the native fragment shader. (See LinearGradient Comment for
505      * the 3D case.) These techniques are based on a whitepaper by Daniel Rice
506      * on radial gradient performance (attached to the bug report for 6521533).
507      * One can refer to that document for the complete set of formulas and
508      * calculations, but the basic goal is to compose a transform that will
509      * convert an (x,y) position in device space into a &quot;u&quot; value that represents
510      * the relative distance to the gradient focus point.  The resulting
511      * value can be used to look up the appropriate color by linearly
512      * interpolating between the two nearest colors in the gradient.
513      */
514     static void setRadialGradient(ShaderGraphics g,
515                                   Shader shader,
516                                   RadialGradient paint,
517                                   float rx, float ry, float rw, float rh)
518     {
519         Affine3D at = scratchXform3D;
520         g.getPaintShaderTransform(at);
521 
522         // save original (untransformed) center and focus points and
523         // adjust to account for proportional attribute if necessary
524         float radius = paint.getRadius();
525         float cx = paint.getCenterX();
526         float cy = paint.getCenterY();
527         float fa = paint.getFocusAngle();
528         float fd = paint.getFocusDistance();
529         if (fd &lt; 0) {
530             fd = -fd;
531             fa = fa+180;
532         }
533         fa = (float) Math.toRadians(fa);
534         if (paint.isProportional()) {
535             float bcx = rx + (rw / 2f);
536             float bcy = ry + (rh / 2f);
537             float scale = Math.min(rw, rh);
538             cx = (cx - 0.5f) * scale + bcx;
539             cy = (cy - 0.5f) * scale + bcy;
540             if (rw != rh &amp;&amp; rw != 0f &amp;&amp; rh != 0f) {
541                 at.translate(bcx, bcy);
542                 at.scale(rw / scale, rh / scale);
543                 at.translate(-bcx, -bcy);
544             }
545             radius = radius * scale;
546         }
547 
548         // transform from gradient coords to device coords
549         BaseTransform paintXform = paint.getGradientTransformNoClone();
550         if (paintXform != null) {
551             at.concatenate(paintXform);
552         }
553 
554         // transform unit circle to gradient coords; we start with the
555         // unit circle (center=(0,0), focus on positive x-axis, radius=1)
556         // and then transform into gradient space
557         at.translate(cx, cy);
558         at.rotate(fa);
559         at.scale(radius, radius);
560 
561             // invert to get mapping from device coords to unit circle
562         try {
563             at.invert();
564         } catch (Exception e) {
565             at.setToScale(0.0, 0.0, 0.0);
566         }
567 
568         if (!at.is2D()) {
569             NGCamera cam = g.getCameraNoClone();
570             Vec3d tmpVec = new Vec3d();
571             PickRay tmpvec = new PickRay();
572 
573             PickRay ray00 = project(0, 0, cam, at, tmpvec, tmpVec, null);
574             PickRay ray10 = project(1, 0, cam, at, tmpvec, tmpVec, null);
575             PickRay ray01 = project(0, 1, cam, at, tmpvec, tmpVec, null);
576 
577             double p0 = ray10.getDirectionNoClone().x - ray00.getDirectionNoClone().x;
578             double p1 = ray01.getDirectionNoClone().x - ray00.getDirectionNoClone().x;
579             double p2 = ray00.getDirectionNoClone().x;
580 
581             double py0 = ray10.getDirectionNoClone().y - ray00.getDirectionNoClone().y;
582             double py1 = ray01.getDirectionNoClone().y - ray00.getDirectionNoClone().y;
583             double py2 = ray00.getDirectionNoClone().y;
584 
585             p0 *= -ray00.getOriginNoClone().z;
586             p1 *= -ray00.getOriginNoClone().z;
587             p2 *= -ray00.getOriginNoClone().z;
588 
589             py0 *= -ray00.getOriginNoClone().z;
590             py1 *= -ray00.getOriginNoClone().z;
591             py2 *= -ray00.getOriginNoClone().z;
592 
593             double wv0 = ray10.getDirectionNoClone().z - ray00.getDirectionNoClone().z;
594             double wv1 = ray01.getDirectionNoClone().z - ray00.getDirectionNoClone().z;
595             double wv2 = ray00.getDirectionNoClone().z;
596 
597             shader.setConstant(&quot;perspVec&quot;, (float) wv0, (float) wv1, (float) wv2);
598             shader.setConstant(&quot;m0&quot;, (float) p0, (float) p1, (float) p2, (float) ray00.getOriginNoClone().x);
599             shader.setConstant(&quot;m1&quot;, (float) py0, (float) py1, (float) py2, (float) ray00.getOriginNoClone().y);
600         } else {
601             float m00 = (float) at.getMxx();
602             float m01 = (float) at.getMxy();
603             float m02 = (float) at.getMxt();
604             shader.setConstant(&quot;m0&quot;, m00, m01, m02, 0.0f);
605 
606             float m10 = (float) at.getMyx();
607             float m11 = (float) at.getMyy();
608             float m12 = (float) at.getMyt();
609             shader.setConstant(&quot;m1&quot;, m10, m11, m12, 0.0f);
610 
611             shader.setConstant(&quot;perspVec&quot;, 0.0f, 0.0f, 1.0f);
612         }
613 
614         // clamp the focus point so that it does not rest on, or outside
615         // of, the circumference of the gradient circle
616         fd = (float) Math.min(fd, 0.99f);
617 
618         // pack a few unrelated, precalculated values into a single float4
619         float denom = 1.0f - (fd * fd);
620         float inv_denom = 1.0f / denom;
621         shader.setConstant(&quot;precalc&quot;, fd, denom, inv_denom);
622 
623         setMultiGradient(shader, paint);
624     }
625 
626     static AffineBase getRadialGradientTx(RadialGradient paint,
627                                           Shader shader,
628                                           BaseTransform renderTx,
629                                           float rx, float ry, float rw, float rh)
630     {
631         Affine3D at = scratchXform3D;
632         at.setTransform(renderTx);
633 
634         // save original (untransformed) center and focus points and
635         // adjust to account for proportional attribute if necessary
636         float radius = paint.getRadius();
637         float cx = paint.getCenterX();
638         float cy = paint.getCenterY();
639         float fa = paint.getFocusAngle();
640         float fd = paint.getFocusDistance();
641         if (fd &lt; 0) {
642             fd = -fd;
643             fa = fa+180;
644         }
645         fa = (float) Math.toRadians(fa);
646         if (paint.isProportional()) {
647             float bcx = rx + (rw / 2f);
648             float bcy = ry + (rh / 2f);
649             float scale = Math.min(rw, rh);
650             cx = (cx - 0.5f) * scale + bcx;
651             cy = (cy - 0.5f) * scale + bcy;
652             if (rw != rh &amp;&amp; rw != 0f &amp;&amp; rh != 0f) {
653                 at.translate(bcx, bcy);
654                 at.scale(rw / scale, rh / scale);
655                 at.translate(-bcx, -bcy);
656             }
657             radius = radius * scale;
658         }
659         if (paint.getSpreadMethod() == Gradient.REFLECT) {
660             radius *= 2.0f;
661         }
662 
663         // transform from gradient coords to device coords
664         BaseTransform paintXform = paint.getGradientTransformNoClone();
665         if (paintXform != null) {
666             at.concatenate(paintXform);
667         }
668 
669         // transform unit circle to gradient coords; we start with the
670         // unit circle (center=(0,0), focus on positive x-axis, radius=1)
671         // and then transform into gradient space
672         at.translate(cx, cy);
673         at.rotate(fa);
674         at.scale(radius, radius);
675 
676             // invert to get mapping from device coords to unit circle
677         try {
678             at.invert();
679         } catch (Exception e) {
680             at.setToScale(0.0, 0.0, 0.0);
681         }
682 
683         // clamp the focus point so that it does not rest on, or outside
684         // of, the circumference of the gradient circle
685         fd = (float) Math.min(fd, 0.99f);
686 
687         // pack a few unrelated, precalculated values into a single float4
688         float denom = 1.0f - (fd * fd);
689         float inv_denom = 1.0f / denom;
690         shader.setConstant(&quot;precalc&quot;, fd, denom, inv_denom);
691 
692         setTextureGradient(shader, paint);
693 
694         return at;
695     }
696 
697 /************************** ImagePattern support ****************************/
698 
699     /**
700      * We use the plane equation to automatically
701      * map the ImagePattern image to the geometry being rendered.  The
702      * shader uses two separate plane equations that take the (x,y)
703      * location (in device space) of the fragment being rendered to
704      * calculate (u,v) texture coordinates for that fragment:
705      *     u = Ax + By + Cz + Dw
706      *     v = Ex + Fy + Gz + Hw
707      *
708      * For the 3D case we calculate a perspective vector by projecting rays
709      * at various points, can finding the deltas. So we need to calculate appropriate
710      * values for the plane equation constants (A,B,D) and (E,F,H) such
711      * that {u,v}=0 for the top-left of the ImagePattern&#39;s anchor
712      * rectangle and {u,v}=1 for the bottom-right of the anchor rectangle.
713      * We can easily make the texture image repeat for {u,v} values
714      * outside the range [0,1] by using the fract() instruction within
715      * the shader.
716      *
717      * Calculating the plane equation constants is surprisingly simple.
718      * We can think of it as an inverse matrix operation that takes
719      * device space coordinates and transforms them into user space
720      * coordinates that correspond to a location relative to the anchor
721      * rectangle.  First, we translate and scale the current user space
722      * transform by applying the anchor rectangle bounds.  We then take
723      * the inverse of this affine transform.  The rows of the resulting
724      * inverse matrix correlate nicely to the plane equation constants
725      * we were seeking.
726      */
727 
728     static void setImagePattern(ShaderGraphics g,
729                                 Shader shader,
730                                 ImagePattern paint,
731                                 float rx, float ry, float rw, float rh)
732     {
733         float x1 = rx + (paint.getX() * rw);
734         float y1 = ry + (paint.getY() * rh);
735         float x2 = x1 + (paint.getWidth() * rw);
736         float y2 = y1 + (paint.getHeight() * rh);
737 
738         ResourceFactory rf = g.getResourceFactory();
739         Image img = paint.getImage();
740         Texture paintTex = rf.getCachedTexture(img, Texture.WrapMode.REPEAT);
741         float cx = paintTex.getContentX();
742         float cy = paintTex.getContentY();
743         float cw = paintTex.getContentWidth();
744         float ch = paintTex.getContentHeight();
745         float texw = paintTex.getPhysicalWidth();
746         float texh = paintTex.getPhysicalHeight();
747         paintTex.unlock();
748 
749         // calculate plane equation constants
750         Affine3D at = scratchXform3D;
751         g.getPaintShaderTransform(at);
752 
<a name="2" id="anc2"></a>




753         at.translate(x1, y1);
754         at.scale(x2 - x1, y2 - y1);
755         // Adjustment for case when WrapMode.REPEAT is simulated
756         if (cw &lt; texw) {
757             at.translate(0.5/cw, 0.0);
758             cx += 0.5f;
759         }
760         if (ch &lt; texh) {
761             at.translate(0.0, 0.5/ch);
762             cy += 0.5f;
763         }
764 
765         try {
766             at.invert();
767         } catch (Exception e) {
768             at.setToScale(0.0, 0.0, 0.0);
769         }
770 
771         if (!at.is2D()) {
772             NGCamera cam = g.getCameraNoClone();
773             Vec3d tmpVec = new Vec3d();
774             PickRay tmpvec = new PickRay();
775             PickRay ray00 = project(0,0,cam,at,tmpvec,tmpVec,null);
776             PickRay ray10 = project(1,0,cam,at,tmpvec,tmpVec,null);
777             PickRay ray01 = project(0,1,cam,at,tmpvec,tmpVec,null);
778 
779             double p0 = ray10.getDirectionNoClone().x - ray00.getDirectionNoClone().x;
780             double p1 = ray01.getDirectionNoClone().x - ray00.getDirectionNoClone().x;
781             double p2 = ray00.getDirectionNoClone().x;
782 
783             double py0 = ray10.getDirectionNoClone().y - ray00.getDirectionNoClone().y;
784             double py1 = ray01.getDirectionNoClone().y - ray00.getDirectionNoClone().y;
785             double py2 = ray00.getDirectionNoClone().y;
786 
787             p0 *= -ray00.getOriginNoClone().z;
788             p1 *= -ray00.getOriginNoClone().z;
789             p2 *= -ray00.getOriginNoClone().z;
790 
791             py0 *= -ray00.getOriginNoClone().z;
792             py1 *= -ray00.getOriginNoClone().z;
793             py2 *= -ray00.getOriginNoClone().z;
794 
795             double wv0 = ray10.getDirectionNoClone().z - ray00.getDirectionNoClone().z;
796             double wv1 = ray01.getDirectionNoClone().z - ray00.getDirectionNoClone().z;
797             double wv2 = ray00.getDirectionNoClone().z;
798 
799             shader.setConstant(&quot;perspVec&quot;, (float)wv0, (float)wv1, (float)wv2);
800             shader.setConstant(&quot;xParams&quot;, (float)p0, (float)p1, (float)p2, (float)ray00.getOriginNoClone().x);
801             shader.setConstant(&quot;yParams&quot;, (float)py0, (float)py1, (float)py2, (float)ray00.getOriginNoClone().y);
802         } else {
803             float m00 = (float)at.getMxx();
804             float m01 = (float)at.getMxy();
805             float m02 = (float)at.getMxt();
806             shader.setConstant(&quot;xParams&quot;, m00, m01, m02, 0.0f);
807 
808             float m10 = (float)at.getMyx();
809             float m11 = (float)at.getMyy();
810             float m12 = (float)at.getMyt();
811             shader.setConstant(&quot;yParams&quot;, m10, m11, m12, 0.0f);
812             shader.setConstant(&quot;perspVec&quot;, 0.0f, 0.0f, 1.0f);
813         }
814 
815         cx /= texw;
816         cy /= texh;
817         cw /= texw;
818         ch /= texh;
819         shader.setConstant(&quot;content&quot;, cx, cy, cw, ch);
820     }
821 
822     static AffineBase getImagePatternTx(ShaderGraphics g,
823                                         ImagePattern paint,
824                                         Shader shader,
825                                         BaseTransform renderTx,
826                                         float rx, float ry, float rw, float rh)
827     {
828         float px = paint.getX();
829         float py = paint.getY();
830         float pw = paint.getWidth();
831         float ph = paint.getHeight();
832         if (paint.isProportional()) {
833             px = rx + px * rw;
834             py = ry + py * rh;
835             pw = pw * rw;
836             ph = ph * rh;
837         }
838 
839         ResourceFactory rf = g.getResourceFactory();
840         Image img = paint.getImage();
841         Texture paintTex = rf.getCachedTexture(img, Texture.WrapMode.REPEAT);
842         float cx = paintTex.getContentX();
843         float cy = paintTex.getContentY();
844         float cw = paintTex.getContentWidth();
845         float ch = paintTex.getContentHeight();
846         float texw = paintTex.getPhysicalWidth();
847         float texh = paintTex.getPhysicalHeight();
848         paintTex.unlock();
849 
850         // calculate plane equation constants
851         AffineBase ret;
<a name="3" id="anc3"></a><span class="line-modified">852         if (renderTx.isIdentity()) {</span>

853             Affine2D at = scratchXform2D;
854 
855             at.setToTranslation(px, py);
856             at.scale(pw, ph);
857             ret = at;
858         } else {
859             Affine3D at = scratchXform3D;
860             at.setTransform(renderTx);
<a name="4" id="anc4"></a>
861 
862             at.translate(px, py);
863             at.scale(pw, ph);
864             ret = at;
865         }
866 
867         // Adjustment for case when WrapMode.REPEAT is simulated
868         if (cw &lt; texw) {
869             ret.translate(0.5/cw, 0.0);
870             cx += 0.5f;
871         }
872         if (ch &lt; texh) {
873             ret.translate(0.0, 0.5/ch);
874             cy += 0.5f;
875         }
876 
877         try {
878             ret.invert();
879         } catch (Exception e) {
880             ret = scratchXform2D;
881             scratchXform2D.setToScale(0.0, 0.0);
882         }
883 
884         cx /= texw;
885         cy /= texh;
886         cw /= texw;
887         ch /= texh;
888         shader.setConstant(&quot;content&quot;, cx, cy, cw, ch);
889 
890         return ret;
891     }
892 
893     static PickRay project(float x, float y,
894                            NGCamera cam, BaseTransform inv,
895                            PickRay tmpray, Vec3d tmpvec, Point2D ret)
896     {
897         tmpray = cam.computePickRay(x, y, tmpray);
898         return tmpray.project(inv, cam instanceof NGPerspectiveCamera,
899                                          tmpvec, ret);
900     }
901 
902 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>