<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/java/com/sun/javafx/webkit/prism/WCGraphicsPrismContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.javafx.webkit.prism;
  27 
  28 import com.sun.glass.ui.Screen;
  29 import com.sun.javafx.font.FontStrike;
  30 import com.sun.javafx.font.Metrics;
  31 import com.sun.javafx.font.PGFont;
  32 import com.sun.javafx.geom.*;
  33 import com.sun.javafx.geom.transform.Affine2D;
  34 import com.sun.javafx.geom.transform.Affine3D;
  35 import com.sun.javafx.geom.transform.BaseTransform;
  36 import com.sun.javafx.geom.transform.GeneralTransform3D;
  37 import com.sun.javafx.logging.PlatformLogger;
  38 import com.sun.javafx.logging.PlatformLogger.Level;
  39 import com.sun.javafx.scene.text.GlyphList;
  40 import com.sun.javafx.scene.text.TextLayout;
  41 import com.sun.javafx.sg.prism.*;
  42 import com.sun.javafx.text.TextRun;
  43 import com.sun.prism.*;
  44 import com.sun.prism.paint.Color;
  45 import com.sun.prism.paint.Gradient;
  46 import com.sun.prism.paint.ImagePattern;
  47 import com.sun.prism.paint.Paint;
  48 import com.sun.scenario.effect.*;
  49 import com.sun.scenario.effect.impl.prism.PrDrawable;
  50 import com.sun.scenario.effect.impl.prism.PrEffectHelper;
  51 import com.sun.scenario.effect.impl.prism.PrFilterContext;
  52 import com.sun.webkit.graphics.*;
  53 
  54 import java.nio.ByteBuffer;
  55 import java.nio.ByteOrder;
  56 import java.security.AccessController;
  57 import java.security.PrivilegedAction;
  58 import java.util.ArrayList;
  59 import java.util.List;
  60 
  61 import static com.sun.scenario.effect.Blend.Mode.*;
  62 import com.sun.scenario.effect.impl.Renderer;
  63 import com.sun.scenario.effect.impl.prism.PrRenderer;
  64 
  65 class WCGraphicsPrismContext extends WCGraphicsContext {
  66 
  67     public enum Type {
  68         /**
  69          * Base context associated with the topmost page buffer.
  70          * Created and disposed during a single render pass.
  71          */
  72         PRIMARY,
  73 
  74         /**
  75          * A context associated with a dedicated buffer representing
  76          * a separate render target like canvas, buffered image etc.
  77          * Its life cycle is not limited to a single render pass.
  78          */
  79         DEDICATED
  80     }
  81 
  82     private final static PlatformLogger log =
  83             PlatformLogger.getLogger(WCGraphicsPrismContext.class.getName());
  84     private final static boolean DEBUG_DRAW_CLIP_SHAPE = Boolean.valueOf(
  85             AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt;
  86             System.getProperty(&quot;com.sun.webkit.debugDrawClipShape&quot;, &quot;false&quot;)));
  87 
  88     Graphics baseGraphics;
  89     private BaseTransform baseTransform;
  90 
  91     private final List&lt;ContextState&gt; states = new ArrayList&lt;ContextState&gt;();
  92 
  93     private ContextState state = new ContextState();
  94 
  95     // Cache for getPlatformGraphics
  96     private Graphics cachedGraphics = null;
  97 
  98     private int fontSmoothingType;
  99     private boolean isRootLayerValid = false;
 100 
 101     WCGraphicsPrismContext(Graphics g) {
 102         state.setClip(g.getClipRect());
 103         state.setAlpha(g.getExtraAlpha());
 104         baseGraphics = g;
 105         initBaseTransform(g.getTransformNoClone());
 106     }
 107 
 108     WCGraphicsPrismContext() {
 109     }
 110 
 111     public Type type() {
 112         return Type.PRIMARY;
 113     }
 114 
 115     final void initBaseTransform(BaseTransform t) {
 116         baseTransform = new Affine3D(t);
 117         state.setTransform((Affine3D)baseTransform);
 118     }
 119 
 120     private void resetCachedGraphics() {
 121         cachedGraphics = null;
 122     }
 123 
 124     @Override
 125     public Object getPlatformGraphics() {
 126         return getGraphics(false);
 127     }
 128 
 129     Graphics getGraphics(boolean checkClip) {
 130         if (cachedGraphics == null) {
 131             Layer l = state.getLayerNoClone();
 132             cachedGraphics = (l != null)
 133                     ? l.getGraphics()
 134                     : baseGraphics;
 135 
 136             state.apply(cachedGraphics);
 137 
 138             if (log.isLoggable(Level.FINE)) {
 139                 log.fine(&quot;getPlatformGraphics for &quot; + this + &quot; : &quot; +
 140                          cachedGraphics);
 141             }
 142         }
 143 
 144         Rectangle clip = cachedGraphics.getClipRectNoClone();
 145         return (checkClip &amp;&amp; clip!=null &amp;&amp; clip.isEmpty())
 146             ? null
 147             : cachedGraphics;
 148     }
 149 
 150     public void saveState()
 151     {
 152         state.markAsRestorePoint();
 153         saveStateInternal();
 154     }
 155 
 156     private void saveStateInternal()
 157     {
 158         states.add(state);
 159         state = state.clone();
 160     }
 161 
 162     private void startNewLayer(Layer layer) {
 163         saveStateInternal();
 164 
 165         // layer has the same bounds as clip, so we have to translate
 166         Rectangle clip = state.getClipNoClone();
 167 
 168         //left-side (post-) translate.
 169         //NB! an order of transforms is essential!
 170         Affine3D newTr = new Affine3D(BaseTransform.getTranslateInstance(
 171                 -clip.x,
 172                 -clip.y));
 173         newTr.concatenate(state.getTransformNoClone());
 174 
 175         //move clip to (0, 0) - start of texture
 176         clip.x = 0;
 177         clip.y = 0;
 178         //no-clone - no-set!
 179 
 180         Graphics g = getGraphics(true);
 181         if (g != null &amp;&amp; g != baseGraphics) {
 182             layer.init(g);
 183         }
 184 
 185         state.setTransform(newTr);
 186         state.setLayer(layer);
 187 
 188         resetCachedGraphics();
 189     }
 190 
 191     private void renderLayer(final Layer layer) {
 192         WCTransform cur = getTransform();
 193 
 194         //translate to (layer.getX(), layer.getY())
 195         setTransform(new WCTransform(
 196             1.0, 0.0,
 197             0.0, 1.0,
 198             layer.getX(), layer.getY()));
 199 
 200         // composite drawing delegated to the layer rendering
 201         Graphics g = getGraphics(true);
 202         if (g != null) {
 203             layer.render(g);
 204         }
 205 
 206         //restore transform
 207         setTransform(cur);
 208     }
 209 
 210     private void restoreStateInternal() {
 211         int size = states.size();
 212         if (size == 0) {
 213             assert false: &quot;Unbalanced restoreState&quot;;
 214             return;
 215         }
 216 
 217         Layer layer = state.getLayerNoClone();
 218         state = states.remove(size - 1);
 219         if (layer != state.getLayerNoClone()) {
 220             renderLayer(layer);
 221             layer.dispose();
 222             if (log.isLoggable(Level.FINE)) {
 223                 log.fine(&quot;Popped layer &quot; + layer);
 224             }
 225         } else {
 226             resetCachedGraphics();
 227         }
 228     }
 229 
 230     public void restoreState()
 231     {
 232         log.fine(&quot;restoring state&quot;);
 233         do {
 234             restoreStateInternal();
 235         } while ( !state.isRestorePoint() );
 236     }
 237 
 238     /**
 239      *  Renders all layers to the underlaying Graphics, but preserves the
 240      *  current state and the states stack
 241      */
 242     private void flushAllLayers() {
 243         if (state == null) {
 244             // context disposed
 245             return;
 246         }
 247 
 248         if (isRootLayerValid) {
 249             log.fine(&quot;FlushAllLayers: root layer is valid, skipping&quot;);
 250             return;
 251         }
 252 
 253         if (log.isLoggable(Level.FINE)) {
 254             log.fine(&quot;FlushAllLayers&quot;);
 255         }
 256 
 257         ContextState currentState = state;
 258 
 259         for (int i = states.size() - 1; i &gt;=0; i--) {
 260             Layer layer = state.getLayerNoClone();
 261             state = states.get(i);
 262             if (layer != state.getLayerNoClone()) {
 263                 renderLayer(layer);
 264             } else {
 265                 resetCachedGraphics();
 266             }
 267         }
 268 
 269         Layer layer = state.getLayerNoClone();
 270         if (layer != null) {
 271             renderLayer(layer);
 272         }
 273 
 274         state = currentState;
 275         isRootLayerValid = true;
 276     }
 277 
 278 
 279     public void dispose() {
 280         if (!states.isEmpty()) {
 281             log.fine(&quot;Unbalanced saveState/restoreState&quot;);
 282         }
 283         for (ContextState state: states) {
 284             if (state.getLayerNoClone() != null) {
 285                 state.getLayerNoClone().dispose();
 286             }
 287         }
 288         states.clear();
 289 
 290         if (state != null &amp;&amp; state.getLayerNoClone() != null) {
 291             state.getLayerNoClone().dispose();
 292         }
 293         state = null;
 294     }
 295 
 296 
 297     public void setClip(WCPath path, boolean isOut) {
 298         Affine3D tr = new Affine3D(state.getTransformNoClone());
 299         path.transform(
 300                 tr.getMxx(), tr.getMyx(),
 301                 tr.getMxy(), tr.getMyy(),
 302                 tr.getMxt(), tr.getMyt());
 303         //path now is in node coordinates, as well as clip
 304 
 305         if (!isOut) {
 306             WCRectangle pathBounds = path.getBounds();
 307 
 308             // path bounds could be fractional so &#39;inclusive&#39; rounding
 309             // is used for determining clip rectangle
 310             int pixelX = (int) Math.floor(pathBounds.getX());
 311             int pixelY = (int) Math.floor(pathBounds.getY());
 312             int pixelW = (int) Math.ceil(pathBounds.getMaxX()) - pixelX;
 313             int pixelH = (int) Math.ceil(pathBounds.getMaxY()) - pixelY;
 314 
 315             state.clip(new Rectangle(pixelX, pixelY, pixelW, pixelH));
 316         }
 317 
 318         Rectangle clip = state.getClipNoClone();
 319 
 320         if (isOut) {
 321             path.addRect(clip.x, clip.y, clip.width, clip.height);
 322             //Out clip path is always EVENODD.
 323         }
 324 
 325         path.translate(-clip.x, -clip.y);
 326 
 327         Layer layer = new ClipLayer(
 328             getGraphics(false), clip, path, type() == Type.DEDICATED);
 329 
 330         startNewLayer(layer);
 331 
 332         if (log.isLoggable(Level.FINE)) {
 333             log.fine(&quot;setClip(WCPath &quot; + path.getID() + &quot;)&quot;);
 334             log.fine(&quot;Pushed layer &quot; + layer);
 335         }
 336     }
 337 
 338     private Rectangle transformClip(Rectangle localClip) {
 339         if (localClip==null) {
 340             return null;
 341         }
 342 
 343         float[] points = new float[] {
 344             localClip.x, localClip.y,
 345             localClip.x + localClip.width, localClip.y,
 346             localClip.x, localClip.y + localClip.height,
 347             localClip.x  + localClip.width, localClip.y + localClip.height};
 348         state.getTransformNoClone().transform(points, 0, points, 0, 4);
 349         float minX = Math.min(
 350                points[0], Math.min(
 351                points[2], Math.min(
 352                points[4], points[6])));
 353         float maxX = Math.max(
 354                points[0], Math.max(
 355                points[2], Math.max(
 356                points[4], points[6])));
 357         float minY = Math.min(
 358                points[1], Math.min(
 359                points[3], Math.min(
 360                points[5], points[7])));
 361         float maxY = Math.max(
 362                points[1], Math.max(
 363                points[3], Math.max(
 364                points[5], points[7])));
 365         return new Rectangle(new RectBounds(minX, minY, maxX, maxY));
 366 
 367 /* #1 loose rotate
 368         state.getTransformNoClone().transform(localClip, localClip);
 369 */
 370 /* #2 problem with negative coordinates
 371         RectBounds rb = TransformedShape.transformedShape(
 372             new RoundRectangle2D(localClip.x, localClip.y, localClip.width, localClip.height, 0, 0),
 373             state.getTransformNoClone()).getBounds();
 374         return rb.isEmpty()
 375             ? null
 376             : new Rectangle(rb);
 377  */
 378     }
 379 
 380     private void setClip(Rectangle shape) {
 381         Affine3D tr = state.getTransformNoClone();
 382         if (tr.getMxy() == 0 &amp;&amp; tr.getMxz() == 0
 383          &amp;&amp; tr.getMyx() == 0 &amp;&amp; tr.getMyz() == 0
 384          &amp;&amp; tr.getMzx() == 0 &amp;&amp; tr.getMzy() == 0) {
 385             //There is no rotation here: scale + translation.
 386             //Fast &amp; easy!
 387             state.clip(transformClip(shape));
 388             if (log.isLoggable(Level.FINE)) {
 389                 log.fine(&quot;setClip({0})&quot;, shape);
 390             }
 391             if (DEBUG_DRAW_CLIP_SHAPE) {
 392                 //Draw clip shape
 393                 Rectangle rc = state.getClipNoClone();
 394                 if (rc != null &amp;&amp; rc.width &gt;= 2 &amp;&amp; rc.height &gt;= 2) {
 395                     WCTransform cur = getTransform();
 396                     //translate to (layer.getX(), layer.getY())
 397                     setTransform(new WCTransform(
 398                         1.0, 0.0,
 399                         0.0, 1.0,
 400                         0.0, 0.0));
 401 
 402                     Graphics g2d = getGraphics(true);
 403                     if (g2d != null) {
 404                         float fbase = (float)Math.random();
 405                         g2d.setPaint(new Color(
 406                                 fbase,
 407                                 1f - fbase,
 408                                 0.5f,
 409                                 0.1f));
 410                         g2d.setStroke(new BasicStroke());
 411                         g2d.fillRect(rc.x, rc.y, rc.width, rc.height);
 412 
 413                         g2d.setPaint(new Color(
 414                                 1f - fbase,
 415                                 fbase,
 416                                 0.5f,
 417                                 1f));
 418                         g2d.drawRect(rc.x, rc.y, rc.width, rc.height);
 419                     }
 420                     //restore transform
 421                     setTransform(cur);
 422                     state.clip(new Rectangle(rc.x+1, rc.y+1, rc.width-2, rc.height-2));
 423                 }
 424             }
 425             if (cachedGraphics != null) {
 426                 cachedGraphics.setClipRect(state.getClipNoClone());
 427             }
 428         } else {
 429             //twisted axis set
 430             WCPath path = new WCPathImpl();
 431             path.addRect(shape.x, shape.y, shape.width, shape.height);
 432             setClip(path, false);
 433         }
 434     }
 435 
 436     public void setClip(int cx, int cy, int cw, int ch) {
 437         setClip(new Rectangle(cx, cy, cw, ch));
 438     }
 439 
 440     public void setClip(WCRectangle c) {
 441         setClip(new Rectangle((int)c.getX(), (int)c.getY(),
 442                               (int)c.getWidth(), (int)c.getHeight()));
 443     }
 444 
 445     public WCRectangle getClip() {
 446         Rectangle r = state.getClipNoClone();
 447         return r == null ? null : new WCRectangle(r.x, r.y, r.width, r.height);
 448     }
 449 
 450     protected Rectangle getClipRectNoClone() {
 451         return state.getClipNoClone();
 452     }
 453 
 454     protected Affine3D getTransformNoClone() {
 455         return state.getTransformNoClone();
 456     }
 457 
 458     public void translate(float x, float y) {
 459         if (log.isLoggable(Level.FINE)) {
 460             log.fine(&quot;translate({0},{1})&quot;, new Object[] {x, y});
 461         }
 462         state.translate(x, y);
 463         if (cachedGraphics != null) {
 464             cachedGraphics.translate(x, y);
 465         }
 466     }
 467 
 468     public void scale(float sx, float sy) {
 469         if (log.isLoggable(Level.FINE)) {
 470             log.fine(&quot;scale(&quot; + sx + &quot; &quot; + sy + &quot;)&quot;);
 471         }
 472         state.scale(sx, sy);
 473         if (cachedGraphics != null) {
 474             cachedGraphics.scale(sx, sy);
 475         }
 476     }
 477 
 478     public void rotate(float radians) {
 479         if (log.isLoggable(Level.FINE)) {
 480             log.fine(&quot;rotate(&quot; + radians + &quot;)&quot;);
 481         }
 482         state.rotate(radians);
 483         if (cachedGraphics != null) {
 484             cachedGraphics.setTransform(state.getTransformNoClone());
 485         }
 486     }
 487 
 488     // overriden in WCBufferedContext
 489     protected boolean shouldRenderRect(float x, float y, float w, float h,
 490                                        DropShadow shadow, BasicStroke stroke)
 491     {
 492         return true;
 493     }
 494 
 495     // overriden in WCBufferedContext
 496     protected boolean shouldRenderShape(Shape shape, DropShadow shadow, BasicStroke stroke) {
 497         return true;
 498     }
 499 
 500     // overriden in WCBufferedContext
 501     protected boolean shouldCalculateIntersection() {
 502         return false;
 503     }
 504 
 505     @Override
 506     public void fillRect(final float x, final float y, final float w, final float h, final Integer rgba) {
 507         if (log.isLoggable(Level.FINE)) {
 508             String format = (rgba != null)
 509                     ? &quot;fillRect(%f, %f, %f, %f, 0x%x)&quot;
 510                     : &quot;fillRect(%f, %f, %f, %f, null)&quot;;
 511             log.fine(String.format(format, x, y, w, h, rgba));
 512         }
 513         if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
 514             return;
 515         }
 516         new Composite() {
 517             @Override void doPaint(Graphics g) {
 518                 Paint paint = (rgba != null) ? createColor(rgba) : state.getPaintNoClone();
 519                 DropShadow shadow = state.getShadowNoClone();
 520                 // TextureMapperJava::drawSolidColor calls fillRect with perspective
 521                 // projection.
 522                 if (shadow != null || !state.getPerspectiveTransformNoClone().isIdentity()) {
 523                     final NGRectangle node = new NGRectangle();
 524                     node.updateRectangle(x, y, w, h, 0, 0);
 525                     render(g, shadow, paint, null, node);
 526                 } else {
 527                     g.setPaint(paint);
 528                     g.fillRect(x, y, w, h);
 529                 }
 530             }
 531         }.paint();
 532     }
 533 
 534     @Override
 535     public void fillRoundedRect(final float x, final float y, final float w, final float h,
 536         final float topLeftW, final float topLeftH, final float topRightW, final float topRightH,
 537         final float bottomLeftW, final float bottomLeftH, final float bottomRightW, final float bottomRightH,
 538         final int rgba)
 539     {
 540         if (log.isLoggable(Level.FINE)) {
 541             log.fine(String.format(&quot;fillRoundedRect(%f, %f, %f, %f, &quot;
 542                     + &quot;%f, %f, %f, %f, %f, %f, %f, %f, 0x%x)&quot;,
 543                     x, y, w, h, topLeftW, topLeftH, topRightW, topRightH,
 544                     bottomLeftW, bottomLeftH, bottomRightW, bottomRightH, rgba));
 545         }
 546         if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
 547             return;
 548         }
 549         new Composite() {
 550             @Override void doPaint(Graphics g) {
 551                 // Prism only supports single arcWidth/Height.
 552                 // We work around by calculating average width and height here
 553 
 554                 float arcW = (topLeftW + topRightW + bottomLeftW + bottomRightW) / 2;
 555                 float arcH = (topLeftH + topRightH + bottomLeftH + bottomRightH) / 2;
 556 
 557                 Paint paint = createColor(rgba);
 558                 DropShadow shadow = state.getShadowNoClone();
 559                 if (shadow != null) {
 560                     final NGRectangle node = new NGRectangle();
 561                     node.updateRectangle(x, y, w, h, arcW, arcH);
 562                     render(g, shadow, paint, null, node);
 563                 } else {
 564                     g.setPaint(paint);
 565                     g.fillRoundRect(x, y, w, h, arcW, arcH);
 566                 }
 567             }
 568         }.paint();
 569     }
 570 
 571     @Override
 572     public void clearRect(final float x, final float y, final float w, final float h) {
 573         if (log.isLoggable(Level.FINE)) {
 574             log.fine(String.format(&quot;clearRect(%f, %f, %f, %f)&quot;, x, y, w, h));
 575         }
 576         if (shouldCalculateIntersection()) {
 577             // No intersection is applicable for clearRect.
 578             return;
 579         }
 580         new Composite() {
 581             @Override void doPaint(Graphics g) {
 582                 g.clearQuad(x, y, x + w, y + h);
 583             }
 584         }.paint();
 585     }
 586 
 587     @Override
 588     public void setFillColor(int rgba) {
 589         if (log.isLoggable(Level.FINE)) {
 590             log.fine(String.format(&quot;setFillColor(0x%x)&quot;, rgba));
 591         }
 592         state.setPaint(createColor(rgba));
 593     }
 594 
 595     @Override
 596     public void setFillGradient(WCGradient gradient) {
 597         if (log.isLoggable(Level.FINE)) {
 598             log.fine(&quot;setFillGradient(&quot; + gradient + &quot;)&quot;);
 599         }
 600         state.setPaint((Gradient) gradient.getPlatformGradient());
 601     }
 602 
 603     @Override
 604     public void setTextMode(boolean fill, boolean stroke, boolean clip) {
 605         if (log.isLoggable(Level.FINE)) {
 606             log.fine(&quot;setTextMode(fill:&quot; + fill + &quot;,stroke:&quot; + stroke + &quot;,clip:&quot; + clip + &quot;)&quot;);
 607         }
 608         state.setTextMode(fill, stroke, clip);
 609     }
 610 
 611     @Override
 612     public void setFontSmoothingType(int fontSmoothingType) {
 613         this.fontSmoothingType = fontSmoothingType;
 614     }
 615 
 616     @Override
 617     public int getFontSmoothingType() {
 618         return fontSmoothingType;
 619     }
 620 
 621     @Override
 622     public void setStrokeStyle(int style) {
 623         if (log.isLoggable(Level.FINE)) {
 624             log.fine(&quot;setStrokeStyle({0})&quot;, style);
 625         }
 626         state.getStrokeNoClone().setStyle(style);
 627     }
 628 
 629     @Override
 630     public void setStrokeColor(int rgba) {
 631         if (log.isLoggable(Level.FINE)) {
 632             log.fine(String.format(&quot;setStrokeColor(0x%x)&quot;, rgba));
 633         }
 634         state.getStrokeNoClone().setPaint(createColor(rgba));
 635     }
 636 
 637     @Override
 638     public void setStrokeWidth(float width) {
 639         if (log.isLoggable(Level.FINE)) {
 640             log.fine(&quot;setStrokeWidth({0})&quot;, new Object[] { width });
 641         }
 642         state.getStrokeNoClone().setThickness(width);
 643     }
 644 
 645     @Override
 646     public void setStrokeGradient(WCGradient gradient) {
 647         if (log.isLoggable(Level.FINE)) {
 648             log.fine(&quot;setStrokeGradient(&quot; + gradient + &quot;)&quot;);
 649         }
 650         state.getStrokeNoClone().setPaint((Gradient) gradient.getPlatformGradient());
 651     }
 652 
 653     @Override
 654     public void setLineDash(float offset, float... sizes) {
 655         if (log.isLoggable(Level.FINE)) {
 656             StringBuilder s = new StringBuilder(&quot;[&quot;);
 657             for (int i=0; i &lt; sizes.length; i++) {
 658                 s.append(sizes[i]).append(&#39;,&#39;);
 659             }
 660             s.append(&#39;]&#39;);
 661             log.fine(&quot;setLineDash({0},{1}&quot;, new Object[] {offset, s});
 662         }
 663         state.getStrokeNoClone().setDashOffset(offset);
 664         if (sizes != null) {
 665             boolean allZero = true;
 666             for (int i = 0; i &lt; sizes.length; i++) {
 667                 if (sizes[i] != 0) {
 668                     allZero = false;
 669                     break;
 670                 }
 671             }
 672             if (allZero) {
 673                 sizes = null;
 674             }
 675         }
 676         state.getStrokeNoClone().setDashSizes(sizes);
 677     }
 678 
 679     @Override
 680     public void setLineCap(int lineCap) {
 681         if (log.isLoggable(Level.FINE)) {
 682             log.fine(&quot;setLineCap(&quot; + lineCap + &quot;)&quot;);
 683         }
 684         state.getStrokeNoClone().setLineCap(lineCap);
 685     }
 686 
 687     @Override
 688     public void setLineJoin(int lineJoin) {
 689         if (log.isLoggable(Level.FINE)) {
 690             log.fine(&quot;setLineJoin(&quot; + lineJoin + &quot;)&quot;);
 691         }
 692         state.getStrokeNoClone().setLineJoin(lineJoin);
 693     }
 694 
 695     @Override
 696     public void setMiterLimit(float miterLimit) {
 697         if (log.isLoggable(Level.FINE)) {
 698             log.fine(&quot;setMiterLimit(&quot; + miterLimit + &quot;)&quot;);
 699         }
 700         state.getStrokeNoClone().setMiterLimit(miterLimit);
 701     }
 702 
 703     @Override
 704     public void setShadow(float dx, float dy, float blur, int rgba) {
 705         if (log.isLoggable(Level.FINE)) {
 706             String format = &quot;setShadow(%f, %f, %f, 0x%x)&quot;;
 707             log.fine(String.format(format, dx, dy, blur, rgba));
 708         }
 709         state.setShadow(createShadow(dx, dy, blur, rgba));
 710     }
 711 
 712     @Override
 713     public void drawPolygon(final WCPath path, final boolean shouldAntialias) {
 714         if (log.isLoggable(Level.FINE)) {
 715             log.fine(&quot;drawPolygon({0})&quot;,
 716                     new Object[] {shouldAntialias});
 717         }
 718         if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(), null,
 719                                 state.getStrokeNoClone().getPlatformStroke()))
 720         {
 721             return;
 722         }
 723         new Composite() {
 724             @Override void doPaint(Graphics g) {
 725                 Path2D p2d = (Path2D) path.getPlatformPath();
 726                 g.setPaint(state.getPaintNoClone());
 727                 g.fill(p2d);
 728                 if (state.getStrokeNoClone().apply(g)) {
 729                     g.draw(p2d);
 730                 }
 731             }
 732         }.paint();
 733     }
 734 
 735     @Override
 736     public void drawLine(final int x0, final int y0, final int x1, final int y1) {
 737         if (log.isLoggable(Level.FINE)) {
 738             log.fine(&quot;drawLine({0}, {1}, {2}, {3})&quot;,
 739                     new Object[] {x0, y0, x1, y1});
 740         }
 741         Line2D line = new Line2D(x0, y0, x1, y1);
 742         if (!shouldRenderShape(line, null, state.getStrokeNoClone().getPlatformStroke())) {
 743             return;
 744         }
 745         new Composite() {
 746             @Override void doPaint(Graphics g) {
 747                 if (state.getStrokeNoClone().apply(g)) {
 748                     g.drawLine(x0, y0, x1, y1);
 749                 }
 750             }
 751         }.paint();
 752     }
 753 
 754     @Override
 755     public void drawPattern(
 756         final WCImage texture,
 757         final WCRectangle srcRect,
 758         final WCTransform patternTransform,
 759         final WCPoint phase,
 760         final WCRectangle destRect)
 761     {
 762         if (log.isLoggable(Level.FINE)) {
 763             log.fine(&quot;drawPattern({0}, {1}, {2}, {3})&quot;,
 764                     new Object[] {destRect.getIntX(), destRect.getIntY(),
 765                                   destRect.getIntWidth(),
 766                                   destRect.getIntHeight()});
 767         }
 768         if (!shouldRenderRect(destRect.getX(), destRect.getY(),
 769                               destRect.getWidth(), destRect.getHeight(), null, null))
 770         {
 771             return;
 772         }
 773         if (texture != null) {
 774             new Composite() {
 775                 @Override void doPaint(Graphics g) {
 776                     Image img = ((PrismImage)texture).getImage();
 777 
 778                     // Create subImage only if srcRect doesn&#39;t fit the texture bounds. See RT-20193.
 779                     if (!srcRect.contains(new WCRectangle(0, 0, texture.getWidth(), texture.getHeight()))) {
 780 
 781                         img = img.createSubImage(srcRect.getIntX(),
 782                                                  srcRect.getIntY(),
 783                                                  (int)Math.ceil(srcRect.getWidth()),
 784                                                  (int)Math.ceil(srcRect.getHeight()));
 785                     }
 786 
 787                     double m[] = patternTransform.getMatrix();
 788                     Affine3D at = new Affine3D();
 789                     at.translate(phase.getX(), phase.getY());
 790                     at.concatenate(m[0], m[1], m[4], m[2], m[3], m[5]);
 791 
 792                     g.setPaint(new ImagePattern(
 793                                img,
 794                                srcRect.getX(), srcRect.getY(),
 795                                srcRect.getWidth(), srcRect.getHeight(),
 796                                at, false, false));
 797 
 798                     g.fillRect(destRect.getX(), destRect.getY(),
 799                                destRect.getWidth(), destRect.getHeight());
 800                 }
 801             }.paint();
 802         }
 803     }
 804 
 805     @Override
 806     public void drawImage(final WCImage img,
 807                           final float dstx, final float dsty, final float dstw, final float dsth,
 808                           final float srcx, final float srcy, final float srcw, final float srch)
 809     {
 810         if (log.isLoggable(Level.FINE)){
 811             log.fine(&quot;drawImage(img, dst({0},{1},{2},{3}), &quot; +
 812                     &quot;src({4},{5},{6},{7}))&quot;,
 813                     new Object[] {dstx, dsty, dstw, dsth,
 814                                   srcx, srcy, srcw, srch});
 815         }
 816         if (!shouldRenderRect(dstx, dsty, dstw, dsth, state.getShadowNoClone(), null)) {
 817             return;
 818         }
 819         if (img instanceof PrismImage) {
 820             new Composite() {
 821                 @Override void doPaint(Graphics g) {
 822                     PrismImage pi = (PrismImage) img;
 823                     DropShadow shadow = state.getShadowNoClone();
 824                     if (shadow != null) {
 825                         NGImageView node = new NGImageView();
 826                         node.setImage(pi.getImage());
 827                         node.setX(dstx);
 828                         node.setY(dsty);
 829                         node.setViewport(srcx, srcy, srcw, srch, dstw, dsth);
 830                         node.setContentBounds(new RectBounds(dstx, dsty, dstx + dstw, dsty + dsth));
 831                         render(g, shadow, null, null, node);
 832                     } else {
 833                         pi.draw(g,
 834                                 (int) dstx, (int) dsty,
 835                                 (int) (dstx + dstw), (int) (dsty + dsth),
 836                                 (int) srcx, (int) srcy,
 837                                 (int) (srcx + srcw), (int) (srcy + srch));
 838                     }
 839                 }
 840             }.paint();
 841         }
 842     }
 843 
 844     @Override
 845     public void drawBitmapImage(final ByteBuffer image, final int x, final int y, final int w, final int h) {
 846         if (!shouldRenderRect(x, y, w, h, null, null)) {
 847             return;
 848         }
 849         new Composite() {
 850             @Override void doPaint(Graphics g) {
 851                 image.order(ByteOrder.nativeOrder());
 852                 Image img = Image.fromByteBgraPreData(image, w, h);
 853                 ResourceFactory rf = g.getResourceFactory();
 854                 Texture txt = rf.createTexture(img, Texture.Usage.STATIC, Texture.WrapMode.REPEAT);
 855                 g.drawTexture(txt, x, y, x + w, y + h, 0, 0, w, h);
 856                 txt.dispose();
 857             }
 858         }.paint();
 859     }
 860 
 861     @Override
 862     public void drawIcon(WCIcon icon, int x, int y) {
 863         if (log.isLoggable(Level.FINE)) {
 864             log.fine(&quot;UNIMPLEMENTED drawIcon ({0}, {1})&quot;,
 865                     new Object[] {x, y});
 866         }
 867     }
 868 
 869     @Override
 870     public void drawRect(final int x, final int y, final int w, final int h) {
 871         if (log.isLoggable(Level.FINE)) {
 872             log.fine(&quot;drawRect({0}, {1}, {2}, {3})&quot;,
 873                     new Object[]{x, y, w, h});
 874         }
 875         if (!shouldRenderRect(x, y, w, h,
 876                               null, state.getStrokeNoClone().getPlatformStroke()))
 877         {
 878             return;
 879         }
 880         new Composite() {
 881             @Override void doPaint(Graphics g) {
 882                 Paint c = state.getPaintNoClone();
 883                 if (c != null &amp;&amp; c.isOpaque()) {
 884                     g.setPaint(c);
 885                     g.fillRect(x, y, w, h);
 886                 }
 887 
 888                 if (state.getStrokeNoClone().apply(g)) {
 889                     g.drawRect(x, y, w, h);
 890                 }
 891             }
 892         }.paint();
 893     }
 894 
 895     @Override
 896     public void drawString(final WCFont f, final int[] glyphs,
 897                            final float[] advances, final float x, final float y)
 898     {
 899         if (log.isLoggable(Level.FINE)) {
 900             log.fine(String.format(
 901                     &quot;Drawing %d glyphs @(%.1f, %.1f)&quot;,
 902                     glyphs.length, x, y));
 903         }
 904         PGFont font = (PGFont)f.getPlatformFont();
 905         TextRun gl = TextUtilities.createGlyphList(glyphs, advances, x, y);
 906 
 907         DropShadow shadow = state.getShadowNoClone();
 908         BasicStroke stroke = state.isTextStroke()
 909                 ? state.getStrokeNoClone().getPlatformStroke()
 910                 : null;
 911 
 912         final FontStrike strike = font.getStrike(getTransformNoClone(), getFontSmoothingType());
 913         if (shouldCalculateIntersection()) {
 914             Metrics m = strike.getMetrics();
 915             gl.setMetrics(m.getAscent(), m.getDescent(), m.getLineGap());
 916             if (!shouldRenderRect(x, y, gl.getWidth(), gl.getHeight(), shadow, stroke)) {
 917                 return;
 918             }
 919         }
 920         new Composite() {
 921             @Override void doPaint(Graphics g) {
 922                 Paint paint = state.isTextFill()
 923                         ? state.getPaintNoClone()
 924                         : null;
 925                 if (shadow != null) {
 926                     final NGText span = new NGText();
 927                     span.setGlyphs(new GlyphList[] {gl});
 928                     span.setFont(font);
 929                     span.setFontSmoothingType(fontSmoothingType);
 930                     render(g, shadow, paint, stroke, span);
 931                 } else {
 932                     if (paint != null) {
 933                         g.setPaint(paint);
 934                         g.drawString(gl, strike, x, y, null, 0, 0);
 935                     }
 936                     if (stroke != null) {
 937                         paint = state.getStrokeNoClone().getPaint();
 938                         if (paint != null) {
 939                             g.setPaint(paint);
 940                             g.setStroke(stroke);
 941                             g.draw(strike.getOutline(gl, BaseTransform.getTranslateInstance(x, y)));
 942                         }
 943                     }
 944                 }
 945             }
 946         }.paint();
 947     }
 948 
 949     @Override public void drawString(WCFont f, String str, boolean rtl,
 950             int from, int to, float x, float y)
 951     {
 952         if (log.isLoggable(Level.FINE)) {
 953             log.fine(String.format(
 954                     &quot;str=&#39;%s&#39; (length=%d), from=%d, to=%d, rtl=%b, @(%.1f, %.1f)&quot;,
 955                     str, str.length(), from, to, rtl, x, y));
 956         }
 957         TextLayout layout = TextUtilities.createLayout(
 958                 str.substring(from, to), f.getPlatformFont());
 959         int count = 0;
 960         GlyphList[] runs = layout.getRuns();
 961         for (GlyphList run: runs) {
 962             count += run.getGlyphCount();
 963         }
 964 
 965         int[] glyphs = new int[count];
 966         float[] adv = new float[count];
 967         count = 0;
 968         for (GlyphList run: layout.getRuns()) {
 969             int gc = run.getGlyphCount();
 970             for (int i = 0; i &lt; gc; i++) {
 971                 glyphs[count] = run.getGlyphCode(i);
 972                 adv[count] = run.getPosX(i + 1) - run.getPosX(i);
 973                 count++;
 974             }
 975         }
 976 
 977         // adjust x coordinate (see RT-29908)
 978         if (rtl) {
 979             x += (TextUtilities.getLayoutWidth(str.substring(from), f.getPlatformFont()) -
 980                   layout.getBounds().getWidth());
 981         } else {
 982             x += TextUtilities.getLayoutWidth(str.substring(0, from), f.getPlatformFont());
 983         }
 984         drawString(f, glyphs, adv, x, y);
 985     }
 986 
 987     @Override
 988     public void setComposite(int composite) {
 989         log.fine(&quot;setComposite({0})&quot;, composite);
 990         state.setCompositeOperation(composite);
 991     }
 992 
 993     @Override
 994     public void drawEllipse(final int x, final int y, final int w, final int h) {
 995         if (log.isLoggable(Level.FINE)) {
 996             log.fine(&quot;drawEllipse({0}, {1}, {2}, {3})&quot;,
 997                     new Object[] { x, y, w, h});
 998         }
 999         if (!shouldRenderRect(x, y, w, h,
1000                               null, state.getStrokeNoClone().getPlatformStroke()))
1001         {
1002             return;
1003         }
1004         new Composite() {
1005             @Override void doPaint(Graphics g) {
1006                 g.setPaint(state.getPaintNoClone());
1007                 g.fillEllipse(x, y, w, h);
1008                 if (state.getStrokeNoClone().apply(g)) {
1009                     g.drawEllipse(x, y, w, h);
1010                 }
1011             }
1012         }.paint();
1013     }
1014 
1015     private final static BasicStroke focusRingStroke =
1016         new BasicStroke(1.1f, BasicStroke.CAP_BUTT,
1017                          BasicStroke.JOIN_ROUND, 0.0f,
1018                          new float[] {1.0f}, 0.0f);
1019 
1020     @Override
1021     public void drawFocusRing(final int x, final int y, final int w, final int h, final int rgba) {
1022         if (log.isLoggable(Level.FINE)) {
1023             log.fine(String.format(&quot;drawFocusRing: %d, %d, %d, %d, 0x%x&quot;, x, y, w, h, rgba));
1024         }
1025         if (!shouldRenderRect(x, y, w, h, null, focusRingStroke)) {
1026             return;
1027         }
1028         new Composite() {
1029             @Override void doPaint(Graphics g) {
1030                 g.setPaint(createColor(rgba));
1031                 BasicStroke stroke = g.getStroke();
1032                 g.setStroke(focusRingStroke);
1033                 g.drawRoundRect(x, y, w, h, 4, 4);
1034                 g.setStroke(stroke);
1035             }
1036         }.paint();
1037     }
1038 
1039     public void setAlpha(float alpha) {
1040         log.fine(&quot;setAlpha({0})&quot;, alpha);
1041 
1042         state.setAlpha(alpha);
1043 
1044         if (null != cachedGraphics) {
1045             cachedGraphics.setExtraAlpha(state.getAlpha());
1046         }
1047     }
1048 
1049     public float getAlpha() {
1050         return state.getAlpha();
1051     }
1052 
1053     @Override public void beginTransparencyLayer(float opacity) {
1054         TransparencyLayer layer = new TransparencyLayer(
1055                 getGraphics(false), state.getClipNoClone(), opacity);
1056 
1057         if (log.isLoggable(Level.FINE)) {
1058             log.fine(String.format(&quot;beginTransparencyLayer(%s)&quot;, layer));
1059         }
1060 
1061         //[saveStateIntertal] will work as [saveState]
1062         state.markAsRestorePoint();
1063 
1064         startNewLayer(layer);
1065     }
1066 
1067     @Override public void endTransparencyLayer() {
1068         if (log.isLoggable(Level.FINE)) {
1069             log.fine(String.format(&quot;endTransparencyLayer(%s)&quot;, state.getLayerNoClone()));
1070         }
1071 
1072         //pair to [startNewLayer] that works as [saveState] call
1073         restoreState();
1074     }
1075 
1076     @Override
1077     public void drawWidget(final RenderTheme theme, final Ref widget, final int x, final int y) {
1078         WCSize s = theme.getWidgetSize(widget);
1079         if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
1080             return;
1081         }
1082         new Composite() {
1083             @Override void doPaint(Graphics g) {
1084                 theme.drawWidget(WCGraphicsPrismContext.this, widget, x, y);
1085             }
1086         }.paint();
1087     }
1088 
1089     @Override
1090     public void drawScrollbar(final ScrollBarTheme theme, final Ref widget, int x, int y,
1091                               int pressedPart, int hoveredPart)
1092     {
1093         if (log.isLoggable(Level.FINE)) {
1094             log.fine(String.format(&quot;drawScrollbar(%s, %s, x = %d, y = %d)&quot;, theme, widget, x, y));
1095         }
1096 
1097         WCSize s = theme.getWidgetSize(widget);
1098         if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
1099             return;
1100         }
1101         new Composite() {
1102             @Override void doPaint(Graphics g) {
1103                 theme.paint(WCGraphicsPrismContext.this, widget, x, y, pressedPart, hoveredPart);
1104             }
1105         }.paint();
1106     }
1107 
1108     private static Rectangle intersect(Rectangle what, Rectangle with) {
1109         if (what == null) {
1110             return with;
1111         }
1112         RectBounds b = what.toRectBounds();
1113         b.intersectWith(with);
1114         what.setBounds(b);
1115         return what;
1116     }
1117 
1118     static Color createColor(int rgba) {
1119         float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
1120         float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
1121         float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
1122         float b = (0xFF &amp; (rgba)) / 255.0f;
1123         return new Color(r, g, b, a);
1124     }
1125 
1126     private static Color4f createColor4f(int rgba) {
1127         float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
1128         float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
1129         float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
1130         float b = (0xFF &amp; (rgba)) / 255.0f;
1131         return new Color4f(r, g, b, a);
1132     }
1133 
1134     private DropShadow createShadow(float dx, float dy, float blur, int rgba) {
1135         if (dx == 0f &amp;&amp; dy == 0f &amp;&amp; blur == 0f) {
1136             return null;
1137         }
1138         DropShadow shadow = new DropShadow();
1139         shadow.setOffsetX((int) dx);
1140         shadow.setOffsetY((int) dy);
1141         shadow.setRadius((blur &lt; 0f) ? 0f : (blur &gt; 127f) ? 127f : blur);
1142         shadow.setColor(createColor4f(rgba));
1143         return shadow;
1144     }
1145 
1146     private void render(Graphics g, Effect effect, Paint paint, BasicStroke stroke, NGNode node) {
1147         if (node instanceof NGShape) {
1148             NGShape shape = (NGShape) node;
1149             Shape realShape = shape.getShape();
1150             Paint strokePaint = state.getStrokeNoClone().getPaint();
1151             if ((stroke != null) &amp;&amp; (strokePaint != null)) {
1152                 realShape = stroke.createStrokedShape(realShape);
1153                 shape.setDrawStroke(stroke);
1154                 shape.setDrawPaint(strokePaint);
1155                 shape.setMode((paint == null) ? NGShape.Mode.STROKE : NGShape.Mode.STROKE_FILL);
1156             } else {
1157                 shape.setMode((paint == null) ? NGShape.Mode.EMPTY : NGShape.Mode.FILL);
1158             }
1159             shape.setFillPaint(paint);
1160             shape.setContentBounds(realShape.getBounds());
1161         }
1162         boolean culling = g.hasPreCullingBits();
1163         g.setHasPreCullingBits(false);
1164         node.setEffect(effect);
1165         node.render(g);
1166         g.setHasPreCullingBits(culling);
1167     }
1168 
1169     private static final class ContextState {
1170         private final WCStrokeImpl stroke = new WCStrokeImpl();
1171         private Rectangle clip;
1172         private Paint paint;
1173         private float alpha;
1174 
1175         private boolean textFill = true;
1176         private boolean textStroke = false;
1177         private boolean textClip = false;
1178         private boolean restorePoint = false;
1179 
1180         private DropShadow shadow;
1181         private Affine3D xform;
1182         private GeneralTransform3D perspectiveTransform;
1183         private Layer layer;
1184         private int compositeOperation;
1185 
1186         private ContextState() {
1187             clip = null;
1188             paint = Color.BLACK;
1189             stroke.setPaint(Color.BLACK);
1190             alpha = 1.0f;
1191             xform = new Affine3D();
1192             perspectiveTransform = new GeneralTransform3D();
1193             compositeOperation = COMPOSITE_SOURCE_OVER;
1194         }
1195 
1196         private ContextState(ContextState state) {
1197             stroke.copyFrom(state.getStrokeNoClone());
1198             setPaint(state.getPaintNoClone());
1199             clip = state.getClipNoClone();
1200             if (clip != null) {
1201                 clip = new Rectangle(clip);
1202             }
1203             xform = new Affine3D(state.getTransformNoClone());
1204             perspectiveTransform = new GeneralTransform3D().set(state.getPerspectiveTransformNoClone());
1205             setShadow(state.getShadowNoClone());
1206             setLayer(state.getLayerNoClone());
1207             setAlpha(state.getAlpha());
1208             setTextMode(state.isTextFill(), state.isTextStroke(), state.isTextClip());
1209             setCompositeOperation(state.getCompositeOperation());
1210         }
1211 
1212         @Override
1213         protected ContextState clone() {
1214             return new ContextState(this);
1215         }
1216 
1217         private void apply(Graphics g) {
1218             g.setTransform(getTransformNoClone());
1219             g.setPerspectiveTransform(getPerspectiveTransformNoClone());
1220             g.setClipRect(getClipNoClone());
1221             g.setExtraAlpha(getAlpha());
1222         }
1223 
1224         private int getCompositeOperation() {
1225             return compositeOperation;
1226         }
1227 
1228         private void setCompositeOperation(int compositeOperation) {
1229             this.compositeOperation = compositeOperation;
1230         }
1231 
1232         private WCStrokeImpl getStrokeNoClone() {
1233             return stroke;
1234         }
1235 
1236         private Paint getPaintNoClone() {
1237             return paint;
1238         }
1239 
1240         private void setPaint(Paint paint) {
1241             this.paint = paint;
1242         }
1243 
1244         private Rectangle getClipNoClone() {
1245             return clip;
1246         }
1247 
1248         private Layer getLayerNoClone() {
1249             return layer;
1250         }
1251 
1252         private void setLayer(Layer layer) {
1253             this.layer = layer;
1254         }
1255 
1256         private void setClip(Rectangle area) {
1257             clip = area;
1258         }
1259 
1260         private void clip(Rectangle area) {
1261             if (null == clip) {
1262                 clip = area;
1263             } else {
1264                 clip.intersectWith(area);
1265             }
1266         }
1267 
1268         private void setAlpha(float alpha) {
1269             this.alpha = alpha;
1270         }
1271 
1272         private float getAlpha() {
1273             return alpha;
1274         }
1275 
1276         private void setTextMode(boolean fill, boolean stroke, boolean clip) {
1277             textFill = fill;
1278             textStroke = stroke;
1279             textClip = clip;
1280         }
1281 
1282         private boolean isTextFill() {
1283             return textFill;
1284         }
1285 
1286         private boolean isTextStroke() {
1287             return textStroke;
1288         }
1289 
1290         private boolean isTextClip() {
1291             return textClip;
1292         }
1293 
1294         private void markAsRestorePoint() {
1295             restorePoint = true;
1296         }
1297 
1298         private boolean isRestorePoint() {
1299             return restorePoint;
1300         }
1301 
1302         private void setShadow(DropShadow shadow) {
1303             this.shadow = shadow;
1304         }
1305 
1306         private DropShadow getShadowNoClone() {
1307             return shadow;
1308         }
1309 
1310         private Affine3D getTransformNoClone() {
1311             return xform;
1312         }
1313 
1314         private GeneralTransform3D getPerspectiveTransformNoClone() {
1315             return perspectiveTransform;
1316         }
1317 
1318         private void setTransform(final Affine3D at) {
1319             this.xform.setTransform(at);
1320         }
1321 
1322         private void setPerspectiveTransform(final GeneralTransform3D gt) {
1323             this.perspectiveTransform.set(gt);
1324         }
1325 
1326         private void concatTransform(Affine3D at) {
1327             xform.concatenate(at);
1328         }
1329 
1330         private void translate(double dx, double dy) {
1331             xform.translate(dx, dy);
1332         }
1333 
1334         private void scale(double sx, double sy) {
1335             xform.scale(sx,sy);
1336         }
1337 
1338         private void rotate(double radians) {
1339             xform.rotate(radians);
1340         }
1341     }
1342 
1343     private abstract static class Layer {
1344         FilterContext fctx;
1345         PrDrawable buffer;
1346         Graphics graphics;
1347         final Rectangle bounds;
1348         boolean permanent;
1349 
1350         Layer(Graphics g, Rectangle bounds, boolean permanent) {
1351             this.bounds = new Rectangle(bounds);
1352             this.permanent = permanent;
1353 
1354             // avoid creating zero-size drawable, see also RT-21410
1355             int w = Math.max(bounds.width, 1);
1356             int h = Math.max(bounds.height, 1);
1357             fctx = getFilterContext(g);
1358             if (permanent) {
1359                 ResourceFactory f = GraphicsPipeline.getDefaultResourceFactory();
1360                 RTTexture rtt = f.createRTTexture(w, h, Texture.WrapMode.CLAMP_NOT_NEEDED);
1361                 rtt.makePermanent();
1362                 buffer = ((PrRenderer)Renderer.getRenderer(fctx)).createDrawable(rtt);
1363             } else {
1364                 buffer = (PrDrawable) Effect.getCompatibleImage(fctx, w, h);
1365             }
1366         }
1367 
1368         Graphics getGraphics() {
1369             if (graphics == null) {
1370                 graphics = buffer.createGraphics();
1371             }
1372             return graphics;
1373         }
1374 
1375         abstract void init(Graphics g);
1376 
1377         abstract void render(Graphics g);
1378 
1379         private void dispose() {
1380             if (buffer != null) {
1381                 if (permanent) {
1382                     buffer.flush(); // releases the resource
1383                 } else {
1384                     Effect.releaseCompatibleImage(fctx, buffer);
1385                 }
1386                 fctx = null;
1387                 buffer = null;
1388             }
1389         }
1390 
1391         private double getX() { return (double) bounds.x; }
1392         private double getY() { return (double) bounds.y; }
1393     }
1394 
1395     private final class TransparencyLayer extends Layer {
1396         private final float opacity;
1397 
1398         private TransparencyLayer(Graphics g, Rectangle bounds, float opacity) {
1399             super(g, bounds, false);
1400             this.opacity = opacity;
1401         }
1402 
1403         @Override void init(Graphics g) {
1404             state.setCompositeOperation(COMPOSITE_SOURCE_OVER);
1405         }
1406 
1407         @Override void render(Graphics g) {
1408             new Composite() {
1409                 @Override void doPaint(Graphics g) {
1410                     float op = g.getExtraAlpha();
1411                     g.setExtraAlpha(opacity);
1412                     Affine3D tx = new Affine3D(g.getTransformNoClone());
1413                     g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
1414                     g.drawTexture(buffer.getTextureObject(),
1415                             bounds.x, bounds.y, bounds.width, bounds.height);
1416                     g.setTransform(tx);
1417                     g.setExtraAlpha(op);
1418                 }
1419             }.paint(g);
1420         }
1421 
1422         @Override public String toString() {
1423             return String.format(&quot;TransparencyLayer[%d,%d + %dx%d, opacity %.2f]&quot;,
1424                 bounds.x, bounds.y, bounds.width, bounds.height, opacity);
1425         }
1426     }
1427 
1428     private static final class ClipLayer extends Layer {
1429         private final WCPath normalizedToClipPath;
1430         private boolean srcover;
1431 
1432         private ClipLayer(Graphics g, Rectangle bounds, WCPath normalizedToClipPath,
1433                           boolean permanent)
1434         {
1435             super(g, bounds, permanent);
1436             this.normalizedToClipPath = normalizedToClipPath;
1437             srcover = true;
1438         }
1439 
1440         @Override void init(Graphics g) {
1441             RTTexture texture = null;
1442             ReadbackGraphics readbackGraphics = null;
1443             try {
1444                 readbackGraphics = (ReadbackGraphics) g;
1445                 texture = readbackGraphics.readBack(bounds);
1446                 getGraphics().drawTexture(texture, 0, 0, bounds.width, bounds.height);
1447             } finally {
1448                 if (readbackGraphics != null &amp;&amp; texture != null) {
1449                     readbackGraphics.releaseReadBackBuffer(texture);
1450                 }
1451             }
1452             srcover = false;
1453         }
1454 
1455         @Override void render(Graphics g) {
1456             Path2D p2d = ((WCPathImpl)normalizedToClipPath).getPlatformPath();
1457 
1458             // render normalizedToClipPath to a drawable
1459             PrDrawable bufferImg = (PrDrawable) Effect.getCompatibleImage(
1460                     fctx, bounds.width, bounds.height);
1461             Graphics bufferGraphics = bufferImg.createGraphics();
1462 
1463             bufferGraphics.setPaint(Color.BLACK);
1464             bufferGraphics.fill(p2d);
1465 
1466             // blend buffer and clipImg onto |g|
1467             if (g instanceof MaskTextureGraphics &amp;&amp; ! (g instanceof PrinterGraphics)) {
1468                 MaskTextureGraphics mg = (MaskTextureGraphics) g;
1469                 if (srcover) {
1470                     mg.drawPixelsMasked(buffer.getTextureObject(),
1471                                         bufferImg.getTextureObject(),
1472                                         bounds.x, bounds.y, bounds.width, bounds.height,
1473                                         0, 0, 0, 0);
1474                 } else {
1475                     mg.maskInterpolatePixels(buffer.getTextureObject(),
1476                                              bufferImg.getTextureObject(),
1477                                              bounds.x, bounds.y, bounds.width, bounds.height,
1478                                              0, 0, 0, 0);
1479                 }
1480             } else {
1481                 Blend blend = new Blend(Blend.Mode.SRC_IN,
1482                         new PassThrough(bufferImg, bounds.width, bounds.height),
1483                         new PassThrough(buffer, bounds.width, bounds.height));
1484                 Affine3D tx = new Affine3D(g.getTransformNoClone());
1485                 g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
1486                 PrEffectHelper.render(blend, g, bounds.x, bounds.y, null);
1487                 g.setTransform(tx);
1488             }
1489 
1490             Effect.releaseCompatibleImage(fctx, bufferImg);
1491         }
1492 
1493         @Override public String toString() {
1494             return String.format(&quot;ClipLayer[%d,%d + %dx%d, path %s]&quot;,
1495                     bounds.x, bounds.y, bounds.width, bounds.height,
1496                     normalizedToClipPath);
1497         }
1498     }
1499 
1500     private abstract class Composite {
1501         abstract void doPaint(Graphics g);
1502 
1503         void paint() {
1504             paint(getGraphics(true));
1505         }
1506 
1507         void paint(Graphics g) {
1508             if (g != null) {
1509                 CompositeMode oldCompositeMode = g.getCompositeMode();
1510                 switch (state.getCompositeOperation()) {
1511                     // decode operations that don&#39;t require Blend first
1512                     case COMPOSITE_COPY:
1513                         g.setCompositeMode(CompositeMode.SRC);
1514                         doPaint(g);
1515                         g.setCompositeMode(oldCompositeMode);
1516                         break;
1517                     case COMPOSITE_SOURCE_OVER:
1518                         g.setCompositeMode(CompositeMode.SRC_OVER);
1519                         doPaint(g);
1520                         g.setCompositeMode(oldCompositeMode);
1521                         break;
1522                     default:
1523                         // other operations require usage of Blend
1524                         blend(g);
1525                         break;
1526                 }
1527                 isRootLayerValid = false;
1528             }
1529         }
1530 
1531         private void blend(Graphics g) {
1532             FilterContext fctx = getFilterContext(g);
1533             PrDrawable dstImg = null;
1534             PrDrawable srcImg = null;
1535             ReadbackGraphics readBackGraphics = null;
1536             RTTexture texture = null;
1537             Rectangle clip = state.getClipNoClone();
1538             WCImage image = getImage();
1539             try {
1540                 if (image != null &amp;&amp; image instanceof PrismImage) {
1541                     // blending on canvas
1542                     dstImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
1543                     Graphics dstG = dstImg.createGraphics();
1544                     ((PrismImage) image).draw(dstG,
1545                             0, 0, clip.width, clip.height,
1546                             clip.x, clip.y, clip.width, clip.height);
1547                 } else {
1548                     // blending on page
1549                     readBackGraphics = (ReadbackGraphics) g;
1550                     texture = readBackGraphics.readBack(clip);
1551                     dstImg = PrDrawable.create(fctx, texture);
1552                 }
1553 
1554                 srcImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
1555                 Graphics srcG = srcImg.createGraphics();
1556                 state.apply(srcG);
1557                 doPaint(srcG);
1558 
1559                 g.clear();
1560                 PrEffectHelper.render(createEffect(dstImg, srcImg, clip.width, clip.height), g, 0, 0, null);
1561 
1562             } finally {
1563                 if (srcImg != null) {
1564                     Effect.releaseCompatibleImage(fctx, srcImg);
1565                 }
1566                 if (dstImg != null) {
1567                     if (readBackGraphics != null &amp;&amp; texture != null) {
1568                         readBackGraphics.releaseReadBackBuffer(texture);
1569                     } else {
1570                         Effect.releaseCompatibleImage(fctx, dstImg);
1571                     }
1572                 }
1573             }
1574         }
1575 
1576         // provides some syntax sugar for createEffect()
1577         private Effect createBlend(Blend.Mode mode,
1578                                    PrDrawable dstImg,
1579                                    PrDrawable srcImg,
1580                                    int width,
1581                                    int height)
1582         {
1583             return new Blend(
1584                     mode,
1585                     new PassThrough(dstImg, width, height),
1586                     new PassThrough(srcImg, width, height));
1587         }
1588 
1589         private Effect createEffect(PrDrawable dstImg,
1590                                     PrDrawable srcImg,
1591                                     int width,
1592                                     int height)
1593         {
1594             switch (state.getCompositeOperation()) {
1595                 case COMPOSITE_CLEAR: // same as xor
1596                 case COMPOSITE_XOR:
1597                     return new Blend(
1598                             SRC_OVER,
1599                             createBlend(SRC_OUT, dstImg, srcImg, width, height),
1600                             createBlend(SRC_OUT, srcImg, dstImg, width, height)
1601                     );
1602                 case COMPOSITE_SOURCE_IN:
1603                     return createBlend(SRC_IN, dstImg, srcImg, width, height);
1604                 case COMPOSITE_SOURCE_OUT:
1605                     return createBlend(SRC_OUT, dstImg, srcImg, width, height);
1606                 case COMPOSITE_SOURCE_ATOP:
1607                     return createBlend(SRC_ATOP, dstImg, srcImg, width, height);
1608                 case COMPOSITE_DESTINATION_OVER:
1609                     return createBlend(SRC_OVER, srcImg, dstImg, width, height);
1610                 case COMPOSITE_DESTINATION_IN:
1611                     return createBlend(SRC_IN, srcImg, dstImg, width, height);
1612                 case COMPOSITE_DESTINATION_OUT:
1613                     return createBlend(SRC_OUT, srcImg, dstImg, width, height);
1614                 case COMPOSITE_DESTINATION_ATOP:
1615                     return createBlend(SRC_ATOP, srcImg, dstImg, width, height);
1616                 case COMPOSITE_HIGHLIGHT:
1617                     return createBlend(ADD, dstImg, srcImg, width, height);
1618                 default:
1619                     return createBlend(SRC_OVER, dstImg, srcImg, width, height);
1620             }
1621         }
1622     }
1623 
1624     private static final class PassThrough extends Effect {
1625         private final PrDrawable img;
1626         private final int width;
1627         private final int height;
1628 
1629         private PassThrough(PrDrawable img, int width, int height) {
1630             this.img = img;
1631             this.width = width;
1632             this.height = height;
1633         }
1634 
1635         @Override public ImageData filter(
1636                 FilterContext fctx,
1637                 BaseTransform transform,
1638                 Rectangle outputClip,
1639                 Object renderHelper,
1640                 Effect defaultInput) {
1641             // We have an unpaired lock() here, because unlocking is done
1642             // internally by ImageData. See RT-33625 for details.
1643             img.lock();
1644             ImageData imgData = new ImageData(fctx, img, new Rectangle(
1645                                               (int) transform.getMxt(),
1646                                               (int) transform.getMyt(),
1647                                               width, height));
1648             imgData.setReusable(true);
1649             return imgData;
1650         }
1651 
1652         @Override public RectBounds getBounds(
1653                 BaseTransform transform,
1654                 Effect defaultInput) {
1655             return null;
1656         }
1657 
1658         @Override public AccelType getAccelType(FilterContext fctx) {
1659             return AccelType.INTRINSIC;
1660         }
1661 
1662         @Override
1663         public boolean reducesOpaquePixels() {
1664             return false;
1665         }
1666 
1667         @Override
1668         public DirtyRegionContainer getDirtyRegions(Effect defaultInput, DirtyRegionPool regionPool) {
1669             return null;
1670         }
1671     }
1672 
1673     private static FilterContext getFilterContext(Graphics g) {
1674         Screen screen = g.getAssociatedScreen();
1675         if (screen == null) {
1676             ResourceFactory factory = g.getResourceFactory();
1677             return PrFilterContext.getPrinterContext(factory);
1678         } else {
1679             return PrFilterContext.getInstance(screen);
1680         }
1681     }
1682 
1683     @Override
1684     public void strokeArc(final int x, final int y, final int w, final int h,
1685                           final int startAngle, final int angleSpan)
1686     {
1687         if (log.isLoggable(Level.FINE)) {
1688             log.fine(String.format(&quot;strokeArc(%d, %d, %d, %d, %d, %d)&quot;,
1689                                    x, y, w, h, startAngle, angleSpan));
1690         }
1691         Arc2D arc = new Arc2D(x, y, w, h, startAngle, angleSpan, Arc2D.OPEN);
1692         if (state.getStrokeNoClone().isApplicable() &amp;&amp;
1693             !shouldRenderShape(arc, null, state.getStrokeNoClone().getPlatformStroke()))
1694         {
1695             return;
1696         }
1697         new Composite() {
1698             @Override void doPaint(Graphics g) {
1699                 if (state.getStrokeNoClone().apply(g)) {
1700                     g.draw(arc);
1701                 }
1702             }
1703         }.paint();
1704     }
1705 
1706     @Override
1707     public WCImage getImage() {
1708         return null;
1709     }
1710 
1711     @Override
1712     public void strokeRect(final float x, final float y, final float w, final float h,
1713                            final float lineWidth) {
1714         if (log.isLoggable(Level.FINE)) {
1715             log.fine(String.format(&quot;strokeRect_FFFFF(%f, %f, %f, %f, %f)&quot;,
1716                                    x, y, w, h, lineWidth));
1717         }
1718         BasicStroke stroke = new BasicStroke(
1719             lineWidth,
1720             BasicStroke.CAP_BUTT,
1721             BasicStroke.JOIN_MITER,
1722             Math.max(1.0f, lineWidth),
1723             state.getStrokeNoClone().getDashSizes(),
1724             state.getStrokeNoClone().getDashOffset());
1725 
1726         if (!shouldRenderRect(x, y, w, h, null, stroke)) {
1727             return;
1728         }
1729         new Composite() {
1730             @Override void doPaint(Graphics g) {
1731                 g.setStroke(stroke);
1732                 Paint paint = state.getStrokeNoClone().getPaint();
1733                 if (paint == null) {
1734                     paint = state.getPaintNoClone();
1735                 }
1736                 g.setPaint(paint);
1737                 g.drawRect(x, y, w, h);
1738             }
1739         }.paint();
1740     }
1741 
1742     @Override
1743     public void strokePath(final WCPath path) {
1744         log.fine(&quot;strokePath&quot;);
1745         if (path != null) {
1746             final BasicStroke stroke = state.getStrokeNoClone().getPlatformStroke();
1747             final DropShadow shadow = state.getShadowNoClone();
1748             final Path2D p2d = (Path2D)path.getPlatformPath();
1749 
1750             if ((stroke == null &amp;&amp; shadow == null) ||
1751                 !shouldRenderShape(p2d, shadow, stroke))
1752             {
1753                 return;
1754             }
1755             new Composite() {
1756                 @Override void doPaint(Graphics g) {
1757                     if (shadow != null) {
1758                         final NGPath node = new NGPath();
1759                         node.updateWithPath2d(p2d);
1760                         render(g, shadow, null, stroke, node);
1761                     } else if (stroke != null) {
1762                         Paint paint = state.getStrokeNoClone().getPaint();
1763                         if (paint == null) {
1764                             paint = state.getPaintNoClone();
1765                         }
1766                         g.setPaint(paint);
1767                         g.setStroke(stroke);
1768                         g.draw(p2d);
1769                     }
1770                 }
1771             }.paint();
1772         }
1773     }
1774 
1775     @Override
1776     public void fillPath(final WCPath path) {
1777         log.fine(&quot;fillPath&quot;);
1778         if (path != null) {
1779             if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(),
1780                                    state.getShadowNoClone(), null))
1781             {
1782                 return;
1783             }
1784             new Composite() {
1785                 @Override void doPaint(Graphics g) {
1786                     Path2D p2d = (Path2D) path.getPlatformPath();
1787                     Paint paint = state.getPaintNoClone();
1788                     DropShadow shadow = state.getShadowNoClone();
1789                     if (shadow != null) {
1790                         final NGPath node = new NGPath();
1791                         node.updateWithPath2d(p2d);
1792                         render(g, shadow, paint, null, node);
1793                     } else {
1794                         g.setPaint(paint);
1795                         g.fill(p2d);
1796                     }
1797                 }
1798             }.paint();
1799         }
1800     }
1801 
1802     public void setPerspectiveTransform(WCTransform tm) {
1803         final GeneralTransform3D at = new GeneralTransform3D().set(tm.getMatrix());
1804         state.setPerspectiveTransform(at);
1805         resetCachedGraphics();
1806     }
1807 
1808     public void setTransform(WCTransform tm) {
1809         final double m[] = tm.getMatrix();
1810         final Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
1811         if (state.getLayerNoClone() == null) {
1812             at.preConcatenate(baseTransform);
1813         }
1814         state.setTransform(at);
1815         resetCachedGraphics();
1816     }
1817 
1818     public WCTransform getTransform() {
1819         Affine3D xf = state.getTransformNoClone();
1820         return new WCTransform(xf.getMxx(), xf.getMyx(),
1821                                xf.getMxy(), xf.getMyy(),
1822                                xf.getMxt(), xf.getMyt());
1823     }
1824 
1825     public void concatTransform(WCTransform tm) {
1826         double m[] = tm.getMatrix();
1827         Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
1828         state.concatTransform(at);
1829         resetCachedGraphics();
1830     }
1831 
1832     @Override
1833     public void flush() {
1834         flushAllLayers();
1835     }
1836 
1837     @Override
1838     public WCGradient createLinearGradient(WCPoint p1, WCPoint p2) {
1839         return new WCLinearGradient(p1, p2);
1840     }
1841 
1842     @Override
1843     public WCGradient createRadialGradient(WCPoint p1, float r1, WCPoint p2, float r2) {
1844         return new WCRadialGradient(p1, r1, p2, r2);
1845     }
1846 }
    </pre>
  </body>
</html>