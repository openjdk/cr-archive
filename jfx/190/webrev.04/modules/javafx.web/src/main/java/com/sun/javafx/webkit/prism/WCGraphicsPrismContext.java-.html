<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/java/com/sun/javafx/webkit/prism/WCGraphicsPrismContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.javafx.webkit.prism;
  27 
  28 import com.sun.glass.ui.Screen;
  29 import com.sun.javafx.font.FontStrike;
  30 import com.sun.javafx.font.Metrics;
  31 import com.sun.javafx.font.PGFont;
  32 import com.sun.javafx.geom.*;
  33 import com.sun.javafx.geom.transform.Affine2D;
  34 import com.sun.javafx.geom.transform.Affine3D;
  35 import com.sun.javafx.geom.transform.BaseTransform;
  36 import com.sun.javafx.geom.transform.GeneralTransform3D;
  37 import com.sun.javafx.logging.PlatformLogger;
  38 import com.sun.javafx.logging.PlatformLogger.Level;
  39 import com.sun.javafx.scene.text.GlyphList;
  40 import com.sun.javafx.scene.text.TextLayout;
  41 import com.sun.javafx.sg.prism.*;
  42 import com.sun.javafx.text.TextRun;
  43 import com.sun.prism.*;
  44 import com.sun.prism.paint.Color;
  45 import com.sun.prism.paint.Gradient;
  46 import com.sun.prism.paint.ImagePattern;
  47 import com.sun.prism.paint.Paint;
  48 import com.sun.scenario.effect.*;
  49 import com.sun.scenario.effect.impl.prism.PrDrawable;
  50 import com.sun.scenario.effect.impl.prism.PrEffectHelper;
  51 import com.sun.scenario.effect.impl.prism.PrFilterContext;
  52 import com.sun.webkit.graphics.*;
  53 
  54 import java.nio.ByteBuffer;
  55 import java.nio.ByteOrder;
  56 import java.security.AccessController;
  57 import java.security.PrivilegedAction;
  58 import java.util.ArrayList;
  59 import java.util.List;
  60 
  61 import static com.sun.scenario.effect.Blend.Mode.*;
  62 import com.sun.scenario.effect.impl.Renderer;
  63 import com.sun.scenario.effect.impl.prism.PrRenderer;
  64 
  65 class WCGraphicsPrismContext extends WCGraphicsContext {
  66 
  67     public enum Type {
  68         /**
  69          * Base context associated with the topmost page buffer.
  70          * Created and disposed during a single render pass.
  71          */
  72         PRIMARY,
  73 
  74         /**
  75          * A context associated with a dedicated buffer representing
  76          * a separate render target like canvas, buffered image etc.
  77          * Its life cycle is not limited to a single render pass.
  78          */
  79         DEDICATED
  80     }
  81 
  82     private final static PlatformLogger log =
  83             PlatformLogger.getLogger(WCGraphicsPrismContext.class.getName());
  84     private final static boolean DEBUG_DRAW_CLIP_SHAPE = Boolean.valueOf(
  85             AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt;
  86             System.getProperty(&quot;com.sun.webkit.debugDrawClipShape&quot;, &quot;false&quot;)));
  87 
  88     Graphics baseGraphics;
  89     private BaseTransform baseTransform;
  90 
  91     private final List&lt;ContextState&gt; states = new ArrayList&lt;ContextState&gt;();
  92 
  93     private ContextState state = new ContextState();
  94 
  95     // Cache for getPlatformGraphics
  96     private Graphics cachedGraphics = null;
  97 
  98     private int fontSmoothingType;
  99     private boolean isRootLayerValid = false;
 100 
 101     WCGraphicsPrismContext(Graphics g) {
 102         state.setClip(g.getClipRect());
 103         state.setAlpha(g.getExtraAlpha());
 104         baseGraphics = g;
 105         initBaseTransform(g.getTransformNoClone());
 106     }
 107 
 108     WCGraphicsPrismContext() {
 109     }
 110 
 111     public Type type() {
 112         return Type.PRIMARY;
 113     }
 114 
 115     final void initBaseTransform(BaseTransform t) {
 116         baseTransform = new Affine3D(t);
 117         state.setTransform((Affine3D)baseTransform);
 118     }
 119 
 120     private void resetCachedGraphics() {
 121         cachedGraphics = null;
 122     }
 123 
 124     @Override
 125     public Object getPlatformGraphics() {
 126         return getGraphics(false);
 127     }
 128 
 129     Graphics getGraphics(boolean checkClip) {
 130         if (cachedGraphics == null) {
 131             Layer l = state.getLayerNoClone();
 132             cachedGraphics = (l != null)
 133                     ? l.getGraphics()
 134                     : baseGraphics;
 135 
 136             state.apply(cachedGraphics);
 137 
 138             if (log.isLoggable(Level.FINE)) {
 139                 log.fine(&quot;getPlatformGraphics for &quot; + this + &quot; : &quot; +
 140                          cachedGraphics);
 141             }
 142         }
 143 
 144         Rectangle clip = cachedGraphics.getClipRectNoClone();
 145         return (checkClip &amp;&amp; clip!=null &amp;&amp; clip.isEmpty())
 146             ? null
 147             : cachedGraphics;
 148     }
 149 
 150     public void saveState()
 151     {
 152         state.markAsRestorePoint();
 153         saveStateInternal();
 154     }
 155 
 156     private void saveStateInternal()
 157     {
 158         states.add(state);
 159         state = state.clone();
 160     }
 161 
 162     private void startNewLayer(Layer layer) {
 163         saveStateInternal();
 164 
 165         // layer has the same bounds as clip, so we have to translate
 166         Rectangle clip = state.getClipNoClone();
 167 
 168         //left-side (post-) translate.
 169         //NB! an order of transforms is essential!
 170         Affine3D newTr = new Affine3D(BaseTransform.getTranslateInstance(
 171                 -clip.x,
 172                 -clip.y));
 173         newTr.concatenate(state.getTransformNoClone());
 174 
 175         //move clip to (0, 0) - start of texture
 176         clip.x = 0;
 177         clip.y = 0;
 178         //no-clone - no-set!
 179 
 180         Graphics g = getGraphics(true);
 181         if (g != null &amp;&amp; g != baseGraphics) {
 182             layer.init(g);
 183         }
 184 
 185         state.setTransform(newTr);
 186         state.setLayer(layer);
 187 
 188         resetCachedGraphics();
 189     }
 190 
 191     private void renderLayer(final Layer layer) {
 192         WCTransform cur = getTransform();
 193 
 194         //translate to (layer.getX(), layer.getY())
 195         setTransform(new WCTransform(
 196             1.0, 0.0,
 197             0.0, 1.0,
 198             layer.getX(), layer.getY()));
 199 
 200         // composite drawing delegated to the layer rendering
 201         Graphics g = getGraphics(true);
 202         if (g != null) {
 203             layer.render(g);
 204         }
 205 
 206         //restore transform
 207         setTransform(cur);
 208     }
 209 
 210     private void restoreStateInternal() {
 211         int size = states.size();
 212         if (size == 0) {
 213             assert false: &quot;Unbalanced restoreState&quot;;
 214             return;
 215         }
 216 
 217         Layer layer = state.getLayerNoClone();
 218         state = states.remove(size - 1);
 219         if (layer != state.getLayerNoClone()) {
 220             renderLayer(layer);
 221             layer.dispose();
 222             if (log.isLoggable(Level.FINE)) {
 223                 log.fine(&quot;Popped layer &quot; + layer);
 224             }
 225         } else {
 226             resetCachedGraphics();
 227         }
 228     }
 229 
 230     public void restoreState()
 231     {
 232         log.fine(&quot;restoring state&quot;);
 233         do {
 234             restoreStateInternal();
 235         } while ( !state.isRestorePoint() );
 236     }
 237 
 238     /**
 239      *  Renders all layers to the underlaying Graphics, but preserves the
 240      *  current state and the states stack
 241      */
 242     private void flushAllLayers() {
 243         if (state == null) {
 244             // context disposed
 245             return;
 246         }
 247 
 248         if (isRootLayerValid) {
 249             log.fine(&quot;FlushAllLayers: root layer is valid, skipping&quot;);
 250             return;
 251         }
 252 
 253         if (log.isLoggable(Level.FINE)) {
 254             log.fine(&quot;FlushAllLayers&quot;);
 255         }
 256 
 257         ContextState currentState = state;
 258 
 259         for (int i = states.size() - 1; i &gt;=0; i--) {
 260             Layer layer = state.getLayerNoClone();
 261             state = states.get(i);
 262             if (layer != state.getLayerNoClone()) {
 263                 renderLayer(layer);
 264             } else {
 265                 resetCachedGraphics();
 266             }
 267         }
 268 
 269         Layer layer = state.getLayerNoClone();
 270         if (layer != null) {
 271             renderLayer(layer);
 272         }
 273 
 274         state = currentState;
 275         isRootLayerValid = true;
 276     }
 277 
 278 
 279     public void dispose() {
 280         if (!states.isEmpty()) {
 281             log.fine(&quot;Unbalanced saveState/restoreState&quot;);
 282         }
 283         for (ContextState state: states) {
 284             if (state.getLayerNoClone() != null) {
 285                 state.getLayerNoClone().dispose();
 286             }
 287         }
 288         states.clear();
 289 
 290         if (state != null &amp;&amp; state.getLayerNoClone() != null) {
 291             state.getLayerNoClone().dispose();
 292         }
 293         state = null;
 294     }
 295 
 296 
 297     public void setClip(WCPath path, boolean isOut) {
 298         Affine3D tr = new Affine3D(state.getTransformNoClone());
 299         path.transform(
 300                 tr.getMxx(), tr.getMyx(),
 301                 tr.getMxy(), tr.getMyy(),
 302                 tr.getMxt(), tr.getMyt());
 303         //path now is in node coordinates, as well as clip
 304 
 305         if (!isOut) {
 306             WCRectangle pathBounds = path.getBounds();
 307 
 308             // path bounds could be fractional so &#39;inclusive&#39; rounding
 309             // is used for determining clip rectangle
 310             int pixelX = (int) Math.floor(pathBounds.getX());
 311             int pixelY = (int) Math.floor(pathBounds.getY());
 312             int pixelW = (int) Math.ceil(pathBounds.getMaxX()) - pixelX;
 313             int pixelH = (int) Math.ceil(pathBounds.getMaxY()) - pixelY;
 314 
 315             state.clip(new Rectangle(pixelX, pixelY, pixelW, pixelH));
 316         }
 317 
 318         Rectangle clip = state.getClipNoClone();
 319 
 320         if (isOut) {
 321             path.addRect(clip.x, clip.y, clip.width, clip.height);
 322             //Out clip path is always EVENODD.
 323         }
 324 
 325         path.translate(-clip.x, -clip.y);
 326 
 327         Layer layer = new ClipLayer(
 328             getGraphics(false), clip, path, type() == Type.DEDICATED);
 329 
 330         startNewLayer(layer);
 331 
 332         if (log.isLoggable(Level.FINE)) {
 333             log.fine(&quot;setClip(WCPath &quot; + path.getID() + &quot;)&quot;);
 334             log.fine(&quot;Pushed layer &quot; + layer);
 335         }
 336     }
 337 
 338     private Rectangle transformClip(Rectangle localClip) {
 339         if (localClip==null) {
 340             return null;
 341         }
 342 
 343         float[] points = new float[] {
 344             localClip.x, localClip.y,
 345             localClip.x + localClip.width, localClip.y,
 346             localClip.x, localClip.y + localClip.height,
 347             localClip.x  + localClip.width, localClip.y + localClip.height};
 348         state.getTransformNoClone().transform(points, 0, points, 0, 4);
 349         float minX = Math.min(
 350                points[0], Math.min(
 351                points[2], Math.min(
 352                points[4], points[6])));
 353         float maxX = Math.max(
 354                points[0], Math.max(
 355                points[2], Math.max(
 356                points[4], points[6])));
 357         float minY = Math.min(
 358                points[1], Math.min(
 359                points[3], Math.min(
 360                points[5], points[7])));
 361         float maxY = Math.max(
 362                points[1], Math.max(
 363                points[3], Math.max(
 364                points[5], points[7])));
 365         return new Rectangle(new RectBounds(minX, minY, maxX, maxY));
 366 
 367 /* #1 loose rotate
 368         state.getTransformNoClone().transform(localClip, localClip);
 369 */
 370 /* #2 problem with negative coordinates
 371         RectBounds rb = TransformedShape.transformedShape(
 372             new RoundRectangle2D(localClip.x, localClip.y, localClip.width, localClip.height, 0, 0),
 373             state.getTransformNoClone()).getBounds();
 374         return rb.isEmpty()
 375             ? null
 376             : new Rectangle(rb);
 377  */
 378     }
 379 
 380     private void setClip(Rectangle shape) {
 381         Affine3D tr = state.getTransformNoClone();
 382         if (tr.getMxy() == 0 &amp;&amp; tr.getMxz() == 0
 383          &amp;&amp; tr.getMyx() == 0 &amp;&amp; tr.getMyz() == 0
 384          &amp;&amp; tr.getMzx() == 0 &amp;&amp; tr.getMzy() == 0) {
 385             //There is no rotation here: scale + translation.
 386             //Fast &amp; easy!
 387             state.clip(transformClip(shape));
 388             if (log.isLoggable(Level.FINE)) {
 389                 log.fine(&quot;setClip({0})&quot;, shape);
 390             }
 391             if (DEBUG_DRAW_CLIP_SHAPE) {
 392                 //Draw clip shape
 393                 Rectangle rc = state.getClipNoClone();
 394                 if (rc != null &amp;&amp; rc.width &gt;= 2 &amp;&amp; rc.height &gt;= 2) {
 395                     WCTransform cur = getTransform();
 396                     //translate to (layer.getX(), layer.getY())
 397                     setTransform(new WCTransform(
 398                         1.0, 0.0,
 399                         0.0, 1.0,
 400                         0.0, 0.0));
 401 
 402                     Graphics g2d = getGraphics(true);
 403                     if (g2d != null) {
 404                         float fbase = (float)Math.random();
 405                         g2d.setPaint(new Color(
 406                                 fbase,
 407                                 1f - fbase,
 408                                 0.5f,
 409                                 0.1f));
 410                         g2d.setStroke(new BasicStroke());
 411                         g2d.fillRect(rc.x, rc.y, rc.width, rc.height);
 412 
 413                         g2d.setPaint(new Color(
 414                                 1f - fbase,
 415                                 fbase,
 416                                 0.5f,
 417                                 1f));
 418                         g2d.drawRect(rc.x, rc.y, rc.width, rc.height);
 419                     }
 420                     //restore transform
 421                     setTransform(cur);
 422                     state.clip(new Rectangle(rc.x+1, rc.y+1, rc.width-2, rc.height-2));
 423                 }
 424             }
 425             if (cachedGraphics != null) {
 426                 cachedGraphics.setClipRect(state.getClipNoClone());
 427             }
 428         } else {
 429             //twisted axis set
 430             WCPath path = new WCPathImpl();
 431             path.addRect(shape.x, shape.y, shape.width, shape.height);
 432             setClip(path, false);
 433         }
 434     }
 435 
 436     public void setClip(int cx, int cy, int cw, int ch) {
 437         setClip(new Rectangle(cx, cy, cw, ch));
 438     }
 439 
 440     public void setClip(WCRectangle c) {
 441         setClip(new Rectangle((int)c.getX(), (int)c.getY(),
 442                               (int)c.getWidth(), (int)c.getHeight()));
 443     }
 444 
 445     public WCRectangle getClip() {
 446         Rectangle r = state.getClipNoClone();
 447         return r == null ? null : new WCRectangle(r.x, r.y, r.width, r.height);
 448     }
 449 
 450     protected Rectangle getClipRectNoClone() {
 451         return state.getClipNoClone();
 452     }
 453 
 454     protected Affine3D getTransformNoClone() {
 455         return state.getTransformNoClone();
 456     }
 457 
 458     public void translate(float x, float y) {
 459         if (log.isLoggable(Level.FINE)) {
 460             log.fine(&quot;translate({0},{1})&quot;, new Object[] {x, y});
 461         }
 462         state.translate(x, y);
 463         if (cachedGraphics != null) {
 464             cachedGraphics.translate(x, y);
 465         }
 466     }
 467 
 468     public void scale(float sx, float sy) {
 469         if (log.isLoggable(Level.FINE)) {
 470             log.fine(&quot;scale(&quot; + sx + &quot; &quot; + sy + &quot;)&quot;);
 471         }
 472         state.scale(sx, sy);
 473         if (cachedGraphics != null) {
 474             cachedGraphics.scale(sx, sy);
 475         }
 476     }
 477 
 478     public void rotate(float radians) {
 479         if (log.isLoggable(Level.FINE)) {
 480             log.fine(&quot;rotate(&quot; + radians + &quot;)&quot;);
 481         }
 482         state.rotate(radians);
 483         if (cachedGraphics != null) {
 484             cachedGraphics.setTransform(state.getTransformNoClone());
 485         }
 486     }
 487 
 488     // overriden in WCBufferedContext
 489     protected boolean shouldRenderRect(float x, float y, float w, float h,
 490                                        DropShadow shadow, BasicStroke stroke)
 491     {
 492         return true;
 493     }
 494 
 495     // overriden in WCBufferedContext
 496     protected boolean shouldRenderShape(Shape shape, DropShadow shadow, BasicStroke stroke) {
 497         return true;
 498     }
 499 
 500     // overriden in WCBufferedContext
 501     protected boolean shouldCalculateIntersection() {
 502         return false;
 503     }
 504 
 505     @Override
 506     public void fillRect(final float x, final float y, final float w, final float h, final Integer rgba) {
 507         if (log.isLoggable(Level.FINE)) {
 508             String format = (rgba != null)
 509                     ? &quot;fillRect(%f, %f, %f, %f, 0x%x)&quot;
 510                     : &quot;fillRect(%f, %f, %f, %f, null)&quot;;
 511             log.fine(String.format(format, x, y, w, h, rgba));
 512         }
 513         if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
 514             return;
 515         }
 516         new Composite() {
 517             @Override void doPaint(Graphics g) {
 518                 Paint paint = (rgba != null) ? createColor(rgba) : state.getPaintNoClone();
 519                 DropShadow shadow = state.getShadowNoClone();
 520                 // TextureMapperJava::drawSolidColor calls fillRect with perspective
 521                 // projection.
 522                 if (shadow != null || !state.getPerspectiveTransformNoClone().isIdentity()) {
 523                     final NGRectangle node = new NGRectangle();
 524                     node.updateRectangle(x, y, w, h, 0, 0);
 525                     render(g, shadow, paint, null, node);
 526                 } else {
 527                     g.setPaint(paint);
 528                     g.fillRect(x, y, w, h);
 529                 }
 530             }
 531         }.paint();
 532     }
 533 
 534     @Override
 535     public void fillRoundedRect(final float x, final float y, final float w, final float h,
 536         final float topLeftW, final float topLeftH, final float topRightW, final float topRightH,
 537         final float bottomLeftW, final float bottomLeftH, final float bottomRightW, final float bottomRightH,
 538         final int rgba)
 539     {
 540         if (log.isLoggable(Level.FINE)) {
 541             log.fine(String.format(&quot;fillRoundedRect(%f, %f, %f, %f, &quot;
 542                     + &quot;%f, %f, %f, %f, %f, %f, %f, %f, 0x%x)&quot;,
 543                     x, y, w, h, topLeftW, topLeftH, topRightW, topRightH,
 544                     bottomLeftW, bottomLeftH, bottomRightW, bottomRightH, rgba));
 545         }
 546         if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
 547             return;
 548         }
 549         new Composite() {
 550             @Override void doPaint(Graphics g) {
 551                 // Prism only supports single arcWidth/Height.
 552                 // We work around by calculating average width and height here
 553 
 554                 float arcW = (topLeftW + topRightW + bottomLeftW + bottomRightW) / 2;
 555                 float arcH = (topLeftH + topRightH + bottomLeftH + bottomRightH) / 2;
 556 
 557                 Paint paint = createColor(rgba);
 558                 DropShadow shadow = state.getShadowNoClone();
 559                 if (shadow != null) {
 560                     final NGRectangle node = new NGRectangle();
 561                     node.updateRectangle(x, y, w, h, arcW, arcH);
 562                     render(g, shadow, paint, null, node);
 563                 } else {
 564                     g.setPaint(paint);
 565                     g.fillRoundRect(x, y, w, h, arcW, arcH);
 566                 }
 567             }
 568         }.paint();
 569     }
 570 
 571     @Override
 572     public void clearRect(final float x, final float y, final float w, final float h) {
 573         if (log.isLoggable(Level.FINE)) {
 574             log.fine(String.format(&quot;clearRect(%f, %f, %f, %f)&quot;, x, y, w, h));
 575         }
 576         if (shouldCalculateIntersection()) {
 577             // No intersection is applicable for clearRect.
 578             return;
 579         }
 580         new Composite() {
 581             @Override void doPaint(Graphics g) {
 582                 g.clearQuad(x, y, x + w, y + h);
 583             }
 584         }.paint();
 585     }
 586 
 587     @Override
 588     public void setFillColor(int rgba) {
 589         if (log.isLoggable(Level.FINE)) {
 590             log.fine(String.format(&quot;setFillColor(0x%x)&quot;, rgba));
 591         }
 592         state.setPaint(createColor(rgba));
 593     }
 594 
 595     @Override
 596     public void setFillGradient(WCGradient gradient) {
 597         if (log.isLoggable(Level.FINE)) {
 598             log.fine(&quot;setFillGradient(&quot; + gradient + &quot;)&quot;);
 599         }
 600         state.setPaint((Gradient) gradient.getPlatformGradient());
 601     }
 602 
 603     @Override
 604     public void setTextMode(boolean fill, boolean stroke, boolean clip) {
 605         if (log.isLoggable(Level.FINE)) {
 606             log.fine(&quot;setTextMode(fill:&quot; + fill + &quot;,stroke:&quot; + stroke + &quot;,clip:&quot; + clip + &quot;)&quot;);
 607         }
 608         state.setTextMode(fill, stroke, clip);
 609     }
 610 
 611     @Override
 612     public void setFontSmoothingType(int fontSmoothingType) {
 613         this.fontSmoothingType = fontSmoothingType;
 614     }
 615 
 616     @Override
 617     public int getFontSmoothingType() {
 618         return fontSmoothingType;
 619     }
 620 
 621     @Override
 622     public void setStrokeStyle(int style) {
 623         if (log.isLoggable(Level.FINE)) {
 624             log.fine(&quot;setStrokeStyle({0})&quot;, style);
 625         }
 626         state.getStrokeNoClone().setStyle(style);
 627     }
 628 
 629     @Override
 630     public void setStrokeColor(int rgba) {
 631         if (log.isLoggable(Level.FINE)) {
 632             log.fine(String.format(&quot;setStrokeColor(0x%x)&quot;, rgba));
 633         }
 634         state.getStrokeNoClone().setPaint(createColor(rgba));
 635     }
 636 
 637     @Override
 638     public void setStrokeWidth(float width) {
 639         if (log.isLoggable(Level.FINE)) {
 640             log.fine(&quot;setStrokeWidth({0})&quot;, new Object[] { width });
 641         }
 642         state.getStrokeNoClone().setThickness(width);
 643     }
 644 
 645     @Override
 646     public void setStrokeGradient(WCGradient gradient) {
 647         if (log.isLoggable(Level.FINE)) {
 648             log.fine(&quot;setStrokeGradient(&quot; + gradient + &quot;)&quot;);
 649         }
 650         state.getStrokeNoClone().setPaint((Gradient) gradient.getPlatformGradient());
 651     }
 652 
 653     @Override
 654     public void setLineDash(float offset, float... sizes) {
 655         if (log.isLoggable(Level.FINE)) {
 656             StringBuilder s = new StringBuilder(&quot;[&quot;);
 657             for (int i=0; i &lt; sizes.length; i++) {
 658                 s.append(sizes[i]).append(&#39;,&#39;);
 659             }
 660             s.append(&#39;]&#39;);
 661             log.fine(&quot;setLineDash({0},{1}&quot;, new Object[] {offset, s});
 662         }
 663         state.getStrokeNoClone().setDashOffset(offset);
 664         if (sizes != null) {
 665             boolean allZero = true;
 666             for (int i = 0; i &lt; sizes.length; i++) {
 667                 if (sizes[i] != 0) {
 668                     allZero = false;
 669                     break;
 670                 }
 671             }
 672             if (allZero) {
 673                 sizes = null;
 674             }
 675         }
 676         state.getStrokeNoClone().setDashSizes(sizes);
 677     }
 678 
 679     @Override
 680     public void setLineCap(int lineCap) {
 681         if (log.isLoggable(Level.FINE)) {
 682             log.fine(&quot;setLineCap(&quot; + lineCap + &quot;)&quot;);
 683         }
 684         state.getStrokeNoClone().setLineCap(lineCap);
 685     }
 686 
 687     @Override
 688     public void setLineJoin(int lineJoin) {
 689         if (log.isLoggable(Level.FINE)) {
 690             log.fine(&quot;setLineJoin(&quot; + lineJoin + &quot;)&quot;);
 691         }
 692         state.getStrokeNoClone().setLineJoin(lineJoin);
 693     }
 694 
 695     @Override
 696     public void setMiterLimit(float miterLimit) {
 697         if (log.isLoggable(Level.FINE)) {
 698             log.fine(&quot;setMiterLimit(&quot; + miterLimit + &quot;)&quot;);
 699         }
 700         state.getStrokeNoClone().setMiterLimit(miterLimit);
 701     }
 702 
 703     @Override
 704     public void setShadow(float dx, float dy, float blur, int rgba) {
 705         if (log.isLoggable(Level.FINE)) {
 706             String format = &quot;setShadow(%f, %f, %f, 0x%x)&quot;;
 707             log.fine(String.format(format, dx, dy, blur, rgba));
 708         }
 709         state.setShadow(createShadow(dx, dy, blur, rgba));
 710     }
 711 
 712     @Override
 713     public void drawPolygon(final WCPath path, final boolean shouldAntialias) {
 714         if (log.isLoggable(Level.FINE)) {
 715             log.fine(&quot;drawPolygon({0})&quot;,
 716                     new Object[] {shouldAntialias});
 717         }
 718         if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(), null,
 719                                 state.getStrokeNoClone().getPlatformStroke()))
 720         {
 721             return;
 722         }
 723         new Composite() {
 724             @Override void doPaint(Graphics g) {
 725                 Path2D p2d = (Path2D) path.getPlatformPath();
 726                 g.setPaint(state.getPaintNoClone());
 727                 g.fill(p2d);
 728                 if (state.getStrokeNoClone().apply(g)) {
 729                     g.draw(p2d);
 730                 }
 731             }
 732         }.paint();
 733     }
 734 
 735     @Override
 736     public void drawLine(final int x0, final int y0, final int x1, final int y1) {
 737         if (log.isLoggable(Level.FINE)) {
 738             log.fine(&quot;drawLine({0}, {1}, {2}, {3})&quot;,
 739                     new Object[] {x0, y0, x1, y1});
 740         }
 741         Line2D line = new Line2D(x0, y0, x1, y1);
 742         if (!shouldRenderShape(line, null, state.getStrokeNoClone().getPlatformStroke())) {
 743             return;
 744         }
 745         new Composite() {
 746             @Override void doPaint(Graphics g) {
 747                 if (state.getStrokeNoClone().apply(g)) {
 748                     g.drawLine(x0, y0, x1, y1);
 749                 }
 750             }
 751         }.paint();
 752     }
 753 
 754     @Override
 755     public void drawPattern(
 756         final WCImage texture,
 757         final WCRectangle srcRect,
 758         final WCTransform patternTransform,
 759         final WCPoint phase,
 760         final WCRectangle destRect)
 761     {
 762         if (log.isLoggable(Level.FINE)) {
 763             log.fine(&quot;drawPattern({0}, {1}, {2}, {3})&quot;,
 764                     new Object[] {destRect.getIntX(), destRect.getIntY(),
 765                                   destRect.getIntWidth(),
 766                                   destRect.getIntHeight()});
 767         }
 768         if (!shouldRenderRect(destRect.getX(), destRect.getY(),
 769                               destRect.getWidth(), destRect.getHeight(), null, null))
 770         {
 771             return;
 772         }
 773         if (texture != null) {
 774             new Composite() {
 775                 @Override void doPaint(Graphics g) {
 776                     // The handling of pattern transform is modeled after the WebKit
 777                     // ImageCG.cpp&#39;s Image::drawPattern()
 778                     float adjustedX = phase.getX()
 779                             + srcRect.getX() * (float) patternTransform.getMatrix()[0];
 780                     float adjustedY = phase.getY()
 781                             + srcRect.getY() * (float) patternTransform.getMatrix()[3];
 782                     float scaledTileWidth =
 783                             srcRect.getWidth() * (float) patternTransform.getMatrix()[0];
 784                     float scaledTileHeight =
 785                             srcRect.getHeight() * (float) patternTransform.getMatrix()[3];
 786 
 787                     Image img = ((PrismImage)texture).getImage();
 788 
 789                     // Create subImage only if srcRect doesn&#39;t fit the texture bounds. See RT-20193.
 790                     if (!srcRect.contains(new WCRectangle(0, 0, texture.getWidth(), texture.getHeight()))) {
 791 
 792                         img = img.createSubImage(srcRect.getIntX(),
 793                                                  srcRect.getIntY(),
 794                                                  (int)Math.ceil(srcRect.getWidth()),
 795                                                  (int)Math.ceil(srcRect.getHeight()));
 796                     }
 797                     g.setPaint(new ImagePattern(
 798                                img,
 799                                adjustedX, adjustedY,
 800                                scaledTileWidth, scaledTileHeight,
 801                                false, false));
 802 
 803                     g.fillRect(destRect.getX(), destRect.getY(),
 804                                destRect.getWidth(), destRect.getHeight());
 805                 }
 806             }.paint();
 807         }
 808     }
 809 
 810     @Override
 811     public void drawImage(final WCImage img,
 812                           final float dstx, final float dsty, final float dstw, final float dsth,
 813                           final float srcx, final float srcy, final float srcw, final float srch)
 814     {
 815         if (log.isLoggable(Level.FINE)){
 816             log.fine(&quot;drawImage(img, dst({0},{1},{2},{3}), &quot; +
 817                     &quot;src({4},{5},{6},{7}))&quot;,
 818                     new Object[] {dstx, dsty, dstw, dsth,
 819                                   srcx, srcy, srcw, srch});
 820         }
 821         if (!shouldRenderRect(dstx, dsty, dstw, dsth, state.getShadowNoClone(), null)) {
 822             return;
 823         }
 824         if (img instanceof PrismImage) {
 825             new Composite() {
 826                 @Override void doPaint(Graphics g) {
 827                     PrismImage pi = (PrismImage) img;
 828                     DropShadow shadow = state.getShadowNoClone();
 829                     if (shadow != null) {
 830                         NGImageView node = new NGImageView();
 831                         node.setImage(pi.getImage());
 832                         node.setX(dstx);
 833                         node.setY(dsty);
 834                         node.setViewport(srcx, srcy, srcw, srch, dstw, dsth);
 835                         node.setContentBounds(new RectBounds(dstx, dsty, dstx + dstw, dsty + dsth));
 836                         render(g, shadow, null, null, node);
 837                     } else {
 838                         pi.draw(g,
 839                                 (int) dstx, (int) dsty,
 840                                 (int) (dstx + dstw), (int) (dsty + dsth),
 841                                 (int) srcx, (int) srcy,
 842                                 (int) (srcx + srcw), (int) (srcy + srch));
 843                     }
 844                 }
 845             }.paint();
 846         }
 847     }
 848 
 849     @Override
 850     public void drawBitmapImage(final ByteBuffer image, final int x, final int y, final int w, final int h) {
 851         if (!shouldRenderRect(x, y, w, h, null, null)) {
 852             return;
 853         }
 854         new Composite() {
 855             @Override void doPaint(Graphics g) {
 856                 image.order(ByteOrder.nativeOrder());
 857                 Image img = Image.fromByteBgraPreData(image, w, h);
 858                 ResourceFactory rf = g.getResourceFactory();
 859                 Texture txt = rf.createTexture(img, Texture.Usage.STATIC, Texture.WrapMode.REPEAT);
 860                 g.drawTexture(txt, x, y, x + w, y + h, 0, 0, w, h);
 861                 txt.dispose();
 862             }
 863         }.paint();
 864     }
 865 
 866     @Override
 867     public void drawIcon(WCIcon icon, int x, int y) {
 868         if (log.isLoggable(Level.FINE)) {
 869             log.fine(&quot;UNIMPLEMENTED drawIcon ({0}, {1})&quot;,
 870                     new Object[] {x, y});
 871         }
 872     }
 873 
 874     @Override
 875     public void drawRect(final int x, final int y, final int w, final int h) {
 876         if (log.isLoggable(Level.FINE)) {
 877             log.fine(&quot;drawRect({0}, {1}, {2}, {3})&quot;,
 878                     new Object[]{x, y, w, h});
 879         }
 880         if (!shouldRenderRect(x, y, w, h,
 881                               null, state.getStrokeNoClone().getPlatformStroke()))
 882         {
 883             return;
 884         }
 885         new Composite() {
 886             @Override void doPaint(Graphics g) {
 887                 Paint c = state.getPaintNoClone();
 888                 if (c != null &amp;&amp; c.isOpaque()) {
 889                     g.setPaint(c);
 890                     g.fillRect(x, y, w, h);
 891                 }
 892 
 893                 if (state.getStrokeNoClone().apply(g)) {
 894                     g.drawRect(x, y, w, h);
 895                 }
 896             }
 897         }.paint();
 898     }
 899 
 900     @Override
 901     public void drawString(final WCFont f, final int[] glyphs,
 902                            final float[] advances, final float x, final float y)
 903     {
 904         if (log.isLoggable(Level.FINE)) {
 905             log.fine(String.format(
 906                     &quot;Drawing %d glyphs @(%.1f, %.1f)&quot;,
 907                     glyphs.length, x, y));
 908         }
 909         PGFont font = (PGFont)f.getPlatformFont();
 910         TextRun gl = TextUtilities.createGlyphList(glyphs, advances, x, y);
 911 
 912         DropShadow shadow = state.getShadowNoClone();
 913         BasicStroke stroke = state.isTextStroke()
 914                 ? state.getStrokeNoClone().getPlatformStroke()
 915                 : null;
 916 
 917         final FontStrike strike = font.getStrike(getTransformNoClone(), getFontSmoothingType());
 918         if (shouldCalculateIntersection()) {
 919             Metrics m = strike.getMetrics();
 920             gl.setMetrics(m.getAscent(), m.getDescent(), m.getLineGap());
 921             if (!shouldRenderRect(x, y, gl.getWidth(), gl.getHeight(), shadow, stroke)) {
 922                 return;
 923             }
 924         }
 925         new Composite() {
 926             @Override void doPaint(Graphics g) {
 927                 Paint paint = state.isTextFill()
 928                         ? state.getPaintNoClone()
 929                         : null;
 930                 if (shadow != null) {
 931                     final NGText span = new NGText();
 932                     span.setGlyphs(new GlyphList[] {gl});
 933                     span.setFont(font);
 934                     span.setFontSmoothingType(fontSmoothingType);
 935                     render(g, shadow, paint, stroke, span);
 936                 } else {
 937                     if (paint != null) {
 938                         g.setPaint(paint);
 939                         g.drawString(gl, strike, x, y, null, 0, 0);
 940                     }
 941                     if (stroke != null) {
 942                         paint = state.getStrokeNoClone().getPaint();
 943                         if (paint != null) {
 944                             g.setPaint(paint);
 945                             g.setStroke(stroke);
 946                             g.draw(strike.getOutline(gl, BaseTransform.getTranslateInstance(x, y)));
 947                         }
 948                     }
 949                 }
 950             }
 951         }.paint();
 952     }
 953 
 954     @Override public void drawString(WCFont f, String str, boolean rtl,
 955             int from, int to, float x, float y)
 956     {
 957         if (log.isLoggable(Level.FINE)) {
 958             log.fine(String.format(
 959                     &quot;str=&#39;%s&#39; (length=%d), from=%d, to=%d, rtl=%b, @(%.1f, %.1f)&quot;,
 960                     str, str.length(), from, to, rtl, x, y));
 961         }
 962         TextLayout layout = TextUtilities.createLayout(
 963                 str.substring(from, to), f.getPlatformFont());
 964         int count = 0;
 965         GlyphList[] runs = layout.getRuns();
 966         for (GlyphList run: runs) {
 967             count += run.getGlyphCount();
 968         }
 969 
 970         int[] glyphs = new int[count];
 971         float[] adv = new float[count];
 972         count = 0;
 973         for (GlyphList run: layout.getRuns()) {
 974             int gc = run.getGlyphCount();
 975             for (int i = 0; i &lt; gc; i++) {
 976                 glyphs[count] = run.getGlyphCode(i);
 977                 adv[count] = run.getPosX(i + 1) - run.getPosX(i);
 978                 count++;
 979             }
 980         }
 981 
 982         // adjust x coordinate (see RT-29908)
 983         if (rtl) {
 984             x += (TextUtilities.getLayoutWidth(str.substring(from), f.getPlatformFont()) -
 985                   layout.getBounds().getWidth());
 986         } else {
 987             x += TextUtilities.getLayoutWidth(str.substring(0, from), f.getPlatformFont());
 988         }
 989         drawString(f, glyphs, adv, x, y);
 990     }
 991 
 992     @Override
 993     public void setComposite(int composite) {
 994         log.fine(&quot;setComposite({0})&quot;, composite);
 995         state.setCompositeOperation(composite);
 996     }
 997 
 998     @Override
 999     public void drawEllipse(final int x, final int y, final int w, final int h) {
1000         if (log.isLoggable(Level.FINE)) {
1001             log.fine(&quot;drawEllipse({0}, {1}, {2}, {3})&quot;,
1002                     new Object[] { x, y, w, h});
1003         }
1004         if (!shouldRenderRect(x, y, w, h,
1005                               null, state.getStrokeNoClone().getPlatformStroke()))
1006         {
1007             return;
1008         }
1009         new Composite() {
1010             @Override void doPaint(Graphics g) {
1011                 g.setPaint(state.getPaintNoClone());
1012                 g.fillEllipse(x, y, w, h);
1013                 if (state.getStrokeNoClone().apply(g)) {
1014                     g.drawEllipse(x, y, w, h);
1015                 }
1016             }
1017         }.paint();
1018     }
1019 
1020     private final static BasicStroke focusRingStroke =
1021         new BasicStroke(1.1f, BasicStroke.CAP_BUTT,
1022                          BasicStroke.JOIN_ROUND, 0.0f,
1023                          new float[] {1.0f}, 0.0f);
1024 
1025     @Override
1026     public void drawFocusRing(final int x, final int y, final int w, final int h, final int rgba) {
1027         if (log.isLoggable(Level.FINE)) {
1028             log.fine(String.format(&quot;drawFocusRing: %d, %d, %d, %d, 0x%x&quot;, x, y, w, h, rgba));
1029         }
1030         if (!shouldRenderRect(x, y, w, h, null, focusRingStroke)) {
1031             return;
1032         }
1033         new Composite() {
1034             @Override void doPaint(Graphics g) {
1035                 g.setPaint(createColor(rgba));
1036                 BasicStroke stroke = g.getStroke();
1037                 g.setStroke(focusRingStroke);
1038                 g.drawRoundRect(x, y, w, h, 4, 4);
1039                 g.setStroke(stroke);
1040             }
1041         }.paint();
1042     }
1043 
1044     public void setAlpha(float alpha) {
1045         log.fine(&quot;setAlpha({0})&quot;, alpha);
1046 
1047         state.setAlpha(alpha);
1048 
1049         if (null != cachedGraphics) {
1050             cachedGraphics.setExtraAlpha(state.getAlpha());
1051         }
1052     }
1053 
1054     public float getAlpha() {
1055         return state.getAlpha();
1056     }
1057 
1058     @Override public void beginTransparencyLayer(float opacity) {
1059         TransparencyLayer layer = new TransparencyLayer(
1060                 getGraphics(false), state.getClipNoClone(), opacity);
1061 
1062         if (log.isLoggable(Level.FINE)) {
1063             log.fine(String.format(&quot;beginTransparencyLayer(%s)&quot;, layer));
1064         }
1065 
1066         //[saveStateIntertal] will work as [saveState]
1067         state.markAsRestorePoint();
1068 
1069         startNewLayer(layer);
1070     }
1071 
1072     @Override public void endTransparencyLayer() {
1073         if (log.isLoggable(Level.FINE)) {
1074             log.fine(String.format(&quot;endTransparencyLayer(%s)&quot;, state.getLayerNoClone()));
1075         }
1076 
1077         //pair to [startNewLayer] that works as [saveState] call
1078         restoreState();
1079     }
1080 
1081     @Override
1082     public void drawWidget(final RenderTheme theme, final Ref widget, final int x, final int y) {
1083         WCSize s = theme.getWidgetSize(widget);
1084         if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
1085             return;
1086         }
1087         new Composite() {
1088             @Override void doPaint(Graphics g) {
1089                 theme.drawWidget(WCGraphicsPrismContext.this, widget, x, y);
1090             }
1091         }.paint();
1092     }
1093 
1094     @Override
1095     public void drawScrollbar(final ScrollBarTheme theme, final Ref widget, int x, int y,
1096                               int pressedPart, int hoveredPart)
1097     {
1098         if (log.isLoggable(Level.FINE)) {
1099             log.fine(String.format(&quot;drawScrollbar(%s, %s, x = %d, y = %d)&quot;, theme, widget, x, y));
1100         }
1101 
1102         WCSize s = theme.getWidgetSize(widget);
1103         if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
1104             return;
1105         }
1106         new Composite() {
1107             @Override void doPaint(Graphics g) {
1108                 theme.paint(WCGraphicsPrismContext.this, widget, x, y, pressedPart, hoveredPart);
1109             }
1110         }.paint();
1111     }
1112 
1113     private static Rectangle intersect(Rectangle what, Rectangle with) {
1114         if (what == null) {
1115             return with;
1116         }
1117         RectBounds b = what.toRectBounds();
1118         b.intersectWith(with);
1119         what.setBounds(b);
1120         return what;
1121     }
1122 
1123     static Color createColor(int rgba) {
1124         float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
1125         float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
1126         float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
1127         float b = (0xFF &amp; (rgba)) / 255.0f;
1128         return new Color(r, g, b, a);
1129     }
1130 
1131     private static Color4f createColor4f(int rgba) {
1132         float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
1133         float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
1134         float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
1135         float b = (0xFF &amp; (rgba)) / 255.0f;
1136         return new Color4f(r, g, b, a);
1137     }
1138 
1139     private DropShadow createShadow(float dx, float dy, float blur, int rgba) {
1140         if (dx == 0f &amp;&amp; dy == 0f &amp;&amp; blur == 0f) {
1141             return null;
1142         }
1143         DropShadow shadow = new DropShadow();
1144         shadow.setOffsetX((int) dx);
1145         shadow.setOffsetY((int) dy);
1146         shadow.setRadius((blur &lt; 0f) ? 0f : (blur &gt; 127f) ? 127f : blur);
1147         shadow.setColor(createColor4f(rgba));
1148         return shadow;
1149     }
1150 
1151     private void render(Graphics g, Effect effect, Paint paint, BasicStroke stroke, NGNode node) {
1152         if (node instanceof NGShape) {
1153             NGShape shape = (NGShape) node;
1154             Shape realShape = shape.getShape();
1155             Paint strokePaint = state.getStrokeNoClone().getPaint();
1156             if ((stroke != null) &amp;&amp; (strokePaint != null)) {
1157                 realShape = stroke.createStrokedShape(realShape);
1158                 shape.setDrawStroke(stroke);
1159                 shape.setDrawPaint(strokePaint);
1160                 shape.setMode((paint == null) ? NGShape.Mode.STROKE : NGShape.Mode.STROKE_FILL);
1161             } else {
1162                 shape.setMode((paint == null) ? NGShape.Mode.EMPTY : NGShape.Mode.FILL);
1163             }
1164             shape.setFillPaint(paint);
1165             shape.setContentBounds(realShape.getBounds());
1166         }
1167         boolean culling = g.hasPreCullingBits();
1168         g.setHasPreCullingBits(false);
1169         node.setEffect(effect);
1170         node.render(g);
1171         g.setHasPreCullingBits(culling);
1172     }
1173 
1174     private static final class ContextState {
1175         private final WCStrokeImpl stroke = new WCStrokeImpl();
1176         private Rectangle clip;
1177         private Paint paint;
1178         private float alpha;
1179 
1180         private boolean textFill = true;
1181         private boolean textStroke = false;
1182         private boolean textClip = false;
1183         private boolean restorePoint = false;
1184 
1185         private DropShadow shadow;
1186         private Affine3D xform;
1187         private GeneralTransform3D perspectiveTransform;
1188         private Layer layer;
1189         private int compositeOperation;
1190 
1191         private ContextState() {
1192             clip = null;
1193             paint = Color.BLACK;
1194             stroke.setPaint(Color.BLACK);
1195             alpha = 1.0f;
1196             xform = new Affine3D();
1197             perspectiveTransform = new GeneralTransform3D();
1198             compositeOperation = COMPOSITE_SOURCE_OVER;
1199         }
1200 
1201         private ContextState(ContextState state) {
1202             stroke.copyFrom(state.getStrokeNoClone());
1203             setPaint(state.getPaintNoClone());
1204             clip = state.getClipNoClone();
1205             if (clip != null) {
1206                 clip = new Rectangle(clip);
1207             }
1208             xform = new Affine3D(state.getTransformNoClone());
1209             perspectiveTransform = new GeneralTransform3D().set(state.getPerspectiveTransformNoClone());
1210             setShadow(state.getShadowNoClone());
1211             setLayer(state.getLayerNoClone());
1212             setAlpha(state.getAlpha());
1213             setTextMode(state.isTextFill(), state.isTextStroke(), state.isTextClip());
1214             setCompositeOperation(state.getCompositeOperation());
1215         }
1216 
1217         @Override
1218         protected ContextState clone() {
1219             return new ContextState(this);
1220         }
1221 
1222         private void apply(Graphics g) {
1223             g.setTransform(getTransformNoClone());
1224             g.setPerspectiveTransform(getPerspectiveTransformNoClone());
1225             g.setClipRect(getClipNoClone());
1226             g.setExtraAlpha(getAlpha());
1227         }
1228 
1229         private int getCompositeOperation() {
1230             return compositeOperation;
1231         }
1232 
1233         private void setCompositeOperation(int compositeOperation) {
1234             this.compositeOperation = compositeOperation;
1235         }
1236 
1237         private WCStrokeImpl getStrokeNoClone() {
1238             return stroke;
1239         }
1240 
1241         private Paint getPaintNoClone() {
1242             return paint;
1243         }
1244 
1245         private void setPaint(Paint paint) {
1246             this.paint = paint;
1247         }
1248 
1249         private Rectangle getClipNoClone() {
1250             return clip;
1251         }
1252 
1253         private Layer getLayerNoClone() {
1254             return layer;
1255         }
1256 
1257         private void setLayer(Layer layer) {
1258             this.layer = layer;
1259         }
1260 
1261         private void setClip(Rectangle area) {
1262             clip = area;
1263         }
1264 
1265         private void clip(Rectangle area) {
1266             if (null == clip) {
1267                 clip = area;
1268             } else {
1269                 clip.intersectWith(area);
1270             }
1271         }
1272 
1273         private void setAlpha(float alpha) {
1274             this.alpha = alpha;
1275         }
1276 
1277         private float getAlpha() {
1278             return alpha;
1279         }
1280 
1281         private void setTextMode(boolean fill, boolean stroke, boolean clip) {
1282             textFill = fill;
1283             textStroke = stroke;
1284             textClip = clip;
1285         }
1286 
1287         private boolean isTextFill() {
1288             return textFill;
1289         }
1290 
1291         private boolean isTextStroke() {
1292             return textStroke;
1293         }
1294 
1295         private boolean isTextClip() {
1296             return textClip;
1297         }
1298 
1299         private void markAsRestorePoint() {
1300             restorePoint = true;
1301         }
1302 
1303         private boolean isRestorePoint() {
1304             return restorePoint;
1305         }
1306 
1307         private void setShadow(DropShadow shadow) {
1308             this.shadow = shadow;
1309         }
1310 
1311         private DropShadow getShadowNoClone() {
1312             return shadow;
1313         }
1314 
1315         private Affine3D getTransformNoClone() {
1316             return xform;
1317         }
1318 
1319         private GeneralTransform3D getPerspectiveTransformNoClone() {
1320             return perspectiveTransform;
1321         }
1322 
1323         private void setTransform(final Affine3D at) {
1324             this.xform.setTransform(at);
1325         }
1326 
1327         private void setPerspectiveTransform(final GeneralTransform3D gt) {
1328             this.perspectiveTransform.set(gt);
1329         }
1330 
1331         private void concatTransform(Affine3D at) {
1332             xform.concatenate(at);
1333         }
1334 
1335         private void translate(double dx, double dy) {
1336             xform.translate(dx, dy);
1337         }
1338 
1339         private void scale(double sx, double sy) {
1340             xform.scale(sx,sy);
1341         }
1342 
1343         private void rotate(double radians) {
1344             xform.rotate(radians);
1345         }
1346     }
1347 
1348     private abstract static class Layer {
1349         FilterContext fctx;
1350         PrDrawable buffer;
1351         Graphics graphics;
1352         final Rectangle bounds;
1353         boolean permanent;
1354 
1355         Layer(Graphics g, Rectangle bounds, boolean permanent) {
1356             this.bounds = new Rectangle(bounds);
1357             this.permanent = permanent;
1358 
1359             // avoid creating zero-size drawable, see also RT-21410
1360             int w = Math.max(bounds.width, 1);
1361             int h = Math.max(bounds.height, 1);
1362             fctx = getFilterContext(g);
1363             if (permanent) {
1364                 ResourceFactory f = GraphicsPipeline.getDefaultResourceFactory();
1365                 RTTexture rtt = f.createRTTexture(w, h, Texture.WrapMode.CLAMP_NOT_NEEDED);
1366                 rtt.makePermanent();
1367                 buffer = ((PrRenderer)Renderer.getRenderer(fctx)).createDrawable(rtt);
1368             } else {
1369                 buffer = (PrDrawable) Effect.getCompatibleImage(fctx, w, h);
1370             }
1371         }
1372 
1373         Graphics getGraphics() {
1374             if (graphics == null) {
1375                 graphics = buffer.createGraphics();
1376             }
1377             return graphics;
1378         }
1379 
1380         abstract void init(Graphics g);
1381 
1382         abstract void render(Graphics g);
1383 
1384         private void dispose() {
1385             if (buffer != null) {
1386                 if (permanent) {
1387                     buffer.flush(); // releases the resource
1388                 } else {
1389                     Effect.releaseCompatibleImage(fctx, buffer);
1390                 }
1391                 fctx = null;
1392                 buffer = null;
1393             }
1394         }
1395 
1396         private double getX() { return (double) bounds.x; }
1397         private double getY() { return (double) bounds.y; }
1398     }
1399 
1400     private final class TransparencyLayer extends Layer {
1401         private final float opacity;
1402 
1403         private TransparencyLayer(Graphics g, Rectangle bounds, float opacity) {
1404             super(g, bounds, false);
1405             this.opacity = opacity;
1406         }
1407 
1408         @Override void init(Graphics g) {
1409             state.setCompositeOperation(COMPOSITE_SOURCE_OVER);
1410         }
1411 
1412         @Override void render(Graphics g) {
1413             new Composite() {
1414                 @Override void doPaint(Graphics g) {
1415                     float op = g.getExtraAlpha();
1416                     g.setExtraAlpha(opacity);
1417                     Affine3D tx = new Affine3D(g.getTransformNoClone());
1418                     g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
1419                     g.drawTexture(buffer.getTextureObject(),
1420                             bounds.x, bounds.y, bounds.width, bounds.height);
1421                     g.setTransform(tx);
1422                     g.setExtraAlpha(op);
1423                 }
1424             }.paint(g);
1425         }
1426 
1427         @Override public String toString() {
1428             return String.format(&quot;TransparencyLayer[%d,%d + %dx%d, opacity %.2f]&quot;,
1429                 bounds.x, bounds.y, bounds.width, bounds.height, opacity);
1430         }
1431     }
1432 
1433     private static final class ClipLayer extends Layer {
1434         private final WCPath normalizedToClipPath;
1435         private boolean srcover;
1436 
1437         private ClipLayer(Graphics g, Rectangle bounds, WCPath normalizedToClipPath,
1438                           boolean permanent)
1439         {
1440             super(g, bounds, permanent);
1441             this.normalizedToClipPath = normalizedToClipPath;
1442             srcover = true;
1443         }
1444 
1445         @Override void init(Graphics g) {
1446             RTTexture texture = null;
1447             ReadbackGraphics readbackGraphics = null;
1448             try {
1449                 readbackGraphics = (ReadbackGraphics) g;
1450                 texture = readbackGraphics.readBack(bounds);
1451                 getGraphics().drawTexture(texture, 0, 0, bounds.width, bounds.height);
1452             } finally {
1453                 if (readbackGraphics != null &amp;&amp; texture != null) {
1454                     readbackGraphics.releaseReadBackBuffer(texture);
1455                 }
1456             }
1457             srcover = false;
1458         }
1459 
1460         @Override void render(Graphics g) {
1461             Path2D p2d = ((WCPathImpl)normalizedToClipPath).getPlatformPath();
1462 
1463             // render normalizedToClipPath to a drawable
1464             PrDrawable bufferImg = (PrDrawable) Effect.getCompatibleImage(
1465                     fctx, bounds.width, bounds.height);
1466             Graphics bufferGraphics = bufferImg.createGraphics();
1467 
1468             bufferGraphics.setPaint(Color.BLACK);
1469             bufferGraphics.fill(p2d);
1470 
1471             // blend buffer and clipImg onto |g|
1472             if (g instanceof MaskTextureGraphics &amp;&amp; ! (g instanceof PrinterGraphics)) {
1473                 MaskTextureGraphics mg = (MaskTextureGraphics) g;
1474                 if (srcover) {
1475                     mg.drawPixelsMasked(buffer.getTextureObject(),
1476                                         bufferImg.getTextureObject(),
1477                                         bounds.x, bounds.y, bounds.width, bounds.height,
1478                                         0, 0, 0, 0);
1479                 } else {
1480                     mg.maskInterpolatePixels(buffer.getTextureObject(),
1481                                              bufferImg.getTextureObject(),
1482                                              bounds.x, bounds.y, bounds.width, bounds.height,
1483                                              0, 0, 0, 0);
1484                 }
1485             } else {
1486                 Blend blend = new Blend(Blend.Mode.SRC_IN,
1487                         new PassThrough(bufferImg, bounds.width, bounds.height),
1488                         new PassThrough(buffer, bounds.width, bounds.height));
1489                 Affine3D tx = new Affine3D(g.getTransformNoClone());
1490                 g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
1491                 PrEffectHelper.render(blend, g, bounds.x, bounds.y, null);
1492                 g.setTransform(tx);
1493             }
1494 
1495             Effect.releaseCompatibleImage(fctx, bufferImg);
1496         }
1497 
1498         @Override public String toString() {
1499             return String.format(&quot;ClipLayer[%d,%d + %dx%d, path %s]&quot;,
1500                     bounds.x, bounds.y, bounds.width, bounds.height,
1501                     normalizedToClipPath);
1502         }
1503     }
1504 
1505     private abstract class Composite {
1506         abstract void doPaint(Graphics g);
1507 
1508         void paint() {
1509             paint(getGraphics(true));
1510         }
1511 
1512         void paint(Graphics g) {
1513             if (g != null) {
1514                 CompositeMode oldCompositeMode = g.getCompositeMode();
1515                 switch (state.getCompositeOperation()) {
1516                     // decode operations that don&#39;t require Blend first
1517                     case COMPOSITE_COPY:
1518                         g.setCompositeMode(CompositeMode.SRC);
1519                         doPaint(g);
1520                         g.setCompositeMode(oldCompositeMode);
1521                         break;
1522                     case COMPOSITE_SOURCE_OVER:
1523                         g.setCompositeMode(CompositeMode.SRC_OVER);
1524                         doPaint(g);
1525                         g.setCompositeMode(oldCompositeMode);
1526                         break;
1527                     default:
1528                         // other operations require usage of Blend
1529                         blend(g);
1530                         break;
1531                 }
1532                 isRootLayerValid = false;
1533             }
1534         }
1535 
1536         private void blend(Graphics g) {
1537             FilterContext fctx = getFilterContext(g);
1538             PrDrawable dstImg = null;
1539             PrDrawable srcImg = null;
1540             ReadbackGraphics readBackGraphics = null;
1541             RTTexture texture = null;
1542             Rectangle clip = state.getClipNoClone();
1543             WCImage image = getImage();
1544             try {
1545                 if (image != null &amp;&amp; image instanceof PrismImage) {
1546                     // blending on canvas
1547                     dstImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
1548                     Graphics dstG = dstImg.createGraphics();
1549                     ((PrismImage) image).draw(dstG,
1550                             0, 0, clip.width, clip.height,
1551                             clip.x, clip.y, clip.width, clip.height);
1552                 } else {
1553                     // blending on page
1554                     readBackGraphics = (ReadbackGraphics) g;
1555                     texture = readBackGraphics.readBack(clip);
1556                     dstImg = PrDrawable.create(fctx, texture);
1557                 }
1558 
1559                 srcImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
1560                 Graphics srcG = srcImg.createGraphics();
1561                 state.apply(srcG);
1562                 doPaint(srcG);
1563 
1564                 g.clear();
1565                 PrEffectHelper.render(createEffect(dstImg, srcImg, clip.width, clip.height), g, 0, 0, null);
1566 
1567             } finally {
1568                 if (srcImg != null) {
1569                     Effect.releaseCompatibleImage(fctx, srcImg);
1570                 }
1571                 if (dstImg != null) {
1572                     if (readBackGraphics != null &amp;&amp; texture != null) {
1573                         readBackGraphics.releaseReadBackBuffer(texture);
1574                     } else {
1575                         Effect.releaseCompatibleImage(fctx, dstImg);
1576                     }
1577                 }
1578             }
1579         }
1580 
1581         // provides some syntax sugar for createEffect()
1582         private Effect createBlend(Blend.Mode mode,
1583                                    PrDrawable dstImg,
1584                                    PrDrawable srcImg,
1585                                    int width,
1586                                    int height)
1587         {
1588             return new Blend(
1589                     mode,
1590                     new PassThrough(dstImg, width, height),
1591                     new PassThrough(srcImg, width, height));
1592         }
1593 
1594         private Effect createEffect(PrDrawable dstImg,
1595                                     PrDrawable srcImg,
1596                                     int width,
1597                                     int height)
1598         {
1599             switch (state.getCompositeOperation()) {
1600                 case COMPOSITE_CLEAR: // same as xor
1601                 case COMPOSITE_XOR:
1602                     return new Blend(
1603                             SRC_OVER,
1604                             createBlend(SRC_OUT, dstImg, srcImg, width, height),
1605                             createBlend(SRC_OUT, srcImg, dstImg, width, height)
1606                     );
1607                 case COMPOSITE_SOURCE_IN:
1608                     return createBlend(SRC_IN, dstImg, srcImg, width, height);
1609                 case COMPOSITE_SOURCE_OUT:
1610                     return createBlend(SRC_OUT, dstImg, srcImg, width, height);
1611                 case COMPOSITE_SOURCE_ATOP:
1612                     return createBlend(SRC_ATOP, dstImg, srcImg, width, height);
1613                 case COMPOSITE_DESTINATION_OVER:
1614                     return createBlend(SRC_OVER, srcImg, dstImg, width, height);
1615                 case COMPOSITE_DESTINATION_IN:
1616                     return createBlend(SRC_IN, srcImg, dstImg, width, height);
1617                 case COMPOSITE_DESTINATION_OUT:
1618                     return createBlend(SRC_OUT, srcImg, dstImg, width, height);
1619                 case COMPOSITE_DESTINATION_ATOP:
1620                     return createBlend(SRC_ATOP, srcImg, dstImg, width, height);
1621                 case COMPOSITE_HIGHLIGHT:
1622                     return createBlend(ADD, dstImg, srcImg, width, height);
1623                 default:
1624                     return createBlend(SRC_OVER, dstImg, srcImg, width, height);
1625             }
1626         }
1627     }
1628 
1629     private static final class PassThrough extends Effect {
1630         private final PrDrawable img;
1631         private final int width;
1632         private final int height;
1633 
1634         private PassThrough(PrDrawable img, int width, int height) {
1635             this.img = img;
1636             this.width = width;
1637             this.height = height;
1638         }
1639 
1640         @Override public ImageData filter(
1641                 FilterContext fctx,
1642                 BaseTransform transform,
1643                 Rectangle outputClip,
1644                 Object renderHelper,
1645                 Effect defaultInput) {
1646             // We have an unpaired lock() here, because unlocking is done
1647             // internally by ImageData. See RT-33625 for details.
1648             img.lock();
1649             ImageData imgData = new ImageData(fctx, img, new Rectangle(
1650                                               (int) transform.getMxt(),
1651                                               (int) transform.getMyt(),
1652                                               width, height));
1653             imgData.setReusable(true);
1654             return imgData;
1655         }
1656 
1657         @Override public RectBounds getBounds(
1658                 BaseTransform transform,
1659                 Effect defaultInput) {
1660             return null;
1661         }
1662 
1663         @Override public AccelType getAccelType(FilterContext fctx) {
1664             return AccelType.INTRINSIC;
1665         }
1666 
1667         @Override
1668         public boolean reducesOpaquePixels() {
1669             return false;
1670         }
1671 
1672         @Override
1673         public DirtyRegionContainer getDirtyRegions(Effect defaultInput, DirtyRegionPool regionPool) {
1674             return null;
1675         }
1676     }
1677 
1678     private static FilterContext getFilterContext(Graphics g) {
1679         Screen screen = g.getAssociatedScreen();
1680         if (screen == null) {
1681             ResourceFactory factory = g.getResourceFactory();
1682             return PrFilterContext.getPrinterContext(factory);
1683         } else {
1684             return PrFilterContext.getInstance(screen);
1685         }
1686     }
1687 
1688     @Override
1689     public void strokeArc(final int x, final int y, final int w, final int h,
1690                           final int startAngle, final int angleSpan)
1691     {
1692         if (log.isLoggable(Level.FINE)) {
1693             log.fine(String.format(&quot;strokeArc(%d, %d, %d, %d, %d, %d)&quot;,
1694                                    x, y, w, h, startAngle, angleSpan));
1695         }
1696         Arc2D arc = new Arc2D(x, y, w, h, startAngle, angleSpan, Arc2D.OPEN);
1697         if (state.getStrokeNoClone().isApplicable() &amp;&amp;
1698             !shouldRenderShape(arc, null, state.getStrokeNoClone().getPlatformStroke()))
1699         {
1700             return;
1701         }
1702         new Composite() {
1703             @Override void doPaint(Graphics g) {
1704                 if (state.getStrokeNoClone().apply(g)) {
1705                     g.draw(arc);
1706                 }
1707             }
1708         }.paint();
1709     }
1710 
1711     @Override
1712     public WCImage getImage() {
1713         return null;
1714     }
1715 
1716     @Override
1717     public void strokeRect(final float x, final float y, final float w, final float h,
1718                            final float lineWidth) {
1719         if (log.isLoggable(Level.FINE)) {
1720             log.fine(String.format(&quot;strokeRect_FFFFF(%f, %f, %f, %f, %f)&quot;,
1721                                    x, y, w, h, lineWidth));
1722         }
1723         BasicStroke stroke = new BasicStroke(
1724             lineWidth,
1725             BasicStroke.CAP_BUTT,
1726             BasicStroke.JOIN_MITER,
1727             Math.max(1.0f, lineWidth),
1728             state.getStrokeNoClone().getDashSizes(),
1729             state.getStrokeNoClone().getDashOffset());
1730 
1731         if (!shouldRenderRect(x, y, w, h, null, stroke)) {
1732             return;
1733         }
1734         new Composite() {
1735             @Override void doPaint(Graphics g) {
1736                 g.setStroke(stroke);
1737                 Paint paint = state.getStrokeNoClone().getPaint();
1738                 if (paint == null) {
1739                     paint = state.getPaintNoClone();
1740                 }
1741                 g.setPaint(paint);
1742                 g.drawRect(x, y, w, h);
1743             }
1744         }.paint();
1745     }
1746 
1747     @Override
1748     public void strokePath(final WCPath path) {
1749         log.fine(&quot;strokePath&quot;);
1750         if (path != null) {
1751             final BasicStroke stroke = state.getStrokeNoClone().getPlatformStroke();
1752             final DropShadow shadow = state.getShadowNoClone();
1753             final Path2D p2d = (Path2D)path.getPlatformPath();
1754 
1755             if ((stroke == null &amp;&amp; shadow == null) ||
1756                 !shouldRenderShape(p2d, shadow, stroke))
1757             {
1758                 return;
1759             }
1760             new Composite() {
1761                 @Override void doPaint(Graphics g) {
1762                     if (shadow != null) {
1763                         final NGPath node = new NGPath();
1764                         node.updateWithPath2d(p2d);
1765                         render(g, shadow, null, stroke, node);
1766                     } else if (stroke != null) {
1767                         Paint paint = state.getStrokeNoClone().getPaint();
1768                         if (paint == null) {
1769                             paint = state.getPaintNoClone();
1770                         }
1771                         g.setPaint(paint);
1772                         g.setStroke(stroke);
1773                         g.draw(p2d);
1774                     }
1775                 }
1776             }.paint();
1777         }
1778     }
1779 
1780     @Override
1781     public void fillPath(final WCPath path) {
1782         log.fine(&quot;fillPath&quot;);
1783         if (path != null) {
1784             if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(),
1785                                    state.getShadowNoClone(), null))
1786             {
1787                 return;
1788             }
1789             new Composite() {
1790                 @Override void doPaint(Graphics g) {
1791                     Path2D p2d = (Path2D) path.getPlatformPath();
1792                     Paint paint = state.getPaintNoClone();
1793                     DropShadow shadow = state.getShadowNoClone();
1794                     if (shadow != null) {
1795                         final NGPath node = new NGPath();
1796                         node.updateWithPath2d(p2d);
1797                         render(g, shadow, paint, null, node);
1798                     } else {
1799                         g.setPaint(paint);
1800                         g.fill(p2d);
1801                     }
1802                 }
1803             }.paint();
1804         }
1805     }
1806 
1807     public void setPerspectiveTransform(WCTransform tm) {
1808         final GeneralTransform3D at = new GeneralTransform3D().set(tm.getMatrix());
1809         state.setPerspectiveTransform(at);
1810         resetCachedGraphics();
1811     }
1812 
1813     public void setTransform(WCTransform tm) {
1814         final double m[] = tm.getMatrix();
1815         final Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
1816         if (state.getLayerNoClone() == null) {
1817             at.preConcatenate(baseTransform);
1818         }
1819         state.setTransform(at);
1820         resetCachedGraphics();
1821     }
1822 
1823     public WCTransform getTransform() {
1824         Affine3D xf = state.getTransformNoClone();
1825         return new WCTransform(xf.getMxx(), xf.getMyx(),
1826                                xf.getMxy(), xf.getMyy(),
1827                                xf.getMxt(), xf.getMyt());
1828     }
1829 
1830     public void concatTransform(WCTransform tm) {
1831         double m[] = tm.getMatrix();
1832         Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
1833         state.concatTransform(at);
1834         resetCachedGraphics();
1835     }
1836 
1837     @Override
1838     public void flush() {
1839         flushAllLayers();
1840     }
1841 
1842     @Override
1843     public WCGradient createLinearGradient(WCPoint p1, WCPoint p2) {
1844         return new WCLinearGradient(p1, p2);
1845     }
1846 
1847     @Override
1848     public WCGradient createRadialGradient(WCPoint p1, float r1, WCPoint p2, float r2) {
1849         return new WCRadialGradient(p1, r1, p2, r2);
1850     }
1851 }
    </pre>
  </body>
</html>