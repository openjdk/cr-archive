<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/com/sun/prism/j2d/J2DPrismGraphics.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.prism.j2d;
  27 
  28 import java.awt.LinearGradientPaint;
  29 import java.awt.font.GlyphVector;
  30 import java.awt.geom.NoninvertibleTransformException;
  31 import java.awt.geom.Rectangle2D;
  32 import java.lang.ref.WeakReference;
  33 import java.util.List;
  34 import java.util.concurrent.ConcurrentHashMap;
  35 import com.sun.glass.ui.Screen;
  36 import com.sun.javafx.PlatformUtil;
  37 import com.sun.javafx.font.CompositeGlyphMapper;
  38 import com.sun.javafx.font.CompositeStrike;
  39 import com.sun.javafx.font.FontResource;
  40 import com.sun.javafx.font.FontStrike;
  41 import com.sun.javafx.font.Metrics;
  42 import com.sun.javafx.geom.PathIterator;
  43 import com.sun.javafx.geom.RectBounds;
  44 import com.sun.javafx.geom.Rectangle;
  45 import com.sun.javafx.geom.Shape;
  46 import com.sun.javafx.geom.transform.Affine2D;
  47 import com.sun.javafx.geom.transform.BaseTransform;
  48 import com.sun.javafx.geom.transform.GeneralTransform3D;
  49 import com.sun.javafx.scene.text.GlyphList;
  50 import com.sun.javafx.sg.prism.NGCamera;
  51 import com.sun.javafx.sg.prism.NGLightBase;
  52 import com.sun.javafx.sg.prism.NodePath;
  53 import com.sun.prism.BasicStroke;
  54 import com.sun.prism.CompositeMode;
  55 import com.sun.prism.MaskTextureGraphics;
  56 import com.sun.prism.RTTexture;
  57 import com.sun.prism.ReadbackGraphics;
  58 import com.sun.prism.RenderTarget;
  59 import com.sun.prism.ResourceFactory;
  60 import com.sun.prism.Texture;
  61 import com.sun.prism.Texture.WrapMode;
  62 import com.sun.prism.impl.PrismSettings;
  63 import com.sun.prism.j2d.paint.MultipleGradientPaint.ColorSpaceType;
  64 import com.sun.prism.j2d.paint.RadialGradientPaint;
  65 import com.sun.prism.paint.Color;
  66 import com.sun.prism.paint.Gradient;
  67 import com.sun.prism.paint.ImagePattern;
  68 import com.sun.prism.paint.LinearGradient;
  69 import com.sun.prism.paint.Paint;
  70 import com.sun.prism.paint.RadialGradient;
  71 import com.sun.prism.paint.Stop;
  72 import static java.awt.RenderingHints.KEY_ANTIALIASING;
  73 import static java.awt.RenderingHints.KEY_TEXT_ANTIALIASING;
  74 import static java.awt.RenderingHints.VALUE_ANTIALIAS_OFF;
  75 import static java.awt.RenderingHints.VALUE_ANTIALIAS_ON;
  76 import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB;
  77 import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON;
  78 
  79 public class J2DPrismGraphics
  80     // Do not subclass BaseGraphics without fixing drawTextureVO below...
  81     implements ReadbackGraphics, MaskTextureGraphics
  82     // Do not implement RectShadowGraphics without fixing RT-15016 (note that
  83     // BaseGraphics implements RectShadowGraphics).
  84 {
  85     static {
  86         // Assuming direct translation of BasicStroke enums:
  87         assert(com.sun.prism.BasicStroke.CAP_BUTT == java.awt.BasicStroke.CAP_BUTT);
  88         assert(com.sun.prism.BasicStroke.CAP_ROUND == java.awt.BasicStroke.CAP_ROUND);
  89         assert(com.sun.prism.BasicStroke.CAP_SQUARE == java.awt.BasicStroke.CAP_SQUARE);
  90         assert(com.sun.prism.BasicStroke.JOIN_BEVEL == java.awt.BasicStroke.JOIN_BEVEL);
  91         assert(com.sun.prism.BasicStroke.JOIN_MITER == java.awt.BasicStroke.JOIN_MITER);
  92         assert(com.sun.prism.BasicStroke.JOIN_ROUND == java.awt.BasicStroke.JOIN_ROUND);
  93         // Assuming direct translation of PathIterator enums:
  94         assert(com.sun.javafx.geom.PathIterator.WIND_EVEN_ODD == java.awt.geom.PathIterator.WIND_EVEN_ODD);
  95         assert(com.sun.javafx.geom.PathIterator.WIND_NON_ZERO == java.awt.geom.PathIterator.WIND_NON_ZERO);
  96         assert(com.sun.javafx.geom.PathIterator.SEG_MOVETO == java.awt.geom.PathIterator.SEG_MOVETO);
  97         assert(com.sun.javafx.geom.PathIterator.SEG_LINETO == java.awt.geom.PathIterator.SEG_LINETO);
  98         assert(com.sun.javafx.geom.PathIterator.SEG_QUADTO == java.awt.geom.PathIterator.SEG_QUADTO);
  99         assert(com.sun.javafx.geom.PathIterator.SEG_CUBICTO == java.awt.geom.PathIterator.SEG_CUBICTO);
 100         assert(com.sun.javafx.geom.PathIterator.SEG_CLOSE == java.awt.geom.PathIterator.SEG_CLOSE);
 101     }
 102     static final LinearGradientPaint.CycleMethod LGP_CYCLE_METHODS[] = {
 103         LinearGradientPaint.CycleMethod.NO_CYCLE,
 104         LinearGradientPaint.CycleMethod.REFLECT,
 105         LinearGradientPaint.CycleMethod.REPEAT,
 106     };
 107     static final RadialGradientPaint.CycleMethod RGP_CYCLE_METHODS[] = {
 108         RadialGradientPaint.CycleMethod.NO_CYCLE,
 109         RadialGradientPaint.CycleMethod.REFLECT,
 110         RadialGradientPaint.CycleMethod.REPEAT,
 111     };
 112 
 113     private static final BasicStroke DEFAULT_STROKE =
 114         new BasicStroke(1.0f, BasicStroke.CAP_SQUARE, BasicStroke.JOIN_MITER, 10.0f);
 115     private static final Paint DEFAULT_PAINT = Color.WHITE;
 116     static java.awt.geom.AffineTransform J2D_IDENTITY =
 117         new java.awt.geom.AffineTransform();
 118     private int clipRectIndex;
 119     private boolean hasPreCullingBits = false;
 120     private float pixelScaleX = 1.0f;
 121     private float pixelScaleY = 1.0f;
 122 
 123     static java.awt.Color toJ2DColor(Color c) {
 124         return new java.awt.Color(c.getRed(),
 125                                   c.getGreen(),
 126                                   c.getBlue(),
 127                                   c.getAlpha());
 128     }
 129 
 130     /*
 131      * Ensure that no fractions are equal
 132      *
 133      * Note that the J2D objects reject equal fractions, but the FX versions
 134      * allow them.
 135      *
 136      * The FX version treats values with equal fractions such that as you
 137      * approach the fractional value from below it interpolates to the
 138      * first color associated with that fraction and as you interpolate
 139      * away from it from above it interpolates the last such color.
 140      *
 141      * To get the J2D version to exhibit the FX behavior we collapse all
 142      * adjacent fractional values into a pair of values that are stored
 143      * with a pair of immediately adjacent floating point values.  This way
 144      * they have unique fractions, but no fractional value can be generated
 145      * which fits between them.  Yet, as you approach from below it will
 146      * interpolate to the first of the pair of colors and as you move away
 147      * above it, the second value will take precedence for interpolation.
 148      *
 149      * Math.ulp() is used to generate an &quot;immediately adjacent fp value&quot;.
 150      */
 151     static int fixFractions(float fractions[], java.awt.Color colors[]) {
 152         float fprev = fractions[0];
 153         int i = 1;  // index of next incoming color/fractions we will examine
 154         int n = 1;  // index of next outgoing color/fraction we will store
 155         while (i &lt; fractions.length) {
 156             float f = fractions[i];
 157             java.awt.Color c = colors[i++];
 158             if (f &lt;= fprev) {
 159                 // If we find any duplicates after we reach 1.0 we can
 160                 // just ignore the rest of the array.  Not only is there
 161                 // no more &quot;fraction room&quot; to assign them to, but we will
 162                 // never generate a fraction &gt;1.0 to access them anyway
 163                 if (f &gt;= 1.0f) break;
 164                 // Find all fractions that are either fprev or fprev+ulp
 165                 // and collapse them into two entries, the first at fprev
 166                 // which is already stored, and the last matching entry
 167                 // will be stored with fraction fprev+ulp
 168                 f = fprev + Math.ulp(fprev);
 169                 while (i &lt; fractions.length) {
 170                     if (fractions[i] &gt; f) break;
 171                     // We continue to remember the color of the last
 172                     // &quot;matching&quot; entry so it can be stored below
 173                     c = colors[i++];
 174                 }
 175             }
 176             fractions[n] = fprev = f;
 177             colors[n++] = c;
 178         }
 179         return n;
 180     }
 181 
 182     java.awt.Paint toJ2DPaint(Paint p, java.awt.geom.Rectangle2D b) {
 183         if (p instanceof Color) {
 184             return toJ2DColor((Color) p);
 185         } else if (p instanceof Gradient) {
 186             Gradient g = (Gradient) p;
 187             if (g.isProportional()) {
 188                 if (b == null) {
 189                     return null;
 190                 }
 191             }
 192             List&lt;Stop&gt; stops = g.getStops();
 193             int n = stops.size();
 194             float fractions[] = new float[n];
 195             java.awt.Color colors[] = new java.awt.Color[n];
 196             float prevf = -1f;
 197             boolean needsFix = false;
 198             for (int i = 0; i &lt; n; i++) {
 199                 Stop stop = stops.get(i);
 200                 float f = stop.getOffset();
 201                 needsFix = (needsFix || f &lt;= prevf);
 202                 fractions[i] = prevf = f;
 203                 colors[i] = toJ2DColor(stop.getColor());
 204             }
 205             if (needsFix) {
 206                 n = fixFractions(fractions, colors);
 207                 if (n &lt; fractions.length) {
 208                     float newf[] = new float[n];
 209                     System.arraycopy(fractions, 0, newf, 0, n);
 210                     fractions = newf;
 211                     java.awt.Color newc[] = new java.awt.Color[n];
 212                     System.arraycopy(colors, 0, newc, 0, n);
 213                     colors = newc;
 214                 }
 215             }
 216             if (g instanceof LinearGradient) {
 217                 LinearGradient lg = (LinearGradient) p;
 218                 float x1 = lg.getX1();
 219                 float y1 = lg.getY1();
 220                 float x2 = lg.getX2();
 221                 float y2 = lg.getY2();
 222                 if (g.isProportional()) {
 223                     float x = (float) b.getX();
 224                     float y = (float) b.getY();
 225                     float w = (float) b.getWidth();
 226                     float h = (float) b.getHeight();
 227                     x1 = x + w * x1;
 228                     y1 = y + h * y1;
 229                     x2 = x + w * x2;
 230                     y2 = y + h * y2;
 231                 }
 232                 if (x1 == x2 &amp;&amp; y1 == y2) {
 233                     // Hardware pipelines use an inverse transform of
 234                     // all zeros to choose colors when the start and end
 235                     // point are the same so that the first color is
 236                     // always chosen...
 237                     return colors[0];
 238                 }
 239                 java.awt.geom.Point2D p1 =
 240                     new java.awt.geom.Point2D.Float(x1, y1);
 241                 java.awt.geom.Point2D p2 =
 242                     new java.awt.geom.Point2D.Float(x2, y2);
 243                 LinearGradientPaint.CycleMethod method =
 244                     LGP_CYCLE_METHODS[g.getSpreadMethod()];
 245                 return new LinearGradientPaint(p1, p2, fractions, colors, method);
 246             } else if (g instanceof RadialGradient) {
 247                 RadialGradient rg = (RadialGradient) g;
 248                 float cx = rg.getCenterX();
 249                 float cy = rg.getCenterY();
 250                 float r = rg.getRadius();
 251                 double fa = Math.toRadians(rg.getFocusAngle());
 252                 float fd = rg.getFocusDistance();
 253                 java.awt.geom.AffineTransform at = J2D_IDENTITY;
 254                 if (g.isProportional()) {
 255                     float x = (float) b.getX();
 256                     float y = (float) b.getY();
 257                     float w = (float) b.getWidth();
 258                     float h = (float) b.getHeight();
 259                     float dim = Math.min(w, h);
 260                     float bcx = x + w * 0.5f;
 261                     float bcy = y + h * 0.5f;
 262                     cx = bcx + (cx - 0.5f) * dim;
 263                     cy = bcy + (cy - 0.5f) * dim;
 264                     r *= dim;
 265                     if (w != h &amp;&amp; w != 0.0 &amp;&amp; h != 0.0) {
 266                         at = java.awt.geom.AffineTransform.getTranslateInstance(bcx, bcy);
 267                         at.scale(w / dim, h / dim);
 268                         at.translate(-bcx, -bcy);
 269                     }
 270                 }
 271                 java.awt.geom.Point2D center =
 272                     new java.awt.geom.Point2D.Float(cx, cy);
 273                 float fx = (float) (cx + fd * r * Math.cos(fa));
 274                 float fy = (float) (cy + fd * r * Math.sin(fa));
 275                 java.awt.geom.Point2D focus =
 276                     new java.awt.geom.Point2D.Float(fx, fy);
 277                 RadialGradientPaint.CycleMethod method =
 278                     RGP_CYCLE_METHODS[g.getSpreadMethod()];
 279                 return new RadialGradientPaint(center, r, focus, fractions, colors,
 280                                                method, ColorSpaceType.SRGB, at);
 281             }
 282         } else if (p instanceof ImagePattern) {
 283             ImagePattern imgpat = (ImagePattern) p;
 284             float x = imgpat.getX();
 285             float y = imgpat.getY();
 286             float w = imgpat.getWidth();
 287             float h = imgpat.getHeight();
 288             if (p.isProportional()) {
 289                 if (b == null) {
 290                     return null;
 291                 }
 292                 float bx = (float) b.getX();
 293                 float by = (float) b.getY();
 294                 float bw = (float) b.getWidth();
 295                 float bh = (float) b.getHeight();
 296                 w += x;
 297                 h += y;
 298                 x = bx + x * bw;
 299                 y = by + y * bh;
 300                 w = bx + w * bw;
 301                 h = by + h * bh;
 302                 w -= x;
 303                 h -= y;
 304             }
 305             Texture tex =
 306                 getResourceFactory().getCachedTexture(imgpat.getImage(), WrapMode.REPEAT);
 307             java.awt.image.BufferedImage bimg = ((J2DTexture) tex).getBufferedImage();
 308             tex.unlock();
 309             return new java.awt.TexturePaint(bimg, tmpRect(x, y, w, h));
 310         }
 311         throw new UnsupportedOperationException(&quot;Paint &quot;+p+&quot; not supported yet.&quot;);
 312     }
 313 
 314     static java.awt.Stroke toJ2DStroke(BasicStroke stroke) {
 315         float lineWidth = stroke.getLineWidth();
 316         int type = stroke.getType();
 317         if (type != BasicStroke.TYPE_CENTERED) {
 318             lineWidth *= 2;
 319         }
 320         java.awt.BasicStroke bs =
 321                 new java.awt.BasicStroke(lineWidth,
 322                                          stroke.getEndCap(),
 323                                          stroke.getLineJoin(),
 324                                          stroke.getMiterLimit(),
 325                                          stroke.getDashArray(),
 326                                          stroke.getDashPhase());
 327         if (type == BasicStroke.TYPE_INNER) {
 328             return new InnerStroke(bs);
 329         } else if (type == BasicStroke.TYPE_OUTER) {
 330             return new OuterStroke(bs);
 331         } else {
 332             return bs;
 333         }
 334     }
 335 
 336     private static ConcurrentHashMap&lt;java.awt.Font,
 337                                      WeakReference&lt;java.awt.Font&gt;&gt;
 338         fontMap = new ConcurrentHashMap&lt;java.awt.Font,
 339                                         WeakReference&lt;java.awt.Font&gt;&gt;();
 340     private static volatile int cleared = 0;
 341 
 342     private static java.awt.Font toJ2DFont(FontStrike strike) {
 343         FontResource fr = strike.getFontResource();
 344         java.awt.Font j2dfont;
 345         Object peer = fr.getPeer();
 346         if (peer == null &amp;&amp; fr.isEmbeddedFont()) {
 347             J2DFontFactory.registerFont(fr);
 348             peer = fr.getPeer();
 349         }
 350         if (peer != null &amp;&amp; peer instanceof java.awt.Font) {
 351             j2dfont = (java.awt.Font)peer;
 352         } else {
 353             if (PlatformUtil.isMac()) {
 354                 // Looking up J2D fonts via full name is not reliable on the
 355                 // Mac, however using the PostScript font name is. The likely
 356                 // cause is Mac platform internals heavy reliance on PostScript
 357                 // names for font identification.
 358                 String psName = fr.getPSName();
 359                 // dummy size
 360                 j2dfont = new java.awt.Font(psName, java.awt.Font.PLAIN, 12);
 361 
 362                 // REMIND: Due to bugs in j2d font lookup, these two workarounds
 363                 // are required to ensure the correct font is used. Once fixed
 364                 // in the jdk these workarounds should be removed.
 365                 if (!j2dfont.getPSName().equals(psName)) {
 366                     // 1. Lookup font via family and style. This covers the
 367                     // case when the J2D PostScript name does not match psName
 368                     // in font file. For example &quot;HelveticaCYBold&quot; has the
 369                     // psName &quot;HelveticaCY-Bold&quot; in j2d.
 370                     int style = fr.isBold() ? java.awt.Font.BOLD : 0;
 371                     style = style | (fr.isItalic() ? java.awt.Font.ITALIC : 0);
 372                     j2dfont = new java.awt.Font(fr.getFamilyName(), style, 12);
 373 
 374                     if(!j2dfont.getPSName().equals(psName)) {
 375                         // 2. J2D seems to be unable to find a few fonts where
 376                         // psName == familyName.  Workaround is an exhaustive
 377                         // search of all fonts.
 378                         java.awt.Font[] allj2dFonts =
 379                                 java.awt.GraphicsEnvironment.
 380                                 getLocalGraphicsEnvironment().getAllFonts();
 381                         for (java.awt.Font f : allj2dFonts) {
 382                             if (f.getPSName().equals(psName)) {
 383                                 j2dfont = f;
 384                                 break;
 385                             }
 386                         }
 387                     }
 388                 }
 389             } else {
 390                 // dummy size
 391                 j2dfont = new java.awt.Font(fr.getFullName(),
 392                                             java.awt.Font.PLAIN, 12);
 393             }
 394 
 395             // Adding j2dfont as peer is OK since fr is a decomposed
 396             // FontResource. Thus preventing font lookup next time we render.
 397             fr.setPeer(j2dfont);
 398         }
 399         // deriveFont(...) still has a bug and will cause #2 problem to occur
 400         j2dfont = j2dfont.deriveFont(strike.getSize()); // exact float font size
 401         java.awt.Font compFont = null;
 402         WeakReference&lt;java.awt.Font&gt; ref = fontMap.get(j2dfont);
 403         if (ref != null) {
 404             compFont = ref.get();
 405             if (compFont == null) {
 406                 cleared++;
 407             }
 408         }
 409         if (compFont == null) {
 410             if (fontMap.size() &gt; 100 &amp;&amp; cleared &gt; 10) { // purge the map.
 411                 for (java.awt.Font key : fontMap.keySet()) {
 412                     ref = fontMap.get(key);
 413                     if (ref == null || ref.get() == null) {
 414                         fontMap.remove(key);
 415                     }
 416                 }
 417                 cleared = 0;
 418             }
 419             compFont = J2DFontFactory.getCompositeFont(j2dfont);
 420             ref = new WeakReference(compFont);
 421             fontMap.put(j2dfont, ref);
 422         }
 423         return compFont;
 424     }
 425 
 426     public static java.awt.geom.AffineTransform
 427         toJ2DTransform(BaseTransform t)
 428     {
 429         return new java.awt.geom.AffineTransform(t.getMxx(), t.getMyx(),
 430                                                  t.getMxy(), t.getMyy(),
 431                                                  t.getMxt(), t.getMyt());
 432     }
 433 
 434     private static java.awt.geom.AffineTransform tmpAT =
 435         new java.awt.geom.AffineTransform();
 436     static java.awt.geom.AffineTransform tmpJ2DTransform(BaseTransform t)
 437     {
 438         tmpAT.setTransform(t.getMxx(), t.getMyx(),
 439                            t.getMxy(), t.getMyy(),
 440                            t.getMxt(), t.getMyt());
 441         return tmpAT;
 442     }
 443 
 444     static BaseTransform toPrTransform(java.awt.geom.AffineTransform t)
 445     {
 446         return BaseTransform.getInstance(t.getScaleX(), t.getShearY(),
 447                                          t.getShearX(), t.getScaleY(),
 448                                          t.getTranslateX(), t.getTranslateY());
 449     }
 450 
 451     static Rectangle toPrRect(java.awt.Rectangle r)
 452     {
 453         return new Rectangle(r.x, r.y, r.width, r.height);
 454     }
 455 
 456     private static java.awt.geom.Path2D tmpQuadShape =
 457         new java.awt.geom.Path2D.Float();
 458     private static java.awt.Shape tmpQuad(float x1, float y1,
 459                                           float x2, float y2)
 460     {
 461         tmpQuadShape.reset();
 462         tmpQuadShape.moveTo(x1, y1);
 463         tmpQuadShape.lineTo(x2, y1);
 464         tmpQuadShape.lineTo(x2, y2);
 465         tmpQuadShape.lineTo(x1, y2);
 466         tmpQuadShape.closePath();
 467         return tmpQuadShape;
 468     }
 469 
 470     private static java.awt.geom.Rectangle2D.Float tmpRect =
 471         new java.awt.geom.Rectangle2D.Float();
 472     private static java.awt.geom.Rectangle2D tmpRect(float x, float y, float w, float h) {
 473         tmpRect.setRect(x, y, w, h);
 474         return tmpRect;
 475     }
 476 
 477     private static java.awt.geom.Ellipse2D tmpEllipse =
 478         new java.awt.geom.Ellipse2D.Float();
 479     private static java.awt.Shape tmpEllipse(float x, float y, float w, float h) {
 480         tmpEllipse.setFrame(x, y, w, h);
 481         return tmpEllipse;
 482     }
 483 
 484     private static java.awt.geom.RoundRectangle2D tmpRRect =
 485         new java.awt.geom.RoundRectangle2D.Float();
 486     private static java.awt.Shape tmpRRect(float x, float y, float w, float h,
 487                                            float aw, float ah)
 488     {
 489         tmpRRect.setRoundRect(x, y, w, h, aw, ah);
 490         return tmpRRect;
 491     }
 492 
 493     private static java.awt.geom.Line2D tmpLine =
 494         new java.awt.geom.Line2D.Float();
 495     private static java.awt.Shape tmpLine(float x1, float y1, float x2, float y2) {
 496         tmpLine.setLine(x1, y1, x2, y2);
 497         return tmpLine;
 498     }
 499 
 500     private static AdaptorShape tmpAdaptor = new AdaptorShape();
 501     private static java.awt.Shape tmpShape(Shape s) {
 502         tmpAdaptor.setShape(s);
 503         return tmpAdaptor;
 504     }
 505 
 506     private boolean antialiasedShape = true;
 507     J2DPresentable target;
 508     java.awt.Graphics2D g2d;
 509     Affine2D transform;
 510     Rectangle clipRect;
 511     RectBounds devClipRect;
 512     RectBounds finalClipRect;
 513     Paint paint;
 514     boolean paintWasProportional;
 515     BasicStroke stroke;
 516     boolean cull;
 517 
 518     J2DPrismGraphics(J2DPresentable target, java.awt.Graphics2D g2d) {
 519         this(g2d, target.getContentWidth(), target.getContentHeight());
 520         this.target = target;
 521     }
 522 
 523     J2DPrismGraphics(java.awt.Graphics2D g2d, int width, int height) {
 524         this.g2d = g2d;
 525         captureTransform(g2d);
 526         this.transform = new Affine2D();
 527         this.devClipRect = new RectBounds(0, 0, width, height);
 528         this.finalClipRect = new RectBounds(0, 0, width, height);
 529         this.cull = true;
 530 
 531         g2d.setRenderingHint(java.awt.RenderingHints.KEY_STROKE_CONTROL,
 532                              java.awt.RenderingHints.VALUE_STROKE_PURE);
 533         g2d.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING,
 534                               java.awt.RenderingHints.VALUE_ANTIALIAS_ON);
 535         g2d.setRenderingHint(java.awt.RenderingHints.KEY_INTERPOLATION,
 536                              java.awt.RenderingHints.VALUE_INTERPOLATION_BILINEAR);
 537         /* Set the text hints to those most equivalent to FX rendering.
 538          * Will need to revisit this since its unlikely to be sufficient.
 539          */
 540         g2d.setRenderingHint(java.awt.RenderingHints.KEY_FRACTIONALMETRICS,
 541                            java.awt.RenderingHints.VALUE_FRACTIONALMETRICS_ON);
 542         g2d.setRenderingHint(java.awt.RenderingHints.KEY_TEXT_ANTIALIASING,
 543                              java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
 544 
 545 
 546         setTransform(BaseTransform.IDENTITY_TRANSFORM);
 547         setPaint(DEFAULT_PAINT);
 548         setStroke(DEFAULT_STROKE);
 549     }
 550 
 551     public RenderTarget getRenderTarget() {
 552         return target;
 553     }
 554 
 555     public Screen getAssociatedScreen() {
 556         return target.getAssociatedScreen();
 557     }
 558 
 559     public ResourceFactory getResourceFactory() {
 560         return target.getResourceFactory();
 561     }
 562 
 563     public void reset() {
 564     }
 565 
 566     public Rectangle getClipRect() {
 567         return clipRect == null ? null : new Rectangle(clipRect);
 568     }
 569 
 570     public Rectangle getClipRectNoClone() {
 571         return clipRect;
 572     }
 573 
 574     public RectBounds getFinalClipNoClone() {
 575         return finalClipRect;
 576     }
 577 
 578     public void setClipRect(Rectangle clipRect) {
 579         this.finalClipRect.setBounds(devClipRect);
 580         if (clipRect == null) {
 581             this.clipRect = null;
 582             g2d.setClip(null);
 583         } else {
 584             this.clipRect = new Rectangle(clipRect);
 585             this.finalClipRect.intersectWith(clipRect);
 586             setTransformG2D(J2D_IDENTITY);
 587             g2d.setClip(clipRect.x, clipRect.y, clipRect.width, clipRect.height);
 588             setTransformG2D(tmpJ2DTransform(transform));
 589         }
 590     }
 591 
 592     private java.awt.AlphaComposite getAWTComposite() {
 593         return (java.awt.AlphaComposite) g2d.getComposite();
 594     }
 595 
 596     public float getExtraAlpha() {
 597         return getAWTComposite().getAlpha();
 598     }
 599 
 600     public void setExtraAlpha(float extraAlpha) {
 601         g2d.setComposite(getAWTComposite().derive(extraAlpha));
 602     }
 603 
 604     public CompositeMode getCompositeMode() {
 605         int rule = getAWTComposite().getRule();
 606         switch (rule) {
 607             case java.awt.AlphaComposite.CLEAR:
 608                 return CompositeMode.CLEAR;
 609             case java.awt.AlphaComposite.SRC:
 610                 return CompositeMode.SRC;
 611             case java.awt.AlphaComposite.SRC_OVER:
 612                 return CompositeMode.SRC_OVER;
 613             default:
 614                 throw new InternalError(&quot;Unrecognized AlphaCompsite rule: &quot;+rule);
 615         }
 616     }
 617 
 618     public void setCompositeMode(CompositeMode mode) {
 619         java.awt.AlphaComposite awtComp = getAWTComposite();
 620         switch (mode) {
 621             case CLEAR:
 622                 awtComp = awtComp.derive(java.awt.AlphaComposite.CLEAR);
 623                 break;
 624             case SRC:
 625                 awtComp = awtComp.derive(java.awt.AlphaComposite.SRC);
 626                 break;
 627             case SRC_OVER:
 628                 awtComp = awtComp.derive(java.awt.AlphaComposite.SRC_OVER);
 629                 break;
 630             default:
 631                 throw new InternalError(&quot;Unrecognized composite mode: &quot;+mode);
 632         }
 633         g2d.setComposite(awtComp);
 634     }
 635 
 636     public Paint getPaint() {
 637         return paint;
 638     }
 639 
 640     public void setPaint(Paint paint) {
 641         this.paint = paint;
 642         java.awt.Paint j2dpaint = toJ2DPaint(paint, null);
 643         if (j2dpaint == null) {
 644             paintWasProportional = true;
 645         } else {
 646             paintWasProportional = false;
 647             g2d.setPaint(j2dpaint);
 648         }
 649     }
 650 
 651     public BasicStroke getStroke() {
 652         return stroke;
 653     }
 654 
 655     public void setStroke(BasicStroke stroke) {
 656         this.stroke = stroke;
 657         g2d.setStroke(toJ2DStroke(stroke));
 658     }
 659 
 660     public BaseTransform getTransformNoClone() {
 661         return transform;
 662     }
 663 
 664     public void translate(float tx, float ty) {
 665         transform.translate(tx, ty);
 666         g2d.translate(tx, ty);
 667     }
 668 
 669     public void scale(float sx, float sy) {
 670         transform.scale(sx, sy);
 671         g2d.scale(sx, sy);
 672     }
 673 
 674     public void transform(BaseTransform xform) {
 675         if (!xform.is2D()) {
 676             // No-op until we support 3D
 677             return;
 678         }
 679         transform.concatenate(xform);
 680         setTransformG2D(tmpJ2DTransform(transform));
 681     }
 682 
 683     public void setTransform(BaseTransform xform) {
 684         // TODO: Modify PrEffectHelper to not pass a null... (RT-27384)
 685         if (xform == null) xform = BaseTransform.IDENTITY_TRANSFORM;
 686         transform.setTransform(xform);
 687         setTransformG2D(tmpJ2DTransform(transform));
 688     }
 689 
 690     public void setTransform(double m00, double m10,
 691                              double m01, double m11,
 692                              double m02, double m12)
 693     {
 694         transform.setTransform(m00, m10, m01, m11, m02, m12);
 695         setTransformG2D(tmpJ2DTransform(transform));
 696     }
 697 
 698     public void clear() {
 699         clear(Color.TRANSPARENT);
 700     }
 701 
 702     public void clear(Color color) {
 703         this.getRenderTarget().setOpaque(color.isOpaque());
 704         clear(toJ2DColor(color));
 705     }
 706 
 707     void clear(java.awt.Color c) {
 708         java.awt.Graphics2D gtmp = (java.awt.Graphics2D) g2d.create();
 709         gtmp.setTransform(J2D_IDENTITY);
 710         gtmp.setComposite(java.awt.AlphaComposite.Src);
 711         gtmp.setColor(c);
 712         gtmp.fillRect(0, 0, target.getContentWidth(), target.getContentHeight());
 713         gtmp.dispose();
 714     }
 715 
 716     public void clearQuad(float x1, float y1, float x2, float y2) {
 717         g2d.setComposite(java.awt.AlphaComposite.Clear);
 718         g2d.fill(tmpQuad(x1, y1, x2, y2));
 719     }
 720 
 721     void fill(java.awt.Shape shape) {
 722         if (paintWasProportional) {
 723             if (nodeBounds != null) {
 724                 g2d.setPaint(toJ2DPaint(paint, nodeBounds));
 725             } else {
 726                 g2d.setPaint(toJ2DPaint(paint, shape.getBounds2D()));
 727             }
 728         }
<a name="1" id="anc1"></a>


















 729         g2d.fill(shape);
 730     }
 731 
 732     public void fill(Shape shape) {
 733         fill(tmpShape(shape));
 734     }
 735 
 736     public void fillRect(float x, float y, float width, float height) {
 737         fill(tmpRect(x, y, width, height));
 738     }
 739 
 740     public void fillRoundRect(float x, float y, float width, float height,
 741                               float arcw, float arch)
 742     {
 743         fill(tmpRRect(x, y, width, height, arcw, arch));
 744     }
 745 
 746     public void fillEllipse(float x, float y, float width, float height) {
 747         fill(tmpEllipse(x, y, width, height));
 748     }
 749 
 750     public void fillQuad(float x1, float y1, float x2, float y2) {
 751         fill(tmpQuad(x1, y1, x2, y2));
 752     }
 753 
 754     void draw(java.awt.Shape shape) {
 755         if (paintWasProportional) {
 756             if (nodeBounds != null) {
 757                 g2d.setPaint(toJ2DPaint(paint, nodeBounds));
 758             } else {
 759                 g2d.setPaint(toJ2DPaint(paint, shape.getBounds2D()));
 760             }
 761         }
 762         try {
 763             g2d.draw(shape);
 764         } catch (Throwable t) {
 765             // Workaround for JDK bug 6670624
 766             // We may get a Ductus PRError (extends RuntimeException)
 767             // or we may get an InternalError (extends Error)
 768             // The only common superclass of the two is Throwable...
 769         }
 770     }
 771 
 772     public void draw(Shape shape) {
 773         draw(tmpShape(shape));
 774     }
 775 
 776     public void drawLine(float x1, float y1, float x2, float y2) {
 777         draw(tmpLine(x1, y1, x2, y2));
 778     }
 779 
 780     public void drawRect(float x, float y, float width, float height) {
 781         draw(tmpRect(x, y, width, height));
 782     }
 783 
 784     public void drawRoundRect(float x, float y, float width, float height, float arcw, float arch) {
 785         draw(tmpRRect(x, y, width, height, arcw, arch));
 786     }
 787 
 788     public void drawEllipse(float x, float y, float width, float height) {
 789         draw(tmpEllipse(x, y, width, height));
 790     }
 791 
 792     Rectangle2D nodeBounds = null;
 793 
 794     public void setNodeBounds(RectBounds bounds) {
 795         nodeBounds = bounds != null ?
 796                 new Rectangle2D.Float(bounds.getMinX(), bounds.getMinY(),
 797                                       bounds.getWidth(),bounds.getHeight()) :
 798                 null;
 799     }
 800 
 801     private void drawString(GlyphList gl, int start, int end,
 802                             FontStrike strike, float x, float y) {
 803         if (start == end) return;
 804         int count = end - start;
 805         int[] glyphs = new int[count];
 806         for (int i = 0; i &lt; count; i++) {
 807             glyphs[i] = gl.getGlyphCode(start + i) &amp; CompositeGlyphMapper.GLYPHMASK;
 808         }
 809         java.awt.Font j2dfont = toJ2DFont(strike);
 810         GlyphVector gv = j2dfont.createGlyphVector(g2d.getFontRenderContext(), glyphs);
 811         java.awt.geom.Point2D pt = new java.awt.geom.Point2D.Float();
 812         for (int i = 0; i &lt; count; i++) {
 813             pt.setLocation(gl.getPosX(start + i), gl.getPosY(start + i));
 814             gv.setGlyphPosition(i, pt);
 815         }
 816         g2d.drawGlyphVector(gv, x, y);
 817     }
 818 
 819     public void drawString(GlyphList gl, FontStrike strike, float x, float y,
 820                            Color selectColor, int start, int end) {
 821 
 822         int count = gl.getGlyphCount();
 823         if (count == 0) return;
 824 
 825         // In JDK6, setting graphics AA disables fast text loops
 826         g2d.setRenderingHint(KEY_ANTIALIASING, VALUE_ANTIALIAS_OFF);
 827 
 828         // If the surface has Alpha, JDK will ignore the LCD loops.
 829         // So for this to have any effect we need to fix JDK, or
 830         // ensure an opaque surface type.
 831         if (strike.getAAMode() == FontResource.AA_LCD) {
 832             g2d.setRenderingHint(KEY_TEXT_ANTIALIASING, VALUE_TEXT_ANTIALIAS_LCD_HRGB);
 833         }
 834 
 835         if (paintWasProportional) {
 836             Rectangle2D rectBounds = nodeBounds;
 837             if (rectBounds == null) {
 838                 Metrics m = strike.getMetrics();
 839                 rectBounds = new Rectangle2D.Float(0,
 840                                                    m.getAscent(),
 841                                                    gl.getWidth(),
 842                                                    m.getLineHeight());
 843             }
 844             g2d.setPaint(toJ2DPaint(paint, rectBounds));
 845         }
 846 
 847         CompositeStrike cStrike = null;
 848         int slot = 0;
 849         if (strike instanceof CompositeStrike) {
 850             cStrike = (CompositeStrike)strike;
 851             int glyphCode = gl.getGlyphCode(0);
 852             slot = cStrike.getStrikeSlotForGlyph(glyphCode);
 853         }
 854         java.awt.Color sColor = null;
 855         java.awt.Color tColor = null;
 856         boolean selected = false;
 857         if (selectColor != null) {
 858             sColor = toJ2DColor(selectColor);
 859             tColor = g2d.getColor();
 860             int offset = gl.getCharOffset(0);
 861             selected = start &lt;= offset &amp;&amp; offset &lt; end;
 862         }
 863         int index = 0;
 864         if (sColor != null || cStrike != null) {
 865             /* Draw a segment every time selection or font changes */
 866             for (int i = 1; i &lt; count; i++) {
 867                 if (sColor != null) {
 868                     int offset = gl.getCharOffset(i);
 869                     boolean glyphSelected = start &lt;= offset &amp;&amp; offset &lt; end;
 870                     if (selected != glyphSelected) {
 871                         if (cStrike != null) {
 872                             strike = cStrike.getStrikeSlot(slot);
 873                         }
 874                         g2d.setColor(selected ? sColor : tColor);
 875                         drawString(gl, index, i, strike, x, y);
 876                         index = i;
 877                         selected = glyphSelected;
 878                     }
 879                 }
 880                 if (cStrike != null) {
 881                     int glyphCode = gl.getGlyphCode(i);
 882                     int glyphSlot = cStrike.getStrikeSlotForGlyph(glyphCode);
 883                     if (slot != glyphSlot) {
 884                         strike = cStrike.getStrikeSlot(slot);
 885                         if (sColor != null) {
 886                             g2d.setColor(selected ? sColor : tColor);
 887                         }
 888                         drawString(gl, index, i, strike, x, y);
 889                         index = i;
 890                         slot = glyphSlot;
 891                     }
 892                 }
 893             }
 894 
 895             /* Set strike and color to draw the last segment */
 896             if (cStrike != null) {
 897                 strike = cStrike.getStrikeSlot(slot);
 898             }
 899             if (sColor != null) {
 900                 g2d.setColor(selected ? sColor : tColor);
 901             }
 902         }
 903         drawString(gl, index, count, strike, x, y);
 904 
 905         /* Always restore the graphics to its initial color */
 906         if (selectColor != null) {
 907             g2d.setColor(tColor);
 908         }
 909 
 910         // Set hints back to the default.
 911         g2d.setRenderingHint(KEY_TEXT_ANTIALIASING, VALUE_TEXT_ANTIALIAS_ON);
 912         g2d.setRenderingHint(KEY_ANTIALIASING, VALUE_ANTIALIAS_ON);
 913     }
 914 
 915     /**
 916      * Overridden by printing subclass to preserve the printer graphics
 917      * transform.
 918      */
 919     protected void setTransformG2D(java.awt.geom.AffineTransform tx) {
 920         g2d.setTransform(tx);
 921     }
 922 
 923     /**
 924      * Needed only by printing subclass, which over-rides it.
 925      */
 926     protected void captureTransform(java.awt.Graphics2D g2d) {
 927         return;
 928     }
 929 
 930     public void drawMappedTextureRaw(Texture tex,
 931                                      float dx1, float dy1, float dx2, float dy2,
 932                                      float tx11, float ty11, float tx21, float ty21,
 933                                      float tx12, float ty12, float tx22, float ty22)
 934     {
 935         java.awt.Image img = ((J2DTexture) tex).getBufferedImage();
 936         float mxx = tx21-tx11;
 937         float myx = ty21-ty11;
 938         float mxy = tx12-tx11;
 939         float myy = ty12-ty11;
 940 //        assert(Math.abs(mxx - (tx22-tx12)) &lt; .000001);
 941 //        assert(Math.abs(myx - (ty22-ty12)) &lt; .000001);
 942 //        assert(Math.abs(mxy - (tx22-tx21)) &lt; .000001);
 943 //        assert(Math.abs(myy - (ty22-ty21)) &lt; .000001);
 944         setTransformG2D(J2D_IDENTITY);
 945         tmpAT.setTransform(mxx, myx, mxy, myy, tx11, ty11);
 946         try {
 947             tmpAT.invert();
 948             g2d.translate(dx1, dy1);
 949             g2d.scale(dx2-dx1, dy2-dy1);
 950             g2d.transform(tmpAT);
 951             g2d.drawImage(img, 0, 0, 1, 1, null);
 952         } catch (NoninvertibleTransformException e) {
 953         }
 954         setTransform(transform);
 955     }
 956 
 957     public void drawTexture(Texture tex, float x, float y, float w, float h) {
 958         java.awt.Image img = ((J2DTexture) tex).getBufferedImage();
 959         g2d.drawImage(img, (int) x, (int) y, (int) (x+w), (int) (y+h), 0, 0, (int)w, (int) h, null);
 960     }
 961 
 962     public void drawTexture(Texture tex,
 963                             float dx1, float dy1, float dx2, float dy2,
 964                             float sx1, float sy1, float sx2, float sy2)
 965     {
 966         java.awt.Image img = ((J2DTexture) tex).getBufferedImage();
 967         // Simply casting the subimage coordinates to integers does not
 968         // produce the same behavior as the Prism hw pipelines (see RT-19270).
 969         g2d.drawImage(img,
 970                 (int) dx1, (int) dy1, (int) dx2, (int) dy2,
 971                 (int) sx1, (int) sy1, (int) sx2, (int) sy2,
 972                 null);
 973     }
 974 
 975     @Override
 976     public void drawTexture3SliceH(Texture tex,
 977                                    float dx1, float dy1, float dx2, float dy2,
 978                                    float sx1, float sy1, float sx2, float sy2,
 979                                    float dh1, float dh2, float sh1, float sh2)
 980     {
 981         // Workaround for problems in NGRegion which may pass zero-width
 982         // source image area.
 983         if (sh1 + 0.1f &gt; sh2) sh2 += 1;
 984         drawTexture(tex, dx1, dy1, dh1, dy2, sx1, sy1, sh1, sy2);
 985         drawTexture(tex, dh1, dy1, dh2, dy2, sh1, sy1, sh2, sy2);
 986         drawTexture(tex, dh2, dy1, dx2, dy2, sh2, sy1, sx2, sy2);
 987     }
 988 
 989     @Override
 990     public void drawTexture3SliceV(Texture tex,
 991                                    float dx1, float dy1, float dx2, float dy2,
 992                                    float sx1, float sy1, float sx2, float sy2,
 993                                    float dv1, float dv2, float sv1, float sv2)
 994     {
 995         // Workaround for problems in NGRegion which may pass zero-height
 996         // source image area.
 997         if (sv1 +0.1f &gt; sv2) sv2 += 1;
 998         drawTexture(tex, dx1, dy1, dx2, dv1, sx1, sy1, sx2, sv1);
 999         drawTexture(tex, dx1, dv1, dx2, dv2, sx1, sv1, sx2, sv2);
1000         drawTexture(tex, dx1, dv2, dx2, dy2, sx1, sv2, sx2, sy2);
1001     }
1002 
1003     @Override
1004     public void drawTexture9Slice(Texture tex,
1005                                   float dx1, float dy1, float dx2, float dy2,
1006                                   float sx1, float sy1, float sx2, float sy2,
1007                                   float dh1, float dv1, float dh2, float dv2,
1008                                   float sh1, float sv1, float sh2, float sv2)
1009     {
1010         // Workaround for problems in NGRegion which may pass zero-width
1011         // or zero height source image area.
1012         if (sh1 + 0.1f &gt; sh2) sh2 += 1;
1013         if (sv1 + 0.1f &gt; sv2) sv2 += 1;
1014         drawTexture(tex, dx1, dy1, dh1, dv1, sx1, sy1, sh1, sv1);
1015         drawTexture(tex, dh1, dy1, dh2, dv1, sh1, sy1, sh2, sv1);
1016         drawTexture(tex, dh2, dy1, dx2, dv1, sh2, sy1, sx2, sv1);
1017 
1018         drawTexture(tex, dx1, dv1, dh1, dv2, sx1, sv1, sh1, sv2);
1019         drawTexture(tex, dh1, dv1, dh2, dv2, sh1, sv1, sh2, sv2);
1020         drawTexture(tex, dh2, dv1, dx2, dv2, sh2, sv1, sx2, sv2);
1021 
1022         drawTexture(tex, dx1, dv2, dh1, dy2, sx1, sv2, sh1, sy2);
1023         drawTexture(tex, dh1, dv2, dh2, dy2, sh1, sv2, sh2, sy2);
1024         drawTexture(tex, dh2, dv2, dx2, dy2, sh2, sv2, sx2, sy2);
1025     }
1026 
1027     public void drawTextureRaw(Texture tex,
1028                                float dx1, float dy1, float dx2, float dy2,
1029                                float tx1, float ty1, float tx2, float ty2)
1030     {
1031         int w = tex.getContentWidth();
1032         int h = tex.getContentHeight();
1033         tx1 *= w;
1034         ty1 *= h;
1035         tx2 *= w;
1036         ty2 *= h;
1037         drawTexture(tex, dx1, dy1, dx2, dy2, tx1, ty1, tx2, ty2);
1038     }
1039 
1040     public void drawTextureVO(Texture tex,
1041                               float topopacity, float botopacity,
1042                               float dx1, float dy1, float dx2, float dy2,
1043                               float sx1, float sy1, float sx2, float sy2)
1044     {
1045         // assert(caller is PrReflectionPeer and buffer is cleared to transparent)
1046         // NOTE: the assert conditions are true because that is the only
1047         // place where this method is used (unless we subclass BaseGraphics),
1048         // but there is no code here to verify that information.
1049         // The workarounds to do this for the general case would cost a lot
1050         // because they would involve creating a temporary intermediate buffer,
1051         // doing the operations below into the buffer, and then applying the
1052         // buffer to the destination.  That is not hard, but it costs a lot
1053         // of buffer allocation (or caching) when it is not really necessary
1054         // given the way this method is called currently.
1055         // Note that isoEdgeMask is ignored here, but since this is only ever
1056         // called by PrReflectionPeer and that code always uses ISOLATE_NONE
1057         // then we would only need to support ISOLATE_NONE.  The code below
1058         // does not yet verify if the results will be compatible with
1059         // ISOLATE_NONE, but given that the source coordinates are rounded to
1060         // integers in drawTexture() there is not much it can do to get exact
1061         // edge condition behavior until that deficiency is fixed (see
1062         // RT-19270 and RT-19271).
1063         java.awt.Paint savepaint = g2d.getPaint();
1064         java.awt.Composite savecomp = g2d.getComposite();
1065         java.awt.Color c1 = new java.awt.Color(1f, 1f, 1f, topopacity);
1066         java.awt.Color c2 = new java.awt.Color(1f, 1f, 1f, botopacity);
1067         g2d.setPaint(new java.awt.GradientPaint(0f, dy1, c1, 0f, dy2, c2, true));
1068         g2d.setComposite(java.awt.AlphaComposite.Src);
1069         int x = (int) Math.floor(Math.min(dx1, dx2));
1070         int y = (int) Math.floor(Math.min(dy1, dy2));
1071         int w = (int) Math.ceil(Math.max(dx1, dx2)) - x;
1072         int h = (int) Math.ceil(Math.max(dy1, dy2)) - y;
1073         g2d.fillRect(x, y, w, h);
1074         g2d.setComposite(java.awt.AlphaComposite.SrcIn);
1075         drawTexture(tex, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2);
1076         g2d.setComposite(savecomp);
1077         g2d.setPaint(savepaint);
1078     }
1079 
1080     public void drawPixelsMasked(RTTexture imgtex, RTTexture masktex,
1081                                  int dx, int dy, int dw, int dh,
1082                                  int ix, int iy, int mx, int my)
1083     {
1084         doDrawMaskTexture((J2DRTTexture) imgtex, (J2DRTTexture) masktex,
1085                           dx, dy, dw, dh,
1086                           ix, iy, mx, my,
1087                           true);
1088     }
1089 
1090     public void maskInterpolatePixels(RTTexture imgtex, RTTexture masktex, int dx,
1091                                       int dy, int dw, int dh, int ix, int iy,
1092                                       int mx, int my) {
1093         doDrawMaskTexture((J2DRTTexture) imgtex, (J2DRTTexture) masktex,
1094                           dx, dy, dw, dh,
1095                           ix, iy, mx, my,
1096                           false);
1097     }
1098 
1099     private void doDrawMaskTexture(J2DRTTexture imgtex, J2DRTTexture masktex,
1100                                    int dx, int dy, int dw, int dh,
1101                                    int ix, int iy, int mx, int my,
1102                                    boolean srcover)
1103     {
1104         int cx0 = clipRect.x;
1105         int cy0 = clipRect.y;
1106         int cx1 = cx0 + clipRect.width;
1107         int cy1 = cy0 + clipRect.height;
1108 
1109         if (dw &lt;= 0 || dh &lt;= 0) return;
1110         if (dx &lt; cx0) {
1111             int bump = cx0 - dx;
1112             if ((dw -= bump) &lt;= 0) return;
1113             ix += bump;
1114             mx += bump;
1115             dx = cx0;
1116         }
1117         if (dy &lt; cy0) {
1118             int bump = cy0 - dy;
1119             if ((dh -= bump) &lt;= 0) return;
1120             iy += bump;
1121             my += bump;
1122             dy = cy0;
1123         }
1124         if (dx + dw &gt; cx1 &amp;&amp; (dw = cx1 - dx) &lt;= 0) return;
1125         if (dy + dh &gt; cy1 &amp;&amp; (dh = cy1 - dy) &lt;= 0) return;
1126 
1127         int iw = imgtex.getContentWidth();
1128         int ih = imgtex.getContentHeight();
1129         if (ix &lt; 0) {
1130             if ((dw += ix) &lt;= 0) return;
1131             dx -= ix;
1132             mx -= ix;
1133             ix = 0;
1134         }
1135         if (iy &lt; 0) {
1136             if ((dh += iy) &lt;= 0) return;
1137             dy -= iy;
1138             my -= iy;
1139             iy = 0;
1140         }
1141         if (ix + dw &gt; iw &amp;&amp; (dw = iw - ix) &lt;= 0) return;
1142         if (iy + dh &gt; ih &amp;&amp; (dh = ih - iy) &lt;= 0) return;
1143 
1144         int mw = masktex.getContentWidth();
1145         int mh = masktex.getContentHeight();
1146         if (mx &lt; 0) {
1147             if ((dw += mx) &lt;= 0) return;
1148             dx -= mx;
1149             ix -= mx;
1150             mx = 0;
1151         }
1152         if (my &lt; 0) {
1153             if ((dh += my) &lt;= 0) return;
1154             dy -= my;
1155             iy -= my;
1156             my = 0;
1157         }
1158         if (mx + dw &gt; mw &amp;&amp; (dw = mw - mx) &lt;= 0) return;
1159         if (my + dh &gt; mh &amp;&amp; (dh = mh - my) &lt;= 0) return;
1160 
1161         int imgbuf[] = imgtex.getPixels();
1162         int maskbuf[] = masktex.getPixels();
1163         java.awt.image.DataBuffer db = target.getBackBuffer().getRaster().getDataBuffer();
1164         int dstbuf[] = ((java.awt.image.DataBufferInt) db).getData();
1165         int iscan = imgtex.getBufferedImage().getWidth();
1166         int mscan = masktex.getBufferedImage().getWidth();
1167         int dscan = target.getBackBuffer().getWidth();
1168         int ioff = iy * iscan + ix;
1169         int moff = my * mscan + mx;
1170         int doff = dy * dscan + dx;
1171         if (srcover) {
1172             for (int y = 0; y &lt; dh; y++) {
1173                 for (int x = 0; x &lt; dw; x++) {
1174                     int a, r, g, b;
1175                     int maskalpha = maskbuf[moff+x] &gt;&gt;&gt; 24;
1176                     if (maskalpha == 0) continue;
1177                     int imgpix = imgbuf[ioff+x];
1178                     a = (imgpix &gt;&gt;&gt; 24);
1179                     if (a == 0) continue;
1180                     if (maskalpha &lt; 0xff) {
1181                         maskalpha += (maskalpha &gt;&gt; 7);
1182                         a *= maskalpha;
1183                         r = ((imgpix &gt;&gt;  16) &amp; 0xff) * maskalpha;
1184                         g = ((imgpix &gt;&gt;   8) &amp; 0xff) * maskalpha;
1185                         b = ((imgpix       ) &amp; 0xff) * maskalpha;
1186                     } else if (a &lt; 0xff) {
1187                         a &lt;&lt;= 8;
1188                         r = ((imgpix &gt;&gt;  16) &amp; 0xff) &lt;&lt; 8;
1189                         g = ((imgpix &gt;&gt;   8) &amp; 0xff) &lt;&lt; 8;
1190                         b = ((imgpix       ) &amp; 0xff) &lt;&lt; 8;
1191                     } else {
1192                         dstbuf[doff+x] = imgpix;
1193                         continue;
1194                     }
1195                     maskalpha = ((a + 128) &gt;&gt; 8);
1196                     maskalpha += (maskalpha &gt;&gt; 7);
1197                     maskalpha = 256 - maskalpha;
1198                     imgpix = dstbuf[doff+x];
1199                     a += ((imgpix &gt;&gt;&gt; 24)       ) * maskalpha + 128;
1200                     r += ((imgpix &gt;&gt;  16) &amp; 0xff) * maskalpha + 128;
1201                     g += ((imgpix &gt;&gt;   8) &amp; 0xff) * maskalpha + 128;
1202                     b += ((imgpix       ) &amp; 0xff) * maskalpha + 128;
1203                     imgpix = ((a &gt;&gt; 8) &lt;&lt; 24) +
1204                              ((r &gt;&gt; 8) &lt;&lt; 16) +
1205                              ((g &gt;&gt; 8) &lt;&lt;  8) +
1206                              ((b &gt;&gt; 8)      );
1207                     dstbuf[doff+x] = imgpix;
1208                 }
1209                 ioff += iscan;
1210                 moff += mscan;
1211                 doff += dscan;
1212             }
1213         } else {
1214             for (int y = 0; y &lt; dh; y++) {
1215                 for (int x = 0; x &lt; dw; x++) {
1216                     int maskalpha = maskbuf[moff+x] &gt;&gt;&gt; 24;
1217                     if (maskalpha == 0) continue;
1218                     int imgpix = imgbuf[ioff+x];
1219                     if (maskalpha &lt; 0xff) {
1220                         maskalpha += (maskalpha &gt;&gt; 7);
1221                         int a = ((imgpix &gt;&gt;&gt; 24)       ) * maskalpha;
1222                         int r = ((imgpix &gt;&gt;  16) &amp; 0xff) * maskalpha;
1223                         int g = ((imgpix &gt;&gt;   8) &amp; 0xff) * maskalpha;
1224                         int b = ((imgpix       ) &amp; 0xff) * maskalpha;
1225                         maskalpha = 256 - maskalpha;
1226                         imgpix = dstbuf[doff+x];
1227                         a += ((imgpix &gt;&gt;&gt; 24)       ) * maskalpha + 128;
1228                         r += ((imgpix &gt;&gt;  16) &amp; 0xff) * maskalpha + 128;
1229                         g += ((imgpix &gt;&gt;   8) &amp; 0xff) * maskalpha + 128;
1230                         b += ((imgpix       ) &amp; 0xff) * maskalpha + 128;
1231                         imgpix = ((a &gt;&gt; 8) &lt;&lt; 24) +
1232                                  ((r &gt;&gt; 8) &lt;&lt; 16) +
1233                                  ((g &gt;&gt; 8) &lt;&lt;  8) +
1234                                  ((b &gt;&gt; 8)      );
1235                     }
1236                     dstbuf[doff+x] = imgpix;
1237                 }
1238                 ioff += iscan;
1239                 moff += mscan;
1240                 doff += dscan;
1241             }
1242         }
1243     }
1244 
1245     public boolean canReadBack() {
1246         return true;
1247     }
1248 
1249     public RTTexture readBack(Rectangle view) {
1250         J2DRTTexture rtt = target.getReadbackBuffer();
1251         java.awt.Graphics2D rttg2d = rtt.createAWTGraphics2D();
1252         rttg2d.setComposite(java.awt.AlphaComposite.Src);
1253         int x0 = view.x;
1254         int y0 = view.y;
1255         int w = view.width;
1256         int h = view.height;
1257         int x1 = x0 + w;
1258         int y1 = y0 + h;
1259         rttg2d.drawImage(target.getBackBuffer(),
1260                           0,  0,  w,  h,
1261                          x0, y0, x1, y1, null);
1262         rttg2d.dispose();
1263         return rtt;
1264     }
1265 
1266     public void releaseReadBackBuffer(RTTexture view) {
1267         // This will be needed when we track LCD buffer locks and uses.
1268         // (See RT-29488)
1269 //        target.getReadbackBuffer().unlock();
1270     }
1271 
1272     public NGCamera getCameraNoClone() {
1273         throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
1274     }
1275 
1276     public void setPerspectiveTransform(GeneralTransform3D transform) {
1277     }
1278 
1279 
1280     public boolean isDepthBuffer() {
1281         return false;
1282     }
1283 
1284     public boolean isDepthTest() {
1285         return false;
1286     }
1287 
1288     public boolean isAlphaTestShader() {
1289         if (PrismSettings.verbose &amp;&amp; PrismSettings.forceAlphaTestShader) {
1290             System.out.println(&quot;J2D pipe doesn&#39;t support shader with alpha testing&quot;);
1291         }
1292         return false;
1293     }
1294 
1295     public void setAntialiasedShape(boolean aa) {
1296         antialiasedShape = aa;
1297         g2d.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING,
1298                 antialiasedShape ? java.awt.RenderingHints.VALUE_ANTIALIAS_ON
1299                         : java.awt.RenderingHints.VALUE_ANTIALIAS_OFF);
1300     }
1301 
1302     public boolean isAntialiasedShape() {
1303         return antialiasedShape;
1304     }
1305 
1306     public void scale(float sx, float sy, float sz) {
1307         throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
1308     }
1309 
1310     public void setTransform3D(double mxx, double mxy, double mxz, double mxt,
1311                                double myx, double myy, double myz, double myt,
1312                                double mzx, double mzy, double mzz, double mzt)
1313     {
1314         if (mxz != 0.0 || myz != 0.0 ||
1315             mzx != 0.0 || mzy != 0.0 || mzz != 1.0 || mzt != 0.0)
1316         {
1317             throw new UnsupportedOperationException(&quot;3D transforms not supported.&quot;);
1318         }
1319         setTransform(mxx, myx, mxy, myy, mxt, myt);
1320     }
1321 
1322     public void setCamera(NGCamera camera) {
1323         // No-op until we support 3D
1324         /*
1325         if (!(camera instanceof PrismParallelCameraImpl)) {
1326 
1327             throw new UnsupportedOperationException(camera+&quot; not supported.&quot;);
1328         }
1329         */
1330     }
1331 
1332     public void setDepthBuffer(boolean depthBuffer) {
1333         // No-op until we support 3D
1334     }
1335 
1336     public void setDepthTest(boolean depthTest) {
1337         // No-op until we support 3D
1338     }
1339 
1340     public void sync() {
1341     }
1342 
1343     public void translate(float tx, float ty, float tz) {
1344         throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
1345     }
1346 
1347     public void setCulling(boolean cull) {
1348         this.cull = cull;
1349     }
1350 
1351     public boolean isCulling() {
1352         return this.cull;
1353     }
1354 
1355  public void setClipRectIndex(int index) {
1356         this.clipRectIndex = index;
1357     }
1358     public int getClipRectIndex() {
1359         return this.clipRectIndex;
1360     }
1361 
1362     public void setHasPreCullingBits(boolean hasBits) {
1363         this.hasPreCullingBits = hasBits;
1364     }
1365 
1366     public boolean hasPreCullingBits() {
1367         return hasPreCullingBits;
1368     }
1369 
1370     private NodePath renderRoot;
1371     @Override
1372     public void setRenderRoot(NodePath root) {
1373         this.renderRoot = root;
1374     }
1375 
1376     @Override
1377     public NodePath getRenderRoot() {
1378         return renderRoot;
1379     }
1380 
1381     public void setState3D(boolean flag) {
1382     }
1383 
1384     public boolean isState3D() {
1385         return false;
1386     }
1387 
1388     public void setup3DRendering() {
1389     }
1390 
1391     @Override
1392     public void setPixelScaleFactors(float pixelScaleX, float pixelScaleY) {
1393         this.pixelScaleX = pixelScaleX;
1394         this.pixelScaleY = pixelScaleY;
1395     }
1396 
1397     @Override
1398     public float getPixelScaleFactorX() {
1399         return pixelScaleX;
1400     }
1401 
1402     @Override
1403     public float getPixelScaleFactorY() {
1404         return pixelScaleY;
1405     }
1406 
1407     @Override
1408     public void blit(RTTexture srcTex, RTTexture dstTex,
1409             int srcX0, int srcY0, int srcX1, int srcY1,
1410             int dstX0, int dstY0, int dstX1, int dstY1) {
1411         throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
1412     }
1413 
1414     private static class AdaptorShape implements java.awt.Shape {
1415         private Shape prshape;
1416 
1417         public void setShape(Shape prshape) {
1418             this.prshape = prshape;
1419         }
1420 
1421         public boolean contains(double x, double y) {
1422             return prshape.contains((float) x, (float) y);
1423         }
1424 
1425         public boolean contains(java.awt.geom.Point2D p) {
1426             return contains(p.getX(), p.getY());
1427         }
1428 
1429         public boolean contains(double x, double y, double w, double h) {
1430             return prshape.contains((float) x, (float) y, (float) w, (float) h);
1431         }
1432 
1433         public boolean contains(java.awt.geom.Rectangle2D r) {
1434             return contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());
1435         }
1436 
1437         public boolean intersects(double x, double y, double w, double h) {
1438             return prshape.intersects((float) x, (float) y, (float) w, (float) h);
1439         }
1440 
1441         public boolean intersects(java.awt.geom.Rectangle2D r) {
1442             return intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());
1443         }
1444 
1445         public java.awt.Rectangle getBounds() {
1446             return getBounds2D().getBounds();
1447         }
1448 
1449         public java.awt.geom.Rectangle2D getBounds2D() {
1450             RectBounds b = prshape.getBounds();
1451             java.awt.geom.Rectangle2D r2d =
1452                 new java.awt.geom.Rectangle2D.Float();
1453             r2d.setFrameFromDiagonal(b.getMinX(), b.getMinY(), b.getMaxX(), b.getMaxY());
1454             return r2d;
1455         }
1456 
1457         private static AdaptorPathIterator tmpAdaptor =
1458                 new AdaptorPathIterator();
1459         private static java.awt.geom.PathIterator tmpAdaptor(PathIterator pi) {
1460             tmpAdaptor.setIterator(pi);
1461             return tmpAdaptor;
1462         }
1463 
1464         public java.awt.geom.PathIterator
1465             getPathIterator(java.awt.geom.AffineTransform at)
1466         {
1467             BaseTransform tx = (at == null) ? null : toPrTransform(at);
1468             return tmpAdaptor(prshape.getPathIterator(tx));
1469         }
1470 
1471         public java.awt.geom.PathIterator
1472             getPathIterator(java.awt.geom.AffineTransform at,
1473                             double flatness)
1474         {
1475             BaseTransform tx = (at == null) ? null : toPrTransform(at);
1476             return tmpAdaptor(prshape.getPathIterator(tx, (float) flatness));
1477         }
1478     }
1479 
1480     private static class AdaptorPathIterator
1481         implements java.awt.geom.PathIterator
1482     {
1483         private static int NUM_COORDS[] = { 2, 2, 4, 6, 0 };
1484         PathIterator priterator;
1485         float tmpcoords[];
1486 
1487         public void setIterator(PathIterator priterator) {
1488             this.priterator = priterator;
1489         }
1490 
1491         public int currentSegment(float[] coords) {
1492             return priterator.currentSegment(coords);
1493         }
1494 
1495         public int currentSegment(double[] coords) {
1496             if (tmpcoords == null) {
1497                 tmpcoords = new float[6];
1498             }
1499             int ret = priterator.currentSegment(tmpcoords);
1500             for (int i = 0; i &lt; NUM_COORDS[ret]; i++) {
1501                 coords[i] = (double) tmpcoords[i];
1502             }
1503             return ret;
1504         }
1505 
1506         public int getWindingRule() {
1507             return priterator.getWindingRule();
1508         }
1509 
1510         public boolean isDone() {
1511             return priterator.isDone();
1512         }
1513 
1514         public void next() {
1515             priterator.next();
1516         }
1517     }
1518 
1519     static abstract class FilterStroke implements java.awt.Stroke {
1520         protected java.awt.BasicStroke stroke;
1521 
1522         FilterStroke(java.awt.BasicStroke stroke) {
1523             this.stroke = stroke;
1524         }
1525 
1526         abstract protected java.awt.Shape makeStrokedRect(java.awt.geom.Rectangle2D r);
1527         abstract protected java.awt.Shape makeStrokedShape(java.awt.Shape s);
1528 
1529         public java.awt.Shape createStrokedShape(java.awt.Shape p) {
1530             if (p instanceof java.awt.geom.Rectangle2D) {
1531                 java.awt.Shape s = makeStrokedRect((java.awt.geom.Rectangle2D) p);
1532                 if (s != null) {
1533                     return s;
1534                 }
1535             }
1536             return makeStrokedShape(p);
1537         }
1538 
1539         // ArcIterator.btan(Math.PI/2)
1540         static final double CtrlVal = 0.5522847498307933;
1541 
1542         static java.awt.geom.Point2D cornerArc(java.awt.geom.GeneralPath gp,
1543                                                       float x0, float y0,
1544                                                       float xc, float yc,
1545                                                       float x1, float y1)
1546         {
1547             return cornerArc(gp, x0, y0, xc, yc, x1, y1, 0.5f);
1548         }
1549 
1550         static java.awt.geom.Point2D cornerArc(java.awt.geom.GeneralPath gp,
1551                                                       float x0, float y0,
1552                                                       float xc, float yc,
1553                                                       float x1, float y1, float t)
1554         {
1555             float xc0 = (float) (x0 + CtrlVal * (xc - x0));
1556             float yc0 = (float) (y0 + CtrlVal * (yc - y0));
1557             float xc1 = (float) (x1 + CtrlVal * (xc - x1));
1558             float yc1 = (float) (y1 + CtrlVal * (yc - y1));
1559             gp.curveTo(xc0, yc0, xc1, yc1, x1, y1);
1560 
1561             return new java.awt.geom.Point2D.Float(eval(x0, xc0, xc1, x1, t),
1562                                                    eval(y0, yc0, yc1, y1, t));
1563         }
1564 
1565         static float eval(float c0, float c1, float c2, float c3, float t) {
1566             c0 = c0 + (c1-c0) * t;
1567             c1 = c1 + (c2-c1) * t;
1568             c2 = c2 + (c3-c2) * t;
1569             c0 = c0 + (c1-c0) * t;
1570             c1 = c1 + (c2-c1) * t;
1571             return c0 + (c1-c0) * t;
1572         }
1573     }
1574 
1575     static class InnerStroke extends FilterStroke {
1576         InnerStroke(java.awt.BasicStroke stroke) {
1577             super(stroke);
1578         }
1579 
1580         protected java.awt.Shape makeStrokedRect(java.awt.geom.Rectangle2D r) {
1581             if (stroke.getDashArray() != null) {
1582                 return null;
1583             }
1584             float pad = stroke.getLineWidth() / 2f;
1585             if (pad &gt;= r.getWidth() || pad &gt;= r.getHeight()) {
1586                 return r;
1587             }
1588             float rx0 = (float) r.getX();
1589             float ry0 = (float) r.getY();
1590             float rx1 = rx0 + (float) r.getWidth();
1591             float ry1 = ry0 + (float) r.getHeight();
1592             java.awt.geom.GeneralPath gp = new java.awt.geom.GeneralPath();
1593             gp.moveTo(rx0, ry0);
1594             gp.lineTo(rx1, ry0);
1595             gp.lineTo(rx1, ry1);
1596             gp.lineTo(rx0, ry1);
1597             gp.closePath();
1598             rx0 += pad;
1599             ry0 += pad;
1600             rx1 -= pad;
1601             ry1 -= pad;
1602             gp.moveTo(rx0, ry0);
1603             gp.lineTo(rx0, ry1);
1604             gp.lineTo(rx1, ry1);
1605             gp.lineTo(rx1, ry0);
1606             gp.closePath();
1607             return gp;
1608         }
1609 
1610         // NOTE: This is a work in progress, not used yet
1611         protected java.awt.Shape makeStrokedEllipse(java.awt.geom.Ellipse2D e) {
1612             if (stroke.getDashArray() != null) {
1613                 return null;
1614             }
1615             float pad = stroke.getLineWidth() / 2f;
1616             float w = (float) e.getWidth();
1617             float h = (float) e.getHeight();
1618             if (w - 2*pad &gt; h * 2 || h - 2*pad &gt; w * 2) {
1619                 // If the inner ellipse is too &quot;squashed&quot; then we can not
1620                 // approximate it with just a single cubic per quadrant.
1621                 // NOTE: measure so we can relax this restriction and
1622                 // also consider modifying the code below to insert
1623                 // more cubics in those cases.
1624                 return null;
1625             }
1626             if (pad &gt;= w || pad &gt;= h) {
1627                 return e;
1628             }
1629             float x0 = (float) e.getX();
1630             float y0 = (float) e.getY();
1631             float xc = x0 + w / 2f;
1632             float yc = y0 + h / 2f;
1633             float x1 = x0 + w;
1634             float y1 = y0 + h;
1635             java.awt.geom.GeneralPath gp = new java.awt.geom.GeneralPath();
1636             gp.moveTo(xc, y0);
1637             cornerArc(gp, xc, y0, x1, y0, x1, yc);
1638             cornerArc(gp, x1, yc, x1, y1, xc, y1);
1639             cornerArc(gp, xc, y1, x0, y1, x0, yc);
1640             cornerArc(gp, x0, yc, x0, y0, xc, y0);
1641             gp.closePath();
1642             x0 += pad;
1643             y0 += pad;
1644             x1 -= pad;
1645             y1 -= pad;
1646             gp.moveTo(xc, y0);
1647             cornerArc(gp, xc, y0, x0, y0, x0, yc);
1648             cornerArc(gp, x0, yc, x0, y1, xc, y1);
1649             cornerArc(gp, xc, y1, x1, y1, x1, yc);
1650             cornerArc(gp, x1, yc, x1, y0, xc, y0);
1651             gp.closePath();
1652             return gp;
1653         }
1654 
1655         @Override
1656         protected java.awt.Shape makeStrokedShape(java.awt.Shape s) {
1657             java.awt.Shape ss = stroke.createStrokedShape(s);
1658             java.awt.geom.Area b = new java.awt.geom.Area(ss);
1659             b.intersect(new java.awt.geom.Area(s));
1660             return b;
1661         }
1662     }
1663 
1664     static class OuterStroke extends FilterStroke {
1665         static double SQRT_2 = Math.sqrt(2);
1666 
1667         OuterStroke(java.awt.BasicStroke stroke) {
1668             super(stroke);
1669         }
1670 
1671         protected java.awt.Shape makeStrokedRect(java.awt.geom.Rectangle2D r) {
1672             if (stroke.getDashArray() != null) {
1673                 return null;
1674             }
1675             float pad = stroke.getLineWidth() / 2f;
1676             float rx0 = (float) r.getX();
1677             float ry0 = (float) r.getY();
1678             float rx1 = rx0 + (float) r.getWidth();
1679             float ry1 = ry0 + (float) r.getHeight();
1680             java.awt.geom.GeneralPath gp = new java.awt.geom.GeneralPath();
1681             // clockwise
1682             gp.moveTo(rx0, ry0);
1683             gp.lineTo(rx1, ry0);
1684             gp.lineTo(rx1, ry1);
1685             gp.lineTo(rx0, ry1);
1686             gp.closePath();
1687             float ox0 = rx0 - pad;
1688             float oy0 = ry0 - pad;
1689             float ox1 = rx1 + pad;
1690             float oy1 = ry1 + pad;
1691             switch (stroke.getLineJoin()) {
1692             case BasicStroke.JOIN_MITER:
1693                 // A miter limit of less than sqrt(2) bevels right angles...
1694                 if (stroke.getMiterLimit() &gt;= SQRT_2) {
1695                     // counter-clockwise
1696                     gp.moveTo(ox0, oy0);
1697                     gp.lineTo(ox0, oy1);
1698                     gp.lineTo(ox1, oy1);
1699                     gp.lineTo(ox1, oy0);
1700                     gp.closePath();
1701                     break;
1702                 }
1703                 // NO BREAK
1704             case BasicStroke.JOIN_BEVEL:
1705                 // counter-clockwise
1706                 gp.moveTo(ox0, ry0);
1707                 gp.lineTo(ox0, ry1);  // left edge
1708                 gp.lineTo(rx0, oy1);  // ll corner
1709                 gp.lineTo(rx1, oy1);  // bottom edge
1710                 gp.lineTo(ox1, ry1);  // lr corner
1711                 gp.lineTo(ox1, ry0);  // right edge
1712                 gp.lineTo(rx1, oy0);  // ur corner
1713                 gp.lineTo(rx0, oy0);  // top edge
1714                 gp.closePath();       // ul corner
1715                 break;
1716             case BasicStroke.JOIN_ROUND:
1717                 // counter-clockwise
1718                 gp.moveTo(ox0, ry0);
1719                 gp.lineTo(ox0, ry1);                          // left edge
1720                 cornerArc(gp, ox0, ry1, ox0, oy1, rx0, oy1);  // ll corner
1721                 gp.lineTo(rx1, oy1);                          // bottom edge
1722                 cornerArc(gp, rx1, oy1, ox1, oy1, ox1, ry1);  // lr corner
1723                 gp.lineTo(ox1, ry0);                          // right edge
1724                 cornerArc(gp, ox1, ry0, ox1, oy0, rx1, oy0);  // ur corner
1725                 gp.lineTo(rx0, oy0);                          // top edge
1726                 cornerArc(gp, rx0, oy0, ox0, oy0, ox0, ry0);  // ul corner
1727                 gp.closePath();
1728                 break;
1729             default:
1730                 throw new InternalError(&quot;Unrecognized line join style&quot;);
1731             }
1732             return gp;
1733         }
1734 
1735         // NOTE: This is a work in progress, not used yet
1736         protected java.awt.Shape makeStrokedEllipse(java.awt.geom.Ellipse2D e) {
1737             if (stroke.getDashArray() != null) {
1738                 return null;
1739             }
1740             float pad = stroke.getLineWidth() / 2f;
1741             float w = (float) e.getWidth();
1742             float h = (float) e.getHeight();
1743             if (w &gt; h * 2 || h &gt; w * 2) {
1744                 // If the inner ellipse is too &quot;squashed&quot; then we can not
1745                 // approximate it with just a single cubic per quadrant.
1746                 // NOTE: measure so we can relax this restriction and
1747                 // also consider modifying the code below to insert
1748                 // more cubics in those cases.
1749                 return null;
1750             }
1751             float x0 = (float) e.getX();
1752             float y0 = (float) e.getY();
1753             float xc = x0 + w / 2f;
1754             float yc = y0 + h / 2f;
1755             float x1 = x0 + w;
1756             float y1 = y0 + h;
1757             java.awt.geom.GeneralPath gp = new java.awt.geom.GeneralPath();
1758             gp.moveTo(xc, y0);
1759             cornerArc(gp, xc, y0, x1, y0, x1, yc);
1760             cornerArc(gp, x1, yc, x1, y1, xc, y1);
1761             cornerArc(gp, xc, y1, x0, y1, x0, yc);
1762             cornerArc(gp, x0, yc, x0, y0, xc, y0);
1763             gp.closePath();
1764             x0 -= pad;
1765             y0 -= pad;
1766             x1 += pad;
1767             y1 += pad;
1768             gp.moveTo(xc, y0);
1769             cornerArc(gp, xc, y0, x0, y0, x0, yc);
1770             cornerArc(gp, x0, yc, x0, y1, xc, y1);
1771             cornerArc(gp, xc, y1, x1, y1, x1, yc);
1772             cornerArc(gp, x1, yc, x1, y0, xc, y0);
1773             gp.closePath();
1774             return gp;
1775         }
1776 
1777         @Override
1778         protected java.awt.Shape makeStrokedShape(java.awt.Shape s) {
1779             java.awt.Shape ss = stroke.createStrokedShape(s);
1780             java.awt.geom.Area b = new java.awt.geom.Area(ss);
1781             b.subtract(new java.awt.geom.Area(s));
1782             return b;
1783         }
1784     }
1785 
1786     @Override
1787     public void setLights(NGLightBase[] lights) {
1788         // Light are not supported by J2d
1789     }
1790 
1791     @Override
1792     public NGLightBase[] getLights() {
1793         // Light are not supported by J2d
1794         return null;
1795     }
1796 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>