<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/java/javafx/scene/web/WebEngine.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.web;
  27 
  28 import com.sun.javafx.logging.PlatformLogger;
  29 import com.sun.javafx.scene.web.Debugger;
  30 import com.sun.javafx.scene.web.Printable;
  31 import com.sun.javafx.tk.TKPulseListener;
  32 import com.sun.javafx.tk.Toolkit;
  33 import com.sun.javafx.webkit.*;
  34 import com.sun.javafx.webkit.prism.PrismGraphicsManager;
  35 import com.sun.javafx.webkit.prism.PrismInvoker;
  36 import com.sun.javafx.webkit.prism.theme.PrismRenderer;
  37 import com.sun.javafx.webkit.theme.RenderThemeImpl;
  38 import com.sun.javafx.webkit.theme.Renderer;
  39 import com.sun.webkit.*;
  40 import com.sun.webkit.graphics.WCGraphicsManager;
  41 import com.sun.webkit.network.URLs;
  42 import com.sun.webkit.network.Util;
  43 import javafx.animation.AnimationTimer;
  44 import javafx.application.Platform;
  45 import javafx.beans.InvalidationListener;
  46 import javafx.beans.property.*;
  47 import javafx.concurrent.Worker;
  48 import javafx.event.EventHandler;
  49 import javafx.event.EventType;
  50 import javafx.geometry.Rectangle2D;
  51 import javafx.print.PageLayout;
  52 import javafx.print.PrinterJob;
  53 import javafx.scene.Node;
  54 import javafx.util.Callback;
  55 import org.w3c.dom.Document;
  56 
  57 import java.io.BufferedInputStream;
  58 import java.io.File;
  59 import java.io.IOException;
  60 import static java.lang.String.format;
  61 import java.lang.ref.WeakReference;
  62 import java.net.MalformedURLException;
  63 import java.net.URLConnection;
  64 import java.nio.file.Files;
  65 import java.nio.file.Path;
  66 import java.nio.file.attribute.PosixFilePermissions;
  67 import java.security.AccessController;
  68 import java.security.PrivilegedAction;
  69 import java.util.ArrayList;
  70 import java.util.Base64;
  71 import java.util.List;
  72 import java.util.Objects;
  73 
  74 import static com.sun.webkit.LoadListenerClient.*;
  75 
  76 /**
  77  * {@code WebEngine} is a non-visual object capable of managing one Web page
  78  * at a time. It loads Web pages, creates their document models, applies
  79  * styles as necessary, and runs JavaScript on pages. It provides access
  80  * to the document model of the current page, and enables two-way
  81  * communication between a Java application and JavaScript code of the page.
  82  *
  83  * &lt;p&gt;&lt;b&gt;Loading Web Pages&lt;/b&gt;&lt;/p&gt;
  84  * &lt;p&gt;The {@code WebEngine} class provides two ways to load content into a
  85  * {@code WebEngine} object:
  86  * &lt;ul&gt;
  87  * &lt;li&gt;From an arbitrary URL using the {@link #load} method. This method uses
  88  *     the {@code java.net} package for network access and protocol handling.
  89  * &lt;li&gt;From an in-memory String using the
  90  *     {@link #loadContent(java.lang.String, java.lang.String)} and
  91  *     {@link #loadContent(java.lang.String)} methods.
  92  * &lt;/ul&gt;
  93  * &lt;p&gt;Loading always happens on a background thread. Methods that initiate
  94  * loading return immediately after scheduling a background job. To track
  95  * progress and/or cancel a job, use the {@link javafx.concurrent.Worker}
  96  * instance available from the {@link #getLoadWorker} method.
  97  *
  98  * &lt;p&gt;The following example changes the stage title when loading completes
  99  * successfully:
 100  * &lt;pre&gt;{@code
 101     import javafx.concurrent.Worker.State;
 102     final Stage stage;
 103     webEngine.getLoadWorker().stateProperty().addListener(
 104         new ChangeListener&lt;State&gt;() {
 105             public void changed(ObservableValue ov, State oldState, State newState) {
 106                 if (newState == State.SUCCEEDED) {
 107                     stage.setTitle(webEngine.getLocation());
 108                 }
 109             }
 110         });
 111     webEngine.load(&quot;http://javafx.com&quot;);
 112  * }&lt;/pre&gt;
 113  *
 114  * &lt;p&gt;&lt;b&gt;User Interface Callbacks&lt;/b&gt;&lt;/p&gt;
 115  * &lt;p&gt;A number of user interface callbacks may be registered with a
 116  * {@code WebEngine} object. These callbacks are invoked when a script running
 117  * on the page requests a user interface operation to be performed, for
 118  * example, opens a popup window or changes status text. A {@code WebEngine}
 119  * object cannot handle such requests internally, so it passes the request to
 120  * the corresponding callbacks. If no callback is defined for a specific
 121  * operation, the request is silently ignored.
 122  *
 123  * &lt;p&gt;The table below shows JavaScript user interface methods and properties
 124  * with their corresponding {@code WebEngine} callbacks:
 125  * &lt;table border=&quot;1&quot;&gt;
 126  * &lt;caption&gt;JavaScript Callback Table&lt;/caption&gt;
 127  * &lt;tr&gt;
 128  *     &lt;th scope=&quot;col&quot;&gt;JavaScript method/property&lt;/th&gt;
 129  *     &lt;th scope=&quot;col&quot;&gt;WebEngine callback&lt;/th&gt;
 130  * &lt;/tr&gt;
 131  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.alert()}&lt;/th&gt;&lt;td&gt;{@code onAlert}&lt;/td&gt;&lt;/tr&gt;
 132  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.confirm()}&lt;/th&gt;&lt;td&gt;{@code confirmHandler}&lt;/td&gt;&lt;/tr&gt;
 133  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.open()}&lt;/th&gt;&lt;td&gt;{@code createPopupHandler}&lt;/td&gt;&lt;/tr&gt;
 134  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.open()} and&lt;br&gt;
 135  *         {@code window.close()}&lt;/th&gt;&lt;td&gt;{@code onVisibilityChanged}&lt;/td&gt;&lt;/tr&gt;
 136  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.prompt()}&lt;/th&gt;&lt;td&gt;{@code promptHandler}&lt;/td&gt;&lt;/tr&gt;
 137  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Setting {@code window.status}&lt;/th&gt;&lt;td&gt;{@code onStatusChanged}&lt;/td&gt;&lt;/tr&gt;
 138  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Setting any of the following:&lt;br&gt;
 139  *         {@code window.innerWidth}, {@code window.innerHeight},&lt;br&gt;
 140  *         {@code window.outerWidth}, {@code window.outerHeight},&lt;br&gt;
 141  *         {@code window.screenX}, {@code window.screenY},&lt;br&gt;
 142  *         {@code window.screenLeft}, {@code window.screenTop}&lt;/th&gt;
 143  *         &lt;td&gt;{@code onResized}&lt;/td&gt;&lt;/tr&gt;
 144  * &lt;/table&gt;
 145  *
 146  * &lt;p&gt;The following example shows a callback that resizes a browser window:
 147  * &lt;pre&gt;{@code
 148     Stage stage;
 149     webEngine.setOnResized(
 150         new EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;() {
 151             public void handle(WebEvent&lt;Rectangle2D&gt; ev) {
 152                 Rectangle2D r = ev.getData();
 153                 stage.setWidth(r.getWidth());
 154                 stage.setHeight(r.getHeight());
 155             }
 156         });
 157  * }&lt;/pre&gt;
 158  *
 159  * &lt;p&gt;&lt;b&gt;Access to Document Model&lt;/b&gt;&lt;/p&gt;
 160  * &lt;p&gt;The {@code WebEngine} objects create and manage a Document Object Model
 161  * (DOM) for their Web pages. The model can be accessed and modified using
 162  * Java DOM Core classes. The {@link #getDocument()} method provides access
 163  * to the root of the model. Additionally DOM Event specification is supported
 164  * to define event handlers in Java code.
 165  *
 166  * &lt;p&gt;The following example attaches a Java event listener to an element of
 167  * a Web page. Clicking on the element causes the application to exit:
 168  * &lt;pre&gt;{@code
 169     EventListener listener = new EventListener() {
 170         public void handleEvent(Event ev) {
 171             Platform.exit();
 172         }
 173     };
 174 
 175     Document doc = webEngine.getDocument();
 176     Element el = doc.getElementById(&quot;exit-app&quot;);
 177     ((EventTarget) el).addEventListener(&quot;click&quot;, listener, false);
 178  * }&lt;/pre&gt;
 179  *
 180  * &lt;p&gt;&lt;b&gt;Evaluating JavaScript expressions&lt;/b&gt;&lt;/p&gt;
 181  * &lt;p&gt;It is possible to execute arbitrary JavaScript code in the context of
 182  * the current page using the {@link #executeScript} method. For example:
 183  * &lt;pre&gt;{@code
 184     webEngine.executeScript(&quot;history.back()&quot;);
 185  * }&lt;/pre&gt;
 186  *
 187  * &lt;p&gt;The execution result is returned to the caller,
 188  * as described in the next section.
 189  *
 190  * &lt;p&gt;&lt;b&gt;Mapping JavaScript values to Java objects&lt;/b&gt;&lt;/p&gt;
 191  *
 192  * JavaScript values are represented using the obvious Java classes:
 193  * null becomes Java null; a boolean becomes a {@code java.lang.Boolean};
 194  * and a string becomes a {@code java.lang.String}.
 195  * A number can be {@code java.lang.Double} or a {@code java.lang.Integer},
 196  * depending.
 197  * The undefined value maps to a specific unique String
 198  * object whose value is {@code &quot;undefined&quot;}.
 199  * &lt;p&gt;
 200  * If the result is a
 201  * JavaScript object, it is wrapped as an instance of the
 202  * {@link netscape.javascript.JSObject} class.
 203  * (As a special case, if the JavaScript object is
 204  * a {@code JavaRuntimeObject} as discussed in the next section,
 205  * then the original Java object is extracted instead.)
 206  * The {@code JSObject} class is a proxy that provides access to
 207  * methods and properties of its underlying JavaScript object.
 208  * The most commonly used {@code JSObject} methods are
 209  * {@link netscape.javascript.JSObject#getMember getMember}
 210  * (to read a named property),
 211  * {@link netscape.javascript.JSObject#setMember setMember}
 212  * (to set or define a property),
 213  * and {@link netscape.javascript.JSObject#call call}
 214  * (to call a function-valued property).
 215  * &lt;p&gt;
 216  * A DOM {@code Node} is mapped to an object that both extends
 217  * {@code JSObject} and implements the appropriate DOM interfaces.
 218  * To get a {@code JSObject} object for a {@code Node} just do a cast:
 219  * &lt;pre&gt;
 220  * JSObject jdoc = (JSObject) webEngine.getDocument();
 221  * &lt;/pre&gt;
 222  * &lt;p&gt;
 223  * In some cases the context provides a specific Java type that guides
 224  * the conversion.
 225  * For example if setting a Java {@code String} field from a JavaScript
 226  * expression, then the JavaScript value is converted to a string.
 227  *
 228  * &lt;p&gt;&lt;b&gt;Mapping Java objects to JavaScript values&lt;/b&gt;&lt;/p&gt;
 229  *
 230  * The arguments of the {@code JSObject} methods {@code setMember} and
 231  * {@code call} pass Java objects to the JavaScript environment.
 232  * This is roughly the inverse of the JavaScript-to-Java mapping
 233  * described above:
 234  * Java {@code String},  {@code Number}, or {@code Boolean} objects
 235  * are converted to the obvious JavaScript values. A  {@code JSObject}
 236  * object is converted to the original wrapped JavaScript object.
 237  * Otherwise a {@code JavaRuntimeObject} is created.  This is
 238  * a JavaScript object that acts as a proxy for the Java object,
 239  * in that accessing properties of the {@code JavaRuntimeObject}
 240  * causes the Java field or method with the same name to be accessed.
 241  * &lt;p&gt; Note that the Java objects bound using
 242  * {@link netscape.javascript.JSObject#setMember JSObject.setMember},
 243  * {@link netscape.javascript.JSObject#setSlot JSObject.setSlot}, and
 244  * {@link netscape.javascript.JSObject#call JSObject.call}
 245  * are implemented using weak references. This means that the Java object
 246  * can be garbage collected, causing subsequent accesses to the JavaScript
 247  * objects to have no effect.
 248  *
 249  * &lt;p&gt;&lt;b&gt;Calling back to Java from JavaScript&lt;/b&gt;&lt;/p&gt;
 250  *
 251  * &lt;p&gt;The {@link netscape.javascript.JSObject#setMember JSObject.setMember}
 252  * method is useful to enable upcalls from JavaScript
 253  * into Java code, as illustrated by the following example. The Java code
 254  * establishes a new JavaScript object named {@code app}. This object has one
 255  * public member, the method {@code exit}.
 256  * &lt;pre&gt;&lt;code&gt;
 257 public class JavaApplication {
 258     public void exit() {
 259         Platform.exit();
 260     }
 261 }
 262 ...
 263 JavaApplication javaApp = new JavaApplication();
 264 JSObject window = (JSObject) webEngine.executeScript(&quot;window&quot;);
 265 window.setMember(&quot;app&quot;, javaApp);
 266  * &lt;/code&gt;&lt;/pre&gt;
 267  * You can then refer to the object and the method from your HTML page:
 268  * &lt;pre&gt;{@code
 269     &lt;a href=&quot;&quot; onclick=&quot;app.exit()&quot;&gt;Click here to exit application&lt;/a&gt;
 270  * }&lt;/pre&gt;
 271  * &lt;p&gt;When a user clicks the link the application is closed.
 272  * &lt;p&gt;
 273  * Note that in the above example, the application holds a reference
 274  * to the {@code JavaApplication} instance. This is required for the callback
 275  * from JavaScript to execute the desired method.
 276  * &lt;p&gt; In the following example, the application does not hold a reference
 277  * to the Java object:
 278  * &lt;pre&gt;&lt;code&gt;
 279  * JSObject window = (JSObject) webEngine.executeScript(&quot;window&quot;);
 280  * window.setMember(&quot;app&quot;, new JavaApplication());
 281  * &lt;/code&gt;&lt;/pre&gt;
 282  * &lt;p&gt; In this case, since the property value is a local object, {@code &quot;new JavaApplication()&quot;},
 283  * the value may be garbage collected in next GC cycle.
 284  * &lt;p&gt;
 285  * When a user clicks the link, it does not guarantee to execute the callback method {@code exit}.
 286  * &lt;p&gt;
 287  * If there are multiple Java methods with the given name,
 288  * then the engine selects one matching the number of parameters
 289  * in the call.  (Varargs are not handled.) An unspecified one is
 290  * chosen if there are multiple ones with the correct number of parameters.
 291  * &lt;p&gt;
 292  * You can pick a specific overloaded method by listing the
 293  * parameter types in an &quot;extended method name&quot;, which has the
 294  * form &lt;code&gt;&quot;&lt;var&gt;method_name&lt;/var&gt;(&lt;var&gt;param_type1&lt;/var&gt;,...,&lt;var&gt;param_typen&lt;/var&gt;)&quot;&lt;/code&gt;.  Typically you&#39;d write the JavaScript expression:
 295  * &lt;pre&gt;
 296  * &lt;code&gt;&lt;var&gt;receiver&lt;/var&gt;[&quot;&lt;var&gt;method_name&lt;/var&gt;(&lt;var&gt;param_type1&lt;/var&gt;,...,&lt;var&gt;param_typeN&lt;/var&gt;)&quot;](&lt;var&gt;arg1&lt;/var&gt;,...,&lt;var&gt;argN&lt;/var&gt;)&lt;/code&gt;
 297  * &lt;/pre&gt;
 298  *
 299  * &lt;p&gt;
 300  * The Java class and method must both be declared public.
 301  * &lt;/p&gt;
 302  *
 303  * &lt;p&gt;&lt;b&gt;Deploying an Application as a Module&lt;/b&gt;&lt;/p&gt;
 304  * &lt;p&gt;
 305  * If any Java class passed to JavaScript is in a named module, then it must
 306  * be reflectively accessible to the {@code javafx.web} module.
 307  * A class is reflectively accessible if the module
 308  * {@link Module#isOpen(String,Module) opens} the containing package to at
 309  * least the {@code javafx.web} module.
 310  * Otherwise, the method will not be called, and no error or
 311  * warning will be produced.
 312  * &lt;/p&gt;
 313  * &lt;p&gt;
 314  * For example, if {@code com.foo.MyClass} is in the {@code foo.app} module,
 315  * the {@code module-info.java} might
 316  * look like this:
 317  * &lt;/p&gt;
 318  *
 319 &lt;pre&gt;{@code module foo.app {
 320     opens com.foo to javafx.web;
 321 }}&lt;/pre&gt;
 322  *
 323  * &lt;p&gt;
 324  * Alternatively, a class is reflectively accessible if the module
 325  * {@link Module#isExported(String) exports} the containing package
 326  * unconditionally.
 327  * &lt;/p&gt;
 328  *
 329  * &lt;p&gt;&lt;b&gt;Threading&lt;/b&gt;&lt;/p&gt;
 330  * &lt;p&gt;{@code WebEngine} objects must be created and accessed solely from the
 331  * JavaFX Application thread. This rule also applies to any DOM and JavaScript
 332  * objects obtained from the {@code WebEngine} object.
 333  * @since JavaFX 2.0
 334  */
 335 final public class WebEngine {
 336     static {
 337         Accessor.setPageAccessor(w -&gt; w == null ? null : w.getPage());
 338 
 339         Invoker.setInvoker(new PrismInvoker());
 340         Renderer.setRenderer(new PrismRenderer());
 341         WCGraphicsManager.setGraphicsManager(new PrismGraphicsManager());
 342         CursorManager.setCursorManager(new CursorManagerImpl());
 343         com.sun.webkit.EventLoop.setEventLoop(new EventLoopImpl());
 344         ThemeClient.setDefaultRenderTheme(new RenderThemeImpl());
 345         Utilities.setUtilities(new UtilitiesImpl());
 346     }
 347 
 348     private static final PlatformLogger logger =
 349             PlatformLogger.getLogger(WebEngine.class.getName());
 350 
 351     /**
 352      * The number of instances of this class.
 353      * Used to start and stop the pulse timer.
 354      */
 355     private static int instanceCount = 0;
 356 
 357     /**
 358      * The node associated with this engine. There is a one-to-one correspondence
 359      * between the WebView and its WebEngine (although not all WebEngines have
 360      * a WebView, every WebView has one and only one WebEngine).
 361      */
 362     private final ObjectProperty&lt;WebView&gt; view = new SimpleObjectProperty&lt;WebView&gt;(this, &quot;view&quot;);
 363 
 364     /**
 365      * The Worker which shows progress of the web engine as it loads pages.
 366      */
 367     private final LoadWorker loadWorker = new LoadWorker();
 368 
 369     /**
 370      * The object that provides interaction with the native webkit core.
 371      */
 372     private final WebPage page;
 373 
 374     private final SelfDisposer disposer;
 375 
 376     private final DebuggerImpl debugger = new DebuggerImpl();
 377 
 378     private boolean userDataDirectoryApplied = false;
 379 
 380 
 381     /**
 382      * Returns a {@link javafx.concurrent.Worker} object that can be used to
 383      * track loading progress.
 384      *
 385      * @return the {@code Worker} object
 386      */
 387     public final Worker&lt;Void&gt; getLoadWorker() {
 388         return loadWorker;
 389     }
 390 
 391 
 392     /*
 393      * The final document. This may be null if no document has been loaded.
 394      */
 395     private final DocumentProperty document = new DocumentProperty();
 396 
 397     public final Document getDocument() { return document.getValue(); }
 398 
 399     /**
 400      * Document object for the current Web page. The value is {@code null}
 401      * if the Web page failed to load.
 402      *
 403      * @return the document property
 404      */
 405     public final ReadOnlyObjectProperty&lt;Document&gt; documentProperty() {
 406         return document;
 407     }
 408 
 409 
 410     /*
 411      * The location of the current page. This may return null.
 412      */
 413     private final ReadOnlyStringWrapper location = new ReadOnlyStringWrapper(this, &quot;location&quot;);
 414 
 415     public final String getLocation() { return location.getValue(); }
 416 
 417     /**
 418      * URL of the current Web page. If the current page has no URL,
 419      * the value is an empty String.
 420      *
 421      * @return the location property
 422      */
 423     public final ReadOnlyStringProperty locationProperty() { return location.getReadOnlyProperty(); }
 424 
 425     private void updateLocation(String value) {
 426         this.location.set(value);
 427         this.document.invalidate(false);
 428         this.title.set(null);
 429     }
 430 
 431 
 432     /*
 433      * The page title.
 434      */
 435     private final ReadOnlyStringWrapper title = new ReadOnlyStringWrapper(this, &quot;title&quot;);
 436 
 437     public final String getTitle() { return title.getValue(); }
 438 
 439     /**
 440      * Title of the current Web page. If the current page has no title,
 441      * the value is {@code null}.
 442      *
 443      * @return the title property
 444      */
 445     public final ReadOnlyStringProperty titleProperty() { return title.getReadOnlyProperty(); }
 446 
 447     private void updateTitle() {
 448         title.set(page.getTitle(page.getMainFrame()));
 449     }
 450 
 451     //
 452     // Settings
 453 
 454     /**
 455      * Specifies whether JavaScript execution is enabled.
 456      *
 457      * @defaultValue true
 458      * @since JavaFX 2.2
 459      */
 460     private BooleanProperty javaScriptEnabled;
 461 
 462     public final void setJavaScriptEnabled(boolean value) {
 463         javaScriptEnabledProperty().set(value);
 464     }
 465 
 466     public final boolean isJavaScriptEnabled() {
 467         return javaScriptEnabled == null ? true : javaScriptEnabled.get();
 468     }
 469 
 470     public final BooleanProperty javaScriptEnabledProperty() {
 471         if (javaScriptEnabled == null) {
 472             javaScriptEnabled = new BooleanPropertyBase(true) {
 473                 @Override public void invalidated() {
 474                     checkThread();
 475                     page.setJavaScriptEnabled(get());
 476                 }
 477 
 478                 @Override public Object getBean() {
 479                     return WebEngine.this;
 480                 }
 481 
 482                 @Override public String getName() {
 483                     return &quot;javaScriptEnabled&quot;;
 484                 }
 485             };
 486         }
 487         return javaScriptEnabled;
 488     }
 489 
 490     /**
 491      * Location of the user stylesheet as a string URL.
 492      *
 493      * &lt;p&gt;This should be a local URL, i.e. either {@code &#39;data:&#39;},
<a name="1" id="anc1"></a><span class="line-modified"> 494      * {@code &#39;file:&#39;}, or {@code &#39;jar:&#39;}. Remote URLs are not allowed</span>
 495      * for security reasons.
 496      *
 497      * @defaultValue null
 498      * @since JavaFX 2.2
 499      */
 500     private StringProperty userStyleSheetLocation;
 501 
 502     public final void setUserStyleSheetLocation(String value) {
 503         userStyleSheetLocationProperty().set(value);
 504     }
 505 
 506     public final String getUserStyleSheetLocation() {
 507         return userStyleSheetLocation == null ? null : userStyleSheetLocation.get();
 508     }
 509 
 510     private byte[] readFully(BufferedInputStream in) throws IOException {
 511         final int BUF_SIZE = 4096;
 512         int outSize = 0;
 513         final List&lt;byte[]&gt; outList = new ArrayList&lt;&gt;();
 514         byte[] buffer = new byte[BUF_SIZE];
 515 
 516         while (true) {
 517             int nBytes = in.read(buffer);
 518             if (nBytes &lt; 0) break;
 519 
 520             byte[] chunk;
 521             if (nBytes == buffer.length) {
 522                 chunk = buffer;
 523                 buffer = new byte[BUF_SIZE];
 524             } else {
 525                 chunk = new byte[nBytes];
 526                 System.arraycopy(buffer, 0, chunk, 0, nBytes);
 527             }
 528             outList.add(chunk);
 529             outSize += nBytes;
 530         }
 531 
 532         final byte[] out = new byte[outSize];
 533         int outPos = 0;
 534         for (byte[] chunk : outList) {
 535             System.arraycopy(chunk, 0, out, outPos, chunk.length);
 536             outPos += chunk.length;
 537         }
 538 
 539         return out;
 540     }
 541 
 542     public final StringProperty userStyleSheetLocationProperty() {
 543         if (userStyleSheetLocation == null) {
 544             userStyleSheetLocation = new StringPropertyBase(null) {
 545                 private final static String DATA_PREFIX = &quot;data:text/css;charset=utf-8;base64,&quot;;
 546 
 547                 @Override public void invalidated() {
 548                     checkThread();
 549                     String url = get();
 550                     String dataUrl;
 551                     if (url == null || url.length() &lt;= 0) {
 552                         dataUrl = null;
 553                     } else if (url.startsWith(DATA_PREFIX)) {
 554                         dataUrl = url;
 555                     } else if (url.startsWith(&quot;file:&quot;) ||
 556                                url.startsWith(&quot;jar:&quot;)  ||
<a name="2" id="anc2"></a>
 557                                url.startsWith(&quot;data:&quot;))
 558                     {
 559                         try {
 560                             URLConnection conn = URLs.newURL(url).openConnection();
 561                             conn.connect();
 562 
 563                             BufferedInputStream in =
 564                                     new BufferedInputStream(conn.getInputStream());
 565                             byte[] inBytes = readFully(in);
 566                             String out = Base64.getMimeEncoder().encodeToString(inBytes);
 567                             dataUrl = DATA_PREFIX + out;
 568                         } catch (IOException e) {
 569                             throw new RuntimeException(e);
 570                         }
 571                     } else {
 572                         throw new IllegalArgumentException(&quot;Invalid stylesheet URL&quot;);
 573                     }
 574                     page.setUserStyleSheetLocation(dataUrl);
 575                 }
 576 
 577                 @Override public Object getBean() {
 578                     return WebEngine.this;
 579                 }
 580 
 581                 @Override public String getName() {
 582                     return &quot;userStyleSheetLocation&quot;;
 583                 }
 584             };
 585         }
 586         return userStyleSheetLocation;
 587     }
 588 
 589     /**
 590      * Specifies the directory to be used by this {@code WebEngine}
 591      * to store local user data.
 592      *
 593      * &lt;p&gt;If the value of this property is not {@code null},
 594      * the {@code WebEngine} will attempt to store local user data
 595      * in the respective directory.
 596      * If the value of this property is {@code null},
 597      * the {@code WebEngine} will attempt to store local user data
 598      * in an automatically selected system-dependent user- and
 599      * application-specific directory.
 600      *
 601      * &lt;p&gt;When a {@code WebEngine} is about to start loading a web
 602      * page or executing a script for the first time, it checks whether
 603      * it can actually use the directory specified by this property.
 604      * If the check fails for some reason, the {@code WebEngine} invokes
 605      * the {@link WebEngine#onErrorProperty WebEngine.onError} event handler,
 606      * if any, with a {@link WebErrorEvent} describing the reason.
 607      * If the invoked event handler modifies the {@code userDataDirectory}
 608      * property, the {@code WebEngine} retries with the new value as soon
 609      * as the handler returns. If the handler does not modify the
 610      * {@code userDataDirectory} property (which is the default),
 611      * the {@code WebEngine} continues without local user data.
 612      *
 613      * &lt;p&gt;Once the {@code WebEngine} has started loading a web page or
 614      * executing a script, changes made to this property have no effect
 615      * on where the {@code WebEngine} stores or will store local user
 616      * data.
 617      *
 618      * &lt;p&gt;Currently, the directory specified by this property is used
 619      * only to store the data that backs the {@code window.localStorage}
 620      * objects. In the future, more types of data can be added.
 621      *
 622      * @defaultValue {@code null}
 623      * @since JavaFX 8.0
 624      */
 625     private final ObjectProperty&lt;File&gt; userDataDirectory =
 626             new SimpleObjectProperty&lt;&gt;(this, &quot;userDataDirectory&quot;);
 627 
 628     public final File getUserDataDirectory() {
 629         return userDataDirectory.get();
 630     }
 631 
 632     public final void setUserDataDirectory(File value) {
 633         userDataDirectory.set(value);
 634     }
 635 
 636     public final ObjectProperty&lt;File&gt; userDataDirectoryProperty() {
 637         return userDataDirectory;
 638     }
 639 
 640     /**
 641      * Specifies user agent ID string. This string is the value of the
 642      * {@code User-Agent} HTTP header.
 643      *
 644      * @defaultValue system dependent
 645      * @since JavaFX 8.0
 646      */
 647     private StringProperty userAgent;
 648 
 649     public final void setUserAgent(String value) {
 650         userAgentProperty().set(value);
 651     }
 652 
 653     public final String getUserAgent() {
 654         return userAgent == null ? page.getUserAgent() : userAgent.get();
 655     }
 656 
 657     public final StringProperty userAgentProperty() {
 658         if (userAgent == null) {
 659             userAgent = new StringPropertyBase(page.getUserAgent()) {
 660                 @Override public void invalidated() {
 661                     checkThread();
 662                     page.setUserAgent(get());
 663                 }
 664 
 665                 @Override public Object getBean() {
 666                     return WebEngine.this;
 667                 }
 668 
 669                 @Override public String getName() {
 670                     return &quot;userAgent&quot;;
 671                 }
 672             };
 673         }
 674         return userAgent;
 675     }
 676 
 677     private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onAlert
 678             = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt;(this, &quot;onAlert&quot;);
 679 
 680     public final EventHandler&lt;WebEvent&lt;String&gt;&gt; getOnAlert() { return onAlert.get(); }
 681 
 682     public final void setOnAlert(EventHandler&lt;WebEvent&lt;String&gt;&gt; handler) { onAlert.set(handler); }
 683 
 684     /**
 685      * JavaScript {@code alert} handler property. This handler is invoked
 686      * when a script running on the Web page calls the {@code alert} function.
 687      * @return the onAlert property
 688      */
 689     public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onAlertProperty() { return onAlert; }
 690 
 691 
 692     private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onStatusChanged
 693             = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt;(this, &quot;onStatusChanged&quot;);
 694 
 695     public final EventHandler&lt;WebEvent&lt;String&gt;&gt; getOnStatusChanged() { return onStatusChanged.get(); }
 696 
 697     public final void setOnStatusChanged(EventHandler&lt;WebEvent&lt;String&gt;&gt; handler) { onStatusChanged.set(handler); }
 698 
 699     /**
 700      * JavaScript status handler property. This handler is invoked when
 701      * a script running on the Web page sets {@code window.status} property.
 702      * @return the onStatusChanged property
 703      */
 704     public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onStatusChangedProperty() { return onStatusChanged; }
 705 
 706 
 707     private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt; onResized
 708             = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt;(this, &quot;onResized&quot;);
 709 
 710     public final EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt; getOnResized() { return onResized.get(); }
 711 
 712     public final void setOnResized(EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt; handler) { onResized.set(handler); }
 713 
 714     /**
 715      * JavaScript window resize handler property. This handler is invoked
 716      * when a script running on the Web page moves or resizes the
 717      * {@code window} object.
 718      * @return the onResized property
 719      */
 720     public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt; onResizedProperty() { return onResized; }
 721 
 722 
 723     private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt; onVisibilityChanged
 724             = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt;(this, &quot;onVisibilityChanged&quot;);
 725 
 726     public final EventHandler&lt;WebEvent&lt;Boolean&gt;&gt; getOnVisibilityChanged() { return onVisibilityChanged.get(); }
 727 
 728     public final void setOnVisibilityChanged(EventHandler&lt;WebEvent&lt;Boolean&gt;&gt; handler) { onVisibilityChanged.set(handler); }
 729 
 730     /**
 731      * JavaScript window visibility handler property. This handler is invoked
 732      * when a script running on the Web page changes visibility of the
 733      * {@code window} object.
 734      * @return the onVisibilityChanged property
 735      */
 736     public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt; onVisibilityChangedProperty() { return onVisibilityChanged; }
 737 
 738 
 739     private final ObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt; createPopupHandler
 740             = new SimpleObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt;(this, &quot;createPopupHandler&quot;,
 741             p -&gt; WebEngine.this);
 742 
 743     public final Callback&lt;PopupFeatures, WebEngine&gt; getCreatePopupHandler() { return createPopupHandler.get(); }
 744 
 745     public final void setCreatePopupHandler(Callback&lt;PopupFeatures, WebEngine&gt; handler) { createPopupHandler.set(handler); }
 746 
 747     /**
 748      * JavaScript popup handler property. This handler is invoked when a script
 749      * running on the Web page requests a popup to be created.
 750      * &lt;p&gt;To satisfy this request a handler may create a new {@code WebEngine},
 751      * attach a visibility handler and optionally a resize handler, and return
 752      * the newly created engine. To block the popup, a handler should return
 753      * {@code null}.
 754      * &lt;p&gt;By default, a popup handler is installed that opens popups in this
 755      * {@code WebEngine}.
 756      *
 757      * @return the createPopupHandler property
 758      *
 759      * @see PopupFeatures
 760      */
 761     public final ObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt; createPopupHandlerProperty() { return createPopupHandler; }
 762 
 763 
 764     private final ObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt; confirmHandler
 765             = new SimpleObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt;(this, &quot;confirmHandler&quot;);
 766 
 767     public final Callback&lt;String, Boolean&gt; getConfirmHandler() { return confirmHandler.get(); }
 768 
 769     public final void setConfirmHandler(Callback&lt;String, Boolean&gt; handler) { confirmHandler.set(handler); }
 770 
 771     /**
 772      * JavaScript {@code confirm} handler property. This handler is invoked
 773      * when a script running on the Web page calls the {@code confirm} function.
 774      * &lt;p&gt;An implementation may display a dialog box with Yes and No options,
 775      * and return the user&#39;s choice.
 776      *
 777      * @return the confirmHandler property
 778      */
 779     public final ObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt; confirmHandlerProperty() { return confirmHandler; }
 780 
 781 
 782     private final ObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt; promptHandler
 783             = new SimpleObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt;(this, &quot;promptHandler&quot;);
 784 
 785     public final Callback&lt;PromptData, String&gt; getPromptHandler() { return promptHandler.get(); }
 786 
 787     public final void setPromptHandler(Callback&lt;PromptData, String&gt; handler) { promptHandler.set(handler); }
 788 
 789     /**
 790      * JavaScript {@code prompt} handler property. This handler is invoked
 791      * when a script running on the Web page calls the {@code prompt} function.
 792      * &lt;p&gt;An implementation may display a dialog box with an text field,
 793      * and return the user&#39;s input.
 794      *
 795      * @return the promptHandler property
 796      * @see PromptData
 797      */
 798     public final ObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt; promptHandlerProperty() { return promptHandler; }
 799 
 800     /**
 801      * The event handler called when an error occurs.
 802      *
 803      * @defaultValue {@code null}
 804      * @since JavaFX 8.0
 805      */
 806     private final ObjectProperty&lt;EventHandler&lt;WebErrorEvent&gt;&gt; onError =
 807             new SimpleObjectProperty&lt;&gt;(this, &quot;onError&quot;);
 808 
 809     public final EventHandler&lt;WebErrorEvent&gt; getOnError() {
 810         return onError.get();
 811     }
 812 
 813     public final void setOnError(EventHandler&lt;WebErrorEvent&gt; handler) {
 814         onError.set(handler);
 815     }
 816 
 817     public final ObjectProperty&lt;EventHandler&lt;WebErrorEvent&gt;&gt; onErrorProperty() {
 818         return onError;
 819     }
 820 
 821 
 822     /**
 823      * Creates a new engine.
 824      */
 825     public WebEngine() {
 826         this(null, false);
 827     }
 828 
 829     /**
 830      * Creates a new engine and loads a Web page into it.
 831      *
 832      * @param url the URL of the web page to load
 833      */
 834     public WebEngine(String url) {
 835         this(url, true);
 836     }
 837 
 838     private WebEngine(String url, boolean callLoad) {
 839         checkThread();
 840         Accessor accessor = new AccessorImpl(this);
 841         page = new WebPage(
 842             new WebPageClientImpl(accessor),
 843             new UIClientImpl(accessor),
 844             null,
 845             new InspectorClientImpl(this),
 846             new ThemeClientImpl(accessor),
 847             false);
 848         page.addLoadListenerClient(new PageLoadListener(this));
 849 
 850         history = new WebHistory(page);
 851 
 852         disposer = new SelfDisposer(page);
 853         Disposer.addRecord(this, disposer);
 854 
 855         if (callLoad) {
 856             load(url);
 857         }
 858 
 859         if (instanceCount == 0 &amp;&amp;
 860             Timer.getMode() == Timer.Mode.PLATFORM_TICKS)
 861         {
 862             PulseTimer.start();
 863         }
 864         instanceCount++;
 865     }
 866 
 867     /**
 868      * Loads a Web page into this engine. This method starts asynchronous
 869      * loading and returns immediately.
 870      * @param url URL of the web page to load
 871      */
 872     public void load(String url) {
 873         checkThread();
 874         loadWorker.cancelAndReset();
 875 
 876         if (url == null || url.equals(&quot;&quot;) || url.equals(&quot;about:blank&quot;)) {
 877             url = &quot;&quot;;
 878         } else {
 879             // verify and, if possible, adjust the url on the Java
 880             // side, otherwise it may crash native code
 881             try {
 882                 url = Util.adjustUrlForWebKit(url);
 883             } catch (MalformedURLException e) {
 884                 loadWorker.dispatchLoadEvent(getMainFrame(),
 885                         PAGE_STARTED, url, null, 0.0, 0);
 886                 loadWorker.dispatchLoadEvent(getMainFrame(),
 887                         LOAD_FAILED, url, null, 0.0, MALFORMED_URL);
 888                 return;
 889             }
 890         }
 891         applyUserDataDirectory();
 892         page.open(page.getMainFrame(), url);
 893     }
 894 
 895     /**
 896      * Loads the given HTML content directly. This method is useful when you have an HTML
 897      * String composed in memory, or loaded from some system which cannot be reached via
 898      * a URL (for example, the HTML text may have come from a database). As with
 899      * {@link #load(String)}, this method is asynchronous.
 900      *
 901      * @param content the HTML content to load
 902      */
 903     public void loadContent(String content) {
 904         loadContent(content, &quot;text/html&quot;);
 905     }
 906 
 907     /**
 908      * Loads the given content directly. This method is useful when you have content
 909      * composed in memory, or loaded from some system which cannot be reached via
 910      * a URL (for example, the SVG text may have come from a database). As with
 911      * {@link #load(String)}, this method is asynchronous. This method also allows you to
 912      * specify the content type of the string being loaded, and so may optionally support
 913      * other types besides just HTML.
 914      *
 915      * @param content the HTML content to load
 916      * @param contentType the type of content to load
 917      */
 918     public void loadContent(String content, String contentType) {
 919         checkThread();
 920         loadWorker.cancelAndReset();
 921         applyUserDataDirectory();
 922         page.load(page.getMainFrame(), content, contentType);
 923     }
 924 
 925     /**
 926      * Reloads the current page, whether loaded from URL or directly from a String in
 927      * one of the {@code loadContent} methods.
 928      */
 929     public void reload() {
 930         // TODO what happens if this is called while currently loading a page?
 931         checkThread();
 932         page.refresh(page.getMainFrame());
 933     }
 934 
 935     private final WebHistory history;
 936 
 937     /**
 938      * Returns the session history object.
 939      *
 940      * @return history object
 941      * @since JavaFX 2.2
 942      */
 943     public WebHistory getHistory() {
 944         return history;
 945     }
 946 
 947     /**
 948      * Executes a script in the context of the current page.
 949      *
 950      * @param script the script
 951      * @return execution result, converted to a Java object using the following
 952      * rules:
 953      * &lt;ul&gt;
 954      * &lt;li&gt;JavaScript Int32 is converted to {@code java.lang.Integer}
 955      * &lt;li&gt;Other JavaScript numbers to {@code java.lang.Double}
 956      * &lt;li&gt;JavaScript string to {@code java.lang.String}
 957      * &lt;li&gt;JavaScript boolean to {@code java.lang.Boolean}
 958      * &lt;li&gt;JavaScript {@code null} to {@code null}
 959      * &lt;li&gt;Most JavaScript objects get wrapped as
 960      *     {@code netscape.javascript.JSObject}
 961      * &lt;li&gt;JavaScript JSNode objects get mapped to instances of
 962      *     {@code netscape.javascript.JSObject}, that also implement
 963      *     {@code org.w3c.dom.Node}
 964      * &lt;li&gt;A special case is the JavaScript class {@code JavaRuntimeObject}
 965      *     which is used to wrap a Java object as a JavaScript value - in this
 966      *     case we just extract the original Java value.
 967      * &lt;/ul&gt;
 968      */
 969     public Object executeScript(String script) {
 970         checkThread();
 971         applyUserDataDirectory();
 972         return page.executeScript(page.getMainFrame(), script);
 973     }
 974 
 975     private long getMainFrame() {
 976         return page.getMainFrame();
 977     }
 978 
 979     WebPage getPage() {
 980         return page;
 981     }
 982 
 983     void setView(WebView view) {
 984         this.view.setValue(view);
 985     }
 986 
 987     private void stop() {
 988         checkThread();
 989         page.stop(page.getMainFrame());
 990     }
 991 
 992     private void applyUserDataDirectory() {
 993         if (userDataDirectoryApplied) {
 994             return;
 995         }
 996         userDataDirectoryApplied = true;
 997         File nominalUserDataDir = getUserDataDirectory();
 998         while (true) {
 999             File userDataDir;
1000             String displayString;
1001             if (nominalUserDataDir == null) {
1002                 userDataDir = defaultUserDataDirectory();
1003                 displayString = format(&quot;null (%s)&quot;, userDataDir);
1004             } else {
1005                 userDataDir = nominalUserDataDir;
1006                 displayString = userDataDir.toString();
1007             }
1008             logger.fine(&quot;Trying to apply user data directory [{0}]&quot;, displayString);
1009             String errorMessage;
1010             EventType&lt;WebErrorEvent&gt; errorType;
1011             Throwable error;
1012             try {
1013                 userDataDir = DirectoryLock.canonicalize(userDataDir);
1014                 File localStorageDir = new File(userDataDir, &quot;localstorage&quot;);
1015                 File[] dirs = new File[] {
1016                     userDataDir,
1017                     localStorageDir,
1018                 };
1019                 for (File dir : dirs) {
1020                     createDirectories(dir);
1021                     // Additional security check to make sure the caller
1022                     // has permission to write to the target directory
1023                     File test = new File(dir, &quot;.test&quot;);
1024                     if (test.createNewFile()) {
1025                         test.delete();
1026                     }
1027                 }
1028                 disposer.userDataDirectoryLock = new DirectoryLock(userDataDir);
1029 
1030                 page.setLocalStorageDatabasePath(localStorageDir.getPath());
1031                 page.setLocalStorageEnabled(true);
1032 
1033                 logger.fine(&quot;User data directory [{0}] has &quot;
1034                         + &quot;been applied successfully&quot;, displayString);
1035                 return;
1036 
1037             } catch (DirectoryLock.DirectoryAlreadyInUseException ex) {
1038                 errorMessage = &quot;User data directory [%s] is already in use&quot;;
1039                 errorType = WebErrorEvent.USER_DATA_DIRECTORY_ALREADY_IN_USE;
1040                 error = ex;
1041             } catch (IOException ex) {
1042                 errorMessage = &quot;An I/O error occurred while setting up &quot;
1043                         + &quot;user data directory [%s]&quot;;
1044                 errorType = WebErrorEvent.USER_DATA_DIRECTORY_IO_ERROR;
1045                 error = ex;
1046             } catch (SecurityException ex) {
1047                 errorMessage = &quot;A security error occurred while setting up &quot;
1048                         + &quot;user data directory [%s]&quot;;
1049                 errorType = WebErrorEvent.USER_DATA_DIRECTORY_SECURITY_ERROR;
1050                 error = ex;
1051             }
1052 
1053             errorMessage = format(errorMessage, displayString);
1054             logger.fine(&quot;{0}, calling error handler&quot;, errorMessage);
1055             File oldNominalUserDataDir = nominalUserDataDir;
1056             fireError(errorType, errorMessage, error);
1057             nominalUserDataDir = getUserDataDirectory();
1058             if (Objects.equals(nominalUserDataDir, oldNominalUserDataDir)) {
1059                 logger.fine(&quot;Error handler did not modify user data directory, &quot;
1060                         + &quot;continuing without user data directory&quot;);
1061                 return;
1062             } else {
1063                 logger.fine(&quot;Error handler has set user data directory to [{0}], &quot;
1064                         + &quot;retrying&quot;, nominalUserDataDir);
1065                 continue;
1066             }
1067         }
1068     }
1069 
1070     private static File defaultUserDataDirectory() {
1071         return new File(
1072                 com.sun.glass.ui.Application.GetApplication()
1073                         .getDataDirectory(),
1074                 &quot;webview&quot;);
1075     }
1076 
1077     private static void createDirectories(File directory) throws IOException {
1078         Path path = directory.toPath();
1079         try {
1080             Files.createDirectories(path, PosixFilePermissions.asFileAttribute(
1081                     PosixFilePermissions.fromString(&quot;rwx------&quot;)));
1082         } catch (UnsupportedOperationException ex) {
1083             Files.createDirectories(path);
1084         }
1085     }
1086 
1087     private void fireError(EventType&lt;WebErrorEvent&gt; eventType, String message,
1088                            Throwable exception)
1089     {
1090         EventHandler&lt;WebErrorEvent&gt; handler = getOnError();
1091         if (handler != null) {
1092             handler.handle(new WebErrorEvent(this, eventType,
1093                                              message, exception));
1094         }
1095     }
1096 
1097     // for testing purposes only
1098     void dispose() {
1099         disposer.dispose();
1100     }
1101 
1102     private static final class SelfDisposer implements DisposerRecord {
1103         private WebPage page;
1104         private DirectoryLock userDataDirectoryLock;
1105 
1106         private SelfDisposer(WebPage page) {
1107             this.page = page;
1108         }
1109 
1110         @Override public void dispose() {
1111             if (page == null) {
1112                 return;
1113             }
1114             page.dispose();
1115             page = null;
1116             if (userDataDirectoryLock != null) {
1117                 userDataDirectoryLock.close();
1118             }
1119             instanceCount--;
1120             if (instanceCount == 0 &amp;&amp;
1121                 Timer.getMode() == Timer.Mode.PLATFORM_TICKS)
1122             {
1123                 PulseTimer.stop();
1124             }
1125         }
1126     }
1127 
1128     private static final class AccessorImpl extends Accessor {
1129         private final WeakReference&lt;WebEngine&gt; engine;
1130 
1131         private AccessorImpl(WebEngine w) {
1132             this.engine = new WeakReference&lt;WebEngine&gt;(w);
1133         }
1134 
1135         @Override public WebEngine getEngine() {
1136             return engine.get();
1137         }
1138 
1139         @Override public WebPage getPage() {
1140             WebEngine w = getEngine();
1141             return w == null ? null : w.page;
1142         }
1143 
1144         @Override public WebView getView() {
1145             WebEngine w = getEngine();
1146             return w == null ? null : w.view.get();
1147         }
1148 
1149         @Override public void addChild(Node child) {
1150             WebView view = getView();
1151             if (view != null) {
1152                 view.getChildren().add(child);
1153             }
1154         }
1155 
1156         @Override public void removeChild(Node child) {
1157             WebView view = getView();
1158             if (view != null) {
1159                 view.getChildren().remove(child);
1160             }
1161         }
1162 
1163         @Override public void addViewListener(InvalidationListener l) {
1164             WebEngine w = getEngine();
1165             if (w != null) {
1166                 w.view.addListener(l);
1167             }
1168         }
1169     }
1170 
1171     /**
1172      * Drives the {@code Timer} when {@code Timer.Mode.PLATFORM_TICKS} is set.
1173      */
1174     private static final class PulseTimer {
1175 
1176         // Used just to guarantee constant pulse activity. See RT-14433.
1177         private static final AnimationTimer animation =
1178             new AnimationTimer() {
1179                 @Override public void handle(long l) {}
1180             };
1181 
1182         private static final TKPulseListener listener =
1183                 () -&gt; {
1184                     // Note, the timer event is executed right in the notifyTick(),
1185                     // that is during the pulse event. This makes the timer more
1186                     // repsonsive, though prolongs the pulse. So far it causes no
1187                     // problems but nevertheless it should be kept in mind.
1188 
1189                     // Execute notifyTick in runLater to run outside of pulse so
1190                     // that events will run in order and be able to display dialogs
1191                     // or call other methods that require a nested event loop.
1192                     Platform.runLater(() -&gt; Timer.getTimer().notifyTick());
1193                 };
1194 
1195         private static void start(){
1196             Toolkit.getToolkit().addSceneTkPulseListener(listener);
1197             animation.start();
1198         }
1199 
1200         private static void stop() {
1201             Toolkit.getToolkit().removeSceneTkPulseListener(listener);
1202             animation.stop();
1203         }
1204     }
1205 
1206     static void checkThread() {
1207         Toolkit.getToolkit().checkFxUserThread();
1208     }
1209 
1210 
1211     /**
1212      * The page load event listener. This object references the owner
1213      * WebEngine weakly so as to avoid referencing WebEngine from WebPage
1214      * strongly.
1215      */
1216     private static final class PageLoadListener implements LoadListenerClient {
1217 
1218         private final WeakReference&lt;WebEngine&gt; engine;
1219 
1220 
1221         private PageLoadListener(WebEngine engine) {
1222             this.engine = new WeakReference&lt;WebEngine&gt;(engine);
1223         }
1224 
1225 
1226         @Override public void dispatchLoadEvent(long frame, int state,
1227                 String url, String contentType, double progress, int errorCode)
1228         {
1229             WebEngine w = engine.get();
1230             if (w != null) {
1231                 w.loadWorker.dispatchLoadEvent(frame, state, url,
1232                         contentType, progress, errorCode);
1233             }
1234         }
1235 
1236         @Override public void dispatchResourceLoadEvent(long frame,
1237                 int state, String url, String contentType, double progress,
1238                 int errorCode)
1239         {
1240         }
1241     }
1242 
1243 
1244     private final class LoadWorker implements Worker&lt;Void&gt; {
1245 
1246         private final ReadOnlyObjectWrapper&lt;State&gt; state = new ReadOnlyObjectWrapper&lt;State&gt;(this, &quot;state&quot;, State.READY);
1247         @Override public final State getState() { checkThread(); return state.get(); }
1248         @Override public final ReadOnlyObjectProperty&lt;State&gt; stateProperty() { checkThread(); return state.getReadOnlyProperty(); }
1249         private void updateState(State value) {
1250             checkThread();
1251             this.state.set(value);
1252             running.set(value == State.SCHEDULED || value == State.RUNNING);
1253         }
1254 
1255         /**
1256          * @InheritDoc
1257          */
1258         private final ReadOnlyObjectWrapper&lt;Void&gt; value = new ReadOnlyObjectWrapper&lt;Void&gt;(this, &quot;value&quot;, null);
1259         @Override public final Void getValue() { checkThread(); return value.get(); }
1260         @Override public final ReadOnlyObjectProperty&lt;Void&gt; valueProperty() { checkThread(); return value.getReadOnlyProperty(); }
1261 
1262         /**
1263          * @InheritDoc
1264          */
1265         private final ReadOnlyObjectWrapper&lt;Throwable&gt; exception = new ReadOnlyObjectWrapper&lt;Throwable&gt;(this, &quot;exception&quot;);
1266         @Override public final Throwable getException() { checkThread(); return exception.get(); }
1267         @Override public final ReadOnlyObjectProperty&lt;Throwable&gt; exceptionProperty() { checkThread(); return exception.getReadOnlyProperty(); }
1268 
1269         /**
1270          * @InheritDoc
1271          */
1272         private final ReadOnlyDoubleWrapper workDone = new ReadOnlyDoubleWrapper(this, &quot;workDone&quot;, -1);
1273         @Override public final double getWorkDone() { checkThread(); return workDone.get(); }
1274         @Override public final ReadOnlyDoubleProperty workDoneProperty() { checkThread(); return workDone.getReadOnlyProperty(); }
1275 
1276         /**
1277          * @InheritDoc
1278          */
1279         private final ReadOnlyDoubleWrapper totalWorkToBeDone = new ReadOnlyDoubleWrapper(this, &quot;totalWork&quot;, -1);
1280         @Override public final double getTotalWork() { checkThread(); return totalWorkToBeDone.get(); }
1281         @Override public final ReadOnlyDoubleProperty totalWorkProperty() { checkThread(); return totalWorkToBeDone.getReadOnlyProperty(); }
1282 
1283         /**
1284          * @InheritDoc
1285          */
1286         private final ReadOnlyDoubleWrapper progress = new ReadOnlyDoubleWrapper(this, &quot;progress&quot;, -1);
1287         @Override public final double getProgress() { checkThread(); return progress.get(); }
1288         @Override public final ReadOnlyDoubleProperty progressProperty() { checkThread(); return progress.getReadOnlyProperty(); }
1289         private void updateProgress(double p) {
1290             totalWorkToBeDone.set(100.0);
1291             workDone.set(p * 100.0);
1292             progress.set(p);
1293         }
1294 
1295         /**
1296          * @InheritDoc
1297          */
1298         private final ReadOnlyBooleanWrapper running = new ReadOnlyBooleanWrapper(this, &quot;running&quot;, false);
1299         @Override public final boolean isRunning() { checkThread(); return running.get(); }
1300         @Override public final ReadOnlyBooleanProperty runningProperty() { checkThread(); return running.getReadOnlyProperty(); }
1301 
1302         /**
1303          * @InheritDoc
1304          */
1305         private final ReadOnlyStringWrapper message = new ReadOnlyStringWrapper(this, &quot;message&quot;, &quot;&quot;);
1306         @Override public final String getMessage() { return message.get(); }
1307         @Override public final ReadOnlyStringProperty messageProperty() { return message.getReadOnlyProperty(); }
1308 
1309         /**
1310          * @InheritDoc
1311          */
1312         private final ReadOnlyStringWrapper title = new ReadOnlyStringWrapper(this, &quot;title&quot;, &quot;WebEngine Loader&quot;);
1313         @Override public final String getTitle() { return title.get(); }
1314         @Override public final ReadOnlyStringProperty titleProperty() { return title.getReadOnlyProperty(); }
1315 
1316         /**
1317          * Cancels the loading of the page. If called after the page has already
1318          * been loaded, then this call takes no effect.
1319          */
1320         @Override public boolean cancel() {
1321             if (isRunning()) {
1322                 stop(); // this call indirectly sets state
1323                 return true;
1324             } else {
1325                 return false;
1326             }
1327         }
1328 
1329         private void cancelAndReset() {
1330             cancel();
1331             exception.set(null);
1332             message.set(&quot;&quot;);
1333             totalWorkToBeDone.set(-1);
1334             workDone.set(-1);
1335             progress.set(-1);
1336             updateState(State.READY);
1337             running.set(false);
1338         }
1339 
1340         private void dispatchLoadEvent(long frame, int state,
1341                 String url, String contentType, double workDone, int errorCode)
1342         {
1343             if (frame != getMainFrame()) {
1344                 return;
1345             }
1346             switch (state) {
1347                 case PAGE_STARTED:
1348                     message.set(&quot;Loading &quot; + url);
1349                     updateLocation(url);
1350                     updateProgress(0.0);
1351                     updateState(State.SCHEDULED);
1352                     updateState(State.RUNNING);
1353                     break;
1354                 case PAGE_REDIRECTED:
1355                     message.set(&quot;Loading &quot; + url);
1356                     updateLocation(url);
1357                     break;
1358                 case PAGE_REPLACED:
1359                     message.set(&quot;Replaced &quot; + url);
1360                     // Update only the location, don&#39;t change title or document.
1361                     WebEngine.this.location.set(url);
1362                     break;
1363                 case PAGE_FINISHED:
1364                     message.set(&quot;Loading complete&quot;);
1365                     updateProgress(1.0);
1366                     updateState(State.SUCCEEDED);
1367                     break;
1368                 case LOAD_FAILED:
1369                     message.set(&quot;Loading failed&quot;);
1370                     exception.set(describeError(errorCode));
1371                     updateState(State.FAILED);
1372                     break;
1373                 case LOAD_STOPPED:
1374                     message.set(&quot;Loading stopped&quot;);
1375                     updateState(State.CANCELLED);
1376                     break;
1377                 case PROGRESS_CHANGED:
1378                     updateProgress(workDone);
1379                     break;
1380                 case TITLE_RECEIVED:
1381                     updateTitle();
1382                     break;
1383                 case DOCUMENT_AVAILABLE:
1384                     if (this.state.get() != State.RUNNING) {
1385                         // We have empty load; send a synthetic event (RT-32097)
1386                         dispatchLoadEvent(frame, PAGE_STARTED, url, contentType, workDone, errorCode);
1387                     }
1388                     document.invalidate(true);
1389                     break;
1390             }
1391         }
1392 
1393         private Throwable describeError(int errorCode) {
1394             String reason = &quot;Unknown error&quot;;
1395 
1396             switch (errorCode) {
1397                 case UNKNOWN_HOST:
1398                     reason = &quot;Unknown host&quot;;
1399                     break;
1400                 case MALFORMED_URL:
1401                     reason = &quot;Malformed URL&quot;;
1402                     break;
1403                 case SSL_HANDSHAKE:
1404                     reason = &quot;SSL handshake failed&quot;;
1405                     break;
1406                 case CONNECTION_REFUSED:
1407                     reason = &quot;Connection refused by server&quot;;
1408                     break;
1409                 case CONNECTION_RESET:
1410                     reason = &quot;Connection reset by server&quot;;
1411                     break;
1412                 case NO_ROUTE_TO_HOST:
1413                     reason = &quot;No route to host&quot;;
1414                     break;
1415                 case CONNECTION_TIMED_OUT:
1416                     reason = &quot;Connection timed out&quot;;
1417                     break;
1418                 case PERMISSION_DENIED:
1419                     reason = &quot;Permission denied&quot;;
1420                     break;
1421                 case INVALID_RESPONSE:
1422                     reason = &quot;Invalid response from server&quot;;
1423                     break;
1424                 case TOO_MANY_REDIRECTS:
1425                     reason = &quot;Too many redirects&quot;;
1426                     break;
1427                 case FILE_NOT_FOUND:
1428                     reason = &quot;File not found&quot;;
1429                     break;
1430             }
1431             return new Throwable(reason);
1432         }
1433     }
1434 
1435 
1436     private final class DocumentProperty
1437             extends ReadOnlyObjectPropertyBase&lt;Document&gt; {
1438 
1439         private boolean available;
1440         private Document document;
1441 
1442         private void invalidate(boolean available) {
1443             if (this.available || available) {
1444                 this.available = available;
1445                 this.document = null;
1446                 fireValueChangedEvent();
1447             }
1448         }
1449 
1450         public Document get() {
1451             if (!this.available) {
1452                 return null;
1453             }
1454             if (this.document == null) {
1455                 this.document = page.getDocument(page.getMainFrame());
1456                 if (this.document == null) {
1457                     this.available = false;
1458                 }
1459             }
1460             return this.document;
1461         }
1462 
1463         public Object getBean() {
1464             return WebEngine.this;
1465         }
1466 
1467         public String getName() {
1468             return &quot;document&quot;;
1469         }
1470     }
1471 
1472 
1473     /*
1474      * Returns the debugger associated with this web engine.
1475      * The debugger is an object that can be used to debug
1476      * the web page currently loaded into the web engine.
1477      * &lt;p&gt;
1478      * All methods of the debugger must be called on
1479      * the JavaFX Application Thread.
1480      * The message callback object registered with the debugger
1481      * is always called on the JavaFX Application Thread.
1482      * @return the debugger associated with this web engine.
1483      *         The return value cannot be {@code null}.
1484      */
1485     Debugger getDebugger() {
1486         return debugger;
1487     }
1488 
1489     /**
1490      * The debugger implementation.
1491      */
1492     private final class DebuggerImpl implements Debugger {
1493 
1494         private boolean enabled;
1495         private Callback&lt;String,Void&gt; messageCallback;
1496 
1497 
1498         @Override
1499         public boolean isEnabled() {
1500             checkThread();
1501             return enabled;
1502         }
1503 
1504         @Override
1505         public void setEnabled(boolean enabled) {
1506             checkThread();
1507             if (enabled != this.enabled) {
1508                 if (enabled) {
1509                     page.setDeveloperExtrasEnabled(true);
1510                     page.connectInspectorFrontend();
1511                 } else {
1512                     page.disconnectInspectorFrontend();
1513                     page.setDeveloperExtrasEnabled(false);
1514                 }
1515                 this.enabled = enabled;
1516             }
1517         }
1518 
1519         @Override
1520         public void sendMessage(String message) {
1521             checkThread();
1522             if (!enabled) {
1523                 throw new IllegalStateException(&quot;Debugger is not enabled&quot;);
1524             }
1525             if (message == null) {
1526                 throw new NullPointerException(&quot;message is null&quot;);
1527             }
1528             page.dispatchInspectorMessageFromFrontend(message);
1529         }
1530 
1531         @Override
1532         public Callback&lt;String,Void&gt; getMessageCallback() {
1533             checkThread();
1534             return messageCallback;
1535         }
1536 
1537         @Override
1538         public void setMessageCallback(Callback&lt;String,Void&gt; callback) {
1539             checkThread();
1540             messageCallback = callback;
1541         }
1542     }
1543 
1544     /**
1545      * The inspector client implementation. This object references the owner
1546      * WebEngine weakly so as to avoid referencing WebEngine from WebPage
1547      * strongly.
1548      */
1549     private static final class InspectorClientImpl implements InspectorClient {
1550 
1551         private final WeakReference&lt;WebEngine&gt; engine;
1552 
1553 
1554         private InspectorClientImpl(WebEngine engine) {
1555             this.engine = new WeakReference&lt;WebEngine&gt;(engine);
1556         }
1557 
1558 
1559         @Override
1560         public boolean sendMessageToFrontend(final String message) {
1561             boolean result = false;
1562             WebEngine webEngine = engine.get();
1563             if (webEngine != null) {
1564                 final Callback&lt;String,Void&gt; messageCallback =
1565                         webEngine.debugger.messageCallback;
1566                 if (messageCallback != null) {
1567                     AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
1568                         messageCallback.call(message);
1569                         return null;
1570                     }, webEngine.page.getAccessControlContext());
1571                     result = true;
1572                 }
1573             }
1574             return result;
1575         }
1576     }
1577 
1578     private static final boolean printStatusOK(PrinterJob job) {
1579         switch (job.getJobStatus()) {
1580             case NOT_STARTED:
1581             case PRINTING:
1582                 return true;
1583             default:
1584                 return false;
1585         }
1586     }
1587 
1588     /**
1589      * Prints the current Web page using the given printer job.
1590      * &lt;p&gt;This method does not modify the state of the job, nor does it call
1591      * {@link PrinterJob#endJob}, so the job may be safely reused afterwards.
1592      *
1593      * @param job printer job used for printing
1594      * @since JavaFX 8.0
1595      */
1596     public void print(PrinterJob job) {
1597         if (!printStatusOK(job)) {
1598             return;
1599         }
1600 
1601         PageLayout pl = job.getJobSettings().getPageLayout();
1602         float width = (float) pl.getPrintableWidth();
1603         float height = (float) pl.getPrintableHeight();
1604         int pageCount = page.beginPrinting(width, height);
1605 
1606         for (int i = 0; i &lt; pageCount; i++) {
1607             if (printStatusOK(job)) {
1608                 Node printable = new Printable(page, i, width);
1609                 job.printPage(printable);
1610             }
1611         }
1612         page.endPrinting();
1613     }
1614 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>