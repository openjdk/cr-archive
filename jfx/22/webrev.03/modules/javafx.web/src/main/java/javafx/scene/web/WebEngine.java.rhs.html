<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/java/javafx/scene/web/WebEngine.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.web;
  27 
  28 import com.sun.javafx.logging.PlatformLogger;
  29 import com.sun.javafx.scene.web.Debugger;
  30 import com.sun.javafx.scene.web.Printable;
  31 import com.sun.javafx.tk.TKPulseListener;
  32 import com.sun.javafx.tk.Toolkit;
  33 import com.sun.javafx.webkit.*;
  34 import com.sun.javafx.webkit.prism.PrismGraphicsManager;
  35 import com.sun.javafx.webkit.prism.PrismInvoker;
  36 import com.sun.javafx.webkit.prism.theme.PrismRenderer;
  37 import com.sun.javafx.webkit.theme.RenderThemeImpl;
  38 import com.sun.javafx.webkit.theme.Renderer;
  39 import com.sun.webkit.*;
  40 import com.sun.webkit.graphics.WCGraphicsManager;
  41 import com.sun.webkit.network.URLs;
  42 import com.sun.webkit.network.Util;
  43 import javafx.animation.AnimationTimer;
  44 import javafx.application.Platform;
  45 import javafx.beans.InvalidationListener;
  46 import javafx.beans.property.*;
  47 import javafx.concurrent.Worker;
  48 import javafx.event.EventHandler;
  49 import javafx.event.EventType;
  50 import javafx.geometry.Rectangle2D;
  51 import javafx.print.PageLayout;
  52 import javafx.print.PrinterJob;
  53 import javafx.scene.Node;
  54 import javafx.util.Callback;
  55 import org.w3c.dom.Document;
  56 
  57 import java.io.BufferedInputStream;
  58 import java.io.File;
  59 import java.io.IOException;
  60 import static java.lang.String.format;
  61 import java.lang.ref.WeakReference;
  62 import java.net.MalformedURLException;
  63 import java.net.URLConnection;
  64 import java.nio.file.Files;
  65 import java.nio.file.Path;
  66 import java.nio.file.attribute.PosixFilePermissions;
  67 import java.security.AccessController;
  68 import java.security.PrivilegedAction;
  69 import java.util.ArrayList;
  70 import java.util.Base64;
  71 import java.util.List;
  72 import java.util.Objects;
  73 
  74 import static com.sun.webkit.LoadListenerClient.*;
  75 
  76 /**
  77  * {@code WebEngine} is a non-visual object capable of managing one Web page
  78  * at a time. It loads Web pages, creates their document models, applies
  79  * styles as necessary, and runs JavaScript on pages. It provides access
  80  * to the document model of the current page, and enables two-way
  81  * communication between a Java application and JavaScript code of the page.
  82  *
  83  * &lt;p&gt;&lt;b&gt;Loading Web Pages&lt;/b&gt;&lt;/p&gt;
  84  * &lt;p&gt;The {@code WebEngine} class provides two ways to load content into a
  85  * {@code WebEngine} object:
  86  * &lt;ul&gt;
  87  * &lt;li&gt;From an arbitrary URL using the {@link #load} method. This method uses
  88  *     the {@code java.net} package for network access and protocol handling.
  89  * &lt;li&gt;From an in-memory String using the
  90  *     {@link #loadContent(java.lang.String, java.lang.String)} and
  91  *     {@link #loadContent(java.lang.String)} methods.
  92  * &lt;/ul&gt;
  93  * &lt;p&gt;Loading always happens on a background thread. Methods that initiate
  94  * loading return immediately after scheduling a background job. To track
  95  * progress and/or cancel a job, use the {@link javafx.concurrent.Worker}
  96  * instance available from the {@link #getLoadWorker} method.
  97  *
  98  * &lt;p&gt;The following example changes the stage title when loading completes
  99  * successfully:
 100  * &lt;pre&gt;{@code
 101     import javafx.concurrent.Worker.State;
 102     final Stage stage;
 103     webEngine.getLoadWorker().stateProperty().addListener(
 104         new ChangeListener&lt;State&gt;() {
 105             public void changed(ObservableValue ov, State oldState, State newState) {
 106                 if (newState == State.SUCCEEDED) {
 107                     stage.setTitle(webEngine.getLocation());
 108                 }
 109             }
 110         });
 111     webEngine.load(&quot;http://javafx.com&quot;);
 112  * }&lt;/pre&gt;
 113  *
 114  * &lt;p&gt;&lt;b&gt;User Interface Callbacks&lt;/b&gt;&lt;/p&gt;
 115  * &lt;p&gt;A number of user interface callbacks may be registered with a
 116  * {@code WebEngine} object. These callbacks are invoked when a script running
 117  * on the page requests a user interface operation to be performed, for
 118  * example, opens a popup window or changes status text. A {@code WebEngine}
 119  * object cannot handle such requests internally, so it passes the request to
 120  * the corresponding callbacks. If no callback is defined for a specific
 121  * operation, the request is silently ignored.
 122  *
 123  * &lt;p&gt;The table below shows JavaScript user interface methods and properties
 124  * with their corresponding {@code WebEngine} callbacks:
 125  * &lt;table border=&quot;1&quot;&gt;
 126  * &lt;caption&gt;JavaScript Callback Table&lt;/caption&gt;
 127  * &lt;tr&gt;
 128  *     &lt;th scope=&quot;col&quot;&gt;JavaScript method/property&lt;/th&gt;
 129  *     &lt;th scope=&quot;col&quot;&gt;WebEngine callback&lt;/th&gt;
 130  * &lt;/tr&gt;
 131  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.alert()}&lt;/th&gt;&lt;td&gt;{@code onAlert}&lt;/td&gt;&lt;/tr&gt;
 132  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.confirm()}&lt;/th&gt;&lt;td&gt;{@code confirmHandler}&lt;/td&gt;&lt;/tr&gt;
 133  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.open()}&lt;/th&gt;&lt;td&gt;{@code createPopupHandler}&lt;/td&gt;&lt;/tr&gt;
 134  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.open()} and&lt;br&gt;
 135  *         {@code window.close()}&lt;/th&gt;&lt;td&gt;{@code onVisibilityChanged}&lt;/td&gt;&lt;/tr&gt;
 136  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.prompt()}&lt;/th&gt;&lt;td&gt;{@code promptHandler}&lt;/td&gt;&lt;/tr&gt;
 137  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Setting {@code window.status}&lt;/th&gt;&lt;td&gt;{@code onStatusChanged}&lt;/td&gt;&lt;/tr&gt;
 138  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Setting any of the following:&lt;br&gt;
 139  *         {@code window.innerWidth}, {@code window.innerHeight},&lt;br&gt;
 140  *         {@code window.outerWidth}, {@code window.outerHeight},&lt;br&gt;
 141  *         {@code window.screenX}, {@code window.screenY},&lt;br&gt;
 142  *         {@code window.screenLeft}, {@code window.screenTop}&lt;/th&gt;
 143  *         &lt;td&gt;{@code onResized}&lt;/td&gt;&lt;/tr&gt;
 144  * &lt;/table&gt;
 145  *
 146  * &lt;p&gt;The following example shows a callback that resizes a browser window:
 147  * &lt;pre&gt;{@code
 148     Stage stage;
 149     webEngine.setOnResized(
 150         new EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;() {
 151             public void handle(WebEvent&lt;Rectangle2D&gt; ev) {
 152                 Rectangle2D r = ev.getData();
 153                 stage.setWidth(r.getWidth());
 154                 stage.setHeight(r.getHeight());
 155             }
 156         });
 157  * }&lt;/pre&gt;
 158  *
 159  * &lt;p&gt;&lt;b&gt;Access to Document Model&lt;/b&gt;&lt;/p&gt;
 160  * &lt;p&gt;The {@code WebEngine} objects create and manage a Document Object Model
 161  * (DOM) for their Web pages. The model can be accessed and modified using
 162  * Java DOM Core classes. The {@link #getDocument()} method provides access
 163  * to the root of the model. Additionally DOM Event specification is supported
 164  * to define event handlers in Java code.
 165  *
 166  * &lt;p&gt;The following example attaches a Java event listener to an element of
 167  * a Web page. Clicking on the element causes the application to exit:
 168  * &lt;pre&gt;{@code
 169     EventListener listener = new EventListener() {
 170         public void handleEvent(Event ev) {
 171             Platform.exit();
 172         }
 173     };
 174 
 175     Document doc = webEngine.getDocument();
 176     Element el = doc.getElementById(&quot;exit-app&quot;);
 177     ((EventTarget) el).addEventListener(&quot;click&quot;, listener, false);
 178  * }&lt;/pre&gt;
 179  *
 180  * &lt;p&gt;&lt;b&gt;Evaluating JavaScript expressions&lt;/b&gt;&lt;/p&gt;
 181  * &lt;p&gt;It is possible to execute arbitrary JavaScript code in the context of
 182  * the current page using the {@link #executeScript} method. For example:
 183  * &lt;pre&gt;{@code
 184     webEngine.executeScript(&quot;history.back()&quot;);
 185  * }&lt;/pre&gt;
 186  *
 187  * &lt;p&gt;The execution result is returned to the caller,
 188  * as described in the next section.
 189  *
 190  * &lt;p&gt;&lt;b&gt;Mapping JavaScript values to Java objects&lt;/b&gt;&lt;/p&gt;
 191  *
 192  * JavaScript values are represented using the obvious Java classes:
 193  * null becomes Java null; a boolean becomes a {@code java.lang.Boolean};
 194  * and a string becomes a {@code java.lang.String}.
 195  * A number can be {@code java.lang.Double} or a {@code java.lang.Integer},
 196  * depending.
 197  * The undefined value maps to a specific unique String
 198  * object whose value is {@code &quot;undefined&quot;}.
 199  * &lt;p&gt;
 200  * If the result is a
 201  * JavaScript object, it is wrapped as an instance of the
 202  * {@link netscape.javascript.JSObject} class.
 203  * (As a special case, if the JavaScript object is
 204  * a {@code JavaRuntimeObject} as discussed in the next section,
 205  * then the original Java object is extracted instead.)
 206  * The {@code JSObject} class is a proxy that provides access to
 207  * methods and properties of its underlying JavaScript object.
 208  * The most commonly used {@code JSObject} methods are
 209  * {@link netscape.javascript.JSObject#getMember getMember}
 210  * (to read a named property),
 211  * {@link netscape.javascript.JSObject#setMember setMember}
 212  * (to set or define a property),
 213  * and {@link netscape.javascript.JSObject#call call}
 214  * (to call a function-valued property).
 215  * &lt;p&gt;
 216  * A DOM {@code Node} is mapped to an object that both extends
 217  * {@code JSObject} and implements the appropriate DOM interfaces.
 218  * To get a {@code JSObject} object for a {@code Node} just do a cast:
 219  * &lt;pre&gt;
 220  * JSObject jdoc = (JSObject) webEngine.getDocument();
 221  * &lt;/pre&gt;
 222  * &lt;p&gt;
 223  * In some cases the context provides a specific Java type that guides
 224  * the conversion.
 225  * For example if setting a Java {@code String} field from a JavaScript
 226  * expression, then the JavaScript value is converted to a string.
 227  *
 228  * &lt;p&gt;&lt;b&gt;Mapping Java objects to JavaScript values&lt;/b&gt;&lt;/p&gt;
 229  *
 230  * The arguments of the {@code JSObject} methods {@code setMember} and
 231  * {@code call} pass Java objects to the JavaScript environment.
 232  * This is roughly the inverse of the JavaScript-to-Java mapping
 233  * described above:
 234  * Java {@code String},  {@code Number}, or {@code Boolean} objects
 235  * are converted to the obvious JavaScript values. A  {@code JSObject}
 236  * object is converted to the original wrapped JavaScript object.
 237  * Otherwise a {@code JavaRuntimeObject} is created.  This is
 238  * a JavaScript object that acts as a proxy for the Java object,
 239  * in that accessing properties of the {@code JavaRuntimeObject}
 240  * causes the Java field or method with the same name to be accessed.
 241  * &lt;p&gt; Note that the Java objects bound using
 242  * {@link netscape.javascript.JSObject#setMember JSObject.setMember},
 243  * {@link netscape.javascript.JSObject#setSlot JSObject.setSlot}, and
 244  * {@link netscape.javascript.JSObject#call JSObject.call}
 245  * are implemented using weak references. This means that the Java object
 246  * can be garbage collected, causing subsequent accesses to the JavaScript
 247  * objects to have no effect.
 248  *
 249  * &lt;p&gt;&lt;b&gt;Calling back to Java from JavaScript&lt;/b&gt;&lt;/p&gt;
 250  *
 251  * &lt;p&gt;The {@link netscape.javascript.JSObject#setMember JSObject.setMember}
 252  * method is useful to enable upcalls from JavaScript
 253  * into Java code, as illustrated by the following example. The Java code
 254  * establishes a new JavaScript object named {@code app}. This object has one
 255  * public member, the method {@code exit}.
 256  * &lt;pre&gt;&lt;code&gt;
 257 public class JavaApplication {
 258     public void exit() {
 259         Platform.exit();
 260     }
 261 }
 262 ...
 263 JavaApplication javaApp = new JavaApplication();
 264 JSObject window = (JSObject) webEngine.executeScript(&quot;window&quot;);
 265 window.setMember(&quot;app&quot;, javaApp);
 266  * &lt;/code&gt;&lt;/pre&gt;
 267  * You can then refer to the object and the method from your HTML page:
 268  * &lt;pre&gt;{@code
 269     &lt;a href=&quot;&quot; onclick=&quot;app.exit()&quot;&gt;Click here to exit application&lt;/a&gt;
 270  * }&lt;/pre&gt;
 271  * &lt;p&gt;When a user clicks the link the application is closed.
 272  * &lt;p&gt;
 273  * Note that in the above example, the application holds a reference
 274  * to the {@code JavaApplication} instance. This is required for the callback
 275  * from JavaScript to execute the desired method.
 276  * &lt;p&gt; In the following example, the application does not hold a reference
 277  * to the Java object:
 278  * &lt;pre&gt;&lt;code&gt;
 279  * JSObject window = (JSObject) webEngine.executeScript(&quot;window&quot;);
 280  * window.setMember(&quot;app&quot;, new JavaApplication());
 281  * &lt;/code&gt;&lt;/pre&gt;
 282  * &lt;p&gt; In this case, since the property value is a local object, {@code &quot;new JavaApplication()&quot;},
 283  * the value may be garbage collected in next GC cycle.
 284  * &lt;p&gt;
 285  * When a user clicks the link, it does not guarantee to execute the callback method {@code exit}.
 286  * &lt;p&gt;
 287  * If there are multiple Java methods with the given name,
 288  * then the engine selects one matching the number of parameters
 289  * in the call.  (Varargs are not handled.) An unspecified one is
 290  * chosen if there are multiple ones with the correct number of parameters.
 291  * &lt;p&gt;
 292  * You can pick a specific overloaded method by listing the
 293  * parameter types in an &quot;extended method name&quot;, which has the
 294  * form &lt;code&gt;&quot;&lt;var&gt;method_name&lt;/var&gt;(&lt;var&gt;param_type1&lt;/var&gt;,...,&lt;var&gt;param_typen&lt;/var&gt;)&quot;&lt;/code&gt;.  Typically you&#39;d write the JavaScript expression:
 295  * &lt;pre&gt;
 296  * &lt;code&gt;&lt;var&gt;receiver&lt;/var&gt;[&quot;&lt;var&gt;method_name&lt;/var&gt;(&lt;var&gt;param_type1&lt;/var&gt;,...,&lt;var&gt;param_typeN&lt;/var&gt;)&quot;](&lt;var&gt;arg1&lt;/var&gt;,...,&lt;var&gt;argN&lt;/var&gt;)&lt;/code&gt;
 297  * &lt;/pre&gt;
 298  *
 299  * &lt;p&gt;
 300  * The Java class and method must both be declared public.
 301  * &lt;/p&gt;
 302  *
 303  * &lt;p&gt;&lt;b&gt;Deploying an Application as a Module&lt;/b&gt;&lt;/p&gt;
 304  * &lt;p&gt;
 305  * If any Java class passed to JavaScript is in a named module, then it must
 306  * be reflectively accessible to the {@code javafx.web} module.
 307  * A class is reflectively accessible if the module
 308  * {@link Module#isOpen(String,Module) opens} the containing package to at
 309  * least the {@code javafx.web} module.
 310  * Otherwise, the method will not be called, and no error or
 311  * warning will be produced.
 312  * &lt;/p&gt;
 313  * &lt;p&gt;
 314  * For example, if {@code com.foo.MyClass} is in the {@code foo.app} module,
 315  * the {@code module-info.java} might
 316  * look like this:
 317  * &lt;/p&gt;
 318  *
 319 &lt;pre&gt;{@code module foo.app {
 320     opens com.foo to javafx.web;
 321 }}&lt;/pre&gt;
 322  *
 323  * &lt;p&gt;
 324  * Alternatively, a class is reflectively accessible if the module
 325  * {@link Module#isExported(String) exports} the containing package
 326  * unconditionally.
 327  * &lt;/p&gt;
 328  *
 329  * &lt;p&gt;&lt;b&gt;Threading&lt;/b&gt;&lt;/p&gt;
 330  * &lt;p&gt;{@code WebEngine} objects must be created and accessed solely from the
 331  * JavaFX Application thread. This rule also applies to any DOM and JavaScript
 332  * objects obtained from the {@code WebEngine} object.
 333  * @since JavaFX 2.0
 334  */
 335 final public class WebEngine {
 336     static {
 337         Accessor.setPageAccessor(w -&gt; w == null ? null : w.getPage());
 338 
 339         Invoker.setInvoker(new PrismInvoker());
 340         Renderer.setRenderer(new PrismRenderer());
 341         WCGraphicsManager.setGraphicsManager(new PrismGraphicsManager());
 342         CursorManager.setCursorManager(new CursorManagerImpl());
 343         com.sun.webkit.EventLoop.setEventLoop(new EventLoopImpl());
 344         ThemeClient.setDefaultRenderTheme(new RenderThemeImpl());
 345         Utilities.setUtilities(new UtilitiesImpl());
 346     }
 347 
 348     private static final PlatformLogger logger =
 349             PlatformLogger.getLogger(WebEngine.class.getName());
 350 
 351     /**
 352      * The number of instances of this class.
 353      * Used to start and stop the pulse timer.
 354      */
 355     private static int instanceCount = 0;
 356 
 357     /**
 358      * The node associated with this engine. There is a one-to-one correspondence
 359      * between the WebView and its WebEngine (although not all WebEngines have
 360      * a WebView, every WebView has one and only one WebEngine).
 361      */
 362     private final ObjectProperty&lt;WebView&gt; view = new SimpleObjectProperty&lt;WebView&gt;(this, &quot;view&quot;);
 363 
 364     /**
 365      * The Worker which shows progress of the web engine as it loads pages.
 366      */
 367     private final LoadWorker loadWorker = new LoadWorker();
 368 
 369     /**
 370      * The object that provides interaction with the native webkit core.
 371      */
 372     private final WebPage page;
 373 
 374     private final SelfDisposer disposer;
 375 
 376     private final DebuggerImpl debugger = new DebuggerImpl();
 377 
 378     private boolean userDataDirectoryApplied = false;
 379 
 380 
 381     /**
 382      * Returns a {@link javafx.concurrent.Worker} object that can be used to
 383      * track loading progress.
 384      *
 385      * @return the {@code Worker} object
 386      */
 387     public final Worker&lt;Void&gt; getLoadWorker() {
 388         return loadWorker;
 389     }
 390 
 391 
 392     /*
 393      * The final document. This may be null if no document has been loaded.
 394      */
 395     private final DocumentProperty document = new DocumentProperty();
 396 
 397     public final Document getDocument() { return document.getValue(); }
 398 
 399     /**
 400      * Document object for the current Web page. The value is {@code null}
 401      * if the Web page failed to load.
 402      *
 403      * @return the document property
 404      */
 405     public final ReadOnlyObjectProperty&lt;Document&gt; documentProperty() {
 406         return document;
 407     }
 408 
 409 
 410     /*
 411      * The location of the current page. This may return null.
 412      */
 413     private final ReadOnlyStringWrapper location = new ReadOnlyStringWrapper(this, &quot;location&quot;);
 414 
 415     public final String getLocation() { return location.getValue(); }
 416 
 417     /**
 418      * URL of the current Web page. If the current page has no URL,
 419      * the value is an empty String.
 420      *
 421      * @return the location property
 422      */
 423     public final ReadOnlyStringProperty locationProperty() { return location.getReadOnlyProperty(); }
 424 
 425     private void updateLocation(String value) {
 426         this.location.set(value);
 427         this.document.invalidate(false);
 428         this.title.set(null);
 429     }
 430 
 431 
 432     /*
 433      * The page title.
 434      */
 435     private final ReadOnlyStringWrapper title = new ReadOnlyStringWrapper(this, &quot;title&quot;);
 436 
 437     public final String getTitle() { return title.getValue(); }
 438 
 439     /**
 440      * Title of the current Web page. If the current page has no title,
 441      * the value is {@code null}.
 442      *
 443      * @return the title property
 444      */
 445     public final ReadOnlyStringProperty titleProperty() { return title.getReadOnlyProperty(); }
 446 
 447     private void updateTitle() {
 448         title.set(page.getTitle(page.getMainFrame()));
 449     }
 450 
 451     //
 452     // Settings
 453 
 454     /**
 455      * Specifies whether JavaScript execution is enabled.
 456      *
 457      * @defaultValue true
 458      * @since JavaFX 2.2
 459      */
 460     private BooleanProperty javaScriptEnabled;
 461 
 462     public final void setJavaScriptEnabled(boolean value) {
 463         javaScriptEnabledProperty().set(value);
 464     }
 465 
 466     public final boolean isJavaScriptEnabled() {
 467         return javaScriptEnabled == null ? true : javaScriptEnabled.get();
 468     }
 469 
 470     public final BooleanProperty javaScriptEnabledProperty() {
 471         if (javaScriptEnabled == null) {
 472             javaScriptEnabled = new BooleanPropertyBase(true) {
 473                 @Override public void invalidated() {
 474                     checkThread();
 475                     page.setJavaScriptEnabled(get());
 476                 }
 477 
 478                 @Override public Object getBean() {
 479                     return WebEngine.this;
 480                 }
 481 
 482                 @Override public String getName() {
 483                     return &quot;javaScriptEnabled&quot;;
 484                 }
 485             };
 486         }
 487         return javaScriptEnabled;
 488     }
 489 
 490     /**
 491      * Location of the user stylesheet as a string URL.
 492      *
 493      * &lt;p&gt;This should be a local URL, i.e. either {@code &#39;data:&#39;},
<a name="1" id="anc1"></a><span class="line-modified"> 494      * {@code &#39;file:&#39;}, {@code &#39;jar:&#39;}, or {@code &#39;jrt:&#39;}. Remote URLs are not allowed</span>
 495      * for security reasons.
 496      *
 497      * @defaultValue null
 498      * @since JavaFX 2.2
 499      */
 500     private StringProperty userStyleSheetLocation;
 501 
 502     public final void setUserStyleSheetLocation(String value) {
 503         userStyleSheetLocationProperty().set(value);
 504     }
 505 
 506     public final String getUserStyleSheetLocation() {
 507         return userStyleSheetLocation == null ? null : userStyleSheetLocation.get();
 508     }
 509 
 510     private byte[] readFully(BufferedInputStream in) throws IOException {
 511         final int BUF_SIZE = 4096;
 512         int outSize = 0;
 513         final List&lt;byte[]&gt; outList = new ArrayList&lt;&gt;();
 514         byte[] buffer = new byte[BUF_SIZE];
 515 
 516         while (true) {
 517             int nBytes = in.read(buffer);
 518             if (nBytes &lt; 0) break;
 519 
 520             byte[] chunk;
 521             if (nBytes == buffer.length) {
 522                 chunk = buffer;
 523                 buffer = new byte[BUF_SIZE];
 524             } else {
 525                 chunk = new byte[nBytes];
 526                 System.arraycopy(buffer, 0, chunk, 0, nBytes);
 527             }
 528             outList.add(chunk);
 529             outSize += nBytes;
 530         }
 531 
 532         final byte[] out = new byte[outSize];
 533         int outPos = 0;
 534         for (byte[] chunk : outList) {
 535             System.arraycopy(chunk, 0, out, outPos, chunk.length);
 536             outPos += chunk.length;
 537         }
 538 
 539         return out;
 540     }
 541 
 542     public final StringProperty userStyleSheetLocationProperty() {
 543         if (userStyleSheetLocation == null) {
 544             userStyleSheetLocation = new StringPropertyBase(null) {
 545                 private final static String DATA_PREFIX = &quot;data:text/css;charset=utf-8;base64,&quot;;
 546 
 547                 @Override public void invalidated() {
 548                     checkThread();
 549                     String url = get();
 550                     String dataUrl;
 551                     if (url == null || url.length() &lt;= 0) {
 552                         dataUrl = null;
 553                     } else if (url.startsWith(DATA_PREFIX)) {
 554                         dataUrl = url;
 555                     } else if (url.startsWith(&quot;file:&quot;) ||
 556                                url.startsWith(&quot;jar:&quot;)  ||
<a name="2" id="anc2"></a><span class="line-added"> 557                                url.startsWith(&quot;jrt:&quot;)  ||</span>
 558                                url.startsWith(&quot;data:&quot;))
 559                     {
 560                         try {
 561                             URLConnection conn = URLs.newURL(url).openConnection();
 562                             conn.connect();
 563 
 564                             BufferedInputStream in =
 565                                     new BufferedInputStream(conn.getInputStream());
 566                             byte[] inBytes = readFully(in);
 567                             String out = Base64.getMimeEncoder().encodeToString(inBytes);
 568                             dataUrl = DATA_PREFIX + out;
 569                         } catch (IOException e) {
 570                             throw new RuntimeException(e);
 571                         }
 572                     } else {
 573                         throw new IllegalArgumentException(&quot;Invalid stylesheet URL&quot;);
 574                     }
 575                     page.setUserStyleSheetLocation(dataUrl);
 576                 }
 577 
 578                 @Override public Object getBean() {
 579                     return WebEngine.this;
 580                 }
 581 
 582                 @Override public String getName() {
 583                     return &quot;userStyleSheetLocation&quot;;
 584                 }
 585             };
 586         }
 587         return userStyleSheetLocation;
 588     }
 589 
 590     /**
 591      * Specifies the directory to be used by this {@code WebEngine}
 592      * to store local user data.
 593      *
 594      * &lt;p&gt;If the value of this property is not {@code null},
 595      * the {@code WebEngine} will attempt to store local user data
 596      * in the respective directory.
 597      * If the value of this property is {@code null},
 598      * the {@code WebEngine} will attempt to store local user data
 599      * in an automatically selected system-dependent user- and
 600      * application-specific directory.
 601      *
 602      * &lt;p&gt;When a {@code WebEngine} is about to start loading a web
 603      * page or executing a script for the first time, it checks whether
 604      * it can actually use the directory specified by this property.
 605      * If the check fails for some reason, the {@code WebEngine} invokes
 606      * the {@link WebEngine#onErrorProperty WebEngine.onError} event handler,
 607      * if any, with a {@link WebErrorEvent} describing the reason.
 608      * If the invoked event handler modifies the {@code userDataDirectory}
 609      * property, the {@code WebEngine} retries with the new value as soon
 610      * as the handler returns. If the handler does not modify the
 611      * {@code userDataDirectory} property (which is the default),
 612      * the {@code WebEngine} continues without local user data.
 613      *
 614      * &lt;p&gt;Once the {@code WebEngine} has started loading a web page or
 615      * executing a script, changes made to this property have no effect
 616      * on where the {@code WebEngine} stores or will store local user
 617      * data.
 618      *
 619      * &lt;p&gt;Currently, the directory specified by this property is used
 620      * only to store the data that backs the {@code window.localStorage}
 621      * objects. In the future, more types of data can be added.
 622      *
 623      * @defaultValue {@code null}
 624      * @since JavaFX 8.0
 625      */
 626     private final ObjectProperty&lt;File&gt; userDataDirectory =
 627             new SimpleObjectProperty&lt;&gt;(this, &quot;userDataDirectory&quot;);
 628 
 629     public final File getUserDataDirectory() {
 630         return userDataDirectory.get();
 631     }
 632 
 633     public final void setUserDataDirectory(File value) {
 634         userDataDirectory.set(value);
 635     }
 636 
 637     public final ObjectProperty&lt;File&gt; userDataDirectoryProperty() {
 638         return userDataDirectory;
 639     }
 640 
 641     /**
 642      * Specifies user agent ID string. This string is the value of the
 643      * {@code User-Agent} HTTP header.
 644      *
 645      * @defaultValue system dependent
 646      * @since JavaFX 8.0
 647      */
 648     private StringProperty userAgent;
 649 
 650     public final void setUserAgent(String value) {
 651         userAgentProperty().set(value);
 652     }
 653 
 654     public final String getUserAgent() {
 655         return userAgent == null ? page.getUserAgent() : userAgent.get();
 656     }
 657 
 658     public final StringProperty userAgentProperty() {
 659         if (userAgent == null) {
 660             userAgent = new StringPropertyBase(page.getUserAgent()) {
 661                 @Override public void invalidated() {
 662                     checkThread();
 663                     page.setUserAgent(get());
 664                 }
 665 
 666                 @Override public Object getBean() {
 667                     return WebEngine.this;
 668                 }
 669 
 670                 @Override public String getName() {
 671                     return &quot;userAgent&quot;;
 672                 }
 673             };
 674         }
 675         return userAgent;
 676     }
 677 
 678     private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onAlert
 679             = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt;(this, &quot;onAlert&quot;);
 680 
 681     public final EventHandler&lt;WebEvent&lt;String&gt;&gt; getOnAlert() { return onAlert.get(); }
 682 
 683     public final void setOnAlert(EventHandler&lt;WebEvent&lt;String&gt;&gt; handler) { onAlert.set(handler); }
 684 
 685     /**
 686      * JavaScript {@code alert} handler property. This handler is invoked
 687      * when a script running on the Web page calls the {@code alert} function.
 688      * @return the onAlert property
 689      */
 690     public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onAlertProperty() { return onAlert; }
 691 
 692 
 693     private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onStatusChanged
 694             = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt;(this, &quot;onStatusChanged&quot;);
 695 
 696     public final EventHandler&lt;WebEvent&lt;String&gt;&gt; getOnStatusChanged() { return onStatusChanged.get(); }
 697 
 698     public final void setOnStatusChanged(EventHandler&lt;WebEvent&lt;String&gt;&gt; handler) { onStatusChanged.set(handler); }
 699 
 700     /**
 701      * JavaScript status handler property. This handler is invoked when
 702      * a script running on the Web page sets {@code window.status} property.
 703      * @return the onStatusChanged property
 704      */
 705     public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onStatusChangedProperty() { return onStatusChanged; }
 706 
 707 
 708     private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt; onResized
 709             = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt;(this, &quot;onResized&quot;);
 710 
 711     public final EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt; getOnResized() { return onResized.get(); }
 712 
 713     public final void setOnResized(EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt; handler) { onResized.set(handler); }
 714 
 715     /**
 716      * JavaScript window resize handler property. This handler is invoked
 717      * when a script running on the Web page moves or resizes the
 718      * {@code window} object.
 719      * @return the onResized property
 720      */
 721     public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt; onResizedProperty() { return onResized; }
 722 
 723 
 724     private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt; onVisibilityChanged
 725             = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt;(this, &quot;onVisibilityChanged&quot;);
 726 
 727     public final EventHandler&lt;WebEvent&lt;Boolean&gt;&gt; getOnVisibilityChanged() { return onVisibilityChanged.get(); }
 728 
 729     public final void setOnVisibilityChanged(EventHandler&lt;WebEvent&lt;Boolean&gt;&gt; handler) { onVisibilityChanged.set(handler); }
 730 
 731     /**
 732      * JavaScript window visibility handler property. This handler is invoked
 733      * when a script running on the Web page changes visibility of the
 734      * {@code window} object.
 735      * @return the onVisibilityChanged property
 736      */
 737     public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt; onVisibilityChangedProperty() { return onVisibilityChanged; }
 738 
 739 
 740     private final ObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt; createPopupHandler
 741             = new SimpleObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt;(this, &quot;createPopupHandler&quot;,
 742             p -&gt; WebEngine.this);
 743 
 744     public final Callback&lt;PopupFeatures, WebEngine&gt; getCreatePopupHandler() { return createPopupHandler.get(); }
 745 
 746     public final void setCreatePopupHandler(Callback&lt;PopupFeatures, WebEngine&gt; handler) { createPopupHandler.set(handler); }
 747 
 748     /**
 749      * JavaScript popup handler property. This handler is invoked when a script
 750      * running on the Web page requests a popup to be created.
 751      * &lt;p&gt;To satisfy this request a handler may create a new {@code WebEngine},
 752      * attach a visibility handler and optionally a resize handler, and return
 753      * the newly created engine. To block the popup, a handler should return
 754      * {@code null}.
 755      * &lt;p&gt;By default, a popup handler is installed that opens popups in this
 756      * {@code WebEngine}.
 757      *
 758      * @return the createPopupHandler property
 759      *
 760      * @see PopupFeatures
 761      */
 762     public final ObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt; createPopupHandlerProperty() { return createPopupHandler; }
 763 
 764 
 765     private final ObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt; confirmHandler
 766             = new SimpleObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt;(this, &quot;confirmHandler&quot;);
 767 
 768     public final Callback&lt;String, Boolean&gt; getConfirmHandler() { return confirmHandler.get(); }
 769 
 770     public final void setConfirmHandler(Callback&lt;String, Boolean&gt; handler) { confirmHandler.set(handler); }
 771 
 772     /**
 773      * JavaScript {@code confirm} handler property. This handler is invoked
 774      * when a script running on the Web page calls the {@code confirm} function.
 775      * &lt;p&gt;An implementation may display a dialog box with Yes and No options,
 776      * and return the user&#39;s choice.
 777      *
 778      * @return the confirmHandler property
 779      */
 780     public final ObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt; confirmHandlerProperty() { return confirmHandler; }
 781 
 782 
 783     private final ObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt; promptHandler
 784             = new SimpleObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt;(this, &quot;promptHandler&quot;);
 785 
 786     public final Callback&lt;PromptData, String&gt; getPromptHandler() { return promptHandler.get(); }
 787 
 788     public final void setPromptHandler(Callback&lt;PromptData, String&gt; handler) { promptHandler.set(handler); }
 789 
 790     /**
 791      * JavaScript {@code prompt} handler property. This handler is invoked
 792      * when a script running on the Web page calls the {@code prompt} function.
 793      * &lt;p&gt;An implementation may display a dialog box with an text field,
 794      * and return the user&#39;s input.
 795      *
 796      * @return the promptHandler property
 797      * @see PromptData
 798      */
 799     public final ObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt; promptHandlerProperty() { return promptHandler; }
 800 
 801     /**
 802      * The event handler called when an error occurs.
 803      *
 804      * @defaultValue {@code null}
 805      * @since JavaFX 8.0
 806      */
 807     private final ObjectProperty&lt;EventHandler&lt;WebErrorEvent&gt;&gt; onError =
 808             new SimpleObjectProperty&lt;&gt;(this, &quot;onError&quot;);
 809 
 810     public final EventHandler&lt;WebErrorEvent&gt; getOnError() {
 811         return onError.get();
 812     }
 813 
 814     public final void setOnError(EventHandler&lt;WebErrorEvent&gt; handler) {
 815         onError.set(handler);
 816     }
 817 
 818     public final ObjectProperty&lt;EventHandler&lt;WebErrorEvent&gt;&gt; onErrorProperty() {
 819         return onError;
 820     }
 821 
 822 
 823     /**
 824      * Creates a new engine.
 825      */
 826     public WebEngine() {
 827         this(null, false);
 828     }
 829 
 830     /**
 831      * Creates a new engine and loads a Web page into it.
 832      *
 833      * @param url the URL of the web page to load
 834      */
 835     public WebEngine(String url) {
 836         this(url, true);
 837     }
 838 
 839     private WebEngine(String url, boolean callLoad) {
 840         checkThread();
 841         Accessor accessor = new AccessorImpl(this);
 842         page = new WebPage(
 843             new WebPageClientImpl(accessor),
 844             new UIClientImpl(accessor),
 845             null,
 846             new InspectorClientImpl(this),
 847             new ThemeClientImpl(accessor),
 848             false);
 849         page.addLoadListenerClient(new PageLoadListener(this));
 850 
 851         history = new WebHistory(page);
 852 
 853         disposer = new SelfDisposer(page);
 854         Disposer.addRecord(this, disposer);
 855 
 856         if (callLoad) {
 857             load(url);
 858         }
 859 
 860         if (instanceCount == 0 &amp;&amp;
 861             Timer.getMode() == Timer.Mode.PLATFORM_TICKS)
 862         {
 863             PulseTimer.start();
 864         }
 865         instanceCount++;
 866     }
 867 
 868     /**
 869      * Loads a Web page into this engine. This method starts asynchronous
 870      * loading and returns immediately.
 871      * @param url URL of the web page to load
 872      */
 873     public void load(String url) {
 874         checkThread();
 875         loadWorker.cancelAndReset();
 876 
 877         if (url == null || url.equals(&quot;&quot;) || url.equals(&quot;about:blank&quot;)) {
 878             url = &quot;&quot;;
 879         } else {
 880             // verify and, if possible, adjust the url on the Java
 881             // side, otherwise it may crash native code
 882             try {
 883                 url = Util.adjustUrlForWebKit(url);
 884             } catch (MalformedURLException e) {
 885                 loadWorker.dispatchLoadEvent(getMainFrame(),
 886                         PAGE_STARTED, url, null, 0.0, 0);
 887                 loadWorker.dispatchLoadEvent(getMainFrame(),
 888                         LOAD_FAILED, url, null, 0.0, MALFORMED_URL);
 889                 return;
 890             }
 891         }
 892         applyUserDataDirectory();
 893         page.open(page.getMainFrame(), url);
 894     }
 895 
 896     /**
 897      * Loads the given HTML content directly. This method is useful when you have an HTML
 898      * String composed in memory, or loaded from some system which cannot be reached via
 899      * a URL (for example, the HTML text may have come from a database). As with
 900      * {@link #load(String)}, this method is asynchronous.
 901      *
 902      * @param content the HTML content to load
 903      */
 904     public void loadContent(String content) {
 905         loadContent(content, &quot;text/html&quot;);
 906     }
 907 
 908     /**
 909      * Loads the given content directly. This method is useful when you have content
 910      * composed in memory, or loaded from some system which cannot be reached via
 911      * a URL (for example, the SVG text may have come from a database). As with
 912      * {@link #load(String)}, this method is asynchronous. This method also allows you to
 913      * specify the content type of the string being loaded, and so may optionally support
 914      * other types besides just HTML.
 915      *
 916      * @param content the HTML content to load
 917      * @param contentType the type of content to load
 918      */
 919     public void loadContent(String content, String contentType) {
 920         checkThread();
 921         loadWorker.cancelAndReset();
 922         applyUserDataDirectory();
 923         page.load(page.getMainFrame(), content, contentType);
 924     }
 925 
 926     /**
 927      * Reloads the current page, whether loaded from URL or directly from a String in
 928      * one of the {@code loadContent} methods.
 929      */
 930     public void reload() {
 931         // TODO what happens if this is called while currently loading a page?
 932         checkThread();
 933         page.refresh(page.getMainFrame());
 934     }
 935 
 936     private final WebHistory history;
 937 
 938     /**
 939      * Returns the session history object.
 940      *
 941      * @return history object
 942      * @since JavaFX 2.2
 943      */
 944     public WebHistory getHistory() {
 945         return history;
 946     }
 947 
 948     /**
 949      * Executes a script in the context of the current page.
 950      *
 951      * @param script the script
 952      * @return execution result, converted to a Java object using the following
 953      * rules:
 954      * &lt;ul&gt;
 955      * &lt;li&gt;JavaScript Int32 is converted to {@code java.lang.Integer}
 956      * &lt;li&gt;Other JavaScript numbers to {@code java.lang.Double}
 957      * &lt;li&gt;JavaScript string to {@code java.lang.String}
 958      * &lt;li&gt;JavaScript boolean to {@code java.lang.Boolean}
 959      * &lt;li&gt;JavaScript {@code null} to {@code null}
 960      * &lt;li&gt;Most JavaScript objects get wrapped as
 961      *     {@code netscape.javascript.JSObject}
 962      * &lt;li&gt;JavaScript JSNode objects get mapped to instances of
 963      *     {@code netscape.javascript.JSObject}, that also implement
 964      *     {@code org.w3c.dom.Node}
 965      * &lt;li&gt;A special case is the JavaScript class {@code JavaRuntimeObject}
 966      *     which is used to wrap a Java object as a JavaScript value - in this
 967      *     case we just extract the original Java value.
 968      * &lt;/ul&gt;
 969      */
 970     public Object executeScript(String script) {
 971         checkThread();
 972         applyUserDataDirectory();
 973         return page.executeScript(page.getMainFrame(), script);
 974     }
 975 
 976     private long getMainFrame() {
 977         return page.getMainFrame();
 978     }
 979 
 980     WebPage getPage() {
 981         return page;
 982     }
 983 
 984     void setView(WebView view) {
 985         this.view.setValue(view);
 986     }
 987 
 988     private void stop() {
 989         checkThread();
 990         page.stop(page.getMainFrame());
 991     }
 992 
 993     private void applyUserDataDirectory() {
 994         if (userDataDirectoryApplied) {
 995             return;
 996         }
 997         userDataDirectoryApplied = true;
 998         File nominalUserDataDir = getUserDataDirectory();
 999         while (true) {
1000             File userDataDir;
1001             String displayString;
1002             if (nominalUserDataDir == null) {
1003                 userDataDir = defaultUserDataDirectory();
1004                 displayString = format(&quot;null (%s)&quot;, userDataDir);
1005             } else {
1006                 userDataDir = nominalUserDataDir;
1007                 displayString = userDataDir.toString();
1008             }
1009             logger.fine(&quot;Trying to apply user data directory [{0}]&quot;, displayString);
1010             String errorMessage;
1011             EventType&lt;WebErrorEvent&gt; errorType;
1012             Throwable error;
1013             try {
1014                 userDataDir = DirectoryLock.canonicalize(userDataDir);
1015                 File localStorageDir = new File(userDataDir, &quot;localstorage&quot;);
1016                 File[] dirs = new File[] {
1017                     userDataDir,
1018                     localStorageDir,
1019                 };
1020                 for (File dir : dirs) {
1021                     createDirectories(dir);
1022                     // Additional security check to make sure the caller
1023                     // has permission to write to the target directory
1024                     File test = new File(dir, &quot;.test&quot;);
1025                     if (test.createNewFile()) {
1026                         test.delete();
1027                     }
1028                 }
1029                 disposer.userDataDirectoryLock = new DirectoryLock(userDataDir);
1030 
1031                 page.setLocalStorageDatabasePath(localStorageDir.getPath());
1032                 page.setLocalStorageEnabled(true);
1033 
1034                 logger.fine(&quot;User data directory [{0}] has &quot;
1035                         + &quot;been applied successfully&quot;, displayString);
1036                 return;
1037 
1038             } catch (DirectoryLock.DirectoryAlreadyInUseException ex) {
1039                 errorMessage = &quot;User data directory [%s] is already in use&quot;;
1040                 errorType = WebErrorEvent.USER_DATA_DIRECTORY_ALREADY_IN_USE;
1041                 error = ex;
1042             } catch (IOException ex) {
1043                 errorMessage = &quot;An I/O error occurred while setting up &quot;
1044                         + &quot;user data directory [%s]&quot;;
1045                 errorType = WebErrorEvent.USER_DATA_DIRECTORY_IO_ERROR;
1046                 error = ex;
1047             } catch (SecurityException ex) {
1048                 errorMessage = &quot;A security error occurred while setting up &quot;
1049                         + &quot;user data directory [%s]&quot;;
1050                 errorType = WebErrorEvent.USER_DATA_DIRECTORY_SECURITY_ERROR;
1051                 error = ex;
1052             }
1053 
1054             errorMessage = format(errorMessage, displayString);
1055             logger.fine(&quot;{0}, calling error handler&quot;, errorMessage);
1056             File oldNominalUserDataDir = nominalUserDataDir;
1057             fireError(errorType, errorMessage, error);
1058             nominalUserDataDir = getUserDataDirectory();
1059             if (Objects.equals(nominalUserDataDir, oldNominalUserDataDir)) {
1060                 logger.fine(&quot;Error handler did not modify user data directory, &quot;
1061                         + &quot;continuing without user data directory&quot;);
1062                 return;
1063             } else {
1064                 logger.fine(&quot;Error handler has set user data directory to [{0}], &quot;
1065                         + &quot;retrying&quot;, nominalUserDataDir);
1066                 continue;
1067             }
1068         }
1069     }
1070 
1071     private static File defaultUserDataDirectory() {
1072         return new File(
1073                 com.sun.glass.ui.Application.GetApplication()
1074                         .getDataDirectory(),
1075                 &quot;webview&quot;);
1076     }
1077 
1078     private static void createDirectories(File directory) throws IOException {
1079         Path path = directory.toPath();
1080         try {
1081             Files.createDirectories(path, PosixFilePermissions.asFileAttribute(
1082                     PosixFilePermissions.fromString(&quot;rwx------&quot;)));
1083         } catch (UnsupportedOperationException ex) {
1084             Files.createDirectories(path);
1085         }
1086     }
1087 
1088     private void fireError(EventType&lt;WebErrorEvent&gt; eventType, String message,
1089                            Throwable exception)
1090     {
1091         EventHandler&lt;WebErrorEvent&gt; handler = getOnError();
1092         if (handler != null) {
1093             handler.handle(new WebErrorEvent(this, eventType,
1094                                              message, exception));
1095         }
1096     }
1097 
1098     // for testing purposes only
1099     void dispose() {
1100         disposer.dispose();
1101     }
1102 
1103     private static final class SelfDisposer implements DisposerRecord {
1104         private WebPage page;
1105         private DirectoryLock userDataDirectoryLock;
1106 
1107         private SelfDisposer(WebPage page) {
1108             this.page = page;
1109         }
1110 
1111         @Override public void dispose() {
1112             if (page == null) {
1113                 return;
1114             }
1115             page.dispose();
1116             page = null;
1117             if (userDataDirectoryLock != null) {
1118                 userDataDirectoryLock.close();
1119             }
1120             instanceCount--;
1121             if (instanceCount == 0 &amp;&amp;
1122                 Timer.getMode() == Timer.Mode.PLATFORM_TICKS)
1123             {
1124                 PulseTimer.stop();
1125             }
1126         }
1127     }
1128 
1129     private static final class AccessorImpl extends Accessor {
1130         private final WeakReference&lt;WebEngine&gt; engine;
1131 
1132         private AccessorImpl(WebEngine w) {
1133             this.engine = new WeakReference&lt;WebEngine&gt;(w);
1134         }
1135 
1136         @Override public WebEngine getEngine() {
1137             return engine.get();
1138         }
1139 
1140         @Override public WebPage getPage() {
1141             WebEngine w = getEngine();
1142             return w == null ? null : w.page;
1143         }
1144 
1145         @Override public WebView getView() {
1146             WebEngine w = getEngine();
1147             return w == null ? null : w.view.get();
1148         }
1149 
1150         @Override public void addChild(Node child) {
1151             WebView view = getView();
1152             if (view != null) {
1153                 view.getChildren().add(child);
1154             }
1155         }
1156 
1157         @Override public void removeChild(Node child) {
1158             WebView view = getView();
1159             if (view != null) {
1160                 view.getChildren().remove(child);
1161             }
1162         }
1163 
1164         @Override public void addViewListener(InvalidationListener l) {
1165             WebEngine w = getEngine();
1166             if (w != null) {
1167                 w.view.addListener(l);
1168             }
1169         }
1170     }
1171 
1172     /**
1173      * Drives the {@code Timer} when {@code Timer.Mode.PLATFORM_TICKS} is set.
1174      */
1175     private static final class PulseTimer {
1176 
1177         // Used just to guarantee constant pulse activity. See RT-14433.
1178         private static final AnimationTimer animation =
1179             new AnimationTimer() {
1180                 @Override public void handle(long l) {}
1181             };
1182 
1183         private static final TKPulseListener listener =
1184                 () -&gt; {
1185                     // Note, the timer event is executed right in the notifyTick(),
1186                     // that is during the pulse event. This makes the timer more
1187                     // repsonsive, though prolongs the pulse. So far it causes no
1188                     // problems but nevertheless it should be kept in mind.
1189 
1190                     // Execute notifyTick in runLater to run outside of pulse so
1191                     // that events will run in order and be able to display dialogs
1192                     // or call other methods that require a nested event loop.
1193                     Platform.runLater(() -&gt; Timer.getTimer().notifyTick());
1194                 };
1195 
1196         private static void start(){
1197             Toolkit.getToolkit().addSceneTkPulseListener(listener);
1198             animation.start();
1199         }
1200 
1201         private static void stop() {
1202             Toolkit.getToolkit().removeSceneTkPulseListener(listener);
1203             animation.stop();
1204         }
1205     }
1206 
1207     static void checkThread() {
1208         Toolkit.getToolkit().checkFxUserThread();
1209     }
1210 
1211 
1212     /**
1213      * The page load event listener. This object references the owner
1214      * WebEngine weakly so as to avoid referencing WebEngine from WebPage
1215      * strongly.
1216      */
1217     private static final class PageLoadListener implements LoadListenerClient {
1218 
1219         private final WeakReference&lt;WebEngine&gt; engine;
1220 
1221 
1222         private PageLoadListener(WebEngine engine) {
1223             this.engine = new WeakReference&lt;WebEngine&gt;(engine);
1224         }
1225 
1226 
1227         @Override public void dispatchLoadEvent(long frame, int state,
1228                 String url, String contentType, double progress, int errorCode)
1229         {
1230             WebEngine w = engine.get();
1231             if (w != null) {
1232                 w.loadWorker.dispatchLoadEvent(frame, state, url,
1233                         contentType, progress, errorCode);
1234             }
1235         }
1236 
1237         @Override public void dispatchResourceLoadEvent(long frame,
1238                 int state, String url, String contentType, double progress,
1239                 int errorCode)
1240         {
1241         }
1242     }
1243 
1244 
1245     private final class LoadWorker implements Worker&lt;Void&gt; {
1246 
1247         private final ReadOnlyObjectWrapper&lt;State&gt; state = new ReadOnlyObjectWrapper&lt;State&gt;(this, &quot;state&quot;, State.READY);
1248         @Override public final State getState() { checkThread(); return state.get(); }
1249         @Override public final ReadOnlyObjectProperty&lt;State&gt; stateProperty() { checkThread(); return state.getReadOnlyProperty(); }
1250         private void updateState(State value) {
1251             checkThread();
1252             this.state.set(value);
1253             running.set(value == State.SCHEDULED || value == State.RUNNING);
1254         }
1255 
1256         /**
1257          * @InheritDoc
1258          */
1259         private final ReadOnlyObjectWrapper&lt;Void&gt; value = new ReadOnlyObjectWrapper&lt;Void&gt;(this, &quot;value&quot;, null);
1260         @Override public final Void getValue() { checkThread(); return value.get(); }
1261         @Override public final ReadOnlyObjectProperty&lt;Void&gt; valueProperty() { checkThread(); return value.getReadOnlyProperty(); }
1262 
1263         /**
1264          * @InheritDoc
1265          */
1266         private final ReadOnlyObjectWrapper&lt;Throwable&gt; exception = new ReadOnlyObjectWrapper&lt;Throwable&gt;(this, &quot;exception&quot;);
1267         @Override public final Throwable getException() { checkThread(); return exception.get(); }
1268         @Override public final ReadOnlyObjectProperty&lt;Throwable&gt; exceptionProperty() { checkThread(); return exception.getReadOnlyProperty(); }
1269 
1270         /**
1271          * @InheritDoc
1272          */
1273         private final ReadOnlyDoubleWrapper workDone = new ReadOnlyDoubleWrapper(this, &quot;workDone&quot;, -1);
1274         @Override public final double getWorkDone() { checkThread(); return workDone.get(); }
1275         @Override public final ReadOnlyDoubleProperty workDoneProperty() { checkThread(); return workDone.getReadOnlyProperty(); }
1276 
1277         /**
1278          * @InheritDoc
1279          */
1280         private final ReadOnlyDoubleWrapper totalWorkToBeDone = new ReadOnlyDoubleWrapper(this, &quot;totalWork&quot;, -1);
1281         @Override public final double getTotalWork() { checkThread(); return totalWorkToBeDone.get(); }
1282         @Override public final ReadOnlyDoubleProperty totalWorkProperty() { checkThread(); return totalWorkToBeDone.getReadOnlyProperty(); }
1283 
1284         /**
1285          * @InheritDoc
1286          */
1287         private final ReadOnlyDoubleWrapper progress = new ReadOnlyDoubleWrapper(this, &quot;progress&quot;, -1);
1288         @Override public final double getProgress() { checkThread(); return progress.get(); }
1289         @Override public final ReadOnlyDoubleProperty progressProperty() { checkThread(); return progress.getReadOnlyProperty(); }
1290         private void updateProgress(double p) {
1291             totalWorkToBeDone.set(100.0);
1292             workDone.set(p * 100.0);
1293             progress.set(p);
1294         }
1295 
1296         /**
1297          * @InheritDoc
1298          */
1299         private final ReadOnlyBooleanWrapper running = new ReadOnlyBooleanWrapper(this, &quot;running&quot;, false);
1300         @Override public final boolean isRunning() { checkThread(); return running.get(); }
1301         @Override public final ReadOnlyBooleanProperty runningProperty() { checkThread(); return running.getReadOnlyProperty(); }
1302 
1303         /**
1304          * @InheritDoc
1305          */
1306         private final ReadOnlyStringWrapper message = new ReadOnlyStringWrapper(this, &quot;message&quot;, &quot;&quot;);
1307         @Override public final String getMessage() { return message.get(); }
1308         @Override public final ReadOnlyStringProperty messageProperty() { return message.getReadOnlyProperty(); }
1309 
1310         /**
1311          * @InheritDoc
1312          */
1313         private final ReadOnlyStringWrapper title = new ReadOnlyStringWrapper(this, &quot;title&quot;, &quot;WebEngine Loader&quot;);
1314         @Override public final String getTitle() { return title.get(); }
1315         @Override public final ReadOnlyStringProperty titleProperty() { return title.getReadOnlyProperty(); }
1316 
1317         /**
1318          * Cancels the loading of the page. If called after the page has already
1319          * been loaded, then this call takes no effect.
1320          */
1321         @Override public boolean cancel() {
1322             if (isRunning()) {
1323                 stop(); // this call indirectly sets state
1324                 return true;
1325             } else {
1326                 return false;
1327             }
1328         }
1329 
1330         private void cancelAndReset() {
1331             cancel();
1332             exception.set(null);
1333             message.set(&quot;&quot;);
1334             totalWorkToBeDone.set(-1);
1335             workDone.set(-1);
1336             progress.set(-1);
1337             updateState(State.READY);
1338             running.set(false);
1339         }
1340 
1341         private void dispatchLoadEvent(long frame, int state,
1342                 String url, String contentType, double workDone, int errorCode)
1343         {
1344             if (frame != getMainFrame()) {
1345                 return;
1346             }
1347             switch (state) {
1348                 case PAGE_STARTED:
1349                     message.set(&quot;Loading &quot; + url);
1350                     updateLocation(url);
1351                     updateProgress(0.0);
1352                     updateState(State.SCHEDULED);
1353                     updateState(State.RUNNING);
1354                     break;
1355                 case PAGE_REDIRECTED:
1356                     message.set(&quot;Loading &quot; + url);
1357                     updateLocation(url);
1358                     break;
1359                 case PAGE_REPLACED:
1360                     message.set(&quot;Replaced &quot; + url);
1361                     // Update only the location, don&#39;t change title or document.
1362                     WebEngine.this.location.set(url);
1363                     break;
1364                 case PAGE_FINISHED:
1365                     message.set(&quot;Loading complete&quot;);
1366                     updateProgress(1.0);
1367                     updateState(State.SUCCEEDED);
1368                     break;
1369                 case LOAD_FAILED:
1370                     message.set(&quot;Loading failed&quot;);
1371                     exception.set(describeError(errorCode));
1372                     updateState(State.FAILED);
1373                     break;
1374                 case LOAD_STOPPED:
1375                     message.set(&quot;Loading stopped&quot;);
1376                     updateState(State.CANCELLED);
1377                     break;
1378                 case PROGRESS_CHANGED:
1379                     updateProgress(workDone);
1380                     break;
1381                 case TITLE_RECEIVED:
1382                     updateTitle();
1383                     break;
1384                 case DOCUMENT_AVAILABLE:
1385                     if (this.state.get() != State.RUNNING) {
1386                         // We have empty load; send a synthetic event (RT-32097)
1387                         dispatchLoadEvent(frame, PAGE_STARTED, url, contentType, workDone, errorCode);
1388                     }
1389                     document.invalidate(true);
1390                     break;
1391             }
1392         }
1393 
1394         private Throwable describeError(int errorCode) {
1395             String reason = &quot;Unknown error&quot;;
1396 
1397             switch (errorCode) {
1398                 case UNKNOWN_HOST:
1399                     reason = &quot;Unknown host&quot;;
1400                     break;
1401                 case MALFORMED_URL:
1402                     reason = &quot;Malformed URL&quot;;
1403                     break;
1404                 case SSL_HANDSHAKE:
1405                     reason = &quot;SSL handshake failed&quot;;
1406                     break;
1407                 case CONNECTION_REFUSED:
1408                     reason = &quot;Connection refused by server&quot;;
1409                     break;
1410                 case CONNECTION_RESET:
1411                     reason = &quot;Connection reset by server&quot;;
1412                     break;
1413                 case NO_ROUTE_TO_HOST:
1414                     reason = &quot;No route to host&quot;;
1415                     break;
1416                 case CONNECTION_TIMED_OUT:
1417                     reason = &quot;Connection timed out&quot;;
1418                     break;
1419                 case PERMISSION_DENIED:
1420                     reason = &quot;Permission denied&quot;;
1421                     break;
1422                 case INVALID_RESPONSE:
1423                     reason = &quot;Invalid response from server&quot;;
1424                     break;
1425                 case TOO_MANY_REDIRECTS:
1426                     reason = &quot;Too many redirects&quot;;
1427                     break;
1428                 case FILE_NOT_FOUND:
1429                     reason = &quot;File not found&quot;;
1430                     break;
1431             }
1432             return new Throwable(reason);
1433         }
1434     }
1435 
1436 
1437     private final class DocumentProperty
1438             extends ReadOnlyObjectPropertyBase&lt;Document&gt; {
1439 
1440         private boolean available;
1441         private Document document;
1442 
1443         private void invalidate(boolean available) {
1444             if (this.available || available) {
1445                 this.available = available;
1446                 this.document = null;
1447                 fireValueChangedEvent();
1448             }
1449         }
1450 
1451         public Document get() {
1452             if (!this.available) {
1453                 return null;
1454             }
1455             if (this.document == null) {
1456                 this.document = page.getDocument(page.getMainFrame());
1457                 if (this.document == null) {
1458                     this.available = false;
1459                 }
1460             }
1461             return this.document;
1462         }
1463 
1464         public Object getBean() {
1465             return WebEngine.this;
1466         }
1467 
1468         public String getName() {
1469             return &quot;document&quot;;
1470         }
1471     }
1472 
1473 
1474     /*
1475      * Returns the debugger associated with this web engine.
1476      * The debugger is an object that can be used to debug
1477      * the web page currently loaded into the web engine.
1478      * &lt;p&gt;
1479      * All methods of the debugger must be called on
1480      * the JavaFX Application Thread.
1481      * The message callback object registered with the debugger
1482      * is always called on the JavaFX Application Thread.
1483      * @return the debugger associated with this web engine.
1484      *         The return value cannot be {@code null}.
1485      */
1486     Debugger getDebugger() {
1487         return debugger;
1488     }
1489 
1490     /**
1491      * The debugger implementation.
1492      */
1493     private final class DebuggerImpl implements Debugger {
1494 
1495         private boolean enabled;
1496         private Callback&lt;String,Void&gt; messageCallback;
1497 
1498 
1499         @Override
1500         public boolean isEnabled() {
1501             checkThread();
1502             return enabled;
1503         }
1504 
1505         @Override
1506         public void setEnabled(boolean enabled) {
1507             checkThread();
1508             if (enabled != this.enabled) {
1509                 if (enabled) {
1510                     page.setDeveloperExtrasEnabled(true);
1511                     page.connectInspectorFrontend();
1512                 } else {
1513                     page.disconnectInspectorFrontend();
1514                     page.setDeveloperExtrasEnabled(false);
1515                 }
1516                 this.enabled = enabled;
1517             }
1518         }
1519 
1520         @Override
1521         public void sendMessage(String message) {
1522             checkThread();
1523             if (!enabled) {
1524                 throw new IllegalStateException(&quot;Debugger is not enabled&quot;);
1525             }
1526             if (message == null) {
1527                 throw new NullPointerException(&quot;message is null&quot;);
1528             }
1529             page.dispatchInspectorMessageFromFrontend(message);
1530         }
1531 
1532         @Override
1533         public Callback&lt;String,Void&gt; getMessageCallback() {
1534             checkThread();
1535             return messageCallback;
1536         }
1537 
1538         @Override
1539         public void setMessageCallback(Callback&lt;String,Void&gt; callback) {
1540             checkThread();
1541             messageCallback = callback;
1542         }
1543     }
1544 
1545     /**
1546      * The inspector client implementation. This object references the owner
1547      * WebEngine weakly so as to avoid referencing WebEngine from WebPage
1548      * strongly.
1549      */
1550     private static final class InspectorClientImpl implements InspectorClient {
1551 
1552         private final WeakReference&lt;WebEngine&gt; engine;
1553 
1554 
1555         private InspectorClientImpl(WebEngine engine) {
1556             this.engine = new WeakReference&lt;WebEngine&gt;(engine);
1557         }
1558 
1559 
1560         @Override
1561         public boolean sendMessageToFrontend(final String message) {
1562             boolean result = false;
1563             WebEngine webEngine = engine.get();
1564             if (webEngine != null) {
1565                 final Callback&lt;String,Void&gt; messageCallback =
1566                         webEngine.debugger.messageCallback;
1567                 if (messageCallback != null) {
1568                     AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
1569                         messageCallback.call(message);
1570                         return null;
1571                     }, webEngine.page.getAccessControlContext());
1572                     result = true;
1573                 }
1574             }
1575             return result;
1576         }
1577     }
1578 
1579     private static final boolean printStatusOK(PrinterJob job) {
1580         switch (job.getJobStatus()) {
1581             case NOT_STARTED:
1582             case PRINTING:
1583                 return true;
1584             default:
1585                 return false;
1586         }
1587     }
1588 
1589     /**
1590      * Prints the current Web page using the given printer job.
1591      * &lt;p&gt;This method does not modify the state of the job, nor does it call
1592      * {@link PrinterJob#endJob}, so the job may be safely reused afterwards.
1593      *
1594      * @param job printer job used for printing
1595      * @since JavaFX 8.0
1596      */
1597     public void print(PrinterJob job) {
1598         if (!printStatusOK(job)) {
1599             return;
1600         }
1601 
1602         PageLayout pl = job.getJobSettings().getPageLayout();
1603         float width = (float) pl.getPrintableWidth();
1604         float height = (float) pl.getPrintableHeight();
1605         int pageCount = page.beginPrinting(width, height);
1606 
1607         for (int i = 0; i &lt; pageCount; i++) {
1608             if (printStatusOK(job)) {
1609                 Node printable = new Printable(page, i, width);
1610                 job.printPage(printable);
1611             }
1612         }
1613         page.endPrinting();
1614     }
1615 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>