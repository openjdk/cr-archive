<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/java/javafx/scene/transform/Transform.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.transform;
  27 
  28 import java.util.Iterator;
  29 
  30 import com.sun.javafx.geometry.BoundsUtils;
  31 import javafx.event.EventDispatchChain;
  32 
  33 import javafx.scene.Node;
  34 
  35 import com.sun.javafx.util.WeakReferenceQueue;
  36 import com.sun.javafx.binding.ExpressionHelper;
  37 import com.sun.javafx.event.EventHandlerManager;
  38 import com.sun.javafx.geom.transform.Affine3D;
  39 import com.sun.javafx.geom.transform.BaseTransform;
  40 import com.sun.javafx.scene.NodeHelper;
  41 import com.sun.javafx.scene.transform.TransformHelper;
  42 import com.sun.javafx.scene.transform.TransformUtils;
  43 import java.lang.ref.SoftReference;
  44 import javafx.beans.InvalidationListener;
  45 import javafx.beans.property.ObjectProperty;
  46 import javafx.beans.property.ReadOnlyBooleanProperty;
  47 import javafx.beans.property.SimpleObjectProperty;
  48 import javafx.beans.value.ChangeListener;
  49 import javafx.event.Event;
  50 import javafx.event.EventHandler;
  51 import javafx.event.EventTarget;
  52 import javafx.event.EventType;
  53 import javafx.geometry.Bounds;
  54 import javafx.geometry.Point2D;
  55 import javafx.geometry.Point3D;
  56 
  57 // PENDING_DOC_REVIEW of this whole class
  58 /**
  59  * This class is a base class for different affine transformations.
  60  * It provides factory methods for the simple transformations - rotating,
  61  * scaling, shearing, and translation. It allows to get the transformation
  62  * matrix elements for any transform.
  63  *
  64  * &lt;p&gt;Example:&lt;/p&gt;
  65  *
  66  * &lt;pre&gt;{@code
  67  *  Rectangle rect = new Rectangle(50,50, Color.RED);
  68  *  rect.getTransforms().add(new Rotate(45,0,0)); //rotate by 45 degrees
  69  * }&lt;/pre&gt;
  70  * @since JavaFX 2.0
  71  */
  72 public abstract class Transform implements Cloneable, EventTarget {
  73 
  74     static {
  75         // This is used by classes in different packages to get access to
  76         // private and package private methods.
  77         TransformHelper.setTransformAccessor(new TransformHelper.TransformAccessor() {
  78 
  79             @Override
  80             public void add(Transform transform, Node node) {
  81                 transform.add(node);
  82             }
  83 
  84             @Override
  85             public void remove(Transform transform, Node node) {
  86                 transform.remove(node);
  87             }
  88 
  89             @Override
  90             public void apply(Transform transform, Affine3D affine3D) {
  91                 transform.apply(affine3D);
  92             }
  93 
  94             @Override
  95             public BaseTransform derive(Transform transform, BaseTransform baseTransform) {
  96                 return transform.derive(baseTransform);
  97             }
  98 
  99             @Override
 100             public Transform createImmutableTransform() {
 101                 return Transform.createImmutableTransform();
 102             }
 103 
 104             @Override
 105             public Transform createImmutableTransform(
 106                     double mxx, double mxy, double mxz, double tx,
 107                     double myx, double myy, double myz, double ty,
 108                     double mzx, double mzy, double mzz, double tz) {
 109                 return Transform.createImmutableTransform(mxx, mxy, mxz, tx,
 110                         myx, myy, myz, ty, mzx, mzy, mzz, tz);
 111             }
 112 
 113             @Override
 114             public Transform createImmutableTransform(Transform transform,
 115                     double mxx, double mxy, double mxz, double tx,
 116                     double myx, double myy, double myz, double ty,
 117                     double mzx, double mzy, double mzz, double tz) {
 118                 return Transform.createImmutableTransform(transform,
 119                         mxx, mxy, mxz, tx, myx, myy, myz, ty, mzx, mzy, mzz, tz);
 120             }
 121 
 122             @Override
 123             public Transform createImmutableTransform(Transform transform,
 124                     Transform left, Transform right) {
 125                 return Transform.createImmutableTransform(transform, left, right);
 126             }
 127         });
 128     }
 129 
 130     /* *************************************************************************
 131      *                                                                         *
 132      *                            Factories                                    *
 133      *                                                                         *
 134      **************************************************************************/
 135 
 136     /**
 137      * Returns a new {@code Affine} object from 12 number
 138      * values representing the 6 specifiable entries of the 3x4
 139      * Affine transformation matrix.
 140      *
 141      * @param mxx the X coordinate scaling element of the 3x4 matrix
 142      * @param myx the Y coordinate shearing element of the 3x4 matrix
 143      * @param mxy the X coordinate shearing element of the 3x4 matrix
 144      * @param myy the Y coordinate scaling element of the 3x4 matrix
 145      * @param tx the X coordinate translation element of the 3x4 matrix
 146      * @param ty the Y coordinate translation element of the 3x4 matrix
 147      * @return a new {@code Affine} object derived from specified parameters
 148      */
 149     public static Affine affine(
 150         double mxx, double myx, double mxy, double myy, double tx, double ty) {
 151         final Affine affine = new Affine();
 152         affine.setMxx(mxx);
 153         affine.setMxy(mxy);
 154         affine.setTx(tx);
 155         affine.setMyx(myx);
 156         affine.setMyy(myy);
 157         affine.setTy(ty);
 158         return affine;
 159     }
 160 
 161 
 162     /**
 163      * Returns a new {@code Affine} object from 12 number
 164      * values representing the 12 specifiable entries of the 3x4
 165      * Affine transformation matrix.
 166      *
 167      * @param mxx the X coordinate scaling element of the 3x4 matrix
 168      * @param mxy the XY element of the 3x4 matrix
 169      * @param mxz the XZ element of the 3x4 matrix
 170      * @param tx the X coordinate translation element of the 3x4 matrix
 171      * @param myx the YX element of the 3x4 matrix
 172      * @param myy the Y coordinate scaling element of the 3x4 matrix
 173      * @param myz the YZ element of the 3x4 matrix
 174      * @param ty the Y coordinate translation element of the 3x4 matrix
 175      * @param mzx the ZX element of the 3x4 matrix
 176      * @param mzy the ZY element of the 3x4 matrix
 177      * @param mzz the Z coordinate scaling element of the 3x4 matrix
 178      * @param tz the Z coordinate translation element of the 3x4 matrix
 179      * @return a new {@code Affine} object derived from specified parameters
 180      */
 181     public static Affine affine(
 182         double mxx, double mxy, double mxz, double tx,
 183         double myx, double myy, double myz, double ty,
 184         double mzx, double mzy, double mzz, double tz) {
 185         final Affine affine = new Affine();
 186         affine.setMxx(mxx);
 187         affine.setMxy(mxy);
 188         affine.setMxz(mxz);
 189         affine.setTx(tx);
 190         affine.setMyx(myx);
 191         affine.setMyy(myy);
 192         affine.setMyz(myz);
 193         affine.setTy(ty);
 194         affine.setMzx(mzx);
 195         affine.setMzy(mzy);
 196         affine.setMzz(mzz);
 197         affine.setTz(tz);
 198         return affine;
 199     }
 200 
 201 
 202     /**
 203      * Returns a {@code Translate} object representing a translation transformation.
 204      * &lt;p&gt;
 205      * This is equivalent to:
 206      * &lt;pre&gt;
 207      *    new Translate(x, y);
 208      * &lt;/pre&gt;
 209      * @param x the translate x value
 210      * @param y the translate y value
 211      * @return the Translate object representing a translation transformation
 212      */
 213     public static Translate translate(double x, double y) {
 214         final Translate translate = new Translate();
 215         translate.setX(x);
 216         translate.setY(y);
 217         return translate;
 218     }
 219 
 220 
 221     /**
 222      * Returns a {@code Rotate} object that rotates coordinates around a pivot
 223      * point.
 224      * &lt;p&gt;
 225      * This is equivalent to:
 226      * &lt;pre&gt;
 227      *    new Rotate(angle, pivotX, pivotY);
 228      * &lt;/pre&gt;
 229      * @param angle the rotation angle
 230      * @param pivotX the pivot x value
 231      * @param pivotY the pivot y value
 232      * @return the Rotate object that rotates coordinates around a pivot point
 233      */
 234     public static Rotate rotate(double angle, double pivotX, double pivotY) {
 235         final Rotate rotate = new Rotate();
 236         rotate.setAngle(angle);
 237         rotate.setPivotX(pivotX);
 238         rotate.setPivotY(pivotY);
 239         return rotate;
 240     }
 241 
 242 
 243     /**
 244      * Returns a {@code Scale} object representing a scaling transformation.
 245      * &lt;p&gt;
 246      * This is equivalent to:
 247      * &lt;pre&gt;
 248      *    new Scale(x, y);
 249      * &lt;/pre&gt;
 250      * @param x the scale x value
 251      * @param y the scale y value
 252      * @return the Scale object representing a scaling transformation
 253      */
 254     public static Scale scale(double x, double y) {
 255         final Scale scale = new Scale();
 256         scale.setX(x);
 257         scale.setY(y);
 258         return scale;
 259     }
 260 
 261 
 262     /**
 263      * Returns a {@code Scale} object representing a scaling transformation.
 264      * The returned scale operation will be about the given pivot point.
 265      * &lt;p&gt;
 266      * This is equivalent to:
 267      * &lt;pre&gt;
 268      *    new Scale(x, y, pivotX, pivotY);
 269      * &lt;/pre&gt;
 270      * @param x the scale x value
 271      * @param y the scale y value
 272      * @param pivotX the pivot x value
 273      * @param pivotY the pivot y value
 274      * @return the Scale object representing a scaling transformation
 275      */
 276     public static Scale scale(double x, double y, double pivotX, double pivotY) {
 277         final Scale scale = new Scale();
 278         scale.setX(x);
 279         scale.setY(y);
 280         scale.setPivotX(pivotX);
 281         scale.setPivotY(pivotY);
 282         return scale;
 283     }
 284 
 285 
 286     /**
 287      * Returns a {@code Shear} object representing a shearing transformation.
 288      * &lt;p&gt;
 289      * This is equivalent to:
 290      * &lt;pre&gt;
 291      *    new Shear(x, y);
 292      * &lt;/pre&gt;
 293      * @param x the shear x value
 294      * @param y the shear y value
 295      * @return the Shear object representing a shearing transformation
 296      */
 297     public static Shear shear(double x, double y) {
 298         final Shear shear = new Shear();
 299         shear.setX(x);
 300         shear.setY(y);
 301         return shear;
 302     }
 303 
 304     /**
 305      * Returns a {@code Shear} object representing a shearing transformation.
 306      * &lt;p&gt;
 307      * This is equivalent to:
 308      * &lt;pre&gt;
 309      *    new Shear(x, y, pivotX, pivotY);
 310      * &lt;/pre&gt;
 311      * @param x the shear x value
 312      * @param y the shear y value
 313      * @param pivotX the pivot x value
 314      * @param pivotY the pivot y value
 315      * @return the Shear object representing a shearing transformation
 316      */
 317     public static Shear shear(double x, double y, double pivotX, double pivotY) {
 318         final Shear shear = new Shear();
 319         shear.setX(x);
 320         shear.setY(y);
 321         shear.setPivotX(pivotX);
 322         shear.setPivotY(pivotY);
 323         return shear;
 324     }
 325 
 326     /**
 327      * For transforms with expensive inversion we cache the inverted matrix
 328      * once it is needed and computed for some operation.
 329      */
 330     private SoftReference&lt;Transform&gt; inverseCache = null;
 331 
 332     private WeakReferenceQueue nodes = new WeakReferenceQueue();
 333 
 334     /* *************************************************************************
 335      *                                                                         *
 336      *                         Element getters                                 *
 337      *                                                                         *
 338      **************************************************************************/
 339 
 340     /**
 341      * Gets the X coordinate scaling element of the 3x4 matrix.
 342      *
 343      * @return the X coordinate scaling element of the 3x4 matrix
 344      * @since JavaFX 2.2
 345      */
 346     public  double getMxx() {
 347         return 1.0;
 348     }
 349 
 350     /**
 351      * Gets the XY coordinate element of the 3x4 matrix.
 352      *
 353      * @return the XY coordinate element of the 3x4 matrix
 354      * @since JavaFX 2.2
 355      */
 356     public  double getMxy() {
 357         return 0.0;
 358     }
 359 
 360     /**
 361      * Gets the XZ coordinate element of the 3x4 matrix.
 362      *
 363      * @return the XZ coordinate element of the 3x4 matrix
 364      * @since JavaFX 2.2
 365      */
 366     public  double getMxz() {
 367         return 0.0;
 368     }
 369 
 370     /**
 371      * Gets the X coordinate translation element of the 3x4 matrix.
 372      *
 373      * @return the X coordinate translation element of the 3x4 matrix
 374      * @since JavaFX 2.2
 375      */
 376     public  double getTx() {
 377         return 0.0;
 378     }
 379 
 380     /**
 381      * Gets the YX coordinate element of the 3x4 matrix.
 382      *
 383      * @return the YX coordinate element of the 3x4 matrix
 384      * @since JavaFX 2.2
 385      */
 386     public  double getMyx() {
 387         return 0.0;
 388     }
 389 
 390     /**
 391      * Gets the Y coordinate scaling element of the 3x4 matrix.
 392      *
 393      * @return the Y coordinate scaling element of the 3x4 matrix
 394      * @since JavaFX 2.2
 395      */
 396     public  double getMyy() {
 397         return 1.0;
 398     }
 399 
 400     /**
 401      * Gets the YZ coordinate element of the 3x4 matrix.
 402      *
 403      * @return the YZ coordinate element of the 3x4 matrix
 404      * @since JavaFX 2.2
 405      */
 406     public  double getMyz() {
 407         return 0.0;
 408     }
 409 
 410     /**
 411      * Gets the Y coordinate translation element of the 3x4 matrix.
 412      *
 413      * @return the Y coordinate translation element of the 3x4 matrix
 414      * @since JavaFX 2.2
 415      */
 416     public  double getTy() {
 417         return 0.0;
 418     }
 419 
 420     /**
 421      * Gets the ZX coordinate element of the 3x4 matrix.
 422      *
 423      * @return the ZX coordinate element of the 3x4 matrix
 424      * @since JavaFX 2.2
 425      */
 426     public  double getMzx() {
 427         return 0.0;
 428     }
 429 
 430     /**
 431      * Gets the ZY coordinate element of the 3x4 matrix.
 432      *
 433      * @return the ZY coordinate element of the 3x4 matrix
 434      * @since JavaFX 2.2
 435      */
 436     public  double getMzy() {
 437         return 0.0;
 438     }
 439 
 440     /**
 441      * Gets the Z coordinate scaling element of the 3x4 matrix.
 442      *
 443      * @return the Z coordinate scaling element of the 3x4 matrix
 444      * @since JavaFX 2.2
 445      */
 446     public  double getMzz() {
 447         return 1.0;
 448     }
 449 
 450     /**
 451      * Gets the Z coordinate translation element of the 3x4 matrix.
 452      *
 453      * @return the Z coordinate translation element of the 3x4 matrix
 454      * @since JavaFX 2.2
 455      */
 456     public  double getTz() {
 457         return 0.0;
 458     }
 459 
 460     /**
 461      * Gets the specified element of the transformation matrix.
 462      * @param type type of matrix to get the value from
 463      * @param row zero-based row number
 464      * @param column zero-based column number
 465      * @return value of the specified transformation matrix element
 466      * @throws IllegalArgumentException if a 2D matrix type is requested for
 467      *         a 3D transform
 468      * @throws IndexOutOfBoundsException if the indices are not within
 469      *         the specified matrix type
 470      * @throws NullPointerException if the specified {@code type} is null
 471      * @since JavaFX 8.0
 472      */
 473     public double getElement(MatrixType type, int row, int column) {
 474         if (row &lt; 0 || row &gt;= type.rows() || column &lt; 0 || column &gt;= type.columns()) {
 475             throw new IndexOutOfBoundsException(&quot;Index outside of affine &quot;
 476                     + &quot;matrix &quot; + type + &quot;: [&quot; + row + &quot;, &quot; + column + &quot;]&quot;);
 477         }
 478         switch(type) {
 479             case MT_2D_2x3:
 480                 // fall-through
 481             case MT_2D_3x3:
 482                 if (!isType2D()) {
 483                     throw new IllegalArgumentException(&quot;Cannot access 2D matrix &quot;
 484                             + &quot;of a 3D transform&quot;);
 485                 }
 486                 switch(row) {
 487                     case 0:
 488                         switch(column) {
 489                             case 0: return getMxx();
 490                             case 1: return getMxy();
 491                             case 2: return getTx();
 492                         }
 493                     case 1:
 494                         switch(column) {
 495                             case 0: return getMyx();
 496                             case 1: return getMyy();
 497                             case 2: return getTy();
 498                         }
 499                     case 2:
 500                         switch(column) {
 501                             case 0: return 0.0;
 502                             case 1: return 0.0;
 503                             case 2: return 1.0;
 504                         }
 505                 }
 506                 break;
 507             case MT_3D_3x4:
 508                 // fall-through
 509             case MT_3D_4x4:
 510                 switch(row) {
 511                     case 0:
 512                         switch(column) {
 513                             case 0: return getMxx();
 514                             case 1: return getMxy();
 515                             case 2: return getMxz();
 516                             case 3: return getTx();
 517                         }
 518                     case 1:
 519                         switch(column) {
 520                             case 0: return getMyx();
 521                             case 1: return getMyy();
 522                             case 2: return getMyz();
 523                             case 3: return getTy();
 524                         }
 525                     case 2:
 526                         switch(column) {
 527                             case 0: return getMzx();
 528                             case 1: return getMzy();
 529                             case 2: return getMzz();
 530                             case 3: return getTz();
 531                         }
 532                     case 3:
 533                         switch(column) {
 534                             case 0: return 0.0;
 535                             case 1: return 0.0;
 536                             case 2: return 0.0;
 537                             case 3: return 1.0;
 538                         }
 539                 }
 540                 break;
 541         }
 542         // cannot reach here
 543         throw new InternalError(&quot;Unsupported matrix type &quot; + type);
 544     }
 545 
 546     /* *************************************************************************
 547      *                                                                         *
 548      *                           State getters                                 *
 549      *                                                                         *
 550      **************************************************************************/
 551 
 552     /**
 553      * Computes if this transform is currently a 2D transform (has no effect
 554      * in the direction of Z axis).
 555      * Used by the subclasses to effectively provide value of the type2D
 556      * property.
 557      * @return true if this transform is currently 2D-only
 558      */
 559     boolean computeIs2D() {
 560         return getMxz() == 0.0 &amp;&amp; getMzx() == 0.0 &amp;&amp; getMzy() == 0.0 &amp;&amp;
 561                     getMzz() == 1.0 &amp;&amp; getTz() == 0.0;
 562     }
 563 
 564     /**
 565      * Computes if this transform is currently an identity (has
 566      * no effect in any direction).
 567      * Used by the subclasses to effectively provide value of the identity
 568      * property.
 569      * @return true if this transform is currently an identity transform
 570      */
 571     boolean computeIsIdentity() {
 572         return
 573             getMxx() == 1.0 &amp;&amp; getMxy() == 0.0 &amp;&amp; getMxz() == 0.0 &amp;&amp; getTx() == 0.0 &amp;&amp;
 574             getMyx() == 0.0 &amp;&amp; getMyy() == 1.0 &amp;&amp; getMyz() == 0.0 &amp;&amp; getTy() == 0.0 &amp;&amp;
 575             getMzx() == 0.0 &amp;&amp; getMzy() == 0.0 &amp;&amp; getMzz() == 1.0 &amp;&amp; getTz() == 0.0;
 576     }
 577 
 578     /**
 579      * Computes determinant of the transformation matrix.
 580      * Among other things, determinant can be used for testing this transform&#39;s
 581      * invertibility - it is invertible if determinant is not equal to zero.
 582      * @return Determinant of the transformation matrix
 583      * @since JavaFX 8.0
 584      */
 585     public double determinant() {
 586         final double myx = getMyx();
 587         final double myy = getMyy();
 588         final double myz = getMyz();
 589         final double mzx = getMzx();
 590         final double mzy = getMzy();
 591         final double mzz = getMzz();
 592 
 593         return (getMxx() * (myy * mzz - mzy * myz) +
 594                 getMxy() * (myz * mzx - mzz * myx) +
 595                 getMxz() * (myx * mzy - mzx * myy));
 596     }
 597 
 598     /**
 599      * Determines if this is currently a 2D transform.
 600      * Transform is 2D if it has no effect along the Z axis.
 601      * @since JavaFX 8.0
 602      */
 603     private LazyBooleanProperty type2D;
 604 
 605     public final boolean isType2D() {
 606         return type2D == null ? computeIs2D() : type2D.get();
 607     }
 608 
 609     public final ReadOnlyBooleanProperty type2DProperty() {
 610         if (type2D == null) {
 611             type2D = new LazyBooleanProperty() {
 612 
 613                 @Override
 614                 protected boolean computeValue() {
 615                     return computeIs2D();
 616                 }
 617 
 618                 @Override
 619                 public Object getBean() {
 620                     return Transform.this;
 621                 }
 622 
 623                 @Override
 624                 public String getName() {
 625                     return &quot;type2D&quot;;
 626                 }
 627             };
 628         }
 629         return type2D;
 630     }
 631 
 632     /**
 633      * Determines if this is currently an identity transform.
 634      * Identity transform has no effect on the transformed nodes.
 635      * @since JavaFX 8.0
 636      */
 637     private LazyBooleanProperty identity;
 638 
 639     public final boolean isIdentity() {
 640         return identity == null ? computeIsIdentity() : identity.get();
 641     }
 642 
 643     public final ReadOnlyBooleanProperty identityProperty() {
 644         if (identity == null) {
 645             identity = new LazyBooleanProperty() {
 646 
 647                 @Override
 648                 protected boolean computeValue() {
 649                     return computeIsIdentity();
 650                 }
 651 
 652                 @Override
 653                 public Object getBean() {
 654                     return Transform.this;
 655                 }
 656 
 657                 @Override
 658                 public String getName() {
 659                     return &quot;identity&quot;;
 660                 }
 661             };
 662         }
 663         return identity;
 664     }
 665 
 666     /**
 667      * Lazily computed read-only boolean property implementation.
 668      * Used for type2D and identity properties.
 669      */
 670     private static abstract class LazyBooleanProperty
 671             extends ReadOnlyBooleanProperty {
 672 
 673         private ExpressionHelper&lt;Boolean&gt; helper;
 674         private boolean valid;
 675         private boolean value;
 676 
 677         @Override
 678         public void addListener(InvalidationListener listener) {
 679             helper = ExpressionHelper.addListener(helper, this, listener);
 680         }
 681 
 682         @Override
 683         public void removeListener(InvalidationListener listener) {
 684             helper = ExpressionHelper.removeListener(helper, listener);
 685         }
 686 
 687         @Override
 688         public void addListener(ChangeListener&lt;? super Boolean&gt; listener) {
 689             helper = ExpressionHelper.addListener(helper, this, listener);
 690         }
 691 
 692         @Override
 693         public void removeListener(ChangeListener&lt;? super Boolean&gt; listener) {
 694             helper = ExpressionHelper.removeListener(helper, listener);
 695         }
 696 
 697         @Override
 698         public boolean get() {
 699             if (!valid) {
 700                 value = computeValue();
 701                 valid = true;
 702             }
 703 
 704             return value;
 705         }
 706 
 707         public void invalidate() {
 708             if (valid) {
 709                 valid = false;
 710                 ExpressionHelper.fireValueChangedEvent(helper);
 711             }
 712         }
 713 
 714         protected abstract boolean computeValue();
 715     }
 716 
 717     /**
 718      * Transforms the specified point by this transform and by the specified
 719      * transform and returns distance of the result points. Used for similarTo
 720      * method. Has to be used only for 2D transforms (otherwise throws an
 721      * exception).
 722      * @param t the other transform
 723      * @param x point&#39;s X coordinate
 724      * @param y point&#39;s Y coordinate
 725      * @return distance of the transformed points
 726      */
 727     private double transformDiff(Transform t, double x, double y) {
 728         final Point2D byThis = transform(x, y);
 729         final Point2D byOther = t.transform(x, y);
 730         return byThis.distance(byOther);
 731     }
 732 
 733     /**
 734      * Transforms the specified point by this transform and by the specified
 735      * transform and returns distance of the result points. Used for similarTo
 736      * method.
 737      * @param t the other transform
 738      * @param x point&#39;s X coordinate
 739      * @param y point&#39;s Y coordinate
 740      * @param z point&#39;s Z coordinate
 741      * @return distance of the transformed points
 742      */
 743     private double transformDiff(Transform t, double x, double y, double z) {
 744         final Point3D byThis = transform(x, y, z);
 745         final Point3D byOther = t.transform(x, y, z);
 746         return byThis.distance(byOther);
 747     }
 748 
 749     /**
 750      * Checks if this transform is similar to the specified transform.
 751      * The two transforms are considered similar if any point from
 752      * {@code range} is transformed by them to points that are no farther
 753      * than {@code maxDelta} from each other.
 754      * @param transform transform to be compared to this transform
 755      * @param range region of interest on which the two transforms are compared
 756      * @param maxDelta maximum allowed distance for the results of transforming
 757      *                 any single point from {@code range} by the two transforms
 758      * @return true if the transforms are similar according to the specified
 759      *              criteria
 760      * @throws NullPointerException if the specified {@code transform}
 761      *         or {@code range} is null
 762      * @since JavaFX 8.0
 763      */
 764     public boolean similarTo(Transform transform, Bounds range, double maxDelta) {
 765 
 766         double cornerX, cornerY, cornerZ;
 767 
 768         if (isType2D() &amp;&amp; transform.isType2D()) {
 769             cornerX = range.getMinX();
 770             cornerY = range.getMinY();
 771 
 772             if (transformDiff(transform, cornerX, cornerY) &gt; maxDelta) {
 773                 return false;
 774             }
 775 
 776             cornerY = range.getMaxY();
 777             if (transformDiff(transform, cornerX, cornerY) &gt; maxDelta) {
 778                 return false;
 779             }
 780 
 781             cornerX = range.getMaxX();
 782             cornerY = range.getMinY();
 783             if (transformDiff(transform, cornerX, cornerY) &gt; maxDelta) {
 784                 return false;
 785             }
 786 
 787             cornerY = range.getMaxY();
 788             if (transformDiff(transform, cornerX, cornerY) &gt; maxDelta) {
 789                 return false;
 790             }
 791 
 792             return true;
 793         }
 794 
 795         cornerX = range.getMinX();
 796         cornerY = range.getMinY();
 797         cornerZ = range.getMinZ();
 798         if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
 799             return false;
 800         }
 801 
 802         cornerY = range.getMaxY();
 803         if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
 804             return false;
 805         }
 806 
 807         cornerX = range.getMaxX();
 808         cornerY = range.getMinY();
 809         if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
 810             return false;
 811         }
 812 
 813         cornerY = range.getMaxY();
 814         if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
 815             return false;
 816         }
 817 
 818         if (range.getDepth() != 0.0) {
 819             cornerX = range.getMinX();
 820             cornerY = range.getMinY();
 821             cornerZ = range.getMaxZ();
 822             if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
 823                 return false;
 824             }
 825 
 826             cornerY = range.getMaxY();
 827             if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
 828                 return false;
 829             }
 830 
 831             cornerX = range.getMaxX();
 832             cornerY = range.getMinY();
 833             if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
 834                 return false;
 835             }
 836 
 837             cornerY = range.getMaxY();
 838             if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
 839                 return false;
 840             }
 841         }
 842 
 843         return true;
 844     }
 845 
 846     /* *************************************************************************
 847      *                                                                         *
 848      *                           Array getters                                 *
 849      *                                                                         *
 850      **************************************************************************/
 851 
 852     /**
 853      * Core of the toArray implementation for the 2D case.
 854      * All of the checks has been made by the enclosing method as well as
 855      * the constant elements filled, this method only fills the varying
 856      * elements to the array. Used by subclasses to fill
 857      * the elements efficiently.
 858      * @param array array to be filled with the 6 2D elements
 859      */
 860     void fill2DArray(double[] array) {
 861         array[0] = getMxx();
 862         array[1] = getMxy();
 863         array[2] = getTx();
 864         array[3] = getMyx();
 865         array[4] = getMyy();
 866         array[5] = getTy();
 867     }
 868 
 869     /**
 870      * Core of the toArray implementation for the 3D case.
 871      * All of the checks has been made by the enclosing method as well as
 872      * the constant elements filled, this method only fills the varying
 873      * elements to the array. Used by subclasses to fill
 874      * the elements efficiently.
 875      * @param array array to be filled with the 12 3D elements
 876      */
 877     void fill3DArray(double[] array) {
 878         array[0] = getMxx();
 879         array[1] = getMxy();
 880         array[2] = getMxz();
 881         array[3] = getTx();
 882         array[4] = getMyx();
 883         array[5] = getMyy();
 884         array[6] = getMyz();
 885         array[7] = getTy();
 886         array[8] = getMzx();
 887         array[9] = getMzy();
 888         array[10] = getMzz();
 889         array[11] = getTz();
 890     }
 891 
 892     /**
 893      * Returns an array containing the flattened transformation matrix.
 894      * If the requested matrix type fits in the specified array, it is returned
 895      * therein. Otherwise, a new array is created.
 896      * @param type matrix type to be filled in the array
 897      * @param array array into which the elements of the matrix are to be
 898      *              stored, if it is non-null and big enough; otherwise,
 899      *              a new array is created for this purpose.
 900      * @return an array containing the elements of the requested matrix type
 901      *         representing this transform
 902      * @throws IllegalArgumentException if a 2D matrix type is requested for
 903      *         a 3D transform
 904      * @throws NullPointerException if the specified {@code type} is null
 905      * @since JavaFX 8.0
 906      */
 907     public double[] toArray(MatrixType type, double[] array) {
 908         checkRequestedMAT(type);
 909 
 910         if (array == null || array.length &lt; type.elements()) {
 911             array = new double[type.elements()];
 912         }
 913 
 914         switch (type) {
 915             case MT_2D_3x3:
 916                 array[6] = 0.0;
 917                 array[7] = 0.0;
 918                 array[8] = 1.0;
 919                 // fall-through
 920             case MT_2D_2x3:
 921                 fill2DArray(array);
 922                 break;
 923             case MT_3D_4x4:
 924                 array[12] = 0.0;
 925                 array[13] = 0.0;
 926                 array[14] = 0.0;
 927                 array[15] = 1.0;
 928                 // fall-through
 929             case MT_3D_3x4:
 930                 fill3DArray(array);
 931                 break;
 932             default:
 933                 throw new InternalError(&quot;Unsupported matrix type &quot; + type);
 934         }
 935 
 936         return array;
 937     }
 938 
 939     /**
 940      * Returns an array containing the flattened transformation matrix.
 941      * @param type matrix type to be filled in the array
 942      * @return an array containing the elements of the requested matrix type
 943      *         representing this transform
 944      * @throws IllegalArgumentException if a 2D matrix type is requested for
 945      *         a 3D transform
 946      * @throws NullPointerException if the specified {@code type} is null
 947      * @since JavaFX 8.0
 948      */
 949     public double[] toArray(MatrixType type) {
 950         return toArray(type, null);
 951     }
 952 
 953     /**
 954      * Returns an array containing a row of the transformation matrix.
 955      * If the row of the requested matrix type fits in the specified array,
 956      * it is returned therein. Otherwise, a new array is created.
 957      * @param type matrix type whose row is to be filled in the array
 958      * @param row zero-based index of the row
 959      * @param array array into which the elements of the row are to be
 960      *              stored, if it is non-null and big enough; otherwise,
 961      *              a new array is created for this purpose.
 962      * @return an array containing the requested row of the requested matrix
 963      *         type representing this transform
 964      * @throws IllegalArgumentException if a 2D matrix type is requested for
 965      *         a 3D transform
 966      * @throws IndexOutOfBoundsException if the {@code row} index is not within
 967      *         the number of rows of the specified matrix type
 968      * @throws NullPointerException if the specified {@code type} is null
 969      * @since JavaFX 8.0
 970      */
 971     public double[] row(MatrixType type, int row, double[] array) {
 972 
 973         checkRequestedMAT(type);
 974 
 975         if (row &lt; 0 || row &gt;= type.rows()) {
 976             throw new IndexOutOfBoundsException(
 977                     &quot;Cannot get row &quot; + row + &quot; from &quot; + type);
 978         }
 979 
 980         if (array == null || array.length &lt; type.columns()) {
 981             array = new double[type.columns()];
 982         }
 983 
 984         switch(type) {
 985             case MT_2D_2x3:
 986             case MT_2D_3x3:
 987                 switch (row) {
 988                     case 0:
 989                         array[0] = getMxx();
 990                         array[1] = getMxy();
 991                         array[2] = getTx();
 992                         break;
 993                     case 1:
 994                         array[0] = getMyx();
 995                         array[1] = getMyy();
 996                         array[2] = getTy();
 997                         break;
 998                     case 2:
 999                         array[0] = 0.0;
1000                         array[1] = 0.0;
1001                         array[2] = 1.0;
1002                         break;
1003                 }
1004                 break;
1005             case MT_3D_3x4:
1006             case MT_3D_4x4:
1007                 switch (row) {
1008                     case 0:
1009                         array[0] = getMxx();
1010                         array[1] = getMxy();
1011                         array[2] = getMxz();
1012                         array[3] = getTx();
1013                         break;
1014                     case 1:
1015                         array[0] = getMyx();
1016                         array[1] = getMyy();
1017                         array[2] = getMyz();
1018                         array[3] = getTy();
1019                         break;
1020                     case 2:
1021                         array[0] = getMzx();
1022                         array[1] = getMzy();
1023                         array[2] = getMzz();
1024                         array[3] = getTz();
1025                         break;
1026                     case 3:
1027                         array[0] = 0.0;
1028                         array[1] = 0.0;
1029                         array[2] = 0.0;
1030                         array[3] = 1.0;
1031                         break;
1032                 }
1033                 break;
1034             default:
1035                 throw new InternalError(&quot;Unsupported row &quot; + row + &quot; of &quot; + type);
1036         }
1037         return array;
1038     }
1039 
1040     /**
1041      * Returns an array containing a row of the transformation matrix.
1042      * @param type matrix type whose row is to be filled in the array
1043      * @param row zero-based index of the row
1044      * @return an array containing the requested row of the requested matrix
1045      *         type representing this transform
1046      * @throws IllegalArgumentException if a 2D matrix type is requested for
1047      *         a 3D transform
1048      * @throws IndexOutOfBoundsException if the {@code row} index is not within
1049      *         the number of rows of the specified matrix type
1050      * @throws NullPointerException if the specified {@code type} is null
1051      * @since JavaFX 8.0
1052      */
1053     public double[] row(MatrixType type, int row) {
1054         return row(type, row, null);
1055     }
1056 
1057     /**
1058      * Returns an array containing a column of the transformation matrix.
1059      * If the column of the requested matrix type fits in the specified array,
1060      * it is returned therein. Otherwise, a new array is created.
1061      * @param type matrix type whose column is to be filled in the array
1062      * @param column zero-based index of the column
1063      * @param array array into which the elements of the column are to be
1064      *              stored, if it is non-null and big enough; otherwise,
1065      *              a new array is created for this purpose.
1066      * @return an array containing the requested column of the requested matrix
1067      *         type representing this transform
1068      * @throws IllegalArgumentException if a 2D matrix type is requested for
1069      *         a 3D transform
1070      * @throws IndexOutOfBoundsException if the {@code column} index
1071      *         is not within the number of columns of the specified matrix type
1072      * @throws NullPointerException if the specified {@code type} is null
1073      * @since JavaFX 8.0
1074      */
1075     public double[] column(MatrixType type, int column, double[] array) {
1076 
1077         checkRequestedMAT(type);
1078 
1079         if (column &lt; 0 || column &gt;= type.columns()) {
1080             throw new IndexOutOfBoundsException(
1081                     &quot;Cannot get row &quot; + column + &quot; from &quot; + type);
1082         }
1083 
1084         if (array == null || array.length &lt; type.rows()) {
1085             array = new double[type.rows()];
1086         }
1087 
1088         switch(type) {
1089             case MT_2D_2x3:
1090                 switch (column) {
1091                     case 0:
1092                         array[0] = getMxx();
1093                         array[1] = getMyx();
1094                         break;
1095                     case 1:
1096                         array[0] = getMxy();
1097                         array[1] = getMyy();
1098                         break;
1099                     case 2:
1100                         array[0] = getTx();
1101                         array[1] = getTy();
1102                         break;
1103                 }
1104                 break;
1105             case MT_2D_3x3:
1106                 switch (column) {
1107                     case 0:
1108                         array[0] = getMxx();
1109                         array[1] = getMyx();
1110                         array[2] = 0.0;
1111                         break;
1112                     case 1:
1113                         array[0] = getMxy();
1114                         array[1] = getMyy();
1115                         array[2] = 0.0;
1116                         break;
1117                     case 2:
1118                         array[0] = getTx();
1119                         array[1] = getTy();
1120                         array[2] = 1.0;
1121                         break;
1122                 }
1123                 break;
1124             case MT_3D_3x4:
1125                 switch (column) {
1126                     case 0:
1127                         array[0] = getMxx();
1128                         array[1] = getMyx();
1129                         array[2] = getMzx();
1130                         break;
1131                     case 1:
1132                         array[0] = getMxy();
1133                         array[1] = getMyy();
1134                         array[2] = getMzy();
1135                         break;
1136                     case 2:
1137                         array[0] = getMxz();
1138                         array[1] = getMyz();
1139                         array[2] = getMzz();
1140                         break;
1141                     case 3:
1142                         array[0] = getTx();
1143                         array[1] = getTy();
1144                         array[2] = getTz();
1145                         break;
1146                 }
1147                 break;
1148             case MT_3D_4x4:
1149                 switch (column) {
1150                     case 0:
1151                         array[0] = getMxx();
1152                         array[1] = getMyx();
1153                         array[2] = getMzx();
1154                         array[3] = 0.0;
1155                         break;
1156                     case 1:
1157                         array[0] = getMxy();
1158                         array[1] = getMyy();
1159                         array[2] = getMzy();
1160                         array[3] = 0.0;
1161                         break;
1162                     case 2:
1163                         array[0] = getMxz();
1164                         array[1] = getMyz();
1165                         array[2] = getMzz();
1166                         array[3] = 0.0;
1167                         break;
1168                     case 3:
1169                         array[0] = getTx();
1170                         array[1] = getTy();
1171                         array[2] = getTz();
1172                         array[3] = 1.0;
1173                         break;
1174                 }
1175                 break;
1176             default:
1177                 throw new InternalError(&quot;Unsupported column &quot; + column + &quot; of &quot;
1178                         + type);
1179         }
1180         return array;
1181     }
1182 
1183     /**
1184      * Returns an array containing a column of the transformation matrix.
1185      * @param type matrix type whose column is to be filled in the array
1186      * @param column zero-based index of the column
1187      * @return an array containing the requested column of the requested matrix
1188      *         type representing this transform
1189      * @throws IllegalArgumentException if a 2D matrix type is requested for
1190      *         a 3D transform
1191      * @throws IndexOutOfBoundsException if the {@code column} index
1192      *         is not within the number of columns of the specified matrix type
1193      * @throws NullPointerException if the specified {@code type} is null
1194      * @since JavaFX 8.0
1195      */
1196     public double[] column(MatrixType type, int column) {
1197         return column(type, column, null);
1198     }
1199 
1200     /* *************************************************************************
1201      *                                                                         *
1202      *                         Transform creators                              *
1203      *                                                                         *
1204      **************************************************************************/
1205 
1206     /**
1207      * Returns the concatenation of this transform and the specified transform.
1208      * Applying the resulting transform to a node has the same effect as
1209      * adding the two transforms to its {@code getTransforms()} list,
1210      * {@code this} transform first and the specified {@code transform} second.
1211      * @param transform transform to be concatenated with this transform
1212      * @return The concatenated transform
1213      * @throws NullPointerException if the specified {@code transform} is null
1214      * @since JavaFX 8.0
1215      */
1216     public Transform createConcatenation(Transform transform) {
1217         final double txx = transform.getMxx();
1218         final double txy = transform.getMxy();
1219         final double txz = transform.getMxz();
1220         final double ttx = transform.getTx();
1221         final double tyx = transform.getMyx();
1222         final double tyy = transform.getMyy();
1223         final double tyz = transform.getMyz();
1224         final double tty = transform.getTy();
1225         final double tzx = transform.getMzx();
1226         final double tzy = transform.getMzy();
1227         final double tzz = transform.getMzz();
1228         final double ttz = transform.getTz();
1229         return new Affine(
1230             (getMxx() * txx + getMxy() * tyx + getMxz() * tzx),
1231             (getMxx() * txy + getMxy() * tyy + getMxz() * tzy),
1232             (getMxx() * txz + getMxy() * tyz + getMxz() * tzz),
1233             (getMxx() * ttx + getMxy() * tty + getMxz() * ttz + getTx()),
1234             (getMyx() * txx + getMyy() * tyx + getMyz() * tzx),
1235             (getMyx() * txy + getMyy() * tyy + getMyz() * tzy),
1236             (getMyx() * txz + getMyy() * tyz + getMyz() * tzz),
1237             (getMyx() * ttx + getMyy() * tty + getMyz() * ttz + getTy()),
1238             (getMzx() * txx + getMzy() * tyx + getMzz() * tzx),
1239             (getMzx() * txy + getMzy() * tyy + getMzz() * tzy),
1240             (getMzx() * txz + getMzy() * tyz + getMzz() * tzz),
1241             (getMzx() * ttx + getMzy() * tty + getMzz() * ttz + getTz()));
1242     }
1243 
1244     /**
1245      * Returns the inverse transform of this transform.
1246      * @return the inverse transform
1247      * @throws NonInvertibleTransformException if this transform
1248      *         cannot be inverted
1249      * @since JavaFX 8.0
1250      */
1251     public Transform createInverse() throws NonInvertibleTransformException {
1252         return getInverseCache().clone();
1253     }
1254 
1255     /**
1256      * Returns a deep copy of this transform.
1257      * @return a copy of this transform
1258      * @since JavaFX 8.0
1259      */
1260     @Override
1261     public Transform clone() {
1262         return TransformUtils.immutableTransform(this);
1263     }
1264 
1265     /* *************************************************************************
1266      *                                                                         *
1267      *                     Transform, Inverse Transform                        *
1268      *                                                                         *
1269      **************************************************************************/
1270 
1271     /**
1272      * Transforms the specified point by this transform.
1273      * This method can be used only for 2D transforms.
1274      * @param x the X coordinate of the point
1275      * @param y the Y coordinate of the point
1276      * @return the transformed point
1277      * @throws IllegalStateException if this is a 3D transform
1278      * @since JavaFX 8.0
1279      */
1280     public Point2D transform(double x, double y) {
1281         ensureCanTransform2DPoint();
1282 
1283         return new Point2D(
1284             getMxx() * x + getMxy() * y + getTx(),
1285             getMyx() * x + getMyy() * y + getTy());
1286     }
1287 
1288     /**
1289      * Transforms the specified point by this transform.
1290      * This method can be used only for 2D transforms.
1291      * @param point the point to be transformed
1292      * @return the transformed point
1293      * @throws IllegalStateException if this is a 3D transform
1294      * @throws NullPointerException if the specified {@code point} is null
1295      * @since JavaFX 8.0
1296      */
1297     public Point2D transform(Point2D point) {
1298         return transform(point.getX(), point.getY());
1299     }
1300 
1301     /**
1302      * Transforms the specified point by this transform.
1303      * @param x the X coordinate of the point
1304      * @param y the Y coordinate of the point
1305      * @param z the Z coordinate of the point
1306      * @return the transformed point
1307      * @since JavaFX 8.0
1308      */
1309     public Point3D transform(double x, double y, double z) {
1310         return new Point3D(
1311             getMxx() * x + getMxy() * y + getMxz() * z + getTx(),
1312             getMyx() * x + getMyy() * y + getMyz() * z + getTy(),
1313             getMzx() * x + getMzy() * y + getMzz() * z + getTz());
1314     }
1315 
1316     /**
1317      * Transforms the specified point by this transform.
1318      * @param point the point to be transformed
1319      * @return the transformed point
1320      * @throws NullPointerException if the specified {@code point} is null
1321      * @since JavaFX 8.0
1322      */
1323     public Point3D transform(Point3D point) {
1324         return transform(point.getX(), point.getY(), point.getZ());
1325     }
1326 
1327     /**
1328      * Transforms the specified bounds by this transform.
1329      * @param bounds the bounds to be transformed
1330      * @return the transformed bounds
1331      * @since JavaFX 8.0
1332      */
1333     public Bounds transform(Bounds bounds) {
1334         if (isType2D() &amp;&amp; (bounds.getMinZ() == 0) &amp;&amp; (bounds.getMaxZ() == 0)) {
1335             Point2D p1 = transform(bounds.getMinX(), bounds.getMinY());
1336             Point2D p2 = transform(bounds.getMaxX(), bounds.getMinY());
1337             Point2D p3 = transform(bounds.getMaxX(), bounds.getMaxY());
1338             Point2D p4 = transform(bounds.getMinX(), bounds.getMaxY());
1339 
1340             return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
1341         }
1342         Point3D p1 = transform(bounds.getMinX(), bounds.getMinY(), bounds.getMinZ());
1343         Point3D p2 = transform(bounds.getMinX(), bounds.getMinY(), bounds.getMaxZ());
1344         Point3D p3 = transform(bounds.getMinX(), bounds.getMaxY(), bounds.getMinZ());
1345         Point3D p4 = transform(bounds.getMinX(), bounds.getMaxY(), bounds.getMaxZ());
1346         Point3D p5 = transform(bounds.getMaxX(), bounds.getMaxY(), bounds.getMinZ());
1347         Point3D p6 = transform(bounds.getMaxX(), bounds.getMaxY(), bounds.getMaxZ());
1348         Point3D p7 = transform(bounds.getMaxX(), bounds.getMinY(), bounds.getMinZ());
1349         Point3D p8 = transform(bounds.getMaxX(), bounds.getMinY(), bounds.getMaxZ());
1350 
1351         return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
1352     }
1353 
1354     /**
1355      * Core of the transform2DPoints method.
1356      * All the checks has been performed and the care of the overlaps has been
1357      * taken by the enclosing method, this method only transforms the points
1358      * and fills them to the array. Used by the subclasses to perform
1359      * the transform efficiently.
1360      */
1361     void transform2DPointsImpl(double[] srcPts, int srcOff,
1362             double[] dstPts, int dstOff, int numPts) {
1363         final double xx = getMxx();
1364         final double xy = getMxy();
1365         final double tx = getTx();
1366         final double yx = getMyx();
1367         final double yy = getMyy();
1368         final double ty = getTy();
1369 
1370         while (--numPts &gt;= 0) {
1371             final double x = srcPts[srcOff++];
1372             final double y = srcPts[srcOff++];
1373 
1374             dstPts[dstOff++] = xx * x + xy * y + tx;
1375             dstPts[dstOff++] = yx * x + yy * y + ty;
1376         }
1377     }
1378 
1379     /**
1380      * Core of the transform3DPoints method.
1381      * All the checks has been performed and the care of the overlaps has been
1382      * taken by the enclosing method, this method only transforms the points
1383      * and fills them to the array. Used by the subclasses to perform
1384      * the transform efficiently.
1385      */
1386     void transform3DPointsImpl(double[] srcPts, int srcOff,
1387             double[] dstPts, int dstOff, int numPts) {
1388 
1389         final double xx = getMxx();
1390         final double xy = getMxy();
1391         final double xz = getMxz();
1392         final double tx = getTx();
1393         final double yx = getMyx();
1394         final double yy = getMyy();
1395         final double yz = getMyz();
1396         final double ty = getTy();
1397         final double zx = getMzx();
1398         final double zy = getMzy();
1399         final double zz = getMzz();
1400         final double tz = getTz();
1401 
1402         while (--numPts &gt;= 0) {
1403             final double x = srcPts[srcOff++];
1404             final double y = srcPts[srcOff++];
1405             final double z = srcPts[srcOff++];
1406 
1407             dstPts[dstOff++] = xx * x + xy * y + xz * z + tx;
1408             dstPts[dstOff++] = yx * x + yy * y + yz * z + ty;
1409             dstPts[dstOff++] = zx * x + zy * y + zz * z + tz;
1410         }
1411     }
1412 
1413     /**
1414      * Transforms an array of coordinates by this transform.
1415      * The two coordinate array sections can be exactly the same or
1416      * can be overlapping sections of the same array without affecting the
1417      * validity of the results.
1418      * This method ensures that no source coordinates are overwritten by a
1419      * previous operation before they can be transformed.
1420      * The coordinates are stored in the arrays starting at the specified
1421      * offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.
1422      * This method can be used only for 2D transforms.
1423      * @param srcPts the array containing the source point coordinates.
1424      * Each point is stored as a pair of x,&amp;nbsp;y coordinates.
1425      * @param srcOff the offset to the first point to be transformed
1426      * in the source array
1427      * @param dstPts the array into which the transformed point coordinates
1428      * are returned.  Each point is stored as a pair of x,&amp;nbsp;y
1429      * coordinates.
1430      * @param dstOff the offset to the location of the first
1431      * transformed point that is stored in the destination array
1432      * @param numPts the number of points to be transformed
1433      * @throws IllegalStateException if this is a 3D transform
1434      * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null
1435      * @since JavaFX 8.0
1436      */
1437     public void transform2DPoints(double[] srcPts, int srcOff,
1438                           double[] dstPts, int dstOff,
1439                           int numPts) {
1440 
1441         if (srcPts == null || dstPts == null) {
1442             throw new NullPointerException();
1443         }
1444 
1445         if (!isType2D()) {
1446             throw new IllegalStateException(&quot;Cannot transform 2D points &quot;
1447                     + &quot;with a 3D transform&quot;);
1448         }
1449 
1450         // deal with overlapping arrays
1451         srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 2);
1452 
1453         // do the transformations
1454         transform2DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);
1455     }
1456 
1457     /**
1458      * Transforms an array of floating point coordinates by this transform.
1459      * The three coordinate array sections can be exactly the same or
1460      * can be overlapping sections of the same array without affecting the
1461      * validity of the results.
1462      * This method ensures that no source coordinates are overwritten by a
1463      * previous operation before they can be transformed.
1464      * The coordinates are stored in the arrays starting at the specified
1465      * offset in the order &lt;code&gt;[x0, y0, z0, x1, y1, z1, ..., xn, yn, zn]&lt;/code&gt;.
1466      * @param srcPts the array containing the source point coordinates.
1467      * Each point is stored as a tiplet of x,&amp;nbsp;y,&amp;nbsp;z coordinates.
1468      * @param srcOff the offset to the first point to be transformed
1469      * in the source array
1470      * @param dstPts the array into which the transformed point coordinates
1471      * are returned.  Each point is stored as a triplet of x,&amp;nbsp;y,&amp;nbsp;z
1472      * coordinates.
1473      * @param dstOff the offset to the location of the first
1474      * transformed point that is stored in the destination array
1475      * @param numPts the number of points to be transformed
1476      * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null
1477      * @since JavaFX 8.0
1478      */
1479     public void transform3DPoints(double[] srcPts, int srcOff,
1480                           double[] dstPts, int dstOff,
1481                           int numPts) {
1482 
1483         if (srcPts == null || dstPts == null) {
1484             throw new NullPointerException();
1485         }
1486 
1487         // deal with overlapping arrays
1488         srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 3);
1489 
1490         // do the transformations
1491         transform3DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);
1492     }
1493 
1494     /**
1495      * Transforms the relative magnitude vector by this transform.
1496      * The vector is transformed without applying the translation components
1497      * of the affine transformation matrix.
1498      * This method can be used only for a 2D transform.
1499      * @param x vector magnitude in the direction of the X axis
1500      * @param y vector magnitude in the direction of the Y axis
1501      * @return the transformed relative magnitude vector represented
1502      *         by a {@code Point2D} instance
1503      * @throws IllegalStateException if this is a 3D transform
1504      * @since JavaFX 8.0
1505      */
1506     public Point2D deltaTransform(double x, double y) {
1507         ensureCanTransform2DPoint();
1508 
1509         return new Point2D(
1510             getMxx() * x + getMxy() * y,
1511             getMyx() * x + getMyy() * y);
1512     }
1513 
1514     /**
1515      * Transforms the relative magnitude vector represented by the specified
1516      * {@code Point2D} instance by this transform.
1517      * The vector is transformed without applying the translation components
1518      * of the affine transformation matrix.
1519      * This method can be used only for a 2D transform.
1520      * @param point the relative magnitude vector
1521      * @return the transformed relative magnitude vector represented
1522      *         by a {@code Point2D} instance
1523      * @throws IllegalStateException if this is a 3D transform
1524      * @throws NullPointerException if the specified {@code point} is null
1525      * @since JavaFX 8.0
1526      */
1527     public Point2D deltaTransform(Point2D point) {
1528         return deltaTransform(point.getX(), point.getY());
1529     }
1530 
1531     /**
1532      * Transforms the relative magnitude vector by this transform.
1533      * The vector is transformed without applying the translation components
1534      * of the affine transformation matrix.
1535      * @param x vector magnitude in the direction of the X axis
1536      * @param y vector magnitude in the direction of the Y axis
1537      * @param z vector magnitude in the direction of the Z axis
1538      * @return the transformed relative magnitude vector represented
1539      *         by a {@code Point3D} instance
1540      * @since JavaFX 8.0
1541      */
1542     public Point3D deltaTransform(double x, double y, double z) {
1543         return new Point3D(
1544             getMxx() * x + getMxy() * y + getMxz() * z,
1545             getMyx() * x + getMyy() * y + getMyz() * z,
1546             getMzx() * x + getMzy() * y + getMzz() * z);
1547     }
1548 
1549     /**
1550      * Transforms the relative magnitude vector represented by the specified
1551      * {@code Point3D} instance by this transform.
1552      * The vector is transformed without applying the translation components
1553      * of the affine transformation matrix.
1554      * @param point the relative magnitude vector
1555      * @return the transformed relative magnitude vector represented
1556      *         by a {@code Point3D} instance
1557      * @throws NullPointerException if the specified {@code point} is null
1558      * @since JavaFX 8.0
1559      */
1560     public Point3D deltaTransform(Point3D point) {
1561         return deltaTransform(point.getX(), point.getY(), point.getZ());
1562     }
1563 
1564     /**
1565      * Transforms the specified point by the inverse of this transform.
1566      * This method can be used only for 2D transforms.
1567      * @param x the X coordinate of the point
1568      * @param y the Y coordinate of the point
1569      * @return the inversely transformed point
1570      * @throws IllegalStateException if this is a 3D transform
1571      * @throws NonInvertibleTransformException if this transform
1572      *         cannot be inverted
1573      * @since JavaFX 8.0
1574      */
1575     public Point2D inverseTransform(double x, double y)
1576             throws NonInvertibleTransformException {
1577 
1578         ensureCanTransform2DPoint();
1579 
1580         return getInverseCache().transform(x, y);
1581     }
1582 
1583     /**
1584      * Transforms the specified point by the inverse of this transform.
1585      * This method can be used only for 2D transforms.
1586      * @param point the point to be transformed
1587      * @return the inversely transformed point
1588      * @throws IllegalStateException if this is a 3D transform
1589      * @throws NonInvertibleTransformException if this transform
1590      *         cannot be inverted
1591      * @throws NullPointerException if the specified {@code point} is null
1592      * @since JavaFX 8.0
1593      */
1594     public Point2D inverseTransform(Point2D point)
1595             throws NonInvertibleTransformException {
1596         return inverseTransform(point.getX(), point.getY());
1597     }
1598 
1599     /**
1600      * Transforms the specified point by the inverse of this transform.
1601      * @param x the X coordinate of the point
1602      * @param y the Y coordinate of the point
1603      * @param z the Z coordinate of the point
1604      * @return the inversely transformed point
1605      * @throws NonInvertibleTransformException if this transform
1606      *         cannot be inverted
1607      * @since JavaFX 8.0
1608      */
1609     public Point3D inverseTransform(double x, double y, double z)
1610             throws NonInvertibleTransformException {
1611 
1612         return getInverseCache().transform(x, y, z);
1613     }
1614 
1615     /**
1616      * Transforms the specified point by the inverse of this transform.
1617      * @param point the point to be transformed
1618      * @return the inversely transformed point
1619      * @throws NonInvertibleTransformException if this transform
1620      *         cannot be inverted
1621      * @throws NullPointerException if the specified {@code point} is null
1622      * @since JavaFX 8.0
1623      */
1624     public Point3D inverseTransform(Point3D point)
1625             throws NonInvertibleTransformException {
1626         return inverseTransform(point.getX(), point.getY(), point.getZ());
1627     }
1628 
1629     /**
1630      * Transforms the specified bounds by the inverse of this transform.
1631      * @param bounds the bounds to be transformed
1632      * @return the inversely transformed bounds
1633      * @throws NonInvertibleTransformException if this transform
1634      *         cannot be inverted
1635      * @throws NullPointerException if the specified {@code bounds} is null
1636      * @since JavaFX 8.0
1637      */
1638     public Bounds inverseTransform(Bounds bounds)
1639             throws NonInvertibleTransformException {
1640         if (isType2D() &amp;&amp; (bounds.getMinZ() == 0) &amp;&amp; (bounds.getMaxZ() == 0)) {
1641             Point2D p1 = inverseTransform(bounds.getMinX(), bounds.getMinY());
1642             Point2D p2 = inverseTransform(bounds.getMaxX(), bounds.getMinY());
1643             Point2D p3 = inverseTransform(bounds.getMaxX(), bounds.getMaxY());
1644             Point2D p4 = inverseTransform(bounds.getMinX(), bounds.getMaxY());
1645 
1646             return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
1647         }
1648         Point3D p1 = inverseTransform(bounds.getMinX(), bounds.getMinY(), bounds.getMinZ());
1649         Point3D p2 = inverseTransform(bounds.getMinX(), bounds.getMinY(), bounds.getMaxZ());
1650         Point3D p3 = inverseTransform(bounds.getMinX(), bounds.getMaxY(), bounds.getMinZ());
1651         Point3D p4 = inverseTransform(bounds.getMinX(), bounds.getMaxY(), bounds.getMaxZ());
1652         Point3D p5 = inverseTransform(bounds.getMaxX(), bounds.getMaxY(), bounds.getMinZ());
1653         Point3D p6 = inverseTransform(bounds.getMaxX(), bounds.getMaxY(), bounds.getMaxZ());
1654         Point3D p7 = inverseTransform(bounds.getMaxX(), bounds.getMinY(), bounds.getMinZ());
1655         Point3D p8 = inverseTransform(bounds.getMaxX(), bounds.getMinY(), bounds.getMaxZ());
1656 
1657         return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
1658 
1659     }
1660 
1661     /**
1662      * Core of the inverseTransform2DPoints method.
1663      * All the checks has been performed and the care of the overlaps has been
1664      * taken by the enclosing method, this method only transforms the points
1665      * and fills them to the array. Used by the subclasses to perform
1666      * the transform efficiently.
1667      */
1668     void inverseTransform2DPointsImpl(double[] srcPts, int srcOff,
1669             double[] dstPts, int dstOff, int numPts)
1670             throws NonInvertibleTransformException {
1671 
1672         getInverseCache().transform2DPointsImpl(srcPts, srcOff,
1673                 dstPts, dstOff, numPts);
1674     }
1675 
1676     /**
1677      * Core of the inverseTransform3DPoints method.
1678      * All the checks has been performed and the care of the overlaps has been
1679      * taken by the enclosing method, this method only transforms the points
1680      * and fills them to the array. Used by the subclasses to perform
1681      * the transform efficiently.
1682      */
1683     void inverseTransform3DPointsImpl(double[] srcPts, int srcOff,
1684             double[] dstPts, int dstOff, int numPts)
1685             throws NonInvertibleTransformException {
1686 
1687         getInverseCache().transform3DPointsImpl(srcPts, srcOff,
1688                 dstPts, dstOff, numPts);
1689     }
1690 
1691     /**
1692      * Transforms an array of coordinates by the inverse of this transform.
1693      * The two coordinate array sections can be exactly the same or
1694      * can be overlapping sections of the same array without affecting the
1695      * validity of the results.
1696      * This method ensures that no source coordinates are overwritten by a
1697      * previous operation before they can be transformed.
1698      * The coordinates are stored in the arrays starting at the specified
1699      * offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.
1700      * This method can be used only for 2D transforms.
1701      * @param srcPts the array containing the source point coordinates.
1702      * Each point is stored as a pair of x,&amp;nbsp;y coordinates.
1703      * @param srcOff the offset to the first point to be transformed
1704      * in the source array
1705      * @param dstPts the array into which the transformed point coordinates
1706      * are returned.  Each point is stored as a pair of x,&amp;nbsp;y
1707      * coordinates.
1708      * @param dstOff the offset to the location of the first
1709      * transformed point that is stored in the destination array
1710      * @param numPts the number of points to be transformed
1711      * @throws IllegalStateException if this is a 3D transform
1712      * @throws NonInvertibleTransformException if this transform
1713      *         cannot be inverted
1714      * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null
1715      * @since JavaFX 8.0
1716      */
1717     public void inverseTransform2DPoints(double[] srcPts, int srcOff,
1718                           double[] dstPts, int dstOff,
1719                           int numPts) throws NonInvertibleTransformException{
1720 
1721         if (srcPts == null || dstPts == null) {
1722             throw new NullPointerException();
1723         }
1724 
1725         if (!isType2D()) {
1726             throw new IllegalStateException(&quot;Cannot transform 2D points &quot;
1727                     + &quot;with a 3D transform&quot;);
1728         }
1729 
1730         // deal with overlapping arrays
1731         srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 2);
1732 
1733         // do the transformations
1734         inverseTransform2DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);
1735     }
1736 
1737     /**
1738      * Transforms an array of floating point coordinates by the inverse
1739      * of this transform.
1740      * The three coordinate array sections can be exactly the same or
1741      * can be overlapping sections of the same array without affecting the
1742      * validity of the results.
1743      * This method ensures that no source coordinates are overwritten by a
1744      * previous operation before they can be transformed.
1745      * The coordinates are stored in the arrays starting at the specified
1746      * offset in the order &lt;code&gt;[x0, y0, z0, x1, y1, z1, ..., xn, yn, zn]&lt;/code&gt;.
1747      * @param srcPts the array containing the source point coordinates.
1748      * Each point is stored as a triplet of x,&amp;nbsp;y,&amp;nbsp;z coordinates.
1749      * @param srcOff the offset to the first point to be transformed
1750      * in the source array
1751      * @param dstPts the array into which the transformed point coordinates
1752      * are returned.  Each point is stored as a triplet of x,&amp;nbsp;y,&amp;nbsp;z
1753      * coordinates.
1754      * @param dstOff the offset to the location of the first
1755      * transformed point that is stored in the destination array
1756      * @param numPts the number of points to be transformed
1757      * @throws NonInvertibleTransformException if this transform
1758      *         cannot be inverted
1759      * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null
1760      * @since JavaFX 8.0
1761      */
1762     public void inverseTransform3DPoints(double[] srcPts, int srcOff,
1763                           double[] dstPts, int dstOff,
1764                           int numPts) throws NonInvertibleTransformException {
1765 
1766         if (srcPts == null || dstPts == null) {
1767             throw new NullPointerException();
1768         }
1769 
1770         // deal with overlapping arrays
1771         srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 3);
1772 
1773         // do the transformations
1774         inverseTransform3DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);
1775     }
1776 
1777     /**
1778      * Transforms the relative magnitude vector by the inverse of this transform.
1779      * The vector is transformed without applying the translation components
1780      * of the affine transformation matrix.
1781      * This method can be used only for a 2D transform.
1782      * @param x vector magnitude in the direction of the X axis
1783      * @param y vector magnitude in the direction of the Y axis
1784      * @return the inversely transformed relative magnitude vector represented
1785      *         by a {@code Point2D} instance
1786      * @throws IllegalStateException if this is a 3D transform
1787      * @throws NonInvertibleTransformException if this transform
1788      *         cannot be inverted
1789      * @since JavaFX 8.0
1790      */
1791     public Point2D inverseDeltaTransform(double x, double y)
1792             throws NonInvertibleTransformException {
1793 
1794         ensureCanTransform2DPoint();
1795 
1796         return getInverseCache().deltaTransform(x, y);
1797     }
1798 
1799     /**
1800      * Transforms the relative magnitude vector represented by the specified
1801      * {@code Point2D} instance by the inverse of this transform.
1802      * The vector is transformed without applying the translation components
1803      * of the affine transformation matrix.
1804      * This method can be used only for a 2D transform.
1805      * @param point the relative magnitude vector
1806      * @return the inversely transformed relative magnitude vector represented
1807      *         by a {@code Point2D} instance
1808      * @throws IllegalStateException if this is a 3D transform
1809      * @throws NonInvertibleTransformException if this transform
1810      *         cannot be inverted
1811      * @throws NullPointerException if the specified {@code point} is null
1812      * @since JavaFX 8.0
1813      */
1814     public Point2D inverseDeltaTransform(Point2D point)
1815             throws NonInvertibleTransformException {
1816         return inverseDeltaTransform(point.getX(), point.getY());
1817     }
1818 
1819     /**
1820      * Transforms the relative magnitude vector by the inverse of this transform.
1821      * The vector is transformed without applying the translation components
1822      * of the affine transformation matrix.
1823      * @param x vector magnitude in the direction of the X axis
1824      * @param y vector magnitude in the direction of the Y axis
1825      * @param z vector magnitude in the direction of the Z axis
1826      * @return the inversely transformed relative magnitude vector represented
1827      *         by a {@code Point3D} instance
1828      * @throws NonInvertibleTransformException if this transform
1829      *         cannot be inverted
1830      * @since JavaFX 8.0
1831      */
1832     public Point3D inverseDeltaTransform(double x, double y, double z)
1833             throws NonInvertibleTransformException {
1834 
1835         return getInverseCache().deltaTransform(x, y, z);
1836     }
1837 
1838     /**
1839      * Transforms the relative magnitude vector represented by the specified
1840      * {@code Point3D} instance by the inverse of this transform.
1841      * The vector is transformed without applying the translation components
1842      * of the affine transformation matrix.
1843      * @param point the relative magnitude vector
1844      * @return the inversely transformed relative magnitude vector represented
1845      *         by a {@code Point3D} instance
1846      * @throws NonInvertibleTransformException if this transform
1847      *         cannot be inverted
1848      * @throws NullPointerException if the specified {@code point} is null
1849      * @since JavaFX 8.0
1850      */
1851     public Point3D inverseDeltaTransform(Point3D point)
1852             throws NonInvertibleTransformException {
1853         return inverseDeltaTransform(point.getX(), point.getY(), point.getZ());
1854     }
1855 
1856     /**
1857      * Helper method for transforming arrays of points that deals with
1858      * overlapping arrays.
1859      * @return the (if necessary fixed) srcOff
1860      */
1861     private int getFixedSrcOffset(double[] srcPts, int srcOff,
1862             double[] dstPts, int dstOff,
1863             int numPts, int dimensions) {
1864 
1865         if (dstPts == srcPts &amp;&amp;
1866             dstOff &gt; srcOff &amp;&amp; dstOff &lt; srcOff + numPts * dimensions)
1867         {
1868             // If the arrays overlap partially with the destination higher
1869             // than the source and we transform the coordinates normally
1870             // we would overwrite some of the later source coordinates
1871             // with results of previous transformations.
1872             // To get around this we use arraycopy to copy the points
1873             // to their final destination with correct overwrite
1874             // handling and then transform them in place in the new
1875             // safer location.
1876             System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * dimensions);
1877             return dstOff;
1878         }
1879 
1880         return srcOff;
1881     }
1882 
1883     /* *************************************************************************
1884      *                                                                         *
1885      *                         Event Dispatch                                  *
1886      *                                                                         *
1887      **************************************************************************/
1888 
1889     private EventHandlerManager internalEventDispatcher;
1890     private EventHandlerManager getInternalEventDispatcher() {
1891         if (internalEventDispatcher == null) {
1892             internalEventDispatcher = new EventHandlerManager(this);
1893         }
1894         return internalEventDispatcher;
1895     }
1896     private ObjectProperty&lt;EventHandler&lt;? super TransformChangedEvent&gt;&gt;
1897             onTransformChanged;
1898 
1899     @Override
1900     public EventDispatchChain buildEventDispatchChain(EventDispatchChain tail) {
1901         return internalEventDispatcher == null
1902                 ? tail : tail.append(getInternalEventDispatcher());
1903     }
1904 
1905     /**
1906      * &lt;p&gt;
1907      * Registers an event handler to this transform. Any event filters are first
1908      * processed, then the specified onFoo event handlers, and finally any
1909      * event handlers registered by this method.
1910      * &lt;/p&gt;&lt;p&gt;
1911      * Currently the only event delivered to a {@code Transform} is the
1912      * {@code TransformChangedEvent} with it&#39;s single type
1913      * {@code TRANSFORM_CHANGED}.
1914      * &lt;/p&gt;
1915      *
1916      * @param &lt;T&gt; the specific event class of the handler
1917      * @param eventType the type of the events to receive by the handler
1918      * @param eventHandler the handler to register
1919      * @throws NullPointerException if the event type or handler is null
1920      * @since JavaFX 8.0
1921      */
1922     public final &lt;T extends Event&gt; void addEventHandler(
1923             final EventType&lt;T&gt; eventType,
1924             final EventHandler&lt;? super T&gt; eventHandler) {
1925         getInternalEventDispatcher()
1926                 .addEventHandler(eventType, eventHandler);
1927         // need to validate all properties to get the change events
1928         validate();
1929     }
1930 
1931     /**
1932      * Unregisters a previously registered event handler from this transform.
1933      * One handler might have been registered for different event types, so the
1934      * caller needs to specify the particular event type from which to
1935      * unregister the handler.
1936      *
1937      * @param &lt;T&gt; the specific event class of the handler
1938      * @param eventType the event type from which to unregister
1939      * @param eventHandler the handler to unregister
1940      * @throws NullPointerException if the event type or handler is null
1941      * @since JavaFX 8.0
1942      */
1943     public final &lt;T extends Event&gt; void removeEventHandler(
1944             final EventType&lt;T&gt; eventType,
1945             final EventHandler&lt;? super T&gt; eventHandler) {
1946         getInternalEventDispatcher()
1947                 .removeEventHandler(eventType, eventHandler);
1948     }
1949 
1950     /**
1951      * &lt;p&gt;
1952      * Registers an event filter to this transform. Registered event filters get
1953      * an event before any associated event handlers.
1954      * &lt;/p&gt;&lt;p&gt;
1955      * Currently the only event delivered to a {@code Transform} is the
1956      * {@code TransformChangedEvent} with it&#39;s single type
1957      * {@code TRANSFORM_CHANGED}.
1958      *
1959      * @param &lt;T&gt; the specific event class of the filter
1960      * @param eventType the type of the events to receive by the filter
1961      * @param eventFilter the filter to register
1962      * @throws NullPointerException if the event type or filter is null
1963      * @since JavaFX 8.0
1964      */
1965     public final &lt;T extends Event&gt; void addEventFilter(
1966             final EventType&lt;T&gt; eventType,
1967             final EventHandler&lt;? super T&gt; eventFilter) {
1968         getInternalEventDispatcher()
1969                 .addEventFilter(eventType, eventFilter);
1970         // need to validate all properties to get the change events
1971         validate();
1972     }
1973 
1974     /**
1975      * Unregisters a previously registered event filter from this transform. One
1976      * filter might have been registered for different event types, so the
1977      * caller needs to specify the particular event type from which to
1978      * unregister the filter.
1979      *
1980      * @param &lt;T&gt; the specific event class of the filter
1981      * @param eventType the event type from which to unregister
1982      * @param eventFilter the filter to unregister
1983      * @throws NullPointerException if the event type or filter is null
1984      * @since JavaFX 8.0
1985      */
1986     public final &lt;T extends Event&gt; void removeEventFilter(
1987             final EventType&lt;T&gt; eventType,
1988             final EventHandler&lt;? super T&gt; eventFilter) {
1989         getInternalEventDispatcher()
1990                 .removeEventFilter(eventType, eventFilter);
1991     }
1992 
1993     /**
1994      * Sets the onTransformChanged event handler which is called whenever
1995      * the transform changes any of its parameters.
1996      *
1997      * @param value the event handler, can be null to clear it
1998      * @since JavaFX 8.0
1999      */
2000     public final void setOnTransformChanged(
2001             EventHandler&lt;? super TransformChangedEvent&gt; value) {
2002         onTransformChangedProperty().set(value);
2003         // need to validate all properties to get the change events
2004         validate();
2005     }
2006 
2007     /**
2008      * Gets the onTransformChanged event handler.
2009      * @return the event handler previously set by {@code setOnTransformChanged}
2010      * method, null if the handler is not set.
2011      * @since JavaFX 8.0
2012      */
2013     public final EventHandler&lt;? super TransformChangedEvent&gt; getOnTransformChanged() {
2014         return (onTransformChanged == null) ? null : onTransformChanged.get();
2015     }
2016 
2017     /**
2018      * The onTransformChanged event handler is called whenever the transform
2019      * changes any of its parameters.
2020      * @return the onTransformChanged event handler
2021      * @since JavaFX 8.0
2022      */
2023     public final ObjectProperty&lt;EventHandler&lt;? super TransformChangedEvent&gt;&gt;
2024             onTransformChangedProperty() {
2025         if (onTransformChanged == null) {
2026 
2027             onTransformChanged = new SimpleObjectProperty&lt;EventHandler
2028                     &lt;? super TransformChangedEvent&gt;&gt;(this, &quot;onTransformChanged&quot;) {
2029 
2030                 @Override protected void invalidated() {
2031                     getInternalEventDispatcher().setEventHandler(
2032                             TransformChangedEvent.TRANSFORM_CHANGED, get());
2033                 }
2034             };
2035         }
2036 
2037         return onTransformChanged;
2038     }
2039 
2040     /* *************************************************************************
2041      *                                                                         *
2042      *                    Internal implementation stuff                        *
2043      *                                                                         *
2044      **************************************************************************/
2045 
2046     /**
2047      * Makes sure the specified matrix type can be requested from this transform.
2048      * Is used for convenience in various methods that accept
2049      * the MatrixType argument.
2050      * @param type matrix type to check
2051      * @throws IllegalArgumentException if this is a 3D transform and
2052      *                                  a 2D type is requested
2053      */
2054     void checkRequestedMAT(MatrixType type) throws IllegalArgumentException{
2055         if (type.is2D() &amp;&amp; !isType2D()) {
2056             throw new IllegalArgumentException(&quot;Cannot access 2D matrix &quot;
2057                     + &quot;for a 3D transform&quot;);
2058         }
2059     }
2060 
2061     /**
2062      * Makes sure this is a 2D transform.
2063      * Is used for convenience in various 2D point transformation methods.
2064      * @throws IllegalStateException if this is a 2D transform
2065      */
2066     void ensureCanTransform2DPoint() throws IllegalStateException {
2067         if (!isType2D()) {
2068             throw new IllegalStateException(&quot;Cannot transform 2D point &quot;
2069                     + &quot;with a 3D transform&quot;);
2070         }
2071     }
2072 
2073     /**
2074      * Needed for the proper delivery of the TransformChangedEvent.
2075      * If the members are invalid, the transformChanged() notification
2076      * is not called and the event is not delivered. To avoid that
2077      * we need to manually validate all properties. Subclasses validate
2078      * their specific properties.
2079      */
2080     void validate() {
2081         getMxx(); getMxy(); getMxz(); getTx();
2082         getMyx(); getMyy(); getMyz(); getTy();
2083         getMzx(); getMzy(); getMzz(); getTz();
2084     }
2085 
2086     abstract void apply(Affine3D t);
2087 
2088     abstract BaseTransform derive(BaseTransform t);
2089 
2090     void add(final Node node) {
2091         nodes.add(node);
2092     }
2093 
2094     void remove(final Node node) {
2095         nodes.remove(node);
2096     }
2097 
2098     /**
2099      * This method must be called by all transforms whenever any of their
2100      * parameters changes. It is typically called when any of the transform&#39;s
2101      * properties is invalidated (it is OK to skip the call if an invalid
2102      * property is set).
2103      * @since JavaFX 8.0
2104      */
2105     protected void transformChanged() {
2106         inverseCache = null;
2107         final Iterator iterator = nodes.iterator();
2108         while (iterator.hasNext()) {
2109             NodeHelper.transformsChanged(((Node) iterator.next()));
2110         }
2111 
2112         if (type2D != null) {
2113             type2D.invalidate();
2114         }
2115 
2116         if (identity != null) {
2117             identity.invalidate();
2118         }
2119 
2120         if (internalEventDispatcher != null) {
2121             // need to validate all properties for the event to be fired next time
2122             validate();
2123             Event.fireEvent(this, new TransformChangedEvent(this, this));
2124         }
2125     }
2126 
2127     /**
2128      * Visitor from {@code Affine} class which provides an efficient
2129      * {@code append} operation for the subclasses.
2130      * @param a {@code Affine} instance to append to
2131      */
2132     void appendTo(Affine a) {
2133         a.append(getMxx(), getMxy(), getMxz(), getTx(),
2134                  getMyx(), getMyy(), getMyz(), getTy(),
2135                  getMzx(), getMzy(), getMzz(), getTz());
2136     }
2137 
2138     /**
2139      * Visitor from {@code Affine} class which provides an efficient
2140      * {@code prepend} operation for the subclasses.
2141      * @param a {@code Affine} instance to prepend to
2142      */
2143     void prependTo(Affine a) {
2144         a.prepend(getMxx(), getMxy(), getMxz(), getTx(),
2145                   getMyx(), getMyy(), getMyz(), getTy(),
2146                   getMzx(), getMzy(), getMzz(), getTz());
2147     }
2148 
2149     /**
2150      * &lt;p&gt;
2151      * Gets the inverse transform cache.
2152      * &lt;/p&gt;&lt;p&gt;
2153      * Computing the inverse transform is generally an expensive operation,
2154      * so once it is needed we cache the result (throwing it away when the
2155      * transform changes). The subclasses may avoid using the cache if their
2156      * inverse can be computed quickly on the fly.
2157      * &lt;/p&gt;&lt;p&gt;
2158      * This method computes the inverse if the cache is not valid.
2159      * &lt;/p&gt;
2160      * @return the cached inverse transformation
2161      * @throws NonInvertibleTransformException if this transform
2162      *         cannot be inverted
2163      */
2164     private Transform getInverseCache() throws NonInvertibleTransformException {
2165         if (inverseCache == null || inverseCache.get() == null) {
2166             Affine inv = new Affine(
2167                     getMxx(), getMxy(), getMxz(), getTx(),
2168                     getMyx(), getMyy(), getMyz(), getTy(),
2169                     getMzx(), getMzy(), getMzz(), getTz());
2170             inv.invert();
2171             inverseCache = new SoftReference&lt;Transform&gt;(inv);
2172             return inv;
2173         }
2174 
2175         return inverseCache.get();
2176     }
2177 
2178     /**
2179      * Used only by tests to emulate garbage collecting the soft references
2180      */
2181     void clearInverseCache() {
2182         if (inverseCache != null) {
2183             inverseCache.clear();
2184         }
2185     }
2186 
2187     /**************************************************************************
2188      *  ImmutableTransform Class and supporting methods
2189      **************************************************************************/
2190 
2191     static Transform createImmutableTransform() {
2192         return new ImmutableTransform();
2193     }
2194 
2195     static Transform createImmutableTransform(
2196             double mxx, double mxy, double mxz, double tx,
2197             double myx, double myy, double myz, double ty,
2198             double mzx, double mzy, double mzz, double tz) {
2199         return new ImmutableTransform(
2200                 mxx, mxy, mxz, tx,
2201                 myx, myy, myz, ty,
2202                 mzx, mzy, mzz, tz);
2203     }
2204 
2205     static Transform createImmutableTransform(Transform transform,
2206             double mxx, double mxy, double mxz, double tx,
2207             double myx, double myy, double myz, double ty,
2208             double mzx, double mzy, double mzz, double tz) {
2209         if (transform == null) {
2210             return new ImmutableTransform(
2211                     mxx, mxy, mxz, tx,
2212                     myx, myy, myz, ty,
2213                     mzx, mzy, mzz, tz);
2214         }
2215         ((Transform.ImmutableTransform) transform).setToTransform(
2216                 mxx, mxy, mxz, tx,
2217                 myx, myy, myz, ty,
2218                 mzx, mzy, mzz, tz);
2219         return transform;
2220     }
2221 
2222     static Transform createImmutableTransform(Transform transform,
2223             Transform left, Transform right) {
2224         if (transform == null) {
2225             transform = new ImmutableTransform();
2226         }
2227         ((Transform.ImmutableTransform) transform).setToConcatenation(
2228                 (ImmutableTransform) left, (ImmutableTransform) right);
2229         return transform;
2230     }
2231 
2232     /**
2233      * Immutable transformation with performance optimizations based on Affine.
2234      *
2235      * From user&#39;s perspective, this transform is immutable. However, we can
2236      * modify it internally. This allows for reusing instances that were
2237      * not handed to users. The caller is responsible for not modifying
2238      * user-visible instances.
2239      *
2240      * Note: can&#39;t override Transform&#39;s package private methods so they cannot
2241      * be optimized. Currently not a big deal.
2242      */
2243     static class ImmutableTransform extends Transform {
2244 
2245         private static final int APPLY_IDENTITY = 0;
2246         private static final int APPLY_TRANSLATE = 1;
2247         private static final int APPLY_SCALE = 2;
2248         private static final int APPLY_SHEAR = 4;
2249         private static final int APPLY_NON_3D = 0;
2250         private static final int APPLY_3D_COMPLEX = 4;
2251         private transient int state2d;
2252         private transient int state3d;
2253 
2254         private double xx;
2255         private double xy;
2256         private double xz;
2257         private double yx;
2258         private double yy;
2259         private double yz;
2260         private double zx;
2261         private double zy;
2262         private double zz;
2263         private double xt;
2264         private double yt;
2265         private double zt;
2266 
2267         ImmutableTransform() {
2268             xx = yy = zz = 1.0;
2269         }
2270 
2271         ImmutableTransform(Transform transform) {
2272             this(transform.getMxx(), transform.getMxy(), transform.getMxz(),
2273                                                                  transform.getTx(),
2274                  transform.getMyx(), transform.getMyy(), transform.getMyz(),
2275                                                                  transform.getTy(),
2276                  transform.getMzx(), transform.getMzy(), transform.getMzz(),
2277                                                                  transform.getTz());
2278         }
2279 
2280         ImmutableTransform(double mxx, double mxy, double mxz, double tx,
2281                       double myx, double myy, double myz, double ty,
2282                       double mzx, double mzy, double mzz, double tz) {
2283             xx = mxx;
2284             xy = mxy;
2285             xz = mxz;
2286             xt = tx;
2287 
2288             yx = myx;
2289             yy = myy;
2290             yz = myz;
2291             yt = ty;
2292 
2293             zx = mzx;
2294             zy = mzy;
2295             zz = mzz;
2296             zt = tz;
2297 
2298             updateState();
2299         }
2300 
2301         // Beware: this is modifying immutable transform!
2302         // It is private and it is there just for the purpose of reusing
2303         // instances not given to users
2304         private void setToTransform(double mxx, double mxy, double mxz, double tx,
2305                                     double myx, double myy, double myz, double ty,
2306                                     double mzx, double mzy, double mzz, double tz)
2307         {
2308             xx = mxx;
2309             xy = mxy;
2310             xz = mxz;
2311             xt = tx;
2312             yx = myx;
2313             yy = myy;
2314             yz = myz;
2315             yt = ty;
2316             zx = mzx;
2317             zy = mzy;
2318             zz = mzz;
2319             zt = tz;
2320             updateState();
2321         }
2322 
2323         // Beware: this is modifying immutable transform!
2324         // It is private and it is there just for the purpose of reusing
2325         // instances not given to users
2326         private void setToConcatenation(ImmutableTransform left, ImmutableTransform right) {
2327             if (left.state3d == APPLY_NON_3D &amp;&amp; right.state3d == APPLY_NON_3D) {
2328                 xx = left.xx * right.xx + left.xy * right.yx;
2329                 xy = left.xx * right.xy + left.xy * right.yy;
2330                 xt = left.xx * right.xt + left.xy * right.yt + left.xt;
2331                 yx = left.yx * right.xx + left.yy * right.yx;
2332                 yy = left.yx * right.xy + left.yy * right.yy;
2333                 yt = left.yx * right.xt + left.yy * right.yt + left.yt;
2334                 if (state3d != APPLY_NON_3D) {
2335                     xz = yz = zx = zy = zt = 0.0;
2336                     zz = 1.0;
2337                     state3d = APPLY_NON_3D;
2338                 }
2339                 updateState2D();
2340             } else {
2341                 xx = left.xx * right.xx + left.xy * right.yx + left.xz * right.zx;
2342                 xy = left.xx * right.xy + left.xy * right.yy + left.xz * right.zy;
2343                 xz = left.xx * right.xz + left.xy * right.yz + left.xz * right.zz;
2344                 xt = left.xx * right.xt + left.xy * right.yt + left.xz * right.zt + left.xt;
2345                 yx = left.yx * right.xx + left.yy * right.yx + left.yz * right.zx;
2346                 yy = left.yx * right.xy + left.yy * right.yy + left.yz * right.zy;
2347                 yz = left.yx * right.xz + left.yy * right.yz + left.yz * right.zz;
2348                 yt = left.yx * right.xt + left.yy * right.yt + left.yz * right.zt + left.yt;
2349                 zx = left.zx * right.xx + left.zy * right.yx + left.zz * right.zx;
2350                 zy = left.zx * right.xy + left.zy * right.yy + left.zz * right.zy;
2351                 zz = left.zx * right.xz + left.zy * right.yz + left.zz * right.zz;
2352                 zt = left.zx * right.xt + left.zy * right.yt + left.zz * right.zt + left.zt;
2353                 updateState();
2354             }
2355             // could be further optimized using the states, but that would
2356             // require a lot of code (see Affine and all its append* methods)
2357         }
2358 
2359         @Override
2360         public double getMxx() {
2361             return xx;
2362         }
2363 
2364         @Override
2365         public double getMxy() {
2366             return xy;
2367         }
2368 
2369         @Override
2370         public double getMxz() {
2371             return xz;
2372         }
2373 
2374         @Override
2375         public double getTx() {
2376             return xt;
2377         }
2378 
2379         @Override
2380         public double getMyx() {
2381             return yx;
2382         }
2383 
2384         @Override
2385         public double getMyy() {
2386             return yy;
2387         }
2388 
2389         @Override
2390         public double getMyz() {
2391             return yz;
2392         }
2393 
2394         @Override
2395         public double getTy() {
2396             return yt;
2397         }
2398 
2399         @Override
2400         public double getMzx() {
2401             return zx;
2402         }
2403 
2404         @Override
2405         public double getMzy() {
2406             return zy;
2407         }
2408 
2409         @Override
2410         public double getMzz() {
2411             return zz;
2412         }
2413 
2414         @Override
2415         public double getTz() {
2416             return zt;
2417         }
2418 
2419     /* *************************************************************************
2420      *                                                                         *
2421      *                           State getters                                 *
2422      *                                                                         *
2423      **************************************************************************/
2424 
2425         @Override
2426         public double determinant() {
2427             switch(state3d) {
2428                 default:
2429                     stateError();
2430                     // cannot reach
2431                 case APPLY_NON_3D:
2432                     switch (state2d) {
2433                         default:
2434                             stateError();
2435                             // cannot reach
2436                         case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
2437                         case APPLY_SHEAR | APPLY_SCALE:
2438                             return xx * yy - xy * yx;
2439                         case APPLY_SHEAR | APPLY_TRANSLATE:
2440                         case APPLY_SHEAR:
2441                             return -(xy* yx);
2442                         case APPLY_SCALE | APPLY_TRANSLATE:
2443                         case APPLY_SCALE:
2444                             return xx * yy;
2445                         case APPLY_TRANSLATE:
2446                         case APPLY_IDENTITY:
2447                             return 1.0;
2448                     }
2449                 case APPLY_TRANSLATE:
2450                     return 1.0;
2451                 case APPLY_SCALE:
2452                 case APPLY_SCALE | APPLY_TRANSLATE:
2453                     return xx * yy * zz;
2454                 case APPLY_3D_COMPLEX:
2455                     return (xx* (yy * zz - zy * yz) +
2456                             xy* (yz * zx - zz * yx) +
2457                             xz* (yx * zy - zx * yy));
2458             }
2459         }
2460 
2461         @Override
2462         public Transform createConcatenation(Transform transform) {
2463             javafx.scene.transform.Affine a = new Affine(this);
2464             a.append(transform);
2465             return a;
2466         }
2467 
2468         @Override
2469         public javafx.scene.transform.Affine createInverse() throws NonInvertibleTransformException {
2470             javafx.scene.transform.Affine t = new Affine(this);
2471             t.invert();
2472             return t;
2473         }
2474 
2475         @Override
2476         public Transform clone() {
2477             return new ImmutableTransform(this);
2478         }
2479 
2480         /* *************************************************************************
2481          *                                                                         *
2482          *                     Transform, Inverse Transform                        *
2483          *                                                                         *
2484          **************************************************************************/
2485 
2486         @Override
2487         public Point2D transform(double x, double y) {
2488             ensureCanTransform2DPoint();
2489 
2490             switch (state2d) {
2491                 default:
2492                     stateError();
2493                     // cannot reach
2494                 case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
2495                     return new Point2D(
2496                         xx * x + xy * y + xt,
2497                         yx * x + yy * y + yt);
2498                 case APPLY_SHEAR | APPLY_SCALE:
2499                     return new Point2D(
2500                         xx * x + xy * y,
2501                         yx * x + yy * y);
2502                 case APPLY_SHEAR | APPLY_TRANSLATE:
2503                     return new Point2D(
2504                             xy * y + xt,
2505                             yx * x + yt);
2506                 case APPLY_SHEAR:
2507                     return new Point2D(xy * y, yx * x);
2508                 case APPLY_SCALE | APPLY_TRANSLATE:
2509                     return new Point2D(
2510                             xx * x + xt,
2511                             yy * y + yt);
2512                 case APPLY_SCALE:
2513                     return new Point2D(xx * x, yy * y);
2514                 case APPLY_TRANSLATE:
2515                     return new Point2D(x + xt, y + yt);
2516                 case APPLY_IDENTITY:
2517                     return new Point2D(x, y);
2518             }
2519         }
2520 
2521         @Override
2522         public Point3D transform(double x, double y, double z) {
2523             switch (state3d) {
2524                 default:
2525                     stateError();
2526                     // cannot reach
2527                 case APPLY_NON_3D:
2528                     switch (state2d) {
2529                         default:
2530                             stateError();
2531                             // cannot reach
2532                         case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
2533                             return new Point3D(
2534                                 xx * x + xy * y + xt,
2535                                 yx * x + yy * y + yt, z);
2536                         case APPLY_SHEAR | APPLY_SCALE:
2537                             return new Point3D(
2538                                 xx * x + xy * y,
2539                                 yx * x + yy * y, z);
2540                         case APPLY_SHEAR | APPLY_TRANSLATE:
2541                             return new Point3D(
2542                                     xy * y + xt, yx * x + yt,
2543                                     z);
2544                         case APPLY_SHEAR:
2545                             return new Point3D(xy * y, yx * x, z);
2546                         case APPLY_SCALE | APPLY_TRANSLATE:
2547                             return new Point3D(
2548                                     xx * x + xt, yy * y + yt,
2549                                     z);
2550                         case APPLY_SCALE:
2551                             return new Point3D(xx * x, yy * y, z);
2552                         case APPLY_TRANSLATE:
2553                             return new Point3D(x + xt, y + yt, z);
2554                         case APPLY_IDENTITY:
2555                             return new Point3D(x, y, z);
2556                     }
2557                 case APPLY_TRANSLATE:
2558                     return new Point3D(x + xt, y + yt, z + zt);
2559                 case APPLY_SCALE:
2560                     return new Point3D(xx * x, yy * y, zz * z);
2561                 case APPLY_SCALE | APPLY_TRANSLATE:
2562                     return new Point3D(
2563                             xx * x + xt,
2564                             yy * y + yt,
2565                             zz * z + zt);
2566                 case APPLY_3D_COMPLEX:
2567                     return new Point3D(
2568                         xx * x + xy * y + xz * z + xt,
2569                         yx * x + yy * y + yz * z + yt,
2570                         zx * x + zy * y + zz * z + zt);
2571             }
2572         }
2573 
2574         @Override
2575         public Point2D deltaTransform(double x, double y) {
2576             ensureCanTransform2DPoint();
2577 
2578             switch (state2d) {
2579                 default:
2580                     stateError();
2581                     // cannot reach
2582                 case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
2583                 case APPLY_SHEAR | APPLY_SCALE:
2584                     return new Point2D(
2585                         xx * x + xy * y,
2586                         yx * x + yy * y);
2587                 case APPLY_SHEAR | APPLY_TRANSLATE:
2588                 case APPLY_SHEAR:
2589                     return new Point2D(xy * y, yx * x);
2590                 case APPLY_SCALE | APPLY_TRANSLATE:
2591                 case APPLY_SCALE:
2592                     return new Point2D(xx * x, yy * y);
2593                 case APPLY_TRANSLATE:
2594                 case APPLY_IDENTITY:
2595                     return new Point2D(x, y);
2596             }
2597         }
2598 
2599         @Override
2600         public Point3D deltaTransform(double x, double y, double z) {
2601             switch (state3d) {
2602                 default:
2603                     stateError();
2604                     // cannot reach
2605                 case APPLY_NON_3D:
2606                     switch (state2d) {
2607                         default:
2608                             stateError();
2609                             // cannot reach
2610                         case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
2611                         case APPLY_SHEAR | APPLY_SCALE:
2612                             return new Point3D(
2613                                 xx * x + xy * y,
2614                                 yx * x + yy * y, z);
2615                         case APPLY_SHEAR | APPLY_TRANSLATE:
2616                         case APPLY_SHEAR:
2617                             return new Point3D(xy * y, yx * x, z);
2618                         case APPLY_SCALE | APPLY_TRANSLATE:
2619                         case APPLY_SCALE:
2620                             return new Point3D(xx * x, yy * y, z);
2621                         case APPLY_TRANSLATE:
2622                         case APPLY_IDENTITY:
2623                             return new Point3D(x, y, z);
2624                     }
2625                 case APPLY_TRANSLATE:
2626                     return new Point3D(x, y, z);
2627                 case APPLY_SCALE:
2628                 case APPLY_SCALE | APPLY_TRANSLATE:
2629                     return new Point3D(xx * x, yy * y, zz * z);
2630                 case APPLY_3D_COMPLEX:
2631                     return new Point3D(
2632                         xx * x + xy * y + xz * z,
2633                         yx * x + yy * y + yz * z,
2634                         zx * x + zy * y + zz * z);
2635             }
2636         }
2637 
2638         @Override
2639         public Point2D inverseTransform(double x, double y)
2640                 throws NonInvertibleTransformException {
2641             ensureCanTransform2DPoint();
2642 
2643             switch (state2d) {
2644                 default:
2645                     return super.inverseTransform(x, y);
2646                 case APPLY_SHEAR | APPLY_TRANSLATE:
2647                     if (xy == 0.0 || yx == 0.0) {
2648                         throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
2649                     }
2650                     return new Point2D(
2651                             (1.0 / yx) * y - yt / yx,
2652                             (1.0 / xy) * x - xt / xy);
2653                 case APPLY_SHEAR:
2654                     if (xy == 0.0 || yx == 0.0) {
2655                         throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
2656                     }
2657                     return new Point2D((1.0 / yx) * y, (1.0 / xy) * x);
2658                 case APPLY_SCALE | APPLY_TRANSLATE:
2659                     if (xx == 0.0 || yy == 0.0) {
2660                         throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
2661                     }
2662                     return new Point2D(
2663                             (1.0 / xx) * x - xt / xx,
2664                             (1.0 / yy) * y - yt / yy);
2665                 case APPLY_SCALE:
2666                     if (xx == 0.0 || yy == 0.0) {
2667                         throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
2668                     }
2669                     return new Point2D((1.0 / xx) * x, (1.0 / yy) * y);
2670                 case APPLY_TRANSLATE:
2671                     return new Point2D(x - xt, y - yt);
2672                 case APPLY_IDENTITY:
2673                     return new Point2D(x, y);
2674             }
2675         }
2676 
2677         @Override
2678         public Point3D inverseTransform(double x, double y, double z)
2679                 throws NonInvertibleTransformException {
2680             switch(state3d) {
2681                 default:
2682                     stateError();
2683                     // cannot reach
2684                 case APPLY_NON_3D:
2685                     switch (state2d) {
2686                         default:
2687                             return super.inverseTransform(x, y, z);
2688                         case APPLY_SHEAR | APPLY_TRANSLATE:
2689                             if (xy == 0.0 || yx == 0.0) {
2690                                 throw new NonInvertibleTransformException(
2691                                         &quot;Determinant is 0&quot;);
2692                             }
2693                             return new Point3D(
2694                                     (1.0 / yx) * y - yt / yx,
2695                                     (1.0 / xy) * x - xt / xy, z);
2696                         case APPLY_SHEAR:
2697                             if (xy == 0.0 || yx == 0.0) {
2698                                 throw new NonInvertibleTransformException(
2699                                         &quot;Determinant is 0&quot;);
2700                             }
2701                             return new Point3D(
2702                                     (1.0 / yx) * y,
2703                                     (1.0 / xy) * x, z);
2704                         case APPLY_SCALE | APPLY_TRANSLATE:
2705                             if (xx == 0.0 || yy == 0.0) {
2706                                 throw new NonInvertibleTransformException(
2707                                         &quot;Determinant is 0&quot;);
2708                             }
2709                             return new Point3D(
2710                                     (1.0 / xx) * x - xt / xx,
2711                                     (1.0 / yy) * y - yt / yy, z);
2712                         case APPLY_SCALE:
2713                             if (xx == 0.0 || yy == 0.0) {
2714                                 throw new NonInvertibleTransformException(
2715                                         &quot;Determinant is 0&quot;);
2716                             }
2717                             return new Point3D((1.0 / xx) * x, (1.0 / yy) * y, z);
2718                         case APPLY_TRANSLATE:
2719                             return new Point3D(x - xt, y - yt, z);
2720                         case APPLY_IDENTITY:
2721                             return new Point3D(x, y, z);
2722                     }
2723                 case APPLY_TRANSLATE:
2724                     return new Point3D(x - xt, y - yt, z - zt);
2725                 case APPLY_SCALE:
2726                     if (xx == 0.0 || yy == 0.0 || zz == 0.0) {
2727                         throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
2728                     }
2729                     return new Point3D(
2730                             (1.0 / xx) * x,
2731                             (1.0 / yy) * y,
2732                             (1.0 / zz) * z);
2733                 case APPLY_SCALE | APPLY_TRANSLATE:
2734                     if (xx == 0.0 || yy == 0.0 || zz == 0.0) {
2735                         throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
2736                     }
2737                     return new Point3D(
2738                             (1.0 / xx) * x - xt / xx,
2739                             (1.0 / yy) * y - yt / yy,
2740                             (1.0 / zz) * z - zt / zz);
2741                 case APPLY_3D_COMPLEX:
2742                     return super.inverseTransform(x, y, z);
2743             }
2744         }
2745 
2746         @Override
2747         public Point2D inverseDeltaTransform(double x, double y)
2748                 throws NonInvertibleTransformException {
2749             ensureCanTransform2DPoint();
2750 
2751             switch (state2d) {
2752                 default:
2753                     return super.inverseDeltaTransform(x, y);
2754                 case APPLY_SHEAR | APPLY_TRANSLATE:
2755                 case APPLY_SHEAR:
2756                     if (xy == 0.0 || yx == 0.0) {
2757                         throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
2758                     }
2759                     return new Point2D((1.0 / yx) * y, (1.0 / xy) * x);
2760                 case APPLY_SCALE | APPLY_TRANSLATE:
2761                 case APPLY_SCALE:
2762                     if (xx == 0.0 || yy == 0.0) {
2763                         throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
2764                     }
2765                     return new Point2D((1.0 / xx) * x, (1.0 / yy) * y);
2766                 case APPLY_TRANSLATE:
2767                 case APPLY_IDENTITY:
2768                     return new Point2D(x, y);
2769             }
2770         }
2771 
2772         @Override
2773         public Point3D inverseDeltaTransform(double x, double y, double z)
2774                 throws NonInvertibleTransformException {
2775             switch(state3d) {
2776                 default:
2777                     stateError();
2778                     // cannot reach
2779                 case APPLY_NON_3D:
2780                     switch (state2d) {
2781                         default:
2782                             return super.inverseDeltaTransform(x, y, z);
2783                         case APPLY_SHEAR | APPLY_TRANSLATE:
2784                         case APPLY_SHEAR:
2785                             if (xy == 0.0 || yx == 0.0) {
2786                                 throw new NonInvertibleTransformException(
2787                                         &quot;Determinant is 0&quot;);
2788                             }
2789                             return new Point3D(
2790                                     (1.0 / yx) * y,
2791                                     (1.0 / xy) * x, z);
2792                         case APPLY_SCALE | APPLY_TRANSLATE:
2793                         case APPLY_SCALE:
2794                             if (xx == 0.0 || yy == 0.0) {
2795                                 throw new NonInvertibleTransformException(
2796                                         &quot;Determinant is 0&quot;);
2797                             }
2798                             return new Point3D(
2799                                     (1.0 / xx) * x,
2800                                     (1.0 / yy) * y, z);
2801                         case APPLY_TRANSLATE:
2802                         case APPLY_IDENTITY:
2803                             return new Point3D(x, y, z);
2804                     }
2805 
2806                 case APPLY_TRANSLATE:
2807                     return new Point3D(x, y, z);
2808                 case APPLY_SCALE | APPLY_TRANSLATE:
2809                 case APPLY_SCALE:
2810                     if (xx == 0.0 || yy == 0.0 || zz == 0.0) {
2811                         throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
2812                     }
2813                     return new Point3D(
2814                             (1.0 / xx) * x,
2815                             (1.0 / yy) * y,
2816                             (1.0 / zz) * z);
2817                 case APPLY_3D_COMPLEX:
2818                     return super.inverseDeltaTransform(x, y, z);
2819             }
2820         }
2821 
2822         /* *************************************************************************
2823          *                                                                         *
2824          *                               Other API                                 *
2825          *                                                                         *
2826          **************************************************************************/
2827 
2828         @Override
2829         public String toString() {
2830            final StringBuilder sb = new StringBuilder(&quot;Transform [\n&quot;);
2831 
2832             sb.append(&quot;\t&quot;).append(xx);
2833             sb.append(&quot;, &quot;).append(xy);
2834             sb.append(&quot;, &quot;).append(xz);
2835             sb.append(&quot;, &quot;).append(xt);
2836             sb.append(&#39;\n&#39;);
2837             sb.append(&quot;\t&quot;).append(yx);
2838             sb.append(&quot;, &quot;).append(yy);
2839             sb.append(&quot;, &quot;).append(yz);
2840             sb.append(&quot;, &quot;).append(yt);
2841             sb.append(&#39;\n&#39;);
2842             sb.append(&quot;\t&quot;).append(zx);
2843             sb.append(&quot;, &quot;).append(zy);
2844             sb.append(&quot;, &quot;).append(zz);
2845             sb.append(&quot;, &quot;).append(zt);
2846 
2847             return sb.append(&quot;\n]&quot;).toString();
2848         }
2849 
2850         /* *************************************************************************
2851          *                                                                         *
2852          *                    Internal implementation stuff                        *
2853          *                                                                         *
2854          **************************************************************************/
2855 
2856         private void updateState() {
2857             updateState2D();
2858 
2859             state3d = APPLY_NON_3D;
2860 
2861             if (xz != 0.0 ||
2862                 yz != 0.0 ||
2863                 zx != 0.0 ||
2864                 zy != 0.0)
2865             {
2866                 state3d = APPLY_3D_COMPLEX;
2867             } else {
2868                 if ((state2d &amp; APPLY_SHEAR) == 0) {
2869                     if (zt != 0.0) {
2870                         state3d |= APPLY_TRANSLATE;
2871                     }
2872                     if (zz != 1.0) {
2873                         state3d |= APPLY_SCALE;
2874                     }
2875                     if (state3d != APPLY_NON_3D) {
2876                         state3d |= (state2d &amp; (APPLY_SCALE | APPLY_TRANSLATE));
2877                     }
2878                 } else {
2879                     if (zz != 1.0 || zt != 0.0) {
2880                         state3d = APPLY_3D_COMPLEX;
2881                     }
2882                 }
2883             }
2884         }
2885 
2886         private void updateState2D() {
2887             if (xy == 0.0 &amp;&amp; yx == 0.0) {
2888                 if (xx == 1.0 &amp;&amp; yy == 1.0) {
2889                     if (xt == 0.0 &amp;&amp; yt == 0.0) {
2890                         state2d = APPLY_IDENTITY;
2891                     } else {
2892                         state2d = APPLY_TRANSLATE;
2893                     }
2894                 } else {
2895                     if (xt == 0.0 &amp;&amp; yt == 0.0) {
2896                         state2d = APPLY_SCALE;
2897                     } else {
2898                         state2d = (APPLY_SCALE | APPLY_TRANSLATE);
2899                     }
2900                 }
2901             } else {
2902                 if (xx == 0.0 &amp;&amp; yy == 0.0) {
2903                     if (xt == 0.0 &amp;&amp; yt == 0.0) {
2904                         state2d = APPLY_SHEAR;
2905                     } else {
2906                         state2d = (APPLY_SHEAR | APPLY_TRANSLATE);
2907                     }
2908                 } else {
2909                     if (xt == 0.0 &amp;&amp; yt == 0.0) {
2910                         state2d = (APPLY_SHEAR | APPLY_SCALE);
2911                     } else {
2912                         state2d = (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE);
2913                     }
2914                 }
2915             }
2916         }
2917 
2918         void ensureCanTransform2DPoint() throws IllegalStateException {
2919             if (state3d != APPLY_NON_3D) {
2920                 throw new IllegalStateException(&quot;Cannot transform 2D point &quot;
2921                         + &quot;with a 3D transform&quot;);
2922             }
2923         }
2924 
2925         private static void stateError() {
2926             throw new InternalError(&quot;missing case in a switch&quot;);
2927         }
2928 
2929 
2930         @Override
2931         void apply(final Affine3D trans) {
2932             trans.concatenate(xx, xy, xz, xt,
2933                               yx, yy, yz, yt,
2934                               zx, zy, zz, zt);
2935         }
2936 
2937         @Override
2938         BaseTransform derive(final BaseTransform trans) {
2939             return trans.deriveWithConcatenation(xx, xy, xz, xt,
2940                                                  yx, yy, yz, yt,
2941                                                  zx, zy, zz, zt);
2942         }
2943 
2944         /**
2945          * Used only by tests to check the 2d matrix state
2946          */
2947         int getState2d() {
2948             return state2d;
2949         }
2950 
2951         /**
2952          * Used only by tests to check the 3d matrix state
2953          */
2954         int getState3d() {
2955             return state3d;
2956         }
2957 
2958     }
2959 
2960 }
    </pre>
  </body>
</html>