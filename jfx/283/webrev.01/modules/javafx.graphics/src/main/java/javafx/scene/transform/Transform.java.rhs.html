<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/javafx/scene/transform/Transform.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.transform;
  27 
  28 import java.util.Iterator;
  29 
  30 import com.sun.javafx.geometry.BoundsUtils;
  31 import javafx.event.EventDispatchChain;
  32 
  33 import javafx.scene.Node;
  34 
  35 import com.sun.javafx.util.WeakReferenceQueue;
  36 import com.sun.javafx.binding.ExpressionHelper;
  37 import com.sun.javafx.event.EventHandlerManager;
  38 import com.sun.javafx.geom.transform.Affine3D;
  39 import com.sun.javafx.geom.transform.BaseTransform;
  40 import com.sun.javafx.scene.NodeHelper;
  41 import com.sun.javafx.scene.transform.TransformHelper;
  42 import com.sun.javafx.scene.transform.TransformUtils;
  43 import java.lang.ref.SoftReference;
  44 import javafx.beans.InvalidationListener;
  45 import javafx.beans.property.ObjectProperty;
  46 import javafx.beans.property.ReadOnlyBooleanProperty;
  47 import javafx.beans.property.SimpleObjectProperty;
  48 import javafx.beans.value.ChangeListener;
  49 import javafx.event.Event;
  50 import javafx.event.EventHandler;
  51 import javafx.event.EventTarget;
  52 import javafx.event.EventType;
  53 import javafx.geometry.Bounds;
  54 import javafx.geometry.Point2D;
  55 import javafx.geometry.Point3D;
  56 
  57 // PENDING_DOC_REVIEW of this whole class
  58 /**
  59  * This class is a base class for different affine transformations.
  60  * It provides factory methods for the simple transformations - rotating,
  61  * scaling, shearing, and translation. It allows to get the transformation
  62  * matrix elements for any transform.
  63  *
  64  * &lt;p&gt;Example:&lt;/p&gt;
  65  *
  66  * &lt;pre&gt;{@code
  67  *  Rectangle rect = new Rectangle(50,50, Color.RED);
  68  *  rect.getTransforms().add(new Rotate(45,0,0)); //rotate by 45 degrees
  69  * }&lt;/pre&gt;
  70  * @since JavaFX 2.0
  71  */
  72 public abstract class Transform implements Cloneable, EventTarget {
  73 
  74     static {
  75         // This is used by classes in different packages to get access to
  76         // private and package private methods.
  77         TransformHelper.setTransformAccessor(new TransformHelper.TransformAccessor() {
  78 
  79             @Override
  80             public void add(Transform transform, Node node) {
  81                 transform.add(node);
  82             }
  83 
  84             @Override
  85             public void remove(Transform transform, Node node) {
  86                 transform.remove(node);
  87             }
  88 
  89             @Override
  90             public void apply(Transform transform, Affine3D affine3D) {
  91                 transform.apply(affine3D);
  92             }
  93 
  94             @Override
  95             public BaseTransform derive(Transform transform, BaseTransform baseTransform) {
  96                 return transform.derive(baseTransform);
  97             }
  98 
  99             @Override
 100             public Transform createImmutableTransform() {
 101                 return Transform.createImmutableTransform();
 102             }
 103 
 104             @Override
 105             public Transform createImmutableTransform(
 106                     double mxx, double mxy, double mxz, double tx,
 107                     double myx, double myy, double myz, double ty,
 108                     double mzx, double mzy, double mzz, double tz) {
 109                 return Transform.createImmutableTransform(mxx, mxy, mxz, tx,
 110                         myx, myy, myz, ty, mzx, mzy, mzz, tz);
 111             }
 112 
 113             @Override
 114             public Transform createImmutableTransform(Transform transform,
 115                     double mxx, double mxy, double mxz, double tx,
 116                     double myx, double myy, double myz, double ty,
 117                     double mzx, double mzy, double mzz, double tz) {
 118                 return Transform.createImmutableTransform(transform,
 119                         mxx, mxy, mxz, tx, myx, myy, myz, ty, mzx, mzy, mzz, tz);
 120             }
 121 
 122             @Override
 123             public Transform createImmutableTransform(Transform transform,
 124                     Transform left, Transform right) {
 125                 return Transform.createImmutableTransform(transform, left, right);
 126             }
 127         });
 128     }
 129 
<a name="1" id="anc1"></a><span class="line-added"> 130     /**</span>
<span class="line-added"> 131      * Creates a default {@code Transform}.</span>
<span class="line-added"> 132      */</span>
<span class="line-added"> 133     public Transform() {</span>
<span class="line-added"> 134     }</span>
<span class="line-added"> 135 </span>
 136     /* *************************************************************************
 137      *                                                                         *
 138      *                            Factories                                    *
 139      *                                                                         *
 140      **************************************************************************/
 141 
 142     /**
 143      * Returns a new {@code Affine} object from 12 number
 144      * values representing the 6 specifiable entries of the 3x4
 145      * Affine transformation matrix.
 146      *
 147      * @param mxx the X coordinate scaling element of the 3x4 matrix
 148      * @param myx the Y coordinate shearing element of the 3x4 matrix
 149      * @param mxy the X coordinate shearing element of the 3x4 matrix
 150      * @param myy the Y coordinate scaling element of the 3x4 matrix
 151      * @param tx the X coordinate translation element of the 3x4 matrix
 152      * @param ty the Y coordinate translation element of the 3x4 matrix
 153      * @return a new {@code Affine} object derived from specified parameters
 154      */
 155     public static Affine affine(
 156         double mxx, double myx, double mxy, double myy, double tx, double ty) {
 157         final Affine affine = new Affine();
 158         affine.setMxx(mxx);
 159         affine.setMxy(mxy);
 160         affine.setTx(tx);
 161         affine.setMyx(myx);
 162         affine.setMyy(myy);
 163         affine.setTy(ty);
 164         return affine;
 165     }
 166 
 167 
 168     /**
 169      * Returns a new {@code Affine} object from 12 number
 170      * values representing the 12 specifiable entries of the 3x4
 171      * Affine transformation matrix.
 172      *
 173      * @param mxx the X coordinate scaling element of the 3x4 matrix
 174      * @param mxy the XY element of the 3x4 matrix
 175      * @param mxz the XZ element of the 3x4 matrix
 176      * @param tx the X coordinate translation element of the 3x4 matrix
 177      * @param myx the YX element of the 3x4 matrix
 178      * @param myy the Y coordinate scaling element of the 3x4 matrix
 179      * @param myz the YZ element of the 3x4 matrix
 180      * @param ty the Y coordinate translation element of the 3x4 matrix
 181      * @param mzx the ZX element of the 3x4 matrix
 182      * @param mzy the ZY element of the 3x4 matrix
 183      * @param mzz the Z coordinate scaling element of the 3x4 matrix
 184      * @param tz the Z coordinate translation element of the 3x4 matrix
 185      * @return a new {@code Affine} object derived from specified parameters
 186      */
 187     public static Affine affine(
 188         double mxx, double mxy, double mxz, double tx,
 189         double myx, double myy, double myz, double ty,
 190         double mzx, double mzy, double mzz, double tz) {
 191         final Affine affine = new Affine();
 192         affine.setMxx(mxx);
 193         affine.setMxy(mxy);
 194         affine.setMxz(mxz);
 195         affine.setTx(tx);
 196         affine.setMyx(myx);
 197         affine.setMyy(myy);
 198         affine.setMyz(myz);
 199         affine.setTy(ty);
 200         affine.setMzx(mzx);
 201         affine.setMzy(mzy);
 202         affine.setMzz(mzz);
 203         affine.setTz(tz);
 204         return affine;
 205     }
 206 
 207 
 208     /**
 209      * Returns a {@code Translate} object representing a translation transformation.
 210      * &lt;p&gt;
 211      * This is equivalent to:
 212      * &lt;pre&gt;
 213      *    new Translate(x, y);
 214      * &lt;/pre&gt;
 215      * @param x the translate x value
 216      * @param y the translate y value
 217      * @return the Translate object representing a translation transformation
 218      */
 219     public static Translate translate(double x, double y) {
 220         final Translate translate = new Translate();
 221         translate.setX(x);
 222         translate.setY(y);
 223         return translate;
 224     }
 225 
 226 
 227     /**
 228      * Returns a {@code Rotate} object that rotates coordinates around a pivot
 229      * point.
 230      * &lt;p&gt;
 231      * This is equivalent to:
 232      * &lt;pre&gt;
 233      *    new Rotate(angle, pivotX, pivotY);
 234      * &lt;/pre&gt;
 235      * @param angle the rotation angle
 236      * @param pivotX the pivot x value
 237      * @param pivotY the pivot y value
 238      * @return the Rotate object that rotates coordinates around a pivot point
 239      */
 240     public static Rotate rotate(double angle, double pivotX, double pivotY) {
 241         final Rotate rotate = new Rotate();
 242         rotate.setAngle(angle);
 243         rotate.setPivotX(pivotX);
 244         rotate.setPivotY(pivotY);
 245         return rotate;
 246     }
 247 
 248 
 249     /**
 250      * Returns a {@code Scale} object representing a scaling transformation.
 251      * &lt;p&gt;
 252      * This is equivalent to:
 253      * &lt;pre&gt;
 254      *    new Scale(x, y);
 255      * &lt;/pre&gt;
 256      * @param x the scale x value
 257      * @param y the scale y value
 258      * @return the Scale object representing a scaling transformation
 259      */
 260     public static Scale scale(double x, double y) {
 261         final Scale scale = new Scale();
 262         scale.setX(x);
 263         scale.setY(y);
 264         return scale;
 265     }
 266 
 267 
 268     /**
 269      * Returns a {@code Scale} object representing a scaling transformation.
 270      * The returned scale operation will be about the given pivot point.
 271      * &lt;p&gt;
 272      * This is equivalent to:
 273      * &lt;pre&gt;
 274      *    new Scale(x, y, pivotX, pivotY);
 275      * &lt;/pre&gt;
 276      * @param x the scale x value
 277      * @param y the scale y value
 278      * @param pivotX the pivot x value
 279      * @param pivotY the pivot y value
 280      * @return the Scale object representing a scaling transformation
 281      */
 282     public static Scale scale(double x, double y, double pivotX, double pivotY) {
 283         final Scale scale = new Scale();
 284         scale.setX(x);
 285         scale.setY(y);
 286         scale.setPivotX(pivotX);
 287         scale.setPivotY(pivotY);
 288         return scale;
 289     }
 290 
 291 
 292     /**
 293      * Returns a {@code Shear} object representing a shearing transformation.
 294      * &lt;p&gt;
 295      * This is equivalent to:
 296      * &lt;pre&gt;
 297      *    new Shear(x, y);
 298      * &lt;/pre&gt;
 299      * @param x the shear x value
 300      * @param y the shear y value
 301      * @return the Shear object representing a shearing transformation
 302      */
 303     public static Shear shear(double x, double y) {
 304         final Shear shear = new Shear();
 305         shear.setX(x);
 306         shear.setY(y);
 307         return shear;
 308     }
 309 
 310     /**
 311      * Returns a {@code Shear} object representing a shearing transformation.
 312      * &lt;p&gt;
 313      * This is equivalent to:
 314      * &lt;pre&gt;
 315      *    new Shear(x, y, pivotX, pivotY);
 316      * &lt;/pre&gt;
 317      * @param x the shear x value
 318      * @param y the shear y value
 319      * @param pivotX the pivot x value
 320      * @param pivotY the pivot y value
 321      * @return the Shear object representing a shearing transformation
 322      */
 323     public static Shear shear(double x, double y, double pivotX, double pivotY) {
 324         final Shear shear = new Shear();
 325         shear.setX(x);
 326         shear.setY(y);
 327         shear.setPivotX(pivotX);
 328         shear.setPivotY(pivotY);
 329         return shear;
 330     }
 331 
 332     /**
 333      * For transforms with expensive inversion we cache the inverted matrix
 334      * once it is needed and computed for some operation.
 335      */
 336     private SoftReference&lt;Transform&gt; inverseCache = null;
 337 
 338     private WeakReferenceQueue nodes = new WeakReferenceQueue();
 339 
 340     /* *************************************************************************
 341      *                                                                         *
 342      *                         Element getters                                 *
 343      *                                                                         *
 344      **************************************************************************/
 345 
 346     /**
 347      * Gets the X coordinate scaling element of the 3x4 matrix.
 348      *
 349      * @return the X coordinate scaling element of the 3x4 matrix
 350      * @since JavaFX 2.2
 351      */
 352     public  double getMxx() {
 353         return 1.0;
 354     }
 355 
 356     /**
 357      * Gets the XY coordinate element of the 3x4 matrix.
 358      *
 359      * @return the XY coordinate element of the 3x4 matrix
 360      * @since JavaFX 2.2
 361      */
 362     public  double getMxy() {
 363         return 0.0;
 364     }
 365 
 366     /**
 367      * Gets the XZ coordinate element of the 3x4 matrix.
 368      *
 369      * @return the XZ coordinate element of the 3x4 matrix
 370      * @since JavaFX 2.2
 371      */
 372     public  double getMxz() {
 373         return 0.0;
 374     }
 375 
 376     /**
 377      * Gets the X coordinate translation element of the 3x4 matrix.
 378      *
 379      * @return the X coordinate translation element of the 3x4 matrix
 380      * @since JavaFX 2.2
 381      */
 382     public  double getTx() {
 383         return 0.0;
 384     }
 385 
 386     /**
 387      * Gets the YX coordinate element of the 3x4 matrix.
 388      *
 389      * @return the YX coordinate element of the 3x4 matrix
 390      * @since JavaFX 2.2
 391      */
 392     public  double getMyx() {
 393         return 0.0;
 394     }
 395 
 396     /**
 397      * Gets the Y coordinate scaling element of the 3x4 matrix.
 398      *
 399      * @return the Y coordinate scaling element of the 3x4 matrix
 400      * @since JavaFX 2.2
 401      */
 402     public  double getMyy() {
 403         return 1.0;
 404     }
 405 
 406     /**
 407      * Gets the YZ coordinate element of the 3x4 matrix.
 408      *
 409      * @return the YZ coordinate element of the 3x4 matrix
 410      * @since JavaFX 2.2
 411      */
 412     public  double getMyz() {
 413         return 0.0;
 414     }
 415 
 416     /**
 417      * Gets the Y coordinate translation element of the 3x4 matrix.
 418      *
 419      * @return the Y coordinate translation element of the 3x4 matrix
 420      * @since JavaFX 2.2
 421      */
 422     public  double getTy() {
 423         return 0.0;
 424     }
 425 
 426     /**
 427      * Gets the ZX coordinate element of the 3x4 matrix.
 428      *
 429      * @return the ZX coordinate element of the 3x4 matrix
 430      * @since JavaFX 2.2
 431      */
 432     public  double getMzx() {
 433         return 0.0;
 434     }
 435 
 436     /**
 437      * Gets the ZY coordinate element of the 3x4 matrix.
 438      *
 439      * @return the ZY coordinate element of the 3x4 matrix
 440      * @since JavaFX 2.2
 441      */
 442     public  double getMzy() {
 443         return 0.0;
 444     }
 445 
 446     /**
 447      * Gets the Z coordinate scaling element of the 3x4 matrix.
 448      *
 449      * @return the Z coordinate scaling element of the 3x4 matrix
 450      * @since JavaFX 2.2
 451      */
 452     public  double getMzz() {
 453         return 1.0;
 454     }
 455 
 456     /**
 457      * Gets the Z coordinate translation element of the 3x4 matrix.
 458      *
 459      * @return the Z coordinate translation element of the 3x4 matrix
 460      * @since JavaFX 2.2
 461      */
 462     public  double getTz() {
 463         return 0.0;
 464     }
 465 
 466     /**
 467      * Gets the specified element of the transformation matrix.
 468      * @param type type of matrix to get the value from
 469      * @param row zero-based row number
 470      * @param column zero-based column number
 471      * @return value of the specified transformation matrix element
 472      * @throws IllegalArgumentException if a 2D matrix type is requested for
 473      *         a 3D transform
 474      * @throws IndexOutOfBoundsException if the indices are not within
 475      *         the specified matrix type
 476      * @throws NullPointerException if the specified {@code type} is null
 477      * @since JavaFX 8.0
 478      */
 479     public double getElement(MatrixType type, int row, int column) {
 480         if (row &lt; 0 || row &gt;= type.rows() || column &lt; 0 || column &gt;= type.columns()) {
 481             throw new IndexOutOfBoundsException(&quot;Index outside of affine &quot;
 482                     + &quot;matrix &quot; + type + &quot;: [&quot; + row + &quot;, &quot; + column + &quot;]&quot;);
 483         }
 484         switch(type) {
 485             case MT_2D_2x3:
 486                 // fall-through
 487             case MT_2D_3x3:
 488                 if (!isType2D()) {
 489                     throw new IllegalArgumentException(&quot;Cannot access 2D matrix &quot;
 490                             + &quot;of a 3D transform&quot;);
 491                 }
 492                 switch(row) {
 493                     case 0:
 494                         switch(column) {
 495                             case 0: return getMxx();
 496                             case 1: return getMxy();
 497                             case 2: return getTx();
 498                         }
 499                     case 1:
 500                         switch(column) {
 501                             case 0: return getMyx();
 502                             case 1: return getMyy();
 503                             case 2: return getTy();
 504                         }
 505                     case 2:
 506                         switch(column) {
 507                             case 0: return 0.0;
 508                             case 1: return 0.0;
 509                             case 2: return 1.0;
 510                         }
 511                 }
 512                 break;
 513             case MT_3D_3x4:
 514                 // fall-through
 515             case MT_3D_4x4:
 516                 switch(row) {
 517                     case 0:
 518                         switch(column) {
 519                             case 0: return getMxx();
 520                             case 1: return getMxy();
 521                             case 2: return getMxz();
 522                             case 3: return getTx();
 523                         }
 524                     case 1:
 525                         switch(column) {
 526                             case 0: return getMyx();
 527                             case 1: return getMyy();
 528                             case 2: return getMyz();
 529                             case 3: return getTy();
 530                         }
 531                     case 2:
 532                         switch(column) {
 533                             case 0: return getMzx();
 534                             case 1: return getMzy();
 535                             case 2: return getMzz();
 536                             case 3: return getTz();
 537                         }
 538                     case 3:
 539                         switch(column) {
 540                             case 0: return 0.0;
 541                             case 1: return 0.0;
 542                             case 2: return 0.0;
 543                             case 3: return 1.0;
 544                         }
 545                 }
 546                 break;
 547         }
 548         // cannot reach here
 549         throw new InternalError(&quot;Unsupported matrix type &quot; + type);
 550     }
 551 
 552     /* *************************************************************************
 553      *                                                                         *
 554      *                           State getters                                 *
 555      *                                                                         *
 556      **************************************************************************/
 557 
 558     /**
 559      * Computes if this transform is currently a 2D transform (has no effect
 560      * in the direction of Z axis).
 561      * Used by the subclasses to effectively provide value of the type2D
 562      * property.
 563      * @return true if this transform is currently 2D-only
 564      */
 565     boolean computeIs2D() {
 566         return getMxz() == 0.0 &amp;&amp; getMzx() == 0.0 &amp;&amp; getMzy() == 0.0 &amp;&amp;
 567                     getMzz() == 1.0 &amp;&amp; getTz() == 0.0;
 568     }
 569 
 570     /**
 571      * Computes if this transform is currently an identity (has
 572      * no effect in any direction).
 573      * Used by the subclasses to effectively provide value of the identity
 574      * property.
 575      * @return true if this transform is currently an identity transform
 576      */
 577     boolean computeIsIdentity() {
 578         return
 579             getMxx() == 1.0 &amp;&amp; getMxy() == 0.0 &amp;&amp; getMxz() == 0.0 &amp;&amp; getTx() == 0.0 &amp;&amp;
 580             getMyx() == 0.0 &amp;&amp; getMyy() == 1.0 &amp;&amp; getMyz() == 0.0 &amp;&amp; getTy() == 0.0 &amp;&amp;
 581             getMzx() == 0.0 &amp;&amp; getMzy() == 0.0 &amp;&amp; getMzz() == 1.0 &amp;&amp; getTz() == 0.0;
 582     }
 583 
 584     /**
 585      * Computes determinant of the transformation matrix.
 586      * Among other things, determinant can be used for testing this transform&#39;s
 587      * invertibility - it is invertible if determinant is not equal to zero.
 588      * @return Determinant of the transformation matrix
 589      * @since JavaFX 8.0
 590      */
 591     public double determinant() {
 592         final double myx = getMyx();
 593         final double myy = getMyy();
 594         final double myz = getMyz();
 595         final double mzx = getMzx();
 596         final double mzy = getMzy();
 597         final double mzz = getMzz();
 598 
 599         return (getMxx() * (myy * mzz - mzy * myz) +
 600                 getMxy() * (myz * mzx - mzz * myx) +
 601                 getMxz() * (myx * mzy - mzx * myy));
 602     }
 603 
 604     /**
 605      * Determines if this is currently a 2D transform.
 606      * Transform is 2D if it has no effect along the Z axis.
 607      * @since JavaFX 8.0
 608      */
 609     private LazyBooleanProperty type2D;
 610 
 611     public final boolean isType2D() {
 612         return type2D == null ? computeIs2D() : type2D.get();
 613     }
 614 
 615     public final ReadOnlyBooleanProperty type2DProperty() {
 616         if (type2D == null) {
 617             type2D = new LazyBooleanProperty() {
 618 
 619                 @Override
 620                 protected boolean computeValue() {
 621                     return computeIs2D();
 622                 }
 623 
 624                 @Override
 625                 public Object getBean() {
 626                     return Transform.this;
 627                 }
 628 
 629                 @Override
 630                 public String getName() {
 631                     return &quot;type2D&quot;;
 632                 }
 633             };
 634         }
 635         return type2D;
 636     }
 637 
 638     /**
 639      * Determines if this is currently an identity transform.
 640      * Identity transform has no effect on the transformed nodes.
 641      * @since JavaFX 8.0
 642      */
 643     private LazyBooleanProperty identity;
 644 
 645     public final boolean isIdentity() {
 646         return identity == null ? computeIsIdentity() : identity.get();
 647     }
 648 
 649     public final ReadOnlyBooleanProperty identityProperty() {
 650         if (identity == null) {
 651             identity = new LazyBooleanProperty() {
 652 
 653                 @Override
 654                 protected boolean computeValue() {
 655                     return computeIsIdentity();
 656                 }
 657 
 658                 @Override
 659                 public Object getBean() {
 660                     return Transform.this;
 661                 }
 662 
 663                 @Override
 664                 public String getName() {
 665                     return &quot;identity&quot;;
 666                 }
 667             };
 668         }
 669         return identity;
 670     }
 671 
 672     /**
 673      * Lazily computed read-only boolean property implementation.
 674      * Used for type2D and identity properties.
 675      */
 676     private static abstract class LazyBooleanProperty
 677             extends ReadOnlyBooleanProperty {
 678 
 679         private ExpressionHelper&lt;Boolean&gt; helper;
 680         private boolean valid;
 681         private boolean value;
 682 
 683         @Override
 684         public void addListener(InvalidationListener listener) {
 685             helper = ExpressionHelper.addListener(helper, this, listener);
 686         }
 687 
 688         @Override
 689         public void removeListener(InvalidationListener listener) {
 690             helper = ExpressionHelper.removeListener(helper, listener);
 691         }
 692 
 693         @Override
 694         public void addListener(ChangeListener&lt;? super Boolean&gt; listener) {
 695             helper = ExpressionHelper.addListener(helper, this, listener);
 696         }
 697 
 698         @Override
 699         public void removeListener(ChangeListener&lt;? super Boolean&gt; listener) {
 700             helper = ExpressionHelper.removeListener(helper, listener);
 701         }
 702 
 703         @Override
 704         public boolean get() {
 705             if (!valid) {
 706                 value = computeValue();
 707                 valid = true;
 708             }
 709 
 710             return value;
 711         }
 712 
 713         public void invalidate() {
 714             if (valid) {
 715                 valid = false;
 716                 ExpressionHelper.fireValueChangedEvent(helper);
 717             }
 718         }
 719 
 720         protected abstract boolean computeValue();
 721     }
 722 
 723     /**
 724      * Transforms the specified point by this transform and by the specified
 725      * transform and returns distance of the result points. Used for similarTo
 726      * method. Has to be used only for 2D transforms (otherwise throws an
 727      * exception).
 728      * @param t the other transform
 729      * @param x point&#39;s X coordinate
 730      * @param y point&#39;s Y coordinate
 731      * @return distance of the transformed points
 732      */
 733     private double transformDiff(Transform t, double x, double y) {
 734         final Point2D byThis = transform(x, y);
 735         final Point2D byOther = t.transform(x, y);
 736         return byThis.distance(byOther);
 737     }
 738 
 739     /**
 740      * Transforms the specified point by this transform and by the specified
 741      * transform and returns distance of the result points. Used for similarTo
 742      * method.
 743      * @param t the other transform
 744      * @param x point&#39;s X coordinate
 745      * @param y point&#39;s Y coordinate
 746      * @param z point&#39;s Z coordinate
 747      * @return distance of the transformed points
 748      */
 749     private double transformDiff(Transform t, double x, double y, double z) {
 750         final Point3D byThis = transform(x, y, z);
 751         final Point3D byOther = t.transform(x, y, z);
 752         return byThis.distance(byOther);
 753     }
 754 
 755     /**
 756      * Checks if this transform is similar to the specified transform.
 757      * The two transforms are considered similar if any point from
 758      * {@code range} is transformed by them to points that are no farther
 759      * than {@code maxDelta} from each other.
 760      * @param transform transform to be compared to this transform
 761      * @param range region of interest on which the two transforms are compared
 762      * @param maxDelta maximum allowed distance for the results of transforming
 763      *                 any single point from {@code range} by the two transforms
 764      * @return true if the transforms are similar according to the specified
 765      *              criteria
 766      * @throws NullPointerException if the specified {@code transform}
 767      *         or {@code range} is null
 768      * @since JavaFX 8.0
 769      */
 770     public boolean similarTo(Transform transform, Bounds range, double maxDelta) {
 771 
 772         double cornerX, cornerY, cornerZ;
 773 
 774         if (isType2D() &amp;&amp; transform.isType2D()) {
 775             cornerX = range.getMinX();
 776             cornerY = range.getMinY();
 777 
 778             if (transformDiff(transform, cornerX, cornerY) &gt; maxDelta) {
 779                 return false;
 780             }
 781 
 782             cornerY = range.getMaxY();
 783             if (transformDiff(transform, cornerX, cornerY) &gt; maxDelta) {
 784                 return false;
 785             }
 786 
 787             cornerX = range.getMaxX();
 788             cornerY = range.getMinY();
 789             if (transformDiff(transform, cornerX, cornerY) &gt; maxDelta) {
 790                 return false;
 791             }
 792 
 793             cornerY = range.getMaxY();
 794             if (transformDiff(transform, cornerX, cornerY) &gt; maxDelta) {
 795                 return false;
 796             }
 797 
 798             return true;
 799         }
 800 
 801         cornerX = range.getMinX();
 802         cornerY = range.getMinY();
 803         cornerZ = range.getMinZ();
 804         if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
 805             return false;
 806         }
 807 
 808         cornerY = range.getMaxY();
 809         if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
 810             return false;
 811         }
 812 
 813         cornerX = range.getMaxX();
 814         cornerY = range.getMinY();
 815         if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
 816             return false;
 817         }
 818 
 819         cornerY = range.getMaxY();
 820         if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
 821             return false;
 822         }
 823 
 824         if (range.getDepth() != 0.0) {
 825             cornerX = range.getMinX();
 826             cornerY = range.getMinY();
 827             cornerZ = range.getMaxZ();
 828             if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
 829                 return false;
 830             }
 831 
 832             cornerY = range.getMaxY();
 833             if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
 834                 return false;
 835             }
 836 
 837             cornerX = range.getMaxX();
 838             cornerY = range.getMinY();
 839             if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
 840                 return false;
 841             }
 842 
 843             cornerY = range.getMaxY();
 844             if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
 845                 return false;
 846             }
 847         }
 848 
 849         return true;
 850     }
 851 
 852     /* *************************************************************************
 853      *                                                                         *
 854      *                           Array getters                                 *
 855      *                                                                         *
 856      **************************************************************************/
 857 
 858     /**
 859      * Core of the toArray implementation for the 2D case.
 860      * All of the checks has been made by the enclosing method as well as
 861      * the constant elements filled, this method only fills the varying
 862      * elements to the array. Used by subclasses to fill
 863      * the elements efficiently.
 864      * @param array array to be filled with the 6 2D elements
 865      */
 866     void fill2DArray(double[] array) {
 867         array[0] = getMxx();
 868         array[1] = getMxy();
 869         array[2] = getTx();
 870         array[3] = getMyx();
 871         array[4] = getMyy();
 872         array[5] = getTy();
 873     }
 874 
 875     /**
 876      * Core of the toArray implementation for the 3D case.
 877      * All of the checks has been made by the enclosing method as well as
 878      * the constant elements filled, this method only fills the varying
 879      * elements to the array. Used by subclasses to fill
 880      * the elements efficiently.
 881      * @param array array to be filled with the 12 3D elements
 882      */
 883     void fill3DArray(double[] array) {
 884         array[0] = getMxx();
 885         array[1] = getMxy();
 886         array[2] = getMxz();
 887         array[3] = getTx();
 888         array[4] = getMyx();
 889         array[5] = getMyy();
 890         array[6] = getMyz();
 891         array[7] = getTy();
 892         array[8] = getMzx();
 893         array[9] = getMzy();
 894         array[10] = getMzz();
 895         array[11] = getTz();
 896     }
 897 
 898     /**
 899      * Returns an array containing the flattened transformation matrix.
 900      * If the requested matrix type fits in the specified array, it is returned
 901      * therein. Otherwise, a new array is created.
 902      * @param type matrix type to be filled in the array
 903      * @param array array into which the elements of the matrix are to be
 904      *              stored, if it is non-null and big enough; otherwise,
 905      *              a new array is created for this purpose.
 906      * @return an array containing the elements of the requested matrix type
 907      *         representing this transform
 908      * @throws IllegalArgumentException if a 2D matrix type is requested for
 909      *         a 3D transform
 910      * @throws NullPointerException if the specified {@code type} is null
 911      * @since JavaFX 8.0
 912      */
 913     public double[] toArray(MatrixType type, double[] array) {
 914         checkRequestedMAT(type);
 915 
 916         if (array == null || array.length &lt; type.elements()) {
 917             array = new double[type.elements()];
 918         }
 919 
 920         switch (type) {
 921             case MT_2D_3x3:
 922                 array[6] = 0.0;
 923                 array[7] = 0.0;
 924                 array[8] = 1.0;
 925                 // fall-through
 926             case MT_2D_2x3:
 927                 fill2DArray(array);
 928                 break;
 929             case MT_3D_4x4:
 930                 array[12] = 0.0;
 931                 array[13] = 0.0;
 932                 array[14] = 0.0;
 933                 array[15] = 1.0;
 934                 // fall-through
 935             case MT_3D_3x4:
 936                 fill3DArray(array);
 937                 break;
 938             default:
 939                 throw new InternalError(&quot;Unsupported matrix type &quot; + type);
 940         }
 941 
 942         return array;
 943     }
 944 
 945     /**
 946      * Returns an array containing the flattened transformation matrix.
 947      * @param type matrix type to be filled in the array
 948      * @return an array containing the elements of the requested matrix type
 949      *         representing this transform
 950      * @throws IllegalArgumentException if a 2D matrix type is requested for
 951      *         a 3D transform
 952      * @throws NullPointerException if the specified {@code type} is null
 953      * @since JavaFX 8.0
 954      */
 955     public double[] toArray(MatrixType type) {
 956         return toArray(type, null);
 957     }
 958 
 959     /**
 960      * Returns an array containing a row of the transformation matrix.
 961      * If the row of the requested matrix type fits in the specified array,
 962      * it is returned therein. Otherwise, a new array is created.
 963      * @param type matrix type whose row is to be filled in the array
 964      * @param row zero-based index of the row
 965      * @param array array into which the elements of the row are to be
 966      *              stored, if it is non-null and big enough; otherwise,
 967      *              a new array is created for this purpose.
 968      * @return an array containing the requested row of the requested matrix
 969      *         type representing this transform
 970      * @throws IllegalArgumentException if a 2D matrix type is requested for
 971      *         a 3D transform
 972      * @throws IndexOutOfBoundsException if the {@code row} index is not within
 973      *         the number of rows of the specified matrix type
 974      * @throws NullPointerException if the specified {@code type} is null
 975      * @since JavaFX 8.0
 976      */
 977     public double[] row(MatrixType type, int row, double[] array) {
 978 
 979         checkRequestedMAT(type);
 980 
 981         if (row &lt; 0 || row &gt;= type.rows()) {
 982             throw new IndexOutOfBoundsException(
 983                     &quot;Cannot get row &quot; + row + &quot; from &quot; + type);
 984         }
 985 
 986         if (array == null || array.length &lt; type.columns()) {
 987             array = new double[type.columns()];
 988         }
 989 
 990         switch(type) {
 991             case MT_2D_2x3:
 992             case MT_2D_3x3:
 993                 switch (row) {
 994                     case 0:
 995                         array[0] = getMxx();
 996                         array[1] = getMxy();
 997                         array[2] = getTx();
 998                         break;
 999                     case 1:
1000                         array[0] = getMyx();
1001                         array[1] = getMyy();
1002                         array[2] = getTy();
1003                         break;
1004                     case 2:
1005                         array[0] = 0.0;
1006                         array[1] = 0.0;
1007                         array[2] = 1.0;
1008                         break;
1009                 }
1010                 break;
1011             case MT_3D_3x4:
1012             case MT_3D_4x4:
1013                 switch (row) {
1014                     case 0:
1015                         array[0] = getMxx();
1016                         array[1] = getMxy();
1017                         array[2] = getMxz();
1018                         array[3] = getTx();
1019                         break;
1020                     case 1:
1021                         array[0] = getMyx();
1022                         array[1] = getMyy();
1023                         array[2] = getMyz();
1024                         array[3] = getTy();
1025                         break;
1026                     case 2:
1027                         array[0] = getMzx();
1028                         array[1] = getMzy();
1029                         array[2] = getMzz();
1030                         array[3] = getTz();
1031                         break;
1032                     case 3:
1033                         array[0] = 0.0;
1034                         array[1] = 0.0;
1035                         array[2] = 0.0;
1036                         array[3] = 1.0;
1037                         break;
1038                 }
1039                 break;
1040             default:
1041                 throw new InternalError(&quot;Unsupported row &quot; + row + &quot; of &quot; + type);
1042         }
1043         return array;
1044     }
1045 
1046     /**
1047      * Returns an array containing a row of the transformation matrix.
1048      * @param type matrix type whose row is to be filled in the array
1049      * @param row zero-based index of the row
1050      * @return an array containing the requested row of the requested matrix
1051      *         type representing this transform
1052      * @throws IllegalArgumentException if a 2D matrix type is requested for
1053      *         a 3D transform
1054      * @throws IndexOutOfBoundsException if the {@code row} index is not within
1055      *         the number of rows of the specified matrix type
1056      * @throws NullPointerException if the specified {@code type} is null
1057      * @since JavaFX 8.0
1058      */
1059     public double[] row(MatrixType type, int row) {
1060         return row(type, row, null);
1061     }
1062 
1063     /**
1064      * Returns an array containing a column of the transformation matrix.
1065      * If the column of the requested matrix type fits in the specified array,
1066      * it is returned therein. Otherwise, a new array is created.
1067      * @param type matrix type whose column is to be filled in the array
1068      * @param column zero-based index of the column
1069      * @param array array into which the elements of the column are to be
1070      *              stored, if it is non-null and big enough; otherwise,
1071      *              a new array is created for this purpose.
1072      * @return an array containing the requested column of the requested matrix
1073      *         type representing this transform
1074      * @throws IllegalArgumentException if a 2D matrix type is requested for
1075      *         a 3D transform
1076      * @throws IndexOutOfBoundsException if the {@code column} index
1077      *         is not within the number of columns of the specified matrix type
1078      * @throws NullPointerException if the specified {@code type} is null
1079      * @since JavaFX 8.0
1080      */
1081     public double[] column(MatrixType type, int column, double[] array) {
1082 
1083         checkRequestedMAT(type);
1084 
1085         if (column &lt; 0 || column &gt;= type.columns()) {
1086             throw new IndexOutOfBoundsException(
1087                     &quot;Cannot get row &quot; + column + &quot; from &quot; + type);
1088         }
1089 
1090         if (array == null || array.length &lt; type.rows()) {
1091             array = new double[type.rows()];
1092         }
1093 
1094         switch(type) {
1095             case MT_2D_2x3:
1096                 switch (column) {
1097                     case 0:
1098                         array[0] = getMxx();
1099                         array[1] = getMyx();
1100                         break;
1101                     case 1:
1102                         array[0] = getMxy();
1103                         array[1] = getMyy();
1104                         break;
1105                     case 2:
1106                         array[0] = getTx();
1107                         array[1] = getTy();
1108                         break;
1109                 }
1110                 break;
1111             case MT_2D_3x3:
1112                 switch (column) {
1113                     case 0:
1114                         array[0] = getMxx();
1115                         array[1] = getMyx();
1116                         array[2] = 0.0;
1117                         break;
1118                     case 1:
1119                         array[0] = getMxy();
1120                         array[1] = getMyy();
1121                         array[2] = 0.0;
1122                         break;
1123                     case 2:
1124                         array[0] = getTx();
1125                         array[1] = getTy();
1126                         array[2] = 1.0;
1127                         break;
1128                 }
1129                 break;
1130             case MT_3D_3x4:
1131                 switch (column) {
1132                     case 0:
1133                         array[0] = getMxx();
1134                         array[1] = getMyx();
1135                         array[2] = getMzx();
1136                         break;
1137                     case 1:
1138                         array[0] = getMxy();
1139                         array[1] = getMyy();
1140                         array[2] = getMzy();
1141                         break;
1142                     case 2:
1143                         array[0] = getMxz();
1144                         array[1] = getMyz();
1145                         array[2] = getMzz();
1146                         break;
1147                     case 3:
1148                         array[0] = getTx();
1149                         array[1] = getTy();
1150                         array[2] = getTz();
1151                         break;
1152                 }
1153                 break;
1154             case MT_3D_4x4:
1155                 switch (column) {
1156                     case 0:
1157                         array[0] = getMxx();
1158                         array[1] = getMyx();
1159                         array[2] = getMzx();
1160                         array[3] = 0.0;
1161                         break;
1162                     case 1:
1163                         array[0] = getMxy();
1164                         array[1] = getMyy();
1165                         array[2] = getMzy();
1166                         array[3] = 0.0;
1167                         break;
1168                     case 2:
1169                         array[0] = getMxz();
1170                         array[1] = getMyz();
1171                         array[2] = getMzz();
1172                         array[3] = 0.0;
1173                         break;
1174                     case 3:
1175                         array[0] = getTx();
1176                         array[1] = getTy();
1177                         array[2] = getTz();
1178                         array[3] = 1.0;
1179                         break;
1180                 }
1181                 break;
1182             default:
1183                 throw new InternalError(&quot;Unsupported column &quot; + column + &quot; of &quot;
1184                         + type);
1185         }
1186         return array;
1187     }
1188 
1189     /**
1190      * Returns an array containing a column of the transformation matrix.
1191      * @param type matrix type whose column is to be filled in the array
1192      * @param column zero-based index of the column
1193      * @return an array containing the requested column of the requested matrix
1194      *         type representing this transform
1195      * @throws IllegalArgumentException if a 2D matrix type is requested for
1196      *         a 3D transform
1197      * @throws IndexOutOfBoundsException if the {@code column} index
1198      *         is not within the number of columns of the specified matrix type
1199      * @throws NullPointerException if the specified {@code type} is null
1200      * @since JavaFX 8.0
1201      */
1202     public double[] column(MatrixType type, int column) {
1203         return column(type, column, null);
1204     }
1205 
1206     /* *************************************************************************
1207      *                                                                         *
1208      *                         Transform creators                              *
1209      *                                                                         *
1210      **************************************************************************/
1211 
1212     /**
1213      * Returns the concatenation of this transform and the specified transform.
1214      * Applying the resulting transform to a node has the same effect as
1215      * adding the two transforms to its {@code getTransforms()} list,
1216      * {@code this} transform first and the specified {@code transform} second.
1217      * @param transform transform to be concatenated with this transform
1218      * @return The concatenated transform
1219      * @throws NullPointerException if the specified {@code transform} is null
1220      * @since JavaFX 8.0
1221      */
1222     public Transform createConcatenation(Transform transform) {
1223         final double txx = transform.getMxx();
1224         final double txy = transform.getMxy();
1225         final double txz = transform.getMxz();
1226         final double ttx = transform.getTx();
1227         final double tyx = transform.getMyx();
1228         final double tyy = transform.getMyy();
1229         final double tyz = transform.getMyz();
1230         final double tty = transform.getTy();
1231         final double tzx = transform.getMzx();
1232         final double tzy = transform.getMzy();
1233         final double tzz = transform.getMzz();
1234         final double ttz = transform.getTz();
1235         return new Affine(
1236             (getMxx() * txx + getMxy() * tyx + getMxz() * tzx),
1237             (getMxx() * txy + getMxy() * tyy + getMxz() * tzy),
1238             (getMxx() * txz + getMxy() * tyz + getMxz() * tzz),
1239             (getMxx() * ttx + getMxy() * tty + getMxz() * ttz + getTx()),
1240             (getMyx() * txx + getMyy() * tyx + getMyz() * tzx),
1241             (getMyx() * txy + getMyy() * tyy + getMyz() * tzy),
1242             (getMyx() * txz + getMyy() * tyz + getMyz() * tzz),
1243             (getMyx() * ttx + getMyy() * tty + getMyz() * ttz + getTy()),
1244             (getMzx() * txx + getMzy() * tyx + getMzz() * tzx),
1245             (getMzx() * txy + getMzy() * tyy + getMzz() * tzy),
1246             (getMzx() * txz + getMzy() * tyz + getMzz() * tzz),
1247             (getMzx() * ttx + getMzy() * tty + getMzz() * ttz + getTz()));
1248     }
1249 
1250     /**
1251      * Returns the inverse transform of this transform.
1252      * @return the inverse transform
1253      * @throws NonInvertibleTransformException if this transform
1254      *         cannot be inverted
1255      * @since JavaFX 8.0
1256      */
1257     public Transform createInverse() throws NonInvertibleTransformException {
1258         return getInverseCache().clone();
1259     }
1260 
1261     /**
1262      * Returns a deep copy of this transform.
1263      * @return a copy of this transform
1264      * @since JavaFX 8.0
1265      */
1266     @Override
1267     public Transform clone() {
1268         return TransformUtils.immutableTransform(this);
1269     }
1270 
1271     /* *************************************************************************
1272      *                                                                         *
1273      *                     Transform, Inverse Transform                        *
1274      *                                                                         *
1275      **************************************************************************/
1276 
1277     /**
1278      * Transforms the specified point by this transform.
1279      * This method can be used only for 2D transforms.
1280      * @param x the X coordinate of the point
1281      * @param y the Y coordinate of the point
1282      * @return the transformed point
1283      * @throws IllegalStateException if this is a 3D transform
1284      * @since JavaFX 8.0
1285      */
1286     public Point2D transform(double x, double y) {
1287         ensureCanTransform2DPoint();
1288 
1289         return new Point2D(
1290             getMxx() * x + getMxy() * y + getTx(),
1291             getMyx() * x + getMyy() * y + getTy());
1292     }
1293 
1294     /**
1295      * Transforms the specified point by this transform.
1296      * This method can be used only for 2D transforms.
1297      * @param point the point to be transformed
1298      * @return the transformed point
1299      * @throws IllegalStateException if this is a 3D transform
1300      * @throws NullPointerException if the specified {@code point} is null
1301      * @since JavaFX 8.0
1302      */
1303     public Point2D transform(Point2D point) {
1304         return transform(point.getX(), point.getY());
1305     }
1306 
1307     /**
1308      * Transforms the specified point by this transform.
1309      * @param x the X coordinate of the point
1310      * @param y the Y coordinate of the point
1311      * @param z the Z coordinate of the point
1312      * @return the transformed point
1313      * @since JavaFX 8.0
1314      */
1315     public Point3D transform(double x, double y, double z) {
1316         return new Point3D(
1317             getMxx() * x + getMxy() * y + getMxz() * z + getTx(),
1318             getMyx() * x + getMyy() * y + getMyz() * z + getTy(),
1319             getMzx() * x + getMzy() * y + getMzz() * z + getTz());
1320     }
1321 
1322     /**
1323      * Transforms the specified point by this transform.
1324      * @param point the point to be transformed
1325      * @return the transformed point
1326      * @throws NullPointerException if the specified {@code point} is null
1327      * @since JavaFX 8.0
1328      */
1329     public Point3D transform(Point3D point) {
1330         return transform(point.getX(), point.getY(), point.getZ());
1331     }
1332 
1333     /**
1334      * Transforms the specified bounds by this transform.
1335      * @param bounds the bounds to be transformed
1336      * @return the transformed bounds
1337      * @since JavaFX 8.0
1338      */
1339     public Bounds transform(Bounds bounds) {
1340         if (isType2D() &amp;&amp; (bounds.getMinZ() == 0) &amp;&amp; (bounds.getMaxZ() == 0)) {
1341             Point2D p1 = transform(bounds.getMinX(), bounds.getMinY());
1342             Point2D p2 = transform(bounds.getMaxX(), bounds.getMinY());
1343             Point2D p3 = transform(bounds.getMaxX(), bounds.getMaxY());
1344             Point2D p4 = transform(bounds.getMinX(), bounds.getMaxY());
1345 
1346             return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
1347         }
1348         Point3D p1 = transform(bounds.getMinX(), bounds.getMinY(), bounds.getMinZ());
1349         Point3D p2 = transform(bounds.getMinX(), bounds.getMinY(), bounds.getMaxZ());
1350         Point3D p3 = transform(bounds.getMinX(), bounds.getMaxY(), bounds.getMinZ());
1351         Point3D p4 = transform(bounds.getMinX(), bounds.getMaxY(), bounds.getMaxZ());
1352         Point3D p5 = transform(bounds.getMaxX(), bounds.getMaxY(), bounds.getMinZ());
1353         Point3D p6 = transform(bounds.getMaxX(), bounds.getMaxY(), bounds.getMaxZ());
1354         Point3D p7 = transform(bounds.getMaxX(), bounds.getMinY(), bounds.getMinZ());
1355         Point3D p8 = transform(bounds.getMaxX(), bounds.getMinY(), bounds.getMaxZ());
1356 
1357         return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
1358     }
1359 
1360     /**
1361      * Core of the transform2DPoints method.
1362      * All the checks has been performed and the care of the overlaps has been
1363      * taken by the enclosing method, this method only transforms the points
1364      * and fills them to the array. Used by the subclasses to perform
1365      * the transform efficiently.
1366      */
1367     void transform2DPointsImpl(double[] srcPts, int srcOff,
1368             double[] dstPts, int dstOff, int numPts) {
1369         final double xx = getMxx();
1370         final double xy = getMxy();
1371         final double tx = getTx();
1372         final double yx = getMyx();
1373         final double yy = getMyy();
1374         final double ty = getTy();
1375 
1376         while (--numPts &gt;= 0) {
1377             final double x = srcPts[srcOff++];
1378             final double y = srcPts[srcOff++];
1379 
1380             dstPts[dstOff++] = xx * x + xy * y + tx;
1381             dstPts[dstOff++] = yx * x + yy * y + ty;
1382         }
1383     }
1384 
1385     /**
1386      * Core of the transform3DPoints method.
1387      * All the checks has been performed and the care of the overlaps has been
1388      * taken by the enclosing method, this method only transforms the points
1389      * and fills them to the array. Used by the subclasses to perform
1390      * the transform efficiently.
1391      */
1392     void transform3DPointsImpl(double[] srcPts, int srcOff,
1393             double[] dstPts, int dstOff, int numPts) {
1394 
1395         final double xx = getMxx();
1396         final double xy = getMxy();
1397         final double xz = getMxz();
1398         final double tx = getTx();
1399         final double yx = getMyx();
1400         final double yy = getMyy();
1401         final double yz = getMyz();
1402         final double ty = getTy();
1403         final double zx = getMzx();
1404         final double zy = getMzy();
1405         final double zz = getMzz();
1406         final double tz = getTz();
1407 
1408         while (--numPts &gt;= 0) {
1409             final double x = srcPts[srcOff++];
1410             final double y = srcPts[srcOff++];
1411             final double z = srcPts[srcOff++];
1412 
1413             dstPts[dstOff++] = xx * x + xy * y + xz * z + tx;
1414             dstPts[dstOff++] = yx * x + yy * y + yz * z + ty;
1415             dstPts[dstOff++] = zx * x + zy * y + zz * z + tz;
1416         }
1417     }
1418 
1419     /**
1420      * Transforms an array of coordinates by this transform.
1421      * The two coordinate array sections can be exactly the same or
1422      * can be overlapping sections of the same array without affecting the
1423      * validity of the results.
1424      * This method ensures that no source coordinates are overwritten by a
1425      * previous operation before they can be transformed.
1426      * The coordinates are stored in the arrays starting at the specified
1427      * offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.
1428      * This method can be used only for 2D transforms.
1429      * @param srcPts the array containing the source point coordinates.
1430      * Each point is stored as a pair of x,&amp;nbsp;y coordinates.
1431      * @param srcOff the offset to the first point to be transformed
1432      * in the source array
1433      * @param dstPts the array into which the transformed point coordinates
1434      * are returned.  Each point is stored as a pair of x,&amp;nbsp;y
1435      * coordinates.
1436      * @param dstOff the offset to the location of the first
1437      * transformed point that is stored in the destination array
1438      * @param numPts the number of points to be transformed
1439      * @throws IllegalStateException if this is a 3D transform
1440      * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null
1441      * @since JavaFX 8.0
1442      */
1443     public void transform2DPoints(double[] srcPts, int srcOff,
1444                           double[] dstPts, int dstOff,
1445                           int numPts) {
1446 
1447         if (srcPts == null || dstPts == null) {
1448             throw new NullPointerException();
1449         }
1450 
1451         if (!isType2D()) {
1452             throw new IllegalStateException(&quot;Cannot transform 2D points &quot;
1453                     + &quot;with a 3D transform&quot;);
1454         }
1455 
1456         // deal with overlapping arrays
1457         srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 2);
1458 
1459         // do the transformations
1460         transform2DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);
1461     }
1462 
1463     /**
1464      * Transforms an array of floating point coordinates by this transform.
1465      * The three coordinate array sections can be exactly the same or
1466      * can be overlapping sections of the same array without affecting the
1467      * validity of the results.
1468      * This method ensures that no source coordinates are overwritten by a
1469      * previous operation before they can be transformed.
1470      * The coordinates are stored in the arrays starting at the specified
1471      * offset in the order &lt;code&gt;[x0, y0, z0, x1, y1, z1, ..., xn, yn, zn]&lt;/code&gt;.
1472      * @param srcPts the array containing the source point coordinates.
1473      * Each point is stored as a tiplet of x,&amp;nbsp;y,&amp;nbsp;z coordinates.
1474      * @param srcOff the offset to the first point to be transformed
1475      * in the source array
1476      * @param dstPts the array into which the transformed point coordinates
1477      * are returned.  Each point is stored as a triplet of x,&amp;nbsp;y,&amp;nbsp;z
1478      * coordinates.
1479      * @param dstOff the offset to the location of the first
1480      * transformed point that is stored in the destination array
1481      * @param numPts the number of points to be transformed
1482      * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null
1483      * @since JavaFX 8.0
1484      */
1485     public void transform3DPoints(double[] srcPts, int srcOff,
1486                           double[] dstPts, int dstOff,
1487                           int numPts) {
1488 
1489         if (srcPts == null || dstPts == null) {
1490             throw new NullPointerException();
1491         }
1492 
1493         // deal with overlapping arrays
1494         srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 3);
1495 
1496         // do the transformations
1497         transform3DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);
1498     }
1499 
1500     /**
1501      * Transforms the relative magnitude vector by this transform.
1502      * The vector is transformed without applying the translation components
1503      * of the affine transformation matrix.
1504      * This method can be used only for a 2D transform.
1505      * @param x vector magnitude in the direction of the X axis
1506      * @param y vector magnitude in the direction of the Y axis
1507      * @return the transformed relative magnitude vector represented
1508      *         by a {@code Point2D} instance
1509      * @throws IllegalStateException if this is a 3D transform
1510      * @since JavaFX 8.0
1511      */
1512     public Point2D deltaTransform(double x, double y) {
1513         ensureCanTransform2DPoint();
1514 
1515         return new Point2D(
1516             getMxx() * x + getMxy() * y,
1517             getMyx() * x + getMyy() * y);
1518     }
1519 
1520     /**
1521      * Transforms the relative magnitude vector represented by the specified
1522      * {@code Point2D} instance by this transform.
1523      * The vector is transformed without applying the translation components
1524      * of the affine transformation matrix.
1525      * This method can be used only for a 2D transform.
1526      * @param point the relative magnitude vector
1527      * @return the transformed relative magnitude vector represented
1528      *         by a {@code Point2D} instance
1529      * @throws IllegalStateException if this is a 3D transform
1530      * @throws NullPointerException if the specified {@code point} is null
1531      * @since JavaFX 8.0
1532      */
1533     public Point2D deltaTransform(Point2D point) {
1534         return deltaTransform(point.getX(), point.getY());
1535     }
1536 
1537     /**
1538      * Transforms the relative magnitude vector by this transform.
1539      * The vector is transformed without applying the translation components
1540      * of the affine transformation matrix.
1541      * @param x vector magnitude in the direction of the X axis
1542      * @param y vector magnitude in the direction of the Y axis
1543      * @param z vector magnitude in the direction of the Z axis
1544      * @return the transformed relative magnitude vector represented
1545      *         by a {@code Point3D} instance
1546      * @since JavaFX 8.0
1547      */
1548     public Point3D deltaTransform(double x, double y, double z) {
1549         return new Point3D(
1550             getMxx() * x + getMxy() * y + getMxz() * z,
1551             getMyx() * x + getMyy() * y + getMyz() * z,
1552             getMzx() * x + getMzy() * y + getMzz() * z);
1553     }
1554 
1555     /**
1556      * Transforms the relative magnitude vector represented by the specified
1557      * {@code Point3D} instance by this transform.
1558      * The vector is transformed without applying the translation components
1559      * of the affine transformation matrix.
1560      * @param point the relative magnitude vector
1561      * @return the transformed relative magnitude vector represented
1562      *         by a {@code Point3D} instance
1563      * @throws NullPointerException if the specified {@code point} is null
1564      * @since JavaFX 8.0
1565      */
1566     public Point3D deltaTransform(Point3D point) {
1567         return deltaTransform(point.getX(), point.getY(), point.getZ());
1568     }
1569 
1570     /**
1571      * Transforms the specified point by the inverse of this transform.
1572      * This method can be used only for 2D transforms.
1573      * @param x the X coordinate of the point
1574      * @param y the Y coordinate of the point
1575      * @return the inversely transformed point
1576      * @throws IllegalStateException if this is a 3D transform
1577      * @throws NonInvertibleTransformException if this transform
1578      *         cannot be inverted
1579      * @since JavaFX 8.0
1580      */
1581     public Point2D inverseTransform(double x, double y)
1582             throws NonInvertibleTransformException {
1583 
1584         ensureCanTransform2DPoint();
1585 
1586         return getInverseCache().transform(x, y);
1587     }
1588 
1589     /**
1590      * Transforms the specified point by the inverse of this transform.
1591      * This method can be used only for 2D transforms.
1592      * @param point the point to be transformed
1593      * @return the inversely transformed point
1594      * @throws IllegalStateException if this is a 3D transform
1595      * @throws NonInvertibleTransformException if this transform
1596      *         cannot be inverted
1597      * @throws NullPointerException if the specified {@code point} is null
1598      * @since JavaFX 8.0
1599      */
1600     public Point2D inverseTransform(Point2D point)
1601             throws NonInvertibleTransformException {
1602         return inverseTransform(point.getX(), point.getY());
1603     }
1604 
1605     /**
1606      * Transforms the specified point by the inverse of this transform.
1607      * @param x the X coordinate of the point
1608      * @param y the Y coordinate of the point
1609      * @param z the Z coordinate of the point
1610      * @return the inversely transformed point
1611      * @throws NonInvertibleTransformException if this transform
1612      *         cannot be inverted
1613      * @since JavaFX 8.0
1614      */
1615     public Point3D inverseTransform(double x, double y, double z)
1616             throws NonInvertibleTransformException {
1617 
1618         return getInverseCache().transform(x, y, z);
1619     }
1620 
1621     /**
1622      * Transforms the specified point by the inverse of this transform.
1623      * @param point the point to be transformed
1624      * @return the inversely transformed point
1625      * @throws NonInvertibleTransformException if this transform
1626      *         cannot be inverted
1627      * @throws NullPointerException if the specified {@code point} is null
1628      * @since JavaFX 8.0
1629      */
1630     public Point3D inverseTransform(Point3D point)
1631             throws NonInvertibleTransformException {
1632         return inverseTransform(point.getX(), point.getY(), point.getZ());
1633     }
1634 
1635     /**
1636      * Transforms the specified bounds by the inverse of this transform.
1637      * @param bounds the bounds to be transformed
1638      * @return the inversely transformed bounds
1639      * @throws NonInvertibleTransformException if this transform
1640      *         cannot be inverted
1641      * @throws NullPointerException if the specified {@code bounds} is null
1642      * @since JavaFX 8.0
1643      */
1644     public Bounds inverseTransform(Bounds bounds)
1645             throws NonInvertibleTransformException {
1646         if (isType2D() &amp;&amp; (bounds.getMinZ() == 0) &amp;&amp; (bounds.getMaxZ() == 0)) {
1647             Point2D p1 = inverseTransform(bounds.getMinX(), bounds.getMinY());
1648             Point2D p2 = inverseTransform(bounds.getMaxX(), bounds.getMinY());
1649             Point2D p3 = inverseTransform(bounds.getMaxX(), bounds.getMaxY());
1650             Point2D p4 = inverseTransform(bounds.getMinX(), bounds.getMaxY());
1651 
1652             return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
1653         }
1654         Point3D p1 = inverseTransform(bounds.getMinX(), bounds.getMinY(), bounds.getMinZ());
1655         Point3D p2 = inverseTransform(bounds.getMinX(), bounds.getMinY(), bounds.getMaxZ());
1656         Point3D p3 = inverseTransform(bounds.getMinX(), bounds.getMaxY(), bounds.getMinZ());
1657         Point3D p4 = inverseTransform(bounds.getMinX(), bounds.getMaxY(), bounds.getMaxZ());
1658         Point3D p5 = inverseTransform(bounds.getMaxX(), bounds.getMaxY(), bounds.getMinZ());
1659         Point3D p6 = inverseTransform(bounds.getMaxX(), bounds.getMaxY(), bounds.getMaxZ());
1660         Point3D p7 = inverseTransform(bounds.getMaxX(), bounds.getMinY(), bounds.getMinZ());
1661         Point3D p8 = inverseTransform(bounds.getMaxX(), bounds.getMinY(), bounds.getMaxZ());
1662 
1663         return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
1664 
1665     }
1666 
1667     /**
1668      * Core of the inverseTransform2DPoints method.
1669      * All the checks has been performed and the care of the overlaps has been
1670      * taken by the enclosing method, this method only transforms the points
1671      * and fills them to the array. Used by the subclasses to perform
1672      * the transform efficiently.
1673      */
1674     void inverseTransform2DPointsImpl(double[] srcPts, int srcOff,
1675             double[] dstPts, int dstOff, int numPts)
1676             throws NonInvertibleTransformException {
1677 
1678         getInverseCache().transform2DPointsImpl(srcPts, srcOff,
1679                 dstPts, dstOff, numPts);
1680     }
1681 
1682     /**
1683      * Core of the inverseTransform3DPoints method.
1684      * All the checks has been performed and the care of the overlaps has been
1685      * taken by the enclosing method, this method only transforms the points
1686      * and fills them to the array. Used by the subclasses to perform
1687      * the transform efficiently.
1688      */
1689     void inverseTransform3DPointsImpl(double[] srcPts, int srcOff,
1690             double[] dstPts, int dstOff, int numPts)
1691             throws NonInvertibleTransformException {
1692 
1693         getInverseCache().transform3DPointsImpl(srcPts, srcOff,
1694                 dstPts, dstOff, numPts);
1695     }
1696 
1697     /**
1698      * Transforms an array of coordinates by the inverse of this transform.
1699      * The two coordinate array sections can be exactly the same or
1700      * can be overlapping sections of the same array without affecting the
1701      * validity of the results.
1702      * This method ensures that no source coordinates are overwritten by a
1703      * previous operation before they can be transformed.
1704      * The coordinates are stored in the arrays starting at the specified
1705      * offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.
1706      * This method can be used only for 2D transforms.
1707      * @param srcPts the array containing the source point coordinates.
1708      * Each point is stored as a pair of x,&amp;nbsp;y coordinates.
1709      * @param srcOff the offset to the first point to be transformed
1710      * in the source array
1711      * @param dstPts the array into which the transformed point coordinates
1712      * are returned.  Each point is stored as a pair of x,&amp;nbsp;y
1713      * coordinates.
1714      * @param dstOff the offset to the location of the first
1715      * transformed point that is stored in the destination array
1716      * @param numPts the number of points to be transformed
1717      * @throws IllegalStateException if this is a 3D transform
1718      * @throws NonInvertibleTransformException if this transform
1719      *         cannot be inverted
1720      * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null
1721      * @since JavaFX 8.0
1722      */
1723     public void inverseTransform2DPoints(double[] srcPts, int srcOff,
1724                           double[] dstPts, int dstOff,
1725                           int numPts) throws NonInvertibleTransformException{
1726 
1727         if (srcPts == null || dstPts == null) {
1728             throw new NullPointerException();
1729         }
1730 
1731         if (!isType2D()) {
1732             throw new IllegalStateException(&quot;Cannot transform 2D points &quot;
1733                     + &quot;with a 3D transform&quot;);
1734         }
1735 
1736         // deal with overlapping arrays
1737         srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 2);
1738 
1739         // do the transformations
1740         inverseTransform2DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);
1741     }
1742 
1743     /**
1744      * Transforms an array of floating point coordinates by the inverse
1745      * of this transform.
1746      * The three coordinate array sections can be exactly the same or
1747      * can be overlapping sections of the same array without affecting the
1748      * validity of the results.
1749      * This method ensures that no source coordinates are overwritten by a
1750      * previous operation before they can be transformed.
1751      * The coordinates are stored in the arrays starting at the specified
1752      * offset in the order &lt;code&gt;[x0, y0, z0, x1, y1, z1, ..., xn, yn, zn]&lt;/code&gt;.
1753      * @param srcPts the array containing the source point coordinates.
1754      * Each point is stored as a triplet of x,&amp;nbsp;y,&amp;nbsp;z coordinates.
1755      * @param srcOff the offset to the first point to be transformed
1756      * in the source array
1757      * @param dstPts the array into which the transformed point coordinates
1758      * are returned.  Each point is stored as a triplet of x,&amp;nbsp;y,&amp;nbsp;z
1759      * coordinates.
1760      * @param dstOff the offset to the location of the first
1761      * transformed point that is stored in the destination array
1762      * @param numPts the number of points to be transformed
1763      * @throws NonInvertibleTransformException if this transform
1764      *         cannot be inverted
1765      * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null
1766      * @since JavaFX 8.0
1767      */
1768     public void inverseTransform3DPoints(double[] srcPts, int srcOff,
1769                           double[] dstPts, int dstOff,
1770                           int numPts) throws NonInvertibleTransformException {
1771 
1772         if (srcPts == null || dstPts == null) {
1773             throw new NullPointerException();
1774         }
1775 
1776         // deal with overlapping arrays
1777         srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 3);
1778 
1779         // do the transformations
1780         inverseTransform3DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);
1781     }
1782 
1783     /**
1784      * Transforms the relative magnitude vector by the inverse of this transform.
1785      * The vector is transformed without applying the translation components
1786      * of the affine transformation matrix.
1787      * This method can be used only for a 2D transform.
1788      * @param x vector magnitude in the direction of the X axis
1789      * @param y vector magnitude in the direction of the Y axis
1790      * @return the inversely transformed relative magnitude vector represented
1791      *         by a {@code Point2D} instance
1792      * @throws IllegalStateException if this is a 3D transform
1793      * @throws NonInvertibleTransformException if this transform
1794      *         cannot be inverted
1795      * @since JavaFX 8.0
1796      */
1797     public Point2D inverseDeltaTransform(double x, double y)
1798             throws NonInvertibleTransformException {
1799 
1800         ensureCanTransform2DPoint();
1801 
1802         return getInverseCache().deltaTransform(x, y);
1803     }
1804 
1805     /**
1806      * Transforms the relative magnitude vector represented by the specified
1807      * {@code Point2D} instance by the inverse of this transform.
1808      * The vector is transformed without applying the translation components
1809      * of the affine transformation matrix.
1810      * This method can be used only for a 2D transform.
1811      * @param point the relative magnitude vector
1812      * @return the inversely transformed relative magnitude vector represented
1813      *         by a {@code Point2D} instance
1814      * @throws IllegalStateException if this is a 3D transform
1815      * @throws NonInvertibleTransformException if this transform
1816      *         cannot be inverted
1817      * @throws NullPointerException if the specified {@code point} is null
1818      * @since JavaFX 8.0
1819      */
1820     public Point2D inverseDeltaTransform(Point2D point)
1821             throws NonInvertibleTransformException {
1822         return inverseDeltaTransform(point.getX(), point.getY());
1823     }
1824 
1825     /**
1826      * Transforms the relative magnitude vector by the inverse of this transform.
1827      * The vector is transformed without applying the translation components
1828      * of the affine transformation matrix.
1829      * @param x vector magnitude in the direction of the X axis
1830      * @param y vector magnitude in the direction of the Y axis
1831      * @param z vector magnitude in the direction of the Z axis
1832      * @return the inversely transformed relative magnitude vector represented
1833      *         by a {@code Point3D} instance
1834      * @throws NonInvertibleTransformException if this transform
1835      *         cannot be inverted
1836      * @since JavaFX 8.0
1837      */
1838     public Point3D inverseDeltaTransform(double x, double y, double z)
1839             throws NonInvertibleTransformException {
1840 
1841         return getInverseCache().deltaTransform(x, y, z);
1842     }
1843 
1844     /**
1845      * Transforms the relative magnitude vector represented by the specified
1846      * {@code Point3D} instance by the inverse of this transform.
1847      * The vector is transformed without applying the translation components
1848      * of the affine transformation matrix.
1849      * @param point the relative magnitude vector
1850      * @return the inversely transformed relative magnitude vector represented
1851      *         by a {@code Point3D} instance
1852      * @throws NonInvertibleTransformException if this transform
1853      *         cannot be inverted
1854      * @throws NullPointerException if the specified {@code point} is null
1855      * @since JavaFX 8.0
1856      */
1857     public Point3D inverseDeltaTransform(Point3D point)
1858             throws NonInvertibleTransformException {
1859         return inverseDeltaTransform(point.getX(), point.getY(), point.getZ());
1860     }
1861 
1862     /**
1863      * Helper method for transforming arrays of points that deals with
1864      * overlapping arrays.
1865      * @return the (if necessary fixed) srcOff
1866      */
1867     private int getFixedSrcOffset(double[] srcPts, int srcOff,
1868             double[] dstPts, int dstOff,
1869             int numPts, int dimensions) {
1870 
1871         if (dstPts == srcPts &amp;&amp;
1872             dstOff &gt; srcOff &amp;&amp; dstOff &lt; srcOff + numPts * dimensions)
1873         {
1874             // If the arrays overlap partially with the destination higher
1875             // than the source and we transform the coordinates normally
1876             // we would overwrite some of the later source coordinates
1877             // with results of previous transformations.
1878             // To get around this we use arraycopy to copy the points
1879             // to their final destination with correct overwrite
1880             // handling and then transform them in place in the new
1881             // safer location.
1882             System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * dimensions);
1883             return dstOff;
1884         }
1885 
1886         return srcOff;
1887     }
1888 
1889     /* *************************************************************************
1890      *                                                                         *
1891      *                         Event Dispatch                                  *
1892      *                                                                         *
1893      **************************************************************************/
1894 
1895     private EventHandlerManager internalEventDispatcher;
1896     private EventHandlerManager getInternalEventDispatcher() {
1897         if (internalEventDispatcher == null) {
1898             internalEventDispatcher = new EventHandlerManager(this);
1899         }
1900         return internalEventDispatcher;
1901     }
1902     private ObjectProperty&lt;EventHandler&lt;? super TransformChangedEvent&gt;&gt;
1903             onTransformChanged;
1904 
1905     @Override
1906     public EventDispatchChain buildEventDispatchChain(EventDispatchChain tail) {
1907         return internalEventDispatcher == null
1908                 ? tail : tail.append(getInternalEventDispatcher());
1909     }
1910 
1911     /**
1912      * &lt;p&gt;
1913      * Registers an event handler to this transform. Any event filters are first
1914      * processed, then the specified onFoo event handlers, and finally any
1915      * event handlers registered by this method.
1916      * &lt;/p&gt;&lt;p&gt;
1917      * Currently the only event delivered to a {@code Transform} is the
1918      * {@code TransformChangedEvent} with it&#39;s single type
1919      * {@code TRANSFORM_CHANGED}.
1920      * &lt;/p&gt;
1921      *
1922      * @param &lt;T&gt; the specific event class of the handler
1923      * @param eventType the type of the events to receive by the handler
1924      * @param eventHandler the handler to register
1925      * @throws NullPointerException if the event type or handler is null
1926      * @since JavaFX 8.0
1927      */
1928     public final &lt;T extends Event&gt; void addEventHandler(
1929             final EventType&lt;T&gt; eventType,
1930             final EventHandler&lt;? super T&gt; eventHandler) {
1931         getInternalEventDispatcher()
1932                 .addEventHandler(eventType, eventHandler);
1933         // need to validate all properties to get the change events
1934         validate();
1935     }
1936 
1937     /**
1938      * Unregisters a previously registered event handler from this transform.
1939      * One handler might have been registered for different event types, so the
1940      * caller needs to specify the particular event type from which to
1941      * unregister the handler.
1942      *
1943      * @param &lt;T&gt; the specific event class of the handler
1944      * @param eventType the event type from which to unregister
1945      * @param eventHandler the handler to unregister
1946      * @throws NullPointerException if the event type or handler is null
1947      * @since JavaFX 8.0
1948      */
1949     public final &lt;T extends Event&gt; void removeEventHandler(
1950             final EventType&lt;T&gt; eventType,
1951             final EventHandler&lt;? super T&gt; eventHandler) {
1952         getInternalEventDispatcher()
1953                 .removeEventHandler(eventType, eventHandler);
1954     }
1955 
1956     /**
1957      * &lt;p&gt;
1958      * Registers an event filter to this transform. Registered event filters get
1959      * an event before any associated event handlers.
1960      * &lt;/p&gt;&lt;p&gt;
1961      * Currently the only event delivered to a {@code Transform} is the
1962      * {@code TransformChangedEvent} with it&#39;s single type
1963      * {@code TRANSFORM_CHANGED}.
1964      *
1965      * @param &lt;T&gt; the specific event class of the filter
1966      * @param eventType the type of the events to receive by the filter
1967      * @param eventFilter the filter to register
1968      * @throws NullPointerException if the event type or filter is null
1969      * @since JavaFX 8.0
1970      */
1971     public final &lt;T extends Event&gt; void addEventFilter(
1972             final EventType&lt;T&gt; eventType,
1973             final EventHandler&lt;? super T&gt; eventFilter) {
1974         getInternalEventDispatcher()
1975                 .addEventFilter(eventType, eventFilter);
1976         // need to validate all properties to get the change events
1977         validate();
1978     }
1979 
1980     /**
1981      * Unregisters a previously registered event filter from this transform. One
1982      * filter might have been registered for different event types, so the
1983      * caller needs to specify the particular event type from which to
1984      * unregister the filter.
1985      *
1986      * @param &lt;T&gt; the specific event class of the filter
1987      * @param eventType the event type from which to unregister
1988      * @param eventFilter the filter to unregister
1989      * @throws NullPointerException if the event type or filter is null
1990      * @since JavaFX 8.0
1991      */
1992     public final &lt;T extends Event&gt; void removeEventFilter(
1993             final EventType&lt;T&gt; eventType,
1994             final EventHandler&lt;? super T&gt; eventFilter) {
1995         getInternalEventDispatcher()
1996                 .removeEventFilter(eventType, eventFilter);
1997     }
1998 
1999     /**
2000      * Sets the onTransformChanged event handler which is called whenever
2001      * the transform changes any of its parameters.
2002      *
2003      * @param value the event handler, can be null to clear it
2004      * @since JavaFX 8.0
2005      */
2006     public final void setOnTransformChanged(
2007             EventHandler&lt;? super TransformChangedEvent&gt; value) {
2008         onTransformChangedProperty().set(value);
2009         // need to validate all properties to get the change events
2010         validate();
2011     }
2012 
2013     /**
2014      * Gets the onTransformChanged event handler.
2015      * @return the event handler previously set by {@code setOnTransformChanged}
2016      * method, null if the handler is not set.
2017      * @since JavaFX 8.0
2018      */
2019     public final EventHandler&lt;? super TransformChangedEvent&gt; getOnTransformChanged() {
2020         return (onTransformChanged == null) ? null : onTransformChanged.get();
2021     }
2022 
2023     /**
2024      * The onTransformChanged event handler is called whenever the transform
2025      * changes any of its parameters.
2026      * @return the onTransformChanged event handler
2027      * @since JavaFX 8.0
2028      */
2029     public final ObjectProperty&lt;EventHandler&lt;? super TransformChangedEvent&gt;&gt;
2030             onTransformChangedProperty() {
2031         if (onTransformChanged == null) {
2032 
2033             onTransformChanged = new SimpleObjectProperty&lt;EventHandler
2034                     &lt;? super TransformChangedEvent&gt;&gt;(this, &quot;onTransformChanged&quot;) {
2035 
2036                 @Override protected void invalidated() {
2037                     getInternalEventDispatcher().setEventHandler(
2038                             TransformChangedEvent.TRANSFORM_CHANGED, get());
2039                 }
2040             };
2041         }
2042 
2043         return onTransformChanged;
2044     }
2045 
2046     /* *************************************************************************
2047      *                                                                         *
2048      *                    Internal implementation stuff                        *
2049      *                                                                         *
2050      **************************************************************************/
2051 
2052     /**
2053      * Makes sure the specified matrix type can be requested from this transform.
2054      * Is used for convenience in various methods that accept
2055      * the MatrixType argument.
2056      * @param type matrix type to check
2057      * @throws IllegalArgumentException if this is a 3D transform and
2058      *                                  a 2D type is requested
2059      */
2060     void checkRequestedMAT(MatrixType type) throws IllegalArgumentException{
2061         if (type.is2D() &amp;&amp; !isType2D()) {
2062             throw new IllegalArgumentException(&quot;Cannot access 2D matrix &quot;
2063                     + &quot;for a 3D transform&quot;);
2064         }
2065     }
2066 
2067     /**
2068      * Makes sure this is a 2D transform.
2069      * Is used for convenience in various 2D point transformation methods.
2070      * @throws IllegalStateException if this is a 2D transform
2071      */
2072     void ensureCanTransform2DPoint() throws IllegalStateException {
2073         if (!isType2D()) {
2074             throw new IllegalStateException(&quot;Cannot transform 2D point &quot;
2075                     + &quot;with a 3D transform&quot;);
2076         }
2077     }
2078 
2079     /**
2080      * Needed for the proper delivery of the TransformChangedEvent.
2081      * If the members are invalid, the transformChanged() notification
2082      * is not called and the event is not delivered. To avoid that
2083      * we need to manually validate all properties. Subclasses validate
2084      * their specific properties.
2085      */
2086     void validate() {
2087         getMxx(); getMxy(); getMxz(); getTx();
2088         getMyx(); getMyy(); getMyz(); getTy();
2089         getMzx(); getMzy(); getMzz(); getTz();
2090     }
2091 
2092     abstract void apply(Affine3D t);
2093 
2094     abstract BaseTransform derive(BaseTransform t);
2095 
2096     void add(final Node node) {
2097         nodes.add(node);
2098     }
2099 
2100     void remove(final Node node) {
2101         nodes.remove(node);
2102     }
2103 
2104     /**
2105      * This method must be called by all transforms whenever any of their
2106      * parameters changes. It is typically called when any of the transform&#39;s
2107      * properties is invalidated (it is OK to skip the call if an invalid
2108      * property is set).
2109      * @since JavaFX 8.0
2110      */
2111     protected void transformChanged() {
2112         inverseCache = null;
2113         final Iterator iterator = nodes.iterator();
2114         while (iterator.hasNext()) {
2115             NodeHelper.transformsChanged(((Node) iterator.next()));
2116         }
2117 
2118         if (type2D != null) {
2119             type2D.invalidate();
2120         }
2121 
2122         if (identity != null) {
2123             identity.invalidate();
2124         }
2125 
2126         if (internalEventDispatcher != null) {
2127             // need to validate all properties for the event to be fired next time
2128             validate();
2129             Event.fireEvent(this, new TransformChangedEvent(this, this));
2130         }
2131     }
2132 
2133     /**
2134      * Visitor from {@code Affine} class which provides an efficient
2135      * {@code append} operation for the subclasses.
2136      * @param a {@code Affine} instance to append to
2137      */
2138     void appendTo(Affine a) {
2139         a.append(getMxx(), getMxy(), getMxz(), getTx(),
2140                  getMyx(), getMyy(), getMyz(), getTy(),
2141                  getMzx(), getMzy(), getMzz(), getTz());
2142     }
2143 
2144     /**
2145      * Visitor from {@code Affine} class which provides an efficient
2146      * {@code prepend} operation for the subclasses.
2147      * @param a {@code Affine} instance to prepend to
2148      */
2149     void prependTo(Affine a) {
2150         a.prepend(getMxx(), getMxy(), getMxz(), getTx(),
2151                   getMyx(), getMyy(), getMyz(), getTy(),
2152                   getMzx(), getMzy(), getMzz(), getTz());
2153     }
2154 
2155     /**
2156      * &lt;p&gt;
2157      * Gets the inverse transform cache.
2158      * &lt;/p&gt;&lt;p&gt;
2159      * Computing the inverse transform is generally an expensive operation,
2160      * so once it is needed we cache the result (throwing it away when the
2161      * transform changes). The subclasses may avoid using the cache if their
2162      * inverse can be computed quickly on the fly.
2163      * &lt;/p&gt;&lt;p&gt;
2164      * This method computes the inverse if the cache is not valid.
2165      * &lt;/p&gt;
2166      * @return the cached inverse transformation
2167      * @throws NonInvertibleTransformException if this transform
2168      *         cannot be inverted
2169      */
2170     private Transform getInverseCache() throws NonInvertibleTransformException {
2171         if (inverseCache == null || inverseCache.get() == null) {
2172             Affine inv = new Affine(
2173                     getMxx(), getMxy(), getMxz(), getTx(),
2174                     getMyx(), getMyy(), getMyz(), getTy(),
2175                     getMzx(), getMzy(), getMzz(), getTz());
2176             inv.invert();
2177             inverseCache = new SoftReference&lt;Transform&gt;(inv);
2178             return inv;
2179         }
2180 
2181         return inverseCache.get();
2182     }
2183 
2184     /**
2185      * Used only by tests to emulate garbage collecting the soft references
2186      */
2187     void clearInverseCache() {
2188         if (inverseCache != null) {
2189             inverseCache.clear();
2190         }
2191     }
2192 
2193     /**************************************************************************
2194      *  ImmutableTransform Class and supporting methods
2195      **************************************************************************/
2196 
2197     static Transform createImmutableTransform() {
2198         return new ImmutableTransform();
2199     }
2200 
2201     static Transform createImmutableTransform(
2202             double mxx, double mxy, double mxz, double tx,
2203             double myx, double myy, double myz, double ty,
2204             double mzx, double mzy, double mzz, double tz) {
2205         return new ImmutableTransform(
2206                 mxx, mxy, mxz, tx,
2207                 myx, myy, myz, ty,
2208                 mzx, mzy, mzz, tz);
2209     }
2210 
2211     static Transform createImmutableTransform(Transform transform,
2212             double mxx, double mxy, double mxz, double tx,
2213             double myx, double myy, double myz, double ty,
2214             double mzx, double mzy, double mzz, double tz) {
2215         if (transform == null) {
2216             return new ImmutableTransform(
2217                     mxx, mxy, mxz, tx,
2218                     myx, myy, myz, ty,
2219                     mzx, mzy, mzz, tz);
2220         }
2221         ((Transform.ImmutableTransform) transform).setToTransform(
2222                 mxx, mxy, mxz, tx,
2223                 myx, myy, myz, ty,
2224                 mzx, mzy, mzz, tz);
2225         return transform;
2226     }
2227 
2228     static Transform createImmutableTransform(Transform transform,
2229             Transform left, Transform right) {
2230         if (transform == null) {
2231             transform = new ImmutableTransform();
2232         }
2233         ((Transform.ImmutableTransform) transform).setToConcatenation(
2234                 (ImmutableTransform) left, (ImmutableTransform) right);
2235         return transform;
2236     }
2237 
2238     /**
2239      * Immutable transformation with performance optimizations based on Affine.
2240      *
2241      * From user&#39;s perspective, this transform is immutable. However, we can
2242      * modify it internally. This allows for reusing instances that were
2243      * not handed to users. The caller is responsible for not modifying
2244      * user-visible instances.
2245      *
2246      * Note: can&#39;t override Transform&#39;s package private methods so they cannot
2247      * be optimized. Currently not a big deal.
2248      */
2249     static class ImmutableTransform extends Transform {
2250 
2251         private static final int APPLY_IDENTITY = 0;
2252         private static final int APPLY_TRANSLATE = 1;
2253         private static final int APPLY_SCALE = 2;
2254         private static final int APPLY_SHEAR = 4;
2255         private static final int APPLY_NON_3D = 0;
2256         private static final int APPLY_3D_COMPLEX = 4;
2257         private transient int state2d;
2258         private transient int state3d;
2259 
2260         private double xx;
2261         private double xy;
2262         private double xz;
2263         private double yx;
2264         private double yy;
2265         private double yz;
2266         private double zx;
2267         private double zy;
2268         private double zz;
2269         private double xt;
2270         private double yt;
2271         private double zt;
2272 
2273         ImmutableTransform() {
2274             xx = yy = zz = 1.0;
2275         }
2276 
2277         ImmutableTransform(Transform transform) {
2278             this(transform.getMxx(), transform.getMxy(), transform.getMxz(),
2279                                                                  transform.getTx(),
2280                  transform.getMyx(), transform.getMyy(), transform.getMyz(),
2281                                                                  transform.getTy(),
2282                  transform.getMzx(), transform.getMzy(), transform.getMzz(),
2283                                                                  transform.getTz());
2284         }
2285 
2286         ImmutableTransform(double mxx, double mxy, double mxz, double tx,
2287                       double myx, double myy, double myz, double ty,
2288                       double mzx, double mzy, double mzz, double tz) {
2289             xx = mxx;
2290             xy = mxy;
2291             xz = mxz;
2292             xt = tx;
2293 
2294             yx = myx;
2295             yy = myy;
2296             yz = myz;
2297             yt = ty;
2298 
2299             zx = mzx;
2300             zy = mzy;
2301             zz = mzz;
2302             zt = tz;
2303 
2304             updateState();
2305         }
2306 
2307         // Beware: this is modifying immutable transform!
2308         // It is private and it is there just for the purpose of reusing
2309         // instances not given to users
2310         private void setToTransform(double mxx, double mxy, double mxz, double tx,
2311                                     double myx, double myy, double myz, double ty,
2312                                     double mzx, double mzy, double mzz, double tz)
2313         {
2314             xx = mxx;
2315             xy = mxy;
2316             xz = mxz;
2317             xt = tx;
2318             yx = myx;
2319             yy = myy;
2320             yz = myz;
2321             yt = ty;
2322             zx = mzx;
2323             zy = mzy;
2324             zz = mzz;
2325             zt = tz;
2326             updateState();
2327         }
2328 
2329         // Beware: this is modifying immutable transform!
2330         // It is private and it is there just for the purpose of reusing
2331         // instances not given to users
2332         private void setToConcatenation(ImmutableTransform left, ImmutableTransform right) {
2333             if (left.state3d == APPLY_NON_3D &amp;&amp; right.state3d == APPLY_NON_3D) {
2334                 xx = left.xx * right.xx + left.xy * right.yx;
2335                 xy = left.xx * right.xy + left.xy * right.yy;
2336                 xt = left.xx * right.xt + left.xy * right.yt + left.xt;
2337                 yx = left.yx * right.xx + left.yy * right.yx;
2338                 yy = left.yx * right.xy + left.yy * right.yy;
2339                 yt = left.yx * right.xt + left.yy * right.yt + left.yt;
2340                 if (state3d != APPLY_NON_3D) {
2341                     xz = yz = zx = zy = zt = 0.0;
2342                     zz = 1.0;
2343                     state3d = APPLY_NON_3D;
2344                 }
2345                 updateState2D();
2346             } else {
2347                 xx = left.xx * right.xx + left.xy * right.yx + left.xz * right.zx;
2348                 xy = left.xx * right.xy + left.xy * right.yy + left.xz * right.zy;
2349                 xz = left.xx * right.xz + left.xy * right.yz + left.xz * right.zz;
2350                 xt = left.xx * right.xt + left.xy * right.yt + left.xz * right.zt + left.xt;
2351                 yx = left.yx * right.xx + left.yy * right.yx + left.yz * right.zx;
2352                 yy = left.yx * right.xy + left.yy * right.yy + left.yz * right.zy;
2353                 yz = left.yx * right.xz + left.yy * right.yz + left.yz * right.zz;
2354                 yt = left.yx * right.xt + left.yy * right.yt + left.yz * right.zt + left.yt;
2355                 zx = left.zx * right.xx + left.zy * right.yx + left.zz * right.zx;
2356                 zy = left.zx * right.xy + left.zy * right.yy + left.zz * right.zy;
2357                 zz = left.zx * right.xz + left.zy * right.yz + left.zz * right.zz;
2358                 zt = left.zx * right.xt + left.zy * right.yt + left.zz * right.zt + left.zt;
2359                 updateState();
2360             }
2361             // could be further optimized using the states, but that would
2362             // require a lot of code (see Affine and all its append* methods)
2363         }
2364 
2365         @Override
2366         public double getMxx() {
2367             return xx;
2368         }
2369 
2370         @Override
2371         public double getMxy() {
2372             return xy;
2373         }
2374 
2375         @Override
2376         public double getMxz() {
2377             return xz;
2378         }
2379 
2380         @Override
2381         public double getTx() {
2382             return xt;
2383         }
2384 
2385         @Override
2386         public double getMyx() {
2387             return yx;
2388         }
2389 
2390         @Override
2391         public double getMyy() {
2392             return yy;
2393         }
2394 
2395         @Override
2396         public double getMyz() {
2397             return yz;
2398         }
2399 
2400         @Override
2401         public double getTy() {
2402             return yt;
2403         }
2404 
2405         @Override
2406         public double getMzx() {
2407             return zx;
2408         }
2409 
2410         @Override
2411         public double getMzy() {
2412             return zy;
2413         }
2414 
2415         @Override
2416         public double getMzz() {
2417             return zz;
2418         }
2419 
2420         @Override
2421         public double getTz() {
2422             return zt;
2423         }
2424 
2425     /* *************************************************************************
2426      *                                                                         *
2427      *                           State getters                                 *
2428      *                                                                         *
2429      **************************************************************************/
2430 
2431         @Override
2432         public double determinant() {
2433             switch(state3d) {
2434                 default:
2435                     stateError();
2436                     // cannot reach
2437                 case APPLY_NON_3D:
2438                     switch (state2d) {
2439                         default:
2440                             stateError();
2441                             // cannot reach
2442                         case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
2443                         case APPLY_SHEAR | APPLY_SCALE:
2444                             return xx * yy - xy * yx;
2445                         case APPLY_SHEAR | APPLY_TRANSLATE:
2446                         case APPLY_SHEAR:
2447                             return -(xy* yx);
2448                         case APPLY_SCALE | APPLY_TRANSLATE:
2449                         case APPLY_SCALE:
2450                             return xx * yy;
2451                         case APPLY_TRANSLATE:
2452                         case APPLY_IDENTITY:
2453                             return 1.0;
2454                     }
2455                 case APPLY_TRANSLATE:
2456                     return 1.0;
2457                 case APPLY_SCALE:
2458                 case APPLY_SCALE | APPLY_TRANSLATE:
2459                     return xx * yy * zz;
2460                 case APPLY_3D_COMPLEX:
2461                     return (xx* (yy * zz - zy * yz) +
2462                             xy* (yz * zx - zz * yx) +
2463                             xz* (yx * zy - zx * yy));
2464             }
2465         }
2466 
2467         @Override
2468         public Transform createConcatenation(Transform transform) {
2469             javafx.scene.transform.Affine a = new Affine(this);
2470             a.append(transform);
2471             return a;
2472         }
2473 
2474         @Override
2475         public javafx.scene.transform.Affine createInverse() throws NonInvertibleTransformException {
2476             javafx.scene.transform.Affine t = new Affine(this);
2477             t.invert();
2478             return t;
2479         }
2480 
2481         @Override
2482         public Transform clone() {
2483             return new ImmutableTransform(this);
2484         }
2485 
2486         /* *************************************************************************
2487          *                                                                         *
2488          *                     Transform, Inverse Transform                        *
2489          *                                                                         *
2490          **************************************************************************/
2491 
2492         @Override
2493         public Point2D transform(double x, double y) {
2494             ensureCanTransform2DPoint();
2495 
2496             switch (state2d) {
2497                 default:
2498                     stateError();
2499                     // cannot reach
2500                 case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
2501                     return new Point2D(
2502                         xx * x + xy * y + xt,
2503                         yx * x + yy * y + yt);
2504                 case APPLY_SHEAR | APPLY_SCALE:
2505                     return new Point2D(
2506                         xx * x + xy * y,
2507                         yx * x + yy * y);
2508                 case APPLY_SHEAR | APPLY_TRANSLATE:
2509                     return new Point2D(
2510                             xy * y + xt,
2511                             yx * x + yt);
2512                 case APPLY_SHEAR:
2513                     return new Point2D(xy * y, yx * x);
2514                 case APPLY_SCALE | APPLY_TRANSLATE:
2515                     return new Point2D(
2516                             xx * x + xt,
2517                             yy * y + yt);
2518                 case APPLY_SCALE:
2519                     return new Point2D(xx * x, yy * y);
2520                 case APPLY_TRANSLATE:
2521                     return new Point2D(x + xt, y + yt);
2522                 case APPLY_IDENTITY:
2523                     return new Point2D(x, y);
2524             }
2525         }
2526 
2527         @Override
2528         public Point3D transform(double x, double y, double z) {
2529             switch (state3d) {
2530                 default:
2531                     stateError();
2532                     // cannot reach
2533                 case APPLY_NON_3D:
2534                     switch (state2d) {
2535                         default:
2536                             stateError();
2537                             // cannot reach
2538                         case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
2539                             return new Point3D(
2540                                 xx * x + xy * y + xt,
2541                                 yx * x + yy * y + yt, z);
2542                         case APPLY_SHEAR | APPLY_SCALE:
2543                             return new Point3D(
2544                                 xx * x + xy * y,
2545                                 yx * x + yy * y, z);
2546                         case APPLY_SHEAR | APPLY_TRANSLATE:
2547                             return new Point3D(
2548                                     xy * y + xt, yx * x + yt,
2549                                     z);
2550                         case APPLY_SHEAR:
2551                             return new Point3D(xy * y, yx * x, z);
2552                         case APPLY_SCALE | APPLY_TRANSLATE:
2553                             return new Point3D(
2554                                     xx * x + xt, yy * y + yt,
2555                                     z);
2556                         case APPLY_SCALE:
2557                             return new Point3D(xx * x, yy * y, z);
2558                         case APPLY_TRANSLATE:
2559                             return new Point3D(x + xt, y + yt, z);
2560                         case APPLY_IDENTITY:
2561                             return new Point3D(x, y, z);
2562                     }
2563                 case APPLY_TRANSLATE:
2564                     return new Point3D(x + xt, y + yt, z + zt);
2565                 case APPLY_SCALE:
2566                     return new Point3D(xx * x, yy * y, zz * z);
2567                 case APPLY_SCALE | APPLY_TRANSLATE:
2568                     return new Point3D(
2569                             xx * x + xt,
2570                             yy * y + yt,
2571                             zz * z + zt);
2572                 case APPLY_3D_COMPLEX:
2573                     return new Point3D(
2574                         xx * x + xy * y + xz * z + xt,
2575                         yx * x + yy * y + yz * z + yt,
2576                         zx * x + zy * y + zz * z + zt);
2577             }
2578         }
2579 
2580         @Override
2581         public Point2D deltaTransform(double x, double y) {
2582             ensureCanTransform2DPoint();
2583 
2584             switch (state2d) {
2585                 default:
2586                     stateError();
2587                     // cannot reach
2588                 case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
2589                 case APPLY_SHEAR | APPLY_SCALE:
2590                     return new Point2D(
2591                         xx * x + xy * y,
2592                         yx * x + yy * y);
2593                 case APPLY_SHEAR | APPLY_TRANSLATE:
2594                 case APPLY_SHEAR:
2595                     return new Point2D(xy * y, yx * x);
2596                 case APPLY_SCALE | APPLY_TRANSLATE:
2597                 case APPLY_SCALE:
2598                     return new Point2D(xx * x, yy * y);
2599                 case APPLY_TRANSLATE:
2600                 case APPLY_IDENTITY:
2601                     return new Point2D(x, y);
2602             }
2603         }
2604 
2605         @Override
2606         public Point3D deltaTransform(double x, double y, double z) {
2607             switch (state3d) {
2608                 default:
2609                     stateError();
2610                     // cannot reach
2611                 case APPLY_NON_3D:
2612                     switch (state2d) {
2613                         default:
2614                             stateError();
2615                             // cannot reach
2616                         case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
2617                         case APPLY_SHEAR | APPLY_SCALE:
2618                             return new Point3D(
2619                                 xx * x + xy * y,
2620                                 yx * x + yy * y, z);
2621                         case APPLY_SHEAR | APPLY_TRANSLATE:
2622                         case APPLY_SHEAR:
2623                             return new Point3D(xy * y, yx * x, z);
2624                         case APPLY_SCALE | APPLY_TRANSLATE:
2625                         case APPLY_SCALE:
2626                             return new Point3D(xx * x, yy * y, z);
2627                         case APPLY_TRANSLATE:
2628                         case APPLY_IDENTITY:
2629                             return new Point3D(x, y, z);
2630                     }
2631                 case APPLY_TRANSLATE:
2632                     return new Point3D(x, y, z);
2633                 case APPLY_SCALE:
2634                 case APPLY_SCALE | APPLY_TRANSLATE:
2635                     return new Point3D(xx * x, yy * y, zz * z);
2636                 case APPLY_3D_COMPLEX:
2637                     return new Point3D(
2638                         xx * x + xy * y + xz * z,
2639                         yx * x + yy * y + yz * z,
2640                         zx * x + zy * y + zz * z);
2641             }
2642         }
2643 
2644         @Override
2645         public Point2D inverseTransform(double x, double y)
2646                 throws NonInvertibleTransformException {
2647             ensureCanTransform2DPoint();
2648 
2649             switch (state2d) {
2650                 default:
2651                     return super.inverseTransform(x, y);
2652                 case APPLY_SHEAR | APPLY_TRANSLATE:
2653                     if (xy == 0.0 || yx == 0.0) {
2654                         throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
2655                     }
2656                     return new Point2D(
2657                             (1.0 / yx) * y - yt / yx,
2658                             (1.0 / xy) * x - xt / xy);
2659                 case APPLY_SHEAR:
2660                     if (xy == 0.0 || yx == 0.0) {
2661                         throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
2662                     }
2663                     return new Point2D((1.0 / yx) * y, (1.0 / xy) * x);
2664                 case APPLY_SCALE | APPLY_TRANSLATE:
2665                     if (xx == 0.0 || yy == 0.0) {
2666                         throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
2667                     }
2668                     return new Point2D(
2669                             (1.0 / xx) * x - xt / xx,
2670                             (1.0 / yy) * y - yt / yy);
2671                 case APPLY_SCALE:
2672                     if (xx == 0.0 || yy == 0.0) {
2673                         throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
2674                     }
2675                     return new Point2D((1.0 / xx) * x, (1.0 / yy) * y);
2676                 case APPLY_TRANSLATE:
2677                     return new Point2D(x - xt, y - yt);
2678                 case APPLY_IDENTITY:
2679                     return new Point2D(x, y);
2680             }
2681         }
2682 
2683         @Override
2684         public Point3D inverseTransform(double x, double y, double z)
2685                 throws NonInvertibleTransformException {
2686             switch(state3d) {
2687                 default:
2688                     stateError();
2689                     // cannot reach
2690                 case APPLY_NON_3D:
2691                     switch (state2d) {
2692                         default:
2693                             return super.inverseTransform(x, y, z);
2694                         case APPLY_SHEAR | APPLY_TRANSLATE:
2695                             if (xy == 0.0 || yx == 0.0) {
2696                                 throw new NonInvertibleTransformException(
2697                                         &quot;Determinant is 0&quot;);
2698                             }
2699                             return new Point3D(
2700                                     (1.0 / yx) * y - yt / yx,
2701                                     (1.0 / xy) * x - xt / xy, z);
2702                         case APPLY_SHEAR:
2703                             if (xy == 0.0 || yx == 0.0) {
2704                                 throw new NonInvertibleTransformException(
2705                                         &quot;Determinant is 0&quot;);
2706                             }
2707                             return new Point3D(
2708                                     (1.0 / yx) * y,
2709                                     (1.0 / xy) * x, z);
2710                         case APPLY_SCALE | APPLY_TRANSLATE:
2711                             if (xx == 0.0 || yy == 0.0) {
2712                                 throw new NonInvertibleTransformException(
2713                                         &quot;Determinant is 0&quot;);
2714                             }
2715                             return new Point3D(
2716                                     (1.0 / xx) * x - xt / xx,
2717                                     (1.0 / yy) * y - yt / yy, z);
2718                         case APPLY_SCALE:
2719                             if (xx == 0.0 || yy == 0.0) {
2720                                 throw new NonInvertibleTransformException(
2721                                         &quot;Determinant is 0&quot;);
2722                             }
2723                             return new Point3D((1.0 / xx) * x, (1.0 / yy) * y, z);
2724                         case APPLY_TRANSLATE:
2725                             return new Point3D(x - xt, y - yt, z);
2726                         case APPLY_IDENTITY:
2727                             return new Point3D(x, y, z);
2728                     }
2729                 case APPLY_TRANSLATE:
2730                     return new Point3D(x - xt, y - yt, z - zt);
2731                 case APPLY_SCALE:
2732                     if (xx == 0.0 || yy == 0.0 || zz == 0.0) {
2733                         throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
2734                     }
2735                     return new Point3D(
2736                             (1.0 / xx) * x,
2737                             (1.0 / yy) * y,
2738                             (1.0 / zz) * z);
2739                 case APPLY_SCALE | APPLY_TRANSLATE:
2740                     if (xx == 0.0 || yy == 0.0 || zz == 0.0) {
2741                         throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
2742                     }
2743                     return new Point3D(
2744                             (1.0 / xx) * x - xt / xx,
2745                             (1.0 / yy) * y - yt / yy,
2746                             (1.0 / zz) * z - zt / zz);
2747                 case APPLY_3D_COMPLEX:
2748                     return super.inverseTransform(x, y, z);
2749             }
2750         }
2751 
2752         @Override
2753         public Point2D inverseDeltaTransform(double x, double y)
2754                 throws NonInvertibleTransformException {
2755             ensureCanTransform2DPoint();
2756 
2757             switch (state2d) {
2758                 default:
2759                     return super.inverseDeltaTransform(x, y);
2760                 case APPLY_SHEAR | APPLY_TRANSLATE:
2761                 case APPLY_SHEAR:
2762                     if (xy == 0.0 || yx == 0.0) {
2763                         throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
2764                     }
2765                     return new Point2D((1.0 / yx) * y, (1.0 / xy) * x);
2766                 case APPLY_SCALE | APPLY_TRANSLATE:
2767                 case APPLY_SCALE:
2768                     if (xx == 0.0 || yy == 0.0) {
2769                         throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
2770                     }
2771                     return new Point2D((1.0 / xx) * x, (1.0 / yy) * y);
2772                 case APPLY_TRANSLATE:
2773                 case APPLY_IDENTITY:
2774                     return new Point2D(x, y);
2775             }
2776         }
2777 
2778         @Override
2779         public Point3D inverseDeltaTransform(double x, double y, double z)
2780                 throws NonInvertibleTransformException {
2781             switch(state3d) {
2782                 default:
2783                     stateError();
2784                     // cannot reach
2785                 case APPLY_NON_3D:
2786                     switch (state2d) {
2787                         default:
2788                             return super.inverseDeltaTransform(x, y, z);
2789                         case APPLY_SHEAR | APPLY_TRANSLATE:
2790                         case APPLY_SHEAR:
2791                             if (xy == 0.0 || yx == 0.0) {
2792                                 throw new NonInvertibleTransformException(
2793                                         &quot;Determinant is 0&quot;);
2794                             }
2795                             return new Point3D(
2796                                     (1.0 / yx) * y,
2797                                     (1.0 / xy) * x, z);
2798                         case APPLY_SCALE | APPLY_TRANSLATE:
2799                         case APPLY_SCALE:
2800                             if (xx == 0.0 || yy == 0.0) {
2801                                 throw new NonInvertibleTransformException(
2802                                         &quot;Determinant is 0&quot;);
2803                             }
2804                             return new Point3D(
2805                                     (1.0 / xx) * x,
2806                                     (1.0 / yy) * y, z);
2807                         case APPLY_TRANSLATE:
2808                         case APPLY_IDENTITY:
2809                             return new Point3D(x, y, z);
2810                     }
2811 
2812                 case APPLY_TRANSLATE:
2813                     return new Point3D(x, y, z);
2814                 case APPLY_SCALE | APPLY_TRANSLATE:
2815                 case APPLY_SCALE:
2816                     if (xx == 0.0 || yy == 0.0 || zz == 0.0) {
2817                         throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
2818                     }
2819                     return new Point3D(
2820                             (1.0 / xx) * x,
2821                             (1.0 / yy) * y,
2822                             (1.0 / zz) * z);
2823                 case APPLY_3D_COMPLEX:
2824                     return super.inverseDeltaTransform(x, y, z);
2825             }
2826         }
2827 
2828         /* *************************************************************************
2829          *                                                                         *
2830          *                               Other API                                 *
2831          *                                                                         *
2832          **************************************************************************/
2833 
2834         @Override
2835         public String toString() {
2836            final StringBuilder sb = new StringBuilder(&quot;Transform [\n&quot;);
2837 
2838             sb.append(&quot;\t&quot;).append(xx);
2839             sb.append(&quot;, &quot;).append(xy);
2840             sb.append(&quot;, &quot;).append(xz);
2841             sb.append(&quot;, &quot;).append(xt);
2842             sb.append(&#39;\n&#39;);
2843             sb.append(&quot;\t&quot;).append(yx);
2844             sb.append(&quot;, &quot;).append(yy);
2845             sb.append(&quot;, &quot;).append(yz);
2846             sb.append(&quot;, &quot;).append(yt);
2847             sb.append(&#39;\n&#39;);
2848             sb.append(&quot;\t&quot;).append(zx);
2849             sb.append(&quot;, &quot;).append(zy);
2850             sb.append(&quot;, &quot;).append(zz);
2851             sb.append(&quot;, &quot;).append(zt);
2852 
2853             return sb.append(&quot;\n]&quot;).toString();
2854         }
2855 
2856         /* *************************************************************************
2857          *                                                                         *
2858          *                    Internal implementation stuff                        *
2859          *                                                                         *
2860          **************************************************************************/
2861 
2862         private void updateState() {
2863             updateState2D();
2864 
2865             state3d = APPLY_NON_3D;
2866 
2867             if (xz != 0.0 ||
2868                 yz != 0.0 ||
2869                 zx != 0.0 ||
2870                 zy != 0.0)
2871             {
2872                 state3d = APPLY_3D_COMPLEX;
2873             } else {
2874                 if ((state2d &amp; APPLY_SHEAR) == 0) {
2875                     if (zt != 0.0) {
2876                         state3d |= APPLY_TRANSLATE;
2877                     }
2878                     if (zz != 1.0) {
2879                         state3d |= APPLY_SCALE;
2880                     }
2881                     if (state3d != APPLY_NON_3D) {
2882                         state3d |= (state2d &amp; (APPLY_SCALE | APPLY_TRANSLATE));
2883                     }
2884                 } else {
2885                     if (zz != 1.0 || zt != 0.0) {
2886                         state3d = APPLY_3D_COMPLEX;
2887                     }
2888                 }
2889             }
2890         }
2891 
2892         private void updateState2D() {
2893             if (xy == 0.0 &amp;&amp; yx == 0.0) {
2894                 if (xx == 1.0 &amp;&amp; yy == 1.0) {
2895                     if (xt == 0.0 &amp;&amp; yt == 0.0) {
2896                         state2d = APPLY_IDENTITY;
2897                     } else {
2898                         state2d = APPLY_TRANSLATE;
2899                     }
2900                 } else {
2901                     if (xt == 0.0 &amp;&amp; yt == 0.0) {
2902                         state2d = APPLY_SCALE;
2903                     } else {
2904                         state2d = (APPLY_SCALE | APPLY_TRANSLATE);
2905                     }
2906                 }
2907             } else {
2908                 if (xx == 0.0 &amp;&amp; yy == 0.0) {
2909                     if (xt == 0.0 &amp;&amp; yt == 0.0) {
2910                         state2d = APPLY_SHEAR;
2911                     } else {
2912                         state2d = (APPLY_SHEAR | APPLY_TRANSLATE);
2913                     }
2914                 } else {
2915                     if (xt == 0.0 &amp;&amp; yt == 0.0) {
2916                         state2d = (APPLY_SHEAR | APPLY_SCALE);
2917                     } else {
2918                         state2d = (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE);
2919                     }
2920                 }
2921             }
2922         }
2923 
2924         void ensureCanTransform2DPoint() throws IllegalStateException {
2925             if (state3d != APPLY_NON_3D) {
2926                 throw new IllegalStateException(&quot;Cannot transform 2D point &quot;
2927                         + &quot;with a 3D transform&quot;);
2928             }
2929         }
2930 
2931         private static void stateError() {
2932             throw new InternalError(&quot;missing case in a switch&quot;);
2933         }
2934 
2935 
2936         @Override
2937         void apply(final Affine3D trans) {
2938             trans.concatenate(xx, xy, xz, xt,
2939                               yx, yy, yz, yt,
2940                               zx, zy, zz, zt);
2941         }
2942 
2943         @Override
2944         BaseTransform derive(final BaseTransform trans) {
2945             return trans.deriveWithConcatenation(xx, xy, xz, xt,
2946                                                  yx, yy, yz, yt,
2947                                                  zx, zy, zz, zt);
2948         }
2949 
2950         /**
2951          * Used only by tests to check the 2d matrix state
2952          */
2953         int getState2d() {
2954             return state2d;
2955         }
2956 
2957         /**
2958          * Used only by tests to check the 3d matrix state
2959          */
2960         int getState3d() {
2961             return state3d;
2962         }
2963 
2964     }
2965 
2966 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>