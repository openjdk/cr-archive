diff a/application/org.openjdk.jmc.flightrecorder.ui/defaultPages.xml b/application/org.openjdk.jmc.flightrecorder.ui/defaultPages.xml
--- a/application/org.openjdk.jmc.flightrecorder.ui/defaultPages.xml
+++ b/application/org.openjdk.jmc.flightrecorder.ui/defaultPages.xml
@@ -236,165 +236,301 @@
             </threadLane>
           <threadLane name="Other Types" enabled="false" editable="false" isRestLane="true"/>
   		</state>
   		<page factory="org.openjdk.jmc.flightrecorder.ui.threads" id="org.openjdk.jmc.flightrecorder.ui.threads">
   			<state>
-  			<sash weights="1,5" />
-  			<threadLane name="EJB">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Database_Access"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/EJB/EJB_Home_Remove"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Timer_Manager"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/EJB/EJB_Home_Create"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Pool_Manager_Remove"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Business_Method_Post_Invoke_Cleanup"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/EJB/EJB_Pool_Manager_Create"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Replicated_Session_Manager"/>
-                </filter>
-            </threadLane>
-            <threadLane name="EJB Business Method Invoke" enabled="true">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/EJB/EJB_Business_Method_Invoke"/>
-                </filter>
-            </threadLane>
-            <threadLane name="JDBC" enabled="true">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/JDBC/JDBC_Statement_Execute"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Data_Source_Get_Connection"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Driver_Connect"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Statement_Creation"/>
-                </filter>
-            </threadLane>
-            <threadLane name="JDBC Connection">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Reserve"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Create_Statement"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Commit"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Prepare"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Release"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/JDBC/JDBC_Connection_Rollback"/>
-                </filter>
-            </threadLane>
-           <threadLane name="JDBC Connection Close">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Close"/>
-                </filter>
-            </threadLane>
-            <threadLane name="Servlet Request Run" enabled="true">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Servlet_Request_Run"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Servlet_Request_Run_Begin"/>
-                </filter>
-            </threadLane>
-            <threadLane name="Web Application Load">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Web_Application_Load"/>
-                </filter>
-            </threadLane>
-            <threadLane name="Servlet Execute">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Execute"/>
-                </filter>
-            </threadLane>
-           <threadLane name="Servlet Context Execute">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Context_Execute"/>
-                </filter>
-            </threadLane>
-            <threadLane name="Servlet Invocation">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Servlet_Invocation"/>
-                </filter>
-            </threadLane>
-            <threadLane name="Servlet Filter">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Check_Access"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Filter"/>
-                </filter>
-            </threadLane>
-            <threadLane name="Servlet Request">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Request"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Request_Dispatch"/>
-                </filter>
-            </threadLane>
-            <threadLane name="Servlet Response Write Headers/Stale Resource">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Response_Write_Headers"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Stale_Resource"/>
-                </filter>
-            </threadLane>
-            <threadLane name="Servlet Response Send">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Response_Send"/>
-                </filter>
-            </threadLane>
-            <threadLane name="JAX-RPC">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Client_Response"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Client_Request"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Request"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Response"/>
-                </filter>
-            </threadLane>
-            <threadLane name="WebServices" enabled="true">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Dispatch"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXWS/Webservices_JAXWS_Request"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXWS/Webservices_JAXWS_Endpoint"/>
-                </filter>
-            </threadLane>
-            <threadLane name="DMS">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/dms-context/dms/ExecutionContext/span"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/dms-anonymous-phase/dms/AnonymousPhase/span"/>
-                </filter>
-            </threadLane>
-            <threadLane name="DMS execution context start">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/dms-context/dms/ExecutionContext/start"/>
-                </filter>
-            </threadLane>
-            <threadLane name="DMS HTTP">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/dms-http/dms/HttpRequest/span"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/dms-http/dms/HttpRequest/start"/>
-                </filter>
-            </threadLane>
-            <threadLane name="JavaFX Pulse" enabled="true">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/technetwork/java/javafx/index.html/javafx/pulse"/>
-                </filter>
-            </threadLane>
-            <threadLane name="JavaFX Input" enabled="true">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/technetwork/java/javafx/index.html/javafx/input"/>
-                </filter>
-            </threadLane>
-            <threadLane name="Java Latencies" enabled="true">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="jdk.JavaMonitorEnter"/>
-                    <filter kind="TYPE" type="jdk.SocketRead"/>
-                    <filter kind="TYPE" type="jdk.Compilation"/>
-                    <filter kind="TYPE" type="jdk.ExecutionSampling"/>
-                    <filter kind="TYPE" type="jdk.SocketWrite"/>
-                    <filter kind="TYPE" type="jdk.ClassLoad"/>
-                    <filter kind="TYPE" type="jdk.ThreadPark"/>
-                    <filter kind="TYPE" type="jdk.FileWrite"/>
-                    <filter kind="TYPE" type="jdk.ThreadSleep"/>
-                    <filter kind="TYPE" type="jdk.JavaMonitorWait"/>
-                    <filter kind="TYPE" type="jdk.FileRead"/>
-                </filter>
-            </threadLane>
-            <threadLane name="JVM Compiler">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="jdk.SweepCodeCache"/>
-                    <filter kind="TYPE" type="jdk.CompilerPhase"/>
-                </filter>
-            </threadLane>
-          <threadLane name="Other Types" enabled="false" editable="false" isRestLane="true"/>
+	  			<sash weights="1,5" />
+	  			<threadLane name="EJB">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Database_Access"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/EJB/EJB_Home_Remove"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Timer_Manager"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/EJB/EJB_Home_Create"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Pool_Manager_Remove"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Business_Method_Post_Invoke_Cleanup"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/EJB/EJB_Pool_Manager_Create"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Replicated_Session_Manager"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="EJB Business Method Invoke" enabled="true">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/EJB/EJB_Business_Method_Invoke"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="JDBC" enabled="true">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/JDBC/JDBC_Statement_Execute"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Data_Source_Get_Connection"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Driver_Connect"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Statement_Creation"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="JDBC Connection">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Reserve"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Create_Statement"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Commit"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Prepare"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Release"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/JDBC/JDBC_Connection_Rollback"/>
+	                </filter>
+	            </threadLane>
+	           <threadLane name="JDBC Connection Close">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Close"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="Servlet Request Run" enabled="true">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Servlet_Request_Run"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Servlet_Request_Run_Begin"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="Web Application Load">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Web_Application_Load"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="Servlet Execute">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Execute"/>
+	                </filter>
+	            </threadLane>
+	           <threadLane name="Servlet Context Execute">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Context_Execute"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="Servlet Invocation">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Servlet_Invocation"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="Servlet Filter">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Check_Access"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Filter"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="Servlet Request">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Request"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Request_Dispatch"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="Servlet Response Write Headers/Stale Resource">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Response_Write_Headers"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Stale_Resource"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="Servlet Response Send">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Response_Send"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="JAX-RPC">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Client_Response"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Client_Request"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Request"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Response"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="WebServices" enabled="true">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Dispatch"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXWS/Webservices_JAXWS_Request"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXWS/Webservices_JAXWS_Endpoint"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="DMS">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/dms-context/dms/ExecutionContext/span"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/dms-anonymous-phase/dms/AnonymousPhase/span"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="DMS execution context start">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/dms-context/dms/ExecutionContext/start"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="DMS HTTP">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/dms-http/dms/HttpRequest/span"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/dms-http/dms/HttpRequest/start"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="JavaFX Pulse" enabled="true">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/technetwork/java/javafx/index.html/javafx/pulse"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="JavaFX Input" enabled="true">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/technetwork/java/javafx/index.html/javafx/input"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="Java Latencies" enabled="true">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="jdk.JavaMonitorEnter"/>
+	                    <filter kind="TYPE" type="jdk.SocketRead"/>
+	                    <filter kind="TYPE" type="jdk.Compilation"/>
+	                    <filter kind="TYPE" type="jdk.ExecutionSampling"/>
+	                    <filter kind="TYPE" type="jdk.SocketWrite"/>
+	                    <filter kind="TYPE" type="jdk.ClassLoad"/>
+	                    <filter kind="TYPE" type="jdk.ThreadPark"/>
+	                    <filter kind="TYPE" type="jdk.FileWrite"/>
+	                    <filter kind="TYPE" type="jdk.ThreadSleep"/>
+	                    <filter kind="TYPE" type="jdk.JavaMonitorWait"/>
+	                    <filter kind="TYPE" type="jdk.FileRead"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="JVM Compiler">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="jdk.SweepCodeCache"/>
+	                    <filter kind="TYPE" type="jdk.CompilerPhase"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="Other Types" enabled="false" editable="false" isRestLane="true"/>
   			</state>
+			<!-- Legacy Threads Page -->
+			<page factory="org.openjdk.jmc.flightrecorder.ui.threadslegacy" id="org.openjdk.jmc.flightrecorder.ui.threadslegacy">
+			    <state>
+			        <sash weights="1,5" />
+			        <threadLane name="EJB">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Database_Access"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/EJB/EJB_Home_Remove"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Timer_Manager"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/EJB/EJB_Home_Create"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Pool_Manager_Remove"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Business_Method_Post_Invoke_Cleanup"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/EJB/EJB_Pool_Manager_Create"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Replicated_Session_Manager"/></filter>
+			        </threadLane>
+			        <threadLane name="EJB Business Method Invoke" enabled="true">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/EJB/EJB_Business_Method_Invoke"/></filter>
+			        </threadLane>
+			        <threadLane name="JDBC" enabled="true">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/JDBC/JDBC_Statement_Execute"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Data_Source_Get_Connection"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Driver_Connect"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Statement_Creation"/></filter>
+			        </threadLane>
+			        <threadLane name="JDBC Connection">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Reserve"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Create_Statement"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Commit"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Prepare"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Release"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/JDBC/JDBC_Connection_Rollback"/></filter>
+			        </threadLane>
+			        <threadLane name="JDBC Connection Close">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Close"/></filter>
+			        </threadLane>
+			        <threadLane name="Servlet Request Run" enabled="true">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Servlet_Request_Run"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Servlet_Request_Run_Begin"/></filter>
+			        </threadLane>
+			        <threadLane name="Web Application Load">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Web_Application_Load"/></filter>
+			        </threadLane>
+			        <threadLane name="Servlet Execute">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Execute"/></filter>
+			        </threadLane>
+			        <threadLane name="Servlet Context Execute">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Context_Execute"/></filter>
+			        </threadLane>
+			        <threadLane name="Servlet Invocation">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Servlet_Invocation"/></filter>
+			        </threadLane>
+			        <threadLane name="Servlet Filter">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Check_Access"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Filter"/></filter>
+			        </threadLane>
+			        <threadLane name="Servlet Request">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Request"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Request_Dispatch"/></filter>
+			        </threadLane>
+			        <threadLane name="Servlet Response Write Headers/Stale Resource">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Response_Write_Headers"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Stale_Resource"/></filter>
+			        </threadLane>
+			        <threadLane name="Servlet Response Send">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Response_Send"/></filter>
+			        </threadLane>
+			        <threadLane name="JAX-RPC">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Client_Response"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Client_Request"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Request"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Response"/></filter>
+			        </threadLane>
+			        <threadLane name="WebServices" enabled="true">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Dispatch"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXWS/Webservices_JAXWS_Request"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXWS/Webservices_JAXWS_Endpoint"/></filter>
+			        </threadLane>
+			        <threadLane name="DMS">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/dms-context/dms/ExecutionContext/span"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/dms-anonymous-phase/dms/AnonymousPhase/span"/></filter>
+			        </threadLane>
+			        <threadLane name="DMS execution context start">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/dms-context/dms/ExecutionContext/start"/></filter>
+			        </threadLane>
+			        <threadLane name="DMS HTTP">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/dms-http/dms/HttpRequest/span"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/dms-http/dms/HttpRequest/start"/></filter>
+			        </threadLane>
+			        <threadLane name="JavaFX Pulse" enabled="true">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/technetwork/java/javafx/index.html/javafx/pulse"/></filter>
+			        </threadLane>
+			        <threadLane name="JavaFX Input" enabled="true">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/technetwork/java/javafx/index.html/javafx/input"/></filter>
+			        </threadLane>
+			        <threadLane name="Java Latencies" enabled="true">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="jdk.JavaMonitorEnter"/>
+			                <filter kind="TYPE" type="jdk.SocketRead"/>
+			                <filter kind="TYPE" type="jdk.Compilation"/>
+			                <filter kind="TYPE" type="jdk.ExecutionSampling"/>
+			                <filter kind="TYPE" type="jdk.SocketWrite"/>
+			                <filter kind="TYPE" type="jdk.ClassLoad"/>
+			                <filter kind="TYPE" type="jdk.ThreadPark"/>
+			                <filter kind="TYPE" type="jdk.FileWrite"/>
+			                <filter kind="TYPE" type="jdk.ThreadSleep"/>
+			                <filter kind="TYPE" type="jdk.JavaMonitorWait"/>
+			                <filter kind="TYPE" type="jdk.FileRead"/></filter>
+			        </threadLane>
+			        <threadLane name="JVM Compiler">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="jdk.SweepCodeCache"/>
+			                <filter kind="TYPE" type="jdk.CompilerPhase"/></filter>
+			        </threadLane>
+			        <threadLane name="Other Types" enabled="false" editable="false" isRestLane="true"/>
+			    </state>
+			</page>
   		</page>
 		<page factory="org.openjdk.jmc.flightrecorder.ui.heap" id="org.openjdk.jmc.flightrecorder.ui.heap">
 			<state>
 				<chart>
 					<checkedAction id="heapUsed" />
diff a/application/org.openjdk.jmc.flightrecorder.ui/plugin.xml b/application/org.openjdk.jmc.flightrecorder.ui/plugin.xml
--- a/application/org.openjdk.jmc.flightrecorder.ui/plugin.xml
+++ b/application/org.openjdk.jmc.flightrecorder.ui/plugin.xml
@@ -216,10 +216,14 @@
       </factory>
       <factory
       		class="org.openjdk.jmc.flightrecorder.ui.pages.ThreadsPage$ThreadsPageFactory"
       		id="org.openjdk.jmc.flightrecorder.ui.threads">
       </factory>
+      <factory
+      		class="org.openjdk.jmc.flightrecorder.ui.pages.ThreadsPageLegacy$ThreadsPageLegacyFactory"
+      		id="org.openjdk.jmc.flightrecorder.ui.threadslegacy">
+      </factory>
       <factory
             class="org.openjdk.jmc.flightrecorder.ui.pages.HeapPage$HeapPageFactory"
             id="org.openjdk.jmc.flightrecorder.ui.heap">
       </factory>
             <factory
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DataPageToolkit.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DataPageToolkit.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DataPageToolkit.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DataPageToolkit.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -153,10 +153,12 @@
 import org.openjdk.jmc.ui.column.TableSettings;
 import org.openjdk.jmc.ui.column.TableSettings.ColumnSettings;
 import org.openjdk.jmc.ui.handlers.ActionToolkit;
 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
 import org.openjdk.jmc.ui.misc.ChartCanvas;
+import org.openjdk.jmc.ui.misc.ChartControlBar;
+import org.openjdk.jmc.ui.misc.ChartTextCanvas;
 import org.openjdk.jmc.ui.misc.CompositeToolkit;
 import org.openjdk.jmc.ui.misc.DisplayToolkit;
 import org.openjdk.jmc.ui.misc.FilterEditor;
 import org.openjdk.jmc.ui.misc.FilterEditor.AttributeValueProvider;
 import org.openjdk.jmc.ui.misc.OverlayImageDescriptor;
@@ -310,10 +312,14 @@
 
 	public static void setChart(ChartCanvas canvas, XYChart chart, Consumer<IItemCollection> selectionListener) {
 		setChart(canvas, chart, selectionListener, null);
 	}
 
+	public static void setChart(ChartTextCanvas canvas, XYChart chart, Consumer<IItemCollection> selectionListener) {
+		setChart(canvas, chart, selectionListener, null);
+	}
+
 	public static void setChart(
 		ChartCanvas canvas, XYChart chart, Consumer<IItemCollection> selectionListener,
 		Consumer<IRange<IQuantity>> selectRangeConsumer) {
 		IMenuManager contextMenu = canvas.getContextMenu();
 		contextMenu.removeAll();
@@ -329,10 +335,41 @@
 				}
 				canvas.redrawChart();
 			}
 		});
 
+		canvas.setSelectionListener(() -> {
+			selectionListener.accept(ItemRow.getRangeSelection(chart, JfrAttributes.LIFETIME));
+			IQuantity start = chart.getSelectionStart();
+			IQuantity end = chart.getSelectionEnd();
+			if (selectRangeConsumer != null) {
+				selectRangeConsumer
+						.accept(start != null && end != null ? QuantityRange.createWithEnd(start, end) : null);
+			}
+		});
+		canvas.setChart(chart);
+	}
+
+	public static void setChart(
+		ChartTextCanvas canvas, XYChart chart, Consumer<IItemCollection> selectionListener,
+		Consumer<IRange<IQuantity>> selectRangeConsumer) {
+		IMenuManager contextMenu = canvas.getContextMenu();
+		contextMenu.removeAll();
+		canvas.getContextMenu().add(new Action(Messages.CHART_ZOOM_TO_SELECTED_RANGE) {
+			@Override
+			public void run() {
+				IQuantity selectionStart = chart.getSelectionStart();
+				IQuantity selectionEnd = chart.getSelectionEnd();
+				if (selectionStart == null || selectionEnd == null) {
+					chart.clearVisibleRange();
+				} else {
+					chart.setVisibleRange(selectionStart, selectionEnd);
+				}
+				canvas.redrawChartText();
+			}
+		});
+
 		canvas.setSelectionListener(() -> {
 			selectionListener.accept(ItemRow.getRangeSelection(chart, JfrAttributes.LIFETIME));
 			IQuantity start = chart.getSelectionStart();
 			IQuantity end = chart.getSelectionEnd();
 			if (selectRangeConsumer != null) {
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DropdownLaneFilter.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DropdownLaneFilter.java
--- /dev/null
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DropdownLaneFilter.java
@@ -0,0 +1,161 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.flightrecorder.ui.common;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.ShellAdapter;
+import org.eclipse.swt.events.ShellEvent;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Listener;
+import org.eclipse.swt.widgets.Shell;
+
+import org.openjdk.jmc.flightrecorder.ui.common.LaneEditor.EditLanesContainer;
+import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
+import org.openjdk.jmc.ui.common.util.Environment;
+import org.openjdk.jmc.ui.common.util.Environment.OSType;
+import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
+
+public class DropdownLaneFilter extends Composite {
+	private static final int EXTRA_SHELL_WIDTH = 300;
+	private static final int SHELL_HEIGHT = 500;
+	private Button dropdownButton;
+	private GridLayout layout;
+	private MCContextMenuManager[] mms;
+	private Shell shell;
+	private ThreadGraphLanes lanes;
+	private EditLanesContainer container;
+
+	public DropdownLaneFilter(Composite parent, ThreadGraphLanes lanes, MCContextMenuManager[] mms) {
+		super(parent, SWT.NONE);
+		this.lanes = lanes;
+		this.mms = mms;
+		this.layout = new GridLayout();
+		layout.marginHeight = 0;
+		layout.marginWidth = 0;
+		setLayout(layout);
+		dropdownButton = new Button(this, SWT.TOGGLE);
+		dropdownButton.setLayoutData(new GridData(GridData.FILL_BOTH));
+		dropdownButton.setText(Messages.DropdownLaneFilter_THREAD_STATE_SELECTION);
+		dropdownButton.addListener(SWT.MouseUp, new Listener() {
+			@Override
+			public void handleEvent(Event e) {
+				/*
+				 * Windows: works IFF the menu item that is toggled is also highlight. e.g, if the
+				 * user wanted to toggle the Java Compiler lanes, then it's not enough to just click
+				 * the checkbox - the Java Compiler menu item must be highlighted at the time of
+				 * toggling
+				 *
+				 * MacOS: There are currently issues with paint timings with Mac OS at the moment
+				 * where toggling an activity lane from the dropdown does not redraw the chart. This
+				 * may be related to the Windows issue, and may be a SWT limitation.
+				 */
+				if (Environment.getOSType() != OSType.LINUX) {
+					lanes.openEditLanesDialog(mms, false);
+					dropdownButton.setSelection(false);
+				} else {
+					if (dropdownButton.getSelection()) {
+						displayDropdown();
+					}
+				}
+			}
+		});
+	}
+
+	/**
+	 * Creates a new shell which is positioned below the dropdown button. This new shell creates the
+	 * appearance of a dropdown component, and it's contents will be the TypeFilterBuilder as found
+	 * in the Edit Thread Lanes dialog.
+	 */
+	private void displayDropdown() {
+		Point p = dropdownButton.getParent().toDisplay(dropdownButton.getLocation());
+		Point size = dropdownButton.getSize();
+		Rectangle shellRect = new Rectangle(p.x, p.y + size.y, size.x, 0);
+
+		shell = new Shell(DropdownLaneFilter.this.getShell(), SWT.BORDER);
+		shell.addShellListener(new ShellAdapter() {
+
+			public void shellDeactivated(ShellEvent e) {
+				if (!isCursorOnTopOfButton()) {
+					// If the shell is closed without clicking the button (i.e., not forcing
+					// a toggle), then the button must be toggled programmatically.
+					dropdownButton.setSelection(false);
+				}
+				disposeDropdown();
+			}
+		});
+
+		shell.setLayout(this.layout);
+		shell.setSize(shellRect.width + EXTRA_SHELL_WIDTH, SHELL_HEIGHT);
+		shell.setLocation(shellRect.x, shellRect.y);
+
+		container = new EditLanesContainer(shell, lanes.getTypeTree(), lanes.getLaneDefinitions(), () -> updateChart());
+		container.setLayoutData(new GridData(GridData.FILL_BOTH));
+		shell.open();
+	}
+
+	private void disposeDropdown() {
+		if (shell != null && !shell.isDisposed()) {
+			shell.close();
+		}
+	}
+
+	/**
+	 * Determine whether or not the mouse cursor is overlapping the dropdown button. An open
+	 * dropdown shell should close when the user clicks the button. In Linux, the MouseListener on
+	 * the button will fire. In Windows, the shell has priority and the MouseListener doesn't get
+	 * activated. This function is to be used in the ShellAdapter to determine if the user closed
+	 * the shell by trying to click the button, or by clicking away from the dropdown shell.
+	 *
+	 * @return true if the mouse cursor is on top of the button
+	 */
+	private boolean isCursorOnTopOfButton() {
+		Point cursor = Display.getCurrent().getCursorLocation();
+		Point buttonLoc = dropdownButton.toDisplay(1, 1);
+		Rectangle buttonRect = new Rectangle(buttonLoc.x, buttonLoc.y, dropdownButton.getSize().x,
+				dropdownButton.getSize().y);
+		return buttonRect.contains(cursor);
+	}
+
+	private void updateChart() {
+		lanes.buildChart();
+		lanes.updateContextMenus(mms, false);
+	}
+}
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/FlavorSelector.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/FlavorSelector.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/FlavorSelector.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/FlavorSelector.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -63,11 +63,13 @@
 import org.eclipse.swt.graphics.RGB;
 import org.eclipse.swt.widgets.Button;
 import org.eclipse.swt.widgets.Canvas;
 import org.eclipse.swt.widgets.Composite;
 import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Event;
 import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Listener;
 import org.eclipse.ui.forms.widgets.Form;
 
 import org.openjdk.jmc.common.IDisplayable;
 import org.openjdk.jmc.common.IMCThread;
 import org.openjdk.jmc.common.item.IAttribute;
@@ -299,11 +301,10 @@
 		sameThreadsButton.setEnabled(showConcurrentButton.getSelection());
 		sameThreadsButton.setSelection(flavorSelectorState.sameThreads);
 		sameThreadsButton.addSelectionListener(new SameThreadsSelectionListener());
 
 		// FIXME: Persist state for above checkboxes?
-
 		onShow.ifPresent(on -> {
 			Label rangeLabel = new Label(selectorRow, SWT.NONE);
 			rangeLabel.setLayoutData(GridDataFactory.swtDefaults().create());
 			rangeLabel.setText(Messages.FlavorSelector_LABEL_TIMERANGE);
 			showButton = new Button(selectorRow, SWT.PUSH);
@@ -312,10 +313,16 @@
 			showButton.setLayoutData(GridDataFactory.swtDefaults().create());
 			resetButton = new Button(selectorRow, SWT.PUSH);
 			resetButton.setText(Messages.FlavorSelector_BUTTON_TIMERANGE_CLEAR);
 			resetButton.setToolTipText(Messages.FlavorSelector_BUTTON_TIMERANGE_CLEAR_TOOLTIP);
 			resetButton.addListener(SWT.Selection, e -> on.accept(false));
+			resetButton.addListener(SWT.Selection, new Listener() {
+				@Override
+				public void handleEvent(Event event) {
+					on.accept(false);
+				}
+			});
 			resetButton.setLayoutData(GridDataFactory.swtDefaults().create());
 			showButton.addListener(SWT.Selection, e -> on.accept(true));
 		});
 
 		canvas = new Canvas(container, SWT.NO_BACKGROUND);
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/LaneEditor.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/LaneEditor.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/LaneEditor.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/LaneEditor.java
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
- * 
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ *
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
  *
@@ -101,33 +101,44 @@
 			}
 			return PredicateToolkit.falsePredicate();
 		}
 	};
 
-	private static class EditLanesWizardPage extends WizardPage implements IPerformFinishable {
+	static class EditLanesContainer extends Composite {
+
+		final EventTypeFolderNode root;
+		final List<LaneDefinition> lanes;
 
-		private final EventTypeFolderNode root;
-		private final List<LaneDefinition> lanes;
 		private LaneDefinition restLane;
 		private TypeFilterBuilder filterEditor;
 		private CheckboxTableViewer lanesViewer;
 		private Object selected;
+		private Runnable updateChart;
+		private boolean isDropdownFilter;
 
-		private EditLanesWizardPage(EventTypeFolderNode root, Collection<LaneDefinition> lanesInput) {
-			super("EditFilterLanesPage"); //$NON-NLS-1$
+		EditLanesContainer(Composite parent, EventTypeFolderNode root, List<LaneDefinition> lanes) {
+			this(parent, root, lanes, null);
+		}
+
+		EditLanesContainer(Composite parent, EventTypeFolderNode root, List<LaneDefinition> lanes, Runnable action) {
+			super(parent, SWT.NONE);
 			this.root = root;
-			this.lanes = new ArrayList<>(lanesInput);
+			this.lanes = lanes;
+			this.updateChart = action;
 			restLane = ensureRestLane(lanes);
+			init();
 		}
 
-		@Override
-		public void createControl(Composite parent) {
+		public List<LaneDefinition> getLanes() {
+			return lanes;
+		}
+
+		private void init() {
 			// FIXME: Do we want to group under categories somehow, or just hide the filters that don't have any existing event types.
-			Composite container = new Composite(parent, SWT.NONE);
-			container.setLayout(GridLayoutFactory.swtDefaults().numColumns(2).create());
+			this.setLayout(GridLayoutFactory.swtDefaults().numColumns(2).create());
 
-			Composite laneHeaderContainer = new Composite(container, SWT.NONE);
+			Composite laneHeaderContainer = new Composite(this, SWT.NONE);
 			laneHeaderContainer.setLayout(GridLayoutFactory.swtDefaults().create());
 			laneHeaderContainer.setLayoutData(GridDataFactory.fillDefaults().create());
 
 			// FIXME: Add a duplicate action?
 			IAction moveUpAction = ActionToolkit.action(() -> moveSelected(true), Messages.LANES_MOVE_UP_ACTION,
@@ -143,16 +154,16 @@
 			toolbar.setLayoutData(GridDataFactory.fillDefaults().create());
 
 			Label lanesTitle = new Label(laneHeaderContainer, SWT.NONE);
 			lanesTitle.setText(Messages.LANES_EDITOR_LABEL);
 			lanesTitle.setLayoutData(GridDataFactory.fillDefaults().create());
-			Label filterTitle = new Label(container, SWT.NONE);
+			Label filterTitle = new Label(this, SWT.NONE);
 			filterTitle.setText(Messages.LANES_FILTER_LABEL);
 			filterTitle.setLayoutData(
 					GridDataFactory.fillDefaults().grab(true, false).align(SWT.BEGINNING, SWT.END).create());
 
-			lanesViewer = CheckboxTableViewer.newCheckList(container, SWT.BORDER | SWT.V_SCROLL);
+			lanesViewer = CheckboxTableViewer.newCheckList(this, SWT.BORDER | SWT.V_SCROLL);
 			TableViewerColumn viewerColumn = new TableViewerColumn(lanesViewer, SWT.NONE);
 			viewerColumn.getColumn().setText(Messages.LANES_LANE_COLUMN);
 			viewerColumn.getColumn().setWidth(200);
 			// FIXME: Would like to enable editing by some other means than single-clicking, but seems a bit tricky.
 			viewerColumn.setEditingSupport(new EditingSupport(lanesViewer) {
@@ -269,21 +280,20 @@
 			// FIXME: Add icon
 			mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, addAction);
 
 			mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, removeAction);
 
-			filterEditor = new TypeFilterBuilder(container, this::onTypeFilterChange);
+			filterEditor = new TypeFilterBuilder(this, this::onTypeFilterChange);
 			filterEditor.setInput(root);
 			filterEditor.getControl().setLayoutData(GridDataFactory.fillDefaults().grab(true, true).create());
+			isDropdownFilter = updateChart != null ? true : false;
 			lanesViewer.getControl().setLayoutData(GridDataFactory.fillDefaults().grab(false, true).create());
 
 			lanesViewer.addSelectionChangedListener(
 					e -> laneSelectionChanges(((IStructuredSelection) e.getSelection()).getFirstElement()));
 			LaneDefinition firstLane = lanes.get(0);
 			lanesViewer.setSelection(new StructuredSelection(firstLane));
-
-			setControl(container);
 		}
 
 		private void addLane() {
 			int selectIndex = Math.max(0, lanes.indexOf(selected));
 			IItemFilter emptyFilter = ItemFilters.type(Collections.emptySet());
@@ -302,10 +312,13 @@
 							NLS.bind(Messages.LANES_EDIT_NOT_ALLOWED_WARNING_DESC, selectedLane.getName()));
 					// FIXME: Can we refresh the filter editor to show that nothing has changed?
 				}
 			}
 			lanesViewer.update(selected, null);
+			if (isDropdownFilter) {
+				updateChart();
+			}
 		}
 
 		private void deleteSelected() {
 			// FIXME: It's currently not possible to delete the last lane
 			int selectIndex = Math.max(0, lanes.indexOf(selected) - 1);
@@ -330,57 +343,105 @@
 			}
 		}
 
 		private void laneSelectionChanges(Object newSelected) {
 			int selectedIndex = lanes.indexOf(newSelected);
-			if (this.selected != newSelected) {
-				saveFilter();
-				this.selected = lanes.get(selectedIndex);
-				if (selected instanceof LaneDefinition) {
-					Types typesFilter;
-					if (((LaneDefinition) selected).getFilter() instanceof Types) {
-						typesFilter = ((Types) ((LaneDefinition) selected).getFilter());
-					} else {
-						typesFilter = (Types) ItemFilters.convertToTypes(((LaneDefinition) selected).getFilter(),
-								filterEditor.getAllTypes());
+			if (selectedIndex == -1 && isDropdownFilter) {
+				selectedIndex = findLaneDefinitionIndexByName(selected);
+			}
+			saveFilter();
+			this.selected = lanes.get(selectedIndex);
+			if (selected instanceof LaneDefinition) {
+				Types typesFilter;
+				if (((LaneDefinition) selected).getFilter() instanceof Types) {
+					typesFilter = ((Types) ((LaneDefinition) selected).getFilter());
+				} else {
+					typesFilter = (Types) ItemFilters.convertToTypes(((LaneDefinition) selected).getFilter(),
+							filterEditor.getAllTypes());
+				}
+				filterEditor.selectTypes(typesFilter.getTypes());
+			}
+			if (isDropdownFilter) {
+				updateChart();
+			}
+		}
+
+		private void updateChart() {
+			saveFilter(); // updates the LaneDefinition with the new filter
+			updateChart.run(); // repaints the chart and text canvases
+		}
+
+		private int findLaneDefinitionIndexByName(Object selected) {
+			int index = -1;
+			if (selected != null) {
+				for (int i = 0; i < lanes.size(); i++) {
+					if (lanes.get(i).getName().equals(((LaneDefinition) selected).getName())) {
+						index = i;
+						break;
 					}
-					filterEditor.selectTypes(typesFilter.getTypes());
 				}
 			}
+			return index;
 		}
 
 		private void saveFilter() {
 			int selectedIndex = lanes.indexOf(selected);
+			if (selectedIndex == -1 && isDropdownFilter) {
+				selectedIndex = findLaneDefinitionIndexByName(selected);
+			}
 			if (selectedIndex >= 0) {
 				LaneDefinition ld = lanes.get(selectedIndex);
-				if (!ld.isRestLane()) {
-					IItemFilter newFilter = ItemFilters
-							.type(filterEditor.getCheckedTypeIds().collect(Collectors.toSet()));
-					LaneDefinition newLd = new LaneDefinition(ld.name, lanesViewer.getChecked(ld), newFilter,
-							ld.isRestLane);
-					lanes.set(selectedIndex, newLd);
-					lanesViewer.replace(newLd, selectedIndex);
-					if (restLane != null) {
-						LaneDefinition newRest = new LaneDefinition(restLane.name, restLane.enabled,
-								getRestFilter(lanes), true);
-						int restIndex = lanes.indexOf(restLane);
-						lanes.set(restIndex, newRest);
-						lanesViewer.replace(newRest, restIndex);
-						restLane = newRest;
-					}
-					lanesViewer.refresh();
+				IItemFilter newFilter = ItemFilters.type(filterEditor.getCheckedTypeIds().collect(Collectors.toSet()));
+				LaneDefinition newLd = new LaneDefinition(ld.name, lanesViewer.getChecked(ld), newFilter,
+						ld.isRestLane);
+				lanes.set(selectedIndex, newLd);
+				lanesViewer.replace(newLd, selectedIndex);
+				if (ld.isRestLane()) {
+					restLane = newLd;
+				} else {
+					LaneDefinition newRest = new LaneDefinition(restLane.name, restLane.enabled, getRestFilter(lanes),
+							true);
+					int restIndex = findLaneDefinitionIndexByName(restLane);
+					lanes.set(restIndex, newRest);
+					lanesViewer.replace(newRest, restIndex);
+					restLane = newRest;
 				}
+				lanesViewer.refresh();
 			}
 		}
+	}
+
+	private static class EditLanesWizardPage extends WizardPage implements IPerformFinishable {
+
+		private EditLanesContainer container;
+		protected EventTypeFolderNode root;
+		private List<LaneDefinition> lanes;
+
+		private EditLanesWizardPage(EventTypeFolderNode root, Collection<LaneDefinition> lanesInput) {
+			super("EditFilterLanesPage"); //$NON-NLS-1$
+			this.root = root;
+			this.lanes = new ArrayList<>(lanesInput);
+		}
+
+		public List<LaneDefinition> getLanes() {
+			return lanes;
+		}
+
+		@Override
+		public void createControl(Composite parent) {
+			container = new EditLanesContainer(parent, root, lanes);
+			setControl(container);
+		}
 
 		@Override
 		public boolean performFinish() {
-			saveFilter();
+			container.saveFilter();
 			for (int i = 0; i < lanes.size(); i++) {
 				LaneDefinition ld = lanes.get(i);
-				if (ld.isEnabled() != lanesViewer.getChecked(ld)) {
-					lanes.set(i, new LaneDefinition(ld.name, lanesViewer.getChecked(ld), ld.filter, ld.isRestLane));
+				if (ld.isEnabled() != container.lanesViewer.getChecked(ld)) {
+					lanes.set(i, new LaneDefinition(ld.name, container.lanesViewer.getChecked(ld), ld.filter,
+							ld.isRestLane));
 				}
 			}
 			return true;
 		}
 	}
@@ -432,10 +493,14 @@
 
 		public boolean isRestLane() {
 			return isRestLane;
 		}
 
+		public boolean isEnabledAndNotRestLane() {
+			return enabled && !isRestLane;
+		}
+
 		@Override
 		public void saveTo(IWritableState writableState) {
 			writableState.putString(NAME, name);
 			StateToolkit.writeBoolean(writableState, ENABLED, enabled);
 			StateToolkit.writeBoolean(writableState, IS_REST_LANE, isRestLane);
@@ -471,11 +536,11 @@
 		EventTypeFolderNode root, List<LaneDefinition> lanes, String title, String description) {
 		EditLanesWizardPage page = new EditLanesWizardPage(root, lanes);
 		page.setTitle(title);
 		page.setDescription(description);
 		if (OnePageWizardDialog.open(page, 500, 600) == Window.OK) {
-			return page.lanes.stream().filter(LaneEditor::laneIncludesTypes).collect(Collectors.toList());
+			return page.getLanes().stream().filter(LaneEditor::laneIncludesTypes).collect(Collectors.toList());
 		}
 		return lanes;
 	}
 
 	private static boolean laneIncludesTypes(LaneDefinition ld) {
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/ThreadGraphLanes.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/ThreadGraphLanes.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/ThreadGraphLanes.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/ThreadGraphLanes.java
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
- * 
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ *
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
  *
@@ -92,28 +92,46 @@
 	private List<LaneDefinition> naLanes;
 	private Supplier<StreamModel> dataSourceSupplier;
 	private Runnable buildChart;
 	private List<IAction> actions;
 	private String tooltipTitle;
+	private EventTypeFolderNode typeTree;
 
 	public ThreadGraphLanes(Supplier<StreamModel> dataSourceSupplier, Runnable buildChart) {
 		this.dataSourceSupplier = dataSourceSupplier;
 		this.buildChart = buildChart;
 		this.actions = new ArrayList<>();
+		this.typeTree = dataSourceSupplier.get().getTypeTree(ItemCollectionToolkit
+				.stream(dataSourceSupplier.get().getItems()).filter(this::typeWithThreadAndDuration));
+	}
+
+	protected EventTypeFolderNode getTypeTree() {
+		return typeTree;
 	}
 
 	public void openEditLanesDialog(MCContextMenuManager mm, boolean isLegendMenu) {
 		// FIXME: Might there be other interesting events that don't really have duration?
-		EventTypeFolderNode typeTree = dataSourceSupplier.get().getTypeTree(ItemCollectionToolkit
+		typeTree = dataSourceSupplier.get().getTypeTree(ItemCollectionToolkit
 				.stream(dataSourceSupplier.get().getItems()).filter(this::typeWithThreadAndDuration));
 		laneDefs = LaneEditor.openDialog(typeTree, laneDefs.stream().collect(Collectors.toList()),
 				Messages.JavaApplicationPage_EDIT_THREAD_LANES_DIALOG_TITLE,
 				Messages.JavaApplicationPage_EDIT_THREAD_LANES_DIALOG_MESSAGE);
 		updateContextMenu(mm, isLegendMenu);
 		buildChart.run();
 	}
 
+	public void openEditLanesDialog(MCContextMenuManager[] mms, boolean isLegendMenu) {
+		// FIXME: Might there be other interesting events that don't really have duration?
+		typeTree = dataSourceSupplier.get().getTypeTree(ItemCollectionToolkit
+				.stream(dataSourceSupplier.get().getItems()).filter(this::typeWithThreadAndDuration));
+		laneDefs = LaneEditor.openDialog(typeTree, laneDefs.stream().collect(Collectors.toList()),
+				Messages.JavaApplicationPage_EDIT_THREAD_LANES_DIALOG_TITLE,
+				Messages.JavaApplicationPage_EDIT_THREAD_LANES_DIALOG_MESSAGE);
+		updateContextMenus(mms, isLegendMenu);
+		buildChart.run();
+	}
+
 	public List<LaneDefinition> getLaneDefinitions() {
 		return laneDefs;
 	}
 
 	private Boolean typeWithThreadAndDuration(IItemIterable itemStream) {
@@ -137,10 +155,19 @@
 
 	private void resetTooltipTitle() {
 		this.tooltipTitle = null;
 	}
 
+	public void buildChart() {
+		buildChart.run();
+	}
+
+	private void setLaneDefinitionEnablement(LaneDefinition oldLd, int laneIndex, boolean isEnabled) {
+		LaneDefinition newLd = new LaneDefinition(oldLd.getName(), isEnabled, oldLd.getFilter(), oldLd.isRestLane());
+		laneDefs.set(laneIndex, newLd);
+	}
+
 	public IXDataRenderer buildThreadRenderer(Object thread, IItemCollection items) {
 		this.resetTooltipTitle();
 		String threadName = thread == null ? "" : ((IMCThread) thread).getThreadName(); //$NON-NLS-1$
 		// FIXME: Workaround since this method can be called from super class constructor. Refactor to avoid this.
 		List<LaneDefinition> laneFilters = this.laneDefs == null ? Collections.emptyList() : this.laneDefs;
@@ -241,12 +268,64 @@
 
 	//create two action identifiers to handle the chart context menu and the legend context menu
 	private List<String> chartActionIdentifiers = new ArrayList<>();
 	private List<String> legendActionIdentifiers = new ArrayList<>();
 
-	public void updateContextMenu(MCContextMenuManager mm, boolean isLegendMenu) {
+	public void updateContextMenus(MCContextMenuManager[] mms, boolean isLegendMenu) {
+		if (isLegendMenu) {
+			for (String id : legendActionIdentifiers) {
+				for (MCContextMenuManager mm : mms) {
+					mm.remove(id);
+				}
+			}
+			legendActionIdentifiers.clear();
+		} else {
+			for (String id : chartActionIdentifiers) {
+				for (MCContextMenuManager mm : mms) {
+					mm.remove(id);
+				}
+			}
+			chartActionIdentifiers.clear();
+		}
+		if (mms[0].indexOf(EDIT_LANES) == -1) {
+			IAction action = ActionToolkit.action(() -> this.openEditLanesDialog(mms, isLegendMenu),
+					Messages.JavaApplicationPage_EDIT_THREAD_LANES_ACTION,
+					FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_LANES_EDIT));
+			action.setId(EDIT_LANES);
+			for (MCContextMenuManager mm : mms) {
+				mm.add(action);
+				mm.add(new Separator());
+			}
+			actions.add(action);
+		}
+		laneDefs.stream().forEach(ld -> {
+			Action checkAction = new Action(ld.getName(), IAction.AS_CHECK_BOX) {
+				int laneIndex = laneDefs.indexOf(ld);
 
+				@Override
+				public void run() {
+					setLaneDefinitionEnablement(ld, laneIndex, isChecked());
+					buildChart.run();
+				}
+			};
+			String identifier = ld.getName() + checkAction.hashCode();
+			checkAction.setId(identifier);
+			if (isLegendMenu) {
+				legendActionIdentifiers.add(identifier);
+			} else {
+				chartActionIdentifiers.add(identifier);
+			}
+			checkAction.setChecked(ld.isEnabled());
+			// FIXME: Add a tooltip here
+			for (MCContextMenuManager mm : mms) {
+				mm.add(checkAction);
+			}
+			actions.add(checkAction);
+		});
+	}
+
+	public void updateContextMenu(MCContextMenuManager mm, boolean isLegendMenu) {
 		if (isLegendMenu) {
 			for (String id : legendActionIdentifiers) {
 				mm.remove(id);
 			}
 			legendActionIdentifiers.clear();
@@ -269,13 +348,11 @@
 			Action checkAction = new Action(ld.getName(), IAction.AS_CHECK_BOX) {
 				int laneIndex = laneDefs.indexOf(ld);
 
 				@Override
 				public void run() {
-					LaneDefinition newLd = new LaneDefinition(ld.getName(), isChecked(), ld.getFilter(),
-							ld.isRestLane());
-					laneDefs.set(laneIndex, newLd);
+					setLaneDefinitionEnablement(ld, laneIndex, isChecked());
 					buildChart.run();
 				}
 			};
 			String identifier = ld.getName() + checkAction.hashCode();
 			checkAction.setId(identifier);
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/TypeLabelProvider.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/TypeLabelProvider.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/TypeLabelProvider.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/TypeLabelProvider.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -34,44 +34,83 @@
 
 import java.awt.Color;
 
 import org.openjdk.jmc.common.util.ColorToolkit;
 import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;
+import org.openjdk.jmc.ui.misc.PatternFly.Palette;
 
 // May evolve into a label provider
 public class TypeLabelProvider {
 
 	public static Color getColor(String typeId) {
 		switch (typeId) {
-		case JdkTypeIDs.ERRORS_THROWN:
-			return new Color(0xFF0000);
-		case JdkTypeIDs.EXCEPTIONS_THROWN:
-			return new Color(0xC80000);
+		case JdkTypeIDs.RECORDINGS:
+			return Palette.PF_CYAN_300.getAWTColor();
+		case JdkTypeIDs.RECORDING_SETTING:
+			return Palette.PF_GREEN_300.getAWTColor();
+		case JdkTypeIDs.THROWABLES_STATISTICS:
+			return Palette.PF_GOLD_500.getAWTColor();
+		case JdkTypeIDs.BIASED_LOCK_CLASS_REVOCATION:
+			return Palette.PF_PURPLE_400.getAWTColor();
+		case JdkTypeIDs.BIASED_LOCK_REVOCATION:
+			return Palette.PF_LIGHT_GREEN_300.getAWTColor();
+		case JdkTypeIDs.BIASED_LOCK_SELF_REVOCATION:
+			return Palette.PF_LIGHT_GREEN_400.getAWTColor();
 		case JdkTypeIDs.FILE_READ:
-			return new Color(0xBE4422);
+			return Palette.PF_ORANGE_300.getAWTColor();
 		case JdkTypeIDs.FILE_WRITE:
-			return new Color(0x2C689E);
+			return Palette.PF_CYAN_600.getAWTColor();
+		case JdkTypeIDs.ERRORS_THROWN:
+			return Palette.PF_RED_100.getAWTColor();
+		case JdkTypeIDs.EXCEPTIONS_THROWN:
+			return Palette.PF_RED_300.getAWTColor();
 		case JdkTypeIDs.MONITOR_ENTER:
-			return new Color(0xFF6D64);
+			return Palette.PF_ORANGE_200.getAWTColor();
 		case JdkTypeIDs.MONITOR_WAIT:
-			return new Color(0xFFE75B);
+			return Palette.PF_GOLD_200.getAWTColor();
+		case JdkTypeIDs.THREAD_PARK:
+			return Palette.PF_BLACK_500.getAWTColor();
+		case JdkTypeIDs.THREAD_SLEEP:
+			return Palette.PF_BLUE_500.getAWTColor();
+		case JdkTypeIDs.OLD_OBJECT_SAMPLE:
+			return Palette.PF_CYAN_200.getAWTColor();
+		case JdkTypeIDs.SWEEP_CODE_CACHE:
+			return Palette.PF_LIGHT_GREEN_500.getAWTColor();
+		case JdkTypeIDs.SOCKET_READ:
+			return new Color(0xC8321E);
+		case JdkTypeIDs.SOCKET_WRITE:
+			return Palette.PF_LIGHT_BLUE_500.getAWTColor();
+		case JdkTypeIDs.CLASS_LOAD:
+			return Palette.PF_PURPLE_100.getAWTColor();
+		case JdkTypeIDs.COMPILATION:
+			return Palette.PF_GOLD_300.getAWTColor();
+		case JdkTypeIDs.GC_PAUSE:
+			return new Color(0xDC3C00);
+		case JdkTypeIDs.GC_PAUSE_L1:
+			return new Color(0xE6CB45);
+		case JdkTypeIDs.GC_PAUSE_L2:
+			return new Color(0x458AE6);
+		case JdkTypeIDs.GC_PAUSE_L3:
+			return new Color(0xE645E2);
+		case JdkTypeIDs.GC_PAUSE_L4:
+			return new Color(0x85A115);
+		case JdkTypeIDs.SAFEPOINT_BEGIN:
+			return Palette.PF_PURPLE_200.getAWTColor();
+		case JdkTypeIDs.SAFEPOINT_CLEANUP:
+			return Palette.PF_PURPLE_500.getAWTColor();
+		case JdkTypeIDs.SAFEPOINT_CLEANUP_TASK:
+			return Palette.PF_BLUE_300.getAWTColor();
+		case JdkTypeIDs.VM_OPERATIONS:
+			return Palette.PF_ORANGE_500.getAWTColor();
 		case JdkTypeIDs.ALLOC_INSIDE_TLAB:
 			return new Color(0xFF8000);
 		case JdkTypeIDs.ALLOC_OUTSIDE_TLAB:
 			return new Color(0x808000);
-		case JdkTypeIDs.SOCKET_READ:
-			return new Color(0xC8321E);
-		case JdkTypeIDs.SOCKET_WRITE:
-			return new Color(0x4678C8);
-		case JdkTypeIDs.THREAD_PARK:
-			return new Color(0x808080);
 		case JdkTypeIDs.JAVA_THREAD_END:
 			return new Color(0x408040);
 		case JdkTypeIDs.JAVA_THREAD_START:
 			return new Color(0x80FF80);
-		case JdkTypeIDs.CLASS_LOAD:
-			return new Color(0x9B81DB);
 		case JdkTypeIDs.CLASS_UNLOAD:
 			return new Color(0x00FF00);
 		case JdkTypeIDs.COMPILER_FAILURE:
 			return new Color(0xE67245);
 		case JdkTypeIDs.GARBAGE_COLLECTION:
@@ -82,30 +121,16 @@
 			return new Color(0xFF8080);
 		case JdkTypeIDs.GC_DETAILED_EVACUATION_FAILED:
 			return new Color(0xFF0000);
 		case JdkTypeIDs.GC_DETAILED_PROMOTION_FAILED:
 			return new Color(0xD04E4E);
-		case JdkTypeIDs.GC_PAUSE:
-			return new Color(0xDC3C00);
-		case JdkTypeIDs.GC_PAUSE_L1:
-			return new Color(0xE6CB45);
-		case JdkTypeIDs.GC_PAUSE_L2:
-			return new Color(0x458AE6);
-		case JdkTypeIDs.GC_PAUSE_L3:
-			return new Color(0xE645E2);
-		case JdkTypeIDs.GC_PAUSE_L4:
-			return new Color(0x85A115);
 		case JdkTypeIDs.EXECUTION_SAMPLE:
 			return new Color(0xCC66FF);
 		case JdkTypeIDs.EXECUTION_SAMPLING_INFO_EVENT_ID:
 			return new Color(0xE6C940);
-		case JdkTypeIDs.VM_OPERATIONS:
-			return new Color(0xBA6F1F);
 		case JdkTypeIDs.PROCESSES:
 			return new Color(0xE37A44);
-		case JdkTypeIDs.COMPILATION:
-			return new Color(0xF7EA2A);
 		case JdkTypeIDs.CONCURRENT_MODE_FAILURE:
 			return new Color(0xFF0000);
 		case JdkTypeIDs.CONTEXT_SWITCH_RATE:
 			return new Color(0x7940E6);
 		case JdkTypeIDs.CPU_INFORMATION:
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/messages/internal/Messages.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/messages/internal/Messages.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/messages/internal/Messages.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/messages/internal/Messages.java
@@ -97,10 +97,12 @@
 	public static String CompilationsPage_COMPILATIONS_TABLE_SELECTION;
 	public static String CompilationsPage_PAGE_NAME;
 	public static String CompilationsPage_ROW_DURATIONS;
 	public static String CompilationsPage_TAB_COMPILATIONS;
 	public static String CompilationsPage_TAB_COMPILATIONS_FAILED;
+	public static String DropdownLaneFilter_QUICK_FILTER;
+	public static String DropdownLaneFilter_THREAD_STATE_SELECTION;
 	public static String DUMP_RECORDING_DEFAULT_TIMESPAN_TO_DUMP;
 	public static String DUMP_RECORDING_NO_DEFAULT;
 	public static String DUMP_RECORDING_TIMESPAN;
 	public static String DUMP_RECORDING_TIMESPAN_LESS_THAN_ZERO;
 	public static String DUMP_RECORDING_TIMESPAN_UNPARSABLE;
@@ -506,14 +508,23 @@
 	public static String TABLECOMPONENT_GROUP_BY;
 	public static String TABLECOMPONENT_HISTOGRAM_SELECTION;
 	public static String TABLECOMPONENT_NONE;
 	public static String ThreadDumpsPage_PAGE_NAME;
 	public static String ThreadsPage_EDIT_LANES;
+	public static String ThreadsPage_FOLD_CHART_TOOLTIP;
+	public static String ThreadsPage_FOLD_TABLE_TOOLTIP;
 	public static String ThreadsPage_HIDE_THREAD_ACTION;
+	public static String ThreadsPage_LANE_FILTER_HEADER;
 	public static String ThreadsPage_LANE_TOOLTIP_TITLE;
 	public static String ThreadsPage_NAME;
+	public static String ThreadsPage_NAME_LEGACY;
 	public static String ThreadsPage_RESET_CHART_TO_SELECTION_ACTION;
+	public static String ThreadsPage_SHOW_CHART_TOOLTIP;
+	public static String ThreadsPage_SHOW_TABLE_TOOLTIP;
+	public static String ThreadsPage_TABLE_POPUP_DESCRIPTION;
+	public static String ThreadsPage_TABLE_POPUP_TITLE;
+	public static String ThreadsPage_VIEW_THREAD_DETAILS;
 	public static String TlabPage_PAGE_NAME;
 	public static String TlabPage_THREADS_TAB_NAME;
 	public static String TlabPage_METHODS_TAB_NAME;
 	public static String TlabPage_ROW_TLAB_ALLOCATIONS;
 	public static String TlabPage_ROW_TLAB_ALLOCATIONS_DESC;
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ChartAndTableUI.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ChartAndTableUI.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ChartAndTableUI.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ChartAndTableUI.java
@@ -82,29 +82,38 @@
 
 	private static final String SASH = "sash"; //$NON-NLS-1$
 	private static final String TABLE = "table"; //$NON-NLS-1$
 	private static final String CHART = "chart"; //$NON-NLS-1$
 	private static final String SELECTED = "selected"; //$NON-NLS-1$
-	private final IItemFilter pageFilter;
-	private final StreamModel model;
+	private static final int X_OFFSET = 180;
+	private IItemFilter pageFilter;
+	protected StreamModel model;
 	protected CheckboxTableViewer chartLegend;
-	protected final Form form;
-	protected final Composite chartContainer;
-	protected final ChartCanvas chartCanvas;
-	protected final FilterComponent tableFilterComponent;
-	protected final ItemHistogram table;
-	protected final SashForm sash;
-	private final IPageContainer pageContainer;
+	protected Form form;
+	protected Composite chartContainer;
+	protected ChartCanvas chartCanvas;
+	protected FilterComponent tableFilterComponent;
+	protected ItemHistogram table;
+	protected SashForm sash;
+	private IPageContainer pageContainer;
 	protected List<IAction> allChartSeriesActions;
 	private IItemCollection selectionItems;
 	private IRange<IQuantity> timeRange;
 	protected XYChart chart;
 	protected FlavorSelector flavorSelector;
 
 	ChartAndTableUI(IItemFilter pageFilter, StreamModel model, Composite parent, FormToolkit toolkit,
 			IPageContainer pageContainer, IState state, String sectionTitle, IItemFilter tableFilter, Image icon,
 			FlavorSelectorState flavorSelectorState, IAttribute<?> classifier) {
+		init(pageFilter, model, parent, toolkit, pageContainer, state, sectionTitle, tableFilter, icon,
+				flavorSelectorState, classifier);
+	}
+
+	protected void init(
+		IItemFilter pageFilter, StreamModel model, Composite parent, FormToolkit toolkit, IPageContainer pageContainer,
+		IState state, String sectionTitle, IItemFilter tableFilter, Image icon, FlavorSelectorState flavorSelectorState,
+		IAttribute<?> classifier) {
 		this.pageFilter = pageFilter;
 		this.model = model;
 		this.pageContainer = pageContainer;
 		form = DataPageToolkit.createForm(parent, toolkit, sectionTitle, icon);
 		sash = new SashForm(form.getBody(), SWT.VERTICAL);
@@ -137,11 +146,11 @@
 		gd.widthHint = 180;
 		chartLegend.getControl().setLayoutData(gd);
 		PersistableSashForm.loadState(sash, state.getChild(SASH));
 		DataPageToolkit.createChartTimestampTooltip(chartCanvas);
 
-		chart = new XYChart(pageContainer.getRecordingRange(), RendererToolkit.empty(), 180);
+		chart = new XYChart(pageContainer.getRecordingRange(), RendererToolkit.empty(), X_OFFSET);
 		DataPageToolkit.setChart(chartCanvas, chart, pageContainer::showSelection);
 		SelectionStoreActionToolkit.addSelectionStoreRangeActions(pageContainer.getSelectionStore(), chart,
 				JfrAttributes.LIFETIME, NLS.bind(Messages.ChartAndTableUI_TIMELINE_SELECTION, form.getText()),
 				chartCanvas.getContextMenu());
 		buildChart();
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPage.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPage.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPage.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPage.java
@@ -39,15 +39,22 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
+import org.eclipse.jface.action.GroupMarker;
 import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.action.IToolBarManager;
 import org.eclipse.jface.action.Separator;
 import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.jface.viewers.TableViewer;
 import org.eclipse.swt.SWT;
+import org.eclipse.swt.layout.GridData;
 import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Item;
+import org.eclipse.swt.widgets.Listener;
 import org.eclipse.ui.forms.widgets.FormToolkit;
 import org.openjdk.jmc.common.IMCThread;
 import org.openjdk.jmc.common.IState;
 import org.openjdk.jmc.common.IWritableState;
 import org.openjdk.jmc.common.item.Aggregators;
@@ -74,10 +81,11 @@
 import org.openjdk.jmc.flightrecorder.ui.common.ImageConstants;
 import org.openjdk.jmc.flightrecorder.ui.common.ItemHistogram;
 import org.openjdk.jmc.flightrecorder.ui.common.ItemHistogram.HistogramSelection;
 import org.openjdk.jmc.flightrecorder.ui.common.ItemHistogram.ItemHistogramBuilder;
 import org.openjdk.jmc.flightrecorder.ui.common.ItemRow;
+import org.openjdk.jmc.flightrecorder.ui.common.DropdownLaneFilter;
 import org.openjdk.jmc.flightrecorder.ui.common.ThreadGraphLanes;
 import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
 import org.openjdk.jmc.ui.UIPlugin;
 import org.openjdk.jmc.ui.charts.IXDataRenderer;
 import org.openjdk.jmc.ui.charts.QuantitySpanRenderer;
@@ -152,55 +160,171 @@
 			return null;
 		}, Messages.JavaApplicationPage_COLUMN_THREAD_DURATION,
 				Messages.JavaApplicationPage_COLUMN_THREAD_DURATION_DESC);
 	}
 
-	private class ThreadsPageUi extends ChartAndTableUI {
+	private class ThreadsPageUi extends ThreadsPageLayoutUI {
 		private static final String THREADS_TABLE_FILTER = "threadsTableFilter"; //$NON-NLS-1$
+		private static final String FOLD_CHART_ACTION = "foldChartAction"; //$NON-NLS-1$
+		private static final String FOLD_TABLE_ACTION = "foldTableAction"; //$NON-NLS-1$
 		private static final String HIDE_THREAD = "hideThread"; //$NON-NLS-1$
 		private static final String RESET_CHART = "resetChart"; //$NON-NLS-1$
+		public static final String TOOLBAR_FOLD_ACTIONS = "foldActions"; //$NON-NLS-1$
 		private Boolean isChartMenuActionsInit;
 		private Boolean isChartModified;
 		private Boolean reloadThreads;
-		private IAction hideThreadAction;
+		private IAction foldChartAction;
+		private IAction foldTableAction;
+		private IAction hideThreadActionChart;
+		private IAction hideThreadActionText;
 		private IAction resetChartAction;
+		private int[] weights;
 		private List<IXDataRenderer> threadRows;
-		private MCContextMenuManager mm;
+		private MCContextMenuManager mmChart;
+		private MCContextMenuManager mmText;
+		private MCContextMenuManager[] mms;
 		private ThreadGraphLanes lanes;
+		private DropdownLaneFilter laneFilter;
 
 		ThreadsPageUi(Composite parent, FormToolkit toolkit, IPageContainer editor, IState state) {
 			super(pageFilter, getDataSource(), parent, toolkit, editor, state, getName(), pageFilter, getIcon(),
 					flavorSelectorState, JfrAttributes.EVENT_THREAD);
-			mm = (MCContextMenuManager) chartCanvas.getContextMenu();
-			sash.setOrientation(SWT.HORIZONTAL);
-			addActionsToContextMenu(mm);
+			mmChart = (MCContextMenuManager) chartCanvas.getContextMenu();
+			mmText = (MCContextMenuManager) textCanvas.getContextMenu();
+			mms = new MCContextMenuManager[] {mmChart, mmText};
+			initializeStoredSashWeights();
+			canvasSash.setOrientation(SWT.HORIZONTAL);
+			addResizeListenerToTableAndChartComponents();
+			addActionsToContextMenu();
 			// FIXME: The lanes field is initialized by initializeChartConfiguration which is called by the super constructor. This is too indirect for SpotBugs to resolve and should be simplified.
-			lanes.updateContextMenu(mm, false);
-
-			form.getToolBarManager()
-					.add(ActionToolkit.action(() -> lanes.openEditLanesDialog(mm, false),
-							Messages.ThreadsPage_EDIT_LANES,
-							FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_LANES_EDIT)));
-			form.getToolBarManager().update(true);
+			lanes.updateContextMenus(mms, false);
+			addActionsToToolbar(form.getToolBarManager());
 			chartLegend.getControl().dispose();
-			buildChart();
+			form.getToolBarManager().update(true);
+			setupLaneFilter();
+			buildChart(true);
 			table.getManager().setSelectionState(histogramSelectionState);
 			tableFilterComponent.loadState(state.getChild(THREADS_TABLE_FILTER));
+			for (Item columnWidget : ((TableViewer) table.getManager().getViewer()).getTable().getColumns()) {
+				columnWidget.addListener(SWT.Selection, e -> buildChart(false));
+			}
 			chart.setVisibleRange(visibleRange.getStart(), visibleRange.getEnd());
 			onFilterChange(tableFilter);
 		}
 
+		private void addActionsToToolbar(IToolBarManager tb) {
+			foldTableAction = ActionToolkit.checkAction(selected -> {
+				performToolbarAction(FOLD_TABLE_ACTION, selected);
+			}, sash.getWeights()[0] == 0 ? Messages.ThreadsPage_SHOW_TABLE_TOOLTIP
+					: Messages.ThreadsPage_FOLD_TABLE_TOOLTIP,
+					FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_TABLE));
+			foldTableAction.setChecked(sash.getWeights()[0] == 0 ? false : true);
+
+			foldChartAction = ActionToolkit.checkAction(selected -> {
+				performToolbarAction(FOLD_CHART_ACTION, selected);
+			}, sash.getWeights()[1] == 0 ? Messages.ThreadsPage_SHOW_CHART_TOOLTIP
+					: Messages.ThreadsPage_FOLD_CHART_TOOLTIP,
+					FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_CHART_BAR));
+			foldChartAction.setChecked(sash.getWeights()[1] == 0 ? false : true);
+
+			tb.add(new GroupMarker(TOOLBAR_FOLD_ACTIONS));
+			tb.appendToGroup(TOOLBAR_FOLD_ACTIONS, foldTableAction);
+			tb.appendToGroup(TOOLBAR_FOLD_ACTIONS, foldChartAction);
+			tb.appendToGroup(TOOLBAR_FOLD_ACTIONS, new Separator());
+
+			tb.add(ActionToolkit.action(() -> lanes.openEditLanesDialog(mms, false), Messages.ThreadsPage_EDIT_LANES,
+					FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_LANES_EDIT)));
+		}
+
+		private void addResizeListenerToTableAndChartComponents() {
+			tableFilterComponent.getComponent().addListener(SWT.Resize, new Listener() {
+				@Override
+				public void handleEvent(Event event) {
+					if (!foldTableAction.isChecked() && tableFilterComponent.getComponent().getSize().y > 0) {
+						foldTableAction.setChecked(true);
+					}
+				}
+			});
+
+			canvasSash.addListener(SWT.Resize, new Listener() {
+				@Override
+				public void handleEvent(Event event) {
+					if (!foldChartAction.isChecked() && chartCanvas.getSize().y > 0) {
+						foldChartAction.setChecked(true);
+					}
+				}
+			});
+		}
+
+		private void performToolbarAction(String action, boolean selected) {
+			switch (action) {
+			case FOLD_TABLE_ACTION:
+				if (selected) {
+					sash.setWeights(this.getStoredSashWeights());
+					foldTableAction.setToolTipText(Messages.ThreadsPage_FOLD_TABLE_TOOLTIP);
+				} else {
+					// if the chart is folded, don't fold the table
+					if (sash.getWeights()[1] == 0) {
+						this.foldTableAction.setChecked(true);
+					} else {
+						this.setStoredSashWeights(sash.getWeights());
+						sash.setWeights(new int[] {0, 2});
+						foldTableAction.setToolTipText(Messages.ThreadsPage_SHOW_TABLE_TOOLTIP);
+					}
+				}
+				break;
+			case FOLD_CHART_ACTION:
+				if (selected) {
+					sash.setWeights(this.getStoredSashWeights());
+					foldChartAction.setToolTipText(Messages.ThreadsPage_FOLD_CHART_TOOLTIP);
+				} else {
+					// if the table is folded, don't fold the chart
+					if (sash.getWeights()[0] == 0) {
+						this.foldChartAction.setChecked(true);
+					} else {
+						this.setStoredSashWeights(sash.getWeights());
+						sash.setWeights(new int[] {1, 0});
+						foldChartAction.setToolTipText(Messages.ThreadsPage_SHOW_CHART_TOOLTIP);
+					}
+				}
+				break;
+			}
+		}
+
+		private void initializeStoredSashWeights() {
+			// if either the chart or table are folded on init, store a default value of {1, 2}
+			if (sash.getWeights()[0] == 0 || sash.getWeights()[1] == 0) {
+				this.setStoredSashWeights(new int[] {1, 2});
+			} else {
+				this.setStoredSashWeights(sash.getWeights());
+			}
+		}
+
+		protected int[] getStoredSashWeights() {
+			return this.weights;
+		}
+
+		protected void setStoredSashWeights(int[] weights) {
+			this.weights = weights;
+		}
+
+		private void setupLaneFilter() {
+			MCContextMenuManager[] mms = {mmChart, mmText};
+			laneFilter = new DropdownLaneFilter(controlBar.getLaneFilterContainer(), lanes, mms);
+			laneFilter.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, false, false));
+		}
+
 		/**
 		 * Hides a thread from the chart and rebuilds the chart
 		 */
 		private void hideThread(Object thread) {
 			if (this.threadRows != null && this.threadRows.size() > 0 && thread instanceof IMCThread) {
 				int index = indexOfThread(thread);
 				if (index != -1) {
 					this.threadRows.remove(index);
 					this.reloadThreads = false;
-					buildChart();
+					buildChart(false);
 					if (!this.isChartModified) {
 						this.isChartModified = true;
 						setResetChartActionEnablement(true);
 					}
 				}
@@ -229,43 +353,52 @@
 		}
 
 		/**
 		 * Update the context menu to include actions to hide threads and reset the chart
 		 */
-		private void addActionsToContextMenu(MCContextMenuManager mm) {
-			mm.add(new Separator());
+		private void addActionsToContextMenu() {
+			mmChart.add(new Separator());
+			mmText.add(new Separator());
+			IAction hideThreadActionChart = ActionToolkit.action(
+					() -> this.hideThread(chartCanvas.getHoveredItemData()), Messages.ThreadsPage_HIDE_THREAD_ACTION,
+					UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_DELETE));
+			hideThreadActionChart.setId(HIDE_THREAD);
+			this.hideThreadActionChart = hideThreadActionChart;
+			mmChart.add(hideThreadActionChart);
 
-			IAction hideThreadAction = ActionToolkit.action(() -> this.hideThread(chartCanvas.getHoveredItemData()),
+			IAction hideThreadActionText = ActionToolkit.action(() -> this.hideThread(textCanvas.getHoveredItemData()),
 					Messages.ThreadsPage_HIDE_THREAD_ACTION,
 					UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_DELETE));
-			hideThreadAction.setId(HIDE_THREAD);
-			this.hideThreadAction = hideThreadAction;
-			mm.add(hideThreadAction);
+			hideThreadActionText.setId(HIDE_THREAD);
+			this.hideThreadActionText = hideThreadActionText;
+			mmText.add(hideThreadActionText);
 
 			IAction resetChartAction = ActionToolkit.action(() -> this.resetChartToSelection(),
 					Messages.ThreadsPage_RESET_CHART_TO_SELECTION_ACTION,
 					UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_REFRESH));
 			resetChartAction.setId(RESET_CHART);
 			resetChartAction.setEnabled(this.isChartModified);
 			this.resetChartAction = resetChartAction;
-			mm.add(resetChartAction);
+			mmChart.add(resetChartAction);
+			mmText.add(resetChartAction);
 
 			this.isChartMenuActionsInit = true;
 		}
 
 		/**
 		 * Redraws the chart, and disables the reset chart menu action
 		 */
 		private void resetChartToSelection() {
-			buildChart();
+			buildChart(false);
 			this.isChartModified = false;
 			setResetChartActionEnablement(false);
 			setHideThreadActionEnablement(true);
 		}
 
 		private void setHideThreadActionEnablement(Boolean enabled) {
-			this.hideThreadAction.setEnabled(enabled);
+			this.hideThreadActionChart.setEnabled(enabled);
+			this.hideThreadActionText.setEnabled(enabled);
 		}
 
 		private void setResetChartActionEnablement(Boolean enabled) {
 			this.resetChartAction.setEnabled(enabled);
 		}
@@ -277,26 +410,28 @@
 		}
 
 		@Override
 		protected IXDataRenderer getChartRenderer(IItemCollection itemsInTable, HistogramSelection tableSelection) {
 			List<IXDataRenderer> rows = new ArrayList<>();
-
+			ItemHistogram histogram = table;
 			IItemCollection selectedItems;
 			HistogramSelection selection;
 			if (tableSelection.getRowCount() == 0) {
 				selectedItems = itemsInTable;
-				selection = table.getAllRows();
+				selection = histogram.getAllRows();
 			} else {
 				selectedItems = tableSelection.getItems();
 				selection = tableSelection;
 			}
 			boolean useDefaultSelection = rows.size() > 1;
 			if (lanes.getLaneDefinitions().stream().anyMatch(a -> a.isEnabled()) && selection.getRowCount() > 0) {
 				if (this.reloadThreads) {
 					this.threadRows = selection
 							.getSelectedRows((object, items) -> lanes.buildThreadRenderer(object, items))
 							.collect(Collectors.toList());
+					chartCanvas.setNumItems(this.threadRows.size());
+					textCanvas.setNumItems(this.threadRows.size());
 					this.isChartModified = false;
 					if (this.isChartMenuActionsInit) {
 						setResetChartActionEnablement(false);
 						setHideThreadActionEnablement(true);
 					}
@@ -341,11 +476,11 @@
 		@Override
 		protected List<IAction> initializeChartConfiguration(IState state) {
 			this.isChartMenuActionsInit = false;
 			this.isChartModified = false;
 			this.reloadThreads = true;
-			lanes = new ThreadGraphLanes(() -> getDataSource(), () -> buildChart());
+			lanes = new ThreadGraphLanes(() -> getDataSource(), () -> buildChart(false));
 			return lanes.initializeChartConfiguration(Stream.of(state.getChildren(THREAD_LANE)));
 		}
 	}
 
 	private FlavorSelectorState flavorSelectorState;
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPageLayoutUI.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPageLayoutUI.java
--- /dev/null
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPageLayoutUI.java
@@ -0,0 +1,349 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.flightrecorder.ui.pages;
+
+import org.eclipse.jface.viewers.StructuredSelection;
+import org.eclipse.osgi.util.NLS;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.SashForm;
+import org.eclipse.swt.custom.ScrolledComposite;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.FormAttachment;
+import org.eclipse.swt.layout.FormData;
+import org.eclipse.swt.layout.FormLayout;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Listener;
+import org.eclipse.ui.forms.widgets.FormToolkit;
+
+import org.openjdk.jmc.common.IState;
+import org.openjdk.jmc.common.IWritableState;
+import org.openjdk.jmc.common.item.IAttribute;
+import org.openjdk.jmc.common.item.IItemCollection;
+import org.openjdk.jmc.common.item.IItemFilter;
+import org.openjdk.jmc.common.unit.IQuantity;
+import org.openjdk.jmc.common.unit.IRange;
+import org.openjdk.jmc.flightrecorder.JfrAttributes;
+import org.openjdk.jmc.flightrecorder.ui.IPageContainer;
+import org.openjdk.jmc.flightrecorder.ui.StreamModel;
+import org.openjdk.jmc.flightrecorder.ui.common.DataPageToolkit;
+import org.openjdk.jmc.flightrecorder.ui.common.FilterComponent;
+import org.openjdk.jmc.flightrecorder.ui.common.FlavorSelector;
+import org.openjdk.jmc.flightrecorder.ui.common.FlavorSelector.FlavorSelectorState;
+import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
+import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStoreActionToolkit;
+import org.openjdk.jmc.ui.charts.IXDataRenderer;
+import org.openjdk.jmc.ui.charts.RendererToolkit;
+import org.openjdk.jmc.ui.charts.XYChart;
+import org.openjdk.jmc.ui.column.ColumnMenusFactory;
+import org.openjdk.jmc.ui.common.util.Environment;
+import org.openjdk.jmc.ui.handlers.ActionToolkit;
+import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
+import org.openjdk.jmc.ui.misc.ChartCanvas;
+import org.openjdk.jmc.ui.misc.ChartControlBar;
+import org.openjdk.jmc.ui.misc.ActionUiToolkit;
+import org.openjdk.jmc.ui.misc.ChartButtonGroup;
+import org.openjdk.jmc.ui.misc.ChartTextCanvas;
+import org.openjdk.jmc.ui.misc.PersistableSashForm;
+import org.openjdk.jmc.ui.misc.TimelineCanvas;
+
+abstract class ThreadsPageLayoutUI extends ChartAndTableUI {
+
+	private static final double Y_SCALE = Display.getCurrent().getDPI().y / Environment.getNormalDPI();
+	private static final String TABLE = "table"; //$NON-NLS-1$
+	private static final String CHART = "chart"; //$NON-NLS-1$
+	private static final String CANVAS_SASH = "canvasSash"; //$NON-NLS-1$
+	private static final String PAGE_SASH = "pageSash"; //$NON-NLS-1$
+	private static final String SELECTED = "selected"; //$NON-NLS-1$
+	private static final int TIMELINE_HEIGHT = 40;
+	private static final int X_OFFSET = 0;
+	private static final int Y_OFFSET = 0;
+	protected ChartControlBar controlBar;
+	protected ChartTextCanvas textCanvas;
+	protected IPageContainer pageContainer;
+	private Composite zoomPanContainer;
+	private ChartButtonGroup buttonGroup;
+	private IItemCollection selectionItems;
+	private IItemFilter pageFilter;
+	private IRange<IQuantity> timeRange;
+	protected SashForm canvasSash;
+	private TimelineCanvas timelineCanvas;
+
+	ThreadsPageLayoutUI(IItemFilter pageFilter, StreamModel model, Composite parent, FormToolkit toolkit,
+			IPageContainer pageContainer, IState state, String sectionTitle, IItemFilter tableFilter, Image icon,
+			FlavorSelectorState flavorSelectorState, IAttribute<?> classifier) {
+		super(pageFilter, model, parent, toolkit, pageContainer, state, sectionTitle, tableFilter, icon,
+				flavorSelectorState, classifier);
+	}
+
+	protected void init(
+		IItemFilter pageFilter, StreamModel model, Composite parent, FormToolkit toolkit, IPageContainer pageContainer,
+		IState state, String sectionTitle, IItemFilter tableFilter, Image icon, FlavorSelectorState flavorSelectorState,
+		IAttribute<?> classifier) {
+		this.pageFilter = pageFilter;
+		this.model = model;
+		this.pageContainer = pageContainer;
+		form = DataPageToolkit.createForm(parent, toolkit, sectionTitle, icon);
+		sash = new SashForm(form.getBody(), SWT.VERTICAL);
+		toolkit.adapt(sash);
+
+		setupTable(state, sectionTitle, tableFilter, classifier);
+		setupChartContainers(toolkit);
+
+		allChartSeriesActions = initializeChartConfiguration(state);
+		IState chartState = state.getChild(CHART);
+		ActionToolkit.loadCheckState(chartState, allChartSeriesActions.stream());
+		chartLegend = ActionUiToolkit.buildCheckboxViewer(chartContainer, allChartSeriesActions.stream());
+		GridData gridData = new GridData(SWT.FILL, SWT.FILL, false, true);
+		gridData.widthHint = 180;
+		chartLegend.getControl().setLayoutData(gridData);
+		DataPageToolkit.createChartTimestampTooltip(chartCanvas);
+
+		chart = new XYChart(pageContainer.getRecordingRange(), RendererToolkit.empty(), X_OFFSET, Y_OFFSET,
+				timelineCanvas, controlBar, buttonGroup);
+		DataPageToolkit.setChart(chartCanvas, chart, pageContainer::showSelection);
+		DataPageToolkit.setChart(textCanvas, chart, pageContainer::showSelection);
+		SelectionStoreActionToolkit.addSelectionStoreRangeActions(pageContainer.getSelectionStore(), chart,
+				JfrAttributes.LIFETIME, NLS.bind(Messages.ChartAndTableUI_TIMELINE_SELECTION, form.getText()),
+				chartCanvas.getContextMenu());
+		SelectionStoreActionToolkit.addSelectionStoreRangeActions(pageContainer.getSelectionStore(), chart,
+				JfrAttributes.LIFETIME, NLS.bind(Messages.ChartAndTableUI_TIMELINE_SELECTION, form.getText()),
+				textCanvas.getContextMenu());
+
+		chartCanvas.setZoomOnClickListener(mouseDown -> buttonGroup.zoomOnClick(mouseDown));
+		chartCanvas.setZoomToSelectionListener(() -> buttonGroup.zoomToSelection());
+
+		// Wire-up the chart & text canvases to the control bar and button group
+		chartCanvas.setTextCanvas(textCanvas);
+		textCanvas.setChartCanvas(chartCanvas);
+		controlBar.setChart(chart);
+		controlBar.setChartCanvas(chartCanvas);
+		controlBar.setTextCanvas(textCanvas);
+		buttonGroup.createZoomPan(zoomPanContainer);
+		timelineCanvas.setChart(chart);
+
+		if (chartState != null) {
+			final String legendSelection = chartState.getAttribute(SELECTED);
+
+			if (legendSelection != null) {
+				allChartSeriesActions.stream().filter(ia -> legendSelection.equals(ia.getId())).findFirst()
+						.ifPresent(a -> chartLegend.setSelection(new StructuredSelection(a)));
+			}
+		}
+
+		if (state.getChild(PAGE_SASH) == null) {
+			sash.setWeights(new int[] {0, 3});
+		} else {
+			PersistableSashForm.loadState(sash, state.getChild(PAGE_SASH));
+		}
+
+		if (state.getChild(CANVAS_SASH) == null) {
+			canvasSash.setWeights(new int[] {1, 4});
+		} else {
+			PersistableSashForm.loadState(canvasSash, state.getChild(CANVAS_SASH));
+		}
+
+		flavorSelector = FlavorSelector.itemsWithTimerange(form, pageFilter, model.getItems(), pageContainer,
+				this::onFlavorSelected, this::onSetRange, flavorSelectorState);
+	}
+
+	private void setupTable(IState state, String sectionTitle, IItemFilter tableFilter, IAttribute<?> classifier) {
+		// Setup the table
+		table = buildHistogram(sash, state.getChild(TABLE), classifier);
+		MCContextMenuManager mm = MCContextMenuManager.create(table.getManager().getViewer().getControl());
+		ColumnMenusFactory.addDefaultMenus(table.getManager(), mm);
+		table.getManager().getViewer().addSelectionChangedListener(e -> buildChart(true));
+		table.getManager().getViewer()
+				.addSelectionChangedListener(e -> pageContainer.showSelection(table.getSelection().getItems()));
+		SelectionStoreActionToolkit.addSelectionStoreActions(pageContainer.getSelectionStore(), table,
+				NLS.bind(Messages.ChartAndTableUI_HISTOGRAM_SELECTION, sectionTitle), mm);
+		tableFilterComponent = FilterComponent.createFilterComponent(table.getManager().getViewer().getControl(),
+				table.getManager(), tableFilter, model.getItems().apply(pageFilter),
+				pageContainer.getSelectionStore()::getSelections, this::onFilterChange);
+		mm.add(tableFilterComponent.getShowFilterAction());
+		mm.add(tableFilterComponent.getShowSearchAction());
+	}
+
+	private void setupChartContainers(FormToolkit toolkit) {
+		// Scrolled Composite containing all of the chart-related components
+		ScrolledComposite scChartContainer = new ScrolledComposite(sash, SWT.H_SCROLL | SWT.V_SCROLL);
+		scChartContainer.setAlwaysShowScrollBars(false);
+		scChartContainer.setExpandHorizontal(true);
+		scChartContainer.setExpandVertical(true);
+		scChartContainer.addListener(SWT.Resize, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				int width = controlBar.computeSize(SWT.DEFAULT, SWT.DEFAULT).x;
+				int height = controlBar.computeSize(SWT.DEFAULT, SWT.DEFAULT).y
+						+ buttonGroup.computeSize(SWT.DEFAULT, SWT.DEFAULT).y;
+				if (width > 0 && height > 0) {
+					scChartContainer.setMinSize(scChartContainer.computeSize(width, height));
+					scChartContainer.removeListener(SWT.Resize, this);
+				}
+			}
+		});
+
+		// chartContainer to layout all of the chart components
+		chartContainer = toolkit.createComposite(scChartContainer);
+		chartContainer.setLayout(new GridLayout());
+		chartContainer.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
+		scChartContainer.setContent(chartContainer);
+
+		// Chart Control Toolbar
+		Listener resetListener = new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				onSetRange(false);
+				table.getManager().getViewer().setSelection(null);
+			}
+		};
+		controlBar = new ChartControlBar(chartContainer, resetListener, pageContainer.getRecordingRange());
+		controlBar.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, false));
+		buttonGroup = controlBar.getButtonGroup();
+
+		// Container to hold the chartContainer and a zoom-pan overlay
+		Composite zoomPanAndChartContainer = toolkit.createComposite(chartContainer);
+		zoomPanAndChartContainer.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
+		zoomPanAndChartContainer.setLayout(new FormLayout());
+
+		// Container to hold fixed zoom-pan display
+		zoomPanContainer = toolkit.createComposite(zoomPanAndChartContainer);
+		zoomPanContainer.setLayout(new FillLayout());
+		FormData fd = new FormData();
+		fd.height = 80;
+		fd.width = 150;
+		fd.bottom = new FormAttachment(100, -12);
+		fd.right = new FormAttachment(100, -12);
+		zoomPanContainer.setLayoutData(fd);
+
+		// SashForm to hold the two canvas components: chart text canvas on the left, chart canvas on the right
+		canvasSash = new SashForm(zoomPanAndChartContainer, SWT.HORIZONTAL);
+		fd = new FormData();
+		fd.right = new FormAttachment(100, -1);
+		fd.top = new FormAttachment(0, 1);
+		fd.left = new FormAttachment(0, 1);
+		fd.bottom = new FormAttachment(100, -1);
+		canvasSash.setLayoutData(fd);
+		toolkit.adapt(canvasSash);
+
+		ScrolledComposite scText = new ScrolledComposite(canvasSash, SWT.BORDER | SWT.V_SCROLL);
+		GridData scTextGd = new GridData(SWT.FILL, SWT.FILL, false, true);
+		textCanvas = new ChartTextCanvas(scText);
+		textCanvas.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, true));
+		scTextGd.widthHint = 180;
+		scText.setLayoutData(scTextGd);
+		scText.setContent(textCanvas);
+		scText.setAlwaysShowScrollBars(false);
+		scText.setExpandHorizontal(true);
+		scText.setExpandVertical(true);
+
+		ScrolledComposite scChart = new ScrolledComposite(canvasSash, SWT.BORDER | SWT.V_SCROLL);
+		chartCanvas = new ChartCanvas(scChart);
+		chartCanvas.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
+		scChart.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
+		scChart.setContent(chartCanvas);
+		scChart.setAlwaysShowScrollBars(true);
+		scChart.setExpandHorizontal(true);
+		scChart.setExpandVertical(true);
+
+		timelineCanvas = new TimelineCanvas(chartContainer, chartCanvas, canvasSash, Y_SCALE);
+		GridData gridData = new GridData(SWT.FILL, SWT.DEFAULT, true, false);
+		gridData.heightHint = (int) (TIMELINE_HEIGHT * Y_SCALE);
+		timelineCanvas.setLayoutData(gridData);
+	}
+
+	protected void onFilterChange(IItemFilter filter) {
+		IItemCollection items = getItems();
+		if (tableFilterComponent.isVisible()) {
+			table.show(items.apply(filter));
+			tableFilterComponent.setColor(table.getAllRows().getRowCount());
+		} else if (table != null) {
+			table.show(items);
+		}
+	}
+
+	private void onSetRange(Boolean useRange) {
+		IRange<IQuantity> range = useRange ? timeRange : pageContainer.getRecordingRange();
+		chart.setVisibleRange(range.getStart(), range.getEnd());
+		chart.resetZoomFactor();
+		if (table != null) {
+			table.getManager().getViewer().setSelection(null);
+		}
+		chartCanvas.resetLaneHeight();
+		buildChart(true);
+	}
+
+	@Override
+	public void saveTo(IWritableState writableState) {
+		super.saveTo(writableState);
+		PersistableSashForm.saveState(sash, writableState.createChild(PAGE_SASH));
+		PersistableSashForm.saveState(canvasSash, writableState.createChild(CANVAS_SASH));
+	}
+
+	private void onFlavorSelected(IItemCollection items, IRange<IQuantity> timeRange) {
+		this.selectionItems = items;
+		this.timeRange = timeRange;
+		table.show(getItems());
+
+		if (selectionItems != null) {
+			Object[] tableInput = (Object[]) table.getManager().getViewer().getInput();
+			if (tableInput != null) {
+				table.getManager().getViewer().setSelection(new StructuredSelection(tableInput));
+			} else {
+				table.getManager().getViewer().setSelection(null);
+			}
+		}
+	}
+
+	protected void buildChart(boolean resetLaneHeightControls) {
+		IXDataRenderer rendererRoot = getChartRenderer(getItems(), table.getSelection());
+		if (resetLaneHeightControls) {
+			controlBar.resetLaneHeightToMinimum();
+		}
+		chartCanvas.replaceRenderer(rendererRoot);
+		textCanvas.replaceRenderer(rendererRoot);
+	}
+
+	private IItemCollection getItems() {
+		return selectionItems != null ? selectionItems.apply(pageFilter) : model.getItems().apply(pageFilter);
+	}
+
+	public void setTimeRange(IRange<IQuantity> range) {
+		this.timeRange = range;
+	}
+}
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPageLegacy.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPageLegacy.java
--- /dev/null
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPageLegacy.java
@@ -0,0 +1,366 @@
+/*
+ * Copyright (c) 2018, 2020 Oracle and/or its affiliates. All rights reserved.
+ * 
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.flightrecorder.ui.pages;
+
+import static org.openjdk.jmc.common.item.Aggregators.max;
+import static org.openjdk.jmc.common.item.Aggregators.min;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.action.Separator;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.ui.forms.widgets.FormToolkit;
+import org.openjdk.jmc.common.IMCThread;
+import org.openjdk.jmc.common.IState;
+import org.openjdk.jmc.common.IWritableState;
+import org.openjdk.jmc.common.item.Aggregators;
+import org.openjdk.jmc.common.item.IAggregator;
+import org.openjdk.jmc.common.item.IAttribute;
+import org.openjdk.jmc.common.item.IItemCollection;
+import org.openjdk.jmc.common.item.IItemFilter;
+import org.openjdk.jmc.common.item.ItemFilters;
+import org.openjdk.jmc.common.unit.IQuantity;
+import org.openjdk.jmc.common.unit.IRange;
+import org.openjdk.jmc.flightrecorder.JfrAttributes;
+import org.openjdk.jmc.flightrecorder.jdk.JdkAttributes;
+import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;
+import org.openjdk.jmc.flightrecorder.rules.util.JfrRuleTopics;
+import org.openjdk.jmc.flightrecorder.ui.FlightRecorderUI;
+import org.openjdk.jmc.flightrecorder.ui.IDataPageFactory;
+import org.openjdk.jmc.flightrecorder.ui.IDisplayablePage;
+import org.openjdk.jmc.flightrecorder.ui.IPageContainer;
+import org.openjdk.jmc.flightrecorder.ui.IPageDefinition;
+import org.openjdk.jmc.flightrecorder.ui.IPageUI;
+import org.openjdk.jmc.flightrecorder.ui.StreamModel;
+import org.openjdk.jmc.flightrecorder.ui.common.AbstractDataPage;
+import org.openjdk.jmc.flightrecorder.ui.common.FlavorSelector.FlavorSelectorState;
+import org.openjdk.jmc.flightrecorder.ui.common.ImageConstants;
+import org.openjdk.jmc.flightrecorder.ui.common.ItemHistogram;
+import org.openjdk.jmc.flightrecorder.ui.common.ItemHistogram.HistogramSelection;
+import org.openjdk.jmc.flightrecorder.ui.common.ItemHistogram.ItemHistogramBuilder;
+import org.openjdk.jmc.flightrecorder.ui.common.ItemRow;
+import org.openjdk.jmc.flightrecorder.ui.common.ThreadGraphLanes;
+import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
+import org.openjdk.jmc.ui.UIPlugin;
+import org.openjdk.jmc.ui.charts.IXDataRenderer;
+import org.openjdk.jmc.ui.charts.QuantitySpanRenderer;
+import org.openjdk.jmc.ui.charts.RendererToolkit;
+import org.openjdk.jmc.ui.column.ColumnManager.SelectionState;
+import org.openjdk.jmc.ui.column.TableSettings;
+import org.openjdk.jmc.ui.handlers.ActionToolkit;
+import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
+
+public class ThreadsPageLegacy extends AbstractDataPage {
+
+	public static class ThreadsPageLegacyFactory implements IDataPageFactory {
+
+		@Override
+		public String getName(IState state) {
+			return Messages.ThreadsPage_NAME_LEGACY;
+		}
+
+		@Override
+		public String[] getTopics(IState state) {
+			return new String[] {JfrRuleTopics.THREADS_TOPIC};
+		}
+
+		@Override
+		public ImageDescriptor getImageDescriptor(IState state) {
+			return FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.PAGE_THREADS);
+		}
+
+		@Override
+		public IDisplayablePage createPage(IPageDefinition definition, StreamModel items, IPageContainer editor) {
+			return new ThreadsPageLegacy(definition, items, editor);
+		}
+
+	}
+
+	private static final String THREAD_START_COL = "threadStart"; //$NON-NLS-1$
+	private static final String THREAD_END_COL = "threadEnd"; //$NON-NLS-1$
+	private static final String THREAD_DURATION_COL = "threadDuration"; //$NON-NLS-1$
+	private static final String THREAD_LANE = "threadLane"; //$NON-NLS-1$
+
+	private static final IItemFilter pageFilter = ItemFilters.hasAttribute(JfrAttributes.EVENT_THREAD);
+	private static final ItemHistogramBuilder HISTOGRAM = new ItemHistogramBuilder();
+
+	static {
+		HISTOGRAM.addColumn(JdkAttributes.EVENT_THREAD_GROUP_NAME);
+		HISTOGRAM.addColumn(JdkAttributes.EVENT_THREAD_ID);
+		HISTOGRAM.addColumn(THREAD_START_COL,
+				min(Messages.JavaApplicationPage_COLUMN_THREAD_START,
+						Messages.JavaApplicationPage_COLUMN_THREAD_START_DESC, JdkTypeIDs.JAVA_THREAD_START,
+						JfrAttributes.EVENT_TIMESTAMP));
+		/*
+		 * Will order empty cells before first end time.
+		 * 
+		 * It should be noted that no event (empty column cell) is considered less than all values
+		 * (this is common for all columns), which causes the column to sort threads without end
+		 * time (indicating that the thread ended after the end of the recording) is ordered before
+		 * the thread that ended first. While this is not optimal, we decided to accept it as it's
+		 * not obviously better to have this particular column ordering empty cells last in contrast
+		 * to all other columns.
+		 */
+		HISTOGRAM.addColumn(THREAD_END_COL,
+				max(Messages.JavaApplicationPage_COLUMN_THREAD_END, Messages.JavaApplicationPage_COLUMN_THREAD_END_DESC,
+						JdkTypeIDs.JAVA_THREAD_END, JfrAttributes.EVENT_TIMESTAMP));
+		HISTOGRAM.addColumn(THREAD_DURATION_COL, ic -> {
+			IQuantity threadStart = ic.apply(ItemFilters.type(JdkTypeIDs.JAVA_THREAD_START))
+					.getAggregate((IAggregator<IQuantity, ?>) Aggregators.min(JfrAttributes.EVENT_TIMESTAMP));
+			IQuantity threadEnd = ic.apply(ItemFilters.type(JdkTypeIDs.JAVA_THREAD_END))
+					.getAggregate((IAggregator<IQuantity, ?>) Aggregators.max(JfrAttributes.EVENT_TIMESTAMP));
+			if (threadStart != null && threadEnd != null) {
+				return threadEnd.subtract(threadStart);
+			}
+			return null;
+		}, Messages.JavaApplicationPage_COLUMN_THREAD_DURATION,
+				Messages.JavaApplicationPage_COLUMN_THREAD_DURATION_DESC);
+	}
+
+	private class ThreadsPageUi extends ChartAndTableUI {
+		private static final String THREADS_TABLE_FILTER = "threadsTableFilter"; //$NON-NLS-1$
+		private static final String HIDE_THREAD = "hideThread"; //$NON-NLS-1$
+		private static final String RESET_CHART = "resetChart"; //$NON-NLS-1$
+		private Boolean isChartMenuActionsInit;
+		private Boolean isChartModified;
+		private Boolean reloadThreads;
+		private IAction hideThreadAction;
+		private IAction resetChartAction;
+		private List<IXDataRenderer> threadRows;
+		private MCContextMenuManager mm;
+		private ThreadGraphLanes lanes;
+
+		ThreadsPageUi(Composite parent, FormToolkit toolkit, IPageContainer editor, IState state) {
+			super(pageFilter, getDataSource(), parent, toolkit, editor, state, getName(), pageFilter, getIcon(),
+					flavorSelectorState, JfrAttributes.EVENT_THREAD);
+			mm = (MCContextMenuManager) chartCanvas.getContextMenu();
+			sash.setOrientation(SWT.HORIZONTAL);
+			addActionsToContextMenu(mm);
+			// FIXME: The lanes field is initialized by initializeChartConfiguration which is called by the super constructor. This is too indirect for SpotBugs to resolve and should be simplified.
+			lanes.updateContextMenu(mm, false);
+
+			form.getToolBarManager()
+					.add(ActionToolkit.action(() -> lanes.openEditLanesDialog(mm, false),
+							Messages.ThreadsPage_EDIT_LANES,
+							FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_LANES_EDIT)));
+			form.getToolBarManager().update(true);
+			chartLegend.getControl().dispose();
+			buildChart();
+			table.getManager().setSelectionState(histogramSelectionState);
+			tableFilterComponent.loadState(state.getChild(THREADS_TABLE_FILTER));
+			chart.setVisibleRange(visibleRange.getStart(), visibleRange.getEnd());
+			onFilterChange(tableFilter);
+		}
+
+		/**
+		 * Hides a thread from the chart and rebuilds the chart
+		 */
+		private void hideThread(Object thread) {
+			if (this.threadRows != null && this.threadRows.size() > 0 && thread instanceof IMCThread) {
+				int index = indexOfThread(thread);
+				if (index != -1) {
+					this.threadRows.remove(index);
+					this.reloadThreads = false;
+					buildChart();
+					if (!this.isChartModified) {
+						this.isChartModified = true;
+						setResetChartActionEnablement(true);
+					}
+				}
+				if (this.threadRows.size() == 0) {
+					setHideThreadActionEnablement(false);
+				}
+			}
+		}
+
+		/**
+		 * Locates the index of the target Thread in the current selection list
+		 *
+		 * @param thread
+		 *            the thread of interest
+		 * @return the index of the thread in the current selection, or -1 if not found
+		 */
+		private int indexOfThread(Object thread) {
+			for (int i = 0; i < this.threadRows.size() && thread != null; i++) {
+				if (this.threadRows.get(i) instanceof QuantitySpanRenderer) {
+					if (thread.equals(((QuantitySpanRenderer) this.threadRows.get(i)).getData())) {
+						return i;
+					}
+				}
+			}
+			return -1;
+		}
+
+		/**
+		 * Update the context menu to include actions to hide threads and reset the chart
+		 */
+		private void addActionsToContextMenu(MCContextMenuManager mm) {
+			mm.add(new Separator());
+
+			IAction hideThreadAction = ActionToolkit.action(() -> this.hideThread(chartCanvas.getHoveredItemData()),
+					Messages.ThreadsPage_HIDE_THREAD_ACTION,
+					UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_DELETE));
+			hideThreadAction.setId(HIDE_THREAD);
+			this.hideThreadAction = hideThreadAction;
+			mm.add(hideThreadAction);
+
+			IAction resetChartAction = ActionToolkit.action(() -> this.resetChartToSelection(),
+					Messages.ThreadsPage_RESET_CHART_TO_SELECTION_ACTION,
+					UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_REFRESH));
+			resetChartAction.setId(RESET_CHART);
+			resetChartAction.setEnabled(this.isChartModified);
+			this.resetChartAction = resetChartAction;
+			mm.add(resetChartAction);
+
+			this.isChartMenuActionsInit = true;
+		}
+
+		/**
+		 * Redraws the chart, and disables the reset chart menu action
+		 */
+		private void resetChartToSelection() {
+			buildChart();
+			this.isChartModified = false;
+			setResetChartActionEnablement(false);
+			setHideThreadActionEnablement(true);
+		}
+
+		private void setHideThreadActionEnablement(Boolean enabled) {
+			this.hideThreadAction.setEnabled(enabled);
+		}
+
+		private void setResetChartActionEnablement(Boolean enabled) {
+			this.resetChartAction.setEnabled(enabled);
+		}
+
+		@Override
+		protected ItemHistogram buildHistogram(Composite parent, IState state, IAttribute<?> classifier) {
+			ItemHistogram build = HISTOGRAM.buildWithoutBorder(parent, classifier, TableSettings.forState(state));
+			return build;
+		}
+
+		@Override
+		protected IXDataRenderer getChartRenderer(IItemCollection itemsInTable, HistogramSelection tableSelection) {
+			List<IXDataRenderer> rows = new ArrayList<>();
+
+			IItemCollection selectedItems;
+			HistogramSelection selection;
+			if (tableSelection.getRowCount() == 0) {
+				selectedItems = itemsInTable;
+				selection = table.getAllRows();
+			} else {
+				selectedItems = tableSelection.getItems();
+				selection = tableSelection;
+			}
+			boolean useDefaultSelection = rows.size() > 1;
+			if (lanes.getLaneDefinitions().stream().anyMatch(a -> a.isEnabled()) && selection.getRowCount() > 0) {
+				if (this.reloadThreads) {
+					this.threadRows = selection
+							.getSelectedRows((object, items) -> lanes.buildThreadRenderer(object, items))
+							.collect(Collectors.toList());
+					this.isChartModified = false;
+					if (this.isChartMenuActionsInit) {
+						setResetChartActionEnablement(false);
+						setHideThreadActionEnablement(true);
+					}
+				} else {
+					this.reloadThreads = true;
+				}
+
+				double threadsWeight = Math.sqrt(threadRows.size()) * 0.15;
+				double otherRowWeight = Math.max(threadsWeight * 0.1, (1 - threadsWeight) / rows.size());
+				List<Double> weights = Stream
+						.concat(Stream.generate(() -> otherRowWeight).limit(rows.size()), Stream.of(threadsWeight))
+						.collect(Collectors.toList());
+				rows.add(RendererToolkit.uniformRows(this.threadRows));
+				useDefaultSelection = true;
+				rows = Arrays.asList(RendererToolkit.weightedRows(rows, weights));
+			}
+			IXDataRenderer root = rows.size() == 1 ? rows.get(0) : RendererToolkit.uniformRows(rows);
+			// We don't use the default selection when there is only one row. This is to get the correct payload.
+			return useDefaultSelection ? new ItemRow(root, selectedItems.apply(lanes.getEnabledLanesFilter())) : root;
+		}
+
+		@Override
+		protected void onFilterChange(IItemFilter filter) {
+			super.onFilterChange(filter);
+			tableFilter = filter;
+		}
+
+		@Override
+		public void saveTo(IWritableState state) {
+			super.saveTo(state);
+			tableFilterComponent.saveState(state.createChild(THREADS_TABLE_FILTER));
+			lanes.saveTo(state);
+			saveToLocal();
+		}
+
+		private void saveToLocal() {
+			flavorSelectorState = flavorSelector.getFlavorSelectorState();
+			histogramSelectionState = table.getManager().getSelectionState();
+			visibleRange = chart.getVisibleRange();
+		}
+
+		@Override
+		protected List<IAction> initializeChartConfiguration(IState state) {
+			this.isChartMenuActionsInit = false;
+			this.isChartModified = false;
+			this.reloadThreads = true;
+			lanes = new ThreadGraphLanes(() -> getDataSource(), () -> buildChart());
+			return lanes.initializeChartConfiguration(Stream.of(state.getChildren(THREAD_LANE)));
+		}
+	}
+
+	private FlavorSelectorState flavorSelectorState;
+	private SelectionState histogramSelectionState;
+	private IItemFilter tableFilter;
+	private IRange<IQuantity> visibleRange;
+
+	public ThreadsPageLegacy(IPageDefinition definition, StreamModel model, IPageContainer editor) {
+		super(definition, model, editor);
+		visibleRange = editor.getRecordingRange();
+	}
+
+	@Override
+	public IPageUI display(Composite parent, FormToolkit toolkit, IPageContainer editor, IState state) {
+		return new ThreadsPageUi(parent, toolkit, editor, state);
+	}
+
+}
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/resources/org/openjdk/jmc/flightrecorder/ui/messages/internal/messages.properties b/application/org.openjdk.jmc.flightrecorder.ui/src/main/resources/org/openjdk/jmc/flightrecorder/ui/messages/internal/messages.properties
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/resources/org/openjdk/jmc/flightrecorder/ui/messages/internal/messages.properties
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/resources/org/openjdk/jmc/flightrecorder/ui/messages/internal/messages.properties
@@ -102,10 +102,13 @@
 CompilationsPage_TAB_COMPILATIONS=Compilations
 CompilationsPage_TAB_COMPILATIONS_FAILED=Failed Compilations
 CONFIGURATION_EDIT_ACTION=Edit Configuration
 COUNT_COLUMN_NAME=Count
 
+DropdownLaneFilter_QUICK_FILTER=Quick Filter
+DropdownLaneFilter_THREAD_STATE_SELECTION=Thread State Selection
+
 DUMP_RECORDING_DEFAULT_TIMESPAN_TO_DUMP=When double-clicking on a recording in the JVM Browser
 DUMP_RECORDING_TIMESPAN_VALUE=Default time span when dumping the last part of a recording:
 DUMP_RECORDING_TIMESPAN=Dump the last part of the recording
 DUMP_RECORDING_WHOLE=Dump the whole recording
 DUMP_RECORDING_NO_DEFAULT=Show a dump dialog
@@ -489,15 +492,25 @@
 TABLECOMPONENT_NONE=[None]
 
 ThreadDumpsPage_PAGE_NAME=Thread Dumps
 
 ThreadsPage_EDIT_LANES=Edit Thread Lanes
+ThreadsPage_FOLD_CHART_TOOLTIP=Fold Chart
+ThreadsPage_FOLD_TABLE_TOOLTIP=Fold Table
 ThreadsPage_HIDE_THREAD_ACTION=Hide Thread From The Chart
+ThreadsPage_LANE_FILTER_HEADER=THREAD STATE SELECTION
 # {0} is the thread name, {1} is the lane name
 ThreadsPage_LANE_TOOLTIP_TITLE={0} / {1} Lane
 ThreadsPage_NAME=Threads
+ThreadsPage_NAME_LEGACY = (Legacy) Threads
 ThreadsPage_RESET_CHART_TO_SELECTION_ACTION=Reset The Chart To Current Selection
+ThreadsPage_SHOW_CHART_TOOLTIP=Show Chart
+ThreadsPage_SHOW_TABLE_TOOLTIP=Show Table
+ThreadsPage_VIEW_THREAD_DETAILS=View Thread Details
+ThreadsPage_TABLE_POPUP_DESCRIPTION=Store a thread selection to make a new filter
+ThreadsPage_TABLE_POPUP_TITLE=Thread Details
+
 TlabPage_PAGE_NAME=TLAB Allocations
 TlabPage_THREADS_TAB_NAME=By Threads
 TlabPage_METHODS_TAB_NAME=By Top Methods
 TlabPage_ROW_TLAB_ALLOCATIONS=TLAB Allocations
 TlabPage_ROW_TLAB_ALLOCATIONS_DESC=Data generated from allocation samples. The samples are collected either when acquiring a new thread local allocation buffer (TLAB) or when allocating outside of such buffers.
diff a/application/org.openjdk.jmc.ui/icons/fa-minus-16.png b/application/org.openjdk.jmc.ui/icons/fa-minus-16.png
Binary files /dev/null and application/org.openjdk.jmc.ui/icons/fa-minus-16.png differ
diff a/application/org.openjdk.jmc.ui/icons/fa-plus-16.png b/application/org.openjdk.jmc.ui/icons/fa-plus-16.png
Binary files /dev/null and application/org.openjdk.jmc.ui/icons/fa-plus-16.png differ
diff a/application/org.openjdk.jmc.ui/icons/fa-scale-to-fit-16.png b/application/org.openjdk.jmc.ui/icons/fa-scale-to-fit-16.png
Binary files /dev/null and application/org.openjdk.jmc.ui/icons/fa-scale-to-fit-16.png differ
diff a/application/org.openjdk.jmc.ui/icons/fa-scale-to-fit.svg b/application/org.openjdk.jmc.ui/icons/fa-scale-to-fit.svg
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/icons/fa-scale-to-fit.svg
@@ -0,0 +1,1 @@
+<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 14"><title>Scale-to-fit_option2</title><path d="M10,10.77a.74.74,0,0,1,.21-.53.73.73,0,0,1,.54-.22h3.87a.4.4,0,0,1,.27.11.37.37,0,0,1,.11.27v1.25a.36.36,0,0,1-.11.26.4.4,0,0,1-.27.11H12v2.63a.36.36,0,0,1-.11.26.4.4,0,0,1-.27.11H10.37a.36.36,0,0,1-.26-.11.33.33,0,0,1-.11-.26ZM15,22.4a.37.37,0,0,0-.11-.27.4.4,0,0,0-.27-.11H12V19.4a.37.37,0,0,0-.11-.27.4.4,0,0,0-.27-.11H10.37a.36.36,0,0,0-.26.11.33.33,0,0,0-.11.27v3.87a.72.72,0,0,0,.21.53.73.73,0,0,0,.54.22h3.87a.4.4,0,0,0,.27-.11.36.36,0,0,0,.11-.26Zm4-10.75a.33.33,0,0,0,.11.26.36.36,0,0,0,.26.11H22v2.63a.33.33,0,0,0,.11.26.36.36,0,0,0,.26.11h1.25a.4.4,0,0,0,.27-.11.36.36,0,0,0,.11-.26V10.77a.75.75,0,0,0-.22-.53.73.73,0,0,0-.53-.22H19.37a.36.36,0,0,0-.26.11.33.33,0,0,0-.11.27ZM22.37,19a.36.36,0,0,0-.26.11.33.33,0,0,0-.11.27V22H19.37a.36.36,0,0,0-.26.11.33.33,0,0,0-.11.27v1.25a.33.33,0,0,0,.11.26.36.36,0,0,0,.26.11h3.88a.75.75,0,0,0,.75-.75V19.4a.37.37,0,0,0-.11-.27.4.4,0,0,0-.27-.11Z" transform="translate(-10 -10.02)"/></svg>
diff a/application/org.openjdk.jmc.ui/icons/fa-select.svg b/application/org.openjdk.jmc.ui/icons/fa-select.svg
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/icons/fa-select.svg
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Generator: Adobe Illustrator 23.0.4, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
+<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
+	 viewBox="0 0 10.1 16.2" style="enable-background:new 0 0 10.1 16.2;" xml:space="preserve">
+<style type="text/css">
+	.st0{enable-background:new    ;}
+</style>
+<title>Select</title>
+<g class="st0">
+	<path d="M6.1,10.5l1.8,4.2C8,14.8,8,15,7.9,15.1s-0.2,0.2-0.3,0.3L6,16.1c-0.1,0.1-0.3,0.1-0.4,0s-0.2-0.2-0.3-0.3l-1.7-4l-2.7,2.8
+		c-0.2,0.2-0.4,0.2-0.6,0.1S0,14.4,0,14.2V0.7c0-0.3,0.1-0.4,0.3-0.5s0.4-0.1,0.6,0.1l8.9,9.2C10,9.7,10,9.9,9.9,10.1
+		s-0.3,0.4-0.5,0.4H6.1z"/>
+</g>
+</svg>
diff a/application/org.openjdk.jmc.ui/icons/fa-selection-16.png b/application/org.openjdk.jmc.ui/icons/fa-selection-16.png
Binary files /dev/null and application/org.openjdk.jmc.ui/icons/fa-selection-16.png differ
diff a/application/org.openjdk.jmc.ui/icons/fa-zoom-in-16.png b/application/org.openjdk.jmc.ui/icons/fa-zoom-in-16.png
Binary files /dev/null and application/org.openjdk.jmc.ui/icons/fa-zoom-in-16.png differ
diff a/application/org.openjdk.jmc.ui/icons/fa-zoom-in.svg b/application/org.openjdk.jmc.ui/icons/fa-zoom-in.svg
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/icons/fa-zoom-in.svg
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Generator: Adobe Illustrator 23.0.4, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
+<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
+	 viewBox="0 0 16.7 16.2" style="enable-background:new 0 0 16.7 16.2;" xml:space="preserve">
+<style type="text/css">
+	.st0{enable-background:new    ;}
+</style>
+<title>Zoom-in</title>
+<g class="st0">
+	<path d="M14.9,15.9c-0.1,0.1-0.3,0.2-0.5,0.2S14,16,13.9,15.9l-3.1-3.1c-0.1-0.1-0.2-0.3-0.2-0.5v-0.5c-1.2,0.9-2.5,1.4-4,1.4
+		c-1.2,0-2.3-0.3-3.3-0.9s-1.8-1.4-2.4-2.4S0,7.8,0,6.6s0.3-2.3,0.9-3.3S2.2,1.5,3.2,1s2.1-0.9,3.3-0.9S8.8,0.4,9.8,1
+		s1.8,1.4,2.4,2.4s0.8,2,0.8,3.2c0,1.5-0.5,2.8-1.4,4h0.5c0.2,0,0.4,0.1,0.5,0.2l3.1,3.1c0.1,0.1,0.2,0.3,0.2,0.5s-0.1,0.4-0.2,0.5
+		L14.9,15.9z M10.2,4.5C9.8,3.8,9.3,3.3,8.6,2.9S7.3,2.3,6.5,2.3S5,2.5,4.4,2.9S3.2,3.8,2.8,4.5S2.2,5.8,2.2,6.6s0.2,1.5,0.6,2.1
+		s0.9,1.2,1.5,1.5s1.4,0.6,2.1,0.6s1.5-0.2,2.1-0.6S9.7,9.3,10,8.7s0.6-1.4,0.6-2.1S10.6,5.1,10.2,4.5z M9.5,7.1
+		c0,0.1,0,0.2-0.1,0.3C9.3,7.5,9.2,7.5,9.1,7.5H7.4v1.8c0,0.1,0,0.2-0.1,0.3s-0.2,0-0.3,0H6c-0.1,0-0.2,0-0.3-0.1S5.6,9.3,5.6,9.2
+		V7.5H3.9c-0.1,0-0.2,0-0.3-0.1S3.5,7.2,3.5,7.1v-1c0-0.1,0-0.2,0.1-0.3s0.2-0.1,0.3-0.1h1.8V4c0-0.1,0-0.2,0.1-0.3S5.9,3.6,6,3.6h1
+		c0.1,0,0.2,0,0.3,0.1S7.4,3.9,7.4,4v1.8h1.8c0.1,0,0.2,0,0.3,0.1s0.1,0.2,0.1,0.3v0.9H9.5z"/>
+</g>
+</svg>
diff a/application/org.openjdk.jmc.ui/icons/fa-zoom-out-16.png b/application/org.openjdk.jmc.ui/icons/fa-zoom-out-16.png
Binary files /dev/null and application/org.openjdk.jmc.ui/icons/fa-zoom-out-16.png differ
diff a/application/org.openjdk.jmc.ui/icons/fa-zoom-out.svg b/application/org.openjdk.jmc.ui/icons/fa-zoom-out.svg
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/icons/fa-zoom-out.svg
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Generator: Adobe Illustrator 23.0.4, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
+<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
+	 viewBox="0 0 16.3 16.1" style="enable-background:new 0 0 16.3 16.1;" xml:space="preserve">
+<style type="text/css">
+	.st0{enable-background:new    ;}
+</style>
+<title>Zoom-out</title>
+<g class="st0">
+	<path d="M14.9,15.9c-0.1,0.1-0.3,0.2-0.5,0.2S14,16,13.9,15.9l-3.1-3.1c-0.1-0.1-0.2-0.3-0.2-0.5v-0.5c-1.2,0.9-2.5,1.4-4,1.4
+		c-1.2,0-2.3-0.3-3.3-0.9s-1.8-1.4-2.4-2.4S0,7.8,0,6.6s0.3-2.3,0.9-3.3S2.2,1.5,3.2,1s2.1-0.9,3.3-0.9S8.8,0.4,9.8,1
+		s1.8,1.4,2.4,2.4s0.8,2,0.8,3.2c0,1.5-0.5,2.8-1.4,4h0.5c0.2,0,0.4,0.1,0.5,0.2l3.1,3.1c0.1,0.1,0.2,0.3,0.2,0.5s-0.1,0.4-0.2,0.5
+		L14.9,15.9z M10.2,4.5C9.8,3.8,9.3,3.3,8.6,2.9S7.3,2.3,6.5,2.3S5,2.5,4.4,2.9S3.2,3.8,2.8,4.5S2.2,5.8,2.2,6.6s0.2,1.5,0.6,2.1
+		s0.9,1.2,1.5,1.5s1.4,0.6,2.1,0.6s1.5-0.2,2.1-0.6S9.7,9.3,10,8.7s0.6-1.4,0.6-2.1S10.6,5.1,10.2,4.5z M9.5,7.1
+		c0,0.1,0,0.2-0.1,0.3C9.3,7.5,9.2,7.5,9.1,7.5H3.9c-0.1,0-0.2,0-0.3-0.1S3.5,7.2,3.5,7.1v-1c0-0.1,0-0.2,0.1-0.3s0.2-0.1,0.3-0.1
+		h5.2c0.1,0,0.2,0,0.3,0.1S9.5,6,9.5,6.1V7.1z"/>
+</g>
+</svg>
diff a/application/org.openjdk.jmc.ui/icons/fa-zoom-pan-16.png b/application/org.openjdk.jmc.ui/icons/fa-zoom-pan-16.png
Binary files /dev/null and application/org.openjdk.jmc.ui/icons/fa-zoom-pan-16.png differ
diff a/application/org.openjdk.jmc.ui/icons/fa-zoom-pan.svg b/application/org.openjdk.jmc.ui/icons/fa-zoom-pan.svg
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/icons/fa-zoom-pan.svg
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Generator: Adobe Illustrator 23.0.4, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
+<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
+	 viewBox="0 0 16.4 16.2" style="enable-background:new 0 0 16.4 16.2;" xml:space="preserve">
+<style type="text/css">
+	.st0{enable-background:new    ;}
+</style>
+<title>Zoom-pan</title>
+<g class="st0">
+	<path d="M8.5,15.9C8.4,16,8.2,16.1,8,16.1S7.6,16,7.5,15.9L5,13.4c-0.1-0.2-0.2-0.3-0.2-0.5s0.1-0.4,0.2-0.6s0.3-0.2,0.5-0.2h1.6V9
+		H4v1.5c0,0.2-0.1,0.4-0.2,0.5s-0.3,0.2-0.5,0.2S2.9,11.1,2.8,11L0.2,8.6C0.1,8.5,0,8.3,0,8.1s0.1-0.4,0.2-0.6L2.7,5
+		C2.9,4.9,3,4.8,3.2,4.8S3.6,4.9,3.7,5S4,5.4,4,5.6v1.6h3.2V4H5.5C5.3,4,5.1,4,5,3.8S4.8,3.5,4.8,3.3s0-0.4,0.2-0.5l2.5-2.5
+		C7.6,0.2,7.8,0.1,8,0.1s0.4,0.1,0.5,0.2L11,2.8c0.1,0.2,0.2,0.3,0.2,0.5S11.1,3.7,11,3.8S10.7,4,10.5,4H8.9v3.2H12V5.6
+		c0-0.2,0.1-0.4,0.2-0.5s0.3-0.2,0.5-0.2s0.4,0.1,0.5,0.2l2.6,2.4C15.9,7.7,16,7.9,16,8.1s-0.1,0.4-0.2,0.5l-2.5,2.5
+		c-0.2,0.2-0.3,0.2-0.5,0.2s-0.4-0.1-0.5-0.2S12,10.8,12,10.5V9H8.9v3.2h1.6c0.2,0,0.4,0.1,0.5,0.2s0.2,0.3,0.2,0.5
+		s-0.1,0.4-0.2,0.5L8.5,15.9z"/>
+</g>
+</svg>
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/UIPlugin.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/UIPlugin.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/UIPlugin.java
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/UIPlugin.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -124,10 +124,19 @@
 	public static final String ICON_LOGICAL_PACKAGE = "logical_package_obj.gif"; //$NON-NLS-1$
 
 	// module
 	public static final String ICON_MODULE = "jigsaw-32.png"; //$NON-NLS-1$
 
+	// font awesome
+	public static final String ICON_FA_SCALE_TO_FIT = "fa-scale-to-fit-16.png";
+	public static final String ICON_FA_SELECTION = "fa-selection-16.png";
+	public static final String ICON_FA_ZOOM_IN = "fa-zoom-in-16.png";
+	public static final String ICON_FA_ZOOM_OUT = "fa-zoom-out-16.png";
+	public static final String ICON_FA_ZOOM_PAN = "fa-zoom-pan-16.png";
+	public static final String ICON_FA_PLUS = "fa-plus-16.png";
+	public static final String ICON_FA_MINUS = "fa-minus-16.png";
+
 	// thread
 	public final static String ICON_THREAD_RUNNING = "thread_obj.gif"; //$NON-NLS-1$
 	public final static String ICON_THREAD_SUSPENDED = "threads_obj.gif"; //$NON-NLS-1$
 	public final static String ICON_THREAD_TERMINATED = "threadt_obj.gif"; //$NON-NLS-1$
 	public static final String ICON_THREAD_DEADLOCKED = "live-thread-deadlocked-16.PNG"; //$NON-NLS-1$
@@ -270,10 +279,19 @@
 		registerImage(registry, ICON_PROPERTY_OBJECT, ICON_PROPERTY_OBJECT);
 
 		registerImage(registry, ICON_EXPAND_ALL, ICON_EXPAND_ALL);
 		registerImage(registry, ICON_COLLAPSE_ALL, ICON_COLLAPSE_ALL);
 
+		// font awesome
+		registerImage(registry, ICON_FA_SCALE_TO_FIT, ICON_FA_SCALE_TO_FIT);
+		registerImage(registry, ICON_FA_SELECTION, ICON_FA_SELECTION);
+		registerImage(registry, ICON_FA_ZOOM_IN, ICON_FA_ZOOM_IN);
+		registerImage(registry, ICON_FA_ZOOM_OUT, ICON_FA_ZOOM_OUT);
+		registerImage(registry, ICON_FA_ZOOM_PAN, ICON_FA_ZOOM_PAN);
+		registerImage(registry, ICON_FA_PLUS, ICON_FA_PLUS);
+		registerImage(registry, ICON_FA_MINUS, ICON_FA_MINUS);
+
 		// Threads
 		registerImage(registry, ICON_THREAD_RUNNING, ICON_THREAD_RUNNING);
 		registerImage(registry, ICON_THREAD_SUSPENDED, ICON_THREAD_SUSPENDED);
 		registerImage(registry, ICON_THREAD_TERMINATED, ICON_THREAD_TERMINATED);
 		registerImage(registry, ICON_THREAD_DEADLOCKED, ICON_THREAD_DEADLOCKED);
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/AWTChartToolkit.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/AWTChartToolkit.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/AWTChartToolkit.java
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/AWTChartToolkit.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -291,10 +291,16 @@
 	}
 
 	public static void drawAxis(
 		Graphics2D ctx, SubdividedQuantityRange range, int axisPos, boolean labelAhead, int labelLimit,
 		boolean vertical) {
+		drawAxis(ctx, range, axisPos, labelAhead, labelLimit, vertical, 0);
+	}
+
+	public static void drawAxis(
+		Graphics2D ctx, SubdividedQuantityRange range, int axisPos, boolean labelAhead, int labelLimit,
+		boolean vertical, int xOffset) {
 		int axisSize = range.getPixelExtent();
 		FontMetrics fm = ctx.getFontMetrics();
 		int textAscent = fm.getAscent();
 		int textYadjust = textAscent / 2;
 		int labelYPos = labelAhead ? axisPos - TICK_SIZE : axisPos + TICK_SIZE + textAscent;
@@ -303,11 +309,11 @@
 		if (vertical) {
 			ctx.drawLine(axisPos, Y_AXIS_TOP_SPACE, axisPos, axisSize - 1);
 			drawUpArrow(ctx, axisPos, Y_AXIS_TOP_SPACE, Math.min(ARROW_SIZE, axisSize - 2));
 			labelSpacing = fm.getHeight() - textAscent;
 		} else {
-			ctx.drawLine(0, axisPos, axisSize - 1, axisPos);
+			ctx.drawLine(0 + xOffset, axisPos, axisSize + xOffset, axisPos);
 			labelSpacing = fm.charWidth(' ') * 2;
 		}
 
 		IRange<IQuantity> firstBucket = QuantityRange.createWithEnd(range.getSubdivider(0), range.getSubdivider(1));
 		IQuantity lastShownTick = null;
@@ -352,18 +358,18 @@
 					if (changeFormatter != null) {
 						label = changeFormatter.formatAdjacent(lastShownTick, range.getSubdivider(i));
 					} else {
 						label = formatter.format(currentTick);
 					}
-					ctx.drawLine(tickPos, axisPos - TICK_LINE, tickPos, axisPos + TICK_LINE);
+					ctx.drawLine(tickPos + xOffset, axisPos - TICK_LINE, tickPos + xOffset, axisPos + TICK_LINE);
 					int textXadjust = fm.stringWidth(label) / 2;
 					// FIXME: Decide if truncated labels should be shown
 //					if ((tickPos + textXadjust) >= axisSize) {
 					if (tickPos >= axisSize) {
 						break;
 					} else if ((tickPos - textXadjust) >= labelLimit) {
-						ctx.drawString(label, tickPos - textXadjust, labelYPos);
+						ctx.drawString(label, tickPos - textXadjust + xOffset, labelYPos);
 						labelLimit = tickPos + textXadjust + labelSpacing;
 						lastShownTick = currentTick;
 					}
 				}
 			}
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/XYChart.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/XYChart.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/XYChart.java
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/XYChart.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -39,52 +39,86 @@
 import java.awt.geom.Point2D;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
+import java.util.Stack;
 import java.util.function.Consumer;
 
 import org.openjdk.jmc.common.IDisplayable;
 import org.openjdk.jmc.common.unit.IQuantity;
 import org.openjdk.jmc.common.unit.IRange;
 import org.openjdk.jmc.common.unit.QuantitiesToolkit;
 import org.openjdk.jmc.common.unit.QuantityRange;
+import org.openjdk.jmc.common.unit.UnitLookup;
 import org.openjdk.jmc.ui.charts.IChartInfoVisitor.ITick;
+import org.openjdk.jmc.ui.misc.ChartButtonGroup;
+import org.openjdk.jmc.ui.misc.ChartControlBar;
+import org.openjdk.jmc.ui.misc.TimelineCanvas;
+import org.openjdk.jmc.ui.misc.PatternFly.Palette;
 
 public class XYChart {
 	private static final String ELLIPSIS = "..."; //$NON-NLS-1$
 	private static final Color SELECTION_COLOR = new Color(255, 255, 255, 220);
 	private static final Color RANGE_INDICATION_COLOR = new Color(255, 60, 20);
-	private static final int Y_OFFSET = 35;
-	private static final int RANGE_INDICATOR_HEIGHT = 4;
+	private static final int BASE_ZOOM_LEVEL = 100;
+	private static final int RANGE_INDICATOR_HEIGHT = 7;
 	private final IQuantity start;
 	private final IQuantity end;
+	private IQuantity rangeDuration;
 	private IXDataRenderer rendererRoot;
 	private IRenderedRow rendererResult;
 	private final int xOffset;
+	private int yOffset = 35;
 	private final int bucketWidth;
 	// FIXME: Use bucketWidth * ticksPerBucket instead of hardcoded value?
 //	private final int ticksPerBucket = 4;
 
 	private IQuantity currentStart;
 	private IQuantity currentEnd;
 
 	private final Set<Object> selectedRows = new HashSet<>();
+	private int axisWidth;
+	private int rowColorCounter;
 	private IQuantity selectionStart;
 	private IQuantity selectionEnd;
 	private SubdividedQuantityRange xBucketRange;
 	private SubdividedQuantityRange xTickRange;
-	private int axisWidth;
+
+	// JFR Threads Page
+	private static final double ZOOM_PAN_FACTOR = 0.05;
+	private static final int ZOOM_PAN_MODIFIER = 2;
+	private double zoomPanPower = ZOOM_PAN_FACTOR / ZOOM_PAN_MODIFIER;
+	private double currentZoom;
+	private int zoomSteps;
+	private ChartButtonGroup buttonGroup;
+	private ChartControlBar controlBar;
+	private Stack<Integer> modifiedSteps;
+	private TimelineCanvas timelineCanvas;
+	private int longestCharWidth = 0;
 
 	public XYChart(IRange<IQuantity> range, IXDataRenderer rendererRoot) {
 		this(range.getStart(), range.getEnd(), rendererRoot);
 	}
 
 	public XYChart(IRange<IQuantity> range, IXDataRenderer rendererRoot, int xOffset) {
 		this(range.getStart(), range.getEnd(), rendererRoot, xOffset);
 	}
 
+	// JFR Threads Page
+	public XYChart(IRange<IQuantity> range, IXDataRenderer rendererRoot, int xOffset, Integer yOffset,
+			TimelineCanvas timelineCanvas, ChartControlBar controlBar, ChartButtonGroup buttonGroup) {
+		this(range.getStart(), range.getEnd(), rendererRoot, xOffset);
+		this.yOffset = yOffset;
+		this.timelineCanvas = timelineCanvas;
+		this.controlBar = controlBar;
+		this.buttonGroup = buttonGroup;
+		this.rangeDuration = range.getExtent();
+		this.currentZoom = BASE_ZOOM_LEVEL;
+		this.isZoomCalculated = false;
+	}
+
 	public XYChart(IRange<IQuantity> range, IXDataRenderer rendererRoot, int xOffset, int bucketWidth) {
 		this(range.getStart(), range.getEnd(), rendererRoot, xOffset, bucketWidth);
 	}
 
 	public XYChart(IQuantity start, IQuantity end, IXDataRenderer rendererRoot) {
@@ -97,21 +131,22 @@
 
 	public XYChart(IQuantity start, IQuantity end, IXDataRenderer rendererRoot, int xOffset, int bucketWidth) {
 		this.rendererRoot = rendererRoot;
 		// Start value must always be strictly less than end
 		assert (start.compareTo(end) < 0);
-		currentStart = start;
+		this.currentStart = start;
 		this.start = start;
-		currentEnd = end;
+		this.currentEnd = end;
 		this.end = end;
 		this.xOffset = xOffset;
 		this.bucketWidth = bucketWidth;
 	}
 
 	public void setRendererRoot(IXDataRenderer rendererRoot) {
 		clearSelection();
 		this.rendererRoot = rendererRoot;
+		longestCharWidth = 0;
 	}
 
 	public IXDataRenderer getRendererRoot() {
 		return rendererRoot;
 	}
@@ -131,96 +166,195 @@
 	public IRange<IQuantity> getSelectionRange() {
 		return (selectionStart != null) && (selectionEnd != null)
 				? QuantityRange.createWithEnd(selectionStart, selectionEnd) : null;
 	}
 
-	public void render(Graphics2D context, int width, int height) {
-		if (width > xOffset && height > Y_OFFSET) {
+	public void renderChart(Graphics2D context, int width, int height) {
+		if (width > xOffset && height > yOffset) {
 			axisWidth = width - xOffset;
 			// FIXME: xBucketRange and xTickRange should be more related, so that each tick is typically an integer number of buckets (or possibly 2.5 buckets).
 			xBucketRange = new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, bucketWidth);
 			// FIXME: Use bucketWidth * ticksPerBucket instead of hardcoded value?
 			xTickRange = new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, 100);
 			AffineTransform oldTransform = context.getTransform();
 			context.translate(xOffset, 0);
-			doRender(context, height - Y_OFFSET);
+			doRenderChart(context, height - yOffset);
 			context.setTransform(oldTransform);
 		}
 	}
 
+	public void renderTextCanvasText(Graphics2D context, int width, int height) {
+		AffineTransform oldTransform = context.getTransform();
+		axisWidth = width - xOffset;
+		doRenderTextCanvasText(context, height);
+		context.setTransform(oldTransform);
+	}
+
+	public void renderText(Graphics2D context, int width, int height) {
+		if (width > xOffset && height > yOffset) {
+			axisWidth = xOffset;
+			AffineTransform oldTransform = context.getTransform();
+			doRenderText(context);
+			context.setTransform(oldTransform);
+			axisWidth = width - xOffset;
+		}
+	}
+
 	private void renderRangeIndication(Graphics2D context, int rangeIndicatorY) {
 		// FIXME: Extract the needed functionality from SubdividedQuantityRange
 		SubdividedQuantityRange fullRangeAxis = new SubdividedQuantityRange(start, end, axisWidth, 25);
 		int x1 = (int) fullRangeAxis.getPixel(currentStart);
 		int x2 = (int) Math.ceil(fullRangeAxis.getPixel(currentEnd));
-		if (x1 > 0 || x2 < axisWidth) {
+
+		if (timelineCanvas != null) {
+			timelineCanvas.renderRangeIndicator(x1, x2);
+			updateZoomPanIndicator();
+		} else {
 			context.setPaint(RANGE_INDICATION_COLOR);
 			context.fillRect(x1, rangeIndicatorY, x2 - x1, RANGE_INDICATOR_HEIGHT);
 			context.setPaint(Color.DARK_GRAY);
 			context.drawRect(0, rangeIndicatorY, axisWidth - 1, RANGE_INDICATOR_HEIGHT);
 		}
 	}
 
-	private void doRender(Graphics2D context, int axisHeight) {
+	public void updateZoomPanIndicator() {
+		if (buttonGroup != null) {
+			buttonGroup.updateZoomPanIndicator();
+		}
+	}
+
+	private IRenderedRow getRendererResult(Graphics2D context, int axisHeight) {
+		if (xBucketRange == null) {
+			xBucketRange = getXBucketRange();
+		}
+		return rendererRoot.render(context, xBucketRange, axisHeight);
+	}
+
+	private SubdividedQuantityRange getXBucketRange() {
+		return new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, bucketWidth);
+	}
+
+	private void doRenderChart(Graphics2D context, int axisHeight) {
+		rowColorCounter = 0;
 		context.setPaint(Color.LIGHT_GRAY);
 		AWTChartToolkit.drawGrid(context, xTickRange, axisHeight, false);
 		// Attempt to make graphs so low they cover the axis show by drawing the full axis first ...
 		context.setPaint(Color.BLACK);
-		AWTChartToolkit.drawAxis(context, xTickRange, axisHeight - 1, false, 1 - xOffset, false);
+		if (timelineCanvas != null) {
+			timelineCanvas.setXTickRange(xTickRange);
+		} else {
+			AWTChartToolkit.drawAxis(context, xTickRange, axisHeight - 1, false, 1 - xOffset, false);
+		}
 		// ... then the graph ...
-		rendererResult = rendererRoot.render(context, xBucketRange, axisHeight);
+		rendererResult = getRendererResult(context, axisHeight);
 		AffineTransform oldTransform = context.getTransform();
-		renderText(context, rendererResult);
+
 		context.setTransform(oldTransform);
 		if (!selectedRows.isEmpty()) {
-			renderSelection(context, rendererResult);
+			renderSelectionChart(context, rendererResult);
 			context.setTransform(oldTransform);
 		}
 		// .. and finally a semitransparent axis line again.
 		context.setPaint(new Color(0, 0, 0, 64));
 		context.drawLine(0, axisHeight - 1, axisWidth - 1, axisHeight - 1);
 		renderRangeIndication(context, axisHeight + 25);
 	}
 
-	private void renderSelection(Graphics2D context, IRenderedRow row) {
+	private void doRenderText(Graphics2D context) {
+		AffineTransform oldTransform = context.getTransform();
+		rowColorCounter = -1;
+		renderText(context, rendererResult);
+		context.setTransform(oldTransform);
+	}
+
+	private void doRenderTextCanvasText(Graphics2D context, int height) {
+		if (rendererResult == null) {
+			rendererResult = getRendererResult(context, height - yOffset);
+		}
+		AffineTransform oldTransform = context.getTransform();
+		rowColorCounter = 0;
+		renderText(context, rendererResult);
+		context.setTransform(oldTransform);
+		if (!selectedRows.isEmpty()) {
+			renderSelectionText(context, rendererResult);
+			context.setTransform(oldTransform);
+		}
+	}
+
+	private void renderSelectionText(Graphics2D context, IRenderedRow row) {
+		if (selectedRows.contains(row.getPayload())) {
+			if (row.getHeight() != rendererResult.getHeight()) {
+				Color highlight = new Color(0, 206, 209, 20);
+				context.setColor(highlight);
+				context.fillRect(0, 0, axisWidth, row.getHeight());
+			} else {
+				selectedRows.clear();
+			}
+		} else {
+			List<IRenderedRow> subdivision = row.getNestedRows();
+			if (subdivision.isEmpty()) {
+				dimRect(context, 0, axisWidth, row.getHeight());
+			} else {
+				for (IRenderedRow nestedRow : row.getNestedRows()) {
+					renderSelectionText(context, nestedRow);
+				}
+				return;
+			}
+		}
+		context.translate(0, row.getHeight());
+	}
+
+	private void renderSelectionChart(Graphics2D context, IRenderedRow row) {
 		if (selectedRows.contains(row.getPayload())) {
 			renderSelection(context, xBucketRange, row.getHeight());
 		} else {
 			List<IRenderedRow> subdivision = row.getNestedRows();
 			if (subdivision.isEmpty()) {
 				dimRect(context, 0, axisWidth, row.getHeight());
 			} else {
 				for (IRenderedRow nestedRow : row.getNestedRows()) {
-					renderSelection(context, nestedRow);
+					renderSelectionChart(context, nestedRow);
 				}
 				return;
 			}
 		}
 		context.translate(0, row.getHeight());
 	}
 
+	// Paint the background of every-other row in a slightly different shade
+	// to better differentiate the thread lanes from one another
+	private void paintRowBackground(Graphics2D context, int height) {
+		if (rowColorCounter >= 0) {
+			if (rowColorCounter % 2 == 0) {
+				context.setColor(Palette.PF_BLACK_100.getAWTColor());
+			} else {
+				context.setColor(Palette.PF_BLACK_200.getAWTColor());
+			}
+			context.fillRect(0, 0, axisWidth, height);
+			rowColorCounter++;
+		}
+	}
+
 	private void renderText(Graphics2D context, IRenderedRow row) {
 		String text = row.getName();
 		int height = row.getHeight();
 		if (height >= context.getFontMetrics().getHeight()) {
 			if (text != null) {
+				paintRowBackground(context, row.getHeight());
 				context.setColor(Color.BLACK);
-				int y;
-				if (height > 40) {
-					context.drawLine(-xOffset, height - 1, -15, height - 1);
-					y = height - context.getFontMetrics().getHeight() / 2;
-				} else {
-					// draw the string in the middle of the row
-					y = ((height - context.getFontMetrics().getHeight()) / 2) + context.getFontMetrics().getAscent();
-				}
+				context.drawLine(0, height - 1, axisWidth - 15, height - 1);
+				int y = ((height - context.getFontMetrics().getHeight()) / 2) + context.getFontMetrics().getAscent();
 				int charsWidth = context.getFontMetrics().charsWidth(text.toCharArray(), 0, text.length());
-				if (charsWidth > xOffset) {
+				if (charsWidth > longestCharWidth) {
+					longestCharWidth = charsWidth;
+				}
+				if (xOffset > 0 && charsWidth > xOffset) {
 					float fitRatio = ((float) xOffset) / (charsWidth
 							+ context.getFontMetrics().charsWidth(ELLIPSIS.toCharArray(), 0, ELLIPSIS.length()));
 					text = text.substring(0, ((int) (text.length() * fitRatio)) - 1) + ELLIPSIS;
 				}
-				context.drawString(text, -xOffset + 2, y);
+				context.drawString(text, 2, y);
 			} else {
 				List<IRenderedRow> subdivision = row.getNestedRows();
 				if (!subdivision.isEmpty()) {
 					for (IRenderedRow nestedRow : row.getNestedRows()) {
 						renderText(context, nestedRow);
@@ -230,17 +364,29 @@
 			}
 		}
 		context.translate(0, height);
 	}
 
+	/**
+	 * Get the longest character width of a thread name to be rendered
+	 * 
+	 * @return the character width of longest thread name
+	 */
+	public int getLongestCharWidth() {
+		return longestCharWidth;
+	}
+
 	/**
 	 * Pan the view.
 	 *
 	 * @param rightPercent
 	 * @return true if the bounds changed. That is, if a redraw is required.
 	 */
 	public boolean pan(int rightPercent) {
+		if (rangeDuration != null) {
+			return panRange(Integer.signum(rightPercent));
+		}
 		if (xBucketRange != null) {
 			IQuantity oldStart = currentStart;
 			IQuantity oldEnd = currentEnd;
 			if (rightPercent > 0) {
 				currentEnd = QuantitiesToolkit
@@ -257,17 +403,56 @@
 		}
 		// Return true since a redraw forces creation of xBucketRange.
 		return true;
 	}
 
+	/**
+	 * Pan the view at a rate relative the current zoom level.
+	 * 
+	 * @param panDirection
+	 *            -1 to pan left, 1 to pan right
+	 * @return true if the chart needs to be redrawn
+	 */
+	public boolean panRange(int panDirection) {
+		if (zoomSteps == 0 || panDirection == 0 || (currentStart.compareTo(start) == 0 && panDirection == -1)
+				|| (currentEnd.compareTo(end) == 0 && panDirection == 1)) {
+			return false;
+		}
+
+		IQuantity panDiff = rangeDuration.multiply(panDirection * zoomPanPower);
+		IQuantity newStart = currentStart.in(UnitLookup.EPOCH_NS).add(panDiff);
+		IQuantity newEnd = currentEnd.in(UnitLookup.EPOCH_NS).add(panDiff);
+
+		// if panning would flow over the recording range start or end time,
+		// calculate the difference and add it so the other side.
+		if (newStart.compareTo(start) < 0) {
+			IQuantity diff = start.subtract(newStart);
+			newStart = start;
+			newEnd = newEnd.add(diff);
+		} else if (newEnd.compareTo(end) > 0) {
+			IQuantity diff = newEnd.subtract(end);
+			newStart = newStart.add(diff);
+			newEnd = end;
+		}
+		currentStart = newStart;
+		currentEnd = newEnd;
+		controlBar.setStartTime(currentStart);
+		controlBar.setEndTime(currentEnd);
+		isZoomCalculated = true;
+		return true;
+	}
+
 	/**
 	 * Zoom the view.
 	 *
 	 * @param zoomInSteps
 	 * @return true if the bounds changed. That is, if a redraw is required.
 	 */
 	public boolean zoom(int zoomInSteps) {
+		if (rangeDuration != null) {
+			return zoomRange(zoomInSteps);
+		}
 		return zoomXAxis(axisWidth / 2, zoomInSteps);
 	}
 
 	/**
 	 * Zoom the view.
@@ -278,10 +463,11 @@
 	 */
 	public boolean zoom(int x, int zoomInSteps) {
 		return zoomXAxis(x - xOffset, zoomInSteps);
 	}
 
+	// Default zoom mechanics
 	private boolean zoomXAxis(int x, int zoomInSteps) {
 		if (xBucketRange == null) {
 			// Return true since a redraw forces creation of xBucketRange.
 			return true;
 		}
@@ -297,11 +483,188 @@
 			return (currentStart.compareTo(oldStart) != 0) || (currentEnd.compareTo(oldEnd) != 0);
 		}
 		return false;
 	}
 
+	/**
+	 * Zoom to a specific step count
+	 * 
+	 * @param zoomToStep
+	 *            the desired end zoom step amount
+	 * @return true if a redraw is required as a result of a successful zoom
+	 */
+	public boolean zoomToStep(int zoomToStep) {
+		if (zoomToStep == 0) {
+			resetTimeline();
+			return true;
+		} else {
+			return zoomRange(zoomToStep - zoomSteps);
+		}
+	}
+
+	/**
+	 * Zoom based on a percentage of the recording range
+	 * 
+	 * @param zoomInSteps
+	 *            the amount of desired steps to take
+	 * @return true if a redraw is required as a result of a successful zoom
+	 */
+	private boolean zoomRange(int steps) {
+		if (steps == 0) {
+			return false;
+		} else if (steps > 0) {
+			zoomIn(steps);
+		} else {
+			zoomOut(steps);
+		}
+		return true;
+	}
+
+	/**
+	 * Zoom into the chart at a rate of 5% of the overall recording range at each step. If the chart
+	 * is zoomed in far enough such that one more step at 5% is not possible, the zoom power is
+	 * halved and the zoom will proceed. <br>
+	 * Every time the zoom power is halved, the instigating step value is pushed onto the
+	 * modifiedSteps stack. This stack is consulted on zoom out events in order to ensure the chart
+	 * zooms out the same way it was zoomed in.
+	 */
+	private void zoomIn(int steps) {
+		do {
+			IQuantity zoomDiff = rangeDuration.multiply(zoomPanPower);
+			IQuantity newStart = currentStart.in(UnitLookup.EPOCH_NS).add(zoomDiff);
+			IQuantity newEnd = currentEnd.in(UnitLookup.EPOCH_NS).subtract(zoomDiff);
+			if (newStart.compareTo(newEnd) >= 0) { // adjust the zoom factor
+				if (modifiedSteps == null) {
+					modifiedSteps = new Stack<Integer>();
+				}
+				modifiedSteps.push(zoomSteps);
+				zoomPanPower = zoomPanPower / ZOOM_PAN_MODIFIER;
+				zoomDiff = rangeDuration.multiply(zoomPanPower);
+				newStart = currentStart.in(UnitLookup.EPOCH_NS).add(zoomDiff);
+				newEnd = currentEnd.in(UnitLookup.EPOCH_NS).subtract(zoomDiff);
+			}
+			currentZoom = currentZoom + (zoomPanPower * ZOOM_PAN_MODIFIER * 100);
+			isZoomCalculated = true;
+			zoomSteps++;
+			setVisibleRange(newStart, newEnd);
+			steps--;
+		} while (steps > 0);
+	}
+
+	/**
+	 * Zoom out of the chart at a rate equal to the how the chart was zoomed in.
+	 */
+	private void zoomOut(int steps) {
+		do {
+			if (modifiedSteps != null && modifiedSteps.size() > 0 && modifiedSteps.peek() == zoomSteps) {
+				modifiedSteps.pop();
+				zoomPanPower = zoomPanPower * ZOOM_PAN_MODIFIER;
+			}
+			IQuantity zoomDiff = rangeDuration.multiply(zoomPanPower);
+			IQuantity newStart = currentStart.in(UnitLookup.EPOCH_NS).subtract(zoomDiff);
+			IQuantity newEnd = currentEnd.in(UnitLookup.EPOCH_NS).add(zoomDiff);
+
+			// if zooming out would flow over the recording range start or end time,
+			// calculate the difference and add it to the other side.
+			if (newStart.compareTo(start) < 0) {
+				IQuantity diff = start.subtract(newStart);
+				newStart = start;
+				newEnd = newEnd.add(diff);
+			} else if (newEnd.compareTo(end) > 0) {
+				IQuantity diff = newEnd.subtract(end);
+				newStart = newStart.subtract(diff);
+				newEnd = end;
+			}
+			currentZoom = currentZoom - (zoomPanPower * ZOOM_PAN_MODIFIER * 100);
+			if (currentZoom < BASE_ZOOM_LEVEL) {
+				currentZoom = BASE_ZOOM_LEVEL;
+			}
+			isZoomCalculated = true;
+			zoomSteps--;
+			setVisibleRange(newStart, newEnd);
+			steps++;
+		} while (steps < 0);
+	}
+
+	// need to check from ChartAndPopupTableUI if not using the OG start/end position,
+	// will have to calculate the new zoom level
+	public void resetZoomFactor() {
+		zoomSteps = 0;
+		zoomPanPower = ZOOM_PAN_FACTOR / ZOOM_PAN_MODIFIER;
+		currentZoom = BASE_ZOOM_LEVEL;
+		modifiedSteps = new Stack<Integer>();
+	}
+
+	/**
+	 * Reset the visible range to be the recording range, and reset the zoom-related objects
+	 */
+	public void resetTimeline() {
+		resetZoomFactor();
+		setVisibleRange(start, end);
+	}
+
+	private void selectionZoom(IQuantity newStart, IQuantity newEnd) {
+		double percentage = calculateZoom(newStart, newEnd);
+		zoomSteps = calculateZoomSteps(percentage);
+		currentZoom = BASE_ZOOM_LEVEL + (percentage * 100);
+	}
+
+	/**
+	 * When a drag-select zoom occurs, use the new range value to determine how many steps have been
+	 * taken, and adjust zoomSteps and zoomPower accordingly
+	 */
+	private double calculateZoom(IQuantity newStart, IQuantity newEnd) {
+		// calculate the new visible range, and it's percentage of the total range
+		IQuantity newRange = newEnd.in(UnitLookup.EPOCH_NS).subtract(newStart.in(UnitLookup.EPOCH_NS));
+		return 1 - (newRange.longValue() / (double) rangeDuration.in(UnitLookup.NANOSECOND).longValue());
+	}
+
+	/**
+	 * Calculate the number of steps required to achieve the passed zoom percentage
+	 */
+	private int calculateZoomSteps(double percentage) {
+		int steps = (int) Math.floor(percentage / ZOOM_PAN_FACTOR);
+		double tempPercent = steps * ZOOM_PAN_FACTOR;
+
+		if (tempPercent < percentage) {
+			if (percentage > 1 - ZOOM_PAN_FACTOR) {
+				double factor = ZOOM_PAN_FACTOR;
+				do {
+					factor = factor / ZOOM_PAN_MODIFIER;
+					tempPercent = tempPercent + factor;
+					if (modifiedSteps == null) {
+						modifiedSteps = new Stack<Integer>();
+					}
+					if (modifiedSteps.size() == 0 || modifiedSteps.peek() < steps) {
+						modifiedSteps.push(steps);
+					}
+					steps++;
+				} while (tempPercent <= percentage);
+				zoomPanPower = factor / ZOOM_PAN_MODIFIER;
+			} else {
+				steps++;
+			}
+		}
+		return steps;
+	}
+
+	private boolean isZoomCalculated;
+	private boolean isZoomPanDrag;
+
+	public void setIsZoomPanDrag(boolean isZoomPanDrag) {
+		this.isZoomPanDrag = isZoomPanDrag;
+	}
+
+	private boolean getIsZoomPanDrag() {
+		return isZoomPanDrag;
+	}
+
 	public void setVisibleRange(IQuantity rangeStart, IQuantity rangeEnd) {
+		if (rangeDuration != null && !isZoomCalculated && !getIsZoomPanDrag()) {
+			selectionZoom(rangeStart, rangeEnd);
+		}
+		isZoomCalculated = false;
 		rangeStart = QuantitiesToolkit.max(rangeStart, start);
 		rangeEnd = QuantitiesToolkit.min(rangeEnd, end);
 		if (rangeStart.compareTo(rangeEnd) < 0) {
 			SubdividedQuantityRange testRange = new SubdividedQuantityRange(rangeStart, rangeEnd, 10000, 1);
 			if (testRange.getQuantityAtPixel(0).compareTo(testRange.getQuantityAtPixel(1)) < 0) {
@@ -310,10 +673,14 @@
 			} else {
 				// Ensures that zoom out is always allowed
 				currentStart = QuantitiesToolkit.min(rangeStart, currentStart);
 				currentEnd = QuantitiesToolkit.max(rangeEnd, currentEnd);
 			}
+			if (controlBar != null) {
+				controlBar.setStartTime(currentStart);
+				controlBar.setEndTime(currentEnd);
+			}
 			rangeListeners.stream().forEach(l -> l.accept(getVisibleRange()));
 		}
 	}
 
 	private List<Consumer<IRange<IQuantity>>> rangeListeners = new ArrayList<>();
@@ -330,34 +697,36 @@
 	public void clearVisibleRange() {
 		currentStart = start;
 		currentEnd = end;
 	}
 
-	public boolean select(int x1, int x2, int y1, int y2) {
-		int xStart = Math.min(x1, x2) - xOffset;
-		int xEnd = Math.max(x1, x2) - xOffset;
+	public boolean select(int x1, int x2, int y1, int y2, boolean clear) {
+		int xStart = Math.min(x1, x2);
+		int xEnd = Math.max(x1, x2);
 
-		if (xBucketRange != null && (xEnd >= 0)) {
-			return select(xBucketRange.getQuantityAtPixel(Math.max(0, xStart)), xBucketRange.getQuantityAtPixel(xEnd),
-					y1, y2);
+		if (xBucketRange != null && (xEnd != xStart) && xEnd - xOffset >= 0) {
+			return select(xBucketRange.getQuantityAtPixel(Math.max(0, xStart - xOffset)),
+					xBucketRange.getQuantityAtPixel(xEnd - xOffset), y1, y2, clear);
 		} else {
-			return select(null, null, y1, y2);
+			return select(null, null, y1, y2, clear);
 		}
 	}
 
-	public boolean select(IQuantity xStart, IQuantity xEnd, int y1, int y2) {
+	public boolean select(IQuantity xStart, IQuantity xEnd, int y1, int y2, boolean clear) {
 		if (xStart != null && xStart.compareTo(start) < 0) {
 			xStart = start;
 		}
 		if (xEnd != null && xEnd.compareTo(end) > 0) {
 			xEnd = end;
 		}
 		Set<Object> oldRows = null;
 		if (QuantitiesToolkit.same(selectionStart, xStart) && QuantitiesToolkit.same(selectionEnd, xEnd)) {
 			oldRows = new HashSet<>(selectedRows);
 		}
-		selectedRows.clear();
+		if (clear) {
+			selectedRows.clear();
+		}
 		addSelectedRows(rendererResult, 0, Math.min(y1, y2), Math.max(y1, y2));
 		selectionStart = xStart;
 		selectionEnd = xEnd;
 		return (oldRows == null) || !oldRows.equals(selectedRows);
 	}
@@ -391,11 +760,15 @@
 	}
 
 	private boolean addPayload(IRenderedRow row) {
 		Object payload = row.getPayload();
 		if (payload != null) {
-			selectedRows.add(payload);
+			if (selectedRows.contains(payload)) { // ctrl+click deselection
+				selectedRows.remove(payload);
+			} else {
+				selectedRows.add(payload);
+			}
 			return true;
 		}
 		return false;
 	}
 
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartButtonGroup.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartButtonGroup.java
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartButtonGroup.java
@@ -0,0 +1,531 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.ui.misc;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Timer;
+import java.util.TimerTask;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.ScrolledComposite;
+import org.eclipse.swt.events.MouseAdapter;
+import org.eclipse.swt.events.MouseEvent;
+import org.eclipse.swt.events.MouseMoveListener;
+import org.eclipse.swt.events.MouseWheelListener;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.events.PaintListener;
+import org.eclipse.swt.graphics.Cursor;
+import org.eclipse.swt.graphics.GC;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Canvas;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Listener;
+import org.openjdk.jmc.common.unit.IQuantity;
+import org.openjdk.jmc.common.unit.IRange;
+import org.openjdk.jmc.ui.UIPlugin;
+import org.openjdk.jmc.ui.charts.SubdividedQuantityRange;
+import org.openjdk.jmc.ui.charts.XYChart;
+import org.openjdk.jmc.ui.misc.PatternFly.Palette;
+
+public class ChartButtonGroup extends Composite {
+	private static final String DEFAULT_CURSOR = "defaultCursor";
+	private static final String HAND_CURSOR = "handCursor";
+	private static final String ZOOM_IN_CURSOR = "zoomInCursor";
+	private static final String ZOOM_OUT_CURSOR = "zoomOutCursor";
+	private static final int ZOOM_INCREMENT = 1;
+	private List<Button> buttonGroup;
+	private Map<String, Cursor> cursors;
+	private Button scaleToFitBtn;
+	private Button selectionBtn;
+	private Button zoomInBtn;
+	private Button zoomOutBtn;
+	private Button zoomPanBtn;
+	private ChartCanvas chartCanvas;
+	private ChartTextCanvas textCanvas;
+	private Runnable resetLaneHeightAction;
+	private XYChart chart;
+	private ZoomPan zoomPan;
+
+	public ChartButtonGroup(Composite parent) {
+		super(parent, SWT.NONE);
+		GridLayout gl = new GridLayout(5, true);
+		gl.horizontalSpacing = 0;
+		gl.marginWidth = 0;
+		this.setLayout(gl);
+		this.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, false));
+
+		cursors = new HashMap<>();
+		initCursorMap();
+
+		buttonGroup = new ArrayList<>();
+		initSelectionButton();
+		initZoomInButton();
+		initZoomOutButton();
+		initZoomPanButton();
+		initScaleToFitButton();
+	}
+
+	private void initCursorMap() {
+		cursors.put(DEFAULT_CURSOR, getDisplay().getSystemCursor(SWT.CURSOR_ARROW));
+		cursors.put(HAND_CURSOR, getDisplay().getSystemCursor(SWT.CURSOR_HAND));
+		cursors.put(ZOOM_IN_CURSOR, new Cursor(getDisplay(),
+				UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_IN).getImageData(), 0, 0));
+		cursors.put(ZOOM_OUT_CURSOR, new Cursor(getDisplay(),
+				UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_OUT).getImageData(), 0, 0));
+	}
+
+	private void initSelectionButton() {
+		selectionBtn = new Button(this, SWT.TOGGLE);
+		selectionBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		selectionBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_SELECTION));
+		selectionBtn.setSelection(true);
+		selectionBtn.setToolTipText(Messages.ChartDisplayControlBar_SELECTION_TOOL_TOOLTIP);
+		selectionBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				setButtonSelectionStates(selectionBtn, null);
+				changeCursor(DEFAULT_CURSOR);
+			};
+		});
+		buttonGroup.add(selectionBtn);
+	}
+
+	private void initZoomInButton() {
+		zoomInBtn = new Button(this, SWT.TOGGLE);
+		zoomInBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		zoomInBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_IN));
+		zoomInBtn.setSelection(false);
+		StringBuilder sb = new StringBuilder();
+		sb.append(Messages.ChartDisplayControlBar_ZOOM_IN_CLICK_TOOLTIP);
+		sb.append(System.getProperty("line.separator"));
+		sb.append(Messages.ChartDisplayControlBar_ZOOM_IN_HOLD_TOOLTIP);
+		zoomInBtn.setToolTipText(sb.toString());
+		zoomInBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				setButtonSelectionStates(zoomInBtn, zoomPanBtn);
+				changeCursor(ZOOM_IN_CURSOR);
+			}
+		});
+		zoomInBtn.addMouseListener(new LongPressListener(ZOOM_INCREMENT));
+		buttonGroup.add(zoomInBtn);
+	}
+
+	private void initZoomOutButton() {
+		zoomOutBtn = new Button(this, SWT.TOGGLE);
+		zoomOutBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		zoomOutBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_OUT));
+		zoomOutBtn.setSelection(false);
+		StringBuilder sb = new StringBuilder();
+		sb.append(Messages.ChartDisplayControlBar_ZOOM_OUT_CLICK_TOOLTIP);
+		sb.append(System.getProperty("line.separator"));
+		sb.append(Messages.ChartDisplayControlBar_ZOOM_OUT_HOLD_TOOLTIP);
+		zoomOutBtn.setToolTipText(sb.toString());
+		zoomOutBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event e) {
+				setButtonSelectionStates(zoomOutBtn, zoomPanBtn);
+				changeCursor(ZOOM_OUT_CURSOR);
+			}
+		});
+		zoomOutBtn.addMouseListener(new LongPressListener(-ZOOM_INCREMENT));
+		buttonGroup.add(zoomOutBtn);
+	}
+
+	private void initZoomPanButton() {
+		zoomPanBtn = new Button(this, SWT.TOGGLE);
+		zoomPanBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		zoomPanBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_PAN));
+		zoomPanBtn.setSelection(false);
+		zoomPanBtn.setToolTipText(Messages.ChartDisplayControlBar_ZOOM_PAN_TOOLTIP);
+		zoomPanBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				showZoomPanDisplay(zoomPanBtn.getSelection());
+			}
+		});
+		buttonGroup.add(zoomPanBtn);
+	}
+
+	private void initScaleToFitButton() {
+		scaleToFitBtn = new Button(this, SWT.PUSH);
+		scaleToFitBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		scaleToFitBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_SCALE_TO_FIT));
+		scaleToFitBtn.setSelection(false);
+		scaleToFitBtn.setToolTipText(Messages.ChartDisplayControlBar_SCALE_TO_FIT_TOOLTIP);
+		scaleToFitBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				chart.resetTimeline();
+				chartCanvas.redrawChart();
+				getDisplay().syncExec(resetLaneHeightAction);
+			}
+		});
+		buttonGroup.add(scaleToFitBtn);
+	}
+
+	void setChart(XYChart chart) {
+		this.chart = chart;
+	}
+
+	void setResetLaneHeightAction(Runnable resetLaneHeightAction) {
+		this.resetLaneHeightAction = resetLaneHeightAction;
+	}
+
+	void setChartCanvas(ChartCanvas chartCanvas) {
+		this.chartCanvas = chartCanvas;
+	}
+
+	void setTextCanvas(ChartTextCanvas textCanvas) {
+		this.textCanvas = textCanvas;
+	}
+
+	public void updateZoomPanIndicator() {
+		zoomPan.redraw();
+	}
+
+	public void zoomOnClick(Boolean mouseDown) {
+		boolean shouldZoom = zoomInBtn.getSelection() || zoomOutBtn.getSelection();
+		if (shouldZoom) {
+			if (mouseDown) {
+				chart.clearSelection();
+			} else {
+				int zoomAmount = zoomInBtn.getSelection() ? ZOOM_INCREMENT : -ZOOM_INCREMENT;
+				zoom(zoomAmount);
+				if (textCanvas != null) {
+					textCanvas.redrawChartText();
+				}
+			}
+		}
+	}
+
+	public void zoomToSelection() {
+		if (zoomInBtn.getSelection()) {
+			IQuantity selectionStart = chart.getSelectionStart();
+			IQuantity selectionEnd = chart.getSelectionEnd();
+			if (selectionStart == null || selectionEnd == null) {
+				chart.clearVisibleRange();
+			} else {
+				chart.setVisibleRange(selectionStart, selectionEnd);
+				chartCanvas.redrawChart();
+			}
+		}
+	}
+
+	private void changeCursor(String cursorName) {
+		chartCanvas.changeCursor(cursors.get(cursorName));
+	}
+
+	private void setButtonSelectionStates(Button buttonSelected, Button dependentButton) {
+		for (Button button : buttonGroup) {
+			if ((button.getStyle() & SWT.TOGGLE) != 0) {
+				if (button.equals(buttonSelected)) {
+					button.setSelection(true);
+				} else if (dependentButton != null) {
+					if (button.equals(dependentButton)) {
+						button.setSelection(true);
+					} else {
+						button.setSelection(false);
+					}
+				} else {
+					button.setSelection(false);
+				}
+			}
+			showZoomPanDisplay(zoomPanBtn.getSelection());
+		}
+	}
+
+	private class LongPressListener extends MouseAdapter {
+
+		private static final long LONG_PRESS_TIME = 500;
+		private Timer timer;
+		private int zoomAmount;
+
+		LongPressListener(int zoomAmount) {
+			this.zoomAmount = zoomAmount;
+		}
+
+		@Override
+		public void mouseDown(MouseEvent e) {
+			if (e.button == 1) {
+				timer = new Timer();
+				timer.schedule(new LongPress(), LONG_PRESS_TIME, (long) (LONG_PRESS_TIME * 1.5));
+			}
+		}
+
+		@Override
+		public void mouseUp(MouseEvent e) {
+			timer.cancel();
+		}
+
+		public class LongPress extends TimerTask {
+
+			@Override
+			public void run() {
+				doZoomInOut(zoomAmount);
+			}
+		}
+
+		private void doZoomInOut(int zoomAmount) {
+			DisplayToolkit.inDisplayThread().execute(() -> zoom(zoomAmount));
+		}
+	}
+
+	private void zoom(int zoomAmount) {
+		chart.zoom(zoomAmount);
+		chartCanvas.redrawChart();
+	}
+
+	public void createZoomPan(Composite parent) {
+		zoomPan = new ZoomPan(parent);
+		parent.setVisible(false);
+	}
+
+	private void showZoomPanDisplay(boolean show) {
+		if (show) {
+			zoomPan.getParent().setVisible(true);
+			zoomPan.redrawZoomPan();
+		} else {
+			zoomPan.getParent().setVisible(false);
+		}
+	}
+
+	private class ZoomPan extends Canvas {
+		private static final int BORDER_PADDING = 2;
+		private static final double MIN_HEIGHT_PERCENT = 0.15;
+		private static final double MIN_WIDTH_PERCENT = 0.08;
+		private IRange<IQuantity> chartRange;
+		private IRange<IQuantity> lastChartZoomedRange;
+		private Rectangle zoomRect;
+
+		public ZoomPan(Composite parent) {
+			super(parent, SWT.NO_BACKGROUND);
+			addPaintListener(new Painter());
+			PanDetector panDetector = new PanDetector();
+			addMouseListener(panDetector);
+			addMouseMoveListener(panDetector);
+			addMouseWheelListener(panDetector);
+			chartRange = chart.getVisibleRange();
+		}
+
+		public void redrawZoomPan() {
+			redraw();
+		}
+
+		private class PanDetector extends MouseAdapter implements MouseMoveListener, MouseWheelListener {
+			Point currentSelection;
+			Point lastSelection;
+			boolean isPan = false;
+
+			@Override
+			public void mouseDown(MouseEvent e) {
+				if (e.button == 1 && inBounds(e)) {
+					isPan = true;
+					chart.setIsZoomPanDrag(isPan);
+					currentSelection = chartCanvas.translateDisplayToImageCoordinates(e.x, e.y);
+				}
+			}
+
+			private boolean inBounds(MouseEvent e) {
+				Point zoomCanvasBounds = getParent().getSize();
+				if (zoomRect.height < MIN_HEIGHT_PERCENT * zoomCanvasBounds.y
+						|| zoomRect.width < MIN_WIDTH_PERCENT * zoomCanvasBounds.x) {
+					return zoomCanvasBounds.x >= e.x && zoomCanvasBounds.y >= e.y;
+				} else {
+					return zoomRect.contains(e.x, e.y);
+				}
+			}
+
+			@Override
+			public void mouseUp(MouseEvent e) {
+				isPan = false;
+				chart.setIsZoomPanDrag(isPan);
+			}
+
+			@Override
+			public void mouseMove(MouseEvent e) {
+				zoomPan.setCursor(cursors.get(HAND_CURSOR));
+				if (isPan && getParent().getSize().x >= e.x && getParent().getSize().y >= e.y) {
+					lastSelection = currentSelection;
+					currentSelection = chartCanvas.translateDisplayToImageCoordinates(e.x, e.y);
+					int xdiff = currentSelection.x - lastSelection.x;
+					int ydiff = currentSelection.y - lastSelection.y;
+					updateZoomRectFromPan(xdiff, ydiff);
+				}
+			}
+
+			@Override
+			public void mouseScrolled(MouseEvent e) {
+				updateZoomRectFromPan(0, -e.count);
+			}
+		}
+
+		private void updateZoomRectFromPan(int xdiff, int ydiff) {
+			Point bounds = getParent().getSize();
+			boolean xModified = false;
+			boolean yModified = false;
+
+			int xOld = zoomRect.x;
+			zoomRect.x += xdiff;
+			if (zoomRect.x > (bounds.x - zoomRect.width - BORDER_PADDING - 1)) {
+				zoomRect.x = bounds.x - zoomRect.width - BORDER_PADDING - 1;
+			} else if (zoomRect.x < BORDER_PADDING) {
+				zoomRect.x = BORDER_PADDING;
+			}
+			xModified = xOld != zoomRect.x;
+
+			int yOld = zoomRect.y;
+			zoomRect.y += ydiff;
+			if (zoomRect.y < BORDER_PADDING) {
+				zoomRect.y = BORDER_PADDING;
+			} else if (zoomRect.y > (bounds.y - zoomRect.height - BORDER_PADDING - 1)) {
+				zoomRect.y = bounds.y - zoomRect.height - BORDER_PADDING - 1;
+			}
+			yModified = yOld != zoomRect.y;
+
+			if (xModified || yModified) {
+				updateChartFromZoomRect(xModified, yModified);
+				chartCanvas.redrawChart();
+			}
+		}
+
+		private void updateChartFromZoomRect(boolean updateXRange, boolean updateYRange) {
+			Rectangle zoomCanvasBounds = new Rectangle(0, 0, getParent().getSize().x, getParent().getSize().y);
+			Rectangle totalBounds = chartCanvas.getBounds();
+
+			if (updateXRange) {
+				double ratio = getVisibilityRatio(zoomRect.x - BORDER_PADDING, zoomCanvasBounds.x,
+						zoomCanvasBounds.width - BORDER_PADDING);
+				int start = getPixelLocation(ratio, totalBounds.width, 0);
+
+				ratio = getVisibilityRatio(zoomRect.x + zoomRect.width + BORDER_PADDING + 1, zoomCanvasBounds.width,
+						zoomCanvasBounds.width - BORDER_PADDING);
+				int end = getPixelLocation(ratio, totalBounds.width, totalBounds.width);
+
+				SubdividedQuantityRange xAxis = new SubdividedQuantityRange(chartRange.getStart(), chartRange.getEnd(),
+						totalBounds.width, 1);
+				chart.setVisibleRange(xAxis.getQuantityAtPixel(start), xAxis.getQuantityAtPixel(end));
+				lastChartZoomedRange = chart.getVisibleRange();
+			}
+			if (updateYRange) {
+				double ratio = getVisibilityRatio(zoomRect.y - BORDER_PADDING, 0,
+						zoomCanvasBounds.height - BORDER_PADDING);
+				int top = getPixelLocation(ratio, totalBounds.height, 0);
+
+				Point p = ((ScrolledComposite) chartCanvas.getParent()).getOrigin();
+				p.y = top;
+
+				if (textCanvas != null) {
+					textCanvas.syncScroll(p);
+				}
+				chartCanvas.syncScroll(p);
+			}
+		}
+
+		class Painter implements PaintListener {
+			@Override
+			public void paintControl(PaintEvent e) {
+
+				Rectangle backgroundRect = new Rectangle(0, 0, getParent().getSize().x, getParent().getSize().y);
+				GC gc = e.gc;
+
+				gc.setBackground(Palette.PF_BLACK_400.getSWTColor());
+				gc.fillRectangle(backgroundRect);
+				gc.setForeground(Palette.PF_BLACK_900.getSWTColor());
+				gc.drawRectangle(0, 0, backgroundRect.width - 1, backgroundRect.height - 1);
+
+				updateZoomRectFromChart();
+
+				gc.setBackground(Palette.PF_BLACK_100.getSWTColor());
+				gc.fillRectangle(zoomRect);
+				gc.setForeground(Palette.PF_BLACK_900.getSWTColor());
+				gc.drawRectangle(zoomRect);
+			}
+		}
+
+		private void updateZoomRectFromChart() {
+			Rectangle zoomCanvasBounds = new Rectangle(0, 0, getParent().getSize().x, getParent().getSize().y);
+			IRange<IQuantity> zoomedRange = chart.getVisibleRange();
+			IQuantity visibleWidth = chartRange.getExtent();
+			double visibleHeight = chartCanvas.getParent().getBounds().height;
+			Rectangle totalBounds = chartCanvas.getBounds();
+
+			if (zoomRect == null) {
+				zoomRect = new Rectangle(0, 0, 0, 0);
+			}
+			if (!chart.getVisibleRange().equals(lastChartZoomedRange)) {
+				double ratio = getVisibilityRatio(zoomedRange.getStart(), chartRange.getStart(), visibleWidth);
+				int start = getPixelLocation(ratio, zoomCanvasBounds.width, 0);
+
+				ratio = getVisibilityRatio(zoomedRange.getEnd(), chartRange.getEnd(), visibleWidth);
+				int end = getPixelLocation(ratio, zoomCanvasBounds.width, zoomCanvasBounds.width);
+
+				zoomRect.x = start + BORDER_PADDING;
+				zoomRect.width = end - start - 2 * BORDER_PADDING - 1;
+				lastChartZoomedRange = chart.getVisibleRange();
+			}
+			double ratio = getVisibilityRatio(0, totalBounds.y, totalBounds.height);
+			int top = getPixelLocation(ratio, zoomCanvasBounds.height, 0);
+
+			ratio = getVisibilityRatio(visibleHeight, totalBounds.height + totalBounds.y, totalBounds.height);
+			int bottom = getPixelLocation(ratio, zoomCanvasBounds.height, zoomCanvasBounds.height);
+
+			zoomRect.y = top + BORDER_PADDING;
+			zoomRect.height = bottom - top - 2 * BORDER_PADDING - 1;
+
+		}
+
+		private double getVisibilityRatio(double visibleBound, double borderBound, double totalLength) {
+			double diff = visibleBound - borderBound;
+			return diff / totalLength;
+		}
+
+		private double getVisibilityRatio(IQuantity visibleBound, IQuantity borderBound, IQuantity totalLength) {
+			IQuantity diff = visibleBound.subtract(borderBound);
+			return diff.ratioTo(totalLength);
+		}
+
+		private int getPixelLocation(double visiblityRatio, int totalLength, int offset) {
+			return offset + (int) (visiblityRatio * totalLength);
+		}
+	}
+}
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartCanvas.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartCanvas.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartCanvas.java
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartCanvas.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -30,31 +30,33 @@
  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 package org.openjdk.jmc.ui.misc;
 
-import java.awt.Color;
 import java.awt.Graphics2D;
 import java.awt.geom.Point2D;
 import java.awt.geom.Rectangle2D;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.function.Consumer;
 
 import org.eclipse.jface.action.IMenuManager;
 import org.eclipse.jface.util.IPropertyChangeListener;
 import org.eclipse.jface.util.PropertyChangeEvent;
 import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.ScrolledComposite;
 import org.eclipse.swt.events.FocusEvent;
 import org.eclipse.swt.events.FocusListener;
 import org.eclipse.swt.events.KeyEvent;
 import org.eclipse.swt.events.KeyListener;
 import org.eclipse.swt.events.MouseAdapter;
 import org.eclipse.swt.events.MouseEvent;
 import org.eclipse.swt.events.MouseMoveListener;
 import org.eclipse.swt.events.MouseTrackListener;
 import org.eclipse.swt.events.PaintEvent;
 import org.eclipse.swt.events.PaintListener;
+import org.eclipse.swt.graphics.Cursor;
 import org.eclipse.swt.graphics.GC;
 import org.eclipse.swt.graphics.Point;
 import org.eclipse.swt.graphics.Rectangle;
 import org.eclipse.swt.widgets.Canvas;
 import org.eclipse.swt.widgets.Composite;
@@ -70,21 +72,30 @@
 import org.openjdk.jmc.ui.charts.IXDataRenderer;
 import org.openjdk.jmc.ui.charts.XYChart;
 import org.openjdk.jmc.ui.common.util.Environment;
 import org.openjdk.jmc.ui.common.util.Environment.OSType;
 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
+import org.openjdk.jmc.ui.misc.PatternFly.Palette;
 
 public class ChartCanvas extends Canvas {
+	private int laneHeight;
+	private int minLaneHeight = -1;
+	private int minReadableLaneHeight;
+	private int savedLaneHeight;
+	private int numItems = 0;
 	private int lastMouseX = -1;
 	private int lastMouseY = -1;
 	private List<Rectangle2D> highlightRects;
 	private Object hoveredItemData;
 
 	private class Selector extends MouseAdapter implements MouseMoveListener, MouseTrackListener {
 
 		int selectionStartX = -1;
 		int selectionStartY = -1;
+		Point highlightSelectionStart;
+		Point highlightSelectionEnd;
+		Point lastSelection;
 		boolean selectionIsClick = false;
 
 		@Override
 		public void mouseDown(MouseEvent e) {
 			/*
@@ -101,15 +112,52 @@
 			 * The code below instead relies on ignoring mouse down events when SWT.MOD4 is
 			 * depressed. Since MOD4 is CTRL on OS X and 0 on all other current platforms, this
 			 * suffices. Except for an additional platform check, this approach is also used in
 			 * org.eclipse.swt.custom.StyledText.handleMouseDown(Event).
 			 */
-			if ((e.button == 1) && ((e.stateMask & SWT.MOD4) == 0)) {
+			if ((e.button == 1) && ((e.stateMask & SWT.MOD4) == 0) && ((e.stateMask & SWT.CTRL) == 0)
+					&& ((e.stateMask & SWT.SHIFT) == 0)) {
 				selectionStartX = e.x;
 				selectionStartY = e.y;
+				highlightSelectionEnd = new Point(-1, -1);
+				lastSelection = new Point(-1, -1);
 				selectionIsClick = true;
 				toggleSelect(selectionStartX, selectionStartY);
+			} else if (((e.stateMask & SWT.CTRL) != 0) && (e.button == 1)) {
+				select(e.x, e.x, e.y, e.y, false);
+				if (selectionListener != null) {
+					selectionListener.run();
+				}
+			} else if (((e.stateMask & SWT.SHIFT) != 0) && (e.button == 1)) {
+				if (highlightSelectionEnd.y == -1) {
+					highlightSelectionEnd = new Point(e.x, e.y);
+					lastSelection = highlightSelectionEnd;
+					if (highlightSelectionStart.y > highlightSelectionEnd.y) {
+						Point temp = highlightSelectionStart;
+						highlightSelectionStart = highlightSelectionEnd;
+						highlightSelectionEnd = temp;
+					}
+				} else {
+					if (e.y > highlightSelectionStart.y && e.y < highlightSelectionEnd.y) {
+						if (e.y < lastSelection.y) {
+							highlightSelectionEnd = new Point(e.x, e.y);
+						} else if (e.y > lastSelection.y) {
+							highlightSelectionStart = new Point(e.x, e.y);
+						}
+					} else if (e.y < highlightSelectionStart.y) {
+						highlightSelectionStart = new Point(e.x, e.y);
+						lastSelection = highlightSelectionStart;
+					} else if (e.y > highlightSelectionEnd.y) {
+						highlightSelectionEnd = new Point(e.x, e.y);
+						lastSelection = highlightSelectionEnd;
+					}
+				}
+				select(highlightSelectionStart.x, highlightSelectionEnd.x, highlightSelectionStart.y,
+						highlightSelectionEnd.y, true);
+				if (selectionListener != null) {
+					selectionListener.run();
+				}
 			}
 		}
 
 		@Override
 		public void mouseMove(MouseEvent e) {
@@ -129,22 +177,29 @@
 			if (selectionIsClick && ((Math.abs(x - selectionStartX) > 3) || (Math.abs(y - selectionStartY) > 3))) {
 				selectionIsClick = false;
 			}
 			if (!selectionIsClick) {
 				select((int) (selectionStartX / xScale), (int) (x / xScale), (int) (selectionStartY / yScale),
-						(int) (y / yScale));
+						(int) (y / yScale), true);
 			}
 		}
 
 		@Override
 		public void mouseUp(MouseEvent e) {
 			if (selectionStartX >= 0 && (e.button == 1)) {
 				updateSelectionState(e);
+				highlightSelectionStart = new Point(selectionStartX, selectionStartY);
 				selectionStartX = -1;
 				selectionStartY = -1;
+				if (selectionIsClick) {
+					notifyZoomOnClickListener(e.button);
+				}
 				if (selectionListener != null) {
 					selectionListener.run();
+					if (zoomToSelectionListener != null && !selectionIsClick) {
+						zoomToSelectionListener.run();
+					}
 				}
 			}
 		}
 
 		@Override
@@ -166,19 +221,33 @@
 
 	class Painter implements PaintListener {
 
 		@Override
 		public void paintControl(PaintEvent e) {
-			Rectangle rect = getClientArea();
+			Rectangle rect = new Rectangle(0, 0, getParent().getSize().x, getParent().getSize().y);
+			if (minLaneHeight == -1) {
+				minLaneHeight = calculateMinLaneHeight(rect);
+				laneHeight = minLaneHeight;
+			}
+			if (getNumItems() == 0) {
+				rect = getClientArea();
+			} else if (getNumItems() == 1 || (laneHeight * getNumItems() < rect.height)) {
+				// it fills the height
+			} else {
+				rect.height = laneHeight * getNumItems();
+			}
+
 			if (awtNeedsRedraw || !awtCanvas.hasImage(rect.width, rect.height)) {
 				Graphics2D g2d = awtCanvas.getGraphics(rect.width, rect.height);
-				g2d.setColor(Color.WHITE);
-				g2d.fillRect(0, 0, rect.width, rect.height);
 				Point adjusted = translateDisplayToImageCoordinates(rect.width, rect.height);
+				g2d.setColor(Palette.PF_BLACK_100.getAWTColor());
+				g2d.fillRect(0, 0, adjusted.x, adjusted.y);
 				render(g2d, adjusted.x, adjusted.y);
-				if (highlightRects != null) {
-					updateHighlightRects();
+				if (isScrollableChart()) {
+					minReadableLaneHeight = (int) (g2d.getFontMetrics().getHeight() * xScale);
+					minLaneHeight = initMinLaneHeight();
+					((ScrolledComposite) getParent()).setMinSize(rect.width, rect.height);
 				}
 				awtNeedsRedraw = false;
 			}
 			awtCanvas.paint(e, 0, 0);
 			// Crude, flickering highlight of areas also delivered to tooltips.
@@ -198,14 +267,77 @@
 						int width = (int) Math.round(r.getWidth() * xScale);
 						int height = (int) Math.round(r.getHeight() * yScale);
 						gc.drawRectangle(x, y, width, height);
 					}
 				}
+				updateHighlightRects();
 			}
 		}
 	}
 
+	public void setNumItems(int numItems) {
+		this.numItems = numItems;
+	}
+
+	private int getNumItems() {
+		return numItems;
+	}
+
+	private boolean isScrollableChart() {
+		return getParent() instanceof ScrolledComposite;
+	}
+
+	protected int initMinLaneHeight() {
+		// if the min readable lane height * the number of items exceeds the screen, then use min readable height
+		if (minReadableLaneHeight * getNumItems() > getParent().getSize().y) {
+			return minReadableLaneHeight;
+		} else { // if the minimum readable lane height * the number of items leaves extra space, then the min height is the height / number of items
+			return getParent().getSize().y / getNumItems();
+		}
+	}
+
+	protected int calculateMinLaneHeight(Rectangle rect) {
+		return (int) (awtCanvas.getGraphics(rect.width, rect.height).getFontMetrics().getHeight() * xScale);
+	}
+
+	public boolean isLaneHeightMinimumSize() {
+		return laneHeight == minLaneHeight;
+	}
+
+	void setOverviewLaneHeight() {
+		this.savedLaneHeight = laneHeight;
+		setLaneHeight(-1);
+		zoomer = new Zoomer();
+		addListener(SWT.MouseVerticalWheel, zoomer);
+	}
+
+	void adjustLaneHeight(int amount) {
+		if (laneHeight == -1) {
+			restoreLaneHeight();
+		}
+		laneHeight = Math.max(minLaneHeight, laneHeight + amount);
+	}
+
+	void setLaneHeight(int height) {
+		this.laneHeight = height;
+	}
+
+	void restoreLaneHeight() {
+		laneHeight = savedLaneHeight;
+		removeListener(SWT.MouseVerticalWheel, zoomer);
+	}
+
+	public void resetLaneHeight() {
+		if (minLaneHeight != -1) {
+			if (laneHeight == -1) {
+				removeListener(SWT.MouseVerticalWheel, zoomer);
+			}
+			minLaneHeight = initMinLaneHeight();
+			laneHeight = minLaneHeight;
+		}
+	}
+
 	class Zoomer implements Listener {
 
 		@Override
 		public void handleEvent(Event event) {
 			handleWheelEvent(event.stateMask, event.x, event.count);
@@ -285,10 +417,18 @@
 			case '-':
 				zoom(-1);
 				break;
 			default:
 				switch (event.keyCode) {
+				case SWT.ESC:
+					awtChart.clearSelection();
+					if (selectionListener != null) {
+						selectionListener.run();
+					}
+					redrawChart();
+					redrawChartText();
+					break;
 				case SWT.ARROW_RIGHT:
 					pan(10);
 					break;
 				case SWT.ARROW_LEFT:
 					pan(-10);
@@ -331,30 +471,46 @@
 	private final double yScale = Display.getDefault().getDPI().y / Environment.getNormalDPI();
 
 	private final AwtCanvas awtCanvas = new AwtCanvas();
 	private boolean awtNeedsRedraw;
 	private Runnable selectionListener;
+	private Runnable zoomToSelectionListener;
+	private Consumer<Boolean> zoomOnClickListener;
 	private IPropertyChangeListener aaListener;
 	private XYChart awtChart;
 	private MCContextMenuManager chartMenu;
+	private ChartTextCanvas textCanvas;
+	private Listener zoomer;
 
 	public ChartCanvas(Composite parent) {
 		super(parent, SWT.NO_BACKGROUND);
 		addPaintListener(new Painter());
 		Selector selector = new Selector();
 		addMouseListener(selector);
 		addMouseMoveListener(selector);
-		addMouseTrackListener(selector);
 		FocusTracker.enableFocusTracking(this);
-		addListener(SWT.MouseVerticalWheel, new Zoomer());
 		addKeyListener(new KeyNavigator());
 		aaListener = new AntiAliasingListener();
 		UIPlugin.getDefault().getPreferenceStore().addPropertyChangeListener(aaListener);
 		addDisposeListener(e -> UIPlugin.getDefault().getPreferenceStore().removePropertyChangeListener(aaListener));
 		if (Environment.getOSType() == OSType.WINDOWS) {
 			addMouseTrackListener(new WheelStealingZoomer());
 		}
+		if (isScrollableChart()) { // JFR Threads Page
+			((ScrolledComposite) getParent()).getVerticalBar().addListener(SWT.Selection, e -> vBarScroll());
+		} else {
+			addMouseTrackListener(selector);
+			addListener(SWT.MouseVerticalWheel, new Zoomer());
+		}
+	}
+
+	private void vBarScroll() {
+		if (textCanvas != null) {
+			Point location = ((ScrolledComposite) getParent()).getOrigin();
+			textCanvas.syncScroll(location);
+			awtChart.updateZoomPanIndicator();
+		}
 	}
 
 	public IMenuManager getContextMenu() {
 		if (chartMenu == null) {
 			chartMenu = MCContextMenuManager.create(this);
@@ -363,11 +519,15 @@
 		return chartMenu;
 	}
 
 	private void render(Graphics2D context, int width, int height) {
 		if (awtChart != null) {
-			awtChart.render(context, width, height);
+			awtChart.renderChart(context, width, height);
+			if (textCanvas == null) {
+				awtChart.renderText(context, width, height);
+			}
+			awtChart.updateZoomPanIndicator();
 		}
 	}
 
 	/**
 	 * Translates display coordinates into image coordinates for the chart.
@@ -376,11 +536,11 @@
 	 *            the provided x coordinate
 	 * @param y
 	 *            the provided y coordinate
 	 * @return a Point that represents the (x,y) coordinates in the chart's coordinate space
 	 */
-	private Point translateDisplayToImageCoordinates(int x, int y) {
+	protected Point translateDisplayToImageCoordinates(int x, int y) {
 		int xImage = (int) Math.round(x / xScale);
 		int yImage = (int) Math.round(y / yScale);
 		return new Point(xImage, yImage);
 	}
 
@@ -389,14 +549,25 @@
 	 *
 	 * @param x
 	 *            the provided display x coordinate
 	 * @return the x coordinate in the chart's coordinate space
 	 */
-	private int translateDisplayToImageXCoordinates(int x) {
+	protected int translateDisplayToImageXCoordinates(int x) {
 		return (int) Math.round(x / xScale);
 	}
 
+	/**
+	 * Translates a display x coordinate into an image x coordinate for the chart.
+	 *
+	 * @param x
+	 *            the provided display x coordinate
+	 * @return the x coordinate in the chart's coordinate space
+	 */
+	protected int translateDisplayToImageYCoordinates(int y) {
+		return (int) Math.round(y / yScale);
+	}
+
 	public Object getHoveredItemData() {
 		return this.hoveredItemData;
 	}
 
 	public void setHoveredItemData(Object data) {
@@ -405,10 +576,15 @@
 
 	public void resetHoveredItemData() {
 		this.hoveredItemData = null;
 	}
 
+	public void syncHighlightedRectangles(List<Rectangle2D> newRects) {
+		highlightRects = newRects;
+		redraw();
+	}
+
 	private void updateHighlightRects() {
 		List<Rectangle2D> newRects = new ArrayList<>();
 		infoAt(new IChartInfoVisitor.Adapter() {
 			@Override
 			public void visit(IBucket bucket) {
@@ -445,10 +621,13 @@
 			}
 		}, lastMouseX, lastMouseY);
 		// Attempt to reduce flicker by avoiding unnecessary updates.
 		if (!newRects.equals(highlightRects)) {
 			highlightRects = newRects;
+			if (textCanvas != null) {
+				textCanvas.syncHighlightedRectangles(highlightRects);
+			}
 			redraw();
 		}
 	}
 
 	private void clearHighlightRects() {
@@ -483,13 +662,16 @@
 		if ((awtChart != null) && awtChart.zoom(x, zoomInSteps)) {
 			redrawChart();
 		}
 	}
 
-	private void select(int x1, int x2, int y1, int y2) {
-		if ((awtChart != null) && awtChart.select(x1, x2, y1, y2)) {
+	private void select(int x1, int x2, int y1, int y2, boolean clear) {
+		Point p1 = translateDisplayToImageCoordinates(x1, y1);
+		Point p2 = translateDisplayToImageCoordinates(x2, y2);
+		if ((awtChart != null) && awtChart.select(p1.x, p2.x, p1.y, p2.y, clear)) {
 			redrawChart();
+			redrawChartText();
 		}
 	}
 
 	private void toggleSelect(int x, int y) {
 		Point p = translateDisplayToImageCoordinates(x, y);
@@ -513,26 +695,35 @@
 						range[1] = (x1 instanceof IQuantity) ? (IQuantity) x1 : null;
 					}
 				}
 			}, x, y);
 			if ((range[0] != null) || (range[1] != null)) {
-				if (!awtChart.select(range[0], range[1], p.y, p.y)) {
+				if (!awtChart.select(range[0], range[1], p.y, p.y, true)) {
 					awtChart.clearSelection();
 				}
 			} else {
-				if (!awtChart.select(p.x, p.x, p.y, p.y)) {
+				if (!awtChart.select(p.x, p.x, p.y, p.y, true)) {
 					awtChart.clearSelection();
 				}
 			}
+			notifyZoomOnClickListener(SWT.MouseDown);
 			redrawChart();
+			redrawChartText();
 		}
 	}
 
 	public void setChart(XYChart awtChart) {
 		this.awtChart = awtChart;
 		notifyListener();
-		redrawChart();
+	}
+
+	public void setTextCanvas(ChartTextCanvas textCanvas) {
+		this.textCanvas = textCanvas;
+	}
+
+	public void syncScroll(Point scrollPoint) {
+		((ScrolledComposite) getParent()).setOrigin(scrollPoint);
 	}
 
 	public void replaceRenderer(IXDataRenderer rendererRoot) {
 		assert awtChart != null;
 		awtChart.setRendererRoot(rendererRoot);
@@ -542,16 +733,34 @@
 
 	public void setSelectionListener(Runnable selectionListener) {
 		this.selectionListener = selectionListener;
 	}
 
+	public void setZoomToSelectionListener(Runnable zoomListener) {
+		this.zoomToSelectionListener = zoomListener;
+	}
+
+	public void setZoomOnClickListener(Consumer<Boolean> clickListener) {
+		this.zoomOnClickListener = clickListener;
+	}
+
+	private void notifyZoomOnClickListener(Integer button) {
+		if (zoomOnClickListener != null) {
+			zoomOnClickListener.accept(button == SWT.MouseDown);
+		}
+	}
+
 	private void notifyListener() {
 		if (selectionListener != null) {
 			selectionListener.run();
 		}
 	}
 
+	public void changeCursor(Cursor cursor) {
+		setCursor(cursor);
+	}
+
 	public void infoAt(IChartInfoVisitor visitor, int x, int y) {
 		Point p = translateDisplayToImageCoordinates(x, y);
 		if (awtChart != null) {
 			awtChart.infoAt(visitor, p.x, p.y);
 		}
@@ -560,8 +769,21 @@
 	/**
 	 * Mark both the (AWT) chart and the SWT control as needing a redraw.
 	 */
 	public void redrawChart() {
 		awtNeedsRedraw = true;
-		redraw();
+		getDisplay().asyncExec(new Runnable() {
+			public void run() {
+				if (!isDisposed()) {
+					redraw();
+				}
+			}
+		});
 	}
+
+	private void redrawChartText() {
+		if (textCanvas != null) {
+			textCanvas.redrawChartText();
+		}
+	}
+
 }
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartControlBar.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartControlBar.java
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartControlBar.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.ui.misc;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Listener;
+
+import org.openjdk.jmc.common.unit.IQuantity;
+import org.openjdk.jmc.common.unit.IRange;
+import org.openjdk.jmc.ui.charts.XYChart;
+
+public class ChartControlBar extends Composite {
+
+	private ChartButtonGroup buttonGroup;
+	private ChartLaneHeightControls laneHeightControls;
+	private Composite laneFilterContainer;
+	private TimeFilter timeFilter;
+
+	public ChartControlBar(Composite parent, Listener resetListener, IRange<IQuantity> recordingRange) {
+		super(parent, SWT.NONE);
+		this.setLayout(new GridLayout(4, false));
+
+		timeFilter = new TimeFilter(this, recordingRange, resetListener);
+		timeFilter.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, false, false));
+
+		laneFilterContainer = new Composite(this, SWT.NONE);
+		laneFilterContainer.setLayout(new GridLayout());
+
+		Composite buttonGroupContainer = new Composite(this, SWT.NONE);
+		buttonGroupContainer.setLayout(new GridLayout(3, false));
+		buttonGroupContainer.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, true, false));
+		buttonGroup = new ChartButtonGroup(buttonGroupContainer);
+		laneHeightControls = new ChartLaneHeightControls(buttonGroupContainer);
+		buttonGroup.setResetLaneHeightAction(() -> resetLaneHeightToMinimum());
+	}
+
+	public Composite getLaneFilterContainer() {
+		return laneFilterContainer;
+	}
+
+	public ChartButtonGroup getButtonGroup() {
+		return buttonGroup;
+	}
+
+	public void resetLaneHeightToMinimum() {
+		laneHeightControls.resetLaneHeightToMinimum();
+	}
+
+	public void setChart(XYChart chart) {
+		buttonGroup.setChart(chart);
+		timeFilter.setChart(chart);
+	}
+
+	public void setChartCanvas(ChartCanvas canvas) {
+		buttonGroup.setChartCanvas(canvas);
+		laneHeightControls.setChartCanvas(canvas);
+		timeFilter.setChartCanvas(canvas);
+	}
+
+	public void setTextCanvas(ChartTextCanvas textCanvas) {
+		buttonGroup.setTextCanvas(textCanvas);
+		laneHeightControls.setTextCanvas(textCanvas);
+	}
+
+	public void setStartTime(IQuantity startTime) {
+		timeFilter.setStartTime(startTime);
+	}
+
+	public void setEndTime(IQuantity endTime) {
+		timeFilter.setEndTime(endTime);
+	}
+}
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartLaneHeightControls.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartLaneHeightControls.java
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartLaneHeightControls.java
@@ -0,0 +1,153 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.ui.misc;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Listener;
+import org.openjdk.jmc.ui.UIPlugin;
+
+public class ChartLaneHeightControls extends Composite {
+	private Button decHeightBtn;
+	private Button incHeightBtn;
+	private Button overviewBtn;
+	private ChartCanvas chartCanvas;
+	private ChartTextCanvas textCanvas;
+	private static final int ADJUST_AMOUNT = 3;
+
+	public ChartLaneHeightControls(Composite parent) {
+		super(parent, SWT.NONE);
+		GridLayout gl = new GridLayout(3, true);
+		gl.horizontalSpacing = 0;
+		gl.marginWidth = 0;
+		this.setLayout(gl);
+
+		initDecreaseHeightButton();
+		initIncreaseHeightButton();
+		initOverviewButton();
+	}
+
+	private void initDecreaseHeightButton() {
+		decHeightBtn = new Button(this, SWT.PUSH);
+		decHeightBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		decHeightBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_MINUS));
+		decHeightBtn.setToolTipText(Messages.ChartLaneHeightControls_LANE_HEIGHT_DECREASE_TOOLTIP);
+		decHeightBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				adjustLaneHeight(-ADJUST_AMOUNT);
+			}
+		});
+		decHeightBtn.setEnabled(false);
+	}
+
+	private void initIncreaseHeightButton() {
+		incHeightBtn = new Button(this, SWT.PUSH);
+		incHeightBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		incHeightBtn.setToolTipText(Messages.ChartLaneHeightControls_LANE_HEIGHT_INCREASE_TOOLTIP);
+		incHeightBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_PLUS));
+		incHeightBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				adjustLaneHeight(ADJUST_AMOUNT);
+			}
+		});
+	}
+
+	private void initOverviewButton() {
+		overviewBtn = new Button(this, SWT.TOGGLE);
+		overviewBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		overviewBtn.setToolTipText(Messages.ChartLaneHeightControls_OVERVIEW_BUTTON_TOOLTIP);
+		overviewBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_ADRESS));
+		overviewBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				if (!overviewBtn.getSelection()) {
+					chartCanvas.restoreLaneHeight();
+					chartCanvas.redrawChart();
+					if (textCanvas != null) {
+						textCanvas.restoreLaneHeight();
+						textCanvas.redrawChartText();
+					}
+				} else {
+					chartCanvas.setOverviewLaneHeight();
+					chartCanvas.redrawChart();
+					if (textCanvas != null) {
+						textCanvas.setOverviewLaneHeight();
+						textCanvas.redrawChartText();
+					}
+				}
+			}
+		});
+	}
+
+	private void adjustLaneHeight(int amount) {
+		chartCanvas.adjustLaneHeight(amount);
+		chartCanvas.redrawChart();
+		if (textCanvas != null) {
+			textCanvas.adjustLaneHeight(amount);
+			textCanvas.redrawChartText();
+		}
+		if (chartCanvas.isLaneHeightMinimumSize()) {
+			decHeightBtn.setEnabled(false);
+		} else {
+			decHeightBtn.setEnabled(true);
+		}
+		if (overviewBtn.getSelection()) {
+			overviewBtn.setSelection(false);
+		}
+	}
+
+	void resetLaneHeightToMinimum() {
+		chartCanvas.resetLaneHeight();
+		if (textCanvas != null) {
+			textCanvas.resetLaneHeight();
+		}
+		decHeightBtn.setEnabled(false);
+		overviewBtn.setSelection(false);
+	}
+
+	void setChartCanvas(ChartCanvas chartCanvas) {
+		this.chartCanvas = chartCanvas;
+	}
+
+	void setTextCanvas(ChartTextCanvas textCanvas) {
+		this.textCanvas = textCanvas;
+	}
+
+}
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartTextCanvas.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartTextCanvas.java
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartTextCanvas.java
@@ -0,0 +1,483 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.ui.misc;
+
+import java.awt.Graphics2D;
+import java.awt.geom.Rectangle2D;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.eclipse.jface.action.IMenuManager;
+import org.eclipse.jface.util.IPropertyChangeListener;
+import org.eclipse.jface.util.PropertyChangeEvent;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.ScrolledComposite;
+import org.eclipse.swt.events.KeyEvent;
+import org.eclipse.swt.events.KeyListener;
+import org.eclipse.swt.events.MouseAdapter;
+import org.eclipse.swt.events.MouseEvent;
+import org.eclipse.swt.events.MouseMoveListener;
+import org.eclipse.swt.events.MouseTrackListener;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.events.PaintListener;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.widgets.Canvas;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Display;
+import org.openjdk.jmc.ui.UIPlugin;
+import org.openjdk.jmc.ui.accessibility.FocusTracker;
+import org.openjdk.jmc.ui.charts.IChartInfoVisitor;
+import org.openjdk.jmc.ui.charts.IXDataRenderer;
+import org.openjdk.jmc.ui.charts.XYChart;
+import org.openjdk.jmc.ui.common.util.Environment;
+import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
+import org.openjdk.jmc.ui.misc.PatternFly.Palette;
+
+public class ChartTextCanvas extends Canvas {
+	private int laneHeight;
+	private int savedLaneHeight;
+	private int minLaneHeight = -1;
+	private int numItems = 0;
+	private int lastMouseX = -1;
+	private int lastMouseY = -1;
+	private List<Rectangle2D> highlightRects;
+
+	private class Selector extends MouseAdapter implements MouseMoveListener, MouseTrackListener {
+
+		int selectionStartX = -1;
+		int selectionStartY = -1;
+		Point highlightSelectionStart;
+		Point highlightSelectionEnd;
+		Point lastSelection;
+		boolean selectionIsClick = false;
+		Set<Point> highlightPoints;
+
+		@Override
+		public void mouseDown(MouseEvent e) {
+			/*
+			 * On Mac OS X, CTRL + left mouse button can be used to trigger a context menu. (This is
+			 * for historical reasons when the primary input device on Macs were a mouse with a
+			 * single physical button. All modern Macs have other means to bring up the context
+			 * menu, typically a two finger tap.)
+			 * 
+			 * Although I think it would be best to check that this MouseEvent does not cause a
+			 * platform specific popup trigger, like java.awt.event.MouseEvent.isPopupTrigger() for
+			 * AWT, SWT doesn't seem to have something as simple. It has the MenuDetectEvent, but
+			 * the order in relation to this MouseEvent is unspecified.
+			 * 
+			 * The code below instead relies on ignoring mouse down events when SWT.MOD4 is
+			 * depressed. Since MOD4 is CTRL on OS X and 0 on all other current platforms, this
+			 * suffices. Except for an additional platform check, this approach is also used in
+			 * org.eclipse.swt.custom.StyledText.handleMouseDown(Event).
+			 */
+			if ((e.button == 1) && ((e.stateMask & SWT.MOD4) == 0) && ((e.stateMask & SWT.CTRL) == 0)
+					&& ((e.stateMask & SWT.SHIFT) == 0)) {
+				highlightPoints = new HashSet<>();
+				highlightPoints.add(new Point(e.x, e.y));
+				selectionStartX = e.x;
+				selectionStartY = e.y;
+				highlightSelectionEnd = new Point(-1, -1);
+				lastSelection = new Point(-1, -1);
+				selectionIsClick = true;
+				toggleSelect(selectionStartX, selectionStartY);
+			} else if (((e.stateMask & SWT.CTRL) != 0) && (e.button == 1)) {
+				highlightPoints.add(new Point(e.x, e.y));
+				select(e.x, e.x, e.y, e.y, false);
+				if (selectionListener != null) {
+					selectionListener.run();
+				}
+			} else if (((e.stateMask & SWT.SHIFT) != 0) && (e.button == 1)) {
+				if (highlightSelectionEnd.y == -1) {
+					highlightSelectionEnd = new Point(e.x, e.y);
+					lastSelection = highlightSelectionEnd;
+					if (highlightSelectionStart.y > highlightSelectionEnd.y) {
+						Point temp = highlightSelectionStart;
+						highlightSelectionStart = highlightSelectionEnd;
+						highlightSelectionEnd = temp;
+					}
+				} else {
+					if (e.y > highlightSelectionStart.y && e.y < highlightSelectionEnd.y) {
+						if (e.y < lastSelection.y) {
+							highlightSelectionEnd = new Point(e.x, e.y);
+						} else if (e.y > lastSelection.y) {
+							highlightSelectionStart = new Point(e.x, e.y);
+						}
+					} else if (e.y < highlightSelectionStart.y) {
+						highlightSelectionStart = new Point(e.x, e.y);
+						lastSelection = highlightSelectionStart;
+					} else if (e.y > highlightSelectionEnd.y) {
+						highlightSelectionEnd = new Point(e.x, e.y);
+						lastSelection = highlightSelectionEnd;
+					}
+				}
+				select(highlightSelectionStart.x, highlightSelectionStart.x, highlightSelectionStart.y,
+						highlightSelectionEnd.y, true);
+				if (selectionListener != null) {
+					selectionListener.run();
+				}
+			}
+		}
+
+		@Override
+		public void mouseMove(MouseEvent e) {
+			if (selectionStartX >= 0) {
+				highlightRects = null;
+				updateSelectionState(e);
+			} else {
+				lastMouseX = e.x;
+				lastMouseY = e.y;
+				updateHighlightRects();
+			}
+		}
+
+		private void updateSelectionState(MouseEvent e) {
+			int x = e.x;
+			int y = e.y;
+			if (selectionIsClick && ((Math.abs(x - selectionStartX) > 3) || (Math.abs(y - selectionStartY) > 3))) {
+				selectionIsClick = false;
+			}
+			if (!selectionIsClick) {
+				select((int) (selectionStartX / xScale), (int) (selectionStartX / xScale),
+						(int) (selectionStartY / yScale), (int) (y / yScale), true);
+			}
+		}
+
+		@Override
+		public void mouseUp(MouseEvent e) {
+			if (selectionStartX >= 0 && (e.button == 1)) {
+				updateSelectionState(e);
+				highlightSelectionStart = new Point(selectionStartX, selectionStartY);
+				selectionStartX = -1;
+				selectionStartY = -1;
+				if (selectionListener != null) {
+					selectionListener.run();
+				}
+			}
+		}
+
+		@Override
+		public void mouseEnter(MouseEvent e) {
+		}
+
+		@Override
+		public void mouseExit(MouseEvent e) {
+			if (!getClientArea().contains(e.x, e.y)) {
+				resetHoveredItemData();
+			}
+			clearHighlightRects();
+		}
+
+		@Override
+		public void mouseHover(MouseEvent e) {
+		}
+	}
+
+	class Painter implements PaintListener {
+
+		@Override
+		public void paintControl(PaintEvent e) {
+			int minScrollWidth = (int) ((awtChart.getLongestCharWidth() + 10) * xScale);
+			int rectWidth = Math.max(minScrollWidth, getParent().getSize().x);
+			Rectangle rect = new Rectangle(0, 0, rectWidth, getParent().getSize().y);
+			if (getNumItems() > 0) {
+				if (minLaneHeight == -1) {
+					minLaneHeight = chartCanvas.calculateMinLaneHeight(rect);
+					laneHeight = minLaneHeight;
+				}
+				if (getNumItems() != 1 && !(laneHeight * getNumItems() < rect.height)) {
+					rect.height = laneHeight * getNumItems();
+				}
+			}
+
+			if (awtNeedsRedraw || !awtCanvas.hasImage(rect.width, rect.height)) {
+				Graphics2D g2d = awtCanvas.getGraphics(rect.width, rect.height);
+				minLaneHeight = (int) (g2d.getFontMetrics().getHeight() * xScale);
+				Point adjusted = chartCanvas.translateDisplayToImageCoordinates(rect.width, rect.height);
+				g2d.setColor(Palette.PF_BLACK_100.getAWTColor());
+				g2d.fillRect(0, 0, adjusted.x, adjusted.y);
+				render(g2d, adjusted.x, adjusted.y);
+				((ScrolledComposite) getParent()).setMinSize(rect.width, rect.height);
+				if (highlightRects != null) {
+					updateHighlightRects();
+				}
+				awtNeedsRedraw = false;
+			}
+			awtCanvas.paint(e, 0, 0);
+		}
+	}
+
+	public void setNumItems(int numItems) {
+		this.numItems = numItems;
+	}
+
+	private int getNumItems() {
+		return numItems;
+	}
+
+	void setOverviewLaneHeight() {
+		this.savedLaneHeight = laneHeight;
+		setLaneHeight(-1);
+	}
+
+	void adjustLaneHeight(int amount) {
+		if (laneHeight == -1) {
+			restoreLaneHeight();
+		}
+		laneHeight = Math.max(minLaneHeight, laneHeight + amount);
+	}
+
+	void setLaneHeight(int height) {
+		this.laneHeight = height;
+	}
+
+	void restoreLaneHeight() {
+		laneHeight = savedLaneHeight;
+	}
+
+	void resetLaneHeight() {
+		if (minLaneHeight != -1) {
+			minLaneHeight = chartCanvas.initMinLaneHeight();
+			laneHeight = minLaneHeight;
+		}
+	}
+
+	class KeyNavigator implements KeyListener {
+
+		@Override
+		public void keyPressed(KeyEvent event) {
+			switch (event.character) {
+			default:
+				switch (event.keyCode) {
+				case SWT.ESC:
+					awtChart.clearSelection();
+					if (selectionListener != null) {
+						selectionListener.run();
+					}
+					redrawChart();
+					redrawChartText();
+					break;
+				default:
+					// Ignore
+				}
+			}
+		}
+
+		@Override
+		public void keyReleased(KeyEvent event) {
+			// Ignore
+		}
+
+	}
+
+	private class AntiAliasingListener implements IPropertyChangeListener {
+
+		@Override
+		public void propertyChange(PropertyChangeEvent event) {
+			redrawChartText();
+		}
+
+	}
+
+	/**
+	 * This gets the "normal" DPI value for the system (72 on MacOS and 96 on Windows/Linux. It's
+	 * used to determine how much larger the current DPI is so that we can draw the charts based on
+	 * how large that area would be given the "normal" DPI value. Every draw on this smaller chart
+	 * is then scaled up by the Graphics2D objects DefaultTransform.
+	 */
+	private final double xScale = Display.getDefault().getDPI().x / Environment.getNormalDPI();
+	private final double yScale = Display.getDefault().getDPI().y / Environment.getNormalDPI();
+
+	public final AwtCanvas awtCanvas = new AwtCanvas();
+	private boolean awtNeedsRedraw;
+	private Runnable selectionListener;
+	private IPropertyChangeListener aaListener;
+	private XYChart awtChart;
+	private ChartCanvas chartCanvas;
+	private MCContextMenuManager chartMenu;
+	private Object hoveredItemData;
+
+	public ChartTextCanvas(Composite parent) {
+		super(parent, SWT.NO_BACKGROUND);
+		numItems = 0;
+		addPaintListener(new Painter());
+		Selector selector = new Selector();
+		addMouseListener(selector);
+		addMouseMoveListener(selector);
+		FocusTracker.enableFocusTracking(this);
+		addKeyListener(new KeyNavigator());
+		aaListener = new AntiAliasingListener();
+		UIPlugin.getDefault().getPreferenceStore().addPropertyChangeListener(aaListener);
+		addDisposeListener(e -> UIPlugin.getDefault().getPreferenceStore().removePropertyChangeListener(aaListener));
+		((ScrolledComposite) getParent()).getVerticalBar().addListener(SWT.Selection, e -> vBarScroll());
+	}
+
+	private void vBarScroll() {
+		if (chartCanvas != null) {
+			Point location = ((ScrolledComposite) getParent()).getOrigin();
+			chartCanvas.syncScroll(location);
+		}
+	}
+
+	public IMenuManager getContextMenu() {
+		if (chartMenu == null) {
+			chartMenu = MCContextMenuManager.create(this);
+			chartMenu.addMenuListener(manager -> clearHighlightRects());
+		}
+		return chartMenu;
+	}
+
+	private void render(Graphics2D context, int width, int height) {
+		if (awtChart != null) {
+			awtChart.renderTextCanvasText(context, width, height);
+		}
+	}
+
+	public Object getHoveredItemData() {
+		return this.hoveredItemData;
+	}
+
+	public void setHoveredItemData(Object data) {
+		this.hoveredItemData = data;
+	}
+
+	void resetHoveredItemData() {
+		this.hoveredItemData = null;
+	}
+
+	public void syncHighlightedRectangles(List<Rectangle2D> newRects) {
+		highlightRects = newRects;
+		redraw();
+	}
+
+	private void updateHighlightRects() {
+		infoAt(new IChartInfoVisitor.Adapter() {
+			@Override
+			public void hover(Object data) {
+				if (data != null) {
+					setHoveredItemData(data);
+				}
+			}
+		}, lastMouseX, lastMouseY);
+		redraw();
+		if (chartCanvas != null) {
+			chartCanvas.syncHighlightedRectangles(highlightRects);
+		}
+	}
+
+	private void clearHighlightRects() {
+		if (highlightRects != null) {
+			highlightRects = null;
+			redraw();
+		}
+	}
+
+	public void select(int x1, int x2, int y1, int y2, boolean clear) {
+		Point p1 = chartCanvas.translateDisplayToImageCoordinates(x1, y1);
+		Point p2 = chartCanvas.translateDisplayToImageCoordinates(x2, y2);
+		if ((awtChart != null) && awtChart.select(p1.x, p2.x, p1.y, p2.y, clear)) {
+			redrawChartText();
+			redrawChart();
+		}
+	}
+
+	private void toggleSelect(int x, int y) {
+		Point p = chartCanvas.translateDisplayToImageCoordinates(x, y);
+		if (awtChart != null) {
+			if (!awtChart.select(p.x, p.x, p.y, p.y, true)) {
+				awtChart.clearSelection();
+			}
+			redrawChartText();
+			redrawChart();
+		}
+	}
+
+	public void setChart(XYChart awtChart) {
+		this.awtChart = awtChart;
+		notifyListener();
+	}
+
+	public void setChartCanvas(ChartCanvas chartCanvas) {
+		this.chartCanvas = chartCanvas;
+	}
+
+	public void syncScroll(Point scrollPoint) {
+		((ScrolledComposite) getParent()).setOrigin(scrollPoint);
+	}
+
+	public void replaceRenderer(IXDataRenderer rendererRoot) {
+		assert awtChart != null;
+		awtChart.setRendererRoot(rendererRoot);
+		notifyListener();
+		redrawChartText();
+	}
+
+	public void setSelectionListener(Runnable selectionListener) {
+		this.selectionListener = selectionListener;
+	}
+
+	private void notifyListener() {
+		if (selectionListener != null) {
+			selectionListener.run();
+		}
+	}
+
+	public void infoAt(IChartInfoVisitor visitor, int x, int y) {
+		Point p = chartCanvas.translateDisplayToImageCoordinates(x, y);
+		if (awtChart != null) {
+			awtChart.infoAt(visitor, p.x, p.y);
+		}
+	}
+
+	/**
+	 * Mark both the (AWT) chart and the SWT control as needing a redraw.
+	 */
+	public void redrawChartText() {
+		awtNeedsRedraw = true;
+		getDisplay().asyncExec(new Runnable() {
+			public void run() {
+				if (!isDisposed()) {
+					redraw();
+				}
+			}
+		});
+	}
+
+	private void redrawChart() {
+		if (chartCanvas != null) {
+			chartCanvas.redrawChart();
+		}
+	}
+}
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/Messages.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/Messages.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/Messages.java
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/Messages.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -36,10 +36,20 @@
 
 public class Messages extends NLS {
 	private static final String BUNDLE_NAME = "org.openjdk.jmc.ui.misc.messages"; //$NON-NLS-1$
 
 	public static String AbstractWarningItem_WARNING;
+	public static String ChartDisplayControlBar_SCALE_TO_FIT_TOOLTIP;
+	public static String ChartDisplayControlBar_SELECTION_TOOL_TOOLTIP;
+	public static String ChartDisplayControlBar_ZOOM_IN_CLICK_TOOLTIP;
+	public static String ChartDisplayControlBar_ZOOM_IN_HOLD_TOOLTIP;
+	public static String ChartDisplayControlBar_ZOOM_PAN_TOOLTIP;
+	public static String ChartDisplayControlBar_ZOOM_OUT_CLICK_TOOLTIP;
+	public static String ChartDisplayControlBar_ZOOM_OUT_HOLD_TOOLTIP;
+	public static String ChartLaneHeightControls_LANE_HEIGHT_DECREASE_TOOLTIP;
+	public static String ChartLaneHeightControls_LANE_HEIGHT_INCREASE_TOOLTIP;
+	public static String ChartLaneHeightControls_OVERVIEW_BUTTON_TOOLTIP;
 	public static String DIALOG_FILE_EXISTS_TITLE;
 	public static String DIALOG_OVERWRITE_QUESTION_TEXT;
 	public static String EXPORT_AS_IMAGE_ACTION_TEXT;
 	public static String ExceptionDialog_NO_DETAILS_AVAILABLE;
 	public static String FAILED_TO_SAVE_IMAGE;
@@ -92,10 +102,20 @@
 	public static String NumberFieldEditor_ERROR_MESSAGE_MUST_BE;
 	public static String NumberFieldEditor_ERROR_MESSAGE_NO_GREATER;
 	public static String NumberFieldEditor_ERROR_MESSAGE_NO_SMALLER;
 	public static String ProgressComposite_PLEASE_WAIT;
 	public static String QuestionLinkDialog_FAILED_OPEN_BROWSER;
+	public static String TimeFilter_END_TIME_EXCEEDS_ERROR;
+	public static String TimeFilter_ERROR;
+	public static String TimeFilter_FILTER;
+	public static String TimeFilter_FILTER_EVENTS;
+	public static String TimeFilter_FROM;
+	public static String TimeFilter_INVALID_FORMAT_ERROR;
+	public static String TimeFilter_RESET;
+	public static String TimeFilter_START_TIME_LONGER_THAN_END_ERROR;
+	public static String TimeFilter_START_TIME_PRECEEDS_ERROR;
+	public static String TimeFilter_TO;
 
 	static {
 		NLS.initializeMessages(BUNDLE_NAME, Messages.class);
 	}
 
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/PatternFly.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/PatternFly.java
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/PatternFly.java
@@ -0,0 +1,201 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.ui.misc;
+
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.widgets.Display;
+
+public class PatternFly {
+
+	private static final String AWT = "AWT";
+	private static final String SWT = "SWT";
+
+	/**
+	 * The following color Palette is based on the PatternFly palette for reinforcing application
+	 * content and workflows. https://www.patternfly.org/v3/styles/color-palette/
+	 */
+	public enum Palette {
+		/**
+		 * Primary Colors: Black & Blue
+		 */
+		PF_BLACK("#030303"),
+		PF_BLACK_100("#fafafa"),
+		PF_BLACK_150("#f5f5f5"),
+		PF_BLACK_200("#ededed"),
+		PF_BLACK_300("#d1d1d1"),
+		PF_BLACK_400("#bbbbbb"),
+		PF_BLACK_500("#8b8d8f"),
+		PF_BLACK_600("#72767b"),
+		PF_BLACK_700("#4d5258"),
+		PF_BLACK_800("#393f44"),
+		PF_BLACK_900("#292e34"),
+
+		PF_BLUE("#0088ce"),
+		PF_BLUE_50("#def3ff"),
+		PF_BLUE_100("#bee1f4"),
+		PF_BLUE_200("#7dc3e8"),
+		PF_BLUE_300("#39a5dc"),
+		PF_BLUE_400("#0088ce"),
+		PF_BLUE_500("#00659c"),
+		PF_BLUE_600("#004368"),
+		PF_BLUE_700("#002235"),
+
+		/**
+		 * Secondary Colors: Red, Orange, Gold, Light Green, Green, Light Blue, Purple
+		 */
+		PF_RED("#8b0000"),
+		PF_RED_100("#cc0000"),
+		PF_RED_200("#a30000"),
+		PF_RED_300("#8b0000"),
+		PF_RED_400("#470000"),
+		PF_RED_500("#2c0000"),
+
+		PF_ORANGE("#ec7a08"),
+		PF_ORANGE_100("#fbdebf"),
+		PF_ORANGE_200("#f7bd7f"),
+		PF_ORANGE_300("#f39d3c"),
+		PF_ORANGE_400("#ec7a08"),
+		PF_ORANGE_500("#b35c00"),
+		PF_ORANGE_600("#773d00"),
+		PF_ORANGE_700("#3b1f00"),
+
+		PF_GOLD("#f0ab00"),
+		PF_GOLD_100("#fbeabc"),
+		PF_GOLD_200("#f9d67a"),
+		PF_GOLD_300("#f5c12e"),
+		PF_GOLD_400("#f0ab00"),
+		PF_GOLD_500("#b58100"),
+		PF_GOLD_600("#795600"),
+		PF_GOLD_700("#3d2c00"),
+
+		PF_LIGHT_GREEN("#92d400"),
+		PF_LIGHT_GREEN_100("#e4f5bc"),
+		PF_LIGHT_GREEN_200("#c8eb79"),
+		PF_LIGHT_GREEN_300("#ace12e"),
+		PF_LIGHT_GREEN_400("#92d400"),
+		PF_LIGHT_GREEN_500("#6ca100"),
+		PF_LIGHT_GREEN_600("#486b00"),
+		PF_LIGHT_GREEN_700("#253600"),
+
+		PF_GREEN("#3f9c35"),
+		PF_GREEN_100("#cfe7cd"),
+		PF_GREEN_200("#9ecf99"),
+		PF_GREEN_300("#6ec664"),
+		PF_GREEN_400("#3f9c35"),
+		PF_GREEN_500("#2d7623"),
+		PF_GREEN_600("#1e4f18"),
+		PF_GREEN_700("#0f280d"),
+
+		PF_CYAN("#007a87"),
+		PF_CYAN_100("#bedee1"),
+		PF_CYAN_200("#7dbdc3"),
+		PF_CYAN_300("#3a9ca6"),
+		PF_CYAN_400("#007a87"),
+		PF_CYAN_500("#005c66"),
+		PF_CYAN_600("#003d44"),
+		PF_CYAN_700("#001f22"),
+
+		PF_LIGHT_BLUE("#00b9e4"),
+		PF_LIGHT_BLUE_100("#beedf9"),
+		PF_LIGHT_BLUE_200("#7cdbf3"),
+		PF_LIGHT_BLUE_300("#35caed"),
+		PF_LIGHT_BLUE_400("#00b9e4"),
+		PF_LIGHT_BLUE_500("#008bad"),
+		PF_LIGHT_BLUE_600("#005c73"),
+		PF_LIGHT_BLUE_700("#002d39"),
+
+		PF_PURPLE("#703fec"),
+		PF_PURPLE_100("#c7bfff"),
+		PF_PURPLE_200("#a18fff"),
+		PF_PURPLE_300("#8461f7"),
+		PF_PURPLE_400("#703fec"),
+		PF_PURPLE_500("#582fc0"),
+		PF_PURPLE_600("#40199a"),
+		PF_PURPLE_700("#1f0066");
+
+		private final String color;
+
+		Palette(String color) {
+			this.color = color;
+		}
+
+		/**
+		 * Return a color object of the type corresponding to the constant passed into the method.
+		 * This function first converts the PatternFly color hex value to an AWT Color object. Next,
+		 * it either returns the AWT Color object if the constant type is AWT, or uses the RGB
+		 * values to generate an SWT Color object.
+		 *
+		 * @param type
+		 *            String constant: AWT or SWT
+		 * @return a RGB color (as a regular Object to be casted later)
+		 */
+		private Object parseRGB(String type) {
+			java.awt.Color awtColor = new java.awt.Color(java.awt.Color.decode(this.color).getRGB());
+			switch (type) {
+			case (AWT):
+				return awtColor;
+			case (SWT):
+				return new org.eclipse.swt.graphics.Color(Display.getCurrent(), awtColor.getRed(), awtColor.getGreen(),
+						awtColor.getBlue());
+			default:
+				return null;
+			}
+		}
+
+		/**
+		 * Converts the PatternFly hex color value to an AWT Color object
+		 * 
+		 * @return AWT Color of the selected PatternFly color
+		 */
+		public java.awt.Color getAWTColor() {
+			return (java.awt.Color) parseRGB(AWT);
+		}
+
+		/**
+		 * Converts the PatternFly hex color value to an SWT Color object
+		 * 
+		 * @return SWT Color of the selected PatternFly color
+		 */
+		public org.eclipse.swt.graphics.Color getSWTColor() {
+			return (org.eclipse.swt.graphics.Color) parseRGB(SWT);
+		}
+
+		/**
+		 * Page & Component Specific Colors
+		 */
+		public static Color getThreadsPageBackgroundColor() {
+			return PF_BLACK_200.getSWTColor();
+		}
+	}
+}
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/TimeFilter.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/TimeFilter.java
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/TimeFilter.java
@@ -0,0 +1,318 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.ui.misc;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Calendar;
+import java.util.Date;
+
+import org.eclipse.jface.resource.JFaceResources;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.ModifyEvent;
+import org.eclipse.swt.events.ModifyListener;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Listener;
+import org.eclipse.swt.widgets.Text;
+
+import org.openjdk.jmc.common.unit.IQuantity;
+import org.openjdk.jmc.common.unit.IRange;
+import org.openjdk.jmc.common.unit.UnitLookup;
+import org.openjdk.jmc.ui.charts.XYChart;
+import org.openjdk.jmc.ui.misc.PatternFly.Palette;
+
+public class TimeFilter extends Composite {
+
+	private enum FilterType {
+		START, END
+	};
+
+	private static final String dateFormat = "yyyy-MM-dd ";
+	private static final String timeFormat = "HH:mm:ss:SSS";
+	private boolean isMultiDayRecording = false;
+	public Calendar calendar;
+	private ChartCanvas chartCanvas;
+	private XYChart chart;
+	private SimpleDateFormat sdf;
+	private SimpleDateFormat dateFormatter = new SimpleDateFormat(dateFormat);
+	private TimeDisplay startDisplay;
+	private TimeDisplay endDisplay;
+
+	public TimeFilter(Composite parent, IRange<IQuantity> recordingRange, Listener resetListener) {
+		super(parent, SWT.NONE);
+		this.setLayout(new GridLayout(7, false));
+
+		inspectRecordingRange(recordingRange);
+
+		Label eventsLabel = new Label(this, SWT.LEFT);
+		eventsLabel.setText(Messages.TimeFilter_FILTER_EVENTS);
+		eventsLabel.setFont(JFaceResources.getFontRegistry().get(JFaceResources.BANNER_FONT));
+
+		Label fromLabel = new Label(this, SWT.CENTER);
+		fromLabel.setText(Messages.TimeFilter_FROM);
+
+		startDisplay = new TimeDisplay(this, FilterType.START, recordingRange.getStart());
+
+		Label toLabel = new Label(this, SWT.CENTER);
+		toLabel.setText(Messages.TimeFilter_TO);
+
+		endDisplay = new TimeDisplay(this, FilterType.END, recordingRange.getEnd());
+
+		Button resetBtn = new Button(this, SWT.PUSH);
+		resetBtn.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, false, false));
+		resetBtn.setText(Messages.TimeFilter_RESET);
+		resetBtn.addListener(SWT.Selection, resetListener);
+	}
+
+	/**
+	 * Determines whether or not the time range of the recording spans multiple days, and if not,
+	 * sets up a Calendar object to hold the date of the recording.
+	 * 
+	 * @param recordingRange
+	 */
+	private void inspectRecordingRange(IRange<IQuantity> recordingRange) {
+		long firstDateEpoch = recordingRange.getStart().in(UnitLookup.EPOCH_MS).longValue();
+		long secondDateEpoch = recordingRange.getEnd().in(UnitLookup.EPOCH_MS).longValue();
+		isMultiDayRecording = !dateFormatter.format(firstDateEpoch).equals(dateFormatter.format(secondDateEpoch));
+		if (!isMultiDayRecording) {
+			calendar = Calendar.getInstance();
+			calendar.setTimeInMillis(firstDateEpoch);
+			calendar.set(Calendar.HOUR_OF_DAY, 0);
+			calendar.set(Calendar.MINUTE, 0);
+			calendar.set(Calendar.SECOND, 0);
+			calendar.set(Calendar.MILLISECOND, 0);
+			calendar.add(Calendar.MILLISECOND, calendar.getTimeZone().getRawOffset());
+		}
+	}
+
+	protected void updateRange() {
+		chart.setVisibleRange(startDisplay.getCurrentTime(), endDisplay.getCurrentTime());
+		chartCanvas.redrawChart();
+	}
+
+	public void setChart(XYChart chart) {
+		this.chart = chart;
+	}
+
+	public void setChartCanvas(ChartCanvas canvas) {
+		this.chartCanvas = canvas;
+	}
+
+	public void setStartTime(IQuantity time) {
+		startDisplay.setTime(time);
+	}
+
+	public void setEndTime(IQuantity time) {
+		endDisplay.setTime(time);
+	}
+
+	private class TimeDisplay extends Composite {
+
+		private boolean bypassModifyListener;
+		private FilterType type;
+		private int lastEventTime;
+		private IQuantity defaultTime;
+		private IQuantity currentTime;
+		private Text timeText;
+
+		public TimeDisplay(TimeFilter parent, FilterType type, IQuantity defaultTime) {
+			super(parent, SWT.NONE);
+			this.type = type;
+			this.defaultTime = defaultTime;
+			this.setLayout(new GridLayout());
+			timeText = new Text(this, SWT.SEARCH | SWT.SINGLE);
+			// if the recording spans multiple days, include the date in the time display
+			if (!isMultiDayRecording) {
+				timeText.setTextLimit(12);
+				sdf = new SimpleDateFormat(timeFormat);
+			} else {
+				timeText.setTextLimit(23);
+				sdf = new SimpleDateFormat(dateFormat + timeFormat);
+			}
+			timeText.addModifyListener(new ModifyListener() {
+				@Override
+				public void modifyText(ModifyEvent e) {
+					if (getBypassModifyListener()) {
+						setBypassModifyListener(false);
+						return;
+					}
+
+					/**
+					 * If the user edits a Text by highlighting a character and overwrites it with a
+					 * new one, the ModifyListener will fire twice. To prevent validation (and
+					 * potential error dialogs) from occurring twice, compare the time of the
+					 * current ModifyEvent to the last seen ModifyEvent.
+					 */
+					if (e.time == lastEventTime) {
+						return;
+					} else {
+						lastEventTime = e.time;
+					}
+
+					String newTimestring = timeText.getText();
+					if (!isValidSyntax(newTimestring)) {
+						return;
+					}
+					IQuantity newTime = convertStringToIQuantity(newTimestring);
+					if (currentTime == null || newTime == null) {
+						return;
+					}
+					if (isWithinRange(newTime)) {
+						timeText.setForeground(Palette.PF_BLACK.getSWTColor());
+						currentTime = newTime;
+						parent.updateRange();
+					} else {
+						timeText.setForeground(Palette.PF_RED_100.getSWTColor());
+					}
+				}
+			});
+		}
+
+		/**
+		 * Converts the IQuantity time to a string and displays it in the Text
+		 * 
+		 * @param time
+		 *            IQuantity
+		 */
+		public void setTime(IQuantity time) {
+			setBypassModifyListener(true);
+			String timestring = sdf.format(new Date(time.in(UnitLookup.EPOCH_MS).longValue()));
+			this.currentTime = time;
+			timeText.setText(timestring);
+			timeText.setForeground(Palette.PF_BLACK.getSWTColor());
+			setBypassModifyListener(false);
+		}
+
+		/**
+		 * Converts a formatted time string into an IQuantity. If the recording range is within a
+		 * single day, the SimpleDateFormat format will be HH:mm:ss:SSS and need to be added to the
+		 * base date (calendar) in order to calculate the epoch milliseconds.
+		 *
+		 * @param timestring
+		 *            String
+		 * @return IQuantity
+		 */
+		private IQuantity convertStringToIQuantity(String timestring) {
+			try {
+				long parsedTime = sdf.parse(timestring).getTime();
+				if (!isMultiDayRecording) {
+					parsedTime += calendar.getTimeInMillis();
+				}
+				return UnitLookup.EPOCH_MS.quantity(parsedTime);
+			} catch (ParseException e) {
+			}
+			return null;
+		}
+
+		/**
+		 * Verify that the passed time is within the recording range
+		 * 
+		 * @param time
+		 *            IQuantity
+		 * @return true if the specified time is within the time range of the recording
+		 */
+		private boolean isWithinRange(IQuantity time) {
+			if (time == null) {
+				return false;
+			}
+			long timeMillis = time.in(UnitLookup.EPOCH_MS).longValue();
+			if (type == FilterType.START) {
+				if (timeMillis < defaultTime.in(UnitLookup.EPOCH_MS).longValue()) {
+					DialogToolkit.showWarning(getDisplay().getActiveShell(), Messages.TimeFilter_ERROR,
+							Messages.TimeFilter_START_TIME_PRECEEDS_ERROR);
+					return false;
+				} else if (timeMillis > endDisplay.getDefaultTime().in(UnitLookup.EPOCH_MS).longValue()
+						|| timeMillis > endDisplay.getCurrentTime().in(UnitLookup.EPOCH_MS).longValue()) {
+					DialogToolkit.showWarning(getDisplay().getActiveShell(), Messages.TimeFilter_ERROR,
+							Messages.TimeFilter_START_TIME_LONGER_THAN_END_ERROR);
+					endDisplay.getDefaultTime().in(UnitLookup.EPOCH_MS).longValue();
+					return false;
+				}
+			} else {
+				if (timeMillis > defaultTime.in(UnitLookup.EPOCH_MS).longValue()) {
+					DialogToolkit.showWarning(getDisplay().getActiveShell(), Messages.TimeFilter_ERROR,
+							Messages.TimeFilter_END_TIME_EXCEEDS_ERROR);
+					return false;
+				} else if (timeMillis < startDisplay.getDefaultTime().in(UnitLookup.EPOCH_MS).longValue()
+						|| timeMillis < startDisplay.getCurrentTime().in(UnitLookup.EPOCH_MS).longValue()) {
+					DialogToolkit.showWarning(getDisplay().getActiveShell(), Messages.TimeFilter_ERROR,
+							Messages.TimeFilter_START_TIME_LONGER_THAN_END_ERROR);
+					return false;
+				}
+			}
+			return true;
+		}
+
+		/**
+		 * Verify that the passed time string matches the expected time format
+		 * 
+		 * @param formattedTimestring
+		 *            String
+		 * @return true if the text corresponds to the current SimpleDateFormat format
+		 */
+		private boolean isValidSyntax(String formattedTimestring) {
+			if (formattedTimestring.length() != timeText.getTextLimit()) {
+				return false;
+			}
+			try {
+				sdf.parse(formattedTimestring);
+			} catch (ParseException e) {
+				return false;
+			}
+			return true;
+		}
+
+		private IQuantity getDefaultTime() {
+			return defaultTime;
+		}
+
+		private IQuantity getCurrentTime() {
+			return currentTime;
+		}
+
+		// When programmatically changing the Text (e.g., this.setTime()), use
+		// a boolean to prevent the ModifyListener from firing
+		private boolean getBypassModifyListener() {
+			return this.bypassModifyListener;
+		}
+
+		private void setBypassModifyListener(boolean bypassModifyListener) {
+			this.bypassModifyListener = bypassModifyListener;
+		}
+	}
+}
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/TimelineCanvas.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/TimelineCanvas.java
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/TimelineCanvas.java
@@ -0,0 +1,202 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.ui.misc;
+
+import java.awt.Graphics2D;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.SashForm;
+import org.eclipse.swt.events.MouseAdapter;
+import org.eclipse.swt.events.MouseEvent;
+import org.eclipse.swt.events.MouseMoveListener;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.events.PaintListener;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.widgets.Canvas;
+import org.eclipse.swt.widgets.Composite;
+
+import org.openjdk.jmc.common.unit.IQuantity;
+import org.openjdk.jmc.common.unit.IRange;
+import org.openjdk.jmc.ui.charts.AWTChartToolkit;
+import org.openjdk.jmc.ui.charts.SubdividedQuantityRange;
+import org.openjdk.jmc.ui.charts.XYChart;
+import org.openjdk.jmc.ui.misc.PatternFly.Palette;
+
+public class TimelineCanvas extends Canvas {
+	private static final int BASE_RANGE_INDICATOR_HEIGHT = 10;
+	private static final int BASE_RANGE_INDICATOR_Y_OFFSET = 25;
+	private int rangeIndicatorHeight;
+	private int rangeIndicatorYOffset;
+	private int x1;
+	private int x2;
+	private int xOffset;
+	private AwtCanvas awtCanvas;
+	private ChartCanvas chartCanvas;
+	private Graphics2D g2d;
+	private IRange<IQuantity> chartRange;
+	private Rectangle dragRect;
+	private Rectangle indicatorRect;
+	private Rectangle timelineRect;
+	private SashForm sashForm;
+	private SubdividedQuantityRange xTickRange;
+	private XYChart chart;
+
+	public TimelineCanvas(Composite parent, ChartCanvas chartCanvas, SashForm sashForm, double yScale) {
+		super(parent, SWT.NONE);
+		this.chartCanvas = chartCanvas;
+		this.sashForm = sashForm;
+		awtCanvas = new AwtCanvas();
+		addPaintListener(new TimelineCanvasPainter());
+		DragDetector dragDetector = new DragDetector();
+		addMouseListener(dragDetector);
+		addMouseMoveListener(dragDetector);
+		rangeIndicatorHeight = (int) (BASE_RANGE_INDICATOR_HEIGHT * yScale);
+		rangeIndicatorYOffset = (int) (BASE_RANGE_INDICATOR_Y_OFFSET * yScale);
+	}
+
+	private int calculateXOffset() {
+		return sashForm.getChildren()[0].getSize().x + sashForm.getSashWidth();
+	}
+
+	public void renderRangeIndicator(int x1, int x2) {
+		this.x1 = x1;
+		this.x2 = x2;
+		this.redraw();
+	}
+
+	public void setXTickRange(SubdividedQuantityRange xTickRange) {
+		this.xTickRange = xTickRange;
+	}
+
+	public void setChart(XYChart chart) {
+		this.chart = chart;
+		chartRange = chart.getVisibleRange();
+	}
+
+	private class TimelineCanvasPainter implements PaintListener {
+
+		@Override
+		public void paintControl(PaintEvent e) {
+			xOffset = chartCanvas.translateDisplayToImageXCoordinates(calculateXOffset());
+
+			Rectangle rect = getClientArea();
+			g2d = awtCanvas.getGraphics(rect.width, rect.height);
+
+			// Draw the background
+			Point adjusted = chartCanvas.translateDisplayToImageCoordinates(rect.width, rect.height);
+			g2d.setColor(Palette.PF_BLACK_100.getAWTColor());
+			g2d.fillRect(0, 0, adjusted.x, adjusted.y);
+
+			// Draw the horizontal axis
+			if (xTickRange != null) {
+				g2d.setColor(Palette.PF_BLACK.getAWTColor());
+				AWTChartToolkit.drawAxis(g2d, xTickRange, 0, false, 1, false, xOffset);
+			}
+
+			// Draw the range indicator
+			indicatorRect = dragRect != null ? dragRect
+					: new Rectangle(x1 + xOffset,
+							chartCanvas.translateDisplayToImageYCoordinates(rangeIndicatorYOffset), x2 - x1,
+							chartCanvas.translateDisplayToImageYCoordinates(rangeIndicatorHeight));
+			dragRect = null;
+			g2d.setPaint(Palette.PF_ORANGE_400.getAWTColor());
+			g2d.fillRect(indicatorRect.x, indicatorRect.y, indicatorRect.width, indicatorRect.height);
+
+			Point totalSize = sashForm.getChildren()[1].getSize();
+			adjusted = chartCanvas.translateDisplayToImageCoordinates(totalSize.x, totalSize.y);
+			timelineRect = new Rectangle(xOffset,
+					chartCanvas.translateDisplayToImageYCoordinates(rangeIndicatorYOffset), adjusted.x,
+					chartCanvas.translateDisplayToImageYCoordinates(rangeIndicatorHeight));
+			g2d.setPaint(Palette.PF_BLACK_600.getAWTColor());
+			g2d.drawRect(timelineRect.x, timelineRect.y, timelineRect.width, timelineRect.height);
+
+			awtCanvas.paint(e, 0, 0);
+		}
+	}
+
+	private class DragDetector extends MouseAdapter implements MouseMoveListener {
+
+		boolean isDrag = false;
+		Point currentSelection;
+		Point lastSelection;
+
+		@Override
+		public void mouseDown(MouseEvent e) {
+			e.x = chartCanvas.translateDisplayToImageXCoordinates(e.x);
+			e.y = chartCanvas.translateDisplayToImageYCoordinates(e.y);
+			if (isDrag || e.button == 1 && timelineRect.contains(e.x, e.y)) {
+				isDrag = true;
+				currentSelection = new Point(e.x, e.y);
+			}
+		}
+
+		@Override
+		public void mouseUp(MouseEvent e) {
+			isDrag = false;
+			chart.setIsZoomPanDrag(false);
+		}
+
+		@Override
+		public void mouseMove(MouseEvent e) {
+			e.x = chartCanvas.translateDisplayToImageXCoordinates(e.x);
+			e.y = chartCanvas.translateDisplayToImageYCoordinates(e.y);
+			if (timelineRect.contains(e.x, e.y)) {
+				setCursor(getDisplay().getSystemCursor(SWT.CURSOR_HAND));
+			} else {
+				setCursor(getDisplay().getSystemCursor(SWT.CURSOR_ARROW));
+			}
+			if (isDrag) {
+				lastSelection = currentSelection;
+				chart.setIsZoomPanDrag(true);
+				currentSelection = new Point(e.x, e.y);
+				int xdiff = currentSelection.x - lastSelection.x;
+				updateTimelineIndicatorFromDrag(xdiff);
+			}
+		}
+
+		private void updateTimelineIndicatorFromDrag(int xdiff) {
+			if (xdiff != 0 && (indicatorRect.x + xdiff) >= timelineRect.x
+					&& (indicatorRect.x + xdiff + indicatorRect.width) <= timelineRect.x + timelineRect.width) {
+				indicatorRect.x = indicatorRect.x + xdiff;
+				SubdividedQuantityRange xAxis = new SubdividedQuantityRange(chartRange.getStart(), chartRange.getEnd(),
+						timelineRect.width, 1);
+				chart.setVisibleRange(xAxis.getQuantityAtPixel(indicatorRect.x - xOffset),
+						xAxis.getQuantityAtPixel(indicatorRect.x - xOffset + indicatorRect.width));
+				dragRect = indicatorRect;
+				chartCanvas.redrawChart();
+			}
+		}
+	}
+}
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/wizards/OnePageWizardDialog.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/wizards/OnePageWizardDialog.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/wizards/OnePageWizardDialog.java
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/wizards/OnePageWizardDialog.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -148,6 +148,14 @@
 		OnePageWizardDialog d = new OnePageWizardDialog(Display.getCurrent().getActiveShell(), wp);
 		d.setWidthConstraint(width, width);
 		d.setHeightConstraint(height, height);
 		return d.open();
 	}
+
+	public static int openAndHideCancelButton(IWizardPage wp, int width, int height) {
+		OnePageWizardDialog d = new OnePageWizardDialog(Display.getCurrent().getActiveShell(), wp);
+		d.setHideCancelButton(true);
+		d.setWidthConstraint(width, width);
+		d.setHeightConstraint(height, height);
+		return d.open();
+	}
 }
diff a/application/org.openjdk.jmc.ui/src/main/resources/org/openjdk/jmc/ui/misc/messages.properties b/application/org.openjdk.jmc.ui/src/main/resources/org/openjdk/jmc/ui/misc/messages.properties
--- a/application/org.openjdk.jmc.ui/src/main/resources/org/openjdk/jmc/ui/misc/messages.properties
+++ b/application/org.openjdk.jmc.ui/src/main/resources/org/openjdk/jmc/ui/misc/messages.properties
@@ -1,7 +1,7 @@
 #
-#  Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+#  Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
 #
 #  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 #  The contents of this file are subject to the terms of either the Universal Permissive License 
 #  v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -28,10 +28,20 @@
 #  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 #  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 #  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 #  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #
+ChartDisplayControlBar_SCALE_TO_FIT_TOOLTIP=Scale-to-Fit
+ChartDisplayControlBar_SELECTION_TOOL_TOOLTIP=Selection Tool
+ChartDisplayControlBar_ZOOM_IN_CLICK_TOOLTIP=Click: Toggle Click-to-Zoom-In mode
+ChartDisplayControlBar_ZOOM_IN_HOLD_TOOLTIP=Hold: Continuous Zoom-In
+ChartDisplayControlBar_ZOOM_PAN_TOOLTIP=Toggle Zoom-Pan Display
+ChartDisplayControlBar_ZOOM_OUT_CLICK_TOOLTIP=Click: Toggle Click-to-Zoom-Out mode
+ChartDisplayControlBar_ZOOM_OUT_HOLD_TOOLTIP=Hold: Continuous Zoom-Out
+ChartLaneHeightControls_LANE_HEIGHT_DECREASE_TOOLTIP=Decrease thread lane height
+ChartLaneHeightControls_LANE_HEIGHT_INCREASE_TOOLTIP=Increase thread lane height
+ChartLaneHeightControls_OVERVIEW_BUTTON_TOOLTIP=Toggle Overview Mode
 NumberFieldEditor_ERROR_MESSAGE_INTERVAL=Must be {0} between {1} and {2}
 NumberFieldEditor_ERROR_MESSAGE_NO_GREATER=Must be {0} no greater than {2}
 NumberFieldEditor_ERROR_MESSAGE_NO_SMALLER=Must be {0} no smaller than {1}
 NumberFieldEditor_ERROR_MESSAGE_MUST_BE=Must be {0}
 IntFieldEditor_ERROR_MESSAGE_PART_POSITIVE_INTEGER=positive integer
@@ -93,5 +103,15 @@
 DIALOG_OVERWRITE_QUESTION_TEXT=A file with name {0} already exists. Do you want to overwrite it?
 MOVE_LEFT=Move left
 MOVE_RIGHT=Move right
 QuestionLinkDialog_FAILED_OPEN_BROWSER=Failed to open browser
 ProgressComposite_PLEASE_WAIT=Please Wait...
+TimeFilter_END_TIME_EXCEEDS_ERROR=The selected end time exceeds the range of the recording.
+TimeFilter_ERROR=Time Filter Error
+TimeFilter_FILTER=Filter
+TimeFilter_FILTER_EVENTS=Filter Events
+TimeFilter_FROM=From
+TimeFilter_INVALID_FORMAT_ERROR=Invalid time format
+TimeFilter_RESET=Reset
+TimeFilter_START_TIME_LONGER_THAN_END_ERROR=The selected start time exceeds the specified end time.
+TimeFilter_START_TIME_PRECEEDS_ERROR=The selected start time precedes the range of the recording.
+TimeFilter_TO=to
diff a/application/uitests/org.openjdk.jmc.flightrecorder.uitest/src/test/java/org/openjdk/jmc/flightrecorder/uitest/JfrThreadsPageLegacyTest.java b/application/uitests/org.openjdk.jmc.flightrecorder.uitest/src/test/java/org/openjdk/jmc/flightrecorder/uitest/JfrThreadsPageLegacyTest.java
--- /dev/null
+++ b/application/uitests/org.openjdk.jmc.flightrecorder.uitest/src/test/java/org/openjdk/jmc/flightrecorder/uitest/JfrThreadsPageLegacyTest.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.flightrecorder.uitest;
+
+import org.junit.Assert;
+import org.junit.Rule;
+import org.junit.Test;
+import org.openjdk.jmc.test.jemmy.MCJemmyTestBase;
+import org.openjdk.jmc.test.jemmy.MCUITestRule;
+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCChartCanvas;
+import org.openjdk.jmc.test.jemmy.misc.wrappers.JfrNavigator;
+import org.openjdk.jmc.test.jemmy.misc.wrappers.JfrUi;
+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCMenu;
+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCTable;
+
+public class JfrThreadsPageLegacyTest extends MCJemmyTestBase {
+
+	private static final String PLAIN_JFR = "plain_recording.jfr";
+	private static final String TABLE_COLUMN_HEADER = "Thread";
+	private static final String HIDE_THREAD = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_HIDE_THREAD_ACTION;
+	private static final String RESET_CHART = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_RESET_CHART_TO_SELECTION_ACTION;
+
+	private static MCChartCanvas chartCanvas;
+	private static MCTable threadsTable;
+
+	@Rule
+	public MCUITestRule testRule = new MCUITestRule(verboseRuleOutput) {
+		@Override
+		public void before() {
+			JfrUi.openJfr(materialize("jfr", PLAIN_JFR, JfrThreadsPageLegacyTest.class));
+			JfrNavigator.selectTab(JfrUi.Tabs.THREADS_LEGACY);
+			threadsTable = MCTable.getByColumnHeader(TABLE_COLUMN_HEADER);
+			chartCanvas = MCChartCanvas.getChartCanvas();
+		}
+
+		@Override
+		public void after() {
+			MCMenu.closeActiveEditor();
+		}
+	};
+
+	@Test
+	public void testMenuItemEnablement() {
+		final int numThreads = threadsTable.getItemCount();
+		Assert.assertTrue(numThreads > 0);
+
+		Assert.assertFalse(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
+		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
+
+		chartCanvas.clickContextMenuItem(HIDE_THREAD);
+
+		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
+		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
+
+		chartCanvas.clickContextMenuItem(RESET_CHART);
+
+		Assert.assertFalse(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
+		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
+	}
+
+	@Test
+	public void testHideAllThreads() {
+		final int numSelection = 7;
+		final int numThreads = threadsTable.getItemCount();
+		Assert.assertTrue(numThreads > 0 && numThreads >= numSelection);
+		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
+		Assert.assertFalse(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
+
+		// Select a limited number of threads in the chart using the table
+		threadsTable.selectItems(0, numSelection - 1);
+
+		// Hide all the threads from the chart
+		for (int i = 0; i < numSelection; i++) {
+			chartCanvas.clickContextMenuItem(HIDE_THREAD);
+		}
+
+		// Once all threads are hidden from the chart, the hide thread menu item will be disabled
+		Assert.assertFalse(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
+		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
+
+		chartCanvas.clickContextMenuItem(RESET_CHART);
+
+		// Verify the menu item isEnabled values are back to their default values
+		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
+		Assert.assertFalse(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
+	}
+}
diff a/application/uitests/org.openjdk.jmc.flightrecorder.uitest/src/test/java/org/openjdk/jmc/flightrecorder/uitest/JfrThreadsPageTest.java b/application/uitests/org.openjdk.jmc.flightrecorder.uitest/src/test/java/org/openjdk/jmc/flightrecorder/uitest/JfrThreadsPageTest.java
--- a/application/uitests/org.openjdk.jmc.flightrecorder.uitest/src/test/java/org/openjdk/jmc/flightrecorder/uitest/JfrThreadsPageTest.java
+++ b/application/uitests/org.openjdk.jmc.flightrecorder.uitest/src/test/java/org/openjdk/jmc/flightrecorder/uitest/JfrThreadsPageTest.java
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Red Hat Inc. All rights reserved.
  *
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -31,50 +31,174 @@
  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 package org.openjdk.jmc.flightrecorder.uitest;
 
+import java.util.Arrays;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.function.Supplier;
+
 import org.junit.Assert;
 import org.junit.Rule;
 import org.junit.Test;
 import org.openjdk.jmc.test.jemmy.MCJemmyTestBase;
 import org.openjdk.jmc.test.jemmy.MCUITestRule;
 import org.openjdk.jmc.test.jemmy.misc.wrappers.MCChartCanvas;
 import org.openjdk.jmc.test.jemmy.misc.wrappers.JfrNavigator;
 import org.openjdk.jmc.test.jemmy.misc.wrappers.JfrUi;
+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCButton;
 import org.openjdk.jmc.test.jemmy.misc.wrappers.MCMenu;
+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCSashForm;
 import org.openjdk.jmc.test.jemmy.misc.wrappers.MCTable;
+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCText;
+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCTextCanvas;
+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCToolBar;
+import org.openjdk.jmc.ui.UIPlugin;
 
 public class JfrThreadsPageTest extends MCJemmyTestBase {
 
 	private static final String PLAIN_JFR = "plain_recording.jfr";
 	private static final String TABLE_COLUMN_HEADER = "Thread";
+	private static final String OK_BUTTON = "OK";
+	private static final String RESET_BUTTON = "Reset";
+	private static final String START_TIME = "08:06:19:489";
+	private static final String NEW_START_TIME = "08:06:19:500";
+	private static final String INVALID_START_TIME = "08:06:19:480";
+	private static final String INVALID_END_TIME = "08:07:19:733";
+	private static final String FOLD_CHART = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_FOLD_CHART_TOOLTIP;
+	private static final String FOLD_TABLE = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_FOLD_TABLE_TOOLTIP;
 	private static final String HIDE_THREAD = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_HIDE_THREAD_ACTION;
 	private static final String RESET_CHART = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_RESET_CHART_TO_SELECTION_ACTION;
+	private static final String SHOW_CHART = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_SHOW_CHART_TOOLTIP;
+	private static final String SHOW_TABLE = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_SHOW_TABLE_TOOLTIP;
+	private static final String TIME_FILTER_ERROR = org.openjdk.jmc.ui.misc.Messages.TimeFilter_ERROR;
 
 	private static MCChartCanvas chartCanvas;
+	private static MCSashForm sashForm;
+	private static MCTextCanvas textCanvas;
 	private static MCTable threadsTable;
+	private static MCToolBar toolbar;
+	private boolean selected;
 
 	@Rule
 	public MCUITestRule testRule = new MCUITestRule(verboseRuleOutput) {
 		@Override
 		public void before() {
 			JfrUi.openJfr(materialize("jfr", PLAIN_JFR, JfrThreadsPageTest.class));
 			JfrNavigator.selectTab(JfrUi.Tabs.THREADS);
-			threadsTable = MCTable.getByColumnHeader(TABLE_COLUMN_HEADER);
+	        toolbar = MCToolBar.getByToolTip(SHOW_TABLE);
+	        toolbar.clickToolItem(SHOW_TABLE);
 			chartCanvas = MCChartCanvas.getChartCanvas();
+			textCanvas = MCTextCanvas.getTextCanvas();
+			selected = false;
+			sashForm = MCSashForm.getMCSashForm();
+			threadsTable = MCTable.getByColumnHeader(TABLE_COLUMN_HEADER);
 		}
 
 		@Override
 		public void after() {
+			selected = false;
+			toolbar.clickToolItem(FOLD_TABLE);
 			MCMenu.closeActiveEditor();
 		}
 	};
 
+	@Test
+	public void testTextCanvasSelection() throws InterruptedException, ExecutionException, TimeoutException {
+		threadsTable.selectItems(0, 0);
+		Assert.assertEquals(1, threadsTable.getSelectionCount());
+
+		CompletableFuture<Void> future = new CompletableFuture<>();
+		CompletableFuture.supplyAsync(new Supplier<Void>() {
+
+			@Override
+			public Void get() {
+				textCanvas.setSelectionListener(() -> {
+					selected = !selected;
+					future.complete(null);
+				});
+				textCanvas.clickTextCanvas();
+				return future.join();
+			}
+
+		}).get(10, TimeUnit.SECONDS);
+
+		Assert.assertTrue(selected);
+	}
+
+	@Test
+	public void testZoom() {
+		MCText startTimeField = MCText.getByText(START_TIME);
+		MCButton zoomInBtn = MCButton.getByImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_IN));
+		MCButton zoomOutBtn = MCButton.getByImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_OUT));
+
+		// zoom with display bar
+		Assert.assertEquals(START_TIME, startTimeField.getText());
+		zoomInBtn.click();
+		chartCanvas.clickChart();
+		Assert.assertNotEquals(START_TIME, startTimeField.getText());
+
+		zoomOutBtn.click();
+		chartCanvas.clickChart();
+		Assert.assertEquals(START_TIME, startTimeField.getText());
+
+		// zoom with controls
+		chartCanvas.clickChart();
+		chartCanvas.keyboardZoomIn();
+		Assert.assertNotEquals(START_TIME, startTimeField.getText());
+
+		chartCanvas.keyboardZoomOut();
+		Assert.assertEquals(START_TIME, startTimeField.getText());
+	}
+
+	@Test
+	public void testResetButtons() {
+		MCText StartTimeField = MCText.getByText(START_TIME);
+		MCButton resetBtn = MCButton.getByLabel(RESET_BUTTON);
+		MCButton scaleToFitBtn = MCButton.getByImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_SCALE_TO_FIT));
+
+		StartTimeField.setText(NEW_START_TIME);
+		Assert.assertNotEquals(START_TIME, StartTimeField.getText());
+
+		resetBtn.click();
+		Assert.assertEquals(START_TIME, StartTimeField.getText());
+
+		StartTimeField.setText(NEW_START_TIME);
+		Assert.assertNotEquals(START_TIME, StartTimeField.getText());
+
+		scaleToFitBtn.click();
+		Assert.assertEquals(START_TIME, StartTimeField.getText());
+	}
+
+	@Test
+	public void testTimeFilterInvalid() {
+		MCText startTimeField = MCText.getByText(START_TIME);
+		MCText endTimeField = MCText.getByText(START_TIME);
+		MCButton resetBtn = MCButton.getByLabel(RESET_BUTTON);
+
+		startTimeField.setText(INVALID_START_TIME);
+		MCButton okButton = MCButton.getByLabel(TIME_FILTER_ERROR, OK_BUTTON);
+		Assert.assertNotNull(okButton);
+		okButton.click();
+
+		MCButton.focusMc();
+		resetBtn.click();
+		Assert.assertEquals(START_TIME, startTimeField.getText());
+
+		endTimeField.setText(INVALID_END_TIME);
+		okButton = MCButton.getByLabel(TIME_FILTER_ERROR, OK_BUTTON);
+		Assert.assertNotNull(okButton);
+		okButton.click();
+	}
+
 	@Test
 	public void testMenuItemEnablement() {
 		final int numThreads = threadsTable.getItemCount();
+
 		Assert.assertTrue(numThreads > 0);
 
 		Assert.assertFalse(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
 		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
 
@@ -90,11 +214,13 @@
 	}
 
 	@Test
 	public void testHideAllThreads() {
 		final int numSelection = 7;
+
 		final int numThreads = threadsTable.getItemCount();
+
 		Assert.assertTrue(numThreads > 0 && numThreads >= numSelection);
 		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
 		Assert.assertFalse(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
 
 		// Select a limited number of threads in the chart using the table
@@ -113,6 +239,72 @@
 
 		// Verify the menu item isEnabled values are back to their default values
 		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
 		Assert.assertFalse(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
 	}
+
+    @Test
+    public void testFoldingChart() {
+        // Sash weights should both be non-zero to display the chart and table
+        Assert.assertTrue(sashForm.getWeights()[0] != 0 && sashForm.getWeights()[1] != 0);
+
+        // Sash weight corresponding to the chart should be zero when folded
+        toolbar.clickToolItem(FOLD_CHART);
+        Assert.assertTrue(sashForm.getWeights()[0] != 0 && sashForm.getWeights()[1] == 0);
+
+        // When unfolded, the sash weights should be non-zero
+        toolbar.clickToolItem(SHOW_CHART);
+        Assert.assertTrue(sashForm.getWeights()[0] != 0 && sashForm.getWeights()[1] != 0);
+    }
+
+    @Test
+    public void testFoldingTable() {
+        // Sash weights should both be non-zero to display the chart and table
+        Assert.assertTrue(sashForm.getWeights()[0] != 0 && sashForm.getWeights()[1] != 0);
+
+        // Sash weight corresponding to the table should be zero when folded
+        toolbar.clickToolItem(FOLD_TABLE);
+        Assert.assertTrue(sashForm.getWeights()[0] == 0 && sashForm.getWeights()[1] != 0);
+
+        // When unfolded, the sash weights should be non-zero
+        toolbar.clickToolItem(SHOW_TABLE);
+        Assert.assertTrue(sashForm.getWeights()[0] != 0 && sashForm.getWeights()[1] != 0);
+    }
+
+    @Test
+    public void testInvalidFoldingActions() {
+        toolbar.clickToolItem(FOLD_TABLE);
+        int[] weights = sashForm.getWeights();
+        toolbar.clickToolItem(FOLD_CHART);
+        // If the table is already folded, the fold chart action shouldn't work
+        Assert.assertTrue(Arrays.equals(weights, sashForm.getWeights()));
+        toolbar.clickToolItem(SHOW_TABLE);
+
+        toolbar.clickToolItem(FOLD_CHART);
+        weights = sashForm.getWeights();
+        toolbar.clickToolItem(FOLD_TABLE);
+        // If the chart is already folded, the fold table action shouldn't work
+        Assert.assertTrue(Arrays.equals(weights, sashForm.getWeights()));
+
+        // Bring back the chart before retiring
+        toolbar.clickToolItem(SHOW_CHART);
+    }
+
+    @Test
+    public void testPersistingSashWeights() {
+        // Fold the table away
+        toolbar.clickToolItem(FOLD_TABLE);
+        int[] weights = sashForm.getWeights();
+        Assert.assertTrue(sashForm.getWeights()[0] == 0 && sashForm.getWeights()[1] != 0);
+        MCMenu.closeActiveEditor();
+
+        // Re-open the JFR file & verify the table is still folded
+        JfrUi.openJfr(materialize("jfr", PLAIN_JFR, JfrThreadsPageTest.class));
+        JfrNavigator.selectTab(JfrUi.Tabs.THREADS);
+        sashForm = MCSashForm.getMCSashForm();
+        Assert.assertTrue(Arrays.equals(weights, sashForm.getWeights()));
+
+        // Bring back the table before retiring
+        toolbar = MCToolBar.getByToolTip(SHOW_TABLE);
+        toolbar.clickToolItem(SHOW_TABLE);
+    }
 }
diff a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/base/wrappers/MCJemmyBase.java b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/base/wrappers/MCJemmyBase.java
--- a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/base/wrappers/MCJemmyBase.java
+++ b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/base/wrappers/MCJemmyBase.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -211,10 +211,21 @@
 	 */
 	protected static Wrap<? extends Shell> getShell() {
 		return Shells.SHELLS.lookup(Shell.class, new ByTextShell<>("JDK Mission Control")).wrap();
 	}
 
+	/**
+	 * Gets a shell by text
+	 *
+	 * @param text
+	 *            the text string to lookup the shell with
+	 * @return the associated shell
+	 */
+	protected static Wrap<? extends Shell> getShellByText(String text) {
+		return Shells.SHELLS.lookup(Shell.class, new ByTextShell<>(text)).wrap();
+	}
+
 	/**
 	 * Tries to set focus on Mission Control
 	 */
 	public static void focusMc() {
 		getShell().as(Focusable.class).focuser().focus();
diff a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/JfrUi.java b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/JfrUi.java
--- a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/JfrUi.java
+++ b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/JfrUi.java
@@ -56,10 +56,11 @@
 	 */
 	public static enum Tabs {
 		AUTOMATED_ANALYSIS_RESULTS,
 		JAVA_APPLICATION,
 		THREADS,
+		THREADS_LEGACY,
 		MEMORY,
 		LOCK_INSTANCES,
 		FILE_IO,
 		SOCKET_IO,
 		METHOD_PROFILING,
@@ -105,10 +106,13 @@
 				tabText = new String[] {"JVM Internals", "TLAB Allocations"};
 				break;
 			case THREADS:
 				tabText = new String[] {"Java Application", "Threads"};
 				break;
+			case THREADS_LEGACY:
+				tabText = new String[] {"Java Application", "Threads", "(Legacy) Threads"};
+				break;
 			case MEMORY:
 				tabText = new String[] {"Java Application", "Memory"};
 				break;
 			case METHOD_PROFILING:
 				tabText = new String[] {"Java Application", "Method Profiling"};
diff a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCButton.java b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCButton.java
--- a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCButton.java
+++ b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCButton.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -34,10 +34,11 @@
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.eclipse.jface.dialogs.IDialogConstants;
+import org.eclipse.swt.graphics.Image;
 import org.eclipse.swt.widgets.Button;
 import org.eclipse.swt.widgets.Display;
 import org.eclipse.swt.widgets.Shell;
 import org.jemmy.Point;
 import org.jemmy.control.Wrap;
@@ -58,10 +59,49 @@
 
 	private MCButton(Wrap<? extends Button> button) {
 		this.control = button;
 	}
 
+	/**
+	 * Finds a button in the supplied shell by image and returns it.
+	 *
+	 * @param shell
+	 *            the shell where to search for the button
+	 * @param image
+	 *            the image to look up the button with
+	 * @return a {@link MCButton} (possibly null)
+	 */
+	@SuppressWarnings("unchecked")
+	public static MCButton getByImage(Wrap<? extends Shell> shell, Image image) {
+		List<Wrap<? extends Button>> allVisibleButtonWraps = getVisible(
+				shell.as(Parent.class, Button.class).lookup(Button.class));
+		for (final Wrap<? extends Button> buttonWrap : allVisibleButtonWraps) {
+			Fetcher<Image> fetcher = new Fetcher<Image>() {
+				@Override
+				public void run() {
+					setOutput(buttonWrap.getControl().getImage());
+				}
+			};
+			Display.getDefault().syncExec(fetcher);
+			if (image.equals(fetcher.getOutput())) {
+				return new MCButton(buttonWrap);
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Finds a button in the default Mission Control shell and returns it.
+	 *
+	 * @param image
+	 *            the image of the button
+	 * @return a {@link MCButton} in the default shell matching the image.
+	 */
+	public static MCButton getByImage(Image image) {
+		return getByImage(getShell(), image);
+	}
+
 	/**
 	 * Finds a button in the default Mission Control shell and returns it.
 	 *
 	 * @param label
 	 *            the {@link MCButton} Label of the button
@@ -93,10 +133,23 @@
 	 */
 	public static MCButton getByLabel(String label) {
 		return getByLabel(getShell(), label);
 	}
 
+	/**
+	 * Finds a button in a shell with the given text and returns it.
+	 *
+	 * @param label
+	 *            the label string of the button
+	 * @param shellText
+	 *            the text to look up the shell that the button is contained in
+	 * @return a {@link MCButton} in the shell matching the label
+	 */
+	public static MCButton getByLabel(String shellText, String label) {
+		return getByLabel(getShellByText(shellText), label);
+	}
+
 	/**
 	 * Finds a button by button label and returns it
 	 *
 	 * @param shell
 	 *            the shell where to find the button
diff a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCChartCanvas.java b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCChartCanvas.java
--- a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCChartCanvas.java
+++ b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCChartCanvas.java
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Red Hat Inc. All rights reserved.
  *
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -42,10 +42,12 @@
 import org.openjdk.jmc.test.jemmy.misc.fetchers.Fetcher;
 import org.openjdk.jmc.ui.misc.ChartCanvas;
 import org.jemmy.Point;
 import org.jemmy.control.Wrap;
 import org.jemmy.input.StringPopupOwner;
+import org.jemmy.interfaces.Keyboard.KeyboardButtons;
+import org.jemmy.interfaces.Mouse.MouseButtons;
 import org.jemmy.interfaces.Parent;
 import org.jemmy.resources.StringComparePolicy;
 
 /**
  * The Jemmy wrapper for the Mission Control Chart Canvas.
@@ -107,10 +109,35 @@
 		StringPopupOwner<Shell> contextMenu = control.as(StringPopupOwner.class);
 		contextMenu.setPolicy(StringComparePolicy.SUBSTRING);
 		contextMenu.push(getRelativeClickPoint(), new String[] {menuItemText});
 	}
 
+	/**
+	 * Click the center of the chart in the ChartCanvas
+	 */
+	public void clickChart() {
+		Display.getDefault().syncExec(() -> {
+			control.mouse().click(1, getRelativeClickPoint(), MouseButtons.BUTTON1);
+		});
+	}
+
+	/**
+	 * Zoom in the chart with keyboard controls
+	 */
+	public void keyboardZoomIn() {
+		control.keyboard().pushKey(KeyboardButtons.UP);
+		waitForIdle();
+	}
+
+	/**
+	 * Zoom out the chart with keyboard controls
+	 */
+	public void keyboardZoomOut() {
+		control.keyboard().pushKey(KeyboardButtons.DOWN);
+		waitForIdle();
+	}
+
 	/**
 	 * Checks the isEnabled value for a menu item in the context menu
 	 *
 	 * @param menuItemText
 	 *            the menu item of interest
@@ -127,11 +154,11 @@
 	 */
 	private Point getRelativeClickPoint() {
 		Fetcher<Point> fetcher = new Fetcher<Point>() {
 			@Override
 			public void run() {
-				setOutput(new Point(control.getScreenBounds().x / 2, control.getScreenBounds().y / 2));
+				setOutput(new Point(control.getControl().getParent().getSize().x / 2, control.getControl().getParent().getSize().y / 2));
 			}
 		};
 		Display.getDefault().syncExec(fetcher);
 		return fetcher.getOutput();
 	}
diff a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCSashForm.java b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCSashForm.java
--- /dev/null
+++ b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCSashForm.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.test.jemmy.misc.wrappers;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.eclipse.swt.custom.SashForm;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Shell;
+import org.jemmy.control.Wrap;
+import org.jemmy.interfaces.Parent;
+import org.openjdk.jmc.test.jemmy.misc.base.wrappers.MCJemmyBase;
+import org.openjdk.jmc.test.jemmy.misc.fetchers.Fetcher;
+
+/**
+ * The Jemmy wrapper for the Mission Control SashForm.
+ */
+public class MCSashForm extends MCJemmyBase {
+
+	private MCSashForm(Wrap<? extends SashForm> formWrap) {
+		this.control = formWrap;
+	}
+
+	/**
+	 * Returns all visible {@link MCSashForm} objects underneath the supplied shell
+	 *
+	 * @param shell
+	 *            the shell from where to start the search for the SashForm object
+	 * @return a {@link List} of {@link MCSashForm} objects
+	 */
+	@SuppressWarnings("unchecked")
+	public static List<MCSashForm> getAll(Wrap<? extends Shell> shell) {
+		List<Wrap<? extends SashForm>> list = getVisible(shell.as(Parent.class, SashForm.class).lookup(SashForm.class));
+		List<MCSashForm> sashForms = new ArrayList<MCSashForm>();
+		for (int i = 0; i < list.size(); i++) {
+			sashForms.add(new MCSashForm(list.get(i)));
+		}
+		return sashForms;
+	}
+
+	/**
+	 * Returns the first visible {@link MCSashForm} object underneath the supplied shell
+	 *
+	 * @param shell
+	 *            the shell from where to start the search for the SashForm object
+	 * @return a {@link MCSashForm} object
+	 */
+	public static MCSashForm getFirst(Wrap<? extends Shell> shell) {
+		return getAll(shell).get(0);
+	}
+
+	/**
+	 * Returns the first visible {@link MCSashForm} object underneath the Mission Control main shell
+	 *
+	 * @return a {@link MCSashForm} object
+	 */
+	public static MCSashForm getMCSashForm() {
+		return getFirst(getShell());
+	}
+
+	/**
+	 * Returns the current weights of the SashForm
+	 *
+	 * @return the Sash Weights
+	 */
+	public int[] getWeights() {
+		Fetcher<int[]> fetcher = new Fetcher<int[]>() {
+			@Override
+			public void run() {
+				setOutput(((SashForm) control.getControl()).getWeights());
+			}
+		};
+		Display.getDefault().syncExec(fetcher);
+		return fetcher.getOutput();
+	}
+}
diff a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCTable.java b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCTable.java
--- a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCTable.java
+++ b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCTable.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -276,10 +276,23 @@
 	 */
 	public static MCTable getByColumnHeader(String headerName) {
 		return getByColumnHeader(getShell(), headerName);
 	}
 
+	/**
+	 * Finds tables by column header (first match only)
+	 *
+	 * @param shellText
+	 *            text to look up the shell that contains the table
+	 * @param headerName
+	 *            the name of the column header
+	 * @return a {@link MCTable}
+	 */
+	public static MCTable getByColumnHeader(String shellText, String headerName) {
+		return getByColumnHeader(getShellByText(shellText), headerName);
+	}
+
 	/**
 	 * Finds tables by column header (first match only)
 	 *
 	 * @param shell
 	 *            the shell in which to look for the table
@@ -513,10 +526,28 @@
 		};
 		Display.getDefault().syncExec(fetcher);
 		return fetcher.getOutput().intValue();
 	}
 
+	/**
+	 * Gets the number of items selected in the table
+	 *
+	 * @return the number of items selected in the table
+	 */
+	public int getSelectionCount() {
+		final Table table = getWrap().getControl();
+		Fetcher<Integer> fetcher = new Fetcher<Integer>() {
+			@Override
+			public void run() {
+				int count = table.getSelectionCount();
+				setOutput(count);
+			}
+		};
+		Display.getDefault().syncExec(fetcher);
+		return fetcher.getOutput().intValue();
+	}
+
 	/**
 	 * Whether or not the table contains the text given
 	 *
 	 * @param item
 	 *            the text
diff a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCTextCanvas.java b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCTextCanvas.java
--- /dev/null
+++ b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCTextCanvas.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.test.jemmy.misc.wrappers;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Shell;
+import org.openjdk.jmc.test.jemmy.misc.base.wrappers.MCJemmyBase;
+import org.openjdk.jmc.test.jemmy.misc.fetchers.Fetcher;
+import org.openjdk.jmc.ui.misc.ChartTextCanvas;
+import org.jemmy.Point;
+import org.jemmy.control.Wrap;
+import org.jemmy.interfaces.Mouse.MouseButtons;
+import org.jemmy.interfaces.Parent;
+
+/**
+ * The Jemmy wrapper for the Mission Control Text Canvas.
+ */
+public class MCTextCanvas extends MCJemmyBase {
+	private MCTextCanvas(Wrap<? extends ChartTextCanvas> textCanvasWrap) {
+		this.control = textCanvasWrap;
+	}
+
+	/**
+	 * Returns all visible {@link MCtextCanvas} objects underneath the supplied shell
+	 *
+	 * @param shell
+	 *            the shell from where to start the search for the ChartTextCanvas object
+	 * @return a {@link List} of {@link MCtextCanvas} objects
+	 */
+	@SuppressWarnings("unchecked")
+	public static List<MCTextCanvas> getAll(Wrap<? extends Shell> shell) {
+		List<Wrap<? extends ChartTextCanvas>> list = getVisible(
+				shell.as(Parent.class, ChartTextCanvas.class).lookup(ChartTextCanvas.class));
+		List<MCTextCanvas> canvases = new ArrayList<>();
+		for (int i = 0; i < list.size(); i++) {
+			canvases.add(new MCTextCanvas(list.get(i)));
+		}
+		return canvases;
+	}
+
+	/**
+	 * Returns the first visible {@link MCtextCanvas} object underneath the supplied shell
+	 *
+	 * @param shell
+	 *            the shell from where to start the search for the ChartTextCanvas object
+	 * @return a {@link MCtextCanvas} object
+	 */
+	public static MCTextCanvas getFirst(Wrap<? extends Shell> shell) {
+		return getAll(shell).get(0);
+	}
+
+	/**
+	 * Returns the first visible {@link MCTextCanvas} object underneath the Mission Control main
+	 * shell
+	 *
+	 * @return a {@link MCTextCanvas} object
+	 */
+	public static MCTextCanvas getTextCanvas() {
+		return getFirst(getShell());
+	}
+
+	/**
+	 * Sets a selection listener for the Text Canvas
+	 *
+	 * @param listener
+	 *            the selection listener to be set
+	 */
+	public void setSelectionListener(Runnable listener) {
+		ChartTextCanvas.class.cast(control.getControl()).setSelectionListener(listener);
+	}
+
+	/**
+	 * Click the middle thread listed in the Text Canvas
+	 */
+	@SuppressWarnings("unchecked")
+	public void clickTextCanvas() {
+		Display.getDefault().syncExec(() -> {
+			control.mouse().click(1, getRelativeClickPoint(), MouseButtons.BUTTON1);
+		});
+	}
+
+	/**
+	 * Calculates the click point of the Text Canvas
+	 *
+	 * @return the Point of the Text Canvas
+	 */
+	private Point getRelativeClickPoint() {
+		Fetcher<Point> fetcher = new Fetcher<Point>() {
+			@Override
+			public void run() {
+				Rectangle clientArea = ChartTextCanvas.class.cast(control.getControl()).getClientArea();
+				setOutput(new Point(clientArea.width / 2, clientArea.height / 2));
+			}
+		};
+		Display.getDefault().syncExec(fetcher);
+		return fetcher.getOutput();
+	}
+
+}
diff a/license/THIRDPARTYREADME.txt b/license/THIRDPARTYREADME.txt
--- a/license/THIRDPARTYREADME.txt
+++ b/license/THIRDPARTYREADME.txt
@@ -2037,5 +2037,68 @@
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
+
+%% The following notice is provided with respect to FontAwesome,
+which may be included with this product in the form of icons.
+
+Font Awesome Free License
+-------------------------
+
+Font Awesome Free is free, open source, and GPL friendly. You can use it for
+commercial projects, open source projects, or really almost whatever you want.
+Full Font Awesome Free license: https://fontawesome.com/license/free.
+
+# Icons: CC BY 4.0 License (https://creativecommons.org/licenses/by/4.0/)
+In the Font Awesome Free download, the CC BY 4.0 license applies to all icons
+packaged as SVG and JS file types.
+
+# Fonts: SIL OFL 1.1 License (https://scripts.sil.org/OFL)
+In the Font Awesome Free download, the SIL OFL license applies to all icons
+packaged as web and desktop font files.
+
+# Code: MIT License (https://opensource.org/licenses/MIT)
+In the Font Awesome Free download, the MIT license applies to all non-font and
+non-icon files.
+
+# Attribution
+Attribution is required by MIT, SIL OFL, and CC BY licenses. Downloaded Font
+Awesome Free files already contain embedded comments with sufficient
+attribution, so you shouldn't need to do anything additional when using these
+files normally.
+
+We've kept attribution comments terse, so we ask that you do not actively work
+to remove them from files, especially code. They're a great way for folks to
+learn about Font Awesome.
+
+# Brand Icons
+All brand icons are trademarks of their respective owners. The use of these
+trademarks does not indicate endorsement of the trademark holder by Font
+Awesome, nor vice versa. **Please do not use brand logos for any purpose except
+to represent the company, product, or service to which they refer.**
+
+%% The following notice is provided with respect to PatternFly,
+whose color palette may be included with this product.
+
+MIT License
+
+Copyright (c) 2019 Red Hat, Inc.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
