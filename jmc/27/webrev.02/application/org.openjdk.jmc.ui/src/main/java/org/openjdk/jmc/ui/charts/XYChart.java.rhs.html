<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/XYChart.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * 
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * The contents of this file are subject to the terms of either the Universal Permissive License
  7  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
  8  *
  9  * or the following license:
 10  *
 11  * Redistribution and use in source and binary forms, with or without modification, are permitted
 12  * provided that the following conditions are met:
 13  * 
 14  * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
 15  * and the following disclaimer.
 16  * 
 17  * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
 18  * conditions and the following disclaimer in the documentation and/or other materials provided with
 19  * the distribution.
 20  * 
 21  * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
 22  * endorse or promote products derived from this software without specific prior written permission.
 23  * 
 24  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
 25  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 26  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 27  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 28  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 30  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 31  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 package org.openjdk.jmc.ui.charts;
 34 
 35 import java.awt.Color;
 36 import java.awt.Graphics2D;
 37 import java.awt.Point;
 38 import java.awt.geom.AffineTransform;
 39 import java.awt.geom.Point2D;
 40 import java.util.ArrayList;
 41 import java.util.HashSet;
 42 import java.util.List;
 43 import java.util.Set;
<a name="2" id="anc2"></a><span class="line-added"> 44 import java.util.Stack;</span>
 45 import java.util.function.Consumer;
 46 
 47 import org.openjdk.jmc.common.IDisplayable;
 48 import org.openjdk.jmc.common.unit.IQuantity;
 49 import org.openjdk.jmc.common.unit.IRange;
 50 import org.openjdk.jmc.common.unit.QuantitiesToolkit;
 51 import org.openjdk.jmc.common.unit.QuantityRange;
<a name="3" id="anc3"></a><span class="line-added"> 52 import org.openjdk.jmc.common.unit.UnitLookup;</span>
 53 import org.openjdk.jmc.ui.charts.IChartInfoVisitor.ITick;
<a name="4" id="anc4"></a><span class="line-added"> 54 import org.openjdk.jmc.ui.misc.ChartButtonGroup;</span>
<span class="line-added"> 55 import org.openjdk.jmc.ui.misc.ChartControlBar;</span>
<span class="line-added"> 56 import org.openjdk.jmc.ui.misc.TimelineCanvas;</span>
<span class="line-added"> 57 import org.openjdk.jmc.ui.misc.PatternFly.Palette;</span>
 58 
 59 public class XYChart {
 60 	private static final String ELLIPSIS = &quot;...&quot;; //$NON-NLS-1$
 61 	private static final Color SELECTION_COLOR = new Color(255, 255, 255, 220);
 62 	private static final Color RANGE_INDICATION_COLOR = new Color(255, 60, 20);
<a name="5" id="anc5"></a><span class="line-modified"> 63 	private static final int BASE_ZOOM_LEVEL = 100;</span>
<span class="line-modified"> 64 	private static final int RANGE_INDICATOR_HEIGHT = 7;</span>
 65 	private final IQuantity start;
 66 	private final IQuantity end;
<a name="6" id="anc6"></a><span class="line-added"> 67 	private IQuantity rangeDuration;</span>
 68 	private IXDataRenderer rendererRoot;
 69 	private IRenderedRow rendererResult;
 70 	private final int xOffset;
<a name="7" id="anc7"></a><span class="line-added"> 71 	private int yOffset = 35;</span>
 72 	private final int bucketWidth;
 73 	// FIXME: Use bucketWidth * ticksPerBucket instead of hardcoded value?
 74 //	private final int ticksPerBucket = 4;
 75 
 76 	private IQuantity currentStart;
 77 	private IQuantity currentEnd;
 78 
 79 	private final Set&lt;Object&gt; selectedRows = new HashSet&lt;&gt;();
<a name="8" id="anc8"></a><span class="line-added"> 80 	private int axisWidth;</span>
<span class="line-added"> 81 	private int rowColorCounter;</span>
 82 	private IQuantity selectionStart;
 83 	private IQuantity selectionEnd;
 84 	private SubdividedQuantityRange xBucketRange;
 85 	private SubdividedQuantityRange xTickRange;
<a name="9" id="anc9"></a><span class="line-modified"> 86 </span>
<span class="line-added"> 87 	// JFR Threads Page</span>
<span class="line-added"> 88 	private static final double ZOOM_PAN_FACTOR = 0.05;</span>
<span class="line-added"> 89 	private static final int ZOOM_PAN_MODIFIER = 2;</span>
<span class="line-added"> 90 	private double zoomPanPower = ZOOM_PAN_FACTOR / ZOOM_PAN_MODIFIER;</span>
<span class="line-added"> 91 	private double currentZoom;</span>
<span class="line-added"> 92 	private int zoomSteps;</span>
<span class="line-added"> 93 	private ChartButtonGroup buttonGroup;</span>
<span class="line-added"> 94 	private ChartControlBar controlBar;</span>
<span class="line-added"> 95 	private Stack&lt;Integer&gt; modifiedSteps;</span>
<span class="line-added"> 96 	private TimelineCanvas timelineCanvas;</span>
<span class="line-added"> 97 	private int longestCharWidth = 0;</span>
 98 
 99 	public XYChart(IRange&lt;IQuantity&gt; range, IXDataRenderer rendererRoot) {
100 		this(range.getStart(), range.getEnd(), rendererRoot);
101 	}
102 
103 	public XYChart(IRange&lt;IQuantity&gt; range, IXDataRenderer rendererRoot, int xOffset) {
104 		this(range.getStart(), range.getEnd(), rendererRoot, xOffset);
105 	}
106 
<a name="10" id="anc10"></a><span class="line-added">107 	// JFR Threads Page</span>
<span class="line-added">108 	public XYChart(IRange&lt;IQuantity&gt; range, IXDataRenderer rendererRoot, int xOffset, Integer yOffset,</span>
<span class="line-added">109 			TimelineCanvas timelineCanvas, ChartControlBar controlBar, ChartButtonGroup buttonGroup) {</span>
<span class="line-added">110 		this(range.getStart(), range.getEnd(), rendererRoot, xOffset);</span>
<span class="line-added">111 		this.yOffset = yOffset;</span>
<span class="line-added">112 		this.timelineCanvas = timelineCanvas;</span>
<span class="line-added">113 		this.controlBar = controlBar;</span>
<span class="line-added">114 		this.buttonGroup = buttonGroup;</span>
<span class="line-added">115 		this.rangeDuration = range.getExtent();</span>
<span class="line-added">116 		this.currentZoom = BASE_ZOOM_LEVEL;</span>
<span class="line-added">117 		this.isZoomCalculated = false;</span>
<span class="line-added">118 	}</span>
<span class="line-added">119 </span>
120 	public XYChart(IRange&lt;IQuantity&gt; range, IXDataRenderer rendererRoot, int xOffset, int bucketWidth) {
121 		this(range.getStart(), range.getEnd(), rendererRoot, xOffset, bucketWidth);
122 	}
123 
124 	public XYChart(IQuantity start, IQuantity end, IXDataRenderer rendererRoot) {
125 		this(start, end, rendererRoot, 60);
126 	}
127 
128 	public XYChart(IQuantity start, IQuantity end, IXDataRenderer rendererRoot, int xOffset) {
129 		this(start, end, rendererRoot, xOffset, 25);
130 	}
131 
132 	public XYChart(IQuantity start, IQuantity end, IXDataRenderer rendererRoot, int xOffset, int bucketWidth) {
133 		this.rendererRoot = rendererRoot;
134 		// Start value must always be strictly less than end
135 		assert (start.compareTo(end) &lt; 0);
<a name="11" id="anc11"></a><span class="line-modified">136 		this.currentStart = start;</span>
137 		this.start = start;
<a name="12" id="anc12"></a><span class="line-modified">138 		this.currentEnd = end;</span>
139 		this.end = end;
140 		this.xOffset = xOffset;
141 		this.bucketWidth = bucketWidth;
142 	}
143 
144 	public void setRendererRoot(IXDataRenderer rendererRoot) {
145 		clearSelection();
146 		this.rendererRoot = rendererRoot;
<a name="13" id="anc13"></a><span class="line-added">147 		longestCharWidth = 0;</span>
148 	}
149 
150 	public IXDataRenderer getRendererRoot() {
151 		return rendererRoot;
152 	}
153 
154 	public Object[] getSelectedRows() {
155 		return selectedRows.toArray(new Object[selectedRows.size()]);
156 	}
157 
158 	public IQuantity getSelectionStart() {
159 		return selectionStart;
160 	}
161 
162 	public IQuantity getSelectionEnd() {
163 		return selectionEnd;
164 	}
165 
166 	public IRange&lt;IQuantity&gt; getSelectionRange() {
167 		return (selectionStart != null) &amp;&amp; (selectionEnd != null)
168 				? QuantityRange.createWithEnd(selectionStart, selectionEnd) : null;
169 	}
170 
<a name="14" id="anc14"></a><span class="line-modified">171 	public void renderChart(Graphics2D context, int width, int height) {</span>
<span class="line-modified">172 		if (width &gt; xOffset &amp;&amp; height &gt; yOffset) {</span>
173 			axisWidth = width - xOffset;
174 			// FIXME: xBucketRange and xTickRange should be more related, so that each tick is typically an integer number of buckets (or possibly 2.5 buckets).
175 			xBucketRange = new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, bucketWidth);
176 			// FIXME: Use bucketWidth * ticksPerBucket instead of hardcoded value?
177 			xTickRange = new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, 100);
178 			AffineTransform oldTransform = context.getTransform();
179 			context.translate(xOffset, 0);
<a name="15" id="anc15"></a><span class="line-modified">180 			doRenderChart(context, height - yOffset);</span>
181 			context.setTransform(oldTransform);
182 		}
183 	}
184 
<a name="16" id="anc16"></a><span class="line-added">185 	public void renderTextCanvasText(Graphics2D context, int width, int height) {</span>
<span class="line-added">186 		AffineTransform oldTransform = context.getTransform();</span>
<span class="line-added">187 		axisWidth = width - xOffset;</span>
<span class="line-added">188 		doRenderTextCanvasText(context, height);</span>
<span class="line-added">189 		context.setTransform(oldTransform);</span>
<span class="line-added">190 	}</span>
<span class="line-added">191 </span>
<span class="line-added">192 	public void renderText(Graphics2D context, int width, int height) {</span>
<span class="line-added">193 		if (width &gt; xOffset &amp;&amp; height &gt; yOffset) {</span>
<span class="line-added">194 			axisWidth = xOffset;</span>
<span class="line-added">195 			AffineTransform oldTransform = context.getTransform();</span>
<span class="line-added">196 			doRenderText(context);</span>
<span class="line-added">197 			context.setTransform(oldTransform);</span>
<span class="line-added">198 			axisWidth = width - xOffset;</span>
<span class="line-added">199 		}</span>
<span class="line-added">200 	}</span>
<span class="line-added">201 </span>
202 	private void renderRangeIndication(Graphics2D context, int rangeIndicatorY) {
203 		// FIXME: Extract the needed functionality from SubdividedQuantityRange
204 		SubdividedQuantityRange fullRangeAxis = new SubdividedQuantityRange(start, end, axisWidth, 25);
205 		int x1 = (int) fullRangeAxis.getPixel(currentStart);
206 		int x2 = (int) Math.ceil(fullRangeAxis.getPixel(currentEnd));
<a name="17" id="anc17"></a><span class="line-modified">207 </span>
<span class="line-added">208 		if (timelineCanvas != null) {</span>
<span class="line-added">209 			timelineCanvas.renderRangeIndicator(x1, x2);</span>
<span class="line-added">210 			updateZoomPanIndicator();</span>
<span class="line-added">211 		} else {</span>
212 			context.setPaint(RANGE_INDICATION_COLOR);
213 			context.fillRect(x1, rangeIndicatorY, x2 - x1, RANGE_INDICATOR_HEIGHT);
214 			context.setPaint(Color.DARK_GRAY);
215 			context.drawRect(0, rangeIndicatorY, axisWidth - 1, RANGE_INDICATOR_HEIGHT);
216 		}
217 	}
218 
<a name="18" id="anc18"></a><span class="line-modified">219 	public void updateZoomPanIndicator() {</span>
<span class="line-added">220 		if (buttonGroup != null) {</span>
<span class="line-added">221 			buttonGroup.updateZoomPanIndicator();</span>
<span class="line-added">222 		}</span>
<span class="line-added">223 	}</span>
<span class="line-added">224 </span>
<span class="line-added">225 	private IRenderedRow getRendererResult(Graphics2D context, int axisHeight) {</span>
<span class="line-added">226 		if (xBucketRange == null) {</span>
<span class="line-added">227 			xBucketRange = getXBucketRange();</span>
<span class="line-added">228 		}</span>
<span class="line-added">229 		return rendererRoot.render(context, xBucketRange, axisHeight);</span>
<span class="line-added">230 	}</span>
<span class="line-added">231 </span>
<span class="line-added">232 	private SubdividedQuantityRange getXBucketRange() {</span>
<span class="line-added">233 		return new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, bucketWidth);</span>
<span class="line-added">234 	}</span>
<span class="line-added">235 </span>
<span class="line-added">236 	private void doRenderChart(Graphics2D context, int axisHeight) {</span>
<span class="line-added">237 		rowColorCounter = 0;</span>
238 		context.setPaint(Color.LIGHT_GRAY);
239 		AWTChartToolkit.drawGrid(context, xTickRange, axisHeight, false);
240 		// Attempt to make graphs so low they cover the axis show by drawing the full axis first ...
241 		context.setPaint(Color.BLACK);
<a name="19" id="anc19"></a><span class="line-modified">242 		if (timelineCanvas != null) {</span>
<span class="line-added">243 			timelineCanvas.setXTickRange(xTickRange);</span>
<span class="line-added">244 		} else {</span>
<span class="line-added">245 			AWTChartToolkit.drawAxis(context, xTickRange, axisHeight - 1, false, 1 - xOffset, false);</span>
<span class="line-added">246 		}</span>
247 		// ... then the graph ...
<a name="20" id="anc20"></a><span class="line-modified">248 		rendererResult = getRendererResult(context, axisHeight);</span>
249 		AffineTransform oldTransform = context.getTransform();
<a name="21" id="anc21"></a><span class="line-modified">250 </span>
251 		context.setTransform(oldTransform);
252 		if (!selectedRows.isEmpty()) {
<a name="22" id="anc22"></a><span class="line-modified">253 			renderSelectionChart(context, rendererResult);</span>
254 			context.setTransform(oldTransform);
255 		}
256 		// .. and finally a semitransparent axis line again.
257 		context.setPaint(new Color(0, 0, 0, 64));
258 		context.drawLine(0, axisHeight - 1, axisWidth - 1, axisHeight - 1);
259 		renderRangeIndication(context, axisHeight + 25);
260 	}
261 
<a name="23" id="anc23"></a><span class="line-modified">262 	private void doRenderText(Graphics2D context) {</span>
<span class="line-added">263 		AffineTransform oldTransform = context.getTransform();</span>
<span class="line-added">264 		rowColorCounter = -1;</span>
<span class="line-added">265 		renderText(context, rendererResult);</span>
<span class="line-added">266 		context.setTransform(oldTransform);</span>
<span class="line-added">267 	}</span>
<span class="line-added">268 </span>
<span class="line-added">269 	private void doRenderTextCanvasText(Graphics2D context, int height) {</span>
<span class="line-added">270 		if (rendererResult == null) {</span>
<span class="line-added">271 			rendererResult = getRendererResult(context, height - yOffset);</span>
<span class="line-added">272 		}</span>
<span class="line-added">273 		AffineTransform oldTransform = context.getTransform();</span>
<span class="line-added">274 		rowColorCounter = 0;</span>
<span class="line-added">275 		renderText(context, rendererResult);</span>
<span class="line-added">276 		context.setTransform(oldTransform);</span>
<span class="line-added">277 		if (!selectedRows.isEmpty()) {</span>
<span class="line-added">278 			renderSelectionText(context, rendererResult);</span>
<span class="line-added">279 			context.setTransform(oldTransform);</span>
<span class="line-added">280 		}</span>
<span class="line-added">281 	}</span>
<span class="line-added">282 </span>
<span class="line-added">283 	private void renderSelectionText(Graphics2D context, IRenderedRow row) {</span>
<span class="line-added">284 		if (selectedRows.contains(row.getPayload())) {</span>
<span class="line-added">285 			if (row.getHeight() != rendererResult.getHeight()) {</span>
<span class="line-added">286 				Color highlight = new Color(0, 206, 209, 20);</span>
<span class="line-added">287 				context.setColor(highlight);</span>
<span class="line-added">288 				context.fillRect(0, 0, axisWidth, row.getHeight());</span>
<span class="line-added">289 			} else {</span>
<span class="line-added">290 				selectedRows.clear();</span>
<span class="line-added">291 			}</span>
<span class="line-added">292 		} else {</span>
<span class="line-added">293 			List&lt;IRenderedRow&gt; subdivision = row.getNestedRows();</span>
<span class="line-added">294 			if (subdivision.isEmpty()) {</span>
<span class="line-added">295 				dimRect(context, 0, axisWidth, row.getHeight());</span>
<span class="line-added">296 			} else {</span>
<span class="line-added">297 				for (IRenderedRow nestedRow : row.getNestedRows()) {</span>
<span class="line-added">298 					renderSelectionText(context, nestedRow);</span>
<span class="line-added">299 				}</span>
<span class="line-added">300 				return;</span>
<span class="line-added">301 			}</span>
<span class="line-added">302 		}</span>
<span class="line-added">303 		context.translate(0, row.getHeight());</span>
<span class="line-added">304 	}</span>
<span class="line-added">305 </span>
<span class="line-added">306 	private void renderSelectionChart(Graphics2D context, IRenderedRow row) {</span>
307 		if (selectedRows.contains(row.getPayload())) {
308 			renderSelection(context, xBucketRange, row.getHeight());
309 		} else {
310 			List&lt;IRenderedRow&gt; subdivision = row.getNestedRows();
311 			if (subdivision.isEmpty()) {
312 				dimRect(context, 0, axisWidth, row.getHeight());
313 			} else {
314 				for (IRenderedRow nestedRow : row.getNestedRows()) {
<a name="24" id="anc24"></a><span class="line-modified">315 					renderSelectionChart(context, nestedRow);</span>
316 				}
317 				return;
318 			}
319 		}
320 		context.translate(0, row.getHeight());
321 	}
322 
<a name="25" id="anc25"></a><span class="line-added">323 	// Paint the background of every-other row in a slightly different shade</span>
<span class="line-added">324 	// to better differentiate the thread lanes from one another</span>
<span class="line-added">325 	private void paintRowBackground(Graphics2D context, int height) {</span>
<span class="line-added">326 		if (rowColorCounter &gt;= 0) {</span>
<span class="line-added">327 			if (rowColorCounter % 2 == 0) {</span>
<span class="line-added">328 				context.setColor(Palette.PF_BLACK_100.getAWTColor());</span>
<span class="line-added">329 			} else {</span>
<span class="line-added">330 				context.setColor(Palette.PF_BLACK_200.getAWTColor());</span>
<span class="line-added">331 			}</span>
<span class="line-added">332 			context.fillRect(0, 0, axisWidth, height);</span>
<span class="line-added">333 			rowColorCounter++;</span>
<span class="line-added">334 		}</span>
<span class="line-added">335 	}</span>
<span class="line-added">336 </span>
337 	private void renderText(Graphics2D context, IRenderedRow row) {
338 		String text = row.getName();
339 		int height = row.getHeight();
340 		if (height &gt;= context.getFontMetrics().getHeight()) {
341 			if (text != null) {
<a name="26" id="anc26"></a><span class="line-added">342 				paintRowBackground(context, row.getHeight());</span>
343 				context.setColor(Color.BLACK);
<a name="27" id="anc27"></a><span class="line-modified">344 				context.drawLine(0, height - 1, axisWidth - 15, height - 1);</span>
<span class="line-modified">345 				int y = ((height - context.getFontMetrics().getHeight()) / 2) + context.getFontMetrics().getAscent();</span>






346 				int charsWidth = context.getFontMetrics().charsWidth(text.toCharArray(), 0, text.length());
<a name="28" id="anc28"></a><span class="line-modified">347 				if (charsWidth &gt; longestCharWidth) {</span>
<span class="line-added">348 					longestCharWidth = charsWidth;</span>
<span class="line-added">349 				}</span>
<span class="line-added">350 				if (xOffset &gt; 0 &amp;&amp; charsWidth &gt; xOffset) {</span>
351 					float fitRatio = ((float) xOffset) / (charsWidth
352 							+ context.getFontMetrics().charsWidth(ELLIPSIS.toCharArray(), 0, ELLIPSIS.length()));
353 					text = text.substring(0, ((int) (text.length() * fitRatio)) - 1) + ELLIPSIS;
354 				}
<a name="29" id="anc29"></a><span class="line-modified">355 				context.drawString(text, 2, y);</span>
356 			} else {
357 				List&lt;IRenderedRow&gt; subdivision = row.getNestedRows();
358 				if (!subdivision.isEmpty()) {
359 					for (IRenderedRow nestedRow : row.getNestedRows()) {
360 						renderText(context, nestedRow);
361 					}
362 					return;
363 				}
364 			}
365 		}
366 		context.translate(0, height);
367 	}
368 
<a name="30" id="anc30"></a><span class="line-added">369 	/**</span>
<span class="line-added">370 	 * Get the longest character width of a thread name to be rendered</span>
<span class="line-added">371 	 * </span>
<span class="line-added">372 	 * @return the character width of longest thread name</span>
<span class="line-added">373 	 */</span>
<span class="line-added">374 	public int getLongestCharWidth() {</span>
<span class="line-added">375 		return longestCharWidth;</span>
<span class="line-added">376 	}</span>
<span class="line-added">377 </span>
378 	/**
379 	 * Pan the view.
380 	 *
381 	 * @param rightPercent
382 	 * @return true if the bounds changed. That is, if a redraw is required.
383 	 */
384 	public boolean pan(int rightPercent) {
<a name="31" id="anc31"></a><span class="line-added">385 		if (rangeDuration != null) {</span>
<span class="line-added">386 			return panRange(Integer.signum(rightPercent));</span>
<span class="line-added">387 		}</span>
388 		if (xBucketRange != null) {
389 			IQuantity oldStart = currentStart;
390 			IQuantity oldEnd = currentEnd;
391 			if (rightPercent &gt; 0) {
392 				currentEnd = QuantitiesToolkit
393 						.min(xBucketRange.getQuantityAtPixel(axisWidth + axisWidth * rightPercent / 100), end);
394 				currentStart = QuantitiesToolkit
395 						.max(xBucketRange.getQuantityAtPixel(xBucketRange.getPixel(currentEnd) - axisWidth), start);
396 			} else if (rightPercent &lt; 0) {
397 				currentStart = QuantitiesToolkit.max(xBucketRange.getQuantityAtPixel(axisWidth * rightPercent / 100),
398 						start);
399 				currentEnd = QuantitiesToolkit
400 						.min(xBucketRange.getQuantityAtPixel(xBucketRange.getPixel(currentStart) + axisWidth), end);
401 			}
402 			return (currentStart.compareTo(oldStart) != 0) || (currentEnd.compareTo(oldEnd) != 0);
403 		}
404 		// Return true since a redraw forces creation of xBucketRange.
405 		return true;
406 	}
407 
<a name="32" id="anc32"></a><span class="line-added">408 	/**</span>
<span class="line-added">409 	 * Pan the view at a rate relative the current zoom level.</span>
<span class="line-added">410 	 * </span>
<span class="line-added">411 	 * @param panDirection</span>
<span class="line-added">412 	 *            -1 to pan left, 1 to pan right</span>
<span class="line-added">413 	 * @return true if the chart needs to be redrawn</span>
<span class="line-added">414 	 */</span>
<span class="line-added">415 	public boolean panRange(int panDirection) {</span>
<span class="line-added">416 		if (zoomSteps == 0 || panDirection == 0 || (currentStart.compareTo(start) == 0 &amp;&amp; panDirection == -1)</span>
<span class="line-added">417 				|| (currentEnd.compareTo(end) == 0 &amp;&amp; panDirection == 1)) {</span>
<span class="line-added">418 			return false;</span>
<span class="line-added">419 		}</span>
<span class="line-added">420 </span>
<span class="line-added">421 		IQuantity panDiff = rangeDuration.multiply(panDirection * zoomPanPower);</span>
<span class="line-added">422 		IQuantity newStart = currentStart.in(UnitLookup.EPOCH_NS).add(panDiff);</span>
<span class="line-added">423 		IQuantity newEnd = currentEnd.in(UnitLookup.EPOCH_NS).add(panDiff);</span>
<span class="line-added">424 </span>
<span class="line-added">425 		// if panning would flow over the recording range start or end time,</span>
<span class="line-added">426 		// calculate the difference and add it so the other side.</span>
<span class="line-added">427 		if (newStart.compareTo(start) &lt; 0) {</span>
<span class="line-added">428 			IQuantity diff = start.subtract(newStart);</span>
<span class="line-added">429 			newStart = start;</span>
<span class="line-added">430 			newEnd = newEnd.add(diff);</span>
<span class="line-added">431 		} else if (newEnd.compareTo(end) &gt; 0) {</span>
<span class="line-added">432 			IQuantity diff = newEnd.subtract(end);</span>
<span class="line-added">433 			newStart = newStart.add(diff);</span>
<span class="line-added">434 			newEnd = end;</span>
<span class="line-added">435 		}</span>
<span class="line-added">436 		currentStart = newStart;</span>
<span class="line-added">437 		currentEnd = newEnd;</span>
<span class="line-added">438 		controlBar.setStartTime(currentStart);</span>
<span class="line-added">439 		controlBar.setEndTime(currentEnd);</span>
<span class="line-added">440 		isZoomCalculated = true;</span>
<span class="line-added">441 		return true;</span>
<span class="line-added">442 	}</span>
<span class="line-added">443 </span>
444 	/**
445 	 * Zoom the view.
446 	 *
447 	 * @param zoomInSteps
448 	 * @return true if the bounds changed. That is, if a redraw is required.
449 	 */
450 	public boolean zoom(int zoomInSteps) {
<a name="33" id="anc33"></a><span class="line-added">451 		if (rangeDuration != null) {</span>
<span class="line-added">452 			return zoomRange(zoomInSteps);</span>
<span class="line-added">453 		}</span>
454 		return zoomXAxis(axisWidth / 2, zoomInSteps);
455 	}
456 
457 	/**
458 	 * Zoom the view.
459 	 *
460 	 * @param x
461 	 * @param zoomInSteps
462 	 * @return true if the bounds changed. That is, if a redraw is required.
463 	 */
464 	public boolean zoom(int x, int zoomInSteps) {
465 		return zoomXAxis(x - xOffset, zoomInSteps);
466 	}
467 
<a name="34" id="anc34"></a><span class="line-added">468 	// Default zoom mechanics</span>
469 	private boolean zoomXAxis(int x, int zoomInSteps) {
470 		if (xBucketRange == null) {
471 			// Return true since a redraw forces creation of xBucketRange.
472 			return true;
473 		}
474 		if ((x &gt; 0) &amp;&amp; (x &lt; axisWidth)) {
475 			IQuantity oldStart = currentStart;
476 			IQuantity oldEnd = currentEnd;
477 			// Absolute value of zoomFactor must be less than 1. Currently it ranges between -0.5 and 0.5.
478 			double zoomFactor = Math.atan(zoomInSteps) / Math.PI;
479 			int newStart = (int) (zoomFactor * x);
480 			int newEnd = (int) (axisWidth * (1 - zoomFactor)) + newStart;
481 			SubdividedQuantityRange xAxis = new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, 1);
482 			setVisibleRange(xAxis.getQuantityAtPixel(newStart), xAxis.getQuantityAtPixel(newEnd));
483 			return (currentStart.compareTo(oldStart) != 0) || (currentEnd.compareTo(oldEnd) != 0);
484 		}
485 		return false;
486 	}
487 
<a name="35" id="anc35"></a><span class="line-added">488 	/**</span>
<span class="line-added">489 	 * Zoom to a specific step count</span>
<span class="line-added">490 	 * </span>
<span class="line-added">491 	 * @param zoomToStep</span>
<span class="line-added">492 	 *            the desired end zoom step amount</span>
<span class="line-added">493 	 * @return true if a redraw is required as a result of a successful zoom</span>
<span class="line-added">494 	 */</span>
<span class="line-added">495 	public boolean zoomToStep(int zoomToStep) {</span>
<span class="line-added">496 		if (zoomToStep == 0) {</span>
<span class="line-added">497 			resetTimeline();</span>
<span class="line-added">498 			return true;</span>
<span class="line-added">499 		} else {</span>
<span class="line-added">500 			return zoomRange(zoomToStep - zoomSteps);</span>
<span class="line-added">501 		}</span>
<span class="line-added">502 	}</span>
<span class="line-added">503 </span>
<span class="line-added">504 	/**</span>
<span class="line-added">505 	 * Zoom based on a percentage of the recording range</span>
<span class="line-added">506 	 * </span>
<span class="line-added">507 	 * @param zoomInSteps</span>
<span class="line-added">508 	 *            the amount of desired steps to take</span>
<span class="line-added">509 	 * @return true if a redraw is required as a result of a successful zoom</span>
<span class="line-added">510 	 */</span>
<span class="line-added">511 	private boolean zoomRange(int steps) {</span>
<span class="line-added">512 		if (steps == 0) {</span>
<span class="line-added">513 			return false;</span>
<span class="line-added">514 		} else if (steps &gt; 0) {</span>
<span class="line-added">515 			zoomIn(steps);</span>
<span class="line-added">516 		} else {</span>
<span class="line-added">517 			zoomOut(steps);</span>
<span class="line-added">518 		}</span>
<span class="line-added">519 		return true;</span>
<span class="line-added">520 	}</span>
<span class="line-added">521 </span>
<span class="line-added">522 	/**</span>
<span class="line-added">523 	 * Zoom into the chart at a rate of 5% of the overall recording range at each step. If the chart</span>
<span class="line-added">524 	 * is zoomed in far enough such that one more step at 5% is not possible, the zoom power is</span>
<span class="line-added">525 	 * halved and the zoom will proceed. &lt;br&gt;</span>
<span class="line-added">526 	 * Every time the zoom power is halved, the instigating step value is pushed onto the</span>
<span class="line-added">527 	 * modifiedSteps stack. This stack is consulted on zoom out events in order to ensure the chart</span>
<span class="line-added">528 	 * zooms out the same way it was zoomed in.</span>
<span class="line-added">529 	 */</span>
<span class="line-added">530 	private void zoomIn(int steps) {</span>
<span class="line-added">531 		do {</span>
<span class="line-added">532 			IQuantity zoomDiff = rangeDuration.multiply(zoomPanPower);</span>
<span class="line-added">533 			IQuantity newStart = currentStart.in(UnitLookup.EPOCH_NS).add(zoomDiff);</span>
<span class="line-added">534 			IQuantity newEnd = currentEnd.in(UnitLookup.EPOCH_NS).subtract(zoomDiff);</span>
<span class="line-added">535 			if (newStart.compareTo(newEnd) &gt;= 0) { // adjust the zoom factor</span>
<span class="line-added">536 				if (modifiedSteps == null) {</span>
<span class="line-added">537 					modifiedSteps = new Stack&lt;Integer&gt;();</span>
<span class="line-added">538 				}</span>
<span class="line-added">539 				modifiedSteps.push(zoomSteps);</span>
<span class="line-added">540 				zoomPanPower = zoomPanPower / ZOOM_PAN_MODIFIER;</span>
<span class="line-added">541 				zoomDiff = rangeDuration.multiply(zoomPanPower);</span>
<span class="line-added">542 				newStart = currentStart.in(UnitLookup.EPOCH_NS).add(zoomDiff);</span>
<span class="line-added">543 				newEnd = currentEnd.in(UnitLookup.EPOCH_NS).subtract(zoomDiff);</span>
<span class="line-added">544 			}</span>
<span class="line-added">545 			currentZoom = currentZoom + (zoomPanPower * ZOOM_PAN_MODIFIER * 100);</span>
<span class="line-added">546 			isZoomCalculated = true;</span>
<span class="line-added">547 			zoomSteps++;</span>
<span class="line-added">548 			setVisibleRange(newStart, newEnd);</span>
<span class="line-added">549 			steps--;</span>
<span class="line-added">550 		} while (steps &gt; 0);</span>
<span class="line-added">551 	}</span>
<span class="line-added">552 </span>
<span class="line-added">553 	/**</span>
<span class="line-added">554 	 * Zoom out of the chart at a rate equal to the how the chart was zoomed in.</span>
<span class="line-added">555 	 */</span>
<span class="line-added">556 	private void zoomOut(int steps) {</span>
<span class="line-added">557 		do {</span>
<span class="line-added">558 			if (modifiedSteps != null &amp;&amp; modifiedSteps.size() &gt; 0 &amp;&amp; modifiedSteps.peek() == zoomSteps) {</span>
<span class="line-added">559 				modifiedSteps.pop();</span>
<span class="line-added">560 				zoomPanPower = zoomPanPower * ZOOM_PAN_MODIFIER;</span>
<span class="line-added">561 			}</span>
<span class="line-added">562 			IQuantity zoomDiff = rangeDuration.multiply(zoomPanPower);</span>
<span class="line-added">563 			IQuantity newStart = currentStart.in(UnitLookup.EPOCH_NS).subtract(zoomDiff);</span>
<span class="line-added">564 			IQuantity newEnd = currentEnd.in(UnitLookup.EPOCH_NS).add(zoomDiff);</span>
<span class="line-added">565 </span>
<span class="line-added">566 			// if zooming out would flow over the recording range start or end time,</span>
<span class="line-added">567 			// calculate the difference and add it to the other side.</span>
<span class="line-added">568 			if (newStart.compareTo(start) &lt; 0) {</span>
<span class="line-added">569 				IQuantity diff = start.subtract(newStart);</span>
<span class="line-added">570 				newStart = start;</span>
<span class="line-added">571 				newEnd = newEnd.add(diff);</span>
<span class="line-added">572 			} else if (newEnd.compareTo(end) &gt; 0) {</span>
<span class="line-added">573 				IQuantity diff = newEnd.subtract(end);</span>
<span class="line-added">574 				newStart = newStart.subtract(diff);</span>
<span class="line-added">575 				newEnd = end;</span>
<span class="line-added">576 			}</span>
<span class="line-added">577 			currentZoom = currentZoom - (zoomPanPower * ZOOM_PAN_MODIFIER * 100);</span>
<span class="line-added">578 			if (currentZoom &lt; BASE_ZOOM_LEVEL) {</span>
<span class="line-added">579 				currentZoom = BASE_ZOOM_LEVEL;</span>
<span class="line-added">580 			}</span>
<span class="line-added">581 			isZoomCalculated = true;</span>
<span class="line-added">582 			zoomSteps--;</span>
<span class="line-added">583 			setVisibleRange(newStart, newEnd);</span>
<span class="line-added">584 			steps++;</span>
<span class="line-added">585 		} while (steps &lt; 0);</span>
<span class="line-added">586 	}</span>
<span class="line-added">587 </span>
<span class="line-added">588 	// need to check from ChartAndPopupTableUI if not using the OG start/end position,</span>
<span class="line-added">589 	// will have to calculate the new zoom level</span>
<span class="line-added">590 	public void resetZoomFactor() {</span>
<span class="line-added">591 		zoomSteps = 0;</span>
<span class="line-added">592 		zoomPanPower = ZOOM_PAN_FACTOR / ZOOM_PAN_MODIFIER;</span>
<span class="line-added">593 		currentZoom = BASE_ZOOM_LEVEL;</span>
<span class="line-added">594 		modifiedSteps = new Stack&lt;Integer&gt;();</span>
<span class="line-added">595 	}</span>
<span class="line-added">596 </span>
<span class="line-added">597 	/**</span>
<span class="line-added">598 	 * Reset the visible range to be the recording range, and reset the zoom-related objects</span>
<span class="line-added">599 	 */</span>
<span class="line-added">600 	public void resetTimeline() {</span>
<span class="line-added">601 		resetZoomFactor();</span>
<span class="line-added">602 		setVisibleRange(start, end);</span>
<span class="line-added">603 	}</span>
<span class="line-added">604 </span>
<span class="line-added">605 	private void selectionZoom(IQuantity newStart, IQuantity newEnd) {</span>
<span class="line-added">606 		double percentage = calculateZoom(newStart, newEnd);</span>
<span class="line-added">607 		zoomSteps = calculateZoomSteps(percentage);</span>
<span class="line-added">608 		currentZoom = BASE_ZOOM_LEVEL + (percentage * 100);</span>
<span class="line-added">609 	}</span>
<span class="line-added">610 </span>
<span class="line-added">611 	/**</span>
<span class="line-added">612 	 * When a drag-select zoom occurs, use the new range value to determine how many steps have been</span>
<span class="line-added">613 	 * taken, and adjust zoomSteps and zoomPower accordingly</span>
<span class="line-added">614 	 */</span>
<span class="line-added">615 	private double calculateZoom(IQuantity newStart, IQuantity newEnd) {</span>
<span class="line-added">616 		// calculate the new visible range, and it&#39;s percentage of the total range</span>
<span class="line-added">617 		IQuantity newRange = newEnd.in(UnitLookup.EPOCH_NS).subtract(newStart.in(UnitLookup.EPOCH_NS));</span>
<span class="line-added">618 		return 1 - (newRange.longValue() / (double) rangeDuration.in(UnitLookup.NANOSECOND).longValue());</span>
<span class="line-added">619 	}</span>
<span class="line-added">620 </span>
<span class="line-added">621 	/**</span>
<span class="line-added">622 	 * Calculate the number of steps required to achieve the passed zoom percentage</span>
<span class="line-added">623 	 */</span>
<span class="line-added">624 	private int calculateZoomSteps(double percentage) {</span>
<span class="line-added">625 		int steps = (int) Math.floor(percentage / ZOOM_PAN_FACTOR);</span>
<span class="line-added">626 		double tempPercent = steps * ZOOM_PAN_FACTOR;</span>
<span class="line-added">627 </span>
<span class="line-added">628 		if (tempPercent &lt; percentage) {</span>
<span class="line-added">629 			if (percentage &gt; 1 - ZOOM_PAN_FACTOR) {</span>
<span class="line-added">630 				double factor = ZOOM_PAN_FACTOR;</span>
<span class="line-added">631 				do {</span>
<span class="line-added">632 					factor = factor / ZOOM_PAN_MODIFIER;</span>
<span class="line-added">633 					tempPercent = tempPercent + factor;</span>
<span class="line-added">634 					if (modifiedSteps == null) {</span>
<span class="line-added">635 						modifiedSteps = new Stack&lt;Integer&gt;();</span>
<span class="line-added">636 					}</span>
<span class="line-added">637 					if (modifiedSteps.size() == 0 || modifiedSteps.peek() &lt; steps) {</span>
<span class="line-added">638 						modifiedSteps.push(steps);</span>
<span class="line-added">639 					}</span>
<span class="line-added">640 					steps++;</span>
<span class="line-added">641 				} while (tempPercent &lt;= percentage);</span>
<span class="line-added">642 				zoomPanPower = factor / ZOOM_PAN_MODIFIER;</span>
<span class="line-added">643 			} else {</span>
<span class="line-added">644 				steps++;</span>
<span class="line-added">645 			}</span>
<span class="line-added">646 		}</span>
<span class="line-added">647 		return steps;</span>
<span class="line-added">648 	}</span>
<span class="line-added">649 </span>
<span class="line-added">650 	private boolean isZoomCalculated;</span>
<span class="line-added">651 	private boolean isZoomPanDrag;</span>
<span class="line-added">652 </span>
<span class="line-added">653 	public void setIsZoomPanDrag(boolean isZoomPanDrag) {</span>
<span class="line-added">654 		this.isZoomPanDrag = isZoomPanDrag;</span>
<span class="line-added">655 	}</span>
<span class="line-added">656 </span>
<span class="line-added">657 	private boolean getIsZoomPanDrag() {</span>
<span class="line-added">658 		return isZoomPanDrag;</span>
<span class="line-added">659 	}</span>
<span class="line-added">660 </span>
661 	public void setVisibleRange(IQuantity rangeStart, IQuantity rangeEnd) {
<a name="36" id="anc36"></a><span class="line-added">662 		if (rangeDuration != null &amp;&amp; !isZoomCalculated &amp;&amp; !getIsZoomPanDrag()) {</span>
<span class="line-added">663 			selectionZoom(rangeStart, rangeEnd);</span>
<span class="line-added">664 		}</span>
<span class="line-added">665 		isZoomCalculated = false;</span>
666 		rangeStart = QuantitiesToolkit.max(rangeStart, start);
667 		rangeEnd = QuantitiesToolkit.min(rangeEnd, end);
668 		if (rangeStart.compareTo(rangeEnd) &lt; 0) {
669 			SubdividedQuantityRange testRange = new SubdividedQuantityRange(rangeStart, rangeEnd, 10000, 1);
670 			if (testRange.getQuantityAtPixel(0).compareTo(testRange.getQuantityAtPixel(1)) &lt; 0) {
671 				currentStart = rangeStart;
672 				currentEnd = rangeEnd;
673 			} else {
674 				// Ensures that zoom out is always allowed
675 				currentStart = QuantitiesToolkit.min(rangeStart, currentStart);
676 				currentEnd = QuantitiesToolkit.max(rangeEnd, currentEnd);
677 			}
<a name="37" id="anc37"></a><span class="line-added">678 			if (controlBar != null) {</span>
<span class="line-added">679 				controlBar.setStartTime(currentStart);</span>
<span class="line-added">680 				controlBar.setEndTime(currentEnd);</span>
<span class="line-added">681 			}</span>
682 			rangeListeners.stream().forEach(l -&gt; l.accept(getVisibleRange()));
683 		}
684 	}
685 
686 	private List&lt;Consumer&lt;IRange&lt;IQuantity&gt;&gt;&gt; rangeListeners = new ArrayList&lt;&gt;();
687 
688 	public void addVisibleRangeListener(Consumer&lt;IRange&lt;IQuantity&gt;&gt; rangeListener) {
689 		rangeListeners.add(rangeListener);
690 	}
691 
692 	public IRange&lt;IQuantity&gt; getVisibleRange() {
693 		return (currentStart != null) &amp;&amp; (currentEnd != null) ? QuantityRange.createWithEnd(currentStart, currentEnd)
694 				: null;
695 	}
696 
697 	public void clearVisibleRange() {
698 		currentStart = start;
699 		currentEnd = end;
700 	}
701 
<a name="38" id="anc38"></a><span class="line-modified">702 	public boolean select(int x1, int x2, int y1, int y2, boolean clear) {</span>
<span class="line-modified">703 		int xStart = Math.min(x1, x2);</span>
<span class="line-modified">704 		int xEnd = Math.max(x1, x2);</span>
705 
<a name="39" id="anc39"></a><span class="line-modified">706 		if (xBucketRange != null &amp;&amp; (xEnd != xStart) &amp;&amp; xEnd - xOffset &gt;= 0) {</span>
<span class="line-modified">707 			return select(xBucketRange.getQuantityAtPixel(Math.max(0, xStart - xOffset)),</span>
<span class="line-modified">708 					xBucketRange.getQuantityAtPixel(xEnd - xOffset), y1, y2, clear);</span>
709 		} else {
<a name="40" id="anc40"></a><span class="line-modified">710 			return select(null, null, y1, y2, clear);</span>
711 		}
712 	}
713 
<a name="41" id="anc41"></a><span class="line-modified">714 	public boolean select(IQuantity xStart, IQuantity xEnd, int y1, int y2, boolean clear) {</span>
715 		if (xStart != null &amp;&amp; xStart.compareTo(start) &lt; 0) {
716 			xStart = start;
717 		}
718 		if (xEnd != null &amp;&amp; xEnd.compareTo(end) &gt; 0) {
719 			xEnd = end;
720 		}
721 		Set&lt;Object&gt; oldRows = null;
722 		if (QuantitiesToolkit.same(selectionStart, xStart) &amp;&amp; QuantitiesToolkit.same(selectionEnd, xEnd)) {
723 			oldRows = new HashSet&lt;&gt;(selectedRows);
724 		}
<a name="42" id="anc42"></a><span class="line-modified">725 		if (clear) {</span>
<span class="line-added">726 			selectedRows.clear();</span>
<span class="line-added">727 		}</span>
728 		addSelectedRows(rendererResult, 0, Math.min(y1, y2), Math.max(y1, y2));
729 		selectionStart = xStart;
730 		selectionEnd = xEnd;
731 		return (oldRows == null) || !oldRows.equals(selectedRows);
732 	}
733 
734 	public boolean clearSelection() {
735 		if ((selectionStart == null) &amp;&amp; (selectionEnd == null) &amp;&amp; selectedRows.isEmpty()) {
736 			return false;
737 		}
738 		selectedRows.clear();
739 		selectionStart = selectionEnd = null;
740 		return true;
741 	}
742 
743 	private boolean addSelectedRows(IRenderedRow row, int yRowStart, int ySelectionStart, int ySelectionEnd) {
744 		List&lt;IRenderedRow&gt; subdivision = row.getNestedRows();
745 		if (subdivision.isEmpty()) {
746 			return addPayload(row);
747 		} else {
748 			boolean nestedHasPayload = false;
749 			for (IRenderedRow nestedRow : row.getNestedRows()) {
750 				int yRowEnd = yRowStart + nestedRow.getHeight();
751 				if (yRowStart &gt; ySelectionEnd) {
752 					break;
753 				} else if (yRowEnd &gt; ySelectionStart) {
754 					nestedHasPayload |= addSelectedRows(nestedRow, yRowStart, ySelectionStart, ySelectionEnd);
755 				}
756 				yRowStart = yRowEnd;
757 			}
758 			return nestedHasPayload || addPayload(row);
759 		}
760 	}
761 
762 	private boolean addPayload(IRenderedRow row) {
763 		Object payload = row.getPayload();
764 		if (payload != null) {
<a name="43" id="anc43"></a><span class="line-modified">765 			if (selectedRows.contains(payload)) { // ctrl+click deselection</span>
<span class="line-added">766 				selectedRows.remove(payload);</span>
<span class="line-added">767 			} else {</span>
<span class="line-added">768 				selectedRows.add(payload);</span>
<span class="line-added">769 			}</span>
770 			return true;
771 		}
772 		return false;
773 	}
774 
775 	private void renderSelection(Graphics2D context, SubdividedQuantityRange xRange, int height) {
776 		int selFrom = 0;
777 		int selTo = axisWidth;
778 		if (selectionStart != null &amp;&amp; selectionEnd != null) {
779 			selFrom = (int) xRange.getPixel(selectionStart);
780 			// Removed &quot;+ 1&quot; for now to make the selection symmetrical with respect to chart highlights.
781 			selTo = (int) xRange.getPixel(selectionEnd);
782 		}
783 		// FIXME: Would like to show selection by graying out the other parts, can we do that?
784 //		if (selWidth &gt; 0) {
785 //			context.setColor(Color.WHITE);
786 //			context.setXORMode(Color.BLACK);
787 //			Stroke oldStroke = context.getStroke();
788 //			context.setStroke(SELECTION_STROKE);
789 //			context.drawRect(selFrom, 0, selWidth, height);
790 //			context.setStroke(oldStroke);
791 //			context.setPaintMode();
792 //		}
793 		if (selFrom &gt; 0) {
794 			dimRect(context, 0, selFrom, height);
795 			context.setColor(Color.BLACK);
796 			context.drawLine(selFrom, 0, selFrom, height);
797 		}
798 		if (selTo &lt; axisWidth) {
799 			dimRect(context, selTo, axisWidth - selTo, height);
800 			context.setColor(Color.BLACK);
801 			context.drawLine(selTo, 0, selTo, height);
802 		}
803 	}
804 
805 	private static void dimRect(Graphics2D context, int from, int width, int height) {
806 		context.setColor(SELECTION_COLOR);
807 		context.fillRect(from, 0, width, height);
808 	}
809 
810 	/**
811 	 * Let the {@code visitor} visit the chart elements in the vicinity of {@code x} and {@code y}.
812 	 * The visitation should adhere to a basic front to back ordering, so that elements which
813 	 * &lt;em&gt;conceptually&lt;/em&gt; are at the front should be visited first. Note that this has no direct
814 	 * link to the drawing order. Also, this doesn&#39;t dictate any particular order between elements
815 	 * that conceptually are at the same level. (Good practice is to visit elements from different
816 	 * sub charts in a consistent order. If the sub charts have some kind of fixed ordering, such as
817 	 * stacked line charts, this order from top to bottom seems most appropriate.)
818 	 *
819 	 * @param visitor
820 	 * @param x
821 	 * @param y
822 	 */
823 	public void infoAt(IChartInfoVisitor visitor, int x, int y) {
824 		if (rendererResult == null) {
825 			return;
826 		}
827 		final int height = rendererResult.getHeight();
828 		if (y &lt; height) {
829 			rendererResult.infoAt(visitor, x - xOffset, y, new Point(xOffset, 0));
830 		} else {
831 			x -= xOffset;
832 			if (x &gt;= 0) {
833 				// Snap to closest of ticks and buckets (useful even if no bar charts are shown).
834 				int tickIndex = xTickRange.getClosestSubdividerAtPixel(x);
835 				double tickX = xTickRange.getSubdividerPixel(tickIndex);
836 				int bucketIndex = xBucketRange.getClosestSubdividerAtPixel(x);
837 				double bucketX = xBucketRange.getSubdividerPixel(bucketIndex);
838 				if (Math.abs(x - bucketX) &lt; Math.abs(x - tickX)) {
839 					visitor.visit(tickFor(xBucketRange, bucketIndex));
840 				} else {
841 					visitor.visit(tickFor(xTickRange, tickIndex));
842 				}
843 			}
844 		}
845 	}
846 
847 	private ITick tickFor(final SubdividedQuantityRange xRange, final int index) {
848 		return new ITick() {
849 			@Override
850 			public IDisplayable getValue() {
851 				return xRange.getSubdivider(index);
852 			}
853 
854 			@Override
855 			public Point2D getTarget() {
856 				return new Point(xOffset + (int) xRange.getSubdividerPixel(index), rendererResult.getHeight() - 1);
857 			}
858 		};
859 	}
860 }
<a name="44" id="anc44"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="44" type="hidden" />
</body>
</html>