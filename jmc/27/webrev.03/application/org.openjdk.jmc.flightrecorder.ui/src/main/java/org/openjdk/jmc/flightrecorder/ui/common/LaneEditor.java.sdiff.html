<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/LaneEditor.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FlavorSelector.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ThreadGraphLanes.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/LaneEditor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">  3  * </span>
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * The contents of this file are subject to the terms of either the Universal Permissive License
  7  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
  8  *
  9  * or the following license:
 10  *
 11  * Redistribution and use in source and binary forms, with or without modification, are permitted
 12  * provided that the following conditions are met:
 13  * 
 14  * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
 15  * and the following disclaimer.
 16  * 
 17  * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
 18  * conditions and the following disclaimer in the documentation and/or other materials provided with
 19  * the distribution.
 20  * 
 21  * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
 22  * endorse or promote products derived from this software without specific prior written permission.
 23  * 
</pre>
<hr />
<pre>
 86 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
 87 import org.openjdk.jmc.ui.misc.ActionUiToolkit;
 88 import org.openjdk.jmc.ui.misc.CompositeToolkit;
 89 import org.openjdk.jmc.ui.misc.DialogToolkit;
 90 import org.openjdk.jmc.ui.misc.SWTColorToolkit;
 91 import org.openjdk.jmc.ui.wizards.IPerformFinishable;
 92 import org.openjdk.jmc.ui.wizards.OnePageWizardDialog;
 93 
 94 public class LaneEditor {
 95 
 96 	private static final IItemFilter TYPE_HAS_THREAD_AND_DURATION = new IItemFilter() {
 97 		@Override
 98 		public IPredicate&lt;IItem&gt; getPredicate(IType&lt;IItem&gt; type) {
 99 			if (DataPageToolkit.isTypeWithThreadAndDuration(type)) {
100 				return PredicateToolkit.truePredicate();
101 			}
102 			return PredicateToolkit.falsePredicate();
103 		}
104 	};
105 
<span class="line-modified">106 	private static class EditLanesWizardPage extends WizardPage implements IPerformFinishable {</span>



107 
<span class="line-removed">108 		private final EventTypeFolderNode root;</span>
<span class="line-removed">109 		private final List&lt;LaneDefinition&gt; lanes;</span>
110 		private LaneDefinition restLane;
111 		private TypeFilterBuilder filterEditor;
112 		private CheckboxTableViewer lanesViewer;
113 		private Object selected;


114 
<span class="line-modified">115 		private EditLanesWizardPage(EventTypeFolderNode root, Collection&lt;LaneDefinition&gt; lanesInput) {</span>
<span class="line-modified">116 			super(&quot;EditFilterLanesPage&quot;); //$NON-NLS-1$</span>




117 			this.root = root;
<span class="line-modified">118 			this.lanes = new ArrayList&lt;&gt;(lanesInput);</span>

119 			restLane = ensureRestLane(lanes);

120 		}
121 
<span class="line-modified">122 		@Override</span>
<span class="line-modified">123 		public void createControl(Composite parent) {</span>



124 			// FIXME: Do we want to group under categories somehow, or just hide the filters that don&#39;t have any existing event types.
<span class="line-modified">125 			Composite container = new Composite(parent, SWT.NONE);</span>
<span class="line-removed">126 			container.setLayout(GridLayoutFactory.swtDefaults().numColumns(2).create());</span>
127 
<span class="line-modified">128 			Composite laneHeaderContainer = new Composite(container, SWT.NONE);</span>
129 			laneHeaderContainer.setLayout(GridLayoutFactory.swtDefaults().create());
130 			laneHeaderContainer.setLayoutData(GridDataFactory.fillDefaults().create());
131 
132 			// FIXME: Add a duplicate action?
133 			IAction moveUpAction = ActionToolkit.action(() -&gt; moveSelected(true), Messages.LANES_MOVE_UP_ACTION,
134 					UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_NAV_UP));
135 			IAction moveDownAction = ActionToolkit.action(() -&gt; moveSelected(false), Messages.LANES_MOVE_DOWN_ACTION,
136 					UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_NAV_DOWN));
137 			IAction addAction = ActionToolkit.action(this::addLane, Messages.LANES_ADD_LANE_ACTION,
138 					UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_ADD));
139 			IAction removeAction = ActionToolkit.commandAction(this::deleteSelected,
140 					IWorkbenchCommandConstants.EDIT_DELETE);
141 			Control toolbar = ActionUiToolkit.buildToolBar(laneHeaderContainer,
142 					Stream.of(moveUpAction, moveDownAction, addAction, removeAction), false);
143 			toolbar.setLayoutData(GridDataFactory.fillDefaults().create());
144 
145 			Label lanesTitle = new Label(laneHeaderContainer, SWT.NONE);
146 			lanesTitle.setText(Messages.LANES_EDITOR_LABEL);
147 			lanesTitle.setLayoutData(GridDataFactory.fillDefaults().create());
<span class="line-modified">148 			Label filterTitle = new Label(container, SWT.NONE);</span>
149 			filterTitle.setText(Messages.LANES_FILTER_LABEL);
150 			filterTitle.setLayoutData(
151 					GridDataFactory.fillDefaults().grab(true, false).align(SWT.BEGINNING, SWT.END).create());
152 
<span class="line-modified">153 			lanesViewer = CheckboxTableViewer.newCheckList(container, SWT.BORDER | SWT.V_SCROLL);</span>
154 			TableViewerColumn viewerColumn = new TableViewerColumn(lanesViewer, SWT.NONE);
155 			viewerColumn.getColumn().setText(Messages.LANES_LANE_COLUMN);
156 			viewerColumn.getColumn().setWidth(200);
157 			// FIXME: Would like to enable editing by some other means than single-clicking, but seems a bit tricky.
158 			viewerColumn.setEditingSupport(new EditingSupport(lanesViewer) {
159 
160 				private String currentName;
161 
162 				@Override
163 				protected void setValue(Object element, Object value) {
164 					String newName = value.toString();
165 					if (currentName != null &amp;&amp; currentName.equals(newName)) {
166 						return;
167 					}
168 					LaneDefinition oldLd = (LaneDefinition) element;
169 					LaneDefinition newLane = new LaneDefinition(value.toString(), oldLd.enabled, oldLd.filter,
170 							oldLd.isRestLane);
171 					int elementIndex = lanes.indexOf(element);
172 					lanes.set(elementIndex, newLane);
173 					lanesViewer.replace(newLane, elementIndex);
</pre>
<hr />
<pre>
254 					if (sb.length() &gt; 0) {
255 						sb.insert(0, &quot;&lt;form&gt;&quot;); //$NON-NLS-1$
256 						sb.append(&quot;&lt;/form&gt;&quot;); //$NON-NLS-1$
257 						formText.setText(sb.toString(), true, false);
258 					} else {
259 						formText.setText(Messages.LANES_CHECK_TO_INCLUDE, false, false);
260 					}
261 					return formText;
262 				}
263 			};
264 			lanesViewer.setInput(lanes);
265 			lanesViewer.setCheckedElements(lanes.stream().filter(ld -&gt; ld.isEnabled()).toArray());
266 			MCContextMenuManager mm = MCContextMenuManager.create(lanesViewer.getControl());
267 			mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, moveUpAction);
268 			mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, moveDownAction);
269 			// FIXME: Add icon
270 			mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, addAction);
271 
272 			mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, removeAction);
273 
<span class="line-modified">274 			filterEditor = new TypeFilterBuilder(container, this::onTypeFilterChange);</span>
275 			filterEditor.setInput(root);
276 			filterEditor.getControl().setLayoutData(GridDataFactory.fillDefaults().grab(true, true).create());

277 			lanesViewer.getControl().setLayoutData(GridDataFactory.fillDefaults().grab(false, true).create());
278 
279 			lanesViewer.addSelectionChangedListener(
280 					e -&gt; laneSelectionChanges(((IStructuredSelection) e.getSelection()).getFirstElement()));
281 			LaneDefinition firstLane = lanes.get(0);
282 			lanesViewer.setSelection(new StructuredSelection(firstLane));
<span class="line-removed">283 </span>
<span class="line-removed">284 			setControl(container);</span>
285 		}
286 
287 		private void addLane() {
288 			int selectIndex = Math.max(0, lanes.indexOf(selected));
289 			IItemFilter emptyFilter = ItemFilters.type(Collections.emptySet());
290 			LaneDefinition newEmpty = new LaneDefinition(null, false, emptyFilter, false);
291 			lanes.add(selectIndex + 1, newEmpty);
292 			lanesViewer.insert(newEmpty, selectIndex + 1);
293 			lanesViewer.setSelection(new StructuredSelection(newEmpty));
294 		}
295 
296 		private void onTypeFilterChange() {
297 			if (selected instanceof LaneDefinition) {
298 				LaneDefinition selectedLane = (LaneDefinition) selected;
299 				if (selectedLane.isRestLane()) {
300 					DialogToolkit.showWarningDialogAsync(lanesViewer.getControl().getDisplay(),
301 							Messages.LANES_EDIT_NOT_ALLOWED_WARNING,
302 							NLS.bind(Messages.LANES_EDIT_NOT_ALLOWED_WARNING_DESC, selectedLane.getName()));
303 					// FIXME: Can we refresh the filter editor to show that nothing has changed?
304 				}
305 			}
306 			lanesViewer.update(selected, null);



307 		}
308 
309 		private void deleteSelected() {
310 			// FIXME: It&#39;s currently not possible to delete the last lane
311 			int selectIndex = Math.max(0, lanes.indexOf(selected) - 1);
312 			if (selected instanceof LaneDefinition &amp;&amp; ((LaneDefinition) selected).isRestLane()) {
313 				lanes.remove(selected);
314 				lanesViewer.setSelection(new StructuredSelection(lanes.get(selectIndex)));
315 				lanesViewer.refresh();
316 			} else {
317 				DialogToolkit.showWarningDialogAsync(lanesViewer.getControl().getDisplay(),
318 						Messages.LANES_DELETE_NOT_ALLOWED_WARNING, NLS.bind(
319 								Messages.LANES_DELETE_NOT_ALLOWED_WARNING_DESC, ((LaneDefinition) selected).getName()));
320 			}
321 		}
322 
323 		private void moveSelected(boolean up) {
324 			int fromIndex = lanes.indexOf(selected);
325 			int toIndex = fromIndex + (up ? -1 : 1);
326 			if (fromIndex &gt;= 0 &amp;&amp; toIndex &gt;= 0 &amp;&amp; toIndex &lt; lanes.size()) {
327 				LaneDefinition removed = lanes.remove(fromIndex);
328 				lanes.add(toIndex, removed);
329 				lanesViewer.refresh();
330 			}
331 		}
332 
333 		private void laneSelectionChanges(Object newSelected) {
334 			int selectedIndex = lanes.indexOf(newSelected);
<span class="line-modified">335 			if (this.selected != newSelected) {</span>
<span class="line-modified">336 				saveFilter();</span>
<span class="line-modified">337 				this.selected = lanes.get(selectedIndex);</span>
<span class="line-modified">338 				if (selected instanceof LaneDefinition) {</span>
<span class="line-modified">339 					Types typesFilter;</span>
<span class="line-modified">340 					if (((LaneDefinition) selected).getFilter() instanceof Types) {</span>
<span class="line-modified">341 						typesFilter = ((Types) ((LaneDefinition) selected).getFilter());</span>
<span class="line-modified">342 					} else {</span>
<span class="line-modified">343 						typesFilter = (Types) ItemFilters.convertToTypes(((LaneDefinition) selected).getFilter(),</span>
<span class="line-modified">344 								filterEditor.getAllTypes());</span>






















345 					}
<span class="line-removed">346 					filterEditor.selectTypes(typesFilter.getTypes());</span>
347 				}
348 			}

349 		}
350 
351 		private void saveFilter() {
352 			int selectedIndex = lanes.indexOf(selected);



353 			if (selectedIndex &gt;= 0) {
354 				LaneDefinition ld = lanes.get(selectedIndex);
<span class="line-modified">355 				if (!ld.isRestLane()) {</span>
<span class="line-modified">356 					IItemFilter newFilter = ItemFilters</span>
<span class="line-modified">357 							.type(filterEditor.getCheckedTypeIds().collect(Collectors.toSet()));</span>
<span class="line-modified">358 					LaneDefinition newLd = new LaneDefinition(ld.name, lanesViewer.getChecked(ld), newFilter,</span>
<span class="line-modified">359 							ld.isRestLane);</span>
<span class="line-modified">360 					lanes.set(selectedIndex, newLd);</span>
<span class="line-modified">361 					lanesViewer.replace(newLd, selectedIndex);</span>
<span class="line-modified">362 					if (restLane != null) {</span>
<span class="line-modified">363 						LaneDefinition newRest = new LaneDefinition(restLane.name, restLane.enabled,</span>
<span class="line-modified">364 								getRestFilter(lanes), true);</span>
<span class="line-modified">365 						int restIndex = lanes.indexOf(restLane);</span>
<span class="line-modified">366 						lanes.set(restIndex, newRest);</span>
<span class="line-modified">367 						lanesViewer.replace(newRest, restIndex);</span>
<span class="line-modified">368 						restLane = newRest;</span>
<span class="line-removed">369 					}</span>
<span class="line-removed">370 					lanesViewer.refresh();</span>
371 				}

372 			}
373 		}























374 
375 		@Override
376 		public boolean performFinish() {
<span class="line-modified">377 			saveFilter();</span>
378 			for (int i = 0; i &lt; lanes.size(); i++) {
379 				LaneDefinition ld = lanes.get(i);
<span class="line-modified">380 				if (ld.isEnabled() != lanesViewer.getChecked(ld)) {</span>
<span class="line-modified">381 					lanes.set(i, new LaneDefinition(ld.name, lanesViewer.getChecked(ld), ld.filter, ld.isRestLane));</span>

382 				}
383 			}
384 			return true;
385 		}
386 	}
387 
388 	public static class LaneDefinition implements IDescribable, IStateful {
389 
390 		private static final String FILTER = &quot;filter&quot;; //$NON-NLS-1$
391 		private static final String NAME = &quot;name&quot;; //$NON-NLS-1$
392 		private static final String ENABLED = &quot;enabled&quot;; //$NON-NLS-1$
393 		private static final String IS_REST_LANE = &quot;isRestLane&quot;; //$NON-NLS-1$
394 
395 		private final String name;
396 		private final IItemFilter filter;
397 		private final boolean enabled;
398 		private final boolean isRestLane;
399 
400 		public LaneDefinition(String name, boolean enabled, IItemFilter filter, boolean isRestLane) {
401 			this.name = name;
</pre>
<hr />
<pre>
417 							: count &gt; 0 ? NLS.bind(Messages.LANES_DEFINITION_NAME, count) : Messages.LANES_EMPTY_LANE;
418 		}
419 
420 		@Override
421 		public String getDescription() {
422 			return NLS.bind(Messages.LANES_DEFINITION_DESC, getName());
423 		}
424 
425 		public IItemFilter getFilter() {
426 			return filter;
427 		}
428 
429 		public boolean isEnabled() {
430 			return enabled;
431 		}
432 
433 		public boolean isRestLane() {
434 			return isRestLane;
435 		}
436 




437 		@Override
438 		public void saveTo(IWritableState writableState) {
439 			writableState.putString(NAME, name);
440 			StateToolkit.writeBoolean(writableState, ENABLED, enabled);
441 			StateToolkit.writeBoolean(writableState, IS_REST_LANE, isRestLane);
442 			if (!isRestLane &amp;&amp; filter != null) {
443 				((PersistableItemFilter) filter).saveTo(writableState.createChild(FILTER));
444 			}
445 		}
446 
447 		public static LaneDefinition readFrom(IState memento) {
448 			String name = memento.getAttribute(NAME);
449 			boolean enabled = StateToolkit.readBoolean(memento, ENABLED, false);
450 			boolean isRestLane = StateToolkit.readBoolean(memento, IS_REST_LANE, false);
451 			IState filterState = memento.getChild(FILTER);
452 			IItemFilter filter;
453 			if (isRestLane) {
454 				filter = null;
455 			} else if (filterState != null) {
456 				filter = PersistableItemFilter.readFrom(filterState);
457 			} else {
458 				throw new UnsupportedOperationException(&quot;Null filter not allowed for thread lane: &quot; + name); //$NON-NLS-1$
459 			}
460 			// FIXME: Should probably warn if filter is not an instance of Types, and possibly handle other type filter variants as well, like TypeMatches.
461 			return new LaneDefinition(name, enabled, filter, isRestLane);
462 		}
463 
464 		@Override
465 		public String toString() {
466 			return getName() + &quot;(&quot; + enabled + &quot;)&quot;; //$NON-NLS-1$ //$NON-NLS-2$
467 		}
468 	}
469 
470 	public static List&lt;LaneDefinition&gt; openDialog(
471 		EventTypeFolderNode root, List&lt;LaneDefinition&gt; lanes, String title, String description) {
472 		EditLanesWizardPage page = new EditLanesWizardPage(root, lanes);
473 		page.setTitle(title);
474 		page.setDescription(description);
475 		if (OnePageWizardDialog.open(page, 500, 600) == Window.OK) {
<span class="line-modified">476 			return page.lanes.stream().filter(LaneEditor::laneIncludesTypes).collect(Collectors.toList());</span>
477 		}
478 		return lanes;
479 	}
480 
481 	private static boolean laneIncludesTypes(LaneDefinition ld) {
482 		return ld.isRestLane() || ld.getFilter() instanceof Types &amp;&amp; ((Types) ld.getFilter()).getTypes().size() &gt; 0;
483 	}
484 
485 	private static IItemFilter getRestFilter(List&lt;LaneDefinition&gt; lanesInput) {
486 		List&lt;IItemFilter&gt; laneFilters = lanesInput.stream().filter(ld -&gt; !ld.isRestLane).map(ld -&gt; ld.getFilter())
487 				.collect(Collectors.toList());
488 		IItemFilter laneFilter = ItemFilters.or(laneFilters.toArray(new IItemFilter[laneFilters.size()]));
489 		return ItemFilters.and(ItemFilters.not(laneFilter), TYPE_HAS_THREAD_AND_DURATION);
490 	}
491 
492 	public static LaneDefinition ensureRestLane(List&lt;LaneDefinition&gt; lanesInput) {
493 		// FIXME: Should we react if there are several rest lanes specified, or just ignore the other ones?
494 		LaneDefinition oldRestLane = lanesInput.stream().filter(ld -&gt; ld.isRestLane).findAny().orElse(null);
495 		LaneDefinition newRestLane;
496 		IItemFilter restFilter = getRestFilter(lanesInput);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">  3  *</span>
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * The contents of this file are subject to the terms of either the Universal Permissive License
  7  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
  8  *
  9  * or the following license:
 10  *
 11  * Redistribution and use in source and binary forms, with or without modification, are permitted
 12  * provided that the following conditions are met:
 13  * 
 14  * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
 15  * and the following disclaimer.
 16  * 
 17  * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
 18  * conditions and the following disclaimer in the documentation and/or other materials provided with
 19  * the distribution.
 20  * 
 21  * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
 22  * endorse or promote products derived from this software without specific prior written permission.
 23  * 
</pre>
<hr />
<pre>
 86 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
 87 import org.openjdk.jmc.ui.misc.ActionUiToolkit;
 88 import org.openjdk.jmc.ui.misc.CompositeToolkit;
 89 import org.openjdk.jmc.ui.misc.DialogToolkit;
 90 import org.openjdk.jmc.ui.misc.SWTColorToolkit;
 91 import org.openjdk.jmc.ui.wizards.IPerformFinishable;
 92 import org.openjdk.jmc.ui.wizards.OnePageWizardDialog;
 93 
 94 public class LaneEditor {
 95 
 96 	private static final IItemFilter TYPE_HAS_THREAD_AND_DURATION = new IItemFilter() {
 97 		@Override
 98 		public IPredicate&lt;IItem&gt; getPredicate(IType&lt;IItem&gt; type) {
 99 			if (DataPageToolkit.isTypeWithThreadAndDuration(type)) {
100 				return PredicateToolkit.truePredicate();
101 			}
102 			return PredicateToolkit.falsePredicate();
103 		}
104 	};
105 
<span class="line-modified">106 	static class EditLanesContainer extends Composite {</span>
<span class="line-added">107 </span>
<span class="line-added">108 		final EventTypeFolderNode root;</span>
<span class="line-added">109 		final List&lt;LaneDefinition&gt; lanes;</span>
110 


111 		private LaneDefinition restLane;
112 		private TypeFilterBuilder filterEditor;
113 		private CheckboxTableViewer lanesViewer;
114 		private Object selected;
<span class="line-added">115 		private Runnable updateChart;</span>
<span class="line-added">116 		private boolean isDropdownFilter;</span>
117 
<span class="line-modified">118 		EditLanesContainer(Composite parent, EventTypeFolderNode root, List&lt;LaneDefinition&gt; lanes) {</span>
<span class="line-modified">119 			this(parent, root, lanes, null);</span>
<span class="line-added">120 		}</span>
<span class="line-added">121 </span>
<span class="line-added">122 		EditLanesContainer(Composite parent, EventTypeFolderNode root, List&lt;LaneDefinition&gt; lanes, Runnable action) {</span>
<span class="line-added">123 			super(parent, SWT.NONE);</span>
124 			this.root = root;
<span class="line-modified">125 			this.lanes = lanes;</span>
<span class="line-added">126 			this.updateChart = action;</span>
127 			restLane = ensureRestLane(lanes);
<span class="line-added">128 			init();</span>
129 		}
130 
<span class="line-modified">131 		public List&lt;LaneDefinition&gt; getLanes() {</span>
<span class="line-modified">132 			return lanes;</span>
<span class="line-added">133 		}</span>
<span class="line-added">134 </span>
<span class="line-added">135 		private void init() {</span>
136 			// FIXME: Do we want to group under categories somehow, or just hide the filters that don&#39;t have any existing event types.
<span class="line-modified">137 			this.setLayout(GridLayoutFactory.swtDefaults().numColumns(2).create());</span>

138 
<span class="line-modified">139 			Composite laneHeaderContainer = new Composite(this, SWT.NONE);</span>
140 			laneHeaderContainer.setLayout(GridLayoutFactory.swtDefaults().create());
141 			laneHeaderContainer.setLayoutData(GridDataFactory.fillDefaults().create());
142 
143 			// FIXME: Add a duplicate action?
144 			IAction moveUpAction = ActionToolkit.action(() -&gt; moveSelected(true), Messages.LANES_MOVE_UP_ACTION,
145 					UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_NAV_UP));
146 			IAction moveDownAction = ActionToolkit.action(() -&gt; moveSelected(false), Messages.LANES_MOVE_DOWN_ACTION,
147 					UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_NAV_DOWN));
148 			IAction addAction = ActionToolkit.action(this::addLane, Messages.LANES_ADD_LANE_ACTION,
149 					UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_ADD));
150 			IAction removeAction = ActionToolkit.commandAction(this::deleteSelected,
151 					IWorkbenchCommandConstants.EDIT_DELETE);
152 			Control toolbar = ActionUiToolkit.buildToolBar(laneHeaderContainer,
153 					Stream.of(moveUpAction, moveDownAction, addAction, removeAction), false);
154 			toolbar.setLayoutData(GridDataFactory.fillDefaults().create());
155 
156 			Label lanesTitle = new Label(laneHeaderContainer, SWT.NONE);
157 			lanesTitle.setText(Messages.LANES_EDITOR_LABEL);
158 			lanesTitle.setLayoutData(GridDataFactory.fillDefaults().create());
<span class="line-modified">159 			Label filterTitle = new Label(this, SWT.NONE);</span>
160 			filterTitle.setText(Messages.LANES_FILTER_LABEL);
161 			filterTitle.setLayoutData(
162 					GridDataFactory.fillDefaults().grab(true, false).align(SWT.BEGINNING, SWT.END).create());
163 
<span class="line-modified">164 			lanesViewer = CheckboxTableViewer.newCheckList(this, SWT.BORDER | SWT.V_SCROLL);</span>
165 			TableViewerColumn viewerColumn = new TableViewerColumn(lanesViewer, SWT.NONE);
166 			viewerColumn.getColumn().setText(Messages.LANES_LANE_COLUMN);
167 			viewerColumn.getColumn().setWidth(200);
168 			// FIXME: Would like to enable editing by some other means than single-clicking, but seems a bit tricky.
169 			viewerColumn.setEditingSupport(new EditingSupport(lanesViewer) {
170 
171 				private String currentName;
172 
173 				@Override
174 				protected void setValue(Object element, Object value) {
175 					String newName = value.toString();
176 					if (currentName != null &amp;&amp; currentName.equals(newName)) {
177 						return;
178 					}
179 					LaneDefinition oldLd = (LaneDefinition) element;
180 					LaneDefinition newLane = new LaneDefinition(value.toString(), oldLd.enabled, oldLd.filter,
181 							oldLd.isRestLane);
182 					int elementIndex = lanes.indexOf(element);
183 					lanes.set(elementIndex, newLane);
184 					lanesViewer.replace(newLane, elementIndex);
</pre>
<hr />
<pre>
265 					if (sb.length() &gt; 0) {
266 						sb.insert(0, &quot;&lt;form&gt;&quot;); //$NON-NLS-1$
267 						sb.append(&quot;&lt;/form&gt;&quot;); //$NON-NLS-1$
268 						formText.setText(sb.toString(), true, false);
269 					} else {
270 						formText.setText(Messages.LANES_CHECK_TO_INCLUDE, false, false);
271 					}
272 					return formText;
273 				}
274 			};
275 			lanesViewer.setInput(lanes);
276 			lanesViewer.setCheckedElements(lanes.stream().filter(ld -&gt; ld.isEnabled()).toArray());
277 			MCContextMenuManager mm = MCContextMenuManager.create(lanesViewer.getControl());
278 			mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, moveUpAction);
279 			mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, moveDownAction);
280 			// FIXME: Add icon
281 			mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, addAction);
282 
283 			mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, removeAction);
284 
<span class="line-modified">285 			filterEditor = new TypeFilterBuilder(this, this::onTypeFilterChange);</span>
286 			filterEditor.setInput(root);
287 			filterEditor.getControl().setLayoutData(GridDataFactory.fillDefaults().grab(true, true).create());
<span class="line-added">288 			isDropdownFilter = updateChart != null ? true : false;</span>
289 			lanesViewer.getControl().setLayoutData(GridDataFactory.fillDefaults().grab(false, true).create());
290 
291 			lanesViewer.addSelectionChangedListener(
292 					e -&gt; laneSelectionChanges(((IStructuredSelection) e.getSelection()).getFirstElement()));
293 			LaneDefinition firstLane = lanes.get(0);
294 			lanesViewer.setSelection(new StructuredSelection(firstLane));


295 		}
296 
297 		private void addLane() {
298 			int selectIndex = Math.max(0, lanes.indexOf(selected));
299 			IItemFilter emptyFilter = ItemFilters.type(Collections.emptySet());
300 			LaneDefinition newEmpty = new LaneDefinition(null, false, emptyFilter, false);
301 			lanes.add(selectIndex + 1, newEmpty);
302 			lanesViewer.insert(newEmpty, selectIndex + 1);
303 			lanesViewer.setSelection(new StructuredSelection(newEmpty));
304 		}
305 
306 		private void onTypeFilterChange() {
307 			if (selected instanceof LaneDefinition) {
308 				LaneDefinition selectedLane = (LaneDefinition) selected;
309 				if (selectedLane.isRestLane()) {
310 					DialogToolkit.showWarningDialogAsync(lanesViewer.getControl().getDisplay(),
311 							Messages.LANES_EDIT_NOT_ALLOWED_WARNING,
312 							NLS.bind(Messages.LANES_EDIT_NOT_ALLOWED_WARNING_DESC, selectedLane.getName()));
313 					// FIXME: Can we refresh the filter editor to show that nothing has changed?
314 				}
315 			}
316 			lanesViewer.update(selected, null);
<span class="line-added">317 			if (isDropdownFilter) {</span>
<span class="line-added">318 				updateChart();</span>
<span class="line-added">319 			}</span>
320 		}
321 
322 		private void deleteSelected() {
323 			// FIXME: It&#39;s currently not possible to delete the last lane
324 			int selectIndex = Math.max(0, lanes.indexOf(selected) - 1);
325 			if (selected instanceof LaneDefinition &amp;&amp; ((LaneDefinition) selected).isRestLane()) {
326 				lanes.remove(selected);
327 				lanesViewer.setSelection(new StructuredSelection(lanes.get(selectIndex)));
328 				lanesViewer.refresh();
329 			} else {
330 				DialogToolkit.showWarningDialogAsync(lanesViewer.getControl().getDisplay(),
331 						Messages.LANES_DELETE_NOT_ALLOWED_WARNING, NLS.bind(
332 								Messages.LANES_DELETE_NOT_ALLOWED_WARNING_DESC, ((LaneDefinition) selected).getName()));
333 			}
334 		}
335 
336 		private void moveSelected(boolean up) {
337 			int fromIndex = lanes.indexOf(selected);
338 			int toIndex = fromIndex + (up ? -1 : 1);
339 			if (fromIndex &gt;= 0 &amp;&amp; toIndex &gt;= 0 &amp;&amp; toIndex &lt; lanes.size()) {
340 				LaneDefinition removed = lanes.remove(fromIndex);
341 				lanes.add(toIndex, removed);
342 				lanesViewer.refresh();
343 			}
344 		}
345 
346 		private void laneSelectionChanges(Object newSelected) {
347 			int selectedIndex = lanes.indexOf(newSelected);
<span class="line-modified">348 			if (selectedIndex == -1 &amp;&amp; isDropdownFilter) {</span>
<span class="line-modified">349 				selectedIndex = findLaneDefinitionIndexByName(selected);</span>
<span class="line-modified">350 			}</span>
<span class="line-modified">351 			saveFilter();</span>
<span class="line-modified">352 			this.selected = lanes.get(selectedIndex);</span>
<span class="line-modified">353 			if (selected instanceof LaneDefinition) {</span>
<span class="line-modified">354 				Types typesFilter;</span>
<span class="line-modified">355 				if (((LaneDefinition) selected).getFilter() instanceof Types) {</span>
<span class="line-modified">356 					typesFilter = ((Types) ((LaneDefinition) selected).getFilter());</span>
<span class="line-modified">357 				} else {</span>
<span class="line-added">358 					typesFilter = (Types) ItemFilters.convertToTypes(((LaneDefinition) selected).getFilter(),</span>
<span class="line-added">359 							filterEditor.getAllTypes());</span>
<span class="line-added">360 				}</span>
<span class="line-added">361 				filterEditor.selectTypes(typesFilter.getTypes());</span>
<span class="line-added">362 			}</span>
<span class="line-added">363 			if (isDropdownFilter) {</span>
<span class="line-added">364 				updateChart();</span>
<span class="line-added">365 			}</span>
<span class="line-added">366 		}</span>
<span class="line-added">367 </span>
<span class="line-added">368 		private void updateChart() {</span>
<span class="line-added">369 			saveFilter(); // updates the LaneDefinition with the new filter</span>
<span class="line-added">370 			updateChart.run(); // repaints the chart and text canvases</span>
<span class="line-added">371 		}</span>
<span class="line-added">372 </span>
<span class="line-added">373 		private int findLaneDefinitionIndexByName(Object selected) {</span>
<span class="line-added">374 			int index = -1;</span>
<span class="line-added">375 			if (selected != null) {</span>
<span class="line-added">376 				for (int i = 0; i &lt; lanes.size(); i++) {</span>
<span class="line-added">377 					if (lanes.get(i).getName().equals(((LaneDefinition) selected).getName())) {</span>
<span class="line-added">378 						index = i;</span>
<span class="line-added">379 						break;</span>
380 					}

381 				}
382 			}
<span class="line-added">383 			return index;</span>
384 		}
385 
386 		private void saveFilter() {
387 			int selectedIndex = lanes.indexOf(selected);
<span class="line-added">388 			if (selectedIndex == -1 &amp;&amp; isDropdownFilter) {</span>
<span class="line-added">389 				selectedIndex = findLaneDefinitionIndexByName(selected);</span>
<span class="line-added">390 			}</span>
391 			if (selectedIndex &gt;= 0) {
392 				LaneDefinition ld = lanes.get(selectedIndex);
<span class="line-modified">393 				IItemFilter newFilter = ItemFilters.type(filterEditor.getCheckedTypeIds().collect(Collectors.toSet()));</span>
<span class="line-modified">394 				LaneDefinition newLd = new LaneDefinition(ld.name, lanesViewer.getChecked(ld), newFilter,</span>
<span class="line-modified">395 						ld.isRestLane);</span>
<span class="line-modified">396 				lanes.set(selectedIndex, newLd);</span>
<span class="line-modified">397 				lanesViewer.replace(newLd, selectedIndex);</span>
<span class="line-modified">398 				if (ld.isRestLane()) {</span>
<span class="line-modified">399 					restLane = newLd;</span>
<span class="line-modified">400 				} else {</span>
<span class="line-modified">401 					LaneDefinition newRest = new LaneDefinition(restLane.name, restLane.enabled, getRestFilter(lanes),</span>
<span class="line-modified">402 							true);</span>
<span class="line-modified">403 					int restIndex = findLaneDefinitionIndexByName(restLane);</span>
<span class="line-modified">404 					lanes.set(restIndex, newRest);</span>
<span class="line-modified">405 					lanesViewer.replace(newRest, restIndex);</span>
<span class="line-modified">406 					restLane = newRest;</span>


407 				}
<span class="line-added">408 				lanesViewer.refresh();</span>
409 			}
410 		}
<span class="line-added">411 	}</span>
<span class="line-added">412 </span>
<span class="line-added">413 	private static class EditLanesWizardPage extends WizardPage implements IPerformFinishable {</span>
<span class="line-added">414 </span>
<span class="line-added">415 		private EditLanesContainer container;</span>
<span class="line-added">416 		protected EventTypeFolderNode root;</span>
<span class="line-added">417 		private List&lt;LaneDefinition&gt; lanes;</span>
<span class="line-added">418 </span>
<span class="line-added">419 		private EditLanesWizardPage(EventTypeFolderNode root, Collection&lt;LaneDefinition&gt; lanesInput) {</span>
<span class="line-added">420 			super(&quot;EditFilterLanesPage&quot;); //$NON-NLS-1$</span>
<span class="line-added">421 			this.root = root;</span>
<span class="line-added">422 			this.lanes = new ArrayList&lt;&gt;(lanesInput);</span>
<span class="line-added">423 		}</span>
<span class="line-added">424 </span>
<span class="line-added">425 		public List&lt;LaneDefinition&gt; getLanes() {</span>
<span class="line-added">426 			return lanes;</span>
<span class="line-added">427 		}</span>
<span class="line-added">428 </span>
<span class="line-added">429 		@Override</span>
<span class="line-added">430 		public void createControl(Composite parent) {</span>
<span class="line-added">431 			container = new EditLanesContainer(parent, root, lanes);</span>
<span class="line-added">432 			setControl(container);</span>
<span class="line-added">433 		}</span>
434 
435 		@Override
436 		public boolean performFinish() {
<span class="line-modified">437 			container.saveFilter();</span>
438 			for (int i = 0; i &lt; lanes.size(); i++) {
439 				LaneDefinition ld = lanes.get(i);
<span class="line-modified">440 				if (ld.isEnabled() != container.lanesViewer.getChecked(ld)) {</span>
<span class="line-modified">441 					lanes.set(i, new LaneDefinition(ld.name, container.lanesViewer.getChecked(ld), ld.filter,</span>
<span class="line-added">442 							ld.isRestLane));</span>
443 				}
444 			}
445 			return true;
446 		}
447 	}
448 
449 	public static class LaneDefinition implements IDescribable, IStateful {
450 
451 		private static final String FILTER = &quot;filter&quot;; //$NON-NLS-1$
452 		private static final String NAME = &quot;name&quot;; //$NON-NLS-1$
453 		private static final String ENABLED = &quot;enabled&quot;; //$NON-NLS-1$
454 		private static final String IS_REST_LANE = &quot;isRestLane&quot;; //$NON-NLS-1$
455 
456 		private final String name;
457 		private final IItemFilter filter;
458 		private final boolean enabled;
459 		private final boolean isRestLane;
460 
461 		public LaneDefinition(String name, boolean enabled, IItemFilter filter, boolean isRestLane) {
462 			this.name = name;
</pre>
<hr />
<pre>
478 							: count &gt; 0 ? NLS.bind(Messages.LANES_DEFINITION_NAME, count) : Messages.LANES_EMPTY_LANE;
479 		}
480 
481 		@Override
482 		public String getDescription() {
483 			return NLS.bind(Messages.LANES_DEFINITION_DESC, getName());
484 		}
485 
486 		public IItemFilter getFilter() {
487 			return filter;
488 		}
489 
490 		public boolean isEnabled() {
491 			return enabled;
492 		}
493 
494 		public boolean isRestLane() {
495 			return isRestLane;
496 		}
497 
<span class="line-added">498 		public boolean isEnabledAndNotRestLane() {</span>
<span class="line-added">499 			return enabled &amp;&amp; !isRestLane;</span>
<span class="line-added">500 		}</span>
<span class="line-added">501 </span>
502 		@Override
503 		public void saveTo(IWritableState writableState) {
504 			writableState.putString(NAME, name);
505 			StateToolkit.writeBoolean(writableState, ENABLED, enabled);
506 			StateToolkit.writeBoolean(writableState, IS_REST_LANE, isRestLane);
507 			if (!isRestLane &amp;&amp; filter != null) {
508 				((PersistableItemFilter) filter).saveTo(writableState.createChild(FILTER));
509 			}
510 		}
511 
512 		public static LaneDefinition readFrom(IState memento) {
513 			String name = memento.getAttribute(NAME);
514 			boolean enabled = StateToolkit.readBoolean(memento, ENABLED, false);
515 			boolean isRestLane = StateToolkit.readBoolean(memento, IS_REST_LANE, false);
516 			IState filterState = memento.getChild(FILTER);
517 			IItemFilter filter;
518 			if (isRestLane) {
519 				filter = null;
520 			} else if (filterState != null) {
521 				filter = PersistableItemFilter.readFrom(filterState);
522 			} else {
523 				throw new UnsupportedOperationException(&quot;Null filter not allowed for thread lane: &quot; + name); //$NON-NLS-1$
524 			}
525 			// FIXME: Should probably warn if filter is not an instance of Types, and possibly handle other type filter variants as well, like TypeMatches.
526 			return new LaneDefinition(name, enabled, filter, isRestLane);
527 		}
528 
529 		@Override
530 		public String toString() {
531 			return getName() + &quot;(&quot; + enabled + &quot;)&quot;; //$NON-NLS-1$ //$NON-NLS-2$
532 		}
533 	}
534 
535 	public static List&lt;LaneDefinition&gt; openDialog(
536 		EventTypeFolderNode root, List&lt;LaneDefinition&gt; lanes, String title, String description) {
537 		EditLanesWizardPage page = new EditLanesWizardPage(root, lanes);
538 		page.setTitle(title);
539 		page.setDescription(description);
540 		if (OnePageWizardDialog.open(page, 500, 600) == Window.OK) {
<span class="line-modified">541 			return page.getLanes().stream().filter(LaneEditor::laneIncludesTypes).collect(Collectors.toList());</span>
542 		}
543 		return lanes;
544 	}
545 
546 	private static boolean laneIncludesTypes(LaneDefinition ld) {
547 		return ld.isRestLane() || ld.getFilter() instanceof Types &amp;&amp; ((Types) ld.getFilter()).getTypes().size() &gt; 0;
548 	}
549 
550 	private static IItemFilter getRestFilter(List&lt;LaneDefinition&gt; lanesInput) {
551 		List&lt;IItemFilter&gt; laneFilters = lanesInput.stream().filter(ld -&gt; !ld.isRestLane).map(ld -&gt; ld.getFilter())
552 				.collect(Collectors.toList());
553 		IItemFilter laneFilter = ItemFilters.or(laneFilters.toArray(new IItemFilter[laneFilters.size()]));
554 		return ItemFilters.and(ItemFilters.not(laneFilter), TYPE_HAS_THREAD_AND_DURATION);
555 	}
556 
557 	public static LaneDefinition ensureRestLane(List&lt;LaneDefinition&gt; lanesInput) {
558 		// FIXME: Should we react if there are several rest lanes specified, or just ignore the other ones?
559 		LaneDefinition oldRestLane = lanesInput.stream().filter(ld -&gt; ld.isRestLane).findAny().orElse(null);
560 		LaneDefinition newRestLane;
561 		IItemFilter restFilter = getRestFilter(lanesInput);
</pre>
</td>
</tr>
</table>
<center><a href="FlavorSelector.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ThreadGraphLanes.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>