<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DataPageToolkit.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * 
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * The contents of this file are subject to the terms of either the Universal Permissive License
   7  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
   8  *
   9  * or the following license:
  10  *
  11  * Redistribution and use in source and binary forms, with or without modification, are permitted
  12  * provided that the following conditions are met:
  13  * 
  14  * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
  15  * and the following disclaimer.
  16  * 
  17  * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
  18  * conditions and the following disclaimer in the documentation and/or other materials provided with
  19  * the distribution.
  20  * 
  21  * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
  22  * endorse or promote products derived from this software without specific prior written permission.
  23  * 
  24  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
  25  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  26  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
  27  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  28  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  29  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  30  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  31  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  32  */
  33 package org.openjdk.jmc.flightrecorder.ui.common;
  34 
  35 import java.awt.Color;
  36 import java.io.FileInputStream;
  37 import java.io.InputStream;
  38 import java.util.ArrayList;
  39 import java.util.Arrays;
  40 import java.util.Collection;
  41 import java.util.Collections;
  42 import java.util.Comparator;
  43 import java.util.HashMap;
  44 import java.util.HashSet;
  45 import java.util.Iterator;
  46 import java.util.List;
  47 import java.util.Map;
  48 import java.util.Objects;
  49 import java.util.Optional;
  50 import java.util.Set;
  51 import java.util.function.Consumer;
  52 import java.util.function.Predicate;
  53 import java.util.function.Supplier;
  54 import java.util.regex.Matcher;
  55 import java.util.regex.Pattern;
  56 import java.util.stream.Collectors;
  57 import java.util.stream.Stream;
  58 
  59 import org.eclipse.core.runtime.IAdaptable;
  60 import org.eclipse.jface.action.Action;
  61 import org.eclipse.jface.action.IAction;
  62 import org.eclipse.jface.action.IMenuListener;
  63 import org.eclipse.jface.action.IMenuManager;
  64 import org.eclipse.jface.action.MenuManager;
  65 import org.eclipse.jface.action.Separator;
  66 import org.eclipse.jface.dialogs.InputDialog;
  67 import org.eclipse.jface.resource.ImageDescriptor;
  68 import org.eclipse.jface.resource.JFaceResources;
  69 import org.eclipse.jface.viewers.ColumnViewer;
  70 import org.eclipse.jface.viewers.IBaseLabelProvider;
  71 import org.eclipse.jface.viewers.StyledCellLabelProvider;
  72 import org.eclipse.jface.viewers.ViewerCell;
  73 import org.eclipse.jface.window.ToolTip;
  74 import org.eclipse.jface.window.Window;
  75 import org.eclipse.jface.wizard.Wizard;
  76 import org.eclipse.jface.wizard.WizardDialog;
  77 import org.eclipse.jface.wizard.WizardPage;
  78 import org.eclipse.swt.SWT;
  79 import org.eclipse.swt.custom.CTabFolder;
  80 import org.eclipse.swt.custom.CTabItem;
  81 import org.eclipse.swt.events.SelectionAdapter;
  82 import org.eclipse.swt.events.SelectionEvent;
  83 import org.eclipse.swt.graphics.GC;
  84 import org.eclipse.swt.graphics.Image;
  85 import org.eclipse.swt.graphics.ImageData;
  86 import org.eclipse.swt.layout.FillLayout;
  87 import org.eclipse.swt.layout.GridData;
  88 import org.eclipse.swt.layout.GridLayout;
  89 import org.eclipse.swt.widgets.Button;
  90 import org.eclipse.swt.widgets.Composite;
  91 import org.eclipse.swt.widgets.Control;
  92 import org.eclipse.swt.widgets.Display;
  93 import org.eclipse.swt.widgets.Event;
  94 import org.eclipse.swt.widgets.FileDialog;
  95 import org.eclipse.swt.widgets.Label;
  96 import org.eclipse.ui.forms.widgets.Form;
  97 import org.eclipse.ui.forms.widgets.FormText;
  98 import org.eclipse.ui.forms.widgets.FormToolkit;
  99 import org.openjdk.jmc.common.item.IAggregator;
 100 import org.openjdk.jmc.common.item.IAttribute;
 101 import org.openjdk.jmc.common.item.ICanonicalAccessorFactory;
 102 import org.openjdk.jmc.common.item.IItem;
 103 import org.openjdk.jmc.common.item.IItemCollection;
 104 import org.openjdk.jmc.common.item.IItemFilter;
 105 import org.openjdk.jmc.common.item.IItemIterable;
 106 import org.openjdk.jmc.common.item.IItemQuery;
 107 import org.openjdk.jmc.common.item.IMemberAccessor;
 108 import org.openjdk.jmc.common.item.IType;
 109 import org.openjdk.jmc.common.item.ItemFilters;
 110 import org.openjdk.jmc.common.item.ItemToolkit;
 111 import org.openjdk.jmc.common.unit.IQuantity;
 112 import org.openjdk.jmc.common.unit.IRange;
 113 import org.openjdk.jmc.common.unit.KindOfQuantity;
 114 import org.openjdk.jmc.common.unit.QuantitiesToolkit;
 115 import org.openjdk.jmc.common.unit.QuantityRange;
 116 import org.openjdk.jmc.common.unit.RangeContentType;
 117 import org.openjdk.jmc.common.unit.UnitLookup;
 118 import org.openjdk.jmc.common.util.ColorToolkit;
 119 import org.openjdk.jmc.common.util.CompositeKey;
 120 import org.openjdk.jmc.flightrecorder.JfrAttributes;
 121 import org.openjdk.jmc.flightrecorder.jdk.JdkAggregators;
 122 import org.openjdk.jmc.flightrecorder.jdk.JdkAttributes;
 123 import org.openjdk.jmc.flightrecorder.jdk.JdkFilters;
 124 import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;
 125 import org.openjdk.jmc.flightrecorder.rules.Result;
 126 import org.openjdk.jmc.flightrecorder.rules.Severity;
 127 import org.openjdk.jmc.flightrecorder.ui.FlightRecorderUI;
 128 import org.openjdk.jmc.flightrecorder.ui.IPageContainer;
 129 import org.openjdk.jmc.flightrecorder.ui.ItemCollectionToolkit;
 130 import org.openjdk.jmc.flightrecorder.ui.ItemIterableToolkit;
 131 import org.openjdk.jmc.flightrecorder.ui.PageManager;
 132 import org.openjdk.jmc.flightrecorder.ui.common.ItemHistogram.CompositeKeyHistogramBuilder;
 133 import org.openjdk.jmc.flightrecorder.ui.common.ItemList.ItemListBuilder;
 134 import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
 135 import org.openjdk.jmc.flightrecorder.ui.overview.ResultOverview;
 136 import org.openjdk.jmc.flightrecorder.ui.pages.itemhandler.ItemHandlerPage;
 137 import org.openjdk.jmc.flightrecorder.ui.pages.itemhandler.ItemHandlerPage.ItemHandlerUiStandIn;
 138 import org.openjdk.jmc.flightrecorder.ui.selection.IFilterFlavor;
 139 import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStore.SelectionStoreEntry;
 140 import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStoreActionToolkit;
 141 import org.openjdk.jmc.ui.charts.AWTChartToolkit.IColorProvider;
 142 import org.openjdk.jmc.ui.charts.IQuantitySeries;
 143 import org.openjdk.jmc.ui.charts.ISpanSeries;
 144 import org.openjdk.jmc.ui.charts.IXDataRenderer;
 145 import org.openjdk.jmc.ui.charts.QuantitySeries;
 146 import org.openjdk.jmc.ui.charts.RendererToolkit;
 147 import org.openjdk.jmc.ui.charts.SpanRenderer;
 148 import org.openjdk.jmc.ui.charts.SubdividedQuantityRange;
 149 import org.openjdk.jmc.ui.charts.XYChart;
 150 import org.openjdk.jmc.ui.charts.XYDataRenderer;
 151 import org.openjdk.jmc.ui.charts.XYQuantities;
 152 import org.openjdk.jmc.ui.column.ColumnMenusFactory;
 153 import org.openjdk.jmc.ui.column.TableSettings;
 154 import org.openjdk.jmc.ui.column.TableSettings.ColumnSettings;
 155 import org.openjdk.jmc.ui.handlers.ActionToolkit;
 156 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
 157 import org.openjdk.jmc.ui.misc.ChartCanvas;
<a name="2" id="anc2"></a><span class="line-added"> 158 import org.openjdk.jmc.ui.misc.ChartControlBar;</span>
<span class="line-added"> 159 import org.openjdk.jmc.ui.misc.ChartTextCanvas;</span>
 160 import org.openjdk.jmc.ui.misc.CompositeToolkit;
 161 import org.openjdk.jmc.ui.misc.DisplayToolkit;
 162 import org.openjdk.jmc.ui.misc.FilterEditor;
 163 import org.openjdk.jmc.ui.misc.FilterEditor.AttributeValueProvider;
 164 import org.openjdk.jmc.ui.misc.OverlayImageDescriptor;
 165 import org.openjdk.jmc.ui.misc.SWTColorToolkit;
 166 
 167 public class DataPageToolkit {
 168 
 169 	public static final IColorProvider&lt;IItem&gt; ITEM_COLOR = item -&gt; TypeLabelProvider
 170 			.getColorOrDefault(item.getType().getIdentifier());
 171 
 172 	public static final IColorProvider&lt;IItem&gt; getAttributeValueColor(final IAttribute&lt;?&gt; attribute) {
 173 		return new IColorProvider&lt;IItem&gt;() {
 174 
 175 			@Override
 176 			public Color getColor(IItem item) {
 177 				IMemberAccessor&lt;?, IItem&gt; accessor = attribute.getAccessor(ItemToolkit.getItemType(item));
 178 				Object attributeValue = accessor != null ? accessor.getMember(item) : null;
 179 				// FIXME: Should we include the type or not?
 180 				return attributeValue != null
 181 						? TypeLabelProvider.getColorOrDefault(attribute.getIdentifier() + &quot;=&quot; + attributeValue + &quot;(&quot; //$NON-NLS-1$ //$NON-NLS-2$
 182 								+ item.getType().getIdentifier() + &quot;)&quot;) //$NON-NLS-1$
 183 						: ITEM_COLOR.getColor(item);
 184 			}
 185 		};
 186 	}
 187 
 188 	private static final Map&lt;String, Color&gt; FIELD_COLOR_MAP = new HashMap&lt;&gt;();
 189 	private static final Map&lt;String, Integer&gt; DEFAULT_COLUMNS_ORDER;
 190 
 191 	static {
 192 
 193 		// FIXME: Create FieldAppearance class, similar to TypeAppearence?
 194 		FIELD_COLOR_MAP.put(JdkAttributes.MACHINE_TOTAL.getIdentifier(), new Color(255, 128, 0));
 195 		FIELD_COLOR_MAP.put(JdkAttributes.JVM_SYSTEM.getIdentifier(), new Color(128, 128, 128));
 196 		FIELD_COLOR_MAP.put(JdkAttributes.JVM_USER.getIdentifier(), new Color(0, 0, 255));
 197 		FIELD_COLOR_MAP.put(JdkAttributes.JVM_TOTAL.getIdentifier(), new Color(64, 64, 191));
 198 
 199 		// FIXME: Handle ColorProvider and combined events
 200 		Map&lt;String, Integer&gt; columnsOrderMap = new HashMap&lt;&gt;();
 201 		columnsOrderMap.put(createColumnId(JfrAttributes.START_TIME), 1);
 202 		columnsOrderMap.put(createColumnId(JfrAttributes.DURATION), 2);
 203 		columnsOrderMap.put(createColumnId(JfrAttributes.END_TIME), 3);
 204 		columnsOrderMap.put(createColumnId(JfrAttributes.EVENT_THREAD), 4);
 205 		DEFAULT_COLUMNS_ORDER = Collections.unmodifiableMap(columnsOrderMap);
 206 	}
 207 
 208 	public static final Color ALLOCATION_COLOR = new Color(64, 144, 230);
 209 
 210 	public static final String FORM_TOOLBAR_PAGE_RESULTS = &quot;pageResults&quot;; //$NON-NLS-1$
 211 	public static final String FORM_TOOLBAR_PAGE_SETUP = &quot;pageSetup&quot;; //$NON-NLS-1$
 212 	public static final String FORM_TOOLBAR_PAGE_NAV = &quot;pageNav&quot;; //$NON-NLS-1$
 213 
 214 	public static final String RESULT_ACTION_ID = &quot;resultAction&quot;; //$NON-NLS-1$
 215 
 216 	public static Color getFieldColor(String fieldId) {
 217 		return FIELD_COLOR_MAP.getOrDefault(fieldId, ColorToolkit.getDistinguishableColor(fieldId));
 218 	}
 219 
 220 	public static Color getFieldColor(IAttribute&lt;?&gt; attribute) {
 221 		return getFieldColor(attribute.getIdentifier());
 222 	}
 223 
 224 	public static TableSettings createTableSettingsByOrderByAndColumnsWithDefaultOrdering(
 225 		final String orderBy, final Collection&lt;ColumnSettings&gt; columns) {
 226 		final Stream&lt;ColumnSettings&gt; defaultOrderColumns = columns.stream()
 227 				.filter(c -&gt; DEFAULT_COLUMNS_ORDER.containsKey(c.getId())).filter(c -&gt; !c.isHidden())
 228 				.sorted((c1, c2) -&gt; Integer.compare(DEFAULT_COLUMNS_ORDER.get(c1.getId()),
 229 						DEFAULT_COLUMNS_ORDER.get(c2.getId())));
 230 		final Stream&lt;ColumnSettings&gt; naturalOrderColumns = columns.stream()
 231 				.filter(c -&gt; !DEFAULT_COLUMNS_ORDER.containsKey(c.getId()))
 232 				.sorted((c1, c2) -&gt; String.CASE_INSENSITIVE_ORDER.compare(c1.getId(), c2.getId()));
 233 		final List&lt;ColumnSettings&gt; resultColumns = Stream.concat(defaultOrderColumns, naturalOrderColumns)
 234 				.collect(Collectors.toList());
 235 		return new TableSettings(orderBy, resultColumns);
 236 	}
 237 
 238 	public static TableSettings createTableSettingsByAllAndVisibleColumns(
 239 		final Collection&lt;String&gt; allColumns, final Collection&lt;String&gt; visibleColumns) {
 240 		final List&lt;ColumnSettings&gt; defaultListCols = new ArrayList&lt;&gt;();
 241 		for (String columnId : allColumns) {
 242 			defaultListCols.add(new ColumnSettings(columnId, !visibleColumns.contains(columnId), null, null));
 243 		}
 244 		return createTableSettingsByOrderByAndColumnsWithDefaultOrdering(null, defaultListCols);
 245 	}
 246 
 247 	private static String createColumnId(IAttribute&lt;?&gt; attr) {
 248 		return new StringBuilder().append(attr.getIdentifier()).append(&quot;:&quot;) //$NON-NLS-1$
 249 				.append(attr.getContentType().getIdentifier()).toString();
 250 	}
 251 
 252 	public static IAction createAttributeCheckAction(IAttribute&lt;?&gt; attribute, Consumer&lt;Boolean&gt; onChange) {
 253 		return createCheckAction(attribute.getName(), attribute.getDescription(), attribute.getIdentifier(),
 254 				getFieldColor(attribute), onChange);
 255 	}
 256 
 257 	public static IAction createTypeCheckAction(
 258 		String actionId, String typeId, String name, String description, Consumer&lt;Boolean&gt; onChange) {
 259 		return createCheckAction(name, description, actionId, TypeLabelProvider.getColorOrDefault(typeId), onChange);
 260 	}
 261 
 262 	public static IAction createAggregatorCheckAction(
 263 		IAggregator&lt;?, ?&gt; aggregator, String id, Color color, Consumer&lt;Boolean&gt; onChange) {
 264 		return createCheckAction(aggregator.getName(), aggregator.getDescription(), id, color, onChange);
 265 	}
 266 
 267 	public static IAction createCheckAction(
 268 		String name, String description, String id, Color color, Consumer&lt;Boolean&gt; onChange) {
 269 		return createCheckAction(name, description, id,
 270 				SWTColorToolkit.getColorThumbnailDescriptor(SWTColorToolkit.asRGB(color)), onChange);
 271 	}
 272 
 273 	public static IAction createCheckAction(
 274 		String name, String description, String id, ImageDescriptor icon, Consumer&lt;Boolean&gt; onChange) {
 275 		return ActionToolkit.checkAction(onChange, name, description, icon, id);
 276 	}
 277 
 278 	public static Optional&lt;IXDataRenderer&gt; buildLinesRow(
 279 		String title, String description, IItemCollection items, boolean fill, IItemQuery query,
 280 		Predicate&lt;IAttribute&lt;IQuantity&gt;&gt; attributeFilter, IQuantity includeLow, IQuantity includeHigh) {
 281 		XYDataRenderer renderer = includeHigh != null
 282 				? new XYDataRenderer(includeLow, includeHigh, true, title, description)
 283 				: new XYDataRenderer(includeLow, title, description);
 284 		IItemCollection filteredItemsSupplier = items.apply(query.getFilter());
 285 		Stream&lt;IAttribute&lt;IQuantity&gt;&gt; attributes = getQuantityAttributes(query);
 286 		if (attributeFilter != null) {
 287 			attributes = attributes.filter(attributeFilter);
 288 		}
 289 		if (DataPageToolkit.addEndTimeLines(renderer, filteredItemsSupplier, fill, attributes)) {
 290 			return Optional.of(new ItemRow(title, description, renderer, filteredItemsSupplier));
 291 		}
 292 		return Optional.empty();
 293 	}
 294 
 295 	/**
 296 	 * @param q
 297 	 *            A query containing only {@code IAttribute&lt;IQuantity&gt;} attributes. Queries
 298 	 *            containing non-quantity attributes are not supported and may cause
 299 	 *            ClassCastExceptions later when the attributes are used.
 300 	 * @return a stream of the query attributes
 301 	 */
 302 	/*
 303 	 * FIXME: JMC-5125 - This cast chain is scary and should be reworked.
 304 	 * 
 305 	 * If the query contains any non-quantity attributes then there will be a ClassCastException
 306 	 * later when the attributes are used to extract values.
 307 	 */
 308 	@SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
 309 	public static Stream&lt;IAttribute&lt;IQuantity&gt;&gt; getQuantityAttributes(IItemQuery q) {
 310 		return (Stream) q.getAttributes().stream();
 311 	}
 312 
 313 	public static void setChart(ChartCanvas canvas, XYChart chart, Consumer&lt;IItemCollection&gt; selectionListener) {
 314 		setChart(canvas, chart, selectionListener, null);
 315 	}
 316 
<a name="3" id="anc3"></a><span class="line-added"> 317 	public static void setChart(ChartTextCanvas canvas, XYChart chart, Consumer&lt;IItemCollection&gt; selectionListener) {</span>
<span class="line-added"> 318 		setChart(canvas, chart, selectionListener, null);</span>
<span class="line-added"> 319 	}</span>
<span class="line-added"> 320 </span>
 321 	public static void setChart(
 322 		ChartCanvas canvas, XYChart chart, Consumer&lt;IItemCollection&gt; selectionListener,
 323 		Consumer&lt;IRange&lt;IQuantity&gt;&gt; selectRangeConsumer) {
 324 		IMenuManager contextMenu = canvas.getContextMenu();
 325 		contextMenu.removeAll();
 326 		canvas.getContextMenu().add(new Action(Messages.CHART_ZOOM_TO_SELECTED_RANGE) {
 327 			@Override
 328 			public void run() {
 329 				IQuantity selectionStart = chart.getSelectionStart();
 330 				IQuantity selectionEnd = chart.getSelectionEnd();
 331 				if (selectionStart == null || selectionEnd == null) {
 332 					chart.clearVisibleRange();
 333 				} else {
 334 					chart.setVisibleRange(selectionStart, selectionEnd);
 335 				}
 336 				canvas.redrawChart();
 337 			}
 338 		});
 339 
<a name="4" id="anc4"></a><span class="line-added"> 340 		canvas.setSelectionListener(() -&gt; {</span>
<span class="line-added"> 341 			selectionListener.accept(ItemRow.getRangeSelection(chart, JfrAttributes.LIFETIME));</span>
<span class="line-added"> 342 			IQuantity start = chart.getSelectionStart();</span>
<span class="line-added"> 343 			IQuantity end = chart.getSelectionEnd();</span>
<span class="line-added"> 344 			if (selectRangeConsumer != null) {</span>
<span class="line-added"> 345 				selectRangeConsumer</span>
<span class="line-added"> 346 						.accept(start != null &amp;&amp; end != null ? QuantityRange.createWithEnd(start, end) : null);</span>
<span class="line-added"> 347 			}</span>
<span class="line-added"> 348 		});</span>
<span class="line-added"> 349 		canvas.setChart(chart);</span>
<span class="line-added"> 350 	}</span>
<span class="line-added"> 351 </span>
<span class="line-added"> 352 	public static void setChart(</span>
<span class="line-added"> 353 		ChartTextCanvas canvas, XYChart chart, Consumer&lt;IItemCollection&gt; selectionListener,</span>
<span class="line-added"> 354 		Consumer&lt;IRange&lt;IQuantity&gt;&gt; selectRangeConsumer) {</span>
<span class="line-added"> 355 		IMenuManager contextMenu = canvas.getContextMenu();</span>
<span class="line-added"> 356 		contextMenu.removeAll();</span>
<span class="line-added"> 357 		canvas.getContextMenu().add(new Action(Messages.CHART_ZOOM_TO_SELECTED_RANGE) {</span>
<span class="line-added"> 358 			@Override</span>
<span class="line-added"> 359 			public void run() {</span>
<span class="line-added"> 360 				IQuantity selectionStart = chart.getSelectionStart();</span>
<span class="line-added"> 361 				IQuantity selectionEnd = chart.getSelectionEnd();</span>
<span class="line-added"> 362 				if (selectionStart == null || selectionEnd == null) {</span>
<span class="line-added"> 363 					chart.clearVisibleRange();</span>
<span class="line-added"> 364 				} else {</span>
<span class="line-added"> 365 					chart.setVisibleRange(selectionStart, selectionEnd);</span>
<span class="line-added"> 366 				}</span>
<span class="line-added"> 367 				canvas.redrawChartText();</span>
<span class="line-added"> 368 			}</span>
<span class="line-added"> 369 		});</span>
<span class="line-added"> 370 </span>
 371 		canvas.setSelectionListener(() -&gt; {
 372 			selectionListener.accept(ItemRow.getRangeSelection(chart, JfrAttributes.LIFETIME));
 373 			IQuantity start = chart.getSelectionStart();
 374 			IQuantity end = chart.getSelectionEnd();
 375 			if (selectRangeConsumer != null) {
 376 				selectRangeConsumer
 377 						.accept(start != null &amp;&amp; end != null ? QuantityRange.createWithEnd(start, end) : null);
 378 			}
 379 		});
 380 		canvas.setChart(chart);
 381 	}
 382 
 383 	public static void setChart(
 384 		ChartCanvas canvas, XYChart chart, IAttribute&lt;IQuantity&gt; selectionAttribute,
 385 		Consumer&lt;IItemCollection&gt; selectionListener) {
 386 		IMenuManager contextMenu = canvas.getContextMenu();
 387 		contextMenu.removeAll();
 388 		canvas.setSelectionListener(() -&gt; selectionListener.accept(ItemRow.getSelection(chart, selectionAttribute)));
 389 		canvas.setChart(chart);
 390 	}
 391 
 392 	/**
 393 	 * Only works for items that are either fully overlapping, or disjunct. Must be ensured by
 394 	 * client code.
 395 	 */
 396 	private static class RangePayload implements IAdaptable {
 397 		IItem item;
 398 		IQuantity start;
 399 		IQuantity end;
 400 		double rangeInPixels;
 401 
 402 		RangePayload(IItem item, IQuantity start, IQuantity end, double rangeInPixels) {
 403 			this.item = item;
 404 			this.start = start;
 405 			this.end = end;
 406 			this.rangeInPixels = rangeInPixels;
 407 		}
 408 
 409 		void combineWith(IItem item, IQuantity start, IQuantity end, double rangeInPixels) {
 410 			if (this.start.compareTo(start) &lt; 0) {
 411 				// Will choose the item that starts last
 412 				this.start = start;
 413 				this.end = end;
 414 				this.item = item;
 415 				extendRangeInPixels(this.end.compareTo(start) &gt; 0, rangeInPixels);
 416 			} else {
 417 				extendRangeInPixels(end.compareTo(this.start) &gt; 0, rangeInPixels);
 418 			}
 419 		}
 420 
 421 		void extendRangeInPixels(boolean overlapping, double rangeInPixels) {
 422 			this.rangeInPixels = overlapping ? Math.max(this.rangeInPixels, rangeInPixels)
 423 					: this.rangeInPixels + rangeInPixels;
 424 		}
 425 
 426 		@Override
 427 		public &lt;T&gt; T getAdapter(Class&lt;T&gt; adapter) {
 428 			return IItem.class.isAssignableFrom(adapter) ? adapter.cast(item) : null;
 429 		}
 430 	}
 431 
 432 	private static ISpanSeries&lt;RangePayload&gt; rangeSeries(
 433 		IItemCollection events, IAttribute&lt;IQuantity&gt; startAttribute, IAttribute&lt;IQuantity&gt; endAttribute) {
 434 		return new ISpanSeries&lt;RangePayload&gt;() {
 435 			@Override
 436 			public XYQuantities&lt;RangePayload[]&gt; getQuantities(SubdividedQuantityRange xBucketRange) {
 437 				SubdividedQuantityRange xRange = xBucketRange.copyWithPixelSubdividers();
 438 				List&lt;RangePayload&gt; spanningPixels = new ArrayList&lt;&gt;();
 439 				RangePayload[] pixelBuckets = new RangePayload[xRange.getNumSubdividers()];
 440 				events.forEach(is -&gt; {
 441 					IMemberAccessor&lt;IQuantity, IItem&gt; startAccessor = startAttribute.getAccessor(is.getType());
 442 					IMemberAccessor&lt;IQuantity, IItem&gt; endAccessor = endAttribute.getAccessor(is.getType());
 443 					is.forEach(item -&gt; {
 444 						IQuantity start = startAccessor.getMember(item);
 445 						IQuantity end = endAccessor.getMember(item);
 446 						int xPos = xRange.getFloorSubdivider(start);
 447 						int endPos = xRange.getFloorSubdivider(end);
 448 						if (xPos &lt; pixelBuckets.length &amp;&amp; endPos &gt;= 0) {
 449 							// FIXME: If we have very short events (nanosecond scale) we can sometimes get a negative range.
 450 							double rangeInPixels = xRange.getPixel(end) - xRange.getPixel(start);
 451 							if (xPos != endPos) {
 452 								spanningPixels.add(new RangePayload(item, start, end, rangeInPixels));
 453 							} else if (pixelBuckets[xPos] == null) {
 454 								pixelBuckets[xPos] = new RangePayload(item, start, end, rangeInPixels);
 455 							} else {
 456 								pixelBuckets[xPos].combineWith(item, start, end, rangeInPixels);
 457 							}
 458 						}
 459 					});
 460 				});
 461 				RangePayload[] sorted = Stream
 462 						.concat(Stream.of(pixelBuckets).filter(Objects::nonNull), spanningPixels.stream())
 463 						.sorted(Comparator.comparing(r -&gt; r.start)).toArray(RangePayload[]::new);
 464 				// FIXME: Should make it possible to use the RangePayload[] directly instead
 465 				List&lt;IQuantity&gt; starts = Stream.of(sorted).map(r -&gt; r.start).collect(Collectors.toList());
 466 				List&lt;IQuantity&gt; ends = Stream.of(sorted).map(r -&gt; r.end).collect(Collectors.toList());
 467 				return XYQuantities.create(sorted, starts, ends, xRange);
 468 			}
 469 
 470 			@Override
 471 			public IQuantity getStartX(RangePayload payload) {
 472 				return payload.start;
 473 			}
 474 		};
 475 	}
 476 
 477 	public final static Color GC_BASE_COLOR = TypeLabelProvider.getColor(JdkTypeIDs.GC_PAUSE);
 478 	private final static Color VM_OPERATIONS_BASE_COLOR = TypeLabelProvider.getColor(JdkTypeIDs.VM_OPERATIONS);
 479 	private final static IColorProvider&lt;RangePayload&gt; GC_COLOR = payload -&gt; adjustAlpha(GC_BASE_COLOR,
 480 			payload.rangeInPixels);
 481 	private final static IColorProvider&lt;RangePayload&gt; APPLICATION_PAUSE_COLOR = payload -&gt; adjustAlpha(
 482 			payload.item.getType().getIdentifier().equals(JdkTypeIDs.GC_PAUSE) ? GC_BASE_COLOR
 483 					: VM_OPERATIONS_BASE_COLOR,
 484 			payload.rangeInPixels);
 485 	public final static ImageDescriptor GC_LEGEND_ICON = new OverlayImageDescriptor(
 486 			SWTColorToolkit.getColorThumbnailDescriptor(SWTColorToolkit.asRGB(GC_BASE_COLOR)), false,
 487 			FlightRecorderUI.getDefault().getMCImageDescriptor(&quot;trash_overlay.png&quot;)); //$NON-NLS-1$
 488 
 489 	/**
 490 	 * Return a color with alpha calculated from a fraction.
 491 	 *
 492 	 * @param color
 493 	 *            a base color
 494 	 * @param fraction
 495 	 *            A value where 0 gives the lowest alpha value and 1 gives the highest. Fractions
 496 	 *            above 1 are accepted and treated as 1. Negative fractions should not be used.
 497 	 * @return a color with RGB from the base color and an alpha value depending on the fraction
 498 	 */
 499 	private static Color adjustAlpha(Color color, double fraction) {
 500 		return ColorToolkit.withAlpha(color, Math.min(200, (int) ((Math.max(0, fraction) + 0.15) * 255)));
 501 	}
 502 
 503 	public static ItemRow buildGcPauseRow(IItemCollection items) {
 504 		IItemCollection pauseEvents = items.apply(JdkFilters.GC_PAUSE);
 505 		ISpanSeries&lt;RangePayload&gt; gcBackdrop = rangeSeries(pauseEvents, JfrAttributes.START_TIME,
 506 				JfrAttributes.END_TIME);
 507 		return new ItemRow(SpanRenderer.build(gcBackdrop, GC_COLOR), pauseEvents);
 508 	}
 509 
 510 	public static ItemRow buildApplicationPauseRow(IItemCollection items) {
 511 		IItemFilter vmOperationPauseFilter = ItemFilters.and(JdkFilters.VM_OPERATIONS,
 512 				ItemFilters.equals(JdkAttributes.SAFEPOINT, true));
 513 		IItemCollection applicationPauses = items
 514 				.apply(ItemFilters.or(JdkFilters.GC_PAUSE, JdkFilters.SAFE_POINTS, vmOperationPauseFilter));
 515 		ISpanSeries&lt;RangePayload&gt; pausesSeries = rangeSeries(applicationPauses, JfrAttributes.START_TIME,
 516 				JfrAttributes.END_TIME);
 517 		return new ItemRow(SpanRenderer.build(pausesSeries, APPLICATION_PAUSE_COLOR), applicationPauses);
 518 	}
 519 
 520 	public static IXDataRenderer buildTimestampHistogramRenderer(
 521 		IItemCollection items, IAggregator&lt;IQuantity, ?&gt; aggregator, IAttribute&lt;IQuantity&gt; timestampAttribute,
 522 		Color color) {
 523 		IQuantitySeries&lt;IQuantity[]&gt; aggregatorSeries = BucketBuilder.aggregatorSeries(items, aggregator,
 524 				timestampAttribute);
 525 		XYDataRenderer renderer = new XYDataRenderer(getKindOfQuantity(aggregator).getDefaultUnit().quantity(0),
 526 				aggregator.getName(), aggregator.getDescription());
 527 		renderer.addBarChart(aggregator.getName(), aggregatorSeries, color);
 528 		return renderer;
 529 	}
 530 
 531 	public static IXDataRenderer buildTimestampHistogramRenderer(
 532 		IItemCollection items, IAggregator&lt;IQuantity, ?&gt; aggregator, Color color) {
 533 		return buildTimestampHistogramRenderer(items, aggregator, JfrAttributes.CENTER_TIME, color);
 534 	}
 535 
 536 	public static ItemRow buildTimestampHistogram(
 537 		String title, String description, IItemCollection items, IAggregator&lt;IQuantity, ?&gt; aggregator,
 538 		IAttribute&lt;IQuantity&gt; timestampAttribute, Color color) {
 539 		return new ItemRow(title, description,
 540 				buildTimestampHistogramRenderer(items, aggregator, timestampAttribute, color), items);
 541 	}
 542 
 543 	public static ItemRow buildTimestampHistogram(
 544 		String title, String description, IItemCollection items, IAggregator&lt;IQuantity, ?&gt; aggregator, Color color) {
 545 		return new ItemRow(title, description, buildTimestampHistogramRenderer(items, aggregator, color), items);
 546 	}
 547 
 548 	public static ItemHistogram createDistinctItemsTable(
 549 		Composite parent, IItemCollection items, IItemQuery query, TableSettings settings) {
 550 		CompositeKeyHistogramBuilder histogramBuilder = new CompositeKeyHistogramBuilder();
 551 		for (IAttribute&lt;?&gt; attribute : query.getAttributes()) {
 552 			histogramBuilder.addKeyColumn(attribute);
 553 		}
 554 		for (IAggregator&lt;?, ?&gt; aggregator : query.getAggregators()) {
 555 			histogramBuilder.addColumn(aggregator.getName(), aggregator);
 556 		}
 557 		ItemHistogram table = histogramBuilder.buildWithoutBorder(parent, settings);
 558 		return table;
 559 	}
 560 
 561 	public static IBaseLabelProvider createTableHighlightProvider(Pattern highlightPattern, boolean isWarning) {
 562 		return new StyledCellLabelProvider() {
 563 			@Override
 564 			public void update(ViewerCell cell) {
 565 				org.eclipse.swt.graphics.Color color = isWarning
 566 						? new org.eclipse.swt.graphics.Color(Display.getCurrent(), 240, 120, 140)
 567 						: new org.eclipse.swt.graphics.Color(Display.getCurrent(), 255, 144, 4);
 568 				String text = getText(cell.getElement(), cell.getColumnIndex());
 569 				Matcher matcher = highlightPattern.matcher(text);
 570 				if (matcher.find()) {
 571 					cell.getViewerRow().setBackground(0, color);
 572 					cell.getViewerRow().setBackground(1, color);
 573 				}
 574 				cell.setText(text);
 575 				super.update(cell);
 576 			}
 577 
 578 			private String getText(Object element, int index) {
 579 				Object key = AggregationGrid.getKey(element);
 580 				Object[] keyElements = ((CompositeKey) key).getKeyElements();
 581 				return keyElements[index].toString();
 582 			}
 583 		};
 584 	}
 585 
 586 	public static void addContextMenus(
 587 		IPageContainer pc, ItemHistogram h, String selectionName, IAction ... extraActions) {
 588 		MCContextMenuManager mm = MCContextMenuManager.create(h.getManager().getViewer().getControl());
 589 		ColumnMenusFactory.addDefaultMenus(h.getManager(), mm);
 590 		SelectionStoreActionToolkit.addSelectionStoreActions(pc.getSelectionStore(), h, selectionName, mm);
 591 		for (IAction action : extraActions) {
 592 			mm.add(action);
 593 		}
 594 	}
 595 
 596 	public static IXDataRenderer buildSizeRow(
 597 		String title, String description, IItemCollection items, IAggregator&lt;IQuantity, ?&gt; a, Color color,
 598 		IColorProvider&lt;IItem&gt; cp) {
 599 		return RendererToolkit.layers(buildSpanRenderer(items, cp),
 600 				buildTimestampHistogram(title, description, items, a, color));
 601 	}
 602 
 603 	public static ItemRow buildDurationHistogram(
 604 		String title, String description, IItemCollection items, IAggregator&lt;IQuantity, ?&gt; a, Color color) {
 605 		IQuantitySeries&lt;IQuantity[]&gt; allocationSeries = BucketBuilder.aggregatorSeries(items, a,
 606 				JfrAttributes.DURATION);
 607 		XYDataRenderer renderer = new XYDataRenderer(getKindOfQuantity(a).getDefaultUnit().quantity(0), title,
 608 				description);
 609 		renderer.addBarChart(a.getName(), allocationSeries, color);
 610 		return new ItemRow(title, description, renderer, items);
 611 	}
 612 
 613 	public static ItemRow buildSizeHistogram(
 614 		String title, String description, IItemCollection items, IAggregator&lt;IQuantity, ?&gt; a, Color color,
 615 		IAttribute&lt;IQuantity&gt; attribute) {
 616 		IQuantitySeries&lt;IQuantity[]&gt; allocationSeries = BucketBuilder.aggregatorSeries(items, a, JdkAttributes.IO_SIZE);
 617 		XYDataRenderer renderer = new XYDataRenderer(getKindOfQuantity(a).getDefaultUnit().quantity(0), title,
 618 				description);
 619 		renderer.addBarChart(a.getName(), allocationSeries, color);
 620 		return new ItemRow(title, description, renderer, items);
 621 	}
 622 
 623 	public static IRange&lt;IQuantity&gt; buildSizeRange(IItemCollection items, boolean isSocket) {
 624 		IQuantity end = null;
 625 		if (isSocket) {
 626 			end = QuantitiesToolkit.maxPresent(items.getAggregate(JdkAggregators.SOCKET_READ_LARGEST),
 627 					items.getAggregate(JdkAggregators.SOCKET_WRITE_LARGEST));
 628 		} else {
 629 			end = QuantitiesToolkit.maxPresent(items.getAggregate(JdkAggregators.FILE_READ_LARGEST),
 630 					items.getAggregate(JdkAggregators.FILE_WRITE_LARGEST));
 631 		}
 632 		end = end == null ? UnitLookup.BYTE.quantity(1024) : end;
 633 		return QuantityRange.createWithEnd(UnitLookup.BYTE.quantity(0), end);
 634 	}
 635 
 636 	// FIXME: Make something that can use something other than time as x-axis?
 637 	public static IXDataRenderer buildSpanRenderer(IItemCollection pathItems, IColorProvider&lt;IItem&gt; cp) {
 638 		ISpanSeries&lt;IItem&gt; dataSeries = QuantitySeries.max(pathItems, JfrAttributes.START_TIME, JfrAttributes.END_TIME);
 639 		return SpanRenderer.withBoundaries(dataSeries, cp);
 640 	}
 641 
 642 	public static boolean addEndTimeLines(
 643 		XYDataRenderer renderer, IItemCollection items, boolean fill, Stream&lt;IAttribute&lt;IQuantity&gt;&gt; yAttributes) {
 644 		// FIXME: JMC-4520 - Handle multiple item iterables
 645 		Iterator&lt;IItemIterable&gt; ii = items.iterator();
 646 		if (ii.hasNext()) {
 647 			IItemIterable itemStream = ii.next();
 648 			IType&lt;IItem&gt; type = itemStream.getType();
 649 			// FIXME: A better way to ensure sorting by endTime
 650 			return yAttributes.peek(a -&gt; addEndTimeLine(renderer, itemStream.iterator(), type, a, fill))
 651 					.mapToLong(a -&gt; 1L).sum() &gt; 0;
 652 		}
 653 		return false;
 654 	}
 655 
 656 	public static void addEndTimeLine(
 657 		XYDataRenderer renderer, Iterator&lt;? extends IItem&gt; items, IType&lt;IItem&gt; type, IAttribute&lt;IQuantity&gt; yAttribute,
 658 		boolean fill) {
 659 		IQuantitySeries&lt;?&gt; qs = buildQuantitySeries(items, type, JfrAttributes.END_TIME, yAttribute);
 660 		renderer.addLineChart(yAttribute.getName(), qs, getFieldColor(yAttribute), fill);
 661 	}
 662 
 663 	public static IQuantitySeries&lt;?&gt; buildQuantitySeries(
 664 		Iterator&lt;? extends IItem&gt; items, IType&lt;IItem&gt; type, IAttribute&lt;IQuantity&gt; xAttribute,
 665 		IAttribute&lt;IQuantity&gt; yAttribute) {
 666 		IMemberAccessor&lt;IQuantity, IItem&gt; yAccessor = yAttribute.getAccessor(type);
 667 		if (yAccessor == null) {
 668 			throw new RuntimeException(yAttribute.getIdentifier() + &quot; is not an attribute for &quot; + type.getIdentifier()); //$NON-NLS-1$
 669 		}
 670 		return buildQuantitySeries(items, type, xAttribute, yAccessor);
 671 	}
 672 
 673 	public static IQuantitySeries&lt;?&gt; buildQuantitySeries(
 674 		Iterator&lt;? extends IItem&gt; items, IType&lt;IItem&gt; type, IAttribute&lt;IQuantity&gt; xAttribute,
 675 		IMemberAccessor&lt;? extends IQuantity, IItem&gt; yAccessor) {
 676 		IMemberAccessor&lt;IQuantity, IItem&gt; xAccessor = xAttribute.getAccessor(type);
 677 		return QuantitySeries.all(items, xAccessor, yAccessor);
 678 	}
 679 
 680 	public static void createChartTooltip(ChartCanvas chart) {
 681 		createChartTooltip(chart, ChartToolTipProvider::new);
 682 	}
 683 
 684 	public static void createChartTimestampTooltip(ChartCanvas chart) {
 685 		createChartTooltip(chart, JfrAttributes.START_TIME, JfrAttributes.END_TIME, JfrAttributes.DURATION,
 686 				JfrAttributes.EVENT_TYPE, JfrAttributes.EVENT_STACKTRACE);
 687 	}
 688 
 689 	public static void createChartTooltip(ChartCanvas chart, IAttribute&lt;?&gt; ... excludedAttributes) {
 690 		createChartTooltip(chart, new HashSet&lt;&gt;(Arrays.asList(excludedAttributes)));
 691 	}
 692 
 693 	public static void createChartTooltip(ChartCanvas chart, Set&lt;IAttribute&lt;?&gt;&gt; excludedAttributes) {
 694 		createChartTooltip(chart, () -&gt; new ChartToolTipProvider() {
 695 			@SuppressWarnings(&quot;deprecation&quot;)
 696 			@Override
 697 			protected Stream&lt;IAttribute&lt;?&gt;&gt; getAttributeStream(IType&lt;IItem&gt; type) {
 698 				return type.getAttributes().stream().filter(a -&gt; !excludedAttributes.contains(a));
 699 			}
 700 		});
 701 	}
 702 
 703 	public static void createChartTooltip(ChartCanvas chart, Supplier&lt;ChartToolTipProvider&gt; toolTipProviderSupplier) {
 704 		new ToolTip(chart) {
 705 			String html;
 706 			Map&lt;String, Image&gt; images;
 707 
 708 			@Override
 709 			protected boolean shouldCreateToolTip(Event event) {
 710 				ChartToolTipProvider provider = toolTipProviderSupplier.get();
 711 				chart.infoAt(provider, event.x, event.y);
 712 				html = provider.getHTML();
 713 				images = provider.getImages();
 714 				return html != null;
 715 			}
 716 
 717 			@Override
 718 			protected Composite createToolTipContentArea(Event event, Composite parent) {
 719 				FormText formText = CompositeToolkit.createInfoFormText(parent);
 720 				for (Map.Entry&lt;String, Image&gt; imgEntry : images.entrySet()) {
 721 					formText.setImage(imgEntry.getKey(), imgEntry.getValue());
 722 				}
 723 				formText.setText(html, true, false);
 724 				return formText;
 725 			}
 726 
 727 		};
 728 
 729 	}
 730 
 731 	private static KindOfQuantity&lt;?&gt; getKindOfQuantity(IAggregator&lt;IQuantity, ?&gt; a) {
 732 		IType&lt;? super IQuantity&gt; ct = a.getValueType();
 733 		// FIXME: Refactor to avoid this cast
 734 		return ((KindOfQuantity&lt;?&gt;) ct);
 735 	}
 736 
 737 	public static Form createForm(Composite parent, FormToolkit toolkit, String title, Image img) {
 738 		Form form = toolkit.createForm(parent);
 739 		form.setText(title.replaceAll(&quot;&amp;&quot;, &quot;&amp;&amp;&quot;)); //$NON-NLS-1$ //$NON-NLS-2$
 740 		form.setImage(img);
 741 		toolkit.decorateFormHeading(form);
 742 		FillLayout fillLayout = new FillLayout();
 743 		fillLayout.marginHeight = 15;
 744 		fillLayout.marginWidth = 8;
 745 		form.getBody().setLayout(fillLayout);
 746 		form.getToolBarManager().add(new Separator(FORM_TOOLBAR_PAGE_RESULTS));
 747 		form.getToolBarManager().add(new Separator(FORM_TOOLBAR_PAGE_SETUP));
 748 		form.getToolBarManager().add(new Separator(FORM_TOOLBAR_PAGE_NAV));
 749 		return form;
 750 	}
 751 
 752 	public static class ShowResultAction extends Action {
 753 
 754 		private String[] topics;
 755 		private final IPageContainer pageContainer;
 756 		private volatile Severity maxSeverity;
 757 		private final List&lt;Consumer&lt;Result&gt;&gt; listeners = new ArrayList&lt;&gt;();
 758 
 759 		ShowResultAction(String title, int style, ImageDescriptor icon, Supplier&lt;String&gt; tooltip,
 760 				IPageContainer pageContainer, String ... topics) {
 761 			super(title, style);
 762 			setImageDescriptor(icon);
 763 			setToolTipText(tooltip.get());
 764 			this.topics = topics;
 765 			this.pageContainer = pageContainer;
 766 			maxSeverity = pageContainer.getRuleManager().getMaxSeverity(topics);
 767 			for (String topic : topics) {
 768 				Consumer&lt;Result&gt; listener = result -&gt; {
 769 					Severity severity = Severity.get(result.getScore());
 770 					if (severity.compareTo(maxSeverity) &gt; 0) {
 771 						maxSeverity = severity;
 772 						setImageDescriptor(getResultIcon(maxSeverity));
 773 					} else if (severity.compareTo(maxSeverity) &lt; 0) { // severity could be less than previous max
 774 						maxSeverity = pageContainer.getRuleManager().getMaxSeverity(topics);
 775 					}
 776 					setToolTipText(tooltip.get());
 777 				};
 778 				listeners.add(listener);
 779 				pageContainer.getRuleManager().addResultListener(topic, listener);
 780 			}
 781 		}
 782 
 783 		private void removeListeners() {
 784 			listeners.forEach(l -&gt; pageContainer.getRuleManager().removeResultListener(l));
 785 		}
 786 
 787 		@Override
 788 		public void run() {
 789 			pageContainer.showResults(topics);
 790 		}
 791 	}
 792 
 793 	public static void addRuleResultAction(
 794 		Form form, IPageContainer pageContainer, Supplier&lt;String&gt; tooltip, String[] topics) {
 795 		if (topics == null || topics.length == 0 || !FlightRecorderUI.getDefault().isAnalysisEnabled()) {
 796 			return;
 797 		}
 798 		ImageDescriptor icon = getResultIcon(pageContainer.getRuleManager().getMaxSeverity(topics));
 799 		ShowResultAction resultAction = new ShowResultAction(Messages.RULES_SHOW_RESULTS_ACTION, IAction.AS_PUSH_BUTTON,
 800 				icon, tooltip, pageContainer, topics);
 801 		resultAction.setId(RESULT_ACTION_ID);
 802 		form.getToolBarManager().appendToGroup(DataPageToolkit.FORM_TOOLBAR_PAGE_RESULTS, resultAction);
 803 		form.getToolBarManager().update(true);
 804 		form.addDisposeListener(e -&gt; resultAction.removeListeners());
 805 	}
 806 
 807 	private static ImageDescriptor getResultIcon(Severity severity) {
 808 		switch (severity) {
 809 		case OK:
 810 			return ResultOverview.ICON_OK;
 811 		case INFO:
 812 			return ResultOverview.ICON_INFO;
 813 		case WARNING:
 814 			return ResultOverview.ICON_WARNING;
 815 		case NA:
 816 			return ResultOverview.ICON_NA;
 817 		}
 818 		return null;
 819 	}
 820 
 821 	/**
 822 	 * Return a disabled Action.
 823 	 *
 824 	 * @param text
 825 	 *            text to be displayed by the MenuItem, and represent it as it&#39;s id.
 826 	 * @return an Action containing the desired text, which will be disabled in a UI component.
 827 	 */
 828 	public static IAction disabledAction(String text) {
 829 		IAction disabledAction = new Action(text) {
 830 			@Override
 831 			public boolean isEnabled() {
 832 				return false;
 833 			}
 834 		};
 835 		disabledAction.setId(text);
 836 		return disabledAction;
 837 	}
 838 
 839 	public static FilterEditor buildFilterSelector(
 840 		Composite parent, IItemFilter filter, IItemCollection items, Supplier&lt;Stream&lt;SelectionStoreEntry&gt;&gt; selections,
 841 		Consumer&lt;IItemFilter&gt; onSelect, boolean hasBorder) {
 842 		Supplier&lt;Collection&lt;IAttribute&lt;?&gt;&gt;&gt; attributeSupplier = () -&gt; getPersistableAttributes(
 843 				getAttributes(filter != null ? items.apply(filter) : items)).collect(Collectors.toList());
 844 
 845 		AttributeValueProvider valueSupplier = new AttributeValueProvider() {
 846 			@Override
 847 			public &lt;V&gt; V defaultValue(ICanonicalAccessorFactory&lt;V&gt; attribute) {
 848 				return findValueForFilter(items, attribute);
 849 			}
 850 		};
 851 
 852 		FilterEditor editor = new FilterEditor(parent, onSelect, filter, attributeSupplier, valueSupplier,
 853 				TypeLabelProvider::getColorOrDefault, hasBorder ? SWT.BORDER : SWT.NONE);
 854 
 855 		MenuManager addFromSelectionPredicate = new MenuManager(Messages.FILTER_ADD_FROM_SELECTION);
 856 		editor.getContextMenu().prependToGroup(MCContextMenuManager.GROUP_NEW, addFromSelectionPredicate);
 857 		addFromSelectionPredicate.setRemoveAllWhenShown(true);
 858 		addFromSelectionPredicate.addMenuListener(new IMenuListener() {
 859 
 860 			@Override
 861 			public void menuAboutToShow(IMenuManager manager) {
 862 				selections.get().forEach(entry -&gt; {
 863 					MenuManager selectionFlavors = new MenuManager(entry.getName());
 864 					entry.getSelection().getFlavors(editor.getFilter(), items, null)
 865 							.filter(f -&gt; f instanceof IFilterFlavor).forEach(flavor -&gt; {
 866 								selectionFlavors.add(new Action(flavor.getName()) {
 867 									@Override
 868 									public void run() {
 869 										editor.addRoot(((IFilterFlavor) flavor).getFilter());
 870 									}
 871 								});
 872 							});
 873 					if (!selectionFlavors.isEmpty()) {
 874 						if (manager.find(Messages.FILTER_NO_SELECTION_AVAILABLE) != null) {
 875 							manager.remove(Messages.FILTER_NO_SELECTION_AVAILABLE);
 876 						}
 877 						manager.add(selectionFlavors);
 878 					} else {
 879 						manager.add(disabledAction(Messages.FILTER_NO_SELECTION_AVAILABLE));
 880 					}
 881 				});
 882 			}
 883 		});
 884 
 885 		// FIXME: This could potentially move into the FilterEditor class
 886 		MenuManager addAttributeValuePredicate = new MenuManager(Messages.FILTER_ADD_FROM_ATTRIBUTE);
 887 		editor.getContextMenu().prependToGroup(MCContextMenuManager.GROUP_NEW, addAttributeValuePredicate);
 888 		addAttributeValuePredicate.setRemoveAllWhenShown(true);
 889 		addAttributeValuePredicate.addMenuListener(new IMenuListener() {
 890 			Collection&lt;IAttribute&lt;?&gt;&gt; attributes;
 891 
 892 			@Override
 893 			public void menuAboutToShow(IMenuManager manager) {
 894 				if (attributes == null) {
 895 					attributes = attributeSupplier.get();
 896 				}
 897 				if (!attributes.isEmpty()) {
 898 					if (manager.find(Messages.FILTER_NO_ATTRIBUTE_AVAILABLE) != null) {
 899 						manager.remove(Messages.FILTER_NO_ATTRIBUTE_AVAILABLE);
 900 					}
 901 					attributes.stream().distinct().sorted((a1, a2) -&gt; a1.getName().compareTo(a2.getName()))
 902 							.forEach(attr -&gt; {
 903 								addAttributeValuePredicate.add(new Action(attr.getName()) {
 904 									@Override
 905 									public void run() {
 906 										IItemFilter filter = createDefaultFilter(items, attr);
 907 										editor.addRoot(filter);
 908 									}
 909 								});
 910 							});
 911 				} else {
 912 					manager.add(disabledAction(Messages.FILTER_NO_ATTRIBUTE_AVAILABLE));
 913 				}
 914 
 915 			}
 916 		});
 917 		return editor;
 918 	}
 919 
 920 	// FIXME: Move to some AttributeToolkit?
 921 	@SuppressWarnings(&quot;deprecation&quot;)
 922 	private static Stream&lt;IAttribute&lt;?&gt;&gt; getAttributes(IItemCollection items) {
 923 		return ItemCollectionToolkit.stream(items).filter(IItemIterable::hasItems)
 924 				.flatMap(is -&gt; is.getType().getAttributes().stream());
 925 	}
 926 
 927 	public static Stream&lt;IAttribute&lt;?&gt;&gt; getPersistableAttributes(Stream&lt;IAttribute&lt;?&gt;&gt; attributes) {
 928 		// FIXME: Would like to always be able to persist a string representation of the attribute, because this is usable by filters.
 929 
 930 		// FIXME: Should we always include event type? Does it make any sense, except on the custom pages?
 931 
 932 		// FIXME: Transform both START_TIME and END_TIME to LIFETIME?
 933 		// FIXME: Add derived attributes, like a conversion of any THREAD or CLASS attribute? Thread group?
 934 		/*
 935 		 * Make sure to do the conversions in the right order, so for example a stack trace can be
 936 		 * converted to a top method, which then is converted to a method string.
 937 		 */
 938 		return attributes.map(a -&gt; a.equals(JfrAttributes.EVENT_THREAD) ? JdkAttributes.EVENT_THREAD_NAME : a)
 939 				.flatMap(a -&gt; a.equals(JfrAttributes.EVENT_STACKTRACE) ? Stream.of(JdkAttributes.STACK_TRACE_STRING,
 940 						JdkAttributes.STACK_TRACE_TOP_METHOD_STRING, JdkAttributes.STACK_TRACE_TOP_CLASS_STRING,
 941 						JdkAttributes.STACK_TRACE_TOP_PACKAGE, JdkAttributes.STACK_TRACE_BOTTOM_METHOD_STRING)
 942 						: Stream.of(a))
 943 				.map(a -&gt; a.equals(JdkAttributes.COMPILER_METHOD) ? JdkAttributes.COMPILER_METHOD_STRING : a)
 944 				// FIXME: String or id?
 945 				.map(a -&gt; a.equals(JdkAttributes.REC_SETTING_FOR) ? JdkAttributes.REC_SETTING_FOR_NAME : a)
 946 				.map(a -&gt; a.equals(JdkAttributes.CLASS_DEFINING_CLASSLOADER)
 947 						? JdkAttributes.CLASS_DEFINING_CLASSLOADER_STRING : a)
 948 				.map(a -&gt; a.equals(JdkAttributes.CLASS_INITIATING_CLASSLOADER)
 949 						? JdkAttributes.CLASS_INITIATING_CLASSLOADER_STRING : a)
 950 				.map(a -&gt; a.equals(JdkAttributes.PARENT_CLASSLOADER) ? JdkAttributes.PARENT_CLASSLOADER_STRING : a)
 951 				.map(a -&gt; a.equals(JdkAttributes.CLASSLOADER) ? JdkAttributes.CLASSLOADER_STRING : a)
 952 				.filter(a -&gt; a.equals(JfrAttributes.EVENT_TYPE) || (a.getContentType() instanceof RangeContentType)
 953 						|| (a.getContentType().getPersister() != null))
 954 				.distinct();
 955 	}
 956 
 957 	/**
 958 	 * Returns a value for attribute, firstly by trying to find one in the items, secondly by
 959 	 * creating a default value for some known content types. Returns null if the first two cases
 960 	 * fail.
 961 	 *
 962 	 * @param items
 963 	 * @param attribute
 964 	 * @return a value of type V, or null
 965 	 */
 966 	@SuppressWarnings(&quot;unchecked&quot;)
 967 	private static &lt;V&gt; V findValueForFilter(IItemCollection items, ICanonicalAccessorFactory&lt;V&gt; attribute) {
 968 		IItem firstItem = ItemCollectionToolkit.stream(items).filter(is -&gt; is.getType().hasAttribute(attribute))
 969 				.flatMap(ItemIterableToolkit::stream)
 970 				.filter(i -&gt; ((IMemberAccessor&lt;V, IItem&gt;) attribute.getAccessor(i.getType())).getMember(i) != null)
 971 				.findFirst().orElse(null);
 972 		if (firstItem != null) {
 973 			IMemberAccessor&lt;V, IItem&gt; accessor = (IMemberAccessor&lt;V, IItem&gt;) attribute.getAccessor(firstItem.getType());
 974 			return accessor.getMember(firstItem);
 975 		}
 976 		if (UnitLookup.PLAIN_TEXT.equals(attribute.getContentType())) {
 977 			return (V) &quot;&quot;; //$NON-NLS-1$
 978 		}
 979 		if (attribute.getContentType() instanceof KindOfQuantity&lt;?&gt;) {
 980 			return (V) ((KindOfQuantity&lt;?&gt;) attribute.getContentType()).getDefaultUnit().quantity(0);
 981 		}
 982 		return null;
 983 	}
 984 
 985 	/**
 986 	 * Returns an default filter for attribute, which might be an equals filter, hasAttribute
 987 	 * filter, or type filter, depending on the attribute and the contents of the items.
 988 	 *
 989 	 * @param items
 990 	 * @param attribute
 991 	 * @return a filter
 992 	 */
 993 	// FIXME: Should move to FilterEditor, or some subclass/specialization?
 994 	private static &lt;V&gt; IItemFilter createDefaultFilter(IItemCollection items, ICanonicalAccessorFactory&lt;V&gt; attribute) {
 995 		V value = findValueForFilter(items, attribute);
 996 		if (value == null) {
 997 			return ItemFilters.hasAttribute(attribute);
 998 		} else if (attribute.equals(JfrAttributes.EVENT_TYPE)) {
 999 			return ItemFilters.type(((IType&lt;?&gt;) value).getIdentifier());
1000 		}
1001 		return ItemFilters.equals(attribute, value);
1002 	}
1003 
1004 	public static void addRenameAction(Form form, IPageContainer editor) {
1005 		form.getMenuManager().add(new Action(Messages.PAGE_RENAME_MENU_ACTION) {
1006 			@Override
1007 			public void run() {
1008 				InputDialog dialog = new InputDialog(form.getShell(), Messages.PAGE_RENAME_DIALOG_TITLE,
1009 						Messages.PAGE_RENAME_DIALOG_MESSAGE, form.getText(), null);
1010 				if (dialog.open() == Window.OK) {
1011 					form.setText(dialog.getValue());
1012 					editor.currentPageRefresh();
1013 				}
1014 			}
1015 		});
1016 	}
1017 
1018 	public static void addIconChangeAction(Form form, IPageContainer editor, Consumer&lt;Image&gt; newIconConsumer) {
1019 		form.getMenuManager().add(new Action(Messages.PAGE_CHANGE_ICON_MENU_ACTION) {
1020 			@Override
1021 			public void run() {
1022 				WizardDialog dialog = new WizardDialog(form.getShell(),
1023 						new IconChangeWizard(form.getImage(), newIconConsumer));
1024 				dialog.open();
1025 				editor.currentPageRefresh();
1026 			}
1027 		});
1028 	}
1029 
1030 	private static class IconChangeWizard extends Wizard {
1031 
1032 		private final Image currentImage;
1033 		private final Consumer&lt;Image&gt; imageConsumer;
1034 		private Label imageLabel;
1035 
1036 		public IconChangeWizard(Image currentImage, Consumer&lt;Image&gt; imageConsumer) {
1037 			setWindowTitle(Messages.PAGE_CHANGE_ICON_WIZARD_TITLE);
1038 			this.currentImage = currentImage;
1039 			this.imageConsumer = imageConsumer;
1040 		}
1041 
1042 		@Override
1043 		public void addPages() {
1044 			addPage(new WizardPage(Messages.PAGE_CHANGE_ICON_WIZARD_PAGE_TITLE) {
1045 
1046 				@Override
1047 				public String getTitle() {
1048 					return Messages.PAGE_CHANGE_ICON_WIZARD_PAGE_TITLE;
1049 				}
1050 
1051 				@Override
1052 				public String getDescription() {
1053 					return Messages.PAGE_CHANGE_ICON_WIZARD_PAGE_DESC;
1054 				}
1055 
1056 				@Override
1057 				public void createControl(Composite parent) {
1058 					Composite container = new Composite(parent, SWT.NONE);
1059 					GridLayout layout = new GridLayout(1, false);
1060 					container.setLayout(layout);
1061 
1062 					Button button = new Button(container, SWT.NONE);
1063 					button.setText(Messages.PAGE_CHANGE_ICON_CHOOSE_IMAGE_FILE);
1064 
1065 					button.addSelectionListener(new SelectionAdapter() {
1066 						@Override
1067 						public void widgetSelected(SelectionEvent e) {
1068 							chooseImageFileDialog();
1069 						}
1070 					});
1071 
1072 					if (currentImage != null) {
1073 						new Label(container, SWT.NONE).setText(Messages.PAGE_CHANGE_ICON_CURRENT_ICON);
1074 						new Label(container, SWT.BORDER).setImage(currentImage);
1075 					}
1076 					new Label(container, SWT.NONE).setText(Messages.PAGE_CHANGE_ICON_NEW_ICON_PREVIEW);
1077 					imageLabel = new Label(container, SWT.BORDER);
1078 					GridData gd = new GridData(16, 16);
1079 					imageLabel.setLayoutData(gd);
1080 
1081 					setControl(container);
1082 				}
1083 
1084 				private void chooseImageFileDialog() {
1085 					FileDialog fileDialog = new FileDialog(getShell(), SWT.OPEN);
1086 					String[] filterNames = new String[] {&quot;Image Files&quot;, &quot;All Files (*)&quot;}; //$NON-NLS-1$ //$NON-NLS-2$
1087 					String[] filterExtensions = new String[] {&quot;*.gif;*.png;*.xpm;*.jpg;*.jpeg;*.tiff&quot;, &quot;*&quot;}; //$NON-NLS-1$ //$NON-NLS-2$
1088 					fileDialog.setFilterNames(filterNames);
1089 					fileDialog.setFilterExtensions(filterExtensions);
1090 					String filename = fileDialog.open();
1091 					if (filename == null) {
1092 						// Dialog was cancelled. Bail out early to avoid handling that case later. Premature?
1093 						return;
1094 					}
1095 					try (InputStream fis = new FileInputStream(filename)) {
1096 						ImageData imageData = new ImageData(fis);
1097 						// Validate image data
1098 						if (imageData.width != 16 || imageData.height != 16) {
1099 							imageData = resizeImage(imageData, 16, 16);
1100 						}
1101 						DisplayToolkit.dispose(imageLabel.getImage());
1102 						imageLabel.setImage(new Image(getShell().getDisplay(), imageData));
1103 						imageLabel.getParent().layout();
1104 						setPageComplete(isPageComplete());
1105 					} catch (Exception e) {
1106 						// FIXME: Add proper logging
1107 						e.printStackTrace();
1108 					}
1109 				}
1110 
1111 				private ImageData resizeImage(ImageData imageData, int width, int height) {
1112 					Image original = ImageDescriptor.createFromImageDataProvider((zoom) -&gt; imageData).createImage();
1113 					Image scaled = new Image(Display.getDefault(), width, height);
1114 					GC gc = new GC(scaled);
1115 					gc.setAntialias(SWT.ON);
1116 					gc.setInterpolation(SWT.HIGH);
1117 					gc.drawImage(original, 0, 0, imageData.width, imageData.height, 0, 0, width, height);
1118 					gc.dispose();
1119 					original.dispose();
1120 					ImageData scaledData = scaled.getImageData();
1121 					scaled.dispose();
1122 					return scaledData;
1123 				}
1124 
1125 				@Override
1126 				public boolean isPageComplete() {
1127 					return imageLabel.getImage() != null;
1128 				}
1129 
1130 			});
1131 		}
1132 
1133 		@Override
1134 		public boolean performFinish() {
1135 			imageConsumer.accept(imageLabel.getImage());
1136 			DisplayToolkit.dispose(currentImage);
1137 			return true;
1138 		}
1139 
1140 		@Override
1141 		public boolean performCancel() {
1142 			DisplayToolkit.dispose(imageLabel.getImage());
1143 			return true;
1144 		}
1145 
1146 	}
1147 
1148 	public static ItemList createSimpleItemList(
1149 		Composite parent, ItemListBuilder listBuilder, IPageContainer pageContainer, TableSettings tableSettings,
1150 		String selectionName) {
1151 
1152 		ItemList list = listBuilder.build(parent, tableSettings);
1153 		ColumnViewer viewer = list.getManager().getViewer();
1154 		MCContextMenuManager mm = MCContextMenuManager.create(viewer.getControl());
1155 		list.setMenuManager(mm);
1156 		ColumnMenusFactory.addDefaultMenus(list.getManager(), mm);
1157 		viewer.addSelectionChangedListener(
1158 				e -&gt; pageContainer.showSelection(ItemCollectionToolkit.build(list.getSelection().get())));
1159 
1160 		if (selectionName != null) {
1161 			SelectionStoreActionToolkit.addSelectionStoreActions(pageContainer.getSelectionStore(), list, selectionName,
1162 					mm);
1163 		}
1164 
1165 		return list;
1166 	}
1167 
1168 	public static void addTabItem(CTabFolder tabFolder, Control section, String name) {
1169 		CTabItem tabItem = new CTabItem(tabFolder, SWT.NONE);
1170 		tabItem.setControl(section);
1171 		tabItem.setText(name);
1172 	}
1173 
1174 	public static TypeFilterBuilder buildEventTypeTree(
1175 		Composite parent, FormToolkit toolkit, Runnable onChange, boolean checkbox) {
1176 		// TODO: Make more accessible.
1177 		// TODO: Add support for storing the expansion state in a memento.
1178 		// TODO: Add input from selection store, output to selection store
1179 		// TODO: Add toolbar for choosing tree or checkbox tree.
1180 		Composite treeComposite = new Composite(parent, SWT.NONE);
1181 		treeComposite.setLayout(new GridLayout());
1182 		toolkit.adapt(treeComposite);
1183 		Label caption = toolkit.createLabel(treeComposite, Messages.EVENT_TYPE_TREE_TITLE);
1184 		caption.setFont(JFaceResources.getFontRegistry().getBold(JFaceResources.DEFAULT_FONT));
1185 		caption.setLayoutData(new GridData(SWT.FILL, SWT.TOP, true, false));
1186 
1187 		TypeFilterBuilder typeFilterTree = new TypeFilterBuilder(treeComposite, onChange, checkbox);
1188 
1189 		typeFilterTree.getControl().setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
1190 		return typeFilterTree;
1191 	}
1192 
1193 	public static boolean isTypeWithThreadAndDuration(IType&lt;?&gt; type) {
1194 		return JfrAttributes.EVENT_THREAD.getAccessor(type) != null
1195 				&amp;&amp; JfrAttributes.START_TIME.getAccessor(type) != JfrAttributes.END_TIME.getAccessor(type);
1196 	}
1197 
1198 	public static void addPage(Set&lt;IType&lt;?&gt;&gt; selectedTypes) {
1199 		PageManager pm = FlightRecorderUI.getDefault().getPageManager();
1200 		pm.makeRoot(pm.createPage(ItemHandlerPage.Factory.class, new ItemHandlerUiStandIn(selectedTypes)));
1201 	}
1202 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>