diff a/application/org.openjdk.jmc.flightrecorder.ui/defaultPages.xml b/application/org.openjdk.jmc.flightrecorder.ui/defaultPages.xml
--- a/application/org.openjdk.jmc.flightrecorder.ui/defaultPages.xml
+++ b/application/org.openjdk.jmc.flightrecorder.ui/defaultPages.xml
@@ -236,165 +236,301 @@
             </threadLane>
           <threadLane name="Other Types" enabled="false" editable="false" isRestLane="true"/>
   		</state>
   		<page factory="org.openjdk.jmc.flightrecorder.ui.threads" id="org.openjdk.jmc.flightrecorder.ui.threads">
   			<state>
-  			<sash weights="1,5" />
-  			<threadLane name="EJB">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Database_Access"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/EJB/EJB_Home_Remove"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Timer_Manager"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/EJB/EJB_Home_Create"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Pool_Manager_Remove"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Business_Method_Post_Invoke_Cleanup"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/EJB/EJB_Pool_Manager_Create"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Replicated_Session_Manager"/>
-                </filter>
-            </threadLane>
-            <threadLane name="EJB Business Method Invoke" enabled="true">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/EJB/EJB_Business_Method_Invoke"/>
-                </filter>
-            </threadLane>
-            <threadLane name="JDBC" enabled="true">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/JDBC/JDBC_Statement_Execute"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Data_Source_Get_Connection"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Driver_Connect"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Statement_Creation"/>
-                </filter>
-            </threadLane>
-            <threadLane name="JDBC Connection">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Reserve"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Create_Statement"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Commit"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Prepare"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Release"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/JDBC/JDBC_Connection_Rollback"/>
-                </filter>
-            </threadLane>
-           <threadLane name="JDBC Connection Close">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Close"/>
-                </filter>
-            </threadLane>
-            <threadLane name="Servlet Request Run" enabled="true">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Servlet_Request_Run"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Servlet_Request_Run_Begin"/>
-                </filter>
-            </threadLane>
-            <threadLane name="Web Application Load">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Web_Application_Load"/>
-                </filter>
-            </threadLane>
-            <threadLane name="Servlet Execute">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Execute"/>
-                </filter>
-            </threadLane>
-           <threadLane name="Servlet Context Execute">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Context_Execute"/>
-                </filter>
-            </threadLane>
-            <threadLane name="Servlet Invocation">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Servlet_Invocation"/>
-                </filter>
-            </threadLane>
-            <threadLane name="Servlet Filter">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Check_Access"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Filter"/>
-                </filter>
-            </threadLane>
-            <threadLane name="Servlet Request">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Request"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Request_Dispatch"/>
-                </filter>
-            </threadLane>
-            <threadLane name="Servlet Response Write Headers/Stale Resource">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Response_Write_Headers"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Stale_Resource"/>
-                </filter>
-            </threadLane>
-            <threadLane name="Servlet Response Send">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Response_Send"/>
-                </filter>
-            </threadLane>
-            <threadLane name="JAX-RPC">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Client_Response"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Client_Request"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Request"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Response"/>
-                </filter>
-            </threadLane>
-            <threadLane name="WebServices" enabled="true">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Dispatch"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXWS/Webservices_JAXWS_Request"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXWS/Webservices_JAXWS_Endpoint"/>
-                </filter>
-            </threadLane>
-            <threadLane name="DMS">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/dms-context/dms/ExecutionContext/span"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/dms-anonymous-phase/dms/AnonymousPhase/span"/>
-                </filter>
-            </threadLane>
-            <threadLane name="DMS execution context start">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/dms-context/dms/ExecutionContext/start"/>
-                </filter>
-            </threadLane>
-            <threadLane name="DMS HTTP">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/dms-http/dms/HttpRequest/span"/>
-                    <filter kind="TYPE" type="http://www.oracle.com/dms-http/dms/HttpRequest/start"/>
-                </filter>
-            </threadLane>
-            <threadLane name="JavaFX Pulse" enabled="true">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/technetwork/java/javafx/index.html/javafx/pulse"/>
-                </filter>
-            </threadLane>
-            <threadLane name="JavaFX Input" enabled="true">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="http://www.oracle.com/technetwork/java/javafx/index.html/javafx/input"/>
-                </filter>
-            </threadLane>
-            <threadLane name="Java Latencies" enabled="true">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="jdk.JavaMonitorEnter"/>
-                    <filter kind="TYPE" type="jdk.SocketRead"/>
-                    <filter kind="TYPE" type="jdk.Compilation"/>
-                    <filter kind="TYPE" type="jdk.ExecutionSampling"/>
-                    <filter kind="TYPE" type="jdk.SocketWrite"/>
-                    <filter kind="TYPE" type="jdk.ClassLoad"/>
-                    <filter kind="TYPE" type="jdk.ThreadPark"/>
-                    <filter kind="TYPE" type="jdk.FileWrite"/>
-                    <filter kind="TYPE" type="jdk.ThreadSleep"/>
-                    <filter kind="TYPE" type="jdk.JavaMonitorWait"/>
-                    <filter kind="TYPE" type="jdk.FileRead"/>
-                </filter>
-            </threadLane>
-            <threadLane name="JVM Compiler">
-                <filter kind="OR">
-                    <filter kind="TYPE" type="jdk.SweepCodeCache"/>
-                    <filter kind="TYPE" type="jdk.CompilerPhase"/>
-                </filter>
-            </threadLane>
-          <threadLane name="Other Types" enabled="false" editable="false" isRestLane="true"/>
+	  			<sash weights="1,5" />
+	  			<threadLane name="EJB">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Database_Access"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/EJB/EJB_Home_Remove"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Timer_Manager"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/EJB/EJB_Home_Create"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Pool_Manager_Remove"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Business_Method_Post_Invoke_Cleanup"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/EJB/EJB_Pool_Manager_Create"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Replicated_Session_Manager"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="EJB Business Method Invoke" enabled="true">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/EJB/EJB_Business_Method_Invoke"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="JDBC" enabled="true">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/JDBC/JDBC_Statement_Execute"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Data_Source_Get_Connection"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Driver_Connect"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Statement_Creation"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="JDBC Connection">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Reserve"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Create_Statement"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Commit"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Prepare"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Release"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/JDBC/JDBC_Connection_Rollback"/>
+	                </filter>
+	            </threadLane>
+	           <threadLane name="JDBC Connection Close">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Close"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="Servlet Request Run" enabled="true">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Servlet_Request_Run"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Servlet_Request_Run_Begin"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="Web Application Load">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Web_Application_Load"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="Servlet Execute">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Execute"/>
+	                </filter>
+	            </threadLane>
+	           <threadLane name="Servlet Context Execute">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Context_Execute"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="Servlet Invocation">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Servlet_Invocation"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="Servlet Filter">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Check_Access"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Filter"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="Servlet Request">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Request"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Request_Dispatch"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="Servlet Response Write Headers/Stale Resource">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Response_Write_Headers"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Stale_Resource"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="Servlet Response Send">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Response_Send"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="JAX-RPC">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Client_Response"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Client_Request"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Request"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Response"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="WebServices" enabled="true">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Dispatch"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXWS/Webservices_JAXWS_Request"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXWS/Webservices_JAXWS_Endpoint"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="DMS">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/dms-context/dms/ExecutionContext/span"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/dms-anonymous-phase/dms/AnonymousPhase/span"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="DMS execution context start">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/dms-context/dms/ExecutionContext/start"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="DMS HTTP">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/dms-http/dms/HttpRequest/span"/>
+	                    <filter kind="TYPE" type="http://www.oracle.com/dms-http/dms/HttpRequest/start"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="JavaFX Pulse" enabled="true">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/technetwork/java/javafx/index.html/javafx/pulse"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="JavaFX Input" enabled="true">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="http://www.oracle.com/technetwork/java/javafx/index.html/javafx/input"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="Java Latencies" enabled="true">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="jdk.JavaMonitorEnter"/>
+	                    <filter kind="TYPE" type="jdk.SocketRead"/>
+	                    <filter kind="TYPE" type="jdk.Compilation"/>
+	                    <filter kind="TYPE" type="jdk.ExecutionSampling"/>
+	                    <filter kind="TYPE" type="jdk.SocketWrite"/>
+	                    <filter kind="TYPE" type="jdk.ClassLoad"/>
+	                    <filter kind="TYPE" type="jdk.ThreadPark"/>
+	                    <filter kind="TYPE" type="jdk.FileWrite"/>
+	                    <filter kind="TYPE" type="jdk.ThreadSleep"/>
+	                    <filter kind="TYPE" type="jdk.JavaMonitorWait"/>
+	                    <filter kind="TYPE" type="jdk.FileRead"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="JVM Compiler">
+	                <filter kind="OR">
+	                    <filter kind="TYPE" type="jdk.SweepCodeCache"/>
+	                    <filter kind="TYPE" type="jdk.CompilerPhase"/>
+	                </filter>
+	            </threadLane>
+	            <threadLane name="Other Types" enabled="false" editable="false" isRestLane="true"/>
   			</state>
+			<!-- Legacy Threads Page -->
+			<page factory="org.openjdk.jmc.flightrecorder.ui.threadslegacy" id="org.openjdk.jmc.flightrecorder.ui.threadslegacy">
+			    <state>
+			        <sash weights="1,5" />
+			        <threadLane name="EJB">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Database_Access"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/EJB/EJB_Home_Remove"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Timer_Manager"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/EJB/EJB_Home_Create"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Pool_Manager_Remove"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Business_Method_Post_Invoke_Cleanup"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/EJB/EJB_Pool_Manager_Create"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/high/wls/EJB/EJB_Replicated_Session_Manager"/></filter>
+			        </threadLane>
+			        <threadLane name="EJB Business Method Invoke" enabled="true">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/EJB/EJB_Business_Method_Invoke"/></filter>
+			        </threadLane>
+			        <threadLane name="JDBC" enabled="true">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/JDBC/JDBC_Statement_Execute"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Data_Source_Get_Connection"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Driver_Connect"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Statement_Creation"/></filter>
+			        </threadLane>
+			        <threadLane name="JDBC Connection">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Reserve"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Create_Statement"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Commit"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Prepare"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Release"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/JDBC/JDBC_Connection_Rollback"/></filter>
+			        </threadLane>
+			        <threadLane name="JDBC Connection Close">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/JDBC/JDBC_Connection_Close"/></filter>
+			        </threadLane>
+			        <threadLane name="Servlet Request Run" enabled="true">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Servlet_Request_Run"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Servlet_Request_Run_Begin"/></filter>
+			        </threadLane>
+			        <threadLane name="Web Application Load">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Web_Application_Load"/></filter>
+			        </threadLane>
+			        <threadLane name="Servlet Execute">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Execute"/></filter>
+			        </threadLane>
+			        <threadLane name="Servlet Context Execute">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Context_Execute"/></filter>
+			        </threadLane>
+			        <threadLane name="Servlet Invocation">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Servlet/Servlet_Invocation"/></filter>
+			        </threadLane>
+			        <threadLane name="Servlet Filter">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Check_Access"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Filter"/></filter>
+			        </threadLane>
+			        <threadLane name="Servlet Request">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Request"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Request_Dispatch"/></filter>
+			        </threadLane>
+			        <threadLane name="Servlet Response Write Headers/Stale Resource">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Response_Write_Headers"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Stale_Resource"/></filter>
+			        </threadLane>
+			        <threadLane name="Servlet Response Send">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/medium/wls/Servlet/Servlet_Response_Send"/></filter>
+			        </threadLane>
+			        <threadLane name="JAX-RPC">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Client_Response"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Client_Request"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Request"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Response"/></filter>
+			        </threadLane>
+			        <threadLane name="WebServices" enabled="true">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXRPC/Webservices_JAXRPC_Dispatch"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXWS/Webservices_JAXWS_Request"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/wls/flightrecorder/low/wls/Webservices/JAXWS/Webservices_JAXWS_Endpoint"/></filter>
+			        </threadLane>
+			        <threadLane name="DMS">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/dms-context/dms/ExecutionContext/span"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/dms-anonymous-phase/dms/AnonymousPhase/span"/></filter>
+			        </threadLane>
+			        <threadLane name="DMS execution context start">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/dms-context/dms/ExecutionContext/start"/></filter>
+			        </threadLane>
+			        <threadLane name="DMS HTTP">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/dms-http/dms/HttpRequest/span"/>
+			                <filter kind="TYPE" type="http://www.oracle.com/dms-http/dms/HttpRequest/start"/></filter>
+			        </threadLane>
+			        <threadLane name="JavaFX Pulse" enabled="true">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/technetwork/java/javafx/index.html/javafx/pulse"/></filter>
+			        </threadLane>
+			        <threadLane name="JavaFX Input" enabled="true">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="http://www.oracle.com/technetwork/java/javafx/index.html/javafx/input"/></filter>
+			        </threadLane>
+			        <threadLane name="Java Latencies" enabled="true">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="jdk.JavaMonitorEnter"/>
+			                <filter kind="TYPE" type="jdk.SocketRead"/>
+			                <filter kind="TYPE" type="jdk.Compilation"/>
+			                <filter kind="TYPE" type="jdk.ExecutionSampling"/>
+			                <filter kind="TYPE" type="jdk.SocketWrite"/>
+			                <filter kind="TYPE" type="jdk.ClassLoad"/>
+			                <filter kind="TYPE" type="jdk.ThreadPark"/>
+			                <filter kind="TYPE" type="jdk.FileWrite"/>
+			                <filter kind="TYPE" type="jdk.ThreadSleep"/>
+			                <filter kind="TYPE" type="jdk.JavaMonitorWait"/>
+			                <filter kind="TYPE" type="jdk.FileRead"/></filter>
+			        </threadLane>
+			        <threadLane name="JVM Compiler">
+			            <filter kind="OR">
+			                <filter kind="TYPE" type="jdk.SweepCodeCache"/>
+			                <filter kind="TYPE" type="jdk.CompilerPhase"/></filter>
+			        </threadLane>
+			        <threadLane name="Other Types" enabled="false" editable="false" isRestLane="true"/>
+			    </state>
+			</page>
   		</page>
 		<page factory="org.openjdk.jmc.flightrecorder.ui.heap" id="org.openjdk.jmc.flightrecorder.ui.heap">
 			<state>
 				<chart>
 					<checkedAction id="heapUsed" />
diff a/application/org.openjdk.jmc.flightrecorder.ui/plugin.xml b/application/org.openjdk.jmc.flightrecorder.ui/plugin.xml
--- a/application/org.openjdk.jmc.flightrecorder.ui/plugin.xml
+++ b/application/org.openjdk.jmc.flightrecorder.ui/plugin.xml
@@ -216,10 +216,14 @@
       </factory>
       <factory
       		class="org.openjdk.jmc.flightrecorder.ui.pages.ThreadsPage$ThreadsPageFactory"
       		id="org.openjdk.jmc.flightrecorder.ui.threads">
       </factory>
+      <factory
+      		class="org.openjdk.jmc.flightrecorder.ui.pages.ThreadsPageLegacy$ThreadsPageLegacyFactory"
+      		id="org.openjdk.jmc.flightrecorder.ui.threadslegacy">
+      </factory>
       <factory
             class="org.openjdk.jmc.flightrecorder.ui.pages.HeapPage$HeapPageFactory"
             id="org.openjdk.jmc.flightrecorder.ui.heap">
       </factory>
             <factory
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DataPageToolkit.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DataPageToolkit.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DataPageToolkit.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DataPageToolkit.java
@@ -137,11 +137,10 @@
 import org.openjdk.jmc.flightrecorder.ui.pages.itemhandler.ItemHandlerPage.ItemHandlerUiStandIn;
 import org.openjdk.jmc.flightrecorder.ui.selection.IFilterFlavor;
 import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStore.SelectionStoreEntry;
 import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStoreActionToolkit;
 import org.openjdk.jmc.ui.charts.AWTChartToolkit.IColorProvider;
-import org.openjdk.jmc.ui.charts.ChartFilterControlBar;
 import org.openjdk.jmc.ui.charts.IQuantitySeries;
 import org.openjdk.jmc.ui.charts.ISpanSeries;
 import org.openjdk.jmc.ui.charts.IXDataRenderer;
 import org.openjdk.jmc.ui.charts.QuantitySeries;
 import org.openjdk.jmc.ui.charts.RendererToolkit;
@@ -154,10 +153,11 @@
 import org.openjdk.jmc.ui.column.TableSettings;
 import org.openjdk.jmc.ui.column.TableSettings.ColumnSettings;
 import org.openjdk.jmc.ui.handlers.ActionToolkit;
 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
 import org.openjdk.jmc.ui.misc.ChartCanvas;
+import org.openjdk.jmc.ui.misc.ChartControlBar;
 import org.openjdk.jmc.ui.misc.ChartTextCanvas;
 import org.openjdk.jmc.ui.misc.CompositeToolkit;
 import org.openjdk.jmc.ui.misc.DisplayToolkit;
 import org.openjdk.jmc.ui.misc.FilterEditor;
 import org.openjdk.jmc.ui.misc.FilterEditor.AttributeValueProvider;
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DropdownLaneFilter.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DropdownLaneFilter.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DropdownLaneFilter.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DropdownLaneFilter.java
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
  *
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -47,12 +47,13 @@
 import org.eclipse.swt.widgets.Listener;
 import org.eclipse.swt.widgets.Shell;
 
 import org.openjdk.jmc.flightrecorder.ui.common.LaneEditor.EditLanesContainer;
 import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
+import org.openjdk.jmc.ui.common.util.Environment;
+import org.openjdk.jmc.ui.common.util.Environment.OSType;
 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
-import org.openjdk.jmc.ui.misc.PatternFly.Palette;
 
 public class DropdownLaneFilter extends Composite {
 	private static final int EXTRA_SHELL_WIDTH = 300;
 	private static final int SHELL_HEIGHT = 500;
 	private Button dropdownButton;
@@ -64,24 +65,37 @@
 
 	public DropdownLaneFilter(Composite parent, ThreadGraphLanes lanes, MCContextMenuManager[] mms) {
 		super(parent, SWT.NONE);
 		this.lanes = lanes;
 		this.mms = mms;
-		this.setBackground(Palette.getThreadsPageBackgroundColor());
-		GridLayout layout = new GridLayout();
+		this.layout = new GridLayout();
 		layout.marginHeight = 0;
 		layout.marginWidth = 0;
-		this.layout = layout;
 		setLayout(layout);
 		dropdownButton = new Button(this, SWT.TOGGLE);
 		dropdownButton.setLayoutData(new GridData(GridData.FILL_BOTH));
 		dropdownButton.setText(Messages.DropdownLaneFilter_THREAD_STATE_SELECTION);
 		dropdownButton.addListener(SWT.MouseUp, new Listener() {
 			@Override
 			public void handleEvent(Event e) {
-				if (dropdownButton.getSelection()) {
-					displayDropdown();
+				/*
+				 * Windows: works IFF the menu item that is toggled is also highlight. e.g, if the
+				 * user wanted to toggle the Java Compiler lanes, then it's not enough to just click
+				 * the checkbox - the Java Compiler menu item must be highlighted at the time of
+				 * toggling
+				 *
+				 * MacOS: There are currently issues with paint timings with Mac OS at the moment
+				 * where toggling an activity lane from the dropdown does not redraw the chart. This
+				 * may be related to the Windows issue, and may be a SWT limitation.
+				 */
+				if (Environment.getOSType() != OSType.LINUX) {
+					lanes.openEditLanesDialog(mms, false);
+					dropdownButton.setSelection(false);
+				} else {
+					if (dropdownButton.getSelection()) {
+						displayDropdown();
+					}
 				}
 			}
 		});
 	}
 
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/LaneEditor.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/LaneEditor.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/LaneEditor.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/LaneEditor.java
@@ -115,27 +115,27 @@
 		private Runnable updateChart;
 		private boolean isDropdownFilter;
 
 		EditLanesContainer(Composite parent, EventTypeFolderNode root, List<LaneDefinition> lanes) {
 			this(parent, root, lanes, null);
-        }
+		}
 
 		EditLanesContainer(Composite parent, EventTypeFolderNode root, List<LaneDefinition> lanes, Runnable action) {
 			super(parent, SWT.NONE);
-            this.root = root;
-            this.lanes = lanes;
-            this.updateChart = action;
-            restLane = ensureRestLane(lanes);
-            init();
+			this.root = root;
+			this.lanes = lanes;
+			this.updateChart = action;
+			restLane = ensureRestLane(lanes);
+			init();
 		}
 
 		public List<LaneDefinition> getLanes() {
 			return lanes;
 		}
 
-        private void init() {
-            // FIXME: Do we want to group under categories somehow, or just hide the filters that don't have any existing event types.
+		private void init() {
+			// FIXME: Do we want to group under categories somehow, or just hide the filters that don't have any existing event types.
 			this.setLayout(GridLayoutFactory.swtDefaults().numColumns(2).create());
 
 			Composite laneHeaderContainer = new Composite(this, SWT.NONE);
 			laneHeaderContainer.setLayout(GridLayoutFactory.swtDefaults().create());
 			laneHeaderContainer.setLayoutData(GridDataFactory.fillDefaults().create());
@@ -290,11 +290,11 @@
 
 			lanesViewer.addSelectionChangedListener(
 					e -> laneSelectionChanges(((IStructuredSelection) e.getSelection()).getFirstElement()));
 			LaneDefinition firstLane = lanes.get(0);
 			lanesViewer.setSelection(new StructuredSelection(firstLane));
-        }
+		}
 
 		private void addLane() {
 			int selectIndex = Math.max(0, lanes.indexOf(selected));
 			IItemFilter emptyFilter = ItemFilters.type(Collections.emptySet());
 			LaneDefinition newEmpty = new LaneDefinition(null, false, emptyFilter, false);
@@ -367,11 +367,11 @@
 
 		private void updateChart() {
 			saveFilter(); // updates the LaneDefinition with the new filter
 			updateChart.run(); // repaints the chart and text canvases
 		}
-		
+
 		private int findLaneDefinitionIndexByName(Object selected) {
 			int index = -1;
 			if (selected != null) {
 				for (int i = 0; i < lanes.size(); i++) {
 					if (lanes.get(i).getName().equals(((LaneDefinition) selected).getName())) {
@@ -388,27 +388,26 @@
 			if (selectedIndex == -1 && isDropdownFilter) {
 				selectedIndex = findLaneDefinitionIndexByName(selected);
 			}
 			if (selectedIndex >= 0) {
 				LaneDefinition ld = lanes.get(selectedIndex);
-				if (!ld.isRestLane()) {
-					IItemFilter newFilter = ItemFilters
-							.type(filterEditor.getCheckedTypeIds().collect(Collectors.toSet()));
-					LaneDefinition newLd = new LaneDefinition(ld.name, lanesViewer.getChecked(ld), newFilter,
-							ld.isRestLane);
-					lanes.set(selectedIndex, newLd);
-					lanesViewer.replace(newLd, selectedIndex);
-					if (restLane != null) {
-						LaneDefinition newRest = new LaneDefinition(restLane.name, restLane.enabled,
-								getRestFilter(lanes), true);
-						int restIndex = lanes.indexOf(restLane);
-						lanes.set(restIndex, newRest);
-						lanesViewer.replace(newRest, restIndex);
-						restLane = newRest;
-					}
-					lanesViewer.refresh();
+				IItemFilter newFilter = ItemFilters.type(filterEditor.getCheckedTypeIds().collect(Collectors.toSet()));
+				LaneDefinition newLd = new LaneDefinition(ld.name, lanesViewer.getChecked(ld), newFilter,
+						ld.isRestLane);
+				lanes.set(selectedIndex, newLd);
+				lanesViewer.replace(newLd, selectedIndex);
+				if (ld.isRestLane()) {
+					restLane = newLd;
+				} else {
+					LaneDefinition newRest = new LaneDefinition(restLane.name, restLane.enabled, getRestFilter(lanes),
+							true);
+					int restIndex = findLaneDefinitionIndexByName(restLane);
+					lanes.set(restIndex, newRest);
+					lanesViewer.replace(newRest, restIndex);
+					restLane = newRest;
 				}
+				lanesViewer.refresh();
 			}
 		}
 	}
 
 	private static class EditLanesWizardPage extends WizardPage implements IPerformFinishable {
@@ -437,11 +436,12 @@
 		public boolean performFinish() {
 			container.saveFilter();
 			for (int i = 0; i < lanes.size(); i++) {
 				LaneDefinition ld = lanes.get(i);
 				if (ld.isEnabled() != container.lanesViewer.getChecked(ld)) {
-					lanes.set(i, new LaneDefinition(ld.name, container.lanesViewer.getChecked(ld), ld.filter, ld.isRestLane));
+					lanes.set(i, new LaneDefinition(ld.name, container.lanesViewer.getChecked(ld), ld.filter,
+							ld.isRestLane));
 				}
 			}
 			return true;
 		}
 	}
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/ThreadGraphLanes.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/ThreadGraphLanes.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/ThreadGraphLanes.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/ThreadGraphLanes.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  *
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -40,11 +40,10 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
@@ -60,11 +59,10 @@
 import org.openjdk.jmc.common.item.IItem;
 import org.openjdk.jmc.common.item.IItemCollection;
 import org.openjdk.jmc.common.item.IItemFilter;
 import org.openjdk.jmc.common.item.IItemIterable;
 import org.openjdk.jmc.common.item.ItemFilters;
-import org.openjdk.jmc.common.item.ItemFilters.Types;
 import org.openjdk.jmc.common.unit.IQuantity;
 import org.openjdk.jmc.flightrecorder.JfrAttributes;
 import org.openjdk.jmc.flightrecorder.jdk.JdkFilters;
 import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;
 import org.openjdk.jmc.flightrecorder.ui.EventTypeFolderNode;
@@ -95,17 +93,15 @@
 	private Supplier<StreamModel> dataSourceSupplier;
 	private Runnable buildChart;
 	private List<IAction> actions;
 	private String tooltipTitle;
 	private EventTypeFolderNode typeTree;
-	private boolean quickFilterExist;
 
 	public ThreadGraphLanes(Supplier<StreamModel> dataSourceSupplier, Runnable buildChart) {
 		this.dataSourceSupplier = dataSourceSupplier;
 		this.buildChart = buildChart;
 		this.actions = new ArrayList<>();
-		this.quickFilterExist = false;
 		this.typeTree = dataSourceSupplier.get().getTypeTree(ItemCollectionToolkit
 				.stream(dataSourceSupplier.get().getItems()).filter(this::typeWithThreadAndDuration));
 	}
 
 	protected EventTypeFolderNode getTypeTree() {
@@ -147,24 +143,10 @@
 				.filter((Predicate<? super LaneDefinition>) LaneDefinition::isEnabled).map(ld -> ld.getFilter())
 				.collect(Collectors.toList());
 		return ItemFilters.or(laneFilters.toArray(new IItemFilter[laneFilters.size()]));
 	}
 
-	/**
-	 * Retrieves the set of lane names that are currently enabled.<br>
-	 * Note: The "Rest lane" is of type ItemFilters$Composite, and cannot be cast to Types, so it
-	 * gets filtered out of the end result.
-	 * 
-	 * @return the enabled lanes independent from the rest lane
-	 */
-	public Set<String> getEnabledLanes() {
-		List<IItemFilter> laneFilters = laneDefs.stream()
-				.filter((Predicate<? super LaneDefinition>) LaneDefinition::isEnabledAndNotRestLane)
-				.map(ld -> ld.getFilter()).collect(Collectors.toList());
-		return ((Types) ItemFilters.or(laneFilters.toArray(new IItemFilter[laneFilters.size()]))).getTypes();
-	}
-
 	private void setTooltipTitle(String description) {
 		this.tooltipTitle = description;
 	}
 
 	private String getTooltipTitle() {
@@ -173,35 +155,10 @@
 
 	private void resetTooltipTitle() {
 		this.tooltipTitle = null;
 	}
 
-	/**
-	 * Introduces a "Quick Filter" to the lane definitions which is controlled by the dropdown lane
-	 * filter. Initially, the enabled activity lanes will be a copy of the currently enabled lanes.
-	 * When initially used, the "Quick Filter" will be the only active lane definition in an attempt
-	 * to preserve the lane activity of the existing lane definitions. The "Quick Filter" is meant
-	 * for easy viewing of activities, and will not be persisted.
-	 */
-	public void useDropdownFilter(LaneDefinition quickFilterDef) {
-		if (quickFilterExist) {
-			for (int i = 0; i < laneDefs.size(); i++) {
-				if (quickFilterDef.getName().equals(laneDefs.get(i).getName())) {
-					laneDefs.remove(laneDefs.get(i));
-					laneDefs.add(i, quickFilterDef);
-				}
-			}
-		} else {
-			for (int i = 0; i < laneDefs.size(); i++) {
-				setLaneDefinitionEnablement(laneDefs.get(i), i, false);
-			}
-			laneDefs.add(0, quickFilterDef);
-			quickFilterExist = true;
-		}
-		buildChart.run();
-	}
-
 	public void buildChart() {
 		buildChart.run();
 	}
 
 	private void setLaneDefinitionEnablement(LaneDefinition oldLd, int laneIndex, boolean isEnabled) {
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/TypeLabelProvider.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/TypeLabelProvider.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/TypeLabelProvider.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/TypeLabelProvider.java
@@ -54,11 +54,11 @@
 		case JdkTypeIDs.BIASED_LOCK_REVOCATION:
 			return Palette.PF_LIGHT_GREEN_300.getAWTColor();
 		case JdkTypeIDs.BIASED_LOCK_SELF_REVOCATION:
 			return Palette.PF_LIGHT_GREEN_400.getAWTColor();
 		case JdkTypeIDs.FILE_READ:
-			return Palette.PF_ORANGE_400.getAWTColor();
+			return Palette.PF_ORANGE_300.getAWTColor();
 		case JdkTypeIDs.FILE_WRITE:
 			return Palette.PF_CYAN_600.getAWTColor();
 		case JdkTypeIDs.ERRORS_THROWN:
 			return Palette.PF_RED_100.getAWTColor();
 		case JdkTypeIDs.EXCEPTIONS_THROWN:
@@ -74,39 +74,33 @@
 		case JdkTypeIDs.OLD_OBJECT_SAMPLE:
 			return Palette.PF_CYAN_200.getAWTColor();
 		case JdkTypeIDs.SWEEP_CODE_CACHE:
 			return Palette.PF_LIGHT_GREEN_500.getAWTColor();
 		case JdkTypeIDs.SOCKET_READ:
-			return Palette.PF_RED_200.getAWTColor();
+			return new Color(0xC8321E);
 		case JdkTypeIDs.SOCKET_WRITE:
 			return Palette.PF_LIGHT_BLUE_500.getAWTColor();
 		case JdkTypeIDs.CLASS_LOAD:
 			return Palette.PF_PURPLE_100.getAWTColor();
 		case JdkTypeIDs.COMPILATION:
 			return Palette.PF_GOLD_300.getAWTColor();
 		case JdkTypeIDs.GC_PAUSE:
-			return Palette.PF_ORANGE_500.getAWTColor();
+			return new Color(0xDC3C00);
 		case JdkTypeIDs.GC_PAUSE_L1:
-			return Palette.PF_GOLD_400.getAWTColor();
+			return new Color(0xE6CB45);
 		case JdkTypeIDs.GC_PAUSE_L2:
-			return Palette.PF_BLUE_400.getAWTColor();
+			return new Color(0x458AE6);
 		case JdkTypeIDs.GC_PAUSE_L3:
-			return Palette.PF_PURPLE_300.getAWTColor();
+			return new Color(0xE645E2);
 		case JdkTypeIDs.GC_PAUSE_L4:
-			return Palette.PF_LIGHT_GREEN_600.getAWTColor();
+			return new Color(0x85A115);
 		case JdkTypeIDs.SAFEPOINT_BEGIN:
 			return Palette.PF_PURPLE_200.getAWTColor();
 		case JdkTypeIDs.SAFEPOINT_CLEANUP:
 			return Palette.PF_PURPLE_500.getAWTColor();
 		case JdkTypeIDs.SAFEPOINT_CLEANUP_TASK:
 			return Palette.PF_BLUE_300.getAWTColor();
-		case JdkTypeIDs.SAFEPOINT_END:
-			return Palette.PF_GREEN_400.getAWTColor();
-		case JdkTypeIDs.SAFEPOINT_STATE_SYNC:
-			return Palette.PF_LIGHT_GREEN_200.getAWTColor();
-		case JdkTypeIDs.SAFEPOINT_WAIT_BLOCKED:
-			return Palette.PF_GREEN_500.getAWTColor();
 		case JdkTypeIDs.VM_OPERATIONS:
 			return Palette.PF_ORANGE_500.getAWTColor();
 		case JdkTypeIDs.ALLOC_INSIDE_TLAB:
 			return new Color(0xFF8000);
 		case JdkTypeIDs.ALLOC_OUTSIDE_TLAB:
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/messages/internal/Messages.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/messages/internal/Messages.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/messages/internal/Messages.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/messages/internal/Messages.java
@@ -508,15 +508,20 @@
 	public static String TABLECOMPONENT_GROUP_BY;
 	public static String TABLECOMPONENT_HISTOGRAM_SELECTION;
 	public static String TABLECOMPONENT_NONE;
 	public static String ThreadDumpsPage_PAGE_NAME;
 	public static String ThreadsPage_EDIT_LANES;
+	public static String ThreadsPage_FOLD_CHART_TOOLTIP;
+	public static String ThreadsPage_FOLD_TABLE_TOOLTIP;
 	public static String ThreadsPage_HIDE_THREAD_ACTION;
 	public static String ThreadsPage_LANE_FILTER_HEADER;
 	public static String ThreadsPage_LANE_TOOLTIP_TITLE;
 	public static String ThreadsPage_NAME;
+	public static String ThreadsPage_NAME_LEGACY;
 	public static String ThreadsPage_RESET_CHART_TO_SELECTION_ACTION;
+	public static String ThreadsPage_SHOW_CHART_TOOLTIP;
+	public static String ThreadsPage_SHOW_TABLE_TOOLTIP;
 	public static String ThreadsPage_TABLE_POPUP_DESCRIPTION;
 	public static String ThreadsPage_TABLE_POPUP_TITLE;
 	public static String ThreadsPage_VIEW_THREAD_DETAILS;
 	public static String TlabPage_PAGE_NAME;
 	public static String TlabPage_THREADS_TAB_NAME;
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ChartAndPopupTableUI.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ChartAndPopupTableUI.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ChartAndPopupTableUI.java
+++ /dev/null
@@ -1,379 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2019, Red Hat Inc. All rights reserved.
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * The contents of this file are subject to the terms of either the Universal Permissive License
- * v 1.0 as shown at http://oss.oracle.com/licenses/upl
- *
- * or the following license:
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted
- * provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
- * and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
- * conditions and the following disclaimer in the documentation and/or other materials provided with
- * the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
- * endorse or promote products derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
- * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.openjdk.jmc.flightrecorder.ui.pages;
-
-import org.eclipse.jface.viewers.StructuredSelection;
-import org.eclipse.osgi.util.NLS;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.custom.SashForm;
-import org.eclipse.swt.custom.ScrolledComposite;
-import org.eclipse.swt.graphics.Image;
-import org.eclipse.swt.layout.FillLayout;
-import org.eclipse.swt.layout.FormAttachment;
-import org.eclipse.swt.layout.FormData;
-import org.eclipse.swt.layout.FormLayout;
-import org.eclipse.swt.layout.GridData;
-import org.eclipse.swt.layout.GridLayout;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Display;
-import org.eclipse.swt.widgets.Event;
-import org.eclipse.swt.widgets.Listener;
-import org.eclipse.ui.forms.widgets.FormToolkit;
-
-import org.openjdk.jmc.common.IState;
-import org.openjdk.jmc.common.IWritableState;
-import org.openjdk.jmc.common.item.IAttribute;
-import org.openjdk.jmc.common.item.IItemCollection;
-import org.openjdk.jmc.common.item.IItemFilter;
-import org.openjdk.jmc.common.unit.IQuantity;
-import org.openjdk.jmc.common.unit.IRange;
-import org.openjdk.jmc.flightrecorder.JfrAttributes;
-import org.openjdk.jmc.flightrecorder.ui.IPageContainer;
-import org.openjdk.jmc.flightrecorder.ui.StreamModel;
-import org.openjdk.jmc.flightrecorder.ui.common.DataPageToolkit;
-import org.openjdk.jmc.flightrecorder.ui.common.FilterComponent;
-import org.openjdk.jmc.flightrecorder.ui.common.FlavorSelector;
-import org.openjdk.jmc.flightrecorder.ui.common.FlavorSelector.FlavorSelectorState;
-import org.openjdk.jmc.flightrecorder.ui.common.ItemHistogram;
-import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
-import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStoreActionToolkit;
-import org.openjdk.jmc.ui.charts.ChartFilterControlBar;
-import org.openjdk.jmc.ui.charts.IXDataRenderer;
-import org.openjdk.jmc.ui.charts.RendererToolkit;
-import org.openjdk.jmc.ui.charts.XYChart;
-import org.openjdk.jmc.ui.common.util.Environment;
-import org.openjdk.jmc.ui.handlers.ActionToolkit;
-import org.openjdk.jmc.ui.misc.ActionUiToolkit;
-import org.openjdk.jmc.ui.misc.ChartCanvas;
-import org.openjdk.jmc.ui.misc.ChartDisplayControlBar;
-import org.openjdk.jmc.ui.misc.ChartLaneHeightControls;
-import org.openjdk.jmc.ui.misc.ChartTextCanvas;
-import org.openjdk.jmc.ui.misc.PersistableSashForm;
-import org.openjdk.jmc.ui.misc.TimelineCanvas;
-
-abstract class ChartAndPopupTableUI extends ChartAndTableUI {
-
-	private static final double Y_SCALE = Display.getCurrent().getDPI().y / Environment.getNormalDPI();
-	private static final String SASH = "sash"; //$NON-NLS-1$
-	private static final String TABLE = "table"; //$NON-NLS-1$
-	private static final String CHART = "chart"; //$NON-NLS-1$
-	private static final String SELECTED = "selected"; //$NON-NLS-1$
-	private static final int TIMELINE_HEIGHT = 40;
-	private static final int X_OFFSET = 0;
-	private static final int Y_OFFSET = 0;
-	protected ChartFilterControlBar filterBar;
-	protected ChartTextCanvas textCanvas;
-	protected ItemHistogram hiddenTable;
-	protected IPageContainer pageContainer;
-	private ChartDisplayControlBar displayBar;
-	private Composite hiddenTableContainer;
-	private IItemCollection selectionItems;
-	private IItemFilter pageFilter;
-	private IRange<IQuantity> timeRange;
-	private TimelineCanvas timelineCanvas;
-	private ChartLaneHeightControls heightBtns;
-
-	ChartAndPopupTableUI(IItemFilter pageFilter, StreamModel model, Composite parent, FormToolkit toolkit,
-			IPageContainer pageContainer, IState state, String sectionTitle, IItemFilter tableFilter, Image icon,
-			FlavorSelectorState flavorSelectorState, IAttribute<?> classifier) {
-		super(pageFilter, model, parent, toolkit, pageContainer, state, sectionTitle, tableFilter, icon,
-				flavorSelectorState, classifier);
-	}
-
-	protected void init(
-		IItemFilter pageFilter, StreamModel model, Composite parent, FormToolkit toolkit, IPageContainer pageContainer,
-		IState state, String sectionTitle, IItemFilter tableFilter, Image icon,
-		FlavorSelectorState flavorSelectorState, IAttribute<?> classifier) {
-		this.pageFilter = pageFilter;
-		this.model = model;
-		this.pageContainer = pageContainer;
-		form = DataPageToolkit.createForm(parent, toolkit, sectionTitle, icon);
-
-		hiddenTableContainer = new Composite(form, SWT.NONE);
-		hiddenTableContainer.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
-		hiddenTableContainer.setVisible(false);
-
-		hiddenTable = buildHistogram(hiddenTableContainer, state.getChild(TABLE), classifier);
-		hiddenTable.getManager().getViewer().addSelectionChangedListener(e -> buildChart());
-
-		tableFilterComponent = FilterComponent.createFilterComponent(hiddenTable.getManager().getViewer().getControl(),
-				hiddenTable.getManager(), tableFilter, model.getItems().apply(pageFilter),
-				pageContainer.getSelectionStore()::getSelections, this::onFilterChange);
-
-		/**
-		 * Scrolled Composite Page Container - Contains all page functionality Chart Container (1
-		 * column gridlayout) - Contains filter bar & graph container Graph Container (2 column
-		 * gridlayout) - Contains chart and timeline container & display bar Chart and Timeline
-		 * Container (1 column gridlayout) Contains chart and text container and timeline canvas
-		 * Timeline and Height Buttons Container (2 column gridlayout) Contains timeline and lane
-		 * height button controls Zoom-pan and Chart Container (formlayout) - Contains chart and
-		 * text container contents and zoom-pan overlay Zoom-pan Container (filllayout) - Contains
-		 * zoom-pan chart overlay Full screen Chart Container (1 column gridlayout) - Contains chart
-		 * container Chart and Text Container (2 column gridlayout) - Contains scText and
-		 * textCanvas) & scChart (and chart canvas)
-		 */
-
-		// Scrolled Composite containing all page functionality
-		ScrolledComposite scPageContainer = new ScrolledComposite(form.getBody(), SWT.H_SCROLL | SWT.V_SCROLL);
-
-		chartContainer = toolkit.createComposite(scPageContainer);
-		chartContainer.setLayout(new GridLayout());
-		chartContainer.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
-
-		scPageContainer.setContent(chartContainer);
-		scPageContainer.setAlwaysShowScrollBars(false);
-		scPageContainer.setExpandHorizontal(true);
-		scPageContainer.setExpandVertical(true);
-		scPageContainer.addListener(SWT.Resize, new Listener() {
-			@Override
-			public void handleEvent(Event event) {
-				int width = filterBar.computeSize(SWT.DEFAULT, SWT.DEFAULT).x;
-				int height = filterBar.computeSize(SWT.DEFAULT, SWT.DEFAULT).y
-						+ displayBar.computeSize(SWT.DEFAULT, SWT.DEFAULT).y;
-				if (width > 0 && height > 0) {
-					scPageContainer.setMinSize(scPageContainer.computeSize(width, height));
-					scPageContainer.removeListener(SWT.Resize, this);
-				}
-			}
-		});
-
-		// Filter Controls
-		Listener resetListener = new Listener() {
-			@Override
-			public void handleEvent(Event event) {
-				onSetRange(false);
-			}
-		};
-		filterBar = new ChartFilterControlBar(chartContainer, resetListener, pageContainer.getRecordingRange());
-		filterBar.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, false));
-
-		// Container to hold the chart (& timeline) and display toolbar
-		Composite graphContainer = toolkit.createComposite(chartContainer);
-		GridLayout gridLayout = new GridLayout(2, false);
-		gridLayout.marginWidth = 0;
-		gridLayout.marginHeight = 0;
-		graphContainer.setLayout(gridLayout);
-		graphContainer.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
-
-		// Container to hold the chart and timeline canvas
-		Composite chartAndTimelineContainer = toolkit.createComposite(graphContainer);
-		gridLayout = new GridLayout();
-		gridLayout.marginWidth = 0;
-		gridLayout.marginHeight = 0;
-		chartAndTimelineContainer.setLayout(gridLayout);
-		chartAndTimelineContainer.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
-
-		// Container to hold the chart and a zoom-pan overlay
-		Composite zoomPanAndChartContainer = toolkit.createComposite(chartAndTimelineContainer);
-		zoomPanAndChartContainer.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
-		zoomPanAndChartContainer.setLayout(new FormLayout());
-
-		// Container to hold fixed zoom-pan display
-		Composite zoomPanContainer = toolkit.createComposite(zoomPanAndChartContainer);
-		zoomPanContainer.setLayout(new FillLayout());
-		FormData fd = new FormData();
-		fd.height = 80;
-		fd.width = 150;
-		fd.bottom = new FormAttachment(100, -12);
-		fd.right = new FormAttachment(100, -12);
-		zoomPanContainer.setLayoutData(fd);
-
-		// Container to hold the chart
-		Composite fullScreenChartContainer = toolkit.createComposite(zoomPanAndChartContainer);
-		fullScreenChartContainer.setLayout(gridLayout);
-		fd = new FormData();
-		fd.right = new FormAttachment(100, -1);
-		fd.top = new FormAttachment(0, 1);
-		fd.left = new FormAttachment(0, 1);
-		fd.bottom = new FormAttachment(100, -1);
-		fullScreenChartContainer.setLayoutData(fd);
-
-		// Container to hold the text and chart canvases
-		Composite chartAndTextContainer = toolkit.createComposite(fullScreenChartContainer);
-		gridLayout = new GridLayout(2, false);
-		gridLayout.horizontalSpacing = 0;
-		gridLayout.marginWidth = 0;
-		gridLayout.marginHeight = 0;
-		chartAndTextContainer.setLayout(gridLayout);
-		chartAndTextContainer.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
-
-		sash = new SashForm(chartAndTextContainer, SWT.VERTICAL);
-		sash.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
-		toolkit.adapt(sash);
-
-		ScrolledComposite scText = new ScrolledComposite(sash, SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
-		GridData scTextGd = new GridData(SWT.FILL, SWT.FILL, false, true);
-		scTextGd.widthHint = 180;
-		scText.setLayoutData(scTextGd);
-		textCanvas = new ChartTextCanvas(scText);
-		textCanvas.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, true));
-
-		ScrolledComposite scChart = new ScrolledComposite(sash, SWT.BORDER | SWT.V_SCROLL);
-		scChart.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
-		chartCanvas = new ChartCanvas(scChart);
-		chartCanvas.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
-
-		chartCanvas.setTextCanvas(textCanvas);
-		textCanvas.setChartCanvas(chartCanvas);
-
-		scChart.setContent(chartCanvas);
-		scChart.setAlwaysShowScrollBars(true);
-		scChart.setExpandHorizontal(true);
-		scChart.setExpandVertical(true);
-		scText.setContent(textCanvas);
-		scText.setAlwaysShowScrollBars(false);
-		scText.setExpandHorizontal(true);
-		scText.setExpandVertical(true);
-
-		Composite timelineAndHeightBtnsContainer = toolkit.createComposite(chartAndTimelineContainer);
-		gridLayout = new GridLayout(2, false);
-		gridLayout.horizontalSpacing = 0;
-		gridLayout.marginWidth = 0;
-		timelineAndHeightBtnsContainer.setLayout(gridLayout);
-		timelineAndHeightBtnsContainer.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, false));
-
-		heightBtns = new ChartLaneHeightControls(timelineAndHeightBtnsContainer, chartCanvas, textCanvas);
-		heightBtns.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, false));
-
-		timelineCanvas = new TimelineCanvas(timelineAndHeightBtnsContainer, chartCanvas, sash, Y_SCALE);
-		GridData gridData = new GridData(SWT.FILL, SWT.DEFAULT, true, false);
-		gridData.heightHint = (int) (TIMELINE_HEIGHT * Y_SCALE);
-		timelineCanvas.setLayoutData(gridData);
-
-		// add the display bar to the right of the chart scrolled composite
-		displayBar = new ChartDisplayControlBar(graphContainer);
-
-		allChartSeriesActions = initializeChartConfiguration(state);
-		IState chartState = state.getChild(CHART);
-		ActionToolkit.loadCheckState(chartState, allChartSeriesActions.stream());
-		chartLegend = ActionUiToolkit.buildCheckboxViewer(chartContainer, allChartSeriesActions.stream());
-		gridData = new GridData(SWT.FILL, SWT.FILL, false, true);
-		gridData.widthHint = 180;
-		chartLegend.getControl().setLayoutData(gridData);
-		PersistableSashForm.loadState(sash, state.getChild(SASH));
-		DataPageToolkit.createChartTimestampTooltip(chartCanvas);
-
-		chart = new XYChart(pageContainer.getRecordingRange(), RendererToolkit.empty(), X_OFFSET, Y_OFFSET,
-				timelineCanvas, filterBar, displayBar);
-		DataPageToolkit.setChart(chartCanvas, chart, pageContainer::showSelection);
-		DataPageToolkit.setChart(textCanvas, chart, pageContainer::showSelection);
-		SelectionStoreActionToolkit.addSelectionStoreRangeActions(pageContainer.getSelectionStore(), chart,
-				JfrAttributes.LIFETIME, NLS.bind(Messages.ChartAndTableUI_TIMELINE_SELECTION, form.getText()),
-				chartCanvas.getContextMenu());
-		SelectionStoreActionToolkit.addSelectionStoreRangeActions(pageContainer.getSelectionStore(), chart,
-				JfrAttributes.LIFETIME, NLS.bind(Messages.ChartAndTableUI_TIMELINE_SELECTION, form.getText()),
-				textCanvas.getContextMenu());
-
-		// Wire-up the chart & text canvases to the filter and display bars
-		displayBar.setChart(chart);
-		displayBar.setChartCanvas(chartCanvas);
-		displayBar.setTextCanvas(textCanvas);
-		displayBar.createZoomPan(zoomPanContainer);
-		chartCanvas.setZoomOnClickListener(mouseDown -> displayBar.zoomOnClick(mouseDown));
-		chartCanvas.setZoomToSelectionListener(() -> displayBar.zoomToSelection());
-		timelineCanvas.setChart(chart);
-
-		if (chartState != null) {
-			final String legendSelection = chartState.getAttribute(SELECTED);
-
-			if (legendSelection != null) {
-				allChartSeriesActions.stream().filter(ia -> legendSelection.equals(ia.getId())).findFirst()
-						.ifPresent(a -> chartLegend.setSelection(new StructuredSelection(a)));
-			}
-		}
-
-		flavorSelector = FlavorSelector.itemsWithTimerange(form, pageFilter, model.getItems(), pageContainer,
-				this::onFlavorSelected, this::onSetRange, flavorSelectorState);
-	}
-
-	protected void onFilterChange(IItemFilter filter) {
-		IItemCollection items = getItems();
-		if (tableFilterComponent.isVisible()) {
-			table.show(items.apply(filter));
-			tableFilterComponent.setColor(table.getAllRows().getRowCount());
-		} else if (table != null) {
-			table.show(items);
-		}
-	}
-
-	@Override
-	public void saveTo(IWritableState writableState) {
-		table = getUndisposedTable();
-		super.saveTo(writableState);
-	}
-
-	private void onSetRange(Boolean useRange) {
-		IRange<IQuantity> range = useRange ? timeRange : pageContainer.getRecordingRange();
-		chart.setVisibleRange(range.getStart(), range.getEnd());
-		chart.resetZoomFactor();
-		displayBar.resetZoomScale();
-		buildChart();
-	}
-
-	private void onFlavorSelected(IItemCollection items, IRange<IQuantity> timeRange) {
-		this.selectionItems = items;
-		this.timeRange = timeRange;
-		hiddenTable.show(getItems());
-		if (selectionItems != null) {
-			Object[] tableInput = (Object[]) hiddenTable.getManager().getViewer().getInput();
-			if (tableInput != null) {
-				hiddenTable.getManager().getViewer().setSelection(new StructuredSelection(tableInput));
-			} else {
-				hiddenTable.getManager().getViewer().setSelection(null);
-			}
-		}
-	}
-
-	protected void buildChart() {
-		IXDataRenderer rendererRoot = getChartRenderer(getItems(), getUndisposedTable().getSelection());
-		chartCanvas.replaceRenderer(rendererRoot);
-		textCanvas.replaceRenderer(rendererRoot);
-	}
-
-	private IItemCollection getItems() {
-		return selectionItems != null ? selectionItems.apply(pageFilter) : model.getItems().apply(pageFilter);
-	}
-
-	public void setTimeRange(IRange<IQuantity> range) {
-		this.timeRange = range;
-	}
-
-	protected ItemHistogram getUndisposedTable() {
-		return isDisposed(table) ? hiddenTable : table;
-	}
-
-	private boolean isDisposed(ItemHistogram histogram) {
-		return histogram == null ? true : histogram.getManager().getViewer().getControl().isDisposed();
-	}
-}
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ChartAndTableUI.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ChartAndTableUI.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ChartAndTableUI.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ChartAndTableUI.java
@@ -108,12 +108,12 @@
 				flavorSelectorState, classifier);
 	}
 
 	protected void init(
 		IItemFilter pageFilter, StreamModel model, Composite parent, FormToolkit toolkit, IPageContainer pageContainer,
-		IState state, String sectionTitle, IItemFilter tableFilter, Image icon,
-		FlavorSelectorState flavorSelectorState, IAttribute<?> classifier) {
+		IState state, String sectionTitle, IItemFilter tableFilter, Image icon, FlavorSelectorState flavorSelectorState,
+		IAttribute<?> classifier) {
 		this.pageFilter = pageFilter;
 		this.model = model;
 		this.pageContainer = pageContainer;
 		form = DataPageToolkit.createForm(parent, toolkit, sectionTitle, icon);
 		sash = new SashForm(form.getBody(), SWT.VERTICAL);
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPage.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPage.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPage.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPage.java
@@ -39,22 +39,22 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
+import org.eclipse.jface.action.GroupMarker;
 import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.action.IToolBarManager;
 import org.eclipse.jface.action.Separator;
 import org.eclipse.jface.resource.ImageDescriptor;
-import org.eclipse.jface.viewers.StructuredSelection;
 import org.eclipse.jface.viewers.TableViewer;
-import org.eclipse.jface.wizard.WizardPage;
-import org.eclipse.osgi.util.NLS;
 import org.eclipse.swt.SWT;
 import org.eclipse.swt.layout.GridData;
 import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Event;
 import org.eclipse.swt.widgets.Item;
+import org.eclipse.swt.widgets.Listener;
 import org.eclipse.ui.forms.widgets.FormToolkit;
 import org.openjdk.jmc.common.IMCThread;
 import org.openjdk.jmc.common.IState;
 import org.openjdk.jmc.common.IWritableState;
 import org.openjdk.jmc.common.item.Aggregators;
@@ -75,32 +75,27 @@
 import org.openjdk.jmc.flightrecorder.ui.IPageContainer;
 import org.openjdk.jmc.flightrecorder.ui.IPageDefinition;
 import org.openjdk.jmc.flightrecorder.ui.IPageUI;
 import org.openjdk.jmc.flightrecorder.ui.StreamModel;
 import org.openjdk.jmc.flightrecorder.ui.common.AbstractDataPage;
-import org.openjdk.jmc.flightrecorder.ui.common.FilterComponent;
 import org.openjdk.jmc.flightrecorder.ui.common.FlavorSelector.FlavorSelectorState;
 import org.openjdk.jmc.flightrecorder.ui.common.ImageConstants;
 import org.openjdk.jmc.flightrecorder.ui.common.ItemHistogram;
 import org.openjdk.jmc.flightrecorder.ui.common.ItemHistogram.HistogramSelection;
 import org.openjdk.jmc.flightrecorder.ui.common.ItemHistogram.ItemHistogramBuilder;
 import org.openjdk.jmc.flightrecorder.ui.common.ItemRow;
 import org.openjdk.jmc.flightrecorder.ui.common.DropdownLaneFilter;
 import org.openjdk.jmc.flightrecorder.ui.common.ThreadGraphLanes;
 import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
-import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStoreActionToolkit;
 import org.openjdk.jmc.ui.UIPlugin;
 import org.openjdk.jmc.ui.charts.IXDataRenderer;
 import org.openjdk.jmc.ui.charts.QuantitySpanRenderer;
 import org.openjdk.jmc.ui.charts.RendererToolkit;
 import org.openjdk.jmc.ui.column.ColumnManager.SelectionState;
-import org.openjdk.jmc.ui.column.ColumnMenusFactory;
 import org.openjdk.jmc.ui.column.TableSettings;
 import org.openjdk.jmc.ui.handlers.ActionToolkit;
 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
-import org.openjdk.jmc.ui.wizards.IPerformFinishable;
-import org.openjdk.jmc.ui.wizards.OnePageWizardDialog;
 
 public class ThreadsPage extends AbstractDataPage {
 
 	public static class ThreadsPageFactory implements IDataPageFactory {
 
@@ -165,59 +160,159 @@
 			return null;
 		}, Messages.JavaApplicationPage_COLUMN_THREAD_DURATION,
 				Messages.JavaApplicationPage_COLUMN_THREAD_DURATION_DESC);
 	}
 
-	private class ThreadsPageUi extends ChartAndPopupTableUI {
+	private class ThreadsPageUi extends ThreadsPageLayoutUI {
 		private static final String THREADS_TABLE_FILTER = "threadsTableFilter"; //$NON-NLS-1$
+		private static final String FOLD_CHART_ACTION = "foldChartAction"; //$NON-NLS-1$
+		private static final String FOLD_TABLE_ACTION = "foldTableAction"; //$NON-NLS-1$
 		private static final String HIDE_THREAD = "hideThread"; //$NON-NLS-1$
 		private static final String RESET_CHART = "resetChart"; //$NON-NLS-1$
-		private static final String TABLE = "table"; //$NON-NLS-1$
+		public static final String TOOLBAR_FOLD_ACTIONS = "foldActions"; //$NON-NLS-1$
 		private Boolean isChartMenuActionsInit;
 		private Boolean isChartModified;
 		private Boolean reloadThreads;
+		private IAction foldChartAction;
+		private IAction foldTableAction;
 		private IAction hideThreadActionChart;
 		private IAction hideThreadActionText;
 		private IAction resetChartAction;
+		private int[] weights;
 		private List<IXDataRenderer> threadRows;
 		private MCContextMenuManager mmChart;
 		private MCContextMenuManager mmText;
+		private MCContextMenuManager[] mms;
 		private ThreadGraphLanes lanes;
 		private DropdownLaneFilter laneFilter;
 
 		ThreadsPageUi(Composite parent, FormToolkit toolkit, IPageContainer editor, IState state) {
 			super(pageFilter, getDataSource(), parent, toolkit, editor, state, getName(), pageFilter, getIcon(),
 					flavorSelectorState, JfrAttributes.EVENT_THREAD);
 			mmChart = (MCContextMenuManager) chartCanvas.getContextMenu();
 			mmText = (MCContextMenuManager) textCanvas.getContextMenu();
-			sash.setOrientation(SWT.HORIZONTAL);
+			mms = new MCContextMenuManager[] {mmChart, mmText};
+			initializeStoredSashWeights();
+			canvasSash.setOrientation(SWT.HORIZONTAL);
+			addResizeListenerToTableAndChartComponents();
 			addActionsToContextMenu();
 			// FIXME: The lanes field is initialized by initializeChartConfiguration which is called by the super constructor. This is too indirect for SpotBugs to resolve and should be simplified.
-			MCContextMenuManager[] mms = {mmChart, mmText};
 			lanes.updateContextMenus(mms, false);
-			form.getToolBarManager()
-					.add(ActionToolkit.action(() -> lanes.openEditLanesDialog(mms, false),
-							Messages.ThreadsPage_EDIT_LANES,
-							FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_LANES_EDIT)));
-			form.getToolBarManager()
-					.add(ActionToolkit.action(() -> openViewThreadDetailsDialog(state),
-							Messages.ThreadsPage_VIEW_THREAD_DETAILS,
-							FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_TABLE)));
-			form.getToolBarManager().update(true);
+			addActionsToToolbar(form.getToolBarManager());
 			chartLegend.getControl().dispose();
-			setupFilterBar();
-			buildChart();
+			form.getToolBarManager().update(true);
+			setupLaneFilter();
+			buildChart(true);
+			table.getManager().setSelectionState(histogramSelectionState);
+			tableFilterComponent.loadState(state.getChild(THREADS_TABLE_FILTER));
+			for (Item columnWidget : ((TableViewer) table.getManager().getViewer()).getTable().getColumns()) {
+				columnWidget.addListener(SWT.Selection, e -> buildChart(false));
+			}
 			chart.setVisibleRange(visibleRange.getStart(), visibleRange.getEnd());
 			onFilterChange(tableFilter);
 		}
 
-		private void setupFilterBar() {
+		private void addActionsToToolbar(IToolBarManager tb) {
+			foldTableAction = ActionToolkit.checkAction(selected -> {
+				performToolbarAction(FOLD_TABLE_ACTION, selected);
+			}, sash.getWeights()[0] == 0 ? Messages.ThreadsPage_SHOW_TABLE_TOOLTIP
+					: Messages.ThreadsPage_FOLD_TABLE_TOOLTIP,
+					FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_TABLE));
+			foldTableAction.setChecked(sash.getWeights()[0] == 0 ? false : true);
+
+			foldChartAction = ActionToolkit.checkAction(selected -> {
+				performToolbarAction(FOLD_CHART_ACTION, selected);
+			}, sash.getWeights()[1] == 0 ? Messages.ThreadsPage_SHOW_CHART_TOOLTIP
+					: Messages.ThreadsPage_FOLD_CHART_TOOLTIP,
+					FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_CHART_BAR));
+			foldChartAction.setChecked(sash.getWeights()[1] == 0 ? false : true);
+
+			tb.add(new GroupMarker(TOOLBAR_FOLD_ACTIONS));
+			tb.appendToGroup(TOOLBAR_FOLD_ACTIONS, foldTableAction);
+			tb.appendToGroup(TOOLBAR_FOLD_ACTIONS, foldChartAction);
+			tb.appendToGroup(TOOLBAR_FOLD_ACTIONS, new Separator());
+
+			tb.add(ActionToolkit.action(() -> lanes.openEditLanesDialog(mms, false), Messages.ThreadsPage_EDIT_LANES,
+					FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_LANES_EDIT)));
+		}
+
+		private void addResizeListenerToTableAndChartComponents() {
+			tableFilterComponent.getComponent().addListener(SWT.Resize, new Listener() {
+				@Override
+				public void handleEvent(Event event) {
+					if (!foldTableAction.isChecked() && tableFilterComponent.getComponent().getSize().y > 0) {
+						foldTableAction.setChecked(true);
+					}
+				}
+			});
+
+			canvasSash.addListener(SWT.Resize, new Listener() {
+				@Override
+				public void handleEvent(Event event) {
+					if (!foldChartAction.isChecked() && chartCanvas.getSize().y > 0) {
+						foldChartAction.setChecked(true);
+					}
+				}
+			});
+		}
+
+		private void performToolbarAction(String action, boolean selected) {
+			switch (action) {
+			case FOLD_TABLE_ACTION:
+				if (selected) {
+					sash.setWeights(this.getStoredSashWeights());
+					foldTableAction.setToolTipText(Messages.ThreadsPage_FOLD_TABLE_TOOLTIP);
+				} else {
+					// if the chart is folded, don't fold the table
+					if (sash.getWeights()[1] == 0) {
+						this.foldTableAction.setChecked(true);
+					} else {
+						this.setStoredSashWeights(sash.getWeights());
+						sash.setWeights(new int[] {0, 2});
+						foldTableAction.setToolTipText(Messages.ThreadsPage_SHOW_TABLE_TOOLTIP);
+					}
+				}
+				break;
+			case FOLD_CHART_ACTION:
+				if (selected) {
+					sash.setWeights(this.getStoredSashWeights());
+					foldChartAction.setToolTipText(Messages.ThreadsPage_FOLD_CHART_TOOLTIP);
+				} else {
+					// if the table is folded, don't fold the chart
+					if (sash.getWeights()[0] == 0) {
+						this.foldChartAction.setChecked(true);
+					} else {
+						this.setStoredSashWeights(sash.getWeights());
+						sash.setWeights(new int[] {1, 0});
+						foldChartAction.setToolTipText(Messages.ThreadsPage_SHOW_CHART_TOOLTIP);
+					}
+				}
+				break;
+			}
+		}
+
+		private void initializeStoredSashWeights() {
+			// if either the chart or table are folded on init, store a default value of {1, 2}
+			if (sash.getWeights()[0] == 0 || sash.getWeights()[1] == 0) {
+				this.setStoredSashWeights(new int[] {1, 2});
+			} else {
+				this.setStoredSashWeights(sash.getWeights());
+			}
+		}
+
+		protected int[] getStoredSashWeights() {
+			return this.weights;
+		}
+
+		protected void setStoredSashWeights(int[] weights) {
+			this.weights = weights;
+		}
+
+		private void setupLaneFilter() {
 			MCContextMenuManager[] mms = {mmChart, mmText};
-			laneFilter = new DropdownLaneFilter(filterBar, lanes, mms);
+			laneFilter = new DropdownLaneFilter(controlBar.getLaneFilterContainer(), lanes, mms);
 			laneFilter.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, false, false));
-			filterBar.setChart(chart);
-			filterBar.setChartCanvas(chartCanvas);
 		}
 
 		/**
 		 * Hides a thread from the chart and rebuilds the chart
 		 */
@@ -225,11 +320,11 @@
 			if (this.threadRows != null && this.threadRows.size() > 0 && thread instanceof IMCThread) {
 				int index = indexOfThread(thread);
 				if (index != -1) {
 					this.threadRows.remove(index);
 					this.reloadThreads = false;
-					buildChart();
+					buildChart(false);
 					if (!this.isChartModified) {
 						this.isChartModified = true;
 						setResetChartActionEnablement(true);
 					}
 				}
@@ -260,45 +355,42 @@
 		/**
 		 * Update the context menu to include actions to hide threads and reset the chart
 		 */
 		private void addActionsToContextMenu() {
 			mmChart.add(new Separator());
+			mmText.add(new Separator());
 			IAction hideThreadActionChart = ActionToolkit.action(
 					() -> this.hideThread(chartCanvas.getHoveredItemData()), Messages.ThreadsPage_HIDE_THREAD_ACTION,
 					UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_DELETE));
-
 			hideThreadActionChart.setId(HIDE_THREAD);
 			this.hideThreadActionChart = hideThreadActionChart;
 			mmChart.add(hideThreadActionChart);
 
-			mmText.add(new Separator());
 			IAction hideThreadActionText = ActionToolkit.action(() -> this.hideThread(textCanvas.getHoveredItemData()),
 					Messages.ThreadsPage_HIDE_THREAD_ACTION,
 					UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_DELETE));
-
 			hideThreadActionText.setId(HIDE_THREAD);
 			this.hideThreadActionText = hideThreadActionText;
 			mmText.add(hideThreadActionText);
 
 			IAction resetChartAction = ActionToolkit.action(() -> this.resetChartToSelection(),
 					Messages.ThreadsPage_RESET_CHART_TO_SELECTION_ACTION,
 					UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_REFRESH));
 			resetChartAction.setId(RESET_CHART);
 			resetChartAction.setEnabled(this.isChartModified);
 			this.resetChartAction = resetChartAction;
-
 			mmChart.add(resetChartAction);
 			mmText.add(resetChartAction);
 
 			this.isChartMenuActionsInit = true;
 		}
 
 		/**
 		 * Redraws the chart, and disables the reset chart menu action
 		 */
 		private void resetChartToSelection() {
-			buildChart();
+			buildChart(false);
 			this.isChartModified = false;
 			setResetChartActionEnablement(false);
 			setHideThreadActionEnablement(true);
 		}
 
@@ -318,11 +410,11 @@
 		}
 
 		@Override
 		protected IXDataRenderer getChartRenderer(IItemCollection itemsInTable, HistogramSelection tableSelection) {
 			List<IXDataRenderer> rows = new ArrayList<>();
-			ItemHistogram histogram = getUndisposedTable();
+			ItemHistogram histogram = table;
 			IItemCollection selectedItems;
 			HistogramSelection selection;
 			if (tableSelection.getRowCount() == 0) {
 				selectedItems = itemsInTable;
 				selection = histogram.getAllRows();
@@ -371,109 +463,36 @@
 		public void saveTo(IWritableState state) {
 			super.saveTo(state);
 			tableFilterComponent.saveState(state.createChild(THREADS_TABLE_FILTER));
 			lanes.saveTo(state);
 			saveToLocal();
-			Display.getCurrent().setData(NO_INPUT_METHOD, null);
 		}
 
 		private void saveToLocal() {
 			flavorSelectorState = flavorSelector.getFlavorSelectorState();
-			histogramSelectionState = getUndisposedTable().getManager().getSelectionState();
+			histogramSelectionState = table.getManager().getSelectionState();
 			visibleRange = chart.getVisibleRange();
 		}
 
 		@Override
 		protected List<IAction> initializeChartConfiguration(IState state) {
 			this.isChartMenuActionsInit = false;
 			this.isChartModified = false;
 			this.reloadThreads = true;
-			lanes = new ThreadGraphLanes(() -> getDataSource(), () -> buildChart());
+			lanes = new ThreadGraphLanes(() -> getDataSource(), () -> buildChart(false));
 			return lanes.initializeChartConfiguration(Stream.of(state.getChildren(THREAD_LANE)));
 		}
-
-		private TablePopup tablePopup;
-
-		public void openViewThreadDetailsDialog(IState state) {
-			tablePopup = new TablePopup(state);
-			OnePageWizardDialog.openAndHideCancelButton(tablePopup, 500, 600);
-		}
-
-		private class TablePopup extends WizardPage implements IPerformFinishable {
-
-			private IState state;
-
-			protected TablePopup(IState state) {
-				super("ThreadDetailsPage"); //$NON-NLS-1$
-				this.state = state;
-				setTitle(Messages.ThreadsPage_TABLE_POPUP_TITLE);
-				setDescription(Messages.ThreadsPage_TABLE_POPUP_DESCRIPTION);
-			}
-
-			@Override
-			public void createControl(Composite parent) {
-				table = buildHistogram(parent, state.getChild(TABLE), JfrAttributes.EVENT_THREAD);
-				MCContextMenuManager mm = MCContextMenuManager.create(table.getManager().getViewer().getControl());
-				ColumnMenusFactory.addDefaultMenus(table.getManager(), mm);
-				table.getManager().getViewer().addSelectionChangedListener(e -> buildChart());
-				table.getManager().getViewer()
-						.addSelectionChangedListener(e -> pageContainer.showSelection(table.getSelection().getItems()));
-				SelectionStoreActionToolkit.addSelectionStoreActions(pageContainer.getSelectionStore(), table,
-						NLS.bind(Messages.ChartAndTableUI_HISTOGRAM_SELECTION, getName()), mm);
-				tableFilterComponent = FilterComponent.createFilterComponent(
-						table.getManager().getViewer().getControl(), table.getManager(), tableFilter,
-						model.getItems().apply(pageFilter), pageContainer.getSelectionStore()::getSelections,
-						this::onFilterChangeHelper);
-				mm.add(tableFilterComponent.getShowFilterAction());
-				mm.add(tableFilterComponent.getShowSearchAction());
-				table.getManager().setSelectionState(histogramSelectionState);
-				tableFilterComponent.loadState(state.getChild(THREADS_TABLE_FILTER));
-				onFilterChange(tableFilter);
-
-				if (selectionInput != null) {
-					table.getManager().getViewer().setSelection(new StructuredSelection(selectionInput));
-				}
-
-				Item[] columnWidgets = ((TableViewer) table.getManager().getViewer()).getTable().getColumns();
-				for (Item columWidget : columnWidgets) {
-					columWidget.addListener(SWT.Selection, e -> columnSortChanged());
-				}
-
-				setControl(parent);
-			}
-
-			private void columnSortChanged() {
-				if (!table.getSelection().getItems().hasItems()) {
-					buildChart();
-				}
-			}
-
-			private void onFilterChangeHelper(IItemFilter filter) {
-				onFilterChange(filter);
-			}
-
-			@Override
-			public boolean performFinish() {
-				IItemCollection lastSelection = table.getSelection().getItems();
-				table.show(lastSelection);
-				selectionInput = (Object[]) table.getManager().getViewer().getInput();
-				return true;
-			}
-		}
 	}
 
-	private static final String NO_INPUT_METHOD = "org.eclipse.swt.internal.gtk.noInputMethod"; //$NON-NLS-1$
-	private Object[] selectionInput;
 	private FlavorSelectorState flavorSelectorState;
 	private SelectionState histogramSelectionState;
 	private IItemFilter tableFilter;
 	private IRange<IQuantity> visibleRange;
 
 	public ThreadsPage(IPageDefinition definition, StreamModel model, IPageContainer editor) {
 		super(definition, model, editor);
 		visibleRange = editor.getRecordingRange();
-		Display.getCurrent().setData(NO_INPUT_METHOD, true);
 	}
 
 	@Override
 	public IPageUI display(Composite parent, FormToolkit toolkit, IPageContainer editor, IState state) {
 		return new ThreadsPageUi(parent, toolkit, editor, state);
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPageLayoutUI.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPageLayoutUI.java
--- /dev/null
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPageLayoutUI.java
@@ -0,0 +1,349 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.flightrecorder.ui.pages;
+
+import org.eclipse.jface.viewers.StructuredSelection;
+import org.eclipse.osgi.util.NLS;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.SashForm;
+import org.eclipse.swt.custom.ScrolledComposite;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.FormAttachment;
+import org.eclipse.swt.layout.FormData;
+import org.eclipse.swt.layout.FormLayout;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Listener;
+import org.eclipse.ui.forms.widgets.FormToolkit;
+
+import org.openjdk.jmc.common.IState;
+import org.openjdk.jmc.common.IWritableState;
+import org.openjdk.jmc.common.item.IAttribute;
+import org.openjdk.jmc.common.item.IItemCollection;
+import org.openjdk.jmc.common.item.IItemFilter;
+import org.openjdk.jmc.common.unit.IQuantity;
+import org.openjdk.jmc.common.unit.IRange;
+import org.openjdk.jmc.flightrecorder.JfrAttributes;
+import org.openjdk.jmc.flightrecorder.ui.IPageContainer;
+import org.openjdk.jmc.flightrecorder.ui.StreamModel;
+import org.openjdk.jmc.flightrecorder.ui.common.DataPageToolkit;
+import org.openjdk.jmc.flightrecorder.ui.common.FilterComponent;
+import org.openjdk.jmc.flightrecorder.ui.common.FlavorSelector;
+import org.openjdk.jmc.flightrecorder.ui.common.FlavorSelector.FlavorSelectorState;
+import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
+import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStoreActionToolkit;
+import org.openjdk.jmc.ui.charts.IXDataRenderer;
+import org.openjdk.jmc.ui.charts.RendererToolkit;
+import org.openjdk.jmc.ui.charts.XYChart;
+import org.openjdk.jmc.ui.column.ColumnMenusFactory;
+import org.openjdk.jmc.ui.common.util.Environment;
+import org.openjdk.jmc.ui.handlers.ActionToolkit;
+import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
+import org.openjdk.jmc.ui.misc.ChartCanvas;
+import org.openjdk.jmc.ui.misc.ChartControlBar;
+import org.openjdk.jmc.ui.misc.ActionUiToolkit;
+import org.openjdk.jmc.ui.misc.ChartButtonGroup;
+import org.openjdk.jmc.ui.misc.ChartTextCanvas;
+import org.openjdk.jmc.ui.misc.PersistableSashForm;
+import org.openjdk.jmc.ui.misc.TimelineCanvas;
+
+abstract class ThreadsPageLayoutUI extends ChartAndTableUI {
+
+	private static final double Y_SCALE = Display.getCurrent().getDPI().y / Environment.getNormalDPI();
+	private static final String TABLE = "table"; //$NON-NLS-1$
+	private static final String CHART = "chart"; //$NON-NLS-1$
+	private static final String CANVAS_SASH = "canvasSash"; //$NON-NLS-1$
+	private static final String PAGE_SASH = "pageSash"; //$NON-NLS-1$
+	private static final String SELECTED = "selected"; //$NON-NLS-1$
+	private static final int TIMELINE_HEIGHT = 40;
+	private static final int X_OFFSET = 0;
+	private static final int Y_OFFSET = 0;
+	protected ChartControlBar controlBar;
+	protected ChartTextCanvas textCanvas;
+	protected IPageContainer pageContainer;
+	private Composite zoomPanContainer;
+	private ChartButtonGroup buttonGroup;
+	private IItemCollection selectionItems;
+	private IItemFilter pageFilter;
+	private IRange<IQuantity> timeRange;
+	protected SashForm canvasSash;
+	private TimelineCanvas timelineCanvas;
+
+	ThreadsPageLayoutUI(IItemFilter pageFilter, StreamModel model, Composite parent, FormToolkit toolkit,
+			IPageContainer pageContainer, IState state, String sectionTitle, IItemFilter tableFilter, Image icon,
+			FlavorSelectorState flavorSelectorState, IAttribute<?> classifier) {
+		super(pageFilter, model, parent, toolkit, pageContainer, state, sectionTitle, tableFilter, icon,
+				flavorSelectorState, classifier);
+	}
+
+	protected void init(
+		IItemFilter pageFilter, StreamModel model, Composite parent, FormToolkit toolkit, IPageContainer pageContainer,
+		IState state, String sectionTitle, IItemFilter tableFilter, Image icon, FlavorSelectorState flavorSelectorState,
+		IAttribute<?> classifier) {
+		this.pageFilter = pageFilter;
+		this.model = model;
+		this.pageContainer = pageContainer;
+		form = DataPageToolkit.createForm(parent, toolkit, sectionTitle, icon);
+		sash = new SashForm(form.getBody(), SWT.VERTICAL);
+		toolkit.adapt(sash);
+
+		setupTable(state, sectionTitle, tableFilter, classifier);
+		setupChartContainers(toolkit);
+
+		allChartSeriesActions = initializeChartConfiguration(state);
+		IState chartState = state.getChild(CHART);
+		ActionToolkit.loadCheckState(chartState, allChartSeriesActions.stream());
+		chartLegend = ActionUiToolkit.buildCheckboxViewer(chartContainer, allChartSeriesActions.stream());
+		GridData gridData = new GridData(SWT.FILL, SWT.FILL, false, true);
+		gridData.widthHint = 180;
+		chartLegend.getControl().setLayoutData(gridData);
+		DataPageToolkit.createChartTimestampTooltip(chartCanvas);
+
+		chart = new XYChart(pageContainer.getRecordingRange(), RendererToolkit.empty(), X_OFFSET, Y_OFFSET,
+				timelineCanvas, controlBar, buttonGroup);
+		DataPageToolkit.setChart(chartCanvas, chart, pageContainer::showSelection);
+		DataPageToolkit.setChart(textCanvas, chart, pageContainer::showSelection);
+		SelectionStoreActionToolkit.addSelectionStoreRangeActions(pageContainer.getSelectionStore(), chart,
+				JfrAttributes.LIFETIME, NLS.bind(Messages.ChartAndTableUI_TIMELINE_SELECTION, form.getText()),
+				chartCanvas.getContextMenu());
+		SelectionStoreActionToolkit.addSelectionStoreRangeActions(pageContainer.getSelectionStore(), chart,
+				JfrAttributes.LIFETIME, NLS.bind(Messages.ChartAndTableUI_TIMELINE_SELECTION, form.getText()),
+				textCanvas.getContextMenu());
+
+		chartCanvas.setZoomOnClickListener(mouseDown -> buttonGroup.zoomOnClick(mouseDown));
+		chartCanvas.setZoomToSelectionListener(() -> buttonGroup.zoomToSelection());
+
+		// Wire-up the chart & text canvases to the control bar and button group
+		chartCanvas.setTextCanvas(textCanvas);
+		textCanvas.setChartCanvas(chartCanvas);
+		controlBar.setChart(chart);
+		controlBar.setChartCanvas(chartCanvas);
+		controlBar.setTextCanvas(textCanvas);
+		buttonGroup.createZoomPan(zoomPanContainer);
+		timelineCanvas.setChart(chart);
+
+		if (chartState != null) {
+			final String legendSelection = chartState.getAttribute(SELECTED);
+
+			if (legendSelection != null) {
+				allChartSeriesActions.stream().filter(ia -> legendSelection.equals(ia.getId())).findFirst()
+						.ifPresent(a -> chartLegend.setSelection(new StructuredSelection(a)));
+			}
+		}
+
+		if (state.getChild(PAGE_SASH) == null) {
+			sash.setWeights(new int[] {0, 3});
+		} else {
+			PersistableSashForm.loadState(sash, state.getChild(PAGE_SASH));
+		}
+
+		if (state.getChild(CANVAS_SASH) == null) {
+			canvasSash.setWeights(new int[] {1, 4});
+		} else {
+			PersistableSashForm.loadState(canvasSash, state.getChild(CANVAS_SASH));
+		}
+
+		flavorSelector = FlavorSelector.itemsWithTimerange(form, pageFilter, model.getItems(), pageContainer,
+				this::onFlavorSelected, this::onSetRange, flavorSelectorState);
+	}
+
+	private void setupTable(IState state, String sectionTitle, IItemFilter tableFilter, IAttribute<?> classifier) {
+		// Setup the table
+		table = buildHistogram(sash, state.getChild(TABLE), classifier);
+		MCContextMenuManager mm = MCContextMenuManager.create(table.getManager().getViewer().getControl());
+		ColumnMenusFactory.addDefaultMenus(table.getManager(), mm);
+		table.getManager().getViewer().addSelectionChangedListener(e -> buildChart(true));
+		table.getManager().getViewer()
+				.addSelectionChangedListener(e -> pageContainer.showSelection(table.getSelection().getItems()));
+		SelectionStoreActionToolkit.addSelectionStoreActions(pageContainer.getSelectionStore(), table,
+				NLS.bind(Messages.ChartAndTableUI_HISTOGRAM_SELECTION, sectionTitle), mm);
+		tableFilterComponent = FilterComponent.createFilterComponent(table.getManager().getViewer().getControl(),
+				table.getManager(), tableFilter, model.getItems().apply(pageFilter),
+				pageContainer.getSelectionStore()::getSelections, this::onFilterChange);
+		mm.add(tableFilterComponent.getShowFilterAction());
+		mm.add(tableFilterComponent.getShowSearchAction());
+	}
+
+	private void setupChartContainers(FormToolkit toolkit) {
+		// Scrolled Composite containing all of the chart-related components
+		ScrolledComposite scChartContainer = new ScrolledComposite(sash, SWT.H_SCROLL | SWT.V_SCROLL);
+		scChartContainer.setAlwaysShowScrollBars(false);
+		scChartContainer.setExpandHorizontal(true);
+		scChartContainer.setExpandVertical(true);
+		scChartContainer.addListener(SWT.Resize, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				int width = controlBar.computeSize(SWT.DEFAULT, SWT.DEFAULT).x;
+				int height = controlBar.computeSize(SWT.DEFAULT, SWT.DEFAULT).y
+						+ buttonGroup.computeSize(SWT.DEFAULT, SWT.DEFAULT).y;
+				if (width > 0 && height > 0) {
+					scChartContainer.setMinSize(scChartContainer.computeSize(width, height));
+					scChartContainer.removeListener(SWT.Resize, this);
+				}
+			}
+		});
+
+		// chartContainer to layout all of the chart components
+		chartContainer = toolkit.createComposite(scChartContainer);
+		chartContainer.setLayout(new GridLayout());
+		chartContainer.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
+		scChartContainer.setContent(chartContainer);
+
+		// Chart Control Toolbar
+		Listener resetListener = new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				onSetRange(false);
+				table.getManager().getViewer().setSelection(null);
+			}
+		};
+		controlBar = new ChartControlBar(chartContainer, resetListener, pageContainer.getRecordingRange());
+		controlBar.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, false));
+		buttonGroup = controlBar.getButtonGroup();
+
+		// Container to hold the chartContainer and a zoom-pan overlay
+		Composite zoomPanAndChartContainer = toolkit.createComposite(chartContainer);
+		zoomPanAndChartContainer.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
+		zoomPanAndChartContainer.setLayout(new FormLayout());
+
+		// Container to hold fixed zoom-pan display
+		zoomPanContainer = toolkit.createComposite(zoomPanAndChartContainer);
+		zoomPanContainer.setLayout(new FillLayout());
+		FormData fd = new FormData();
+		fd.height = 80;
+		fd.width = 150;
+		fd.bottom = new FormAttachment(100, -12);
+		fd.right = new FormAttachment(100, -12);
+		zoomPanContainer.setLayoutData(fd);
+
+		// SashForm to hold the two canvas components: chart text canvas on the left, chart canvas on the right
+		canvasSash = new SashForm(zoomPanAndChartContainer, SWT.HORIZONTAL);
+		fd = new FormData();
+		fd.right = new FormAttachment(100, -1);
+		fd.top = new FormAttachment(0, 1);
+		fd.left = new FormAttachment(0, 1);
+		fd.bottom = new FormAttachment(100, -1);
+		canvasSash.setLayoutData(fd);
+		toolkit.adapt(canvasSash);
+
+		ScrolledComposite scText = new ScrolledComposite(canvasSash, SWT.BORDER | SWT.V_SCROLL);
+		GridData scTextGd = new GridData(SWT.FILL, SWT.FILL, false, true);
+		textCanvas = new ChartTextCanvas(scText);
+		textCanvas.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, true));
+		scTextGd.widthHint = 180;
+		scText.setLayoutData(scTextGd);
+		scText.setContent(textCanvas);
+		scText.setAlwaysShowScrollBars(false);
+		scText.setExpandHorizontal(true);
+		scText.setExpandVertical(true);
+
+		ScrolledComposite scChart = new ScrolledComposite(canvasSash, SWT.BORDER | SWT.V_SCROLL);
+		chartCanvas = new ChartCanvas(scChart);
+		chartCanvas.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
+		scChart.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
+		scChart.setContent(chartCanvas);
+		scChart.setAlwaysShowScrollBars(true);
+		scChart.setExpandHorizontal(true);
+		scChart.setExpandVertical(true);
+
+		timelineCanvas = new TimelineCanvas(chartContainer, chartCanvas, canvasSash, Y_SCALE);
+		GridData gridData = new GridData(SWT.FILL, SWT.DEFAULT, true, false);
+		gridData.heightHint = (int) (TIMELINE_HEIGHT * Y_SCALE);
+		timelineCanvas.setLayoutData(gridData);
+	}
+
+	protected void onFilterChange(IItemFilter filter) {
+		IItemCollection items = getItems();
+		if (tableFilterComponent.isVisible()) {
+			table.show(items.apply(filter));
+			tableFilterComponent.setColor(table.getAllRows().getRowCount());
+		} else if (table != null) {
+			table.show(items);
+		}
+	}
+
+	private void onSetRange(Boolean useRange) {
+		IRange<IQuantity> range = useRange ? timeRange : pageContainer.getRecordingRange();
+		chart.setVisibleRange(range.getStart(), range.getEnd());
+		chart.resetZoomFactor();
+		if (table != null) {
+			table.getManager().getViewer().setSelection(null);
+		}
+		chartCanvas.resetLaneHeight();
+		buildChart(true);
+	}
+
+	@Override
+	public void saveTo(IWritableState writableState) {
+		super.saveTo(writableState);
+		PersistableSashForm.saveState(sash, writableState.createChild(PAGE_SASH));
+		PersistableSashForm.saveState(canvasSash, writableState.createChild(CANVAS_SASH));
+	}
+
+	private void onFlavorSelected(IItemCollection items, IRange<IQuantity> timeRange) {
+		this.selectionItems = items;
+		this.timeRange = timeRange;
+		table.show(getItems());
+
+		if (selectionItems != null) {
+			Object[] tableInput = (Object[]) table.getManager().getViewer().getInput();
+			if (tableInput != null) {
+				table.getManager().getViewer().setSelection(new StructuredSelection(tableInput));
+			} else {
+				table.getManager().getViewer().setSelection(null);
+			}
+		}
+	}
+
+	protected void buildChart(boolean resetLaneHeightControls) {
+		IXDataRenderer rendererRoot = getChartRenderer(getItems(), table.getSelection());
+		if (resetLaneHeightControls) {
+			controlBar.resetLaneHeightToMinimum();
+		}
+		chartCanvas.replaceRenderer(rendererRoot);
+		textCanvas.replaceRenderer(rendererRoot);
+	}
+
+	private IItemCollection getItems() {
+		return selectionItems != null ? selectionItems.apply(pageFilter) : model.getItems().apply(pageFilter);
+	}
+
+	public void setTimeRange(IRange<IQuantity> range) {
+		this.timeRange = range;
+	}
+}
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPageLegacy.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPageLegacy.java
--- /dev/null
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPageLegacy.java
@@ -0,0 +1,366 @@
+/*
+ * Copyright (c) 2018, 2020 Oracle and/or its affiliates. All rights reserved.
+ * 
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.flightrecorder.ui.pages;
+
+import static org.openjdk.jmc.common.item.Aggregators.max;
+import static org.openjdk.jmc.common.item.Aggregators.min;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.action.Separator;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.ui.forms.widgets.FormToolkit;
+import org.openjdk.jmc.common.IMCThread;
+import org.openjdk.jmc.common.IState;
+import org.openjdk.jmc.common.IWritableState;
+import org.openjdk.jmc.common.item.Aggregators;
+import org.openjdk.jmc.common.item.IAggregator;
+import org.openjdk.jmc.common.item.IAttribute;
+import org.openjdk.jmc.common.item.IItemCollection;
+import org.openjdk.jmc.common.item.IItemFilter;
+import org.openjdk.jmc.common.item.ItemFilters;
+import org.openjdk.jmc.common.unit.IQuantity;
+import org.openjdk.jmc.common.unit.IRange;
+import org.openjdk.jmc.flightrecorder.JfrAttributes;
+import org.openjdk.jmc.flightrecorder.jdk.JdkAttributes;
+import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;
+import org.openjdk.jmc.flightrecorder.rules.util.JfrRuleTopics;
+import org.openjdk.jmc.flightrecorder.ui.FlightRecorderUI;
+import org.openjdk.jmc.flightrecorder.ui.IDataPageFactory;
+import org.openjdk.jmc.flightrecorder.ui.IDisplayablePage;
+import org.openjdk.jmc.flightrecorder.ui.IPageContainer;
+import org.openjdk.jmc.flightrecorder.ui.IPageDefinition;
+import org.openjdk.jmc.flightrecorder.ui.IPageUI;
+import org.openjdk.jmc.flightrecorder.ui.StreamModel;
+import org.openjdk.jmc.flightrecorder.ui.common.AbstractDataPage;
+import org.openjdk.jmc.flightrecorder.ui.common.FlavorSelector.FlavorSelectorState;
+import org.openjdk.jmc.flightrecorder.ui.common.ImageConstants;
+import org.openjdk.jmc.flightrecorder.ui.common.ItemHistogram;
+import org.openjdk.jmc.flightrecorder.ui.common.ItemHistogram.HistogramSelection;
+import org.openjdk.jmc.flightrecorder.ui.common.ItemHistogram.ItemHistogramBuilder;
+import org.openjdk.jmc.flightrecorder.ui.common.ItemRow;
+import org.openjdk.jmc.flightrecorder.ui.common.ThreadGraphLanes;
+import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
+import org.openjdk.jmc.ui.UIPlugin;
+import org.openjdk.jmc.ui.charts.IXDataRenderer;
+import org.openjdk.jmc.ui.charts.QuantitySpanRenderer;
+import org.openjdk.jmc.ui.charts.RendererToolkit;
+import org.openjdk.jmc.ui.column.ColumnManager.SelectionState;
+import org.openjdk.jmc.ui.column.TableSettings;
+import org.openjdk.jmc.ui.handlers.ActionToolkit;
+import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
+
+public class ThreadsPageLegacy extends AbstractDataPage {
+
+	public static class ThreadsPageLegacyFactory implements IDataPageFactory {
+
+		@Override
+		public String getName(IState state) {
+			return Messages.ThreadsPage_NAME_LEGACY;
+		}
+
+		@Override
+		public String[] getTopics(IState state) {
+			return new String[] {JfrRuleTopics.THREADS_TOPIC};
+		}
+
+		@Override
+		public ImageDescriptor getImageDescriptor(IState state) {
+			return FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.PAGE_THREADS);
+		}
+
+		@Override
+		public IDisplayablePage createPage(IPageDefinition definition, StreamModel items, IPageContainer editor) {
+			return new ThreadsPageLegacy(definition, items, editor);
+		}
+
+	}
+
+	private static final String THREAD_START_COL = "threadStart"; //$NON-NLS-1$
+	private static final String THREAD_END_COL = "threadEnd"; //$NON-NLS-1$
+	private static final String THREAD_DURATION_COL = "threadDuration"; //$NON-NLS-1$
+	private static final String THREAD_LANE = "threadLane"; //$NON-NLS-1$
+
+	private static final IItemFilter pageFilter = ItemFilters.hasAttribute(JfrAttributes.EVENT_THREAD);
+	private static final ItemHistogramBuilder HISTOGRAM = new ItemHistogramBuilder();
+
+	static {
+		HISTOGRAM.addColumn(JdkAttributes.EVENT_THREAD_GROUP_NAME);
+		HISTOGRAM.addColumn(JdkAttributes.EVENT_THREAD_ID);
+		HISTOGRAM.addColumn(THREAD_START_COL,
+				min(Messages.JavaApplicationPage_COLUMN_THREAD_START,
+						Messages.JavaApplicationPage_COLUMN_THREAD_START_DESC, JdkTypeIDs.JAVA_THREAD_START,
+						JfrAttributes.EVENT_TIMESTAMP));
+		/*
+		 * Will order empty cells before first end time.
+		 * 
+		 * It should be noted that no event (empty column cell) is considered less than all values
+		 * (this is common for all columns), which causes the column to sort threads without end
+		 * time (indicating that the thread ended after the end of the recording) is ordered before
+		 * the thread that ended first. While this is not optimal, we decided to accept it as it's
+		 * not obviously better to have this particular column ordering empty cells last in contrast
+		 * to all other columns.
+		 */
+		HISTOGRAM.addColumn(THREAD_END_COL,
+				max(Messages.JavaApplicationPage_COLUMN_THREAD_END, Messages.JavaApplicationPage_COLUMN_THREAD_END_DESC,
+						JdkTypeIDs.JAVA_THREAD_END, JfrAttributes.EVENT_TIMESTAMP));
+		HISTOGRAM.addColumn(THREAD_DURATION_COL, ic -> {
+			IQuantity threadStart = ic.apply(ItemFilters.type(JdkTypeIDs.JAVA_THREAD_START))
+					.getAggregate((IAggregator<IQuantity, ?>) Aggregators.min(JfrAttributes.EVENT_TIMESTAMP));
+			IQuantity threadEnd = ic.apply(ItemFilters.type(JdkTypeIDs.JAVA_THREAD_END))
+					.getAggregate((IAggregator<IQuantity, ?>) Aggregators.max(JfrAttributes.EVENT_TIMESTAMP));
+			if (threadStart != null && threadEnd != null) {
+				return threadEnd.subtract(threadStart);
+			}
+			return null;
+		}, Messages.JavaApplicationPage_COLUMN_THREAD_DURATION,
+				Messages.JavaApplicationPage_COLUMN_THREAD_DURATION_DESC);
+	}
+
+	private class ThreadsPageUi extends ChartAndTableUI {
+		private static final String THREADS_TABLE_FILTER = "threadsTableFilter"; //$NON-NLS-1$
+		private static final String HIDE_THREAD = "hideThread"; //$NON-NLS-1$
+		private static final String RESET_CHART = "resetChart"; //$NON-NLS-1$
+		private Boolean isChartMenuActionsInit;
+		private Boolean isChartModified;
+		private Boolean reloadThreads;
+		private IAction hideThreadAction;
+		private IAction resetChartAction;
+		private List<IXDataRenderer> threadRows;
+		private MCContextMenuManager mm;
+		private ThreadGraphLanes lanes;
+
+		ThreadsPageUi(Composite parent, FormToolkit toolkit, IPageContainer editor, IState state) {
+			super(pageFilter, getDataSource(), parent, toolkit, editor, state, getName(), pageFilter, getIcon(),
+					flavorSelectorState, JfrAttributes.EVENT_THREAD);
+			mm = (MCContextMenuManager) chartCanvas.getContextMenu();
+			sash.setOrientation(SWT.HORIZONTAL);
+			addActionsToContextMenu(mm);
+			// FIXME: The lanes field is initialized by initializeChartConfiguration which is called by the super constructor. This is too indirect for SpotBugs to resolve and should be simplified.
+			lanes.updateContextMenu(mm, false);
+
+			form.getToolBarManager()
+					.add(ActionToolkit.action(() -> lanes.openEditLanesDialog(mm, false),
+							Messages.ThreadsPage_EDIT_LANES,
+							FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_LANES_EDIT)));
+			form.getToolBarManager().update(true);
+			chartLegend.getControl().dispose();
+			buildChart();
+			table.getManager().setSelectionState(histogramSelectionState);
+			tableFilterComponent.loadState(state.getChild(THREADS_TABLE_FILTER));
+			chart.setVisibleRange(visibleRange.getStart(), visibleRange.getEnd());
+			onFilterChange(tableFilter);
+		}
+
+		/**
+		 * Hides a thread from the chart and rebuilds the chart
+		 */
+		private void hideThread(Object thread) {
+			if (this.threadRows != null && this.threadRows.size() > 0 && thread instanceof IMCThread) {
+				int index = indexOfThread(thread);
+				if (index != -1) {
+					this.threadRows.remove(index);
+					this.reloadThreads = false;
+					buildChart();
+					if (!this.isChartModified) {
+						this.isChartModified = true;
+						setResetChartActionEnablement(true);
+					}
+				}
+				if (this.threadRows.size() == 0) {
+					setHideThreadActionEnablement(false);
+				}
+			}
+		}
+
+		/**
+		 * Locates the index of the target Thread in the current selection list
+		 *
+		 * @param thread
+		 *            the thread of interest
+		 * @return the index of the thread in the current selection, or -1 if not found
+		 */
+		private int indexOfThread(Object thread) {
+			for (int i = 0; i < this.threadRows.size() && thread != null; i++) {
+				if (this.threadRows.get(i) instanceof QuantitySpanRenderer) {
+					if (thread.equals(((QuantitySpanRenderer) this.threadRows.get(i)).getData())) {
+						return i;
+					}
+				}
+			}
+			return -1;
+		}
+
+		/**
+		 * Update the context menu to include actions to hide threads and reset the chart
+		 */
+		private void addActionsToContextMenu(MCContextMenuManager mm) {
+			mm.add(new Separator());
+
+			IAction hideThreadAction = ActionToolkit.action(() -> this.hideThread(chartCanvas.getHoveredItemData()),
+					Messages.ThreadsPage_HIDE_THREAD_ACTION,
+					UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_DELETE));
+			hideThreadAction.setId(HIDE_THREAD);
+			this.hideThreadAction = hideThreadAction;
+			mm.add(hideThreadAction);
+
+			IAction resetChartAction = ActionToolkit.action(() -> this.resetChartToSelection(),
+					Messages.ThreadsPage_RESET_CHART_TO_SELECTION_ACTION,
+					UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_REFRESH));
+			resetChartAction.setId(RESET_CHART);
+			resetChartAction.setEnabled(this.isChartModified);
+			this.resetChartAction = resetChartAction;
+			mm.add(resetChartAction);
+
+			this.isChartMenuActionsInit = true;
+		}
+
+		/**
+		 * Redraws the chart, and disables the reset chart menu action
+		 */
+		private void resetChartToSelection() {
+			buildChart();
+			this.isChartModified = false;
+			setResetChartActionEnablement(false);
+			setHideThreadActionEnablement(true);
+		}
+
+		private void setHideThreadActionEnablement(Boolean enabled) {
+			this.hideThreadAction.setEnabled(enabled);
+		}
+
+		private void setResetChartActionEnablement(Boolean enabled) {
+			this.resetChartAction.setEnabled(enabled);
+		}
+
+		@Override
+		protected ItemHistogram buildHistogram(Composite parent, IState state, IAttribute<?> classifier) {
+			ItemHistogram build = HISTOGRAM.buildWithoutBorder(parent, classifier, TableSettings.forState(state));
+			return build;
+		}
+
+		@Override
+		protected IXDataRenderer getChartRenderer(IItemCollection itemsInTable, HistogramSelection tableSelection) {
+			List<IXDataRenderer> rows = new ArrayList<>();
+
+			IItemCollection selectedItems;
+			HistogramSelection selection;
+			if (tableSelection.getRowCount() == 0) {
+				selectedItems = itemsInTable;
+				selection = table.getAllRows();
+			} else {
+				selectedItems = tableSelection.getItems();
+				selection = tableSelection;
+			}
+			boolean useDefaultSelection = rows.size() > 1;
+			if (lanes.getLaneDefinitions().stream().anyMatch(a -> a.isEnabled()) && selection.getRowCount() > 0) {
+				if (this.reloadThreads) {
+					this.threadRows = selection
+							.getSelectedRows((object, items) -> lanes.buildThreadRenderer(object, items))
+							.collect(Collectors.toList());
+					this.isChartModified = false;
+					if (this.isChartMenuActionsInit) {
+						setResetChartActionEnablement(false);
+						setHideThreadActionEnablement(true);
+					}
+				} else {
+					this.reloadThreads = true;
+				}
+
+				double threadsWeight = Math.sqrt(threadRows.size()) * 0.15;
+				double otherRowWeight = Math.max(threadsWeight * 0.1, (1 - threadsWeight) / rows.size());
+				List<Double> weights = Stream
+						.concat(Stream.generate(() -> otherRowWeight).limit(rows.size()), Stream.of(threadsWeight))
+						.collect(Collectors.toList());
+				rows.add(RendererToolkit.uniformRows(this.threadRows));
+				useDefaultSelection = true;
+				rows = Arrays.asList(RendererToolkit.weightedRows(rows, weights));
+			}
+			IXDataRenderer root = rows.size() == 1 ? rows.get(0) : RendererToolkit.uniformRows(rows);
+			// We don't use the default selection when there is only one row. This is to get the correct payload.
+			return useDefaultSelection ? new ItemRow(root, selectedItems.apply(lanes.getEnabledLanesFilter())) : root;
+		}
+
+		@Override
+		protected void onFilterChange(IItemFilter filter) {
+			super.onFilterChange(filter);
+			tableFilter = filter;
+		}
+
+		@Override
+		public void saveTo(IWritableState state) {
+			super.saveTo(state);
+			tableFilterComponent.saveState(state.createChild(THREADS_TABLE_FILTER));
+			lanes.saveTo(state);
+			saveToLocal();
+		}
+
+		private void saveToLocal() {
+			flavorSelectorState = flavorSelector.getFlavorSelectorState();
+			histogramSelectionState = table.getManager().getSelectionState();
+			visibleRange = chart.getVisibleRange();
+		}
+
+		@Override
+		protected List<IAction> initializeChartConfiguration(IState state) {
+			this.isChartMenuActionsInit = false;
+			this.isChartModified = false;
+			this.reloadThreads = true;
+			lanes = new ThreadGraphLanes(() -> getDataSource(), () -> buildChart());
+			return lanes.initializeChartConfiguration(Stream.of(state.getChildren(THREAD_LANE)));
+		}
+	}
+
+	private FlavorSelectorState flavorSelectorState;
+	private SelectionState histogramSelectionState;
+	private IItemFilter tableFilter;
+	private IRange<IQuantity> visibleRange;
+
+	public ThreadsPageLegacy(IPageDefinition definition, StreamModel model, IPageContainer editor) {
+		super(definition, model, editor);
+		visibleRange = editor.getRecordingRange();
+	}
+
+	@Override
+	public IPageUI display(Composite parent, FormToolkit toolkit, IPageContainer editor, IState state) {
+		return new ThreadsPageUi(parent, toolkit, editor, state);
+	}
+
+}
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/resources/org/openjdk/jmc/flightrecorder/ui/messages/internal/messages.properties b/application/org.openjdk.jmc.flightrecorder.ui/src/main/resources/org/openjdk/jmc/flightrecorder/ui/messages/internal/messages.properties
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/resources/org/openjdk/jmc/flightrecorder/ui/messages/internal/messages.properties
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/resources/org/openjdk/jmc/flightrecorder/ui/messages/internal/messages.properties
@@ -492,16 +492,21 @@
 TABLECOMPONENT_NONE=[None]
 
 ThreadDumpsPage_PAGE_NAME=Thread Dumps
 
 ThreadsPage_EDIT_LANES=Edit Thread Lanes
+ThreadsPage_FOLD_CHART_TOOLTIP=Fold Chart
+ThreadsPage_FOLD_TABLE_TOOLTIP=Fold Table
 ThreadsPage_HIDE_THREAD_ACTION=Hide Thread From The Chart
 ThreadsPage_LANE_FILTER_HEADER=THREAD STATE SELECTION
 # {0} is the thread name, {1} is the lane name
 ThreadsPage_LANE_TOOLTIP_TITLE={0} / {1} Lane
 ThreadsPage_NAME=Threads
+ThreadsPage_NAME_LEGACY = (Legacy) Threads
 ThreadsPage_RESET_CHART_TO_SELECTION_ACTION=Reset The Chart To Current Selection
+ThreadsPage_SHOW_CHART_TOOLTIP=Show Chart
+ThreadsPage_SHOW_TABLE_TOOLTIP=Show Table
 ThreadsPage_VIEW_THREAD_DETAILS=View Thread Details
 ThreadsPage_TABLE_POPUP_DESCRIPTION=Store a thread selection to make a new filter
 ThreadsPage_TABLE_POPUP_TITLE=Thread Details
 
 TlabPage_PAGE_NAME=TLAB Allocations
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/ChartFilterControlBar.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/ChartFilterControlBar.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/ChartFilterControlBar.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2019, Red Hat Inc. All rights reserved.
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * The contents of this file are subject to the terms of either the Universal Permissive License
- * v 1.0 as shown at http://oss.oracle.com/licenses/upl
- *
- * or the following license:
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted
- * provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
- * and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
- * conditions and the following disclaimer in the documentation and/or other materials provided with
- * the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
- * endorse or promote products derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
- * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.openjdk.jmc.ui.charts;
-
-import org.eclipse.jface.resource.JFaceResources;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.layout.GridData;
-import org.eclipse.swt.layout.GridLayout;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Label;
-import org.eclipse.swt.widgets.Listener;
-
-import org.openjdk.jmc.common.unit.IQuantity;
-import org.openjdk.jmc.common.unit.IRange;
-import org.openjdk.jmc.ui.misc.ChartCanvas;
-import org.openjdk.jmc.ui.misc.PatternFly.Palette;
-import org.openjdk.jmc.ui.misc.TimeFilter;
-
-public class ChartFilterControlBar extends Composite {
-
-	private static final String THREADS_LABEL = "Threads";
-
-	private TimeFilter timeFilter;
-
-	public ChartFilterControlBar(Composite parent, Listener resetListener, IRange<IQuantity> recordingRange) {
-		super(parent, SWT.NONE);
-		this.setLayout(new GridLayout(3, false));
-		this.setBackground(Palette.getThreadsPageBackgroundColor());
-		Label nameLabel = new Label(this, SWT.CENTER | SWT.HORIZONTAL);
-		nameLabel.setText(THREADS_LABEL);
-		nameLabel.setBackground(Palette.getThreadsPageBackgroundColor());
-		GridData gd = new GridData(SWT.FILL, SWT.CENTER, false, true);
-		gd.widthHint = 180;
-		nameLabel.setLayoutData(gd);
-		nameLabel.setFont(JFaceResources.getFontRegistry().get(JFaceResources.BANNER_FONT));
-
-		timeFilter = new TimeFilter(this, recordingRange, resetListener);
-		timeFilter.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, false, false));
-	}
-
-	public void setChart(XYChart chart) {
-		timeFilter.setChart(chart);
-	}
-
-	public void setChartCanvas(ChartCanvas canvas) {
-		timeFilter.setChartCanvas(canvas);
-	}
-
-	public void setStartTime(IQuantity startTime) {
-		timeFilter.setStartTime(startTime);
-	}
-
-	public void setEndTime(IQuantity endTime) {
-		timeFilter.setEndTime(endTime);
-	}
-}
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/XYChart.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/XYChart.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/XYChart.java
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/XYChart.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -49,11 +49,12 @@
 import org.openjdk.jmc.common.unit.IRange;
 import org.openjdk.jmc.common.unit.QuantitiesToolkit;
 import org.openjdk.jmc.common.unit.QuantityRange;
 import org.openjdk.jmc.common.unit.UnitLookup;
 import org.openjdk.jmc.ui.charts.IChartInfoVisitor.ITick;
-import org.openjdk.jmc.ui.misc.ChartDisplayControlBar;
+import org.openjdk.jmc.ui.misc.ChartButtonGroup;
+import org.openjdk.jmc.ui.misc.ChartControlBar;
 import org.openjdk.jmc.ui.misc.TimelineCanvas;
 import org.openjdk.jmc.ui.misc.PatternFly.Palette;
 
 public class XYChart {
 	private static final String ELLIPSIS = "..."; //$NON-NLS-1$
@@ -87,12 +88,12 @@
 	private static final double ZOOM_PAN_FACTOR = 0.05;
 	private static final int ZOOM_PAN_MODIFIER = 2;
 	private double zoomPanPower = ZOOM_PAN_FACTOR / ZOOM_PAN_MODIFIER;
 	private double currentZoom;
 	private int zoomSteps;
-	private ChartDisplayControlBar displayBar;
-	private ChartFilterControlBar filterBar;
+	private ChartButtonGroup buttonGroup;
+	private ChartControlBar controlBar;
 	private Stack<Integer> modifiedSteps;
 	private TimelineCanvas timelineCanvas;
 	private int longestCharWidth = 0;
 
 	public XYChart(IRange<IQuantity> range, IXDataRenderer rendererRoot) {
@@ -103,16 +104,16 @@
 		this(range.getStart(), range.getEnd(), rendererRoot, xOffset);
 	}
 
 	// JFR Threads Page
 	public XYChart(IRange<IQuantity> range, IXDataRenderer rendererRoot, int xOffset, Integer yOffset,
-			TimelineCanvas timelineCanvas, ChartFilterControlBar filterBar, ChartDisplayControlBar displayBar) {
+			TimelineCanvas timelineCanvas, ChartControlBar controlBar, ChartButtonGroup buttonGroup) {
 		this(range.getStart(), range.getEnd(), rendererRoot, xOffset);
 		this.yOffset = yOffset;
 		this.timelineCanvas = timelineCanvas;
-		this.filterBar = filterBar;
-		this.displayBar = displayBar;
+		this.controlBar = controlBar;
+		this.buttonGroup = buttonGroup;
 		this.rangeDuration = range.getExtent();
 		this.currentZoom = BASE_ZOOM_LEVEL;
 		this.isZoomCalculated = false;
 	}
 
@@ -180,12 +181,12 @@
 			context.setTransform(oldTransform);
 		}
 	}
 
 	public void renderTextCanvasText(Graphics2D context, int width, int height) {
-		axisWidth = width;
 		AffineTransform oldTransform = context.getTransform();
+		axisWidth = width - xOffset;
 		doRenderTextCanvasText(context, height);
 		context.setTransform(oldTransform);
 	}
 
 	public void renderText(Graphics2D context, int width, int height) {
@@ -214,12 +215,12 @@
 			context.drawRect(0, rangeIndicatorY, axisWidth - 1, RANGE_INDICATOR_HEIGHT);
 		}
 	}
 
 	public void updateZoomPanIndicator() {
-		if (displayBar != null) {
-			displayBar.updateZoomPanIndicator();
+		if (buttonGroup != null) {
+			buttonGroup.updateZoomPanIndicator();
 		}
 	}
 
 	private IRenderedRow getRendererResult(Graphics2D context, int axisHeight) {
 		if (xBucketRange == null) {
@@ -432,12 +433,12 @@
 			newStart = newStart.add(diff);
 			newEnd = end;
 		}
 		currentStart = newStart;
 		currentEnd = newEnd;
-		filterBar.setStartTime(currentStart);
-		filterBar.setEndTime(currentEnd);
+		controlBar.setStartTime(currentStart);
+		controlBar.setEndTime(currentEnd);
 		isZoomCalculated = true;
 		return true;
 	}
 
 	/**
@@ -513,12 +514,10 @@
 		} else if (steps > 0) {
 			zoomIn(steps);
 		} else {
 			zoomOut(steps);
 		}
-		// set displayBar text
-		displayBar.setZoomPercentageText(currentZoom);
 		return true;
 	}
 
 	/**
 	 * Zoom into the chart at a rate of 5% of the overall recording range at each step. If the chart
@@ -590,11 +589,10 @@
 	// will have to calculate the new zoom level
 	public void resetZoomFactor() {
 		zoomSteps = 0;
 		zoomPanPower = ZOOM_PAN_FACTOR / ZOOM_PAN_MODIFIER;
 		currentZoom = BASE_ZOOM_LEVEL;
-		displayBar.setZoomPercentageText(currentZoom);
 		modifiedSteps = new Stack<Integer>();
 	}
 
 	/**
 	 * Reset the visible range to be the recording range, and reset the zoom-related objects
@@ -606,12 +604,10 @@
 
 	private void selectionZoom(IQuantity newStart, IQuantity newEnd) {
 		double percentage = calculateZoom(newStart, newEnd);
 		zoomSteps = calculateZoomSteps(percentage);
 		currentZoom = BASE_ZOOM_LEVEL + (percentage * 100);
-		displayBar.setScaleValue(zoomSteps);
-		displayBar.setZoomPercentageText(currentZoom);
 	}
 
 	/**
 	 * When a drag-select zoom occurs, use the new range value to determine how many steps have been
 	 * taken, and adjust zoomSteps and zoomPower accordingly
@@ -677,13 +673,13 @@
 			} else {
 				// Ensures that zoom out is always allowed
 				currentStart = QuantitiesToolkit.min(rangeStart, currentStart);
 				currentEnd = QuantitiesToolkit.max(rangeEnd, currentEnd);
 			}
-			if (filterBar != null) {
-				filterBar.setStartTime(currentStart);
-				filterBar.setEndTime(currentEnd);
+			if (controlBar != null) {
+				controlBar.setStartTime(currentStart);
+				controlBar.setEndTime(currentEnd);
 			}
 			rangeListeners.stream().forEach(l -> l.accept(getVisibleRange()));
 		}
 	}
 
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartButtonGroup.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartButtonGroup.java
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartButtonGroup.java
@@ -0,0 +1,531 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.ui.misc;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Timer;
+import java.util.TimerTask;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.ScrolledComposite;
+import org.eclipse.swt.events.MouseAdapter;
+import org.eclipse.swt.events.MouseEvent;
+import org.eclipse.swt.events.MouseMoveListener;
+import org.eclipse.swt.events.MouseWheelListener;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.events.PaintListener;
+import org.eclipse.swt.graphics.Cursor;
+import org.eclipse.swt.graphics.GC;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Canvas;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Listener;
+import org.openjdk.jmc.common.unit.IQuantity;
+import org.openjdk.jmc.common.unit.IRange;
+import org.openjdk.jmc.ui.UIPlugin;
+import org.openjdk.jmc.ui.charts.SubdividedQuantityRange;
+import org.openjdk.jmc.ui.charts.XYChart;
+import org.openjdk.jmc.ui.misc.PatternFly.Palette;
+
+public class ChartButtonGroup extends Composite {
+	private static final String DEFAULT_CURSOR = "defaultCursor";
+	private static final String HAND_CURSOR = "handCursor";
+	private static final String ZOOM_IN_CURSOR = "zoomInCursor";
+	private static final String ZOOM_OUT_CURSOR = "zoomOutCursor";
+	private static final int ZOOM_INCREMENT = 1;
+	private List<Button> buttonGroup;
+	private Map<String, Cursor> cursors;
+	private Button scaleToFitBtn;
+	private Button selectionBtn;
+	private Button zoomInBtn;
+	private Button zoomOutBtn;
+	private Button zoomPanBtn;
+	private ChartCanvas chartCanvas;
+	private ChartTextCanvas textCanvas;
+	private Runnable resetLaneHeightAction;
+	private XYChart chart;
+	private ZoomPan zoomPan;
+
+	public ChartButtonGroup(Composite parent) {
+		super(parent, SWT.NONE);
+		GridLayout gl = new GridLayout(5, true);
+		gl.horizontalSpacing = 0;
+		gl.marginWidth = 0;
+		this.setLayout(gl);
+		this.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, false));
+
+		cursors = new HashMap<>();
+		initCursorMap();
+
+		buttonGroup = new ArrayList<>();
+		initSelectionButton();
+		initZoomInButton();
+		initZoomOutButton();
+		initZoomPanButton();
+		initScaleToFitButton();
+	}
+
+	private void initCursorMap() {
+		cursors.put(DEFAULT_CURSOR, getDisplay().getSystemCursor(SWT.CURSOR_ARROW));
+		cursors.put(HAND_CURSOR, getDisplay().getSystemCursor(SWT.CURSOR_HAND));
+		cursors.put(ZOOM_IN_CURSOR, new Cursor(getDisplay(),
+				UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_IN).getImageData(), 0, 0));
+		cursors.put(ZOOM_OUT_CURSOR, new Cursor(getDisplay(),
+				UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_OUT).getImageData(), 0, 0));
+	}
+
+	private void initSelectionButton() {
+		selectionBtn = new Button(this, SWT.TOGGLE);
+		selectionBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		selectionBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_SELECTION));
+		selectionBtn.setSelection(true);
+		selectionBtn.setToolTipText(Messages.ChartDisplayControlBar_SELECTION_TOOL_TOOLTIP);
+		selectionBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				setButtonSelectionStates(selectionBtn, null);
+				changeCursor(DEFAULT_CURSOR);
+			};
+		});
+		buttonGroup.add(selectionBtn);
+	}
+
+	private void initZoomInButton() {
+		zoomInBtn = new Button(this, SWT.TOGGLE);
+		zoomInBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		zoomInBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_IN));
+		zoomInBtn.setSelection(false);
+		StringBuilder sb = new StringBuilder();
+		sb.append(Messages.ChartDisplayControlBar_ZOOM_IN_CLICK_TOOLTIP);
+		sb.append(System.getProperty("line.separator"));
+		sb.append(Messages.ChartDisplayControlBar_ZOOM_IN_HOLD_TOOLTIP);
+		zoomInBtn.setToolTipText(sb.toString());
+		zoomInBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				setButtonSelectionStates(zoomInBtn, zoomPanBtn);
+				changeCursor(ZOOM_IN_CURSOR);
+			}
+		});
+		zoomInBtn.addMouseListener(new LongPressListener(ZOOM_INCREMENT));
+		buttonGroup.add(zoomInBtn);
+	}
+
+	private void initZoomOutButton() {
+		zoomOutBtn = new Button(this, SWT.TOGGLE);
+		zoomOutBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		zoomOutBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_OUT));
+		zoomOutBtn.setSelection(false);
+		StringBuilder sb = new StringBuilder();
+		sb.append(Messages.ChartDisplayControlBar_ZOOM_OUT_CLICK_TOOLTIP);
+		sb.append(System.getProperty("line.separator"));
+		sb.append(Messages.ChartDisplayControlBar_ZOOM_OUT_HOLD_TOOLTIP);
+		zoomOutBtn.setToolTipText(sb.toString());
+		zoomOutBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event e) {
+				setButtonSelectionStates(zoomOutBtn, zoomPanBtn);
+				changeCursor(ZOOM_OUT_CURSOR);
+			}
+		});
+		zoomOutBtn.addMouseListener(new LongPressListener(-ZOOM_INCREMENT));
+		buttonGroup.add(zoomOutBtn);
+	}
+
+	private void initZoomPanButton() {
+		zoomPanBtn = new Button(this, SWT.TOGGLE);
+		zoomPanBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		zoomPanBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_PAN));
+		zoomPanBtn.setSelection(false);
+		zoomPanBtn.setToolTipText(Messages.ChartDisplayControlBar_ZOOM_PAN_TOOLTIP);
+		zoomPanBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				showZoomPanDisplay(zoomPanBtn.getSelection());
+			}
+		});
+		buttonGroup.add(zoomPanBtn);
+	}
+
+	private void initScaleToFitButton() {
+		scaleToFitBtn = new Button(this, SWT.PUSH);
+		scaleToFitBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		scaleToFitBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_SCALE_TO_FIT));
+		scaleToFitBtn.setSelection(false);
+		scaleToFitBtn.setToolTipText(Messages.ChartDisplayControlBar_SCALE_TO_FIT_TOOLTIP);
+		scaleToFitBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				chart.resetTimeline();
+				chartCanvas.redrawChart();
+				getDisplay().syncExec(resetLaneHeightAction);
+			}
+		});
+		buttonGroup.add(scaleToFitBtn);
+	}
+
+	void setChart(XYChart chart) {
+		this.chart = chart;
+	}
+
+	void setResetLaneHeightAction(Runnable resetLaneHeightAction) {
+		this.resetLaneHeightAction = resetLaneHeightAction;
+	}
+
+	void setChartCanvas(ChartCanvas chartCanvas) {
+		this.chartCanvas = chartCanvas;
+	}
+
+	void setTextCanvas(ChartTextCanvas textCanvas) {
+		this.textCanvas = textCanvas;
+	}
+
+	public void updateZoomPanIndicator() {
+		zoomPan.redraw();
+	}
+
+	public void zoomOnClick(Boolean mouseDown) {
+		boolean shouldZoom = zoomInBtn.getSelection() || zoomOutBtn.getSelection();
+		if (shouldZoom) {
+			if (mouseDown) {
+				chart.clearSelection();
+			} else {
+				int zoomAmount = zoomInBtn.getSelection() ? ZOOM_INCREMENT : -ZOOM_INCREMENT;
+				zoom(zoomAmount);
+				if (textCanvas != null) {
+					textCanvas.redrawChartText();
+				}
+			}
+		}
+	}
+
+	public void zoomToSelection() {
+		if (zoomInBtn.getSelection()) {
+			IQuantity selectionStart = chart.getSelectionStart();
+			IQuantity selectionEnd = chart.getSelectionEnd();
+			if (selectionStart == null || selectionEnd == null) {
+				chart.clearVisibleRange();
+			} else {
+				chart.setVisibleRange(selectionStart, selectionEnd);
+				chartCanvas.redrawChart();
+			}
+		}
+	}
+
+	private void changeCursor(String cursorName) {
+		chartCanvas.changeCursor(cursors.get(cursorName));
+	}
+
+	private void setButtonSelectionStates(Button buttonSelected, Button dependentButton) {
+		for (Button button : buttonGroup) {
+			if ((button.getStyle() & SWT.TOGGLE) != 0) {
+				if (button.equals(buttonSelected)) {
+					button.setSelection(true);
+				} else if (dependentButton != null) {
+					if (button.equals(dependentButton)) {
+						button.setSelection(true);
+					} else {
+						button.setSelection(false);
+					}
+				} else {
+					button.setSelection(false);
+				}
+			}
+			showZoomPanDisplay(zoomPanBtn.getSelection());
+		}
+	}
+
+	private class LongPressListener extends MouseAdapter {
+
+		private static final long LONG_PRESS_TIME = 500;
+		private Timer timer;
+		private int zoomAmount;
+
+		LongPressListener(int zoomAmount) {
+			this.zoomAmount = zoomAmount;
+		}
+
+		@Override
+		public void mouseDown(MouseEvent e) {
+			if (e.button == 1) {
+				timer = new Timer();
+				timer.schedule(new LongPress(), LONG_PRESS_TIME, (long) (LONG_PRESS_TIME * 1.5));
+			}
+		}
+
+		@Override
+		public void mouseUp(MouseEvent e) {
+			timer.cancel();
+		}
+
+		public class LongPress extends TimerTask {
+
+			@Override
+			public void run() {
+				doZoomInOut(zoomAmount);
+			}
+		}
+
+		private void doZoomInOut(int zoomAmount) {
+			DisplayToolkit.inDisplayThread().execute(() -> zoom(zoomAmount));
+		}
+	}
+
+	private void zoom(int zoomAmount) {
+		chart.zoom(zoomAmount);
+		chartCanvas.redrawChart();
+	}
+
+	public void createZoomPan(Composite parent) {
+		zoomPan = new ZoomPan(parent);
+		parent.setVisible(false);
+	}
+
+	private void showZoomPanDisplay(boolean show) {
+		if (show) {
+			zoomPan.getParent().setVisible(true);
+			zoomPan.redrawZoomPan();
+		} else {
+			zoomPan.getParent().setVisible(false);
+		}
+	}
+
+	private class ZoomPan extends Canvas {
+		private static final int BORDER_PADDING = 2;
+		private static final double MIN_HEIGHT_PERCENT = 0.15;
+		private static final double MIN_WIDTH_PERCENT = 0.08;
+		private IRange<IQuantity> chartRange;
+		private IRange<IQuantity> lastChartZoomedRange;
+		private Rectangle zoomRect;
+
+		public ZoomPan(Composite parent) {
+			super(parent, SWT.NO_BACKGROUND);
+			addPaintListener(new Painter());
+			PanDetector panDetector = new PanDetector();
+			addMouseListener(panDetector);
+			addMouseMoveListener(panDetector);
+			addMouseWheelListener(panDetector);
+			chartRange = chart.getVisibleRange();
+		}
+
+		public void redrawZoomPan() {
+			redraw();
+		}
+
+		private class PanDetector extends MouseAdapter implements MouseMoveListener, MouseWheelListener {
+			Point currentSelection;
+			Point lastSelection;
+			boolean isPan = false;
+
+			@Override
+			public void mouseDown(MouseEvent e) {
+				if (e.button == 1 && inBounds(e)) {
+					isPan = true;
+					chart.setIsZoomPanDrag(isPan);
+					currentSelection = chartCanvas.translateDisplayToImageCoordinates(e.x, e.y);
+				}
+			}
+
+			private boolean inBounds(MouseEvent e) {
+				Point zoomCanvasBounds = getParent().getSize();
+				if (zoomRect.height < MIN_HEIGHT_PERCENT * zoomCanvasBounds.y
+						|| zoomRect.width < MIN_WIDTH_PERCENT * zoomCanvasBounds.x) {
+					return zoomCanvasBounds.x >= e.x && zoomCanvasBounds.y >= e.y;
+				} else {
+					return zoomRect.contains(e.x, e.y);
+				}
+			}
+
+			@Override
+			public void mouseUp(MouseEvent e) {
+				isPan = false;
+				chart.setIsZoomPanDrag(isPan);
+			}
+
+			@Override
+			public void mouseMove(MouseEvent e) {
+				zoomPan.setCursor(cursors.get(HAND_CURSOR));
+				if (isPan && getParent().getSize().x >= e.x && getParent().getSize().y >= e.y) {
+					lastSelection = currentSelection;
+					currentSelection = chartCanvas.translateDisplayToImageCoordinates(e.x, e.y);
+					int xdiff = currentSelection.x - lastSelection.x;
+					int ydiff = currentSelection.y - lastSelection.y;
+					updateZoomRectFromPan(xdiff, ydiff);
+				}
+			}
+
+			@Override
+			public void mouseScrolled(MouseEvent e) {
+				updateZoomRectFromPan(0, -e.count);
+			}
+		}
+
+		private void updateZoomRectFromPan(int xdiff, int ydiff) {
+			Point bounds = getParent().getSize();
+			boolean xModified = false;
+			boolean yModified = false;
+
+			int xOld = zoomRect.x;
+			zoomRect.x += xdiff;
+			if (zoomRect.x > (bounds.x - zoomRect.width - BORDER_PADDING - 1)) {
+				zoomRect.x = bounds.x - zoomRect.width - BORDER_PADDING - 1;
+			} else if (zoomRect.x < BORDER_PADDING) {
+				zoomRect.x = BORDER_PADDING;
+			}
+			xModified = xOld != zoomRect.x;
+
+			int yOld = zoomRect.y;
+			zoomRect.y += ydiff;
+			if (zoomRect.y < BORDER_PADDING) {
+				zoomRect.y = BORDER_PADDING;
+			} else if (zoomRect.y > (bounds.y - zoomRect.height - BORDER_PADDING - 1)) {
+				zoomRect.y = bounds.y - zoomRect.height - BORDER_PADDING - 1;
+			}
+			yModified = yOld != zoomRect.y;
+
+			if (xModified || yModified) {
+				updateChartFromZoomRect(xModified, yModified);
+				chartCanvas.redrawChart();
+			}
+		}
+
+		private void updateChartFromZoomRect(boolean updateXRange, boolean updateYRange) {
+			Rectangle zoomCanvasBounds = new Rectangle(0, 0, getParent().getSize().x, getParent().getSize().y);
+			Rectangle totalBounds = chartCanvas.getBounds();
+
+			if (updateXRange) {
+				double ratio = getVisibilityRatio(zoomRect.x - BORDER_PADDING, zoomCanvasBounds.x,
+						zoomCanvasBounds.width - BORDER_PADDING);
+				int start = getPixelLocation(ratio, totalBounds.width, 0);
+
+				ratio = getVisibilityRatio(zoomRect.x + zoomRect.width + BORDER_PADDING + 1, zoomCanvasBounds.width,
+						zoomCanvasBounds.width - BORDER_PADDING);
+				int end = getPixelLocation(ratio, totalBounds.width, totalBounds.width);
+
+				SubdividedQuantityRange xAxis = new SubdividedQuantityRange(chartRange.getStart(), chartRange.getEnd(),
+						totalBounds.width, 1);
+				chart.setVisibleRange(xAxis.getQuantityAtPixel(start), xAxis.getQuantityAtPixel(end));
+				lastChartZoomedRange = chart.getVisibleRange();
+			}
+			if (updateYRange) {
+				double ratio = getVisibilityRatio(zoomRect.y - BORDER_PADDING, 0,
+						zoomCanvasBounds.height - BORDER_PADDING);
+				int top = getPixelLocation(ratio, totalBounds.height, 0);
+
+				Point p = ((ScrolledComposite) chartCanvas.getParent()).getOrigin();
+				p.y = top;
+
+				if (textCanvas != null) {
+					textCanvas.syncScroll(p);
+				}
+				chartCanvas.syncScroll(p);
+			}
+		}
+
+		class Painter implements PaintListener {
+			@Override
+			public void paintControl(PaintEvent e) {
+
+				Rectangle backgroundRect = new Rectangle(0, 0, getParent().getSize().x, getParent().getSize().y);
+				GC gc = e.gc;
+
+				gc.setBackground(Palette.PF_BLACK_400.getSWTColor());
+				gc.fillRectangle(backgroundRect);
+				gc.setForeground(Palette.PF_BLACK_900.getSWTColor());
+				gc.drawRectangle(0, 0, backgroundRect.width - 1, backgroundRect.height - 1);
+
+				updateZoomRectFromChart();
+
+				gc.setBackground(Palette.PF_BLACK_100.getSWTColor());
+				gc.fillRectangle(zoomRect);
+				gc.setForeground(Palette.PF_BLACK_900.getSWTColor());
+				gc.drawRectangle(zoomRect);
+			}
+		}
+
+		private void updateZoomRectFromChart() {
+			Rectangle zoomCanvasBounds = new Rectangle(0, 0, getParent().getSize().x, getParent().getSize().y);
+			IRange<IQuantity> zoomedRange = chart.getVisibleRange();
+			IQuantity visibleWidth = chartRange.getExtent();
+			double visibleHeight = chartCanvas.getParent().getBounds().height;
+			Rectangle totalBounds = chartCanvas.getBounds();
+
+			if (zoomRect == null) {
+				zoomRect = new Rectangle(0, 0, 0, 0);
+			}
+			if (!chart.getVisibleRange().equals(lastChartZoomedRange)) {
+				double ratio = getVisibilityRatio(zoomedRange.getStart(), chartRange.getStart(), visibleWidth);
+				int start = getPixelLocation(ratio, zoomCanvasBounds.width, 0);
+
+				ratio = getVisibilityRatio(zoomedRange.getEnd(), chartRange.getEnd(), visibleWidth);
+				int end = getPixelLocation(ratio, zoomCanvasBounds.width, zoomCanvasBounds.width);
+
+				zoomRect.x = start + BORDER_PADDING;
+				zoomRect.width = end - start - 2 * BORDER_PADDING - 1;
+				lastChartZoomedRange = chart.getVisibleRange();
+			}
+			double ratio = getVisibilityRatio(0, totalBounds.y, totalBounds.height);
+			int top = getPixelLocation(ratio, zoomCanvasBounds.height, 0);
+
+			ratio = getVisibilityRatio(visibleHeight, totalBounds.height + totalBounds.y, totalBounds.height);
+			int bottom = getPixelLocation(ratio, zoomCanvasBounds.height, zoomCanvasBounds.height);
+
+			zoomRect.y = top + BORDER_PADDING;
+			zoomRect.height = bottom - top - 2 * BORDER_PADDING - 1;
+
+		}
+
+		private double getVisibilityRatio(double visibleBound, double borderBound, double totalLength) {
+			double diff = visibleBound - borderBound;
+			return diff / totalLength;
+		}
+
+		private double getVisibilityRatio(IQuantity visibleBound, IQuantity borderBound, IQuantity totalLength) {
+			IQuantity diff = visibleBound.subtract(borderBound);
+			return diff.ratioTo(totalLength);
+		}
+
+		private int getPixelLocation(double visiblityRatio, int totalLength, int offset) {
+			return offset + (int) (visiblityRatio * totalLength);
+		}
+	}
+}
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartCanvas.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartCanvas.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartCanvas.java
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartCanvas.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -75,13 +75,15 @@
 import org.openjdk.jmc.ui.common.util.Environment.OSType;
 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
 import org.openjdk.jmc.ui.misc.PatternFly.Palette;
 
 public class ChartCanvas extends Canvas {
-	private static final int DEFAULT_LANE_HEIGHT = 50;
-	private int laneHeight = DEFAULT_LANE_HEIGHT;
-	private int minLaneheight = 20;
+	private int laneHeight;
+	private int minLaneHeight = -1;
+	private int minReadableLaneHeight;
+	private int savedLaneHeight;
+	private int numItems = 0;
 	private int lastMouseX = -1;
 	private int lastMouseY = -1;
 	private List<Rectangle2D> highlightRects;
 	private Object hoveredItemData;
 
@@ -215,46 +217,38 @@
 		@Override
 		public void mouseHover(MouseEvent e) {
 		}
 	}
 
-	private int numItems = 0;
-
-	public void setNumItems(int numItems) {
-		this.numItems = numItems;
-	}
-
-	private int getNumItems() {
-		return numItems;
-	}
-
 	class Painter implements PaintListener {
 
 		@Override
 		public void paintControl(PaintEvent e) {
 			Rectangle rect = new Rectangle(0, 0, getParent().getSize().x, getParent().getSize().y);
+			if (minLaneHeight == -1) {
+				minLaneHeight = calculateMinLaneHeight(rect);
+				laneHeight = minLaneHeight;
+			}
 			if (getNumItems() == 0) {
 				rect = getClientArea();
 			} else if (getNumItems() == 1 || (laneHeight * getNumItems() < rect.height)) {
 				// it fills the height
 			} else {
 				rect.height = laneHeight * getNumItems();
 			}
 
 			if (awtNeedsRedraw || !awtCanvas.hasImage(rect.width, rect.height)) {
 				Graphics2D g2d = awtCanvas.getGraphics(rect.width, rect.height);
-				minLaneheight = Math.max(20, (int) (g2d.getFontMetrics().getHeight() * xScale + 3));
 				Point adjusted = translateDisplayToImageCoordinates(rect.width, rect.height);
 				g2d.setColor(Palette.PF_BLACK_100.getAWTColor());
 				g2d.fillRect(0, 0, adjusted.x, adjusted.y);
 				render(g2d, adjusted.x, adjusted.y);
-				if (getParent() instanceof ScrolledComposite) {
+				if (isScrollableChart()) {
+					minReadableLaneHeight = (int) (g2d.getFontMetrics().getHeight() * xScale);
+					minLaneHeight = initMinLaneHeight();
 					((ScrolledComposite) getParent()).setMinSize(rect.width, rect.height);
 				}
-				if (highlightRects != null) {
-					updateHighlightRects();
-				}
 				awtNeedsRedraw = false;
 			}
 			awtCanvas.paint(e, 0, 0);
 			// Crude, flickering highlight of areas also delivered to tooltips.
 			// FIXME: Remove flicker by drawing in a buffered stage (AWT or SWT).
@@ -273,20 +267,75 @@
 						int width = (int) Math.round(r.getWidth() * xScale);
 						int height = (int) Math.round(r.getHeight() * yScale);
 						gc.drawRectangle(x, y, width, height);
 					}
 				}
+				updateHighlightRects();
 			}
 		}
 	}
 
-	public void adjustLaneHeight(int amount) {
-		laneHeight = Math.min(Math.max(minLaneheight, laneHeight + amount), DEFAULT_LANE_HEIGHT);
+	public void setNumItems(int numItems) {
+		this.numItems = numItems;
+	}
+
+	private int getNumItems() {
+		return numItems;
+	}
+
+	private boolean isScrollableChart() {
+		return getParent() instanceof ScrolledComposite;
+	}
+
+	protected int initMinLaneHeight() {
+		// if the min readable lane height * the number of items exceeds the screen, then use min readable height
+		if (minReadableLaneHeight * getNumItems() > getParent().getSize().y) {
+			return minReadableLaneHeight;
+		} else { // if the minimum readable lane height * the number of items leaves extra space, then the min height is the height / number of items
+			return getParent().getSize().y / getNumItems();
+		}
+	}
+
+	protected int calculateMinLaneHeight(Rectangle rect) {
+		return (int) (awtCanvas.getGraphics(rect.width, rect.height).getFontMetrics().getHeight() * xScale);
+	}
+
+	public boolean isLaneHeightMinimumSize() {
+		return laneHeight == minLaneHeight;
+	}
+
+	void setOverviewLaneHeight() {
+		this.savedLaneHeight = laneHeight;
+		setLaneHeight(-1);
+		zoomer = new Zoomer();
+		addListener(SWT.MouseVerticalWheel, zoomer);
+	}
+
+	void adjustLaneHeight(int amount) {
+		if (laneHeight == -1) {
+			restoreLaneHeight();
+		}
+		laneHeight = Math.max(minLaneHeight, laneHeight + amount);
+	}
+
+	void setLaneHeight(int height) {
+		this.laneHeight = height;
+	}
+
+	void restoreLaneHeight() {
+		laneHeight = savedLaneHeight;
+		removeListener(SWT.MouseVerticalWheel, zoomer);
 	}
 
 	public void resetLaneHeight() {
-		laneHeight = DEFAULT_LANE_HEIGHT;
+		if (minLaneHeight != -1) {
+			if (laneHeight == -1) {
+				removeListener(SWT.MouseVerticalWheel, zoomer);
+			}
+			minLaneHeight = initMinLaneHeight();
+			laneHeight = minLaneHeight;
+		}
 	}
 
 	class Zoomer implements Listener {
 
 		@Override
@@ -428,10 +477,11 @@
 	private Consumer<Boolean> zoomOnClickListener;
 	private IPropertyChangeListener aaListener;
 	private XYChart awtChart;
 	private MCContextMenuManager chartMenu;
 	private ChartTextCanvas textCanvas;
+	private Listener zoomer;
 
 	public ChartCanvas(Composite parent) {
 		super(parent, SWT.NO_BACKGROUND);
 		addPaintListener(new Painter());
 		Selector selector = new Selector();
@@ -443,11 +493,11 @@
 		UIPlugin.getDefault().getPreferenceStore().addPropertyChangeListener(aaListener);
 		addDisposeListener(e -> UIPlugin.getDefault().getPreferenceStore().removePropertyChangeListener(aaListener));
 		if (Environment.getOSType() == OSType.WINDOWS) {
 			addMouseTrackListener(new WheelStealingZoomer());
 		}
-		if (getParent() instanceof ScrolledComposite) { // JFR Threads Page
+		if (isScrollableChart()) { // JFR Threads Page
 			((ScrolledComposite) getParent()).getVerticalBar().addListener(SWT.Selection, e -> vBarScroll());
 		} else {
 			addMouseTrackListener(selector);
 			addListener(SWT.MouseVerticalWheel, new Zoomer());
 		}
@@ -719,11 +769,17 @@
 	/**
 	 * Mark both the (AWT) chart and the SWT control as needing a redraw.
 	 */
 	public void redrawChart() {
 		awtNeedsRedraw = true;
-		redraw();
+		getDisplay().asyncExec(new Runnable() {
+			public void run() {
+				if (!isDisposed()) {
+					redraw();
+				}
+			}
+		});
 	}
 
 	private void redrawChartText() {
 		if (textCanvas != null) {
 			textCanvas.redrawChartText();
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartControlBar.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartControlBar.java
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartControlBar.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.ui.misc;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Listener;
+
+import org.openjdk.jmc.common.unit.IQuantity;
+import org.openjdk.jmc.common.unit.IRange;
+import org.openjdk.jmc.ui.charts.XYChart;
+
+public class ChartControlBar extends Composite {
+
+	private ChartButtonGroup buttonGroup;
+	private ChartLaneHeightControls laneHeightControls;
+	private Composite laneFilterContainer;
+	private TimeFilter timeFilter;
+
+	public ChartControlBar(Composite parent, Listener resetListener, IRange<IQuantity> recordingRange) {
+		super(parent, SWT.NONE);
+		this.setLayout(new GridLayout(4, false));
+
+		timeFilter = new TimeFilter(this, recordingRange, resetListener);
+		timeFilter.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, false, false));
+
+		laneFilterContainer = new Composite(this, SWT.NONE);
+		laneFilterContainer.setLayout(new GridLayout());
+
+		Composite buttonGroupContainer = new Composite(this, SWT.NONE);
+		buttonGroupContainer.setLayout(new GridLayout(3, false));
+		buttonGroupContainer.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, true, false));
+		buttonGroup = new ChartButtonGroup(buttonGroupContainer);
+		laneHeightControls = new ChartLaneHeightControls(buttonGroupContainer);
+		buttonGroup.setResetLaneHeightAction(() -> resetLaneHeightToMinimum());
+	}
+
+	public Composite getLaneFilterContainer() {
+		return laneFilterContainer;
+	}
+
+	public ChartButtonGroup getButtonGroup() {
+		return buttonGroup;
+	}
+
+	public void resetLaneHeightToMinimum() {
+		laneHeightControls.resetLaneHeightToMinimum();
+	}
+
+	public void setChart(XYChart chart) {
+		buttonGroup.setChart(chart);
+		timeFilter.setChart(chart);
+	}
+
+	public void setChartCanvas(ChartCanvas canvas) {
+		buttonGroup.setChartCanvas(canvas);
+		laneHeightControls.setChartCanvas(canvas);
+		timeFilter.setChartCanvas(canvas);
+	}
+
+	public void setTextCanvas(ChartTextCanvas textCanvas) {
+		buttonGroup.setTextCanvas(textCanvas);
+		laneHeightControls.setTextCanvas(textCanvas);
+	}
+
+	public void setStartTime(IQuantity startTime) {
+		timeFilter.setStartTime(startTime);
+	}
+
+	public void setEndTime(IQuantity endTime) {
+		timeFilter.setEndTime(endTime);
+	}
+}
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartDisplayControlBar.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartDisplayControlBar.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartDisplayControlBar.java
+++ /dev/null
@@ -1,571 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2019, Red Hat Inc. All rights reserved.
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * The contents of this file are subject to the terms of either the Universal Permissive License
- * v 1.0 as shown at http://oss.oracle.com/licenses/upl
- *
- * or the following license:
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted
- * provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
- * and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
- * conditions and the following disclaimer in the documentation and/or other materials provided with
- * the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
- * endorse or promote products derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
- * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.openjdk.jmc.ui.misc;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Timer;
-import java.util.TimerTask;
-
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.custom.ScrolledComposite;
-import org.eclipse.swt.events.MouseAdapter;
-import org.eclipse.swt.events.MouseEvent;
-import org.eclipse.swt.events.MouseMoveListener;
-import org.eclipse.swt.events.MouseWheelListener;
-import org.eclipse.swt.events.PaintEvent;
-import org.eclipse.swt.events.PaintListener;
-import org.eclipse.swt.graphics.Cursor;
-import org.eclipse.swt.graphics.GC;
-import org.eclipse.swt.graphics.Point;
-import org.eclipse.swt.graphics.Rectangle;
-import org.eclipse.swt.layout.GridData;
-import org.eclipse.swt.layout.GridLayout;
-import org.eclipse.swt.widgets.Button;
-import org.eclipse.swt.widgets.Canvas;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Event;
-import org.eclipse.swt.widgets.Listener;
-import org.eclipse.swt.widgets.Scale;
-import org.eclipse.swt.widgets.Text;
-import org.openjdk.jmc.common.unit.IQuantity;
-import org.openjdk.jmc.common.unit.IRange;
-import org.openjdk.jmc.ui.UIPlugin;
-import org.openjdk.jmc.ui.charts.SubdividedQuantityRange;
-import org.openjdk.jmc.ui.charts.XYChart;
-import org.openjdk.jmc.ui.misc.PatternFly.Palette;
-
-public class ChartDisplayControlBar extends Composite {
-	private static final String ZOOM_IN_CURSOR = "zoomInCursor";
-	private static final String ZOOM_OUT_CURSOR = "zoomOutCursor";
-	private static final String DEFAULT_CURSOR = "defaultCursor";
-	private static final String HAND_CURSOR = "handCursor";
-	private static final int ZOOM_INCREMENT = 1;
-	private Map<String, Cursor> cursors;
-	private Scale scale;
-	private Text zoomText;
-	private XYChart chart;
-	private ChartCanvas chartCanvas;
-	private ChartTextCanvas textCanvas;
-	private List<Button> buttonGroup;
-	private Button zoomInBtn;
-	private Button zoomOutBtn;
-	private Button selectionBtn;
-	private Button zoomPanBtn;
-	private Button scaleToFitBtn;
-
-	private ZoomPan zoomPan;
-
-	public ChartDisplayControlBar(Composite parent) {
-		super(parent, SWT.NONE);
-
-		this.setLayout(new GridLayout());
-		this.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, true));
-		this.setBackground(Palette.getThreadsPageBackgroundColor());
-
-		cursors = new HashMap<>();
-		cursors.put(DEFAULT_CURSOR, getDisplay().getSystemCursor(SWT.CURSOR_ARROW));
-		cursors.put(HAND_CURSOR, getDisplay().getSystemCursor(SWT.CURSOR_HAND));
-		cursors.put(ZOOM_IN_CURSOR, new Cursor(getDisplay(),
-				UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_IN).getImageData(), 0, 0));
-		cursors.put(ZOOM_OUT_CURSOR, new Cursor(getDisplay(),
-				UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_OUT).getImageData(), 0, 0));
-
-		buttonGroup = new ArrayList<>();
-		selectionBtn = new Button(this, SWT.TOGGLE);
-		selectionBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
-		selectionBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_SELECTION));
-		selectionBtn.setSelection(true);
-		selectionBtn.setToolTipText(Messages.ChartDisplayControlBar_SELECTION_TOOL_TOOLTIP);
-		selectionBtn.addListener(SWT.Selection, new Listener() {
-			@Override
-			public void handleEvent(Event event) {
-				setButtonSelectionStates(selectionBtn, null);
-				changeCursor(DEFAULT_CURSOR);
-			};
-		});
-		buttonGroup.add(selectionBtn);
-
-		zoomInBtn = new Button(this, SWT.TOGGLE);
-		zoomInBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
-		zoomInBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_IN));
-		zoomInBtn.setSelection(false);
-		StringBuilder sb = new StringBuilder();
-		sb.append(Messages.ChartDisplayControlBar_ZOOM_IN_CLICK_TOOLTIP);
-		sb.append(System.getProperty("line.separator"));
-		sb.append(Messages.ChartDisplayControlBar_ZOOM_IN_HOLD_TOOLTIP);
-		zoomInBtn.setToolTipText(sb.toString());
-		zoomInBtn.addListener(SWT.Selection, new Listener() {
-			@Override
-			public void handleEvent(Event event) {
-				if (scale.getSelection() > 0) {
-					setButtonSelectionStates(zoomInBtn, zoomPanBtn);
-					changeCursor(ZOOM_IN_CURSOR);
-				} else {
-					setButtonSelectionStates(selectionBtn, null);
-					changeCursor(DEFAULT_CURSOR);
-				}
-			}
-		});
-		zoomInBtn.addMouseListener(new LongPressListener(ZOOM_INCREMENT));
-		buttonGroup.add(zoomInBtn);
-
-		scale = new Scale(this, SWT.VERTICAL);
-		scale.setMinimum(0);
-		scale.setMaximum(30);
-		scale.setIncrement(1);
-		scale.setSelection(30);
-		scale.setLayoutData(new GridData(SWT.CENTER, SWT.FILL, true, true));
-		scale.addListener(SWT.Selection, new Listener() {
-			@Override
-			public void handleEvent(Event event) {
-				chart.zoomToStep(scale.getMaximum() - scale.getSelection());
-				chartCanvas.redrawChart();
-			}
-		});
-
-		zoomText = new Text(this, SWT.BORDER | SWT.READ_ONLY | SWT.SINGLE);
-		zoomText.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
-		setZoomPercentageText(100);
-
-		zoomOutBtn = new Button(this, SWT.TOGGLE);
-		zoomOutBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
-		zoomOutBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_OUT));
-		zoomOutBtn.setSelection(false);
-		sb = new StringBuilder();
-		sb.append(Messages.ChartDisplayControlBar_ZOOM_OUT_CLICK_TOOLTIP);
-		sb.append(System.getProperty("line.separator"));
-		sb.append(Messages.ChartDisplayControlBar_ZOOM_OUT_HOLD_TOOLTIP);
-		zoomOutBtn.setToolTipText(sb.toString());
-		zoomOutBtn.addListener(SWT.Selection, new Listener() {
-			@Override
-			public void handleEvent(Event e) {
-				if (scale.getSelection() < scale.getMaximum()) {
-					setButtonSelectionStates(zoomOutBtn, zoomPanBtn);
-					changeCursor(ZOOM_OUT_CURSOR);
-				} else {
-					setButtonSelectionStates(selectionBtn, null);
-					changeCursor(DEFAULT_CURSOR);
-				}
-			}
-		});
-		zoomOutBtn.addMouseListener(new LongPressListener(-ZOOM_INCREMENT));
-		buttonGroup.add(zoomOutBtn);
-
-		zoomPanBtn = new Button(this, SWT.TOGGLE);
-		zoomPanBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
-		zoomPanBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_PAN));
-		zoomPanBtn.setSelection(false);
-		zoomPanBtn.setToolTipText(Messages.ChartDisplayControlBar_ZOOM_PAN_TOOLTIP);
-		zoomPanBtn.addListener(SWT.Selection, new Listener() {
-			@Override
-			public void handleEvent(Event event) {
-				showZoomPanDisplay(zoomPanBtn.getSelection());
-			}
-		});
-		buttonGroup.add(zoomPanBtn);
-
-		scaleToFitBtn = new Button(this, SWT.PUSH);
-		scaleToFitBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
-		scaleToFitBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_SCALE_TO_FIT));
-		scaleToFitBtn.setSelection(false);
-		scaleToFitBtn.setToolTipText(Messages.ChartDisplayControlBar_SCALE_TO_FIT_TOOLTIP);
-		scaleToFitBtn.addListener(SWT.Selection, new Listener() {
-			@Override
-			public void handleEvent(Event event) {
-				resetZoomScale();
-				chart.resetTimeline();
-				chartCanvas.redrawChart();
-			}
-		});
-		buttonGroup.add(scaleToFitBtn);
-	}
-
-	public void setChart(XYChart chart) {
-		this.chart = chart;
-	}
-
-	public void setChartCanvas(ChartCanvas chartCanvas) {
-		this.chartCanvas = chartCanvas;
-	}
-
-	public void setTextCanvas(ChartTextCanvas textCanvas) {
-		this.textCanvas = textCanvas;
-	}
-
-	public void updateZoomPanIndicator() {
-		zoomPan.redraw();
-	}
-
-	public void zoomOnClick(Boolean mouseDown) {
-		boolean shouldZoom = zoomInBtn.getSelection() || zoomOutBtn.getSelection();
-		if (shouldZoom) {
-			if (mouseDown) {
-				chart.clearSelection();
-			} else {
-				int zoomAmount = zoomInBtn.getSelection() ? ZOOM_INCREMENT : -ZOOM_INCREMENT;
-				zoom(zoomAmount);
-				if (textCanvas != null) {
-					textCanvas.redrawChartText();
-				}
-			}
-		}
-	}
-
-	public void zoomToSelection() {
-		if (zoomInBtn.getSelection() && scale.getSelection() > 0) {
-			IQuantity selectionStart = chart.getSelectionStart();
-			IQuantity selectionEnd = chart.getSelectionEnd();
-			if (selectionStart == null || selectionEnd == null) {
-				chart.clearVisibleRange();
-			} else {
-				chart.setVisibleRange(selectionStart, selectionEnd);
-				chartCanvas.redrawChart();
-			}
-		}
-	}
-
-	public void setZoomPercentageText(double zoom) {
-		zoomText.setText(String.format("%.2f %s", zoom, "%"));
-	}
-
-	public void setScaleValue(int value) {
-		scale.setSelection(scale.getMaximum() - value);
-	}
-
-	public void increaseScaleValue() {
-		scale.setSelection(scale.getSelection() - 1);
-	}
-
-	public void decreaseScaleValue() {
-		scale.setSelection(scale.getSelection() + 1);
-	}
-
-	public void resetZoomScale() {
-		scale.setSelection(scale.getMaximum());
-		setZoomPercentageText(100);
-		resetLaneHeight();
-	}
-
-	private void resetLaneHeight() {
-		chartCanvas.resetLaneHeight();
-		if (textCanvas != null) {
-			textCanvas.resetLaneHeight();
-		}
-	}
-
-	private void changeCursor(String cursorName) {
-		chartCanvas.changeCursor(cursors.get(cursorName));
-	}
-
-	private void setButtonSelectionStates(Button buttonSelected, Button dependentButton) {
-		for (Button button : buttonGroup) {
-			if ((button.getStyle() & SWT.TOGGLE) != 0) {
-				if (button.equals(buttonSelected)) {
-					button.setSelection(true);
-				} else if (dependentButton != null) {
-					if (button.equals(dependentButton)) {
-						button.setSelection(true);
-					} else {
-						button.setSelection(false);
-					}
-				} else {
-					button.setSelection(false);
-				}
-			}
-			showZoomPanDisplay(zoomPanBtn.getSelection());
-		}
-	}
-
-	private class LongPressListener extends MouseAdapter {
-
-		private static final long LONG_PRESS_TIME = 500;
-		private Timer timer;
-		private int zoomAmount;
-
-		LongPressListener(int zoomAmount) {
-			this.zoomAmount = zoomAmount;
-		}
-
-		@Override
-		public void mouseDown(MouseEvent e) {
-			if (e.button == 1) {
-				timer = new Timer();
-				timer.schedule(new LongPress(), LONG_PRESS_TIME, (long) (LONG_PRESS_TIME * 1.5));
-			}
-		}
-
-		@Override
-		public void mouseUp(MouseEvent e) {
-			timer.cancel();
-		}
-
-		public class LongPress extends TimerTask {
-
-			@Override
-			public void run() {
-				doZoomInOut(zoomAmount);
-			}
-		}
-
-		private void doZoomInOut(int zoomAmount) {
-			DisplayToolkit.inDisplayThread().execute(() -> zoom(zoomAmount));
-		}
-	}
-
-	private void zoom(int zoomAmount) {
-		int newScaleValue = scale.getSelection() - zoomAmount;
-		if (newScaleValue >= scale.getMinimum() && newScaleValue <= scale.getMaximum()) {
-			scale.setSelection(scale.getSelection() - zoomAmount);
-			chart.zoom(zoomAmount);
-			chartCanvas.redrawChart();
-		}
-	}
-
-	public void createZoomPan(Composite parent) {
-		zoomPan = new ZoomPan(parent);
-		parent.setVisible(false);
-	}
-
-	private void showZoomPanDisplay(boolean show) {
-		if (show) {
-			zoomPan.getParent().setVisible(true);
-			zoomPan.redrawZoomPan();
-		} else {
-			zoomPan.getParent().setVisible(false);
-		}
-	}
-
-	private class ZoomPan extends Canvas {
-		private static final int BORDER_PADDING = 2;
-		private static final double MIN_HEIGHT_PERCENT = 0.15;
-		private static final double MIN_WIDTH_PERCENT = 0.08;
-		private IRange<IQuantity> chartRange;
-		private IRange<IQuantity> lastChartZoomedRange;
-		private Rectangle zoomRect;
-
-		public ZoomPan(Composite parent) {
-			super(parent, SWT.NO_BACKGROUND);
-			addPaintListener(new Painter());
-			PanDetector panDetector = new PanDetector();
-			addMouseListener(panDetector);
-			addMouseMoveListener(panDetector);
-			addMouseWheelListener(panDetector);
-			chartRange = chart.getVisibleRange();
-		}
-
-		public void redrawZoomPan() {
-			redraw();
-		}
-
-		private class PanDetector extends MouseAdapter implements MouseMoveListener, MouseWheelListener {
-			Point currentSelection;
-			Point lastSelection;
-			boolean isPan = false;
-
-			@Override
-			public void mouseDown(MouseEvent e) {
-				if (e.button == 1 && inBounds(e)) {
-					isPan = true;
-					chart.setIsZoomPanDrag(isPan);
-					currentSelection = chartCanvas.translateDisplayToImageCoordinates(e.x, e.y);
-				}
-			}
-
-			private boolean inBounds(MouseEvent e) {
-				Point zoomCanvasBounds = getParent().getSize();
-				if (zoomRect.height < MIN_HEIGHT_PERCENT * zoomCanvasBounds.y
-						|| zoomRect.width < MIN_WIDTH_PERCENT * zoomCanvasBounds.x) {
-					return zoomCanvasBounds.x >= e.x && zoomCanvasBounds.y >= e.y;
-				} else {
-					return zoomRect.contains(e.x, e.y);
-				}
-			}
-
-			@Override
-			public void mouseUp(MouseEvent e) {
-				isPan = false;
-				chart.setIsZoomPanDrag(isPan);
-			}
-
-			@Override
-			public void mouseMove(MouseEvent e) {
-				zoomPan.setCursor(cursors.get(HAND_CURSOR));
-				if (isPan && getParent().getSize().x >= e.x && getParent().getSize().y >= e.y) {
-					lastSelection = currentSelection;
-					currentSelection = chartCanvas.translateDisplayToImageCoordinates(e.x, e.y);
-					int xdiff = currentSelection.x - lastSelection.x;
-					int ydiff = currentSelection.y - lastSelection.y;
-					updateZoomRectFromPan(xdiff, ydiff);
-				}
-			}
-
-			@Override
-			public void mouseScrolled(MouseEvent e) {
-				updateZoomRectFromPan(0, -e.count);
-			}
-		}
-
-		private void updateZoomRectFromPan(int xdiff, int ydiff) {
-			Point bounds = getParent().getSize();
-			boolean xModified = false;
-			boolean yModified = false;
-
-			int xOld = zoomRect.x;
-			zoomRect.x += xdiff;
-			if (zoomRect.x > (bounds.x - zoomRect.width - BORDER_PADDING - 1)) {
-				zoomRect.x = bounds.x - zoomRect.width - BORDER_PADDING - 1;
-			} else if (zoomRect.x < BORDER_PADDING) {
-				zoomRect.x = BORDER_PADDING;
-			}
-			xModified = xOld != zoomRect.x;
-
-			int yOld = zoomRect.y;
-			zoomRect.y += ydiff;
-			if (zoomRect.y < BORDER_PADDING) {
-				zoomRect.y = BORDER_PADDING;
-			} else if (zoomRect.y > (bounds.y - zoomRect.height - BORDER_PADDING - 1)) {
-				zoomRect.y = bounds.y - zoomRect.height - BORDER_PADDING - 1;
-			}
-			yModified = yOld != zoomRect.y;
-
-			if (xModified || yModified) {
-				updateChartFromZoomRect(xModified, yModified);
-				chartCanvas.redrawChart();
-			}
-		}
-
-		private void updateChartFromZoomRect(boolean updateXRange, boolean updateYRange) {
-			Rectangle zoomCanvasBounds = new Rectangle(0, 0, getParent().getSize().x, getParent().getSize().y);
-			Rectangle totalBounds = chartCanvas.getBounds();
-
-			if (updateXRange) {
-				double ratio = getVisibilityRatio(zoomRect.x - BORDER_PADDING, zoomCanvasBounds.x,
-						zoomCanvasBounds.width - BORDER_PADDING);
-				int start = getPixelLocation(ratio, totalBounds.width, 0);
-
-				ratio = getVisibilityRatio(zoomRect.x + zoomRect.width + BORDER_PADDING + 1, zoomCanvasBounds.width,
-						zoomCanvasBounds.width - BORDER_PADDING);
-				int end = getPixelLocation(ratio, totalBounds.width, totalBounds.width);
-
-				SubdividedQuantityRange xAxis = new SubdividedQuantityRange(chartRange.getStart(), chartRange.getEnd(),
-						totalBounds.width, 1);
-				chart.setVisibleRange(xAxis.getQuantityAtPixel(start), xAxis.getQuantityAtPixel(end));
-				lastChartZoomedRange = chart.getVisibleRange();
-			}
-			if (updateYRange) {
-				double ratio = getVisibilityRatio(zoomRect.y - BORDER_PADDING, 0,
-						zoomCanvasBounds.height - BORDER_PADDING);
-				int top = getPixelLocation(ratio, totalBounds.height, 0);
-
-				Point p = ((ScrolledComposite) chartCanvas.getParent()).getOrigin();
-				p.y = top;
-
-				if (textCanvas != null) {
-					textCanvas.syncScroll(p);
-				}
-				chartCanvas.syncScroll(p);
-			}
-		}
-
-		class Painter implements PaintListener {
-			@Override
-			public void paintControl(PaintEvent e) {
-
-				Rectangle backgroundRect = new Rectangle(0, 0, getParent().getSize().x, getParent().getSize().y);
-				GC gc = e.gc;
-
-				gc.setBackground(Palette.PF_BLACK_400.getSWTColor());
-				gc.fillRectangle(backgroundRect);
-				gc.setForeground(Palette.PF_BLACK_900.getSWTColor());
-				gc.drawRectangle(0, 0, backgroundRect.width - 1, backgroundRect.height - 1);
-
-				updateZoomRectFromChart();
-
-				gc.setBackground(Palette.PF_BLACK_100.getSWTColor());
-				gc.fillRectangle(zoomRect);
-				gc.setForeground(Palette.PF_BLACK_900.getSWTColor());
-				gc.drawRectangle(zoomRect);
-			}
-		}
-
-		private void updateZoomRectFromChart() {
-			Rectangle zoomCanvasBounds = new Rectangle(0, 0, getParent().getSize().x, getParent().getSize().y);
-			IRange<IQuantity> zoomedRange = chart.getVisibleRange();
-			IQuantity visibleWidth = chartRange.getExtent();
-			double visibleHeight = chartCanvas.getParent().getBounds().height;
-			Rectangle totalBounds = chartCanvas.getBounds();
-
-			if (zoomRect == null) {
-				zoomRect = new Rectangle(0, 0, 0, 0);
-			}
-			if (!chart.getVisibleRange().equals(lastChartZoomedRange)) {
-				double ratio = getVisibilityRatio(zoomedRange.getStart(), chartRange.getStart(), visibleWidth);
-				int start = getPixelLocation(ratio, zoomCanvasBounds.width, 0);
-
-				ratio = getVisibilityRatio(zoomedRange.getEnd(), chartRange.getEnd(), visibleWidth);
-				int end = getPixelLocation(ratio, zoomCanvasBounds.width, zoomCanvasBounds.width);
-
-				zoomRect.x = start + BORDER_PADDING;
-				zoomRect.width = end - start - 2 * BORDER_PADDING - 1;
-				lastChartZoomedRange = chart.getVisibleRange();
-			}
-			double ratio = getVisibilityRatio(0, totalBounds.y, totalBounds.height);
-			int top = getPixelLocation(ratio, zoomCanvasBounds.height, 0);
-
-			ratio = getVisibilityRatio(visibleHeight, totalBounds.height + totalBounds.y, totalBounds.height);
-			int bottom = getPixelLocation(ratio, zoomCanvasBounds.height, zoomCanvasBounds.height);
-
-			zoomRect.y = top + BORDER_PADDING;
-			zoomRect.height = bottom - top - 2 * BORDER_PADDING - 1;
-
-		}
-
-		private double getVisibilityRatio(double visibleBound, double borderBound, double totalLength) {
-			double diff = visibleBound - borderBound;
-			return diff / totalLength;
-		}
-
-		private double getVisibilityRatio(IQuantity visibleBound, IQuantity borderBound, IQuantity totalLength) {
-			IQuantity diff = visibleBound.subtract(borderBound);
-			return diff.ratioTo(totalLength);
-		}
-
-		private int getPixelLocation(double visiblityRatio, int totalLength, int offset) {
-			return offset + (int) (visiblityRatio * totalLength);
-		}
-	}
-}
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartLaneHeightControls.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartLaneHeightControls.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartLaneHeightControls.java
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartLaneHeightControls.java
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
  *
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -39,44 +39,81 @@
 import org.eclipse.swt.widgets.Button;
 import org.eclipse.swt.widgets.Composite;
 import org.eclipse.swt.widgets.Event;
 import org.eclipse.swt.widgets.Listener;
 import org.openjdk.jmc.ui.UIPlugin;
-import org.openjdk.jmc.ui.misc.PatternFly.Palette;
 
 public class ChartLaneHeightControls extends Composite {
-	private Button incHeightBtn;
 	private Button decHeightBtn;
+	private Button incHeightBtn;
+	private Button overviewBtn;
 	private ChartCanvas chartCanvas;
 	private ChartTextCanvas textCanvas;
+	private static final int ADJUST_AMOUNT = 3;
 
-	public ChartLaneHeightControls(Composite parent, ChartCanvas chartCanvas, ChartTextCanvas textCanvas) {
+	public ChartLaneHeightControls(Composite parent) {
 		super(parent, SWT.NONE);
-		this.setLayout(new GridLayout(2, true));
-		this.chartCanvas = chartCanvas;
-		this.textCanvas = textCanvas;
-		this.setBackground(Palette.PF_BLACK_100.getSWTColor());
+		GridLayout gl = new GridLayout(3, true);
+		gl.horizontalSpacing = 0;
+		gl.marginWidth = 0;
+		this.setLayout(gl);
 
+		initDecreaseHeightButton();
+		initIncreaseHeightButton();
+		initOverviewButton();
+	}
+
+	private void initDecreaseHeightButton() {
 		decHeightBtn = new Button(this, SWT.PUSH);
 		decHeightBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
 		decHeightBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_MINUS));
 		decHeightBtn.setToolTipText(Messages.ChartLaneHeightControls_LANE_HEIGHT_DECREASE_TOOLTIP);
 		decHeightBtn.addListener(SWT.Selection, new Listener() {
 			@Override
 			public void handleEvent(Event event) {
-				adjustLaneHeight(-1);
+				adjustLaneHeight(-ADJUST_AMOUNT);
 			}
 		});
+		decHeightBtn.setEnabled(false);
+	}
 
+	private void initIncreaseHeightButton() {
 		incHeightBtn = new Button(this, SWT.PUSH);
 		incHeightBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
 		incHeightBtn.setToolTipText(Messages.ChartLaneHeightControls_LANE_HEIGHT_INCREASE_TOOLTIP);
 		incHeightBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_PLUS));
 		incHeightBtn.addListener(SWT.Selection, new Listener() {
 			@Override
 			public void handleEvent(Event event) {
-				adjustLaneHeight(1);
+				adjustLaneHeight(ADJUST_AMOUNT);
+			}
+		});
+	}
+
+	private void initOverviewButton() {
+		overviewBtn = new Button(this, SWT.TOGGLE);
+		overviewBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		overviewBtn.setToolTipText(Messages.ChartLaneHeightControls_OVERVIEW_BUTTON_TOOLTIP);
+		overviewBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_ADRESS));
+		overviewBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				if (!overviewBtn.getSelection()) {
+					chartCanvas.restoreLaneHeight();
+					chartCanvas.redrawChart();
+					if (textCanvas != null) {
+						textCanvas.restoreLaneHeight();
+						textCanvas.redrawChartText();
+					}
+				} else {
+					chartCanvas.setOverviewLaneHeight();
+					chartCanvas.redrawChart();
+					if (textCanvas != null) {
+						textCanvas.setOverviewLaneHeight();
+						textCanvas.redrawChartText();
+					}
+				}
 			}
 		});
 	}
 
 	private void adjustLaneHeight(int amount) {
@@ -84,8 +121,33 @@
 		chartCanvas.redrawChart();
 		if (textCanvas != null) {
 			textCanvas.adjustLaneHeight(amount);
 			textCanvas.redrawChartText();
 		}
+		if (chartCanvas.isLaneHeightMinimumSize()) {
+			decHeightBtn.setEnabled(false);
+		} else {
+			decHeightBtn.setEnabled(true);
+		}
+		if (overviewBtn.getSelection()) {
+			overviewBtn.setSelection(false);
+		}
+	}
+
+	void resetLaneHeightToMinimum() {
+		chartCanvas.resetLaneHeight();
+		if (textCanvas != null) {
+			textCanvas.resetLaneHeight();
+		}
+		decHeightBtn.setEnabled(false);
+		overviewBtn.setSelection(false);
+	}
+
+	void setChartCanvas(ChartCanvas chartCanvas) {
+		this.chartCanvas = chartCanvas;
+	}
+
+	void setTextCanvas(ChartTextCanvas textCanvas) {
+		this.textCanvas = textCanvas;
 	}
 
 }
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartTextCanvas.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartTextCanvas.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartTextCanvas.java
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartTextCanvas.java
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
  *
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -65,14 +65,14 @@
 import org.openjdk.jmc.ui.common.util.Environment;
 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
 import org.openjdk.jmc.ui.misc.PatternFly.Palette;
 
 public class ChartTextCanvas extends Canvas {
-	private static final int DEFAULT_LANE_HEIGHT = 50;
-	private int laneHeight = DEFAULT_LANE_HEIGHT;
-	private int minLaneheight = 20;
-	private int numItems;
+	private int laneHeight;
+	private int savedLaneHeight;
+	private int minLaneHeight = -1;
+	private int numItems = 0;
 	private int lastMouseX = -1;
 	private int lastMouseY = -1;
 	private List<Rectangle2D> highlightRects;
 
 	private class Selector extends MouseAdapter implements MouseMoveListener, MouseTrackListener {
@@ -203,32 +203,30 @@
 		@Override
 		public void mouseHover(MouseEvent e) {
 		}
 	}
 
-	public void setNumItems(int numItems) {
-		this.numItems = numItems;
-	}
-
-	private int getNumItems() {
-		return numItems;
-	}
-
 	class Painter implements PaintListener {
 
 		@Override
 		public void paintControl(PaintEvent e) {
 			int minScrollWidth = (int) ((awtChart.getLongestCharWidth() + 10) * xScale);
 			int rectWidth = Math.max(minScrollWidth, getParent().getSize().x);
 			Rectangle rect = new Rectangle(0, 0, rectWidth, getParent().getSize().y);
-			if (getNumItems() != 1 && !(laneHeight * getNumItems() < rect.height)) {
-				rect.height = laneHeight * getNumItems();
+			if (getNumItems() > 0) {
+				if (minLaneHeight == -1) {
+					minLaneHeight = chartCanvas.calculateMinLaneHeight(rect);
+					laneHeight = minLaneHeight;
+				}
+				if (getNumItems() != 1 && !(laneHeight * getNumItems() < rect.height)) {
+					rect.height = laneHeight * getNumItems();
+				}
 			}
 
 			if (awtNeedsRedraw || !awtCanvas.hasImage(rect.width, rect.height)) {
 				Graphics2D g2d = awtCanvas.getGraphics(rect.width, rect.height);
-				minLaneheight = Math.max(20, (int) (g2d.getFontMetrics().getHeight() * xScale + 3));
+				minLaneHeight = (int) (g2d.getFontMetrics().getHeight() * xScale);
 				Point adjusted = chartCanvas.translateDisplayToImageCoordinates(rect.width, rect.height);
 				g2d.setColor(Palette.PF_BLACK_100.getAWTColor());
 				g2d.fillRect(0, 0, adjusted.x, adjusted.y);
 				render(g2d, adjusted.x, adjusted.y);
 				((ScrolledComposite) getParent()).setMinSize(rect.width, rect.height);
@@ -239,16 +237,43 @@
 			}
 			awtCanvas.paint(e, 0, 0);
 		}
 	}
 
-	public void adjustLaneHeight(int amount) {
-		laneHeight = Math.min(Math.max(minLaneheight, laneHeight + amount), DEFAULT_LANE_HEIGHT);
+	public void setNumItems(int numItems) {
+		this.numItems = numItems;
 	}
 
-	public void resetLaneHeight() {
-		laneHeight = DEFAULT_LANE_HEIGHT;
+	private int getNumItems() {
+		return numItems;
+	}
+
+	void setOverviewLaneHeight() {
+		this.savedLaneHeight = laneHeight;
+		setLaneHeight(-1);
+	}
+
+	void adjustLaneHeight(int amount) {
+		if (laneHeight == -1) {
+			restoreLaneHeight();
+		}
+		laneHeight = Math.max(minLaneHeight, laneHeight + amount);
+	}
+
+	void setLaneHeight(int height) {
+		this.laneHeight = height;
+	}
+
+	void restoreLaneHeight() {
+		laneHeight = savedLaneHeight;
+	}
+
+	void resetLaneHeight() {
+		if (minLaneHeight != -1) {
+			minLaneHeight = chartCanvas.initMinLaneHeight();
+			laneHeight = minLaneHeight;
+		}
 	}
 
 	class KeyNavigator implements KeyListener {
 
 		@Override
@@ -346,11 +371,11 @@
 
 	public void setHoveredItemData(Object data) {
 		this.hoveredItemData = data;
 	}
 
-	public void resetHoveredItemData() {
+	void resetHoveredItemData() {
 		this.hoveredItemData = null;
 	}
 
 	public void syncHighlightedRectangles(List<Rectangle2D> newRects) {
 		highlightRects = newRects;
@@ -407,11 +432,10 @@
 	public void setChartCanvas(ChartCanvas chartCanvas) {
 		this.chartCanvas = chartCanvas;
 	}
 
 	public void syncScroll(Point scrollPoint) {
-		getParent().getVerticalBar().setVisible(false);
 		((ScrolledComposite) getParent()).setOrigin(scrollPoint);
 	}
 
 	public void replaceRenderer(IXDataRenderer rendererRoot) {
 		assert awtChart != null;
@@ -440,11 +464,17 @@
 	/**
 	 * Mark both the (AWT) chart and the SWT control as needing a redraw.
 	 */
 	public void redrawChartText() {
 		awtNeedsRedraw = true;
-		redraw();
+		getDisplay().asyncExec(new Runnable() {
+			public void run() {
+				if (!isDisposed()) {
+					redraw();
+				}
+			}
+		});
 	}
 
 	private void redrawChart() {
 		if (chartCanvas != null) {
 			chartCanvas.redrawChart();
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/Messages.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/Messages.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/Messages.java
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/Messages.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -45,10 +45,11 @@
 	public static String ChartDisplayControlBar_ZOOM_PAN_TOOLTIP;
 	public static String ChartDisplayControlBar_ZOOM_OUT_CLICK_TOOLTIP;
 	public static String ChartDisplayControlBar_ZOOM_OUT_HOLD_TOOLTIP;
 	public static String ChartLaneHeightControls_LANE_HEIGHT_DECREASE_TOOLTIP;
 	public static String ChartLaneHeightControls_LANE_HEIGHT_INCREASE_TOOLTIP;
+	public static String ChartLaneHeightControls_OVERVIEW_BUTTON_TOOLTIP;
 	public static String DIALOG_FILE_EXISTS_TITLE;
 	public static String DIALOG_OVERWRITE_QUESTION_TEXT;
 	public static String EXPORT_AS_IMAGE_ACTION_TEXT;
 	public static String ExceptionDialog_NO_DETAILS_AVAILABLE;
 	public static String FAILED_TO_SAVE_IMAGE;
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/PatternFly.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/PatternFly.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/PatternFly.java
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/PatternFly.java
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
  *
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/TimeFilter.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/TimeFilter.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/TimeFilter.java
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/TimeFilter.java
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
  *
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -73,29 +73,25 @@
 	private TimeDisplay startDisplay;
 	private TimeDisplay endDisplay;
 
 	public TimeFilter(Composite parent, IRange<IQuantity> recordingRange, Listener resetListener) {
 		super(parent, SWT.NONE);
-		this.setBackground(Palette.getThreadsPageBackgroundColor());
 		this.setLayout(new GridLayout(7, false));
 
 		inspectRecordingRange(recordingRange);
 
 		Label eventsLabel = new Label(this, SWT.LEFT);
 		eventsLabel.setText(Messages.TimeFilter_FILTER_EVENTS);
 		eventsLabel.setFont(JFaceResources.getFontRegistry().get(JFaceResources.BANNER_FONT));
-		eventsLabel.setBackground(Palette.getThreadsPageBackgroundColor());
 
 		Label fromLabel = new Label(this, SWT.CENTER);
 		fromLabel.setText(Messages.TimeFilter_FROM);
-		fromLabel.setBackground(Palette.getThreadsPageBackgroundColor());
 
 		startDisplay = new TimeDisplay(this, FilterType.START, recordingRange.getStart());
 
 		Label toLabel = new Label(this, SWT.CENTER);
 		toLabel.setText(Messages.TimeFilter_TO);
-		toLabel.setBackground(Palette.getThreadsPageBackgroundColor());
 
 		endDisplay = new TimeDisplay(this, FilterType.END, recordingRange.getEnd());
 
 		Button resetBtn = new Button(this, SWT.PUSH);
 		resetBtn.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, false, false));
@@ -156,11 +152,10 @@
 
 		public TimeDisplay(TimeFilter parent, FilterType type, IQuantity defaultTime) {
 			super(parent, SWT.NONE);
 			this.type = type;
 			this.defaultTime = defaultTime;
-			this.setBackground(Palette.getThreadsPageBackgroundColor());
 			this.setLayout(new GridLayout());
 			timeText = new Text(this, SWT.SEARCH | SWT.SINGLE);
 			// if the recording spans multiple days, include the date in the time display
 			if (!isMultiDayRecording) {
 				timeText.setTextLimit(12);
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/TimelineCanvas.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/TimelineCanvas.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/TimelineCanvas.java
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/TimelineCanvas.java
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
  *
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -85,13 +85,11 @@
 		rangeIndicatorHeight = (int) (BASE_RANGE_INDICATOR_HEIGHT * yScale);
 		rangeIndicatorYOffset = (int) (BASE_RANGE_INDICATOR_Y_OFFSET * yScale);
 	}
 
 	private int calculateXOffset() {
-		int offset = sashForm.getChildren()[0].getSize().x + sashForm.getSashWidth()
-				- getParent().getChildren()[0].getSize().x;
-		return Math.max(offset, 0);
+		return sashForm.getChildren()[0].getSize().x + sashForm.getSashWidth();
 	}
 
 	public void renderRangeIndicator(int x1, int x2) {
 		this.x1 = x1;
 		this.x2 = x2;
diff a/application/org.openjdk.jmc.ui/src/main/resources/org/openjdk/jmc/ui/misc/messages.properties b/application/org.openjdk.jmc.ui/src/main/resources/org/openjdk/jmc/ui/misc/messages.properties
--- a/application/org.openjdk.jmc.ui/src/main/resources/org/openjdk/jmc/ui/misc/messages.properties
+++ b/application/org.openjdk.jmc.ui/src/main/resources/org/openjdk/jmc/ui/misc/messages.properties
@@ -37,10 +37,11 @@
 ChartDisplayControlBar_ZOOM_PAN_TOOLTIP=Toggle Zoom-Pan Display
 ChartDisplayControlBar_ZOOM_OUT_CLICK_TOOLTIP=Click: Toggle Click-to-Zoom-Out mode
 ChartDisplayControlBar_ZOOM_OUT_HOLD_TOOLTIP=Hold: Continuous Zoom-Out
 ChartLaneHeightControls_LANE_HEIGHT_DECREASE_TOOLTIP=Decrease thread lane height
 ChartLaneHeightControls_LANE_HEIGHT_INCREASE_TOOLTIP=Increase thread lane height
+ChartLaneHeightControls_OVERVIEW_BUTTON_TOOLTIP=Toggle Overview Mode
 NumberFieldEditor_ERROR_MESSAGE_INTERVAL=Must be {0} between {1} and {2}
 NumberFieldEditor_ERROR_MESSAGE_NO_GREATER=Must be {0} no greater than {2}
 NumberFieldEditor_ERROR_MESSAGE_NO_SMALLER=Must be {0} no smaller than {1}
 NumberFieldEditor_ERROR_MESSAGE_MUST_BE=Must be {0}
 IntFieldEditor_ERROR_MESSAGE_PART_POSITIVE_INTEGER=positive integer
diff a/application/uitests/org.openjdk.jmc.flightrecorder.uitest/src/test/java/org/openjdk/jmc/flightrecorder/uitest/JfrThreadsPageLegacyTest.java b/application/uitests/org.openjdk.jmc.flightrecorder.uitest/src/test/java/org/openjdk/jmc/flightrecorder/uitest/JfrThreadsPageLegacyTest.java
--- /dev/null
+++ b/application/uitests/org.openjdk.jmc.flightrecorder.uitest/src/test/java/org/openjdk/jmc/flightrecorder/uitest/JfrThreadsPageLegacyTest.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.flightrecorder.uitest;
+
+import org.junit.Assert;
+import org.junit.Rule;
+import org.junit.Test;
+import org.openjdk.jmc.test.jemmy.MCJemmyTestBase;
+import org.openjdk.jmc.test.jemmy.MCUITestRule;
+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCChartCanvas;
+import org.openjdk.jmc.test.jemmy.misc.wrappers.JfrNavigator;
+import org.openjdk.jmc.test.jemmy.misc.wrappers.JfrUi;
+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCMenu;
+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCTable;
+
+public class JfrThreadsPageLegacyTest extends MCJemmyTestBase {
+
+	private static final String PLAIN_JFR = "plain_recording.jfr";
+	private static final String TABLE_COLUMN_HEADER = "Thread";
+	private static final String HIDE_THREAD = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_HIDE_THREAD_ACTION;
+	private static final String RESET_CHART = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_RESET_CHART_TO_SELECTION_ACTION;
+
+	private static MCChartCanvas chartCanvas;
+	private static MCTable threadsTable;
+
+	@Rule
+	public MCUITestRule testRule = new MCUITestRule(verboseRuleOutput) {
+		@Override
+		public void before() {
+			JfrUi.openJfr(materialize("jfr", PLAIN_JFR, JfrThreadsPageLegacyTest.class));
+			JfrNavigator.selectTab(JfrUi.Tabs.THREADS_LEGACY);
+			threadsTable = MCTable.getByColumnHeader(TABLE_COLUMN_HEADER);
+			chartCanvas = MCChartCanvas.getChartCanvas();
+		}
+
+		@Override
+		public void after() {
+			MCMenu.closeActiveEditor();
+		}
+	};
+
+	@Test
+	public void testMenuItemEnablement() {
+		final int numThreads = threadsTable.getItemCount();
+		Assert.assertTrue(numThreads > 0);
+
+		Assert.assertFalse(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
+		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
+
+		chartCanvas.clickContextMenuItem(HIDE_THREAD);
+
+		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
+		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
+
+		chartCanvas.clickContextMenuItem(RESET_CHART);
+
+		Assert.assertFalse(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
+		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
+	}
+
+	@Test
+	public void testHideAllThreads() {
+		final int numSelection = 7;
+		final int numThreads = threadsTable.getItemCount();
+		Assert.assertTrue(numThreads > 0 && numThreads >= numSelection);
+		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
+		Assert.assertFalse(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
+
+		// Select a limited number of threads in the chart using the table
+		threadsTable.selectItems(0, numSelection - 1);
+
+		// Hide all the threads from the chart
+		for (int i = 0; i < numSelection; i++) {
+			chartCanvas.clickContextMenuItem(HIDE_THREAD);
+		}
+
+		// Once all threads are hidden from the chart, the hide thread menu item will be disabled
+		Assert.assertFalse(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
+		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
+
+		chartCanvas.clickContextMenuItem(RESET_CHART);
+
+		// Verify the menu item isEnabled values are back to their default values
+		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
+		Assert.assertFalse(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
+	}
+}
diff a/application/uitests/org.openjdk.jmc.flightrecorder.uitest/src/test/java/org/openjdk/jmc/flightrecorder/uitest/JfrThreadsPageTest.java b/application/uitests/org.openjdk.jmc.flightrecorder.uitest/src/test/java/org/openjdk/jmc/flightrecorder/uitest/JfrThreadsPageTest.java
--- a/application/uitests/org.openjdk.jmc.flightrecorder.uitest/src/test/java/org/openjdk/jmc/flightrecorder/uitest/JfrThreadsPageTest.java
+++ b/application/uitests/org.openjdk.jmc.flightrecorder.uitest/src/test/java/org/openjdk/jmc/flightrecorder/uitest/JfrThreadsPageTest.java
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Red Hat Inc. All rights reserved.
  *
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -31,10 +31,11 @@
  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 package org.openjdk.jmc.flightrecorder.uitest;
 
+import java.util.Arrays;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.function.Supplier;
@@ -47,10 +48,11 @@
 import org.openjdk.jmc.test.jemmy.misc.wrappers.MCChartCanvas;
 import org.openjdk.jmc.test.jemmy.misc.wrappers.JfrNavigator;
 import org.openjdk.jmc.test.jemmy.misc.wrappers.JfrUi;
 import org.openjdk.jmc.test.jemmy.misc.wrappers.MCButton;
 import org.openjdk.jmc.test.jemmy.misc.wrappers.MCMenu;
+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCSashForm;
 import org.openjdk.jmc.test.jemmy.misc.wrappers.MCTable;
 import org.openjdk.jmc.test.jemmy.misc.wrappers.MCText;
 import org.openjdk.jmc.test.jemmy.misc.wrappers.MCTextCanvas;
 import org.openjdk.jmc.test.jemmy.misc.wrappers.MCToolBar;
 import org.openjdk.jmc.ui.UIPlugin;
@@ -63,46 +65,52 @@
 	private static final String RESET_BUTTON = "Reset";
 	private static final String START_TIME = "08:06:19:489";
 	private static final String NEW_START_TIME = "08:06:19:500";
 	private static final String INVALID_START_TIME = "08:06:19:480";
 	private static final String INVALID_END_TIME = "08:07:19:733";
-	private static final String DEFAULT_ZOOM = "100.00 %";
+	private static final String FOLD_CHART = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_FOLD_CHART_TOOLTIP;
+	private static final String FOLD_TABLE = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_FOLD_TABLE_TOOLTIP;
 	private static final String HIDE_THREAD = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_HIDE_THREAD_ACTION;
 	private static final String RESET_CHART = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_RESET_CHART_TO_SELECTION_ACTION;
-	private static final String TABLE_TOOLTIP = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_VIEW_THREAD_DETAILS;
-	private static final String TABLE_SHELL_TEXT = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_TABLE_POPUP_TITLE;
+	private static final String SHOW_CHART = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_SHOW_CHART_TOOLTIP;
+	private static final String SHOW_TABLE = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_SHOW_TABLE_TOOLTIP;
 	private static final String TIME_FILTER_ERROR = org.openjdk.jmc.ui.misc.Messages.TimeFilter_ERROR;
 
 	private static MCChartCanvas chartCanvas;
+	private static MCSashForm sashForm;
 	private static MCTextCanvas textCanvas;
 	private static MCTable threadsTable;
+	private static MCToolBar toolbar;
 	private boolean selected;
 
 	@Rule
 	public MCUITestRule testRule = new MCUITestRule(verboseRuleOutput) {
 		@Override
 		public void before() {
 			JfrUi.openJfr(materialize("jfr", PLAIN_JFR, JfrThreadsPageTest.class));
 			JfrNavigator.selectTab(JfrUi.Tabs.THREADS);
+	        toolbar = MCToolBar.getByToolTip(SHOW_TABLE);
+	        toolbar.clickToolItem(SHOW_TABLE);
 			chartCanvas = MCChartCanvas.getChartCanvas();
 			textCanvas = MCTextCanvas.getTextCanvas();
 			selected = false;
+			sashForm = MCSashForm.getMCSashForm();
+			threadsTable = MCTable.getByColumnHeader(TABLE_COLUMN_HEADER);
 		}
 
 		@Override
 		public void after() {
 			selected = false;
+			toolbar.clickToolItem(FOLD_TABLE);
 			MCMenu.closeActiveEditor();
 		}
 	};
 
 	@Test
 	public void testTextCanvasSelection() throws InterruptedException, ExecutionException, TimeoutException {
-		openThreadsTable();
 		threadsTable.selectItems(0, 0);
 		Assert.assertEquals(1, threadsTable.getSelectionCount());
-		closeThreadsTable();
 
 		CompletableFuture<Void> future = new CompletableFuture<>();
 		CompletableFuture.supplyAsync(new Supplier<Void>() {
 
 			@Override
@@ -120,54 +128,49 @@
 		Assert.assertTrue(selected);
 	}
 
 	@Test
 	public void testZoom() {
+		MCText startTimeField = MCText.getByText(START_TIME);
 		MCButton zoomInBtn = MCButton.getByImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_IN));
 		MCButton zoomOutBtn = MCButton.getByImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_OUT));
-		MCText zoomDisplay = MCText.getByText(DEFAULT_ZOOM);
 
-		//zoom with display bar
-		Assert.assertEquals(zoomDisplay.getText(), DEFAULT_ZOOM);
+		// zoom with display bar
+		Assert.assertEquals(START_TIME, startTimeField.getText());
 		zoomInBtn.click();
 		chartCanvas.clickChart();
-		Assert.assertNotEquals(zoomDisplay.getText(), DEFAULT_ZOOM);
+		Assert.assertNotEquals(START_TIME, startTimeField.getText());
 
 		zoomOutBtn.click();
 		chartCanvas.clickChart();
-		Assert.assertEquals(zoomDisplay.getText(), DEFAULT_ZOOM);
+		Assert.assertEquals(START_TIME, startTimeField.getText());
 
-		//zoom with controls
+		// zoom with controls
 		chartCanvas.clickChart();
 		chartCanvas.keyboardZoomIn();
-		Assert.assertNotEquals(zoomDisplay.getText(), DEFAULT_ZOOM);
+		Assert.assertNotEquals(START_TIME, startTimeField.getText());
 
 		chartCanvas.keyboardZoomOut();
-		Assert.assertEquals(zoomDisplay.getText(), DEFAULT_ZOOM);
+		Assert.assertEquals(START_TIME, startTimeField.getText());
 	}
 
 	@Test
 	public void testResetButtons() {
 		MCText StartTimeField = MCText.getByText(START_TIME);
-		MCText zoomDisplay = MCText.getByText(DEFAULT_ZOOM);
 		MCButton resetBtn = MCButton.getByLabel(RESET_BUTTON);
 		MCButton scaleToFitBtn = MCButton.getByImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_SCALE_TO_FIT));
 
 		StartTimeField.setText(NEW_START_TIME);
 		Assert.assertNotEquals(START_TIME, StartTimeField.getText());
-		Assert.assertNotEquals(zoomDisplay.getText(), DEFAULT_ZOOM);
 
 		resetBtn.click();
 		Assert.assertEquals(START_TIME, StartTimeField.getText());
-		Assert.assertEquals(zoomDisplay.getText(), DEFAULT_ZOOM);
 
 		StartTimeField.setText(NEW_START_TIME);
 		Assert.assertNotEquals(START_TIME, StartTimeField.getText());
-		Assert.assertNotEquals(zoomDisplay.getText(), DEFAULT_ZOOM);
 
 		scaleToFitBtn.click();
-		Assert.assertEquals(zoomDisplay.getText(), DEFAULT_ZOOM);
 		Assert.assertEquals(START_TIME, StartTimeField.getText());
 	}
 
 	@Test
 	public void testTimeFilterInvalid() {
@@ -190,13 +193,11 @@
 		okButton.click();
 	}
 
 	@Test
 	public void testMenuItemEnablement() {
-		openThreadsTable();
 		final int numThreads = threadsTable.getItemCount();
-		closeThreadsTable();
 
 		Assert.assertTrue(numThreads > 0);
 
 		Assert.assertFalse(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
 		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
@@ -214,22 +215,18 @@
 
 	@Test
 	public void testHideAllThreads() {
 		final int numSelection = 7;
 
-		openThreadsTable();
 		final int numThreads = threadsTable.getItemCount();
-		closeThreadsTable();
 
 		Assert.assertTrue(numThreads > 0 && numThreads >= numSelection);
 		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
 		Assert.assertFalse(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
 
-		openThreadsTable();
 		// Select a limited number of threads in the chart using the table
 		threadsTable.selectItems(0, numSelection - 1);
-		closeThreadsTable();
 
 		// Hide all the threads from the chart
 		for (int i = 0; i < numSelection; i++) {
 			chartCanvas.clickContextMenuItem(HIDE_THREAD);
 		}
@@ -243,42 +240,71 @@
 		// Verify the menu item isEnabled values are back to their default values
 		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
 		Assert.assertFalse(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
 	}
 
-	@Test
-	public void testPopupTableSelection() {
-		openThreadsTable();
-		final int numSelection = 7;
-		final int numThreads = threadsTable.getItemCount();
-		Assert.assertTrue(numThreads > 0 && numThreads >= numSelection);
-
-		threadsTable.selectItems(0, numSelection - 1);
-		int originalSelection = threadsTable.getSelectionCount();
-		Assert.assertEquals(numSelection, originalSelection);
-		closeThreadsTable();
-
-		openThreadsTable();
-		int newSelection = threadsTable.getSelectionCount();
-		Assert.assertEquals(newSelection, originalSelection);
-		closeThreadsTable();
-	}
-
-	private void openThreadsTable() {
-		if (threadsTable == null) {
-			MCToolBar.focusMc();
-			MCToolBar tb = MCToolBar.getByToolTip(TABLE_TOOLTIP);
-			tb.clickToolItem(TABLE_TOOLTIP);
-			threadsTable = MCTable.getByColumnHeader(TABLE_SHELL_TEXT, TABLE_COLUMN_HEADER);
-		}
-	}
-
-	private void closeThreadsTable() {
-		if (threadsTable != null) {
-			MCButton okButton = MCButton.getByLabel(TABLE_SHELL_TEXT, OK_BUTTON);
-			okButton.click();
-			threadsTable = null;
-			MCToolBar.focusMc();
-		}
-	}
-
+    @Test
+    public void testFoldingChart() {
+        // Sash weights should both be non-zero to display the chart and table
+        Assert.assertTrue(sashForm.getWeights()[0] != 0 && sashForm.getWeights()[1] != 0);
+
+        // Sash weight corresponding to the chart should be zero when folded
+        toolbar.clickToolItem(FOLD_CHART);
+        Assert.assertTrue(sashForm.getWeights()[0] != 0 && sashForm.getWeights()[1] == 0);
+
+        // When unfolded, the sash weights should be non-zero
+        toolbar.clickToolItem(SHOW_CHART);
+        Assert.assertTrue(sashForm.getWeights()[0] != 0 && sashForm.getWeights()[1] != 0);
+    }
+
+    @Test
+    public void testFoldingTable() {
+        // Sash weights should both be non-zero to display the chart and table
+        Assert.assertTrue(sashForm.getWeights()[0] != 0 && sashForm.getWeights()[1] != 0);
+
+        // Sash weight corresponding to the table should be zero when folded
+        toolbar.clickToolItem(FOLD_TABLE);
+        Assert.assertTrue(sashForm.getWeights()[0] == 0 && sashForm.getWeights()[1] != 0);
+
+        // When unfolded, the sash weights should be non-zero
+        toolbar.clickToolItem(SHOW_TABLE);
+        Assert.assertTrue(sashForm.getWeights()[0] != 0 && sashForm.getWeights()[1] != 0);
+    }
+
+    @Test
+    public void testInvalidFoldingActions() {
+        toolbar.clickToolItem(FOLD_TABLE);
+        int[] weights = sashForm.getWeights();
+        toolbar.clickToolItem(FOLD_CHART);
+        // If the table is already folded, the fold chart action shouldn't work
+        Assert.assertTrue(Arrays.equals(weights, sashForm.getWeights()));
+        toolbar.clickToolItem(SHOW_TABLE);
+
+        toolbar.clickToolItem(FOLD_CHART);
+        weights = sashForm.getWeights();
+        toolbar.clickToolItem(FOLD_TABLE);
+        // If the chart is already folded, the fold table action shouldn't work
+        Assert.assertTrue(Arrays.equals(weights, sashForm.getWeights()));
+
+        // Bring back the chart before retiring
+        toolbar.clickToolItem(SHOW_CHART);
+    }
+
+    @Test
+    public void testPersistingSashWeights() {
+        // Fold the table away
+        toolbar.clickToolItem(FOLD_TABLE);
+        int[] weights = sashForm.getWeights();
+        Assert.assertTrue(sashForm.getWeights()[0] == 0 && sashForm.getWeights()[1] != 0);
+        MCMenu.closeActiveEditor();
+
+        // Re-open the JFR file & verify the table is still folded
+        JfrUi.openJfr(materialize("jfr", PLAIN_JFR, JfrThreadsPageTest.class));
+        JfrNavigator.selectTab(JfrUi.Tabs.THREADS);
+        sashForm = MCSashForm.getMCSashForm();
+        Assert.assertTrue(Arrays.equals(weights, sashForm.getWeights()));
+
+        // Bring back the table before retiring
+        toolbar = MCToolBar.getByToolTip(SHOW_TABLE);
+        toolbar.clickToolItem(SHOW_TABLE);
+    }
 }
diff a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/base/wrappers/MCJemmyBase.java b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/base/wrappers/MCJemmyBase.java
--- a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/base/wrappers/MCJemmyBase.java
+++ b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/base/wrappers/MCJemmyBase.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
diff a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/JfrUi.java b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/JfrUi.java
--- a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/JfrUi.java
+++ b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/JfrUi.java
@@ -56,10 +56,11 @@
 	 */
 	public static enum Tabs {
 		AUTOMATED_ANALYSIS_RESULTS,
 		JAVA_APPLICATION,
 		THREADS,
+		THREADS_LEGACY,
 		MEMORY,
 		LOCK_INSTANCES,
 		FILE_IO,
 		SOCKET_IO,
 		METHOD_PROFILING,
@@ -105,10 +106,13 @@
 				tabText = new String[] {"JVM Internals", "TLAB Allocations"};
 				break;
 			case THREADS:
 				tabText = new String[] {"Java Application", "Threads"};
 				break;
+			case THREADS_LEGACY:
+				tabText = new String[] {"Java Application", "Threads", "(Legacy) Threads"};
+				break;
 			case MEMORY:
 				tabText = new String[] {"Java Application", "Memory"};
 				break;
 			case METHOD_PROFILING:
 				tabText = new String[] {"Java Application", "Method Profiling"};
diff a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCChartCanvas.java b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCChartCanvas.java
--- a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCChartCanvas.java
+++ b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCChartCanvas.java
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Red Hat Inc. All rights reserved.
  *
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -112,11 +112,10 @@
 	}
 
 	/**
 	 * Click the center of the chart in the ChartCanvas
 	 */
-	@SuppressWarnings("unchecked")
 	public void clickChart() {
 		Display.getDefault().syncExec(() -> {
 			control.mouse().click(1, getRelativeClickPoint(), MouseButtons.BUTTON1);
 		});
 	}
@@ -155,11 +154,11 @@
 	 */
 	private Point getRelativeClickPoint() {
 		Fetcher<Point> fetcher = new Fetcher<Point>() {
 			@Override
 			public void run() {
-				setOutput(new Point(control.getScreenBounds().x / 2, control.getScreenBounds().y / 2));
+				setOutput(new Point(control.getControl().getParent().getSize().x / 2, control.getControl().getParent().getSize().y / 2));
 			}
 		};
 		Display.getDefault().syncExec(fetcher);
 		return fetcher.getOutput();
 	}
diff a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCSashForm.java b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCSashForm.java
--- /dev/null
+++ b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCSashForm.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.test.jemmy.misc.wrappers;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.eclipse.swt.custom.SashForm;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Shell;
+import org.jemmy.control.Wrap;
+import org.jemmy.interfaces.Parent;
+import org.openjdk.jmc.test.jemmy.misc.base.wrappers.MCJemmyBase;
+import org.openjdk.jmc.test.jemmy.misc.fetchers.Fetcher;
+
+/**
+ * The Jemmy wrapper for the Mission Control SashForm.
+ */
+public class MCSashForm extends MCJemmyBase {
+
+	private MCSashForm(Wrap<? extends SashForm> formWrap) {
+		this.control = formWrap;
+	}
+
+	/**
+	 * Returns all visible {@link MCSashForm} objects underneath the supplied shell
+	 *
+	 * @param shell
+	 *            the shell from where to start the search for the SashForm object
+	 * @return a {@link List} of {@link MCSashForm} objects
+	 */
+	@SuppressWarnings("unchecked")
+	public static List<MCSashForm> getAll(Wrap<? extends Shell> shell) {
+		List<Wrap<? extends SashForm>> list = getVisible(shell.as(Parent.class, SashForm.class).lookup(SashForm.class));
+		List<MCSashForm> sashForms = new ArrayList<MCSashForm>();
+		for (int i = 0; i < list.size(); i++) {
+			sashForms.add(new MCSashForm(list.get(i)));
+		}
+		return sashForms;
+	}
+
+	/**
+	 * Returns the first visible {@link MCSashForm} object underneath the supplied shell
+	 *
+	 * @param shell
+	 *            the shell from where to start the search for the SashForm object
+	 * @return a {@link MCSashForm} object
+	 */
+	public static MCSashForm getFirst(Wrap<? extends Shell> shell) {
+		return getAll(shell).get(0);
+	}
+
+	/**
+	 * Returns the first visible {@link MCSashForm} object underneath the Mission Control main shell
+	 *
+	 * @return a {@link MCSashForm} object
+	 */
+	public static MCSashForm getMCSashForm() {
+		return getFirst(getShell());
+	}
+
+	/**
+	 * Returns the current weights of the SashForm
+	 *
+	 * @return the Sash Weights
+	 */
+	public int[] getWeights() {
+		Fetcher<int[]> fetcher = new Fetcher<int[]>() {
+			@Override
+			public void run() {
+				setOutput(((SashForm) control.getControl()).getWeights());
+			}
+		};
+		Display.getDefault().syncExec(fetcher);
+		return fetcher.getOutput();
+	}
+}
diff a/license/THIRDPARTYREADME.txt b/license/THIRDPARTYREADME.txt
--- a/license/THIRDPARTYREADME.txt
+++ b/license/THIRDPARTYREADME.txt
@@ -2037,5 +2037,68 @@
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
+
+%% The following notice is provided with respect to FontAwesome,
+which may be included with this product in the form of icons.
+
+Font Awesome Free License
+-------------------------
+
+Font Awesome Free is free, open source, and GPL friendly. You can use it for
+commercial projects, open source projects, or really almost whatever you want.
+Full Font Awesome Free license: https://fontawesome.com/license/free.
+
+# Icons: CC BY 4.0 License (https://creativecommons.org/licenses/by/4.0/)
+In the Font Awesome Free download, the CC BY 4.0 license applies to all icons
+packaged as SVG and JS file types.
+
+# Fonts: SIL OFL 1.1 License (https://scripts.sil.org/OFL)
+In the Font Awesome Free download, the SIL OFL license applies to all icons
+packaged as web and desktop font files.
+
+# Code: MIT License (https://opensource.org/licenses/MIT)
+In the Font Awesome Free download, the MIT license applies to all non-font and
+non-icon files.
+
+# Attribution
+Attribution is required by MIT, SIL OFL, and CC BY licenses. Downloaded Font
+Awesome Free files already contain embedded comments with sufficient
+attribution, so you shouldn't need to do anything additional when using these
+files normally.
+
+We've kept attribution comments terse, so we ask that you do not actively work
+to remove them from files, especially code. They're a great way for folks to
+learn about Font Awesome.
+
+# Brand Icons
+All brand icons are trademarks of their respective owners. The use of these
+trademarks does not indicate endorsement of the trademark holder by Font
+Awesome, nor vice versa. **Please do not use brand logos for any purpose except
+to represent the company, product, or service to which they refer.**
+
+%% The following notice is provided with respect to PatternFly,
+whose color palette may be included with this product.
+
+MIT License
+
+Copyright (c) 2019 Red Hat, Inc.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
