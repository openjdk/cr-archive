<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/GarbageCollectionsPage.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * 
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * The contents of this file are subject to the terms of either the Universal Permissive License
  7  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
  8  *
  9  * or the following license:
 10  *
 11  * Redistribution and use in source and binary forms, with or without modification, are permitted
 12  * provided that the following conditions are met:
 13  * 
 14  * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
 15  * and the following disclaimer.
 16  * 
 17  * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
 18  * conditions and the following disclaimer in the documentation and/or other materials provided with
 19  * the distribution.
 20  * 
 21  * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
 22  * endorse or promote products derived from this software without specific prior written permission.
 23  * 
 24  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
 25  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 26  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 27  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 28  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 30  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 31  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 package org.openjdk.jmc.flightrecorder.ui.pages;
 34 
 35 import static org.openjdk.jmc.common.item.Attribute.attr;
 36 import static org.openjdk.jmc.common.item.ItemQueryBuilder.fromWhere;
 37 import static org.openjdk.jmc.common.unit.UnitLookup.MEMORY;
 38 import static org.openjdk.jmc.flightrecorder.jdk.JdkAggregators.LONGEST_GC_PAUSE;
 39 import static org.openjdk.jmc.flightrecorder.jdk.JdkAggregators.TOTAL_GC_PAUSE;
 40 import static org.openjdk.jmc.flightrecorder.jdk.JdkQueries.HEAP_SUMMARY;
 41 import static org.openjdk.jmc.flightrecorder.ui.common.DataPageToolkit.createAggregatorCheckAction;
 42 import static org.openjdk.jmc.flightrecorder.ui.common.DataPageToolkit.createAttributeCheckAction;
 43 
 44 import java.awt.Color;
 45 import java.util.ArrayList;
 46 import java.util.Arrays;
 47 import java.util.HashMap;
 48 import java.util.Iterator;
 49 import java.util.List;
 50 import java.util.Map;
 51 import java.util.Set;
 52 import java.util.function.Predicate;
 53 import java.util.function.Supplier;
 54 import java.util.stream.Collectors;
 55 import java.util.stream.Stream;
 56 
 57 import org.eclipse.jface.action.IAction;
 58 import org.eclipse.jface.resource.ImageDescriptor;
 59 import org.eclipse.jface.viewers.ArrayContentProvider;
 60 import org.eclipse.jface.viewers.CheckboxTableViewer;
 61 import org.eclipse.jface.viewers.ColumnViewerToolTipSupport;
 62 import org.eclipse.jface.viewers.IStructuredSelection;
 63 import org.eclipse.jface.viewers.TableViewer;
 64 import org.eclipse.swt.SWT;
 65 import org.eclipse.swt.custom.CTabFolder;
 66 import org.eclipse.swt.custom.SashForm;
 67 import org.eclipse.swt.layout.GridData;
 68 import org.eclipse.swt.layout.GridLayout;
 69 import org.eclipse.swt.widgets.Composite;
 70 import org.eclipse.ui.forms.widgets.Form;
 71 import org.eclipse.ui.forms.widgets.FormToolkit;
 72 
 73 import org.openjdk.jmc.common.IMCThread;
 74 import org.openjdk.jmc.common.IState;
 75 import org.openjdk.jmc.common.IWritableState;
 76 import org.openjdk.jmc.common.item.Aggregators;
 77 import org.openjdk.jmc.common.item.IAggregator;
 78 import org.openjdk.jmc.common.item.IAttribute;
 79 import org.openjdk.jmc.common.item.IItem;
 80 import org.openjdk.jmc.common.item.IItemCollection;
 81 import org.openjdk.jmc.common.item.IItemFilter;
 82 import org.openjdk.jmc.common.item.IItemIterable;
 83 import org.openjdk.jmc.common.item.IItemQuery;
 84 import org.openjdk.jmc.common.item.IMemberAccessor;
 85 import org.openjdk.jmc.common.item.IType;
 86 import org.openjdk.jmc.common.item.ItemFilters;
 87 import org.openjdk.jmc.common.item.ItemQueryBuilder;
 88 import org.openjdk.jmc.common.item.ItemToolkit;
 89 import org.openjdk.jmc.common.unit.IQuantity;
 90 import org.openjdk.jmc.common.unit.IRange;
 91 import org.openjdk.jmc.common.unit.LinearKindOfQuantity;
 92 import org.openjdk.jmc.common.unit.UnitLookup;
 93 import org.openjdk.jmc.flightrecorder.JfrAttributes;
 94 import org.openjdk.jmc.flightrecorder.jdk.JdkAttributes;
 95 import org.openjdk.jmc.flightrecorder.jdk.JdkFilters;
 96 import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;
 97 import org.openjdk.jmc.flightrecorder.rules.jdk.memory.ReferenceStatisticsType;
 98 import org.openjdk.jmc.flightrecorder.rules.util.JfrRuleTopics;
 99 import org.openjdk.jmc.flightrecorder.ui.FlightRecorderUI;
100 import org.openjdk.jmc.flightrecorder.ui.IDataPageFactory;
101 import org.openjdk.jmc.flightrecorder.ui.IDisplayablePage;
102 import org.openjdk.jmc.flightrecorder.ui.IPageContainer;
103 import org.openjdk.jmc.flightrecorder.ui.IPageDefinition;
104 import org.openjdk.jmc.flightrecorder.ui.IPageUI;
105 import org.openjdk.jmc.flightrecorder.ui.ItemCollectionToolkit;
106 import org.openjdk.jmc.flightrecorder.ui.StreamModel;
107 import org.openjdk.jmc.flightrecorder.ui.common.AbstractDataPage;
108 import org.openjdk.jmc.flightrecorder.ui.common.DataPageToolkit;
109 import org.openjdk.jmc.flightrecorder.ui.common.FilterComponent;
110 import org.openjdk.jmc.flightrecorder.ui.common.FlavorSelector;
111 import org.openjdk.jmc.flightrecorder.ui.common.FlavorSelector.FlavorSelectorState;
112 import org.openjdk.jmc.flightrecorder.ui.common.ImageConstants;
113 import org.openjdk.jmc.flightrecorder.ui.common.ItemList;
114 import org.openjdk.jmc.flightrecorder.ui.common.ItemList.ItemListBuilder;
115 import org.openjdk.jmc.flightrecorder.ui.common.ItemRow;
116 import org.openjdk.jmc.flightrecorder.ui.common.ThreadGraphLanes;
117 import org.openjdk.jmc.flightrecorder.ui.common.TypeLabelProvider;
118 import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
119 import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStoreActionToolkit;
120 import org.openjdk.jmc.ui.charts.AWTChartToolkit;
121 import org.openjdk.jmc.ui.charts.ISpanSeries;
122 import org.openjdk.jmc.ui.charts.IXDataRenderer;
123 import org.openjdk.jmc.ui.charts.QuantitySeries;
124 import org.openjdk.jmc.ui.charts.RendererToolkit;
125 import org.openjdk.jmc.ui.charts.SpanRenderer;
126 import org.openjdk.jmc.ui.charts.XYChart;
127 import org.openjdk.jmc.ui.column.ColumnBuilder;
128 import org.openjdk.jmc.ui.column.ColumnManager;
129 import org.openjdk.jmc.ui.column.ColumnManager.SelectionState;
130 import org.openjdk.jmc.ui.column.ColumnMenusFactory;
131 import org.openjdk.jmc.ui.column.IColumn;
132 import org.openjdk.jmc.ui.column.TableSettings;
133 import org.openjdk.jmc.ui.handlers.ActionToolkit;
134 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
135 import org.openjdk.jmc.ui.misc.ActionUiToolkit;
136 import org.openjdk.jmc.ui.misc.ChartCanvas;
137 import org.openjdk.jmc.ui.misc.PersistableSashForm;
138 
139 public class GarbageCollectionsPage extends AbstractDataPage {
140 	public static class GarbageCollectionPageFactory implements IDataPageFactory {
141 
142 		@Override
143 		public String getName(IState state) {
144 			return Messages.GarbageCollectionsPage_PAGE_NAME;
145 		}
146 
147 		@Override
148 		public ImageDescriptor getImageDescriptor(IState state) {
149 			return FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.PAGE_GC);
150 		}
151 
152 		@Override
153 		public String[] getTopics(IState state) {
154 			return new String[] {JfrRuleTopics.GARBAGE_COLLECTION};
155 		}
156 
157 		@Override
158 		public IDisplayablePage createPage(IPageDefinition dpd, StreamModel items, IPageContainer editor) {
159 			return new GarbageCollectionsPage(dpd, items, editor);
160 		}
161 	}
162 
163 	private static final ReferenceStatisticsType[] REF_TYPE = ReferenceStatisticsType.values();
164 	private static final String SASH = &quot;sash&quot;; //$NON-NLS-1$
165 	private static final String TABLE_SASH = &quot;tableSash&quot;; //$NON-NLS-1$
166 	private static final String THREAD_LANES = &quot;threadLane&quot;; //$NON-NLS-1$
167 	private static final String GCS = &quot;gcs&quot;; //$NON-NLS-1$
168 	private static final String CHART = &quot;chart&quot;; //$NON-NLS-1$
169 	private static final String PHASE_TABLE_FILTER = &quot;phaseTableFilter&quot;; //$NON-NLS-1$
170 	private static final String GC_TABLE_FILTER = &quot;gcTableFilter&quot;; //$NON-NLS-1$
171 	private static final String METASPACE_TABLE_FILTER = &quot;metaspaceTableFilter&quot;; //$NON-NLS-1$
172 	private static final String PHASE_LIST = &quot;phaseList&quot;; //$NON-NLS-1$
173 	private static final String METASPACE_LIST = &quot;metaspaceList&quot;; //$NON-NLS-1$
174 	private static final String ACTIVITY_LANES_ID = &quot;threadActivityLanes&quot;; //$NON-NLS-1$
175 
176 	private final static Color LONGEST_PAUSE_COLOR = DataPageToolkit.GC_BASE_COLOR.brighter();
177 	private final static Color SUM_OF_PAUSES_COLOR = DataPageToolkit.GC_BASE_COLOR.brighter().brighter();
178 
179 	public static final IAttribute&lt;IQuantity&gt; HEAP_USED_POST_GC = attr(&quot;heapUsed&quot;, Messages.ATTR_HEAP_USED_POST_GC, //$NON-NLS-1$
180 			Messages.ATTR_HEAP_USED_POST_GC_DESC, MEMORY);
181 
182 	public static final IItemQuery HEAP_SUMMARY_POST_GC = fromWhere(JdkFilters.HEAP_SUMMARY_AFTER_GC)
183 			.select(HEAP_USED_POST_GC).build();
184 	private final static IItemQuery METASPACE_SUMMARY = ItemQueryBuilder.fromWhere(JdkFilters.METASPACE_SUMMARY)
185 			.select(JdkAttributes.GC_METASPACE_USED, JdkAttributes.GC_METASPACE_CAPACITY,
186 					JdkAttributes.GC_METASPACE_COMMITTED, JdkAttributes.GC_METASPACE_RESERVED)
187 			.build();
188 
189 	private static class GC {
190 		final IType&lt;IItem&gt; type;
191 		final IItem gcItem;
192 		final Object[] referenceStatisticsData;
193 		IQuantity gcId;
194 		IQuantity duration;
195 		String gcCause;
196 		String gcName;
197 		IQuantity longestPause;
198 		IQuantity sumOfPauses;
199 		IQuantity startTime;
200 		IQuantity endTime;
201 		IQuantity usedDelta;
202 		IQuantity committedDelta;
203 		IQuantity usedMetaspaceDelta;
204 		IQuantity committedMetaspaceDelta;
205 
206 		GC(IItem gcItem, IType&lt;IItem&gt; type) {
207 			this.type = type;
208 			this.gcItem = gcItem;
209 			referenceStatisticsData = new Object[REF_TYPE.length];
210 			usedDelta = UnitLookup.BYTE.quantity(0);
211 			committedDelta = UnitLookup.BYTE.quantity(0);
212 			usedMetaspaceDelta = UnitLookup.BYTE.quantity(0);
213 			committedMetaspaceDelta = UnitLookup.BYTE.quantity(0);
214 		}
215 
216 		Object getRefCount(ReferenceStatisticsType type) {
217 			return referenceStatisticsData[type.ordinal()];
218 		}
219 
220 		void setRefCount(Object type, Object count) {
221 			for (int i = 0; i &lt; REF_TYPE.length; i++) {
222 				if (REF_TYPE[i].typeValue.equals(type)) {
223 					referenceStatisticsData[i] = count;
224 					break;
225 				}
226 			}
227 		}
228 	}
229 
230 	private static final ItemListBuilder PHASES = new ItemListBuilder();
231 	private static final ItemListBuilder METASPACE = new ItemListBuilder();
232 	static {
233 		PHASES.addColumn(JfrAttributes.EVENT_TYPE);
234 		PHASES.addColumn(JdkAttributes.GC_PHASE_NAME);
235 		PHASES.addColumn(JfrAttributes.DURATION);
236 		PHASES.addColumn(JfrAttributes.START_TIME);
237 		PHASES.addColumn(JfrAttributes.EVENT_THREAD);
238 		PHASES.addColumn(JdkAttributes.GC_ID);
239 
240 		METASPACE.addColumn(JdkAttributes.GC_METASPACE_USED);
241 		METASPACE.addColumn(JdkAttributes.GC_DATASPACE_COMMITTED);
242 		METASPACE.addColumn(JdkAttributes.GC_DATASPACE_RESERVED);
243 		METASPACE.addColumn(JdkAttributes.GC_DATASPACE_USED);
244 		METASPACE.addColumn(JdkAttributes.GC_CLASSSPACE_COMMITTED);
245 		METASPACE.addColumn(JdkAttributes.GC_CLASSSPACE_RESERVED);
246 		METASPACE.addColumn(JdkAttributes.GC_CLASSSPACE_USED);
247 		METASPACE.addColumn(JdkAttributes.GC_THRESHOLD);
248 		METASPACE.addColumn(JdkAttributes.GC_WHEN);
249 		METASPACE.addColumn(JdkAttributes.GC_ID);
250 		METASPACE.addColumn(JfrAttributes.START_TIME);
251 	}
252 
253 	private class GarbageCollectionsUi implements IPageUI {
254 
255 		private final SashForm sash;
256 		private final SashForm tableSash;
257 		private final IPageContainer pageContainer;
258 		private final ChartCanvas chartCanvas;
259 		private final ColumnManager gcList;
260 		private IXDataRenderer renderRoot = RendererToolkit.empty();
261 		private IAction GCEventThread = DataPageToolkit.createCheckAction(
262 				Messages.JavaApplicationPage_THREAD_ACTIVITY_ACTION,
263 				Messages.JavaApplicationPage_THREAD_ACTIVITY_ACTION_DESC, ACTIVITY_LANES_ID,
264 				FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_LANES), b -&gt; buildChart());
265 		private final IAction enablePhases = ActionToolkit.checkAction(b -&gt; buildChart(),
266 				Messages.GarbageCollectionsPage_ROW_PAUSE_PHASES, Messages.GarbageCollectionsPage_ROW_PAUSE_PHASES_DESC,
267 				FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_PARTS), &quot;phases&quot;); //$NON-NLS-1$
268 		private final IAction longestPause = createAggregatorCheckAction(LONGEST_GC_PAUSE, &quot;longestPause&quot;, //$NON-NLS-1$
269 				LONGEST_PAUSE_COLOR, b -&gt; buildChart());
270 		private final IAction sumOfPauses = createAggregatorCheckAction(TOTAL_GC_PAUSE, &quot;sumOfPauses&quot;, //$NON-NLS-1$
271 				SUM_OF_PAUSES_COLOR, b -&gt; buildChart());
272 		private final List&lt;IAction&gt; allChartSeriesActions = Stream.concat(
273 				Stream.concat(HEAP_SUMMARY.getAttributes().stream(),
274 						Stream.concat(HEAP_SUMMARY_POST_GC.getAttributes().stream(),
275 								METASPACE_SUMMARY.getAttributes().stream()))
276 						.map(a -&gt; createAttributeCheckAction(a, b -&gt; buildChart())),
277 				Stream.of(longestPause, sumOfPauses, enablePhases, GCEventThread)).collect(Collectors.toList());
278 		private final Set&lt;String&gt; excludedAttributeIds;
279 		private FilterComponent tableFilter;
280 		private XYChart gcChart;
281 		private IRange&lt;IQuantity&gt; currentRange;
282 		private ItemList phasesList;
283 		private FilterComponent phasesFilter;
284 		private ItemList metaspaceList;
285 		private FilterComponent metaspaceFilter;
286 		private CTabFolder gcInfoFolder;
287 		private IItemCollection selectionItems;
288 		private FlavorSelector flavorSelector;
289 		private ThreadGraphLanes lanes;
290 		private MCContextMenuManager mm;
291 
292 		GarbageCollectionsUi(Composite parent, FormToolkit toolkit, IPageContainer pageContainer, IState state) {
293 			this.pageContainer = pageContainer;
294 			excludedAttributeIds = calculateExcludedAttributeIds(getDataSource().getItems());
295 			Form form = DataPageToolkit.createForm(parent, toolkit, getName(), getIcon());
296 			sash = new SashForm(form.getBody(), SWT.VERTICAL);
297 			toolkit.adapt(sash);
298 			tableSash = new SashForm(sash, SWT.HORIZONTAL);
299 			toolkit.adapt(tableSash);
300 
301 			TableViewer tableViewer = new TableViewer(tableSash,
302 					SWT.MULTI | SWT.VIRTUAL | SWT.H_SCROLL | SWT.V_SCROLL | SWT.FULL_SELECTION);
303 			tableViewer.setContentProvider(ArrayContentProvider.getInstance());
304 			ColumnViewerToolTipSupport.enableFor(tableViewer);
305 			List&lt;IColumn&gt; columns = new ArrayList&lt;&gt;();
306 			columns.add(buildGCItemAttributeColumn(JdkAttributes.GC_ID, o -&gt; ((GC) o).gcId));
307 			columns.add(buildGCItemAttributeColumn(JfrAttributes.DURATION, o -&gt; ((GC) o).duration));
308 			columns.add(buildGCItemAttributeColumn(JdkAttributes.GC_CAUSE, o -&gt; ((GC) o).gcCause));
309 			columns.add(buildGCItemAttributeColumn(JdkAttributes.GC_NAME, o -&gt; ((GC) o).gcName));
310 			columns.add(buildGCItemAttributeColumn(JdkAttributes.GC_LONGEST_PAUSE, o -&gt; ((GC) o).longestPause));
311 			columns.add(buildGCItemAttributeColumn(JdkAttributes.GC_SUM_OF_PAUSES, o -&gt; ((GC) o).sumOfPauses));
312 			columns.add(buildGCItemAttributeColumn(JfrAttributes.START_TIME, o -&gt; ((GC) o).startTime));
313 			columns.add(buildGCItemAttributeColumn(JfrAttributes.END_TIME, o -&gt; ((GC) o).endTime));
314 			for (ReferenceStatisticsType t : REF_TYPE) {
315 				columns.add(new ColumnBuilder(t.localizedName, &quot;ReferenceStatisticsType-&quot; + t.name(), //$NON-NLS-1$
316 						o -&gt; ((GC) o).getRefCount(t)).style(SWT.RIGHT).build());
317 			}
318 			columns.add(new ColumnBuilder(Messages.GarbageCollectionsPage_USED_HEAP_DELTA, &quot;usedHeapDelta&quot;, //$NON-NLS-1$
319 					o -&gt; ((GC) o).usedDelta).style(SWT.RIGHT).build());
320 			columns.add(new ColumnBuilder(Messages.GarbageCollectionsPage_COMMITTED_HEAP_DELTA, &quot;committedHeapDelta&quot;, //$NON-NLS-1$
321 					o -&gt; ((GC) o).committedDelta).style(SWT.RIGHT).build());
322 			columns.add(new ColumnBuilder(Messages.GarbageCollectionsPage_USED_METASPACE_DELTA, &quot;usedMetaspaceDelta&quot;, //$NON-NLS-1$
323 					o -&gt; ((GC) o).usedMetaspaceDelta).style(SWT.RIGHT).build());
324 			columns.add(new ColumnBuilder(Messages.GarbageCollectionsPage_COMMITTED_METASPACE_DELTA,
325 					&quot;committedMetaspaceDelta&quot;, o -&gt; ((GC) o).committedMetaspaceDelta).style(SWT.RIGHT).build()); //$NON-NLS-1$
326 
327 			gcList = ColumnManager.build(tableViewer, columns, TableSettings.forState(state.getChild(GCS)));
328 			MCContextMenuManager itemListMm = MCContextMenuManager.create(gcList.getViewer().getControl());
329 			ColumnMenusFactory.addDefaultMenus(gcList, itemListMm);
330 			gcList.getViewer().addSelectionChangedListener(e -&gt; {
331 				buildChart();
332 				pageContainer.showSelection(ItemCollectionToolkit.build(gcSelectedGcItems()));
333 				updatePhaseList();
334 				updateMetaspaceList();
335 			});
336 
337 			SelectionStoreActionToolkit.addSelectionStoreActions(gcList.getViewer(), pageContainer.getSelectionStore(),
338 					() -&gt; ItemCollectionToolkit.build(gcSelectedGcItems()),
339 					Messages.GarbageCollectionsPage_LIST_SELECTION, itemListMm);
340 			tableFilter = FilterComponent.createFilterComponent(tableViewer.getControl(), gcList, tableFilterState,
341 					getDataSource().getItems().apply(JdkFilters.GARBAGE_COLLECTION),
342 					pageContainer.getSelectionStore()::getSelections, this::onFilterChange);
343 			itemListMm.add(tableFilter.getShowFilterAction());
344 			itemListMm.add(tableFilter.getShowSearchAction());
345 
346 			gcInfoFolder = new CTabFolder(tableSash, SWT.NONE);
347 			phasesList = PHASES.buildWithoutBorder(gcInfoFolder, TableSettings.forState(state.getChild(PHASE_LIST)));
348 			phasesList.getManager().getViewer().addSelectionChangedListener(e -&gt; {
349 				buildChart();
350 				pageContainer.showSelection(ItemCollectionToolkit.build(phasesList.getSelection().get()));
351 			});
352 			phasesFilter = FilterComponent.createFilterComponent(phasesList, phasesFilterState,
353 					getDataSource().getItems().apply(JdkFilters.GC_PAUSE_PHASE),
354 					pageContainer.getSelectionStore()::getSelections, this::onPhasesFilterChange);
355 			MCContextMenuManager phasesMm = MCContextMenuManager
356 					.create(phasesList.getManager().getViewer().getControl());
357 			ColumnMenusFactory.addDefaultMenus(phasesList.getManager(), phasesMm);
358 			SelectionStoreActionToolkit.addSelectionStoreActions(pageContainer.getSelectionStore(), phasesList,
359 					Messages.GarbageCollectionsPage_PAUSE_PHASE_SELECTION, phasesMm);
360 			phasesMm.add(phasesFilter.getShowFilterAction());
361 			phasesMm.add(phasesFilter.getShowSearchAction());
362 			DataPageToolkit.addTabItem(gcInfoFolder, phasesFilter.getComponent(),
363 					Messages.GarbageCollectionsPage_PAUSE_PHASES_TITLE);
364 
365 			metaspaceList = METASPACE.buildWithoutBorder(gcInfoFolder,
366 					TableSettings.forState(state.getChild(METASPACE_LIST)));
367 			metaspaceList.getManager().getViewer().addSelectionChangedListener(
368 					e -&gt; pageContainer.showSelection(ItemCollectionToolkit.build(metaspaceList.getSelection().get())));
369 			metaspaceFilter = FilterComponent.createFilterComponent(metaspaceList, metaspaceFilterState,
370 					getDataSource().getItems().apply(JdkFilters.METASPACE_SUMMARY),
371 					pageContainer.getSelectionStore()::getSelections, this::onMetaspaceFilterChange);
372 			MCContextMenuManager metaspaceMm = MCContextMenuManager
373 					.create(metaspaceList.getManager().getViewer().getControl());
374 			ColumnMenusFactory.addDefaultMenus(metaspaceList.getManager(), metaspaceMm);
375 			SelectionStoreActionToolkit.addSelectionStoreActions(pageContainer.getSelectionStore(), metaspaceList,
376 					Messages.GarbageCollectionsPage_METASPACE_SELECTION, metaspaceMm);
377 			metaspaceMm.add(metaspaceFilter.getShowFilterAction());
378 			metaspaceMm.add(metaspaceFilter.getShowSearchAction());
379 			DataPageToolkit.addTabItem(gcInfoFolder, metaspaceFilter.getComponent(),
380 					Messages.GarbageCollectionsPage_METASPACE_TITLE);
381 
382 			Composite chartContainer = toolkit.createComposite(sash);
383 			chartContainer.setLayout(new GridLayout(2, false));
384 			chartCanvas = new ChartCanvas(chartContainer);
385 			chartCanvas.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
386 			ActionToolkit.loadCheckState(state.getChild(CHART), allChartSeriesActions.stream());
387 			CheckboxTableViewer chartLegend = ActionUiToolkit.buildCheckboxViewer(chartContainer,
388 					allChartSeriesActions.stream().filter(a -&gt; includeAttribute(a.getId())));
389 			GridData gd = new GridData(SWT.FILL, SWT.FILL, false, true);
390 			gd.widthHint = 180;
391 			chartLegend.getControl().setLayoutData(gd);
392 			lanes = new ThreadGraphLanes(() -&gt; getDataSource(), () -&gt; buildChart());
393 			lanes.initializeChartConfiguration(Stream.of(state.getChildren(THREAD_LANES)));
394 			IAction editLanesAction = ActionToolkit.action(() -&gt; lanes.openEditLanesDialog(mm, false),
395 					Messages.ThreadsPage_EDIT_LANES,
396 					FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_LANES_EDIT));
397 			form.getToolBarManager().add(editLanesAction);
398 
399 			DataPageToolkit.createChartTimestampTooltip(chartCanvas);
400 			gcChart = new XYChart(pageContainer.getRecordingRange(), renderRoot, 180);
401 			gcChart.setVisibleRange(timelineRange.getStart(), timelineRange.getEnd());
402 			gcChart.addVisibleRangeListener(r -&gt; timelineRange = r);
403 
404 			PersistableSashForm.loadState(sash, state.getChild(SASH));
405 			PersistableSashForm.loadState(tableSash, state.getChild(TABLE_SASH));
406 
407 			flavorSelector = FlavorSelector.itemsWithTimerange(form, JdkFilters.GARBAGE_COLLECTION,
408 					getDataSource().getItems(), pageContainer, this::onInputSelected, this::onShow,
409 					flavorSelectorState);
410 
411 			gcInfoFolder.setSelection(gcInfoTabSelection);
412 			addResultActions(form);
413 			tableFilter.loadState(state.getChild(GC_TABLE_FILTER));
414 			phasesFilter.loadState(state.getChild(PHASE_TABLE_FILTER));
415 			metaspaceFilter.loadState(state.getChild(METASPACE_TABLE_FILTER));
416 			gcList.setSelectionState(gcListSelection);
417 			phasesList.getManager().setSelectionState(phasesSelection);
418 			metaspaceList.getManager().setSelectionState(metaspaceSelection);
419 			mm = (MCContextMenuManager) chartCanvas.getContextMenu();
420 			lanes.updateContextMenu(mm, false);
421 			lanes.updateContextMenu(MCContextMenuManager.create(chartLegend.getControl()), true);
422 
423 			// Older recordings may not have thread information in pause events.
424 			// In those cases there is no need for the thread activity actions.
425 			if (!getDataSource().getItems()
426 					.apply(ItemFilters.and(ItemFilters.hasAttribute(JfrAttributes.EVENT_THREAD), JdkFilters.GC_PAUSE))
427 					.hasItems()) {
428 				editLanesAction.setEnabled(false);
429 				editLanesAction.setToolTipText(Messages.GarbageCollectionsPage_DISABLED_TOOLTIP);
430 				GCEventThread.setEnabled(false);
431 				GCEventThread.setDescription(Messages.GarbageCollectionsPage_DISABLED_TOOLTIP);
432 				for (IAction action : lanes.getContextMenuActions()) {
433 					action.setEnabled(false);
434 				}
435 			}
436 		}
437 
438 		private void updatePhaseList() {
439 			phasesList.show(ItemCollectionToolkit.filterIfNotNull(getPhaseItems(), phasesFilterState));
440 		}
441 
442 		private void updateMetaspaceList() {
443 			metaspaceList.show(ItemCollectionToolkit.filterIfNotNull(getMetaspaceItems(), metaspaceFilterState));
444 		}
445 
446 		private IItemCollection getMetaspaceItems() {
447 			Set&lt;IQuantity&gt; selectedGcIds = getSelectedGcIds();
448 			IItemCollection metaspaceItems = getDataSource().getItems().apply(JdkFilters.METASPACE_SUMMARY)
449 					.apply(ItemFilters.memberOf(JdkAttributes.GC_ID, selectedGcIds));
450 			return metaspaceItems;
451 		}
452 
453 		private IItemCollection getPhaseItems() {
454 			Set&lt;IQuantity&gt; gcIds = getSelectedGcIds();
455 			IItemCollection gcIdPausePhases = getDataSource().getItems().apply(JdkFilters.GC_PAUSE_PHASE)
456 					.apply(ItemFilters.memberOf(JdkAttributes.GC_ID, gcIds));
457 			return gcIdPausePhases;
458 		}
459 
460 		private Set&lt;IQuantity&gt; getSelectedGcIds() {
461 			@SuppressWarnings(&quot;unchecked&quot;)
462 			List&lt;GC&gt; selected = ((IStructuredSelection) gcList.getViewer().getSelection()).toList();
463 			Set&lt;IQuantity&gt; gcIds = selected.stream()
464 					.map(gc -&gt; gc.type.getAccessor(JdkAttributes.GC_ID.getKey()).getMember(gc.gcItem))
465 					.collect(Collectors.toSet());
466 			return gcIds;
467 		}
468 
469 		private void onFilterChange(IItemFilter newFilter) {
470 			IItemCollection items = selectionItems != null ? selectionItems : getDataSource().getItems();
471 			items = items.apply(JdkFilters.GARBAGE_COLLECTION);
472 			if (tableFilter.isVisible()) {
473 				updateTable(ItemCollectionToolkit.filterIfNotNull(items, newFilter));
474 				Object input = gcList.getViewer().getInput();
475 				tableFilter.setColor(input instanceof Object[] &amp;&amp; ((Object[]) input).length &gt; 0 ? 1 : 0);
476 			} else {
477 				updateTable(items);
478 			}
479 			tableFilterState = newFilter;
480 		}
481 
482 		private void onPhasesFilterChange(IItemFilter filter) {
483 			phasesFilter.filterChangeHelper(filter, phasesList,
484 					getDataSource().getItems().apply(JdkFilters.GC_PAUSE_PHASE));
485 			phasesFilterState = filter;
486 		}
487 
488 		private void onMetaspaceFilterChange(IItemFilter filter) {
489 			metaspaceFilter.filterChangeHelper(filter, metaspaceList,
490 					getDataSource().getItems().apply(JdkFilters.METASPACE_SUMMARY));
491 			metaspaceFilterState = filter;
492 		}
493 
494 		private ItemRow buildSpanRow(IItemCollection items, String typeId) {
495 			IItemCollection filtered = items.apply(ItemFilters.type(typeId));
496 			return new ItemRow(DataPageToolkit.buildSpanRenderer(filtered,
497 					AWTChartToolkit.staticColor(TypeLabelProvider.getColorOrDefault(typeId))), filtered);
498 		}
499 
500 		private void buildChart() {
501 			IItemCollection allItems = getDataSource().getItems();
502 			List&lt;IXDataRenderer&gt; rows = new ArrayList&lt;&gt;();
503 			Predicate&lt;IAttribute&lt;IQuantity&gt;&gt; legendFilter = this::isAttributeEnabled;
504 			DataPageToolkit.buildLinesRow(Messages.GarbageCollectionsPage_ROW_HEAP,
505 					Messages.GarbageCollectionsPage_ROW_HEAP_DESC, allItems, false, HEAP_SUMMARY, legendFilter,
506 					UnitLookup.BYTE.quantity(0), null).ifPresent(rows::add);
507 			DataPageToolkit.buildLinesRow(Messages.GarbageCollectionsPage_ROW_HEAP_POST_GC,
508 					Messages.GarbageCollectionsPage_ROW_HEAP_POST_GC_DESC, allItems, false, HEAP_SUMMARY_POST_GC,
509 					legendFilter, UnitLookup.BYTE.quantity(0), null).ifPresent(rows::add);
510 			DataPageToolkit.buildLinesRow(Messages.GarbageCollectionsPage_ROW_METASPACE,
511 					Messages.GarbageCollectionsPage_ROW_METASPACE_DESC, allItems, false, METASPACE_SUMMARY,
512 					legendFilter, UnitLookup.BYTE.quantity(0), null).ifPresent(rows::add);
513 			// Pauses
514 			List&lt;IXDataRenderer&gt; gcPauseRows = new ArrayList&lt;&gt;();
515 			IItemCollection pauseEvents = allItems.apply(JdkFilters.GC_PAUSE);
516 			if (longestPause.isChecked()) {
517 				gcPauseRows.add(DataPageToolkit.buildTimestampHistogramRenderer(pauseEvents, LONGEST_GC_PAUSE,
518 						LONGEST_PAUSE_COLOR));
519 			}
520 			if (sumOfPauses.isChecked()) {
521 				gcPauseRows.add(DataPageToolkit.buildTimestampHistogramRenderer(pauseEvents, TOTAL_GC_PAUSE,
522 						SUM_OF_PAUSES_COLOR));
523 			}
524 			if (!gcPauseRows.isEmpty()) {
525 				rows.add(RendererToolkit.layers(DataPageToolkit.buildGcPauseRow(allItems),
526 						RendererToolkit.uniformRows(gcPauseRows)));
527 			}
528 			// Phases
529 			if (enablePhases.isChecked()) {
530 				ItemRow pauses = buildSpanRow(allItems, JdkTypeIDs.GC_PAUSE);
531 				ItemRow l1 = buildSpanRow(allItems, JdkTypeIDs.GC_PAUSE_L1);
532 				ItemRow l2 = buildSpanRow(allItems, JdkTypeIDs.GC_PAUSE_L2);
533 				ItemRow l3 = buildSpanRow(allItems, JdkTypeIDs.GC_PAUSE_L3);
534 				ItemRow l4 = buildSpanRow(allItems, JdkTypeIDs.GC_PAUSE_L4);
535 				rows.add(RendererToolkit.uniformRows(Arrays.asList(pauses, l1, l2, l3, l4), enablePhases.getText()));
536 			}
537 			IItemFilter pauseThreadsFilter = ItemFilters.and(JdkFilters.GC_PAUSE,
538 					ItemFilters.hasAttribute(JfrAttributes.EVENT_THREAD));
539 			// Thread information may not be available in earlier recordings, ensure we actually have items before proceeding
540 			if (GCEventThread.isChecked() &amp;&amp; phasesList.getSelection().get().count() &gt; 0
541 					&amp;&amp; allItems.apply(pauseThreadsFilter).hasItems()) {
542 				// Get the event threads from the selected events
543 				IAggregator&lt;Set&lt;IMCThread&gt;, ?&gt; distinctThreadsAggregator = Aggregators
544 						.distinct(JfrAttributes.EVENT_THREAD);
545 				IItemCollection items = ItemCollectionToolkit.build(phasesList.getSelection().get());
546 				Set&lt;IMCThread&gt; threads = items.getAggregate(distinctThreadsAggregator);
547 				List&lt;IXDataRenderer&gt; renderers = threads.stream()
548 						.map((thread) -&gt; lanes.buildThreadRenderer(thread,
549 								getDataSource().getItems()
550 										.apply(ItemFilters.equals(JfrAttributes.EVENT_THREAD, thread))))
551 						.collect(Collectors.toList());
552 				rows.add(RendererToolkit.uniformRows(renderers));
553 			}
554 
555 			renderRoot = RendererToolkit.layers(RendererToolkit.uniformRows(rows), buildTableSelectionRenderer());
556 			chartCanvas.replaceRenderer(renderRoot);
557 		}
558 
559 		private boolean isAttributeEnabled(IAttribute&lt;IQuantity&gt; attr) {
560 			String id = attr.getIdentifier();
561 			String name = attr.getName();
562 			return includeAttribute(id)
563 					&amp;&amp; allChartSeriesActions.stream().filter(a -&gt; name.equals(a.getText())).findAny().get().isChecked();
564 		}
565 
566 		private boolean includeAttribute(String attrId) {
567 			return !excludedAttributeIds.contains(attrId);
568 		}
569 
570 		private IXDataRenderer buildTableSelectionRenderer() {
571 			Supplier&lt;Stream&lt;? extends IItem&gt;&gt; phaseSelection = phasesList.getSelection();
572 			Stream&lt;? extends IItem&gt; gcItems = phaseSelection.get().count() &gt; 0 ? phaseSelection.get()
573 					: gcSelectedGcItems();
574 			ISpanSeries&lt;IItem&gt; gcBackdrop = QuantitySeries.max(ItemCollectionToolkit.build(gcItems),
575 					JfrAttributes.START_TIME, JfrAttributes.END_TIME);
576 			return SpanRenderer.build(gcBackdrop, AWTChartToolkit.staticColor(new Color(100, 180, 220, 150)));
577 		}
578 
579 		@Override
580 		public void saveTo(IWritableState memento) {
581 			PersistableSashForm.saveState(sash, memento.createChild(SASH));
582 			PersistableSashForm.saveState(tableSash, memento.createChild(TABLE_SASH));
583 			gcList.getSettings().saveState(memento.createChild(GCS));
584 			phasesList.getManager().getSettings().saveState(memento.createChild(PHASE_LIST));
585 			metaspaceList.getManager().getSettings().saveState(memento.createChild(METASPACE_LIST));
586 			ActionToolkit.saveCheckState(memento.createChild(CHART), allChartSeriesActions.stream());
587 			tableFilter.saveState(memento.createChild(GC_TABLE_FILTER));
588 			phasesFilter.saveState(memento.createChild(PHASE_TABLE_FILTER));
589 			metaspaceFilter.saveState(memento.createChild(METASPACE_TABLE_FILTER));
590 
591 			saveToLocal();
592 		}
593 
594 		private void saveToLocal() {
595 			gcListSelection = gcList.getSelectionState();
596 			phasesSelection = phasesList.getManager().getSelectionState();
597 			metaspaceSelection = metaspaceList.getManager().getSelectionState();
598 			gcInfoTabSelection = gcInfoFolder.getSelectionIndex();
599 			flavorSelectorState = flavorSelector.getFlavorSelectorState();
600 		}
601 
602 		private void updateTable(IItemCollection gcs) {
603 			Map&lt;Object, GC&gt; gcMap = new HashMap&lt;&gt;();
604 			gcs.forEach(is -&gt; {
605 				IMemberAccessor&lt;IQuantity, IItem&gt; gcIdAccessor = JdkAttributes.GC_ID.getAccessor(is.getType());
606 				IMemberAccessor&lt;IQuantity, IItem&gt; durationAccessor = JfrAttributes.DURATION.getAccessor(is.getType());
607 				IMemberAccessor&lt;String, IItem&gt; causeAccessor = JdkAttributes.GC_CAUSE.getAccessor(is.getType());
608 				IMemberAccessor&lt;String, IItem&gt; nameAccessor = JdkAttributes.GC_NAME.getAccessor(is.getType());
609 				IMemberAccessor&lt;IQuantity, IItem&gt; longestPauseAccessor = JdkAttributes.GC_LONGEST_PAUSE
610 						.getAccessor(is.getType());
611 				IMemberAccessor&lt;IQuantity, IItem&gt; sumPauseAccessor = JdkAttributes.GC_SUM_OF_PAUSES
612 						.getAccessor(is.getType());
613 				IMemberAccessor&lt;IQuantity, IItem&gt; startTimeAccessor = JfrAttributes.START_TIME
614 						.getAccessor(is.getType());
615 				IMemberAccessor&lt;IQuantity, IItem&gt; endTimeAccessor = JfrAttributes.END_TIME.getAccessor(is.getType());
616 
617 				is.forEach(item -&gt; {
618 					GC value = new GC(item, is.getType());
619 					value.gcId = gcIdAccessor.getMember(item);
620 					value.duration = durationAccessor.getMember(item);
621 					value.gcCause = causeAccessor.getMember(item);
622 					value.gcName = nameAccessor.getMember(item);
623 					value.longestPause = longestPauseAccessor.getMember(item);
624 					value.sumOfPauses = sumPauseAccessor.getMember(item);
625 					value.startTime = startTimeAccessor.getMember(item);
626 					value.endTime = endTimeAccessor.getMember(item);
627 					logDuplicateGcId(gcMap.put(gcIdAccessor.getMember(item), value));
628 				});
629 			});
630 			IItemCollection refItems = getDataSource().getItems().apply(JdkFilters.REFERENCE_STATISTICS);
631 			refItems.forEach(is -&gt; {
632 				IMemberAccessor&lt;IQuantity, IItem&gt; gdIdAccessor = JdkAttributes.GC_ID.getAccessor(is.getType());
633 				IMemberAccessor&lt;String, IItem&gt; typeAccessor = JdkAttributes.REFERENCE_STATISTICS_TYPE
634 						.getAccessor(is.getType());
635 				IMemberAccessor&lt;IQuantity, IItem&gt; countAccessor = JdkAttributes.REFERENCE_STATISTICS_COUNT
636 						.getAccessor(is.getType());
637 				is.forEach(item -&gt; {
638 					GC gc = gcMap.get(gdIdAccessor.getMember(item));
639 					if (gc != null) {
640 						gc.setRefCount(typeAccessor.getMember(item), countAccessor.getMember(item));
641 					}
642 				});
643 			});
644 			IItemCollection heapItems = getDataSource().getItems().apply(JdkFilters.HEAP_SUMMARY);
645 			heapItems.forEach(is -&gt; {
646 				IMemberAccessor&lt;IQuantity, IItem&gt; gcIdAccessor = JdkAttributes.GC_ID.getAccessor(is.getType());
647 				IMemberAccessor&lt;String, IItem&gt; gcWhenAccessor = JdkAttributes.GC_WHEN.getAccessor(is.getType());
648 				IMemberAccessor&lt;IQuantity, IItem&gt; usedHeapAccessor = JdkAttributes.HEAP_USED.getAccessor(is.getType());
649 				IMemberAccessor&lt;IQuantity, IItem&gt; committedHeapAccessor = JdkAttributes.GC_HEAPSPACE_COMMITTED
650 						.getAccessor(is.getType());
651 
652 				is.forEach(item -&gt; {
653 					GC gc = gcMap.get(gcIdAccessor.getMember(item));
654 					if (gc != null) {
655 						String when = gcWhenAccessor.getMember(item);
656 						if (&quot;Before GC&quot;.equals(when)) { //$NON-NLS-1$
657 							gc.usedDelta = gc.usedDelta.subtract(usedHeapAccessor.getMember(item));
658 							gc.committedDelta = gc.committedDelta.subtract(committedHeapAccessor.getMember(item));
659 						} else {
660 							gc.usedDelta = gc.usedDelta.add(usedHeapAccessor.getMember(item));
661 							gc.committedDelta = gc.committedDelta.add(committedHeapAccessor.getMember(item));
662 						}
663 					}
664 				});
665 			});
666 
667 			IItemCollection metaspaceItems = getDataSource().getItems().apply(JdkFilters.METASPACE_SUMMARY);
668 			metaspaceItems.forEach(is -&gt; {
669 				IMemberAccessor&lt;IQuantity, IItem&gt; gcIdAccessor = JdkAttributes.GC_ID.getAccessor(is.getType());
670 				IMemberAccessor&lt;String, IItem&gt; gcWhenAccessor = JdkAttributes.GC_WHEN.getAccessor(is.getType());
671 				IMemberAccessor&lt;IQuantity, IItem&gt; usedMetaspaceAccessor = JdkAttributes.GC_METASPACE_USED
672 						.getAccessor(is.getType());
673 				IMemberAccessor&lt;IQuantity, IItem&gt; committedMetaspaceAccessor = JdkAttributes.GC_METASPACE_COMMITTED
674 						.getAccessor(is.getType());
675 
676 				is.forEach(item -&gt; {
677 					GC gc = gcMap.get(gcIdAccessor.getMember(item));
678 					if (gc != null &amp;&amp; usedMetaspaceAccessor != null &amp;&amp; committedMetaspaceAccessor != null
679 							&amp;&amp; gcWhenAccessor != null) {
680 						String when = gcWhenAccessor.getMember(item);
681 						if (&quot;Before GC&quot;.equals(when)) { //$NON-NLS-1$
682 							gc.usedMetaspaceDelta = gc.usedMetaspaceDelta
683 									.subtract(usedMetaspaceAccessor.getMember(item));
684 							gc.committedMetaspaceDelta = gc.committedMetaspaceDelta
685 									.subtract(committedMetaspaceAccessor.getMember(item));
686 						} else {
687 							gc.usedMetaspaceDelta = gc.usedMetaspaceDelta.add(usedMetaspaceAccessor.getMember(item));
688 							gc.committedMetaspaceDelta = gc.committedMetaspaceDelta
689 									.add(committedMetaspaceAccessor.getMember(item));
690 						}
691 					}
692 				});
693 			});
694 			gcList.getViewer().setInput(gcMap.values().toArray());
695 		}
696 
697 		private void onShow(Boolean show) {
698 			IRange&lt;IQuantity&gt; range = show ? currentRange : pageContainer.getRecordingRange();
699 			gcChart.setVisibleRange(range.getStart(), range.getEnd());
700 			buildChart();
701 		}
702 
703 		private void updateChart() {
704 			DataPageToolkit.setChart(chartCanvas, gcChart, pageContainer::showSelection);
705 			SelectionStoreActionToolkit.addSelectionStoreRangeActions(pageContainer.getSelectionStore(), gcChart,
706 					JfrAttributes.LIFETIME, Messages.GarbageCollectionsPage_TIMELINE_SELECTION,
707 					chartCanvas.getContextMenu());
708 			buildChart();
709 		}
710 
711 		private void onInputSelected(IItemCollection items, IRange&lt;IQuantity&gt; timeRange) {
712 			this.currentRange = timeRange;
713 			selectionItems = items;
714 			IItemCollection gcs = items != null ? items : getDataSource().getItems();
715 			updateTable(gcs.apply(JdkFilters.GARBAGE_COLLECTION));
716 			updateChart();
717 		}
718 
719 		private Stream&lt;? extends IItem&gt; gcSelectedGcItems() {
720 			@SuppressWarnings(&quot;unchecked&quot;)
721 			List&lt;GC&gt; sel = ((IStructuredSelection) gcList.getViewer().getSelection()).toList();
722 			return sel.stream().map(gc -&gt; gc.gcItem);
723 		}
724 	}
725 
726 	private static void logDuplicateGcId(GC duplicateGC) {
727 		if (duplicateGC != null) {
728 			IQuantity gcID = JdkAttributes.GC_ID.getAccessor(ItemToolkit.getItemType(duplicateGC.gcItem))
729 					.getMember(duplicateGC.gcItem);
730 			FlightRecorderUI.getDefault().getLogger().severe(&quot;GC with id &quot; + gcID + &quot; is duplicated&quot;); //$NON-NLS-1$ //$NON-NLS-2$
731 		}
732 	}
733 
734 	private static IColumn buildGCItemAttributeColumn(IAttribute&lt;?&gt; a, IMemberAccessor&lt;?, Object&gt; cellAccessor) {
735 		int style = a.getContentType() instanceof LinearKindOfQuantity ? SWT.RIGHT : SWT.NONE;
736 		return new ColumnBuilder(a.getName(), a.getIdentifier(), cellAccessor).description(a.getDescription())
737 				.style(style).build();
738 	}
739 
740 	@Override
741 	public IPageUI display(Composite parent, FormToolkit toolkit, IPageContainer pageContainer, IState state) {
742 		return new GarbageCollectionsUi(parent, toolkit, pageContainer, state);
743 	}
744 
745 	private IItemFilter tableFilterState;
746 	private IItemFilter phasesFilterState;
747 	private IItemFilter metaspaceFilterState;
748 	private IRange&lt;IQuantity&gt; timelineRange;
749 	private SelectionState gcListSelection;
750 	private SelectionState phasesSelection;
751 	private SelectionState metaspaceSelection;
752 	private int gcInfoTabSelection = 0;
753 	public FlavorSelectorState flavorSelectorState;
754 
755 	public GarbageCollectionsPage(IPageDefinition dpd, StreamModel items, IPageContainer editor) {
756 		super(dpd, items, editor);
757 		timelineRange = editor.getRecordingRange();
758 	}
759 
760 	@Override
761 	public IItemFilter getDefaultSelectionFilter() {
762 		return ItemFilters.or(JdkFilters.GC_PAUSE, JdkFilters.GC_PAUSE_PHASE, JdkFilters.HEAP_SUMMARY,
763 				JdkFilters.METASPACE_SUMMARY);
764 	}
765 
766 	private static Set&lt;String&gt; calculateExcludedAttributeIds(IItemCollection items) {
767 		// In JDK7 there are no metaspace events. In early JDK8
768 		// metaspace:committed is missing. In later JDK8 metaspace:capacity is
769 		// missing.
770 		Stream&lt;IAttribute&lt;?&gt;&gt; exclude = METASPACE_SUMMARY.getAttributes().stream();
771 		Iterator&lt;IItemIterable&gt; iterator = items.apply(METASPACE_SUMMARY.getFilter()).iterator();
772 		if (iterator.hasNext()) {
773 			IType&lt;IItem&gt; type = iterator.next().getType();
774 			exclude = exclude.filter(a -&gt; a.getAccessor(type) == null);
775 		}
776 		return exclude.map(IAttribute::getIdentifier).collect(Collectors.toSet());
777 	}
778 }
    </pre>
  </body>
</html>