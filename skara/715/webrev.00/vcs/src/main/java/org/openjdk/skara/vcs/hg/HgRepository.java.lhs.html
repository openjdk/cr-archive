<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames vcs/src/main/java/org/openjdk/skara/vcs/hg/HgRepository.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.skara.vcs.hg;
  24 
  25 import org.openjdk.skara.process.Process;
  26 import org.openjdk.skara.process.Execution;
  27 import org.openjdk.skara.vcs.*;
  28 import org.openjdk.skara.vcs.tools.*;
  29 
  30 import java.io.*;
  31 import java.nio.file.*;
  32 import java.time.*;
  33 import java.time.format.DateTimeFormatter;
  34 import java.util.*;
  35 import java.util.logging.Logger;
  36 import java.util.stream.*;
  37 import java.net.URI;
  38 
  39 public class HgRepository implements Repository {
  40     private static final String EXT_PY = &quot;ext.py&quot;;
  41     private final Path dir;
  42     private final Logger log = Logger.getLogger(&quot;org.openjdk.skara.vcs.hg&quot;);
  43 
  44     private void copyResource(String name, Path p) throws IOException {
  45         Files.copy(this.getClass().getResourceAsStream(&quot;/&quot; + name), p, StandardCopyOption.REPLACE_EXISTING);
  46     }
  47 
  48     private java.lang.Process start(String... cmd) throws IOException {
  49         return start(Arrays.asList(cmd));
  50     }
  51 
  52     private java.lang.Process start(List&lt;String&gt; cmd) throws IOException {
  53         log.fine(&quot;Executing &quot; + String.join(&quot; &quot;, cmd));
  54         var pb = new ProcessBuilder(cmd);
  55         pb.directory(dir.toFile());
  56         pb.redirectError(ProcessBuilder.Redirect.DISCARD);
  57         pb.environment().put(&quot;HGRCPATH&quot;, &quot;&quot;);
  58         pb.environment().put(&quot;HGPLAIN&quot;, &quot;&quot;);
  59         return pb.start();
  60     }
  61 
  62     private static void stop(java.lang.Process p) throws IOException {
  63         if (p != null &amp;&amp; p.isAlive()) {
  64             var stream = p.getInputStream();
  65             var read = 0;
  66             var buf = new byte[128];
  67             while (read != -1) {
  68                 read = stream.read(buf);
  69             }
  70             try {
  71                 p.waitFor();
  72             } catch (InterruptedException e) {
  73                 throw new IOException(e);
  74             }
  75         }
  76     }
  77 
  78     private Execution capture(List&lt;String&gt; cmd) {
  79         return capture(cmd.toArray(new String[0]));
  80     }
  81 
  82     private Execution capture(String... cmd) {
  83         return capture(dir, cmd);
  84     }
  85 
  86     private static Execution capture(Path cwd, List&lt;String&gt; cmd) {
  87         return capture(cwd, cmd.toArray(new String[0]));
  88     }
  89     private static Execution capture(Path cwd, String... cmd) {
  90         return Process.capture(cmd)
  91                       .environ(&quot;HGRCPATH&quot;, &quot;&quot;)
  92                       .environ(&quot;HGPLAIN&quot;, &quot;&quot;)
  93                       .workdir(cwd)
  94                       .execute();
  95     }
  96 
  97     private static Execution.Result await(Execution e) throws IOException {
  98         var result = e.await();
  99         if (result.status() != 0) {
 100             if (result.exception().isPresent()) {
 101                 throw new IOException(&quot;Unexpected exit code\n&quot; + result, result.exception().get());
 102             } else {
 103                 throw new IOException(&quot;Unexpected exit code\n&quot; + result);
 104             }
 105         }
 106         return result;
 107     }
 108 
 109     private static void await(java.lang.Process p) throws IOException {
 110         try {
 111             var res = p.waitFor();
 112             if (res != 0) {
 113                 throw new IOException(&quot;Unexpected exit code: &quot; + res);
 114             }
 115         } catch (InterruptedException e) {
 116             throw new IOException(e);
 117         }
 118     }
 119 
 120     public HgRepository(Path dir) {
 121         this.dir = dir.toAbsolutePath();
 122     }
 123 
 124     @Override
 125     public List&lt;Branch&gt; branches() throws IOException {
 126         try (var p = capture(&quot;hg&quot;, &quot;branches&quot;)) {
 127             return await(p).stdout()
 128                            .stream()
 129                            .map(line -&gt; line.split(&quot;\\s&quot;)[0])
 130                            .map(Branch::new)
 131                            .collect(Collectors.toList());
 132         }
 133     }
 134 
 135     @Override
 136     public List&lt;Branch&gt; branches(String remote) throws IOException {
 137         // Mercurial does not have namespacing of branch names
 138         return branches();
 139     }
 140 
 141     @Override
 142     public List&lt;Tag&gt; tags() throws IOException {
 143         try (var p = capture(&quot;hg&quot;, &quot;tags&quot;)) {
 144             return await(p).stdout()
 145                            .stream()
 146                            .map(line -&gt; line.split(&quot;\\s&quot;)[0])
 147                            .map(Tag::new)
 148                            .collect(Collectors.toList());
 149         }
 150     }
 151 
 152     @Override
 153     public Path root() throws IOException {
 154         try (var p = capture(&quot;hg&quot;, &quot;root&quot;)) {
 155             var res = await(p);
 156             if (res.stdout().size() != 1) {
 157                 throw new IOException(&quot;Unexpected output\n&quot; + res);
 158             }
 159             return Paths.get(res.stdout().get(0));
 160         }
 161     }
 162 
 163     private void checkout(String ref, boolean force) throws IOException {
 164         var cmd = new ArrayList&lt;String&gt;();
 165         cmd.addAll(List.of(&quot;hg&quot;, &quot;update&quot;));
 166         if (!force) {
 167             cmd.add(&quot;--check&quot;);
 168         }
 169         cmd.add(ref);
 170         try (var p = capture(cmd)) {
 171             await(p);
 172         }
 173     }
 174 
 175     @Override
 176     public void checkout(Hash h, boolean force) throws IOException {
 177         checkout(h.hex(), force);
 178     }
 179 
 180     @Override
 181     public void checkout(Branch b, boolean force) throws IOException {
 182         checkout(b.name(), force);
 183     }
 184 
 185     @Override
 186     public Optional&lt;Hash&gt; resolve(String ref) throws IOException {
 187         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;--rev=&quot; + ref, &quot;--template={node}\n&quot;)) {
 188             var res = p.await();
 189             if (res.status() == 0 &amp;&amp; res.stdout().size() == 1) {
 190                 return Optional.of(new Hash(res.stdout().get(0)));
 191             }
 192             return Optional.empty();
 193         }
 194     }
 195 
 196     @Override
 197     public Commits commits() throws IOException {
 198         return commits(null, -1, false);
 199     }
 200 
 201     @Override
 202     public Commits commits(boolean reverse) throws IOException {
 203         return commits(null, -1, reverse);
 204     }
 205 
 206     @Override
 207     public Commits commits(int n) throws IOException {
 208         return commits(null, n, false);
 209     }
 210 
 211     @Override
 212     public Commits commits(int n, boolean reverse) throws IOException {
 213         return commits(null, n, reverse);
 214     }
 215 
 216     @Override
 217     public Commits commits(String range) throws IOException {
 218         return commits(range, -1, false);
 219     }
 220 
 221     @Override
 222     public Commits commits(String range, int n) throws IOException {
 223         return commits(range, n, false);
 224     }
 225 
 226     @Override
 227     public Commits commits(String range, boolean reverse) throws IOException {
 228         return commits(range, -1, reverse);
 229     }
 230 
 231     @Override
 232     public Commits commits(String range, int n,  boolean reverse) throws IOException {
 233         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 234         copyResource(EXT_PY, ext);
 235         return new HgCommits(dir, range, ext, reverse, n);
 236     }
 237 
 238     @Override
 239     public Optional&lt;Commit&gt; lookup(Hash h) throws IOException {
 240         var commits = commits(h.hex()).asList();
 241         if (commits.size() != 1) {
 242             return Optional.empty();
 243         }
 244         return Optional.of(commits.get(0));
 245     }
 246 
 247     @Override
 248     public Optional&lt;Commit&gt; lookup(Branch b) throws IOException {
 249         var hash = resolve(b.name()).orElseThrow(() -&gt; new IOException(&quot;Branch &quot; + b.name() + &quot; not found&quot;));
 250         return lookup(hash);
 251     }
 252 
 253     @Override
 254     public Optional&lt;Commit&gt; lookup(Tag t) throws IOException {
 255         var hash = resolve(t.name()).orElseThrow(() -&gt; new IOException(&quot;Tag &quot; + t.name() + &quot; not found&quot;));
 256         return lookup(hash);
 257     }
 258 
 259     @Override
 260     public List&lt;CommitMetadata&gt; commitMetadata(String range, List&lt;Path&gt; paths) throws IOException {
 261         return commitMetadata(range, paths, false);
 262     }
 263 
 264     @Override
 265     public List&lt;CommitMetadata&gt; commitMetadata(Hash from, Hash to, List&lt;Path&gt; paths) throws IOException {
 266         return commitMetadata(from.hex() + &quot;:&quot; + to.hex() + &quot;-&quot; + from.hex(), paths, false);
 267     }
 268 
 269     @Override
 270     public List&lt;CommitMetadata&gt; commitMetadata(Hash from, Hash to, List&lt;Path&gt; paths, boolean reverse) throws IOException {
 271         return commitMetadata(from.hex() + &quot;:&quot; + to.hex() + &quot;-&quot; + from.hex(), paths, reverse);
 272     }
 273 
 274     @Override
 275     public List&lt;CommitMetadata&gt; commitMetadata(String range, List&lt;Path&gt; paths, boolean reverse) throws IOException {
 276         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 277         copyResource(EXT_PY, ext);
 278 
 279         var args = new ArrayList&lt;String&gt;();
 280         args.addAll(List.of(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.dump=&quot; + ext.toAbsolutePath().toString(), &quot;metadata&quot;));
 281         range = range == null ? &quot;tip:0&quot; : range;
 282         var revset = reverse ? &quot;reverse(&quot; + range + &quot;)&quot; : range;
 283         args.add(revset);
 284         if (paths != null &amp;&amp; !paths.isEmpty()) {
 285             args.add(paths.stream().map(Path::toString).collect(Collectors.joining(&quot;\t&quot;)));
 286         }
 287         var p = start(args);
 288         var reader = new UnixStreamReader(p.getInputStream());
 289         var result = new ArrayList&lt;CommitMetadata&gt;();
 290 
 291         var line = reader.readLine();
 292         while (line != null) {
 293             result.add(HgCommitMetadata.read(reader));
 294             line = reader.readLine();
 295         }
 296 
 297         await(p);
 298         return result;
 299     }
 300 
 301     @Override
 302     public List&lt;CommitMetadata&gt; commitMetadata(String range) throws IOException {
 303         return commitMetadata(range, List.of(), false);
 304     }
 305 
 306     @Override
 307     public List&lt;CommitMetadata&gt; commitMetadata(boolean reverse) throws IOException {
 308         return commitMetadata(null, List.of(), reverse);
 309     }
 310 
 311     @Override
 312     public List&lt;CommitMetadata&gt; commitMetadata(Hash from, Hash to) throws IOException {
 313         return commitMetadata(from.hex() + &quot;:&quot; + to.hex() + &quot;-&quot; + from.hex(), List.of(), false);
 314     }
 315 
 316     @Override
 317     public List&lt;CommitMetadata&gt; commitMetadata(String range, boolean reverse) throws IOException {
 318         return commitMetadata(range, List.of(), reverse);
 319     }
 320 
 321     @Override
 322     public List&lt;CommitMetadata&gt; commitMetadata(Hash from, Hash to, boolean reverse) throws IOException {
 323         return commitMetadata(from.hex() + &quot;:&quot; + to.hex() + &quot;-&quot; + from.hex(), reverse);
 324     }
 325 
 326     @Override
 327     public List&lt;CommitMetadata&gt; commitMetadata(List&lt;Path&gt; paths) throws IOException {
 328         return commitMetadata(null, paths, false);
 329     }
 330 
 331     @Override
 332     public List&lt;CommitMetadata&gt; commitMetadata(List&lt;Path&gt; paths, boolean reverse) throws IOException {
 333         return commitMetadata(null, paths, reverse);
 334     }
 335 
 336     @Override
 337     public List&lt;CommitMetadata&gt; commitMetadata() throws IOException {
 338         return commitMetadata(null, List.of(), false);
 339     }
 340 
 341     @Override
 342     public boolean isEmpty() throws IOException {
 343         var numBranches = branches().size();
 344         var numTags = tags().size();
 345 
 346         if (numBranches &gt; 0 || numTags &gt; 1) {
 347             return false;
 348         }
 349 
 350         var tip = resolve(&quot;tip&quot;);
 351         return tip.isEmpty() || tip.get().equals(Hash.zero());
 352     }
 353 
 354     @Override
 355     public boolean isHealthy() throws IOException {
 356         var root = root().toString();
 357         return !(Files.exists(Path.of(root, &quot;.hg&quot;, &quot;wlock&quot;)) ||
 358                  Files.exists(Path.of(root, &quot;.hg&quot;, &quot;store&quot;, &quot;lock&quot;)));
 359     }
 360 
 361     @Override
 362     public void clean() throws IOException {
 363         try (var p = capture(&quot;hg&quot;, &quot;merge&quot;, &quot;--abort&quot;)) {
 364             p.await();
 365         }
 366 
 367         try (var p = capture(&quot;hg&quot;, &quot;recover&quot;)) {
 368             p.await();
 369         }
 370 
 371         try (var p = capture(&quot;hg&quot;, &quot;status&quot;, &quot;--ignored&quot;, &quot;--no-status&quot;)) {
 372             var root = root().toString();
 373             for (var filename : await(p).stdout()) {
 374                 Files.delete(Path.of(root, filename));
 375             }
 376         }
 377 
 378         try (var p = capture(&quot;hg&quot;, &quot;status&quot;, &quot;--unknown&quot;, &quot;--no-status&quot;)) {
 379             var root = root().toString();
 380             for (var filename : await(p).stdout()) {
 381                 Files.delete(Path.of(root, filename));
 382             }
 383         }
 384 
 385         try (var p = capture(&quot;hg&quot;, &quot;revert&quot;, &quot;--no-backup&quot;, &quot;--all&quot;)) {
 386             await(p);
 387         }
 388     }
 389 
 390     @Override
 391     public void reset(Hash target, boolean hard) throws IOException {
 392         throw new RuntimeException(&quot;Not implemented yet&quot;);
 393     }
 394 
 395     @Override
 396     public Repository reinitialize() throws IOException {
 397         Files.walk(dir)
 398              .map(Path::toFile)
 399              .sorted(Comparator.reverseOrder())
 400              .forEach(File::delete);
 401 
 402         return init();
 403     }
 404 
 405     @Override
 406     public Hash fetch(URI uri, String refspec, boolean includeTags) throws IOException {
 407         // Ignore includeTags, Mercurial always fetches tags
 408         return fetch(uri != null ? uri.toString() : null, refspec);
 409     }
 410 
 411     private Hash fetch(String from, String refspec) throws IOException {
 412         var oldHeads = new HashSet&lt;Hash&gt;(heads());
 413 
 414         var cmd = new ArrayList&lt;String&gt;();
 415         cmd.add(&quot;hg&quot;);
 416         cmd.add(&quot;pull&quot;);
 417         if (refspec != null) {
 418             cmd.add(&quot;--rev&quot;);
 419             cmd.add(refspec);
 420         }
 421         if (from != null) {
 422             cmd.add(from);
 423         }
 424         try (var p = capture(cmd)) {
 425             await(p);
 426         }
 427 
 428         var newHeads = new HashSet&lt;Hash&gt;(heads());
 429         newHeads.removeAll(oldHeads);
 430 
 431         if (newHeads.size() &gt; 1) {
 432             throw new IllegalStateException(&quot;fetching multiple heads is not supported&quot;);
 433         } else if (newHeads.size() == 0) {
 434             // no new head was fetched, return current head
 435             return head();
 436         }
 437         return newHeads.iterator().next();
 438     }
 439 
 440     @Override
 441     public void fetchAll(boolean includeTags) throws IOException {
 442         // Ignore includeTags, Mercurial always fetches tags
 443         var pullPaths = new ArrayList&lt;URI&gt;();
 444         try (var p = capture(&quot;hg&quot;, &quot;paths&quot;)) {
 445             var res = await(p);
 446             for (var line : res.stdout()) {
 447                 var parts = line.split(&quot;=&quot;);
 448                 var name = parts[0].trim();
 449                 var uri = parts[1].trim();
 450                 if (!name.endsWith(&quot;-push&quot;)) {
 451                     pullPaths.add(URI.create(uri));
 452                 }
 453             }
 454         }
 455 
 456         for (var uri : pullPaths) {
 457             fetch(uri, null);
 458         }
 459     }
 460 
 461     @Override
 462     public void fetchRemote(String remote) throws IOException {
 463         fetch(remote, null);
 464     }
 465 
 466     @Override
 467     public void delete(Branch b) throws IOException {
 468         throw new RuntimeException(&quot;Branches cannot be deleted in Mercurial&quot;);
 469     }
 470 
 471     @Override
 472     public Repository init() throws IOException {
 473         if (!Files.exists(dir)) {
 474             Files.createDirectories(dir);
 475         }
 476 
 477         try (var p = capture(&quot;hg&quot;, &quot;init&quot;)) {
 478             await(p);
 479             return this;
 480         }
 481     }
 482 
 483     @Override
 484     public void pushAll(URI uri) throws IOException {
 485         try (var p = capture(&quot;hg&quot;, &quot;push&quot;, &quot;--new-branch&quot;, uri.toString())) {
 486             await(p);
 487         }
 488     }
 489 
 490     @Override
 491     public void push(Hash hash, URI uri, String ref, boolean force) throws IOException {
 492         var cmd = new ArrayList&lt;&gt;(List.of(&quot;hg&quot;, &quot;push&quot;, &quot;--rev=&quot; + hash.hex()));
 493         if (force) {
 494             cmd.add(&quot;--force&quot;);
 495         }
 496         cmd.add(uri.toString() + &quot;#&quot; + ref);
 497         try (var p = capture(cmd)) {
 498             await(p);
 499         }
 500     }
 501 
 502     @Override
 503     public void push(Branch branch, String remote, boolean setUpstream) throws IOException {
 504         // ignore setUpstream, no such concept in Mercurial
 505         try (var p = capture(&quot;hg&quot;, &quot;push&quot;, &quot;--branch&quot;, branch.name(), remote)) {
 506             await(p);
 507         }
 508     }
 509 
 510     @Override
 511     public boolean isClean() throws IOException {
 512         try (var p = capture(&quot;hg&quot;, &quot;status&quot;)) {
 513             var output = await(p);
 514             return output.stdout().size() == 0;
 515         }
 516     }
 517 
 518     @Override
 519     public boolean exists() throws IOException {
 520         if (!Files.exists(dir)) {
 521             return false;
 522         }
 523 
 524         try {
 525             root();
 526             return true;
 527         } catch (IOException e) {
 528             return false;
 529         }
 530     }
 531 
 532     private void export(String revset, Path to) throws IOException {
 533         var cmd = List.of(&quot;hg&quot;, &quot;export&quot;, &quot;--git&quot;, &quot;--rev&quot;, revset);
 534         log.fine(&quot;Executing &quot; + String.join(&quot; &quot;, cmd));
 535         var pb = new ProcessBuilder(cmd);
 536         pb.directory(dir.toFile());
 537         pb.redirectError(ProcessBuilder.Redirect.DISCARD);
 538         pb.redirectOutput(to.toFile());
 539         pb.environment().put(&quot;HGRCPATH&quot;, &quot;&quot;);
 540         pb.environment().put(&quot;HGPLAIN&quot;, &quot;&quot;);
 541         var p = pb.start();
 542         try {
 543             await(p);
 544         } catch (Throwable t) {
 545             if (p.isAlive()) {
 546                 try {
 547                     p.waitFor();
 548                 } catch (InterruptedException e) {
 549                     throw new IOException(e);
 550                 }
 551             }
 552 
 553             throw new IOException(t);
 554         }
 555     }
 556 
 557     @Override
 558     public void squash(Hash h) throws IOException {
 559         var revset = &quot;.:&quot; + h.hex() + &quot; and not .&quot;;
 560         var patch = Files.createTempFile(&quot;squash&quot;, &quot;.patch&quot;);
 561         export(revset, patch);
 562 
 563         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.mq=&quot;, &quot;strip&quot;, &quot;--rev&quot;, revset)) {
 564             await(p);
 565         }
 566 
 567         try (var p = capture(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toString())) {
 568             await(p);
 569         }
 570     }
 571 
 572 
 573     @Override
 574     public Hash commit(String message, String authorName, String authorEmail)  throws IOException {
 575         return commit(message, authorName, authorEmail, null);
 576     }
 577 
 578     @Override
 579     public Hash commit(String message, String authorName, String authorEmail, ZonedDateTime authorDate)  throws IOException {
 580         var user = authorEmail == null ? authorName : authorName + &quot; &lt;&quot; + authorEmail + &quot;&gt;&quot;;
 581         var cmd = new ArrayList&lt;String&gt;();
 582         cmd.addAll(List.of(&quot;hg&quot;, &quot;commit&quot;, &quot;--message=&quot; + message, &quot;--user=&quot; + user));
 583         if (authorDate != null) {
 584             var formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
 585             cmd.add(&quot;--date=&quot; + authorDate.format(formatter));
 586         }
 587         try (var p = capture(cmd)) {
 588             await(p);
 589         }
 590         return resolve(&quot;tip&quot;).orElseThrow(() -&gt; new IOException(&quot;Could not resolve &#39;tip&#39;&quot;));
 591     }
 592 
 593     @Override
 594     public Hash commit(String message,
 595                        String authorName,
 596                        String authorEmail,
 597                        String committerName,
 598                        String committerEmail) throws IOException {
 599         return commit(message, authorName, authorEmail, null, committerName, committerEmail, null);
 600     }
 601 
 602     @Override
 603     public Hash commit(String message,
 604                        String authorName,
 605                        String authorEmail,
 606                        ZonedDateTime authorDate,
 607                        String committerName,
 608                        String committerEmail,
 609                        ZonedDateTime committerDate) throws IOException {
 610         if (!Objects.equals(authorName, committerName) ||
 611             !Objects.equals(authorEmail, committerEmail) ||
 612             !Objects.equals(authorDate, committerDate)) {
 613             throw new IllegalArgumentException(&quot;hg does not support different author and committer data&quot;);
 614         }
 615 
 616         return commit(message, authorName, authorEmail, authorDate);
 617     }
 618 
 619     @Override
 620     public Hash commit(String message, String authorName, String authorEmail, ZonedDateTime authorDate, String committerName, String committerEmail, ZonedDateTime committerDate, List&lt;Hash&gt; parents, Tree tree) throws IOException {
 621         throw new RuntimeException(&quot;not implemented yet&quot;);
 622     }
 623 
 624     @Override
 625     public Hash amend(String message) throws IOException {
 626         try (var p = capture(&quot;hg&quot;, &quot;commit&quot;, &quot;--amend&quot;, &quot;--message=&quot; + message)) {
 627             await(p);
 628         }
 629         return resolve(&quot;tip&quot;).orElseThrow(() -&gt; new IOException(&quot;Could not resolve &#39;tip&#39;&quot;));
 630     }
 631 
 632     @Override
 633     public Hash amend(String message, String authorName, String authorEmail) throws IOException {
 634         var user = authorEmail == null ? authorName : authorName + &quot; &lt;&quot; + authorEmail + &quot;&gt;&quot;;
 635         try (var p = capture(&quot;hg&quot;, &quot;commit&quot;, &quot;--amend&quot;, &quot;--message=&quot; + message, &quot;--user=&quot; + user)) {
 636             await(p);
 637         }
 638         return resolve(&quot;tip&quot;).orElseThrow(() -&gt; new IOException(&quot;Could not resolve &#39;tip&#39;&quot;));
 639     }
 640 
 641     @Override
 642     public Hash amend(String message, String authorName, String authorEmail, String committerName, String committerEmail) throws IOException {
 643         if (!Objects.equals(authorName, committerName) ||
 644             !Objects.equals(authorEmail, committerEmail)) {
 645             throw new IllegalArgumentException(&quot;hg does not support different author and committer data&quot;);
 646         }
 647 
 648         return amend(message, authorName, authorEmail);
 649     }
 650 
 651     @Override
 652     public Tag tag(Hash hash, String name, String message, String authorName, String authorEmail) throws IOException {
 653         var user = authorName + &quot; &lt;&quot; + authorEmail + &quot;&gt;&quot;;
 654         try (var p = capture(&quot;hg&quot;, &quot;tag&quot;,
 655                              &quot;--message&quot;, message,
 656                              &quot;--user&quot;, user,
 657                              &quot;--rev&quot;, hash.hex(),
 658                              name)) {
 659             await(p);
 660         }
 661 
 662         return new Tag(name);
 663     }
 664 
 665     @Override
 666     public Branch branch(Hash hash, String name) throws IOException {
 667         // Model a lightweight branch with a bookmark. Not ideal but the
 668         // closest to git branches.
 669         try (var p = capture(&quot;hg&quot;, &quot;bookmark&quot;, &quot;--rev&quot;, hash.hex(), name)) {
 670             await(p);
 671         }
 672 
 673         return new Branch(name);
 674     }
 675 
 676     @Override
 677     public void prune(Branch branch, String remote) throws IOException {
 678         try (var p = capture(&quot;hg&quot;, &quot;bookmark&quot;, &quot;--delete&quot;, branch.name())) {
 679             await(p);
 680         }
 681         try (var p = capture(&quot;hg&quot;, &quot;push&quot;, &quot;--bookmark&quot;, branch.name(), remote)) {
 682             await(p);
 683         }
 684     }
 685 
 686     @Override
 687     public Hash mergeBase(Hash first, Hash second) throws IOException {
 688         var revset = &quot;ancestor(&quot; + first.hex() + &quot;, &quot; + second.hex() + &quot;)&quot;;
 689         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;--rev=&quot; + revset, &quot;--template={node}\n&quot;)) {
 690             var res = await(p);
 691             if (res.stdout().size() != 1) {
 692                 throw new IOException(&quot;Unexpected output\n&quot; + res);
 693             }
 694             return new Hash(res.stdout().get(0));
 695         }
 696     }
 697 
 698     @Override
 699     public boolean isAncestor(Hash ancestor, Hash descendant) throws IOException {
 700         throw new RuntimeException(&quot;Not implemented yet&quot;);
 701     }
 702 
 703     @Override
 704     public void rebase(Hash hash, String committerName, String committerEmail) throws IOException {
 705         var current = currentBranch().orElseThrow(() -&gt;
 706                 new IOException(&quot;No current branch to rebase upon&quot;)
 707         );
 708         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.rebase=&quot;,
 709                              &quot;rebase&quot;, &quot;--dest&quot;, hash.hex(), &quot;--base&quot;, current.name())) {
 710             await(p);
 711         }
 712     }
 713 
 714     @Override
 715     public Optional&lt;Branch&gt; currentBranch() throws IOException {
 716         try (var p = capture(&quot;hg&quot;, &quot;branch&quot;)) {
 717             var res = await(p);
 718             if (res.stdout().size() != 1) {
 719                 return Optional.empty();
 720             }
 721             return Optional.of(new Branch(res.stdout().get(0)));
 722         }
 723     }
 724 
 725     @Override
 726     public Optional&lt;Bookmark&gt; currentBookmark() throws IOException {
 727         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;-r&quot;, &quot;.&quot;, &quot;--template&quot;, &quot;{activebookmark}\n&quot;)) {
 728             var res = await(p);
 729             if (res.stdout().size() == 1) {
 730                 return Optional.of(new Bookmark(res.stdout().get(0)));
 731             }
 732             return Optional.empty();
 733         }
 734     }
 735 
 736     @Override
 737     public Branch defaultBranch() throws IOException {
 738         return new Branch(&quot;default&quot;);
 739     }
 740 
 741     @Override
 742     public Optional&lt;Tag&gt; defaultTag() throws IOException {
 743         return Optional.of(new Tag(&quot;tip&quot;));
 744     }
 745 
 746     @Override
 747     public Optional&lt;byte[]&gt; show(Path path, Hash hash) throws IOException {
 748         var output = Files.createTempFile(&quot;hg-cat-rev-&quot; + hash.abbreviate(), &quot;.bin&quot;);
 749         try (var p = capture(&quot;hg&quot;, &quot;cat&quot;, &quot;--output=&quot; + output, &quot;--rev=&quot; + hash.hex(), path.toString())) {
 750             var res = p.await();
 751             if (res.status() == 0 &amp;&amp; Files.exists(output)) {
 752                 var bytes = Files.readAllBytes(output);
 753                 Files.delete(output);
 754                 return Optional.of(bytes);
 755             }
 756 
 757             if (Files.exists(output)) {
 758                 Files.delete(output);
 759             }
 760             return Optional.empty();
 761         }
 762     }
 763 
 764     private List&lt;FileEntry&gt; allFiles(Hash hash, List&lt;Path&gt; paths) throws IOException {
 765         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 766         copyResource(EXT_PY, ext);
 767 
 768         var include = new HashSet&lt;&gt;(paths);
 769 
 770         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.ls-tree=&quot; + ext, &quot;ls-tree&quot;, hash.hex())) {
 771             var res = await(p);
 772             var entries = new ArrayList&lt;FileEntry&gt;();
 773             for (var line : res.stdout()) {
 774                 var parts = line.split(&quot;\t&quot;);
 775                 var metadata = parts[0].split(&quot; &quot;);
 776                 var path = Path.of(parts[1]);
 777                 if (include.isEmpty() || include.contains(path)) {
 778                     var entry = new FileEntry(hash,
 779                                               FileType.fromOctal(metadata[0]),
 780                                               new Hash(metadata[2]),
 781                                               path);
 782                     entries.add(entry);
 783                 }
 784             }
 785             return entries;
 786         }
 787     }
 788 
 789     @Override
 790     public List&lt;FileEntry&gt; files(Hash hash, List&lt;Path&gt; paths) throws IOException {
 791         if (paths.isEmpty()) {
 792             return allFiles(hash, paths);
 793         }
 794 
 795         var entries = new ArrayList&lt;FileEntry&gt;();
 796         var batchSize = 64;
 797         var start = 0;
 798         while (start &lt; paths.size()) {
 799             var end = start + batchSize;
 800             if (end &gt; paths.size()) {
 801                 end = paths.size();
 802             }
 803             entries.addAll(allFiles(hash, paths.subList(start, end)));
 804             start = end;
 805         }
 806         return entries;
 807     }
 808 
 809     @Override
 810     public List&lt;StatusEntry&gt; status(Hash from, Hash to) throws IOException {
 811         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 812         copyResource(EXT_PY, ext);
 813 
 814         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.diff-git-raw=&quot; + ext.toAbsolutePath().toString(),
 815                                                &quot;diff-git-raw&quot;, from.hex(), to.hex())) {
 816             var res = await(p);
 817             var entries = new ArrayList&lt;StatusEntry&gt;();
 818             for (var line : res.stdout()) {
 819                 entries.add(StatusEntry.fromRawLine(line));
 820             }
 821             return entries;
 822         }
 823     }
 824 
 825     @Override
 826     public List&lt;StatusEntry&gt; status() throws IOException {
 827         // TODO: can use merge.mergestate.read(repo) to implement diff-git-raw-workspace
 828         throw new RuntimeException(&quot;Not implemented yet&quot;);
 829     }
 830 
 831     @Override
 832     public void dump(FileEntry entry, Path to) throws IOException {
 833         var output = to.toAbsolutePath();
 834         try (var p = capture(&quot;hg&quot;, &quot;cat&quot;, &quot;--output=&quot; + output.toString(),
 835                                           &quot;--rev=&quot; + entry.commit(),
 836                                           entry.path().toString())) {
 837             await(p);
 838         }
 839     }
 840 
 841     @Override
 842     public void revert(Hash parent) throws IOException {
 843         try (var p = capture(&quot;hg&quot;, &quot;revert&quot;, &quot;--no-backup&quot;, &quot;--all&quot;, &quot;--rev&quot;, parent.hex())) {
 844             await(p);
 845         }
 846     }
 847 
 848     @Override
<a name="1" id="anc1"></a><span class="line-modified"> 849     public Diff diff(Hash from) throws IOException {</span>
 850         return diff(from, List.of());
 851     }
 852 
 853     @Override
<a name="2" id="anc2"></a><span class="line-modified"> 854     public Diff diff(Hash from, List&lt;Path&gt; files) throws IOException {</span>
 855         return diff(from, null, files);
 856     }
 857 
 858     @Override
<a name="3" id="anc3"></a><span class="line-modified"> 859     public Diff diff(Hash from, Hash to) throws IOException {</span>
 860         return diff(from, to, List.of());
 861     }
 862 
 863     @Override
<a name="4" id="anc4"></a><span class="line-modified"> 864     public Diff diff(Hash from, Hash to, List&lt;Path&gt; files) throws IOException {</span>
 865         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 866         copyResource(EXT_PY, ext);
 867 
 868         var cmd = new ArrayList&lt;&gt;(List.of(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.diff-git-raw=&quot; + ext.toAbsolutePath(),
 869                                                 &quot;diff-git-raw&quot;, &quot;--patch&quot;, from.hex()));
 870         if (to != null) {
 871             cmd.add(to.hex());
 872         }
 873 
 874         if (files != null) {
 875             var filenames = files.stream().map(Path::toString).collect(Collectors.toList());
 876             cmd.add(&quot;--files=&quot; + String.join(&quot;,&quot;, filenames));
 877         }
 878 
 879         var p = start(cmd);
 880         try {
 881             var patches = UnifiedDiffParser.parseGitRaw(p.getInputStream());
 882             await(p);
 883             return new Diff(from, to, patches);
 884         } catch (Throwable t) {
 885             throw new IOException(t);
 886         }
 887     }
 888 
 889     @Override
 890     public Optional&lt;String&gt; username() throws IOException {
 891         var lines = config(&quot;ui.username&quot;);
 892         return lines.size() == 1 ? Optional.of(lines.get(0)) : Optional.empty();
 893     }
 894 
 895     @Override
 896     public Hash head() throws IOException {
 897         return resolve(&quot;.&quot;).orElseThrow(() -&gt; new IOException(&quot;. not available&quot;));
 898     }
 899 
 900     private List&lt;Hash&gt; heads() throws IOException {
 901         var heads = new ArrayList&lt;Hash&gt;();
 902         try (var p = capture(&quot;hg&quot;, &quot;heads&quot;, &quot;--template={node}\n&quot;)) {
 903             var res = p.await();
 904             if (res.status() == 0) {
 905                 for (var hash : res.stdout()) {
 906                     heads.add(new Hash(hash));
 907                 }
 908             }
 909         }
 910         return heads;
 911     }
 912 
 913     @Override
 914     public List&lt;String&gt; config(String key) throws IOException {
 915         // Do not use HgRepository.capture() here, want to run *with*
 916         // hg configuration.
 917         try (var p = Process.capture(&quot;hg&quot;, &quot;showconfig&quot;, key)
 918                             .workdir(dir)
 919                             .execute()) {
 920             var res = p.await();
 921             if (res.status() == 1) {
 922                 return List.of();
 923             }
 924             return res.stdout();
 925         }
 926     }
 927 
 928     public static Optional&lt;Repository&gt; get(Path p) throws IOException {
 929         if (!Files.exists(p)) {
 930             return Optional.empty();
 931         }
 932 
 933         var r = new HgRepository(p);
 934         return r.exists() ? Optional.of(new HgRepository(r.root())) : Optional.empty();
 935     }
 936 
 937     @Override
 938     public Repository copyTo(Path destination) throws IOException {
 939         var from = root().toAbsolutePath().toString();
 940         var to = destination.toAbsolutePath().toString();
 941         try (var p = capture(&quot;hg&quot;, &quot;clone&quot;, from, to)) {
 942             await(p);
 943         }
 944 
 945         return new HgRepository(destination.toAbsolutePath());
 946     }
 947 
 948     @Override
 949     public void merge(Hash h) throws IOException {
 950         merge(h.hex(), null);
 951     }
 952 
 953     @Override
 954     public void merge(Branch b) throws IOException {
 955         merge(b.name(), null);
 956     }
 957 
 958     @Override
 959     public void merge(Hash h, String strategy) throws IOException {
 960         merge(h.hex(), strategy);
 961     }
 962 
 963     private void merge(String ref, String strategy) throws IOException {
 964         var cmd = new ArrayList&lt;String&gt;();
 965         cmd.addAll(List.of(&quot;hg&quot;, &quot;merge&quot;, &quot;--rev=&quot; + ref));
 966         if (strategy != null) {
 967             cmd.add(&quot;--tool=&quot; + strategy);
 968         }
 969         try (var p = capture(cmd)) {
 970             await(p);
 971         }
 972     }
 973 
 974     @Override
 975     public void abortMerge() throws IOException {
 976         try (var p = capture(&quot;hg&quot;, &quot;merge&quot;, &quot;--abort&quot;)) {
 977             await(p);
 978         }
 979 
 980         try (var p = capture(&quot;hg&quot;, &quot;status&quot;, &quot;--unknown&quot;, &quot;--no-status&quot;)) {
 981             var res = await(p);
 982             for (var path : res.stdout()) {
 983                 if (path.toString().endsWith(&quot;.orig&quot;)) {
 984                     Files.delete(root().resolve(path));
 985                 }
 986             }
 987         }
 988     }
 989 
 990     @Override
 991     public void addRemote(String name, String path) throws IOException {
 992         setPaths(name, path, path);
 993     }
 994 
 995     @Override
 996     public void setPaths(String remote, String pullPath, String pushPath) throws IOException {
 997         var hgrc = Path.of(root().toString(), &quot;.hg&quot;, &quot;hgrc&quot;);
 998         if (!Files.exists(hgrc)) {
 999             Files.createFile(hgrc);
1000         }
1001 
1002         var lines = Files.readAllLines(hgrc);
1003         var newLines = new ArrayList&lt;String&gt;();
1004 
1005         var isInPathsSection = false;
1006         var hasPathsSection = false;
1007         for (var line : lines) {
1008             var isSectionHeader = line.startsWith(&quot;[&quot;) &amp;&amp; line.endsWith(&quot;]&quot;);
1009             if (isSectionHeader &amp;&amp; !isInPathsSection) {
1010                 isInPathsSection = line.equals(&quot;[paths]&quot;);
1011                 if (isInPathsSection) {
1012                     newLines.add(line);
1013                     newLines.add(remote + &quot; = &quot; + (pullPath == null ? &quot;&quot; : pullPath));
1014                     newLines.add(remote + &quot;-push = &quot; + (pushPath == null ? &quot;&quot; : pushPath));
1015                     hasPathsSection = true;
1016                     continue;
1017                 }
1018             }
1019 
1020             if (isInPathsSection &amp;&amp; line.startsWith(remote)) {
1021                 if (line.startsWith(remote + &quot;-push&quot;)) {
1022                     // skip
1023                 } else if (line.startsWith(remote + &quot;:pushurl&quot;)) {
1024                     // skip
1025                 } else if (line.startsWith(remote + &quot; &quot;) || line.startsWith(remote + &quot;=&quot;)) {
1026                     // skip
1027                 } else {
1028                     newLines.add(line);
1029                 }
1030             } else {
1031                 newLines.add(line);
1032             }
1033         }
1034 
1035         Files.write(hgrc, newLines, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);
1036         if (!hasPathsSection) {
1037             var section = List.of(&quot;[paths]&quot;,
1038                                   remote + &quot; = &quot; + (pullPath == null ? &quot;&quot; : pullPath),
1039                                   remote + &quot;-push = &quot; + (pushPath == null ? &quot;&quot; : pushPath));
1040             Files.write(hgrc, section, StandardOpenOption.WRITE, StandardOpenOption.APPEND);
1041         }
1042     }
1043 
1044     @Override
1045     public String pullPath(String remote) throws IOException {
1046         var lines = config(&quot;paths.&quot; + remote);
1047         if (lines.size() != 1) {
1048             throw new IOException(&quot;Pull path not found for remote: &quot; + remote);
1049         }
1050         return lines.get(0);
1051     }
1052 
1053     @Override
1054     public String pushPath(String remote) throws IOException {
1055         var lines = config(&quot;paths.&quot; + remote + &quot;-push&quot;);
1056         if (lines.size() != 1) {
1057             lines = config(&quot;paths.&quot; + remote + &quot;@push&quot;);
1058         }
1059         if (lines.size() != 1) {
1060             return pullPath(remote);
1061         }
1062         return lines.get(0);
1063     }
1064 
1065     @Override
1066     public boolean isValidRevisionRange(String expression) throws IOException {
1067         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;--template&quot;, &quot; &quot;, &quot;--rev&quot;, expression)) {
1068             return p.await().status() == 0;
1069         }
1070     }
1071 
1072     private void setPermissions(Patch.Info target) throws IOException {
1073         if (target.path().isPresent() &amp;&amp; target.type().isPresent()) {
1074             var perms = target.type().get().permissions();
1075             if (perms.isPresent()) {
1076                 Files.setPosixFilePermissions(target.path().get(), perms.get());
1077             }
1078         }
1079     }
1080 
1081     @Override
1082     public void apply(Diff diff, boolean force) throws IOException {
1083         var patchFile = Files.createTempFile(&quot;import&quot;, &quot;.patch&quot;);
1084         diff.toFile(patchFile);
1085         apply(patchFile, force);
1086         Files.delete(patchFile);
1087     }
1088 
1089     @Override
1090     public void apply(Path patchFile, boolean force) throws IOException {
1091         var cmd = new ArrayList&lt;String&gt;();
1092         cmd.addAll(List.of(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;));
1093         if (force) {
1094             cmd.add(&quot;--force&quot;);
1095         }
1096         cmd.add(patchFile.toAbsolutePath().toString());
1097         try (var p = capture(cmd)) {
1098             await(p);
1099         }
1100     }
1101 
1102     @Override
1103     public void copy(Path from, Path to) throws IOException {
1104         try (var p = capture(&quot;hg&quot;, &quot;copy&quot;, from.toString(), to.toString())) {
1105             await(p);
1106         }
1107     }
1108 
1109     @Override
1110     public void move(Path from, Path to) throws IOException {
1111         try (var p = capture(&quot;hg&quot;, &quot;move&quot;, from.toString(), to.toString())) {
1112             await(p);
1113         }
1114     }
1115 
1116     @FunctionalInterface
1117     private static interface Operation {
1118         void execute(List&lt;Path&gt; args) throws IOException;
1119     }
1120 
1121     private void batch(Operation op, List&lt;Path&gt; args) throws IOException {
1122         var batchSize = 64;
1123         var start = 0;
1124         while (start &lt; args.size()) {
1125             var end = start + batchSize;
1126             if (end &gt; args.size()) {
1127                 end = args.size();
1128             }
1129             op.execute(args.subList(start, end));
1130             start = end;
1131         }
1132     }
1133 
1134     private void addAll(List&lt;Path&gt; paths) throws IOException {
1135         var cmd = new ArrayList&lt;&gt;(List.of(&quot;hg&quot;, &quot;add&quot;));
1136         for (var path : paths) {
1137             cmd.add(path.toString());
1138         }
1139         try (var p = capture(cmd)) {
1140             await(p);
1141         }
1142     }
1143 
1144     private void removeAll(List&lt;Path&gt; paths) throws IOException {
1145         var cmd = new ArrayList&lt;&gt;(List.of(&quot;hg&quot;, &quot;rm&quot;));
1146         for (var path : paths) {
1147             cmd.add(path.toString());
1148         }
1149         try (var p = capture(cmd)) {
1150             await(p);
1151         }
1152     }
1153 
1154 
1155     @Override
1156     public void remove(List&lt;Path&gt; paths) throws IOException {
1157         batch(this::removeAll, paths);
1158     }
1159 
1160     @Override
1161     public void add(List&lt;Path&gt; paths) throws IOException {
1162         batch(this::addAll, paths);
1163     }
1164 
1165     @Override
1166     public void addremove() throws IOException {
1167         try (var p = capture(&quot;hg&quot;, &quot;addremove&quot;)) {
1168             await(p);
1169         }
1170     }
1171 
1172     @Override
1173     public Optional&lt;String&gt; upstreamFor(Branch b) throws IOException {
1174         // Mercurial doesn&#39;t have the concept of remotes like git,
1175         // a local branch must have the same name (if present) on the remote
1176         return Optional.of(b.name());
1177     }
1178 
1179     public static Repository clone(URI from, Path to, boolean isBare, Path seed) throws IOException {
1180         var cmd = new ArrayList&lt;String&gt;();
1181         cmd.addAll(List.of(&quot;hg&quot;, &quot;clone&quot;));
1182         if (isBare) {
1183             cmd.add(&quot;--noupdate&quot;);
1184         }
1185         cmd.addAll(List.of(from.toString(), to.toString()));
1186 
1187         try (var p = capture(Path.of(&quot;&quot;).toAbsolutePath(), cmd)) {
1188             await(p);
1189         }
1190         return new HgRepository(to);
1191     }
1192 
1193     @Override
1194     public void pull() throws IOException {
1195         pull(null, null);
1196     }
1197 
1198     @Override
1199     public void pull(String remote) throws IOException {
1200         pull(remote, null);
1201     }
1202 
1203     @Override
1204     public void pull(String remote, String refspec) throws IOException {
1205         var cmd = new ArrayList&lt;String&gt;();
1206         cmd.addAll(List.of(&quot;hg&quot;, &quot;pull&quot;, &quot;--update&quot;));
1207         if (refspec != null) {
1208             cmd.add(&quot;--branch&quot;);
1209             cmd.add(refspec);
1210         }
1211         if (remote != null) {
1212             cmd.add(remote);
1213         }
1214         try (var p = capture(cmd)) {
1215             await(p);
1216         }
1217     }
1218 
1219     @Override
1220     public boolean contains(Branch b, Hash h) throws IOException {
1221         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;--template&quot;, &quot;{branch}&quot;, &quot;-r&quot;, h.hex())) {
1222             var res = await(p);
1223             if (res.stdout().size() != 1) {
1224                 throw new IOException(&quot;Unexpected output: &quot; + String.join(&quot;\n&quot;, res.stdout()));
1225             }
1226             var line = res.stdout().get(0);
1227             return line.equals(b.name());
1228         }
1229     }
1230 
1231     @Override
1232     public List&lt;Reference&gt; remoteBranches(String remote) throws IOException {
1233         var refs = new ArrayList&lt;Reference&gt;();
1234 
1235         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
1236         copyResource(EXT_PY, ext);
1237 
1238         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.ls-remote=&quot; + ext, &quot;ls-remote&quot;, remote)) {
1239             var res = await(p);
1240             for (var line : res.stdout()) {
1241                 var parts = line.split(&quot;\t&quot;);
1242                 refs.add(new Reference(parts[1], new Hash(parts[0])));
1243             }
1244         }
1245         return refs;
1246     }
1247 
1248     @Override
1249     public List&lt;String&gt; remotes() throws IOException {
1250         var remotes = new ArrayList&lt;String&gt;();
1251         try (var p = capture(&quot;hg&quot;, &quot;paths&quot;)) {
1252             for (var line : await(p).stdout()) {
1253                 var parts = line.split(&quot; = &quot;);
1254                 var name = parts[0];
1255                 if (name.endsWith(&quot;-push&quot;) || name.endsWith(&quot;:push&quot;)) {
1256                     continue;
1257                 } else {
1258                     remotes.add(name);
1259                 }
1260             }
1261         }
1262         return remotes;
1263     }
1264 
1265     @Override
1266     public void addSubmodule(String pullPath, Path path) throws IOException {
1267         var uri = Files.exists(Path.of(pullPath)) ? Path.of(pullPath).toUri().toString() : pullPath;
1268         HgRepository.clone(URI.create(uri), root().resolve(path).toAbsolutePath(), false, null);
1269         var hgSub = root().resolve(&quot;.hgsub&quot;);
1270         Files.writeString(hgSub, path.toString() + &quot; = &quot; + pullPath + &quot;\n&quot;,
1271                           StandardOpenOption.WRITE, StandardOpenOption.APPEND, StandardOpenOption.CREATE);
1272         add(List.of(hgSub));
1273     }
1274 
1275     @Override
1276     public void updateSubmodule(Path path) throws IOException {
1277         checkout(&quot;.&quot;, false);
1278     }
1279 
1280     @Override
1281     public List&lt;Submodule&gt; submodules() throws IOException {
1282         var hgSub = root().resolve(&quot;.hgsub&quot;);
1283         var hgSubState = root().resolve(&quot;.hgsubstate&quot;);
1284         if (!(Files.exists(hgSub) &amp;&amp; Files.exists(hgSubState))) {
1285             return List.of();
1286         }
1287 
1288         var urls = new HashMap&lt;String, String&gt;();
1289         for (var line : Files.readAllLines(hgSub)) {
1290             var parts = line.split(&quot;=&quot;);
1291             var path = parts[0].trim();
1292             var url = parts[1].trim();
1293             urls.put(path, url);
1294         }
1295 
1296         var hashes = new HashMap&lt;String, String&gt;();
1297         for (var line : Files.readAllLines(hgSubState)) {
1298             var parts = line.split(&quot; &quot;);
1299             var hash = parts[0];
1300             var path = parts[1];
1301             hashes.put(path, hash);
1302         }
1303 
1304         var modules = new ArrayList&lt;Submodule&gt;();
1305         for (var path : urls.keySet()) {
1306             var url = urls.get(path);
1307             var hash = hashes.get(path);
1308             modules.add(new Submodule(new Hash(hash), Path.of(path), url));
1309         }
1310 
1311         return modules;
1312     }
1313 
1314     @Override
1315     public Tree tree(Hash h) throws IOException {
1316         throw new RuntimeException(&quot;not implemented yet&quot;);
1317     }
1318 
1319     @Override
1320     public Optional&lt;Tag.Annotated&gt; annotate(Tag tag) throws IOException {
1321         var hgtags = root().resolve(&quot;.hgtags&quot;);
1322         if (!Files.exists(hgtags)) {
1323             return Optional.empty();
1324         }
1325         try (var p = capture(&quot;hg&quot;, &quot;annotate&quot;, hgtags.toString())) {
1326             var reversed = new ArrayList&lt;&gt;(await(p).stdout());
1327             Collections.reverse(reversed);
1328             for (var line : reversed) {
1329                 var parts = line.split(&quot; &quot;);
1330                 var tagName = parts[2];
1331                 if (tagName.equals(tag.name())) {
1332                     var target = new Hash(parts[1]);
1333                     var rev = parts[0].substring(0, parts[0].length() - 1).trim(); // skip last &#39;:&#39; and ev. whitespace
1334                     var hash = resolve(rev).orElseThrow(IOException::new);
1335                     var commit = lookup(hash).orElseThrow(IOException::new);
1336                     var message = String.join(&quot;\n&quot;, commit.message()) + &quot;\n&quot;;
1337                     return Optional.of(new Tag.Annotated(tagName, target, commit.author(), commit.authored(), message));
1338                 }
1339             }
1340         }
1341         return Optional.empty();
1342     }
1343 
1344     @Override
1345     public void config(String section, String key, String value, boolean global) throws IOException {
1346         var hgrc = global ?
1347             Path.of(System.getProperty(&quot;user.home&quot;), &quot;.hgrc&quot;) :
1348             root().resolve(&quot;.hg&quot;).resolve(&quot;hgrc&quot;);
1349 
1350         var lines = List.of(
1351             &quot;[&quot; + section + &quot;]&quot;,
1352             key + &quot; = &quot; + value
1353         );
1354         if (!Files.exists(hgrc)) {
1355             Files.createFile(hgrc);
1356         }
1357         Files.write(hgrc, lines, StandardOpenOption.WRITE, StandardOpenOption.APPEND);
1358     }
1359 
1360     @Override
1361     public String range(Hash h) {
1362         return h.hex();
1363     }
1364 
1365     @Override
1366     public String rangeInclusive(Hash from, Hash to) {
1367         return from.hex() + &quot;:&quot; + to.hex();
1368     }
1369 
1370     @Override
1371     public String rangeExclusive(Hash from, Hash to) {
1372         return from.hex() + &quot;:&quot; + to.hex() + &quot;-&quot; + from.hex();
1373     }
1374 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>