<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames vcs/src/main/java/org/openjdk/skara/vcs/git/GitRepository.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.skara.vcs.git;
  24 
  25 import org.openjdk.skara.process.*;
  26 import org.openjdk.skara.process.Process;
  27 import org.openjdk.skara.vcs.*;
  28 import org.openjdk.skara.vcs.tools.*;
  29 
  30 import java.io.*;
  31 import java.net.URI;
  32 import java.nio.file.*;
  33 import java.nio.charset.StandardCharsets;
  34 import java.time.*;
  35 import java.time.format.DateTimeFormatter;
  36 import java.util.*;
  37 import java.util.logging.Logger;
  38 import java.util.stream.Collectors;
  39 
  40 public class GitRepository implements Repository {
  41     private final Path dir;
  42     private final Logger log = Logger.getLogger(&quot;org.openjdk.skara.vcs.git&quot;);
  43     private Path cachedRoot = null;
  44 
  45     private java.lang.Process start(String... cmd) throws IOException {
  46         return start(Arrays.asList(cmd));
  47     }
  48 
  49     private java.lang.Process start(List&lt;String&gt; cmd) throws IOException {
  50         log.fine(&quot;Executing &quot; + String.join(&quot; &quot;, cmd));
  51         var pb = new ProcessBuilder(cmd);
  52         pb.directory(dir.toFile());
  53         pb.redirectError(ProcessBuilder.Redirect.DISCARD);
  54         return pb.start();
  55     }
  56 
  57     private static void stop(java.lang.Process p) throws IOException {
  58         if (p != null &amp;&amp; p.isAlive()) {
  59             var stream = p.getInputStream();
  60             var read = 0;
  61             var buf = new byte[128];
  62             while (read != -1) {
  63                 read = stream.read(buf);
  64             }
  65             try {
  66                 p.waitFor();
  67             } catch (InterruptedException e) {
  68                 throw new IOException(e);
  69             }
  70         }
  71     }
  72 
  73     private Execution capture(List&lt;String&gt; cmd) {
  74         return capture(cmd.toArray(new String[0]));
  75     }
  76 
  77     private Execution capture(String... cmd) {
  78         return capture(dir, cmd);
  79     }
  80 
  81     private static Execution capture(Path cwd, String... cmd) {
  82         return Process.capture(cmd)
  83                       .workdir(cwd)
  84                       .execute();
  85     }
  86 
  87     private static Execution capture(Path cwd, List&lt;String&gt; cmd) {
  88         return capture(cwd, cmd.toArray(new String[0]));
  89     }
  90 
  91     private static Execution.Result await(Execution e) throws IOException {
  92         var result = e.await();
  93         if (result.status() != 0) {
  94             throw new IOException(&quot;Unexpected exit code\n&quot; + result);
  95         }
  96         return result;
  97     }
  98 
  99     private static void await(java.lang.Process p) throws IOException {
 100         try {
 101             var res = p.waitFor();
 102             if (res != 0) {
 103                 throw new IOException(&quot;Unexpected exit code: &quot; + res);
 104             }
 105         } catch (InterruptedException e) {
 106             throw new IOException(e);
 107         }
 108     }
 109 
 110     public GitRepository(Path dir) {
 111         this.dir = dir.toAbsolutePath();
 112     }
 113 
 114     public List&lt;Branch&gt; branches() throws IOException {
 115         try (var p = capture(&quot;git&quot;, &quot;for-each-ref&quot;, &quot;--format=%(refname:short)&quot;, &quot;refs/heads&quot;)) {
 116             return await(p).stdout()
 117                            .stream()
 118                            .map(Branch::new)
 119                            .collect(Collectors.toList());
 120         }
 121     }
 122 
 123     public List&lt;Branch&gt; branches(String remote) throws IOException {
 124         try (var p = capture(&quot;git&quot;, &quot;for-each-ref&quot;, &quot;--format=%(refname:short)&quot;, &quot;refs/remotes/&quot; + remote + &quot;/&quot;)) {
 125             return await(p).stdout()
 126                            .stream()
 127                            .map(Branch::new)
 128                            .collect(Collectors.toList());
 129         }
 130     }
 131 
 132     public List&lt;Tag&gt; tags() throws IOException {
 133         try (var p = capture(&quot;git&quot;, &quot;for-each-ref&quot;, &quot;--format=%(refname:short)&quot;, &quot;refs/tags&quot;)) {
 134             return await(p).stdout()
 135                            .stream()
 136                            .map(Tag::new)
 137                            .collect(Collectors.toList());
 138         }
 139     }
 140 
 141     @Override
 142     public Commits commits() throws IOException {
 143         return new GitCommits(dir, &quot;--all&quot;, false, -1);
 144     }
 145 
 146     @Override
 147     public Commits commits(int n) throws IOException {
 148         return new GitCommits(dir, &quot;--all&quot;, false, n);
 149     }
 150 
 151     @Override
 152     public Commits commits(boolean reverse) throws IOException {
 153         return new GitCommits(dir, &quot;--all&quot;, reverse, -1);
 154     }
 155 
 156     @Override
 157     public Commits commits(int n, boolean reverse) throws IOException {
 158         return new GitCommits(dir, &quot;--all&quot;, reverse, n);
 159     }
 160 
 161     @Override
 162     public Commits commits(String range) throws IOException {
 163         return new GitCommits(dir, range, false, -1);
 164     }
 165 
 166     @Override
 167     public Commits commits(String range, int n) throws IOException {
 168         return new GitCommits(dir, range, false, n);
 169     }
 170 
 171     @Override
 172     public Commits commits(String range, boolean reverse) throws IOException {
 173         return new GitCommits(dir, range, reverse, -1);
 174     }
 175 
 176     @Override
 177     public Commits commits(String range, int n, boolean reverse) throws IOException {
 178         return new GitCommits(dir, range, reverse, n);
 179     }
 180 
 181     @Override
 182     public Optional&lt;Commit&gt; lookup(Hash h) throws IOException {
 183         var commits = commits(h.hex(), 1).asList();
 184         if (commits.size() != 1) {
 185             return Optional.empty();
 186         }
 187         return Optional.of(commits.get(0));
 188     }
 189 
 190     @Override
 191     public Optional&lt;Commit&gt; lookup(Branch b) throws IOException {
 192         var hash = resolve(b.name()).orElseThrow(() -&gt; new IOException(&quot;Branch &quot; + b.name() + &quot; not found&quot;));
 193         return lookup(hash);
 194     }
 195 
 196     @Override
 197     public Optional&lt;Commit&gt; lookup(Tag t) throws IOException {
 198         var hash = resolve(t.name()).orElseThrow(() -&gt; new IOException(&quot;Tag &quot; + t.name() + &quot; not found&quot;));
 199         return lookup(hash);
 200     }
 201 
 202     @Override
 203     public List&lt;CommitMetadata&gt; commitMetadata(String range, List&lt;Path&gt; paths, boolean reverse) throws IOException {
 204         var args = new ArrayList&lt;String&gt;();
 205         args.addAll(List.of(&quot;git&quot;, &quot;rev-list&quot;,
 206                                    &quot;--format=&quot; + GitCommitMetadata.FORMAT,
 207                                    &quot;--no-abbrev&quot;,
 208                                    &quot;--no-color&quot;,
 209                                    range));
 210         if (reverse) {
 211             args.add(&quot;--reverse&quot;);
 212         }
 213         if (paths != null &amp;&amp; !paths.isEmpty()) {
 214             args.add(&quot;--&quot;);
 215             for (var path : paths) {
 216                 args.add(path.toString());
 217             }
 218         }
 219         var p = start(args);
 220         var reader = new UnixStreamReader(p.getInputStream());
 221         var result = new ArrayList&lt;CommitMetadata&gt;();
 222 
 223         var line = reader.readLine();
 224         while (line != null) {
 225             if (!line.startsWith(&quot;commit&quot;)) {
 226                 throw new IOException(&quot;Unexpected line: &quot; + line);
 227             }
 228 
 229             result.add(GitCommitMetadata.read(reader));
 230             line = reader.readLine();
 231         }
 232 
 233         await(p);
 234         return result;
 235     }
 236 
 237     @Override
 238     public List&lt;CommitMetadata&gt; commitMetadata(Hash from, Hash to, List&lt;Path&gt; paths, boolean reverse) throws IOException {
 239         return commitMetadata(from.hex() + &quot;..&quot; + to.hex(), paths, reverse);
 240     }
 241 
 242     @Override
 243     public List&lt;CommitMetadata&gt; commitMetadata(String range, List&lt;Path&gt; paths) throws IOException {
 244         return commitMetadata(range, paths, false);
 245     }
 246 
 247     @Override
 248     public List&lt;CommitMetadata&gt; commitMetadata(Hash from, Hash to, List&lt;Path&gt; paths) throws IOException {
 249         return commitMetadata(from.hex() + &quot;..&quot; + to.hex(), paths, false);
 250     }
 251 
 252     @Override
 253     public List&lt;CommitMetadata&gt; commitMetadata(boolean reverse) throws IOException {
 254         return commitMetadata(&quot;--all&quot;, List.of(), reverse);
 255     }
 256 
 257     @Override
 258     public List&lt;CommitMetadata&gt; commitMetadata(String range) throws IOException {
 259         return commitMetadata(range, List.of(), false);
 260     }
 261 
 262     @Override
 263     public List&lt;CommitMetadata&gt; commitMetadata(Hash from, Hash to) throws IOException {
 264         return commitMetadata(from.hex() + &quot;..&quot; + to.hex(), List.of(), false);
 265     }
 266 
 267     @Override
 268     public List&lt;CommitMetadata&gt; commitMetadata(String range, boolean reverse) throws IOException {
 269         return commitMetadata(range, List.of(), reverse);
 270     }
 271 
 272     @Override
 273     public List&lt;CommitMetadata&gt; commitMetadata(Hash from, Hash to, boolean reverse) throws IOException {
 274         return commitMetadata(from.hex() + &quot;..&quot; + to.hex(), List.of(), reverse);
 275     }
 276 
 277     @Override
 278     public List&lt;CommitMetadata&gt; commitMetadata(List&lt;Path&gt; paths) throws IOException {
 279         return commitMetadata(&quot;--all&quot;, paths, false);
 280     }
 281 
 282     @Override
 283     public List&lt;CommitMetadata&gt; commitMetadata(List&lt;Path&gt; paths, boolean reverse) throws IOException {
 284         return commitMetadata(&quot;--all&quot;, paths, reverse);
 285     }
 286 
 287     @Override
 288     public List&lt;CommitMetadata&gt; commitMetadata() throws IOException {
 289         return commitMetadata(&quot;--all&quot;);
 290     }
 291 
 292     private List&lt;Hash&gt; refs() throws IOException {
 293         try (var p = capture(&quot;git&quot;, &quot;show-ref&quot;, &quot;--hash&quot;, &quot;--abbrev&quot;)) {
 294             var res = p.await();
 295             if (res.status() == -1) {
 296                 if (res.stdout().size() != 0) {
 297                     throw new IOException(&quot;Unexpected output\n&quot; + res);
 298                 }
 299                 return new ArrayList&lt;&gt;();
 300             } else {
 301                 return res.stdout().stream()
 302                           .map(Hash::new)
 303                           .collect(Collectors.toList());
 304             }
 305         }
 306     }
 307 
 308     @Override
 309     public boolean isEmpty() throws IOException {
 310         int numLooseObjects = -1;
 311         int numPackedObjects = -1;
 312 
 313         try (var p = capture(&quot;git&quot;, &quot;count-objects&quot;, &quot;-v&quot;)) {
 314             var res = await(p);
 315             var stdout = res.stdout();
 316 
 317             for (var line : stdout) {
 318                 if (line.startsWith(&quot;count: &quot;)) {
 319                     try {
 320                         numLooseObjects = Integer.parseUnsignedInt(line.split(&quot; &quot;)[1]);
 321                     } catch (NumberFormatException e) {
 322                         throw new IOException(&quot;Unexpected &#39;count&#39; value\n&quot; + res, e);
 323                     }
 324 
 325                 } else if (line.startsWith(&quot;in-pack: &quot;)) {
 326                     try {
 327                         numPackedObjects = Integer.parseUnsignedInt(line.split(&quot; &quot;)[1]);
 328                     } catch (NumberFormatException e) {
 329                         throw new IOException(&quot;Unexpected &#39;in-pack&#39; value\n&quot; + res, e);
 330                     }
 331                 }
 332             }
 333         }
 334 
 335         return numLooseObjects == 0 &amp;&amp; numPackedObjects == 0 &amp;&amp; refs().size() == 0;
 336     }
 337 
 338     @Override
 339 
 340     public boolean isHealthy() throws IOException {
 341         try (var p = capture(&quot;git&quot;, &quot;fsck&quot;, &quot;--connectivity-only&quot;)) {
 342             if (p.await().status() != 0) {
 343                 return false;
 344             }
 345         }
 346         return true;
 347     }
 348 
 349     @Override
 350     public void clean() throws IOException {
 351         cachedRoot = null;
 352 
 353         try (var p = capture(&quot;git&quot;, &quot;clean&quot;, &quot;-x&quot;, &quot;-d&quot;, &quot;--force&quot;, &quot;--force&quot;)) {
 354             await(p);
 355         }
 356 
 357         try (var p = capture(&quot;git&quot;, &quot;reset&quot;, &quot;--hard&quot;)) {
 358             await(p);
 359         }
 360 
 361         try (var p = capture(&quot;git&quot;, &quot;rebase&quot;, &quot;--quit&quot;)) {
 362             p.await(); // Don&#39;t care about the result.
 363         }
 364     }
 365 
 366     @Override
 367     public void reset(Hash target, boolean hard) throws IOException {
 368         var cmd = new ArrayList&lt;&gt;(List.of(&quot;git&quot;, &quot;reset&quot;));
 369         if (hard) {
 370            cmd.add(&quot;--hard&quot;);
 371         }
 372         cmd.add(target.hex());
 373 
 374         try (var p = capture(cmd)) {
 375             await(p);
 376         }
 377     }
 378 
 379 
 380     @Override
 381     public void revert(Hash h) throws IOException {
 382         try (var p = capture(&quot;git&quot;, &quot;checkout&quot;, &quot;--recurse-submodules&quot;, h.hex(), &quot;--&quot;, &quot;.&quot;)) {
 383             await(p);
 384         }
 385     }
 386 
 387     @Override
 388     public Repository reinitialize() throws IOException {
 389         cachedRoot = null;
 390 
 391         Files.walk(dir)
 392              .map(Path::toFile)
 393              .sorted(Comparator.reverseOrder())
 394              .forEach(File::delete);
 395 
 396         return init();
 397     }
 398 
 399     @Override
 400     public Hash fetch(URI uri, String refspec, boolean includeTags) throws IOException {
 401         var cmd = new ArrayList&lt;String&gt;();
 402         cmd.addAll(List.of(&quot;git&quot;, &quot;fetch&quot;, &quot;--recurse-submodules=on-demand&quot;));
 403         if (includeTags) {
 404             cmd.add(&quot;--tags&quot;);
 405         } else {
 406             cmd.add(&quot;--no-tags&quot;);
 407         }
 408         cmd.add(uri.toString());
 409         cmd.add(refspec);
 410         try (var p = capture(cmd)) {
 411             await(p);
 412             return resolve(&quot;FETCH_HEAD&quot;).get();
 413         }
 414     }
 415 
 416     @Override
 417     public void fetchAll(boolean includeTags) throws IOException {
 418         var cmd = new ArrayList&lt;String&gt;();
 419         cmd.addAll(List.of(&quot;git&quot;, &quot;fetch&quot;, &quot;--recurse-submodules=on-demand&quot;));
 420         cmd.add(&quot;--prune&quot;);
 421         if (includeTags) {
 422             cmd.add(&quot;--tags&quot;);
 423             cmd.add(&quot;--prune-tags&quot;);
 424         } else {
 425             cmd.add(&quot;--no-tags&quot;);
 426         }
 427         cmd.add(&quot;--all&quot;);
 428         try (var p = capture(cmd)) {
 429             await(p);
 430         }
 431     }
 432 
 433     @Override
 434     public void fetchRemote(String remote) throws IOException {
 435         var lines = config(&quot;remote.&quot; + remote + &quot;.fetch&quot;);
 436         var refspec = lines.size() == 1 ? lines.get(0) : &quot;+refs/heads/*:refs/remotes/&quot; + remote + &quot;/*&quot;;
 437         try (var p = capture(&quot;git&quot;, &quot;fetch&quot;, &quot;--recurse-submodules=on-demand&quot;, &quot;--prune&quot;, remote, refspec, &quot;+refs/tags/*:refs/tags/*&quot;)) {
 438             await(p);
 439         }
 440     }
 441 
 442     private void checkout(String ref, boolean force) throws IOException {
 443         var cmd = new ArrayList&lt;String&gt;();
 444         cmd.addAll(List.of(&quot;git&quot;, &quot;-c&quot;, &quot;advice.detachedHead=false&quot;, &quot;checkout&quot;, &quot;--recurse-submodules&quot;));
 445         if (force) {
 446             cmd.add(&quot;--force&quot;);
 447         }
 448         cmd.add(ref);
 449         try (var p = capture(cmd)) {
 450             await(p);
 451         }
 452     }
 453 
 454     @Override
 455     public void checkout(Hash h, boolean force) throws IOException {
 456         checkout(h.hex(), force);
 457     }
 458 
 459     @Override
 460     public void checkout(Branch b, boolean force) throws IOException {
 461         checkout(b.name(), force);
 462     }
 463 
 464     @Override
 465     public Repository init() throws IOException {
 466         cachedRoot = null;
 467 
 468         if (!Files.exists(dir)) {
 469             Files.createDirectories(dir);
 470         }
 471 
 472         try (var p = capture(&quot;git&quot;, &quot;init&quot;)) {
 473             await(p);
 474             return this;
 475         }
 476     }
 477 
 478     @Override
 479     public void pushAll(URI uri) throws IOException {
 480         try (var p = capture(&quot;git&quot;, &quot;push&quot;, &quot;--mirror&quot;, uri.toString())) {
 481             await(p);
 482         }
 483     }
 484 
 485     @Override
 486     public void push(Hash hash, URI uri, String ref, boolean force) throws IOException {
 487         String refspec = force ? &quot;+&quot; : &quot;&quot;;
 488         if (!ref.startsWith(&quot;refs/&quot;)) {
 489             ref = &quot;refs/heads/&quot; + ref;
 490         }
 491         refspec += hash.hex() + &quot;:&quot; + ref;
 492 
 493         try (var p = capture(&quot;git&quot;, &quot;push&quot;, uri.toString(), refspec)) {
 494             await(p);
 495         }
 496     }
 497 
 498     @Override
 499     public void push(Branch branch, String remote, boolean setUpstream) throws IOException {
 500         var cmd = new ArrayList&lt;String&gt;();
 501         cmd.addAll(List.of(&quot;git&quot;, &quot;push&quot;, remote, branch.name()));
 502         if (setUpstream) {
 503             cmd.add(&quot;--set-upstream&quot;);
 504         }
 505 
 506         try (var p = capture(cmd)) {
 507             await(p);
 508         }
 509     }
 510 
 511     @Override
 512     public boolean isClean() throws IOException {
 513         try (var p = capture(&quot;git&quot;, &quot;status&quot;, &quot;--porcelain&quot;)) {
 514             var output = await(p);
 515             return output.stdout().size() == 0;
 516         }
 517     }
 518 
 519     @Override
 520     public boolean exists() throws IOException {
 521         if (!Files.exists(dir)) {
 522             return false;
 523         }
 524 
 525         try (var p = capture(&quot;git&quot;, &quot;rev-parse&quot;, &quot;--git-dir&quot;)) {
 526             return p.await().status() == 0;
 527         }
 528     }
 529 
 530     @Override
 531     public Path root() throws IOException {
 532         if (cachedRoot != null) {
 533             return cachedRoot;
 534         }
 535 
 536         try (var p = capture(&quot;git&quot;, &quot;rev-parse&quot;, &quot;--show-toplevel&quot;)) {
 537             var res = p.await();
 538             if (res.status() != 0 || res.stdout().size() != 1) {
 539                 // Perhaps this is a bare repository
 540                 try (var p2 = capture(&quot;git&quot;, &quot;rev-parse&quot;, &quot;--git-dir&quot;)) {
 541                     var res2 = await(p2);
 542                     if (res2.stdout().size() != 1) {
 543                         throw new IOException(&quot;Unexpected output\n&quot; + res2);
 544                     }
 545                     cachedRoot = dir.resolve(Path.of(res2.stdout().get(0)));
 546                     return cachedRoot;
 547                 }
 548             }
 549 
 550             cachedRoot = Path.of(res.stdout().get(0));
 551             return cachedRoot;
 552         }
 553     }
 554 
 555     @Override
 556     public void squash(Hash h) throws IOException {
 557         try (var p = capture(&quot;git&quot;, &quot;merge&quot;, &quot;--squash&quot;, h.hex())) {
 558             await(p);
 559         }
 560     }
 561 
 562     @FunctionalInterface
 563     private static interface Operation {
 564         void execute(List&lt;Path&gt; args) throws IOException;
 565     }
 566 
 567     private void batch(Operation op, List&lt;Path&gt; args) throws IOException {
 568         var batchSize = 64;
 569         var start = 0;
 570         while (start &lt; args.size()) {
 571             var end = start + batchSize;
 572             if (end &gt; args.size()) {
 573                 end = args.size();
 574             }
 575             op.execute(args.subList(start, end));
 576             start = end;
 577         }
 578     }
 579 
 580     private void addAll(List&lt;Path&gt; paths) throws IOException {
 581         var cmd = new ArrayList&lt;&gt;(List.of(&quot;git&quot;, &quot;add&quot;));
 582         for (var path : paths) {
 583             cmd.add(path.toString());
 584         }
 585         try (var p = capture(cmd)) {
 586             await(p);
 587         }
 588     }
 589 
 590     @Override
 591     public void add(List&lt;Path&gt; paths) throws IOException {
 592         batch(this::addAll, paths);
 593     }
 594 
 595     private void removeAll(List&lt;Path&gt; paths) throws IOException {
 596         var cmd = new ArrayList&lt;&gt;(List.of(&quot;git&quot;, &quot;rm&quot;));
 597         for (var path : paths) {
 598             cmd.add(path.toString());
 599         }
 600         try (var p = capture(cmd)) {
 601             await(p);
 602         }
 603     }
 604 
 605     @Override
 606     public void remove(List&lt;Path&gt; paths) throws IOException {
 607         batch(this::removeAll, paths);
 608     }
 609 
 610     @Override
 611     public void delete(Branch b) throws IOException {
 612         try (var p = capture(&quot;git&quot;, &quot;branch&quot;, &quot;-D&quot;, b.name())) {
 613             await(p);
 614         }
 615     }
 616 
 617     @Override
 618     public void addremove() throws IOException {
 619         try (var p = capture(&quot;git&quot;, &quot;add&quot;, &quot;--all&quot;)) {
 620             await(p);
 621         }
 622     }
 623 
 624     @Override
 625     public Hash commit(String message, String authorName, String authorEmail)  throws IOException {
 626         return commit(message, authorName, authorEmail, null);
 627     }
 628 
 629     @Override
 630     public Hash commit(String message, String authorName, String authorEmail, ZonedDateTime authorDate)  throws IOException {
 631         return commit(message, authorName, authorEmail, authorDate, authorName, authorEmail, authorDate);
 632     }
 633 
 634     @Override
 635     public Hash commit(String message,
 636                        String authorName,
 637                        String authorEmail,
 638                        String committerName,
 639                        String committerEmail) throws IOException {
 640         return commit(message, authorName, authorEmail, null, committerName, committerEmail, null);
 641     }
 642 
 643     @Override
 644     public Hash commit(String message,
 645                        String authorName,
 646                        String authorEmail,
 647                        ZonedDateTime authorDate,
 648                        String committerName,
 649                        String committerEmail,
 650                        ZonedDateTime committerDate) throws IOException {
 651         var cmd = Process.capture(&quot;git&quot;, &quot;commit&quot;, &quot;--message=&quot; + message)
 652                          .workdir(dir)
 653                          .environ(&quot;GIT_AUTHOR_NAME&quot;, authorName)
 654                          .environ(&quot;GIT_AUTHOR_EMAIL&quot;, authorEmail)
 655                          .environ(&quot;GIT_COMMITTER_NAME&quot;, committerName)
 656                          .environ(&quot;GIT_COMMITTER_EMAIL&quot;, committerEmail);
 657         if (authorDate != null) {
 658             cmd = cmd.environ(&quot;GIT_AUTHOR_DATE&quot;,
 659                               authorDate.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME));
 660         }
 661         if (committerDate != null) {
 662             cmd = cmd.environ(&quot;GIT_COMMITTER_DATE&quot;,
 663                               committerDate.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME));
 664         }
 665         try (var p = cmd.execute()) {
 666             await(p);
 667             return head();
 668         }
 669     }
 670 
 671     @Override
 672     public Hash commit(String message, String authorName, String authorEmail, ZonedDateTime authorDate, String committerName, String committerEmail, ZonedDateTime committerDate, List&lt;Hash&gt; parents, Tree tree) throws IOException {
 673         // Ensure we don&#39;t create identical commits
 674         if (parents.size() == 1) {
 675             var parentTree = tree(parents.get(0));
 676             if (parentTree.equals(tree)) {
 677                 return parents.get(0);
 678             }
 679         }
 680 
 681         var cmdLine = new ArrayList&lt;&gt;(List.of(&quot;git&quot;, &quot;commit-tree&quot;, tree.hash().hex(), &quot;-m&quot;, message));
 682         for (var parent : parents) {
 683             cmdLine.add(&quot;-p&quot;);
 684             cmdLine.add(parent.hex());
 685         }
 686         var cmd = Process.capture(cmdLine.toArray(new String[0]))
 687                 .workdir(dir)
 688                 .environ(&quot;GIT_AUTHOR_NAME&quot;, authorName)
 689                 .environ(&quot;GIT_AUTHOR_EMAIL&quot;, authorEmail)
 690                 .environ(&quot;GIT_COMMITTER_NAME&quot;, committerName)
 691                 .environ(&quot;GIT_COMMITTER_EMAIL&quot;, committerEmail);
 692         if (authorDate != null) {
 693             cmd = cmd.environ(&quot;GIT_AUTHOR_DATE&quot;,
 694                     authorDate.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME));
 695         }
 696         if (committerDate != null) {
 697             cmd = cmd.environ(&quot;GIT_COMMITTER_DATE&quot;,
 698                     committerDate.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME));
 699         }
 700         try (var p = cmd.execute()) {
 701             var res = await(p);
 702             if (res.stdout().size() != 1) {
 703                 throw new IOException(&quot;Unexpected output: &quot; + res.stdout());
 704             }
 705             var commitHash = res.stdout().get(0).trim();
 706             if (commitHash.length() != 40) {
 707                 throw new IOException(&quot;Unexpected output: &quot; + commitHash);
 708             }
 709             return new Hash(commitHash);
 710         }
 711     }
 712 
 713     @Override
 714     public Hash amend(String message) throws IOException {
 715         return amend(message, null, null, null, null);
 716     }
 717 
 718     @Override
 719     public Hash amend(String message, String authorName, String authorEmail) throws IOException {
 720         return amend(message, authorName, authorEmail, null, null);
 721     }
 722 
 723     @Override
 724     public Hash amend(String message, String authorName, String authorEmail, String committerName, String committerEmail) throws IOException {
 725         if (authorName == null || authorEmail == null) {
 726             var head = lookup(head()).orElseThrow();
 727             if (authorName == null) {
 728                 authorName = head.author().name();
 729             }
 730             if (authorEmail == null) {
 731                 authorEmail = head.author().email();
 732             }
 733         }
 734         if (committerName == null) {
 735             committerName = authorName;
 736             committerEmail = authorEmail;
 737         }
 738         var cmd = Process.capture(&quot;git&quot;, &quot;commit&quot;, &quot;--amend&quot;, &quot;--reset-author&quot;, &quot;--message=&quot; + message)
 739                          .workdir(dir)
 740                          .environ(&quot;GIT_AUTHOR_NAME&quot;, authorName)
 741                          .environ(&quot;GIT_AUTHOR_EMAIL&quot;, authorEmail)
 742                          .environ(&quot;GIT_COMMITTER_NAME&quot;, committerName)
 743                          .environ(&quot;GIT_COMMITTER_EMAIL&quot;, committerEmail);
 744         try (var p = cmd.execute()) {
 745             await(p);
 746             return head();
 747         }
 748     }
 749 
 750     @Override
 751     public Tag tag(Hash hash, String name, String message, String authorName, String authorEmail) throws IOException {
 752         var cmd = Process.capture(&quot;git&quot;, &quot;tag&quot;, &quot;--annotate&quot;, &quot;--message=&quot; + message, name, hash.hex())
 753                          .workdir(dir)
 754                          .environ(&quot;GIT_AUTHOR_NAME&quot;, authorName)
 755                          .environ(&quot;GIT_AUTHOR_EMAIL&quot;, authorEmail)
 756                          .environ(&quot;GIT_COMMITTER_NAME&quot;, authorName)
 757                          .environ(&quot;GIT_COMMITTER_EMAIL&quot;, authorEmail);
 758         try (var p = cmd.execute()) {
 759             await(p);
 760         }
 761 
 762         return new Tag(name);
 763     }
 764 
 765     @Override
 766     public Branch branch(Hash hash, String name) throws IOException {
 767         try (var p = capture(&quot;git&quot;, &quot;branch&quot;, name, hash.hex())) {
 768             await(p);
 769         }
 770 
 771         return new Branch(name);
 772     }
 773 
 774     @Override
 775     public void prune(Branch branch, String remote) throws IOException {
 776         try (var p = capture(&quot;git&quot;, &quot;push&quot;, &quot;--delete&quot;, remote, branch.name())) {
 777             await(p);
 778         }
 779         try (var p = capture(&quot;git&quot;, &quot;branch&quot;, &quot;--delete&quot;, &quot;--force&quot;, branch.name())) {
 780             await(p);
 781         }
 782     }
 783 
 784     @Override
 785     public Hash mergeBase(Hash first, Hash second) throws IOException {
 786         try (var p = capture(&quot;git&quot;, &quot;merge-base&quot;, first.hex(), second.hex())) {
 787             var res = await(p);
 788             if (res.stdout().size() != 1) {
 789                  throw new IOException(&quot;Unexpected output\n&quot; + res);
 790             }
 791             return new Hash(res.stdout().get(0));
 792         }
 793     }
 794 
 795     @Override
 796     public boolean isAncestor(Hash ancestor, Hash descendant) throws IOException {
 797         try (var p = capture(&quot;git&quot;, &quot;merge-base&quot;, &quot;--is-ancestor&quot;, ancestor.hex(), descendant.hex())) {
 798             var res = p.await();
 799             return res.status() == 0;
 800         }
 801     }
 802 
 803     @Override
 804     public void rebase(Hash hash, String committerName, String committerEmail) throws IOException {
 805         try (var p = Process.capture(&quot;git&quot;, &quot;rebase&quot;, &quot;--onto&quot;, hash.hex(), &quot;--root&quot;)
 806                             .environ(&quot;GIT_COMMITTER_NAME&quot;, committerName)
 807                             .environ(&quot;GIT_COMMITTER_EMAIL&quot;, committerEmail)
 808                             .workdir(dir)
 809                             .execute()) {
 810             await(p);
 811         }
 812     }
 813 
 814     @Override
 815     public Optional&lt;Hash&gt; resolve(String ref) throws IOException {
 816         try (var p = capture(&quot;git&quot;, &quot;rev-parse&quot;, ref + &quot;^{commit}&quot;)) {
 817             var res = p.await();
 818             if (res.status() == 0 &amp;&amp; res.stdout().size() == 1) {
 819                 return Optional.of(new Hash(res.stdout().get(0)));
 820             }
 821             return Optional.empty();
 822         }
 823     }
 824 
 825     @Override
 826     public Optional&lt;Branch&gt; currentBranch() throws IOException {
 827         try (var p = capture(&quot;git&quot;, &quot;symbolic-ref&quot;, &quot;--short&quot;, &quot;HEAD&quot;)) {
 828             var res = p.await();
 829             if (res.status() == 0 &amp;&amp; res.stdout().size() == 1) {
 830                 return Optional.of(new Branch(res.stdout().get(0)));
 831             }
 832             return Optional.empty();
 833         }
 834     }
 835 
 836     @Override
 837     public Optional&lt;Bookmark&gt; currentBookmark() throws IOException {
 838         throw new RuntimeException(&quot;git does not have bookmarks&quot;);
 839     }
 840 
 841     @Override
 842     public Branch defaultBranch() throws IOException {
 843         try (var p = capture(&quot;git&quot;, &quot;symbolic-ref&quot;, &quot;--short&quot;, &quot;refs/remotes/origin/HEAD&quot;)) {
 844             var res = p.await();
 845             if (res.status() == 0 &amp;&amp; res.stdout().size() == 1) {
 846                 var ref = res.stdout().get(0).substring(&quot;origin/&quot;.length());
 847                 return new Branch(ref);
 848             } else {
 849                 return new Branch(&quot;master&quot;);
 850             }
 851         }
 852     }
 853 
 854     @Override
 855     public Optional&lt;Tag&gt; defaultTag() throws IOException {
 856         return Optional.empty();
 857     }
 858 
 859     @Override
 860     public Optional&lt;String&gt; username() throws IOException {
 861         var lines = config(&quot;user.name&quot;);
 862         return lines.size() == 1 ? Optional.of(lines.get(0)) : Optional.empty();
 863     }
 864 
 865     private String treeEntry(Path path, Hash hash) throws IOException {
 866         try (var p = Process.capture(&quot;git&quot;, &quot;ls-tree&quot;, hash.hex(), path.toString())
 867                             .workdir(root())
 868                             .execute()) {
 869             var res = await(p);
 870             if (res.stdout().size() == 0) {
 871                 return null;
 872             }
 873             if (res.stdout().size() &gt; 1) {
 874                 throw new IOException(&quot;Unexpected output\n&quot; + res);
 875             }
 876             return res.stdout().get(0);
 877         }
 878     }
 879 
 880     private List&lt;FileEntry&gt; allFiles(Hash hash, List&lt;Path&gt; paths) throws IOException {
 881         var cmd = new ArrayList&lt;String&gt;();
 882         cmd.addAll(List.of(&quot;git&quot;, &quot;ls-tree&quot;, &quot;-r&quot;));
 883         cmd.add(hash.hex());
 884         cmd.addAll(paths.stream().map(Path::toString).collect(Collectors.toList()));
 885         try (var p = Process.capture(cmd.toArray(new String[0]))
 886                             .workdir(root())
 887                             .execute()) {
 888             var res = await(p);
 889             var entries = new ArrayList&lt;FileEntry&gt;();
 890             for (var line : res.stdout()) {
 891                 var parts = line.split(&quot;\t&quot;);
 892                 var metadata = parts[0].split(&quot; &quot;);
 893                 var filename = parts[1];
 894 
 895                 var entry = new FileEntry(hash,
 896                                           FileType.fromOctal(metadata[0]),
 897                                           new Hash(metadata[2]),
 898                                           Path.of(filename));
 899                 entries.add(entry);
 900             }
 901             return entries;
 902         }
 903     }
 904 
 905     @Override
 906     public List&lt;FileEntry&gt; files(Hash hash, List&lt;Path&gt; paths) throws IOException {
 907         if (paths.isEmpty()) {
 908             return allFiles(hash, paths);
 909         }
 910 
 911         var entries = new ArrayList&lt;FileEntry&gt;();
 912         var batchSize = 64;
 913         var start = 0;
 914         while (start &lt; paths.size()) {
 915             var end = start + batchSize;
 916             if (end &gt; paths.size()) {
 917                 end = paths.size();
 918             }
 919             entries.addAll(allFiles(hash, paths.subList(start, end)));
 920             start = end;
 921         }
 922         return entries;
 923     }
 924 
 925     private Path unpackFile(String blob) throws IOException {
 926         try (var p = capture(&quot;git&quot;, &quot;unpack-file&quot;, blob)) {
 927             var res = await(p);
 928             if (res.stdout().size() != 1) {
 929                 throw new IOException(&quot;Unexpected output\n&quot; + res);
 930             }
 931 
 932             return Path.of(root().toString(), res.stdout().get(0));
 933         }
 934     }
 935 
 936     @Override
 937     public Optional&lt;byte[]&gt; show(Path path, Hash hash) throws IOException {
 938         var entries = files(hash, path);
 939         if (entries.size() == 0) {
 940             return Optional.empty();
 941         } else if (entries.size() &gt; 1) {
 942             throw new IOException(&quot;Multiple files match path &quot; + path.toString() + &quot; in commit &quot; + hash.hex());
 943         }
 944 
 945         var entry = entries.get(0);
 946         var type = entry.type();
 947         if (type.isVCSLink()) {
 948             var content = &quot;Subproject commit &quot; + entry.hash().hex() + &quot; &quot; + entry.path().toString();
 949             return Optional.of(content.getBytes(StandardCharsets.UTF_8));
 950         } else if (type.isRegular()) {
 951             var tmp = unpackFile(entry.hash().hex());
 952             var content = Files.readAllBytes(tmp);
 953             Files.delete(tmp);
 954             return Optional.of(content);
 955         }
 956 
 957         return Optional.empty();
 958     }
 959 
 960     @Override
 961     public void dump(FileEntry entry, Path to) throws IOException {
 962         var type = entry.type();
 963         if (type.isRegular()) {
 964             var path = unpackFile(entry.hash().hex());
 965             Files.createDirectories(to.getParent());
 966             Files.move(path, to, StandardCopyOption.REPLACE_EXISTING);
 967         }
 968     }
 969 
 970     @Override
 971     public List&lt;StatusEntry&gt; status(Hash from, Hash to) throws IOException {
 972         var cmd = new ArrayList&lt;String&gt;();
 973         cmd.addAll(List.of(&quot;git&quot;, &quot;diff&quot;, &quot;--raw&quot;,
 974                                           &quot;--find-renames=90%&quot;,
 975                                           &quot;--find-copies=90%&quot;,
 976                                           &quot;--find-copies-harder&quot;,
 977                                           &quot;--no-abbrev&quot;,
 978                                           &quot;--no-color&quot;));
 979         if (from != null) {
 980             cmd.add(from.hex());
 981         }
 982         if (to != null) {
 983             cmd.add(to.hex());
 984         }
 985         try (var p = capture(cmd)) {
 986             var res = await(p);
 987             var entries = new ArrayList&lt;StatusEntry&gt;();
 988             for (var line : res.stdout()) {
 989                 entries.add(StatusEntry.fromRawLine(line));
 990             }
 991             return entries;
 992         }
 993     }
 994 
 995     @Override
 996     public List&lt;StatusEntry&gt; status() throws IOException {
 997         return status(null, null);
 998     }
 999 
1000     @Override
<a name="1" id="anc1"></a><span class="line-modified">1001     public Diff diff(Hash from, int similarity) throws IOException {</span>
<span class="line-modified">1002         return diff(from, List.of(), similarity);</span>
1003     }
1004 
1005     @Override
<a name="2" id="anc2"></a><span class="line-modified">1006     public Diff diff(Hash from, List&lt;Path&gt; files, int similarity) throws IOException {</span>
<span class="line-modified">1007         return diff(from, null, files, similarity);</span>
1008     }
1009 
1010     @Override
<a name="3" id="anc3"></a><span class="line-modified">1011     public Diff diff(Hash from, Hash to, int similarity) throws IOException {</span>
<span class="line-modified">1012         return diff(from, to, List.of(), similarity);</span>
1013     }
1014 
1015     @Override
<a name="4" id="anc4"></a><span class="line-modified">1016     public Diff diff(Hash from, Hash to, List&lt;Path&gt; files, int similarity) throws IOException {</span>
<span class="line-added">1017         if (similarity &lt; 0 || similarity &gt; 100) {</span>
<span class="line-added">1018             throw new IllegalArgumentException(&quot;similarity must be between 0 and 100, is: &quot;  + similarity);</span>
<span class="line-added">1019         }</span>
1020         var cmd = new ArrayList&lt;&gt;(List.of(&quot;git&quot;, &quot;diff&quot;, &quot;--patch&quot;,
<a name="5" id="anc5"></a><span class="line-modified">1021                                                          &quot;--find-renames=&quot; + similarity + &quot;%&quot;,</span>
<span class="line-modified">1022                                                          &quot;--find-copies=&quot; + similarity + &quot;%&quot;,</span>
1023                                                          &quot;--find-copies-harder&quot;,
1024                                                          &quot;--binary&quot;,
1025                                                          &quot;--raw&quot;,
1026                                                          &quot;--no-abbrev&quot;,
1027                                                          &quot;--unified=0&quot;,
1028                                                          &quot;--no-color&quot;,
1029                                                          from.hex()));
1030         if (to != null) {
1031             cmd.add(to.hex());
1032         }
1033 
1034         if (files != null &amp;&amp; !files.isEmpty()) {
1035             cmd.add(&quot;--&quot;);
1036             for (var file : files) {
1037                 cmd.add(file.toString());
1038             }
1039         }
1040 
1041         var p = start(cmd);
1042         try {
1043             var patches = UnifiedDiffParser.parseGitRaw(p.getInputStream());
1044             await(p);
1045             return new Diff(from, to, patches);
1046         } catch (Throwable t) {
1047             stop(p);
1048             throw t;
1049         }
1050     }
1051 
1052     @Override
1053     public List&lt;String&gt; config(String key) throws IOException {
1054         try (var p = capture(&quot;git&quot;, &quot;config&quot;, key)) {
1055             var res = p.await();
1056             return res.status() == 0 ? res.stdout() : List.of();
1057         }
1058     }
1059 
1060     @Override
1061     public Hash head() throws IOException {
1062         return resolve(&quot;HEAD&quot;).orElseThrow(() -&gt; new IllegalStateException(&quot;HEAD ref is not present&quot;));
1063     }
1064 
1065     public static Optional&lt;Repository&gt; get(Path p) throws IOException {
1066         if (!Files.exists(p)) {
1067             return Optional.empty();
1068         }
1069 
1070         var r = new GitRepository(p);
1071         return r.exists() ? Optional.of(new GitRepository(r.root())) : Optional.empty();
1072     }
1073 
1074     @Override
1075     public Repository copyTo(Path destination) throws IOException {
1076         try (var p = capture(&quot;git&quot;, &quot;clone&quot;, &quot;--recurse-submodules&quot;, root().toString(), destination.toString())) {
1077             await(p);
1078         }
1079 
1080         return new GitRepository(destination);
1081     }
1082 
1083     @Override
1084     public void merge(Hash h) throws IOException {
1085         merge(h.hex(), null);
1086     }
1087 
1088     @Override
1089     public void merge(Branch b) throws IOException {
1090         merge(b.name(), null);
1091     }
1092 
1093     @Override
1094     public void merge(Hash h, String strategy) throws IOException {
1095         merge(h.hex(), strategy);
1096     }
1097 
1098     private void merge(String ref, String strategy) throws IOException {
1099         var cmd = new ArrayList&lt;String&gt;();
1100         cmd.addAll(List.of(&quot;git&quot;, &quot;-c&quot;, &quot;user.name=unused&quot;, &quot;-c&quot;, &quot;user.email=unused&quot;,
1101                            &quot;merge&quot;, &quot;--no-commit&quot;));
1102         if (strategy != null) {
1103             cmd.add(&quot;-s&quot;);
1104             cmd.add(strategy);
1105         }
1106         cmd.add(ref);
1107         try (var p = capture(cmd)) {
1108             await(p);
1109         }
1110     }
1111 
1112     @Override
1113     public void abortMerge() throws IOException {
1114         try (var p = capture(&quot;git&quot;, &quot;merge&quot;, &quot;--abort&quot;)) {
1115             await(p);
1116         }
1117     }
1118 
1119     @Override
1120     public void addRemote(String name, String pullPath) throws IOException {
1121         try (var p = capture(&quot;git&quot;, &quot;remote&quot;, &quot;add&quot;, name, pullPath)) {
1122             await(p);
1123         }
1124     }
1125 
1126     @Override
1127     public void setPaths(String remote, String pullPath, String pushPath) throws IOException {
1128         pullPath = pullPath == null ? &quot;&quot; : pullPath;
1129         try (var p = capture(&quot;git&quot;, &quot;config&quot;, &quot;remote.&quot; + remote + &quot;.url&quot;, pullPath)) {
1130             await(p);
1131         }
1132 
1133         pushPath = pushPath == null ? &quot;&quot; : pushPath;
1134         try (var p = capture(&quot;git&quot;, &quot;config&quot;, &quot;remote.&quot; + remote + &quot;.pushurl&quot;, pushPath)) {
1135             await(p);
1136         }
1137     }
1138 
1139     @Override
1140     public String pullPath(String remote) throws IOException {
1141         var lines = config(&quot;remote.&quot; + remote + &quot;.url&quot;);
1142         if (lines.size() != 1) {
1143             throw new IOException(&quot;No pull path found for remote &quot; + remote);
1144         }
1145         return lines.get(0);
1146     }
1147 
1148     @Override
1149     public String pushPath(String remote) throws IOException {
1150         var lines = config(&quot;remote.&quot; + remote + &quot;.pushurl&quot;);
1151         if (lines.size() != 1) {
1152             return pullPath(remote);
1153         }
1154         return lines.get(0);
1155     }
1156 
1157     @Override
1158     public boolean isValidRevisionRange(String expression) throws IOException {
1159         try (var p = capture(&quot;git&quot;, &quot;rev-parse&quot;, expression)) {
1160             return p.await().status() == 0;
1161         }
1162     }
1163 
1164     private void applyPatch(Patch patch) throws IOException {
1165         if (patch.isEmpty()) {
1166             return;
1167         }
1168 
1169         if (patch.isTextual()) {
1170         } else {
1171             throw new IllegalArgumentException(&quot;Cannot handle binary patches yet&quot;);
1172         }
1173     }
1174 
1175     @Override
1176     public void apply(Diff diff, boolean force) throws IOException {
1177         // ignore force, no such concept in git
1178         var patchFile = Files.createTempFile(&quot;apply&quot;, &quot;.patch&quot;);
1179         diff.toFile(patchFile);
1180         apply(patchFile, force);
1181         Files.delete(patchFile);
1182     }
1183 
1184     @Override
1185     public void apply(Path patchFile, boolean force)  throws IOException {
1186         var cmd = new ArrayList&lt;String&gt;();
1187         cmd.addAll(List.of(&quot;git&quot;, &quot;apply&quot;, &quot;--index&quot;, &quot;--unidiff-zero&quot;));
1188         cmd.add(patchFile.toAbsolutePath().toString());
1189         try (var p = capture(cmd)) {
1190             await(p);
1191             Files.delete(patchFile);
1192         }
1193     }
1194 
1195     @Override
1196     public void copy(Path from, Path to) throws IOException {
1197         Files.copy(from, to);
1198         add(to);
1199     }
1200 
1201     @Override
1202     public void move(Path from, Path to) throws IOException {
1203         try (var p = capture(&quot;git&quot;, &quot;mv&quot;, from.toString(), to.toString())) {
1204             await(p);
1205         }
1206     }
1207 
1208     @Override
1209     public Optional&lt;String&gt; upstreamFor(Branch b) throws IOException {
1210         try (var p = capture(&quot;git&quot;, &quot;for-each-ref&quot;, &quot;--format=%(upstream:short)&quot;, &quot;refs/heads/&quot; + b.name())) {
1211             var lines = await(p).stdout();
1212             return lines.size() == 1 &amp;&amp; !lines.get(0).isEmpty()? Optional.of(lines.get(0)) : Optional.empty();
1213         }
1214     }
1215 
1216     public static Repository clone(URI from, Path to, boolean isBare, Path seed) throws IOException {
1217         var cmd = new ArrayList&lt;String&gt;();
1218         cmd.addAll(List.of(&quot;git&quot;, &quot;clone&quot;));
1219         if (isBare) {
1220             cmd.add(&quot;--bare&quot;);
1221         } else {
1222             cmd.add(&quot;--recurse-submodules&quot;);
1223         }
1224         if (seed != null) {
1225             cmd.add(&quot;--reference-if-able&quot;);
1226             cmd.add(seed.toString());
1227         }
1228         cmd.addAll(List.of(from.toString(), to.toString()));
1229         try (var p = capture(Path.of(&quot;&quot;).toAbsolutePath(), cmd)) {
1230             await(p);
1231         }
1232         return new GitRepository(to);
1233     }
1234 
1235     public static Repository mirror(URI from, Path to) throws IOException {
1236         var cwd = Path.of(&quot;&quot;).toAbsolutePath();
1237         try (var p = capture(cwd, &quot;git&quot;, &quot;clone&quot;, &quot;--mirror&quot;, from.toString(), to.toString())) {
1238             await(p);
1239         }
1240         return new GitRepository(to);
1241     }
1242 
1243     @Override
1244     public void pull() throws IOException {
1245         pull(null, null);
1246     }
1247 
1248     @Override
1249     public void pull(String remote) throws IOException {
1250         pull(remote, null);
1251     }
1252 
1253 
1254     @Override
1255     public void pull(String remote, String refspec) throws IOException {
1256         var cmd = new ArrayList&lt;String&gt;();
1257         cmd.add(&quot;git&quot;);
1258         cmd.add(&quot;pull&quot;);
1259         cmd.add(&quot;--recurse-submodules&quot;);
1260         if (remote != null) {
1261             cmd.add(remote);
1262         }
1263         if (refspec != null) {
1264             cmd.add(refspec);
1265         }
1266         try (var p = capture(cmd)) {
1267             await(p);
1268         }
1269     }
1270 
1271     @Override
1272     public boolean contains(Branch b, Hash h) throws IOException {
1273         try (var p = capture(&quot;git&quot;, &quot;for-each-ref&quot;, &quot;--contains&quot;, h.hex(), &quot;--format&quot;, &quot;%(refname:short)&quot;)) {
1274             var res = await(p);
1275             for (var line : res.stdout()) {
1276                 if (line.equals(b.name())) {
1277                     return true;
1278                 }
1279             }
1280         }
1281 
1282         return false;
1283     }
1284 
1285     @Override
1286     public List&lt;Reference&gt; remoteBranches(String remote) throws IOException {
1287         var refs = new ArrayList&lt;Reference&gt;();
1288         try (var p = capture(&quot;git&quot;, &quot;ls-remote&quot;, &quot;--heads&quot;, &quot;--refs&quot;, remote)) {
1289             for (var line : await(p).stdout()) {
1290                 var parts = line.split(&quot;\t&quot;);
1291                 var name = parts[1].replace(&quot;refs/heads/&quot;, &quot;&quot;);
1292                 refs.add(new Reference(name, new Hash(parts[0])));
1293             }
1294         }
1295         return refs;
1296     }
1297 
1298     @Override
1299     public List&lt;String&gt; remotes() throws IOException {
1300         var remotes = new ArrayList&lt;String&gt;();
1301         try (var p = capture(&quot;git&quot;, &quot;remote&quot;)) {
1302             for (var line : await(p).stdout()) {
1303                 remotes.add(line);
1304             }
1305         }
1306         return remotes;
1307     }
1308 
1309     @Override
1310     public void updateSubmodule(Path path) throws IOException {
1311         try (var p = capture(&quot;git&quot;, &quot;submodule&quot;, &quot;update&quot;, path.toString())) {
1312             await(p);
1313         }
1314     }
1315 
1316     @Override
1317     public void addSubmodule(String pullPath, Path path) throws IOException {
1318         try (var p = capture(&quot;git&quot;, &quot;submodule&quot;, &quot;add&quot;, pullPath, path.toString())) {
1319             await(p);
1320         }
1321     }
1322 
1323     @Override
1324     public List&lt;Submodule&gt; submodules() throws IOException {
1325         var gitModules = root().resolve(&quot;.gitmodules&quot;);
1326         if (!Files.exists(gitModules)) {
1327             return List.of();
1328         }
1329 
1330         var urls = new HashMap&lt;String, String&gt;();
1331         var paths = new HashMap&lt;String, String&gt;();
1332         try (var p = capture(&quot;git&quot;, &quot;config&quot;, &quot;--file&quot;, gitModules.toAbsolutePath().toString(),
1333                                               &quot;--list&quot;)) {
1334             for (var line : await(p).stdout()) {
1335                 if (line.startsWith(&quot;submodule.&quot;)) {
1336                     line = line.substring(&quot;submodule.&quot;.length());
1337                     var parts = line.split(&quot;=&quot;);
1338                     var nameAndProperty = parts[0].split(&quot;\\.&quot;);
1339                     var name = nameAndProperty[0];
1340                     var prop = nameAndProperty[1];
1341                     var value = parts[1];
1342                     if (prop.equals(&quot;path&quot;)) {
1343                         paths.put(name, value);
1344                     } else if (prop.equals(&quot;url&quot;)) {
1345                         urls.put(name, value);
1346                     } else {
1347                         throw new IOException(&quot;Unexpected submodule property: &quot; + prop);
1348                     }
1349                 }
1350             }
1351         }
1352 
1353         var hashes = new HashMap&lt;String, String&gt;();
1354         try (var p = capture(&quot;git&quot;, &quot;submodule&quot;, &quot;status&quot;)) {
1355             for (var line : await(p).stdout()) {
1356                 var parts = line.substring(1).split(&quot; &quot;);
1357                 var hash = parts[0];
1358                 var path = parts[1];
1359                 hashes.put(path, hash);
1360             }
1361         }
1362 
1363         var modules = new ArrayList&lt;Submodule&gt;();
1364         for (var name : paths.keySet()) {
1365             var url = urls.get(name);
1366             var path = paths.get(name);
1367             var hash = hashes.get(path);
1368 
1369             modules.add(new Submodule(new Hash(hash), Path.of(path), url));
1370         }
1371 
1372         return modules;
1373     }
1374 
1375     @Override
1376     public Tree tree(Hash h) throws IOException {
1377         String treeHash;
1378         try (var p = capture(&quot;git&quot;, &quot;cat-file&quot;, &quot;-p&quot;, h.hex())) {
1379             var res = p.await();
1380             if (res.stdout().size() &gt; 0) {
1381                 var line = res.stdout().get(0);
1382                 if (line.startsWith(&quot;tree &quot;)) {
1383                     treeHash = line.substring(5).trim();
1384                     if (treeHash.length() != 40) {
1385                         throw new IOException(&quot;Unexpected output: &quot; + treeHash);
1386                     }
1387                 } else {
1388                     throw new IOException(&quot;Unexpected output: &quot; + line);
1389                 }
1390             } else {
1391                 throw new IOException(&quot;Unexpected output: &quot; + res.stderr());
1392             }
1393         }
1394         return new Tree(new Hash(treeHash));
1395     }
1396 
1397     @Override
1398     public Optional&lt;Tag.Annotated&gt; annotate(Tag tag) throws IOException {
1399         var ref = &quot;refs/tags/&quot; + tag.name();
1400         var format = &quot;%(refname:short)%0a%(*objectname)%0a%(taggername) %(taggeremail)%0a%(taggerdate:iso-strict)%0a%(contents)&quot;;
1401         try (var p = capture(&quot;git&quot;, &quot;for-each-ref&quot;, &quot;--format&quot;, format, ref)) {
1402             var lines = await(p).stdout();
1403             if (lines.size() &gt;= 4) {
1404                 var name = lines.get(0);
1405                 var targetLine = lines.get(1);
1406                 var authorLine = lines.get(2);
1407                 var dateLine = lines.get(3);
1408 
1409                 if (targetLine.isEmpty() &amp;&amp; authorLine.equals(&quot; &quot;) &amp;&amp; dateLine.isEmpty()) {
1410                     // Must be a lightweight tag, no metadata present
1411                     return Optional.empty();
1412                 }
1413 
1414                 var target = new Hash(targetLine);
1415                 var author = Author.fromString(authorLine);
1416                 var formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
1417                 var date = ZonedDateTime.parse(dateLine, formatter);
1418                 var message = String.join(&quot;\n&quot;, lines.subList(4, lines.size()));
1419 
1420                 return Optional.of(new Tag.Annotated(name, target, author, date, message));
1421             }
1422             return Optional.empty();
1423         }
1424     }
1425 
1426     @Override
1427     public void config(String section, String key, String value, boolean global) throws IOException {
1428         var cmd = new ArrayList&lt;String&gt;();
1429         cmd.addAll(List.of(&quot;git&quot;, &quot;config&quot;));
1430         if (global) {
1431             cmd.add(&quot;--global&quot;);
1432         }
1433         cmd.add(section + &quot;.&quot; + key);
1434         cmd.add(value);
1435         try (var p = capture(cmd)) {
1436             await(p);
1437         }
1438     }
1439 
1440     @Override
1441     public String range(Hash h) {
1442         return h.hex() + &quot;^!&quot;;
1443     }
1444 
1445     @Override
1446     public String rangeInclusive(Hash from, Hash to) {
1447         return from.hex() + &quot;^..&quot; + to.hex();
1448     }
1449 
1450     @Override
1451     public String rangeExclusive(Hash from, Hash to) {
1452         return from.hex() + &quot;..&quot; + to.hex();
1453     }
1454 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>