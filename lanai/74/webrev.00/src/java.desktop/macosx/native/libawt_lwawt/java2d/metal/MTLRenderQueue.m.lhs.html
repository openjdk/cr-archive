<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifndef HEADLESS
  27 
  28 #include &lt;stdlib.h&gt;
  29 
  30 #include &quot;sun_java2d_pipe_BufferedOpCodes.h&quot;
  31 
  32 #include &quot;jlong.h&quot;
  33 #include &quot;MTLBlitLoops.h&quot;
  34 #include &quot;MTLBufImgOps.h&quot;
  35 #include &quot;MTLMaskBlit.h&quot;
  36 #include &quot;MTLMaskFill.h&quot;
  37 #include &quot;MTLPaints.h&quot;
  38 #include &quot;MTLRenderQueue.h&quot;
  39 #include &quot;MTLRenderer.h&quot;
  40 #include &quot;MTLTextRenderer.h&quot;
  41 #import &quot;ThreadUtilities.h&quot;
  42 
  43 /**
  44  * References to the &quot;current&quot; context and destination surface.
  45  */
  46 static MTLContext *mtlc = NULL;
  47 static BMTLSDOps *dstOps = NULL;
  48 jint mtlPreviousOp = MTL_OP_INIT;
  49 
  50 
  51 /**
  52  * The following methods are implemented in the windowing system (i.e. GLX
  53  * and WGL) source files.
  54  */
  55 extern void MTLGC_DestroyMTLGraphicsConfig(jlong pConfigInfo);
  56 extern void MTLSD_SwapBuffers(JNIEnv *env, jlong window);
  57 
  58 // TODO : Debug logic added for opcode verification,
  59 // should be removed later.
  60 static char *getOpcodeString(jint opcode) {
  61     static char opName[30];
  62     switch (opcode) {
  63         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
  64             {
  65                 strcpy(opName, &quot;DRAW_LINE&quot;);
  66             }
  67             break;
  68         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
  69             {
  70                 strcpy(opName, &quot;DRAW_RECT&quot;);
  71             }
  72             break;
  73         case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
  74             {
  75                 strcpy(opName, &quot;DRAW_POLY&quot;);
  76             }
  77             break;
  78         case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
  79             {
  80                 strcpy(opName, &quot;DRAW_PIXEL&quot;);
  81             }
  82             break;
  83         case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
  84             {
  85                 strcpy(opName, &quot;DRAW_SCANLINES&quot;);
  86             }
  87             break;
  88         case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
  89             {
  90                 strcpy(opName, &quot;DRAW_PARALLELOGRAM&quot;);
  91             }
  92             break;
  93         case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
  94             {
  95                 strcpy(opName, &quot;DRAW_AAPARALLELOGRAM&quot;);
  96             }
  97             break;
  98         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
  99             {
 100                 strcpy(opName, &quot;FILL_RECT&quot;);
 101             }
 102             break;
 103         case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
 104             {
 105                 strcpy(opName, &quot;FILL_SPANS&quot;);
 106             }
 107             break;
 108         case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
 109             {
 110                 strcpy(opName, &quot;FILL_PARALLELOGRAM&quot;);
 111             }
 112             break;
 113         case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
 114             {
 115                 strcpy(opName, &quot;FILL_AAPARALLELOGRAM&quot;);
 116             }
 117             break;
 118         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
 119             {
 120                 strcpy(opName, &quot;DRAW_GLYPH_LIST&quot;);
 121             }
 122             break;
 123         case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
 124             {
 125                 strcpy(opName, &quot;COPY_AREA&quot;);
 126             }
 127             break;
 128         case sun_java2d_pipe_BufferedOpCodes_BLIT:
 129             {
 130                 strcpy(opName, &quot;BLIT&quot;);
 131             }
 132             break;
 133         case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
 134             {
 135                 strcpy(opName, &quot;SURFACE_TO_SW_BLIT&quot;);
 136             }
 137             break;
 138         case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
 139             {
 140                 strcpy(opName, &quot;MASK_FILL&quot;);
 141             }
 142             break;
 143         case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
 144             {
 145 
 146                 strcpy(opName, &quot;MASK_BLIT&quot;);
 147             }
 148             break;
 149         case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
 150             {
 151                 strcpy(opName, &quot;SET_RECT_CLIP&quot;);
 152             }
 153             break;
 154         case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
 155             {
 156                 strcpy(opName, &quot;BEGIN_SHAPE_CLIP&quot;);
 157             }
 158             break;
 159         case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
 160             {
 161                 strcpy(opName, &quot;SET_SHAPE_CLIP_SPANS&quot;);
 162             }
 163             break;
 164         case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
 165             {
 166                 strcpy(opName, &quot;END_SHAPE_CLIP&quot;);
 167             }
 168             break;
 169         case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
 170             {
 171                 strcpy(opName, &quot;RESET_CLIP&quot;);
 172             }
 173             break;
 174         case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
 175             {
 176                 strcpy(opName, &quot;SET_ALPHA_COMPOSITE&quot;);
 177             }
 178             break;
 179         case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
 180             {
 181                 strcpy(opName, &quot;SET_XOR_COMPOSITE&quot;);
 182             }
 183             break;
 184         case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
 185             {
 186                 strcpy(opName, &quot;RESET_COMPOSITE&quot;);
 187             }
 188             break;
 189         case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
 190             {
 191                 strcpy(opName, &quot;SET_TRANSFORM&quot;);
 192             }
 193             break;
 194         case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
 195             {
 196                 strcpy(opName, &quot;RESET_TRANSFORM&quot;);
 197             }
 198             break;
 199         case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
 200             {
 201 
 202                 strcpy(opName, &quot;SET_SURFACES&quot;);
 203             }
 204             break;
 205         case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
 206             {
 207                 strcpy(opName, &quot;SET_SCRATCH_SURFACE&quot;);
 208             }
 209             break;
 210         case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
 211             {
 212                 strcpy(opName, &quot;FLUSH_SURFACE&quot;);
 213             }
 214             break;
 215         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
 216             {
 217                 strcpy(opName, &quot;DISPOSE_SURFACE&quot;);
 218             }
 219             break;
 220         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
 221             {
 222                 strcpy(opName, &quot;DISPOSE_CONFIG&quot;);
 223             }
 224             break;
 225         case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
 226             {
 227                 strcpy(opName, &quot;INVALIDATE_CONTEXT&quot;);
 228             }
 229             break;
 230         case sun_java2d_pipe_BufferedOpCodes_SYNC:
 231             {
 232                 strcpy(opName, &quot;SYNC&quot;);
 233 
 234             }
 235             break;
 236         case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
 237             {
 238                 strcpy(opName, &quot;SWAP_BUFFERS&quot;);
 239             }
 240             break;
 241         case sun_java2d_pipe_BufferedOpCodes_NOOP:
 242             strcpy(opName, &quot;NOOP&quot;);
 243             break;
 244         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
 245             {
 246                 strcpy(opName, &quot;RESET_PAINT&quot;);
 247             }
 248             break;
 249         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
 250             {
 251                 strcpy(opName, &quot;SET_COLOR&quot;);
 252             }
 253             break;
 254         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
 255             {
 256                 strcpy(opName, &quot;SET_GRADIENT_PAINT&quot;);
 257             }
 258             break;
 259         case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
 260             {
 261                 strcpy(opName, &quot;SET_LINEAR_GRADIENT_PAINT&quot;);
 262             }
 263             break;
 264         case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
 265             {
 266                 strcpy(opName, &quot;SET_RADIAL_GRADIENT_PAINT&quot;);
 267             }
 268             break;
 269         case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
 270             {
 271                 strcpy(opName, &quot;SET_TEXTURE_PAINT&quot;);
 272             }
 273             break;
 274         case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
 275             {
 276                 strcpy(opName, &quot;ENABLE_CONVOLVE_OP&quot;);
 277             }
 278             break;
 279         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
 280             {
 281                 strcpy(opName, &quot;DISABLE_CONVOLVE_OP&quot;);
 282             }
 283             break;
 284         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
 285             {
 286                 strcpy(opName, &quot;ENABLE_RESCALE_OP&quot;);
 287             }
 288             break;
 289         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
 290             {
 291                  strcpy(opName, &quot;DISABLE_RESCALE_OP&quot;);
 292             }
 293             break;
 294         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
 295             {
 296                 strcpy(opName, &quot;ENABLE_LOOKUP_OP&quot;);
 297             }
 298             break;
 299         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
 300             {
 301                 strcpy(opName, &quot;DISABLE_LOOKUP_OP&quot;);
 302             }
 303             break;
 304         default:
 305             strcpy(opName, &quot;UNKNOWN&quot;);
 306             break;
 307         }
 308     return opName;
 309 }
 310 
 311 void MTLRenderQueue_CheckPreviousOp(jint op) {
 312 
 313     if (mtlPreviousOp == op) {
 314         // The op is the same as last time, so we can return immediately.
 315         return;
 316     }
 317 
 318     J2dTraceLn1(J2D_TRACE_VERBOSE,
 319                 &quot;MTLRenderQueue_CheckPreviousOp: new op=%d&quot;, op);
 320 
 321     if (op == MTL_OP_SET_COLOR) {
 322         return; // SET_COLOR should not cause endEncoder
 323     }
 324 
 325     if (mtlPreviousOp == MTL_OP_INIT) {
 326         mtlPreviousOp = op;
 327         return;
 328     }
 329 
 330     if (mtlc != NULL) {
 331         [mtlc.encoderManager endEncoder];
 332 
 333         if (op == MTL_OP_RESET_PAINT || op == MTL_OP_SYNC) {
 334             MTLCommandBufferWrapper *cbwrapper = [mtlc pullCommandBufferWrapper];
 335             id &lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
 336             [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
 337                 [cbwrapper release];
 338             }];
 339             [commandbuf commit];
 340             if (op == MTL_OP_SYNC) {
 341                 [commandbuf waitUntilCompleted];
 342             }
 343         }
 344     }
 345     mtlPreviousOp = op;
 346 }
 347 
 348 JNIEXPORT void JNICALL
 349 Java_sun_java2d_metal_MTLRenderQueue_flushBuffer
 350     (JNIEnv *env, jobject mtlrq,
 351      jlong buf, jint limit)
 352 {
 353     unsigned char *b, *end;
 354 
 355     J2dTraceLn1(J2D_TRACE_INFO,
 356                 &quot;MTLRenderQueue_flushBuffer: limit=%d&quot;, limit);
 357 
 358     b = (unsigned char *)jlong_to_ptr(buf);
 359     if (b == NULL) {
 360         J2dRlsTraceLn(J2D_TRACE_ERROR,
 361             &quot;MTLRenderQueue_flushBuffer: cannot get direct buffer address&quot;);
 362         return;
 363     }
 364 
 365     end = b + limit;
 366 
 367     jboolean DEBUG_LOG = JNI_FALSE;
 368     while (b &lt; end) {
 369         jint opcode = NEXT_INT(b);
 370 
 371         if (DEBUG_LOG) {
 372             J2dTraceLn2(J2D_TRACE_ERROR,
 373                     &quot;MTLRenderQueue_flushBuffer: opcode_name = %s, rem=%d&quot;,
 374                     getOpcodeString(opcode), (end-b));
 375         } else {
 376             J2dTraceLn2(J2D_TRACE_VERBOSE,
 377                     &quot;MTLRenderQueue_flushBuffer: opcode=%d, rem=%d&quot;,
 378                     opcode, (end-b));
 379         }
 380 
 381         switch (opcode) {
 382 
 383         // draw ops
 384         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
 385             {
 386                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 387 
 388                 if ([mtlc useXORComposite]) {
 389                     commitEncodedCommands();
 390                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_LINE in XOR mode - Force commit earlier draw calls before DRAW_LINE.&quot;);
 391                 }
 392                 jint x1 = NEXT_INT(b);
 393                 jint y1 = NEXT_INT(b);
 394                 jint x2 = NEXT_INT(b);
 395                 jint y2 = NEXT_INT(b);
 396                 MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);
 397             }
 398             break;
 399         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
 400             {
 401                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 402 
 403                 if ([mtlc useXORComposite]) {
 404                     commitEncodedCommands();
 405                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_RECT in XOR mode - Force commit earlier draw calls before DRAW_RECT.&quot;);
 406                 }
 407                 jint x = NEXT_INT(b);
 408                 jint y = NEXT_INT(b);
 409                 jint w = NEXT_INT(b);
 410                 jint h = NEXT_INT(b);
 411                 MTLRenderer_DrawRect(mtlc, dstOps, x, y, w, h);
 412             }
 413             break;
 414         case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
 415             {
 416                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
<a name="1" id="anc1"></a><span class="line-removed"> 417 </span>
<span class="line-removed"> 418                 if ([mtlc useXORComposite]) {</span>
<span class="line-removed"> 419                     commitEncodedCommands();</span>
<span class="line-removed"> 420                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_POLY in XOR mode - Force commit earlier draw calls before DRAW_POLY.&quot;);</span>
<span class="line-removed"> 421                 }</span>
<span class="line-removed"> 422 </span>
 423                 jint nPoints      = NEXT_INT(b);
 424                 jboolean isClosed = NEXT_BOOLEAN(b);
 425                 jint transX       = NEXT_INT(b);
 426                 jint transY       = NEXT_INT(b);
 427                 jint *xPoints = (jint *)b;
 428                 jint *yPoints = ((jint *)b) + nPoints;
<a name="2" id="anc2"></a><span class="line-modified"> 429                 MTLRenderer_DrawPoly(mtlc, dstOps, nPoints, isClosed, transX, transY, xPoints, yPoints);</span>




















 430                 SKIP_BYTES(b, nPoints * BYTES_PER_POLY_POINT);
 431             }
 432             break;
 433         case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
 434             {
 435                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 436 
 437                 if ([mtlc useXORComposite]) {
 438                     commitEncodedCommands();
 439                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_PIXEL in XOR mode - Force commit earlier draw calls before DRAW_PIXEL.&quot;);
 440                 }
 441 
 442                 jint x = NEXT_INT(b);
 443                 jint y = NEXT_INT(b);
 444                 CONTINUE_IF_NULL(mtlc);
 445                 MTLRenderer_DrawPixel(mtlc, dstOps, x, y);
 446             }
 447             break;
 448         case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
 449             {
 450                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 451 
 452                 if ([mtlc useXORComposite]) {
 453                     commitEncodedCommands();
 454                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_SCANLINES in XOR mode - Force commit earlier draw calls before DRAW_SCANLINES.&quot;);
 455                 }
 456 
 457                 jint count = NEXT_INT(b);
 458                 MTLRenderer_DrawScanlines(mtlc, dstOps, count, (jint *)b);
 459 
 460                 SKIP_BYTES(b, count * BYTES_PER_SCANLINE);
 461             }
 462             break;
 463         case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
 464             {
 465                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 466 
 467                 if ([mtlc useXORComposite]) {
 468                     commitEncodedCommands();
 469                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_PARALLELOGRAM in XOR mode - Force commit earlier draw calls before DRAW_PARALLELOGRAM.&quot;);
 470                 }
 471 
 472                 jfloat x11 = NEXT_FLOAT(b);
 473                 jfloat y11 = NEXT_FLOAT(b);
 474                 jfloat dx21 = NEXT_FLOAT(b);
 475                 jfloat dy21 = NEXT_FLOAT(b);
 476                 jfloat dx12 = NEXT_FLOAT(b);
 477                 jfloat dy12 = NEXT_FLOAT(b);
 478                 jfloat lwr21 = NEXT_FLOAT(b);
 479                 jfloat lwr12 = NEXT_FLOAT(b);
 480 
 481                 MTLRenderer_DrawParallelogram(mtlc, dstOps,
 482                                               x11, y11,
 483                                               dx21, dy21,
 484                                               dx12, dy12,
 485                                               lwr21, lwr12);
 486             }
 487             break;
 488         case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
 489             {
 490                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 491                 jfloat x11 = NEXT_FLOAT(b);
 492                 jfloat y11 = NEXT_FLOAT(b);
 493                 jfloat dx21 = NEXT_FLOAT(b);
 494                 jfloat dy21 = NEXT_FLOAT(b);
 495                 jfloat dx12 = NEXT_FLOAT(b);
 496                 jfloat dy12 = NEXT_FLOAT(b);
 497                 jfloat lwr21 = NEXT_FLOAT(b);
 498                 jfloat lwr12 = NEXT_FLOAT(b);
 499 
 500                 MTLRenderer_DrawAAParallelogram(mtlc, dstOps,
 501                                                 x11, y11,
 502                                                 dx21, dy21,
 503                                                 dx12, dy12,
 504                                                 lwr21, lwr12);
 505             }
 506             break;
 507 
 508         // fill ops
 509         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
 510             {
 511                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 512 
 513                 if ([mtlc useXORComposite]) {
 514                     commitEncodedCommands();
 515                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;FILL_RECT in XOR mode - Force commit earlier draw calls before FILL_RECT.&quot;);
 516                 }
 517 
 518                 jint x = NEXT_INT(b);
 519                 jint y = NEXT_INT(b);
 520                 jint w = NEXT_INT(b);
 521                 jint h = NEXT_INT(b);
 522                 MTLRenderer_FillRect(mtlc, dstOps, x, y, w, h);
 523             }
 524             break;
 525         case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
 526             {
 527                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 528 
 529                 if ([mtlc useXORComposite]) {
 530                     commitEncodedCommands();
 531                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;FILL_SPANS in XOR mode - Force commit earlier draw calls before FILL_SPANS.&quot;);
 532                 }
 533 
 534                 jint count = NEXT_INT(b);
 535                 MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
 536                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
 537             }
 538             break;
 539         case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
 540             {
 541                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 542 
 543                 if ([mtlc useXORComposite]) {
 544                     commitEncodedCommands();
 545                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;FILL_PARALLELOGRAM in XOR mode - Force commit earlier draw calls before FILL_PARALLELOGRAM.&quot;);
 546                 }
 547 
 548                 jfloat x11 = NEXT_FLOAT(b);
 549                 jfloat y11 = NEXT_FLOAT(b);
 550                 jfloat dx21 = NEXT_FLOAT(b);
 551                 jfloat dy21 = NEXT_FLOAT(b);
 552                 jfloat dx12 = NEXT_FLOAT(b);
 553                 jfloat dy12 = NEXT_FLOAT(b);
 554                 MTLRenderer_FillParallelogram(mtlc, dstOps,
 555                                               x11, y11,
 556                                               dx21, dy21,
 557                                               dx12, dy12);
 558             }
 559             break;
 560         case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
 561             {
 562                 CHECK_PREVIOUS_OP(MTL_OP_AA);
 563                 jfloat x11 = NEXT_FLOAT(b);
 564                 jfloat y11 = NEXT_FLOAT(b);
 565                 jfloat dx21 = NEXT_FLOAT(b);
 566                 jfloat dy21 = NEXT_FLOAT(b);
 567                 jfloat dx12 = NEXT_FLOAT(b);
 568                 jfloat dy12 = NEXT_FLOAT(b);
 569                 MTLRenderer_FillAAParallelogram(mtlc, dstOps,
 570                                                 x11, y11,
 571                                                 dx21, dy21,
 572                                                 dx12, dy12);
 573             }
 574             break;
 575 
 576         // text-related ops
 577         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
 578             {
 579                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 580 
 581                 if ([mtlc useXORComposite]) {
 582                     commitEncodedCommands();
 583                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_GLYPH_LIST in XOR mode - Force commit earlier draw calls before DRAW_GLYPH_LIST.&quot;);
 584                 }
 585 
 586                 jint numGlyphs        = NEXT_INT(b);
 587                 jint packedParams     = NEXT_INT(b);
 588                 jfloat glyphListOrigX = NEXT_FLOAT(b);
 589                 jfloat glyphListOrigY = NEXT_FLOAT(b);
 590                 jboolean usePositions = EXTRACT_BOOLEAN(packedParams,
 591                                                         OFFSET_POSITIONS);
 592                 jboolean subPixPos    = EXTRACT_BOOLEAN(packedParams,
 593                                                         OFFSET_SUBPIXPOS);
 594                 jboolean rgbOrder     = EXTRACT_BOOLEAN(packedParams,
 595                                                         OFFSET_RGBORDER);
 596                 jint lcdContrast      = EXTRACT_BYTE(packedParams,
 597                                                      OFFSET_CONTRAST);
 598                 unsigned char *images = b;
 599                 unsigned char *positions;
 600                 jint bytesPerGlyph;
 601                 if (usePositions) {
 602                     positions = (b + numGlyphs * BYTES_PER_GLYPH_IMAGE);
 603                     bytesPerGlyph = BYTES_PER_POSITIONED_GLYPH;
 604                 } else {
 605                     positions = NULL;
 606                     bytesPerGlyph = BYTES_PER_GLYPH_IMAGE;
 607                 }
 608                 MTLTR_DrawGlyphList(env, mtlc, dstOps,
 609                                     numGlyphs, usePositions,
 610                                     subPixPos, rgbOrder, lcdContrast,
 611                                     glyphListOrigX, glyphListOrigY,
 612                                     images, positions);
 613                 SKIP_BYTES(b, numGlyphs * bytesPerGlyph);
 614             }
 615             break;
 616 
 617         // copy-related ops
 618         case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
 619             {
 620                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 621                 jint x  = NEXT_INT(b);
 622                 jint y  = NEXT_INT(b);
 623                 jint w  = NEXT_INT(b);
 624                 jint h  = NEXT_INT(b);
 625                 jint dx = NEXT_INT(b);
 626                 jint dy = NEXT_INT(b);
 627                 MTLBlitLoops_CopyArea(env, mtlc, dstOps,
 628                                       x, y, w, h, dx, dy);
 629             }
 630             break;
 631         case sun_java2d_pipe_BufferedOpCodes_BLIT:
 632             {
 633                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 634                 jint packedParams = NEXT_INT(b);
 635                 jint sx1          = NEXT_INT(b);
 636                 jint sy1          = NEXT_INT(b);
 637                 jint sx2          = NEXT_INT(b);
 638                 jint sy2          = NEXT_INT(b);
 639                 jdouble dx1       = NEXT_DOUBLE(b);
 640                 jdouble dy1       = NEXT_DOUBLE(b);
 641                 jdouble dx2       = NEXT_DOUBLE(b);
 642                 jdouble dy2       = NEXT_DOUBLE(b);
 643                 jlong pSrc        = NEXT_LONG(b);
 644                 jlong pDst        = NEXT_LONG(b);
 645                 jint hint         = EXTRACT_BYTE(packedParams, OFFSET_HINT);
 646                 jboolean texture  = EXTRACT_BOOLEAN(packedParams,
 647                                                     OFFSET_TEXTURE);
 648                 jboolean xform    = EXTRACT_BOOLEAN(packedParams,
 649                                                     OFFSET_XFORM);
 650                 jboolean isoblit  = EXTRACT_BOOLEAN(packedParams,
 651                                                     OFFSET_ISOBLIT);
 652                 if (isoblit) {
 653                     MTLBlitLoops_IsoBlit(env, mtlc, pSrc, pDst,
 654                                          xform, hint, texture,
 655                                          sx1, sy1, sx2, sy2,
 656                                          dx1, dy1, dx2, dy2);
 657                 } else {
 658                     jint srctype = EXTRACT_BYTE(packedParams, OFFSET_SRCTYPE);
 659                     MTLBlitLoops_Blit(env, mtlc, pSrc, pDst,
 660                                       xform, hint, srctype, texture,
 661                                       sx1, sy1, sx2, sy2,
 662                                       dx1, dy1, dx2, dy2);
 663                 }
 664             }
 665             break;
 666         case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
 667             {
 668                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 669                 jint sx      = NEXT_INT(b);
 670                 jint sy      = NEXT_INT(b);
 671                 jint dx      = NEXT_INT(b);
 672                 jint dy      = NEXT_INT(b);
 673                 jint w       = NEXT_INT(b);
 674                 jint h       = NEXT_INT(b);
 675                 jint dsttype = NEXT_INT(b);
 676                 jlong pSrc   = NEXT_LONG(b);
 677                 jlong pDst   = NEXT_LONG(b);
 678                 MTLBlitLoops_SurfaceToSwBlit(env, mtlc,
 679                                              pSrc, pDst, dsttype,
 680                                              sx, sy, dx, dy, w, h);
 681             }
 682             break;
 683         case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
 684             {
 685                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 686                 jint x        = NEXT_INT(b);
 687                 jint y        = NEXT_INT(b);
 688                 jint w        = NEXT_INT(b);
 689                 jint h        = NEXT_INT(b);
 690                 jint maskoff  = NEXT_INT(b);
 691                 jint maskscan = NEXT_INT(b);
 692                 jint masklen  = NEXT_INT(b);
 693                 unsigned char *pMask = (masklen &gt; 0) ? b : NULL;
 694                 MTLMaskFill_MaskFill(mtlc, dstOps, x, y, w, h,
 695                                      maskoff, maskscan, masklen, pMask);
 696                 SKIP_BYTES(b, masklen);
 697             }
 698             break;
 699         case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
 700             {
 701                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 702                 jint dstx     = NEXT_INT(b);
 703                 jint dsty     = NEXT_INT(b);
 704                 jint width    = NEXT_INT(b);
 705                 jint height   = NEXT_INT(b);
 706                 jint masklen  = width * height * sizeof(jint);
 707                 MTLMaskBlit_MaskBlit(env, mtlc, dstOps,
 708                                      dstx, dsty, width, height, b);
 709                 SKIP_BYTES(b, masklen);
 710             }
 711             break;
 712 
 713         // state-related ops
 714         case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
 715             {
 716                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 717                 jint x1 = NEXT_INT(b);
 718                 jint y1 = NEXT_INT(b);
 719                 jint x2 = NEXT_INT(b);
 720                 jint y2 = NEXT_INT(b);
 721                 [mtlc setClipRectX1:x1 Y1:y1 X2:x2 Y2:y2];
 722             }
 723             break;
 724         case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
 725             {
 726                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 727                 [mtlc beginShapeClip:dstOps];
 728             }
 729             break;
 730         case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
 731             {
 732                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 733                 // This results in creation of new render encoder with
 734                 // stencil buffer set as render target
 735                 jint count = NEXT_INT(b);
 736                 MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
 737                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
 738             }
 739             break;
 740         case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
 741             {
 742                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 743                 [mtlc endShapeClip:dstOps];
 744             }
 745             break;
 746         case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
 747             {
 748                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 749                 [mtlc resetClip];
 750             }
 751             break;
 752         case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
 753             {
 754                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 755                 jint rule         = NEXT_INT(b);
 756                 jfloat extraAlpha = NEXT_FLOAT(b);
 757                 jint flags        = NEXT_INT(b);
 758                 [mtlc setAlphaCompositeRule:rule extraAlpha:extraAlpha flags:flags];
 759             }
 760             break;
 761         case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
 762             {
 763                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 764                 jint xorPixel = NEXT_INT(b);
 765                 [mtlc setXorComposite:xorPixel];
 766             }
 767             break;
 768         case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
 769             {
 770                 /* TODO: check whether something needs to be done here if we are moving out of XOR composite
 771                 commitEncodedCommands();
 772                 MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
 773                 [cbwrapper onComplete];
 774 
 775                 J2dTraceLn(J2D_TRACE_VERBOSE, &quot;RESET_COMPOSITE - Force commit earlier draw calls before RESET_COMPOSITE.&quot;);*/
 776 
 777                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 778                 [mtlc resetComposite];
 779             }
 780             break;
 781         case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
 782             {
 783                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 784                 jdouble m00 = NEXT_DOUBLE(b);
 785                 jdouble m10 = NEXT_DOUBLE(b);
 786                 jdouble m01 = NEXT_DOUBLE(b);
 787                 jdouble m11 = NEXT_DOUBLE(b);
 788                 jdouble m02 = NEXT_DOUBLE(b);
 789                 jdouble m12 = NEXT_DOUBLE(b);
 790                 [mtlc setTransformM00:m00 M10:m10 M01:m01 M11:m11 M02:m02 M12:m12];
 791             }
 792             break;
 793         case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
 794             {
 795                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 796                 [mtlc resetTransform];
 797             }
 798             break;
 799 
 800         // context-related ops
 801         case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
 802             {
 803                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 804                 jlong pSrc = NEXT_LONG(b);
 805                 jlong pDst = NEXT_LONG(b);
 806 
 807                 dstOps = (BMTLSDOps *)jlong_to_ptr(pDst);
 808                 mtlc = [MTLContext setSurfacesEnv:env src:pSrc dst:pDst];
 809             }
 810             break;
 811         case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
 812             {
 813                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 814                 jlong pConfigInfo = NEXT_LONG(b);
 815                 MTLGraphicsConfigInfo *mtlInfo =
 816                         (MTLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);
 817 
 818                 if (mtlInfo == NULL) {
 819 
 820                 } else {
 821                     MTLContext *newMtlc = mtlInfo-&gt;context;
 822                     if (newMtlc == NULL) {
 823 
 824                     } else {
 825                         mtlc = newMtlc;
 826                         dstOps = NULL;
 827                     }
 828                 }
 829             }
 830             break;
 831         case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
 832             {
 833                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 834                 jlong pData = NEXT_LONG(b);
 835                 BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
 836                 if (mtlsdo != NULL) {
 837                     CONTINUE_IF_NULL(mtlc);
 838                     MTLSD_Delete(env, mtlsdo);
 839                 }
 840             }
 841             break;
 842         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
 843             {
 844                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 845                 jlong pData = NEXT_LONG(b);
 846                 BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
 847                 if (mtlsdo != NULL) {
 848                     CONTINUE_IF_NULL(mtlc);
 849                     MTLSD_Delete(env, mtlsdo);
 850                     if (mtlsdo-&gt;privOps != NULL) {
 851                         free(mtlsdo-&gt;privOps);
 852                     }
 853                 }
 854             }
 855             break;
 856         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
 857             {
 858                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 859                 jlong pConfigInfo = NEXT_LONG(b);
 860                 CONTINUE_IF_NULL(mtlc);
 861                 MTLGC_DestroyMTLGraphicsConfig(pConfigInfo);
 862 
 863                 // the previous method will call glX/wglMakeCurrent(None),
 864                 // so we should nullify the current mtlc and dstOps to avoid
 865                 // calling glFlush() (or similar) while no context is current
 866                 mtlc = NULL;
 867              //   dstOps = NULL;
 868             }
 869             break;
 870         case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
 871             {
 872                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 873                 // invalidate the references to the current context and
 874                 // destination surface that are maintained at the native level
 875                 mtlc = NULL;
 876             //    dstOps = NULL;
 877             }
 878             break;
 879         case sun_java2d_pipe_BufferedOpCodes_SYNC:
 880             {
 881                 CHECK_PREVIOUS_OP(MTL_OP_SYNC);
 882             }
 883             break;
 884 
 885         // multibuffering ops
 886         case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
 887             {
 888                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 889                 jlong window = NEXT_LONG(b);
 890                 MTLSD_SwapBuffers(env, window);
 891             }
 892             break;
 893 
 894         // special no-op (mainly used for achieving 8-byte alignment)
 895         case sun_java2d_pipe_BufferedOpCodes_NOOP:
 896             break;
 897 
 898         // paint-related ops
 899         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
 900             {
 901               CHECK_PREVIOUS_OP(MTL_OP_RESET_PAINT);
 902               [mtlc resetPaint];
 903             }
 904             break;
 905         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
 906             {
 907                 CHECK_PREVIOUS_OP(MTL_OP_SET_COLOR);
 908                 jint pixel = NEXT_INT(b);
 909                 [mtlc setColorPaint:pixel];
 910             }
 911             break;
 912         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
 913             {
 914                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 915                 jboolean useMask= NEXT_BOOLEAN(b);
 916                 jboolean cyclic = NEXT_BOOLEAN(b);
 917                 jdouble p0      = NEXT_DOUBLE(b);
 918                 jdouble p1      = NEXT_DOUBLE(b);
 919                 jdouble p3      = NEXT_DOUBLE(b);
 920                 jint pixel1     = NEXT_INT(b);
 921                 jint pixel2     = NEXT_INT(b);
 922                 [mtlc setGradientPaintUseMask:useMask
 923                                     cyclic:cyclic
 924                                         p0:p0
 925                                         p1:p1
 926                                         p3:p3
 927                                     pixel1:pixel1
 928                                     pixel2:pixel2];
 929             }
 930             break;
 931         case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
 932             {
 933                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 934                 jboolean useMask = NEXT_BOOLEAN(b);
 935                 jboolean linear  = NEXT_BOOLEAN(b);
 936                 jint cycleMethod = NEXT_INT(b);
 937                 jint numStops    = NEXT_INT(b);
 938                 jfloat p0        = NEXT_FLOAT(b);
 939                 jfloat p1        = NEXT_FLOAT(b);
 940                 jfloat p3        = NEXT_FLOAT(b);
 941                 void *fractions, *pixels;
 942                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
 943                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
 944                 [mtlc setLinearGradientPaint:useMask
 945                                       linear:linear
 946                                  cycleMethod:cycleMethod
 947                                     numStops:numStops
 948                                           p0:p0
 949                                           p1:p1
 950                                           p3:p3
 951                                    fractions:fractions
 952                                       pixels:pixels];
 953             }
 954             break;
 955         case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
 956             {
 957                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 958                 jboolean useMask = NEXT_BOOLEAN(b);
 959                 jboolean linear  = NEXT_BOOLEAN(b);
 960                 jint numStops    = NEXT_INT(b);
 961                 jint cycleMethod = NEXT_INT(b);
 962                 jfloat m00       = NEXT_FLOAT(b);
 963                 jfloat m01       = NEXT_FLOAT(b);
 964                 jfloat m02       = NEXT_FLOAT(b);
 965                 jfloat m10       = NEXT_FLOAT(b);
 966                 jfloat m11       = NEXT_FLOAT(b);
 967                 jfloat m12       = NEXT_FLOAT(b);
 968                 jfloat focusX    = NEXT_FLOAT(b);
 969                 void *fractions, *pixels;
 970                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
 971                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
 972                 [mtlc setRadialGradientPaint:useMask
 973                                       linear:linear
 974                                  cycleMethod:cycleMethod
 975                                     numStops:numStops
 976                                          m00:m00
 977                                          m01:m01
 978                                          m02:m02
 979                                          m10:m10
 980                                          m11:m11
 981                                          m12:m12
 982                                       focusX:focusX
 983                                    fractions:fractions
 984                                       pixels:pixels];
 985             }
 986             break;
 987         case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
 988             {
 989                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 990                 jboolean useMask= NEXT_BOOLEAN(b);
 991                 jboolean filter = NEXT_BOOLEAN(b);
 992                 jlong pSrc      = NEXT_LONG(b);
 993                 jdouble xp0     = NEXT_DOUBLE(b);
 994                 jdouble xp1     = NEXT_DOUBLE(b);
 995                 jdouble xp3     = NEXT_DOUBLE(b);
 996                 jdouble yp0     = NEXT_DOUBLE(b);
 997                 jdouble yp1     = NEXT_DOUBLE(b);
 998                 jdouble yp3     = NEXT_DOUBLE(b);
 999                 [mtlc setTexturePaint:useMask
1000                               pSrcOps:pSrc
1001                                filter:filter
1002                                   xp0:xp0
1003                                   xp1:xp1
1004                                   xp3:xp3
1005                                   yp0:yp0
1006                                   yp1:yp1
1007                                   yp3:yp3];
1008             }
1009             break;
1010 
1011         // BufferedImageOp-related ops
1012         case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
1013             {
1014                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1015                 jlong pSrc        = NEXT_LONG(b);
1016                 jboolean edgeZero = NEXT_BOOLEAN(b);
1017                 jint kernelWidth  = NEXT_INT(b);
1018                 jint kernelHeight = NEXT_INT(b);
1019 
1020                 BMTLSDOps * bmtlsdOps = (BMTLSDOps *)pSrc;
1021                 MTLConvolveOp * convolveOp = [[MTLConvolveOp alloc] init:edgeZero
1022                         kernelWidth:kernelWidth
1023                        kernelHeight:kernelHeight
1024                            srcWidth:bmtlsdOps-&gt;width
1025                           srcHeight:bmtlsdOps-&gt;height
1026                              kernel:b
1027                              device:mtlc.device
1028                                               ];
1029                 [mtlc setBufImgOp:convolveOp];
1030                 SKIP_BYTES(b, kernelWidth * kernelHeight * sizeof(jfloat));
1031             }
1032             break;
1033         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
1034             {
1035                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1036                 [mtlc setBufImgOp:NULL];
1037             }
1038             break;
1039         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
1040             {
1041                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1042                 jlong pSrc          = NEXT_LONG(b);
1043                 jboolean nonPremult = NEXT_BOOLEAN(b);
1044                 jint numFactors     = 4;
1045                 unsigned char *scaleFactors = b;
1046                 unsigned char *offsets = (b + numFactors * sizeof(jfloat));
1047                 MTLRescaleOp * rescaleOp = [[MTLRescaleOp alloc] init:nonPremult factors:scaleFactors offsets:offsets];
1048                 [mtlc setBufImgOp:rescaleOp];
1049                 SKIP_BYTES(b, numFactors * sizeof(jfloat) * 2);
1050             }
1051             break;
1052         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
1053             {
1054                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1055                 [mtlc setBufImgOp:NULL];
1056             }
1057             break;
1058         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
1059             {
1060                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1061                 jlong pSrc          = NEXT_LONG(b);
1062                 jboolean nonPremult = NEXT_BOOLEAN(b);
1063                 jboolean shortData  = NEXT_BOOLEAN(b);
1064                 jint numBands       = NEXT_INT(b);
1065                 jint bandLength     = NEXT_INT(b);
1066                 jint offset         = NEXT_INT(b);
1067                 jint bytesPerElem = shortData ? sizeof(jshort):sizeof(jbyte);
1068                 void *tableValues = b;
1069 
1070                 MTLLookupOp * lookupOp = [[MTLLookupOp alloc] init:nonPremult
1071                                                          shortData:shortData
1072                                                           numBands:numBands
1073                                                         bandLength:bandLength
1074                                                             offset:offset
1075                                                        tableValues:tableValues
1076                                                             device:mtlc.device];
1077                 [mtlc setBufImgOp:lookupOp];
1078                 SKIP_BYTES(b, numBands * bandLength * bytesPerElem);
1079             }
1080             break;
1081         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
1082             {
1083                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1084                 [mtlc setBufImgOp:NULL];
1085             }
1086             break;
1087 
1088         default:
1089             J2dRlsTraceLn1(J2D_TRACE_ERROR,
1090                 &quot;MTLRenderQueue_flushBuffer: invalid opcode=%d&quot;, opcode);
1091             return;
1092         }
1093     }
1094 
1095     if (mtlc != NULL) {
1096         [mtlc.encoderManager endEncoder];
1097         MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
1098         id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
1099         [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
1100             [cbwrapper release];
1101         }];
1102         [commandbuf commit];
1103         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
1104         if (dstOps != NULL) {
1105             MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps-&gt;privOps;
1106             MTLLayer *layer = (MTLLayer*)dstMTLOps-&gt;layer;
1107             if (layer != NULL) {
1108                 [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){
1109                     AWT_ASSERT_APPKIT_THREAD;
1110                     [layer setNeedsDisplay];
1111                 }];
1112             }
1113         }
1114     }
1115     RESET_PREVIOUS_OP();
1116 }
1117 
1118 /**
1119  * Returns a pointer to the &quot;current&quot; context, as set by the last SET_SURFACES
1120  * or SET_SCRATCH_SURFACE operation.
1121  */
1122 MTLContext *
1123 MTLRenderQueue_GetCurrentContext()
1124 {
1125     return mtlc;
1126 }
1127 
1128 /**
1129  * Returns a pointer to the &quot;current&quot; destination surface, as set by the last
1130  * SET_SURFACES operation.
1131  */
1132 BMTLSDOps *
1133 MTLRenderQueue_GetCurrentDestination()
1134 {
1135     return dstOps;
1136 }
1137 
1138 /**
1139  * commit earlier encoded commmands
1140  * these would be rendered to the back-buffer - which is read in shader while rendering in XOR mode
1141  */
1142 void commitEncodedCommands() {
1143     [mtlc.encoderManager endEncoder];
1144 
1145     MTLCommandBufferWrapper *cbwrapper = [mtlc pullCommandBufferWrapper];
1146     id &lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
1147     [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
1148         [cbwrapper release];
1149     }];
1150     [commandbuf commit];
1151     [commandbuf waitUntilCompleted];
1152 }
1153 
1154 #endif /* !HEADLESS */
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>