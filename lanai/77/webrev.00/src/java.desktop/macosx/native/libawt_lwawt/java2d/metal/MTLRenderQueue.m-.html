<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifndef HEADLESS
  27 
  28 #include &lt;stdlib.h&gt;
  29 
  30 #include &quot;sun_java2d_pipe_BufferedOpCodes.h&quot;
  31 
  32 #include &quot;jlong.h&quot;
  33 #include &quot;MTLBlitLoops.h&quot;
  34 #include &quot;MTLBufImgOps.h&quot;
  35 #include &quot;MTLMaskBlit.h&quot;
  36 #include &quot;MTLMaskFill.h&quot;
  37 #include &quot;MTLPaints.h&quot;
  38 #include &quot;MTLRenderQueue.h&quot;
  39 #include &quot;MTLRenderer.h&quot;
  40 #include &quot;MTLTextRenderer.h&quot;
  41 #import &quot;ThreadUtilities.h&quot;
  42 
  43 /**
  44  * References to the &quot;current&quot; context and destination surface.
  45  */
  46 static MTLContext *mtlc = NULL;
  47 static BMTLSDOps *dstOps = NULL;
  48 jint mtlPreviousOp = MTL_OP_INIT;
  49 
  50 
  51 /**
  52  * The following methods are implemented in the windowing system (i.e. GLX
  53  * and WGL) source files.
  54  */
  55 extern void MTLGC_DestroyMTLGraphicsConfig(jlong pConfigInfo);
  56 extern void MTLSD_SwapBuffers(JNIEnv *env, jlong window);
  57 
  58 // TODO : Debug logic added for opcode verification,
  59 // should be removed later.
  60 static char *getOpcodeString(jint opcode) {
  61     static char opName[30];
  62     switch (opcode) {
  63         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
  64             {
  65                 strcpy(opName, &quot;DRAW_LINE&quot;);
  66             }
  67             break;
  68         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
  69             {
  70                 strcpy(opName, &quot;DRAW_RECT&quot;);
  71             }
  72             break;
  73         case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
  74             {
  75                 strcpy(opName, &quot;DRAW_POLY&quot;);
  76             }
  77             break;
  78         case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
  79             {
  80                 strcpy(opName, &quot;DRAW_PIXEL&quot;);
  81             }
  82             break;
  83         case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
  84             {
  85                 strcpy(opName, &quot;DRAW_SCANLINES&quot;);
  86             }
  87             break;
  88         case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
  89             {
  90                 strcpy(opName, &quot;DRAW_PARALLELOGRAM&quot;);
  91             }
  92             break;
  93         case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
  94             {
  95                 strcpy(opName, &quot;DRAW_AAPARALLELOGRAM&quot;);
  96             }
  97             break;
  98         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
  99             {
 100                 strcpy(opName, &quot;FILL_RECT&quot;);
 101             }
 102             break;
 103         case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
 104             {
 105                 strcpy(opName, &quot;FILL_SPANS&quot;);
 106             }
 107             break;
 108         case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
 109             {
 110                 strcpy(opName, &quot;FILL_PARALLELOGRAM&quot;);
 111             }
 112             break;
 113         case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
 114             {
 115                 strcpy(opName, &quot;FILL_AAPARALLELOGRAM&quot;);
 116             }
 117             break;
 118         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
 119             {
 120                 strcpy(opName, &quot;DRAW_GLYPH_LIST&quot;);
 121             }
 122             break;
 123         case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
 124             {
 125                 strcpy(opName, &quot;COPY_AREA&quot;);
 126             }
 127             break;
 128         case sun_java2d_pipe_BufferedOpCodes_BLIT:
 129             {
 130                 strcpy(opName, &quot;BLIT&quot;);
 131             }
 132             break;
 133         case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
 134             {
 135                 strcpy(opName, &quot;SURFACE_TO_SW_BLIT&quot;);
 136             }
 137             break;
 138         case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
 139             {
 140                 strcpy(opName, &quot;MASK_FILL&quot;);
 141             }
 142             break;
 143         case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
 144             {
 145 
 146                 strcpy(opName, &quot;MASK_BLIT&quot;);
 147             }
 148             break;
 149         case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
 150             {
 151                 strcpy(opName, &quot;SET_RECT_CLIP&quot;);
 152             }
 153             break;
 154         case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
 155             {
 156                 strcpy(opName, &quot;BEGIN_SHAPE_CLIP&quot;);
 157             }
 158             break;
 159         case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
 160             {
 161                 strcpy(opName, &quot;SET_SHAPE_CLIP_SPANS&quot;);
 162             }
 163             break;
 164         case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
 165             {
 166                 strcpy(opName, &quot;END_SHAPE_CLIP&quot;);
 167             }
 168             break;
 169         case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
 170             {
 171                 strcpy(opName, &quot;RESET_CLIP&quot;);
 172             }
 173             break;
 174         case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
 175             {
 176                 strcpy(opName, &quot;SET_ALPHA_COMPOSITE&quot;);
 177             }
 178             break;
 179         case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
 180             {
 181                 strcpy(opName, &quot;SET_XOR_COMPOSITE&quot;);
 182             }
 183             break;
 184         case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
 185             {
 186                 strcpy(opName, &quot;RESET_COMPOSITE&quot;);
 187             }
 188             break;
 189         case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
 190             {
 191                 strcpy(opName, &quot;SET_TRANSFORM&quot;);
 192             }
 193             break;
 194         case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
 195             {
 196                 strcpy(opName, &quot;RESET_TRANSFORM&quot;);
 197             }
 198             break;
 199         case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
 200             {
 201 
 202                 strcpy(opName, &quot;SET_SURFACES&quot;);
 203             }
 204             break;
 205         case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
 206             {
 207                 strcpy(opName, &quot;SET_SCRATCH_SURFACE&quot;);
 208             }
 209             break;
 210         case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
 211             {
 212                 strcpy(opName, &quot;FLUSH_SURFACE&quot;);
 213             }
 214             break;
 215         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
 216             {
 217                 strcpy(opName, &quot;DISPOSE_SURFACE&quot;);
 218             }
 219             break;
 220         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
 221             {
 222                 strcpy(opName, &quot;DISPOSE_CONFIG&quot;);
 223             }
 224             break;
 225         case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
 226             {
 227                 strcpy(opName, &quot;INVALIDATE_CONTEXT&quot;);
 228             }
 229             break;
 230         case sun_java2d_pipe_BufferedOpCodes_SYNC:
 231             {
 232                 strcpy(opName, &quot;SYNC&quot;);
 233 
 234             }
 235             break;
 236         case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
 237             {
 238                 strcpy(opName, &quot;SWAP_BUFFERS&quot;);
 239             }
 240             break;
 241         case sun_java2d_pipe_BufferedOpCodes_NOOP:
 242             strcpy(opName, &quot;NOOP&quot;);
 243             break;
 244         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
 245             {
 246                 strcpy(opName, &quot;RESET_PAINT&quot;);
 247             }
 248             break;
 249         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
 250             {
 251                 strcpy(opName, &quot;SET_COLOR&quot;);
 252             }
 253             break;
 254         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
 255             {
 256                 strcpy(opName, &quot;SET_GRADIENT_PAINT&quot;);
 257             }
 258             break;
 259         case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
 260             {
 261                 strcpy(opName, &quot;SET_LINEAR_GRADIENT_PAINT&quot;);
 262             }
 263             break;
 264         case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
 265             {
 266                 strcpy(opName, &quot;SET_RADIAL_GRADIENT_PAINT&quot;);
 267             }
 268             break;
 269         case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
 270             {
 271                 strcpy(opName, &quot;SET_TEXTURE_PAINT&quot;);
 272             }
 273             break;
 274         case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
 275             {
 276                 strcpy(opName, &quot;ENABLE_CONVOLVE_OP&quot;);
 277             }
 278             break;
 279         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
 280             {
 281                 strcpy(opName, &quot;DISABLE_CONVOLVE_OP&quot;);
 282             }
 283             break;
 284         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
 285             {
 286                 strcpy(opName, &quot;ENABLE_RESCALE_OP&quot;);
 287             }
 288             break;
 289         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
 290             {
 291                  strcpy(opName, &quot;DISABLE_RESCALE_OP&quot;);
 292             }
 293             break;
 294         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
 295             {
 296                 strcpy(opName, &quot;ENABLE_LOOKUP_OP&quot;);
 297             }
 298             break;
 299         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
 300             {
 301                 strcpy(opName, &quot;DISABLE_LOOKUP_OP&quot;);
 302             }
 303             break;
 304         default:
 305             strcpy(opName, &quot;UNKNOWN&quot;);
 306             break;
 307         }
 308     return opName;
 309 }
 310 
 311 void MTLRenderQueue_CheckPreviousOp(jint op) {
 312 
 313     if (mtlPreviousOp == op) {
 314         // The op is the same as last time, so we can return immediately.
 315         return;
 316     }
 317 
 318     J2dTraceLn1(J2D_TRACE_VERBOSE,
 319                 &quot;MTLRenderQueue_CheckPreviousOp: new op=%d&quot;, op);
 320 
 321     if (op == MTL_OP_SET_COLOR) {
 322         return; // SET_COLOR should not cause endEncoder
 323     }
 324 
 325     if (mtlPreviousOp == MTL_OP_INIT) {
 326         mtlPreviousOp = op;
 327         return;
 328     }
 329 
 330     if (mtlc != NULL) {
 331         [mtlc.encoderManager endEncoder];
 332 
 333         if (op == MTL_OP_RESET_PAINT || op == MTL_OP_SYNC) {
 334             MTLCommandBufferWrapper *cbwrapper = [mtlc pullCommandBufferWrapper];
 335             id &lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
 336             [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
 337                 [cbwrapper release];
 338             }];
 339             [commandbuf commit];
 340             if (op == MTL_OP_SYNC) {
 341                 [commandbuf waitUntilCompleted];
 342             }
 343         }
 344     }
 345     mtlPreviousOp = op;
 346 }
 347 
 348 JNIEXPORT void JNICALL
 349 Java_sun_java2d_metal_MTLRenderQueue_flushBuffer
 350     (JNIEnv *env, jobject mtlrq,
 351      jlong buf, jint limit)
 352 {
 353     unsigned char *b, *end;
 354 
 355     J2dTraceLn1(J2D_TRACE_INFO,
 356                 &quot;MTLRenderQueue_flushBuffer: limit=%d&quot;, limit);
 357 
 358     b = (unsigned char *)jlong_to_ptr(buf);
 359     if (b == NULL) {
 360         J2dRlsTraceLn(J2D_TRACE_ERROR,
 361             &quot;MTLRenderQueue_flushBuffer: cannot get direct buffer address&quot;);
 362         return;
 363     }
 364 
 365     end = b + limit;
 366 
 367     jboolean DEBUG_LOG = JNI_FALSE;
 368     while (b &lt; end) {
 369         jint opcode = NEXT_INT(b);
 370 
 371         if (DEBUG_LOG) {
 372             J2dTraceLn2(J2D_TRACE_ERROR,
 373                     &quot;MTLRenderQueue_flushBuffer: opcode_name = %s, rem=%d&quot;,
 374                     getOpcodeString(opcode), (end-b));
 375         } else {
 376             J2dTraceLn2(J2D_TRACE_VERBOSE,
 377                     &quot;MTLRenderQueue_flushBuffer: opcode=%d, rem=%d&quot;,
 378                     opcode, (end-b));
 379         }
 380 
 381         switch (opcode) {
 382 
 383         // draw ops
 384         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
 385             {
 386                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 387 
 388                 if ([mtlc useXORComposite]) {
 389                     commitEncodedCommands();
 390                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_LINE in XOR mode - Force commit earlier draw calls before DRAW_LINE.&quot;);
 391                 }
 392                 jint x1 = NEXT_INT(b);
 393                 jint y1 = NEXT_INT(b);
 394                 jint x2 = NEXT_INT(b);
 395                 jint y2 = NEXT_INT(b);
 396                 MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);
 397             }
 398             break;
 399         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
 400             {
 401                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 402 
 403                 if ([mtlc useXORComposite]) {
 404                     commitEncodedCommands();
 405                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_RECT in XOR mode - Force commit earlier draw calls before DRAW_RECT.&quot;);
 406                 }
 407                 jint x = NEXT_INT(b);
 408                 jint y = NEXT_INT(b);
 409                 jint w = NEXT_INT(b);
 410                 jint h = NEXT_INT(b);
 411                 MTLRenderer_DrawRect(mtlc, dstOps, x, y, w, h);
 412             }
 413             break;
 414         case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
 415             {
 416                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 417                 jint nPoints      = NEXT_INT(b);
 418                 jboolean isClosed = NEXT_BOOLEAN(b);
 419                 jint transX       = NEXT_INT(b);
 420                 jint transY       = NEXT_INT(b);
 421                 jint *xPoints = (jint *)b;
 422                 jint *yPoints = ((jint *)b) + nPoints;
 423 
 424                 if ([mtlc useXORComposite]) {
 425                     commitEncodedCommands();
 426                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_POLY in XOR mode - Force commit earlier draw calls before DRAW_POLY.&quot;);
 427 
 428                     // draw separate (N-1) lines using N points
 429                     for(int point = 0; point &lt; nPoints-1; point++) {
 430                         jint x1 = xPoints[point] + transX;
 431                         jint y1 = yPoints[point] + transY;
 432                         jint x2 = xPoints[point + 1] + transX;
 433                         jint y2 = yPoints[point + 1] + transY;
 434                         MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);
 435                     }
 436 
 437                     if (isClosed) {
 438                         MTLRenderer_DrawLine(mtlc, dstOps, xPoints[0] + transX, yPoints[0] + transY, xPoints[nPoints-1] + transX, yPoints[nPoints-1] + transY);
 439                     }
 440                 } else {
 441                     MTLRenderer_DrawPoly(mtlc, dstOps, nPoints, isClosed, transX, transY, xPoints, yPoints);
 442                 }
 443 
 444                 SKIP_BYTES(b, nPoints * BYTES_PER_POLY_POINT);
 445             }
 446             break;
 447         case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
 448             {
 449                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 450 
 451                 if ([mtlc useXORComposite]) {
 452                     commitEncodedCommands();
 453                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_PIXEL in XOR mode - Force commit earlier draw calls before DRAW_PIXEL.&quot;);
 454                 }
 455 
 456                 jint x = NEXT_INT(b);
 457                 jint y = NEXT_INT(b);
 458                 CONTINUE_IF_NULL(mtlc);
 459                 MTLRenderer_DrawPixel(mtlc, dstOps, x, y);
 460             }
 461             break;
 462         case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
 463             {
 464                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 465 
 466                 if ([mtlc useXORComposite]) {
 467                     commitEncodedCommands();
 468                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_SCANLINES in XOR mode - Force commit earlier draw calls before DRAW_SCANLINES.&quot;);
 469                 }
 470 
 471                 jint count = NEXT_INT(b);
 472                 MTLRenderer_DrawScanlines(mtlc, dstOps, count, (jint *)b);
 473 
 474                 SKIP_BYTES(b, count * BYTES_PER_SCANLINE);
 475             }
 476             break;
 477         case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
 478             {
 479                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 480 
 481                 if ([mtlc useXORComposite]) {
 482                     commitEncodedCommands();
 483                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_PARALLELOGRAM in XOR mode - Force commit earlier draw calls before DRAW_PARALLELOGRAM.&quot;);
 484                 }
 485 
 486                 jfloat x11 = NEXT_FLOAT(b);
 487                 jfloat y11 = NEXT_FLOAT(b);
 488                 jfloat dx21 = NEXT_FLOAT(b);
 489                 jfloat dy21 = NEXT_FLOAT(b);
 490                 jfloat dx12 = NEXT_FLOAT(b);
 491                 jfloat dy12 = NEXT_FLOAT(b);
 492                 jfloat lwr21 = NEXT_FLOAT(b);
 493                 jfloat lwr12 = NEXT_FLOAT(b);
 494 
 495                 MTLRenderer_DrawParallelogram(mtlc, dstOps,
 496                                               x11, y11,
 497                                               dx21, dy21,
 498                                               dx12, dy12,
 499                                               lwr21, lwr12);
 500             }
 501             break;
 502         case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
 503             {
 504                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 505                 jfloat x11 = NEXT_FLOAT(b);
 506                 jfloat y11 = NEXT_FLOAT(b);
 507                 jfloat dx21 = NEXT_FLOAT(b);
 508                 jfloat dy21 = NEXT_FLOAT(b);
 509                 jfloat dx12 = NEXT_FLOAT(b);
 510                 jfloat dy12 = NEXT_FLOAT(b);
 511                 jfloat lwr21 = NEXT_FLOAT(b);
 512                 jfloat lwr12 = NEXT_FLOAT(b);
 513 
 514                 MTLRenderer_DrawAAParallelogram(mtlc, dstOps,
 515                                                 x11, y11,
 516                                                 dx21, dy21,
 517                                                 dx12, dy12,
 518                                                 lwr21, lwr12);
 519             }
 520             break;
 521 
 522         // fill ops
 523         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
 524             {
 525                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 526 
 527                 if ([mtlc useXORComposite]) {
 528                     commitEncodedCommands();
 529                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;FILL_RECT in XOR mode - Force commit earlier draw calls before FILL_RECT.&quot;);
 530                 }
 531 
 532                 jint x = NEXT_INT(b);
 533                 jint y = NEXT_INT(b);
 534                 jint w = NEXT_INT(b);
 535                 jint h = NEXT_INT(b);
 536                 MTLRenderer_FillRect(mtlc, dstOps, x, y, w, h);
 537             }
 538             break;
 539         case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
 540             {
 541                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 542 
 543                 if ([mtlc useXORComposite]) {
 544                     commitEncodedCommands();
 545                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;FILL_SPANS in XOR mode - Force commit earlier draw calls before FILL_SPANS.&quot;);
 546                 }
 547 
 548                 jint count = NEXT_INT(b);
 549                 MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
 550                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
 551             }
 552             break;
 553         case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
 554             {
 555                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 556 
 557                 if ([mtlc useXORComposite]) {
 558                     commitEncodedCommands();
 559                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;FILL_PARALLELOGRAM in XOR mode - Force commit earlier draw calls before FILL_PARALLELOGRAM.&quot;);
 560                 }
 561 
 562                 jfloat x11 = NEXT_FLOAT(b);
 563                 jfloat y11 = NEXT_FLOAT(b);
 564                 jfloat dx21 = NEXT_FLOAT(b);
 565                 jfloat dy21 = NEXT_FLOAT(b);
 566                 jfloat dx12 = NEXT_FLOAT(b);
 567                 jfloat dy12 = NEXT_FLOAT(b);
 568                 MTLRenderer_FillParallelogram(mtlc, dstOps,
 569                                               x11, y11,
 570                                               dx21, dy21,
 571                                               dx12, dy12);
 572             }
 573             break;
 574         case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
 575             {
 576                 CHECK_PREVIOUS_OP(MTL_OP_AA);
 577                 jfloat x11 = NEXT_FLOAT(b);
 578                 jfloat y11 = NEXT_FLOAT(b);
 579                 jfloat dx21 = NEXT_FLOAT(b);
 580                 jfloat dy21 = NEXT_FLOAT(b);
 581                 jfloat dx12 = NEXT_FLOAT(b);
 582                 jfloat dy12 = NEXT_FLOAT(b);
 583                 MTLRenderer_FillAAParallelogram(mtlc, dstOps,
 584                                                 x11, y11,
 585                                                 dx21, dy21,
 586                                                 dx12, dy12);
 587             }
 588             break;
 589 
 590         // text-related ops
 591         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
 592             {
 593                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 594 
 595                 if ([mtlc useXORComposite]) {
 596                     commitEncodedCommands();
 597                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_GLYPH_LIST in XOR mode - Force commit earlier draw calls before DRAW_GLYPH_LIST.&quot;);
 598                 }
 599 
 600                 jint numGlyphs        = NEXT_INT(b);
 601                 jint packedParams     = NEXT_INT(b);
 602                 jfloat glyphListOrigX = NEXT_FLOAT(b);
 603                 jfloat glyphListOrigY = NEXT_FLOAT(b);
 604                 jboolean usePositions = EXTRACT_BOOLEAN(packedParams,
 605                                                         OFFSET_POSITIONS);
 606                 jboolean subPixPos    = EXTRACT_BOOLEAN(packedParams,
 607                                                         OFFSET_SUBPIXPOS);
 608                 jboolean rgbOrder     = EXTRACT_BOOLEAN(packedParams,
 609                                                         OFFSET_RGBORDER);
 610                 jint lcdContrast      = EXTRACT_BYTE(packedParams,
 611                                                      OFFSET_CONTRAST);
 612                 unsigned char *images = b;
 613                 unsigned char *positions;
 614                 jint bytesPerGlyph;
 615                 if (usePositions) {
 616                     positions = (b + numGlyphs * BYTES_PER_GLYPH_IMAGE);
 617                     bytesPerGlyph = BYTES_PER_POSITIONED_GLYPH;
 618                 } else {
 619                     positions = NULL;
 620                     bytesPerGlyph = BYTES_PER_GLYPH_IMAGE;
 621                 }
 622                 MTLTR_DrawGlyphList(env, mtlc, dstOps,
 623                                     numGlyphs, usePositions,
 624                                     subPixPos, rgbOrder, lcdContrast,
 625                                     glyphListOrigX, glyphListOrigY,
 626                                     images, positions);
 627                 SKIP_BYTES(b, numGlyphs * bytesPerGlyph);
 628             }
 629             break;
 630 
 631         // copy-related ops
 632         case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
 633             {
 634                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 635                 jint x  = NEXT_INT(b);
 636                 jint y  = NEXT_INT(b);
 637                 jint w  = NEXT_INT(b);
 638                 jint h  = NEXT_INT(b);
 639                 jint dx = NEXT_INT(b);
 640                 jint dy = NEXT_INT(b);
 641                 MTLBlitLoops_CopyArea(env, mtlc, dstOps,
 642                                       x, y, w, h, dx, dy);
 643             }
 644             break;
 645         case sun_java2d_pipe_BufferedOpCodes_BLIT:
 646             {
 647                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 648                 jint packedParams = NEXT_INT(b);
 649                 jint sx1          = NEXT_INT(b);
 650                 jint sy1          = NEXT_INT(b);
 651                 jint sx2          = NEXT_INT(b);
 652                 jint sy2          = NEXT_INT(b);
 653                 jdouble dx1       = NEXT_DOUBLE(b);
 654                 jdouble dy1       = NEXT_DOUBLE(b);
 655                 jdouble dx2       = NEXT_DOUBLE(b);
 656                 jdouble dy2       = NEXT_DOUBLE(b);
 657                 jlong pSrc        = NEXT_LONG(b);
 658                 jlong pDst        = NEXT_LONG(b);
 659                 jint hint         = EXTRACT_BYTE(packedParams, OFFSET_HINT);
 660                 jboolean texture  = EXTRACT_BOOLEAN(packedParams,
 661                                                     OFFSET_TEXTURE);
 662                 jboolean xform    = EXTRACT_BOOLEAN(packedParams,
 663                                                     OFFSET_XFORM);
 664                 jboolean isoblit  = EXTRACT_BOOLEAN(packedParams,
 665                                                     OFFSET_ISOBLIT);
 666                 if (isoblit) {
 667                     MTLBlitLoops_IsoBlit(env, mtlc, pSrc, pDst,
 668                                          xform, hint, texture,
 669                                          sx1, sy1, sx2, sy2,
 670                                          dx1, dy1, dx2, dy2);
 671                 } else {
 672                     jint srctype = EXTRACT_BYTE(packedParams, OFFSET_SRCTYPE);
 673                     MTLBlitLoops_Blit(env, mtlc, pSrc, pDst,
 674                                       xform, hint, srctype, texture,
 675                                       sx1, sy1, sx2, sy2,
 676                                       dx1, dy1, dx2, dy2);
 677                 }
 678             }
 679             break;
 680         case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
 681             {
 682                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 683                 jint sx      = NEXT_INT(b);
 684                 jint sy      = NEXT_INT(b);
 685                 jint dx      = NEXT_INT(b);
 686                 jint dy      = NEXT_INT(b);
 687                 jint w       = NEXT_INT(b);
 688                 jint h       = NEXT_INT(b);
 689                 jint dsttype = NEXT_INT(b);
 690                 jlong pSrc   = NEXT_LONG(b);
 691                 jlong pDst   = NEXT_LONG(b);
 692                 MTLBlitLoops_SurfaceToSwBlit(env, mtlc,
 693                                              pSrc, pDst, dsttype,
 694                                              sx, sy, dx, dy, w, h);
 695             }
 696             break;
 697         case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
 698             {
 699                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 700                 jint x        = NEXT_INT(b);
 701                 jint y        = NEXT_INT(b);
 702                 jint w        = NEXT_INT(b);
 703                 jint h        = NEXT_INT(b);
 704                 jint maskoff  = NEXT_INT(b);
 705                 jint maskscan = NEXT_INT(b);
 706                 jint masklen  = NEXT_INT(b);
 707                 unsigned char *pMask = (masklen &gt; 0) ? b : NULL;
 708                 MTLMaskFill_MaskFill(mtlc, dstOps, x, y, w, h,
 709                                      maskoff, maskscan, masklen, pMask);
 710                 SKIP_BYTES(b, masklen);
 711             }
 712             break;
 713         case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
 714             {
 715                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 716                 jint dstx     = NEXT_INT(b);
 717                 jint dsty     = NEXT_INT(b);
 718                 jint width    = NEXT_INT(b);
 719                 jint height   = NEXT_INT(b);
 720                 jint masklen  = width * height * sizeof(jint);
 721                 MTLMaskBlit_MaskBlit(env, mtlc, dstOps,
 722                                      dstx, dsty, width, height, b);
 723                 SKIP_BYTES(b, masklen);
 724             }
 725             break;
 726 
 727         // state-related ops
 728         case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
 729             {
 730                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 731                 jint x1 = NEXT_INT(b);
 732                 jint y1 = NEXT_INT(b);
 733                 jint x2 = NEXT_INT(b);
 734                 jint y2 = NEXT_INT(b);
 735                 [mtlc setClipRectX1:x1 Y1:y1 X2:x2 Y2:y2];
 736             }
 737             break;
 738         case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
 739             {
 740                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 741                 [mtlc beginShapeClip:dstOps];
 742             }
 743             break;
 744         case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
 745             {
 746                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 747                 // This results in creation of new render encoder with
 748                 // stencil buffer set as render target
 749                 jint count = NEXT_INT(b);
 750                 MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
 751                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
 752             }
 753             break;
 754         case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
 755             {
 756                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 757                 [mtlc endShapeClip:dstOps];
 758             }
 759             break;
 760         case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
 761             {
 762                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 763                 [mtlc resetClip];
 764             }
 765             break;
 766         case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
 767             {
 768                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 769                 jint rule         = NEXT_INT(b);
 770                 jfloat extraAlpha = NEXT_FLOAT(b);
 771                 jint flags        = NEXT_INT(b);
 772                 [mtlc setAlphaCompositeRule:rule extraAlpha:extraAlpha flags:flags];
 773             }
 774             break;
 775         case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
 776             {
 777                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 778                 jint xorPixel = NEXT_INT(b);
 779                 [mtlc setXorComposite:xorPixel];
 780             }
 781             break;
 782         case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
 783             {
 784                 /* TODO: check whether something needs to be done here if we are moving out of XOR composite
 785                 commitEncodedCommands();
 786                 MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
 787                 [cbwrapper onComplete];
 788 
 789                 J2dTraceLn(J2D_TRACE_VERBOSE, &quot;RESET_COMPOSITE - Force commit earlier draw calls before RESET_COMPOSITE.&quot;);*/
 790 
 791                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 792                 [mtlc resetComposite];
 793             }
 794             break;
 795         case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
 796             {
 797                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 798                 jdouble m00 = NEXT_DOUBLE(b);
 799                 jdouble m10 = NEXT_DOUBLE(b);
 800                 jdouble m01 = NEXT_DOUBLE(b);
 801                 jdouble m11 = NEXT_DOUBLE(b);
 802                 jdouble m02 = NEXT_DOUBLE(b);
 803                 jdouble m12 = NEXT_DOUBLE(b);
 804                 [mtlc setTransformM00:m00 M10:m10 M01:m01 M11:m11 M02:m02 M12:m12];
 805             }
 806             break;
 807         case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
 808             {
 809                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 810                 [mtlc resetTransform];
 811             }
 812             break;
 813 
 814         // context-related ops
 815         case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
 816             {
 817                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 818                 jlong pSrc = NEXT_LONG(b);
 819                 jlong pDst = NEXT_LONG(b);
 820 
 821                 dstOps = (BMTLSDOps *)jlong_to_ptr(pDst);
 822                 mtlc = [MTLContext setSurfacesEnv:env src:pSrc dst:pDst];
 823             }
 824             break;
 825         case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
 826             {
 827                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 828                 jlong pConfigInfo = NEXT_LONG(b);
 829                 MTLGraphicsConfigInfo *mtlInfo =
 830                         (MTLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);
 831 
 832                 if (mtlInfo == NULL) {
 833 
 834                 } else {
 835                     MTLContext *newMtlc = mtlInfo-&gt;context;
 836                     if (newMtlc == NULL) {
 837 
 838                     } else {
 839                         mtlc = newMtlc;
 840                         dstOps = NULL;
 841                     }
 842                 }
 843             }
 844             break;
 845         case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
 846             {
 847                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 848                 jlong pData = NEXT_LONG(b);
 849                 BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
 850                 if (mtlsdo != NULL) {
 851                     CONTINUE_IF_NULL(mtlc);
 852                     MTLSD_Delete(env, mtlsdo);
 853                 }
 854             }
 855             break;
 856         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
 857             {
 858                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 859                 jlong pData = NEXT_LONG(b);
 860                 BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
 861                 if (mtlsdo != NULL) {
 862                     CONTINUE_IF_NULL(mtlc);
 863                     MTLSD_Delete(env, mtlsdo);
 864                     if (mtlsdo-&gt;privOps != NULL) {
 865                         free(mtlsdo-&gt;privOps);
 866                     }
 867                 }
 868             }
 869             break;
 870         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
 871             {
 872                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 873                 jlong pConfigInfo = NEXT_LONG(b);
 874                 CONTINUE_IF_NULL(mtlc);
 875                 MTLGC_DestroyMTLGraphicsConfig(pConfigInfo);
 876 
 877                 // the previous method will call glX/wglMakeCurrent(None),
 878                 // so we should nullify the current mtlc and dstOps to avoid
 879                 // calling glFlush() (or similar) while no context is current
 880                 mtlc = NULL;
 881              //   dstOps = NULL;
 882             }
 883             break;
 884         case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
 885             {
 886                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 887                 // invalidate the references to the current context and
 888                 // destination surface that are maintained at the native level
 889                 mtlc = NULL;
 890             //    dstOps = NULL;
 891             }
 892             break;
 893         case sun_java2d_pipe_BufferedOpCodes_SYNC:
 894             {
 895                 CHECK_PREVIOUS_OP(MTL_OP_SYNC);
 896             }
 897             break;
 898 
 899         // multibuffering ops
 900         case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
 901             {
 902                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 903                 jlong window = NEXT_LONG(b);
 904                 MTLSD_SwapBuffers(env, window);
 905             }
 906             break;
 907 
 908         // special no-op (mainly used for achieving 8-byte alignment)
 909         case sun_java2d_pipe_BufferedOpCodes_NOOP:
 910             break;
 911 
 912         // paint-related ops
 913         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
 914             {
 915               CHECK_PREVIOUS_OP(MTL_OP_RESET_PAINT);
 916               [mtlc resetPaint];
 917             }
 918             break;
 919         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
 920             {
 921                 CHECK_PREVIOUS_OP(MTL_OP_SET_COLOR);
 922                 jint pixel = NEXT_INT(b);
 923                 [mtlc setColorPaint:pixel];
 924             }
 925             break;
 926         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
 927             {
 928                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 929                 jboolean useMask= NEXT_BOOLEAN(b);
 930                 jboolean cyclic = NEXT_BOOLEAN(b);
 931                 jdouble p0      = NEXT_DOUBLE(b);
 932                 jdouble p1      = NEXT_DOUBLE(b);
 933                 jdouble p3      = NEXT_DOUBLE(b);
 934                 jint pixel1     = NEXT_INT(b);
 935                 jint pixel2     = NEXT_INT(b);
 936                 [mtlc setGradientPaintUseMask:useMask
 937                                     cyclic:cyclic
 938                                         p0:p0
 939                                         p1:p1
 940                                         p3:p3
 941                                     pixel1:pixel1
 942                                     pixel2:pixel2];
 943             }
 944             break;
 945         case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
 946             {
 947                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 948                 jboolean useMask = NEXT_BOOLEAN(b);
 949                 jboolean linear  = NEXT_BOOLEAN(b);
 950                 jint cycleMethod = NEXT_INT(b);
 951                 jint numStops    = NEXT_INT(b);
 952                 jfloat p0        = NEXT_FLOAT(b);
 953                 jfloat p1        = NEXT_FLOAT(b);
 954                 jfloat p3        = NEXT_FLOAT(b);
 955                 void *fractions, *pixels;
 956                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
 957                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
 958                 [mtlc setLinearGradientPaint:useMask
 959                                       linear:linear
 960                                  cycleMethod:cycleMethod
 961                                     numStops:numStops
 962                                           p0:p0
 963                                           p1:p1
 964                                           p3:p3
 965                                    fractions:fractions
 966                                       pixels:pixels];
 967             }
 968             break;
 969         case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
 970             {
 971                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 972                 jboolean useMask = NEXT_BOOLEAN(b);
 973                 jboolean linear  = NEXT_BOOLEAN(b);
 974                 jint numStops    = NEXT_INT(b);
 975                 jint cycleMethod = NEXT_INT(b);
 976                 jfloat m00       = NEXT_FLOAT(b);
 977                 jfloat m01       = NEXT_FLOAT(b);
 978                 jfloat m02       = NEXT_FLOAT(b);
 979                 jfloat m10       = NEXT_FLOAT(b);
 980                 jfloat m11       = NEXT_FLOAT(b);
 981                 jfloat m12       = NEXT_FLOAT(b);
 982                 jfloat focusX    = NEXT_FLOAT(b);
 983                 void *fractions, *pixels;
 984                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
 985                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
 986                 [mtlc setRadialGradientPaint:useMask
 987                                       linear:linear
 988                                  cycleMethod:cycleMethod
 989                                     numStops:numStops
 990                                          m00:m00
 991                                          m01:m01
 992                                          m02:m02
 993                                          m10:m10
 994                                          m11:m11
 995                                          m12:m12
 996                                       focusX:focusX
 997                                    fractions:fractions
 998                                       pixels:pixels];
 999             }
1000             break;
1001         case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
1002             {
1003                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1004                 jboolean useMask= NEXT_BOOLEAN(b);
1005                 jboolean filter = NEXT_BOOLEAN(b);
1006                 jlong pSrc      = NEXT_LONG(b);
1007                 jdouble xp0     = NEXT_DOUBLE(b);
1008                 jdouble xp1     = NEXT_DOUBLE(b);
1009                 jdouble xp3     = NEXT_DOUBLE(b);
1010                 jdouble yp0     = NEXT_DOUBLE(b);
1011                 jdouble yp1     = NEXT_DOUBLE(b);
1012                 jdouble yp3     = NEXT_DOUBLE(b);
1013                 [mtlc setTexturePaint:useMask
1014                               pSrcOps:pSrc
1015                                filter:filter
1016                                   xp0:xp0
1017                                   xp1:xp1
1018                                   xp3:xp3
1019                                   yp0:yp0
1020                                   yp1:yp1
1021                                   yp3:yp3];
1022             }
1023             break;
1024 
1025         // BufferedImageOp-related ops
1026         case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
1027             {
1028                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1029                 jlong pSrc        = NEXT_LONG(b);
1030                 jboolean edgeZero = NEXT_BOOLEAN(b);
1031                 jint kernelWidth  = NEXT_INT(b);
1032                 jint kernelHeight = NEXT_INT(b);
1033 
1034                 BMTLSDOps * bmtlsdOps = (BMTLSDOps *)pSrc;
1035                 MTLConvolveOp * convolveOp = [[MTLConvolveOp alloc] init:edgeZero
1036                         kernelWidth:kernelWidth
1037                        kernelHeight:kernelHeight
1038                            srcWidth:bmtlsdOps-&gt;width
1039                           srcHeight:bmtlsdOps-&gt;height
1040                              kernel:b
1041                              device:mtlc.device
1042                                               ];
1043                 [mtlc setBufImgOp:convolveOp];
1044                 SKIP_BYTES(b, kernelWidth * kernelHeight * sizeof(jfloat));
1045             }
1046             break;
1047         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
1048             {
1049                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1050                 [mtlc setBufImgOp:NULL];
1051             }
1052             break;
1053         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
1054             {
1055                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1056                 jlong pSrc          = NEXT_LONG(b);
1057                 jboolean nonPremult = NEXT_BOOLEAN(b);
1058                 jint numFactors     = 4;
1059                 unsigned char *scaleFactors = b;
1060                 unsigned char *offsets = (b + numFactors * sizeof(jfloat));
1061                 MTLRescaleOp * rescaleOp = [[MTLRescaleOp alloc] init:nonPremult factors:scaleFactors offsets:offsets];
1062                 [mtlc setBufImgOp:rescaleOp];
1063                 SKIP_BYTES(b, numFactors * sizeof(jfloat) * 2);
1064             }
1065             break;
1066         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
1067             {
1068                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1069                 [mtlc setBufImgOp:NULL];
1070             }
1071             break;
1072         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
1073             {
1074                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1075                 jlong pSrc          = NEXT_LONG(b);
1076                 jboolean nonPremult = NEXT_BOOLEAN(b);
1077                 jboolean shortData  = NEXT_BOOLEAN(b);
1078                 jint numBands       = NEXT_INT(b);
1079                 jint bandLength     = NEXT_INT(b);
1080                 jint offset         = NEXT_INT(b);
1081                 jint bytesPerElem = shortData ? sizeof(jshort):sizeof(jbyte);
1082                 void *tableValues = b;
1083 
1084                 MTLLookupOp * lookupOp = [[MTLLookupOp alloc] init:nonPremult
1085                                                          shortData:shortData
1086                                                           numBands:numBands
1087                                                         bandLength:bandLength
1088                                                             offset:offset
1089                                                        tableValues:tableValues
1090                                                             device:mtlc.device];
1091                 [mtlc setBufImgOp:lookupOp];
1092                 SKIP_BYTES(b, numBands * bandLength * bytesPerElem);
1093             }
1094             break;
1095         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
1096             {
1097                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1098                 [mtlc setBufImgOp:NULL];
1099             }
1100             break;
1101 
1102         default:
1103             J2dRlsTraceLn1(J2D_TRACE_ERROR,
1104                 &quot;MTLRenderQueue_flushBuffer: invalid opcode=%d&quot;, opcode);
1105             return;
1106         }
1107     }
1108 
1109     if (mtlc != NULL) {
1110         [mtlc.encoderManager endEncoder];
1111         MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
1112         id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
1113         [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
1114             [cbwrapper release];
1115         }];
1116         [commandbuf commit];
1117         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
1118         if (dstOps != NULL) {
1119             MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps-&gt;privOps;
1120             MTLLayer *layer = (MTLLayer*)dstMTLOps-&gt;layer;
1121             if (layer != NULL) {
1122                 [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){
1123                     AWT_ASSERT_APPKIT_THREAD;
1124                     [layer setNeedsDisplay];
1125                 }];
1126             }
1127         }
1128     }
1129     RESET_PREVIOUS_OP();
1130 }
1131 
1132 /**
1133  * Returns a pointer to the &quot;current&quot; context, as set by the last SET_SURFACES
1134  * or SET_SCRATCH_SURFACE operation.
1135  */
1136 MTLContext *
1137 MTLRenderQueue_GetCurrentContext()
1138 {
1139     return mtlc;
1140 }
1141 
1142 /**
1143  * Returns a pointer to the &quot;current&quot; destination surface, as set by the last
1144  * SET_SURFACES operation.
1145  */
1146 BMTLSDOps *
1147 MTLRenderQueue_GetCurrentDestination()
1148 {
1149     return dstOps;
1150 }
1151 
1152 /**
1153  * commit earlier encoded commmands
1154  * these would be rendered to the back-buffer - which is read in shader while rendering in XOR mode
1155  */
1156 void commitEncodedCommands() {
1157     [mtlc.encoderManager endEncoder];
1158 
1159     MTLCommandBufferWrapper *cbwrapper = [mtlc pullCommandBufferWrapper];
1160     id &lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
1161     [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
1162         [cbwrapper release];
1163     }];
1164     [commandbuf commit];
1165     [commandbuf waitUntilCompleted];
1166 }
1167 
1168 #endif /* !HEADLESS */
    </pre>
  </body>
</html>