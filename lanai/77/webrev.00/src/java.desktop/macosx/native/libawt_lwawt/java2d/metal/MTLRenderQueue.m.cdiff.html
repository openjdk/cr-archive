<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MTLPaints.m.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLTextRenderer.m.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 361,774 ***</span>
              &quot;MTLRenderQueue_flushBuffer: cannot get direct buffer address&quot;);
          return;
      }
  
      end = b + limit;
<span class="line-modified">! </span>
<span class="line-modified">!     jboolean DEBUG_LOG = JNI_FALSE;</span>
<span class="line-modified">!     while (b &lt; end) {</span>
<span class="line-modified">!         jint opcode = NEXT_INT(b);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (DEBUG_LOG) {</span>
<span class="line-modified">!             J2dTraceLn2(J2D_TRACE_ERROR,</span>
<span class="line-modified">!                     &quot;MTLRenderQueue_flushBuffer: opcode_name = %s, rem=%d&quot;,</span>
<span class="line-modified">!                     getOpcodeString(opcode), (end-b));</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             J2dTraceLn2(J2D_TRACE_VERBOSE,</span>
<span class="line-modified">!                     &quot;MTLRenderQueue_flushBuffer: opcode=%d, rem=%d&quot;,</span>
<span class="line-modified">!                     opcode, (end-b));</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         switch (opcode) {</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // draw ops</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 if ([mtlc useXORComposite]) {</span>
<span class="line-modified">!                     commitEncodedCommands();</span>
<span class="line-modified">!                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_LINE in XOR mode - Force commit earlier draw calls before DRAW_LINE.&quot;);</span>
                  }
<span class="line-modified">!                 jint x1 = NEXT_INT(b);</span>
<span class="line-modified">!                 jint y1 = NEXT_INT(b);</span>
<span class="line-modified">!                 jint x2 = NEXT_INT(b);</span>
<span class="line-modified">!                 jint y2 = NEXT_INT(b);</span>
<span class="line-modified">!                 MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 if ([mtlc useXORComposite]) {</span>
<span class="line-modified">!                     commitEncodedCommands();</span>
<span class="line-modified">!                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_RECT in XOR mode - Force commit earlier draw calls before DRAW_RECT.&quot;);</span>
                  }
<span class="line-modified">!                 jint x = NEXT_INT(b);</span>
<span class="line-modified">!                 jint y = NEXT_INT(b);</span>
<span class="line-modified">!                 jint w = NEXT_INT(b);</span>
<span class="line-modified">!                 jint h = NEXT_INT(b);</span>
<span class="line-modified">!                 MTLRenderer_DrawRect(mtlc, dstOps, x, y, w, h);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                 jint nPoints      = NEXT_INT(b);</span>
<span class="line-modified">!                 jboolean isClosed = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                 jint transX       = NEXT_INT(b);</span>
<span class="line-modified">!                 jint transY       = NEXT_INT(b);</span>
<span class="line-modified">!                 jint *xPoints = (jint *)b;</span>
<span class="line-modified">!                 jint *yPoints = ((jint *)b) + nPoints;</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 if ([mtlc useXORComposite]) {</span>
<span class="line-modified">!                     commitEncodedCommands();</span>
<span class="line-modified">!                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_POLY in XOR mode - Force commit earlier draw calls before DRAW_POLY.&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     // draw separate (N-1) lines using N points</span>
<span class="line-modified">!                     for(int point = 0; point &lt; nPoints-1; point++) {</span>
<span class="line-modified">!                         jint x1 = xPoints[point] + transX;</span>
<span class="line-modified">!                         jint y1 = yPoints[point] + transY;</span>
<span class="line-modified">!                         jint x2 = xPoints[point + 1] + transX;</span>
<span class="line-modified">!                         jint y2 = yPoints[point + 1] + transY;</span>
<span class="line-modified">!                         MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);</span>
                      }
  
<span class="line-modified">!                     if (isClosed) {</span>
<span class="line-modified">!                         MTLRenderer_DrawLine(mtlc, dstOps, xPoints[0] + transX, yPoints[0] + transY, xPoints[nPoints-1] + transX, yPoints[nPoints-1] + transY);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     MTLRenderer_DrawPoly(mtlc, dstOps, nPoints, isClosed, transX, transY, xPoints, yPoints);</span>
                  }
  
<span class="line-modified">!                 SKIP_BYTES(b, nPoints * BYTES_PER_POLY_POINT);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:</span>
<span class="line-modified">!             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 if ([mtlc useXORComposite]) {</span>
<span class="line-removed">-                     commitEncodedCommands();</span>
<span class="line-removed">-                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_PIXEL in XOR mode - Force commit earlier draw calls before DRAW_PIXEL.&quot;);</span>
                  }
  
<span class="line-modified">!                 jint x = NEXT_INT(b);</span>
<span class="line-modified">!                 jint y = NEXT_INT(b);</span>
<span class="line-removed">-                 CONTINUE_IF_NULL(mtlc);</span>
<span class="line-removed">-                 MTLRenderer_DrawPixel(mtlc, dstOps, x, y);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
  
<span class="line-modified">!                 if ([mtlc useXORComposite]) {</span>
<span class="line-modified">!                     commitEncodedCommands();</span>
<span class="line-removed">-                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_SCANLINES in XOR mode - Force commit earlier draw calls before DRAW_SCANLINES.&quot;);</span>
                  }
  
<span class="line-modified">!                 jint count = NEXT_INT(b);</span>
<span class="line-modified">!                 MTLRenderer_DrawScanlines(mtlc, dstOps, count, (jint *)b);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 SKIP_BYTES(b, count * BYTES_PER_SCANLINE);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 if ([mtlc useXORComposite]) {</span>
<span class="line-modified">!                     commitEncodedCommands();</span>
<span class="line-modified">!                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_PARALLELOGRAM in XOR mode - Force commit earlier draw calls before DRAW_PARALLELOGRAM.&quot;);</span>
                  }
  
<span class="line-modified">!                 jfloat x11 = NEXT_FLOAT(b);</span>
<span class="line-modified">!                 jfloat y11 = NEXT_FLOAT(b);</span>
<span class="line-modified">!                 jfloat dx21 = NEXT_FLOAT(b);</span>
<span class="line-modified">!                 jfloat dy21 = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 jfloat dx12 = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 jfloat dy12 = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 jfloat lwr21 = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 jfloat lwr12 = NEXT_FLOAT(b);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 MTLRenderer_DrawParallelogram(mtlc, dstOps,</span>
<span class="line-removed">-                                               x11, y11,</span>
<span class="line-removed">-                                               dx21, dy21,</span>
<span class="line-removed">-                                               dx12, dy12,</span>
<span class="line-removed">-                                               lwr21, lwr12);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-removed">-                 jfloat x11 = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 jfloat y11 = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 jfloat dx21 = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 jfloat dy21 = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 jfloat dx12 = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 jfloat dy12 = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 jfloat lwr21 = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 jfloat lwr12 = NEXT_FLOAT(b);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 MTLRenderer_DrawAAParallelogram(mtlc, dstOps,</span>
<span class="line-removed">-                                                 x11, y11,</span>
<span class="line-removed">-                                                 dx21, dy21,</span>
<span class="line-removed">-                                                 dx12, dy12,</span>
<span class="line-removed">-                                                 lwr21, lwr12);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
  
<span class="line-modified">!         // fill ops</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
  
<span class="line-modified">!                 if ([mtlc useXORComposite]) {</span>
<span class="line-modified">!                     commitEncodedCommands();</span>
<span class="line-modified">!                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;FILL_RECT in XOR mode - Force commit earlier draw calls before FILL_RECT.&quot;);</span>
                  }
  
<span class="line-modified">!                 jint x = NEXT_INT(b);</span>
<span class="line-modified">!                 jint y = NEXT_INT(b);</span>
<span class="line-modified">!                 jint w = NEXT_INT(b);</span>
<span class="line-modified">!                 jint h = NEXT_INT(b);</span>
<span class="line-removed">-                 MTLRenderer_FillRect(mtlc, dstOps, x, y, w, h);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 if ([mtlc useXORComposite]) {</span>
<span class="line-removed">-                     commitEncodedCommands();</span>
<span class="line-removed">-                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;FILL_SPANS in XOR mode - Force commit earlier draw calls before FILL_SPANS.&quot;);</span>
                  }
  
<span class="line-modified">!                 jint count = NEXT_INT(b);</span>
<span class="line-modified">!                 MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);</span>
<span class="line-modified">!                 SKIP_BYTES(b, count * BYTES_PER_SPAN);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 if ([mtlc useXORComposite]) {</span>
<span class="line-modified">!                     commitEncodedCommands();</span>
<span class="line-modified">!                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;FILL_PARALLELOGRAM in XOR mode - Force commit earlier draw calls before FILL_PARALLELOGRAM.&quot;);</span>
                  }
  
<span class="line-modified">!                 jfloat x11 = NEXT_FLOAT(b);</span>
<span class="line-modified">!                 jfloat y11 = NEXT_FLOAT(b);</span>
<span class="line-modified">!                 jfloat dx21 = NEXT_FLOAT(b);</span>
<span class="line-modified">!                 jfloat dy21 = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 jfloat dx12 = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 jfloat dy12 = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 MTLRenderer_FillParallelogram(mtlc, dstOps,</span>
<span class="line-removed">-                                               x11, y11,</span>
<span class="line-removed">-                                               dx21, dy21,</span>
<span class="line-removed">-                                               dx12, dy12);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_AA);</span>
<span class="line-removed">-                 jfloat x11 = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 jfloat y11 = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 jfloat dx21 = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 jfloat dy21 = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 jfloat dx12 = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 jfloat dy12 = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 MTLRenderer_FillAAParallelogram(mtlc, dstOps,</span>
<span class="line-removed">-                                                 x11, y11,</span>
<span class="line-removed">-                                                 dx21, dy21,</span>
<span class="line-removed">-                                                 dx12, dy12);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
  
<span class="line-modified">!         // text-related ops</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
  
<span class="line-modified">!                 if ([mtlc useXORComposite]) {</span>
<span class="line-modified">!                     commitEncodedCommands();</span>
<span class="line-modified">!                     J2dTraceLn(J2D_TRACE_VERBOSE, &quot;DRAW_GLYPH_LIST in XOR mode - Force commit earlier draw calls before DRAW_GLYPH_LIST.&quot;);</span>
                  }
  
<span class="line-modified">!                 jint numGlyphs        = NEXT_INT(b);</span>
<span class="line-modified">!                 jint packedParams     = NEXT_INT(b);</span>
<span class="line-modified">!                 jfloat glyphListOrigX = NEXT_FLOAT(b);</span>
<span class="line-modified">!                 jfloat glyphListOrigY = NEXT_FLOAT(b);</span>
<span class="line-modified">!                 jboolean usePositions = EXTRACT_BOOLEAN(packedParams,</span>
<span class="line-modified">!                                                         OFFSET_POSITIONS);</span>
<span class="line-modified">!                 jboolean subPixPos    = EXTRACT_BOOLEAN(packedParams,</span>
<span class="line-modified">!                                                         OFFSET_SUBPIXPOS);</span>
<span class="line-modified">!                 jboolean rgbOrder     = EXTRACT_BOOLEAN(packedParams,</span>
<span class="line-modified">!                                                         OFFSET_RGBORDER);</span>
<span class="line-modified">!                 jint lcdContrast      = EXTRACT_BYTE(packedParams,</span>
<span class="line-modified">!                                                      OFFSET_CONTRAST);</span>
<span class="line-modified">!                 unsigned char *images = b;</span>
<span class="line-removed">-                 unsigned char *positions;</span>
<span class="line-removed">-                 jint bytesPerGlyph;</span>
<span class="line-removed">-                 if (usePositions) {</span>
<span class="line-removed">-                     positions = (b + numGlyphs * BYTES_PER_GLYPH_IMAGE);</span>
<span class="line-removed">-                     bytesPerGlyph = BYTES_PER_POSITIONED_GLYPH;</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     positions = NULL;</span>
<span class="line-removed">-                     bytesPerGlyph = BYTES_PER_GLYPH_IMAGE;</span>
                  }
<span class="line-modified">!                 MTLTR_DrawGlyphList(env, mtlc, dstOps,</span>
<span class="line-modified">!                                     numGlyphs, usePositions,</span>
<span class="line-modified">!                                     subPixPos, rgbOrder, lcdContrast,</span>
<span class="line-modified">!                                     glyphListOrigX, glyphListOrigY,</span>
<span class="line-modified">!                                     images, positions);</span>
<span class="line-modified">!                 SKIP_BYTES(b, numGlyphs * bytesPerGlyph);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // copy-related ops</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                 jint x  = NEXT_INT(b);</span>
<span class="line-modified">!                 jint y  = NEXT_INT(b);</span>
<span class="line-modified">!                 jint w  = NEXT_INT(b);</span>
<span class="line-modified">!                 jint h  = NEXT_INT(b);</span>
<span class="line-modified">!                 jint dx = NEXT_INT(b);</span>
<span class="line-modified">!                 jint dy = NEXT_INT(b);</span>
<span class="line-modified">!                 MTLBlitLoops_CopyArea(env, mtlc, dstOps,</span>
<span class="line-modified">!                                       x, y, w, h, dx, dy);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_BLIT:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                 jint packedParams = NEXT_INT(b);</span>
<span class="line-modified">!                 jint sx1          = NEXT_INT(b);</span>
<span class="line-modified">!                 jint sy1          = NEXT_INT(b);</span>
<span class="line-modified">!                 jint sx2          = NEXT_INT(b);</span>
<span class="line-modified">!                 jint sy2          = NEXT_INT(b);</span>
<span class="line-modified">!                 jdouble dx1       = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                 jdouble dy1       = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                 jdouble dx2       = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                 jdouble dy2       = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                 jlong pSrc        = NEXT_LONG(b);</span>
<span class="line-modified">!                 jlong pDst        = NEXT_LONG(b);</span>
<span class="line-modified">!                 jint hint         = EXTRACT_BYTE(packedParams, OFFSET_HINT);</span>
<span class="line-modified">!                 jboolean texture  = EXTRACT_BOOLEAN(packedParams,</span>
<span class="line-modified">!                                                     OFFSET_TEXTURE);</span>
<span class="line-modified">!                 jboolean xform    = EXTRACT_BOOLEAN(packedParams,</span>
<span class="line-modified">!                                                     OFFSET_XFORM);</span>
<span class="line-modified">!                 jboolean isoblit  = EXTRACT_BOOLEAN(packedParams,</span>
<span class="line-modified">!                                                     OFFSET_ISOBLIT);</span>
<span class="line-modified">!                 if (isoblit) {</span>
<span class="line-modified">!                     MTLBlitLoops_IsoBlit(env, mtlc, pSrc, pDst,</span>
<span class="line-modified">!                                          xform, hint, texture,</span>
<span class="line-modified">!                                          sx1, sy1, sx2, sy2,</span>
<span class="line-modified">!                                          dx1, dy1, dx2, dy2);</span>
<span class="line-modified">!                 } else {</span>
<span class="line-modified">!                     jint srctype = EXTRACT_BYTE(packedParams, OFFSET_SRCTYPE);</span>
<span class="line-modified">!                     MTLBlitLoops_Blit(env, mtlc, pSrc, pDst,</span>
<span class="line-modified">!                                       xform, hint, srctype, texture,</span>
<span class="line-modified">!                                       sx1, sy1, sx2, sy2,</span>
<span class="line-modified">!                                       dx1, dy1, dx2, dy2);</span>
                  }
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-removed">-                 jint sx      = NEXT_INT(b);</span>
<span class="line-removed">-                 jint sy      = NEXT_INT(b);</span>
<span class="line-removed">-                 jint dx      = NEXT_INT(b);</span>
<span class="line-removed">-                 jint dy      = NEXT_INT(b);</span>
<span class="line-removed">-                 jint w       = NEXT_INT(b);</span>
<span class="line-removed">-                 jint h       = NEXT_INT(b);</span>
<span class="line-removed">-                 jint dsttype = NEXT_INT(b);</span>
<span class="line-removed">-                 jlong pSrc   = NEXT_LONG(b);</span>
<span class="line-removed">-                 jlong pDst   = NEXT_LONG(b);</span>
<span class="line-removed">-                 MTLBlitLoops_SurfaceToSwBlit(env, mtlc,</span>
<span class="line-removed">-                                              pSrc, pDst, dsttype,</span>
<span class="line-removed">-                                              sx, sy, dx, dy, w, h);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-removed">-                 jint x        = NEXT_INT(b);</span>
<span class="line-removed">-                 jint y        = NEXT_INT(b);</span>
<span class="line-removed">-                 jint w        = NEXT_INT(b);</span>
<span class="line-removed">-                 jint h        = NEXT_INT(b);</span>
<span class="line-removed">-                 jint maskoff  = NEXT_INT(b);</span>
<span class="line-removed">-                 jint maskscan = NEXT_INT(b);</span>
<span class="line-removed">-                 jint masklen  = NEXT_INT(b);</span>
<span class="line-removed">-                 unsigned char *pMask = (masklen &gt; 0) ? b : NULL;</span>
<span class="line-removed">-                 MTLMaskFill_MaskFill(mtlc, dstOps, x, y, w, h,</span>
<span class="line-removed">-                                      maskoff, maskscan, masklen, pMask);</span>
<span class="line-removed">-                 SKIP_BYTES(b, masklen);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-removed">-                 jint dstx     = NEXT_INT(b);</span>
<span class="line-removed">-                 jint dsty     = NEXT_INT(b);</span>
<span class="line-removed">-                 jint width    = NEXT_INT(b);</span>
<span class="line-removed">-                 jint height   = NEXT_INT(b);</span>
<span class="line-removed">-                 jint masklen  = width * height * sizeof(jint);</span>
<span class="line-removed">-                 MTLMaskBlit_MaskBlit(env, mtlc, dstOps,</span>
<span class="line-removed">-                                      dstx, dsty, width, height, b);</span>
<span class="line-removed">-                 SKIP_BYTES(b, masklen);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // state-related ops</span>
<span class="line-removed">-         case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-removed">-                 jint x1 = NEXT_INT(b);</span>
<span class="line-removed">-                 jint y1 = NEXT_INT(b);</span>
<span class="line-removed">-                 jint x2 = NEXT_INT(b);</span>
<span class="line-removed">-                 jint y2 = NEXT_INT(b);</span>
<span class="line-removed">-                 [mtlc setClipRectX1:x1 Y1:y1 X2:x2 Y2:y2];</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-removed">-                 [mtlc beginShapeClip:dstOps];</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-removed">-                 // This results in creation of new render encoder with</span>
<span class="line-removed">-                 // stencil buffer set as render target</span>
<span class="line-removed">-                 jint count = NEXT_INT(b);</span>
<span class="line-removed">-                 MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);</span>
<span class="line-removed">-                 SKIP_BYTES(b, count * BYTES_PER_SPAN);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-removed">-                 [mtlc endShapeClip:dstOps];</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-removed">-                 [mtlc resetClip];</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-removed">-                 jint rule         = NEXT_INT(b);</span>
<span class="line-removed">-                 jfloat extraAlpha = NEXT_FLOAT(b);</span>
<span class="line-removed">-                 jint flags        = NEXT_INT(b);</span>
<span class="line-removed">-                 [mtlc setAlphaCompositeRule:rule extraAlpha:extraAlpha flags:flags];</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-removed">-                 jint xorPixel = NEXT_INT(b);</span>
<span class="line-removed">-                 [mtlc setXorComposite:xorPixel];</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 /* TODO: check whether something needs to be done here if we are moving out of XOR composite</span>
<span class="line-removed">-                 commitEncodedCommands();</span>
<span class="line-removed">-                 MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];</span>
<span class="line-removed">-                 [cbwrapper onComplete];</span>
  
<span class="line-modified">!                 J2dTraceLn(J2D_TRACE_VERBOSE, &quot;RESET_COMPOSITE - Force commit earlier draw calls before RESET_COMPOSITE.&quot;);*/</span>
  
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                 [mtlc resetComposite];</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-removed">-                 jdouble m00 = NEXT_DOUBLE(b);</span>
<span class="line-removed">-                 jdouble m10 = NEXT_DOUBLE(b);</span>
<span class="line-removed">-                 jdouble m01 = NEXT_DOUBLE(b);</span>
<span class="line-removed">-                 jdouble m11 = NEXT_DOUBLE(b);</span>
<span class="line-removed">-                 jdouble m02 = NEXT_DOUBLE(b);</span>
<span class="line-removed">-                 jdouble m12 = NEXT_DOUBLE(b);</span>
<span class="line-removed">-                 [mtlc setTransformM00:m00 M10:m10 M01:m01 M11:m11 M02:m02 M12:m12];</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-removed">-                 [mtlc resetTransform];</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
  
<span class="line-modified">!         // context-related ops</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                 jlong pSrc = NEXT_LONG(b);</span>
<span class="line-modified">!                 jlong pDst = NEXT_LONG(b);</span>
  
<span class="line-modified">!                 dstOps = (BMTLSDOps *)jlong_to_ptr(pDst);</span>
<span class="line-modified">!                 mtlc = [MTLContext setSurfacesEnv:env src:pSrc dst:pDst];</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:</span>
<span class="line-modified">!             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-removed">-                 jlong pConfigInfo = NEXT_LONG(b);</span>
<span class="line-removed">-                 MTLGraphicsConfigInfo *mtlInfo =</span>
<span class="line-removed">-                         (MTLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);</span>
  
<span class="line-modified">!                 if (mtlInfo == NULL) {</span>
  
<span class="line-modified">!                 } else {</span>
<span class="line-removed">-                     MTLContext *newMtlc = mtlInfo-&gt;context;</span>
<span class="line-removed">-                     if (newMtlc == NULL) {</span>
  
                      } else {
<span class="line-modified">!                         mtlc = newMtlc;</span>
<span class="line-modified">!                         dstOps = NULL;</span>
                      }
                  }
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                 jlong pData = NEXT_LONG(b);</span>
<span class="line-modified">!                 BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);</span>
<span class="line-modified">!                 if (mtlsdo != NULL) {</span>
<span class="line-modified">!                     CONTINUE_IF_NULL(mtlc);</span>
<span class="line-modified">!                     MTLSD_Delete(env, mtlsdo);</span>
                  }
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                 jlong pData = NEXT_LONG(b);</span>
<span class="line-modified">!                 BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);</span>
<span class="line-modified">!                 if (mtlsdo != NULL) {</span>
<span class="line-modified">!                     CONTINUE_IF_NULL(mtlc);</span>
<span class="line-modified">!                     MTLSD_Delete(env, mtlsdo);</span>
<span class="line-modified">!                     if (mtlsdo-&gt;privOps != NULL) {</span>
<span class="line-removed">-                         free(mtlsdo-&gt;privOps);</span>
                      }
                  }
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-removed">-                 jlong pConfigInfo = NEXT_LONG(b);</span>
<span class="line-removed">-                 CONTINUE_IF_NULL(mtlc);</span>
<span class="line-removed">-                 MTLGC_DestroyMTLGraphicsConfig(pConfigInfo);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 // the previous method will call glX/wglMakeCurrent(None),</span>
<span class="line-removed">-                 // so we should nullify the current mtlc and dstOps to avoid</span>
<span class="line-removed">-                 // calling glFlush() (or similar) while no context is current</span>
<span class="line-removed">-                 mtlc = NULL;</span>
<span class="line-removed">-              //   dstOps = NULL;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-removed">-                 // invalidate the references to the current context and</span>
<span class="line-removed">-                 // destination surface that are maintained at the native level</span>
<span class="line-removed">-                 mtlc = NULL;</span>
<span class="line-removed">-             //    dstOps = NULL;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case sun_java2d_pipe_BufferedOpCodes_SYNC:</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 CHECK_PREVIOUS_OP(MTL_OP_SYNC);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
  
<span class="line-modified">!         // multibuffering ops</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                 jlong window = NEXT_LONG(b);</span>
<span class="line-modified">!                 MTLSD_SwapBuffers(env, window);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
  
<span class="line-modified">!         // special no-op (mainly used for achieving 8-byte alignment)</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_NOOP:</span>
<span class="line-modified">!             break;</span>
  
<span class="line-modified">!         // paint-related ops</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!               CHECK_PREVIOUS_OP(MTL_OP_RESET_PAINT);</span>
<span class="line-modified">!               [mtlc resetPaint];</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_SET_COLOR);</span>
<span class="line-modified">!                 jint pixel = NEXT_INT(b);</span>
<span class="line-modified">!                 [mtlc setColorPaint:pixel];</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                 jboolean useMask= NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                 jboolean cyclic = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                 jdouble p0      = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                 jdouble p1      = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                 jdouble p3      = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                 jint pixel1     = NEXT_INT(b);</span>
<span class="line-modified">!                 jint pixel2     = NEXT_INT(b);</span>
<span class="line-modified">!                 [mtlc setGradientPaintUseMask:useMask</span>
<span class="line-modified">!                                     cyclic:cyclic</span>
<span class="line-modified">!                                         p0:p0</span>
<span class="line-modified">!                                         p1:p1</span>
<span class="line-modified">!                                         p3:p3</span>
<span class="line-modified">!                                     pixel1:pixel1</span>
<span class="line-modified">!                                     pixel2:pixel2];</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                 jboolean useMask = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                 jboolean linear  = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                 jint cycleMethod = NEXT_INT(b);</span>
<span class="line-modified">!                 jint numStops    = NEXT_INT(b);</span>
<span class="line-modified">!                 jfloat p0        = NEXT_FLOAT(b);</span>
<span class="line-modified">!                 jfloat p1        = NEXT_FLOAT(b);</span>
<span class="line-modified">!                 jfloat p3        = NEXT_FLOAT(b);</span>
<span class="line-modified">!                 void *fractions, *pixels;</span>
<span class="line-modified">!                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));</span>
<span class="line-modified">!                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));</span>
<span class="line-modified">!                 [mtlc setLinearGradientPaint:useMask</span>
<span class="line-modified">!                                       linear:linear</span>
<span class="line-modified">!                                  cycleMethod:cycleMethod</span>
<span class="line-modified">!                                     numStops:numStops</span>
<span class="line-modified">!                                           p0:p0</span>
<span class="line-modified">!                                           p1:p1</span>
<span class="line-modified">!                                           p3:p3</span>
<span class="line-modified">!                                    fractions:fractions</span>
<span class="line-modified">!                                       pixels:pixels];</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                 jboolean useMask = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                 jboolean linear  = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                 jint numStops    = NEXT_INT(b);</span>
<span class="line-modified">!                 jint cycleMethod = NEXT_INT(b);</span>
<span class="line-modified">!                 jfloat m00       = NEXT_FLOAT(b);</span>
<span class="line-modified">!                 jfloat m01       = NEXT_FLOAT(b);</span>
<span class="line-modified">!                 jfloat m02       = NEXT_FLOAT(b);</span>
<span class="line-modified">!                 jfloat m10       = NEXT_FLOAT(b);</span>
<span class="line-modified">!                 jfloat m11       = NEXT_FLOAT(b);</span>
<span class="line-modified">!                 jfloat m12       = NEXT_FLOAT(b);</span>
<span class="line-modified">!                 jfloat focusX    = NEXT_FLOAT(b);</span>
<span class="line-modified">!                 void *fractions, *pixels;</span>
<span class="line-modified">!                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));</span>
<span class="line-modified">!                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));</span>
<span class="line-modified">!                 [mtlc setRadialGradientPaint:useMask</span>
<span class="line-modified">!                                       linear:linear</span>
<span class="line-modified">!                                  cycleMethod:cycleMethod</span>
<span class="line-modified">!                                     numStops:numStops</span>
<span class="line-modified">!                                          m00:m00</span>
<span class="line-modified">!                                          m01:m01</span>
<span class="line-modified">!                                          m02:m02</span>
<span class="line-modified">!                                          m10:m10</span>
<span class="line-modified">!                                          m11:m11</span>
<span class="line-modified">!                                          m12:m12</span>
<span class="line-modified">!                                       focusX:focusX</span>
<span class="line-modified">!                                    fractions:fractions</span>
<span class="line-modified">!                                       pixels:pixels];</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                 jboolean useMask= NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                 jboolean filter = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                 jlong pSrc      = NEXT_LONG(b);</span>
<span class="line-modified">!                 jdouble xp0     = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                 jdouble xp1     = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                 jdouble xp3     = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                 jdouble yp0     = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                 jdouble yp1     = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                 jdouble yp3     = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                 [mtlc setTexturePaint:useMask</span>
<span class="line-modified">!                               pSrcOps:pSrc</span>
<span class="line-modified">!                                filter:filter</span>
<span class="line-modified">!                                   xp0:xp0</span>
<span class="line-modified">!                                   xp1:xp1</span>
<span class="line-modified">!                                   xp3:xp3</span>
<span class="line-modified">!                                   yp0:yp0</span>
<span class="line-modified">!                                   yp1:yp1</span>
<span class="line-modified">!                                   yp3:yp3];</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
  
<span class="line-modified">!         // BufferedImageOp-related ops</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                 jlong pSrc        = NEXT_LONG(b);</span>
<span class="line-modified">!                 jboolean edgeZero = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                 jint kernelWidth  = NEXT_INT(b);</span>
<span class="line-modified">!                 jint kernelHeight = NEXT_INT(b);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 BMTLSDOps * bmtlsdOps = (BMTLSDOps *)pSrc;</span>
<span class="line-modified">!                 MTLConvolveOp * convolveOp = [[MTLConvolveOp alloc] init:edgeZero</span>
<span class="line-modified">!                         kernelWidth:kernelWidth</span>
<span class="line-modified">!                        kernelHeight:kernelHeight</span>
<span class="line-modified">!                            srcWidth:bmtlsdOps-&gt;width</span>
<span class="line-modified">!                           srcHeight:bmtlsdOps-&gt;height</span>
<span class="line-modified">!                              kernel:b</span>
<span class="line-modified">!                              device:mtlc.device</span>
<span class="line-modified">!                                               ];</span>
<span class="line-modified">!                 [mtlc setBufImgOp:convolveOp];</span>
<span class="line-modified">!                 SKIP_BYTES(b, kernelWidth * kernelHeight * sizeof(jfloat));</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                 [mtlc setBufImgOp:NULL];</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                 jlong pSrc          = NEXT_LONG(b);</span>
<span class="line-modified">!                 jboolean nonPremult = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                 jint numFactors     = 4;</span>
<span class="line-modified">!                 unsigned char *scaleFactors = b;</span>
<span class="line-modified">!                 unsigned char *offsets = (b + numFactors * sizeof(jfloat));</span>
<span class="line-modified">!                 MTLRescaleOp * rescaleOp = [[MTLRescaleOp alloc] init:nonPremult factors:scaleFactors offsets:offsets];</span>
<span class="line-modified">!                 [mtlc setBufImgOp:rescaleOp];</span>
<span class="line-modified">!                 SKIP_BYTES(b, numFactors * sizeof(jfloat) * 2);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                 [mtlc setBufImgOp:NULL];</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                 jlong pSrc          = NEXT_LONG(b);</span>
<span class="line-modified">!                 jboolean nonPremult = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                 jboolean shortData  = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                 jint numBands       = NEXT_INT(b);</span>
<span class="line-modified">!                 jint bandLength     = NEXT_INT(b);</span>
<span class="line-modified">!                 jint offset         = NEXT_INT(b);</span>
<span class="line-modified">!                 jint bytesPerElem = shortData ? sizeof(jshort):sizeof(jbyte);</span>
<span class="line-modified">!                 void *tableValues = b;</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 MTLLookupOp * lookupOp = [[MTLLookupOp alloc] init:nonPremult</span>
<span class="line-modified">!                                                          shortData:shortData</span>
<span class="line-modified">!                                                           numBands:numBands</span>
<span class="line-modified">!                                                         bandLength:bandLength</span>
<span class="line-modified">!                                                             offset:offset</span>
<span class="line-modified">!                                                        tableValues:tableValues</span>
<span class="line-modified">!                                                             device:mtlc.device];</span>
<span class="line-modified">!                 [mtlc setBufImgOp:lookupOp];</span>
<span class="line-modified">!                 SKIP_BYTES(b, numBands * bandLength * bytesPerElem);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                 [mtlc setBufImgOp:NULL];</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
  
<span class="line-modified">!         default:</span>
<span class="line-modified">!             J2dRlsTraceLn1(J2D_TRACE_ERROR,</span>
<span class="line-modified">!                 &quot;MTLRenderQueue_flushBuffer: invalid opcode=%d&quot;, opcode);</span>
<span class="line-modified">!             return;</span>
          }
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     if (mtlc != NULL) {</span>
<span class="line-modified">!         [mtlc.encoderManager endEncoder];</span>
<span class="line-modified">!         MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];</span>
<span class="line-modified">!         id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];</span>
<span class="line-modified">!         [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {</span>
<span class="line-modified">!             [cbwrapper release];</span>
<span class="line-modified">!         }];</span>
<span class="line-modified">!         [commandbuf commit];</span>
<span class="line-modified">!         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();</span>
<span class="line-modified">!         if (dstOps != NULL) {</span>
<span class="line-modified">!             MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps-&gt;privOps;</span>
<span class="line-modified">!             MTLLayer *layer = (MTLLayer*)dstMTLOps-&gt;layer;</span>
<span class="line-modified">!             if (layer != NULL) {</span>
<span class="line-modified">!                 [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){</span>
<span class="line-modified">!                     AWT_ASSERT_APPKIT_THREAD;</span>
<span class="line-modified">!                     [layer setNeedsDisplay];</span>
<span class="line-modified">!                 }];</span>
              }
          }
      }
<span class="line-removed">-     RESET_PREVIOUS_OP();</span>
  }
  
  /**
   * Returns a pointer to the &quot;current&quot; context, as set by the last SET_SURFACES
   * or SET_SCRATCH_SURFACE operation.
<span class="line-new-header">--- 361,792 ---</span>
              &quot;MTLRenderQueue_flushBuffer: cannot get direct buffer address&quot;);
          return;
      }
  
      end = b + limit;
<span class="line-modified">!     @autoreleasepool {</span>
<span class="line-modified">!         jboolean DEBUG_LOG = JNI_FALSE;</span>
<span class="line-modified">!         while (b &lt; end) {</span>
<span class="line-modified">!             jint opcode = NEXT_INT(b);</span>
<span class="line-modified">! </span>
<span class="line-modified">!             if (DEBUG_LOG) {</span>
<span class="line-modified">!                 J2dTraceLn2(J2D_TRACE_ERROR,</span>
<span class="line-modified">!                         &quot;MTLRenderQueue_flushBuffer: opcode_name = %s, rem=%d&quot;,</span>
<span class="line-modified">!                         getOpcodeString(opcode), (end-b));</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 J2dTraceLn2(J2D_TRACE_VERBOSE,</span>
<span class="line-modified">!                         &quot;MTLRenderQueue_flushBuffer: opcode=%d, rem=%d&quot;,</span>
<span class="line-modified">!                         opcode, (end-b));</span>
<span class="line-modified">!             }</span>
<span class="line-modified">! </span>
<span class="line-modified">!             switch (opcode) {</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 // draw ops</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     if ([mtlc useXORComposite]) {</span>
<span class="line-modified">!                         commitEncodedCommands();</span>
<span class="line-modified">!                         J2dTraceLn(J2D_TRACE_VERBOSE,</span>
<span class="line-added">+                                    &quot;DRAW_LINE in XOR mode - Force commit earlier draw calls before DRAW_LINE.&quot;);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     jint x1 = NEXT_INT(b);</span>
<span class="line-added">+                     jint y1 = NEXT_INT(b);</span>
<span class="line-added">+                     jint x2 = NEXT_INT(b);</span>
<span class="line-added">+                     jint y2 = NEXT_INT(b);</span>
<span class="line-added">+                     MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);</span>
<span class="line-added">+                     break;</span>
                  }
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     if ([mtlc useXORComposite]) {</span>
<span class="line-modified">!                         commitEncodedCommands();</span>
<span class="line-modified">!                         J2dTraceLn(J2D_TRACE_VERBOSE,</span>
<span class="line-modified">!                                    &quot;DRAW_RECT in XOR mode - Force commit earlier draw calls before DRAW_RECT.&quot;);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                     jint x = NEXT_INT(b);</span>
<span class="line-modified">!                     jint y = NEXT_INT(b);</span>
<span class="line-modified">!                     jint w = NEXT_INT(b);</span>
<span class="line-modified">!                     jint h = NEXT_INT(b);</span>
<span class="line-modified">!                     MTLRenderer_DrawRect(mtlc, dstOps, x, y, w, h);</span>
<span class="line-added">+                     break;</span>
                  }
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                     jint nPoints      = NEXT_INT(b);</span>
<span class="line-modified">!                     jboolean isClosed = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                     jint transX       = NEXT_INT(b);</span>
<span class="line-modified">!                     jint transY       = NEXT_INT(b);</span>
<span class="line-modified">!                     jint *xPoints = (jint *)b;</span>
<span class="line-modified">!                     jint *yPoints = ((jint *)b) + nPoints;</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     if ([mtlc useXORComposite]) {</span>
<span class="line-modified">!                         commitEncodedCommands();</span>
<span class="line-modified">!                         J2dTraceLn(J2D_TRACE_VERBOSE,</span>
<span class="line-modified">!                                    &quot;DRAW_POLY in XOR mode - Force commit earlier draw calls before DRAW_POLY.&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                         // draw separate (N-1) lines using N points</span>
<span class="line-modified">!                         for(int point = 0; point &lt; nPoints-1; point++) {</span>
<span class="line-modified">!                             jint x1 = xPoints[point] + transX;</span>
<span class="line-modified">!                             jint y1 = yPoints[point] + transY;</span>
<span class="line-modified">!                             jint x2 = xPoints[point + 1] + transX;</span>
<span class="line-modified">!                             jint y2 = yPoints[point + 1] + transY;</span>
<span class="line-modified">!                             MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);</span>
<span class="line-modified">!                         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!                         if (isClosed) {</span>
<span class="line-modified">!                             MTLRenderer_DrawLine(mtlc, dstOps, xPoints[0] + transX, yPoints[0] + transY,</span>
<span class="line-modified">!                                                  xPoints[nPoints-1] + transX, yPoints[nPoints-1] + transY);</span>
<span class="line-modified">!                         }</span>
<span class="line-added">+                     } else {</span>
<span class="line-added">+                         MTLRenderer_DrawPoly(mtlc, dstOps, nPoints, isClosed, transX, transY, xPoints, yPoints);</span>
                      }
  
<span class="line-modified">!                     SKIP_BYTES(b, nPoints * BYTES_PER_POLY_POINT);</span>
<span class="line-modified">!                     break;</span>
                  }
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if ([mtlc useXORComposite]) {</span>
<span class="line-added">+                         commitEncodedCommands();</span>
<span class="line-added">+                         J2dTraceLn(J2D_TRACE_VERBOSE,</span>
<span class="line-added">+                                    &quot;DRAW_PIXEL in XOR mode - Force commit earlier draw calls before DRAW_PIXEL.&quot;);</span>
<span class="line-added">+                     }</span>
  
<span class="line-modified">!                     jint x = NEXT_INT(b);</span>
<span class="line-modified">!                     jint y = NEXT_INT(b);</span>
<span class="line-modified">!                     CONTINUE_IF_NULL(mtlc);</span>
<span class="line-modified">!                     MTLRenderer_DrawPixel(mtlc, dstOps, x, y);</span>
<span class="line-modified">!                     break;</span>
                  }
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if ([mtlc useXORComposite]) {</span>
<span class="line-added">+                         commitEncodedCommands();</span>
<span class="line-added">+                         J2dTraceLn(J2D_TRACE_VERBOSE,</span>
<span class="line-added">+                                    &quot;DRAW_SCANLINES in XOR mode - Force commit earlier draw calls before &quot;</span>
<span class="line-added">+                                    &quot;DRAW_SCANLINES.&quot;);</span>
<span class="line-added">+                     }</span>
  
<span class="line-modified">!                     jint count = NEXT_INT(b);</span>
<span class="line-modified">!                     MTLRenderer_DrawScanlines(mtlc, dstOps, count, (jint *)b);</span>
  
<span class="line-modified">!                     SKIP_BYTES(b, count * BYTES_PER_SCANLINE);</span>
<span class="line-modified">!                     break;</span>
                  }
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if ([mtlc useXORComposite]) {</span>
<span class="line-added">+                         commitEncodedCommands();</span>
<span class="line-added">+                         J2dTraceLn(J2D_TRACE_VERBOSE,</span>
<span class="line-added">+                                    &quot;DRAW_PARALLELOGRAM in XOR mode - Force commit earlier draw calls before &quot;</span>
<span class="line-added">+                                    &quot;DRAW_PARALLELOGRAM.&quot;);</span>
<span class="line-added">+                     }</span>
  
<span class="line-modified">!                     jfloat x11 = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     jfloat y11 = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     jfloat dx21 = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     jfloat dy21 = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     jfloat dx12 = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     jfloat dy12 = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     jfloat lwr21 = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     jfloat lwr12 = NEXT_FLOAT(b);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     MTLRenderer_DrawParallelogram(mtlc, dstOps,</span>
<span class="line-modified">!                                                   x11, y11,</span>
<span class="line-modified">!                                                   dx21, dy21,</span>
<span class="line-modified">!                                                   dx12, dy12,</span>
<span class="line-added">+                                                   lwr21, lwr12);</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added">+                     jfloat x11 = NEXT_FLOAT(b);</span>
<span class="line-added">+                     jfloat y11 = NEXT_FLOAT(b);</span>
<span class="line-added">+                     jfloat dx21 = NEXT_FLOAT(b);</span>
<span class="line-added">+                     jfloat dy21 = NEXT_FLOAT(b);</span>
<span class="line-added">+                     jfloat dx12 = NEXT_FLOAT(b);</span>
<span class="line-added">+                     jfloat dy12 = NEXT_FLOAT(b);</span>
<span class="line-added">+                     jfloat lwr21 = NEXT_FLOAT(b);</span>
<span class="line-added">+                     jfloat lwr12 = NEXT_FLOAT(b);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     MTLRenderer_DrawAAParallelogram(mtlc, dstOps,</span>
<span class="line-added">+                                                     x11, y11,</span>
<span class="line-added">+                                                     dx21, dy21,</span>
<span class="line-added">+                                                     dx12, dy12,</span>
<span class="line-added">+                                                     lwr21, lwr12);</span>
<span class="line-added">+                     break;</span>
                  }
  
<span class="line-modified">!                 // fill ops</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
  
<span class="line-modified">!                     if ([mtlc useXORComposite]) {</span>
<span class="line-modified">!                         commitEncodedCommands();</span>
<span class="line-modified">!                         J2dTraceLn(J2D_TRACE_VERBOSE,</span>
<span class="line-modified">!                                    &quot;FILL_RECT in XOR mode - Force commit earlier draw calls before FILL_RECT.&quot;);</span>
<span class="line-added">+                     }</span>
  
<span class="line-modified">!                     jint x = NEXT_INT(b);</span>
<span class="line-modified">!                     jint y = NEXT_INT(b);</span>
<span class="line-modified">!                     jint w = NEXT_INT(b);</span>
<span class="line-added">+                     jint h = NEXT_INT(b);</span>
<span class="line-added">+                     MTLRenderer_FillRect(mtlc, dstOps, x, y, w, h);</span>
<span class="line-added">+                     break;</span>
                  }
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if ([mtlc useXORComposite]) {</span>
<span class="line-added">+                         commitEncodedCommands();</span>
<span class="line-added">+                         J2dTraceLn(J2D_TRACE_VERBOSE,</span>
<span class="line-added">+                                    &quot;FILL_SPANS in XOR mode - Force commit earlier draw calls before FILL_SPANS.&quot;);</span>
<span class="line-added">+                     }</span>
  
<span class="line-modified">!                     jint count = NEXT_INT(b);</span>
<span class="line-modified">!                     MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);</span>
<span class="line-modified">!                     SKIP_BYTES(b, count * BYTES_PER_SPAN);</span>
<span class="line-modified">!                     break;</span>
                  }
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if ([mtlc useXORComposite]) {</span>
<span class="line-added">+                         commitEncodedCommands();</span>
<span class="line-added">+                         J2dTraceLn(J2D_TRACE_VERBOSE,</span>
<span class="line-added">+                                    &quot;FILL_PARALLELOGRAM in XOR mode - Force commit earlier draw calls before &quot;</span>
<span class="line-added">+                                    &quot;FILL_PARALLELOGRAM.&quot;);</span>
<span class="line-added">+                     }</span>
  
<span class="line-modified">!                     jfloat x11 = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     jfloat y11 = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     jfloat dx21 = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     jfloat dy21 = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     jfloat dx12 = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     jfloat dy12 = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     MTLRenderer_FillParallelogram(mtlc, dstOps,</span>
<span class="line-modified">!                                                   x11, y11,</span>
<span class="line-modified">!                                                   dx21, dy21,</span>
<span class="line-modified">!                                                   dx12, dy12);</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_AA);</span>
<span class="line-added">+                     jfloat x11 = NEXT_FLOAT(b);</span>
<span class="line-added">+                     jfloat y11 = NEXT_FLOAT(b);</span>
<span class="line-added">+                     jfloat dx21 = NEXT_FLOAT(b);</span>
<span class="line-added">+                     jfloat dy21 = NEXT_FLOAT(b);</span>
<span class="line-added">+                     jfloat dx12 = NEXT_FLOAT(b);</span>
<span class="line-added">+                     jfloat dy12 = NEXT_FLOAT(b);</span>
<span class="line-added">+                     MTLRenderer_FillAAParallelogram(mtlc, dstOps,</span>
<span class="line-added">+                                                     x11, y11,</span>
<span class="line-added">+                                                     dx21, dy21,</span>
<span class="line-added">+                                                     dx12, dy12);</span>
<span class="line-added">+                     break;</span>
                  }
  
<span class="line-modified">!                 // text-related ops</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
  
<span class="line-modified">!                     if ([mtlc useXORComposite]) {</span>
<span class="line-modified">!                         commitEncodedCommands();</span>
<span class="line-modified">!                         J2dTraceLn(J2D_TRACE_VERBOSE,</span>
<span class="line-modified">!                                    &quot;DRAW_GLYPH_LIST in XOR mode - Force commit earlier draw calls before &quot;</span>
<span class="line-added">+                                    &quot;DRAW_GLYPH_LIST.&quot;);</span>
<span class="line-added">+                     }</span>
  
<span class="line-modified">!                     jint numGlyphs        = NEXT_INT(b);</span>
<span class="line-modified">!                     jint packedParams     = NEXT_INT(b);</span>
<span class="line-modified">!                     jfloat glyphListOrigX = NEXT_FLOAT(b);</span>
<span class="line-added">+                     jfloat glyphListOrigY = NEXT_FLOAT(b);</span>
<span class="line-added">+                     jboolean usePositions = EXTRACT_BOOLEAN(packedParams,</span>
<span class="line-added">+                                                             OFFSET_POSITIONS);</span>
<span class="line-added">+                     jboolean subPixPos    = EXTRACT_BOOLEAN(packedParams,</span>
<span class="line-added">+                                                             OFFSET_SUBPIXPOS);</span>
<span class="line-added">+                     jboolean rgbOrder     = EXTRACT_BOOLEAN(packedParams,</span>
<span class="line-added">+                                                             OFFSET_RGBORDER);</span>
<span class="line-added">+                     jint lcdContrast      = EXTRACT_BYTE(packedParams,</span>
<span class="line-added">+                                                          OFFSET_CONTRAST);</span>
<span class="line-added">+                     unsigned char *images = b;</span>
<span class="line-added">+                     unsigned char *positions;</span>
<span class="line-added">+                     jint bytesPerGlyph;</span>
<span class="line-added">+                     if (usePositions) {</span>
<span class="line-added">+                         positions = (b + numGlyphs * BYTES_PER_GLYPH_IMAGE);</span>
<span class="line-added">+                         bytesPerGlyph = BYTES_PER_POSITIONED_GLYPH;</span>
<span class="line-added">+                     } else {</span>
<span class="line-added">+                         positions = NULL;</span>
<span class="line-added">+                         bytesPerGlyph = BYTES_PER_GLYPH_IMAGE;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     MTLTR_DrawGlyphList(env, mtlc, dstOps,</span>
<span class="line-added">+                                         numGlyphs, usePositions,</span>
<span class="line-added">+                                         subPixPos, rgbOrder, lcdContrast,</span>
<span class="line-added">+                                         glyphListOrigX, glyphListOrigY,</span>
<span class="line-added">+                                         images, positions);</span>
<span class="line-added">+                     SKIP_BYTES(b, numGlyphs * bytesPerGlyph);</span>
<span class="line-added">+                     break;</span>
                  }
  
<span class="line-modified">!                 // copy-related ops</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                     jint x  = NEXT_INT(b);</span>
<span class="line-modified">!                     jint y  = NEXT_INT(b);</span>
<span class="line-modified">!                     jint w  = NEXT_INT(b);</span>
<span class="line-modified">!                     jint h  = NEXT_INT(b);</span>
<span class="line-modified">!                     jint dx = NEXT_INT(b);</span>
<span class="line-modified">!                     jint dy = NEXT_INT(b);</span>
<span class="line-modified">!                     MTLBlitLoops_CopyArea(env, mtlc, dstOps,</span>
<span class="line-modified">!                                           x, y, w, h, dx, dy);</span>
<span class="line-modified">!                     break;</span>
                  }
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_BLIT:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                     jint packedParams = NEXT_INT(b);</span>
<span class="line-modified">!                     jint sx1          = NEXT_INT(b);</span>
<span class="line-modified">!                     jint sy1          = NEXT_INT(b);</span>
<span class="line-modified">!                     jint sx2          = NEXT_INT(b);</span>
<span class="line-modified">!                     jint sy2          = NEXT_INT(b);</span>
<span class="line-modified">!                     jdouble dx1       = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                     jdouble dy1       = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                     jdouble dx2       = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                     jdouble dy2       = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                     jlong pSrc        = NEXT_LONG(b);</span>
<span class="line-modified">!                     jlong pDst        = NEXT_LONG(b);</span>
<span class="line-modified">!                     jint hint         = EXTRACT_BYTE(packedParams, OFFSET_HINT);</span>
<span class="line-modified">!                     jboolean texture  = EXTRACT_BOOLEAN(packedParams,</span>
<span class="line-modified">!                                                         OFFSET_TEXTURE);</span>
<span class="line-modified">!                     jboolean xform    = EXTRACT_BOOLEAN(packedParams,</span>
<span class="line-modified">!                                                         OFFSET_XFORM);</span>
<span class="line-modified">!                     jboolean isoblit  = EXTRACT_BOOLEAN(packedParams,</span>
<span class="line-modified">!                                                         OFFSET_ISOBLIT);</span>
<span class="line-modified">!                     if (isoblit) {</span>
<span class="line-modified">!                         MTLBlitLoops_IsoBlit(env, mtlc, pSrc, pDst,</span>
<span class="line-modified">!                                              xform, hint, texture,</span>
<span class="line-modified">!                                              sx1, sy1, sx2, sy2,</span>
<span class="line-modified">!                                              dx1, dy1, dx2, dy2);</span>
<span class="line-modified">!                     } else {</span>
<span class="line-modified">!                         jint srctype = EXTRACT_BYTE(packedParams, OFFSET_SRCTYPE);</span>
<span class="line-modified">!                         MTLBlitLoops_Blit(env, mtlc, pSrc, pDst,</span>
<span class="line-modified">!                                           xform, hint, srctype, texture,</span>
<span class="line-modified">!                                           sx1, sy1, sx2, sy2,</span>
<span class="line-modified">!                                           dx1, dy1, dx2, dy2);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                     jint sx      = NEXT_INT(b);</span>
<span class="line-modified">!                     jint sy      = NEXT_INT(b);</span>
<span class="line-modified">!                     jint dx      = NEXT_INT(b);</span>
<span class="line-modified">!                     jint dy      = NEXT_INT(b);</span>
<span class="line-modified">!                     jint w       = NEXT_INT(b);</span>
<span class="line-modified">!                     jint h       = NEXT_INT(b);</span>
<span class="line-modified">!                     jint dsttype = NEXT_INT(b);</span>
<span class="line-modified">!                     jlong pSrc   = NEXT_LONG(b);</span>
<span class="line-modified">!                     jlong pDst   = NEXT_LONG(b);</span>
<span class="line-modified">!                     MTLBlitLoops_SurfaceToSwBlit(env, mtlc,</span>
<span class="line-modified">!                                                  pSrc, pDst, dsttype,</span>
<span class="line-modified">!                                                  sx, sy, dx, dy, w, h);</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added">+                     jint x        = NEXT_INT(b);</span>
<span class="line-added">+                     jint y        = NEXT_INT(b);</span>
<span class="line-added">+                     jint w        = NEXT_INT(b);</span>
<span class="line-added">+                     jint h        = NEXT_INT(b);</span>
<span class="line-added">+                     jint maskoff  = NEXT_INT(b);</span>
<span class="line-added">+                     jint maskscan = NEXT_INT(b);</span>
<span class="line-added">+                     jint masklen  = NEXT_INT(b);</span>
<span class="line-added">+                     unsigned char *pMask = (masklen &gt; 0) ? b : NULL;</span>
<span class="line-added">+                     MTLMaskFill_MaskFill(mtlc, dstOps, x, y, w, h,</span>
<span class="line-added">+                                          maskoff, maskscan, masklen, pMask);</span>
<span class="line-added">+                     SKIP_BYTES(b, masklen);</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added">+                     jint dstx     = NEXT_INT(b);</span>
<span class="line-added">+                     jint dsty     = NEXT_INT(b);</span>
<span class="line-added">+                     jint width    = NEXT_INT(b);</span>
<span class="line-added">+                     jint height   = NEXT_INT(b);</span>
<span class="line-added">+                     jint masklen  = width * height * sizeof(jint);</span>
<span class="line-added">+                     MTLMaskBlit_MaskBlit(env, mtlc, dstOps,</span>
<span class="line-added">+                                          dstx, dsty, width, height, b);</span>
<span class="line-added">+                     SKIP_BYTES(b, masklen);</span>
<span class="line-added">+                     break;</span>
                  }
  
<span class="line-modified">!                 // state-related ops</span>
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added">+                     jint x1 = NEXT_INT(b);</span>
<span class="line-added">+                     jint y1 = NEXT_INT(b);</span>
<span class="line-added">+                     jint x2 = NEXT_INT(b);</span>
<span class="line-added">+                     jint y2 = NEXT_INT(b);</span>
<span class="line-added">+                     [mtlc setClipRectX1:x1 Y1:y1 X2:x2 Y2:y2];</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added">+                     [mtlc beginShapeClip:dstOps];</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added">+                     // This results in creation of new render encoder with</span>
<span class="line-added">+                     // stencil buffer set as render target</span>
<span class="line-added">+                     jint count = NEXT_INT(b);</span>
<span class="line-added">+                     MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);</span>
<span class="line-added">+                     SKIP_BYTES(b, count * BYTES_PER_SPAN);</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added">+                     [mtlc endShapeClip:dstOps];</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added">+                     [mtlc resetClip];</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added">+                     jint rule         = NEXT_INT(b);</span>
<span class="line-added">+                     jfloat extraAlpha = NEXT_FLOAT(b);</span>
<span class="line-added">+                     jint flags        = NEXT_INT(b);</span>
<span class="line-added">+                     [mtlc setAlphaCompositeRule:rule extraAlpha:extraAlpha flags:flags];</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added">+                     jint xorPixel = NEXT_INT(b);</span>
<span class="line-added">+                     [mtlc setXorComposite:xorPixel];</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     /* TODO: check whether something needs to be done here if we are moving out of XOR composite</span>
<span class="line-added">+                     commitEncodedCommands();</span>
<span class="line-added">+                     MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];</span>
<span class="line-added">+                     [cbwrapper onComplete];</span>
  
<span class="line-modified">!                     J2dTraceLn(J2D_TRACE_VERBOSE,</span>
<span class="line-modified">!                      &quot;RESET_COMPOSITE - Force commit earlier draw calls before RESET_COMPOSITE.&quot;);*/</span>
  
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                     [mtlc resetComposite];</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:</span>
<span class="line-modified">!                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added">+                     jdouble m00 = NEXT_DOUBLE(b);</span>
<span class="line-added">+                     jdouble m10 = NEXT_DOUBLE(b);</span>
<span class="line-added">+                     jdouble m01 = NEXT_DOUBLE(b);</span>
<span class="line-added">+                     jdouble m11 = NEXT_DOUBLE(b);</span>
<span class="line-added">+                     jdouble m02 = NEXT_DOUBLE(b);</span>
<span class="line-added">+                     jdouble m12 = NEXT_DOUBLE(b);</span>
<span class="line-added">+                     [mtlc setTransformM00:m00 M10:m10 M01:m01 M11:m11 M02:m02 M12:m12];</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added">+                     [mtlc resetTransform];</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
  
<span class="line-modified">!                 // context-related ops</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                     jlong pSrc = NEXT_LONG(b);</span>
<span class="line-modified">!                     jlong pDst = NEXT_LONG(b);</span>
  
<span class="line-modified">!                     dstOps = (BMTLSDOps *)jlong_to_ptr(pDst);</span>
<span class="line-added">+                     mtlc = [MTLContext setSurfacesEnv:env src:pSrc dst:pDst];</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added">+                     jlong pConfigInfo = NEXT_LONG(b);</span>
<span class="line-added">+                     MTLGraphicsConfigInfo *mtlInfo =</span>
<span class="line-added">+                             (MTLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);</span>
  
<span class="line-modified">!                     if (mtlInfo == NULL) {</span>
  
                      } else {
<span class="line-modified">!                         MTLContext *newMtlc = mtlInfo-&gt;context;</span>
<span class="line-modified">!                         if (newMtlc == NULL) {</span>
<span class="line-added">+ </span>
<span class="line-added">+                         } else {</span>
<span class="line-added">+                             mtlc = newMtlc;</span>
<span class="line-added">+                             dstOps = NULL;</span>
<span class="line-added">+                         }</span>
                      }
<span class="line-added">+                     break;</span>
                  }
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                     jlong pData = NEXT_LONG(b);</span>
<span class="line-modified">!                     BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);</span>
<span class="line-modified">!                     if (mtlsdo != NULL) {</span>
<span class="line-modified">!                         CONTINUE_IF_NULL(mtlc);</span>
<span class="line-modified">!                         MTLSD_Delete(env, mtlsdo);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                     break;</span>
                  }
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                     jlong pData = NEXT_LONG(b);</span>
<span class="line-modified">!                     BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);</span>
<span class="line-modified">!                     if (mtlsdo != NULL) {</span>
<span class="line-modified">!                         CONTINUE_IF_NULL(mtlc);</span>
<span class="line-modified">!                         MTLSD_Delete(env, mtlsdo);</span>
<span class="line-modified">!                         if (mtlsdo-&gt;privOps != NULL) {</span>
<span class="line-modified">!                             free(mtlsdo-&gt;privOps);</span>
<span class="line-modified">!                         }</span>
                      }
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added">+                     jlong pConfigInfo = NEXT_LONG(b);</span>
<span class="line-added">+                     CONTINUE_IF_NULL(mtlc);</span>
<span class="line-added">+                     MTLGC_DestroyMTLGraphicsConfig(pConfigInfo);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     // the previous method will call glX/wglMakeCurrent(None),</span>
<span class="line-added">+                     // so we should nullify the current mtlc and dstOps to avoid</span>
<span class="line-added">+                     // calling glFlush() (or similar) while no context is current</span>
<span class="line-added">+                     mtlc = NULL;</span>
<span class="line-added">+                  //   dstOps = NULL;</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added">+                     // invalidate the references to the current context and</span>
<span class="line-added">+                     // destination surface that are maintained at the native level</span>
<span class="line-added">+                     mtlc = NULL;</span>
<span class="line-added">+                 //    dstOps = NULL;</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 case sun_java2d_pipe_BufferedOpCodes_SYNC:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     CHECK_PREVIOUS_OP(MTL_OP_SYNC);</span>
<span class="line-added">+                     break;</span>
                  }
  
<span class="line-modified">!                 // multibuffering ops</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                     jlong window = NEXT_LONG(b);</span>
<span class="line-modified">!                     MTLSD_SwapBuffers(env, window);</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
  
<span class="line-modified">!                 // special no-op (mainly used for achieving 8-byte alignment)</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_NOOP:</span>
<span class="line-modified">!                     break;</span>
  
<span class="line-modified">!                 // paint-related ops</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                   CHECK_PREVIOUS_OP(MTL_OP_RESET_PAINT);</span>
<span class="line-modified">!                   [mtlc resetPaint];</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_SET_COLOR);</span>
<span class="line-modified">!                     jint pixel = NEXT_INT(b);</span>
<span class="line-modified">!                     [mtlc setColorPaint:pixel];</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                     jboolean useMask= NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                     jboolean cyclic = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                     jdouble p0      = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                     jdouble p1      = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                     jdouble p3      = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                     jint pixel1     = NEXT_INT(b);</span>
<span class="line-modified">!                     jint pixel2     = NEXT_INT(b);</span>
<span class="line-modified">!                     [mtlc setGradientPaintUseMask:useMask</span>
<span class="line-modified">!                                         cyclic:cyclic</span>
<span class="line-modified">!                                             p0:p0</span>
<span class="line-modified">!                                             p1:p1</span>
<span class="line-modified">!                                             p3:p3</span>
<span class="line-modified">!                                         pixel1:pixel1</span>
<span class="line-modified">!                                         pixel2:pixel2];</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                     jboolean useMask = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                     jboolean linear  = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                     jint cycleMethod = NEXT_INT(b);</span>
<span class="line-modified">!                     jint numStops    = NEXT_INT(b);</span>
<span class="line-modified">!                     jfloat p0        = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     jfloat p1        = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     jfloat p3        = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     void *fractions, *pixels;</span>
<span class="line-modified">!                     fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));</span>
<span class="line-modified">!                     pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));</span>
<span class="line-modified">!                     [mtlc setLinearGradientPaint:useMask</span>
<span class="line-modified">!                                           linear:linear</span>
<span class="line-modified">!                                      cycleMethod:cycleMethod</span>
<span class="line-modified">!                                         numStops:numStops</span>
<span class="line-modified">!                                               p0:p0</span>
<span class="line-modified">!                                               p1:p1</span>
<span class="line-modified">!                                               p3:p3</span>
<span class="line-modified">!                                        fractions:fractions</span>
<span class="line-modified">!                                           pixels:pixels];</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                     jboolean useMask = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                     jboolean linear  = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                     jint numStops    = NEXT_INT(b);</span>
<span class="line-modified">!                     jint cycleMethod = NEXT_INT(b);</span>
<span class="line-modified">!                     jfloat m00       = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     jfloat m01       = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     jfloat m02       = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     jfloat m10       = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     jfloat m11       = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     jfloat m12       = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     jfloat focusX    = NEXT_FLOAT(b);</span>
<span class="line-modified">!                     void *fractions, *pixels;</span>
<span class="line-modified">!                     fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));</span>
<span class="line-modified">!                     pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));</span>
<span class="line-modified">!                     [mtlc setRadialGradientPaint:useMask</span>
<span class="line-modified">!                                           linear:linear</span>
<span class="line-modified">!                                      cycleMethod:cycleMethod</span>
<span class="line-modified">!                                         numStops:numStops</span>
<span class="line-modified">!                                              m00:m00</span>
<span class="line-modified">!                                              m01:m01</span>
<span class="line-modified">!                                              m02:m02</span>
<span class="line-modified">!                                              m10:m10</span>
<span class="line-modified">!                                              m11:m11</span>
<span class="line-modified">!                                              m12:m12</span>
<span class="line-modified">!                                           focusX:focusX</span>
<span class="line-modified">!                                        fractions:fractions</span>
<span class="line-modified">!                                           pixels:pixels];</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                     jboolean useMask= NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                     jboolean filter = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                     jlong pSrc      = NEXT_LONG(b);</span>
<span class="line-modified">!                     jdouble xp0     = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                     jdouble xp1     = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                     jdouble xp3     = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                     jdouble yp0     = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                     jdouble yp1     = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                     jdouble yp3     = NEXT_DOUBLE(b);</span>
<span class="line-modified">!                     [mtlc setTexturePaint:useMask</span>
<span class="line-modified">!                                   pSrcOps:pSrc</span>
<span class="line-modified">!                                    filter:filter</span>
<span class="line-modified">!                                       xp0:xp0</span>
<span class="line-modified">!                                       xp1:xp1</span>
<span class="line-modified">!                                       xp3:xp3</span>
<span class="line-modified">!                                       yp0:yp0</span>
<span class="line-modified">!                                       yp1:yp1</span>
<span class="line-modified">!                                       yp3:yp3];</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
  
<span class="line-modified">!                 // BufferedImageOp-related ops</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                     jlong pSrc        = NEXT_LONG(b);</span>
<span class="line-modified">!                     jboolean edgeZero = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                     jint kernelWidth  = NEXT_INT(b);</span>
<span class="line-modified">!                     jint kernelHeight = NEXT_INT(b);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     BMTLSDOps * bmtlsdOps = (BMTLSDOps *)pSrc;</span>
<span class="line-modified">!                     MTLConvolveOp * convolveOp = [[MTLConvolveOp alloc] init:edgeZero</span>
<span class="line-modified">!                             kernelWidth:kernelWidth</span>
<span class="line-modified">!                            kernelHeight:kernelHeight</span>
<span class="line-modified">!                                srcWidth:bmtlsdOps-&gt;width</span>
<span class="line-modified">!                               srcHeight:bmtlsdOps-&gt;height</span>
<span class="line-modified">!                                  kernel:b</span>
<span class="line-modified">!                                  device:mtlc.device</span>
<span class="line-modified">!                                                   ];</span>
<span class="line-modified">!                     [mtlc setBufImgOp:convolveOp];</span>
<span class="line-modified">!                     SKIP_BYTES(b, kernelWidth * kernelHeight * sizeof(jfloat));</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                     [mtlc setBufImgOp:NULL];</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                     jlong pSrc          = NEXT_LONG(b);</span>
<span class="line-modified">!                     jboolean nonPremult = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                     jint numFactors     = 4;</span>
<span class="line-modified">!                     unsigned char *scaleFactors = b;</span>
<span class="line-modified">!                     unsigned char *offsets = (b + numFactors * sizeof(jfloat));</span>
<span class="line-modified">!                     MTLRescaleOp * rescaleOp =</span>
<span class="line-modified">!                             [[MTLRescaleOp alloc] init:nonPremult factors:scaleFactors offsets:offsets];</span>
<span class="line-modified">!                     [mtlc setBufImgOp:rescaleOp];</span>
<span class="line-modified">!                     SKIP_BYTES(b, numFactors * sizeof(jfloat) * 2);</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                     [mtlc setBufImgOp:NULL];</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                     jlong pSrc          = NEXT_LONG(b);</span>
<span class="line-modified">!                     jboolean nonPremult = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                     jboolean shortData  = NEXT_BOOLEAN(b);</span>
<span class="line-modified">!                     jint numBands       = NEXT_INT(b);</span>
<span class="line-modified">!                     jint bandLength     = NEXT_INT(b);</span>
<span class="line-modified">!                     jint offset         = NEXT_INT(b);</span>
<span class="line-modified">!                     jint bytesPerElem = shortData ? sizeof(jshort):sizeof(jbyte);</span>
<span class="line-modified">!                     void *tableValues = b;</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     MTLLookupOp * lookupOp = [[MTLLookupOp alloc] init:nonPremult</span>
<span class="line-modified">!                                                              shortData:shortData</span>
<span class="line-modified">!                                                               numBands:numBands</span>
<span class="line-modified">!                                                             bandLength:bandLength</span>
<span class="line-modified">!                                                                 offset:offset</span>
<span class="line-modified">!                                                            tableValues:tableValues</span>
<span class="line-modified">!                                                                 device:mtlc.device];</span>
<span class="line-modified">!                     [mtlc setBufImgOp:lookupOp];</span>
<span class="line-modified">!                     SKIP_BYTES(b, numBands * bandLength * bytesPerElem);</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-modified">!                     [mtlc setBufImgOp:NULL];</span>
<span class="line-modified">!                     break;</span>
<span class="line-added">+                 }</span>
  
<span class="line-modified">!                 default:</span>
<span class="line-modified">!                     J2dRlsTraceLn1(J2D_TRACE_ERROR,</span>
<span class="line-modified">!                         &quot;MTLRenderQueue_flushBuffer: invalid opcode=%d&quot;, opcode);</span>
<span class="line-modified">!                     return;</span>
<span class="line-added">+             }</span>
          }
  
<span class="line-modified">!         if (mtlc != NULL) {</span>
<span class="line-modified">!             [mtlc.encoderManager endEncoder];</span>
<span class="line-modified">!             MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];</span>
<span class="line-modified">!             id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];</span>
<span class="line-modified">!             [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {</span>
<span class="line-modified">!                 [cbwrapper release];</span>
<span class="line-modified">!             }];</span>
<span class="line-modified">!             [commandbuf commit];</span>
<span class="line-modified">!             BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();</span>
<span class="line-modified">!             if (dstOps != NULL) {</span>
<span class="line-modified">!                 MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps-&gt;privOps;</span>
<span class="line-modified">!                 MTLLayer *layer = (MTLLayer*)dstMTLOps-&gt;layer;</span>
<span class="line-modified">!                 if (layer != NULL) {</span>
<span class="line-modified">!                     [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){</span>
<span class="line-modified">!                         AWT_ASSERT_APPKIT_THREAD;</span>
<span class="line-modified">!                         [layer setNeedsDisplay];</span>
<span class="line-modified">!                     }];</span>
<span class="line-added">+                 }</span>
              }
          }
<span class="line-added">+         RESET_PREVIOUS_OP();</span>
      }
  }
  
  /**
   * Returns a pointer to the &quot;current&quot; context, as set by the last SET_SURFACES
   * or SET_SCRATCH_SURFACE operation.
</pre>
<center><a href="MTLPaints.m.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLTextRenderer.m.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>