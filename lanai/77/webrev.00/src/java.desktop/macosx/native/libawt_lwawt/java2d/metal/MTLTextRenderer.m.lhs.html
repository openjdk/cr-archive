<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLTextRenderer.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifndef HEADLESS
  27 
  28 #include &lt;stdlib.h&gt;
  29 #include &lt;limits.h&gt;
  30 #include &lt;math.h&gt;
  31 #include &lt;jlong.h&gt;
  32 
  33 #include &quot;sun_java2d_metal_MTLTextRenderer.h&quot;
  34 
  35 #include &quot;SurfaceData.h&quot;
  36 #include &quot;MTLContext.h&quot;
  37 #include &quot;MTLRenderQueue.h&quot;
  38 #include &quot;MTLTextRenderer.h&quot;
  39 #include &quot;MTLVertexCache.h&quot;
  40 #include &quot;MTLGlyphCache.h&quot;
  41 #include &quot;MTLBlitLoops.h&quot;
  42 
  43 /**
  44  * The following constants define the inner and outer bounds of the
  45  * accelerated glyph cache.
  46  */
  47 #define MTLTR_CACHE_WIDTH       512
  48 #define MTLTR_CACHE_HEIGHT      512
  49 #define MTLTR_CACHE_CELL_WIDTH  32
  50 #define MTLTR_CACHE_CELL_HEIGHT 32
  51 
  52 /**
  53  * The current &quot;glyph mode&quot; state.  This variable is used to track the
  54  * codepath used to render a particular glyph.  This variable is reset to
  55  * MODE_NOT_INITED at the beginning of every call to MTLTR_DrawGlyphList().
  56  * As each glyph is rendered, the glyphMode variable is updated to reflect
  57  * the current mode, so if the current mode is the same as the mode used
  58  * to render the previous glyph, we can avoid doing costly setup operations
  59  * each time.
  60  */
  61 typedef enum {
  62     MODE_NOT_INITED,
  63     MODE_USE_CACHE_GRAY,
  64     MODE_USE_CACHE_LCD,
  65     MODE_NO_CACHE_GRAY,
  66     MODE_NO_CACHE_LCD,
  67     MODE_NO_CACHE_COLOR
  68 } GlyphMode;
  69 static GlyphMode glyphMode = MODE_NOT_INITED;
  70 
  71 /**
  72  * There are two separate glyph caches: for AA and for LCD.
  73  * Once one of them is initialized as either GRAY or LCD, it
  74  * stays in that mode for the duration of the application.  It should
  75  * be safe to use this one glyph cache for all screens in a multimon
  76  * environment, since the glyph cache texture is shared between all contexts,
  77  * and (in theory) OpenGL drivers should be smart enough to manage that
  78  * texture across all screens.
  79  */
  80 
  81 static MTLGlyphCacheInfo *glyphCacheLCD = NULL;
  82 static MTLGlyphCacheInfo *glyphCacheAA = NULL;
  83 
  84 /**
  85  * The handle to the LCD text fragment program object.
  86  */
  87 static GLhandleARB lcdTextProgram = 0;
  88 
  89 /**
  90  * This value tracks the previous LCD contrast setting, so if the contrast
  91  * value hasn&#39;t changed since the last time the gamma uniforms were
  92  * updated (not very common), then we can skip updating the unforms.
  93  */
  94 static jint lastLCDContrast = -1;
  95 
  96 /**
  97  * This value tracks the previous LCD rgbOrder setting, so if the rgbOrder
  98  * value has changed since the last time, it indicates that we need to
  99  * invalidate the cache, which may already store glyph images in the reverse
 100  * order.  Note that in most real world applications this value will not
 101  * change over the course of the application, but tests like Font2DTest
 102  * allow for changing the ordering at runtime, so we need to handle that case.
 103  */
 104 static jboolean lastRGBOrder = JNI_TRUE;
 105 
 106 /**
 107  * This constant defines the size of the tile to use in the
 108  * MTLTR_DrawLCDGlyphNoCache() method.  See below for more on why we
 109  * restrict this value to a particular size.
 110  */
 111 #define MTLTR_NOCACHE_TILE_SIZE 32
 112 
 113 /**
 114  * These constants define the size of the &quot;cached destination&quot; texture.
 115  * This texture is only used when rendering LCD-optimized text, as that
 116  * codepath needs direct access to the destination.  There is no way to
 117  * access the framebuffer directly from an OpenGL shader, so we need to first
 118  * copy the destination region corresponding to a particular glyph into
 119  * this cached texture, and then that texture will be accessed inside the
 120  * shader.  Copying the destination into this cached texture can be a very
 121  * expensive operation (accounting for about half the rendering time for
 122  * LCD text), so to mitigate this cost we try to bulk read a horizontal
 123  * region of the destination at a time.  (These values are empirically
 124  * derived for the common case where text runs horizontally.)
 125  *
 126  * Note: It is assumed in various calculations below that:
 127  *     (MTLTR_CACHED_DEST_WIDTH  &gt;= MTLTR_CACHE_CELL_WIDTH)  &amp;&amp;
 128  *     (MTLTR_CACHED_DEST_WIDTH  &gt;= MTLTR_NOCACHE_TILE_SIZE) &amp;&amp;
 129  *     (MTLTR_CACHED_DEST_HEIGHT &gt;= MTLTR_CACHE_CELL_HEIGHT) &amp;&amp;
 130  *     (MTLTR_CACHED_DEST_HEIGHT &gt;= MTLTR_NOCACHE_TILE_SIZE)
 131  */
 132 #define MTLTR_CACHED_DEST_WIDTH  512
 133 #define MTLTR_CACHED_DEST_HEIGHT (MTLTR_CACHE_CELL_HEIGHT * 2)
 134 
 135 /**
 136  * The handle to the &quot;cached destination&quot; texture object.
 137  */
 138 static GLuint cachedDestTextureID = 0;
 139 
 140 /**
 141  * The current bounds of the &quot;cached destination&quot; texture, in destination
 142  * coordinate space.  The width/height of these bounds will not exceed the
 143  * MTLTR_CACHED_DEST_WIDTH/HEIGHT values defined above.  These bounds are
 144  * only considered valid when the isCachedDestValid flag is JNI_TRUE.
 145  */
 146 static SurfaceDataBounds cachedDestBounds;
 147 
 148 /**
 149  * This flag indicates whether the &quot;cached destination&quot; texture contains
 150  * valid data.  This flag is reset to JNI_FALSE at the beginning of every
 151  * call to MTLTR_DrawGlyphList().  Once we copy valid destination data
 152  * into the cached texture, this flag is set to JNI_TRUE.  This way, we can
 153  * limit the number of times we need to copy destination data, which is a
 154  * very costly operation.
 155  */
 156 static jboolean isCachedDestValid = JNI_FALSE;
 157 
 158 /**
 159  * The bounds of the previously rendered LCD glyph, in destination
 160  * coordinate space.  We use these bounds to determine whether the glyph
 161  * currently being rendered overlaps the previously rendered glyph (i.e.
 162  * its bounding box intersects that of the previously rendered glyph).  If
 163  * so, we need to re-read the destination area associated with that previous
 164  * glyph so that we can correctly blend with the actual destination data.
 165  */
 166 static SurfaceDataBounds previousGlyphBounds;
 167 
 168 static struct TxtVertex txtVertices[6];
 169 static jint vertexCacheIndex = 0;
 170 static id&lt;MTLRenderCommandEncoder&gt; lcdCacheEncoder = nil;
 171 
 172 #define LCD_ADD_VERTEX(TX, TY, DX, DY, DZ) \
 173     do { \
 174         struct TxtVertex *v = &amp;txtVertices[vertexCacheIndex++]; \
 175         v-&gt;txtpos[0] = TX; \
 176         v-&gt;txtpos[1] = TY; \
 177         v-&gt;position[0]= DX; \
 178         v-&gt;position[1] = DY; \
 179     } while (0)
 180 
 181 #define LCD_ADD_TRIANGLES(TX1, TY1, TX2, TY2, DX1, DY1, DX2, DY2) \
 182     do { \
 183         LCD_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \
 184         LCD_ADD_VERTEX(TX2, TY1, DX2, DY1, 0); \
 185         LCD_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \
 186         LCD_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \
 187         LCD_ADD_VERTEX(TX1, TY2, DX1, DY2, 0); \
 188         LCD_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \
 189     } while (0)
 190 
 191 /**
 192  * Initializes the one glyph cache (texture and data structure).
 193  * If lcdCache is JNI_TRUE, the texture will contain RGB data,
 194  * otherwise we will simply store the grayscale/monochrome glyph images
 195  * as intensity values (which work well with the GL_MODULATE function).
 196  */
 197 static jboolean
 198 MTLTR_InitGlyphCache(MTLContext *mtlc, jboolean lcdCache)
 199 {
 200     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_InitGlyphCache&quot;);
 201     // TODO : Need to fix RGB order in case of LCD
 202     MTLPixelFormat pixelFormat = MTLPixelFormatBGRA8Unorm;
 203 
 204     MTLGlyphCacheInfo *gcinfo;
 205     // init glyph cache data structure
 206     gcinfo = MTLGlyphCache_Init(MTLTR_CACHE_WIDTH,
 207                                 MTLTR_CACHE_HEIGHT,
 208                                 MTLTR_CACHE_CELL_WIDTH,
 209                                 MTLTR_CACHE_CELL_HEIGHT,
 210                                 MTLVertexCache_FlushGlyphVertexCache);
 211 
 212     if (gcinfo == NULL) {
 213         J2dRlsTraceLn(J2D_TRACE_ERROR,
 214                       &quot;MTLTR_InitGlyphCache: could not init MTL glyph cache&quot;);
 215         return JNI_FALSE;
 216     }
 217 
 218     MTLTextureDescriptor *textureDescriptor =
 219         [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:pixelFormat
 220                                                             width:MTLTR_CACHE_WIDTH
 221                                                             height:MTLTR_CACHE_HEIGHT
 222                                                             mipmapped:NO];
 223 
 224     gcinfo-&gt;texture = [mtlc.device newTextureWithDescriptor:textureDescriptor];
<a name="1" id="anc1"></a><span class="line-removed"> 225     [textureDescriptor release];</span>
 226 
 227     if (lcdCache) {
 228         glyphCacheLCD = gcinfo;
 229     } else {
 230         glyphCacheAA = gcinfo;
 231     }
 232 
 233     return JNI_TRUE;
 234 }
 235 
 236 id&lt;MTLTexture&gt;
 237 MTLTR_GetGlyphCacheTexture()
 238 {
 239     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_GetGlyphCacheTexture&quot;);
 240     if (glyphCacheAA != NULL) {
 241         return glyphCacheAA-&gt;texture;
 242     }
 243     return NULL;
 244 }
 245 
 246 /**
 247  * Adds the given glyph to the glyph cache (texture and data structure)
 248  * associated with the given MTLContext.
 249  */
 250 static void
 251 MTLTR_AddToGlyphCache(GlyphInfo *glyph, MTLContext *mtlc,
 252                       jboolean lcdCache)
 253 {
 254     MTLCacheCellInfo *ccinfo;
 255     MTLGlyphCacheInfo *gcinfo;
 256     jint w = glyph-&gt;width;
 257     jint h = glyph-&gt;height;
 258 
 259     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_AddToGlyphCache&quot;);
 260     if (!lcdCache) {
 261         gcinfo = glyphCacheAA;
 262     } else {
 263         gcinfo = glyphCacheLCD;
 264     }
 265 
 266     if ((gcinfo == NULL) || (glyph-&gt;image == NULL)) {
 267         return;
 268     }
 269 
 270     bool isCacheFull = MTLGlyphCache_IsCacheFull(gcinfo, glyph);
 271     if (isCacheFull) {
 272         MTLGlyphCache_Free(gcinfo);
 273         if (!lcdCache) {
 274             MTLTR_InitGlyphCache(mtlc, JNI_FALSE);
 275             gcinfo = glyphCacheAA;
 276         } else {
 277             MTLTR_InitGlyphCache(mtlc, JNI_TRUE);
 278             gcinfo = glyphCacheLCD;
 279         }
 280     }
 281     MTLGlyphCache_AddGlyph(gcinfo, glyph);
 282     ccinfo = (MTLCacheCellInfo *) glyph-&gt;cellInfo;
 283 
 284     if (ccinfo != NULL) {
 285         // store glyph image in texture cell
 286         MTLRegion region = {
 287                 {ccinfo-&gt;x,  ccinfo-&gt;y,   0},
 288                 {w, h, 1}
 289         };
 290         if (!lcdCache) {
 291             // Opengl uses GL_INTENSITY as internal pixel format to set number of
 292             // color components in the texture for grayscale texture.
 293             // It is mentioned that for GL_INTENSITY format,
 294             // the GL assembles it into an RGBA element by replicating the
 295             // intensity value three times for red, green, blue, and alpha.
 296             // To let metal behave the same for grayscale text,
 297             // we need to make sure we create BGRA component by replicating
 298             // graycale pixel value as in R=G=B=A=grayscale pixel value
 299 
 300             unsigned int imageBytes = w * h * 4;
 301             unsigned char imageData[imageBytes];
 302             memset(&amp;imageData, 0, sizeof(imageData));
 303 
 304             unsigned int dstindex = 0;
 305             for (int i = 0; i &lt; (w * h); i++) {
 306                 imageData[dstindex++] = glyph-&gt;image[i];
 307                 imageData[dstindex++] = glyph-&gt;image[i];
 308                 imageData[dstindex++] = glyph-&gt;image[i];
 309                 imageData[dstindex++] = glyph-&gt;image[i];
 310             }
 311             NSUInteger bytesPerRow = 4 * w;
 312             [gcinfo-&gt;texture replaceRegion:region
 313                              mipmapLevel:0
 314                              withBytes:imageData
 315                              bytesPerRow:bytesPerRow];
 316         } else {
 317             unsigned int imageBytes = w * h * 4;
 318             unsigned char imageData[imageBytes];
 319             memset(&amp;imageData, 0, sizeof(imageData));
 320 
 321             for (int i = 0; i &lt; h; i++) {
 322                 for (int j = 0; j &lt; w; j++) {
 323                     imageData[(i * w * 4) + j * 4] = glyph-&gt;image[(i * w * 3) + j * 3];
 324                     imageData[(i * w * 4) + j * 4 + 1] = glyph-&gt;image[(i * w * 3) + j * 3 + 1];
 325                     imageData[(i * w * 4) + j * 4 + 2] = glyph-&gt;image[(i * w * 3) + j * 3 + 2];
 326                     imageData[(i * w * 4) + j * 4 + 3] = 0xFF;
 327                 }
 328             }
 329 
 330             NSUInteger bytesPerRow = 4 * w;
 331             [gcinfo-&gt;texture replaceRegion:region
 332                              mipmapLevel:0
 333                              withBytes:imageData
 334                              bytesPerRow:bytesPerRow];
 335         }
 336     }
 337 }
 338 
<a name="2" id="anc2"></a><span class="line-removed"> 339 static MTLRenderPipelineDescriptor * templateRenderPipelineDesc = nil;</span>
 340 static MTLRenderPipelineDescriptor * templateLCDPipelineDesc = nil;
 341 
 342 /**
 343  * Enables the LCD text shader and updates any related state, such as the
 344  * gamma lookup table textures.
 345  */
 346 static jboolean
 347 MTLTR_EnableLCDGlyphModeState(id&lt;MTLRenderCommandEncoder&gt; encoder,
 348                               MTLContext *mtlc, 
 349                               MTLSDOps *dstOps,
 350                               jint contrast)
 351 {
 352     // create the LCD text shader, if necessary
 353     if (templateLCDPipelineDesc == nil) {
 354 
 355         MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];
 356         vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;
 357         vertDesc.attributes[VertexAttributePosition].offset = 0;
 358         vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;
 359         vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);
 360         vertDesc.layouts[MeshVertexBuffer].stepRate = 1;
 361         vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 362 
<a name="3" id="anc3"></a><span class="line-modified"> 363         templateLCDPipelineDesc = [[MTLRenderPipelineDescriptor new] autorelease];</span>
 364         templateLCDPipelineDesc.sampleCount = 1;
 365         templateLCDPipelineDesc.vertexDescriptor = vertDesc;
 366         templateLCDPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;
 367         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;
 368         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);
 369         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;
 370         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);
 371         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;
 372         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 373         templateLCDPipelineDesc.label = @&quot;template_lcd&quot;;
 374     }
 375 
 376     id&lt;MTLRenderPipelineState&gt; pipelineState =
 377                 [mtlc.pipelineStateStorage
 378                     getPipelineState:templateLCDPipelineDesc
 379                     vertexShaderId:@&quot;vert_txt&quot;
 380                     fragmentShaderId:@&quot;lcd_color&quot;
 381                    ];
 382 
 383     [encoder setRenderPipelineState:pipelineState];
 384 
 385     // update the current color settings
 386     double gamma = ((double)contrast) / 100.0;
 387     double invgamma = 1.0/gamma;
 388     jfloat radj, gadj, badj;
 389     jfloat clr[4];
 390     jint col = [mtlc.paint getColor];
 391 
 392     J2dTraceLn2(J2D_TRACE_INFO, &quot;primary color %x, contrast %d&quot;, col, contrast);
 393     J2dTraceLn2(J2D_TRACE_INFO, &quot;gamma %f, invgamma %f&quot;, gamma, invgamma);
 394 
 395     clr[0] = ((col &gt;&gt; 16) &amp; 0xFF)/255.0f;
 396     clr[1] = ((col &gt;&gt; 8) &amp; 0xFF)/255.0f;
 397     clr[2] = ((col) &amp; 0xFF)/255.0f;
 398 
 399     // gamma adjust the primary color
 400     radj = (float)pow(clr[0], gamma);
 401     gadj = (float)pow(clr[1], gamma);
 402     badj = (float)pow(clr[2], gamma);
 403 
 404     struct LCDFrameUniforms uf = {
 405             {radj, gadj, badj},
 406             {gamma, gamma, gamma},
 407             {invgamma, invgamma, invgamma}};
 408     [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
 409 
 410     return JNI_TRUE;
 411 }
 412 
 413 static jboolean
 414 MTLTR_SetLCDCachePipelineState(MTLContext *mtlc)
 415 {
 416     if (templateLCDPipelineDesc == nil) {
 417 
 418         MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];
 419         vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;
 420         vertDesc.attributes[VertexAttributePosition].offset = 0;
 421         vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;
 422         vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);
 423         vertDesc.layouts[MeshVertexBuffer].stepRate = 1;
 424         vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 425 
<a name="4" id="anc4"></a><span class="line-modified"> 426         templateLCDPipelineDesc = [[MTLRenderPipelineDescriptor new] autorelease];</span>
 427         templateLCDPipelineDesc.sampleCount = 1;
 428         templateLCDPipelineDesc.vertexDescriptor = vertDesc;
 429         templateLCDPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;
 430         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;
 431         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);
 432         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;
 433         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);
 434         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;
 435         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 436         templateLCDPipelineDesc.label = @&quot;template_lcd&quot;;
 437     }
 438 
 439     id&lt;MTLRenderPipelineState&gt; pipelineState =
 440                 [mtlc.pipelineStateStorage
 441                     getPipelineState:templateLCDPipelineDesc
 442                     vertexShaderId:@&quot;vert_txt&quot;
 443                     fragmentShaderId:@&quot;lcd_color&quot;
 444                    ];
 445 
 446     [lcdCacheEncoder setRenderPipelineState:pipelineState];
 447     return JNI_TRUE;
 448 }
 449 
 450 static jboolean
 451 MTLTR_SetLCDContrast(MTLContext *mtlc,
 452                      jint contrast)
 453 {
 454     // update the current color settings
 455     double gamma = ((double)contrast) / 100.0;
 456     double invgamma = 1.0/gamma;
 457     jfloat radj, gadj, badj;
 458     jfloat clr[4];
 459     jint col = [mtlc.paint getColor];
 460 
 461     J2dTraceLn2(J2D_TRACE_INFO, &quot;primary color %x, contrast %d&quot;, col, contrast);
 462     J2dTraceLn2(J2D_TRACE_INFO, &quot;gamma %f, invgamma %f&quot;, gamma, invgamma);
 463 
 464     clr[0] = ((col &gt;&gt; 16) &amp; 0xFF)/255.0f;
 465     clr[1] = ((col &gt;&gt; 8) &amp; 0xFF)/255.0f;
 466     clr[2] = ((col) &amp; 0xFF)/255.0f;
 467 
 468     // gamma adjust the primary color
 469     radj = (float)pow(clr[0], gamma);
 470     gadj = (float)pow(clr[1], gamma);
 471     badj = (float)pow(clr[2], gamma);
 472 
 473     struct LCDFrameUniforms uf = {
 474             {radj, gadj, badj},
 475             {gamma, gamma, gamma},
 476             {invgamma, invgamma, invgamma}};
 477     [lcdCacheEncoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
 478     return JNI_TRUE;
 479 }
 480 
 481 void
 482 MTLTR_EnableGlyphVertexCache(MTLContext *mtlc, BMTLSDOps *dstOps)
 483 {
 484 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_EnableGlyphVertexCache&quot;);
 485 
 486     if (!MTLVertexCache_InitVertexCache()) {
 487         return;
 488     }
 489 
 490     if (glyphCacheAA == NULL) {
 491         if (!MTLTR_InitGlyphCache(mtlc, JNI_FALSE)) {
 492             return;
 493         }
 494     }
 495     MTLVertexCache_CreateSamplingEncoder(mtlc, dstOps);
 496 }
 497 
 498 void
 499 MTLTR_DisableGlyphVertexCache(MTLContext *mtlc)
 500 {
 501     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DisableGlyphVertexCache&quot;);
 502     MTLVertexCache_FlushGlyphVertexCache();
 503     MTLVertexCache_RestoreColorState(mtlc);
 504     MTLVertexCache_FreeVertexCache();
 505 }
 506 
 507 /**
 508  * Disables any pending state associated with the current &quot;glyph mode&quot;.
 509  */
 510 void
 511 MTLTR_DisableGlyphModeState()
 512 {
 513     // TODO : This is similar to OpenGL implementation
 514     // When LCD implementation is done weshould make
 515     // more changes.
 516     J2dTraceLn1(J2D_TRACE_VERBOSE,
 517                 &quot;MTLTR_DisableGlyphModeState: mode=%d&quot;, glyphMode);
 518     switch (glyphMode) {
 519     case MODE_NO_CACHE_LCD:
 520         // TODO : Along with LCD implementation
 521         // changes needs to be made
 522     case MODE_USE_CACHE_LCD:
 523         // TODO : Along with LCD implementation
 524         // changes needs to be made
 525         break;
 526     case MODE_NO_CACHE_GRAY:
 527     case MODE_USE_CACHE_GRAY:
 528     case MODE_NOT_INITED:
 529     default:
 530         break;
 531     }
 532 }
 533 
 534 static jboolean
 535 MTLTR_DrawGrayscaleGlyphViaCache(MTLContext *mtlc,
 536                                  GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)
 537 {
 538     MTLCacheCellInfo *cell;
 539     jfloat x1, y1, x2, y2;
 540 
 541     if (glyphMode != MODE_USE_CACHE_GRAY) {
 542         if (glyphMode == MODE_NO_CACHE_GRAY) {
 543             MTLVertexCache_DisableMaskCache(mtlc);
 544         } else if (glyphMode == MODE_USE_CACHE_LCD) {
 545             [mtlc.encoderManager endEncoder];
 546             lcdCacheEncoder = nil;
 547         }
 548         MTLTR_EnableGlyphVertexCache(mtlc, dstOps);
 549         glyphMode = MODE_USE_CACHE_GRAY;
 550     }
 551 
 552     if (ginfo-&gt;cellInfo == NULL) {
 553         // attempt to add glyph to accelerated glyph cache
 554         MTLTR_AddToGlyphCache(ginfo, mtlc, JNI_FALSE);
 555 
 556         if (ginfo-&gt;cellInfo == NULL) {
 557             // we&#39;ll just no-op in the rare case that the cell is NULL
 558             return JNI_TRUE;
 559         }
 560     }
 561 
 562     cell = (MTLCacheCellInfo *) (ginfo-&gt;cellInfo);
 563     cell-&gt;timesRendered++;
 564 
 565     x1 = (jfloat)x;
 566     y1 = (jfloat)y;
 567     x2 = x1 + ginfo-&gt;width;
 568     y2 = y1 + ginfo-&gt;height;
 569 
 570     MTLVertexCache_AddGlyphQuad(mtlc,
 571                                 cell-&gt;tx1, cell-&gt;ty1,
 572                                 cell-&gt;tx2, cell-&gt;ty2,
 573                                 x1, y1, x2, y2);
 574 
 575     return JNI_TRUE;
 576 }
 577 
 578 /**
 579  * Evaluates to true if the rectangle defined by gx1/gy1/gx2/gy2 is
 580  * inside outerBounds.
 581  */
 582 #define INSIDE(gx1, gy1, gx2, gy2, outerBounds) \
 583     (((gx1) &gt;= outerBounds.x1) &amp;&amp; ((gy1) &gt;= outerBounds.y1) &amp;&amp; \
 584      ((gx2) &lt;= outerBounds.x2) &amp;&amp; ((gy2) &lt;= outerBounds.y2))
 585 
 586 /**
 587  * Evaluates to true if the rectangle defined by gx1/gy1/gx2/gy2 intersects
 588  * the rectangle defined by bounds.
 589  */
 590 #define INTERSECTS(gx1, gy1, gx2, gy2, bounds) \
 591     ((bounds.x2 &gt; (gx1)) &amp;&amp; (bounds.y2 &gt; (gy1)) &amp;&amp; \
 592      (bounds.x1 &lt; (gx2)) &amp;&amp; (bounds.y1 &lt; (gy2)))
 593 
 594 /**
 595  * This method checks to see if the given LCD glyph bounds fall within the
 596  * cached destination texture bounds.  If so, this method can return
 597  * immediately.  If not, this method will copy a chunk of framebuffer data
 598  * into the cached destination texture and then update the current cached
 599  * destination bounds before returning.
 600  */
 601 static void
 602 MTLTR_UpdateCachedDestination(MTLSDOps *dstOps, GlyphInfo *ginfo,
 603                               jint gx1, jint gy1, jint gx2, jint gy2,
 604                               jint glyphIndex, jint totalGlyphs)
 605 {
 606     //TODO
 607 }
 608 
 609 static jboolean
 610 MTLTR_DrawLCDGlyphViaCache(MTLContext *mtlc, BMTLSDOps *dstOps,
 611                            GlyphInfo *ginfo, jint x, jint y,
 612                            jint rowBytesOffset,
 613                            jboolean rgbOrder, jint contrast,
 614                            id&lt;MTLTexture&gt; dstTexture)
 615 {
 616     CacheCellInfo *cell;
 617     jfloat tx1, ty1, tx2, ty2;
 618     jint w = ginfo-&gt;width;
 619     jint h = ginfo-&gt;height;
 620 
 621     if (glyphMode != MODE_USE_CACHE_LCD) {
 622         if (glyphMode == MODE_NO_CACHE_GRAY) {
 623             MTLVertexCache_DisableMaskCache(mtlc);
 624         } else if (glyphMode == MODE_USE_CACHE_GRAY) {
 625             MTLTR_DisableGlyphVertexCache(mtlc);
 626         }
 627 
 628         if (glyphCacheLCD == NULL) {
 629             if (!MTLTR_InitGlyphCache(mtlc, JNI_TRUE)) {
 630                 return JNI_FALSE;
 631             }
 632         }
 633         if (lcdCacheEncoder == nil) {
 634             lcdCacheEncoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];
 635             MTLTR_SetLCDCachePipelineState(mtlc);
 636         }
 637         if (rgbOrder != lastRGBOrder) {
 638             // need to invalidate the cache in this case; see comments
 639             // for lastRGBOrder above
 640             MTLGlyphCache_Invalidate(glyphCacheLCD);
 641             lastRGBOrder = rgbOrder;
 642         }
 643 
 644         glyphMode = MODE_USE_CACHE_LCD;
 645     }
 646 
 647     if (ginfo-&gt;cellInfo == NULL) {
 648         // attempt to add glyph to accelerated glyph cache
 649         // TODO : Handle RGB order
 650         MTLTR_AddToGlyphCache(ginfo, mtlc, JNI_TRUE);
 651 
 652         if (ginfo-&gt;cellInfo == NULL) {
 653             // we&#39;ll just no-op in the rare case that the cell is NULL
 654             return JNI_TRUE;
 655         }
 656     }
 657     cell = (CacheCellInfo *) (ginfo-&gt;cellInfo);
 658     cell-&gt;timesRendered++;
 659 
 660     MTLTR_SetLCDContrast(mtlc, contrast);
 661     tx1 = cell-&gt;tx1;
 662     ty1 = cell-&gt;ty1;
 663     tx2 = cell-&gt;tx2;
 664     ty2 = cell-&gt;ty2;
 665 
 666     J2dTraceLn4(J2D_TRACE_INFO, &quot;tx1 %f, ty1 %f, tx2 %f, ty2 %f&quot;, tx1, ty1, tx2, ty2);
 667     J2dTraceLn2(J2D_TRACE_INFO, &quot;textureWidth %d textureHeight %d&quot;, dstOps-&gt;textureWidth, dstOps-&gt;textureHeight);
 668 
 669     LCD_ADD_TRIANGLES(tx1, ty1, tx2, ty2, x, y, x+w, y+h);
 670 
 671     [lcdCacheEncoder setVertexBytes:txtVertices length:sizeof(txtVertices) atIndex:MeshVertexBuffer];
 672     [lcdCacheEncoder setFragmentTexture:glyphCacheLCD-&gt;texture atIndex:0];
 673     [lcdCacheEncoder setFragmentTexture:dstOps-&gt;pTexture atIndex:1];
 674 
 675     [lcdCacheEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
 676 
 677     vertexCacheIndex = 0;
 678 
 679     return JNI_TRUE;
 680 }
 681 
 682 static jboolean
 683 MTLTR_DrawGrayscaleGlyphNoCache(MTLContext *mtlc,
 684                                 GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)
 685 {
 686     jint tw, th;
 687     jint sx, sy, sw, sh;
 688     jint x0;
 689     jint w = ginfo-&gt;width;
 690     jint h = ginfo-&gt;height;
 691 
 692     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGrayscaleGlyphNoCache&quot;);
 693     if (glyphMode != MODE_NO_CACHE_GRAY) {
 694         if (glyphMode == MODE_USE_CACHE_GRAY) {
 695             MTLTR_DisableGlyphVertexCache(mtlc);
 696         } else if (glyphMode == MODE_USE_CACHE_LCD) {
 697             [mtlc.encoderManager endEncoder];
 698             lcdCacheEncoder = nil;
 699         }
 700         MTLVertexCache_EnableMaskCache(mtlc, dstOps);
 701         glyphMode = MODE_NO_CACHE_GRAY;
 702     }
 703 
 704     x0 = x;
 705     tw = MTLVC_MASK_CACHE_TILE_WIDTH;
 706     th = MTLVC_MASK_CACHE_TILE_HEIGHT;
 707 
 708     for (sy = 0; sy &lt; h; sy += th, y += th) {
 709         x = x0;
 710         sh = ((sy + th) &gt; h) ? (h - sy) : th;
 711 
 712         for (sx = 0; sx &lt; w; sx += tw, x += tw) {
 713             sw = ((sx + tw) &gt; w) ? (w - sx) : tw;
 714 
 715             J2dTraceLn7(J2D_TRACE_INFO, &quot;sx = %d sy = %d x = %d y = %d sw = %d sh = %d w = %d&quot;, sx, sy, x, y, sw, sh, w);
 716             MTLVertexCache_AddMaskQuad(mtlc,
 717                                        sx, sy, x, y, sw, sh,
 718                                        w, ginfo-&gt;image,
 719                                        dstOps,
 720                                        ginfo-&gt;width);
 721         }
 722     }
 723 
 724     return JNI_TRUE;
 725 }
 726 
 727 
 728 static jboolean
 729 MTLTR_DrawLCDGlyphNoCache(MTLContext *mtlc, BMTLSDOps *dstOps,
 730                           GlyphInfo *ginfo, jint x, jint y,
 731                           jint rowBytesOffset,
 732                           jboolean rgbOrder, jint contrast,
 733                           id&lt;MTLTexture&gt; dstTexture)
 734 {
 735     jfloat tx1, ty1, tx2, ty2;
 736     jfloat dtx1=0, dty1=0, dtx2=0, dty2=0;
 737     jint tw, th;
 738     jint sx=0, sy=0, sw=0, sh=0, dxadj=0, dyadj=0;
 739     jint x0;
 740     jint w = ginfo-&gt;width;
 741     jint h = ginfo-&gt;height;
 742     id&lt;MTLTexture&gt; blitTexture = nil;
 743 
 744     J2dTraceLn2(J2D_TRACE_INFO, &quot;MTLTR_DrawLCDGlyphNoCache x %d, y%d&quot;, x, y);
 745     J2dTraceLn3(J2D_TRACE_INFO, &quot;MTLTR_DrawLCDGlyphNoCache rowBytesOffset=%d, rgbOrder=%d, contrast=%d&quot;, rowBytesOffset, rgbOrder, contrast);
 746 
 747 
 748     id&lt;MTLRenderCommandEncoder&gt; encoder = nil;
 749 
 750     MTLTextureDescriptor *textureDescriptor =
 751         [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatBGRA8Unorm
 752                                                             width:w
 753                                                             height:h
 754                                                             mipmapped:NO];
 755 
 756     blitTexture = [mtlc.device newTextureWithDescriptor:textureDescriptor];
 757     [textureDescriptor release];
 758 
 759     if (glyphMode != MODE_NO_CACHE_LCD) {
 760         if (glyphMode == MODE_NO_CACHE_GRAY) {
 761             MTLVertexCache_DisableMaskCache(mtlc);
 762         } else if (glyphMode == MODE_USE_CACHE_GRAY) {
 763             MTLTR_DisableGlyphVertexCache(mtlc);
 764         } else if (glyphMode == MODE_USE_CACHE_LCD) {
 765             [mtlc.encoderManager endEncoder];
 766             lcdCacheEncoder = nil;
 767         }
 768 
 769         if (blitTexture == nil) {
 770             J2dTraceLn(J2D_TRACE_ERROR, &quot;can&#39;t obtain temporary texture object from pool&quot;);
 771             return JNI_FALSE;
 772         }
 773 
 774 
 775         glyphMode = MODE_NO_CACHE_LCD;
 776     }
 777     encoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];
 778     if (!MTLTR_EnableLCDGlyphModeState(encoder, mtlc, dstOps,contrast))
 779     {
 780         return JNI_FALSE;
 781     }
 782 
 783     x0 = x;
 784     tx1 = 0.0f;
 785     ty1 = 0.0f;
 786     dtx1 = 0.0f;
 787     dty2 = 0.0f;
 788     tw = MTLTR_NOCACHE_TILE_SIZE;
 789     th = MTLTR_NOCACHE_TILE_SIZE;
 790 
 791     unsigned int imageBytes = w * h *4;
 792     unsigned char imageData[imageBytes];
 793     memset(&amp;imageData, 0, sizeof(imageData));
 794 
 795     for (int i = 0; i &lt; h; i++) {
 796         for (int j = 0; j &lt; w; j++) {
 797             imageData[(i * w * 4) + j * 4] = ginfo-&gt;image[(i * w * 3) + j * 3];
 798             imageData[(i * w * 4) + j * 4 + 1] = ginfo-&gt;image[(i * w * 3) + j * 3 + 1];
 799             imageData[(i * w * 4) + j * 4 + 2] = ginfo-&gt;image[(i * w * 3) + j * 3 + 2];
 800             imageData[(i * w * 4) + j * 4 + 3] = 0xFF;
 801         }
 802     }
 803 
 804     // copy LCD mask into glyph texture tile
 805     MTLRegion region = MTLRegionMake2D(0, 0, w, h);
 806 
 807     NSUInteger bytesPerRow = 4 * ginfo-&gt;width;
 808     [blitTexture replaceRegion:region
 809                  mipmapLevel:0
 810                  withBytes:imageData
 811                  bytesPerRow:bytesPerRow];
 812 
 813     J2dTraceLn7(J2D_TRACE_INFO, &quot;sx = %d sy = %d x = %d y = %d sw = %d sh = %d w = %d&quot;, sx, sy, x, y, sw, sh, w);
 814 
 815 
 816     // update the lower-right glyph texture coordinates
 817     tx2 = 1.0f;
 818     ty2 = 1.0f;
 819 
 820     J2dTraceLn5(J2D_TRACE_INFO, &quot;xOffset %d yOffset %d, dxadj %d, dyadj %d dstOps-&gt;height %d&quot;, dstOps-&gt;xOffset, dstOps-&gt;yOffset, dxadj, dyadj, dstOps-&gt;height);
 821 
 822     dtx1 = ((jfloat)dxadj) / dstOps-&gt;textureWidth;
 823     dtx2 = ((float)dxadj + sw) / dstOps-&gt;textureWidth;
 824   
 825     dty1 = ((jfloat)dyadj + sh) / dstOps-&gt;textureHeight;
 826     dty2 = ((jfloat)dyadj) / dstOps-&gt;textureHeight;
 827 
 828     J2dTraceLn4(J2D_TRACE_INFO, &quot;tx1 %f, ty1 %f, tx2 %f, ty2 %f&quot;, tx1, ty1, tx2, ty2);
 829     J2dTraceLn2(J2D_TRACE_INFO, &quot;textureWidth %d textureHeight %d&quot;, dstOps-&gt;textureWidth, dstOps-&gt;textureHeight);
 830     J2dTraceLn4(J2D_TRACE_INFO, &quot;dtx1 %f, dty1 %f, dtx2 %f, dty2 %f&quot;, dtx1, dty1, dtx2, dty2);
 831 
 832     LCD_ADD_TRIANGLES(tx1, ty1, tx2, ty2, x, y, x+w, y+h);
 833 
 834     [encoder setVertexBytes:txtVertices length:sizeof(txtVertices) atIndex:MeshVertexBuffer];
 835     [encoder setFragmentTexture:blitTexture atIndex:0];
 836     [encoder setFragmentTexture:dstOps-&gt;pTexture atIndex:1];
 837 
 838     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
 839 
 840     vertexCacheIndex = 0;
 841     [mtlc.encoderManager endEncoder];
 842     [blitTexture release];
 843 
 844     MTLCommandBufferWrapper* cbwrapper = [mtlc pullCommandBufferWrapper];
 845 
 846     id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
 847     [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
 848         [cbwrapper release];
 849     }];
 850 
 851     [commandbuf commit];
 852     [commandbuf waitUntilCompleted];
 853 
 854     return JNI_TRUE;
 855 }
 856 
 857 // see DrawGlyphList.c for more on this macro...
 858 #define FLOOR_ASSIGN(l, r) \
 859     if ((r)&lt;0) (l) = ((int)floor(r)); else (l) = ((int)(r))
 860 
 861 void
 862 MTLTR_DrawGlyphList(JNIEnv *env, MTLContext *mtlc, BMTLSDOps *dstOps,
 863                     jint totalGlyphs, jboolean usePositions,
 864                     jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,
 865                     jfloat glyphListOrigX, jfloat glyphListOrigY,
 866                     unsigned char *images, unsigned char *positions)
 867 {
 868     int glyphCounter;
 869 
 870     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList&quot;);
 871 
 872     RETURN_IF_NULL(mtlc);
 873     RETURN_IF_NULL(dstOps);
 874     RETURN_IF_NULL(images);
 875     if (usePositions) {
 876         RETURN_IF_NULL(positions);
 877     }
 878 
 879     glyphMode = MODE_NOT_INITED;
 880     isCachedDestValid = JNI_FALSE;
 881     J2dTraceLn1(J2D_TRACE_INFO, &quot;totalGlyphs = %d&quot;, totalGlyphs);
 882 
 883     for (glyphCounter = 0; glyphCounter &lt; totalGlyphs; glyphCounter++) {
 884         J2dTraceLn(J2D_TRACE_INFO, &quot;Entered for loop for glyph list&quot;);
 885         jint x, y;
 886         jfloat glyphx, glyphy;
 887         jboolean grayscale, ok;
 888         GlyphInfo *ginfo = (GlyphInfo *)jlong_to_ptr(NEXT_LONG(images));
 889 
 890         if (ginfo == NULL) {
 891             // this shouldn&#39;t happen, but if it does we&#39;ll just break out...
 892             J2dRlsTraceLn(J2D_TRACE_ERROR,
 893                           &quot;MTLTR_DrawGlyphList: glyph info is null&quot;);
 894             break;
 895         }
 896 
 897         grayscale = (ginfo-&gt;rowBytes == ginfo-&gt;width);
 898 
 899         if (usePositions) {
 900             jfloat posx = NEXT_FLOAT(positions);
 901             jfloat posy = NEXT_FLOAT(positions);
 902             glyphx = glyphListOrigX + posx + ginfo-&gt;topLeftX;
 903             glyphy = glyphListOrigY + posy + ginfo-&gt;topLeftY;
 904             FLOOR_ASSIGN(x, glyphx);
 905             FLOOR_ASSIGN(y, glyphy);
 906         } else {
 907             glyphx = glyphListOrigX + ginfo-&gt;topLeftX;
 908             glyphy = glyphListOrigY + ginfo-&gt;topLeftY;
 909             FLOOR_ASSIGN(x, glyphx);
 910             FLOOR_ASSIGN(y, glyphy);
 911             glyphListOrigX += ginfo-&gt;advanceX;
 912             glyphListOrigY += ginfo-&gt;advanceY;
 913         }
 914 
 915         if (ginfo-&gt;image == NULL) {
 916             J2dTraceLn(J2D_TRACE_INFO, &quot;Glyph image is null&quot;);
 917             continue;
 918         }
 919 
 920         J2dTraceLn2(J2D_TRACE_INFO, &quot;Glyph width = %d height = %d&quot;, ginfo-&gt;width, ginfo-&gt;height);
 921         J2dTraceLn1(J2D_TRACE_INFO, &quot;rowBytes = %d&quot;, ginfo-&gt;rowBytes);
 922         if (grayscale) {
 923             // grayscale or monochrome glyph data
 924             if (ginfo-&gt;width &lt;= MTLTR_CACHE_CELL_WIDTH &amp;&amp;
 925                 ginfo-&gt;height &lt;= MTLTR_CACHE_CELL_HEIGHT)
 926             {
 927                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList Grayscale cache&quot;);
 928                 ok = MTLTR_DrawGrayscaleGlyphViaCache(mtlc, ginfo, x, y, dstOps);
 929             } else {
 930                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList Grayscale no cache&quot;);
 931                 ok = MTLTR_DrawGrayscaleGlyphNoCache(mtlc, ginfo, x, y, dstOps);
 932             }
 933         } else {
 934             void* dstTexture = dstOps-&gt;textureLCD;
 935 
 936             // LCD-optimized glyph data
 937             jint rowBytesOffset = 0;
 938 
 939             if (subPixPos) {
 940                 jint frac = (jint)((glyphx - x) * 3);
 941                 if (frac != 0) {
 942                     rowBytesOffset = 3 - frac;
 943                     x += 1;
 944                 }
 945             }
 946 
 947             if (rowBytesOffset == 0 &amp;&amp;
 948                 ginfo-&gt;width &lt;= MTLTR_CACHE_CELL_WIDTH &amp;&amp;
 949                 ginfo-&gt;height &lt;= MTLTR_CACHE_CELL_HEIGHT)
 950             {
 951                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList LCD cache&quot;);
 952                 ok = MTLTR_DrawLCDGlyphViaCache(mtlc, dstOps,
 953                                                 ginfo, x, y,
 954                                                 rowBytesOffset,
 955                                                 rgbOrder, lcdContrast,
 956                                                 dstTexture);
 957             } else {
 958                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList LCD no cache&quot;);
 959                 ok = MTLTR_DrawLCDGlyphNoCache(mtlc, dstOps,
 960                                                ginfo, x, y,
 961                                                rowBytesOffset,
 962                                                rgbOrder, lcdContrast,
 963                                                dstTexture);
 964             }
 965         }
 966 
 967         if (!ok) {
 968             break;
 969         }
 970     }
 971     /*
 972      * Only in case of grayscale text drawing we need to flush
 973      * cache. Still in case of LCD we are not using any intermediate
 974      * cache.
 975      */
 976     if (glyphMode == MODE_NO_CACHE_GRAY) {
 977         MTLVertexCache_DisableMaskCache(mtlc);
 978     } else if (glyphMode == MODE_USE_CACHE_GRAY) {
 979         MTLTR_DisableGlyphVertexCache(mtlc);
 980     } else if (glyphMode == MODE_USE_CACHE_LCD) {
 981         [mtlc.encoderManager endEncoder];
 982         lcdCacheEncoder = nil;
 983     }
 984 }
 985 
 986 JNIEXPORT void JNICALL
 987 Java_sun_java2d_metal_MTLTextRenderer_drawGlyphList
 988     (JNIEnv *env, jobject self,
 989      jint numGlyphs, jboolean usePositions,
 990      jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,
 991      jfloat glyphListOrigX, jfloat glyphListOrigY,
 992      jlongArray imgArray, jfloatArray posArray)
 993 {
 994     unsigned char *images;
 995 
 996     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTextRenderer_drawGlyphList&quot;);
 997 
 998     images = (unsigned char *)
 999         (*env)-&gt;GetPrimitiveArrayCritical(env, imgArray, NULL);
1000     if (images != NULL) {
1001         MTLContext *mtlc = MTLRenderQueue_GetCurrentContext();
1002         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
1003 
1004         if (usePositions) {
1005             unsigned char *positions = (unsigned char *)
1006                 (*env)-&gt;GetPrimitiveArrayCritical(env, posArray, NULL);
1007             if (positions != NULL) {
1008                 MTLTR_DrawGlyphList(env, mtlc, dstOps,
1009                                     numGlyphs, usePositions,
1010                                     subPixPos, rgbOrder, lcdContrast,
1011                                     glyphListOrigX, glyphListOrigY,
1012                                     images, positions);
1013                 (*env)-&gt;ReleasePrimitiveArrayCritical(env, posArray,
1014                                                       positions, JNI_ABORT);
1015             }
1016         } else {
1017             MTLTR_DrawGlyphList(env, mtlc, dstOps,
1018                                 numGlyphs, usePositions,
1019                                 subPixPos, rgbOrder, lcdContrast,
1020                                 glyphListOrigX, glyphListOrigY,
1021                                 images, NULL);
1022         }
1023 
1024         (*env)-&gt;ReleasePrimitiveArrayCritical(env, imgArray,
1025                                               images, JNI_ABORT);
1026     }
1027 }
1028 
1029 #endif /* !HEADLESS */
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>