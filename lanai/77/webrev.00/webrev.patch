diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/EncoderManager.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/EncoderManager.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/EncoderManager.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/EncoderManager.m
@@ -396,11 +396,10 @@
 }
 
 - (void) endEncoder {
     if (_encoder != nil) {
       [_encoder endEncoding];
-      [_encoder release];
       _encoder = nil;
         if (_aaDestination != nil) {
           id<MTLTexture> aaDest = _aaDestination;
           _aaDestination = nil;
           NSUInteger _w = _destination.width;
@@ -423,11 +422,10 @@
 
           [_encoder setVertexBytes:quadTxVerticesBuffer length:sizeof(quadTxVerticesBuffer) atIndex:MeshVertexBuffer];
           [_encoder setFragmentTexture:aaDest atIndex: 0];
           [_encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
           [_encoder endEncoding];
-          [_encoder release];
         }
 
         _encoder = nil;
         _destination = nil;
     }
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLClip.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLClip.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLClip.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLClip.m
@@ -15,11 +15,11 @@
     vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;
     vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);
     vertDesc.layouts[MeshVertexBuffer].stepRate = 1;
     vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 
-    templateStencilPipelineDesc = [[MTLRenderPipelineDescriptor new] autorelease];
+    templateStencilPipelineDesc = [MTLRenderPipelineDescriptor new];
     templateStencilPipelineDesc.sampleCount = 1;
     templateStencilPipelineDesc.vertexDescriptor = vertDesc;
     templateStencilPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatR8Uint; // A byte buffer format
     templateStencilPipelineDesc.label = @"template_stencil";
 }
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m
@@ -67,26 +67,26 @@
     vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;
     vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);
     vertDesc.layouts[MeshVertexBuffer].stepRate = 1;
     vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 
-    templateRenderPipelineDesc = [[MTLRenderPipelineDescriptor new] autorelease];
+    templateRenderPipelineDesc = [MTLRenderPipelineDescriptor new];
     templateRenderPipelineDesc.sampleCount = 1;
     templateRenderPipelineDesc.vertexDescriptor = vertDesc;
     templateRenderPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;
     templateRenderPipelineDesc.label = @"template_render";
 
-    templateTexturePipelineDesc = [[templateRenderPipelineDesc copy] autorelease];
+    templateTexturePipelineDesc = [templateRenderPipelineDesc copy];
     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;
     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);
     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;
     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);
     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;
     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
     templateTexturePipelineDesc.label = @"template_texture";
 
-    templateAATexturePipelineDesc = [[templateTexturePipelineDesc copy] autorelease];
+    templateAATexturePipelineDesc = [templateTexturePipelineDesc copy];
     templateAATexturePipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorOne;
     templateAATexturePipelineDesc.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactorOne;
     templateAATexturePipelineDesc.colorAttachments[0].destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
     templateAATexturePipelineDesc.colorAttachments[0].destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
     templateAATexturePipelineDesc.label = @"template_aa_texture";
@@ -361,11 +361,11 @@
 {
     initTemplatePipelineDescriptors();
 
     NSString * vertShader = @"vert_txt";
     NSString * fragShader = @"frag_txt";
-    MTLRenderPipelineDescriptor * rpDesc = templateTexturePipelineDesc;
+    MTLRenderPipelineDescriptor * rpDesc = [[templateTexturePipelineDesc copy] autorelease];
 
     if (renderOptions->isTexture) {
         NSObject *bufImgOp = [mtlc getBufImgOp];
         if (bufImgOp != nil) {
             if ([bufImgOp isKindOfClass:[MTLRescaleOp class]]) {
@@ -485,11 +485,11 @@
 
     jint xorColor = (jint) [mtlc.composite getXorColor];
 
     NSString * vertShader = @"vert_txt_xorMode";
     NSString * fragShader = @"frag_txt_xorMode";
-    MTLRenderPipelineDescriptor * rpDesc = templateTexturePipelineDesc;
+    MTLRenderPipelineDescriptor * rpDesc = [[templateTexturePipelineDesc copy] autorelease];
 
     if (renderOptions->isTexture) {
         const int col = _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? _color ^ xorColor : 0 ^ xorColor;
         setTxtUniforms(encoder, col, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0,
                        renderOptions->interpolation, NO, [mtlc.composite getExtraAlpha],
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m
@@ -361,774 +361,792 @@
             "MTLRenderQueue_flushBuffer: cannot get direct buffer address");
         return;
     }
 
     end = b + limit;
-
-    jboolean DEBUG_LOG = JNI_FALSE;
-    while (b < end) {
-        jint opcode = NEXT_INT(b);
-
-        if (DEBUG_LOG) {
-            J2dTraceLn2(J2D_TRACE_ERROR,
-                    "MTLRenderQueue_flushBuffer: opcode_name = %s, rem=%d",
-                    getOpcodeString(opcode), (end-b));
-        } else {
-            J2dTraceLn2(J2D_TRACE_VERBOSE,
-                    "MTLRenderQueue_flushBuffer: opcode=%d, rem=%d",
-                    opcode, (end-b));
-        }
-
-        switch (opcode) {
-
-        // draw ops
-        case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-
-                if ([mtlc useXORComposite]) {
-                    commitEncodedCommands();
-                    J2dTraceLn(J2D_TRACE_VERBOSE, "DRAW_LINE in XOR mode - Force commit earlier draw calls before DRAW_LINE.");
+    @autoreleasepool {
+        jboolean DEBUG_LOG = JNI_FALSE;
+        while (b < end) {
+            jint opcode = NEXT_INT(b);
+
+            if (DEBUG_LOG) {
+                J2dTraceLn2(J2D_TRACE_ERROR,
+                        "MTLRenderQueue_flushBuffer: opcode_name = %s, rem=%d",
+                        getOpcodeString(opcode), (end-b));
+            } else {
+                J2dTraceLn2(J2D_TRACE_VERBOSE,
+                        "MTLRenderQueue_flushBuffer: opcode=%d, rem=%d",
+                        opcode, (end-b));
+            }
+
+            switch (opcode) {
+
+                // draw ops
+                case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+
+                    if ([mtlc useXORComposite]) {
+                        commitEncodedCommands();
+                        J2dTraceLn(J2D_TRACE_VERBOSE,
+                                   "DRAW_LINE in XOR mode - Force commit earlier draw calls before DRAW_LINE.");
+                    }
+                    jint x1 = NEXT_INT(b);
+                    jint y1 = NEXT_INT(b);
+                    jint x2 = NEXT_INT(b);
+                    jint y2 = NEXT_INT(b);
+                    MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);
+                    break;
                 }
-                jint x1 = NEXT_INT(b);
-                jint y1 = NEXT_INT(b);
-                jint x2 = NEXT_INT(b);
-                jint y2 = NEXT_INT(b);
-                MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-
-                if ([mtlc useXORComposite]) {
-                    commitEncodedCommands();
-                    J2dTraceLn(J2D_TRACE_VERBOSE, "DRAW_RECT in XOR mode - Force commit earlier draw calls before DRAW_RECT.");
+                case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+
+                    if ([mtlc useXORComposite]) {
+                        commitEncodedCommands();
+                        J2dTraceLn(J2D_TRACE_VERBOSE,
+                                   "DRAW_RECT in XOR mode - Force commit earlier draw calls before DRAW_RECT.");
+                    }
+                    jint x = NEXT_INT(b);
+                    jint y = NEXT_INT(b);
+                    jint w = NEXT_INT(b);
+                    jint h = NEXT_INT(b);
+                    MTLRenderer_DrawRect(mtlc, dstOps, x, y, w, h);
+                    break;
                 }
-                jint x = NEXT_INT(b);
-                jint y = NEXT_INT(b);
-                jint w = NEXT_INT(b);
-                jint h = NEXT_INT(b);
-                MTLRenderer_DrawRect(mtlc, dstOps, x, y, w, h);
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jint nPoints      = NEXT_INT(b);
-                jboolean isClosed = NEXT_BOOLEAN(b);
-                jint transX       = NEXT_INT(b);
-                jint transY       = NEXT_INT(b);
-                jint *xPoints = (jint *)b;
-                jint *yPoints = ((jint *)b) + nPoints;
-
-                if ([mtlc useXORComposite]) {
-                    commitEncodedCommands();
-                    J2dTraceLn(J2D_TRACE_VERBOSE, "DRAW_POLY in XOR mode - Force commit earlier draw calls before DRAW_POLY.");
-
-                    // draw separate (N-1) lines using N points
-                    for(int point = 0; point < nPoints-1; point++) {
-                        jint x1 = xPoints[point] + transX;
-                        jint y1 = yPoints[point] + transY;
-                        jint x2 = xPoints[point + 1] + transX;
-                        jint y2 = yPoints[point + 1] + transY;
-                        MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);
+                case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jint nPoints      = NEXT_INT(b);
+                    jboolean isClosed = NEXT_BOOLEAN(b);
+                    jint transX       = NEXT_INT(b);
+                    jint transY       = NEXT_INT(b);
+                    jint *xPoints = (jint *)b;
+                    jint *yPoints = ((jint *)b) + nPoints;
+
+                    if ([mtlc useXORComposite]) {
+                        commitEncodedCommands();
+                        J2dTraceLn(J2D_TRACE_VERBOSE,
+                                   "DRAW_POLY in XOR mode - Force commit earlier draw calls before DRAW_POLY.");
+
+                        // draw separate (N-1) lines using N points
+                        for(int point = 0; point < nPoints-1; point++) {
+                            jint x1 = xPoints[point] + transX;
+                            jint y1 = yPoints[point] + transY;
+                            jint x2 = xPoints[point + 1] + transX;
+                            jint y2 = yPoints[point + 1] + transY;
+                            MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);
+                        }
+
+                        if (isClosed) {
+                            MTLRenderer_DrawLine(mtlc, dstOps, xPoints[0] + transX, yPoints[0] + transY,
+                                                 xPoints[nPoints-1] + transX, yPoints[nPoints-1] + transY);
+                        }
+                    } else {
+                        MTLRenderer_DrawPoly(mtlc, dstOps, nPoints, isClosed, transX, transY, xPoints, yPoints);
                     }
 
-                    if (isClosed) {
-                        MTLRenderer_DrawLine(mtlc, dstOps, xPoints[0] + transX, yPoints[0] + transY, xPoints[nPoints-1] + transX, yPoints[nPoints-1] + transY);
-                    }
-                } else {
-                    MTLRenderer_DrawPoly(mtlc, dstOps, nPoints, isClosed, transX, transY, xPoints, yPoints);
+                    SKIP_BYTES(b, nPoints * BYTES_PER_POLY_POINT);
+                    break;
                 }
+                case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+
+                    if ([mtlc useXORComposite]) {
+                        commitEncodedCommands();
+                        J2dTraceLn(J2D_TRACE_VERBOSE,
+                                   "DRAW_PIXEL in XOR mode - Force commit earlier draw calls before DRAW_PIXEL.");
+                    }
 
-                SKIP_BYTES(b, nPoints * BYTES_PER_POLY_POINT);
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-
-                if ([mtlc useXORComposite]) {
-                    commitEncodedCommands();
-                    J2dTraceLn(J2D_TRACE_VERBOSE, "DRAW_PIXEL in XOR mode - Force commit earlier draw calls before DRAW_PIXEL.");
+                    jint x = NEXT_INT(b);
+                    jint y = NEXT_INT(b);
+                    CONTINUE_IF_NULL(mtlc);
+                    MTLRenderer_DrawPixel(mtlc, dstOps, x, y);
+                    break;
                 }
+                case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+
+                    if ([mtlc useXORComposite]) {
+                        commitEncodedCommands();
+                        J2dTraceLn(J2D_TRACE_VERBOSE,
+                                   "DRAW_SCANLINES in XOR mode - Force commit earlier draw calls before "
+                                   "DRAW_SCANLINES.");
+                    }
 
-                jint x = NEXT_INT(b);
-                jint y = NEXT_INT(b);
-                CONTINUE_IF_NULL(mtlc);
-                MTLRenderer_DrawPixel(mtlc, dstOps, x, y);
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jint count = NEXT_INT(b);
+                    MTLRenderer_DrawScanlines(mtlc, dstOps, count, (jint *)b);
 
-                if ([mtlc useXORComposite]) {
-                    commitEncodedCommands();
-                    J2dTraceLn(J2D_TRACE_VERBOSE, "DRAW_SCANLINES in XOR mode - Force commit earlier draw calls before DRAW_SCANLINES.");
+                    SKIP_BYTES(b, count * BYTES_PER_SCANLINE);
+                    break;
                 }
+                case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+
+                    if ([mtlc useXORComposite]) {
+                        commitEncodedCommands();
+                        J2dTraceLn(J2D_TRACE_VERBOSE,
+                                   "DRAW_PARALLELOGRAM in XOR mode - Force commit earlier draw calls before "
+                                   "DRAW_PARALLELOGRAM.");
+                    }
 
-                jint count = NEXT_INT(b);
-                MTLRenderer_DrawScanlines(mtlc, dstOps, count, (jint *)b);
-
-                SKIP_BYTES(b, count * BYTES_PER_SCANLINE);
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-
-                if ([mtlc useXORComposite]) {
-                    commitEncodedCommands();
-                    J2dTraceLn(J2D_TRACE_VERBOSE, "DRAW_PARALLELOGRAM in XOR mode - Force commit earlier draw calls before DRAW_PARALLELOGRAM.");
+                    jfloat x11 = NEXT_FLOAT(b);
+                    jfloat y11 = NEXT_FLOAT(b);
+                    jfloat dx21 = NEXT_FLOAT(b);
+                    jfloat dy21 = NEXT_FLOAT(b);
+                    jfloat dx12 = NEXT_FLOAT(b);
+                    jfloat dy12 = NEXT_FLOAT(b);
+                    jfloat lwr21 = NEXT_FLOAT(b);
+                    jfloat lwr12 = NEXT_FLOAT(b);
+
+                    MTLRenderer_DrawParallelogram(mtlc, dstOps,
+                                                  x11, y11,
+                                                  dx21, dy21,
+                                                  dx12, dy12,
+                                                  lwr21, lwr12);
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jfloat x11 = NEXT_FLOAT(b);
+                    jfloat y11 = NEXT_FLOAT(b);
+                    jfloat dx21 = NEXT_FLOAT(b);
+                    jfloat dy21 = NEXT_FLOAT(b);
+                    jfloat dx12 = NEXT_FLOAT(b);
+                    jfloat dy12 = NEXT_FLOAT(b);
+                    jfloat lwr21 = NEXT_FLOAT(b);
+                    jfloat lwr12 = NEXT_FLOAT(b);
+
+                    MTLRenderer_DrawAAParallelogram(mtlc, dstOps,
+                                                    x11, y11,
+                                                    dx21, dy21,
+                                                    dx12, dy12,
+                                                    lwr21, lwr12);
+                    break;
                 }
 
-                jfloat x11 = NEXT_FLOAT(b);
-                jfloat y11 = NEXT_FLOAT(b);
-                jfloat dx21 = NEXT_FLOAT(b);
-                jfloat dy21 = NEXT_FLOAT(b);
-                jfloat dx12 = NEXT_FLOAT(b);
-                jfloat dy12 = NEXT_FLOAT(b);
-                jfloat lwr21 = NEXT_FLOAT(b);
-                jfloat lwr12 = NEXT_FLOAT(b);
-
-                MTLRenderer_DrawParallelogram(mtlc, dstOps,
-                                              x11, y11,
-                                              dx21, dy21,
-                                              dx12, dy12,
-                                              lwr21, lwr12);
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jfloat x11 = NEXT_FLOAT(b);
-                jfloat y11 = NEXT_FLOAT(b);
-                jfloat dx21 = NEXT_FLOAT(b);
-                jfloat dy21 = NEXT_FLOAT(b);
-                jfloat dx12 = NEXT_FLOAT(b);
-                jfloat dy12 = NEXT_FLOAT(b);
-                jfloat lwr21 = NEXT_FLOAT(b);
-                jfloat lwr12 = NEXT_FLOAT(b);
-
-                MTLRenderer_DrawAAParallelogram(mtlc, dstOps,
-                                                x11, y11,
-                                                dx21, dy21,
-                                                dx12, dy12,
-                                                lwr21, lwr12);
-            }
-            break;
+                // fill ops
+                case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 
-        // fill ops
-        case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    if ([mtlc useXORComposite]) {
+                        commitEncodedCommands();
+                        J2dTraceLn(J2D_TRACE_VERBOSE,
+                                   "FILL_RECT in XOR mode - Force commit earlier draw calls before FILL_RECT.");
+                    }
 
-                if ([mtlc useXORComposite]) {
-                    commitEncodedCommands();
-                    J2dTraceLn(J2D_TRACE_VERBOSE, "FILL_RECT in XOR mode - Force commit earlier draw calls before FILL_RECT.");
+                    jint x = NEXT_INT(b);
+                    jint y = NEXT_INT(b);
+                    jint w = NEXT_INT(b);
+                    jint h = NEXT_INT(b);
+                    MTLRenderer_FillRect(mtlc, dstOps, x, y, w, h);
+                    break;
                 }
+                case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+
+                    if ([mtlc useXORComposite]) {
+                        commitEncodedCommands();
+                        J2dTraceLn(J2D_TRACE_VERBOSE,
+                                   "FILL_SPANS in XOR mode - Force commit earlier draw calls before FILL_SPANS.");
+                    }
 
-                jint x = NEXT_INT(b);
-                jint y = NEXT_INT(b);
-                jint w = NEXT_INT(b);
-                jint h = NEXT_INT(b);
-                MTLRenderer_FillRect(mtlc, dstOps, x, y, w, h);
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-
-                if ([mtlc useXORComposite]) {
-                    commitEncodedCommands();
-                    J2dTraceLn(J2D_TRACE_VERBOSE, "FILL_SPANS in XOR mode - Force commit earlier draw calls before FILL_SPANS.");
+                    jint count = NEXT_INT(b);
+                    MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
+                    SKIP_BYTES(b, count * BYTES_PER_SPAN);
+                    break;
                 }
+                case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+
+                    if ([mtlc useXORComposite]) {
+                        commitEncodedCommands();
+                        J2dTraceLn(J2D_TRACE_VERBOSE,
+                                   "FILL_PARALLELOGRAM in XOR mode - Force commit earlier draw calls before "
+                                   "FILL_PARALLELOGRAM.");
+                    }
 
-                jint count = NEXT_INT(b);
-                MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
-                SKIP_BYTES(b, count * BYTES_PER_SPAN);
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-
-                if ([mtlc useXORComposite]) {
-                    commitEncodedCommands();
-                    J2dTraceLn(J2D_TRACE_VERBOSE, "FILL_PARALLELOGRAM in XOR mode - Force commit earlier draw calls before FILL_PARALLELOGRAM.");
+                    jfloat x11 = NEXT_FLOAT(b);
+                    jfloat y11 = NEXT_FLOAT(b);
+                    jfloat dx21 = NEXT_FLOAT(b);
+                    jfloat dy21 = NEXT_FLOAT(b);
+                    jfloat dx12 = NEXT_FLOAT(b);
+                    jfloat dy12 = NEXT_FLOAT(b);
+                    MTLRenderer_FillParallelogram(mtlc, dstOps,
+                                                  x11, y11,
+                                                  dx21, dy21,
+                                                  dx12, dy12);
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_AA);
+                    jfloat x11 = NEXT_FLOAT(b);
+                    jfloat y11 = NEXT_FLOAT(b);
+                    jfloat dx21 = NEXT_FLOAT(b);
+                    jfloat dy21 = NEXT_FLOAT(b);
+                    jfloat dx12 = NEXT_FLOAT(b);
+                    jfloat dy12 = NEXT_FLOAT(b);
+                    MTLRenderer_FillAAParallelogram(mtlc, dstOps,
+                                                    x11, y11,
+                                                    dx21, dy21,
+                                                    dx12, dy12);
+                    break;
                 }
 
-                jfloat x11 = NEXT_FLOAT(b);
-                jfloat y11 = NEXT_FLOAT(b);
-                jfloat dx21 = NEXT_FLOAT(b);
-                jfloat dy21 = NEXT_FLOAT(b);
-                jfloat dx12 = NEXT_FLOAT(b);
-                jfloat dy12 = NEXT_FLOAT(b);
-                MTLRenderer_FillParallelogram(mtlc, dstOps,
-                                              x11, y11,
-                                              dx21, dy21,
-                                              dx12, dy12);
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_AA);
-                jfloat x11 = NEXT_FLOAT(b);
-                jfloat y11 = NEXT_FLOAT(b);
-                jfloat dx21 = NEXT_FLOAT(b);
-                jfloat dy21 = NEXT_FLOAT(b);
-                jfloat dx12 = NEXT_FLOAT(b);
-                jfloat dy12 = NEXT_FLOAT(b);
-                MTLRenderer_FillAAParallelogram(mtlc, dstOps,
-                                                x11, y11,
-                                                dx21, dy21,
-                                                dx12, dy12);
-            }
-            break;
+                // text-related ops
+                case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 
-        // text-related ops
-        case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    if ([mtlc useXORComposite]) {
+                        commitEncodedCommands();
+                        J2dTraceLn(J2D_TRACE_VERBOSE,
+                                   "DRAW_GLYPH_LIST in XOR mode - Force commit earlier draw calls before "
+                                   "DRAW_GLYPH_LIST.");
+                    }
 
-                if ([mtlc useXORComposite]) {
-                    commitEncodedCommands();
-                    J2dTraceLn(J2D_TRACE_VERBOSE, "DRAW_GLYPH_LIST in XOR mode - Force commit earlier draw calls before DRAW_GLYPH_LIST.");
+                    jint numGlyphs        = NEXT_INT(b);
+                    jint packedParams     = NEXT_INT(b);
+                    jfloat glyphListOrigX = NEXT_FLOAT(b);
+                    jfloat glyphListOrigY = NEXT_FLOAT(b);
+                    jboolean usePositions = EXTRACT_BOOLEAN(packedParams,
+                                                            OFFSET_POSITIONS);
+                    jboolean subPixPos    = EXTRACT_BOOLEAN(packedParams,
+                                                            OFFSET_SUBPIXPOS);
+                    jboolean rgbOrder     = EXTRACT_BOOLEAN(packedParams,
+                                                            OFFSET_RGBORDER);
+                    jint lcdContrast      = EXTRACT_BYTE(packedParams,
+                                                         OFFSET_CONTRAST);
+                    unsigned char *images = b;
+                    unsigned char *positions;
+                    jint bytesPerGlyph;
+                    if (usePositions) {
+                        positions = (b + numGlyphs * BYTES_PER_GLYPH_IMAGE);
+                        bytesPerGlyph = BYTES_PER_POSITIONED_GLYPH;
+                    } else {
+                        positions = NULL;
+                        bytesPerGlyph = BYTES_PER_GLYPH_IMAGE;
+                    }
+                    MTLTR_DrawGlyphList(env, mtlc, dstOps,
+                                        numGlyphs, usePositions,
+                                        subPixPos, rgbOrder, lcdContrast,
+                                        glyphListOrigX, glyphListOrigY,
+                                        images, positions);
+                    SKIP_BYTES(b, numGlyphs * bytesPerGlyph);
+                    break;
                 }
 
-                jint numGlyphs        = NEXT_INT(b);
-                jint packedParams     = NEXT_INT(b);
-                jfloat glyphListOrigX = NEXT_FLOAT(b);
-                jfloat glyphListOrigY = NEXT_FLOAT(b);
-                jboolean usePositions = EXTRACT_BOOLEAN(packedParams,
-                                                        OFFSET_POSITIONS);
-                jboolean subPixPos    = EXTRACT_BOOLEAN(packedParams,
-                                                        OFFSET_SUBPIXPOS);
-                jboolean rgbOrder     = EXTRACT_BOOLEAN(packedParams,
-                                                        OFFSET_RGBORDER);
-                jint lcdContrast      = EXTRACT_BYTE(packedParams,
-                                                     OFFSET_CONTRAST);
-                unsigned char *images = b;
-                unsigned char *positions;
-                jint bytesPerGlyph;
-                if (usePositions) {
-                    positions = (b + numGlyphs * BYTES_PER_GLYPH_IMAGE);
-                    bytesPerGlyph = BYTES_PER_POSITIONED_GLYPH;
-                } else {
-                    positions = NULL;
-                    bytesPerGlyph = BYTES_PER_GLYPH_IMAGE;
+                // copy-related ops
+                case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jint x  = NEXT_INT(b);
+                    jint y  = NEXT_INT(b);
+                    jint w  = NEXT_INT(b);
+                    jint h  = NEXT_INT(b);
+                    jint dx = NEXT_INT(b);
+                    jint dy = NEXT_INT(b);
+                    MTLBlitLoops_CopyArea(env, mtlc, dstOps,
+                                          x, y, w, h, dx, dy);
+                    break;
                 }
-                MTLTR_DrawGlyphList(env, mtlc, dstOps,
-                                    numGlyphs, usePositions,
-                                    subPixPos, rgbOrder, lcdContrast,
-                                    glyphListOrigX, glyphListOrigY,
-                                    images, positions);
-                SKIP_BYTES(b, numGlyphs * bytesPerGlyph);
-            }
-            break;
-
-        // copy-related ops
-        case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jint x  = NEXT_INT(b);
-                jint y  = NEXT_INT(b);
-                jint w  = NEXT_INT(b);
-                jint h  = NEXT_INT(b);
-                jint dx = NEXT_INT(b);
-                jint dy = NEXT_INT(b);
-                MTLBlitLoops_CopyArea(env, mtlc, dstOps,
-                                      x, y, w, h, dx, dy);
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_BLIT:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jint packedParams = NEXT_INT(b);
-                jint sx1          = NEXT_INT(b);
-                jint sy1          = NEXT_INT(b);
-                jint sx2          = NEXT_INT(b);
-                jint sy2          = NEXT_INT(b);
-                jdouble dx1       = NEXT_DOUBLE(b);
-                jdouble dy1       = NEXT_DOUBLE(b);
-                jdouble dx2       = NEXT_DOUBLE(b);
-                jdouble dy2       = NEXT_DOUBLE(b);
-                jlong pSrc        = NEXT_LONG(b);
-                jlong pDst        = NEXT_LONG(b);
-                jint hint         = EXTRACT_BYTE(packedParams, OFFSET_HINT);
-                jboolean texture  = EXTRACT_BOOLEAN(packedParams,
-                                                    OFFSET_TEXTURE);
-                jboolean xform    = EXTRACT_BOOLEAN(packedParams,
-                                                    OFFSET_XFORM);
-                jboolean isoblit  = EXTRACT_BOOLEAN(packedParams,
-                                                    OFFSET_ISOBLIT);
-                if (isoblit) {
-                    MTLBlitLoops_IsoBlit(env, mtlc, pSrc, pDst,
-                                         xform, hint, texture,
-                                         sx1, sy1, sx2, sy2,
-                                         dx1, dy1, dx2, dy2);
-                } else {
-                    jint srctype = EXTRACT_BYTE(packedParams, OFFSET_SRCTYPE);
-                    MTLBlitLoops_Blit(env, mtlc, pSrc, pDst,
-                                      xform, hint, srctype, texture,
-                                      sx1, sy1, sx2, sy2,
-                                      dx1, dy1, dx2, dy2);
+                case sun_java2d_pipe_BufferedOpCodes_BLIT:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jint packedParams = NEXT_INT(b);
+                    jint sx1          = NEXT_INT(b);
+                    jint sy1          = NEXT_INT(b);
+                    jint sx2          = NEXT_INT(b);
+                    jint sy2          = NEXT_INT(b);
+                    jdouble dx1       = NEXT_DOUBLE(b);
+                    jdouble dy1       = NEXT_DOUBLE(b);
+                    jdouble dx2       = NEXT_DOUBLE(b);
+                    jdouble dy2       = NEXT_DOUBLE(b);
+                    jlong pSrc        = NEXT_LONG(b);
+                    jlong pDst        = NEXT_LONG(b);
+                    jint hint         = EXTRACT_BYTE(packedParams, OFFSET_HINT);
+                    jboolean texture  = EXTRACT_BOOLEAN(packedParams,
+                                                        OFFSET_TEXTURE);
+                    jboolean xform    = EXTRACT_BOOLEAN(packedParams,
+                                                        OFFSET_XFORM);
+                    jboolean isoblit  = EXTRACT_BOOLEAN(packedParams,
+                                                        OFFSET_ISOBLIT);
+                    if (isoblit) {
+                        MTLBlitLoops_IsoBlit(env, mtlc, pSrc, pDst,
+                                             xform, hint, texture,
+                                             sx1, sy1, sx2, sy2,
+                                             dx1, dy1, dx2, dy2);
+                    } else {
+                        jint srctype = EXTRACT_BYTE(packedParams, OFFSET_SRCTYPE);
+                        MTLBlitLoops_Blit(env, mtlc, pSrc, pDst,
+                                          xform, hint, srctype, texture,
+                                          sx1, sy1, sx2, sy2,
+                                          dx1, dy1, dx2, dy2);
+                    }
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jint sx      = NEXT_INT(b);
+                    jint sy      = NEXT_INT(b);
+                    jint dx      = NEXT_INT(b);
+                    jint dy      = NEXT_INT(b);
+                    jint w       = NEXT_INT(b);
+                    jint h       = NEXT_INT(b);
+                    jint dsttype = NEXT_INT(b);
+                    jlong pSrc   = NEXT_LONG(b);
+                    jlong pDst   = NEXT_LONG(b);
+                    MTLBlitLoops_SurfaceToSwBlit(env, mtlc,
+                                                 pSrc, pDst, dsttype,
+                                                 sx, sy, dx, dy, w, h);
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jint x        = NEXT_INT(b);
+                    jint y        = NEXT_INT(b);
+                    jint w        = NEXT_INT(b);
+                    jint h        = NEXT_INT(b);
+                    jint maskoff  = NEXT_INT(b);
+                    jint maskscan = NEXT_INT(b);
+                    jint masklen  = NEXT_INT(b);
+                    unsigned char *pMask = (masklen > 0) ? b : NULL;
+                    MTLMaskFill_MaskFill(mtlc, dstOps, x, y, w, h,
+                                         maskoff, maskscan, masklen, pMask);
+                    SKIP_BYTES(b, masklen);
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jint dstx     = NEXT_INT(b);
+                    jint dsty     = NEXT_INT(b);
+                    jint width    = NEXT_INT(b);
+                    jint height   = NEXT_INT(b);
+                    jint masklen  = width * height * sizeof(jint);
+                    MTLMaskBlit_MaskBlit(env, mtlc, dstOps,
+                                         dstx, dsty, width, height, b);
+                    SKIP_BYTES(b, masklen);
+                    break;
                 }
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jint sx      = NEXT_INT(b);
-                jint sy      = NEXT_INT(b);
-                jint dx      = NEXT_INT(b);
-                jint dy      = NEXT_INT(b);
-                jint w       = NEXT_INT(b);
-                jint h       = NEXT_INT(b);
-                jint dsttype = NEXT_INT(b);
-                jlong pSrc   = NEXT_LONG(b);
-                jlong pDst   = NEXT_LONG(b);
-                MTLBlitLoops_SurfaceToSwBlit(env, mtlc,
-                                             pSrc, pDst, dsttype,
-                                             sx, sy, dx, dy, w, h);
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jint x        = NEXT_INT(b);
-                jint y        = NEXT_INT(b);
-                jint w        = NEXT_INT(b);
-                jint h        = NEXT_INT(b);
-                jint maskoff  = NEXT_INT(b);
-                jint maskscan = NEXT_INT(b);
-                jint masklen  = NEXT_INT(b);
-                unsigned char *pMask = (masklen > 0) ? b : NULL;
-                MTLMaskFill_MaskFill(mtlc, dstOps, x, y, w, h,
-                                     maskoff, maskscan, masklen, pMask);
-                SKIP_BYTES(b, masklen);
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jint dstx     = NEXT_INT(b);
-                jint dsty     = NEXT_INT(b);
-                jint width    = NEXT_INT(b);
-                jint height   = NEXT_INT(b);
-                jint masklen  = width * height * sizeof(jint);
-                MTLMaskBlit_MaskBlit(env, mtlc, dstOps,
-                                     dstx, dsty, width, height, b);
-                SKIP_BYTES(b, masklen);
-            }
-            break;
-
-        // state-related ops
-        case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jint x1 = NEXT_INT(b);
-                jint y1 = NEXT_INT(b);
-                jint x2 = NEXT_INT(b);
-                jint y2 = NEXT_INT(b);
-                [mtlc setClipRectX1:x1 Y1:y1 X2:x2 Y2:y2];
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                [mtlc beginShapeClip:dstOps];
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                // This results in creation of new render encoder with
-                // stencil buffer set as render target
-                jint count = NEXT_INT(b);
-                MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
-                SKIP_BYTES(b, count * BYTES_PER_SPAN);
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                [mtlc endShapeClip:dstOps];
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                [mtlc resetClip];
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jint rule         = NEXT_INT(b);
-                jfloat extraAlpha = NEXT_FLOAT(b);
-                jint flags        = NEXT_INT(b);
-                [mtlc setAlphaCompositeRule:rule extraAlpha:extraAlpha flags:flags];
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jint xorPixel = NEXT_INT(b);
-                [mtlc setXorComposite:xorPixel];
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
-            {
-                /* TODO: check whether something needs to be done here if we are moving out of XOR composite
-                commitEncodedCommands();
-                MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
-                [cbwrapper onComplete];
 
-                J2dTraceLn(J2D_TRACE_VERBOSE, "RESET_COMPOSITE - Force commit earlier draw calls before RESET_COMPOSITE.");*/
+                // state-related ops
+                case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jint x1 = NEXT_INT(b);
+                    jint y1 = NEXT_INT(b);
+                    jint x2 = NEXT_INT(b);
+                    jint y2 = NEXT_INT(b);
+                    [mtlc setClipRectX1:x1 Y1:y1 X2:x2 Y2:y2];
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    [mtlc beginShapeClip:dstOps];
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    // This results in creation of new render encoder with
+                    // stencil buffer set as render target
+                    jint count = NEXT_INT(b);
+                    MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
+                    SKIP_BYTES(b, count * BYTES_PER_SPAN);
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    [mtlc endShapeClip:dstOps];
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    [mtlc resetClip];
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jint rule         = NEXT_INT(b);
+                    jfloat extraAlpha = NEXT_FLOAT(b);
+                    jint flags        = NEXT_INT(b);
+                    [mtlc setAlphaCompositeRule:rule extraAlpha:extraAlpha flags:flags];
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jint xorPixel = NEXT_INT(b);
+                    [mtlc setXorComposite:xorPixel];
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
+                {
+                    /* TODO: check whether something needs to be done here if we are moving out of XOR composite
+                    commitEncodedCommands();
+                    MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
+                    [cbwrapper onComplete];
 
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                [mtlc resetComposite];
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jdouble m00 = NEXT_DOUBLE(b);
-                jdouble m10 = NEXT_DOUBLE(b);
-                jdouble m01 = NEXT_DOUBLE(b);
-                jdouble m11 = NEXT_DOUBLE(b);
-                jdouble m02 = NEXT_DOUBLE(b);
-                jdouble m12 = NEXT_DOUBLE(b);
-                [mtlc setTransformM00:m00 M10:m10 M01:m01 M11:m11 M02:m02 M12:m12];
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                [mtlc resetTransform];
-            }
-            break;
+                    J2dTraceLn(J2D_TRACE_VERBOSE,
+                     "RESET_COMPOSITE - Force commit earlier draw calls before RESET_COMPOSITE.");*/
 
-        // context-related ops
-        case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jlong pSrc = NEXT_LONG(b);
-                jlong pDst = NEXT_LONG(b);
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    [mtlc resetComposite];
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jdouble m00 = NEXT_DOUBLE(b);
+                    jdouble m10 = NEXT_DOUBLE(b);
+                    jdouble m01 = NEXT_DOUBLE(b);
+                    jdouble m11 = NEXT_DOUBLE(b);
+                    jdouble m02 = NEXT_DOUBLE(b);
+                    jdouble m12 = NEXT_DOUBLE(b);
+                    [mtlc setTransformM00:m00 M10:m10 M01:m01 M11:m11 M02:m02 M12:m12];
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    [mtlc resetTransform];
+                    break;
+                }
 
-                dstOps = (BMTLSDOps *)jlong_to_ptr(pDst);
-                mtlc = [MTLContext setSurfacesEnv:env src:pSrc dst:pDst];
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jlong pConfigInfo = NEXT_LONG(b);
-                MTLGraphicsConfigInfo *mtlInfo =
-                        (MTLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);
+                // context-related ops
+                case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jlong pSrc = NEXT_LONG(b);
+                    jlong pDst = NEXT_LONG(b);
 
-                if (mtlInfo == NULL) {
+                    dstOps = (BMTLSDOps *)jlong_to_ptr(pDst);
+                    mtlc = [MTLContext setSurfacesEnv:env src:pSrc dst:pDst];
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jlong pConfigInfo = NEXT_LONG(b);
+                    MTLGraphicsConfigInfo *mtlInfo =
+                            (MTLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);
 
-                } else {
-                    MTLContext *newMtlc = mtlInfo->context;
-                    if (newMtlc == NULL) {
+                    if (mtlInfo == NULL) {
 
                     } else {
-                        mtlc = newMtlc;
-                        dstOps = NULL;
+                        MTLContext *newMtlc = mtlInfo->context;
+                        if (newMtlc == NULL) {
+
+                        } else {
+                            mtlc = newMtlc;
+                            dstOps = NULL;
+                        }
                     }
+                    break;
                 }
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jlong pData = NEXT_LONG(b);
-                BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
-                if (mtlsdo != NULL) {
-                    CONTINUE_IF_NULL(mtlc);
-                    MTLSD_Delete(env, mtlsdo);
+                case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jlong pData = NEXT_LONG(b);
+                    BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
+                    if (mtlsdo != NULL) {
+                        CONTINUE_IF_NULL(mtlc);
+                        MTLSD_Delete(env, mtlsdo);
+                    }
+                    break;
                 }
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jlong pData = NEXT_LONG(b);
-                BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
-                if (mtlsdo != NULL) {
-                    CONTINUE_IF_NULL(mtlc);
-                    MTLSD_Delete(env, mtlsdo);
-                    if (mtlsdo->privOps != NULL) {
-                        free(mtlsdo->privOps);
+                case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jlong pData = NEXT_LONG(b);
+                    BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
+                    if (mtlsdo != NULL) {
+                        CONTINUE_IF_NULL(mtlc);
+                        MTLSD_Delete(env, mtlsdo);
+                        if (mtlsdo->privOps != NULL) {
+                            free(mtlsdo->privOps);
+                        }
                     }
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jlong pConfigInfo = NEXT_LONG(b);
+                    CONTINUE_IF_NULL(mtlc);
+                    MTLGC_DestroyMTLGraphicsConfig(pConfigInfo);
+
+                    // the previous method will call glX/wglMakeCurrent(None),
+                    // so we should nullify the current mtlc and dstOps to avoid
+                    // calling glFlush() (or similar) while no context is current
+                    mtlc = NULL;
+                 //   dstOps = NULL;
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    // invalidate the references to the current context and
+                    // destination surface that are maintained at the native level
+                    mtlc = NULL;
+                //    dstOps = NULL;
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_SYNC:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_SYNC);
+                    break;
                 }
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jlong pConfigInfo = NEXT_LONG(b);
-                CONTINUE_IF_NULL(mtlc);
-                MTLGC_DestroyMTLGraphicsConfig(pConfigInfo);
-
-                // the previous method will call glX/wglMakeCurrent(None),
-                // so we should nullify the current mtlc and dstOps to avoid
-                // calling glFlush() (or similar) while no context is current
-                mtlc = NULL;
-             //   dstOps = NULL;
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                // invalidate the references to the current context and
-                // destination surface that are maintained at the native level
-                mtlc = NULL;
-            //    dstOps = NULL;
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_SYNC:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_SYNC);
-            }
-            break;
 
-        // multibuffering ops
-        case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jlong window = NEXT_LONG(b);
-                MTLSD_SwapBuffers(env, window);
-            }
-            break;
+                // multibuffering ops
+                case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jlong window = NEXT_LONG(b);
+                    MTLSD_SwapBuffers(env, window);
+                    break;
+                }
 
-        // special no-op (mainly used for achieving 8-byte alignment)
-        case sun_java2d_pipe_BufferedOpCodes_NOOP:
-            break;
+                // special no-op (mainly used for achieving 8-byte alignment)
+                case sun_java2d_pipe_BufferedOpCodes_NOOP:
+                    break;
 
-        // paint-related ops
-        case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
-            {
-              CHECK_PREVIOUS_OP(MTL_OP_RESET_PAINT);
-              [mtlc resetPaint];
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_SET_COLOR);
-                jint pixel = NEXT_INT(b);
-                [mtlc setColorPaint:pixel];
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jboolean useMask= NEXT_BOOLEAN(b);
-                jboolean cyclic = NEXT_BOOLEAN(b);
-                jdouble p0      = NEXT_DOUBLE(b);
-                jdouble p1      = NEXT_DOUBLE(b);
-                jdouble p3      = NEXT_DOUBLE(b);
-                jint pixel1     = NEXT_INT(b);
-                jint pixel2     = NEXT_INT(b);
-                [mtlc setGradientPaintUseMask:useMask
-                                    cyclic:cyclic
-                                        p0:p0
-                                        p1:p1
-                                        p3:p3
-                                    pixel1:pixel1
-                                    pixel2:pixel2];
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jboolean useMask = NEXT_BOOLEAN(b);
-                jboolean linear  = NEXT_BOOLEAN(b);
-                jint cycleMethod = NEXT_INT(b);
-                jint numStops    = NEXT_INT(b);
-                jfloat p0        = NEXT_FLOAT(b);
-                jfloat p1        = NEXT_FLOAT(b);
-                jfloat p3        = NEXT_FLOAT(b);
-                void *fractions, *pixels;
-                fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
-                pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
-                [mtlc setLinearGradientPaint:useMask
-                                      linear:linear
-                                 cycleMethod:cycleMethod
-                                    numStops:numStops
-                                          p0:p0
-                                          p1:p1
-                                          p3:p3
-                                   fractions:fractions
-                                      pixels:pixels];
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jboolean useMask = NEXT_BOOLEAN(b);
-                jboolean linear  = NEXT_BOOLEAN(b);
-                jint numStops    = NEXT_INT(b);
-                jint cycleMethod = NEXT_INT(b);
-                jfloat m00       = NEXT_FLOAT(b);
-                jfloat m01       = NEXT_FLOAT(b);
-                jfloat m02       = NEXT_FLOAT(b);
-                jfloat m10       = NEXT_FLOAT(b);
-                jfloat m11       = NEXT_FLOAT(b);
-                jfloat m12       = NEXT_FLOAT(b);
-                jfloat focusX    = NEXT_FLOAT(b);
-                void *fractions, *pixels;
-                fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
-                pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
-                [mtlc setRadialGradientPaint:useMask
-                                      linear:linear
-                                 cycleMethod:cycleMethod
-                                    numStops:numStops
-                                         m00:m00
-                                         m01:m01
-                                         m02:m02
-                                         m10:m10
-                                         m11:m11
-                                         m12:m12
-                                      focusX:focusX
-                                   fractions:fractions
-                                      pixels:pixels];
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jboolean useMask= NEXT_BOOLEAN(b);
-                jboolean filter = NEXT_BOOLEAN(b);
-                jlong pSrc      = NEXT_LONG(b);
-                jdouble xp0     = NEXT_DOUBLE(b);
-                jdouble xp1     = NEXT_DOUBLE(b);
-                jdouble xp3     = NEXT_DOUBLE(b);
-                jdouble yp0     = NEXT_DOUBLE(b);
-                jdouble yp1     = NEXT_DOUBLE(b);
-                jdouble yp3     = NEXT_DOUBLE(b);
-                [mtlc setTexturePaint:useMask
-                              pSrcOps:pSrc
-                               filter:filter
-                                  xp0:xp0
-                                  xp1:xp1
-                                  xp3:xp3
-                                  yp0:yp0
-                                  yp1:yp1
-                                  yp3:yp3];
-            }
-            break;
+                // paint-related ops
+                case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
+                {
+                  CHECK_PREVIOUS_OP(MTL_OP_RESET_PAINT);
+                  [mtlc resetPaint];
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_SET_COLOR);
+                    jint pixel = NEXT_INT(b);
+                    [mtlc setColorPaint:pixel];
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jboolean useMask= NEXT_BOOLEAN(b);
+                    jboolean cyclic = NEXT_BOOLEAN(b);
+                    jdouble p0      = NEXT_DOUBLE(b);
+                    jdouble p1      = NEXT_DOUBLE(b);
+                    jdouble p3      = NEXT_DOUBLE(b);
+                    jint pixel1     = NEXT_INT(b);
+                    jint pixel2     = NEXT_INT(b);
+                    [mtlc setGradientPaintUseMask:useMask
+                                        cyclic:cyclic
+                                            p0:p0
+                                            p1:p1
+                                            p3:p3
+                                        pixel1:pixel1
+                                        pixel2:pixel2];
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jboolean useMask = NEXT_BOOLEAN(b);
+                    jboolean linear  = NEXT_BOOLEAN(b);
+                    jint cycleMethod = NEXT_INT(b);
+                    jint numStops    = NEXT_INT(b);
+                    jfloat p0        = NEXT_FLOAT(b);
+                    jfloat p1        = NEXT_FLOAT(b);
+                    jfloat p3        = NEXT_FLOAT(b);
+                    void *fractions, *pixels;
+                    fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
+                    pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
+                    [mtlc setLinearGradientPaint:useMask
+                                          linear:linear
+                                     cycleMethod:cycleMethod
+                                        numStops:numStops
+                                              p0:p0
+                                              p1:p1
+                                              p3:p3
+                                       fractions:fractions
+                                          pixels:pixels];
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jboolean useMask = NEXT_BOOLEAN(b);
+                    jboolean linear  = NEXT_BOOLEAN(b);
+                    jint numStops    = NEXT_INT(b);
+                    jint cycleMethod = NEXT_INT(b);
+                    jfloat m00       = NEXT_FLOAT(b);
+                    jfloat m01       = NEXT_FLOAT(b);
+                    jfloat m02       = NEXT_FLOAT(b);
+                    jfloat m10       = NEXT_FLOAT(b);
+                    jfloat m11       = NEXT_FLOAT(b);
+                    jfloat m12       = NEXT_FLOAT(b);
+                    jfloat focusX    = NEXT_FLOAT(b);
+                    void *fractions, *pixels;
+                    fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
+                    pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
+                    [mtlc setRadialGradientPaint:useMask
+                                          linear:linear
+                                     cycleMethod:cycleMethod
+                                        numStops:numStops
+                                             m00:m00
+                                             m01:m01
+                                             m02:m02
+                                             m10:m10
+                                             m11:m11
+                                             m12:m12
+                                          focusX:focusX
+                                       fractions:fractions
+                                          pixels:pixels];
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jboolean useMask= NEXT_BOOLEAN(b);
+                    jboolean filter = NEXT_BOOLEAN(b);
+                    jlong pSrc      = NEXT_LONG(b);
+                    jdouble xp0     = NEXT_DOUBLE(b);
+                    jdouble xp1     = NEXT_DOUBLE(b);
+                    jdouble xp3     = NEXT_DOUBLE(b);
+                    jdouble yp0     = NEXT_DOUBLE(b);
+                    jdouble yp1     = NEXT_DOUBLE(b);
+                    jdouble yp3     = NEXT_DOUBLE(b);
+                    [mtlc setTexturePaint:useMask
+                                  pSrcOps:pSrc
+                                   filter:filter
+                                      xp0:xp0
+                                      xp1:xp1
+                                      xp3:xp3
+                                      yp0:yp0
+                                      yp1:yp1
+                                      yp3:yp3];
+                    break;
+                }
 
-        // BufferedImageOp-related ops
-        case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jlong pSrc        = NEXT_LONG(b);
-                jboolean edgeZero = NEXT_BOOLEAN(b);
-                jint kernelWidth  = NEXT_INT(b);
-                jint kernelHeight = NEXT_INT(b);
-
-                BMTLSDOps * bmtlsdOps = (BMTLSDOps *)pSrc;
-                MTLConvolveOp * convolveOp = [[MTLConvolveOp alloc] init:edgeZero
-                        kernelWidth:kernelWidth
-                       kernelHeight:kernelHeight
-                           srcWidth:bmtlsdOps->width
-                          srcHeight:bmtlsdOps->height
-                             kernel:b
-                             device:mtlc.device
-                                              ];
-                [mtlc setBufImgOp:convolveOp];
-                SKIP_BYTES(b, kernelWidth * kernelHeight * sizeof(jfloat));
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                [mtlc setBufImgOp:NULL];
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jlong pSrc          = NEXT_LONG(b);
-                jboolean nonPremult = NEXT_BOOLEAN(b);
-                jint numFactors     = 4;
-                unsigned char *scaleFactors = b;
-                unsigned char *offsets = (b + numFactors * sizeof(jfloat));
-                MTLRescaleOp * rescaleOp = [[MTLRescaleOp alloc] init:nonPremult factors:scaleFactors offsets:offsets];
-                [mtlc setBufImgOp:rescaleOp];
-                SKIP_BYTES(b, numFactors * sizeof(jfloat) * 2);
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                [mtlc setBufImgOp:NULL];
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                jlong pSrc          = NEXT_LONG(b);
-                jboolean nonPremult = NEXT_BOOLEAN(b);
-                jboolean shortData  = NEXT_BOOLEAN(b);
-                jint numBands       = NEXT_INT(b);
-                jint bandLength     = NEXT_INT(b);
-                jint offset         = NEXT_INT(b);
-                jint bytesPerElem = shortData ? sizeof(jshort):sizeof(jbyte);
-                void *tableValues = b;
-
-                MTLLookupOp * lookupOp = [[MTLLookupOp alloc] init:nonPremult
-                                                         shortData:shortData
-                                                          numBands:numBands
-                                                        bandLength:bandLength
-                                                            offset:offset
-                                                       tableValues:tableValues
-                                                            device:mtlc.device];
-                [mtlc setBufImgOp:lookupOp];
-                SKIP_BYTES(b, numBands * bandLength * bytesPerElem);
-            }
-            break;
-        case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
-            {
-                CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                [mtlc setBufImgOp:NULL];
-            }
-            break;
+                // BufferedImageOp-related ops
+                case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jlong pSrc        = NEXT_LONG(b);
+                    jboolean edgeZero = NEXT_BOOLEAN(b);
+                    jint kernelWidth  = NEXT_INT(b);
+                    jint kernelHeight = NEXT_INT(b);
+
+                    BMTLSDOps * bmtlsdOps = (BMTLSDOps *)pSrc;
+                    MTLConvolveOp * convolveOp = [[MTLConvolveOp alloc] init:edgeZero
+                            kernelWidth:kernelWidth
+                           kernelHeight:kernelHeight
+                               srcWidth:bmtlsdOps->width
+                              srcHeight:bmtlsdOps->height
+                                 kernel:b
+                                 device:mtlc.device
+                                                  ];
+                    [mtlc setBufImgOp:convolveOp];
+                    SKIP_BYTES(b, kernelWidth * kernelHeight * sizeof(jfloat));
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    [mtlc setBufImgOp:NULL];
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jlong pSrc          = NEXT_LONG(b);
+                    jboolean nonPremult = NEXT_BOOLEAN(b);
+                    jint numFactors     = 4;
+                    unsigned char *scaleFactors = b;
+                    unsigned char *offsets = (b + numFactors * sizeof(jfloat));
+                    MTLRescaleOp * rescaleOp =
+                            [[MTLRescaleOp alloc] init:nonPremult factors:scaleFactors offsets:offsets];
+                    [mtlc setBufImgOp:rescaleOp];
+                    SKIP_BYTES(b, numFactors * sizeof(jfloat) * 2);
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    [mtlc setBufImgOp:NULL];
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    jlong pSrc          = NEXT_LONG(b);
+                    jboolean nonPremult = NEXT_BOOLEAN(b);
+                    jboolean shortData  = NEXT_BOOLEAN(b);
+                    jint numBands       = NEXT_INT(b);
+                    jint bandLength     = NEXT_INT(b);
+                    jint offset         = NEXT_INT(b);
+                    jint bytesPerElem = shortData ? sizeof(jshort):sizeof(jbyte);
+                    void *tableValues = b;
+
+                    MTLLookupOp * lookupOp = [[MTLLookupOp alloc] init:nonPremult
+                                                             shortData:shortData
+                                                              numBands:numBands
+                                                            bandLength:bandLength
+                                                                offset:offset
+                                                           tableValues:tableValues
+                                                                device:mtlc.device];
+                    [mtlc setBufImgOp:lookupOp];
+                    SKIP_BYTES(b, numBands * bandLength * bytesPerElem);
+                    break;
+                }
+                case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
+                {
+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);
+                    [mtlc setBufImgOp:NULL];
+                    break;
+                }
 
-        default:
-            J2dRlsTraceLn1(J2D_TRACE_ERROR,
-                "MTLRenderQueue_flushBuffer: invalid opcode=%d", opcode);
-            return;
+                default:
+                    J2dRlsTraceLn1(J2D_TRACE_ERROR,
+                        "MTLRenderQueue_flushBuffer: invalid opcode=%d", opcode);
+                    return;
+            }
         }
-    }
 
-    if (mtlc != NULL) {
-        [mtlc.encoderManager endEncoder];
-        MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
-        id<MTLCommandBuffer> commandbuf = [cbwrapper getCommandBuffer];
-        [commandbuf addCompletedHandler:^(id <MTLCommandBuffer> commandbuf) {
-            [cbwrapper release];
-        }];
-        [commandbuf commit];
-        BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
-        if (dstOps != NULL) {
-            MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps->privOps;
-            MTLLayer *layer = (MTLLayer*)dstMTLOps->layer;
-            if (layer != NULL) {
-                [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){
-                    AWT_ASSERT_APPKIT_THREAD;
-                    [layer setNeedsDisplay];
-                }];
+        if (mtlc != NULL) {
+            [mtlc.encoderManager endEncoder];
+            MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
+            id<MTLCommandBuffer> commandbuf = [cbwrapper getCommandBuffer];
+            [commandbuf addCompletedHandler:^(id <MTLCommandBuffer> commandbuf) {
+                [cbwrapper release];
+            }];
+            [commandbuf commit];
+            BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
+            if (dstOps != NULL) {
+                MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps->privOps;
+                MTLLayer *layer = (MTLLayer*)dstMTLOps->layer;
+                if (layer != NULL) {
+                    [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){
+                        AWT_ASSERT_APPKIT_THREAD;
+                        [layer setNeedsDisplay];
+                    }];
+                }
             }
         }
+        RESET_PREVIOUS_OP();
     }
-    RESET_PREVIOUS_OP();
 }
 
 /**
  * Returns a pointer to the "current" context, as set by the last SET_SURFACES
  * or SET_SCRATCH_SURFACE operation.
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLTextRenderer.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLTextRenderer.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLTextRenderer.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLTextRenderer.m
@@ -220,11 +220,10 @@
                                                             width:MTLTR_CACHE_WIDTH
                                                             height:MTLTR_CACHE_HEIGHT
                                                             mipmapped:NO];
 
     gcinfo->texture = [mtlc.device newTextureWithDescriptor:textureDescriptor];
-    [textureDescriptor release];
 
     if (lcdCache) {
         glyphCacheLCD = gcinfo;
     } else {
         glyphCacheAA = gcinfo;
@@ -334,11 +333,10 @@
                              bytesPerRow:bytesPerRow];
         }
     }
 }
 
-static MTLRenderPipelineDescriptor * templateRenderPipelineDesc = nil;
 static MTLRenderPipelineDescriptor * templateLCDPipelineDesc = nil;
 
 /**
  * Enables the LCD text shader and updates any related state, such as the
  * gamma lookup table textures.
@@ -358,11 +356,11 @@
         vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;
         vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);
         vertDesc.layouts[MeshVertexBuffer].stepRate = 1;
         vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 
-        templateLCDPipelineDesc = [[MTLRenderPipelineDescriptor new] autorelease];
+        templateLCDPipelineDesc = [MTLRenderPipelineDescriptor new];
         templateLCDPipelineDesc.sampleCount = 1;
         templateLCDPipelineDesc.vertexDescriptor = vertDesc;
         templateLCDPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;
         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;
         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);
@@ -421,11 +419,11 @@
         vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;
         vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);
         vertDesc.layouts[MeshVertexBuffer].stepRate = 1;
         vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 
-        templateLCDPipelineDesc = [[MTLRenderPipelineDescriptor new] autorelease];
+        templateLCDPipelineDesc = [MTLRenderPipelineDescriptor new];
         templateLCDPipelineDesc.sampleCount = 1;
         templateLCDPipelineDesc.vertexDescriptor = vertDesc;
         templateLCDPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;
         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;
         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);
