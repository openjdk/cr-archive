<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLTextRenderer.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifndef HEADLESS
  27 
  28 #include &lt;stdlib.h&gt;
  29 #include &lt;limits.h&gt;
  30 #include &lt;math.h&gt;
  31 #include &lt;jlong.h&gt;
  32 
  33 #include &quot;sun_java2d_metal_MTLTextRenderer.h&quot;
  34 
  35 #include &quot;SurfaceData.h&quot;
  36 #include &quot;MTLContext.h&quot;
  37 #include &quot;MTLRenderQueue.h&quot;
  38 #include &quot;MTLTextRenderer.h&quot;
  39 #include &quot;MTLVertexCache.h&quot;
  40 #include &quot;MTLGlyphCache.h&quot;
  41 #include &quot;MTLBlitLoops.h&quot;
  42 
  43 /**
  44  * The following constants define the inner and outer bounds of the
  45  * accelerated glyph cache.
  46  */
  47 #define MTLTR_CACHE_WIDTH       512
  48 #define MTLTR_CACHE_HEIGHT      512
  49 #define MTLTR_CACHE_CELL_WIDTH  32
  50 #define MTLTR_CACHE_CELL_HEIGHT 32
  51 
  52 /**
  53  * The current &quot;glyph mode&quot; state.  This variable is used to track the
  54  * codepath used to render a particular glyph.  This variable is reset to
  55  * MODE_NOT_INITED at the beginning of every call to MTLTR_DrawGlyphList().
  56  * As each glyph is rendered, the glyphMode variable is updated to reflect
  57  * the current mode, so if the current mode is the same as the mode used
  58  * to render the previous glyph, we can avoid doing costly setup operations
  59  * each time.
  60  */
  61 typedef enum {
  62     MODE_NOT_INITED,
  63     MODE_USE_CACHE_GRAY,
  64     MODE_USE_CACHE_LCD,
  65     MODE_NO_CACHE_GRAY,
  66     MODE_NO_CACHE_LCD,
  67     MODE_NO_CACHE_COLOR
  68 } GlyphMode;
  69 static GlyphMode glyphMode = MODE_NOT_INITED;
  70 
  71 /**
  72  * There are two separate glyph caches: for AA and for LCD.
  73  * Once one of them is initialized as either GRAY or LCD, it
  74  * stays in that mode for the duration of the application.  It should
  75  * be safe to use this one glyph cache for all screens in a multimon
  76  * environment, since the glyph cache texture is shared between all contexts,
  77  * and (in theory) OpenGL drivers should be smart enough to manage that
  78  * texture across all screens.
  79  */
  80 
  81 static MTLGlyphCacheInfo *glyphCacheLCD = NULL;
  82 static MTLGlyphCacheInfo *glyphCacheAA = NULL;
  83 
  84 /**
  85  * The handle to the LCD text fragment program object.
  86  */
  87 static GLhandleARB lcdTextProgram = 0;
  88 
  89 /**
  90  * This value tracks the previous LCD contrast setting, so if the contrast
  91  * value hasn&#39;t changed since the last time the gamma uniforms were
  92  * updated (not very common), then we can skip updating the unforms.
  93  */
  94 static jint lastLCDContrast = -1;
  95 
  96 /**
  97  * This value tracks the previous LCD rgbOrder setting, so if the rgbOrder
  98  * value has changed since the last time, it indicates that we need to
  99  * invalidate the cache, which may already store glyph images in the reverse
 100  * order.  Note that in most real world applications this value will not
 101  * change over the course of the application, but tests like Font2DTest
 102  * allow for changing the ordering at runtime, so we need to handle that case.
 103  */
 104 static jboolean lastRGBOrder = JNI_TRUE;
 105 
 106 /**
 107  * This constant defines the size of the tile to use in the
 108  * MTLTR_DrawLCDGlyphNoCache() method.  See below for more on why we
 109  * restrict this value to a particular size.
 110  */
 111 #define MTLTR_NOCACHE_TILE_SIZE 32
 112 
 113 /**
 114  * These constants define the size of the &quot;cached destination&quot; texture.
 115  * This texture is only used when rendering LCD-optimized text, as that
 116  * codepath needs direct access to the destination.  There is no way to
 117  * access the framebuffer directly from an OpenGL shader, so we need to first
 118  * copy the destination region corresponding to a particular glyph into
 119  * this cached texture, and then that texture will be accessed inside the
 120  * shader.  Copying the destination into this cached texture can be a very
 121  * expensive operation (accounting for about half the rendering time for
 122  * LCD text), so to mitigate this cost we try to bulk read a horizontal
 123  * region of the destination at a time.  (These values are empirically
 124  * derived for the common case where text runs horizontally.)
 125  *
 126  * Note: It is assumed in various calculations below that:
 127  *     (MTLTR_CACHED_DEST_WIDTH  &gt;= MTLTR_CACHE_CELL_WIDTH)  &amp;&amp;
 128  *     (MTLTR_CACHED_DEST_WIDTH  &gt;= MTLTR_NOCACHE_TILE_SIZE) &amp;&amp;
 129  *     (MTLTR_CACHED_DEST_HEIGHT &gt;= MTLTR_CACHE_CELL_HEIGHT) &amp;&amp;
 130  *     (MTLTR_CACHED_DEST_HEIGHT &gt;= MTLTR_NOCACHE_TILE_SIZE)
 131  */
 132 #define MTLTR_CACHED_DEST_WIDTH  512
 133 #define MTLTR_CACHED_DEST_HEIGHT (MTLTR_CACHE_CELL_HEIGHT * 2)
 134 
 135 /**
 136  * The handle to the &quot;cached destination&quot; texture object.
 137  */
 138 static GLuint cachedDestTextureID = 0;
 139 
 140 /**
 141  * The current bounds of the &quot;cached destination&quot; texture, in destination
 142  * coordinate space.  The width/height of these bounds will not exceed the
 143  * MTLTR_CACHED_DEST_WIDTH/HEIGHT values defined above.  These bounds are
 144  * only considered valid when the isCachedDestValid flag is JNI_TRUE.
 145  */
 146 static SurfaceDataBounds cachedDestBounds;
 147 
 148 /**
 149  * This flag indicates whether the &quot;cached destination&quot; texture contains
 150  * valid data.  This flag is reset to JNI_FALSE at the beginning of every
 151  * call to MTLTR_DrawGlyphList().  Once we copy valid destination data
 152  * into the cached texture, this flag is set to JNI_TRUE.  This way, we can
 153  * limit the number of times we need to copy destination data, which is a
 154  * very costly operation.
 155  */
 156 static jboolean isCachedDestValid = JNI_FALSE;
 157 
 158 /**
 159  * The bounds of the previously rendered LCD glyph, in destination
 160  * coordinate space.  We use these bounds to determine whether the glyph
 161  * currently being rendered overlaps the previously rendered glyph (i.e.
 162  * its bounding box intersects that of the previously rendered glyph).  If
 163  * so, we need to re-read the destination area associated with that previous
 164  * glyph so that we can correctly blend with the actual destination data.
 165  */
 166 static SurfaceDataBounds previousGlyphBounds;
 167 
 168 static struct TxtVertex txtVertices[6];
 169 static jint vertexCacheIndex = 0;
 170 static id&lt;MTLRenderCommandEncoder&gt; lcdCacheEncoder = nil;
 171 
 172 #define LCD_ADD_VERTEX(TX, TY, DX, DY, DZ) \
 173     do { \
 174         struct TxtVertex *v = &amp;txtVertices[vertexCacheIndex++]; \
 175         v-&gt;txtpos[0] = TX; \
 176         v-&gt;txtpos[1] = TY; \
 177         v-&gt;position[0]= DX; \
 178         v-&gt;position[1] = DY; \
 179     } while (0)
 180 
 181 #define LCD_ADD_TRIANGLES(TX1, TY1, TX2, TY2, DX1, DY1, DX2, DY2) \
 182     do { \
 183         LCD_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \
 184         LCD_ADD_VERTEX(TX2, TY1, DX2, DY1, 0); \
 185         LCD_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \
 186         LCD_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \
 187         LCD_ADD_VERTEX(TX1, TY2, DX1, DY2, 0); \
 188         LCD_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \
 189     } while (0)
 190 
 191 /**
 192  * Initializes the one glyph cache (texture and data structure).
 193  * If lcdCache is JNI_TRUE, the texture will contain RGB data,
 194  * otherwise we will simply store the grayscale/monochrome glyph images
 195  * as intensity values (which work well with the GL_MODULATE function).
 196  */
 197 static jboolean
 198 MTLTR_InitGlyphCache(MTLContext *mtlc, jboolean lcdCache)
 199 {
 200     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_InitGlyphCache&quot;);
 201     // TODO : Need to fix RGB order in case of LCD
 202     MTLPixelFormat pixelFormat = MTLPixelFormatBGRA8Unorm;
 203 
 204     MTLGlyphCacheInfo *gcinfo;
 205     // init glyph cache data structure
 206     gcinfo = MTLGlyphCache_Init(MTLTR_CACHE_WIDTH,
 207                                 MTLTR_CACHE_HEIGHT,
 208                                 MTLTR_CACHE_CELL_WIDTH,
 209                                 MTLTR_CACHE_CELL_HEIGHT,
 210                                 MTLVertexCache_FlushGlyphVertexCache);
 211 
 212     if (gcinfo == NULL) {
 213         J2dRlsTraceLn(J2D_TRACE_ERROR,
 214                       &quot;MTLTR_InitGlyphCache: could not init MTL glyph cache&quot;);
 215         return JNI_FALSE;
 216     }
 217 
 218     MTLTextureDescriptor *textureDescriptor =
 219         [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:pixelFormat
 220                                                             width:MTLTR_CACHE_WIDTH
 221                                                             height:MTLTR_CACHE_HEIGHT
 222                                                             mipmapped:NO];
 223 
 224     gcinfo-&gt;texture = [mtlc.device newTextureWithDescriptor:textureDescriptor];
 225 
 226     if (lcdCache) {
 227         glyphCacheLCD = gcinfo;
 228     } else {
 229         glyphCacheAA = gcinfo;
 230     }
 231 
 232     return JNI_TRUE;
 233 }
 234 
 235 id&lt;MTLTexture&gt;
 236 MTLTR_GetGlyphCacheTexture()
 237 {
 238     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_GetGlyphCacheTexture&quot;);
 239     if (glyphCacheAA != NULL) {
 240         return glyphCacheAA-&gt;texture;
 241     }
 242     return NULL;
 243 }
 244 
 245 /**
 246  * Adds the given glyph to the glyph cache (texture and data structure)
 247  * associated with the given MTLContext.
 248  */
 249 static void
 250 MTLTR_AddToGlyphCache(GlyphInfo *glyph, MTLContext *mtlc,
 251                       jboolean lcdCache)
 252 {
 253     MTLCacheCellInfo *ccinfo;
 254     MTLGlyphCacheInfo *gcinfo;
 255     jint w = glyph-&gt;width;
 256     jint h = glyph-&gt;height;
 257 
 258     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_AddToGlyphCache&quot;);
 259     if (!lcdCache) {
 260         gcinfo = glyphCacheAA;
 261     } else {
 262         gcinfo = glyphCacheLCD;
 263     }
 264 
 265     if ((gcinfo == NULL) || (glyph-&gt;image == NULL)) {
 266         return;
 267     }
 268 
 269     bool isCacheFull = MTLGlyphCache_IsCacheFull(gcinfo, glyph);
 270     if (isCacheFull) {
 271         MTLGlyphCache_Free(gcinfo);
 272         if (!lcdCache) {
 273             MTLTR_InitGlyphCache(mtlc, JNI_FALSE);
 274             gcinfo = glyphCacheAA;
 275         } else {
 276             MTLTR_InitGlyphCache(mtlc, JNI_TRUE);
 277             gcinfo = glyphCacheLCD;
 278         }
 279     }
 280     MTLGlyphCache_AddGlyph(gcinfo, glyph);
 281     ccinfo = (MTLCacheCellInfo *) glyph-&gt;cellInfo;
 282 
 283     if (ccinfo != NULL) {
 284         // store glyph image in texture cell
 285         MTLRegion region = {
 286                 {ccinfo-&gt;x,  ccinfo-&gt;y,   0},
 287                 {w, h, 1}
 288         };
 289         if (!lcdCache) {
 290             // Opengl uses GL_INTENSITY as internal pixel format to set number of
 291             // color components in the texture for grayscale texture.
 292             // It is mentioned that for GL_INTENSITY format,
 293             // the GL assembles it into an RGBA element by replicating the
 294             // intensity value three times for red, green, blue, and alpha.
 295             // To let metal behave the same for grayscale text,
 296             // we need to make sure we create BGRA component by replicating
 297             // graycale pixel value as in R=G=B=A=grayscale pixel value
 298 
 299             unsigned int imageBytes = w * h * 4;
 300             unsigned char imageData[imageBytes];
 301             memset(&amp;imageData, 0, sizeof(imageData));
 302 
 303             unsigned int dstindex = 0;
 304             for (int i = 0; i &lt; (w * h); i++) {
 305                 imageData[dstindex++] = glyph-&gt;image[i];
 306                 imageData[dstindex++] = glyph-&gt;image[i];
 307                 imageData[dstindex++] = glyph-&gt;image[i];
 308                 imageData[dstindex++] = glyph-&gt;image[i];
 309             }
 310             NSUInteger bytesPerRow = 4 * w;
 311             [gcinfo-&gt;texture replaceRegion:region
 312                              mipmapLevel:0
 313                              withBytes:imageData
 314                              bytesPerRow:bytesPerRow];
 315         } else {
 316             unsigned int imageBytes = w * h * 4;
 317             unsigned char imageData[imageBytes];
 318             memset(&amp;imageData, 0, sizeof(imageData));
 319 
 320             for (int i = 0; i &lt; h; i++) {
 321                 for (int j = 0; j &lt; w; j++) {
 322                     imageData[(i * w * 4) + j * 4] = glyph-&gt;image[(i * w * 3) + j * 3];
 323                     imageData[(i * w * 4) + j * 4 + 1] = glyph-&gt;image[(i * w * 3) + j * 3 + 1];
 324                     imageData[(i * w * 4) + j * 4 + 2] = glyph-&gt;image[(i * w * 3) + j * 3 + 2];
 325                     imageData[(i * w * 4) + j * 4 + 3] = 0xFF;
 326                 }
 327             }
 328 
 329             NSUInteger bytesPerRow = 4 * w;
 330             [gcinfo-&gt;texture replaceRegion:region
 331                              mipmapLevel:0
 332                              withBytes:imageData
 333                              bytesPerRow:bytesPerRow];
 334         }
 335     }
 336 }
 337 
 338 static MTLRenderPipelineDescriptor * templateLCDPipelineDesc = nil;
 339 
 340 /**
 341  * Enables the LCD text shader and updates any related state, such as the
 342  * gamma lookup table textures.
 343  */
 344 static jboolean
 345 MTLTR_EnableLCDGlyphModeState(id&lt;MTLRenderCommandEncoder&gt; encoder,
 346                               MTLContext *mtlc, 
 347                               MTLSDOps *dstOps,
 348                               jint contrast)
 349 {
 350     // create the LCD text shader, if necessary
 351     if (templateLCDPipelineDesc == nil) {
 352 
 353         MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];
 354         vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;
 355         vertDesc.attributes[VertexAttributePosition].offset = 0;
 356         vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;
 357         vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);
 358         vertDesc.layouts[MeshVertexBuffer].stepRate = 1;
 359         vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 360 
 361         templateLCDPipelineDesc = [MTLRenderPipelineDescriptor new];
 362         templateLCDPipelineDesc.sampleCount = 1;
 363         templateLCDPipelineDesc.vertexDescriptor = vertDesc;
 364         templateLCDPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;
 365         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;
 366         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);
 367         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;
 368         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);
 369         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;
 370         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 371         templateLCDPipelineDesc.label = @&quot;template_lcd&quot;;
 372     }
 373 
 374     id&lt;MTLRenderPipelineState&gt; pipelineState =
 375                 [mtlc.pipelineStateStorage
 376                     getPipelineState:templateLCDPipelineDesc
 377                     vertexShaderId:@&quot;vert_txt&quot;
 378                     fragmentShaderId:@&quot;lcd_color&quot;
 379                    ];
 380 
 381     [encoder setRenderPipelineState:pipelineState];
 382 
 383     // update the current color settings
 384     double gamma = ((double)contrast) / 100.0;
 385     double invgamma = 1.0/gamma;
 386     jfloat radj, gadj, badj;
 387     jfloat clr[4];
 388     jint col = [mtlc.paint getColor];
 389 
 390     J2dTraceLn2(J2D_TRACE_INFO, &quot;primary color %x, contrast %d&quot;, col, contrast);
 391     J2dTraceLn2(J2D_TRACE_INFO, &quot;gamma %f, invgamma %f&quot;, gamma, invgamma);
 392 
 393     clr[0] = ((col &gt;&gt; 16) &amp; 0xFF)/255.0f;
 394     clr[1] = ((col &gt;&gt; 8) &amp; 0xFF)/255.0f;
 395     clr[2] = ((col) &amp; 0xFF)/255.0f;
 396 
 397     // gamma adjust the primary color
 398     radj = (float)pow(clr[0], gamma);
 399     gadj = (float)pow(clr[1], gamma);
 400     badj = (float)pow(clr[2], gamma);
 401 
 402     struct LCDFrameUniforms uf = {
 403             {radj, gadj, badj},
 404             {gamma, gamma, gamma},
 405             {invgamma, invgamma, invgamma}};
 406     [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
 407 
 408     return JNI_TRUE;
 409 }
 410 
 411 static jboolean
 412 MTLTR_SetLCDCachePipelineState(MTLContext *mtlc)
 413 {
 414     if (templateLCDPipelineDesc == nil) {
 415 
 416         MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];
 417         vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;
 418         vertDesc.attributes[VertexAttributePosition].offset = 0;
 419         vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;
 420         vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);
 421         vertDesc.layouts[MeshVertexBuffer].stepRate = 1;
 422         vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 423 
 424         templateLCDPipelineDesc = [MTLRenderPipelineDescriptor new];
 425         templateLCDPipelineDesc.sampleCount = 1;
 426         templateLCDPipelineDesc.vertexDescriptor = vertDesc;
 427         templateLCDPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;
 428         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;
 429         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);
 430         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;
 431         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);
 432         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;
 433         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 434         templateLCDPipelineDesc.label = @&quot;template_lcd&quot;;
 435     }
 436 
 437     id&lt;MTLRenderPipelineState&gt; pipelineState =
 438                 [mtlc.pipelineStateStorage
 439                     getPipelineState:templateLCDPipelineDesc
 440                     vertexShaderId:@&quot;vert_txt&quot;
 441                     fragmentShaderId:@&quot;lcd_color&quot;
 442                    ];
 443 
 444     [lcdCacheEncoder setRenderPipelineState:pipelineState];
 445     return JNI_TRUE;
 446 }
 447 
 448 static jboolean
 449 MTLTR_SetLCDContrast(MTLContext *mtlc,
 450                      jint contrast)
 451 {
 452     // update the current color settings
 453     double gamma = ((double)contrast) / 100.0;
 454     double invgamma = 1.0/gamma;
 455     jfloat radj, gadj, badj;
 456     jfloat clr[4];
 457     jint col = [mtlc.paint getColor];
 458 
 459     J2dTraceLn2(J2D_TRACE_INFO, &quot;primary color %x, contrast %d&quot;, col, contrast);
 460     J2dTraceLn2(J2D_TRACE_INFO, &quot;gamma %f, invgamma %f&quot;, gamma, invgamma);
 461 
 462     clr[0] = ((col &gt;&gt; 16) &amp; 0xFF)/255.0f;
 463     clr[1] = ((col &gt;&gt; 8) &amp; 0xFF)/255.0f;
 464     clr[2] = ((col) &amp; 0xFF)/255.0f;
 465 
 466     // gamma adjust the primary color
 467     radj = (float)pow(clr[0], gamma);
 468     gadj = (float)pow(clr[1], gamma);
 469     badj = (float)pow(clr[2], gamma);
 470 
 471     struct LCDFrameUniforms uf = {
 472             {radj, gadj, badj},
 473             {gamma, gamma, gamma},
 474             {invgamma, invgamma, invgamma}};
 475     [lcdCacheEncoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
 476     return JNI_TRUE;
 477 }
 478 
 479 void
 480 MTLTR_EnableGlyphVertexCache(MTLContext *mtlc, BMTLSDOps *dstOps)
 481 {
 482 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_EnableGlyphVertexCache&quot;);
 483 
 484     if (!MTLVertexCache_InitVertexCache()) {
 485         return;
 486     }
 487 
 488     if (glyphCacheAA == NULL) {
 489         if (!MTLTR_InitGlyphCache(mtlc, JNI_FALSE)) {
 490             return;
 491         }
 492     }
 493     MTLVertexCache_CreateSamplingEncoder(mtlc, dstOps);
 494 }
 495 
 496 void
 497 MTLTR_DisableGlyphVertexCache(MTLContext *mtlc)
 498 {
 499     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DisableGlyphVertexCache&quot;);
 500     MTLVertexCache_FlushGlyphVertexCache();
 501     MTLVertexCache_RestoreColorState(mtlc);
 502     MTLVertexCache_FreeVertexCache();
 503 }
 504 
 505 /**
 506  * Disables any pending state associated with the current &quot;glyph mode&quot;.
 507  */
 508 void
 509 MTLTR_DisableGlyphModeState()
 510 {
 511     // TODO : This is similar to OpenGL implementation
 512     // When LCD implementation is done weshould make
 513     // more changes.
 514     J2dTraceLn1(J2D_TRACE_VERBOSE,
 515                 &quot;MTLTR_DisableGlyphModeState: mode=%d&quot;, glyphMode);
 516     switch (glyphMode) {
 517     case MODE_NO_CACHE_LCD:
 518         // TODO : Along with LCD implementation
 519         // changes needs to be made
 520     case MODE_USE_CACHE_LCD:
 521         // TODO : Along with LCD implementation
 522         // changes needs to be made
 523         break;
 524     case MODE_NO_CACHE_GRAY:
 525     case MODE_USE_CACHE_GRAY:
 526     case MODE_NOT_INITED:
 527     default:
 528         break;
 529     }
 530 }
 531 
 532 static jboolean
 533 MTLTR_DrawGrayscaleGlyphViaCache(MTLContext *mtlc,
 534                                  GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)
 535 {
 536     MTLCacheCellInfo *cell;
 537     jfloat x1, y1, x2, y2;
 538 
 539     if (glyphMode != MODE_USE_CACHE_GRAY) {
 540         if (glyphMode == MODE_NO_CACHE_GRAY) {
 541             MTLVertexCache_DisableMaskCache(mtlc);
 542         } else if (glyphMode == MODE_USE_CACHE_LCD) {
 543             [mtlc.encoderManager endEncoder];
 544             lcdCacheEncoder = nil;
 545         }
 546         MTLTR_EnableGlyphVertexCache(mtlc, dstOps);
 547         glyphMode = MODE_USE_CACHE_GRAY;
 548     }
 549 
 550     if (ginfo-&gt;cellInfo == NULL) {
 551         // attempt to add glyph to accelerated glyph cache
 552         MTLTR_AddToGlyphCache(ginfo, mtlc, JNI_FALSE);
 553 
 554         if (ginfo-&gt;cellInfo == NULL) {
 555             // we&#39;ll just no-op in the rare case that the cell is NULL
 556             return JNI_TRUE;
 557         }
 558     }
 559 
 560     cell = (MTLCacheCellInfo *) (ginfo-&gt;cellInfo);
 561     cell-&gt;timesRendered++;
 562 
 563     x1 = (jfloat)x;
 564     y1 = (jfloat)y;
 565     x2 = x1 + ginfo-&gt;width;
 566     y2 = y1 + ginfo-&gt;height;
 567 
 568     MTLVertexCache_AddGlyphQuad(mtlc,
 569                                 cell-&gt;tx1, cell-&gt;ty1,
 570                                 cell-&gt;tx2, cell-&gt;ty2,
 571                                 x1, y1, x2, y2);
 572 
 573     return JNI_TRUE;
 574 }
 575 
 576 /**
 577  * Evaluates to true if the rectangle defined by gx1/gy1/gx2/gy2 is
 578  * inside outerBounds.
 579  */
 580 #define INSIDE(gx1, gy1, gx2, gy2, outerBounds) \
 581     (((gx1) &gt;= outerBounds.x1) &amp;&amp; ((gy1) &gt;= outerBounds.y1) &amp;&amp; \
 582      ((gx2) &lt;= outerBounds.x2) &amp;&amp; ((gy2) &lt;= outerBounds.y2))
 583 
 584 /**
 585  * Evaluates to true if the rectangle defined by gx1/gy1/gx2/gy2 intersects
 586  * the rectangle defined by bounds.
 587  */
 588 #define INTERSECTS(gx1, gy1, gx2, gy2, bounds) \
 589     ((bounds.x2 &gt; (gx1)) &amp;&amp; (bounds.y2 &gt; (gy1)) &amp;&amp; \
 590      (bounds.x1 &lt; (gx2)) &amp;&amp; (bounds.y1 &lt; (gy2)))
 591 
 592 /**
 593  * This method checks to see if the given LCD glyph bounds fall within the
 594  * cached destination texture bounds.  If so, this method can return
 595  * immediately.  If not, this method will copy a chunk of framebuffer data
 596  * into the cached destination texture and then update the current cached
 597  * destination bounds before returning.
 598  */
 599 static void
 600 MTLTR_UpdateCachedDestination(MTLSDOps *dstOps, GlyphInfo *ginfo,
 601                               jint gx1, jint gy1, jint gx2, jint gy2,
 602                               jint glyphIndex, jint totalGlyphs)
 603 {
 604     //TODO
 605 }
 606 
 607 static jboolean
 608 MTLTR_DrawLCDGlyphViaCache(MTLContext *mtlc, BMTLSDOps *dstOps,
 609                            GlyphInfo *ginfo, jint x, jint y,
 610                            jint rowBytesOffset,
 611                            jboolean rgbOrder, jint contrast,
 612                            id&lt;MTLTexture&gt; dstTexture)
 613 {
 614     CacheCellInfo *cell;
 615     jfloat tx1, ty1, tx2, ty2;
 616     jint w = ginfo-&gt;width;
 617     jint h = ginfo-&gt;height;
 618 
 619     if (glyphMode != MODE_USE_CACHE_LCD) {
 620         if (glyphMode == MODE_NO_CACHE_GRAY) {
 621             MTLVertexCache_DisableMaskCache(mtlc);
 622         } else if (glyphMode == MODE_USE_CACHE_GRAY) {
 623             MTLTR_DisableGlyphVertexCache(mtlc);
 624         }
 625 
 626         if (glyphCacheLCD == NULL) {
 627             if (!MTLTR_InitGlyphCache(mtlc, JNI_TRUE)) {
 628                 return JNI_FALSE;
 629             }
 630         }
 631         if (lcdCacheEncoder == nil) {
 632             lcdCacheEncoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];
 633             MTLTR_SetLCDCachePipelineState(mtlc);
 634         }
 635         if (rgbOrder != lastRGBOrder) {
 636             // need to invalidate the cache in this case; see comments
 637             // for lastRGBOrder above
 638             MTLGlyphCache_Invalidate(glyphCacheLCD);
 639             lastRGBOrder = rgbOrder;
 640         }
 641 
 642         glyphMode = MODE_USE_CACHE_LCD;
 643     }
 644 
 645     if (ginfo-&gt;cellInfo == NULL) {
 646         // attempt to add glyph to accelerated glyph cache
 647         // TODO : Handle RGB order
 648         MTLTR_AddToGlyphCache(ginfo, mtlc, JNI_TRUE);
 649 
 650         if (ginfo-&gt;cellInfo == NULL) {
 651             // we&#39;ll just no-op in the rare case that the cell is NULL
 652             return JNI_TRUE;
 653         }
 654     }
 655     cell = (CacheCellInfo *) (ginfo-&gt;cellInfo);
 656     cell-&gt;timesRendered++;
 657 
 658     MTLTR_SetLCDContrast(mtlc, contrast);
 659     tx1 = cell-&gt;tx1;
 660     ty1 = cell-&gt;ty1;
 661     tx2 = cell-&gt;tx2;
 662     ty2 = cell-&gt;ty2;
 663 
 664     J2dTraceLn4(J2D_TRACE_INFO, &quot;tx1 %f, ty1 %f, tx2 %f, ty2 %f&quot;, tx1, ty1, tx2, ty2);
 665     J2dTraceLn2(J2D_TRACE_INFO, &quot;textureWidth %d textureHeight %d&quot;, dstOps-&gt;textureWidth, dstOps-&gt;textureHeight);
 666 
 667     LCD_ADD_TRIANGLES(tx1, ty1, tx2, ty2, x, y, x+w, y+h);
 668 
 669     [lcdCacheEncoder setVertexBytes:txtVertices length:sizeof(txtVertices) atIndex:MeshVertexBuffer];
 670     [lcdCacheEncoder setFragmentTexture:glyphCacheLCD-&gt;texture atIndex:0];
 671     [lcdCacheEncoder setFragmentTexture:dstOps-&gt;pTexture atIndex:1];
 672 
 673     [lcdCacheEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
 674 
 675     vertexCacheIndex = 0;
 676 
 677     return JNI_TRUE;
 678 }
 679 
 680 static jboolean
 681 MTLTR_DrawGrayscaleGlyphNoCache(MTLContext *mtlc,
 682                                 GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)
 683 {
 684     jint tw, th;
 685     jint sx, sy, sw, sh;
 686     jint x0;
 687     jint w = ginfo-&gt;width;
 688     jint h = ginfo-&gt;height;
 689 
 690     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGrayscaleGlyphNoCache&quot;);
 691     if (glyphMode != MODE_NO_CACHE_GRAY) {
 692         if (glyphMode == MODE_USE_CACHE_GRAY) {
 693             MTLTR_DisableGlyphVertexCache(mtlc);
 694         } else if (glyphMode == MODE_USE_CACHE_LCD) {
 695             [mtlc.encoderManager endEncoder];
 696             lcdCacheEncoder = nil;
 697         }
 698         MTLVertexCache_EnableMaskCache(mtlc, dstOps);
 699         glyphMode = MODE_NO_CACHE_GRAY;
 700     }
 701 
 702     x0 = x;
 703     tw = MTLVC_MASK_CACHE_TILE_WIDTH;
 704     th = MTLVC_MASK_CACHE_TILE_HEIGHT;
 705 
 706     for (sy = 0; sy &lt; h; sy += th, y += th) {
 707         x = x0;
 708         sh = ((sy + th) &gt; h) ? (h - sy) : th;
 709 
 710         for (sx = 0; sx &lt; w; sx += tw, x += tw) {
 711             sw = ((sx + tw) &gt; w) ? (w - sx) : tw;
 712 
 713             J2dTraceLn7(J2D_TRACE_INFO, &quot;sx = %d sy = %d x = %d y = %d sw = %d sh = %d w = %d&quot;, sx, sy, x, y, sw, sh, w);
 714             MTLVertexCache_AddMaskQuad(mtlc,
 715                                        sx, sy, x, y, sw, sh,
 716                                        w, ginfo-&gt;image,
 717                                        dstOps,
 718                                        ginfo-&gt;width);
 719         }
 720     }
 721 
 722     return JNI_TRUE;
 723 }
 724 
 725 
 726 static jboolean
 727 MTLTR_DrawLCDGlyphNoCache(MTLContext *mtlc, BMTLSDOps *dstOps,
 728                           GlyphInfo *ginfo, jint x, jint y,
 729                           jint rowBytesOffset,
 730                           jboolean rgbOrder, jint contrast,
 731                           id&lt;MTLTexture&gt; dstTexture)
 732 {
 733     jfloat tx1, ty1, tx2, ty2;
 734     jfloat dtx1=0, dty1=0, dtx2=0, dty2=0;
 735     jint tw, th;
 736     jint sx=0, sy=0, sw=0, sh=0, dxadj=0, dyadj=0;
 737     jint x0;
 738     jint w = ginfo-&gt;width;
 739     jint h = ginfo-&gt;height;
 740     id&lt;MTLTexture&gt; blitTexture = nil;
 741 
 742     J2dTraceLn2(J2D_TRACE_INFO, &quot;MTLTR_DrawLCDGlyphNoCache x %d, y%d&quot;, x, y);
 743     J2dTraceLn3(J2D_TRACE_INFO, &quot;MTLTR_DrawLCDGlyphNoCache rowBytesOffset=%d, rgbOrder=%d, contrast=%d&quot;, rowBytesOffset, rgbOrder, contrast);
 744 
 745 
 746     id&lt;MTLRenderCommandEncoder&gt; encoder = nil;
 747 
 748     MTLTextureDescriptor *textureDescriptor =
 749         [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatBGRA8Unorm
 750                                                             width:w
 751                                                             height:h
 752                                                             mipmapped:NO];
 753 
 754     blitTexture = [mtlc.device newTextureWithDescriptor:textureDescriptor];
<a name="1" id="anc1"></a><span class="line-removed"> 755     [textureDescriptor release];</span>
 756 
 757     if (glyphMode != MODE_NO_CACHE_LCD) {
 758         if (glyphMode == MODE_NO_CACHE_GRAY) {
 759             MTLVertexCache_DisableMaskCache(mtlc);
 760         } else if (glyphMode == MODE_USE_CACHE_GRAY) {
 761             MTLTR_DisableGlyphVertexCache(mtlc);
 762         } else if (glyphMode == MODE_USE_CACHE_LCD) {
 763             [mtlc.encoderManager endEncoder];
 764             lcdCacheEncoder = nil;
 765         }
 766 
 767         if (blitTexture == nil) {
 768             J2dTraceLn(J2D_TRACE_ERROR, &quot;can&#39;t obtain temporary texture object from pool&quot;);
 769             return JNI_FALSE;
 770         }
 771 
 772 
 773         glyphMode = MODE_NO_CACHE_LCD;
 774     }
 775     encoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];
 776     if (!MTLTR_EnableLCDGlyphModeState(encoder, mtlc, dstOps,contrast))
 777     {
 778         return JNI_FALSE;
 779     }
 780 
 781     x0 = x;
 782     tx1 = 0.0f;
 783     ty1 = 0.0f;
 784     dtx1 = 0.0f;
 785     dty2 = 0.0f;
 786     tw = MTLTR_NOCACHE_TILE_SIZE;
 787     th = MTLTR_NOCACHE_TILE_SIZE;
 788 
 789     unsigned int imageBytes = w * h *4;
 790     unsigned char imageData[imageBytes];
 791     memset(&amp;imageData, 0, sizeof(imageData));
 792 
 793     for (int i = 0; i &lt; h; i++) {
 794         for (int j = 0; j &lt; w; j++) {
 795             imageData[(i * w * 4) + j * 4] = ginfo-&gt;image[(i * w * 3) + j * 3];
 796             imageData[(i * w * 4) + j * 4 + 1] = ginfo-&gt;image[(i * w * 3) + j * 3 + 1];
 797             imageData[(i * w * 4) + j * 4 + 2] = ginfo-&gt;image[(i * w * 3) + j * 3 + 2];
 798             imageData[(i * w * 4) + j * 4 + 3] = 0xFF;
 799         }
 800     }
 801 
 802     // copy LCD mask into glyph texture tile
 803     MTLRegion region = MTLRegionMake2D(0, 0, w, h);
 804 
 805     NSUInteger bytesPerRow = 4 * ginfo-&gt;width;
 806     [blitTexture replaceRegion:region
 807                  mipmapLevel:0
 808                  withBytes:imageData
 809                  bytesPerRow:bytesPerRow];
 810 
 811     J2dTraceLn7(J2D_TRACE_INFO, &quot;sx = %d sy = %d x = %d y = %d sw = %d sh = %d w = %d&quot;, sx, sy, x, y, sw, sh, w);
 812 
 813 
 814     // update the lower-right glyph texture coordinates
 815     tx2 = 1.0f;
 816     ty2 = 1.0f;
 817 
 818     J2dTraceLn5(J2D_TRACE_INFO, &quot;xOffset %d yOffset %d, dxadj %d, dyadj %d dstOps-&gt;height %d&quot;, dstOps-&gt;xOffset, dstOps-&gt;yOffset, dxadj, dyadj, dstOps-&gt;height);
 819 
 820     dtx1 = ((jfloat)dxadj) / dstOps-&gt;textureWidth;
 821     dtx2 = ((float)dxadj + sw) / dstOps-&gt;textureWidth;
 822   
 823     dty1 = ((jfloat)dyadj + sh) / dstOps-&gt;textureHeight;
 824     dty2 = ((jfloat)dyadj) / dstOps-&gt;textureHeight;
 825 
 826     J2dTraceLn4(J2D_TRACE_INFO, &quot;tx1 %f, ty1 %f, tx2 %f, ty2 %f&quot;, tx1, ty1, tx2, ty2);
 827     J2dTraceLn2(J2D_TRACE_INFO, &quot;textureWidth %d textureHeight %d&quot;, dstOps-&gt;textureWidth, dstOps-&gt;textureHeight);
 828     J2dTraceLn4(J2D_TRACE_INFO, &quot;dtx1 %f, dty1 %f, dtx2 %f, dty2 %f&quot;, dtx1, dty1, dtx2, dty2);
 829 
 830     LCD_ADD_TRIANGLES(tx1, ty1, tx2, ty2, x, y, x+w, y+h);
 831 
 832     [encoder setVertexBytes:txtVertices length:sizeof(txtVertices) atIndex:MeshVertexBuffer];
 833     [encoder setFragmentTexture:blitTexture atIndex:0];
 834     [encoder setFragmentTexture:dstOps-&gt;pTexture atIndex:1];
 835 
 836     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
 837 
 838     vertexCacheIndex = 0;
 839     [mtlc.encoderManager endEncoder];
 840     [blitTexture release];
 841 
 842     MTLCommandBufferWrapper* cbwrapper = [mtlc pullCommandBufferWrapper];
 843 
 844     id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
 845     [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
 846         [cbwrapper release];
 847     }];
 848 
 849     [commandbuf commit];
 850     [commandbuf waitUntilCompleted];
 851 
 852     return JNI_TRUE;
 853 }
 854 
 855 // see DrawGlyphList.c for more on this macro...
 856 #define FLOOR_ASSIGN(l, r) \
 857     if ((r)&lt;0) (l) = ((int)floor(r)); else (l) = ((int)(r))
 858 
 859 void
 860 MTLTR_DrawGlyphList(JNIEnv *env, MTLContext *mtlc, BMTLSDOps *dstOps,
 861                     jint totalGlyphs, jboolean usePositions,
 862                     jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,
 863                     jfloat glyphListOrigX, jfloat glyphListOrigY,
 864                     unsigned char *images, unsigned char *positions)
 865 {
 866     int glyphCounter;
 867 
 868     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList&quot;);
 869 
 870     RETURN_IF_NULL(mtlc);
 871     RETURN_IF_NULL(dstOps);
 872     RETURN_IF_NULL(images);
 873     if (usePositions) {
 874         RETURN_IF_NULL(positions);
 875     }
 876 
 877     glyphMode = MODE_NOT_INITED;
 878     isCachedDestValid = JNI_FALSE;
 879     J2dTraceLn1(J2D_TRACE_INFO, &quot;totalGlyphs = %d&quot;, totalGlyphs);
 880 
 881     for (glyphCounter = 0; glyphCounter &lt; totalGlyphs; glyphCounter++) {
 882         J2dTraceLn(J2D_TRACE_INFO, &quot;Entered for loop for glyph list&quot;);
 883         jint x, y;
 884         jfloat glyphx, glyphy;
 885         jboolean grayscale, ok;
 886         GlyphInfo *ginfo = (GlyphInfo *)jlong_to_ptr(NEXT_LONG(images));
 887 
 888         if (ginfo == NULL) {
 889             // this shouldn&#39;t happen, but if it does we&#39;ll just break out...
 890             J2dRlsTraceLn(J2D_TRACE_ERROR,
 891                           &quot;MTLTR_DrawGlyphList: glyph info is null&quot;);
 892             break;
 893         }
 894 
 895         grayscale = (ginfo-&gt;rowBytes == ginfo-&gt;width);
 896 
 897         if (usePositions) {
 898             jfloat posx = NEXT_FLOAT(positions);
 899             jfloat posy = NEXT_FLOAT(positions);
 900             glyphx = glyphListOrigX + posx + ginfo-&gt;topLeftX;
 901             glyphy = glyphListOrigY + posy + ginfo-&gt;topLeftY;
 902             FLOOR_ASSIGN(x, glyphx);
 903             FLOOR_ASSIGN(y, glyphy);
 904         } else {
 905             glyphx = glyphListOrigX + ginfo-&gt;topLeftX;
 906             glyphy = glyphListOrigY + ginfo-&gt;topLeftY;
 907             FLOOR_ASSIGN(x, glyphx);
 908             FLOOR_ASSIGN(y, glyphy);
 909             glyphListOrigX += ginfo-&gt;advanceX;
 910             glyphListOrigY += ginfo-&gt;advanceY;
 911         }
 912 
 913         if (ginfo-&gt;image == NULL) {
 914             J2dTraceLn(J2D_TRACE_INFO, &quot;Glyph image is null&quot;);
 915             continue;
 916         }
 917 
 918         J2dTraceLn2(J2D_TRACE_INFO, &quot;Glyph width = %d height = %d&quot;, ginfo-&gt;width, ginfo-&gt;height);
 919         J2dTraceLn1(J2D_TRACE_INFO, &quot;rowBytes = %d&quot;, ginfo-&gt;rowBytes);
 920         if (grayscale) {
 921             // grayscale or monochrome glyph data
 922             if (ginfo-&gt;width &lt;= MTLTR_CACHE_CELL_WIDTH &amp;&amp;
 923                 ginfo-&gt;height &lt;= MTLTR_CACHE_CELL_HEIGHT)
 924             {
 925                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList Grayscale cache&quot;);
 926                 ok = MTLTR_DrawGrayscaleGlyphViaCache(mtlc, ginfo, x, y, dstOps);
 927             } else {
 928                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList Grayscale no cache&quot;);
 929                 ok = MTLTR_DrawGrayscaleGlyphNoCache(mtlc, ginfo, x, y, dstOps);
 930             }
 931         } else {
 932             void* dstTexture = dstOps-&gt;textureLCD;
 933 
 934             // LCD-optimized glyph data
 935             jint rowBytesOffset = 0;
 936 
 937             if (subPixPos) {
 938                 jint frac = (jint)((glyphx - x) * 3);
 939                 if (frac != 0) {
 940                     rowBytesOffset = 3 - frac;
 941                     x += 1;
 942                 }
 943             }
 944 
 945             if (rowBytesOffset == 0 &amp;&amp;
 946                 ginfo-&gt;width &lt;= MTLTR_CACHE_CELL_WIDTH &amp;&amp;
 947                 ginfo-&gt;height &lt;= MTLTR_CACHE_CELL_HEIGHT)
 948             {
 949                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList LCD cache&quot;);
 950                 ok = MTLTR_DrawLCDGlyphViaCache(mtlc, dstOps,
 951                                                 ginfo, x, y,
 952                                                 rowBytesOffset,
 953                                                 rgbOrder, lcdContrast,
 954                                                 dstTexture);
 955             } else {
 956                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList LCD no cache&quot;);
 957                 ok = MTLTR_DrawLCDGlyphNoCache(mtlc, dstOps,
 958                                                ginfo, x, y,
 959                                                rowBytesOffset,
 960                                                rgbOrder, lcdContrast,
 961                                                dstTexture);
 962             }
 963         }
 964 
 965         if (!ok) {
 966             break;
 967         }
 968     }
 969     /*
 970      * Only in case of grayscale text drawing we need to flush
 971      * cache. Still in case of LCD we are not using any intermediate
 972      * cache.
 973      */
 974     if (glyphMode == MODE_NO_CACHE_GRAY) {
 975         MTLVertexCache_DisableMaskCache(mtlc);
 976     } else if (glyphMode == MODE_USE_CACHE_GRAY) {
 977         MTLTR_DisableGlyphVertexCache(mtlc);
 978     } else if (glyphMode == MODE_USE_CACHE_LCD) {
 979         [mtlc.encoderManager endEncoder];
 980         lcdCacheEncoder = nil;
 981     }
 982 }
 983 
 984 JNIEXPORT void JNICALL
 985 Java_sun_java2d_metal_MTLTextRenderer_drawGlyphList
 986     (JNIEnv *env, jobject self,
 987      jint numGlyphs, jboolean usePositions,
 988      jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,
 989      jfloat glyphListOrigX, jfloat glyphListOrigY,
 990      jlongArray imgArray, jfloatArray posArray)
 991 {
 992     unsigned char *images;
 993 
 994     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTextRenderer_drawGlyphList&quot;);
 995 
 996     images = (unsigned char *)
 997         (*env)-&gt;GetPrimitiveArrayCritical(env, imgArray, NULL);
 998     if (images != NULL) {
 999         MTLContext *mtlc = MTLRenderQueue_GetCurrentContext();
1000         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
1001 
1002         if (usePositions) {
1003             unsigned char *positions = (unsigned char *)
1004                 (*env)-&gt;GetPrimitiveArrayCritical(env, posArray, NULL);
1005             if (positions != NULL) {
1006                 MTLTR_DrawGlyphList(env, mtlc, dstOps,
1007                                     numGlyphs, usePositions,
1008                                     subPixPos, rgbOrder, lcdContrast,
1009                                     glyphListOrigX, glyphListOrigY,
1010                                     images, positions);
1011                 (*env)-&gt;ReleasePrimitiveArrayCritical(env, posArray,
1012                                                       positions, JNI_ABORT);
1013             }
1014         } else {
1015             MTLTR_DrawGlyphList(env, mtlc, dstOps,
1016                                 numGlyphs, usePositions,
1017                                 subPixPos, rgbOrder, lcdContrast,
1018                                 glyphListOrigX, glyphListOrigY,
1019                                 images, NULL);
1020         }
1021 
1022         (*env)-&gt;ReleasePrimitiveArrayCritical(env, imgArray,
1023                                               images, JNI_ABORT);
1024     }
1025 }
1026 
1027 #endif /* !HEADLESS */
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>