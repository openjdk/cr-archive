<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &quot;MTLPaints.h&quot;
 29 
 30 #include &quot;MTLClip.h&quot;
 31 
 32 #include &quot;common.h&quot;
 33 
 34 #include &quot;sun_java2d_SunGraphics2D.h&quot;
 35 #include &quot;sun_java2d_pipe_BufferedPaints.h&quot;
 36 #import &quot;MTLComposite.h&quot;
 37 #import &quot;MTLBufImgOps.h&quot;
 38 #include &quot;MTLRenderQueue.h&quot;
 39 
 40 #define RGBA_TO_V4(c)              \
 41 {                                  \
 42     (((c) &gt;&gt; 16) &amp; (0xFF))/255.0f, \
 43     (((c) &gt;&gt; 8) &amp; 0xFF)/255.0f,    \
 44     ((c) &amp; 0xFF)/255.0f,           \
 45     (((c) &gt;&gt; 24) &amp; 0xFF)/255.0f    \
 46 }
 47 
 48 #define FLOAT_ARR_TO_V4(p) \
 49 {                      \
 50     p[0], \
 51     p[1], \
 52     p[2], \
 53     p[3]  \
 54 }
 55 
 56 static MTLRenderPipelineDescriptor * templateRenderPipelineDesc = nil;
 57 static MTLRenderPipelineDescriptor * templateTexturePipelineDesc = nil;
 58 static MTLRenderPipelineDescriptor * templateAATexturePipelineDesc = nil;
 59 
 60 static void initTemplatePipelineDescriptors() {
 61     if (templateRenderPipelineDesc != nil &amp;&amp; templateTexturePipelineDesc != nil)
 62         return;
 63 
 64     MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];
 65     vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;
 66     vertDesc.attributes[VertexAttributePosition].offset = 0;
 67     vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;
 68     vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);
 69     vertDesc.layouts[MeshVertexBuffer].stepRate = 1;
 70     vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 71 
 72     templateRenderPipelineDesc = [MTLRenderPipelineDescriptor new];
 73     templateRenderPipelineDesc.sampleCount = 1;
 74     templateRenderPipelineDesc.vertexDescriptor = vertDesc;
 75     templateRenderPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;
 76     templateRenderPipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorOne;
 77     templateRenderPipelineDesc.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactorOne;
 78     templateRenderPipelineDesc.colorAttachments[0].destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
 79     templateRenderPipelineDesc.colorAttachments[0].destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
 80     templateRenderPipelineDesc.label = @&quot;template_render&quot;;
 81 
 82     templateTexturePipelineDesc = [templateRenderPipelineDesc copy];
 83     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;
 84     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);
 85     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;
 86     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);
 87     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;
 88     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 89     templateTexturePipelineDesc.label = @&quot;template_texture&quot;;
 90 
 91     templateAATexturePipelineDesc = [templateTexturePipelineDesc copy];
 92     templateAATexturePipelineDesc.label = @&quot;template_aa_texture&quot;;
 93 
 94 }
 95 
 96 @implementation MTLPaint {
 97     // TODO: remove paintState, split into heirarchy of Paint-objects (i.e. PaintColor, PaintGrad, e.t.c)
 98     jint          _paintState;
 99 
100     // color-mode
101     jint          _color;
102 
103     // lin-grad-mode
104     jdouble       _p0;
105     jdouble       _p1;
106     jdouble       _p3;
107     jboolean      _cyclic;
108     jint          _pixel1;
109     jint          _pixel2;
110     jboolean      _useMask;
111 
112     // texture paint
113     id&lt;MTLTexture&gt; _paintTexture;
114     struct AnchorData _anchor;
115 }
116 
117 - (id)init {
118     self = [super init];
119     if (self) {
120         _paintState = sun_java2d_SunGraphics2D_PAINT_UNDEFINED;
121     }
122     return self;
123 }
124 
125 - (BOOL)isEqual:(MTLPaint *)other {
126     if (self == other)
127         return YES;
128     if (_paintState == sun_java2d_SunGraphics2D_PAINT_UNDEFINED)
129         return _paintState == other-&gt;_paintState;
130     if (_paintState != other-&gt;_paintState)
131         return NO;
132     if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
133         return _p0 == other-&gt;_p0
134                &amp;&amp; _p1 == other-&gt;_p1
135                &amp;&amp; _p3 == other-&gt;_p3
136                &amp;&amp; _pixel1 == other-&gt;_pixel1
137                &amp;&amp; _pixel2 == other-&gt;_pixel2;
138     }
139     if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
140         return _color == other-&gt;_color;
141     }
142     if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
143         return _paintTexture == other-&gt;_paintTexture
144                &amp;&amp; _anchor.xParams[0] == other-&gt;_anchor.xParams[0]
145                &amp;&amp; _anchor.xParams[1] == other-&gt;_anchor.xParams[1]
146                &amp;&amp; _anchor.xParams[2] == other-&gt;_anchor.xParams[2]
147                &amp;&amp; _anchor.yParams[0] == other-&gt;_anchor.yParams[0]
148                &amp;&amp; _anchor.yParams[1] == other-&gt;_anchor.yParams[1]
149                &amp;&amp; _anchor.yParams[2] == other-&gt;_anchor.yParams[2];
150     }
151 
152     J2dTraceLn1(J2D_TRACE_ERROR, &quot;Unimplemented paint mode %d&quot;, _paintState);
153     return NO;
154 }
155 
156 - (void)copyFrom:(MTLPaint *)other {
157     _paintState = other-&gt;_paintState;
158     if (other-&gt;_paintState == sun_java2d_SunGraphics2D_PAINT_UNDEFINED)
159         return;
160 
161     if (other-&gt;_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
162         _p0 = other-&gt;_p0;
163         _p1 = other-&gt;_p1;
164         _p3 = other-&gt;_p3;
165         _pixel1 = other-&gt;_pixel1;
166         _pixel2 = other-&gt;_pixel2;
167         return;
168     }
169     if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
170         _color = other-&gt;_color;
171         return;
172     }
173 
174     if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
175         _color = other-&gt;_color;
176         _paintTexture = other-&gt;_paintTexture;
177         _anchor = other-&gt;_anchor;
178         return;
179     }
180 
181     J2dTraceLn1(J2D_TRACE_ERROR, &quot;Unsupported paint mode %d&quot;, _paintState);
182 }
183 
184 - (NSString *)getDescription {
185     if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
186         return [NSString stringWithFormat:@&quot;[r=%d g=%d b=%d a=%d]&quot;, (_color &gt;&gt; 16) &amp; (0xFF), (_color &gt;&gt; 8) &amp; 0xFF, (_color) &amp; 0xFF, (_color &gt;&gt; 24) &amp; 0xFF];
187     }
188     
189     if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
190         return [NSString stringWithFormat:@&quot;gradient&quot;];
191     }
192 
193     if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
194         return [NSString stringWithFormat:@&quot;texture_paint&quot;];
195     }
196 
197     return @&quot;unknown-paint&quot;;
198 }
199 
200 - (jint)getColor {
201     return _color;
202 }
203 
204 - (void)reset {
205     _paintState = sun_java2d_SunGraphics2D_PAINT_UNDEFINED;
206     _paintTexture = nil;
207     _anchor.xParams[0] = _anchor.xParams[1] = _anchor.xParams[2] = 0.0f;
208     _anchor.yParams[0] = _anchor.yParams[1] = _anchor.yParams[2] = 0.0f; 
209 }
210 
211 - (void)setColor:(jint)pixelColor {
212     _paintState = sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR;
213     _color = pixelColor;
214 }
215 
216 - (void)setGradientUseMask:(jboolean)useMask
217                     cyclic:(jboolean)cyclic
218                         p0:(jdouble)p0
219                         p1:(jdouble)p1
220                         p3:(jdouble)p3
221                     pixel1:(jint)pixel1
222                     pixel2:(jint)pixel2
223 {
224     //TODO Resolve gradient distribution problem
225     //TODO Implement useMask
226     //TODO Implement cyclic
227     //fprintf(stderr,
228     //        &quot;MTLPaints_SetGradientPaint useMask=%d cyclic=%d &quot;
229     //        &quot;p0=%f p1=%f p3=%f pix1=%d pix2=%d\n&quot;, useMask, cyclic,
230     //        p0, p1, p3, pixel1, pixel2);
231 
232     _paintState = sun_java2d_SunGraphics2D_PAINT_GRADIENT;
233     _useMask = useMask;
234     _pixel1 = pixel1;
235     _pixel2 = pixel2;
236     _p0 = p0;
237     _p1 = p1;
238     _p3 = p3;
239     _cyclic = cyclic;
240 }
241 
242 - (void)setLinearGradient:(jboolean)useMask
243                    linear:(jboolean)linear
244               cycleMethod:(jboolean)cycleMethod
245                  numStops:(jint)numStops
246                        p0:(jfloat)p0
247                        p1:(jfloat)p1
248                        p3:(jfloat)p3
249                 fractions:(void *)fractions
250                    pixels:(void *)pixels
251 {
252     J2dTraceLn(J2D_TRACE_ERROR, &quot;setLinearGradient: UNIMPLEMENTED&quot;);
253     [self setColor:0];
254 }
255 
256 - (void)setRadialGradient:(jboolean)useMask
257                    linear:(jboolean)linear
258               cycleMethod:(jboolean)cycleMethod
259                  numStops:(jint)numStops
260                       m00:(jfloat)m00
261                       m01:(jfloat)m01
262                       m02:(jfloat)m02
263                       m10:(jfloat)m10
264                       m11:(jfloat)m11
265                       m12:(jfloat)m12
266                    focusX:(jfloat)focusX
267                 fractions:(void *)fractions
268                    pixels:(void *)pixels
269 {
270     J2dTraceLn(J2D_TRACE_ERROR, &quot;setRadialGradient: UNIMPLEMENTED&quot;);
271     [self setColor:0];
272 }
273 
274 - (void)setTexture:(jboolean)useMask
275            textureID:(id&lt;MTLTexture&gt;)textureID
276             filter:(jboolean)filter
277                xp0:(jdouble)xp0
278                xp1:(jdouble)xp1
279                xp3:(jdouble)xp3
280                yp0:(jdouble)yp0
281                yp1:(jdouble)yp1
282                yp3:(jdouble)yp3
283 {
284     _paintState = sun_java2d_SunGraphics2D_PAINT_TEXTURE;
285     _paintTexture = textureID;
286     
287     _anchor.xParams[0] = xp0;
288     _anchor.xParams[1] = xp1;
289     _anchor.xParams[2] = xp3;
290 
291     _anchor.yParams[0] = yp0;
292     _anchor.yParams[1] = yp1;
293     _anchor.yParams[2] = yp3;
294 }
295 
296 static id&lt;MTLSamplerState&gt; samplerNearestClamp = nil;
297 static id&lt;MTLSamplerState&gt; samplerLinearClamp = nil;
298 static id&lt;MTLSamplerState&gt; samplerNearestRepeat = nil;
299 static id&lt;MTLSamplerState&gt; samplerLinearRepeat = nil;
300 
301 void initSamplers(id&lt;MTLDevice&gt; device) {
302     // TODO: move this code into SamplerManager (need implement)
303 
304     if (samplerNearestClamp != nil)
305         return;
306 
307     MTLSamplerDescriptor *samplerDescriptor = [MTLSamplerDescriptor new];
308 
309     samplerDescriptor.rAddressMode = MTLSamplerAddressModeClampToEdge;
310     samplerDescriptor.sAddressMode = MTLSamplerAddressModeClampToEdge;
311     samplerDescriptor.tAddressMode = MTLSamplerAddressModeClampToEdge;
312 
313     samplerDescriptor.minFilter = MTLSamplerMinMagFilterNearest;
314     samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;
315     samplerNearestClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];
316 
317     samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;
318     samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;
319     samplerLinearClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];
320 
321     samplerDescriptor.rAddressMode = MTLSamplerAddressModeRepeat;
322     samplerDescriptor.sAddressMode = MTLSamplerAddressModeRepeat;
323     samplerDescriptor.tAddressMode = MTLSamplerAddressModeRepeat;
324 
325     samplerDescriptor.minFilter = MTLSamplerMinMagFilterNearest;
326     samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;
327     samplerNearestRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];
328 
329     samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;
330     samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;
331     samplerLinearRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];
332 }
333 
334 static void setSampler(id&lt;MTLRenderCommandEncoder&gt; encoder, int interpolation, bool repeat) {
335     id&lt;MTLSamplerState&gt; sampler;
336     if (repeat) {
337         sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearRepeat : samplerNearestRepeat;
338     } else {
339         sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearClamp : samplerNearestClamp;
340     }
341     [encoder setFragmentSamplerState:sampler atIndex:0];
342 }
343 
344 static void setTxtUniforms(
345         id&lt;MTLRenderCommandEncoder&gt; encoder, int color, int mode, int interpolation, bool repeat, jfloat extraAlpha,
346         const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags
347 ) {
348     struct TxtFrameUniforms uf = {RGBA_TO_V4(color), mode, srcFlags-&gt;isOpaque, dstFlags-&gt;isOpaque, extraAlpha};
349     [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
350 
351     setSampler(encoder, interpolation, repeat);
352 }
353 
354 // For the current paint mode:
355 // 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState
356 // 2. Set vertex and fragment buffers
357 - (void)setPipelineState:(id&lt;MTLRenderCommandEncoder&gt;)encoder
358                  context:(MTLContext *)mtlc
359            renderOptions:(const RenderOptions *)renderOptions
360     pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage
361 {
362     initTemplatePipelineDescriptors();
363 
364     NSString * vertShader = @&quot;vert_txt&quot;;
365     NSString * fragShader = @&quot;frag_txt&quot;;
366     MTLRenderPipelineDescriptor * rpDesc = [[templateTexturePipelineDesc copy] autorelease];
367 
368     if (renderOptions-&gt;isTexture) {
369         NSObject *bufImgOp = [mtlc getBufImgOp];
370         if (bufImgOp != nil) {
371             if ([bufImgOp isKindOfClass:[MTLRescaleOp class]]) {
372                 MTLRescaleOp *rescaleOp = bufImgOp;
373                 vertShader = @&quot;vert_txt&quot;;
374                 fragShader = @&quot;frag_txt_op_rescale&quot;;
375 
376                 struct TxtFrameOpRescaleUniforms uf = {
377                         RGBA_TO_V4(0), [mtlc.composite getExtraAlpha], renderOptions-&gt;srcFlags.isOpaque,
378                         rescaleOp.isNonPremult,
379                         FLOAT_ARR_TO_V4([rescaleOp getScaleFactors]), FLOAT_ARR_TO_V4([rescaleOp getOffsets])
380                 };
381                 [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
382                 setSampler(encoder, renderOptions-&gt;interpolation, NO);
383             } else if ([bufImgOp isKindOfClass:[MTLConvolveOp class]]) {
384                 MTLConvolveOp * convolveOp = bufImgOp;
385                 vertShader = @&quot;vert_txt&quot;;
386                 fragShader = @&quot;frag_txt_op_convolve&quot;;
387 
388                 struct TxtFrameOpConvolveUniforms uf = {
389                         [mtlc.composite getExtraAlpha], FLOAT_ARR_TO_V4([convolveOp getImgEdge]),
390                         convolveOp.kernelSize, convolveOp.isEdgeZeroFill,
391                 };
392                 [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
393                 setSampler(encoder, renderOptions-&gt;interpolation, NO);
394 
395                 [encoder setFragmentBuffer:[convolveOp getBuffer] offset:0 atIndex:2];
396             } else if ([bufImgOp isKindOfClass:[MTLLookupOp class]]) {
397                 MTLLookupOp * lookupOp = bufImgOp;
398                 vertShader = @&quot;vert_txt&quot;;
399                 fragShader = @&quot;frag_txt_op_lookup&quot;;
400 
401                 struct TxtFrameOpLookupUniforms uf = {
402                         [mtlc.composite getExtraAlpha], FLOAT_ARR_TO_V4([lookupOp getOffset]),
403                         lookupOp.isUseSrcAlpha, lookupOp.isNonPremult,
404                 };
405                 [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
406                 setSampler(encoder, renderOptions-&gt;interpolation, NO);
407                 [encoder setFragmentTexture:[lookupOp getLookupTexture] atIndex: 1];
408             }
409         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
410             vertShader = @&quot;vert_txt_tp&quot;;
411             fragShader = @&quot;frag_txt_tp&quot;;
412             [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
413             [encoder setFragmentTexture:_paintTexture atIndex:1];
414 
415             setTxtUniforms(encoder, 0, 0, renderOptions-&gt;interpolation, YES, [mtlc.composite getExtraAlpha],
416                            &amp;renderOptions-&gt;srcFlags, &amp;renderOptions-&gt;dstFlags);
417         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
418             vertShader = @&quot;vert_txt_grad&quot;;
419             fragShader = @&quot;frag_txt_grad&quot;;
420             struct GradFrameUniforms uf = {
421                     {_p0, _p1, _p3},
422                     RGBA_TO_V4(_pixel1),
423                     RGBA_TO_V4(_pixel2),
424                     _cyclic};
425             [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:0];
426 
427         } else {
428             vertShader = @&quot;vert_txt&quot;;
429             fragShader = @&quot;frag_txt&quot;;
430             if (renderOptions-&gt;isAA) {
431                 fragShader = @&quot;aa_frag_txt&quot;;
432                 rpDesc = templateAATexturePipelineDesc;
433             }
434 
435             setTxtUniforms(encoder, _color, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0,
436                            renderOptions-&gt;interpolation, NO, [mtlc.composite getExtraAlpha], &amp;renderOptions-&gt;srcFlags,
437                            &amp;renderOptions-&gt;dstFlags);
438         }
439     } else {
440         rpDesc = templateRenderPipelineDesc;
441 
442         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
443             vertShader = @&quot;vert_col&quot;;
444             fragShader = @&quot;frag_col&quot;;
445 
446             struct FrameUniforms uf = {RGBA_TO_V4(_color)};
447             [encoder setVertexBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
448         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
449             vertShader = @&quot;vert_grad&quot;;
450             fragShader = @&quot;frag_grad&quot;;
451 
452             struct GradFrameUniforms uf = {
453                     {_p0, _p1, _p3},
454                     RGBA_TO_V4(_pixel1),
455                     RGBA_TO_V4(_pixel2),
456                     _cyclic
457             };
458             [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:0];
459         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
460             vertShader = @&quot;vert_tp&quot;;
461             fragShader = @&quot;frag_tp&quot;;
462 
463             [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
464             [encoder setFragmentTexture:_paintTexture atIndex:0];
465 
466         }
467     }
468 
469     id &lt;MTLRenderPipelineState&gt; pipelineState = [pipelineStateStorage getPipelineState:rpDesc
470                                                                         vertexShaderId:vertShader
471                                                                       fragmentShaderId:fragShader
472                                                                              composite:mtlc.composite
473                                                                          renderOptions:renderOptions
474                                                                          stencilNeeded:[mtlc.clip isShape]];
475     [encoder setRenderPipelineState:pipelineState];
476 }
477 
478 
479 // For the current paint mode: and for XOR composite - a separate method is added as fragment shader differ in some cases
480 // 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState
481 // 2. Set vertex and fragment buffers
482 - (void)setXorModePipelineState:(id&lt;MTLRenderCommandEncoder&gt;)encoder
483                         context:(MTLContext *)mtlc
484                   renderOptions:(const RenderOptions *)renderOptions
485            pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage
486 {
487     initTemplatePipelineDescriptors();
488 
489     jint xorColor = (jint) [mtlc.composite getXorColor];
490 
491     NSString * vertShader = @&quot;vert_txt_xorMode&quot;;
492     NSString * fragShader = @&quot;frag_txt_xorMode&quot;;
493     MTLRenderPipelineDescriptor * rpDesc = [[templateTexturePipelineDesc copy] autorelease];
494 
495     if (renderOptions-&gt;isTexture) {
496         const int col = _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? _color ^ xorColor : 0 ^ xorColor;
497         setTxtUniforms(encoder, col, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0,
498                        renderOptions-&gt;interpolation, NO, [mtlc.composite getExtraAlpha],
499                        &amp;renderOptions-&gt;srcFlags, &amp;renderOptions-&gt;dstFlags);
500         [encoder setFragmentBytes:&amp;xorColor length:sizeof(xorColor) atIndex: 0];
501 
502         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
503         [encoder setFragmentTexture:dstOps-&gt;pTexture atIndex:1];
504 
505         J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints - setXorModePipelineState -- TEXTURE DRAW&quot;);
506     } else {
507         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
508             vertShader = @&quot;vert_col_xorMode&quot;;
509             fragShader = @&quot;frag_col_xorMode&quot;;
510             rpDesc = templateRenderPipelineDesc;
511 
512             // Calculate _color ^ xorColor for RGB components
513             // This color gets XORed with destination framebuffer pixel color
514             struct FrameUniforms uf = {RGBA_TO_V4(_color ^ xorColor)};
515             [encoder setVertexBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
516 
517             BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
518             [encoder setFragmentTexture:dstOps-&gt;pTexture atIndex:0];
519 
520             J2dTraceLn(J2D_TRACE_INFO ,&quot;MTLPaints - setXorModePipelineState -- PAINT_ALPHACOLOR&quot;);
521         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
522             // This block is not reached in current implementation.
523             // Gradient paint XOR mode rendering uses a tile based rendering using a SW pipe (similar to OGL)
524             vertShader = @&quot;vert_grad_xorMode&quot;;
525             fragShader = @&quot;frag_grad_xorMode&quot;;
526             rpDesc = templateRenderPipelineDesc;
527 
528             struct GradFrameUniforms uf = {
529                         {_p0, _p1, _p3},
530                         RGBA_TO_V4(_pixel1 ^ xorColor),
531                         RGBA_TO_V4(_pixel2 ^ xorColor),
532                         _cyclic
533             };
534 
535             [encoder setFragmentBytes: &amp;uf length:sizeof(uf) atIndex:0];
536             BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
537             [encoder setFragmentTexture:dstOps-&gt;pTexture atIndex:0];
538 
539             J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints - setXorModePipelineState -- PAINT_GRADIENT&quot;);
540         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
541             // This block is not reached in current implementation.
542             // Texture paint XOR mode rendering uses a tile based rendering using a SW pipe (similar to OGL)
543             vertShader = @&quot;vert_tp_xorMode&quot;;
544             fragShader = @&quot;frag_tp_xorMode&quot;;
545             rpDesc = templateRenderPipelineDesc;
546 
547             [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
548             [encoder setFragmentTexture:_paintTexture atIndex: 0];
549             BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
550             [encoder setFragmentTexture:dstOps-&gt;pTexture atIndex:1];
551             [encoder setFragmentBytes:&amp;xorColor length:sizeof(xorColor) atIndex: 0];
552 
553             J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints - setXorModePipelineState -- PAINT_TEXTURE&quot;);
554         }
555     }
556 
557     id &lt;MTLRenderPipelineState&gt; pipelineState = [pipelineStateStorage getPipelineState:rpDesc
558                                                                         vertexShaderId:vertShader
559                                                                       fragmentShaderId:fragShader
560                                                                              composite:mtlc.composite
561                                                                          renderOptions:renderOptions
562                                                                          stencilNeeded:[mtlc.clip isShape]];
563     [encoder setRenderPipelineState:pipelineState];
564 }
565 
566 @end
567 
568 /************************* GradientPaint support ****************************/
569 
570 static void
571 MTLPaints_InitGradientTexture()
572 {
573     //TODO
574     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_InitGradientTexture -- :TODO&quot;);
575 }
576 
577 /****************** Shared MultipleGradientPaint support ********************/
578 
579 /**
580  * These constants are identical to those defined in the
581  * MultipleGradientPaint.CycleMethod enum; they are copied here for
582  * convenience (ideally we would pull them directly from the Java level,
583  * but that entails more hassle than it is worth).
584  */
585 #define CYCLE_NONE    0
586 #define CYCLE_REFLECT 1
587 #define CYCLE_REPEAT  2
588 
589 /**
590  * The following constants are flags that can be bitwise-or&#39;ed together
591  * to control how the MultipleGradientPaint shader source code is generated:
592  *
593  *   MULTI_CYCLE_METHOD
594  *     Placeholder for the CycleMethod enum constant.
595  *
596  *   MULTI_LARGE
597  *     If set, use the (slower) shader that supports a larger number of
598  *     gradient colors; otherwise, use the optimized codepath.  See
599  *     the MAX_FRACTIONS_SMALL/LARGE constants below for more details.
600  *
601  *   MULTI_USE_MASK
602  *     If set, apply the alpha mask value from texture unit 0 to the
603  *     final color result (only used in the MaskFill case).
604  *
605  *   MULTI_LINEAR_RGB
606  *     If set, convert the linear RGB result back into the sRGB color space.
607  */
608 #define MULTI_CYCLE_METHOD (3 &lt;&lt; 0)
609 #define MULTI_LARGE        (1 &lt;&lt; 2)
610 #define MULTI_USE_MASK     (1 &lt;&lt; 3)
611 #define MULTI_LINEAR_RGB   (1 &lt;&lt; 4)
612 
613 /**
614  * This value determines the size of the array of programs for each
615  * MultipleGradientPaint type.  This value reflects the maximum value that
616  * can be represented by performing a bitwise-or of all the MULTI_*
617  * constants defined above.
618  */
619 #define MAX_PROGRAMS 32
620 
621 /** Evaluates to true if the given bit is set on the local flags variable. */
622 #define IS_SET(flagbit) \
623     (((flags) &amp; (flagbit)) != 0)
624 
625 /** Composes the given parameters as flags into the given flags variable.*/
626 #define COMPOSE_FLAGS(flags, cycleMethod, large, useMask, linear) \
627     do {                                                   \
628         flags |= ((cycleMethod) &amp; MULTI_CYCLE_METHOD);     \
629         if (large)   flags |= MULTI_LARGE;                 \
630         if (useMask) flags |= MULTI_USE_MASK;              \
631         if (linear)  flags |= MULTI_LINEAR_RGB;            \
632     } while (0)
633 
634 /** Extracts the CycleMethod enum value from the given flags variable. */
635 #define EXTRACT_CYCLE_METHOD(flags) \
636     ((flags) &amp; MULTI_CYCLE_METHOD)
637 
638 /**
639  * The maximum number of gradient &quot;stops&quot; supported by the fragment shader
640  * and related code.  When the MULTI_LARGE flag is set, we will use
641  * MAX_FRACTIONS_LARGE; otherwise, we use MAX_FRACTIONS_SMALL.  By having
642  * two separate values, we can have one highly optimized shader (SMALL) that
643  * supports only a few fractions/colors, and then another, less optimal
644  * shader that supports more stops.
645  */
646 #define MAX_FRACTIONS sun_java2d_pipe_BufferedPaints_MULTI_MAX_FRACTIONS
647 #define MAX_FRACTIONS_LARGE MAX_FRACTIONS
648 #define MAX_FRACTIONS_SMALL 4
649 
650 /**
651  * The maximum number of gradient colors supported by all of the gradient
652  * fragment shaders.  Note that this value must be a power of two, as it
653  * determines the size of the 1D texture created below.  It also must be
654  * greater than or equal to MAX_FRACTIONS (there is no strict requirement
655  * that the two values be equal).
656  */
657 #define MAX_COLORS 16
658 
659 /**
660  * The handle to the gradient color table texture object used by the shaders.
661  */
662 static jint multiGradientTexID = 0;
663 
664 /**
665  * This is essentially a template of the shader source code that can be used
666  * for either LinearGradientPaint or RadialGradientPaint.  It includes the
667  * structure and some variables that are common to each; the remaining
668  * code snippets (for CycleMethod, ColorSpaceType, and mask modulation)
669  * are filled in prior to compiling the shader at runtime depending on the
670  * paint parameters.  See MTLPaints_CreateMultiGradProgram() for more details.
671  */
672 static const char *multiGradientShaderSource =
673     // gradient texture size (in texels)
674     &quot;const int TEXTURE_SIZE = %d;&quot;
675     // maximum number of fractions/colors supported by this shader
676     &quot;const int MAX_FRACTIONS = %d;&quot;
677     // size of a single texel
678     &quot;const float FULL_TEXEL = (1.0 / float(TEXTURE_SIZE));&quot;
679     // size of half of a single texel
680     &quot;const float HALF_TEXEL = (FULL_TEXEL / 2.0);&quot;
681     // texture containing the gradient colors
682     &quot;uniform sampler1D colors;&quot;
683     // array of gradient stops/fractions
684     &quot;uniform float fractions[MAX_FRACTIONS];&quot;
685     // array of scale factors (one for each interval)
686     &quot;uniform float scaleFactors[MAX_FRACTIONS-1];&quot;
687     // (placeholder for mask variable)
688     &quot;%s&quot;
689     // (placeholder for Linear/RadialGP-specific variables)
690     &quot;%s&quot;
691     &quot;&quot;
692     &quot;void main(void)&quot;
693     &quot;{&quot;
694     &quot;    float dist;&quot;
695          // (placeholder for Linear/RadialGradientPaint-specific code)
696     &quot;    %s&quot;
697     &quot;&quot;
698     &quot;    float tc;&quot;
699          // (placeholder for CycleMethod-specific code)
700     &quot;    %s&quot;
701     &quot;&quot;
702          // calculate interpolated color
703     &quot;    vec4 result = texture1D(colors, tc);&quot;
704     &quot;&quot;
705          // (placeholder for ColorSpace conversion code)
706     &quot;    %s&quot;
707     &quot;&quot;
708          // (placeholder for mask modulation code)
709     &quot;    %s&quot;
710     &quot;&quot;
711          // modulate with gl_Color in order to apply extra alpha
712     &quot;    gl_FragColor = result * gl_Color;&quot;
713     &quot;}&quot;;
714 
715 /**
716  * This code takes a &quot;dist&quot; value as input (as calculated earlier by the
717  * LGP/RGP-specific code) in the range [0,1] and produces a texture
718  * coordinate value &quot;tc&quot; that represents the position of the chosen color
719  * in the one-dimensional gradient texture (also in the range [0,1]).
720  *
721  * One naive way to implement this would be to iterate through the fractions
722  * to figure out in which interval &quot;dist&quot; falls, and then compute the
723  * relative distance between the two nearest stops.  This approach would
724  * require an &quot;if&quot; check on every iteration, and it is best to avoid
725  * conditionals in fragment shaders for performance reasons.  Also, one might
726  * be tempted to use a break statement to jump out of the loop once the
727  * interval was found, but break statements (and non-constant loop bounds)
728  * are not natively available on most graphics hardware today, so that is
729  * a non-starter.
730  *
731  * The more optimal approach used here avoids these issues entirely by using
732  * an accumulation function that is equivalent to the process described above.
733  * The scaleFactors array is pre-initialized at enable time as follows:
734  *     scaleFactors[i] = 1.0 / (fractions[i+1] - fractions[i]);
735  *
736  * For each iteration, we subtract fractions[i] from dist and then multiply
737  * that value by scaleFactors[i].  If we are within the target interval,
738  * this value will be a fraction in the range [0,1] indicating the relative
739  * distance between fraction[i] and fraction[i+1].  If we are below the
740  * target interval, this value will be negative, so we clamp it to zero
741  * to avoid accumulating any value.  If we are above the target interval,
742  * the value will be greater than one, so we clamp it to one.  Upon exiting
743  * the loop, we will have accumulated zero or more 1.0&#39;s and a single
744  * fractional value.  This accumulated value tells us the position of the
745  * fragment color in the one-dimensional gradient texture, i.e., the
746  * texcoord called &quot;tc&quot;.
747  */
748 static const char *texCoordCalcCode =
749     &quot;int i;&quot;
750     &quot;float relFraction = 0.0;&quot;
751     &quot;for (i = 0; i &lt; MAX_FRACTIONS-1; i++) {&quot;
752     &quot;    relFraction +=&quot;
753     &quot;        clamp((dist - fractions[i]) * scaleFactors[i], 0.0, 1.0);&quot;
754     &quot;}&quot;
755     // we offset by half a texel so that we find the linearly interpolated
756     // color between the two texel centers of interest
757     &quot;tc = HALF_TEXEL + (FULL_TEXEL * relFraction);&quot;;
758 
759 /** Code for NO_CYCLE that gets plugged into the CycleMethod placeholder. */
760 static const char *noCycleCode =
761     &quot;if (dist &lt;= 0.0) {&quot;
762     &quot;    tc = 0.0;&quot;
763     &quot;} else if (dist &gt;= 1.0) {&quot;
764     &quot;    tc = 1.0;&quot;
765     &quot;} else {&quot;
766          // (placeholder for texcoord calculation)
767     &quot;    %s&quot;
768     &quot;}&quot;;
769 
770 /** Code for REFLECT that gets plugged into the CycleMethod placeholder. */
771 static const char *reflectCode =
772     &quot;dist = 1.0 - (abs(fract(dist * 0.5) - 0.5) * 2.0);&quot;
773     // (placeholder for texcoord calculation)
774     &quot;%s&quot;;
775 
776 /** Code for REPEAT that gets plugged into the CycleMethod placeholder. */
777 static const char *repeatCode =
778     &quot;dist = fract(dist);&quot;
779     // (placeholder for texcoord calculation)
780     &quot;%s&quot;;
781 
782 static void
783 MTLPaints_InitMultiGradientTexture()
784 {
785     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_InitMultiGradientTexture -- :TODO&quot;);
786 }
787 
788 /**
789  * Compiles and links the MultipleGradientPaint shader program.  If
790  * successful, this function returns a handle to the newly created
791  * shader program; otherwise returns 0.
792  */
793 static void*
794 MTLPaints_CreateMultiGradProgram(jint flags,
795                                  char *paintVars, char *distCode)
796 {
797 
798     //TODO
799     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_CreateMultiGradProgram -- :TODO&quot;);
800 
801     return NULL;
802 }
803 
804 /**
805  * Called from the MTLPaints_SetLinear/RadialGradientPaint() methods
806  * in order to setup the fraction/color values that are common to both.
807  */
808 static void
809 MTLPaints_SetMultiGradientPaint(void* multiGradProgram,
810                                 jint numStops,
811                                 void *pFractions, void *pPixels)
812 {
813     //TODO
814     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_SetMultiGradientPaint -- :TODO&quot;);
815 
816 }
817 
818 /********************** LinearGradientPaint support *************************/
819 
820 /**
821  * The handles to the LinearGradientPaint fragment program objects.  The
822  * index to the array should be a bitwise-or&#39;ing of the MULTI_* flags defined
823  * above.  Note that most applications will likely need to initialize one
824  * or two of these elements, so the array is usually sparsely populated.
825  */
826 static void* linearGradPrograms[MAX_PROGRAMS];
827 
828 /**
829  * Compiles and links the LinearGradientPaint shader program.  If successful,
830  * this function returns a handle to the newly created shader program;
831  * otherwise returns 0.
832  */
833 static void*
834 MTLPaints_CreateLinearGradProgram(jint flags)
835 {
836     char *paintVars;
837     char *distCode;
838 
839     J2dTraceLn1(J2D_TRACE_INFO,
840                 &quot;MTLPaints_CreateLinearGradProgram&quot;,
841                 flags);
842 
843     /*
844      * To simplify the code and to make it easier to upload a number of
845      * uniform values at once, we pack a bunch of scalar (float) values
846      * into vec3 values below.  Here&#39;s how the values are related:
847      *
848      *   params.x = p0
849      *   params.y = p1
850      *   params.z = p3
851      *
852      *   yoff = dstOps-&gt;yOffset + dstOps-&gt;height
853      */
854     paintVars =
855         &quot;uniform vec3 params;&quot;
856         &quot;uniform float yoff;&quot;;
857     distCode =
858         // note that gl_FragCoord is in window space relative to the
859         // lower-left corner, so we have to flip the y-coordinate here
860         &quot;vec3 fragCoord = vec3(gl_FragCoord.x, yoff-gl_FragCoord.y, 1.0);&quot;
861         &quot;dist = dot(params, fragCoord);&quot;;
862 
863     return MTLPaints_CreateMultiGradProgram(flags, paintVars, distCode);
864 }
865 
866 /********************** RadialGradientPaint support *************************/
867 
868 /**
869  * The handles to the RadialGradientPaint fragment program objects.  The
870  * index to the array should be a bitwise-or&#39;ing of the MULTI_* flags defined
871  * above.  Note that most applications will likely need to initialize one
872  * or two of these elements, so the array is usually sparsely populated.
873  */
874 static void* radialGradPrograms[MAX_PROGRAMS];
875 
876 /**
877  * Compiles and links the RadialGradientPaint shader program.  If successful,
878  * this function returns a handle to the newly created shader program;
879  * otherwise returns 0.
880  */
881 static void*
882 MTLPaints_CreateRadialGradProgram(jint flags)
883 {
884     char *paintVars;
885     char *distCode;
886 
887     J2dTraceLn1(J2D_TRACE_INFO,
888                 &quot;MTLPaints_CreateRadialGradProgram&quot;,
889                 flags);
890 
891     /*
892      * To simplify the code and to make it easier to upload a number of
893      * uniform values at once, we pack a bunch of scalar (float) values
894      * into vec3 and vec4 values below.  Here&#39;s how the values are related:
895      *
896      *   m0.x = m00
897      *   m0.y = m01
898      *   m0.z = m02
899      *
900      *   m1.x = m10
901      *   m1.y = m11
902      *   m1.z = m12
903      *
904      *   precalc.x = focusX
905      *   precalc.y = yoff = dstOps-&gt;yOffset + dstOps-&gt;height
906      *   precalc.z = 1.0 - (focusX * focusX)
907      *   precalc.w = 1.0 / precalc.z
908      */
909     paintVars =
910         &quot;uniform vec3 m0;&quot;
911         &quot;uniform vec3 m1;&quot;
912         &quot;uniform vec4 precalc;&quot;;
913 
914     /*
915      * The following code is derived from Daniel Rice&#39;s whitepaper on
916      * radial gradient performance (attached to the bug report for 6521533).
917      * Refer to that document as well as the setup code in the Java-level
918      * BufferedPaints.setRadialGradientPaint() method for more details.
919      */
920     distCode =
921         // note that gl_FragCoord is in window space relative to the
922         // lower-left corner, so we have to flip the y-coordinate here
923         &quot;vec3 fragCoord =&quot;
924         &quot;    vec3(gl_FragCoord.x, precalc.y - gl_FragCoord.y, 1.0);&quot;
925         &quot;float x = dot(fragCoord, m0);&quot;
926         &quot;float y = dot(fragCoord, m1);&quot;
927         &quot;float xfx = x - precalc.x;&quot;
928         &quot;dist = (precalc.x*xfx + sqrt(xfx*xfx + y*y*precalc.z))*precalc.w;&quot;;
929 
930     return MTLPaints_CreateMultiGradProgram(flags, paintVars, distCode);
931 }
932 
933 #endif /* !HEADLESS */
    </pre>
  </body>
</html>