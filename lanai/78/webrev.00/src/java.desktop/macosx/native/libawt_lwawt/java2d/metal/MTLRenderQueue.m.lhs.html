<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifndef HEADLESS
  27 
  28 #include &lt;stdlib.h&gt;
  29 
  30 #include &quot;sun_java2d_pipe_BufferedOpCodes.h&quot;
  31 
  32 #include &quot;jlong.h&quot;
  33 #include &quot;MTLBlitLoops.h&quot;
  34 #include &quot;MTLBufImgOps.h&quot;
  35 #include &quot;MTLMaskBlit.h&quot;
  36 #include &quot;MTLMaskFill.h&quot;
  37 #include &quot;MTLPaints.h&quot;
  38 #include &quot;MTLRenderQueue.h&quot;
  39 #include &quot;MTLRenderer.h&quot;
  40 #include &quot;MTLTextRenderer.h&quot;
  41 #import &quot;ThreadUtilities.h&quot;
  42 
  43 /**
  44  * References to the &quot;current&quot; context and destination surface.
  45  */
  46 static MTLContext *mtlc = NULL;
  47 static BMTLSDOps *dstOps = NULL;
  48 jint mtlPreviousOp = MTL_OP_INIT;
  49 
  50 
  51 /**
  52  * The following methods are implemented in the windowing system (i.e. GLX
  53  * and WGL) source files.
  54  */
  55 extern void MTLGC_DestroyMTLGraphicsConfig(jlong pConfigInfo);
  56 extern void MTLSD_SwapBuffers(JNIEnv *env, jlong window);
  57 
  58 // TODO : Debug logic added for opcode verification,
  59 // should be removed later.
  60 static char *getOpcodeString(jint opcode) {
  61     static char opName[30];
  62     switch (opcode) {
  63         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
  64             {
  65                 strcpy(opName, &quot;DRAW_LINE&quot;);
  66             }
  67             break;
  68         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
  69             {
  70                 strcpy(opName, &quot;DRAW_RECT&quot;);
  71             }
  72             break;
  73         case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
  74             {
  75                 strcpy(opName, &quot;DRAW_POLY&quot;);
  76             }
  77             break;
  78         case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
  79             {
  80                 strcpy(opName, &quot;DRAW_PIXEL&quot;);
  81             }
  82             break;
  83         case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
  84             {
  85                 strcpy(opName, &quot;DRAW_SCANLINES&quot;);
  86             }
  87             break;
  88         case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
  89             {
  90                 strcpy(opName, &quot;DRAW_PARALLELOGRAM&quot;);
  91             }
  92             break;
  93         case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
  94             {
  95                 strcpy(opName, &quot;DRAW_AAPARALLELOGRAM&quot;);
  96             }
  97             break;
  98         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
  99             {
 100                 strcpy(opName, &quot;FILL_RECT&quot;);
 101             }
 102             break;
 103         case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
 104             {
 105                 strcpy(opName, &quot;FILL_SPANS&quot;);
 106             }
 107             break;
 108         case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
 109             {
 110                 strcpy(opName, &quot;FILL_PARALLELOGRAM&quot;);
 111             }
 112             break;
 113         case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
 114             {
 115                 strcpy(opName, &quot;FILL_AAPARALLELOGRAM&quot;);
 116             }
 117             break;
 118         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
 119             {
 120                 strcpy(opName, &quot;DRAW_GLYPH_LIST&quot;);
 121             }
 122             break;
 123         case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
 124             {
 125                 strcpy(opName, &quot;COPY_AREA&quot;);
 126             }
 127             break;
 128         case sun_java2d_pipe_BufferedOpCodes_BLIT:
 129             {
 130                 strcpy(opName, &quot;BLIT&quot;);
 131             }
 132             break;
 133         case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
 134             {
 135                 strcpy(opName, &quot;SURFACE_TO_SW_BLIT&quot;);
 136             }
 137             break;
 138         case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
 139             {
 140                 strcpy(opName, &quot;MASK_FILL&quot;);
 141             }
 142             break;
 143         case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
 144             {
 145 
 146                 strcpy(opName, &quot;MASK_BLIT&quot;);
 147             }
 148             break;
 149         case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
 150             {
 151                 strcpy(opName, &quot;SET_RECT_CLIP&quot;);
 152             }
 153             break;
 154         case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
 155             {
 156                 strcpy(opName, &quot;BEGIN_SHAPE_CLIP&quot;);
 157             }
 158             break;
 159         case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
 160             {
 161                 strcpy(opName, &quot;SET_SHAPE_CLIP_SPANS&quot;);
 162             }
 163             break;
 164         case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
 165             {
 166                 strcpy(opName, &quot;END_SHAPE_CLIP&quot;);
 167             }
 168             break;
 169         case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
 170             {
 171                 strcpy(opName, &quot;RESET_CLIP&quot;);
 172             }
 173             break;
 174         case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
 175             {
 176                 strcpy(opName, &quot;SET_ALPHA_COMPOSITE&quot;);
 177             }
 178             break;
 179         case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
 180             {
 181                 strcpy(opName, &quot;SET_XOR_COMPOSITE&quot;);
 182             }
 183             break;
 184         case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
 185             {
 186                 strcpy(opName, &quot;RESET_COMPOSITE&quot;);
 187             }
 188             break;
 189         case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
 190             {
 191                 strcpy(opName, &quot;SET_TRANSFORM&quot;);
 192             }
 193             break;
 194         case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
 195             {
 196                 strcpy(opName, &quot;RESET_TRANSFORM&quot;);
 197             }
 198             break;
 199         case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
 200             {
 201 
 202                 strcpy(opName, &quot;SET_SURFACES&quot;);
 203             }
 204             break;
 205         case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
 206             {
 207                 strcpy(opName, &quot;SET_SCRATCH_SURFACE&quot;);
 208             }
 209             break;
 210         case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
 211             {
 212                 strcpy(opName, &quot;FLUSH_SURFACE&quot;);
 213             }
 214             break;
 215         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
 216             {
 217                 strcpy(opName, &quot;DISPOSE_SURFACE&quot;);
 218             }
 219             break;
 220         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
 221             {
 222                 strcpy(opName, &quot;DISPOSE_CONFIG&quot;);
 223             }
 224             break;
 225         case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
 226             {
 227                 strcpy(opName, &quot;INVALIDATE_CONTEXT&quot;);
 228             }
 229             break;
 230         case sun_java2d_pipe_BufferedOpCodes_SYNC:
 231             {
 232                 strcpy(opName, &quot;SYNC&quot;);
 233 
 234             }
 235             break;
 236         case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
 237             {
 238                 strcpy(opName, &quot;SWAP_BUFFERS&quot;);
 239             }
 240             break;
 241         case sun_java2d_pipe_BufferedOpCodes_NOOP:
 242             strcpy(opName, &quot;NOOP&quot;);
 243             break;
 244         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
 245             {
 246                 strcpy(opName, &quot;RESET_PAINT&quot;);
 247             }
 248             break;
 249         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
 250             {
 251                 strcpy(opName, &quot;SET_COLOR&quot;);
 252             }
 253             break;
 254         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
 255             {
 256                 strcpy(opName, &quot;SET_GRADIENT_PAINT&quot;);
 257             }
 258             break;
 259         case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
 260             {
 261                 strcpy(opName, &quot;SET_LINEAR_GRADIENT_PAINT&quot;);
 262             }
 263             break;
 264         case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
 265             {
 266                 strcpy(opName, &quot;SET_RADIAL_GRADIENT_PAINT&quot;);
 267             }
 268             break;
 269         case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
 270             {
 271                 strcpy(opName, &quot;SET_TEXTURE_PAINT&quot;);
 272             }
 273             break;
 274         case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
 275             {
 276                 strcpy(opName, &quot;ENABLE_CONVOLVE_OP&quot;);
 277             }
 278             break;
 279         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
 280             {
 281                 strcpy(opName, &quot;DISABLE_CONVOLVE_OP&quot;);
 282             }
 283             break;
 284         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
 285             {
 286                 strcpy(opName, &quot;ENABLE_RESCALE_OP&quot;);
 287             }
 288             break;
 289         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
 290             {
 291                  strcpy(opName, &quot;DISABLE_RESCALE_OP&quot;);
 292             }
 293             break;
 294         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
 295             {
 296                 strcpy(opName, &quot;ENABLE_LOOKUP_OP&quot;);
 297             }
 298             break;
 299         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
 300             {
 301                 strcpy(opName, &quot;DISABLE_LOOKUP_OP&quot;);
 302             }
 303             break;
 304         default:
 305             strcpy(opName, &quot;UNKNOWN&quot;);
 306             break;
 307         }
 308     return opName;
 309 }
 310 
 311 void MTLRenderQueue_CheckPreviousOp(jint op) {
 312 
 313     if (mtlPreviousOp == op) {
 314         // The op is the same as last time, so we can return immediately.
 315         return;
 316     }
 317 
 318     J2dTraceLn1(J2D_TRACE_VERBOSE,
 319                 &quot;MTLRenderQueue_CheckPreviousOp: new op=%d&quot;, op);
 320 
 321     if (op == MTL_OP_SET_COLOR) {
 322         return; // SET_COLOR should not cause endEncoder
 323     }
 324 
 325     if (mtlPreviousOp == MTL_OP_INIT) {
 326         mtlPreviousOp = op;
 327         return;
 328     }
 329 
 330     if (mtlc != NULL) {
 331         [mtlc.encoderManager endEncoder];
 332 
 333         if (op == MTL_OP_RESET_PAINT || op == MTL_OP_SYNC) {
 334             MTLCommandBufferWrapper *cbwrapper = [mtlc pullCommandBufferWrapper];
 335             id &lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
 336             [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
 337                 [cbwrapper release];
 338             }];
 339             [commandbuf commit];
 340             if (op == MTL_OP_SYNC) {
 341                 [commandbuf waitUntilCompleted];
 342             }
 343         }
 344     }
 345     mtlPreviousOp = op;
 346 }
 347 
 348 JNIEXPORT void JNICALL
 349 Java_sun_java2d_metal_MTLRenderQueue_flushBuffer
 350     (JNIEnv *env, jobject mtlrq,
 351      jlong buf, jint limit)
 352 {
 353     unsigned char *b, *end;
 354 
 355     J2dTraceLn1(J2D_TRACE_INFO,
 356                 &quot;MTLRenderQueue_flushBuffer: limit=%d&quot;, limit);
 357 
 358     b = (unsigned char *)jlong_to_ptr(buf);
 359     if (b == NULL) {
 360         J2dRlsTraceLn(J2D_TRACE_ERROR,
 361             &quot;MTLRenderQueue_flushBuffer: cannot get direct buffer address&quot;);
 362         return;
 363     }
 364 
 365     end = b + limit;
 366     @autoreleasepool {
 367         jboolean DEBUG_LOG = JNI_FALSE;
 368         while (b &lt; end) {
 369             jint opcode = NEXT_INT(b);
 370 
 371             if (DEBUG_LOG) {
 372                 J2dTraceLn2(J2D_TRACE_ERROR,
 373                         &quot;MTLRenderQueue_flushBuffer: opcode_name = %s, rem=%d&quot;,
 374                         getOpcodeString(opcode), (end-b));
 375             } else {
 376                 J2dTraceLn2(J2D_TRACE_VERBOSE,
 377                         &quot;MTLRenderQueue_flushBuffer: opcode=%d, rem=%d&quot;,
 378                         opcode, (end-b));
 379             }
 380 
 381             switch (opcode) {
 382 
 383                 // draw ops
 384                 case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
 385                 {
 386                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 387 
 388                     if ([mtlc useXORComposite]) {
 389                         commitEncodedCommands();
 390                         J2dTraceLn(J2D_TRACE_VERBOSE,
 391                                    &quot;DRAW_LINE in XOR mode - Force commit earlier draw calls before DRAW_LINE.&quot;);
 392                     }
 393                     jint x1 = NEXT_INT(b);
 394                     jint y1 = NEXT_INT(b);
 395                     jint x2 = NEXT_INT(b);
 396                     jint y2 = NEXT_INT(b);
 397                     MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);
 398                     break;
 399                 }
 400                 case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
 401                 {
 402                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 403 
 404                     if ([mtlc useXORComposite]) {
 405                         commitEncodedCommands();
 406                         J2dTraceLn(J2D_TRACE_VERBOSE,
 407                                    &quot;DRAW_RECT in XOR mode - Force commit earlier draw calls before DRAW_RECT.&quot;);
 408                     }
 409                     jint x = NEXT_INT(b);
 410                     jint y = NEXT_INT(b);
 411                     jint w = NEXT_INT(b);
 412                     jint h = NEXT_INT(b);
 413                     MTLRenderer_DrawRect(mtlc, dstOps, x, y, w, h);
 414                     break;
 415                 }
 416                 case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
 417                 {
 418                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 419                     jint nPoints      = NEXT_INT(b);
 420                     jboolean isClosed = NEXT_BOOLEAN(b);
 421                     jint transX       = NEXT_INT(b);
 422                     jint transY       = NEXT_INT(b);
 423                     jint *xPoints = (jint *)b;
 424                     jint *yPoints = ((jint *)b) + nPoints;
 425 
 426                     if ([mtlc useXORComposite]) {
 427                         commitEncodedCommands();
 428                         J2dTraceLn(J2D_TRACE_VERBOSE,
 429                                    &quot;DRAW_POLY in XOR mode - Force commit earlier draw calls before DRAW_POLY.&quot;);
 430 
 431                         // draw separate (N-1) lines using N points
 432                         for(int point = 0; point &lt; nPoints-1; point++) {
 433                             jint x1 = xPoints[point] + transX;
 434                             jint y1 = yPoints[point] + transY;
 435                             jint x2 = xPoints[point + 1] + transX;
 436                             jint y2 = yPoints[point + 1] + transY;
 437                             MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);
 438                         }
 439 
 440                         if (isClosed) {
 441                             MTLRenderer_DrawLine(mtlc, dstOps, xPoints[0] + transX, yPoints[0] + transY,
 442                                                  xPoints[nPoints-1] + transX, yPoints[nPoints-1] + transY);
 443                         }
 444                     } else {
 445                         MTLRenderer_DrawPoly(mtlc, dstOps, nPoints, isClosed, transX, transY, xPoints, yPoints);
 446                     }
 447 
 448                     SKIP_BYTES(b, nPoints * BYTES_PER_POLY_POINT);
 449                     break;
 450                 }
 451                 case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
 452                 {
 453                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 454 
 455                     if ([mtlc useXORComposite]) {
 456                         commitEncodedCommands();
 457                         J2dTraceLn(J2D_TRACE_VERBOSE,
 458                                    &quot;DRAW_PIXEL in XOR mode - Force commit earlier draw calls before DRAW_PIXEL.&quot;);
 459                     }
 460 
 461                     jint x = NEXT_INT(b);
 462                     jint y = NEXT_INT(b);
 463                     CONTINUE_IF_NULL(mtlc);
 464                     MTLRenderer_DrawPixel(mtlc, dstOps, x, y);
 465                     break;
 466                 }
 467                 case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
 468                 {
 469                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 470 
 471                     if ([mtlc useXORComposite]) {
 472                         commitEncodedCommands();
 473                         J2dTraceLn(J2D_TRACE_VERBOSE,
 474                                    &quot;DRAW_SCANLINES in XOR mode - Force commit earlier draw calls before &quot;
 475                                    &quot;DRAW_SCANLINES.&quot;);
 476                     }
 477 
 478                     jint count = NEXT_INT(b);
 479                     MTLRenderer_DrawScanlines(mtlc, dstOps, count, (jint *)b);
 480 
 481                     SKIP_BYTES(b, count * BYTES_PER_SCANLINE);
 482                     break;
 483                 }
 484                 case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
 485                 {
 486                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 487 
 488                     if ([mtlc useXORComposite]) {
 489                         commitEncodedCommands();
 490                         J2dTraceLn(J2D_TRACE_VERBOSE,
 491                                    &quot;DRAW_PARALLELOGRAM in XOR mode - Force commit earlier draw calls before &quot;
 492                                    &quot;DRAW_PARALLELOGRAM.&quot;);
 493                     }
 494 
 495                     jfloat x11 = NEXT_FLOAT(b);
 496                     jfloat y11 = NEXT_FLOAT(b);
 497                     jfloat dx21 = NEXT_FLOAT(b);
 498                     jfloat dy21 = NEXT_FLOAT(b);
 499                     jfloat dx12 = NEXT_FLOAT(b);
 500                     jfloat dy12 = NEXT_FLOAT(b);
 501                     jfloat lwr21 = NEXT_FLOAT(b);
 502                     jfloat lwr12 = NEXT_FLOAT(b);
 503 
 504                     MTLRenderer_DrawParallelogram(mtlc, dstOps,
 505                                                   x11, y11,
 506                                                   dx21, dy21,
 507                                                   dx12, dy12,
 508                                                   lwr21, lwr12);
 509                     break;
 510                 }
 511                 case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
 512                 {
 513                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 514                     jfloat x11 = NEXT_FLOAT(b);
 515                     jfloat y11 = NEXT_FLOAT(b);
 516                     jfloat dx21 = NEXT_FLOAT(b);
 517                     jfloat dy21 = NEXT_FLOAT(b);
 518                     jfloat dx12 = NEXT_FLOAT(b);
 519                     jfloat dy12 = NEXT_FLOAT(b);
 520                     jfloat lwr21 = NEXT_FLOAT(b);
 521                     jfloat lwr12 = NEXT_FLOAT(b);
 522 
 523                     MTLRenderer_DrawAAParallelogram(mtlc, dstOps,
 524                                                     x11, y11,
 525                                                     dx21, dy21,
 526                                                     dx12, dy12,
 527                                                     lwr21, lwr12);
 528                     break;
 529                 }
 530 
 531                 // fill ops
 532                 case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
 533                 {
 534                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 535 
 536                     if ([mtlc useXORComposite]) {
 537                         commitEncodedCommands();
 538                         J2dTraceLn(J2D_TRACE_VERBOSE,
 539                                    &quot;FILL_RECT in XOR mode - Force commit earlier draw calls before FILL_RECT.&quot;);
 540                     }
 541 
 542                     jint x = NEXT_INT(b);
 543                     jint y = NEXT_INT(b);
 544                     jint w = NEXT_INT(b);
 545                     jint h = NEXT_INT(b);
 546                     MTLRenderer_FillRect(mtlc, dstOps, x, y, w, h);
 547                     break;
 548                 }
 549                 case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
 550                 {
 551                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 552 
 553                     if ([mtlc useXORComposite]) {
 554                         commitEncodedCommands();
 555                         J2dTraceLn(J2D_TRACE_VERBOSE,
 556                                    &quot;FILL_SPANS in XOR mode - Force commit earlier draw calls before FILL_SPANS.&quot;);
 557                     }
 558 
 559                     jint count = NEXT_INT(b);
 560                     MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
 561                     SKIP_BYTES(b, count * BYTES_PER_SPAN);
 562                     break;
 563                 }
 564                 case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
 565                 {
 566                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 567 
 568                     if ([mtlc useXORComposite]) {
 569                         commitEncodedCommands();
 570                         J2dTraceLn(J2D_TRACE_VERBOSE,
 571                                    &quot;FILL_PARALLELOGRAM in XOR mode - Force commit earlier draw calls before &quot;
 572                                    &quot;FILL_PARALLELOGRAM.&quot;);
 573                     }
 574 
 575                     jfloat x11 = NEXT_FLOAT(b);
 576                     jfloat y11 = NEXT_FLOAT(b);
 577                     jfloat dx21 = NEXT_FLOAT(b);
 578                     jfloat dy21 = NEXT_FLOAT(b);
 579                     jfloat dx12 = NEXT_FLOAT(b);
 580                     jfloat dy12 = NEXT_FLOAT(b);
 581                     MTLRenderer_FillParallelogram(mtlc, dstOps,
 582                                                   x11, y11,
 583                                                   dx21, dy21,
 584                                                   dx12, dy12);
 585                     break;
 586                 }
 587                 case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
 588                 {
 589                     CHECK_PREVIOUS_OP(MTL_OP_AA);
 590                     jfloat x11 = NEXT_FLOAT(b);
 591                     jfloat y11 = NEXT_FLOAT(b);
 592                     jfloat dx21 = NEXT_FLOAT(b);
 593                     jfloat dy21 = NEXT_FLOAT(b);
 594                     jfloat dx12 = NEXT_FLOAT(b);
 595                     jfloat dy12 = NEXT_FLOAT(b);
 596                     MTLRenderer_FillAAParallelogram(mtlc, dstOps,
 597                                                     x11, y11,
 598                                                     dx21, dy21,
 599                                                     dx12, dy12);
 600                     break;
 601                 }
 602 
 603                 // text-related ops
 604                 case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
 605                 {
 606                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 607 
 608                     if ([mtlc useXORComposite]) {
 609                         commitEncodedCommands();
 610                         J2dTraceLn(J2D_TRACE_VERBOSE,
 611                                    &quot;DRAW_GLYPH_LIST in XOR mode - Force commit earlier draw calls before &quot;
 612                                    &quot;DRAW_GLYPH_LIST.&quot;);
 613                     }
 614 
 615                     jint numGlyphs        = NEXT_INT(b);
 616                     jint packedParams     = NEXT_INT(b);
 617                     jfloat glyphListOrigX = NEXT_FLOAT(b);
 618                     jfloat glyphListOrigY = NEXT_FLOAT(b);
 619                     jboolean usePositions = EXTRACT_BOOLEAN(packedParams,
 620                                                             OFFSET_POSITIONS);
 621                     jboolean subPixPos    = EXTRACT_BOOLEAN(packedParams,
 622                                                             OFFSET_SUBPIXPOS);
 623                     jboolean rgbOrder     = EXTRACT_BOOLEAN(packedParams,
 624                                                             OFFSET_RGBORDER);
 625                     jint lcdContrast      = EXTRACT_BYTE(packedParams,
 626                                                          OFFSET_CONTRAST);
 627                     unsigned char *images = b;
 628                     unsigned char *positions;
 629                     jint bytesPerGlyph;
 630                     if (usePositions) {
 631                         positions = (b + numGlyphs * BYTES_PER_GLYPH_IMAGE);
 632                         bytesPerGlyph = BYTES_PER_POSITIONED_GLYPH;
 633                     } else {
 634                         positions = NULL;
 635                         bytesPerGlyph = BYTES_PER_GLYPH_IMAGE;
 636                     }
 637                     MTLTR_DrawGlyphList(env, mtlc, dstOps,
 638                                         numGlyphs, usePositions,
 639                                         subPixPos, rgbOrder, lcdContrast,
 640                                         glyphListOrigX, glyphListOrigY,
 641                                         images, positions);
 642                     SKIP_BYTES(b, numGlyphs * bytesPerGlyph);
 643                     break;
 644                 }
 645 
 646                 // copy-related ops
 647                 case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
 648                 {
 649                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 650                     jint x  = NEXT_INT(b);
 651                     jint y  = NEXT_INT(b);
 652                     jint w  = NEXT_INT(b);
 653                     jint h  = NEXT_INT(b);
 654                     jint dx = NEXT_INT(b);
 655                     jint dy = NEXT_INT(b);
 656                     MTLBlitLoops_CopyArea(env, mtlc, dstOps,
 657                                           x, y, w, h, dx, dy);
 658                     break;
 659                 }
 660                 case sun_java2d_pipe_BufferedOpCodes_BLIT:
 661                 {
 662                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 663                     jint packedParams = NEXT_INT(b);
 664                     jint sx1          = NEXT_INT(b);
 665                     jint sy1          = NEXT_INT(b);
 666                     jint sx2          = NEXT_INT(b);
 667                     jint sy2          = NEXT_INT(b);
 668                     jdouble dx1       = NEXT_DOUBLE(b);
 669                     jdouble dy1       = NEXT_DOUBLE(b);
 670                     jdouble dx2       = NEXT_DOUBLE(b);
 671                     jdouble dy2       = NEXT_DOUBLE(b);
 672                     jlong pSrc        = NEXT_LONG(b);
 673                     jlong pDst        = NEXT_LONG(b);
 674                     jint hint         = EXTRACT_BYTE(packedParams, OFFSET_HINT);
 675                     jboolean texture  = EXTRACT_BOOLEAN(packedParams,
 676                                                         OFFSET_TEXTURE);
 677                     jboolean xform    = EXTRACT_BOOLEAN(packedParams,
 678                                                         OFFSET_XFORM);
 679                     jboolean isoblit  = EXTRACT_BOOLEAN(packedParams,
 680                                                         OFFSET_ISOBLIT);
 681                     if (isoblit) {
 682                         MTLBlitLoops_IsoBlit(env, mtlc, pSrc, pDst,
 683                                              xform, hint, texture,
 684                                              sx1, sy1, sx2, sy2,
 685                                              dx1, dy1, dx2, dy2);
 686                     } else {
 687                         jint srctype = EXTRACT_BYTE(packedParams, OFFSET_SRCTYPE);
 688                         MTLBlitLoops_Blit(env, mtlc, pSrc, pDst,
 689                                           xform, hint, srctype, texture,
 690                                           sx1, sy1, sx2, sy2,
 691                                           dx1, dy1, dx2, dy2);
 692                     }
 693                     break;
 694                 }
 695                 case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
 696                 {
 697                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 698                     jint sx      = NEXT_INT(b);
 699                     jint sy      = NEXT_INT(b);
 700                     jint dx      = NEXT_INT(b);
 701                     jint dy      = NEXT_INT(b);
 702                     jint w       = NEXT_INT(b);
 703                     jint h       = NEXT_INT(b);
 704                     jint dsttype = NEXT_INT(b);
 705                     jlong pSrc   = NEXT_LONG(b);
 706                     jlong pDst   = NEXT_LONG(b);
 707                     MTLBlitLoops_SurfaceToSwBlit(env, mtlc,
 708                                                  pSrc, pDst, dsttype,
 709                                                  sx, sy, dx, dy, w, h);
 710                     break;
 711                 }
 712                 case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
 713                 {
 714                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 715                     jint x        = NEXT_INT(b);
 716                     jint y        = NEXT_INT(b);
 717                     jint w        = NEXT_INT(b);
 718                     jint h        = NEXT_INT(b);
 719                     jint maskoff  = NEXT_INT(b);
 720                     jint maskscan = NEXT_INT(b);
 721                     jint masklen  = NEXT_INT(b);
 722                     unsigned char *pMask = (masklen &gt; 0) ? b : NULL;
 723                     MTLMaskFill_MaskFill(mtlc, dstOps, x, y, w, h,
 724                                          maskoff, maskscan, masklen, pMask);
 725                     SKIP_BYTES(b, masklen);
 726                     break;
 727                 }
 728                 case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
 729                 {
 730                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 731                     jint dstx     = NEXT_INT(b);
 732                     jint dsty     = NEXT_INT(b);
 733                     jint width    = NEXT_INT(b);
 734                     jint height   = NEXT_INT(b);
 735                     jint masklen  = width * height * sizeof(jint);
 736                     MTLMaskBlit_MaskBlit(env, mtlc, dstOps,
 737                                          dstx, dsty, width, height, b);
 738                     SKIP_BYTES(b, masklen);
 739                     break;
 740                 }
 741 
 742                 // state-related ops
 743                 case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
 744                 {
 745                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 746                     jint x1 = NEXT_INT(b);
 747                     jint y1 = NEXT_INT(b);
 748                     jint x2 = NEXT_INT(b);
 749                     jint y2 = NEXT_INT(b);
 750                     [mtlc setClipRectX1:x1 Y1:y1 X2:x2 Y2:y2];
 751                     break;
 752                 }
 753                 case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
 754                 {
 755                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 756                     [mtlc beginShapeClip:dstOps];
 757                     break;
 758                 }
 759                 case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
 760                 {
 761                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 762                     // This results in creation of new render encoder with
 763                     // stencil buffer set as render target
 764                     jint count = NEXT_INT(b);
 765                     MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
 766                     SKIP_BYTES(b, count * BYTES_PER_SPAN);
 767                     break;
 768                 }
 769                 case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
 770                 {
 771                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 772                     [mtlc endShapeClip:dstOps];
 773                     break;
 774                 }
 775                 case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
 776                 {
 777                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 778                     [mtlc resetClip];
 779                     break;
 780                 }
 781                 case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
 782                 {
 783                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 784                     jint rule         = NEXT_INT(b);
 785                     jfloat extraAlpha = NEXT_FLOAT(b);
 786                     jint flags        = NEXT_INT(b);
 787                     [mtlc setAlphaCompositeRule:rule extraAlpha:extraAlpha flags:flags];
 788                     break;
 789                 }
 790                 case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
 791                 {
 792                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 793                     jint xorPixel = NEXT_INT(b);
 794                     [mtlc setXorComposite:xorPixel];
 795                     break;
 796                 }
 797                 case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
 798                 {
 799                     /* TODO: check whether something needs to be done here if we are moving out of XOR composite
 800                     commitEncodedCommands();
 801                     MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
 802                     [cbwrapper onComplete];
 803 
 804                     J2dTraceLn(J2D_TRACE_VERBOSE,
 805                      &quot;RESET_COMPOSITE - Force commit earlier draw calls before RESET_COMPOSITE.&quot;);*/
 806 
 807                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 808                     [mtlc resetComposite];
 809                     break;
 810                 }
 811                 case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
 812                 {
 813                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 814                     jdouble m00 = NEXT_DOUBLE(b);
 815                     jdouble m10 = NEXT_DOUBLE(b);
 816                     jdouble m01 = NEXT_DOUBLE(b);
 817                     jdouble m11 = NEXT_DOUBLE(b);
 818                     jdouble m02 = NEXT_DOUBLE(b);
 819                     jdouble m12 = NEXT_DOUBLE(b);
 820                     [mtlc setTransformM00:m00 M10:m10 M01:m01 M11:m11 M02:m02 M12:m12];
 821                     break;
 822                 }
 823                 case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
 824                 {
 825                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 826                     [mtlc resetTransform];
 827                     break;
 828                 }
 829 
 830                 // context-related ops
 831                 case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
 832                 {
 833                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 834                     jlong pSrc = NEXT_LONG(b);
 835                     jlong pDst = NEXT_LONG(b);
 836 
 837                     dstOps = (BMTLSDOps *)jlong_to_ptr(pDst);
<a name="1" id="anc1"></a>


 838                     mtlc = [MTLContext setSurfacesEnv:env src:pSrc dst:pDst];
 839                     break;
 840                 }
 841                 case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
 842                 {
 843                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 844                     jlong pConfigInfo = NEXT_LONG(b);
 845                     MTLGraphicsConfigInfo *mtlInfo =
 846                             (MTLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);
 847 
 848                     if (mtlInfo == NULL) {
 849 
 850                     } else {
 851                         MTLContext *newMtlc = mtlInfo-&gt;context;
 852                         if (newMtlc == NULL) {
 853 
 854                         } else {
<a name="2" id="anc2"></a>


 855                             mtlc = newMtlc;
 856                             dstOps = NULL;
 857                         }
 858                     }
 859                     break;
 860                 }
 861                 case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
 862                 {
 863                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 864                     jlong pData = NEXT_LONG(b);
 865                     BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
 866                     if (mtlsdo != NULL) {
 867                         CONTINUE_IF_NULL(mtlc);
 868                         MTLSD_Delete(env, mtlsdo);
 869                     }
 870                     break;
 871                 }
 872                 case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
 873                 {
 874                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 875                     jlong pData = NEXT_LONG(b);
 876                     BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
 877                     if (mtlsdo != NULL) {
 878                         CONTINUE_IF_NULL(mtlc);
 879                         MTLSD_Delete(env, mtlsdo);
 880                         if (mtlsdo-&gt;privOps != NULL) {
 881                             free(mtlsdo-&gt;privOps);
 882                         }
 883                     }
 884                     break;
 885                 }
 886                 case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
 887                 {
 888                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 889                     jlong pConfigInfo = NEXT_LONG(b);
 890                     CONTINUE_IF_NULL(mtlc);
 891                     MTLGC_DestroyMTLGraphicsConfig(pConfigInfo);
 892 
 893                     // the previous method will call glX/wglMakeCurrent(None),
 894                     // so we should nullify the current mtlc and dstOps to avoid
 895                     // calling glFlush() (or similar) while no context is current
<a name="3" id="anc3"></a>


 896                     mtlc = NULL;
 897                  //   dstOps = NULL;
 898                     break;
 899                 }
 900                 case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
 901                 {
 902                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 903                     // invalidate the references to the current context and
 904                     // destination surface that are maintained at the native level
<a name="4" id="anc4"></a>


 905                     mtlc = NULL;
 906                 //    dstOps = NULL;
 907                     break;
 908                 }
 909                 case sun_java2d_pipe_BufferedOpCodes_SYNC:
 910                 {
 911                     CHECK_PREVIOUS_OP(MTL_OP_SYNC);
 912                     break;
 913                 }
 914 
 915                 // multibuffering ops
 916                 case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
 917                 {
 918                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 919                     jlong window = NEXT_LONG(b);
 920                     MTLSD_SwapBuffers(env, window);
 921                     break;
 922                 }
 923 
 924                 // special no-op (mainly used for achieving 8-byte alignment)
 925                 case sun_java2d_pipe_BufferedOpCodes_NOOP:
 926                     break;
 927 
 928                 // paint-related ops
 929                 case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
 930                 {
 931                   CHECK_PREVIOUS_OP(MTL_OP_RESET_PAINT);
 932                   [mtlc resetPaint];
 933                     break;
 934                 }
 935                 case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
 936                 {
 937                     CHECK_PREVIOUS_OP(MTL_OP_SET_COLOR);
 938                     jint pixel = NEXT_INT(b);
 939                     [mtlc setColorPaint:pixel];
 940                     break;
 941                 }
 942                 case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
 943                 {
 944                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 945                     jboolean useMask= NEXT_BOOLEAN(b);
 946                     jboolean cyclic = NEXT_BOOLEAN(b);
 947                     jdouble p0      = NEXT_DOUBLE(b);
 948                     jdouble p1      = NEXT_DOUBLE(b);
 949                     jdouble p3      = NEXT_DOUBLE(b);
 950                     jint pixel1     = NEXT_INT(b);
 951                     jint pixel2     = NEXT_INT(b);
 952                     [mtlc setGradientPaintUseMask:useMask
 953                                         cyclic:cyclic
 954                                             p0:p0
 955                                             p1:p1
 956                                             p3:p3
 957                                         pixel1:pixel1
 958                                         pixel2:pixel2];
 959                     break;
 960                 }
 961                 case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
 962                 {
 963                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 964                     jboolean useMask = NEXT_BOOLEAN(b);
 965                     jboolean linear  = NEXT_BOOLEAN(b);
 966                     jint cycleMethod = NEXT_INT(b);
 967                     jint numStops    = NEXT_INT(b);
 968                     jfloat p0        = NEXT_FLOAT(b);
 969                     jfloat p1        = NEXT_FLOAT(b);
 970                     jfloat p3        = NEXT_FLOAT(b);
 971                     void *fractions, *pixels;
 972                     fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
 973                     pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
 974                     [mtlc setLinearGradientPaint:useMask
 975                                           linear:linear
 976                                      cycleMethod:cycleMethod
 977                                         numStops:numStops
 978                                               p0:p0
 979                                               p1:p1
 980                                               p3:p3
 981                                        fractions:fractions
 982                                           pixels:pixels];
 983                     break;
 984                 }
 985                 case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
 986                 {
 987                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 988                     jboolean useMask = NEXT_BOOLEAN(b);
 989                     jboolean linear  = NEXT_BOOLEAN(b);
 990                     jint numStops    = NEXT_INT(b);
 991                     jint cycleMethod = NEXT_INT(b);
 992                     jfloat m00       = NEXT_FLOAT(b);
 993                     jfloat m01       = NEXT_FLOAT(b);
 994                     jfloat m02       = NEXT_FLOAT(b);
 995                     jfloat m10       = NEXT_FLOAT(b);
 996                     jfloat m11       = NEXT_FLOAT(b);
 997                     jfloat m12       = NEXT_FLOAT(b);
 998                     jfloat focusX    = NEXT_FLOAT(b);
 999                     void *fractions, *pixels;
1000                     fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
1001                     pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
1002                     [mtlc setRadialGradientPaint:useMask
1003                                           linear:linear
1004                                      cycleMethod:cycleMethod
1005                                         numStops:numStops
1006                                              m00:m00
1007                                              m01:m01
1008                                              m02:m02
1009                                              m10:m10
1010                                              m11:m11
1011                                              m12:m12
1012                                           focusX:focusX
1013                                        fractions:fractions
1014                                           pixels:pixels];
1015                     break;
1016                 }
1017                 case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
1018                 {
1019                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1020                     jboolean useMask= NEXT_BOOLEAN(b);
1021                     jboolean filter = NEXT_BOOLEAN(b);
1022                     jlong pSrc      = NEXT_LONG(b);
1023                     jdouble xp0     = NEXT_DOUBLE(b);
1024                     jdouble xp1     = NEXT_DOUBLE(b);
1025                     jdouble xp3     = NEXT_DOUBLE(b);
1026                     jdouble yp0     = NEXT_DOUBLE(b);
1027                     jdouble yp1     = NEXT_DOUBLE(b);
1028                     jdouble yp3     = NEXT_DOUBLE(b);
1029                     [mtlc setTexturePaint:useMask
1030                                   pSrcOps:pSrc
1031                                    filter:filter
1032                                       xp0:xp0
1033                                       xp1:xp1
1034                                       xp3:xp3
1035                                       yp0:yp0
1036                                       yp1:yp1
1037                                       yp3:yp3];
1038                     break;
1039                 }
1040 
1041                 // BufferedImageOp-related ops
1042                 case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
1043                 {
1044                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1045                     jlong pSrc        = NEXT_LONG(b);
1046                     jboolean edgeZero = NEXT_BOOLEAN(b);
1047                     jint kernelWidth  = NEXT_INT(b);
1048                     jint kernelHeight = NEXT_INT(b);
1049 
1050                     BMTLSDOps * bmtlsdOps = (BMTLSDOps *)pSrc;
1051                     MTLConvolveOp * convolveOp = [[MTLConvolveOp alloc] init:edgeZero
1052                             kernelWidth:kernelWidth
1053                            kernelHeight:kernelHeight
1054                                srcWidth:bmtlsdOps-&gt;width
1055                               srcHeight:bmtlsdOps-&gt;height
1056                                  kernel:b
1057                                  device:mtlc.device
1058                                                   ];
1059                     [mtlc setBufImgOp:convolveOp];
1060                     SKIP_BYTES(b, kernelWidth * kernelHeight * sizeof(jfloat));
1061                     break;
1062                 }
1063                 case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
1064                 {
1065                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1066                     [mtlc setBufImgOp:NULL];
1067                     break;
1068                 }
1069                 case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
1070                 {
1071                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1072                     jlong pSrc          = NEXT_LONG(b);
1073                     jboolean nonPremult = NEXT_BOOLEAN(b);
1074                     jint numFactors     = 4;
1075                     unsigned char *scaleFactors = b;
1076                     unsigned char *offsets = (b + numFactors * sizeof(jfloat));
1077                     MTLRescaleOp * rescaleOp =
1078                             [[MTLRescaleOp alloc] init:nonPremult factors:scaleFactors offsets:offsets];
1079                     [mtlc setBufImgOp:rescaleOp];
1080                     SKIP_BYTES(b, numFactors * sizeof(jfloat) * 2);
1081                     break;
1082                 }
1083                 case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
1084                 {
1085                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1086                     [mtlc setBufImgOp:NULL];
1087                     break;
1088                 }
1089                 case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
1090                 {
1091                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1092                     jlong pSrc          = NEXT_LONG(b);
1093                     jboolean nonPremult = NEXT_BOOLEAN(b);
1094                     jboolean shortData  = NEXT_BOOLEAN(b);
1095                     jint numBands       = NEXT_INT(b);
1096                     jint bandLength     = NEXT_INT(b);
1097                     jint offset         = NEXT_INT(b);
1098                     jint bytesPerElem = shortData ? sizeof(jshort):sizeof(jbyte);
1099                     void *tableValues = b;
1100 
1101                     MTLLookupOp * lookupOp = [[MTLLookupOp alloc] init:nonPremult
1102                                                              shortData:shortData
1103                                                               numBands:numBands
1104                                                             bandLength:bandLength
1105                                                                 offset:offset
1106                                                            tableValues:tableValues
1107                                                                 device:mtlc.device];
1108                     [mtlc setBufImgOp:lookupOp];
1109                     SKIP_BYTES(b, numBands * bandLength * bytesPerElem);
1110                     break;
1111                 }
1112                 case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
1113                 {
1114                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1115                     [mtlc setBufImgOp:NULL];
1116                     break;
1117                 }
1118 
1119                 default:
1120                     J2dRlsTraceLn1(J2D_TRACE_ERROR,
1121                         &quot;MTLRenderQueue_flushBuffer: invalid opcode=%d&quot;, opcode);
1122                     return;
1123             }
1124         }
1125 
1126         if (mtlc != NULL) {
1127             [mtlc.encoderManager endEncoder];
1128             MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
1129             id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
1130             [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
1131                 [cbwrapper release];
1132             }];
1133             [commandbuf commit];
1134             BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
1135             if (dstOps != NULL) {
1136                 MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps-&gt;privOps;
1137                 MTLLayer *layer = (MTLLayer*)dstMTLOps-&gt;layer;
1138                 if (layer != NULL) {
1139                     [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){
1140                         AWT_ASSERT_APPKIT_THREAD;
1141                         [layer setNeedsDisplay];
1142                     }];
1143                 }
1144             }
1145         }
1146         RESET_PREVIOUS_OP();
1147     }
1148 }
1149 
1150 /**
1151  * Returns a pointer to the &quot;current&quot; context, as set by the last SET_SURFACES
1152  * or SET_SCRATCH_SURFACE operation.
1153  */
1154 MTLContext *
1155 MTLRenderQueue_GetCurrentContext()
1156 {
1157     return mtlc;
1158 }
1159 
1160 /**
1161  * Returns a pointer to the &quot;current&quot; destination surface, as set by the last
1162  * SET_SURFACES operation.
1163  */
1164 BMTLSDOps *
1165 MTLRenderQueue_GetCurrentDestination()
1166 {
1167     return dstOps;
1168 }
1169 
1170 /**
1171  * commit earlier encoded commmands
1172  * these would be rendered to the back-buffer - which is read in shader while rendering in XOR mode
1173  */
1174 void commitEncodedCommands() {
1175     [mtlc.encoderManager endEncoder];
1176 
1177     MTLCommandBufferWrapper *cbwrapper = [mtlc pullCommandBufferWrapper];
1178     id &lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
1179     [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
1180         [cbwrapper release];
1181     }];
1182     [commandbuf commit];
1183     [commandbuf waitUntilCompleted];
1184 }
1185 
1186 #endif /* !HEADLESS */
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>