<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifndef HEADLESS
  27 
  28 #include &lt;stdlib.h&gt;
  29 
  30 #include &quot;sun_java2d_pipe_BufferedOpCodes.h&quot;
  31 
  32 #include &quot;jlong.h&quot;
  33 #include &quot;MTLBlitLoops.h&quot;
  34 #include &quot;MTLBufImgOps.h&quot;
  35 #include &quot;MTLMaskBlit.h&quot;
  36 #include &quot;MTLMaskFill.h&quot;
  37 #include &quot;MTLPaints.h&quot;
  38 #include &quot;MTLRenderQueue.h&quot;
  39 #include &quot;MTLRenderer.h&quot;
  40 #include &quot;MTLTextRenderer.h&quot;
  41 #import &quot;ThreadUtilities.h&quot;
  42 
  43 /**
  44  * References to the &quot;current&quot; context and destination surface.
  45  */
  46 static MTLContext *mtlc = NULL;
  47 static BMTLSDOps *dstOps = NULL;
  48 jint mtlPreviousOp = MTL_OP_INIT;
  49 
  50 
  51 /**
  52  * The following methods are implemented in the windowing system (i.e. GLX
  53  * and WGL) source files.
  54  */
  55 extern void MTLGC_DestroyMTLGraphicsConfig(jlong pConfigInfo);
  56 extern void MTLSD_SwapBuffers(JNIEnv *env, jlong window);
  57 
  58 // TODO : Debug logic added for opcode verification,
  59 // should be removed later.
  60 static char *getOpcodeString(jint opcode) {
  61     static char opName[30];
  62     switch (opcode) {
  63         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
  64             {
  65                 strcpy(opName, &quot;DRAW_LINE&quot;);
  66             }
  67             break;
  68         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
  69             {
  70                 strcpy(opName, &quot;DRAW_RECT&quot;);
  71             }
  72             break;
  73         case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
  74             {
  75                 strcpy(opName, &quot;DRAW_POLY&quot;);
  76             }
  77             break;
  78         case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
  79             {
  80                 strcpy(opName, &quot;DRAW_PIXEL&quot;);
  81             }
  82             break;
  83         case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
  84             {
  85                 strcpy(opName, &quot;DRAW_SCANLINES&quot;);
  86             }
  87             break;
  88         case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
  89             {
  90                 strcpy(opName, &quot;DRAW_PARALLELOGRAM&quot;);
  91             }
  92             break;
  93         case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
  94             {
  95                 strcpy(opName, &quot;DRAW_AAPARALLELOGRAM&quot;);
  96             }
  97             break;
  98         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
  99             {
 100                 strcpy(opName, &quot;FILL_RECT&quot;);
 101             }
 102             break;
 103         case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
 104             {
 105                 strcpy(opName, &quot;FILL_SPANS&quot;);
 106             }
 107             break;
 108         case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
 109             {
 110                 strcpy(opName, &quot;FILL_PARALLELOGRAM&quot;);
 111             }
 112             break;
 113         case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
 114             {
 115                 strcpy(opName, &quot;FILL_AAPARALLELOGRAM&quot;);
 116             }
 117             break;
 118         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
 119             {
 120                 strcpy(opName, &quot;DRAW_GLYPH_LIST&quot;);
 121             }
 122             break;
 123         case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
 124             {
 125                 strcpy(opName, &quot;COPY_AREA&quot;);
 126             }
 127             break;
 128         case sun_java2d_pipe_BufferedOpCodes_BLIT:
 129             {
 130                 strcpy(opName, &quot;BLIT&quot;);
 131             }
 132             break;
 133         case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
 134             {
 135                 strcpy(opName, &quot;SURFACE_TO_SW_BLIT&quot;);
 136             }
 137             break;
 138         case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
 139             {
 140                 strcpy(opName, &quot;MASK_FILL&quot;);
 141             }
 142             break;
 143         case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
 144             {
 145 
 146                 strcpy(opName, &quot;MASK_BLIT&quot;);
 147             }
 148             break;
 149         case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
 150             {
 151                 strcpy(opName, &quot;SET_RECT_CLIP&quot;);
 152             }
 153             break;
 154         case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
 155             {
 156                 strcpy(opName, &quot;BEGIN_SHAPE_CLIP&quot;);
 157             }
 158             break;
 159         case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
 160             {
 161                 strcpy(opName, &quot;SET_SHAPE_CLIP_SPANS&quot;);
 162             }
 163             break;
 164         case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
 165             {
 166                 strcpy(opName, &quot;END_SHAPE_CLIP&quot;);
 167             }
 168             break;
 169         case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
 170             {
 171                 strcpy(opName, &quot;RESET_CLIP&quot;);
 172             }
 173             break;
 174         case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
 175             {
 176                 strcpy(opName, &quot;SET_ALPHA_COMPOSITE&quot;);
 177             }
 178             break;
 179         case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
 180             {
 181                 strcpy(opName, &quot;SET_XOR_COMPOSITE&quot;);
 182             }
 183             break;
 184         case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
 185             {
 186                 strcpy(opName, &quot;RESET_COMPOSITE&quot;);
 187             }
 188             break;
 189         case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
 190             {
 191                 strcpy(opName, &quot;SET_TRANSFORM&quot;);
 192             }
 193             break;
 194         case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
 195             {
 196                 strcpy(opName, &quot;RESET_TRANSFORM&quot;);
 197             }
 198             break;
 199         case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
 200             {
 201 
 202                 strcpy(opName, &quot;SET_SURFACES&quot;);
 203             }
 204             break;
 205         case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
 206             {
 207                 strcpy(opName, &quot;SET_SCRATCH_SURFACE&quot;);
 208             }
 209             break;
 210         case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
 211             {
 212                 strcpy(opName, &quot;FLUSH_SURFACE&quot;);
 213             }
 214             break;
 215         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
 216             {
 217                 strcpy(opName, &quot;DISPOSE_SURFACE&quot;);
 218             }
 219             break;
 220         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
 221             {
 222                 strcpy(opName, &quot;DISPOSE_CONFIG&quot;);
 223             }
 224             break;
 225         case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
 226             {
 227                 strcpy(opName, &quot;INVALIDATE_CONTEXT&quot;);
 228             }
 229             break;
 230         case sun_java2d_pipe_BufferedOpCodes_SYNC:
 231             {
 232                 strcpy(opName, &quot;SYNC&quot;);
 233 
 234             }
 235             break;
 236         case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
 237             {
 238                 strcpy(opName, &quot;SWAP_BUFFERS&quot;);
 239             }
 240             break;
 241         case sun_java2d_pipe_BufferedOpCodes_NOOP:
 242             strcpy(opName, &quot;NOOP&quot;);
 243             break;
 244         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
 245             {
 246                 strcpy(opName, &quot;RESET_PAINT&quot;);
 247             }
 248             break;
 249         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
 250             {
 251                 strcpy(opName, &quot;SET_COLOR&quot;);
 252             }
 253             break;
 254         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
 255             {
 256                 strcpy(opName, &quot;SET_GRADIENT_PAINT&quot;);
 257             }
 258             break;
 259         case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
 260             {
 261                 strcpy(opName, &quot;SET_LINEAR_GRADIENT_PAINT&quot;);
 262             }
 263             break;
 264         case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
 265             {
 266                 strcpy(opName, &quot;SET_RADIAL_GRADIENT_PAINT&quot;);
 267             }
 268             break;
 269         case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
 270             {
 271                 strcpy(opName, &quot;SET_TEXTURE_PAINT&quot;);
 272             }
 273             break;
 274         case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
 275             {
 276                 strcpy(opName, &quot;ENABLE_CONVOLVE_OP&quot;);
 277             }
 278             break;
 279         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
 280             {
 281                 strcpy(opName, &quot;DISABLE_CONVOLVE_OP&quot;);
 282             }
 283             break;
 284         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
 285             {
 286                 strcpy(opName, &quot;ENABLE_RESCALE_OP&quot;);
 287             }
 288             break;
 289         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
 290             {
 291                  strcpy(opName, &quot;DISABLE_RESCALE_OP&quot;);
 292             }
 293             break;
 294         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
 295             {
 296                 strcpy(opName, &quot;ENABLE_LOOKUP_OP&quot;);
 297             }
 298             break;
 299         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
 300             {
 301                 strcpy(opName, &quot;DISABLE_LOOKUP_OP&quot;);
 302             }
 303             break;
 304         default:
 305             strcpy(opName, &quot;UNKNOWN&quot;);
 306             break;
 307         }
 308     return opName;
 309 }
 310 
 311 void MTLRenderQueue_CheckPreviousOp(jint op) {
 312 
 313     if (mtlPreviousOp == op) {
 314         // The op is the same as last time, so we can return immediately.
 315         return;
 316     }
 317 
 318     J2dTraceLn1(J2D_TRACE_VERBOSE,
 319                 &quot;MTLRenderQueue_CheckPreviousOp: new op=%d&quot;, op);
 320 
 321     if (op == MTL_OP_SET_COLOR) {
 322         return; // SET_COLOR should not cause endEncoder
 323     }
 324 
 325     if (mtlPreviousOp == MTL_OP_INIT) {
 326         mtlPreviousOp = op;
 327         return;
 328     }
 329 
 330     if (mtlc != NULL) {
 331         [mtlc.encoderManager endEncoder];
 332 
 333         if (op == MTL_OP_RESET_PAINT || op == MTL_OP_SYNC) {
 334             MTLCommandBufferWrapper *cbwrapper = [mtlc pullCommandBufferWrapper];
 335             id &lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
 336             [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
 337                 [cbwrapper release];
 338             }];
 339             [commandbuf commit];
 340             if (op == MTL_OP_SYNC) {
 341                 [commandbuf waitUntilCompleted];
 342             }
 343         }
 344     }
 345     mtlPreviousOp = op;
 346 }
 347 
 348 JNIEXPORT void JNICALL
 349 Java_sun_java2d_metal_MTLRenderQueue_flushBuffer
 350     (JNIEnv *env, jobject mtlrq,
 351      jlong buf, jint limit)
 352 {
 353     unsigned char *b, *end;
 354 
 355     J2dTraceLn1(J2D_TRACE_INFO,
 356                 &quot;MTLRenderQueue_flushBuffer: limit=%d&quot;, limit);
 357 
 358     b = (unsigned char *)jlong_to_ptr(buf);
 359     if (b == NULL) {
 360         J2dRlsTraceLn(J2D_TRACE_ERROR,
 361             &quot;MTLRenderQueue_flushBuffer: cannot get direct buffer address&quot;);
 362         return;
 363     }
 364 
 365     end = b + limit;
 366     @autoreleasepool {
 367         jboolean DEBUG_LOG = JNI_FALSE;
 368         while (b &lt; end) {
 369             jint opcode = NEXT_INT(b);
 370 
 371             if (DEBUG_LOG) {
 372                 J2dTraceLn2(J2D_TRACE_ERROR,
 373                         &quot;MTLRenderQueue_flushBuffer: opcode_name = %s, rem=%d&quot;,
 374                         getOpcodeString(opcode), (end-b));
 375             } else {
 376                 J2dTraceLn2(J2D_TRACE_VERBOSE,
 377                         &quot;MTLRenderQueue_flushBuffer: opcode=%d, rem=%d&quot;,
 378                         opcode, (end-b));
 379             }
 380 
 381             switch (opcode) {
 382 
 383                 // draw ops
 384                 case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
 385                 {
 386                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 387 
 388                     if ([mtlc useXORComposite]) {
 389                         commitEncodedCommands();
 390                         J2dTraceLn(J2D_TRACE_VERBOSE,
 391                                    &quot;DRAW_LINE in XOR mode - Force commit earlier draw calls before DRAW_LINE.&quot;);
 392                     }
 393                     jint x1 = NEXT_INT(b);
 394                     jint y1 = NEXT_INT(b);
 395                     jint x2 = NEXT_INT(b);
 396                     jint y2 = NEXT_INT(b);
 397                     MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);
 398                     break;
 399                 }
 400                 case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
 401                 {
 402                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 403 
 404                     if ([mtlc useXORComposite]) {
 405                         commitEncodedCommands();
 406                         J2dTraceLn(J2D_TRACE_VERBOSE,
 407                                    &quot;DRAW_RECT in XOR mode - Force commit earlier draw calls before DRAW_RECT.&quot;);
 408                     }
 409                     jint x = NEXT_INT(b);
 410                     jint y = NEXT_INT(b);
 411                     jint w = NEXT_INT(b);
 412                     jint h = NEXT_INT(b);
 413                     MTLRenderer_DrawRect(mtlc, dstOps, x, y, w, h);
 414                     break;
 415                 }
 416                 case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
 417                 {
 418                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 419                     jint nPoints      = NEXT_INT(b);
 420                     jboolean isClosed = NEXT_BOOLEAN(b);
 421                     jint transX       = NEXT_INT(b);
 422                     jint transY       = NEXT_INT(b);
 423                     jint *xPoints = (jint *)b;
 424                     jint *yPoints = ((jint *)b) + nPoints;
 425 
 426                     if ([mtlc useXORComposite]) {
 427                         commitEncodedCommands();
 428                         J2dTraceLn(J2D_TRACE_VERBOSE,
 429                                    &quot;DRAW_POLY in XOR mode - Force commit earlier draw calls before DRAW_POLY.&quot;);
 430 
 431                         // draw separate (N-1) lines using N points
 432                         for(int point = 0; point &lt; nPoints-1; point++) {
 433                             jint x1 = xPoints[point] + transX;
 434                             jint y1 = yPoints[point] + transY;
 435                             jint x2 = xPoints[point + 1] + transX;
 436                             jint y2 = yPoints[point + 1] + transY;
 437                             MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);
 438                         }
 439 
 440                         if (isClosed) {
 441                             MTLRenderer_DrawLine(mtlc, dstOps, xPoints[0] + transX, yPoints[0] + transY,
 442                                                  xPoints[nPoints-1] + transX, yPoints[nPoints-1] + transY);
 443                         }
 444                     } else {
 445                         MTLRenderer_DrawPoly(mtlc, dstOps, nPoints, isClosed, transX, transY, xPoints, yPoints);
 446                     }
 447 
 448                     SKIP_BYTES(b, nPoints * BYTES_PER_POLY_POINT);
 449                     break;
 450                 }
 451                 case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
 452                 {
 453                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 454 
 455                     if ([mtlc useXORComposite]) {
 456                         commitEncodedCommands();
 457                         J2dTraceLn(J2D_TRACE_VERBOSE,
 458                                    &quot;DRAW_PIXEL in XOR mode - Force commit earlier draw calls before DRAW_PIXEL.&quot;);
 459                     }
 460 
 461                     jint x = NEXT_INT(b);
 462                     jint y = NEXT_INT(b);
 463                     CONTINUE_IF_NULL(mtlc);
 464                     MTLRenderer_DrawPixel(mtlc, dstOps, x, y);
 465                     break;
 466                 }
 467                 case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
 468                 {
 469                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 470 
 471                     if ([mtlc useXORComposite]) {
 472                         commitEncodedCommands();
 473                         J2dTraceLn(J2D_TRACE_VERBOSE,
 474                                    &quot;DRAW_SCANLINES in XOR mode - Force commit earlier draw calls before &quot;
 475                                    &quot;DRAW_SCANLINES.&quot;);
 476                     }
 477 
 478                     jint count = NEXT_INT(b);
 479                     MTLRenderer_DrawScanlines(mtlc, dstOps, count, (jint *)b);
 480 
 481                     SKIP_BYTES(b, count * BYTES_PER_SCANLINE);
 482                     break;
 483                 }
 484                 case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
 485                 {
 486                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 487 
 488                     if ([mtlc useXORComposite]) {
 489                         commitEncodedCommands();
 490                         J2dTraceLn(J2D_TRACE_VERBOSE,
 491                                    &quot;DRAW_PARALLELOGRAM in XOR mode - Force commit earlier draw calls before &quot;
 492                                    &quot;DRAW_PARALLELOGRAM.&quot;);
 493                     }
 494 
 495                     jfloat x11 = NEXT_FLOAT(b);
 496                     jfloat y11 = NEXT_FLOAT(b);
 497                     jfloat dx21 = NEXT_FLOAT(b);
 498                     jfloat dy21 = NEXT_FLOAT(b);
 499                     jfloat dx12 = NEXT_FLOAT(b);
 500                     jfloat dy12 = NEXT_FLOAT(b);
 501                     jfloat lwr21 = NEXT_FLOAT(b);
 502                     jfloat lwr12 = NEXT_FLOAT(b);
 503 
 504                     MTLRenderer_DrawParallelogram(mtlc, dstOps,
 505                                                   x11, y11,
 506                                                   dx21, dy21,
 507                                                   dx12, dy12,
 508                                                   lwr21, lwr12);
 509                     break;
 510                 }
 511                 case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
 512                 {
 513                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 514                     jfloat x11 = NEXT_FLOAT(b);
 515                     jfloat y11 = NEXT_FLOAT(b);
 516                     jfloat dx21 = NEXT_FLOAT(b);
 517                     jfloat dy21 = NEXT_FLOAT(b);
 518                     jfloat dx12 = NEXT_FLOAT(b);
 519                     jfloat dy12 = NEXT_FLOAT(b);
 520                     jfloat lwr21 = NEXT_FLOAT(b);
 521                     jfloat lwr12 = NEXT_FLOAT(b);
 522 
 523                     MTLRenderer_DrawAAParallelogram(mtlc, dstOps,
 524                                                     x11, y11,
 525                                                     dx21, dy21,
 526                                                     dx12, dy12,
 527                                                     lwr21, lwr12);
 528                     break;
 529                 }
 530 
 531                 // fill ops
 532                 case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
 533                 {
 534                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 535 
 536                     if ([mtlc useXORComposite]) {
 537                         commitEncodedCommands();
 538                         J2dTraceLn(J2D_TRACE_VERBOSE,
 539                                    &quot;FILL_RECT in XOR mode - Force commit earlier draw calls before FILL_RECT.&quot;);
 540                     }
 541 
 542                     jint x = NEXT_INT(b);
 543                     jint y = NEXT_INT(b);
 544                     jint w = NEXT_INT(b);
 545                     jint h = NEXT_INT(b);
 546                     MTLRenderer_FillRect(mtlc, dstOps, x, y, w, h);
 547                     break;
 548                 }
 549                 case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
 550                 {
 551                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 552 
 553                     if ([mtlc useXORComposite]) {
 554                         commitEncodedCommands();
 555                         J2dTraceLn(J2D_TRACE_VERBOSE,
 556                                    &quot;FILL_SPANS in XOR mode - Force commit earlier draw calls before FILL_SPANS.&quot;);
 557                     }
 558 
 559                     jint count = NEXT_INT(b);
 560                     MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
 561                     SKIP_BYTES(b, count * BYTES_PER_SPAN);
 562                     break;
 563                 }
 564                 case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
 565                 {
 566                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 567 
 568                     if ([mtlc useXORComposite]) {
 569                         commitEncodedCommands();
 570                         J2dTraceLn(J2D_TRACE_VERBOSE,
 571                                    &quot;FILL_PARALLELOGRAM in XOR mode - Force commit earlier draw calls before &quot;
 572                                    &quot;FILL_PARALLELOGRAM.&quot;);
 573                     }
 574 
 575                     jfloat x11 = NEXT_FLOAT(b);
 576                     jfloat y11 = NEXT_FLOAT(b);
 577                     jfloat dx21 = NEXT_FLOAT(b);
 578                     jfloat dy21 = NEXT_FLOAT(b);
 579                     jfloat dx12 = NEXT_FLOAT(b);
 580                     jfloat dy12 = NEXT_FLOAT(b);
 581                     MTLRenderer_FillParallelogram(mtlc, dstOps,
 582                                                   x11, y11,
 583                                                   dx21, dy21,
 584                                                   dx12, dy12);
 585                     break;
 586                 }
 587                 case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
 588                 {
 589                     CHECK_PREVIOUS_OP(MTL_OP_AA);
 590                     jfloat x11 = NEXT_FLOAT(b);
 591                     jfloat y11 = NEXT_FLOAT(b);
 592                     jfloat dx21 = NEXT_FLOAT(b);
 593                     jfloat dy21 = NEXT_FLOAT(b);
 594                     jfloat dx12 = NEXT_FLOAT(b);
 595                     jfloat dy12 = NEXT_FLOAT(b);
 596                     MTLRenderer_FillAAParallelogram(mtlc, dstOps,
 597                                                     x11, y11,
 598                                                     dx21, dy21,
 599                                                     dx12, dy12);
 600                     break;
 601                 }
 602 
 603                 // text-related ops
 604                 case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
 605                 {
 606                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 607 
 608                     if ([mtlc useXORComposite]) {
 609                         commitEncodedCommands();
 610                         J2dTraceLn(J2D_TRACE_VERBOSE,
 611                                    &quot;DRAW_GLYPH_LIST in XOR mode - Force commit earlier draw calls before &quot;
 612                                    &quot;DRAW_GLYPH_LIST.&quot;);
 613                     }
 614 
 615                     jint numGlyphs        = NEXT_INT(b);
 616                     jint packedParams     = NEXT_INT(b);
 617                     jfloat glyphListOrigX = NEXT_FLOAT(b);
 618                     jfloat glyphListOrigY = NEXT_FLOAT(b);
 619                     jboolean usePositions = EXTRACT_BOOLEAN(packedParams,
 620                                                             OFFSET_POSITIONS);
 621                     jboolean subPixPos    = EXTRACT_BOOLEAN(packedParams,
 622                                                             OFFSET_SUBPIXPOS);
 623                     jboolean rgbOrder     = EXTRACT_BOOLEAN(packedParams,
 624                                                             OFFSET_RGBORDER);
 625                     jint lcdContrast      = EXTRACT_BYTE(packedParams,
 626                                                          OFFSET_CONTRAST);
 627                     unsigned char *images = b;
 628                     unsigned char *positions;
 629                     jint bytesPerGlyph;
 630                     if (usePositions) {
 631                         positions = (b + numGlyphs * BYTES_PER_GLYPH_IMAGE);
 632                         bytesPerGlyph = BYTES_PER_POSITIONED_GLYPH;
 633                     } else {
 634                         positions = NULL;
 635                         bytesPerGlyph = BYTES_PER_GLYPH_IMAGE;
 636                     }
 637                     MTLTR_DrawGlyphList(env, mtlc, dstOps,
 638                                         numGlyphs, usePositions,
 639                                         subPixPos, rgbOrder, lcdContrast,
 640                                         glyphListOrigX, glyphListOrigY,
 641                                         images, positions);
 642                     SKIP_BYTES(b, numGlyphs * bytesPerGlyph);
 643                     break;
 644                 }
 645 
 646                 // copy-related ops
 647                 case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
 648                 {
 649                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 650                     jint x  = NEXT_INT(b);
 651                     jint y  = NEXT_INT(b);
 652                     jint w  = NEXT_INT(b);
 653                     jint h  = NEXT_INT(b);
 654                     jint dx = NEXT_INT(b);
 655                     jint dy = NEXT_INT(b);
 656                     MTLBlitLoops_CopyArea(env, mtlc, dstOps,
 657                                           x, y, w, h, dx, dy);
 658                     break;
 659                 }
 660                 case sun_java2d_pipe_BufferedOpCodes_BLIT:
 661                 {
 662                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 663                     jint packedParams = NEXT_INT(b);
 664                     jint sx1          = NEXT_INT(b);
 665                     jint sy1          = NEXT_INT(b);
 666                     jint sx2          = NEXT_INT(b);
 667                     jint sy2          = NEXT_INT(b);
 668                     jdouble dx1       = NEXT_DOUBLE(b);
 669                     jdouble dy1       = NEXT_DOUBLE(b);
 670                     jdouble dx2       = NEXT_DOUBLE(b);
 671                     jdouble dy2       = NEXT_DOUBLE(b);
 672                     jlong pSrc        = NEXT_LONG(b);
 673                     jlong pDst        = NEXT_LONG(b);
 674                     jint hint         = EXTRACT_BYTE(packedParams, OFFSET_HINT);
 675                     jboolean texture  = EXTRACT_BOOLEAN(packedParams,
 676                                                         OFFSET_TEXTURE);
 677                     jboolean xform    = EXTRACT_BOOLEAN(packedParams,
 678                                                         OFFSET_XFORM);
 679                     jboolean isoblit  = EXTRACT_BOOLEAN(packedParams,
 680                                                         OFFSET_ISOBLIT);
 681                     if (isoblit) {
 682                         MTLBlitLoops_IsoBlit(env, mtlc, pSrc, pDst,
 683                                              xform, hint, texture,
 684                                              sx1, sy1, sx2, sy2,
 685                                              dx1, dy1, dx2, dy2);
 686                     } else {
 687                         jint srctype = EXTRACT_BYTE(packedParams, OFFSET_SRCTYPE);
 688                         MTLBlitLoops_Blit(env, mtlc, pSrc, pDst,
 689                                           xform, hint, srctype, texture,
 690                                           sx1, sy1, sx2, sy2,
 691                                           dx1, dy1, dx2, dy2);
 692                     }
 693                     break;
 694                 }
 695                 case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
 696                 {
 697                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 698                     jint sx      = NEXT_INT(b);
 699                     jint sy      = NEXT_INT(b);
 700                     jint dx      = NEXT_INT(b);
 701                     jint dy      = NEXT_INT(b);
 702                     jint w       = NEXT_INT(b);
 703                     jint h       = NEXT_INT(b);
 704                     jint dsttype = NEXT_INT(b);
 705                     jlong pSrc   = NEXT_LONG(b);
 706                     jlong pDst   = NEXT_LONG(b);
 707                     MTLBlitLoops_SurfaceToSwBlit(env, mtlc,
 708                                                  pSrc, pDst, dsttype,
 709                                                  sx, sy, dx, dy, w, h);
 710                     break;
 711                 }
 712                 case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
 713                 {
 714                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 715                     jint x        = NEXT_INT(b);
 716                     jint y        = NEXT_INT(b);
 717                     jint w        = NEXT_INT(b);
 718                     jint h        = NEXT_INT(b);
 719                     jint maskoff  = NEXT_INT(b);
 720                     jint maskscan = NEXT_INT(b);
 721                     jint masklen  = NEXT_INT(b);
 722                     unsigned char *pMask = (masklen &gt; 0) ? b : NULL;
 723                     MTLMaskFill_MaskFill(mtlc, dstOps, x, y, w, h,
 724                                          maskoff, maskscan, masklen, pMask);
 725                     SKIP_BYTES(b, masklen);
 726                     break;
 727                 }
 728                 case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
 729                 {
 730                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 731                     jint dstx     = NEXT_INT(b);
 732                     jint dsty     = NEXT_INT(b);
 733                     jint width    = NEXT_INT(b);
 734                     jint height   = NEXT_INT(b);
 735                     jint masklen  = width * height * sizeof(jint);
 736                     MTLMaskBlit_MaskBlit(env, mtlc, dstOps,
 737                                          dstx, dsty, width, height, b);
 738                     SKIP_BYTES(b, masklen);
 739                     break;
 740                 }
 741 
 742                 // state-related ops
 743                 case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
 744                 {
 745                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 746                     jint x1 = NEXT_INT(b);
 747                     jint y1 = NEXT_INT(b);
 748                     jint x2 = NEXT_INT(b);
 749                     jint y2 = NEXT_INT(b);
 750                     [mtlc setClipRectX1:x1 Y1:y1 X2:x2 Y2:y2];
 751                     break;
 752                 }
 753                 case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
 754                 {
 755                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 756                     [mtlc beginShapeClip:dstOps];
 757                     break;
 758                 }
 759                 case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
 760                 {
 761                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 762                     // This results in creation of new render encoder with
 763                     // stencil buffer set as render target
 764                     jint count = NEXT_INT(b);
 765                     MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
 766                     SKIP_BYTES(b, count * BYTES_PER_SPAN);
 767                     break;
 768                 }
 769                 case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
 770                 {
 771                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 772                     [mtlc endShapeClip:dstOps];
 773                     break;
 774                 }
 775                 case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
 776                 {
 777                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 778                     [mtlc resetClip];
 779                     break;
 780                 }
 781                 case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
 782                 {
 783                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 784                     jint rule         = NEXT_INT(b);
 785                     jfloat extraAlpha = NEXT_FLOAT(b);
 786                     jint flags        = NEXT_INT(b);
 787                     [mtlc setAlphaCompositeRule:rule extraAlpha:extraAlpha flags:flags];
 788                     break;
 789                 }
 790                 case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
 791                 {
 792                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 793                     jint xorPixel = NEXT_INT(b);
 794                     [mtlc setXorComposite:xorPixel];
 795                     break;
 796                 }
 797                 case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
 798                 {
 799                     /* TODO: check whether something needs to be done here if we are moving out of XOR composite
 800                     commitEncodedCommands();
 801                     MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
 802                     [cbwrapper onComplete];
 803 
 804                     J2dTraceLn(J2D_TRACE_VERBOSE,
 805                      &quot;RESET_COMPOSITE - Force commit earlier draw calls before RESET_COMPOSITE.&quot;);*/
 806 
 807                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 808                     [mtlc resetComposite];
 809                     break;
 810                 }
 811                 case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
 812                 {
 813                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 814                     jdouble m00 = NEXT_DOUBLE(b);
 815                     jdouble m10 = NEXT_DOUBLE(b);
 816                     jdouble m01 = NEXT_DOUBLE(b);
 817                     jdouble m11 = NEXT_DOUBLE(b);
 818                     jdouble m02 = NEXT_DOUBLE(b);
 819                     jdouble m12 = NEXT_DOUBLE(b);
 820                     [mtlc setTransformM00:m00 M10:m10 M01:m01 M11:m11 M02:m02 M12:m12];
 821                     break;
 822                 }
 823                 case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
 824                 {
 825                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 826                     [mtlc resetTransform];
 827                     break;
 828                 }
 829 
 830                 // context-related ops
 831                 case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
 832                 {
 833                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 834                     jlong pSrc = NEXT_LONG(b);
 835                     jlong pDst = NEXT_LONG(b);
 836 
 837                     dstOps = (BMTLSDOps *)jlong_to_ptr(pDst);
 838                     if (mtlc != NULL) {
 839                         [mtlc.encoderManager endEncoder];
 840                     }
 841                     mtlc = [MTLContext setSurfacesEnv:env src:pSrc dst:pDst];
 842                     break;
 843                 }
 844                 case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
 845                 {
 846                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 847                     jlong pConfigInfo = NEXT_LONG(b);
 848                     MTLGraphicsConfigInfo *mtlInfo =
 849                             (MTLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);
 850 
 851                     if (mtlInfo == NULL) {
 852 
 853                     } else {
 854                         MTLContext *newMtlc = mtlInfo-&gt;context;
 855                         if (newMtlc == NULL) {
 856 
 857                         } else {
 858                             if (mtlc != NULL) {
 859                                 [mtlc.encoderManager endEncoder];
 860                             }
 861                             mtlc = newMtlc;
 862                             dstOps = NULL;
 863                         }
 864                     }
 865                     break;
 866                 }
 867                 case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
 868                 {
 869                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 870                     jlong pData = NEXT_LONG(b);
 871                     BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
 872                     if (mtlsdo != NULL) {
 873                         CONTINUE_IF_NULL(mtlc);
 874                         MTLSD_Delete(env, mtlsdo);
 875                     }
 876                     break;
 877                 }
 878                 case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
 879                 {
 880                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 881                     jlong pData = NEXT_LONG(b);
 882                     BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
 883                     if (mtlsdo != NULL) {
 884                         CONTINUE_IF_NULL(mtlc);
 885                         MTLSD_Delete(env, mtlsdo);
 886                         if (mtlsdo-&gt;privOps != NULL) {
 887                             free(mtlsdo-&gt;privOps);
 888                         }
 889                     }
 890                     break;
 891                 }
 892                 case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
 893                 {
 894                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 895                     jlong pConfigInfo = NEXT_LONG(b);
 896                     CONTINUE_IF_NULL(mtlc);
 897                     MTLGC_DestroyMTLGraphicsConfig(pConfigInfo);
 898 
 899                     // the previous method will call glX/wglMakeCurrent(None),
 900                     // so we should nullify the current mtlc and dstOps to avoid
 901                     // calling glFlush() (or similar) while no context is current
 902                     if (mtlc != NULL) {
 903                         [mtlc.encoderManager endEncoder];
 904                     }
 905                     mtlc = NULL;
 906                  //   dstOps = NULL;
 907                     break;
 908                 }
 909                 case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
 910                 {
 911                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 912                     // invalidate the references to the current context and
 913                     // destination surface that are maintained at the native level
 914                     if (mtlc != NULL) {
 915                         [mtlc.encoderManager endEncoder];
 916                     }
 917                     mtlc = NULL;
 918                 //    dstOps = NULL;
 919                     break;
 920                 }
 921                 case sun_java2d_pipe_BufferedOpCodes_SYNC:
 922                 {
 923                     CHECK_PREVIOUS_OP(MTL_OP_SYNC);
 924                     break;
 925                 }
 926 
 927                 // multibuffering ops
 928                 case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
 929                 {
 930                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 931                     jlong window = NEXT_LONG(b);
 932                     MTLSD_SwapBuffers(env, window);
 933                     break;
 934                 }
 935 
 936                 // special no-op (mainly used for achieving 8-byte alignment)
 937                 case sun_java2d_pipe_BufferedOpCodes_NOOP:
 938                     break;
 939 
 940                 // paint-related ops
 941                 case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
 942                 {
 943                   CHECK_PREVIOUS_OP(MTL_OP_RESET_PAINT);
 944                   [mtlc resetPaint];
 945                     break;
 946                 }
 947                 case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
 948                 {
 949                     CHECK_PREVIOUS_OP(MTL_OP_SET_COLOR);
 950                     jint pixel = NEXT_INT(b);
 951                     [mtlc setColorPaint:pixel];
 952                     break;
 953                 }
 954                 case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
 955                 {
 956                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 957                     jboolean useMask= NEXT_BOOLEAN(b);
 958                     jboolean cyclic = NEXT_BOOLEAN(b);
 959                     jdouble p0      = NEXT_DOUBLE(b);
 960                     jdouble p1      = NEXT_DOUBLE(b);
 961                     jdouble p3      = NEXT_DOUBLE(b);
 962                     jint pixel1     = NEXT_INT(b);
 963                     jint pixel2     = NEXT_INT(b);
 964                     [mtlc setGradientPaintUseMask:useMask
 965                                         cyclic:cyclic
 966                                             p0:p0
 967                                             p1:p1
 968                                             p3:p3
 969                                         pixel1:pixel1
 970                                         pixel2:pixel2];
 971                     break;
 972                 }
 973                 case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
 974                 {
 975                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 976                     jboolean useMask = NEXT_BOOLEAN(b);
 977                     jboolean linear  = NEXT_BOOLEAN(b);
 978                     jint cycleMethod = NEXT_INT(b);
 979                     jint numStops    = NEXT_INT(b);
 980                     jfloat p0        = NEXT_FLOAT(b);
 981                     jfloat p1        = NEXT_FLOAT(b);
 982                     jfloat p3        = NEXT_FLOAT(b);
 983                     void *fractions, *pixels;
 984                     fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
 985                     pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
 986                     [mtlc setLinearGradientPaint:useMask
 987                                           linear:linear
 988                                      cycleMethod:cycleMethod
 989                                         numStops:numStops
 990                                               p0:p0
 991                                               p1:p1
 992                                               p3:p3
 993                                        fractions:fractions
 994                                           pixels:pixels];
 995                     break;
 996                 }
 997                 case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
 998                 {
 999                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1000                     jboolean useMask = NEXT_BOOLEAN(b);
1001                     jboolean linear  = NEXT_BOOLEAN(b);
1002                     jint numStops    = NEXT_INT(b);
1003                     jint cycleMethod = NEXT_INT(b);
1004                     jfloat m00       = NEXT_FLOAT(b);
1005                     jfloat m01       = NEXT_FLOAT(b);
1006                     jfloat m02       = NEXT_FLOAT(b);
1007                     jfloat m10       = NEXT_FLOAT(b);
1008                     jfloat m11       = NEXT_FLOAT(b);
1009                     jfloat m12       = NEXT_FLOAT(b);
1010                     jfloat focusX    = NEXT_FLOAT(b);
1011                     void *fractions, *pixels;
1012                     fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
1013                     pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
1014                     [mtlc setRadialGradientPaint:useMask
1015                                           linear:linear
1016                                      cycleMethod:cycleMethod
1017                                         numStops:numStops
1018                                              m00:m00
1019                                              m01:m01
1020                                              m02:m02
1021                                              m10:m10
1022                                              m11:m11
1023                                              m12:m12
1024                                           focusX:focusX
1025                                        fractions:fractions
1026                                           pixels:pixels];
1027                     break;
1028                 }
1029                 case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
1030                 {
1031                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1032                     jboolean useMask= NEXT_BOOLEAN(b);
1033                     jboolean filter = NEXT_BOOLEAN(b);
1034                     jlong pSrc      = NEXT_LONG(b);
1035                     jdouble xp0     = NEXT_DOUBLE(b);
1036                     jdouble xp1     = NEXT_DOUBLE(b);
1037                     jdouble xp3     = NEXT_DOUBLE(b);
1038                     jdouble yp0     = NEXT_DOUBLE(b);
1039                     jdouble yp1     = NEXT_DOUBLE(b);
1040                     jdouble yp3     = NEXT_DOUBLE(b);
1041                     [mtlc setTexturePaint:useMask
1042                                   pSrcOps:pSrc
1043                                    filter:filter
1044                                       xp0:xp0
1045                                       xp1:xp1
1046                                       xp3:xp3
1047                                       yp0:yp0
1048                                       yp1:yp1
1049                                       yp3:yp3];
1050                     break;
1051                 }
1052 
1053                 // BufferedImageOp-related ops
1054                 case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
1055                 {
1056                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1057                     jlong pSrc        = NEXT_LONG(b);
1058                     jboolean edgeZero = NEXT_BOOLEAN(b);
1059                     jint kernelWidth  = NEXT_INT(b);
1060                     jint kernelHeight = NEXT_INT(b);
1061 
1062                     BMTLSDOps * bmtlsdOps = (BMTLSDOps *)pSrc;
1063                     MTLConvolveOp * convolveOp = [[MTLConvolveOp alloc] init:edgeZero
1064                             kernelWidth:kernelWidth
1065                            kernelHeight:kernelHeight
1066                                srcWidth:bmtlsdOps-&gt;width
1067                               srcHeight:bmtlsdOps-&gt;height
1068                                  kernel:b
1069                                  device:mtlc.device
1070                                                   ];
1071                     [mtlc setBufImgOp:convolveOp];
1072                     SKIP_BYTES(b, kernelWidth * kernelHeight * sizeof(jfloat));
1073                     break;
1074                 }
1075                 case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
1076                 {
1077                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1078                     [mtlc setBufImgOp:NULL];
1079                     break;
1080                 }
1081                 case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
1082                 {
1083                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1084                     jlong pSrc          = NEXT_LONG(b);
1085                     jboolean nonPremult = NEXT_BOOLEAN(b);
1086                     jint numFactors     = 4;
1087                     unsigned char *scaleFactors = b;
1088                     unsigned char *offsets = (b + numFactors * sizeof(jfloat));
1089                     MTLRescaleOp * rescaleOp =
1090                             [[MTLRescaleOp alloc] init:nonPremult factors:scaleFactors offsets:offsets];
1091                     [mtlc setBufImgOp:rescaleOp];
1092                     SKIP_BYTES(b, numFactors * sizeof(jfloat) * 2);
1093                     break;
1094                 }
1095                 case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
1096                 {
1097                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1098                     [mtlc setBufImgOp:NULL];
1099                     break;
1100                 }
1101                 case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
1102                 {
1103                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1104                     jlong pSrc          = NEXT_LONG(b);
1105                     jboolean nonPremult = NEXT_BOOLEAN(b);
1106                     jboolean shortData  = NEXT_BOOLEAN(b);
1107                     jint numBands       = NEXT_INT(b);
1108                     jint bandLength     = NEXT_INT(b);
1109                     jint offset         = NEXT_INT(b);
1110                     jint bytesPerElem = shortData ? sizeof(jshort):sizeof(jbyte);
1111                     void *tableValues = b;
1112 
1113                     MTLLookupOp * lookupOp = [[MTLLookupOp alloc] init:nonPremult
1114                                                              shortData:shortData
1115                                                               numBands:numBands
1116                                                             bandLength:bandLength
1117                                                                 offset:offset
1118                                                            tableValues:tableValues
1119                                                                 device:mtlc.device];
1120                     [mtlc setBufImgOp:lookupOp];
1121                     SKIP_BYTES(b, numBands * bandLength * bytesPerElem);
1122                     break;
1123                 }
1124                 case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
1125                 {
1126                     CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1127                     [mtlc setBufImgOp:NULL];
1128                     break;
1129                 }
1130 
1131                 default:
1132                     J2dRlsTraceLn1(J2D_TRACE_ERROR,
1133                         &quot;MTLRenderQueue_flushBuffer: invalid opcode=%d&quot;, opcode);
1134                     return;
1135             }
1136         }
1137 
1138         if (mtlc != NULL) {
1139             [mtlc.encoderManager endEncoder];
1140             MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
1141             id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
1142             [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
1143                 [cbwrapper release];
1144             }];
1145             [commandbuf commit];
1146             BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
1147             if (dstOps != NULL) {
1148                 MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps-&gt;privOps;
1149                 MTLLayer *layer = (MTLLayer*)dstMTLOps-&gt;layer;
1150                 if (layer != NULL) {
1151                     [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){
1152                         AWT_ASSERT_APPKIT_THREAD;
1153                         [layer setNeedsDisplay];
1154                     }];
1155                 }
1156             }
1157         }
1158         RESET_PREVIOUS_OP();
1159     }
1160 }
1161 
1162 /**
1163  * Returns a pointer to the &quot;current&quot; context, as set by the last SET_SURFACES
1164  * or SET_SCRATCH_SURFACE operation.
1165  */
1166 MTLContext *
1167 MTLRenderQueue_GetCurrentContext()
1168 {
1169     return mtlc;
1170 }
1171 
1172 /**
1173  * Returns a pointer to the &quot;current&quot; destination surface, as set by the last
1174  * SET_SURFACES operation.
1175  */
1176 BMTLSDOps *
1177 MTLRenderQueue_GetCurrentDestination()
1178 {
1179     return dstOps;
1180 }
1181 
1182 /**
1183  * commit earlier encoded commmands
1184  * these would be rendered to the back-buffer - which is read in shader while rendering in XOR mode
1185  */
1186 void commitEncodedCommands() {
1187     [mtlc.encoderManager endEncoder];
1188 
1189     MTLCommandBufferWrapper *cbwrapper = [mtlc pullCommandBufferWrapper];
1190     id &lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
1191     [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
1192         [cbwrapper release];
1193     }];
1194     [commandbuf commit];
1195     [commandbuf waitUntilCompleted];
1196 }
1197 
1198 #endif /* !HEADLESS */
    </pre>
  </body>
</html>