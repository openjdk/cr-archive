<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBlitLoops.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &lt;jni.h&gt;
 29 #include &lt;jlong.h&gt;
 30 
 31 #include &quot;SurfaceData.h&quot;
 32 #include &quot;MTLBlitLoops.h&quot;
 33 #include &quot;MTLRenderQueue.h&quot;
 34 #include &quot;MTLSurfaceData.h&quot;
 35 #include &quot;MTLUtils.h&quot;
 36 #include &quot;GraphicsPrimitiveMgr.h&quot;
 37 
 38 #include &lt;stdlib.h&gt; // malloc
 39 #include &lt;string.h&gt; // memcpy
 40 #include &quot;IntArgbPre.h&quot;
 41 
 42 #import &lt;Accelerate/Accelerate.h&gt;
 43 
 44 #ifdef DEBUG
 45 #define TRACE_ISOBLIT
 46 #define TRACE_BLIT
 47 #endif //DEBUG
 48 //#define DEBUG_ISOBLIT
 49 //#define DEBUG_BLIT
 50 
 51 typedef struct {
 52     MTLPixelFormat   format;
 53     jboolean hasAlpha;
 54     jboolean isPremult;
 55     const uint8_t * permuteMap;
 56 } MTLRasterFormatInfo;
 57 
 58 // 0 denotes the alpha channel, 1 the red channel, 2 the green channel, and 3 the blue channel.
 59 const uint8_t permuteMap_rgbx[4] = { 1, 2, 3, 0 };
 60 const uint8_t permuteMap_bgrx[4] = { 3, 2, 1, 0 };
 61 
 62 static uint8_t revertPerm(const uint8_t * perm, uint8_t pos) {
 63     for (int c = 0; c &lt; 4; ++c) {
 64         if (perm[c] == pos)
 65             return c;
 66     }
 67     return -1;
 68 }
 69 
 70 #define uint2swizzle(channel) (channel == 0 ? MTLTextureSwizzleAlpha : (channel == 1 ? MTLTextureSwizzleRed : (channel == 2 ? MTLTextureSwizzleGreen : (channel == 3 ? MTLTextureSwizzleBlue : MTLTextureSwizzleZero))))
 71 
 72 /**
 73  * This table contains the &quot;pixel formats&quot; for all system memory surfaces
 74  * that Metal is capable of handling, indexed by the &quot;PF_&quot; constants defined
 75  * in MTLLSurfaceData.java.  These pixel formats contain information that is
 76  * passed to Metal when copying from a system memory (&quot;Sw&quot;) surface to
 77  * an Metal surface
 78  */
 79 MTLRasterFormatInfo RasterFormatInfos[] = {
 80         { MTLPixelFormatBGRA8Unorm, 1, 0, NULL }, /* 0 - IntArgb      */ // Argb (in java notation)
 81         { MTLPixelFormatBGRA8Unorm, 1, 1, NULL }, /* 1 - IntArgbPre   */
 82         { MTLPixelFormatBGRA8Unorm, 0, 1, NULL }, /* 2 - IntRgb       */ // xrgb
 83         { MTLPixelFormatBGRA8Unorm, 0, 1, permuteMap_rgbx }, /* 3 - IntRgbx      */
 84         { MTLPixelFormatRGBA8Unorm, 0, 1, NULL }, /* 4 - IntBgr       */ // xbgr
 85         { MTLPixelFormatBGRA8Unorm, 0, 1, permuteMap_bgrx }, /* 5 - IntBgrx      */
 86 
 87 //        TODO: support 2-byte formats
 88 //        { GL_BGRA, GL_UNSIGNED_SHORT_1_5_5_5_REV,
 89 //                2, 0, 1,                                     }, /* 7 - Ushort555Rgb */
 90 //        { GL_RGBA, GL_UNSIGNED_SHORT_5_5_5_1,
 91 //                2, 0, 1,                                     }, /* 8 - Ushort555Rgbx*/
 92 //        { GL_LUMINANCE, GL_UNSIGNED_BYTE,
 93 //                1, 0, 1,                                     }, /* 9 - ByteGray     */
 94 //        { GL_LUMINANCE, GL_UNSIGNED_SHORT,
 95 //                2, 0, 1,                                     }, /*10 - UshortGray   */
 96 //        { GL_BGR,  GL_UNSIGNED_BYTE,
 97 //                1, 0, 1,                                     }, /*11 - ThreeByteBgr */
 98 };
 99 
100 extern void J2dTraceImpl(int level, jboolean cr, const char *string, ...);
101 
102 void fillTxQuad(
103         struct TxtVertex * txQuadVerts,
104         jint sx1, jint sy1, jint sx2, jint sy2, jint sw, jint sh,
105         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2, jdouble dw, jdouble dh
106 ) {
107     const float nsx1 = sx1/(float)sw;
108     const float nsy1 = sy1/(float)sh;
109     const float nsx2 = sx2/(float)sw;
110     const float nsy2 = sy2/(float)sh;
111 
112     txQuadVerts[0].position[0] = dx1;
113     txQuadVerts[0].position[1] = dy1;
114     txQuadVerts[0].txtpos[0]   = nsx1;
115     txQuadVerts[0].txtpos[1]   = nsy1;
116 
117     txQuadVerts[1].position[0] = dx2;
118     txQuadVerts[1].position[1] = dy1;
119     txQuadVerts[1].txtpos[0]   = nsx2;
120     txQuadVerts[1].txtpos[1]   = nsy1;
121 
122     txQuadVerts[2].position[0] = dx2;
123     txQuadVerts[2].position[1] = dy2;
124     txQuadVerts[2].txtpos[0]   = nsx2;
125     txQuadVerts[2].txtpos[1]   = nsy2;
126 
127     txQuadVerts[3].position[0] = dx2;
128     txQuadVerts[3].position[1] = dy2;
129     txQuadVerts[3].txtpos[0]   = nsx2;
130     txQuadVerts[3].txtpos[1]   = nsy2;
131 
132     txQuadVerts[4].position[0] = dx1;
133     txQuadVerts[4].position[1] = dy2;
134     txQuadVerts[4].txtpos[0]   = nsx1;
135     txQuadVerts[4].txtpos[1]   = nsy2;
136 
137     txQuadVerts[5].position[0] = dx1;
138     txQuadVerts[5].position[1] = dy1;
139     txQuadVerts[5].txtpos[0]   = nsx1;
140     txQuadVerts[5].txtpos[1]   = nsy1;
141 }
142 
143 //#define TRACE_drawTex2Tex
144 
145 void drawTex2Tex(MTLContext *mtlc,
146                         id&lt;MTLTexture&gt; src, id&lt;MTLTexture&gt; dst,
147                         jboolean isSrcOpaque, jboolean isDstOpaque, jint hint,
148                         jint sx1, jint sy1, jint sx2, jint sy2,
149                         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
150 {
151 #ifdef TRACE_drawTex2Tex
152     J2dRlsTraceLn2(J2D_TRACE_VERBOSE, &quot;drawTex2Tex: src tex=%p, dst tex=%p&quot;, src, dst);
153     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  sw=%d sh=%d dw=%d dh=%d&quot;, src.width, src.height, dst.width, dst.height);
154     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  sx1=%d sy1=%d sx2=%d sy2=%d&quot;, sx1, sy1, sx2, sy2);
155     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  dx1=%f dy1=%f dx2=%f dy2=%f&quot;, dx1, dy1, dx2, dy2);
156 #endif //TRACE_drawTex2Tex
157 
158     id&lt;MTLRenderCommandEncoder&gt; encoder = [mtlc.encoderManager getTextureEncoder:dst
159                                                                      isSrcOpaque:isSrcOpaque
160                                                                      isDstOpaque:isDstOpaque
161                                                                    interpolation:hint
162     ];
163 
164     struct TxtVertex quadTxVerticesBuffer[6];
165     fillTxQuad(quadTxVerticesBuffer, sx1, sy1, sx2, sy2, src.width, src.height, dx1, dy1, dx2, dy2, dst.width, dst.height);
166 
167     [encoder setVertexBytes:quadTxVerticesBuffer length:sizeof(quadTxVerticesBuffer) atIndex:MeshVertexBuffer];
168     [encoder setFragmentTexture:src atIndex: 0];
169     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
170 }
171 
172 static
173 id&lt;MTLTexture&gt; replaceTextureRegion(MTLContext *mtlc, id&lt;MTLTexture&gt; dest, const SurfaceDataRasInfo * srcInfo, const MTLRasterFormatInfo * rfi, int dx1, int dy1, int dx2, int dy2) {
174     const int dw = dx2 - dx1;
175     const int dh = dy2 - dy1;
176 
177     const void * raster = srcInfo-&gt;rasBase;
178     raster += srcInfo-&gt;bounds.y1*srcInfo-&gt;scanStride + srcInfo-&gt;bounds.x1*srcInfo-&gt;pixelStride;
179 
180     id&lt;MTLTexture&gt; result = nil;
181     if (rfi-&gt;permuteMap != NULL) {
182 #if defined(__MAC_10_15) &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= __MAC_10_15
183         if (@available(macOS 10.15, *)) {
184             @autoreleasepool {
185                 const uint8_t swzRed = revertPerm(rfi-&gt;permuteMap, 1);
186                 const uint8_t swzGreen = revertPerm(rfi-&gt;permuteMap, 2);
187                 const uint8_t swzBlue = revertPerm(rfi-&gt;permuteMap, 3);
188                 const uint8_t swzAlpha = revertPerm(rfi-&gt;permuteMap, 0);
189                 MTLTextureSwizzleChannels swizzle = MTLTextureSwizzleChannelsMake(
190                         uint2swizzle(swzRed),
191                         uint2swizzle(swzGreen),
192                         uint2swizzle(swzBlue),
193                         rfi-&gt;hasAlpha ? uint2swizzle(swzAlpha) : MTLTextureSwizzleOne
194                 );
195                 result = [dest
196                         newTextureViewWithPixelFormat:MTLPixelFormatBGRA8Unorm
197                         textureType:MTLTextureType2D
198                         levels:NSMakeRange(0, 1) slices:NSMakeRange(0, 1)
199                         swizzle:swizzle];
200                 J2dTraceLn5(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion [use swizzle for pooled]: %d, %d, %d, %d, hasA=%d&quot;,
201                             swizzle.red, swizzle.green, swizzle.blue, swizzle.alpha, rfi-&gt;hasAlpha);
202             }
203         } else
204 #endif // __MAC_10_15 &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= __MAC_10_15
205         {
206             // perform raster conversion
207             // invoked only from rq-thread, so use static buffers
208             // but it&#39;s better to use thread-local buffers (or special buffer manager)
209             const int destRasterSize = dw*dh*4;
210 
211             static int bufferSize = 0;
212             static void * buffer = NULL;
213             if (buffer == NULL || bufferSize &lt; destRasterSize) {
214                 bufferSize = destRasterSize;
215                 buffer = realloc(buffer, bufferSize);
216             }
217             if (buffer == NULL) {
218                 J2dTraceLn1(J2D_TRACE_ERROR, &quot;replaceTextureRegion: can&#39;t alloc buffer for raster conversion, size=%d&quot;, bufferSize);
219                 bufferSize = 0;
220                 return nil;
221             }
222             vImage_Buffer srcBuf;
223             srcBuf.height = dh;
224             srcBuf.width = dw;
225             srcBuf.rowBytes = srcInfo-&gt;scanStride;
226             srcBuf.data = raster;
227 
228             vImage_Buffer destBuf;
229             destBuf.height = dh;
230             destBuf.width = dw;
231             destBuf.rowBytes = dw*4;
232             destBuf.data = buffer;
233 
234             vImagePermuteChannels_ARGB8888(&amp;srcBuf, &amp;destBuf, rfi-&gt;permuteMap, kvImageNoFlags);
235             raster = buffer;
236 
237             J2dTraceLn5(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion [use conversion]: %d, %d, %d, %d, hasA=%d&quot;,
238                         rfi-&gt;permuteMap[0], rfi-&gt;permuteMap[1], rfi-&gt;permuteMap[2], rfi-&gt;permuteMap[3], rfi-&gt;hasAlpha);
239         }
240     }
241 
242     MTLRegion region = MTLRegionMake2D(dx1, dy1, dw, dh);
243     if (result != nil)
244         dest = result;
245 
246     @autoreleasepool {
247         id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];
248 
249         J2dTraceLn4(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion src (dw, dh) : [%d, %d] dest (dx1, dy1) =[%d, %d]&quot;,
250                     dw, dh, dx1, dy1);
251 
252         id &lt;MTLBuffer&gt; buff = [[mtlc.device newBufferWithBytes:raster length:srcInfo-&gt;scanStride * dh options:MTLResourceStorageModeManaged] autorelease];
253         [blitEncoder copyFromBuffer:buff
254                 sourceOffset:0 sourceBytesPerRow:srcInfo-&gt;scanStride sourceBytesPerImage:srcInfo-&gt;scanStride * dh sourceSize:MTLSizeMake(dw, dh, 1)
255                 toTexture:dest destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(dx1, dy1, 0)];
256         [blitEncoder endEncoding];
257     }
258 
259     return result;
260 }
261 
262 /**
263  * Inner loop used for copying a source system memory (&quot;Sw&quot;) surface to a
264  * destination MTL &quot;Surface&quot;.  This method is invoked from
265  * MTLBlitLoops_Blit().
266  */
267 
268 static void
269 MTLBlitSwToTextureViaPooledTexture(
270         MTLContext *mtlc, SurfaceDataRasInfo *srcInfo, BMTLSDOps * bmtlsdOps,
271         MTLRasterFormatInfo * rfi, jboolean useBlitEncoder, jint hint,
272         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
273 {
274     const int sw = srcInfo-&gt;bounds.x2 - srcInfo-&gt;bounds.x1;
275     const int sh = srcInfo-&gt;bounds.y2 - srcInfo-&gt;bounds.y1;
276     id&lt;MTLTexture&gt; dest = bmtlsdOps-&gt;pTexture;
277 
278     MTLPooledTextureHandle * texHandle = [mtlc.texturePool getTexture:sw height:sh format:rfi-&gt;format];
279     if (texHandle == nil) {
280         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitSwToTextureViaPooledTexture: can&#39;t obtain temporary texture object from pool&quot;);
281         return;
282     }
283     [[mtlc getCommandBufferWrapper] registerPooledTexture:texHandle];
284     [texHandle release];
285 
286     id&lt;MTLTexture&gt; texBuff = texHandle.texture;
287     id&lt;MTLTexture&gt; swizzledTexture = replaceTextureRegion(mtlc, texBuff, srcInfo, rfi, 0, 0, sw, sh);
288     if (useBlitEncoder) {
289         id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];
290         [blitEncoder copyFromTexture:swizzledTexture != nil ? swizzledTexture : texBuff
291                          sourceSlice:0
292                          sourceLevel:0
293                         sourceOrigin:MTLOriginMake(0, 0, 0)
294                           sourceSize:MTLSizeMake(sw, sh, 1)
295                            toTexture:dest
296                     destinationSlice:0
297                     destinationLevel:0
298                    destinationOrigin:MTLOriginMake(dx1, dy1, 0)];
299         [blitEncoder endEncoding];
300     } else {
301         drawTex2Tex(mtlc, swizzledTexture != nil ? swizzledTexture : texBuff, dest, !rfi-&gt;hasAlpha, bmtlsdOps-&gt;isOpaque, hint,
302                     0, 0, sw, sh, dx1, dy1, dx2, dy2);
303     }
304 
305     if (swizzledTexture != nil) {
306         [swizzledTexture release];
307     }
308 }
309 
310 static
311 jboolean isIntegerAndUnscaled(
312         jint sx1, jint sy1, jint sx2, jint sy2,
313         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2
314 ) {
315     const jdouble epsilon = 0.0001f;
316 
317     // check that dx1,dy1 is integer
318     if (fabs(dx1 - (int)dx1) &gt; epsilon || fabs(dy1 - (int)dy1) &gt; epsilon) {
319         return JNI_FALSE;
320     }
321     // check that destSize equals srcSize
322     if (fabs(dx2 - dx1 - sx2 + sx1) &gt; epsilon || fabs(dy2 - dy1 - sy2 + sy1) &gt; epsilon) {
323         return JNI_FALSE;
324     }
325     return JNI_TRUE;
326 }
327 
328 static
329 jboolean clipDestCoords(
330         jdouble *dx1, jdouble *dy1, jdouble *dx2, jdouble *dy2,
331         jint *sx1, jint *sy1, jint *sx2, jint *sy2,
332         jint destW, jint destH, const MTLScissorRect * clipRect
333 ) {
334     // Trim destination rect by clip-rect (or dest.bounds)
335     const jint sw    = *sx2 - *sx1;
336     const jint sh    = *sy2 - *sy1;
337     const jdouble dw = *dx2 - *dx1;
338     const jdouble dh = *dy2 - *dy1;
339 
340     jdouble dcx1 = 0;
341     jdouble dcx2 = destW;
342     jdouble dcy1 = 0;
343     jdouble dcy2 = destH;
344     if (clipRect != NULL) {
345         if (clipRect-&gt;x &gt; dcx1)
346             dcx1 = clipRect-&gt;x;
347         const int maxX = clipRect-&gt;x + clipRect-&gt;width;
348         if (dcx2 &gt; maxX)
349             dcx2 = maxX;
350         if (clipRect-&gt;y &gt; dcy1)
351             dcy1 = clipRect-&gt;y;
352         const int maxY = clipRect-&gt;y + clipRect-&gt;height;
353         if (dcy2 &gt; maxY)
354             dcy2 = maxY;
355 
356         if (dcx1 &gt;= dcx2) {
357             J2dTraceLn2(J2D_TRACE_ERROR, &quot;\tclipDestCoords: dcx1=%1.2f, dcx2=%1.2f&quot;, dcx1, dcx2);
358             dcx1 = dcx2;
359         }
360         if (dcy1 &gt;= dcy2) {
361             J2dTraceLn2(J2D_TRACE_ERROR, &quot;\tclipDestCoords: dcy1=%1.2f, dcy2=%1.2f&quot;, dcy1, dcy2);
362             dcy1 = dcy2;
363         }
364     }
365     if (*dx2 &lt;= dcx1 || *dx1 &gt;= dcx2 || *dy2 &lt;= dcy1 || *dy1 &gt;= dcy2) {
366         J2dTraceLn(J2D_TRACE_INFO, &quot;\tclipDestCoords: dest rect doesn&#39;t intersect clip area&quot;);
367         J2dTraceLn4(J2D_TRACE_INFO, &quot;\tdx2=%1.4f &lt;= dcx1=%1.4f || *dx1=%1.4f &gt;= dcx2=%1.4f&quot;, *dx2, dcx1, *dx1, dcx2);
368         J2dTraceLn4(J2D_TRACE_INFO, &quot;\t*dy2=%1.4f &lt;= dcy1=%1.4f || *dy1=%1.4f &gt;= dcy2=%1.4f&quot;, *dy2, dcy1, *dy1, dcy2);
369         return JNI_FALSE;
370     }
371     if (*dx1 &lt; dcx1) {
372         J2dTraceLn3(J2D_TRACE_VERBOSE, &quot;\t\tdx1=%1.2f, will be clipped to %1.2f | sx1+=%d&quot;, *dx1, dcx1, (jint)((dcx1 - *dx1) * (sw/dw)));
373         *sx1 += (jint)((dcx1 - *dx1) * (sw/dw));
374         *dx1 = dcx1;
375     }
376     if (*dx2 &gt; dcx2) {
377         J2dTraceLn3(J2D_TRACE_VERBOSE, &quot;\t\tdx2=%1.2f, will be clipped to %1.2f | sx2-=%d&quot;, *dx2, dcx2, (jint)((*dx2 - dcx2) * (sw/dw)));
378         *sx2 -= (jint)((*dx2 - dcx2) * (sw/dw));
379         *dx2 = dcx2;
380     }
381     if (*dy1 &lt; dcy1) {
382         J2dTraceLn3(J2D_TRACE_VERBOSE, &quot;\t\tdy1=%1.2f, will be clipped to %1.2f | sy1+=%d&quot;, *dy1, dcy1, (jint)((dcy1 - *dy1) * (sh/dh)));
383         *sy1 += (jint)((dcy1 - *dy1) * (sh/dh));
384         *dy1 = dcy1;
385     }
386     if (*dy2 &gt; dcy2) {
387         J2dTraceLn3(J2D_TRACE_VERBOSE, &quot;\t\tdy2=%1.2f, will be clipped to %1.2f | sy2-=%d&quot;, *dy2, dcy2, (jint)((*dy2 - dcy2) * (sh/dh)));
388         *sy2 -= (jint)((*dy2 - dcy2) * (sh/dh));
389         *dy2 = dcy2;
390     }
391     return JNI_TRUE;
392 }
393 
394 /**
395  * General blit method for copying a native MTL surface to another MTL &quot;Surface&quot;.
396  * Parameter texture == true forces to use &#39;texture&#39; codepath (dest coordinates will always be integers).
397  * Parameter xform == true only when AffineTransform is used (invoked only from TransformBlit, dest coordinates will always be integers).
398  */
399 void
400 MTLBlitLoops_IsoBlit(JNIEnv *env,
401                      MTLContext *mtlc, jlong pSrcOps, jlong pDstOps,
402                      jboolean xform, jint hint, jboolean texture,
403                      jint sx1, jint sy1, jint sx2, jint sy2,
404                      jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
405 {
406     BMTLSDOps *srcOps = (BMTLSDOps *)jlong_to_ptr(pSrcOps);
407     BMTLSDOps *dstOps = (BMTLSDOps *)jlong_to_ptr(pDstOps);
408 
409     RETURN_IF_NULL(mtlc);
410     RETURN_IF_NULL(srcOps);
411     RETURN_IF_NULL(dstOps);
412 
413     id&lt;MTLTexture&gt; srcTex = srcOps-&gt;pTexture;
414     id&lt;MTLTexture&gt; dstTex = dstOps-&gt;pTexture;
415     if (srcTex == nil || srcTex == nil) {
416         J2dTraceLn2(J2D_TRACE_ERROR, &quot;MTLBlitLoops_IsoBlit: surface is null (stex=%p, dtex=%p)&quot;, srcTex, dstTex);
417         return;
418     }
419 
420     const jint sw    = sx2 - sx1;
421     const jint sh    = sy2 - sy1;
422     const jdouble dw = dx2 - dx1;
423     const jdouble dh = dy2 - dy1;
424 
425     if (sw &lt;= 0 || sh &lt;= 0 || dw &lt;= 0 || dh &lt;= 0) {
426         J2dTraceLn4(J2D_TRACE_WARNING, &quot;MTLBlitLoops_IsoBlit: invalid dimensions: sw=%d, sh%d, dw=%d, dh=%d&quot;, sw, sh, dw, dh);
427         return;
428     }
429 
430 #ifdef DEBUG_ISOBLIT
431     if ((xform == JNI_TRUE) != (mtlc.useTransform == JNI_TRUE)) {
432         J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
433                 &quot;MTLBlitLoops_IsoBlit state error: xform=%d, mtlc.useTransform=%d, texture=%d&quot;,
434                 xform, mtlc.useTransform, texture);
435     }
436 #endif // DEBUG_ISOBLIT
437 
438     clipDestCoords(
439             &amp;dx1, &amp;dy1, &amp;dx2, &amp;dy2,
440             &amp;sx1, &amp;sy1, &amp;sx2, &amp;sy2,
441             dstTex.width, dstTex.height, texture ? NULL : [mtlc.clip getRect]
442     );
443 
444     SurfaceDataBounds bounds;
445     bounds.x1 = sx1;
446     bounds.y1 = sy1;
447     bounds.x2 = sx2;
448     bounds.y2 = sy2;
449     SurfaceData_IntersectBoundsXYXY(&amp;bounds, 0, 0, srcOps-&gt;width, srcOps-&gt;height);
450 
451     if (bounds.x2 &lt;= bounds.x1 || bounds.y2 &lt;= bounds.y1) {
452         J2dTraceLn(J2D_TRACE_VERBOSE, &quot;MTLBlitLoops_IsoBlit: source rectangle doesn&#39;t intersect with source surface bounds&quot;);
453         J2dTraceLn6(J2D_TRACE_VERBOSE, &quot;  sx1=%d sy1=%d sx2=%d sy2=%d sw=%d sh=%d&quot;, sx1, sy1, sx2, sy2, srcOps-&gt;width, srcOps-&gt;height);
454         J2dTraceLn4(J2D_TRACE_VERBOSE, &quot;  dx1=%f dy1=%f dx2=%f dy2=%f&quot;, dx1, dy1, dx2, dy2);
455         return;
456     }
457 
458     if (bounds.x1 != sx1) {
459         dx1 += (bounds.x1 - sx1) * (dw / sw);
460         sx1 = bounds.x1;
461     }
462     if (bounds.y1 != sy1) {
463         dy1 += (bounds.y1 - sy1) * (dh / sh);
464         sy1 = bounds.y1;
465     }
466     if (bounds.x2 != sx2) {
467         dx2 += (bounds.x2 - sx2) * (dw / sw);
468         sx2 = bounds.x2;
469     }
470     if (bounds.y2 != sy2) {
471         dy2 += (bounds.y2 - sy2) * (dh / sh);
472         sy2 = bounds.y2;
473     }
474 
475 #ifdef TRACE_ISOBLIT
476     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_FALSE,
477          &quot;MTLBlitLoops_IsoBlit [tx=%d, xf=%d, AC=%s]: src=%s, dst=%s | (%d, %d, %d, %d)-&gt;(%1.2f, %1.2f, %1.2f, %1.2f)&quot;,
478          texture, xform, [mtlc getCompositeDescription].cString,
479          getSurfaceDescription(srcOps).cString, getSurfaceDescription(dstOps).cString,
480          sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2);
481 #endif //TRACE_ISOBLIT
482 
483     if (!texture &amp;&amp; !xform
484         &amp;&amp; [mtlc isBlendingDisabled:srcOps-&gt;isOpaque]
485         &amp;&amp; isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2)
486         &amp;&amp; (dstOps-&gt;isOpaque || !srcOps-&gt;isOpaque)
487     ) {
488 #ifdef TRACE_ISOBLIT
489         J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via blitEncoder]&quot;);
490 #endif //TRACE_ISOBLIT
491 
492         id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];
493         [blitEncoder copyFromTexture:srcTex
494                          sourceSlice:0
495                          sourceLevel:0
496                         sourceOrigin:MTLOriginMake(sx1, sy1, 0)
497                           sourceSize:MTLSizeMake(sx2 - sx1, sy2 - sy1, 1)
498                            toTexture:dstTex
499                     destinationSlice:0
500                     destinationLevel:0
501                    destinationOrigin:MTLOriginMake(dx1, dy1, 0)];
502         [blitEncoder endEncoding];
503         return;
504     }
505 
506 #ifdef TRACE_ISOBLIT
507     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via sampling]&quot;);
508 #endif //TRACE_ISOBLIT
509     drawTex2Tex(mtlc, srcTex, dstTex,
510             [mtlc isBlendingDisabled:srcOps-&gt;isOpaque],
511             dstOps-&gt;isOpaque, hint, sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2);
512 }
513 
514 /**
515  * General blit method for copying a system memory (&quot;Sw&quot;) surface to a native MTL surface.
516  * Parameter texture == true only in SwToTextureBlit (straight copy from sw to texture), dest coordinates will always be integers.
517  * Parameter xform == true only when AffineTransform is used (invoked only from TransformBlit, dest coordinates will always be integers).
518  */
519 void
520 MTLBlitLoops_Blit(JNIEnv *env,
521                   MTLContext *mtlc, jlong pSrcOps, jlong pDstOps,
522                   jboolean xform, jint hint,
523                   jint srctype, jboolean texture,
524                   jint sx1, jint sy1, jint sx2, jint sy2,
525                   jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
526 {
527     SurfaceDataOps *srcOps = (SurfaceDataOps *)jlong_to_ptr(pSrcOps);
528     BMTLSDOps *dstOps = (BMTLSDOps *)jlong_to_ptr(pDstOps);
529 
530     RETURN_IF_NULL(mtlc);
531     RETURN_IF_NULL(srcOps);
532     RETURN_IF_NULL(dstOps);
533 
534     id&lt;MTLTexture&gt; dest = dstOps-&gt;pTexture;
535     if (dest == NULL) {
536         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitLoops_Blit: dest is null&quot;);
537         return;
538     }
539     if (srctype &lt; 0 || srctype &gt;= sizeof(RasterFormatInfos)/ sizeof(MTLRasterFormatInfo)) {
540         J2dTraceLn1(J2D_TRACE_ERROR, &quot;MTLBlitLoops_Blit: source pixel format %d isn&#39;t supported&quot;, srctype);
541         return;
542     }
543     const jint sw    = sx2 - sx1;
544     const jint sh    = sy2 - sy1;
545     const jdouble dw = dx2 - dx1;
546     const jdouble dh = dy2 - dy1;
547 
548     if (sw &lt;= 0 || sh &lt;= 0 || dw &lt;= 0 || dh &lt;= 0) {
549         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitLoops_Blit: invalid dimensions&quot;);
550         return;
551     }
552 
553 #ifdef DEBUG_BLIT
554     if (
555         (xform == JNI_TRUE) != (mtlc.useTransform == JNI_TRUE)
556         || (xform &amp;&amp; texture)
557     ) {
558         J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
559                 &quot;MTLBlitLoops_Blit state error: xform=%d, mtlc.useTransform=%d, texture=%d&quot;,
560                 xform, mtlc.useTransform, texture);
561     }
562     if (texture) {
563         if (!isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2)) {
564             J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
565                     &quot;MTLBlitLoops_Blit state error: texture=true, but src and dst dimensions aren&#39;t equal or dest coords aren&#39;t integers&quot;);
566         }
567         if (!dstOps-&gt;isOpaque &amp;&amp; !RasterFormatInfos[srctype].hasAlpha) {
568             J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
569                     &quot;MTLBlitLoops_Blit state error: texture=true, but dest has alpha and source hasn&#39;t alpha, can&#39;t use texture-codepath&quot;);
570         }
571     }
572 #endif // DEBUG_BLIT
573 
574     clipDestCoords(
575             &amp;dx1, &amp;dy1, &amp;dx2, &amp;dy2,
576             &amp;sx1, &amp;sy1, &amp;sx2, &amp;sy2,
577             dest.width, dest.height, texture ? NULL : [mtlc.clip getRect]
578     );
579 
580     SurfaceDataRasInfo srcInfo;
581     srcInfo.bounds.x1 = sx1;
582     srcInfo.bounds.y1 = sy1;
583     srcInfo.bounds.x2 = sx2;
584     srcInfo.bounds.y2 = sy2;
585 
586     // NOTE: This function will modify the contents of the bounds field to represent the maximum available raster data.
587     if (srcOps-&gt;Lock(env, srcOps, &amp;srcInfo, SD_LOCK_READ) != SD_SUCCESS) {
588         J2dTraceLn(J2D_TRACE_WARNING, &quot;MTLBlitLoops_Blit: could not acquire lock&quot;);
589         return;
590     }
591 
592     if (srcInfo.bounds.x2 &gt; srcInfo.bounds.x1 &amp;&amp; srcInfo.bounds.y2 &gt; srcInfo.bounds.y1) {
593         srcOps-&gt;GetRasInfo(env, srcOps, &amp;srcInfo);
594         if (srcInfo.rasBase) {
595             if (srcInfo.bounds.x1 != sx1) {
596                 const int dx = srcInfo.bounds.x1 - sx1;
597                 dx1 += dx * (dw / sw);
598             }
599             if (srcInfo.bounds.y1 != sy1) {
600                 const int dy = srcInfo.bounds.y1 - sy1;
601                 dy1 += dy * (dh / sh);
602             }
603             if (srcInfo.bounds.x2 != sx2) {
604                 const int dx = srcInfo.bounds.x2 - sx2;
605                 dx2 += dx * (dw / sw);
606             }
607             if (srcInfo.bounds.y2 != sy2) {
608                 const int dy = srcInfo.bounds.y2 - sy2;
609                 dy2 += dy * (dh / sh);
610             }
611 
612 #ifdef TRACE_BLIT
613             J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_FALSE,
614                     &quot;MTLBlitLoops_Blit [tx=%d, xf=%d, AC=%s]: bdst=%s, src=%p (%dx%d) O=%d premul=%d | (%d, %d, %d, %d)-&gt;(%1.2f, %1.2f, %1.2f, %1.2f)&quot;,
615                     texture, xform, [mtlc getCompositeDescription].cString,
616                     getSurfaceDescription(dstOps).cString, srcOps,
617                     sx2 - sx1, sy2 - sy1,
618                     RasterFormatInfos[srctype].hasAlpha ? 0 : 1, RasterFormatInfos[srctype].isPremult ? 1 : 0,
619                     sx1, sy1, sx2, sy2,
620                     dx1, dy1, dx2, dy2);
621 #endif //TRACE_BLIT
622 
623             MTLRasterFormatInfo rfi = RasterFormatInfos[srctype];
624             const jboolean useReplaceRegion = texture ||
625                     ([mtlc isBlendingDisabled:!rfi.hasAlpha]
626                     &amp;&amp; !xform
627                     &amp;&amp; isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2));
628 
629             if (useReplaceRegion) {
630                 if (dstOps-&gt;isOpaque || rfi.hasAlpha) {
631 #ifdef TRACE_BLIT
632                     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [replaceTextureRegion]&quot;);
633 #endif //TRACE_BLIT
634                     replaceTextureRegion(mtlc, dest, &amp;srcInfo, &amp;rfi, (int) dx1, (int) dy1, (int) dx2, (int) dy2);
635                 } else {
636 #ifdef TRACE_BLIT
637                     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via pooled + blit]&quot;);
638 #endif //TRACE_BLIT
639                     MTLBlitSwToTextureViaPooledTexture(mtlc, &amp;srcInfo, dstOps, &amp;rfi, true, hint, dx1, dy1, dx2, dy2);
640                 }
641             } else { // !useReplaceRegion
642 #ifdef TRACE_BLIT
643                 J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via pooled texture]&quot;);
644 #endif //TRACE_BLIT
645                 MTLBlitSwToTextureViaPooledTexture(mtlc, &amp;srcInfo, dstOps, &amp;rfi, false, hint, dx1, dy1, dx2, dy2);
646             }
647         }
648         SurfaceData_InvokeRelease(env, srcOps, &amp;srcInfo);
649     }
650     SurfaceData_InvokeUnlock(env, srcOps, &amp;srcInfo);
651 }
652 
653 /**
654  * Specialized blit method for copying a native MTL &quot;Surface&quot; (pbuffer,
655  * window, etc.) to a system memory (&quot;Sw&quot;) surface.
656  */
657 void
658 MTLBlitLoops_SurfaceToSwBlit(JNIEnv *env, MTLContext *mtlc,
659                              jlong pSrcOps, jlong pDstOps, jint dsttype,
660                              jint srcx, jint srcy, jint dstx, jint dsty,
661                              jint width, jint height)
662 {
663     J2dTraceLn6(J2D_TRACE_VERBOSE, &quot;MTLBlitLoops_SurfaceToSwBlit: sx=%d sy=%d w=%d h=%d dx=%d dy=%d&quot;, srcx, srcy, width, height, dstx, dsty);
664 
665     BMTLSDOps *srcOps = (BMTLSDOps *)jlong_to_ptr(pSrcOps);
666     SurfaceDataOps *dstOps = (SurfaceDataOps *)jlong_to_ptr(pDstOps);
667     SurfaceDataRasInfo srcInfo, dstInfo;
668 
669     if (dsttype &lt; 0 || dsttype &gt;= sizeof(RasterFormatInfos)/ sizeof(MTLRasterFormatInfo)) {
670         J2dTraceLn1(J2D_TRACE_ERROR, &quot;MTLBlitLoops_SurfaceToSwBlit: destination pixel format %d isn&#39;t supported&quot;, dsttype);
671         return;
672     }
673 
674     if (width &lt;= 0 || height &lt;= 0) {
675         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitLoops_SurfaceToSwBlit: dimensions are non-positive&quot;);
676         return;
677     }
678 
679     RETURN_IF_NULL(srcOps);
680     RETURN_IF_NULL(dstOps);
681     RETURN_IF_NULL(mtlc);
682 
683     srcInfo.bounds.x1 = srcx;
684     srcInfo.bounds.y1 = srcy;
685     srcInfo.bounds.x2 = srcx + width;
686     srcInfo.bounds.y2 = srcy + height;
687     dstInfo.bounds.x1 = dstx;
688     dstInfo.bounds.y1 = dsty;
689     dstInfo.bounds.x2 = dstx + width;
690     dstInfo.bounds.y2 = dsty + height;
691 
692     if (dstOps-&gt;Lock(env, dstOps, &amp;dstInfo, SD_LOCK_WRITE) != SD_SUCCESS) {
693         J2dTraceLn(J2D_TRACE_WARNING,&quot;MTLBlitLoops_SurfaceToSwBlit: could not acquire dst lock&quot;);
694         return;
695     }
696 
697     SurfaceData_IntersectBoundsXYXY(&amp;srcInfo.bounds,
698                                     0, 0, srcOps-&gt;width, srcOps-&gt;height);
699     SurfaceData_IntersectBlitBounds(&amp;dstInfo.bounds, &amp;srcInfo.bounds,
700                                     srcx - dstx, srcy - dsty);
701 
702     if (srcInfo.bounds.x2 &gt; srcInfo.bounds.x1 &amp;&amp;
703         srcInfo.bounds.y2 &gt; srcInfo.bounds.y1)
704     {
705         dstOps-&gt;GetRasInfo(env, dstOps, &amp;dstInfo);
706         if (dstInfo.rasBase) {
707             void *pDst = dstInfo.rasBase;
708 
709             srcx = srcInfo.bounds.x1;
710             srcy = srcInfo.bounds.y1;
711             dstx = dstInfo.bounds.x1;
712             dsty = dstInfo.bounds.y1;
713             width = srcInfo.bounds.x2 - srcInfo.bounds.x1;
714             height = srcInfo.bounds.y2 - srcInfo.bounds.y1;
715 
716             pDst = PtrAddBytes(pDst, dstx * dstInfo.pixelStride);
717             pDst = PtrPixelsRow(pDst, dsty, dstInfo.scanStride);
718 
719             // Metal texture is (0,0) at left-top
720             srcx = srcOps-&gt;xOffset + srcx;
721             srcy = srcOps-&gt;yOffset + srcy;
722             const int srcLength = width * height * 4; // NOTE: assume that src format is MTLPixelFormatBGRA8Unorm
723 
724 #ifdef DEBUG
725             void *pDstEnd = dstInfo.rasBase + (height - 1)*dstInfo.scanStride + width*dstInfo.pixelStride;
726             if (pDst + srcLength &gt; pDstEnd) {
727                 J2dTraceLn6(J2D_TRACE_ERROR, &quot;MTLBlitLoops_SurfaceToSwBlit: length mismatch: dstx=%d, dsty=%d, w=%d, h=%d, pixStride=%d, scanStride=%d&quot;,
728                         dstx, dsty, width, height, dstInfo.pixelStride, dstInfo.scanStride);
729                 return;
730             }
731 #endif //DEBUG
732 
733             // Create MTLBuffer (or use static)
734             MTLRasterFormatInfo rfi = RasterFormatInfos[dsttype];
735             const jboolean directCopy = rfi.permuteMap == NULL;
736 
737             id&lt;MTLBuffer&gt; mtlbuf;
738 #ifdef USE_STATIC_BUFFER
739             if (directCopy) {
740                 // NOTE: theoretically we can use newBufferWithBytesNoCopy, but pDst must be allocated with special API
741                 // mtlbuf = [mtlc.device
742                 //          newBufferWithBytesNoCopy:pDst
743                 //                            length:(NSUInteger) srcLength
744                 //                           options:MTLResourceCPUCacheModeDefaultCache
745                 //                       deallocator:nil];
746                 //
747                 // see https://developer.apple.com/documentation/metal/mtldevice/1433382-newbufferwithbytesnocopy?language=objc
748                 //
749                 // The storage allocation of the returned new MTLBuffer object is the same as the pointer input value.
750                 // The existing memory allocation must be covered by a single VM region, typically allocated with vm_allocate or mmap.
751                 // Memory allocated by malloc is specifically disallowed.
752             }
753 
754             static id&lt;MTLBuffer&gt; mtlIntermediateBuffer = nil; // need to reimplement with MTLBufferManager
755             if (mtlIntermediateBuffer == nil || mtlIntermediateBuffer.length &lt; srcLength) {
756                 if (mtlIntermediateBuffer != nil) {
757                     [mtlIntermediateBuffer release];
758                 }
759                 mtlIntermediateBuffer = [mtlc.device newBufferWithLength:srcLength options:MTLResourceCPUCacheModeDefaultCache];
760             }
761             mtlbuf = mtlIntermediateBuffer;
762 #else // USE_STATIC_BUFFER
763             mtlbuf = [mtlc.device newBufferWithLength:width*height*4 options:MTLResourceStorageModeShared];
764 #endif // USE_STATIC_BUFFER
765 
766             // Read from surface into MTLBuffer
767             // NOTE: using of separate blitCommandBuffer can produce errors (draw into surface (with general cmd-buf)
768             // can be unfinished when reading raster from blit cmd-buf).
769             // Consider to use [mtlc.encoderManager createBlitEncoder] and [mtlc commitCommandBuffer:JNI_TRUE];
770             J2dTraceLn1(J2D_TRACE_VERBOSE, &quot;MTLBlitLoops_SurfaceToSwBlit: source texture %p&quot;, srcOps-&gt;pTexture);
771 
772             id&lt;MTLCommandBuffer&gt; cb = [mtlc createCommandBuffer];
773             id&lt;MTLBlitCommandEncoder&gt; blitEncoder = [cb blitCommandEncoder];
774             [blitEncoder synchronizeTexture:srcOps-&gt;pTexture slice:0 level:0];
775             [blitEncoder copyFromTexture:srcOps-&gt;pTexture
776                             sourceSlice:0
777                             sourceLevel:0
778                            sourceOrigin:MTLOriginMake(srcx, srcy, 0)
779                              sourceSize:MTLSizeMake(width, height, 1)
780                                toBuffer:mtlbuf
781                       destinationOffset:0 /*offset already taken in: pDst = PtrAddBytes(pDst, dstx * dstInfo.pixelStride)*/
782                  destinationBytesPerRow:width*4
783                destinationBytesPerImage:width * height*4];
784             [blitEncoder endEncoding];
785 
786             // Commit and wait for reading complete
787             [cb commit];
788             [cb waitUntilCompleted];
789 
790             // Perform conversion if necessary
791             if (directCopy) {
792                 memcpy(pDst, mtlbuf.contents, srcLength);
793             } else {
794                 J2dTraceLn6(J2D_TRACE_VERBOSE,&quot;MTLBlitLoops_SurfaceToSwBlit: dsttype=%d, raster conversion will be performed, dest rfi: %d, %d, %d, %d, hasA=%d&quot;,
795                             dsttype, rfi.permuteMap[0], rfi.permuteMap[1], rfi.permuteMap[2], rfi.permuteMap[3], rfi.hasAlpha);
796 
797                 // perform raster conversion: mtlIntermediateBuffer(8888) -&gt; pDst(rfi)
798                 // invoked only from rq-thread, so use static buffers
799                 // but it&#39;s better to use thread-local buffers (or special buffer manager)
800                 vImage_Buffer srcBuf;
801                 srcBuf.height = height;
802                 srcBuf.width = width;
803                 srcBuf.rowBytes = 4*width;
804                 srcBuf.data = mtlbuf.contents;
805 
806                 vImage_Buffer destBuf;
807                 destBuf.height = height;
808                 destBuf.width = width;
809                 destBuf.rowBytes = dstInfo.scanStride;
810                 destBuf.data = pDst;
811 
812                 vImagePermuteChannels_ARGB8888(&amp;srcBuf, &amp;destBuf, rfi.permuteMap, kvImageNoFlags);
813             }
814 #ifndef USE_STATIC_BUFFER
815             [mtlbuf release];
816 #endif // USE_STATIC_BUFFER
817         }
818         SurfaceData_InvokeRelease(env, dstOps, &amp;dstInfo);
819     }
820     SurfaceData_InvokeUnlock(env, dstOps, &amp;dstInfo);
821 }
822 
823 void
824 MTLBlitLoops_CopyArea(JNIEnv *env,
825                       MTLContext *mtlc, BMTLSDOps *dstOps,
826                       jint x, jint y, jint width, jint height,
827                       jint dx, jint dy)
828 {
829 #ifdef DEBUG
830     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE, &quot;MTLBlitLoops_CopyArea: bdst=%p [tex=%p] %dx%d | src (%d, %d), %dx%d -&gt; dst (%d, %d)&quot;,
831             dstOps, dstOps-&gt;pTexture, ((id&lt;MTLTexture&gt;)dstOps-&gt;pTexture).width, ((id&lt;MTLTexture&gt;)dstOps-&gt;pTexture).height, x, y, width, height, dx, dy);
832 #endif //DEBUG
833 
834     @autoreleasepool {
835     id&lt;MTLCommandBuffer&gt; cb = [mtlc createCommandBuffer];
836     id&lt;MTLBlitCommandEncoder&gt; blitEncoder = [cb blitCommandEncoder];
837 
838     // Create an intrermediate buffer
839     int totalBuffsize = width * height * 4;
840     id &lt;MTLBuffer&gt; buff = [[mtlc.device newBufferWithLength:totalBuffsize options:MTLResourceStorageModePrivate] autorelease];
841 
842     [blitEncoder copyFromTexture:dstOps-&gt;pTexture
843             sourceSlice:0 sourceLevel:0 sourceOrigin:MTLOriginMake(x, y, 0) sourceSize:MTLSizeMake(width, height, 1)
844              toBuffer:buff destinationOffset:0 destinationBytesPerRow:(width * 4) destinationBytesPerImage:totalBuffsize];
845 
846     [blitEncoder copyFromBuffer:buff
847             sourceOffset:0 sourceBytesPerRow:width*4 sourceBytesPerImage:totalBuffsize sourceSize:MTLSizeMake(width, height, 1)
848             toTexture:dstOps-&gt;pTexture destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(x + dx, y + dy, 0)];
849     [blitEncoder endEncoding];
850 
851     [cb commit];
852     //[cb waitUntilCompleted];
853 
854     /*[blitEncoder
855             copyFromTexture:dstOps-&gt;pTexture
856             sourceSlice:0 sourceLevel:0 sourceOrigin:MTLOriginMake(x, y, 0) sourceSize:MTLSizeMake(width, height, 1)
857             toTexture:dstOps-&gt;pTexture destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(x + dx, y + dy, 0)];
858     [blitEncoder endEncoding];*/
859 
860     }
861     // TODO:
862     //  1. check rect bounds
863     //  2. support CopyArea with extra-alpha (and with custom Composite if necessary)
864 }
865 
866 #endif /* !HEADLESS */
    </pre>
  </body>
</html>