diff a/make/ReleaseFile.gmk b/make/ReleaseFile.gmk
--- a/make/ReleaseFile.gmk
+++ b/make/ReleaseFile.gmk
@@ -51,11 +51,11 @@
   $(if $(VENDOR_VERSION_STRING), \
     $(call info-file-item, "IMPLEMENTOR_VERSION", "$(VENDOR_VERSION_STRING)"))
   $(call info-file-item, "JAVA_VERSION_DATE", "$(VERSION_DATE)")
   $(call info-file-item, "OS_NAME", "$(RELEASE_FILE_OS_NAME)")
   $(call info-file-item, "OS_ARCH", "$(RELEASE_FILE_OS_ARCH)")
-  $(call info-file-item, "LIBC", "$(OPENJDK_TARGET_LIBC)")
+  $(call info-file-item, "LIBC", "$(RELEASE_FILE_LIBC)")
 endef
 
 # Param 1 - The file containing the MODULES list
 define prepare-info-file
   $(call LogInfo, Generating $(patsubst $(OUTPUTDIR)/%,%,$@))
diff a/make/autoconf/build-aux/config.guess b/make/autoconf/build-aux/config.guess
--- a/make/autoconf/build-aux/config.guess
+++ b/make/autoconf/build-aux/config.guess
@@ -28,17 +28,17 @@
 # and fix the broken property, if needed.
 
 DIR=`dirname $0`
 OUT=`. $DIR/autoconf-config.guess`
 
-# config.guess doesn't identify systems running the musl C library, and will
-# instead return a string with a -gnu suffix. This block detects musl and
-# modifies the string to have a -musl suffix instead. 
+# Detect C library.
+# Use '-gnu'  suffix on systems that use glibc.
+# Use '-musl' suffix on systems that use the musl libc.
 echo $OUT | grep -- -linux- > /dev/null 2> /dev/null
 if test $? = 0; then
-  ldd_version=`ldd --version 2>&1 | head -1 | cut -f1 -d' '`
-  if [ x"${ldd_version}" = x"musl" ]; then
+  libc_vendor=`ldd --version 2>&1 | sed -n '1s/.*\(musl\).*/\1/p'`
+  if [ x"${libc_vendor}" = x"musl" ]; then
     OUT=`echo $OUT | sed 's/-gnu/-musl/'`
   fi
 fi
 
 # Test and fix cygwin on x86_64
diff a/make/autoconf/build-aux/config.sub b/make/autoconf/build-aux/config.sub
--- a/make/autoconf/build-aux/config.sub
+++ b/make/autoconf/build-aux/config.sub
@@ -27,12 +27,12 @@
 # autoconf system (which might easily get lost in a future update), we
 # wrap it and fix the broken property, if needed.
 
 DIR=`dirname $0`
 
-if [ "$1"x = "x86_64-unknown-linux-musl"x ]; then
-    echo $1
+if echo $* | grep linux-musl >/dev/null ; then
+    echo $*
     exit
 fi
 
 # Allow wsl
 if echo $* | grep x86_64-pc-wsl >/dev/null ; then
diff a/make/autoconf/flags-cflags.m4 b/make/autoconf/flags-cflags.m4
--- a/make/autoconf/flags-cflags.m4
+++ b/make/autoconf/flags-cflags.m4
@@ -552,10 +552,14 @@
         OS_CFLAGS="$OS_CFLAGS \
             -DMAC_OS_X_VERSION_MAX_ALLOWED=$MACOSX_VERSION_MAX_NODOTS"
     fi
   fi
 
+  if test "x$OPENJDK_TARGET_LIBC" = xmusl; then
+    OS_CFLAGS="$OS_CFLAGS -DMUSL_LIBC"
+  fi
+
   # Where does this really belong??
   if test "x$TOOLCHAIN_TYPE" = xgcc || test "x$TOOLCHAIN_TYPE" = xclang; then
     PICFLAG="-fPIC"
     PIEFLAG="-fPIE"
   elif test "x$TOOLCHAIN_TYPE" = xxlc; then
diff a/make/autoconf/platform.m4 b/make/autoconf/platform.m4
--- a/make/autoconf/platform.m4
+++ b/make/autoconf/platform.m4
@@ -216,11 +216,17 @@
       ;;
     *)
       AC_MSG_ERROR([unsupported operating system $1])
       ;;
   esac
+])
 
+# Support macro for PLATFORM_EXTRACT_TARGET_AND_BUILD.
+# Converts autoconf style OS name to OpenJDK style, into
+# VAR_LIBC.
+AC_DEFUN([PLATFORM_EXTRACT_VARS_FROM_LIBC],
+[
   case "$1" in
     *linux*-musl)
       VAR_LIBC=musl
       ;;
     *linux*-gnu)
@@ -247,13 +253,14 @@
   OPENJDK_TARGET_AUTOCONF_NAME="$host"
   OPENJDK_BUILD_AUTOCONF_NAME="$build"
   AC_SUBST(OPENJDK_TARGET_AUTOCONF_NAME)
   AC_SUBST(OPENJDK_BUILD_AUTOCONF_NAME)
 
-  # Convert the autoconf OS/CPU value to our own data, into the VAR_OS/CPU variables.
+  # Convert the autoconf OS/CPU value to our own data, into the VAR_OS/CPU/LIBC variables.
   PLATFORM_EXTRACT_VARS_FROM_OS($build_os)
   PLATFORM_EXTRACT_VARS_FROM_CPU($build_cpu)
+  PLATFORM_EXTRACT_VARS_FROM_LIBC($build_os)
   # ..and setup our own variables. (Do this explicitly to facilitate searching)
   OPENJDK_BUILD_OS="$VAR_OS"
   if test "x$VAR_OS_TYPE" != x; then
     OPENJDK_BUILD_OS_TYPE="$VAR_OS_TYPE"
   else
@@ -284,13 +291,14 @@
   if test "x$OPENJDK_BUILD_OS" = "xlinux"; then
     AC_MSG_CHECKING([openjdk-build C library])
     AC_MSG_RESULT([$OPENJDK_BUILD_LIBC])
   fi
 
-  # Convert the autoconf OS/CPU value to our own data, into the VAR_OS/CPU variables.
+  # Convert the autoconf OS/CPU value to our own data, into the VAR_OS/CPU/LIBC variables.
   PLATFORM_EXTRACT_VARS_FROM_OS($host_os)
   PLATFORM_EXTRACT_VARS_FROM_CPU($host_cpu)
+  PLATFORM_EXTRACT_VARS_FROM_LIBC($host_os)
   # ... and setup our own variables. (Do this explicitly to facilitate searching)
   OPENJDK_TARGET_OS="$VAR_OS"
   if test "x$VAR_OS_TYPE" != x; then
     OPENJDK_TARGET_OS_TYPE="$VAR_OS_TYPE"
   else
@@ -446,11 +454,11 @@
   else
     OPENJDK_$1_CPU_BUNDLE="$OPENJDK_$1_CPU"
   fi
 
   OPENJDK_$1_LIBC_BUNDLE=""
-  if test "x$OPENJDK_$1_LIBC" = "xmusl"; then  
+  if test "x$OPENJDK_$1_LIBC" = "xmusl"; then
     OPENJDK_$1_LIBC_BUNDLE="-$OPENJDK_$1_LIBC"
   fi
 
   OPENJDK_$1_BUNDLE_PLATFORM="${OPENJDK_$1_OS_BUNDLE}-${OPENJDK_$1_CPU_BUNDLE}${OPENJDK_$1_LIBC_BUNDLE}"
   AC_SUBST(OPENJDK_$1_BUNDLE_PLATFORM)
@@ -555,13 +563,15 @@
   fi
   if test "x$OPENJDK_TARGET_OS" = "xaix"; then
     RELEASE_FILE_OS_NAME="AIX"
   fi
   RELEASE_FILE_OS_ARCH=${OPENJDK_TARGET_CPU}
+  RELEASE_FILE_LIBC=${OPENJDK_TARGET_LIBC}
 
   AC_SUBST(RELEASE_FILE_OS_NAME)
   AC_SUBST(RELEASE_FILE_OS_ARCH)
+  AC_SUBST(RELEASE_FILE_LIBC)
 ])
 
 AC_DEFUN([PLATFORM_SET_MODULE_TARGET_OS_VALUES],
 [
   if test "x$OPENJDK_TARGET_OS" = xmacosx; then
diff a/make/autoconf/spec.gmk.in b/make/autoconf/spec.gmk.in
--- a/make/autoconf/spec.gmk.in
+++ b/make/autoconf/spec.gmk.in
@@ -121,10 +121,11 @@
 OPENJDK_MODULE_TARGET_PLATFORM:=@OPENJDK_MODULE_TARGET_PLATFORM@
 
 # OS_* properties in release file
 RELEASE_FILE_OS_NAME:=@RELEASE_FILE_OS_NAME@
 RELEASE_FILE_OS_ARCH:=@RELEASE_FILE_OS_ARCH@
+RELEASE_FILE_LIBC:=@RELEASE_FILE_LIBC@
 
 SOURCE_DATE := @SOURCE_DATE@
 ENABLE_REPRODUCIBLE_BUILD := @ENABLE_REPRODUCIBLE_BUILD@
 
 LIBM:=@LIBM@
@@ -842,11 +843,10 @@
 #
 # Misc
 #
 
 INCLUDE_SA=@INCLUDE_SA@
-INCLUDE_SA_ATTACH=@INCLUDE_SA_ATTACH@
 INCLUDE_GRAAL=@INCLUDE_GRAAL@
 INCLUDE_JVMCI=@INCLUDE_JVMCI@
 
 OS_VERSION_MAJOR:=@OS_VERSION_MAJOR@
 OS_VERSION_MINOR:=@OS_VERSION_MINOR@
diff a/make/hotspot/lib/CompileJvm.gmk b/make/hotspot/lib/CompileJvm.gmk
--- a/make/hotspot/lib/CompileJvm.gmk
+++ b/make/hotspot/lib/CompileJvm.gmk
@@ -59,22 +59,17 @@
   OPENJDK_TARGET_CPU_VM_VERSION := amd64
 else
   OPENJDK_TARGET_CPU_VM_VERSION := $(OPENJDK_TARGET_CPU)
 endif
 
-ifneq ($(HOTSPOT_TARGET_LIBC),)
-  LIBC_DEFINE := -DHOTSPOT_LIBC='"$(HOTSPOT_TARGET_LIBC)"'
-endif
-
 CFLAGS_VM_VERSION := \
     $(VERSION_CFLAGS) \
     -DHOTSPOT_VERSION_STRING='"$(VERSION_STRING)"' \
     -DDEBUG_LEVEL='"$(DEBUG_LEVEL)"' \
     -DHOTSPOT_BUILD_USER='"$(USERNAME)"' \
     -DHOTSPOT_VM_DISTRO='"$(HOTSPOT_VM_DISTRO)"' \
     -DCPU='"$(OPENJDK_TARGET_CPU_VM_VERSION)"' \
-    $(LIBC_DEFINE) \
     #
 
 ifneq ($(HOTSPOT_BUILD_TIME), )
   CFLAGS_VM_VERSION += -DHOTSPOT_BUILD_TIME='"$(HOTSPOT_BUILD_TIME)"'
 endif
diff a/make/hotspot/lib/JvmFlags.gmk b/make/hotspot/lib/JvmFlags.gmk
--- a/make/hotspot/lib/JvmFlags.gmk
+++ b/make/hotspot/lib/JvmFlags.gmk
@@ -64,14 +64,10 @@
     -DTARGET_COMPILER_$(HOTSPOT_TOOLCHAIN_TYPE) \
     -D$(HOTSPOT_TARGET_CPU_DEFINE) \
     -DHOTSPOT_LIB_ARCH='"$(OPENJDK_TARGET_CPU_LEGACY_LIB)"' \
     #
 
-ifneq ($(HOTSPOT_TARGET_LIBC),)
-  JVM_CFLAGS_TARGET_DEFINES += -DHOTSPOT_LIBC='"$(HOTSPOT_TARGET_LIBC)"'
-endif
-
 ifeq ($(DEBUG_LEVEL), release)
   # For hotspot, release builds differ internally between "optimized" and "product"
   # in that "optimize" does not define PRODUCT.
   ifneq ($(HOTSPOT_DEBUG_LEVEL), optimized)
     JVM_CFLAGS_DEBUGLEVEL := -DPRODUCT
diff a/make/modules/java.base/lib/CoreLibraries.gmk b/make/modules/java.base/lib/CoreLibraries.gmk
--- a/make/modules/java.base/lib/CoreLibraries.gmk
+++ b/make/modules/java.base/lib/CoreLibraries.gmk
@@ -179,12 +179,10 @@
   ifneq ($(MSVCP_DLL), )
     LIBJLI_CFLAGS += -DMSVCP_DLL_NAME='"$(notdir $(MSVCP_DLL))"'
   endif
 endif
 
-LIBJLI_CFLAGS += -DLIBC=\"$(OPENJDK_TARGET_LIBC)\"
-
 LIBJLI_CFLAGS += $(LIBZ_CFLAGS)
 
 ifneq ($(USE_EXTERNAL_LIBZ), true)
   LIBJLI_EXTRA_FILES += \
       $(addprefix $(TOPDIR)/src/java.base/share/native/libzip/zlib/, \
diff a/make/modules/jdk.hotspot.agent/Lib.gmk b/make/modules/jdk.hotspot.agent/Lib.gmk
--- a/make/modules/jdk.hotspot.agent/Lib.gmk
+++ b/make/modules/jdk.hotspot.agent/Lib.gmk
@@ -46,12 +46,10 @@
       SA_CXXFLAGS := -RTC1
     endif
   endif
 endif
 
-SA_CFLAGS += -DLIBC=\"$(OPENJDK_TARGET_LIBC)\"
-
 SA_TOOLCHAIN := $(TOOLCHAIN_DEFAULT)
 ifeq ($(call isTargetOs, linux), true)
   SA_TOOLCHAIN := TOOLCHAIN_LINK_CXX
 endif
 
diff a/make/modules/jdk.jdwp.agent/Lib.gmk b/make/modules/jdk.jdwp.agent/Lib.gmk
--- a/make/modules/jdk.jdwp.agent/Lib.gmk
+++ b/make/modules/jdk.jdwp.agent/Lib.gmk
@@ -29,11 +29,10 @@
 
 $(eval $(call SetupJdkLibrary, BUILD_LIBDT_SOCKET, \
     NAME := dt_socket, \
     OPTIMIZATION := LOW, \
     CFLAGS := $(CFLAGS_JDKLIB) $(LIBDT_SOCKET_CPPFLAGS), \
-    DISABLED_WARNINGS_gcc := stringop-truncation, \
     EXTRA_HEADER_DIRS := \
         include \
         libjdwp/export, \
     LDFLAGS := $(LDFLAGS_JDKLIB) \
         $(call SET_SHARED_LIBRARY_ORIGIN), \
diff a/make/test/JtregNativeJdk.gmk b/make/test/JtregNativeJdk.gmk
--- a/make/test/JtregNativeJdk.gmk
+++ b/make/test/JtregNativeJdk.gmk
@@ -91,15 +91,10 @@
   # stripping during the test libraries' build.
   BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libFib := -g
   BUILD_JDK_JTREG_LIBRARIES_STRIP_SYMBOLS_libFib := false
 endif
 
-ifeq ($(OPENJDK_TARGET_LIBC), musl)
-  # 'strncpy' output truncated before terminating nul copying as many bytes from a string as its length
-  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libInheritedChannel := -Wno-stringop-truncation -Wno-stringop-overflow
-endif
-
 # This evaluation is expensive and should only be done if this target was
 # explicitly called.
 ifneq ($(filter build-test-jdk-jtreg-native, $(MAKECMDGOALS)), )
   $(eval $(call SetupTestFilesCompilation, BUILD_JDK_JTREG_LIBRARIES, \
       TYPE := LIBRARY, \
diff a/src/hotspot/os/linux/os_linux.cpp b/src/hotspot/os/linux/os_linux.cpp
--- a/src/hotspot/os/linux/os_linux.cpp
+++ b/src/hotspot/os/linux/os_linux.cpp
@@ -132,10 +132,21 @@
 #define MAX_SECS 100000000
 
 // for timer info max values which include all bits
 #define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)
 
+#ifdef MUSL_LIBC
+// dlvsym is not a part of POSIX
+// and musl libc doesn't implement it.
+static void *dlvsym(void *handle,
+                    const char *symbol,
+                    const char *version) {
+   // load the latest version of symbol
+   return dlsym(handle, symbol);
+}
+#endif
+
 enum CoredumpFilterBit {
   FILE_BACKED_PVT_BIT = 1 << 2,
   FILE_BACKED_SHARED_BIT = 1 << 3,
   LARGEPAGES_BIT = 1 << 6,
   DAX_SHARED_BIT = 1 << 8
@@ -151,12 +162,12 @@
 int (*os::Linux::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 int (*os::Linux::_pthread_setname_np)(pthread_t, const char*) = NULL;
 pthread_t os::Linux::_main_thread;
 int os::Linux::_page_size = -1;
 bool os::Linux::_supports_fast_thread_cpu_time = false;
-const char * os::Linux::_glibc_version = "unknown";
-const char * os::Linux::_libpthread_version = "unknown";
+const char * os::Linux::_libc_version = NULL;
+const char * os::Linux::_libpthread_version = NULL;
 size_t os::Linux::_default_large_page_size = 0;
 
 static jlong initial_time_count=0;
 
 static int clock_tics_per_sec = 100;
@@ -605,25 +616,28 @@
 #if !defined(_CS_GNU_LIBC_VERSION) || \
     !defined(_CS_GNU_LIBPTHREAD_VERSION)
   #error "glibc too old (< 2.3.2)"
 #endif
 
-  size_t n;
-
-  n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);
-  if (n > 0) {
-    char* str = (char *)malloc(n, mtInternal);
-    confstr(_CS_GNU_LIBC_VERSION, str, n);
-    os::Linux::set_glibc_version(str);
-  }
+#ifdef MUSL_LIBC
+  // confstr() from musl libc returns EINVAL for
+  // _CS_GNU_LIBC_VERSION and _CS_GNU_LIBPTHREAD_VERSION
+  os::Linux::set_libc_version("unknown");
+  os::Linux::set_libpthread_version("unknown");
+#else
+  size_t n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);
+  assert(n > 0, "cannot retrieve glibc version");
+  char *str = (char *)malloc(n, mtInternal);
+  confstr(_CS_GNU_LIBC_VERSION, str, n);
+  os::Linux::set_libc_version(str);
 
   n = confstr(_CS_GNU_LIBPTHREAD_VERSION, NULL, 0);
-  if (n > 0) {
-    char* str = (char *)malloc(n, mtInternal);
-    confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);
-    os::Linux::set_libpthread_version(str);
-  }
+  assert(n > 0, "cannot retrieve pthread version");
+  str = (char *)malloc(n, mtInternal);
+  confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);
+  os::Linux::set_libpthread_version(str);
+#endif
 }
 
 /////////////////////////////////////////////////////////////////////////////
 // thread stack expansion
 
@@ -2317,11 +2331,11 @@
 }
 
 void os::Linux::print_libversion_info(outputStream* st) {
   // libc, pthread
   st->print("libc: ");
-  st->print("%s ", os::Linux::glibc_version());
+  st->print("%s ", os::Linux::libc_version());
   st->print("%s ", os::Linux::libpthread_version());
   st->cr();
 }
 
 void os::Linux::print_proc_sys_info(outputStream* st) {
@@ -3268,48 +3282,34 @@
 
 // Something to do with the numa-aware allocator needs these symbols
 extern "C" JNIEXPORT void numa_warn(int number, char *where, ...) { }
 extern "C" JNIEXPORT void numa_error(char *where) { }
 
-static void* dlvsym_if_available(void* handle, const char* name, const char* version) {
-  typedef void* (*dlvsym_func_type)(void* handle, const char* name, const char* version);
-  static dlvsym_func_type dlvsym_func;
-  static bool initialized = false;
-
-  if (!initialized) {
-    dlvsym_func = (dlvsym_func_type)dlsym(RTLD_NEXT, "dlvsym");
-    initialized = true;
-  }
-
-  if (dlvsym_func != NULL) {
-    void *f = dlvsym_func(handle, name, version);
-    if (f != NULL) {
-      return f;
-    }
-  }
-
-  return dlsym(handle, name);
-}
-
 // Handle request to load libnuma symbol version 1.1 (API v1). If it fails
 // load symbol from base version instead.
 void* os::Linux::libnuma_dlsym(void* handle, const char *name) {
-  return dlvsym_if_available(handle, name, "libnuma_1.1");
+  void *f = dlvsym(handle, name, "libnuma_1.1");
+  if (f == NULL) {
+    f = dlsym(handle, name);
+  }
+  return f;
 }
 
 // Handle request to load libnuma symbol version 1.2 (API v2) only.
 // Return NULL if the symbol is not defined in this particular version.
 void* os::Linux::libnuma_v2_dlsym(void* handle, const char* name) {
-  return dlvsym_if_available(handle, name, "libnuma_1.2");
+  return dlvsym(handle, name, "libnuma_1.2");
 }
 
 bool os::Linux::libnuma_init() {
   if (sched_getcpu() != -1) { // Requires sched_getcpu() support
     void *handle = dlopen("libnuma.so.1", RTLD_LAZY);
     if (handle != NULL) {
       set_numa_node_to_cpus(CAST_TO_FN_PTR(numa_node_to_cpus_func_t,
                                            libnuma_dlsym(handle, "numa_node_to_cpus")));
+      set_numa_node_to_cpus_v2(CAST_TO_FN_PTR(numa_node_to_cpus_v2_func_t,
+                                              libnuma_v2_dlsym(handle, "numa_node_to_cpus")));
       set_numa_max_node(CAST_TO_FN_PTR(numa_max_node_func_t,
                                        libnuma_dlsym(handle, "numa_max_node")));
       set_numa_num_configured_nodes(CAST_TO_FN_PTR(numa_num_configured_nodes_func_t,
                                                    libnuma_dlsym(handle, "numa_num_configured_nodes")));
       set_numa_available(CAST_TO_FN_PTR(numa_available_func_t,
@@ -3455,10 +3455,11 @@
 
 GrowableArray<int>* os::Linux::_cpu_to_node;
 GrowableArray<int>* os::Linux::_nindex_to_node;
 os::Linux::sched_getcpu_func_t os::Linux::_sched_getcpu;
 os::Linux::numa_node_to_cpus_func_t os::Linux::_numa_node_to_cpus;
+os::Linux::numa_node_to_cpus_v2_func_t os::Linux::_numa_node_to_cpus_v2;
 os::Linux::numa_max_node_func_t os::Linux::_numa_max_node;
 os::Linux::numa_num_configured_nodes_func_t os::Linux::_numa_num_configured_nodes;
 os::Linux::numa_available_func_t os::Linux::_numa_available;
 os::Linux::numa_tonode_memory_func_t os::Linux::_numa_tonode_memory;
 os::Linux::numa_interleave_memory_func_t os::Linux::_numa_interleave_memory;
@@ -5254,14 +5255,13 @@
 
 extern void report_error(char* file_name, int line_no, char* title,
                          char* format, ...);
 
 // Some linux distributions (notably: Alpine Linux) include the
-// grsecurity in the kernel by default. Of particular interest from a
-// JVM perspective is PaX (https://pax.grsecurity.net/), which adds
-// some security features related to page attributes. Specifically,
-// the MPROTECT PaX functionality
+// grsecurity in the kernel. Of particular interest from a JVM perspective
+// is PaX (https://pax.grsecurity.net/), which adds some security features
+// related to page attributes. Specifically, the MPROTECT PaX functionality
 // (https://pax.grsecurity.net/docs/mprotect.txt) prevents dynamic
 // code generation by disallowing a (previously) writable page to be
 // marked as executable. This is, of course, exactly what HotSpot does
 // for both JIT compiled method, as well as for stubs, adapters, etc.
 //
@@ -5273,15 +5273,17 @@
 #ifndef ZERO
   size_t size = os::Linux::page_size();
 
   void* p = ::mmap(NULL, size, PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
   if (p == MAP_FAILED) {
+    log_debug(os)("os_linux.cpp: check_pax: mmap failed (%s)" , os::strerror(errno));
     vm_exit_out_of_memory(size, OOM_MMAP_ERROR, "failed to allocate memory for PaX check.");
   }
 
   int res = ::mprotect(p, size, PROT_WRITE|PROT_EXEC);
   if (res == -1) {
+    log_debug(os)("os_linux.cpp: check_pax: mprotect failed (%s)" , os::strerror(errno));
     vm_exit_during_initialization("Failed to mark memory page as executable",
                                   "Please check if grsecurity/PaX is enabled in your kernel.\n"
                                   "\n"
                                   "For example, you can do this by running (note: you may need root privileges):\n"
                                   "\n"
@@ -5484,11 +5486,11 @@
 #endif
 
   Linux::libpthread_init();
   Linux::sched_getcpu_init();
   log_info(os)("HotSpot is running with %s, %s",
-               Linux::glibc_version(), Linux::libpthread_version());
+               Linux::libc_version(), Linux::libpthread_version());
 
   if (UseNUMA || UseNUMAInterleaving) {
     Linux::numa_init();
   }
 
diff a/src/hotspot/os/linux/os_linux.hpp b/src/hotspot/os/linux/os_linux.hpp
--- a/src/hotspot/os/linux/os_linux.hpp
+++ b/src/hotspot/os/linux/os_linux.hpp
@@ -46,11 +46,11 @@
   static int (*_pthread_setname_np)(pthread_t, const char*);
 
   static address   _initial_thread_stack_bottom;
   static uintptr_t _initial_thread_stack_size;
 
-  static const char *_glibc_version;
+  static const char *_libc_version;
   static const char *_libpthread_version;
 
   static bool _supports_fast_thread_cpu_time;
 
   static GrowableArray<int>* _cpu_to_node;
@@ -73,11 +73,11 @@
 
   static int commit_memory_impl(char* addr, size_t bytes, bool exec);
   static int commit_memory_impl(char* addr, size_t bytes,
                                 size_t alignment_hint, bool exec);
 
-  static void set_glibc_version(const char *s)      { _glibc_version = s; }
+  static void set_libc_version(const char *s)       { _libc_version = s; }
   static void set_libpthread_version(const char *s) { _libpthread_version = s; }
 
   static void rebuild_cpu_to_node_map();
   static void rebuild_nindex_to_node_map();
   static GrowableArray<int>* cpu_to_node()    { return _cpu_to_node; }
@@ -164,11 +164,11 @@
   // For signal-chaining
   static struct sigaction *get_chained_signal_action(int sig);
   static bool chained_handler(int sig, siginfo_t* siginfo, void* context);
 
   // GNU libc and libpthread version strings
-  static const char *glibc_version()          { return _glibc_version; }
+  static const char *libc_version()           { return _libc_version; }
   static const char *libpthread_version()     { return _libpthread_version; }
 
   static void libpthread_init();
   static void sched_getcpu_init();
   static bool libnuma_init();
@@ -205,10 +205,11 @@
   static void numa_init();
   static void expand_stack_to(address bottom);
 
   typedef int (*sched_getcpu_func_t)(void);
   typedef int (*numa_node_to_cpus_func_t)(int node, unsigned long *buffer, int bufferlen);
+  typedef int (*numa_node_to_cpus_v2_func_t)(int node, void *mask);
   typedef int (*numa_max_node_func_t)(void);
   typedef int (*numa_num_configured_nodes_func_t)(void);
   typedef int (*numa_available_func_t)(void);
   typedef int (*numa_tonode_memory_func_t)(void *start, size_t size, int node);
   typedef void (*numa_interleave_memory_func_t)(void *start, size_t size, unsigned long *nodemask);
@@ -221,10 +222,11 @@
   typedef int (*numa_bitmask_isbitset_func_t)(struct bitmask *bmp, unsigned int n);
   typedef int (*numa_distance_func_t)(int node1, int node2);
 
   static sched_getcpu_func_t _sched_getcpu;
   static numa_node_to_cpus_func_t _numa_node_to_cpus;
+  static numa_node_to_cpus_v2_func_t _numa_node_to_cpus_v2;
   static numa_max_node_func_t _numa_max_node;
   static numa_num_configured_nodes_func_t _numa_num_configured_nodes;
   static numa_available_func_t _numa_available;
   static numa_tonode_memory_func_t _numa_tonode_memory;
   static numa_interleave_memory_func_t _numa_interleave_memory;
@@ -242,10 +244,11 @@
   static struct bitmask* _numa_interleave_bitmask;
   static struct bitmask* _numa_membind_bitmask;
 
   static void set_sched_getcpu(sched_getcpu_func_t func) { _sched_getcpu = func; }
   static void set_numa_node_to_cpus(numa_node_to_cpus_func_t func) { _numa_node_to_cpus = func; }
+  static void set_numa_node_to_cpus_v2(numa_node_to_cpus_v2_func_t func) { _numa_node_to_cpus_v2 = func; }
   static void set_numa_max_node(numa_max_node_func_t func) { _numa_max_node = func; }
   static void set_numa_num_configured_nodes(numa_num_configured_nodes_func_t func) { _numa_num_configured_nodes = func; }
   static void set_numa_available(numa_available_func_t func) { _numa_available = func; }
   static void set_numa_tonode_memory(numa_tonode_memory_func_t func) { _numa_tonode_memory = func; }
   static void set_numa_interleave_memory(numa_interleave_memory_func_t func) { _numa_interleave_memory = func; }
@@ -272,11 +275,27 @@
   static NumaAllocationPolicy _current_numa_policy;
 
  public:
   static int sched_getcpu()  { return _sched_getcpu != NULL ? _sched_getcpu() : -1; }
   static int numa_node_to_cpus(int node, unsigned long *buffer, int bufferlen) {
-    return _numa_node_to_cpus != NULL ? _numa_node_to_cpus(node, buffer, bufferlen) : -1;
+    // use the latest version of numa_node_to_cpus if available
+    if (_numa_node_to_cpus_v2 != NULL) {
+
+      // libnuma bitmask struct
+      struct bitmask {
+        unsigned long size; /* number of bits in the map */
+        unsigned long *maskp;
+      };
+
+      struct bitmask mask;
+      mask.maskp = (unsigned long *)buffer;
+      mask.size = bufferlen * 8;
+      return _numa_node_to_cpus_v2(node, &mask);
+    } else if (_numa_node_to_cpus != NULL) {
+      return _numa_node_to_cpus(node, buffer, bufferlen);
+    }
+    return -1;
   }
   static int numa_max_node() { return _numa_max_node != NULL ? _numa_max_node() : -1; }
   static int numa_num_configured_nodes() {
     return _numa_num_configured_nodes != NULL ? _numa_num_configured_nodes() : -1;
   }
diff a/src/hotspot/share/gc/shared/genCollectedHeap.cpp b/src/hotspot/share/gc/shared/genCollectedHeap.cpp
--- a/src/hotspot/share/gc/shared/genCollectedHeap.cpp
+++ b/src/hotspot/share/gc/shared/genCollectedHeap.cpp
@@ -1100,11 +1100,11 @@
 // Requires "*prev_ptr" to be non-NULL.  Deletes and a block of minimal size
 // from the list headed by "*prev_ptr".
 static ScratchBlock *removeSmallestScratch(ScratchBlock **prev_ptr) {
   bool first = true;
   size_t min_size = 0;   // "first" makes this conceptually infinite.
-  ScratchBlock **smallest_ptr = NULL, *smallest;
+  ScratchBlock **smallest_ptr, *smallest;
   ScratchBlock  *cur = *prev_ptr;
   while (cur) {
     assert(*prev_ptr == cur, "just checking");
     if (first || cur->num_words < min_size) {
       smallest_ptr = prev_ptr;
diff a/src/hotspot/share/prims/whitebox.cpp b/src/hotspot/share/prims/whitebox.cpp
--- a/src/hotspot/share/prims/whitebox.cpp
+++ b/src/hotspot/share/prims/whitebox.cpp
@@ -2280,10 +2280,22 @@
       os::naked_short_sleep(50);
     }
   }
 WB_END
 
+WB_ENTRY(jstring, WB_GetLibcName(JNIEnv* env, jobject o))
+  ThreadToNativeFromVM ttn(thread);
+#ifdef MUSL_LIBC
+  jstring info_string = env->NewStringUTF("musl");
+#else
+  jstring info_string = env->NewStringUTF("glibc");
+#endif
+  CHECK_JNI_EXCEPTION_(env, NULL);
+
+  return info_string;
+WB_END
+
 #define CC (char*)
 
 static JNINativeMethod methods[] = {
   {CC"getObjectAddress0",                CC"(Ljava/lang/Object;)J", (void*)&WB_GetObjectAddress  },
   {CC"getObjectSize0",                   CC"(Ljava/lang/Object;)J", (void*)&WB_GetObjectSize     },
@@ -2531,10 +2543,11 @@
   {CC"disableElfSectionCache",    CC"()V",            (void*)&WB_DisableElfSectionCache },
   {CC"resolvedMethodItemsCount",  CC"()J",            (void*)&WB_ResolvedMethodItemsCount },
   {CC"protectionDomainRemovedCount",   CC"()I",       (void*)&WB_ProtectionDomainRemovedCount },
   {CC"aotLibrariesCount", CC"()I",                    (void*)&WB_AotLibrariesCount },
   {CC"getKlassMetadataSize", CC"(Ljava/lang/Class;)I",(void*)&WB_GetKlassMetadataSize},
+  {CC"getLibcName",          CC"()Ljava/lang/String;",(void*)&WB_GetLibcName},
 };
 
 
 #undef CC
 
diff a/src/hotspot/share/runtime/abstract_vm_version.cpp b/src/hotspot/share/runtime/abstract_vm_version.cpp
--- a/src/hotspot/share/runtime/abstract_vm_version.cpp
+++ b/src/hotspot/share/runtime/abstract_vm_version.cpp
@@ -255,12 +255,12 @@
     #endif
   #else
     #define FLOAT_ARCH_STR XSTR(FLOAT_ARCH)
   #endif
 
-  #ifdef HOTSPOT_LIBC
-    #define LIBC_STR "-" HOTSPOT_LIBC
+  #ifdef MUSL_LIBC
+    #define LIBC_STR "-musl"
   #else
     #define LIBC_STR ""
   #endif
 
   #ifndef HOTSPOT_BUILD_TIME
diff a/src/java.base/unix/native/libjava/childproc.c b/src/java.base/unix/native/libjava/childproc.c
--- a/src/java.base/unix/native/libjava/childproc.c
+++ b/src/java.base/unix/native/libjava/childproc.c
@@ -234,17 +234,11 @@
             const char *argv[],
             const char *const envp[])
 {
     if (envp == NULL || (char **) envp == environ) {
         execvp(file, (char **) argv);
-        // ENOEXEC indicates that the file header was not recognized. The musl C
-        // library does not implement the fallback to /bin/sh for that case, so fall
-        // through to the code below which implements that fallback using
-        // execve_with_shell_fallback.
-        if (errno != ENOEXEC) {
-            return;
-        }
+        return;
     }
 
     if (*file == '\0') {
         errno = ENOENT;
         return;
diff a/src/java.base/unix/native/libjli/java_md.c b/src/java.base/unix/native/libjli/java_md.c
--- a/src/java.base/unix/native/libjli/java_md.c
+++ b/src/java.base/unix/native/libjli/java_md.c
@@ -228,41 +228,35 @@
     char jpath[PATH_MAX + 1];
     char *llp;
     char *dmllp = NULL;
     char *p; /* a utility pointer */
 
-#ifdef __linux
-#ifndef LIBC
-#error "LIBC not set"
-#endif
-
-    if (strcmp(LIBC, "musl") == 0) {
-      /*
-       * The musl library loader requires LD_LIBRARY_PATH to be set in
-       * order to correctly resolve the dependency libjava.so has on libjvm.so.
-       *
-       * Specifically, it differs from glibc in the sense that even if
-       * libjvm.so has already been loaded it will not be considered a
-       * candidate for resolving the dependency unless the *full* path
-       * of the already loaded library matches the dependency being loaded.
-       *
-       * libjvm.so is being loaded by the launcher using a long path to
-       * dlopen, not just the basename of the library. Typically this
-       * is something like "../lib/server/libjvm.so". However, if/when
-       * libjvm.so later tries to dlopen libjava.so (which it does in
-       * order to get access to a few functions implemented in
-       * libjava.so) the musl loader will, as part of loading
-       * dependent libraries, try to load libjvm.so using only its
-       * basename "libjvm.so". Since this does not match the longer
-       * path path it was first loaded with, the already loaded
-       * library is not considered a candidate, and the loader will
-       * instead look for libjvm.so elsewhere. If it's not in
-       * LD_LIBRARY_PATH the dependency load will fail, and libjava.so
-       * will therefore fail as well.
-       */
-      return JNI_TRUE;
-    }
+#ifdef MUSL_LIBC
+    /*
+     * The musl library loader requires LD_LIBRARY_PATH to be set in order
+     * to correctly resolve the dependency libjava.so has on libjvm.so.
+     *
+     * Specifically, it differs from glibc in the sense that even if
+     * libjvm.so has already been loaded it will not be considered a
+     * candidate for resolving the dependency unless the *full* path
+     * of the already loaded library matches the dependency being loaded.
+     *
+     * libjvm.so is loaded by the launcher using the long path to
+     * dlopen, not just the basename of the library. Typically this
+     * is something like "../lib/server/libjvm.so". However, if/when
+     * libjvm.so later tries to dlopen libjava.so (which it does in
+     * order to get access to a few functions implemented in
+     * libjava.so) the musl loader will, as part of loading
+     * dependent libraries, try to load libjvm.so using only its
+     * basename "libjvm.so". Since this does not match the longer
+     * path it was first loaded with, the already loaded
+     * library is not considered a candidate, and the loader will
+     * instead look for libjvm.so elsewhere. If it's not in
+     * LD_LIBRARY_PATH the dependency load will fail, and libjava.so
+     * will therefore fail as well.
+     */
+    return JNI_TRUE;
 #endif
 
 #ifdef AIX
     /* We always have to set the LIBPATH on AIX because ld doesn't support $ORIGIN. */
     return JNI_TRUE;
diff a/src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c b/src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c
--- a/src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c
+++ b/src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c
@@ -371,14 +371,10 @@
 static bool read_lib_segments(struct ps_prochandle* ph, int lib_fd, ELF_EHDR* lib_ehdr, uintptr_t lib_base) {
   int i = 0;
   ELF_PHDR* phbuf;
   ELF_PHDR* lib_php = NULL;
 
-#ifndef LIBC
-#error "LIBC not set"
-#endif
-
   int page_size = sysconf(_SC_PAGE_SIZE);
 
   if ((phbuf = read_program_header_table(lib_fd, lib_ehdr)) == NULL) {
     return false;
   }
@@ -409,12 +405,12 @@
         // in the coredump (See JDK-7133122).
         // Thus we need to replace the PT_LOAD segment with the library version.
         //
         // Coredump stores value of p_memsz elf field
         // rounded up to page boundary.
-        if ((strcmp(LIBC, "musl")) &&
-            (existing_map->memsz != page_size) &&
+
+        if ((existing_map->memsz != page_size) &&
             (existing_map->fd != lib_fd) &&
             (ROUNDUP(existing_map->memsz, page_size) != ROUNDUP(lib_php->p_memsz, page_size))) {
 
           print_debug("address conflict @ 0x%lx (existing map size = %ld, size = %ld, flags = %d)\n",
                         target_vaddr, existing_map->memsz, lib_php->p_memsz, lib_php->p_flags);
diff a/src/jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c b/src/jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c
--- a/src/jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c
+++ b/src/jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c
@@ -277,15 +277,16 @@
       if (process_doesnt_exist(pid)) {
         print_debug("Thread with pid %d does not exist\n", pid);
         return ATTACH_THREAD_DEAD;
       }
     }
-    char buf[200];
-    if (strerror_r(errno, buf, sizeof(buf) == 0)) {
-      snprintf(err_buf, err_buf_len, "ptrace(PTRACE_ATTACH, ..) failed for %d: %s", pid, buf);
-      print_error("%s\n", err_buf);
-    }
+    // To improve portability across platforms and avoid conflicts
+    // between GNU and XSI versions of strerror_r, plain strerror is used.
+    // It's safe because this code is not used in any multithreaded environment.
+    char* msg = strerror(errno);
+    snprintf(err_buf, err_buf_len, "ptrace(PTRACE_ATTACH, ..) failed for %d: %s", pid, msg);
+    print_error("%s\n", err_buf);
     return ATTACH_FAIL;
   } else {
     attach_state_t wait_ret = ptrace_waitpid(pid);
     if (wait_ret == ATTACH_THREAD_DEAD) {
       print_debug("Thread with pid %d does not exist\n", pid);
diff a/src/jdk.jdwp.agent/share/native/libjdwp/util.h b/src/jdk.jdwp.agent/share/native/libjdwp/util.h
--- a/src/jdk.jdwp.agent/share/native/libjdwp/util.h
+++ b/src/jdk.jdwp.agent/share/native/libjdwp/util.h
@@ -30,22 +30,28 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include <stdarg.h>
 
+#ifdef LINUX
+// Note. On Alpine Linux pthread.h includes calloc/malloc functions declaration.
+// We need to include pthread.h before the following stdlib names poisoning.
+#include <pthread.h>
+#endif
+
 #ifdef DEBUG
     /* Just to make sure these interfaces are not used here. */
     #undef free
-    #define free do_not_use_this_interface_free
+    #define free(p) Do not use this interface.
     #undef malloc
-    #define malloc do_not_use_this_interface_malloc
+    #define malloc(p) Do not use this interface.
     #undef calloc
-    #define calloc do_not_use_this_interface_calloc
+    #define calloc(p) Do not use this interface.
     #undef realloc
-    #define realloc do_not_use_this_interface_realloc
+    #define realloc(p) Do not use this interface.
     #undef strdup
-    #define strdup do_not_use_this_interface_strdup
+    #define strdup(p) Do not use this interface.
 #endif
 
 #include "log_messages.h"
 #include "vm_interface.h"
 #include "JDWP.h"
diff a/test/hotspot/jtreg/TEST.ROOT b/test/hotspot/jtreg/TEST.ROOT
--- a/test/hotspot/jtreg/TEST.ROOT
+++ b/test/hotspot/jtreg/TEST.ROOT
@@ -69,10 +69,11 @@
     vm.cds.custom.loaders \
     vm.cds.archived.java.heap \
     vm.graal.enabled \
     vm.compiler1.enabled \
     vm.compiler2.enabled \
+    vm.musl \
     docker.support \
     test.vm.gc.nvdimm
 
 # Minimum jtreg version
 requiredVersion=5.1 b1
diff a/test/hotspot/jtreg/runtime/8176717/TestInheritFD.java b/test/hotspot/jtreg/runtime/8176717/TestInheritFD.java
--- a/test/hotspot/jtreg/runtime/8176717/TestInheritFD.java
+++ b/test/hotspot/jtreg/runtime/8176717/TestInheritFD.java
@@ -28,10 +28,11 @@
 import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.toList;
 import static jdk.test.lib.process.ProcessTools.createJavaProcessBuilder;
 import static jdk.test.lib.Platform.isWindows;
 import jdk.test.lib.Utils;
+import jdk.test.lib.Platform;
 import jtreg.SkippedException;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -117,17 +118,16 @@
         public static void main(String[] args) throws IOException, InterruptedException {
             ProcessBuilder pb = createJavaProcessBuilder(
                 "-Dtest.jdk=" + getProperty("test.jdk"),
                 VMShouldNotInheritFileDescriptors.class.getName(),
                 args[0],
-                getPid());
+                "" + ProcessHandle.current().pid());
             pb.inheritIO(); // in future, redirect information from third VM to first VM
             pb.start();
 
             if (!isWindows()) {
-                System.out.printf("(Second VM) Open file descriptors: %s%n",
-                        outputContainingFilenames().stream().collect(joining("\n")));
+                System.out.println("(Second VM) Open file descriptors:\n" + outputContainingFilenames().stream().collect(joining("\n")));
             }
         }
     }
 
     static class VMShouldNotInheritFileDescriptors {
@@ -170,39 +170,40 @@
         } catch (IOException e) {
             throw new RuntimeException(e);
         }
     }
 
-    static Optional<Command> lsofCommandCache = stream(new Command[]{
-            new Command("/usr/bin/lsof", "-p"),
-            new Command("/usr/sbin/lsof", "-p"),
-            new Command("/bin/lsof", "-p"),
-            new Command("/sbin/lsof", "-p"),
-            new Command("/usr/local/bin/lsof", "-p"),
-        })
-        .filter(command -> command.exists())
+    static Optional<String[]> lsofCommandCache = stream(new String[][]{
+            {"/usr/bin/lsof", "-p"},
+            {"/usr/sbin/lsof", "-p"},
+            {"/bin/lsof", "-p"},
+            {"/sbin/lsof", "-p"},
+            {"/usr/local/bin/lsof", "-p"}})
+        .filter(args -> new File(args[0]).exists())
         .findFirst();
 
-    static Optional<Command> lsofCommand() {
+    static Optional<String[]> lsofCommand() {
         return lsofCommandCache;
     }
 
-    static Command lsofCmd() {
-        return lsofCommand().orElseThrow(() -> new RuntimeException("lsof like command not found"));
-    }
-
     static Collection<String> outputContainingFilenames() {
-        String pid = getPid();
-        Command command = lsofCmd();
-        System.out.printf("using command: %s%n", command);
-        return run(command.name, command.option, pid)
-                .filter(line -> line.contains(pid))
-                .collect(toList());
+        long pid = ProcessHandle.current().pid();
+
+        String[] command = lsofCommand().orElseThrow(() -> new RuntimeException("lsof like command not found"));
+        System.out.println("using command: " + command[0] + " " + command[1]);
+        return run(command[0], command[1], "" + pid).collect(toList());
     }
 
     static boolean findOpenLogFile(Collection<String> fileNames) {
+        String pid = Long.toString(ProcessHandle.current().pid());
+        String[] command = lsofCommand().orElseThrow(() ->
+                new RuntimeException("lsof like command not found"));
+        String lsof = command[0];
+        boolean isBusybox = Platform.isBusybox(lsof);
         return fileNames.stream()
+            // lsof from busybox does not support "-p" option
+            .filter(fileName -> !isBusybox || fileName.contains(pid))
             .filter(fileName -> fileName.contains(LOG_SUFFIX))
             .findAny()
             .isPresent();
     }
 
@@ -210,30 +211,7 @@
         System.out.println("waiting for pid: " + parentPid);
         ProcessHandle.of(parentPid).ifPresent(handle -> handle.onExit().join());
         System.out.println("trying to rename file to the same name: " + f);
         System.out.println(f.renameTo(f) ? RETAINS_FD : LEAKS_FD); // this parts communicates a closed file descriptor by printing "VM RESULT => RETAINS FD"
     }
-
-    private static String getPid() {
-        return Long.toString(ProcessHandle.current().pid());
-    }
-
-    private static class Command {
-        private final String name;
-        private final String option;
-
-        public Command(String name, String option) {
-            this.name = name;
-            this.option = option;
-        }
-
-        private boolean exists() {
-            return new File(name).exists();
-        }
-
-        public String toString() {
-            return String.format("[name: %s, option: %s]",
-                    name, option);
-        }
-    }
 }
 
diff a/test/hotspot/jtreg/runtime/StackGuardPages/exeinvoke.c b/test/hotspot/jtreg/runtime/StackGuardPages/exeinvoke.c
--- a/test/hotspot/jtreg/runtime/StackGuardPages/exeinvoke.c
+++ b/test/hotspot/jtreg/runtime/StackGuardPages/exeinvoke.c
@@ -90,15 +90,16 @@
     fprintf(stderr, "Test ERROR. Can't set sigaction (%d)\n", errno);
     exit(7);
   }
 }
 
-int get_java_stacksize () {
-  size_t stacksize;
+size_t get_java_stacksize () {
   pthread_attr_t attr;
   JDK1_1InitArgs jdk_args;
 
+  memset(&jdk_args, 0, (sizeof jdk_args));
+
   jdk_args.version = JNI_VERSION_1_1;
   JNI_GetDefaultJavaVMInitArgs(&jdk_args);
   if (jdk_args.javaStackSize <= 0) {
     fprintf(stderr, "Test ERROR. Can't get a valid value for the default stacksize.\n");
     exit(7);
@@ -271,11 +272,11 @@
   if (JNI_CreateJavaVM (&_jvm, (void **)&env, &vm_args) < 0 ) {
     fprintf(stderr, "Test ERROR. Can't create JavaVM\n");
     exit(7);
   }
 
-  int stack_size = get_java_stacksize();
+  size_t stack_size = get_java_stacksize();
   pthread_t thr;
   pthread_attr_t thread_attr;
 
   pthread_attr_init(&thread_attr);
   pthread_attr_setstacksize(&thread_attr, stack_size);
@@ -283,12 +284,12 @@
   if (argc > 1 && strcmp(argv[1], "test_java_overflow") == 0) {
     printf("\nTesting JAVA_OVERFLOW\n");
 
     printf("Testing stack guard page behaviour for other thread\n");
 
-    pthread_create (&thr, &thread_attr, run_java_overflow, NULL);
-    pthread_join (thr, NULL);
+    pthread_create(&thr, &thread_attr, run_java_overflow, NULL);
+    pthread_join(thr, NULL);
 
     printf("Testing stack guard page behaviour for initial thread\n");
     run_java_overflow(NULL);
     // This test crash on error
     exit(0);
@@ -296,12 +297,12 @@
 
   if (argc > 1 && strcmp(argv[1], "test_native_overflow") == 0) {
     printf("\nTesting NATIVE_OVERFLOW\n");
 
     printf("Testing stack guard page behaviour for other thread\n");
-    pthread_create (&thr, &thread_attr, run_native_overflow, NULL);
-    pthread_join (thr, NULL);
+    pthread_create(&thr, &thread_attr, run_native_overflow, NULL);
+    pthread_join(thr, NULL);
 
     printf("Testing stack guard page behaviour for initial thread\n");
     run_native_overflow(NULL);
 
     exit((_failures > 0) ? 1 : 0);
diff a/test/hotspot/jtreg/runtime/jni/terminatedThread/TestTerminatedThread.java b/test/hotspot/jtreg/runtime/jni/terminatedThread/TestTerminatedThread.java
--- a/test/hotspot/jtreg/runtime/jni/terminatedThread/TestTerminatedThread.java
+++ b/test/hotspot/jtreg/runtime/jni/terminatedThread/TestTerminatedThread.java
@@ -24,10 +24,13 @@
 
 /*
  * @test
  * @bug     8205878 8206954
  * @requires os.family != "windows"
+ * @comment Calling pthread_getcpuclockid() with invalid pid leads to undefined
+ * behavior in musl libc (see 8240187).
+ * @requires !vm.musl
  * @summary Basic test of Thread and ThreadMXBean queries on a natively
  *          attached thread that has failed to detach before terminating.
  * @comment The native code only supports POSIX so no windows testing
  * @run main/othervm/native TestTerminatedThread
  */
diff a/test/jdk/java/lang/ProcessBuilder/Basic.java b/test/jdk/java/lang/ProcessBuilder/Basic.java
--- a/test/jdk/java/lang/ProcessBuilder/Basic.java
+++ b/test/jdk/java/lang/ProcessBuilder/Basic.java
@@ -29,19 +29,21 @@
  *      4947220 7018606 7034570 4244896 5049299 8003488 8054494 8058464
  *      8067796 8224905
  * @key intermittent
  * @summary Basic tests for Process and Environment Variable code
  * @modules java.base/java.lang:open
+ * @library /test/lib
  * @run main/othervm/timeout=300 Basic
  * @run main/othervm/timeout=300 -Djdk.lang.Process.launchMechanism=fork Basic
  * @author Martin Buchholz
  */
 
 /*
  * @test
  * @modules java.base/java.lang:open
  * @requires (os.family == "linux")
+ * @library /test/lib
  * @run main/othervm/timeout=300 -Djdk.lang.Process.launchMechanism=posix_spawn Basic
  */
 
 import java.lang.ProcessBuilder.Redirect;
 import java.lang.ProcessHandle;
@@ -61,10 +63,12 @@
 import static java.lang.System.getenv;
 import static java.lang.System.out;
 import static java.lang.Boolean.TRUE;
 import static java.util.AbstractMap.SimpleImmutableEntry;
 
+import jdk.test.lib.Platform;
+
 public class Basic {
 
     /* used for Windows only */
     static final String systemRoot = System.getenv("SystemRoot");
 
@@ -622,17 +626,10 @@
              new File("/bin/sh").exists() &&
              new File("/bin/true").exists() &&
              new File("/bin/false").exists());
     }
 
-    static class BusyBox {
-        public static boolean is() { return is; }
-        private static final boolean is =
-            (! Windows.is() &&
-             new File("/bin/busybox").exists());
-    }
-
     static class UnicodeOS {
         public static boolean is() { return is; }
         private static final String osName = System.getProperty("os.name");
         private static final boolean is =
             // MacOS X would probably also qualify
@@ -667,22 +664,22 @@
                 }
             } catch (Throwable t) { unexpected(t); return -1; }
         }
     }
 
-    // On alpine linux, /bin/true and /bin/false are just links to /bin/busybox.
+    // On Alpine Linux, /bin/true and /bin/false are just links to /bin/busybox.
     // Some tests copy /bin/true and /bin/false to files with a different filename.
     // However, copying the busbox executable into a file with a different name
     // won't result in the expected return codes. As workaround, we create
-    // executable files that can be copied and produce the exepected return
-    // values. We use this workaround, if we find the busybox executable.
+    // executable files that can be copied and produce the expected return
+    // values.
 
     private static class TrueExe {
         public static String path() { return path; }
         private static final String path = path0();
         private static String path0(){
-            if (!BusyBox.is()) {
+            if (!Platform.isBusybox("/bin/true")) {
                 return "/bin/true";
             }
             else {
                 File trueExe = new File("true");
                 setFileContents(trueExe, "#!/bin/true\n");
@@ -694,11 +691,11 @@
 
     private static class FalseExe {
         public static String path() { return path; }
         private static final String path = path0();
         private static String path0(){
-            if (!BusyBox.is()) {
+            if (!Platform.isBusybox("/bin/false")) {
                 return "/bin/false";
             }
             else {
                 File falseExe = new File("false");
                 setFileContents(falseExe, "#!/bin/false\n");
diff a/test/jdk/java/lang/ProcessBuilder/RedirectWithLongFilename.java b/test/jdk/java/lang/ProcessBuilder/RedirectWithLongFilename.java
--- a/test/jdk/java/lang/ProcessBuilder/RedirectWithLongFilename.java
+++ b/test/jdk/java/lang/ProcessBuilder/RedirectWithLongFilename.java
@@ -24,10 +24,12 @@
 /*
  * @test
  * @bug 8072611
  * @summary ProcessBuilder Redirect to file appending on Windows should work with long file names
  * @author Thomas Stuefe
+ * @comment test library compilation is required by Basic class
+ * @library /test/lib
  */
 
 import java.io.File;
 import java.lang.ProcessBuilder.Redirect;
 import java.nio.file.Files;
diff a/test/jdk/java/lang/ProcessHandle/InfoTest.java b/test/jdk/java/lang/ProcessHandle/InfoTest.java
--- a/test/jdk/java/lang/ProcessHandle/InfoTest.java
+++ b/test/jdk/java/lang/ProcessHandle/InfoTest.java
@@ -299,11 +299,11 @@
                 if (info.command().isPresent()) {
                     String command = info.command().get();
                     String expected = "sleep";
                     if (Platform.isWindows()) {
                         expected = "sleep.exe";
-                    } else if (new File("/bin/busybox").exists()) {
+                    } else if (Platform.isBusybox("/bin/sleep")) {
                         // With busybox sleep is just a sym link to busybox.
                         // The busbox executable is seen as ProcessHandle.Info command.
                         expected = "busybox";
                     }
                     Assert.assertTrue(command.endsWith(expected), "Command: expected: \'" +
diff a/test/jdk/tools/launcher/ExecutionEnvironment.java b/test/jdk/tools/launcher/ExecutionEnvironment.java
--- a/test/jdk/tools/launcher/ExecutionEnvironment.java
+++ b/test/jdk/tools/launcher/ExecutionEnvironment.java
@@ -27,11 +27,16 @@
  * @summary Checks for LD_LIBRARY_PATH and execution  on *nixes
  * @library /test/lib
  * @modules jdk.compiler
  *          jdk.zipfs
  * @compile -XDignore.symbol.file ExecutionEnvironment.java
- * @run main/othervm ExecutionEnvironment
+ * @build sun.hotspot.WhiteBox
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ * @run main/othervm -Xbootclasspath/a:.
+ *                   -XX:+UnlockDiagnosticVMOptions
+ *                   -XX:+WhiteBoxAPI
+ *                   ExecutionEnvironment
  */
 
 /*
  * This tests for various things as follows:
  * Ensures that:
@@ -63,10 +68,12 @@
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
+import sun.hotspot.WhiteBox;
+
 public class ExecutionEnvironment extends TestHelper {
     static final String LD_LIBRARY_PATH    = Platform.sharedLibraryPathVariableName();
     static final String LD_LIBRARY_PATH_32 = LD_LIBRARY_PATH + "_32";
     static final String LD_LIBRARY_PATH_64 = LD_LIBRARY_PATH + "_64";
 
@@ -81,10 +88,15 @@
         LD_LIBRARY_PATH_64 + "=" + LD_LIBRARY_PATH_64_VALUE
     };
 
     static final File testJarFile = new File("EcoFriendly.jar");
 
+    private static final boolean isMusl =
+            WhiteBox.getWhiteBox().getLibcName().contains("musl");
+    private static final boolean isExpandedLoadLibraryPath =
+            TestHelper.isAIX || isMusl;
+
     public ExecutionEnvironment() {
         createTestJar();
     }
 
     static void createTestJar() {
@@ -133,26 +145,23 @@
 
         if (!tr.isNotZeroOutput()) {
             flagError(tr, "Error: No output at all. Did the test execute ?");
         }
 
-        boolean isExpandedLibPath = TestHelper.isExpandedSharedLibraryPath;
-
         for (String x : LD_PATH_STRINGS) {
             if (!tr.contains(x)) {
-                if (isExpandedLibPath && x.startsWith(LD_LIBRARY_PATH)) {
+                if (isExpandedLoadLibraryPath
+                        && x.startsWith(LD_LIBRARY_PATH)) {
                     // AIX does not support the '-rpath' linker options so the
                     // launchers have to prepend the jdk library path to 'LIBPATH'.
                     // The musl library loader requires LD_LIBRARY_PATH to be set in
                     // order to correctly resolve the dependency libjava.so has on libjvm.so.
-                    String expandedLibPath = String.format("%s=%s%c%s",
-                            LD_LIBRARY_PATH,
-                            System.getenv(LD_LIBRARY_PATH),
-                            File.pathSeparatorChar,
-                            LD_LIBRARY_PATH_VALUE);
-                    if (!tr.matches(expandedLibPath)) {
-                        flagError(tr, "FAIL: did not get <" + expandedLibPath + ">");
+                    String libPath = LD_LIBRARY_PATH + "=" +
+                        System.getenv(LD_LIBRARY_PATH) +
+                        System.getProperty("path.separator") + LD_LIBRARY_PATH_VALUE;
+                    if (!tr.matches(libPath)) {
+                        flagError(tr, "FAIL: did not get <" + libPath + ">");
                     }
                 }
                 else {
                     flagError(tr, "FAIL: did not get <" + x + ">");
                 }
diff a/test/jdk/tools/launcher/Test7029048.java b/test/jdk/tools/launcher/Test7029048.java
--- a/test/jdk/tools/launcher/Test7029048.java
+++ b/test/jdk/tools/launcher/Test7029048.java
@@ -26,23 +26,32 @@
  * @bug 7029048 8217340 8217216
  * @summary Ensure that the launcher defends against user settings of the
  *          LD_LIBRARY_PATH environment variable on Unixes
  * @library /test/lib
  * @compile -XDignore.symbol.file ExecutionEnvironment.java Test7029048.java
- * @run main Test7029048
+ * @build sun.hotspot.WhiteBox
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI Test7029048
  */
 
 import java.io.File;
 import java.io.IOException;
 import java.nio.file.Files;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
+import sun.hotspot.WhiteBox;
+
 public class Test7029048 extends TestHelper {
 
+    private static final boolean isMusl =
+            WhiteBox.getWhiteBox().getLibcName().contains("musl");
+    private static final boolean isExpandedLoadLibraryPath =
+            TestHelper.isAIX || isMusl;
+
     private static final String LIBJVM = ExecutionEnvironment.LIBJVM;
     private static final String LD_LIBRARY_PATH =
             ExecutionEnvironment.LD_LIBRARY_PATH;
     private static final String LD_LIBRARY_PATH_64 =
             ExecutionEnvironment.LD_LIBRARY_PATH_64;
@@ -153,21 +162,21 @@
                     } else {
                         Files.deleteIfExists(dstServerLibjvm.toPath());
                     }
 
                     desc = "LD_LIBRARY_PATH should not be set (no libjvm.so)";
-                    if (TestHelper.isExpandedSharedLibraryPath) {
+                    if (isExpandedLoadLibraryPath) {
                         printSkipMessage(desc);
                         continue;
                     }
                     break;
                 case NO_DIR:
                     if (dstLibDir.exists()) {
                         recursiveDelete(dstLibDir);
                     }
                     desc = "LD_LIBRARY_PATH should not be set (no directory)";
-                    if (TestHelper.isExpandedSharedLibraryPath) {
+                    if (isExpandedLoadLibraryPath) {
                         printSkipMessage(desc);
                         continue;
                     }
                     break;
                 default:
@@ -191,12 +200,12 @@
         }
         return pass;
     }
 
     private static void printSkipMessage(String description) {
-        System.out.printf("Skipping test case '%s' because the Aix launcher" +
-                          " adds the paths in any case.%n", description);
+        System.out.printf("Skipping test case '%s' because the Aix and musl launchers" +
+                          " add the paths in any case.%n", description);
     }
 
     public static void main(String... args) throws Exception {
         if (TestHelper.isWindows || TestHelper.isMacOSX) {
             System.out.println("Note: applicable on neither Windows nor MacOSX");
diff a/test/jdk/tools/launcher/TestHelper.java b/test/jdk/tools/launcher/TestHelper.java
--- a/test/jdk/tools/launcher/TestHelper.java
+++ b/test/jdk/tools/launcher/TestHelper.java
@@ -87,15 +87,13 @@
             System.getProperty("sun.arch.data.model").equals("32");
     static final boolean isLinux =
             System.getProperty("os.name", "unknown").startsWith("Linux");
     static final boolean isAIX =
             System.getProperty("os.name", "unknown").startsWith("AIX");
-    static final boolean isMusl = isMuslLibc();
     static final String LIBJVM = isWindows
                         ? "jvm.dll"
                         : "libjvm" + (isMacOSX ? ".dylib" : ".so");
-    static final boolean isExpandedSharedLibraryPath = isAIX || isMusl;
 
     // make a note of the golden default locale
     static final Locale DefaultLocale = Locale.getDefault();
 
     static final String JAVA_FILE_EXT   = ".java";
@@ -532,31 +530,10 @@
             "}"
         };
         createFile(new File(launcherTestDir, "Main.java"), Arrays.asList(moduleCode));
     }
 
-    /**
-     * Check if we run with musl libc.
-     *
-     * @return true if we run with musl libc.
-     */
-    private static boolean isMuslLibc() {
-        try {
-            ProcessBuilder pb = new ProcessBuilder("ldd", "--version");
-            pb.redirectErrorStream(true);
-            final Process p = pb.start();
-            try (BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()))) {
-                return br.lines()
-                        .findFirst()
-                        .filter(line -> line.contains("musl"))
-                        .isPresent();
-            }
-        } catch (Exception ignore) {
-        }
-        return false;
-    }
-
     static class ToolFilter implements FileFilter {
         final List<String> exclude = new ArrayList<>();
         protected ToolFilter(String... exclude) {
             for (String x : exclude) {
                 String str = x + ((isWindows) ? EXE_FILE_EXT : "");
diff a/test/jtreg-ext/requires/VMProps.java b/test/jtreg-ext/requires/VMProps.java
--- a/test/jtreg-ext/requires/VMProps.java
+++ b/test/jtreg-ext/requires/VMProps.java
@@ -21,15 +21,13 @@
  * questions.
  */
 package requires;
 
 import java.io.BufferedInputStream;
-import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.InputStreamReader;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.StandardOpenOption;
 import java.util.ArrayList;
@@ -505,27 +503,16 @@
 
         return (p.exitValue() == 0);
     }
 
     /**
-     * Check if we run with musl libc.
+     * Checks musl libc.
      *
-     * @return true if we run with musl libc.
+     * @return true if musl libc is used.
      */
     protected String isMusl() {
-        try {
-            ProcessBuilder pb = new ProcessBuilder("ldd", "--version");
-            pb.redirectErrorStream(true);
-            final Process p = pb.start();
-            BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
-            String line = br.readLine();
-            if (line != null && line.contains("musl")) {
-                return "true";
-            }
-        } catch (Exception e) {
-        }
-        return "false";
+        return Boolean.toString(WB.getLibcName().contains("musl"));
     }
 
     private String implementor() {
         try (InputStream in = new BufferedInputStream(new FileInputStream(
                 System.getProperty("java.home") + "/release"))) {
diff a/test/lib/jdk/test/lib/Platform.java b/test/lib/jdk/test/lib/Platform.java
--- a/test/lib/jdk/test/lib/Platform.java
+++ b/test/lib/jdk/test/lib/Platform.java
@@ -107,10 +107,25 @@
 
     public static boolean isLinux() {
         return isOs("linux");
     }
 
+    public static boolean isBusybox(String tool) {
+        try {
+
+            Path busybox = Paths.get("/bin/busybox");
+            Path toolpath = Paths.get(tool);
+
+            return !isWindows()
+                    && Files.exists(busybox)
+                    && Files.isSymbolicLink(toolpath)
+                    && busybox.equals(Files.readSymbolicLink(toolpath));
+        } catch (IOException ignore) {
+            return false;
+        }
+    }
+
     public static boolean isOSX() {
         return isOs("mac");
     }
 
     public static boolean isWindows() {
diff a/test/lib/sun/hotspot/WhiteBox.java b/test/lib/sun/hotspot/WhiteBox.java
--- a/test/lib/sun/hotspot/WhiteBox.java
+++ b/test/lib/sun/hotspot/WhiteBox.java
@@ -616,6 +616,9 @@
 
   public native int getKlassMetadataSize(Class<?> c);
 
   // ThreadSMR GC safety check for threadObj
   public native void checkThreadObjOfTerminatingThread(Thread target);
+
+  // libc name
+  public native String getLibcName();
 }
