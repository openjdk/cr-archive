<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/lang/ProcessBuilder/Basic.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * @test
  26  * @bug 4199068 4738465 4937983 4930681 4926230 4931433 4932663 4986689
  27  *      5026830 5023243 5070673 4052517 4811767 6192449 6397034 6413313
  28  *      6464154 6523983 6206031 4960438 6631352 6631966 6850957 6850958
  29  *      4947220 7018606 7034570 4244896 5049299 8003488 8054494 8058464
  30  *      8067796 8224905
  31  * @key intermittent
  32  * @summary Basic tests for Process and Environment Variable code
  33  * @modules java.base/java.lang:open
<a name="1" id="anc1"></a><span class="line-added">  34  * @library /test/lib</span>
  35  * @run main/othervm/timeout=300 Basic
  36  * @run main/othervm/timeout=300 -Djdk.lang.Process.launchMechanism=fork Basic
  37  * @author Martin Buchholz
  38  */
  39 
  40 /*
  41  * @test
  42  * @modules java.base/java.lang:open
  43  * @requires (os.family == &quot;linux&quot;)
<a name="2" id="anc2"></a><span class="line-added">  44  * @library /test/lib</span>
  45  * @run main/othervm/timeout=300 -Djdk.lang.Process.launchMechanism=posix_spawn Basic
  46  */
  47 
  48 import java.lang.ProcessBuilder.Redirect;
  49 import java.lang.ProcessHandle;
  50 import static java.lang.ProcessBuilder.Redirect.*;
  51 
  52 import java.io.*;
  53 import java.lang.reflect.Field;
  54 import java.nio.file.Files;
  55 import java.nio.file.Paths;
  56 import java.nio.file.StandardCopyOption;
  57 import java.util.*;
  58 import java.util.concurrent.CountDownLatch;
  59 import java.util.concurrent.TimeUnit;
  60 import java.security.*;
  61 import java.util.regex.Pattern;
  62 import java.util.regex.Matcher;
  63 import static java.lang.System.getenv;
  64 import static java.lang.System.out;
  65 import static java.lang.Boolean.TRUE;
  66 import static java.util.AbstractMap.SimpleImmutableEntry;
  67 
<a name="3" id="anc3"></a><span class="line-added">  68 import jdk.test.lib.Platform;</span>
<span class="line-added">  69 </span>
  70 public class Basic {
  71 
  72     /* used for Windows only */
  73     static final String systemRoot = System.getenv(&quot;SystemRoot&quot;);
  74 
  75     /* used for Mac OS X only */
  76     static final String cfUserTextEncoding = System.getenv(&quot;__CF_USER_TEXT_ENCODING&quot;);
  77 
  78     /* used for AIX only */
  79     static final String libpath = System.getenv(&quot;LIBPATH&quot;);
  80 
  81     /* Used for regex String matching for long error messages */
  82     static final String PERMISSION_DENIED_ERROR_MSG = &quot;(Permission denied|error=13)&quot;;
  83     static final String NO_SUCH_FILE_ERROR_MSG = &quot;(No such file|error=2)&quot;;
  84 
  85     /**
  86      * Returns the number of milliseconds since time given by
  87      * startNanoTime, which must have been previously returned from a
  88      * call to {@link System.nanoTime()}.
  89      */
  90     private static long millisElapsedSince(long startNanoTime) {
  91         return TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanoTime);
  92     }
  93 
  94     private static String commandOutput(Reader r) throws Throwable {
  95         StringBuilder sb = new StringBuilder();
  96         int c;
  97         while ((c = r.read()) &gt; 0)
  98             if (c != &#39;\r&#39;)
  99                 sb.append((char) c);
 100         return sb.toString();
 101     }
 102 
 103     private static String commandOutput(Process p) throws Throwable {
 104         check(p.getInputStream()  == p.getInputStream());
 105         check(p.getOutputStream() == p.getOutputStream());
 106         check(p.getErrorStream()  == p.getErrorStream());
 107         Reader r = new InputStreamReader(p.getInputStream(),&quot;UTF-8&quot;);
 108         String output = commandOutput(r);
 109         equal(p.waitFor(), 0);
 110         equal(p.exitValue(), 0);
 111         // The debug/fastdebug versions of the VM may write some warnings to stdout
 112         // (i.e. &quot;Warning:  Cannot open log file: hotspot.log&quot; if the VM is started
 113         // in a directory without write permissions). These warnings will confuse tests
 114         // which match the entire output of the child process so better filter them out.
 115         return output.replaceAll(&quot;Warning:.*\\n&quot;, &quot;&quot;);
 116     }
 117 
 118     private static String commandOutput(ProcessBuilder pb) {
 119         try {
 120             return commandOutput(pb.start());
 121         } catch (Throwable t) {
 122             String commandline = &quot;&quot;;
 123             for (String arg : pb.command())
 124                 commandline += &quot; &quot; + arg;
 125             System.out.println(&quot;Exception trying to run process: &quot; + commandline);
 126             unexpected(t);
 127             return &quot;&quot;;
 128         }
 129     }
 130 
 131     private static String commandOutput(String...command) {
 132         try {
 133             return commandOutput(Runtime.getRuntime().exec(command));
 134         } catch (Throwable t) {
 135             String commandline = &quot;&quot;;
 136             for (String arg : command)
 137                 commandline += &quot; &quot; + arg;
 138             System.out.println(&quot;Exception trying to run process: &quot; + commandline);
 139             unexpected(t);
 140             return &quot;&quot;;
 141         }
 142     }
 143 
 144     private static void checkCommandOutput(ProcessBuilder pb,
 145                                            String expected,
 146                                            String failureMsg) {
 147         String got = commandOutput(pb);
 148         check(got.equals(expected),
 149               failureMsg + &quot;\n&quot; +
 150               &quot;Expected: \&quot;&quot; + expected + &quot;\&quot;\n&quot; +
 151               &quot;Got: \&quot;&quot; + got + &quot;\&quot;&quot;);
 152     }
 153 
 154     private static String absolutifyPath(String path) {
 155         StringBuilder sb = new StringBuilder();
 156         for (String file : path.split(File.pathSeparator)) {
 157             if (sb.length() != 0)
 158                 sb.append(File.pathSeparator);
 159             sb.append(new File(file).getAbsolutePath());
 160         }
 161         return sb.toString();
 162     }
 163 
 164     // compare windows-style, by canonicalizing to upper case,
 165     // not lower case as String.compareToIgnoreCase does
 166     private static class WindowsComparator
 167         implements Comparator&lt;String&gt; {
 168         public int compare(String x, String y) {
 169             return x.toUpperCase(Locale.US)
 170                 .compareTo(y.toUpperCase(Locale.US));
 171         }
 172     }
 173 
 174     private static String sortedLines(String lines) {
 175         String[] arr = lines.split(&quot;\n&quot;);
 176         List&lt;String&gt; ls = new ArrayList&lt;String&gt;();
 177         for (String s : arr)
 178             ls.add(s);
 179         Collections.sort(ls, new WindowsComparator());
 180         StringBuilder sb = new StringBuilder();
 181         for (String s : ls)
 182             sb.append(s + &quot;\n&quot;);
 183         return sb.toString();
 184     }
 185 
 186     private static void compareLinesIgnoreCase(String lines1, String lines2) {
 187         if (! (sortedLines(lines1).equalsIgnoreCase(sortedLines(lines2)))) {
 188             String dashes =
 189                 &quot;-----------------------------------------------------&quot;;
 190             out.println(dashes);
 191             out.print(sortedLines(lines1));
 192             out.println(dashes);
 193             out.print(sortedLines(lines2));
 194             out.println(dashes);
 195             out.println(&quot;sizes: &quot; + sortedLines(lines1).length() +
 196                         &quot; &quot; + sortedLines(lines2).length());
 197 
 198             fail(&quot;Sorted string contents differ&quot;);
 199         }
 200     }
 201 
 202     private static final Runtime runtime = Runtime.getRuntime();
 203 
 204     private static final String[] winEnvCommand = {&quot;cmd.exe&quot;, &quot;/c&quot;, &quot;set&quot;};
 205 
 206     private static String winEnvFilter(String env) {
 207         return env.replaceAll(&quot;\r&quot;, &quot;&quot;)
 208             .replaceAll(&quot;(?m)^(?:COMSPEC|PROMPT|PATHEXT)=.*\n&quot;,&quot;&quot;);
 209     }
 210 
 211     private static String unixEnvProg() {
 212         return new File(&quot;/usr/bin/env&quot;).canExecute() ? &quot;/usr/bin/env&quot;
 213             : &quot;/bin/env&quot;;
 214     }
 215 
 216     private static String nativeEnv(String[] env) {
 217         try {
 218             if (Windows.is()) {
 219                 return winEnvFilter
 220                     (commandOutput(runtime.exec(winEnvCommand, env)));
 221             } else {
 222                 return commandOutput(runtime.exec(unixEnvProg(), env));
 223             }
 224         } catch (Throwable t) { throw new Error(t); }
 225     }
 226 
 227     private static String nativeEnv(ProcessBuilder pb) {
 228         try {
 229             if (Windows.is()) {
 230                 pb.command(winEnvCommand);
 231                 return winEnvFilter(commandOutput(pb));
 232             } else {
 233                 pb.command(new String[]{unixEnvProg()});
 234                 return commandOutput(pb);
 235             }
 236         } catch (Throwable t) { throw new Error(t); }
 237     }
 238 
 239     private static void checkSizes(Map&lt;String,String&gt; environ, int size) {
 240         try {
 241             equal(size, environ.size());
 242             equal(size, environ.entrySet().size());
 243             equal(size, environ.keySet().size());
 244             equal(size, environ.values().size());
 245 
 246             boolean isEmpty = (size == 0);
 247             equal(isEmpty, environ.isEmpty());
 248             equal(isEmpty, environ.entrySet().isEmpty());
 249             equal(isEmpty, environ.keySet().isEmpty());
 250             equal(isEmpty, environ.values().isEmpty());
 251         } catch (Throwable t) { unexpected(t); }
 252     }
 253 
 254     private interface EnvironmentFrobber {
 255         void doIt(Map&lt;String,String&gt; environ);
 256     }
 257 
 258     private static void testVariableDeleter(EnvironmentFrobber fooDeleter) {
 259         try {
 260             Map&lt;String,String&gt; environ = new ProcessBuilder().environment();
 261             environ.put(&quot;Foo&quot;, &quot;BAAR&quot;);
 262             fooDeleter.doIt(environ);
 263             equal(environ.get(&quot;Foo&quot;), null);
 264             equal(environ.remove(&quot;Foo&quot;), null);
 265         } catch (Throwable t) { unexpected(t); }
 266     }
 267 
 268     private static void testVariableAdder(EnvironmentFrobber fooAdder) {
 269         try {
 270             Map&lt;String,String&gt; environ = new ProcessBuilder().environment();
 271             environ.remove(&quot;Foo&quot;);
 272             fooAdder.doIt(environ);
 273             equal(environ.get(&quot;Foo&quot;), &quot;Bahrein&quot;);
 274         } catch (Throwable t) { unexpected(t); }
 275     }
 276 
 277     private static void testVariableModifier(EnvironmentFrobber fooModifier) {
 278         try {
 279             Map&lt;String,String&gt; environ = new ProcessBuilder().environment();
 280             environ.put(&quot;Foo&quot;,&quot;OldValue&quot;);
 281             fooModifier.doIt(environ);
 282             equal(environ.get(&quot;Foo&quot;), &quot;NewValue&quot;);
 283         } catch (Throwable t) { unexpected(t); }
 284     }
 285 
 286     private static void printUTF8(String s) throws IOException {
 287         out.write(s.getBytes(&quot;UTF-8&quot;));
 288     }
 289 
 290     private static String getenvAsString(Map&lt;String,String&gt; environment) {
 291         StringBuilder sb = new StringBuilder();
 292         environment = new TreeMap&lt;&gt;(environment);
 293         for (Map.Entry&lt;String,String&gt; e : environment.entrySet())
 294             // Ignore magic environment variables added by the launcher
 295             if (! e.getKey().equals(&quot;LD_LIBRARY_PATH&quot;))
 296                 sb.append(e.getKey())
 297                     .append(&#39;=&#39;)
 298                     .append(e.getValue())
 299                     .append(&#39;,&#39;);
 300         return sb.toString();
 301     }
 302 
 303     static void print4095(OutputStream s, byte b) throws Throwable {
 304         byte[] bytes = new byte[4095];
 305         Arrays.fill(bytes, b);
 306         s.write(bytes);         // Might hang!
 307     }
 308 
 309     static void checkPermissionDenied(ProcessBuilder pb) {
 310         try {
 311             pb.start();
 312             fail(&quot;Expected IOException not thrown&quot;);
 313         } catch (IOException e) {
 314             String m = e.getMessage();
 315             if (EnglishUnix.is() &amp;&amp;
 316                 ! matches(m, PERMISSION_DENIED_ERROR_MSG))
 317                 unexpected(e);
 318         } catch (Throwable t) { unexpected(t); }
 319     }
 320 
 321     public static class JavaChild {
 322         public static void main(String args[]) throws Throwable {
 323             String action = args[0];
 324             if (action.equals(&quot;sleep&quot;)) {
 325                 Thread.sleep(10 * 60 * 1000L);
 326             } else if (action.equals(&quot;pid&quot;)) {
 327                 System.out.println(ProcessHandle.current().pid());
 328             } else if (action.equals(&quot;testIO&quot;)) {
 329                 String expected = &quot;standard input&quot;;
 330                 char[] buf = new char[expected.length()+1];
 331                 int n = new InputStreamReader(System.in).read(buf,0,buf.length);
 332                 if (n != expected.length())
 333                     System.exit(5);
 334                 if (! new String(buf,0,n).equals(expected))
 335                     System.exit(5);
 336                 System.err.print(&quot;standard error&quot;);
 337                 System.out.print(&quot;standard output&quot;);
 338             } else if (action.equals(&quot;testInheritIO&quot;)
 339                     || action.equals(&quot;testRedirectInherit&quot;)) {
 340                 List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
 341                 childArgs.add(&quot;testIO&quot;);
 342                 ProcessBuilder pb = new ProcessBuilder(childArgs);
 343                 if (action.equals(&quot;testInheritIO&quot;))
 344                     pb.inheritIO();
 345                 else
 346                     redirectIO(pb, INHERIT, INHERIT, INHERIT);
 347                 ProcessResults r = run(pb);
 348                 if (! r.out().equals(&quot;&quot;))
 349                     System.exit(7);
 350                 if (! r.err().equals(&quot;&quot;))
 351                     System.exit(8);
 352                 if (r.exitValue() != 0)
 353                     System.exit(9);
 354             } else if (action.equals(&quot;System.getenv(String)&quot;)) {
 355                 String val = System.getenv(args[1]);
 356                 printUTF8(val == null ? &quot;null&quot; : val);
 357             } else if (action.equals(&quot;System.getenv(\\u1234)&quot;)) {
 358                 String val = System.getenv(&quot;\u1234&quot;);
 359                 printUTF8(val == null ? &quot;null&quot; : val);
 360             } else if (action.equals(&quot;System.getenv()&quot;)) {
 361                 printUTF8(getenvAsString(System.getenv()));
 362             } else if (action.equals(&quot;ArrayOOME&quot;)) {
 363                 Object dummy;
 364                 switch(new Random().nextInt(3)) {
 365                 case 0: dummy = new Integer[Integer.MAX_VALUE]; break;
 366                 case 1: dummy = new double[Integer.MAX_VALUE];  break;
 367                 case 2: dummy = new byte[Integer.MAX_VALUE][];  break;
 368                 default: throw new InternalError();
 369                 }
 370             } else if (action.equals(&quot;pwd&quot;)) {
 371                 printUTF8(new File(System.getProperty(&quot;user.dir&quot;))
 372                           .getCanonicalPath());
 373             } else if (action.equals(&quot;print4095&quot;)) {
 374                 print4095(System.out, (byte) &#39;!&#39;);
 375                 print4095(System.err, (byte) &#39;E&#39;);
 376                 System.exit(5);
 377             } else if (action.equals(&quot;OutErr&quot;)) {
 378                 // You might think the system streams would be
 379                 // buffered, and in fact they are implemented using
 380                 // BufferedOutputStream, but each and every print
 381                 // causes immediate operating system I/O.
 382                 System.out.print(&quot;out&quot;);
 383                 System.err.print(&quot;err&quot;);
 384                 System.out.print(&quot;out&quot;);
 385                 System.err.print(&quot;err&quot;);
 386             } else if (action.equals(&quot;null PATH&quot;)) {
 387                 equal(System.getenv(&quot;PATH&quot;), null);
 388                 check(new File(&quot;/bin/true&quot;).exists());
 389                 check(new File(&quot;/bin/false&quot;).exists());
 390                 ProcessBuilder pb1 = new ProcessBuilder();
 391                 ProcessBuilder pb2 = new ProcessBuilder();
 392                 pb2.environment().put(&quot;PATH&quot;, &quot;anyOldPathIgnoredAnyways&quot;);
 393                 ProcessResults r;
 394 
 395                 for (final ProcessBuilder pb :
 396                          new ProcessBuilder[] {pb1, pb2}) {
 397                     pb.command(&quot;true&quot;);
 398                     equal(run(pb).exitValue(), True.exitValue());
 399 
 400                     pb.command(&quot;false&quot;);
 401                     equal(run(pb).exitValue(), False.exitValue());
 402                 }
 403 
 404                 if (failed != 0) throw new Error(&quot;null PATH&quot;);
 405             } else if (action.equals(&quot;PATH search algorithm&quot;)) {
 406                 equal(System.getenv(&quot;PATH&quot;), &quot;dir1:dir2:&quot;);
 407                 check(new File(TrueExe.path()).exists());
 408                 check(new File(FalseExe.path()).exists());
 409                 String[] cmd = {&quot;prog&quot;};
 410                 ProcessBuilder pb1 = new ProcessBuilder(cmd);
 411                 ProcessBuilder pb2 = new ProcessBuilder(cmd);
 412                 ProcessBuilder pb3 = new ProcessBuilder(cmd);
 413                 pb2.environment().put(&quot;PATH&quot;, &quot;anyOldPathIgnoredAnyways&quot;);
 414                 pb3.environment().remove(&quot;PATH&quot;);
 415 
 416                 for (final ProcessBuilder pb :
 417                          new ProcessBuilder[] {pb1, pb2, pb3}) {
 418                     try {
 419                         // Not on PATH at all; directories don&#39;t exist
 420                         try {
 421                             pb.start();
 422                             fail(&quot;Expected IOException not thrown&quot;);
 423                         } catch (IOException e) {
 424                             String m = e.getMessage();
 425                             if (EnglishUnix.is() &amp;&amp;
 426                                 ! matches(m, NO_SUCH_FILE_ERROR_MSG))
 427                                 unexpected(e);
 428                         } catch (Throwable t) { unexpected(t); }
 429 
 430                         // Not on PATH at all; directories exist
 431                         new File(&quot;dir1&quot;).mkdirs();
 432                         new File(&quot;dir2&quot;).mkdirs();
 433                         try {
 434                             pb.start();
 435                             fail(&quot;Expected IOException not thrown&quot;);
 436                         } catch (IOException e) {
 437                             String m = e.getMessage();
 438                             if (EnglishUnix.is() &amp;&amp;
 439                                 ! matches(m, NO_SUCH_FILE_ERROR_MSG))
 440                                 unexpected(e);
 441                         } catch (Throwable t) { unexpected(t); }
 442 
 443                         // Can&#39;t execute a directory -- permission denied
 444                         // Report EACCES errno
 445                         new File(&quot;dir1/prog&quot;).mkdirs();
 446                         checkPermissionDenied(pb);
 447 
 448                         // continue searching if EACCES
 449                         copy(TrueExe.path(), &quot;dir2/prog&quot;);
 450                         equal(run(pb).exitValue(), True.exitValue());
 451                         new File(&quot;dir1/prog&quot;).delete();
 452                         new File(&quot;dir2/prog&quot;).delete();
 453 
 454                         new File(&quot;dir2/prog&quot;).mkdirs();
 455                         copy(TrueExe.path(), &quot;dir1/prog&quot;);
 456                         equal(run(pb).exitValue(), True.exitValue());
 457 
 458                         // Check empty PATH component means current directory.
 459                         //
 460                         // While we&#39;re here, let&#39;s test different kinds of
 461                         // Unix executables, and PATH vs explicit searching.
 462                         new File(&quot;dir1/prog&quot;).delete();
 463                         new File(&quot;dir2/prog&quot;).delete();
 464                         for (String[] command :
 465                                  new String[][] {
 466                                      new String[] {&quot;./prog&quot;},
 467                                      cmd}) {
 468                             pb.command(command);
 469                             File prog = new File(&quot;./prog&quot;);
 470                             // &quot;Normal&quot; binaries
 471                             copy(TrueExe.path(), &quot;./prog&quot;);
 472                             equal(run(pb).exitValue(),
 473                                   True.exitValue());
 474                             copy(FalseExe.path(), &quot;./prog&quot;);
 475                             equal(run(pb).exitValue(),
 476                                   False.exitValue());
 477                             prog.delete();
 478                             // Interpreter scripts with #!
 479                             setFileContents(prog, &quot;#!/bin/true\n&quot;);
 480                             prog.setExecutable(true);
 481                             equal(run(pb).exitValue(),
 482                                   True.exitValue());
 483                             prog.delete();
 484                             setFileContents(prog, &quot;#!/bin/false\n&quot;);
 485                             prog.setExecutable(true);
 486                             equal(run(pb).exitValue(),
 487                                   False.exitValue());
 488                             // Traditional shell scripts without #!
 489                             setFileContents(prog, &quot;exec /bin/true\n&quot;);
 490                             prog.setExecutable(true);
 491                             equal(run(pb).exitValue(),
 492                                   True.exitValue());
 493                             prog.delete();
 494                             setFileContents(prog, &quot;exec /bin/false\n&quot;);
 495                             prog.setExecutable(true);
 496                             equal(run(pb).exitValue(),
 497                                   False.exitValue());
 498                             prog.delete();
 499                         }
 500 
 501                         // Test Unix interpreter scripts
 502                         File dir1Prog = new File(&quot;dir1/prog&quot;);
 503                         dir1Prog.delete();
 504                         pb.command(new String[] {&quot;prog&quot;, &quot;world&quot;});
 505                         setFileContents(dir1Prog, &quot;#!/bin/echo hello\n&quot;);
 506                         checkPermissionDenied(pb);
 507                         dir1Prog.setExecutable(true);
 508                         equal(run(pb).out(), &quot;hello dir1/prog world\n&quot;);
 509                         equal(run(pb).exitValue(), True.exitValue());
 510                         dir1Prog.delete();
 511                         pb.command(cmd);
 512 
 513                         // Test traditional shell scripts without #!
 514                         setFileContents(dir1Prog, &quot;/bin/echo \&quot;$@\&quot;\n&quot;);
 515                         pb.command(new String[] {&quot;prog&quot;, &quot;hello&quot;, &quot;world&quot;});
 516                         checkPermissionDenied(pb);
 517                         dir1Prog.setExecutable(true);
 518                         equal(run(pb).out(), &quot;hello world\n&quot;);
 519                         equal(run(pb).exitValue(), True.exitValue());
 520                         dir1Prog.delete();
 521                         pb.command(cmd);
 522 
 523                         // If prog found on both parent and child&#39;s PATH,
 524                         // parent&#39;s is used.
 525                         new File(&quot;dir1/prog&quot;).delete();
 526                         new File(&quot;dir2/prog&quot;).delete();
 527                         new File(&quot;prog&quot;).delete();
 528                         new File(&quot;dir3&quot;).mkdirs();
 529                         copy(TrueExe.path(), &quot;dir1/prog&quot;);
 530                         copy(FalseExe.path(), &quot;dir3/prog&quot;);
 531                         pb.environment().put(&quot;PATH&quot;,&quot;dir3&quot;);
 532                         equal(run(pb).exitValue(), True.exitValue());
 533                         copy(TrueExe.path(), &quot;dir3/prog&quot;);
 534                         copy(FalseExe.path(), &quot;dir1/prog&quot;);
 535                         equal(run(pb).exitValue(), False.exitValue());
 536 
 537                     } finally {
 538                         // cleanup
 539                         new File(&quot;dir1/prog&quot;).delete();
 540                         new File(&quot;dir2/prog&quot;).delete();
 541                         new File(&quot;dir3/prog&quot;).delete();
 542                         new File(&quot;dir1&quot;).delete();
 543                         new File(&quot;dir2&quot;).delete();
 544                         new File(&quot;dir3&quot;).delete();
 545                         new File(&quot;prog&quot;).delete();
 546                     }
 547                 }
 548 
 549                 if (failed != 0) throw new Error(&quot;PATH search algorithm&quot;);
 550             }
 551             else throw new Error(&quot;JavaChild invocation error&quot;);
 552         }
 553     }
 554 
 555     private static void copy(String src, String dst) throws IOException {
 556         Files.copy(Paths.get(src), Paths.get(dst),
 557                    StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);
 558     }
 559 
 560     private static String javaChildOutput(ProcessBuilder pb, String...args) {
 561         List&lt;String&gt; list = new ArrayList&lt;String&gt;(javaChildArgs);
 562         for (String arg : args)
 563             list.add(arg);
 564         pb.command(list);
 565         return commandOutput(pb);
 566     }
 567 
 568     private static String getenvInChild(ProcessBuilder pb) {
 569         return javaChildOutput(pb, &quot;System.getenv()&quot;);
 570     }
 571 
 572     private static String getenvInChild1234(ProcessBuilder pb) {
 573         return javaChildOutput(pb, &quot;System.getenv(\\u1234)&quot;);
 574     }
 575 
 576     private static String getenvInChild(ProcessBuilder pb, String name) {
 577         return javaChildOutput(pb, &quot;System.getenv(String)&quot;, name);
 578     }
 579 
 580     private static String pwdInChild(ProcessBuilder pb) {
 581         return javaChildOutput(pb, &quot;pwd&quot;);
 582     }
 583 
 584     private static final String javaExe =
 585         System.getProperty(&quot;java.home&quot;) +
 586         File.separator + &quot;bin&quot; + File.separator + &quot;java&quot;;
 587 
 588     private static final String classpath =
 589         System.getProperty(&quot;java.class.path&quot;);
 590 
 591     private static final List&lt;String&gt; javaChildArgs =
 592         Arrays.asList(javaExe,
 593                       &quot;-XX:+DisplayVMOutputToStderr&quot;,
 594                       &quot;-classpath&quot;, absolutifyPath(classpath),
 595                       &quot;Basic$JavaChild&quot;);
 596 
 597     private static void testEncoding(String encoding, String tested) {
 598         try {
 599             // If round trip conversion works, should be able to set env vars
 600             // correctly in child.
 601             if (new String(tested.getBytes()).equals(tested)) {
 602                 out.println(&quot;Testing &quot; + encoding + &quot; environment values&quot;);
 603                 ProcessBuilder pb = new ProcessBuilder();
 604                 pb.environment().put(&quot;ASCIINAME&quot;,tested);
 605                 equal(getenvInChild(pb,&quot;ASCIINAME&quot;), tested);
 606             }
 607         } catch (Throwable t) { unexpected(t); }
 608     }
 609 
 610     static class Windows {
 611         public static boolean is() { return is; }
 612         private static final boolean is =
 613             System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;);
 614     }
 615 
 616     static class AIX {
 617         public static boolean is() { return is; }
 618         private static final boolean is =
 619             System.getProperty(&quot;os.name&quot;).equals(&quot;AIX&quot;);
 620     }
 621 
 622     static class Unix {
 623         public static boolean is() { return is; }
 624         private static final boolean is =
 625             (! Windows.is() &amp;&amp;
 626              new File(&quot;/bin/sh&quot;).exists() &amp;&amp;
 627              new File(&quot;/bin/true&quot;).exists() &amp;&amp;
 628              new File(&quot;/bin/false&quot;).exists());
 629     }
 630 
<a name="4" id="anc4"></a>






 631     static class UnicodeOS {
 632         public static boolean is() { return is; }
 633         private static final String osName = System.getProperty(&quot;os.name&quot;);
 634         private static final boolean is =
 635             // MacOS X would probably also qualify
 636             osName.startsWith(&quot;Windows&quot;)   &amp;&amp;
 637             ! osName.startsWith(&quot;Windows 9&quot;) &amp;&amp;
 638             ! osName.equals(&quot;Windows Me&quot;);
 639     }
 640 
 641     static class MacOSX {
 642         public static boolean is() { return is; }
 643         private static final String osName = System.getProperty(&quot;os.name&quot;);
 644         private static final boolean is = osName.contains(&quot;OS X&quot;);
 645     }
 646 
 647     static class True {
 648         public static int exitValue() { return 0; }
 649     }
 650 
 651     private static class False {
 652         public static int exitValue() { return exitValue; }
 653         private static final int exitValue = exitValue0();
 654         private static int exitValue0() {
 655             // /bin/false returns an *unspecified* non-zero number.
 656             try {
 657                 if (! Unix.is())
 658                     return -1;
 659                 else {
 660                     int rc = new ProcessBuilder(&quot;/bin/false&quot;)
 661                         .start().waitFor();
 662                     check(rc != 0);
 663                     return rc;
 664                 }
 665             } catch (Throwable t) { unexpected(t); return -1; }
 666         }
 667     }
 668 
<a name="5" id="anc5"></a><span class="line-modified"> 669     // On Alpine Linux, /bin/true and /bin/false are just links to /bin/busybox.</span>
 670     // Some tests copy /bin/true and /bin/false to files with a different filename.
 671     // However, copying the busbox executable into a file with a different name
 672     // won&#39;t result in the expected return codes. As workaround, we create
<a name="6" id="anc6"></a><span class="line-modified"> 673     // executable files that can be copied and produce the expected return</span>
<span class="line-modified"> 674     // values.</span>
 675 
 676     private static class TrueExe {
 677         public static String path() { return path; }
 678         private static final String path = path0();
 679         private static String path0(){
<a name="7" id="anc7"></a><span class="line-modified"> 680             if (!Platform.isBusybox(&quot;/bin/true&quot;)) {</span>
 681                 return &quot;/bin/true&quot;;
 682             }
 683             else {
 684                 File trueExe = new File(&quot;true&quot;);
 685                 setFileContents(trueExe, &quot;#!/bin/true\n&quot;);
 686                 trueExe.setExecutable(true);
 687                 return trueExe.getAbsolutePath();
 688             }
 689         }
 690     }
 691 
 692     private static class FalseExe {
 693         public static String path() { return path; }
 694         private static final String path = path0();
 695         private static String path0(){
<a name="8" id="anc8"></a><span class="line-modified"> 696             if (!Platform.isBusybox(&quot;/bin/false&quot;)) {</span>
 697                 return &quot;/bin/false&quot;;
 698             }
 699             else {
 700                 File falseExe = new File(&quot;false&quot;);
 701                 setFileContents(falseExe, &quot;#!/bin/false\n&quot;);
 702                 falseExe.setExecutable(true);
 703                 return falseExe.getAbsolutePath();
 704             }
 705         }
 706     }
 707 
 708     static class EnglishUnix {
 709         private static final Boolean is =
 710             (! Windows.is() &amp;&amp; isEnglish(&quot;LANG&quot;) &amp;&amp; isEnglish(&quot;LC_ALL&quot;));
 711 
 712         private static boolean isEnglish(String envvar) {
 713             String val = getenv(envvar);
 714             return (val == null) || val.matches(&quot;en.*&quot;) || val.matches(&quot;C&quot;);
 715         }
 716 
 717         /** Returns true if we can expect English OS error strings */
 718         static boolean is() { return is; }
 719     }
 720 
 721     static class DelegatingProcess extends Process {
 722         final Process p;
 723 
 724         DelegatingProcess(Process p) {
 725             this.p = p;
 726         }
 727 
 728         @Override
 729         public void destroy() {
 730             p.destroy();
 731         }
 732 
 733         @Override
 734         public int exitValue() {
 735             return p.exitValue();
 736         }
 737 
 738         @Override
 739         public int waitFor() throws InterruptedException {
 740             return p.waitFor();
 741         }
 742 
 743         @Override
 744         public OutputStream getOutputStream() {
 745             return p.getOutputStream();
 746         }
 747 
 748         @Override
 749         public InputStream getInputStream() {
 750             return p.getInputStream();
 751         }
 752 
 753         @Override
 754         public InputStream getErrorStream() {
 755             return p.getErrorStream();
 756         }
 757     }
 758 
 759     private static boolean matches(String str, String regex) {
 760         return Pattern.compile(regex).matcher(str).find();
 761     }
 762 
 763     private static String matchAndExtract(String str, String regex) {
 764         Matcher matcher = Pattern.compile(regex).matcher(str);
 765         if (matcher.find()) {
 766             return matcher.group();
 767         } else {
 768             return &quot;&quot;;
 769         }
 770     }
 771 
 772     /* Only used for Mac OS X --
 773      * Mac OS X (may) add the variable __CF_USER_TEXT_ENCODING to an empty
 774      * environment. The environment variable JAVA_MAIN_CLASS_&lt;pid&gt; may also
 775      * be set in Mac OS X.
 776      * Remove them both from the list of env variables
 777      */
 778     private static String removeMacExpectedVars(String vars) {
 779         // Check for __CF_USER_TEXT_ENCODING
 780         String cleanedVars = vars.replace(&quot;__CF_USER_TEXT_ENCODING=&quot;
 781                                             +cfUserTextEncoding+&quot;,&quot;,&quot;&quot;);
 782         // Check for JAVA_MAIN_CLASS_&lt;pid&gt;
 783         String javaMainClassStr
 784                 = matchAndExtract(cleanedVars,
 785                                     &quot;JAVA_MAIN_CLASS_\\d+=Basic.JavaChild,&quot;);
 786         return cleanedVars.replace(javaMainClassStr,&quot;&quot;);
 787     }
 788 
 789     /* Only used for AIX --
 790      * AIX adds the variable AIXTHREAD_GUARDPAGES=0 to the environment.
 791      * Remove it from the list of env variables
 792      */
 793     private static String removeAixExpectedVars(String vars) {
 794         return vars.replace(&quot;AIXTHREAD_GUARDPAGES=0,&quot;, &quot;&quot;);
 795     }
 796 
 797     private static String sortByLinesWindowsly(String text) {
 798         String[] lines = text.split(&quot;\n&quot;);
 799         Arrays.sort(lines, new WindowsComparator());
 800         StringBuilder sb = new StringBuilder();
 801         for (String line : lines)
 802             sb.append(line).append(&quot;\n&quot;);
 803         return sb.toString();
 804     }
 805 
 806     private static void checkMapSanity(Map&lt;String,String&gt; map) {
 807         try {
 808             Set&lt;String&gt; keySet = map.keySet();
 809             Collection&lt;String&gt; values = map.values();
 810             Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();
 811 
 812             equal(entrySet.size(), keySet.size());
 813             equal(entrySet.size(), values.size());
 814 
 815             StringBuilder s1 = new StringBuilder();
 816             for (Map.Entry&lt;String,String&gt; e : entrySet)
 817                 s1.append(e.getKey() + &quot;=&quot; + e.getValue() + &quot;\n&quot;);
 818 
 819             StringBuilder s2 = new StringBuilder();
 820             for (String var : keySet)
 821                 s2.append(var + &quot;=&quot; + map.get(var) + &quot;\n&quot;);
 822 
 823             equal(s1.toString(), s2.toString());
 824 
 825             Iterator&lt;String&gt; kIter = keySet.iterator();
 826             Iterator&lt;String&gt; vIter = values.iterator();
 827             Iterator&lt;Map.Entry&lt;String,String&gt;&gt; eIter = entrySet.iterator();
 828 
 829             while (eIter.hasNext()) {
 830                 Map.Entry&lt;String,String&gt; entry = eIter.next();
 831                 String key   = kIter.next();
 832                 String value = vIter.next();
 833                 check(entrySet.contains(entry));
 834                 check(keySet.contains(key));
 835                 check(values.contains(value));
 836                 check(map.containsKey(key));
 837                 check(map.containsValue(value));
 838                 equal(entry.getKey(), key);
 839                 equal(entry.getValue(), value);
 840             }
 841             check(!kIter.hasNext() &amp;&amp;
 842                     !vIter.hasNext());
 843 
 844         } catch (Throwable t) { unexpected(t); }
 845     }
 846 
 847     private static void checkMapEquality(Map&lt;String,String&gt; map1,
 848                                          Map&lt;String,String&gt; map2) {
 849         try {
 850             equal(map1.size(), map2.size());
 851             equal(map1.isEmpty(), map2.isEmpty());
 852             for (String key : map1.keySet()) {
 853                 equal(map1.get(key), map2.get(key));
 854                 check(map2.keySet().contains(key));
 855             }
 856             equal(map1, map2);
 857             equal(map2, map1);
 858             equal(map1.entrySet(), map2.entrySet());
 859             equal(map2.entrySet(), map1.entrySet());
 860             equal(map1.keySet(), map2.keySet());
 861             equal(map2.keySet(), map1.keySet());
 862 
 863             equal(map1.hashCode(), map2.hashCode());
 864             equal(map1.entrySet().hashCode(), map2.entrySet().hashCode());
 865             equal(map1.keySet().hashCode(), map2.keySet().hashCode());
 866         } catch (Throwable t) { unexpected(t); }
 867     }
 868 
 869     static void checkRedirects(ProcessBuilder pb,
 870                                Redirect in, Redirect out, Redirect err) {
 871         equal(pb.redirectInput(), in);
 872         equal(pb.redirectOutput(), out);
 873         equal(pb.redirectError(), err);
 874     }
 875 
 876     static void redirectIO(ProcessBuilder pb,
 877                            Redirect in, Redirect out, Redirect err) {
 878         pb.redirectInput(in);
 879         pb.redirectOutput(out);
 880         pb.redirectError(err);
 881     }
 882 
 883     static void setFileContents(File file, String contents) {
 884         try {
 885             Writer w = new FileWriter(file);
 886             w.write(contents);
 887             w.close();
 888         } catch (Throwable t) { unexpected(t); }
 889     }
 890 
 891     static String fileContents(File file) {
 892         try {
 893             Reader r = new FileReader(file);
 894             StringBuilder sb = new StringBuilder();
 895             char[] buffer = new char[1024];
 896             int n;
 897             while ((n = r.read(buffer)) != -1)
 898                 sb.append(buffer,0,n);
 899             r.close();
 900             return new String(sb);
 901         } catch (Throwable t) { unexpected(t); return &quot;&quot;; }
 902     }
 903 
 904     static void testIORedirection() throws Throwable {
 905         final File ifile = new File(&quot;ifile&quot;);
 906         final File ofile = new File(&quot;ofile&quot;);
 907         final File efile = new File(&quot;efile&quot;);
 908         ifile.delete();
 909         ofile.delete();
 910         efile.delete();
 911 
 912         //----------------------------------------------------------------
 913         // Check mutual inequality of different types of Redirect
 914         //----------------------------------------------------------------
 915         Redirect[] redirects =
 916             { PIPE,
 917               INHERIT,
 918               DISCARD,
 919               Redirect.from(ifile),
 920               Redirect.to(ifile),
 921               Redirect.appendTo(ifile),
 922               Redirect.from(ofile),
 923               Redirect.to(ofile),
 924               Redirect.appendTo(ofile),
 925             };
 926         for (int i = 0; i &lt; redirects.length; i++)
 927             for (int j = 0; j &lt; redirects.length; j++)
 928                 equal(redirects[i].equals(redirects[j]), (i == j));
 929 
 930         //----------------------------------------------------------------
 931         // Check basic properties of different types of Redirect
 932         //----------------------------------------------------------------
 933         equal(PIPE.type(), Redirect.Type.PIPE);
 934         equal(PIPE.toString(), &quot;PIPE&quot;);
 935         equal(PIPE.file(), null);
 936 
 937         equal(INHERIT.type(), Redirect.Type.INHERIT);
 938         equal(INHERIT.toString(), &quot;INHERIT&quot;);
 939         equal(INHERIT.file(), null);
 940 
 941         equal(DISCARD.type(), Redirect.Type.WRITE);
 942         equal(DISCARD.toString(), &quot;WRITE&quot;);
 943         equal(DISCARD.file(), new File((Windows.is() ? &quot;NUL&quot; : &quot;/dev/null&quot;)));
 944 
 945         equal(Redirect.from(ifile).type(), Redirect.Type.READ);
 946         equal(Redirect.from(ifile).toString(),
 947               &quot;redirect to read from file \&quot;ifile\&quot;&quot;);
 948         equal(Redirect.from(ifile).file(), ifile);
 949         equal(Redirect.from(ifile),
 950               Redirect.from(ifile));
 951         equal(Redirect.from(ifile).hashCode(),
 952               Redirect.from(ifile).hashCode());
 953 
 954         equal(Redirect.to(ofile).type(), Redirect.Type.WRITE);
 955         equal(Redirect.to(ofile).toString(),
 956               &quot;redirect to write to file \&quot;ofile\&quot;&quot;);
 957         equal(Redirect.to(ofile).file(), ofile);
 958         equal(Redirect.to(ofile),
 959               Redirect.to(ofile));
 960         equal(Redirect.to(ofile).hashCode(),
 961               Redirect.to(ofile).hashCode());
 962 
 963         equal(Redirect.appendTo(ofile).type(), Redirect.Type.APPEND);
 964         equal(Redirect.appendTo(efile).toString(),
 965               &quot;redirect to append to file \&quot;efile\&quot;&quot;);
 966         equal(Redirect.appendTo(efile).file(), efile);
 967         equal(Redirect.appendTo(efile),
 968               Redirect.appendTo(efile));
 969         equal(Redirect.appendTo(efile).hashCode(),
 970               Redirect.appendTo(efile).hashCode());
 971 
 972         //----------------------------------------------------------------
 973         // Check initial values of redirects
 974         //----------------------------------------------------------------
 975         List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
 976         childArgs.add(&quot;testIO&quot;);
 977         final ProcessBuilder pb = new ProcessBuilder(childArgs);
 978         checkRedirects(pb, PIPE, PIPE, PIPE);
 979 
 980         //----------------------------------------------------------------
 981         // Check inheritIO
 982         //----------------------------------------------------------------
 983         pb.inheritIO();
 984         checkRedirects(pb, INHERIT, INHERIT, INHERIT);
 985 
 986         //----------------------------------------------------------------
 987         // Check DISCARD for stdout,stderr
 988         //----------------------------------------------------------------
 989         redirectIO(pb, INHERIT, DISCARD, DISCARD);
 990         checkRedirects(pb, INHERIT, DISCARD, DISCARD);
 991 
 992         //----------------------------------------------------------------
 993         // Check setters and getters agree
 994         //----------------------------------------------------------------
 995         pb.redirectInput(ifile);
 996         equal(pb.redirectInput().file(), ifile);
 997         equal(pb.redirectInput(), Redirect.from(ifile));
 998 
 999         pb.redirectOutput(ofile);
1000         equal(pb.redirectOutput().file(), ofile);
1001         equal(pb.redirectOutput(), Redirect.to(ofile));
1002 
1003         pb.redirectError(efile);
1004         equal(pb.redirectError().file(), efile);
1005         equal(pb.redirectError(), Redirect.to(efile));
1006 
1007         THROWS(IllegalArgumentException.class,
1008                () -&gt; pb.redirectInput(Redirect.to(ofile)),
1009                () -&gt; pb.redirectOutput(Redirect.from(ifile)),
1010                () -&gt; pb.redirectError(Redirect.from(ifile)),
1011                () -&gt; pb.redirectInput(DISCARD));
1012 
1013         THROWS(NullPointerException.class,
1014                 () -&gt; pb.redirectInput((File)null),
1015                 () -&gt; pb.redirectOutput((File)null),
1016                 () -&gt; pb.redirectError((File)null),
1017                 () -&gt; pb.redirectInput((Redirect)null),
1018                 () -&gt; pb.redirectOutput((Redirect)null),
1019                 () -&gt; pb.redirectError((Redirect)null));
1020 
1021         THROWS(IOException.class,
1022                // Input file does not exist
1023                () -&gt; pb.start());
1024         setFileContents(ifile, &quot;standard input&quot;);
1025 
1026         //----------------------------------------------------------------
1027         // Writing to non-existent files
1028         //----------------------------------------------------------------
1029         {
1030             ProcessResults r = run(pb);
1031             equal(r.exitValue(), 0);
1032             equal(fileContents(ofile), &quot;standard output&quot;);
1033             equal(fileContents(efile), &quot;standard error&quot;);
1034             equal(r.out(), &quot;&quot;);
1035             equal(r.err(), &quot;&quot;);
1036             ofile.delete();
1037             efile.delete();
1038         }
1039 
1040         //----------------------------------------------------------------
1041         // Both redirectErrorStream + redirectError
1042         //----------------------------------------------------------------
1043         {
1044             pb.redirectErrorStream(true);
1045             ProcessResults r = run(pb);
1046             equal(r.exitValue(), 0);
1047             equal(fileContents(ofile),
1048                     &quot;standard error&quot; + &quot;standard output&quot;);
1049             equal(fileContents(efile), &quot;&quot;);
1050             equal(r.out(), &quot;&quot;);
1051             equal(r.err(), &quot;&quot;);
1052             ofile.delete();
1053             efile.delete();
1054         }
1055 
1056         //----------------------------------------------------------------
1057         // Appending to existing files
1058         //----------------------------------------------------------------
1059         {
1060             setFileContents(ofile, &quot;ofile-contents&quot;);
1061             setFileContents(efile, &quot;efile-contents&quot;);
1062             pb.redirectOutput(Redirect.appendTo(ofile));
1063             pb.redirectError(Redirect.appendTo(efile));
1064             pb.redirectErrorStream(false);
1065             ProcessResults r = run(pb);
1066             equal(r.exitValue(), 0);
1067             equal(fileContents(ofile),
1068                   &quot;ofile-contents&quot; + &quot;standard output&quot;);
1069             equal(fileContents(efile),
1070                   &quot;efile-contents&quot; + &quot;standard error&quot;);
1071             equal(r.out(), &quot;&quot;);
1072             equal(r.err(), &quot;&quot;);
1073             ofile.delete();
1074             efile.delete();
1075         }
1076 
1077         //----------------------------------------------------------------
1078         // Replacing existing files
1079         //----------------------------------------------------------------
1080         {
1081             setFileContents(ofile, &quot;ofile-contents&quot;);
1082             setFileContents(efile, &quot;efile-contents&quot;);
1083             pb.redirectOutput(ofile);
1084             pb.redirectError(Redirect.to(efile));
1085             ProcessResults r = run(pb);
1086             equal(r.exitValue(), 0);
1087             equal(fileContents(ofile), &quot;standard output&quot;);
1088             equal(fileContents(efile), &quot;standard error&quot;);
1089             equal(r.out(), &quot;&quot;);
1090             equal(r.err(), &quot;&quot;);
1091             ofile.delete();
1092             efile.delete();
1093         }
1094 
1095         //----------------------------------------------------------------
1096         // Appending twice to the same file?
1097         //----------------------------------------------------------------
1098         {
1099             setFileContents(ofile, &quot;ofile-contents&quot;);
1100             setFileContents(efile, &quot;efile-contents&quot;);
1101             Redirect appender = Redirect.appendTo(ofile);
1102             pb.redirectOutput(appender);
1103             pb.redirectError(appender);
1104             ProcessResults r = run(pb);
1105             equal(r.exitValue(), 0);
1106             equal(fileContents(ofile),
1107                   &quot;ofile-contents&quot; +
1108                   &quot;standard error&quot; +
1109                   &quot;standard output&quot;);
1110             equal(fileContents(efile), &quot;efile-contents&quot;);
1111             equal(r.out(), &quot;&quot;);
1112             equal(r.err(), &quot;&quot;);
1113             ifile.delete();
1114             ofile.delete();
1115             efile.delete();
1116         }
1117 
1118         //----------------------------------------------------------------
1119         // DISCARDing output
1120         //----------------------------------------------------------------
1121         {
1122             setFileContents(ifile, &quot;standard input&quot;);
1123             pb.redirectOutput(DISCARD);
1124             pb.redirectError(DISCARD);
1125             ProcessResults r = run(pb);
1126             equal(r.exitValue(), 0);
1127             equal(r.out(), &quot;&quot;);
1128             equal(r.err(), &quot;&quot;);
1129         }
1130 
1131         //----------------------------------------------------------------
1132         // DISCARDing output and redirecting error
1133         //----------------------------------------------------------------
1134         {
1135             setFileContents(ifile, &quot;standard input&quot;);
1136             setFileContents(ofile, &quot;ofile-contents&quot;);
1137             setFileContents(efile, &quot;efile-contents&quot;);
1138             pb.redirectOutput(DISCARD);
1139             pb.redirectError(efile);
1140             ProcessResults r = run(pb);
1141             equal(r.exitValue(), 0);
1142             equal(fileContents(ofile), &quot;ofile-contents&quot;);
1143             equal(fileContents(efile), &quot;standard error&quot;);
1144             equal(r.out(), &quot;&quot;);
1145             equal(r.err(), &quot;&quot;);
1146             ofile.delete();
1147             efile.delete();
1148         }
1149 
1150         //----------------------------------------------------------------
1151         // DISCARDing error and redirecting output
1152         //----------------------------------------------------------------
1153         {
1154             setFileContents(ifile, &quot;standard input&quot;);
1155             setFileContents(ofile, &quot;ofile-contents&quot;);
1156             setFileContents(efile, &quot;efile-contents&quot;);
1157             pb.redirectOutput(ofile);
1158             pb.redirectError(DISCARD);
1159             ProcessResults r = run(pb);
1160             equal(r.exitValue(), 0);
1161             equal(fileContents(ofile), &quot;standard output&quot;);
1162             equal(fileContents(efile), &quot;efile-contents&quot;);
1163             equal(r.out(), &quot;&quot;);
1164             equal(r.err(), &quot;&quot;);
1165             ofile.delete();
1166             efile.delete();
1167         }
1168 
1169         //----------------------------------------------------------------
1170         // DISCARDing output and merging error into output
1171         //----------------------------------------------------------------
1172         {
1173             setFileContents(ifile, &quot;standard input&quot;);
1174             setFileContents(ofile, &quot;ofile-contents&quot;);
1175             setFileContents(efile, &quot;efile-contents&quot;);
1176             pb.redirectOutput(DISCARD);
1177             pb.redirectErrorStream(true);
1178             pb.redirectError(efile);
1179             ProcessResults r = run(pb);
1180             equal(r.exitValue(), 0);
1181             equal(fileContents(ofile), &quot;ofile-contents&quot;);   // untouched
1182             equal(fileContents(efile), &quot;&quot;);                 // empty
1183             equal(r.out(), &quot;&quot;);
1184             equal(r.err(), &quot;&quot;);
1185             ifile.delete();
1186             ofile.delete();
1187             efile.delete();
1188             pb.redirectErrorStream(false);                  // reset for next test
1189         }
1190 
1191         //----------------------------------------------------------------
1192         // Testing INHERIT is harder.
1193         // Note that this requires __FOUR__ nested JVMs involved in one test,
1194         // if you count the harness JVM.
1195         //----------------------------------------------------------------
1196         for (String testName : new String[] { &quot;testInheritIO&quot;, &quot;testRedirectInherit&quot; } ) {
1197             redirectIO(pb, PIPE, PIPE, PIPE);
1198             List&lt;String&gt; command = pb.command();
1199             command.set(command.size() - 1, testName);
1200             Process p = pb.start();
1201             new PrintStream(p.getOutputStream()).print(&quot;standard input&quot;);
1202             p.getOutputStream().close();
1203             ProcessResults r = run(p);
1204             equal(r.exitValue(), 0);
1205             equal(r.out(), &quot;standard output&quot;);
1206             equal(r.err(), &quot;standard error&quot;);
1207         }
1208 
1209         //----------------------------------------------------------------
1210         // Test security implications of I/O redirection
1211         //----------------------------------------------------------------
1212 
1213         // Read access to current directory is always granted;
1214         // So create a tmpfile for input instead.
1215         final File tmpFile = File.createTempFile(&quot;Basic&quot;, &quot;tmp&quot;);
1216         setFileContents(tmpFile, &quot;standard input&quot;);
1217 
1218         final Policy policy = new Policy();
1219         Policy.setPolicy(policy);
1220         System.setSecurityManager(new SecurityManager());
1221         try {
1222             final Permission xPermission
1223                 = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;execute&quot;);
1224             final Permission rxPermission
1225                 = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read,execute&quot;);
1226             final Permission wxPermission
1227                 = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;write,execute&quot;);
1228             final Permission rwxPermission
1229                 = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read,write,execute&quot;);
1230 
1231             THROWS(SecurityException.class,
1232                    () -&gt; { policy.setPermissions(xPermission);
1233                            redirectIO(pb, from(tmpFile), PIPE, PIPE);
1234                            pb.start();},
1235                    () -&gt; { policy.setPermissions(rxPermission);
1236                            redirectIO(pb, PIPE, to(ofile), PIPE);
1237                            pb.start();},
1238                    () -&gt; { policy.setPermissions(rxPermission);
1239                            redirectIO(pb, PIPE, PIPE, to(efile));
1240                            pb.start();});
1241 
1242             {
1243                 policy.setPermissions(rxPermission);
1244                 redirectIO(pb, from(tmpFile), PIPE, PIPE);
1245                 ProcessResults r = run(pb);
1246                 equal(r.out(), &quot;standard output&quot;);
1247                 equal(r.err(), &quot;standard error&quot;);
1248             }
1249 
1250             {
1251                 policy.setPermissions(wxPermission);
1252                 redirectIO(pb, PIPE, to(ofile), to(efile));
1253                 Process p = pb.start();
1254                 new PrintStream(p.getOutputStream()).print(&quot;standard input&quot;);
1255                 p.getOutputStream().close();
1256                 ProcessResults r = run(p);
1257                 policy.setPermissions(rwxPermission);
1258                 equal(fileContents(ofile), &quot;standard output&quot;);
1259                 equal(fileContents(efile), &quot;standard error&quot;);
1260             }
1261 
1262             {
1263                 policy.setPermissions(rwxPermission);
1264                 redirectIO(pb, from(tmpFile), to(ofile), to(efile));
1265                 ProcessResults r = run(pb);
1266                 policy.setPermissions(rwxPermission);
1267                 equal(fileContents(ofile), &quot;standard output&quot;);
1268                 equal(fileContents(efile), &quot;standard error&quot;);
1269             }
1270 
1271         } finally {
1272             policy.setPermissions(new RuntimePermission(&quot;setSecurityManager&quot;));
1273             System.setSecurityManager(null);
1274             tmpFile.delete();
1275             ifile.delete();
1276             ofile.delete();
1277             efile.delete();
1278         }
1279     }
1280 
1281     static void checkProcessPid() {
1282         ProcessBuilder pb = new ProcessBuilder();
1283         List&lt;String&gt; list = new ArrayList&lt;String&gt;(javaChildArgs);
1284         list.add(&quot;pid&quot;);
1285         pb.command(list);
1286         try {
1287             Process p = pb.start();
1288             String s = commandOutput(p);
1289             long actualPid = Long.valueOf(s.trim());
1290             long expectedPid = p.pid();
1291             equal(actualPid, expectedPid);
1292         } catch (Throwable t) {
1293             unexpected(t);
1294         }
1295 
1296 
1297         // Test the default implementation of Process.getPid
1298         DelegatingProcess p = new DelegatingProcess(null);
1299         THROWS(UnsupportedOperationException.class,
1300                 () -&gt; p.pid(),
1301                 () -&gt; p.toHandle(),
1302                 () -&gt; p.supportsNormalTermination(),
1303                 () -&gt; p.children(),
1304                 () -&gt; p.descendants());
1305 
1306     }
1307 
1308     private static void realMain(String[] args) throws Throwable {
1309         if (Windows.is())
1310             System.out.println(&quot;This appears to be a Windows system.&quot;);
1311         if (Unix.is())
1312             System.out.println(&quot;This appears to be a Unix system.&quot;);
1313         if (UnicodeOS.is())
1314             System.out.println(&quot;This appears to be a Unicode-based OS.&quot;);
1315 
1316         try { testIORedirection(); }
1317         catch (Throwable t) { unexpected(t); }
1318 
1319         //----------------------------------------------------------------
1320         // Basic tests for getPid()
1321         //----------------------------------------------------------------
1322         checkProcessPid();
1323 
1324         //----------------------------------------------------------------
1325         // Basic tests for setting, replacing and deleting envvars
1326         //----------------------------------------------------------------
1327         try {
1328             ProcessBuilder pb = new ProcessBuilder();
1329             Map&lt;String,String&gt; environ = pb.environment();
1330 
1331             // New env var
1332             environ.put(&quot;QUUX&quot;, &quot;BAR&quot;);
1333             equal(environ.get(&quot;QUUX&quot;), &quot;BAR&quot;);
1334             equal(getenvInChild(pb,&quot;QUUX&quot;), &quot;BAR&quot;);
1335 
1336             // Modify env var
1337             environ.put(&quot;QUUX&quot;,&quot;bear&quot;);
1338             equal(environ.get(&quot;QUUX&quot;), &quot;bear&quot;);
1339             equal(getenvInChild(pb,&quot;QUUX&quot;), &quot;bear&quot;);
1340             checkMapSanity(environ);
1341 
1342             // Remove env var
1343             environ.remove(&quot;QUUX&quot;);
1344             equal(environ.get(&quot;QUUX&quot;), null);
1345             equal(getenvInChild(pb,&quot;QUUX&quot;), &quot;null&quot;);
1346             checkMapSanity(environ);
1347 
1348             // Remove non-existent env var
1349             environ.remove(&quot;QUUX&quot;);
1350             equal(environ.get(&quot;QUUX&quot;), null);
1351             equal(getenvInChild(pb,&quot;QUUX&quot;), &quot;null&quot;);
1352             checkMapSanity(environ);
1353         } catch (Throwable t) { unexpected(t); }
1354 
1355         //----------------------------------------------------------------
1356         // Pass Empty environment to child
1357         //----------------------------------------------------------------
1358         try {
1359             ProcessBuilder pb = new ProcessBuilder();
1360             pb.environment().clear();
1361             String expected = Windows.is() ? &quot;SystemRoot=&quot;+systemRoot+&quot;,&quot;: &quot;&quot;;
1362             expected = AIX.is() ? &quot;LIBPATH=&quot;+libpath+&quot;,&quot;: expected;
1363             if (Windows.is()) {
1364                 pb.environment().put(&quot;SystemRoot&quot;, systemRoot);
1365             }
1366             if (AIX.is()) {
1367                 pb.environment().put(&quot;LIBPATH&quot;, libpath);
1368             }
1369             String result = getenvInChild(pb);
1370             if (MacOSX.is()) {
1371                 result = removeMacExpectedVars(result);
1372             }
1373             if (AIX.is()) {
1374                 result = removeAixExpectedVars(result);
1375             }
1376             equal(result, expected);
1377         } catch (Throwable t) { unexpected(t); }
1378 
1379         //----------------------------------------------------------------
1380         // System.getenv() is read-only.
1381         //----------------------------------------------------------------
1382         THROWS(UnsupportedOperationException.class,
1383                () -&gt; getenv().put(&quot;FOO&quot;,&quot;BAR&quot;),
1384                () -&gt; getenv().remove(&quot;PATH&quot;),
1385                () -&gt; getenv().keySet().remove(&quot;PATH&quot;),
1386                () -&gt; getenv().values().remove(&quot;someValue&quot;));
1387 
1388         try {
1389             Collection&lt;Map.Entry&lt;String,String&gt;&gt; c = getenv().entrySet();
1390             if (! c.isEmpty())
1391                 try {
1392                     c.iterator().next().setValue(&quot;foo&quot;);
1393                     fail(&quot;Expected UnsupportedOperationException not thrown&quot;);
1394                 } catch (UnsupportedOperationException e) {} // OK
1395         } catch (Throwable t) { unexpected(t); }
1396 
1397         //----------------------------------------------------------------
1398         // System.getenv() always returns the same object in our implementation.
1399         //----------------------------------------------------------------
1400         try {
1401             check(System.getenv() == System.getenv());
1402         } catch (Throwable t) { unexpected(t); }
1403 
1404         //----------------------------------------------------------------
1405         // You can&#39;t create an env var name containing &quot;=&quot;,
1406         // or an env var name or value containing NUL.
1407         //----------------------------------------------------------------
1408         {
1409             final Map&lt;String,String&gt; m = new ProcessBuilder().environment();
1410             THROWS(IllegalArgumentException.class,
1411                    () -&gt; m.put(&quot;FOO=&quot;,&quot;BAR&quot;),
1412                    () -&gt; m.put(&quot;FOO\u0000&quot;,&quot;BAR&quot;),
1413                    () -&gt; m.put(&quot;FOO&quot;,&quot;BAR\u0000&quot;));
1414         }
1415 
1416         //----------------------------------------------------------------
1417         // Commands must never be null.
1418         //----------------------------------------------------------------
1419         THROWS(NullPointerException.class,
1420                () -&gt; new ProcessBuilder((List&lt;String&gt;)null),
1421                () -&gt; new ProcessBuilder().command((List&lt;String&gt;)null));
1422 
1423         //----------------------------------------------------------------
1424         // Put in a command; get the same one back out.
1425         //----------------------------------------------------------------
1426         try {
1427             List&lt;String&gt; command = new ArrayList&lt;String&gt;();
1428             ProcessBuilder pb = new ProcessBuilder(command);
1429             check(pb.command() == command);
1430             List&lt;String&gt; command2 = new ArrayList&lt;String&gt;(2);
1431             command2.add(&quot;foo&quot;);
1432             command2.add(&quot;bar&quot;);
1433             pb.command(command2);
1434             check(pb.command() == command2);
1435             pb.command(&quot;foo&quot;, &quot;bar&quot;);
1436             check(pb.command() != command2 &amp;&amp; pb.command().equals(command2));
1437             pb.command(command2);
1438             command2.add(&quot;baz&quot;);
1439             equal(pb.command().get(2), &quot;baz&quot;);
1440         } catch (Throwable t) { unexpected(t); }
1441 
1442         //----------------------------------------------------------------
1443         // Commands must contain at least one element.
1444         //----------------------------------------------------------------
1445         THROWS(IndexOutOfBoundsException.class,
1446                () -&gt; new ProcessBuilder().start(),
1447                () -&gt; new ProcessBuilder(new ArrayList&lt;String&gt;()).start(),
1448                () -&gt; Runtime.getRuntime().exec(new String[]{}));
1449 
1450         //----------------------------------------------------------------
1451         // Commands must not contain null elements at start() time.
1452         //----------------------------------------------------------------
1453         THROWS(NullPointerException.class,
1454                () -&gt; new ProcessBuilder(&quot;foo&quot;,null,&quot;bar&quot;).start(),
1455                () -&gt; new ProcessBuilder((String)null).start(),
1456                () -&gt; new ProcessBuilder(new String[]{null}).start(),
1457                () -&gt; new ProcessBuilder(new String[]{&quot;foo&quot;,null,&quot;bar&quot;}).start());
1458 
1459         //----------------------------------------------------------------
1460         // Command lists are growable.
1461         //----------------------------------------------------------------
1462         try {
1463             new ProcessBuilder().command().add(&quot;foo&quot;);
1464             new ProcessBuilder(&quot;bar&quot;).command().add(&quot;foo&quot;);
1465             new ProcessBuilder(new String[]{&quot;1&quot;,&quot;2&quot;}).command().add(&quot;3&quot;);
1466         } catch (Throwable t) { unexpected(t); }
1467 
1468         //----------------------------------------------------------------
1469         // Nulls in environment updates generate NullPointerException
1470         //----------------------------------------------------------------
1471         try {
1472             final Map&lt;String,String&gt; env = new ProcessBuilder().environment();
1473             THROWS(NullPointerException.class,
1474                    () -&gt; env.put(&quot;foo&quot;,null),
1475                    () -&gt; env.put(null,&quot;foo&quot;),
1476                    () -&gt; env.remove(null),
1477                    () -&gt; { for (Map.Entry&lt;String,String&gt; e : env.entrySet())
1478                                e.setValue(null);},
1479                    () -&gt; Runtime.getRuntime().exec(new String[]{&quot;foo&quot;},
1480                                                    new String[]{null}));
1481         } catch (Throwable t) { unexpected(t); }
1482 
1483         //----------------------------------------------------------------
1484         // Non-String types in environment updates generate ClassCastException
1485         //----------------------------------------------------------------
1486         try {
1487             final Map&lt;String,String&gt; env = new ProcessBuilder().environment();
1488             THROWS(ClassCastException.class,
1489                    () -&gt; env.remove(TRUE),
1490                    () -&gt; env.keySet().remove(TRUE),
1491                    () -&gt; env.values().remove(TRUE),
1492                    () -&gt; env.entrySet().remove(TRUE));
1493         } catch (Throwable t) { unexpected(t); }
1494 
1495         //----------------------------------------------------------------
1496         // Check query operations on environment maps
1497         //----------------------------------------------------------------
1498         try {
1499             List&lt;Map&lt;String,String&gt;&gt; envs =
1500                 new ArrayList&lt;Map&lt;String,String&gt;&gt;(2);
1501             envs.add(System.getenv());
1502             envs.add(new ProcessBuilder().environment());
1503             for (final Map&lt;String,String&gt; env : envs) {
1504                 //----------------------------------------------------------------
1505                 // Nulls in environment queries are forbidden.
1506                 //----------------------------------------------------------------
1507                 THROWS(NullPointerException.class,
1508                        () -&gt; getenv(null),
1509                        () -&gt; env.get(null),
1510                        () -&gt; env.containsKey(null),
1511                        () -&gt; env.containsValue(null),
1512                        () -&gt; env.keySet().contains(null),
1513                        () -&gt; env.values().contains(null));
1514 
1515                 //----------------------------------------------------------------
1516                 // Non-String types in environment queries are forbidden.
1517                 //----------------------------------------------------------------
1518                 THROWS(ClassCastException.class,
1519                        () -&gt; env.get(TRUE),
1520                        () -&gt; env.containsKey(TRUE),
1521                        () -&gt; env.containsValue(TRUE),
1522                        () -&gt; env.keySet().contains(TRUE),
1523                        () -&gt; env.values().contains(TRUE));
1524 
1525                 //----------------------------------------------------------------
1526                 // Illegal String values in environment queries are (grumble) OK
1527                 //----------------------------------------------------------------
1528                 equal(env.get(&quot;\u0000&quot;), null);
1529                 check(! env.containsKey(&quot;\u0000&quot;));
1530                 check(! env.containsValue(&quot;\u0000&quot;));
1531                 check(! env.keySet().contains(&quot;\u0000&quot;));
1532                 check(! env.values().contains(&quot;\u0000&quot;));
1533             }
1534 
1535         } catch (Throwable t) { unexpected(t); }
1536 
1537         try {
1538             final Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet =
1539                 new ProcessBuilder().environment().entrySet();
1540             THROWS(NullPointerException.class,
1541                    () -&gt; entrySet.contains(null));
1542             THROWS(ClassCastException.class,
1543                    () -&gt; entrySet.contains(TRUE),
1544                    () -&gt; entrySet.contains(
1545                              new SimpleImmutableEntry&lt;Boolean,String&gt;(TRUE,&quot;&quot;)));
1546 
1547             check(! entrySet.contains
1548                   (new SimpleImmutableEntry&lt;String,String&gt;(&quot;&quot;, &quot;&quot;)));
1549         } catch (Throwable t) { unexpected(t); }
1550 
1551         //----------------------------------------------------------------
1552         // Put in a directory; get the same one back out.
1553         //----------------------------------------------------------------
1554         try {
1555             ProcessBuilder pb = new ProcessBuilder();
1556             File foo = new File(&quot;foo&quot;);
1557             equal(pb.directory(), null);
1558             equal(pb.directory(foo).directory(), foo);
1559             equal(pb.directory(null).directory(), null);
1560         } catch (Throwable t) { unexpected(t); }
1561 
1562         //----------------------------------------------------------------
1563         // If round-trip conversion works, check envvar pass-through to child
1564         //----------------------------------------------------------------
1565         try {
1566             testEncoding(&quot;ASCII&quot;,   &quot;xyzzy&quot;);
1567             testEncoding(&quot;Latin1&quot;,  &quot;\u00f1\u00e1&quot;);
1568             testEncoding(&quot;Unicode&quot;, &quot;\u22f1\u11e1&quot;);
1569         } catch (Throwable t) { unexpected(t); }
1570 
1571         //----------------------------------------------------------------
1572         // A surprisingly large number of ways to delete an environment var.
1573         //----------------------------------------------------------------
1574         testVariableDeleter(new EnvironmentFrobber() {
1575                 public void doIt(Map&lt;String,String&gt; environ) {
1576                     environ.remove(&quot;Foo&quot;);}});
1577 
1578         testVariableDeleter(new EnvironmentFrobber() {
1579                 public void doIt(Map&lt;String,String&gt; environ) {
1580                     environ.keySet().remove(&quot;Foo&quot;);}});
1581 
1582         testVariableDeleter(new EnvironmentFrobber() {
1583                 public void doIt(Map&lt;String,String&gt; environ) {
1584                     environ.values().remove(&quot;BAAR&quot;);}});
1585 
1586         testVariableDeleter(new EnvironmentFrobber() {
1587                 public void doIt(Map&lt;String,String&gt; environ) {
1588                     // Legally fabricate a ProcessEnvironment.StringEntry,
1589                     // even though it&#39;s private.
1590                     Map&lt;String,String&gt; environ2
1591                         = new ProcessBuilder().environment();
1592                     environ2.clear();
1593                     environ2.put(&quot;Foo&quot;,&quot;BAAR&quot;);
1594                     // Subtlety alert.
1595                     Map.Entry&lt;String,String&gt; e
1596                         = environ2.entrySet().iterator().next();
1597                     environ.entrySet().remove(e);}});
1598 
1599         testVariableDeleter(new EnvironmentFrobber() {
1600                 public void doIt(Map&lt;String,String&gt; environ) {
1601                     Map.Entry&lt;String,String&gt; victim = null;
1602                     for (Map.Entry&lt;String,String&gt; e : environ.entrySet())
1603                         if (e.getKey().equals(&quot;Foo&quot;))
1604                             victim = e;
1605                     if (victim != null)
1606                         environ.entrySet().remove(victim);}});
1607 
1608         testVariableDeleter(new EnvironmentFrobber() {
1609                 public void doIt(Map&lt;String,String&gt; environ) {
1610                     Iterator&lt;String&gt; it = environ.keySet().iterator();
1611                     while (it.hasNext()) {
1612                         String val = it.next();
1613                         if (val.equals(&quot;Foo&quot;))
1614                             it.remove();}}});
1615 
1616         testVariableDeleter(new EnvironmentFrobber() {
1617                 public void doIt(Map&lt;String,String&gt; environ) {
1618                     Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it
1619                         = environ.entrySet().iterator();
1620                     while (it.hasNext()) {
1621                         Map.Entry&lt;String,String&gt; e = it.next();
1622                         if (e.getKey().equals(&quot;Foo&quot;))
1623                             it.remove();}}});
1624 
1625         testVariableDeleter(new EnvironmentFrobber() {
1626                 public void doIt(Map&lt;String,String&gt; environ) {
1627                     Iterator&lt;String&gt; it = environ.values().iterator();
1628                     while (it.hasNext()) {
1629                         String val = it.next();
1630                         if (val.equals(&quot;BAAR&quot;))
1631                             it.remove();}}});
1632 
1633         //----------------------------------------------------------------
1634         // A surprisingly small number of ways to add an environment var.
1635         //----------------------------------------------------------------
1636         testVariableAdder(new EnvironmentFrobber() {
1637                 public void doIt(Map&lt;String,String&gt; environ) {
1638                     environ.put(&quot;Foo&quot;,&quot;Bahrein&quot;);}});
1639 
1640         //----------------------------------------------------------------
1641         // A few ways to modify an environment var.
1642         //----------------------------------------------------------------
1643         testVariableModifier(new EnvironmentFrobber() {
1644                 public void doIt(Map&lt;String,String&gt; environ) {
1645                     environ.put(&quot;Foo&quot;,&quot;NewValue&quot;);}});
1646 
1647         testVariableModifier(new EnvironmentFrobber() {
1648                 public void doIt(Map&lt;String,String&gt; environ) {
1649                     for (Map.Entry&lt;String,String&gt; e : environ.entrySet())
1650                         if (e.getKey().equals(&quot;Foo&quot;))
1651                             e.setValue(&quot;NewValue&quot;);}});
1652 
1653         //----------------------------------------------------------------
1654         // Fiddle with environment sizes
1655         //----------------------------------------------------------------
1656         try {
1657             Map&lt;String,String&gt; environ = new ProcessBuilder().environment();
1658             int size = environ.size();
1659             checkSizes(environ, size);
1660 
1661             environ.put(&quot;UnLiKeLYeNVIROmtNam&quot;, &quot;someVal&quot;);
1662             checkSizes(environ, size+1);
1663 
1664             // Check for environment independence
1665             new ProcessBuilder().environment().clear();
1666 
1667             environ.put(&quot;UnLiKeLYeNVIROmtNam&quot;, &quot;someOtherVal&quot;);
1668             checkSizes(environ, size+1);
1669 
1670             environ.remove(&quot;UnLiKeLYeNVIROmtNam&quot;);
1671             checkSizes(environ, size);
1672 
1673             environ.clear();
1674             checkSizes(environ, 0);
1675 
1676             environ.clear();
1677             checkSizes(environ, 0);
1678 
1679             environ = new ProcessBuilder().environment();
1680             environ.keySet().clear();
1681             checkSizes(environ, 0);
1682 
1683             environ = new ProcessBuilder().environment();
1684             environ.entrySet().clear();
1685             checkSizes(environ, 0);
1686 
1687             environ = new ProcessBuilder().environment();
1688             environ.values().clear();
1689             checkSizes(environ, 0);
1690         } catch (Throwable t) { unexpected(t); }
1691 
1692         //----------------------------------------------------------------
1693         // Check that various map invariants hold
1694         //----------------------------------------------------------------
1695         checkMapSanity(new ProcessBuilder().environment());
1696         checkMapSanity(System.getenv());
1697         checkMapEquality(new ProcessBuilder().environment(),
1698                          new ProcessBuilder().environment());
1699 
1700 
1701         //----------------------------------------------------------------
1702         // Check effects on external &quot;env&quot; command.
1703         //----------------------------------------------------------------
1704         try {
1705             Set&lt;String&gt; env1 = new HashSet&lt;String&gt;
1706                 (Arrays.asList(nativeEnv((String[])null).split(&quot;\n&quot;)));
1707 
1708             ProcessBuilder pb = new ProcessBuilder();
1709             pb.environment().put(&quot;QwErTyUiOp&quot;,&quot;AsDfGhJk&quot;);
1710 
1711             Set&lt;String&gt; env2 = new HashSet&lt;String&gt;
1712                 (Arrays.asList(nativeEnv(pb).split(&quot;\n&quot;)));
1713 
1714             check(env2.size() == env1.size() + 1);
1715             env1.add(&quot;QwErTyUiOp=AsDfGhJk&quot;);
1716             check(env1.equals(env2));
1717         } catch (Throwable t) { unexpected(t); }
1718 
1719         //----------------------------------------------------------------
1720         // Test Runtime.exec(...envp...)
1721         // Check for sort order of environment variables on Windows.
1722         //----------------------------------------------------------------
1723         try {
1724             String systemRoot = &quot;SystemRoot=&quot; + System.getenv(&quot;SystemRoot&quot;);
1725             // &#39;+&#39; &lt; &#39;A&#39; &lt; &#39;Z&#39; &lt; &#39;_&#39; &lt; &#39;a&#39; &lt; &#39;z&#39; &lt; &#39;~&#39;
1726             String[]envp = {&quot;FOO=BAR&quot;,&quot;BAZ=GORP&quot;,&quot;QUUX=&quot;,
1727                             &quot;+=+&quot;, &quot;_=_&quot;, &quot;~=~&quot;, systemRoot};
1728             String output = nativeEnv(envp);
1729             String expected = &quot;+=+\nBAZ=GORP\nFOO=BAR\nQUUX=\n&quot;+systemRoot+&quot;\n_=_\n~=~\n&quot;;
1730             // On Windows, Java must keep the environment sorted.
1731             // Order is random on Unix, so this test does the sort.
1732             if (! Windows.is())
1733                 output = sortByLinesWindowsly(output);
1734             equal(output, expected);
1735         } catch (Throwable t) { unexpected(t); }
1736 
1737         //----------------------------------------------------------------
1738         // Test Runtime.exec(...envp...)
1739         // and check SystemRoot gets set automatically on Windows
1740         //----------------------------------------------------------------
1741         try {
1742             if (Windows.is()) {
1743                 String systemRoot = &quot;SystemRoot=&quot; + System.getenv(&quot;SystemRoot&quot;);
1744                 String[]envp = {&quot;FOO=BAR&quot;,&quot;BAZ=GORP&quot;,&quot;QUUX=&quot;,
1745                                 &quot;+=+&quot;, &quot;_=_&quot;, &quot;~=~&quot;};
1746                 String output = nativeEnv(envp);
1747                 String expected = &quot;+=+\nBAZ=GORP\nFOO=BAR\nQUUX=\n&quot;+systemRoot+&quot;\n_=_\n~=~\n&quot;;
1748                 equal(output, expected);
1749             }
1750         } catch (Throwable t) { unexpected(t); }
1751 
1752         //----------------------------------------------------------------
1753         // System.getenv() must be consistent with System.getenv(String)
1754         //----------------------------------------------------------------
1755         try {
1756             for (Map.Entry&lt;String,String&gt; e : getenv().entrySet())
1757                 equal(getenv(e.getKey()), e.getValue());
1758         } catch (Throwable t) { unexpected(t); }
1759 
1760         //----------------------------------------------------------------
1761         // Fiddle with working directory in child
1762         //----------------------------------------------------------------
1763         try {
1764             String canonicalUserDir =
1765                 new File(System.getProperty(&quot;user.dir&quot;)).getCanonicalPath();
1766             String[] sdirs = new String[]
1767                 {&quot;.&quot;, &quot;..&quot;, &quot;/&quot;, &quot;/bin&quot;,
1768                  &quot;C:&quot;, &quot;c:&quot;, &quot;C:/&quot;, &quot;c:\\&quot;, &quot;\\&quot;, &quot;\\bin&quot;,
1769                  &quot;c:\\windows  &quot;, &quot;c:\\Program Files&quot;, &quot;c:\\Program Files\\&quot; };
1770             for (String sdir : sdirs) {
1771                 File dir = new File(sdir);
1772                 if (! (dir.isDirectory() &amp;&amp; dir.exists()))
1773                     continue;
1774                 out.println(&quot;Testing directory &quot; + dir);
1775                 //dir = new File(dir.getCanonicalPath());
1776 
1777                 ProcessBuilder pb = new ProcessBuilder();
1778                 equal(pb.directory(), null);
1779                 equal(pwdInChild(pb), canonicalUserDir);
1780 
1781                 pb.directory(dir);
1782                 equal(pb.directory(), dir);
1783                 equal(pwdInChild(pb), dir.getCanonicalPath());
1784 
1785                 pb.directory(null);
1786                 equal(pb.directory(), null);
1787                 equal(pwdInChild(pb), canonicalUserDir);
1788 
1789                 pb.directory(dir);
1790             }
1791         } catch (Throwable t) { unexpected(t); }
1792 
1793         //----------------------------------------------------------------
1794         // Working directory with Unicode in child
1795         //----------------------------------------------------------------
1796         try {
1797             if (UnicodeOS.is()) {
1798                 File dir = new File(System.getProperty(&quot;test.dir&quot;, &quot;.&quot;),
1799                                     &quot;ProcessBuilderDir\u4e00\u4e02&quot;);
1800                 try {
1801                     if (!dir.exists())
1802                         dir.mkdir();
1803                     out.println(&quot;Testing Unicode directory:&quot; + dir);
1804                     ProcessBuilder pb = new ProcessBuilder();
1805                     pb.directory(dir);
1806                     equal(pwdInChild(pb), dir.getCanonicalPath());
1807                 } finally {
1808                     if (dir.exists())
1809                         dir.delete();
1810                 }
1811             }
1812         } catch (Throwable t) { unexpected(t); }
1813 
1814         //----------------------------------------------------------------
1815         // OOME in child allocating maximally sized array
1816         // Test for hotspot/jvmti bug 6850957
1817         //----------------------------------------------------------------
1818         try {
1819             List&lt;String&gt; list = new ArrayList&lt;String&gt;(javaChildArgs);
1820             list.add(1, String.format(&quot;-XX:OnOutOfMemoryError=%s -version&quot;,
1821                                       javaExe));
1822             list.add(&quot;ArrayOOME&quot;);
1823             ProcessResults r = run(new ProcessBuilder(list));
1824             check(r.err().contains(&quot;java.lang.OutOfMemoryError:&quot;));
1825             check(r.err().contains(javaExe));
1826             check(r.err().contains(System.getProperty(&quot;java.version&quot;)));
1827             equal(r.exitValue(), 1);
1828         } catch (Throwable t) { unexpected(t); }
1829 
1830         //----------------------------------------------------------------
1831         // Windows has tricky semi-case-insensitive semantics
1832         //----------------------------------------------------------------
1833         if (Windows.is())
1834             try {
1835                 out.println(&quot;Running case insensitve variable tests&quot;);
1836                 for (String[] namePair :
1837                          new String[][]
1838                     { new String[]{&quot;PATH&quot;,&quot;PaTh&quot;},
1839                       new String[]{&quot;home&quot;,&quot;HOME&quot;},
1840                       new String[]{&quot;SYSTEMROOT&quot;,&quot;SystemRoot&quot;}}) {
1841                     check((getenv(namePair[0]) == null &amp;&amp;
1842                            getenv(namePair[1]) == null)
1843                           ||
1844                           getenv(namePair[0]).equals(getenv(namePair[1])),
1845                           &quot;Windows environment variables are not case insensitive&quot;);
1846                 }
1847             } catch (Throwable t) { unexpected(t); }
1848 
1849         //----------------------------------------------------------------
1850         // Test proper Unicode child environment transfer
1851         //----------------------------------------------------------------
1852         if (UnicodeOS.is())
1853             try {
1854                 ProcessBuilder pb = new ProcessBuilder();
1855                 pb.environment().put(&quot;\u1234&quot;,&quot;\u5678&quot;);
1856                 pb.environment().remove(&quot;PATH&quot;);
1857                 equal(getenvInChild1234(pb), &quot;\u5678&quot;);
1858             } catch (Throwable t) { unexpected(t); }
1859 
1860 
1861         //----------------------------------------------------------------
1862         // Test Runtime.exec(...envp...) with envstrings with initial `=&#39;
1863         //----------------------------------------------------------------
1864         try {
1865             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
1866             childArgs.add(&quot;System.getenv()&quot;);
1867             String[] cmdp = childArgs.toArray(new String[childArgs.size()]);
1868             String[] envp;
1869             String[] envpWin = {&quot;=C:=\\&quot;, &quot;=ExitValue=3&quot;, &quot;SystemRoot=&quot;+systemRoot};
1870             String[] envpOth = {&quot;=ExitValue=3&quot;, &quot;=C:=\\&quot;};
1871             if (Windows.is()) {
1872                 envp = envpWin;
1873             } else {
1874                 envp = envpOth;
1875             }
1876             Process p = Runtime.getRuntime().exec(cmdp, envp);
1877             String expected = Windows.is() ? &quot;=C:=\\,=ExitValue=3,SystemRoot=&quot;+systemRoot+&quot;,&quot; : &quot;=C:=\\,&quot;;
1878             expected = AIX.is() ? expected + &quot;LIBPATH=&quot;+libpath+&quot;,&quot;: expected;
1879             String commandOutput = commandOutput(p);
1880             if (MacOSX.is()) {
1881                 commandOutput = removeMacExpectedVars(commandOutput);
1882             }
1883             if (AIX.is()) {
1884                 commandOutput = removeAixExpectedVars(commandOutput);
1885             }
1886             equal(commandOutput, expected);
1887             if (Windows.is()) {
1888                 ProcessBuilder pb = new ProcessBuilder(childArgs);
1889                 pb.environment().clear();
1890                 pb.environment().put(&quot;SystemRoot&quot;, systemRoot);
1891                 pb.environment().put(&quot;=ExitValue&quot;, &quot;3&quot;);
1892                 pb.environment().put(&quot;=C:&quot;, &quot;\\&quot;);
1893                 equal(commandOutput(pb), expected);
1894             }
1895         } catch (Throwable t) { unexpected(t); }
1896 
1897         //----------------------------------------------------------------
1898         // Test Runtime.exec(...envp...) with envstrings without any `=&#39;
1899         //----------------------------------------------------------------
1900         try {
1901             String[] cmdp = {&quot;echo&quot;};
1902             String[] envp = {&quot;Hello&quot;, &quot;World&quot;}; // Yuck!
1903             Process p = Runtime.getRuntime().exec(cmdp, envp);
1904             equal(commandOutput(p), &quot;\n&quot;);
1905         } catch (Throwable t) { unexpected(t); }
1906 
1907         //----------------------------------------------------------------
1908         // Test Runtime.exec(...envp...) with envstrings containing NULs
1909         //----------------------------------------------------------------
1910         try {
1911             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
1912             childArgs.add(&quot;System.getenv()&quot;);
1913             String[] cmdp = childArgs.toArray(new String[childArgs.size()]);
1914             String[] envpWin = {&quot;SystemRoot=&quot;+systemRoot, &quot;LC_ALL=C\u0000\u0000&quot;, // Yuck!
1915                              &quot;FO\u0000=B\u0000R&quot;};
1916             String[] envpOth = {&quot;LC_ALL=C\u0000\u0000&quot;, // Yuck!
1917                              &quot;FO\u0000=B\u0000R&quot;};
1918             String[] envp;
1919             if (Windows.is()) {
1920                 envp = envpWin;
1921             } else {
1922                 envp = envpOth;
1923             }
1924             System.out.println (&quot;cmdp&quot;);
1925             for (int i=0; i&lt;cmdp.length; i++) {
1926                 System.out.printf (&quot;cmdp %d: %s\n&quot;, i, cmdp[i]);
1927             }
1928             System.out.println (&quot;envp&quot;);
1929             for (int i=0; i&lt;envp.length; i++) {
1930                 System.out.printf (&quot;envp %d: %s\n&quot;, i, envp[i]);
1931             }
1932             Process p = Runtime.getRuntime().exec(cmdp, envp);
1933             String commandOutput = commandOutput(p);
1934             if (MacOSX.is()) {
1935                 commandOutput = removeMacExpectedVars(commandOutput);
1936             }
1937             if (AIX.is()) {
1938                 commandOutput = removeAixExpectedVars(commandOutput);
1939             }
1940             check(commandOutput.equals(Windows.is()
1941                     ? &quot;LC_ALL=C,SystemRoot=&quot;+systemRoot+&quot;,&quot;
1942                     : AIX.is()
1943                             ? &quot;LC_ALL=C,LIBPATH=&quot;+libpath+&quot;,&quot;
1944                             : &quot;LC_ALL=C,&quot;),
1945                   &quot;Incorrect handling of envstrings containing NULs&quot;);
1946         } catch (Throwable t) { unexpected(t); }
1947 
1948         //----------------------------------------------------------------
1949         // Test the redirectErrorStream property
1950         //----------------------------------------------------------------
1951         try {
1952             ProcessBuilder pb = new ProcessBuilder();
1953             equal(pb.redirectErrorStream(), false);
1954             equal(pb.redirectErrorStream(true), pb);
1955             equal(pb.redirectErrorStream(), true);
1956             equal(pb.redirectErrorStream(false), pb);
1957             equal(pb.redirectErrorStream(), false);
1958         } catch (Throwable t) { unexpected(t); }
1959 
1960         try {
1961             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
1962             childArgs.add(&quot;OutErr&quot;);
1963             ProcessBuilder pb = new ProcessBuilder(childArgs);
1964             {
1965                 ProcessResults r = run(pb);
1966                 equal(r.out(), &quot;outout&quot;);
1967                 equal(r.err(), &quot;errerr&quot;);
1968             }
1969             {
1970                 pb.redirectErrorStream(true);
1971                 ProcessResults r = run(pb);
1972                 equal(r.out(), &quot;outerrouterr&quot;);
1973                 equal(r.err(), &quot;&quot;);
1974             }
1975         } catch (Throwable t) { unexpected(t); }
1976 
1977         if (Unix.is()) {
1978             //----------------------------------------------------------------
1979             // We can find true and false when PATH is null
1980             //----------------------------------------------------------------
1981             try {
1982                 List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
1983                 childArgs.add(&quot;null PATH&quot;);
1984                 ProcessBuilder pb = new ProcessBuilder(childArgs);
1985                 pb.environment().remove(&quot;PATH&quot;);
1986                 ProcessResults r = run(pb);
1987                 equal(r.out(), &quot;&quot;);
1988                 equal(r.err(), &quot;&quot;);
1989                 equal(r.exitValue(), 0);
1990             } catch (Throwable t) { unexpected(t); }
1991 
1992             //----------------------------------------------------------------
1993             // PATH search algorithm on Unix
1994             //----------------------------------------------------------------
1995             try {
1996                 List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
1997                 childArgs.add(&quot;PATH search algorithm&quot;);
1998                 ProcessBuilder pb = new ProcessBuilder(childArgs);
1999                 pb.environment().put(&quot;PATH&quot;, &quot;dir1:dir2:&quot;);
2000                 ProcessResults r = run(pb);
2001                 equal(r.out(), &quot;&quot;);
2002                 equal(r.err(), &quot;&quot;);
2003                 equal(r.exitValue(), True.exitValue());
2004             } catch (Throwable t) { unexpected(t); }
2005 
2006             //----------------------------------------------------------------
2007             // Parent&#39;s, not child&#39;s PATH is used
2008             //----------------------------------------------------------------
2009             try {
2010                 new File(&quot;suBdiR&quot;).mkdirs();
2011                 copy(TrueExe.path(), &quot;suBdiR/unliKely&quot;);
2012                 final ProcessBuilder pb =
2013                     new ProcessBuilder(new String[]{&quot;unliKely&quot;});
2014                 pb.environment().put(&quot;PATH&quot;, &quot;suBdiR&quot;);
2015                 THROWS(IOException.class, () -&gt; pb.start());
2016             } catch (Throwable t) { unexpected(t);
2017             } finally {
2018                 new File(&quot;suBdiR/unliKely&quot;).delete();
2019                 new File(&quot;suBdiR&quot;).delete();
2020             }
2021         }
2022 
2023         //----------------------------------------------------------------
2024         // Attempt to start bogus program &quot;&quot;
2025         //----------------------------------------------------------------
2026         try {
2027             new ProcessBuilder(&quot;&quot;).start();
2028             fail(&quot;Expected IOException not thrown&quot;);
2029         } catch (IOException e) {
2030             String m = e.getMessage();
2031             if (EnglishUnix.is() &amp;&amp;
2032                 ! matches(m, NO_SUCH_FILE_ERROR_MSG))
2033                 unexpected(e);
2034         } catch (Throwable t) { unexpected(t); }
2035 
2036         //----------------------------------------------------------------
2037         // Check that attempt to execute program name with funny
2038         // characters throws an exception containing those characters.
2039         //----------------------------------------------------------------
2040         for (String programName : new String[] {&quot;\u00f0&quot;, &quot;\u01f0&quot;})
2041             try {
2042                 new ProcessBuilder(programName).start();
2043                 fail(&quot;Expected IOException not thrown&quot;);
2044             } catch (IOException e) {
2045                 String m = e.getMessage();
2046                 Pattern p = Pattern.compile(programName);
2047                 if (! matches(m, programName)
2048                     || (EnglishUnix.is() &amp;&amp;
2049                         ! matches(m, NO_SUCH_FILE_ERROR_MSG)))
2050                     unexpected(e);
2051             } catch (Throwable t) { unexpected(t); }
2052 
2053         //----------------------------------------------------------------
2054         // Attempt to start process in nonexistent directory fails.
2055         //----------------------------------------------------------------
2056         try {
2057             new ProcessBuilder(&quot;echo&quot;)
2058                 .directory(new File(&quot;UnLiKeLY&quot;))
2059                 .start();
2060             fail(&quot;Expected IOException not thrown&quot;);
2061         } catch (IOException e) {
2062             String m = e.getMessage();
2063             if (! matches(m, &quot;in directory&quot;)
2064                 || (EnglishUnix.is() &amp;&amp;
2065                     ! matches(m, NO_SUCH_FILE_ERROR_MSG)))
2066                 unexpected(e);
2067         } catch (Throwable t) { unexpected(t); }
2068 
2069         //----------------------------------------------------------------
2070         // Attempt to write 4095 bytes to the pipe buffer without a
2071         // reader to drain it would deadlock, if not for the fact that
2072         // interprocess pipe buffers are at least 4096 bytes.
2073         //
2074         // Also, check that available reports all the bytes expected
2075         // in the pipe buffer, and that I/O operations do the expected
2076         // things.
2077         //----------------------------------------------------------------
2078         try {
2079             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2080             childArgs.add(&quot;print4095&quot;);
2081             final int SIZE = 4095;
2082             final Process p = new ProcessBuilder(childArgs).start();
2083             print4095(p.getOutputStream(), (byte) &#39;!&#39;); // Might hang!
2084             p.waitFor();                                // Might hang!
2085             equal(SIZE, p.getInputStream().available());
2086             equal(SIZE, p.getErrorStream().available());
2087             THROWS(IOException.class,
2088                    () -&gt; { p.getOutputStream().write((byte) &#39;!&#39;);
2089                            p.getOutputStream().flush();});
2090 
2091             final byte[] bytes = new byte[SIZE + 1];
2092             equal(SIZE, p.getInputStream().read(bytes));
2093             for (int i = 0; i &lt; SIZE; i++)
2094                 equal((byte) &#39;!&#39;, bytes[i]);
2095             equal((byte) 0, bytes[SIZE]);
2096 
2097             equal(SIZE, p.getErrorStream().read(bytes));
2098             for (int i = 0; i &lt; SIZE; i++)
2099                 equal((byte) &#39;E&#39;, bytes[i]);
2100             equal((byte) 0, bytes[SIZE]);
2101 
2102             equal(0, p.getInputStream().available());
2103             equal(0, p.getErrorStream().available());
2104             equal(-1, p.getErrorStream().read());
2105             equal(-1, p.getInputStream().read());
2106 
2107             equal(p.exitValue(), 5);
2108 
2109             p.getInputStream().close();
2110             p.getErrorStream().close();
2111             try { p.getOutputStream().close(); } catch (IOException flushFailed) { }
2112 
2113             InputStream[] streams = { p.getInputStream(), p.getErrorStream() };
2114             for (final InputStream in : streams) {
2115                 Fun[] ops = {
2116                     () -&gt; in.read(),
2117                     () -&gt; in.read(bytes),
2118                     () -&gt; in.available()
2119                 };
2120                 for (Fun op : ops) {
2121                     try {
2122                         op.f();
2123                         fail();
2124                     } catch (IOException expected) {
2125                         check(expected.getMessage()
2126                               .matches(&quot;[Ss]tream [Cc]losed&quot;));
2127                     }
2128                 }
2129             }
2130         } catch (Throwable t) { unexpected(t); }
2131 
2132         //----------------------------------------------------------------
2133         // Check that reads which are pending when Process.destroy is
2134         // called, get EOF, or IOException(&quot;Stream closed&quot;).
2135         //----------------------------------------------------------------
2136         try {
2137             final int cases = 4;
2138             for (int i = 0; i &lt; cases; i++) {
2139                 final int action = i;
2140                 List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2141                 childArgs.add(&quot;sleep&quot;);
2142                 final byte[] bytes = new byte[10];
2143                 final Process p = new ProcessBuilder(childArgs).start();
2144                 final CountDownLatch latch = new CountDownLatch(1);
2145                 final InputStream s;
2146                 switch (action &amp; 0x1) {
2147                     case 0: s = p.getInputStream(); break;
2148                     case 1: s = p.getErrorStream(); break;
2149                     default: throw new Error();
2150                 }
2151                 final Thread thread = new Thread() {
2152                     public void run() {
2153                         try {
2154                             int r;
2155                             latch.countDown();
2156                             switch (action &amp; 0x2) {
2157                                 case 0: r = s.read(); break;
2158                                 case 2: r = s.read(bytes); break;
2159                                 default: throw new Error();
2160                             }
2161                             if (r &gt;= 0) {
2162                                 // The child sent unexpected output; print it to diagnose
2163                                 System.out.println(&quot;Unexpected child output:&quot;);
2164                                 if ((action &amp; 0x2) == 0) {
2165                                     System.out.write(r);    // Single character
2166 
2167                                 } else {
2168                                     System.out.write(bytes, 0, r);
2169                                 }
2170                                 for (int c = s.read(); c &gt;= 0; c = s.read())
2171                                     System.out.write(c);
2172                                 System.out.println(&quot;\nEND Child output.&quot;);
2173                             }
2174                             equal(-1, r);
2175                         } catch (IOException ioe) {
2176                             if (!ioe.getMessage().equals(&quot;Stream closed&quot;)) {
2177                                 // BufferedInputStream may throw IOE(&quot;Stream closed&quot;).
2178                                 unexpected(ioe);
2179                             }
2180                         } catch (Throwable t) { unexpected(t); }}};
2181 
2182                 thread.start();
2183                 latch.await();
2184                 Thread.sleep(10);
2185 
2186                 if (s instanceof BufferedInputStream) {
2187                     // Wait until after the s.read occurs in &quot;thread&quot; by
2188                     // checking when the input stream monitor is acquired
2189                     // (BufferedInputStream.read is synchronized)
2190                     while (!isLocked(s, 10)) {
2191                         Thread.sleep(100);
2192                     }
2193                 }
2194                 p.destroy();
2195                 thread.join();
2196             }
2197         } catch (Throwable t) { unexpected(t); }
2198 
2199         //----------------------------------------------------------------
2200         // Check that subprocesses which create subprocesses of their
2201         // own do not cause parent to hang waiting for file
2202         // descriptors to be closed.
2203         //----------------------------------------------------------------
2204         try {
2205             if (Unix.is()
2206                 &amp;&amp; new File(&quot;/bin/bash&quot;).exists()
2207                 &amp;&amp; new File(&quot;/bin/sleep&quot;).exists()) {
2208                 // Notice that we only destroy the process created by us (i.e.
2209                 // our child) but not our grandchild (i.e. &#39;/bin/sleep&#39;). So
2210                 // pay attention that the grandchild doesn&#39;t run too long to
2211                 // avoid polluting the process space with useless processes.
2212                 // Running the grandchild for 60s should be more than enough.
2213                 final String[] cmd = { &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;(/bin/sleep 60)&quot; };
2214                 final String[] cmdkill = { &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;(/usr/bin/pkill -f \&quot;sleep 60\&quot;)&quot; };
2215                 final ProcessBuilder pb = new ProcessBuilder(cmd);
2216                 final Process p = pb.start();
2217                 final InputStream stdout = p.getInputStream();
2218                 final InputStream stderr = p.getErrorStream();
2219                 final OutputStream stdin = p.getOutputStream();
2220                 final Thread reader = new Thread() {
2221                     public void run() {
2222                         try { stdout.read(); }
2223                         catch (IOException e) {
2224                             // Check that reader failed because stream was
2225                             // asynchronously closed.
2226                             // e.printStackTrace();
2227                             String msg = e.getMessage();
2228                             if (EnglishUnix.is() &amp;&amp;
2229                                 ! (msg.matches(&quot;.*Bad file.*&quot;) ||
2230                                         msg.matches(&quot;.*Stream closed.*&quot;)))
2231                                 unexpected(e);
2232                         }
2233                         catch (Throwable t) { unexpected(t); }}};
2234                 reader.setDaemon(true);
2235                 reader.start();
2236                 Thread.sleep(100);
2237                 p.destroy();
2238                 check(p.waitFor() != 0);
2239                 check(p.exitValue() != 0);
2240                 // Subprocess is now dead, but file descriptors remain open.
2241                 // Make sure the test will fail if we don&#39;t manage to close
2242                 // the open streams within 30 seconds. Notice that this time
2243                 // must be shorter than the sleep time of the grandchild.
2244                 Timer t = new Timer(&quot;test/java/lang/ProcessBuilder/Basic.java process reaper&quot;, true);
2245                 t.schedule(new TimerTask() {
2246                       public void run() {
2247                           fail(&quot;Subprocesses which create subprocesses of &quot; +
2248                                &quot;their own caused the parent to hang while &quot; +
2249                                &quot;waiting for file descriptors to be closed.&quot;);
2250                           System.exit(-1);
2251                       }
2252                   }, 30000);
2253                 stdout.close();
2254                 stderr.close();
2255                 stdin.close();
2256                 new ProcessBuilder(cmdkill).start();
2257                 // All streams successfully closed so we can cancel the timer.
2258                 t.cancel();
2259                 //----------------------------------------------------------
2260                 // There remain unsolved issues with asynchronous close.
2261                 // Here&#39;s a highly non-portable experiment to demonstrate:
2262                 //----------------------------------------------------------
2263                 if (Boolean.getBoolean(&quot;wakeupJeff!&quot;)) {
2264                     System.out.println(&quot;wakeupJeff!&quot;);
2265                     // Initialize signal handler for INTERRUPT_SIGNAL.
2266                     new FileInputStream(&quot;/bin/sleep&quot;).getChannel().close();
2267                     // Send INTERRUPT_SIGNAL to every thread in this java.
2268                     String[] wakeupJeff = {
2269                         &quot;/bin/bash&quot;, &quot;-c&quot;,
2270                         &quot;/bin/ps --noheaders -Lfp $PPID | &quot; +
2271                         &quot;/usr/bin/perl -nale &#39;print $F[3]&#39; | &quot; +
2272                         // INTERRUPT_SIGNAL == 62 on my machine du jour.
2273                         &quot;/usr/bin/xargs kill -62&quot;
2274                     };
2275                     new ProcessBuilder(wakeupJeff).start().waitFor();
2276                     // If wakeupJeff worked, reader probably got EBADF.
2277                     reader.join();
2278                 }
2279             }
2280 
2281             //----------------------------------------------------------------
2282             // Check the Process toString() method
2283             //----------------------------------------------------------------
2284             {
2285                 List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2286                 childArgs.add(&quot;testIO&quot;);
2287                 ProcessBuilder pb = new ProcessBuilder(childArgs);
2288                 pb.redirectInput(Redirect.PIPE);
2289                 pb.redirectOutput(DISCARD);
2290                 pb.redirectError(DISCARD);
2291                 final Process p = pb.start();
2292                 // Child process waits until it gets input
2293                 String s = p.toString();
2294                 check(s.contains(&quot;not exited&quot;));
2295                 check(s.contains(&quot;pid=&quot; + p.pid() + &quot;,&quot;));
2296 
2297                 new PrintStream(p.getOutputStream()).print(&quot;standard input&quot;);
2298                 p.getOutputStream().close();
2299 
2300                 // Check the toString after it exits
2301                 int exitValue = p.waitFor();
2302                 s = p.toString();
2303                 check(s.contains(&quot;pid=&quot; + p.pid() + &quot;,&quot;));
2304                 check(s.contains(&quot;exitValue=&quot; + exitValue) &amp;&amp;
2305                         !s.contains(&quot;not exited&quot;));
2306             }
2307         } catch (Throwable t) { unexpected(t); }
2308 
2309         //----------------------------------------------------------------
2310         // Attempt to start process with insufficient permissions fails.
2311         //----------------------------------------------------------------
2312         try {
2313             new File(&quot;emptyCommand&quot;).delete();
2314             new FileOutputStream(&quot;emptyCommand&quot;).close();
2315             new File(&quot;emptyCommand&quot;).setExecutable(false);
2316             new ProcessBuilder(&quot;./emptyCommand&quot;).start();
2317             fail(&quot;Expected IOException not thrown&quot;);
2318         } catch (IOException e) {
2319             new File(&quot;./emptyCommand&quot;).delete();
2320             String m = e.getMessage();
2321             if (EnglishUnix.is() &amp;&amp;
2322                 ! matches(m, PERMISSION_DENIED_ERROR_MSG))
2323                 unexpected(e);
2324         } catch (Throwable t) { unexpected(t); }
2325 
2326         new File(&quot;emptyCommand&quot;).delete();
2327 
2328         //----------------------------------------------------------------
2329         // Check for correct security permission behavior
2330         //----------------------------------------------------------------
2331         final Policy policy = new Policy();
2332         Policy.setPolicy(policy);
2333         System.setSecurityManager(new SecurityManager());
2334 
2335         try {
2336             // No permissions required to CREATE a ProcessBuilder
2337             policy.setPermissions(/* Nothing */);
2338             new ProcessBuilder(&quot;env&quot;).directory(null).directory();
2339             new ProcessBuilder(&quot;env&quot;).directory(new File(&quot;dir&quot;)).directory();
2340             new ProcessBuilder(&quot;env&quot;).command(&quot;??&quot;).command();
2341         } catch (Throwable t) { unexpected(t); }
2342 
2343         THROWS(SecurityException.class,
2344                () -&gt; { policy.setPermissions(/* Nothing */);
2345                        System.getenv(&quot;foo&quot;);},
2346                () -&gt; { policy.setPermissions(/* Nothing */);
2347                        System.getenv();},
2348                () -&gt; { policy.setPermissions(/* Nothing */);
2349                        new ProcessBuilder(&quot;echo&quot;).start();},
2350                () -&gt; { policy.setPermissions(/* Nothing */);
2351                        Runtime.getRuntime().exec(&quot;echo&quot;);},
2352                () -&gt; { policy.setPermissions(
2353                                new RuntimePermission(&quot;getenv.bar&quot;));
2354                        System.getenv(&quot;foo&quot;);});
2355 
2356         try {
2357             policy.setPermissions(new RuntimePermission(&quot;getenv.foo&quot;));
2358             System.getenv(&quot;foo&quot;);
2359 
2360             policy.setPermissions(new RuntimePermission(&quot;getenv.*&quot;));
2361             System.getenv(&quot;foo&quot;);
2362             System.getenv();
2363             new ProcessBuilder().environment();
2364         } catch (Throwable t) { unexpected(t); }
2365 
2366 
2367         final Permission execPermission
2368             = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;execute&quot;);
2369 
2370         THROWS(SecurityException.class,
2371                () -&gt; { // environment permission by itself insufficient
2372                        policy.setPermissions(new RuntimePermission(&quot;getenv.*&quot;));
2373                        ProcessBuilder pb = new ProcessBuilder(&quot;env&quot;);
2374                        pb.environment().put(&quot;foo&quot;,&quot;bar&quot;);
2375                        pb.start();},
2376                () -&gt; { // exec permission by itself insufficient
2377                        policy.setPermissions(execPermission);
2378                        ProcessBuilder pb = new ProcessBuilder(&quot;env&quot;);
2379                        pb.environment().put(&quot;foo&quot;,&quot;bar&quot;);
2380                        pb.start();});
2381 
2382         try {
2383             // Both permissions? OK.
2384             policy.setPermissions(new RuntimePermission(&quot;getenv.*&quot;),
2385                                   execPermission);
2386             ProcessBuilder pb = new ProcessBuilder(&quot;env&quot;);
2387             pb.environment().put(&quot;foo&quot;,&quot;bar&quot;);
2388             Process p = pb.start();
2389             closeStreams(p);
2390         } catch (IOException e) { // OK
2391         } catch (Throwable t) { unexpected(t); }
2392 
2393         try {
2394             // Don&#39;t need environment permission unless READING environment
2395             policy.setPermissions(execPermission);
2396             Runtime.getRuntime().exec(&quot;env&quot;, new String[]{});
2397         } catch (IOException e) { // OK
2398         } catch (Throwable t) { unexpected(t); }
2399 
2400         try {
2401             // Don&#39;t need environment permission unless READING environment
2402             policy.setPermissions(execPermission);
2403             new ProcessBuilder(&quot;env&quot;).start();
2404         } catch (IOException e) { // OK
2405         } catch (Throwable t) { unexpected(t); }
2406 
2407         // Restore &quot;normal&quot; state without a security manager
2408         policy.setPermissions(new RuntimePermission(&quot;setSecurityManager&quot;));
2409         System.setSecurityManager(null);
2410 
2411         //----------------------------------------------------------------
2412         // Check that Process.isAlive() &amp;
2413         // Process.waitFor(0, TimeUnit.MILLISECONDS) work as expected.
2414         //----------------------------------------------------------------
2415         try {
2416             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2417             childArgs.add(&quot;sleep&quot;);
2418             final Process p = new ProcessBuilder(childArgs).start();
2419             long start = System.nanoTime();
2420             if (!p.isAlive() || p.waitFor(0, TimeUnit.MILLISECONDS)) {
2421                 fail(&quot;Test failed: Process exited prematurely&quot;);
2422             }
2423             long end = System.nanoTime();
2424             // give waitFor(timeout) a wide berth (2s)
2425             System.out.printf(&quot; waitFor process: delta: %d%n&quot;,(end - start) );
2426 
2427             if ((end - start) &gt; TimeUnit.SECONDS.toNanos(2))
2428                 fail(&quot;Test failed: waitFor took too long (&quot; + (end - start) + &quot;ns)&quot;);
2429 
2430             p.destroy();
2431             p.waitFor();
2432 
2433             if (p.isAlive() ||
2434                 !p.waitFor(0, TimeUnit.MILLISECONDS))
2435             {
2436                 fail(&quot;Test failed: Process still alive - please terminate &quot; +
2437                     p.toString() + &quot; manually&quot;);
2438             }
2439         } catch (Throwable t) { unexpected(t); }
2440 
2441         //----------------------------------------------------------------
2442         // Check that Process.waitFor(timeout, TimeUnit.MILLISECONDS)
2443         // works as expected.
2444         //----------------------------------------------------------------
2445         try {
2446             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2447             childArgs.add(&quot;sleep&quot;);
2448             final Process p = new ProcessBuilder(childArgs).start();
2449             long start = System.nanoTime();
2450 
2451             p.waitFor(10, TimeUnit.MILLISECONDS);
2452 
2453             long end = System.nanoTime();
2454             if ((end - start) &lt; TimeUnit.MILLISECONDS.toNanos(10))
2455                 fail(&quot;Test failed: waitFor didn&#39;t take long enough (&quot; + (end - start) + &quot;ns)&quot;);
2456 
2457             p.destroy();
2458         } catch (Throwable t) { unexpected(t); }
2459 
2460         //----------------------------------------------------------------
2461         // Check that Process.waitFor(timeout, TimeUnit.MILLISECONDS)
2462         // interrupt works as expected, if interrupted while waiting.
2463         //----------------------------------------------------------------
2464         try {
2465             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2466             childArgs.add(&quot;sleep&quot;);
2467             final Process p = new ProcessBuilder(childArgs).start();
2468             final long start = System.nanoTime();
2469             final CountDownLatch aboutToWaitFor = new CountDownLatch(1);
2470 
2471             final Thread thread = new Thread() {
2472                 public void run() {
2473                     try {
2474                         aboutToWaitFor.countDown();
2475                         Thread.currentThread().interrupt();
2476                         boolean result = p.waitFor(30L * 1000L, TimeUnit.MILLISECONDS);
2477                         fail(&quot;waitFor() wasn&#39;t interrupted, its return value was: &quot; + result);
2478                     } catch (InterruptedException success) {
2479                     } catch (Throwable t) { unexpected(t); }
2480                 }
2481             };
2482 
2483             thread.start();
2484             aboutToWaitFor.await();
2485             thread.interrupt();
2486             thread.join(10L * 1000L);
2487             check(millisElapsedSince(start) &lt; 10L * 1000L);
2488             check(!thread.isAlive());
2489             p.destroy();
2490         } catch (Throwable t) { unexpected(t); }
2491 
2492         //----------------------------------------------------------------
2493         // Check that Process.waitFor(Long.MAX_VALUE, TimeUnit.MILLISECONDS)
2494         // interrupt works as expected, if interrupted while waiting.
2495         //----------------------------------------------------------------
2496         try {
2497             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2498             childArgs.add(&quot;sleep&quot;);
2499             final Process p = new ProcessBuilder(childArgs).start();
2500             final long start = System.nanoTime();
2501             final CountDownLatch aboutToWaitFor = new CountDownLatch(1);
2502 
2503             final Thread thread = new Thread() {
2504                 public void run() {
2505                     try {
2506                         aboutToWaitFor.countDown();
2507                         Thread.currentThread().interrupt();
2508                         boolean result = p.waitFor(Long.MAX_VALUE, TimeUnit.MILLISECONDS);
2509                         fail(&quot;waitFor() wasn&#39;t interrupted, its return value was: &quot; + result);
2510                     } catch (InterruptedException success) {
2511                     } catch (Throwable t) { unexpected(t); }
2512                 }
2513             };
2514 
2515             thread.start();
2516             aboutToWaitFor.await();
2517             thread.interrupt();
2518             thread.join(10L * 1000L);
2519             check(millisElapsedSince(start) &lt; 10L * 1000L);
2520             check(!thread.isAlive());
2521             p.destroy();
2522         } catch (Throwable t) { unexpected(t); }
2523 
2524         //----------------------------------------------------------------
2525         // Check that Process.waitFor(timeout, TimeUnit.MILLISECONDS)
2526         // interrupt works as expected, if interrupted before waiting.
2527         //----------------------------------------------------------------
2528         try {
2529             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2530             childArgs.add(&quot;sleep&quot;);
2531             final Process p = new ProcessBuilder(childArgs).start();
2532             final long start = System.nanoTime();
2533             final CountDownLatch threadStarted = new CountDownLatch(1);
2534 
2535             final Thread thread = new Thread() {
2536                 public void run() {
2537                     try {
2538                         threadStarted.countDown();
2539                         do { Thread.yield(); }
2540                         while (!Thread.currentThread().isInterrupted());
2541                         boolean result = p.waitFor(30L * 1000L, TimeUnit.MILLISECONDS);
2542                         fail(&quot;waitFor() wasn&#39;t interrupted, its return value was: &quot; + result);
2543                     } catch (InterruptedException success) {
2544                     } catch (Throwable t) { unexpected(t); }
2545                 }
2546             };
2547 
2548             thread.start();
2549             threadStarted.await();
2550             thread.interrupt();
2551             thread.join(10L * 1000L);
2552             check(millisElapsedSince(start) &lt; 10L * 1000L);
2553             check(!thread.isAlive());
2554             p.destroy();
2555         } catch (Throwable t) { unexpected(t); }
2556 
2557         //----------------------------------------------------------------
2558         // Check that Process.waitFor(timeout, null) throws NPE.
2559         //----------------------------------------------------------------
2560         try {
2561             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2562             childArgs.add(&quot;sleep&quot;);
2563             final Process p = new ProcessBuilder(childArgs).start();
2564             THROWS(NullPointerException.class,
2565                     () -&gt;  p.waitFor(10L, null));
2566             THROWS(NullPointerException.class,
2567                     () -&gt;  p.waitFor(0L, null));
2568             THROWS(NullPointerException.class,
2569                     () -&gt; p.waitFor(-1L, null));
2570             // Terminate process and recheck after it exits
2571             p.destroy();
2572             p.waitFor();
2573             THROWS(NullPointerException.class,
2574                     () -&gt; p.waitFor(10L, null));
2575             THROWS(NullPointerException.class,
2576                     () -&gt; p.waitFor(0L, null));
2577             THROWS(NullPointerException.class,
2578                     () -&gt; p.waitFor(-1L, null));
2579         } catch (Throwable t) { unexpected(t); }
2580 
2581         //----------------------------------------------------------------
2582         // Check that default implementation of Process.waitFor(timeout, null) throws NPE.
2583         //----------------------------------------------------------------
2584         try {
2585             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2586             childArgs.add(&quot;sleep&quot;);
2587             final Process proc = new ProcessBuilder(childArgs).start();
2588             final DelegatingProcess p = new DelegatingProcess(proc);
2589 
2590             THROWS(NullPointerException.class,
2591                     () -&gt;  p.waitFor(10L, null));
2592             THROWS(NullPointerException.class,
2593                     () -&gt;  p.waitFor(0L, null));
2594             THROWS(NullPointerException.class,
2595                     () -&gt;  p.waitFor(-1L, null));
2596             // Terminate process and recheck after it exits
2597             p.destroy();
2598             p.waitFor();
2599             THROWS(NullPointerException.class,
2600                     () -&gt; p.waitFor(10L, null));
2601             THROWS(NullPointerException.class,
2602                     () -&gt; p.waitFor(0L, null));
2603             THROWS(NullPointerException.class,
2604                     () -&gt; p.waitFor(-1L, null));
2605         } catch (Throwable t) { unexpected(t); }
2606 
2607         //----------------------------------------------------------------
2608         // Check the default implementation for
2609         // Process.waitFor(long, TimeUnit)
2610         //----------------------------------------------------------------
2611         try {
2612             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2613             childArgs.add(&quot;sleep&quot;);
2614             final Process proc = new ProcessBuilder(childArgs).start();
2615             DelegatingProcess p = new DelegatingProcess(proc);
2616             long start = System.nanoTime();
2617 
2618             p.waitFor(1000, TimeUnit.MILLISECONDS);
2619 
2620             long end = System.nanoTime();
2621             if ((end - start) &lt; 500000000)
2622                 fail(&quot;Test failed: waitFor didn&#39;t take long enough&quot;);
2623 
2624             p.destroy();
2625 
2626             p.waitFor(1000, TimeUnit.MILLISECONDS);
2627         } catch (Throwable t) { unexpected(t); }
2628     }
2629 
2630     static void closeStreams(Process p) {
2631         try {
2632             p.getOutputStream().close();
2633             p.getInputStream().close();
2634             p.getErrorStream().close();
2635         } catch (Throwable t) { unexpected(t); }
2636     }
2637 
2638     //----------------------------------------------------------------
2639     // A Policy class designed to make permissions fiddling very easy.
2640     //----------------------------------------------------------------
2641     private static class Policy extends java.security.Policy {
2642         static final java.security.Policy DEFAULT_POLICY = java.security.Policy.getPolicy();
2643 
2644         private Permissions perms;
2645 
2646         public void setPermissions(Permission...permissions) {
2647             perms = new Permissions();
2648             for (Permission permission : permissions)
2649                 perms.add(permission);
2650         }
2651 
2652         public Policy() { setPermissions(/* Nothing */); }
2653 
2654         public PermissionCollection getPermissions(CodeSource cs) {
2655             return perms;
2656         }
2657 
2658         public PermissionCollection getPermissions(ProtectionDomain pd) {
2659             return perms;
2660         }
2661 
2662         public boolean implies(ProtectionDomain pd, Permission p) {
2663             return perms.implies(p) || DEFAULT_POLICY.implies(pd, p);
2664         }
2665 
2666         public void refresh() {}
2667     }
2668 
2669     private static class StreamAccumulator extends Thread {
2670         private final InputStream is;
2671         private final StringBuilder sb = new StringBuilder();
2672         private Throwable throwable = null;
2673 
2674         public String result () throws Throwable {
2675             if (throwable != null)
2676                 throw throwable;
2677             return sb.toString();
2678         }
2679 
2680         StreamAccumulator (InputStream is) {
2681             this.is = is;
2682         }
2683 
2684         public void run() {
2685             try {
2686                 Reader r = new InputStreamReader(is);
2687                 char[] buf = new char[4096];
2688                 int n;
2689                 while ((n = r.read(buf)) &gt; 0) {
2690                     sb.append(buf,0,n);
2691                 }
2692             } catch (Throwable t) {
2693                 throwable = t;
2694             } finally {
2695                 try { is.close(); }
2696                 catch (Throwable t) { throwable = t; }
2697             }
2698         }
2699     }
2700 
2701     static ProcessResults run(ProcessBuilder pb) {
2702         try {
2703             return run(pb.start());
2704         } catch (Throwable t) { unexpected(t); return null; }
2705     }
2706 
2707     private static ProcessResults run(Process p) {
2708         Throwable throwable = null;
2709         int exitValue = -1;
2710         String out = &quot;&quot;;
2711         String err = &quot;&quot;;
2712 
2713         StreamAccumulator outAccumulator =
2714             new StreamAccumulator(p.getInputStream());
2715         StreamAccumulator errAccumulator =
2716             new StreamAccumulator(p.getErrorStream());
2717 
2718         try {
2719             outAccumulator.start();
2720             errAccumulator.start();
2721 
2722             exitValue = p.waitFor();
2723 
2724             outAccumulator.join();
2725             errAccumulator.join();
2726 
2727             out = outAccumulator.result();
2728             err = errAccumulator.result();
2729         } catch (Throwable t) {
2730             throwable = t;
2731         }
2732 
2733         return new ProcessResults(out, err, exitValue, throwable);
2734     }
2735 
2736     //----------------------------------------------------------------
2737     // Results of a command
2738     //----------------------------------------------------------------
2739     private static class ProcessResults {
2740         private final String out;
2741         private final String err;
2742         private final int exitValue;
2743         private final Throwable throwable;
2744 
2745         public ProcessResults(String out,
2746                               String err,
2747                               int exitValue,
2748                               Throwable throwable) {
2749             this.out = out;
2750             this.err = err;
2751             this.exitValue = exitValue;
2752             this.throwable = throwable;
2753         }
2754 
2755         public String out()          { return out; }
2756         public String err()          { return err; }
2757         public int exitValue()       { return exitValue; }
2758         public Throwable throwable() { return throwable; }
2759 
2760         public String toString() {
2761             StringBuilder sb = new StringBuilder();
2762             sb.append(&quot;&lt;STDOUT&gt;\n&quot; + out() + &quot;&lt;/STDOUT&gt;\n&quot;)
2763                 .append(&quot;&lt;STDERR&gt;\n&quot; + err() + &quot;&lt;/STDERR&gt;\n&quot;)
2764                 .append(&quot;exitValue = &quot; + exitValue + &quot;\n&quot;);
2765             if (throwable != null)
2766                 sb.append(throwable.getStackTrace());
2767             return sb.toString();
2768         }
2769     }
2770 
2771     //--------------------- Infrastructure ---------------------------
2772     static volatile int passed = 0, failed = 0;
2773     static void pass() {passed++;}
2774     static void fail() {failed++; Thread.dumpStack();}
2775     static void fail(String msg) {System.err.println(msg); fail();}
2776     static void unexpected(Throwable t) {failed++; t.printStackTrace();}
2777     static void check(boolean cond) {if (cond) pass(); else fail();}
2778     static void check(boolean cond, String m) {if (cond) pass(); else fail(m);}
2779     static void equal(Object x, Object y) {
2780         if (x == null ? y == null : x.equals(y)) pass();
2781         else fail(&quot;&gt;&#39;&quot; + x + &quot;&#39;&lt;&quot; + &quot; not equal to &quot; + &quot;&#39;&quot; + y + &quot;&#39;&quot;);}
2782 
2783     public static void main(String[] args) throws Throwable {
2784         try {realMain(args);} catch (Throwable t) {unexpected(t);}
2785         System.out.printf(&quot;%nPassed = %d, failed = %d%n%n&quot;, passed, failed);
2786         if (failed &gt; 0) throw new AssertionError(&quot;Some tests failed&quot;);}
2787     interface Fun {void f() throws Throwable;}
2788     static void THROWS(Class&lt;? extends Throwable&gt; k, Fun... fs) {
2789         for (Fun f : fs)
2790             try { f.f(); fail(&quot;Expected &quot; + k.getName() + &quot; not thrown&quot;); }
2791             catch (Throwable t) {
2792                 if (k.isAssignableFrom(t.getClass())) pass();
2793                 else unexpected(t);}}
2794 
2795     static boolean isLocked(final Object monitor, final long millis) throws InterruptedException {
2796         return new Thread() {
2797             volatile boolean unlocked;
2798 
2799             @Override
2800             public void run() {
2801                 synchronized (monitor) { unlocked = true; }
2802             }
2803 
2804             boolean isLocked() throws InterruptedException {
2805                 start();
2806                 join(millis);
2807                 return !unlocked;
2808             }
2809         }.isLocked();
2810     }
2811 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>