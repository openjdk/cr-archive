<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/os_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../../../make/test/JtregNativeJdk.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_linux.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 117   #define _GNU_SOURCE
 118   #include &lt;sched.h&gt;
 119   #undef _GNU_SOURCE
 120 #else
 121   #include &lt;sched.h&gt;
 122 #endif
 123 
 124 // if RUSAGE_THREAD for getrusage() has not been defined, do it here. The code calling
 125 // getrusage() is prepared to handle the associated failure.
 126 #ifndef RUSAGE_THREAD
 127   #define RUSAGE_THREAD   (1)               /* only the calling thread */
 128 #endif
 129 
 130 #define MAX_PATH    (2 * K)
 131 
 132 #define MAX_SECS 100000000
 133 
 134 // for timer info max values which include all bits
 135 #define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)
 136 











 137 enum CoredumpFilterBit {
 138   FILE_BACKED_PVT_BIT = 1 &lt;&lt; 2,
 139   FILE_BACKED_SHARED_BIT = 1 &lt;&lt; 3,
 140   LARGEPAGES_BIT = 1 &lt;&lt; 6,
 141   DAX_SHARED_BIT = 1 &lt;&lt; 8
 142 };
 143 
 144 ////////////////////////////////////////////////////////////////////////////////
 145 // global variables
 146 julong os::Linux::_physical_memory = 0;
 147 
 148 address   os::Linux::_initial_thread_stack_bottom = NULL;
 149 uintptr_t os::Linux::_initial_thread_stack_size   = 0;
 150 
 151 int (*os::Linux::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 152 int (*os::Linux::_pthread_setname_np)(pthread_t, const char*) = NULL;
 153 pthread_t os::Linux::_main_thread;
 154 int os::Linux::_page_size = -1;
 155 bool os::Linux::_supports_fast_thread_cpu_time = false;
<span class="line-modified"> 156 const char * os::Linux::_glibc_version = &quot;unknown&quot;;</span>
<span class="line-modified"> 157 const char * os::Linux::_libpthread_version = &quot;unknown&quot;;</span>
 158 size_t os::Linux::_default_large_page_size = 0;
 159 
 160 static jlong initial_time_count=0;
 161 
 162 static int clock_tics_per_sec = 100;
 163 
 164 // If the VM might have been created on the primordial thread, we need to resolve the
 165 // primordial thread stack bounds and check if the current thread might be the
 166 // primordial thread in places. If we know that the primordial thread is never used,
 167 // such as when the VM was created by one of the standard java launchers, we can
 168 // avoid this
 169 static bool suppress_primordial_thread_resolution = false;
 170 
 171 // For diagnostics to print a message once. see run_periodic_checks
 172 static sigset_t check_signal_done;
 173 static bool check_signals = true;
 174 
 175 // Signal number used to suspend/resume a thread
 176 
 177 // do not use any signal number less than SIGSEGV, see 4355769
</pre>
<hr />
<pre>
 590     if (thread-&gt;is_VM_thread()) {
 591       // Only the VM thread handles BREAK_SIGNAL ...
 592       pthread_sigmask(SIG_UNBLOCK, vm_signals(), NULL);
 593     } else {
 594       // ... all other threads block BREAK_SIGNAL
 595       pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);
 596     }
 597   }
 598 }
 599 
 600 //////////////////////////////////////////////////////////////////////////////
 601 // detecting pthread library
 602 
 603 void os::Linux::libpthread_init() {
 604   // Save glibc and pthread version strings.
 605 #if !defined(_CS_GNU_LIBC_VERSION) || \
 606     !defined(_CS_GNU_LIBPTHREAD_VERSION)
 607   #error &quot;glibc too old (&lt; 2.3.2)&quot;
 608 #endif
 609 
<span class="line-modified"> 610   size_t n;</span>
<span class="line-modified"> 611 </span>
<span class="line-modified"> 612   n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);</span>
<span class="line-modified"> 613   if (n &gt; 0) {</span>
<span class="line-modified"> 614     char* str = (char *)malloc(n, mtInternal);</span>
<span class="line-modified"> 615     confstr(_CS_GNU_LIBC_VERSION, str, n);</span>
<span class="line-modified"> 616     os::Linux::set_glibc_version(str);</span>
<span class="line-modified"> 617   }</span>



 618 
 619   n = confstr(_CS_GNU_LIBPTHREAD_VERSION, NULL, 0);
<span class="line-modified"> 620   if (n &gt; 0) {</span>
<span class="line-modified"> 621     char* str = (char *)malloc(n, mtInternal);</span>
<span class="line-modified"> 622     confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);</span>
<span class="line-modified"> 623     os::Linux::set_libpthread_version(str);</span>
<span class="line-modified"> 624   }</span>
 625 }
 626 
 627 /////////////////////////////////////////////////////////////////////////////
 628 // thread stack expansion
 629 
 630 // os::Linux::manually_expand_stack() takes care of expanding the thread
 631 // stack. Note that this is normally not needed: pthread stacks allocate
 632 // thread stack using mmap() without MAP_NORESERVE, so the stack is already
 633 // committed. Therefore it is not necessary to expand the stack manually.
 634 //
 635 // Manually expanding the stack was historically needed on LinuxThreads
 636 // thread stacks, which were allocated with mmap(MAP_GROWSDOWN). Nowadays
 637 // it is kept to deal with very rare corner cases:
 638 //
 639 // For one, user may run the VM on an own implementation of threads
 640 // whose stacks are - like the old LinuxThreads - implemented using
 641 // mmap(MAP_GROWSDOWN).
 642 //
 643 // Also, this coding may be needed if the VM is running on the primordial
 644 // thread. Normally we avoid running on the primordial thread; however,
</pre>
<hr />
<pre>
2302     }
2303     if (file_exists(file)) {
2304       parse_os_info(buf, buflen, file);
2305       return;
2306     }
2307   }
2308   // special case for debian
2309   if (file_exists(&quot;/etc/debian_version&quot;)) {
2310     strncpy(buf, &quot;Debian &quot;, buflen);
2311     if (buflen &gt; 7) {
2312       parse_os_info(&amp;buf[7], buflen-7, &quot;/etc/debian_version&quot;);
2313     }
2314   } else {
2315     strncpy(buf, &quot;Linux&quot;, buflen);
2316   }
2317 }
2318 
2319 void os::Linux::print_libversion_info(outputStream* st) {
2320   // libc, pthread
2321   st-&gt;print(&quot;libc: &quot;);
<span class="line-modified">2322   st-&gt;print(&quot;%s &quot;, os::Linux::glibc_version());</span>
2323   st-&gt;print(&quot;%s &quot;, os::Linux::libpthread_version());
2324   st-&gt;cr();
2325 }
2326 
2327 void os::Linux::print_proc_sys_info(outputStream* st) {
2328   _print_ascii_file_h(&quot;/proc/sys/kernel/threads-max (system-wide limit on the number of threads)&quot;,
2329                       &quot;/proc/sys/kernel/threads-max&quot;, st);
2330   _print_ascii_file_h(&quot;/proc/sys/vm/max_map_count (maximum number of memory map areas a process may have)&quot;,
2331                       &quot;/proc/sys/vm/max_map_count&quot;, st);
2332   _print_ascii_file_h(&quot;/proc/sys/kernel/pid_max (system-wide limit on number of process identifiers)&quot;,
2333                       &quot;/proc/sys/kernel/pid_max&quot;, st);
2334 }
2335 
2336 void os::Linux::print_system_memory_info(outputStream* st) {
2337   _print_ascii_file_h(&quot;/proc/meminfo&quot;, &quot;/proc/meminfo&quot;, st, false);
2338   st-&gt;cr();
2339 
2340   // some information regarding THPs; for details see
2341   // https://www.kernel.org/doc/Documentation/vm/transhuge.txt
2342   _print_ascii_file_h(&quot;/sys/kernel/mm/transparent_hugepage/enabled&quot;,
</pre>
<hr />
<pre>
3253 void os::Linux::sched_getcpu_init() {
3254   // sched_getcpu() should be in libc.
3255   set_sched_getcpu(CAST_TO_FN_PTR(sched_getcpu_func_t,
3256                                   dlsym(RTLD_DEFAULT, &quot;sched_getcpu&quot;)));
3257 
3258   // If it&#39;s not, try a direct syscall.
3259   if (sched_getcpu() == -1) {
3260     set_sched_getcpu(CAST_TO_FN_PTR(sched_getcpu_func_t,
3261                                     (void*)&amp;sched_getcpu_syscall));
3262   }
3263 
3264   if (sched_getcpu() == -1) {
3265     vm_exit_during_initialization(&quot;getcpu(2) system call not supported by kernel&quot;);
3266   }
3267 }
3268 
3269 // Something to do with the numa-aware allocator needs these symbols
3270 extern &quot;C&quot; JNIEXPORT void numa_warn(int number, char *where, ...) { }
3271 extern &quot;C&quot; JNIEXPORT void numa_error(char *where) { }
3272 
<span class="line-removed">3273 static void* dlvsym_if_available(void* handle, const char* name, const char* version) {</span>
<span class="line-removed">3274   typedef void* (*dlvsym_func_type)(void* handle, const char* name, const char* version);</span>
<span class="line-removed">3275   static dlvsym_func_type dlvsym_func;</span>
<span class="line-removed">3276   static bool initialized = false;</span>
<span class="line-removed">3277 </span>
<span class="line-removed">3278   if (!initialized) {</span>
<span class="line-removed">3279     dlvsym_func = (dlvsym_func_type)dlsym(RTLD_NEXT, &quot;dlvsym&quot;);</span>
<span class="line-removed">3280     initialized = true;</span>
<span class="line-removed">3281   }</span>
<span class="line-removed">3282 </span>
<span class="line-removed">3283   if (dlvsym_func != NULL) {</span>
<span class="line-removed">3284     void *f = dlvsym_func(handle, name, version);</span>
<span class="line-removed">3285     if (f != NULL) {</span>
<span class="line-removed">3286       return f;</span>
<span class="line-removed">3287     }</span>
<span class="line-removed">3288   }</span>
<span class="line-removed">3289 </span>
<span class="line-removed">3290   return dlsym(handle, name);</span>
<span class="line-removed">3291 }</span>
<span class="line-removed">3292 </span>
3293 // Handle request to load libnuma symbol version 1.1 (API v1). If it fails
3294 // load symbol from base version instead.
3295 void* os::Linux::libnuma_dlsym(void* handle, const char *name) {
<span class="line-modified">3296   return dlvsym_if_available(handle, name, &quot;libnuma_1.1&quot;);</span>




3297 }
3298 
3299 // Handle request to load libnuma symbol version 1.2 (API v2) only.
3300 // Return NULL if the symbol is not defined in this particular version.
3301 void* os::Linux::libnuma_v2_dlsym(void* handle, const char* name) {
<span class="line-modified">3302   return dlvsym_if_available(handle, name, &quot;libnuma_1.2&quot;);</span>
3303 }
3304 
3305 bool os::Linux::libnuma_init() {
3306   if (sched_getcpu() != -1) { // Requires sched_getcpu() support
3307     void *handle = dlopen(&quot;libnuma.so.1&quot;, RTLD_LAZY);
3308     if (handle != NULL) {
3309       set_numa_node_to_cpus(CAST_TO_FN_PTR(numa_node_to_cpus_func_t,
3310                                            libnuma_dlsym(handle, &quot;numa_node_to_cpus&quot;)));


3311       set_numa_max_node(CAST_TO_FN_PTR(numa_max_node_func_t,
3312                                        libnuma_dlsym(handle, &quot;numa_max_node&quot;)));
3313       set_numa_num_configured_nodes(CAST_TO_FN_PTR(numa_num_configured_nodes_func_t,
3314                                                    libnuma_dlsym(handle, &quot;numa_num_configured_nodes&quot;)));
3315       set_numa_available(CAST_TO_FN_PTR(numa_available_func_t,
3316                                         libnuma_dlsym(handle, &quot;numa_available&quot;)));
3317       set_numa_tonode_memory(CAST_TO_FN_PTR(numa_tonode_memory_func_t,
3318                                             libnuma_dlsym(handle, &quot;numa_tonode_memory&quot;)));
3319       set_numa_interleave_memory(CAST_TO_FN_PTR(numa_interleave_memory_func_t,
3320                                                 libnuma_dlsym(handle, &quot;numa_interleave_memory&quot;)));
3321       set_numa_interleave_memory_v2(CAST_TO_FN_PTR(numa_interleave_memory_v2_func_t,
3322                                                 libnuma_v2_dlsym(handle, &quot;numa_interleave_memory&quot;)));
3323       set_numa_set_bind_policy(CAST_TO_FN_PTR(numa_set_bind_policy_func_t,
3324                                               libnuma_dlsym(handle, &quot;numa_set_bind_policy&quot;)));
3325       set_numa_bitmask_isbitset(CAST_TO_FN_PTR(numa_bitmask_isbitset_func_t,
3326                                                libnuma_dlsym(handle, &quot;numa_bitmask_isbitset&quot;)));
3327       set_numa_distance(CAST_TO_FN_PTR(numa_distance_func_t,
3328                                        libnuma_dlsym(handle, &quot;numa_distance&quot;)));
3329       set_numa_get_membind(CAST_TO_FN_PTR(numa_get_membind_func_t,
3330                                           libnuma_v2_dlsym(handle, &quot;numa_get_membind&quot;)));
</pre>
<hr />
<pre>
3440             }
3441           }
3442         }
3443       }
3444     }
3445   }
3446   FREE_C_HEAP_ARRAY(unsigned long, cpu_map);
3447 }
3448 
3449 int os::Linux::get_node_by_cpu(int cpu_id) {
3450   if (cpu_to_node() != NULL &amp;&amp; cpu_id &gt;= 0 &amp;&amp; cpu_id &lt; cpu_to_node()-&gt;length()) {
3451     return cpu_to_node()-&gt;at(cpu_id);
3452   }
3453   return -1;
3454 }
3455 
3456 GrowableArray&lt;int&gt;* os::Linux::_cpu_to_node;
3457 GrowableArray&lt;int&gt;* os::Linux::_nindex_to_node;
3458 os::Linux::sched_getcpu_func_t os::Linux::_sched_getcpu;
3459 os::Linux::numa_node_to_cpus_func_t os::Linux::_numa_node_to_cpus;

3460 os::Linux::numa_max_node_func_t os::Linux::_numa_max_node;
3461 os::Linux::numa_num_configured_nodes_func_t os::Linux::_numa_num_configured_nodes;
3462 os::Linux::numa_available_func_t os::Linux::_numa_available;
3463 os::Linux::numa_tonode_memory_func_t os::Linux::_numa_tonode_memory;
3464 os::Linux::numa_interleave_memory_func_t os::Linux::_numa_interleave_memory;
3465 os::Linux::numa_interleave_memory_v2_func_t os::Linux::_numa_interleave_memory_v2;
3466 os::Linux::numa_set_bind_policy_func_t os::Linux::_numa_set_bind_policy;
3467 os::Linux::numa_bitmask_isbitset_func_t os::Linux::_numa_bitmask_isbitset;
3468 os::Linux::numa_distance_func_t os::Linux::_numa_distance;
3469 os::Linux::numa_get_membind_func_t os::Linux::_numa_get_membind;
3470 os::Linux::numa_get_interleave_mask_func_t os::Linux::_numa_get_interleave_mask;
3471 os::Linux::numa_move_pages_func_t os::Linux::_numa_move_pages;
3472 os::Linux::numa_set_preferred_func_t os::Linux::_numa_set_preferred;
3473 os::Linux::NumaAllocationPolicy os::Linux::_current_numa_policy;
3474 unsigned long* os::Linux::_numa_all_nodes;
3475 struct bitmask* os::Linux::_numa_all_nodes_ptr;
3476 struct bitmask* os::Linux::_numa_nodes_ptr;
3477 struct bitmask* os::Linux::_numa_interleave_bitmask;
3478 struct bitmask* os::Linux::_numa_membind_bitmask;
3479 
</pre>
<hr />
<pre>
5239     tty-&gt;print(&quot;expected:&quot;);
5240     os::Posix::print_sa_flags(tty, os::Linux::get_our_sigflags(sig));
5241     tty-&gt;cr();
5242     tty-&gt;print(&quot;  found:&quot;);
5243     os::Posix::print_sa_flags(tty, act.sa_flags);
5244     tty-&gt;cr();
5245     // No need to check this sig any longer
5246     sigaddset(&amp;check_signal_done, sig);
5247   }
5248 
5249   // Dump all the signal
5250   if (sigismember(&amp;check_signal_done, sig)) {
5251     print_signal_handlers(tty, buf, O_BUFLEN);
5252   }
5253 }
5254 
5255 extern void report_error(char* file_name, int line_no, char* title,
5256                          char* format, ...);
5257 
5258 // Some linux distributions (notably: Alpine Linux) include the
<span class="line-modified">5259 // grsecurity in the kernel by default. Of particular interest from a</span>
<span class="line-modified">5260 // JVM perspective is PaX (https://pax.grsecurity.net/), which adds</span>
<span class="line-modified">5261 // some security features related to page attributes. Specifically,</span>
<span class="line-removed">5262 // the MPROTECT PaX functionality</span>
5263 // (https://pax.grsecurity.net/docs/mprotect.txt) prevents dynamic
5264 // code generation by disallowing a (previously) writable page to be
5265 // marked as executable. This is, of course, exactly what HotSpot does
5266 // for both JIT compiled method, as well as for stubs, adapters, etc.
5267 //
5268 // Instead of crashing &quot;lazily&quot; when trying to make a page executable,
5269 // this code probes for the presence of PaX and reports the failure
5270 // eagerly.
5271 static void check_pax(void) {
5272   // Zero doesn&#39;t generate code dynamically, so no need to perform the PaX check
5273 #ifndef ZERO
5274   size_t size = os::Linux::page_size();
5275 
5276   void* p = ::mmap(NULL, size, PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
5277   if (p == MAP_FAILED) {

5278     vm_exit_out_of_memory(size, OOM_MMAP_ERROR, &quot;failed to allocate memory for PaX check.&quot;);
5279   }
5280 
5281   int res = ::mprotect(p, size, PROT_WRITE|PROT_EXEC);
5282   if (res == -1) {

5283     vm_exit_during_initialization(&quot;Failed to mark memory page as executable&quot;,
5284                                   &quot;Please check if grsecurity/PaX is enabled in your kernel.\n&quot;
5285                                   &quot;\n&quot;
5286                                   &quot;For example, you can do this by running (note: you may need root privileges):\n&quot;
5287                                   &quot;\n&quot;
5288                                   &quot;    sysctl kernel.pax.softmode\n&quot;
5289                                   &quot;\n&quot;
5290                                   &quot;If PaX is included in the kernel you will see something like this:\n&quot;
5291                                   &quot;\n&quot;
5292                                   &quot;    kernel.pax.softmode = 0\n&quot;
5293                                   &quot;\n&quot;
5294                                   &quot;In particular, if the value is 0 (zero), then PaX is enabled.\n&quot;
5295                                   &quot;\n&quot;
5296                                   &quot;PaX includes security functionality which interferes with the dynamic code\n&quot;
5297                                   &quot;generation the JVM relies on. Specifically, the MPROTECT functionality as\n&quot;
5298                                   &quot;described on https://pax.grsecurity.net/docs/mprotect.txt is not compatible\n&quot;
5299                                   &quot;with the JVM. If you want to allow the JVM to run you will have to disable PaX.\n&quot;
5300                                   &quot;You can do this on a per-executable basis using the paxctl tool, for example:\n&quot;
5301                                   &quot;\n&quot;
5302                                   &quot;    paxctl -cm bin/java\n&quot;
</pre>
<hr />
<pre>
5469   // Check and sets minimum stack sizes against command line options
5470   if (Posix::set_minimum_stack_sizes() == JNI_ERR) {
5471     return JNI_ERR;
5472   }
5473 
5474 #if defined(IA32)
5475   // Need to ensure we&#39;ve determined the process&#39;s initial stack to
5476   // perform the workaround
5477   Linux::capture_initial_stack(JavaThread::stack_size_at_create());
5478   workaround_expand_exec_shield_cs_limit();
5479 #else
5480   suppress_primordial_thread_resolution = Arguments::created_by_java_launcher();
5481   if (!suppress_primordial_thread_resolution) {
5482     Linux::capture_initial_stack(JavaThread::stack_size_at_create());
5483   }
5484 #endif
5485 
5486   Linux::libpthread_init();
5487   Linux::sched_getcpu_init();
5488   log_info(os)(&quot;HotSpot is running with %s, %s&quot;,
<span class="line-modified">5489                Linux::glibc_version(), Linux::libpthread_version());</span>
5490 
5491   if (UseNUMA || UseNUMAInterleaving) {
5492     Linux::numa_init();
5493   }
5494 
5495   if (MaxFDLimit) {
5496     // set the number of file descriptors to max. print out error
5497     // if getrlimit/setrlimit fails but continue regardless.
5498     struct rlimit nbr_files;
5499     int status = getrlimit(RLIMIT_NOFILE, &amp;nbr_files);
5500     if (status != 0) {
5501       log_info(os)(&quot;os::init_2 getrlimit failed: %s&quot;, os::strerror(errno));
5502     } else {
5503       nbr_files.rlim_cur = nbr_files.rlim_max;
5504       status = setrlimit(RLIMIT_NOFILE, &amp;nbr_files);
5505       if (status != 0) {
5506         log_info(os)(&quot;os::init_2 setrlimit failed: %s&quot;, os::strerror(errno));
5507       }
5508     }
5509   }
</pre>
</td>
<td>
<hr />
<pre>
 117   #define _GNU_SOURCE
 118   #include &lt;sched.h&gt;
 119   #undef _GNU_SOURCE
 120 #else
 121   #include &lt;sched.h&gt;
 122 #endif
 123 
 124 // if RUSAGE_THREAD for getrusage() has not been defined, do it here. The code calling
 125 // getrusage() is prepared to handle the associated failure.
 126 #ifndef RUSAGE_THREAD
 127   #define RUSAGE_THREAD   (1)               /* only the calling thread */
 128 #endif
 129 
 130 #define MAX_PATH    (2 * K)
 131 
 132 #define MAX_SECS 100000000
 133 
 134 // for timer info max values which include all bits
 135 #define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)
 136 
<span class="line-added"> 137 #ifdef MUSL_LIBC</span>
<span class="line-added"> 138 // dlvsym is not a part of POSIX</span>
<span class="line-added"> 139 // and musl libc doesn&#39;t implement it.</span>
<span class="line-added"> 140 static void *dlvsym(void *handle,</span>
<span class="line-added"> 141                     const char *symbol,</span>
<span class="line-added"> 142                     const char *version) {</span>
<span class="line-added"> 143    // load the latest version of symbol</span>
<span class="line-added"> 144    return dlsym(handle, symbol);</span>
<span class="line-added"> 145 }</span>
<span class="line-added"> 146 #endif</span>
<span class="line-added"> 147 </span>
 148 enum CoredumpFilterBit {
 149   FILE_BACKED_PVT_BIT = 1 &lt;&lt; 2,
 150   FILE_BACKED_SHARED_BIT = 1 &lt;&lt; 3,
 151   LARGEPAGES_BIT = 1 &lt;&lt; 6,
 152   DAX_SHARED_BIT = 1 &lt;&lt; 8
 153 };
 154 
 155 ////////////////////////////////////////////////////////////////////////////////
 156 // global variables
 157 julong os::Linux::_physical_memory = 0;
 158 
 159 address   os::Linux::_initial_thread_stack_bottom = NULL;
 160 uintptr_t os::Linux::_initial_thread_stack_size   = 0;
 161 
 162 int (*os::Linux::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 163 int (*os::Linux::_pthread_setname_np)(pthread_t, const char*) = NULL;
 164 pthread_t os::Linux::_main_thread;
 165 int os::Linux::_page_size = -1;
 166 bool os::Linux::_supports_fast_thread_cpu_time = false;
<span class="line-modified"> 167 const char * os::Linux::_libc_version = NULL;</span>
<span class="line-modified"> 168 const char * os::Linux::_libpthread_version = NULL;</span>
 169 size_t os::Linux::_default_large_page_size = 0;
 170 
 171 static jlong initial_time_count=0;
 172 
 173 static int clock_tics_per_sec = 100;
 174 
 175 // If the VM might have been created on the primordial thread, we need to resolve the
 176 // primordial thread stack bounds and check if the current thread might be the
 177 // primordial thread in places. If we know that the primordial thread is never used,
 178 // such as when the VM was created by one of the standard java launchers, we can
 179 // avoid this
 180 static bool suppress_primordial_thread_resolution = false;
 181 
 182 // For diagnostics to print a message once. see run_periodic_checks
 183 static sigset_t check_signal_done;
 184 static bool check_signals = true;
 185 
 186 // Signal number used to suspend/resume a thread
 187 
 188 // do not use any signal number less than SIGSEGV, see 4355769
</pre>
<hr />
<pre>
 601     if (thread-&gt;is_VM_thread()) {
 602       // Only the VM thread handles BREAK_SIGNAL ...
 603       pthread_sigmask(SIG_UNBLOCK, vm_signals(), NULL);
 604     } else {
 605       // ... all other threads block BREAK_SIGNAL
 606       pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);
 607     }
 608   }
 609 }
 610 
 611 //////////////////////////////////////////////////////////////////////////////
 612 // detecting pthread library
 613 
 614 void os::Linux::libpthread_init() {
 615   // Save glibc and pthread version strings.
 616 #if !defined(_CS_GNU_LIBC_VERSION) || \
 617     !defined(_CS_GNU_LIBPTHREAD_VERSION)
 618   #error &quot;glibc too old (&lt; 2.3.2)&quot;
 619 #endif
 620 
<span class="line-modified"> 621 #ifdef MUSL_LIBC</span>
<span class="line-modified"> 622   // confstr() from musl libc returns EINVAL for</span>
<span class="line-modified"> 623   // _CS_GNU_LIBC_VERSION and _CS_GNU_LIBPTHREAD_VERSION</span>
<span class="line-modified"> 624   os::Linux::set_libc_version(&quot;unknown&quot;);</span>
<span class="line-modified"> 625   os::Linux::set_libpthread_version(&quot;unknown&quot;);</span>
<span class="line-modified"> 626 #else</span>
<span class="line-modified"> 627   size_t n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);</span>
<span class="line-modified"> 628   assert(n &gt; 0, &quot;cannot retrieve glibc version&quot;);</span>
<span class="line-added"> 629   char *str = (char *)malloc(n, mtInternal);</span>
<span class="line-added"> 630   confstr(_CS_GNU_LIBC_VERSION, str, n);</span>
<span class="line-added"> 631   os::Linux::set_libc_version(str);</span>
 632 
 633   n = confstr(_CS_GNU_LIBPTHREAD_VERSION, NULL, 0);
<span class="line-modified"> 634   assert(n &gt; 0, &quot;cannot retrieve pthread version&quot;);</span>
<span class="line-modified"> 635   str = (char *)malloc(n, mtInternal);</span>
<span class="line-modified"> 636   confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);</span>
<span class="line-modified"> 637   os::Linux::set_libpthread_version(str);</span>
<span class="line-modified"> 638 #endif</span>
 639 }
 640 
 641 /////////////////////////////////////////////////////////////////////////////
 642 // thread stack expansion
 643 
 644 // os::Linux::manually_expand_stack() takes care of expanding the thread
 645 // stack. Note that this is normally not needed: pthread stacks allocate
 646 // thread stack using mmap() without MAP_NORESERVE, so the stack is already
 647 // committed. Therefore it is not necessary to expand the stack manually.
 648 //
 649 // Manually expanding the stack was historically needed on LinuxThreads
 650 // thread stacks, which were allocated with mmap(MAP_GROWSDOWN). Nowadays
 651 // it is kept to deal with very rare corner cases:
 652 //
 653 // For one, user may run the VM on an own implementation of threads
 654 // whose stacks are - like the old LinuxThreads - implemented using
 655 // mmap(MAP_GROWSDOWN).
 656 //
 657 // Also, this coding may be needed if the VM is running on the primordial
 658 // thread. Normally we avoid running on the primordial thread; however,
</pre>
<hr />
<pre>
2316     }
2317     if (file_exists(file)) {
2318       parse_os_info(buf, buflen, file);
2319       return;
2320     }
2321   }
2322   // special case for debian
2323   if (file_exists(&quot;/etc/debian_version&quot;)) {
2324     strncpy(buf, &quot;Debian &quot;, buflen);
2325     if (buflen &gt; 7) {
2326       parse_os_info(&amp;buf[7], buflen-7, &quot;/etc/debian_version&quot;);
2327     }
2328   } else {
2329     strncpy(buf, &quot;Linux&quot;, buflen);
2330   }
2331 }
2332 
2333 void os::Linux::print_libversion_info(outputStream* st) {
2334   // libc, pthread
2335   st-&gt;print(&quot;libc: &quot;);
<span class="line-modified">2336   st-&gt;print(&quot;%s &quot;, os::Linux::libc_version());</span>
2337   st-&gt;print(&quot;%s &quot;, os::Linux::libpthread_version());
2338   st-&gt;cr();
2339 }
2340 
2341 void os::Linux::print_proc_sys_info(outputStream* st) {
2342   _print_ascii_file_h(&quot;/proc/sys/kernel/threads-max (system-wide limit on the number of threads)&quot;,
2343                       &quot;/proc/sys/kernel/threads-max&quot;, st);
2344   _print_ascii_file_h(&quot;/proc/sys/vm/max_map_count (maximum number of memory map areas a process may have)&quot;,
2345                       &quot;/proc/sys/vm/max_map_count&quot;, st);
2346   _print_ascii_file_h(&quot;/proc/sys/kernel/pid_max (system-wide limit on number of process identifiers)&quot;,
2347                       &quot;/proc/sys/kernel/pid_max&quot;, st);
2348 }
2349 
2350 void os::Linux::print_system_memory_info(outputStream* st) {
2351   _print_ascii_file_h(&quot;/proc/meminfo&quot;, &quot;/proc/meminfo&quot;, st, false);
2352   st-&gt;cr();
2353 
2354   // some information regarding THPs; for details see
2355   // https://www.kernel.org/doc/Documentation/vm/transhuge.txt
2356   _print_ascii_file_h(&quot;/sys/kernel/mm/transparent_hugepage/enabled&quot;,
</pre>
<hr />
<pre>
3267 void os::Linux::sched_getcpu_init() {
3268   // sched_getcpu() should be in libc.
3269   set_sched_getcpu(CAST_TO_FN_PTR(sched_getcpu_func_t,
3270                                   dlsym(RTLD_DEFAULT, &quot;sched_getcpu&quot;)));
3271 
3272   // If it&#39;s not, try a direct syscall.
3273   if (sched_getcpu() == -1) {
3274     set_sched_getcpu(CAST_TO_FN_PTR(sched_getcpu_func_t,
3275                                     (void*)&amp;sched_getcpu_syscall));
3276   }
3277 
3278   if (sched_getcpu() == -1) {
3279     vm_exit_during_initialization(&quot;getcpu(2) system call not supported by kernel&quot;);
3280   }
3281 }
3282 
3283 // Something to do with the numa-aware allocator needs these symbols
3284 extern &quot;C&quot; JNIEXPORT void numa_warn(int number, char *where, ...) { }
3285 extern &quot;C&quot; JNIEXPORT void numa_error(char *where) { }
3286 




















3287 // Handle request to load libnuma symbol version 1.1 (API v1). If it fails
3288 // load symbol from base version instead.
3289 void* os::Linux::libnuma_dlsym(void* handle, const char *name) {
<span class="line-modified">3290   void *f = dlvsym(handle, name, &quot;libnuma_1.1&quot;);</span>
<span class="line-added">3291   if (f == NULL) {</span>
<span class="line-added">3292     f = dlsym(handle, name);</span>
<span class="line-added">3293   }</span>
<span class="line-added">3294   return f;</span>
3295 }
3296 
3297 // Handle request to load libnuma symbol version 1.2 (API v2) only.
3298 // Return NULL if the symbol is not defined in this particular version.
3299 void* os::Linux::libnuma_v2_dlsym(void* handle, const char* name) {
<span class="line-modified">3300   return dlvsym(handle, name, &quot;libnuma_1.2&quot;);</span>
3301 }
3302 
3303 bool os::Linux::libnuma_init() {
3304   if (sched_getcpu() != -1) { // Requires sched_getcpu() support
3305     void *handle = dlopen(&quot;libnuma.so.1&quot;, RTLD_LAZY);
3306     if (handle != NULL) {
3307       set_numa_node_to_cpus(CAST_TO_FN_PTR(numa_node_to_cpus_func_t,
3308                                            libnuma_dlsym(handle, &quot;numa_node_to_cpus&quot;)));
<span class="line-added">3309       set_numa_node_to_cpus_v2(CAST_TO_FN_PTR(numa_node_to_cpus_v2_func_t,</span>
<span class="line-added">3310                                               libnuma_v2_dlsym(handle, &quot;numa_node_to_cpus&quot;)));</span>
3311       set_numa_max_node(CAST_TO_FN_PTR(numa_max_node_func_t,
3312                                        libnuma_dlsym(handle, &quot;numa_max_node&quot;)));
3313       set_numa_num_configured_nodes(CAST_TO_FN_PTR(numa_num_configured_nodes_func_t,
3314                                                    libnuma_dlsym(handle, &quot;numa_num_configured_nodes&quot;)));
3315       set_numa_available(CAST_TO_FN_PTR(numa_available_func_t,
3316                                         libnuma_dlsym(handle, &quot;numa_available&quot;)));
3317       set_numa_tonode_memory(CAST_TO_FN_PTR(numa_tonode_memory_func_t,
3318                                             libnuma_dlsym(handle, &quot;numa_tonode_memory&quot;)));
3319       set_numa_interleave_memory(CAST_TO_FN_PTR(numa_interleave_memory_func_t,
3320                                                 libnuma_dlsym(handle, &quot;numa_interleave_memory&quot;)));
3321       set_numa_interleave_memory_v2(CAST_TO_FN_PTR(numa_interleave_memory_v2_func_t,
3322                                                 libnuma_v2_dlsym(handle, &quot;numa_interleave_memory&quot;)));
3323       set_numa_set_bind_policy(CAST_TO_FN_PTR(numa_set_bind_policy_func_t,
3324                                               libnuma_dlsym(handle, &quot;numa_set_bind_policy&quot;)));
3325       set_numa_bitmask_isbitset(CAST_TO_FN_PTR(numa_bitmask_isbitset_func_t,
3326                                                libnuma_dlsym(handle, &quot;numa_bitmask_isbitset&quot;)));
3327       set_numa_distance(CAST_TO_FN_PTR(numa_distance_func_t,
3328                                        libnuma_dlsym(handle, &quot;numa_distance&quot;)));
3329       set_numa_get_membind(CAST_TO_FN_PTR(numa_get_membind_func_t,
3330                                           libnuma_v2_dlsym(handle, &quot;numa_get_membind&quot;)));
</pre>
<hr />
<pre>
3440             }
3441           }
3442         }
3443       }
3444     }
3445   }
3446   FREE_C_HEAP_ARRAY(unsigned long, cpu_map);
3447 }
3448 
3449 int os::Linux::get_node_by_cpu(int cpu_id) {
3450   if (cpu_to_node() != NULL &amp;&amp; cpu_id &gt;= 0 &amp;&amp; cpu_id &lt; cpu_to_node()-&gt;length()) {
3451     return cpu_to_node()-&gt;at(cpu_id);
3452   }
3453   return -1;
3454 }
3455 
3456 GrowableArray&lt;int&gt;* os::Linux::_cpu_to_node;
3457 GrowableArray&lt;int&gt;* os::Linux::_nindex_to_node;
3458 os::Linux::sched_getcpu_func_t os::Linux::_sched_getcpu;
3459 os::Linux::numa_node_to_cpus_func_t os::Linux::_numa_node_to_cpus;
<span class="line-added">3460 os::Linux::numa_node_to_cpus_v2_func_t os::Linux::_numa_node_to_cpus_v2;</span>
3461 os::Linux::numa_max_node_func_t os::Linux::_numa_max_node;
3462 os::Linux::numa_num_configured_nodes_func_t os::Linux::_numa_num_configured_nodes;
3463 os::Linux::numa_available_func_t os::Linux::_numa_available;
3464 os::Linux::numa_tonode_memory_func_t os::Linux::_numa_tonode_memory;
3465 os::Linux::numa_interleave_memory_func_t os::Linux::_numa_interleave_memory;
3466 os::Linux::numa_interleave_memory_v2_func_t os::Linux::_numa_interleave_memory_v2;
3467 os::Linux::numa_set_bind_policy_func_t os::Linux::_numa_set_bind_policy;
3468 os::Linux::numa_bitmask_isbitset_func_t os::Linux::_numa_bitmask_isbitset;
3469 os::Linux::numa_distance_func_t os::Linux::_numa_distance;
3470 os::Linux::numa_get_membind_func_t os::Linux::_numa_get_membind;
3471 os::Linux::numa_get_interleave_mask_func_t os::Linux::_numa_get_interleave_mask;
3472 os::Linux::numa_move_pages_func_t os::Linux::_numa_move_pages;
3473 os::Linux::numa_set_preferred_func_t os::Linux::_numa_set_preferred;
3474 os::Linux::NumaAllocationPolicy os::Linux::_current_numa_policy;
3475 unsigned long* os::Linux::_numa_all_nodes;
3476 struct bitmask* os::Linux::_numa_all_nodes_ptr;
3477 struct bitmask* os::Linux::_numa_nodes_ptr;
3478 struct bitmask* os::Linux::_numa_interleave_bitmask;
3479 struct bitmask* os::Linux::_numa_membind_bitmask;
3480 
</pre>
<hr />
<pre>
5240     tty-&gt;print(&quot;expected:&quot;);
5241     os::Posix::print_sa_flags(tty, os::Linux::get_our_sigflags(sig));
5242     tty-&gt;cr();
5243     tty-&gt;print(&quot;  found:&quot;);
5244     os::Posix::print_sa_flags(tty, act.sa_flags);
5245     tty-&gt;cr();
5246     // No need to check this sig any longer
5247     sigaddset(&amp;check_signal_done, sig);
5248   }
5249 
5250   // Dump all the signal
5251   if (sigismember(&amp;check_signal_done, sig)) {
5252     print_signal_handlers(tty, buf, O_BUFLEN);
5253   }
5254 }
5255 
5256 extern void report_error(char* file_name, int line_no, char* title,
5257                          char* format, ...);
5258 
5259 // Some linux distributions (notably: Alpine Linux) include the
<span class="line-modified">5260 // grsecurity in the kernel. Of particular interest from a JVM perspective</span>
<span class="line-modified">5261 // is PaX (https://pax.grsecurity.net/), which adds some security features</span>
<span class="line-modified">5262 // related to page attributes. Specifically, the MPROTECT PaX functionality</span>

5263 // (https://pax.grsecurity.net/docs/mprotect.txt) prevents dynamic
5264 // code generation by disallowing a (previously) writable page to be
5265 // marked as executable. This is, of course, exactly what HotSpot does
5266 // for both JIT compiled method, as well as for stubs, adapters, etc.
5267 //
5268 // Instead of crashing &quot;lazily&quot; when trying to make a page executable,
5269 // this code probes for the presence of PaX and reports the failure
5270 // eagerly.
5271 static void check_pax(void) {
5272   // Zero doesn&#39;t generate code dynamically, so no need to perform the PaX check
5273 #ifndef ZERO
5274   size_t size = os::Linux::page_size();
5275 
5276   void* p = ::mmap(NULL, size, PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
5277   if (p == MAP_FAILED) {
<span class="line-added">5278     log_debug(os)(&quot;os_linux.cpp: check_pax: mmap failed (%s)&quot; , os::strerror(errno));</span>
5279     vm_exit_out_of_memory(size, OOM_MMAP_ERROR, &quot;failed to allocate memory for PaX check.&quot;);
5280   }
5281 
5282   int res = ::mprotect(p, size, PROT_WRITE|PROT_EXEC);
5283   if (res == -1) {
<span class="line-added">5284     log_debug(os)(&quot;os_linux.cpp: check_pax: mprotect failed (%s)&quot; , os::strerror(errno));</span>
5285     vm_exit_during_initialization(&quot;Failed to mark memory page as executable&quot;,
5286                                   &quot;Please check if grsecurity/PaX is enabled in your kernel.\n&quot;
5287                                   &quot;\n&quot;
5288                                   &quot;For example, you can do this by running (note: you may need root privileges):\n&quot;
5289                                   &quot;\n&quot;
5290                                   &quot;    sysctl kernel.pax.softmode\n&quot;
5291                                   &quot;\n&quot;
5292                                   &quot;If PaX is included in the kernel you will see something like this:\n&quot;
5293                                   &quot;\n&quot;
5294                                   &quot;    kernel.pax.softmode = 0\n&quot;
5295                                   &quot;\n&quot;
5296                                   &quot;In particular, if the value is 0 (zero), then PaX is enabled.\n&quot;
5297                                   &quot;\n&quot;
5298                                   &quot;PaX includes security functionality which interferes with the dynamic code\n&quot;
5299                                   &quot;generation the JVM relies on. Specifically, the MPROTECT functionality as\n&quot;
5300                                   &quot;described on https://pax.grsecurity.net/docs/mprotect.txt is not compatible\n&quot;
5301                                   &quot;with the JVM. If you want to allow the JVM to run you will have to disable PaX.\n&quot;
5302                                   &quot;You can do this on a per-executable basis using the paxctl tool, for example:\n&quot;
5303                                   &quot;\n&quot;
5304                                   &quot;    paxctl -cm bin/java\n&quot;
</pre>
<hr />
<pre>
5471   // Check and sets minimum stack sizes against command line options
5472   if (Posix::set_minimum_stack_sizes() == JNI_ERR) {
5473     return JNI_ERR;
5474   }
5475 
5476 #if defined(IA32)
5477   // Need to ensure we&#39;ve determined the process&#39;s initial stack to
5478   // perform the workaround
5479   Linux::capture_initial_stack(JavaThread::stack_size_at_create());
5480   workaround_expand_exec_shield_cs_limit();
5481 #else
5482   suppress_primordial_thread_resolution = Arguments::created_by_java_launcher();
5483   if (!suppress_primordial_thread_resolution) {
5484     Linux::capture_initial_stack(JavaThread::stack_size_at_create());
5485   }
5486 #endif
5487 
5488   Linux::libpthread_init();
5489   Linux::sched_getcpu_init();
5490   log_info(os)(&quot;HotSpot is running with %s, %s&quot;,
<span class="line-modified">5491                Linux::libc_version(), Linux::libpthread_version());</span>
5492 
5493   if (UseNUMA || UseNUMAInterleaving) {
5494     Linux::numa_init();
5495   }
5496 
5497   if (MaxFDLimit) {
5498     // set the number of file descriptors to max. print out error
5499     // if getrlimit/setrlimit fails but continue regardless.
5500     struct rlimit nbr_files;
5501     int status = getrlimit(RLIMIT_NOFILE, &amp;nbr_files);
5502     if (status != 0) {
5503       log_info(os)(&quot;os::init_2 getrlimit failed: %s&quot;, os::strerror(errno));
5504     } else {
5505       nbr_files.rlim_cur = nbr_files.rlim_max;
5506       status = setrlimit(RLIMIT_NOFILE, &amp;nbr_files);
5507       if (status != 0) {
5508         log_info(os)(&quot;os::init_2 setrlimit failed: %s&quot;, os::strerror(errno));
5509       }
5510     }
5511   }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../make/test/JtregNativeJdk.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_linux.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>