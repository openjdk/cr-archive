<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/RuntimeHelper.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Index_h.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/RuntimeHelper.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  *  published by the Free Software Foundation.  Oracle designates this
  8  *  particular file as subject to the &quot;Classpath&quot; exception as provided
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 
<span class="line-removed"> 27 package jdk.internal.clang.libclang;</span>
 28 // Generated by jextract
 29 



 30 import jdk.incubator.foreign.CSupport;
 31 import jdk.incubator.foreign.ForeignLinker;
 32 import jdk.incubator.foreign.FunctionDescriptor;
 33 import jdk.incubator.foreign.LibraryLookup;
 34 import jdk.incubator.foreign.MemoryAddress;
 35 import jdk.incubator.foreign.MemoryLayout;
 36 import jdk.incubator.foreign.MemorySegment;
 37 
 38 import java.lang.invoke.MethodHandle;
 39 import java.lang.invoke.MethodHandles;
 40 import java.lang.invoke.MethodType;
<span class="line-modified"> 41 import java.nio.file.Files;</span>
<span class="line-modified"> 42 import java.nio.file.Path;</span>
<span class="line-removed"> 43 import java.nio.file.Paths;</span>
 44 import java.util.Arrays;

 45 import java.util.Optional;
 46 


 47 public class RuntimeHelper {
 48 
 49     private final static ForeignLinker ABI = CSupport.getSystemLinker();
 50 
 51     private final static ClassLoader LOADER = RuntimeHelper.class.getClassLoader();
 52 
 53     private final static MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();
 54 
<span class="line-modified"> 55     static final LibraryLookup[] libraries(String[] libNames, String[] libPaths) {</span>
 56         if (libNames.length == 0) {
<span class="line-modified"> 57             return new LibraryLookup[]{LibraryLookup.ofDefault()};</span>
 58         } else {
<span class="line-modified"> 59             Path[] paths = Arrays.stream(libPaths).map(Paths::get).toArray(Path[]::new);</span>
<span class="line-modified"> 60             return Arrays.stream(libNames).map(libName -&gt; {</span>
<span class="line-modified"> 61                 Optional&lt;Path&gt; absPath = findLibraryPath(paths, libName);</span>
<span class="line-modified"> 62                 return absPath.isPresent() ?</span>
<span class="line-modified"> 63                         LibraryLookup.ofPath(absPath.get().toString()) :</span>
<span class="line-modified"> 64                         LibraryLookup.ofLibrary(libName);</span>
<span class="line-modified"> 65             }).toArray(LibraryLookup[]::new);</span>


 66         }
 67     }
 68 
<span class="line-removed"> 69     private static final Optional&lt;Path&gt; findLibraryPath(Path[] paths, String libName) {</span>
<span class="line-removed"> 70         return Arrays.stream(paths).</span>
<span class="line-removed"> 71                 map(p -&gt; p.resolve(System.mapLibraryName(libName))).</span>
<span class="line-removed"> 72                 filter(Files::isRegularFile).map(Path::toAbsolutePath).findFirst();</span>
<span class="line-removed"> 73     }</span>
<span class="line-removed"> 74 </span>
 75     private static final Optional&lt;LibraryLookup.Symbol&gt; lookup(LibraryLookup[] LIBRARIES, String sym) {
 76         for (LibraryLookup l : LIBRARIES) {
 77             try {
 78                 return Optional.of(l.lookup(sym));
 79             } catch (Throwable t) {
 80             }
 81         }
 82         try {
 83             return Optional.of(LibraryLookup.ofDefault().lookup(sym));
 84         } catch (Throwable t) {
 85             return Optional.empty();
 86         }
 87     }
 88 
<span class="line-modified"> 89     public static final MemoryAddress lookupGlobalVariable(LibraryLookup[] LIBRARIES, String name, MemoryLayout layout) {</span>
<span class="line-modified"> 90         return lookup(LIBRARIES, name).map(a -&gt;</span>
<span class="line-modified"> 91             MemorySegment.ofNativeRestricted(</span>
<span class="line-modified"> 92                 a.address(), layout.byteSize(), null, null, a</span>
<span class="line-modified"> 93             ).withAccessModes(MemorySegment.READ | MemorySegment.WRITE).address()).orElse(null);</span>
 94     }
 95 
<span class="line-modified"> 96     public static final MethodHandle downcallHandle(LibraryLookup[] LIBRARIES, String name, String desc, FunctionDescriptor fdesc) {</span>




 97         return lookup(LIBRARIES, name).map(
<span class="line-modified"> 98                 addr -&gt; ABI.downcallHandle(addr,</span>
<span class="line-modified"> 99                                            MethodType.fromMethodDescriptorString(desc, LOADER),</span>
<span class="line-modified">100                                            fdesc)).orElse(null);</span>



101     }
102 
<span class="line-modified">103     public static final MemoryAddress upcallStub(MethodHandle handle, FunctionDescriptor fdesc) {</span>
<span class="line-modified">104         return ABI.upcallStub(handle, fdesc).address();</span>
105     }
106 
<span class="line-modified">107     public static final &lt;Z&gt; MemoryAddress upcallStub(Class&lt;Z&gt; fi, Z z, FunctionDescriptor fdesc, String mtypeDesc) {</span>
108         try {
109             MethodHandle handle = MH_LOOKUP.findVirtual(fi, &quot;apply&quot;,
110                     MethodType.fromMethodDescriptorString(mtypeDesc, LOADER));
111             handle = handle.bindTo(z);
112             return upcallStub(handle, fdesc);
113         } catch (Throwable ex) {
114             throw new AssertionError(ex);
115         }
116     }







































































































































117 }
</pre>
</td>
<td>
<hr />
<pre>
  7  *  published by the Free Software Foundation.  Oracle designates this
  8  *  particular file as subject to the &quot;Classpath&quot; exception as provided
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 

 27 // Generated by jextract
 28 
<span class="line-added"> 29 package jdk.internal.clang.libclang;</span>
<span class="line-added"> 30 </span>
<span class="line-added"> 31 import jdk.incubator.foreign.Addressable;</span>
 32 import jdk.incubator.foreign.CSupport;
 33 import jdk.incubator.foreign.ForeignLinker;
 34 import jdk.incubator.foreign.FunctionDescriptor;
 35 import jdk.incubator.foreign.LibraryLookup;
 36 import jdk.incubator.foreign.MemoryAddress;
 37 import jdk.incubator.foreign.MemoryLayout;
 38 import jdk.incubator.foreign.MemorySegment;
 39 
 40 import java.lang.invoke.MethodHandle;
 41 import java.lang.invoke.MethodHandles;
 42 import java.lang.invoke.MethodType;
<span class="line-modified"> 43 import java.io.File;</span>
<span class="line-modified"> 44 import java.nio.charset.StandardCharsets;</span>

 45 import java.util.Arrays;
<span class="line-added"> 46 import java.util.Objects;</span>
 47 import java.util.Optional;
 48 
<span class="line-added"> 49 import static jdk.incubator.foreign.CSupport.*;</span>
<span class="line-added"> 50 </span>
 51 public class RuntimeHelper {
 52 
 53     private final static ForeignLinker ABI = CSupport.getSystemLinker();
 54 
 55     private final static ClassLoader LOADER = RuntimeHelper.class.getClassLoader();
 56 
 57     private final static MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();
 58 
<span class="line-modified"> 59     static final LibraryLookup[] libraries(String... libNames) {</span>
 60         if (libNames.length == 0) {
<span class="line-modified"> 61             return new LibraryLookup[] { LibraryLookup.ofDefault() };</span>
 62         } else {
<span class="line-modified"> 63             return Arrays.stream(libNames)</span>
<span class="line-modified"> 64                  .map(libName -&gt; {</span>
<span class="line-modified"> 65                       if (libName.indexOf(File.separatorChar) != -1) {</span>
<span class="line-modified"> 66                           return LibraryLookup.ofPath(libName);</span>
<span class="line-modified"> 67                       } else {</span>
<span class="line-modified"> 68                           return LibraryLookup.ofLibrary(libName);</span>
<span class="line-modified"> 69                       }</span>
<span class="line-added"> 70                  })</span>
<span class="line-added"> 71                 .toArray(LibraryLookup[]::new);</span>
 72         }
 73     }
 74 






 75     private static final Optional&lt;LibraryLookup.Symbol&gt; lookup(LibraryLookup[] LIBRARIES, String sym) {
 76         for (LibraryLookup l : LIBRARIES) {
 77             try {
 78                 return Optional.of(l.lookup(sym));
 79             } catch (Throwable t) {
 80             }
 81         }
 82         try {
 83             return Optional.of(LibraryLookup.ofDefault().lookup(sym));
 84         } catch (Throwable t) {
 85             return Optional.empty();
 86         }
 87     }
 88 
<span class="line-modified"> 89     public static final MemorySegment lookupGlobalVariable(LibraryLookup[] LIBRARIES, String name, MemoryLayout layout) {</span>
<span class="line-modified"> 90         return lookup(LIBRARIES, name).map(s -&gt;</span>
<span class="line-modified"> 91             nonCloseableNonTransferableSegment(MemorySegment.ofNativeRestricted(</span>
<span class="line-modified"> 92                  s.address(), layout.byteSize(), null, null, s</span>
<span class="line-modified"> 93             ))).orElse(null);</span>
 94     }
 95 
<span class="line-modified"> 96     public static final MemorySegment nonCloseableNonTransferableSegment(MemorySegment seg) {</span>
<span class="line-added"> 97         return seg.withAccessModes(seg.accessModes() &amp;  ~MemorySegment.CLOSE &amp; ~MemorySegment.HANDOFF);</span>
<span class="line-added"> 98     }</span>
<span class="line-added"> 99 </span>
<span class="line-added">100     public static final MethodHandle downcallHandle(LibraryLookup[] LIBRARIES, String name, String desc, FunctionDescriptor fdesc, boolean variadic) {</span>
101         return lookup(LIBRARIES, name).map(
<span class="line-modified">102                 addr -&gt; {</span>
<span class="line-modified">103                     MethodType mt = MethodType.fromMethodDescriptorString(desc, LOADER);</span>
<span class="line-modified">104                     return variadic ?</span>
<span class="line-added">105                         VarargsInvoker.make(addr, mt, fdesc) :</span>
<span class="line-added">106                         ABI.downcallHandle(addr, mt, fdesc);</span>
<span class="line-added">107                 }).orElse(null);</span>
108     }
109 
<span class="line-modified">110     public static final MemorySegment upcallStub(MethodHandle handle, FunctionDescriptor fdesc) {</span>
<span class="line-modified">111         return ABI.upcallStub(handle, fdesc);</span>
112     }
113 
<span class="line-modified">114     public static final &lt;Z&gt; MemorySegment upcallStub(Class&lt;Z&gt; fi, Z z, FunctionDescriptor fdesc, String mtypeDesc) {</span>
115         try {
116             MethodHandle handle = MH_LOOKUP.findVirtual(fi, &quot;apply&quot;,
117                     MethodType.fromMethodDescriptorString(mtypeDesc, LOADER));
118             handle = handle.bindTo(z);
119             return upcallStub(handle, fdesc);
120         } catch (Throwable ex) {
121             throw new AssertionError(ex);
122         }
123     }
<span class="line-added">124 </span>
<span class="line-added">125     public static MemorySegment asArrayRestricted(MemoryAddress addr, MemoryLayout layout, int numElements) {</span>
<span class="line-added">126         return MemorySegment.ofNativeRestricted(addr, numElements * layout.byteSize(),</span>
<span class="line-added">127                Thread.currentThread(), null, null);</span>
<span class="line-added">128     }</span>
<span class="line-added">129 </span>
<span class="line-added">130     public static MemorySegment asArray(MemorySegment seg, MemoryLayout layout, int numElements) {</span>
<span class="line-added">131         Objects.requireNonNull(seg);</span>
<span class="line-added">132         return seg.asSlice(0L, numElements * layout.byteSize());</span>
<span class="line-added">133     }</span>
<span class="line-added">134 </span>
<span class="line-added">135     private static class VarargsInvoker {</span>
<span class="line-added">136         private static final MethodHandle INVOKE_MH;</span>
<span class="line-added">137         private final Addressable symbol;</span>
<span class="line-added">138         private final MethodType varargs;</span>
<span class="line-added">139         private final FunctionDescriptor function;</span>
<span class="line-added">140 </span>
<span class="line-added">141         private VarargsInvoker(Addressable symbol, MethodType type, FunctionDescriptor function) {</span>
<span class="line-added">142             this.symbol = symbol;</span>
<span class="line-added">143             this.varargs = type;</span>
<span class="line-added">144             this.function = function;</span>
<span class="line-added">145         }</span>
<span class="line-added">146 </span>
<span class="line-added">147         static {</span>
<span class="line-added">148             try {</span>
<span class="line-added">149                 INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, &quot;invoke&quot;, MethodType.methodType(Object.class, Object[].class));</span>
<span class="line-added">150             } catch (ReflectiveOperationException e) {</span>
<span class="line-added">151                 throw new RuntimeException(e);</span>
<span class="line-added">152             }</span>
<span class="line-added">153         }</span>
<span class="line-added">154 </span>
<span class="line-added">155         static MethodHandle make(Addressable symbol, MethodType type, FunctionDescriptor function) {</span>
<span class="line-added">156             VarargsInvoker invoker = new VarargsInvoker(symbol, type, function);</span>
<span class="line-added">157             return INVOKE_MH.bindTo(invoker).asCollector(Object[].class, type.parameterCount())</span>
<span class="line-added">158                     .asType(type);</span>
<span class="line-added">159         }</span>
<span class="line-added">160 </span>
<span class="line-added">161         private Object invoke(Object[] args) throws Throwable {</span>
<span class="line-added">162             // one trailing Object[]</span>
<span class="line-added">163             int nNamedArgs = function.argumentLayouts().size();</span>
<span class="line-added">164             assert(args.length == nNamedArgs + 1);</span>
<span class="line-added">165             // The last argument is the array of vararg collector</span>
<span class="line-added">166             Object[] unnamedArgs = (Object[]) args[args.length - 1];</span>
<span class="line-added">167 </span>
<span class="line-added">168             int argsCount = nNamedArgs + unnamedArgs.length;</span>
<span class="line-added">169             Class&lt;?&gt;[] argTypes = new Class&lt;?&gt;[argsCount];</span>
<span class="line-added">170             MemoryLayout[] argLayouts = new MemoryLayout[nNamedArgs + unnamedArgs.length];</span>
<span class="line-added">171 </span>
<span class="line-added">172             int pos = 0;</span>
<span class="line-added">173             for (pos = 0; pos &lt; nNamedArgs; pos++) {</span>
<span class="line-added">174                 argTypes[pos] = varargs.parameterType(pos);</span>
<span class="line-added">175                 argLayouts[pos] = function.argumentLayouts().get(pos);</span>
<span class="line-added">176             }</span>
<span class="line-added">177 </span>
<span class="line-added">178             assert pos == nNamedArgs;</span>
<span class="line-added">179             for (Object o: unnamedArgs) {</span>
<span class="line-added">180                 argTypes[pos] = normalize(o.getClass());</span>
<span class="line-added">181                 argLayouts[pos] = variadicLayout(argTypes[pos]);</span>
<span class="line-added">182                 pos++;</span>
<span class="line-added">183             }</span>
<span class="line-added">184             assert pos == argsCount;</span>
<span class="line-added">185 </span>
<span class="line-added">186             MethodType mt = MethodType.methodType(varargs.returnType(), argTypes);</span>
<span class="line-added">187             FunctionDescriptor f = (function.returnLayout().isEmpty()) ?</span>
<span class="line-added">188                     FunctionDescriptor.ofVoid(argLayouts) :</span>
<span class="line-added">189                     FunctionDescriptor.of(function.returnLayout().get(), argLayouts);</span>
<span class="line-added">190             MethodHandle mh = ABI.downcallHandle(symbol, mt, f);</span>
<span class="line-added">191             // flatten argument list so that it can be passed to an asSpreader MH</span>
<span class="line-added">192             Object[] allArgs = new Object[nNamedArgs + unnamedArgs.length];</span>
<span class="line-added">193             System.arraycopy(args, 0, allArgs, 0, nNamedArgs);</span>
<span class="line-added">194             System.arraycopy(unnamedArgs, 0, allArgs, nNamedArgs, unnamedArgs.length);</span>
<span class="line-added">195 </span>
<span class="line-added">196             return mh.asSpreader(Object[].class, argsCount).invoke(allArgs);</span>
<span class="line-added">197         }</span>
<span class="line-added">198 </span>
<span class="line-added">199         private static Class&lt;?&gt; unboxIfNeeded(Class&lt;?&gt; clazz) {</span>
<span class="line-added">200             if (clazz == Boolean.class) {</span>
<span class="line-added">201                 return boolean.class;</span>
<span class="line-added">202             } else if (clazz == Void.class) {</span>
<span class="line-added">203                 return void.class;</span>
<span class="line-added">204             } else if (clazz == Byte.class) {</span>
<span class="line-added">205                 return byte.class;</span>
<span class="line-added">206             } else if (clazz == Character.class) {</span>
<span class="line-added">207                 return char.class;</span>
<span class="line-added">208             } else if (clazz == Short.class) {</span>
<span class="line-added">209                 return short.class;</span>
<span class="line-added">210             } else if (clazz == Integer.class) {</span>
<span class="line-added">211                 return int.class;</span>
<span class="line-added">212             } else if (clazz == Long.class) {</span>
<span class="line-added">213                 return long.class;</span>
<span class="line-added">214             } else if (clazz == Float.class) {</span>
<span class="line-added">215                 return float.class;</span>
<span class="line-added">216             } else if (clazz == Double.class) {</span>
<span class="line-added">217                 return double.class;</span>
<span class="line-added">218             } else {</span>
<span class="line-added">219                 return clazz;</span>
<span class="line-added">220             }</span>
<span class="line-added">221         }</span>
<span class="line-added">222 </span>
<span class="line-added">223         private Class&lt;?&gt; promote(Class&lt;?&gt; c) {</span>
<span class="line-added">224             if (c == byte.class || c == char.class || c == short.class || c == int.class) {</span>
<span class="line-added">225                 return long.class;</span>
<span class="line-added">226             } else if (c == float.class) {</span>
<span class="line-added">227                 return double.class;</span>
<span class="line-added">228             } else {</span>
<span class="line-added">229                 return c;</span>
<span class="line-added">230             }</span>
<span class="line-added">231         }</span>
<span class="line-added">232 </span>
<span class="line-added">233         private Class&lt;?&gt; normalize(Class&lt;?&gt; c) {</span>
<span class="line-added">234             c = unboxIfNeeded(c);</span>
<span class="line-added">235             if (c.isPrimitive()) {</span>
<span class="line-added">236                 return promote(c);</span>
<span class="line-added">237             }</span>
<span class="line-added">238             if (MemoryAddress.class.isAssignableFrom(c)) {</span>
<span class="line-added">239                 return MemoryAddress.class;</span>
<span class="line-added">240             }</span>
<span class="line-added">241             if (MemorySegment.class.isAssignableFrom(c)) {</span>
<span class="line-added">242                 return MemorySegment.class;</span>
<span class="line-added">243             }</span>
<span class="line-added">244             throw new IllegalArgumentException(&quot;Invalid type for ABI: &quot; + c.getTypeName());</span>
<span class="line-added">245         }</span>
<span class="line-added">246 </span>
<span class="line-added">247         private MemoryLayout variadicLayout(Class&lt;?&gt; c) {</span>
<span class="line-added">248             if (c == long.class) {</span>
<span class="line-added">249                 return C_LONGLONG;</span>
<span class="line-added">250             } else if (c == double.class) {</span>
<span class="line-added">251                 return C_DOUBLE;</span>
<span class="line-added">252             } else if (MemoryAddress.class.isAssignableFrom(c)) {</span>
<span class="line-added">253                 return C_POINTER;</span>
<span class="line-added">254             } else {</span>
<span class="line-added">255                 throw new IllegalArgumentException(&quot;Unhandled variadic argument class: &quot; + c);</span>
<span class="line-added">256             }</span>
<span class="line-added">257         }</span>
<span class="line-added">258     }</span>
259 }
</pre>
</td>
</tr>
</table>
<center><a href="Index_h.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>