<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/RuntimeHelper.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  *  This code is free software; you can redistribute it and/or modify it
  6  *  under the terms of the GNU General Public License version 2 only, as
  7  *  published by the Free Software Foundation.  Oracle designates this
  8  *  particular file as subject to the &quot;Classpath&quot; exception as provided
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 
 27 // Generated by jextract
 28 
 29 package jdk.internal.clang.libclang;
 30 
 31 import jdk.incubator.foreign.Addressable;
 32 import jdk.incubator.foreign.CSupport;
 33 import jdk.incubator.foreign.ForeignLinker;
 34 import jdk.incubator.foreign.FunctionDescriptor;
 35 import jdk.incubator.foreign.LibraryLookup;
 36 import jdk.incubator.foreign.MemoryAddress;
 37 import jdk.incubator.foreign.MemoryLayout;
 38 import jdk.incubator.foreign.MemorySegment;
 39 
 40 import java.lang.invoke.MethodHandle;
 41 import java.lang.invoke.MethodHandles;
 42 import java.lang.invoke.MethodType;
 43 import java.io.File;
 44 import java.nio.charset.StandardCharsets;
 45 import java.util.Arrays;
 46 import java.util.Objects;
 47 import java.util.Optional;
 48 
 49 import static jdk.incubator.foreign.CSupport.*;
 50 
 51 public class RuntimeHelper {
 52 
 53     private final static ForeignLinker ABI = CSupport.getSystemLinker();
 54 
 55     private final static ClassLoader LOADER = RuntimeHelper.class.getClassLoader();
 56 
 57     private final static MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();
 58 
 59     static final LibraryLookup[] libraries(String... libNames) {
 60         if (libNames.length == 0) {
 61             return new LibraryLookup[] { LibraryLookup.ofDefault() };
 62         } else {
 63             return Arrays.stream(libNames)
 64                  .map(libName -&gt; {
 65                       if (libName.indexOf(File.separatorChar) != -1) {
 66                           return LibraryLookup.ofPath(libName);
 67                       } else {
 68                           return LibraryLookup.ofLibrary(libName);
 69                       }
 70                  })
 71                 .toArray(LibraryLookup[]::new);
 72         }
 73     }
 74 
 75     private static final Optional&lt;LibraryLookup.Symbol&gt; lookup(LibraryLookup[] LIBRARIES, String sym) {
 76         for (LibraryLookup l : LIBRARIES) {
 77             try {
 78                 return Optional.of(l.lookup(sym));
 79             } catch (Throwable t) {
 80             }
 81         }
 82         try {
 83             return Optional.of(LibraryLookup.ofDefault().lookup(sym));
 84         } catch (Throwable t) {
 85             return Optional.empty();
 86         }
 87     }
 88 
 89     public static final MemorySegment lookupGlobalVariable(LibraryLookup[] LIBRARIES, String name, MemoryLayout layout) {
 90         return lookup(LIBRARIES, name).map(s -&gt;
 91             nonCloseableNonTransferableSegment(MemorySegment.ofNativeRestricted(
 92                  s.address(), layout.byteSize(), null, null, s
 93             ))).orElse(null);
 94     }
 95 
 96     public static final MemorySegment nonCloseableNonTransferableSegment(MemorySegment seg) {
 97         return seg.withAccessModes(seg.accessModes() &amp;  ~MemorySegment.CLOSE &amp; ~MemorySegment.HANDOFF);
 98     }
 99 
100     public static final MethodHandle downcallHandle(LibraryLookup[] LIBRARIES, String name, String desc, FunctionDescriptor fdesc, boolean variadic) {
101         return lookup(LIBRARIES, name).map(
102                 addr -&gt; {
103                     MethodType mt = MethodType.fromMethodDescriptorString(desc, LOADER);
104                     return variadic ?
105                         VarargsInvoker.make(addr, mt, fdesc) :
106                         ABI.downcallHandle(addr, mt, fdesc);
107                 }).orElse(null);
108     }
109 
110     public static final MemorySegment upcallStub(MethodHandle handle, FunctionDescriptor fdesc) {
111         return ABI.upcallStub(handle, fdesc);
112     }
113 
114     public static final &lt;Z&gt; MemorySegment upcallStub(Class&lt;Z&gt; fi, Z z, FunctionDescriptor fdesc, String mtypeDesc) {
115         try {
116             MethodHandle handle = MH_LOOKUP.findVirtual(fi, &quot;apply&quot;,
117                     MethodType.fromMethodDescriptorString(mtypeDesc, LOADER));
118             handle = handle.bindTo(z);
119             return upcallStub(handle, fdesc);
120         } catch (Throwable ex) {
121             throw new AssertionError(ex);
122         }
123     }
124 
125     public static MemorySegment asArrayRestricted(MemoryAddress addr, MemoryLayout layout, int numElements) {
126         return MemorySegment.ofNativeRestricted(addr, numElements * layout.byteSize(),
127                Thread.currentThread(), null, null);
128     }
129 
130     public static MemorySegment asArray(MemorySegment seg, MemoryLayout layout, int numElements) {
131         Objects.requireNonNull(seg);
132         return seg.asSlice(0L, numElements * layout.byteSize());
133     }
134 
135     private static class VarargsInvoker {
136         private static final MethodHandle INVOKE_MH;
137         private final Addressable symbol;
138         private final MethodType varargs;
139         private final FunctionDescriptor function;
140 
141         private VarargsInvoker(Addressable symbol, MethodType type, FunctionDescriptor function) {
142             this.symbol = symbol;
143             this.varargs = type;
144             this.function = function;
145         }
146 
147         static {
148             try {
149                 INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, &quot;invoke&quot;, MethodType.methodType(Object.class, Object[].class));
150             } catch (ReflectiveOperationException e) {
151                 throw new RuntimeException(e);
152             }
153         }
154 
155         static MethodHandle make(Addressable symbol, MethodType type, FunctionDescriptor function) {
156             VarargsInvoker invoker = new VarargsInvoker(symbol, type, function);
157             return INVOKE_MH.bindTo(invoker).asCollector(Object[].class, type.parameterCount())
158                     .asType(type);
159         }
160 
161         private Object invoke(Object[] args) throws Throwable {
162             // one trailing Object[]
163             int nNamedArgs = function.argumentLayouts().size();
164             assert(args.length == nNamedArgs + 1);
165             // The last argument is the array of vararg collector
166             Object[] unnamedArgs = (Object[]) args[args.length - 1];
167 
168             int argsCount = nNamedArgs + unnamedArgs.length;
169             Class&lt;?&gt;[] argTypes = new Class&lt;?&gt;[argsCount];
170             MemoryLayout[] argLayouts = new MemoryLayout[nNamedArgs + unnamedArgs.length];
171 
172             int pos = 0;
173             for (pos = 0; pos &lt; nNamedArgs; pos++) {
174                 argTypes[pos] = varargs.parameterType(pos);
175                 argLayouts[pos] = function.argumentLayouts().get(pos);
176             }
177 
178             assert pos == nNamedArgs;
179             for (Object o: unnamedArgs) {
180                 argTypes[pos] = normalize(o.getClass());
181                 argLayouts[pos] = variadicLayout(argTypes[pos]);
182                 pos++;
183             }
184             assert pos == argsCount;
185 
186             MethodType mt = MethodType.methodType(varargs.returnType(), argTypes);
187             FunctionDescriptor f = (function.returnLayout().isEmpty()) ?
188                     FunctionDescriptor.ofVoid(argLayouts) :
189                     FunctionDescriptor.of(function.returnLayout().get(), argLayouts);
190             MethodHandle mh = ABI.downcallHandle(symbol, mt, f);
191             // flatten argument list so that it can be passed to an asSpreader MH
192             Object[] allArgs = new Object[nNamedArgs + unnamedArgs.length];
193             System.arraycopy(args, 0, allArgs, 0, nNamedArgs);
194             System.arraycopy(unnamedArgs, 0, allArgs, nNamedArgs, unnamedArgs.length);
195 
196             return mh.asSpreader(Object[].class, argsCount).invoke(allArgs);
197         }
198 
199         private static Class&lt;?&gt; unboxIfNeeded(Class&lt;?&gt; clazz) {
200             if (clazz == Boolean.class) {
201                 return boolean.class;
202             } else if (clazz == Void.class) {
203                 return void.class;
204             } else if (clazz == Byte.class) {
205                 return byte.class;
206             } else if (clazz == Character.class) {
207                 return char.class;
208             } else if (clazz == Short.class) {
209                 return short.class;
210             } else if (clazz == Integer.class) {
211                 return int.class;
212             } else if (clazz == Long.class) {
213                 return long.class;
214             } else if (clazz == Float.class) {
215                 return float.class;
216             } else if (clazz == Double.class) {
217                 return double.class;
218             } else {
219                 return clazz;
220             }
221         }
222 
223         private Class&lt;?&gt; promote(Class&lt;?&gt; c) {
224             if (c == byte.class || c == char.class || c == short.class || c == int.class) {
225                 return long.class;
226             } else if (c == float.class) {
227                 return double.class;
228             } else {
229                 return c;
230             }
231         }
232 
233         private Class&lt;?&gt; normalize(Class&lt;?&gt; c) {
234             c = unboxIfNeeded(c);
235             if (c.isPrimitive()) {
236                 return promote(c);
237             }
238             if (MemoryAddress.class.isAssignableFrom(c)) {
239                 return MemoryAddress.class;
240             }
241             if (MemorySegment.class.isAssignableFrom(c)) {
242                 return MemorySegment.class;
243             }
244             throw new IllegalArgumentException(&quot;Invalid type for ABI: &quot; + c.getTypeName());
245         }
246 
247         private MemoryLayout variadicLayout(Class&lt;?&gt; c) {
248             if (c == long.class) {
249                 return C_LONGLONG;
250             } else if (c == double.class) {
251                 return C_DOUBLE;
252             } else if (MemoryAddress.class.isAssignableFrom(c)) {
253                 return C_POINTER;
254             } else {
255                 throw new IllegalArgumentException(&quot;Unhandled variadic argument class: &quot; + c);
256             }
257         }
258     }
259 }
    </pre>
  </body>
</html>