<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  *  This code is free software; you can redistribute it and/or modify it
  6  *  under the terms of the GNU General Public License version 2 only, as
  7  *  published by the Free Software Foundation.  Oracle designates this
  8  *  particular file as subject to the &quot;Classpath&quot; exception as provided
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 package jdk.incubator.foreign;
 27 
 28 import jdk.internal.foreign.NativeMemorySegmentImpl;
 29 import jdk.internal.foreign.Utils;
 30 import jdk.internal.foreign.abi.SharedUtils;
 31 
 32 import java.nio.ByteOrder;
 33 import java.nio.charset.Charset;
 34 import java.util.Objects;
 35 import java.util.function.Consumer;
 36 
 37 /**
 38  * A set of utilities for working with libraries using the C language/ABI
 39  */
 40 public class CSupport {
 41     /**
 42      * Obtain a linker that uses the de facto C ABI of the current system to do it&#39;s linking.
 43      * &lt;p&gt;
 44      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
 45      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
 46      * restricted methods, and use safe and supported functionalities, where possible.
 47      * @return a linker for this system.
 48      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
 49      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
 50      */
 51     public static ForeignLinker getSystemLinker() {
 52         Utils.checkRestrictedAccess(&quot;CSupport.getSystemLinker&quot;);
 53         return SharedUtils.getSystemLinker();
 54     }
 55 
 56     /**
 57      * An interface that models a C {@code va_list}.
 58      * &lt;p&gt;
 59      * A va list is a stateful cursor used to iterate over a set of variadic arguments.
 60      * &lt;p&gt;
 61      * Per the C specification (see C standard 6.5.2.2 Function calls - item 6),
 62      * arguments to variadic calls are erased by way of &#39;default argument promotions&#39;,
 63      * which erases integral types by way of integer promotion (see C standard 6.3.1.1 - item 2),
 64      * and which erases all {@code float} arguments to {@code double}.
 65      * &lt;p&gt;
 66      * As such, this interface only supports reading {@code int}, {@code double},
 67      * and any other type that fits into a {@code long}.
 68      */
 69     public interface VaList extends Addressable, AutoCloseable {
 70 
 71         /**
 72          * Reads the next value as an {@code int} and advances this va list&#39;s position.
 73          *
 74          * @param layout the layout of the value
 75          * @return the value read as an {@code int}
 76          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
 77          * (see {@link #close()}).
 78          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code int}
 79          */
 80         int vargAsInt(MemoryLayout layout);
 81 
 82         /**
 83          * Reads the next value as a {@code long} and advances this va list&#39;s position.
 84          *
 85          * @param layout the layout of the value
 86          * @return the value read as an {@code long}
 87          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
 88          * (see {@link #close()}).
 89          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code long}
 90          */
 91         long vargAsLong(MemoryLayout layout);
 92 
 93         /**
 94          * Reads the next value as a {@code double} and advances this va list&#39;s position.
 95          *
 96          * @param layout the layout of the value
 97          * @return the value read as an {@code double}
 98          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
 99          * (see {@link #close()}).
100          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code double}
101          */
102         double vargAsDouble(MemoryLayout layout);
103 
104         /**
105          * Reads the next value as a {@code MemoryAddress} and advances this va list&#39;s position.
106          *
107          * @param layout the layout of the value
108          * @return the value read as an {@code MemoryAddress}
109          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
110          * (see {@link #close()}).
111          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemoryAddress}
112          */
113         MemoryAddress vargAsAddress(MemoryLayout layout);
114 
115         /**
116          * Reads the next value as a {@code MemorySegment}, and advances this va list&#39;s position.
117          * &lt;p&gt;
118          * The memory segment returned by this method will be allocated using
119          * {@link MemorySegment#allocateNative(long, long)}, and will have to be closed separately.
120          *
121          * @param layout the layout of the value
122          * @return the value read as an {@code MemorySegment}
123          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
124          * (see {@link #close()}).
125          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}
126          */
127         MemorySegment vargAsSegment(MemoryLayout layout);
128 
129         /**
130          * Reads the next value as a {@code MemorySegment}, and advances this va list&#39;s position.
131          * &lt;p&gt;
132          * The memory segment returned by this method will be allocated using the given {@code NativeScope}.
133          *
134          * @param layout the layout of the value
135          * @param scope the scope to allocate the segment in
136          * @return the value read as an {@code MemorySegment}
137          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
138          * (see {@link #close()}).
139          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}
140          */
141         MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope);
142 
143         /**
144          * Skips a number of elements with the given memory layouts, and advances this va list&#39;s position.
145          *
146          * @param layouts the layout of the value
147          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
148          * (see {@link #close()}).
149          */
150         void skip(MemoryLayout... layouts);
151 
152         /**
153          * A predicate used to check if the memory associated with the C {@code va_list} modelled
154          * by this instance is still valid to use.
155          *
156          * @return true, if the memory associated with the C {@code va_list} modelled by this instance is still valid
157          * @see #close()
158          */
159         boolean isAlive();
160 
161         /**
162          * Releases the underlying C {@code va_list} modelled by this instance, and any native memory that is attached
163          * to this va list that holds its elements (see {@link VaList#make(Consumer)}).
164          * &lt;p&gt;
165          * After calling this method, {@link #isAlive()} will return {@code false} and further attempts to read values
166          * from this va list will result in an exception.
167          *
168          * @see #isAlive()
169          */
170         void close();
171 
172         /**
173          * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list&#39;s elements
174          * starting from the current position, without affecting the state of the original va list, essentially
175          * allowing the elements to be traversed multiple times.
176          * &lt;p&gt;
177          * If this method needs to allocate native memory for the copy, it will use
178          * {@link MemorySegment#allocateNative(long, long)} to do so. {@link #close()} will have to be called on the
179          * returned va list instance to release the allocated memory.
180          * &lt;p&gt;
181          * This method only copies the va list cursor itself and not the memory that may be attached to the
182          * va list which holds its elements. That means that if this va list was created with the
183          * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its
184          * elements, making the copy unusable.
185          *
186          * @return a copy of this C {@code va_list}.
187          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
188          * (see {@link #close()}).
189          */
190         VaList copy();
191 
192         /**
193          * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list&#39;s elements
194          * starting from the current position, without affecting the state of the original va list, essentially
195          * allowing the elements to be traversed multiple times.
196          * &lt;p&gt;
197          * If this method needs to allocate native memory for the copy, it will use
198          * the given {@code NativeScope} to do so.
199          * &lt;p&gt;
200          * This method only copies the va list cursor itself and not the memory that may be attached to the
201          * va list which holds its elements. That means that if this va list was created with the
202          * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its
203          * elements, making the copy unusable.
204          *
205          * @param scope the scope to allocate the copy in
206          * @return a copy of this C {@code va_list}.
207          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
208          * (see {@link #close()}).
209          */
210         VaList copy(NativeScope scope);
211 
212         /**
213          * Returns the memory address of the C {@code va_list} associated with this instance.
214          *
215          * @return the memory address of the C {@code va_list} associated with this instance.
216          */
217         @Override
218         MemoryAddress address();
219 
220         /**
221          * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list}.
222          *
223          * @param address a memory address pointing to an existing C {@code va_list}.
224          * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.
225          */
226         static VaList ofAddress(MemoryAddress address) {
227             return SharedUtils.newVaListOfAddress(address);
228         }
229 
230         /**
231          * Constructs a new {@code VaList} using a builder (see {@link Builder}).
232          * &lt;p&gt;
233          * If this method needs to allocate native memory for the va list, it will use
234          * {@link MemorySegment#allocateNative(long, long)} to do so.
235          * &lt;p&gt;
236          * This method will allocate native memory to hold the elements in the va list. This memory
237          * will be &#39;attached&#39; to the returned va list instance, and will be released when {@link VaList#close()}
238          * is called.
239          * &lt;p&gt;
240          * Note that when there are no elements added to the created va list,
241          * this method will return the same as {@linkplain #empty()}.
242          *
243          * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements
244          *                of the underlying C {@code va_list}.
245          * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.
246          */
247         static VaList make(Consumer&lt;VaList.Builder&gt; actions) {
248             return SharedUtils.newVaList(actions, MemorySegment::allocateNative);
249         }
250 
251         /**
252          * Constructs a new {@code VaList} using a builder (see {@link Builder}).
253          * &lt;p&gt;
254          * If this method needs to allocate native memory for the va list, it will use
255          * the given {@code NativeScope} to do so.
256          * &lt;p&gt;
257          * This method will allocate native memory to hold the elements in the va list. This memory
258          * will be managed by the given {@code NativeScope}, and will be released when the scope is closed.
259          * &lt;p&gt;
260          * Note that when there are no elements added to the created va list,
261          * this method will return the same as {@linkplain #empty()}.
262          *
263          * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements
264          *                of the underlying C {@code va_list}.
265          * @param scope the scope to be used for the valist allocation.
266          * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.
267          */
268         static VaList make(Consumer&lt;VaList.Builder&gt; actions, NativeScope scope) {
269             return SharedUtils.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
270         }
271 
272         /**
273          * Returns an empty C {@code va_list} constant.
274          * &lt;p&gt;
275          * The returned {@code VaList} can not be closed.
276          *
277          * @return a {@code VaList} modelling an empty C {@code va_list}.
278          */
279         static VaList empty() {
280             return SharedUtils.emptyVaList();
281         }
282 
283         /**
284          * A builder interface used to construct a C {@code va_list}.
285          */
286         interface Builder {
287 
288             /**
289              * Adds a native value represented as an {@code int} to the C {@code va_list} being constructed.
290              *
291              * @param layout the native layout of the value.
292              * @param value the value, represented as an {@code int}.
293              * @return this builder.
294              * @throws IllegalArgumentException if the given memory layout is not compatible with {@code int}
295              */
296             Builder vargFromInt(MemoryLayout layout, int value);
297 
298             /**
299              * Adds a native value represented as a {@code long} to the C {@code va_list} being constructed.
300              *
301              * @param layout the native layout of the value.
302              * @param value the value, represented as a {@code long}.
303              * @return this builder.
304              * @throws IllegalArgumentException if the given memory layout is not compatible with {@code long}
305              */
306             Builder vargFromLong(MemoryLayout layout, long value);
307 
308             /**
309              * Adds a native value represented as a {@code double} to the C {@code va_list} being constructed.
310              *
311              * @param layout the native layout of the value.
312              * @param value the value, represented as a {@code double}.
313              * @return this builder.
314              * @throws IllegalArgumentException if the given memory layout is not compatible with {@code double}
315              */
316             Builder vargFromDouble(MemoryLayout layout, double value);
317 
318             /**
319              * Adds a native value represented as a {@code MemoryAddress} to the C {@code va_list} being constructed.
320              *
321              * @param layout the native layout of the value.
322              * @param value the value, represented as a {@code MemoryAddress}.
323              * @return this builder.
324              * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemoryAddress}
325              */
326             Builder vargFromAddress(MemoryLayout layout, MemoryAddress value);
327 
328             /**
329              * Adds a native value represented as a {@code MemorySegment} to the C {@code va_list} being constructed.
330              *
331              * @param layout the native layout of the value.
332              * @param value the value, represented as a {@code MemorySegment}.
333              * @return this builder.
334              * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}
335              */
336             Builder vargFromSegment(MemoryLayout layout, MemorySegment value);
337         }
338     }
339 
340     /**
341      * The {@code _Bool} native type.
342      */
343     public static final ValueLayout C_BOOL = Utils.pick(SysV.C_BOOL, Win64.C_BOOL, AArch64.C_BOOL);
344     /**
345      * The {@code char} native type.
346      */
347     public static final ValueLayout C_CHAR = Utils.pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);
348     /**
349      * The {@code short} native type.
350      */
351     public static final ValueLayout C_SHORT = Utils.pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);
352     /**
353      * The {@code int} native type.
354      */
355     public static final ValueLayout C_INT = Utils.pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);
356     /**
357      * The {@code long} native type.
358      */
359     public static final ValueLayout C_LONG = Utils.pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);
360     /**
361      * The {@code long long} native type.
362      */
363     public static final ValueLayout C_LONGLONG = Utils.pick(SysV.C_LONGLONG, Win64.C_LONGLONG, AArch64.C_LONGLONG);
364     /**
365      * The {@code float} native type.
366      */
367     public static final ValueLayout C_FLOAT = Utils.pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);
368     /**
369      * The {@code double} native type.
370      */
371     public static final ValueLayout C_DOUBLE = Utils.pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);
372     /**
373      * The {@code long double} native type.
374      */
375     public static final ValueLayout C_LONGDOUBLE = Utils.pick(SysV.C_LONGDOUBLE, Win64.C_LONGDOUBLE, AArch64.C_LONGDOUBLE);
376     /**
377      * The {@code T*} native type.
378      */
379     public static final ValueLayout C_POINTER = Utils.pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);
380 
381     /**
382      * The {@code va_list} native type.
383      */
384     public static final MemoryLayout C_VA_LIST = Utils.pick(SysV.C_VA_LIST, Win64.C_VA_LIST, AArch64.C_VA_LIST);
385 
386     /**
387      * This class defines layout constants modelling standard primitive types supported by the x64 SystemV ABI.
388      */
389     public static final class SysV {
390         private SysV() {
391             //just the one
392         }
393 
394         /**
395          * The name of the SysV linker
396          * @see ForeignLinker#name
397          */
398         public static final String NAME = &quot;SysV&quot;;
399 
400         /**
401          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
402          * attribute value must be an enum constant from {@link ArgumentClass}.
403          */
404         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/sysv/class&quot;;
405 
406         /**
407          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
408          */
409         public enum ArgumentClass {
410             /** Classification constant for integral values */
411             INTEGER,
412             /** Classification constant for floating point values */
413             SSE,
414             /** Classification constant for x87 floating point values */
415             X87,
416             /** Classification constant for {@code complex long double} values */
417             COMPLEX_87,
418             /** Classification constant for machine pointer values */
419             POINTER;
420         }
421 
422         /**
423          * The {@code _Bool} native type.
424          */
425         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
426                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
427 
428         /**
429          * The {@code char} native type.
430          */
431         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
432                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
433 
434         /**
435          * The {@code short} native type.
436          */
437         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
438                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
439 
440         /**
441          * The {@code int} native type.
442          */
443         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
444                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
445 
446         /**
447          * The {@code long} native type.
448          */
449         public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
450                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
451 
452         /**
453          * The {@code long long} native type.
454          */
455         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
456                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
457 
458         /**
459          * The {@code float} native type.
460          */
461         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
462                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
463 
464         /**
465          * The {@code double} native type.
466          */
467         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
468                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
469 
470         /**
471          * The {@code long double} native type.
472          */
473         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
474                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.X87);
475 
476         /**
477          * The {@code complex long double} native type.
478          */
479         public static final GroupLayout C_COMPLEX_LONGDOUBLE = MemoryLayout.ofStruct(C_LONGDOUBLE, C_LONGDOUBLE)
480                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.COMPLEX_87);
481 
482         /**
483          * The {@code T*} native type.
484          */
485         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
486                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
487 
488         /**
489          * The {@code va_list} native type, as it is passed to a function.
490          */
491         public static final MemoryLayout C_VA_LIST = SysV.C_POINTER;
492     }
493 
494     /**
495      * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.
496      */
497     public static final class Win64 {
498 
499         private Win64() {
500             //just the one
501         }
502 
503         /**
504          * The name of the Windows linker
505          * @see ForeignLinker#name
506          */
507         public final static String NAME = &quot;Windows&quot;;
508 
509         /**
510          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used to mark variadic parameters. The
511          * attribute value must be a boolean.
512          */
513         public final static String VARARGS_ATTRIBUTE_NAME = &quot;abi/windows/varargs&quot;;
514 
515         /**
516          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
517          * attribute value must be an enum constant from {@link ArgumentClass}.
518          */
519         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/windows/class&quot;;
520 
521         /**
522          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
523          */
524         public enum ArgumentClass {
525             /** Classification constant for integral values */
526             INTEGER,
527             /** Classification constant for floating point values */
528             FLOAT,
529             /** Classification constant for machine pointer values */
530             POINTER;
531         }
532 
533         /**
534          * The {@code _Bool} native type.
535          */
536         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
537                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
538 
539         /**
540          * The {@code char} native type.
541          */
542         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
543                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
544 
545         /**
546          * The {@code short} native type.
547          */
548         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
549                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
550 
551         /**
552          * The {@code int} native type.
553          */
554         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
555                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
556 
557         /**
558          * The {@code long} native type.
559          */
560         public static final ValueLayout C_LONG = MemoryLayouts.BITS_32_LE
561                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
562 
563         /**
564          * The {@code long long} native type.
565          */
566         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
567                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
568 
569         /**
570          * The {@code float} native type.
571          */
572         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
573                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
574 
575         /**
576          * The {@code double} native type.
577          */
578         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
579                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
580 
581         /**
582          * The {@code long double} native type.
583          */
584         public static final ValueLayout C_LONGDOUBLE = MemoryLayouts.BITS_64_LE
585                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
586 
587         /**
588          * The {@code T*} native type.
589          */
590         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
591                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
592 
593         /**
594          * The {@code va_list} native type, as it is passed to a function.
595          */
596         public static final MemoryLayout C_VA_LIST = Win64.C_POINTER;
597 
598         /**
599          * Return a new memory layout which describes a variadic parameter to be passed to a function.
600          * @param layout the original parameter layout.
601          * @return a layout which is the same as {@code layout}, except for the extra attribute {@link #VARARGS_ATTRIBUTE_NAME},
602          * which is set to {@code true}.
603          */
604         public static ValueLayout asVarArg(ValueLayout layout) {
605             return layout.withAttribute(VARARGS_ATTRIBUTE_NAME, true);
606         }
607     }
608 
609     /**
610      * This class defines layout constants modelling standard primitive types supported by the AArch64 ABI.
611      */
612     public static final class AArch64 {
613 
614         private AArch64() {
615             //just the one
616         }
617 
618         /**
619          * The name of the AArch64 linker
620          * @see ForeignLinker#name
621          */
622         public final static String NAME = &quot;AArch64&quot;;
623 
624         /**
625          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
626          * attribute value must be an enum constant from {@link ArgumentClass}.
627          */
628         public static final String CLASS_ATTRIBUTE_NAME = &quot;abi/aarch64/class&quot;;
629 
630         /**
631          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
632          */
633         public enum ArgumentClass {
634             /** Classification constant for machine integral values */
635             INTEGER,
636             /** Classification constant for machine floating point values */
637             VECTOR,
638             /** Classification constant for machine pointer values */
639             POINTER;
640         }
641 
642         /**
643          * The {@code _Bool} native type.
644          */
645         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
646                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
647 
648         /**
649          * The {@code char} native type.
650          */
651         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
652                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
653 
654         /**
655          * The {@code short} native type.
656          */
657         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
658                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
659 
660         /**
661          * The {@code int} native type.
662          */
663         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
664                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
665 
666         /**
667          * The {@code long} native type.
668          */
669         public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
670                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
671 
672         /**
673          * The {@code long long} native type.
674          */
675         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
676                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
677 
678         /**
679          * The {@code float} native type.
680          */
681         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
682                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
683 
684         /**
685          * The {@code double} native type.
686          */
687         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
688                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
689 
690         /**
691          * The {@code long double} native type.
692          */
693         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
694                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
695 
696         /**
697          * The {@code T*} native type.
698          */
699         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
700                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
701 
702         /**
703          * The {@code va_list} native type, as it is passed to a function.
704          */
705         public static final MemoryLayout C_VA_LIST = AArch64.C_POINTER;
706     }
707 
708     /**
709      * Convert a Java string into a null-terminated C string, using the
710      * platform&#39;s default charset, storing the result into a new native memory segment.
711      * &lt;p&gt;
712      * This method always replaces malformed-input and unmappable-character
713      * sequences with this charset&#39;s default replacement byte array.  The
714      * {@link java.nio.charset.CharsetEncoder} class should be used when more
715      * control over the encoding process is required.
716      *
717      * @param str the Java string to be converted into a C string.
718      * @return a new native memory segment containing the converted C string.
719      * @throws NullPointerException if either {@code str == null}.
720      */
721     public static MemorySegment toCString(String str) {
722         Objects.requireNonNull(str);
723         return toCString(str.getBytes());
724     }
725 
726     /**
727      * Convert a Java string into a null-terminated C string, using the given {@linkplain java.nio.charset.Charset charset},
728      * storing the result into a new native memory segment.
729      * &lt;p&gt;
730      * This method always replaces malformed-input and unmappable-character
731      * sequences with this charset&#39;s default replacement byte array.  The
732      * {@link java.nio.charset.CharsetEncoder} class should be used when more
733      * control over the encoding process is required.
734      *
735      * @param str the Java string to be converted into a C string.
736      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.
737      * @return a new native memory segment containing the converted C string.
738      * @throws NullPointerException if either {@code str == null} or {@code charset == null}.
739      */
740     public static MemorySegment toCString(String str, Charset charset) {
741         Objects.requireNonNull(str);
742         Objects.requireNonNull(charset);
743         return toCString(str.getBytes(charset));
744     }
745 
746     /**
747      * Convert a Java string into a null-terminated C string, using the platform&#39;s default charset,
748      * storing the result into a native memory segment allocated using the provided scope.
749      * &lt;p&gt;
750      * This method always replaces malformed-input and unmappable-character
751      * sequences with this charset&#39;s default replacement byte array.  The
752      * {@link java.nio.charset.CharsetEncoder} class should be used when more
753      * control over the encoding process is required.
754      *
755      * @param str the Java string to be converted into a C string.
756      * @param scope the scope to be used for the native segment allocation.
757      * @return a new native memory segment containing the converted C string.
758      * @throws NullPointerException if either {@code str == null} or {@code scope == null}.
759      */
760     public static MemorySegment toCString(String str, NativeScope scope) {
761         Objects.requireNonNull(str);
762         Objects.requireNonNull(scope);
763         return toCString(str.getBytes(), scope);
764     }
765 
766     /**
767      * Convert a Java string into a null-terminated C string, using the given {@linkplain java.nio.charset.Charset charset},
768      * storing the result into a new native memory segment native memory segment allocated using the provided scope.
769      * &lt;p&gt;
770      * This method always replaces malformed-input and unmappable-character
771      * sequences with this charset&#39;s default replacement byte array.  The
772      * {@link java.nio.charset.CharsetEncoder} class should be used when more
773      * control over the encoding process is required.
774      *
775      * @param str the Java string to be converted into a C string.
776      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.
777      * @param scope the scope to be used for the native segment allocation.
778      * @return a new native memory segment containing the converted C string.
779      * @throws NullPointerException if either {@code str == null}, {@code charset == null} or {@code scope == null}.
780      */
781     public static MemorySegment toCString(String str, Charset charset, NativeScope scope) {
782         Objects.requireNonNull(str);
783         Objects.requireNonNull(charset);
784         Objects.requireNonNull(scope);
785         return toCString(str.getBytes(charset), scope);
786     }
787 
788     /**
789      * Convert a null-terminated C string stored at given address into a Java string, using the platform&#39;s default charset.
790      * &lt;p&gt;
791      * This method always replaces malformed-input and unmappable-character
792      * sequences with this charset&#39;s default replacement string.  The {@link
793      * java.nio.charset.CharsetDecoder} class should be used when more control
794      * over the decoding process is required.
795      * &lt;p&gt;
796      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
797      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
798      * restricted methods, and use safe and supported functionalities, where possible.
799      * @param addr the address at which the string is stored.
800      * @return a Java string with the contents of the null-terminated C string at given address.
801      * @throws NullPointerException if {@code addr == null}
802      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
803      */
804     public static String toJavaStringRestricted(MemoryAddress addr) {
805         Utils.checkRestrictedAccess(&quot;CSupport.toJavaStringRestricted&quot;);
806         return SharedUtils.toJavaStringInternal(NativeMemorySegmentImpl.EVERYTHING, addr.toRawLongValue(), Charset.defaultCharset());
807     }
808 
809     /**
810      * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.
811      * &lt;p&gt;
812      * This method always replaces malformed-input and unmappable-character
813      * sequences with this charset&#39;s default replacement string.  The {@link
814      * java.nio.charset.CharsetDecoder} class should be used when more control
815      * over the decoding process is required.
816      * &lt;p&gt;
817      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
818      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
819      * restricted methods, and use safe and supported functionalities, where possible.
820      * @param addr the address at which the string is stored.
821      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the Java string.
822      * @return a Java string with the contents of the null-terminated C string at given address.
823      * @throws NullPointerException if {@code addr == null}
824      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
825      */
826     public static String toJavaStringRestricted(MemoryAddress addr, Charset charset) {
827         Utils.checkRestrictedAccess(&quot;CSupport.toJavaStringRestricted&quot;);
828         return SharedUtils.toJavaStringInternal(NativeMemorySegmentImpl.EVERYTHING, addr.toRawLongValue(), charset);
829     }
830 
831     /**
832      * Convert a null-terminated C string stored at given address into a Java string, using the platform&#39;s default charset.
833      * &lt;p&gt;
834      * This method always replaces malformed-input and unmappable-character
835      * sequences with this charset&#39;s default replacement string.  The {@link
836      * java.nio.charset.CharsetDecoder} class should be used when more control
837      * over the decoding process is required.
838      * @param addr the address at which the string is stored.
839      * @return a Java string with the contents of the null-terminated C string at given address.
840      * @throws NullPointerException if {@code addr == null}
841      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
842      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
843      * associated with {@code addr}, or if {@code addr} is associated with a segment that is &lt;em&gt;not alive&lt;/em&gt;.
844      */
845     public static String toJavaString(MemorySegment addr) {
846         return SharedUtils.toJavaStringInternal(addr, 0L, Charset.defaultCharset());
847     }
848 
849     /**
850      * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.
851      * &lt;p&gt;
852      * This method always replaces malformed-input and unmappable-character
853      * sequences with this charset&#39;s default replacement string.  The {@link
854      * java.nio.charset.CharsetDecoder} class should be used when more control
855      * over the decoding process is required.
856      * @param addr the address at which the string is stored.
857      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the Java string.
858      * @return a Java string with the contents of the null-terminated C string at given address.
859      * @throws NullPointerException if {@code addr == null}
860      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
861      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
862      * associated with {@code addr}, or if {@code addr} is associated with a segment that is &lt;em&gt;not alive&lt;/em&gt;.
863      */
864     public static String toJavaString(MemorySegment addr, Charset charset) {
865         return SharedUtils.toJavaStringInternal(addr, 0L, charset);
866     }
867 
868     private static void copy(MemorySegment addr, byte[] bytes) {
869         var heapSegment = MemorySegment.ofArray(bytes);
870         addr.copyFrom(heapSegment);
871         MemoryAccess.setByteAtOffset(addr, bytes.length, (byte)0);
872     }
873 
874     private static MemorySegment toCString(byte[] bytes) {
875         MemorySegment segment = MemorySegment.allocateNative(bytes.length + 1, 1L);
876         copy(segment, bytes);
877         return segment;
878     }
879 
880     private static MemorySegment toCString(byte[] bytes, NativeScope scope) {
881         MemorySegment addr = scope.allocate(bytes.length + 1, 1L);
882         copy(addr, bytes);
883         return addr;
884     }
885 
886     /**
887      * Allocate memory of given size using malloc.
888      *
889      * @param size memory size to be allocated
890      * @return addr memory address of the allocated memory
891      */
892     public static MemoryAddress allocateMemoryRestricted(long size) {
893         Utils.checkRestrictedAccess(&quot;CSupport.allocateMemoryRestricted&quot;);
894         return SharedUtils.allocateMemoryInternal(size);
895     }
896 
897     /**
898      * Free the memory pointed by the given memory address.
899      *
900      * @param addr memory address of the native memory to be freed
901      */
902     public static void freeMemoryRestricted(MemoryAddress addr) {
903         Utils.checkRestrictedAccess(&quot;CSupport.freeMemoryRestricted&quot;);
904         SharedUtils.freeMemoryInternal(addr);
905     }
906 }
    </pre>
  </body>
</html>