<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/x86/macroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;asm/assembler.hpp&quot;
  28 #include &quot;asm/assembler.inline.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/barrierSet.hpp&quot;
  31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  32 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;memory/universe.hpp&quot;
  36 #include &quot;oops/accessDecorators.hpp&quot;
  37 #include &quot;oops/compressedOops.inline.hpp&quot;
  38 #include &quot;oops/klass.inline.hpp&quot;
  39 #include &quot;prims/methodHandles.hpp&quot;
  40 #include &quot;runtime/biasedLocking.hpp&quot;
  41 #include &quot;runtime/flags/flagSetting.hpp&quot;
  42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  43 #include &quot;runtime/objectMonitor.hpp&quot;
  44 #include &quot;runtime/os.hpp&quot;
  45 #include &quot;runtime/safepoint.hpp&quot;
  46 #include &quot;runtime/safepointMechanism.hpp&quot;
  47 #include &quot;runtime/sharedRuntime.hpp&quot;
  48 #include &quot;runtime/stubRoutines.hpp&quot;
  49 #include &quot;runtime/thread.hpp&quot;
  50 #include &quot;utilities/macros.hpp&quot;
  51 #include &quot;crc32c.h&quot;
  52 
  53 #ifdef PRODUCT
  54 #define BLOCK_COMMENT(str) /* nothing */
  55 #define STOP(error) stop(error)
  56 #else
  57 #define BLOCK_COMMENT(str) block_comment(str)
  58 #define STOP(error) block_comment(error); stop(error)
  59 #endif
  60 
  61 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  62 
  63 #ifdef ASSERT
  64 bool AbstractAssembler::pd_check_instruction_mark() { return true; }
  65 #endif
  66 
  67 static Assembler::Condition reverse[] = {
  68     Assembler::noOverflow     /* overflow      = 0x0 */ ,
  69     Assembler::overflow       /* noOverflow    = 0x1 */ ,
  70     Assembler::aboveEqual     /* carrySet      = 0x2, below         = 0x2 */ ,
  71     Assembler::below          /* aboveEqual    = 0x3, carryClear    = 0x3 */ ,
  72     Assembler::notZero        /* zero          = 0x4, equal         = 0x4 */ ,
  73     Assembler::zero           /* notZero       = 0x5, notEqual      = 0x5 */ ,
  74     Assembler::above          /* belowEqual    = 0x6 */ ,
  75     Assembler::belowEqual     /* above         = 0x7 */ ,
  76     Assembler::positive       /* negative      = 0x8 */ ,
  77     Assembler::negative       /* positive      = 0x9 */ ,
  78     Assembler::noParity       /* parity        = 0xa */ ,
  79     Assembler::parity         /* noParity      = 0xb */ ,
  80     Assembler::greaterEqual   /* less          = 0xc */ ,
  81     Assembler::less           /* greaterEqual  = 0xd */ ,
  82     Assembler::greater        /* lessEqual     = 0xe */ ,
  83     Assembler::lessEqual      /* greater       = 0xf, */
  84 
  85 };
  86 
  87 
  88 // Implementation of MacroAssembler
  89 
  90 // First all the versions that have distinct versions depending on 32/64 bit
  91 // Unless the difference is trivial (1 line or so).
  92 
  93 #ifndef _LP64
  94 
  95 // 32bit versions
  96 
  97 Address MacroAssembler::as_Address(AddressLiteral adr) {
  98   return Address(adr.target(), adr.rspec());
  99 }
 100 
 101 Address MacroAssembler::as_Address(ArrayAddress adr) {
 102   return Address::make_array(adr);
 103 }
 104 
 105 void MacroAssembler::call_VM_leaf_base(address entry_point,
 106                                        int number_of_arguments) {
 107   call(RuntimeAddress(entry_point));
 108   increment(rsp, number_of_arguments * wordSize);
 109 }
 110 
 111 void MacroAssembler::cmpklass(Address src1, Metadata* obj) {
 112   cmp_literal32(src1, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 113 }
 114 
 115 void MacroAssembler::cmpklass(Register src1, Metadata* obj) {
 116   cmp_literal32(src1, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 117 }
 118 
 119 void MacroAssembler::cmpoop_raw(Address src1, jobject obj) {
 120   cmp_literal32(src1, (int32_t)obj, oop_Relocation::spec_for_immediate());
 121 }
 122 
 123 void MacroAssembler::cmpoop_raw(Register src1, jobject obj) {
 124   cmp_literal32(src1, (int32_t)obj, oop_Relocation::spec_for_immediate());
 125 }
 126 
 127 void MacroAssembler::cmpoop(Address src1, jobject obj) {
 128   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 129   bs-&gt;obj_equals(this, src1, obj);
 130 }
 131 
 132 void MacroAssembler::cmpoop(Register src1, jobject obj) {
 133   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 134   bs-&gt;obj_equals(this, src1, obj);
 135 }
 136 
 137 void MacroAssembler::extend_sign(Register hi, Register lo) {
 138   // According to Intel Doc. AP-526, &quot;Integer Divide&quot;, p.18.
 139   if (VM_Version::is_P6() &amp;&amp; hi == rdx &amp;&amp; lo == rax) {
 140     cdql();
 141   } else {
 142     movl(hi, lo);
 143     sarl(hi, 31);
 144   }
 145 }
 146 
 147 void MacroAssembler::jC2(Register tmp, Label&amp; L) {
 148   // set parity bit if FPU flag C2 is set (via rax)
 149   save_rax(tmp);
 150   fwait(); fnstsw_ax();
 151   sahf();
 152   restore_rax(tmp);
 153   // branch
 154   jcc(Assembler::parity, L);
 155 }
 156 
 157 void MacroAssembler::jnC2(Register tmp, Label&amp; L) {
 158   // set parity bit if FPU flag C2 is set (via rax)
 159   save_rax(tmp);
 160   fwait(); fnstsw_ax();
 161   sahf();
 162   restore_rax(tmp);
 163   // branch
 164   jcc(Assembler::noParity, L);
 165 }
 166 
 167 // 32bit can do a case table jump in one instruction but we no longer allow the base
 168 // to be installed in the Address class
 169 void MacroAssembler::jump(ArrayAddress entry) {
 170   jmp(as_Address(entry));
 171 }
 172 
 173 // Note: y_lo will be destroyed
 174 void MacroAssembler::lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo) {
 175   // Long compare for Java (semantics as described in JVM spec.)
 176   Label high, low, done;
 177 
 178   cmpl(x_hi, y_hi);
 179   jcc(Assembler::less, low);
 180   jcc(Assembler::greater, high);
 181   // x_hi is the return register
 182   xorl(x_hi, x_hi);
 183   cmpl(x_lo, y_lo);
 184   jcc(Assembler::below, low);
 185   jcc(Assembler::equal, done);
 186 
 187   bind(high);
 188   xorl(x_hi, x_hi);
 189   increment(x_hi);
 190   jmp(done);
 191 
 192   bind(low);
 193   xorl(x_hi, x_hi);
 194   decrementl(x_hi);
 195 
 196   bind(done);
 197 }
 198 
 199 void MacroAssembler::lea(Register dst, AddressLiteral src) {
 200     mov_literal32(dst, (int32_t)src.target(), src.rspec());
 201 }
 202 
 203 void MacroAssembler::lea(Address dst, AddressLiteral adr) {
 204   // leal(dst, as_Address(adr));
 205   // see note in movl as to why we must use a move
 206   mov_literal32(dst, (int32_t) adr.target(), adr.rspec());
 207 }
 208 
 209 void MacroAssembler::leave() {
 210   mov(rsp, rbp);
 211   pop(rbp);
 212 }
 213 
 214 void MacroAssembler::lmul(int x_rsp_offset, int y_rsp_offset) {
 215   // Multiplication of two Java long values stored on the stack
 216   // as illustrated below. Result is in rdx:rax.
 217   //
 218   // rsp ---&gt; [  ??  ] \               \
 219   //            ....    | y_rsp_offset  |
 220   //          [ y_lo ] /  (in bytes)    | x_rsp_offset
 221   //          [ y_hi ]                  | (in bytes)
 222   //            ....                    |
 223   //          [ x_lo ]                 /
 224   //          [ x_hi ]
 225   //            ....
 226   //
 227   // Basic idea: lo(result) = lo(x_lo * y_lo)
 228   //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
 229   Address x_hi(rsp, x_rsp_offset + wordSize); Address x_lo(rsp, x_rsp_offset);
 230   Address y_hi(rsp, y_rsp_offset + wordSize); Address y_lo(rsp, y_rsp_offset);
 231   Label quick;
 232   // load x_hi, y_hi and check if quick
 233   // multiplication is possible
 234   movl(rbx, x_hi);
 235   movl(rcx, y_hi);
 236   movl(rax, rbx);
 237   orl(rbx, rcx);                                 // rbx, = 0 &lt;=&gt; x_hi = 0 and y_hi = 0
 238   jcc(Assembler::zero, quick);                   // if rbx, = 0 do quick multiply
 239   // do full multiplication
 240   // 1st step
 241   mull(y_lo);                                    // x_hi * y_lo
 242   movl(rbx, rax);                                // save lo(x_hi * y_lo) in rbx,
 243   // 2nd step
 244   movl(rax, x_lo);
 245   mull(rcx);                                     // x_lo * y_hi
 246   addl(rbx, rax);                                // add lo(x_lo * y_hi) to rbx,
 247   // 3rd step
 248   bind(quick);                                   // note: rbx, = 0 if quick multiply!
 249   movl(rax, x_lo);
 250   mull(y_lo);                                    // x_lo * y_lo
 251   addl(rdx, rbx);                                // correct hi(x_lo * y_lo)
 252 }
 253 
 254 void MacroAssembler::lneg(Register hi, Register lo) {
 255   negl(lo);
 256   adcl(hi, 0);
 257   negl(hi);
 258 }
 259 
 260 void MacroAssembler::lshl(Register hi, Register lo) {
 261   // Java shift left long support (semantics as described in JVM spec., p.305)
 262   // (basic idea for shift counts s &gt;= n: x &lt;&lt; s == (x &lt;&lt; n) &lt;&lt; (s - n))
 263   // shift value is in rcx !
 264   assert(hi != rcx, &quot;must not use rcx&quot;);
 265   assert(lo != rcx, &quot;must not use rcx&quot;);
 266   const Register s = rcx;                        // shift count
 267   const int      n = BitsPerWord;
 268   Label L;
 269   andl(s, 0x3f);                                 // s := s &amp; 0x3f (s &lt; 0x40)
 270   cmpl(s, n);                                    // if (s &lt; n)
 271   jcc(Assembler::less, L);                       // else (s &gt;= n)
 272   movl(hi, lo);                                  // x := x &lt;&lt; n
 273   xorl(lo, lo);
 274   // Note: subl(s, n) is not needed since the Intel shift instructions work rcx mod n!
 275   bind(L);                                       // s (mod n) &lt; n
 276   shldl(hi, lo);                                 // x := x &lt;&lt; s
 277   shll(lo);
 278 }
 279 
 280 
 281 void MacroAssembler::lshr(Register hi, Register lo, bool sign_extension) {
 282   // Java shift right long support (semantics as described in JVM spec., p.306 &amp; p.310)
 283   // (basic idea for shift counts s &gt;= n: x &gt;&gt; s == (x &gt;&gt; n) &gt;&gt; (s - n))
 284   assert(hi != rcx, &quot;must not use rcx&quot;);
 285   assert(lo != rcx, &quot;must not use rcx&quot;);
 286   const Register s = rcx;                        // shift count
 287   const int      n = BitsPerWord;
 288   Label L;
 289   andl(s, 0x3f);                                 // s := s &amp; 0x3f (s &lt; 0x40)
 290   cmpl(s, n);                                    // if (s &lt; n)
 291   jcc(Assembler::less, L);                       // else (s &gt;= n)
 292   movl(lo, hi);                                  // x := x &gt;&gt; n
 293   if (sign_extension) sarl(hi, 31);
 294   else                xorl(hi, hi);
 295   // Note: subl(s, n) is not needed since the Intel shift instructions work rcx mod n!
 296   bind(L);                                       // s (mod n) &lt; n
 297   shrdl(lo, hi);                                 // x := x &gt;&gt; s
 298   if (sign_extension) sarl(hi);
 299   else                shrl(hi);
 300 }
 301 
 302 void MacroAssembler::movoop(Register dst, jobject obj) {
 303   mov_literal32(dst, (int32_t)obj, oop_Relocation::spec_for_immediate());
 304 }
 305 
 306 void MacroAssembler::movoop(Address dst, jobject obj) {
 307   mov_literal32(dst, (int32_t)obj, oop_Relocation::spec_for_immediate());
 308 }
 309 
 310 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
 311   mov_literal32(dst, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 312 }
 313 
 314 void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {
 315   mov_literal32(dst, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 316 }
 317 
 318 void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {
 319   // scratch register is not used,
 320   // it is defined to match parameters of 64-bit version of this method.
 321   if (src.is_lval()) {
 322     mov_literal32(dst, (intptr_t)src.target(), src.rspec());
 323   } else {
 324     movl(dst, as_Address(src));
 325   }
 326 }
 327 
 328 void MacroAssembler::movptr(ArrayAddress dst, Register src) {
 329   movl(as_Address(dst), src);
 330 }
 331 
 332 void MacroAssembler::movptr(Register dst, ArrayAddress src) {
 333   movl(dst, as_Address(src));
 334 }
 335 
 336 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
 337 void MacroAssembler::movptr(Address dst, intptr_t src) {
 338   movl(dst, src);
 339 }
 340 
 341 
 342 void MacroAssembler::pop_callee_saved_registers() {
 343   pop(rcx);
 344   pop(rdx);
 345   pop(rdi);
 346   pop(rsi);
 347 }
 348 
 349 void MacroAssembler::push_callee_saved_registers() {
 350   push(rsi);
 351   push(rdi);
 352   push(rdx);
 353   push(rcx);
 354 }
 355 
 356 void MacroAssembler::pushoop(jobject obj) {
 357   push_literal32((int32_t)obj, oop_Relocation::spec_for_immediate());
 358 }
 359 
 360 void MacroAssembler::pushklass(Metadata* obj) {
 361   push_literal32((int32_t)obj, metadata_Relocation::spec_for_immediate());
 362 }
 363 
 364 void MacroAssembler::pushptr(AddressLiteral src) {
 365   if (src.is_lval()) {
 366     push_literal32((int32_t)src.target(), src.rspec());
 367   } else {
 368     pushl(as_Address(src));
 369   }
 370 }
 371 
 372 void MacroAssembler::set_word_if_not_zero(Register dst) {
 373   xorl(dst, dst);
 374   set_byte_if_not_zero(dst);
 375 }
 376 
 377 static void pass_arg0(MacroAssembler* masm, Register arg) {
 378   masm-&gt;push(arg);
 379 }
 380 
 381 static void pass_arg1(MacroAssembler* masm, Register arg) {
 382   masm-&gt;push(arg);
 383 }
 384 
 385 static void pass_arg2(MacroAssembler* masm, Register arg) {
 386   masm-&gt;push(arg);
 387 }
 388 
 389 static void pass_arg3(MacroAssembler* masm, Register arg) {
 390   masm-&gt;push(arg);
 391 }
 392 
 393 #ifndef PRODUCT
 394 extern &quot;C&quot; void findpc(intptr_t x);
 395 #endif
 396 
 397 void MacroAssembler::debug32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip, char* msg) {
 398   // In order to get locks to work, we need to fake a in_VM state
 399   JavaThread* thread = JavaThread::current();
 400   JavaThreadState saved_state = thread-&gt;thread_state();
 401   thread-&gt;set_thread_state(_thread_in_vm);
 402   if (ShowMessageBoxOnError) {
 403     JavaThread* thread = JavaThread::current();
 404     JavaThreadState saved_state = thread-&gt;thread_state();
 405     thread-&gt;set_thread_state(_thread_in_vm);
 406     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
 407       ttyLocker ttyl;
 408       BytecodeCounter::print();
 409     }
 410     // To see where a verify_oop failed, get $ebx+40/X for this frame.
 411     // This is the value of eip which points to where verify_oop will return.
 412     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
 413       print_state32(rdi, rsi, rbp, rsp, rbx, rdx, rcx, rax, eip);
 414       BREAKPOINT;
 415     }
 416   }
 417   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
 418 }
 419 
 420 void MacroAssembler::print_state32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip) {
 421   ttyLocker ttyl;
 422   FlagSetting fs(Debugging, true);
 423   tty-&gt;print_cr(&quot;eip = 0x%08x&quot;, eip);
 424 #ifndef PRODUCT
 425   if ((WizardMode || Verbose) &amp;&amp; PrintMiscellaneous) {
 426     tty-&gt;cr();
 427     findpc(eip);
 428     tty-&gt;cr();
 429   }
 430 #endif
 431 #define PRINT_REG(rax) \
 432   { tty-&gt;print(&quot;%s = &quot;, #rax); os::print_location(tty, rax); }
 433   PRINT_REG(rax);
 434   PRINT_REG(rbx);
 435   PRINT_REG(rcx);
 436   PRINT_REG(rdx);
 437   PRINT_REG(rdi);
 438   PRINT_REG(rsi);
 439   PRINT_REG(rbp);
 440   PRINT_REG(rsp);
 441 #undef PRINT_REG
 442   // Print some words near top of staack.
 443   int* dump_sp = (int*) rsp;
 444   for (int col1 = 0; col1 &lt; 8; col1++) {
 445     tty-&gt;print(&quot;(rsp+0x%03x) 0x%08x: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 446     os::print_location(tty, *dump_sp++);
 447   }
 448   for (int row = 0; row &lt; 16; row++) {
 449     tty-&gt;print(&quot;(rsp+0x%03x) 0x%08x: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 450     for (int col = 0; col &lt; 8; col++) {
 451       tty-&gt;print(&quot; 0x%08x&quot;, *dump_sp++);
 452     }
 453     tty-&gt;cr();
 454   }
 455   // Print some instructions around pc:
 456   Disassembler::decode((address)eip-64, (address)eip);
 457   tty-&gt;print_cr(&quot;--------&quot;);
 458   Disassembler::decode((address)eip, (address)eip+32);
 459 }
 460 
 461 void MacroAssembler::stop(const char* msg) {
 462   ExternalAddress message((address)msg);
 463   // push address of message
 464   pushptr(message.addr());
 465   { Label L; call(L, relocInfo::none); bind(L); }     // push eip
 466   pusha();                                            // push registers
 467   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug32)));
 468   hlt();
 469 }
 470 
 471 void MacroAssembler::warn(const char* msg) {
 472   push_CPU_state();
 473 
 474   ExternalAddress message((address) msg);
 475   // push address of message
 476   pushptr(message.addr());
 477 
 478   call(RuntimeAddress(CAST_FROM_FN_PTR(address, warning)));
 479   addl(rsp, wordSize);       // discard argument
 480   pop_CPU_state();
 481 }
 482 
 483 void MacroAssembler::print_state() {
 484   { Label L; call(L, relocInfo::none); bind(L); }     // push eip
 485   pusha();                                            // push registers
 486 
 487   push_CPU_state();
 488   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::print_state32)));
 489   pop_CPU_state();
 490 
 491   popa();
 492   addl(rsp, wordSize);
 493 }
 494 
 495 #else // _LP64
 496 
 497 // 64 bit versions
 498 
 499 Address MacroAssembler::as_Address(AddressLiteral adr) {
 500   // amd64 always does this as a pc-rel
 501   // we can be absolute or disp based on the instruction type
 502   // jmp/call are displacements others are absolute
 503   assert(!adr.is_lval(), &quot;must be rval&quot;);
 504   assert(reachable(adr), &quot;must be&quot;);
 505   return Address((int32_t)(intptr_t)(adr.target() - pc()), adr.target(), adr.reloc());
 506 
 507 }
 508 
 509 Address MacroAssembler::as_Address(ArrayAddress adr) {
 510   AddressLiteral base = adr.base();
 511   lea(rscratch1, base);
 512   Address index = adr.index();
 513   assert(index._disp == 0, &quot;must not have disp&quot;); // maybe it can?
 514   Address array(rscratch1, index._index, index._scale, index._disp);
 515   return array;
 516 }
 517 
 518 void MacroAssembler::call_VM_leaf_base(address entry_point, int num_args) {
 519   Label L, E;
 520 
 521 #ifdef _WIN64
 522   // Windows always allocates space for it&#39;s register args
 523   assert(num_args &lt;= 4, &quot;only register arguments supported&quot;);
 524   subq(rsp,  frame::arg_reg_save_area_bytes);
 525 #endif
 526 
 527   // Align stack if necessary
 528   testl(rsp, 15);
 529   jcc(Assembler::zero, L);
 530 
 531   subq(rsp, 8);
 532   {
 533     call(RuntimeAddress(entry_point));
 534   }
 535   addq(rsp, 8);
 536   jmp(E);
 537 
 538   bind(L);
 539   {
 540     call(RuntimeAddress(entry_point));
 541   }
 542 
 543   bind(E);
 544 
 545 #ifdef _WIN64
 546   // restore stack pointer
 547   addq(rsp, frame::arg_reg_save_area_bytes);
 548 #endif
 549 
 550 }
 551 
 552 void MacroAssembler::cmp64(Register src1, AddressLiteral src2) {
 553   assert(!src2.is_lval(), &quot;should use cmpptr&quot;);
 554 
 555   if (reachable(src2)) {
 556     cmpq(src1, as_Address(src2));
 557   } else {
 558     lea(rscratch1, src2);
 559     Assembler::cmpq(src1, Address(rscratch1, 0));
 560   }
 561 }
 562 
 563 int MacroAssembler::corrected_idivq(Register reg) {
 564   // Full implementation of Java ldiv and lrem; checks for special
 565   // case as described in JVM spec., p.243 &amp; p.271.  The function
 566   // returns the (pc) offset of the idivl instruction - may be needed
 567   // for implicit exceptions.
 568   //
 569   //         normal case                           special case
 570   //
 571   // input : rax: dividend                         min_long
 572   //         reg: divisor   (may not be eax/edx)   -1
 573   //
 574   // output: rax: quotient  (= rax idiv reg)       min_long
 575   //         rdx: remainder (= rax irem reg)       0
 576   assert(reg != rax &amp;&amp; reg != rdx, &quot;reg cannot be rax or rdx register&quot;);
 577   static const int64_t min_long = 0x8000000000000000;
 578   Label normal_case, special_case;
 579 
 580   // check for special case
 581   cmp64(rax, ExternalAddress((address) &amp;min_long));
 582   jcc(Assembler::notEqual, normal_case);
 583   xorl(rdx, rdx); // prepare rdx for possible special case (where
 584                   // remainder = 0)
 585   cmpq(reg, -1);
 586   jcc(Assembler::equal, special_case);
 587 
 588   // handle normal case
 589   bind(normal_case);
 590   cdqq();
 591   int idivq_offset = offset();
 592   idivq(reg);
 593 
 594   // normal and special case exit
 595   bind(special_case);
 596 
 597   return idivq_offset;
 598 }
 599 
 600 void MacroAssembler::decrementq(Register reg, int value) {
 601   if (value == min_jint) { subq(reg, value); return; }
 602   if (value &lt;  0) { incrementq(reg, -value); return; }
 603   if (value == 0) {                        ; return; }
 604   if (value == 1 &amp;&amp; UseIncDec) { decq(reg) ; return; }
 605   /* else */      { subq(reg, value)       ; return; }
 606 }
 607 
 608 void MacroAssembler::decrementq(Address dst, int value) {
 609   if (value == min_jint) { subq(dst, value); return; }
 610   if (value &lt;  0) { incrementq(dst, -value); return; }
 611   if (value == 0) {                        ; return; }
 612   if (value == 1 &amp;&amp; UseIncDec) { decq(dst) ; return; }
 613   /* else */      { subq(dst, value)       ; return; }
 614 }
 615 
 616 void MacroAssembler::incrementq(AddressLiteral dst) {
 617   if (reachable(dst)) {
 618     incrementq(as_Address(dst));
 619   } else {
 620     lea(rscratch1, dst);
 621     incrementq(Address(rscratch1, 0));
 622   }
 623 }
 624 
 625 void MacroAssembler::incrementq(Register reg, int value) {
 626   if (value == min_jint) { addq(reg, value); return; }
 627   if (value &lt;  0) { decrementq(reg, -value); return; }
 628   if (value == 0) {                        ; return; }
 629   if (value == 1 &amp;&amp; UseIncDec) { incq(reg) ; return; }
 630   /* else */      { addq(reg, value)       ; return; }
 631 }
 632 
 633 void MacroAssembler::incrementq(Address dst, int value) {
 634   if (value == min_jint) { addq(dst, value); return; }
 635   if (value &lt;  0) { decrementq(dst, -value); return; }
 636   if (value == 0) {                        ; return; }
 637   if (value == 1 &amp;&amp; UseIncDec) { incq(dst) ; return; }
 638   /* else */      { addq(dst, value)       ; return; }
 639 }
 640 
 641 // 32bit can do a case table jump in one instruction but we no longer allow the base
 642 // to be installed in the Address class
 643 void MacroAssembler::jump(ArrayAddress entry) {
 644   lea(rscratch1, entry.base());
 645   Address dispatch = entry.index();
 646   assert(dispatch._base == noreg, &quot;must be&quot;);
 647   dispatch._base = rscratch1;
 648   jmp(dispatch);
 649 }
 650 
 651 void MacroAssembler::lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo) {
 652   ShouldNotReachHere(); // 64bit doesn&#39;t use two regs
 653   cmpq(x_lo, y_lo);
 654 }
 655 
 656 void MacroAssembler::lea(Register dst, AddressLiteral src) {
 657     mov_literal64(dst, (intptr_t)src.target(), src.rspec());
 658 }
 659 
 660 void MacroAssembler::lea(Address dst, AddressLiteral adr) {
 661   mov_literal64(rscratch1, (intptr_t)adr.target(), adr.rspec());
 662   movptr(dst, rscratch1);
 663 }
 664 
 665 void MacroAssembler::leave() {
 666   // %%% is this really better? Why not on 32bit too?
 667   emit_int8((unsigned char)0xC9); // LEAVE
 668 }
 669 
 670 void MacroAssembler::lneg(Register hi, Register lo) {
 671   ShouldNotReachHere(); // 64bit doesn&#39;t use two regs
 672   negq(lo);
 673 }
 674 
 675 void MacroAssembler::movoop(Register dst, jobject obj) {
 676   mov_literal64(dst, (intptr_t)obj, oop_Relocation::spec_for_immediate());
 677 }
 678 
 679 void MacroAssembler::movoop(Address dst, jobject obj) {
 680   mov_literal64(rscratch1, (intptr_t)obj, oop_Relocation::spec_for_immediate());
 681   movq(dst, rscratch1);
 682 }
 683 
 684 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
 685   mov_literal64(dst, (intptr_t)obj, metadata_Relocation::spec_for_immediate());
 686 }
 687 
 688 void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {
 689   mov_literal64(rscratch1, (intptr_t)obj, metadata_Relocation::spec_for_immediate());
 690   movq(dst, rscratch1);
 691 }
 692 
 693 void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {
 694   if (src.is_lval()) {
 695     mov_literal64(dst, (intptr_t)src.target(), src.rspec());
 696   } else {
 697     if (reachable(src)) {
 698       movq(dst, as_Address(src));
 699     } else {
 700       lea(scratch, src);
 701       movq(dst, Address(scratch, 0));
 702     }
 703   }
 704 }
 705 
 706 void MacroAssembler::movptr(ArrayAddress dst, Register src) {
 707   movq(as_Address(dst), src);
 708 }
 709 
 710 void MacroAssembler::movptr(Register dst, ArrayAddress src) {
 711   movq(dst, as_Address(src));
 712 }
 713 
 714 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
 715 void MacroAssembler::movptr(Address dst, intptr_t src) {
 716   mov64(rscratch1, src);
 717   movq(dst, rscratch1);
 718 }
 719 
 720 // These are mostly for initializing NULL
 721 void MacroAssembler::movptr(Address dst, int32_t src) {
 722   movslq(dst, src);
 723 }
 724 
 725 void MacroAssembler::movptr(Register dst, int32_t src) {
 726   mov64(dst, (intptr_t)src);
 727 }
 728 
 729 void MacroAssembler::pushoop(jobject obj) {
 730   movoop(rscratch1, obj);
 731   push(rscratch1);
 732 }
 733 
 734 void MacroAssembler::pushklass(Metadata* obj) {
 735   mov_metadata(rscratch1, obj);
 736   push(rscratch1);
 737 }
 738 
 739 void MacroAssembler::pushptr(AddressLiteral src) {
 740   lea(rscratch1, src);
 741   if (src.is_lval()) {
 742     push(rscratch1);
 743   } else {
 744     pushq(Address(rscratch1, 0));
 745   }
 746 }
 747 
 748 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
 749                                          Register last_java_fp,
 750                                          address  last_java_pc) {
 751   vzeroupper();
 752   // determine last_java_sp register
 753   if (!last_java_sp-&gt;is_valid()) {
 754     last_java_sp = rsp;
 755   }
 756 
 757   // last_java_fp is optional
 758   if (last_java_fp-&gt;is_valid()) {
 759     movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()),
 760            last_java_fp);
 761   }
 762 
 763   // last_java_pc is optional
 764   if (last_java_pc != NULL) {
 765     Address java_pc(r15_thread,
 766                     JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset());
 767     lea(rscratch1, InternalAddress(last_java_pc));
 768     movptr(java_pc, rscratch1);
 769   }
 770 
 771   movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), last_java_sp);
 772 }
 773 
 774 static void pass_arg0(MacroAssembler* masm, Register arg) {
 775   if (c_rarg0 != arg ) {
 776     masm-&gt;mov(c_rarg0, arg);
 777   }
 778 }
 779 
 780 static void pass_arg1(MacroAssembler* masm, Register arg) {
 781   if (c_rarg1 != arg ) {
 782     masm-&gt;mov(c_rarg1, arg);
 783   }
 784 }
 785 
 786 static void pass_arg2(MacroAssembler* masm, Register arg) {
 787   if (c_rarg2 != arg ) {
 788     masm-&gt;mov(c_rarg2, arg);
 789   }
 790 }
 791 
 792 static void pass_arg3(MacroAssembler* masm, Register arg) {
 793   if (c_rarg3 != arg ) {
 794     masm-&gt;mov(c_rarg3, arg);
 795   }
 796 }
 797 
 798 void MacroAssembler::stop(const char* msg) {
 799   if (ShowMessageBoxOnError) {
 800     address rip = pc();
 801     pusha(); // get regs on stack
 802     lea(c_rarg1, InternalAddress(rip));
 803     movq(c_rarg2, rsp); // pass pointer to regs array
 804   }
 805   lea(c_rarg0, ExternalAddress((address) msg));
 806   andq(rsp, -16); // align stack as required by ABI
 807   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug64)));
 808   hlt();
 809 }
 810 
 811 void MacroAssembler::warn(const char* msg) {
 812   push(rbp);
 813   movq(rbp, rsp);
 814   andq(rsp, -16);     // align stack as required by push_CPU_state and call
 815   push_CPU_state();   // keeps alignment at 16 bytes
 816   lea(c_rarg0, ExternalAddress((address) msg));
 817   lea(rax, ExternalAddress(CAST_FROM_FN_PTR(address, warning)));
 818   call(rax);
 819   pop_CPU_state();
 820   mov(rsp, rbp);
 821   pop(rbp);
 822 }
 823 
 824 void MacroAssembler::print_state() {
 825   address rip = pc();
 826   pusha();            // get regs on stack
 827   push(rbp);
 828   movq(rbp, rsp);
 829   andq(rsp, -16);     // align stack as required by push_CPU_state and call
 830   push_CPU_state();   // keeps alignment at 16 bytes
 831 
 832   lea(c_rarg0, InternalAddress(rip));
 833   lea(c_rarg1, Address(rbp, wordSize)); // pass pointer to regs array
 834   call_VM_leaf(CAST_FROM_FN_PTR(address, MacroAssembler::print_state64), c_rarg0, c_rarg1);
 835 
 836   pop_CPU_state();
 837   mov(rsp, rbp);
 838   pop(rbp);
 839   popa();
 840 }
 841 
 842 #ifndef PRODUCT
 843 extern &quot;C&quot; void findpc(intptr_t x);
 844 #endif
 845 
 846 void MacroAssembler::debug64(char* msg, int64_t pc, int64_t regs[]) {
 847   // In order to get locks to work, we need to fake a in_VM state
 848   if (ShowMessageBoxOnError) {
 849     JavaThread* thread = JavaThread::current();
 850     JavaThreadState saved_state = thread-&gt;thread_state();
 851     thread-&gt;set_thread_state(_thread_in_vm);
 852 #ifndef PRODUCT
 853     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
 854       ttyLocker ttyl;
 855       BytecodeCounter::print();
 856     }
 857 #endif
 858     // To see where a verify_oop failed, get $ebx+40/X for this frame.
 859     // XXX correct this offset for amd64
 860     // This is the value of eip which points to where verify_oop will return.
 861     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
 862       print_state64(pc, regs);
 863       BREAKPOINT;
 864     }
 865   }
 866   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
 867 }
 868 
 869 void MacroAssembler::print_state64(int64_t pc, int64_t regs[]) {
 870   ttyLocker ttyl;
 871   FlagSetting fs(Debugging, true);
 872   tty-&gt;print_cr(&quot;rip = 0x%016lx&quot;, (intptr_t)pc);
 873 #ifndef PRODUCT
 874   tty-&gt;cr();
 875   findpc(pc);
 876   tty-&gt;cr();
 877 #endif
 878 #define PRINT_REG(rax, value) \
 879   { tty-&gt;print(&quot;%s = &quot;, #rax); os::print_location(tty, value); }
 880   PRINT_REG(rax, regs[15]);
 881   PRINT_REG(rbx, regs[12]);
 882   PRINT_REG(rcx, regs[14]);
 883   PRINT_REG(rdx, regs[13]);
 884   PRINT_REG(rdi, regs[8]);
 885   PRINT_REG(rsi, regs[9]);
 886   PRINT_REG(rbp, regs[10]);
 887   // rsp is actually not stored by pusha(), compute the old rsp from regs (rsp after pusha): regs + 16 = old rsp
 888   PRINT_REG(rsp, (intptr_t)(&amp;regs[16]));
 889   PRINT_REG(r8 , regs[7]);
 890   PRINT_REG(r9 , regs[6]);
 891   PRINT_REG(r10, regs[5]);
 892   PRINT_REG(r11, regs[4]);
 893   PRINT_REG(r12, regs[3]);
 894   PRINT_REG(r13, regs[2]);
 895   PRINT_REG(r14, regs[1]);
 896   PRINT_REG(r15, regs[0]);
 897 #undef PRINT_REG
 898   // Print some words near the top of the stack.
 899   int64_t* rsp = &amp;regs[16];
 900   int64_t* dump_sp = rsp;
 901   for (int col1 = 0; col1 &lt; 8; col1++) {
 902     tty-&gt;print(&quot;(rsp+0x%03x) 0x%016lx: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 903     os::print_location(tty, *dump_sp++);
 904   }
 905   for (int row = 0; row &lt; 25; row++) {
 906     tty-&gt;print(&quot;(rsp+0x%03x) 0x%016lx: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 907     for (int col = 0; col &lt; 4; col++) {
 908       tty-&gt;print(&quot; 0x%016lx&quot;, (intptr_t)*dump_sp++);
 909     }
 910     tty-&gt;cr();
 911   }
 912   // Print some instructions around pc:
 913   Disassembler::decode((address)pc-64, (address)pc);
 914   tty-&gt;print_cr(&quot;--------&quot;);
 915   Disassembler::decode((address)pc, (address)pc+32);
 916 }
 917 
 918 #endif // _LP64
 919 
 920 // Now versions that are common to 32/64 bit
 921 
 922 void MacroAssembler::addptr(Register dst, int32_t imm32) {
 923   LP64_ONLY(addq(dst, imm32)) NOT_LP64(addl(dst, imm32));
 924 }
 925 
 926 void MacroAssembler::addptr(Register dst, Register src) {
 927   LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src));
 928 }
 929 
 930 void MacroAssembler::addptr(Address dst, Register src) {
 931   LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src));
 932 }
 933 
 934 void MacroAssembler::addsd(XMMRegister dst, AddressLiteral src) {
 935   if (reachable(src)) {
 936     Assembler::addsd(dst, as_Address(src));
 937   } else {
 938     lea(rscratch1, src);
 939     Assembler::addsd(dst, Address(rscratch1, 0));
 940   }
 941 }
 942 
 943 void MacroAssembler::addss(XMMRegister dst, AddressLiteral src) {
 944   if (reachable(src)) {
 945     addss(dst, as_Address(src));
 946   } else {
 947     lea(rscratch1, src);
 948     addss(dst, Address(rscratch1, 0));
 949   }
 950 }
 951 
 952 void MacroAssembler::addpd(XMMRegister dst, AddressLiteral src) {
 953   if (reachable(src)) {
 954     Assembler::addpd(dst, as_Address(src));
 955   } else {
 956     lea(rscratch1, src);
 957     Assembler::addpd(dst, Address(rscratch1, 0));
 958   }
 959 }
 960 
 961 void MacroAssembler::align(int modulus) {
 962   align(modulus, offset());
 963 }
 964 
 965 void MacroAssembler::align(int modulus, int target) {
 966   if (target % modulus != 0) {
 967     nop(modulus - (target % modulus));
 968   }
 969 }
 970 
 971 void MacroAssembler::andpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
 972   // Used in sign-masking with aligned address.
 973   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
 974   if (reachable(src)) {
 975     Assembler::andpd(dst, as_Address(src));
 976   } else {
 977     lea(scratch_reg, src);
 978     Assembler::andpd(dst, Address(scratch_reg, 0));
 979   }
 980 }
 981 
 982 void MacroAssembler::andps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
 983   // Used in sign-masking with aligned address.
 984   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
 985   if (reachable(src)) {
 986     Assembler::andps(dst, as_Address(src));
 987   } else {
 988     lea(scratch_reg, src);
 989     Assembler::andps(dst, Address(scratch_reg, 0));
 990   }
 991 }
 992 
 993 void MacroAssembler::andptr(Register dst, int32_t imm32) {
 994   LP64_ONLY(andq(dst, imm32)) NOT_LP64(andl(dst, imm32));
 995 }
 996 
 997 void MacroAssembler::atomic_incl(Address counter_addr) {
 998   lock();
 999   incrementl(counter_addr);
1000 }
1001 
1002 void MacroAssembler::atomic_incl(AddressLiteral counter_addr, Register scr) {
1003   if (reachable(counter_addr)) {
1004     atomic_incl(as_Address(counter_addr));
1005   } else {
1006     lea(scr, counter_addr);
1007     atomic_incl(Address(scr, 0));
1008   }
1009 }
1010 
1011 #ifdef _LP64
1012 void MacroAssembler::atomic_incq(Address counter_addr) {
1013   lock();
1014   incrementq(counter_addr);
1015 }
1016 
1017 void MacroAssembler::atomic_incq(AddressLiteral counter_addr, Register scr) {
1018   if (reachable(counter_addr)) {
1019     atomic_incq(as_Address(counter_addr));
1020   } else {
1021     lea(scr, counter_addr);
1022     atomic_incq(Address(scr, 0));
1023   }
1024 }
1025 #endif
1026 
1027 // Writes to stack successive pages until offset reached to check for
1028 // stack overflow + shadow pages.  This clobbers tmp.
1029 void MacroAssembler::bang_stack_size(Register size, Register tmp) {
1030   movptr(tmp, rsp);
1031   // Bang stack for total size given plus shadow page size.
1032   // Bang one page at a time because large size can bang beyond yellow and
1033   // red zones.
1034   Label loop;
1035   bind(loop);
1036   movl(Address(tmp, (-os::vm_page_size())), size );
1037   subptr(tmp, os::vm_page_size());
1038   subl(size, os::vm_page_size());
1039   jcc(Assembler::greater, loop);
1040 
1041   // Bang down shadow pages too.
1042   // At this point, (tmp-0) is the last address touched, so don&#39;t
1043   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
1044   // was post-decremented.)  Skip this address by starting at i=1, and
1045   // touch a few more pages below.  N.B.  It is important to touch all
1046   // the way down including all pages in the shadow zone.
1047   for (int i = 1; i &lt; ((int)JavaThread::stack_shadow_zone_size() / os::vm_page_size()); i++) {
1048     // this could be any sized move but this is can be a debugging crumb
1049     // so the bigger the better.
1050     movptr(Address(tmp, (-i*os::vm_page_size())), size );
1051   }
1052 }
1053 
1054 void MacroAssembler::reserved_stack_check() {
1055     // testing if reserved zone needs to be enabled
1056     Label no_reserved_zone_enabling;
1057     Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);
1058     NOT_LP64(get_thread(rsi);)
1059 
1060     cmpptr(rsp, Address(thread, JavaThread::reserved_stack_activation_offset()));
1061     jcc(Assembler::below, no_reserved_zone_enabling);
1062 
1063     call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone), thread);
1064     jump(RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));
1065     should_not_reach_here();
1066 
1067     bind(no_reserved_zone_enabling);
1068 }
1069 
1070 int MacroAssembler::biased_locking_enter(Register lock_reg,
1071                                          Register obj_reg,
1072                                          Register swap_reg,
1073                                          Register tmp_reg,
1074                                          Register tmp_reg2,
1075                                          bool swap_reg_contains_mark,
1076                                          Label&amp; done,
1077                                          Label* slow_case,
1078                                          BiasedLockingCounters* counters) {
1079   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
1080   assert(swap_reg == rax, &quot;swap_reg must be rax for cmpxchgq&quot;);
1081   assert(tmp_reg != noreg, &quot;tmp_reg must be supplied&quot;);
1082   assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg);
1083   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);
1084   Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());
1085   NOT_LP64( Address saved_mark_addr(lock_reg, 0); )
1086 
1087   if (PrintBiasedLockingStatistics &amp;&amp; counters == NULL) {
1088     counters = BiasedLocking::counters();
1089   }
1090   // Biased locking
1091   // See whether the lock is currently biased toward our thread and
1092   // whether the epoch is still valid
1093   // Note that the runtime guarantees sufficient alignment of JavaThread
1094   // pointers to allow age to be placed into low bits
1095   // First check to see whether biasing is even enabled for this object
1096   Label cas_label;
1097   int null_check_offset = -1;
1098   if (!swap_reg_contains_mark) {
1099     null_check_offset = offset();
1100     movptr(swap_reg, mark_addr);
1101   }
1102   movptr(tmp_reg, swap_reg);
1103   andptr(tmp_reg, markWord::biased_lock_mask_in_place);
1104   cmpptr(tmp_reg, markWord::biased_lock_pattern);
1105   jcc(Assembler::notEqual, cas_label);
1106   // The bias pattern is present in the object&#39;s header. Need to check
1107   // whether the bias owner and the epoch are both still current.
1108 #ifndef _LP64
1109   // Note that because there is no current thread register on x86_32 we
1110   // need to store off the mark word we read out of the object to
1111   // avoid reloading it and needing to recheck invariants below. This
1112   // store is unfortunate but it makes the overall code shorter and
1113   // simpler.
1114   movptr(saved_mark_addr, swap_reg);
1115 #endif
1116   if (swap_reg_contains_mark) {
1117     null_check_offset = offset();
1118   }
1119   load_prototype_header(tmp_reg, obj_reg, tmp_reg2);
1120 #ifdef _LP64
1121   orptr(tmp_reg, r15_thread);
1122   xorptr(tmp_reg, swap_reg);
1123   Register header_reg = tmp_reg;
1124 #else
1125   xorptr(tmp_reg, swap_reg);
1126   get_thread(swap_reg);
1127   xorptr(swap_reg, tmp_reg);
1128   Register header_reg = swap_reg;
1129 #endif
1130   andptr(header_reg, ~((int) markWord::age_mask_in_place));
1131   if (counters != NULL) {
1132     cond_inc32(Assembler::zero,
1133                ExternalAddress((address) counters-&gt;biased_lock_entry_count_addr()));
1134   }
1135   jcc(Assembler::equal, done);
1136 
1137   Label try_revoke_bias;
1138   Label try_rebias;
1139 
1140   // At this point we know that the header has the bias pattern and
1141   // that we are not the bias owner in the current epoch. We need to
1142   // figure out more details about the state of the header in order to
1143   // know what operations can be legally performed on the object&#39;s
1144   // header.
1145 
1146   // If the low three bits in the xor result aren&#39;t clear, that means
1147   // the prototype header is no longer biased and we have to revoke
1148   // the bias on this object.
1149   testptr(header_reg, markWord::biased_lock_mask_in_place);
1150   jccb(Assembler::notZero, try_revoke_bias);
1151 
1152   // Biasing is still enabled for this data type. See whether the
1153   // epoch of the current bias is still valid, meaning that the epoch
1154   // bits of the mark word are equal to the epoch bits of the
1155   // prototype header. (Note that the prototype header&#39;s epoch bits
1156   // only change at a safepoint.) If not, attempt to rebias the object
1157   // toward the current thread. Note that we must be absolutely sure
1158   // that the current epoch is invalid in order to do this because
1159   // otherwise the manipulations it performs on the mark word are
1160   // illegal.
1161   testptr(header_reg, markWord::epoch_mask_in_place);
1162   jccb(Assembler::notZero, try_rebias);
1163 
1164   // The epoch of the current bias is still valid but we know nothing
1165   // about the owner; it might be set or it might be clear. Try to
1166   // acquire the bias of the object using an atomic operation. If this
1167   // fails we will go in to the runtime to revoke the object&#39;s bias.
1168   // Note that we first construct the presumed unbiased header so we
1169   // don&#39;t accidentally blow away another thread&#39;s valid bias.
1170   NOT_LP64( movptr(swap_reg, saved_mark_addr); )
1171   andptr(swap_reg,
1172          markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);
1173 #ifdef _LP64
1174   movptr(tmp_reg, swap_reg);
1175   orptr(tmp_reg, r15_thread);
1176 #else
1177   get_thread(tmp_reg);
1178   orptr(tmp_reg, swap_reg);
1179 #endif
1180   lock();
1181   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1182   // If the biasing toward our thread failed, this means that
1183   // another thread succeeded in biasing it toward itself and we
1184   // need to revoke that bias. The revocation will occur in the
1185   // interpreter runtime in the slow case.
1186   if (counters != NULL) {
1187     cond_inc32(Assembler::zero,
1188                ExternalAddress((address) counters-&gt;anonymously_biased_lock_entry_count_addr()));
1189   }
1190   if (slow_case != NULL) {
1191     jcc(Assembler::notZero, *slow_case);
1192   }
1193   jmp(done);
1194 
1195   bind(try_rebias);
1196   // At this point we know the epoch has expired, meaning that the
1197   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
1198   // circumstances _only_, we are allowed to use the current header&#39;s
1199   // value as the comparison value when doing the cas to acquire the
1200   // bias in the current epoch. In other words, we allow transfer of
1201   // the bias from one thread to another directly in this situation.
1202   //
1203   // FIXME: due to a lack of registers we currently blow away the age
1204   // bits in this situation. Should attempt to preserve them.
1205   load_prototype_header(tmp_reg, obj_reg, tmp_reg2);
1206 #ifdef _LP64
1207   orptr(tmp_reg, r15_thread);
1208 #else
1209   get_thread(swap_reg);
1210   orptr(tmp_reg, swap_reg);
1211   movptr(swap_reg, saved_mark_addr);
1212 #endif
1213   lock();
1214   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1215   // If the biasing toward our thread failed, then another thread
1216   // succeeded in biasing it toward itself and we need to revoke that
1217   // bias. The revocation will occur in the runtime in the slow case.
1218   if (counters != NULL) {
1219     cond_inc32(Assembler::zero,
1220                ExternalAddress((address) counters-&gt;rebiased_lock_entry_count_addr()));
1221   }
1222   if (slow_case != NULL) {
1223     jcc(Assembler::notZero, *slow_case);
1224   }
1225   jmp(done);
1226 
1227   bind(try_revoke_bias);
1228   // The prototype mark in the klass doesn&#39;t have the bias bit set any
1229   // more, indicating that objects of this data type are not supposed
1230   // to be biased any more. We are going to try to reset the mark of
1231   // this object to the prototype value and fall through to the
1232   // CAS-based locking scheme. Note that if our CAS fails, it means
1233   // that another thread raced us for the privilege of revoking the
1234   // bias of this particular object, so it&#39;s okay to continue in the
1235   // normal locking code.
1236   //
1237   // FIXME: due to a lack of registers we currently blow away the age
1238   // bits in this situation. Should attempt to preserve them.
1239   NOT_LP64( movptr(swap_reg, saved_mark_addr); )
1240   load_prototype_header(tmp_reg, obj_reg, tmp_reg2);
1241   lock();
1242   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1243   // Fall through to the normal CAS-based lock, because no matter what
1244   // the result of the above CAS, some thread must have succeeded in
1245   // removing the bias bit from the object&#39;s header.
1246   if (counters != NULL) {
1247     cond_inc32(Assembler::zero,
1248                ExternalAddress((address) counters-&gt;revoked_lock_entry_count_addr()));
1249   }
1250 
1251   bind(cas_label);
1252 
1253   return null_check_offset;
1254 }
1255 
1256 void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label&amp; done) {
1257   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
1258 
1259   // Check for biased locking unlock case, which is a no-op
1260   // Note: we do not have to check the thread ID for two reasons.
1261   // First, the interpreter checks for IllegalMonitorStateException at
1262   // a higher level. Second, if the bias was revoked while we held the
1263   // lock, the object could not be rebiased toward another thread, so
1264   // the bias bit would be clear.
1265   movptr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
1266   andptr(temp_reg, markWord::biased_lock_mask_in_place);
1267   cmpptr(temp_reg, markWord::biased_lock_pattern);
1268   jcc(Assembler::equal, done);
1269 }
1270 
1271 void MacroAssembler::c2bool(Register x) {
1272   // implements x == 0 ? 0 : 1
1273   // note: must only look at least-significant byte of x
1274   //       since C-style booleans are stored in one byte
1275   //       only! (was bug)
1276   andl(x, 0xFF);
1277   setb(Assembler::notZero, x);
1278 }
1279 
1280 // Wouldn&#39;t need if AddressLiteral version had new name
1281 void MacroAssembler::call(Label&amp; L, relocInfo::relocType rtype) {
1282   Assembler::call(L, rtype);
1283 }
1284 
1285 void MacroAssembler::call(Register entry) {
1286   Assembler::call(entry);
1287 }
1288 
1289 void MacroAssembler::call(AddressLiteral entry) {
1290   if (reachable(entry)) {
1291     Assembler::call_literal(entry.target(), entry.rspec());
1292   } else {
1293     lea(rscratch1, entry);
1294     Assembler::call(rscratch1);
1295   }
1296 }
1297 
1298 void MacroAssembler::ic_call(address entry, jint method_index) {
1299   RelocationHolder rh = virtual_call_Relocation::spec(pc(), method_index);
1300   movptr(rax, (intptr_t)Universe::non_oop_word());
1301   call(AddressLiteral(entry, rh));
1302 }
1303 
1304 // Implementation of call_VM versions
1305 
1306 void MacroAssembler::call_VM(Register oop_result,
1307                              address entry_point,
1308                              bool check_exceptions) {
1309   Label C, E;
1310   call(C, relocInfo::none);
1311   jmp(E);
1312 
1313   bind(C);
1314   call_VM_helper(oop_result, entry_point, 0, check_exceptions);
1315   ret(0);
1316 
1317   bind(E);
1318 }
1319 
1320 void MacroAssembler::call_VM(Register oop_result,
1321                              address entry_point,
1322                              Register arg_1,
1323                              bool check_exceptions) {
1324   Label C, E;
1325   call(C, relocInfo::none);
1326   jmp(E);
1327 
1328   bind(C);
1329   pass_arg1(this, arg_1);
1330   call_VM_helper(oop_result, entry_point, 1, check_exceptions);
1331   ret(0);
1332 
1333   bind(E);
1334 }
1335 
1336 void MacroAssembler::call_VM(Register oop_result,
1337                              address entry_point,
1338                              Register arg_1,
1339                              Register arg_2,
1340                              bool check_exceptions) {
1341   Label C, E;
1342   call(C, relocInfo::none);
1343   jmp(E);
1344 
1345   bind(C);
1346 
1347   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1348 
1349   pass_arg2(this, arg_2);
1350   pass_arg1(this, arg_1);
1351   call_VM_helper(oop_result, entry_point, 2, check_exceptions);
1352   ret(0);
1353 
1354   bind(E);
1355 }
1356 
1357 void MacroAssembler::call_VM(Register oop_result,
1358                              address entry_point,
1359                              Register arg_1,
1360                              Register arg_2,
1361                              Register arg_3,
1362                              bool check_exceptions) {
1363   Label C, E;
1364   call(C, relocInfo::none);
1365   jmp(E);
1366 
1367   bind(C);
1368 
1369   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1370   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1371   pass_arg3(this, arg_3);
1372 
1373   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1374   pass_arg2(this, arg_2);
1375 
1376   pass_arg1(this, arg_1);
1377   call_VM_helper(oop_result, entry_point, 3, check_exceptions);
1378   ret(0);
1379 
1380   bind(E);
1381 }
1382 
1383 void MacroAssembler::call_VM(Register oop_result,
1384                              Register last_java_sp,
1385                              address entry_point,
1386                              int number_of_arguments,
1387                              bool check_exceptions) {
1388   Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
1389   call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
1390 }
1391 
1392 void MacroAssembler::call_VM(Register oop_result,
1393                              Register last_java_sp,
1394                              address entry_point,
1395                              Register arg_1,
1396                              bool check_exceptions) {
1397   pass_arg1(this, arg_1);
1398   call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
1399 }
1400 
1401 void MacroAssembler::call_VM(Register oop_result,
1402                              Register last_java_sp,
1403                              address entry_point,
1404                              Register arg_1,
1405                              Register arg_2,
1406                              bool check_exceptions) {
1407 
1408   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1409   pass_arg2(this, arg_2);
1410   pass_arg1(this, arg_1);
1411   call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
1412 }
1413 
1414 void MacroAssembler::call_VM(Register oop_result,
1415                              Register last_java_sp,
1416                              address entry_point,
1417                              Register arg_1,
1418                              Register arg_2,
1419                              Register arg_3,
1420                              bool check_exceptions) {
1421   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1422   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1423   pass_arg3(this, arg_3);
1424   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1425   pass_arg2(this, arg_2);
1426   pass_arg1(this, arg_1);
1427   call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
1428 }
1429 
1430 void MacroAssembler::super_call_VM(Register oop_result,
1431                                    Register last_java_sp,
1432                                    address entry_point,
1433                                    int number_of_arguments,
1434                                    bool check_exceptions) {
1435   Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
1436   MacroAssembler::call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
1437 }
1438 
1439 void MacroAssembler::super_call_VM(Register oop_result,
1440                                    Register last_java_sp,
1441                                    address entry_point,
1442                                    Register arg_1,
1443                                    bool check_exceptions) {
1444   pass_arg1(this, arg_1);
1445   super_call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
1446 }
1447 
1448 void MacroAssembler::super_call_VM(Register oop_result,
1449                                    Register last_java_sp,
1450                                    address entry_point,
1451                                    Register arg_1,
1452                                    Register arg_2,
1453                                    bool check_exceptions) {
1454 
1455   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1456   pass_arg2(this, arg_2);
1457   pass_arg1(this, arg_1);
1458   super_call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
1459 }
1460 
1461 void MacroAssembler::super_call_VM(Register oop_result,
1462                                    Register last_java_sp,
1463                                    address entry_point,
1464                                    Register arg_1,
1465                                    Register arg_2,
1466                                    Register arg_3,
1467                                    bool check_exceptions) {
1468   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1469   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1470   pass_arg3(this, arg_3);
1471   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1472   pass_arg2(this, arg_2);
1473   pass_arg1(this, arg_1);
1474   super_call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
1475 }
1476 
1477 void MacroAssembler::call_VM_base(Register oop_result,
1478                                   Register java_thread,
1479                                   Register last_java_sp,
1480                                   address  entry_point,
1481                                   int      number_of_arguments,
1482                                   bool     check_exceptions) {
1483   // determine java_thread register
1484   if (!java_thread-&gt;is_valid()) {
1485 #ifdef _LP64
1486     java_thread = r15_thread;
1487 #else
1488     java_thread = rdi;
1489     get_thread(java_thread);
1490 #endif // LP64
1491   }
1492   // determine last_java_sp register
1493   if (!last_java_sp-&gt;is_valid()) {
1494     last_java_sp = rsp;
1495   }
1496   // debugging support
1497   assert(number_of_arguments &gt;= 0   , &quot;cannot have negative number of arguments&quot;);
1498   LP64_ONLY(assert(java_thread == r15_thread, &quot;unexpected register&quot;));
1499 #ifdef ASSERT
1500   // TraceBytecodes does not use r12 but saves it over the call, so don&#39;t verify
1501   // r12 is the heapbase.
1502   LP64_ONLY(if (UseCompressedOops &amp;&amp; !TraceBytecodes) verify_heapbase(&quot;call_VM_base: heap base corrupted?&quot;);)
1503 #endif // ASSERT
1504 
1505   assert(java_thread != oop_result  , &quot;cannot use the same register for java_thread &amp; oop_result&quot;);
1506   assert(java_thread != last_java_sp, &quot;cannot use the same register for java_thread &amp; last_java_sp&quot;);
1507 
1508   // push java thread (becomes first argument of C function)
1509 
1510   NOT_LP64(push(java_thread); number_of_arguments++);
1511   LP64_ONLY(mov(c_rarg0, r15_thread));
1512 
1513   // set last Java frame before call
1514   assert(last_java_sp != rbp, &quot;can&#39;t use ebp/rbp&quot;);
1515 
1516   // Only interpreter should have to set fp
1517   set_last_Java_frame(java_thread, last_java_sp, rbp, NULL);
1518 
1519   // do the call, remove parameters
1520   MacroAssembler::call_VM_leaf_base(entry_point, number_of_arguments);
1521 
1522   // restore the thread (cannot use the pushed argument since arguments
1523   // may be overwritten by C code generated by an optimizing compiler);
1524   // however can use the register value directly if it is callee saved.
1525   if (LP64_ONLY(true ||) java_thread == rdi || java_thread == rsi) {
1526     // rdi &amp; rsi (also r15) are callee saved -&gt; nothing to do
1527 #ifdef ASSERT
1528     guarantee(java_thread != rax, &quot;change this code&quot;);
1529     push(rax);
1530     { Label L;
1531       get_thread(rax);
1532       cmpptr(java_thread, rax);
1533       jcc(Assembler::equal, L);
1534       STOP(&quot;MacroAssembler::call_VM_base: rdi not callee saved?&quot;);
1535       bind(L);
1536     }
1537     pop(rax);
1538 #endif
1539   } else {
1540     get_thread(java_thread);
1541   }
1542   // reset last Java frame
1543   // Only interpreter should have to clear fp
1544   reset_last_Java_frame(java_thread, true);
1545 
1546    // C++ interp handles this in the interpreter
1547   check_and_handle_popframe(java_thread);
1548   check_and_handle_earlyret(java_thread);
1549 
1550   if (check_exceptions) {
1551     // check for pending exceptions (java_thread is set upon return)
1552     cmpptr(Address(java_thread, Thread::pending_exception_offset()), (int32_t) NULL_WORD);
1553 #ifndef _LP64
1554     jump_cc(Assembler::notEqual,
1555             RuntimeAddress(StubRoutines::forward_exception_entry()));
1556 #else
1557     // This used to conditionally jump to forward_exception however it is
1558     // possible if we relocate that the branch will not reach. So we must jump
1559     // around so we can always reach
1560 
1561     Label ok;
1562     jcc(Assembler::equal, ok);
1563     jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
1564     bind(ok);
1565 #endif // LP64
1566   }
1567 
1568   // get oop result if there is one and reset the value in the thread
1569   if (oop_result-&gt;is_valid()) {
1570     get_vm_result(oop_result, java_thread);
1571   }
1572 }
1573 
1574 void MacroAssembler::call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions) {
1575 
1576   // Calculate the value for last_Java_sp
1577   // somewhat subtle. call_VM does an intermediate call
1578   // which places a return address on the stack just under the
1579   // stack pointer as the user finsihed with it. This allows
1580   // use to retrieve last_Java_pc from last_Java_sp[-1].
1581   // On 32bit we then have to push additional args on the stack to accomplish
1582   // the actual requested call. On 64bit call_VM only can use register args
1583   // so the only extra space is the return address that call_VM created.
1584   // This hopefully explains the calculations here.
1585 
1586 #ifdef _LP64
1587   // We&#39;ve pushed one address, correct last_Java_sp
1588   lea(rax, Address(rsp, wordSize));
1589 #else
1590   lea(rax, Address(rsp, (1 + number_of_arguments) * wordSize));
1591 #endif // LP64
1592 
1593   call_VM_base(oop_result, noreg, rax, entry_point, number_of_arguments, check_exceptions);
1594 
1595 }
1596 
1597 // Use this method when MacroAssembler version of call_VM_leaf_base() should be called from Interpreter.
1598 void MacroAssembler::call_VM_leaf0(address entry_point) {
1599   MacroAssembler::call_VM_leaf_base(entry_point, 0);
1600 }
1601 
1602 void MacroAssembler::call_VM_leaf(address entry_point, int number_of_arguments) {
1603   call_VM_leaf_base(entry_point, number_of_arguments);
1604 }
1605 
1606 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0) {
1607   pass_arg0(this, arg_0);
1608   call_VM_leaf(entry_point, 1);
1609 }
1610 
1611 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1612 
1613   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1614   pass_arg1(this, arg_1);
1615   pass_arg0(this, arg_0);
1616   call_VM_leaf(entry_point, 2);
1617 }
1618 
1619 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
1620   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1621   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1622   pass_arg2(this, arg_2);
1623   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1624   pass_arg1(this, arg_1);
1625   pass_arg0(this, arg_0);
1626   call_VM_leaf(entry_point, 3);
1627 }
1628 
1629 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0) {
1630   pass_arg0(this, arg_0);
1631   MacroAssembler::call_VM_leaf_base(entry_point, 1);
1632 }
1633 
1634 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1635 
1636   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1637   pass_arg1(this, arg_1);
1638   pass_arg0(this, arg_0);
1639   MacroAssembler::call_VM_leaf_base(entry_point, 2);
1640 }
1641 
1642 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
1643   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1644   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1645   pass_arg2(this, arg_2);
1646   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1647   pass_arg1(this, arg_1);
1648   pass_arg0(this, arg_0);
1649   MacroAssembler::call_VM_leaf_base(entry_point, 3);
1650 }
1651 
1652 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2, Register arg_3) {
1653   LP64_ONLY(assert(arg_0 != c_rarg3, &quot;smashed arg&quot;));
1654   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1655   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1656   pass_arg3(this, arg_3);
1657   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1658   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1659   pass_arg2(this, arg_2);
1660   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1661   pass_arg1(this, arg_1);
1662   pass_arg0(this, arg_0);
1663   MacroAssembler::call_VM_leaf_base(entry_point, 4);
1664 }
1665 
1666 void MacroAssembler::get_vm_result(Register oop_result, Register java_thread) {
1667   movptr(oop_result, Address(java_thread, JavaThread::vm_result_offset()));
1668   movptr(Address(java_thread, JavaThread::vm_result_offset()), NULL_WORD);
1669   verify_oop_msg(oop_result, &quot;broken oop in call_VM_base&quot;);
1670 }
1671 
1672 void MacroAssembler::get_vm_result_2(Register metadata_result, Register java_thread) {
1673   movptr(metadata_result, Address(java_thread, JavaThread::vm_result_2_offset()));
1674   movptr(Address(java_thread, JavaThread::vm_result_2_offset()), NULL_WORD);
1675 }
1676 
1677 void MacroAssembler::check_and_handle_earlyret(Register java_thread) {
1678 }
1679 
1680 void MacroAssembler::check_and_handle_popframe(Register java_thread) {
1681 }
1682 
1683 void MacroAssembler::cmp32(AddressLiteral src1, int32_t imm) {
1684   if (reachable(src1)) {
1685     cmpl(as_Address(src1), imm);
1686   } else {
1687     lea(rscratch1, src1);
1688     cmpl(Address(rscratch1, 0), imm);
1689   }
1690 }
1691 
1692 void MacroAssembler::cmp32(Register src1, AddressLiteral src2) {
1693   assert(!src2.is_lval(), &quot;use cmpptr&quot;);
1694   if (reachable(src2)) {
1695     cmpl(src1, as_Address(src2));
1696   } else {
1697     lea(rscratch1, src2);
1698     cmpl(src1, Address(rscratch1, 0));
1699   }
1700 }
1701 
1702 void MacroAssembler::cmp32(Register src1, int32_t imm) {
1703   Assembler::cmpl(src1, imm);
1704 }
1705 
1706 void MacroAssembler::cmp32(Register src1, Address src2) {
1707   Assembler::cmpl(src1, src2);
1708 }
1709 
1710 void MacroAssembler::cmpsd2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less) {
1711   ucomisd(opr1, opr2);
1712 
1713   Label L;
1714   if (unordered_is_less) {
1715     movl(dst, -1);
1716     jcc(Assembler::parity, L);
1717     jcc(Assembler::below , L);
1718     movl(dst, 0);
1719     jcc(Assembler::equal , L);
1720     increment(dst);
1721   } else { // unordered is greater
1722     movl(dst, 1);
1723     jcc(Assembler::parity, L);
1724     jcc(Assembler::above , L);
1725     movl(dst, 0);
1726     jcc(Assembler::equal , L);
1727     decrementl(dst);
1728   }
1729   bind(L);
1730 }
1731 
1732 void MacroAssembler::cmpss2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less) {
1733   ucomiss(opr1, opr2);
1734 
1735   Label L;
1736   if (unordered_is_less) {
1737     movl(dst, -1);
1738     jcc(Assembler::parity, L);
1739     jcc(Assembler::below , L);
1740     movl(dst, 0);
1741     jcc(Assembler::equal , L);
1742     increment(dst);
1743   } else { // unordered is greater
1744     movl(dst, 1);
1745     jcc(Assembler::parity, L);
1746     jcc(Assembler::above , L);
1747     movl(dst, 0);
1748     jcc(Assembler::equal , L);
1749     decrementl(dst);
1750   }
1751   bind(L);
1752 }
1753 
1754 
1755 void MacroAssembler::cmp8(AddressLiteral src1, int imm) {
1756   if (reachable(src1)) {
1757     cmpb(as_Address(src1), imm);
1758   } else {
1759     lea(rscratch1, src1);
1760     cmpb(Address(rscratch1, 0), imm);
1761   }
1762 }
1763 
1764 void MacroAssembler::cmpptr(Register src1, AddressLiteral src2) {
1765 #ifdef _LP64
1766   if (src2.is_lval()) {
1767     movptr(rscratch1, src2);
1768     Assembler::cmpq(src1, rscratch1);
1769   } else if (reachable(src2)) {
1770     cmpq(src1, as_Address(src2));
1771   } else {
1772     lea(rscratch1, src2);
1773     Assembler::cmpq(src1, Address(rscratch1, 0));
1774   }
1775 #else
1776   if (src2.is_lval()) {
1777     cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());
1778   } else {
1779     cmpl(src1, as_Address(src2));
1780   }
1781 #endif // _LP64
1782 }
1783 
1784 void MacroAssembler::cmpptr(Address src1, AddressLiteral src2) {
1785   assert(src2.is_lval(), &quot;not a mem-mem compare&quot;);
1786 #ifdef _LP64
1787   // moves src2&#39;s literal address
1788   movptr(rscratch1, src2);
1789   Assembler::cmpq(src1, rscratch1);
1790 #else
1791   cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());
1792 #endif // _LP64
1793 }
1794 
1795 void MacroAssembler::cmpoop(Register src1, Register src2) {
1796   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1797   bs-&gt;obj_equals(this, src1, src2);
1798 }
1799 
1800 void MacroAssembler::cmpoop(Register src1, Address src2) {
1801   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1802   bs-&gt;obj_equals(this, src1, src2);
1803 }
1804 
1805 #ifdef _LP64
1806 void MacroAssembler::cmpoop(Register src1, jobject src2) {
1807   movoop(rscratch1, src2);
1808   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1809   bs-&gt;obj_equals(this, src1, rscratch1);
1810 }
1811 #endif
1812 
1813 void MacroAssembler::locked_cmpxchgptr(Register reg, AddressLiteral adr) {
1814   if (reachable(adr)) {
1815     lock();
1816     cmpxchgptr(reg, as_Address(adr));
1817   } else {
1818     lea(rscratch1, adr);
1819     lock();
1820     cmpxchgptr(reg, Address(rscratch1, 0));
1821   }
1822 }
1823 
1824 void MacroAssembler::cmpxchgptr(Register reg, Address adr) {
1825   LP64_ONLY(cmpxchgq(reg, adr)) NOT_LP64(cmpxchgl(reg, adr));
1826 }
1827 
1828 void MacroAssembler::comisd(XMMRegister dst, AddressLiteral src) {
1829   if (reachable(src)) {
1830     Assembler::comisd(dst, as_Address(src));
1831   } else {
1832     lea(rscratch1, src);
1833     Assembler::comisd(dst, Address(rscratch1, 0));
1834   }
1835 }
1836 
1837 void MacroAssembler::comiss(XMMRegister dst, AddressLiteral src) {
1838   if (reachable(src)) {
1839     Assembler::comiss(dst, as_Address(src));
1840   } else {
1841     lea(rscratch1, src);
1842     Assembler::comiss(dst, Address(rscratch1, 0));
1843   }
1844 }
1845 
1846 
1847 void MacroAssembler::cond_inc32(Condition cond, AddressLiteral counter_addr) {
1848   Condition negated_cond = negate_condition(cond);
1849   Label L;
1850   jcc(negated_cond, L);
1851   pushf(); // Preserve flags
1852   atomic_incl(counter_addr);
1853   popf();
1854   bind(L);
1855 }
1856 
1857 int MacroAssembler::corrected_idivl(Register reg) {
1858   // Full implementation of Java idiv and irem; checks for
1859   // special case as described in JVM spec., p.243 &amp; p.271.
1860   // The function returns the (pc) offset of the idivl
1861   // instruction - may be needed for implicit exceptions.
1862   //
1863   //         normal case                           special case
1864   //
1865   // input : rax,: dividend                         min_int
1866   //         reg: divisor   (may not be rax,/rdx)   -1
1867   //
1868   // output: rax,: quotient  (= rax, idiv reg)       min_int
1869   //         rdx: remainder (= rax, irem reg)       0
1870   assert(reg != rax &amp;&amp; reg != rdx, &quot;reg cannot be rax, or rdx register&quot;);
1871   const int min_int = 0x80000000;
1872   Label normal_case, special_case;
1873 
1874   // check for special case
1875   cmpl(rax, min_int);
1876   jcc(Assembler::notEqual, normal_case);
1877   xorl(rdx, rdx); // prepare rdx for possible special case (where remainder = 0)
1878   cmpl(reg, -1);
1879   jcc(Assembler::equal, special_case);
1880 
1881   // handle normal case
1882   bind(normal_case);
1883   cdql();
1884   int idivl_offset = offset();
1885   idivl(reg);
1886 
1887   // normal and special case exit
1888   bind(special_case);
1889 
1890   return idivl_offset;
1891 }
1892 
1893 
1894 
1895 void MacroAssembler::decrementl(Register reg, int value) {
1896   if (value == min_jint) {subl(reg, value) ; return; }
1897   if (value &lt;  0) { incrementl(reg, -value); return; }
1898   if (value == 0) {                        ; return; }
1899   if (value == 1 &amp;&amp; UseIncDec) { decl(reg) ; return; }
1900   /* else */      { subl(reg, value)       ; return; }
1901 }
1902 
1903 void MacroAssembler::decrementl(Address dst, int value) {
1904   if (value == min_jint) {subl(dst, value) ; return; }
1905   if (value &lt;  0) { incrementl(dst, -value); return; }
1906   if (value == 0) {                        ; return; }
1907   if (value == 1 &amp;&amp; UseIncDec) { decl(dst) ; return; }
1908   /* else */      { subl(dst, value)       ; return; }
1909 }
1910 
1911 void MacroAssembler::division_with_shift (Register reg, int shift_value) {
1912   assert (shift_value &gt; 0, &quot;illegal shift value&quot;);
1913   Label _is_positive;
1914   testl (reg, reg);
1915   jcc (Assembler::positive, _is_positive);
1916   int offset = (1 &lt;&lt; shift_value) - 1 ;
1917 
1918   if (offset == 1) {
1919     incrementl(reg);
1920   } else {
1921     addl(reg, offset);
1922   }
1923 
1924   bind (_is_positive);
1925   sarl(reg, shift_value);
1926 }
1927 
1928 void MacroAssembler::divsd(XMMRegister dst, AddressLiteral src) {
1929   if (reachable(src)) {
1930     Assembler::divsd(dst, as_Address(src));
1931   } else {
1932     lea(rscratch1, src);
1933     Assembler::divsd(dst, Address(rscratch1, 0));
1934   }
1935 }
1936 
1937 void MacroAssembler::divss(XMMRegister dst, AddressLiteral src) {
1938   if (reachable(src)) {
1939     Assembler::divss(dst, as_Address(src));
1940   } else {
1941     lea(rscratch1, src);
1942     Assembler::divss(dst, Address(rscratch1, 0));
1943   }
1944 }
1945 
1946 void MacroAssembler::enter() {
1947   push(rbp);
1948   mov(rbp, rsp);
1949 }
1950 
1951 // A 5 byte nop that is safe for patching (see patch_verified_entry)
1952 void MacroAssembler::fat_nop() {
1953   if (UseAddressNop) {
1954     addr_nop_5();
1955   } else {
1956     emit_int8(0x26); // es:
1957     emit_int8(0x2e); // cs:
1958     emit_int8(0x64); // fs:
1959     emit_int8(0x65); // gs:
1960     emit_int8((unsigned char)0x90);
1961   }
1962 }
1963 
1964 #ifndef _LP64
1965 void MacroAssembler::fcmp(Register tmp) {
1966   fcmp(tmp, 1, true, true);
1967 }
1968 
1969 void MacroAssembler::fcmp(Register tmp, int index, bool pop_left, bool pop_right) {
1970   assert(!pop_right || pop_left, &quot;usage error&quot;);
1971   if (VM_Version::supports_cmov()) {
1972     assert(tmp == noreg, &quot;unneeded temp&quot;);
1973     if (pop_left) {
1974       fucomip(index);
1975     } else {
1976       fucomi(index);
1977     }
1978     if (pop_right) {
1979       fpop();
1980     }
1981   } else {
1982     assert(tmp != noreg, &quot;need temp&quot;);
1983     if (pop_left) {
1984       if (pop_right) {
1985         fcompp();
1986       } else {
1987         fcomp(index);
1988       }
1989     } else {
1990       fcom(index);
1991     }
1992     // convert FPU condition into eflags condition via rax,
1993     save_rax(tmp);
1994     fwait(); fnstsw_ax();
1995     sahf();
1996     restore_rax(tmp);
1997   }
1998   // condition codes set as follows:
1999   //
2000   // CF (corresponds to C0) if x &lt; y
2001   // PF (corresponds to C2) if unordered
2002   // ZF (corresponds to C3) if x = y
2003 }
2004 
2005 void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less) {
2006   fcmp2int(dst, unordered_is_less, 1, true, true);
2007 }
2008 
2009 void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less, int index, bool pop_left, bool pop_right) {
2010   fcmp(VM_Version::supports_cmov() ? noreg : dst, index, pop_left, pop_right);
2011   Label L;
2012   if (unordered_is_less) {
2013     movl(dst, -1);
2014     jcc(Assembler::parity, L);
2015     jcc(Assembler::below , L);
2016     movl(dst, 0);
2017     jcc(Assembler::equal , L);
2018     increment(dst);
2019   } else { // unordered is greater
2020     movl(dst, 1);
2021     jcc(Assembler::parity, L);
2022     jcc(Assembler::above , L);
2023     movl(dst, 0);
2024     jcc(Assembler::equal , L);
2025     decrementl(dst);
2026   }
2027   bind(L);
2028 }
2029 
2030 void MacroAssembler::fld_d(AddressLiteral src) {
2031   fld_d(as_Address(src));
2032 }
2033 
2034 void MacroAssembler::fld_s(AddressLiteral src) {
2035   fld_s(as_Address(src));
2036 }
2037 
2038 void MacroAssembler::fldcw(AddressLiteral src) {
2039   Assembler::fldcw(as_Address(src));
2040 }
2041 
2042 void MacroAssembler::fpop() {
2043   ffree();
2044   fincstp();
2045 }
2046 
2047 void MacroAssembler::fremr(Register tmp) {
2048   save_rax(tmp);
2049   { Label L;
2050     bind(L);
2051     fprem();
2052     fwait(); fnstsw_ax();
2053     sahf();
2054     jcc(Assembler::parity, L);
2055   }
2056   restore_rax(tmp);
2057   // Result is in ST0.
2058   // Note: fxch &amp; fpop to get rid of ST1
2059   // (otherwise FPU stack could overflow eventually)
2060   fxch(1);
2061   fpop();
2062 }
2063 
2064 void MacroAssembler::empty_FPU_stack() {
2065   if (VM_Version::supports_mmx()) {
2066     emms();
2067   } else {
2068     for (int i = 8; i-- &gt; 0; ) ffree(i);
2069   }
2070 }
2071 #endif // !LP64
2072 
2073 void MacroAssembler::mulpd(XMMRegister dst, AddressLiteral src) {
2074   if (reachable(src)) {
2075     Assembler::mulpd(dst, as_Address(src));
2076   } else {
2077     lea(rscratch1, src);
2078     Assembler::mulpd(dst, Address(rscratch1, 0));
2079   }
2080 }
2081 
2082 void MacroAssembler::load_float(Address src) {
2083 #ifdef _LP64
2084   movflt(xmm0, src);
2085 #else
2086   if (UseSSE &gt;= 1) {
2087     movflt(xmm0, src);
2088   } else {
2089     fld_s(src);
2090   }
2091 #endif // LP64
2092 }
2093 
2094 void MacroAssembler::store_float(Address dst) {
2095 #ifdef _LP64
2096   movflt(dst, xmm0);
2097 #else
2098   if (UseSSE &gt;= 1) {
2099     movflt(dst, xmm0);
2100   } else {
2101     fstp_s(dst);
2102   }
2103 #endif // LP64
2104 }
2105 
2106 void MacroAssembler::load_double(Address src) {
2107 #ifdef _LP64
2108   movdbl(xmm0, src);
2109 #else
2110   if (UseSSE &gt;= 2) {
2111     movdbl(xmm0, src);
2112   } else {
2113     fld_d(src);
2114   }
2115 #endif // LP64
2116 }
2117 
2118 void MacroAssembler::store_double(Address dst) {
2119 #ifdef _LP64
2120   movdbl(dst, xmm0);
2121 #else
2122   if (UseSSE &gt;= 2) {
2123     movdbl(dst, xmm0);
2124   } else {
2125     fstp_d(dst);
2126   }
2127 #endif // LP64
2128 }
2129 
2130 // dst = c = a * b + c
2131 void MacroAssembler::fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
2132   Assembler::vfmadd231sd(c, a, b);
2133   if (dst != c) {
2134     movdbl(dst, c);
2135   }
2136 }
2137 
2138 // dst = c = a * b + c
2139 void MacroAssembler::fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
2140   Assembler::vfmadd231ss(c, a, b);
2141   if (dst != c) {
2142     movflt(dst, c);
2143   }
2144 }
2145 
2146 // dst = c = a * b + c
2147 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
2148   Assembler::vfmadd231pd(c, a, b, vector_len);
2149   if (dst != c) {
2150     vmovdqu(dst, c);
2151   }
2152 }
2153 
2154 // dst = c = a * b + c
2155 void MacroAssembler::vfmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
2156   Assembler::vfmadd231ps(c, a, b, vector_len);
2157   if (dst != c) {
2158     vmovdqu(dst, c);
2159   }
2160 }
2161 
2162 // dst = c = a * b + c
2163 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {
2164   Assembler::vfmadd231pd(c, a, b, vector_len);
2165   if (dst != c) {
2166     vmovdqu(dst, c);
2167   }
2168 }
2169 
2170 // dst = c = a * b + c
2171 void MacroAssembler::vfmaf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {
2172   Assembler::vfmadd231ps(c, a, b, vector_len);
2173   if (dst != c) {
2174     vmovdqu(dst, c);
2175   }
2176 }
2177 
2178 void MacroAssembler::incrementl(AddressLiteral dst) {
2179   if (reachable(dst)) {
2180     incrementl(as_Address(dst));
2181   } else {
2182     lea(rscratch1, dst);
2183     incrementl(Address(rscratch1, 0));
2184   }
2185 }
2186 
2187 void MacroAssembler::incrementl(ArrayAddress dst) {
2188   incrementl(as_Address(dst));
2189 }
2190 
2191 void MacroAssembler::incrementl(Register reg, int value) {
2192   if (value == min_jint) {addl(reg, value) ; return; }
2193   if (value &lt;  0) { decrementl(reg, -value); return; }
2194   if (value == 0) {                        ; return; }
2195   if (value == 1 &amp;&amp; UseIncDec) { incl(reg) ; return; }
2196   /* else */      { addl(reg, value)       ; return; }
2197 }
2198 
2199 void MacroAssembler::incrementl(Address dst, int value) {
2200   if (value == min_jint) {addl(dst, value) ; return; }
2201   if (value &lt;  0) { decrementl(dst, -value); return; }
2202   if (value == 0) {                        ; return; }
2203   if (value == 1 &amp;&amp; UseIncDec) { incl(dst) ; return; }
2204   /* else */      { addl(dst, value)       ; return; }
2205 }
2206 
2207 void MacroAssembler::jump(AddressLiteral dst) {
2208   if (reachable(dst)) {
2209     jmp_literal(dst.target(), dst.rspec());
2210   } else {
2211     lea(rscratch1, dst);
2212     jmp(rscratch1);
2213   }
2214 }
2215 
2216 void MacroAssembler::jump_cc(Condition cc, AddressLiteral dst) {
2217   if (reachable(dst)) {
2218     InstructionMark im(this);
2219     relocate(dst.reloc());
2220     const int short_size = 2;
2221     const int long_size = 6;
2222     int offs = (intptr_t)dst.target() - ((intptr_t)pc());
2223     if (dst.reloc() == relocInfo::none &amp;&amp; is8bit(offs - short_size)) {
2224       // 0111 tttn #8-bit disp
2225       emit_int8(0x70 | cc);
2226       emit_int8((offs - short_size) &amp; 0xFF);
2227     } else {
2228       // 0000 1111 1000 tttn #32-bit disp
2229       emit_int8(0x0F);
2230       emit_int8((unsigned char)(0x80 | cc));
2231       emit_int32(offs - long_size);
2232     }
2233   } else {
2234 #ifdef ASSERT
2235     warning(&quot;reversing conditional branch&quot;);
2236 #endif /* ASSERT */
2237     Label skip;
2238     jccb(reverse[cc], skip);
2239     lea(rscratch1, dst);
2240     Assembler::jmp(rscratch1);
2241     bind(skip);
2242   }
2243 }
2244 
2245 void MacroAssembler::fld_x(AddressLiteral src) {
2246   Assembler::fld_x(as_Address(src));
2247 }
2248 
2249 void MacroAssembler::ldmxcsr(AddressLiteral src) {
2250   if (reachable(src)) {
2251     Assembler::ldmxcsr(as_Address(src));
2252   } else {
2253     lea(rscratch1, src);
2254     Assembler::ldmxcsr(Address(rscratch1, 0));
2255   }
2256 }
2257 
2258 int MacroAssembler::load_signed_byte(Register dst, Address src) {
2259   int off;
2260   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2261     off = offset();
2262     movsbl(dst, src); // movsxb
2263   } else {
2264     off = load_unsigned_byte(dst, src);
2265     shll(dst, 24);
2266     sarl(dst, 24);
2267   }
2268   return off;
2269 }
2270 
2271 // Note: load_signed_short used to be called load_signed_word.
2272 // Although the &#39;w&#39; in x86 opcodes refers to the term &quot;word&quot; in the assembler
2273 // manual, which means 16 bits, that usage is found nowhere in HotSpot code.
2274 // The term &quot;word&quot; in HotSpot means a 32- or 64-bit machine word.
2275 int MacroAssembler::load_signed_short(Register dst, Address src) {
2276   int off;
2277   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2278     // This is dubious to me since it seems safe to do a signed 16 =&gt; 64 bit
2279     // version but this is what 64bit has always done. This seems to imply
2280     // that users are only using 32bits worth.
2281     off = offset();
2282     movswl(dst, src); // movsxw
2283   } else {
2284     off = load_unsigned_short(dst, src);
2285     shll(dst, 16);
2286     sarl(dst, 16);
2287   }
2288   return off;
2289 }
2290 
2291 int MacroAssembler::load_unsigned_byte(Register dst, Address src) {
2292   // According to Intel Doc. AP-526, &quot;Zero-Extension of Short&quot;, p.16,
2293   // and &quot;3.9 Partial Register Penalties&quot;, p. 22).
2294   int off;
2295   if (LP64_ONLY(true || ) VM_Version::is_P6() || src.uses(dst)) {
2296     off = offset();
2297     movzbl(dst, src); // movzxb
2298   } else {
2299     xorl(dst, dst);
2300     off = offset();
2301     movb(dst, src);
2302   }
2303   return off;
2304 }
2305 
2306 // Note: load_unsigned_short used to be called load_unsigned_word.
2307 int MacroAssembler::load_unsigned_short(Register dst, Address src) {
2308   // According to Intel Doc. AP-526, &quot;Zero-Extension of Short&quot;, p.16,
2309   // and &quot;3.9 Partial Register Penalties&quot;, p. 22).
2310   int off;
2311   if (LP64_ONLY(true ||) VM_Version::is_P6() || src.uses(dst)) {
2312     off = offset();
2313     movzwl(dst, src); // movzxw
2314   } else {
2315     xorl(dst, dst);
2316     off = offset();
2317     movw(dst, src);
2318   }
2319   return off;
2320 }
2321 
2322 void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2) {
2323   switch (size_in_bytes) {
2324 #ifndef _LP64
2325   case  8:
2326     assert(dst2 != noreg, &quot;second dest register required&quot;);
2327     movl(dst,  src);
2328     movl(dst2, src.plus_disp(BytesPerInt));
2329     break;
2330 #else
2331   case  8:  movq(dst, src); break;
2332 #endif
2333   case  4:  movl(dst, src); break;
2334   case  2:  is_signed ? load_signed_short(dst, src) : load_unsigned_short(dst, src); break;
2335   case  1:  is_signed ? load_signed_byte( dst, src) : load_unsigned_byte( dst, src); break;
2336   default:  ShouldNotReachHere();
2337   }
2338 }
2339 
2340 void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2) {
2341   switch (size_in_bytes) {
2342 #ifndef _LP64
2343   case  8:
2344     assert(src2 != noreg, &quot;second source register required&quot;);
2345     movl(dst,                        src);
2346     movl(dst.plus_disp(BytesPerInt), src2);
2347     break;
2348 #else
2349   case  8:  movq(dst, src); break;
2350 #endif
2351   case  4:  movl(dst, src); break;
2352   case  2:  movw(dst, src); break;
2353   case  1:  movb(dst, src); break;
2354   default:  ShouldNotReachHere();
2355   }
2356 }
2357 
2358 void MacroAssembler::mov32(AddressLiteral dst, Register src) {
2359   if (reachable(dst)) {
2360     movl(as_Address(dst), src);
2361   } else {
2362     lea(rscratch1, dst);
2363     movl(Address(rscratch1, 0), src);
2364   }
2365 }
2366 
2367 void MacroAssembler::mov32(Register dst, AddressLiteral src) {
2368   if (reachable(src)) {
2369     movl(dst, as_Address(src));
2370   } else {
2371     lea(rscratch1, src);
2372     movl(dst, Address(rscratch1, 0));
2373   }
2374 }
2375 
2376 // C++ bool manipulation
2377 
2378 void MacroAssembler::movbool(Register dst, Address src) {
2379   if(sizeof(bool) == 1)
2380     movb(dst, src);
2381   else if(sizeof(bool) == 2)
2382     movw(dst, src);
2383   else if(sizeof(bool) == 4)
2384     movl(dst, src);
2385   else
2386     // unsupported
2387     ShouldNotReachHere();
2388 }
2389 
2390 void MacroAssembler::movbool(Address dst, bool boolconst) {
2391   if(sizeof(bool) == 1)
2392     movb(dst, (int) boolconst);
2393   else if(sizeof(bool) == 2)
2394     movw(dst, (int) boolconst);
2395   else if(sizeof(bool) == 4)
2396     movl(dst, (int) boolconst);
2397   else
2398     // unsupported
2399     ShouldNotReachHere();
2400 }
2401 
2402 void MacroAssembler::movbool(Address dst, Register src) {
2403   if(sizeof(bool) == 1)
2404     movb(dst, src);
2405   else if(sizeof(bool) == 2)
2406     movw(dst, src);
2407   else if(sizeof(bool) == 4)
2408     movl(dst, src);
2409   else
2410     // unsupported
2411     ShouldNotReachHere();
2412 }
2413 
2414 void MacroAssembler::movbyte(ArrayAddress dst, int src) {
2415   movb(as_Address(dst), src);
2416 }
2417 
2418 void MacroAssembler::movdl(XMMRegister dst, AddressLiteral src) {
2419   if (reachable(src)) {
2420     movdl(dst, as_Address(src));
2421   } else {
2422     lea(rscratch1, src);
2423     movdl(dst, Address(rscratch1, 0));
2424   }
2425 }
2426 
2427 void MacroAssembler::movq(XMMRegister dst, AddressLiteral src) {
2428   if (reachable(src)) {
2429     movq(dst, as_Address(src));
2430   } else {
2431     lea(rscratch1, src);
2432     movq(dst, Address(rscratch1, 0));
2433   }
2434 }
2435 
2436 void MacroAssembler::movdbl(XMMRegister dst, AddressLiteral src) {
2437   if (reachable(src)) {
2438     if (UseXmmLoadAndClearUpper) {
2439       movsd (dst, as_Address(src));
2440     } else {
2441       movlpd(dst, as_Address(src));
2442     }
2443   } else {
2444     lea(rscratch1, src);
2445     if (UseXmmLoadAndClearUpper) {
2446       movsd (dst, Address(rscratch1, 0));
2447     } else {
2448       movlpd(dst, Address(rscratch1, 0));
2449     }
2450   }
2451 }
2452 
2453 void MacroAssembler::movflt(XMMRegister dst, AddressLiteral src) {
2454   if (reachable(src)) {
2455     movss(dst, as_Address(src));
2456   } else {
2457     lea(rscratch1, src);
2458     movss(dst, Address(rscratch1, 0));
2459   }
2460 }
2461 
2462 void MacroAssembler::movptr(Register dst, Register src) {
2463   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2464 }
2465 
2466 void MacroAssembler::movptr(Register dst, Address src) {
2467   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2468 }
2469 
2470 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
2471 void MacroAssembler::movptr(Register dst, intptr_t src) {
2472   LP64_ONLY(mov64(dst, src)) NOT_LP64(movl(dst, src));
2473 }
2474 
2475 void MacroAssembler::movptr(Address dst, Register src) {
2476   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2477 }
2478 
2479 void MacroAssembler::movdqu(Address dst, XMMRegister src) {
2480     assert(((src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2481     Assembler::movdqu(dst, src);
2482 }
2483 
2484 void MacroAssembler::movdqu(XMMRegister dst, Address src) {
2485     assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2486     Assembler::movdqu(dst, src);
2487 }
2488 
2489 void MacroAssembler::movdqu(XMMRegister dst, XMMRegister src) {
2490     assert(((dst-&gt;encoding() &lt; 16  &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2491     Assembler::movdqu(dst, src);
2492 }
2493 
2494 void MacroAssembler::movdqu(XMMRegister dst, AddressLiteral src, Register scratchReg) {
2495   if (reachable(src)) {
2496     movdqu(dst, as_Address(src));
2497   } else {
2498     lea(scratchReg, src);
2499     movdqu(dst, Address(scratchReg, 0));
2500   }
2501 }
2502 
2503 void MacroAssembler::vmovdqu(Address dst, XMMRegister src) {
2504     assert(((src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2505     Assembler::vmovdqu(dst, src);
2506 }
2507 
2508 void MacroAssembler::vmovdqu(XMMRegister dst, Address src) {
2509     assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2510     Assembler::vmovdqu(dst, src);
2511 }
2512 
2513 void MacroAssembler::vmovdqu(XMMRegister dst, XMMRegister src) {
2514     assert(((dst-&gt;encoding() &lt; 16  &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2515     Assembler::vmovdqu(dst, src);
2516 }
2517 
2518 void MacroAssembler::vmovdqu(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
2519   if (reachable(src)) {
2520     vmovdqu(dst, as_Address(src));
2521   }
2522   else {
2523     lea(scratch_reg, src);
2524     vmovdqu(dst, Address(scratch_reg, 0));
2525   }
2526 }
2527 
2528 void MacroAssembler::evmovdquq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {
2529   if (reachable(src)) {
2530     Assembler::evmovdquq(dst, as_Address(src), vector_len);
2531   } else {
2532     lea(rscratch, src);
2533     Assembler::evmovdquq(dst, Address(rscratch, 0), vector_len);
2534   }
2535 }
2536 
2537 void MacroAssembler::movdqa(XMMRegister dst, AddressLiteral src) {
2538   if (reachable(src)) {
2539     Assembler::movdqa(dst, as_Address(src));
2540   } else {
2541     lea(rscratch1, src);
2542     Assembler::movdqa(dst, Address(rscratch1, 0));
2543   }
2544 }
2545 
2546 void MacroAssembler::movsd(XMMRegister dst, AddressLiteral src) {
2547   if (reachable(src)) {
2548     Assembler::movsd(dst, as_Address(src));
2549   } else {
2550     lea(rscratch1, src);
2551     Assembler::movsd(dst, Address(rscratch1, 0));
2552   }
2553 }
2554 
2555 void MacroAssembler::movss(XMMRegister dst, AddressLiteral src) {
2556   if (reachable(src)) {
2557     Assembler::movss(dst, as_Address(src));
2558   } else {
2559     lea(rscratch1, src);
2560     Assembler::movss(dst, Address(rscratch1, 0));
2561   }
2562 }
2563 
2564 void MacroAssembler::mulsd(XMMRegister dst, AddressLiteral src) {
2565   if (reachable(src)) {
2566     Assembler::mulsd(dst, as_Address(src));
2567   } else {
2568     lea(rscratch1, src);
2569     Assembler::mulsd(dst, Address(rscratch1, 0));
2570   }
2571 }
2572 
2573 void MacroAssembler::mulss(XMMRegister dst, AddressLiteral src) {
2574   if (reachable(src)) {
2575     Assembler::mulss(dst, as_Address(src));
2576   } else {
2577     lea(rscratch1, src);
2578     Assembler::mulss(dst, Address(rscratch1, 0));
2579   }
2580 }
2581 
2582 void MacroAssembler::null_check(Register reg, int offset) {
2583   if (needs_explicit_null_check(offset)) {
2584     // provoke OS NULL exception if reg = NULL by
2585     // accessing M[reg] w/o changing any (non-CC) registers
2586     // NOTE: cmpl is plenty here to provoke a segv
2587     cmpptr(rax, Address(reg, 0));
2588     // Note: should probably use testl(rax, Address(reg, 0));
2589     //       may be shorter code (however, this version of
2590     //       testl needs to be implemented first)
2591   } else {
2592     // nothing to do, (later) access of M[reg + offset]
2593     // will provoke OS NULL exception if reg = NULL
2594   }
2595 }
2596 
2597 void MacroAssembler::os_breakpoint() {
2598   // instead of directly emitting a breakpoint, call os:breakpoint for better debugability
2599   // (e.g., MSVC can&#39;t call ps() otherwise)
2600   call(RuntimeAddress(CAST_FROM_FN_PTR(address, os::breakpoint)));
2601 }
2602 
2603 void MacroAssembler::unimplemented(const char* what) {
2604   const char* buf = NULL;
2605   {
2606     ResourceMark rm;
2607     stringStream ss;
2608     ss.print(&quot;unimplemented: %s&quot;, what);
2609     buf = code_string(ss.as_string());
2610   }
2611   stop(buf);
2612 }
2613 
2614 #ifdef _LP64
2615 #define XSTATE_BV 0x200
2616 #endif
2617 
2618 void MacroAssembler::pop_CPU_state() {
2619   pop_FPU_state();
2620   pop_IU_state();
2621 }
2622 
2623 void MacroAssembler::pop_FPU_state() {
2624 #ifndef _LP64
2625   frstor(Address(rsp, 0));
2626 #else
2627   fxrstor(Address(rsp, 0));
2628 #endif
2629   addptr(rsp, FPUStateSizeInWords * wordSize);
2630 }
2631 
2632 void MacroAssembler::pop_IU_state() {
2633   popa();
2634   LP64_ONLY(addq(rsp, 8));
2635   popf();
2636 }
2637 
2638 // Save Integer and Float state
2639 // Warning: Stack must be 16 byte aligned (64bit)
2640 void MacroAssembler::push_CPU_state() {
2641   push_IU_state();
2642   push_FPU_state();
2643 }
2644 
2645 void MacroAssembler::push_FPU_state() {
2646   subptr(rsp, FPUStateSizeInWords * wordSize);
2647 #ifndef _LP64
2648   fnsave(Address(rsp, 0));
2649   fwait();
2650 #else
2651   fxsave(Address(rsp, 0));
2652 #endif // LP64
2653 }
2654 
2655 void MacroAssembler::push_IU_state() {
2656   // Push flags first because pusha kills them
2657   pushf();
2658   // Make sure rsp stays 16-byte aligned
2659   LP64_ONLY(subq(rsp, 8));
2660   pusha();
2661 }
2662 
2663 void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
2664   reset_last_Java_frame(r15_thread, clear_fp);
2665 }
2666 
2667 void MacroAssembler::reset_last_Java_frame(Register java_thread, bool clear_fp) { // determine java_thread register
2668   if (!java_thread-&gt;is_valid()) {
2669     java_thread = rdi;
2670     get_thread(java_thread);
2671   }
2672   // we must set sp to zero to clear frame
2673   movslq(Address(java_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
2674   // must clear fp, so that compiled frames are not confused; it is
2675   // possible that we need it only for debugging
2676   if (clear_fp) {
2677     movslq(Address(java_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
2678   }
2679   // Always clear the pc because it could have been set by make_walkable()
2680   movslq(Address(java_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
2681   vzeroupper();
2682 }
2683 
2684 void MacroAssembler::restore_rax(Register tmp) {
2685   if (tmp == noreg) pop(rax);
2686   else if (tmp != rax) mov(rax, tmp);
2687 }
2688 
2689 void MacroAssembler::round_to(Register reg, int modulus) {
2690   addptr(reg, modulus - 1);
2691   andptr(reg, -modulus);
2692 }
2693 
2694 void MacroAssembler::save_rax(Register tmp) {
2695   if (tmp == noreg) push(rax);
2696   else if (tmp != rax) mov(tmp, rax);
2697 }
2698 
2699 void MacroAssembler::safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg) {
2700 #ifdef _LP64
2701   assert(thread_reg == r15_thread, &quot;should be&quot;);
2702 #else
2703   if (thread_reg == noreg) {
2704     thread_reg = temp_reg;
2705     get_thread(thread_reg);
2706   }
2707 #endif
2708   testb(Address(thread_reg, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2709   jcc(Assembler::notZero, slow_path); // handshake bit set implies poll
2710 }
2711 
2712 // Calls to C land
2713 //
2714 // When entering C land, the rbp, &amp; rsp of the last Java frame have to be recorded
2715 // in the (thread-local) JavaThread object. When leaving C land, the last Java fp
2716 // has to be reset to 0. This is required to allow proper stack traversal.
2717 void MacroAssembler::set_last_Java_frame(Register java_thread,
2718                                          Register last_java_sp,
2719                                          Register last_java_fp,
2720                                          address  last_java_pc) {
2721   vzeroupper();
2722   // determine java_thread register
2723   if (!java_thread-&gt;is_valid()) {
2724     java_thread = rdi;
2725     get_thread(java_thread);
2726   }
2727   // determine last_java_sp register
2728   if (!last_java_sp-&gt;is_valid()) {
2729     last_java_sp = rsp;
2730   }
2731 
2732   // last_java_fp is optional
2733 
2734   if (last_java_fp-&gt;is_valid()) {
2735     movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), last_java_fp);
2736   }
2737 
2738   // last_java_pc is optional
2739 
2740   if (last_java_pc != NULL) {
2741     lea(Address(java_thread,
2742                  JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset()),
2743         InternalAddress(last_java_pc));
2744 
2745   }
2746   movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), last_java_sp);
2747 }
2748 
2749 void MacroAssembler::shlptr(Register dst, int imm8) {
2750   LP64_ONLY(shlq(dst, imm8)) NOT_LP64(shll(dst, imm8));
2751 }
2752 
2753 void MacroAssembler::shrptr(Register dst, int imm8) {
2754   LP64_ONLY(shrq(dst, imm8)) NOT_LP64(shrl(dst, imm8));
2755 }
2756 
2757 void MacroAssembler::sign_extend_byte(Register reg) {
2758   if (LP64_ONLY(true ||) (VM_Version::is_P6() &amp;&amp; reg-&gt;has_byte_register())) {
2759     movsbl(reg, reg); // movsxb
2760   } else {
2761     shll(reg, 24);
2762     sarl(reg, 24);
2763   }
2764 }
2765 
2766 void MacroAssembler::sign_extend_short(Register reg) {
2767   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2768     movswl(reg, reg); // movsxw
2769   } else {
2770     shll(reg, 16);
2771     sarl(reg, 16);
2772   }
2773 }
2774 
2775 void MacroAssembler::testl(Register dst, AddressLiteral src) {
2776   assert(reachable(src), &quot;Address should be reachable&quot;);
2777   testl(dst, as_Address(src));
2778 }
2779 
2780 void MacroAssembler::pcmpeqb(XMMRegister dst, XMMRegister src) {
2781   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2782   Assembler::pcmpeqb(dst, src);
2783 }
2784 
2785 void MacroAssembler::pcmpeqw(XMMRegister dst, XMMRegister src) {
2786   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2787   Assembler::pcmpeqw(dst, src);
2788 }
2789 
2790 void MacroAssembler::pcmpestri(XMMRegister dst, Address src, int imm8) {
2791   assert((dst-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2792   Assembler::pcmpestri(dst, src, imm8);
2793 }
2794 
2795 void MacroAssembler::pcmpestri(XMMRegister dst, XMMRegister src, int imm8) {
2796   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2797   Assembler::pcmpestri(dst, src, imm8);
2798 }
2799 
2800 void MacroAssembler::pmovzxbw(XMMRegister dst, XMMRegister src) {
2801   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2802   Assembler::pmovzxbw(dst, src);
2803 }
2804 
2805 void MacroAssembler::pmovzxbw(XMMRegister dst, Address src) {
2806   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2807   Assembler::pmovzxbw(dst, src);
2808 }
2809 
2810 void MacroAssembler::pmovmskb(Register dst, XMMRegister src) {
2811   assert((src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2812   Assembler::pmovmskb(dst, src);
2813 }
2814 
2815 void MacroAssembler::ptest(XMMRegister dst, XMMRegister src) {
2816   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2817   Assembler::ptest(dst, src);
2818 }
2819 
2820 void MacroAssembler::sqrtsd(XMMRegister dst, AddressLiteral src) {
2821   if (reachable(src)) {
2822     Assembler::sqrtsd(dst, as_Address(src));
2823   } else {
2824     lea(rscratch1, src);
2825     Assembler::sqrtsd(dst, Address(rscratch1, 0));
2826   }
2827 }
2828 
2829 void MacroAssembler::sqrtss(XMMRegister dst, AddressLiteral src) {
2830   if (reachable(src)) {
2831     Assembler::sqrtss(dst, as_Address(src));
2832   } else {
2833     lea(rscratch1, src);
2834     Assembler::sqrtss(dst, Address(rscratch1, 0));
2835   }
2836 }
2837 
2838 void MacroAssembler::subsd(XMMRegister dst, AddressLiteral src) {
2839   if (reachable(src)) {
2840     Assembler::subsd(dst, as_Address(src));
2841   } else {
2842     lea(rscratch1, src);
2843     Assembler::subsd(dst, Address(rscratch1, 0));
2844   }
2845 }
2846 
2847 void MacroAssembler::roundsd(XMMRegister dst, AddressLiteral src, int32_t rmode, Register scratch_reg) {
2848   if (reachable(src)) {
2849     Assembler::roundsd(dst, as_Address(src), rmode);
2850   } else {
2851     lea(scratch_reg, src);
2852     Assembler::roundsd(dst, Address(scratch_reg, 0), rmode);
2853   }
2854 }
2855 
2856 void MacroAssembler::subss(XMMRegister dst, AddressLiteral src) {
2857   if (reachable(src)) {
2858     Assembler::subss(dst, as_Address(src));
2859   } else {
2860     lea(rscratch1, src);
2861     Assembler::subss(dst, Address(rscratch1, 0));
2862   }
2863 }
2864 
2865 void MacroAssembler::ucomisd(XMMRegister dst, AddressLiteral src) {
2866   if (reachable(src)) {
2867     Assembler::ucomisd(dst, as_Address(src));
2868   } else {
2869     lea(rscratch1, src);
2870     Assembler::ucomisd(dst, Address(rscratch1, 0));
2871   }
2872 }
2873 
2874 void MacroAssembler::ucomiss(XMMRegister dst, AddressLiteral src) {
2875   if (reachable(src)) {
2876     Assembler::ucomiss(dst, as_Address(src));
2877   } else {
2878     lea(rscratch1, src);
2879     Assembler::ucomiss(dst, Address(rscratch1, 0));
2880   }
2881 }
2882 
2883 void MacroAssembler::xorpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
2884   // Used in sign-bit flipping with aligned address.
2885   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
2886   if (reachable(src)) {
2887     Assembler::xorpd(dst, as_Address(src));
2888   } else {
2889     lea(scratch_reg, src);
2890     Assembler::xorpd(dst, Address(scratch_reg, 0));
2891   }
2892 }
2893 
2894 void MacroAssembler::xorpd(XMMRegister dst, XMMRegister src) {
2895   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512dq() &amp;&amp; (dst-&gt;encoding() == src-&gt;encoding())) {
2896     Assembler::vpxor(dst, dst, src, Assembler::AVX_512bit);
2897   }
2898   else {
2899     Assembler::xorpd(dst, src);
2900   }
2901 }
2902 
2903 void MacroAssembler::xorps(XMMRegister dst, XMMRegister src) {
2904   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512dq() &amp;&amp; (dst-&gt;encoding() == src-&gt;encoding())) {
2905     Assembler::vpxor(dst, dst, src, Assembler::AVX_512bit);
2906   } else {
2907     Assembler::xorps(dst, src);
2908   }
2909 }
2910 
2911 void MacroAssembler::xorps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
2912   // Used in sign-bit flipping with aligned address.
2913   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
2914   if (reachable(src)) {
2915     Assembler::xorps(dst, as_Address(src));
2916   } else {
2917     lea(scratch_reg, src);
2918     Assembler::xorps(dst, Address(scratch_reg, 0));
2919   }
2920 }
2921 
2922 void MacroAssembler::pshufb(XMMRegister dst, AddressLiteral src) {
2923   // Used in sign-bit flipping with aligned address.
2924   bool aligned_adr = (((intptr_t)src.target() &amp; 15) == 0);
2925   assert((UseAVX &gt; 0) || aligned_adr, &quot;SSE mode requires address alignment 16 bytes&quot;);
2926   if (reachable(src)) {
2927     Assembler::pshufb(dst, as_Address(src));
2928   } else {
2929     lea(rscratch1, src);
2930     Assembler::pshufb(dst, Address(rscratch1, 0));
2931   }
2932 }
2933 
2934 // AVX 3-operands instructions
2935 
2936 void MacroAssembler::vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
2937   if (reachable(src)) {
2938     vaddsd(dst, nds, as_Address(src));
2939   } else {
2940     lea(rscratch1, src);
2941     vaddsd(dst, nds, Address(rscratch1, 0));
2942   }
2943 }
2944 
2945 void MacroAssembler::vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
2946   if (reachable(src)) {
2947     vaddss(dst, nds, as_Address(src));
2948   } else {
2949     lea(rscratch1, src);
2950     vaddss(dst, nds, Address(rscratch1, 0));
2951   }
2952 }
2953 
2954 void MacroAssembler::vpaddd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {
2955   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
2956   if (reachable(src)) {
2957     Assembler::vpaddd(dst, nds, as_Address(src), vector_len);
2958   } else {
2959     lea(rscratch, src);
2960     Assembler::vpaddd(dst, nds, Address(rscratch, 0), vector_len);
2961   }
2962 }
2963 
2964 void MacroAssembler::vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {
2965   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
2966   vandps(dst, nds, negate_field, vector_len);
2967 }
2968 
2969 void MacroAssembler::vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {
2970   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
2971   vandpd(dst, nds, negate_field, vector_len);
2972 }
2973 
2974 void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
2975   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2976   Assembler::vpaddb(dst, nds, src, vector_len);
2977 }
2978 
2979 void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
2980   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2981   Assembler::vpaddb(dst, nds, src, vector_len);
2982 }
2983 
2984 void MacroAssembler::vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
2985   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2986   Assembler::vpaddw(dst, nds, src, vector_len);
2987 }
2988 
2989 void MacroAssembler::vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
2990   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2991   Assembler::vpaddw(dst, nds, src, vector_len);
2992 }
2993 
2994 void MacroAssembler::vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
2995   if (reachable(src)) {
2996     Assembler::vpand(dst, nds, as_Address(src), vector_len);
2997   } else {
2998     lea(scratch_reg, src);
2999     Assembler::vpand(dst, nds, Address(scratch_reg, 0), vector_len);
3000   }
3001 }
3002 
3003 void MacroAssembler::vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len) {
3004   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3005   Assembler::vpbroadcastw(dst, src, vector_len);
3006 }
3007 
3008 void MacroAssembler::vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3009   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3010   Assembler::vpcmpeqb(dst, nds, src, vector_len);
3011 }
3012 
3013 void MacroAssembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3014   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3015   Assembler::vpcmpeqw(dst, nds, src, vector_len);
3016 }
3017 
3018 void MacroAssembler::vpmovzxbw(XMMRegister dst, Address src, int vector_len) {
3019   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3020   Assembler::vpmovzxbw(dst, src, vector_len);
3021 }
3022 
3023 void MacroAssembler::vpmovmskb(Register dst, XMMRegister src) {
3024   assert((src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
3025   Assembler::vpmovmskb(dst, src);
3026 }
3027 
3028 void MacroAssembler::vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3029   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3030   Assembler::vpmullw(dst, nds, src, vector_len);
3031 }
3032 
3033 void MacroAssembler::vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3034   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3035   Assembler::vpmullw(dst, nds, src, vector_len);
3036 }
3037 
3038 void MacroAssembler::vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3039   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3040   Assembler::vpsubb(dst, nds, src, vector_len);
3041 }
3042 
3043 void MacroAssembler::vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3044   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3045   Assembler::vpsubb(dst, nds, src, vector_len);
3046 }
3047 
3048 void MacroAssembler::vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3049   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3050   Assembler::vpsubw(dst, nds, src, vector_len);
3051 }
3052 
3053 void MacroAssembler::vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3054   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3055   Assembler::vpsubw(dst, nds, src, vector_len);
3056 }
3057 
3058 void MacroAssembler::vpsraw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3059   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3060   Assembler::vpsraw(dst, nds, shift, vector_len);
3061 }
3062 
3063 void MacroAssembler::vpsraw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3064   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3065   Assembler::vpsraw(dst, nds, shift, vector_len);
3066 }
3067 
3068 void MacroAssembler::evpsraq(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3069   assert(UseAVX &gt; 2,&quot;&quot;);
3070   if (!VM_Version::supports_avx512vl() &amp;&amp; vector_len &lt; 2) {
3071      vector_len = 2;
3072   }
3073   Assembler::evpsraq(dst, nds, shift, vector_len);
3074 }
3075 
3076 void MacroAssembler::evpsraq(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3077   assert(UseAVX &gt; 2,&quot;&quot;);
3078   if (!VM_Version::supports_avx512vl() &amp;&amp; vector_len &lt; 2) {
3079      vector_len = 2;
3080   }
3081   Assembler::evpsraq(dst, nds, shift, vector_len);
3082 }
3083 
3084 void MacroAssembler::vpsrlw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3085   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3086   Assembler::vpsrlw(dst, nds, shift, vector_len);
3087 }
3088 
3089 void MacroAssembler::vpsrlw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3090   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3091   Assembler::vpsrlw(dst, nds, shift, vector_len);
3092 }
3093 
3094 void MacroAssembler::vpsllw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3095   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3096   Assembler::vpsllw(dst, nds, shift, vector_len);
3097 }
3098 
3099 void MacroAssembler::vpsllw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3100   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3101   Assembler::vpsllw(dst, nds, shift, vector_len);
3102 }
3103 
3104 void MacroAssembler::vptest(XMMRegister dst, XMMRegister src) {
3105   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
3106   Assembler::vptest(dst, src);
3107 }
3108 
3109 void MacroAssembler::punpcklbw(XMMRegister dst, XMMRegister src) {
3110   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3111   Assembler::punpcklbw(dst, src);
3112 }
3113 
3114 void MacroAssembler::pshufd(XMMRegister dst, Address src, int mode) {
3115   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
3116   Assembler::pshufd(dst, src, mode);
3117 }
3118 
3119 void MacroAssembler::pshuflw(XMMRegister dst, XMMRegister src, int mode) {
3120   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3121   Assembler::pshuflw(dst, src, mode);
3122 }
3123 
3124 void MacroAssembler::vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3125   if (reachable(src)) {
3126     vandpd(dst, nds, as_Address(src), vector_len);
3127   } else {
3128     lea(scratch_reg, src);
3129     vandpd(dst, nds, Address(scratch_reg, 0), vector_len);
3130   }
3131 }
3132 
3133 void MacroAssembler::vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3134   if (reachable(src)) {
3135     vandps(dst, nds, as_Address(src), vector_len);
3136   } else {
3137     lea(scratch_reg, src);
3138     vandps(dst, nds, Address(scratch_reg, 0), vector_len);
3139   }
3140 }
3141 
3142 void MacroAssembler::vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3143   if (reachable(src)) {
3144     vdivsd(dst, nds, as_Address(src));
3145   } else {
3146     lea(rscratch1, src);
3147     vdivsd(dst, nds, Address(rscratch1, 0));
3148   }
3149 }
3150 
3151 void MacroAssembler::vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3152   if (reachable(src)) {
3153     vdivss(dst, nds, as_Address(src));
3154   } else {
3155     lea(rscratch1, src);
3156     vdivss(dst, nds, Address(rscratch1, 0));
3157   }
3158 }
3159 
3160 void MacroAssembler::vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3161   if (reachable(src)) {
3162     vmulsd(dst, nds, as_Address(src));
3163   } else {
3164     lea(rscratch1, src);
3165     vmulsd(dst, nds, Address(rscratch1, 0));
3166   }
3167 }
3168 
3169 void MacroAssembler::vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3170   if (reachable(src)) {
3171     vmulss(dst, nds, as_Address(src));
3172   } else {
3173     lea(rscratch1, src);
3174     vmulss(dst, nds, Address(rscratch1, 0));
3175   }
3176 }
3177 
3178 void MacroAssembler::vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3179   if (reachable(src)) {
3180     vsubsd(dst, nds, as_Address(src));
3181   } else {
3182     lea(rscratch1, src);
3183     vsubsd(dst, nds, Address(rscratch1, 0));
3184   }
3185 }
3186 
3187 void MacroAssembler::vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3188   if (reachable(src)) {
3189     vsubss(dst, nds, as_Address(src));
3190   } else {
3191     lea(rscratch1, src);
3192     vsubss(dst, nds, Address(rscratch1, 0));
3193   }
3194 }
3195 
3196 void MacroAssembler::vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3197   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3198   vxorps(dst, nds, src, Assembler::AVX_128bit);
3199 }
3200 
3201 void MacroAssembler::vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3202   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3203   vxorpd(dst, nds, src, Assembler::AVX_128bit);
3204 }
3205 
3206 void MacroAssembler::vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3207   if (reachable(src)) {
3208     vxorpd(dst, nds, as_Address(src), vector_len);
3209   } else {
3210     lea(scratch_reg, src);
3211     vxorpd(dst, nds, Address(scratch_reg, 0), vector_len);
3212   }
3213 }
3214 
3215 void MacroAssembler::vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3216   if (reachable(src)) {
3217     vxorps(dst, nds, as_Address(src), vector_len);
3218   } else {
3219     lea(scratch_reg, src);
3220     vxorps(dst, nds, Address(scratch_reg, 0), vector_len);
3221   }
3222 }
3223 
3224 void MacroAssembler::vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3225   if (UseAVX &gt; 1 || (vector_len &lt; 1)) {
3226     if (reachable(src)) {
3227       Assembler::vpxor(dst, nds, as_Address(src), vector_len);
3228     } else {
3229       lea(scratch_reg, src);
3230       Assembler::vpxor(dst, nds, Address(scratch_reg, 0), vector_len);
3231     }
3232   }
3233   else {
3234     MacroAssembler::vxorpd(dst, nds, src, vector_len, scratch_reg);
3235   }
3236 }
3237 
3238 //-------------------------------------------------------------------------------------------
3239 
3240 void MacroAssembler::clear_jweak_tag(Register possibly_jweak) {
3241   const int32_t inverted_jweak_mask = ~static_cast&lt;int32_t&gt;(JNIHandles::weak_tag_mask);
3242   STATIC_ASSERT(inverted_jweak_mask == -2); // otherwise check this code
3243   // The inverted mask is sign-extended
3244   andptr(possibly_jweak, inverted_jweak_mask);
3245 }
3246 
3247 void MacroAssembler::resolve_jobject(Register value,
3248                                      Register thread,
3249                                      Register tmp) {
3250   assert_different_registers(value, thread, tmp);
3251   Label done, not_weak;
3252   testptr(value, value);
3253   jcc(Assembler::zero, done);                // Use NULL as-is.
3254   testptr(value, JNIHandles::weak_tag_mask); // Test for jweak tag.
3255   jcc(Assembler::zero, not_weak);
3256   // Resolve jweak.
3257   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
3258                  value, Address(value, -JNIHandles::weak_tag_value), tmp, thread);
3259   verify_oop(value);
3260   jmp(done);
3261   bind(not_weak);
3262   // Resolve (untagged) jobject.
3263   access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);
3264   verify_oop(value);
3265   bind(done);
3266 }
3267 
3268 void MacroAssembler::subptr(Register dst, int32_t imm32) {
3269   LP64_ONLY(subq(dst, imm32)) NOT_LP64(subl(dst, imm32));
3270 }
3271 
3272 // Force generation of a 4 byte immediate value even if it fits into 8bit
3273 void MacroAssembler::subptr_imm32(Register dst, int32_t imm32) {
3274   LP64_ONLY(subq_imm32(dst, imm32)) NOT_LP64(subl_imm32(dst, imm32));
3275 }
3276 
3277 void MacroAssembler::subptr(Register dst, Register src) {
3278   LP64_ONLY(subq(dst, src)) NOT_LP64(subl(dst, src));
3279 }
3280 
3281 // C++ bool manipulation
3282 void MacroAssembler::testbool(Register dst) {
3283   if(sizeof(bool) == 1)
3284     testb(dst, 0xff);
3285   else if(sizeof(bool) == 2) {
3286     // testw implementation needed for two byte bools
3287     ShouldNotReachHere();
3288   } else if(sizeof(bool) == 4)
3289     testl(dst, dst);
3290   else
3291     // unsupported
3292     ShouldNotReachHere();
3293 }
3294 
3295 void MacroAssembler::testptr(Register dst, Register src) {
3296   LP64_ONLY(testq(dst, src)) NOT_LP64(testl(dst, src));
3297 }
3298 
3299 // Defines obj, preserves var_size_in_bytes, okay for t2 == var_size_in_bytes.
3300 void MacroAssembler::tlab_allocate(Register thread, Register obj,
3301                                    Register var_size_in_bytes,
3302                                    int con_size_in_bytes,
3303                                    Register t1,
3304                                    Register t2,
3305                                    Label&amp; slow_case) {
3306   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3307   bs-&gt;tlab_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);
3308 }
3309 
3310 // Defines obj, preserves var_size_in_bytes
3311 void MacroAssembler::eden_allocate(Register thread, Register obj,
3312                                    Register var_size_in_bytes,
3313                                    int con_size_in_bytes,
3314                                    Register t1,
3315                                    Label&amp; slow_case) {
3316   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3317   bs-&gt;eden_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, slow_case);
3318 }
3319 
3320 // Preserves the contents of address, destroys the contents length_in_bytes and temp.
3321 void MacroAssembler::zero_memory(Register address, Register length_in_bytes, int offset_in_bytes, Register temp) {
3322   assert(address != length_in_bytes &amp;&amp; address != temp &amp;&amp; temp != length_in_bytes, &quot;registers must be different&quot;);
3323   assert((offset_in_bytes &amp; (BytesPerWord - 1)) == 0, &quot;offset must be a multiple of BytesPerWord&quot;);
3324   Label done;
3325 
3326   testptr(length_in_bytes, length_in_bytes);
3327   jcc(Assembler::zero, done);
3328 
3329   // initialize topmost word, divide index by 2, check if odd and test if zero
3330   // note: for the remaining code to work, index must be a multiple of BytesPerWord
3331 #ifdef ASSERT
3332   {
3333     Label L;
3334     testptr(length_in_bytes, BytesPerWord - 1);
3335     jcc(Assembler::zero, L);
3336     stop(&quot;length must be a multiple of BytesPerWord&quot;);
3337     bind(L);
3338   }
3339 #endif
3340   Register index = length_in_bytes;
3341   xorptr(temp, temp);    // use _zero reg to clear memory (shorter code)
3342   if (UseIncDec) {
3343     shrptr(index, 3);  // divide by 8/16 and set carry flag if bit 2 was set
3344   } else {
3345     shrptr(index, 2);  // use 2 instructions to avoid partial flag stall
3346     shrptr(index, 1);
3347   }
3348 #ifndef _LP64
3349   // index could have not been a multiple of 8 (i.e., bit 2 was set)
3350   {
3351     Label even;
3352     // note: if index was a multiple of 8, then it cannot
3353     //       be 0 now otherwise it must have been 0 before
3354     //       =&gt; if it is even, we don&#39;t need to check for 0 again
3355     jcc(Assembler::carryClear, even);
3356     // clear topmost word (no jump would be needed if conditional assignment worked here)
3357     movptr(Address(address, index, Address::times_8, offset_in_bytes - 0*BytesPerWord), temp);
3358     // index could be 0 now, must check again
3359     jcc(Assembler::zero, done);
3360     bind(even);
3361   }
3362 #endif // !_LP64
3363   // initialize remaining object fields: index is a multiple of 2 now
3364   {
3365     Label loop;
3366     bind(loop);
3367     movptr(Address(address, index, Address::times_8, offset_in_bytes - 1*BytesPerWord), temp);
3368     NOT_LP64(movptr(Address(address, index, Address::times_8, offset_in_bytes - 2*BytesPerWord), temp);)
3369     decrement(index);
3370     jcc(Assembler::notZero, loop);
3371   }
3372 
3373   bind(done);
3374 }
3375 
3376 // Look up the method for a megamorphic invokeinterface call.
3377 // The target method is determined by &lt;intf_klass, itable_index&gt;.
3378 // The receiver klass is in recv_klass.
3379 // On success, the result will be in method_result, and execution falls through.
3380 // On failure, execution transfers to the given label.
3381 void MacroAssembler::lookup_interface_method(Register recv_klass,
3382                                              Register intf_klass,
3383                                              RegisterOrConstant itable_index,
3384                                              Register method_result,
3385                                              Register scan_temp,
3386                                              Label&amp; L_no_such_interface,
3387                                              bool return_method) {
3388   assert_different_registers(recv_klass, intf_klass, scan_temp);
3389   assert_different_registers(method_result, intf_klass, scan_temp);
3390   assert(recv_klass != method_result || !return_method,
3391          &quot;recv_klass can be destroyed when method isn&#39;t needed&quot;);
3392 
3393   assert(itable_index.is_constant() || itable_index.as_register() == method_result,
3394          &quot;caller must use same register for non-constant itable index as for method&quot;);
3395 
3396   // Compute start of first itableOffsetEntry (which is at the end of the vtable)
3397   int vtable_base = in_bytes(Klass::vtable_start_offset());
3398   int itentry_off = itableMethodEntry::method_offset_in_bytes();
3399   int scan_step   = itableOffsetEntry::size() * wordSize;
3400   int vte_size    = vtableEntry::size_in_bytes();
3401   Address::ScaleFactor times_vte_scale = Address::times_ptr;
3402   assert(vte_size == wordSize, &quot;else adjust times_vte_scale&quot;);
3403 
3404   movl(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));
3405 
3406   // %%% Could store the aligned, prescaled offset in the klassoop.
3407   lea(scan_temp, Address(recv_klass, scan_temp, times_vte_scale, vtable_base));
3408 
3409   if (return_method) {
3410     // Adjust recv_klass by scaled itable_index, so we can free itable_index.
3411     assert(itableMethodEntry::size() * wordSize == wordSize, &quot;adjust the scaling in the code below&quot;);
3412     lea(recv_klass, Address(recv_klass, itable_index, Address::times_ptr, itentry_off));
3413   }
3414 
3415   // for (scan = klass-&gt;itable(); scan-&gt;interface() != NULL; scan += scan_step) {
3416   //   if (scan-&gt;interface() == intf) {
3417   //     result = (klass + scan-&gt;offset() + itable_index);
3418   //   }
3419   // }
3420   Label search, found_method;
3421 
3422   for (int peel = 1; peel &gt;= 0; peel--) {
3423     movptr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));
3424     cmpptr(intf_klass, method_result);
3425 
3426     if (peel) {
3427       jccb(Assembler::equal, found_method);
3428     } else {
3429       jccb(Assembler::notEqual, search);
3430       // (invert the test to fall through to found_method...)
3431     }
3432 
3433     if (!peel)  break;
3434 
3435     bind(search);
3436 
3437     // Check that the previous entry is non-null.  A null entry means that
3438     // the receiver class doesn&#39;t implement the interface, and wasn&#39;t the
3439     // same as when the caller was compiled.
3440     testptr(method_result, method_result);
3441     jcc(Assembler::zero, L_no_such_interface);
3442     addptr(scan_temp, scan_step);
3443   }
3444 
3445   bind(found_method);
3446 
3447   if (return_method) {
3448     // Got a hit.
3449     movl(scan_temp, Address(scan_temp, itableOffsetEntry::offset_offset_in_bytes()));
3450     movptr(method_result, Address(recv_klass, scan_temp, Address::times_1));
3451   }
3452 }
3453 
3454 
3455 // virtual method calling
3456 void MacroAssembler::lookup_virtual_method(Register recv_klass,
3457                                            RegisterOrConstant vtable_index,
3458                                            Register method_result) {
3459   const int base = in_bytes(Klass::vtable_start_offset());
3460   assert(vtableEntry::size() * wordSize == wordSize, &quot;else adjust the scaling in the code below&quot;);
3461   Address vtable_entry_addr(recv_klass,
3462                             vtable_index, Address::times_ptr,
3463                             base + vtableEntry::method_offset_in_bytes());
3464   movptr(method_result, vtable_entry_addr);
3465 }
3466 
3467 
3468 void MacroAssembler::check_klass_subtype(Register sub_klass,
3469                            Register super_klass,
3470                            Register temp_reg,
3471                            Label&amp; L_success) {
3472   Label L_failure;
3473   check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &amp;L_success, &amp;L_failure, NULL);
3474   check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &amp;L_success, NULL);
3475   bind(L_failure);
3476 }
3477 
3478 
3479 void MacroAssembler::check_klass_subtype_fast_path(Register sub_klass,
3480                                                    Register super_klass,
3481                                                    Register temp_reg,
3482                                                    Label* L_success,
3483                                                    Label* L_failure,
3484                                                    Label* L_slow_path,
3485                                         RegisterOrConstant super_check_offset) {
3486   assert_different_registers(sub_klass, super_klass, temp_reg);
3487   bool must_load_sco = (super_check_offset.constant_or_zero() == -1);
3488   if (super_check_offset.is_register()) {
3489     assert_different_registers(sub_klass, super_klass,
3490                                super_check_offset.as_register());
3491   } else if (must_load_sco) {
3492     assert(temp_reg != noreg, &quot;supply either a temp or a register offset&quot;);
3493   }
3494 
3495   Label L_fallthrough;
3496   int label_nulls = 0;
3497   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
3498   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
3499   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
3500   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
3501 
3502   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
3503   int sco_offset = in_bytes(Klass::super_check_offset_offset());
3504   Address super_check_offset_addr(super_klass, sco_offset);
3505 
3506   // Hacked jcc, which &quot;knows&quot; that L_fallthrough, at least, is in
3507   // range of a jccb.  If this routine grows larger, reconsider at
3508   // least some of these.
3509 #define local_jcc(assembler_cond, label)                                \
3510   if (&amp;(label) == &amp;L_fallthrough)  jccb(assembler_cond, label);         \
3511   else                             jcc( assembler_cond, label) /*omit semi*/
3512 
3513   // Hacked jmp, which may only be used just before L_fallthrough.
3514 #define final_jmp(label)                                                \
3515   if (&amp;(label) == &amp;L_fallthrough) { /*do nothing*/ }                    \
3516   else                            jmp(label)                /*omit semi*/
3517 
3518   // If the pointers are equal, we are done (e.g., String[] elements).
3519   // This self-check enables sharing of secondary supertype arrays among
3520   // non-primary types such as array-of-interface.  Otherwise, each such
3521   // type would need its own customized SSA.
3522   // We move this check to the front of the fast path because many
3523   // type checks are in fact trivially successful in this manner,
3524   // so we get a nicely predicted branch right at the start of the check.
3525   cmpptr(sub_klass, super_klass);
3526   local_jcc(Assembler::equal, *L_success);
3527 
3528   // Check the supertype display:
3529   if (must_load_sco) {
3530     // Positive movl does right thing on LP64.
3531     movl(temp_reg, super_check_offset_addr);
3532     super_check_offset = RegisterOrConstant(temp_reg);
3533   }
3534   Address super_check_addr(sub_klass, super_check_offset, Address::times_1, 0);
3535   cmpptr(super_klass, super_check_addr); // load displayed supertype
3536 
3537   // This check has worked decisively for primary supers.
3538   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
3539   // (Secondary supers are interfaces and very deeply nested subtypes.)
3540   // This works in the same check above because of a tricky aliasing
3541   // between the super_cache and the primary super display elements.
3542   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
3543   // Note that the cache is updated below if it does not help us find
3544   // what we need immediately.
3545   // So if it was a primary super, we can just fail immediately.
3546   // Otherwise, it&#39;s the slow path for us (no success at this point).
3547 
3548   if (super_check_offset.is_register()) {
3549     local_jcc(Assembler::equal, *L_success);
3550     cmpl(super_check_offset.as_register(), sc_offset);
3551     if (L_failure == &amp;L_fallthrough) {
3552       local_jcc(Assembler::equal, *L_slow_path);
3553     } else {
3554       local_jcc(Assembler::notEqual, *L_failure);
3555       final_jmp(*L_slow_path);
3556     }
3557   } else if (super_check_offset.as_constant() == sc_offset) {
3558     // Need a slow path; fast failure is impossible.
3559     if (L_slow_path == &amp;L_fallthrough) {
3560       local_jcc(Assembler::equal, *L_success);
3561     } else {
3562       local_jcc(Assembler::notEqual, *L_slow_path);
3563       final_jmp(*L_success);
3564     }
3565   } else {
3566     // No slow path; it&#39;s a fast decision.
3567     if (L_failure == &amp;L_fallthrough) {
3568       local_jcc(Assembler::equal, *L_success);
3569     } else {
3570       local_jcc(Assembler::notEqual, *L_failure);
3571       final_jmp(*L_success);
3572     }
3573   }
3574 
3575   bind(L_fallthrough);
3576 
3577 #undef local_jcc
3578 #undef final_jmp
3579 }
3580 
3581 
3582 void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,
3583                                                    Register super_klass,
3584                                                    Register temp_reg,
3585                                                    Register temp2_reg,
3586                                                    Label* L_success,
3587                                                    Label* L_failure,
3588                                                    bool set_cond_codes) {
3589   assert_different_registers(sub_klass, super_klass, temp_reg);
3590   if (temp2_reg != noreg)
3591     assert_different_registers(sub_klass, super_klass, temp_reg, temp2_reg);
3592 #define IS_A_TEMP(reg) ((reg) == temp_reg || (reg) == temp2_reg)
3593 
3594   Label L_fallthrough;
3595   int label_nulls = 0;
3596   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
3597   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
3598   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
3599 
3600   // a couple of useful fields in sub_klass:
3601   int ss_offset = in_bytes(Klass::secondary_supers_offset());
3602   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
3603   Address secondary_supers_addr(sub_klass, ss_offset);
3604   Address super_cache_addr(     sub_klass, sc_offset);
3605 
3606   // Do a linear scan of the secondary super-klass chain.
3607   // This code is rarely used, so simplicity is a virtue here.
3608   // The repne_scan instruction uses fixed registers, which we must spill.
3609   // Don&#39;t worry too much about pre-existing connections with the input regs.
3610 
3611   assert(sub_klass != rax, &quot;killed reg&quot;); // killed by mov(rax, super)
3612   assert(sub_klass != rcx, &quot;killed reg&quot;); // killed by lea(rcx, &amp;pst_counter)
3613 
3614   // Get super_klass value into rax (even if it was in rdi or rcx).
3615   bool pushed_rax = false, pushed_rcx = false, pushed_rdi = false;
3616   if (super_klass != rax || UseCompressedOops) {
3617     if (!IS_A_TEMP(rax)) { push(rax); pushed_rax = true; }
3618     mov(rax, super_klass);
3619   }
3620   if (!IS_A_TEMP(rcx)) { push(rcx); pushed_rcx = true; }
3621   if (!IS_A_TEMP(rdi)) { push(rdi); pushed_rdi = true; }
3622 
3623 #ifndef PRODUCT
3624   int* pst_counter = &amp;SharedRuntime::_partial_subtype_ctr;
3625   ExternalAddress pst_counter_addr((address) pst_counter);
3626   NOT_LP64(  incrementl(pst_counter_addr) );
3627   LP64_ONLY( lea(rcx, pst_counter_addr) );
3628   LP64_ONLY( incrementl(Address(rcx, 0)) );
3629 #endif //PRODUCT
3630 
3631   // We will consult the secondary-super array.
3632   movptr(rdi, secondary_supers_addr);
3633   // Load the array length.  (Positive movl does right thing on LP64.)
3634   movl(rcx, Address(rdi, Array&lt;Klass*&gt;::length_offset_in_bytes()));
3635   // Skip to start of data.
3636   addptr(rdi, Array&lt;Klass*&gt;::base_offset_in_bytes());
3637 
3638   // Scan RCX words at [RDI] for an occurrence of RAX.
3639   // Set NZ/Z based on last compare.
3640   // Z flag value will not be set by &#39;repne&#39; if RCX == 0 since &#39;repne&#39; does
3641   // not change flags (only scas instruction which is repeated sets flags).
3642   // Set Z = 0 (not equal) before &#39;repne&#39; to indicate that class was not found.
3643 
3644     testptr(rax,rax); // Set Z = 0
3645     repne_scan();
3646 
3647   // Unspill the temp. registers:
3648   if (pushed_rdi)  pop(rdi);
3649   if (pushed_rcx)  pop(rcx);
3650   if (pushed_rax)  pop(rax);
3651 
3652   if (set_cond_codes) {
3653     // Special hack for the AD files:  rdi is guaranteed non-zero.
3654     assert(!pushed_rdi, &quot;rdi must be left non-NULL&quot;);
3655     // Also, the condition codes are properly set Z/NZ on succeed/failure.
3656   }
3657 
3658   if (L_failure == &amp;L_fallthrough)
3659         jccb(Assembler::notEqual, *L_failure);
3660   else  jcc(Assembler::notEqual, *L_failure);
3661 
3662   // Success.  Cache the super we found and proceed in triumph.
3663   movptr(super_cache_addr, super_klass);
3664 
3665   if (L_success != &amp;L_fallthrough) {
3666     jmp(*L_success);
3667   }
3668 
3669 #undef IS_A_TEMP
3670 
3671   bind(L_fallthrough);
3672 }
3673 
3674 void MacroAssembler::clinit_barrier(Register klass, Register thread, Label* L_fast_path, Label* L_slow_path) {
3675   assert(L_fast_path != NULL || L_slow_path != NULL, &quot;at least one is required&quot;);
3676 
3677   Label L_fallthrough;
3678   if (L_fast_path == NULL) {
3679     L_fast_path = &amp;L_fallthrough;
3680   } else if (L_slow_path == NULL) {
3681     L_slow_path = &amp;L_fallthrough;
3682   }
3683 
3684   // Fast path check: class is fully initialized
3685   cmpb(Address(klass, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
3686   jcc(Assembler::equal, *L_fast_path);
3687 
3688   // Fast path check: current thread is initializer thread
3689   cmpptr(thread, Address(klass, InstanceKlass::init_thread_offset()));
3690   if (L_slow_path == &amp;L_fallthrough) {
3691     jcc(Assembler::equal, *L_fast_path);
3692     bind(*L_slow_path);
3693   } else if (L_fast_path == &amp;L_fallthrough) {
3694     jcc(Assembler::notEqual, *L_slow_path);
3695     bind(*L_fast_path);
3696   } else {
3697     Unimplemented();
3698   }
3699 }
3700 
3701 void MacroAssembler::cmov32(Condition cc, Register dst, Address src) {
3702   if (VM_Version::supports_cmov()) {
3703     cmovl(cc, dst, src);
3704   } else {
3705     Label L;
3706     jccb(negate_condition(cc), L);
3707     movl(dst, src);
3708     bind(L);
3709   }
3710 }
3711 
3712 void MacroAssembler::cmov32(Condition cc, Register dst, Register src) {
3713   if (VM_Version::supports_cmov()) {
3714     cmovl(cc, dst, src);
3715   } else {
3716     Label L;
3717     jccb(negate_condition(cc), L);
3718     movl(dst, src);
3719     bind(L);
3720   }
3721 }
3722 
3723 void MacroAssembler::_verify_oop(Register reg, const char* s, const char* file, int line) {
3724   if (!VerifyOops) return;
3725 
3726   // Pass register number to verify_oop_subroutine
3727   const char* b = NULL;
3728   {
3729     ResourceMark rm;
3730     stringStream ss;
3731     ss.print(&quot;verify_oop: %s: %s (%s:%d)&quot;, reg-&gt;name(), s, file, line);
3732     b = code_string(ss.as_string());
3733   }
3734   BLOCK_COMMENT(&quot;verify_oop {&quot;);
3735 #ifdef _LP64
3736   push(rscratch1);                    // save r10, trashed by movptr()
3737 #endif
3738   push(rax);                          // save rax,
3739   push(reg);                          // pass register argument
3740   ExternalAddress buffer((address) b);
3741   // avoid using pushptr, as it modifies scratch registers
3742   // and our contract is not to modify anything
3743   movptr(rax, buffer.addr());
3744   push(rax);
3745   // call indirectly to solve generation ordering problem
3746   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
3747   call(rax);
3748   // Caller pops the arguments (oop, message) and restores rax, r10
3749   BLOCK_COMMENT(&quot;} verify_oop&quot;);
3750 }
3751 
3752 void MacroAssembler::vallones(XMMRegister dst, int vector_len) {
3753   if (UseAVX &gt; 2 &amp;&amp; (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl())) {
3754     vpternlogd(dst, 0xFF, dst, dst, vector_len);
3755   } else {
3756     assert(UseAVX &gt; 0, &quot;&quot;);
3757     vpcmpeqb(dst, dst, dst, vector_len);
3758   }
3759 }
3760 
3761 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
3762                                                       Register tmp,
3763                                                       int offset) {
3764   intptr_t value = *delayed_value_addr;
3765   if (value != 0)
3766     return RegisterOrConstant(value + offset);
3767 
3768   // load indirectly to solve generation ordering problem
3769   movptr(tmp, ExternalAddress((address) delayed_value_addr));
3770 
3771 #ifdef ASSERT
3772   { Label L;
3773     testptr(tmp, tmp);
3774     if (WizardMode) {
3775       const char* buf = NULL;
3776       {
3777         ResourceMark rm;
3778         stringStream ss;
3779         ss.print(&quot;DelayedValue=&quot; INTPTR_FORMAT, delayed_value_addr[1]);
3780         buf = code_string(ss.as_string());
3781       }
3782       jcc(Assembler::notZero, L);
3783       STOP(buf);
3784     } else {
3785       jccb(Assembler::notZero, L);
3786       hlt();
3787     }
3788     bind(L);
3789   }
3790 #endif
3791 
3792   if (offset != 0)
3793     addptr(tmp, offset);
3794 
3795   return RegisterOrConstant(tmp);
3796 }
3797 
3798 
3799 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
3800                                          int extra_slot_offset) {
3801   // cf. TemplateTable::prepare_invoke(), if (load_receiver).
3802   int stackElementSize = Interpreter::stackElementSize;
3803   int offset = Interpreter::expr_offset_in_bytes(extra_slot_offset+0);
3804 #ifdef ASSERT
3805   int offset1 = Interpreter::expr_offset_in_bytes(extra_slot_offset+1);
3806   assert(offset1 - offset == stackElementSize, &quot;correct arithmetic&quot;);
3807 #endif
3808   Register             scale_reg    = noreg;
3809   Address::ScaleFactor scale_factor = Address::no_scale;
3810   if (arg_slot.is_constant()) {
3811     offset += arg_slot.as_constant() * stackElementSize;
3812   } else {
3813     scale_reg    = arg_slot.as_register();
3814     scale_factor = Address::times(stackElementSize);
3815   }
3816   offset += wordSize;           // return PC is on stack
3817   return Address(rsp, scale_reg, scale_factor, offset);
3818 }
3819 
3820 
3821 void MacroAssembler::_verify_oop_addr(Address addr, const char* s, const char* file, int line) {
3822   if (!VerifyOops) return;
3823 
3824   // Address adjust(addr.base(), addr.index(), addr.scale(), addr.disp() + BytesPerWord);
3825   // Pass register number to verify_oop_subroutine
3826   const char* b = NULL;
3827   {
3828     ResourceMark rm;
3829     stringStream ss;
3830     ss.print(&quot;verify_oop_addr: %s (%s:%d)&quot;, s, file, line);
3831     b = code_string(ss.as_string());
3832   }
3833 #ifdef _LP64
3834   push(rscratch1);                    // save r10, trashed by movptr()
3835 #endif
3836   push(rax);                          // save rax,
3837   // addr may contain rsp so we will have to adjust it based on the push
3838   // we just did (and on 64 bit we do two pushes)
3839   // NOTE: 64bit seemed to have had a bug in that it did movq(addr, rax); which
3840   // stores rax into addr which is backwards of what was intended.
3841   if (addr.uses(rsp)) {
3842     lea(rax, addr);
3843     pushptr(Address(rax, LP64_ONLY(2 *) BytesPerWord));
3844   } else {
3845     pushptr(addr);
3846   }
3847 
3848   ExternalAddress buffer((address) b);
3849   // pass msg argument
3850   // avoid using pushptr, as it modifies scratch registers
3851   // and our contract is not to modify anything
3852   movptr(rax, buffer.addr());
3853   push(rax);
3854 
3855   // call indirectly to solve generation ordering problem
3856   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
3857   call(rax);
3858   // Caller pops the arguments (addr, message) and restores rax, r10.
3859 }
3860 
3861 void MacroAssembler::verify_tlab() {
3862 #ifdef ASSERT
3863   if (UseTLAB &amp;&amp; VerifyOops) {
3864     Label next, ok;
3865     Register t1 = rsi;
3866     Register thread_reg = NOT_LP64(rbx) LP64_ONLY(r15_thread);
3867 
3868     push(t1);
3869     NOT_LP64(push(thread_reg));
3870     NOT_LP64(get_thread(thread_reg));
3871 
3872     movptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_top_offset())));
3873     cmpptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_start_offset())));
3874     jcc(Assembler::aboveEqual, next);
3875     STOP(&quot;assert(top &gt;= start)&quot;);
3876     should_not_reach_here();
3877 
3878     bind(next);
3879     movptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_end_offset())));
3880     cmpptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_top_offset())));
3881     jcc(Assembler::aboveEqual, ok);
3882     STOP(&quot;assert(top &lt;= end)&quot;);
3883     should_not_reach_here();
3884 
3885     bind(ok);
3886     NOT_LP64(pop(thread_reg));
3887     pop(t1);
3888   }
3889 #endif
3890 }
3891 
3892 class ControlWord {
3893  public:
3894   int32_t _value;
3895 
3896   int  rounding_control() const        { return  (_value &gt;&gt; 10) &amp; 3      ; }
3897   int  precision_control() const       { return  (_value &gt;&gt;  8) &amp; 3      ; }
3898   bool precision() const               { return ((_value &gt;&gt;  5) &amp; 1) != 0; }
3899   bool underflow() const               { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
3900   bool overflow() const                { return ((_value &gt;&gt;  3) &amp; 1) != 0; }
3901   bool zero_divide() const             { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
3902   bool denormalized() const            { return ((_value &gt;&gt;  1) &amp; 1) != 0; }
3903   bool invalid() const                 { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
3904 
3905   void print() const {
3906     // rounding control
3907     const char* rc;
3908     switch (rounding_control()) {
3909       case 0: rc = &quot;round near&quot;; break;
3910       case 1: rc = &quot;round down&quot;; break;
3911       case 2: rc = &quot;round up  &quot;; break;
3912       case 3: rc = &quot;chop      &quot;; break;
3913     };
3914     // precision control
3915     const char* pc;
3916     switch (precision_control()) {
3917       case 0: pc = &quot;24 bits &quot;; break;
3918       case 1: pc = &quot;reserved&quot;; break;
3919       case 2: pc = &quot;53 bits &quot;; break;
3920       case 3: pc = &quot;64 bits &quot;; break;
3921     };
3922     // flags
3923     char f[9];
3924     f[0] = &#39; &#39;;
3925     f[1] = &#39; &#39;;
3926     f[2] = (precision   ()) ? &#39;P&#39; : &#39;p&#39;;
3927     f[3] = (underflow   ()) ? &#39;U&#39; : &#39;u&#39;;
3928     f[4] = (overflow    ()) ? &#39;O&#39; : &#39;o&#39;;
3929     f[5] = (zero_divide ()) ? &#39;Z&#39; : &#39;z&#39;;
3930     f[6] = (denormalized()) ? &#39;D&#39; : &#39;d&#39;;
3931     f[7] = (invalid     ()) ? &#39;I&#39; : &#39;i&#39;;
3932     f[8] = &#39;\x0&#39;;
3933     // output
3934     printf(&quot;%04x  masks = %s, %s, %s&quot;, _value &amp; 0xFFFF, f, rc, pc);
3935   }
3936 
3937 };
3938 
3939 class StatusWord {
3940  public:
3941   int32_t _value;
3942 
3943   bool busy() const                    { return ((_value &gt;&gt; 15) &amp; 1) != 0; }
3944   bool C3() const                      { return ((_value &gt;&gt; 14) &amp; 1) != 0; }
3945   bool C2() const                      { return ((_value &gt;&gt; 10) &amp; 1) != 0; }
3946   bool C1() const                      { return ((_value &gt;&gt;  9) &amp; 1) != 0; }
3947   bool C0() const                      { return ((_value &gt;&gt;  8) &amp; 1) != 0; }
3948   int  top() const                     { return  (_value &gt;&gt; 11) &amp; 7      ; }
3949   bool error_status() const            { return ((_value &gt;&gt;  7) &amp; 1) != 0; }
3950   bool stack_fault() const             { return ((_value &gt;&gt;  6) &amp; 1) != 0; }
3951   bool precision() const               { return ((_value &gt;&gt;  5) &amp; 1) != 0; }
3952   bool underflow() const               { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
3953   bool overflow() const                { return ((_value &gt;&gt;  3) &amp; 1) != 0; }
3954   bool zero_divide() const             { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
3955   bool denormalized() const            { return ((_value &gt;&gt;  1) &amp; 1) != 0; }
3956   bool invalid() const                 { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
3957 
3958   void print() const {
3959     // condition codes
3960     char c[5];
3961     c[0] = (C3()) ? &#39;3&#39; : &#39;-&#39;;
3962     c[1] = (C2()) ? &#39;2&#39; : &#39;-&#39;;
3963     c[2] = (C1()) ? &#39;1&#39; : &#39;-&#39;;
3964     c[3] = (C0()) ? &#39;0&#39; : &#39;-&#39;;
3965     c[4] = &#39;\x0&#39;;
3966     // flags
3967     char f[9];
3968     f[0] = (error_status()) ? &#39;E&#39; : &#39;-&#39;;
3969     f[1] = (stack_fault ()) ? &#39;S&#39; : &#39;-&#39;;
3970     f[2] = (precision   ()) ? &#39;P&#39; : &#39;-&#39;;
3971     f[3] = (underflow   ()) ? &#39;U&#39; : &#39;-&#39;;
3972     f[4] = (overflow    ()) ? &#39;O&#39; : &#39;-&#39;;
3973     f[5] = (zero_divide ()) ? &#39;Z&#39; : &#39;-&#39;;
3974     f[6] = (denormalized()) ? &#39;D&#39; : &#39;-&#39;;
3975     f[7] = (invalid     ()) ? &#39;I&#39; : &#39;-&#39;;
3976     f[8] = &#39;\x0&#39;;
3977     // output
3978     printf(&quot;%04x  flags = %s, cc =  %s, top = %d&quot;, _value &amp; 0xFFFF, f, c, top());
3979   }
3980 
3981 };
3982 
3983 class TagWord {
3984  public:
3985   int32_t _value;
3986 
3987   int tag_at(int i) const              { return (_value &gt;&gt; (i*2)) &amp; 3; }
3988 
3989   void print() const {
3990     printf(&quot;%04x&quot;, _value &amp; 0xFFFF);
3991   }
3992 
3993 };
3994 
3995 class FPU_Register {
3996  public:
3997   int32_t _m0;
3998   int32_t _m1;
3999   int16_t _ex;
4000 
4001   bool is_indefinite() const           {
4002     return _ex == -1 &amp;&amp; _m1 == (int32_t)0xC0000000 &amp;&amp; _m0 == 0;
4003   }
4004 
4005   void print() const {
4006     char  sign = (_ex &lt; 0) ? &#39;-&#39; : &#39;+&#39;;
4007     const char* kind = (_ex == 0x7FFF || _ex == (int16_t)-1) ? &quot;NaN&quot; : &quot;   &quot;;
4008     printf(&quot;%c%04hx.%08x%08x  %s&quot;, sign, _ex, _m1, _m0, kind);
4009   };
4010 
4011 };
4012 
4013 class FPU_State {
4014  public:
4015   enum {
4016     register_size       = 10,
4017     number_of_registers =  8,
4018     register_mask       =  7
4019   };
4020 
4021   ControlWord  _control_word;
4022   StatusWord   _status_word;
4023   TagWord      _tag_word;
4024   int32_t      _error_offset;
4025   int32_t      _error_selector;
4026   int32_t      _data_offset;
4027   int32_t      _data_selector;
4028   int8_t       _register[register_size * number_of_registers];
4029 
4030   int tag_for_st(int i) const          { return _tag_word.tag_at((_status_word.top() + i) &amp; register_mask); }
4031   FPU_Register* st(int i) const        { return (FPU_Register*)&amp;_register[register_size * i]; }
4032 
4033   const char* tag_as_string(int tag) const {
4034     switch (tag) {
4035       case 0: return &quot;valid&quot;;
4036       case 1: return &quot;zero&quot;;
4037       case 2: return &quot;special&quot;;
4038       case 3: return &quot;empty&quot;;
4039     }
4040     ShouldNotReachHere();
4041     return NULL;
4042   }
4043 
4044   void print() const {
4045     // print computation registers
4046     { int t = _status_word.top();
4047       for (int i = 0; i &lt; number_of_registers; i++) {
4048         int j = (i - t) &amp; register_mask;
4049         printf(&quot;%c r%d = ST%d = &quot;, (j == 0 ? &#39;*&#39; : &#39; &#39;), i, j);
4050         st(j)-&gt;print();
4051         printf(&quot; %s\n&quot;, tag_as_string(_tag_word.tag_at(i)));
4052       }
4053     }
4054     printf(&quot;\n&quot;);
4055     // print control registers
4056     printf(&quot;ctrl = &quot;); _control_word.print(); printf(&quot;\n&quot;);
4057     printf(&quot;stat = &quot;); _status_word .print(); printf(&quot;\n&quot;);
4058     printf(&quot;tags = &quot;); _tag_word    .print(); printf(&quot;\n&quot;);
4059   }
4060 
4061 };
4062 
4063 class Flag_Register {
4064  public:
4065   int32_t _value;
4066 
4067   bool overflow() const                { return ((_value &gt;&gt; 11) &amp; 1) != 0; }
4068   bool direction() const               { return ((_value &gt;&gt; 10) &amp; 1) != 0; }
4069   bool sign() const                    { return ((_value &gt;&gt;  7) &amp; 1) != 0; }
4070   bool zero() const                    { return ((_value &gt;&gt;  6) &amp; 1) != 0; }
4071   bool auxiliary_carry() const         { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
4072   bool parity() const                  { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
4073   bool carry() const                   { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
4074 
4075   void print() const {
4076     // flags
4077     char f[8];
4078     f[0] = (overflow       ()) ? &#39;O&#39; : &#39;-&#39;;
4079     f[1] = (direction      ()) ? &#39;D&#39; : &#39;-&#39;;
4080     f[2] = (sign           ()) ? &#39;S&#39; : &#39;-&#39;;
4081     f[3] = (zero           ()) ? &#39;Z&#39; : &#39;-&#39;;
4082     f[4] = (auxiliary_carry()) ? &#39;A&#39; : &#39;-&#39;;
4083     f[5] = (parity         ()) ? &#39;P&#39; : &#39;-&#39;;
4084     f[6] = (carry          ()) ? &#39;C&#39; : &#39;-&#39;;
4085     f[7] = &#39;\x0&#39;;
4086     // output
4087     printf(&quot;%08x  flags = %s&quot;, _value, f);
4088   }
4089 
4090 };
4091 
4092 class IU_Register {
4093  public:
4094   int32_t _value;
4095 
4096   void print() const {
4097     printf(&quot;%08x  %11d&quot;, _value, _value);
4098   }
4099 
4100 };
4101 
4102 class IU_State {
4103  public:
4104   Flag_Register _eflags;
4105   IU_Register   _rdi;
4106   IU_Register   _rsi;
4107   IU_Register   _rbp;
4108   IU_Register   _rsp;
4109   IU_Register   _rbx;
4110   IU_Register   _rdx;
4111   IU_Register   _rcx;
4112   IU_Register   _rax;
4113 
4114   void print() const {
4115     // computation registers
4116     printf(&quot;rax,  = &quot;); _rax.print(); printf(&quot;\n&quot;);
4117     printf(&quot;rbx,  = &quot;); _rbx.print(); printf(&quot;\n&quot;);
4118     printf(&quot;rcx  = &quot;); _rcx.print(); printf(&quot;\n&quot;);
4119     printf(&quot;rdx  = &quot;); _rdx.print(); printf(&quot;\n&quot;);
4120     printf(&quot;rdi  = &quot;); _rdi.print(); printf(&quot;\n&quot;);
4121     printf(&quot;rsi  = &quot;); _rsi.print(); printf(&quot;\n&quot;);
4122     printf(&quot;rbp,  = &quot;); _rbp.print(); printf(&quot;\n&quot;);
4123     printf(&quot;rsp  = &quot;); _rsp.print(); printf(&quot;\n&quot;);
4124     printf(&quot;\n&quot;);
4125     // control registers
4126     printf(&quot;flgs = &quot;); _eflags.print(); printf(&quot;\n&quot;);
4127   }
4128 };
4129 
4130 
4131 class CPU_State {
4132  public:
4133   FPU_State _fpu_state;
4134   IU_State  _iu_state;
4135 
4136   void print() const {
4137     printf(&quot;--------------------------------------------------\n&quot;);
4138     _iu_state .print();
4139     printf(&quot;\n&quot;);
4140     _fpu_state.print();
4141     printf(&quot;--------------------------------------------------\n&quot;);
4142   }
4143 
4144 };
4145 
4146 
4147 static void _print_CPU_state(CPU_State* state) {
4148   state-&gt;print();
4149 };
4150 
4151 
4152 void MacroAssembler::print_CPU_state() {
4153   push_CPU_state();
4154   push(rsp);                // pass CPU state
4155   call(RuntimeAddress(CAST_FROM_FN_PTR(address, _print_CPU_state)));
4156   addptr(rsp, wordSize);       // discard argument
4157   pop_CPU_state();
4158 }
4159 
4160 
4161 #ifndef _LP64
4162 static bool _verify_FPU(int stack_depth, char* s, CPU_State* state) {
4163   static int counter = 0;
4164   FPU_State* fs = &amp;state-&gt;_fpu_state;
4165   counter++;
4166   // For leaf calls, only verify that the top few elements remain empty.
4167   // We only need 1 empty at the top for C2 code.
4168   if( stack_depth &lt; 0 ) {
4169     if( fs-&gt;tag_for_st(7) != 3 ) {
4170       printf(&quot;FPR7 not empty\n&quot;);
4171       state-&gt;print();
4172       assert(false, &quot;error&quot;);
4173       return false;
4174     }
4175     return true;                // All other stack states do not matter
4176   }
4177 
4178   assert((fs-&gt;_control_word._value &amp; 0xffff) == StubRoutines::_fpu_cntrl_wrd_std,
4179          &quot;bad FPU control word&quot;);
4180 
4181   // compute stack depth
4182   int i = 0;
4183   while (i &lt; FPU_State::number_of_registers &amp;&amp; fs-&gt;tag_for_st(i)  &lt; 3) i++;
4184   int d = i;
4185   while (i &lt; FPU_State::number_of_registers &amp;&amp; fs-&gt;tag_for_st(i) == 3) i++;
4186   // verify findings
4187   if (i != FPU_State::number_of_registers) {
4188     // stack not contiguous
4189     printf(&quot;%s: stack not contiguous at ST%d\n&quot;, s, i);
4190     state-&gt;print();
4191     assert(false, &quot;error&quot;);
4192     return false;
4193   }
4194   // check if computed stack depth corresponds to expected stack depth
4195   if (stack_depth &lt; 0) {
4196     // expected stack depth is -stack_depth or less
4197     if (d &gt; -stack_depth) {
4198       // too many elements on the stack
4199       printf(&quot;%s: &lt;= %d stack elements expected but found %d\n&quot;, s, -stack_depth, d);
4200       state-&gt;print();
4201       assert(false, &quot;error&quot;);
4202       return false;
4203     }
4204   } else {
4205     // expected stack depth is stack_depth
4206     if (d != stack_depth) {
4207       // wrong stack depth
4208       printf(&quot;%s: %d stack elements expected but found %d\n&quot;, s, stack_depth, d);
4209       state-&gt;print();
4210       assert(false, &quot;error&quot;);
4211       return false;
4212     }
4213   }
4214   // everything is cool
4215   return true;
4216 }
4217 
4218 void MacroAssembler::verify_FPU(int stack_depth, const char* s) {
4219   if (!VerifyFPU) return;
4220   push_CPU_state();
4221   push(rsp);                // pass CPU state
4222   ExternalAddress msg((address) s);
4223   // pass message string s
4224   pushptr(msg.addr());
4225   push(stack_depth);        // pass stack depth
4226   call(RuntimeAddress(CAST_FROM_FN_PTR(address, _verify_FPU)));
4227   addptr(rsp, 3 * wordSize);   // discard arguments
4228   // check for error
4229   { Label L;
4230     testl(rax, rax);
4231     jcc(Assembler::notZero, L);
4232     int3();                  // break if error condition
4233     bind(L);
4234   }
4235   pop_CPU_state();
4236 }
4237 #endif // _LP64
4238 
4239 void MacroAssembler::restore_cpu_control_state_after_jni() {
4240   // Either restore the MXCSR register after returning from the JNI Call
4241   // or verify that it wasn&#39;t changed (with -Xcheck:jni flag).
4242   if (VM_Version::supports_sse()) {
4243     if (RestoreMXCSROnJNICalls) {
4244       ldmxcsr(ExternalAddress(StubRoutines::addr_mxcsr_std()));
4245     } else if (CheckJNICalls) {
4246       call(RuntimeAddress(StubRoutines::x86::verify_mxcsr_entry()));
4247     }
4248   }
4249   // Clear upper bits of YMM registers to avoid SSE &lt;-&gt; AVX transition penalty.
4250   vzeroupper();
4251   // Reset k1 to 0xffff.
4252 
4253 #ifdef COMPILER2
4254   if (PostLoopMultiversioning &amp;&amp; VM_Version::supports_evex()) {
4255     push(rcx);
4256     movl(rcx, 0xffff);
4257     kmovwl(k1, rcx);
4258     pop(rcx);
4259   }
4260 #endif // COMPILER2
4261 
4262 #ifndef _LP64
4263   // Either restore the x87 floating pointer control word after returning
4264   // from the JNI call or verify that it wasn&#39;t changed.
4265   if (CheckJNICalls) {
4266     call(RuntimeAddress(StubRoutines::x86::verify_fpu_cntrl_wrd_entry()));
4267   }
4268 #endif // _LP64
4269 }
4270 
4271 // ((OopHandle)result).resolve();
4272 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
4273   assert_different_registers(result, tmp);
4274 
4275   // Only 64 bit platforms support GCs that require a tmp register
4276   // Only IN_HEAP loads require a thread_tmp register
4277   // OopHandle::resolve is an indirection like jobject.
4278   access_load_at(T_OBJECT, IN_NATIVE,
4279                  result, Address(result, 0), tmp, /*tmp_thread*/noreg);
4280 }
4281 
4282 // ((WeakHandle)result).resolve();
4283 void MacroAssembler::resolve_weak_handle(Register rresult, Register rtmp) {
4284   assert_different_registers(rresult, rtmp);
4285   Label resolved;
4286 
4287   // A null weak handle resolves to null.
4288   cmpptr(rresult, 0);
4289   jcc(Assembler::equal, resolved);
4290 
4291   // Only 64 bit platforms support GCs that require a tmp register
4292   // Only IN_HEAP loads require a thread_tmp register
4293   // WeakHandle::resolve is an indirection like jweak.
4294   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
4295                  rresult, Address(rresult, 0), rtmp, /*tmp_thread*/noreg);
4296   bind(resolved);
4297 }
4298 
4299 void MacroAssembler::load_mirror(Register mirror, Register method, Register tmp) {
4300   // get mirror
4301   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
4302   load_method_holder(mirror, method);
4303   movptr(mirror, Address(mirror, mirror_offset));
4304   resolve_oop_handle(mirror, tmp);
4305 }
4306 
4307 void MacroAssembler::load_method_holder_cld(Register rresult, Register rmethod) {
4308   load_method_holder(rresult, rmethod);
4309   movptr(rresult, Address(rresult, InstanceKlass::class_loader_data_offset()));
4310 }
4311 
4312 void MacroAssembler::load_method_holder(Register holder, Register method) {
4313   movptr(holder, Address(method, Method::const_offset()));                      // ConstMethod*
4314   movptr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*
4315   movptr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*
4316 }
4317 
4318 void MacroAssembler::load_klass(Register dst, Register src, Register tmp) {
4319   assert_different_registers(src, tmp);
4320   assert_different_registers(dst, tmp);
4321 #ifdef _LP64
4322   if (UseCompressedClassPointers) {
4323     movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));
4324     decode_klass_not_null(dst, tmp);
4325   } else
4326 #endif
4327     movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
4328 }
4329 
4330 void MacroAssembler::load_prototype_header(Register dst, Register src, Register tmp) {
4331   load_klass(dst, src, tmp);
4332   movptr(dst, Address(dst, Klass::prototype_header_offset()));
4333 }
4334 
4335 void MacroAssembler::store_klass(Register dst, Register src, Register tmp) {
4336   assert_different_registers(src, tmp);
4337   assert_different_registers(dst, tmp);
4338 #ifdef _LP64
4339   if (UseCompressedClassPointers) {
4340     encode_klass_not_null(src, tmp);
4341     movl(Address(dst, oopDesc::klass_offset_in_bytes()), src);
4342   } else
4343 #endif
4344     movptr(Address(dst, oopDesc::klass_offset_in_bytes()), src);
4345 }
4346 
4347 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
4348                                     Register tmp1, Register thread_tmp) {
4349   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4350   decorators = AccessInternal::decorator_fixup(decorators);
4351   bool as_raw = (decorators &amp; AS_RAW) != 0;
4352   if (as_raw) {
4353     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4354   } else {
4355     bs-&gt;load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4356   }
4357 }
4358 
4359 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
4360                                      Register tmp1, Register tmp2) {
4361   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4362   decorators = AccessInternal::decorator_fixup(decorators);
4363   bool as_raw = (decorators &amp; AS_RAW) != 0;
4364   if (as_raw) {
4365     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, tmp2);
4366   } else {
4367     bs-&gt;store_at(this, decorators, type, dst, src, tmp1, tmp2);
4368   }
4369 }
4370 
4371 void MacroAssembler::resolve(DecoratorSet decorators, Register obj) {
4372   // Use stronger ACCESS_WRITE|ACCESS_READ by default.
4373   if ((decorators &amp; (ACCESS_READ | ACCESS_WRITE)) == 0) {
4374     decorators |= ACCESS_READ | ACCESS_WRITE;
4375   }
4376   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4377   return bs-&gt;resolve(this, decorators, obj);
4378 }
4379 
4380 void MacroAssembler::load_heap_oop(Register dst, Address src, Register tmp1,
4381                                    Register thread_tmp, DecoratorSet decorators) {
4382   access_load_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);
4383 }
4384 
4385 // Doesn&#39;t do verfication, generates fixed size code
4386 void MacroAssembler::load_heap_oop_not_null(Register dst, Address src, Register tmp1,
4387                                             Register thread_tmp, DecoratorSet decorators) {
4388   access_load_at(T_OBJECT, IN_HEAP | IS_NOT_NULL | decorators, dst, src, tmp1, thread_tmp);
4389 }
4390 
4391 void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,
4392                                     Register tmp2, DecoratorSet decorators) {
4393   access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, tmp2);
4394 }
4395 
4396 // Used for storing NULLs.
4397 void MacroAssembler::store_heap_oop_null(Address dst) {
4398   access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg);
4399 }
4400 
4401 #ifdef _LP64
4402 void MacroAssembler::store_klass_gap(Register dst, Register src) {
4403   if (UseCompressedClassPointers) {
4404     // Store to klass gap in destination
4405     movl(Address(dst, oopDesc::klass_gap_offset_in_bytes()), src);
4406   }
4407 }
4408 
4409 #ifdef ASSERT
4410 void MacroAssembler::verify_heapbase(const char* msg) {
4411   assert (UseCompressedOops, &quot;should be compressed&quot;);
4412   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4413   if (CheckCompressedOops) {
4414     Label ok;
4415     push(rscratch1); // cmpptr trashes rscratch1
4416     cmpptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
4417     jcc(Assembler::equal, ok);
4418     STOP(msg);
4419     bind(ok);
4420     pop(rscratch1);
4421   }
4422 }
4423 #endif
4424 
4425 // Algorithm must match oop.inline.hpp encode_heap_oop.
4426 void MacroAssembler::encode_heap_oop(Register r) {
4427 #ifdef ASSERT
4428   verify_heapbase(&quot;MacroAssembler::encode_heap_oop: heap base corrupted?&quot;);
4429 #endif
4430   verify_oop_msg(r, &quot;broken oop in encode_heap_oop&quot;);
4431   if (CompressedOops::base() == NULL) {
4432     if (CompressedOops::shift() != 0) {
4433       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4434       shrq(r, LogMinObjAlignmentInBytes);
4435     }
4436     return;
4437   }
4438   testq(r, r);
4439   cmovq(Assembler::equal, r, r12_heapbase);
4440   subq(r, r12_heapbase);
4441   shrq(r, LogMinObjAlignmentInBytes);
4442 }
4443 
4444 void MacroAssembler::encode_heap_oop_not_null(Register r) {
4445 #ifdef ASSERT
4446   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null: heap base corrupted?&quot;);
4447   if (CheckCompressedOops) {
4448     Label ok;
4449     testq(r, r);
4450     jcc(Assembler::notEqual, ok);
4451     STOP(&quot;null oop passed to encode_heap_oop_not_null&quot;);
4452     bind(ok);
4453   }
4454 #endif
4455   verify_oop_msg(r, &quot;broken oop in encode_heap_oop_not_null&quot;);
4456   if (CompressedOops::base() != NULL) {
4457     subq(r, r12_heapbase);
4458   }
4459   if (CompressedOops::shift() != 0) {
4460     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4461     shrq(r, LogMinObjAlignmentInBytes);
4462   }
4463 }
4464 
4465 void MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {
4466 #ifdef ASSERT
4467   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null2: heap base corrupted?&quot;);
4468   if (CheckCompressedOops) {
4469     Label ok;
4470     testq(src, src);
4471     jcc(Assembler::notEqual, ok);
4472     STOP(&quot;null oop passed to encode_heap_oop_not_null2&quot;);
4473     bind(ok);
4474   }
4475 #endif
4476   verify_oop_msg(src, &quot;broken oop in encode_heap_oop_not_null2&quot;);
4477   if (dst != src) {
4478     movq(dst, src);
4479   }
4480   if (CompressedOops::base() != NULL) {
4481     subq(dst, r12_heapbase);
4482   }
4483   if (CompressedOops::shift() != 0) {
4484     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4485     shrq(dst, LogMinObjAlignmentInBytes);
4486   }
4487 }
4488 
4489 void  MacroAssembler::decode_heap_oop(Register r) {
4490 #ifdef ASSERT
4491   verify_heapbase(&quot;MacroAssembler::decode_heap_oop: heap base corrupted?&quot;);
4492 #endif
4493   if (CompressedOops::base() == NULL) {
4494     if (CompressedOops::shift() != 0) {
4495       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4496       shlq(r, LogMinObjAlignmentInBytes);
4497     }
4498   } else {
4499     Label done;
4500     shlq(r, LogMinObjAlignmentInBytes);
4501     jccb(Assembler::equal, done);
4502     addq(r, r12_heapbase);
4503     bind(done);
4504   }
4505   verify_oop_msg(r, &quot;broken oop in decode_heap_oop&quot;);
4506 }
4507 
4508 void  MacroAssembler::decode_heap_oop_not_null(Register r) {
4509   // Note: it will change flags
4510   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4511   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4512   // Cannot assert, unverified entry point counts instructions (see .ad file)
4513   // vtableStubs also counts instructions in pd_code_size_limit.
4514   // Also do not verify_oop as this is called by verify_oop.
4515   if (CompressedOops::shift() != 0) {
4516     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4517     shlq(r, LogMinObjAlignmentInBytes);
4518     if (CompressedOops::base() != NULL) {
4519       addq(r, r12_heapbase);
4520     }
4521   } else {
4522     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
4523   }
4524 }
4525 
4526 void  MacroAssembler::decode_heap_oop_not_null(Register dst, Register src) {
4527   // Note: it will change flags
4528   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4529   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4530   // Cannot assert, unverified entry point counts instructions (see .ad file)
4531   // vtableStubs also counts instructions in pd_code_size_limit.
4532   // Also do not verify_oop as this is called by verify_oop.
4533   if (CompressedOops::shift() != 0) {
4534     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4535     if (LogMinObjAlignmentInBytes == Address::times_8) {
4536       leaq(dst, Address(r12_heapbase, src, Address::times_8, 0));
4537     } else {
4538       if (dst != src) {
4539         movq(dst, src);
4540       }
4541       shlq(dst, LogMinObjAlignmentInBytes);
4542       if (CompressedOops::base() != NULL) {
4543         addq(dst, r12_heapbase);
4544       }
4545     }
4546   } else {
4547     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
4548     if (dst != src) {
4549       movq(dst, src);
4550     }
4551   }
4552 }
4553 
4554 void MacroAssembler::encode_klass_not_null(Register r, Register tmp) {
4555   assert_different_registers(r, tmp);
4556   if (CompressedKlassPointers::base() != NULL) {
4557     mov64(tmp, (int64_t)CompressedKlassPointers::base());
4558     subq(r, tmp);
4559   }
4560   if (CompressedKlassPointers::shift() != 0) {
4561     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4562     shrq(r, LogKlassAlignmentInBytes);
4563   }
4564 }
4565 
4566 void MacroAssembler::encode_and_move_klass_not_null(Register dst, Register src) {
4567   assert_different_registers(src, dst);
4568   if (CompressedKlassPointers::base() != NULL) {
4569     mov64(dst, -(int64_t)CompressedKlassPointers::base());
4570     addq(dst, src);
4571   } else {
4572     movptr(dst, src);
4573   }
4574   if (CompressedKlassPointers::shift() != 0) {
4575     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4576     shrq(dst, LogKlassAlignmentInBytes);
4577   }
4578 }
4579 
4580 // !!! If the instructions that get generated here change then function
4581 // instr_size_for_decode_klass_not_null() needs to get updated.
4582 void  MacroAssembler::decode_klass_not_null(Register r, Register tmp) {
4583   assert_different_registers(r, tmp);
4584   // Note: it will change flags
4585   assert(UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4586   // Cannot assert, unverified entry point counts instructions (see .ad file)
4587   // vtableStubs also counts instructions in pd_code_size_limit.
4588   // Also do not verify_oop as this is called by verify_oop.
4589   if (CompressedKlassPointers::shift() != 0) {
4590     assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4591     shlq(r, LogKlassAlignmentInBytes);
4592   }
4593   if (CompressedKlassPointers::base() != NULL) {
4594     mov64(tmp, (int64_t)CompressedKlassPointers::base());
4595     addq(r, tmp);
4596   }
4597 }
4598 
4599 void  MacroAssembler::decode_and_move_klass_not_null(Register dst, Register src) {
4600   assert_different_registers(src, dst);
4601   // Note: it will change flags
4602   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4603   // Cannot assert, unverified entry point counts instructions (see .ad file)
4604   // vtableStubs also counts instructions in pd_code_size_limit.
4605   // Also do not verify_oop as this is called by verify_oop.
4606 
4607   if (CompressedKlassPointers::base() == NULL &amp;&amp;
4608       CompressedKlassPointers::shift() == 0) {
4609     // The best case scenario is that there is no base or shift. Then it is already
4610     // a pointer that needs nothing but a register rename.
4611     movl(dst, src);
4612   } else {
4613     if (CompressedKlassPointers::base() != NULL) {
4614       mov64(dst, (int64_t)CompressedKlassPointers::base());
4615     } else {
4616       xorq(dst, dst);
4617     }
4618     if (CompressedKlassPointers::shift() != 0) {
4619       assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4620       assert(LogKlassAlignmentInBytes == Address::times_8, &quot;klass not aligned on 64bits?&quot;);
4621       leaq(dst, Address(dst, src, Address::times_8, 0));
4622     } else {
4623       addq(dst, src);
4624     }
4625   }
4626 }
4627 
4628 void  MacroAssembler::set_narrow_oop(Register dst, jobject obj) {
4629   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4630   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4631   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4632   int oop_index = oop_recorder()-&gt;find_index(obj);
4633   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4634   mov_narrow_oop(dst, oop_index, rspec);
4635 }
4636 
4637 void  MacroAssembler::set_narrow_oop(Address dst, jobject obj) {
4638   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4639   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4640   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4641   int oop_index = oop_recorder()-&gt;find_index(obj);
4642   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4643   mov_narrow_oop(dst, oop_index, rspec);
4644 }
4645 
4646 void  MacroAssembler::set_narrow_klass(Register dst, Klass* k) {
4647   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4648   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4649   int klass_index = oop_recorder()-&gt;find_index(k);
4650   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
4651   mov_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
4652 }
4653 
4654 void  MacroAssembler::set_narrow_klass(Address dst, Klass* k) {
4655   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4656   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4657   int klass_index = oop_recorder()-&gt;find_index(k);
4658   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
4659   mov_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
4660 }
4661 
4662 void  MacroAssembler::cmp_narrow_oop(Register dst, jobject obj) {
4663   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4664   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4665   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4666   int oop_index = oop_recorder()-&gt;find_index(obj);
4667   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4668   Assembler::cmp_narrow_oop(dst, oop_index, rspec);
4669 }
4670 
4671 void  MacroAssembler::cmp_narrow_oop(Address dst, jobject obj) {
4672   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4673   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4674   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4675   int oop_index = oop_recorder()-&gt;find_index(obj);
4676   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4677   Assembler::cmp_narrow_oop(dst, oop_index, rspec);
4678 }
4679 
4680 void  MacroAssembler::cmp_narrow_klass(Register dst, Klass* k) {
4681   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4682   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4683   int klass_index = oop_recorder()-&gt;find_index(k);
4684   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
4685   Assembler::cmp_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
4686 }
4687 
4688 void  MacroAssembler::cmp_narrow_klass(Address dst, Klass* k) {
4689   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4690   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4691   int klass_index = oop_recorder()-&gt;find_index(k);
4692   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
4693   Assembler::cmp_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
4694 }
4695 
4696 void MacroAssembler::reinit_heapbase() {
4697   if (UseCompressedOops) {
4698     if (Universe::heap() != NULL) {
4699       if (CompressedOops::base() == NULL) {
4700         MacroAssembler::xorptr(r12_heapbase, r12_heapbase);
4701       } else {
4702         mov64(r12_heapbase, (int64_t)CompressedOops::ptrs_base());
4703       }
4704     } else {
4705       movptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
4706     }
4707   }
4708 }
4709 
4710 #endif // _LP64
4711 
4712 // C2 compiled method&#39;s prolog code.
4713 void MacroAssembler::verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub) {
4714 
4715   // WARNING: Initial instruction MUST be 5 bytes or longer so that
4716   // NativeJump::patch_verified_entry will be able to patch out the entry
4717   // code safely. The push to verify stack depth is ok at 5 bytes,
4718   // the frame allocation can be either 3 or 6 bytes. So if we don&#39;t do
4719   // stack bang then we must use the 6 byte frame allocation even if
4720   // we have no frame. :-(
4721   assert(stack_bang_size &gt;= framesize || stack_bang_size &lt;= 0, &quot;stack bang size incorrect&quot;);
4722 
4723   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
4724   // Remove word for return addr
4725   framesize -= wordSize;
4726   stack_bang_size -= wordSize;
4727 
4728   // Calls to C2R adapters often do not accept exceptional returns.
4729   // We require that their callers must bang for them.  But be careful, because
4730   // some VM calls (such as call site linkage) can use several kilobytes of
4731   // stack.  But the stack safety zone should account for that.
4732   // See bugs 4446381, 4468289, 4497237.
4733   if (stack_bang_size &gt; 0) {
4734     generate_stack_overflow_check(stack_bang_size);
4735 
4736     // We always push rbp, so that on return to interpreter rbp, will be
4737     // restored correctly and we can correct the stack.
4738     push(rbp);
4739     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
4740     if (PreserveFramePointer) {
4741       mov(rbp, rsp);
4742     }
4743     // Remove word for ebp
4744     framesize -= wordSize;
4745 
4746     // Create frame
4747     if (framesize) {
4748       subptr(rsp, framesize);
4749     }
4750   } else {
4751     // Create frame (force generation of a 4 byte immediate value)
4752     subptr_imm32(rsp, framesize);
4753 
4754     // Save RBP register now.
4755     framesize -= wordSize;
4756     movptr(Address(rsp, framesize), rbp);
4757     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
4758     if (PreserveFramePointer) {
4759       movptr(rbp, rsp);
4760       if (framesize &gt; 0) {
4761         addptr(rbp, framesize);
4762       }
4763     }
4764   }
4765 
4766   if (VerifyStackAtCalls) { // Majik cookie to verify stack depth
4767     framesize -= wordSize;
4768     movptr(Address(rsp, framesize), (int32_t)0xbadb100d);
4769   }
4770 
4771 #ifndef _LP64
4772   // If method sets FPU control word do it now
4773   if (fp_mode_24b) {
4774     fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
4775   }
4776   if (UseSSE &gt;= 2 &amp;&amp; VerifyFPU) {
4777     verify_FPU(0, &quot;FPU stack must be clean on entry&quot;);
4778   }
4779 #endif
4780 
4781 #ifdef ASSERT
4782   if (VerifyStackAtCalls) {
4783     Label L;
4784     push(rax);
4785     mov(rax, rsp);
4786     andptr(rax, StackAlignmentInBytes-1);
4787     cmpptr(rax, StackAlignmentInBytes-wordSize);
4788     pop(rax);
4789     jcc(Assembler::equal, L);
4790     STOP(&quot;Stack is not properly aligned!&quot;);
4791     bind(L);
4792   }
4793 #endif
4794 
4795   if (!is_stub) {
4796     BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4797     bs-&gt;nmethod_entry_barrier(this);
4798   }
4799 }
4800 
4801 // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
4802 void MacroAssembler::xmm_clear_mem(Register base, Register cnt, XMMRegister xtmp) {
4803   // cnt - number of qwords (8-byte words).
4804   // base - start address, qword aligned.
4805   Label L_zero_64_bytes, L_loop, L_sloop, L_tail, L_end;
4806   if (UseAVX &gt;= 2) {
4807     vpxor(xtmp, xtmp, xtmp, AVX_256bit);
4808   } else {
4809     pxor(xtmp, xtmp);
4810   }
4811   jmp(L_zero_64_bytes);
4812 
4813   BIND(L_loop);
4814   if (UseAVX &gt;= 2) {
4815     vmovdqu(Address(base,  0), xtmp);
4816     vmovdqu(Address(base, 32), xtmp);
4817   } else {
4818     movdqu(Address(base,  0), xtmp);
4819     movdqu(Address(base, 16), xtmp);
4820     movdqu(Address(base, 32), xtmp);
4821     movdqu(Address(base, 48), xtmp);
4822   }
4823   addptr(base, 64);
4824 
4825   BIND(L_zero_64_bytes);
4826   subptr(cnt, 8);
4827   jccb(Assembler::greaterEqual, L_loop);
4828   addptr(cnt, 4);
4829   jccb(Assembler::less, L_tail);
4830   // Copy trailing 32 bytes
4831   if (UseAVX &gt;= 2) {
4832     vmovdqu(Address(base, 0), xtmp);
4833   } else {
4834     movdqu(Address(base,  0), xtmp);
4835     movdqu(Address(base, 16), xtmp);
4836   }
4837   addptr(base, 32);
4838   subptr(cnt, 4);
4839 
4840   BIND(L_tail);
4841   addptr(cnt, 4);
4842   jccb(Assembler::lessEqual, L_end);
4843   decrement(cnt);
4844 
4845   BIND(L_sloop);
4846   movq(Address(base, 0), xtmp);
4847   addptr(base, 8);
4848   decrement(cnt);
4849   jccb(Assembler::greaterEqual, L_sloop);
4850   BIND(L_end);
4851 }
4852 
4853 void MacroAssembler::clear_mem(Register base, Register cnt, Register tmp, XMMRegister xtmp, bool is_large) {
4854   // cnt - number of qwords (8-byte words).
4855   // base - start address, qword aligned.
4856   // is_large - if optimizers know cnt is larger than InitArrayShortSize
4857   assert(base==rdi, &quot;base register must be edi for rep stos&quot;);
4858   assert(tmp==rax,   &quot;tmp register must be eax for rep stos&quot;);
4859   assert(cnt==rcx,   &quot;cnt register must be ecx for rep stos&quot;);
4860   assert(InitArrayShortSize % BytesPerLong == 0,
4861     &quot;InitArrayShortSize should be the multiple of BytesPerLong&quot;);
4862 
4863   Label DONE;
4864 
4865   if (!is_large || !UseXMMForObjInit) {
4866     xorptr(tmp, tmp);
4867   }
4868 
4869   if (!is_large) {
4870     Label LOOP, LONG;
4871     cmpptr(cnt, InitArrayShortSize/BytesPerLong);
4872     jccb(Assembler::greater, LONG);
4873 
4874     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
4875 
4876     decrement(cnt);
4877     jccb(Assembler::negative, DONE); // Zero length
4878 
4879     // Use individual pointer-sized stores for small counts:
4880     BIND(LOOP);
4881     movptr(Address(base, cnt, Address::times_ptr), tmp);
4882     decrement(cnt);
4883     jccb(Assembler::greaterEqual, LOOP);
4884     jmpb(DONE);
4885 
4886     BIND(LONG);
4887   }
4888 
4889   // Use longer rep-prefixed ops for non-small counts:
4890   if (UseFastStosb) {
4891     shlptr(cnt, 3); // convert to number of bytes
4892     rep_stosb();
4893   } else if (UseXMMForObjInit) {
4894     movptr(tmp, base);
4895     xmm_clear_mem(tmp, cnt, xtmp);
4896   } else {
4897     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
4898     rep_stos();
4899   }
4900 
4901   BIND(DONE);
4902 }
4903 
4904 void MacroAssembler::generate_fill(BasicType t, bool aligned,
4905                                    Register to, Register value, Register count,
4906                                    Register rtmp, XMMRegister xtmp) {
4907   ShortBranchVerifier sbv(this);
4908   assert_different_registers(to, value, count, rtmp);
4909   Label L_exit;
4910   Label L_fill_2_bytes, L_fill_4_bytes;
4911 
4912   int shift = -1;
4913   switch (t) {
4914     case T_BYTE:
4915       shift = 2;
4916       break;
4917     case T_SHORT:
4918       shift = 1;
4919       break;
4920     case T_INT:
4921       shift = 0;
4922       break;
4923     default: ShouldNotReachHere();
4924   }
4925 
4926   if (t == T_BYTE) {
4927     andl(value, 0xff);
4928     movl(rtmp, value);
4929     shll(rtmp, 8);
4930     orl(value, rtmp);
4931   }
4932   if (t == T_SHORT) {
4933     andl(value, 0xffff);
4934   }
4935   if (t == T_BYTE || t == T_SHORT) {
4936     movl(rtmp, value);
4937     shll(rtmp, 16);
4938     orl(value, rtmp);
4939   }
4940 
4941   cmpl(count, 2&lt;&lt;shift); // Short arrays (&lt; 8 bytes) fill by element
4942   jcc(Assembler::below, L_fill_4_bytes); // use unsigned cmp
4943   if (!UseUnalignedLoadStores &amp;&amp; !aligned &amp;&amp; (t == T_BYTE || t == T_SHORT)) {
4944     Label L_skip_align2;
4945     // align source address at 4 bytes address boundary
4946     if (t == T_BYTE) {
4947       Label L_skip_align1;
4948       // One byte misalignment happens only for byte arrays
4949       testptr(to, 1);
4950       jccb(Assembler::zero, L_skip_align1);
4951       movb(Address(to, 0), value);
4952       increment(to);
4953       decrement(count);
4954       BIND(L_skip_align1);
4955     }
4956     // Two bytes misalignment happens only for byte and short (char) arrays
4957     testptr(to, 2);
4958     jccb(Assembler::zero, L_skip_align2);
4959     movw(Address(to, 0), value);
4960     addptr(to, 2);
4961     subl(count, 1&lt;&lt;(shift-1));
4962     BIND(L_skip_align2);
4963   }
4964   if (UseSSE &lt; 2) {
4965     Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;
4966     // Fill 32-byte chunks
4967     subl(count, 8 &lt;&lt; shift);
4968     jcc(Assembler::less, L_check_fill_8_bytes);
4969     align(16);
4970 
4971     BIND(L_fill_32_bytes_loop);
4972 
4973     for (int i = 0; i &lt; 32; i += 4) {
4974       movl(Address(to, i), value);
4975     }
4976 
4977     addptr(to, 32);
4978     subl(count, 8 &lt;&lt; shift);
4979     jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);
4980     BIND(L_check_fill_8_bytes);
4981     addl(count, 8 &lt;&lt; shift);
4982     jccb(Assembler::zero, L_exit);
4983     jmpb(L_fill_8_bytes);
4984 
4985     //
4986     // length is too short, just fill qwords
4987     //
4988     BIND(L_fill_8_bytes_loop);
4989     movl(Address(to, 0), value);
4990     movl(Address(to, 4), value);
4991     addptr(to, 8);
4992     BIND(L_fill_8_bytes);
4993     subl(count, 1 &lt;&lt; (shift + 1));
4994     jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);
4995     // fall through to fill 4 bytes
4996   } else {
4997     Label L_fill_32_bytes;
4998     if (!UseUnalignedLoadStores) {
4999       // align to 8 bytes, we know we are 4 byte aligned to start
5000       testptr(to, 4);
5001       jccb(Assembler::zero, L_fill_32_bytes);
5002       movl(Address(to, 0), value);
5003       addptr(to, 4);
5004       subl(count, 1&lt;&lt;shift);
5005     }
5006     BIND(L_fill_32_bytes);
5007     {
5008       assert( UseSSE &gt;= 2, &quot;supported cpu only&quot; );
5009       Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;
5010       movdl(xtmp, value);
5011       if (UseAVX &gt;= 2 &amp;&amp; UseUnalignedLoadStores) {
5012         Label L_check_fill_32_bytes;
5013         if (UseAVX &gt; 2) {
5014           // Fill 64-byte chunks
5015           Label L_fill_64_bytes_loop_avx3, L_check_fill_64_bytes_avx2;
5016 
5017           // If number of bytes to fill &lt; AVX3Threshold, perform fill using AVX2
5018           cmpl(count, AVX3Threshold);
5019           jccb(Assembler::below, L_check_fill_64_bytes_avx2);
5020 
5021           vpbroadcastd(xtmp, xtmp, Assembler::AVX_512bit);
5022 
5023           subl(count, 16 &lt;&lt; shift);
5024           jccb(Assembler::less, L_check_fill_32_bytes);
5025           align(16);
5026 
5027           BIND(L_fill_64_bytes_loop_avx3);
5028           evmovdqul(Address(to, 0), xtmp, Assembler::AVX_512bit);
5029           addptr(to, 64);
5030           subl(count, 16 &lt;&lt; shift);
5031           jcc(Assembler::greaterEqual, L_fill_64_bytes_loop_avx3);
5032           jmpb(L_check_fill_32_bytes);
5033 
5034           BIND(L_check_fill_64_bytes_avx2);
5035         }
5036         // Fill 64-byte chunks
5037         Label L_fill_64_bytes_loop;
5038         vpbroadcastd(xtmp, xtmp, Assembler::AVX_256bit);
5039 
5040         subl(count, 16 &lt;&lt; shift);
5041         jcc(Assembler::less, L_check_fill_32_bytes);
5042         align(16);
5043 
5044         BIND(L_fill_64_bytes_loop);
5045         vmovdqu(Address(to, 0), xtmp);
5046         vmovdqu(Address(to, 32), xtmp);
5047         addptr(to, 64);
5048         subl(count, 16 &lt;&lt; shift);
5049         jcc(Assembler::greaterEqual, L_fill_64_bytes_loop);
5050 
5051         BIND(L_check_fill_32_bytes);
5052         addl(count, 8 &lt;&lt; shift);
5053         jccb(Assembler::less, L_check_fill_8_bytes);
5054         vmovdqu(Address(to, 0), xtmp);
5055         addptr(to, 32);
5056         subl(count, 8 &lt;&lt; shift);
5057 
5058         BIND(L_check_fill_8_bytes);
5059         // clean upper bits of YMM registers
5060         movdl(xtmp, value);
5061         pshufd(xtmp, xtmp, 0);
5062       } else {
5063         // Fill 32-byte chunks
5064         pshufd(xtmp, xtmp, 0);
5065 
5066         subl(count, 8 &lt;&lt; shift);
5067         jcc(Assembler::less, L_check_fill_8_bytes);
5068         align(16);
5069 
5070         BIND(L_fill_32_bytes_loop);
5071 
5072         if (UseUnalignedLoadStores) {
5073           movdqu(Address(to, 0), xtmp);
5074           movdqu(Address(to, 16), xtmp);
5075         } else {
5076           movq(Address(to, 0), xtmp);
5077           movq(Address(to, 8), xtmp);
5078           movq(Address(to, 16), xtmp);
5079           movq(Address(to, 24), xtmp);
5080         }
5081 
5082         addptr(to, 32);
5083         subl(count, 8 &lt;&lt; shift);
5084         jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);
5085 
5086         BIND(L_check_fill_8_bytes);
5087       }
5088       addl(count, 8 &lt;&lt; shift);
5089       jccb(Assembler::zero, L_exit);
5090       jmpb(L_fill_8_bytes);
5091 
5092       //
5093       // length is too short, just fill qwords
5094       //
5095       BIND(L_fill_8_bytes_loop);
5096       movq(Address(to, 0), xtmp);
5097       addptr(to, 8);
5098       BIND(L_fill_8_bytes);
5099       subl(count, 1 &lt;&lt; (shift + 1));
5100       jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);
5101     }
5102   }
5103   // fill trailing 4 bytes
5104   BIND(L_fill_4_bytes);
5105   testl(count, 1&lt;&lt;shift);
5106   jccb(Assembler::zero, L_fill_2_bytes);
5107   movl(Address(to, 0), value);
5108   if (t == T_BYTE || t == T_SHORT) {
5109     Label L_fill_byte;
5110     addptr(to, 4);
5111     BIND(L_fill_2_bytes);
5112     // fill trailing 2 bytes
5113     testl(count, 1&lt;&lt;(shift-1));
5114     jccb(Assembler::zero, L_fill_byte);
5115     movw(Address(to, 0), value);
5116     if (t == T_BYTE) {
5117       addptr(to, 2);
5118       BIND(L_fill_byte);
5119       // fill trailing byte
5120       testl(count, 1);
5121       jccb(Assembler::zero, L_exit);
5122       movb(Address(to, 0), value);
5123     } else {
5124       BIND(L_fill_byte);
5125     }
5126   } else {
5127     BIND(L_fill_2_bytes);
5128   }
5129   BIND(L_exit);
5130 }
5131 
5132 // encode char[] to byte[] in ISO_8859_1
5133    //@HotSpotIntrinsicCandidate
5134    //private static int implEncodeISOArray(byte[] sa, int sp,
5135    //byte[] da, int dp, int len) {
5136    //  int i = 0;
5137    //  for (; i &lt; len; i++) {
5138    //    char c = StringUTF16.getChar(sa, sp++);
5139    //    if (c &gt; &#39;\u00FF&#39;)
5140    //      break;
5141    //    da[dp++] = (byte)c;
5142    //  }
5143    //  return i;
5144    //}
5145 void MacroAssembler::encode_iso_array(Register src, Register dst, Register len,
5146   XMMRegister tmp1Reg, XMMRegister tmp2Reg,
5147   XMMRegister tmp3Reg, XMMRegister tmp4Reg,
5148   Register tmp5, Register result) {
5149 
5150   // rsi: src
5151   // rdi: dst
5152   // rdx: len
5153   // rcx: tmp5
5154   // rax: result
5155   ShortBranchVerifier sbv(this);
5156   assert_different_registers(src, dst, len, tmp5, result);
5157   Label L_done, L_copy_1_char, L_copy_1_char_exit;
5158 
5159   // set result
5160   xorl(result, result);
5161   // check for zero length
5162   testl(len, len);
5163   jcc(Assembler::zero, L_done);
5164 
5165   movl(result, len);
5166 
5167   // Setup pointers
5168   lea(src, Address(src, len, Address::times_2)); // char[]
5169   lea(dst, Address(dst, len, Address::times_1)); // byte[]
5170   negptr(len);
5171 
5172   if (UseSSE42Intrinsics || UseAVX &gt;= 2) {
5173     Label L_copy_8_chars, L_copy_8_chars_exit;
5174     Label L_chars_16_check, L_copy_16_chars, L_copy_16_chars_exit;
5175 
5176     if (UseAVX &gt;= 2) {
5177       Label L_chars_32_check, L_copy_32_chars, L_copy_32_chars_exit;
5178       movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vector
5179       movdl(tmp1Reg, tmp5);
5180       vpbroadcastd(tmp1Reg, tmp1Reg, Assembler::AVX_256bit);
5181       jmp(L_chars_32_check);
5182 
5183       bind(L_copy_32_chars);
5184       vmovdqu(tmp3Reg, Address(src, len, Address::times_2, -64));
5185       vmovdqu(tmp4Reg, Address(src, len, Address::times_2, -32));
5186       vpor(tmp2Reg, tmp3Reg, tmp4Reg, /* vector_len */ 1);
5187       vptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in  vector
5188       jccb(Assembler::notZero, L_copy_32_chars_exit);
5189       vpackuswb(tmp3Reg, tmp3Reg, tmp4Reg, /* vector_len */ 1);
5190       vpermq(tmp4Reg, tmp3Reg, 0xD8, /* vector_len */ 1);
5191       vmovdqu(Address(dst, len, Address::times_1, -32), tmp4Reg);
5192 
5193       bind(L_chars_32_check);
5194       addptr(len, 32);
5195       jcc(Assembler::lessEqual, L_copy_32_chars);
5196 
5197       bind(L_copy_32_chars_exit);
5198       subptr(len, 16);
5199       jccb(Assembler::greater, L_copy_16_chars_exit);
5200 
5201     } else if (UseSSE42Intrinsics) {
5202       movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vector
5203       movdl(tmp1Reg, tmp5);
5204       pshufd(tmp1Reg, tmp1Reg, 0);
5205       jmpb(L_chars_16_check);
5206     }
5207 
5208     bind(L_copy_16_chars);
5209     if (UseAVX &gt;= 2) {
5210       vmovdqu(tmp2Reg, Address(src, len, Address::times_2, -32));
5211       vptest(tmp2Reg, tmp1Reg);
5212       jcc(Assembler::notZero, L_copy_16_chars_exit);
5213       vpackuswb(tmp2Reg, tmp2Reg, tmp1Reg, /* vector_len */ 1);
5214       vpermq(tmp3Reg, tmp2Reg, 0xD8, /* vector_len */ 1);
5215     } else {
5216       if (UseAVX &gt; 0) {
5217         movdqu(tmp3Reg, Address(src, len, Address::times_2, -32));
5218         movdqu(tmp4Reg, Address(src, len, Address::times_2, -16));
5219         vpor(tmp2Reg, tmp3Reg, tmp4Reg, /* vector_len */ 0);
5220       } else {
5221         movdqu(tmp3Reg, Address(src, len, Address::times_2, -32));
5222         por(tmp2Reg, tmp3Reg);
5223         movdqu(tmp4Reg, Address(src, len, Address::times_2, -16));
5224         por(tmp2Reg, tmp4Reg);
5225       }
5226       ptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in  vector
5227       jccb(Assembler::notZero, L_copy_16_chars_exit);
5228       packuswb(tmp3Reg, tmp4Reg);
5229     }
5230     movdqu(Address(dst, len, Address::times_1, -16), tmp3Reg);
5231 
5232     bind(L_chars_16_check);
5233     addptr(len, 16);
5234     jcc(Assembler::lessEqual, L_copy_16_chars);
5235 
5236     bind(L_copy_16_chars_exit);
5237     if (UseAVX &gt;= 2) {
5238       // clean upper bits of YMM registers
5239       vpxor(tmp2Reg, tmp2Reg);
5240       vpxor(tmp3Reg, tmp3Reg);
5241       vpxor(tmp4Reg, tmp4Reg);
5242       movdl(tmp1Reg, tmp5);
5243       pshufd(tmp1Reg, tmp1Reg, 0);
5244     }
5245     subptr(len, 8);
5246     jccb(Assembler::greater, L_copy_8_chars_exit);
5247 
5248     bind(L_copy_8_chars);
5249     movdqu(tmp3Reg, Address(src, len, Address::times_2, -16));
5250     ptest(tmp3Reg, tmp1Reg);
5251     jccb(Assembler::notZero, L_copy_8_chars_exit);
5252     packuswb(tmp3Reg, tmp1Reg);
5253     movq(Address(dst, len, Address::times_1, -8), tmp3Reg);
5254     addptr(len, 8);
5255     jccb(Assembler::lessEqual, L_copy_8_chars);
5256 
5257     bind(L_copy_8_chars_exit);
5258     subptr(len, 8);
5259     jccb(Assembler::zero, L_done);
5260   }
5261 
5262   bind(L_copy_1_char);
5263   load_unsigned_short(tmp5, Address(src, len, Address::times_2, 0));
5264   testl(tmp5, 0xff00);      // check if Unicode char
5265   jccb(Assembler::notZero, L_copy_1_char_exit);
5266   movb(Address(dst, len, Address::times_1, 0), tmp5);
5267   addptr(len, 1);
5268   jccb(Assembler::less, L_copy_1_char);
5269 
5270   bind(L_copy_1_char_exit);
5271   addptr(result, len); // len is negative count of not processed elements
5272 
5273   bind(L_done);
5274 }
5275 
5276 #ifdef _LP64
5277 /**
5278  * Helper for multiply_to_len().
5279  */
5280 void MacroAssembler::add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2) {
5281   addq(dest_lo, src1);
5282   adcq(dest_hi, 0);
5283   addq(dest_lo, src2);
5284   adcq(dest_hi, 0);
5285 }
5286 
5287 /**
5288  * Multiply 64 bit by 64 bit first loop.
5289  */
5290 void MacroAssembler::multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
5291                                            Register y, Register y_idx, Register z,
5292                                            Register carry, Register product,
5293                                            Register idx, Register kdx) {
5294   //
5295   //  jlong carry, x[], y[], z[];
5296   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
5297   //    huge_128 product = y[idx] * x[xstart] + carry;
5298   //    z[kdx] = (jlong)product;
5299   //    carry  = (jlong)(product &gt;&gt;&gt; 64);
5300   //  }
5301   //  z[xstart] = carry;
5302   //
5303 
5304   Label L_first_loop, L_first_loop_exit;
5305   Label L_one_x, L_one_y, L_multiply;
5306 
5307   decrementl(xstart);
5308   jcc(Assembler::negative, L_one_x);
5309 
5310   movq(x_xstart, Address(x, xstart, Address::times_4,  0));
5311   rorq(x_xstart, 32); // convert big-endian to little-endian
5312 
5313   bind(L_first_loop);
5314   decrementl(idx);
5315   jcc(Assembler::negative, L_first_loop_exit);
5316   decrementl(idx);
5317   jcc(Assembler::negative, L_one_y);
5318   movq(y_idx, Address(y, idx, Address::times_4,  0));
5319   rorq(y_idx, 32); // convert big-endian to little-endian
5320   bind(L_multiply);
5321   movq(product, x_xstart);
5322   mulq(y_idx); // product(rax) * y_idx -&gt; rdx:rax
5323   addq(product, carry);
5324   adcq(rdx, 0);
5325   subl(kdx, 2);
5326   movl(Address(z, kdx, Address::times_4,  4), product);
5327   shrq(product, 32);
5328   movl(Address(z, kdx, Address::times_4,  0), product);
5329   movq(carry, rdx);
5330   jmp(L_first_loop);
5331 
5332   bind(L_one_y);
5333   movl(y_idx, Address(y,  0));
5334   jmp(L_multiply);
5335 
5336   bind(L_one_x);
5337   movl(x_xstart, Address(x,  0));
5338   jmp(L_first_loop);
5339 
5340   bind(L_first_loop_exit);
5341 }
5342 
5343 /**
5344  * Multiply 64 bit by 64 bit and add 128 bit.
5345  */
5346 void MacroAssembler::multiply_add_128_x_128(Register x_xstart, Register y, Register z,
5347                                             Register yz_idx, Register idx,
5348                                             Register carry, Register product, int offset) {
5349   //     huge_128 product = (y[idx] * x_xstart) + z[kdx] + carry;
5350   //     z[kdx] = (jlong)product;
5351 
5352   movq(yz_idx, Address(y, idx, Address::times_4,  offset));
5353   rorq(yz_idx, 32); // convert big-endian to little-endian
5354   movq(product, x_xstart);
5355   mulq(yz_idx);     // product(rax) * yz_idx -&gt; rdx:product(rax)
5356   movq(yz_idx, Address(z, idx, Address::times_4,  offset));
5357   rorq(yz_idx, 32); // convert big-endian to little-endian
5358 
5359   add2_with_carry(rdx, product, carry, yz_idx);
5360 
5361   movl(Address(z, idx, Address::times_4,  offset+4), product);
5362   shrq(product, 32);
5363   movl(Address(z, idx, Address::times_4,  offset), product);
5364 
5365 }
5366 
5367 /**
5368  * Multiply 128 bit by 128 bit. Unrolled inner loop.
5369  */
5370 void MacroAssembler::multiply_128_x_128_loop(Register x_xstart, Register y, Register z,
5371                                              Register yz_idx, Register idx, Register jdx,
5372                                              Register carry, Register product,
5373                                              Register carry2) {
5374   //   jlong carry, x[], y[], z[];
5375   //   int kdx = ystart+1;
5376   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
5377   //     huge_128 product = (y[idx+1] * x_xstart) + z[kdx+idx+1] + carry;
5378   //     z[kdx+idx+1] = (jlong)product;
5379   //     jlong carry2  = (jlong)(product &gt;&gt;&gt; 64);
5380   //     product = (y[idx] * x_xstart) + z[kdx+idx] + carry2;
5381   //     z[kdx+idx] = (jlong)product;
5382   //     carry  = (jlong)(product &gt;&gt;&gt; 64);
5383   //   }
5384   //   idx += 2;
5385   //   if (idx &gt; 0) {
5386   //     product = (y[idx] * x_xstart) + z[kdx+idx] + carry;
5387   //     z[kdx+idx] = (jlong)product;
5388   //     carry  = (jlong)(product &gt;&gt;&gt; 64);
5389   //   }
5390   //
5391 
5392   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
5393 
5394   movl(jdx, idx);
5395   andl(jdx, 0xFFFFFFFC);
5396   shrl(jdx, 2);
5397 
5398   bind(L_third_loop);
5399   subl(jdx, 1);
5400   jcc(Assembler::negative, L_third_loop_exit);
5401   subl(idx, 4);
5402 
5403   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 8);
5404   movq(carry2, rdx);
5405 
5406   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry2, product, 0);
5407   movq(carry, rdx);
5408   jmp(L_third_loop);
5409 
5410   bind (L_third_loop_exit);
5411 
5412   andl (idx, 0x3);
5413   jcc(Assembler::zero, L_post_third_loop_done);
5414 
5415   Label L_check_1;
5416   subl(idx, 2);
5417   jcc(Assembler::negative, L_check_1);
5418 
5419   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 0);
5420   movq(carry, rdx);
5421 
5422   bind (L_check_1);
5423   addl (idx, 0x2);
5424   andl (idx, 0x1);
5425   subl(idx, 1);
5426   jcc(Assembler::negative, L_post_third_loop_done);
5427 
5428   movl(yz_idx, Address(y, idx, Address::times_4,  0));
5429   movq(product, x_xstart);
5430   mulq(yz_idx); // product(rax) * yz_idx -&gt; rdx:product(rax)
5431   movl(yz_idx, Address(z, idx, Address::times_4,  0));
5432 
5433   add2_with_carry(rdx, product, yz_idx, carry);
5434 
5435   movl(Address(z, idx, Address::times_4,  0), product);
5436   shrq(product, 32);
5437 
5438   shlq(rdx, 32);
5439   orq(product, rdx);
5440   movq(carry, product);
5441 
5442   bind(L_post_third_loop_done);
5443 }
5444 
5445 /**
5446  * Multiply 128 bit by 128 bit using BMI2. Unrolled inner loop.
5447  *
5448  */
5449 void MacroAssembler::multiply_128_x_128_bmi2_loop(Register y, Register z,
5450                                                   Register carry, Register carry2,
5451                                                   Register idx, Register jdx,
5452                                                   Register yz_idx1, Register yz_idx2,
5453                                                   Register tmp, Register tmp3, Register tmp4) {
5454   assert(UseBMI2Instructions, &quot;should be used only when BMI2 is available&quot;);
5455 
5456   //   jlong carry, x[], y[], z[];
5457   //   int kdx = ystart+1;
5458   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
5459   //     huge_128 tmp3 = (y[idx+1] * rdx) + z[kdx+idx+1] + carry;
5460   //     jlong carry2  = (jlong)(tmp3 &gt;&gt;&gt; 64);
5461   //     huge_128 tmp4 = (y[idx]   * rdx) + z[kdx+idx] + carry2;
5462   //     carry  = (jlong)(tmp4 &gt;&gt;&gt; 64);
5463   //     z[kdx+idx+1] = (jlong)tmp3;
5464   //     z[kdx+idx] = (jlong)tmp4;
5465   //   }
5466   //   idx += 2;
5467   //   if (idx &gt; 0) {
5468   //     yz_idx1 = (y[idx] * rdx) + z[kdx+idx] + carry;
5469   //     z[kdx+idx] = (jlong)yz_idx1;
5470   //     carry  = (jlong)(yz_idx1 &gt;&gt;&gt; 64);
5471   //   }
5472   //
5473 
5474   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
5475 
5476   movl(jdx, idx);
5477   andl(jdx, 0xFFFFFFFC);
5478   shrl(jdx, 2);
5479 
5480   bind(L_third_loop);
5481   subl(jdx, 1);
5482   jcc(Assembler::negative, L_third_loop_exit);
5483   subl(idx, 4);
5484 
5485   movq(yz_idx1,  Address(y, idx, Address::times_4,  8));
5486   rorxq(yz_idx1, yz_idx1, 32); // convert big-endian to little-endian
5487   movq(yz_idx2, Address(y, idx, Address::times_4,  0));
5488   rorxq(yz_idx2, yz_idx2, 32);
5489 
5490   mulxq(tmp4, tmp3, yz_idx1);  //  yz_idx1 * rdx -&gt; tmp4:tmp3
5491   mulxq(carry2, tmp, yz_idx2); //  yz_idx2 * rdx -&gt; carry2:tmp
5492 
5493   movq(yz_idx1,  Address(z, idx, Address::times_4,  8));
5494   rorxq(yz_idx1, yz_idx1, 32);
5495   movq(yz_idx2, Address(z, idx, Address::times_4,  0));
5496   rorxq(yz_idx2, yz_idx2, 32);
5497 
5498   if (VM_Version::supports_adx()) {
5499     adcxq(tmp3, carry);
5500     adoxq(tmp3, yz_idx1);
5501 
5502     adcxq(tmp4, tmp);
5503     adoxq(tmp4, yz_idx2);
5504 
5505     movl(carry, 0); // does not affect flags
5506     adcxq(carry2, carry);
5507     adoxq(carry2, carry);
5508   } else {
5509     add2_with_carry(tmp4, tmp3, carry, yz_idx1);
5510     add2_with_carry(carry2, tmp4, tmp, yz_idx2);
5511   }
5512   movq(carry, carry2);
5513 
5514   movl(Address(z, idx, Address::times_4, 12), tmp3);
5515   shrq(tmp3, 32);
5516   movl(Address(z, idx, Address::times_4,  8), tmp3);
5517 
5518   movl(Address(z, idx, Address::times_4,  4), tmp4);
5519   shrq(tmp4, 32);
5520   movl(Address(z, idx, Address::times_4,  0), tmp4);
5521 
5522   jmp(L_third_loop);
5523 
5524   bind (L_third_loop_exit);
5525 
5526   andl (idx, 0x3);
5527   jcc(Assembler::zero, L_post_third_loop_done);
5528 
5529   Label L_check_1;
5530   subl(idx, 2);
5531   jcc(Assembler::negative, L_check_1);
5532 
5533   movq(yz_idx1, Address(y, idx, Address::times_4,  0));
5534   rorxq(yz_idx1, yz_idx1, 32);
5535   mulxq(tmp4, tmp3, yz_idx1); //  yz_idx1 * rdx -&gt; tmp4:tmp3
5536   movq(yz_idx2, Address(z, idx, Address::times_4,  0));
5537   rorxq(yz_idx2, yz_idx2, 32);
5538 
5539   add2_with_carry(tmp4, tmp3, carry, yz_idx2);
5540 
5541   movl(Address(z, idx, Address::times_4,  4), tmp3);
5542   shrq(tmp3, 32);
5543   movl(Address(z, idx, Address::times_4,  0), tmp3);
5544   movq(carry, tmp4);
5545 
5546   bind (L_check_1);
5547   addl (idx, 0x2);
5548   andl (idx, 0x1);
5549   subl(idx, 1);
5550   jcc(Assembler::negative, L_post_third_loop_done);
5551   movl(tmp4, Address(y, idx, Address::times_4,  0));
5552   mulxq(carry2, tmp3, tmp4);  //  tmp4 * rdx -&gt; carry2:tmp3
5553   movl(tmp4, Address(z, idx, Address::times_4,  0));
5554 
5555   add2_with_carry(carry2, tmp3, tmp4, carry);
5556 
5557   movl(Address(z, idx, Address::times_4,  0), tmp3);
5558   shrq(tmp3, 32);
5559 
5560   shlq(carry2, 32);
5561   orq(tmp3, carry2);
5562   movq(carry, tmp3);
5563 
5564   bind(L_post_third_loop_done);
5565 }
5566 
5567 /**
5568  * Code for BigInteger::multiplyToLen() instrinsic.
5569  *
5570  * rdi: x
5571  * rax: xlen
5572  * rsi: y
5573  * rcx: ylen
5574  * r8:  z
5575  * r11: zlen
5576  * r12: tmp1
5577  * r13: tmp2
5578  * r14: tmp3
5579  * r15: tmp4
5580  * rbx: tmp5
5581  *
5582  */
5583 void MacroAssembler::multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register zlen,
5584                                      Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5) {
5585   ShortBranchVerifier sbv(this);
5586   assert_different_registers(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, rdx);
5587 
5588   push(tmp1);
5589   push(tmp2);
5590   push(tmp3);
5591   push(tmp4);
5592   push(tmp5);
5593 
5594   push(xlen);
5595   push(zlen);
5596 
5597   const Register idx = tmp1;
5598   const Register kdx = tmp2;
5599   const Register xstart = tmp3;
5600 
5601   const Register y_idx = tmp4;
5602   const Register carry = tmp5;
5603   const Register product  = xlen;
5604   const Register x_xstart = zlen;  // reuse register
5605 
5606   // First Loop.
5607   //
5608   //  final static long LONG_MASK = 0xffffffffL;
5609   //  int xstart = xlen - 1;
5610   //  int ystart = ylen - 1;
5611   //  long carry = 0;
5612   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
5613   //    long product = (y[idx] &amp; LONG_MASK) * (x[xstart] &amp; LONG_MASK) + carry;
5614   //    z[kdx] = (int)product;
5615   //    carry = product &gt;&gt;&gt; 32;
5616   //  }
5617   //  z[xstart] = (int)carry;
5618   //
5619 
5620   movl(idx, ylen);      // idx = ylen;
5621   movl(kdx, zlen);      // kdx = xlen+ylen;
5622   xorq(carry, carry);   // carry = 0;
5623 
5624   Label L_done;
5625 
5626   movl(xstart, xlen);
5627   decrementl(xstart);
5628   jcc(Assembler::negative, L_done);
5629 
5630   multiply_64_x_64_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);
5631 
5632   Label L_second_loop;
5633   testl(kdx, kdx);
5634   jcc(Assembler::zero, L_second_loop);
5635 
5636   Label L_carry;
5637   subl(kdx, 1);
5638   jcc(Assembler::zero, L_carry);
5639 
5640   movl(Address(z, kdx, Address::times_4,  0), carry);
5641   shrq(carry, 32);
5642   subl(kdx, 1);
5643 
5644   bind(L_carry);
5645   movl(Address(z, kdx, Address::times_4,  0), carry);
5646 
5647   // Second and third (nested) loops.
5648   //
5649   // for (int i = xstart-1; i &gt;= 0; i--) { // Second loop
5650   //   carry = 0;
5651   //   for (int jdx=ystart, k=ystart+1+i; jdx &gt;= 0; jdx--, k--) { // Third loop
5652   //     long product = (y[jdx] &amp; LONG_MASK) * (x[i] &amp; LONG_MASK) +
5653   //                    (z[k] &amp; LONG_MASK) + carry;
5654   //     z[k] = (int)product;
5655   //     carry = product &gt;&gt;&gt; 32;
5656   //   }
5657   //   z[i] = (int)carry;
5658   // }
5659   //
5660   // i = xlen, j = tmp1, k = tmp2, carry = tmp5, x[i] = rdx
5661 
5662   const Register jdx = tmp1;
5663 
5664   bind(L_second_loop);
5665   xorl(carry, carry);    // carry = 0;
5666   movl(jdx, ylen);       // j = ystart+1
5667 
5668   subl(xstart, 1);       // i = xstart-1;
5669   jcc(Assembler::negative, L_done);
5670 
5671   push (z);
5672 
5673   Label L_last_x;
5674   lea(z, Address(z, xstart, Address::times_4, 4)); // z = z + k - j
5675   subl(xstart, 1);       // i = xstart-1;
5676   jcc(Assembler::negative, L_last_x);
5677 
5678   if (UseBMI2Instructions) {
5679     movq(rdx,  Address(x, xstart, Address::times_4,  0));
5680     rorxq(rdx, rdx, 32); // convert big-endian to little-endian
5681   } else {
5682     movq(x_xstart, Address(x, xstart, Address::times_4,  0));
5683     rorq(x_xstart, 32);  // convert big-endian to little-endian
5684   }
5685 
5686   Label L_third_loop_prologue;
5687   bind(L_third_loop_prologue);
5688 
5689   push (x);
5690   push (xstart);
5691   push (ylen);
5692 
5693 
5694   if (UseBMI2Instructions) {
5695     multiply_128_x_128_bmi2_loop(y, z, carry, x, jdx, ylen, product, tmp2, x_xstart, tmp3, tmp4);
5696   } else { // !UseBMI2Instructions
5697     multiply_128_x_128_loop(x_xstart, y, z, y_idx, jdx, ylen, carry, product, x);
5698   }
5699 
5700   pop(ylen);
5701   pop(xlen);
5702   pop(x);
5703   pop(z);
5704 
5705   movl(tmp3, xlen);
5706   addl(tmp3, 1);
5707   movl(Address(z, tmp3, Address::times_4,  0), carry);
5708   subl(tmp3, 1);
5709   jccb(Assembler::negative, L_done);
5710 
5711   shrq(carry, 32);
5712   movl(Address(z, tmp3, Address::times_4,  0), carry);
5713   jmp(L_second_loop);
5714 
5715   // Next infrequent code is moved outside loops.
5716   bind(L_last_x);
5717   if (UseBMI2Instructions) {
5718     movl(rdx, Address(x,  0));
5719   } else {
5720     movl(x_xstart, Address(x,  0));
5721   }
5722   jmp(L_third_loop_prologue);
5723 
5724   bind(L_done);
5725 
5726   pop(zlen);
5727   pop(xlen);
5728 
5729   pop(tmp5);
5730   pop(tmp4);
5731   pop(tmp3);
5732   pop(tmp2);
5733   pop(tmp1);
5734 }
5735 
5736 void MacroAssembler::vectorized_mismatch(Register obja, Register objb, Register length, Register log2_array_indxscale,
5737   Register result, Register tmp1, Register tmp2, XMMRegister rymm0, XMMRegister rymm1, XMMRegister rymm2){
5738   assert(UseSSE42Intrinsics, &quot;SSE4.2 must be enabled.&quot;);
5739   Label VECTOR16_LOOP, VECTOR8_LOOP, VECTOR4_LOOP;
5740   Label VECTOR8_TAIL, VECTOR4_TAIL;
5741   Label VECTOR32_NOT_EQUAL, VECTOR16_NOT_EQUAL, VECTOR8_NOT_EQUAL, VECTOR4_NOT_EQUAL;
5742   Label SAME_TILL_END, DONE;
5743   Label BYTES_LOOP, BYTES_TAIL, BYTES_NOT_EQUAL;
5744 
5745   //scale is in rcx in both Win64 and Unix
5746   ShortBranchVerifier sbv(this);
5747 
5748   shlq(length);
5749   xorq(result, result);
5750 
5751   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp;
5752       VM_Version::supports_avx512vlbw()) {
5753     Label VECTOR64_LOOP, VECTOR64_NOT_EQUAL, VECTOR32_TAIL;
5754 
5755     cmpq(length, 64);
5756     jcc(Assembler::less, VECTOR32_TAIL);
5757 
5758     movq(tmp1, length);
5759     andq(tmp1, 0x3F);      // tail count
5760     andq(length, ~(0x3F)); //vector count
5761 
5762     bind(VECTOR64_LOOP);
5763     // AVX512 code to compare 64 byte vectors.
5764     evmovdqub(rymm0, Address(obja, result), Assembler::AVX_512bit);
5765     evpcmpeqb(k7, rymm0, Address(objb, result), Assembler::AVX_512bit);
5766     kortestql(k7, k7);
5767     jcc(Assembler::aboveEqual, VECTOR64_NOT_EQUAL);     // mismatch
5768     addq(result, 64);
5769     subq(length, 64);
5770     jccb(Assembler::notZero, VECTOR64_LOOP);
5771 
5772     //bind(VECTOR64_TAIL);
5773     testq(tmp1, tmp1);
5774     jcc(Assembler::zero, SAME_TILL_END);
5775 
5776     //bind(VECTOR64_TAIL);
5777     // AVX512 code to compare upto 63 byte vectors.
5778     mov64(tmp2, 0xFFFFFFFFFFFFFFFF);
5779     shlxq(tmp2, tmp2, tmp1);
5780     notq(tmp2);
5781     kmovql(k3, tmp2);
5782 
5783     evmovdqub(rymm0, k3, Address(obja, result), Assembler::AVX_512bit);
5784     evpcmpeqb(k7, k3, rymm0, Address(objb, result), Assembler::AVX_512bit);
5785 
5786     ktestql(k7, k3);
5787     jcc(Assembler::below, SAME_TILL_END);     // not mismatch
5788 
5789     bind(VECTOR64_NOT_EQUAL);
5790     kmovql(tmp1, k7);
5791     notq(tmp1);
5792     tzcntq(tmp1, tmp1);
5793     addq(result, tmp1);
5794     shrq(result);
5795     jmp(DONE);
5796     bind(VECTOR32_TAIL);
5797   }
5798 
5799   cmpq(length, 8);
5800   jcc(Assembler::equal, VECTOR8_LOOP);
5801   jcc(Assembler::less, VECTOR4_TAIL);
5802 
5803   if (UseAVX &gt;= 2) {
5804     Label VECTOR16_TAIL, VECTOR32_LOOP;
5805 
5806     cmpq(length, 16);
5807     jcc(Assembler::equal, VECTOR16_LOOP);
5808     jcc(Assembler::less, VECTOR8_LOOP);
5809 
5810     cmpq(length, 32);
5811     jccb(Assembler::less, VECTOR16_TAIL);
5812 
5813     subq(length, 32);
5814     bind(VECTOR32_LOOP);
5815     vmovdqu(rymm0, Address(obja, result));
5816     vmovdqu(rymm1, Address(objb, result));
5817     vpxor(rymm2, rymm0, rymm1, Assembler::AVX_256bit);
5818     vptest(rymm2, rymm2);
5819     jcc(Assembler::notZero, VECTOR32_NOT_EQUAL);//mismatch found
5820     addq(result, 32);
5821     subq(length, 32);
5822     jcc(Assembler::greaterEqual, VECTOR32_LOOP);
5823     addq(length, 32);
5824     jcc(Assembler::equal, SAME_TILL_END);
5825     //falling through if less than 32 bytes left //close the branch here.
5826 
5827     bind(VECTOR16_TAIL);
5828     cmpq(length, 16);
5829     jccb(Assembler::less, VECTOR8_TAIL);
5830     bind(VECTOR16_LOOP);
5831     movdqu(rymm0, Address(obja, result));
5832     movdqu(rymm1, Address(objb, result));
5833     vpxor(rymm2, rymm0, rymm1, Assembler::AVX_128bit);
5834     ptest(rymm2, rymm2);
5835     jcc(Assembler::notZero, VECTOR16_NOT_EQUAL);//mismatch found
5836     addq(result, 16);
5837     subq(length, 16);
5838     jcc(Assembler::equal, SAME_TILL_END);
5839     //falling through if less than 16 bytes left
5840   } else {//regular intrinsics
5841 
5842     cmpq(length, 16);
5843     jccb(Assembler::less, VECTOR8_TAIL);
5844 
5845     subq(length, 16);
5846     bind(VECTOR16_LOOP);
5847     movdqu(rymm0, Address(obja, result));
5848     movdqu(rymm1, Address(objb, result));
5849     pxor(rymm0, rymm1);
5850     ptest(rymm0, rymm0);
5851     jcc(Assembler::notZero, VECTOR16_NOT_EQUAL);//mismatch found
5852     addq(result, 16);
5853     subq(length, 16);
5854     jccb(Assembler::greaterEqual, VECTOR16_LOOP);
5855     addq(length, 16);
5856     jcc(Assembler::equal, SAME_TILL_END);
5857     //falling through if less than 16 bytes left
5858   }
5859 
5860   bind(VECTOR8_TAIL);
5861   cmpq(length, 8);
5862   jccb(Assembler::less, VECTOR4_TAIL);
5863   bind(VECTOR8_LOOP);
5864   movq(tmp1, Address(obja, result));
5865   movq(tmp2, Address(objb, result));
5866   xorq(tmp1, tmp2);
5867   testq(tmp1, tmp1);
5868   jcc(Assembler::notZero, VECTOR8_NOT_EQUAL);//mismatch found
5869   addq(result, 8);
5870   subq(length, 8);
5871   jcc(Assembler::equal, SAME_TILL_END);
5872   //falling through if less than 8 bytes left
5873 
5874   bind(VECTOR4_TAIL);
5875   cmpq(length, 4);
5876   jccb(Assembler::less, BYTES_TAIL);
5877   bind(VECTOR4_LOOP);
5878   movl(tmp1, Address(obja, result));
5879   xorl(tmp1, Address(objb, result));
5880   testl(tmp1, tmp1);
5881   jcc(Assembler::notZero, VECTOR4_NOT_EQUAL);//mismatch found
5882   addq(result, 4);
5883   subq(length, 4);
5884   jcc(Assembler::equal, SAME_TILL_END);
5885   //falling through if less than 4 bytes left
5886 
5887   bind(BYTES_TAIL);
5888   bind(BYTES_LOOP);
5889   load_unsigned_byte(tmp1, Address(obja, result));
5890   load_unsigned_byte(tmp2, Address(objb, result));
5891   xorl(tmp1, tmp2);
5892   testl(tmp1, tmp1);
5893   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
5894   decq(length);
5895   jcc(Assembler::zero, SAME_TILL_END);
5896   incq(result);
5897   load_unsigned_byte(tmp1, Address(obja, result));
5898   load_unsigned_byte(tmp2, Address(objb, result));
5899   xorl(tmp1, tmp2);
5900   testl(tmp1, tmp1);
5901   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
5902   decq(length);
5903   jcc(Assembler::zero, SAME_TILL_END);
5904   incq(result);
5905   load_unsigned_byte(tmp1, Address(obja, result));
5906   load_unsigned_byte(tmp2, Address(objb, result));
5907   xorl(tmp1, tmp2);
5908   testl(tmp1, tmp1);
5909   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
5910   jmp(SAME_TILL_END);
5911 
5912   if (UseAVX &gt;= 2) {
5913     bind(VECTOR32_NOT_EQUAL);
5914     vpcmpeqb(rymm2, rymm2, rymm2, Assembler::AVX_256bit);
5915     vpcmpeqb(rymm0, rymm0, rymm1, Assembler::AVX_256bit);
5916     vpxor(rymm0, rymm0, rymm2, Assembler::AVX_256bit);
5917     vpmovmskb(tmp1, rymm0);
5918     bsfq(tmp1, tmp1);
5919     addq(result, tmp1);
5920     shrq(result);
5921     jmp(DONE);
5922   }
5923 
5924   bind(VECTOR16_NOT_EQUAL);
5925   if (UseAVX &gt;= 2) {
5926     vpcmpeqb(rymm2, rymm2, rymm2, Assembler::AVX_128bit);
5927     vpcmpeqb(rymm0, rymm0, rymm1, Assembler::AVX_128bit);
5928     pxor(rymm0, rymm2);
5929   } else {
5930     pcmpeqb(rymm2, rymm2);
5931     pxor(rymm0, rymm1);
5932     pcmpeqb(rymm0, rymm1);
5933     pxor(rymm0, rymm2);
5934   }
5935   pmovmskb(tmp1, rymm0);
5936   bsfq(tmp1, tmp1);
5937   addq(result, tmp1);
5938   shrq(result);
5939   jmpb(DONE);
5940 
5941   bind(VECTOR8_NOT_EQUAL);
5942   bind(VECTOR4_NOT_EQUAL);
5943   bsfq(tmp1, tmp1);
5944   shrq(tmp1, 3);
5945   addq(result, tmp1);
5946   bind(BYTES_NOT_EQUAL);
5947   shrq(result);
5948   jmpb(DONE);
5949 
5950   bind(SAME_TILL_END);
5951   mov64(result, -1);
5952 
5953   bind(DONE);
5954 }
5955 
5956 //Helper functions for square_to_len()
5957 
5958 /**
5959  * Store the squares of x[], right shifted one bit (divided by 2) into z[]
5960  * Preserves x and z and modifies rest of the registers.
5961  */
5962 void MacroAssembler::square_rshift(Register x, Register xlen, Register z, Register tmp1, Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
5963   // Perform square and right shift by 1
5964   // Handle odd xlen case first, then for even xlen do the following
5965   // jlong carry = 0;
5966   // for (int j=0, i=0; j &lt; xlen; j+=2, i+=4) {
5967   //     huge_128 product = x[j:j+1] * x[j:j+1];
5968   //     z[i:i+1] = (carry &lt;&lt; 63) | (jlong)(product &gt;&gt;&gt; 65);
5969   //     z[i+2:i+3] = (jlong)(product &gt;&gt;&gt; 1);
5970   //     carry = (jlong)product;
5971   // }
5972 
5973   xorq(tmp5, tmp5);     // carry
5974   xorq(rdxReg, rdxReg);
5975   xorl(tmp1, tmp1);     // index for x
5976   xorl(tmp4, tmp4);     // index for z
5977 
5978   Label L_first_loop, L_first_loop_exit;
5979 
5980   testl(xlen, 1);
5981   jccb(Assembler::zero, L_first_loop); //jump if xlen is even
5982 
5983   // Square and right shift by 1 the odd element using 32 bit multiply
5984   movl(raxReg, Address(x, tmp1, Address::times_4, 0));
5985   imulq(raxReg, raxReg);
5986   shrq(raxReg, 1);
5987   adcq(tmp5, 0);
5988   movq(Address(z, tmp4, Address::times_4, 0), raxReg);
5989   incrementl(tmp1);
5990   addl(tmp4, 2);
5991 
5992   // Square and  right shift by 1 the rest using 64 bit multiply
5993   bind(L_first_loop);
5994   cmpptr(tmp1, xlen);
5995   jccb(Assembler::equal, L_first_loop_exit);
5996 
5997   // Square
5998   movq(raxReg, Address(x, tmp1, Address::times_4,  0));
5999   rorq(raxReg, 32);    // convert big-endian to little-endian
6000   mulq(raxReg);        // 64-bit multiply rax * rax -&gt; rdx:rax
6001 
6002   // Right shift by 1 and save carry
6003   shrq(tmp5, 1);       // rdx:rax:tmp5 = (tmp5:rdx:rax) &gt;&gt;&gt; 1
6004   rcrq(rdxReg, 1);
6005   rcrq(raxReg, 1);
6006   adcq(tmp5, 0);
6007 
6008   // Store result in z
6009   movq(Address(z, tmp4, Address::times_4, 0), rdxReg);
6010   movq(Address(z, tmp4, Address::times_4, 8), raxReg);
6011 
6012   // Update indices for x and z
6013   addl(tmp1, 2);
6014   addl(tmp4, 4);
6015   jmp(L_first_loop);
6016 
6017   bind(L_first_loop_exit);
6018 }
6019 
6020 
6021 /**
6022  * Perform the following multiply add operation using BMI2 instructions
6023  * carry:sum = sum + op1*op2 + carry
6024  * op2 should be in rdx
6025  * op2 is preserved, all other registers are modified
6026  */
6027 void MacroAssembler::multiply_add_64_bmi2(Register sum, Register op1, Register op2, Register carry, Register tmp2) {
6028   // assert op2 is rdx
6029   mulxq(tmp2, op1, op1);  //  op1 * op2 -&gt; tmp2:op1
6030   addq(sum, carry);
6031   adcq(tmp2, 0);
6032   addq(sum, op1);
6033   adcq(tmp2, 0);
6034   movq(carry, tmp2);
6035 }
6036 
6037 /**
6038  * Perform the following multiply add operation:
6039  * carry:sum = sum + op1*op2 + carry
6040  * Preserves op1, op2 and modifies rest of registers
6041  */
6042 void MacroAssembler::multiply_add_64(Register sum, Register op1, Register op2, Register carry, Register rdxReg, Register raxReg) {
6043   // rdx:rax = op1 * op2
6044   movq(raxReg, op2);
6045   mulq(op1);
6046 
6047   //  rdx:rax = sum + carry + rdx:rax
6048   addq(sum, carry);
6049   adcq(rdxReg, 0);
6050   addq(sum, raxReg);
6051   adcq(rdxReg, 0);
6052 
6053   // carry:sum = rdx:sum
6054   movq(carry, rdxReg);
6055 }
6056 
6057 /**
6058  * Add 64 bit long carry into z[] with carry propogation.
6059  * Preserves z and carry register values and modifies rest of registers.
6060  *
6061  */
6062 void MacroAssembler::add_one_64(Register z, Register zlen, Register carry, Register tmp1) {
6063   Label L_fourth_loop, L_fourth_loop_exit;
6064 
6065   movl(tmp1, 1);
6066   subl(zlen, 2);
6067   addq(Address(z, zlen, Address::times_4, 0), carry);
6068 
6069   bind(L_fourth_loop);
6070   jccb(Assembler::carryClear, L_fourth_loop_exit);
6071   subl(zlen, 2);
6072   jccb(Assembler::negative, L_fourth_loop_exit);
6073   addq(Address(z, zlen, Address::times_4, 0), tmp1);
6074   jmp(L_fourth_loop);
6075   bind(L_fourth_loop_exit);
6076 }
6077 
6078 /**
6079  * Shift z[] left by 1 bit.
6080  * Preserves x, len, z and zlen registers and modifies rest of the registers.
6081  *
6082  */
6083 void MacroAssembler::lshift_by_1(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2, Register tmp3, Register tmp4) {
6084 
6085   Label L_fifth_loop, L_fifth_loop_exit;
6086 
6087   // Fifth loop
6088   // Perform primitiveLeftShift(z, zlen, 1)
6089 
6090   const Register prev_carry = tmp1;
6091   const Register new_carry = tmp4;
6092   const Register value = tmp2;
6093   const Register zidx = tmp3;
6094 
6095   // int zidx, carry;
6096   // long value;
6097   // carry = 0;
6098   // for (zidx = zlen-2; zidx &gt;=0; zidx -= 2) {
6099   //    (carry:value)  = (z[i] &lt;&lt; 1) | carry ;
6100   //    z[i] = value;
6101   // }
6102 
6103   movl(zidx, zlen);
6104   xorl(prev_carry, prev_carry); // clear carry flag and prev_carry register
6105 
6106   bind(L_fifth_loop);
6107   decl(zidx);  // Use decl to preserve carry flag
6108   decl(zidx);
6109   jccb(Assembler::negative, L_fifth_loop_exit);
6110 
6111   if (UseBMI2Instructions) {
6112      movq(value, Address(z, zidx, Address::times_4, 0));
6113      rclq(value, 1);
6114      rorxq(value, value, 32);
6115      movq(Address(z, zidx, Address::times_4,  0), value);  // Store back in big endian form
6116   }
6117   else {
6118     // clear new_carry
6119     xorl(new_carry, new_carry);
6120 
6121     // Shift z[i] by 1, or in previous carry and save new carry
6122     movq(value, Address(z, zidx, Address::times_4, 0));
6123     shlq(value, 1);
6124     adcl(new_carry, 0);
6125 
6126     orq(value, prev_carry);
6127     rorq(value, 0x20);
6128     movq(Address(z, zidx, Address::times_4,  0), value);  // Store back in big endian form
6129 
6130     // Set previous carry = new carry
6131     movl(prev_carry, new_carry);
6132   }
6133   jmp(L_fifth_loop);
6134 
6135   bind(L_fifth_loop_exit);
6136 }
6137 
6138 
6139 /**
6140  * Code for BigInteger::squareToLen() intrinsic
6141  *
6142  * rdi: x
6143  * rsi: len
6144  * r8:  z
6145  * rcx: zlen
6146  * r12: tmp1
6147  * r13: tmp2
6148  * r14: tmp3
6149  * r15: tmp4
6150  * rbx: tmp5
6151  *
6152  */
6153 void MacroAssembler::square_to_len(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6154 
6155   Label L_second_loop, L_second_loop_exit, L_third_loop, L_third_loop_exit, L_last_x, L_multiply;
6156   push(tmp1);
6157   push(tmp2);
6158   push(tmp3);
6159   push(tmp4);
6160   push(tmp5);
6161 
6162   // First loop
6163   // Store the squares, right shifted one bit (i.e., divided by 2).
6164   square_rshift(x, len, z, tmp1, tmp3, tmp4, tmp5, rdxReg, raxReg);
6165 
6166   // Add in off-diagonal sums.
6167   //
6168   // Second, third (nested) and fourth loops.
6169   // zlen +=2;
6170   // for (int xidx=len-2,zidx=zlen-4; xidx &gt; 0; xidx-=2,zidx-=4) {
6171   //    carry = 0;
6172   //    long op2 = x[xidx:xidx+1];
6173   //    for (int j=xidx-2,k=zidx; j &gt;= 0; j-=2) {
6174   //       k -= 2;
6175   //       long op1 = x[j:j+1];
6176   //       long sum = z[k:k+1];
6177   //       carry:sum = multiply_add_64(sum, op1, op2, carry, tmp_regs);
6178   //       z[k:k+1] = sum;
6179   //    }
6180   //    add_one_64(z, k, carry, tmp_regs);
6181   // }
6182 
6183   const Register carry = tmp5;
6184   const Register sum = tmp3;
6185   const Register op1 = tmp4;
6186   Register op2 = tmp2;
6187 
6188   push(zlen);
6189   push(len);
6190   addl(zlen,2);
6191   bind(L_second_loop);
6192   xorq(carry, carry);
6193   subl(zlen, 4);
6194   subl(len, 2);
6195   push(zlen);
6196   push(len);
6197   cmpl(len, 0);
6198   jccb(Assembler::lessEqual, L_second_loop_exit);
6199 
6200   // Multiply an array by one 64 bit long.
6201   if (UseBMI2Instructions) {
6202     op2 = rdxReg;
6203     movq(op2, Address(x, len, Address::times_4,  0));
6204     rorxq(op2, op2, 32);
6205   }
6206   else {
6207     movq(op2, Address(x, len, Address::times_4,  0));
6208     rorq(op2, 32);
6209   }
6210 
6211   bind(L_third_loop);
6212   decrementl(len);
6213   jccb(Assembler::negative, L_third_loop_exit);
6214   decrementl(len);
6215   jccb(Assembler::negative, L_last_x);
6216 
6217   movq(op1, Address(x, len, Address::times_4,  0));
6218   rorq(op1, 32);
6219 
6220   bind(L_multiply);
6221   subl(zlen, 2);
6222   movq(sum, Address(z, zlen, Address::times_4,  0));
6223 
6224   // Multiply 64 bit by 64 bit and add 64 bits lower half and upper 64 bits as carry.
6225   if (UseBMI2Instructions) {
6226     multiply_add_64_bmi2(sum, op1, op2, carry, tmp2);
6227   }
6228   else {
6229     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
6230   }
6231 
6232   movq(Address(z, zlen, Address::times_4, 0), sum);
6233 
6234   jmp(L_third_loop);
6235   bind(L_third_loop_exit);
6236 
6237   // Fourth loop
6238   // Add 64 bit long carry into z with carry propogation.
6239   // Uses offsetted zlen.
6240   add_one_64(z, zlen, carry, tmp1);
6241 
6242   pop(len);
6243   pop(zlen);
6244   jmp(L_second_loop);
6245 
6246   // Next infrequent code is moved outside loops.
6247   bind(L_last_x);
6248   movl(op1, Address(x, 0));
6249   jmp(L_multiply);
6250 
6251   bind(L_second_loop_exit);
6252   pop(len);
6253   pop(zlen);
6254   pop(len);
6255   pop(zlen);
6256 
6257   // Fifth loop
6258   // Shift z left 1 bit.
6259   lshift_by_1(x, len, z, zlen, tmp1, tmp2, tmp3, tmp4);
6260 
6261   // z[zlen-1] |= x[len-1] &amp; 1;
6262   movl(tmp3, Address(x, len, Address::times_4, -4));
6263   andl(tmp3, 1);
6264   orl(Address(z, zlen, Address::times_4,  -4), tmp3);
6265 
6266   pop(tmp5);
6267   pop(tmp4);
6268   pop(tmp3);
6269   pop(tmp2);
6270   pop(tmp1);
6271 }
6272 
6273 /**
6274  * Helper function for mul_add()
6275  * Multiply the in[] by int k and add to out[] starting at offset offs using
6276  * 128 bit by 32 bit multiply and return the carry in tmp5.
6277  * Only quad int aligned length of in[] is operated on in this function.
6278  * k is in rdxReg for BMI2Instructions, for others it is in tmp2.
6279  * This function preserves out, in and k registers.
6280  * len and offset point to the appropriate index in &quot;in&quot; &amp; &quot;out&quot; correspondingly
6281  * tmp5 has the carry.
6282  * other registers are temporary and are modified.
6283  *
6284  */
6285 void MacroAssembler::mul_add_128_x_32_loop(Register out, Register in,
6286   Register offset, Register len, Register tmp1, Register tmp2, Register tmp3,
6287   Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6288 
6289   Label L_first_loop, L_first_loop_exit;
6290 
6291   movl(tmp1, len);
6292   shrl(tmp1, 2);
6293 
6294   bind(L_first_loop);
6295   subl(tmp1, 1);
6296   jccb(Assembler::negative, L_first_loop_exit);
6297 
6298   subl(len, 4);
6299   subl(offset, 4);
6300 
6301   Register op2 = tmp2;
6302   const Register sum = tmp3;
6303   const Register op1 = tmp4;
6304   const Register carry = tmp5;
6305 
6306   if (UseBMI2Instructions) {
6307     op2 = rdxReg;
6308   }
6309 
6310   movq(op1, Address(in, len, Address::times_4,  8));
6311   rorq(op1, 32);
6312   movq(sum, Address(out, offset, Address::times_4,  8));
6313   rorq(sum, 32);
6314   if (UseBMI2Instructions) {
6315     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
6316   }
6317   else {
6318     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
6319   }
6320   // Store back in big endian from little endian
6321   rorq(sum, 0x20);
6322   movq(Address(out, offset, Address::times_4,  8), sum);
6323 
6324   movq(op1, Address(in, len, Address::times_4,  0));
6325   rorq(op1, 32);
6326   movq(sum, Address(out, offset, Address::times_4,  0));
6327   rorq(sum, 32);
6328   if (UseBMI2Instructions) {
6329     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
6330   }
6331   else {
6332     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
6333   }
6334   // Store back in big endian from little endian
6335   rorq(sum, 0x20);
6336   movq(Address(out, offset, Address::times_4,  0), sum);
6337 
6338   jmp(L_first_loop);
6339   bind(L_first_loop_exit);
6340 }
6341 
6342 /**
6343  * Code for BigInteger::mulAdd() intrinsic
6344  *
6345  * rdi: out
6346  * rsi: in
6347  * r11: offs (out.length - offset)
6348  * rcx: len
6349  * r8:  k
6350  * r12: tmp1
6351  * r13: tmp2
6352  * r14: tmp3
6353  * r15: tmp4
6354  * rbx: tmp5
6355  * Multiply the in[] by word k and add to out[], return the carry in rax
6356  */
6357 void MacroAssembler::mul_add(Register out, Register in, Register offs,
6358    Register len, Register k, Register tmp1, Register tmp2, Register tmp3,
6359    Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6360 
6361   Label L_carry, L_last_in, L_done;
6362 
6363 // carry = 0;
6364 // for (int j=len-1; j &gt;= 0; j--) {
6365 //    long product = (in[j] &amp; LONG_MASK) * kLong +
6366 //                   (out[offs] &amp; LONG_MASK) + carry;
6367 //    out[offs--] = (int)product;
6368 //    carry = product &gt;&gt;&gt; 32;
6369 // }
6370 //
6371   push(tmp1);
6372   push(tmp2);
6373   push(tmp3);
6374   push(tmp4);
6375   push(tmp5);
6376 
6377   Register op2 = tmp2;
6378   const Register sum = tmp3;
6379   const Register op1 = tmp4;
6380   const Register carry =  tmp5;
6381 
6382   if (UseBMI2Instructions) {
6383     op2 = rdxReg;
6384     movl(op2, k);
6385   }
6386   else {
6387     movl(op2, k);
6388   }
6389 
6390   xorq(carry, carry);
6391 
6392   //First loop
6393 
6394   //Multiply in[] by k in a 4 way unrolled loop using 128 bit by 32 bit multiply
6395   //The carry is in tmp5
6396   mul_add_128_x_32_loop(out, in, offs, len, tmp1, tmp2, tmp3, tmp4, tmp5, rdxReg, raxReg);
6397 
6398   //Multiply the trailing in[] entry using 64 bit by 32 bit, if any
6399   decrementl(len);
6400   jccb(Assembler::negative, L_carry);
6401   decrementl(len);
6402   jccb(Assembler::negative, L_last_in);
6403 
6404   movq(op1, Address(in, len, Address::times_4,  0));
6405   rorq(op1, 32);
6406 
6407   subl(offs, 2);
6408   movq(sum, Address(out, offs, Address::times_4,  0));
6409   rorq(sum, 32);
6410 
6411   if (UseBMI2Instructions) {
6412     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
6413   }
6414   else {
6415     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
6416   }
6417 
6418   // Store back in big endian from little endian
6419   rorq(sum, 0x20);
6420   movq(Address(out, offs, Address::times_4,  0), sum);
6421 
6422   testl(len, len);
6423   jccb(Assembler::zero, L_carry);
6424 
6425   //Multiply the last in[] entry, if any
6426   bind(L_last_in);
6427   movl(op1, Address(in, 0));
6428   movl(sum, Address(out, offs, Address::times_4,  -4));
6429 
6430   movl(raxReg, k);
6431   mull(op1); //tmp4 * eax -&gt; edx:eax
6432   addl(sum, carry);
6433   adcl(rdxReg, 0);
6434   addl(sum, raxReg);
6435   adcl(rdxReg, 0);
6436   movl(carry, rdxReg);
6437 
6438   movl(Address(out, offs, Address::times_4,  -4), sum);
6439 
6440   bind(L_carry);
6441   //return tmp5/carry as carry in rax
6442   movl(rax, carry);
6443 
6444   bind(L_done);
6445   pop(tmp5);
6446   pop(tmp4);
6447   pop(tmp3);
6448   pop(tmp2);
6449   pop(tmp1);
6450 }
6451 #endif
6452 
6453 /**
6454  * Emits code to update CRC-32 with a byte value according to constants in table
6455  *
6456  * @param [in,out]crc   Register containing the crc.
6457  * @param [in]val       Register containing the byte to fold into the CRC.
6458  * @param [in]table     Register containing the table of crc constants.
6459  *
6460  * uint32_t crc;
6461  * val = crc_table[(val ^ crc) &amp; 0xFF];
6462  * crc = val ^ (crc &gt;&gt; 8);
6463  *
6464  */
6465 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
6466   xorl(val, crc);
6467   andl(val, 0xFF);
6468   shrl(crc, 8); // unsigned shift
6469   xorl(crc, Address(table, val, Address::times_4, 0));
6470 }
6471 
6472 /**
6473  * Fold 128-bit data chunk
6474  */
6475 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset) {
6476   if (UseAVX &gt; 0) {
6477     vpclmulhdq(xtmp, xK, xcrc); // [123:64]
6478     vpclmulldq(xcrc, xK, xcrc); // [63:0]
6479     vpxor(xcrc, xcrc, Address(buf, offset), 0 /* vector_len */);
6480     pxor(xcrc, xtmp);
6481   } else {
6482     movdqa(xtmp, xcrc);
6483     pclmulhdq(xtmp, xK);   // [123:64]
6484     pclmulldq(xcrc, xK);   // [63:0]
6485     pxor(xcrc, xtmp);
6486     movdqu(xtmp, Address(buf, offset));
6487     pxor(xcrc, xtmp);
6488   }
6489 }
6490 
6491 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, XMMRegister xbuf) {
6492   if (UseAVX &gt; 0) {
6493     vpclmulhdq(xtmp, xK, xcrc);
6494     vpclmulldq(xcrc, xK, xcrc);
6495     pxor(xcrc, xbuf);
6496     pxor(xcrc, xtmp);
6497   } else {
6498     movdqa(xtmp, xcrc);
6499     pclmulhdq(xtmp, xK);
6500     pclmulldq(xcrc, xK);
6501     pxor(xcrc, xbuf);
6502     pxor(xcrc, xtmp);
6503   }
6504 }
6505 
6506 /**
6507  * 8-bit folds to compute 32-bit CRC
6508  *
6509  * uint64_t xcrc;
6510  * timesXtoThe32[xcrc &amp; 0xFF] ^ (xcrc &gt;&gt; 8);
6511  */
6512 void MacroAssembler::fold_8bit_crc32(XMMRegister xcrc, Register table, XMMRegister xtmp, Register tmp) {
6513   movdl(tmp, xcrc);
6514   andl(tmp, 0xFF);
6515   movdl(xtmp, Address(table, tmp, Address::times_4, 0));
6516   psrldq(xcrc, 1); // unsigned shift one byte
6517   pxor(xcrc, xtmp);
6518 }
6519 
6520 /**
6521  * uint32_t crc;
6522  * timesXtoThe32[crc &amp; 0xFF] ^ (crc &gt;&gt; 8);
6523  */
6524 void MacroAssembler::fold_8bit_crc32(Register crc, Register table, Register tmp) {
6525   movl(tmp, crc);
6526   andl(tmp, 0xFF);
6527   shrl(crc, 8);
6528   xorl(crc, Address(table, tmp, Address::times_4, 0));
6529 }
6530 
6531 /**
6532  * @param crc   register containing existing CRC (32-bit)
6533  * @param buf   register pointing to input byte buffer (byte*)
6534  * @param len   register containing number of bytes
6535  * @param table register that will contain address of CRC table
6536  * @param tmp   scratch register
6537  */
6538 void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len, Register table, Register tmp) {
6539   assert_different_registers(crc, buf, len, table, tmp, rax);
6540 
6541   Label L_tail, L_tail_restore, L_tail_loop, L_exit, L_align_loop, L_aligned;
6542   Label L_fold_tail, L_fold_128b, L_fold_512b, L_fold_512b_loop, L_fold_tail_loop;
6543 
6544   // For EVEX with VL and BW, provide a standard mask, VL = 128 will guide the merge
6545   // context for the registers used, where all instructions below are using 128-bit mode
6546   // On EVEX without VL and BW, these instructions will all be AVX.
6547   lea(table, ExternalAddress(StubRoutines::crc_table_addr()));
6548   notl(crc); // ~crc
6549   cmpl(len, 16);
6550   jcc(Assembler::less, L_tail);
6551 
6552   // Align buffer to 16 bytes
6553   movl(tmp, buf);
6554   andl(tmp, 0xF);
6555   jccb(Assembler::zero, L_aligned);
6556   subl(tmp,  16);
6557   addl(len, tmp);
6558 
6559   align(4);
6560   BIND(L_align_loop);
6561   movsbl(rax, Address(buf, 0)); // load byte with sign extension
6562   update_byte_crc32(crc, rax, table);
6563   increment(buf);
6564   incrementl(tmp);
6565   jccb(Assembler::less, L_align_loop);
6566 
6567   BIND(L_aligned);
6568   movl(tmp, len); // save
6569   shrl(len, 4);
6570   jcc(Assembler::zero, L_tail_restore);
6571 
6572   // Fold crc into first bytes of vector
6573   movdqa(xmm1, Address(buf, 0));
6574   movdl(rax, xmm1);
6575   xorl(crc, rax);
6576   if (VM_Version::supports_sse4_1()) {
6577     pinsrd(xmm1, crc, 0);
6578   } else {
6579     pinsrw(xmm1, crc, 0);
6580     shrl(crc, 16);
6581     pinsrw(xmm1, crc, 1);
6582   }
6583   addptr(buf, 16);
6584   subl(len, 4); // len &gt; 0
6585   jcc(Assembler::less, L_fold_tail);
6586 
6587   movdqa(xmm2, Address(buf,  0));
6588   movdqa(xmm3, Address(buf, 16));
6589   movdqa(xmm4, Address(buf, 32));
6590   addptr(buf, 48);
6591   subl(len, 3);
6592   jcc(Assembler::lessEqual, L_fold_512b);
6593 
6594   // Fold total 512 bits of polynomial on each iteration,
6595   // 128 bits per each of 4 parallel streams.
6596   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 32));
6597 
6598   align(32);
6599   BIND(L_fold_512b_loop);
6600   fold_128bit_crc32(xmm1, xmm0, xmm5, buf,  0);
6601   fold_128bit_crc32(xmm2, xmm0, xmm5, buf, 16);
6602   fold_128bit_crc32(xmm3, xmm0, xmm5, buf, 32);
6603   fold_128bit_crc32(xmm4, xmm0, xmm5, buf, 48);
6604   addptr(buf, 64);
6605   subl(len, 4);
6606   jcc(Assembler::greater, L_fold_512b_loop);
6607 
6608   // Fold 512 bits to 128 bits.
6609   BIND(L_fold_512b);
6610   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));
6611   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm2);
6612   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm3);
6613   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm4);
6614 
6615   // Fold the rest of 128 bits data chunks
6616   BIND(L_fold_tail);
6617   addl(len, 3);
6618   jccb(Assembler::lessEqual, L_fold_128b);
6619   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));
6620 
6621   BIND(L_fold_tail_loop);
6622   fold_128bit_crc32(xmm1, xmm0, xmm5, buf,  0);
6623   addptr(buf, 16);
6624   decrementl(len);
6625   jccb(Assembler::greater, L_fold_tail_loop);
6626 
6627   // Fold 128 bits in xmm1 down into 32 bits in crc register.
6628   BIND(L_fold_128b);
6629   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr()));
6630   if (UseAVX &gt; 0) {
6631     vpclmulqdq(xmm2, xmm0, xmm1, 0x1);
6632     vpand(xmm3, xmm0, xmm2, 0 /* vector_len */);
6633     vpclmulqdq(xmm0, xmm0, xmm3, 0x1);
6634   } else {
6635     movdqa(xmm2, xmm0);
6636     pclmulqdq(xmm2, xmm1, 0x1);
6637     movdqa(xmm3, xmm0);
6638     pand(xmm3, xmm2);
6639     pclmulqdq(xmm0, xmm3, 0x1);
6640   }
6641   psrldq(xmm1, 8);
6642   psrldq(xmm2, 4);
6643   pxor(xmm0, xmm1);
6644   pxor(xmm0, xmm2);
6645 
6646   // 8 8-bit folds to compute 32-bit CRC.
6647   for (int j = 0; j &lt; 4; j++) {
6648     fold_8bit_crc32(xmm0, table, xmm1, rax);
6649   }
6650   movdl(crc, xmm0); // mov 32 bits to general register
6651   for (int j = 0; j &lt; 4; j++) {
6652     fold_8bit_crc32(crc, table, rax);
6653   }
6654 
6655   BIND(L_tail_restore);
6656   movl(len, tmp); // restore
6657   BIND(L_tail);
6658   andl(len, 0xf);
6659   jccb(Assembler::zero, L_exit);
6660 
6661   // Fold the rest of bytes
6662   align(4);
6663   BIND(L_tail_loop);
6664   movsbl(rax, Address(buf, 0)); // load byte with sign extension
6665   update_byte_crc32(crc, rax, table);
6666   increment(buf);
6667   decrementl(len);
6668   jccb(Assembler::greater, L_tail_loop);
6669 
6670   BIND(L_exit);
6671   notl(crc); // ~c
6672 }
6673 
6674 #ifdef _LP64
6675 // Helper function for AVX 512 CRC32
6676 // Fold 512-bit data chunks
6677 void MacroAssembler::fold512bit_crc32_avx512(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf,
6678                                              Register pos, int offset) {
6679   evmovdquq(xmm3, Address(buf, pos, Address::times_1, offset), Assembler::AVX_512bit);
6680   evpclmulqdq(xtmp, xcrc, xK, 0x10, Assembler::AVX_512bit); // [123:64]
6681   evpclmulqdq(xmm2, xcrc, xK, 0x01, Assembler::AVX_512bit); // [63:0]
6682   evpxorq(xcrc, xtmp, xmm2, Assembler::AVX_512bit /* vector_len */);
6683   evpxorq(xcrc, xcrc, xmm3, Assembler::AVX_512bit /* vector_len */);
6684 }
6685 
6686 // Helper function for AVX 512 CRC32
6687 // Compute CRC32 for &lt; 256B buffers
6688 void MacroAssembler::kernel_crc32_avx512_256B(Register crc, Register buf, Register len, Register key, Register pos,
6689                                               Register tmp1, Register tmp2, Label&amp; L_barrett, Label&amp; L_16B_reduction_loop,
6690                                               Label&amp; L_get_last_two_xmms, Label&amp; L_128_done, Label&amp; L_cleanup) {
6691 
6692   Label L_less_than_32, L_exact_16_left, L_less_than_16_left;
6693   Label L_less_than_8_left, L_less_than_4_left, L_less_than_2_left, L_zero_left;
6694   Label L_only_less_than_4, L_only_less_than_3, L_only_less_than_2;
6695 
6696   // check if there is enough buffer to be able to fold 16B at a time
6697   cmpl(len, 32);
6698   jcc(Assembler::less, L_less_than_32);
6699 
6700   // if there is, load the constants
6701   movdqu(xmm10, Address(key, 1 * 16));    //rk1 and rk2 in xmm10
6702   movdl(xmm0, crc);                        // get the initial crc value
6703   movdqu(xmm7, Address(buf, pos, Address::times_1, 0 * 16)); //load the plaintext
6704   pxor(xmm7, xmm0);
6705 
6706   // update the buffer pointer
6707   addl(pos, 16);
6708   //update the counter.subtract 32 instead of 16 to save one instruction from the loop
6709   subl(len, 32);
6710   jmp(L_16B_reduction_loop);
6711 
6712   bind(L_less_than_32);
6713   //mov initial crc to the return value. this is necessary for zero - length buffers.
6714   movl(rax, crc);
6715   testl(len, len);
6716   jcc(Assembler::equal, L_cleanup);
6717 
6718   movdl(xmm0, crc);                        //get the initial crc value
6719 
6720   cmpl(len, 16);
6721   jcc(Assembler::equal, L_exact_16_left);
6722   jcc(Assembler::less, L_less_than_16_left);
6723 
6724   movdqu(xmm7, Address(buf, pos, Address::times_1, 0 * 16)); //load the plaintext
6725   pxor(xmm7, xmm0);                       //xor the initial crc value
6726   addl(pos, 16);
6727   subl(len, 16);
6728   movdqu(xmm10, Address(key, 1 * 16));    // rk1 and rk2 in xmm10
6729   jmp(L_get_last_two_xmms);
6730 
6731   bind(L_less_than_16_left);
6732   //use stack space to load data less than 16 bytes, zero - out the 16B in memory first.
6733   pxor(xmm1, xmm1);
6734   movptr(tmp1, rsp);
6735   movdqu(Address(tmp1, 0 * 16), xmm1);
6736 
6737   cmpl(len, 4);
6738   jcc(Assembler::less, L_only_less_than_4);
6739 
6740   //backup the counter value
6741   movl(tmp2, len);
6742   cmpl(len, 8);
6743   jcc(Assembler::less, L_less_than_8_left);
6744 
6745   //load 8 Bytes
6746   movq(rax, Address(buf, pos, Address::times_1, 0 * 16));
6747   movq(Address(tmp1, 0 * 16), rax);
6748   addptr(tmp1, 8);
6749   subl(len, 8);
6750   addl(pos, 8);
6751 
6752   bind(L_less_than_8_left);
6753   cmpl(len, 4);
6754   jcc(Assembler::less, L_less_than_4_left);
6755 
6756   //load 4 Bytes
6757   movl(rax, Address(buf, pos, Address::times_1, 0));
6758   movl(Address(tmp1, 0 * 16), rax);
6759   addptr(tmp1, 4);
6760   subl(len, 4);
6761   addl(pos, 4);
6762 
6763   bind(L_less_than_4_left);
6764   cmpl(len, 2);
6765   jcc(Assembler::less, L_less_than_2_left);
6766 
6767   // load 2 Bytes
6768   movw(rax, Address(buf, pos, Address::times_1, 0));
6769   movl(Address(tmp1, 0 * 16), rax);
6770   addptr(tmp1, 2);
6771   subl(len, 2);
6772   addl(pos, 2);
6773 
6774   bind(L_less_than_2_left);
6775   cmpl(len, 1);
6776   jcc(Assembler::less, L_zero_left);
6777 
6778   // load 1 Byte
6779   movb(rax, Address(buf, pos, Address::times_1, 0));
6780   movb(Address(tmp1, 0 * 16), rax);
6781 
6782   bind(L_zero_left);
6783   movdqu(xmm7, Address(rsp, 0));
6784   pxor(xmm7, xmm0);                       //xor the initial crc value
6785 
6786   lea(rax, ExternalAddress(StubRoutines::x86::shuf_table_crc32_avx512_addr()));
6787   movdqu(xmm0, Address(rax, tmp2));
6788   pshufb(xmm7, xmm0);
6789   jmp(L_128_done);
6790 
6791   bind(L_exact_16_left);
6792   movdqu(xmm7, Address(buf, pos, Address::times_1, 0));
6793   pxor(xmm7, xmm0);                       //xor the initial crc value
6794   jmp(L_128_done);
6795 
6796   bind(L_only_less_than_4);
6797   cmpl(len, 3);
6798   jcc(Assembler::less, L_only_less_than_3);
6799 
6800   // load 3 Bytes
6801   movb(rax, Address(buf, pos, Address::times_1, 0));
6802   movb(Address(tmp1, 0), rax);
6803 
6804   movb(rax, Address(buf, pos, Address::times_1, 1));
6805   movb(Address(tmp1, 1), rax);
6806 
6807   movb(rax, Address(buf, pos, Address::times_1, 2));
6808   movb(Address(tmp1, 2), rax);
6809 
6810   movdqu(xmm7, Address(rsp, 0));
6811   pxor(xmm7, xmm0);                     //xor the initial crc value
6812 
6813   pslldq(xmm7, 0x5);
6814   jmp(L_barrett);
6815   bind(L_only_less_than_3);
6816   cmpl(len, 2);
6817   jcc(Assembler::less, L_only_less_than_2);
6818 
6819   // load 2 Bytes
6820   movb(rax, Address(buf, pos, Address::times_1, 0));
6821   movb(Address(tmp1, 0), rax);
6822 
6823   movb(rax, Address(buf, pos, Address::times_1, 1));
6824   movb(Address(tmp1, 1), rax);
6825 
6826   movdqu(xmm7, Address(rsp, 0));
6827   pxor(xmm7, xmm0);                     //xor the initial crc value
6828 
6829   pslldq(xmm7, 0x6);
6830   jmp(L_barrett);
6831 
6832   bind(L_only_less_than_2);
6833   //load 1 Byte
6834   movb(rax, Address(buf, pos, Address::times_1, 0));
6835   movb(Address(tmp1, 0), rax);
6836 
6837   movdqu(xmm7, Address(rsp, 0));
6838   pxor(xmm7, xmm0);                     //xor the initial crc value
6839 
6840   pslldq(xmm7, 0x7);
6841 }
6842 
6843 /**
6844 * Compute CRC32 using AVX512 instructions
6845 * param crc   register containing existing CRC (32-bit)
6846 * param buf   register pointing to input byte buffer (byte*)
6847 * param len   register containing number of bytes
6848 * param tmp1  scratch register
6849 * param tmp2  scratch register
6850 * return rax  result register
6851 */
6852 void MacroAssembler::kernel_crc32_avx512(Register crc, Register buf, Register len, Register key, Register tmp1, Register tmp2) {
6853   assert_different_registers(crc, buf, len, key, tmp1, tmp2, rax);
6854 
6855   Label L_tail, L_tail_restore, L_tail_loop, L_exit, L_align_loop, L_aligned;
6856   Label L_fold_tail, L_fold_128b, L_fold_512b, L_fold_512b_loop, L_fold_tail_loop;
6857   Label L_less_than_256, L_fold_128_B_loop, L_fold_256_B_loop;
6858   Label L_fold_128_B_register, L_final_reduction_for_128, L_16B_reduction_loop;
6859   Label L_128_done, L_get_last_two_xmms, L_barrett, L_cleanup;
6860 
6861   const Register pos = r12;
6862   push(r12);
6863   subptr(rsp, 16 * 2 + 8);
6864 
6865   // For EVEX with VL and BW, provide a standard mask, VL = 128 will guide the merge
6866   // context for the registers used, where all instructions below are using 128-bit mode
6867   // On EVEX without VL and BW, these instructions will all be AVX.
6868   lea(key, ExternalAddress(StubRoutines::x86::crc_table_avx512_addr()));
6869   notl(crc);
6870   movl(pos, 0);
6871 
6872   // check if smaller than 256B
6873   cmpl(len, 256);
6874   jcc(Assembler::less, L_less_than_256);
6875 
6876   // load the initial crc value
6877   movdl(xmm10, crc);
6878 
6879   // receive the initial 64B data, xor the initial crc value
6880   evmovdquq(xmm0, Address(buf, pos, Address::times_1, 0 * 64), Assembler::AVX_512bit);
6881   evmovdquq(xmm4, Address(buf, pos, Address::times_1, 1 * 64), Assembler::AVX_512bit);
6882   evpxorq(xmm0, xmm0, xmm10, Assembler::AVX_512bit);
6883   evbroadcasti32x4(xmm10, Address(key, 2 * 16), Assembler::AVX_512bit); //zmm10 has rk3 and rk4
6884 
6885   subl(len, 256);
6886   cmpl(len, 256);
6887   jcc(Assembler::less, L_fold_128_B_loop);
6888 
6889   evmovdquq(xmm7, Address(buf, pos, Address::times_1, 2 * 64), Assembler::AVX_512bit);
6890   evmovdquq(xmm8, Address(buf, pos, Address::times_1, 3 * 64), Assembler::AVX_512bit);
6891   evbroadcasti32x4(xmm16, Address(key, 0 * 16), Assembler::AVX_512bit); //zmm16 has rk-1 and rk-2
6892   subl(len, 256);
6893 
6894   bind(L_fold_256_B_loop);
6895   addl(pos, 256);
6896   fold512bit_crc32_avx512(xmm0, xmm16, xmm1, buf, pos, 0 * 64);
6897   fold512bit_crc32_avx512(xmm4, xmm16, xmm1, buf, pos, 1 * 64);
6898   fold512bit_crc32_avx512(xmm7, xmm16, xmm1, buf, pos, 2 * 64);
6899   fold512bit_crc32_avx512(xmm8, xmm16, xmm1, buf, pos, 3 * 64);
6900 
6901   subl(len, 256);
6902   jcc(Assembler::greaterEqual, L_fold_256_B_loop);
6903 
6904   // Fold 256 into 128
6905   addl(pos, 256);
6906   evpclmulqdq(xmm1, xmm0, xmm10, 0x01, Assembler::AVX_512bit);
6907   evpclmulqdq(xmm2, xmm0, xmm10, 0x10, Assembler::AVX_512bit);
6908   vpternlogq(xmm7, 0x96, xmm1, xmm2, Assembler::AVX_512bit); // xor ABC
6909 
6910   evpclmulqdq(xmm5, xmm4, xmm10, 0x01, Assembler::AVX_512bit);
6911   evpclmulqdq(xmm6, xmm4, xmm10, 0x10, Assembler::AVX_512bit);
6912   vpternlogq(xmm8, 0x96, xmm5, xmm6, Assembler::AVX_512bit); // xor ABC
6913 
6914   evmovdquq(xmm0, xmm7, Assembler::AVX_512bit);
6915   evmovdquq(xmm4, xmm8, Assembler::AVX_512bit);
6916 
6917   addl(len, 128);
6918   jmp(L_fold_128_B_register);
6919 
6920   // at this section of the code, there is 128 * x + y(0 &lt;= y&lt;128) bytes of buffer.The fold_128_B_loop
6921   // loop will fold 128B at a time until we have 128 + y Bytes of buffer
6922 
6923   // fold 128B at a time.This section of the code folds 8 xmm registers in parallel
6924   bind(L_fold_128_B_loop);
6925   addl(pos, 128);
6926   fold512bit_crc32_avx512(xmm0, xmm10, xmm1, buf, pos, 0 * 64);
6927   fold512bit_crc32_avx512(xmm4, xmm10, xmm1, buf, pos, 1 * 64);
6928 
6929   subl(len, 128);
6930   jcc(Assembler::greaterEqual, L_fold_128_B_loop);
6931 
6932   addl(pos, 128);
6933 
6934   // at this point, the buffer pointer is pointing at the last y Bytes of the buffer, where 0 &lt;= y &lt; 128
6935   // the 128B of folded data is in 8 of the xmm registers : xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7
6936   bind(L_fold_128_B_register);
6937   evmovdquq(xmm16, Address(key, 5 * 16), Assembler::AVX_512bit); // multiply by rk9-rk16
6938   evmovdquq(xmm11, Address(key, 9 * 16), Assembler::AVX_512bit); // multiply by rk17-rk20, rk1,rk2, 0,0
6939   evpclmulqdq(xmm1, xmm0, xmm16, 0x01, Assembler::AVX_512bit);
6940   evpclmulqdq(xmm2, xmm0, xmm16, 0x10, Assembler::AVX_512bit);
6941   // save last that has no multiplicand
6942   vextracti64x2(xmm7, xmm4, 3);
6943 
6944   evpclmulqdq(xmm5, xmm4, xmm11, 0x01, Assembler::AVX_512bit);
6945   evpclmulqdq(xmm6, xmm4, xmm11, 0x10, Assembler::AVX_512bit);
6946   // Needed later in reduction loop
6947   movdqu(xmm10, Address(key, 1 * 16));
6948   vpternlogq(xmm1, 0x96, xmm2, xmm5, Assembler::AVX_512bit); // xor ABC
6949   vpternlogq(xmm1, 0x96, xmm6, xmm7, Assembler::AVX_512bit); // xor ABC
6950 
6951   // Swap 1,0,3,2 - 01 00 11 10
6952   evshufi64x2(xmm8, xmm1, xmm1, 0x4e, Assembler::AVX_512bit);
6953   evpxorq(xmm8, xmm8, xmm1, Assembler::AVX_256bit);
6954   vextracti128(xmm5, xmm8, 1);
6955   evpxorq(xmm7, xmm5, xmm8, Assembler::AVX_128bit);
6956 
6957   // instead of 128, we add 128 - 16 to the loop counter to save 1 instruction from the loop
6958   // instead of a cmp instruction, we use the negative flag with the jl instruction
6959   addl(len, 128 - 16);
6960   jcc(Assembler::less, L_final_reduction_for_128);
6961 
6962   bind(L_16B_reduction_loop);
6963   vpclmulqdq(xmm8, xmm7, xmm10, 0x1);
6964   vpclmulqdq(xmm7, xmm7, xmm10, 0x10);
6965   vpxor(xmm7, xmm7, xmm8, Assembler::AVX_128bit);
6966   movdqu(xmm0, Address(buf, pos, Address::times_1, 0 * 16));
6967   vpxor(xmm7, xmm7, xmm0, Assembler::AVX_128bit);
6968   addl(pos, 16);
6969   subl(len, 16);
6970   jcc(Assembler::greaterEqual, L_16B_reduction_loop);
6971 
6972   bind(L_final_reduction_for_128);
6973   addl(len, 16);
6974   jcc(Assembler::equal, L_128_done);
6975 
6976   bind(L_get_last_two_xmms);
6977   movdqu(xmm2, xmm7);
6978   addl(pos, len);
6979   movdqu(xmm1, Address(buf, pos, Address::times_1, -16));
6980   subl(pos, len);
6981 
6982   // get rid of the extra data that was loaded before
6983   // load the shift constant
6984   lea(rax, ExternalAddress(StubRoutines::x86::shuf_table_crc32_avx512_addr()));
6985   movdqu(xmm0, Address(rax, len));
6986   addl(rax, len);
6987 
6988   vpshufb(xmm7, xmm7, xmm0, Assembler::AVX_128bit);
6989   //Change mask to 512
6990   vpxor(xmm0, xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_avx512_addr() + 2 * 16), Assembler::AVX_128bit, tmp2);
6991   vpshufb(xmm2, xmm2, xmm0, Assembler::AVX_128bit);
6992 
6993   blendvpb(xmm2, xmm2, xmm1, xmm0, Assembler::AVX_128bit);
6994   vpclmulqdq(xmm8, xmm7, xmm10, 0x1);
6995   vpclmulqdq(xmm7, xmm7, xmm10, 0x10);
6996   vpxor(xmm7, xmm7, xmm8, Assembler::AVX_128bit);
6997   vpxor(xmm7, xmm7, xmm2, Assembler::AVX_128bit);
6998 
6999   bind(L_128_done);
7000   // compute crc of a 128-bit value
7001   movdqu(xmm10, Address(key, 3 * 16));
7002   movdqu(xmm0, xmm7);
7003 
7004   // 64b fold
7005   vpclmulqdq(xmm7, xmm7, xmm10, 0x0);
7006   vpsrldq(xmm0, xmm0, 0x8, Assembler::AVX_128bit);
7007   vpxor(xmm7, xmm7, xmm0, Assembler::AVX_128bit);
7008 
7009   // 32b fold
7010   movdqu(xmm0, xmm7);
7011   vpslldq(xmm7, xmm7, 0x4, Assembler::AVX_128bit);
7012   vpclmulqdq(xmm7, xmm7, xmm10, 0x10);
7013   vpxor(xmm7, xmm7, xmm0, Assembler::AVX_128bit);
7014   jmp(L_barrett);
7015 
7016   bind(L_less_than_256);
7017   kernel_crc32_avx512_256B(crc, buf, len, key, pos, tmp1, tmp2, L_barrett, L_16B_reduction_loop, L_get_last_two_xmms, L_128_done, L_cleanup);
7018 
7019   //barrett reduction
7020   bind(L_barrett);
7021   vpand(xmm7, xmm7, ExternalAddress(StubRoutines::x86::crc_by128_masks_avx512_addr() + 1 * 16), Assembler::AVX_128bit, tmp2);
7022   movdqu(xmm1, xmm7);
7023   movdqu(xmm2, xmm7);
7024   movdqu(xmm10, Address(key, 4 * 16));
7025 
7026   pclmulqdq(xmm7, xmm10, 0x0);
7027   pxor(xmm7, xmm2);
7028   vpand(xmm7, xmm7, ExternalAddress(StubRoutines::x86::crc_by128_masks_avx512_addr()), Assembler::AVX_128bit, tmp2);
7029   movdqu(xmm2, xmm7);
7030   pclmulqdq(xmm7, xmm10, 0x10);
7031   pxor(xmm7, xmm2);
7032   pxor(xmm7, xmm1);
7033   pextrd(crc, xmm7, 2);
7034 
7035   bind(L_cleanup);
7036   notl(crc); // ~c
7037   addptr(rsp, 16 * 2 + 8);
7038   pop(r12);
7039 }
7040 
7041 // S. Gueron / Information Processing Letters 112 (2012) 184
7042 // Algorithm 4: Computing carry-less multiplication using a precomputed lookup table.
7043 // Input: A 32 bit value B = [byte3, byte2, byte1, byte0].
7044 // Output: the 64-bit carry-less product of B * CONST
7045 void MacroAssembler::crc32c_ipl_alg4(Register in, uint32_t n,
7046                                      Register tmp1, Register tmp2, Register tmp3) {
7047   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
7048   if (n &gt; 0) {
7049     addq(tmp3, n * 256 * 8);
7050   }
7051   //    Q1 = TABLEExt[n][B &amp; 0xFF];
7052   movl(tmp1, in);
7053   andl(tmp1, 0x000000FF);
7054   shll(tmp1, 3);
7055   addq(tmp1, tmp3);
7056   movq(tmp1, Address(tmp1, 0));
7057 
7058   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
7059   movl(tmp2, in);
7060   shrl(tmp2, 8);
7061   andl(tmp2, 0x000000FF);
7062   shll(tmp2, 3);
7063   addq(tmp2, tmp3);
7064   movq(tmp2, Address(tmp2, 0));
7065 
7066   shlq(tmp2, 8);
7067   xorq(tmp1, tmp2);
7068 
7069   //    Q3 = TABLEExt[n][B &gt;&gt; 16 &amp; 0xFF];
7070   movl(tmp2, in);
7071   shrl(tmp2, 16);
7072   andl(tmp2, 0x000000FF);
7073   shll(tmp2, 3);
7074   addq(tmp2, tmp3);
7075   movq(tmp2, Address(tmp2, 0));
7076 
7077   shlq(tmp2, 16);
7078   xorq(tmp1, tmp2);
7079 
7080   //    Q4 = TABLEExt[n][B &gt;&gt; 24 &amp; 0xFF];
7081   shrl(in, 24);
7082   andl(in, 0x000000FF);
7083   shll(in, 3);
7084   addq(in, tmp3);
7085   movq(in, Address(in, 0));
7086 
7087   shlq(in, 24);
7088   xorq(in, tmp1);
7089   //    return Q1 ^ Q2 &lt;&lt; 8 ^ Q3 &lt;&lt; 16 ^ Q4 &lt;&lt; 24;
7090 }
7091 
7092 void MacroAssembler::crc32c_pclmulqdq(XMMRegister w_xtmp1,
7093                                       Register in_out,
7094                                       uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
7095                                       XMMRegister w_xtmp2,
7096                                       Register tmp1,
7097                                       Register n_tmp2, Register n_tmp3) {
7098   if (is_pclmulqdq_supported) {
7099     movdl(w_xtmp1, in_out); // modified blindly
7100 
7101     movl(tmp1, const_or_pre_comp_const_index);
7102     movdl(w_xtmp2, tmp1);
7103     pclmulqdq(w_xtmp1, w_xtmp2, 0);
7104 
7105     movdq(in_out, w_xtmp1);
7106   } else {
7107     crc32c_ipl_alg4(in_out, const_or_pre_comp_const_index, tmp1, n_tmp2, n_tmp3);
7108   }
7109 }
7110 
7111 // Recombination Alternative 2: No bit-reflections
7112 // T1 = (CRC_A * U1) &lt;&lt; 1
7113 // T2 = (CRC_B * U2) &lt;&lt; 1
7114 // C1 = T1 &gt;&gt; 32
7115 // C2 = T2 &gt;&gt; 32
7116 // T1 = T1 &amp; 0xFFFFFFFF
7117 // T2 = T2 &amp; 0xFFFFFFFF
7118 // T1 = CRC32(0, T1)
7119 // T2 = CRC32(0, T2)
7120 // C1 = C1 ^ T1
7121 // C2 = C2 ^ T2
7122 // CRC = C1 ^ C2 ^ CRC_C
7123 void MacroAssembler::crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
7124                                      XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7125                                      Register tmp1, Register tmp2,
7126                                      Register n_tmp3) {
7127   crc32c_pclmulqdq(w_xtmp1, in_out, const_or_pre_comp_const_index_u1, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7128   crc32c_pclmulqdq(w_xtmp2, in1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7129   shlq(in_out, 1);
7130   movl(tmp1, in_out);
7131   shrq(in_out, 32);
7132   xorl(tmp2, tmp2);
7133   crc32(tmp2, tmp1, 4);
7134   xorl(in_out, tmp2); // we don&#39;t care about upper 32 bit contents here
7135   shlq(in1, 1);
7136   movl(tmp1, in1);
7137   shrq(in1, 32);
7138   xorl(tmp2, tmp2);
7139   crc32(tmp2, tmp1, 4);
7140   xorl(in1, tmp2);
7141   xorl(in_out, in1);
7142   xorl(in_out, in2);
7143 }
7144 
7145 // Set N to predefined value
7146 // Subtract from a lenght of a buffer
7147 // execute in a loop:
7148 // CRC_A = 0xFFFFFFFF, CRC_B = 0, CRC_C = 0
7149 // for i = 1 to N do
7150 //  CRC_A = CRC32(CRC_A, A[i])
7151 //  CRC_B = CRC32(CRC_B, B[i])
7152 //  CRC_C = CRC32(CRC_C, C[i])
7153 // end for
7154 // Recombine
7155 void MacroAssembler::crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
7156                                        Register in_out1, Register in_out2, Register in_out3,
7157                                        Register tmp1, Register tmp2, Register tmp3,
7158                                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7159                                        Register tmp4, Register tmp5,
7160                                        Register n_tmp6) {
7161   Label L_processPartitions;
7162   Label L_processPartition;
7163   Label L_exit;
7164 
7165   bind(L_processPartitions);
7166   cmpl(in_out1, 3 * size);
7167   jcc(Assembler::less, L_exit);
7168     xorl(tmp1, tmp1);
7169     xorl(tmp2, tmp2);
7170     movq(tmp3, in_out2);
7171     addq(tmp3, size);
7172 
7173     bind(L_processPartition);
7174       crc32(in_out3, Address(in_out2, 0), 8);
7175       crc32(tmp1, Address(in_out2, size), 8);
7176       crc32(tmp2, Address(in_out2, size * 2), 8);
7177       addq(in_out2, 8);
7178       cmpq(in_out2, tmp3);
7179       jcc(Assembler::less, L_processPartition);
7180     crc32c_rec_alt2(const_or_pre_comp_const_index_u1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, in_out3, tmp1, tmp2,
7181             w_xtmp1, w_xtmp2, w_xtmp3,
7182             tmp4, tmp5,
7183             n_tmp6);
7184     addq(in_out2, 2 * size);
7185     subl(in_out1, 3 * size);
7186     jmp(L_processPartitions);
7187 
7188   bind(L_exit);
7189 }
7190 #else
7191 void MacroAssembler::crc32c_ipl_alg4(Register in_out, uint32_t n,
7192                                      Register tmp1, Register tmp2, Register tmp3,
7193                                      XMMRegister xtmp1, XMMRegister xtmp2) {
7194   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
7195   if (n &gt; 0) {
7196     addl(tmp3, n * 256 * 8);
7197   }
7198   //    Q1 = TABLEExt[n][B &amp; 0xFF];
7199   movl(tmp1, in_out);
7200   andl(tmp1, 0x000000FF);
7201   shll(tmp1, 3);
7202   addl(tmp1, tmp3);
7203   movq(xtmp1, Address(tmp1, 0));
7204 
7205   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
7206   movl(tmp2, in_out);
7207   shrl(tmp2, 8);
7208   andl(tmp2, 0x000000FF);
7209   shll(tmp2, 3);
7210   addl(tmp2, tmp3);
7211   movq(xtmp2, Address(tmp2, 0));
7212 
7213   psllq(xtmp2, 8);
7214   pxor(xtmp1, xtmp2);
7215 
7216   //    Q3 = TABLEExt[n][B &gt;&gt; 16 &amp; 0xFF];
7217   movl(tmp2, in_out);
7218   shrl(tmp2, 16);
7219   andl(tmp2, 0x000000FF);
7220   shll(tmp2, 3);
7221   addl(tmp2, tmp3);
7222   movq(xtmp2, Address(tmp2, 0));
7223 
7224   psllq(xtmp2, 16);
7225   pxor(xtmp1, xtmp2);
7226 
7227   //    Q4 = TABLEExt[n][B &gt;&gt; 24 &amp; 0xFF];
7228   shrl(in_out, 24);
7229   andl(in_out, 0x000000FF);
7230   shll(in_out, 3);
7231   addl(in_out, tmp3);
7232   movq(xtmp2, Address(in_out, 0));
7233 
7234   psllq(xtmp2, 24);
7235   pxor(xtmp1, xtmp2); // Result in CXMM
7236   //    return Q1 ^ Q2 &lt;&lt; 8 ^ Q3 &lt;&lt; 16 ^ Q4 &lt;&lt; 24;
7237 }
7238 
7239 void MacroAssembler::crc32c_pclmulqdq(XMMRegister w_xtmp1,
7240                                       Register in_out,
7241                                       uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
7242                                       XMMRegister w_xtmp2,
7243                                       Register tmp1,
7244                                       Register n_tmp2, Register n_tmp3) {
7245   if (is_pclmulqdq_supported) {
7246     movdl(w_xtmp1, in_out);
7247 
7248     movl(tmp1, const_or_pre_comp_const_index);
7249     movdl(w_xtmp2, tmp1);
7250     pclmulqdq(w_xtmp1, w_xtmp2, 0);
7251     // Keep result in XMM since GPR is 32 bit in length
7252   } else {
7253     crc32c_ipl_alg4(in_out, const_or_pre_comp_const_index, tmp1, n_tmp2, n_tmp3, w_xtmp1, w_xtmp2);
7254   }
7255 }
7256 
7257 void MacroAssembler::crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
7258                                      XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7259                                      Register tmp1, Register tmp2,
7260                                      Register n_tmp3) {
7261   crc32c_pclmulqdq(w_xtmp1, in_out, const_or_pre_comp_const_index_u1, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7262   crc32c_pclmulqdq(w_xtmp2, in1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7263 
7264   psllq(w_xtmp1, 1);
7265   movdl(tmp1, w_xtmp1);
7266   psrlq(w_xtmp1, 32);
7267   movdl(in_out, w_xtmp1);
7268 
7269   xorl(tmp2, tmp2);
7270   crc32(tmp2, tmp1, 4);
7271   xorl(in_out, tmp2);
7272 
7273   psllq(w_xtmp2, 1);
7274   movdl(tmp1, w_xtmp2);
7275   psrlq(w_xtmp2, 32);
7276   movdl(in1, w_xtmp2);
7277 
7278   xorl(tmp2, tmp2);
7279   crc32(tmp2, tmp1, 4);
7280   xorl(in1, tmp2);
7281   xorl(in_out, in1);
7282   xorl(in_out, in2);
7283 }
7284 
7285 void MacroAssembler::crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
7286                                        Register in_out1, Register in_out2, Register in_out3,
7287                                        Register tmp1, Register tmp2, Register tmp3,
7288                                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7289                                        Register tmp4, Register tmp5,
7290                                        Register n_tmp6) {
7291   Label L_processPartitions;
7292   Label L_processPartition;
7293   Label L_exit;
7294 
7295   bind(L_processPartitions);
7296   cmpl(in_out1, 3 * size);
7297   jcc(Assembler::less, L_exit);
7298     xorl(tmp1, tmp1);
7299     xorl(tmp2, tmp2);
7300     movl(tmp3, in_out2);
7301     addl(tmp3, size);
7302 
7303     bind(L_processPartition);
7304       crc32(in_out3, Address(in_out2, 0), 4);
7305       crc32(tmp1, Address(in_out2, size), 4);
7306       crc32(tmp2, Address(in_out2, size*2), 4);
7307       crc32(in_out3, Address(in_out2, 0+4), 4);
7308       crc32(tmp1, Address(in_out2, size+4), 4);
7309       crc32(tmp2, Address(in_out2, size*2+4), 4);
7310       addl(in_out2, 8);
7311       cmpl(in_out2, tmp3);
7312       jcc(Assembler::less, L_processPartition);
7313 
7314         push(tmp3);
7315         push(in_out1);
7316         push(in_out2);
7317         tmp4 = tmp3;
7318         tmp5 = in_out1;
7319         n_tmp6 = in_out2;
7320 
7321       crc32c_rec_alt2(const_or_pre_comp_const_index_u1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, in_out3, tmp1, tmp2,
7322             w_xtmp1, w_xtmp2, w_xtmp3,
7323             tmp4, tmp5,
7324             n_tmp6);
7325 
7326         pop(in_out2);
7327         pop(in_out1);
7328         pop(tmp3);
7329 
7330     addl(in_out2, 2 * size);
7331     subl(in_out1, 3 * size);
7332     jmp(L_processPartitions);
7333 
7334   bind(L_exit);
7335 }
7336 #endif //LP64
7337 
7338 #ifdef _LP64
7339 // Algorithm 2: Pipelined usage of the CRC32 instruction.
7340 // Input: A buffer I of L bytes.
7341 // Output: the CRC32C value of the buffer.
7342 // Notations:
7343 // Write L = 24N + r, with N = floor (L/24).
7344 // r = L mod 24 (0 &lt;= r &lt; 24).
7345 // Consider I as the concatenation of A|B|C|R, where A, B, C, each,
7346 // N quadwords, and R consists of r bytes.
7347 // A[j] = I [8j+7:8j], j= 0, 1, ..., N-1
7348 // B[j] = I [N + 8j+7:N + 8j], j= 0, 1, ..., N-1
7349 // C[j] = I [2N + 8j+7:2N + 8j], j= 0, 1, ..., N-1
7350 // if r &gt; 0 R[j] = I [3N +j], j= 0, 1, ...,r-1
7351 void MacroAssembler::crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
7352                                           Register tmp1, Register tmp2, Register tmp3,
7353                                           Register tmp4, Register tmp5, Register tmp6,
7354                                           XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7355                                           bool is_pclmulqdq_supported) {
7356   uint32_t const_or_pre_comp_const_index[CRC32C_NUM_PRECOMPUTED_CONSTANTS];
7357   Label L_wordByWord;
7358   Label L_byteByByteProlog;
7359   Label L_byteByByte;
7360   Label L_exit;
7361 
7362   if (is_pclmulqdq_supported ) {
7363     const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;
7364     const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr+1);
7365 
7366     const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);
7367     const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);
7368 
7369     const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);
7370     const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);
7371     assert((CRC32C_NUM_PRECOMPUTED_CONSTANTS - 1 ) == 5, &quot;Checking whether you declared all of the constants based on the number of \&quot;chunks\&quot;&quot;);
7372   } else {
7373     const_or_pre_comp_const_index[0] = 1;
7374     const_or_pre_comp_const_index[1] = 0;
7375 
7376     const_or_pre_comp_const_index[2] = 3;
7377     const_or_pre_comp_const_index[3] = 2;
7378 
7379     const_or_pre_comp_const_index[4] = 5;
7380     const_or_pre_comp_const_index[5] = 4;
7381    }
7382   crc32c_proc_chunk(CRC32C_HIGH, const_or_pre_comp_const_index[0], const_or_pre_comp_const_index[1], is_pclmulqdq_supported,
7383                     in2, in1, in_out,
7384                     tmp1, tmp2, tmp3,
7385                     w_xtmp1, w_xtmp2, w_xtmp3,
7386                     tmp4, tmp5,
7387                     tmp6);
7388   crc32c_proc_chunk(CRC32C_MIDDLE, const_or_pre_comp_const_index[2], const_or_pre_comp_const_index[3], is_pclmulqdq_supported,
7389                     in2, in1, in_out,
7390                     tmp1, tmp2, tmp3,
7391                     w_xtmp1, w_xtmp2, w_xtmp3,
7392                     tmp4, tmp5,
7393                     tmp6);
7394   crc32c_proc_chunk(CRC32C_LOW, const_or_pre_comp_const_index[4], const_or_pre_comp_const_index[5], is_pclmulqdq_supported,
7395                     in2, in1, in_out,
7396                     tmp1, tmp2, tmp3,
7397                     w_xtmp1, w_xtmp2, w_xtmp3,
7398                     tmp4, tmp5,
7399                     tmp6);
7400   movl(tmp1, in2);
7401   andl(tmp1, 0x00000007);
7402   negl(tmp1);
7403   addl(tmp1, in2);
7404   addq(tmp1, in1);
7405 
7406   BIND(L_wordByWord);
7407   cmpq(in1, tmp1);
7408   jcc(Assembler::greaterEqual, L_byteByByteProlog);
7409     crc32(in_out, Address(in1, 0), 4);
7410     addq(in1, 4);
7411     jmp(L_wordByWord);
7412 
7413   BIND(L_byteByByteProlog);
7414   andl(in2, 0x00000007);
7415   movl(tmp2, 1);
7416 
7417   BIND(L_byteByByte);
7418   cmpl(tmp2, in2);
7419   jccb(Assembler::greater, L_exit);
7420     crc32(in_out, Address(in1, 0), 1);
7421     incq(in1);
7422     incl(tmp2);
7423     jmp(L_byteByByte);
7424 
7425   BIND(L_exit);
7426 }
7427 #else
7428 void MacroAssembler::crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
7429                                           Register tmp1, Register  tmp2, Register tmp3,
7430                                           Register tmp4, Register  tmp5, Register tmp6,
7431                                           XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7432                                           bool is_pclmulqdq_supported) {
7433   uint32_t const_or_pre_comp_const_index[CRC32C_NUM_PRECOMPUTED_CONSTANTS];
7434   Label L_wordByWord;
7435   Label L_byteByByteProlog;
7436   Label L_byteByByte;
7437   Label L_exit;
7438 
7439   if (is_pclmulqdq_supported) {
7440     const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;
7441     const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 1);
7442 
7443     const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);
7444     const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);
7445 
7446     const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);
7447     const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);
7448   } else {
7449     const_or_pre_comp_const_index[0] = 1;
7450     const_or_pre_comp_const_index[1] = 0;
7451 
7452     const_or_pre_comp_const_index[2] = 3;
7453     const_or_pre_comp_const_index[3] = 2;
7454 
7455     const_or_pre_comp_const_index[4] = 5;
7456     const_or_pre_comp_const_index[5] = 4;
7457   }
7458   crc32c_proc_chunk(CRC32C_HIGH, const_or_pre_comp_const_index[0], const_or_pre_comp_const_index[1], is_pclmulqdq_supported,
7459                     in2, in1, in_out,
7460                     tmp1, tmp2, tmp3,
7461                     w_xtmp1, w_xtmp2, w_xtmp3,
7462                     tmp4, tmp5,
7463                     tmp6);
7464   crc32c_proc_chunk(CRC32C_MIDDLE, const_or_pre_comp_const_index[2], const_or_pre_comp_const_index[3], is_pclmulqdq_supported,
7465                     in2, in1, in_out,
7466                     tmp1, tmp2, tmp3,
7467                     w_xtmp1, w_xtmp2, w_xtmp3,
7468                     tmp4, tmp5,
7469                     tmp6);
7470   crc32c_proc_chunk(CRC32C_LOW, const_or_pre_comp_const_index[4], const_or_pre_comp_const_index[5], is_pclmulqdq_supported,
7471                     in2, in1, in_out,
7472                     tmp1, tmp2, tmp3,
7473                     w_xtmp1, w_xtmp2, w_xtmp3,
7474                     tmp4, tmp5,
7475                     tmp6);
7476   movl(tmp1, in2);
7477   andl(tmp1, 0x00000007);
7478   negl(tmp1);
7479   addl(tmp1, in2);
7480   addl(tmp1, in1);
7481 
7482   BIND(L_wordByWord);
7483   cmpl(in1, tmp1);
7484   jcc(Assembler::greaterEqual, L_byteByByteProlog);
7485     crc32(in_out, Address(in1,0), 4);
7486     addl(in1, 4);
7487     jmp(L_wordByWord);
7488 
7489   BIND(L_byteByByteProlog);
7490   andl(in2, 0x00000007);
7491   movl(tmp2, 1);
7492 
7493   BIND(L_byteByByte);
7494   cmpl(tmp2, in2);
7495   jccb(Assembler::greater, L_exit);
7496     movb(tmp1, Address(in1, 0));
7497     crc32(in_out, tmp1, 1);
7498     incl(in1);
7499     incl(tmp2);
7500     jmp(L_byteByByte);
7501 
7502   BIND(L_exit);
7503 }
7504 #endif // LP64
7505 #undef BIND
7506 #undef BLOCK_COMMENT
7507 
7508 // Compress char[] array to byte[].
7509 //   ..\jdk\src\java.base\share\classes\java\lang\StringUTF16.java
7510 //   @HotSpotIntrinsicCandidate
7511 //   private static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {
7512 //     for (int i = 0; i &lt; len; i++) {
7513 //       int c = src[srcOff++];
7514 //       if (c &gt;&gt;&gt; 8 != 0) {
7515 //         return 0;
7516 //       }
7517 //       dst[dstOff++] = (byte)c;
7518 //     }
7519 //     return len;
7520 //   }
7521 void MacroAssembler::char_array_compress(Register src, Register dst, Register len,
7522   XMMRegister tmp1Reg, XMMRegister tmp2Reg,
7523   XMMRegister tmp3Reg, XMMRegister tmp4Reg,
7524   Register tmp5, Register result) {
7525   Label copy_chars_loop, return_length, return_zero, done;
7526 
7527   // rsi: src
7528   // rdi: dst
7529   // rdx: len
7530   // rcx: tmp5
7531   // rax: result
7532 
7533   // rsi holds start addr of source char[] to be compressed
7534   // rdi holds start addr of destination byte[]
7535   // rdx holds length
7536 
7537   assert(len != result, &quot;&quot;);
7538 
7539   // save length for return
7540   push(len);
7541 
7542   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp; // AVX512
7543     VM_Version::supports_avx512vlbw() &amp;&amp;
7544     VM_Version::supports_bmi2()) {
7545 
7546     Label copy_32_loop, copy_loop_tail, below_threshold;
7547 
7548     // alignment
7549     Label post_alignment;
7550 
7551     // if length of the string is less than 16, handle it in an old fashioned way
7552     testl(len, -32);
7553     jcc(Assembler::zero, below_threshold);
7554 
7555     // First check whether a character is compressable ( &lt;= 0xFF).
7556     // Create mask to test for Unicode chars inside zmm vector
7557     movl(result, 0x00FF);
7558     evpbroadcastw(tmp2Reg, result, Assembler::AVX_512bit);
7559 
7560     testl(len, -64);
7561     jcc(Assembler::zero, post_alignment);
7562 
7563     movl(tmp5, dst);
7564     andl(tmp5, (32 - 1));
7565     negl(tmp5);
7566     andl(tmp5, (32 - 1));
7567 
7568     // bail out when there is nothing to be done
7569     testl(tmp5, 0xFFFFFFFF);
7570     jcc(Assembler::zero, post_alignment);
7571 
7572     // ~(~0 &lt;&lt; len), where len is the # of remaining elements to process
7573     movl(result, 0xFFFFFFFF);
7574     shlxl(result, result, tmp5);
7575     notl(result);
7576     kmovdl(k3, result);
7577 
7578     evmovdquw(tmp1Reg, k3, Address(src, 0), Assembler::AVX_512bit);
7579     evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
7580     ktestd(k2, k3);
7581     jcc(Assembler::carryClear, return_zero);
7582 
7583     evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);
7584 
7585     addptr(src, tmp5);
7586     addptr(src, tmp5);
7587     addptr(dst, tmp5);
7588     subl(len, tmp5);
7589 
7590     bind(post_alignment);
7591     // end of alignment
7592 
7593     movl(tmp5, len);
7594     andl(tmp5, (32 - 1));    // tail count (in chars)
7595     andl(len, ~(32 - 1));    // vector count (in chars)
7596     jcc(Assembler::zero, copy_loop_tail);
7597 
7598     lea(src, Address(src, len, Address::times_2));
7599     lea(dst, Address(dst, len, Address::times_1));
7600     negptr(len);
7601 
7602     bind(copy_32_loop);
7603     evmovdquw(tmp1Reg, Address(src, len, Address::times_2), Assembler::AVX_512bit);
7604     evpcmpuw(k2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
7605     kortestdl(k2, k2);
7606     jcc(Assembler::carryClear, return_zero);
7607 
7608     // All elements in current processed chunk are valid candidates for
7609     // compression. Write a truncated byte elements to the memory.
7610     evpmovwb(Address(dst, len, Address::times_1), tmp1Reg, Assembler::AVX_512bit);
7611     addptr(len, 32);
7612     jcc(Assembler::notZero, copy_32_loop);
7613 
7614     bind(copy_loop_tail);
7615     // bail out when there is nothing to be done
7616     testl(tmp5, 0xFFFFFFFF);
7617     jcc(Assembler::zero, return_length);
7618 
7619     movl(len, tmp5);
7620 
7621     // ~(~0 &lt;&lt; len), where len is the # of remaining elements to process
7622     movl(result, 0xFFFFFFFF);
7623     shlxl(result, result, len);
7624     notl(result);
7625 
7626     kmovdl(k3, result);
7627 
7628     evmovdquw(tmp1Reg, k3, Address(src, 0), Assembler::AVX_512bit);
7629     evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
7630     ktestd(k2, k3);
7631     jcc(Assembler::carryClear, return_zero);
7632 
7633     evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);
7634     jmp(return_length);
7635 
7636     bind(below_threshold);
7637   }
7638 
7639   if (UseSSE42Intrinsics) {
7640     Label copy_32_loop, copy_16, copy_tail;
7641 
7642     movl(result, len);
7643 
7644     movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vectors
7645 
7646     // vectored compression
7647     andl(len, 0xfffffff0);    // vector count (in chars)
7648     andl(result, 0x0000000f);    // tail count (in chars)
7649     testl(len, len);
7650     jcc(Assembler::zero, copy_16);
7651 
7652     // compress 16 chars per iter
7653     movdl(tmp1Reg, tmp5);
7654     pshufd(tmp1Reg, tmp1Reg, 0);   // store Unicode mask in tmp1Reg
7655     pxor(tmp4Reg, tmp4Reg);
7656 
7657     lea(src, Address(src, len, Address::times_2));
7658     lea(dst, Address(dst, len, Address::times_1));
7659     negptr(len);
7660 
7661     bind(copy_32_loop);
7662     movdqu(tmp2Reg, Address(src, len, Address::times_2));     // load 1st 8 characters
7663     por(tmp4Reg, tmp2Reg);
7664     movdqu(tmp3Reg, Address(src, len, Address::times_2, 16)); // load next 8 characters
7665     por(tmp4Reg, tmp3Reg);
7666     ptest(tmp4Reg, tmp1Reg);       // check for Unicode chars in next vector
7667     jcc(Assembler::notZero, return_zero);
7668     packuswb(tmp2Reg, tmp3Reg);    // only ASCII chars; compress each to 1 byte
7669     movdqu(Address(dst, len, Address::times_1), tmp2Reg);
7670     addptr(len, 16);
7671     jcc(Assembler::notZero, copy_32_loop);
7672 
7673     // compress next vector of 8 chars (if any)
7674     bind(copy_16);
7675     movl(len, result);
7676     andl(len, 0xfffffff8);    // vector count (in chars)
7677     andl(result, 0x00000007);    // tail count (in chars)
7678     testl(len, len);
7679     jccb(Assembler::zero, copy_tail);
7680 
7681     movdl(tmp1Reg, tmp5);
7682     pshufd(tmp1Reg, tmp1Reg, 0);   // store Unicode mask in tmp1Reg
7683     pxor(tmp3Reg, tmp3Reg);
7684 
7685     movdqu(tmp2Reg, Address(src, 0));
7686     ptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in vector
7687     jccb(Assembler::notZero, return_zero);
7688     packuswb(tmp2Reg, tmp3Reg);    // only LATIN1 chars; compress each to 1 byte
7689     movq(Address(dst, 0), tmp2Reg);
7690     addptr(src, 16);
7691     addptr(dst, 8);
7692 
7693     bind(copy_tail);
7694     movl(len, result);
7695   }
7696   // compress 1 char per iter
7697   testl(len, len);
7698   jccb(Assembler::zero, return_length);
7699   lea(src, Address(src, len, Address::times_2));
7700   lea(dst, Address(dst, len, Address::times_1));
7701   negptr(len);
7702 
7703   bind(copy_chars_loop);
7704   load_unsigned_short(result, Address(src, len, Address::times_2));
7705   testl(result, 0xff00);      // check if Unicode char
7706   jccb(Assembler::notZero, return_zero);
7707   movb(Address(dst, len, Address::times_1), result);  // ASCII char; compress to 1 byte
7708   increment(len);
7709   jcc(Assembler::notZero, copy_chars_loop);
7710 
7711   // if compression succeeded, return length
7712   bind(return_length);
7713   pop(result);
7714   jmpb(done);
7715 
7716   // if compression failed, return 0
7717   bind(return_zero);
7718   xorl(result, result);
7719   addptr(rsp, wordSize);
7720 
7721   bind(done);
7722 }
7723 
7724 // Inflate byte[] array to char[].
7725 //   ..\jdk\src\java.base\share\classes\java\lang\StringLatin1.java
7726 //   @HotSpotIntrinsicCandidate
7727 //   private static void inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len) {
7728 //     for (int i = 0; i &lt; len; i++) {
7729 //       dst[dstOff++] = (char)(src[srcOff++] &amp; 0xff);
7730 //     }
7731 //   }
7732 void MacroAssembler::byte_array_inflate(Register src, Register dst, Register len,
7733   XMMRegister tmp1, Register tmp2) {
7734   Label copy_chars_loop, done, below_threshold, avx3_threshold;
7735   // rsi: src
7736   // rdi: dst
7737   // rdx: len
7738   // rcx: tmp2
7739 
7740   // rsi holds start addr of source byte[] to be inflated
7741   // rdi holds start addr of destination char[]
7742   // rdx holds length
7743   assert_different_registers(src, dst, len, tmp2);
7744   movl(tmp2, len);
7745   if ((UseAVX &gt; 2) &amp;&amp; // AVX512
7746     VM_Version::supports_avx512vlbw() &amp;&amp;
7747     VM_Version::supports_bmi2()) {
7748 
7749     Label copy_32_loop, copy_tail;
7750     Register tmp3_aliased = len;
7751 
7752     // if length of the string is less than 16, handle it in an old fashioned way
7753     testl(len, -16);
7754     jcc(Assembler::zero, below_threshold);
7755 
7756     testl(len, -1 * AVX3Threshold);
7757     jcc(Assembler::zero, avx3_threshold);
7758 
7759     // In order to use only one arithmetic operation for the main loop we use
7760     // this pre-calculation
7761     andl(tmp2, (32 - 1)); // tail count (in chars), 32 element wide loop
7762     andl(len, -32);     // vector count
7763     jccb(Assembler::zero, copy_tail);
7764 
7765     lea(src, Address(src, len, Address::times_1));
7766     lea(dst, Address(dst, len, Address::times_2));
7767     negptr(len);
7768 
7769 
7770     // inflate 32 chars per iter
7771     bind(copy_32_loop);
7772     vpmovzxbw(tmp1, Address(src, len, Address::times_1), Assembler::AVX_512bit);
7773     evmovdquw(Address(dst, len, Address::times_2), tmp1, Assembler::AVX_512bit);
7774     addptr(len, 32);
7775     jcc(Assembler::notZero, copy_32_loop);
7776 
7777     bind(copy_tail);
7778     // bail out when there is nothing to be done
7779     testl(tmp2, -1); // we don&#39;t destroy the contents of tmp2 here
7780     jcc(Assembler::zero, done);
7781 
7782     // ~(~0 &lt;&lt; length), where length is the # of remaining elements to process
7783     movl(tmp3_aliased, -1);
7784     shlxl(tmp3_aliased, tmp3_aliased, tmp2);
7785     notl(tmp3_aliased);
7786     kmovdl(k2, tmp3_aliased);
7787     evpmovzxbw(tmp1, k2, Address(src, 0), Assembler::AVX_512bit);
7788     evmovdquw(Address(dst, 0), k2, tmp1, Assembler::AVX_512bit);
7789 
7790     jmp(done);
7791     bind(avx3_threshold);
7792   }
7793   if (UseSSE42Intrinsics) {
7794     Label copy_16_loop, copy_8_loop, copy_bytes, copy_new_tail, copy_tail;
7795 
7796     if (UseAVX &gt; 1) {
7797       andl(tmp2, (16 - 1));
7798       andl(len, -16);
7799       jccb(Assembler::zero, copy_new_tail);
7800     } else {
7801       andl(tmp2, 0x00000007);   // tail count (in chars)
7802       andl(len, 0xfffffff8);    // vector count (in chars)
7803       jccb(Assembler::zero, copy_tail);
7804     }
7805 
7806     // vectored inflation
7807     lea(src, Address(src, len, Address::times_1));
7808     lea(dst, Address(dst, len, Address::times_2));
7809     negptr(len);
7810 
7811     if (UseAVX &gt; 1) {
7812       bind(copy_16_loop);
7813       vpmovzxbw(tmp1, Address(src, len, Address::times_1), Assembler::AVX_256bit);
7814       vmovdqu(Address(dst, len, Address::times_2), tmp1);
7815       addptr(len, 16);
7816       jcc(Assembler::notZero, copy_16_loop);
7817 
7818       bind(below_threshold);
7819       bind(copy_new_tail);
7820       movl(len, tmp2);
7821       andl(tmp2, 0x00000007);
7822       andl(len, 0xFFFFFFF8);
7823       jccb(Assembler::zero, copy_tail);
7824 
7825       pmovzxbw(tmp1, Address(src, 0));
7826       movdqu(Address(dst, 0), tmp1);
7827       addptr(src, 8);
7828       addptr(dst, 2 * 8);
7829 
7830       jmp(copy_tail, true);
7831     }
7832 
7833     // inflate 8 chars per iter
7834     bind(copy_8_loop);
7835     pmovzxbw(tmp1, Address(src, len, Address::times_1));  // unpack to 8 words
7836     movdqu(Address(dst, len, Address::times_2), tmp1);
7837     addptr(len, 8);
7838     jcc(Assembler::notZero, copy_8_loop);
7839 
7840     bind(copy_tail);
7841     movl(len, tmp2);
7842 
7843     cmpl(len, 4);
7844     jccb(Assembler::less, copy_bytes);
7845 
7846     movdl(tmp1, Address(src, 0));  // load 4 byte chars
7847     pmovzxbw(tmp1, tmp1);
7848     movq(Address(dst, 0), tmp1);
7849     subptr(len, 4);
7850     addptr(src, 4);
7851     addptr(dst, 8);
7852 
7853     bind(copy_bytes);
7854   } else {
7855     bind(below_threshold);
7856   }
7857 
7858   testl(len, len);
7859   jccb(Assembler::zero, done);
7860   lea(src, Address(src, len, Address::times_1));
7861   lea(dst, Address(dst, len, Address::times_2));
7862   negptr(len);
7863 
7864   // inflate 1 char per iter
7865   bind(copy_chars_loop);
7866   load_unsigned_byte(tmp2, Address(src, len, Address::times_1));  // load byte char
7867   movw(Address(dst, len, Address::times_2), tmp2);  // inflate byte char to word
7868   increment(len);
7869   jcc(Assembler::notZero, copy_chars_loop);
7870 
7871   bind(done);
7872 }
7873 
7874 #ifdef _LP64
7875 void MacroAssembler::convert_f2i(Register dst, XMMRegister src) {
7876   Label done;
7877   cvttss2sil(dst, src);
7878   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
7879   cmpl(dst, 0x80000000); // float_sign_flip
7880   jccb(Assembler::notEqual, done);
7881   subptr(rsp, 8);
7882   movflt(Address(rsp, 0), src);
7883   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));
7884   pop(dst);
7885   bind(done);
7886 }
7887 
7888 void MacroAssembler::convert_d2i(Register dst, XMMRegister src) {
7889   Label done;
7890   cvttsd2sil(dst, src);
7891   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
7892   cmpl(dst, 0x80000000); // float_sign_flip
7893   jccb(Assembler::notEqual, done);
7894   subptr(rsp, 8);
7895   movdbl(Address(rsp, 0), src);
7896   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));
7897   pop(dst);
7898   bind(done);
7899 }
7900 
7901 void MacroAssembler::convert_f2l(Register dst, XMMRegister src) {
7902   Label done;
7903   cvttss2siq(dst, src);
7904   cmp64(dst, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
7905   jccb(Assembler::notEqual, done);
7906   subptr(rsp, 8);
7907   movflt(Address(rsp, 0), src);
7908   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));
7909   pop(dst);
7910   bind(done);
7911 }
7912 
7913 void MacroAssembler::convert_d2l(Register dst, XMMRegister src) {
7914   Label done;
7915   cvttsd2siq(dst, src);
7916   cmp64(dst, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
7917   jccb(Assembler::notEqual, done);
7918   subptr(rsp, 8);
7919   movdbl(Address(rsp, 0), src);
7920   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));
7921   pop(dst);
7922   bind(done);
7923 }
7924 
7925 void MacroAssembler::cache_wb(Address line)
7926 {
7927   // 64 bit cpus always support clflush
7928   assert(VM_Version::supports_clflush(), &quot;clflush should be available&quot;);
7929   bool optimized = VM_Version::supports_clflushopt();
7930   bool no_evict = VM_Version::supports_clwb();
7931 
7932   // prefer clwb (writeback without evict) otherwise
7933   // prefer clflushopt (potentially parallel writeback with evict)
7934   // otherwise fallback on clflush (serial writeback with evict)
7935 
7936   if (optimized) {
7937     if (no_evict) {
7938       clwb(line);
7939     } else {
7940       clflushopt(line);
7941     }
7942   } else {
7943     // no need for fence when using CLFLUSH
7944     clflush(line);
7945   }
7946 }
7947 
7948 void MacroAssembler::cache_wbsync(bool is_pre)
7949 {
7950   assert(VM_Version::supports_clflush(), &quot;clflush should be available&quot;);
7951   bool optimized = VM_Version::supports_clflushopt();
7952   bool no_evict = VM_Version::supports_clwb();
7953 
7954   // pick the correct implementation
7955 
7956   if (!is_pre &amp;&amp; (optimized || no_evict)) {
7957     // need an sfence for post flush when using clflushopt or clwb
7958     // otherwise no no need for any synchroniaztion
7959 
7960     sfence();
7961   }
7962 }
7963 #endif // _LP64
7964 
7965 Assembler::Condition MacroAssembler::negate_condition(Assembler::Condition cond) {
7966   switch (cond) {
7967     // Note some conditions are synonyms for others
7968     case Assembler::zero:         return Assembler::notZero;
7969     case Assembler::notZero:      return Assembler::zero;
7970     case Assembler::less:         return Assembler::greaterEqual;
7971     case Assembler::lessEqual:    return Assembler::greater;
7972     case Assembler::greater:      return Assembler::lessEqual;
7973     case Assembler::greaterEqual: return Assembler::less;
7974     case Assembler::below:        return Assembler::aboveEqual;
7975     case Assembler::belowEqual:   return Assembler::above;
7976     case Assembler::above:        return Assembler::belowEqual;
7977     case Assembler::aboveEqual:   return Assembler::below;
7978     case Assembler::overflow:     return Assembler::noOverflow;
7979     case Assembler::noOverflow:   return Assembler::overflow;
7980     case Assembler::negative:     return Assembler::positive;
7981     case Assembler::positive:     return Assembler::negative;
7982     case Assembler::parity:       return Assembler::noParity;
7983     case Assembler::noParity:     return Assembler::parity;
7984   }
7985   ShouldNotReachHere(); return Assembler::overflow;
7986 }
7987 
7988 SkipIfEqual::SkipIfEqual(
7989     MacroAssembler* masm, const bool* flag_addr, bool value) {
7990   _masm = masm;
7991   _masm-&gt;cmp8(ExternalAddress((address)flag_addr), value);
7992   _masm-&gt;jcc(Assembler::equal, _label);
7993 }
7994 
7995 SkipIfEqual::~SkipIfEqual() {
7996   _masm-&gt;bind(_label);
7997 }
7998 
7999 // 32-bit Windows has its own fast-path implementation
8000 // of get_thread
8001 #if !defined(WIN32) || defined(_LP64)
8002 
8003 // This is simply a call to Thread::current()
8004 void MacroAssembler::get_thread(Register thread) {
8005   if (thread != rax) {
8006     push(rax);
8007   }
8008   LP64_ONLY(push(rdi);)
8009   LP64_ONLY(push(rsi);)
8010   push(rdx);
8011   push(rcx);
8012 #ifdef _LP64
8013   push(r8);
8014   push(r9);
8015   push(r10);
8016   push(r11);
8017 #endif
8018 
8019   MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, Thread::current), 0);
8020 
8021 #ifdef _LP64
8022   pop(r11);
8023   pop(r10);
8024   pop(r9);
8025   pop(r8);
8026 #endif
8027   pop(rcx);
8028   pop(rdx);
8029   LP64_ONLY(pop(rsi);)
8030   LP64_ONLY(pop(rdi);)
8031   if (thread != rax) {
8032     mov(thread, rax);
8033     pop(rax);
8034   }
8035 }
8036 
8037 #endif // !WIN32 || _LP64
    </pre>
  </body>
</html>