<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/x86/macroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;asm/assembler.hpp&quot;
  28 #include &quot;asm/assembler.inline.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/barrierSet.hpp&quot;
  31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  32 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;memory/universe.hpp&quot;
  36 #include &quot;oops/accessDecorators.hpp&quot;
  37 #include &quot;oops/compressedOops.inline.hpp&quot;
  38 #include &quot;oops/klass.inline.hpp&quot;
  39 #include &quot;prims/methodHandles.hpp&quot;
  40 #include &quot;runtime/biasedLocking.hpp&quot;
  41 #include &quot;runtime/flags/flagSetting.hpp&quot;
  42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  43 #include &quot;runtime/objectMonitor.hpp&quot;
  44 #include &quot;runtime/os.hpp&quot;
  45 #include &quot;runtime/safepoint.hpp&quot;
  46 #include &quot;runtime/safepointMechanism.hpp&quot;
  47 #include &quot;runtime/sharedRuntime.hpp&quot;
  48 #include &quot;runtime/stubRoutines.hpp&quot;
  49 #include &quot;runtime/thread.hpp&quot;
  50 #include &quot;utilities/macros.hpp&quot;
  51 #include &quot;crc32c.h&quot;
  52 
  53 #ifdef PRODUCT
  54 #define BLOCK_COMMENT(str) /* nothing */
  55 #define STOP(error) stop(error)
  56 #else
  57 #define BLOCK_COMMENT(str) block_comment(str)
  58 #define STOP(error) block_comment(error); stop(error)
  59 #endif
  60 
  61 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  62 
  63 #ifdef ASSERT
  64 bool AbstractAssembler::pd_check_instruction_mark() { return true; }
  65 #endif
  66 
  67 static Assembler::Condition reverse[] = {
  68     Assembler::noOverflow     /* overflow      = 0x0 */ ,
  69     Assembler::overflow       /* noOverflow    = 0x1 */ ,
  70     Assembler::aboveEqual     /* carrySet      = 0x2, below         = 0x2 */ ,
  71     Assembler::below          /* aboveEqual    = 0x3, carryClear    = 0x3 */ ,
  72     Assembler::notZero        /* zero          = 0x4, equal         = 0x4 */ ,
  73     Assembler::zero           /* notZero       = 0x5, notEqual      = 0x5 */ ,
  74     Assembler::above          /* belowEqual    = 0x6 */ ,
  75     Assembler::belowEqual     /* above         = 0x7 */ ,
  76     Assembler::positive       /* negative      = 0x8 */ ,
  77     Assembler::negative       /* positive      = 0x9 */ ,
  78     Assembler::noParity       /* parity        = 0xa */ ,
  79     Assembler::parity         /* noParity      = 0xb */ ,
  80     Assembler::greaterEqual   /* less          = 0xc */ ,
  81     Assembler::less           /* greaterEqual  = 0xd */ ,
  82     Assembler::greater        /* lessEqual     = 0xe */ ,
  83     Assembler::lessEqual      /* greater       = 0xf, */
  84 
  85 };
  86 
  87 
  88 // Implementation of MacroAssembler
  89 
  90 // First all the versions that have distinct versions depending on 32/64 bit
  91 // Unless the difference is trivial (1 line or so).
  92 
  93 #ifndef _LP64
  94 
  95 // 32bit versions
  96 
  97 Address MacroAssembler::as_Address(AddressLiteral adr) {
  98   return Address(adr.target(), adr.rspec());
  99 }
 100 
 101 Address MacroAssembler::as_Address(ArrayAddress adr) {
 102   return Address::make_array(adr);
 103 }
 104 
 105 void MacroAssembler::call_VM_leaf_base(address entry_point,
 106                                        int number_of_arguments) {
 107   call(RuntimeAddress(entry_point));
 108   increment(rsp, number_of_arguments * wordSize);
 109 }
 110 
 111 void MacroAssembler::cmpklass(Address src1, Metadata* obj) {
 112   cmp_literal32(src1, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 113 }
 114 
 115 void MacroAssembler::cmpklass(Register src1, Metadata* obj) {
 116   cmp_literal32(src1, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 117 }
 118 
 119 void MacroAssembler::cmpoop_raw(Address src1, jobject obj) {
 120   cmp_literal32(src1, (int32_t)obj, oop_Relocation::spec_for_immediate());
 121 }
 122 
 123 void MacroAssembler::cmpoop_raw(Register src1, jobject obj) {
 124   cmp_literal32(src1, (int32_t)obj, oop_Relocation::spec_for_immediate());
 125 }
 126 
 127 void MacroAssembler::cmpoop(Address src1, jobject obj) {
 128   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 129   bs-&gt;obj_equals(this, src1, obj);
 130 }
 131 
 132 void MacroAssembler::cmpoop(Register src1, jobject obj) {
 133   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 134   bs-&gt;obj_equals(this, src1, obj);
 135 }
 136 
 137 void MacroAssembler::extend_sign(Register hi, Register lo) {
 138   // According to Intel Doc. AP-526, &quot;Integer Divide&quot;, p.18.
 139   if (VM_Version::is_P6() &amp;&amp; hi == rdx &amp;&amp; lo == rax) {
 140     cdql();
 141   } else {
 142     movl(hi, lo);
 143     sarl(hi, 31);
 144   }
 145 }
 146 
 147 void MacroAssembler::jC2(Register tmp, Label&amp; L) {
 148   // set parity bit if FPU flag C2 is set (via rax)
 149   save_rax(tmp);
 150   fwait(); fnstsw_ax();
 151   sahf();
 152   restore_rax(tmp);
 153   // branch
 154   jcc(Assembler::parity, L);
 155 }
 156 
 157 void MacroAssembler::jnC2(Register tmp, Label&amp; L) {
 158   // set parity bit if FPU flag C2 is set (via rax)
 159   save_rax(tmp);
 160   fwait(); fnstsw_ax();
 161   sahf();
 162   restore_rax(tmp);
 163   // branch
 164   jcc(Assembler::noParity, L);
 165 }
 166 
 167 // 32bit can do a case table jump in one instruction but we no longer allow the base
 168 // to be installed in the Address class
 169 void MacroAssembler::jump(ArrayAddress entry) {
 170   jmp(as_Address(entry));
 171 }
 172 
 173 // Note: y_lo will be destroyed
 174 void MacroAssembler::lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo) {
 175   // Long compare for Java (semantics as described in JVM spec.)
 176   Label high, low, done;
 177 
 178   cmpl(x_hi, y_hi);
 179   jcc(Assembler::less, low);
 180   jcc(Assembler::greater, high);
 181   // x_hi is the return register
 182   xorl(x_hi, x_hi);
 183   cmpl(x_lo, y_lo);
 184   jcc(Assembler::below, low);
 185   jcc(Assembler::equal, done);
 186 
 187   bind(high);
 188   xorl(x_hi, x_hi);
 189   increment(x_hi);
 190   jmp(done);
 191 
 192   bind(low);
 193   xorl(x_hi, x_hi);
 194   decrementl(x_hi);
 195 
 196   bind(done);
 197 }
 198 
 199 void MacroAssembler::lea(Register dst, AddressLiteral src) {
 200     mov_literal32(dst, (int32_t)src.target(), src.rspec());
 201 }
 202 
 203 void MacroAssembler::lea(Address dst, AddressLiteral adr) {
 204   // leal(dst, as_Address(adr));
 205   // see note in movl as to why we must use a move
 206   mov_literal32(dst, (int32_t) adr.target(), adr.rspec());
 207 }
 208 
 209 void MacroAssembler::leave() {
 210   mov(rsp, rbp);
 211   pop(rbp);
 212 }
 213 
 214 void MacroAssembler::lmul(int x_rsp_offset, int y_rsp_offset) {
 215   // Multiplication of two Java long values stored on the stack
 216   // as illustrated below. Result is in rdx:rax.
 217   //
 218   // rsp ---&gt; [  ??  ] \               \
 219   //            ....    | y_rsp_offset  |
 220   //          [ y_lo ] /  (in bytes)    | x_rsp_offset
 221   //          [ y_hi ]                  | (in bytes)
 222   //            ....                    |
 223   //          [ x_lo ]                 /
 224   //          [ x_hi ]
 225   //            ....
 226   //
 227   // Basic idea: lo(result) = lo(x_lo * y_lo)
 228   //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
 229   Address x_hi(rsp, x_rsp_offset + wordSize); Address x_lo(rsp, x_rsp_offset);
 230   Address y_hi(rsp, y_rsp_offset + wordSize); Address y_lo(rsp, y_rsp_offset);
 231   Label quick;
 232   // load x_hi, y_hi and check if quick
 233   // multiplication is possible
 234   movl(rbx, x_hi);
 235   movl(rcx, y_hi);
 236   movl(rax, rbx);
 237   orl(rbx, rcx);                                 // rbx, = 0 &lt;=&gt; x_hi = 0 and y_hi = 0
 238   jcc(Assembler::zero, quick);                   // if rbx, = 0 do quick multiply
 239   // do full multiplication
 240   // 1st step
 241   mull(y_lo);                                    // x_hi * y_lo
 242   movl(rbx, rax);                                // save lo(x_hi * y_lo) in rbx,
 243   // 2nd step
 244   movl(rax, x_lo);
 245   mull(rcx);                                     // x_lo * y_hi
 246   addl(rbx, rax);                                // add lo(x_lo * y_hi) to rbx,
 247   // 3rd step
 248   bind(quick);                                   // note: rbx, = 0 if quick multiply!
 249   movl(rax, x_lo);
 250   mull(y_lo);                                    // x_lo * y_lo
 251   addl(rdx, rbx);                                // correct hi(x_lo * y_lo)
 252 }
 253 
 254 void MacroAssembler::lneg(Register hi, Register lo) {
 255   negl(lo);
 256   adcl(hi, 0);
 257   negl(hi);
 258 }
 259 
 260 void MacroAssembler::lshl(Register hi, Register lo) {
 261   // Java shift left long support (semantics as described in JVM spec., p.305)
 262   // (basic idea for shift counts s &gt;= n: x &lt;&lt; s == (x &lt;&lt; n) &lt;&lt; (s - n))
 263   // shift value is in rcx !
 264   assert(hi != rcx, &quot;must not use rcx&quot;);
 265   assert(lo != rcx, &quot;must not use rcx&quot;);
 266   const Register s = rcx;                        // shift count
 267   const int      n = BitsPerWord;
 268   Label L;
 269   andl(s, 0x3f);                                 // s := s &amp; 0x3f (s &lt; 0x40)
 270   cmpl(s, n);                                    // if (s &lt; n)
 271   jcc(Assembler::less, L);                       // else (s &gt;= n)
 272   movl(hi, lo);                                  // x := x &lt;&lt; n
 273   xorl(lo, lo);
 274   // Note: subl(s, n) is not needed since the Intel shift instructions work rcx mod n!
 275   bind(L);                                       // s (mod n) &lt; n
 276   shldl(hi, lo);                                 // x := x &lt;&lt; s
 277   shll(lo);
 278 }
 279 
 280 
 281 void MacroAssembler::lshr(Register hi, Register lo, bool sign_extension) {
 282   // Java shift right long support (semantics as described in JVM spec., p.306 &amp; p.310)
 283   // (basic idea for shift counts s &gt;= n: x &gt;&gt; s == (x &gt;&gt; n) &gt;&gt; (s - n))
 284   assert(hi != rcx, &quot;must not use rcx&quot;);
 285   assert(lo != rcx, &quot;must not use rcx&quot;);
 286   const Register s = rcx;                        // shift count
 287   const int      n = BitsPerWord;
 288   Label L;
 289   andl(s, 0x3f);                                 // s := s &amp; 0x3f (s &lt; 0x40)
 290   cmpl(s, n);                                    // if (s &lt; n)
 291   jcc(Assembler::less, L);                       // else (s &gt;= n)
 292   movl(lo, hi);                                  // x := x &gt;&gt; n
 293   if (sign_extension) sarl(hi, 31);
 294   else                xorl(hi, hi);
 295   // Note: subl(s, n) is not needed since the Intel shift instructions work rcx mod n!
 296   bind(L);                                       // s (mod n) &lt; n
 297   shrdl(lo, hi);                                 // x := x &gt;&gt; s
 298   if (sign_extension) sarl(hi);
 299   else                shrl(hi);
 300 }
 301 
 302 void MacroAssembler::movoop(Register dst, jobject obj) {
 303   mov_literal32(dst, (int32_t)obj, oop_Relocation::spec_for_immediate());
 304 }
 305 
 306 void MacroAssembler::movoop(Address dst, jobject obj) {
 307   mov_literal32(dst, (int32_t)obj, oop_Relocation::spec_for_immediate());
 308 }
 309 
 310 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
 311   mov_literal32(dst, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 312 }
 313 
 314 void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {
 315   mov_literal32(dst, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 316 }
 317 
 318 void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {
 319   // scratch register is not used,
 320   // it is defined to match parameters of 64-bit version of this method.
 321   if (src.is_lval()) {
 322     mov_literal32(dst, (intptr_t)src.target(), src.rspec());
 323   } else {
 324     movl(dst, as_Address(src));
 325   }
 326 }
 327 
 328 void MacroAssembler::movptr(ArrayAddress dst, Register src) {
 329   movl(as_Address(dst), src);
 330 }
 331 
 332 void MacroAssembler::movptr(Register dst, ArrayAddress src) {
 333   movl(dst, as_Address(src));
 334 }
 335 
 336 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
 337 void MacroAssembler::movptr(Address dst, intptr_t src) {
 338   movl(dst, src);
 339 }
 340 
 341 
 342 void MacroAssembler::pop_callee_saved_registers() {
 343   pop(rcx);
 344   pop(rdx);
 345   pop(rdi);
 346   pop(rsi);
 347 }
 348 
 349 void MacroAssembler::push_callee_saved_registers() {
 350   push(rsi);
 351   push(rdi);
 352   push(rdx);
 353   push(rcx);
 354 }
 355 
 356 void MacroAssembler::pushoop(jobject obj) {
 357   push_literal32((int32_t)obj, oop_Relocation::spec_for_immediate());
 358 }
 359 
 360 void MacroAssembler::pushklass(Metadata* obj) {
 361   push_literal32((int32_t)obj, metadata_Relocation::spec_for_immediate());
 362 }
 363 
 364 void MacroAssembler::pushptr(AddressLiteral src) {
 365   if (src.is_lval()) {
 366     push_literal32((int32_t)src.target(), src.rspec());
 367   } else {
 368     pushl(as_Address(src));
 369   }
 370 }
 371 
 372 void MacroAssembler::set_word_if_not_zero(Register dst) {
 373   xorl(dst, dst);
 374   set_byte_if_not_zero(dst);
 375 }
 376 
 377 static void pass_arg0(MacroAssembler* masm, Register arg) {
 378   masm-&gt;push(arg);
 379 }
 380 
 381 static void pass_arg1(MacroAssembler* masm, Register arg) {
 382   masm-&gt;push(arg);
 383 }
 384 
 385 static void pass_arg2(MacroAssembler* masm, Register arg) {
 386   masm-&gt;push(arg);
 387 }
 388 
 389 static void pass_arg3(MacroAssembler* masm, Register arg) {
 390   masm-&gt;push(arg);
 391 }
 392 
 393 #ifndef PRODUCT
 394 extern &quot;C&quot; void findpc(intptr_t x);
 395 #endif
 396 
 397 void MacroAssembler::debug32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip, char* msg) {
 398   // In order to get locks to work, we need to fake a in_VM state
 399   JavaThread* thread = JavaThread::current();
 400   JavaThreadState saved_state = thread-&gt;thread_state();
 401   thread-&gt;set_thread_state(_thread_in_vm);
 402   if (ShowMessageBoxOnError) {
 403     JavaThread* thread = JavaThread::current();
 404     JavaThreadState saved_state = thread-&gt;thread_state();
 405     thread-&gt;set_thread_state(_thread_in_vm);
 406     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
 407       ttyLocker ttyl;
 408       BytecodeCounter::print();
 409     }
 410     // To see where a verify_oop failed, get $ebx+40/X for this frame.
 411     // This is the value of eip which points to where verify_oop will return.
 412     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
 413       print_state32(rdi, rsi, rbp, rsp, rbx, rdx, rcx, rax, eip);
 414       BREAKPOINT;
 415     }
 416   }
 417   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
 418 }
 419 
 420 void MacroAssembler::print_state32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip) {
 421   ttyLocker ttyl;
 422   FlagSetting fs(Debugging, true);
 423   tty-&gt;print_cr(&quot;eip = 0x%08x&quot;, eip);
 424 #ifndef PRODUCT
 425   if ((WizardMode || Verbose) &amp;&amp; PrintMiscellaneous) {
 426     tty-&gt;cr();
 427     findpc(eip);
 428     tty-&gt;cr();
 429   }
 430 #endif
 431 #define PRINT_REG(rax) \
 432   { tty-&gt;print(&quot;%s = &quot;, #rax); os::print_location(tty, rax); }
 433   PRINT_REG(rax);
 434   PRINT_REG(rbx);
 435   PRINT_REG(rcx);
 436   PRINT_REG(rdx);
 437   PRINT_REG(rdi);
 438   PRINT_REG(rsi);
 439   PRINT_REG(rbp);
 440   PRINT_REG(rsp);
 441 #undef PRINT_REG
 442   // Print some words near top of staack.
 443   int* dump_sp = (int*) rsp;
 444   for (int col1 = 0; col1 &lt; 8; col1++) {
 445     tty-&gt;print(&quot;(rsp+0x%03x) 0x%08x: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 446     os::print_location(tty, *dump_sp++);
 447   }
 448   for (int row = 0; row &lt; 16; row++) {
 449     tty-&gt;print(&quot;(rsp+0x%03x) 0x%08x: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 450     for (int col = 0; col &lt; 8; col++) {
 451       tty-&gt;print(&quot; 0x%08x&quot;, *dump_sp++);
 452     }
 453     tty-&gt;cr();
 454   }
 455   // Print some instructions around pc:
 456   Disassembler::decode((address)eip-64, (address)eip);
 457   tty-&gt;print_cr(&quot;--------&quot;);
 458   Disassembler::decode((address)eip, (address)eip+32);
 459 }
 460 
 461 void MacroAssembler::stop(const char* msg) {
 462   ExternalAddress message((address)msg);
 463   // push address of message
 464   pushptr(message.addr());
 465   { Label L; call(L, relocInfo::none); bind(L); }     // push eip
 466   pusha();                                            // push registers
 467   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug32)));
 468   hlt();
 469 }
 470 
 471 void MacroAssembler::warn(const char* msg) {
 472   push_CPU_state();
 473 
 474   ExternalAddress message((address) msg);
 475   // push address of message
 476   pushptr(message.addr());
 477 
 478   call(RuntimeAddress(CAST_FROM_FN_PTR(address, warning)));
 479   addl(rsp, wordSize);       // discard argument
 480   pop_CPU_state();
 481 }
 482 
 483 void MacroAssembler::print_state() {
 484   { Label L; call(L, relocInfo::none); bind(L); }     // push eip
 485   pusha();                                            // push registers
 486 
 487   push_CPU_state();
 488   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::print_state32)));
 489   pop_CPU_state();
 490 
 491   popa();
 492   addl(rsp, wordSize);
 493 }
 494 
 495 #else // _LP64
 496 
 497 // 64 bit versions
 498 
 499 Address MacroAssembler::as_Address(AddressLiteral adr) {
 500   // amd64 always does this as a pc-rel
 501   // we can be absolute or disp based on the instruction type
 502   // jmp/call are displacements others are absolute
 503   assert(!adr.is_lval(), &quot;must be rval&quot;);
 504   assert(reachable(adr), &quot;must be&quot;);
 505   return Address((int32_t)(intptr_t)(adr.target() - pc()), adr.target(), adr.reloc());
 506 
 507 }
 508 
 509 Address MacroAssembler::as_Address(ArrayAddress adr) {
 510   AddressLiteral base = adr.base();
 511   lea(rscratch1, base);
 512   Address index = adr.index();
 513   assert(index._disp == 0, &quot;must not have disp&quot;); // maybe it can?
 514   Address array(rscratch1, index._index, index._scale, index._disp);
 515   return array;
 516 }
 517 
 518 void MacroAssembler::call_VM_leaf_base(address entry_point, int num_args) {
 519   Label L, E;
 520 
 521 #ifdef _WIN64
 522   // Windows always allocates space for it&#39;s register args
 523   assert(num_args &lt;= 4, &quot;only register arguments supported&quot;);
 524   subq(rsp,  frame::arg_reg_save_area_bytes);
 525 #endif
 526 
 527   // Align stack if necessary
 528   testl(rsp, 15);
 529   jcc(Assembler::zero, L);
 530 
 531   subq(rsp, 8);
 532   {
 533     call(RuntimeAddress(entry_point));
 534   }
 535   addq(rsp, 8);
 536   jmp(E);
 537 
 538   bind(L);
 539   {
 540     call(RuntimeAddress(entry_point));
 541   }
 542 
 543   bind(E);
 544 
 545 #ifdef _WIN64
 546   // restore stack pointer
 547   addq(rsp, frame::arg_reg_save_area_bytes);
 548 #endif
 549 
 550 }
 551 
 552 void MacroAssembler::cmp64(Register src1, AddressLiteral src2) {
 553   assert(!src2.is_lval(), &quot;should use cmpptr&quot;);
 554 
 555   if (reachable(src2)) {
 556     cmpq(src1, as_Address(src2));
 557   } else {
 558     lea(rscratch1, src2);
 559     Assembler::cmpq(src1, Address(rscratch1, 0));
 560   }
 561 }
 562 
 563 int MacroAssembler::corrected_idivq(Register reg) {
 564   // Full implementation of Java ldiv and lrem; checks for special
 565   // case as described in JVM spec., p.243 &amp; p.271.  The function
 566   // returns the (pc) offset of the idivl instruction - may be needed
 567   // for implicit exceptions.
 568   //
 569   //         normal case                           special case
 570   //
 571   // input : rax: dividend                         min_long
 572   //         reg: divisor   (may not be eax/edx)   -1
 573   //
 574   // output: rax: quotient  (= rax idiv reg)       min_long
 575   //         rdx: remainder (= rax irem reg)       0
 576   assert(reg != rax &amp;&amp; reg != rdx, &quot;reg cannot be rax or rdx register&quot;);
 577   static const int64_t min_long = 0x8000000000000000;
 578   Label normal_case, special_case;
 579 
 580   // check for special case
 581   cmp64(rax, ExternalAddress((address) &amp;min_long));
 582   jcc(Assembler::notEqual, normal_case);
 583   xorl(rdx, rdx); // prepare rdx for possible special case (where
 584                   // remainder = 0)
 585   cmpq(reg, -1);
 586   jcc(Assembler::equal, special_case);
 587 
 588   // handle normal case
 589   bind(normal_case);
 590   cdqq();
 591   int idivq_offset = offset();
 592   idivq(reg);
 593 
 594   // normal and special case exit
 595   bind(special_case);
 596 
 597   return idivq_offset;
 598 }
 599 
 600 void MacroAssembler::decrementq(Register reg, int value) {
 601   if (value == min_jint) { subq(reg, value); return; }
 602   if (value &lt;  0) { incrementq(reg, -value); return; }
 603   if (value == 0) {                        ; return; }
 604   if (value == 1 &amp;&amp; UseIncDec) { decq(reg) ; return; }
 605   /* else */      { subq(reg, value)       ; return; }
 606 }
 607 
 608 void MacroAssembler::decrementq(Address dst, int value) {
 609   if (value == min_jint) { subq(dst, value); return; }
 610   if (value &lt;  0) { incrementq(dst, -value); return; }
 611   if (value == 0) {                        ; return; }
 612   if (value == 1 &amp;&amp; UseIncDec) { decq(dst) ; return; }
 613   /* else */      { subq(dst, value)       ; return; }
 614 }
 615 
 616 void MacroAssembler::incrementq(AddressLiteral dst) {
 617   if (reachable(dst)) {
 618     incrementq(as_Address(dst));
 619   } else {
 620     lea(rscratch1, dst);
 621     incrementq(Address(rscratch1, 0));
 622   }
 623 }
 624 
 625 void MacroAssembler::incrementq(Register reg, int value) {
 626   if (value == min_jint) { addq(reg, value); return; }
 627   if (value &lt;  0) { decrementq(reg, -value); return; }
 628   if (value == 0) {                        ; return; }
 629   if (value == 1 &amp;&amp; UseIncDec) { incq(reg) ; return; }
 630   /* else */      { addq(reg, value)       ; return; }
 631 }
 632 
 633 void MacroAssembler::incrementq(Address dst, int value) {
 634   if (value == min_jint) { addq(dst, value); return; }
 635   if (value &lt;  0) { decrementq(dst, -value); return; }
 636   if (value == 0) {                        ; return; }
 637   if (value == 1 &amp;&amp; UseIncDec) { incq(dst) ; return; }
 638   /* else */      { addq(dst, value)       ; return; }
 639 }
 640 
 641 // 32bit can do a case table jump in one instruction but we no longer allow the base
 642 // to be installed in the Address class
 643 void MacroAssembler::jump(ArrayAddress entry) {
 644   lea(rscratch1, entry.base());
 645   Address dispatch = entry.index();
 646   assert(dispatch._base == noreg, &quot;must be&quot;);
 647   dispatch._base = rscratch1;
 648   jmp(dispatch);
 649 }
 650 
 651 void MacroAssembler::lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo) {
 652   ShouldNotReachHere(); // 64bit doesn&#39;t use two regs
 653   cmpq(x_lo, y_lo);
 654 }
 655 
 656 void MacroAssembler::lea(Register dst, AddressLiteral src) {
 657     mov_literal64(dst, (intptr_t)src.target(), src.rspec());
 658 }
 659 
 660 void MacroAssembler::lea(Address dst, AddressLiteral adr) {
 661   mov_literal64(rscratch1, (intptr_t)adr.target(), adr.rspec());
 662   movptr(dst, rscratch1);
 663 }
 664 
 665 void MacroAssembler::leave() {
 666   // %%% is this really better? Why not on 32bit too?
 667   emit_int8((unsigned char)0xC9); // LEAVE
 668 }
 669 
 670 void MacroAssembler::lneg(Register hi, Register lo) {
 671   ShouldNotReachHere(); // 64bit doesn&#39;t use two regs
 672   negq(lo);
 673 }
 674 
 675 void MacroAssembler::movoop(Register dst, jobject obj) {
 676   mov_literal64(dst, (intptr_t)obj, oop_Relocation::spec_for_immediate());
 677 }
 678 
 679 void MacroAssembler::movoop(Address dst, jobject obj) {
 680   mov_literal64(rscratch1, (intptr_t)obj, oop_Relocation::spec_for_immediate());
 681   movq(dst, rscratch1);
 682 }
 683 
 684 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
 685   mov_literal64(dst, (intptr_t)obj, metadata_Relocation::spec_for_immediate());
 686 }
 687 
 688 void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {
 689   mov_literal64(rscratch1, (intptr_t)obj, metadata_Relocation::spec_for_immediate());
 690   movq(dst, rscratch1);
 691 }
 692 
 693 void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {
 694   if (src.is_lval()) {
 695     mov_literal64(dst, (intptr_t)src.target(), src.rspec());
 696   } else {
 697     if (reachable(src)) {
 698       movq(dst, as_Address(src));
 699     } else {
 700       lea(scratch, src);
 701       movq(dst, Address(scratch, 0));
 702     }
 703   }
 704 }
 705 
 706 void MacroAssembler::movptr(ArrayAddress dst, Register src) {
 707   movq(as_Address(dst), src);
 708 }
 709 
 710 void MacroAssembler::movptr(Register dst, ArrayAddress src) {
 711   movq(dst, as_Address(src));
 712 }
 713 
 714 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
 715 void MacroAssembler::movptr(Address dst, intptr_t src) {
 716   mov64(rscratch1, src);
 717   movq(dst, rscratch1);
 718 }
 719 
 720 // These are mostly for initializing NULL
 721 void MacroAssembler::movptr(Address dst, int32_t src) {
 722   movslq(dst, src);
 723 }
 724 
 725 void MacroAssembler::movptr(Register dst, int32_t src) {
 726   mov64(dst, (intptr_t)src);
 727 }
 728 
 729 void MacroAssembler::pushoop(jobject obj) {
 730   movoop(rscratch1, obj);
 731   push(rscratch1);
 732 }
 733 
 734 void MacroAssembler::pushklass(Metadata* obj) {
 735   mov_metadata(rscratch1, obj);
 736   push(rscratch1);
 737 }
 738 
 739 void MacroAssembler::pushptr(AddressLiteral src) {
 740   lea(rscratch1, src);
 741   if (src.is_lval()) {
 742     push(rscratch1);
 743   } else {
 744     pushq(Address(rscratch1, 0));
 745   }
 746 }
 747 
 748 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
 749                                          Register last_java_fp,
 750                                          address  last_java_pc) {
 751   vzeroupper();
 752   // determine last_java_sp register
 753   if (!last_java_sp-&gt;is_valid()) {
 754     last_java_sp = rsp;
 755   }
 756 
 757   // last_java_fp is optional
 758   if (last_java_fp-&gt;is_valid()) {
 759     movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()),
 760            last_java_fp);
 761   }
 762 
 763   // last_java_pc is optional
 764   if (last_java_pc != NULL) {
 765     Address java_pc(r15_thread,
 766                     JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset());
 767     lea(rscratch1, InternalAddress(last_java_pc));
 768     movptr(java_pc, rscratch1);
 769   }
 770 
 771   movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), last_java_sp);
 772 }
 773 
 774 static void pass_arg0(MacroAssembler* masm, Register arg) {
 775   if (c_rarg0 != arg ) {
 776     masm-&gt;mov(c_rarg0, arg);
 777   }
 778 }
 779 
 780 static void pass_arg1(MacroAssembler* masm, Register arg) {
 781   if (c_rarg1 != arg ) {
 782     masm-&gt;mov(c_rarg1, arg);
 783   }
 784 }
 785 
 786 static void pass_arg2(MacroAssembler* masm, Register arg) {
 787   if (c_rarg2 != arg ) {
 788     masm-&gt;mov(c_rarg2, arg);
 789   }
 790 }
 791 
 792 static void pass_arg3(MacroAssembler* masm, Register arg) {
 793   if (c_rarg3 != arg ) {
 794     masm-&gt;mov(c_rarg3, arg);
 795   }
 796 }
 797 
 798 void MacroAssembler::stop(const char* msg) {
 799   if (ShowMessageBoxOnError) {
 800     address rip = pc();
 801     pusha(); // get regs on stack
 802     lea(c_rarg1, InternalAddress(rip));
 803     movq(c_rarg2, rsp); // pass pointer to regs array
 804   }
 805   lea(c_rarg0, ExternalAddress((address) msg));
 806   andq(rsp, -16); // align stack as required by ABI
 807   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug64)));
 808   hlt();
 809 }
 810 
 811 void MacroAssembler::warn(const char* msg) {
 812   push(rbp);
 813   movq(rbp, rsp);
 814   andq(rsp, -16);     // align stack as required by push_CPU_state and call
 815   push_CPU_state();   // keeps alignment at 16 bytes
 816   lea(c_rarg0, ExternalAddress((address) msg));
 817   lea(rax, ExternalAddress(CAST_FROM_FN_PTR(address, warning)));
 818   call(rax);
 819   pop_CPU_state();
 820   mov(rsp, rbp);
 821   pop(rbp);
 822 }
 823 
 824 void MacroAssembler::print_state() {
 825   address rip = pc();
 826   pusha();            // get regs on stack
 827   push(rbp);
 828   movq(rbp, rsp);
 829   andq(rsp, -16);     // align stack as required by push_CPU_state and call
 830   push_CPU_state();   // keeps alignment at 16 bytes
 831 
 832   lea(c_rarg0, InternalAddress(rip));
 833   lea(c_rarg1, Address(rbp, wordSize)); // pass pointer to regs array
 834   call_VM_leaf(CAST_FROM_FN_PTR(address, MacroAssembler::print_state64), c_rarg0, c_rarg1);
 835 
 836   pop_CPU_state();
 837   mov(rsp, rbp);
 838   pop(rbp);
 839   popa();
 840 }
 841 
 842 #ifndef PRODUCT
 843 extern &quot;C&quot; void findpc(intptr_t x);
 844 #endif
 845 
 846 void MacroAssembler::debug64(char* msg, int64_t pc, int64_t regs[]) {
 847   // In order to get locks to work, we need to fake a in_VM state
 848   if (ShowMessageBoxOnError) {
 849     JavaThread* thread = JavaThread::current();
 850     JavaThreadState saved_state = thread-&gt;thread_state();
 851     thread-&gt;set_thread_state(_thread_in_vm);
 852 #ifndef PRODUCT
 853     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
 854       ttyLocker ttyl;
 855       BytecodeCounter::print();
 856     }
 857 #endif
 858     // To see where a verify_oop failed, get $ebx+40/X for this frame.
 859     // XXX correct this offset for amd64
 860     // This is the value of eip which points to where verify_oop will return.
 861     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
 862       print_state64(pc, regs);
 863       BREAKPOINT;
 864     }
 865   }
 866   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
 867 }
 868 
 869 void MacroAssembler::print_state64(int64_t pc, int64_t regs[]) {
 870   ttyLocker ttyl;
 871   FlagSetting fs(Debugging, true);
 872   tty-&gt;print_cr(&quot;rip = 0x%016lx&quot;, (intptr_t)pc);
 873 #ifndef PRODUCT
 874   tty-&gt;cr();
 875   findpc(pc);
 876   tty-&gt;cr();
 877 #endif
 878 #define PRINT_REG(rax, value) \
 879   { tty-&gt;print(&quot;%s = &quot;, #rax); os::print_location(tty, value); }
 880   PRINT_REG(rax, regs[15]);
 881   PRINT_REG(rbx, regs[12]);
 882   PRINT_REG(rcx, regs[14]);
 883   PRINT_REG(rdx, regs[13]);
 884   PRINT_REG(rdi, regs[8]);
 885   PRINT_REG(rsi, regs[9]);
 886   PRINT_REG(rbp, regs[10]);
 887   // rsp is actually not stored by pusha(), compute the old rsp from regs (rsp after pusha): regs + 16 = old rsp
 888   PRINT_REG(rsp, (intptr_t)(&amp;regs[16]));
 889   PRINT_REG(r8 , regs[7]);
 890   PRINT_REG(r9 , regs[6]);
 891   PRINT_REG(r10, regs[5]);
 892   PRINT_REG(r11, regs[4]);
 893   PRINT_REG(r12, regs[3]);
 894   PRINT_REG(r13, regs[2]);
 895   PRINT_REG(r14, regs[1]);
 896   PRINT_REG(r15, regs[0]);
 897 #undef PRINT_REG
 898   // Print some words near the top of the stack.
 899   int64_t* rsp = &amp;regs[16];
 900   int64_t* dump_sp = rsp;
 901   for (int col1 = 0; col1 &lt; 8; col1++) {
 902     tty-&gt;print(&quot;(rsp+0x%03x) 0x%016lx: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 903     os::print_location(tty, *dump_sp++);
 904   }
 905   for (int row = 0; row &lt; 25; row++) {
 906     tty-&gt;print(&quot;(rsp+0x%03x) 0x%016lx: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 907     for (int col = 0; col &lt; 4; col++) {
 908       tty-&gt;print(&quot; 0x%016lx&quot;, (intptr_t)*dump_sp++);
 909     }
 910     tty-&gt;cr();
 911   }
 912   // Print some instructions around pc:
 913   Disassembler::decode((address)pc-64, (address)pc);
 914   tty-&gt;print_cr(&quot;--------&quot;);
 915   Disassembler::decode((address)pc, (address)pc+32);
 916 }
 917 
 918 #endif // _LP64
 919 
 920 // Now versions that are common to 32/64 bit
 921 
 922 void MacroAssembler::addptr(Register dst, int32_t imm32) {
 923   LP64_ONLY(addq(dst, imm32)) NOT_LP64(addl(dst, imm32));
 924 }
 925 
 926 void MacroAssembler::addptr(Register dst, Register src) {
 927   LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src));
 928 }
 929 
 930 void MacroAssembler::addptr(Address dst, Register src) {
 931   LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src));
 932 }
 933 
 934 void MacroAssembler::addsd(XMMRegister dst, AddressLiteral src) {
 935   if (reachable(src)) {
 936     Assembler::addsd(dst, as_Address(src));
 937   } else {
 938     lea(rscratch1, src);
 939     Assembler::addsd(dst, Address(rscratch1, 0));
 940   }
 941 }
 942 
 943 void MacroAssembler::addss(XMMRegister dst, AddressLiteral src) {
 944   if (reachable(src)) {
 945     addss(dst, as_Address(src));
 946   } else {
 947     lea(rscratch1, src);
 948     addss(dst, Address(rscratch1, 0));
 949   }
 950 }
 951 
 952 void MacroAssembler::addpd(XMMRegister dst, AddressLiteral src) {
 953   if (reachable(src)) {
 954     Assembler::addpd(dst, as_Address(src));
 955   } else {
 956     lea(rscratch1, src);
 957     Assembler::addpd(dst, Address(rscratch1, 0));
 958   }
 959 }
 960 
 961 void MacroAssembler::align(int modulus) {
 962   align(modulus, offset());
 963 }
 964 
 965 void MacroAssembler::align(int modulus, int target) {
 966   if (target % modulus != 0) {
 967     nop(modulus - (target % modulus));
 968   }
 969 }
 970 
 971 void MacroAssembler::andpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
 972   // Used in sign-masking with aligned address.
 973   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
 974   if (reachable(src)) {
 975     Assembler::andpd(dst, as_Address(src));
 976   } else {
 977     lea(scratch_reg, src);
 978     Assembler::andpd(dst, Address(scratch_reg, 0));
 979   }
 980 }
 981 
 982 void MacroAssembler::andps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
 983   // Used in sign-masking with aligned address.
 984   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
 985   if (reachable(src)) {
 986     Assembler::andps(dst, as_Address(src));
 987   } else {
 988     lea(scratch_reg, src);
 989     Assembler::andps(dst, Address(scratch_reg, 0));
 990   }
 991 }
 992 
 993 void MacroAssembler::andptr(Register dst, int32_t imm32) {
 994   LP64_ONLY(andq(dst, imm32)) NOT_LP64(andl(dst, imm32));
 995 }
 996 
 997 void MacroAssembler::atomic_incl(Address counter_addr) {
 998   lock();
 999   incrementl(counter_addr);
1000 }
1001 
1002 void MacroAssembler::atomic_incl(AddressLiteral counter_addr, Register scr) {
1003   if (reachable(counter_addr)) {
1004     atomic_incl(as_Address(counter_addr));
1005   } else {
1006     lea(scr, counter_addr);
1007     atomic_incl(Address(scr, 0));
1008   }
1009 }
1010 
1011 #ifdef _LP64
1012 void MacroAssembler::atomic_incq(Address counter_addr) {
1013   lock();
1014   incrementq(counter_addr);
1015 }
1016 
1017 void MacroAssembler::atomic_incq(AddressLiteral counter_addr, Register scr) {
1018   if (reachable(counter_addr)) {
1019     atomic_incq(as_Address(counter_addr));
1020   } else {
1021     lea(scr, counter_addr);
1022     atomic_incq(Address(scr, 0));
1023   }
1024 }
1025 #endif
1026 
1027 // Writes to stack successive pages until offset reached to check for
1028 // stack overflow + shadow pages.  This clobbers tmp.
1029 void MacroAssembler::bang_stack_size(Register size, Register tmp) {
1030   movptr(tmp, rsp);
1031   // Bang stack for total size given plus shadow page size.
1032   // Bang one page at a time because large size can bang beyond yellow and
1033   // red zones.
1034   Label loop;
1035   bind(loop);
1036   movl(Address(tmp, (-os::vm_page_size())), size );
1037   subptr(tmp, os::vm_page_size());
1038   subl(size, os::vm_page_size());
1039   jcc(Assembler::greater, loop);
1040 
1041   // Bang down shadow pages too.
1042   // At this point, (tmp-0) is the last address touched, so don&#39;t
1043   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
1044   // was post-decremented.)  Skip this address by starting at i=1, and
1045   // touch a few more pages below.  N.B.  It is important to touch all
1046   // the way down including all pages in the shadow zone.
1047   for (int i = 1; i &lt; ((int)JavaThread::stack_shadow_zone_size() / os::vm_page_size()); i++) {
1048     // this could be any sized move but this is can be a debugging crumb
1049     // so the bigger the better.
1050     movptr(Address(tmp, (-i*os::vm_page_size())), size );
1051   }
1052 }
1053 
1054 void MacroAssembler::reserved_stack_check() {
1055     // testing if reserved zone needs to be enabled
1056     Label no_reserved_zone_enabling;
1057     Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);
1058     NOT_LP64(get_thread(rsi);)
1059 
1060     cmpptr(rsp, Address(thread, JavaThread::reserved_stack_activation_offset()));
1061     jcc(Assembler::below, no_reserved_zone_enabling);
1062 
1063     call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone), thread);
1064     jump(RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));
1065     should_not_reach_here();
1066 
1067     bind(no_reserved_zone_enabling);
1068 }
1069 
1070 int MacroAssembler::biased_locking_enter(Register lock_reg,
1071                                          Register obj_reg,
1072                                          Register swap_reg,
1073                                          Register tmp_reg,
1074                                          Register tmp_reg2,
1075                                          bool swap_reg_contains_mark,
1076                                          Label&amp; done,
1077                                          Label* slow_case,
1078                                          BiasedLockingCounters* counters) {
1079   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
1080   assert(swap_reg == rax, &quot;swap_reg must be rax for cmpxchgq&quot;);
1081   assert(tmp_reg != noreg, &quot;tmp_reg must be supplied&quot;);
1082   assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg);
1083   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);
1084   Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());
1085   NOT_LP64( Address saved_mark_addr(lock_reg, 0); )
1086 
1087   if (PrintBiasedLockingStatistics &amp;&amp; counters == NULL) {
1088     counters = BiasedLocking::counters();
1089   }
1090   // Biased locking
1091   // See whether the lock is currently biased toward our thread and
1092   // whether the epoch is still valid
1093   // Note that the runtime guarantees sufficient alignment of JavaThread
1094   // pointers to allow age to be placed into low bits
1095   // First check to see whether biasing is even enabled for this object
1096   Label cas_label;
1097   int null_check_offset = -1;
1098   if (!swap_reg_contains_mark) {
1099     null_check_offset = offset();
1100     movptr(swap_reg, mark_addr);
1101   }
1102   movptr(tmp_reg, swap_reg);
1103   andptr(tmp_reg, markWord::biased_lock_mask_in_place);
1104   cmpptr(tmp_reg, markWord::biased_lock_pattern);
1105   jcc(Assembler::notEqual, cas_label);
1106   // The bias pattern is present in the object&#39;s header. Need to check
1107   // whether the bias owner and the epoch are both still current.
1108 #ifndef _LP64
1109   // Note that because there is no current thread register on x86_32 we
1110   // need to store off the mark word we read out of the object to
1111   // avoid reloading it and needing to recheck invariants below. This
1112   // store is unfortunate but it makes the overall code shorter and
1113   // simpler.
1114   movptr(saved_mark_addr, swap_reg);
1115 #endif
1116   if (swap_reg_contains_mark) {
1117     null_check_offset = offset();
1118   }
1119   load_prototype_header(tmp_reg, obj_reg, tmp_reg2);
1120 #ifdef _LP64
1121   orptr(tmp_reg, r15_thread);
1122   xorptr(tmp_reg, swap_reg);
1123   Register header_reg = tmp_reg;
1124 #else
1125   xorptr(tmp_reg, swap_reg);
1126   get_thread(swap_reg);
1127   xorptr(swap_reg, tmp_reg);
1128   Register header_reg = swap_reg;
1129 #endif
1130   andptr(header_reg, ~((int) markWord::age_mask_in_place));
1131   if (counters != NULL) {
1132     cond_inc32(Assembler::zero,
1133                ExternalAddress((address) counters-&gt;biased_lock_entry_count_addr()));
1134   }
1135   jcc(Assembler::equal, done);
1136 
1137   Label try_revoke_bias;
1138   Label try_rebias;
1139 
1140   // At this point we know that the header has the bias pattern and
1141   // that we are not the bias owner in the current epoch. We need to
1142   // figure out more details about the state of the header in order to
1143   // know what operations can be legally performed on the object&#39;s
1144   // header.
1145 
1146   // If the low three bits in the xor result aren&#39;t clear, that means
1147   // the prototype header is no longer biased and we have to revoke
1148   // the bias on this object.
1149   testptr(header_reg, markWord::biased_lock_mask_in_place);
1150   jccb(Assembler::notZero, try_revoke_bias);
1151 
1152   // Biasing is still enabled for this data type. See whether the
1153   // epoch of the current bias is still valid, meaning that the epoch
1154   // bits of the mark word are equal to the epoch bits of the
1155   // prototype header. (Note that the prototype header&#39;s epoch bits
1156   // only change at a safepoint.) If not, attempt to rebias the object
1157   // toward the current thread. Note that we must be absolutely sure
1158   // that the current epoch is invalid in order to do this because
1159   // otherwise the manipulations it performs on the mark word are
1160   // illegal.
1161   testptr(header_reg, markWord::epoch_mask_in_place);
1162   jccb(Assembler::notZero, try_rebias);
1163 
1164   // The epoch of the current bias is still valid but we know nothing
1165   // about the owner; it might be set or it might be clear. Try to
1166   // acquire the bias of the object using an atomic operation. If this
1167   // fails we will go in to the runtime to revoke the object&#39;s bias.
1168   // Note that we first construct the presumed unbiased header so we
1169   // don&#39;t accidentally blow away another thread&#39;s valid bias.
1170   NOT_LP64( movptr(swap_reg, saved_mark_addr); )
1171   andptr(swap_reg,
1172          markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);
1173 #ifdef _LP64
1174   movptr(tmp_reg, swap_reg);
1175   orptr(tmp_reg, r15_thread);
1176 #else
1177   get_thread(tmp_reg);
1178   orptr(tmp_reg, swap_reg);
1179 #endif
1180   lock();
1181   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1182   // If the biasing toward our thread failed, this means that
1183   // another thread succeeded in biasing it toward itself and we
1184   // need to revoke that bias. The revocation will occur in the
1185   // interpreter runtime in the slow case.
1186   if (counters != NULL) {
1187     cond_inc32(Assembler::zero,
1188                ExternalAddress((address) counters-&gt;anonymously_biased_lock_entry_count_addr()));
1189   }
1190   if (slow_case != NULL) {
1191     jcc(Assembler::notZero, *slow_case);
1192   }
1193   jmp(done);
1194 
1195   bind(try_rebias);
1196   // At this point we know the epoch has expired, meaning that the
1197   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
1198   // circumstances _only_, we are allowed to use the current header&#39;s
1199   // value as the comparison value when doing the cas to acquire the
1200   // bias in the current epoch. In other words, we allow transfer of
1201   // the bias from one thread to another directly in this situation.
1202   //
1203   // FIXME: due to a lack of registers we currently blow away the age
1204   // bits in this situation. Should attempt to preserve them.
1205   load_prototype_header(tmp_reg, obj_reg, tmp_reg2);
1206 #ifdef _LP64
1207   orptr(tmp_reg, r15_thread);
1208 #else
1209   get_thread(swap_reg);
1210   orptr(tmp_reg, swap_reg);
1211   movptr(swap_reg, saved_mark_addr);
1212 #endif
1213   lock();
1214   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1215   // If the biasing toward our thread failed, then another thread
1216   // succeeded in biasing it toward itself and we need to revoke that
1217   // bias. The revocation will occur in the runtime in the slow case.
1218   if (counters != NULL) {
1219     cond_inc32(Assembler::zero,
1220                ExternalAddress((address) counters-&gt;rebiased_lock_entry_count_addr()));
1221   }
1222   if (slow_case != NULL) {
1223     jcc(Assembler::notZero, *slow_case);
1224   }
1225   jmp(done);
1226 
1227   bind(try_revoke_bias);
1228   // The prototype mark in the klass doesn&#39;t have the bias bit set any
1229   // more, indicating that objects of this data type are not supposed
1230   // to be biased any more. We are going to try to reset the mark of
1231   // this object to the prototype value and fall through to the
1232   // CAS-based locking scheme. Note that if our CAS fails, it means
1233   // that another thread raced us for the privilege of revoking the
1234   // bias of this particular object, so it&#39;s okay to continue in the
1235   // normal locking code.
1236   //
1237   // FIXME: due to a lack of registers we currently blow away the age
1238   // bits in this situation. Should attempt to preserve them.
1239   NOT_LP64( movptr(swap_reg, saved_mark_addr); )
1240   load_prototype_header(tmp_reg, obj_reg, tmp_reg2);
1241   lock();
1242   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1243   // Fall through to the normal CAS-based lock, because no matter what
1244   // the result of the above CAS, some thread must have succeeded in
1245   // removing the bias bit from the object&#39;s header.
1246   if (counters != NULL) {
1247     cond_inc32(Assembler::zero,
1248                ExternalAddress((address) counters-&gt;revoked_lock_entry_count_addr()));
1249   }
1250 
1251   bind(cas_label);
1252 
1253   return null_check_offset;
1254 }
1255 
1256 void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label&amp; done) {
1257   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
1258 
1259   // Check for biased locking unlock case, which is a no-op
1260   // Note: we do not have to check the thread ID for two reasons.
1261   // First, the interpreter checks for IllegalMonitorStateException at
1262   // a higher level. Second, if the bias was revoked while we held the
1263   // lock, the object could not be rebiased toward another thread, so
1264   // the bias bit would be clear.
1265   movptr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
1266   andptr(temp_reg, markWord::biased_lock_mask_in_place);
1267   cmpptr(temp_reg, markWord::biased_lock_pattern);
1268   jcc(Assembler::equal, done);
1269 }
1270 
1271 void MacroAssembler::c2bool(Register x) {
1272   // implements x == 0 ? 0 : 1
1273   // note: must only look at least-significant byte of x
1274   //       since C-style booleans are stored in one byte
1275   //       only! (was bug)
1276   andl(x, 0xFF);
1277   setb(Assembler::notZero, x);
1278 }
1279 
1280 // Wouldn&#39;t need if AddressLiteral version had new name
1281 void MacroAssembler::call(Label&amp; L, relocInfo::relocType rtype) {
1282   Assembler::call(L, rtype);
1283 }
1284 
1285 void MacroAssembler::call(Register entry) {
1286   Assembler::call(entry);
1287 }
1288 
1289 void MacroAssembler::call(AddressLiteral entry) {
1290   if (reachable(entry)) {
1291     Assembler::call_literal(entry.target(), entry.rspec());
1292   } else {
1293     lea(rscratch1, entry);
1294     Assembler::call(rscratch1);
1295   }
1296 }
1297 
1298 void MacroAssembler::ic_call(address entry, jint method_index) {
1299   RelocationHolder rh = virtual_call_Relocation::spec(pc(), method_index);
1300   movptr(rax, (intptr_t)Universe::non_oop_word());
1301   call(AddressLiteral(entry, rh));
1302 }
1303 
1304 // Implementation of call_VM versions
1305 
1306 void MacroAssembler::call_VM(Register oop_result,
1307                              address entry_point,
1308                              bool check_exceptions) {
1309   Label C, E;
1310   call(C, relocInfo::none);
1311   jmp(E);
1312 
1313   bind(C);
1314   call_VM_helper(oop_result, entry_point, 0, check_exceptions);
1315   ret(0);
1316 
1317   bind(E);
1318 }
1319 
1320 void MacroAssembler::call_VM(Register oop_result,
1321                              address entry_point,
1322                              Register arg_1,
1323                              bool check_exceptions) {
1324   Label C, E;
1325   call(C, relocInfo::none);
1326   jmp(E);
1327 
1328   bind(C);
1329   pass_arg1(this, arg_1);
1330   call_VM_helper(oop_result, entry_point, 1, check_exceptions);
1331   ret(0);
1332 
1333   bind(E);
1334 }
1335 
1336 void MacroAssembler::call_VM(Register oop_result,
1337                              address entry_point,
1338                              Register arg_1,
1339                              Register arg_2,
1340                              bool check_exceptions) {
1341   Label C, E;
1342   call(C, relocInfo::none);
1343   jmp(E);
1344 
1345   bind(C);
1346 
1347   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1348 
1349   pass_arg2(this, arg_2);
1350   pass_arg1(this, arg_1);
1351   call_VM_helper(oop_result, entry_point, 2, check_exceptions);
1352   ret(0);
1353 
1354   bind(E);
1355 }
1356 
1357 void MacroAssembler::call_VM(Register oop_result,
1358                              address entry_point,
1359                              Register arg_1,
1360                              Register arg_2,
1361                              Register arg_3,
1362                              bool check_exceptions) {
1363   Label C, E;
1364   call(C, relocInfo::none);
1365   jmp(E);
1366 
1367   bind(C);
1368 
1369   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1370   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1371   pass_arg3(this, arg_3);
1372 
1373   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1374   pass_arg2(this, arg_2);
1375 
1376   pass_arg1(this, arg_1);
1377   call_VM_helper(oop_result, entry_point, 3, check_exceptions);
1378   ret(0);
1379 
1380   bind(E);
1381 }
1382 
1383 void MacroAssembler::call_VM(Register oop_result,
1384                              Register last_java_sp,
1385                              address entry_point,
1386                              int number_of_arguments,
1387                              bool check_exceptions) {
1388   Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
1389   call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
1390 }
1391 
1392 void MacroAssembler::call_VM(Register oop_result,
1393                              Register last_java_sp,
1394                              address entry_point,
1395                              Register arg_1,
1396                              bool check_exceptions) {
1397   pass_arg1(this, arg_1);
1398   call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
1399 }
1400 
1401 void MacroAssembler::call_VM(Register oop_result,
1402                              Register last_java_sp,
1403                              address entry_point,
1404                              Register arg_1,
1405                              Register arg_2,
1406                              bool check_exceptions) {
1407 
1408   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1409   pass_arg2(this, arg_2);
1410   pass_arg1(this, arg_1);
1411   call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
1412 }
1413 
1414 void MacroAssembler::call_VM(Register oop_result,
1415                              Register last_java_sp,
1416                              address entry_point,
1417                              Register arg_1,
1418                              Register arg_2,
1419                              Register arg_3,
1420                              bool check_exceptions) {
1421   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1422   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1423   pass_arg3(this, arg_3);
1424   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1425   pass_arg2(this, arg_2);
1426   pass_arg1(this, arg_1);
1427   call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
1428 }
1429 
1430 void MacroAssembler::super_call_VM(Register oop_result,
1431                                    Register last_java_sp,
1432                                    address entry_point,
1433                                    int number_of_arguments,
1434                                    bool check_exceptions) {
1435   Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
1436   MacroAssembler::call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
1437 }
1438 
1439 void MacroAssembler::super_call_VM(Register oop_result,
1440                                    Register last_java_sp,
1441                                    address entry_point,
1442                                    Register arg_1,
1443                                    bool check_exceptions) {
1444   pass_arg1(this, arg_1);
1445   super_call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
1446 }
1447 
1448 void MacroAssembler::super_call_VM(Register oop_result,
1449                                    Register last_java_sp,
1450                                    address entry_point,
1451                                    Register arg_1,
1452                                    Register arg_2,
1453                                    bool check_exceptions) {
1454 
1455   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1456   pass_arg2(this, arg_2);
1457   pass_arg1(this, arg_1);
1458   super_call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
1459 }
1460 
1461 void MacroAssembler::super_call_VM(Register oop_result,
1462                                    Register last_java_sp,
1463                                    address entry_point,
1464                                    Register arg_1,
1465                                    Register arg_2,
1466                                    Register arg_3,
1467                                    bool check_exceptions) {
1468   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1469   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1470   pass_arg3(this, arg_3);
1471   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1472   pass_arg2(this, arg_2);
1473   pass_arg1(this, arg_1);
1474   super_call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
1475 }
1476 
1477 void MacroAssembler::call_VM_base(Register oop_result,
1478                                   Register java_thread,
1479                                   Register last_java_sp,
1480                                   address  entry_point,
1481                                   int      number_of_arguments,
1482                                   bool     check_exceptions) {
1483   // determine java_thread register
1484   if (!java_thread-&gt;is_valid()) {
1485 #ifdef _LP64
1486     java_thread = r15_thread;
1487 #else
1488     java_thread = rdi;
1489     get_thread(java_thread);
1490 #endif // LP64
1491   }
1492   // determine last_java_sp register
1493   if (!last_java_sp-&gt;is_valid()) {
1494     last_java_sp = rsp;
1495   }
1496   // debugging support
1497   assert(number_of_arguments &gt;= 0   , &quot;cannot have negative number of arguments&quot;);
1498   LP64_ONLY(assert(java_thread == r15_thread, &quot;unexpected register&quot;));
1499 #ifdef ASSERT
1500   // TraceBytecodes does not use r12 but saves it over the call, so don&#39;t verify
1501   // r12 is the heapbase.
1502   LP64_ONLY(if (UseCompressedOops &amp;&amp; !TraceBytecodes) verify_heapbase(&quot;call_VM_base: heap base corrupted?&quot;);)
1503 #endif // ASSERT
1504 
1505   assert(java_thread != oop_result  , &quot;cannot use the same register for java_thread &amp; oop_result&quot;);
1506   assert(java_thread != last_java_sp, &quot;cannot use the same register for java_thread &amp; last_java_sp&quot;);
1507 
1508   // push java thread (becomes first argument of C function)
1509 
1510   NOT_LP64(push(java_thread); number_of_arguments++);
1511   LP64_ONLY(mov(c_rarg0, r15_thread));
1512 
1513   // set last Java frame before call
1514   assert(last_java_sp != rbp, &quot;can&#39;t use ebp/rbp&quot;);
1515 
1516   // Only interpreter should have to set fp
1517   set_last_Java_frame(java_thread, last_java_sp, rbp, NULL);
1518 
1519   // do the call, remove parameters
1520   MacroAssembler::call_VM_leaf_base(entry_point, number_of_arguments);
1521 
1522   // restore the thread (cannot use the pushed argument since arguments
1523   // may be overwritten by C code generated by an optimizing compiler);
1524   // however can use the register value directly if it is callee saved.
1525   if (LP64_ONLY(true ||) java_thread == rdi || java_thread == rsi) {
1526     // rdi &amp; rsi (also r15) are callee saved -&gt; nothing to do
1527 #ifdef ASSERT
1528     guarantee(java_thread != rax, &quot;change this code&quot;);
1529     push(rax);
1530     { Label L;
1531       get_thread(rax);
1532       cmpptr(java_thread, rax);
1533       jcc(Assembler::equal, L);
1534       STOP(&quot;MacroAssembler::call_VM_base: rdi not callee saved?&quot;);
1535       bind(L);
1536     }
1537     pop(rax);
1538 #endif
1539   } else {
1540     get_thread(java_thread);
1541   }
1542   // reset last Java frame
1543   // Only interpreter should have to clear fp
1544   reset_last_Java_frame(java_thread, true);
1545 
1546    // C++ interp handles this in the interpreter
1547   check_and_handle_popframe(java_thread);
1548   check_and_handle_earlyret(java_thread);
1549 
1550   if (check_exceptions) {
1551     // check for pending exceptions (java_thread is set upon return)
1552     cmpptr(Address(java_thread, Thread::pending_exception_offset()), (int32_t) NULL_WORD);
1553 #ifndef _LP64
1554     jump_cc(Assembler::notEqual,
1555             RuntimeAddress(StubRoutines::forward_exception_entry()));
1556 #else
1557     // This used to conditionally jump to forward_exception however it is
1558     // possible if we relocate that the branch will not reach. So we must jump
1559     // around so we can always reach
1560 
1561     Label ok;
1562     jcc(Assembler::equal, ok);
1563     jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
1564     bind(ok);
1565 #endif // LP64
1566   }
1567 
1568   // get oop result if there is one and reset the value in the thread
1569   if (oop_result-&gt;is_valid()) {
1570     get_vm_result(oop_result, java_thread);
1571   }
1572 }
1573 
1574 void MacroAssembler::call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions) {
1575 
1576   // Calculate the value for last_Java_sp
1577   // somewhat subtle. call_VM does an intermediate call
1578   // which places a return address on the stack just under the
1579   // stack pointer as the user finsihed with it. This allows
1580   // use to retrieve last_Java_pc from last_Java_sp[-1].
1581   // On 32bit we then have to push additional args on the stack to accomplish
1582   // the actual requested call. On 64bit call_VM only can use register args
1583   // so the only extra space is the return address that call_VM created.
1584   // This hopefully explains the calculations here.
1585 
1586 #ifdef _LP64
1587   // We&#39;ve pushed one address, correct last_Java_sp
1588   lea(rax, Address(rsp, wordSize));
1589 #else
1590   lea(rax, Address(rsp, (1 + number_of_arguments) * wordSize));
1591 #endif // LP64
1592 
1593   call_VM_base(oop_result, noreg, rax, entry_point, number_of_arguments, check_exceptions);
1594 
1595 }
1596 
1597 // Use this method when MacroAssembler version of call_VM_leaf_base() should be called from Interpreter.
1598 void MacroAssembler::call_VM_leaf0(address entry_point) {
1599   MacroAssembler::call_VM_leaf_base(entry_point, 0);
1600 }
1601 
1602 void MacroAssembler::call_VM_leaf(address entry_point, int number_of_arguments) {
1603   call_VM_leaf_base(entry_point, number_of_arguments);
1604 }
1605 
1606 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0) {
1607   pass_arg0(this, arg_0);
1608   call_VM_leaf(entry_point, 1);
1609 }
1610 
1611 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1612 
1613   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1614   pass_arg1(this, arg_1);
1615   pass_arg0(this, arg_0);
1616   call_VM_leaf(entry_point, 2);
1617 }
1618 
1619 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
1620   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1621   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1622   pass_arg2(this, arg_2);
1623   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1624   pass_arg1(this, arg_1);
1625   pass_arg0(this, arg_0);
1626   call_VM_leaf(entry_point, 3);
1627 }
1628 
1629 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0) {
1630   pass_arg0(this, arg_0);
1631   MacroAssembler::call_VM_leaf_base(entry_point, 1);
1632 }
1633 
1634 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1635 
1636   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1637   pass_arg1(this, arg_1);
1638   pass_arg0(this, arg_0);
1639   MacroAssembler::call_VM_leaf_base(entry_point, 2);
1640 }
1641 
1642 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
1643   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1644   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1645   pass_arg2(this, arg_2);
1646   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1647   pass_arg1(this, arg_1);
1648   pass_arg0(this, arg_0);
1649   MacroAssembler::call_VM_leaf_base(entry_point, 3);
1650 }
1651 
1652 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2, Register arg_3) {
1653   LP64_ONLY(assert(arg_0 != c_rarg3, &quot;smashed arg&quot;));
1654   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1655   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1656   pass_arg3(this, arg_3);
1657   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1658   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1659   pass_arg2(this, arg_2);
1660   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1661   pass_arg1(this, arg_1);
1662   pass_arg0(this, arg_0);
1663   MacroAssembler::call_VM_leaf_base(entry_point, 4);
1664 }
1665 
1666 void MacroAssembler::get_vm_result(Register oop_result, Register java_thread) {
1667   movptr(oop_result, Address(java_thread, JavaThread::vm_result_offset()));
1668   movptr(Address(java_thread, JavaThread::vm_result_offset()), NULL_WORD);
1669   verify_oop_msg(oop_result, &quot;broken oop in call_VM_base&quot;);
1670 }
1671 
1672 void MacroAssembler::get_vm_result_2(Register metadata_result, Register java_thread) {
1673   movptr(metadata_result, Address(java_thread, JavaThread::vm_result_2_offset()));
1674   movptr(Address(java_thread, JavaThread::vm_result_2_offset()), NULL_WORD);
1675 }
1676 
1677 void MacroAssembler::check_and_handle_earlyret(Register java_thread) {
1678 }
1679 
1680 void MacroAssembler::check_and_handle_popframe(Register java_thread) {
1681 }
1682 
1683 void MacroAssembler::cmp32(AddressLiteral src1, int32_t imm) {
1684   if (reachable(src1)) {
1685     cmpl(as_Address(src1), imm);
1686   } else {
1687     lea(rscratch1, src1);
1688     cmpl(Address(rscratch1, 0), imm);
1689   }
1690 }
1691 
1692 void MacroAssembler::cmp32(Register src1, AddressLiteral src2) {
1693   assert(!src2.is_lval(), &quot;use cmpptr&quot;);
1694   if (reachable(src2)) {
1695     cmpl(src1, as_Address(src2));
1696   } else {
1697     lea(rscratch1, src2);
1698     cmpl(src1, Address(rscratch1, 0));
1699   }
1700 }
1701 
1702 void MacroAssembler::cmp32(Register src1, int32_t imm) {
1703   Assembler::cmpl(src1, imm);
1704 }
1705 
1706 void MacroAssembler::cmp32(Register src1, Address src2) {
1707   Assembler::cmpl(src1, src2);
1708 }
1709 
1710 void MacroAssembler::cmpsd2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less) {
1711   ucomisd(opr1, opr2);
1712 
1713   Label L;
1714   if (unordered_is_less) {
1715     movl(dst, -1);
1716     jcc(Assembler::parity, L);
1717     jcc(Assembler::below , L);
1718     movl(dst, 0);
1719     jcc(Assembler::equal , L);
1720     increment(dst);
1721   } else { // unordered is greater
1722     movl(dst, 1);
1723     jcc(Assembler::parity, L);
1724     jcc(Assembler::above , L);
1725     movl(dst, 0);
1726     jcc(Assembler::equal , L);
1727     decrementl(dst);
1728   }
1729   bind(L);
1730 }
1731 
1732 void MacroAssembler::cmpss2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less) {
1733   ucomiss(opr1, opr2);
1734 
1735   Label L;
1736   if (unordered_is_less) {
1737     movl(dst, -1);
1738     jcc(Assembler::parity, L);
1739     jcc(Assembler::below , L);
1740     movl(dst, 0);
1741     jcc(Assembler::equal , L);
1742     increment(dst);
1743   } else { // unordered is greater
1744     movl(dst, 1);
1745     jcc(Assembler::parity, L);
1746     jcc(Assembler::above , L);
1747     movl(dst, 0);
1748     jcc(Assembler::equal , L);
1749     decrementl(dst);
1750   }
1751   bind(L);
1752 }
1753 
1754 
1755 void MacroAssembler::cmp8(AddressLiteral src1, int imm) {
1756   if (reachable(src1)) {
1757     cmpb(as_Address(src1), imm);
1758   } else {
1759     lea(rscratch1, src1);
1760     cmpb(Address(rscratch1, 0), imm);
1761   }
1762 }
1763 
1764 void MacroAssembler::cmpptr(Register src1, AddressLiteral src2) {
1765 #ifdef _LP64
1766   if (src2.is_lval()) {
1767     movptr(rscratch1, src2);
1768     Assembler::cmpq(src1, rscratch1);
1769   } else if (reachable(src2)) {
1770     cmpq(src1, as_Address(src2));
1771   } else {
1772     lea(rscratch1, src2);
1773     Assembler::cmpq(src1, Address(rscratch1, 0));
1774   }
1775 #else
1776   if (src2.is_lval()) {
1777     cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());
1778   } else {
1779     cmpl(src1, as_Address(src2));
1780   }
1781 #endif // _LP64
1782 }
1783 
1784 void MacroAssembler::cmpptr(Address src1, AddressLiteral src2) {
1785   assert(src2.is_lval(), &quot;not a mem-mem compare&quot;);
1786 #ifdef _LP64
1787   // moves src2&#39;s literal address
1788   movptr(rscratch1, src2);
1789   Assembler::cmpq(src1, rscratch1);
1790 #else
1791   cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());
1792 #endif // _LP64
1793 }
1794 
1795 void MacroAssembler::cmpoop(Register src1, Register src2) {
1796   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1797   bs-&gt;obj_equals(this, src1, src2);
1798 }
1799 
1800 void MacroAssembler::cmpoop(Register src1, Address src2) {
1801   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1802   bs-&gt;obj_equals(this, src1, src2);
1803 }
1804 
1805 #ifdef _LP64
1806 void MacroAssembler::cmpoop(Register src1, jobject src2) {
1807   movoop(rscratch1, src2);
1808   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1809   bs-&gt;obj_equals(this, src1, rscratch1);
1810 }
1811 #endif
1812 
1813 void MacroAssembler::locked_cmpxchgptr(Register reg, AddressLiteral adr) {
1814   if (reachable(adr)) {
1815     lock();
1816     cmpxchgptr(reg, as_Address(adr));
1817   } else {
1818     lea(rscratch1, adr);
1819     lock();
1820     cmpxchgptr(reg, Address(rscratch1, 0));
1821   }
1822 }
1823 
1824 void MacroAssembler::cmpxchgptr(Register reg, Address adr) {
1825   LP64_ONLY(cmpxchgq(reg, adr)) NOT_LP64(cmpxchgl(reg, adr));
1826 }
1827 
1828 void MacroAssembler::comisd(XMMRegister dst, AddressLiteral src) {
1829   if (reachable(src)) {
1830     Assembler::comisd(dst, as_Address(src));
1831   } else {
1832     lea(rscratch1, src);
1833     Assembler::comisd(dst, Address(rscratch1, 0));
1834   }
1835 }
1836 
1837 void MacroAssembler::comiss(XMMRegister dst, AddressLiteral src) {
1838   if (reachable(src)) {
1839     Assembler::comiss(dst, as_Address(src));
1840   } else {
1841     lea(rscratch1, src);
1842     Assembler::comiss(dst, Address(rscratch1, 0));
1843   }
1844 }
1845 
1846 
1847 void MacroAssembler::cond_inc32(Condition cond, AddressLiteral counter_addr) {
1848   Condition negated_cond = negate_condition(cond);
1849   Label L;
1850   jcc(negated_cond, L);
1851   pushf(); // Preserve flags
1852   atomic_incl(counter_addr);
1853   popf();
1854   bind(L);
1855 }
1856 
1857 int MacroAssembler::corrected_idivl(Register reg) {
1858   // Full implementation of Java idiv and irem; checks for
1859   // special case as described in JVM spec., p.243 &amp; p.271.
1860   // The function returns the (pc) offset of the idivl
1861   // instruction - may be needed for implicit exceptions.
1862   //
1863   //         normal case                           special case
1864   //
1865   // input : rax,: dividend                         min_int
1866   //         reg: divisor   (may not be rax,/rdx)   -1
1867   //
1868   // output: rax,: quotient  (= rax, idiv reg)       min_int
1869   //         rdx: remainder (= rax, irem reg)       0
1870   assert(reg != rax &amp;&amp; reg != rdx, &quot;reg cannot be rax, or rdx register&quot;);
1871   const int min_int = 0x80000000;
1872   Label normal_case, special_case;
1873 
1874   // check for special case
1875   cmpl(rax, min_int);
1876   jcc(Assembler::notEqual, normal_case);
1877   xorl(rdx, rdx); // prepare rdx for possible special case (where remainder = 0)
1878   cmpl(reg, -1);
1879   jcc(Assembler::equal, special_case);
1880 
1881   // handle normal case
1882   bind(normal_case);
1883   cdql();
1884   int idivl_offset = offset();
1885   idivl(reg);
1886 
1887   // normal and special case exit
1888   bind(special_case);
1889 
1890   return idivl_offset;
1891 }
1892 
1893 
1894 
1895 void MacroAssembler::decrementl(Register reg, int value) {
1896   if (value == min_jint) {subl(reg, value) ; return; }
1897   if (value &lt;  0) { incrementl(reg, -value); return; }
1898   if (value == 0) {                        ; return; }
1899   if (value == 1 &amp;&amp; UseIncDec) { decl(reg) ; return; }
1900   /* else */      { subl(reg, value)       ; return; }
1901 }
1902 
1903 void MacroAssembler::decrementl(Address dst, int value) {
1904   if (value == min_jint) {subl(dst, value) ; return; }
1905   if (value &lt;  0) { incrementl(dst, -value); return; }
1906   if (value == 0) {                        ; return; }
1907   if (value == 1 &amp;&amp; UseIncDec) { decl(dst) ; return; }
1908   /* else */      { subl(dst, value)       ; return; }
1909 }
1910 
1911 void MacroAssembler::division_with_shift (Register reg, int shift_value) {
1912   assert (shift_value &gt; 0, &quot;illegal shift value&quot;);
1913   Label _is_positive;
1914   testl (reg, reg);
1915   jcc (Assembler::positive, _is_positive);
1916   int offset = (1 &lt;&lt; shift_value) - 1 ;
1917 
1918   if (offset == 1) {
1919     incrementl(reg);
1920   } else {
1921     addl(reg, offset);
1922   }
1923 
1924   bind (_is_positive);
1925   sarl(reg, shift_value);
1926 }
1927 
1928 void MacroAssembler::divsd(XMMRegister dst, AddressLiteral src) {
1929   if (reachable(src)) {
1930     Assembler::divsd(dst, as_Address(src));
1931   } else {
1932     lea(rscratch1, src);
1933     Assembler::divsd(dst, Address(rscratch1, 0));
1934   }
1935 }
1936 
1937 void MacroAssembler::divss(XMMRegister dst, AddressLiteral src) {
1938   if (reachable(src)) {
1939     Assembler::divss(dst, as_Address(src));
1940   } else {
1941     lea(rscratch1, src);
1942     Assembler::divss(dst, Address(rscratch1, 0));
1943   }
1944 }
1945 
1946 void MacroAssembler::enter() {
1947   push(rbp);
1948   mov(rbp, rsp);
1949 }
1950 
1951 // A 5 byte nop that is safe for patching (see patch_verified_entry)
1952 void MacroAssembler::fat_nop() {
1953   if (UseAddressNop) {
1954     addr_nop_5();
1955   } else {
1956     emit_int8(0x26); // es:
1957     emit_int8(0x2e); // cs:
1958     emit_int8(0x64); // fs:
1959     emit_int8(0x65); // gs:
1960     emit_int8((unsigned char)0x90);
1961   }
1962 }
1963 
1964 #ifndef _LP64
1965 void MacroAssembler::fcmp(Register tmp) {
1966   fcmp(tmp, 1, true, true);
1967 }
1968 
1969 void MacroAssembler::fcmp(Register tmp, int index, bool pop_left, bool pop_right) {
1970   assert(!pop_right || pop_left, &quot;usage error&quot;);
1971   if (VM_Version::supports_cmov()) {
1972     assert(tmp == noreg, &quot;unneeded temp&quot;);
1973     if (pop_left) {
1974       fucomip(index);
1975     } else {
1976       fucomi(index);
1977     }
1978     if (pop_right) {
1979       fpop();
1980     }
1981   } else {
1982     assert(tmp != noreg, &quot;need temp&quot;);
1983     if (pop_left) {
1984       if (pop_right) {
1985         fcompp();
1986       } else {
1987         fcomp(index);
1988       }
1989     } else {
1990       fcom(index);
1991     }
1992     // convert FPU condition into eflags condition via rax,
1993     save_rax(tmp);
1994     fwait(); fnstsw_ax();
1995     sahf();
1996     restore_rax(tmp);
1997   }
1998   // condition codes set as follows:
1999   //
2000   // CF (corresponds to C0) if x &lt; y
2001   // PF (corresponds to C2) if unordered
2002   // ZF (corresponds to C3) if x = y
2003 }
2004 
2005 void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less) {
2006   fcmp2int(dst, unordered_is_less, 1, true, true);
2007 }
2008 
2009 void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less, int index, bool pop_left, bool pop_right) {
2010   fcmp(VM_Version::supports_cmov() ? noreg : dst, index, pop_left, pop_right);
2011   Label L;
2012   if (unordered_is_less) {
2013     movl(dst, -1);
2014     jcc(Assembler::parity, L);
2015     jcc(Assembler::below , L);
2016     movl(dst, 0);
2017     jcc(Assembler::equal , L);
2018     increment(dst);
2019   } else { // unordered is greater
2020     movl(dst, 1);
2021     jcc(Assembler::parity, L);
2022     jcc(Assembler::above , L);
2023     movl(dst, 0);
2024     jcc(Assembler::equal , L);
2025     decrementl(dst);
2026   }
2027   bind(L);
2028 }
2029 
2030 void MacroAssembler::fld_d(AddressLiteral src) {
2031   fld_d(as_Address(src));
2032 }
2033 
2034 void MacroAssembler::fld_s(AddressLiteral src) {
2035   fld_s(as_Address(src));
2036 }
2037 
2038 void MacroAssembler::fldcw(AddressLiteral src) {
2039   Assembler::fldcw(as_Address(src));
2040 }
2041 
2042 void MacroAssembler::fpop() {
2043   ffree();
2044   fincstp();
2045 }
2046 
2047 void MacroAssembler::fremr(Register tmp) {
2048   save_rax(tmp);
2049   { Label L;
2050     bind(L);
2051     fprem();
2052     fwait(); fnstsw_ax();
2053     sahf();
2054     jcc(Assembler::parity, L);
2055   }
2056   restore_rax(tmp);
2057   // Result is in ST0.
2058   // Note: fxch &amp; fpop to get rid of ST1
2059   // (otherwise FPU stack could overflow eventually)
2060   fxch(1);
2061   fpop();
2062 }
2063 
2064 void MacroAssembler::empty_FPU_stack() {
2065   if (VM_Version::supports_mmx()) {
2066     emms();
2067   } else {
2068     for (int i = 8; i-- &gt; 0; ) ffree(i);
2069   }
2070 }
2071 #endif // !LP64
2072 
2073 void MacroAssembler::mulpd(XMMRegister dst, AddressLiteral src) {
2074   if (reachable(src)) {
2075     Assembler::mulpd(dst, as_Address(src));
2076   } else {
2077     lea(rscratch1, src);
2078     Assembler::mulpd(dst, Address(rscratch1, 0));
2079   }
2080 }
2081 
2082 void MacroAssembler::load_float(Address src) {
2083 #ifdef _LP64
2084   movflt(xmm0, src);
2085 #else
2086   if (UseSSE &gt;= 1) {
2087     movflt(xmm0, src);
2088   } else {
2089     fld_s(src);
2090   }
2091 #endif // LP64
2092 }
2093 
2094 void MacroAssembler::store_float(Address dst) {
2095 #ifdef _LP64
2096   movflt(dst, xmm0);
2097 #else
2098   if (UseSSE &gt;= 1) {
2099     movflt(dst, xmm0);
2100   } else {
2101     fstp_s(dst);
2102   }
2103 #endif // LP64
2104 }
2105 
2106 void MacroAssembler::load_double(Address src) {
2107 #ifdef _LP64
2108   movdbl(xmm0, src);
2109 #else
2110   if (UseSSE &gt;= 2) {
2111     movdbl(xmm0, src);
2112   } else {
2113     fld_d(src);
2114   }
2115 #endif // LP64
2116 }
2117 
2118 void MacroAssembler::store_double(Address dst) {
2119 #ifdef _LP64
2120   movdbl(dst, xmm0);
2121 #else
2122   if (UseSSE &gt;= 2) {
2123     movdbl(dst, xmm0);
2124   } else {
2125     fstp_d(dst);
2126   }
2127 #endif // LP64
2128 }
2129 
2130 // dst = c = a * b + c
2131 void MacroAssembler::fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
2132   Assembler::vfmadd231sd(c, a, b);
2133   if (dst != c) {
2134     movdbl(dst, c);
2135   }
2136 }
2137 
2138 // dst = c = a * b + c
2139 void MacroAssembler::fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
2140   Assembler::vfmadd231ss(c, a, b);
2141   if (dst != c) {
2142     movflt(dst, c);
2143   }
2144 }
2145 
2146 // dst = c = a * b + c
2147 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
2148   Assembler::vfmadd231pd(c, a, b, vector_len);
2149   if (dst != c) {
2150     vmovdqu(dst, c);
2151   }
2152 }
2153 
2154 // dst = c = a * b + c
2155 void MacroAssembler::vfmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
2156   Assembler::vfmadd231ps(c, a, b, vector_len);
2157   if (dst != c) {
2158     vmovdqu(dst, c);
2159   }
2160 }
2161 
2162 // dst = c = a * b + c
2163 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {
2164   Assembler::vfmadd231pd(c, a, b, vector_len);
2165   if (dst != c) {
2166     vmovdqu(dst, c);
2167   }
2168 }
2169 
2170 // dst = c = a * b + c
2171 void MacroAssembler::vfmaf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {
2172   Assembler::vfmadd231ps(c, a, b, vector_len);
2173   if (dst != c) {
2174     vmovdqu(dst, c);
2175   }
2176 }
2177 
2178 void MacroAssembler::incrementl(AddressLiteral dst) {
2179   if (reachable(dst)) {
2180     incrementl(as_Address(dst));
2181   } else {
2182     lea(rscratch1, dst);
2183     incrementl(Address(rscratch1, 0));
2184   }
2185 }
2186 
2187 void MacroAssembler::incrementl(ArrayAddress dst) {
2188   incrementl(as_Address(dst));
2189 }
2190 
2191 void MacroAssembler::incrementl(Register reg, int value) {
2192   if (value == min_jint) {addl(reg, value) ; return; }
2193   if (value &lt;  0) { decrementl(reg, -value); return; }
2194   if (value == 0) {                        ; return; }
2195   if (value == 1 &amp;&amp; UseIncDec) { incl(reg) ; return; }
2196   /* else */      { addl(reg, value)       ; return; }
2197 }
2198 
2199 void MacroAssembler::incrementl(Address dst, int value) {
2200   if (value == min_jint) {addl(dst, value) ; return; }
2201   if (value &lt;  0) { decrementl(dst, -value); return; }
2202   if (value == 0) {                        ; return; }
2203   if (value == 1 &amp;&amp; UseIncDec) { incl(dst) ; return; }
2204   /* else */      { addl(dst, value)       ; return; }
2205 }
2206 
2207 void MacroAssembler::jump(AddressLiteral dst) {
2208   if (reachable(dst)) {
2209     jmp_literal(dst.target(), dst.rspec());
2210   } else {
2211     lea(rscratch1, dst);
2212     jmp(rscratch1);
2213   }
2214 }
2215 
2216 void MacroAssembler::jump_cc(Condition cc, AddressLiteral dst) {
2217   if (reachable(dst)) {
2218     InstructionMark im(this);
2219     relocate(dst.reloc());
2220     const int short_size = 2;
2221     const int long_size = 6;
2222     int offs = (intptr_t)dst.target() - ((intptr_t)pc());
2223     if (dst.reloc() == relocInfo::none &amp;&amp; is8bit(offs - short_size)) {
2224       // 0111 tttn #8-bit disp
2225       emit_int8(0x70 | cc);
2226       emit_int8((offs - short_size) &amp; 0xFF);
2227     } else {
2228       // 0000 1111 1000 tttn #32-bit disp
2229       emit_int8(0x0F);
2230       emit_int8((unsigned char)(0x80 | cc));
2231       emit_int32(offs - long_size);
2232     }
2233   } else {
2234 #ifdef ASSERT
2235     warning(&quot;reversing conditional branch&quot;);
2236 #endif /* ASSERT */
2237     Label skip;
2238     jccb(reverse[cc], skip);
2239     lea(rscratch1, dst);
2240     Assembler::jmp(rscratch1);
2241     bind(skip);
2242   }
2243 }
2244 
2245 void MacroAssembler::fld_x(AddressLiteral src) {
2246   Assembler::fld_x(as_Address(src));
2247 }
2248 
2249 void MacroAssembler::ldmxcsr(AddressLiteral src) {
2250   if (reachable(src)) {
2251     Assembler::ldmxcsr(as_Address(src));
2252   } else {
2253     lea(rscratch1, src);
2254     Assembler::ldmxcsr(Address(rscratch1, 0));
2255   }
2256 }
2257 
2258 int MacroAssembler::load_signed_byte(Register dst, Address src) {
2259   int off;
2260   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2261     off = offset();
2262     movsbl(dst, src); // movsxb
2263   } else {
2264     off = load_unsigned_byte(dst, src);
2265     shll(dst, 24);
2266     sarl(dst, 24);
2267   }
2268   return off;
2269 }
2270 
2271 // Note: load_signed_short used to be called load_signed_word.
2272 // Although the &#39;w&#39; in x86 opcodes refers to the term &quot;word&quot; in the assembler
2273 // manual, which means 16 bits, that usage is found nowhere in HotSpot code.
2274 // The term &quot;word&quot; in HotSpot means a 32- or 64-bit machine word.
2275 int MacroAssembler::load_signed_short(Register dst, Address src) {
2276   int off;
2277   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2278     // This is dubious to me since it seems safe to do a signed 16 =&gt; 64 bit
2279     // version but this is what 64bit has always done. This seems to imply
2280     // that users are only using 32bits worth.
2281     off = offset();
2282     movswl(dst, src); // movsxw
2283   } else {
2284     off = load_unsigned_short(dst, src);
2285     shll(dst, 16);
2286     sarl(dst, 16);
2287   }
2288   return off;
2289 }
2290 
2291 int MacroAssembler::load_unsigned_byte(Register dst, Address src) {
2292   // According to Intel Doc. AP-526, &quot;Zero-Extension of Short&quot;, p.16,
2293   // and &quot;3.9 Partial Register Penalties&quot;, p. 22).
2294   int off;
2295   if (LP64_ONLY(true || ) VM_Version::is_P6() || src.uses(dst)) {
2296     off = offset();
2297     movzbl(dst, src); // movzxb
2298   } else {
2299     xorl(dst, dst);
2300     off = offset();
2301     movb(dst, src);
2302   }
2303   return off;
2304 }
2305 
2306 // Note: load_unsigned_short used to be called load_unsigned_word.
2307 int MacroAssembler::load_unsigned_short(Register dst, Address src) {
2308   // According to Intel Doc. AP-526, &quot;Zero-Extension of Short&quot;, p.16,
2309   // and &quot;3.9 Partial Register Penalties&quot;, p. 22).
2310   int off;
2311   if (LP64_ONLY(true ||) VM_Version::is_P6() || src.uses(dst)) {
2312     off = offset();
2313     movzwl(dst, src); // movzxw
2314   } else {
2315     xorl(dst, dst);
2316     off = offset();
2317     movw(dst, src);
2318   }
2319   return off;
2320 }
2321 
2322 void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2) {
2323   switch (size_in_bytes) {
2324 #ifndef _LP64
2325   case  8:
2326     assert(dst2 != noreg, &quot;second dest register required&quot;);
2327     movl(dst,  src);
2328     movl(dst2, src.plus_disp(BytesPerInt));
2329     break;
2330 #else
2331   case  8:  movq(dst, src); break;
2332 #endif
2333   case  4:  movl(dst, src); break;
2334   case  2:  is_signed ? load_signed_short(dst, src) : load_unsigned_short(dst, src); break;
2335   case  1:  is_signed ? load_signed_byte( dst, src) : load_unsigned_byte( dst, src); break;
2336   default:  ShouldNotReachHere();
2337   }
2338 }
2339 
2340 void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2) {
2341   switch (size_in_bytes) {
2342 #ifndef _LP64
2343   case  8:
2344     assert(src2 != noreg, &quot;second source register required&quot;);
2345     movl(dst,                        src);
2346     movl(dst.plus_disp(BytesPerInt), src2);
2347     break;
2348 #else
2349   case  8:  movq(dst, src); break;
2350 #endif
2351   case  4:  movl(dst, src); break;
2352   case  2:  movw(dst, src); break;
2353   case  1:  movb(dst, src); break;
2354   default:  ShouldNotReachHere();
2355   }
2356 }
2357 
2358 void MacroAssembler::mov32(AddressLiteral dst, Register src) {
2359   if (reachable(dst)) {
2360     movl(as_Address(dst), src);
2361   } else {
2362     lea(rscratch1, dst);
2363     movl(Address(rscratch1, 0), src);
2364   }
2365 }
2366 
2367 void MacroAssembler::mov32(Register dst, AddressLiteral src) {
2368   if (reachable(src)) {
2369     movl(dst, as_Address(src));
2370   } else {
2371     lea(rscratch1, src);
2372     movl(dst, Address(rscratch1, 0));
2373   }
2374 }
2375 
2376 // C++ bool manipulation
2377 
2378 void MacroAssembler::movbool(Register dst, Address src) {
2379   if(sizeof(bool) == 1)
2380     movb(dst, src);
2381   else if(sizeof(bool) == 2)
2382     movw(dst, src);
2383   else if(sizeof(bool) == 4)
2384     movl(dst, src);
2385   else
2386     // unsupported
2387     ShouldNotReachHere();
2388 }
2389 
2390 void MacroAssembler::movbool(Address dst, bool boolconst) {
2391   if(sizeof(bool) == 1)
2392     movb(dst, (int) boolconst);
2393   else if(sizeof(bool) == 2)
2394     movw(dst, (int) boolconst);
2395   else if(sizeof(bool) == 4)
2396     movl(dst, (int) boolconst);
2397   else
2398     // unsupported
2399     ShouldNotReachHere();
2400 }
2401 
2402 void MacroAssembler::movbool(Address dst, Register src) {
2403   if(sizeof(bool) == 1)
2404     movb(dst, src);
2405   else if(sizeof(bool) == 2)
2406     movw(dst, src);
2407   else if(sizeof(bool) == 4)
2408     movl(dst, src);
2409   else
2410     // unsupported
2411     ShouldNotReachHere();
2412 }
2413 
2414 void MacroAssembler::movbyte(ArrayAddress dst, int src) {
2415   movb(as_Address(dst), src);
2416 }
2417 
2418 void MacroAssembler::movdl(XMMRegister dst, AddressLiteral src) {
2419   if (reachable(src)) {
2420     movdl(dst, as_Address(src));
2421   } else {
2422     lea(rscratch1, src);
2423     movdl(dst, Address(rscratch1, 0));
2424   }
2425 }
2426 
2427 void MacroAssembler::movq(XMMRegister dst, AddressLiteral src) {
2428   if (reachable(src)) {
2429     movq(dst, as_Address(src));
2430   } else {
2431     lea(rscratch1, src);
2432     movq(dst, Address(rscratch1, 0));
2433   }
2434 }
2435 
2436 void MacroAssembler::movdbl(XMMRegister dst, AddressLiteral src) {
2437   if (reachable(src)) {
2438     if (UseXmmLoadAndClearUpper) {
2439       movsd (dst, as_Address(src));
2440     } else {
2441       movlpd(dst, as_Address(src));
2442     }
2443   } else {
2444     lea(rscratch1, src);
2445     if (UseXmmLoadAndClearUpper) {
2446       movsd (dst, Address(rscratch1, 0));
2447     } else {
2448       movlpd(dst, Address(rscratch1, 0));
2449     }
2450   }
2451 }
2452 
2453 void MacroAssembler::movflt(XMMRegister dst, AddressLiteral src) {
2454   if (reachable(src)) {
2455     movss(dst, as_Address(src));
2456   } else {
2457     lea(rscratch1, src);
2458     movss(dst, Address(rscratch1, 0));
2459   }
2460 }
2461 
2462 void MacroAssembler::movptr(Register dst, Register src) {
2463   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2464 }
2465 
2466 void MacroAssembler::movptr(Register dst, Address src) {
2467   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2468 }
2469 
2470 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
2471 void MacroAssembler::movptr(Register dst, intptr_t src) {
2472   LP64_ONLY(mov64(dst, src)) NOT_LP64(movl(dst, src));
2473 }
2474 
2475 void MacroAssembler::movptr(Address dst, Register src) {
2476   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2477 }
2478 
2479 void MacroAssembler::movdqu(Address dst, XMMRegister src) {
2480     assert(((src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2481     Assembler::movdqu(dst, src);
2482 }
2483 
2484 void MacroAssembler::movdqu(XMMRegister dst, Address src) {
2485     assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2486     Assembler::movdqu(dst, src);
2487 }
2488 
2489 void MacroAssembler::movdqu(XMMRegister dst, XMMRegister src) {
2490     assert(((dst-&gt;encoding() &lt; 16  &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2491     Assembler::movdqu(dst, src);
2492 }
2493 
2494 void MacroAssembler::movdqu(XMMRegister dst, AddressLiteral src, Register scratchReg) {
2495   if (reachable(src)) {
2496     movdqu(dst, as_Address(src));
2497   } else {
2498     lea(scratchReg, src);
2499     movdqu(dst, Address(scratchReg, 0));
2500   }
2501 }
2502 
2503 void MacroAssembler::vmovdqu(Address dst, XMMRegister src) {
2504     assert(((src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2505     Assembler::vmovdqu(dst, src);
2506 }
2507 
2508 void MacroAssembler::vmovdqu(XMMRegister dst, Address src) {
2509     assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2510     Assembler::vmovdqu(dst, src);
2511 }
2512 
2513 void MacroAssembler::vmovdqu(XMMRegister dst, XMMRegister src) {
2514     assert(((dst-&gt;encoding() &lt; 16  &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2515     Assembler::vmovdqu(dst, src);
2516 }
2517 
2518 void MacroAssembler::vmovdqu(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
2519   if (reachable(src)) {
2520     vmovdqu(dst, as_Address(src));
2521   }
2522   else {
2523     lea(scratch_reg, src);
2524     vmovdqu(dst, Address(scratch_reg, 0));
2525   }
2526 }
2527 
2528 void MacroAssembler::evmovdquq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {
2529   if (reachable(src)) {
2530     Assembler::evmovdquq(dst, as_Address(src), vector_len);
2531   } else {
2532     lea(rscratch, src);
2533     Assembler::evmovdquq(dst, Address(rscratch, 0), vector_len);
2534   }
2535 }
2536 
2537 void MacroAssembler::movdqa(XMMRegister dst, AddressLiteral src) {
2538   if (reachable(src)) {
2539     Assembler::movdqa(dst, as_Address(src));
2540   } else {
2541     lea(rscratch1, src);
2542     Assembler::movdqa(dst, Address(rscratch1, 0));
2543   }
2544 }
2545 
2546 void MacroAssembler::movsd(XMMRegister dst, AddressLiteral src) {
2547   if (reachable(src)) {
2548     Assembler::movsd(dst, as_Address(src));
2549   } else {
2550     lea(rscratch1, src);
2551     Assembler::movsd(dst, Address(rscratch1, 0));
2552   }
2553 }
2554 
2555 void MacroAssembler::movss(XMMRegister dst, AddressLiteral src) {
2556   if (reachable(src)) {
2557     Assembler::movss(dst, as_Address(src));
2558   } else {
2559     lea(rscratch1, src);
2560     Assembler::movss(dst, Address(rscratch1, 0));
2561   }
2562 }
2563 
2564 void MacroAssembler::mulsd(XMMRegister dst, AddressLiteral src) {
2565   if (reachable(src)) {
2566     Assembler::mulsd(dst, as_Address(src));
2567   } else {
2568     lea(rscratch1, src);
2569     Assembler::mulsd(dst, Address(rscratch1, 0));
2570   }
2571 }
2572 
2573 void MacroAssembler::mulss(XMMRegister dst, AddressLiteral src) {
2574   if (reachable(src)) {
2575     Assembler::mulss(dst, as_Address(src));
2576   } else {
2577     lea(rscratch1, src);
2578     Assembler::mulss(dst, Address(rscratch1, 0));
2579   }
2580 }
2581 
2582 void MacroAssembler::null_check(Register reg, int offset) {
2583   if (needs_explicit_null_check(offset)) {
2584     // provoke OS NULL exception if reg = NULL by
2585     // accessing M[reg] w/o changing any (non-CC) registers
2586     // NOTE: cmpl is plenty here to provoke a segv
2587     cmpptr(rax, Address(reg, 0));
2588     // Note: should probably use testl(rax, Address(reg, 0));
2589     //       may be shorter code (however, this version of
2590     //       testl needs to be implemented first)
2591   } else {
2592     // nothing to do, (later) access of M[reg + offset]
2593     // will provoke OS NULL exception if reg = NULL
2594   }
2595 }
2596 
2597 void MacroAssembler::os_breakpoint() {
2598   // instead of directly emitting a breakpoint, call os:breakpoint for better debugability
2599   // (e.g., MSVC can&#39;t call ps() otherwise)
2600   call(RuntimeAddress(CAST_FROM_FN_PTR(address, os::breakpoint)));
2601 }
2602 
2603 void MacroAssembler::unimplemented(const char* what) {
2604   const char* buf = NULL;
2605   {
2606     ResourceMark rm;
2607     stringStream ss;
2608     ss.print(&quot;unimplemented: %s&quot;, what);
2609     buf = code_string(ss.as_string());
2610   }
2611   stop(buf);
2612 }
2613 
2614 #ifdef _LP64
2615 #define XSTATE_BV 0x200
2616 #endif
2617 
2618 void MacroAssembler::pop_CPU_state() {
2619   pop_FPU_state();
2620   pop_IU_state();
2621 }
2622 
2623 void MacroAssembler::pop_FPU_state() {
2624 #ifndef _LP64
2625   frstor(Address(rsp, 0));
2626 #else
2627   fxrstor(Address(rsp, 0));
2628 #endif
2629   addptr(rsp, FPUStateSizeInWords * wordSize);
2630 }
2631 
2632 void MacroAssembler::pop_IU_state() {
2633   popa();
2634   LP64_ONLY(addq(rsp, 8));
2635   popf();
2636 }
2637 
2638 // Save Integer and Float state
2639 // Warning: Stack must be 16 byte aligned (64bit)
2640 void MacroAssembler::push_CPU_state() {
2641   push_IU_state();
2642   push_FPU_state();
2643 }
2644 
2645 void MacroAssembler::push_FPU_state() {
2646   subptr(rsp, FPUStateSizeInWords * wordSize);
2647 #ifndef _LP64
2648   fnsave(Address(rsp, 0));
2649   fwait();
2650 #else
2651   fxsave(Address(rsp, 0));
2652 #endif // LP64
2653 }
2654 
2655 void MacroAssembler::push_IU_state() {
2656   // Push flags first because pusha kills them
2657   pushf();
2658   // Make sure rsp stays 16-byte aligned
2659   LP64_ONLY(subq(rsp, 8));
2660   pusha();
2661 }
2662 
2663 void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
2664   reset_last_Java_frame(r15_thread, clear_fp);
2665 }
2666 
2667 void MacroAssembler::reset_last_Java_frame(Register java_thread, bool clear_fp) { // determine java_thread register
2668   if (!java_thread-&gt;is_valid()) {
2669     java_thread = rdi;
2670     get_thread(java_thread);
2671   }
2672   // we must set sp to zero to clear frame
2673   movslq(Address(java_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
2674   // must clear fp, so that compiled frames are not confused; it is
2675   // possible that we need it only for debugging
2676   if (clear_fp) {
2677     movslq(Address(java_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
2678   }
2679   // Always clear the pc because it could have been set by make_walkable()
2680   movslq(Address(java_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
2681   movslq(Address(java_thread, JavaThread::saved_rbp_address_offset()), NULL_WORD);
2682   vzeroupper();
2683 }
2684 
2685 void MacroAssembler::restore_rax(Register tmp) {
2686   if (tmp == noreg) pop(rax);
2687   else if (tmp != rax) mov(rax, tmp);
2688 }
2689 
2690 void MacroAssembler::round_to(Register reg, int modulus) {
2691   addptr(reg, modulus - 1);
2692   andptr(reg, -modulus);
2693 }
2694 
2695 void MacroAssembler::save_rax(Register tmp) {
2696   if (tmp == noreg) push(rax);
2697   else if (tmp != rax) mov(tmp, rax);
2698 }
2699 
2700 void MacroAssembler::safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg) {
2701 #ifdef _LP64
2702   assert(thread_reg == r15_thread, &quot;should be&quot;);
2703 #else
2704   if (thread_reg == noreg) {
2705     thread_reg = temp_reg;
2706     get_thread(thread_reg);
2707   }
2708 #endif
2709   testb(Address(thread_reg, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2710   jcc(Assembler::notZero, slow_path); // handshake bit set implies poll
2711 }
2712 
2713 // Calls to C land
2714 //
2715 // When entering C land, the rbp, &amp; rsp of the last Java frame have to be recorded
2716 // in the (thread-local) JavaThread object. When leaving C land, the last Java fp
2717 // has to be reset to 0. This is required to allow proper stack traversal.
2718 void MacroAssembler::set_last_Java_frame(Register java_thread,
2719                                          Register last_java_sp,
2720                                          Register last_java_fp,
2721                                          address  last_java_pc) {
2722   vzeroupper();
2723   // determine java_thread register
2724   if (!java_thread-&gt;is_valid()) {
2725     java_thread = rdi;
2726     get_thread(java_thread);
2727   }
2728   // determine last_java_sp register
2729   if (!last_java_sp-&gt;is_valid()) {
2730     last_java_sp = rsp;
2731   }
2732 
2733   // last_java_fp is optional
2734 
2735   if (last_java_fp-&gt;is_valid()) {
2736     movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), last_java_fp);
2737   }
2738 
2739   // last_java_pc is optional
2740 
2741   if (last_java_pc != NULL) {
2742     lea(Address(java_thread,
2743                  JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset()),
2744         InternalAddress(last_java_pc));
2745 
2746   }
2747   movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), last_java_sp);
2748 }
2749 
2750 void MacroAssembler::shlptr(Register dst, int imm8) {
2751   LP64_ONLY(shlq(dst, imm8)) NOT_LP64(shll(dst, imm8));
2752 }
2753 
2754 void MacroAssembler::shrptr(Register dst, int imm8) {
2755   LP64_ONLY(shrq(dst, imm8)) NOT_LP64(shrl(dst, imm8));
2756 }
2757 
2758 void MacroAssembler::sign_extend_byte(Register reg) {
2759   if (LP64_ONLY(true ||) (VM_Version::is_P6() &amp;&amp; reg-&gt;has_byte_register())) {
2760     movsbl(reg, reg); // movsxb
2761   } else {
2762     shll(reg, 24);
2763     sarl(reg, 24);
2764   }
2765 }
2766 
2767 void MacroAssembler::sign_extend_short(Register reg) {
2768   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2769     movswl(reg, reg); // movsxw
2770   } else {
2771     shll(reg, 16);
2772     sarl(reg, 16);
2773   }
2774 }
2775 
2776 void MacroAssembler::testl(Register dst, AddressLiteral src) {
2777   assert(reachable(src), &quot;Address should be reachable&quot;);
2778   testl(dst, as_Address(src));
2779 }
2780 
2781 void MacroAssembler::pcmpeqb(XMMRegister dst, XMMRegister src) {
2782   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2783   Assembler::pcmpeqb(dst, src);
2784 }
2785 
2786 void MacroAssembler::pcmpeqw(XMMRegister dst, XMMRegister src) {
2787   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2788   Assembler::pcmpeqw(dst, src);
2789 }
2790 
2791 void MacroAssembler::pcmpestri(XMMRegister dst, Address src, int imm8) {
2792   assert((dst-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2793   Assembler::pcmpestri(dst, src, imm8);
2794 }
2795 
2796 void MacroAssembler::pcmpestri(XMMRegister dst, XMMRegister src, int imm8) {
2797   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2798   Assembler::pcmpestri(dst, src, imm8);
2799 }
2800 
2801 void MacroAssembler::pmovzxbw(XMMRegister dst, XMMRegister src) {
2802   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2803   Assembler::pmovzxbw(dst, src);
2804 }
2805 
2806 void MacroAssembler::pmovzxbw(XMMRegister dst, Address src) {
2807   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2808   Assembler::pmovzxbw(dst, src);
2809 }
2810 
2811 void MacroAssembler::pmovmskb(Register dst, XMMRegister src) {
2812   assert((src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2813   Assembler::pmovmskb(dst, src);
2814 }
2815 
2816 void MacroAssembler::ptest(XMMRegister dst, XMMRegister src) {
2817   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2818   Assembler::ptest(dst, src);
2819 }
2820 
2821 void MacroAssembler::sqrtsd(XMMRegister dst, AddressLiteral src) {
2822   if (reachable(src)) {
2823     Assembler::sqrtsd(dst, as_Address(src));
2824   } else {
2825     lea(rscratch1, src);
2826     Assembler::sqrtsd(dst, Address(rscratch1, 0));
2827   }
2828 }
2829 
2830 void MacroAssembler::sqrtss(XMMRegister dst, AddressLiteral src) {
2831   if (reachable(src)) {
2832     Assembler::sqrtss(dst, as_Address(src));
2833   } else {
2834     lea(rscratch1, src);
2835     Assembler::sqrtss(dst, Address(rscratch1, 0));
2836   }
2837 }
2838 
2839 void MacroAssembler::subsd(XMMRegister dst, AddressLiteral src) {
2840   if (reachable(src)) {
2841     Assembler::subsd(dst, as_Address(src));
2842   } else {
2843     lea(rscratch1, src);
2844     Assembler::subsd(dst, Address(rscratch1, 0));
2845   }
2846 }
2847 
2848 void MacroAssembler::roundsd(XMMRegister dst, AddressLiteral src, int32_t rmode, Register scratch_reg) {
2849   if (reachable(src)) {
2850     Assembler::roundsd(dst, as_Address(src), rmode);
2851   } else {
2852     lea(scratch_reg, src);
2853     Assembler::roundsd(dst, Address(scratch_reg, 0), rmode);
2854   }
2855 }
2856 
2857 void MacroAssembler::subss(XMMRegister dst, AddressLiteral src) {
2858   if (reachable(src)) {
2859     Assembler::subss(dst, as_Address(src));
2860   } else {
2861     lea(rscratch1, src);
2862     Assembler::subss(dst, Address(rscratch1, 0));
2863   }
2864 }
2865 
2866 void MacroAssembler::ucomisd(XMMRegister dst, AddressLiteral src) {
2867   if (reachable(src)) {
2868     Assembler::ucomisd(dst, as_Address(src));
2869   } else {
2870     lea(rscratch1, src);
2871     Assembler::ucomisd(dst, Address(rscratch1, 0));
2872   }
2873 }
2874 
2875 void MacroAssembler::ucomiss(XMMRegister dst, AddressLiteral src) {
2876   if (reachable(src)) {
2877     Assembler::ucomiss(dst, as_Address(src));
2878   } else {
2879     lea(rscratch1, src);
2880     Assembler::ucomiss(dst, Address(rscratch1, 0));
2881   }
2882 }
2883 
2884 void MacroAssembler::xorpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
2885   // Used in sign-bit flipping with aligned address.
2886   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
2887   if (reachable(src)) {
2888     Assembler::xorpd(dst, as_Address(src));
2889   } else {
2890     lea(scratch_reg, src);
2891     Assembler::xorpd(dst, Address(scratch_reg, 0));
2892   }
2893 }
2894 
2895 void MacroAssembler::xorpd(XMMRegister dst, XMMRegister src) {
2896   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512dq() &amp;&amp; (dst-&gt;encoding() == src-&gt;encoding())) {
2897     Assembler::vpxor(dst, dst, src, Assembler::AVX_512bit);
2898   }
2899   else {
2900     Assembler::xorpd(dst, src);
2901   }
2902 }
2903 
2904 void MacroAssembler::xorps(XMMRegister dst, XMMRegister src) {
2905   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512dq() &amp;&amp; (dst-&gt;encoding() == src-&gt;encoding())) {
2906     Assembler::vpxor(dst, dst, src, Assembler::AVX_512bit);
2907   } else {
2908     Assembler::xorps(dst, src);
2909   }
2910 }
2911 
2912 void MacroAssembler::xorps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
2913   // Used in sign-bit flipping with aligned address.
2914   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
2915   if (reachable(src)) {
2916     Assembler::xorps(dst, as_Address(src));
2917   } else {
2918     lea(scratch_reg, src);
2919     Assembler::xorps(dst, Address(scratch_reg, 0));
2920   }
2921 }
2922 
2923 void MacroAssembler::pshufb(XMMRegister dst, AddressLiteral src) {
2924   // Used in sign-bit flipping with aligned address.
2925   bool aligned_adr = (((intptr_t)src.target() &amp; 15) == 0);
2926   assert((UseAVX &gt; 0) || aligned_adr, &quot;SSE mode requires address alignment 16 bytes&quot;);
2927   if (reachable(src)) {
2928     Assembler::pshufb(dst, as_Address(src));
2929   } else {
2930     lea(rscratch1, src);
2931     Assembler::pshufb(dst, Address(rscratch1, 0));
2932   }
2933 }
2934 
2935 // AVX 3-operands instructions
2936 
2937 void MacroAssembler::vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
2938   if (reachable(src)) {
2939     vaddsd(dst, nds, as_Address(src));
2940   } else {
2941     lea(rscratch1, src);
2942     vaddsd(dst, nds, Address(rscratch1, 0));
2943   }
2944 }
2945 
2946 void MacroAssembler::vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
2947   if (reachable(src)) {
2948     vaddss(dst, nds, as_Address(src));
2949   } else {
2950     lea(rscratch1, src);
2951     vaddss(dst, nds, Address(rscratch1, 0));
2952   }
2953 }
2954 
2955 void MacroAssembler::vpaddd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {
2956   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
2957   if (reachable(src)) {
2958     Assembler::vpaddd(dst, nds, as_Address(src), vector_len);
2959   } else {
2960     lea(rscratch, src);
2961     Assembler::vpaddd(dst, nds, Address(rscratch, 0), vector_len);
2962   }
2963 }
2964 
2965 void MacroAssembler::vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {
2966   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
2967   vandps(dst, nds, negate_field, vector_len);
2968 }
2969 
2970 void MacroAssembler::vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {
2971   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
2972   vandpd(dst, nds, negate_field, vector_len);
2973 }
2974 
2975 void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
2976   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2977   Assembler::vpaddb(dst, nds, src, vector_len);
2978 }
2979 
2980 void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
2981   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2982   Assembler::vpaddb(dst, nds, src, vector_len);
2983 }
2984 
2985 void MacroAssembler::vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
2986   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2987   Assembler::vpaddw(dst, nds, src, vector_len);
2988 }
2989 
2990 void MacroAssembler::vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
2991   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2992   Assembler::vpaddw(dst, nds, src, vector_len);
2993 }
2994 
2995 void MacroAssembler::vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
2996   if (reachable(src)) {
2997     Assembler::vpand(dst, nds, as_Address(src), vector_len);
2998   } else {
2999     lea(scratch_reg, src);
3000     Assembler::vpand(dst, nds, Address(scratch_reg, 0), vector_len);
3001   }
3002 }
3003 
3004 void MacroAssembler::vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len) {
3005   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3006   Assembler::vpbroadcastw(dst, src, vector_len);
3007 }
3008 
3009 void MacroAssembler::vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3010   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3011   Assembler::vpcmpeqb(dst, nds, src, vector_len);
3012 }
3013 
3014 void MacroAssembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3015   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3016   Assembler::vpcmpeqw(dst, nds, src, vector_len);
3017 }
3018 
3019 void MacroAssembler::vpmovzxbw(XMMRegister dst, Address src, int vector_len) {
3020   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3021   Assembler::vpmovzxbw(dst, src, vector_len);
3022 }
3023 
3024 void MacroAssembler::vpmovmskb(Register dst, XMMRegister src) {
3025   assert((src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
3026   Assembler::vpmovmskb(dst, src);
3027 }
3028 
3029 void MacroAssembler::vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3030   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3031   Assembler::vpmullw(dst, nds, src, vector_len);
3032 }
3033 
3034 void MacroAssembler::vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3035   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3036   Assembler::vpmullw(dst, nds, src, vector_len);
3037 }
3038 
3039 void MacroAssembler::vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3040   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3041   Assembler::vpsubb(dst, nds, src, vector_len);
3042 }
3043 
3044 void MacroAssembler::vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3045   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3046   Assembler::vpsubb(dst, nds, src, vector_len);
3047 }
3048 
3049 void MacroAssembler::vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3050   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3051   Assembler::vpsubw(dst, nds, src, vector_len);
3052 }
3053 
3054 void MacroAssembler::vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3055   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3056   Assembler::vpsubw(dst, nds, src, vector_len);
3057 }
3058 
3059 void MacroAssembler::vpsraw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3060   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3061   Assembler::vpsraw(dst, nds, shift, vector_len);
3062 }
3063 
3064 void MacroAssembler::vpsraw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3065   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3066   Assembler::vpsraw(dst, nds, shift, vector_len);
3067 }
3068 
3069 void MacroAssembler::evpsraq(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3070   assert(UseAVX &gt; 2,&quot;&quot;);
3071   if (!VM_Version::supports_avx512vl() &amp;&amp; vector_len &lt; 2) {
3072      vector_len = 2;
3073   }
3074   Assembler::evpsraq(dst, nds, shift, vector_len);
3075 }
3076 
3077 void MacroAssembler::evpsraq(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3078   assert(UseAVX &gt; 2,&quot;&quot;);
3079   if (!VM_Version::supports_avx512vl() &amp;&amp; vector_len &lt; 2) {
3080      vector_len = 2;
3081   }
3082   Assembler::evpsraq(dst, nds, shift, vector_len);
3083 }
3084 
3085 void MacroAssembler::vpsrlw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3086   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3087   Assembler::vpsrlw(dst, nds, shift, vector_len);
3088 }
3089 
3090 void MacroAssembler::vpsrlw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3091   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3092   Assembler::vpsrlw(dst, nds, shift, vector_len);
3093 }
3094 
3095 void MacroAssembler::vpsllw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3096   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3097   Assembler::vpsllw(dst, nds, shift, vector_len);
3098 }
3099 
3100 void MacroAssembler::vpsllw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3101   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3102   Assembler::vpsllw(dst, nds, shift, vector_len);
3103 }
3104 
3105 void MacroAssembler::vptest(XMMRegister dst, XMMRegister src) {
3106   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
3107   Assembler::vptest(dst, src);
3108 }
3109 
3110 void MacroAssembler::punpcklbw(XMMRegister dst, XMMRegister src) {
3111   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3112   Assembler::punpcklbw(dst, src);
3113 }
3114 
3115 void MacroAssembler::pshufd(XMMRegister dst, Address src, int mode) {
3116   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
3117   Assembler::pshufd(dst, src, mode);
3118 }
3119 
3120 void MacroAssembler::pshuflw(XMMRegister dst, XMMRegister src, int mode) {
3121   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3122   Assembler::pshuflw(dst, src, mode);
3123 }
3124 
3125 void MacroAssembler::vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3126   if (reachable(src)) {
3127     vandpd(dst, nds, as_Address(src), vector_len);
3128   } else {
3129     lea(scratch_reg, src);
3130     vandpd(dst, nds, Address(scratch_reg, 0), vector_len);
3131   }
3132 }
3133 
3134 void MacroAssembler::vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3135   if (reachable(src)) {
3136     vandps(dst, nds, as_Address(src), vector_len);
3137   } else {
3138     lea(scratch_reg, src);
3139     vandps(dst, nds, Address(scratch_reg, 0), vector_len);
3140   }
3141 }
3142 
3143 void MacroAssembler::vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3144   if (reachable(src)) {
3145     vdivsd(dst, nds, as_Address(src));
3146   } else {
3147     lea(rscratch1, src);
3148     vdivsd(dst, nds, Address(rscratch1, 0));
3149   }
3150 }
3151 
3152 void MacroAssembler::vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3153   if (reachable(src)) {
3154     vdivss(dst, nds, as_Address(src));
3155   } else {
3156     lea(rscratch1, src);
3157     vdivss(dst, nds, Address(rscratch1, 0));
3158   }
3159 }
3160 
3161 void MacroAssembler::vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3162   if (reachable(src)) {
3163     vmulsd(dst, nds, as_Address(src));
3164   } else {
3165     lea(rscratch1, src);
3166     vmulsd(dst, nds, Address(rscratch1, 0));
3167   }
3168 }
3169 
3170 void MacroAssembler::vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3171   if (reachable(src)) {
3172     vmulss(dst, nds, as_Address(src));
3173   } else {
3174     lea(rscratch1, src);
3175     vmulss(dst, nds, Address(rscratch1, 0));
3176   }
3177 }
3178 
3179 void MacroAssembler::vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3180   if (reachable(src)) {
3181     vsubsd(dst, nds, as_Address(src));
3182   } else {
3183     lea(rscratch1, src);
3184     vsubsd(dst, nds, Address(rscratch1, 0));
3185   }
3186 }
3187 
3188 void MacroAssembler::vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3189   if (reachable(src)) {
3190     vsubss(dst, nds, as_Address(src));
3191   } else {
3192     lea(rscratch1, src);
3193     vsubss(dst, nds, Address(rscratch1, 0));
3194   }
3195 }
3196 
3197 void MacroAssembler::vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3198   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3199   vxorps(dst, nds, src, Assembler::AVX_128bit);
3200 }
3201 
3202 void MacroAssembler::vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3203   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3204   vxorpd(dst, nds, src, Assembler::AVX_128bit);
3205 }
3206 
3207 void MacroAssembler::vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3208   if (reachable(src)) {
3209     vxorpd(dst, nds, as_Address(src), vector_len);
3210   } else {
3211     lea(scratch_reg, src);
3212     vxorpd(dst, nds, Address(scratch_reg, 0), vector_len);
3213   }
3214 }
3215 
3216 void MacroAssembler::vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3217   if (reachable(src)) {
3218     vxorps(dst, nds, as_Address(src), vector_len);
3219   } else {
3220     lea(scratch_reg, src);
3221     vxorps(dst, nds, Address(scratch_reg, 0), vector_len);
3222   }
3223 }
3224 
3225 void MacroAssembler::vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3226   if (UseAVX &gt; 1 || (vector_len &lt; 1)) {
3227     if (reachable(src)) {
3228       Assembler::vpxor(dst, nds, as_Address(src), vector_len);
3229     } else {
3230       lea(scratch_reg, src);
3231       Assembler::vpxor(dst, nds, Address(scratch_reg, 0), vector_len);
3232     }
3233   }
3234   else {
3235     MacroAssembler::vxorpd(dst, nds, src, vector_len, scratch_reg);
3236   }
3237 }
3238 
3239 //-------------------------------------------------------------------------------------------
3240 
3241 void MacroAssembler::clear_jweak_tag(Register possibly_jweak) {
3242   const int32_t inverted_jweak_mask = ~static_cast&lt;int32_t&gt;(JNIHandles::weak_tag_mask);
3243   STATIC_ASSERT(inverted_jweak_mask == -2); // otherwise check this code
3244   // The inverted mask is sign-extended
3245   andptr(possibly_jweak, inverted_jweak_mask);
3246 }
3247 
3248 void MacroAssembler::resolve_jobject(Register value,
3249                                      Register thread,
3250                                      Register tmp) {
3251   assert_different_registers(value, thread, tmp);
3252   Label done, not_weak;
3253   testptr(value, value);
3254   jcc(Assembler::zero, done);                // Use NULL as-is.
3255   testptr(value, JNIHandles::weak_tag_mask); // Test for jweak tag.
3256   jcc(Assembler::zero, not_weak);
3257   // Resolve jweak.
3258   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
3259                  value, Address(value, -JNIHandles::weak_tag_value), tmp, thread);
3260   verify_oop(value);
3261   jmp(done);
3262   bind(not_weak);
3263   // Resolve (untagged) jobject.
3264   access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);
3265   verify_oop(value);
3266   bind(done);
3267 }
3268 
3269 void MacroAssembler::subptr(Register dst, int32_t imm32) {
3270   LP64_ONLY(subq(dst, imm32)) NOT_LP64(subl(dst, imm32));
3271 }
3272 
3273 // Force generation of a 4 byte immediate value even if it fits into 8bit
3274 void MacroAssembler::subptr_imm32(Register dst, int32_t imm32) {
3275   LP64_ONLY(subq_imm32(dst, imm32)) NOT_LP64(subl_imm32(dst, imm32));
3276 }
3277 
3278 void MacroAssembler::subptr(Register dst, Register src) {
3279   LP64_ONLY(subq(dst, src)) NOT_LP64(subl(dst, src));
3280 }
3281 
3282 // C++ bool manipulation
3283 void MacroAssembler::testbool(Register dst) {
3284   if(sizeof(bool) == 1)
3285     testb(dst, 0xff);
3286   else if(sizeof(bool) == 2) {
3287     // testw implementation needed for two byte bools
3288     ShouldNotReachHere();
3289   } else if(sizeof(bool) == 4)
3290     testl(dst, dst);
3291   else
3292     // unsupported
3293     ShouldNotReachHere();
3294 }
3295 
3296 void MacroAssembler::testptr(Register dst, Register src) {
3297   LP64_ONLY(testq(dst, src)) NOT_LP64(testl(dst, src));
3298 }
3299 
3300 // Defines obj, preserves var_size_in_bytes, okay for t2 == var_size_in_bytes.
3301 void MacroAssembler::tlab_allocate(Register thread, Register obj,
3302                                    Register var_size_in_bytes,
3303                                    int con_size_in_bytes,
3304                                    Register t1,
3305                                    Register t2,
3306                                    Label&amp; slow_case) {
3307   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3308   bs-&gt;tlab_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);
3309 }
3310 
3311 // Defines obj, preserves var_size_in_bytes
3312 void MacroAssembler::eden_allocate(Register thread, Register obj,
3313                                    Register var_size_in_bytes,
3314                                    int con_size_in_bytes,
3315                                    Register t1,
3316                                    Label&amp; slow_case) {
3317   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3318   bs-&gt;eden_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, slow_case);
3319 }
3320 
3321 // Preserves the contents of address, destroys the contents length_in_bytes and temp.
3322 void MacroAssembler::zero_memory(Register address, Register length_in_bytes, int offset_in_bytes, Register temp) {
3323   assert(address != length_in_bytes &amp;&amp; address != temp &amp;&amp; temp != length_in_bytes, &quot;registers must be different&quot;);
3324   assert((offset_in_bytes &amp; (BytesPerWord - 1)) == 0, &quot;offset must be a multiple of BytesPerWord&quot;);
3325   Label done;
3326 
3327   testptr(length_in_bytes, length_in_bytes);
3328   jcc(Assembler::zero, done);
3329 
3330   // initialize topmost word, divide index by 2, check if odd and test if zero
3331   // note: for the remaining code to work, index must be a multiple of BytesPerWord
3332 #ifdef ASSERT
3333   {
3334     Label L;
3335     testptr(length_in_bytes, BytesPerWord - 1);
3336     jcc(Assembler::zero, L);
3337     stop(&quot;length must be a multiple of BytesPerWord&quot;);
3338     bind(L);
3339   }
3340 #endif
3341   Register index = length_in_bytes;
3342   xorptr(temp, temp);    // use _zero reg to clear memory (shorter code)
3343   if (UseIncDec) {
3344     shrptr(index, 3);  // divide by 8/16 and set carry flag if bit 2 was set
3345   } else {
3346     shrptr(index, 2);  // use 2 instructions to avoid partial flag stall
3347     shrptr(index, 1);
3348   }
3349 #ifndef _LP64
3350   // index could have not been a multiple of 8 (i.e., bit 2 was set)
3351   {
3352     Label even;
3353     // note: if index was a multiple of 8, then it cannot
3354     //       be 0 now otherwise it must have been 0 before
3355     //       =&gt; if it is even, we don&#39;t need to check for 0 again
3356     jcc(Assembler::carryClear, even);
3357     // clear topmost word (no jump would be needed if conditional assignment worked here)
3358     movptr(Address(address, index, Address::times_8, offset_in_bytes - 0*BytesPerWord), temp);
3359     // index could be 0 now, must check again
3360     jcc(Assembler::zero, done);
3361     bind(even);
3362   }
3363 #endif // !_LP64
3364   // initialize remaining object fields: index is a multiple of 2 now
3365   {
3366     Label loop;
3367     bind(loop);
3368     movptr(Address(address, index, Address::times_8, offset_in_bytes - 1*BytesPerWord), temp);
3369     NOT_LP64(movptr(Address(address, index, Address::times_8, offset_in_bytes - 2*BytesPerWord), temp);)
3370     decrement(index);
3371     jcc(Assembler::notZero, loop);
3372   }
3373 
3374   bind(done);
3375 }
3376 
3377 // Look up the method for a megamorphic invokeinterface call.
3378 // The target method is determined by &lt;intf_klass, itable_index&gt;.
3379 // The receiver klass is in recv_klass.
3380 // On success, the result will be in method_result, and execution falls through.
3381 // On failure, execution transfers to the given label.
3382 void MacroAssembler::lookup_interface_method(Register recv_klass,
3383                                              Register intf_klass,
3384                                              RegisterOrConstant itable_index,
3385                                              Register method_result,
3386                                              Register scan_temp,
3387                                              Label&amp; L_no_such_interface,
3388                                              bool return_method) {
3389   assert_different_registers(recv_klass, intf_klass, scan_temp);
3390   assert_different_registers(method_result, intf_klass, scan_temp);
3391   assert(recv_klass != method_result || !return_method,
3392          &quot;recv_klass can be destroyed when method isn&#39;t needed&quot;);
3393 
3394   assert(itable_index.is_constant() || itable_index.as_register() == method_result,
3395          &quot;caller must use same register for non-constant itable index as for method&quot;);
3396 
3397   // Compute start of first itableOffsetEntry (which is at the end of the vtable)
3398   int vtable_base = in_bytes(Klass::vtable_start_offset());
3399   int itentry_off = itableMethodEntry::method_offset_in_bytes();
3400   int scan_step   = itableOffsetEntry::size() * wordSize;
3401   int vte_size    = vtableEntry::size_in_bytes();
3402   Address::ScaleFactor times_vte_scale = Address::times_ptr;
3403   assert(vte_size == wordSize, &quot;else adjust times_vte_scale&quot;);
3404 
3405   movl(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));
3406 
3407   // %%% Could store the aligned, prescaled offset in the klassoop.
3408   lea(scan_temp, Address(recv_klass, scan_temp, times_vte_scale, vtable_base));
3409 
3410   if (return_method) {
3411     // Adjust recv_klass by scaled itable_index, so we can free itable_index.
3412     assert(itableMethodEntry::size() * wordSize == wordSize, &quot;adjust the scaling in the code below&quot;);
3413     lea(recv_klass, Address(recv_klass, itable_index, Address::times_ptr, itentry_off));
3414   }
3415 
3416   // for (scan = klass-&gt;itable(); scan-&gt;interface() != NULL; scan += scan_step) {
3417   //   if (scan-&gt;interface() == intf) {
3418   //     result = (klass + scan-&gt;offset() + itable_index);
3419   //   }
3420   // }
3421   Label search, found_method;
3422 
3423   for (int peel = 1; peel &gt;= 0; peel--) {
3424     movptr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));
3425     cmpptr(intf_klass, method_result);
3426 
3427     if (peel) {
3428       jccb(Assembler::equal, found_method);
3429     } else {
3430       jccb(Assembler::notEqual, search);
3431       // (invert the test to fall through to found_method...)
3432     }
3433 
3434     if (!peel)  break;
3435 
3436     bind(search);
3437 
3438     // Check that the previous entry is non-null.  A null entry means that
3439     // the receiver class doesn&#39;t implement the interface, and wasn&#39;t the
3440     // same as when the caller was compiled.
3441     testptr(method_result, method_result);
3442     jcc(Assembler::zero, L_no_such_interface);
3443     addptr(scan_temp, scan_step);
3444   }
3445 
3446   bind(found_method);
3447 
3448   if (return_method) {
3449     // Got a hit.
3450     movl(scan_temp, Address(scan_temp, itableOffsetEntry::offset_offset_in_bytes()));
3451     movptr(method_result, Address(recv_klass, scan_temp, Address::times_1));
3452   }
3453 }
3454 
3455 
3456 // virtual method calling
3457 void MacroAssembler::lookup_virtual_method(Register recv_klass,
3458                                            RegisterOrConstant vtable_index,
3459                                            Register method_result) {
3460   const int base = in_bytes(Klass::vtable_start_offset());
3461   assert(vtableEntry::size() * wordSize == wordSize, &quot;else adjust the scaling in the code below&quot;);
3462   Address vtable_entry_addr(recv_klass,
3463                             vtable_index, Address::times_ptr,
3464                             base + vtableEntry::method_offset_in_bytes());
3465   movptr(method_result, vtable_entry_addr);
3466 }
3467 
3468 
3469 void MacroAssembler::check_klass_subtype(Register sub_klass,
3470                            Register super_klass,
3471                            Register temp_reg,
3472                            Label&amp; L_success) {
3473   Label L_failure;
3474   check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &amp;L_success, &amp;L_failure, NULL);
3475   check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &amp;L_success, NULL);
3476   bind(L_failure);
3477 }
3478 
3479 
3480 void MacroAssembler::check_klass_subtype_fast_path(Register sub_klass,
3481                                                    Register super_klass,
3482                                                    Register temp_reg,
3483                                                    Label* L_success,
3484                                                    Label* L_failure,
3485                                                    Label* L_slow_path,
3486                                         RegisterOrConstant super_check_offset) {
3487   assert_different_registers(sub_klass, super_klass, temp_reg);
3488   bool must_load_sco = (super_check_offset.constant_or_zero() == -1);
3489   if (super_check_offset.is_register()) {
3490     assert_different_registers(sub_klass, super_klass,
3491                                super_check_offset.as_register());
3492   } else if (must_load_sco) {
3493     assert(temp_reg != noreg, &quot;supply either a temp or a register offset&quot;);
3494   }
3495 
3496   Label L_fallthrough;
3497   int label_nulls = 0;
3498   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
3499   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
3500   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
3501   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
3502 
3503   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
3504   int sco_offset = in_bytes(Klass::super_check_offset_offset());
3505   Address super_check_offset_addr(super_klass, sco_offset);
3506 
3507   // Hacked jcc, which &quot;knows&quot; that L_fallthrough, at least, is in
3508   // range of a jccb.  If this routine grows larger, reconsider at
3509   // least some of these.
3510 #define local_jcc(assembler_cond, label)                                \
3511   if (&amp;(label) == &amp;L_fallthrough)  jccb(assembler_cond, label);         \
3512   else                             jcc( assembler_cond, label) /*omit semi*/
3513 
3514   // Hacked jmp, which may only be used just before L_fallthrough.
3515 #define final_jmp(label)                                                \
3516   if (&amp;(label) == &amp;L_fallthrough) { /*do nothing*/ }                    \
3517   else                            jmp(label)                /*omit semi*/
3518 
3519   // If the pointers are equal, we are done (e.g., String[] elements).
3520   // This self-check enables sharing of secondary supertype arrays among
3521   // non-primary types such as array-of-interface.  Otherwise, each such
3522   // type would need its own customized SSA.
3523   // We move this check to the front of the fast path because many
3524   // type checks are in fact trivially successful in this manner,
3525   // so we get a nicely predicted branch right at the start of the check.
3526   cmpptr(sub_klass, super_klass);
3527   local_jcc(Assembler::equal, *L_success);
3528 
3529   // Check the supertype display:
3530   if (must_load_sco) {
3531     // Positive movl does right thing on LP64.
3532     movl(temp_reg, super_check_offset_addr);
3533     super_check_offset = RegisterOrConstant(temp_reg);
3534   }
3535   Address super_check_addr(sub_klass, super_check_offset, Address::times_1, 0);
3536   cmpptr(super_klass, super_check_addr); // load displayed supertype
3537 
3538   // This check has worked decisively for primary supers.
3539   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
3540   // (Secondary supers are interfaces and very deeply nested subtypes.)
3541   // This works in the same check above because of a tricky aliasing
3542   // between the super_cache and the primary super display elements.
3543   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
3544   // Note that the cache is updated below if it does not help us find
3545   // what we need immediately.
3546   // So if it was a primary super, we can just fail immediately.
3547   // Otherwise, it&#39;s the slow path for us (no success at this point).
3548 
3549   if (super_check_offset.is_register()) {
3550     local_jcc(Assembler::equal, *L_success);
3551     cmpl(super_check_offset.as_register(), sc_offset);
3552     if (L_failure == &amp;L_fallthrough) {
3553       local_jcc(Assembler::equal, *L_slow_path);
3554     } else {
3555       local_jcc(Assembler::notEqual, *L_failure);
3556       final_jmp(*L_slow_path);
3557     }
3558   } else if (super_check_offset.as_constant() == sc_offset) {
3559     // Need a slow path; fast failure is impossible.
3560     if (L_slow_path == &amp;L_fallthrough) {
3561       local_jcc(Assembler::equal, *L_success);
3562     } else {
3563       local_jcc(Assembler::notEqual, *L_slow_path);
3564       final_jmp(*L_success);
3565     }
3566   } else {
3567     // No slow path; it&#39;s a fast decision.
3568     if (L_failure == &amp;L_fallthrough) {
3569       local_jcc(Assembler::equal, *L_success);
3570     } else {
3571       local_jcc(Assembler::notEqual, *L_failure);
3572       final_jmp(*L_success);
3573     }
3574   }
3575 
3576   bind(L_fallthrough);
3577 
3578 #undef local_jcc
3579 #undef final_jmp
3580 }
3581 
3582 
3583 void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,
3584                                                    Register super_klass,
3585                                                    Register temp_reg,
3586                                                    Register temp2_reg,
3587                                                    Label* L_success,
3588                                                    Label* L_failure,
3589                                                    bool set_cond_codes) {
3590   assert_different_registers(sub_klass, super_klass, temp_reg);
3591   if (temp2_reg != noreg)
3592     assert_different_registers(sub_klass, super_klass, temp_reg, temp2_reg);
3593 #define IS_A_TEMP(reg) ((reg) == temp_reg || (reg) == temp2_reg)
3594 
3595   Label L_fallthrough;
3596   int label_nulls = 0;
3597   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
3598   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
3599   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
3600 
3601   // a couple of useful fields in sub_klass:
3602   int ss_offset = in_bytes(Klass::secondary_supers_offset());
3603   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
3604   Address secondary_supers_addr(sub_klass, ss_offset);
3605   Address super_cache_addr(     sub_klass, sc_offset);
3606 
3607   // Do a linear scan of the secondary super-klass chain.
3608   // This code is rarely used, so simplicity is a virtue here.
3609   // The repne_scan instruction uses fixed registers, which we must spill.
3610   // Don&#39;t worry too much about pre-existing connections with the input regs.
3611 
3612   assert(sub_klass != rax, &quot;killed reg&quot;); // killed by mov(rax, super)
3613   assert(sub_klass != rcx, &quot;killed reg&quot;); // killed by lea(rcx, &amp;pst_counter)
3614 
3615   // Get super_klass value into rax (even if it was in rdi or rcx).
3616   bool pushed_rax = false, pushed_rcx = false, pushed_rdi = false;
3617   if (super_klass != rax || UseCompressedOops) {
3618     if (!IS_A_TEMP(rax)) { push(rax); pushed_rax = true; }
3619     mov(rax, super_klass);
3620   }
3621   if (!IS_A_TEMP(rcx)) { push(rcx); pushed_rcx = true; }
3622   if (!IS_A_TEMP(rdi)) { push(rdi); pushed_rdi = true; }
3623 
3624 #ifndef PRODUCT
3625   int* pst_counter = &amp;SharedRuntime::_partial_subtype_ctr;
3626   ExternalAddress pst_counter_addr((address) pst_counter);
3627   NOT_LP64(  incrementl(pst_counter_addr) );
3628   LP64_ONLY( lea(rcx, pst_counter_addr) );
3629   LP64_ONLY( incrementl(Address(rcx, 0)) );
3630 #endif //PRODUCT
3631 
3632   // We will consult the secondary-super array.
3633   movptr(rdi, secondary_supers_addr);
3634   // Load the array length.  (Positive movl does right thing on LP64.)
3635   movl(rcx, Address(rdi, Array&lt;Klass*&gt;::length_offset_in_bytes()));
3636   // Skip to start of data.
3637   addptr(rdi, Array&lt;Klass*&gt;::base_offset_in_bytes());
3638 
3639   // Scan RCX words at [RDI] for an occurrence of RAX.
3640   // Set NZ/Z based on last compare.
3641   // Z flag value will not be set by &#39;repne&#39; if RCX == 0 since &#39;repne&#39; does
3642   // not change flags (only scas instruction which is repeated sets flags).
3643   // Set Z = 0 (not equal) before &#39;repne&#39; to indicate that class was not found.
3644 
3645     testptr(rax,rax); // Set Z = 0
3646     repne_scan();
3647 
3648   // Unspill the temp. registers:
3649   if (pushed_rdi)  pop(rdi);
3650   if (pushed_rcx)  pop(rcx);
3651   if (pushed_rax)  pop(rax);
3652 
3653   if (set_cond_codes) {
3654     // Special hack for the AD files:  rdi is guaranteed non-zero.
3655     assert(!pushed_rdi, &quot;rdi must be left non-NULL&quot;);
3656     // Also, the condition codes are properly set Z/NZ on succeed/failure.
3657   }
3658 
3659   if (L_failure == &amp;L_fallthrough)
3660         jccb(Assembler::notEqual, *L_failure);
3661   else  jcc(Assembler::notEqual, *L_failure);
3662 
3663   // Success.  Cache the super we found and proceed in triumph.
3664   movptr(super_cache_addr, super_klass);
3665 
3666   if (L_success != &amp;L_fallthrough) {
3667     jmp(*L_success);
3668   }
3669 
3670 #undef IS_A_TEMP
3671 
3672   bind(L_fallthrough);
3673 }
3674 
3675 void MacroAssembler::clinit_barrier(Register klass, Register thread, Label* L_fast_path, Label* L_slow_path) {
3676   assert(L_fast_path != NULL || L_slow_path != NULL, &quot;at least one is required&quot;);
3677 
3678   Label L_fallthrough;
3679   if (L_fast_path == NULL) {
3680     L_fast_path = &amp;L_fallthrough;
3681   } else if (L_slow_path == NULL) {
3682     L_slow_path = &amp;L_fallthrough;
3683   }
3684 
3685   // Fast path check: class is fully initialized
3686   cmpb(Address(klass, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
3687   jcc(Assembler::equal, *L_fast_path);
3688 
3689   // Fast path check: current thread is initializer thread
3690   cmpptr(thread, Address(klass, InstanceKlass::init_thread_offset()));
3691   if (L_slow_path == &amp;L_fallthrough) {
3692     jcc(Assembler::equal, *L_fast_path);
3693     bind(*L_slow_path);
3694   } else if (L_fast_path == &amp;L_fallthrough) {
3695     jcc(Assembler::notEqual, *L_slow_path);
3696     bind(*L_fast_path);
3697   } else {
3698     Unimplemented();
3699   }
3700 }
3701 
3702 void MacroAssembler::cmov32(Condition cc, Register dst, Address src) {
3703   if (VM_Version::supports_cmov()) {
3704     cmovl(cc, dst, src);
3705   } else {
3706     Label L;
3707     jccb(negate_condition(cc), L);
3708     movl(dst, src);
3709     bind(L);
3710   }
3711 }
3712 
3713 void MacroAssembler::cmov32(Condition cc, Register dst, Register src) {
3714   if (VM_Version::supports_cmov()) {
3715     cmovl(cc, dst, src);
3716   } else {
3717     Label L;
3718     jccb(negate_condition(cc), L);
3719     movl(dst, src);
3720     bind(L);
3721   }
3722 }
3723 
3724 void MacroAssembler::_verify_oop(Register reg, const char* s, const char* file, int line) {
3725   if (!VerifyOops) return;
3726 
3727   // Pass register number to verify_oop_subroutine
3728   const char* b = NULL;
3729   {
3730     ResourceMark rm;
3731     stringStream ss;
3732     ss.print(&quot;verify_oop: %s: %s (%s:%d)&quot;, reg-&gt;name(), s, file, line);
3733     b = code_string(ss.as_string());
3734   }
3735   BLOCK_COMMENT(&quot;verify_oop {&quot;);
3736 #ifdef _LP64
3737   push(rscratch1);                    // save r10, trashed by movptr()
3738 #endif
3739   push(rax);                          // save rax,
3740   push(reg);                          // pass register argument
3741   ExternalAddress buffer((address) b);
3742   // avoid using pushptr, as it modifies scratch registers
3743   // and our contract is not to modify anything
3744   movptr(rax, buffer.addr());
3745   push(rax);
3746   // call indirectly to solve generation ordering problem
3747   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
3748   call(rax);
3749   // Caller pops the arguments (oop, message) and restores rax, r10
3750   BLOCK_COMMENT(&quot;} verify_oop&quot;);
3751 }
3752 
3753 void MacroAssembler::vallones(XMMRegister dst, int vector_len) {
3754   if (UseAVX &gt; 2 &amp;&amp; (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl())) {
3755     vpternlogd(dst, 0xFF, dst, dst, vector_len);
3756   } else {
3757     assert(UseAVX &gt; 0, &quot;&quot;);
3758     vpcmpeqb(dst, dst, dst, vector_len);
3759   }
3760 }
3761 
3762 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
3763                                                       Register tmp,
3764                                                       int offset) {
3765   intptr_t value = *delayed_value_addr;
3766   if (value != 0)
3767     return RegisterOrConstant(value + offset);
3768 
3769   // load indirectly to solve generation ordering problem
3770   movptr(tmp, ExternalAddress((address) delayed_value_addr));
3771 
3772 #ifdef ASSERT
3773   { Label L;
3774     testptr(tmp, tmp);
3775     if (WizardMode) {
3776       const char* buf = NULL;
3777       {
3778         ResourceMark rm;
3779         stringStream ss;
3780         ss.print(&quot;DelayedValue=&quot; INTPTR_FORMAT, delayed_value_addr[1]);
3781         buf = code_string(ss.as_string());
3782       }
3783       jcc(Assembler::notZero, L);
3784       STOP(buf);
3785     } else {
3786       jccb(Assembler::notZero, L);
3787       hlt();
3788     }
3789     bind(L);
3790   }
3791 #endif
3792 
3793   if (offset != 0)
3794     addptr(tmp, offset);
3795 
3796   return RegisterOrConstant(tmp);
3797 }
3798 
3799 
3800 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
3801                                          int extra_slot_offset) {
3802   // cf. TemplateTable::prepare_invoke(), if (load_receiver).
3803   int stackElementSize = Interpreter::stackElementSize;
3804   int offset = Interpreter::expr_offset_in_bytes(extra_slot_offset+0);
3805 #ifdef ASSERT
3806   int offset1 = Interpreter::expr_offset_in_bytes(extra_slot_offset+1);
3807   assert(offset1 - offset == stackElementSize, &quot;correct arithmetic&quot;);
3808 #endif
3809   Register             scale_reg    = noreg;
3810   Address::ScaleFactor scale_factor = Address::no_scale;
3811   if (arg_slot.is_constant()) {
3812     offset += arg_slot.as_constant() * stackElementSize;
3813   } else {
3814     scale_reg    = arg_slot.as_register();
3815     scale_factor = Address::times(stackElementSize);
3816   }
3817   offset += wordSize;           // return PC is on stack
3818   return Address(rsp, scale_reg, scale_factor, offset);
3819 }
3820 
3821 
3822 void MacroAssembler::_verify_oop_addr(Address addr, const char* s, const char* file, int line) {
3823   if (!VerifyOops) return;
3824 
3825   // Address adjust(addr.base(), addr.index(), addr.scale(), addr.disp() + BytesPerWord);
3826   // Pass register number to verify_oop_subroutine
3827   const char* b = NULL;
3828   {
3829     ResourceMark rm;
3830     stringStream ss;
3831     ss.print(&quot;verify_oop_addr: %s (%s:%d)&quot;, s, file, line);
3832     b = code_string(ss.as_string());
3833   }
3834 #ifdef _LP64
3835   push(rscratch1);                    // save r10, trashed by movptr()
3836 #endif
3837   push(rax);                          // save rax,
3838   // addr may contain rsp so we will have to adjust it based on the push
3839   // we just did (and on 64 bit we do two pushes)
3840   // NOTE: 64bit seemed to have had a bug in that it did movq(addr, rax); which
3841   // stores rax into addr which is backwards of what was intended.
3842   if (addr.uses(rsp)) {
3843     lea(rax, addr);
3844     pushptr(Address(rax, LP64_ONLY(2 *) BytesPerWord));
3845   } else {
3846     pushptr(addr);
3847   }
3848 
3849   ExternalAddress buffer((address) b);
3850   // pass msg argument
3851   // avoid using pushptr, as it modifies scratch registers
3852   // and our contract is not to modify anything
3853   movptr(rax, buffer.addr());
3854   push(rax);
3855 
3856   // call indirectly to solve generation ordering problem
3857   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
3858   call(rax);
3859   // Caller pops the arguments (addr, message) and restores rax, r10.
3860 }
3861 
3862 void MacroAssembler::verify_tlab() {
3863 #ifdef ASSERT
3864   if (UseTLAB &amp;&amp; VerifyOops) {
3865     Label next, ok;
3866     Register t1 = rsi;
3867     Register thread_reg = NOT_LP64(rbx) LP64_ONLY(r15_thread);
3868 
3869     push(t1);
3870     NOT_LP64(push(thread_reg));
3871     NOT_LP64(get_thread(thread_reg));
3872 
3873     movptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_top_offset())));
3874     cmpptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_start_offset())));
3875     jcc(Assembler::aboveEqual, next);
3876     STOP(&quot;assert(top &gt;= start)&quot;);
3877     should_not_reach_here();
3878 
3879     bind(next);
3880     movptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_end_offset())));
3881     cmpptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_top_offset())));
3882     jcc(Assembler::aboveEqual, ok);
3883     STOP(&quot;assert(top &lt;= end)&quot;);
3884     should_not_reach_here();
3885 
3886     bind(ok);
3887     NOT_LP64(pop(thread_reg));
3888     pop(t1);
3889   }
3890 #endif
3891 }
3892 
3893 class ControlWord {
3894  public:
3895   int32_t _value;
3896 
3897   int  rounding_control() const        { return  (_value &gt;&gt; 10) &amp; 3      ; }
3898   int  precision_control() const       { return  (_value &gt;&gt;  8) &amp; 3      ; }
3899   bool precision() const               { return ((_value &gt;&gt;  5) &amp; 1) != 0; }
3900   bool underflow() const               { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
3901   bool overflow() const                { return ((_value &gt;&gt;  3) &amp; 1) != 0; }
3902   bool zero_divide() const             { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
3903   bool denormalized() const            { return ((_value &gt;&gt;  1) &amp; 1) != 0; }
3904   bool invalid() const                 { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
3905 
3906   void print() const {
3907     // rounding control
3908     const char* rc;
3909     switch (rounding_control()) {
3910       case 0: rc = &quot;round near&quot;; break;
3911       case 1: rc = &quot;round down&quot;; break;
3912       case 2: rc = &quot;round up  &quot;; break;
3913       case 3: rc = &quot;chop      &quot;; break;
3914     };
3915     // precision control
3916     const char* pc;
3917     switch (precision_control()) {
3918       case 0: pc = &quot;24 bits &quot;; break;
3919       case 1: pc = &quot;reserved&quot;; break;
3920       case 2: pc = &quot;53 bits &quot;; break;
3921       case 3: pc = &quot;64 bits &quot;; break;
3922     };
3923     // flags
3924     char f[9];
3925     f[0] = &#39; &#39;;
3926     f[1] = &#39; &#39;;
3927     f[2] = (precision   ()) ? &#39;P&#39; : &#39;p&#39;;
3928     f[3] = (underflow   ()) ? &#39;U&#39; : &#39;u&#39;;
3929     f[4] = (overflow    ()) ? &#39;O&#39; : &#39;o&#39;;
3930     f[5] = (zero_divide ()) ? &#39;Z&#39; : &#39;z&#39;;
3931     f[6] = (denormalized()) ? &#39;D&#39; : &#39;d&#39;;
3932     f[7] = (invalid     ()) ? &#39;I&#39; : &#39;i&#39;;
3933     f[8] = &#39;\x0&#39;;
3934     // output
3935     printf(&quot;%04x  masks = %s, %s, %s&quot;, _value &amp; 0xFFFF, f, rc, pc);
3936   }
3937 
3938 };
3939 
3940 class StatusWord {
3941  public:
3942   int32_t _value;
3943 
3944   bool busy() const                    { return ((_value &gt;&gt; 15) &amp; 1) != 0; }
3945   bool C3() const                      { return ((_value &gt;&gt; 14) &amp; 1) != 0; }
3946   bool C2() const                      { return ((_value &gt;&gt; 10) &amp; 1) != 0; }
3947   bool C1() const                      { return ((_value &gt;&gt;  9) &amp; 1) != 0; }
3948   bool C0() const                      { return ((_value &gt;&gt;  8) &amp; 1) != 0; }
3949   int  top() const                     { return  (_value &gt;&gt; 11) &amp; 7      ; }
3950   bool error_status() const            { return ((_value &gt;&gt;  7) &amp; 1) != 0; }
3951   bool stack_fault() const             { return ((_value &gt;&gt;  6) &amp; 1) != 0; }
3952   bool precision() const               { return ((_value &gt;&gt;  5) &amp; 1) != 0; }
3953   bool underflow() const               { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
3954   bool overflow() const                { return ((_value &gt;&gt;  3) &amp; 1) != 0; }
3955   bool zero_divide() const             { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
3956   bool denormalized() const            { return ((_value &gt;&gt;  1) &amp; 1) != 0; }
3957   bool invalid() const                 { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
3958 
3959   void print() const {
3960     // condition codes
3961     char c[5];
3962     c[0] = (C3()) ? &#39;3&#39; : &#39;-&#39;;
3963     c[1] = (C2()) ? &#39;2&#39; : &#39;-&#39;;
3964     c[2] = (C1()) ? &#39;1&#39; : &#39;-&#39;;
3965     c[3] = (C0()) ? &#39;0&#39; : &#39;-&#39;;
3966     c[4] = &#39;\x0&#39;;
3967     // flags
3968     char f[9];
3969     f[0] = (error_status()) ? &#39;E&#39; : &#39;-&#39;;
3970     f[1] = (stack_fault ()) ? &#39;S&#39; : &#39;-&#39;;
3971     f[2] = (precision   ()) ? &#39;P&#39; : &#39;-&#39;;
3972     f[3] = (underflow   ()) ? &#39;U&#39; : &#39;-&#39;;
3973     f[4] = (overflow    ()) ? &#39;O&#39; : &#39;-&#39;;
3974     f[5] = (zero_divide ()) ? &#39;Z&#39; : &#39;-&#39;;
3975     f[6] = (denormalized()) ? &#39;D&#39; : &#39;-&#39;;
3976     f[7] = (invalid     ()) ? &#39;I&#39; : &#39;-&#39;;
3977     f[8] = &#39;\x0&#39;;
3978     // output
3979     printf(&quot;%04x  flags = %s, cc =  %s, top = %d&quot;, _value &amp; 0xFFFF, f, c, top());
3980   }
3981 
3982 };
3983 
3984 class TagWord {
3985  public:
3986   int32_t _value;
3987 
3988   int tag_at(int i) const              { return (_value &gt;&gt; (i*2)) &amp; 3; }
3989 
3990   void print() const {
3991     printf(&quot;%04x&quot;, _value &amp; 0xFFFF);
3992   }
3993 
3994 };
3995 
3996 class FPU_Register {
3997  public:
3998   int32_t _m0;
3999   int32_t _m1;
4000   int16_t _ex;
4001 
4002   bool is_indefinite() const           {
4003     return _ex == -1 &amp;&amp; _m1 == (int32_t)0xC0000000 &amp;&amp; _m0 == 0;
4004   }
4005 
4006   void print() const {
4007     char  sign = (_ex &lt; 0) ? &#39;-&#39; : &#39;+&#39;;
4008     const char* kind = (_ex == 0x7FFF || _ex == (int16_t)-1) ? &quot;NaN&quot; : &quot;   &quot;;
4009     printf(&quot;%c%04hx.%08x%08x  %s&quot;, sign, _ex, _m1, _m0, kind);
4010   };
4011 
4012 };
4013 
4014 class FPU_State {
4015  public:
4016   enum {
4017     register_size       = 10,
4018     number_of_registers =  8,
4019     register_mask       =  7
4020   };
4021 
4022   ControlWord  _control_word;
4023   StatusWord   _status_word;
4024   TagWord      _tag_word;
4025   int32_t      _error_offset;
4026   int32_t      _error_selector;
4027   int32_t      _data_offset;
4028   int32_t      _data_selector;
4029   int8_t       _register[register_size * number_of_registers];
4030 
4031   int tag_for_st(int i) const          { return _tag_word.tag_at((_status_word.top() + i) &amp; register_mask); }
4032   FPU_Register* st(int i) const        { return (FPU_Register*)&amp;_register[register_size * i]; }
4033 
4034   const char* tag_as_string(int tag) const {
4035     switch (tag) {
4036       case 0: return &quot;valid&quot;;
4037       case 1: return &quot;zero&quot;;
4038       case 2: return &quot;special&quot;;
4039       case 3: return &quot;empty&quot;;
4040     }
4041     ShouldNotReachHere();
4042     return NULL;
4043   }
4044 
4045   void print() const {
4046     // print computation registers
4047     { int t = _status_word.top();
4048       for (int i = 0; i &lt; number_of_registers; i++) {
4049         int j = (i - t) &amp; register_mask;
4050         printf(&quot;%c r%d = ST%d = &quot;, (j == 0 ? &#39;*&#39; : &#39; &#39;), i, j);
4051         st(j)-&gt;print();
4052         printf(&quot; %s\n&quot;, tag_as_string(_tag_word.tag_at(i)));
4053       }
4054     }
4055     printf(&quot;\n&quot;);
4056     // print control registers
4057     printf(&quot;ctrl = &quot;); _control_word.print(); printf(&quot;\n&quot;);
4058     printf(&quot;stat = &quot;); _status_word .print(); printf(&quot;\n&quot;);
4059     printf(&quot;tags = &quot;); _tag_word    .print(); printf(&quot;\n&quot;);
4060   }
4061 
4062 };
4063 
4064 class Flag_Register {
4065  public:
4066   int32_t _value;
4067 
4068   bool overflow() const                { return ((_value &gt;&gt; 11) &amp; 1) != 0; }
4069   bool direction() const               { return ((_value &gt;&gt; 10) &amp; 1) != 0; }
4070   bool sign() const                    { return ((_value &gt;&gt;  7) &amp; 1) != 0; }
4071   bool zero() const                    { return ((_value &gt;&gt;  6) &amp; 1) != 0; }
4072   bool auxiliary_carry() const         { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
4073   bool parity() const                  { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
4074   bool carry() const                   { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
4075 
4076   void print() const {
4077     // flags
4078     char f[8];
4079     f[0] = (overflow       ()) ? &#39;O&#39; : &#39;-&#39;;
4080     f[1] = (direction      ()) ? &#39;D&#39; : &#39;-&#39;;
4081     f[2] = (sign           ()) ? &#39;S&#39; : &#39;-&#39;;
4082     f[3] = (zero           ()) ? &#39;Z&#39; : &#39;-&#39;;
4083     f[4] = (auxiliary_carry()) ? &#39;A&#39; : &#39;-&#39;;
4084     f[5] = (parity         ()) ? &#39;P&#39; : &#39;-&#39;;
4085     f[6] = (carry          ()) ? &#39;C&#39; : &#39;-&#39;;
4086     f[7] = &#39;\x0&#39;;
4087     // output
4088     printf(&quot;%08x  flags = %s&quot;, _value, f);
4089   }
4090 
4091 };
4092 
4093 class IU_Register {
4094  public:
4095   int32_t _value;
4096 
4097   void print() const {
4098     printf(&quot;%08x  %11d&quot;, _value, _value);
4099   }
4100 
4101 };
4102 
4103 class IU_State {
4104  public:
4105   Flag_Register _eflags;
4106   IU_Register   _rdi;
4107   IU_Register   _rsi;
4108   IU_Register   _rbp;
4109   IU_Register   _rsp;
4110   IU_Register   _rbx;
4111   IU_Register   _rdx;
4112   IU_Register   _rcx;
4113   IU_Register   _rax;
4114 
4115   void print() const {
4116     // computation registers
4117     printf(&quot;rax,  = &quot;); _rax.print(); printf(&quot;\n&quot;);
4118     printf(&quot;rbx,  = &quot;); _rbx.print(); printf(&quot;\n&quot;);
4119     printf(&quot;rcx  = &quot;); _rcx.print(); printf(&quot;\n&quot;);
4120     printf(&quot;rdx  = &quot;); _rdx.print(); printf(&quot;\n&quot;);
4121     printf(&quot;rdi  = &quot;); _rdi.print(); printf(&quot;\n&quot;);
4122     printf(&quot;rsi  = &quot;); _rsi.print(); printf(&quot;\n&quot;);
4123     printf(&quot;rbp,  = &quot;); _rbp.print(); printf(&quot;\n&quot;);
4124     printf(&quot;rsp  = &quot;); _rsp.print(); printf(&quot;\n&quot;);
4125     printf(&quot;\n&quot;);
4126     // control registers
4127     printf(&quot;flgs = &quot;); _eflags.print(); printf(&quot;\n&quot;);
4128   }
4129 };
4130 
4131 
4132 class CPU_State {
4133  public:
4134   FPU_State _fpu_state;
4135   IU_State  _iu_state;
4136 
4137   void print() const {
4138     printf(&quot;--------------------------------------------------\n&quot;);
4139     _iu_state .print();
4140     printf(&quot;\n&quot;);
4141     _fpu_state.print();
4142     printf(&quot;--------------------------------------------------\n&quot;);
4143   }
4144 
4145 };
4146 
4147 
4148 static void _print_CPU_state(CPU_State* state) {
4149   state-&gt;print();
4150 };
4151 
4152 
4153 void MacroAssembler::print_CPU_state() {
4154   push_CPU_state();
4155   push(rsp);                // pass CPU state
4156   call(RuntimeAddress(CAST_FROM_FN_PTR(address, _print_CPU_state)));
4157   addptr(rsp, wordSize);       // discard argument
4158   pop_CPU_state();
4159 }
4160 
4161 
4162 #ifndef _LP64
4163 static bool _verify_FPU(int stack_depth, char* s, CPU_State* state) {
4164   static int counter = 0;
4165   FPU_State* fs = &amp;state-&gt;_fpu_state;
4166   counter++;
4167   // For leaf calls, only verify that the top few elements remain empty.
4168   // We only need 1 empty at the top for C2 code.
4169   if( stack_depth &lt; 0 ) {
4170     if( fs-&gt;tag_for_st(7) != 3 ) {
4171       printf(&quot;FPR7 not empty\n&quot;);
4172       state-&gt;print();
4173       assert(false, &quot;error&quot;);
4174       return false;
4175     }
4176     return true;                // All other stack states do not matter
4177   }
4178 
4179   assert((fs-&gt;_control_word._value &amp; 0xffff) == StubRoutines::_fpu_cntrl_wrd_std,
4180          &quot;bad FPU control word&quot;);
4181 
4182   // compute stack depth
4183   int i = 0;
4184   while (i &lt; FPU_State::number_of_registers &amp;&amp; fs-&gt;tag_for_st(i)  &lt; 3) i++;
4185   int d = i;
4186   while (i &lt; FPU_State::number_of_registers &amp;&amp; fs-&gt;tag_for_st(i) == 3) i++;
4187   // verify findings
4188   if (i != FPU_State::number_of_registers) {
4189     // stack not contiguous
4190     printf(&quot;%s: stack not contiguous at ST%d\n&quot;, s, i);
4191     state-&gt;print();
4192     assert(false, &quot;error&quot;);
4193     return false;
4194   }
4195   // check if computed stack depth corresponds to expected stack depth
4196   if (stack_depth &lt; 0) {
4197     // expected stack depth is -stack_depth or less
4198     if (d &gt; -stack_depth) {
4199       // too many elements on the stack
4200       printf(&quot;%s: &lt;= %d stack elements expected but found %d\n&quot;, s, -stack_depth, d);
4201       state-&gt;print();
4202       assert(false, &quot;error&quot;);
4203       return false;
4204     }
4205   } else {
4206     // expected stack depth is stack_depth
4207     if (d != stack_depth) {
4208       // wrong stack depth
4209       printf(&quot;%s: %d stack elements expected but found %d\n&quot;, s, stack_depth, d);
4210       state-&gt;print();
4211       assert(false, &quot;error&quot;);
4212       return false;
4213     }
4214   }
4215   // everything is cool
4216   return true;
4217 }
4218 
4219 void MacroAssembler::verify_FPU(int stack_depth, const char* s) {
4220   if (!VerifyFPU) return;
4221   push_CPU_state();
4222   push(rsp);                // pass CPU state
4223   ExternalAddress msg((address) s);
4224   // pass message string s
4225   pushptr(msg.addr());
4226   push(stack_depth);        // pass stack depth
4227   call(RuntimeAddress(CAST_FROM_FN_PTR(address, _verify_FPU)));
4228   addptr(rsp, 3 * wordSize);   // discard arguments
4229   // check for error
4230   { Label L;
4231     testl(rax, rax);
4232     jcc(Assembler::notZero, L);
4233     int3();                  // break if error condition
4234     bind(L);
4235   }
4236   pop_CPU_state();
4237 }
4238 #endif // _LP64
4239 
4240 void MacroAssembler::restore_cpu_control_state_after_jni() {
4241   // Either restore the MXCSR register after returning from the JNI Call
4242   // or verify that it wasn&#39;t changed (with -Xcheck:jni flag).
4243   if (VM_Version::supports_sse()) {
4244     if (RestoreMXCSROnJNICalls) {
4245       ldmxcsr(ExternalAddress(StubRoutines::addr_mxcsr_std()));
4246     } else if (CheckJNICalls) {
4247       call(RuntimeAddress(StubRoutines::x86::verify_mxcsr_entry()));
4248     }
4249   }
4250   // Clear upper bits of YMM registers to avoid SSE &lt;-&gt; AVX transition penalty.
4251   vzeroupper();
4252   // Reset k1 to 0xffff.
4253 
4254 #ifdef COMPILER2
4255   if (PostLoopMultiversioning &amp;&amp; VM_Version::supports_evex()) {
4256     push(rcx);
4257     movl(rcx, 0xffff);
4258     kmovwl(k1, rcx);
4259     pop(rcx);
4260   }
4261 #endif // COMPILER2
4262 
4263 #ifndef _LP64
4264   // Either restore the x87 floating pointer control word after returning
4265   // from the JNI call or verify that it wasn&#39;t changed.
4266   if (CheckJNICalls) {
4267     call(RuntimeAddress(StubRoutines::x86::verify_fpu_cntrl_wrd_entry()));
4268   }
4269 #endif // _LP64
4270 }
4271 
4272 // ((OopHandle)result).resolve();
4273 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
4274   assert_different_registers(result, tmp);
4275 
4276   // Only 64 bit platforms support GCs that require a tmp register
4277   // Only IN_HEAP loads require a thread_tmp register
4278   // OopHandle::resolve is an indirection like jobject.
4279   access_load_at(T_OBJECT, IN_NATIVE,
4280                  result, Address(result, 0), tmp, /*tmp_thread*/noreg);
4281 }
4282 
4283 // ((WeakHandle)result).resolve();
4284 void MacroAssembler::resolve_weak_handle(Register rresult, Register rtmp) {
4285   assert_different_registers(rresult, rtmp);
4286   Label resolved;
4287 
4288   // A null weak handle resolves to null.
4289   cmpptr(rresult, 0);
4290   jcc(Assembler::equal, resolved);
4291 
4292   // Only 64 bit platforms support GCs that require a tmp register
4293   // Only IN_HEAP loads require a thread_tmp register
4294   // WeakHandle::resolve is an indirection like jweak.
4295   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
4296                  rresult, Address(rresult, 0), rtmp, /*tmp_thread*/noreg);
4297   bind(resolved);
4298 }
4299 
4300 void MacroAssembler::load_mirror(Register mirror, Register method, Register tmp) {
4301   // get mirror
4302   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
4303   load_method_holder(mirror, method);
4304   movptr(mirror, Address(mirror, mirror_offset));
4305   resolve_oop_handle(mirror, tmp);
4306 }
4307 
4308 void MacroAssembler::load_method_holder_cld(Register rresult, Register rmethod) {
4309   load_method_holder(rresult, rmethod);
4310   movptr(rresult, Address(rresult, InstanceKlass::class_loader_data_offset()));
4311 }
4312 
4313 void MacroAssembler::load_method_holder(Register holder, Register method) {
4314   movptr(holder, Address(method, Method::const_offset()));                      // ConstMethod*
4315   movptr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*
4316   movptr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*
4317 }
4318 
4319 void MacroAssembler::load_klass(Register dst, Register src, Register tmp) {
4320   assert_different_registers(src, tmp);
4321   assert_different_registers(dst, tmp);
4322 #ifdef _LP64
4323   if (UseCompressedClassPointers) {
4324     movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));
4325     decode_klass_not_null(dst, tmp);
4326   } else
4327 #endif
4328     movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
4329 }
4330 
4331 void MacroAssembler::load_prototype_header(Register dst, Register src, Register tmp) {
4332   load_klass(dst, src, tmp);
4333   movptr(dst, Address(dst, Klass::prototype_header_offset()));
4334 }
4335 
4336 void MacroAssembler::store_klass(Register dst, Register src, Register tmp) {
4337   assert_different_registers(src, tmp);
4338   assert_different_registers(dst, tmp);
4339 #ifdef _LP64
4340   if (UseCompressedClassPointers) {
4341     encode_klass_not_null(src, tmp);
4342     movl(Address(dst, oopDesc::klass_offset_in_bytes()), src);
4343   } else
4344 #endif
4345     movptr(Address(dst, oopDesc::klass_offset_in_bytes()), src);
4346 }
4347 
4348 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
4349                                     Register tmp1, Register thread_tmp) {
4350   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4351   decorators = AccessInternal::decorator_fixup(decorators);
4352   bool as_raw = (decorators &amp; AS_RAW) != 0;
4353   if (as_raw) {
4354     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4355   } else {
4356     bs-&gt;load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4357   }
4358 }
4359 
4360 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
4361                                      Register tmp1, Register tmp2) {
4362   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4363   decorators = AccessInternal::decorator_fixup(decorators);
4364   bool as_raw = (decorators &amp; AS_RAW) != 0;
4365   if (as_raw) {
4366     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, tmp2);
4367   } else {
4368     bs-&gt;store_at(this, decorators, type, dst, src, tmp1, tmp2);
4369   }
4370 }
4371 
4372 void MacroAssembler::resolve(DecoratorSet decorators, Register obj) {
4373   // Use stronger ACCESS_WRITE|ACCESS_READ by default.
4374   if ((decorators &amp; (ACCESS_READ | ACCESS_WRITE)) == 0) {
4375     decorators |= ACCESS_READ | ACCESS_WRITE;
4376   }
4377   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4378   return bs-&gt;resolve(this, decorators, obj);
4379 }
4380 
4381 void MacroAssembler::load_heap_oop(Register dst, Address src, Register tmp1,
4382                                    Register thread_tmp, DecoratorSet decorators) {
4383   access_load_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);
4384 }
4385 
4386 // Doesn&#39;t do verfication, generates fixed size code
4387 void MacroAssembler::load_heap_oop_not_null(Register dst, Address src, Register tmp1,
4388                                             Register thread_tmp, DecoratorSet decorators) {
4389   access_load_at(T_OBJECT, IN_HEAP | IS_NOT_NULL | decorators, dst, src, tmp1, thread_tmp);
4390 }
4391 
4392 void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,
4393                                     Register tmp2, DecoratorSet decorators) {
4394   access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, tmp2);
4395 }
4396 
4397 // Used for storing NULLs.
4398 void MacroAssembler::store_heap_oop_null(Address dst) {
4399   access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg);
4400 }
4401 
4402 #ifdef _LP64
4403 void MacroAssembler::store_klass_gap(Register dst, Register src) {
4404   if (UseCompressedClassPointers) {
4405     // Store to klass gap in destination
4406     movl(Address(dst, oopDesc::klass_gap_offset_in_bytes()), src);
4407   }
4408 }
4409 
4410 #ifdef ASSERT
4411 void MacroAssembler::verify_heapbase(const char* msg) {
4412   assert (UseCompressedOops, &quot;should be compressed&quot;);
4413   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4414   if (CheckCompressedOops) {
4415     Label ok;
4416     push(rscratch1); // cmpptr trashes rscratch1
4417     cmpptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
4418     jcc(Assembler::equal, ok);
4419     STOP(msg);
4420     bind(ok);
4421     pop(rscratch1);
4422   }
4423 }
4424 #endif
4425 
4426 // Algorithm must match oop.inline.hpp encode_heap_oop.
4427 void MacroAssembler::encode_heap_oop(Register r) {
4428 #ifdef ASSERT
4429   verify_heapbase(&quot;MacroAssembler::encode_heap_oop: heap base corrupted?&quot;);
4430 #endif
4431   verify_oop_msg(r, &quot;broken oop in encode_heap_oop&quot;);
4432   if (CompressedOops::base() == NULL) {
4433     if (CompressedOops::shift() != 0) {
4434       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4435       shrq(r, LogMinObjAlignmentInBytes);
4436     }
4437     return;
4438   }
4439   testq(r, r);
4440   cmovq(Assembler::equal, r, r12_heapbase);
4441   subq(r, r12_heapbase);
4442   shrq(r, LogMinObjAlignmentInBytes);
4443 }
4444 
4445 void MacroAssembler::encode_heap_oop_not_null(Register r) {
4446 #ifdef ASSERT
4447   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null: heap base corrupted?&quot;);
4448   if (CheckCompressedOops) {
4449     Label ok;
4450     testq(r, r);
4451     jcc(Assembler::notEqual, ok);
4452     STOP(&quot;null oop passed to encode_heap_oop_not_null&quot;);
4453     bind(ok);
4454   }
4455 #endif
4456   verify_oop_msg(r, &quot;broken oop in encode_heap_oop_not_null&quot;);
4457   if (CompressedOops::base() != NULL) {
4458     subq(r, r12_heapbase);
4459   }
4460   if (CompressedOops::shift() != 0) {
4461     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4462     shrq(r, LogMinObjAlignmentInBytes);
4463   }
4464 }
4465 
4466 void MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {
4467 #ifdef ASSERT
4468   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null2: heap base corrupted?&quot;);
4469   if (CheckCompressedOops) {
4470     Label ok;
4471     testq(src, src);
4472     jcc(Assembler::notEqual, ok);
4473     STOP(&quot;null oop passed to encode_heap_oop_not_null2&quot;);
4474     bind(ok);
4475   }
4476 #endif
4477   verify_oop_msg(src, &quot;broken oop in encode_heap_oop_not_null2&quot;);
4478   if (dst != src) {
4479     movq(dst, src);
4480   }
4481   if (CompressedOops::base() != NULL) {
4482     subq(dst, r12_heapbase);
4483   }
4484   if (CompressedOops::shift() != 0) {
4485     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4486     shrq(dst, LogMinObjAlignmentInBytes);
4487   }
4488 }
4489 
4490 void  MacroAssembler::decode_heap_oop(Register r) {
4491 #ifdef ASSERT
4492   verify_heapbase(&quot;MacroAssembler::decode_heap_oop: heap base corrupted?&quot;);
4493 #endif
4494   if (CompressedOops::base() == NULL) {
4495     if (CompressedOops::shift() != 0) {
4496       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4497       shlq(r, LogMinObjAlignmentInBytes);
4498     }
4499   } else {
4500     Label done;
4501     shlq(r, LogMinObjAlignmentInBytes);
4502     jccb(Assembler::equal, done);
4503     addq(r, r12_heapbase);
4504     bind(done);
4505   }
4506   verify_oop_msg(r, &quot;broken oop in decode_heap_oop&quot;);
4507 }
4508 
4509 void  MacroAssembler::decode_heap_oop_not_null(Register r) {
4510   // Note: it will change flags
4511   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4512   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4513   // Cannot assert, unverified entry point counts instructions (see .ad file)
4514   // vtableStubs also counts instructions in pd_code_size_limit.
4515   // Also do not verify_oop as this is called by verify_oop.
4516   if (CompressedOops::shift() != 0) {
4517     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4518     shlq(r, LogMinObjAlignmentInBytes);
4519     if (CompressedOops::base() != NULL) {
4520       addq(r, r12_heapbase);
4521     }
4522   } else {
4523     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
4524   }
4525 }
4526 
4527 void  MacroAssembler::decode_heap_oop_not_null(Register dst, Register src) {
4528   // Note: it will change flags
4529   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4530   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4531   // Cannot assert, unverified entry point counts instructions (see .ad file)
4532   // vtableStubs also counts instructions in pd_code_size_limit.
4533   // Also do not verify_oop as this is called by verify_oop.
4534   if (CompressedOops::shift() != 0) {
4535     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4536     if (LogMinObjAlignmentInBytes == Address::times_8) {
4537       leaq(dst, Address(r12_heapbase, src, Address::times_8, 0));
4538     } else {
4539       if (dst != src) {
4540         movq(dst, src);
4541       }
4542       shlq(dst, LogMinObjAlignmentInBytes);
4543       if (CompressedOops::base() != NULL) {
4544         addq(dst, r12_heapbase);
4545       }
4546     }
4547   } else {
4548     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
4549     if (dst != src) {
4550       movq(dst, src);
4551     }
4552   }
4553 }
4554 
4555 void MacroAssembler::encode_klass_not_null(Register r, Register tmp) {
4556   assert_different_registers(r, tmp);
4557   if (CompressedKlassPointers::base() != NULL) {
4558     mov64(tmp, (int64_t)CompressedKlassPointers::base());
4559     subq(r, tmp);
4560   }
4561   if (CompressedKlassPointers::shift() != 0) {
4562     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4563     shrq(r, LogKlassAlignmentInBytes);
4564   }
4565 }
4566 
4567 void MacroAssembler::encode_and_move_klass_not_null(Register dst, Register src) {
4568   assert_different_registers(src, dst);
4569   if (CompressedKlassPointers::base() != NULL) {
4570     mov64(dst, -(int64_t)CompressedKlassPointers::base());
4571     addq(dst, src);
4572   } else {
4573     movptr(dst, src);
4574   }
4575   if (CompressedKlassPointers::shift() != 0) {
4576     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4577     shrq(dst, LogKlassAlignmentInBytes);
4578   }
4579 }
4580 
4581 // !!! If the instructions that get generated here change then function
4582 // instr_size_for_decode_klass_not_null() needs to get updated.
4583 void  MacroAssembler::decode_klass_not_null(Register r, Register tmp) {
4584   assert_different_registers(r, tmp);
4585   // Note: it will change flags
4586   assert(UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4587   // Cannot assert, unverified entry point counts instructions (see .ad file)
4588   // vtableStubs also counts instructions in pd_code_size_limit.
4589   // Also do not verify_oop as this is called by verify_oop.
4590   if (CompressedKlassPointers::shift() != 0) {
4591     assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4592     shlq(r, LogKlassAlignmentInBytes);
4593   }
4594   if (CompressedKlassPointers::base() != NULL) {
4595     mov64(tmp, (int64_t)CompressedKlassPointers::base());
4596     addq(r, tmp);
4597   }
4598 }
4599 
4600 void  MacroAssembler::decode_and_move_klass_not_null(Register dst, Register src) {
4601   assert_different_registers(src, dst);
4602   // Note: it will change flags
4603   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4604   // Cannot assert, unverified entry point counts instructions (see .ad file)
4605   // vtableStubs also counts instructions in pd_code_size_limit.
4606   // Also do not verify_oop as this is called by verify_oop.
4607 
4608   if (CompressedKlassPointers::base() == NULL &amp;&amp;
4609       CompressedKlassPointers::shift() == 0) {
4610     // The best case scenario is that there is no base or shift. Then it is already
4611     // a pointer that needs nothing but a register rename.
4612     movl(dst, src);
4613   } else {
4614     if (CompressedKlassPointers::base() != NULL) {
4615       mov64(dst, (int64_t)CompressedKlassPointers::base());
4616     } else {
4617       xorq(dst, dst);
4618     }
4619     if (CompressedKlassPointers::shift() != 0) {
4620       assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4621       assert(LogKlassAlignmentInBytes == Address::times_8, &quot;klass not aligned on 64bits?&quot;);
4622       leaq(dst, Address(dst, src, Address::times_8, 0));
4623     } else {
4624       addq(dst, src);
4625     }
4626   }
4627 }
4628 
4629 void  MacroAssembler::set_narrow_oop(Register dst, jobject obj) {
4630   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4631   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4632   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4633   int oop_index = oop_recorder()-&gt;find_index(obj);
4634   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4635   mov_narrow_oop(dst, oop_index, rspec);
4636 }
4637 
4638 void  MacroAssembler::set_narrow_oop(Address dst, jobject obj) {
4639   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4640   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4641   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4642   int oop_index = oop_recorder()-&gt;find_index(obj);
4643   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4644   mov_narrow_oop(dst, oop_index, rspec);
4645 }
4646 
4647 void  MacroAssembler::set_narrow_klass(Register dst, Klass* k) {
4648   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4649   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4650   int klass_index = oop_recorder()-&gt;find_index(k);
4651   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
4652   mov_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
4653 }
4654 
4655 void  MacroAssembler::set_narrow_klass(Address dst, Klass* k) {
4656   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4657   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4658   int klass_index = oop_recorder()-&gt;find_index(k);
4659   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
4660   mov_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
4661 }
4662 
4663 void  MacroAssembler::cmp_narrow_oop(Register dst, jobject obj) {
4664   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4665   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4666   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4667   int oop_index = oop_recorder()-&gt;find_index(obj);
4668   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4669   Assembler::cmp_narrow_oop(dst, oop_index, rspec);
4670 }
4671 
4672 void  MacroAssembler::cmp_narrow_oop(Address dst, jobject obj) {
4673   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4674   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4675   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4676   int oop_index = oop_recorder()-&gt;find_index(obj);
4677   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4678   Assembler::cmp_narrow_oop(dst, oop_index, rspec);
4679 }
4680 
4681 void  MacroAssembler::cmp_narrow_klass(Register dst, Klass* k) {
4682   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4683   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4684   int klass_index = oop_recorder()-&gt;find_index(k);
4685   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
4686   Assembler::cmp_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
4687 }
4688 
4689 void  MacroAssembler::cmp_narrow_klass(Address dst, Klass* k) {
4690   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4691   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4692   int klass_index = oop_recorder()-&gt;find_index(k);
4693   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
4694   Assembler::cmp_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
4695 }
4696 
4697 void MacroAssembler::reinit_heapbase() {
4698   if (UseCompressedOops) {
4699     if (Universe::heap() != NULL) {
4700       if (CompressedOops::base() == NULL) {
4701         MacroAssembler::xorptr(r12_heapbase, r12_heapbase);
4702       } else {
4703         mov64(r12_heapbase, (int64_t)CompressedOops::ptrs_base());
4704       }
4705     } else {
4706       movptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
4707     }
4708   }
4709 }
4710 
4711 #endif // _LP64
4712 
4713 // C2 compiled method&#39;s prolog code.
4714 void MacroAssembler::verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub) {
4715 
4716   // WARNING: Initial instruction MUST be 5 bytes or longer so that
4717   // NativeJump::patch_verified_entry will be able to patch out the entry
4718   // code safely. The push to verify stack depth is ok at 5 bytes,
4719   // the frame allocation can be either 3 or 6 bytes. So if we don&#39;t do
4720   // stack bang then we must use the 6 byte frame allocation even if
4721   // we have no frame. :-(
4722   assert(stack_bang_size &gt;= framesize || stack_bang_size &lt;= 0, &quot;stack bang size incorrect&quot;);
4723 
4724   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
4725   // Remove word for return addr
4726   framesize -= wordSize;
4727   stack_bang_size -= wordSize;
4728 
4729   // Calls to C2R adapters often do not accept exceptional returns.
4730   // We require that their callers must bang for them.  But be careful, because
4731   // some VM calls (such as call site linkage) can use several kilobytes of
4732   // stack.  But the stack safety zone should account for that.
4733   // See bugs 4446381, 4468289, 4497237.
4734   if (stack_bang_size &gt; 0) {
4735     generate_stack_overflow_check(stack_bang_size);
4736 
4737     // We always push rbp, so that on return to interpreter rbp, will be
4738     // restored correctly and we can correct the stack.
4739     push(rbp);
4740     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
4741     if (PreserveFramePointer) {
4742       mov(rbp, rsp);
4743     }
4744     // Remove word for ebp
4745     framesize -= wordSize;
4746 
4747     // Create frame
4748     if (framesize) {
4749       subptr(rsp, framesize);
4750     }
4751   } else {
4752     // Create frame (force generation of a 4 byte immediate value)
4753     subptr_imm32(rsp, framesize);
4754 
4755     // Save RBP register now.
4756     framesize -= wordSize;
4757     movptr(Address(rsp, framesize), rbp);
4758     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
4759     if (PreserveFramePointer) {
4760       movptr(rbp, rsp);
4761       if (framesize &gt; 0) {
4762         addptr(rbp, framesize);
4763       }
4764     }
4765   }
4766 
4767   if (VerifyStackAtCalls) { // Majik cookie to verify stack depth
4768     framesize -= wordSize;
4769     movptr(Address(rsp, framesize), (int32_t)0xbadb100d);
4770   }
4771 
4772 #ifndef _LP64
4773   // If method sets FPU control word do it now
4774   if (fp_mode_24b) {
4775     fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
4776   }
4777   if (UseSSE &gt;= 2 &amp;&amp; VerifyFPU) {
4778     verify_FPU(0, &quot;FPU stack must be clean on entry&quot;);
4779   }
4780 #endif
4781 
4782 #ifdef ASSERT
4783   if (VerifyStackAtCalls) {
4784     Label L;
4785     push(rax);
4786     mov(rax, rsp);
4787     andptr(rax, StackAlignmentInBytes-1);
4788     cmpptr(rax, StackAlignmentInBytes-wordSize);
4789     pop(rax);
4790     jcc(Assembler::equal, L);
4791     STOP(&quot;Stack is not properly aligned!&quot;);
4792     bind(L);
4793   }
4794 #endif
4795 
4796   if (!is_stub) {
4797     BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4798     bs-&gt;nmethod_entry_barrier(this);
4799   }
4800 }
4801 
4802 // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
4803 void MacroAssembler::xmm_clear_mem(Register base, Register cnt, XMMRegister xtmp) {
4804   // cnt - number of qwords (8-byte words).
4805   // base - start address, qword aligned.
4806   Label L_zero_64_bytes, L_loop, L_sloop, L_tail, L_end;
4807   if (UseAVX &gt;= 2) {
4808     vpxor(xtmp, xtmp, xtmp, AVX_256bit);
4809   } else {
4810     pxor(xtmp, xtmp);
4811   }
4812   jmp(L_zero_64_bytes);
4813 
4814   BIND(L_loop);
4815   if (UseAVX &gt;= 2) {
4816     vmovdqu(Address(base,  0), xtmp);
4817     vmovdqu(Address(base, 32), xtmp);
4818   } else {
4819     movdqu(Address(base,  0), xtmp);
4820     movdqu(Address(base, 16), xtmp);
4821     movdqu(Address(base, 32), xtmp);
4822     movdqu(Address(base, 48), xtmp);
4823   }
4824   addptr(base, 64);
4825 
4826   BIND(L_zero_64_bytes);
4827   subptr(cnt, 8);
4828   jccb(Assembler::greaterEqual, L_loop);
4829   addptr(cnt, 4);
4830   jccb(Assembler::less, L_tail);
4831   // Copy trailing 32 bytes
4832   if (UseAVX &gt;= 2) {
4833     vmovdqu(Address(base, 0), xtmp);
4834   } else {
4835     movdqu(Address(base,  0), xtmp);
4836     movdqu(Address(base, 16), xtmp);
4837   }
4838   addptr(base, 32);
4839   subptr(cnt, 4);
4840 
4841   BIND(L_tail);
4842   addptr(cnt, 4);
4843   jccb(Assembler::lessEqual, L_end);
4844   decrement(cnt);
4845 
4846   BIND(L_sloop);
4847   movq(Address(base, 0), xtmp);
4848   addptr(base, 8);
4849   decrement(cnt);
4850   jccb(Assembler::greaterEqual, L_sloop);
4851   BIND(L_end);
4852 }
4853 
4854 void MacroAssembler::clear_mem(Register base, Register cnt, Register tmp, XMMRegister xtmp, bool is_large) {
4855   // cnt - number of qwords (8-byte words).
4856   // base - start address, qword aligned.
4857   // is_large - if optimizers know cnt is larger than InitArrayShortSize
4858   assert(base==rdi, &quot;base register must be edi for rep stos&quot;);
4859   assert(tmp==rax,   &quot;tmp register must be eax for rep stos&quot;);
4860   assert(cnt==rcx,   &quot;cnt register must be ecx for rep stos&quot;);
4861   assert(InitArrayShortSize % BytesPerLong == 0,
4862     &quot;InitArrayShortSize should be the multiple of BytesPerLong&quot;);
4863 
4864   Label DONE;
4865 
4866   if (!is_large || !UseXMMForObjInit) {
4867     xorptr(tmp, tmp);
4868   }
4869 
4870   if (!is_large) {
4871     Label LOOP, LONG;
4872     cmpptr(cnt, InitArrayShortSize/BytesPerLong);
4873     jccb(Assembler::greater, LONG);
4874 
4875     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
4876 
4877     decrement(cnt);
4878     jccb(Assembler::negative, DONE); // Zero length
4879 
4880     // Use individual pointer-sized stores for small counts:
4881     BIND(LOOP);
4882     movptr(Address(base, cnt, Address::times_ptr), tmp);
4883     decrement(cnt);
4884     jccb(Assembler::greaterEqual, LOOP);
4885     jmpb(DONE);
4886 
4887     BIND(LONG);
4888   }
4889 
4890   // Use longer rep-prefixed ops for non-small counts:
4891   if (UseFastStosb) {
4892     shlptr(cnt, 3); // convert to number of bytes
4893     rep_stosb();
4894   } else if (UseXMMForObjInit) {
4895     movptr(tmp, base);
4896     xmm_clear_mem(tmp, cnt, xtmp);
4897   } else {
4898     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
4899     rep_stos();
4900   }
4901 
4902   BIND(DONE);
4903 }
4904 
4905 void MacroAssembler::generate_fill(BasicType t, bool aligned,
4906                                    Register to, Register value, Register count,
4907                                    Register rtmp, XMMRegister xtmp) {
4908   ShortBranchVerifier sbv(this);
4909   assert_different_registers(to, value, count, rtmp);
4910   Label L_exit;
4911   Label L_fill_2_bytes, L_fill_4_bytes;
4912 
4913   int shift = -1;
4914   switch (t) {
4915     case T_BYTE:
4916       shift = 2;
4917       break;
4918     case T_SHORT:
4919       shift = 1;
4920       break;
4921     case T_INT:
4922       shift = 0;
4923       break;
4924     default: ShouldNotReachHere();
4925   }
4926 
4927   if (t == T_BYTE) {
4928     andl(value, 0xff);
4929     movl(rtmp, value);
4930     shll(rtmp, 8);
4931     orl(value, rtmp);
4932   }
4933   if (t == T_SHORT) {
4934     andl(value, 0xffff);
4935   }
4936   if (t == T_BYTE || t == T_SHORT) {
4937     movl(rtmp, value);
4938     shll(rtmp, 16);
4939     orl(value, rtmp);
4940   }
4941 
4942   cmpl(count, 2&lt;&lt;shift); // Short arrays (&lt; 8 bytes) fill by element
4943   jcc(Assembler::below, L_fill_4_bytes); // use unsigned cmp
4944   if (!UseUnalignedLoadStores &amp;&amp; !aligned &amp;&amp; (t == T_BYTE || t == T_SHORT)) {
4945     Label L_skip_align2;
4946     // align source address at 4 bytes address boundary
4947     if (t == T_BYTE) {
4948       Label L_skip_align1;
4949       // One byte misalignment happens only for byte arrays
4950       testptr(to, 1);
4951       jccb(Assembler::zero, L_skip_align1);
4952       movb(Address(to, 0), value);
4953       increment(to);
4954       decrement(count);
4955       BIND(L_skip_align1);
4956     }
4957     // Two bytes misalignment happens only for byte and short (char) arrays
4958     testptr(to, 2);
4959     jccb(Assembler::zero, L_skip_align2);
4960     movw(Address(to, 0), value);
4961     addptr(to, 2);
4962     subl(count, 1&lt;&lt;(shift-1));
4963     BIND(L_skip_align2);
4964   }
4965   if (UseSSE &lt; 2) {
4966     Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;
4967     // Fill 32-byte chunks
4968     subl(count, 8 &lt;&lt; shift);
4969     jcc(Assembler::less, L_check_fill_8_bytes);
4970     align(16);
4971 
4972     BIND(L_fill_32_bytes_loop);
4973 
4974     for (int i = 0; i &lt; 32; i += 4) {
4975       movl(Address(to, i), value);
4976     }
4977 
4978     addptr(to, 32);
4979     subl(count, 8 &lt;&lt; shift);
4980     jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);
4981     BIND(L_check_fill_8_bytes);
4982     addl(count, 8 &lt;&lt; shift);
4983     jccb(Assembler::zero, L_exit);
4984     jmpb(L_fill_8_bytes);
4985 
4986     //
4987     // length is too short, just fill qwords
4988     //
4989     BIND(L_fill_8_bytes_loop);
4990     movl(Address(to, 0), value);
4991     movl(Address(to, 4), value);
4992     addptr(to, 8);
4993     BIND(L_fill_8_bytes);
4994     subl(count, 1 &lt;&lt; (shift + 1));
4995     jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);
4996     // fall through to fill 4 bytes
4997   } else {
4998     Label L_fill_32_bytes;
4999     if (!UseUnalignedLoadStores) {
5000       // align to 8 bytes, we know we are 4 byte aligned to start
5001       testptr(to, 4);
5002       jccb(Assembler::zero, L_fill_32_bytes);
5003       movl(Address(to, 0), value);
5004       addptr(to, 4);
5005       subl(count, 1&lt;&lt;shift);
5006     }
5007     BIND(L_fill_32_bytes);
5008     {
5009       assert( UseSSE &gt;= 2, &quot;supported cpu only&quot; );
5010       Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;
5011       movdl(xtmp, value);
5012       if (UseAVX &gt;= 2 &amp;&amp; UseUnalignedLoadStores) {
5013         Label L_check_fill_32_bytes;
5014         if (UseAVX &gt; 2) {
5015           // Fill 64-byte chunks
5016           Label L_fill_64_bytes_loop_avx3, L_check_fill_64_bytes_avx2;
5017 
5018           // If number of bytes to fill &lt; AVX3Threshold, perform fill using AVX2
5019           cmpl(count, AVX3Threshold);
5020           jccb(Assembler::below, L_check_fill_64_bytes_avx2);
5021 
5022           vpbroadcastd(xtmp, xtmp, Assembler::AVX_512bit);
5023 
5024           subl(count, 16 &lt;&lt; shift);
5025           jccb(Assembler::less, L_check_fill_32_bytes);
5026           align(16);
5027 
5028           BIND(L_fill_64_bytes_loop_avx3);
5029           evmovdqul(Address(to, 0), xtmp, Assembler::AVX_512bit);
5030           addptr(to, 64);
5031           subl(count, 16 &lt;&lt; shift);
5032           jcc(Assembler::greaterEqual, L_fill_64_bytes_loop_avx3);
5033           jmpb(L_check_fill_32_bytes);
5034 
5035           BIND(L_check_fill_64_bytes_avx2);
5036         }
5037         // Fill 64-byte chunks
5038         Label L_fill_64_bytes_loop;
5039         vpbroadcastd(xtmp, xtmp, Assembler::AVX_256bit);
5040 
5041         subl(count, 16 &lt;&lt; shift);
5042         jcc(Assembler::less, L_check_fill_32_bytes);
5043         align(16);
5044 
5045         BIND(L_fill_64_bytes_loop);
5046         vmovdqu(Address(to, 0), xtmp);
5047         vmovdqu(Address(to, 32), xtmp);
5048         addptr(to, 64);
5049         subl(count, 16 &lt;&lt; shift);
5050         jcc(Assembler::greaterEqual, L_fill_64_bytes_loop);
5051 
5052         BIND(L_check_fill_32_bytes);
5053         addl(count, 8 &lt;&lt; shift);
5054         jccb(Assembler::less, L_check_fill_8_bytes);
5055         vmovdqu(Address(to, 0), xtmp);
5056         addptr(to, 32);
5057         subl(count, 8 &lt;&lt; shift);
5058 
5059         BIND(L_check_fill_8_bytes);
5060         // clean upper bits of YMM registers
5061         movdl(xtmp, value);
5062         pshufd(xtmp, xtmp, 0);
5063       } else {
5064         // Fill 32-byte chunks
5065         pshufd(xtmp, xtmp, 0);
5066 
5067         subl(count, 8 &lt;&lt; shift);
5068         jcc(Assembler::less, L_check_fill_8_bytes);
5069         align(16);
5070 
5071         BIND(L_fill_32_bytes_loop);
5072 
5073         if (UseUnalignedLoadStores) {
5074           movdqu(Address(to, 0), xtmp);
5075           movdqu(Address(to, 16), xtmp);
5076         } else {
5077           movq(Address(to, 0), xtmp);
5078           movq(Address(to, 8), xtmp);
5079           movq(Address(to, 16), xtmp);
5080           movq(Address(to, 24), xtmp);
5081         }
5082 
5083         addptr(to, 32);
5084         subl(count, 8 &lt;&lt; shift);
5085         jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);
5086 
5087         BIND(L_check_fill_8_bytes);
5088       }
5089       addl(count, 8 &lt;&lt; shift);
5090       jccb(Assembler::zero, L_exit);
5091       jmpb(L_fill_8_bytes);
5092 
5093       //
5094       // length is too short, just fill qwords
5095       //
5096       BIND(L_fill_8_bytes_loop);
5097       movq(Address(to, 0), xtmp);
5098       addptr(to, 8);
5099       BIND(L_fill_8_bytes);
5100       subl(count, 1 &lt;&lt; (shift + 1));
5101       jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);
5102     }
5103   }
5104   // fill trailing 4 bytes
5105   BIND(L_fill_4_bytes);
5106   testl(count, 1&lt;&lt;shift);
5107   jccb(Assembler::zero, L_fill_2_bytes);
5108   movl(Address(to, 0), value);
5109   if (t == T_BYTE || t == T_SHORT) {
5110     Label L_fill_byte;
5111     addptr(to, 4);
5112     BIND(L_fill_2_bytes);
5113     // fill trailing 2 bytes
5114     testl(count, 1&lt;&lt;(shift-1));
5115     jccb(Assembler::zero, L_fill_byte);
5116     movw(Address(to, 0), value);
5117     if (t == T_BYTE) {
5118       addptr(to, 2);
5119       BIND(L_fill_byte);
5120       // fill trailing byte
5121       testl(count, 1);
5122       jccb(Assembler::zero, L_exit);
5123       movb(Address(to, 0), value);
5124     } else {
5125       BIND(L_fill_byte);
5126     }
5127   } else {
5128     BIND(L_fill_2_bytes);
5129   }
5130   BIND(L_exit);
5131 }
5132 
5133 // encode char[] to byte[] in ISO_8859_1
5134    //@HotSpotIntrinsicCandidate
5135    //private static int implEncodeISOArray(byte[] sa, int sp,
5136    //byte[] da, int dp, int len) {
5137    //  int i = 0;
5138    //  for (; i &lt; len; i++) {
5139    //    char c = StringUTF16.getChar(sa, sp++);
5140    //    if (c &gt; &#39;\u00FF&#39;)
5141    //      break;
5142    //    da[dp++] = (byte)c;
5143    //  }
5144    //  return i;
5145    //}
5146 void MacroAssembler::encode_iso_array(Register src, Register dst, Register len,
5147   XMMRegister tmp1Reg, XMMRegister tmp2Reg,
5148   XMMRegister tmp3Reg, XMMRegister tmp4Reg,
5149   Register tmp5, Register result) {
5150 
5151   // rsi: src
5152   // rdi: dst
5153   // rdx: len
5154   // rcx: tmp5
5155   // rax: result
5156   ShortBranchVerifier sbv(this);
5157   assert_different_registers(src, dst, len, tmp5, result);
5158   Label L_done, L_copy_1_char, L_copy_1_char_exit;
5159 
5160   // set result
5161   xorl(result, result);
5162   // check for zero length
5163   testl(len, len);
5164   jcc(Assembler::zero, L_done);
5165 
5166   movl(result, len);
5167 
5168   // Setup pointers
5169   lea(src, Address(src, len, Address::times_2)); // char[]
5170   lea(dst, Address(dst, len, Address::times_1)); // byte[]
5171   negptr(len);
5172 
5173   if (UseSSE42Intrinsics || UseAVX &gt;= 2) {
5174     Label L_copy_8_chars, L_copy_8_chars_exit;
5175     Label L_chars_16_check, L_copy_16_chars, L_copy_16_chars_exit;
5176 
5177     if (UseAVX &gt;= 2) {
5178       Label L_chars_32_check, L_copy_32_chars, L_copy_32_chars_exit;
5179       movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vector
5180       movdl(tmp1Reg, tmp5);
5181       vpbroadcastd(tmp1Reg, tmp1Reg, Assembler::AVX_256bit);
5182       jmp(L_chars_32_check);
5183 
5184       bind(L_copy_32_chars);
5185       vmovdqu(tmp3Reg, Address(src, len, Address::times_2, -64));
5186       vmovdqu(tmp4Reg, Address(src, len, Address::times_2, -32));
5187       vpor(tmp2Reg, tmp3Reg, tmp4Reg, /* vector_len */ 1);
5188       vptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in  vector
5189       jccb(Assembler::notZero, L_copy_32_chars_exit);
5190       vpackuswb(tmp3Reg, tmp3Reg, tmp4Reg, /* vector_len */ 1);
5191       vpermq(tmp4Reg, tmp3Reg, 0xD8, /* vector_len */ 1);
5192       vmovdqu(Address(dst, len, Address::times_1, -32), tmp4Reg);
5193 
5194       bind(L_chars_32_check);
5195       addptr(len, 32);
5196       jcc(Assembler::lessEqual, L_copy_32_chars);
5197 
5198       bind(L_copy_32_chars_exit);
5199       subptr(len, 16);
5200       jccb(Assembler::greater, L_copy_16_chars_exit);
5201 
5202     } else if (UseSSE42Intrinsics) {
5203       movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vector
5204       movdl(tmp1Reg, tmp5);
5205       pshufd(tmp1Reg, tmp1Reg, 0);
5206       jmpb(L_chars_16_check);
5207     }
5208 
5209     bind(L_copy_16_chars);
5210     if (UseAVX &gt;= 2) {
5211       vmovdqu(tmp2Reg, Address(src, len, Address::times_2, -32));
5212       vptest(tmp2Reg, tmp1Reg);
5213       jcc(Assembler::notZero, L_copy_16_chars_exit);
5214       vpackuswb(tmp2Reg, tmp2Reg, tmp1Reg, /* vector_len */ 1);
5215       vpermq(tmp3Reg, tmp2Reg, 0xD8, /* vector_len */ 1);
5216     } else {
5217       if (UseAVX &gt; 0) {
5218         movdqu(tmp3Reg, Address(src, len, Address::times_2, -32));
5219         movdqu(tmp4Reg, Address(src, len, Address::times_2, -16));
5220         vpor(tmp2Reg, tmp3Reg, tmp4Reg, /* vector_len */ 0);
5221       } else {
5222         movdqu(tmp3Reg, Address(src, len, Address::times_2, -32));
5223         por(tmp2Reg, tmp3Reg);
5224         movdqu(tmp4Reg, Address(src, len, Address::times_2, -16));
5225         por(tmp2Reg, tmp4Reg);
5226       }
5227       ptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in  vector
5228       jccb(Assembler::notZero, L_copy_16_chars_exit);
5229       packuswb(tmp3Reg, tmp4Reg);
5230     }
5231     movdqu(Address(dst, len, Address::times_1, -16), tmp3Reg);
5232 
5233     bind(L_chars_16_check);
5234     addptr(len, 16);
5235     jcc(Assembler::lessEqual, L_copy_16_chars);
5236 
5237     bind(L_copy_16_chars_exit);
5238     if (UseAVX &gt;= 2) {
5239       // clean upper bits of YMM registers
5240       vpxor(tmp2Reg, tmp2Reg);
5241       vpxor(tmp3Reg, tmp3Reg);
5242       vpxor(tmp4Reg, tmp4Reg);
5243       movdl(tmp1Reg, tmp5);
5244       pshufd(tmp1Reg, tmp1Reg, 0);
5245     }
5246     subptr(len, 8);
5247     jccb(Assembler::greater, L_copy_8_chars_exit);
5248 
5249     bind(L_copy_8_chars);
5250     movdqu(tmp3Reg, Address(src, len, Address::times_2, -16));
5251     ptest(tmp3Reg, tmp1Reg);
5252     jccb(Assembler::notZero, L_copy_8_chars_exit);
5253     packuswb(tmp3Reg, tmp1Reg);
5254     movq(Address(dst, len, Address::times_1, -8), tmp3Reg);
5255     addptr(len, 8);
5256     jccb(Assembler::lessEqual, L_copy_8_chars);
5257 
5258     bind(L_copy_8_chars_exit);
5259     subptr(len, 8);
5260     jccb(Assembler::zero, L_done);
5261   }
5262 
5263   bind(L_copy_1_char);
5264   load_unsigned_short(tmp5, Address(src, len, Address::times_2, 0));
5265   testl(tmp5, 0xff00);      // check if Unicode char
5266   jccb(Assembler::notZero, L_copy_1_char_exit);
5267   movb(Address(dst, len, Address::times_1, 0), tmp5);
5268   addptr(len, 1);
5269   jccb(Assembler::less, L_copy_1_char);
5270 
5271   bind(L_copy_1_char_exit);
5272   addptr(result, len); // len is negative count of not processed elements
5273 
5274   bind(L_done);
5275 }
5276 
5277 #ifdef _LP64
5278 /**
5279  * Helper for multiply_to_len().
5280  */
5281 void MacroAssembler::add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2) {
5282   addq(dest_lo, src1);
5283   adcq(dest_hi, 0);
5284   addq(dest_lo, src2);
5285   adcq(dest_hi, 0);
5286 }
5287 
5288 /**
5289  * Multiply 64 bit by 64 bit first loop.
5290  */
5291 void MacroAssembler::multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
5292                                            Register y, Register y_idx, Register z,
5293                                            Register carry, Register product,
5294                                            Register idx, Register kdx) {
5295   //
5296   //  jlong carry, x[], y[], z[];
5297   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
5298   //    huge_128 product = y[idx] * x[xstart] + carry;
5299   //    z[kdx] = (jlong)product;
5300   //    carry  = (jlong)(product &gt;&gt;&gt; 64);
5301   //  }
5302   //  z[xstart] = carry;
5303   //
5304 
5305   Label L_first_loop, L_first_loop_exit;
5306   Label L_one_x, L_one_y, L_multiply;
5307 
5308   decrementl(xstart);
5309   jcc(Assembler::negative, L_one_x);
5310 
5311   movq(x_xstart, Address(x, xstart, Address::times_4,  0));
5312   rorq(x_xstart, 32); // convert big-endian to little-endian
5313 
5314   bind(L_first_loop);
5315   decrementl(idx);
5316   jcc(Assembler::negative, L_first_loop_exit);
5317   decrementl(idx);
5318   jcc(Assembler::negative, L_one_y);
5319   movq(y_idx, Address(y, idx, Address::times_4,  0));
5320   rorq(y_idx, 32); // convert big-endian to little-endian
5321   bind(L_multiply);
5322   movq(product, x_xstart);
5323   mulq(y_idx); // product(rax) * y_idx -&gt; rdx:rax
5324   addq(product, carry);
5325   adcq(rdx, 0);
5326   subl(kdx, 2);
5327   movl(Address(z, kdx, Address::times_4,  4), product);
5328   shrq(product, 32);
5329   movl(Address(z, kdx, Address::times_4,  0), product);
5330   movq(carry, rdx);
5331   jmp(L_first_loop);
5332 
5333   bind(L_one_y);
5334   movl(y_idx, Address(y,  0));
5335   jmp(L_multiply);
5336 
5337   bind(L_one_x);
5338   movl(x_xstart, Address(x,  0));
5339   jmp(L_first_loop);
5340 
5341   bind(L_first_loop_exit);
5342 }
5343 
5344 /**
5345  * Multiply 64 bit by 64 bit and add 128 bit.
5346  */
5347 void MacroAssembler::multiply_add_128_x_128(Register x_xstart, Register y, Register z,
5348                                             Register yz_idx, Register idx,
5349                                             Register carry, Register product, int offset) {
5350   //     huge_128 product = (y[idx] * x_xstart) + z[kdx] + carry;
5351   //     z[kdx] = (jlong)product;
5352 
5353   movq(yz_idx, Address(y, idx, Address::times_4,  offset));
5354   rorq(yz_idx, 32); // convert big-endian to little-endian
5355   movq(product, x_xstart);
5356   mulq(yz_idx);     // product(rax) * yz_idx -&gt; rdx:product(rax)
5357   movq(yz_idx, Address(z, idx, Address::times_4,  offset));
5358   rorq(yz_idx, 32); // convert big-endian to little-endian
5359 
5360   add2_with_carry(rdx, product, carry, yz_idx);
5361 
5362   movl(Address(z, idx, Address::times_4,  offset+4), product);
5363   shrq(product, 32);
5364   movl(Address(z, idx, Address::times_4,  offset), product);
5365 
5366 }
5367 
5368 /**
5369  * Multiply 128 bit by 128 bit. Unrolled inner loop.
5370  */
5371 void MacroAssembler::multiply_128_x_128_loop(Register x_xstart, Register y, Register z,
5372                                              Register yz_idx, Register idx, Register jdx,
5373                                              Register carry, Register product,
5374                                              Register carry2) {
5375   //   jlong carry, x[], y[], z[];
5376   //   int kdx = ystart+1;
5377   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
5378   //     huge_128 product = (y[idx+1] * x_xstart) + z[kdx+idx+1] + carry;
5379   //     z[kdx+idx+1] = (jlong)product;
5380   //     jlong carry2  = (jlong)(product &gt;&gt;&gt; 64);
5381   //     product = (y[idx] * x_xstart) + z[kdx+idx] + carry2;
5382   //     z[kdx+idx] = (jlong)product;
5383   //     carry  = (jlong)(product &gt;&gt;&gt; 64);
5384   //   }
5385   //   idx += 2;
5386   //   if (idx &gt; 0) {
5387   //     product = (y[idx] * x_xstart) + z[kdx+idx] + carry;
5388   //     z[kdx+idx] = (jlong)product;
5389   //     carry  = (jlong)(product &gt;&gt;&gt; 64);
5390   //   }
5391   //
5392 
5393   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
5394 
5395   movl(jdx, idx);
5396   andl(jdx, 0xFFFFFFFC);
5397   shrl(jdx, 2);
5398 
5399   bind(L_third_loop);
5400   subl(jdx, 1);
5401   jcc(Assembler::negative, L_third_loop_exit);
5402   subl(idx, 4);
5403 
5404   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 8);
5405   movq(carry2, rdx);
5406 
5407   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry2, product, 0);
5408   movq(carry, rdx);
5409   jmp(L_third_loop);
5410 
5411   bind (L_third_loop_exit);
5412 
5413   andl (idx, 0x3);
5414   jcc(Assembler::zero, L_post_third_loop_done);
5415 
5416   Label L_check_1;
5417   subl(idx, 2);
5418   jcc(Assembler::negative, L_check_1);
5419 
5420   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 0);
5421   movq(carry, rdx);
5422 
5423   bind (L_check_1);
5424   addl (idx, 0x2);
5425   andl (idx, 0x1);
5426   subl(idx, 1);
5427   jcc(Assembler::negative, L_post_third_loop_done);
5428 
5429   movl(yz_idx, Address(y, idx, Address::times_4,  0));
5430   movq(product, x_xstart);
5431   mulq(yz_idx); // product(rax) * yz_idx -&gt; rdx:product(rax)
5432   movl(yz_idx, Address(z, idx, Address::times_4,  0));
5433 
5434   add2_with_carry(rdx, product, yz_idx, carry);
5435 
5436   movl(Address(z, idx, Address::times_4,  0), product);
5437   shrq(product, 32);
5438 
5439   shlq(rdx, 32);
5440   orq(product, rdx);
5441   movq(carry, product);
5442 
5443   bind(L_post_third_loop_done);
5444 }
5445 
5446 /**
5447  * Multiply 128 bit by 128 bit using BMI2. Unrolled inner loop.
5448  *
5449  */
5450 void MacroAssembler::multiply_128_x_128_bmi2_loop(Register y, Register z,
5451                                                   Register carry, Register carry2,
5452                                                   Register idx, Register jdx,
5453                                                   Register yz_idx1, Register yz_idx2,
5454                                                   Register tmp, Register tmp3, Register tmp4) {
5455   assert(UseBMI2Instructions, &quot;should be used only when BMI2 is available&quot;);
5456 
5457   //   jlong carry, x[], y[], z[];
5458   //   int kdx = ystart+1;
5459   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
5460   //     huge_128 tmp3 = (y[idx+1] * rdx) + z[kdx+idx+1] + carry;
5461   //     jlong carry2  = (jlong)(tmp3 &gt;&gt;&gt; 64);
5462   //     huge_128 tmp4 = (y[idx]   * rdx) + z[kdx+idx] + carry2;
5463   //     carry  = (jlong)(tmp4 &gt;&gt;&gt; 64);
5464   //     z[kdx+idx+1] = (jlong)tmp3;
5465   //     z[kdx+idx] = (jlong)tmp4;
5466   //   }
5467   //   idx += 2;
5468   //   if (idx &gt; 0) {
5469   //     yz_idx1 = (y[idx] * rdx) + z[kdx+idx] + carry;
5470   //     z[kdx+idx] = (jlong)yz_idx1;
5471   //     carry  = (jlong)(yz_idx1 &gt;&gt;&gt; 64);
5472   //   }
5473   //
5474 
5475   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
5476 
5477   movl(jdx, idx);
5478   andl(jdx, 0xFFFFFFFC);
5479   shrl(jdx, 2);
5480 
5481   bind(L_third_loop);
5482   subl(jdx, 1);
5483   jcc(Assembler::negative, L_third_loop_exit);
5484   subl(idx, 4);
5485 
5486   movq(yz_idx1,  Address(y, idx, Address::times_4,  8));
5487   rorxq(yz_idx1, yz_idx1, 32); // convert big-endian to little-endian
5488   movq(yz_idx2, Address(y, idx, Address::times_4,  0));
5489   rorxq(yz_idx2, yz_idx2, 32);
5490 
5491   mulxq(tmp4, tmp3, yz_idx1);  //  yz_idx1 * rdx -&gt; tmp4:tmp3
5492   mulxq(carry2, tmp, yz_idx2); //  yz_idx2 * rdx -&gt; carry2:tmp
5493 
5494   movq(yz_idx1,  Address(z, idx, Address::times_4,  8));
5495   rorxq(yz_idx1, yz_idx1, 32);
5496   movq(yz_idx2, Address(z, idx, Address::times_4,  0));
5497   rorxq(yz_idx2, yz_idx2, 32);
5498 
5499   if (VM_Version::supports_adx()) {
5500     adcxq(tmp3, carry);
5501     adoxq(tmp3, yz_idx1);
5502 
5503     adcxq(tmp4, tmp);
5504     adoxq(tmp4, yz_idx2);
5505 
5506     movl(carry, 0); // does not affect flags
5507     adcxq(carry2, carry);
5508     adoxq(carry2, carry);
5509   } else {
5510     add2_with_carry(tmp4, tmp3, carry, yz_idx1);
5511     add2_with_carry(carry2, tmp4, tmp, yz_idx2);
5512   }
5513   movq(carry, carry2);
5514 
5515   movl(Address(z, idx, Address::times_4, 12), tmp3);
5516   shrq(tmp3, 32);
5517   movl(Address(z, idx, Address::times_4,  8), tmp3);
5518 
5519   movl(Address(z, idx, Address::times_4,  4), tmp4);
5520   shrq(tmp4, 32);
5521   movl(Address(z, idx, Address::times_4,  0), tmp4);
5522 
5523   jmp(L_third_loop);
5524 
5525   bind (L_third_loop_exit);
5526 
5527   andl (idx, 0x3);
5528   jcc(Assembler::zero, L_post_third_loop_done);
5529 
5530   Label L_check_1;
5531   subl(idx, 2);
5532   jcc(Assembler::negative, L_check_1);
5533 
5534   movq(yz_idx1, Address(y, idx, Address::times_4,  0));
5535   rorxq(yz_idx1, yz_idx1, 32);
5536   mulxq(tmp4, tmp3, yz_idx1); //  yz_idx1 * rdx -&gt; tmp4:tmp3
5537   movq(yz_idx2, Address(z, idx, Address::times_4,  0));
5538   rorxq(yz_idx2, yz_idx2, 32);
5539 
5540   add2_with_carry(tmp4, tmp3, carry, yz_idx2);
5541 
5542   movl(Address(z, idx, Address::times_4,  4), tmp3);
5543   shrq(tmp3, 32);
5544   movl(Address(z, idx, Address::times_4,  0), tmp3);
5545   movq(carry, tmp4);
5546 
5547   bind (L_check_1);
5548   addl (idx, 0x2);
5549   andl (idx, 0x1);
5550   subl(idx, 1);
5551   jcc(Assembler::negative, L_post_third_loop_done);
5552   movl(tmp4, Address(y, idx, Address::times_4,  0));
5553   mulxq(carry2, tmp3, tmp4);  //  tmp4 * rdx -&gt; carry2:tmp3
5554   movl(tmp4, Address(z, idx, Address::times_4,  0));
5555 
5556   add2_with_carry(carry2, tmp3, tmp4, carry);
5557 
5558   movl(Address(z, idx, Address::times_4,  0), tmp3);
5559   shrq(tmp3, 32);
5560 
5561   shlq(carry2, 32);
5562   orq(tmp3, carry2);
5563   movq(carry, tmp3);
5564 
5565   bind(L_post_third_loop_done);
5566 }
5567 
5568 /**
5569  * Code for BigInteger::multiplyToLen() instrinsic.
5570  *
5571  * rdi: x
5572  * rax: xlen
5573  * rsi: y
5574  * rcx: ylen
5575  * r8:  z
5576  * r11: zlen
5577  * r12: tmp1
5578  * r13: tmp2
5579  * r14: tmp3
5580  * r15: tmp4
5581  * rbx: tmp5
5582  *
5583  */
5584 void MacroAssembler::multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register zlen,
5585                                      Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5) {
5586   ShortBranchVerifier sbv(this);
5587   assert_different_registers(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, rdx);
5588 
5589   push(tmp1);
5590   push(tmp2);
5591   push(tmp3);
5592   push(tmp4);
5593   push(tmp5);
5594 
5595   push(xlen);
5596   push(zlen);
5597 
5598   const Register idx = tmp1;
5599   const Register kdx = tmp2;
5600   const Register xstart = tmp3;
5601 
5602   const Register y_idx = tmp4;
5603   const Register carry = tmp5;
5604   const Register product  = xlen;
5605   const Register x_xstart = zlen;  // reuse register
5606 
5607   // First Loop.
5608   //
5609   //  final static long LONG_MASK = 0xffffffffL;
5610   //  int xstart = xlen - 1;
5611   //  int ystart = ylen - 1;
5612   //  long carry = 0;
5613   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
5614   //    long product = (y[idx] &amp; LONG_MASK) * (x[xstart] &amp; LONG_MASK) + carry;
5615   //    z[kdx] = (int)product;
5616   //    carry = product &gt;&gt;&gt; 32;
5617   //  }
5618   //  z[xstart] = (int)carry;
5619   //
5620 
5621   movl(idx, ylen);      // idx = ylen;
5622   movl(kdx, zlen);      // kdx = xlen+ylen;
5623   xorq(carry, carry);   // carry = 0;
5624 
5625   Label L_done;
5626 
5627   movl(xstart, xlen);
5628   decrementl(xstart);
5629   jcc(Assembler::negative, L_done);
5630 
5631   multiply_64_x_64_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);
5632 
5633   Label L_second_loop;
5634   testl(kdx, kdx);
5635   jcc(Assembler::zero, L_second_loop);
5636 
5637   Label L_carry;
5638   subl(kdx, 1);
5639   jcc(Assembler::zero, L_carry);
5640 
5641   movl(Address(z, kdx, Address::times_4,  0), carry);
5642   shrq(carry, 32);
5643   subl(kdx, 1);
5644 
5645   bind(L_carry);
5646   movl(Address(z, kdx, Address::times_4,  0), carry);
5647 
5648   // Second and third (nested) loops.
5649   //
5650   // for (int i = xstart-1; i &gt;= 0; i--) { // Second loop
5651   //   carry = 0;
5652   //   for (int jdx=ystart, k=ystart+1+i; jdx &gt;= 0; jdx--, k--) { // Third loop
5653   //     long product = (y[jdx] &amp; LONG_MASK) * (x[i] &amp; LONG_MASK) +
5654   //                    (z[k] &amp; LONG_MASK) + carry;
5655   //     z[k] = (int)product;
5656   //     carry = product &gt;&gt;&gt; 32;
5657   //   }
5658   //   z[i] = (int)carry;
5659   // }
5660   //
5661   // i = xlen, j = tmp1, k = tmp2, carry = tmp5, x[i] = rdx
5662 
5663   const Register jdx = tmp1;
5664 
5665   bind(L_second_loop);
5666   xorl(carry, carry);    // carry = 0;
5667   movl(jdx, ylen);       // j = ystart+1
5668 
5669   subl(xstart, 1);       // i = xstart-1;
5670   jcc(Assembler::negative, L_done);
5671 
5672   push (z);
5673 
5674   Label L_last_x;
5675   lea(z, Address(z, xstart, Address::times_4, 4)); // z = z + k - j
5676   subl(xstart, 1);       // i = xstart-1;
5677   jcc(Assembler::negative, L_last_x);
5678 
5679   if (UseBMI2Instructions) {
5680     movq(rdx,  Address(x, xstart, Address::times_4,  0));
5681     rorxq(rdx, rdx, 32); // convert big-endian to little-endian
5682   } else {
5683     movq(x_xstart, Address(x, xstart, Address::times_4,  0));
5684     rorq(x_xstart, 32);  // convert big-endian to little-endian
5685   }
5686 
5687   Label L_third_loop_prologue;
5688   bind(L_third_loop_prologue);
5689 
5690   push (x);
5691   push (xstart);
5692   push (ylen);
5693 
5694 
5695   if (UseBMI2Instructions) {
5696     multiply_128_x_128_bmi2_loop(y, z, carry, x, jdx, ylen, product, tmp2, x_xstart, tmp3, tmp4);
5697   } else { // !UseBMI2Instructions
5698     multiply_128_x_128_loop(x_xstart, y, z, y_idx, jdx, ylen, carry, product, x);
5699   }
5700 
5701   pop(ylen);
5702   pop(xlen);
5703   pop(x);
5704   pop(z);
5705 
5706   movl(tmp3, xlen);
5707   addl(tmp3, 1);
5708   movl(Address(z, tmp3, Address::times_4,  0), carry);
5709   subl(tmp3, 1);
5710   jccb(Assembler::negative, L_done);
5711 
5712   shrq(carry, 32);
5713   movl(Address(z, tmp3, Address::times_4,  0), carry);
5714   jmp(L_second_loop);
5715 
5716   // Next infrequent code is moved outside loops.
5717   bind(L_last_x);
5718   if (UseBMI2Instructions) {
5719     movl(rdx, Address(x,  0));
5720   } else {
5721     movl(x_xstart, Address(x,  0));
5722   }
5723   jmp(L_third_loop_prologue);
5724 
5725   bind(L_done);
5726 
5727   pop(zlen);
5728   pop(xlen);
5729 
5730   pop(tmp5);
5731   pop(tmp4);
5732   pop(tmp3);
5733   pop(tmp2);
5734   pop(tmp1);
5735 }
5736 
5737 void MacroAssembler::vectorized_mismatch(Register obja, Register objb, Register length, Register log2_array_indxscale,
5738   Register result, Register tmp1, Register tmp2, XMMRegister rymm0, XMMRegister rymm1, XMMRegister rymm2){
5739   assert(UseSSE42Intrinsics, &quot;SSE4.2 must be enabled.&quot;);
5740   Label VECTOR16_LOOP, VECTOR8_LOOP, VECTOR4_LOOP;
5741   Label VECTOR8_TAIL, VECTOR4_TAIL;
5742   Label VECTOR32_NOT_EQUAL, VECTOR16_NOT_EQUAL, VECTOR8_NOT_EQUAL, VECTOR4_NOT_EQUAL;
5743   Label SAME_TILL_END, DONE;
5744   Label BYTES_LOOP, BYTES_TAIL, BYTES_NOT_EQUAL;
5745 
5746   //scale is in rcx in both Win64 and Unix
5747   ShortBranchVerifier sbv(this);
5748 
5749   shlq(length);
5750   xorq(result, result);
5751 
5752   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp;
5753       VM_Version::supports_avx512vlbw()) {
5754     Label VECTOR64_LOOP, VECTOR64_NOT_EQUAL, VECTOR32_TAIL;
5755 
5756     cmpq(length, 64);
5757     jcc(Assembler::less, VECTOR32_TAIL);
5758 
5759     movq(tmp1, length);
5760     andq(tmp1, 0x3F);      // tail count
5761     andq(length, ~(0x3F)); //vector count
5762 
5763     bind(VECTOR64_LOOP);
5764     // AVX512 code to compare 64 byte vectors.
5765     evmovdqub(rymm0, Address(obja, result), Assembler::AVX_512bit);
5766     evpcmpeqb(k7, rymm0, Address(objb, result), Assembler::AVX_512bit);
5767     kortestql(k7, k7);
5768     jcc(Assembler::aboveEqual, VECTOR64_NOT_EQUAL);     // mismatch
5769     addq(result, 64);
5770     subq(length, 64);
5771     jccb(Assembler::notZero, VECTOR64_LOOP);
5772 
5773     //bind(VECTOR64_TAIL);
5774     testq(tmp1, tmp1);
5775     jcc(Assembler::zero, SAME_TILL_END);
5776 
5777     //bind(VECTOR64_TAIL);
5778     // AVX512 code to compare upto 63 byte vectors.
5779     mov64(tmp2, 0xFFFFFFFFFFFFFFFF);
5780     shlxq(tmp2, tmp2, tmp1);
5781     notq(tmp2);
5782     kmovql(k3, tmp2);
5783 
5784     evmovdqub(rymm0, k3, Address(obja, result), Assembler::AVX_512bit);
5785     evpcmpeqb(k7, k3, rymm0, Address(objb, result), Assembler::AVX_512bit);
5786 
5787     ktestql(k7, k3);
5788     jcc(Assembler::below, SAME_TILL_END);     // not mismatch
5789 
5790     bind(VECTOR64_NOT_EQUAL);
5791     kmovql(tmp1, k7);
5792     notq(tmp1);
5793     tzcntq(tmp1, tmp1);
5794     addq(result, tmp1);
5795     shrq(result);
5796     jmp(DONE);
5797     bind(VECTOR32_TAIL);
5798   }
5799 
5800   cmpq(length, 8);
5801   jcc(Assembler::equal, VECTOR8_LOOP);
5802   jcc(Assembler::less, VECTOR4_TAIL);
5803 
5804   if (UseAVX &gt;= 2) {
5805     Label VECTOR16_TAIL, VECTOR32_LOOP;
5806 
5807     cmpq(length, 16);
5808     jcc(Assembler::equal, VECTOR16_LOOP);
5809     jcc(Assembler::less, VECTOR8_LOOP);
5810 
5811     cmpq(length, 32);
5812     jccb(Assembler::less, VECTOR16_TAIL);
5813 
5814     subq(length, 32);
5815     bind(VECTOR32_LOOP);
5816     vmovdqu(rymm0, Address(obja, result));
5817     vmovdqu(rymm1, Address(objb, result));
5818     vpxor(rymm2, rymm0, rymm1, Assembler::AVX_256bit);
5819     vptest(rymm2, rymm2);
5820     jcc(Assembler::notZero, VECTOR32_NOT_EQUAL);//mismatch found
5821     addq(result, 32);
5822     subq(length, 32);
5823     jcc(Assembler::greaterEqual, VECTOR32_LOOP);
5824     addq(length, 32);
5825     jcc(Assembler::equal, SAME_TILL_END);
5826     //falling through if less than 32 bytes left //close the branch here.
5827 
5828     bind(VECTOR16_TAIL);
5829     cmpq(length, 16);
5830     jccb(Assembler::less, VECTOR8_TAIL);
5831     bind(VECTOR16_LOOP);
5832     movdqu(rymm0, Address(obja, result));
5833     movdqu(rymm1, Address(objb, result));
5834     vpxor(rymm2, rymm0, rymm1, Assembler::AVX_128bit);
5835     ptest(rymm2, rymm2);
5836     jcc(Assembler::notZero, VECTOR16_NOT_EQUAL);//mismatch found
5837     addq(result, 16);
5838     subq(length, 16);
5839     jcc(Assembler::equal, SAME_TILL_END);
5840     //falling through if less than 16 bytes left
5841   } else {//regular intrinsics
5842 
5843     cmpq(length, 16);
5844     jccb(Assembler::less, VECTOR8_TAIL);
5845 
5846     subq(length, 16);
5847     bind(VECTOR16_LOOP);
5848     movdqu(rymm0, Address(obja, result));
5849     movdqu(rymm1, Address(objb, result));
5850     pxor(rymm0, rymm1);
5851     ptest(rymm0, rymm0);
5852     jcc(Assembler::notZero, VECTOR16_NOT_EQUAL);//mismatch found
5853     addq(result, 16);
5854     subq(length, 16);
5855     jccb(Assembler::greaterEqual, VECTOR16_LOOP);
5856     addq(length, 16);
5857     jcc(Assembler::equal, SAME_TILL_END);
5858     //falling through if less than 16 bytes left
5859   }
5860 
5861   bind(VECTOR8_TAIL);
5862   cmpq(length, 8);
5863   jccb(Assembler::less, VECTOR4_TAIL);
5864   bind(VECTOR8_LOOP);
5865   movq(tmp1, Address(obja, result));
5866   movq(tmp2, Address(objb, result));
5867   xorq(tmp1, tmp2);
5868   testq(tmp1, tmp1);
5869   jcc(Assembler::notZero, VECTOR8_NOT_EQUAL);//mismatch found
5870   addq(result, 8);
5871   subq(length, 8);
5872   jcc(Assembler::equal, SAME_TILL_END);
5873   //falling through if less than 8 bytes left
5874 
5875   bind(VECTOR4_TAIL);
5876   cmpq(length, 4);
5877   jccb(Assembler::less, BYTES_TAIL);
5878   bind(VECTOR4_LOOP);
5879   movl(tmp1, Address(obja, result));
5880   xorl(tmp1, Address(objb, result));
5881   testl(tmp1, tmp1);
5882   jcc(Assembler::notZero, VECTOR4_NOT_EQUAL);//mismatch found
5883   addq(result, 4);
5884   subq(length, 4);
5885   jcc(Assembler::equal, SAME_TILL_END);
5886   //falling through if less than 4 bytes left
5887 
5888   bind(BYTES_TAIL);
5889   bind(BYTES_LOOP);
5890   load_unsigned_byte(tmp1, Address(obja, result));
5891   load_unsigned_byte(tmp2, Address(objb, result));
5892   xorl(tmp1, tmp2);
5893   testl(tmp1, tmp1);
5894   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
5895   decq(length);
5896   jcc(Assembler::zero, SAME_TILL_END);
5897   incq(result);
5898   load_unsigned_byte(tmp1, Address(obja, result));
5899   load_unsigned_byte(tmp2, Address(objb, result));
5900   xorl(tmp1, tmp2);
5901   testl(tmp1, tmp1);
5902   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
5903   decq(length);
5904   jcc(Assembler::zero, SAME_TILL_END);
5905   incq(result);
5906   load_unsigned_byte(tmp1, Address(obja, result));
5907   load_unsigned_byte(tmp2, Address(objb, result));
5908   xorl(tmp1, tmp2);
5909   testl(tmp1, tmp1);
5910   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
5911   jmp(SAME_TILL_END);
5912 
5913   if (UseAVX &gt;= 2) {
5914     bind(VECTOR32_NOT_EQUAL);
5915     vpcmpeqb(rymm2, rymm2, rymm2, Assembler::AVX_256bit);
5916     vpcmpeqb(rymm0, rymm0, rymm1, Assembler::AVX_256bit);
5917     vpxor(rymm0, rymm0, rymm2, Assembler::AVX_256bit);
5918     vpmovmskb(tmp1, rymm0);
5919     bsfq(tmp1, tmp1);
5920     addq(result, tmp1);
5921     shrq(result);
5922     jmp(DONE);
5923   }
5924 
5925   bind(VECTOR16_NOT_EQUAL);
5926   if (UseAVX &gt;= 2) {
5927     vpcmpeqb(rymm2, rymm2, rymm2, Assembler::AVX_128bit);
5928     vpcmpeqb(rymm0, rymm0, rymm1, Assembler::AVX_128bit);
5929     pxor(rymm0, rymm2);
5930   } else {
5931     pcmpeqb(rymm2, rymm2);
5932     pxor(rymm0, rymm1);
5933     pcmpeqb(rymm0, rymm1);
5934     pxor(rymm0, rymm2);
5935   }
5936   pmovmskb(tmp1, rymm0);
5937   bsfq(tmp1, tmp1);
5938   addq(result, tmp1);
5939   shrq(result);
5940   jmpb(DONE);
5941 
5942   bind(VECTOR8_NOT_EQUAL);
5943   bind(VECTOR4_NOT_EQUAL);
5944   bsfq(tmp1, tmp1);
5945   shrq(tmp1, 3);
5946   addq(result, tmp1);
5947   bind(BYTES_NOT_EQUAL);
5948   shrq(result);
5949   jmpb(DONE);
5950 
5951   bind(SAME_TILL_END);
5952   mov64(result, -1);
5953 
5954   bind(DONE);
5955 }
5956 
5957 //Helper functions for square_to_len()
5958 
5959 /**
5960  * Store the squares of x[], right shifted one bit (divided by 2) into z[]
5961  * Preserves x and z and modifies rest of the registers.
5962  */
5963 void MacroAssembler::square_rshift(Register x, Register xlen, Register z, Register tmp1, Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
5964   // Perform square and right shift by 1
5965   // Handle odd xlen case first, then for even xlen do the following
5966   // jlong carry = 0;
5967   // for (int j=0, i=0; j &lt; xlen; j+=2, i+=4) {
5968   //     huge_128 product = x[j:j+1] * x[j:j+1];
5969   //     z[i:i+1] = (carry &lt;&lt; 63) | (jlong)(product &gt;&gt;&gt; 65);
5970   //     z[i+2:i+3] = (jlong)(product &gt;&gt;&gt; 1);
5971   //     carry = (jlong)product;
5972   // }
5973 
5974   xorq(tmp5, tmp5);     // carry
5975   xorq(rdxReg, rdxReg);
5976   xorl(tmp1, tmp1);     // index for x
5977   xorl(tmp4, tmp4);     // index for z
5978 
5979   Label L_first_loop, L_first_loop_exit;
5980 
5981   testl(xlen, 1);
5982   jccb(Assembler::zero, L_first_loop); //jump if xlen is even
5983 
5984   // Square and right shift by 1 the odd element using 32 bit multiply
5985   movl(raxReg, Address(x, tmp1, Address::times_4, 0));
5986   imulq(raxReg, raxReg);
5987   shrq(raxReg, 1);
5988   adcq(tmp5, 0);
5989   movq(Address(z, tmp4, Address::times_4, 0), raxReg);
5990   incrementl(tmp1);
5991   addl(tmp4, 2);
5992 
5993   // Square and  right shift by 1 the rest using 64 bit multiply
5994   bind(L_first_loop);
5995   cmpptr(tmp1, xlen);
5996   jccb(Assembler::equal, L_first_loop_exit);
5997 
5998   // Square
5999   movq(raxReg, Address(x, tmp1, Address::times_4,  0));
6000   rorq(raxReg, 32);    // convert big-endian to little-endian
6001   mulq(raxReg);        // 64-bit multiply rax * rax -&gt; rdx:rax
6002 
6003   // Right shift by 1 and save carry
6004   shrq(tmp5, 1);       // rdx:rax:tmp5 = (tmp5:rdx:rax) &gt;&gt;&gt; 1
6005   rcrq(rdxReg, 1);
6006   rcrq(raxReg, 1);
6007   adcq(tmp5, 0);
6008 
6009   // Store result in z
6010   movq(Address(z, tmp4, Address::times_4, 0), rdxReg);
6011   movq(Address(z, tmp4, Address::times_4, 8), raxReg);
6012 
6013   // Update indices for x and z
6014   addl(tmp1, 2);
6015   addl(tmp4, 4);
6016   jmp(L_first_loop);
6017 
6018   bind(L_first_loop_exit);
6019 }
6020 
6021 
6022 /**
6023  * Perform the following multiply add operation using BMI2 instructions
6024  * carry:sum = sum + op1*op2 + carry
6025  * op2 should be in rdx
6026  * op2 is preserved, all other registers are modified
6027  */
6028 void MacroAssembler::multiply_add_64_bmi2(Register sum, Register op1, Register op2, Register carry, Register tmp2) {
6029   // assert op2 is rdx
6030   mulxq(tmp2, op1, op1);  //  op1 * op2 -&gt; tmp2:op1
6031   addq(sum, carry);
6032   adcq(tmp2, 0);
6033   addq(sum, op1);
6034   adcq(tmp2, 0);
6035   movq(carry, tmp2);
6036 }
6037 
6038 /**
6039  * Perform the following multiply add operation:
6040  * carry:sum = sum + op1*op2 + carry
6041  * Preserves op1, op2 and modifies rest of registers
6042  */
6043 void MacroAssembler::multiply_add_64(Register sum, Register op1, Register op2, Register carry, Register rdxReg, Register raxReg) {
6044   // rdx:rax = op1 * op2
6045   movq(raxReg, op2);
6046   mulq(op1);
6047 
6048   //  rdx:rax = sum + carry + rdx:rax
6049   addq(sum, carry);
6050   adcq(rdxReg, 0);
6051   addq(sum, raxReg);
6052   adcq(rdxReg, 0);
6053 
6054   // carry:sum = rdx:sum
6055   movq(carry, rdxReg);
6056 }
6057 
6058 /**
6059  * Add 64 bit long carry into z[] with carry propogation.
6060  * Preserves z and carry register values and modifies rest of registers.
6061  *
6062  */
6063 void MacroAssembler::add_one_64(Register z, Register zlen, Register carry, Register tmp1) {
6064   Label L_fourth_loop, L_fourth_loop_exit;
6065 
6066   movl(tmp1, 1);
6067   subl(zlen, 2);
6068   addq(Address(z, zlen, Address::times_4, 0), carry);
6069 
6070   bind(L_fourth_loop);
6071   jccb(Assembler::carryClear, L_fourth_loop_exit);
6072   subl(zlen, 2);
6073   jccb(Assembler::negative, L_fourth_loop_exit);
6074   addq(Address(z, zlen, Address::times_4, 0), tmp1);
6075   jmp(L_fourth_loop);
6076   bind(L_fourth_loop_exit);
6077 }
6078 
6079 /**
6080  * Shift z[] left by 1 bit.
6081  * Preserves x, len, z and zlen registers and modifies rest of the registers.
6082  *
6083  */
6084 void MacroAssembler::lshift_by_1(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2, Register tmp3, Register tmp4) {
6085 
6086   Label L_fifth_loop, L_fifth_loop_exit;
6087 
6088   // Fifth loop
6089   // Perform primitiveLeftShift(z, zlen, 1)
6090 
6091   const Register prev_carry = tmp1;
6092   const Register new_carry = tmp4;
6093   const Register value = tmp2;
6094   const Register zidx = tmp3;
6095 
6096   // int zidx, carry;
6097   // long value;
6098   // carry = 0;
6099   // for (zidx = zlen-2; zidx &gt;=0; zidx -= 2) {
6100   //    (carry:value)  = (z[i] &lt;&lt; 1) | carry ;
6101   //    z[i] = value;
6102   // }
6103 
6104   movl(zidx, zlen);
6105   xorl(prev_carry, prev_carry); // clear carry flag and prev_carry register
6106 
6107   bind(L_fifth_loop);
6108   decl(zidx);  // Use decl to preserve carry flag
6109   decl(zidx);
6110   jccb(Assembler::negative, L_fifth_loop_exit);
6111 
6112   if (UseBMI2Instructions) {
6113      movq(value, Address(z, zidx, Address::times_4, 0));
6114      rclq(value, 1);
6115      rorxq(value, value, 32);
6116      movq(Address(z, zidx, Address::times_4,  0), value);  // Store back in big endian form
6117   }
6118   else {
6119     // clear new_carry
6120     xorl(new_carry, new_carry);
6121 
6122     // Shift z[i] by 1, or in previous carry and save new carry
6123     movq(value, Address(z, zidx, Address::times_4, 0));
6124     shlq(value, 1);
6125     adcl(new_carry, 0);
6126 
6127     orq(value, prev_carry);
6128     rorq(value, 0x20);
6129     movq(Address(z, zidx, Address::times_4,  0), value);  // Store back in big endian form
6130 
6131     // Set previous carry = new carry
6132     movl(prev_carry, new_carry);
6133   }
6134   jmp(L_fifth_loop);
6135 
6136   bind(L_fifth_loop_exit);
6137 }
6138 
6139 
6140 /**
6141  * Code for BigInteger::squareToLen() intrinsic
6142  *
6143  * rdi: x
6144  * rsi: len
6145  * r8:  z
6146  * rcx: zlen
6147  * r12: tmp1
6148  * r13: tmp2
6149  * r14: tmp3
6150  * r15: tmp4
6151  * rbx: tmp5
6152  *
6153  */
6154 void MacroAssembler::square_to_len(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6155 
6156   Label L_second_loop, L_second_loop_exit, L_third_loop, L_third_loop_exit, L_last_x, L_multiply;
6157   push(tmp1);
6158   push(tmp2);
6159   push(tmp3);
6160   push(tmp4);
6161   push(tmp5);
6162 
6163   // First loop
6164   // Store the squares, right shifted one bit (i.e., divided by 2).
6165   square_rshift(x, len, z, tmp1, tmp3, tmp4, tmp5, rdxReg, raxReg);
6166 
6167   // Add in off-diagonal sums.
6168   //
6169   // Second, third (nested) and fourth loops.
6170   // zlen +=2;
6171   // for (int xidx=len-2,zidx=zlen-4; xidx &gt; 0; xidx-=2,zidx-=4) {
6172   //    carry = 0;
6173   //    long op2 = x[xidx:xidx+1];
6174   //    for (int j=xidx-2,k=zidx; j &gt;= 0; j-=2) {
6175   //       k -= 2;
6176   //       long op1 = x[j:j+1];
6177   //       long sum = z[k:k+1];
6178   //       carry:sum = multiply_add_64(sum, op1, op2, carry, tmp_regs);
6179   //       z[k:k+1] = sum;
6180   //    }
6181   //    add_one_64(z, k, carry, tmp_regs);
6182   // }
6183 
6184   const Register carry = tmp5;
6185   const Register sum = tmp3;
6186   const Register op1 = tmp4;
6187   Register op2 = tmp2;
6188 
6189   push(zlen);
6190   push(len);
6191   addl(zlen,2);
6192   bind(L_second_loop);
6193   xorq(carry, carry);
6194   subl(zlen, 4);
6195   subl(len, 2);
6196   push(zlen);
6197   push(len);
6198   cmpl(len, 0);
6199   jccb(Assembler::lessEqual, L_second_loop_exit);
6200 
6201   // Multiply an array by one 64 bit long.
6202   if (UseBMI2Instructions) {
6203     op2 = rdxReg;
6204     movq(op2, Address(x, len, Address::times_4,  0));
6205     rorxq(op2, op2, 32);
6206   }
6207   else {
6208     movq(op2, Address(x, len, Address::times_4,  0));
6209     rorq(op2, 32);
6210   }
6211 
6212   bind(L_third_loop);
6213   decrementl(len);
6214   jccb(Assembler::negative, L_third_loop_exit);
6215   decrementl(len);
6216   jccb(Assembler::negative, L_last_x);
6217 
6218   movq(op1, Address(x, len, Address::times_4,  0));
6219   rorq(op1, 32);
6220 
6221   bind(L_multiply);
6222   subl(zlen, 2);
6223   movq(sum, Address(z, zlen, Address::times_4,  0));
6224 
6225   // Multiply 64 bit by 64 bit and add 64 bits lower half and upper 64 bits as carry.
6226   if (UseBMI2Instructions) {
6227     multiply_add_64_bmi2(sum, op1, op2, carry, tmp2);
6228   }
6229   else {
6230     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
6231   }
6232 
6233   movq(Address(z, zlen, Address::times_4, 0), sum);
6234 
6235   jmp(L_third_loop);
6236   bind(L_third_loop_exit);
6237 
6238   // Fourth loop
6239   // Add 64 bit long carry into z with carry propogation.
6240   // Uses offsetted zlen.
6241   add_one_64(z, zlen, carry, tmp1);
6242 
6243   pop(len);
6244   pop(zlen);
6245   jmp(L_second_loop);
6246 
6247   // Next infrequent code is moved outside loops.
6248   bind(L_last_x);
6249   movl(op1, Address(x, 0));
6250   jmp(L_multiply);
6251 
6252   bind(L_second_loop_exit);
6253   pop(len);
6254   pop(zlen);
6255   pop(len);
6256   pop(zlen);
6257 
6258   // Fifth loop
6259   // Shift z left 1 bit.
6260   lshift_by_1(x, len, z, zlen, tmp1, tmp2, tmp3, tmp4);
6261 
6262   // z[zlen-1] |= x[len-1] &amp; 1;
6263   movl(tmp3, Address(x, len, Address::times_4, -4));
6264   andl(tmp3, 1);
6265   orl(Address(z, zlen, Address::times_4,  -4), tmp3);
6266 
6267   pop(tmp5);
6268   pop(tmp4);
6269   pop(tmp3);
6270   pop(tmp2);
6271   pop(tmp1);
6272 }
6273 
6274 /**
6275  * Helper function for mul_add()
6276  * Multiply the in[] by int k and add to out[] starting at offset offs using
6277  * 128 bit by 32 bit multiply and return the carry in tmp5.
6278  * Only quad int aligned length of in[] is operated on in this function.
6279  * k is in rdxReg for BMI2Instructions, for others it is in tmp2.
6280  * This function preserves out, in and k registers.
6281  * len and offset point to the appropriate index in &quot;in&quot; &amp; &quot;out&quot; correspondingly
6282  * tmp5 has the carry.
6283  * other registers are temporary and are modified.
6284  *
6285  */
6286 void MacroAssembler::mul_add_128_x_32_loop(Register out, Register in,
6287   Register offset, Register len, Register tmp1, Register tmp2, Register tmp3,
6288   Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6289 
6290   Label L_first_loop, L_first_loop_exit;
6291 
6292   movl(tmp1, len);
6293   shrl(tmp1, 2);
6294 
6295   bind(L_first_loop);
6296   subl(tmp1, 1);
6297   jccb(Assembler::negative, L_first_loop_exit);
6298 
6299   subl(len, 4);
6300   subl(offset, 4);
6301 
6302   Register op2 = tmp2;
6303   const Register sum = tmp3;
6304   const Register op1 = tmp4;
6305   const Register carry = tmp5;
6306 
6307   if (UseBMI2Instructions) {
6308     op2 = rdxReg;
6309   }
6310 
6311   movq(op1, Address(in, len, Address::times_4,  8));
6312   rorq(op1, 32);
6313   movq(sum, Address(out, offset, Address::times_4,  8));
6314   rorq(sum, 32);
6315   if (UseBMI2Instructions) {
6316     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
6317   }
6318   else {
6319     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
6320   }
6321   // Store back in big endian from little endian
6322   rorq(sum, 0x20);
6323   movq(Address(out, offset, Address::times_4,  8), sum);
6324 
6325   movq(op1, Address(in, len, Address::times_4,  0));
6326   rorq(op1, 32);
6327   movq(sum, Address(out, offset, Address::times_4,  0));
6328   rorq(sum, 32);
6329   if (UseBMI2Instructions) {
6330     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
6331   }
6332   else {
6333     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
6334   }
6335   // Store back in big endian from little endian
6336   rorq(sum, 0x20);
6337   movq(Address(out, offset, Address::times_4,  0), sum);
6338 
6339   jmp(L_first_loop);
6340   bind(L_first_loop_exit);
6341 }
6342 
6343 /**
6344  * Code for BigInteger::mulAdd() intrinsic
6345  *
6346  * rdi: out
6347  * rsi: in
6348  * r11: offs (out.length - offset)
6349  * rcx: len
6350  * r8:  k
6351  * r12: tmp1
6352  * r13: tmp2
6353  * r14: tmp3
6354  * r15: tmp4
6355  * rbx: tmp5
6356  * Multiply the in[] by word k and add to out[], return the carry in rax
6357  */
6358 void MacroAssembler::mul_add(Register out, Register in, Register offs,
6359    Register len, Register k, Register tmp1, Register tmp2, Register tmp3,
6360    Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6361 
6362   Label L_carry, L_last_in, L_done;
6363 
6364 // carry = 0;
6365 // for (int j=len-1; j &gt;= 0; j--) {
6366 //    long product = (in[j] &amp; LONG_MASK) * kLong +
6367 //                   (out[offs] &amp; LONG_MASK) + carry;
6368 //    out[offs--] = (int)product;
6369 //    carry = product &gt;&gt;&gt; 32;
6370 // }
6371 //
6372   push(tmp1);
6373   push(tmp2);
6374   push(tmp3);
6375   push(tmp4);
6376   push(tmp5);
6377 
6378   Register op2 = tmp2;
6379   const Register sum = tmp3;
6380   const Register op1 = tmp4;
6381   const Register carry =  tmp5;
6382 
6383   if (UseBMI2Instructions) {
6384     op2 = rdxReg;
6385     movl(op2, k);
6386   }
6387   else {
6388     movl(op2, k);
6389   }
6390 
6391   xorq(carry, carry);
6392 
6393   //First loop
6394 
6395   //Multiply in[] by k in a 4 way unrolled loop using 128 bit by 32 bit multiply
6396   //The carry is in tmp5
6397   mul_add_128_x_32_loop(out, in, offs, len, tmp1, tmp2, tmp3, tmp4, tmp5, rdxReg, raxReg);
6398 
6399   //Multiply the trailing in[] entry using 64 bit by 32 bit, if any
6400   decrementl(len);
6401   jccb(Assembler::negative, L_carry);
6402   decrementl(len);
6403   jccb(Assembler::negative, L_last_in);
6404 
6405   movq(op1, Address(in, len, Address::times_4,  0));
6406   rorq(op1, 32);
6407 
6408   subl(offs, 2);
6409   movq(sum, Address(out, offs, Address::times_4,  0));
6410   rorq(sum, 32);
6411 
6412   if (UseBMI2Instructions) {
6413     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
6414   }
6415   else {
6416     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
6417   }
6418 
6419   // Store back in big endian from little endian
6420   rorq(sum, 0x20);
6421   movq(Address(out, offs, Address::times_4,  0), sum);
6422 
6423   testl(len, len);
6424   jccb(Assembler::zero, L_carry);
6425 
6426   //Multiply the last in[] entry, if any
6427   bind(L_last_in);
6428   movl(op1, Address(in, 0));
6429   movl(sum, Address(out, offs, Address::times_4,  -4));
6430 
6431   movl(raxReg, k);
6432   mull(op1); //tmp4 * eax -&gt; edx:eax
6433   addl(sum, carry);
6434   adcl(rdxReg, 0);
6435   addl(sum, raxReg);
6436   adcl(rdxReg, 0);
6437   movl(carry, rdxReg);
6438 
6439   movl(Address(out, offs, Address::times_4,  -4), sum);
6440 
6441   bind(L_carry);
6442   //return tmp5/carry as carry in rax
6443   movl(rax, carry);
6444 
6445   bind(L_done);
6446   pop(tmp5);
6447   pop(tmp4);
6448   pop(tmp3);
6449   pop(tmp2);
6450   pop(tmp1);
6451 }
6452 #endif
6453 
6454 /**
6455  * Emits code to update CRC-32 with a byte value according to constants in table
6456  *
6457  * @param [in,out]crc   Register containing the crc.
6458  * @param [in]val       Register containing the byte to fold into the CRC.
6459  * @param [in]table     Register containing the table of crc constants.
6460  *
6461  * uint32_t crc;
6462  * val = crc_table[(val ^ crc) &amp; 0xFF];
6463  * crc = val ^ (crc &gt;&gt; 8);
6464  *
6465  */
6466 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
6467   xorl(val, crc);
6468   andl(val, 0xFF);
6469   shrl(crc, 8); // unsigned shift
6470   xorl(crc, Address(table, val, Address::times_4, 0));
6471 }
6472 
6473 /**
6474  * Fold 128-bit data chunk
6475  */
6476 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset) {
6477   if (UseAVX &gt; 0) {
6478     vpclmulhdq(xtmp, xK, xcrc); // [123:64]
6479     vpclmulldq(xcrc, xK, xcrc); // [63:0]
6480     vpxor(xcrc, xcrc, Address(buf, offset), 0 /* vector_len */);
6481     pxor(xcrc, xtmp);
6482   } else {
6483     movdqa(xtmp, xcrc);
6484     pclmulhdq(xtmp, xK);   // [123:64]
6485     pclmulldq(xcrc, xK);   // [63:0]
6486     pxor(xcrc, xtmp);
6487     movdqu(xtmp, Address(buf, offset));
6488     pxor(xcrc, xtmp);
6489   }
6490 }
6491 
6492 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, XMMRegister xbuf) {
6493   if (UseAVX &gt; 0) {
6494     vpclmulhdq(xtmp, xK, xcrc);
6495     vpclmulldq(xcrc, xK, xcrc);
6496     pxor(xcrc, xbuf);
6497     pxor(xcrc, xtmp);
6498   } else {
6499     movdqa(xtmp, xcrc);
6500     pclmulhdq(xtmp, xK);
6501     pclmulldq(xcrc, xK);
6502     pxor(xcrc, xbuf);
6503     pxor(xcrc, xtmp);
6504   }
6505 }
6506 
6507 /**
6508  * 8-bit folds to compute 32-bit CRC
6509  *
6510  * uint64_t xcrc;
6511  * timesXtoThe32[xcrc &amp; 0xFF] ^ (xcrc &gt;&gt; 8);
6512  */
6513 void MacroAssembler::fold_8bit_crc32(XMMRegister xcrc, Register table, XMMRegister xtmp, Register tmp) {
6514   movdl(tmp, xcrc);
6515   andl(tmp, 0xFF);
6516   movdl(xtmp, Address(table, tmp, Address::times_4, 0));
6517   psrldq(xcrc, 1); // unsigned shift one byte
6518   pxor(xcrc, xtmp);
6519 }
6520 
6521 /**
6522  * uint32_t crc;
6523  * timesXtoThe32[crc &amp; 0xFF] ^ (crc &gt;&gt; 8);
6524  */
6525 void MacroAssembler::fold_8bit_crc32(Register crc, Register table, Register tmp) {
6526   movl(tmp, crc);
6527   andl(tmp, 0xFF);
6528   shrl(crc, 8);
6529   xorl(crc, Address(table, tmp, Address::times_4, 0));
6530 }
6531 
6532 /**
6533  * @param crc   register containing existing CRC (32-bit)
6534  * @param buf   register pointing to input byte buffer (byte*)
6535  * @param len   register containing number of bytes
6536  * @param table register that will contain address of CRC table
6537  * @param tmp   scratch register
6538  */
6539 void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len, Register table, Register tmp) {
6540   assert_different_registers(crc, buf, len, table, tmp, rax);
6541 
6542   Label L_tail, L_tail_restore, L_tail_loop, L_exit, L_align_loop, L_aligned;
6543   Label L_fold_tail, L_fold_128b, L_fold_512b, L_fold_512b_loop, L_fold_tail_loop;
6544 
6545   // For EVEX with VL and BW, provide a standard mask, VL = 128 will guide the merge
6546   // context for the registers used, where all instructions below are using 128-bit mode
6547   // On EVEX without VL and BW, these instructions will all be AVX.
6548   lea(table, ExternalAddress(StubRoutines::crc_table_addr()));
6549   notl(crc); // ~crc
6550   cmpl(len, 16);
6551   jcc(Assembler::less, L_tail);
6552 
6553   // Align buffer to 16 bytes
6554   movl(tmp, buf);
6555   andl(tmp, 0xF);
6556   jccb(Assembler::zero, L_aligned);
6557   subl(tmp,  16);
6558   addl(len, tmp);
6559 
6560   align(4);
6561   BIND(L_align_loop);
6562   movsbl(rax, Address(buf, 0)); // load byte with sign extension
6563   update_byte_crc32(crc, rax, table);
6564   increment(buf);
6565   incrementl(tmp);
6566   jccb(Assembler::less, L_align_loop);
6567 
6568   BIND(L_aligned);
6569   movl(tmp, len); // save
6570   shrl(len, 4);
6571   jcc(Assembler::zero, L_tail_restore);
6572 
6573   // Fold crc into first bytes of vector
6574   movdqa(xmm1, Address(buf, 0));
6575   movdl(rax, xmm1);
6576   xorl(crc, rax);
6577   if (VM_Version::supports_sse4_1()) {
6578     pinsrd(xmm1, crc, 0);
6579   } else {
6580     pinsrw(xmm1, crc, 0);
6581     shrl(crc, 16);
6582     pinsrw(xmm1, crc, 1);
6583   }
6584   addptr(buf, 16);
6585   subl(len, 4); // len &gt; 0
6586   jcc(Assembler::less, L_fold_tail);
6587 
6588   movdqa(xmm2, Address(buf,  0));
6589   movdqa(xmm3, Address(buf, 16));
6590   movdqa(xmm4, Address(buf, 32));
6591   addptr(buf, 48);
6592   subl(len, 3);
6593   jcc(Assembler::lessEqual, L_fold_512b);
6594 
6595   // Fold total 512 bits of polynomial on each iteration,
6596   // 128 bits per each of 4 parallel streams.
6597   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 32));
6598 
6599   align(32);
6600   BIND(L_fold_512b_loop);
6601   fold_128bit_crc32(xmm1, xmm0, xmm5, buf,  0);
6602   fold_128bit_crc32(xmm2, xmm0, xmm5, buf, 16);
6603   fold_128bit_crc32(xmm3, xmm0, xmm5, buf, 32);
6604   fold_128bit_crc32(xmm4, xmm0, xmm5, buf, 48);
6605   addptr(buf, 64);
6606   subl(len, 4);
6607   jcc(Assembler::greater, L_fold_512b_loop);
6608 
6609   // Fold 512 bits to 128 bits.
6610   BIND(L_fold_512b);
6611   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));
6612   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm2);
6613   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm3);
6614   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm4);
6615 
6616   // Fold the rest of 128 bits data chunks
6617   BIND(L_fold_tail);
6618   addl(len, 3);
6619   jccb(Assembler::lessEqual, L_fold_128b);
6620   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));
6621 
6622   BIND(L_fold_tail_loop);
6623   fold_128bit_crc32(xmm1, xmm0, xmm5, buf,  0);
6624   addptr(buf, 16);
6625   decrementl(len);
6626   jccb(Assembler::greater, L_fold_tail_loop);
6627 
6628   // Fold 128 bits in xmm1 down into 32 bits in crc register.
6629   BIND(L_fold_128b);
6630   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr()));
6631   if (UseAVX &gt; 0) {
6632     vpclmulqdq(xmm2, xmm0, xmm1, 0x1);
6633     vpand(xmm3, xmm0, xmm2, 0 /* vector_len */);
6634     vpclmulqdq(xmm0, xmm0, xmm3, 0x1);
6635   } else {
6636     movdqa(xmm2, xmm0);
6637     pclmulqdq(xmm2, xmm1, 0x1);
6638     movdqa(xmm3, xmm0);
6639     pand(xmm3, xmm2);
6640     pclmulqdq(xmm0, xmm3, 0x1);
6641   }
6642   psrldq(xmm1, 8);
6643   psrldq(xmm2, 4);
6644   pxor(xmm0, xmm1);
6645   pxor(xmm0, xmm2);
6646 
6647   // 8 8-bit folds to compute 32-bit CRC.
6648   for (int j = 0; j &lt; 4; j++) {
6649     fold_8bit_crc32(xmm0, table, xmm1, rax);
6650   }
6651   movdl(crc, xmm0); // mov 32 bits to general register
6652   for (int j = 0; j &lt; 4; j++) {
6653     fold_8bit_crc32(crc, table, rax);
6654   }
6655 
6656   BIND(L_tail_restore);
6657   movl(len, tmp); // restore
6658   BIND(L_tail);
6659   andl(len, 0xf);
6660   jccb(Assembler::zero, L_exit);
6661 
6662   // Fold the rest of bytes
6663   align(4);
6664   BIND(L_tail_loop);
6665   movsbl(rax, Address(buf, 0)); // load byte with sign extension
6666   update_byte_crc32(crc, rax, table);
6667   increment(buf);
6668   decrementl(len);
6669   jccb(Assembler::greater, L_tail_loop);
6670 
6671   BIND(L_exit);
6672   notl(crc); // ~c
6673 }
6674 
6675 #ifdef _LP64
6676 // Helper function for AVX 512 CRC32
6677 // Fold 512-bit data chunks
6678 void MacroAssembler::fold512bit_crc32_avx512(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf,
6679                                              Register pos, int offset) {
6680   evmovdquq(xmm3, Address(buf, pos, Address::times_1, offset), Assembler::AVX_512bit);
6681   evpclmulqdq(xtmp, xcrc, xK, 0x10, Assembler::AVX_512bit); // [123:64]
6682   evpclmulqdq(xmm2, xcrc, xK, 0x01, Assembler::AVX_512bit); // [63:0]
6683   evpxorq(xcrc, xtmp, xmm2, Assembler::AVX_512bit /* vector_len */);
6684   evpxorq(xcrc, xcrc, xmm3, Assembler::AVX_512bit /* vector_len */);
6685 }
6686 
6687 // Helper function for AVX 512 CRC32
6688 // Compute CRC32 for &lt; 256B buffers
6689 void MacroAssembler::kernel_crc32_avx512_256B(Register crc, Register buf, Register len, Register key, Register pos,
6690                                               Register tmp1, Register tmp2, Label&amp; L_barrett, Label&amp; L_16B_reduction_loop,
6691                                               Label&amp; L_get_last_two_xmms, Label&amp; L_128_done, Label&amp; L_cleanup) {
6692 
6693   Label L_less_than_32, L_exact_16_left, L_less_than_16_left;
6694   Label L_less_than_8_left, L_less_than_4_left, L_less_than_2_left, L_zero_left;
6695   Label L_only_less_than_4, L_only_less_than_3, L_only_less_than_2;
6696 
6697   // check if there is enough buffer to be able to fold 16B at a time
6698   cmpl(len, 32);
6699   jcc(Assembler::less, L_less_than_32);
6700 
6701   // if there is, load the constants
6702   movdqu(xmm10, Address(key, 1 * 16));    //rk1 and rk2 in xmm10
6703   movdl(xmm0, crc);                        // get the initial crc value
6704   movdqu(xmm7, Address(buf, pos, Address::times_1, 0 * 16)); //load the plaintext
6705   pxor(xmm7, xmm0);
6706 
6707   // update the buffer pointer
6708   addl(pos, 16);
6709   //update the counter.subtract 32 instead of 16 to save one instruction from the loop
6710   subl(len, 32);
6711   jmp(L_16B_reduction_loop);
6712 
6713   bind(L_less_than_32);
6714   //mov initial crc to the return value. this is necessary for zero - length buffers.
6715   movl(rax, crc);
6716   testl(len, len);
6717   jcc(Assembler::equal, L_cleanup);
6718 
6719   movdl(xmm0, crc);                        //get the initial crc value
6720 
6721   cmpl(len, 16);
6722   jcc(Assembler::equal, L_exact_16_left);
6723   jcc(Assembler::less, L_less_than_16_left);
6724 
6725   movdqu(xmm7, Address(buf, pos, Address::times_1, 0 * 16)); //load the plaintext
6726   pxor(xmm7, xmm0);                       //xor the initial crc value
6727   addl(pos, 16);
6728   subl(len, 16);
6729   movdqu(xmm10, Address(key, 1 * 16));    // rk1 and rk2 in xmm10
6730   jmp(L_get_last_two_xmms);
6731 
6732   bind(L_less_than_16_left);
6733   //use stack space to load data less than 16 bytes, zero - out the 16B in memory first.
6734   pxor(xmm1, xmm1);
6735   movptr(tmp1, rsp);
6736   movdqu(Address(tmp1, 0 * 16), xmm1);
6737 
6738   cmpl(len, 4);
6739   jcc(Assembler::less, L_only_less_than_4);
6740 
6741   //backup the counter value
6742   movl(tmp2, len);
6743   cmpl(len, 8);
6744   jcc(Assembler::less, L_less_than_8_left);
6745 
6746   //load 8 Bytes
6747   movq(rax, Address(buf, pos, Address::times_1, 0 * 16));
6748   movq(Address(tmp1, 0 * 16), rax);
6749   addptr(tmp1, 8);
6750   subl(len, 8);
6751   addl(pos, 8);
6752 
6753   bind(L_less_than_8_left);
6754   cmpl(len, 4);
6755   jcc(Assembler::less, L_less_than_4_left);
6756 
6757   //load 4 Bytes
6758   movl(rax, Address(buf, pos, Address::times_1, 0));
6759   movl(Address(tmp1, 0 * 16), rax);
6760   addptr(tmp1, 4);
6761   subl(len, 4);
6762   addl(pos, 4);
6763 
6764   bind(L_less_than_4_left);
6765   cmpl(len, 2);
6766   jcc(Assembler::less, L_less_than_2_left);
6767 
6768   // load 2 Bytes
6769   movw(rax, Address(buf, pos, Address::times_1, 0));
6770   movl(Address(tmp1, 0 * 16), rax);
6771   addptr(tmp1, 2);
6772   subl(len, 2);
6773   addl(pos, 2);
6774 
6775   bind(L_less_than_2_left);
6776   cmpl(len, 1);
6777   jcc(Assembler::less, L_zero_left);
6778 
6779   // load 1 Byte
6780   movb(rax, Address(buf, pos, Address::times_1, 0));
6781   movb(Address(tmp1, 0 * 16), rax);
6782 
6783   bind(L_zero_left);
6784   movdqu(xmm7, Address(rsp, 0));
6785   pxor(xmm7, xmm0);                       //xor the initial crc value
6786 
6787   lea(rax, ExternalAddress(StubRoutines::x86::shuf_table_crc32_avx512_addr()));
6788   movdqu(xmm0, Address(rax, tmp2));
6789   pshufb(xmm7, xmm0);
6790   jmp(L_128_done);
6791 
6792   bind(L_exact_16_left);
6793   movdqu(xmm7, Address(buf, pos, Address::times_1, 0));
6794   pxor(xmm7, xmm0);                       //xor the initial crc value
6795   jmp(L_128_done);
6796 
6797   bind(L_only_less_than_4);
6798   cmpl(len, 3);
6799   jcc(Assembler::less, L_only_less_than_3);
6800 
6801   // load 3 Bytes
6802   movb(rax, Address(buf, pos, Address::times_1, 0));
6803   movb(Address(tmp1, 0), rax);
6804 
6805   movb(rax, Address(buf, pos, Address::times_1, 1));
6806   movb(Address(tmp1, 1), rax);
6807 
6808   movb(rax, Address(buf, pos, Address::times_1, 2));
6809   movb(Address(tmp1, 2), rax);
6810 
6811   movdqu(xmm7, Address(rsp, 0));
6812   pxor(xmm7, xmm0);                     //xor the initial crc value
6813 
6814   pslldq(xmm7, 0x5);
6815   jmp(L_barrett);
6816   bind(L_only_less_than_3);
6817   cmpl(len, 2);
6818   jcc(Assembler::less, L_only_less_than_2);
6819 
6820   // load 2 Bytes
6821   movb(rax, Address(buf, pos, Address::times_1, 0));
6822   movb(Address(tmp1, 0), rax);
6823 
6824   movb(rax, Address(buf, pos, Address::times_1, 1));
6825   movb(Address(tmp1, 1), rax);
6826 
6827   movdqu(xmm7, Address(rsp, 0));
6828   pxor(xmm7, xmm0);                     //xor the initial crc value
6829 
6830   pslldq(xmm7, 0x6);
6831   jmp(L_barrett);
6832 
6833   bind(L_only_less_than_2);
6834   //load 1 Byte
6835   movb(rax, Address(buf, pos, Address::times_1, 0));
6836   movb(Address(tmp1, 0), rax);
6837 
6838   movdqu(xmm7, Address(rsp, 0));
6839   pxor(xmm7, xmm0);                     //xor the initial crc value
6840 
6841   pslldq(xmm7, 0x7);
6842 }
6843 
6844 /**
6845 * Compute CRC32 using AVX512 instructions
6846 * param crc   register containing existing CRC (32-bit)
6847 * param buf   register pointing to input byte buffer (byte*)
6848 * param len   register containing number of bytes
6849 * param tmp1  scratch register
6850 * param tmp2  scratch register
6851 * return rax  result register
6852 */
6853 void MacroAssembler::kernel_crc32_avx512(Register crc, Register buf, Register len, Register key, Register tmp1, Register tmp2) {
6854   assert_different_registers(crc, buf, len, key, tmp1, tmp2, rax);
6855 
6856   Label L_tail, L_tail_restore, L_tail_loop, L_exit, L_align_loop, L_aligned;
6857   Label L_fold_tail, L_fold_128b, L_fold_512b, L_fold_512b_loop, L_fold_tail_loop;
6858   Label L_less_than_256, L_fold_128_B_loop, L_fold_256_B_loop;
6859   Label L_fold_128_B_register, L_final_reduction_for_128, L_16B_reduction_loop;
6860   Label L_128_done, L_get_last_two_xmms, L_barrett, L_cleanup;
6861 
6862   const Register pos = r12;
6863   push(r12);
6864   subptr(rsp, 16 * 2 + 8);
6865 
6866   // For EVEX with VL and BW, provide a standard mask, VL = 128 will guide the merge
6867   // context for the registers used, where all instructions below are using 128-bit mode
6868   // On EVEX without VL and BW, these instructions will all be AVX.
6869   lea(key, ExternalAddress(StubRoutines::x86::crc_table_avx512_addr()));
6870   notl(crc);
6871   movl(pos, 0);
6872 
6873   // check if smaller than 256B
6874   cmpl(len, 256);
6875   jcc(Assembler::less, L_less_than_256);
6876 
6877   // load the initial crc value
6878   movdl(xmm10, crc);
6879 
6880   // receive the initial 64B data, xor the initial crc value
6881   evmovdquq(xmm0, Address(buf, pos, Address::times_1, 0 * 64), Assembler::AVX_512bit);
6882   evmovdquq(xmm4, Address(buf, pos, Address::times_1, 1 * 64), Assembler::AVX_512bit);
6883   evpxorq(xmm0, xmm0, xmm10, Assembler::AVX_512bit);
6884   evbroadcasti32x4(xmm10, Address(key, 2 * 16), Assembler::AVX_512bit); //zmm10 has rk3 and rk4
6885 
6886   subl(len, 256);
6887   cmpl(len, 256);
6888   jcc(Assembler::less, L_fold_128_B_loop);
6889 
6890   evmovdquq(xmm7, Address(buf, pos, Address::times_1, 2 * 64), Assembler::AVX_512bit);
6891   evmovdquq(xmm8, Address(buf, pos, Address::times_1, 3 * 64), Assembler::AVX_512bit);
6892   evbroadcasti32x4(xmm16, Address(key, 0 * 16), Assembler::AVX_512bit); //zmm16 has rk-1 and rk-2
6893   subl(len, 256);
6894 
6895   bind(L_fold_256_B_loop);
6896   addl(pos, 256);
6897   fold512bit_crc32_avx512(xmm0, xmm16, xmm1, buf, pos, 0 * 64);
6898   fold512bit_crc32_avx512(xmm4, xmm16, xmm1, buf, pos, 1 * 64);
6899   fold512bit_crc32_avx512(xmm7, xmm16, xmm1, buf, pos, 2 * 64);
6900   fold512bit_crc32_avx512(xmm8, xmm16, xmm1, buf, pos, 3 * 64);
6901 
6902   subl(len, 256);
6903   jcc(Assembler::greaterEqual, L_fold_256_B_loop);
6904 
6905   // Fold 256 into 128
6906   addl(pos, 256);
6907   evpclmulqdq(xmm1, xmm0, xmm10, 0x01, Assembler::AVX_512bit);
6908   evpclmulqdq(xmm2, xmm0, xmm10, 0x10, Assembler::AVX_512bit);
6909   vpternlogq(xmm7, 0x96, xmm1, xmm2, Assembler::AVX_512bit); // xor ABC
6910 
6911   evpclmulqdq(xmm5, xmm4, xmm10, 0x01, Assembler::AVX_512bit);
6912   evpclmulqdq(xmm6, xmm4, xmm10, 0x10, Assembler::AVX_512bit);
6913   vpternlogq(xmm8, 0x96, xmm5, xmm6, Assembler::AVX_512bit); // xor ABC
6914 
6915   evmovdquq(xmm0, xmm7, Assembler::AVX_512bit);
6916   evmovdquq(xmm4, xmm8, Assembler::AVX_512bit);
6917 
6918   addl(len, 128);
6919   jmp(L_fold_128_B_register);
6920 
6921   // at this section of the code, there is 128 * x + y(0 &lt;= y&lt;128) bytes of buffer.The fold_128_B_loop
6922   // loop will fold 128B at a time until we have 128 + y Bytes of buffer
6923 
6924   // fold 128B at a time.This section of the code folds 8 xmm registers in parallel
6925   bind(L_fold_128_B_loop);
6926   addl(pos, 128);
6927   fold512bit_crc32_avx512(xmm0, xmm10, xmm1, buf, pos, 0 * 64);
6928   fold512bit_crc32_avx512(xmm4, xmm10, xmm1, buf, pos, 1 * 64);
6929 
6930   subl(len, 128);
6931   jcc(Assembler::greaterEqual, L_fold_128_B_loop);
6932 
6933   addl(pos, 128);
6934 
6935   // at this point, the buffer pointer is pointing at the last y Bytes of the buffer, where 0 &lt;= y &lt; 128
6936   // the 128B of folded data is in 8 of the xmm registers : xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7
6937   bind(L_fold_128_B_register);
6938   evmovdquq(xmm16, Address(key, 5 * 16), Assembler::AVX_512bit); // multiply by rk9-rk16
6939   evmovdquq(xmm11, Address(key, 9 * 16), Assembler::AVX_512bit); // multiply by rk17-rk20, rk1,rk2, 0,0
6940   evpclmulqdq(xmm1, xmm0, xmm16, 0x01, Assembler::AVX_512bit);
6941   evpclmulqdq(xmm2, xmm0, xmm16, 0x10, Assembler::AVX_512bit);
6942   // save last that has no multiplicand
6943   vextracti64x2(xmm7, xmm4, 3);
6944 
6945   evpclmulqdq(xmm5, xmm4, xmm11, 0x01, Assembler::AVX_512bit);
6946   evpclmulqdq(xmm6, xmm4, xmm11, 0x10, Assembler::AVX_512bit);
6947   // Needed later in reduction loop
6948   movdqu(xmm10, Address(key, 1 * 16));
6949   vpternlogq(xmm1, 0x96, xmm2, xmm5, Assembler::AVX_512bit); // xor ABC
6950   vpternlogq(xmm1, 0x96, xmm6, xmm7, Assembler::AVX_512bit); // xor ABC
6951 
6952   // Swap 1,0,3,2 - 01 00 11 10
6953   evshufi64x2(xmm8, xmm1, xmm1, 0x4e, Assembler::AVX_512bit);
6954   evpxorq(xmm8, xmm8, xmm1, Assembler::AVX_256bit);
6955   vextracti128(xmm5, xmm8, 1);
6956   evpxorq(xmm7, xmm5, xmm8, Assembler::AVX_128bit);
6957 
6958   // instead of 128, we add 128 - 16 to the loop counter to save 1 instruction from the loop
6959   // instead of a cmp instruction, we use the negative flag with the jl instruction
6960   addl(len, 128 - 16);
6961   jcc(Assembler::less, L_final_reduction_for_128);
6962 
6963   bind(L_16B_reduction_loop);
6964   vpclmulqdq(xmm8, xmm7, xmm10, 0x1);
6965   vpclmulqdq(xmm7, xmm7, xmm10, 0x10);
6966   vpxor(xmm7, xmm7, xmm8, Assembler::AVX_128bit);
6967   movdqu(xmm0, Address(buf, pos, Address::times_1, 0 * 16));
6968   vpxor(xmm7, xmm7, xmm0, Assembler::AVX_128bit);
6969   addl(pos, 16);
6970   subl(len, 16);
6971   jcc(Assembler::greaterEqual, L_16B_reduction_loop);
6972 
6973   bind(L_final_reduction_for_128);
6974   addl(len, 16);
6975   jcc(Assembler::equal, L_128_done);
6976 
6977   bind(L_get_last_two_xmms);
6978   movdqu(xmm2, xmm7);
6979   addl(pos, len);
6980   movdqu(xmm1, Address(buf, pos, Address::times_1, -16));
6981   subl(pos, len);
6982 
6983   // get rid of the extra data that was loaded before
6984   // load the shift constant
6985   lea(rax, ExternalAddress(StubRoutines::x86::shuf_table_crc32_avx512_addr()));
6986   movdqu(xmm0, Address(rax, len));
6987   addl(rax, len);
6988 
6989   vpshufb(xmm7, xmm7, xmm0, Assembler::AVX_128bit);
6990   //Change mask to 512
6991   vpxor(xmm0, xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_avx512_addr() + 2 * 16), Assembler::AVX_128bit, tmp2);
6992   vpshufb(xmm2, xmm2, xmm0, Assembler::AVX_128bit);
6993 
6994   blendvpb(xmm2, xmm2, xmm1, xmm0, Assembler::AVX_128bit);
6995   vpclmulqdq(xmm8, xmm7, xmm10, 0x1);
6996   vpclmulqdq(xmm7, xmm7, xmm10, 0x10);
6997   vpxor(xmm7, xmm7, xmm8, Assembler::AVX_128bit);
6998   vpxor(xmm7, xmm7, xmm2, Assembler::AVX_128bit);
6999 
7000   bind(L_128_done);
7001   // compute crc of a 128-bit value
7002   movdqu(xmm10, Address(key, 3 * 16));
7003   movdqu(xmm0, xmm7);
7004 
7005   // 64b fold
7006   vpclmulqdq(xmm7, xmm7, xmm10, 0x0);
7007   vpsrldq(xmm0, xmm0, 0x8, Assembler::AVX_128bit);
7008   vpxor(xmm7, xmm7, xmm0, Assembler::AVX_128bit);
7009 
7010   // 32b fold
7011   movdqu(xmm0, xmm7);
7012   vpslldq(xmm7, xmm7, 0x4, Assembler::AVX_128bit);
7013   vpclmulqdq(xmm7, xmm7, xmm10, 0x10);
7014   vpxor(xmm7, xmm7, xmm0, Assembler::AVX_128bit);
7015   jmp(L_barrett);
7016 
7017   bind(L_less_than_256);
7018   kernel_crc32_avx512_256B(crc, buf, len, key, pos, tmp1, tmp2, L_barrett, L_16B_reduction_loop, L_get_last_two_xmms, L_128_done, L_cleanup);
7019 
7020   //barrett reduction
7021   bind(L_barrett);
7022   vpand(xmm7, xmm7, ExternalAddress(StubRoutines::x86::crc_by128_masks_avx512_addr() + 1 * 16), Assembler::AVX_128bit, tmp2);
7023   movdqu(xmm1, xmm7);
7024   movdqu(xmm2, xmm7);
7025   movdqu(xmm10, Address(key, 4 * 16));
7026 
7027   pclmulqdq(xmm7, xmm10, 0x0);
7028   pxor(xmm7, xmm2);
7029   vpand(xmm7, xmm7, ExternalAddress(StubRoutines::x86::crc_by128_masks_avx512_addr()), Assembler::AVX_128bit, tmp2);
7030   movdqu(xmm2, xmm7);
7031   pclmulqdq(xmm7, xmm10, 0x10);
7032   pxor(xmm7, xmm2);
7033   pxor(xmm7, xmm1);
7034   pextrd(crc, xmm7, 2);
7035 
7036   bind(L_cleanup);
7037   notl(crc); // ~c
7038   addptr(rsp, 16 * 2 + 8);
7039   pop(r12);
7040 }
7041 
7042 // S. Gueron / Information Processing Letters 112 (2012) 184
7043 // Algorithm 4: Computing carry-less multiplication using a precomputed lookup table.
7044 // Input: A 32 bit value B = [byte3, byte2, byte1, byte0].
7045 // Output: the 64-bit carry-less product of B * CONST
7046 void MacroAssembler::crc32c_ipl_alg4(Register in, uint32_t n,
7047                                      Register tmp1, Register tmp2, Register tmp3) {
7048   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
7049   if (n &gt; 0) {
7050     addq(tmp3, n * 256 * 8);
7051   }
7052   //    Q1 = TABLEExt[n][B &amp; 0xFF];
7053   movl(tmp1, in);
7054   andl(tmp1, 0x000000FF);
7055   shll(tmp1, 3);
7056   addq(tmp1, tmp3);
7057   movq(tmp1, Address(tmp1, 0));
7058 
7059   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
7060   movl(tmp2, in);
7061   shrl(tmp2, 8);
7062   andl(tmp2, 0x000000FF);
7063   shll(tmp2, 3);
7064   addq(tmp2, tmp3);
7065   movq(tmp2, Address(tmp2, 0));
7066 
7067   shlq(tmp2, 8);
7068   xorq(tmp1, tmp2);
7069 
7070   //    Q3 = TABLEExt[n][B &gt;&gt; 16 &amp; 0xFF];
7071   movl(tmp2, in);
7072   shrl(tmp2, 16);
7073   andl(tmp2, 0x000000FF);
7074   shll(tmp2, 3);
7075   addq(tmp2, tmp3);
7076   movq(tmp2, Address(tmp2, 0));
7077 
7078   shlq(tmp2, 16);
7079   xorq(tmp1, tmp2);
7080 
7081   //    Q4 = TABLEExt[n][B &gt;&gt; 24 &amp; 0xFF];
7082   shrl(in, 24);
7083   andl(in, 0x000000FF);
7084   shll(in, 3);
7085   addq(in, tmp3);
7086   movq(in, Address(in, 0));
7087 
7088   shlq(in, 24);
7089   xorq(in, tmp1);
7090   //    return Q1 ^ Q2 &lt;&lt; 8 ^ Q3 &lt;&lt; 16 ^ Q4 &lt;&lt; 24;
7091 }
7092 
7093 void MacroAssembler::crc32c_pclmulqdq(XMMRegister w_xtmp1,
7094                                       Register in_out,
7095                                       uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
7096                                       XMMRegister w_xtmp2,
7097                                       Register tmp1,
7098                                       Register n_tmp2, Register n_tmp3) {
7099   if (is_pclmulqdq_supported) {
7100     movdl(w_xtmp1, in_out); // modified blindly
7101 
7102     movl(tmp1, const_or_pre_comp_const_index);
7103     movdl(w_xtmp2, tmp1);
7104     pclmulqdq(w_xtmp1, w_xtmp2, 0);
7105 
7106     movdq(in_out, w_xtmp1);
7107   } else {
7108     crc32c_ipl_alg4(in_out, const_or_pre_comp_const_index, tmp1, n_tmp2, n_tmp3);
7109   }
7110 }
7111 
7112 // Recombination Alternative 2: No bit-reflections
7113 // T1 = (CRC_A * U1) &lt;&lt; 1
7114 // T2 = (CRC_B * U2) &lt;&lt; 1
7115 // C1 = T1 &gt;&gt; 32
7116 // C2 = T2 &gt;&gt; 32
7117 // T1 = T1 &amp; 0xFFFFFFFF
7118 // T2 = T2 &amp; 0xFFFFFFFF
7119 // T1 = CRC32(0, T1)
7120 // T2 = CRC32(0, T2)
7121 // C1 = C1 ^ T1
7122 // C2 = C2 ^ T2
7123 // CRC = C1 ^ C2 ^ CRC_C
7124 void MacroAssembler::crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
7125                                      XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7126                                      Register tmp1, Register tmp2,
7127                                      Register n_tmp3) {
7128   crc32c_pclmulqdq(w_xtmp1, in_out, const_or_pre_comp_const_index_u1, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7129   crc32c_pclmulqdq(w_xtmp2, in1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7130   shlq(in_out, 1);
7131   movl(tmp1, in_out);
7132   shrq(in_out, 32);
7133   xorl(tmp2, tmp2);
7134   crc32(tmp2, tmp1, 4);
7135   xorl(in_out, tmp2); // we don&#39;t care about upper 32 bit contents here
7136   shlq(in1, 1);
7137   movl(tmp1, in1);
7138   shrq(in1, 32);
7139   xorl(tmp2, tmp2);
7140   crc32(tmp2, tmp1, 4);
7141   xorl(in1, tmp2);
7142   xorl(in_out, in1);
7143   xorl(in_out, in2);
7144 }
7145 
7146 // Set N to predefined value
7147 // Subtract from a lenght of a buffer
7148 // execute in a loop:
7149 // CRC_A = 0xFFFFFFFF, CRC_B = 0, CRC_C = 0
7150 // for i = 1 to N do
7151 //  CRC_A = CRC32(CRC_A, A[i])
7152 //  CRC_B = CRC32(CRC_B, B[i])
7153 //  CRC_C = CRC32(CRC_C, C[i])
7154 // end for
7155 // Recombine
7156 void MacroAssembler::crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
7157                                        Register in_out1, Register in_out2, Register in_out3,
7158                                        Register tmp1, Register tmp2, Register tmp3,
7159                                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7160                                        Register tmp4, Register tmp5,
7161                                        Register n_tmp6) {
7162   Label L_processPartitions;
7163   Label L_processPartition;
7164   Label L_exit;
7165 
7166   bind(L_processPartitions);
7167   cmpl(in_out1, 3 * size);
7168   jcc(Assembler::less, L_exit);
7169     xorl(tmp1, tmp1);
7170     xorl(tmp2, tmp2);
7171     movq(tmp3, in_out2);
7172     addq(tmp3, size);
7173 
7174     bind(L_processPartition);
7175       crc32(in_out3, Address(in_out2, 0), 8);
7176       crc32(tmp1, Address(in_out2, size), 8);
7177       crc32(tmp2, Address(in_out2, size * 2), 8);
7178       addq(in_out2, 8);
7179       cmpq(in_out2, tmp3);
7180       jcc(Assembler::less, L_processPartition);
7181     crc32c_rec_alt2(const_or_pre_comp_const_index_u1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, in_out3, tmp1, tmp2,
7182             w_xtmp1, w_xtmp2, w_xtmp3,
7183             tmp4, tmp5,
7184             n_tmp6);
7185     addq(in_out2, 2 * size);
7186     subl(in_out1, 3 * size);
7187     jmp(L_processPartitions);
7188 
7189   bind(L_exit);
7190 }
7191 #else
7192 void MacroAssembler::crc32c_ipl_alg4(Register in_out, uint32_t n,
7193                                      Register tmp1, Register tmp2, Register tmp3,
7194                                      XMMRegister xtmp1, XMMRegister xtmp2) {
7195   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
7196   if (n &gt; 0) {
7197     addl(tmp3, n * 256 * 8);
7198   }
7199   //    Q1 = TABLEExt[n][B &amp; 0xFF];
7200   movl(tmp1, in_out);
7201   andl(tmp1, 0x000000FF);
7202   shll(tmp1, 3);
7203   addl(tmp1, tmp3);
7204   movq(xtmp1, Address(tmp1, 0));
7205 
7206   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
7207   movl(tmp2, in_out);
7208   shrl(tmp2, 8);
7209   andl(tmp2, 0x000000FF);
7210   shll(tmp2, 3);
7211   addl(tmp2, tmp3);
7212   movq(xtmp2, Address(tmp2, 0));
7213 
7214   psllq(xtmp2, 8);
7215   pxor(xtmp1, xtmp2);
7216 
7217   //    Q3 = TABLEExt[n][B &gt;&gt; 16 &amp; 0xFF];
7218   movl(tmp2, in_out);
7219   shrl(tmp2, 16);
7220   andl(tmp2, 0x000000FF);
7221   shll(tmp2, 3);
7222   addl(tmp2, tmp3);
7223   movq(xtmp2, Address(tmp2, 0));
7224 
7225   psllq(xtmp2, 16);
7226   pxor(xtmp1, xtmp2);
7227 
7228   //    Q4 = TABLEExt[n][B &gt;&gt; 24 &amp; 0xFF];
7229   shrl(in_out, 24);
7230   andl(in_out, 0x000000FF);
7231   shll(in_out, 3);
7232   addl(in_out, tmp3);
7233   movq(xtmp2, Address(in_out, 0));
7234 
7235   psllq(xtmp2, 24);
7236   pxor(xtmp1, xtmp2); // Result in CXMM
7237   //    return Q1 ^ Q2 &lt;&lt; 8 ^ Q3 &lt;&lt; 16 ^ Q4 &lt;&lt; 24;
7238 }
7239 
7240 void MacroAssembler::crc32c_pclmulqdq(XMMRegister w_xtmp1,
7241                                       Register in_out,
7242                                       uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
7243                                       XMMRegister w_xtmp2,
7244                                       Register tmp1,
7245                                       Register n_tmp2, Register n_tmp3) {
7246   if (is_pclmulqdq_supported) {
7247     movdl(w_xtmp1, in_out);
7248 
7249     movl(tmp1, const_or_pre_comp_const_index);
7250     movdl(w_xtmp2, tmp1);
7251     pclmulqdq(w_xtmp1, w_xtmp2, 0);
7252     // Keep result in XMM since GPR is 32 bit in length
7253   } else {
7254     crc32c_ipl_alg4(in_out, const_or_pre_comp_const_index, tmp1, n_tmp2, n_tmp3, w_xtmp1, w_xtmp2);
7255   }
7256 }
7257 
7258 void MacroAssembler::crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
7259                                      XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7260                                      Register tmp1, Register tmp2,
7261                                      Register n_tmp3) {
7262   crc32c_pclmulqdq(w_xtmp1, in_out, const_or_pre_comp_const_index_u1, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7263   crc32c_pclmulqdq(w_xtmp2, in1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7264 
7265   psllq(w_xtmp1, 1);
7266   movdl(tmp1, w_xtmp1);
7267   psrlq(w_xtmp1, 32);
7268   movdl(in_out, w_xtmp1);
7269 
7270   xorl(tmp2, tmp2);
7271   crc32(tmp2, tmp1, 4);
7272   xorl(in_out, tmp2);
7273 
7274   psllq(w_xtmp2, 1);
7275   movdl(tmp1, w_xtmp2);
7276   psrlq(w_xtmp2, 32);
7277   movdl(in1, w_xtmp2);
7278 
7279   xorl(tmp2, tmp2);
7280   crc32(tmp2, tmp1, 4);
7281   xorl(in1, tmp2);
7282   xorl(in_out, in1);
7283   xorl(in_out, in2);
7284 }
7285 
7286 void MacroAssembler::crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
7287                                        Register in_out1, Register in_out2, Register in_out3,
7288                                        Register tmp1, Register tmp2, Register tmp3,
7289                                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7290                                        Register tmp4, Register tmp5,
7291                                        Register n_tmp6) {
7292   Label L_processPartitions;
7293   Label L_processPartition;
7294   Label L_exit;
7295 
7296   bind(L_processPartitions);
7297   cmpl(in_out1, 3 * size);
7298   jcc(Assembler::less, L_exit);
7299     xorl(tmp1, tmp1);
7300     xorl(tmp2, tmp2);
7301     movl(tmp3, in_out2);
7302     addl(tmp3, size);
7303 
7304     bind(L_processPartition);
7305       crc32(in_out3, Address(in_out2, 0), 4);
7306       crc32(tmp1, Address(in_out2, size), 4);
7307       crc32(tmp2, Address(in_out2, size*2), 4);
7308       crc32(in_out3, Address(in_out2, 0+4), 4);
7309       crc32(tmp1, Address(in_out2, size+4), 4);
7310       crc32(tmp2, Address(in_out2, size*2+4), 4);
7311       addl(in_out2, 8);
7312       cmpl(in_out2, tmp3);
7313       jcc(Assembler::less, L_processPartition);
7314 
7315         push(tmp3);
7316         push(in_out1);
7317         push(in_out2);
7318         tmp4 = tmp3;
7319         tmp5 = in_out1;
7320         n_tmp6 = in_out2;
7321 
7322       crc32c_rec_alt2(const_or_pre_comp_const_index_u1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, in_out3, tmp1, tmp2,
7323             w_xtmp1, w_xtmp2, w_xtmp3,
7324             tmp4, tmp5,
7325             n_tmp6);
7326 
7327         pop(in_out2);
7328         pop(in_out1);
7329         pop(tmp3);
7330 
7331     addl(in_out2, 2 * size);
7332     subl(in_out1, 3 * size);
7333     jmp(L_processPartitions);
7334 
7335   bind(L_exit);
7336 }
7337 #endif //LP64
7338 
7339 #ifdef _LP64
7340 // Algorithm 2: Pipelined usage of the CRC32 instruction.
7341 // Input: A buffer I of L bytes.
7342 // Output: the CRC32C value of the buffer.
7343 // Notations:
7344 // Write L = 24N + r, with N = floor (L/24).
7345 // r = L mod 24 (0 &lt;= r &lt; 24).
7346 // Consider I as the concatenation of A|B|C|R, where A, B, C, each,
7347 // N quadwords, and R consists of r bytes.
7348 // A[j] = I [8j+7:8j], j= 0, 1, ..., N-1
7349 // B[j] = I [N + 8j+7:N + 8j], j= 0, 1, ..., N-1
7350 // C[j] = I [2N + 8j+7:2N + 8j], j= 0, 1, ..., N-1
7351 // if r &gt; 0 R[j] = I [3N +j], j= 0, 1, ...,r-1
7352 void MacroAssembler::crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
7353                                           Register tmp1, Register tmp2, Register tmp3,
7354                                           Register tmp4, Register tmp5, Register tmp6,
7355                                           XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7356                                           bool is_pclmulqdq_supported) {
7357   uint32_t const_or_pre_comp_const_index[CRC32C_NUM_PRECOMPUTED_CONSTANTS];
7358   Label L_wordByWord;
7359   Label L_byteByByteProlog;
7360   Label L_byteByByte;
7361   Label L_exit;
7362 
7363   if (is_pclmulqdq_supported ) {
7364     const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;
7365     const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr+1);
7366 
7367     const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);
7368     const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);
7369 
7370     const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);
7371     const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);
7372     assert((CRC32C_NUM_PRECOMPUTED_CONSTANTS - 1 ) == 5, &quot;Checking whether you declared all of the constants based on the number of \&quot;chunks\&quot;&quot;);
7373   } else {
7374     const_or_pre_comp_const_index[0] = 1;
7375     const_or_pre_comp_const_index[1] = 0;
7376 
7377     const_or_pre_comp_const_index[2] = 3;
7378     const_or_pre_comp_const_index[3] = 2;
7379 
7380     const_or_pre_comp_const_index[4] = 5;
7381     const_or_pre_comp_const_index[5] = 4;
7382    }
7383   crc32c_proc_chunk(CRC32C_HIGH, const_or_pre_comp_const_index[0], const_or_pre_comp_const_index[1], is_pclmulqdq_supported,
7384                     in2, in1, in_out,
7385                     tmp1, tmp2, tmp3,
7386                     w_xtmp1, w_xtmp2, w_xtmp3,
7387                     tmp4, tmp5,
7388                     tmp6);
7389   crc32c_proc_chunk(CRC32C_MIDDLE, const_or_pre_comp_const_index[2], const_or_pre_comp_const_index[3], is_pclmulqdq_supported,
7390                     in2, in1, in_out,
7391                     tmp1, tmp2, tmp3,
7392                     w_xtmp1, w_xtmp2, w_xtmp3,
7393                     tmp4, tmp5,
7394                     tmp6);
7395   crc32c_proc_chunk(CRC32C_LOW, const_or_pre_comp_const_index[4], const_or_pre_comp_const_index[5], is_pclmulqdq_supported,
7396                     in2, in1, in_out,
7397                     tmp1, tmp2, tmp3,
7398                     w_xtmp1, w_xtmp2, w_xtmp3,
7399                     tmp4, tmp5,
7400                     tmp6);
7401   movl(tmp1, in2);
7402   andl(tmp1, 0x00000007);
7403   negl(tmp1);
7404   addl(tmp1, in2);
7405   addq(tmp1, in1);
7406 
7407   BIND(L_wordByWord);
7408   cmpq(in1, tmp1);
7409   jcc(Assembler::greaterEqual, L_byteByByteProlog);
7410     crc32(in_out, Address(in1, 0), 4);
7411     addq(in1, 4);
7412     jmp(L_wordByWord);
7413 
7414   BIND(L_byteByByteProlog);
7415   andl(in2, 0x00000007);
7416   movl(tmp2, 1);
7417 
7418   BIND(L_byteByByte);
7419   cmpl(tmp2, in2);
7420   jccb(Assembler::greater, L_exit);
7421     crc32(in_out, Address(in1, 0), 1);
7422     incq(in1);
7423     incl(tmp2);
7424     jmp(L_byteByByte);
7425 
7426   BIND(L_exit);
7427 }
7428 #else
7429 void MacroAssembler::crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
7430                                           Register tmp1, Register  tmp2, Register tmp3,
7431                                           Register tmp4, Register  tmp5, Register tmp6,
7432                                           XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7433                                           bool is_pclmulqdq_supported) {
7434   uint32_t const_or_pre_comp_const_index[CRC32C_NUM_PRECOMPUTED_CONSTANTS];
7435   Label L_wordByWord;
7436   Label L_byteByByteProlog;
7437   Label L_byteByByte;
7438   Label L_exit;
7439 
7440   if (is_pclmulqdq_supported) {
7441     const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;
7442     const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 1);
7443 
7444     const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);
7445     const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);
7446 
7447     const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);
7448     const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);
7449   } else {
7450     const_or_pre_comp_const_index[0] = 1;
7451     const_or_pre_comp_const_index[1] = 0;
7452 
7453     const_or_pre_comp_const_index[2] = 3;
7454     const_or_pre_comp_const_index[3] = 2;
7455 
7456     const_or_pre_comp_const_index[4] = 5;
7457     const_or_pre_comp_const_index[5] = 4;
7458   }
7459   crc32c_proc_chunk(CRC32C_HIGH, const_or_pre_comp_const_index[0], const_or_pre_comp_const_index[1], is_pclmulqdq_supported,
7460                     in2, in1, in_out,
7461                     tmp1, tmp2, tmp3,
7462                     w_xtmp1, w_xtmp2, w_xtmp3,
7463                     tmp4, tmp5,
7464                     tmp6);
7465   crc32c_proc_chunk(CRC32C_MIDDLE, const_or_pre_comp_const_index[2], const_or_pre_comp_const_index[3], is_pclmulqdq_supported,
7466                     in2, in1, in_out,
7467                     tmp1, tmp2, tmp3,
7468                     w_xtmp1, w_xtmp2, w_xtmp3,
7469                     tmp4, tmp5,
7470                     tmp6);
7471   crc32c_proc_chunk(CRC32C_LOW, const_or_pre_comp_const_index[4], const_or_pre_comp_const_index[5], is_pclmulqdq_supported,
7472                     in2, in1, in_out,
7473                     tmp1, tmp2, tmp3,
7474                     w_xtmp1, w_xtmp2, w_xtmp3,
7475                     tmp4, tmp5,
7476                     tmp6);
7477   movl(tmp1, in2);
7478   andl(tmp1, 0x00000007);
7479   negl(tmp1);
7480   addl(tmp1, in2);
7481   addl(tmp1, in1);
7482 
7483   BIND(L_wordByWord);
7484   cmpl(in1, tmp1);
7485   jcc(Assembler::greaterEqual, L_byteByByteProlog);
7486     crc32(in_out, Address(in1,0), 4);
7487     addl(in1, 4);
7488     jmp(L_wordByWord);
7489 
7490   BIND(L_byteByByteProlog);
7491   andl(in2, 0x00000007);
7492   movl(tmp2, 1);
7493 
7494   BIND(L_byteByByte);
7495   cmpl(tmp2, in2);
7496   jccb(Assembler::greater, L_exit);
7497     movb(tmp1, Address(in1, 0));
7498     crc32(in_out, tmp1, 1);
7499     incl(in1);
7500     incl(tmp2);
7501     jmp(L_byteByByte);
7502 
7503   BIND(L_exit);
7504 }
7505 #endif // LP64
7506 #undef BIND
7507 #undef BLOCK_COMMENT
7508 
7509 // Compress char[] array to byte[].
7510 //   ..\jdk\src\java.base\share\classes\java\lang\StringUTF16.java
7511 //   @HotSpotIntrinsicCandidate
7512 //   private static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {
7513 //     for (int i = 0; i &lt; len; i++) {
7514 //       int c = src[srcOff++];
7515 //       if (c &gt;&gt;&gt; 8 != 0) {
7516 //         return 0;
7517 //       }
7518 //       dst[dstOff++] = (byte)c;
7519 //     }
7520 //     return len;
7521 //   }
7522 void MacroAssembler::char_array_compress(Register src, Register dst, Register len,
7523   XMMRegister tmp1Reg, XMMRegister tmp2Reg,
7524   XMMRegister tmp3Reg, XMMRegister tmp4Reg,
7525   Register tmp5, Register result) {
7526   Label copy_chars_loop, return_length, return_zero, done;
7527 
7528   // rsi: src
7529   // rdi: dst
7530   // rdx: len
7531   // rcx: tmp5
7532   // rax: result
7533 
7534   // rsi holds start addr of source char[] to be compressed
7535   // rdi holds start addr of destination byte[]
7536   // rdx holds length
7537 
7538   assert(len != result, &quot;&quot;);
7539 
7540   // save length for return
7541   push(len);
7542 
7543   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp; // AVX512
7544     VM_Version::supports_avx512vlbw() &amp;&amp;
7545     VM_Version::supports_bmi2()) {
7546 
7547     Label copy_32_loop, copy_loop_tail, below_threshold;
7548 
7549     // alignment
7550     Label post_alignment;
7551 
7552     // if length of the string is less than 16, handle it in an old fashioned way
7553     testl(len, -32);
7554     jcc(Assembler::zero, below_threshold);
7555 
7556     // First check whether a character is compressable ( &lt;= 0xFF).
7557     // Create mask to test for Unicode chars inside zmm vector
7558     movl(result, 0x00FF);
7559     evpbroadcastw(tmp2Reg, result, Assembler::AVX_512bit);
7560 
7561     testl(len, -64);
7562     jcc(Assembler::zero, post_alignment);
7563 
7564     movl(tmp5, dst);
7565     andl(tmp5, (32 - 1));
7566     negl(tmp5);
7567     andl(tmp5, (32 - 1));
7568 
7569     // bail out when there is nothing to be done
7570     testl(tmp5, 0xFFFFFFFF);
7571     jcc(Assembler::zero, post_alignment);
7572 
7573     // ~(~0 &lt;&lt; len), where len is the # of remaining elements to process
7574     movl(result, 0xFFFFFFFF);
7575     shlxl(result, result, tmp5);
7576     notl(result);
7577     kmovdl(k3, result);
7578 
7579     evmovdquw(tmp1Reg, k3, Address(src, 0), Assembler::AVX_512bit);
7580     evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
7581     ktestd(k2, k3);
7582     jcc(Assembler::carryClear, return_zero);
7583 
7584     evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);
7585 
7586     addptr(src, tmp5);
7587     addptr(src, tmp5);
7588     addptr(dst, tmp5);
7589     subl(len, tmp5);
7590 
7591     bind(post_alignment);
7592     // end of alignment
7593 
7594     movl(tmp5, len);
7595     andl(tmp5, (32 - 1));    // tail count (in chars)
7596     andl(len, ~(32 - 1));    // vector count (in chars)
7597     jcc(Assembler::zero, copy_loop_tail);
7598 
7599     lea(src, Address(src, len, Address::times_2));
7600     lea(dst, Address(dst, len, Address::times_1));
7601     negptr(len);
7602 
7603     bind(copy_32_loop);
7604     evmovdquw(tmp1Reg, Address(src, len, Address::times_2), Assembler::AVX_512bit);
7605     evpcmpuw(k2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
7606     kortestdl(k2, k2);
7607     jcc(Assembler::carryClear, return_zero);
7608 
7609     // All elements in current processed chunk are valid candidates for
7610     // compression. Write a truncated byte elements to the memory.
7611     evpmovwb(Address(dst, len, Address::times_1), tmp1Reg, Assembler::AVX_512bit);
7612     addptr(len, 32);
7613     jcc(Assembler::notZero, copy_32_loop);
7614 
7615     bind(copy_loop_tail);
7616     // bail out when there is nothing to be done
7617     testl(tmp5, 0xFFFFFFFF);
7618     jcc(Assembler::zero, return_length);
7619 
7620     movl(len, tmp5);
7621 
7622     // ~(~0 &lt;&lt; len), where len is the # of remaining elements to process
7623     movl(result, 0xFFFFFFFF);
7624     shlxl(result, result, len);
7625     notl(result);
7626 
7627     kmovdl(k3, result);
7628 
7629     evmovdquw(tmp1Reg, k3, Address(src, 0), Assembler::AVX_512bit);
7630     evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
7631     ktestd(k2, k3);
7632     jcc(Assembler::carryClear, return_zero);
7633 
7634     evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);
7635     jmp(return_length);
7636 
7637     bind(below_threshold);
7638   }
7639 
7640   if (UseSSE42Intrinsics) {
7641     Label copy_32_loop, copy_16, copy_tail;
7642 
7643     movl(result, len);
7644 
7645     movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vectors
7646 
7647     // vectored compression
7648     andl(len, 0xfffffff0);    // vector count (in chars)
7649     andl(result, 0x0000000f);    // tail count (in chars)
7650     testl(len, len);
7651     jcc(Assembler::zero, copy_16);
7652 
7653     // compress 16 chars per iter
7654     movdl(tmp1Reg, tmp5);
7655     pshufd(tmp1Reg, tmp1Reg, 0);   // store Unicode mask in tmp1Reg
7656     pxor(tmp4Reg, tmp4Reg);
7657 
7658     lea(src, Address(src, len, Address::times_2));
7659     lea(dst, Address(dst, len, Address::times_1));
7660     negptr(len);
7661 
7662     bind(copy_32_loop);
7663     movdqu(tmp2Reg, Address(src, len, Address::times_2));     // load 1st 8 characters
7664     por(tmp4Reg, tmp2Reg);
7665     movdqu(tmp3Reg, Address(src, len, Address::times_2, 16)); // load next 8 characters
7666     por(tmp4Reg, tmp3Reg);
7667     ptest(tmp4Reg, tmp1Reg);       // check for Unicode chars in next vector
7668     jcc(Assembler::notZero, return_zero);
7669     packuswb(tmp2Reg, tmp3Reg);    // only ASCII chars; compress each to 1 byte
7670     movdqu(Address(dst, len, Address::times_1), tmp2Reg);
7671     addptr(len, 16);
7672     jcc(Assembler::notZero, copy_32_loop);
7673 
7674     // compress next vector of 8 chars (if any)
7675     bind(copy_16);
7676     movl(len, result);
7677     andl(len, 0xfffffff8);    // vector count (in chars)
7678     andl(result, 0x00000007);    // tail count (in chars)
7679     testl(len, len);
7680     jccb(Assembler::zero, copy_tail);
7681 
7682     movdl(tmp1Reg, tmp5);
7683     pshufd(tmp1Reg, tmp1Reg, 0);   // store Unicode mask in tmp1Reg
7684     pxor(tmp3Reg, tmp3Reg);
7685 
7686     movdqu(tmp2Reg, Address(src, 0));
7687     ptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in vector
7688     jccb(Assembler::notZero, return_zero);
7689     packuswb(tmp2Reg, tmp3Reg);    // only LATIN1 chars; compress each to 1 byte
7690     movq(Address(dst, 0), tmp2Reg);
7691     addptr(src, 16);
7692     addptr(dst, 8);
7693 
7694     bind(copy_tail);
7695     movl(len, result);
7696   }
7697   // compress 1 char per iter
7698   testl(len, len);
7699   jccb(Assembler::zero, return_length);
7700   lea(src, Address(src, len, Address::times_2));
7701   lea(dst, Address(dst, len, Address::times_1));
7702   negptr(len);
7703 
7704   bind(copy_chars_loop);
7705   load_unsigned_short(result, Address(src, len, Address::times_2));
7706   testl(result, 0xff00);      // check if Unicode char
7707   jccb(Assembler::notZero, return_zero);
7708   movb(Address(dst, len, Address::times_1), result);  // ASCII char; compress to 1 byte
7709   increment(len);
7710   jcc(Assembler::notZero, copy_chars_loop);
7711 
7712   // if compression succeeded, return length
7713   bind(return_length);
7714   pop(result);
7715   jmpb(done);
7716 
7717   // if compression failed, return 0
7718   bind(return_zero);
7719   xorl(result, result);
7720   addptr(rsp, wordSize);
7721 
7722   bind(done);
7723 }
7724 
7725 // Inflate byte[] array to char[].
7726 //   ..\jdk\src\java.base\share\classes\java\lang\StringLatin1.java
7727 //   @HotSpotIntrinsicCandidate
7728 //   private static void inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len) {
7729 //     for (int i = 0; i &lt; len; i++) {
7730 //       dst[dstOff++] = (char)(src[srcOff++] &amp; 0xff);
7731 //     }
7732 //   }
7733 void MacroAssembler::byte_array_inflate(Register src, Register dst, Register len,
7734   XMMRegister tmp1, Register tmp2) {
7735   Label copy_chars_loop, done, below_threshold, avx3_threshold;
7736   // rsi: src
7737   // rdi: dst
7738   // rdx: len
7739   // rcx: tmp2
7740 
7741   // rsi holds start addr of source byte[] to be inflated
7742   // rdi holds start addr of destination char[]
7743   // rdx holds length
7744   assert_different_registers(src, dst, len, tmp2);
7745   movl(tmp2, len);
7746   if ((UseAVX &gt; 2) &amp;&amp; // AVX512
7747     VM_Version::supports_avx512vlbw() &amp;&amp;
7748     VM_Version::supports_bmi2()) {
7749 
7750     Label copy_32_loop, copy_tail;
7751     Register tmp3_aliased = len;
7752 
7753     // if length of the string is less than 16, handle it in an old fashioned way
7754     testl(len, -16);
7755     jcc(Assembler::zero, below_threshold);
7756 
7757     testl(len, -1 * AVX3Threshold);
7758     jcc(Assembler::zero, avx3_threshold);
7759 
7760     // In order to use only one arithmetic operation for the main loop we use
7761     // this pre-calculation
7762     andl(tmp2, (32 - 1)); // tail count (in chars), 32 element wide loop
7763     andl(len, -32);     // vector count
7764     jccb(Assembler::zero, copy_tail);
7765 
7766     lea(src, Address(src, len, Address::times_1));
7767     lea(dst, Address(dst, len, Address::times_2));
7768     negptr(len);
7769 
7770 
7771     // inflate 32 chars per iter
7772     bind(copy_32_loop);
7773     vpmovzxbw(tmp1, Address(src, len, Address::times_1), Assembler::AVX_512bit);
7774     evmovdquw(Address(dst, len, Address::times_2), tmp1, Assembler::AVX_512bit);
7775     addptr(len, 32);
7776     jcc(Assembler::notZero, copy_32_loop);
7777 
7778     bind(copy_tail);
7779     // bail out when there is nothing to be done
7780     testl(tmp2, -1); // we don&#39;t destroy the contents of tmp2 here
7781     jcc(Assembler::zero, done);
7782 
7783     // ~(~0 &lt;&lt; length), where length is the # of remaining elements to process
7784     movl(tmp3_aliased, -1);
7785     shlxl(tmp3_aliased, tmp3_aliased, tmp2);
7786     notl(tmp3_aliased);
7787     kmovdl(k2, tmp3_aliased);
7788     evpmovzxbw(tmp1, k2, Address(src, 0), Assembler::AVX_512bit);
7789     evmovdquw(Address(dst, 0), k2, tmp1, Assembler::AVX_512bit);
7790 
7791     jmp(done);
7792     bind(avx3_threshold);
7793   }
7794   if (UseSSE42Intrinsics) {
7795     Label copy_16_loop, copy_8_loop, copy_bytes, copy_new_tail, copy_tail;
7796 
7797     if (UseAVX &gt; 1) {
7798       andl(tmp2, (16 - 1));
7799       andl(len, -16);
7800       jccb(Assembler::zero, copy_new_tail);
7801     } else {
7802       andl(tmp2, 0x00000007);   // tail count (in chars)
7803       andl(len, 0xfffffff8);    // vector count (in chars)
7804       jccb(Assembler::zero, copy_tail);
7805     }
7806 
7807     // vectored inflation
7808     lea(src, Address(src, len, Address::times_1));
7809     lea(dst, Address(dst, len, Address::times_2));
7810     negptr(len);
7811 
7812     if (UseAVX &gt; 1) {
7813       bind(copy_16_loop);
7814       vpmovzxbw(tmp1, Address(src, len, Address::times_1), Assembler::AVX_256bit);
7815       vmovdqu(Address(dst, len, Address::times_2), tmp1);
7816       addptr(len, 16);
7817       jcc(Assembler::notZero, copy_16_loop);
7818 
7819       bind(below_threshold);
7820       bind(copy_new_tail);
7821       movl(len, tmp2);
7822       andl(tmp2, 0x00000007);
7823       andl(len, 0xFFFFFFF8);
7824       jccb(Assembler::zero, copy_tail);
7825 
7826       pmovzxbw(tmp1, Address(src, 0));
7827       movdqu(Address(dst, 0), tmp1);
7828       addptr(src, 8);
7829       addptr(dst, 2 * 8);
7830 
7831       jmp(copy_tail, true);
7832     }
7833 
7834     // inflate 8 chars per iter
7835     bind(copy_8_loop);
7836     pmovzxbw(tmp1, Address(src, len, Address::times_1));  // unpack to 8 words
7837     movdqu(Address(dst, len, Address::times_2), tmp1);
7838     addptr(len, 8);
7839     jcc(Assembler::notZero, copy_8_loop);
7840 
7841     bind(copy_tail);
7842     movl(len, tmp2);
7843 
7844     cmpl(len, 4);
7845     jccb(Assembler::less, copy_bytes);
7846 
7847     movdl(tmp1, Address(src, 0));  // load 4 byte chars
7848     pmovzxbw(tmp1, tmp1);
7849     movq(Address(dst, 0), tmp1);
7850     subptr(len, 4);
7851     addptr(src, 4);
7852     addptr(dst, 8);
7853 
7854     bind(copy_bytes);
7855   } else {
7856     bind(below_threshold);
7857   }
7858 
7859   testl(len, len);
7860   jccb(Assembler::zero, done);
7861   lea(src, Address(src, len, Address::times_1));
7862   lea(dst, Address(dst, len, Address::times_2));
7863   negptr(len);
7864 
7865   // inflate 1 char per iter
7866   bind(copy_chars_loop);
7867   load_unsigned_byte(tmp2, Address(src, len, Address::times_1));  // load byte char
7868   movw(Address(dst, len, Address::times_2), tmp2);  // inflate byte char to word
7869   increment(len);
7870   jcc(Assembler::notZero, copy_chars_loop);
7871 
7872   bind(done);
7873 }
7874 
7875 #ifdef _LP64
7876 void MacroAssembler::convert_f2i(Register dst, XMMRegister src) {
7877   Label done;
7878   cvttss2sil(dst, src);
7879   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
7880   cmpl(dst, 0x80000000); // float_sign_flip
7881   jccb(Assembler::notEqual, done);
7882   subptr(rsp, 8);
7883   movflt(Address(rsp, 0), src);
7884   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));
7885   pop(dst);
7886   bind(done);
7887 }
7888 
7889 void MacroAssembler::convert_d2i(Register dst, XMMRegister src) {
7890   Label done;
7891   cvttsd2sil(dst, src);
7892   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
7893   cmpl(dst, 0x80000000); // float_sign_flip
7894   jccb(Assembler::notEqual, done);
7895   subptr(rsp, 8);
7896   movdbl(Address(rsp, 0), src);
7897   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));
7898   pop(dst);
7899   bind(done);
7900 }
7901 
7902 void MacroAssembler::convert_f2l(Register dst, XMMRegister src) {
7903   Label done;
7904   cvttss2siq(dst, src);
7905   cmp64(dst, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
7906   jccb(Assembler::notEqual, done);
7907   subptr(rsp, 8);
7908   movflt(Address(rsp, 0), src);
7909   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));
7910   pop(dst);
7911   bind(done);
7912 }
7913 
7914 void MacroAssembler::convert_d2l(Register dst, XMMRegister src) {
7915   Label done;
7916   cvttsd2siq(dst, src);
7917   cmp64(dst, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
7918   jccb(Assembler::notEqual, done);
7919   subptr(rsp, 8);
7920   movdbl(Address(rsp, 0), src);
7921   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));
7922   pop(dst);
7923   bind(done);
7924 }
7925 
7926 void MacroAssembler::cache_wb(Address line)
7927 {
7928   // 64 bit cpus always support clflush
7929   assert(VM_Version::supports_clflush(), &quot;clflush should be available&quot;);
7930   bool optimized = VM_Version::supports_clflushopt();
7931   bool no_evict = VM_Version::supports_clwb();
7932 
7933   // prefer clwb (writeback without evict) otherwise
7934   // prefer clflushopt (potentially parallel writeback with evict)
7935   // otherwise fallback on clflush (serial writeback with evict)
7936 
7937   if (optimized) {
7938     if (no_evict) {
7939       clwb(line);
7940     } else {
7941       clflushopt(line);
7942     }
7943   } else {
7944     // no need for fence when using CLFLUSH
7945     clflush(line);
7946   }
7947 }
7948 
7949 void MacroAssembler::cache_wbsync(bool is_pre)
7950 {
7951   assert(VM_Version::supports_clflush(), &quot;clflush should be available&quot;);
7952   bool optimized = VM_Version::supports_clflushopt();
7953   bool no_evict = VM_Version::supports_clwb();
7954 
7955   // pick the correct implementation
7956 
7957   if (!is_pre &amp;&amp; (optimized || no_evict)) {
7958     // need an sfence for post flush when using clflushopt or clwb
7959     // otherwise no no need for any synchroniaztion
7960 
7961     sfence();
7962   }
7963 }
7964 #endif // _LP64
7965 
7966 Assembler::Condition MacroAssembler::negate_condition(Assembler::Condition cond) {
7967   switch (cond) {
7968     // Note some conditions are synonyms for others
7969     case Assembler::zero:         return Assembler::notZero;
7970     case Assembler::notZero:      return Assembler::zero;
7971     case Assembler::less:         return Assembler::greaterEqual;
7972     case Assembler::lessEqual:    return Assembler::greater;
7973     case Assembler::greater:      return Assembler::lessEqual;
7974     case Assembler::greaterEqual: return Assembler::less;
7975     case Assembler::below:        return Assembler::aboveEqual;
7976     case Assembler::belowEqual:   return Assembler::above;
7977     case Assembler::above:        return Assembler::belowEqual;
7978     case Assembler::aboveEqual:   return Assembler::below;
7979     case Assembler::overflow:     return Assembler::noOverflow;
7980     case Assembler::noOverflow:   return Assembler::overflow;
7981     case Assembler::negative:     return Assembler::positive;
7982     case Assembler::positive:     return Assembler::negative;
7983     case Assembler::parity:       return Assembler::noParity;
7984     case Assembler::noParity:     return Assembler::parity;
7985   }
7986   ShouldNotReachHere(); return Assembler::overflow;
7987 }
7988 
7989 SkipIfEqual::SkipIfEqual(
7990     MacroAssembler* masm, const bool* flag_addr, bool value) {
7991   _masm = masm;
7992   _masm-&gt;cmp8(ExternalAddress((address)flag_addr), value);
7993   _masm-&gt;jcc(Assembler::equal, _label);
7994 }
7995 
7996 SkipIfEqual::~SkipIfEqual() {
7997   _masm-&gt;bind(_label);
7998 }
7999 
8000 // 32-bit Windows has its own fast-path implementation
8001 // of get_thread
8002 #if !defined(WIN32) || defined(_LP64)
8003 
8004 // This is simply a call to Thread::current()
8005 void MacroAssembler::get_thread(Register thread) {
8006   if (thread != rax) {
8007     push(rax);
8008   }
8009   LP64_ONLY(push(rdi);)
8010   LP64_ONLY(push(rsi);)
8011   push(rdx);
8012   push(rcx);
8013 #ifdef _LP64
8014   push(r8);
8015   push(r9);
8016   push(r10);
8017   push(r11);
8018 #endif
8019 
8020   MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, Thread::current), 0);
8021 
8022 #ifdef _LP64
8023   pop(r11);
8024   pop(r10);
8025   pop(r9);
8026   pop(r8);
8027 #endif
8028   pop(rcx);
8029   pop(rdx);
8030   LP64_ONLY(pop(rsi);)
8031   LP64_ONLY(pop(rdi);)
8032   if (thread != rax) {
8033     mov(thread, rax);
8034     pop(rax);
8035   }
8036 }
8037 
8038 #endif // !WIN32 || _LP64
    </pre>
  </body>
</html>