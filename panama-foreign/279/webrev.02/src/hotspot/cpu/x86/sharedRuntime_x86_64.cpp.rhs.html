<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #ifndef _WINDOWS
  27 #include &quot;alloca.h&quot;
  28 #endif
  29 #include &quot;asm/macroAssembler.hpp&quot;
  30 #include &quot;asm/macroAssembler.inline.hpp&quot;
  31 #include &quot;code/debugInfoRec.hpp&quot;
  32 #include &quot;code/icBuffer.hpp&quot;
  33 #include &quot;code/nativeInst.hpp&quot;
  34 #include &quot;code/vtableStubs.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
  36 #include &quot;gc/shared/gcLocker.hpp&quot;
  37 #include &quot;gc/shared/barrierSet.hpp&quot;
  38 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  39 #include &quot;interpreter/interpreter.hpp&quot;
  40 #include &quot;logging/log.hpp&quot;
  41 #include &quot;memory/resourceArea.hpp&quot;
  42 #include &quot;memory/universe.hpp&quot;
  43 #include &quot;oops/compiledICHolder.hpp&quot;
  44 #include &quot;oops/klass.inline.hpp&quot;
  45 #include &quot;runtime/safepointMechanism.hpp&quot;
  46 #include &quot;runtime/sharedRuntime.hpp&quot;
  47 #include &quot;runtime/vframeArray.hpp&quot;
  48 #include &quot;runtime/vm_version.hpp&quot;
  49 #include &quot;utilities/align.hpp&quot;
  50 #include &quot;utilities/formatBuffer.hpp&quot;
  51 #include &quot;vmreg_x86.inline.hpp&quot;
  52 #ifdef COMPILER1
  53 #include &quot;c1/c1_Runtime1.hpp&quot;
  54 #endif
  55 #ifdef COMPILER2
  56 #include &quot;opto/runtime.hpp&quot;
  57 #endif
  58 #if INCLUDE_JVMCI
  59 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  60 #endif
  61 
  62 #define __ masm-&gt;
  63 
  64 const int StackAlignmentInSlots = StackAlignmentInBytes / VMRegImpl::stack_slot_size;
  65 
  66 class SimpleRuntimeFrame {
  67 
  68   public:
  69 
  70   // Most of the runtime stubs have this simple frame layout.
  71   // This class exists to make the layout shared in one place.
  72   // Offsets are for compiler stack slots, which are jints.
  73   enum layout {
  74     // The frame sender code expects that rbp will be in the &quot;natural&quot; place and
  75     // will override any oopMap setting for it. We must therefore force the layout
  76     // so that it agrees with the frame sender code.
  77     rbp_off = frame::arg_reg_save_area_bytes/BytesPerInt,
  78     rbp_off2,
  79     return_off, return_off2,
  80     framesize
  81   };
  82 };
  83 
  84 class RegisterSaver {
  85   // Capture info about frame layout.  Layout offsets are in jint
  86   // units because compiler frame slots are jints.
  87 #define XSAVE_AREA_BEGIN 160
  88 #define XSAVE_AREA_YMM_BEGIN 576
  89 #define XSAVE_AREA_ZMM_BEGIN 1152
  90 #define XSAVE_AREA_UPPERBANK 1664
  91 #define DEF_XMM_OFFS(regnum) xmm ## regnum ## _off = xmm_off + (regnum)*16/BytesPerInt, xmm ## regnum ## H_off
  92 #define DEF_YMM_OFFS(regnum) ymm ## regnum ## _off = ymm_off + (regnum)*16/BytesPerInt, ymm ## regnum ## H_off
  93 #define DEF_ZMM_OFFS(regnum) zmm ## regnum ## _off = zmm_off + (regnum-16)*64/BytesPerInt, zmm ## regnum ## H_off
  94   enum layout {
  95     fpu_state_off = frame::arg_reg_save_area_bytes/BytesPerInt, // fxsave save area
  96     xmm_off       = fpu_state_off + XSAVE_AREA_BEGIN/BytesPerInt,            // offset in fxsave save area
  97     DEF_XMM_OFFS(0),
  98     DEF_XMM_OFFS(1),
  99     // 2..15 are implied in range usage
 100     ymm_off = xmm_off + (XSAVE_AREA_YMM_BEGIN - XSAVE_AREA_BEGIN)/BytesPerInt,
 101     DEF_YMM_OFFS(0),
 102     DEF_YMM_OFFS(1),
 103     // 2..15 are implied in range usage
 104     zmm_high = xmm_off + (XSAVE_AREA_ZMM_BEGIN - XSAVE_AREA_BEGIN)/BytesPerInt,
 105     zmm_off = xmm_off + (XSAVE_AREA_UPPERBANK - XSAVE_AREA_BEGIN)/BytesPerInt,
 106     DEF_ZMM_OFFS(16),
 107     DEF_ZMM_OFFS(17),
 108     // 18..31 are implied in range usage
 109     fpu_state_end = fpu_state_off + ((FPUStateSizeInWords-1)*wordSize / BytesPerInt),
 110     fpu_stateH_end,
 111     r15_off, r15H_off,
 112     r14_off, r14H_off,
 113     r13_off, r13H_off,
 114     r12_off, r12H_off,
 115     r11_off, r11H_off,
 116     r10_off, r10H_off,
 117     r9_off,  r9H_off,
 118     r8_off,  r8H_off,
 119     rdi_off, rdiH_off,
 120     rsi_off, rsiH_off,
 121     ignore_off, ignoreH_off,  // extra copy of rbp
 122     rsp_off, rspH_off,
 123     rbx_off, rbxH_off,
 124     rdx_off, rdxH_off,
 125     rcx_off, rcxH_off,
 126     rax_off, raxH_off,
 127     // 16-byte stack alignment fill word: see MacroAssembler::push/pop_IU_state
 128     align_off, alignH_off,
 129     flags_off, flagsH_off,
 130     // The frame sender code expects that rbp will be in the &quot;natural&quot; place and
 131     // will override any oopMap setting for it. We must therefore force the layout
 132     // so that it agrees with the frame sender code.
 133     rbp_off, rbpH_off,        // copy of rbp we will restore
 134     return_off, returnH_off,  // slot for return address
 135     reg_save_size             // size in compiler stack slots
 136   };
 137 
 138  public:
 139   static OopMap* save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors = false);
 140   static void restore_live_registers(MacroAssembler* masm, bool restore_vectors = false);
 141 
 142   // Offsets into the register save area
 143   // Used by deoptimization when it is managing result register
 144   // values on its own
 145 
 146   static int rax_offset_in_bytes(void)    { return BytesPerInt * rax_off; }
 147   static int rdx_offset_in_bytes(void)    { return BytesPerInt * rdx_off; }
 148   static int rbx_offset_in_bytes(void)    { return BytesPerInt * rbx_off; }
 149   static int xmm0_offset_in_bytes(void)   { return BytesPerInt * xmm0_off; }
 150   static int return_offset_in_bytes(void) { return BytesPerInt * return_off; }
 151 
 152   // During deoptimization only the result registers need to be restored,
 153   // all the other values have already been extracted.
 154   static void restore_result_registers(MacroAssembler* masm);
 155 };
 156 
 157 OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors) {
 158   int off = 0;
 159   int num_xmm_regs = XMMRegisterImpl::number_of_registers;
 160   if (UseAVX &lt; 3) {
 161     num_xmm_regs = num_xmm_regs/2;
 162   }
 163 #if COMPILER2_OR_JVMCI
 164   if (save_vectors) {
 165     assert(UseAVX &gt; 0, &quot;Vectors larger than 16 byte long are supported only with AVX&quot;);
 166     assert(MaxVectorSize &lt;= 64, &quot;Only up to 64 byte long vectors are supported&quot;);
 167   }
 168 #else
 169   assert(!save_vectors, &quot;vectors are generated only by C2 and JVMCI&quot;);
 170 #endif
 171 
 172   // Always make the frame size 16-byte aligned, both vector and non vector stacks are always allocated
 173   int frame_size_in_bytes = align_up(reg_save_size*BytesPerInt, num_xmm_regs);
 174   // OopMap frame size is in compiler stack slots (jint&#39;s) not bytes or words
 175   int frame_size_in_slots = frame_size_in_bytes / BytesPerInt;
 176   // CodeBlob frame size is in words.
 177   int frame_size_in_words = frame_size_in_bytes / wordSize;
 178   *total_frame_words = frame_size_in_words;
 179 
 180   // Save registers, fpu state, and flags.
 181   // We assume caller has already pushed the return address onto the
 182   // stack, so rsp is 8-byte aligned here.
 183   // We push rpb twice in this sequence because we want the real rbp
 184   // to be under the return like a normal enter.
 185 
 186   __ enter();          // rsp becomes 16-byte aligned here
 187   __ push_CPU_state(); // Push a multiple of 16 bytes
 188 
 189   // push cpu state handles this on EVEX enabled targets
 190   if (save_vectors) {
 191     // Save upper half of YMM registers(0..15)
 192     int base_addr = XSAVE_AREA_YMM_BEGIN;
 193     for (int n = 0; n &lt; 16; n++) {
 194       __ vextractf128_high(Address(rsp, base_addr+n*16), as_XMMRegister(n));
 195     }
 196     if (VM_Version::supports_evex()) {
 197       // Save upper half of ZMM registers(0..15)
 198       base_addr = XSAVE_AREA_ZMM_BEGIN;
 199       for (int n = 0; n &lt; 16; n++) {
 200         __ vextractf64x4_high(Address(rsp, base_addr+n*32), as_XMMRegister(n));
 201       }
 202       // Save full ZMM registers(16..num_xmm_regs)
 203       base_addr = XSAVE_AREA_UPPERBANK;
 204       off = 0;
 205       int vector_len = Assembler::AVX_512bit;
 206       for (int n = 16; n &lt; num_xmm_regs; n++) {
 207         __ evmovdqul(Address(rsp, base_addr+(off++*64)), as_XMMRegister(n), vector_len);
 208       }
 209     }
 210   } else {
 211     if (VM_Version::supports_evex()) {
 212       // Save upper bank of ZMM registers(16..31) for double/float usage
 213       int base_addr = XSAVE_AREA_UPPERBANK;
 214       off = 0;
 215       for (int n = 16; n &lt; num_xmm_regs; n++) {
 216         __ movsd(Address(rsp, base_addr+(off++*64)), as_XMMRegister(n));
 217       }
 218     }
 219   }
 220   __ vzeroupper();
 221   if (frame::arg_reg_save_area_bytes != 0) {
 222     // Allocate argument register save area
 223     __ subptr(rsp, frame::arg_reg_save_area_bytes);
 224   }
 225 
 226   // Set an oopmap for the call site.  This oopmap will map all
 227   // oop-registers and debug-info registers as callee-saved.  This
 228   // will allow deoptimization at this safepoint to find all possible
 229   // debug-info recordings, as well as let GC find all oops.
 230 
 231   OopMapSet *oop_maps = new OopMapSet();
 232   OopMap* map = new OopMap(frame_size_in_slots, 0);
 233 
 234 #define STACK_OFFSET(x) VMRegImpl::stack2reg((x))
 235 
 236   map-&gt;set_callee_saved(STACK_OFFSET( rax_off ), rax-&gt;as_VMReg());
 237   map-&gt;set_callee_saved(STACK_OFFSET( rcx_off ), rcx-&gt;as_VMReg());
 238   map-&gt;set_callee_saved(STACK_OFFSET( rdx_off ), rdx-&gt;as_VMReg());
 239   map-&gt;set_callee_saved(STACK_OFFSET( rbx_off ), rbx-&gt;as_VMReg());
 240   // rbp location is known implicitly by the frame sender code, needs no oopmap
 241   // and the location where rbp was saved by is ignored
 242   map-&gt;set_callee_saved(STACK_OFFSET( rsi_off ), rsi-&gt;as_VMReg());
 243   map-&gt;set_callee_saved(STACK_OFFSET( rdi_off ), rdi-&gt;as_VMReg());
 244   map-&gt;set_callee_saved(STACK_OFFSET( r8_off  ), r8-&gt;as_VMReg());
 245   map-&gt;set_callee_saved(STACK_OFFSET( r9_off  ), r9-&gt;as_VMReg());
 246   map-&gt;set_callee_saved(STACK_OFFSET( r10_off ), r10-&gt;as_VMReg());
 247   map-&gt;set_callee_saved(STACK_OFFSET( r11_off ), r11-&gt;as_VMReg());
 248   map-&gt;set_callee_saved(STACK_OFFSET( r12_off ), r12-&gt;as_VMReg());
 249   map-&gt;set_callee_saved(STACK_OFFSET( r13_off ), r13-&gt;as_VMReg());
 250   map-&gt;set_callee_saved(STACK_OFFSET( r14_off ), r14-&gt;as_VMReg());
 251   map-&gt;set_callee_saved(STACK_OFFSET( r15_off ), r15-&gt;as_VMReg());
 252   // For both AVX and EVEX we will use the legacy FXSAVE area for xmm0..xmm15,
 253   // on EVEX enabled targets, we get it included in the xsave area
 254   off = xmm0_off;
 255   int delta = xmm1_off - off;
 256   for (int n = 0; n &lt; 16; n++) {
 257     XMMRegister xmm_name = as_XMMRegister(n);
 258     map-&gt;set_callee_saved(STACK_OFFSET(off), xmm_name-&gt;as_VMReg());
 259     off += delta;
 260   }
 261   if(UseAVX &gt; 2) {
 262     // Obtain xmm16..xmm31 from the XSAVE area on EVEX enabled targets
 263     off = zmm16_off;
 264     delta = zmm17_off - off;
 265     for (int n = 16; n &lt; num_xmm_regs; n++) {
 266       XMMRegister zmm_name = as_XMMRegister(n);
 267       map-&gt;set_callee_saved(STACK_OFFSET(off), zmm_name-&gt;as_VMReg());
 268       off += delta;
 269     }
 270   }
 271 
 272 #if COMPILER2_OR_JVMCI
 273   if (save_vectors) {
 274     off = ymm0_off;
 275     int delta = ymm1_off - off;
 276     for (int n = 0; n &lt; 16; n++) {
 277       XMMRegister ymm_name = as_XMMRegister(n);
 278       map-&gt;set_callee_saved(STACK_OFFSET(off), ymm_name-&gt;as_VMReg()-&gt;next(4));
 279       off += delta;
 280     }
 281   }
 282 #endif // COMPILER2_OR_JVMCI
 283 
 284   // %%% These should all be a waste but we&#39;ll keep things as they were for now
 285   if (true) {
 286     map-&gt;set_callee_saved(STACK_OFFSET( raxH_off ), rax-&gt;as_VMReg()-&gt;next());
 287     map-&gt;set_callee_saved(STACK_OFFSET( rcxH_off ), rcx-&gt;as_VMReg()-&gt;next());
 288     map-&gt;set_callee_saved(STACK_OFFSET( rdxH_off ), rdx-&gt;as_VMReg()-&gt;next());
 289     map-&gt;set_callee_saved(STACK_OFFSET( rbxH_off ), rbx-&gt;as_VMReg()-&gt;next());
 290     // rbp location is known implicitly by the frame sender code, needs no oopmap
 291     map-&gt;set_callee_saved(STACK_OFFSET( rsiH_off ), rsi-&gt;as_VMReg()-&gt;next());
 292     map-&gt;set_callee_saved(STACK_OFFSET( rdiH_off ), rdi-&gt;as_VMReg()-&gt;next());
 293     map-&gt;set_callee_saved(STACK_OFFSET( r8H_off  ), r8-&gt;as_VMReg()-&gt;next());
 294     map-&gt;set_callee_saved(STACK_OFFSET( r9H_off  ), r9-&gt;as_VMReg()-&gt;next());
 295     map-&gt;set_callee_saved(STACK_OFFSET( r10H_off ), r10-&gt;as_VMReg()-&gt;next());
 296     map-&gt;set_callee_saved(STACK_OFFSET( r11H_off ), r11-&gt;as_VMReg()-&gt;next());
 297     map-&gt;set_callee_saved(STACK_OFFSET( r12H_off ), r12-&gt;as_VMReg()-&gt;next());
 298     map-&gt;set_callee_saved(STACK_OFFSET( r13H_off ), r13-&gt;as_VMReg()-&gt;next());
 299     map-&gt;set_callee_saved(STACK_OFFSET( r14H_off ), r14-&gt;as_VMReg()-&gt;next());
 300     map-&gt;set_callee_saved(STACK_OFFSET( r15H_off ), r15-&gt;as_VMReg()-&gt;next());
 301     // For both AVX and EVEX we will use the legacy FXSAVE area for xmm0..xmm15,
 302     // on EVEX enabled targets, we get it included in the xsave area
 303     off = xmm0H_off;
 304     delta = xmm1H_off - off;
 305     for (int n = 0; n &lt; 16; n++) {
 306       XMMRegister xmm_name = as_XMMRegister(n);
 307       map-&gt;set_callee_saved(STACK_OFFSET(off), xmm_name-&gt;as_VMReg()-&gt;next());
 308       off += delta;
 309     }
 310     if (UseAVX &gt; 2) {
 311       // Obtain xmm16..xmm31 from the XSAVE area on EVEX enabled targets
 312       off = zmm16H_off;
 313       delta = zmm17H_off - off;
 314       for (int n = 16; n &lt; num_xmm_regs; n++) {
 315         XMMRegister zmm_name = as_XMMRegister(n);
 316         map-&gt;set_callee_saved(STACK_OFFSET(off), zmm_name-&gt;as_VMReg()-&gt;next());
 317         off += delta;
 318       }
 319     }
 320   }
 321 
 322   return map;
 323 }
 324 
 325 void RegisterSaver::restore_live_registers(MacroAssembler* masm, bool restore_vectors) {
 326   int num_xmm_regs = XMMRegisterImpl::number_of_registers;
 327   if (UseAVX &lt; 3) {
 328     num_xmm_regs = num_xmm_regs/2;
 329   }
 330   if (frame::arg_reg_save_area_bytes != 0) {
 331     // Pop arg register save area
 332     __ addptr(rsp, frame::arg_reg_save_area_bytes);
 333   }
 334 
 335 #if COMPILER2_OR_JVMCI
 336   if (restore_vectors) {
 337     assert(UseAVX &gt; 0, &quot;Vectors larger than 16 byte long are supported only with AVX&quot;);
 338     assert(MaxVectorSize &lt;= 64, &quot;Only up to 64 byte long vectors are supported&quot;);
 339   }
 340 #else
 341   assert(!restore_vectors, &quot;vectors are generated only by C2&quot;);
 342 #endif
 343 
 344   __ vzeroupper();
 345 
 346   // On EVEX enabled targets everything is handled in pop fpu state
 347   if (restore_vectors) {
 348     // Restore upper half of YMM registers (0..15)
 349     int base_addr = XSAVE_AREA_YMM_BEGIN;
 350     for (int n = 0; n &lt; 16; n++) {
 351       __ vinsertf128_high(as_XMMRegister(n), Address(rsp, base_addr+n*16));
 352     }
 353     if (VM_Version::supports_evex()) {
 354       // Restore upper half of ZMM registers (0..15)
 355       base_addr = XSAVE_AREA_ZMM_BEGIN;
 356       for (int n = 0; n &lt; 16; n++) {
 357         __ vinsertf64x4_high(as_XMMRegister(n), Address(rsp, base_addr+n*32));
 358       }
 359       // Restore full ZMM registers(16..num_xmm_regs)
 360       base_addr = XSAVE_AREA_UPPERBANK;
 361       int vector_len = Assembler::AVX_512bit;
 362       int off = 0;
 363       for (int n = 16; n &lt; num_xmm_regs; n++) {
 364         __ evmovdqul(as_XMMRegister(n), Address(rsp, base_addr+(off++*64)), vector_len);
 365       }
 366     }
 367   } else {
 368     if (VM_Version::supports_evex()) {
 369       // Restore upper bank of ZMM registers(16..31) for double/float usage
 370       int base_addr = XSAVE_AREA_UPPERBANK;
 371       int off = 0;
 372       for (int n = 16; n &lt; num_xmm_regs; n++) {
 373         __ movsd(as_XMMRegister(n), Address(rsp, base_addr+(off++*64)));
 374       }
 375     }
 376   }
 377 
 378   // Recover CPU state
 379   __ pop_CPU_state();
 380   // Get the rbp described implicitly by the calling convention (no oopMap)
 381   __ pop(rbp);
 382 }
 383 
 384 void RegisterSaver::restore_result_registers(MacroAssembler* masm) {
 385 
 386   // Just restore result register. Only used by deoptimization. By
 387   // now any callee save register that needs to be restored to a c2
 388   // caller of the deoptee has been extracted into the vframeArray
 389   // and will be stuffed into the c2i adapter we create for later
 390   // restoration so only result registers need to be restored here.
 391 
 392   // Restore fp result register
 393   __ movdbl(xmm0, Address(rsp, xmm0_offset_in_bytes()));
 394   // Restore integer result register
 395   __ movptr(rax, Address(rsp, rax_offset_in_bytes()));
 396   __ movptr(rdx, Address(rsp, rdx_offset_in_bytes()));
 397 
 398   // Pop all of the register save are off the stack except the return address
 399   __ addptr(rsp, return_offset_in_bytes());
 400 }
 401 
 402 // Is vector&#39;s size (in bytes) bigger than a size saved by default?
 403 // 16 bytes XMM registers are saved by default using fxsave/fxrstor instructions.
 404 bool SharedRuntime::is_wide_vector(int size) {
 405   return size &gt; 16;
 406 }
 407 
 408 size_t SharedRuntime::trampoline_size() {
 409   return 16;
 410 }
 411 
 412 void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {
 413   __ jump(RuntimeAddress(destination));
 414 }
 415 
 416 // The java_calling_convention describes stack locations as ideal slots on
 417 // a frame with no abi restrictions. Since we must observe abi restrictions
 418 // (like the placement of the register window) the slots must be biased by
 419 // the following value.
 420 static int reg2offset_in(VMReg r) {
 421   // Account for saved rbp and return address
 422   // This should really be in_preserve_stack_slots
 423   return (r-&gt;reg2stack() + 4) * VMRegImpl::stack_slot_size;
 424 }
 425 
 426 static int reg2offset_out(VMReg r) {
 427   return (r-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
 428 }
 429 
 430 // ---------------------------------------------------------------------------
 431 // Read the array of BasicTypes from a signature, and compute where the
 432 // arguments should go.  Values in the VMRegPair regs array refer to 4-byte
 433 // quantities.  Values less than VMRegImpl::stack0 are registers, those above
 434 // refer to 4-byte stack slots.  All stack slots are based off of the stack pointer
 435 // as framesizes are fixed.
 436 // VMRegImpl::stack0 refers to the first slot 0(sp).
 437 // and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.  Register
 438 // up to RegisterImpl::number_of_registers) are the 64-bit
 439 // integer registers.
 440 
 441 // Note: the INPUTS in sig_bt are in units of Java argument words, which are
 442 // either 32-bit or 64-bit depending on the build.  The OUTPUTS are in 32-bit
 443 // units regardless of build. Of course for i486 there is no 64 bit build
 444 
 445 // The Java calling convention is a &quot;shifted&quot; version of the C ABI.
 446 // By skipping the first C ABI register we can call non-static jni methods
 447 // with small numbers of arguments without having to shuffle the arguments
 448 // at all. Since we control the java ABI we ought to at least get some
 449 // advantage out of it.
 450 
 451 int SharedRuntime::java_calling_convention(const BasicType *sig_bt,
 452                                            VMRegPair *regs,
 453                                            int total_args_passed,
 454                                            int is_outgoing) {
 455 
 456   // Create the mapping between argument positions and
 457   // registers.
 458   static const Register INT_ArgReg[Argument::n_int_register_parameters_j] = {
 459     j_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4, j_rarg5
 460   };
 461   static const XMMRegister FP_ArgReg[Argument::n_float_register_parameters_j] = {
 462     j_farg0, j_farg1, j_farg2, j_farg3,
 463     j_farg4, j_farg5, j_farg6, j_farg7
 464   };
 465 
 466 
 467   uint int_args = 0;
 468   uint fp_args = 0;
 469   uint stk_args = 0; // inc by 2 each time
 470 
 471   for (int i = 0; i &lt; total_args_passed; i++) {
 472     switch (sig_bt[i]) {
 473     case T_BOOLEAN:
 474     case T_CHAR:
 475     case T_BYTE:
 476     case T_SHORT:
 477     case T_INT:
 478       if (int_args &lt; Argument::n_int_register_parameters_j) {
 479         regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 480       } else {
 481         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 482         stk_args += 2;
 483       }
 484       break;
 485     case T_VOID:
 486       // halves of T_LONG or T_DOUBLE
 487       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 488       regs[i].set_bad();
 489       break;
 490     case T_LONG:
 491       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 492       // fall through
 493     case T_OBJECT:
 494     case T_ARRAY:
 495     case T_ADDRESS:
 496       if (int_args &lt; Argument::n_int_register_parameters_j) {
 497         regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 498       } else {
 499         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 500         stk_args += 2;
 501       }
 502       break;
 503     case T_FLOAT:
 504       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 505         regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 506       } else {
 507         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 508         stk_args += 2;
 509       }
 510       break;
 511     case T_DOUBLE:
 512       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 513       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 514         regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 515       } else {
 516         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 517         stk_args += 2;
 518       }
 519       break;
 520     default:
 521       ShouldNotReachHere();
 522       break;
 523     }
 524   }
 525 
 526   return align_up(stk_args, 2);
 527 }
 528 
 529 // Patch the callers callsite with entry to compiled code if it exists.
 530 static void patch_callers_callsite(MacroAssembler *masm) {
 531   Label L;
 532   __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), (int32_t)NULL_WORD);
 533   __ jcc(Assembler::equal, L);
 534 
 535   // Save the current stack pointer
 536   __ mov(r13, rsp);
 537   // Schedule the branch target address early.
 538   // Call into the VM to patch the caller, then jump to compiled callee
 539   // rax isn&#39;t live so capture return address while we easily can
 540   __ movptr(rax, Address(rsp, 0));
 541 
 542   // align stack so push_CPU_state doesn&#39;t fault
 543   __ andptr(rsp, -(StackAlignmentInBytes));
 544   __ push_CPU_state();
 545   __ vzeroupper();
 546   // VM needs caller&#39;s callsite
 547   // VM needs target method
 548   // This needs to be a long call since we will relocate this adapter to
 549   // the codeBuffer and it may not reach
 550 
 551   // Allocate argument register save area
 552   if (frame::arg_reg_save_area_bytes != 0) {
 553     __ subptr(rsp, frame::arg_reg_save_area_bytes);
 554   }
 555   __ mov(c_rarg0, rbx);
 556   __ mov(c_rarg1, rax);
 557   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
 558 
 559   // De-allocate argument register save area
 560   if (frame::arg_reg_save_area_bytes != 0) {
 561     __ addptr(rsp, frame::arg_reg_save_area_bytes);
 562   }
 563 
 564   __ vzeroupper();
 565   __ pop_CPU_state();
 566   // restore sp
 567   __ mov(rsp, r13);
 568   __ bind(L);
 569 }
 570 
 571 
 572 static void gen_c2i_adapter(MacroAssembler *masm,
 573                             int total_args_passed,
 574                             int comp_args_on_stack,
 575                             const BasicType *sig_bt,
 576                             const VMRegPair *regs,
 577                             Label&amp; skip_fixup) {
 578   // Before we get into the guts of the C2I adapter, see if we should be here
 579   // at all.  We&#39;ve come from compiled code and are attempting to jump to the
 580   // interpreter, which means the caller made a static call to get here
 581   // (vcalls always get a compiled target if there is one).  Check for a
 582   // compiled target.  If there is one, we need to patch the caller&#39;s call.
 583   patch_callers_callsite(masm);
 584 
 585   __ bind(skip_fixup);
 586 
 587   // Since all args are passed on the stack, total_args_passed *
 588   // Interpreter::stackElementSize is the space we need. Plus 1 because
 589   // we also account for the return address location since
 590   // we store it first rather than hold it in rax across all the shuffling
 591 
 592   int extraspace = (total_args_passed * Interpreter::stackElementSize) + wordSize;
 593 
 594   // stack is aligned, keep it that way
 595   extraspace = align_up(extraspace, 2*wordSize);
 596 
 597   // Get return address
 598   __ pop(rax);
 599 
 600   // set senderSP value
 601   __ mov(r13, rsp);
 602 
 603   __ subptr(rsp, extraspace);
 604 
 605   // Store the return address in the expected location
 606   __ movptr(Address(rsp, 0), rax);
 607 
 608   // Now write the args into the outgoing interpreter space
 609   for (int i = 0; i &lt; total_args_passed; i++) {
 610     if (sig_bt[i] == T_VOID) {
 611       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);
 612       continue;
 613     }
 614 
 615     // offset to start parameters
 616     int st_off   = (total_args_passed - i) * Interpreter::stackElementSize;
 617     int next_off = st_off - Interpreter::stackElementSize;
 618 
 619     // Say 4 args:
 620     // i   st_off
 621     // 0   32 T_LONG
 622     // 1   24 T_VOID
 623     // 2   16 T_OBJECT
 624     // 3    8 T_BOOL
 625     // -    0 return address
 626     //
 627     // However to make thing extra confusing. Because we can fit a long/double in
 628     // a single slot on a 64 bt vm and it would be silly to break them up, the interpreter
 629     // leaves one slot empty and only stores to a single slot. In this case the
 630     // slot that is occupied is the T_VOID slot. See I said it was confusing.
 631 
 632     VMReg r_1 = regs[i].first();
 633     VMReg r_2 = regs[i].second();
 634     if (!r_1-&gt;is_valid()) {
 635       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 636       continue;
 637     }
 638     if (r_1-&gt;is_stack()) {
 639       // memory to memory use rax
 640       int ld_off = r_1-&gt;reg2stack() * VMRegImpl::stack_slot_size + extraspace;
 641       if (!r_2-&gt;is_valid()) {
 642         // sign extend??
 643         __ movl(rax, Address(rsp, ld_off));
 644         __ movptr(Address(rsp, st_off), rax);
 645 
 646       } else {
 647 
 648         __ movq(rax, Address(rsp, ld_off));
 649 
 650         // Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG
 651         // T_DOUBLE and T_LONG use two slots in the interpreter
 652         if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
 653           // ld_off == LSW, ld_off+wordSize == MSW
 654           // st_off == MSW, next_off == LSW
 655           __ movq(Address(rsp, next_off), rax);
 656 #ifdef ASSERT
 657           // Overwrite the unused slot with known junk
 658           __ mov64(rax, CONST64(0xdeadffffdeadaaaa));
 659           __ movptr(Address(rsp, st_off), rax);
 660 #endif /* ASSERT */
 661         } else {
 662           __ movq(Address(rsp, st_off), rax);
 663         }
 664       }
 665     } else if (r_1-&gt;is_Register()) {
 666       Register r = r_1-&gt;as_Register();
 667       if (!r_2-&gt;is_valid()) {
 668         // must be only an int (or less ) so move only 32bits to slot
 669         // why not sign extend??
 670         __ movl(Address(rsp, st_off), r);
 671       } else {
 672         // Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG
 673         // T_DOUBLE and T_LONG use two slots in the interpreter
 674         if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
 675           // long/double in gpr
 676 #ifdef ASSERT
 677           // Overwrite the unused slot with known junk
 678           __ mov64(rax, CONST64(0xdeadffffdeadaaab));
 679           __ movptr(Address(rsp, st_off), rax);
 680 #endif /* ASSERT */
 681           __ movq(Address(rsp, next_off), r);
 682         } else {
 683           __ movptr(Address(rsp, st_off), r);
 684         }
 685       }
 686     } else {
 687       assert(r_1-&gt;is_XMMRegister(), &quot;&quot;);
 688       if (!r_2-&gt;is_valid()) {
 689         // only a float use just part of the slot
 690         __ movflt(Address(rsp, st_off), r_1-&gt;as_XMMRegister());
 691       } else {
 692 #ifdef ASSERT
 693         // Overwrite the unused slot with known junk
 694         __ mov64(rax, CONST64(0xdeadffffdeadaaac));
 695         __ movptr(Address(rsp, st_off), rax);
 696 #endif /* ASSERT */
 697         __ movdbl(Address(rsp, next_off), r_1-&gt;as_XMMRegister());
 698       }
 699     }
 700   }
 701 
 702   // Schedule the branch target address early.
 703   __ movptr(rcx, Address(rbx, in_bytes(Method::interpreter_entry_offset())));
 704   __ jmp(rcx);
 705 }
 706 
 707 static void range_check(MacroAssembler* masm, Register pc_reg, Register temp_reg,
 708                         address code_start, address code_end,
 709                         Label&amp; L_ok) {
 710   Label L_fail;
 711   __ lea(temp_reg, ExternalAddress(code_start));
 712   __ cmpptr(pc_reg, temp_reg);
 713   __ jcc(Assembler::belowEqual, L_fail);
 714   __ lea(temp_reg, ExternalAddress(code_end));
 715   __ cmpptr(pc_reg, temp_reg);
 716   __ jcc(Assembler::below, L_ok);
 717   __ bind(L_fail);
 718 }
 719 
 720 void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm,
 721                                     int total_args_passed,
 722                                     int comp_args_on_stack,
 723                                     const BasicType *sig_bt,
 724                                     const VMRegPair *regs) {
 725 
 726   // Note: r13 contains the senderSP on entry. We must preserve it since
 727   // we may do a i2c -&gt; c2i transition if we lose a race where compiled
 728   // code goes non-entrant while we get args ready.
 729   // In addition we use r13 to locate all the interpreter args as
 730   // we must align the stack to 16 bytes on an i2c entry else we
 731   // lose alignment we expect in all compiled code and register
 732   // save code can segv when fxsave instructions find improperly
 733   // aligned stack pointer.
 734 
 735   // Adapters can be frameless because they do not require the caller
 736   // to perform additional cleanup work, such as correcting the stack pointer.
 737   // An i2c adapter is frameless because the *caller* frame, which is interpreted,
 738   // routinely repairs its own stack pointer (from interpreter_frame_last_sp),
 739   // even if a callee has modified the stack pointer.
 740   // A c2i adapter is frameless because the *callee* frame, which is interpreted,
 741   // routinely repairs its caller&#39;s stack pointer (from sender_sp, which is set
 742   // up via the senderSP register).
 743   // In other words, if *either* the caller or callee is interpreted, we can
 744   // get the stack pointer repaired after a call.
 745   // This is why c2i and i2c adapters cannot be indefinitely composed.
 746   // In particular, if a c2i adapter were to somehow call an i2c adapter,
 747   // both caller and callee would be compiled methods, and neither would
 748   // clean up the stack pointer changes performed by the two adapters.
 749   // If this happens, control eventually transfers back to the compiled
 750   // caller, but with an uncorrected stack, causing delayed havoc.
 751 
 752   // Pick up the return address
 753   __ movptr(rax, Address(rsp, 0));
 754 
 755   if (VerifyAdapterCalls &amp;&amp;
 756       (Interpreter::code() != NULL || StubRoutines::code1() != NULL)) {
 757     // So, let&#39;s test for cascading c2i/i2c adapters right now.
 758     //  assert(Interpreter::contains($return_addr) ||
 759     //         StubRoutines::contains($return_addr),
 760     //         &quot;i2c adapter must return to an interpreter frame&quot;);
 761     __ block_comment(&quot;verify_i2c { &quot;);
 762     Label L_ok;
 763     if (Interpreter::code() != NULL)
 764       range_check(masm, rax, r11,
 765                   Interpreter::code()-&gt;code_start(), Interpreter::code()-&gt;code_end(),
 766                   L_ok);
 767     if (StubRoutines::code1() != NULL)
 768       range_check(masm, rax, r11,
 769                   StubRoutines::code1()-&gt;code_begin(), StubRoutines::code1()-&gt;code_end(),
 770                   L_ok);
 771     if (StubRoutines::code2() != NULL)
 772       range_check(masm, rax, r11,
 773                   StubRoutines::code2()-&gt;code_begin(), StubRoutines::code2()-&gt;code_end(),
 774                   L_ok);
 775     const char* msg = &quot;i2c adapter must return to an interpreter frame&quot;;
 776     __ block_comment(msg);
 777     __ stop(msg);
 778     __ bind(L_ok);
 779     __ block_comment(&quot;} verify_i2ce &quot;);
 780   }
 781 
 782   // Must preserve original SP for loading incoming arguments because
 783   // we need to align the outgoing SP for compiled code.
 784   __ movptr(r11, rsp);
 785 
 786   // Cut-out for having no stack args.  Since up to 2 int/oop args are passed
 787   // in registers, we will occasionally have no stack args.
 788   int comp_words_on_stack = 0;
 789   if (comp_args_on_stack) {
 790     // Sig words on the stack are greater-than VMRegImpl::stack0.  Those in
 791     // registers are below.  By subtracting stack0, we either get a negative
 792     // number (all values in registers) or the maximum stack slot accessed.
 793 
 794     // Convert 4-byte c2 stack slots to words.
 795     comp_words_on_stack = align_up(comp_args_on_stack*VMRegImpl::stack_slot_size, wordSize)&gt;&gt;LogBytesPerWord;
 796     // Round up to miminum stack alignment, in wordSize
 797     comp_words_on_stack = align_up(comp_words_on_stack, 2);
 798     __ subptr(rsp, comp_words_on_stack * wordSize);
 799   }
 800 
 801 
 802   // Ensure compiled code always sees stack at proper alignment
 803   __ andptr(rsp, -16);
 804 
 805   // push the return address and misalign the stack that youngest frame always sees
 806   // as far as the placement of the call instruction
 807   __ push(rax);
 808 
 809   // Put saved SP in another register
 810   const Register saved_sp = rax;
 811   __ movptr(saved_sp, r11);
 812 
 813   // Will jump to the compiled code just as if compiled code was doing it.
 814   // Pre-load the register-jump target early, to schedule it better.
 815   __ movptr(r11, Address(rbx, in_bytes(Method::from_compiled_offset())));
 816 
 817 #if INCLUDE_JVMCI
 818   if (EnableJVMCI || UseAOT) {
 819     // check if this call should be routed towards a specific entry point
 820     __ cmpptr(Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())), 0);
 821     Label no_alternative_target;
 822     __ jcc(Assembler::equal, no_alternative_target);
 823     __ movptr(r11, Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 824     __ movptr(Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())), 0);
 825     __ bind(no_alternative_target);
 826   }
 827 #endif // INCLUDE_JVMCI
 828 
 829   // Now generate the shuffle code.  Pick up all register args and move the
 830   // rest through the floating point stack top.
 831   for (int i = 0; i &lt; total_args_passed; i++) {
 832     if (sig_bt[i] == T_VOID) {
 833       // Longs and doubles are passed in native word order, but misaligned
 834       // in the 32-bit build.
 835       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);
 836       continue;
 837     }
 838 
 839     // Pick up 0, 1 or 2 words from SP+offset.
 840 
 841     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(),
 842             &quot;scrambled load targets?&quot;);
 843     // Load in argument order going down.
 844     int ld_off = (total_args_passed - i)*Interpreter::stackElementSize;
 845     // Point to interpreter value (vs. tag)
 846     int next_off = ld_off - Interpreter::stackElementSize;
 847     //
 848     //
 849     //
 850     VMReg r_1 = regs[i].first();
 851     VMReg r_2 = regs[i].second();
 852     if (!r_1-&gt;is_valid()) {
 853       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 854       continue;
 855     }
 856     if (r_1-&gt;is_stack()) {
 857       // Convert stack slot to an SP offset (+ wordSize to account for return address )
 858       int st_off = regs[i].first()-&gt;reg2stack()*VMRegImpl::stack_slot_size + wordSize;
 859 
 860       // We can use r13 as a temp here because compiled code doesn&#39;t need r13 as an input
 861       // and if we end up going thru a c2i because of a miss a reasonable value of r13
 862       // will be generated.
 863       if (!r_2-&gt;is_valid()) {
 864         // sign extend???
 865         __ movl(r13, Address(saved_sp, ld_off));
 866         __ movptr(Address(rsp, st_off), r13);
 867       } else {
 868         //
 869         // We are using two optoregs. This can be either T_OBJECT, T_ADDRESS, T_LONG, or T_DOUBLE
 870         // the interpreter allocates two slots but only uses one for thr T_LONG or T_DOUBLE case
 871         // So we must adjust where to pick up the data to match the interpreter.
 872         //
 873         // Interpreter local[n] == MSW, local[n+1] == LSW however locals
 874         // are accessed as negative so LSW is at LOW address
 875 
 876         // ld_off is MSW so get LSW
 877         const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?
 878                            next_off : ld_off;
 879         __ movq(r13, Address(saved_sp, offset));
 880         // st_off is LSW (i.e. reg.first())
 881         __ movq(Address(rsp, st_off), r13);
 882       }
 883     } else if (r_1-&gt;is_Register()) {  // Register argument
 884       Register r = r_1-&gt;as_Register();
 885       assert(r != rax, &quot;must be different&quot;);
 886       if (r_2-&gt;is_valid()) {
 887         //
 888         // We are using two VMRegs. This can be either T_OBJECT, T_ADDRESS, T_LONG, or T_DOUBLE
 889         // the interpreter allocates two slots but only uses one for thr T_LONG or T_DOUBLE case
 890         // So we must adjust where to pick up the data to match the interpreter.
 891 
 892         const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?
 893                            next_off : ld_off;
 894 
 895         // this can be a misaligned move
 896         __ movq(r, Address(saved_sp, offset));
 897       } else {
 898         // sign extend and use a full word?
 899         __ movl(r, Address(saved_sp, ld_off));
 900       }
 901     } else {
 902       if (!r_2-&gt;is_valid()) {
 903         __ movflt(r_1-&gt;as_XMMRegister(), Address(saved_sp, ld_off));
 904       } else {
 905         __ movdbl(r_1-&gt;as_XMMRegister(), Address(saved_sp, next_off));
 906       }
 907     }
 908   }
 909 
 910   // 6243940 We might end up in handle_wrong_method if
 911   // the callee is deoptimized as we race thru here. If that
 912   // happens we don&#39;t want to take a safepoint because the
 913   // caller frame will look interpreted and arguments are now
 914   // &quot;compiled&quot; so it is much better to make this transition
 915   // invisible to the stack walking code. Unfortunately if
 916   // we try and find the callee by normal means a safepoint
 917   // is possible. So we stash the desired callee in the thread
 918   // and the vm will find there should this case occur.
 919 
 920   __ movptr(Address(r15_thread, JavaThread::callee_target_offset()), rbx);
 921 
 922   // put Method* where a c2i would expect should we end up there
 923   // only needed becaus eof c2 resolve stubs return Method* as a result in
 924   // rax
 925   __ mov(rax, rbx);
 926   __ jmp(r11);
 927 }
 928 
 929 // ---------------------------------------------------------------
 930 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,
 931                                                             int total_args_passed,
 932                                                             int comp_args_on_stack,
 933                                                             const BasicType *sig_bt,
 934                                                             const VMRegPair *regs,
 935                                                             AdapterFingerPrint* fingerprint) {
 936   address i2c_entry = __ pc();
 937 
 938   gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);
 939 
 940   // -------------------------------------------------------------------------
 941   // Generate a C2I adapter.  On entry we know rbx holds the Method* during calls
 942   // to the interpreter.  The args start out packed in the compiled layout.  They
 943   // need to be unpacked into the interpreter layout.  This will almost always
 944   // require some stack space.  We grow the current (compiled) stack, then repack
 945   // the args.  We  finally end in a jump to the generic interpreter entry point.
 946   // On exit from the interpreter, the interpreter will restore our SP (lest the
 947   // compiled code, which relys solely on SP and not RBP, get sick).
 948 
 949   address c2i_unverified_entry = __ pc();
 950   Label skip_fixup;
 951   Label ok;
 952 
 953   Register holder = rax;
 954   Register receiver = j_rarg0;
 955   Register temp = rbx;
 956 
 957   {
 958     __ load_klass(temp, receiver, rscratch1);
 959     __ cmpptr(temp, Address(holder, CompiledICHolder::holder_klass_offset()));
 960     __ movptr(rbx, Address(holder, CompiledICHolder::holder_metadata_offset()));
 961     __ jcc(Assembler::equal, ok);
 962     __ jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 963 
 964     __ bind(ok);
 965     // Method might have been compiled since the call site was patched to
 966     // interpreted if that is the case treat it as a miss so we can get
 967     // the call site corrected.
 968     __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), (int32_t)NULL_WORD);
 969     __ jcc(Assembler::equal, skip_fixup);
 970     __ jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 971   }
 972 
 973   address c2i_entry = __ pc();
 974 
 975   // Class initialization barrier for static methods
 976   address c2i_no_clinit_check_entry = NULL;
 977   if (VM_Version::supports_fast_class_init_checks()) {
 978     Label L_skip_barrier;
 979     Register method = rbx;
 980 
 981     { // Bypass the barrier for non-static methods
 982       Register flags  = rscratch1;
 983       __ movl(flags, Address(method, Method::access_flags_offset()));
 984       __ testl(flags, JVM_ACC_STATIC);
 985       __ jcc(Assembler::zero, L_skip_barrier); // non-static
 986     }
 987 
 988     Register klass = rscratch1;
 989     __ load_method_holder(klass, method);
 990     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
 991 
 992     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
 993 
 994     __ bind(L_skip_barrier);
 995     c2i_no_clinit_check_entry = __ pc();
 996   }
 997 
 998   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 999   bs-&gt;c2i_entry_barrier(masm);
1000 
1001   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
1002 
1003   __ flush();
1004   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);
1005 }
1006 
1007 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
1008                                          VMRegPair *regs,
1009                                          VMRegPair *regs2,
1010                                          int total_args_passed) {
1011   assert(regs2 == NULL, &quot;not needed on x86&quot;);
1012 // We return the amount of VMRegImpl stack slots we need to reserve for all
1013 // the arguments NOT counting out_preserve_stack_slots.
1014 
1015 // NOTE: These arrays will have to change when c1 is ported
1016 #ifdef _WIN64
1017     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
1018       c_rarg0, c_rarg1, c_rarg2, c_rarg3
1019     };
1020     static const XMMRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
1021       c_farg0, c_farg1, c_farg2, c_farg3
1022     };
1023 #else
1024     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
1025       c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, c_rarg5
1026     };
1027     static const XMMRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
1028       c_farg0, c_farg1, c_farg2, c_farg3,
1029       c_farg4, c_farg5, c_farg6, c_farg7
1030     };
1031 #endif // _WIN64
1032 
1033 
1034     uint int_args = 0;
1035     uint fp_args = 0;
1036     uint stk_args = 0; // inc by 2 each time
1037 
1038     for (int i = 0; i &lt; total_args_passed; i++) {
1039       switch (sig_bt[i]) {
1040       case T_BOOLEAN:
1041       case T_CHAR:
1042       case T_BYTE:
1043       case T_SHORT:
1044       case T_INT:
1045         if (int_args &lt; Argument::n_int_register_parameters_c) {
1046           regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
1047 #ifdef _WIN64
1048           fp_args++;
1049           // Allocate slots for callee to stuff register args the stack.
1050           stk_args += 2;
1051 #endif
1052         } else {
1053           regs[i].set1(VMRegImpl::stack2reg(stk_args));
1054           stk_args += 2;
1055         }
1056         break;
1057       case T_LONG:
1058         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1059         // fall through
1060       case T_OBJECT:
1061       case T_ARRAY:
1062       case T_ADDRESS:
1063       case T_METADATA:
1064         if (int_args &lt; Argument::n_int_register_parameters_c) {
1065           regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
1066 #ifdef _WIN64
1067           fp_args++;
1068           stk_args += 2;
1069 #endif
1070         } else {
1071           regs[i].set2(VMRegImpl::stack2reg(stk_args));
1072           stk_args += 2;
1073         }
1074         break;
1075       case T_FLOAT:
1076         if (fp_args &lt; Argument::n_float_register_parameters_c) {
1077           regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
1078 #ifdef _WIN64
1079           int_args++;
1080           // Allocate slots for callee to stuff register args the stack.
1081           stk_args += 2;
1082 #endif
1083         } else {
1084           regs[i].set1(VMRegImpl::stack2reg(stk_args));
1085           stk_args += 2;
1086         }
1087         break;
1088       case T_DOUBLE:
1089         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1090         if (fp_args &lt; Argument::n_float_register_parameters_c) {
1091           regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
1092 #ifdef _WIN64
1093           int_args++;
1094           // Allocate slots for callee to stuff register args the stack.
1095           stk_args += 2;
1096 #endif
1097         } else {
1098           regs[i].set2(VMRegImpl::stack2reg(stk_args));
1099           stk_args += 2;
1100         }
1101         break;
1102       case T_VOID: // Halves of longs and doubles
1103         assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
1104         regs[i].set_bad();
1105         break;
1106       default:
1107         ShouldNotReachHere();
1108         break;
1109       }
1110     }
1111 #ifdef _WIN64
1112   // windows abi requires that we always allocate enough stack space
1113   // for 4 64bit registers to be stored down.
1114   if (stk_args &lt; 8) {
1115     stk_args = 8;
1116   }
1117 #endif // _WIN64
1118 
1119   return stk_args;
1120 }
1121 
1122 // On 64 bit we will store integer like items to the stack as
1123 // 64 bits items (sparc abi) even though java would only store
1124 // 32bits for a parameter. On 32bit it will simply be 32 bits
1125 // So this routine will do 32-&gt;32 on 32bit and 32-&gt;64 on 64bit
1126 static void move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1127   if (src.first()-&gt;is_stack()) {
1128     if (dst.first()-&gt;is_stack()) {
1129       // stack to stack
1130       __ movslq(rax, Address(rbp, reg2offset_in(src.first())));
1131       __ movq(Address(rsp, reg2offset_out(dst.first())), rax);
1132     } else {
1133       // stack to reg
1134       __ movslq(dst.first()-&gt;as_Register(), Address(rbp, reg2offset_in(src.first())));
1135     }
1136   } else if (dst.first()-&gt;is_stack()) {
1137     // reg to stack
1138     // Do we really have to sign extend???
1139     // __ movslq(src.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1140     __ movq(Address(rsp, reg2offset_out(dst.first())), src.first()-&gt;as_Register());
1141   } else {
1142     // Do we really have to sign extend???
1143     // __ movslq(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1144     if (dst.first() != src.first()) {
1145       __ movq(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1146     }
1147   }
1148 }
1149 
1150 static void move_ptr(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1151   if (src.first()-&gt;is_stack()) {
1152     if (dst.first()-&gt;is_stack()) {
1153       // stack to stack
1154       __ movq(rax, Address(rbp, reg2offset_in(src.first())));
1155       __ movq(Address(rsp, reg2offset_out(dst.first())), rax);
1156     } else {
1157       // stack to reg
1158       __ movq(dst.first()-&gt;as_Register(), Address(rbp, reg2offset_in(src.first())));
1159     }
1160   } else if (dst.first()-&gt;is_stack()) {
1161     // reg to stack
1162     __ movq(Address(rsp, reg2offset_out(dst.first())), src.first()-&gt;as_Register());
1163   } else {
1164     if (dst.first() != src.first()) {
1165       __ movq(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1166     }
1167   }
1168 }
1169 
1170 // An oop arg. Must pass a handle not the oop itself
1171 static void object_move(MacroAssembler* masm,
1172                         OopMap* map,
1173                         int oop_handle_offset,
1174                         int framesize_in_slots,
1175                         VMRegPair src,
1176                         VMRegPair dst,
1177                         bool is_receiver,
1178                         int* receiver_offset) {
1179 
1180   // must pass a handle. First figure out the location we use as a handle
1181 
1182   Register rHandle = dst.first()-&gt;is_stack() ? rax : dst.first()-&gt;as_Register();
1183 
1184   // See if oop is NULL if it is we need no handle
1185 
1186   if (src.first()-&gt;is_stack()) {
1187 
1188     // Oop is already on the stack as an argument
1189     int offset_in_older_frame = src.first()-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
1190     map-&gt;set_oop(VMRegImpl::stack2reg(offset_in_older_frame + framesize_in_slots));
1191     if (is_receiver) {
1192       *receiver_offset = (offset_in_older_frame + framesize_in_slots) * VMRegImpl::stack_slot_size;
1193     }
1194 
1195     __ cmpptr(Address(rbp, reg2offset_in(src.first())), (int32_t)NULL_WORD);
1196     __ lea(rHandle, Address(rbp, reg2offset_in(src.first())));
1197     // conditionally move a NULL
1198     __ cmovptr(Assembler::equal, rHandle, Address(rbp, reg2offset_in(src.first())));
1199   } else {
1200 
1201     // Oop is in an a register we must store it to the space we reserve
1202     // on the stack for oop_handles and pass a handle if oop is non-NULL
1203 
1204     const Register rOop = src.first()-&gt;as_Register();
1205     int oop_slot;
1206     if (rOop == j_rarg0)
1207       oop_slot = 0;
1208     else if (rOop == j_rarg1)
1209       oop_slot = 1;
1210     else if (rOop == j_rarg2)
1211       oop_slot = 2;
1212     else if (rOop == j_rarg3)
1213       oop_slot = 3;
1214     else if (rOop == j_rarg4)
1215       oop_slot = 4;
1216     else {
1217       assert(rOop == j_rarg5, &quot;wrong register&quot;);
1218       oop_slot = 5;
1219     }
1220 
1221     oop_slot = oop_slot * VMRegImpl::slots_per_word + oop_handle_offset;
1222     int offset = oop_slot*VMRegImpl::stack_slot_size;
1223 
1224     map-&gt;set_oop(VMRegImpl::stack2reg(oop_slot));
1225     // Store oop in handle area, may be NULL
1226     __ movptr(Address(rsp, offset), rOop);
1227     if (is_receiver) {
1228       *receiver_offset = offset;
1229     }
1230 
1231     __ cmpptr(rOop, (int32_t)NULL_WORD);
1232     __ lea(rHandle, Address(rsp, offset));
1233     // conditionally move a NULL from the handle area where it was just stored
1234     __ cmovptr(Assembler::equal, rHandle, Address(rsp, offset));
1235   }
1236 
1237   // If arg is on the stack then place it otherwise it is already in correct reg.
1238   if (dst.first()-&gt;is_stack()) {
1239     __ movptr(Address(rsp, reg2offset_out(dst.first())), rHandle);
1240   }
1241 }
1242 
1243 // A float arg may have to do float reg int reg conversion
1244 static void float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1245   assert(!src.second()-&gt;is_valid() &amp;&amp; !dst.second()-&gt;is_valid(), &quot;bad float_move&quot;);
1246 
1247   // The calling conventions assures us that each VMregpair is either
1248   // all really one physical register or adjacent stack slots.
1249   // This greatly simplifies the cases here compared to sparc.
1250 
1251   if (src.first()-&gt;is_stack()) {
1252     if (dst.first()-&gt;is_stack()) {
1253       __ movl(rax, Address(rbp, reg2offset_in(src.first())));
1254       __ movptr(Address(rsp, reg2offset_out(dst.first())), rax);
1255     } else {
1256       // stack to reg
1257       assert(dst.first()-&gt;is_XMMRegister(), &quot;only expect xmm registers as parameters&quot;);
1258       __ movflt(dst.first()-&gt;as_XMMRegister(), Address(rbp, reg2offset_in(src.first())));
1259     }
1260   } else if (dst.first()-&gt;is_stack()) {
1261     // reg to stack
1262     assert(src.first()-&gt;is_XMMRegister(), &quot;only expect xmm registers as parameters&quot;);
1263     __ movflt(Address(rsp, reg2offset_out(dst.first())), src.first()-&gt;as_XMMRegister());
1264   } else {
1265     // reg to reg
1266     // In theory these overlap but the ordering is such that this is likely a nop
1267     if ( src.first() != dst.first()) {
1268       __ movdbl(dst.first()-&gt;as_XMMRegister(),  src.first()-&gt;as_XMMRegister());
1269     }
1270   }
1271 }
1272 
1273 // A long move
1274 static void long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1275 
1276   // The calling conventions assures us that each VMregpair is either
1277   // all really one physical register or adjacent stack slots.
1278   // This greatly simplifies the cases here compared to sparc.
1279 
1280   if (src.is_single_phys_reg() ) {
1281     if (dst.is_single_phys_reg()) {
1282       if (dst.first() != src.first()) {
1283         __ mov(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1284       }
1285     } else {
1286       assert(dst.is_single_reg(), &quot;not a stack pair&quot;);
1287       __ movq(Address(rsp, reg2offset_out(dst.first())), src.first()-&gt;as_Register());
1288     }
1289   } else if (dst.is_single_phys_reg()) {
1290     assert(src.is_single_reg(),  &quot;not a stack pair&quot;);
1291     __ movq(dst.first()-&gt;as_Register(), Address(rbp, reg2offset_out(src.first())));
1292   } else {
1293     assert(src.is_single_reg() &amp;&amp; dst.is_single_reg(), &quot;not stack pairs&quot;);
1294     __ movq(rax, Address(rbp, reg2offset_in(src.first())));
1295     __ movq(Address(rsp, reg2offset_out(dst.first())), rax);
1296   }
1297 }
1298 
1299 // A double move
1300 static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1301 
1302   // The calling conventions assures us that each VMregpair is either
1303   // all really one physical register or adjacent stack slots.
1304   // This greatly simplifies the cases here compared to sparc.
1305 
1306   if (src.is_single_phys_reg() ) {
1307     if (dst.is_single_phys_reg()) {
1308       // In theory these overlap but the ordering is such that this is likely a nop
1309       if ( src.first() != dst.first()) {
1310         __ movdbl(dst.first()-&gt;as_XMMRegister(), src.first()-&gt;as_XMMRegister());
1311       }
1312     } else {
1313       assert(dst.is_single_reg(), &quot;not a stack pair&quot;);
1314       __ movdbl(Address(rsp, reg2offset_out(dst.first())), src.first()-&gt;as_XMMRegister());
1315     }
1316   } else if (dst.is_single_phys_reg()) {
1317     assert(src.is_single_reg(),  &quot;not a stack pair&quot;);
1318     __ movdbl(dst.first()-&gt;as_XMMRegister(), Address(rbp, reg2offset_out(src.first())));
1319   } else {
1320     assert(src.is_single_reg() &amp;&amp; dst.is_single_reg(), &quot;not stack pairs&quot;);
1321     __ movq(rax, Address(rbp, reg2offset_in(src.first())));
1322     __ movq(Address(rsp, reg2offset_out(dst.first())), rax);
1323   }
1324 }
1325 
1326 
1327 void SharedRuntime::save_native_result(MacroAssembler *masm, BasicType ret_type, int frame_slots) {
1328   // We always ignore the frame_slots arg and just use the space just below frame pointer
1329   // which by this time is free to use
1330   switch (ret_type) {
1331   case T_FLOAT:
1332     __ movflt(Address(rbp, -wordSize), xmm0);
1333     break;
1334   case T_DOUBLE:
1335     __ movdbl(Address(rbp, -wordSize), xmm0);
1336     break;
1337   case T_VOID:  break;
1338   default: {
1339     __ movptr(Address(rbp, -wordSize), rax);
1340     }
1341   }
1342 }
1343 
1344 void SharedRuntime::restore_native_result(MacroAssembler *masm, BasicType ret_type, int frame_slots) {
1345   // We always ignore the frame_slots arg and just use the space just below frame pointer
1346   // which by this time is free to use
1347   switch (ret_type) {
1348   case T_FLOAT:
1349     __ movflt(xmm0, Address(rbp, -wordSize));
1350     break;
1351   case T_DOUBLE:
1352     __ movdbl(xmm0, Address(rbp, -wordSize));
1353     break;
1354   case T_VOID:  break;
1355   default: {
1356     __ movptr(rax, Address(rbp, -wordSize));
1357     }
1358   }
1359 }
1360 
1361 static void save_args(MacroAssembler *masm, int arg_count, int first_arg, VMRegPair *args) {
1362     for ( int i = first_arg ; i &lt; arg_count ; i++ ) {
1363       if (args[i].first()-&gt;is_Register()) {
1364         __ push(args[i].first()-&gt;as_Register());
1365       } else if (args[i].first()-&gt;is_XMMRegister()) {
1366         __ subptr(rsp, 2*wordSize);
1367         __ movdbl(Address(rsp, 0), args[i].first()-&gt;as_XMMRegister());
1368       }
1369     }
1370 }
1371 
1372 static void restore_args(MacroAssembler *masm, int arg_count, int first_arg, VMRegPair *args) {
1373     for ( int i = arg_count - 1 ; i &gt;= first_arg ; i-- ) {
1374       if (args[i].first()-&gt;is_Register()) {
1375         __ pop(args[i].first()-&gt;as_Register());
1376       } else if (args[i].first()-&gt;is_XMMRegister()) {
1377         __ movdbl(args[i].first()-&gt;as_XMMRegister(), Address(rsp, 0));
1378         __ addptr(rsp, 2*wordSize);
1379       }
1380     }
1381 }
1382 
1383 
1384 static void save_or_restore_arguments(MacroAssembler* masm,
1385                                       const int stack_slots,
1386                                       const int total_in_args,
1387                                       const int arg_save_area,
1388                                       OopMap* map,
1389                                       VMRegPair* in_regs,
1390                                       BasicType* in_sig_bt) {
1391   // if map is non-NULL then the code should store the values,
1392   // otherwise it should load them.
1393   int slot = arg_save_area;
1394   // Save down double word first
1395   for ( int i = 0; i &lt; total_in_args; i++) {
1396     if (in_regs[i].first()-&gt;is_XMMRegister() &amp;&amp; in_sig_bt[i] == T_DOUBLE) {
1397       int offset = slot * VMRegImpl::stack_slot_size;
1398       slot += VMRegImpl::slots_per_word;
1399       assert(slot &lt;= stack_slots, &quot;overflow&quot;);
1400       if (map != NULL) {
1401         __ movdbl(Address(rsp, offset), in_regs[i].first()-&gt;as_XMMRegister());
1402       } else {
1403         __ movdbl(in_regs[i].first()-&gt;as_XMMRegister(), Address(rsp, offset));
1404       }
1405     }
1406     if (in_regs[i].first()-&gt;is_Register() &amp;&amp;
1407         (in_sig_bt[i] == T_LONG || in_sig_bt[i] == T_ARRAY)) {
1408       int offset = slot * VMRegImpl::stack_slot_size;
1409       if (map != NULL) {
1410         __ movq(Address(rsp, offset), in_regs[i].first()-&gt;as_Register());
1411         if (in_sig_bt[i] == T_ARRAY) {
1412           map-&gt;set_oop(VMRegImpl::stack2reg(slot));;
1413         }
1414       } else {
1415         __ movq(in_regs[i].first()-&gt;as_Register(), Address(rsp, offset));
1416       }
1417       slot += VMRegImpl::slots_per_word;
1418     }
1419   }
1420   // Save or restore single word registers
1421   for ( int i = 0; i &lt; total_in_args; i++) {
1422     if (in_regs[i].first()-&gt;is_Register()) {
1423       int offset = slot * VMRegImpl::stack_slot_size;
1424       slot++;
1425       assert(slot &lt;= stack_slots, &quot;overflow&quot;);
1426 
1427       // Value is in an input register pass we must flush it to the stack
1428       const Register reg = in_regs[i].first()-&gt;as_Register();
1429       switch (in_sig_bt[i]) {
1430         case T_BOOLEAN:
1431         case T_CHAR:
1432         case T_BYTE:
1433         case T_SHORT:
1434         case T_INT:
1435           if (map != NULL) {
1436             __ movl(Address(rsp, offset), reg);
1437           } else {
1438             __ movl(reg, Address(rsp, offset));
1439           }
1440           break;
1441         case T_ARRAY:
1442         case T_LONG:
1443           // handled above
1444           break;
1445         case T_OBJECT:
1446         default: ShouldNotReachHere();
1447       }
1448     } else if (in_regs[i].first()-&gt;is_XMMRegister()) {
1449       if (in_sig_bt[i] == T_FLOAT) {
1450         int offset = slot * VMRegImpl::stack_slot_size;
1451         slot++;
1452         assert(slot &lt;= stack_slots, &quot;overflow&quot;);
1453         if (map != NULL) {
1454           __ movflt(Address(rsp, offset), in_regs[i].first()-&gt;as_XMMRegister());
1455         } else {
1456           __ movflt(in_regs[i].first()-&gt;as_XMMRegister(), Address(rsp, offset));
1457         }
1458       }
1459     } else if (in_regs[i].first()-&gt;is_stack()) {
1460       if (in_sig_bt[i] == T_ARRAY &amp;&amp; map != NULL) {
1461         int offset_in_older_frame = in_regs[i].first()-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
1462         map-&gt;set_oop(VMRegImpl::stack2reg(offset_in_older_frame + stack_slots));
1463       }
1464     }
1465   }
1466 }
1467 
1468 // Pin object, return pinned object or null in rax
1469 static void gen_pin_object(MacroAssembler* masm,
1470                            VMRegPair reg) {
1471   __ block_comment(&quot;gen_pin_object {&quot;);
1472 
1473   // rax always contains oop, either incoming or
1474   // pinned.
1475   Register tmp_reg = rax;
1476 
1477   Label is_null;
1478   VMRegPair tmp;
1479   VMRegPair in_reg = reg;
1480 
1481   tmp.set_ptr(tmp_reg-&gt;as_VMReg());
1482   if (reg.first()-&gt;is_stack()) {
1483     // Load the arg up from the stack
1484     move_ptr(masm, reg, tmp);
1485     reg = tmp;
1486   } else {
1487     __ movptr(rax, reg.first()-&gt;as_Register());
1488   }
1489   __ testptr(reg.first()-&gt;as_Register(), reg.first()-&gt;as_Register());
1490   __ jccb(Assembler::equal, is_null);
1491 
1492   if (reg.first()-&gt;as_Register() != c_rarg1) {
1493     __ movptr(c_rarg1, reg.first()-&gt;as_Register());
1494   }
1495 
1496   __ call_VM_leaf(
1497     CAST_FROM_FN_PTR(address, SharedRuntime::pin_object),
1498     r15_thread, c_rarg1);
1499 
1500   __ bind(is_null);
1501   __ block_comment(&quot;} gen_pin_object&quot;);
1502 }
1503 
1504 // Unpin object
1505 static void gen_unpin_object(MacroAssembler* masm,
1506                              VMRegPair reg) {
1507   __ block_comment(&quot;gen_unpin_object {&quot;);
1508   Label is_null;
1509 
1510   if (reg.first()-&gt;is_stack()) {
1511     __ movptr(c_rarg1, Address(rbp, reg2offset_in(reg.first())));
1512   } else if (reg.first()-&gt;as_Register() != c_rarg1) {
1513     __ movptr(c_rarg1, reg.first()-&gt;as_Register());
1514   }
1515 
1516   __ testptr(c_rarg1, c_rarg1);
1517   __ jccb(Assembler::equal, is_null);
1518 
1519   __ call_VM_leaf(
1520     CAST_FROM_FN_PTR(address, SharedRuntime::unpin_object),
1521     r15_thread, c_rarg1);
1522 
1523   __ bind(is_null);
1524   __ block_comment(&quot;} gen_unpin_object&quot;);
1525 }
1526 
1527 // Check GCLocker::needs_gc and enter the runtime if it&#39;s true.  This
1528 // keeps a new JNI critical region from starting until a GC has been
1529 // forced.  Save down any oops in registers and describe them in an
1530 // OopMap.
1531 static void check_needs_gc_for_critical_native(MacroAssembler* masm,
1532                                                int stack_slots,
1533                                                int total_c_args,
1534                                                int total_in_args,
1535                                                int arg_save_area,
1536                                                OopMapSet* oop_maps,
1537                                                VMRegPair* in_regs,
1538                                                BasicType* in_sig_bt) {
1539   __ block_comment(&quot;check GCLocker::needs_gc&quot;);
1540   Label cont;
1541   __ cmp8(ExternalAddress((address)GCLocker::needs_gc_address()), false);
1542   __ jcc(Assembler::equal, cont);
1543 
1544   // Save down any incoming oops and call into the runtime to halt for a GC
1545 
1546   OopMap* map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
1547   save_or_restore_arguments(masm, stack_slots, total_in_args,
1548                             arg_save_area, map, in_regs, in_sig_bt);
1549 
1550   address the_pc = __ pc();
1551   oop_maps-&gt;add_gc_map( __ offset(), map);
1552   __ set_last_Java_frame(rsp, noreg, the_pc);
1553 
1554   __ block_comment(&quot;block_for_jni_critical&quot;);
1555   __ movptr(c_rarg0, r15_thread);
1556   __ mov(r12, rsp); // remember sp
1557   __ subptr(rsp, frame::arg_reg_save_area_bytes); // windows
1558   __ andptr(rsp, -16); // align stack as required by ABI
1559   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::block_for_jni_critical)));
1560   __ mov(rsp, r12); // restore sp
1561   __ reinit_heapbase();
1562 
1563   __ reset_last_Java_frame(false);
1564 
1565   save_or_restore_arguments(masm, stack_slots, total_in_args,
1566                             arg_save_area, NULL, in_regs, in_sig_bt);
1567   __ bind(cont);
1568 #ifdef ASSERT
1569   if (StressCriticalJNINatives) {
1570     // Stress register saving
1571     OopMap* map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
1572     save_or_restore_arguments(masm, stack_slots, total_in_args,
1573                               arg_save_area, map, in_regs, in_sig_bt);
1574     // Destroy argument registers
1575     for (int i = 0; i &lt; total_in_args - 1; i++) {
1576       if (in_regs[i].first()-&gt;is_Register()) {
1577         const Register reg = in_regs[i].first()-&gt;as_Register();
1578         __ xorptr(reg, reg);
1579       } else if (in_regs[i].first()-&gt;is_XMMRegister()) {
1580         __ xorpd(in_regs[i].first()-&gt;as_XMMRegister(), in_regs[i].first()-&gt;as_XMMRegister());
1581       } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
1582         ShouldNotReachHere();
1583       } else if (in_regs[i].first()-&gt;is_stack()) {
1584         // Nothing to do
1585       } else {
1586         ShouldNotReachHere();
1587       }
1588       if (in_sig_bt[i] == T_LONG || in_sig_bt[i] == T_DOUBLE) {
1589         i++;
1590       }
1591     }
1592 
1593     save_or_restore_arguments(masm, stack_slots, total_in_args,
1594                               arg_save_area, NULL, in_regs, in_sig_bt);
1595   }
1596 #endif
1597 }
1598 
1599 // Unpack an array argument into a pointer to the body and the length
1600 // if the array is non-null, otherwise pass 0 for both.
1601 static void unpack_array_argument(MacroAssembler* masm, VMRegPair reg, BasicType in_elem_type, VMRegPair body_arg, VMRegPair length_arg) {
1602   Register tmp_reg = rax;
1603   assert(!body_arg.first()-&gt;is_Register() || body_arg.first()-&gt;as_Register() != tmp_reg,
1604          &quot;possible collision&quot;);
1605   assert(!length_arg.first()-&gt;is_Register() || length_arg.first()-&gt;as_Register() != tmp_reg,
1606          &quot;possible collision&quot;);
1607 
1608   __ block_comment(&quot;unpack_array_argument {&quot;);
1609 
1610   // Pass the length, ptr pair
1611   Label is_null, done;
1612   VMRegPair tmp;
1613   tmp.set_ptr(tmp_reg-&gt;as_VMReg());
1614   if (reg.first()-&gt;is_stack()) {
1615     // Load the arg up from the stack
1616     move_ptr(masm, reg, tmp);
1617     reg = tmp;
1618   }
1619   __ testptr(reg.first()-&gt;as_Register(), reg.first()-&gt;as_Register());
1620   __ jccb(Assembler::equal, is_null);
1621   __ lea(tmp_reg, Address(reg.first()-&gt;as_Register(), arrayOopDesc::base_offset_in_bytes(in_elem_type)));
1622   move_ptr(masm, tmp, body_arg);
1623   // load the length relative to the body.
1624   __ movl(tmp_reg, Address(tmp_reg, arrayOopDesc::length_offset_in_bytes() -
1625                            arrayOopDesc::base_offset_in_bytes(in_elem_type)));
1626   move32_64(masm, tmp, length_arg);
1627   __ jmpb(done);
1628   __ bind(is_null);
1629   // Pass zeros
1630   __ xorptr(tmp_reg, tmp_reg);
1631   move_ptr(masm, tmp, body_arg);
1632   move32_64(masm, tmp, length_arg);
1633   __ bind(done);
1634 
1635   __ block_comment(&quot;} unpack_array_argument&quot;);
1636 }
1637 
1638 
1639 // Different signatures may require very different orders for the move
1640 // to avoid clobbering other arguments.  There&#39;s no simple way to
1641 // order them safely.  Compute a safe order for issuing stores and
1642 // break any cycles in those stores.  This code is fairly general but
1643 // it&#39;s not necessary on the other platforms so we keep it in the
1644 // platform dependent code instead of moving it into a shared file.
1645 // (See bugs 7013347 &amp; 7145024.)
1646 // Note that this code is specific to LP64.
1647 class ComputeMoveOrder: public StackObj {
1648   class MoveOperation: public ResourceObj {
1649     friend class ComputeMoveOrder;
1650    private:
1651     VMRegPair        _src;
1652     VMRegPair        _dst;
1653     int              _src_index;
1654     int              _dst_index;
1655     bool             _processed;
1656     MoveOperation*  _next;
1657     MoveOperation*  _prev;
1658 
1659     static int get_id(VMRegPair r) {
1660       return r.first()-&gt;value();
1661     }
1662 
1663    public:
1664     MoveOperation(int src_index, VMRegPair src, int dst_index, VMRegPair dst):
1665       _src(src)
1666     , _dst(dst)
1667     , _src_index(src_index)
1668     , _dst_index(dst_index)
1669     , _processed(false)
1670     , _next(NULL)
1671     , _prev(NULL) {
1672     }
1673 
1674     VMRegPair src() const              { return _src; }
1675     int src_id() const                 { return get_id(src()); }
1676     int src_index() const              { return _src_index; }
1677     VMRegPair dst() const              { return _dst; }
1678     void set_dst(int i, VMRegPair dst) { _dst_index = i, _dst = dst; }
1679     int dst_index() const              { return _dst_index; }
1680     int dst_id() const                 { return get_id(dst()); }
1681     MoveOperation* next() const       { return _next; }
1682     MoveOperation* prev() const       { return _prev; }
1683     void set_processed()               { _processed = true; }
1684     bool is_processed() const          { return _processed; }
1685 
1686     // insert
1687     void break_cycle(VMRegPair temp_register) {
1688       // create a new store following the last store
1689       // to move from the temp_register to the original
1690       MoveOperation* new_store = new MoveOperation(-1, temp_register, dst_index(), dst());
1691 
1692       // break the cycle of links and insert new_store at the end
1693       // break the reverse link.
1694       MoveOperation* p = prev();
1695       assert(p-&gt;next() == this, &quot;must be&quot;);
1696       _prev = NULL;
1697       p-&gt;_next = new_store;
1698       new_store-&gt;_prev = p;
1699 
1700       // change the original store to save it&#39;s value in the temp.
1701       set_dst(-1, temp_register);
1702     }
1703 
1704     void link(GrowableArray&lt;MoveOperation*&gt;&amp; killer) {
1705       // link this store in front the store that it depends on
1706       MoveOperation* n = killer.at_grow(src_id(), NULL);
1707       if (n != NULL) {
1708         assert(_next == NULL &amp;&amp; n-&gt;_prev == NULL, &quot;shouldn&#39;t have been set yet&quot;);
1709         _next = n;
1710         n-&gt;_prev = this;
1711       }
1712     }
1713   };
1714 
1715  private:
1716   GrowableArray&lt;MoveOperation*&gt; edges;
1717 
1718  public:
1719   ComputeMoveOrder(int total_in_args, VMRegPair* in_regs, int total_c_args, VMRegPair* out_regs,
1720                     BasicType* in_sig_bt, GrowableArray&lt;int&gt;&amp; arg_order, VMRegPair tmp_vmreg) {
1721     // Move operations where the dest is the stack can all be
1722     // scheduled first since they can&#39;t interfere with the other moves.
1723     for (int i = total_in_args - 1, c_arg = total_c_args - 1; i &gt;= 0; i--, c_arg--) {
1724       if (in_sig_bt[i] == T_ARRAY) {
1725         c_arg--;
1726         if (out_regs[c_arg].first()-&gt;is_stack() &amp;&amp;
1727             out_regs[c_arg + 1].first()-&gt;is_stack()) {
1728           arg_order.push(i);
1729           arg_order.push(c_arg);
1730         } else {
1731           if (out_regs[c_arg].first()-&gt;is_stack() ||
1732               in_regs[i].first() == out_regs[c_arg].first()) {
1733             add_edge(i, in_regs[i].first(), c_arg, out_regs[c_arg + 1]);
1734           } else {
1735             add_edge(i, in_regs[i].first(), c_arg, out_regs[c_arg]);
1736           }
1737         }
1738       } else if (in_sig_bt[i] == T_VOID) {
1739         arg_order.push(i);
1740         arg_order.push(c_arg);
1741       } else {
1742         if (out_regs[c_arg].first()-&gt;is_stack() ||
1743             in_regs[i].first() == out_regs[c_arg].first()) {
1744           arg_order.push(i);
1745           arg_order.push(c_arg);
1746         } else {
1747           add_edge(i, in_regs[i].first(), c_arg, out_regs[c_arg]);
1748         }
1749       }
1750     }
1751     // Break any cycles in the register moves and emit the in the
1752     // proper order.
1753     GrowableArray&lt;MoveOperation*&gt;* stores = get_store_order(tmp_vmreg);
1754     for (int i = 0; i &lt; stores-&gt;length(); i++) {
1755       arg_order.push(stores-&gt;at(i)-&gt;src_index());
1756       arg_order.push(stores-&gt;at(i)-&gt;dst_index());
1757     }
1758  }
1759 
1760   // Collected all the move operations
1761   void add_edge(int src_index, VMRegPair src, int dst_index, VMRegPair dst) {
1762     if (src.first() == dst.first()) return;
1763     edges.append(new MoveOperation(src_index, src, dst_index, dst));
1764   }
1765 
1766   // Walk the edges breaking cycles between moves.  The result list
1767   // can be walked in order to produce the proper set of loads
1768   GrowableArray&lt;MoveOperation*&gt;* get_store_order(VMRegPair temp_register) {
1769     // Record which moves kill which values
1770     GrowableArray&lt;MoveOperation*&gt; killer;
1771     for (int i = 0; i &lt; edges.length(); i++) {
1772       MoveOperation* s = edges.at(i);
1773       assert(killer.at_grow(s-&gt;dst_id(), NULL) == NULL, &quot;only one killer&quot;);
1774       killer.at_put_grow(s-&gt;dst_id(), s, NULL);
1775     }
1776     assert(killer.at_grow(MoveOperation::get_id(temp_register), NULL) == NULL,
1777            &quot;make sure temp isn&#39;t in the registers that are killed&quot;);
1778 
1779     // create links between loads and stores
1780     for (int i = 0; i &lt; edges.length(); i++) {
1781       edges.at(i)-&gt;link(killer);
1782     }
1783 
1784     // at this point, all the move operations are chained together
1785     // in a doubly linked list.  Processing it backwards finds
1786     // the beginning of the chain, forwards finds the end.  If there&#39;s
1787     // a cycle it can be broken at any point,  so pick an edge and walk
1788     // backward until the list ends or we end where we started.
1789     GrowableArray&lt;MoveOperation*&gt;* stores = new GrowableArray&lt;MoveOperation*&gt;();
1790     for (int e = 0; e &lt; edges.length(); e++) {
1791       MoveOperation* s = edges.at(e);
1792       if (!s-&gt;is_processed()) {
1793         MoveOperation* start = s;
1794         // search for the beginning of the chain or cycle
1795         while (start-&gt;prev() != NULL &amp;&amp; start-&gt;prev() != s) {
1796           start = start-&gt;prev();
1797         }
1798         if (start-&gt;prev() == s) {
1799           start-&gt;break_cycle(temp_register);
1800         }
1801         // walk the chain forward inserting to store list
1802         while (start != NULL) {
1803           stores-&gt;append(start);
1804           start-&gt;set_processed();
1805           start = start-&gt;next();
1806         }
1807       }
1808     }
1809     return stores;
1810   }
1811 };
1812 
1813 static void verify_oop_args(MacroAssembler* masm,
1814                             const methodHandle&amp; method,
1815                             const BasicType* sig_bt,
1816                             const VMRegPair* regs) {
1817   Register temp_reg = rbx;  // not part of any compiled calling seq
1818   if (VerifyOops) {
1819     for (int i = 0; i &lt; method-&gt;size_of_parameters(); i++) {
1820       if (is_reference_type(sig_bt[i])) {
1821         VMReg r = regs[i].first();
1822         assert(r-&gt;is_valid(), &quot;bad oop arg&quot;);
1823         if (r-&gt;is_stack()) {
1824           __ movptr(temp_reg, Address(rsp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size + wordSize));
1825           __ verify_oop(temp_reg);
1826         } else {
1827           __ verify_oop(r-&gt;as_Register());
1828         }
1829       }
1830     }
1831   }
1832 }
1833 
1834 static void gen_special_dispatch(MacroAssembler* masm,
1835                                  const methodHandle&amp; method,
1836                                  const BasicType* sig_bt,
1837                                  const VMRegPair* regs) {
1838   verify_oop_args(masm, method, sig_bt, regs);
1839   vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1840 
1841   // Now write the args into the outgoing interpreter space
1842   bool     has_receiver   = false;
1843   Register receiver_reg   = noreg;
1844   int      member_arg_pos = -1;
1845   Register member_reg     = noreg;
1846   int      ref_kind       = MethodHandles::signature_polymorphic_intrinsic_ref_kind(iid);
1847   if (ref_kind != 0) {
1848     member_arg_pos = method-&gt;size_of_parameters() - 1;  // trailing MemberName argument
1849     member_reg = rbx;  // known to be free at this point
1850     has_receiver = MethodHandles::ref_kind_has_receiver(ref_kind);
1851   } else if (iid == vmIntrinsics::_invokeBasic || iid == vmIntrinsics::_linkToNative) {
1852     has_receiver = true;
1853   } else {
1854     fatal(&quot;unexpected intrinsic id %d&quot;, iid);
1855   }
1856 
1857   if (member_reg != noreg) {
1858     // Load the member_arg into register, if necessary.
1859     SharedRuntime::check_member_name_argument_is_last_argument(method, sig_bt, regs);
1860     VMReg r = regs[member_arg_pos].first();
1861     if (r-&gt;is_stack()) {
1862       __ movptr(member_reg, Address(rsp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size + wordSize));
1863     } else {
1864       // no data motion is needed
1865       member_reg = r-&gt;as_Register();
1866     }
1867   }
1868 
1869   if (has_receiver) {
1870     // Make sure the receiver is loaded into a register.
1871     assert(method-&gt;size_of_parameters() &gt; 0, &quot;oob&quot;);
1872     assert(sig_bt[0] == T_OBJECT, &quot;receiver argument must be an object&quot;);
1873     VMReg r = regs[0].first();
1874     assert(r-&gt;is_valid(), &quot;bad receiver arg&quot;);
1875     if (r-&gt;is_stack()) {
1876       // Porting note:  This assumes that compiled calling conventions always
1877       // pass the receiver oop in a register.  If this is not true on some
1878       // platform, pick a temp and load the receiver from stack.
1879       fatal(&quot;receiver always in a register&quot;);
1880       receiver_reg = j_rarg0;  // known to be free at this point
1881       __ movptr(receiver_reg, Address(rsp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size + wordSize));
1882     } else {
1883       // no data motion is needed
1884       receiver_reg = r-&gt;as_Register();
1885     }
1886   }
1887 
1888   // Figure out which address we are really jumping to:
1889   MethodHandles::generate_method_handle_dispatch(masm, iid,
1890                                                  receiver_reg, member_reg, /*for_compiler_entry:*/ true);
1891 }
1892 
1893 // ---------------------------------------------------------------------------
1894 // Generate a native wrapper for a given method.  The method takes arguments
1895 // in the Java compiled code convention, marshals them to the native
1896 // convention (handlizes oops, etc), transitions to native, makes the call,
1897 // returns to java state (possibly blocking), unhandlizes any result and
1898 // returns.
1899 //
1900 // Critical native functions are a shorthand for the use of
1901 // GetPrimtiveArrayCritical and disallow the use of any other JNI
1902 // functions.  The wrapper is expected to unpack the arguments before
1903 // passing them to the callee and perform checks before and after the
1904 // native call to ensure that they GCLocker
1905 // lock_critical/unlock_critical semantics are followed.  Some other
1906 // parts of JNI setup are skipped like the tear down of the JNI handle
1907 // block and the check for pending exceptions it&#39;s impossible for them
1908 // to be thrown.
1909 //
1910 // They are roughly structured like this:
1911 //    if (GCLocker::needs_gc())
1912 //      SharedRuntime::block_for_jni_critical();
1913 //    tranistion to thread_in_native
1914 //    unpack arrray arguments and call native entry point
1915 //    check for safepoint in progress
1916 //    check if any thread suspend flags are set
1917 //      call into JVM and possible unlock the JNI critical
1918 //      if a GC was suppressed while in the critical native.
1919 //    transition back to thread_in_Java
1920 //    return to caller
1921 //
1922 nmethod* SharedRuntime::generate_native_wrapper(MacroAssembler* masm,
1923                                                 const methodHandle&amp; method,
1924                                                 int compile_id,
1925                                                 BasicType* in_sig_bt,
1926                                                 VMRegPair* in_regs,
1927                                                 BasicType ret_type,
1928                                                 address critical_entry) {
1929   if (method-&gt;is_method_handle_intrinsic()) {
1930     vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1931     intptr_t start = (intptr_t)__ pc();
1932     int vep_offset = ((intptr_t)__ pc()) - start;
1933     gen_special_dispatch(masm,
1934                          method,
1935                          in_sig_bt,
1936                          in_regs);
1937     int frame_complete = ((intptr_t)__ pc()) - start;  // not complete, period
1938     __ flush();
1939     int stack_slots = SharedRuntime::out_preserve_stack_slots();  // no out slots at all, actually
1940     return nmethod::new_native_nmethod(method,
1941                                        compile_id,
1942                                        masm-&gt;code(),
1943                                        vep_offset,
1944                                        frame_complete,
1945                                        stack_slots / VMRegImpl::slots_per_word,
1946                                        in_ByteSize(-1),
1947                                        in_ByteSize(-1),
1948                                        (OopMapSet*)NULL);
1949   }
1950   bool is_critical_native = true;
1951   address native_func = critical_entry;
1952   if (native_func == NULL) {
1953     native_func = method-&gt;native_function();
1954     is_critical_native = false;
1955   }
1956   assert(native_func != NULL, &quot;must have function&quot;);
1957 
1958   // An OopMap for lock (and class if static)
1959   OopMapSet *oop_maps = new OopMapSet();
1960   intptr_t start = (intptr_t)__ pc();
1961 
1962   // We have received a description of where all the java arg are located
1963   // on entry to the wrapper. We need to convert these args to where
1964   // the jni function will expect them. To figure out where they go
1965   // we convert the java signature to a C signature by inserting
1966   // the hidden arguments as arg[0] and possibly arg[1] (static method)
1967 
1968   const int total_in_args = method-&gt;size_of_parameters();
1969   int total_c_args = total_in_args;
1970   if (!is_critical_native) {
1971     total_c_args += 1;
1972     if (method-&gt;is_static()) {
1973       total_c_args++;
1974     }
1975   } else {
1976     for (int i = 0; i &lt; total_in_args; i++) {
1977       if (in_sig_bt[i] == T_ARRAY) {
1978         total_c_args++;
1979       }
1980     }
1981   }
1982 
1983   BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_c_args);
1984   VMRegPair* out_regs   = NEW_RESOURCE_ARRAY(VMRegPair, total_c_args);
1985   BasicType* in_elem_bt = NULL;
1986 
1987   int argc = 0;
1988   if (!is_critical_native) {
1989     out_sig_bt[argc++] = T_ADDRESS;
1990     if (method-&gt;is_static()) {
1991       out_sig_bt[argc++] = T_OBJECT;
1992     }
1993 
1994     for (int i = 0; i &lt; total_in_args ; i++ ) {
1995       out_sig_bt[argc++] = in_sig_bt[i];
1996     }
1997   } else {
1998     in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_in_args);
1999     SignatureStream ss(method-&gt;signature());
2000     for (int i = 0; i &lt; total_in_args ; i++ ) {
2001       if (in_sig_bt[i] == T_ARRAY) {
2002         // Arrays are passed as int, elem* pair
2003         out_sig_bt[argc++] = T_INT;
2004         out_sig_bt[argc++] = T_ADDRESS;
2005         ss.skip_array_prefix(1);  // skip one &#39;[&#39;
2006         assert(ss.is_primitive(), &quot;primitive type expected&quot;);
2007         in_elem_bt[i] = ss.type();
2008       } else {
2009         out_sig_bt[argc++] = in_sig_bt[i];
2010         in_elem_bt[i] = T_VOID;
2011       }
2012       if (in_sig_bt[i] != T_VOID) {
2013         assert(in_sig_bt[i] == ss.type() ||
2014                in_sig_bt[i] == T_ARRAY, &quot;must match&quot;);
2015         ss.next();
2016       }
2017     }
2018   }
2019 
2020   // Now figure out where the args must be stored and how much stack space
2021   // they require.
2022   int out_arg_slots;
2023   out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);
2024 
2025   // Compute framesize for the wrapper.  We need to handlize all oops in
2026   // incoming registers
2027 
2028   // Calculate the total number of stack slots we will need.
2029 
2030   // First count the abi requirement plus all of the outgoing args
2031   int stack_slots = SharedRuntime::out_preserve_stack_slots() + out_arg_slots;
2032 
2033   // Now the space for the inbound oop handle area
2034   int total_save_slots = 6 * VMRegImpl::slots_per_word;  // 6 arguments passed in registers
2035   if (is_critical_native) {
2036     // Critical natives may have to call out so they need a save area
2037     // for register arguments.
2038     int double_slots = 0;
2039     int single_slots = 0;
2040     for ( int i = 0; i &lt; total_in_args; i++) {
2041       if (in_regs[i].first()-&gt;is_Register()) {
2042         const Register reg = in_regs[i].first()-&gt;as_Register();
2043         switch (in_sig_bt[i]) {
2044           case T_BOOLEAN:
2045           case T_BYTE:
2046           case T_SHORT:
2047           case T_CHAR:
2048           case T_INT:  single_slots++; break;
2049           case T_ARRAY:  // specific to LP64 (7145024)
2050           case T_LONG: double_slots++; break;
2051           default:  ShouldNotReachHere();
2052         }
2053       } else if (in_regs[i].first()-&gt;is_XMMRegister()) {
2054         switch (in_sig_bt[i]) {
2055           case T_FLOAT:  single_slots++; break;
2056           case T_DOUBLE: double_slots++; break;
2057           default:  ShouldNotReachHere();
2058         }
2059       } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
2060         ShouldNotReachHere();
2061       }
2062     }
2063     total_save_slots = double_slots * 2 + single_slots;
2064     // align the save area
2065     if (double_slots != 0) {
2066       stack_slots = align_up(stack_slots, 2);
2067     }
2068   }
2069 
2070   int oop_handle_offset = stack_slots;
2071   stack_slots += total_save_slots;
2072 
2073   // Now any space we need for handlizing a klass if static method
2074 
2075   int klass_slot_offset = 0;
2076   int klass_offset = -1;
2077   int lock_slot_offset = 0;
2078   bool is_static = false;
2079 
2080   if (method-&gt;is_static()) {
2081     klass_slot_offset = stack_slots;
2082     stack_slots += VMRegImpl::slots_per_word;
2083     klass_offset = klass_slot_offset * VMRegImpl::stack_slot_size;
2084     is_static = true;
2085   }
2086 
2087   // Plus a lock if needed
2088 
2089   if (method-&gt;is_synchronized()) {
2090     lock_slot_offset = stack_slots;
2091     stack_slots += VMRegImpl::slots_per_word;
2092   }
2093 
2094   // Now a place (+2) to save return values or temp during shuffling
2095   // + 4 for return address (which we own) and saved rbp
2096   stack_slots += 6;
2097 
2098   // Ok The space we have allocated will look like:
2099   //
2100   //
2101   // FP-&gt; |                     |
2102   //      |---------------------|
2103   //      | 2 slots for moves   |
2104   //      |---------------------|
2105   //      | lock box (if sync)  |
2106   //      |---------------------| &lt;- lock_slot_offset
2107   //      | klass (if static)   |
2108   //      |---------------------| &lt;- klass_slot_offset
2109   //      | oopHandle area      |
2110   //      |---------------------| &lt;- oop_handle_offset (6 java arg registers)
2111   //      | outbound memory     |
2112   //      | based arguments     |
2113   //      |                     |
2114   //      |---------------------|
2115   //      |                     |
2116   // SP-&gt; | out_preserved_slots |
2117   //
2118   //
2119 
2120 
2121   // Now compute actual number of stack words we need rounding to make
2122   // stack properly aligned.
2123   stack_slots = align_up(stack_slots, StackAlignmentInSlots);
2124 
2125   int stack_size = stack_slots * VMRegImpl::stack_slot_size;
2126 
2127   // First thing make an ic check to see if we should even be here
2128 
2129   // We are free to use all registers as temps without saving them and
2130   // restoring them except rbp. rbp is the only callee save register
2131   // as far as the interpreter and the compiler(s) are concerned.
2132 
2133 
2134   const Register ic_reg = rax;
2135   const Register receiver = j_rarg0;
2136 
2137   Label hit;
2138   Label exception_pending;
2139 
2140   assert_different_registers(ic_reg, receiver, rscratch1);
2141   __ verify_oop(receiver);
2142   __ load_klass(rscratch1, receiver, rscratch2);
2143   __ cmpq(ic_reg, rscratch1);
2144   __ jcc(Assembler::equal, hit);
2145 
2146   __ jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
2147 
2148   // Verified entry point must be aligned
2149   __ align(8);
2150 
2151   __ bind(hit);
2152 
2153   int vep_offset = ((intptr_t)__ pc()) - start;
2154 
2155   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; method-&gt;needs_clinit_barrier()) {
2156     Label L_skip_barrier;
2157     Register klass = r10;
2158     __ mov_metadata(klass, method-&gt;method_holder()); // InstanceKlass*
2159     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
2160 
2161     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
2162 
2163     __ bind(L_skip_barrier);
2164   }
2165 
2166 #ifdef COMPILER1
2167   // For Object.hashCode, System.identityHashCode try to pull hashCode from object header if available.
2168   if ((InlineObjectHash &amp;&amp; method-&gt;intrinsic_id() == vmIntrinsics::_hashCode) || (method-&gt;intrinsic_id() == vmIntrinsics::_identityHashCode)) {
2169     inline_check_hashcode_from_object_header(masm, method, j_rarg0 /*obj_reg*/, rax /*result*/);
2170   }
2171 #endif // COMPILER1
2172 
2173   // The instruction at the verified entry point must be 5 bytes or longer
2174   // because it can be patched on the fly by make_non_entrant. The stack bang
2175   // instruction fits that requirement.
2176 
2177   // Generate stack overflow check
2178 
2179   if (UseStackBanging) {
2180     __ bang_stack_with_offset((int)JavaThread::stack_shadow_zone_size());
2181   } else {
2182     // need a 5 byte instruction to allow MT safe patching to non-entrant
2183     __ fat_nop();
2184   }
2185 
2186   // Generate a new frame for the wrapper.
2187   __ enter();
2188   // -2 because return address is already present and so is saved rbp
2189   __ subptr(rsp, stack_size - 2*wordSize);
2190 
2191   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
2192   bs-&gt;nmethod_entry_barrier(masm);
2193 
2194   // Frame is now completed as far as size and linkage.
2195   int frame_complete = ((intptr_t)__ pc()) - start;
2196 
2197     if (UseRTMLocking) {
2198       // Abort RTM transaction before calling JNI
2199       // because critical section will be large and will be
2200       // aborted anyway. Also nmethod could be deoptimized.
2201       __ xabort(0);
2202     }
2203 
2204 #ifdef ASSERT
2205     {
2206       Label L;
2207       __ mov(rax, rsp);
2208       __ andptr(rax, -16); // must be 16 byte boundary (see amd64 ABI)
2209       __ cmpptr(rax, rsp);
2210       __ jcc(Assembler::equal, L);
2211       __ stop(&quot;improperly aligned stack&quot;);
2212       __ bind(L);
2213     }
2214 #endif /* ASSERT */
2215 
2216 
2217   // We use r14 as the oop handle for the receiver/klass
2218   // It is callee save so it survives the call to native
2219 
2220   const Register oop_handle_reg = r14;
2221 
2222   if (is_critical_native &amp;&amp; !Universe::heap()-&gt;supports_object_pinning()) {
2223     check_needs_gc_for_critical_native(masm, stack_slots, total_c_args, total_in_args,
2224                                        oop_handle_offset, oop_maps, in_regs, in_sig_bt);
2225   }
2226 
2227   //
2228   // We immediately shuffle the arguments so that any vm call we have to
2229   // make from here on out (sync slow path, jvmti, etc.) we will have
2230   // captured the oops from our caller and have a valid oopMap for
2231   // them.
2232 
2233   // -----------------
2234   // The Grand Shuffle
2235 
2236   // The Java calling convention is either equal (linux) or denser (win64) than the
2237   // c calling convention. However the because of the jni_env argument the c calling
2238   // convention always has at least one more (and two for static) arguments than Java.
2239   // Therefore if we move the args from java -&gt; c backwards then we will never have
2240   // a register-&gt;register conflict and we don&#39;t have to build a dependency graph
2241   // and figure out how to break any cycles.
2242   //
2243 
2244   // Record esp-based slot for receiver on stack for non-static methods
2245   int receiver_offset = -1;
2246 
2247   // This is a trick. We double the stack slots so we can claim
2248   // the oops in the caller&#39;s frame. Since we are sure to have
2249   // more args than the caller doubling is enough to make
2250   // sure we can capture all the incoming oop args from the
2251   // caller.
2252   //
2253   OopMap* map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
2254 
2255   // Mark location of rbp (someday)
2256   // map-&gt;set_callee_saved(VMRegImpl::stack2reg( stack_slots - 2), stack_slots * 2, 0, vmreg(rbp));
2257 
2258   // Use eax, ebx as temporaries during any memory-memory moves we have to do
2259   // All inbound args are referenced based on rbp and all outbound args via rsp.
2260 
2261 
2262 #ifdef ASSERT
2263   bool reg_destroyed[RegisterImpl::number_of_registers];
2264   bool freg_destroyed[XMMRegisterImpl::number_of_registers];
2265   for ( int r = 0 ; r &lt; RegisterImpl::number_of_registers ; r++ ) {
2266     reg_destroyed[r] = false;
2267   }
2268   for ( int f = 0 ; f &lt; XMMRegisterImpl::number_of_registers ; f++ ) {
2269     freg_destroyed[f] = false;
2270   }
2271 
2272 #endif /* ASSERT */
2273 
2274   // This may iterate in two different directions depending on the
2275   // kind of native it is.  The reason is that for regular JNI natives
2276   // the incoming and outgoing registers are offset upwards and for
2277   // critical natives they are offset down.
2278   GrowableArray&lt;int&gt; arg_order(2 * total_in_args);
2279   // Inbound arguments that need to be pinned for critical natives
2280   GrowableArray&lt;int&gt; pinned_args(total_in_args);
2281   // Current stack slot for storing register based array argument
2282   int pinned_slot = oop_handle_offset;
2283 
2284   VMRegPair tmp_vmreg;
2285   tmp_vmreg.set2(rbx-&gt;as_VMReg());
2286 
2287   if (!is_critical_native) {
2288     for (int i = total_in_args - 1, c_arg = total_c_args - 1; i &gt;= 0; i--, c_arg--) {
2289       arg_order.push(i);
2290       arg_order.push(c_arg);
2291     }
2292   } else {
2293     // Compute a valid move order, using tmp_vmreg to break any cycles
2294     ComputeMoveOrder cmo(total_in_args, in_regs, total_c_args, out_regs, in_sig_bt, arg_order, tmp_vmreg);
2295   }
2296 
2297   int temploc = -1;
2298   for (int ai = 0; ai &lt; arg_order.length(); ai += 2) {
2299     int i = arg_order.at(ai);
2300     int c_arg = arg_order.at(ai + 1);
2301     __ block_comment(err_msg(&quot;move %d -&gt; %d&quot;, i, c_arg));
2302     if (c_arg == -1) {
2303       assert(is_critical_native, &quot;should only be required for critical natives&quot;);
2304       // This arg needs to be moved to a temporary
2305       __ mov(tmp_vmreg.first()-&gt;as_Register(), in_regs[i].first()-&gt;as_Register());
2306       in_regs[i] = tmp_vmreg;
2307       temploc = i;
2308       continue;
2309     } else if (i == -1) {
2310       assert(is_critical_native, &quot;should only be required for critical natives&quot;);
2311       // Read from the temporary location
2312       assert(temploc != -1, &quot;must be valid&quot;);
2313       i = temploc;
2314       temploc = -1;
2315     }
2316 #ifdef ASSERT
2317     if (in_regs[i].first()-&gt;is_Register()) {
2318       assert(!reg_destroyed[in_regs[i].first()-&gt;as_Register()-&gt;encoding()], &quot;destroyed reg!&quot;);
2319     } else if (in_regs[i].first()-&gt;is_XMMRegister()) {
2320       assert(!freg_destroyed[in_regs[i].first()-&gt;as_XMMRegister()-&gt;encoding()], &quot;destroyed reg!&quot;);
2321     }
2322     if (out_regs[c_arg].first()-&gt;is_Register()) {
2323       reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
2324     } else if (out_regs[c_arg].first()-&gt;is_XMMRegister()) {
2325       freg_destroyed[out_regs[c_arg].first()-&gt;as_XMMRegister()-&gt;encoding()] = true;
2326     }
2327 #endif /* ASSERT */
2328     switch (in_sig_bt[i]) {
2329       case T_ARRAY:
2330         if (is_critical_native) {
2331           // pin before unpack
2332           if (Universe::heap()-&gt;supports_object_pinning()) {
2333             save_args(masm, total_c_args, 0, out_regs);
2334             gen_pin_object(masm, in_regs[i]);
2335             pinned_args.append(i);
2336             restore_args(masm, total_c_args, 0, out_regs);
2337 
2338             // rax has pinned array
2339             VMRegPair result_reg;
2340             result_reg.set_ptr(rax-&gt;as_VMReg());
2341             move_ptr(masm, result_reg, in_regs[i]);
2342             if (!in_regs[i].first()-&gt;is_stack()) {
2343               assert(pinned_slot &lt;= stack_slots, &quot;overflow&quot;);
2344               move_ptr(masm, result_reg, VMRegImpl::stack2reg(pinned_slot));
2345               pinned_slot += VMRegImpl::slots_per_word;
2346             }
2347           }
2348           unpack_array_argument(masm, in_regs[i], in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);
2349           c_arg++;
2350 #ifdef ASSERT
2351           if (out_regs[c_arg].first()-&gt;is_Register()) {
2352             reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
2353           } else if (out_regs[c_arg].first()-&gt;is_XMMRegister()) {
2354             freg_destroyed[out_regs[c_arg].first()-&gt;as_XMMRegister()-&gt;encoding()] = true;
2355           }
2356 #endif
2357           break;
2358         }
2359       case T_OBJECT:
2360         assert(!is_critical_native, &quot;no oop arguments&quot;);
2361         object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
2362                     ((i == 0) &amp;&amp; (!is_static)),
2363                     &amp;receiver_offset);
2364         break;
2365       case T_VOID:
2366         break;
2367 
2368       case T_FLOAT:
2369         float_move(masm, in_regs[i], out_regs[c_arg]);
2370           break;
2371 
2372       case T_DOUBLE:
2373         assert( i + 1 &lt; total_in_args &amp;&amp;
2374                 in_sig_bt[i + 1] == T_VOID &amp;&amp;
2375                 out_sig_bt[c_arg+1] == T_VOID, &quot;bad arg list&quot;);
2376         double_move(masm, in_regs[i], out_regs[c_arg]);
2377         break;
2378 
2379       case T_LONG :
2380         long_move(masm, in_regs[i], out_regs[c_arg]);
2381         break;
2382 
2383       case T_ADDRESS: assert(false, &quot;found T_ADDRESS in java args&quot;);
2384 
2385       default:
2386         move32_64(masm, in_regs[i], out_regs[c_arg]);
2387     }
2388   }
2389 
2390   int c_arg;
2391 
2392   // Pre-load a static method&#39;s oop into r14.  Used both by locking code and
2393   // the normal JNI call code.
2394   if (!is_critical_native) {
2395     // point c_arg at the first arg that is already loaded in case we
2396     // need to spill before we call out
2397     c_arg = total_c_args - total_in_args;
2398 
2399     if (method-&gt;is_static()) {
2400 
2401       //  load oop into a register
2402       __ movoop(oop_handle_reg, JNIHandles::make_local(method-&gt;method_holder()-&gt;java_mirror()));
2403 
2404       // Now handlize the static class mirror it&#39;s known not-null.
2405       __ movptr(Address(rsp, klass_offset), oop_handle_reg);
2406       map-&gt;set_oop(VMRegImpl::stack2reg(klass_slot_offset));
2407 
2408       // Now get the handle
2409       __ lea(oop_handle_reg, Address(rsp, klass_offset));
2410       // store the klass handle as second argument
2411       __ movptr(c_rarg1, oop_handle_reg);
2412       // and protect the arg if we must spill
2413       c_arg--;
2414     }
2415   } else {
2416     // For JNI critical methods we need to save all registers in save_args.
2417     c_arg = 0;
2418   }
2419 
2420   // Change state to native (we save the return address in the thread, since it might not
2421   // be pushed on the stack when we do a a stack traversal). It is enough that the pc()
2422   // points into the right code segment. It does not have to be the correct return pc.
2423   // We use the same pc/oopMap repeatedly when we call out
2424 
2425   intptr_t the_pc = (intptr_t) __ pc();
2426   oop_maps-&gt;add_gc_map(the_pc - start, map);
2427 
2428   __ set_last_Java_frame(rsp, noreg, (address)the_pc);
2429 
2430 
2431   // We have all of the arguments setup at this point. We must not touch any register
2432   // argument registers at this point (what if we save/restore them there are no oop?
2433 
2434   {
2435     SkipIfEqual skip(masm, &amp;DTraceMethodProbes, false);
2436     // protect the args we&#39;ve loaded
2437     save_args(masm, total_c_args, c_arg, out_regs);
2438     __ mov_metadata(c_rarg1, method());
2439     __ call_VM_leaf(
2440       CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry),
2441       r15_thread, c_rarg1);
2442     restore_args(masm, total_c_args, c_arg, out_regs);
2443   }
2444 
2445   // RedefineClasses() tracing support for obsolete method entry
2446   if (log_is_enabled(Trace, redefine, class, obsolete)) {
2447     // protect the args we&#39;ve loaded
2448     save_args(masm, total_c_args, c_arg, out_regs);
2449     __ mov_metadata(c_rarg1, method());
2450     __ call_VM_leaf(
2451       CAST_FROM_FN_PTR(address, SharedRuntime::rc_trace_method_entry),
2452       r15_thread, c_rarg1);
2453     restore_args(masm, total_c_args, c_arg, out_regs);
2454   }
2455 
2456   // Lock a synchronized method
2457 
2458   // Register definitions used by locking and unlocking
2459 
2460   const Register swap_reg = rax;  // Must use rax for cmpxchg instruction
2461   const Register obj_reg  = rbx;  // Will contain the oop
2462   const Register lock_reg = r13;  // Address of compiler lock object (BasicLock)
2463   const Register old_hdr  = r13;  // value of old header at unlock time
2464 
2465   Label slow_path_lock;
2466   Label lock_done;
2467 
2468   if (method-&gt;is_synchronized()) {
2469     assert(!is_critical_native, &quot;unhandled&quot;);
2470 
2471 
2472     const int mark_word_offset = BasicLock::displaced_header_offset_in_bytes();
2473 
2474     // Get the handle (the 2nd argument)
2475     __ mov(oop_handle_reg, c_rarg1);
2476 
2477     // Get address of the box
2478 
2479     __ lea(lock_reg, Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size));
2480 
2481     // Load the oop from the handle
2482     __ movptr(obj_reg, Address(oop_handle_reg, 0));
2483 
2484     __ resolve(IS_NOT_NULL, obj_reg);
2485     if (UseBiasedLocking) {
2486       __ biased_locking_enter(lock_reg, obj_reg, swap_reg, rscratch1, rscratch2, false, lock_done, &amp;slow_path_lock);
2487     }
2488 
2489     // Load immediate 1 into swap_reg %rax
2490     __ movl(swap_reg, 1);
2491 
2492     // Load (object-&gt;mark() | 1) into swap_reg %rax
2493     __ orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
2494 
2495     // Save (object-&gt;mark() | 1) into BasicLock&#39;s displaced header
2496     __ movptr(Address(lock_reg, mark_word_offset), swap_reg);
2497 
2498     // src -&gt; dest iff dest == rax else rax &lt;- dest
2499     __ lock();
2500     __ cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
2501     __ jcc(Assembler::equal, lock_done);
2502 
2503     // Hmm should this move to the slow path code area???
2504 
2505     // Test if the oopMark is an obvious stack pointer, i.e.,
2506     //  1) (mark &amp; 3) == 0, and
2507     //  2) rsp &lt;= mark &lt; mark + os::pagesize()
2508     // These 3 tests can be done by evaluating the following
2509     // expression: ((mark - rsp) &amp; (3 - os::vm_page_size())),
2510     // assuming both stack pointer and pagesize have their
2511     // least significant 2 bits clear.
2512     // NOTE: the oopMark is in swap_reg %rax as the result of cmpxchg
2513 
2514     __ subptr(swap_reg, rsp);
2515     __ andptr(swap_reg, 3 - os::vm_page_size());
2516 
2517     // Save the test result, for recursive case, the result is zero
2518     __ movptr(Address(lock_reg, mark_word_offset), swap_reg);
2519     __ jcc(Assembler::notEqual, slow_path_lock);
2520 
2521     // Slow path will re-enter here
2522 
2523     __ bind(lock_done);
2524   }
2525 
2526 
2527   // Finally just about ready to make the JNI call
2528 
2529 
2530   // get JNIEnv* which is first argument to native
2531   if (!is_critical_native) {
2532     __ lea(c_rarg0, Address(r15_thread, in_bytes(JavaThread::jni_environment_offset())));
2533   }
2534 
2535   // Now set thread in native
2536   __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);
2537 
2538   __ call(RuntimeAddress(native_func));
2539 
2540   // Verify or restore cpu control state after JNI call
2541   __ restore_cpu_control_state_after_jni();
2542 
2543   // Unpack native results.
2544   switch (ret_type) {
2545   case T_BOOLEAN: __ c2bool(rax);            break;
2546   case T_CHAR   : __ movzwl(rax, rax);      break;
2547   case T_BYTE   : __ sign_extend_byte (rax); break;
2548   case T_SHORT  : __ sign_extend_short(rax); break;
2549   case T_INT    : /* nothing to do */        break;
2550   case T_DOUBLE :
2551   case T_FLOAT  :
2552     // Result is in xmm0 we&#39;ll save as needed
2553     break;
2554   case T_ARRAY:                 // Really a handle
2555   case T_OBJECT:                // Really a handle
2556       break; // can&#39;t de-handlize until after safepoint check
2557   case T_VOID: break;
2558   case T_LONG: break;
2559   default       : ShouldNotReachHere();
2560   }
2561 
2562   // unpin pinned arguments
2563   pinned_slot = oop_handle_offset;
2564   if (pinned_args.length() &gt; 0) {
2565     // save return value that may be overwritten otherwise.
2566     save_native_result(masm, ret_type, stack_slots);
2567     for (int index = 0; index &lt; pinned_args.length(); index ++) {
2568       int i = pinned_args.at(index);
2569       assert(pinned_slot &lt;= stack_slots, &quot;overflow&quot;);
2570       if (!in_regs[i].first()-&gt;is_stack()) {
2571         int offset = pinned_slot * VMRegImpl::stack_slot_size;
2572         __ movq(in_regs[i].first()-&gt;as_Register(), Address(rsp, offset));
2573         pinned_slot += VMRegImpl::slots_per_word;
2574       }
2575       gen_unpin_object(masm, in_regs[i]);
2576     }
2577     restore_native_result(masm, ret_type, stack_slots);
2578   }
2579 
2580   // Switch thread to &quot;native transition&quot; state before reading the synchronization state.
2581   // This additional state is necessary because reading and testing the synchronization
2582   // state is not atomic w.r.t. GC, as this scenario demonstrates:
2583   //     Java thread A, in _thread_in_native state, loads _not_synchronized and is preempted.
2584   //     VM thread changes sync state to synchronizing and suspends threads for GC.
2585   //     Thread A is resumed to finish this native method, but doesn&#39;t block here since it
2586   //     didn&#39;t see any synchronization is progress, and escapes.
2587   __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);
2588 
2589   // Force this write out before the read below
2590   __ membar(Assembler::Membar_mask_bits(
2591               Assembler::LoadLoad | Assembler::LoadStore |
2592               Assembler::StoreLoad | Assembler::StoreStore));
2593 
2594   Label after_transition;
2595 
2596   // check for safepoint operation in progress and/or pending suspend requests
2597   {
2598     Label Continue;
2599     Label slow_path;
2600 
2601     __ safepoint_poll(slow_path, r15_thread, rscratch1);
2602 
2603     __ cmpl(Address(r15_thread, JavaThread::suspend_flags_offset()), 0);
2604     __ jcc(Assembler::equal, Continue);
2605     __ bind(slow_path);
2606 
2607     // Don&#39;t use call_VM as it will see a possible pending exception and forward it
2608     // and never return here preventing us from clearing _last_native_pc down below.
2609     // Also can&#39;t use call_VM_leaf either as it will check to see if rsi &amp; rdi are
2610     // preserved and correspond to the bcp/locals pointers. So we do a runtime call
2611     // by hand.
2612     //
2613     __ vzeroupper();
2614     save_native_result(masm, ret_type, stack_slots);
2615     __ mov(c_rarg0, r15_thread);
2616     __ mov(r12, rsp); // remember sp
2617     __ subptr(rsp, frame::arg_reg_save_area_bytes); // windows
2618     __ andptr(rsp, -16); // align stack as required by ABI
2619     if (!is_critical_native) {
2620       __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));
2621     } else {
2622       __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans_and_transition)));
2623     }
2624     __ mov(rsp, r12); // restore sp
2625     __ reinit_heapbase();
2626     // Restore any method result value
2627     restore_native_result(masm, ret_type, stack_slots);
2628 
2629     if (is_critical_native) {
2630       // The call above performed the transition to thread_in_Java so
2631       // skip the transition logic below.
2632       __ jmpb(after_transition);
2633     }
2634 
2635     __ bind(Continue);
2636   }
2637 
2638   // change thread state
2639   __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_Java);
2640   __ bind(after_transition);
2641 
2642   Label reguard;
2643   Label reguard_done;
2644   __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), JavaThread::stack_guard_yellow_reserved_disabled);
2645   __ jcc(Assembler::equal, reguard);
2646   __ bind(reguard_done);
2647 
2648   // native result if any is live
2649 
2650   // Unlock
2651   Label unlock_done;
2652   Label slow_path_unlock;
2653   if (method-&gt;is_synchronized()) {
2654 
2655     // Get locked oop from the handle we passed to jni
2656     __ movptr(obj_reg, Address(oop_handle_reg, 0));
2657     __ resolve(IS_NOT_NULL, obj_reg);
2658 
2659     Label done;
2660 
2661     if (UseBiasedLocking) {
2662       __ biased_locking_exit(obj_reg, old_hdr, done);
2663     }
2664 
2665     // Simple recursive lock?
2666 
2667     __ cmpptr(Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size), (int32_t)NULL_WORD);
2668     __ jcc(Assembler::equal, done);
2669 
2670     // Must save rax if if it is live now because cmpxchg must use it
2671     if (ret_type != T_FLOAT &amp;&amp; ret_type != T_DOUBLE &amp;&amp; ret_type != T_VOID) {
2672       save_native_result(masm, ret_type, stack_slots);
2673     }
2674 
2675 
2676     // get address of the stack lock
2677     __ lea(rax, Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size));
2678     //  get old displaced header
2679     __ movptr(old_hdr, Address(rax, 0));
2680 
2681     // Atomic swap old header if oop still contains the stack lock
2682     __ lock();
2683     __ cmpxchgptr(old_hdr, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
2684     __ jcc(Assembler::notEqual, slow_path_unlock);
2685 
2686     // slow path re-enters here
2687     __ bind(unlock_done);
2688     if (ret_type != T_FLOAT &amp;&amp; ret_type != T_DOUBLE &amp;&amp; ret_type != T_VOID) {
2689       restore_native_result(masm, ret_type, stack_slots);
2690     }
2691 
2692     __ bind(done);
2693 
2694   }
2695   {
2696     SkipIfEqual skip(masm, &amp;DTraceMethodProbes, false);
2697     save_native_result(masm, ret_type, stack_slots);
2698     __ mov_metadata(c_rarg1, method());
2699     __ call_VM_leaf(
2700          CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit),
2701          r15_thread, c_rarg1);
2702     restore_native_result(masm, ret_type, stack_slots);
2703   }
2704 
2705   __ reset_last_Java_frame(false);
2706 
2707   // Unbox oop result, e.g. JNIHandles::resolve value.
2708   if (is_reference_type(ret_type)) {
2709     __ resolve_jobject(rax /* value */,
2710                        r15_thread /* thread */,
2711                        rcx /* tmp */);
2712   }
2713 
2714   if (CheckJNICalls) {
2715     // clear_pending_jni_exception_check
2716     __ movptr(Address(r15_thread, JavaThread::pending_jni_exception_check_fn_offset()), NULL_WORD);
2717   }
2718 
2719   if (!is_critical_native) {
2720     // reset handle block
2721     __ movptr(rcx, Address(r15_thread, JavaThread::active_handles_offset()));
2722     __ movl(Address(rcx, JNIHandleBlock::top_offset_in_bytes()), (int32_t)NULL_WORD);
2723   }
2724 
2725   // pop our frame
2726 
2727   __ leave();
2728 
2729   if (!is_critical_native) {
2730     // Any exception pending?
2731     __ cmpptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);
2732     __ jcc(Assembler::notEqual, exception_pending);
2733   }
2734 
2735   // Return
2736 
2737   __ ret(0);
2738 
2739   // Unexpected paths are out of line and go here
2740 
2741   if (!is_critical_native) {
2742     // forward the exception
2743     __ bind(exception_pending);
2744 
2745     // and forward the exception
2746     __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
2747   }
2748 
2749   // Slow path locking &amp; unlocking
2750   if (method-&gt;is_synchronized()) {
2751 
2752     // BEGIN Slow path lock
2753     __ bind(slow_path_lock);
2754 
2755     // has last_Java_frame setup. No exceptions so do vanilla call not call_VM
2756     // args are (oop obj, BasicLock* lock, JavaThread* thread)
2757 
2758     // protect the args we&#39;ve loaded
2759     save_args(masm, total_c_args, c_arg, out_regs);
2760 
2761     __ mov(c_rarg0, obj_reg);
2762     __ mov(c_rarg1, lock_reg);
2763     __ mov(c_rarg2, r15_thread);
2764 
2765     // Not a leaf but we have last_Java_frame setup as we want
2766     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_locking_C), 3);
2767     restore_args(masm, total_c_args, c_arg, out_regs);
2768 
2769 #ifdef ASSERT
2770     { Label L;
2771     __ cmpptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);
2772     __ jcc(Assembler::equal, L);
2773     __ stop(&quot;no pending exception allowed on exit from monitorenter&quot;);
2774     __ bind(L);
2775     }
2776 #endif
2777     __ jmp(lock_done);
2778 
2779     // END Slow path lock
2780 
2781     // BEGIN Slow path unlock
2782     __ bind(slow_path_unlock);
2783 
2784     // If we haven&#39;t already saved the native result we must save it now as xmm registers
2785     // are still exposed.
2786     __ vzeroupper();
2787     if (ret_type == T_FLOAT || ret_type == T_DOUBLE ) {
2788       save_native_result(masm, ret_type, stack_slots);
2789     }
2790 
2791     __ lea(c_rarg1, Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size));
2792 
2793     __ mov(c_rarg0, obj_reg);
2794     __ mov(c_rarg2, r15_thread);
2795     __ mov(r12, rsp); // remember sp
2796     __ subptr(rsp, frame::arg_reg_save_area_bytes); // windows
2797     __ andptr(rsp, -16); // align stack as required by ABI
2798 
2799     // Save pending exception around call to VM (which contains an EXCEPTION_MARK)
2800     // NOTE that obj_reg == rbx currently
2801     __ movptr(rbx, Address(r15_thread, in_bytes(Thread::pending_exception_offset())));
2802     __ movptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);
2803 
2804     // args are (oop obj, BasicLock* lock, JavaThread* thread)
2805     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C)));
2806     __ mov(rsp, r12); // restore sp
2807     __ reinit_heapbase();
2808 #ifdef ASSERT
2809     {
2810       Label L;
2811       __ cmpptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), (int)NULL_WORD);
2812       __ jcc(Assembler::equal, L);
2813       __ stop(&quot;no pending exception allowed on exit complete_monitor_unlocking_C&quot;);
2814       __ bind(L);
2815     }
2816 #endif /* ASSERT */
2817 
2818     __ movptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), rbx);
2819 
2820     if (ret_type == T_FLOAT || ret_type == T_DOUBLE ) {
2821       restore_native_result(masm, ret_type, stack_slots);
2822     }
2823     __ jmp(unlock_done);
2824 
2825     // END Slow path unlock
2826 
2827   } // synchronized
2828 
2829   // SLOW PATH Reguard the stack if needed
2830 
2831   __ bind(reguard);
2832   __ vzeroupper();
2833   save_native_result(masm, ret_type, stack_slots);
2834   __ mov(r12, rsp); // remember sp
2835   __ subptr(rsp, frame::arg_reg_save_area_bytes); // windows
2836   __ andptr(rsp, -16); // align stack as required by ABI
2837   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));
2838   __ mov(rsp, r12); // restore sp
2839   __ reinit_heapbase();
2840   restore_native_result(masm, ret_type, stack_slots);
2841   // and continue
2842   __ jmp(reguard_done);
2843 
2844 
2845 
2846   __ flush();
2847 
2848   nmethod *nm = nmethod::new_native_nmethod(method,
2849                                             compile_id,
2850                                             masm-&gt;code(),
2851                                             vep_offset,
2852                                             frame_complete,
2853                                             stack_slots / VMRegImpl::slots_per_word,
2854                                             (is_static ? in_ByteSize(klass_offset) : in_ByteSize(receiver_offset)),
2855                                             in_ByteSize(lock_slot_offset*VMRegImpl::stack_slot_size),
2856                                             oop_maps);
2857 
2858   if (is_critical_native) {
2859     nm-&gt;set_lazy_critical_native(true);
2860   }
2861 
2862   return nm;
2863 
2864 }
2865 
2866 // this function returns the adjust size (in number of words) to a c2i adapter
2867 // activation for use during deoptimization
2868 int Deoptimization::last_frame_adjust(int callee_parameters, int callee_locals ) {
2869   return (callee_locals - callee_parameters) * Interpreter::stackElementWords;
2870 }
2871 
2872 
2873 uint SharedRuntime::out_preserve_stack_slots() {
2874   return 0;
2875 }
2876 
2877 //------------------------------generate_deopt_blob----------------------------
2878 void SharedRuntime::generate_deopt_blob() {
2879   // Allocate space for the code
2880   ResourceMark rm;
2881   // Setup code generation tools
2882   int pad = 0;
2883 #if INCLUDE_JVMCI
2884   if (EnableJVMCI || UseAOT) {
2885     pad += 512; // Increase the buffer size when compiling for JVMCI
2886   }
2887 #endif
2888   CodeBuffer buffer(&quot;deopt_blob&quot;, 2048+pad, 1024);
2889   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2890   int frame_size_in_words;
2891   OopMap* map = NULL;
2892   OopMapSet *oop_maps = new OopMapSet();
2893 
2894   // -------------
2895   // This code enters when returning to a de-optimized nmethod.  A return
2896   // address has been pushed on the the stack, and return values are in
2897   // registers.
2898   // If we are doing a normal deopt then we were called from the patched
2899   // nmethod from the point we returned to the nmethod. So the return
2900   // address on the stack is wrong by NativeCall::instruction_size
2901   // We will adjust the value so it looks like we have the original return
2902   // address on the stack (like when we eagerly deoptimized).
2903   // In the case of an exception pending when deoptimizing, we enter
2904   // with a return address on the stack that points after the call we patched
2905   // into the exception handler. We have the following register state from,
2906   // e.g., the forward exception stub (see stubGenerator_x86_64.cpp).
2907   //    rax: exception oop
2908   //    rbx: exception handler
2909   //    rdx: throwing pc
2910   // So in this case we simply jam rdx into the useless return address and
2911   // the stack looks just like we want.
2912   //
2913   // At this point we need to de-opt.  We save the argument return
2914   // registers.  We call the first C routine, fetch_unroll_info().  This
2915   // routine captures the return values and returns a structure which
2916   // describes the current frame size and the sizes of all replacement frames.
2917   // The current frame is compiled code and may contain many inlined
2918   // functions, each with their own JVM state.  We pop the current frame, then
2919   // push all the new frames.  Then we call the C routine unpack_frames() to
2920   // populate these frames.  Finally unpack_frames() returns us the new target
2921   // address.  Notice that callee-save registers are BLOWN here; they have
2922   // already been captured in the vframeArray at the time the return PC was
2923   // patched.
2924   address start = __ pc();
2925   Label cont;
2926 
2927   // Prolog for non exception case!
2928 
2929   // Save everything in sight.
2930   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2931 
2932   // Normal deoptimization.  Save exec mode for unpack_frames.
2933   __ movl(r14, Deoptimization::Unpack_deopt); // callee-saved
2934   __ jmp(cont);
2935 
2936   int reexecute_offset = __ pc() - start;
2937 #if INCLUDE_JVMCI &amp;&amp; !defined(COMPILER1)
2938   if (EnableJVMCI &amp;&amp; UseJVMCICompiler) {
2939     // JVMCI does not use this kind of deoptimization
2940     __ should_not_reach_here();
2941   }
2942 #endif
2943 
2944   // Reexecute case
2945   // return address is the pc describes what bci to do re-execute at
2946 
2947   // No need to update map as each call to save_live_registers will produce identical oopmap
2948   (void) RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2949 
2950   __ movl(r14, Deoptimization::Unpack_reexecute); // callee-saved
2951   __ jmp(cont);
2952 
2953 #if INCLUDE_JVMCI
2954   Label after_fetch_unroll_info_call;
2955   int implicit_exception_uncommon_trap_offset = 0;
2956   int uncommon_trap_offset = 0;
2957 
2958   if (EnableJVMCI || UseAOT) {
2959     implicit_exception_uncommon_trap_offset = __ pc() - start;
2960 
2961     __ pushptr(Address(r15_thread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));
2962     __ movptr(Address(r15_thread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())), (int32_t)NULL_WORD);
2963 
2964     uncommon_trap_offset = __ pc() - start;
2965 
2966     // Save everything in sight.
2967     RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2968     // fetch_unroll_info needs to call last_java_frame()
2969     __ set_last_Java_frame(noreg, noreg, NULL);
2970 
2971     __ movl(c_rarg1, Address(r15_thread, in_bytes(JavaThread::pending_deoptimization_offset())));
2972     __ movl(Address(r15_thread, in_bytes(JavaThread::pending_deoptimization_offset())), -1);
2973 
2974     __ movl(r14, (int32_t)Deoptimization::Unpack_reexecute);
2975     __ mov(c_rarg0, r15_thread);
2976     __ movl(c_rarg2, r14); // exec mode
2977     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap)));
2978     oop_maps-&gt;add_gc_map( __ pc()-start, map-&gt;deep_copy());
2979 
2980     __ reset_last_Java_frame(false);
2981 
2982     __ jmp(after_fetch_unroll_info_call);
2983   } // EnableJVMCI
2984 #endif // INCLUDE_JVMCI
2985 
2986   int exception_offset = __ pc() - start;
2987 
2988   // Prolog for exception case
2989 
2990   // all registers are dead at this entry point, except for rax, and
2991   // rdx which contain the exception oop and exception pc
2992   // respectively.  Set them in TLS and fall thru to the
2993   // unpack_with_exception_in_tls entry point.
2994 
2995   __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), rdx);
2996   __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()), rax);
2997 
2998   int exception_in_tls_offset = __ pc() - start;
2999 
3000   // new implementation because exception oop is now passed in JavaThread
3001 
3002   // Prolog for exception case
3003   // All registers must be preserved because they might be used by LinearScan
3004   // Exceptiop oop and throwing PC are passed in JavaThread
3005   // tos: stack at point of call to method that threw the exception (i.e. only
3006   // args are on the stack, no return address)
3007 
3008   // make room on stack for the return address
3009   // It will be patched later with the throwing pc. The correct value is not
3010   // available now because loading it from memory would destroy registers.
3011   __ push(0);
3012 
3013   // Save everything in sight.
3014   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
3015 
3016   // Now it is safe to overwrite any register
3017 
3018   // Deopt during an exception.  Save exec mode for unpack_frames.
3019   __ movl(r14, Deoptimization::Unpack_exception); // callee-saved
3020 
3021   // load throwing pc from JavaThread and patch it as the return address
3022   // of the current frame. Then clear the field in JavaThread
3023 
3024   __ movptr(rdx, Address(r15_thread, JavaThread::exception_pc_offset()));
3025   __ movptr(Address(rbp, wordSize), rdx);
3026   __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), (int32_t)NULL_WORD);
3027 
3028 #ifdef ASSERT
3029   // verify that there is really an exception oop in JavaThread
3030   __ movptr(rax, Address(r15_thread, JavaThread::exception_oop_offset()));
3031   __ verify_oop(rax);
3032 
3033   // verify that there is no pending exception
3034   Label no_pending_exception;
3035   __ movptr(rax, Address(r15_thread, Thread::pending_exception_offset()));
3036   __ testptr(rax, rax);
3037   __ jcc(Assembler::zero, no_pending_exception);
3038   __ stop(&quot;must not have pending exception here&quot;);
3039   __ bind(no_pending_exception);
3040 #endif
3041 
3042   __ bind(cont);
3043 
3044   // Call C code.  Need thread and this frame, but NOT official VM entry
3045   // crud.  We cannot block on this call, no GC can happen.
3046   //
3047   // UnrollBlock* fetch_unroll_info(JavaThread* thread)
3048 
3049   // fetch_unroll_info needs to call last_java_frame().
3050 
3051   __ set_last_Java_frame(noreg, noreg, NULL);
3052 #ifdef ASSERT
3053   { Label L;
3054     __ cmpptr(Address(r15_thread,
3055                     JavaThread::last_Java_fp_offset()),
3056             (int32_t)0);
3057     __ jcc(Assembler::equal, L);
3058     __ stop(&quot;SharedRuntime::generate_deopt_blob: last_Java_fp not cleared&quot;);
3059     __ bind(L);
3060   }
3061 #endif // ASSERT
3062   __ mov(c_rarg0, r15_thread);
3063   __ movl(c_rarg1, r14); // exec_mode
3064   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::fetch_unroll_info)));
3065 
3066   // Need to have an oopmap that tells fetch_unroll_info where to
3067   // find any register it might need.
3068   oop_maps-&gt;add_gc_map(__ pc() - start, map);
3069 
3070   __ reset_last_Java_frame(false);
3071 
3072 #if INCLUDE_JVMCI
3073   if (EnableJVMCI || UseAOT) {
3074     __ bind(after_fetch_unroll_info_call);
3075   }
3076 #endif
3077 
3078   // Load UnrollBlock* into rdi
3079   __ mov(rdi, rax);
3080 
3081   __ movl(r14, Address(rdi, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
3082    Label noException;
3083   __ cmpl(r14, Deoptimization::Unpack_exception);   // Was exception pending?
3084   __ jcc(Assembler::notEqual, noException);
3085   __ movptr(rax, Address(r15_thread, JavaThread::exception_oop_offset()));
3086   // QQQ this is useless it was NULL above
3087   __ movptr(rdx, Address(r15_thread, JavaThread::exception_pc_offset()));
3088   __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()), (int32_t)NULL_WORD);
3089   __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), (int32_t)NULL_WORD);
3090 
3091   __ verify_oop(rax);
3092 
3093   // Overwrite the result registers with the exception results.
3094   __ movptr(Address(rsp, RegisterSaver::rax_offset_in_bytes()), rax);
3095   // I think this is useless
3096   __ movptr(Address(rsp, RegisterSaver::rdx_offset_in_bytes()), rdx);
3097 
3098   __ bind(noException);
3099 
3100   // Only register save data is on the stack.
3101   // Now restore the result registers.  Everything else is either dead
3102   // or captured in the vframeArray.
3103   RegisterSaver::restore_result_registers(masm);
3104 
3105   // All of the register save area has been popped of the stack. Only the
3106   // return address remains.
3107 
3108   // Pop all the frames we must move/replace.
3109   //
3110   // Frame picture (youngest to oldest)
3111   // 1: self-frame (no frame link)
3112   // 2: deopting frame  (no frame link)
3113   // 3: caller of deopting frame (could be compiled/interpreted).
3114   //
3115   // Note: by leaving the return address of self-frame on the stack
3116   // and using the size of frame 2 to adjust the stack
3117   // when we are done the return to frame 3 will still be on the stack.
3118 
3119   // Pop deoptimized frame
3120   __ movl(rcx, Address(rdi, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset_in_bytes()));
3121   __ addptr(rsp, rcx);
3122 
3123   // rsp should be pointing at the return address to the caller (3)
3124 
3125   // Pick up the initial fp we should save
3126   // restore rbp before stack bang because if stack overflow is thrown it needs to be pushed (and preserved)
3127   __ movptr(rbp, Address(rdi, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));
3128 
3129 #ifdef ASSERT
3130   // Compilers generate code that bang the stack by as much as the
3131   // interpreter would need. So this stack banging should never
3132   // trigger a fault. Verify that it does not on non product builds.
3133   if (UseStackBanging) {
3134     __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));
3135     __ bang_stack_size(rbx, rcx);
3136   }
3137 #endif
3138 
3139   // Load address of array of frame pcs into rcx
3140   __ movptr(rcx, Address(rdi, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
3141 
3142   // Trash the old pc
3143   __ addptr(rsp, wordSize);
3144 
3145   // Load address of array of frame sizes into rsi
3146   __ movptr(rsi, Address(rdi, Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));
3147 
3148   // Load counter into rdx
3149   __ movl(rdx, Address(rdi, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));
3150 
3151   // Now adjust the caller&#39;s stack to make up for the extra locals
3152   // but record the original sp so that we can save it in the skeletal interpreter
3153   // frame and the stack walking of interpreter_sender will get the unextended sp
3154   // value and not the &quot;real&quot; sp value.
3155 
3156   const Register sender_sp = r8;
3157 
3158   __ mov(sender_sp, rsp);
3159   __ movl(rbx, Address(rdi,
3160                        Deoptimization::UnrollBlock::
3161                        caller_adjustment_offset_in_bytes()));
3162   __ subptr(rsp, rbx);
3163 
3164   // Push interpreter frames in a loop
3165   Label loop;
3166   __ bind(loop);
3167   __ movptr(rbx, Address(rsi, 0));      // Load frame size
3168   __ subptr(rbx, 2*wordSize);           // We&#39;ll push pc and ebp by hand
3169   __ pushptr(Address(rcx, 0));          // Save return address
3170   __ enter();                           // Save old &amp; set new ebp
3171   __ subptr(rsp, rbx);                  // Prolog
3172   // This value is corrected by layout_activation_impl
3173   __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD );
3174   __ movptr(Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize), sender_sp); // Make it walkable
3175   __ mov(sender_sp, rsp);               // Pass sender_sp to next frame
3176   __ addptr(rsi, wordSize);             // Bump array pointer (sizes)
3177   __ addptr(rcx, wordSize);             // Bump array pointer (pcs)
3178   __ decrementl(rdx);                   // Decrement counter
3179   __ jcc(Assembler::notZero, loop);
3180   __ pushptr(Address(rcx, 0));          // Save final return address
3181 
3182   // Re-push self-frame
3183   __ enter();                           // Save old &amp; set new ebp
3184 
3185   // Allocate a full sized register save area.
3186   // Return address and rbp are in place, so we allocate two less words.
3187   __ subptr(rsp, (frame_size_in_words - 2) * wordSize);
3188 
3189   // Restore frame locals after moving the frame
3190   __ movdbl(Address(rsp, RegisterSaver::xmm0_offset_in_bytes()), xmm0);
3191   __ movptr(Address(rsp, RegisterSaver::rax_offset_in_bytes()), rax);
3192 
3193   // Call C code.  Need thread but NOT official VM entry
3194   // crud.  We cannot block on this call, no GC can happen.  Call should
3195   // restore return values to their stack-slots with the new SP.
3196   //
3197   // void Deoptimization::unpack_frames(JavaThread* thread, int exec_mode)
3198 
3199   // Use rbp because the frames look interpreted now
3200   // Save &quot;the_pc&quot; since it cannot easily be retrieved using the last_java_SP after we aligned SP.
3201   // Don&#39;t need the precise return PC here, just precise enough to point into this code blob.
3202   address the_pc = __ pc();
3203   __ set_last_Java_frame(noreg, rbp, the_pc);
3204 
3205   __ andptr(rsp, -(StackAlignmentInBytes));  // Fix stack alignment as required by ABI
3206   __ mov(c_rarg0, r15_thread);
3207   __ movl(c_rarg1, r14); // second arg: exec_mode
3208   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
3209   // Revert SP alignment after call since we&#39;re going to do some SP relative addressing below
3210   __ movptr(rsp, Address(r15_thread, JavaThread::last_Java_sp_offset()));
3211 
3212   // Set an oopmap for the call site
3213   // Use the same PC we used for the last java frame
3214   oop_maps-&gt;add_gc_map(the_pc - start,
3215                        new OopMap( frame_size_in_words, 0 ));
3216 
3217   // Clear fp AND pc
3218   __ reset_last_Java_frame(true);
3219 
3220   // Collect return values
3221   __ movdbl(xmm0, Address(rsp, RegisterSaver::xmm0_offset_in_bytes()));
3222   __ movptr(rax, Address(rsp, RegisterSaver::rax_offset_in_bytes()));
3223   // I think this is useless (throwing pc?)
3224   __ movptr(rdx, Address(rsp, RegisterSaver::rdx_offset_in_bytes()));
3225 
3226   // Pop self-frame.
3227   __ leave();                           // Epilog
3228 
3229   // Jump to interpreter
3230   __ ret(0);
3231 
3232   // Make sure all code is generated
3233   masm-&gt;flush();
3234 
3235   _deopt_blob = DeoptimizationBlob::create(&amp;buffer, oop_maps, 0, exception_offset, reexecute_offset, frame_size_in_words);
3236   _deopt_blob-&gt;set_unpack_with_exception_in_tls_offset(exception_in_tls_offset);
3237 #if INCLUDE_JVMCI
3238   if (EnableJVMCI || UseAOT) {
3239     _deopt_blob-&gt;set_uncommon_trap_offset(uncommon_trap_offset);
3240     _deopt_blob-&gt;set_implicit_exception_uncommon_trap_offset(implicit_exception_uncommon_trap_offset);
3241   }
3242 #endif
3243 }
3244 
3245 #ifdef COMPILER2
3246 //------------------------------generate_uncommon_trap_blob--------------------
3247 void SharedRuntime::generate_uncommon_trap_blob() {
3248   // Allocate space for the code
3249   ResourceMark rm;
3250   // Setup code generation tools
3251   CodeBuffer buffer(&quot;uncommon_trap_blob&quot;, 2048, 1024);
3252   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
3253 
3254   assert(SimpleRuntimeFrame::framesize % 4 == 0, &quot;sp not 16-byte aligned&quot;);
3255 
3256   address start = __ pc();
3257 
3258   if (UseRTMLocking) {
3259     // Abort RTM transaction before possible nmethod deoptimization.
3260     __ xabort(0);
3261   }
3262 
3263   // Push self-frame.  We get here with a return address on the
3264   // stack, so rsp is 8-byte aligned until we allocate our frame.
3265   __ subptr(rsp, SimpleRuntimeFrame::return_off &lt;&lt; LogBytesPerInt); // Epilog!
3266 
3267   // No callee saved registers. rbp is assumed implicitly saved
3268   __ movptr(Address(rsp, SimpleRuntimeFrame::rbp_off &lt;&lt; LogBytesPerInt), rbp);
3269 
3270   // compiler left unloaded_class_index in j_rarg0 move to where the
3271   // runtime expects it.
3272   __ movl(c_rarg1, j_rarg0);
3273 
3274   __ set_last_Java_frame(noreg, noreg, NULL);
3275 
3276   // Call C code.  Need thread but NOT official VM entry
3277   // crud.  We cannot block on this call, no GC can happen.  Call should
3278   // capture callee-saved registers as well as return values.
3279   // Thread is in rdi already.
3280   //
3281   // UnrollBlock* uncommon_trap(JavaThread* thread, jint unloaded_class_index);
3282 
3283   __ mov(c_rarg0, r15_thread);
3284   __ movl(c_rarg2, Deoptimization::Unpack_uncommon_trap);
3285   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap)));
3286 
3287   // Set an oopmap for the call site
3288   OopMapSet* oop_maps = new OopMapSet();
3289   OopMap* map = new OopMap(SimpleRuntimeFrame::framesize, 0);
3290 
3291   // location of rbp is known implicitly by the frame sender code
3292 
3293   oop_maps-&gt;add_gc_map(__ pc() - start, map);
3294 
3295   __ reset_last_Java_frame(false);
3296 
3297   // Load UnrollBlock* into rdi
3298   __ mov(rdi, rax);
3299 
3300 #ifdef ASSERT
3301   { Label L;
3302     __ cmpptr(Address(rdi, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()),
3303             (int32_t)Deoptimization::Unpack_uncommon_trap);
3304     __ jcc(Assembler::equal, L);
3305     __ stop(&quot;SharedRuntime::generate_deopt_blob: expected Unpack_uncommon_trap&quot;);
3306     __ bind(L);
3307   }
3308 #endif
3309 
3310   // Pop all the frames we must move/replace.
3311   //
3312   // Frame picture (youngest to oldest)
3313   // 1: self-frame (no frame link)
3314   // 2: deopting frame  (no frame link)
3315   // 3: caller of deopting frame (could be compiled/interpreted).
3316 
3317   // Pop self-frame.  We have no frame, and must rely only on rax and rsp.
3318   __ addptr(rsp, (SimpleRuntimeFrame::framesize - 2) &lt;&lt; LogBytesPerInt); // Epilog!
3319 
3320   // Pop deoptimized frame (int)
3321   __ movl(rcx, Address(rdi,
3322                        Deoptimization::UnrollBlock::
3323                        size_of_deoptimized_frame_offset_in_bytes()));
3324   __ addptr(rsp, rcx);
3325 
3326   // rsp should be pointing at the return address to the caller (3)
3327 
3328   // Pick up the initial fp we should save
3329   // restore rbp before stack bang because if stack overflow is thrown it needs to be pushed (and preserved)
3330   __ movptr(rbp, Address(rdi, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));
3331 
3332 #ifdef ASSERT
3333   // Compilers generate code that bang the stack by as much as the
3334   // interpreter would need. So this stack banging should never
3335   // trigger a fault. Verify that it does not on non product builds.
3336   if (UseStackBanging) {
3337     __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));
3338     __ bang_stack_size(rbx, rcx);
3339   }
3340 #endif
3341 
3342   // Load address of array of frame pcs into rcx (address*)
3343   __ movptr(rcx, Address(rdi, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
3344 
3345   // Trash the return pc
3346   __ addptr(rsp, wordSize);
3347 
3348   // Load address of array of frame sizes into rsi (intptr_t*)
3349   __ movptr(rsi, Address(rdi, Deoptimization::UnrollBlock:: frame_sizes_offset_in_bytes()));
3350 
3351   // Counter
3352   __ movl(rdx, Address(rdi, Deoptimization::UnrollBlock:: number_of_frames_offset_in_bytes())); // (int)
3353 
3354   // Now adjust the caller&#39;s stack to make up for the extra locals but
3355   // record the original sp so that we can save it in the skeletal
3356   // interpreter frame and the stack walking of interpreter_sender
3357   // will get the unextended sp value and not the &quot;real&quot; sp value.
3358 
3359   const Register sender_sp = r8;
3360 
3361   __ mov(sender_sp, rsp);
3362   __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock:: caller_adjustment_offset_in_bytes())); // (int)
3363   __ subptr(rsp, rbx);
3364 
3365   // Push interpreter frames in a loop
3366   Label loop;
3367   __ bind(loop);
3368   __ movptr(rbx, Address(rsi, 0)); // Load frame size
3369   __ subptr(rbx, 2 * wordSize);    // We&#39;ll push pc and rbp by hand
3370   __ pushptr(Address(rcx, 0));     // Save return address
3371   __ enter();                      // Save old &amp; set new rbp
3372   __ subptr(rsp, rbx);             // Prolog
3373   __ movptr(Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize),
3374             sender_sp);            // Make it walkable
3375   // This value is corrected by layout_activation_impl
3376   __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD );
3377   __ mov(sender_sp, rsp);          // Pass sender_sp to next frame
3378   __ addptr(rsi, wordSize);        // Bump array pointer (sizes)
3379   __ addptr(rcx, wordSize);        // Bump array pointer (pcs)
3380   __ decrementl(rdx);              // Decrement counter
3381   __ jcc(Assembler::notZero, loop);
3382   __ pushptr(Address(rcx, 0));     // Save final return address
3383 
3384   // Re-push self-frame
3385   __ enter();                 // Save old &amp; set new rbp
3386   __ subptr(rsp, (SimpleRuntimeFrame::framesize - 4) &lt;&lt; LogBytesPerInt);
3387                               // Prolog
3388 
3389   // Use rbp because the frames look interpreted now
3390   // Save &quot;the_pc&quot; since it cannot easily be retrieved using the last_java_SP after we aligned SP.
3391   // Don&#39;t need the precise return PC here, just precise enough to point into this code blob.
3392   address the_pc = __ pc();
3393   __ set_last_Java_frame(noreg, rbp, the_pc);
3394 
3395   // Call C code.  Need thread but NOT official VM entry
3396   // crud.  We cannot block on this call, no GC can happen.  Call should
3397   // restore return values to their stack-slots with the new SP.
3398   // Thread is in rdi already.
3399   //
3400   // BasicType unpack_frames(JavaThread* thread, int exec_mode);
3401 
3402   __ andptr(rsp, -(StackAlignmentInBytes)); // Align SP as required by ABI
3403   __ mov(c_rarg0, r15_thread);
3404   __ movl(c_rarg1, Deoptimization::Unpack_uncommon_trap);
3405   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
3406 
3407   // Set an oopmap for the call site
3408   // Use the same PC we used for the last java frame
3409   oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
3410 
3411   // Clear fp AND pc
3412   __ reset_last_Java_frame(true);
3413 
3414   // Pop self-frame.
3415   __ leave();                 // Epilog
3416 
3417   // Jump to interpreter
3418   __ ret(0);
3419 
3420   // Make sure all code is generated
3421   masm-&gt;flush();
3422 
3423   _uncommon_trap_blob =  UncommonTrapBlob::create(&amp;buffer, oop_maps,
3424                                                  SimpleRuntimeFrame::framesize &gt;&gt; 1);
3425 }
3426 #endif // COMPILER2
3427 
3428 
3429 //------------------------------generate_handler_blob------
3430 //
3431 // Generate a special Compile2Runtime blob that saves all registers,
3432 // and setup oopmap.
3433 //
3434 SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {
3435   assert(StubRoutines::forward_exception_entry() != NULL,
3436          &quot;must be generated before&quot;);
3437 
3438   ResourceMark rm;
3439   OopMapSet *oop_maps = new OopMapSet();
3440   OopMap* map;
3441 
3442   // Allocate space for the code.  Setup code generation tools.
3443   CodeBuffer buffer(&quot;handler_blob&quot;, 2048, 1024);
3444   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
3445 
3446   address start   = __ pc();
3447   address call_pc = NULL;
3448   int frame_size_in_words;
3449   bool cause_return = (poll_type == POLL_AT_RETURN);
3450   bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);
3451 
3452   if (UseRTMLocking) {
3453     // Abort RTM transaction before calling runtime
3454     // because critical section will be large and will be
3455     // aborted anyway. Also nmethod could be deoptimized.
3456     __ xabort(0);
3457   }
3458 
3459   // Make room for return address (or push it again)
3460   if (!cause_return) {
3461     __ push(rbx);
3462   }
3463 
3464   // Save registers, fpu state, and flags
3465   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words, save_vectors);
3466 
3467   // The following is basically a call_VM.  However, we need the precise
3468   // address of the call in order to generate an oopmap. Hence, we do all the
3469   // work outselves.
3470 
3471   __ set_last_Java_frame(noreg, noreg, NULL);
3472 
3473   // The return address must always be correct so that frame constructor never
3474   // sees an invalid pc.
3475 
3476   if (!cause_return) {
3477     // Get the return pc saved by the signal handler and stash it in its appropriate place on the stack.
3478     // Additionally, rbx is a callee saved register and we can look at it later to determine
3479     // if someone changed the return address for us!
3480     __ movptr(rbx, Address(r15_thread, JavaThread::saved_exception_pc_offset()));
3481     __ movptr(Address(rbp, wordSize), rbx);
3482   }
3483 
3484   // Do the call
3485   __ mov(c_rarg0, r15_thread);
3486   __ call(RuntimeAddress(call_ptr));
3487 
3488   // Set an oopmap for the call site.  This oopmap will map all
3489   // oop-registers and debug-info registers as callee-saved.  This
3490   // will allow deoptimization at this safepoint to find all possible
3491   // debug-info recordings, as well as let GC find all oops.
3492 
3493   oop_maps-&gt;add_gc_map( __ pc() - start, map);
3494 
3495   Label noException;
3496 
3497   __ reset_last_Java_frame(false);
3498 
3499   __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);
3500   __ jcc(Assembler::equal, noException);
3501 
3502   // Exception pending
3503 
3504   RegisterSaver::restore_live_registers(masm, save_vectors);
3505 
3506   __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
3507 
3508   // No exception case
3509   __ bind(noException);
3510 
3511   Label no_adjust;
3512 #ifdef ASSERT
3513   Label bail;
3514 #endif
3515   if (!cause_return) {
3516     Label no_prefix, not_special;
3517 
3518     // If our stashed return pc was modified by the runtime we avoid touching it
3519     __ cmpptr(rbx, Address(rbp, wordSize));
3520     __ jccb(Assembler::notEqual, no_adjust);
3521 
3522     // Skip over the poll instruction.
3523     // See NativeInstruction::is_safepoint_poll()
3524     // Possible encodings:
3525     //      85 00       test   %eax,(%rax)
3526     //      85 01       test   %eax,(%rcx)
3527     //      85 02       test   %eax,(%rdx)
3528     //      85 03       test   %eax,(%rbx)
3529     //      85 06       test   %eax,(%rsi)
3530     //      85 07       test   %eax,(%rdi)
3531     //
3532     //   41 85 00       test   %eax,(%r8)
3533     //   41 85 01       test   %eax,(%r9)
3534     //   41 85 02       test   %eax,(%r10)
3535     //   41 85 03       test   %eax,(%r11)
3536     //   41 85 06       test   %eax,(%r14)
3537     //   41 85 07       test   %eax,(%r15)
3538     //
3539     //      85 04 24    test   %eax,(%rsp)
3540     //   41 85 04 24    test   %eax,(%r12)
3541     //      85 45 00    test   %eax,0x0(%rbp)
3542     //   41 85 45 00    test   %eax,0x0(%r13)
3543 
3544     __ cmpb(Address(rbx, 0), NativeTstRegMem::instruction_rex_b_prefix);
3545     __ jcc(Assembler::notEqual, no_prefix);
3546     __ addptr(rbx, 1);
3547     __ bind(no_prefix);
3548 #ifdef ASSERT
3549     __ movptr(rax, rbx); // remember where 0x85 should be, for verification below
3550 #endif
3551     // r12/r13/rsp/rbp base encoding takes 3 bytes with the following register values:
3552     // r12/rsp 0x04
3553     // r13/rbp 0x05
3554     __ movzbq(rcx, Address(rbx, 1));
3555     __ andptr(rcx, 0x07); // looking for 0x04 .. 0x05
3556     __ subptr(rcx, 4);    // looking for 0x00 .. 0x01
3557     __ cmpptr(rcx, 1);
3558     __ jcc(Assembler::above, not_special);
3559     __ addptr(rbx, 1);
3560     __ bind(not_special);
3561 #ifdef ASSERT
3562     // Verify the correct encoding of the poll we&#39;re about to skip.
3563     __ cmpb(Address(rax, 0), NativeTstRegMem::instruction_code_memXregl);
3564     __ jcc(Assembler::notEqual, bail);
3565     // Mask out the modrm bits
3566     __ testb(Address(rax, 1), NativeTstRegMem::modrm_mask);
3567     // rax encodes to 0, so if the bits are nonzero it&#39;s incorrect
3568     __ jcc(Assembler::notZero, bail);
3569 #endif
3570     // Adjust return pc forward to step over the safepoint poll instruction
3571     __ addptr(rbx, 2);
3572     __ movptr(Address(rbp, wordSize), rbx);
3573   }
3574 
3575   __ bind(no_adjust);
3576   // Normal exit, restore registers and exit.
3577   RegisterSaver::restore_live_registers(masm, save_vectors);
3578   __ ret(0);
3579 
3580 #ifdef ASSERT
3581   __ bind(bail);
3582   __ stop(&quot;Attempting to adjust pc to skip safepoint poll but the return point is not what we expected&quot;);
3583 #endif
3584 
3585   // Make sure all code is generated
3586   masm-&gt;flush();
3587 
3588   // Fill-out other meta info
3589   return SafepointBlob::create(&amp;buffer, oop_maps, frame_size_in_words);
3590 }
3591 
3592 //
3593 // generate_resolve_blob - call resolution (static/virtual/opt-virtual/ic-miss
3594 //
3595 // Generate a stub that calls into vm to find out the proper destination
3596 // of a java call. All the argument registers are live at this point
3597 // but since this is generic code we don&#39;t know what they are and the caller
3598 // must do any gc of the args.
3599 //
3600 RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {
3601   assert (StubRoutines::forward_exception_entry() != NULL, &quot;must be generated before&quot;);
3602 
3603   // allocate space for the code
3604   ResourceMark rm;
3605 
3606   CodeBuffer buffer(name, 1000, 512);
3607   MacroAssembler* masm                = new MacroAssembler(&amp;buffer);
3608 
3609   int frame_size_in_words;
3610 
3611   OopMapSet *oop_maps = new OopMapSet();
3612   OopMap* map = NULL;
3613 
3614   int start = __ offset();
3615 
3616   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
3617 
3618   int frame_complete = __ offset();
3619 
3620   __ set_last_Java_frame(noreg, noreg, NULL);
3621 
3622   __ mov(c_rarg0, r15_thread);
3623 
3624   __ call(RuntimeAddress(destination));
3625 
3626 
3627   // Set an oopmap for the call site.
3628   // We need this not only for callee-saved registers, but also for volatile
3629   // registers that the compiler might be keeping live across a safepoint.
3630 
3631   oop_maps-&gt;add_gc_map( __ offset() - start, map);
3632 
3633   // rax contains the address we are going to jump to assuming no exception got installed
3634 
3635   // clear last_Java_sp
3636   __ reset_last_Java_frame(false);
3637   // check for pending exceptions
3638   Label pending;
3639   __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);
3640   __ jcc(Assembler::notEqual, pending);
3641 
3642   // get the returned Method*
3643   __ get_vm_result_2(rbx, r15_thread);
3644   __ movptr(Address(rsp, RegisterSaver::rbx_offset_in_bytes()), rbx);
3645 
3646   __ movptr(Address(rsp, RegisterSaver::rax_offset_in_bytes()), rax);
3647 
3648   RegisterSaver::restore_live_registers(masm);
3649 
3650   // We are back the the original state on entry and ready to go.
3651 
3652   __ jmp(rax);
3653 
3654   // Pending exception after the safepoint
3655 
3656   __ bind(pending);
3657 
3658   RegisterSaver::restore_live_registers(masm);
3659 
3660   // exception pending =&gt; remove activation and forward to exception handler
3661 
3662   __ movptr(Address(r15_thread, JavaThread::vm_result_offset()), (int)NULL_WORD);
3663 
3664   __ movptr(rax, Address(r15_thread, Thread::pending_exception_offset()));
3665   __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
3666 
3667   // -------------
3668   // make sure all code is generated
3669   masm-&gt;flush();
3670 
3671   // return the  blob
3672   // frame_size_words or bytes??
3673   return RuntimeStub::new_runtime_stub(name, &amp;buffer, frame_complete, frame_size_in_words, oop_maps, true);
3674 }
3675 
3676 static const int native_invoker_code_size = MethodHandles::adapter_code_size;
3677 
3678 class NativeInvokerGenerator : public StubCodeGenerator {
3679   address _call_target;
3680   int _shadow_space_bytes;
3681 
3682   const GrowableArray&lt;VMReg&gt;&amp; _input_registers;
3683   const GrowableArray&lt;VMReg&gt;&amp; _output_registers;
3684 public:
3685   NativeInvokerGenerator(CodeBuffer* buffer,
3686                          address call_target,
3687                          int shadow_space_bytes,
3688                          const GrowableArray&lt;VMReg&gt;&amp; input_registers,
3689                          const GrowableArray&lt;VMReg&gt;&amp; output_registers)
3690    : StubCodeGenerator(buffer, PrintMethodHandleStubs),
3691      _call_target(call_target),
3692      _shadow_space_bytes(shadow_space_bytes),
3693      _input_registers(input_registers),
3694      _output_registers(output_registers) {}
3695   void generate();
3696 
3697   void spill_register(VMReg reg) {
3698     assert(reg-&gt;is_reg(), &quot;must be a register&quot;);
3699     MacroAssembler* masm = _masm;
3700     if (reg-&gt;is_Register()) {
3701       __ push(reg-&gt;as_Register());
3702     } else if (reg-&gt;is_XMMRegister()) {
3703       if (UseAVX &gt;= 3) {
3704         __ subptr(rsp, 64); // bytes
3705         __ evmovdqul(Address(rsp, 0), reg-&gt;as_XMMRegister(), Assembler::AVX_512bit);
3706       } else if (UseAVX &gt;= 1) {
3707         __ subptr(rsp, 32);
3708         __ vmovdqu(Address(rsp, 0), reg-&gt;as_XMMRegister());
3709       } else {
3710         __ subptr(rsp, 16);
3711         __ movdqu(Address(rsp, 0), reg-&gt;as_XMMRegister());
3712       }
3713     } else {
3714       ShouldNotReachHere();
3715     }
3716   }
3717 
3718   void fill_register(VMReg reg) {
3719     assert(reg-&gt;is_reg(), &quot;must be a register&quot;);
3720     MacroAssembler* masm = _masm;
3721     if (reg-&gt;is_Register()) {
3722       __ pop(reg-&gt;as_Register());
3723     } else if (reg-&gt;is_XMMRegister()) {
3724       if (UseAVX &gt;= 3) {
3725         __ evmovdqul(reg-&gt;as_XMMRegister(), Address(rsp, 0), Assembler::AVX_512bit);
3726         __ addptr(rsp, 64); // bytes
3727       } else if (UseAVX &gt;= 1) {
3728         __ vmovdqu(reg-&gt;as_XMMRegister(), Address(rsp, 0));
3729         __ addptr(rsp, 32);
3730       } else {
3731         __ movdqu(reg-&gt;as_XMMRegister(), Address(rsp, 0));
3732         __ addptr(rsp, 16);
3733       }
3734     } else {
3735       ShouldNotReachHere();
3736     }
3737   }
3738 
3739 private:
3740 #ifdef ASSERT
3741 bool target_uses_register(VMReg reg) {
3742   return _input_registers.contains(reg) || _output_registers.contains(reg);
3743 }
3744 #endif
3745 };
3746 
3747 address SharedRuntime::make_native_invoker(address call_target,
3748                                            int shadow_space_bytes,
3749                                            const GrowableArray&lt;VMReg&gt;&amp; input_registers,
3750                                            const GrowableArray&lt;VMReg&gt;&amp; output_registers) {
3751   BufferBlob* _invoke_native_blob = BufferBlob::create(&quot;nep_invoker_blob&quot;, native_invoker_code_size);
3752   if (_invoke_native_blob == NULL)
3753     return NULL; // allocation failure
3754 
3755   CodeBuffer code(_invoke_native_blob);
3756   NativeInvokerGenerator g(&amp;code, call_target, shadow_space_bytes, input_registers, output_registers);
3757   g.generate();
3758   code.log_section_sizes(&quot;nep_invoker_blob&quot;);
3759 
3760   return _invoke_native_blob-&gt;code_begin();
3761 }
3762 
3763 void NativeInvokerGenerator::generate() {
3764   assert(!(target_uses_register(r15_thread-&gt;as_VMReg()) || target_uses_register(rscratch1-&gt;as_VMReg())), &quot;Register conflict&quot;);
3765 
3766   MacroAssembler* masm = _masm;
3767   __ enter();
3768 
<a name="1" id="anc1"></a><span class="line-modified">3769   Address java_pc(r15_thread, JavaThread::last_Java_pc_offset());</span>

3770   __ movptr(rscratch1, Address(rsp, 8)); // read return address from stack
3771   __ movptr(java_pc, rscratch1);
3772 
3773   __ movptr(rscratch1, rsp);
<a name="2" id="anc2"></a><span class="line-modified">3774   __ addptr(rscratch1, 16); // skip return and frame</span>
3775   __ movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), rscratch1);
3776 
<a name="3" id="anc3"></a><span class="line-added">3777   __ movptr(Address(r15_thread, JavaThread::saved_rbp_address_offset()), rsp); // rsp points at saved RBP</span>
<span class="line-added">3778 </span>
3779     // State transition
3780   __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);
3781 
3782   if (_shadow_space_bytes != 0) {
3783     // needed here for correct stack args offset on Windows
3784     __ subptr(rsp, _shadow_space_bytes);
3785   }
3786 
3787   __ call(RuntimeAddress(_call_target));
3788 
3789   if (_shadow_space_bytes != 0) {
3790     // needed here for correct stack args offset on Windows
3791     __ addptr(rsp, _shadow_space_bytes);
3792   }
3793 
3794   assert(_output_registers.length() &lt;= 1
3795     || (_output_registers.length() == 2 &amp;&amp; !_output_registers.at(1)-&gt;is_valid()), &quot;no multi-reg returns&quot;);
3796   bool need_spills = _output_registers.length() != 0;
3797   VMReg ret_reg = need_spills ? _output_registers.at(0) : VMRegImpl::Bad();
3798 
3799   __ restore_cpu_control_state_after_jni();
3800 
3801   __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);
3802 
3803   if (os::is_MP()) {
3804     // Force this write out before the read below
3805     __ membar(Assembler::Membar_mask_bits(
3806             Assembler::LoadLoad | Assembler::LoadStore |
3807             Assembler::StoreLoad | Assembler::StoreStore));
3808   }
3809 
3810   Label L_after_safepoint_poll;
3811   Label L_safepoint_poll_slow_path;
3812 
3813   __ safepoint_poll(L_safepoint_poll_slow_path, r15_thread, rscratch1);
3814   __ cmpl(Address(r15_thread, JavaThread::suspend_flags_offset()), 0);
3815   __ jcc(Assembler::notEqual, L_safepoint_poll_slow_path);
3816   // change thread state
3817   __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_Java);
3818 
3819   __ bind(L_after_safepoint_poll);
3820 
3821   __ block_comment(&quot;reguard stack check&quot;);
3822   Label L_reguard;
3823   Label L_after_reguard;
3824   __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), JavaThread::stack_guard_yellow_reserved_disabled);
3825   __ jcc(Assembler::equal, L_reguard);
3826   __ bind(L_after_reguard);
3827 
3828   __ reset_last_Java_frame(r15_thread, true);
3829 
3830   __ leave(); // required for proper stackwalking of RuntimeStub frame
3831   __ ret(0);
3832 
3833   //////////////////////////////////////////////////////////////////////////////
3834 
3835   __ block_comment(&quot;{ L_safepoint_poll_slow_path&quot;);
3836   __ bind(L_safepoint_poll_slow_path);
3837   __ vzeroupper();
3838 
3839   if (need_spills) {
3840     spill_register(ret_reg);
3841   }
3842 
3843   __ mov(c_rarg0, r15_thread);
3844   __ mov(r12, rsp); // remember sp
3845   __ subptr(rsp, frame::arg_reg_save_area_bytes); // windows
3846   __ andptr(rsp, -16); // align stack as required by ABI
3847   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));
3848   __ mov(rsp, r12); // restore sp
3849   __ reinit_heapbase();
3850 
3851   if (need_spills) {
3852     fill_register(ret_reg);
3853   }
3854 
3855   __ jmp(L_after_safepoint_poll);
3856   __ block_comment(&quot;} L_safepoint_poll_slow_path&quot;);
3857 
3858   //////////////////////////////////////////////////////////////////////////////
3859 
3860   __ block_comment(&quot;{ L_reguard&quot;);
3861   __ bind(L_reguard);
3862   __ vzeroupper();
3863 
3864   if (need_spills) {
3865     spill_register(ret_reg);
3866   }
3867 
3868   __ mov(r12, rsp); // remember sp
3869   __ subptr(rsp, frame::arg_reg_save_area_bytes); // windows
3870   __ andptr(rsp, -16); // align stack as required by ABI
3871   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));
3872   __ mov(rsp, r12); // restore sp
3873   __ reinit_heapbase();
3874 
3875   if (need_spills) {
3876     fill_register(ret_reg);
3877   }
3878 
3879   __ jmp(L_after_reguard);
3880 
3881   __ block_comment(&quot;} L_reguard&quot;);
3882 
3883   //////////////////////////////////////////////////////////////////////////////
3884 
3885   __ flush();
3886 }
3887 
3888 //------------------------------Montgomery multiplication------------------------
3889 //
3890 
3891 #ifndef _WINDOWS
3892 
3893 // Subtract 0:b from carry:a.  Return carry.
3894 static julong
3895 sub(julong a[], julong b[], julong carry, long len) {
3896   long long i = 0, cnt = len;
3897   julong tmp;
3898   asm volatile(&quot;clc; &quot;
3899                &quot;0: ; &quot;
3900                &quot;mov (%[b], %[i], 8), %[tmp]; &quot;
3901                &quot;sbb %[tmp], (%[a], %[i], 8); &quot;
3902                &quot;inc %[i]; dec %[cnt]; &quot;
3903                &quot;jne 0b; &quot;
3904                &quot;mov %[carry], %[tmp]; sbb $0, %[tmp]; &quot;
3905                : [i]&quot;+r&quot;(i), [cnt]&quot;+r&quot;(cnt), [tmp]&quot;=&amp;r&quot;(tmp)
3906                : [a]&quot;r&quot;(a), [b]&quot;r&quot;(b), [carry]&quot;r&quot;(carry)
3907                : &quot;memory&quot;);
3908   return tmp;
3909 }
3910 
3911 // Multiply (unsigned) Long A by Long B, accumulating the double-
3912 // length result into the accumulator formed of T0, T1, and T2.
3913 #define MACC(A, B, T0, T1, T2)                                  \
3914 do {                                                            \
3915   unsigned long hi, lo;                                         \
3916   __asm__ (&quot;mul %5; add %%rax, %2; adc %%rdx, %3; adc $0, %4&quot;   \
3917            : &quot;=&amp;d&quot;(hi), &quot;=a&quot;(lo), &quot;+r&quot;(T0), &quot;+r&quot;(T1), &quot;+g&quot;(T2)  \
3918            : &quot;r&quot;(A), &quot;a&quot;(B) : &quot;cc&quot;);                            \
3919  } while(0)
3920 
3921 // As above, but add twice the double-length result into the
3922 // accumulator.
3923 #define MACC2(A, B, T0, T1, T2)                                 \
3924 do {                                                            \
3925   unsigned long hi, lo;                                         \
3926   __asm__ (&quot;mul %5; add %%rax, %2; adc %%rdx, %3; adc $0, %4; &quot; \
3927            &quot;add %%rax, %2; adc %%rdx, %3; adc $0, %4&quot;           \
3928            : &quot;=&amp;d&quot;(hi), &quot;=a&quot;(lo), &quot;+r&quot;(T0), &quot;+r&quot;(T1), &quot;+g&quot;(T2)  \
3929            : &quot;r&quot;(A), &quot;a&quot;(B) : &quot;cc&quot;);                            \
3930  } while(0)
3931 
3932 #else //_WINDOWS
3933 
3934 static julong
3935 sub(julong a[], julong b[], julong carry, long len) {
3936   long i;
3937   julong tmp;
3938   unsigned char c = 1;
3939   for (i = 0; i &lt; len; i++) {
3940     c = _addcarry_u64(c, a[i], ~b[i], &amp;tmp);
3941     a[i] = tmp;
3942   }
3943   c = _addcarry_u64(c, carry, ~0, &amp;tmp);
3944   return tmp;
3945 }
3946 
3947 // Multiply (unsigned) Long A by Long B, accumulating the double-
3948 // length result into the accumulator formed of T0, T1, and T2.
3949 #define MACC(A, B, T0, T1, T2)                          \
3950 do {                                                    \
3951   julong hi, lo;                            \
3952   lo = _umul128(A, B, &amp;hi);                             \
3953   unsigned char c = _addcarry_u64(0, lo, T0, &amp;T0);      \
3954   c = _addcarry_u64(c, hi, T1, &amp;T1);                    \
3955   _addcarry_u64(c, T2, 0, &amp;T2);                         \
3956  } while(0)
3957 
3958 // As above, but add twice the double-length result into the
3959 // accumulator.
3960 #define MACC2(A, B, T0, T1, T2)                         \
3961 do {                                                    \
3962   julong hi, lo;                            \
3963   lo = _umul128(A, B, &amp;hi);                             \
3964   unsigned char c = _addcarry_u64(0, lo, T0, &amp;T0);      \
3965   c = _addcarry_u64(c, hi, T1, &amp;T1);                    \
3966   _addcarry_u64(c, T2, 0, &amp;T2);                         \
3967   c = _addcarry_u64(0, lo, T0, &amp;T0);                    \
3968   c = _addcarry_u64(c, hi, T1, &amp;T1);                    \
3969   _addcarry_u64(c, T2, 0, &amp;T2);                         \
3970  } while(0)
3971 
3972 #endif //_WINDOWS
3973 
3974 // Fast Montgomery multiplication.  The derivation of the algorithm is
3975 // in  A Cryptographic Library for the Motorola DSP56000,
3976 // Dusse and Kaliski, Proc. EUROCRYPT 90, pp. 230-237.
3977 
3978 static void NOINLINE
3979 montgomery_multiply(julong a[], julong b[], julong n[],
3980                     julong m[], julong inv, int len) {
3981   julong t0 = 0, t1 = 0, t2 = 0; // Triple-precision accumulator
3982   int i;
3983 
3984   assert(inv * n[0] == ULLONG_MAX, &quot;broken inverse in Montgomery multiply&quot;);
3985 
3986   for (i = 0; i &lt; len; i++) {
3987     int j;
3988     for (j = 0; j &lt; i; j++) {
3989       MACC(a[j], b[i-j], t0, t1, t2);
3990       MACC(m[j], n[i-j], t0, t1, t2);
3991     }
3992     MACC(a[i], b[0], t0, t1, t2);
3993     m[i] = t0 * inv;
3994     MACC(m[i], n[0], t0, t1, t2);
3995 
3996     assert(t0 == 0, &quot;broken Montgomery multiply&quot;);
3997 
3998     t0 = t1; t1 = t2; t2 = 0;
3999   }
4000 
4001   for (i = len; i &lt; 2*len; i++) {
4002     int j;
4003     for (j = i-len+1; j &lt; len; j++) {
4004       MACC(a[j], b[i-j], t0, t1, t2);
4005       MACC(m[j], n[i-j], t0, t1, t2);
4006     }
4007     m[i-len] = t0;
4008     t0 = t1; t1 = t2; t2 = 0;
4009   }
4010 
4011   while (t0)
4012     t0 = sub(m, n, t0, len);
4013 }
4014 
4015 // Fast Montgomery squaring.  This uses asymptotically 25% fewer
4016 // multiplies so it should be up to 25% faster than Montgomery
4017 // multiplication.  However, its loop control is more complex and it
4018 // may actually run slower on some machines.
4019 
4020 static void NOINLINE
4021 montgomery_square(julong a[], julong n[],
4022                   julong m[], julong inv, int len) {
4023   julong t0 = 0, t1 = 0, t2 = 0; // Triple-precision accumulator
4024   int i;
4025 
4026   assert(inv * n[0] == ULLONG_MAX, &quot;broken inverse in Montgomery square&quot;);
4027 
4028   for (i = 0; i &lt; len; i++) {
4029     int j;
4030     int end = (i+1)/2;
4031     for (j = 0; j &lt; end; j++) {
4032       MACC2(a[j], a[i-j], t0, t1, t2);
4033       MACC(m[j], n[i-j], t0, t1, t2);
4034     }
4035     if ((i &amp; 1) == 0) {
4036       MACC(a[j], a[j], t0, t1, t2);
4037     }
4038     for (; j &lt; i; j++) {
4039       MACC(m[j], n[i-j], t0, t1, t2);
4040     }
4041     m[i] = t0 * inv;
4042     MACC(m[i], n[0], t0, t1, t2);
4043 
4044     assert(t0 == 0, &quot;broken Montgomery square&quot;);
4045 
4046     t0 = t1; t1 = t2; t2 = 0;
4047   }
4048 
4049   for (i = len; i &lt; 2*len; i++) {
4050     int start = i-len+1;
4051     int end = start + (len - start)/2;
4052     int j;
4053     for (j = start; j &lt; end; j++) {
4054       MACC2(a[j], a[i-j], t0, t1, t2);
4055       MACC(m[j], n[i-j], t0, t1, t2);
4056     }
4057     if ((i &amp; 1) == 0) {
4058       MACC(a[j], a[j], t0, t1, t2);
4059     }
4060     for (; j &lt; len; j++) {
4061       MACC(m[j], n[i-j], t0, t1, t2);
4062     }
4063     m[i-len] = t0;
4064     t0 = t1; t1 = t2; t2 = 0;
4065   }
4066 
4067   while (t0)
4068     t0 = sub(m, n, t0, len);
4069 }
4070 
4071 // Swap words in a longword.
4072 static julong swap(julong x) {
4073   return (x &lt;&lt; 32) | (x &gt;&gt; 32);
4074 }
4075 
4076 // Copy len longwords from s to d, word-swapping as we go.  The
4077 // destination array is reversed.
4078 static void reverse_words(julong *s, julong *d, int len) {
4079   d += len;
4080   while(len-- &gt; 0) {
4081     d--;
4082     *d = swap(*s);
4083     s++;
4084   }
4085 }
4086 
4087 // The threshold at which squaring is advantageous was determined
4088 // experimentally on an i7-3930K (Ivy Bridge) CPU @ 3.5GHz.
4089 #define MONTGOMERY_SQUARING_THRESHOLD 64
4090 
4091 void SharedRuntime::montgomery_multiply(jint *a_ints, jint *b_ints, jint *n_ints,
4092                                         jint len, jlong inv,
4093                                         jint *m_ints) {
4094   assert(len % 2 == 0, &quot;array length in montgomery_multiply must be even&quot;);
4095   int longwords = len/2;
4096 
4097   // Make very sure we don&#39;t use so much space that the stack might
4098   // overflow.  512 jints corresponds to an 16384-bit integer and
4099   // will use here a total of 8k bytes of stack space.
4100   int total_allocation = longwords * sizeof (julong) * 4;
4101   guarantee(total_allocation &lt;= 8192, &quot;must be&quot;);
4102   julong *scratch = (julong *)alloca(total_allocation);
4103 
4104   // Local scratch arrays
4105   julong
4106     *a = scratch + 0 * longwords,
4107     *b = scratch + 1 * longwords,
4108     *n = scratch + 2 * longwords,
4109     *m = scratch + 3 * longwords;
4110 
4111   reverse_words((julong *)a_ints, a, longwords);
4112   reverse_words((julong *)b_ints, b, longwords);
4113   reverse_words((julong *)n_ints, n, longwords);
4114 
4115   ::montgomery_multiply(a, b, n, m, (julong)inv, longwords);
4116 
4117   reverse_words(m, (julong *)m_ints, longwords);
4118 }
4119 
4120 void SharedRuntime::montgomery_square(jint *a_ints, jint *n_ints,
4121                                       jint len, jlong inv,
4122                                       jint *m_ints) {
4123   assert(len % 2 == 0, &quot;array length in montgomery_square must be even&quot;);
4124   int longwords = len/2;
4125 
4126   // Make very sure we don&#39;t use so much space that the stack might
4127   // overflow.  512 jints corresponds to an 16384-bit integer and
4128   // will use here a total of 6k bytes of stack space.
4129   int total_allocation = longwords * sizeof (julong) * 3;
4130   guarantee(total_allocation &lt;= 8192, &quot;must be&quot;);
4131   julong *scratch = (julong *)alloca(total_allocation);
4132 
4133   // Local scratch arrays
4134   julong
4135     *a = scratch + 0 * longwords,
4136     *n = scratch + 1 * longwords,
4137     *m = scratch + 2 * longwords;
4138 
4139   reverse_words((julong *)a_ints, a, longwords);
4140   reverse_words((julong *)n_ints, n, longwords);
4141 
4142   if (len &gt;= MONTGOMERY_SQUARING_THRESHOLD) {
4143     ::montgomery_square(a, n, m, (julong)inv, longwords);
4144   } else {
4145     ::montgomery_multiply(a, a, n, m, (julong)inv, longwords);
4146   }
4147 
4148   reverse_words(m, (julong *)m_ints, longwords);
4149 }
4150 
4151 #ifdef COMPILER2
4152 // This is here instead of runtime_x86_64.cpp because it uses SimpleRuntimeFrame
4153 //
4154 //------------------------------generate_exception_blob---------------------------
4155 // creates exception blob at the end
4156 // Using exception blob, this code is jumped from a compiled method.
4157 // (see emit_exception_handler in x86_64.ad file)
4158 //
4159 // Given an exception pc at a call we call into the runtime for the
4160 // handler in this method. This handler might merely restore state
4161 // (i.e. callee save registers) unwind the frame and jump to the
4162 // exception handler for the nmethod if there is no Java level handler
4163 // for the nmethod.
4164 //
4165 // This code is entered with a jmp.
4166 //
4167 // Arguments:
4168 //   rax: exception oop
4169 //   rdx: exception pc
4170 //
4171 // Results:
4172 //   rax: exception oop
4173 //   rdx: exception pc in caller or ???
4174 //   destination: exception handler of caller
4175 //
4176 // Note: the exception pc MUST be at a call (precise debug information)
4177 //       Registers rax, rdx, rcx, rsi, rdi, r8-r11 are not callee saved.
4178 //
4179 
4180 void OptoRuntime::generate_exception_blob() {
4181   assert(!OptoRuntime::is_callee_saved_register(RDX_num), &quot;&quot;);
4182   assert(!OptoRuntime::is_callee_saved_register(RAX_num), &quot;&quot;);
4183   assert(!OptoRuntime::is_callee_saved_register(RCX_num), &quot;&quot;);
4184 
4185   assert(SimpleRuntimeFrame::framesize % 4 == 0, &quot;sp not 16-byte aligned&quot;);
4186 
4187   // Allocate space for the code
4188   ResourceMark rm;
4189   // Setup code generation tools
4190   CodeBuffer buffer(&quot;exception_blob&quot;, 2048, 1024);
4191   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
4192 
4193 
4194   address start = __ pc();
4195 
4196   // Exception pc is &#39;return address&#39; for stack walker
4197   __ push(rdx);
4198   __ subptr(rsp, SimpleRuntimeFrame::return_off &lt;&lt; LogBytesPerInt); // Prolog
4199 
4200   // Save callee-saved registers.  See x86_64.ad.
4201 
4202   // rbp is an implicitly saved callee saved register (i.e., the calling
4203   // convention will save/restore it in the prolog/epilog). Other than that
4204   // there are no callee save registers now that adapter frames are gone.
4205 
4206   __ movptr(Address(rsp, SimpleRuntimeFrame::rbp_off &lt;&lt; LogBytesPerInt), rbp);
4207 
4208   // Store exception in Thread object. We cannot pass any arguments to the
4209   // handle_exception call, since we do not want to make any assumption
4210   // about the size of the frame where the exception happened in.
4211   // c_rarg0 is either rdi (Linux) or rcx (Windows).
4212   __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()),rax);
4213   __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), rdx);
4214 
4215   // This call does all the hard work.  It checks if an exception handler
4216   // exists in the method.
4217   // If so, it returns the handler address.
4218   // If not, it prepares for stack-unwinding, restoring the callee-save
4219   // registers of the frame being removed.
4220   //
4221   // address OptoRuntime::handle_exception_C(JavaThread* thread)
4222 
4223   // At a method handle call, the stack may not be properly aligned
4224   // when returning with an exception.
4225   address the_pc = __ pc();
4226   __ set_last_Java_frame(noreg, noreg, the_pc);
4227   __ mov(c_rarg0, r15_thread);
4228   __ andptr(rsp, -(StackAlignmentInBytes));    // Align stack
4229   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C)));
4230 
4231   // Set an oopmap for the call site.  This oopmap will only be used if we
4232   // are unwinding the stack.  Hence, all locations will be dead.
4233   // Callee-saved registers will be the same as the frame above (i.e.,
4234   // handle_exception_stub), since they were restored when we got the
4235   // exception.
4236 
4237   OopMapSet* oop_maps = new OopMapSet();
4238 
4239   oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
4240 
4241   __ reset_last_Java_frame(false);
4242 
4243   // Restore callee-saved registers
4244 
4245   // rbp is an implicitly saved callee-saved register (i.e., the calling
4246   // convention will save restore it in prolog/epilog) Other than that
4247   // there are no callee save registers now that adapter frames are gone.
4248 
4249   __ movptr(rbp, Address(rsp, SimpleRuntimeFrame::rbp_off &lt;&lt; LogBytesPerInt));
4250 
4251   __ addptr(rsp, SimpleRuntimeFrame::return_off &lt;&lt; LogBytesPerInt); // Epilog
4252   __ pop(rdx);                  // No need for exception pc anymore
4253 
4254   // rax: exception handler
4255 
4256   // We have a handler in rax (could be deopt blob).
4257   __ mov(r8, rax);
4258 
4259   // Get the exception oop
4260   __ movptr(rax, Address(r15_thread, JavaThread::exception_oop_offset()));
4261   // Get the exception pc in case we are deoptimized
4262   __ movptr(rdx, Address(r15_thread, JavaThread::exception_pc_offset()));
4263 #ifdef ASSERT
4264   __ movptr(Address(r15_thread, JavaThread::exception_handler_pc_offset()), (int)NULL_WORD);
4265   __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), (int)NULL_WORD);
4266 #endif
4267   // Clear the exception oop so GC no longer processes it as a root.
4268   __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()), (int)NULL_WORD);
4269 
4270   // rax: exception oop
4271   // r8:  exception handler
4272   // rdx: exception pc
4273   // Jump to handler
4274 
4275   __ jmp(r8);
4276 
4277   // Make sure all code is generated
4278   masm-&gt;flush();
4279 
4280   // Set exception blob
4281   _exception_blob =  ExceptionBlob::create(&amp;buffer, oop_maps, SimpleRuntimeFrame::framesize &gt;&gt; 1);
4282 }
4283 #endif // COMPILER2
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>