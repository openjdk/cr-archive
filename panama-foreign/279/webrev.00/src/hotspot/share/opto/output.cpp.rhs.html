<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/output.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.inline.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;code/compiledIC.hpp&quot;
  29 #include &quot;code/debugInfo.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;compiler/compilerDirectives.hpp&quot;
  33 #include &quot;compiler/disassembler.hpp&quot;
  34 #include &quot;compiler/oopMap.hpp&quot;
  35 #include &quot;gc/shared/barrierSet.hpp&quot;
  36 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/allocation.hpp&quot;
  39 #include &quot;opto/ad.hpp&quot;
  40 #include &quot;opto/block.hpp&quot;
  41 #include &quot;opto/c2compiler.hpp&quot;
  42 #include &quot;opto/callnode.hpp&quot;
  43 #include &quot;opto/cfgnode.hpp&quot;
  44 #include &quot;opto/locknode.hpp&quot;
  45 #include &quot;opto/machnode.hpp&quot;
  46 #include &quot;opto/node.hpp&quot;
  47 #include &quot;opto/optoreg.hpp&quot;
  48 #include &quot;opto/output.hpp&quot;
  49 #include &quot;opto/regalloc.hpp&quot;
  50 #include &quot;opto/runtime.hpp&quot;
  51 #include &quot;opto/subnode.hpp&quot;
  52 #include &quot;opto/type.hpp&quot;
  53 #include &quot;runtime/handles.inline.hpp&quot;
  54 #include &quot;runtime/sharedRuntime.hpp&quot;
  55 #include &quot;utilities/macros.hpp&quot;
  56 #include &quot;utilities/powerOfTwo.hpp&quot;
  57 #include &quot;utilities/xmlstream.hpp&quot;
  58 
  59 #ifndef PRODUCT
  60 #define DEBUG_ARG(x) , x
  61 #else
  62 #define DEBUG_ARG(x)
  63 #endif
  64 
  65 //------------------------------Scheduling----------------------------------
  66 // This class contains all the information necessary to implement instruction
  67 // scheduling and bundling.
  68 class Scheduling {
  69 
  70 private:
  71   // Arena to use
  72   Arena *_arena;
  73 
  74   // Control-Flow Graph info
  75   PhaseCFG *_cfg;
  76 
  77   // Register Allocation info
  78   PhaseRegAlloc *_regalloc;
  79 
  80   // Number of nodes in the method
  81   uint _node_bundling_limit;
  82 
  83   // List of scheduled nodes. Generated in reverse order
  84   Node_List _scheduled;
  85 
  86   // List of nodes currently available for choosing for scheduling
  87   Node_List _available;
  88 
  89   // For each instruction beginning a bundle, the number of following
  90   // nodes to be bundled with it.
  91   Bundle *_node_bundling_base;
  92 
  93   // Mapping from register to Node
  94   Node_List _reg_node;
  95 
  96   // Free list for pinch nodes.
  97   Node_List _pinch_free_list;
  98 
  99   // Latency from the beginning of the containing basic block (base 1)
 100   // for each node.
 101   unsigned short *_node_latency;
 102 
 103   // Number of uses of this node within the containing basic block.
 104   short *_uses;
 105 
 106   // Schedulable portion of current block.  Skips Region/Phi/CreateEx up
 107   // front, branch+proj at end.  Also skips Catch/CProj (same as
 108   // branch-at-end), plus just-prior exception-throwing call.
 109   uint _bb_start, _bb_end;
 110 
 111   // Latency from the end of the basic block as scheduled
 112   unsigned short *_current_latency;
 113 
 114   // Remember the next node
 115   Node *_next_node;
 116 
 117   // Use this for an unconditional branch delay slot
 118   Node *_unconditional_delay_slot;
 119 
 120   // Pointer to a Nop
 121   MachNopNode *_nop;
 122 
 123   // Length of the current bundle, in instructions
 124   uint _bundle_instr_count;
 125 
 126   // Current Cycle number, for computing latencies and bundling
 127   uint _bundle_cycle_number;
 128 
 129   // Bundle information
 130   Pipeline_Use_Element _bundle_use_elements[resource_count];
 131   Pipeline_Use         _bundle_use;
 132 
 133   // Dump the available list
 134   void dump_available() const;
 135 
 136 public:
 137   Scheduling(Arena *arena, Compile &amp;compile);
 138 
 139   // Destructor
 140   NOT_PRODUCT( ~Scheduling(); )
 141 
 142   // Step ahead &quot;i&quot; cycles
 143   void step(uint i);
 144 
 145   // Step ahead 1 cycle, and clear the bundle state (for example,
 146   // at a branch target)
 147   void step_and_clear();
 148 
 149   Bundle* node_bundling(const Node *n) {
 150     assert(valid_bundle_info(n), &quot;oob&quot;);
 151     return (&amp;_node_bundling_base[n-&gt;_idx]);
 152   }
 153 
 154   bool valid_bundle_info(const Node *n) const {
 155     return (_node_bundling_limit &gt; n-&gt;_idx);
 156   }
 157 
 158   bool starts_bundle(const Node *n) const {
 159     return (_node_bundling_limit &gt; n-&gt;_idx &amp;&amp; _node_bundling_base[n-&gt;_idx].starts_bundle());
 160   }
 161 
 162   // Do the scheduling
 163   void DoScheduling();
 164 
 165   // Compute the local latencies walking forward over the list of
 166   // nodes for a basic block
 167   void ComputeLocalLatenciesForward(const Block *bb);
 168 
 169   // Compute the register antidependencies within a basic block
 170   void ComputeRegisterAntidependencies(Block *bb);
 171   void verify_do_def( Node *n, OptoReg::Name def, const char *msg );
 172   void verify_good_schedule( Block *b, const char *msg );
 173   void anti_do_def( Block *b, Node *def, OptoReg::Name def_reg, int is_def );
 174   void anti_do_use( Block *b, Node *use, OptoReg::Name use_reg );
 175 
 176   // Add a node to the current bundle
 177   void AddNodeToBundle(Node *n, const Block *bb);
 178 
 179   // Add a node to the list of available nodes
 180   void AddNodeToAvailableList(Node *n);
 181 
 182   // Compute the local use count for the nodes in a block, and compute
 183   // the list of instructions with no uses in the block as available
 184   void ComputeUseCount(const Block *bb);
 185 
 186   // Choose an instruction from the available list to add to the bundle
 187   Node * ChooseNodeToBundle();
 188 
 189   // See if this Node fits into the currently accumulating bundle
 190   bool NodeFitsInBundle(Node *n);
 191 
 192   // Decrement the use count for a node
 193  void DecrementUseCounts(Node *n, const Block *bb);
 194 
 195   // Garbage collect pinch nodes for reuse by other blocks.
 196   void garbage_collect_pinch_nodes();
 197   // Clean up a pinch node for reuse (helper for above).
 198   void cleanup_pinch( Node *pinch );
 199 
 200   // Information for statistics gathering
 201 #ifndef PRODUCT
 202 private:
 203   // Gather information on size of nops relative to total
 204   uint _branches, _unconditional_delays;
 205 
 206   static uint _total_nop_size, _total_method_size;
 207   static uint _total_branches, _total_unconditional_delays;
 208   static uint _total_instructions_per_bundle[Pipeline::_max_instrs_per_cycle+1];
 209 
 210 public:
 211   static void print_statistics();
 212 
 213   static void increment_instructions_per_bundle(uint i) {
 214     _total_instructions_per_bundle[i]++;
 215   }
 216 
 217   static void increment_nop_size(uint s) {
 218     _total_nop_size += s;
 219   }
 220 
 221   static void increment_method_size(uint s) {
 222     _total_method_size += s;
 223   }
 224 #endif
 225 
 226 };
 227 
 228 
 229 PhaseOutput::PhaseOutput()
 230   : Phase(Phase::Output),
 231     _code_buffer(&quot;Compile::Fill_buffer&quot;),
 232     _first_block_size(0),
 233     _handler_table(),
 234     _inc_table(),
 235     _oop_map_set(NULL),
 236     _scratch_buffer_blob(NULL),
 237     _scratch_locs_memory(NULL),
 238     _scratch_const_size(-1),
 239     _in_scratch_emit_size(false),
 240     _frame_slots(0),
 241     _code_offsets(),
 242     _node_bundling_limit(0),
 243     _node_bundling_base(NULL),
 244     _orig_pc_slot(0),
 245     _orig_pc_slot_offset_in_bytes(0),
 246     _buf_sizes(),
 247     _block(NULL),
 248     _index(0) {
 249   C-&gt;set_output(this);
 250   if (C-&gt;stub_name() == NULL) {
 251     _orig_pc_slot = C-&gt;fixed_slots() - (sizeof(address) / VMRegImpl::stack_slot_size);
 252   }
 253 }
 254 
 255 PhaseOutput::~PhaseOutput() {
 256   C-&gt;set_output(NULL);
 257   if (_scratch_buffer_blob != NULL) {
 258     BufferBlob::free(_scratch_buffer_blob);
 259   }
 260 }
 261 
 262 void PhaseOutput::perform_mach_node_analysis() {
 263   // Late barrier analysis must be done after schedule and bundle
 264   // Otherwise liveness based spilling will fail
 265   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 266   bs-&gt;late_barrier_analysis();
 267 
 268   pd_perform_mach_node_analysis();
 269 }
 270 
 271 // Convert Nodes to instruction bits and pass off to the VM
 272 void PhaseOutput::Output() {
 273   // RootNode goes
 274   assert( C-&gt;cfg()-&gt;get_root_block()-&gt;number_of_nodes() == 0, &quot;&quot; );
 275 
 276   // The number of new nodes (mostly MachNop) is proportional to
 277   // the number of java calls and inner loops which are aligned.
 278   if ( C-&gt;check_node_count((NodeLimitFudgeFactor + C-&gt;java_calls()*3 +
 279                             C-&gt;inner_loops()*(OptoLoopAlignment-1)),
 280                            &quot;out of nodes before code generation&quot; ) ) {
 281     return;
 282   }
 283   // Make sure I can find the Start Node
 284   Block *entry = C-&gt;cfg()-&gt;get_block(1);
 285   Block *broot = C-&gt;cfg()-&gt;get_root_block();
 286 
 287   const StartNode *start = entry-&gt;head()-&gt;as_Start();
 288 
 289   // Replace StartNode with prolog
 290   MachPrologNode *prolog = new MachPrologNode();
 291   entry-&gt;map_node(prolog, 0);
 292   C-&gt;cfg()-&gt;map_node_to_block(prolog, entry);
 293   C-&gt;cfg()-&gt;unmap_node_from_block(start); // start is no longer in any block
 294 
 295   // Virtual methods need an unverified entry point
 296 
 297   if( C-&gt;is_osr_compilation() ) {
 298     if( PoisonOSREntry ) {
 299       // TODO: Should use a ShouldNotReachHereNode...
 300       C-&gt;cfg()-&gt;insert( broot, 0, new MachBreakpointNode() );
 301     }
 302   } else {
 303     if( C-&gt;method() &amp;&amp; !C-&gt;method()-&gt;flags().is_static() ) {
 304       // Insert unvalidated entry point
 305       C-&gt;cfg()-&gt;insert( broot, 0, new MachUEPNode() );
 306     }
 307 
 308   }
 309 
 310   // Break before main entry point
 311   if ((C-&gt;method() &amp;&amp; C-&gt;directive()-&gt;BreakAtExecuteOption) ||
 312       (OptoBreakpoint &amp;&amp; C-&gt;is_method_compilation())       ||
 313       (OptoBreakpointOSR &amp;&amp; C-&gt;is_osr_compilation())       ||
 314       (OptoBreakpointC2R &amp;&amp; !C-&gt;method())                   ) {
 315     // checking for C-&gt;method() means that OptoBreakpoint does not apply to
 316     // runtime stubs or frame converters
 317     C-&gt;cfg()-&gt;insert( entry, 1, new MachBreakpointNode() );
 318   }
 319 
 320   // Insert epilogs before every return
 321   for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {
 322     Block* block = C-&gt;cfg()-&gt;get_block(i);
 323     if (!block-&gt;is_connector() &amp;&amp; block-&gt;non_connector_successor(0) == C-&gt;cfg()-&gt;get_root_block()) { // Found a program exit point?
 324       Node* m = block-&gt;end();
 325       if (m-&gt;is_Mach() &amp;&amp; m-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Halt) {
 326         MachEpilogNode* epilog = new MachEpilogNode(m-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Return);
 327         block-&gt;add_inst(epilog);
 328         C-&gt;cfg()-&gt;map_node_to_block(epilog, block);
 329       }
 330     }
 331   }
 332 
 333   // Keeper of sizing aspects
 334   _buf_sizes = BufferSizingData();
 335 
 336   // Initialize code buffer
 337   estimate_buffer_size(_buf_sizes._const);
 338   if (C-&gt;failing()) return;
 339 
 340   // Pre-compute the length of blocks and replace
 341   // long branches with short if machine supports it.
 342   // Must be done before ScheduleAndBundle due to SPARC delay slots
 343   uint* blk_starts = NEW_RESOURCE_ARRAY(uint, C-&gt;cfg()-&gt;number_of_blocks() + 1);
 344   blk_starts[0] = 0;
 345   shorten_branches(blk_starts);
 346 
 347   ScheduleAndBundle();
 348   if (C-&gt;failing()) {
 349     return;
 350   }
 351 
 352   perform_mach_node_analysis();
 353 
 354   // Complete sizing of codebuffer
 355   CodeBuffer* cb = init_buffer();
 356   if (cb == NULL || C-&gt;failing()) {
 357     return;
 358   }
 359 
 360   BuildOopMaps();
 361 
 362   if (C-&gt;failing())  {
 363     return;
 364   }
 365 
 366   fill_buffer(cb, blk_starts);
 367 }
 368 
 369 bool PhaseOutput::need_stack_bang(int frame_size_in_bytes) const {
 370   // Determine if we need to generate a stack overflow check.
 371   // Do it if the method is not a stub function and
 372   // has java calls or has frame size &gt; vm_page_size/8.
 373   // The debug VM checks that deoptimization doesn&#39;t trigger an
 374   // unexpected stack overflow (compiled method stack banging should
 375   // guarantee it doesn&#39;t happen) so we always need the stack bang in
 376   // a debug VM.
 377   return (UseStackBanging &amp;&amp; C-&gt;stub_function() == NULL &amp;&amp;
 378           (C-&gt;has_java_calls() || frame_size_in_bytes &gt; os::vm_page_size()&gt;&gt;3
 379            DEBUG_ONLY(|| true)));
 380 }
 381 
 382 bool PhaseOutput::need_register_stack_bang() const {
 383   // Determine if we need to generate a register stack overflow check.
 384   // This is only used on architectures which have split register
 385   // and memory stacks (ie. IA64).
 386   // Bang if the method is not a stub function and has java calls
 387   return (C-&gt;stub_function() == NULL &amp;&amp; C-&gt;has_java_calls());
 388 }
 389 
 390 
 391 // Compute the size of first NumberOfLoopInstrToAlign instructions at the top
 392 // of a loop. When aligning a loop we need to provide enough instructions
 393 // in cpu&#39;s fetch buffer to feed decoders. The loop alignment could be
 394 // avoided if we have enough instructions in fetch buffer at the head of a loop.
 395 // By default, the size is set to 999999 by Block&#39;s constructor so that
 396 // a loop will be aligned if the size is not reset here.
 397 //
 398 // Note: Mach instructions could contain several HW instructions
 399 // so the size is estimated only.
 400 //
 401 void PhaseOutput::compute_loop_first_inst_sizes() {
 402   // The next condition is used to gate the loop alignment optimization.
 403   // Don&#39;t aligned a loop if there are enough instructions at the head of a loop
 404   // or alignment padding is larger then MaxLoopPad. By default, MaxLoopPad
 405   // is equal to OptoLoopAlignment-1 except on new Intel cpus, where it is
 406   // equal to 11 bytes which is the largest address NOP instruction.
 407   if (MaxLoopPad &lt; OptoLoopAlignment - 1) {
 408     uint last_block = C-&gt;cfg()-&gt;number_of_blocks() - 1;
 409     for (uint i = 1; i &lt;= last_block; i++) {
 410       Block* block = C-&gt;cfg()-&gt;get_block(i);
 411       // Check the first loop&#39;s block which requires an alignment.
 412       if (block-&gt;loop_alignment() &gt; (uint)relocInfo::addr_unit()) {
 413         uint sum_size = 0;
 414         uint inst_cnt = NumberOfLoopInstrToAlign;
 415         inst_cnt = block-&gt;compute_first_inst_size(sum_size, inst_cnt, C-&gt;regalloc());
 416 
 417         // Check subsequent fallthrough blocks if the loop&#39;s first
 418         // block(s) does not have enough instructions.
 419         Block *nb = block;
 420         while(inst_cnt &gt; 0 &amp;&amp;
 421               i &lt; last_block &amp;&amp;
 422               !C-&gt;cfg()-&gt;get_block(i + 1)-&gt;has_loop_alignment() &amp;&amp;
 423               !nb-&gt;has_successor(block)) {
 424           i++;
 425           nb = C-&gt;cfg()-&gt;get_block(i);
 426           inst_cnt  = nb-&gt;compute_first_inst_size(sum_size, inst_cnt, C-&gt;regalloc());
 427         } // while( inst_cnt &gt; 0 &amp;&amp; i &lt; last_block  )
 428 
 429         block-&gt;set_first_inst_size(sum_size);
 430       } // f( b-&gt;head()-&gt;is_Loop() )
 431     } // for( i &lt;= last_block )
 432   } // if( MaxLoopPad &lt; OptoLoopAlignment-1 )
 433 }
 434 
 435 // The architecture description provides short branch variants for some long
 436 // branch instructions. Replace eligible long branches with short branches.
 437 void PhaseOutput::shorten_branches(uint* blk_starts) {
 438   // Compute size of each block, method size, and relocation information size
 439   uint nblocks  = C-&gt;cfg()-&gt;number_of_blocks();
 440 
 441   uint*      jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
 442   uint*      jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
 443   int*       jmp_nidx   = NEW_RESOURCE_ARRAY(int ,nblocks);
 444 
 445   // Collect worst case block paddings
 446   int* block_worst_case_pad = NEW_RESOURCE_ARRAY(int, nblocks);
 447   memset(block_worst_case_pad, 0, nblocks * sizeof(int));
 448 
 449   DEBUG_ONLY( uint *jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks); )
 450   DEBUG_ONLY( uint *jmp_rule = NEW_RESOURCE_ARRAY(uint,nblocks); )
 451 
 452   bool has_short_branch_candidate = false;
 453 
 454   // Initialize the sizes to 0
 455   int code_size  = 0;          // Size in bytes of generated code
 456   int stub_size  = 0;          // Size in bytes of all stub entries
 457   // Size in bytes of all relocation entries, including those in local stubs.
 458   // Start with 2-bytes of reloc info for the unvalidated entry point
 459   int reloc_size = 1;          // Number of relocation entries
 460 
 461   // Make three passes.  The first computes pessimistic blk_starts,
 462   // relative jmp_offset and reloc_size information.  The second performs
 463   // short branch substitution using the pessimistic sizing.  The
 464   // third inserts nops where needed.
 465 
 466   // Step one, perform a pessimistic sizing pass.
 467   uint last_call_adr = max_juint;
 468   uint last_avoid_back_to_back_adr = max_juint;
 469   uint nop_size = (new MachNopNode())-&gt;size(C-&gt;regalloc());
 470   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
 471     Block* block = C-&gt;cfg()-&gt;get_block(i);
 472     _block = block;
 473 
 474     // During short branch replacement, we store the relative (to blk_starts)
 475     // offset of jump in jmp_offset, rather than the absolute offset of jump.
 476     // This is so that we do not need to recompute sizes of all nodes when
 477     // we compute correct blk_starts in our next sizing pass.
 478     jmp_offset[i] = 0;
 479     jmp_size[i]   = 0;
 480     jmp_nidx[i]   = -1;
 481     DEBUG_ONLY( jmp_target[i] = 0; )
 482     DEBUG_ONLY( jmp_rule[i]   = 0; )
 483 
 484     // Sum all instruction sizes to compute block size
 485     uint last_inst = block-&gt;number_of_nodes();
 486     uint blk_size = 0;
 487     for (uint j = 0; j &lt; last_inst; j++) {
 488       _index = j;
 489       Node* nj = block-&gt;get_node(_index);
 490       // Handle machine instruction nodes
 491       if (nj-&gt;is_Mach()) {
 492         MachNode* mach = nj-&gt;as_Mach();
 493         blk_size += (mach-&gt;alignment_required() - 1) * relocInfo::addr_unit(); // assume worst case padding
 494         reloc_size += mach-&gt;reloc();
 495         if (mach-&gt;is_MachCall()) {
 496           // add size information for trampoline stub
 497           // class CallStubImpl is platform-specific and defined in the *.ad files.
 498           stub_size  += CallStubImpl::size_call_trampoline();
 499           reloc_size += CallStubImpl::reloc_call_trampoline();
 500 
 501           MachCallNode *mcall = mach-&gt;as_MachCall();
 502           // This destination address is NOT PC-relative
 503 
 504           mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());
 505 
 506           if (mcall-&gt;is_MachCallJava() &amp;&amp; mcall-&gt;as_MachCallJava()-&gt;_method) {
 507             stub_size  += CompiledStaticCall::to_interp_stub_size();
 508             reloc_size += CompiledStaticCall::reloc_to_interp_stub();
 509 #if INCLUDE_AOT
 510             stub_size  += CompiledStaticCall::to_aot_stub_size();
 511             reloc_size += CompiledStaticCall::reloc_to_aot_stub();
 512 #endif
 513           }
 514         } else if (mach-&gt;is_MachSafePoint()) {
 515           // If call/safepoint are adjacent, account for possible
 516           // nop to disambiguate the two safepoints.
 517           // ScheduleAndBundle() can rearrange nodes in a block,
 518           // check for all offsets inside this block.
 519           if (last_call_adr &gt;= blk_starts[i]) {
 520             blk_size += nop_size;
 521           }
 522         }
 523         if (mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 524           // Nop is inserted between &quot;avoid back to back&quot; instructions.
 525           // ScheduleAndBundle() can rearrange nodes in a block,
 526           // check for all offsets inside this block.
 527           if (last_avoid_back_to_back_adr &gt;= blk_starts[i]) {
 528             blk_size += nop_size;
 529           }
 530         }
 531         if (mach-&gt;may_be_short_branch()) {
 532           if (!nj-&gt;is_MachBranch()) {
 533 #ifndef PRODUCT
 534             nj-&gt;dump(3);
 535 #endif
 536             Unimplemented();
 537           }
 538           assert(jmp_nidx[i] == -1, &quot;block should have only one branch&quot;);
 539           jmp_offset[i] = blk_size;
 540           jmp_size[i]   = nj-&gt;size(C-&gt;regalloc());
 541           jmp_nidx[i]   = j;
 542           has_short_branch_candidate = true;
 543         }
 544       }
 545       blk_size += nj-&gt;size(C-&gt;regalloc());
 546       // Remember end of call offset
 547       if (nj-&gt;is_MachCall() &amp;&amp; !nj-&gt;is_MachCallLeaf()) {
 548         last_call_adr = blk_starts[i]+blk_size;
 549       }
 550       // Remember end of avoid_back_to_back offset
 551       if (nj-&gt;is_Mach() &amp;&amp; nj-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
 552         last_avoid_back_to_back_adr = blk_starts[i]+blk_size;
 553       }
 554     }
 555 
 556     // When the next block starts a loop, we may insert pad NOP
 557     // instructions.  Since we cannot know our future alignment,
 558     // assume the worst.
 559     if (i &lt; nblocks - 1) {
 560       Block* nb = C-&gt;cfg()-&gt;get_block(i + 1);
 561       int max_loop_pad = nb-&gt;code_alignment()-relocInfo::addr_unit();
 562       if (max_loop_pad &gt; 0) {
 563         assert(is_power_of_2(max_loop_pad+relocInfo::addr_unit()), &quot;&quot;);
 564         // Adjust last_call_adr and/or last_avoid_back_to_back_adr.
 565         // If either is the last instruction in this block, bump by
 566         // max_loop_pad in lock-step with blk_size, so sizing
 567         // calculations in subsequent blocks still can conservatively
 568         // detect that it may the last instruction in this block.
 569         if (last_call_adr == blk_starts[i]+blk_size) {
 570           last_call_adr += max_loop_pad;
 571         }
 572         if (last_avoid_back_to_back_adr == blk_starts[i]+blk_size) {
 573           last_avoid_back_to_back_adr += max_loop_pad;
 574         }
 575         blk_size += max_loop_pad;
 576         block_worst_case_pad[i + 1] = max_loop_pad;
 577       }
 578     }
 579 
 580     // Save block size; update total method size
 581     blk_starts[i+1] = blk_starts[i]+blk_size;
 582   }
 583 
 584   // Step two, replace eligible long jumps.
 585   bool progress = true;
 586   uint last_may_be_short_branch_adr = max_juint;
 587   while (has_short_branch_candidate &amp;&amp; progress) {
 588     progress = false;
 589     has_short_branch_candidate = false;
 590     int adjust_block_start = 0;
 591     for (uint i = 0; i &lt; nblocks; i++) {
 592       Block* block = C-&gt;cfg()-&gt;get_block(i);
 593       int idx = jmp_nidx[i];
 594       MachNode* mach = (idx == -1) ? NULL: block-&gt;get_node(idx)-&gt;as_Mach();
 595       if (mach != NULL &amp;&amp; mach-&gt;may_be_short_branch()) {
 596 #ifdef ASSERT
 597         assert(jmp_size[i] &gt; 0 &amp;&amp; mach-&gt;is_MachBranch(), &quot;sanity&quot;);
 598         int j;
 599         // Find the branch; ignore trailing NOPs.
 600         for (j = block-&gt;number_of_nodes()-1; j&gt;=0; j--) {
 601           Node* n = block-&gt;get_node(j);
 602           if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con)
 603             break;
 604         }
 605         assert(j &gt;= 0 &amp;&amp; j == idx &amp;&amp; block-&gt;get_node(j) == (Node*)mach, &quot;sanity&quot;);
 606 #endif
 607         int br_size = jmp_size[i];
 608         int br_offs = blk_starts[i] + jmp_offset[i];
 609 
 610         // This requires the TRUE branch target be in succs[0]
 611         uint bnum = block-&gt;non_connector_successor(0)-&gt;_pre_order;
 612         int offset = blk_starts[bnum] - br_offs;
 613         if (bnum &gt; i) { // adjust following block&#39;s offset
 614           offset -= adjust_block_start;
 615         }
 616 
 617         // This block can be a loop header, account for the padding
 618         // in the previous block.
 619         int block_padding = block_worst_case_pad[i];
 620         assert(i == 0 || block_padding == 0 || br_offs &gt;= block_padding, &quot;Should have at least a padding on top&quot;);
 621         // In the following code a nop could be inserted before
 622         // the branch which will increase the backward distance.
 623         bool needs_padding = ((uint)(br_offs - block_padding) == last_may_be_short_branch_adr);
 624         assert(!needs_padding || jmp_offset[i] == 0, &quot;padding only branches at the beginning of block&quot;);
 625 
 626         if (needs_padding &amp;&amp; offset &lt;= 0)
 627           offset -= nop_size;
 628 
 629         if (C-&gt;matcher()-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {
 630           // We&#39;ve got a winner.  Replace this branch.
 631           MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
 632 
 633           // Update the jmp_size.
 634           int new_size = replacement-&gt;size(C-&gt;regalloc());
 635           int diff     = br_size - new_size;
 636           assert(diff &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
 637           // Conservatively take into account padding between
 638           // avoid_back_to_back branches. Previous branch could be
 639           // converted into avoid_back_to_back branch during next
 640           // rounds.
 641           if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 642             jmp_offset[i] += nop_size;
 643             diff -= nop_size;
 644           }
 645           adjust_block_start += diff;
 646           block-&gt;map_node(replacement, idx);
 647           mach-&gt;subsume_by(replacement, C);
 648           mach = replacement;
 649           progress = true;
 650 
 651           jmp_size[i] = new_size;
 652           DEBUG_ONLY( jmp_target[i] = bnum; );
 653           DEBUG_ONLY( jmp_rule[i] = mach-&gt;rule(); );
 654         } else {
 655           // The jump distance is not short, try again during next iteration.
 656           has_short_branch_candidate = true;
 657         }
 658       } // (mach-&gt;may_be_short_branch())
 659       if (mach != NULL &amp;&amp; (mach-&gt;may_be_short_branch() ||
 660                            mach-&gt;avoid_back_to_back(MachNode::AVOID_AFTER))) {
 661         last_may_be_short_branch_adr = blk_starts[i] + jmp_offset[i] + jmp_size[i];
 662       }
 663       blk_starts[i+1] -= adjust_block_start;
 664     }
 665   }
 666 
 667 #ifdef ASSERT
 668   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
 669     if (jmp_target[i] != 0) {
 670       int br_size = jmp_size[i];
 671       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
 672       if (!C-&gt;matcher()-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {
 673         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
 674       }
 675       assert(C-&gt;matcher()-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset), &quot;Displacement too large for short jmp&quot;);
 676     }
 677   }
 678 #endif
 679 
 680   // Step 3, compute the offsets of all blocks, will be done in fill_buffer()
 681   // after ScheduleAndBundle().
 682 
 683   // ------------------
 684   // Compute size for code buffer
 685   code_size = blk_starts[nblocks];
 686 
 687   // Relocation records
 688   reloc_size += 1;              // Relo entry for exception handler
 689 
 690   // Adjust reloc_size to number of record of relocation info
 691   // Min is 2 bytes, max is probably 6 or 8, with a tax up to 25% for
 692   // a relocation index.
 693   // The CodeBuffer will expand the locs array if this estimate is too low.
 694   reloc_size *= 10 / sizeof(relocInfo);
 695 
 696   _buf_sizes._reloc = reloc_size;
 697   _buf_sizes._code  = code_size;
 698   _buf_sizes._stub  = stub_size;
 699 }
 700 
 701 //------------------------------FillLocArray-----------------------------------
 702 // Create a bit of debug info and append it to the array.  The mapping is from
 703 // Java local or expression stack to constant, register or stack-slot.  For
 704 // doubles, insert 2 mappings and return 1 (to tell the caller that the next
 705 // entry has been taken care of and caller should skip it).
 706 static LocationValue *new_loc_value( PhaseRegAlloc *ra, OptoReg::Name regnum, Location::Type l_type ) {
 707   // This should never have accepted Bad before
 708   assert(OptoReg::is_valid(regnum), &quot;location must be valid&quot;);
 709   return (OptoReg::is_reg(regnum))
 710          ? new LocationValue(Location::new_reg_loc(l_type, OptoReg::as_VMReg(regnum)) )
 711          : new LocationValue(Location::new_stk_loc(l_type,  ra-&gt;reg2offset(regnum)));
 712 }
 713 
 714 
 715 ObjectValue*
 716 PhaseOutput::sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id) {
 717   for (int i = 0; i &lt; objs-&gt;length(); i++) {
 718     assert(objs-&gt;at(i)-&gt;is_object(), &quot;corrupt object cache&quot;);
 719     ObjectValue* sv = (ObjectValue*) objs-&gt;at(i);
 720     if (sv-&gt;id() == id) {
 721       return sv;
 722     }
 723   }
 724   // Otherwise..
 725   return NULL;
 726 }
 727 
 728 void PhaseOutput::set_sv_for_object_node(GrowableArray&lt;ScopeValue*&gt; *objs,
 729                                      ObjectValue* sv ) {
 730   assert(sv_for_node_id(objs, sv-&gt;id()) == NULL, &quot;Precondition&quot;);
 731   objs-&gt;append(sv);
 732 }
 733 
 734 
 735 void PhaseOutput::FillLocArray( int idx, MachSafePointNode* sfpt, Node *local,
 736                             GrowableArray&lt;ScopeValue*&gt; *array,
 737                             GrowableArray&lt;ScopeValue*&gt; *objs ) {
 738   assert( local, &quot;use _top instead of null&quot; );
 739   if (array-&gt;length() != idx) {
 740     assert(array-&gt;length() == idx + 1, &quot;Unexpected array count&quot;);
 741     // Old functionality:
 742     //   return
 743     // New functionality:
 744     //   Assert if the local is not top. In product mode let the new node
 745     //   override the old entry.
 746     assert(local == C-&gt;top(), &quot;LocArray collision&quot;);
 747     if (local == C-&gt;top()) {
 748       return;
 749     }
 750     array-&gt;pop();
 751   }
 752   const Type *t = local-&gt;bottom_type();
 753 
 754   // Is it a safepoint scalar object node?
 755   if (local-&gt;is_SafePointScalarObject()) {
 756     SafePointScalarObjectNode* spobj = local-&gt;as_SafePointScalarObject();
 757 
 758     ObjectValue* sv = sv_for_node_id(objs, spobj-&gt;_idx);
 759     if (sv == NULL) {
 760       ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
 761       assert(cik-&gt;is_instance_klass() ||
 762              cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 763       sv = new ObjectValue(spobj-&gt;_idx,
 764                            new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
 765       set_sv_for_object_node(objs, sv);
 766 
 767       uint first_ind = spobj-&gt;first_index(sfpt-&gt;jvms());
 768       for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
 769         Node* fld_node = sfpt-&gt;in(first_ind+i);
 770         (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfpt, fld_node, sv-&gt;field_values(), objs);
 771       }
 772     }
 773     array-&gt;append(sv);
 774     return;
 775   }
 776 
 777   // Grab the register number for the local
 778   OptoReg::Name regnum = C-&gt;regalloc()-&gt;get_reg_first(local);
 779   if( OptoReg::is_valid(regnum) ) {// Got a register/stack?
 780     // Record the double as two float registers.
 781     // The register mask for such a value always specifies two adjacent
 782     // float registers, with the lower register number even.
 783     // Normally, the allocation of high and low words to these registers
 784     // is irrelevant, because nearly all operations on register pairs
 785     // (e.g., StoreD) treat them as a single unit.
 786     // Here, we assume in addition that the words in these two registers
 787     // stored &quot;naturally&quot; (by operations like StoreD and double stores
 788     // within the interpreter) such that the lower-numbered register
 789     // is written to the lower memory address.  This may seem like
 790     // a machine dependency, but it is not--it is a requirement on
 791     // the author of the &lt;arch&gt;.ad file to ensure that, for every
 792     // even/odd double-register pair to which a double may be allocated,
 793     // the word in the even single-register is stored to the first
 794     // memory word.  (Note that register numbers are completely
 795     // arbitrary, and are not tied to any machine-level encodings.)
 796 #ifdef _LP64
 797     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon ) {
 798       array-&gt;append(new ConstantIntValue((jint)0));
 799       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Location::dbl ));
 800     } else if ( t-&gt;base() == Type::Long ) {
 801       array-&gt;append(new ConstantIntValue((jint)0));
 802       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Location::lng ));
 803     } else if ( t-&gt;base() == Type::RawPtr ) {
 804       // jsr/ret return address which must be restored into a the full
 805       // width 64-bit stack slot.
 806       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Location::lng ));
 807     }
 808 #else //_LP64
 809     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon || t-&gt;base() == Type::Long ) {
 810       // Repack the double/long as two jints.
 811       // The convention the interpreter uses is that the second local
 812       // holds the first raw word of the native double representation.
 813       // This is actually reasonable, since locals and stack arrays
 814       // grow downwards in all implementations.
 815       // (If, on some machine, the interpreter&#39;s Java locals or stack
 816       // were to grow upwards, the embedded doubles would be word-swapped.)
 817       array-&gt;append(new_loc_value( C-&gt;regalloc(), OptoReg::add(regnum,1), Location::normal ));
 818       array-&gt;append(new_loc_value( C-&gt;regalloc(),              regnum   , Location::normal ));
 819     }
 820 #endif //_LP64
 821     else if( (t-&gt;base() == Type::FloatBot || t-&gt;base() == Type::FloatCon) &amp;&amp;
 822              OptoReg::is_reg(regnum) ) {
 823       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Matcher::float_in_double()
 824                                                       ? Location::float_in_dbl : Location::normal ));
 825     } else if( t-&gt;base() == Type::Int &amp;&amp; OptoReg::is_reg(regnum) ) {
 826       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Matcher::int_in_long
 827                                                       ? Location::int_in_long : Location::normal ));
 828     } else if( t-&gt;base() == Type::NarrowOop ) {
 829       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Location::narrowoop ));
 830     } else {
 831       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, C-&gt;regalloc()-&gt;is_oop(local) ? Location::oop : Location::normal ));
 832     }
 833     return;
 834   }
 835 
 836   // No register.  It must be constant data.
 837   switch (t-&gt;base()) {
 838     case Type::Half:              // Second half of a double
 839       ShouldNotReachHere();       // Caller should skip 2nd halves
 840       break;
 841     case Type::AnyPtr:
 842       array-&gt;append(new ConstantOopWriteValue(NULL));
 843       break;
 844     case Type::AryPtr:
 845     case Type::InstPtr:          // fall through
 846       array-&gt;append(new ConstantOopWriteValue(t-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));
 847       break;
 848     case Type::NarrowOop:
 849       if (t == TypeNarrowOop::NULL_PTR) {
 850         array-&gt;append(new ConstantOopWriteValue(NULL));
 851       } else {
 852         array-&gt;append(new ConstantOopWriteValue(t-&gt;make_ptr()-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));
 853       }
 854       break;
 855     case Type::Int:
 856       array-&gt;append(new ConstantIntValue(t-&gt;is_int()-&gt;get_con()));
 857       break;
 858     case Type::RawPtr:
 859       // A return address (T_ADDRESS).
 860       assert((intptr_t)t-&gt;is_ptr()-&gt;get_con() &lt; (intptr_t)0x10000, &quot;must be a valid BCI&quot;);
 861 #ifdef _LP64
 862       // Must be restored to the full-width 64-bit stack slot.
 863       array-&gt;append(new ConstantLongValue(t-&gt;is_ptr()-&gt;get_con()));
 864 #else
 865       array-&gt;append(new ConstantIntValue(t-&gt;is_ptr()-&gt;get_con()));
 866 #endif
 867       break;
 868     case Type::FloatCon: {
 869       float f = t-&gt;is_float_constant()-&gt;getf();
 870       array-&gt;append(new ConstantIntValue(jint_cast(f)));
 871       break;
 872     }
 873     case Type::DoubleCon: {
 874       jdouble d = t-&gt;is_double_constant()-&gt;getd();
 875 #ifdef _LP64
 876       array-&gt;append(new ConstantIntValue((jint)0));
 877       array-&gt;append(new ConstantDoubleValue(d));
 878 #else
 879       // Repack the double as two jints.
 880     // The convention the interpreter uses is that the second local
 881     // holds the first raw word of the native double representation.
 882     // This is actually reasonable, since locals and stack arrays
 883     // grow downwards in all implementations.
 884     // (If, on some machine, the interpreter&#39;s Java locals or stack
 885     // were to grow upwards, the embedded doubles would be word-swapped.)
 886     jlong_accessor acc;
 887     acc.long_value = jlong_cast(d);
 888     array-&gt;append(new ConstantIntValue(acc.words[1]));
 889     array-&gt;append(new ConstantIntValue(acc.words[0]));
 890 #endif
 891       break;
 892     }
 893     case Type::Long: {
 894       jlong d = t-&gt;is_long()-&gt;get_con();
 895 #ifdef _LP64
 896       array-&gt;append(new ConstantIntValue((jint)0));
 897       array-&gt;append(new ConstantLongValue(d));
 898 #else
 899       // Repack the long as two jints.
 900     // The convention the interpreter uses is that the second local
 901     // holds the first raw word of the native double representation.
 902     // This is actually reasonable, since locals and stack arrays
 903     // grow downwards in all implementations.
 904     // (If, on some machine, the interpreter&#39;s Java locals or stack
 905     // were to grow upwards, the embedded doubles would be word-swapped.)
 906     jlong_accessor acc;
 907     acc.long_value = d;
 908     array-&gt;append(new ConstantIntValue(acc.words[1]));
 909     array-&gt;append(new ConstantIntValue(acc.words[0]));
 910 #endif
 911       break;
 912     }
 913     case Type::Top:               // Add an illegal value here
 914       array-&gt;append(new LocationValue(Location()));
 915       break;
 916     default:
 917       ShouldNotReachHere();
 918       break;
 919   }
 920 }
 921 
 922 // Determine if this node starts a bundle
 923 bool PhaseOutput::starts_bundle(const Node *n) const {
 924   return (_node_bundling_limit &gt; n-&gt;_idx &amp;&amp;
 925           _node_bundling_base[n-&gt;_idx].starts_bundle());
 926 }
 927 
 928 //--------------------------Process_OopMap_Node--------------------------------
 929 void PhaseOutput::Process_OopMap_Node(MachNode *mach, int current_offset) {
 930   // Handle special safepoint nodes for synchronization
 931   MachSafePointNode *sfn   = mach-&gt;as_MachSafePoint();
 932   MachCallNode      *mcall;
 933 
 934   int safepoint_pc_offset = current_offset;
 935   bool is_method_handle_invoke = false;
 936   bool return_oop = false;
 937 
 938   // Add the safepoint in the DebugInfoRecorder
 939   if( !mach-&gt;is_MachCall() ) {
 940     mcall = NULL;
 941     C-&gt;debug_info()-&gt;add_safepoint(safepoint_pc_offset, sfn-&gt;_oop_map);
 942   } else {
 943     mcall = mach-&gt;as_MachCall();
 944 
 945     // Is the call a MethodHandle call?
 946     if (mcall-&gt;is_MachCallJava()) {
 947       if (mcall-&gt;as_MachCallJava()-&gt;_method_handle_invoke) {
 948         assert(C-&gt;has_method_handle_invokes(), &quot;must have been set during call generation&quot;);
 949         is_method_handle_invoke = true;
 950       }
 951     }
 952 
 953     // Check if a call returns an object.
 954     if (mcall-&gt;returns_pointer()) {
 955       return_oop = true;
 956     }
 957     safepoint_pc_offset += mcall-&gt;ret_addr_offset();
 958     C-&gt;debug_info()-&gt;add_safepoint(safepoint_pc_offset, mcall-&gt;_oop_map);
 959   }
 960 
 961   // Loop over the JVMState list to add scope information
 962   // Do not skip safepoints with a NULL method, they need monitor info
 963   JVMState* youngest_jvms = sfn-&gt;jvms();
 964   int max_depth = youngest_jvms-&gt;depth();
 965 
 966   // Allocate the object pool for scalar-replaced objects -- the map from
 967   // small-integer keys (which can be recorded in the local and ostack
 968   // arrays) to descriptions of the object state.
 969   GrowableArray&lt;ScopeValue*&gt; *objs = new GrowableArray&lt;ScopeValue*&gt;();
 970 
 971   // Visit scopes from oldest to youngest.
 972   for (int depth = 1; depth &lt;= max_depth; depth++) {
 973     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
 974     int idx;
 975     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
 976     // Safepoints that do not have method() set only provide oop-map and monitor info
 977     // to support GC; these do not support deoptimization.
 978     int num_locs = (method == NULL) ? 0 : jvms-&gt;loc_size();
 979     int num_exps = (method == NULL) ? 0 : jvms-&gt;stk_size();
 980     int num_mon  = jvms-&gt;nof_monitors();
 981     assert(method == NULL || jvms-&gt;bci() &lt; 0 || num_locs == method-&gt;max_locals(),
 982            &quot;JVMS local count must match that of the method&quot;);
 983 
 984     // Add Local and Expression Stack Information
 985 
 986     // Insert locals into the locarray
 987     GrowableArray&lt;ScopeValue*&gt; *locarray = new GrowableArray&lt;ScopeValue*&gt;(num_locs);
 988     for( idx = 0; idx &lt; num_locs; idx++ ) {
 989       FillLocArray( idx, sfn, sfn-&gt;local(jvms, idx), locarray, objs );
 990     }
 991 
 992     // Insert expression stack entries into the exparray
 993     GrowableArray&lt;ScopeValue*&gt; *exparray = new GrowableArray&lt;ScopeValue*&gt;(num_exps);
 994     for( idx = 0; idx &lt; num_exps; idx++ ) {
 995       FillLocArray( idx,  sfn, sfn-&gt;stack(jvms, idx), exparray, objs );
 996     }
 997 
 998     // Add in mappings of the monitors
 999     assert( !method ||
1000             !method-&gt;is_synchronized() ||
1001             method-&gt;is_native() ||
1002             num_mon &gt; 0 ||
1003             !GenerateSynchronizationCode,
1004             &quot;monitors must always exist for synchronized methods&quot;);
1005 
1006     // Build the growable array of ScopeValues for exp stack
1007     GrowableArray&lt;MonitorValue*&gt; *monarray = new GrowableArray&lt;MonitorValue*&gt;(num_mon);
1008 
1009     // Loop over monitors and insert into array
1010     for (idx = 0; idx &lt; num_mon; idx++) {
1011       // Grab the node that defines this monitor
1012       Node* box_node = sfn-&gt;monitor_box(jvms, idx);
1013       Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
1014 
1015       // Create ScopeValue for object
1016       ScopeValue *scval = NULL;
1017 
1018       if (obj_node-&gt;is_SafePointScalarObject()) {
1019         SafePointScalarObjectNode* spobj = obj_node-&gt;as_SafePointScalarObject();
1020         scval = PhaseOutput::sv_for_node_id(objs, spobj-&gt;_idx);
1021         if (scval == NULL) {
1022           const Type *t = spobj-&gt;bottom_type();
1023           ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
1024           assert(cik-&gt;is_instance_klass() ||
1025                  cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
1026           ObjectValue* sv = new ObjectValue(spobj-&gt;_idx,
1027                                             new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
1028           PhaseOutput::set_sv_for_object_node(objs, sv);
1029 
1030           uint first_ind = spobj-&gt;first_index(youngest_jvms);
1031           for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
1032             Node* fld_node = sfn-&gt;in(first_ind+i);
1033             (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfn, fld_node, sv-&gt;field_values(), objs);
1034           }
1035           scval = sv;
1036         }
1037       } else if (!obj_node-&gt;is_Con()) {
1038         OptoReg::Name obj_reg = C-&gt;regalloc()-&gt;get_reg_first(obj_node);
1039         if( obj_node-&gt;bottom_type()-&gt;base() == Type::NarrowOop ) {
1040           scval = new_loc_value( C-&gt;regalloc(), obj_reg, Location::narrowoop );
1041         } else {
1042           scval = new_loc_value( C-&gt;regalloc(), obj_reg, Location::oop );
1043         }
1044       } else {
1045         const TypePtr *tp = obj_node-&gt;get_ptr_type();
1046         scval = new ConstantOopWriteValue(tp-&gt;is_oopptr()-&gt;const_oop()-&gt;constant_encoding());
1047       }
1048 
1049       OptoReg::Name box_reg = BoxLockNode::reg(box_node);
1050       Location basic_lock = Location::new_stk_loc(Location::normal,C-&gt;regalloc()-&gt;reg2offset(box_reg));
1051       bool eliminated = (box_node-&gt;is_BoxLock() &amp;&amp; box_node-&gt;as_BoxLock()-&gt;is_eliminated());
1052       monarray-&gt;append(new MonitorValue(scval, basic_lock, eliminated));
1053     }
1054 
1055     // We dump the object pool first, since deoptimization reads it in first.
1056     C-&gt;debug_info()-&gt;dump_object_pool(objs);
1057 
1058     // Build first class objects to pass to scope
1059     DebugToken *locvals = C-&gt;debug_info()-&gt;create_scope_values(locarray);
1060     DebugToken *expvals = C-&gt;debug_info()-&gt;create_scope_values(exparray);
1061     DebugToken *monvals = C-&gt;debug_info()-&gt;create_monitor_values(monarray);
1062 
1063     // Make method available for all Safepoints
1064     ciMethod* scope_method = method ? method : C-&gt;method();
1065     // Describe the scope here
1066     assert(jvms-&gt;bci() &gt;= InvocationEntryBci &amp;&amp; jvms-&gt;bci() &lt;= 0x10000, &quot;must be a valid or entry BCI&quot;);
1067     assert(!jvms-&gt;should_reexecute() || depth == max_depth, &quot;reexecute allowed only for the youngest&quot;);
1068     // Now we can describe the scope.
1069     methodHandle null_mh;
1070     bool rethrow_exception = false;
<a name="1" id="anc1"></a><span class="line-modified">1071     C-&gt;debug_info()-&gt;describe_scope(</span>
<span class="line-added">1072       safepoint_pc_offset,</span>
<span class="line-added">1073       null_mh,</span>
<span class="line-added">1074       scope_method,</span>
<span class="line-added">1075       jvms-&gt;bci(),</span>
<span class="line-added">1076       jvms-&gt;should_reexecute(),</span>
<span class="line-added">1077       rethrow_exception,</span>
<span class="line-added">1078       is_method_handle_invoke,</span>
<span class="line-added">1079       mach-&gt;is_MachCallNative(),</span>
<span class="line-added">1080       return_oop,</span>
<span class="line-added">1081       locvals,</span>
<span class="line-added">1082       expvals,</span>
<span class="line-added">1083       monvals</span>
<span class="line-added">1084     );</span>
1085   } // End jvms loop
1086 
1087   // Mark the end of the scope set.
1088   C-&gt;debug_info()-&gt;end_safepoint(safepoint_pc_offset);
1089 }
1090 
1091 
1092 
1093 // A simplified version of Process_OopMap_Node, to handle non-safepoints.
1094 class NonSafepointEmitter {
1095     Compile*  C;
1096     JVMState* _pending_jvms;
1097     int       _pending_offset;
1098 
1099     void emit_non_safepoint();
1100 
1101  public:
1102     NonSafepointEmitter(Compile* compile) {
1103       this-&gt;C = compile;
1104       _pending_jvms = NULL;
1105       _pending_offset = 0;
1106     }
1107 
1108     void observe_instruction(Node* n, int pc_offset) {
1109       if (!C-&gt;debug_info()-&gt;recording_non_safepoints())  return;
1110 
1111       Node_Notes* nn = C-&gt;node_notes_at(n-&gt;_idx);
1112       if (nn == NULL || nn-&gt;jvms() == NULL)  return;
1113       if (_pending_jvms != NULL &amp;&amp;
1114           _pending_jvms-&gt;same_calls_as(nn-&gt;jvms())) {
1115         // Repeated JVMS?  Stretch it up here.
1116         _pending_offset = pc_offset;
1117       } else {
1118         if (_pending_jvms != NULL &amp;&amp;
1119             _pending_offset &lt; pc_offset) {
1120           emit_non_safepoint();
1121         }
1122         _pending_jvms = NULL;
1123         if (pc_offset &gt; C-&gt;debug_info()-&gt;last_pc_offset()) {
1124           // This is the only way _pending_jvms can become non-NULL:
1125           _pending_jvms = nn-&gt;jvms();
1126           _pending_offset = pc_offset;
1127         }
1128       }
1129     }
1130 
1131     // Stay out of the way of real safepoints:
1132     void observe_safepoint(JVMState* jvms, int pc_offset) {
1133       if (_pending_jvms != NULL &amp;&amp;
1134           !_pending_jvms-&gt;same_calls_as(jvms) &amp;&amp;
1135           _pending_offset &lt; pc_offset) {
1136         emit_non_safepoint();
1137       }
1138       _pending_jvms = NULL;
1139     }
1140 
1141     void flush_at_end() {
1142       if (_pending_jvms != NULL) {
1143         emit_non_safepoint();
1144       }
1145       _pending_jvms = NULL;
1146     }
1147 };
1148 
1149 void NonSafepointEmitter::emit_non_safepoint() {
1150   JVMState* youngest_jvms = _pending_jvms;
1151   int       pc_offset     = _pending_offset;
1152 
1153   // Clear it now:
1154   _pending_jvms = NULL;
1155 
1156   DebugInformationRecorder* debug_info = C-&gt;debug_info();
1157   assert(debug_info-&gt;recording_non_safepoints(), &quot;sanity&quot;);
1158 
1159   debug_info-&gt;add_non_safepoint(pc_offset);
1160   int max_depth = youngest_jvms-&gt;depth();
1161 
1162   // Visit scopes from oldest to youngest.
1163   for (int depth = 1; depth &lt;= max_depth; depth++) {
1164     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
1165     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
1166     assert(!jvms-&gt;should_reexecute() || depth==max_depth, &quot;reexecute allowed only for the youngest&quot;);
1167     methodHandle null_mh;
1168     debug_info-&gt;describe_scope(pc_offset, null_mh, method, jvms-&gt;bci(), jvms-&gt;should_reexecute());
1169   }
1170 
1171   // Mark the end of the scope set.
1172   debug_info-&gt;end_non_safepoint(pc_offset);
1173 }
1174 
1175 //------------------------------init_buffer------------------------------------
1176 void PhaseOutput::estimate_buffer_size(int&amp; const_req) {
1177 
1178   // Set the initially allocated size
1179   const_req = initial_const_capacity;
1180 
1181   // The extra spacing after the code is necessary on some platforms.
1182   // Sometimes we need to patch in a jump after the last instruction,
1183   // if the nmethod has been deoptimized.  (See 4932387, 4894843.)
1184 
1185   // Compute the byte offset where we can store the deopt pc.
1186   if (C-&gt;fixed_slots() != 0) {
1187     _orig_pc_slot_offset_in_bytes = C-&gt;regalloc()-&gt;reg2offset(OptoReg::stack2reg(_orig_pc_slot));
1188   }
1189 
1190   // Compute prolog code size
1191   _method_size = 0;
1192   _frame_slots = OptoReg::reg2stack(C-&gt;matcher()-&gt;_old_SP) + C-&gt;regalloc()-&gt;_framesize;
1193 #if defined(IA64) &amp;&amp; !defined(AIX)
1194   if (save_argument_registers()) {
1195     // 4815101: this is a stub with implicit and unknown precision fp args.
1196     // The usual spill mechanism can only generate stfd&#39;s in this case, which
1197     // doesn&#39;t work if the fp reg to spill contains a single-precision denorm.
1198     // Instead, we hack around the normal spill mechanism using stfspill&#39;s and
1199     // ldffill&#39;s in the MachProlog and MachEpilog emit methods.  We allocate
1200     // space here for the fp arg regs (f8-f15) we&#39;re going to thusly spill.
1201     //
1202     // If we ever implement 16-byte &#39;registers&#39; == stack slots, we can
1203     // get rid of this hack and have SpillCopy generate stfspill/ldffill
1204     // instead of stfd/stfs/ldfd/ldfs.
1205     _frame_slots += 8*(16/BytesPerInt);
1206   }
1207 #endif
1208   assert(_frame_slots &gt;= 0 &amp;&amp; _frame_slots &lt; 1000000, &quot;sanity check&quot;);
1209 
1210   if (C-&gt;has_mach_constant_base_node()) {
1211     uint add_size = 0;
1212     // Fill the constant table.
1213     // Note:  This must happen before shorten_branches.
1214     for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {
1215       Block* b = C-&gt;cfg()-&gt;get_block(i);
1216 
1217       for (uint j = 0; j &lt; b-&gt;number_of_nodes(); j++) {
1218         Node* n = b-&gt;get_node(j);
1219 
1220         // If the node is a MachConstantNode evaluate the constant
1221         // value section.
1222         if (n-&gt;is_MachConstant()) {
1223           MachConstantNode* machcon = n-&gt;as_MachConstant();
1224           machcon-&gt;eval_constant(C);
1225         } else if (n-&gt;is_Mach()) {
1226           // On Power there are more nodes that issue constants.
1227           add_size += (n-&gt;as_Mach()-&gt;ins_num_consts() * 8);
1228         }
1229       }
1230     }
1231 
1232     // Calculate the offsets of the constants and the size of the
1233     // constant table (including the padding to the next section).
1234     constant_table().calculate_offsets_and_size();
1235     const_req = constant_table().size() + add_size;
1236   }
1237 
1238   // Initialize the space for the BufferBlob used to find and verify
1239   // instruction size in MachNode::emit_size()
1240   init_scratch_buffer_blob(const_req);
1241 }
1242 
1243 CodeBuffer* PhaseOutput::init_buffer() {
1244   int stub_req  = _buf_sizes._stub;
1245   int code_req  = _buf_sizes._code;
1246   int const_req = _buf_sizes._const;
1247 
1248   int pad_req   = NativeCall::instruction_size;
1249 
1250   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1251   stub_req += bs-&gt;estimate_stub_size();
1252 
1253   // nmethod and CodeBuffer count stubs &amp; constants as part of method&#39;s code.
1254   // class HandlerImpl is platform-specific and defined in the *.ad files.
1255   int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; // add marginal slop for handler
1256   int deopt_handler_req     = HandlerImpl::size_deopt_handler()     + MAX_stubs_size; // add marginal slop for handler
1257   stub_req += MAX_stubs_size;   // ensure per-stub margin
1258   code_req += MAX_inst_size;    // ensure per-instruction margin
1259 
1260   if (StressCodeBuffers)
1261     code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  // force expansion
1262 
1263   int total_req =
1264           const_req +
1265           code_req +
1266           pad_req +
1267           stub_req +
1268           exception_handler_req +
1269           deopt_handler_req;               // deopt handler
1270 
1271   if (C-&gt;has_method_handle_invokes())
1272     total_req += deopt_handler_req;  // deopt MH handler
1273 
1274   CodeBuffer* cb = code_buffer();
1275   cb-&gt;initialize(total_req, _buf_sizes._reloc);
1276 
1277   // Have we run out of code space?
1278   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1279     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1280     return NULL;
1281   }
1282   // Configure the code buffer.
1283   cb-&gt;initialize_consts_size(const_req);
1284   cb-&gt;initialize_stubs_size(stub_req);
1285   cb-&gt;initialize_oop_recorder(C-&gt;env()-&gt;oop_recorder());
1286 
1287   // fill in the nop array for bundling computations
1288   MachNode *_nop_list[Bundle::_nop_count];
1289   Bundle::initialize_nops(_nop_list);
1290 
1291   return cb;
1292 }
1293 
1294 //------------------------------fill_buffer------------------------------------
1295 void PhaseOutput::fill_buffer(CodeBuffer* cb, uint* blk_starts) {
1296   // blk_starts[] contains offsets calculated during short branches processing,
1297   // offsets should not be increased during following steps.
1298 
1299   // Compute the size of first NumberOfLoopInstrToAlign instructions at head
1300   // of a loop. It is used to determine the padding for loop alignment.
1301   compute_loop_first_inst_sizes();
1302 
1303   // Create oopmap set.
1304   _oop_map_set = new OopMapSet();
1305 
1306   // !!!!! This preserves old handling of oopmaps for now
1307   C-&gt;debug_info()-&gt;set_oopmaps(_oop_map_set);
1308 
1309   uint nblocks  = C-&gt;cfg()-&gt;number_of_blocks();
1310   // Count and start of implicit null check instructions
1311   uint inct_cnt = 0;
1312   uint *inct_starts = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1313 
1314   // Count and start of calls
1315   uint *call_returns = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1316 
1317   uint  return_offset = 0;
1318   int nop_size = (new MachNopNode())-&gt;size(C-&gt;regalloc());
1319 
1320   int previous_offset = 0;
1321   int current_offset  = 0;
1322   int last_call_offset = -1;
1323   int last_avoid_back_to_back_offset = -1;
1324 #ifdef ASSERT
1325   uint* jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks);
1326   uint* jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
1327   uint* jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
1328   uint* jmp_rule   = NEW_RESOURCE_ARRAY(uint,nblocks);
1329 #endif
1330 
1331   // Create an array of unused labels, one for each basic block, if printing is enabled
1332 #if defined(SUPPORT_OPTO_ASSEMBLY)
1333   int *node_offsets      = NULL;
1334   uint node_offset_limit = C-&gt;unique();
1335 
1336   if (C-&gt;print_assembly()) {
1337     node_offsets = NEW_RESOURCE_ARRAY(int, node_offset_limit);
1338   }
1339   if (node_offsets != NULL) {
1340     // We need to initialize. Unused array elements may contain garbage and mess up PrintOptoAssembly.
1341     memset(node_offsets, 0, node_offset_limit*sizeof(int));
1342   }
1343 #endif
1344 
1345   NonSafepointEmitter non_safepoints(C);  // emit non-safepoints lazily
1346 
1347   // Emit the constant table.
1348   if (C-&gt;has_mach_constant_base_node()) {
1349     constant_table().emit(*cb);
1350   }
1351 
1352   // Create an array of labels, one for each basic block
1353   Label *blk_labels = NEW_RESOURCE_ARRAY(Label, nblocks+1);
1354   for (uint i=0; i &lt;= nblocks; i++) {
1355     blk_labels[i].init();
1356   }
1357 
1358   // ------------------
1359   // Now fill in the code buffer
1360   Node *delay_slot = NULL;
1361 
1362   for (uint i = 0; i &lt; nblocks; i++) {
1363     Block* block = C-&gt;cfg()-&gt;get_block(i);
1364     _block = block;
1365     Node* head = block-&gt;head();
1366 
1367     // If this block needs to start aligned (i.e, can be reached other
1368     // than by falling-thru from the previous block), then force the
1369     // start of a new bundle.
1370     if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(head)) {
1371       cb-&gt;flush_bundle(true);
1372     }
1373 
1374 #ifdef ASSERT
1375     if (!block-&gt;is_connector()) {
1376       stringStream st;
1377       block-&gt;dump_head(C-&gt;cfg(), &amp;st);
1378       MacroAssembler(cb).block_comment(st.as_string());
1379     }
1380     jmp_target[i] = 0;
1381     jmp_offset[i] = 0;
1382     jmp_size[i]   = 0;
1383     jmp_rule[i]   = 0;
1384 #endif
1385     int blk_offset = current_offset;
1386 
1387     // Define the label at the beginning of the basic block
1388     MacroAssembler(cb).bind(blk_labels[block-&gt;_pre_order]);
1389 
1390     uint last_inst = block-&gt;number_of_nodes();
1391 
1392     // Emit block normally, except for last instruction.
1393     // Emit means &quot;dump code bits into code buffer&quot;.
1394     for (uint j = 0; j&lt;last_inst; j++) {
1395       _index = j;
1396 
1397       // Get the node
1398       Node* n = block-&gt;get_node(j);
1399 
1400       // See if delay slots are supported
1401       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;used_in_unconditional_delay()) {
1402         assert(delay_slot == NULL, &quot;no use of delay slot node&quot;);
1403         assert(n-&gt;size(C-&gt;regalloc()) == Pipeline::instr_unit_size(), &quot;delay slot instruction wrong size&quot;);
1404 
1405         delay_slot = n;
1406         continue;
1407       }
1408 
1409       // If this starts a new instruction group, then flush the current one
1410       // (but allow split bundles)
1411       if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(n))
1412         cb-&gt;flush_bundle(false);
1413 
1414       // Special handling for SafePoint/Call Nodes
1415       bool is_mcall = false;
1416       if (n-&gt;is_Mach()) {
1417         MachNode *mach = n-&gt;as_Mach();
1418         is_mcall = n-&gt;is_MachCall();
1419         bool is_sfn = n-&gt;is_MachSafePoint();
1420 
1421         // If this requires all previous instructions be flushed, then do so
1422         if (is_sfn || is_mcall || mach-&gt;alignment_required() != 1) {
1423           cb-&gt;flush_bundle(true);
1424           current_offset = cb-&gt;insts_size();
1425         }
1426 
1427         // A padding may be needed again since a previous instruction
1428         // could be moved to delay slot.
1429 
1430         // align the instruction if necessary
1431         int padding = mach-&gt;compute_padding(current_offset);
1432         // Make sure safepoint node for polling is distinct from a call&#39;s
1433         // return by adding a nop if needed.
1434         if (is_sfn &amp;&amp; !is_mcall &amp;&amp; padding == 0 &amp;&amp; current_offset == last_call_offset) {
1435           padding = nop_size;
1436         }
1437         if (padding == 0 &amp;&amp; mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE) &amp;&amp;
1438             current_offset == last_avoid_back_to_back_offset) {
1439           // Avoid back to back some instructions.
1440           padding = nop_size;
1441         }
1442 
1443         if (padding &gt; 0) {
1444           assert((padding % nop_size) == 0, &quot;padding is not a multiple of NOP size&quot;);
1445           int nops_cnt = padding / nop_size;
1446           MachNode *nop = new MachNopNode(nops_cnt);
1447           block-&gt;insert_node(nop, j++);
1448           last_inst++;
1449           C-&gt;cfg()-&gt;map_node_to_block(nop, block);
1450           // Ensure enough space.
1451           cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1452           if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1453             C-&gt;record_failure(&quot;CodeCache is full&quot;);
1454             return;
1455           }
1456           nop-&gt;emit(*cb, C-&gt;regalloc());
1457           cb-&gt;flush_bundle(true);
1458           current_offset = cb-&gt;insts_size();
1459         }
1460 
1461         bool observe_safepoint = is_sfn;
1462         // Remember the start of the last call in a basic block
1463         if (is_mcall) {
1464           MachCallNode *mcall = mach-&gt;as_MachCall();
1465 
1466           // This destination address is NOT PC-relative
1467           mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());
1468 
1469           // Save the return address
1470           call_returns[block-&gt;_pre_order] = current_offset + mcall-&gt;ret_addr_offset();
1471 
1472           observe_safepoint = mcall-&gt;guaranteed_safepoint();
1473         }
1474 
1475         // sfn will be valid whenever mcall is valid now because of inheritance
1476         if (observe_safepoint) {
1477           // Handle special safepoint nodes for synchronization
1478           if (!is_mcall) {
1479             MachSafePointNode *sfn = mach-&gt;as_MachSafePoint();
1480             // !!!!! Stubs only need an oopmap right now, so bail out
1481             if (sfn-&gt;jvms()-&gt;method() == NULL) {
1482               // Write the oopmap directly to the code blob??!!
1483               continue;
1484             }
1485           } // End synchronization
1486 
1487           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1488                                            current_offset);
1489           Process_OopMap_Node(mach, current_offset);
1490         } // End if safepoint
1491 
1492           // If this is a null check, then add the start of the previous instruction to the list
1493         else if( mach-&gt;is_MachNullCheck() ) {
1494           inct_starts[inct_cnt++] = previous_offset;
1495         }
1496 
1497           // If this is a branch, then fill in the label with the target BB&#39;s label
1498         else if (mach-&gt;is_MachBranch()) {
1499           // This requires the TRUE branch target be in succs[0]
1500           uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1501 
1502           // Try to replace long branch if delay slot is not used,
1503           // it is mostly for back branches since forward branch&#39;s
1504           // distance is not updated yet.
1505           bool delay_slot_is_used = valid_bundle_info(n) &amp;&amp;
1506                                     C-&gt;output()-&gt;node_bundling(n)-&gt;use_unconditional_delay();
1507           if (!delay_slot_is_used &amp;&amp; mach-&gt;may_be_short_branch()) {
1508             assert(delay_slot == NULL, &quot;not expecting delay slot node&quot;);
1509             int br_size = n-&gt;size(C-&gt;regalloc());
1510             int offset = blk_starts[block_num] - current_offset;
1511             if (block_num &gt;= i) {
1512               // Current and following block&#39;s offset are not
1513               // finalized yet, adjust distance by the difference
1514               // between calculated and final offsets of current block.
1515               offset -= (blk_starts[i] - blk_offset);
1516             }
1517             // In the following code a nop could be inserted before
1518             // the branch which will increase the backward distance.
1519             bool needs_padding = (current_offset == last_avoid_back_to_back_offset);
1520             if (needs_padding &amp;&amp; offset &lt;= 0)
1521               offset -= nop_size;
1522 
1523             if (C-&gt;matcher()-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {
1524               // We&#39;ve got a winner.  Replace this branch.
1525               MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
1526 
1527               // Update the jmp_size.
1528               int new_size = replacement-&gt;size(C-&gt;regalloc());
1529               assert((br_size - new_size) &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
1530               // Insert padding between avoid_back_to_back branches.
1531               if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
1532                 MachNode *nop = new MachNopNode();
1533                 block-&gt;insert_node(nop, j++);
1534                 C-&gt;cfg()-&gt;map_node_to_block(nop, block);
1535                 last_inst++;
1536                 nop-&gt;emit(*cb, C-&gt;regalloc());
1537                 cb-&gt;flush_bundle(true);
1538                 current_offset = cb-&gt;insts_size();
1539               }
1540 #ifdef ASSERT
1541               jmp_target[i] = block_num;
1542               jmp_offset[i] = current_offset - blk_offset;
1543               jmp_size[i]   = new_size;
1544               jmp_rule[i]   = mach-&gt;rule();
1545 #endif
1546               block-&gt;map_node(replacement, j);
1547               mach-&gt;subsume_by(replacement, C);
1548               n    = replacement;
1549               mach = replacement;
1550             }
1551           }
1552           mach-&gt;as_MachBranch()-&gt;label_set( &amp;blk_labels[block_num], block_num );
1553         } else if (mach-&gt;ideal_Opcode() == Op_Jump) {
1554           for (uint h = 0; h &lt; block-&gt;_num_succs; h++) {
1555             Block* succs_block = block-&gt;_succs[h];
1556             for (uint j = 1; j &lt; succs_block-&gt;num_preds(); j++) {
1557               Node* jpn = succs_block-&gt;pred(j);
1558               if (jpn-&gt;is_JumpProj() &amp;&amp; jpn-&gt;in(0) == mach) {
1559                 uint block_num = succs_block-&gt;non_connector()-&gt;_pre_order;
1560                 Label *blkLabel = &amp;blk_labels[block_num];
1561                 mach-&gt;add_case_label(jpn-&gt;as_JumpProj()-&gt;proj_no(), blkLabel);
1562               }
1563             }
1564           }
1565         }
1566 #ifdef ASSERT
1567           // Check that oop-store precedes the card-mark
1568         else if (mach-&gt;ideal_Opcode() == Op_StoreCM) {
1569           uint storeCM_idx = j;
1570           int count = 0;
1571           for (uint prec = mach-&gt;req(); prec &lt; mach-&gt;len(); prec++) {
1572             Node *oop_store = mach-&gt;in(prec);  // Precedence edge
1573             if (oop_store == NULL) continue;
1574             count++;
1575             uint i4;
1576             for (i4 = 0; i4 &lt; last_inst; ++i4) {
1577               if (block-&gt;get_node(i4) == oop_store) {
1578                 break;
1579               }
1580             }
1581             // Note: This test can provide a false failure if other precedence
1582             // edges have been added to the storeCMNode.
1583             assert(i4 == last_inst || i4 &lt; storeCM_idx, &quot;CM card-mark executes before oop-store&quot;);
1584           }
1585           assert(count &gt; 0, &quot;storeCM expects at least one precedence edge&quot;);
1586         }
1587 #endif
1588         else if (!n-&gt;is_Proj()) {
1589           // Remember the beginning of the previous instruction, in case
1590           // it&#39;s followed by a flag-kill and a null-check.  Happens on
1591           // Intel all the time, with add-to-memory kind of opcodes.
1592           previous_offset = current_offset;
1593         }
1594 
1595         // Not an else-if!
1596         // If this is a trap based cmp then add its offset to the list.
1597         if (mach-&gt;is_TrapBasedCheckNode()) {
1598           inct_starts[inct_cnt++] = current_offset;
1599         }
1600       }
1601 
1602       // Verify that there is sufficient space remaining
1603       cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1604       if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1605         C-&gt;record_failure(&quot;CodeCache is full&quot;);
1606         return;
1607       }
1608 
1609       // Save the offset for the listing
1610 #if defined(SUPPORT_OPTO_ASSEMBLY)
1611       if ((node_offsets != NULL) &amp;&amp; (n-&gt;_idx &lt; node_offset_limit)) {
1612         node_offsets[n-&gt;_idx] = cb-&gt;insts_size();
1613       }
1614 #endif
1615 
1616       // &quot;Normal&quot; instruction case
1617       DEBUG_ONLY( uint instr_offset = cb-&gt;insts_size(); )
1618       n-&gt;emit(*cb, C-&gt;regalloc());
1619       current_offset  = cb-&gt;insts_size();
1620 
1621       assert(!is_mcall || (call_returns[block-&gt;_pre_order] == current_offset), &quot;ret_addr_offset() did not match size of emitted code&quot;);
1622 
1623       // Above we only verified that there is enough space in the instruction section.
1624       // However, the instruction may emit stubs that cause code buffer expansion.
1625       // Bail out here if expansion failed due to a lack of code cache space.
1626       if (C-&gt;failing()) {
1627         return;
1628       }
1629 
1630 #ifdef ASSERT
1631       uint n_size = n-&gt;size(C-&gt;regalloc());
1632       if (n_size &lt; (current_offset-instr_offset)) {
1633         MachNode* mach = n-&gt;as_Mach();
1634         n-&gt;dump();
1635         mach-&gt;dump_format(C-&gt;regalloc(), tty);
1636         tty-&gt;print_cr(&quot; n_size (%d), current_offset (%d), instr_offset (%d)&quot;, n_size, current_offset, instr_offset);
1637         Disassembler::decode(cb-&gt;insts_begin() + instr_offset, cb-&gt;insts_begin() + current_offset + 1, tty);
1638         tty-&gt;print_cr(&quot; ------------------- &quot;);
1639         BufferBlob* blob = this-&gt;scratch_buffer_blob();
1640         address blob_begin = blob-&gt;content_begin();
1641         Disassembler::decode(blob_begin, blob_begin + n_size + 1, tty);
1642         assert(false, &quot;wrong size of mach node&quot;);
1643       }
1644 #endif
1645       non_safepoints.observe_instruction(n, current_offset);
1646 
1647       // mcall is last &quot;call&quot; that can be a safepoint
1648       // record it so we can see if a poll will directly follow it
1649       // in which case we&#39;ll need a pad to make the PcDesc sites unique
1650       // see  5010568. This can be slightly inaccurate but conservative
1651       // in the case that return address is not actually at current_offset.
1652       // This is a small price to pay.
1653 
1654       if (is_mcall) {
1655         last_call_offset = current_offset;
1656       }
1657 
1658       if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
1659         // Avoid back to back some instructions.
1660         last_avoid_back_to_back_offset = current_offset;
1661       }
1662 
1663       // See if this instruction has a delay slot
1664       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;use_unconditional_delay()) {
1665         guarantee(delay_slot != NULL, &quot;expecting delay slot node&quot;);
1666 
1667         // Back up 1 instruction
1668         cb-&gt;set_insts_end(cb-&gt;insts_end() - Pipeline::instr_unit_size());
1669 
1670         // Save the offset for the listing
1671 #if defined(SUPPORT_OPTO_ASSEMBLY)
1672         if ((node_offsets != NULL) &amp;&amp; (delay_slot-&gt;_idx &lt; node_offset_limit)) {
1673           node_offsets[delay_slot-&gt;_idx] = cb-&gt;insts_size();
1674         }
1675 #endif
1676 
1677         // Support a SafePoint in the delay slot
1678         if (delay_slot-&gt;is_MachSafePoint()) {
1679           MachNode *mach = delay_slot-&gt;as_Mach();
1680           // !!!!! Stubs only need an oopmap right now, so bail out
1681           if (!mach-&gt;is_MachCall() &amp;&amp; mach-&gt;as_MachSafePoint()-&gt;jvms()-&gt;method() == NULL) {
1682             // Write the oopmap directly to the code blob??!!
1683             delay_slot = NULL;
1684             continue;
1685           }
1686 
1687           int adjusted_offset = current_offset - Pipeline::instr_unit_size();
1688           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1689                                            adjusted_offset);
1690           // Generate an OopMap entry
1691           Process_OopMap_Node(mach, adjusted_offset);
1692         }
1693 
1694         // Insert the delay slot instruction
1695         delay_slot-&gt;emit(*cb, C-&gt;regalloc());
1696 
1697         // Don&#39;t reuse it
1698         delay_slot = NULL;
1699       }
1700 
1701     } // End for all instructions in block
1702 
1703     // If the next block is the top of a loop, pad this block out to align
1704     // the loop top a little. Helps prevent pipe stalls at loop back branches.
1705     if (i &lt; nblocks-1) {
1706       Block *nb = C-&gt;cfg()-&gt;get_block(i + 1);
1707       int padding = nb-&gt;alignment_padding(current_offset);
1708       if( padding &gt; 0 ) {
1709         MachNode *nop = new MachNopNode(padding / nop_size);
1710         block-&gt;insert_node(nop, block-&gt;number_of_nodes());
1711         C-&gt;cfg()-&gt;map_node_to_block(nop, block);
1712         nop-&gt;emit(*cb, C-&gt;regalloc());
1713         current_offset = cb-&gt;insts_size();
1714       }
1715     }
1716     // Verify that the distance for generated before forward
1717     // short branches is still valid.
1718     guarantee((int)(blk_starts[i+1] - blk_starts[i]) &gt;= (current_offset - blk_offset), &quot;shouldn&#39;t increase block size&quot;);
1719 
1720     // Save new block start offset
1721     blk_starts[i] = blk_offset;
1722   } // End of for all blocks
1723   blk_starts[nblocks] = current_offset;
1724 
1725   non_safepoints.flush_at_end();
1726 
1727   // Offset too large?
1728   if (C-&gt;failing())  return;
1729 
1730   // Define a pseudo-label at the end of the code
1731   MacroAssembler(cb).bind( blk_labels[nblocks] );
1732 
1733   // Compute the size of the first block
1734   _first_block_size = blk_labels[1].loc_pos() - blk_labels[0].loc_pos();
1735 
1736 #ifdef ASSERT
1737   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
1738     if (jmp_target[i] != 0) {
1739       int br_size = jmp_size[i];
1740       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
1741       if (!C-&gt;matcher()-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {
1742         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
1743         assert(false, &quot;Displacement too large for short jmp&quot;);
1744       }
1745     }
1746   }
1747 #endif
1748 
1749   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1750   bs-&gt;emit_stubs(*cb);
1751   if (C-&gt;failing())  return;
1752 
1753 #ifndef PRODUCT
1754   // Information on the size of the method, without the extraneous code
1755   Scheduling::increment_method_size(cb-&gt;insts_size());
1756 #endif
1757 
1758   // ------------------
1759   // Fill in exception table entries.
1760   FillExceptionTables(inct_cnt, call_returns, inct_starts, blk_labels);
1761 
1762   // Only java methods have exception handlers and deopt handlers
1763   // class HandlerImpl is platform-specific and defined in the *.ad files.
1764   if (C-&gt;method()) {
1765     // Emit the exception handler code.
1766     _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(*cb));
1767     if (C-&gt;failing()) {
1768       return; // CodeBuffer::expand failed
1769     }
1770     // Emit the deopt handler code.
1771     _code_offsets.set_value(CodeOffsets::Deopt, HandlerImpl::emit_deopt_handler(*cb));
1772 
1773     // Emit the MethodHandle deopt handler code (if required).
1774     if (C-&gt;has_method_handle_invokes() &amp;&amp; !C-&gt;failing()) {
1775       // We can use the same code as for the normal deopt handler, we
1776       // just need a different entry point address.
1777       _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(*cb));
1778     }
1779   }
1780 
1781   // One last check for failed CodeBuffer::expand:
1782   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1783     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1784     return;
1785   }
1786 
1787 #if defined(SUPPORT_ABSTRACT_ASSEMBLY) || defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_OPTO_ASSEMBLY)
1788   if (C-&gt;print_assembly()) {
1789     tty-&gt;cr();
1790     tty-&gt;print_cr(&quot;============================= C2-compiled nmethod ==============================&quot;);
1791   }
1792 #endif
1793 
1794 #if defined(SUPPORT_OPTO_ASSEMBLY)
1795   // Dump the assembly code, including basic-block numbers
1796   if (C-&gt;print_assembly()) {
1797     ttyLocker ttyl;  // keep the following output all in one block
1798     if (!VMThread::should_terminate()) {  // test this under the tty lock
1799       // This output goes directly to the tty, not the compiler log.
1800       // To enable tools to match it up with the compilation activity,
1801       // be sure to tag this tty output with the compile ID.
1802       if (xtty != NULL) {
1803         xtty-&gt;head(&quot;opto_assembly compile_id=&#39;%d&#39;%s&quot;, C-&gt;compile_id(),
1804                    C-&gt;is_osr_compilation()    ? &quot; compile_kind=&#39;osr&#39;&quot; :
1805                    &quot;&quot;);
1806       }
1807       if (C-&gt;method() != NULL) {
1808         tty-&gt;print_cr(&quot;----------------------- MetaData before Compile_id = %d ------------------------&quot;, C-&gt;compile_id());
1809         C-&gt;method()-&gt;print_metadata();
1810       } else if (C-&gt;stub_name() != NULL) {
1811         tty-&gt;print_cr(&quot;----------------------------- RuntimeStub %s -------------------------------&quot;, C-&gt;stub_name());
1812       }
1813       tty-&gt;cr();
1814       tty-&gt;print_cr(&quot;------------------------ OptoAssembly for Compile_id = %d -----------------------&quot;, C-&gt;compile_id());
1815       dump_asm(node_offsets, node_offset_limit);
1816       tty-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);
1817       if (xtty != NULL) {
1818         // print_metadata and dump_asm above may safepoint which makes us loose the ttylock.
1819         // Retake lock too make sure the end tag is coherent, and that xmlStream-&gt;pop_tag is done
1820         // thread safe
1821         ttyLocker ttyl2;
1822         xtty-&gt;tail(&quot;opto_assembly&quot;);
1823       }
1824     }
1825   }
1826 #endif
1827 }
1828 
1829 void PhaseOutput::FillExceptionTables(uint cnt, uint *call_returns, uint *inct_starts, Label *blk_labels) {
1830   _inc_table.set_size(cnt);
1831 
1832   uint inct_cnt = 0;
1833   for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {
1834     Block* block = C-&gt;cfg()-&gt;get_block(i);
1835     Node *n = NULL;
1836     int j;
1837 
1838     // Find the branch; ignore trailing NOPs.
1839     for (j = block-&gt;number_of_nodes() - 1; j &gt;= 0; j--) {
1840       n = block-&gt;get_node(j);
1841       if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con) {
1842         break;
1843       }
1844     }
1845 
1846     // If we didn&#39;t find anything, continue
1847     if (j &lt; 0) {
1848       continue;
1849     }
1850 
1851     // Compute ExceptionHandlerTable subtable entry and add it
1852     // (skip empty blocks)
1853     if (n-&gt;is_Catch()) {
1854 
1855       // Get the offset of the return from the call
1856       uint call_return = call_returns[block-&gt;_pre_order];
1857 #ifdef ASSERT
1858       assert( call_return &gt; 0, &quot;no call seen for this basic block&quot; );
1859       while (block-&gt;get_node(--j)-&gt;is_MachProj()) ;
1860       assert(block-&gt;get_node(j)-&gt;is_MachCall(), &quot;CatchProj must follow call&quot;);
1861 #endif
1862       // last instruction is a CatchNode, find it&#39;s CatchProjNodes
1863       int nof_succs = block-&gt;_num_succs;
1864       // allocate space
1865       GrowableArray&lt;intptr_t&gt; handler_bcis(nof_succs);
1866       GrowableArray&lt;intptr_t&gt; handler_pcos(nof_succs);
1867       // iterate through all successors
1868       for (int j = 0; j &lt; nof_succs; j++) {
1869         Block* s = block-&gt;_succs[j];
1870         bool found_p = false;
1871         for (uint k = 1; k &lt; s-&gt;num_preds(); k++) {
1872           Node* pk = s-&gt;pred(k);
1873           if (pk-&gt;is_CatchProj() &amp;&amp; pk-&gt;in(0) == n) {
1874             const CatchProjNode* p = pk-&gt;as_CatchProj();
1875             found_p = true;
1876             // add the corresponding handler bci &amp; pco information
1877             if (p-&gt;_con != CatchProjNode::fall_through_index) {
1878               // p leads to an exception handler (and is not fall through)
1879               assert(s == C-&gt;cfg()-&gt;get_block(s-&gt;_pre_order), &quot;bad numbering&quot;);
1880               // no duplicates, please
1881               if (!handler_bcis.contains(p-&gt;handler_bci())) {
1882                 uint block_num = s-&gt;non_connector()-&gt;_pre_order;
1883                 handler_bcis.append(p-&gt;handler_bci());
1884                 handler_pcos.append(blk_labels[block_num].loc_pos());
1885               }
1886             }
1887           }
1888         }
1889         assert(found_p, &quot;no matching predecessor found&quot;);
1890         // Note:  Due to empty block removal, one block may have
1891         // several CatchProj inputs, from the same Catch.
1892       }
1893 
1894       // Set the offset of the return from the call
1895       assert(handler_bcis.find(-1) != -1, &quot;must have default handler&quot;);
1896       _handler_table.add_subtable(call_return, &amp;handler_bcis, NULL, &amp;handler_pcos);
1897       continue;
1898     }
1899 
1900     // Handle implicit null exception table updates
1901     if (n-&gt;is_MachNullCheck()) {
1902       uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1903       _inc_table.append(inct_starts[inct_cnt++], blk_labels[block_num].loc_pos());
1904       continue;
1905     }
1906     // Handle implicit exception table updates: trap instructions.
1907     if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;is_TrapBasedCheckNode()) {
1908       uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1909       _inc_table.append(inct_starts[inct_cnt++], blk_labels[block_num].loc_pos());
1910       continue;
1911     }
1912   } // End of for all blocks fill in exception table entries
1913 }
1914 
1915 // Static Variables
1916 #ifndef PRODUCT
1917 uint Scheduling::_total_nop_size = 0;
1918 uint Scheduling::_total_method_size = 0;
1919 uint Scheduling::_total_branches = 0;
1920 uint Scheduling::_total_unconditional_delays = 0;
1921 uint Scheduling::_total_instructions_per_bundle[Pipeline::_max_instrs_per_cycle+1];
1922 #endif
1923 
1924 // Initializer for class Scheduling
1925 
1926 Scheduling::Scheduling(Arena *arena, Compile &amp;compile)
1927         : _arena(arena),
1928           _cfg(compile.cfg()),
1929           _regalloc(compile.regalloc()),
1930           _scheduled(arena),
1931           _available(arena),
1932           _reg_node(arena),
1933           _pinch_free_list(arena),
1934           _next_node(NULL),
1935           _bundle_instr_count(0),
1936           _bundle_cycle_number(0),
1937           _bundle_use(0, 0, resource_count, &amp;_bundle_use_elements[0])
1938 #ifndef PRODUCT
1939         , _branches(0)
1940         , _unconditional_delays(0)
1941 #endif
1942 {
1943   // Create a MachNopNode
1944   _nop = new MachNopNode();
1945 
1946   // Now that the nops are in the array, save the count
1947   // (but allow entries for the nops)
1948   _node_bundling_limit = compile.unique();
1949   uint node_max = _regalloc-&gt;node_regs_max_index();
1950 
1951   compile.output()-&gt;set_node_bundling_limit(_node_bundling_limit);
1952 
1953   // This one is persistent within the Compile class
1954   _node_bundling_base = NEW_ARENA_ARRAY(compile.comp_arena(), Bundle, node_max);
1955 
1956   // Allocate space for fixed-size arrays
1957   _node_latency    = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1958   _uses            = NEW_ARENA_ARRAY(arena, short,          node_max);
1959   _current_latency = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1960 
1961   // Clear the arrays
1962   for (uint i = 0; i &lt; node_max; i++) {
1963     ::new (&amp;_node_bundling_base[i]) Bundle();
1964   }
1965   memset(_node_latency,       0, node_max * sizeof(unsigned short));
1966   memset(_uses,               0, node_max * sizeof(short));
1967   memset(_current_latency,    0, node_max * sizeof(unsigned short));
1968 
1969   // Clear the bundling information
1970   memcpy(_bundle_use_elements, Pipeline_Use::elaborated_elements, sizeof(Pipeline_Use::elaborated_elements));
1971 
1972   // Get the last node
1973   Block* block = _cfg-&gt;get_block(_cfg-&gt;number_of_blocks() - 1);
1974 
1975   _next_node = block-&gt;get_node(block-&gt;number_of_nodes() - 1);
1976 }
1977 
1978 #ifndef PRODUCT
1979 // Scheduling destructor
1980 Scheduling::~Scheduling() {
1981   _total_branches             += _branches;
1982   _total_unconditional_delays += _unconditional_delays;
1983 }
1984 #endif
1985 
1986 // Step ahead &quot;i&quot; cycles
1987 void Scheduling::step(uint i) {
1988 
1989   Bundle *bundle = node_bundling(_next_node);
1990   bundle-&gt;set_starts_bundle();
1991 
1992   // Update the bundle record, but leave the flags information alone
1993   if (_bundle_instr_count &gt; 0) {
1994     bundle-&gt;set_instr_count(_bundle_instr_count);
1995     bundle-&gt;set_resources_used(_bundle_use.resourcesUsed());
1996   }
1997 
1998   // Update the state information
1999   _bundle_instr_count = 0;
2000   _bundle_cycle_number += i;
2001   _bundle_use.step(i);
2002 }
2003 
2004 void Scheduling::step_and_clear() {
2005   Bundle *bundle = node_bundling(_next_node);
2006   bundle-&gt;set_starts_bundle();
2007 
2008   // Update the bundle record
2009   if (_bundle_instr_count &gt; 0) {
2010     bundle-&gt;set_instr_count(_bundle_instr_count);
2011     bundle-&gt;set_resources_used(_bundle_use.resourcesUsed());
2012 
2013     _bundle_cycle_number += 1;
2014   }
2015 
2016   // Clear the bundling information
2017   _bundle_instr_count = 0;
2018   _bundle_use.reset();
2019 
2020   memcpy(_bundle_use_elements,
2021          Pipeline_Use::elaborated_elements,
2022          sizeof(Pipeline_Use::elaborated_elements));
2023 }
2024 
2025 // Perform instruction scheduling and bundling over the sequence of
2026 // instructions in backwards order.
2027 void PhaseOutput::ScheduleAndBundle() {
2028 
2029   // Don&#39;t optimize this if it isn&#39;t a method
2030   if (!C-&gt;method())
2031     return;
2032 
2033   // Don&#39;t optimize this if scheduling is disabled
2034   if (!C-&gt;do_scheduling())
2035     return;
2036 
2037   // Scheduling code works only with pairs (8 bytes) maximum.
2038   if (C-&gt;max_vector_size() &gt; 8)
2039     return;
2040 
2041   Compile::TracePhase tp(&quot;isched&quot;, &amp;timers[_t_instrSched]);
2042 
2043   // Create a data structure for all the scheduling information
2044   Scheduling scheduling(Thread::current()-&gt;resource_area(), *C);
2045 
2046   // Walk backwards over each basic block, computing the needed alignment
2047   // Walk over all the basic blocks
2048   scheduling.DoScheduling();
2049 
2050 #ifndef PRODUCT
2051   if (C-&gt;trace_opto_output()) {
2052     tty-&gt;print(&quot;\n---- After ScheduleAndBundle ----\n&quot;);
2053     for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {
2054       tty-&gt;print(&quot;\nBB#%03d:\n&quot;, i);
2055       Block* block = C-&gt;cfg()-&gt;get_block(i);
2056       for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {
2057         Node* n = block-&gt;get_node(j);
2058         OptoReg::Name reg = C-&gt;regalloc()-&gt;get_reg_first(n);
2059         tty-&gt;print(&quot; %-6s &quot;, reg &gt;= 0 &amp;&amp; reg &lt; REG_COUNT ? Matcher::regName[reg] : &quot;&quot;);
2060         n-&gt;dump();
2061       }
2062     }
2063   }
2064 #endif
2065 }
2066 
2067 // Compute the latency of all the instructions.  This is fairly simple,
2068 // because we already have a legal ordering.  Walk over the instructions
2069 // from first to last, and compute the latency of the instruction based
2070 // on the latency of the preceding instruction(s).
2071 void Scheduling::ComputeLocalLatenciesForward(const Block *bb) {
2072 #ifndef PRODUCT
2073   if (_cfg-&gt;C-&gt;trace_opto_output())
2074     tty-&gt;print(&quot;# -&gt; ComputeLocalLatenciesForward\n&quot;);
2075 #endif
2076 
2077   // Walk over all the schedulable instructions
2078   for( uint j=_bb_start; j &lt; _bb_end; j++ ) {
2079 
2080     // This is a kludge, forcing all latency calculations to start at 1.
2081     // Used to allow latency 0 to force an instruction to the beginning
2082     // of the bb
2083     uint latency = 1;
2084     Node *use = bb-&gt;get_node(j);
2085     uint nlen = use-&gt;len();
2086 
2087     // Walk over all the inputs
2088     for ( uint k=0; k &lt; nlen; k++ ) {
2089       Node *def = use-&gt;in(k);
2090       if (!def)
2091         continue;
2092 
2093       uint l = _node_latency[def-&gt;_idx] + use-&gt;latency(k);
2094       if (latency &lt; l)
2095         latency = l;
2096     }
2097 
2098     _node_latency[use-&gt;_idx] = latency;
2099 
2100 #ifndef PRODUCT
2101     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2102       tty-&gt;print(&quot;# latency %4d: &quot;, latency);
2103       use-&gt;dump();
2104     }
2105 #endif
2106   }
2107 
2108 #ifndef PRODUCT
2109   if (_cfg-&gt;C-&gt;trace_opto_output())
2110     tty-&gt;print(&quot;# &lt;- ComputeLocalLatenciesForward\n&quot;);
2111 #endif
2112 
2113 } // end ComputeLocalLatenciesForward
2114 
2115 // See if this node fits into the present instruction bundle
2116 bool Scheduling::NodeFitsInBundle(Node *n) {
2117   uint n_idx = n-&gt;_idx;
2118 
2119   // If this is the unconditional delay instruction, then it fits
2120   if (n == _unconditional_delay_slot) {
2121 #ifndef PRODUCT
2122     if (_cfg-&gt;C-&gt;trace_opto_output())
2123       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: TRUE; is in unconditional delay slot\n&quot;, n-&gt;_idx);
2124 #endif
2125     return (true);
2126   }
2127 
2128   // If the node cannot be scheduled this cycle, skip it
2129   if (_current_latency[n_idx] &gt; _bundle_cycle_number) {
2130 #ifndef PRODUCT
2131     if (_cfg-&gt;C-&gt;trace_opto_output())
2132       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: FALSE; latency %4d &gt; %d\n&quot;,
2133                  n-&gt;_idx, _current_latency[n_idx], _bundle_cycle_number);
2134 #endif
2135     return (false);
2136   }
2137 
2138   const Pipeline *node_pipeline = n-&gt;pipeline();
2139 
2140   uint instruction_count = node_pipeline-&gt;instructionCount();
2141   if (node_pipeline-&gt;mayHaveNoCode() &amp;&amp; n-&gt;size(_regalloc) == 0)
2142     instruction_count = 0;
2143   else if (node_pipeline-&gt;hasBranchDelay() &amp;&amp; !_unconditional_delay_slot)
2144     instruction_count++;
2145 
2146   if (_bundle_instr_count + instruction_count &gt; Pipeline::_max_instrs_per_cycle) {
2147 #ifndef PRODUCT
2148     if (_cfg-&gt;C-&gt;trace_opto_output())
2149       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: FALSE; too many instructions: %d &gt; %d\n&quot;,
2150                  n-&gt;_idx, _bundle_instr_count + instruction_count, Pipeline::_max_instrs_per_cycle);
2151 #endif
2152     return (false);
2153   }
2154 
2155   // Don&#39;t allow non-machine nodes to be handled this way
2156   if (!n-&gt;is_Mach() &amp;&amp; instruction_count == 0)
2157     return (false);
2158 
2159   // See if there is any overlap
2160   uint delay = _bundle_use.full_latency(0, node_pipeline-&gt;resourceUse());
2161 
2162   if (delay &gt; 0) {
2163 #ifndef PRODUCT
2164     if (_cfg-&gt;C-&gt;trace_opto_output())
2165       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: FALSE; functional units overlap\n&quot;, n_idx);
2166 #endif
2167     return false;
2168   }
2169 
2170 #ifndef PRODUCT
2171   if (_cfg-&gt;C-&gt;trace_opto_output())
2172     tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]:  TRUE\n&quot;, n_idx);
2173 #endif
2174 
2175   return true;
2176 }
2177 
2178 Node * Scheduling::ChooseNodeToBundle() {
2179   uint siz = _available.size();
2180 
2181   if (siz == 0) {
2182 
2183 #ifndef PRODUCT
2184     if (_cfg-&gt;C-&gt;trace_opto_output())
2185       tty-&gt;print(&quot;#   ChooseNodeToBundle: NULL\n&quot;);
2186 #endif
2187     return (NULL);
2188   }
2189 
2190   // Fast path, if only 1 instruction in the bundle
2191   if (siz == 1) {
2192 #ifndef PRODUCT
2193     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2194       tty-&gt;print(&quot;#   ChooseNodeToBundle (only 1): &quot;);
2195       _available[0]-&gt;dump();
2196     }
2197 #endif
2198     return (_available[0]);
2199   }
2200 
2201   // Don&#39;t bother, if the bundle is already full
2202   if (_bundle_instr_count &lt; Pipeline::_max_instrs_per_cycle) {
2203     for ( uint i = 0; i &lt; siz; i++ ) {
2204       Node *n = _available[i];
2205 
2206       // Skip projections, we&#39;ll handle them another way
2207       if (n-&gt;is_Proj())
2208         continue;
2209 
2210       // This presupposed that instructions are inserted into the
2211       // available list in a legality order; i.e. instructions that
2212       // must be inserted first are at the head of the list
2213       if (NodeFitsInBundle(n)) {
2214 #ifndef PRODUCT
2215         if (_cfg-&gt;C-&gt;trace_opto_output()) {
2216           tty-&gt;print(&quot;#   ChooseNodeToBundle: &quot;);
2217           n-&gt;dump();
2218         }
2219 #endif
2220         return (n);
2221       }
2222     }
2223   }
2224 
2225   // Nothing fits in this bundle, choose the highest priority
2226 #ifndef PRODUCT
2227   if (_cfg-&gt;C-&gt;trace_opto_output()) {
2228     tty-&gt;print(&quot;#   ChooseNodeToBundle: &quot;);
2229     _available[0]-&gt;dump();
2230   }
2231 #endif
2232 
2233   return _available[0];
2234 }
2235 
2236 void Scheduling::AddNodeToAvailableList(Node *n) {
2237   assert( !n-&gt;is_Proj(), &quot;projections never directly made available&quot; );
2238 #ifndef PRODUCT
2239   if (_cfg-&gt;C-&gt;trace_opto_output()) {
2240     tty-&gt;print(&quot;#   AddNodeToAvailableList: &quot;);
2241     n-&gt;dump();
2242   }
2243 #endif
2244 
2245   int latency = _current_latency[n-&gt;_idx];
2246 
2247   // Insert in latency order (insertion sort)
2248   uint i;
2249   for ( i=0; i &lt; _available.size(); i++ )
2250     if (_current_latency[_available[i]-&gt;_idx] &gt; latency)
2251       break;
2252 
2253   // Special Check for compares following branches
2254   if( n-&gt;is_Mach() &amp;&amp; _scheduled.size() &gt; 0 ) {
2255     int op = n-&gt;as_Mach()-&gt;ideal_Opcode();
2256     Node *last = _scheduled[0];
2257     if( last-&gt;is_MachIf() &amp;&amp; last-&gt;in(1) == n &amp;&amp;
2258         ( op == Op_CmpI ||
2259           op == Op_CmpU ||
2260           op == Op_CmpUL ||
2261           op == Op_CmpP ||
2262           op == Op_CmpF ||
2263           op == Op_CmpD ||
2264           op == Op_CmpL ) ) {
2265 
2266       // Recalculate position, moving to front of same latency
2267       for ( i=0 ; i &lt; _available.size(); i++ )
2268         if (_current_latency[_available[i]-&gt;_idx] &gt;= latency)
2269           break;
2270     }
2271   }
2272 
2273   // Insert the node in the available list
2274   _available.insert(i, n);
2275 
2276 #ifndef PRODUCT
2277   if (_cfg-&gt;C-&gt;trace_opto_output())
2278     dump_available();
2279 #endif
2280 }
2281 
2282 void Scheduling::DecrementUseCounts(Node *n, const Block *bb) {
2283   for ( uint i=0; i &lt; n-&gt;len(); i++ ) {
2284     Node *def = n-&gt;in(i);
2285     if (!def) continue;
2286     if( def-&gt;is_Proj() )        // If this is a machine projection, then
2287       def = def-&gt;in(0);         // propagate usage thru to the base instruction
2288 
2289     if(_cfg-&gt;get_block_for_node(def) != bb) { // Ignore if not block-local
2290       continue;
2291     }
2292 
2293     // Compute the latency
2294     uint l = _bundle_cycle_number + n-&gt;latency(i);
2295     if (_current_latency[def-&gt;_idx] &lt; l)
2296       _current_latency[def-&gt;_idx] = l;
2297 
2298     // If this does not have uses then schedule it
2299     if ((--_uses[def-&gt;_idx]) == 0)
2300       AddNodeToAvailableList(def);
2301   }
2302 }
2303 
2304 void Scheduling::AddNodeToBundle(Node *n, const Block *bb) {
2305 #ifndef PRODUCT
2306   if (_cfg-&gt;C-&gt;trace_opto_output()) {
2307     tty-&gt;print(&quot;#   AddNodeToBundle: &quot;);
2308     n-&gt;dump();
2309   }
2310 #endif
2311 
2312   // Remove this from the available list
2313   uint i;
2314   for (i = 0; i &lt; _available.size(); i++)
2315     if (_available[i] == n)
2316       break;
2317   assert(i &lt; _available.size(), &quot;entry in _available list not found&quot;);
2318   _available.remove(i);
2319 
2320   // See if this fits in the current bundle
2321   const Pipeline *node_pipeline = n-&gt;pipeline();
2322   const Pipeline_Use&amp; node_usage = node_pipeline-&gt;resourceUse();
2323 
2324   // Check for instructions to be placed in the delay slot. We
2325   // do this before we actually schedule the current instruction,
2326   // because the delay slot follows the current instruction.
2327   if (Pipeline::_branch_has_delay_slot &amp;&amp;
2328       node_pipeline-&gt;hasBranchDelay() &amp;&amp;
2329       !_unconditional_delay_slot) {
2330 
2331     uint siz = _available.size();
2332 
2333     // Conditional branches can support an instruction that
2334     // is unconditionally executed and not dependent by the
2335     // branch, OR a conditionally executed instruction if
2336     // the branch is taken.  In practice, this means that
2337     // the first instruction at the branch target is
2338     // copied to the delay slot, and the branch goes to
2339     // the instruction after that at the branch target
2340     if ( n-&gt;is_MachBranch() ) {
2341 
2342       assert( !n-&gt;is_MachNullCheck(), &quot;should not look for delay slot for Null Check&quot; );
2343       assert( !n-&gt;is_Catch(),         &quot;should not look for delay slot for Catch&quot; );
2344 
2345 #ifndef PRODUCT
2346       _branches++;
2347 #endif
2348 
2349       // At least 1 instruction is on the available list
2350       // that is not dependent on the branch
2351       for (uint i = 0; i &lt; siz; i++) {
2352         Node *d = _available[i];
2353         const Pipeline *avail_pipeline = d-&gt;pipeline();
2354 
2355         // Don&#39;t allow safepoints in the branch shadow, that will
2356         // cause a number of difficulties
2357         if ( avail_pipeline-&gt;instructionCount() == 1 &amp;&amp;
2358              !avail_pipeline-&gt;hasMultipleBundles() &amp;&amp;
2359              !avail_pipeline-&gt;hasBranchDelay() &amp;&amp;
2360              Pipeline::instr_has_unit_size() &amp;&amp;
2361              d-&gt;size(_regalloc) == Pipeline::instr_unit_size() &amp;&amp;
2362              NodeFitsInBundle(d) &amp;&amp;
2363              !node_bundling(d)-&gt;used_in_delay()) {
2364 
2365           if (d-&gt;is_Mach() &amp;&amp; !d-&gt;is_MachSafePoint()) {
2366             // A node that fits in the delay slot was found, so we need to
2367             // set the appropriate bits in the bundle pipeline information so
2368             // that it correctly indicates resource usage.  Later, when we
2369             // attempt to add this instruction to the bundle, we will skip
2370             // setting the resource usage.
2371             _unconditional_delay_slot = d;
2372             node_bundling(n)-&gt;set_use_unconditional_delay();
2373             node_bundling(d)-&gt;set_used_in_unconditional_delay();
2374             _bundle_use.add_usage(avail_pipeline-&gt;resourceUse());
2375             _current_latency[d-&gt;_idx] = _bundle_cycle_number;
2376             _next_node = d;
2377             ++_bundle_instr_count;
2378 #ifndef PRODUCT
2379             _unconditional_delays++;
2380 #endif
2381             break;
2382           }
2383         }
2384       }
2385     }
2386 
2387     // No delay slot, add a nop to the usage
2388     if (!_unconditional_delay_slot) {
2389       // See if adding an instruction in the delay slot will overflow
2390       // the bundle.
2391       if (!NodeFitsInBundle(_nop)) {
2392 #ifndef PRODUCT
2393         if (_cfg-&gt;C-&gt;trace_opto_output())
2394           tty-&gt;print(&quot;#  *** STEP(1 instruction for delay slot) ***\n&quot;);
2395 #endif
2396         step(1);
2397       }
2398 
2399       _bundle_use.add_usage(_nop-&gt;pipeline()-&gt;resourceUse());
2400       _next_node = _nop;
2401       ++_bundle_instr_count;
2402     }
2403 
2404     // See if the instruction in the delay slot requires a
2405     // step of the bundles
2406     if (!NodeFitsInBundle(n)) {
2407 #ifndef PRODUCT
2408       if (_cfg-&gt;C-&gt;trace_opto_output())
2409         tty-&gt;print(&quot;#  *** STEP(branch won&#39;t fit) ***\n&quot;);
2410 #endif
2411       // Update the state information
2412       _bundle_instr_count = 0;
2413       _bundle_cycle_number += 1;
2414       _bundle_use.step(1);
2415     }
2416   }
2417 
2418   // Get the number of instructions
2419   uint instruction_count = node_pipeline-&gt;instructionCount();
2420   if (node_pipeline-&gt;mayHaveNoCode() &amp;&amp; n-&gt;size(_regalloc) == 0)
2421     instruction_count = 0;
2422 
2423   // Compute the latency information
2424   uint delay = 0;
2425 
2426   if (instruction_count &gt; 0 || !node_pipeline-&gt;mayHaveNoCode()) {
2427     int relative_latency = _current_latency[n-&gt;_idx] - _bundle_cycle_number;
2428     if (relative_latency &lt; 0)
2429       relative_latency = 0;
2430 
2431     delay = _bundle_use.full_latency(relative_latency, node_usage);
2432 
2433     // Does not fit in this bundle, start a new one
2434     if (delay &gt; 0) {
2435       step(delay);
2436 
2437 #ifndef PRODUCT
2438       if (_cfg-&gt;C-&gt;trace_opto_output())
2439         tty-&gt;print(&quot;#  *** STEP(%d) ***\n&quot;, delay);
2440 #endif
2441     }
2442   }
2443 
2444   // If this was placed in the delay slot, ignore it
2445   if (n != _unconditional_delay_slot) {
2446 
2447     if (delay == 0) {
2448       if (node_pipeline-&gt;hasMultipleBundles()) {
2449 #ifndef PRODUCT
2450         if (_cfg-&gt;C-&gt;trace_opto_output())
2451           tty-&gt;print(&quot;#  *** STEP(multiple instructions) ***\n&quot;);
2452 #endif
2453         step(1);
2454       }
2455 
2456       else if (instruction_count + _bundle_instr_count &gt; Pipeline::_max_instrs_per_cycle) {
2457 #ifndef PRODUCT
2458         if (_cfg-&gt;C-&gt;trace_opto_output())
2459           tty-&gt;print(&quot;#  *** STEP(%d &gt;= %d instructions) ***\n&quot;,
2460                      instruction_count + _bundle_instr_count,
2461                      Pipeline::_max_instrs_per_cycle);
2462 #endif
2463         step(1);
2464       }
2465     }
2466 
2467     if (node_pipeline-&gt;hasBranchDelay() &amp;&amp; !_unconditional_delay_slot)
2468       _bundle_instr_count++;
2469 
2470     // Set the node&#39;s latency
2471     _current_latency[n-&gt;_idx] = _bundle_cycle_number;
2472 
2473     // Now merge the functional unit information
2474     if (instruction_count &gt; 0 || !node_pipeline-&gt;mayHaveNoCode())
2475       _bundle_use.add_usage(node_usage);
2476 
2477     // Increment the number of instructions in this bundle
2478     _bundle_instr_count += instruction_count;
2479 
2480     // Remember this node for later
2481     if (n-&gt;is_Mach())
2482       _next_node = n;
2483   }
2484 
2485   // It&#39;s possible to have a BoxLock in the graph and in the _bbs mapping but
2486   // not in the bb-&gt;_nodes array.  This happens for debug-info-only BoxLocks.
2487   // &#39;Schedule&#39; them (basically ignore in the schedule) but do not insert them
2488   // into the block.  All other scheduled nodes get put in the schedule here.
2489   int op = n-&gt;Opcode();
2490   if( (op == Op_Node &amp;&amp; n-&gt;req() == 0) || // anti-dependence node OR
2491       (op != Op_Node &amp;&amp;         // Not an unused antidepedence node and
2492        // not an unallocated boxlock
2493        (OptoReg::is_valid(_regalloc-&gt;get_reg_first(n)) || op != Op_BoxLock)) ) {
2494 
2495     // Push any trailing projections
2496     if( bb-&gt;get_node(bb-&gt;number_of_nodes()-1) != n ) {
2497       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2498         Node *foi = n-&gt;fast_out(i);
2499         if( foi-&gt;is_Proj() )
2500           _scheduled.push(foi);
2501       }
2502     }
2503 
2504     // Put the instruction in the schedule list
2505     _scheduled.push(n);
2506   }
2507 
2508 #ifndef PRODUCT
2509   if (_cfg-&gt;C-&gt;trace_opto_output())
2510     dump_available();
2511 #endif
2512 
2513   // Walk all the definitions, decrementing use counts, and
2514   // if a definition has a 0 use count, place it in the available list.
2515   DecrementUseCounts(n,bb);
2516 }
2517 
2518 // This method sets the use count within a basic block.  We will ignore all
2519 // uses outside the current basic block.  As we are doing a backwards walk,
2520 // any node we reach that has a use count of 0 may be scheduled.  This also
2521 // avoids the problem of cyclic references from phi nodes, as long as phi
2522 // nodes are at the front of the basic block.  This method also initializes
2523 // the available list to the set of instructions that have no uses within this
2524 // basic block.
2525 void Scheduling::ComputeUseCount(const Block *bb) {
2526 #ifndef PRODUCT
2527   if (_cfg-&gt;C-&gt;trace_opto_output())
2528     tty-&gt;print(&quot;# -&gt; ComputeUseCount\n&quot;);
2529 #endif
2530 
2531   // Clear the list of available and scheduled instructions, just in case
2532   _available.clear();
2533   _scheduled.clear();
2534 
2535   // No delay slot specified
2536   _unconditional_delay_slot = NULL;
2537 
2538 #ifdef ASSERT
2539   for( uint i=0; i &lt; bb-&gt;number_of_nodes(); i++ )
2540     assert( _uses[bb-&gt;get_node(i)-&gt;_idx] == 0, &quot;_use array not clean&quot; );
2541 #endif
2542 
2543   // Force the _uses count to never go to zero for unscheduable pieces
2544   // of the block
2545   for( uint k = 0; k &lt; _bb_start; k++ )
2546     _uses[bb-&gt;get_node(k)-&gt;_idx] = 1;
2547   for( uint l = _bb_end; l &lt; bb-&gt;number_of_nodes(); l++ )
2548     _uses[bb-&gt;get_node(l)-&gt;_idx] = 1;
2549 
2550   // Iterate backwards over the instructions in the block.  Don&#39;t count the
2551   // branch projections at end or the block header instructions.
2552   for( uint j = _bb_end-1; j &gt;= _bb_start; j-- ) {
2553     Node *n = bb-&gt;get_node(j);
2554     if( n-&gt;is_Proj() ) continue; // Projections handled another way
2555 
2556     // Account for all uses
2557     for ( uint k = 0; k &lt; n-&gt;len(); k++ ) {
2558       Node *inp = n-&gt;in(k);
2559       if (!inp) continue;
2560       assert(inp != n, &quot;no cycles allowed&quot; );
2561       if (_cfg-&gt;get_block_for_node(inp) == bb) { // Block-local use?
2562         if (inp-&gt;is_Proj()) { // Skip through Proj&#39;s
2563           inp = inp-&gt;in(0);
2564         }
2565         ++_uses[inp-&gt;_idx];     // Count 1 block-local use
2566       }
2567     }
2568 
2569     // If this instruction has a 0 use count, then it is available
2570     if (!_uses[n-&gt;_idx]) {
2571       _current_latency[n-&gt;_idx] = _bundle_cycle_number;
2572       AddNodeToAvailableList(n);
2573     }
2574 
2575 #ifndef PRODUCT
2576     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2577       tty-&gt;print(&quot;#   uses: %3d: &quot;, _uses[n-&gt;_idx]);
2578       n-&gt;dump();
2579     }
2580 #endif
2581   }
2582 
2583 #ifndef PRODUCT
2584   if (_cfg-&gt;C-&gt;trace_opto_output())
2585     tty-&gt;print(&quot;# &lt;- ComputeUseCount\n&quot;);
2586 #endif
2587 }
2588 
2589 // This routine performs scheduling on each basic block in reverse order,
2590 // using instruction latencies and taking into account function unit
2591 // availability.
2592 void Scheduling::DoScheduling() {
2593 #ifndef PRODUCT
2594   if (_cfg-&gt;C-&gt;trace_opto_output())
2595     tty-&gt;print(&quot;# -&gt; DoScheduling\n&quot;);
2596 #endif
2597 
2598   Block *succ_bb = NULL;
2599   Block *bb;
2600   Compile* C = Compile::current();
2601 
2602   // Walk over all the basic blocks in reverse order
2603   for (int i = _cfg-&gt;number_of_blocks() - 1; i &gt;= 0; succ_bb = bb, i--) {
2604     bb = _cfg-&gt;get_block(i);
2605 
2606 #ifndef PRODUCT
2607     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2608       tty-&gt;print(&quot;#  Schedule BB#%03d (initial)\n&quot;, i);
2609       for (uint j = 0; j &lt; bb-&gt;number_of_nodes(); j++) {
2610         bb-&gt;get_node(j)-&gt;dump();
2611       }
2612     }
2613 #endif
2614 
2615     // On the head node, skip processing
2616     if (bb == _cfg-&gt;get_root_block()) {
2617       continue;
2618     }
2619 
2620     // Skip empty, connector blocks
2621     if (bb-&gt;is_connector())
2622       continue;
2623 
2624     // If the following block is not the sole successor of
2625     // this one, then reset the pipeline information
2626     if (bb-&gt;_num_succs != 1 || bb-&gt;non_connector_successor(0) != succ_bb) {
2627 #ifndef PRODUCT
2628       if (_cfg-&gt;C-&gt;trace_opto_output()) {
2629         tty-&gt;print(&quot;*** bundle start of next BB, node %d, for %d instructions\n&quot;,
2630                    _next_node-&gt;_idx, _bundle_instr_count);
2631       }
2632 #endif
2633       step_and_clear();
2634     }
2635 
2636     // Leave untouched the starting instruction, any Phis, a CreateEx node
2637     // or Top.  bb-&gt;get_node(_bb_start) is the first schedulable instruction.
2638     _bb_end = bb-&gt;number_of_nodes()-1;
2639     for( _bb_start=1; _bb_start &lt;= _bb_end; _bb_start++ ) {
2640       Node *n = bb-&gt;get_node(_bb_start);
2641       // Things not matched, like Phinodes and ProjNodes don&#39;t get scheduled.
2642       // Also, MachIdealNodes do not get scheduled
2643       if( !n-&gt;is_Mach() ) continue;     // Skip non-machine nodes
2644       MachNode *mach = n-&gt;as_Mach();
2645       int iop = mach-&gt;ideal_Opcode();
2646       if( iop == Op_CreateEx ) continue; // CreateEx is pinned
2647       if( iop == Op_Con ) continue;      // Do not schedule Top
2648       if( iop == Op_Node &amp;&amp;     // Do not schedule PhiNodes, ProjNodes
2649           mach-&gt;pipeline() == MachNode::pipeline_class() &amp;&amp;
2650           !n-&gt;is_SpillCopy() &amp;&amp; !n-&gt;is_MachMerge() )  // Breakpoints, Prolog, etc
2651         continue;
2652       break;                    // Funny loop structure to be sure...
2653     }
2654     // Compute last &quot;interesting&quot; instruction in block - last instruction we
2655     // might schedule.  _bb_end points just after last schedulable inst.  We
2656     // normally schedule conditional branches (despite them being forced last
2657     // in the block), because they have delay slots we can fill.  Calls all
2658     // have their delay slots filled in the template expansions, so we don&#39;t
2659     // bother scheduling them.
2660     Node *last = bb-&gt;get_node(_bb_end);
2661     // Ignore trailing NOPs.
2662     while (_bb_end &gt; 0 &amp;&amp; last-&gt;is_Mach() &amp;&amp;
2663            last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Con) {
2664       last = bb-&gt;get_node(--_bb_end);
2665     }
2666     assert(!last-&gt;is_Mach() || last-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con, &quot;&quot;);
2667     if( last-&gt;is_Catch() ||
2668         (last-&gt;is_Mach() &amp;&amp; last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Halt) ) {
2669       // There might be a prior call.  Skip it.
2670       while (_bb_start &lt; _bb_end &amp;&amp; bb-&gt;get_node(--_bb_end)-&gt;is_MachProj());
2671     } else if( last-&gt;is_MachNullCheck() ) {
2672       // Backup so the last null-checked memory instruction is
2673       // outside the schedulable range. Skip over the nullcheck,
2674       // projection, and the memory nodes.
2675       Node *mem = last-&gt;in(1);
2676       do {
2677         _bb_end--;
2678       } while (mem != bb-&gt;get_node(_bb_end));
2679     } else {
2680       // Set _bb_end to point after last schedulable inst.
2681       _bb_end++;
2682     }
2683 
2684     assert( _bb_start &lt;= _bb_end, &quot;inverted block ends&quot; );
2685 
2686     // Compute the register antidependencies for the basic block
2687     ComputeRegisterAntidependencies(bb);
2688     if (C-&gt;failing())  return;  // too many D-U pinch points
2689 
2690     // Compute intra-bb latencies for the nodes
2691     ComputeLocalLatenciesForward(bb);
2692 
2693     // Compute the usage within the block, and set the list of all nodes
2694     // in the block that have no uses within the block.
2695     ComputeUseCount(bb);
2696 
2697     // Schedule the remaining instructions in the block
2698     while ( _available.size() &gt; 0 ) {
2699       Node *n = ChooseNodeToBundle();
2700       guarantee(n != NULL, &quot;no nodes available&quot;);
2701       AddNodeToBundle(n,bb);
2702     }
2703 
2704     assert( _scheduled.size() == _bb_end - _bb_start, &quot;wrong number of instructions&quot; );
2705 #ifdef ASSERT
2706     for( uint l = _bb_start; l &lt; _bb_end; l++ ) {
2707       Node *n = bb-&gt;get_node(l);
2708       uint m;
2709       for( m = 0; m &lt; _bb_end-_bb_start; m++ )
2710         if( _scheduled[m] == n )
2711           break;
2712       assert( m &lt; _bb_end-_bb_start, &quot;instruction missing in schedule&quot; );
2713     }
2714 #endif
2715 
2716     // Now copy the instructions (in reverse order) back to the block
2717     for ( uint k = _bb_start; k &lt; _bb_end; k++ )
2718       bb-&gt;map_node(_scheduled[_bb_end-k-1], k);
2719 
2720 #ifndef PRODUCT
2721     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2722       tty-&gt;print(&quot;#  Schedule BB#%03d (final)\n&quot;, i);
2723       uint current = 0;
2724       for (uint j = 0; j &lt; bb-&gt;number_of_nodes(); j++) {
2725         Node *n = bb-&gt;get_node(j);
2726         if( valid_bundle_info(n) ) {
2727           Bundle *bundle = node_bundling(n);
2728           if (bundle-&gt;instr_count() &gt; 0 || bundle-&gt;flags() &gt; 0) {
2729             tty-&gt;print(&quot;*** Bundle: &quot;);
2730             bundle-&gt;dump();
2731           }
2732           n-&gt;dump();
2733         }
2734       }
2735     }
2736 #endif
2737 #ifdef ASSERT
2738     verify_good_schedule(bb,&quot;after block local scheduling&quot;);
2739 #endif
2740   }
2741 
2742 #ifndef PRODUCT
2743   if (_cfg-&gt;C-&gt;trace_opto_output())
2744     tty-&gt;print(&quot;# &lt;- DoScheduling\n&quot;);
2745 #endif
2746 
2747   // Record final node-bundling array location
2748   _regalloc-&gt;C-&gt;output()-&gt;set_node_bundling_base(_node_bundling_base);
2749 
2750 } // end DoScheduling
2751 
2752 // Verify that no live-range used in the block is killed in the block by a
2753 // wrong DEF.  This doesn&#39;t verify live-ranges that span blocks.
2754 
2755 // Check for edge existence.  Used to avoid adding redundant precedence edges.
2756 static bool edge_from_to( Node *from, Node *to ) {
2757   for( uint i=0; i&lt;from-&gt;len(); i++ )
2758     if( from-&gt;in(i) == to )
2759       return true;
2760   return false;
2761 }
2762 
2763 #ifdef ASSERT
2764 void Scheduling::verify_do_def( Node *n, OptoReg::Name def, const char *msg ) {
2765   // Check for bad kills
2766   if( OptoReg::is_valid(def) ) { // Ignore stores &amp; control flow
2767     Node *prior_use = _reg_node[def];
2768     if( prior_use &amp;&amp; !edge_from_to(prior_use,n) ) {
2769       tty-&gt;print(&quot;%s = &quot;,OptoReg::as_VMReg(def)-&gt;name());
2770       n-&gt;dump();
2771       tty-&gt;print_cr(&quot;...&quot;);
2772       prior_use-&gt;dump();
2773       assert(edge_from_to(prior_use,n), &quot;%s&quot;, msg);
2774     }
2775     _reg_node.map(def,NULL); // Kill live USEs
2776   }
2777 }
2778 
2779 void Scheduling::verify_good_schedule( Block *b, const char *msg ) {
2780 
2781   // Zap to something reasonable for the verify code
2782   _reg_node.clear();
2783 
2784   // Walk over the block backwards.  Check to make sure each DEF doesn&#39;t
2785   // kill a live value (other than the one it&#39;s supposed to).  Add each
2786   // USE to the live set.
2787   for( uint i = b-&gt;number_of_nodes()-1; i &gt;= _bb_start; i-- ) {
2788     Node *n = b-&gt;get_node(i);
2789     int n_op = n-&gt;Opcode();
2790     if( n_op == Op_MachProj &amp;&amp; n-&gt;ideal_reg() == MachProjNode::fat_proj ) {
2791       // Fat-proj kills a slew of registers
2792       RegMask rm = n-&gt;out_RegMask();// Make local copy
2793       while( rm.is_NotEmpty() ) {
2794         OptoReg::Name kill = rm.find_first_elem();
2795         rm.Remove(kill);
2796         verify_do_def( n, kill, msg );
2797       }
2798     } else if( n_op != Op_Node ) { // Avoid brand new antidependence nodes
2799       // Get DEF&#39;d registers the normal way
2800       verify_do_def( n, _regalloc-&gt;get_reg_first(n), msg );
2801       verify_do_def( n, _regalloc-&gt;get_reg_second(n), msg );
2802     }
2803 
2804     // Now make all USEs live
2805     for( uint i=1; i&lt;n-&gt;req(); i++ ) {
2806       Node *def = n-&gt;in(i);
2807       assert(def != 0, &quot;input edge required&quot;);
2808       OptoReg::Name reg_lo = _regalloc-&gt;get_reg_first(def);
2809       OptoReg::Name reg_hi = _regalloc-&gt;get_reg_second(def);
2810       if( OptoReg::is_valid(reg_lo) ) {
2811         assert(!_reg_node[reg_lo] || edge_from_to(_reg_node[reg_lo],def), &quot;%s&quot;, msg);
2812         _reg_node.map(reg_lo,n);
2813       }
2814       if( OptoReg::is_valid(reg_hi) ) {
2815         assert(!_reg_node[reg_hi] || edge_from_to(_reg_node[reg_hi],def), &quot;%s&quot;, msg);
2816         _reg_node.map(reg_hi,n);
2817       }
2818     }
2819 
2820   }
2821 
2822   // Zap to something reasonable for the Antidependence code
2823   _reg_node.clear();
2824 }
2825 #endif
2826 
2827 // Conditionally add precedence edges.  Avoid putting edges on Projs.
2828 static void add_prec_edge_from_to( Node *from, Node *to ) {
2829   if( from-&gt;is_Proj() ) {       // Put precedence edge on Proj&#39;s input
2830     assert( from-&gt;req() == 1 &amp;&amp; (from-&gt;len() == 1 || from-&gt;in(1)==0), &quot;no precedence edges on projections&quot; );
2831     from = from-&gt;in(0);
2832   }
2833   if( from != to &amp;&amp;             // No cycles (for things like LD L0,[L0+4] )
2834       !edge_from_to( from, to ) ) // Avoid duplicate edge
2835     from-&gt;add_prec(to);
2836 }
2837 
2838 void Scheduling::anti_do_def( Block *b, Node *def, OptoReg::Name def_reg, int is_def ) {
2839   if( !OptoReg::is_valid(def_reg) ) // Ignore stores &amp; control flow
2840     return;
2841 
2842   Node *pinch = _reg_node[def_reg]; // Get pinch point
2843   if ((pinch == NULL) || _cfg-&gt;get_block_for_node(pinch) != b || // No pinch-point yet?
2844       is_def ) {    // Check for a true def (not a kill)
2845     _reg_node.map(def_reg,def); // Record def/kill as the optimistic pinch-point
2846     return;
2847   }
2848 
2849   Node *kill = def;             // Rename &#39;def&#39; to more descriptive &#39;kill&#39;
2850   debug_only( def = (Node*)((intptr_t)0xdeadbeef); )
2851 
2852   // After some number of kills there _may_ be a later def
2853   Node *later_def = NULL;
2854 
2855   Compile* C = Compile::current();
2856 
2857   // Finding a kill requires a real pinch-point.
2858   // Check for not already having a pinch-point.
2859   // Pinch points are Op_Node&#39;s.
2860   if( pinch-&gt;Opcode() != Op_Node ) { // Or later-def/kill as pinch-point?
2861     later_def = pinch;            // Must be def/kill as optimistic pinch-point
2862     if ( _pinch_free_list.size() &gt; 0) {
2863       pinch = _pinch_free_list.pop();
2864     } else {
2865       pinch = new Node(1); // Pinch point to-be
2866     }
2867     if (pinch-&gt;_idx &gt;= _regalloc-&gt;node_regs_max_index()) {
2868       _cfg-&gt;C-&gt;record_method_not_compilable(&quot;too many D-U pinch points&quot;);
2869       return;
2870     }
2871     _cfg-&gt;map_node_to_block(pinch, b);      // Pretend it&#39;s valid in this block (lazy init)
2872     _reg_node.map(def_reg,pinch); // Record pinch-point
2873     //regalloc()-&gt;set_bad(pinch-&gt;_idx); // Already initialized this way.
2874     if( later_def-&gt;outcnt() == 0 || later_def-&gt;ideal_reg() == MachProjNode::fat_proj ) { // Distinguish def from kill
2875       pinch-&gt;init_req(0, C-&gt;top());     // set not NULL for the next call
2876       add_prec_edge_from_to(later_def,pinch); // Add edge from kill to pinch
2877       later_def = NULL;           // and no later def
2878     }
2879     pinch-&gt;set_req(0,later_def);  // Hook later def so we can find it
2880   } else {                        // Else have valid pinch point
2881     if( pinch-&gt;in(0) )            // If there is a later-def
2882       later_def = pinch-&gt;in(0);   // Get it
2883   }
2884 
2885   // Add output-dependence edge from later def to kill
2886   if( later_def )               // If there is some original def
2887     add_prec_edge_from_to(later_def,kill); // Add edge from def to kill
2888 
2889   // See if current kill is also a use, and so is forced to be the pinch-point.
2890   if( pinch-&gt;Opcode() == Op_Node ) {
2891     Node *uses = kill-&gt;is_Proj() ? kill-&gt;in(0) : kill;
2892     for( uint i=1; i&lt;uses-&gt;req(); i++ ) {
2893       if( _regalloc-&gt;get_reg_first(uses-&gt;in(i)) == def_reg ||
2894           _regalloc-&gt;get_reg_second(uses-&gt;in(i)) == def_reg ) {
2895         // Yes, found a use/kill pinch-point
2896         pinch-&gt;set_req(0,NULL);  //
2897         pinch-&gt;replace_by(kill); // Move anti-dep edges up
2898         pinch = kill;
2899         _reg_node.map(def_reg,pinch);
2900         return;
2901       }
2902     }
2903   }
2904 
2905   // Add edge from kill to pinch-point
2906   add_prec_edge_from_to(kill,pinch);
2907 }
2908 
2909 void Scheduling::anti_do_use( Block *b, Node *use, OptoReg::Name use_reg ) {
2910   if( !OptoReg::is_valid(use_reg) ) // Ignore stores &amp; control flow
2911     return;
2912   Node *pinch = _reg_node[use_reg]; // Get pinch point
2913   // Check for no later def_reg/kill in block
2914   if ((pinch != NULL) &amp;&amp; _cfg-&gt;get_block_for_node(pinch) == b &amp;&amp;
2915       // Use has to be block-local as well
2916       _cfg-&gt;get_block_for_node(use) == b) {
2917     if( pinch-&gt;Opcode() == Op_Node &amp;&amp; // Real pinch-point (not optimistic?)
2918         pinch-&gt;req() == 1 ) {   // pinch not yet in block?
2919       pinch-&gt;del_req(0);        // yank pointer to later-def, also set flag
2920       // Insert the pinch-point in the block just after the last use
2921       b-&gt;insert_node(pinch, b-&gt;find_node(use) + 1);
2922       _bb_end++;                // Increase size scheduled region in block
2923     }
2924 
2925     add_prec_edge_from_to(pinch,use);
2926   }
2927 }
2928 
2929 // We insert antidependences between the reads and following write of
2930 // allocated registers to prevent illegal code motion. Hopefully, the
2931 // number of added references should be fairly small, especially as we
2932 // are only adding references within the current basic block.
2933 void Scheduling::ComputeRegisterAntidependencies(Block *b) {
2934 
2935 #ifdef ASSERT
2936   verify_good_schedule(b,&quot;before block local scheduling&quot;);
2937 #endif
2938 
2939   // A valid schedule, for each register independently, is an endless cycle
2940   // of: a def, then some uses (connected to the def by true dependencies),
2941   // then some kills (defs with no uses), finally the cycle repeats with a new
2942   // def.  The uses are allowed to float relative to each other, as are the
2943   // kills.  No use is allowed to slide past a kill (or def).  This requires
2944   // antidependencies between all uses of a single def and all kills that
2945   // follow, up to the next def.  More edges are redundant, because later defs
2946   // &amp; kills are already serialized with true or antidependencies.  To keep
2947   // the edge count down, we add a &#39;pinch point&#39; node if there&#39;s more than
2948   // one use or more than one kill/def.
2949 
2950   // We add dependencies in one bottom-up pass.
2951 
2952   // For each instruction we handle it&#39;s DEFs/KILLs, then it&#39;s USEs.
2953 
2954   // For each DEF/KILL, we check to see if there&#39;s a prior DEF/KILL for this
2955   // register.  If not, we record the DEF/KILL in _reg_node, the
2956   // register-to-def mapping.  If there is a prior DEF/KILL, we insert a
2957   // &quot;pinch point&quot;, a new Node that&#39;s in the graph but not in the block.
2958   // We put edges from the prior and current DEF/KILLs to the pinch point.
2959   // We put the pinch point in _reg_node.  If there&#39;s already a pinch point
2960   // we merely add an edge from the current DEF/KILL to the pinch point.
2961 
2962   // After doing the DEF/KILLs, we handle USEs.  For each used register, we
2963   // put an edge from the pinch point to the USE.
2964 
2965   // To be expedient, the _reg_node array is pre-allocated for the whole
2966   // compilation.  _reg_node is lazily initialized; it either contains a NULL,
2967   // or a valid def/kill/pinch-point, or a leftover node from some prior
2968   // block.  Leftover node from some prior block is treated like a NULL (no
2969   // prior def, so no anti-dependence needed).  Valid def is distinguished by
2970   // it being in the current block.
2971   bool fat_proj_seen = false;
2972   uint last_safept = _bb_end-1;
2973   Node* end_node         = (_bb_end-1 &gt;= _bb_start) ? b-&gt;get_node(last_safept) : NULL;
2974   Node* last_safept_node = end_node;
2975   for( uint i = _bb_end-1; i &gt;= _bb_start; i-- ) {
2976     Node *n = b-&gt;get_node(i);
2977     int is_def = n-&gt;outcnt();   // def if some uses prior to adding precedence edges
2978     if( n-&gt;is_MachProj() &amp;&amp; n-&gt;ideal_reg() == MachProjNode::fat_proj ) {
2979       // Fat-proj kills a slew of registers
2980       // This can add edges to &#39;n&#39; and obscure whether or not it was a def,
2981       // hence the is_def flag.
2982       fat_proj_seen = true;
2983       RegMask rm = n-&gt;out_RegMask();// Make local copy
2984       while( rm.is_NotEmpty() ) {
2985         OptoReg::Name kill = rm.find_first_elem();
2986         rm.Remove(kill);
2987         anti_do_def( b, n, kill, is_def );
2988       }
2989     } else {
2990       // Get DEF&#39;d registers the normal way
2991       anti_do_def( b, n, _regalloc-&gt;get_reg_first(n), is_def );
2992       anti_do_def( b, n, _regalloc-&gt;get_reg_second(n), is_def );
2993     }
2994 
2995     // Kill projections on a branch should appear to occur on the
2996     // branch, not afterwards, so grab the masks from the projections
2997     // and process them.
2998     if (n-&gt;is_MachBranch() || (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Jump)) {
2999       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3000         Node* use = n-&gt;fast_out(i);
3001         if (use-&gt;is_Proj()) {
3002           RegMask rm = use-&gt;out_RegMask();// Make local copy
3003           while( rm.is_NotEmpty() ) {
3004             OptoReg::Name kill = rm.find_first_elem();
3005             rm.Remove(kill);
3006             anti_do_def( b, n, kill, false );
3007           }
3008         }
3009       }
3010     }
3011 
3012     // Check each register used by this instruction for a following DEF/KILL
3013     // that must occur afterward and requires an anti-dependence edge.
3014     for( uint j=0; j&lt;n-&gt;req(); j++ ) {
3015       Node *def = n-&gt;in(j);
3016       if( def ) {
3017         assert( !def-&gt;is_MachProj() || def-&gt;ideal_reg() != MachProjNode::fat_proj, &quot;&quot; );
3018         anti_do_use( b, n, _regalloc-&gt;get_reg_first(def) );
3019         anti_do_use( b, n, _regalloc-&gt;get_reg_second(def) );
3020       }
3021     }
3022     // Do not allow defs of new derived values to float above GC
3023     // points unless the base is definitely available at the GC point.
3024 
3025     Node *m = b-&gt;get_node(i);
3026 
3027     // Add precedence edge from following safepoint to use of derived pointer
3028     if( last_safept_node != end_node &amp;&amp;
3029         m != last_safept_node) {
3030       for (uint k = 1; k &lt; m-&gt;req(); k++) {
3031         const Type *t = m-&gt;in(k)-&gt;bottom_type();
3032         if( t-&gt;isa_oop_ptr() &amp;&amp;
3033             t-&gt;is_ptr()-&gt;offset() != 0 ) {
3034           last_safept_node-&gt;add_prec( m );
3035           break;
3036         }
3037       }
3038     }
3039 
3040     if( n-&gt;jvms() ) {           // Precedence edge from derived to safept
3041       // Check if last_safept_node was moved by pinch-point insertion in anti_do_use()
3042       if( b-&gt;get_node(last_safept) != last_safept_node ) {
3043         last_safept = b-&gt;find_node(last_safept_node);
3044       }
3045       for( uint j=last_safept; j &gt; i; j-- ) {
3046         Node *mach = b-&gt;get_node(j);
3047         if( mach-&gt;is_Mach() &amp;&amp; mach-&gt;as_Mach()-&gt;ideal_Opcode() == Op_AddP )
3048           mach-&gt;add_prec( n );
3049       }
3050       last_safept = i;
3051       last_safept_node = m;
3052     }
3053   }
3054 
3055   if (fat_proj_seen) {
3056     // Garbage collect pinch nodes that were not consumed.
3057     // They are usually created by a fat kill MachProj for a call.
3058     garbage_collect_pinch_nodes();
3059   }
3060 }
3061 
3062 // Garbage collect pinch nodes for reuse by other blocks.
3063 //
3064 // The block scheduler&#39;s insertion of anti-dependence
3065 // edges creates many pinch nodes when the block contains
3066 // 2 or more Calls.  A pinch node is used to prevent a
3067 // combinatorial explosion of edges.  If a set of kills for a
3068 // register is anti-dependent on a set of uses (or defs), rather
3069 // than adding an edge in the graph between each pair of kill
3070 // and use (or def), a pinch is inserted between them:
3071 //
3072 //            use1   use2  use3
3073 //                \   |   /
3074 //                 \  |  /
3075 //                  pinch
3076 //                 /  |  \
3077 //                /   |   \
3078 //            kill1 kill2 kill3
3079 //
3080 // One pinch node is created per register killed when
3081 // the second call is encountered during a backwards pass
3082 // over the block.  Most of these pinch nodes are never
3083 // wired into the graph because the register is never
3084 // used or def&#39;ed in the block.
3085 //
3086 void Scheduling::garbage_collect_pinch_nodes() {
3087 #ifndef PRODUCT
3088   if (_cfg-&gt;C-&gt;trace_opto_output()) tty-&gt;print(&quot;Reclaimed pinch nodes:&quot;);
3089 #endif
3090   int trace_cnt = 0;
3091   for (uint k = 0; k &lt; _reg_node.Size(); k++) {
3092     Node* pinch = _reg_node[k];
3093     if ((pinch != NULL) &amp;&amp; pinch-&gt;Opcode() == Op_Node &amp;&amp;
3094         // no predecence input edges
3095         (pinch-&gt;req() == pinch-&gt;len() || pinch-&gt;in(pinch-&gt;req()) == NULL) ) {
3096       cleanup_pinch(pinch);
3097       _pinch_free_list.push(pinch);
3098       _reg_node.map(k, NULL);
3099 #ifndef PRODUCT
3100       if (_cfg-&gt;C-&gt;trace_opto_output()) {
3101         trace_cnt++;
3102         if (trace_cnt &gt; 40) {
3103           tty-&gt;print(&quot;\n&quot;);
3104           trace_cnt = 0;
3105         }
3106         tty-&gt;print(&quot; %d&quot;, pinch-&gt;_idx);
3107       }
3108 #endif
3109     }
3110   }
3111 #ifndef PRODUCT
3112   if (_cfg-&gt;C-&gt;trace_opto_output()) tty-&gt;print(&quot;\n&quot;);
3113 #endif
3114 }
3115 
3116 // Clean up a pinch node for reuse.
3117 void Scheduling::cleanup_pinch( Node *pinch ) {
3118   assert (pinch &amp;&amp; pinch-&gt;Opcode() == Op_Node &amp;&amp; pinch-&gt;req() == 1, &quot;just checking&quot;);
3119 
3120   for (DUIterator_Last imin, i = pinch-&gt;last_outs(imin); i &gt;= imin; ) {
3121     Node* use = pinch-&gt;last_out(i);
3122     uint uses_found = 0;
3123     for (uint j = use-&gt;req(); j &lt; use-&gt;len(); j++) {
3124       if (use-&gt;in(j) == pinch) {
3125         use-&gt;rm_prec(j);
3126         uses_found++;
3127       }
3128     }
3129     assert(uses_found &gt; 0, &quot;must be a precedence edge&quot;);
3130     i -= uses_found;    // we deleted 1 or more copies of this edge
3131   }
3132   // May have a later_def entry
3133   pinch-&gt;set_req(0, NULL);
3134 }
3135 
3136 #ifndef PRODUCT
3137 
3138 void Scheduling::dump_available() const {
3139   tty-&gt;print(&quot;#Availist  &quot;);
3140   for (uint i = 0; i &lt; _available.size(); i++)
3141     tty-&gt;print(&quot; N%d/l%d&quot;, _available[i]-&gt;_idx,_current_latency[_available[i]-&gt;_idx]);
3142   tty-&gt;cr();
3143 }
3144 
3145 // Print Scheduling Statistics
3146 void Scheduling::print_statistics() {
3147   // Print the size added by nops for bundling
3148   tty-&gt;print(&quot;Nops added %d bytes to total of %d bytes&quot;,
3149              _total_nop_size, _total_method_size);
3150   if (_total_method_size &gt; 0)
3151     tty-&gt;print(&quot;, for %.2f%%&quot;,
3152                ((double)_total_nop_size) / ((double) _total_method_size) * 100.0);
3153   tty-&gt;print(&quot;\n&quot;);
3154 
3155   // Print the number of branch shadows filled
3156   if (Pipeline::_branch_has_delay_slot) {
3157     tty-&gt;print(&quot;Of %d branches, %d had unconditional delay slots filled&quot;,
3158                _total_branches, _total_unconditional_delays);
3159     if (_total_branches &gt; 0)
3160       tty-&gt;print(&quot;, for %.2f%%&quot;,
3161                  ((double)_total_unconditional_delays) / ((double)_total_branches) * 100.0);
3162     tty-&gt;print(&quot;\n&quot;);
3163   }
3164 
3165   uint total_instructions = 0, total_bundles = 0;
3166 
3167   for (uint i = 1; i &lt;= Pipeline::_max_instrs_per_cycle; i++) {
3168     uint bundle_count   = _total_instructions_per_bundle[i];
3169     total_instructions += bundle_count * i;
3170     total_bundles      += bundle_count;
3171   }
3172 
3173   if (total_bundles &gt; 0)
3174     tty-&gt;print(&quot;Average ILP (excluding nops) is %.2f\n&quot;,
3175                ((double)total_instructions) / ((double)total_bundles));
3176 }
3177 #endif
3178 
3179 //-----------------------init_scratch_buffer_blob------------------------------
3180 // Construct a temporary BufferBlob and cache it for this compile.
3181 void PhaseOutput::init_scratch_buffer_blob(int const_size) {
3182   // If there is already a scratch buffer blob allocated and the
3183   // constant section is big enough, use it.  Otherwise free the
3184   // current and allocate a new one.
3185   BufferBlob* blob = scratch_buffer_blob();
3186   if ((blob != NULL) &amp;&amp; (const_size &lt;= _scratch_const_size)) {
3187     // Use the current blob.
3188   } else {
3189     if (blob != NULL) {
3190       BufferBlob::free(blob);
3191     }
3192 
3193     ResourceMark rm;
3194     _scratch_const_size = const_size;
3195     int size = C2Compiler::initial_code_buffer_size(const_size);
3196     blob = BufferBlob::create(&quot;Compile::scratch_buffer&quot;, size);
3197     // Record the buffer blob for next time.
3198     set_scratch_buffer_blob(blob);
3199     // Have we run out of code space?
3200     if (scratch_buffer_blob() == NULL) {
3201       // Let CompilerBroker disable further compilations.
3202       C-&gt;record_failure(&quot;Not enough space for scratch buffer in CodeCache&quot;);
3203       return;
3204     }
3205   }
3206 
3207   // Initialize the relocation buffers
3208   relocInfo* locs_buf = (relocInfo*) blob-&gt;content_end() - MAX_locs_size;
3209   set_scratch_locs_memory(locs_buf);
3210 }
3211 
3212 
3213 //-----------------------scratch_emit_size-------------------------------------
3214 // Helper function that computes size by emitting code
3215 uint PhaseOutput::scratch_emit_size(const Node* n) {
3216   // Start scratch_emit_size section.
3217   set_in_scratch_emit_size(true);
3218 
3219   // Emit into a trash buffer and count bytes emitted.
3220   // This is a pretty expensive way to compute a size,
3221   // but it works well enough if seldom used.
3222   // All common fixed-size instructions are given a size
3223   // method by the AD file.
3224   // Note that the scratch buffer blob and locs memory are
3225   // allocated at the beginning of the compile task, and
3226   // may be shared by several calls to scratch_emit_size.
3227   // The allocation of the scratch buffer blob is particularly
3228   // expensive, since it has to grab the code cache lock.
3229   BufferBlob* blob = this-&gt;scratch_buffer_blob();
3230   assert(blob != NULL, &quot;Initialize BufferBlob at start&quot;);
3231   assert(blob-&gt;size() &gt; MAX_inst_size, &quot;sanity&quot;);
3232   relocInfo* locs_buf = scratch_locs_memory();
3233   address blob_begin = blob-&gt;content_begin();
3234   address blob_end   = (address)locs_buf;
3235   assert(blob-&gt;contains(blob_end), &quot;sanity&quot;);
3236   CodeBuffer buf(blob_begin, blob_end - blob_begin);
3237   buf.initialize_consts_size(_scratch_const_size);
3238   buf.initialize_stubs_size(MAX_stubs_size);
3239   assert(locs_buf != NULL, &quot;sanity&quot;);
3240   int lsize = MAX_locs_size / 3;
3241   buf.consts()-&gt;initialize_shared_locs(&amp;locs_buf[lsize * 0], lsize);
3242   buf.insts()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 1], lsize);
3243   buf.stubs()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 2], lsize);
3244   // Mark as scratch buffer.
3245   buf.consts()-&gt;set_scratch_emit();
3246   buf.insts()-&gt;set_scratch_emit();
3247   buf.stubs()-&gt;set_scratch_emit();
3248 
3249   // Do the emission.
3250 
3251   Label fakeL; // Fake label for branch instructions.
3252   Label*   saveL = NULL;
3253   uint save_bnum = 0;
3254   bool is_branch = n-&gt;is_MachBranch();
3255   if (is_branch) {
3256     MacroAssembler masm(&amp;buf);
3257     masm.bind(fakeL);
3258     n-&gt;as_MachBranch()-&gt;save_label(&amp;saveL, &amp;save_bnum);
3259     n-&gt;as_MachBranch()-&gt;label_set(&amp;fakeL, 0);
3260   }
3261   n-&gt;emit(buf, C-&gt;regalloc());
3262 
3263   // Emitting into the scratch buffer should not fail
3264   assert (!C-&gt;failing(), &quot;Must not have pending failure. Reason is: %s&quot;, C-&gt;failure_reason());
3265 
3266   if (is_branch) // Restore label.
3267     n-&gt;as_MachBranch()-&gt;label_set(saveL, save_bnum);
3268 
3269   // End scratch_emit_size section.
3270   set_in_scratch_emit_size(false);
3271 
3272   return buf.insts_size();
3273 }
3274 
3275 void PhaseOutput::install() {
3276   if (!C-&gt;should_install_code()) {
3277     return;
3278   } else if (C-&gt;stub_function() != NULL) {
3279     install_stub(C-&gt;stub_name(),
3280                  C-&gt;save_argument_registers());
3281   } else {
3282     install_code(C-&gt;method(),
3283                  C-&gt;entry_bci(),
3284                  CompileBroker::compiler2(),
3285                  C-&gt;has_unsafe_access(),
3286                  SharedRuntime::is_wide_vector(C-&gt;max_vector_size()),
3287                  C-&gt;rtm_state());
3288   }
3289 }
3290 
3291 void PhaseOutput::install_code(ciMethod*         target,
3292                                int               entry_bci,
3293                                AbstractCompiler* compiler,
3294                                bool              has_unsafe_access,
3295                                bool              has_wide_vectors,
3296                                RTMState          rtm_state) {
3297   // Check if we want to skip execution of all compiled code.
3298   {
3299 #ifndef PRODUCT
3300     if (OptoNoExecute) {
3301       C-&gt;record_method_not_compilable(&quot;+OptoNoExecute&quot;);  // Flag as failed
3302       return;
3303     }
3304 #endif
3305     Compile::TracePhase tp(&quot;install_code&quot;, &amp;timers[_t_registerMethod]);
3306 
3307     if (C-&gt;is_osr_compilation()) {
3308       _code_offsets.set_value(CodeOffsets::Verified_Entry, 0);
3309       _code_offsets.set_value(CodeOffsets::OSR_Entry, _first_block_size);
3310     } else {
3311       _code_offsets.set_value(CodeOffsets::Verified_Entry, _first_block_size);
3312       _code_offsets.set_value(CodeOffsets::OSR_Entry, 0);
3313     }
3314 
3315     address* native_stubs = NULL;
3316     int num_stubs = 0;
3317     if (!C-&gt;native_stubs()-&gt;is_empty()) {
3318       num_stubs = C-&gt;native_stubs()-&gt;length();
3319       native_stubs = NEW_C_HEAP_ARRAY(address, num_stubs, mtInternal);
3320       for (int i = 0; i &lt; num_stubs; i++) {
3321         native_stubs[i] = C-&gt;native_stubs()-&gt;at(i);
3322       }
3323     }
3324 
3325     C-&gt;env()-&gt;register_method(target,
3326                                      entry_bci,
3327                                      &amp;_code_offsets,
3328                                      _orig_pc_slot_offset_in_bytes,
3329                                      code_buffer(),
3330                                      frame_size_in_words(),
3331                                      oop_map_set(),
3332                                      &amp;_handler_table,
3333                                      inc_table(),
3334                                      compiler,
3335                                      has_unsafe_access,
3336                                      SharedRuntime::is_wide_vector(C-&gt;max_vector_size()),
3337                                      C-&gt;rtm_state(),
3338                                      native_stubs,
3339                                      num_stubs);
3340 
3341     if (C-&gt;log() != NULL) { // Print code cache state into compiler log
3342       C-&gt;log()-&gt;code_cache_state();
3343     }
3344   }
3345 }
3346 void PhaseOutput::install_stub(const char* stub_name,
3347                                bool        caller_must_gc_arguments) {
3348   // Entry point will be accessed using stub_entry_point();
3349   if (code_buffer() == NULL) {
3350     Matcher::soft_match_failure();
3351   } else {
3352     if (PrintAssembly &amp;&amp; (WizardMode || Verbose))
3353       tty-&gt;print_cr(&quot;### Stub::%s&quot;, stub_name);
3354 
3355     if (!C-&gt;failing()) {
3356       assert(C-&gt;fixed_slots() == 0, &quot;no fixed slots used for runtime stubs&quot;);
3357 
3358       // Make the NMethod
3359       // For now we mark the frame as never safe for profile stackwalking
3360       RuntimeStub *rs = RuntimeStub::new_runtime_stub(stub_name,
3361                                                       code_buffer(),
3362                                                       CodeOffsets::frame_never_safe,
3363                                                       // _code_offsets.value(CodeOffsets::Frame_Complete),
3364                                                       frame_size_in_words(),
3365                                                       oop_map_set(),
3366                                                       caller_must_gc_arguments);
3367       assert(rs != NULL &amp;&amp; rs-&gt;is_runtime_stub(), &quot;sanity check&quot;);
3368 
3369       C-&gt;set_stub_entry_point(rs-&gt;entry_point());
3370     }
3371   }
3372 }
3373 
3374 // Support for bundling info
3375 Bundle* PhaseOutput::node_bundling(const Node *n) {
3376   assert(valid_bundle_info(n), &quot;oob&quot;);
3377   return &amp;_node_bundling_base[n-&gt;_idx];
3378 }
3379 
3380 bool PhaseOutput::valid_bundle_info(const Node *n) {
3381   return (_node_bundling_limit &gt; n-&gt;_idx);
3382 }
3383 
3384 //------------------------------frame_size_in_words-----------------------------
3385 // frame_slots in units of words
3386 int PhaseOutput::frame_size_in_words() const {
3387   // shift is 0 in LP32 and 1 in LP64
3388   const int shift = (LogBytesPerWord - LogBytesPerInt);
3389   int words = _frame_slots &gt;&gt; shift;
3390   assert( words &lt;&lt; shift == _frame_slots, &quot;frame size must be properly aligned in LP64&quot; );
3391   return words;
3392 }
3393 
3394 // To bang the stack of this compiled method we use the stack size
3395 // that the interpreter would need in case of a deoptimization. This
3396 // removes the need to bang the stack in the deoptimization blob which
3397 // in turn simplifies stack overflow handling.
3398 int PhaseOutput::bang_size_in_bytes() const {
3399   return MAX2(frame_size_in_bytes() + os::extra_bang_size_in_bytes(), C-&gt;interpreter_frame_size());
3400 }
3401 
3402 //------------------------------dump_asm---------------------------------------
3403 // Dump formatted assembly
3404 #if defined(SUPPORT_OPTO_ASSEMBLY)
3405 void PhaseOutput::dump_asm_on(outputStream* st, int* pcs, uint pc_limit) {
3406 
3407   int pc_digits = 3; // #chars required for pc
3408   int sb_chars  = 3; // #chars for &quot;start bundle&quot; indicator
3409   int tab_size  = 8;
3410   if (pcs != NULL) {
3411     int max_pc = 0;
3412     for (uint i = 0; i &lt; pc_limit; i++) {
3413       max_pc = (max_pc &lt; pcs[i]) ? pcs[i] : max_pc;
3414     }
3415     pc_digits  = ((max_pc &lt; 4096) ? 3 : ((max_pc &lt; 65536) ? 4 : ((max_pc &lt; 65536*256) ? 6 : 8))); // #chars required for pc
3416   }
3417   int prefix_len = ((pc_digits + sb_chars + tab_size - 1)/tab_size)*tab_size;
3418 
3419   bool cut_short = false;
3420   st-&gt;print_cr(&quot;#&quot;);
3421   st-&gt;print(&quot;#  &quot;);  C-&gt;tf()-&gt;dump_on(st);  st-&gt;cr();
3422   st-&gt;print_cr(&quot;#&quot;);
3423 
3424   // For all blocks
3425   int pc = 0x0;                 // Program counter
3426   char starts_bundle = &#39; &#39;;
3427   C-&gt;regalloc()-&gt;dump_frame();
3428 
3429   Node *n = NULL;
3430   for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {
3431     if (VMThread::should_terminate()) {
3432       cut_short = true;
3433       break;
3434     }
3435     Block* block = C-&gt;cfg()-&gt;get_block(i);
3436     if (block-&gt;is_connector() &amp;&amp; !Verbose) {
3437       continue;
3438     }
3439     n = block-&gt;head();
3440     if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {
3441       pc = pcs[n-&gt;_idx];
3442       st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);
3443     }
3444     st-&gt;fill_to(prefix_len);
3445     block-&gt;dump_head(C-&gt;cfg(), st);
3446     if (block-&gt;is_connector()) {
3447       st-&gt;fill_to(prefix_len);
3448       st-&gt;print_cr(&quot;# Empty connector block&quot;);
3449     } else if (block-&gt;num_preds() == 2 &amp;&amp; block-&gt;pred(1)-&gt;is_CatchProj() &amp;&amp; block-&gt;pred(1)-&gt;as_CatchProj()-&gt;_con == CatchProjNode::fall_through_index) {
3450       st-&gt;fill_to(prefix_len);
3451       st-&gt;print_cr(&quot;# Block is sole successor of call&quot;);
3452     }
3453 
3454     // For all instructions
3455     Node *delay = NULL;
3456     for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {
3457       if (VMThread::should_terminate()) {
3458         cut_short = true;
3459         break;
3460       }
3461       n = block-&gt;get_node(j);
3462       if (valid_bundle_info(n)) {
3463         Bundle* bundle = node_bundling(n);
3464         if (bundle-&gt;used_in_unconditional_delay()) {
3465           delay = n;
3466           continue;
3467         }
3468         if (bundle-&gt;starts_bundle()) {
3469           starts_bundle = &#39;+&#39;;
3470         }
3471       }
3472 
3473       if (WizardMode) {
3474         n-&gt;dump();
3475       }
3476 
3477       if( !n-&gt;is_Region() &amp;&amp;    // Dont print in the Assembly
3478           !n-&gt;is_Phi() &amp;&amp;       // a few noisely useless nodes
3479           !n-&gt;is_Proj() &amp;&amp;
3480           !n-&gt;is_MachTemp() &amp;&amp;
3481           !n-&gt;is_SafePointScalarObject() &amp;&amp;
3482           !n-&gt;is_Catch() &amp;&amp;     // Would be nice to print exception table targets
3483           !n-&gt;is_MergeMem() &amp;&amp;  // Not very interesting
3484           !n-&gt;is_top() &amp;&amp;       // Debug info table constants
3485           !(n-&gt;is_Con() &amp;&amp; !n-&gt;is_Mach())// Debug info table constants
3486           ) {
3487         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {
3488           pc = pcs[n-&gt;_idx];
3489           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);
3490         } else {
3491           st-&gt;fill_to(pc_digits);
3492         }
3493         st-&gt;print(&quot; %c &quot;, starts_bundle);
3494         starts_bundle = &#39; &#39;;
3495         st-&gt;fill_to(prefix_len);
3496         n-&gt;format(C-&gt;regalloc(), st);
3497         st-&gt;cr();
3498       }
3499 
3500       // If we have an instruction with a delay slot, and have seen a delay,
3501       // then back up and print it
3502       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;use_unconditional_delay()) {
3503         // Coverity finding - Explicit null dereferenced.
3504         guarantee(delay != NULL, &quot;no unconditional delay instruction&quot;);
3505         if (WizardMode) delay-&gt;dump();
3506 
3507         if (node_bundling(delay)-&gt;starts_bundle())
3508           starts_bundle = &#39;+&#39;;
3509         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {
3510           pc = pcs[n-&gt;_idx];
3511           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);
3512         } else {
3513           st-&gt;fill_to(pc_digits);
3514         }
3515         st-&gt;print(&quot; %c &quot;, starts_bundle);
3516         starts_bundle = &#39; &#39;;
3517         st-&gt;fill_to(prefix_len);
3518         delay-&gt;format(C-&gt;regalloc(), st);
3519         st-&gt;cr();
3520         delay = NULL;
3521       }
3522 
3523       // Dump the exception table as well
3524       if( n-&gt;is_Catch() &amp;&amp; (Verbose || WizardMode) ) {
3525         // Print the exception table for this offset
3526         _handler_table.print_subtable_for(pc);
3527       }
3528       st-&gt;bol(); // Make sure we start on a new line
3529     }
3530     st-&gt;cr(); // one empty line between blocks
3531     assert(cut_short || delay == NULL, &quot;no unconditional delay branch&quot;);
3532   } // End of per-block dump
3533 
3534   if (cut_short)  st-&gt;print_cr(&quot;*** disassembly is cut short ***&quot;);
3535 }
3536 #endif
3537 
3538 #ifndef PRODUCT
3539 void PhaseOutput::print_statistics() {
3540   Scheduling::print_statistics();
3541 }
3542 #endif
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>