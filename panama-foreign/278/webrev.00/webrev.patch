diff a/make/Main.gmk b/make/Main.gmk
--- a/make/Main.gmk
+++ b/make/Main.gmk
@@ -1225,11 +1225,11 @@
     images make-support test-make bundles buildjdk test-results test-support \
     support/images
 CLEAN_DIR_TARGETS := $(addprefix clean-, $(CLEAN_DIRS))
 CLEAN_SUPPORT_DIRS += demos
 CLEAN_SUPPORT_DIR_TARGETS := $(addprefix clean-, $(CLEAN_SUPPORT_DIRS))
-CLEAN_TESTS += hotspot-jtreg-native jdk-jtreg-native lib
+CLEAN_TESTS += hotspot-jtreg-native jdk-jtreg-native lib micro
 CLEAN_TEST_TARGETS += $(addprefix clean-test-, $(CLEAN_TESTS))
 CLEAN_PHASES := gensrc java native include
 CLEAN_PHASE_TARGETS := $(addprefix clean-, $(CLEAN_PHASES))
 CLEAN_MODULE_TARGETS := $(addprefix clean-, $(ALL_MODULES))
 # Construct targets of the form clean-$module-$phase
diff a/make/test/BuildMicrobenchmark.gmk b/make/test/BuildMicrobenchmark.gmk
--- a/make/test/BuildMicrobenchmark.gmk
+++ b/make/test/BuildMicrobenchmark.gmk
@@ -36,11 +36,18 @@
   $(error Cannot continue)
 endif
 
 #### Variables
 
-MICROBENCHMARK_SRC := $(TOPDIR)/test/micro
+# Add platform specific code first to allow override
+MICROBENCHMARK_SRC := $(wildcard $(TOPDIR)/test/os/$(OPENJDK_TARGET_OS)/micro)
+ifneq ($(OPENJDK_TARGET_OS), $(OPENJDK_TARGET_OS_TYPE))
+  MICROBENCHMARK_SRC += $(wildcard $(TOPDIR)/test/os/$(OPENJDK_TARGET_OS_TYPE)/micro)
+endif
+# Add common code for all platform
+MICROBENCHMARK_SRC += $(TOPDIR)/test/micro
+$(info BENCHMARK_SRC: $(MICROBENCHMARK_SRC))
 MICROBENCHMARK_IMAGE_DIR := $(TEST_IMAGE_DIR)/micro
 MICROBENCHMARK_JAR := $(MICROBENCHMARK_IMAGE_DIR)/benchmarks.jar
 
 MICROBENCHMARK_OUTPUT := $(SUPPORT_OUTPUTDIR)/test/micro
 MICROBENCHMARK_CLASSES := $(MICROBENCHMARK_OUTPUT)/classes
diff a/src/jdk.incubator.jbind.core/share/classes/jdk/incubator/jbind/core/RuntimeHelper.java b/src/jdk.incubator.jbind.core/share/classes/jdk/incubator/jbind/core/RuntimeHelper.java
--- /dev/null
+++ b/src/jdk.incubator.jbind.core/share/classes/jdk/incubator/jbind/core/RuntimeHelper.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.incubator.jbind.core;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.lang.invoke.VarHandle;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.Arrays;
+import java.util.Optional;
+import jdk.incubator.foreign.CSupport;
+import jdk.incubator.foreign.ForeignLinker;
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.GroupLayout;
+import jdk.incubator.foreign.LibraryLookup;
+import jdk.incubator.foreign.LibraryLookup.Symbol;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryHandles;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.SequenceLayout;
+
+public class RuntimeHelper {
+    private final static ForeignLinker ABI = CSupport.getSystemLinker();
+    private final static ClassLoader LOADER = RuntimeHelper.class.getClassLoader();
+
+    private final static MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();
+
+    public static final LibraryLookup[] libraries(String... libNames) {
+        if (libNames.length == 0) {
+            return new LibraryLookup[] { LibraryLookup.ofDefault() };
+        } else {
+            return Arrays.stream(libNames)
+                .map(libName -> LibraryLookup.ofLibrary(libName))
+                .toArray(LibraryLookup[]::new);
+        }
+    }
+
+    public static final LibraryLookup[] libraries(String[] libNames, String[] libPaths) {
+        if (libNames.length == 0) {
+            return new LibraryLookup[]{LibraryLookup.ofDefault()};
+        } else {
+            Path[] paths = Arrays.stream(libPaths).map(Paths::get).toArray(Path[]::new);
+            return Arrays.stream(libNames).map(libName -> {
+                Optional<Path> absPath = findLibraryPath(paths, libName);
+                return absPath.isPresent() ?
+                        LibraryLookup.ofPath(absPath.get().toString()) :
+                        LibraryLookup.ofLibrary(libName);
+            }).toArray(LibraryLookup[]::new);
+        }
+    }
+
+    private static final Optional<Path> findLibraryPath(Path[] paths, String libName) {
+        return Arrays.stream(paths).
+                map(p -> p.resolve(System.mapLibraryName(libName))).
+                filter(Files::isRegularFile).map(Path::toAbsolutePath).findFirst();
+    }
+
+    private static final Optional<Symbol> lookup(LibraryLookup[] LIBRARIES, String sym) {
+        for (LibraryLookup l : LIBRARIES) {
+            try {
+                return Optional.of(l.lookup(sym));
+            } catch (Throwable t) {
+            }
+        }
+        try {
+            return Optional.of(LibraryLookup.ofDefault().lookup(sym));
+        } catch (Throwable t) {
+            return Optional.empty();
+        }
+    }
+
+    public static final MemorySegment lookupGlobalVariable(LibraryLookup[] LIBRARIES, String name, MemoryLayout layout) {
+        return lookup(LIBRARIES, name).map(s ->
+            MemorySegment.ofNativeRestricted(
+                 s.address(), layout.byteSize(), null, null, s
+            ).withAccessModes(MemorySegment.READ | MemorySegment.WRITE)).orElse(null);
+    }
+
+    public static final MethodHandle downcallHandle(LibraryLookup[] LIBRARIES, String name, String desc, FunctionDescriptor fdesc, boolean isVariadic) {
+        Symbol symbol = lookup(LIBRARIES, name).orElse(null);
+        if (symbol == null) return null;
+
+        MethodType mt = MethodType.fromMethodDescriptorString(desc, LOADER);
+        if (isVariadic) {
+            return VarargsInvoker.make(symbol, mt, fdesc);
+        } else {
+            return ABI.downcallHandle(symbol, mt, fdesc);
+        }
+    }
+
+    public static final MemorySegment upcallStub(MethodHandle handle, FunctionDescriptor fdesc) {
+        return ABI.upcallStub(handle, fdesc);
+    }
+
+    public static final <Z> MemorySegment upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc) {
+        try {
+            MethodHandle handle = MH_LOOKUP.findVirtual(fi, "apply",
+                    MethodType.fromMethodDescriptorString(mtypeDesc, LOADER));
+            handle = handle.bindTo(z);
+            return upcallStub(handle, fdesc);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+
+    public static VarHandle varHandle(Class<?> carrier, MemoryLayout layout) {
+        boolean isAddr = carrier == MemoryAddress.class;
+        int dims = 0;
+        MemoryLayout tmp = layout;
+        while (tmp instanceof SequenceLayout) {
+            dims++;
+            tmp = ((SequenceLayout) tmp).elementLayout();
+        }
+        MemoryLayout.PathElement[] args = new MemoryLayout.PathElement[dims];
+        Arrays.fill(args, MemoryLayout.PathElement.sequenceElement());
+        VarHandle vh = layout.varHandle(isAddr ? long.class : carrier, args);
+        if (isAddr) {
+            vh = MemoryHandles.asAddressVarHandle(vh);
+        }
+        return vh;
+    }
+}
diff a/src/jdk.incubator.jbind.core/share/classes/jdk/incubator/jbind/core/Struct.java b/src/jdk.incubator.jbind.core/share/classes/jdk/incubator/jbind/core/Struct.java
--- /dev/null
+++ b/src/jdk.incubator.jbind.core/share/classes/jdk/incubator/jbind/core/Struct.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.incubator.jbind.core;
+
+import java.lang.invoke.VarHandle;
+import java.util.Arrays;
+import jdk.incubator.foreign.Addressable;
+import jdk.incubator.foreign.GroupLayout;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryHandles;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemoryLayout.PathElement;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.SequenceLayout;
+
+public abstract class Struct<T extends Struct<T>> implements Addressable {
+    private final MemorySegment ms;
+
+    protected Struct(MemorySegment segment) {
+        this.ms = segment;
+    }
+
+    public abstract GroupLayout getLayout();
+
+    @Override
+    public MemoryAddress address() {
+        return ms.address();
+    };
+
+    protected final MemorySegment getFieldAddr(String name) {
+        return ms.asSlice(getLayout().byteOffset(MemoryLayout.PathElement.groupElement(name)));
+    }
+
+    /**
+     * Return the VarHandle for the field. The returned handle features no coordinate
+     * unless the field is of SequenceLayout, then one long coordinate for each dimension
+     * is added.
+     */
+    protected final VarHandle getFieldHandle(String fieldName, Class<?> carrier) {
+        MemoryLayout.PathElement field = MemoryLayout.PathElement.groupElement(fieldName);
+        MemoryLayout fieldLayout = getLayout().select(field);
+        long offset = getLayout().byteOffset(field);
+        return MemoryHandles.insertCoordinates(RuntimeHelper.varHandle(carrier, fieldLayout),
+            0, ms.asSlice(offset));
+    }
+
+    public MemorySegment segment() {
+        return ms;
+    }
+
+    public MemorySegment asSegment() {
+        return ms.asSlice(0, getLayout().byteSize());
+    }
+}
diff a/src/jdk.incubator.jbind.core/share/classes/jdk/incubator/jbind/core/VarargsInvoker.java b/src/jdk.incubator.jbind.core/share/classes/jdk/incubator/jbind/core/VarargsInvoker.java
--- /dev/null
+++ b/src/jdk.incubator.jbind.core/share/classes/jdk/incubator/jbind/core/VarargsInvoker.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.incubator.jbind.core;
+
+import static jdk.incubator.foreign.CSupport.C_DOUBLE;
+import static jdk.incubator.foreign.CSupport.C_LONGLONG;
+import static jdk.incubator.foreign.CSupport.C_POINTER;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+
+import jdk.incubator.foreign.Addressable;
+import jdk.incubator.foreign.CSupport;
+import jdk.incubator.foreign.ForeignLinker;
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+
+public class VarargsInvoker {
+    private static final ForeignLinker ABI = CSupport.getSystemLinker();
+    private static final MethodHandle INVOKE_MH;
+    private final MemoryAddress symbol;
+    private final MethodType varargs;
+    private final FunctionDescriptor function;
+
+    private VarargsInvoker(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
+        // This MemoryAddress might be on a different thread than where lookup happened
+        this.symbol = symbol;
+        this.varargs = type;
+        this.function = function;
+    }
+
+    static {
+        try {
+            INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, "invoke", MethodType.methodType(Object.class, Object[].class));
+        } catch (ReflectiveOperationException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static MethodHandle make(Addressable symbol, MethodType type, FunctionDescriptor function) {
+        VarargsInvoker invoker = new VarargsInvoker(symbol.address(), type, function);
+        return INVOKE_MH.bindTo(invoker).asCollector(Object[].class, type.parameterCount())
+                .asType(type);
+    }
+
+    private Object invoke(Object[] args) throws Throwable {
+        // one trailing Object[]
+        int nNamedArgs = function.argumentLayouts().size();
+        assert(args.length == nNamedArgs + 1);
+        // The last argument is the array of vararg collector
+        Object[] unnamedArgs = (Object[]) args[args.length - 1];
+
+        int argsCount = nNamedArgs + unnamedArgs.length;
+        Class<?>[] argTypes = new Class<?>[argsCount];
+        MemoryLayout[] argLayouts = new MemoryLayout[nNamedArgs + unnamedArgs.length];
+
+        int pos = 0;
+        for (pos = 0; pos < nNamedArgs; pos++) {
+            argTypes[pos] = varargs.parameterType(pos);
+            argLayouts[pos] = function.argumentLayouts().get(pos);
+        }
+
+        assert pos == nNamedArgs;
+        for (Object o: unnamedArgs) {
+            argTypes[pos] = normalize(o.getClass());
+            argLayouts[pos] = variadicLayout(argTypes[pos]);
+            pos++;
+        }
+        assert pos == argsCount;
+
+        MethodType mt = MethodType.methodType(varargs.returnType(), argTypes);
+        FunctionDescriptor f = (function.returnLayout().isEmpty()) ?
+                FunctionDescriptor.ofVoid(argLayouts) :
+                FunctionDescriptor.of(function.returnLayout().get(), argLayouts);
+        MethodHandle mh = ABI.downcallHandle(symbol, mt, f);
+        // flatten argument list so that it can be passed to an asSpreader MH
+        Object[] allArgs = new Object[nNamedArgs + unnamedArgs.length];
+        System.arraycopy(args, 0, allArgs, 0, nNamedArgs);
+        System.arraycopy(unnamedArgs, 0, allArgs, nNamedArgs, unnamedArgs.length);
+
+        return mh.asSpreader(Object[].class, argsCount).invoke(allArgs);
+    }
+
+    public static Class<?> unboxIfNeeded(Class<?> clazz) {
+        if (clazz == Boolean.class) {
+            return boolean.class;
+        } else if (clazz == Void.class) {
+            return void.class;
+        } else if (clazz == Byte.class) {
+            return byte.class;
+        } else if (clazz == Character.class) {
+            return char.class;
+        } else if (clazz == Short.class) {
+            return short.class;
+        } else if (clazz == Integer.class) {
+            return int.class;
+        } else if (clazz == Long.class) {
+            return long.class;
+        } else if (clazz == Float.class) {
+            return float.class;
+        } else if (clazz == Double.class) {
+            return double.class;
+        } else {
+            return clazz;
+        }
+    }
+
+    private Class<?> promote(Class<?> c) {
+        if (c == byte.class || c == char.class || c == short.class || c == int.class) {
+            return long.class;
+        } else if (c == float.class) {
+            return double.class;
+        } else {
+            return c;
+        }
+    }
+
+    private Class<?> normalize(Class<?> c) {
+        c = unboxIfNeeded(c);
+        if (c.isPrimitive()) {
+            return promote(c);
+        }
+        if (MemoryAddress.class.isAssignableFrom(c)) {
+            return MemoryAddress.class;
+        }
+        if (MemorySegment.class.isAssignableFrom(c)) {
+            return MemorySegment.class;
+        }
+        throw new IllegalArgumentException("Invalid type for ABI: " + c.getTypeName());
+    }
+
+    private MemoryLayout variadicLayout(Class<?> c) {
+        if (c == long.class) {
+            return C_LONGLONG;
+        } else if (c == double.class) {
+            return C_DOUBLE;
+        } else if (MemoryAddress.class.isAssignableFrom(c)) {
+            return C_POINTER;
+        } else {
+            throw new IllegalArgumentException("Unhandled variadic argument class: " + c);
+        }
+    }
+}
diff a/src/jdk.incubator.jbind.core/share/classes/module-info.java b/src/jdk.incubator.jbind.core/share/classes/module-info.java
--- /dev/null
+++ b/src/jdk.incubator.jbind.core/share/classes/module-info.java
@@ -0,0 +1,4 @@
+module jdk.incubator.jbind.core {
+    requires transitive jdk.incubator.foreign;
+    exports jdk.incubator.jbind.core;
+}
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/nio/NativeIO.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/nio/NativeIO.java
--- /dev/null
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/nio/NativeIO.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.bench.jdk.incubator.foreign.nio;
+
+import org.openjdk.jmh.annotations.Benchmark;
+import org.openjdk.jmh.annotations.BenchmarkMode;
+import org.openjdk.jmh.annotations.Fork;
+import org.openjdk.jmh.annotations.Measurement;
+import org.openjdk.jmh.annotations.Mode;
+import org.openjdk.jmh.annotations.OutputTimeUnit;
+import org.openjdk.jmh.annotations.State;
+import org.openjdk.jmh.annotations.Warmup;
+
+import java.io.IOException;
+import java.nio.file.DirectoryStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.nio.file.attribute.PosixFileAttributes;
+import java.nio.file.attribute.PosixFilePermissions;
+import java.util.concurrent.TimeUnit;
+import jdk.incubator.foreign.CSupport;
+import jdk.incubator.foreign.NativeScope;
+import jdk.incubator.foreign.MemoryAddress;
+import org.openjdk.bench.jdk.incubator.foreign.nio.support.FFINativeDispatcher;
+import org.openjdk.bench.jdk.incubator.foreign.nio.support.NativeDispatcher;
+import org.openjdk.bench.jdk.incubator.foreign.nio.support.UnixFileAttributes;
+
+@BenchmarkMode(Mode.AverageTime)
+@Warmup(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)
+@Measurement(iterations = 50, time = 500, timeUnit = TimeUnit.MILLISECONDS)
+@State(org.openjdk.jmh.annotations.Scope.Thread)
+@OutputTimeUnit(TimeUnit.MILLISECONDS)
+@Fork(value=3, jvmArgsAppend={"--enable-preview", "--add-modules", "jdk.incubator.foreign,jdk.incubator.jbind.core", "-Dforeign.restricted=permit"})
+public class NativeIO {
+    @Benchmark
+    public void getcwdinfoBuiltinNio() throws IOException {
+        long usage = 0;
+        Path cwd = Paths.get(".");
+        try (DirectoryStream<Path> dir = Files.newDirectoryStream(cwd)) {
+            for (Path p: dir) {
+                PosixFileAttributes attrs = Files.readAttributes(p, PosixFileAttributes.class);
+                usage += attrs.size();
+            }
+        }
+    }
+
+    @Benchmark
+    public void getcwdinfoJNI() {
+        long usage = 0;
+        var dir = NativeDispatcher.opendirJNI(".");
+        String p = NativeDispatcher.readdirJNI(dir);
+        while (p != null) {
+            UnixFileAttributes attrs = NativeDispatcher.statJNI(p);
+            p = NativeDispatcher.readdirJNI(dir);
+            usage += attrs.size();
+        }
+        NativeDispatcher.closedirJNI(dir);
+    }
+
+    @Benchmark
+    public void getcwdinfoFFI() {
+        long usage = 0;
+        var dir = FFINativeDispatcher.opendirFFI(".");
+        String p = FFINativeDispatcher.readdirFFI(dir);
+        while (p != null) {
+            UnixFileAttributes attrs = FFINativeDispatcher.statFFI(p);
+            p = FFINativeDispatcher.readdirFFI(dir);
+            usage += attrs.size();
+        }
+        FFINativeDispatcher.closedirFFI(dir);
+    }
+
+    private void getcwdinfo(NativeDispatcher instance) throws IOException {
+        long usage = 0;
+        try (DirectoryStream<String> dir = instance.newDirectoryStream(".")) {
+            for (String p: dir) {
+                UnixFileAttributes attrs = instance.readAttributes(p);
+                usage += attrs.size();
+            }
+        }
+    }
+
+    @Benchmark
+    public void getcwdinfoWrapJNI() throws IOException {
+        getcwdinfo(NativeDispatcher.JNI);
+    }
+
+    @Benchmark
+    public void getcwdinfoWrapFFI() throws IOException {
+        getcwdinfo(NativeDispatcher.FFI);
+    }
+}
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/DirectoryIterator.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/DirectoryIterator.java
--- /dev/null
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/DirectoryIterator.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package org.openjdk.bench.jdk.incubator.foreign.nio.support;
+
+import java.nio.file.DirectoryStream;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+import jdk.incubator.foreign.MemoryAddress;
+
+public class DirectoryIterator implements DirectoryStream<String>, Iterator<String> {
+    private final NativeDispatcher dispatcher;
+    private MemoryAddress dir;
+
+    // true when at EOF
+    private boolean atEof;
+
+    // next entry to return
+    private String nextEntry;
+
+    DirectoryIterator(NativeDispatcher dispatcher, String path) {
+        super();
+        this.dispatcher = dispatcher;
+        this.dir = dispatcher.opendir(path);
+        atEof = false;
+    }
+
+    // Return true if file name is "." or ".."
+    private boolean isSelfOrParent(String path) {
+        byte nameAsBytes[] = path.getBytes();
+        if (nameAsBytes[0] == '.') {
+            if ((nameAsBytes.length == 1) ||
+                (nameAsBytes.length == 2 && nameAsBytes[1] == '.')) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    // Returns next entry (or null)
+    private String readNextEntry() {
+        for (;;) {
+            String name = null;
+            name = dispatcher.readdir(dir);
+
+            // EOF
+            if (name == null) {
+                atEof = true;
+                return null;
+            }
+
+            // ignore "." and ".."
+            if (!isSelfOrParent(name)) {
+                return name;
+            }
+        }
+    }
+
+    @Override
+    public synchronized boolean hasNext() {
+        if (nextEntry == null && !atEof)
+            nextEntry = readNextEntry();
+        return nextEntry != null;
+    }
+
+    @Override
+    public synchronized String next() {
+        String result;
+        if (nextEntry == null && !atEof) {
+            result = readNextEntry();
+        } else {
+            result = nextEntry;
+            nextEntry = null;
+        }
+        if (result == null)
+            throw new NoSuchElementException();
+        return result;
+    }
+
+    @Override
+    public Iterator<String> iterator() { return this; }
+
+    @Override
+    public void close() { dispatcher.closedir(dir); }
+}
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/FFINativeDispatcher.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/FFINativeDispatcher.java
--- /dev/null
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/FFINativeDispatcher.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package org.openjdk.bench.jdk.incubator.foreign.nio.support;
+
+import jdk.incubator.foreign.MemoryAddress;
+
+public class FFINativeDispatcher extends NativeDispatcher {
+    public MemoryAddress opendir(String path) { throw new UnsupportedOperationException(); }
+    public String readdir(MemoryAddress dir) { throw new UnsupportedOperationException(); }
+    public void closedir(MemoryAddress dir) { throw new UnsupportedOperationException(); }
+    public UnixFileAttributes readAttributes(String path) { throw new UnsupportedOperationException(); }
+
+    public static UnixFileAttributes statFFI(String path) { throw new UnsupportedOperationException(); }
+    public static MemoryAddress opendirFFI(String path) { throw new UnsupportedOperationException(); }
+    public static void closedirFFI(MemoryAddress dir) { throw new UnsupportedOperationException(); }
+    public static String readdirFFI(MemoryAddress dir) { throw new UnsupportedOperationException(); }
+};
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/NativeDispatcher.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/NativeDispatcher.java
--- /dev/null
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/NativeDispatcher.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package org.openjdk.bench.jdk.incubator.foreign.nio.support;
+
+import java.nio.file.DirectoryStream;
+
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.NativeScope;
+import jdk.incubator.foreign.CSupport;
+
+/**
+ * Unix system and library calls.
+ */
+
+public abstract class NativeDispatcher {
+    static final int PATH_MAX = 1024;
+
+    public abstract MemoryAddress opendir(String path);
+    public abstract String readdir(MemoryAddress dir);
+    public abstract void closedir(MemoryAddress dir);
+    public abstract UnixFileAttributes readAttributes(String path);
+
+    public DirectoryStream<String> newDirectoryStream(String path) {
+        return new DirectoryIterator(this, path);
+    }
+
+    public static final NativeDispatcher FFI  = new FFINativeDispatcher();
+
+    public static final NativeDispatcher JNI = new NativeDispatcher() {
+        public MemoryAddress opendir(String path) { return MemoryAddress.ofLong(opendirJNI(path)); }
+        public String readdir(MemoryAddress dir) { return readdirJNI(dir.toRawLongValue()); }
+        public void closedir(MemoryAddress dir) { closedirJNI(dir.toRawLongValue()); }
+        public UnixFileAttributes readAttributes(String path) { return statJNI(path); }
+    };
+
+    public static native long opendirJNI(String path);
+    public static native String readdirJNI(long dir);
+    public static native void closedirJNI(long dir);
+    public static UnixFileAttributes statJNI(String path) {
+        UnixFileAttributes attrs = new UnixFileAttributes();
+        statJNI(path, attrs);
+        return attrs;
+    }
+
+    public static native void statJNI(String path, UnixFileAttributes attrs);
+    static native int initJNI();
+
+    static {
+        System.loadLibrary("NativeDispatcher");
+        initJNI();
+    }
+}
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/UnixFileAttributes.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/UnixFileAttributes.java
--- /dev/null
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/UnixFileAttributes.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package org.openjdk.bench.jdk.incubator.foreign.nio.support;
+
+import java.nio.file.attribute.FileTime;
+import java.util.concurrent.TimeUnit;
+
+import jdk.incubator.foreign.MemoryAddress;
+
+/**
+ * Unix implementation of PosixFileAttributes.
+ */
+
+public class UnixFileAttributes {
+    private int     st_mode;
+    private long    st_ino;
+    private long    st_dev;
+    private long    st_rdev;
+    private int     st_nlink;
+    private int     st_uid;
+    private int     st_gid;
+    private long    st_size;
+    private long    st_atime_sec;
+    private long    st_atime_nsec;
+    private long    st_mtime_sec;
+    private long    st_mtime_nsec;
+    private long    st_ctime_sec;
+    private long    st_ctime_nsec;
+    private long    st_birthtime_sec;
+
+    UnixFileAttributes() {
+        super();
+    }
+
+    public int mode()  { return st_mode; }
+    public long ino()  { return st_ino; }
+    public long dev()  { return st_dev; }
+    public long rdev() { return st_rdev; }
+    public int nlink() { return st_nlink; }
+    public int uid()   { return st_uid; }
+    public int gid()   { return st_gid; }
+
+    private static FileTime toFileTime(long sec, long nsec) {
+        if (nsec == 0) {
+            return FileTime.from(sec, TimeUnit.SECONDS);
+        } else {
+            try {
+                long nanos = Math.addExact(nsec,
+                    Math.multiplyExact(sec, 1_000_000_000L));
+                return FileTime.from(nanos, TimeUnit.NANOSECONDS);
+            } catch (ArithmeticException ignore) {
+                // truncate to microseconds if nanoseconds overflow
+                long micro = sec*1_000_000L + nsec/1_000L;
+                return FileTime.from(micro, TimeUnit.MICROSECONDS);
+            }
+        }
+    }
+
+    public FileTime ctime() {
+        return toFileTime(st_ctime_sec, st_ctime_nsec);
+    }
+
+    public FileTime lastModifiedTime() {
+        return toFileTime(st_mtime_sec, st_mtime_nsec);
+    }
+
+    public FileTime lastAccessTime() {
+        return toFileTime(st_atime_sec, st_atime_nsec);
+    }
+
+    public FileTime creationTime() {
+        return FileTime.from(st_birthtime_sec, TimeUnit.SECONDS);
+    }
+
+    public long size() {
+        return st_size;
+    }
+}
diff a/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/FFINativeDispatcher.java b/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/FFINativeDispatcher.java
--- /dev/null
+++ b/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/FFINativeDispatcher.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package org.openjdk.bench.jdk.incubator.foreign.nio.support;
+
+import jdk.incubator.foreign.CSupport;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.NativeScope;
+
+public class FFINativeDispatcher extends NativeDispatcher {
+    public MemoryAddress opendir(String path) { return opendirFFI(path); }
+    public String readdir(MemoryAddress dir) { return readdirFFI(dir); }
+    public void closedir(MemoryAddress dir) { closedirFFI(dir); }
+    public UnixFileAttributes readAttributes(String path) { return statFFI(path); }
+
+    public static UnixFileAttributes statFFI(String path) {
+        try (NativeScope scope = NativeScope.unboundedScope()) {
+            var file = CSupport.toCString(path, scope);
+            LibC.stat buffer = LibC.stat.allocate(scope::allocate);
+            LibC.__xstat(0, file, buffer);
+            return new UnixFileAttributes(buffer);
+        }
+    }
+
+    public static MemoryAddress opendirFFI(String path) {
+        try (NativeScope scope = NativeScope.unboundedScope()) {
+            MemoryAddress dir = LibC.opendir(CSupport.toCString(path, scope));
+            if (dir.equals(MemoryAddress.NULL)) {
+                throw new RuntimeException();
+            }
+            return dir;
+        }
+    }
+
+    /**
+     * closedir(DIR* dirp)
+     */
+    public static void closedirFFI(MemoryAddress dir) {
+        LibC.closedir(dir);
+    }
+
+    /**
+     * struct dirent* readdir(DIR *dirp)
+     *
+     * @return  dirent->d_name
+     */
+    public static String readdirFFI(MemoryAddress dir) {
+        MemoryAddress pdir = LibC.readdir(dir);
+        if (pdir.equals(MemoryAddress.NULL)) {
+            return null;
+        }
+
+        MemorySegment segment = MemorySegment.ofNativeRestricted()
+                .asSlice(pdir.toRawLongValue(), LibC.dirent.sizeof());
+        return CSupport.toJavaString(LibC.dirent.at(segment).d_name$ptr());
+    }
+};
diff a/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/LibC.java b/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/LibC.java
--- /dev/null
+++ b/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/LibC.java
@@ -0,0 +1,416 @@
+// Generated by jbind
+
+package org.openjdk.bench.jdk.incubator.foreign.nio.support;
+
+import jdk.incubator.jbind.core.*;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import jdk.incubator.foreign.*;
+import jdk.incubator.foreign.MemoryLayout.PathElement;
+import static jdk.incubator.foreign.CSupport.*;
+
+import java.util.function.LongFunction;
+
+public final class LibC {
+    private static final LibraryLookup[] LIBRARIES = RuntimeHelper.libraries(new String[] {});
+    public static final class stat extends Struct<stat> {
+        protected stat(MemorySegment ms) { super(ms); }
+        public static final stat at(MemorySegment ms) { return new stat(ms); }
+        public static final stat allocate(LongFunction<MemorySegment> allocator, int count) {
+            return new stat(allocator.apply(sizeof() * count));
+        }
+        public static final stat allocate(LongFunction<MemorySegment> allocator) { return allocate(allocator, 1); }
+        public final stat offset(int count) { return at(segment().asSlice(sizeof() * count)); }
+
+        public static final GroupLayout $LAYOUT = MemoryLayout.ofStruct(
+            C_LONG.withName("st_dev"),
+            C_LONG.withName("st_ino"),
+            C_LONG.withName("st_nlink"),
+            C_INT.withName("st_mode"),
+            C_INT.withName("st_uid"),
+            C_INT.withName("st_gid"),
+            C_INT.withName("__pad0"),
+            C_LONG.withName("st_rdev"),
+            C_LONG.withName("st_size"),
+            C_LONG.withName("st_blksize"),
+            C_LONG.withName("st_blocks"),
+            MemoryLayout.ofStruct(
+                C_LONG.withName("tv_sec"),
+                C_LONG.withName("tv_nsec")
+            ).withName("st_atim"),
+            MemoryLayout.ofStruct(
+                C_LONG.withName("tv_sec"),
+                C_LONG.withName("tv_nsec")
+            ).withName("st_mtim"),
+            MemoryLayout.ofStruct(
+                C_LONG.withName("tv_sec"),
+                C_LONG.withName("tv_nsec")
+            ).withName("st_ctim"),
+            MemoryLayout.ofSequence(3, C_LONG).withName("__glibc_reserved")
+        ).withName("stat");
+        public static final long sizeof() { return $LAYOUT.byteSize(); }
+        public static final long offsetof(String fieldName) { return $LAYOUT.byteOffset(MemoryLayout.PathElement.groupElement(fieldName)); }
+        @Override
+        public final GroupLayout getLayout() { return $LAYOUT; }
+
+        public static final VarHandle st_dev$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_dev")));
+        public static final long st_dev$OFFSET = 0L;
+        public final MemorySegment st_dev$ptr() {
+            return segment().asSlice(0L);
+        }
+        public final long st_dev$get() {
+            return (long) st_dev$VH.get(st_dev$ptr());
+        }
+        public final void st_dev$set(long value) {
+            st_dev$VH.set(st_dev$ptr(), value);
+        }
+
+        public static final VarHandle st_ino$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_ino")));
+        public static final long st_ino$OFFSET = 8L;
+        public final MemorySegment st_ino$ptr() {
+            return segment().asSlice(8L);
+        }
+        public final long st_ino$get() {
+            return (long) st_ino$VH.get(st_ino$ptr());
+        }
+        public final void st_ino$set(long value) {
+            st_ino$VH.set(st_ino$ptr(), value);
+        }
+
+        public static final VarHandle st_nlink$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_nlink")));
+        public static final long st_nlink$OFFSET = 16L;
+        public final MemorySegment st_nlink$ptr() {
+            return segment().asSlice(16L);
+        }
+        public final long st_nlink$get() {
+            return (long) st_nlink$VH.get(st_nlink$ptr());
+        }
+        public final void st_nlink$set(long value) {
+            st_nlink$VH.set(st_nlink$ptr(), value);
+        }
+
+        public static final VarHandle st_mode$VH = RuntimeHelper.varHandle(int.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_mode")));
+        public static final long st_mode$OFFSET = 24L;
+        public final MemorySegment st_mode$ptr() {
+            return segment().asSlice(24L);
+        }
+        public final int st_mode$get() {
+            return (int) st_mode$VH.get(st_mode$ptr());
+        }
+        public final void st_mode$set(int value) {
+            st_mode$VH.set(st_mode$ptr(), value);
+        }
+
+        public static final VarHandle st_uid$VH = RuntimeHelper.varHandle(int.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_uid")));
+        public static final long st_uid$OFFSET = 28L;
+        public final MemorySegment st_uid$ptr() {
+            return segment().asSlice(28L);
+        }
+        public final int st_uid$get() {
+            return (int) st_uid$VH.get(st_uid$ptr());
+        }
+        public final void st_uid$set(int value) {
+            st_uid$VH.set(st_uid$ptr(), value);
+        }
+
+        public static final VarHandle st_gid$VH = RuntimeHelper.varHandle(int.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_gid")));
+        public static final long st_gid$OFFSET = 32L;
+        public final MemorySegment st_gid$ptr() {
+            return segment().asSlice(32L);
+        }
+        public final int st_gid$get() {
+            return (int) st_gid$VH.get(st_gid$ptr());
+        }
+        public final void st_gid$set(int value) {
+            st_gid$VH.set(st_gid$ptr(), value);
+        }
+
+        public static final VarHandle __pad0$VH = RuntimeHelper.varHandle(int.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("__pad0")));
+        public static final long __pad0$OFFSET = 36L;
+        public final MemorySegment __pad0$ptr() {
+            return segment().asSlice(36L);
+        }
+        public final int __pad0$get() {
+            return (int) __pad0$VH.get(__pad0$ptr());
+        }
+        public final void __pad0$set(int value) {
+            __pad0$VH.set(__pad0$ptr(), value);
+        }
+
+        public static final VarHandle st_rdev$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_rdev")));
+        public static final long st_rdev$OFFSET = 40L;
+        public final MemorySegment st_rdev$ptr() {
+            return segment().asSlice(40L);
+        }
+        public final long st_rdev$get() {
+            return (long) st_rdev$VH.get(st_rdev$ptr());
+        }
+        public final void st_rdev$set(long value) {
+            st_rdev$VH.set(st_rdev$ptr(), value);
+        }
+
+        public static final VarHandle st_size$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_size")));
+        public static final long st_size$OFFSET = 48L;
+        public final MemorySegment st_size$ptr() {
+            return segment().asSlice(48L);
+        }
+        public final long st_size$get() {
+            return (long) st_size$VH.get(st_size$ptr());
+        }
+        public final void st_size$set(long value) {
+            st_size$VH.set(st_size$ptr(), value);
+        }
+
+        public static final VarHandle st_blksize$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_blksize")));
+        public static final long st_blksize$OFFSET = 56L;
+        public final MemorySegment st_blksize$ptr() {
+            return segment().asSlice(56L);
+        }
+        public final long st_blksize$get() {
+            return (long) st_blksize$VH.get(st_blksize$ptr());
+        }
+        public final void st_blksize$set(long value) {
+            st_blksize$VH.set(st_blksize$ptr(), value);
+        }
+
+        public static final VarHandle st_blocks$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_blocks")));
+        public static final long st_blocks$OFFSET = 64L;
+        public final MemorySegment st_blocks$ptr() {
+            return segment().asSlice(64L);
+        }
+        public final long st_blocks$get() {
+            return (long) st_blocks$VH.get(st_blocks$ptr());
+        }
+        public final void st_blocks$set(long value) {
+            st_blocks$VH.set(st_blocks$ptr(), value);
+        }
+
+        public static final long st_atim$OFFSET = 72L;
+        public final MemorySegment st_atim$ptr() {
+            return segment().asSlice(72L);
+        }
+        public final timespec st_atim$get() {
+            return timespec.at(st_atim$ptr());
+        }
+        public final void st_atim$set(timespec value) {
+            timespec.at(st_atim$ptr()).asSegment().copyFrom(value.asSegment());
+        }
+
+        public static final long st_mtim$OFFSET = 88L;
+        public final MemorySegment st_mtim$ptr() {
+            return segment().asSlice(88L);
+        }
+        public final timespec st_mtim$get() {
+            return timespec.at(st_mtim$ptr());
+        }
+        public final void st_mtim$set(timespec value) {
+            timespec.at(st_mtim$ptr()).asSegment().copyFrom(value.asSegment());
+        }
+
+        public static final long st_ctim$OFFSET = 104L;
+        public final MemorySegment st_ctim$ptr() {
+            return segment().asSlice(104L);
+        }
+        public final timespec st_ctim$get() {
+            return timespec.at(st_ctim$ptr());
+        }
+        public final void st_ctim$set(timespec value) {
+            timespec.at(st_ctim$ptr()).asSegment().copyFrom(value.asSegment());
+        }
+
+        public static final VarHandle __glibc_reserved$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("__glibc_reserved")));
+        public static final long __glibc_reserved$OFFSET = 120L;
+        public final MemorySegment __glibc_reserved$ptr() {
+            return segment().asSlice(120L);
+        }
+        public final long __glibc_reserved$get(long idx0) {
+            return (long) __glibc_reserved$VH.get(__glibc_reserved$ptr(), idx0);
+        }
+        public final void __glibc_reserved$set(long idx0, long value) {
+            __glibc_reserved$VH.set(__glibc_reserved$ptr(), idx0, value);
+        }
+    }
+    public static final class timespec extends Struct<timespec> {
+        protected timespec(MemorySegment ms) { super(ms); }
+        public static final timespec at(MemorySegment ms) { return new timespec(ms); }
+        public static final timespec allocate(LongFunction<MemorySegment> allocator, int count) {
+            return new timespec(allocator.apply(sizeof() * count));
+        }
+        public static final timespec allocate(LongFunction<MemorySegment> allocator) { return allocate(allocator, 1); }
+        public final timespec offset(int count) { return at(segment().asSlice(sizeof() * count)); }
+
+        public static final GroupLayout $LAYOUT = MemoryLayout.ofStruct(
+            C_LONG.withName("tv_sec"),
+            C_LONG.withName("tv_nsec")
+        ).withName("timespec");
+        public static final long sizeof() { return $LAYOUT.byteSize(); }
+        public static final long offsetof(String fieldName) { return $LAYOUT.byteOffset(MemoryLayout.PathElement.groupElement(fieldName)); }
+        @Override
+        public final GroupLayout getLayout() { return $LAYOUT; }
+
+        public static final VarHandle tv_sec$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("tv_sec")));
+        public static final long tv_sec$OFFSET = 0L;
+        public final MemorySegment tv_sec$ptr() {
+            return segment().asSlice(0L);
+        }
+        public final long tv_sec$get() {
+            return (long) tv_sec$VH.get(tv_sec$ptr());
+        }
+        public final void tv_sec$set(long value) {
+            tv_sec$VH.set(tv_sec$ptr(), value);
+        }
+
+        public static final VarHandle tv_nsec$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("tv_nsec")));
+        public static final long tv_nsec$OFFSET = 8L;
+        public final MemorySegment tv_nsec$ptr() {
+            return segment().asSlice(8L);
+        }
+        public final long tv_nsec$get() {
+            return (long) tv_nsec$VH.get(tv_nsec$ptr());
+        }
+        public final void tv_nsec$set(long value) {
+            tv_nsec$VH.set(tv_nsec$ptr(), value);
+        }
+    }
+    public static final class dirent extends Struct<dirent> {
+        protected dirent(MemorySegment ms) { super(ms); }
+        public static final dirent at(MemorySegment ms) { return new dirent(ms); }
+        public static final dirent allocate(LongFunction<MemorySegment> allocator, int count) {
+            return new dirent(allocator.apply(sizeof() * count));
+        }
+        public static final dirent allocate(LongFunction<MemorySegment> allocator) { return allocate(allocator, 1); }
+        public final dirent offset(int count) { return at(segment().asSlice(sizeof() * count)); }
+
+        public static final GroupLayout $LAYOUT = MemoryLayout.ofStruct(
+            C_LONG.withName("d_ino"),
+            C_LONG.withName("d_off"),
+            C_SHORT.withName("d_reclen"),
+            C_BOOL.withName("d_type"),
+            MemoryLayout.ofSequence(256, C_BOOL).withName("d_name"),
+            MemoryLayout.ofPaddingBits(40)
+        ).withName("dirent");
+        public static final long sizeof() { return $LAYOUT.byteSize(); }
+        public static final long offsetof(String fieldName) { return $LAYOUT.byteOffset(MemoryLayout.PathElement.groupElement(fieldName)); }
+        @Override
+        public final GroupLayout getLayout() { return $LAYOUT; }
+
+        public static final VarHandle d_ino$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("d_ino")));
+        public static final long d_ino$OFFSET = 0L;
+        public final MemorySegment d_ino$ptr() {
+            return segment().asSlice(0L);
+        }
+        public final long d_ino$get() {
+            return (long) d_ino$VH.get(d_ino$ptr());
+        }
+        public final void d_ino$set(long value) {
+            d_ino$VH.set(d_ino$ptr(), value);
+        }
+
+        public static final VarHandle d_off$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("d_off")));
+        public static final long d_off$OFFSET = 8L;
+        public final MemorySegment d_off$ptr() {
+            return segment().asSlice(8L);
+        }
+        public final long d_off$get() {
+            return (long) d_off$VH.get(d_off$ptr());
+        }
+        public final void d_off$set(long value) {
+            d_off$VH.set(d_off$ptr(), value);
+        }
+
+        public static final VarHandle d_reclen$VH = RuntimeHelper.varHandle(short.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("d_reclen")));
+        public static final long d_reclen$OFFSET = 16L;
+        public final MemorySegment d_reclen$ptr() {
+            return segment().asSlice(16L);
+        }
+        public final short d_reclen$get() {
+            return (short) d_reclen$VH.get(d_reclen$ptr());
+        }
+        public final void d_reclen$set(short value) {
+            d_reclen$VH.set(d_reclen$ptr(), value);
+        }
+
+        public static final VarHandle d_type$VH = RuntimeHelper.varHandle(byte.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("d_type")));
+        public static final long d_type$OFFSET = 18L;
+        public final MemorySegment d_type$ptr() {
+            return segment().asSlice(18L);
+        }
+        public final byte d_type$get() {
+            return (byte) d_type$VH.get(d_type$ptr());
+        }
+        public final void d_type$set(byte value) {
+            d_type$VH.set(d_type$ptr(), value);
+        }
+
+        public static final VarHandle d_name$VH = RuntimeHelper.varHandle(byte.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("d_name")));
+        public static final long d_name$OFFSET = 19L;
+        public final MemorySegment d_name$ptr() {
+            return segment().asSlice(19L);
+        }
+        public final byte d_name$get(long idx0) {
+            return (byte) d_name$VH.get(d_name$ptr(), idx0);
+        }
+        public final void d_name$set(long idx0, byte value) {
+            d_name$VH.set(d_name$ptr(), idx0, value);
+        }
+    }
+    public static final MethodHandle mh___xstat = RuntimeHelper.downcallHandle(
+        LIBRARIES, "__xstat",
+        "(ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_INT,
+            C_POINTER,
+            C_POINTER
+        ), false
+    );
+    public static final int __xstat(int __ver, jdk.incubator.foreign.Addressable __filename, jdk.incubator.foreign.Addressable __stat_buf) {
+        try {
+            return (int) mh___xstat.invokeExact(__ver, __filename.address(), __stat_buf.address());
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle mh_opendir = RuntimeHelper.downcallHandle(
+        LIBRARIES, "opendir",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        ), false
+    );
+    public static final jdk.incubator.foreign.MemoryAddress opendir(jdk.incubator.foreign.Addressable __name) {
+        try {
+            return (jdk.incubator.foreign.MemoryAddress) mh_opendir.invokeExact(__name.address());
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle mh_closedir = RuntimeHelper.downcallHandle(
+        LIBRARIES, "closedir",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        ), false
+    );
+    public static final int closedir(jdk.incubator.foreign.Addressable __dirp) {
+        try {
+            return (int) mh_closedir.invokeExact(__dirp.address());
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle mh_readdir = RuntimeHelper.downcallHandle(
+        LIBRARIES, "readdir",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        ), false
+    );
+    public static final jdk.incubator.foreign.MemoryAddress readdir(jdk.incubator.foreign.Addressable __dirp) {
+        try {
+            return (jdk.incubator.foreign.MemoryAddress) mh_readdir.invokeExact(__dirp.address());
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+}
+
diff a/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/UnixFileAttributes.java b/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/UnixFileAttributes.java
--- /dev/null
+++ b/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/UnixFileAttributes.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package org.openjdk.bench.jdk.incubator.foreign.nio.support;
+
+import java.nio.file.attribute.FileTime;
+import java.util.concurrent.TimeUnit;
+
+import jdk.incubator.foreign.MemoryAddress;
+
+/**
+ * Unix implementation of PosixFileAttributes.
+ */
+
+public class UnixFileAttributes {
+    private int     st_mode;
+    private long    st_ino;
+    private long    st_dev;
+    private long    st_rdev;
+    private int     st_nlink;
+    private int     st_uid;
+    private int     st_gid;
+    private long    st_size;
+    private long    st_atime_sec;
+    private long    st_atime_nsec;
+    private long    st_mtime_sec;
+    private long    st_mtime_nsec;
+    private long    st_ctime_sec;
+    private long    st_ctime_nsec;
+    private long    st_birthtime_sec;
+
+    UnixFileAttributes() {
+        super();
+    }
+
+    UnixFileAttributes(LibC.stat buf) {
+        st_mode = buf.st_mode$get();
+        st_ino = buf.st_ino$get();
+        st_dev = buf.st_dev$get();
+        st_rdev = buf.st_rdev$get();
+        st_nlink = (int) buf.st_nlink$get();
+        st_uid = buf.st_uid$get();
+        st_gid = buf.st_gid$get();
+        st_size = buf.st_size$get();
+        st_atime_sec = buf.st_atim$get().tv_sec$get();
+        st_mtime_sec = buf.st_mtim$get().tv_sec$get();
+        st_ctime_sec = buf.st_ctim$get().tv_sec$get();
+        st_atime_nsec = buf.st_atim$get().tv_nsec$get();
+        st_mtime_nsec = buf.st_mtim$get().tv_nsec$get();
+        st_ctime_nsec = buf.st_ctim$get().tv_nsec$get();
+        st_birthtime_sec = 0;
+    }
+
+    UnixFileAttributes(MemoryAddress buf) {
+        try {
+            st_mode = (int) LibC.stat.st_mode$VH.get(buf);
+            st_ino = (long) LibC.stat.st_ino$VH.get(buf);
+            st_dev = (long) LibC.stat.st_dev$VH.get(buf);
+            st_rdev = (long) LibC.stat.st_rdev$VH.get(buf);
+            st_nlink = (int) LibC.stat.st_nlink$VH.get(buf);
+            st_uid = (int) LibC.stat.st_uid$VH.get(buf);
+            st_gid = (int) LibC.stat.st_gid$VH.get(buf);
+            st_size = (long) LibC.stat.st_size$VH.get(buf);
+            MemoryAddress ts = buf.addOffset(LibC.stat.st_atim$OFFSET);
+            st_atime_sec = (long) LibC.timespec.tv_sec$VH.get(ts);
+            st_atime_nsec = (long) LibC.timespec.tv_nsec$VH.get(ts);
+
+            ts = buf.addOffset(LibC.stat.st_mtim$OFFSET);
+            st_mtime_sec = (long) LibC.timespec.tv_sec$VH.get(ts);
+            st_mtime_nsec = (long) LibC.timespec.tv_nsec$VH.get(ts);
+
+            ts = buf.addOffset(LibC.stat.st_ctim$OFFSET);
+            st_ctime_sec = (long) LibC.timespec.tv_sec$VH.get(ts);
+            st_ctime_nsec = (long) LibC.timespec.tv_nsec$VH.get(ts);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+
+    public static UnixFileAttributes from(MemoryAddress buf) {
+        return new UnixFileAttributes(buf);
+    }
+
+    // package-private
+    public int mode()  { return st_mode; }
+    public long ino()  { return st_ino; }
+    public long dev()  { return st_dev; }
+    public long rdev() { return st_rdev; }
+    public int nlink() { return st_nlink; }
+    public int uid()   { return st_uid; }
+    public int gid()   { return st_gid; }
+
+    private static FileTime toFileTime(long sec, long nsec) {
+        if (nsec == 0) {
+            return FileTime.from(sec, TimeUnit.SECONDS);
+        } else {
+            try {
+                long nanos = Math.addExact(nsec,
+                    Math.multiplyExact(sec, 1_000_000_000L));
+                return FileTime.from(nanos, TimeUnit.NANOSECONDS);
+            } catch (ArithmeticException ignore) {
+                // truncate to microseconds if nanoseconds overflow
+                long micro = sec*1_000_000L + nsec/1_000L;
+                return FileTime.from(micro, TimeUnit.MICROSECONDS);
+            }
+        }
+    }
+
+    public FileTime ctime() {
+        return toFileTime(st_ctime_sec, st_ctime_nsec);
+    }
+
+    public FileTime lastModifiedTime() {
+        return toFileTime(st_mtime_sec, st_mtime_nsec);
+    }
+
+    public FileTime lastAccessTime() {
+        return toFileTime(st_atime_sec, st_atime_nsec);
+    }
+
+    public FileTime creationTime() {
+        return FileTime.from(st_birthtime_sec, TimeUnit.SECONDS);
+    }
+
+    public long size() {
+        return st_size;
+    }
+}
diff a/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/gencode.sh b/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/gencode.sh
--- /dev/null
+++ b/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/gencode.sh
@@ -0,0 +1,2 @@
+COMMON_ARGS=-J-Dforeign.restricted=permit
+jbind -n LibC $COMMON_ARGS @pkg.args @symbols headers.h
diff a/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/headers.h b/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/headers.h
--- /dev/null
+++ b/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/headers.h
@@ -0,0 +1,4 @@
+#include <sys/stat.h>
+#include <dirent.h>
+
+#include <unistd.h>
diff a/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/pkg.args b/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/pkg.args
--- /dev/null
+++ b/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/pkg.args
@@ -0,0 +1,3 @@
+--src-dump-dir=../../../../../../../..
+-d output
+-t org.openjdk.bench.jdk.incubator.foreign.nio.support
diff a/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/symbols b/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/symbols
--- /dev/null
+++ b/test/os/linux/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/symbols
@@ -0,0 +1,5 @@
+--exclude-headers .*stdbool.h$
+--include-symbols opendir
+--include-symbols readdir
+--include-symbols __xstat
+--include-symbols closedir
diff a/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/FFINativeDispatcher.java b/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/FFINativeDispatcher.java
--- /dev/null
+++ b/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/FFINativeDispatcher.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package org.openjdk.bench.jdk.incubator.foreign.nio.support;
+
+import jdk.incubator.foreign.CSupport;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.NativeScope;
+
+public class FFINativeDispatcher extends NativeDispatcher {
+    public MemoryAddress opendir(String path) { return opendirFFI(path); }
+    public String readdir(MemoryAddress dir) { return readdirFFI(dir); }
+    public void closedir(MemoryAddress dir) { closedirFFI(dir); }
+    public UnixFileAttributes readAttributes(String path) { return statFFI(path); }
+
+    public static UnixFileAttributes statFFI(String path) {
+        try (NativeScope scope = NativeScope.unboundedScope()) {
+            var file = CSupport.toCString(path, scope);
+            LibC.stat64 buffer = LibC.stat64.allocate(scope::allocate);
+            LibC.stat64(file, buffer);
+            return new UnixFileAttributes(buffer);
+        }
+    }
+
+    public static MemoryAddress opendirFFI(String path) {
+        try (NativeScope scope = NativeScope.unboundedScope()) {
+            MemoryAddress dir = LibC.opendir(CSupport.toCString(path, scope));
+            if (dir.equals(MemoryAddress.NULL)) {
+                throw new RuntimeException();
+            }
+            return dir;
+        }
+    }
+
+    /**
+     * closedir(DIR* dirp)
+     */
+    public static void closedirFFI(MemoryAddress dir) {
+        LibC.closedir(dir);
+    }
+
+    /**
+     * struct dirent* readdir(DIR *dirp)
+     *
+     * @return  dirent->d_name
+     */
+    public static String readdirFFI(MemoryAddress dir) {
+        MemoryAddress pdir = LibC.readdir(dir);
+        if (pdir.equals(MemoryAddress.NULL)) {
+            return null;
+        }
+
+        MemorySegment segment = MemorySegment.ofNativeRestricted()
+                .asSlice(pdir.toRawLongValue(), LibC.dirent.sizeof());
+        return CSupport.toJavaString(LibC.dirent.at(segment).d_name$ptr());
+    }
+};
diff a/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/LibC.java b/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/LibC.java
--- /dev/null
+++ b/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/LibC.java
@@ -0,0 +1,512 @@
+// Generated by jbind
+
+package org.openjdk.bench.jdk.incubator.foreign.nio.support;
+
+import jdk.incubator.jbind.core.*;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+import jdk.incubator.foreign.*;
+import jdk.incubator.foreign.MemoryLayout.PathElement;
+import static jdk.incubator.foreign.CSupport.*;
+
+import java.util.function.LongFunction;
+
+public final class LibC {
+    private static final LibraryLookup[] LIBRARIES = RuntimeHelper.libraries(new String[] {});
+    public static final class stat64 extends Struct<stat64> {
+        protected stat64(MemorySegment ms) { super(ms); }
+        public static final stat64 at(MemorySegment ms) { return new stat64(ms); }
+        public static final stat64 allocate(LongFunction<MemorySegment> allocator, int count) {
+            return new stat64(allocator.apply(sizeof() * count));
+        }
+        public static final stat64 allocate(LongFunction<MemorySegment> allocator) { return allocate(allocator, 1); }
+        public final stat64 offset(int count) { return at(segment().asSlice(sizeof() * count)); }
+
+        public static final GroupLayout $LAYOUT = MemoryLayout.ofStruct(
+            C_INT.withName("st_dev"),
+            C_SHORT.withName("st_mode"),
+            C_SHORT.withName("st_nlink"),
+            C_LONG.withName("st_ino"),
+            C_INT.withName("st_uid"),
+            C_INT.withName("st_gid"),
+            C_INT.withName("st_rdev"),
+            MemoryLayout.ofPaddingBits(32),
+            MemoryLayout.ofStruct(
+                C_LONG.withName("tv_sec"),
+                C_LONG.withName("tv_nsec")
+            ).withName("st_atimespec"),
+            MemoryLayout.ofStruct(
+                C_LONG.withName("tv_sec"),
+                C_LONG.withName("tv_nsec")
+            ).withName("st_mtimespec"),
+            MemoryLayout.ofStruct(
+                C_LONG.withName("tv_sec"),
+                C_LONG.withName("tv_nsec")
+            ).withName("st_ctimespec"),
+            MemoryLayout.ofStruct(
+                C_LONG.withName("tv_sec"),
+                C_LONG.withName("tv_nsec")
+            ).withName("st_birthtimespec"),
+            C_LONG.withName("st_size"),
+            C_LONG.withName("st_blocks"),
+            C_INT.withName("st_blksize"),
+            C_INT.withName("st_flags"),
+            C_INT.withName("st_gen"),
+            C_INT.withName("st_lspare"),
+            MemoryLayout.ofSequence(2, C_LONG).withName("st_qspare")
+        ).withName("stat64");
+        public static final long sizeof() { return $LAYOUT.byteSize(); }
+        public static final long offsetof(String fieldName) { return $LAYOUT.byteOffset(MemoryLayout.PathElement.groupElement(fieldName)); }
+        @Override
+        public final GroupLayout getLayout() { return $LAYOUT; }
+
+        public static final VarHandle st_dev$VH = RuntimeHelper.varHandle(int.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_dev")));
+        public static final long st_dev$OFFSET = 0L;
+        public final MemorySegment st_dev$ptr() {
+            return segment().asSlice(0L);
+        }
+        public final int st_dev$get() {
+            return (int) st_dev$VH.get(st_dev$ptr());
+        }
+        public final void st_dev$set(int value) {
+            st_dev$VH.set(st_dev$ptr(), value);
+        }
+
+        public static final VarHandle st_mode$VH = RuntimeHelper.varHandle(short.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_mode")));
+        public static final long st_mode$OFFSET = 4L;
+        public final MemorySegment st_mode$ptr() {
+            return segment().asSlice(4L);
+        }
+        public final short st_mode$get() {
+            return (short) st_mode$VH.get(st_mode$ptr());
+        }
+        public final void st_mode$set(short value) {
+            st_mode$VH.set(st_mode$ptr(), value);
+        }
+
+        public static final VarHandle st_nlink$VH = RuntimeHelper.varHandle(short.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_nlink")));
+        public static final long st_nlink$OFFSET = 6L;
+        public final MemorySegment st_nlink$ptr() {
+            return segment().asSlice(6L);
+        }
+        public final short st_nlink$get() {
+            return (short) st_nlink$VH.get(st_nlink$ptr());
+        }
+        public final void st_nlink$set(short value) {
+            st_nlink$VH.set(st_nlink$ptr(), value);
+        }
+
+        public static final VarHandle st_ino$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_ino")));
+        public static final long st_ino$OFFSET = 8L;
+        public final MemorySegment st_ino$ptr() {
+            return segment().asSlice(8L);
+        }
+        public final long st_ino$get() {
+            return (long) st_ino$VH.get(st_ino$ptr());
+        }
+        public final void st_ino$set(long value) {
+            st_ino$VH.set(st_ino$ptr(), value);
+        }
+
+        public static final VarHandle st_uid$VH = RuntimeHelper.varHandle(int.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_uid")));
+        public static final long st_uid$OFFSET = 16L;
+        public final MemorySegment st_uid$ptr() {
+            return segment().asSlice(16L);
+        }
+        public final int st_uid$get() {
+            return (int) st_uid$VH.get(st_uid$ptr());
+        }
+        public final void st_uid$set(int value) {
+            st_uid$VH.set(st_uid$ptr(), value);
+        }
+
+        public static final VarHandle st_gid$VH = RuntimeHelper.varHandle(int.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_gid")));
+        public static final long st_gid$OFFSET = 20L;
+        public final MemorySegment st_gid$ptr() {
+            return segment().asSlice(20L);
+        }
+        public final int st_gid$get() {
+            return (int) st_gid$VH.get(st_gid$ptr());
+        }
+        public final void st_gid$set(int value) {
+            st_gid$VH.set(st_gid$ptr(), value);
+        }
+
+        public static final VarHandle st_rdev$VH = RuntimeHelper.varHandle(int.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_rdev")));
+        public static final long st_rdev$OFFSET = 24L;
+        public final MemorySegment st_rdev$ptr() {
+            return segment().asSlice(24L);
+        }
+        public final int st_rdev$get() {
+            return (int) st_rdev$VH.get(st_rdev$ptr());
+        }
+        public final void st_rdev$set(int value) {
+            st_rdev$VH.set(st_rdev$ptr(), value);
+        }
+
+        public static final long st_atimespec$OFFSET = 32L;
+        public final MemorySegment st_atimespec$ptr() {
+            return segment().asSlice(32L);
+        }
+        public final timespec st_atimespec$get() {
+            return timespec.at(st_atimespec$ptr());
+        }
+        public final void st_atimespec$set(timespec value) {
+            timespec.at(st_atimespec$ptr()).asSegment().copyFrom(value.asSegment());
+        }
+
+        public static final long st_mtimespec$OFFSET = 48L;
+        public final MemorySegment st_mtimespec$ptr() {
+            return segment().asSlice(48L);
+        }
+        public final timespec st_mtimespec$get() {
+            return timespec.at(st_mtimespec$ptr());
+        }
+        public final void st_mtimespec$set(timespec value) {
+            timespec.at(st_mtimespec$ptr()).asSegment().copyFrom(value.asSegment());
+        }
+
+        public static final long st_ctimespec$OFFSET = 64L;
+        public final MemorySegment st_ctimespec$ptr() {
+            return segment().asSlice(64L);
+        }
+        public final timespec st_ctimespec$get() {
+            return timespec.at(st_ctimespec$ptr());
+        }
+        public final void st_ctimespec$set(timespec value) {
+            timespec.at(st_ctimespec$ptr()).asSegment().copyFrom(value.asSegment());
+        }
+
+        public static final long st_birthtimespec$OFFSET = 80L;
+        public final MemorySegment st_birthtimespec$ptr() {
+            return segment().asSlice(80L);
+        }
+        public final timespec st_birthtimespec$get() {
+            return timespec.at(st_birthtimespec$ptr());
+        }
+        public final void st_birthtimespec$set(timespec value) {
+            timespec.at(st_birthtimespec$ptr()).asSegment().copyFrom(value.asSegment());
+        }
+
+        public static final VarHandle st_size$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_size")));
+        public static final long st_size$OFFSET = 96L;
+        public final MemorySegment st_size$ptr() {
+            return segment().asSlice(96L);
+        }
+        public final long st_size$get() {
+            return (long) st_size$VH.get(st_size$ptr());
+        }
+        public final void st_size$set(long value) {
+            st_size$VH.set(st_size$ptr(), value);
+        }
+
+        public static final VarHandle st_blocks$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_blocks")));
+        public static final long st_blocks$OFFSET = 104L;
+        public final MemorySegment st_blocks$ptr() {
+            return segment().asSlice(104L);
+        }
+        public final long st_blocks$get() {
+            return (long) st_blocks$VH.get(st_blocks$ptr());
+        }
+        public final void st_blocks$set(long value) {
+            st_blocks$VH.set(st_blocks$ptr(), value);
+        }
+
+        public static final VarHandle st_blksize$VH = RuntimeHelper.varHandle(int.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_blksize")));
+        public static final long st_blksize$OFFSET = 112L;
+        public final MemorySegment st_blksize$ptr() {
+            return segment().asSlice(112L);
+        }
+        public final int st_blksize$get() {
+            return (int) st_blksize$VH.get(st_blksize$ptr());
+        }
+        public final void st_blksize$set(int value) {
+            st_blksize$VH.set(st_blksize$ptr(), value);
+        }
+
+        public static final VarHandle st_flags$VH = RuntimeHelper.varHandle(int.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_flags")));
+        public static final long st_flags$OFFSET = 116L;
+        public final MemorySegment st_flags$ptr() {
+            return segment().asSlice(116L);
+        }
+        public final int st_flags$get() {
+            return (int) st_flags$VH.get(st_flags$ptr());
+        }
+        public final void st_flags$set(int value) {
+            st_flags$VH.set(st_flags$ptr(), value);
+        }
+
+        public static final VarHandle st_gen$VH = RuntimeHelper.varHandle(int.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_gen")));
+        public static final long st_gen$OFFSET = 120L;
+        public final MemorySegment st_gen$ptr() {
+            return segment().asSlice(120L);
+        }
+        public final int st_gen$get() {
+            return (int) st_gen$VH.get(st_gen$ptr());
+        }
+        public final void st_gen$set(int value) {
+            st_gen$VH.set(st_gen$ptr(), value);
+        }
+
+        public static final VarHandle st_lspare$VH = RuntimeHelper.varHandle(int.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_lspare")));
+        public static final long st_lspare$OFFSET = 124L;
+        public final MemorySegment st_lspare$ptr() {
+            return segment().asSlice(124L);
+        }
+        public final int st_lspare$get() {
+            return (int) st_lspare$VH.get(st_lspare$ptr());
+        }
+        public final void st_lspare$set(int value) {
+            st_lspare$VH.set(st_lspare$ptr(), value);
+        }
+
+        public static final VarHandle st_qspare$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("st_qspare")));
+        public static final long st_qspare$OFFSET = 128L;
+        public final MemorySegment st_qspare$ptr() {
+            return segment().asSlice(128L);
+        }
+        public final long st_qspare$get(long idx0) {
+            return (long) st_qspare$VH.get(st_qspare$ptr(), idx0);
+        }
+        public final void st_qspare$set(long idx0, long value) {
+            st_qspare$VH.set(st_qspare$ptr(), idx0, value);
+        }
+    }
+    public static final class timespec extends Struct<timespec> {
+        protected timespec(MemorySegment ms) { super(ms); }
+        public static final timespec at(MemorySegment ms) { return new timespec(ms); }
+        public static final timespec allocate(LongFunction<MemorySegment> allocator, int count) {
+            return new timespec(allocator.apply(sizeof() * count));
+        }
+        public static final timespec allocate(LongFunction<MemorySegment> allocator) { return allocate(allocator, 1); }
+        public final timespec offset(int count) { return at(segment().asSlice(sizeof() * count)); }
+
+        public static final GroupLayout $LAYOUT = MemoryLayout.ofStruct(
+            C_LONG.withName("tv_sec"),
+            C_LONG.withName("tv_nsec")
+        ).withName("timespec");
+        public static final long sizeof() { return $LAYOUT.byteSize(); }
+        public static final long offsetof(String fieldName) { return $LAYOUT.byteOffset(MemoryLayout.PathElement.groupElement(fieldName)); }
+        @Override
+        public final GroupLayout getLayout() { return $LAYOUT; }
+
+        public static final VarHandle tv_sec$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("tv_sec")));
+        public static final long tv_sec$OFFSET = 0L;
+        public final MemorySegment tv_sec$ptr() {
+            return segment().asSlice(0L);
+        }
+        public final long tv_sec$get() {
+            return (long) tv_sec$VH.get(tv_sec$ptr());
+        }
+        public final void tv_sec$set(long value) {
+            tv_sec$VH.set(tv_sec$ptr(), value);
+        }
+
+        public static final VarHandle tv_nsec$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("tv_nsec")));
+        public static final long tv_nsec$OFFSET = 8L;
+        public final MemorySegment tv_nsec$ptr() {
+            return segment().asSlice(8L);
+        }
+        public final long tv_nsec$get() {
+            return (long) tv_nsec$VH.get(tv_nsec$ptr());
+        }
+        public final void tv_nsec$set(long value) {
+            tv_nsec$VH.set(tv_nsec$ptr(), value);
+        }
+    }
+    public static final class _opaque_pthread_mutex_t extends Struct<_opaque_pthread_mutex_t> {
+        protected _opaque_pthread_mutex_t(MemorySegment ms) { super(ms); }
+        public static final _opaque_pthread_mutex_t at(MemorySegment ms) { return new _opaque_pthread_mutex_t(ms); }
+        public static final _opaque_pthread_mutex_t allocate(LongFunction<MemorySegment> allocator, int count) {
+            return new _opaque_pthread_mutex_t(allocator.apply(sizeof() * count));
+        }
+        public static final _opaque_pthread_mutex_t allocate(LongFunction<MemorySegment> allocator) { return allocate(allocator, 1); }
+        public final _opaque_pthread_mutex_t offset(int count) { return at(segment().asSlice(sizeof() * count)); }
+
+        public static final GroupLayout $LAYOUT = MemoryLayout.ofStruct(
+            C_LONG.withName("__sig"),
+            MemoryLayout.ofSequence(56, C_BOOL).withName("__opaque")
+        ).withName("_opaque_pthread_mutex_t");
+        public static final long sizeof() { return $LAYOUT.byteSize(); }
+        public static final long offsetof(String fieldName) { return $LAYOUT.byteOffset(MemoryLayout.PathElement.groupElement(fieldName)); }
+        @Override
+        public final GroupLayout getLayout() { return $LAYOUT; }
+
+        public static final VarHandle __sig$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("__sig")));
+        public static final long __sig$OFFSET = 0L;
+        public final MemorySegment __sig$ptr() {
+            return segment().asSlice(0L);
+        }
+        public final long __sig$get() {
+            return (long) __sig$VH.get(__sig$ptr());
+        }
+        public final void __sig$set(long value) {
+            __sig$VH.set(__sig$ptr(), value);
+        }
+
+        public static final VarHandle __opaque$VH = RuntimeHelper.varHandle(byte.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("__opaque")));
+        public static final long __opaque$OFFSET = 8L;
+        public final MemorySegment __opaque$ptr() {
+            return segment().asSlice(8L);
+        }
+        public final byte __opaque$get(long idx0) {
+            return (byte) __opaque$VH.get(__opaque$ptr(), idx0);
+        }
+        public final void __opaque$set(long idx0, byte value) {
+            __opaque$VH.set(__opaque$ptr(), idx0, value);
+        }
+    }
+    public static final class dirent extends Struct<dirent> {
+        protected dirent(MemorySegment ms) { super(ms); }
+        public static final dirent at(MemorySegment ms) { return new dirent(ms); }
+        public static final dirent allocate(LongFunction<MemorySegment> allocator, int count) {
+            return new dirent(allocator.apply(sizeof() * count));
+        }
+        public static final dirent allocate(LongFunction<MemorySegment> allocator) { return allocate(allocator, 1); }
+        public final dirent offset(int count) { return at(segment().asSlice(sizeof() * count)); }
+
+        public static final GroupLayout $LAYOUT = MemoryLayout.ofStruct(
+            C_LONG.withName("d_ino"),
+            C_LONG.withName("d_seekoff"),
+            C_SHORT.withName("d_reclen"),
+            C_SHORT.withName("d_namlen"),
+            C_BOOL.withName("d_type"),
+            MemoryLayout.ofSequence(1024, C_BOOL).withName("d_name"),
+            MemoryLayout.ofPaddingBits(24)
+        ).withName("dirent");
+        public static final long sizeof() { return $LAYOUT.byteSize(); }
+        public static final long offsetof(String fieldName) { return $LAYOUT.byteOffset(MemoryLayout.PathElement.groupElement(fieldName)); }
+        @Override
+        public final GroupLayout getLayout() { return $LAYOUT; }
+
+        public static final VarHandle d_ino$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("d_ino")));
+        public static final long d_ino$OFFSET = 0L;
+        public final MemorySegment d_ino$ptr() {
+            return segment().asSlice(0L);
+        }
+        public final long d_ino$get() {
+            return (long) d_ino$VH.get(d_ino$ptr());
+        }
+        public final void d_ino$set(long value) {
+            d_ino$VH.set(d_ino$ptr(), value);
+        }
+
+        public static final VarHandle d_seekoff$VH = RuntimeHelper.varHandle(long.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("d_seekoff")));
+        public static final long d_seekoff$OFFSET = 8L;
+        public final MemorySegment d_seekoff$ptr() {
+            return segment().asSlice(8L);
+        }
+        public final long d_seekoff$get() {
+            return (long) d_seekoff$VH.get(d_seekoff$ptr());
+        }
+        public final void d_seekoff$set(long value) {
+            d_seekoff$VH.set(d_seekoff$ptr(), value);
+        }
+
+        public static final VarHandle d_reclen$VH = RuntimeHelper.varHandle(short.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("d_reclen")));
+        public static final long d_reclen$OFFSET = 16L;
+        public final MemorySegment d_reclen$ptr() {
+            return segment().asSlice(16L);
+        }
+        public final short d_reclen$get() {
+            return (short) d_reclen$VH.get(d_reclen$ptr());
+        }
+        public final void d_reclen$set(short value) {
+            d_reclen$VH.set(d_reclen$ptr(), value);
+        }
+
+        public static final VarHandle d_namlen$VH = RuntimeHelper.varHandle(short.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("d_namlen")));
+        public static final long d_namlen$OFFSET = 18L;
+        public final MemorySegment d_namlen$ptr() {
+            return segment().asSlice(18L);
+        }
+        public final short d_namlen$get() {
+            return (short) d_namlen$VH.get(d_namlen$ptr());
+        }
+        public final void d_namlen$set(short value) {
+            d_namlen$VH.set(d_namlen$ptr(), value);
+        }
+
+        public static final VarHandle d_type$VH = RuntimeHelper.varHandle(byte.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("d_type")));
+        public static final long d_type$OFFSET = 20L;
+        public final MemorySegment d_type$ptr() {
+            return segment().asSlice(20L);
+        }
+        public final byte d_type$get() {
+            return (byte) d_type$VH.get(d_type$ptr());
+        }
+        public final void d_type$set(byte value) {
+            d_type$VH.set(d_type$ptr(), value);
+        }
+
+        public static final VarHandle d_name$VH = RuntimeHelper.varHandle(byte.class, $LAYOUT.select(MemoryLayout.PathElement.groupElement("d_name")));
+        public static final long d_name$OFFSET = 21L;
+        public final MemorySegment d_name$ptr() {
+            return segment().asSlice(21L);
+        }
+        public final byte d_name$get(long idx0) {
+            return (byte) d_name$VH.get(d_name$ptr(), idx0);
+        }
+        public final void d_name$set(long idx0, byte value) {
+            d_name$VH.set(d_name$ptr(), idx0, value);
+        }
+    }
+    public static final MethodHandle mh_stat64 = RuntimeHelper.downcallHandle(
+        LIBRARIES, "stat64",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_POINTER
+        ), false
+    );
+    public static final int stat64(jdk.incubator.foreign.Addressable x0, jdk.incubator.foreign.Addressable x1) {
+        try {
+            return (int) mh_stat64.invokeExact(x0.address(), x1.address());
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle mh_closedir = RuntimeHelper.downcallHandle(
+        LIBRARIES, "closedir",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        ), false
+    );
+    public static final int closedir(jdk.incubator.foreign.Addressable x0) {
+        try {
+            return (int) mh_closedir.invokeExact(x0.address());
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle mh_opendir = RuntimeHelper.downcallHandle(
+        LIBRARIES, "opendir$INODE64",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        ), false
+    );
+    public static final jdk.incubator.foreign.MemoryAddress opendir(jdk.incubator.foreign.Addressable x0) {
+        try {
+            return (jdk.incubator.foreign.MemoryAddress) mh_opendir.invokeExact(x0.address());
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle mh_readdir = RuntimeHelper.downcallHandle(
+        LIBRARIES, "readdir$INODE64",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        ), false
+    );
+    public static final jdk.incubator.foreign.MemoryAddress readdir(jdk.incubator.foreign.Addressable x0) {
+        try {
+            return (jdk.incubator.foreign.MemoryAddress) mh_readdir.invokeExact(x0.address());
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+}
+
diff a/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/UnixFileAttributes.java b/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/UnixFileAttributes.java
--- /dev/null
+++ b/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/UnixFileAttributes.java
@@ -0,0 +1,153 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package org.openjdk.bench.jdk.incubator.foreign.nio.support;
+
+import java.nio.file.attribute.FileTime;
+import java.util.concurrent.TimeUnit;
+
+import jdk.incubator.foreign.MemoryAddress;
+
+/**
+ * Unix implementation of PosixFileAttributes.
+ */
+
+public class UnixFileAttributes {
+    private int     st_mode;
+    private long    st_ino;
+    private long    st_dev;
+    private long    st_rdev;
+    private int     st_nlink;
+    private int     st_uid;
+    private int     st_gid;
+    private long    st_size;
+    private long    st_atime_sec;
+    private long    st_atime_nsec;
+    private long    st_mtime_sec;
+    private long    st_mtime_nsec;
+    private long    st_ctime_sec;
+    private long    st_ctime_nsec;
+    private long    st_birthtime_sec;
+
+    UnixFileAttributes() {
+        super();
+    }
+
+    UnixFileAttributes(LibC.stat64 buf) {
+        st_mode = buf.st_mode$get();
+        st_ino = buf.st_ino$get();
+        st_dev = buf.st_dev$get();
+        st_rdev = buf.st_rdev$get();
+        st_nlink = buf.st_nlink$get();
+        st_uid = buf.st_uid$get();
+        st_gid = buf.st_gid$get();
+        st_size = buf.st_size$get();
+        st_atime_sec = buf.st_atimespec$get().tv_sec$get();
+        st_mtime_sec = buf.st_mtimespec$get().tv_sec$get();
+        st_ctime_sec = buf.st_ctimespec$get().tv_sec$get();
+        st_atime_nsec = buf.st_atimespec$get().tv_nsec$get();
+        st_mtime_nsec = buf.st_mtimespec$get().tv_nsec$get();
+        st_ctime_nsec = buf.st_ctimespec$get().tv_nsec$get();
+        st_birthtime_sec = buf.st_birthtimespec$get().tv_sec$get();
+    }
+
+    UnixFileAttributes(MemoryAddress buf) {
+        try {
+            st_mode = (int) LibC.stat64.st_mode$VH.get(buf);
+            st_ino = (long) LibC.stat64.st_ino$VH.get(buf);
+            st_dev = (long) LibC.stat64.st_dev$VH.get(buf);
+            st_rdev = (long) LibC.stat64.st_rdev$VH.get(buf);
+            st_nlink = (int) LibC.stat64.st_nlink$VH.get(buf);
+            st_uid = (int) LibC.stat64.st_uid$VH.get(buf);
+            st_gid = (int) LibC.stat64.st_gid$VH.get(buf);
+            st_size = (long) LibC.stat64.st_size$VH.get(buf);
+            MemoryAddress ts = buf.addOffset(LibC.stat64.st_atimespec$OFFSET);
+            st_atime_sec = (long) LibC.timespec.tv_sec$VH.get(ts);
+            st_atime_nsec = (long) LibC.timespec.tv_nsec$VH.get(ts);
+
+            ts = buf.addOffset(LibC.stat64.st_mtimespec$OFFSET);
+            st_mtime_sec = (long) LibC.timespec.tv_sec$VH.get(ts);
+            st_mtime_nsec = (long) LibC.timespec.tv_nsec$VH.get(ts);
+
+            ts = buf.addOffset(LibC.stat64.st_ctimespec$OFFSET);
+            st_ctime_sec = (long) LibC.timespec.tv_sec$VH.get(ts);
+            st_ctime_nsec = (long) LibC.timespec.tv_nsec$VH.get(ts);
+
+            ts = buf.addOffset(LibC.stat64.st_birthtimespec$OFFSET);
+            st_birthtime_sec = (long) LibC.timespec.tv_sec$VH.get(ts);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+
+    public static UnixFileAttributes from(MemoryAddress buf) {
+        return new UnixFileAttributes(buf);
+    }
+
+    // package-private
+    public int mode()  { return st_mode; }
+    public long ino()  { return st_ino; }
+    public long dev()  { return st_dev; }
+    public long rdev() { return st_rdev; }
+    public int nlink() { return st_nlink; }
+    public int uid()   { return st_uid; }
+    public int gid()   { return st_gid; }
+
+    private static FileTime toFileTime(long sec, long nsec) {
+        if (nsec == 0) {
+            return FileTime.from(sec, TimeUnit.SECONDS);
+        } else {
+            try {
+                long nanos = Math.addExact(nsec,
+                    Math.multiplyExact(sec, 1_000_000_000L));
+                return FileTime.from(nanos, TimeUnit.NANOSECONDS);
+            } catch (ArithmeticException ignore) {
+                // truncate to microseconds if nanoseconds overflow
+                long micro = sec*1_000_000L + nsec/1_000L;
+                return FileTime.from(micro, TimeUnit.MICROSECONDS);
+            }
+        }
+    }
+
+    public FileTime ctime() {
+        return toFileTime(st_ctime_sec, st_ctime_nsec);
+    }
+
+    public FileTime lastModifiedTime() {
+        return toFileTime(st_mtime_sec, st_mtime_nsec);
+    }
+
+    public FileTime lastAccessTime() {
+        return toFileTime(st_atime_sec, st_atime_nsec);
+    }
+
+    public FileTime creationTime() {
+        return FileTime.from(st_birthtime_sec, TimeUnit.SECONDS);
+    }
+
+    public long size() {
+        return st_size;
+    }
+}
diff a/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/gencode.sh b/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/gencode.sh
--- /dev/null
+++ b/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/gencode.sh
@@ -0,0 +1,3 @@
+SYSROOT=`xcrun --show-sdk-path`
+COMMON_ARGS="-C -isysroot -C $SYSROOT -J-Dforeign.restricted=permit"
+jbind -n LibC $COMMON_ARGS @pkg.args @symbols headers.h
diff a/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/headers.h b/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/headers.h
--- /dev/null
+++ b/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/headers.h
@@ -0,0 +1,3 @@
+#include <sys/stat.h>
+#include <dirent.h>
+
diff a/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/pkg.args b/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/pkg.args
--- /dev/null
+++ b/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/pkg.args
@@ -0,0 +1,10 @@
+--src-dump-dir=../../../../../../../..
+-d output
+-t org.openjdk.bench.jdk.incubator.foreign.nio.support
+--package-map /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include=org.openjdk.bench.jdk.incubator.foreign.nio.support
+--package-map /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types=jdk.internal.panama.systypes
+--package-map /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks=jdk.internal.macos
+--package-map /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/CoreFoundation.framework/Headers=jdk.internal.macos.cf
+--package-map /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/CoreServices.framework/Headers=jdk.internal.macos.cs
+--exclude-headers .*/math.h$
+--exclude-headers .*/stdbool.h$
diff a/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/symbols b/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/symbols
--- /dev/null
+++ b/test/os/macosx/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/symbols
@@ -0,0 +1,5 @@
+--exclude-headers .*stdbool.h$
+--include-symbols opendir
+--include-symbols readdir
+--include-symbols stat64
+--include-symbols closedir
diff a/test/os/unix/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/libNativeDispatcher.c b/test/os/unix/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/libNativeDispatcher.c
--- /dev/null
+++ b/test/os/unix/micro/org/openjdk/bench/jdk/incubator/foreign/nio/support/libNativeDispatcher.c
@@ -0,0 +1,160 @@
+#include <jni.h>
+#include <sys/stat.h>
+#include <dirent.h>
+
+#define CHECK_NULL_RETURN(x, y)                  \
+    do {                                        \
+        if ((x) == NULL) {                      \
+            return (y);                         \
+        }                                       \
+    } while (0)                                 \
+
+static jfieldID attrs_st_mode;
+static jfieldID attrs_st_ino;
+static jfieldID attrs_st_dev;
+static jfieldID attrs_st_rdev;
+static jfieldID attrs_st_nlink;
+static jfieldID attrs_st_uid;
+static jfieldID attrs_st_gid;
+static jfieldID attrs_st_size;
+static jfieldID attrs_st_atime_sec;
+static jfieldID attrs_st_atime_nsec;
+static jfieldID attrs_st_mtime_sec;
+static jfieldID attrs_st_mtime_nsec;
+static jfieldID attrs_st_ctime_sec;
+static jfieldID attrs_st_ctime_nsec;
+
+#ifdef _DARWIN_FEATURE_64_BIT_INODE
+static jfieldID attrs_st_birthtime_sec;
+#endif
+
+/**
+ * Copy stat members into sun.nio.fs.UnixFileAttributes
+ */
+static void prepAttributes(JNIEnv* env, struct stat* buf, jobject attrs) {
+    (*env)->SetIntField(env, attrs, attrs_st_mode, (jint)buf->st_mode);
+    (*env)->SetLongField(env, attrs, attrs_st_ino, (jlong)buf->st_ino);
+    (*env)->SetLongField(env, attrs, attrs_st_dev, (jlong)buf->st_dev);
+    (*env)->SetLongField(env, attrs, attrs_st_rdev, (jlong)buf->st_rdev);
+    (*env)->SetIntField(env, attrs, attrs_st_nlink, (jint)buf->st_nlink);
+    (*env)->SetIntField(env, attrs, attrs_st_uid, (jint)buf->st_uid);
+    (*env)->SetIntField(env, attrs, attrs_st_gid, (jint)buf->st_gid);
+    (*env)->SetLongField(env, attrs, attrs_st_size, (jlong)buf->st_size);
+    (*env)->SetLongField(env, attrs, attrs_st_atime_sec, (jlong)buf->st_atime);
+    (*env)->SetLongField(env, attrs, attrs_st_mtime_sec, (jlong)buf->st_mtime);
+    (*env)->SetLongField(env, attrs, attrs_st_ctime_sec, (jlong)buf->st_ctime);
+
+#ifdef _DARWIN_FEATURE_64_BIT_INODE
+    (*env)->SetLongField(env, attrs, attrs_st_birthtime_sec, (jlong)buf->st_birthtime);
+#endif
+
+#ifndef MACOSX
+    (*env)->SetLongField(env, attrs, attrs_st_atime_nsec, (jlong)buf->st_atim.tv_nsec);
+    (*env)->SetLongField(env, attrs, attrs_st_mtime_nsec, (jlong)buf->st_mtim.tv_nsec);
+    (*env)->SetLongField(env, attrs, attrs_st_ctime_nsec, (jlong)buf->st_ctim.tv_nsec);
+#else
+    (*env)->SetLongField(env, attrs, attrs_st_atime_nsec, (jlong)buf->st_atimespec.tv_nsec);
+    (*env)->SetLongField(env, attrs, attrs_st_mtime_nsec, (jlong)buf->st_mtimespec.tv_nsec);
+    (*env)->SetLongField(env, attrs, attrs_st_ctime_nsec, (jlong)buf->st_ctimespec.tv_nsec);
+#endif
+}
+
+/*
+ * Class:     org_openjdk_bench_jdk_incubator_foreign_nio_support_NativeDispatcher
+ * Method:    opendirJNI
+ * Signature: (Ljava/lang/String;)J
+ */
+JNIEXPORT jlong JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_nio_support_NativeDispatcher_opendirJNI
+  (JNIEnv *env, jclass cls, jstring path)
+{
+  const char *p = (*env)->GetStringUTFChars(env, path, NULL);
+  DIR* dirp = opendir(p);
+  (*env)->ReleaseStringUTFChars(env, path, p);
+  return (jlong) dirp;
+}
+
+/*
+ * Class:     org_openjdk_bench_jdk_incubator_foreign_nio_support_NativeDispatcher
+ * Method:    readdirJNI
+ * Signature: (J)Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_nio_support_NativeDispatcher_readdirJNI
+  (JNIEnv *env, jclass cls, jlong dir)
+{
+  DIR * dirp = (DIR*) dir;
+  struct dirent *data = readdir(dirp);
+  if (data == NULL) {
+    return NULL;
+  }
+  return (*env)->NewStringUTF(env, data->d_name);
+}
+
+/*
+ * Class:     org_openjdk_bench_jdk_incubator_foreign_nio_support_NativeDispatcher
+ * Method:    closedirJNI
+ * Signature: (J)V
+ */
+JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_nio_support_NativeDispatcher_closedirJNI
+  (JNIEnv *env, jclass cls, jlong dir)
+{
+  DIR * dirp = (DIR*) dir;
+  closedir(dirp);
+}
+
+/*
+ * Class:     org_openjdk_bench_jdk_incubator_foreign_nio_support_NativeDispatcher
+ * Method:    statJNI
+ * Signature: (Ljava/lang/String;Lorg/openjdk/bench/jdk/incubator/foreign/nio/support/UnixFileAttributes;)V
+ */
+JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_nio_support_NativeDispatcher_statJNI
+  (JNIEnv *env, jclass cls, jstring path, jobject attrs)
+{
+  struct stat data;
+  const char *file = (*env)->GetStringUTFChars(env, path, NULL);
+  stat(file, &data);
+  (*env)->ReleaseStringUTFChars(env, path, file);
+  prepAttributes(env, &data, attrs);
+}
+
+JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_nio_support_NativeDispatcher_initJNI
+  (JNIEnv* env, jclass this)
+{
+    jclass clazz;
+
+    clazz = (*env)->FindClass(env, "org/openjdk/bench/jdk/incubator/foreign/nio/support/UnixFileAttributes");
+    CHECK_NULL_RETURN(clazz, 0);
+    attrs_st_mode = (*env)->GetFieldID(env, clazz, "st_mode", "I");
+    CHECK_NULL_RETURN(attrs_st_mode, 0);
+    attrs_st_ino = (*env)->GetFieldID(env, clazz, "st_ino", "J");
+    CHECK_NULL_RETURN(attrs_st_ino, 0);
+    attrs_st_dev = (*env)->GetFieldID(env, clazz, "st_dev", "J");
+    CHECK_NULL_RETURN(attrs_st_dev, 0);
+    attrs_st_rdev = (*env)->GetFieldID(env, clazz, "st_rdev", "J");
+    CHECK_NULL_RETURN(attrs_st_rdev, 0);
+    attrs_st_nlink = (*env)->GetFieldID(env, clazz, "st_nlink", "I");
+    CHECK_NULL_RETURN(attrs_st_nlink, 0);
+    attrs_st_uid = (*env)->GetFieldID(env, clazz, "st_uid", "I");
+    CHECK_NULL_RETURN(attrs_st_uid, 0);
+    attrs_st_gid = (*env)->GetFieldID(env, clazz, "st_gid", "I");
+    CHECK_NULL_RETURN(attrs_st_gid, 0);
+    attrs_st_size = (*env)->GetFieldID(env, clazz, "st_size", "J");
+    CHECK_NULL_RETURN(attrs_st_size, 0);
+    attrs_st_atime_sec = (*env)->GetFieldID(env, clazz, "st_atime_sec", "J");
+    CHECK_NULL_RETURN(attrs_st_atime_sec, 0);
+    attrs_st_atime_nsec = (*env)->GetFieldID(env, clazz, "st_atime_nsec", "J");
+    CHECK_NULL_RETURN(attrs_st_atime_nsec, 0);
+    attrs_st_mtime_sec = (*env)->GetFieldID(env, clazz, "st_mtime_sec", "J");
+    CHECK_NULL_RETURN(attrs_st_mtime_sec, 0);
+    attrs_st_mtime_nsec = (*env)->GetFieldID(env, clazz, "st_mtime_nsec", "J");
+    CHECK_NULL_RETURN(attrs_st_mtime_nsec, 0);
+    attrs_st_ctime_sec = (*env)->GetFieldID(env, clazz, "st_ctime_sec", "J");
+    CHECK_NULL_RETURN(attrs_st_ctime_sec, 0);
+    attrs_st_ctime_nsec = (*env)->GetFieldID(env, clazz, "st_ctime_nsec", "J");
+    CHECK_NULL_RETURN(attrs_st_ctime_nsec, 0);
+
+#ifdef _DARWIN_FEATURE_64_BIT_INODE
+    attrs_st_birthtime_sec = (*env)->GetFieldID(env, clazz, "st_birthtime_sec", "J");
+    CHECK_NULL_RETURN(attrs_st_birthtime_sec, 0);
+#endif
+    return 0;
+}
