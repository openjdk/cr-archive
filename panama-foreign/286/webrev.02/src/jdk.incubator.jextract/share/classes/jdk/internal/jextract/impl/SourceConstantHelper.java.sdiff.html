<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/SourceConstantHelper.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="OutputFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/SourceConstantHelper.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.jextract.impl;
 27 
<span class="line-modified"> 28 import jdk.incubator.foreign.*;</span>
<span class="line-modified"> 29 </span>






 30 import javax.tools.JavaFileObject;
 31 import java.lang.constant.ClassDesc;
 32 import java.lang.constant.DirectMethodHandleDesc;
 33 import java.lang.constant.MethodHandleDesc;
 34 import java.lang.invoke.MethodHandle;
 35 import java.lang.invoke.MethodType;
 36 import java.lang.invoke.VarHandle;
 37 import java.net.URI;
<span class="line-modified"> 38 import java.util.HashSet;</span>

 39 import java.util.List;

 40 import java.util.Objects;
<span class="line-removed"> 41 import java.util.Set;</span>
 42 
 43 import static java.lang.invoke.MethodType.methodType;
 44 
 45 // generates ConstantHelper as java source
 46 class SourceConstantHelper implements ConstantHelper {
<span class="line-modified"> 47     private static final String PRIVATE_MODS = &quot;private static final &quot;;</span>

 48     private static final String ABI_CLASS_ATTR;

 49 
 50     static {
 51         String abi = CSupport.getSystemLinker().name();
 52         ABI_CLASS_ATTR = switch (abi) {
 53             case CSupport.SysV.NAME -&gt; CSupport.SysV.CLASS_ATTRIBUTE_NAME;
 54             case CSupport.Win64.NAME -&gt; CSupport.Win64.CLASS_ATTRIBUTE_NAME;
 55             case CSupport.AArch64.NAME -&gt; CSupport.AArch64.CLASS_ATTRIBUTE_NAME;
 56             default -&gt; throw new UnsupportedOperationException(&quot;Unsupported Foreign Linker: &quot; + abi);
 57         };
 58     }
 59 
 60     // set of names generates already
<span class="line-modified"> 61     private static final Set&lt;String&gt; namesGenerated = new HashSet&lt;&gt;();</span>
 62     // code buffer
<span class="line-modified"> 63     private final StringBuilder sb = new StringBuilder();</span>
 64     // current line alignment (number of 4-spaces)
 65     private int align;
 66     private final String pkgName;
<span class="line-modified"> 67     private final String className;</span>
<span class="line-modified"> 68     private final ClassDesc CD_constantsHelper;</span>




 69 
 70     SourceConstantHelper(String parentClassName, String[] libraryNames) {
 71         int idx = parentClassName.lastIndexOf(&#39;.&#39;);
 72         this.pkgName = idx == -1? &quot;&quot; : parentClassName.substring(0, idx);
<span class="line-modified"> 73         String clsName = parentClassName.substring(idx + 1);</span>
<span class="line-modified"> 74         this.className =  clsName + &quot;$constants&quot;;</span>
<span class="line-modified"> 75         this.CD_constantsHelper = ClassDesc.of(pkgName.isEmpty()? className : (pkgName +&quot;.&quot; + className));</span>
<span class="line-modified"> 76         classBegin(libraryNames);</span>


















 77     }
 78 
 79     @Override
 80     public DirectMethodHandleDesc addLayout(String javaName, MemoryLayout layout) {

 81         String layoutName = javaName + &quot;$LAYOUT&quot;;
<span class="line-modified"> 82         if (namesGenerated.add(layoutName)) {</span>
<span class="line-modified"> 83             String fieldName = emitLayoutField(javaName, layout);</span>
<span class="line-removed"> 84             return emitGetter(layoutName, MemoryLayout.class, fieldName);</span>
 85         } else {
<span class="line-modified"> 86             return getGetterDesc(layoutName, MethodHandle.class);</span>



 87         }
 88     }
 89 
 90     @Override
 91     public DirectMethodHandleDesc addVarHandle(String javaName, String nativeName, MemoryLayout layout, Class&lt;?&gt; type, MemoryLayout parentLayout) {

 92         String varHandleName = javaName + &quot;$VH&quot;;
<span class="line-modified"> 93         if (namesGenerated.add(varHandleName)) {</span>
<span class="line-modified"> 94             String fieldName = emitVarHandleField(javaName, type, layout);</span>
<span class="line-modified"> 95             return emitGetter(varHandleName, VarHandle.class, fieldName);</span>
 96         } else {
<span class="line-modified"> 97             return getGetterDesc(varHandleName, VarHandle.class);</span>



 98         }
 99     }
100 
101     @Override
102     public DirectMethodHandleDesc addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {

103         String mhName = javaName + &quot;$MH&quot;;
<span class="line-modified">104         if (namesGenerated.add(mhName)) {</span>
<span class="line-modified">105             String fieldName = emitMethodHandleField(javaName, nativeName, mtype, desc, varargs);</span>
<span class="line-removed">106             return emitGetter(mhName, MethodHandle.class, fieldName);</span>
107         } else {
<span class="line-modified">108             return getGetterDesc(mhName, MethodHandle.class);</span>



109         }
110     }
111 
112     @Override
113     public DirectMethodHandleDesc addSegment(String javaName, String nativeName, MemoryLayout layout) {

114         String segmentName = javaName + &quot;$SEGMENT&quot;;
<span class="line-modified">115         if (namesGenerated.add(segmentName)) {</span>
<span class="line-modified">116             String fieldName = emitSegmentField(javaName, nativeName, layout);</span>
<span class="line-removed">117             return emitGetter(segmentName, MemorySegment.class, fieldName);</span>
118         } else {
<span class="line-modified">119             return getGetterDesc(segmentName, MemorySegment.class);</span>



120         }
121     }
122 
123     @Override
124     public DirectMethodHandleDesc addFunctionDesc(String javaName, FunctionDescriptor desc) {

125         String funcDescName = javaName + &quot;$FUNC&quot;;
<span class="line-modified">126         if (namesGenerated.add(funcDescName)) {</span>
<span class="line-modified">127             String fieldName = emitFunctionDescField(javaName, desc);</span>
<span class="line-modified">128             return emitGetter(funcDescName, FunctionDescriptor.class, fieldName);</span>
129         } else {
<span class="line-modified">130             return getGetterDesc(funcDescName, FunctionDescriptor.class);</span>



131         }
132     }
133 
134     @Override
135     public DirectMethodHandleDesc addConstant(String name, Class&lt;?&gt; type, Object value) {
<span class="line-modified">136         if (namesGenerated.add(name)) {</span>




137             String str;
138             if (type == MemorySegment.class) {
139                 str = emitConstantSegment(name, value);
140             } else if (type == MemoryAddress.class) {
141                 str = emitConstantAddress(name, value);
142             } else {
143                 str = getConstantString(type, value);
144             }
<span class="line-modified">145             return emitGetter(name, type, str);</span>
<span class="line-modified">146         } else {</span>
<span class="line-modified">147             return getGetterDesc(name, type);</span>
148         }
149     }
150 





151     @Override
152     public List&lt;JavaFileObject&gt; getClasses() {
153         classEnd();
<span class="line-modified">154         String pkgPrefix = pkgName.isEmpty() ? &quot;&quot; : pkgName.replaceAll(&quot;\\.&quot;, &quot;/&quot;) + &quot;/&quot;;</span>
<span class="line-modified">155         return List.of(InMemoryJavaCompiler.jfoFromString(URI.create(pkgPrefix + className + &quot;.java&quot;), sb.toString()));</span>

















156     }
157 
158     // Internals only below this point
<span class="line-modified">159     private void classBegin(String[] libraryNames) {</span>
160         addPackagePrefix(pkgName);
161         addImportSection();
<span class="line-modified">162         append(JavaSourceBuilder.PUB_CLS_MODS);</span>



163         append(&quot;class &quot;);
<span class="line-modified">164         append(className);</span>




165         append(&quot; {\n&quot;);
<span class="line-modified">166         emitLibraries(libraryNames);</span>


167     }
168 
169     private void classEnd() {
170         append(&quot;}\n&quot;);

171     }
172 
173     private DirectMethodHandleDesc getGetterDesc(String name, Class&lt;?&gt; type) {
174         MethodType mt = methodType(type);
175         return MethodHandleDesc.ofMethod(
176                 DirectMethodHandleDesc.Kind.STATIC,
177                 CD_constantsHelper, name, mt.describeConstable().orElseThrow()
178         );
179     }
180 
181     private DirectMethodHandleDesc emitGetter(String name, Class&lt;?&gt; type, String value) {
182         incrAlign();
183         indent();
184         append(JavaSourceBuilder.PUB_MODS);
185         append(type.getName());
186         append(&#39; &#39;);
187         append(name);
188         append(&quot;() { return &quot;);
189         append(value);
190         append(&quot;; }\n\n&quot;);
</pre>
<hr />
<pre>
233         }
234     }
235 
236     private void incrAlign() {
237         align++;
238     }
239     private void decrAlign() {
240         align--;
241     }
242 
243     private String getMethodHandleFieldName(String javaName) {
244         return javaName + &quot;$MH_&quot;;
245     }
246 
247     private String emitMethodHandleField(String javaName, String nativeName, MethodType mtype,
248                                          FunctionDescriptor desc, boolean varargs) {
249         addFunctionDesc(javaName, desc);
250         incrAlign();
251         String fieldName = getMethodHandleFieldName(javaName);
252         indent();
<span class="line-modified">253         append(PRIVATE_MODS + &quot;MethodHandle &quot;);</span>
254         append(fieldName + &quot; = RuntimeHelper.downcallHandle(\n&quot;);
255         incrAlign();
256         indent();
257         append(&quot;LIBRARIES, \&quot;&quot; + nativeName + &quot;\&quot;&quot;);
258         append(&quot;,\n&quot;);
259         indent();
260         append(&quot;\&quot;&quot; + mtype.toMethodDescriptorString() + &quot;\&quot;,\n&quot;);
261         indent();
262         append(getFunctionDescFieldName(javaName));
263         append(&quot;, &quot;);
264         // isVariadic
265         append(varargs);
266         append(&quot;\n&quot;);
267         decrAlign();
268         indent();
269         append(&quot;);\n&quot;);
270         decrAlign();
271         return fieldName;
272     }
273 
274     private String getVarHandleFieldName(String name) {
275         return name + &quot;$VH_&quot;;
276     }
277 
278     private String emitVarHandleField(String javaName, Class&lt;?&gt; type, MemoryLayout layout) {
279         addLayout(javaName, layout);
280         incrAlign();
281         String typeName = type.getName();
282         boolean isAddr = typeName.contains(&quot;MemoryAddress&quot;);
283         if (isAddr) {
284             typeName = &quot;long&quot;;
285         }
286         indent();
287         String fieldName = getVarHandleFieldName(javaName);
<span class="line-modified">288         append(PRIVATE_MODS + &quot;VarHandle &quot; + fieldName + &quot; = &quot;);</span>
289         if (isAddr) {
290             append(&quot;MemoryHandles.asAddressVarHandle(&quot;);
291         }
292         append(getLayoutFieldName(javaName));
293         append(&quot;.varHandle(&quot; + typeName + &quot;.class)&quot;);
294         if (isAddr) {
295             append(&quot;)&quot;);
296         }
297         append(&quot;;\n&quot;);
298         decrAlign();
299         return fieldName;
300     }
301 
302     private String getLayoutFieldName(String javaName) {
303         return javaName + &quot;$LAYOUT_&quot;;
304     }
305 
306     private String emitLayoutField(String javaName, MemoryLayout layout) {
307         String fieldName = getLayoutFieldName(javaName);
308         incrAlign();
309         indent();
<span class="line-modified">310         append(PRIVATE_MODS + &quot;MemoryLayout &quot; + fieldName + &quot; = &quot;);</span>
311         emitLayoutString(layout);
312         append(&quot;;\n&quot;);
313         decrAlign();
314         return fieldName;
315     }
316 
317     private void emitLayoutString(MemoryLayout l) {
318         if (l instanceof ValueLayout) {
319             append(typeToLayoutName((ValueLayout) l));
320         } else if (l instanceof SequenceLayout) {
321             append(&quot;MemoryLayout.ofSequence(&quot;);
322             if (((SequenceLayout) l).elementCount().isPresent()) {
323                 append(((SequenceLayout) l).elementCount().getAsLong() + &quot;, &quot;);
324             }
325             emitLayoutString(((SequenceLayout) l).elementLayout());
326             append(&quot;)&quot;);
327         } else if (l instanceof GroupLayout) {
328             if (l == CSupport.SysV.C_COMPLEX_LONGDOUBLE) {
329                 append(&quot;C_COMPLEX_LONGDOUBLE&quot;);
330             } else {
</pre>
<hr />
<pre>
347                 append(&quot;)&quot;);
348             }
349         } else {
350             // padding
351             append(&quot;MemoryLayout.ofPaddingBits(&quot; + l.bitSize() + &quot;)&quot;);
352         }
353         if (l.name().isPresent()) {
354             append(&quot;.withName(\&quot;&quot; +  l.name().get() + &quot;\&quot;)&quot;);
355         }
356     }
357 
358     private String getFunctionDescFieldName(String javaName) {
359         return javaName + &quot;$FUNC_&quot;;
360     }
361 
362     private String emitFunctionDescField(String javaName, FunctionDescriptor desc) {
363         incrAlign();
364         indent();
365         String fieldName = getFunctionDescFieldName(javaName);
366         final boolean noArgs = desc.argumentLayouts().isEmpty();
<span class="line-modified">367         append(PRIVATE_MODS);</span>
368         append(&quot;FunctionDescriptor &quot;);
369         append(fieldName);
370         append(&quot; = &quot;);
371         if (desc.returnLayout().isPresent()) {
372             append(&quot;FunctionDescriptor.of(&quot;);
373             emitLayoutString(desc.returnLayout().get());
374             if (!noArgs) {
375                 append(&quot;,&quot;);
376             }
377         } else {
378             append(&quot;FunctionDescriptor.ofVoid(&quot;);
379         }
380         if (!noArgs) {
381             append(&quot;\n&quot;);
382             incrAlign();
383             String delim = &quot;&quot;;
384             for (MemoryLayout e : desc.argumentLayouts()) {
385                 append(delim);
386                 indent();
387                 emitLayoutString(e);
388                 delim = &quot;,\n&quot;;
389             }
390             append(&quot;\n&quot;);
391             decrAlign();
392             indent();
393         }
394         append(&quot;);\n&quot;);
395         decrAlign();
396         return fieldName;
397     }
398 
399     private String getConstantSegmentFieldName(String javaName) {
400         return javaName + &quot;$SEGMENT_CONSTANT_&quot;;
401     }
402     private String emitConstantSegment(String javaName, Object value) {
403         incrAlign();
404         indent();
405         String fieldName = getConstantSegmentFieldName(javaName);
<span class="line-modified">406         append(PRIVATE_MODS);</span>
407         append(&quot;MemorySegment &quot;);
408         append(fieldName);
409         append(&quot; = CSupport.toCString(\&quot;&quot;);
410         append(Objects.toString(value));
411         append(&quot;\&quot;);\n&quot;);
412         decrAlign();
413         return fieldName;
414     }
415 
416     private String getConstantAddressFieldName(String javaName) {
417         return javaName + &quot;$ADDR_CONSTANT_&quot;;
418     }
419     private String emitConstantAddress(String javaName, Object value) {
420         incrAlign();
421         indent();
422         String fieldName = getConstantAddressFieldName(javaName);
<span class="line-modified">423         append(PRIVATE_MODS);</span>
424         append(&quot;MemoryAddress &quot;);
425         append(fieldName);
426         append(&quot; = MemoryAddress.ofLong(&quot;);
427         append(((Number)value).longValue());
428         append(&quot;L);\n&quot;);
429         decrAlign();
430         return fieldName;
431     }
432 
433     private String getConstantString(Class&lt;?&gt; type, Object value) {
434         StringBuilder buf = new StringBuilder();
435         if (type == float.class) {
436             float f = ((Number)value).floatValue();
437             if (Float.isFinite(f)) {
438                 buf.append(value);
439                 buf.append(&quot;f&quot;);
440             } else {
441                 buf.append(&quot;Float.valueOf(\&quot;&quot;);
442                 buf.append(value.toString());
443                 buf.append(&quot;\&quot;)&quot;);
</pre>
<hr />
<pre>
488         }
489     }
490 
491     private static boolean matchLayout(ValueLayout a, ValueLayout b) {
492         if (a == b) return true;
493         return (a.bitSize() == b.bitSize() &amp;&amp;
494                 a.order() == b.order() &amp;&amp;
495                 a.bitAlignment() == b.bitAlignment() &amp;&amp;
496                 a.attribute(ABI_CLASS_ATTR).equals(b.attribute(ABI_CLASS_ATTR)));
497     }
498 
499     private String getSegmentFieldName(String javaName) {
500         return javaName + &quot;$SEGMENT_&quot;;
501     }
502 
503     private String emitSegmentField(String javaName, String nativeName, MemoryLayout layout) {
504          addLayout(javaName, layout);
505          incrAlign();
506          indent();
507          String fieldName = getSegmentFieldName(javaName);
<span class="line-modified">508          append(PRIVATE_MODS);</span>
509          append(&quot;MemorySegment &quot;);
510          append(fieldName);
511          append(&quot; = &quot;);
<span class="line-modified">512          append(&quot;RuntimeHelper.lookupGlobalVariable(LIBRARIES, \&quot;&quot;);</span>

513          append(nativeName);
514          append(&quot;\&quot;, &quot;);
515          append(getLayoutFieldName(javaName));
516          append(&quot;);\n&quot;);
517          decrAlign();
518          return fieldName;
519     }
520 
521     private void emitLibraries(String[] libraryNames) {
522         incrAlign();
523         indent();
<span class="line-modified">524         append(PRIVATE_MODS);</span>
525         append(&quot;LibraryLookup[] LIBRARIES = RuntimeHelper.libraries(new String[] {\n&quot;);
526         incrAlign();
527         for (String lib : libraryNames) {
528             indent();
529             append(&#39;\&quot;&#39;);
530             append(lib);
531             append(&quot;\&quot;,\n&quot;);
532         }
533         decrAlign();
534         indent();
535         append(&quot;});\n\n&quot;);
536         decrAlign();
537     }
538 }
</pre>
</td>
<td>
<hr />
<pre>
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.jextract.impl;
 27 
<span class="line-modified"> 28 import jdk.incubator.foreign.CSupport;</span>
<span class="line-modified"> 29 import jdk.incubator.foreign.FunctionDescriptor;</span>
<span class="line-added"> 30 import jdk.incubator.foreign.GroupLayout;</span>
<span class="line-added"> 31 import jdk.incubator.foreign.MemoryAddress;</span>
<span class="line-added"> 32 import jdk.incubator.foreign.MemoryLayout;</span>
<span class="line-added"> 33 import jdk.incubator.foreign.MemorySegment;</span>
<span class="line-added"> 34 import jdk.incubator.foreign.ValueLayout;</span>
<span class="line-added"> 35 import jdk.incubator.foreign.SequenceLayout;</span>
 36 import javax.tools.JavaFileObject;
 37 import java.lang.constant.ClassDesc;
 38 import java.lang.constant.DirectMethodHandleDesc;
 39 import java.lang.constant.MethodHandleDesc;
 40 import java.lang.invoke.MethodHandle;
 41 import java.lang.invoke.MethodType;
 42 import java.lang.invoke.VarHandle;
 43 import java.net.URI;
<span class="line-modified"> 44 import java.util.ArrayList;</span>
<span class="line-added"> 45 import java.util.HashMap;</span>
 46 import java.util.List;
<span class="line-added"> 47 import java.util.Map;</span>
 48 import java.util.Objects;

 49 
 50 import static java.lang.invoke.MethodType.methodType;
 51 
 52 // generates ConstantHelper as java source
 53 class SourceConstantHelper implements ConstantHelper {
<span class="line-modified"> 54     private static final String PACKAGE_FINAL_MODS = &quot;static final &quot;;</span>
<span class="line-added"> 55     private static final String PRIVATE_FINAL_MODS = &quot;private static final &quot;;</span>
 56     private static final String ABI_CLASS_ATTR;
<span class="line-added"> 57     private static final int CONSTANTS_PER_CLASS = Integer.getInteger(&quot;jextract.constants.per.class&quot;, 1000);</span>
 58 
 59     static {
 60         String abi = CSupport.getSystemLinker().name();
 61         ABI_CLASS_ATTR = switch (abi) {
 62             case CSupport.SysV.NAME -&gt; CSupport.SysV.CLASS_ATTRIBUTE_NAME;
 63             case CSupport.Win64.NAME -&gt; CSupport.Win64.CLASS_ATTRIBUTE_NAME;
 64             case CSupport.AArch64.NAME -&gt; CSupport.AArch64.CLASS_ATTRIBUTE_NAME;
 65             default -&gt; throw new UnsupportedOperationException(&quot;Unsupported Foreign Linker: &quot; + abi);
 66         };
 67     }
 68 
 69     // set of names generates already
<span class="line-modified"> 70     private static final Map&lt;String, DirectMethodHandleDesc&gt; namesGenerated = new HashMap&lt;&gt;();</span>
 71     // code buffer
<span class="line-modified"> 72     private StringBuilder sb = new StringBuilder();</span>
 73     // current line alignment (number of 4-spaces)
 74     private int align;
 75     private final String pkgName;
<span class="line-modified"> 76     private final String headerClassName;</span>
<span class="line-modified"> 77     private int constantCount;</span>
<span class="line-added"> 78     private int constantClassCount;</span>
<span class="line-added"> 79     private String constantClassName;</span>
<span class="line-added"> 80     private ClassDesc CD_constantsHelper;</span>
<span class="line-added"> 81     private final List&lt;String&gt; classes = new ArrayList&lt;&gt;();</span>
 82 
 83     SourceConstantHelper(String parentClassName, String[] libraryNames) {
 84         int idx = parentClassName.lastIndexOf(&#39;.&#39;);
 85         this.pkgName = idx == -1? &quot;&quot; : parentClassName.substring(0, idx);
<span class="line-modified"> 86         this.headerClassName =  parentClassName.substring(idx + 1);</span>
<span class="line-modified"> 87         this.constantClassName = getConstantClassName(headerClassName, constantClassCount);</span>
<span class="line-modified"> 88         this.CD_constantsHelper = ClassDesc.of(pkgName.isEmpty() ? constantClassName : (pkgName + &quot;.&quot; + constantClassName));</span>
<span class="line-modified"> 89         classBegin(libraryNames, null, false);</span>
<span class="line-added"> 90     }</span>
<span class="line-added"> 91 </span>
<span class="line-added"> 92     private static String getConstantClassName(String className, int count) {</span>
<span class="line-added"> 93         return className + &quot;$constants$&quot; + count;</span>
<span class="line-added"> 94     }</span>
<span class="line-added"> 95 </span>
<span class="line-added"> 96     private void newConstantClass() {</span>
<span class="line-added"> 97         if (constantCount &gt; CONSTANTS_PER_CLASS) {</span>
<span class="line-added"> 98             classEnd();</span>
<span class="line-added"> 99             constantClassCount++;</span>
<span class="line-added">100             String baseClassName = constantClassName;</span>
<span class="line-added">101             this.constantClassName = getConstantClassName(headerClassName, constantClassCount);</span>
<span class="line-added">102             this.CD_constantsHelper = ClassDesc.of(pkgName.isEmpty() ? constantClassName : (pkgName + &quot;.&quot; + constantClassName));</span>
<span class="line-added">103             this.constantCount = 0;</span>
<span class="line-added">104             this.sb = new StringBuilder();</span>
<span class="line-added">105             classBegin(null, baseClassName, false);</span>
<span class="line-added">106         }</span>
<span class="line-added">107         constantCount++;</span>
108     }
109 
110     @Override
111     public DirectMethodHandleDesc addLayout(String javaName, MemoryLayout layout) {
<span class="line-added">112         newConstantClass();</span>
113         String layoutName = javaName + &quot;$LAYOUT&quot;;
<span class="line-modified">114         if (namesGenerated.containsKey(layoutName)) {</span>
<span class="line-modified">115             return namesGenerated.get(layoutName);</span>

116         } else {
<span class="line-modified">117             String fieldName = emitLayoutField(javaName, layout);</span>
<span class="line-added">118             DirectMethodHandleDesc getter = emitGetter(layoutName, MemoryLayout.class, fieldName);</span>
<span class="line-added">119             namesGenerated.put(layoutName, getter);</span>
<span class="line-added">120             return getter;</span>
121         }
122     }
123 
124     @Override
125     public DirectMethodHandleDesc addVarHandle(String javaName, String nativeName, MemoryLayout layout, Class&lt;?&gt; type, MemoryLayout parentLayout) {
<span class="line-added">126         newConstantClass();</span>
127         String varHandleName = javaName + &quot;$VH&quot;;
<span class="line-modified">128 </span>
<span class="line-modified">129         if (namesGenerated.containsKey(varHandleName)) {</span>
<span class="line-modified">130             return namesGenerated.get(varHandleName);</span>
131         } else {
<span class="line-modified">132             String fieldName = emitVarHandleField(javaName, type, layout);</span>
<span class="line-added">133             DirectMethodHandleDesc getter = emitGetter(varHandleName, VarHandle.class, fieldName);</span>
<span class="line-added">134             namesGenerated.put(varHandleName, getter);</span>
<span class="line-added">135             return getter;</span>
136         }
137     }
138 
139     @Override
140     public DirectMethodHandleDesc addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {
<span class="line-added">141         newConstantClass();</span>
142         String mhName = javaName + &quot;$MH&quot;;
<span class="line-modified">143         if (namesGenerated.containsKey(mhName)) {</span>
<span class="line-modified">144             return namesGenerated.get(mhName);</span>

145         } else {
<span class="line-modified">146             String fieldName = emitMethodHandleField(javaName, nativeName, mtype, desc, varargs);</span>
<span class="line-added">147             DirectMethodHandleDesc getter = emitGetter(mhName, MethodHandle.class, fieldName);</span>
<span class="line-added">148             namesGenerated.put(mhName, getter);</span>
<span class="line-added">149             return getter;</span>
150         }
151     }
152 
153     @Override
154     public DirectMethodHandleDesc addSegment(String javaName, String nativeName, MemoryLayout layout) {
<span class="line-added">155         newConstantClass();</span>
156         String segmentName = javaName + &quot;$SEGMENT&quot;;
<span class="line-modified">157         if (namesGenerated.containsKey(segmentName)) {</span>
<span class="line-modified">158             return namesGenerated.get(segmentName);</span>

159         } else {
<span class="line-modified">160             String fieldName = emitSegmentField(javaName, nativeName, layout);</span>
<span class="line-added">161             DirectMethodHandleDesc getter = emitGetter(segmentName, MemorySegment.class, fieldName);</span>
<span class="line-added">162             namesGenerated.put(segmentName, getter);</span>
<span class="line-added">163             return getter;</span>
164         }
165     }
166 
167     @Override
168     public DirectMethodHandleDesc addFunctionDesc(String javaName, FunctionDescriptor desc) {
<span class="line-added">169         newConstantClass();</span>
170         String funcDescName = javaName + &quot;$FUNC&quot;;
<span class="line-modified">171 </span>
<span class="line-modified">172         if (namesGenerated.containsKey(funcDescName)) {</span>
<span class="line-modified">173             return namesGenerated.get(funcDescName);</span>
174         } else {
<span class="line-modified">175             String fieldName = emitFunctionDescField(javaName, desc);</span>
<span class="line-added">176             DirectMethodHandleDesc getter = emitGetter(funcDescName, FunctionDescriptor.class, fieldName);</span>
<span class="line-added">177             namesGenerated.put(funcDescName, getter);</span>
<span class="line-added">178             return getter;</span>
179         }
180     }
181 
182     @Override
183     public DirectMethodHandleDesc addConstant(String name, Class&lt;?&gt; type, Object value) {
<span class="line-modified">184         newConstantClass();</span>
<span class="line-added">185 </span>
<span class="line-added">186         if (namesGenerated.containsKey(name)) {</span>
<span class="line-added">187             return namesGenerated.get(name);</span>
<span class="line-added">188         } else {</span>
189             String str;
190             if (type == MemorySegment.class) {
191                 str = emitConstantSegment(name, value);
192             } else if (type == MemoryAddress.class) {
193                 str = emitConstantAddress(name, value);
194             } else {
195                 str = getConstantString(type, value);
196             }
<span class="line-modified">197             DirectMethodHandleDesc getter = emitGetter(name, type, str);</span>
<span class="line-modified">198             namesGenerated.put(name, getter);</span>
<span class="line-modified">199             return getter;</span>
200         }
201     }
202 
<span class="line-added">203     private JavaFileObject newJavaFileObject(String className, String src) {</span>
<span class="line-added">204         String pkgPrefix = pkgName.isEmpty() ? &quot;&quot; : pkgName.replaceAll(&quot;\\.&quot;, &quot;/&quot;) + &quot;/&quot;;</span>
<span class="line-added">205         return InMemoryJavaCompiler.jfoFromString(URI.create(pkgPrefix + className + &quot;.java&quot;), src);</span>
<span class="line-added">206     }</span>
<span class="line-added">207 </span>
208     @Override
209     public List&lt;JavaFileObject&gt; getClasses() {
210         classEnd();
<span class="line-modified">211 </span>
<span class="line-modified">212         List&lt;JavaFileObject&gt; javaFileObjects = new ArrayList&lt;&gt;();</span>
<span class="line-added">213         int count = 0;</span>
<span class="line-added">214         for (String src : classes) {</span>
<span class="line-added">215             String name = getConstantClassName(headerClassName, count);</span>
<span class="line-added">216             javaFileObjects.add(newJavaFileObject(name, src));</span>
<span class="line-added">217             count++;</span>
<span class="line-added">218         }</span>
<span class="line-added">219 </span>
<span class="line-added">220         // generate overall header$constants subclass that inherits from</span>
<span class="line-added">221         // the individual &quot;split&quot; header$constants$N classes.</span>
<span class="line-added">222         this.sb = new StringBuilder();</span>
<span class="line-added">223         String baseClassName = constantClassName;</span>
<span class="line-added">224         this.constantClassName = headerClassName + &quot;$constants&quot;;</span>
<span class="line-added">225         classBegin(null, baseClassName, true);</span>
<span class="line-added">226         classEnd();</span>
<span class="line-added">227         javaFileObjects.add(newJavaFileObject(constantClassName, sb.toString()));</span>
<span class="line-added">228 </span>
<span class="line-added">229         return javaFileObjects;</span>
230     }
231 
232     // Internals only below this point
<span class="line-modified">233     private void classBegin(String[] libraryNames, String baseClassName, boolean leafClass) {</span>
234         addPackagePrefix(pkgName);
235         addImportSection();
<span class="line-modified">236         append(&quot;public &quot;);</span>
<span class="line-added">237         if (leafClass) {</span>
<span class="line-added">238             append(&quot;final &quot;);</span>
<span class="line-added">239         }</span>
240         append(&quot;class &quot;);
<span class="line-modified">241         append(constantClassName);</span>
<span class="line-added">242         if (baseClassName != null) {</span>
<span class="line-added">243             append(&quot; extends &quot;);</span>
<span class="line-added">244             append(baseClassName);</span>
<span class="line-added">245         }</span>
246         append(&quot; {\n&quot;);
<span class="line-modified">247         if (libraryNames != null) {</span>
<span class="line-added">248             emitLibraries(libraryNames);</span>
<span class="line-added">249         }</span>
250     }
251 
252     private void classEnd() {
253         append(&quot;}\n&quot;);
<span class="line-added">254         classes.add(sb.toString());</span>
255     }
256 
257     private DirectMethodHandleDesc getGetterDesc(String name, Class&lt;?&gt; type) {
258         MethodType mt = methodType(type);
259         return MethodHandleDesc.ofMethod(
260                 DirectMethodHandleDesc.Kind.STATIC,
261                 CD_constantsHelper, name, mt.describeConstable().orElseThrow()
262         );
263     }
264 
265     private DirectMethodHandleDesc emitGetter(String name, Class&lt;?&gt; type, String value) {
266         incrAlign();
267         indent();
268         append(JavaSourceBuilder.PUB_MODS);
269         append(type.getName());
270         append(&#39; &#39;);
271         append(name);
272         append(&quot;() { return &quot;);
273         append(value);
274         append(&quot;; }\n\n&quot;);
</pre>
<hr />
<pre>
317         }
318     }
319 
320     private void incrAlign() {
321         align++;
322     }
323     private void decrAlign() {
324         align--;
325     }
326 
327     private String getMethodHandleFieldName(String javaName) {
328         return javaName + &quot;$MH_&quot;;
329     }
330 
331     private String emitMethodHandleField(String javaName, String nativeName, MethodType mtype,
332                                          FunctionDescriptor desc, boolean varargs) {
333         addFunctionDesc(javaName, desc);
334         incrAlign();
335         String fieldName = getMethodHandleFieldName(javaName);
336         indent();
<span class="line-modified">337         append(PRIVATE_FINAL_MODS + &quot;MethodHandle &quot;);</span>
338         append(fieldName + &quot; = RuntimeHelper.downcallHandle(\n&quot;);
339         incrAlign();
340         indent();
341         append(&quot;LIBRARIES, \&quot;&quot; + nativeName + &quot;\&quot;&quot;);
342         append(&quot;,\n&quot;);
343         indent();
344         append(&quot;\&quot;&quot; + mtype.toMethodDescriptorString() + &quot;\&quot;,\n&quot;);
345         indent();
346         append(getFunctionDescFieldName(javaName));
347         append(&quot;, &quot;);
348         // isVariadic
349         append(varargs);
350         append(&quot;\n&quot;);
351         decrAlign();
352         indent();
353         append(&quot;);\n&quot;);
354         decrAlign();
355         return fieldName;
356     }
357 
358     private String getVarHandleFieldName(String name) {
359         return name + &quot;$VH_&quot;;
360     }
361 
362     private String emitVarHandleField(String javaName, Class&lt;?&gt; type, MemoryLayout layout) {
363         addLayout(javaName, layout);
364         incrAlign();
365         String typeName = type.getName();
366         boolean isAddr = typeName.contains(&quot;MemoryAddress&quot;);
367         if (isAddr) {
368             typeName = &quot;long&quot;;
369         }
370         indent();
371         String fieldName = getVarHandleFieldName(javaName);
<span class="line-modified">372         append(PRIVATE_FINAL_MODS + &quot;VarHandle &quot; + fieldName + &quot; = &quot;);</span>
373         if (isAddr) {
374             append(&quot;MemoryHandles.asAddressVarHandle(&quot;);
375         }
376         append(getLayoutFieldName(javaName));
377         append(&quot;.varHandle(&quot; + typeName + &quot;.class)&quot;);
378         if (isAddr) {
379             append(&quot;)&quot;);
380         }
381         append(&quot;;\n&quot;);
382         decrAlign();
383         return fieldName;
384     }
385 
386     private String getLayoutFieldName(String javaName) {
387         return javaName + &quot;$LAYOUT_&quot;;
388     }
389 
390     private String emitLayoutField(String javaName, MemoryLayout layout) {
391         String fieldName = getLayoutFieldName(javaName);
392         incrAlign();
393         indent();
<span class="line-modified">394         append(PRIVATE_FINAL_MODS + &quot;MemoryLayout &quot; + fieldName + &quot; = &quot;);</span>
395         emitLayoutString(layout);
396         append(&quot;;\n&quot;);
397         decrAlign();
398         return fieldName;
399     }
400 
401     private void emitLayoutString(MemoryLayout l) {
402         if (l instanceof ValueLayout) {
403             append(typeToLayoutName((ValueLayout) l));
404         } else if (l instanceof SequenceLayout) {
405             append(&quot;MemoryLayout.ofSequence(&quot;);
406             if (((SequenceLayout) l).elementCount().isPresent()) {
407                 append(((SequenceLayout) l).elementCount().getAsLong() + &quot;, &quot;);
408             }
409             emitLayoutString(((SequenceLayout) l).elementLayout());
410             append(&quot;)&quot;);
411         } else if (l instanceof GroupLayout) {
412             if (l == CSupport.SysV.C_COMPLEX_LONGDOUBLE) {
413                 append(&quot;C_COMPLEX_LONGDOUBLE&quot;);
414             } else {
</pre>
<hr />
<pre>
431                 append(&quot;)&quot;);
432             }
433         } else {
434             // padding
435             append(&quot;MemoryLayout.ofPaddingBits(&quot; + l.bitSize() + &quot;)&quot;);
436         }
437         if (l.name().isPresent()) {
438             append(&quot;.withName(\&quot;&quot; +  l.name().get() + &quot;\&quot;)&quot;);
439         }
440     }
441 
442     private String getFunctionDescFieldName(String javaName) {
443         return javaName + &quot;$FUNC_&quot;;
444     }
445 
446     private String emitFunctionDescField(String javaName, FunctionDescriptor desc) {
447         incrAlign();
448         indent();
449         String fieldName = getFunctionDescFieldName(javaName);
450         final boolean noArgs = desc.argumentLayouts().isEmpty();
<span class="line-modified">451         append(PRIVATE_FINAL_MODS);</span>
452         append(&quot;FunctionDescriptor &quot;);
453         append(fieldName);
454         append(&quot; = &quot;);
455         if (desc.returnLayout().isPresent()) {
456             append(&quot;FunctionDescriptor.of(&quot;);
457             emitLayoutString(desc.returnLayout().get());
458             if (!noArgs) {
459                 append(&quot;,&quot;);
460             }
461         } else {
462             append(&quot;FunctionDescriptor.ofVoid(&quot;);
463         }
464         if (!noArgs) {
465             append(&quot;\n&quot;);
466             incrAlign();
467             String delim = &quot;&quot;;
468             for (MemoryLayout e : desc.argumentLayouts()) {
469                 append(delim);
470                 indent();
471                 emitLayoutString(e);
472                 delim = &quot;,\n&quot;;
473             }
474             append(&quot;\n&quot;);
475             decrAlign();
476             indent();
477         }
478         append(&quot;);\n&quot;);
479         decrAlign();
480         return fieldName;
481     }
482 
483     private String getConstantSegmentFieldName(String javaName) {
484         return javaName + &quot;$SEGMENT_CONSTANT_&quot;;
485     }
486     private String emitConstantSegment(String javaName, Object value) {
487         incrAlign();
488         indent();
489         String fieldName = getConstantSegmentFieldName(javaName);
<span class="line-modified">490         append(PRIVATE_FINAL_MODS);</span>
491         append(&quot;MemorySegment &quot;);
492         append(fieldName);
493         append(&quot; = CSupport.toCString(\&quot;&quot;);
494         append(Objects.toString(value));
495         append(&quot;\&quot;);\n&quot;);
496         decrAlign();
497         return fieldName;
498     }
499 
500     private String getConstantAddressFieldName(String javaName) {
501         return javaName + &quot;$ADDR_CONSTANT_&quot;;
502     }
503     private String emitConstantAddress(String javaName, Object value) {
504         incrAlign();
505         indent();
506         String fieldName = getConstantAddressFieldName(javaName);
<span class="line-modified">507         append(PRIVATE_FINAL_MODS);</span>
508         append(&quot;MemoryAddress &quot;);
509         append(fieldName);
510         append(&quot; = MemoryAddress.ofLong(&quot;);
511         append(((Number)value).longValue());
512         append(&quot;L);\n&quot;);
513         decrAlign();
514         return fieldName;
515     }
516 
517     private String getConstantString(Class&lt;?&gt; type, Object value) {
518         StringBuilder buf = new StringBuilder();
519         if (type == float.class) {
520             float f = ((Number)value).floatValue();
521             if (Float.isFinite(f)) {
522                 buf.append(value);
523                 buf.append(&quot;f&quot;);
524             } else {
525                 buf.append(&quot;Float.valueOf(\&quot;&quot;);
526                 buf.append(value.toString());
527                 buf.append(&quot;\&quot;)&quot;);
</pre>
<hr />
<pre>
572         }
573     }
574 
575     private static boolean matchLayout(ValueLayout a, ValueLayout b) {
576         if (a == b) return true;
577         return (a.bitSize() == b.bitSize() &amp;&amp;
578                 a.order() == b.order() &amp;&amp;
579                 a.bitAlignment() == b.bitAlignment() &amp;&amp;
580                 a.attribute(ABI_CLASS_ATTR).equals(b.attribute(ABI_CLASS_ATTR)));
581     }
582 
583     private String getSegmentFieldName(String javaName) {
584         return javaName + &quot;$SEGMENT_&quot;;
585     }
586 
587     private String emitSegmentField(String javaName, String nativeName, MemoryLayout layout) {
588          addLayout(javaName, layout);
589          incrAlign();
590          indent();
591          String fieldName = getSegmentFieldName(javaName);
<span class="line-modified">592          append(PRIVATE_FINAL_MODS);</span>
593          append(&quot;MemorySegment &quot;);
594          append(fieldName);
595          append(&quot; = &quot;);
<span class="line-modified">596          append(&quot;RuntimeHelper.lookupGlobalVariable(&quot;);</span>
<span class="line-added">597          append(&quot;LIBRARIES, \&quot;&quot;);</span>
598          append(nativeName);
599          append(&quot;\&quot;, &quot;);
600          append(getLayoutFieldName(javaName));
601          append(&quot;);\n&quot;);
602          decrAlign();
603          return fieldName;
604     }
605 
606     private void emitLibraries(String[] libraryNames) {
607         incrAlign();
608         indent();
<span class="line-modified">609         append(PACKAGE_FINAL_MODS);</span>
610         append(&quot;LibraryLookup[] LIBRARIES = RuntimeHelper.libraries(new String[] {\n&quot;);
611         incrAlign();
612         for (String lib : libraryNames) {
613             indent();
614             append(&#39;\&quot;&#39;);
615             append(lib);
616             append(&quot;\&quot;,\n&quot;);
617         }
618         decrAlign();
619         indent();
620         append(&quot;});\n\n&quot;);
621         decrAlign();
622     }
623 }
</pre>
</td>
</tr>
</table>
<center><a href="OutputFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>