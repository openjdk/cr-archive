diff a/make/modules/jdk.incubator.jextract/Launcher.gmk b/make/modules/jdk.incubator.jextract/Launcher.gmk
--- a/make/modules/jdk.incubator.jextract/Launcher.gmk
+++ b/make/modules/jdk.incubator.jextract/Launcher.gmk
@@ -26,7 +26,7 @@
 include LauncherCommon.gmk
 
 $(eval $(call SetupBuildLauncher, jextract,\
     CFLAGS := -DENABLE_ARG_FILES, \
     JAVA_ARGS := -Dforeign.restricted=permit, \
-    MAIN_CLASS := jdk.incubator.jextract.tool.Main, \
+    MAIN_CLASS := jdk.incubator.jextract.JextractTool, \
 ))
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Filter.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Filter.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Filter.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package jdk.incubator.jextract;
-
-import jdk.incubator.jextract.Declaration;
-import jdk.incubator.jextract.Position;
-
-public class Filter {
-    private Filter() {}
-
-    public static Declaration.Scoped filter(Declaration.Scoped decl, String... validNames) {
-        Declaration[] newMembers = decl.members().stream()
-                .filter(d -> filterDecl(d, validNames))
-                .toArray(Declaration[]::new);
-        return Declaration.toplevel(decl.pos(), newMembers);
-    }
-
-    private static boolean filterDecl(Declaration d, String... validNames) {
-        if (d.pos() == Position.NO_POSITION) {
-            return false;
-        } else {
-            for (String s : validNames) {
-                String pathName = d.pos().path().toString();
-                if (pathName.contains(s)) {
-                    return true;
-                }
-            }
-            return false;
-        }
-    }
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/FunctionalInterfaceScanner.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/FunctionalInterfaceScanner.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/FunctionalInterfaceScanner.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package jdk.incubator.jextract;
-
-import jdk.incubator.jextract.Declaration;
-import jdk.incubator.jextract.Type;
-import jdk.incubator.foreign.FunctionDescriptor;
-
-import java.util.Optional;
-import java.util.Set;
-
-public class FunctionalInterfaceScanner implements Declaration.Visitor<Void, Set<FunctionDescriptor>> {
-    
-    private final Set<FunctionDescriptor> descriptors;
-
-    public FunctionalInterfaceScanner(Set<FunctionDescriptor> descriptors) {
-        this.descriptors = descriptors;
-    }
-
-    public Declaration.Scoped scan(Declaration.Scoped decl) {
-        decl.accept(this, descriptors);
-        return decl;
-    }
-
-    void scanType(Type t, Set<FunctionDescriptor> functionDescriptors) {
-        t.accept(new TypeScanner(), functionDescriptors);
-    }
-
-    @Override
-    public Void visitScoped(Declaration.Scoped d, Set<FunctionDescriptor> functionDescriptors) {
-        d.members().forEach(m -> m.accept(this, functionDescriptors));
-        return null;
-    }
-
-    @Override
-    public Void visitFunction(Declaration.Function d, Set<FunctionDescriptor> functionDescriptors) {
-        scanType(d.type().returnType(), functionDescriptors);
-        d.parameters().forEach(p -> p.accept(this, functionDescriptors));
-        return null;
-    }
-
-    @Override
-    public Void visitVariable(Declaration.Variable d, Set<FunctionDescriptor> functionDescriptors) {
-        scanType(d.type(), functionDescriptors);
-        return null;
-    }
-
-    @Override
-    public Void visitConstant(Declaration.Constant d, Set<FunctionDescriptor> functionDescriptors) {
-        scanType(d.type(), functionDescriptors);
-        return null;
-    }
-
-    static class TypeScanner implements Type.Visitor<Void, Set<FunctionDescriptor>> {
-
-        @Override
-        public Void visitPrimitive(Type.Primitive t, Set<FunctionDescriptor> functionDescriptors) {
-            return null;
-        }
-
-        @Override
-        public Void visitDelegated(Type.Delegated t, Set<FunctionDescriptor> functionDescriptors) {
-            return t.type().accept(this, functionDescriptors);
-        }
-
-        @Override
-        public Void visitFunction(Type.Function t, Set<FunctionDescriptor> functionDescriptors) {
-            t.returnType().accept(this, functionDescriptors);
-            t.argumentTypes().forEach(a -> a.accept(this, functionDescriptors));
-            Optional<FunctionDescriptor> descriptor = Type.descriptorFor(t);
-            if (descriptor.isPresent()) {
-                functionDescriptors.add(descriptor.get());
-            }
-            return null;
-        }
-
-        @Override
-        public Void visitDeclared(Type.Declared t, Set<FunctionDescriptor> functionDescriptors) {
-            return null;
-        }
-
-        @Override
-        public Void visitArray(Type.Array t, Set<FunctionDescriptor> functionDescriptors) {
-            return t.elementType().accept(this, functionDescriptors);
-        }
-
-        @Override
-        public Void visitType(Type t, Set<FunctionDescriptor> functionDescriptors) {
-            throw new UnsupportedOperationException();
-        }
-    }
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/HeaderBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/HeaderBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/HeaderBuilder.java
+++ /dev/null
@@ -1,186 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.incubator.jextract;
-
-import jdk.incubator.foreign.Addressable;
-import jdk.incubator.foreign.FunctionDescriptor;
-import jdk.incubator.foreign.MemoryAddress;
-
-import java.lang.invoke.MethodType;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * A helper class to generate header interface class in source form.
- * After aggregating various constituents of a .java source, build
- * method is called to get overall generated source string.
- */
-public class HeaderBuilder extends JavaSourceBuilder {
-    public HeaderBuilder(String className, String pkgName, ConstantHelper constantHelper) {
-        super(className, pkgName, constantHelper);
-    }
-
-    public void addFunctionalInterface(String name, MethodType mtype,  FunctionDescriptor fDesc) {
-        incrAlign();
-        indent();
-        sb.append("public interface " + name + " {\n");
-        incrAlign();
-        indent();
-        sb.append(mtype.returnType().getName() + " apply(");
-        String delim = "";
-        for (int i = 0 ; i < mtype.parameterCount(); i++) {
-            sb.append(delim + mtype.parameterType(i).getName() + " x" + i);
-            delim = ", ";
-        }
-        sb.append(");\n");
-        addFunctionalFactory(name, mtype, fDesc);
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-        indent();
-    }
-
-    public void addStaticFunctionWrapper(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS + mtype.returnType().getName() + " " + javaName + " (");
-        String delim = "";
-        List<String> pExprs = new ArrayList<>();
-        final int numParams = paramNames.size();
-        for (int i = 0 ; i < numParams; i++) {
-            String pName = paramNames.get(i);
-            if (pName.isEmpty()) {
-                pName = "x" + i;
-            }
-            if (mtype.parameterType(i).equals(MemoryAddress.class)) {
-                pExprs.add(pName + ".address()");
-            } else {
-                pExprs.add(pName);
-            }
-            Class<?> pType = mtype.parameterType(i);
-            if (pType.equals(MemoryAddress.class)) {
-                pType = Addressable.class;
-            }
-            sb.append(delim + pType.getName() + " " + pName);
-            delim = ", ";
-        }
-        if (varargs) {
-            String lastArg = "x" + numParams;
-            if (numParams > 0) {
-                sb.append(", ");
-            }
-            sb.append("Object... " + lastArg);
-            pExprs.add(lastArg);
-        }
-        sb.append(") {\n");
-        incrAlign();
-        indent();
-        sb.append("try {\n");
-        incrAlign();
-        indent();
-        if (!mtype.returnType().equals(void.class)) {
-            sb.append("return (" + mtype.returnType().getName() + ")");
-        }
-        sb.append(methodHandleGetCallString(javaName, nativeName, mtype, desc, varargs) + ".invokeExact(" + String.join(", ", pExprs) + ");\n");
-        decrAlign();
-        indent();
-        sb.append("} catch (Throwable ex) {\n");
-        incrAlign();
-        indent();
-        sb.append("throw new AssertionError(ex);\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-    }
-
-    public void emitPrimitiveTypedef(Type.Primitive primType, String name) {
-        Type.Primitive.Kind kind = primType.kind();
-        if (primitiveKindSupported(kind) && !kind.layout().isEmpty()) {
-            incrAlign();
-            indent();
-            sb.append(PUB_MODS);
-            sb.append("ValueLayout ");
-            sb.append(name);
-            sb.append(" = ");
-            sb.append(TypeTranslator.typeToLayoutName(kind));
-            sb.append(";\n");
-            decrAlign();
-        }
-    }
-
-    private boolean primitiveKindSupported(Type.Primitive.Kind kind) {
-        return switch(kind) {
-            case Short, Int, Long, LongLong, Float, Double, LongDouble, Char -> true;
-            default -> false;
-        };
-    }
-
-    public void emitTypedef(String className, String superClassName) {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS);
-        sb.append("class ");
-        sb.append(className);
-        sb.append(" extends ");
-        sb.append(superClassName);
-        sb.append(" {\n");
-        incrAlign();
-        indent();
-        // private constructor
-        sb.append("private ");
-        sb.append(className);
-        sb.append("() {}\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-    }
-
-    private void addFunctionalFactory(String className, MethodType mtype, FunctionDescriptor fDesc) {
-        indent();
-        sb.append(PUB_MODS + "MemorySegment allocate(" + className + " fi) {\n");
-        incrAlign();
-        indent();
-        sb.append("return RuntimeHelper.upcallStub(" + className + ".class, fi, " + functionGetCallString(className, fDesc) + ", " +
-                "\"" + mtype.toMethodDescriptorString() + "\");\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-
-        indent();
-        sb.append(PUB_MODS + "MemorySegment allocate(" + className + " fi, NativeScope scope) {\n");
-        incrAlign();
-        indent();
-        sb.append("return scope.register(allocate(fi));\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-    }
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/JavaSourceBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/JavaSourceBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/JavaSourceBuilder.java
+++ /dev/null
@@ -1,227 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.incubator.jextract;
-
-import jdk.incubator.foreign.FunctionDescriptor;
-import jdk.incubator.foreign.MemoryLayout;
-
-import javax.tools.JavaFileObject;
-import java.lang.constant.ClassDesc;
-import java.lang.constant.DirectMethodHandleDesc;
-import java.lang.invoke.MethodType;
-
-/**
- * Superclass for .java source generator classes.
- */
-abstract class JavaSourceBuilder {
-    static final String PUB_CLS_MODS = "public final ";
-    static final String PUB_MODS = "public static ";
-    protected final String className;
-    protected final String pkgName;
-    protected final ConstantHelper constantHelper;
-    // buffer
-    protected final StringBuffer sb;
-    // current line alignment (number of 4-spaces)
-    private int align;
-
-    JavaSourceBuilder(String className, String pkgName, ConstantHelper constantHelper, int align) {
-        this.className = className;
-        this.pkgName = pkgName;
-        this.constantHelper = constantHelper;
-        this.align = align;
-        this.sb = new StringBuffer();
-    }
-
-    JavaSourceBuilder(String className, String pkgName, ConstantHelper constantHelper) {
-        this(className, pkgName, constantHelper, 0);
-    }
-
-    protected String getClassModifiers() {
-        return PUB_CLS_MODS;
-    }
-
-    public void classBegin() {
-        addPackagePrefix();
-        addImportSection();
-
-        indent();
-        sb.append(getClassModifiers());
-        sb.append("class ");
-        sb.append(className);
-        sb.append(" {\n\n");
-        emitConstructor();
-    }
-
-    public void emitConstructor() {
-        incrAlign();
-        indent();
-        sb.append("private ");
-        sb.append(className);
-        sb.append("() {}");
-        sb.append('\n');
-        decrAlign();
-    }
-
-    public void classEnd() {
-        indent();
-        sb.append("}\n\n");
-    }
-
-    public String getSource() {
-        return sb.toString();
-    }
-
-    public void addContent(String src) {
-        sb.append(src);
-    }
-
-    public JavaFileObject build() {
-        String res = sb.toString();
-        this.sb.delete(0, res.length());
-        return Utils.fileFromString(pkgName, className, res);
-    }
-
-    public void addLayoutGetter(String javaName, MemoryLayout layout) {
-        emitForwardGetter(constantHelper.addLayout(javaName, layout));
-    }
-
-    public void addVarHandleGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
-        emitForwardGetter(constantHelper.addVarHandle(javaName, nativeName, layout, type, parentLayout));
-    }
-
-    public void addMethodHandleGetter(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {
-        emitForwardGetter(constantHelper.addMethodHandle(javaName, nativeName, mtype, desc, varargs));
-    }
-
-    public void addAddressGetter(String javaName, String nativeName, MemoryLayout layout, MemoryLayout parentLayout) {
-        emitForwardGetter(constantHelper.addAddress(javaName, nativeName, layout));
-    }
-
-    public void addConstantGetter(String javaName, Class<?> type, Object value) {
-        emitForwardGetter(constantHelper.addConstant(javaName, type, value));
-    }
-
-    public void addGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS + type.getName() + " " + javaName + "$get() {\n");
-        incrAlign();
-        indent();
-        String vhParam = addressGetCallString(javaName, nativeName, layout);
-        sb.append("return (" + type.getName() + ")"
-                + varHandleGetCallString(javaName, nativeName, layout, type, null) + ".get(" + vhParam + ");\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-    }
-
-    public void addSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS + "void " + javaName + "$set(" + type.getName() + " x) {\n");
-        incrAlign();
-        indent();
-        String vhParam = addressGetCallString(javaName, nativeName, layout);
-        sb.append(varHandleGetCallString(javaName, nativeName, layout, type, null) + ".set(" + vhParam + ", x);\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-    }
-
-    // Utility
-
-    protected void addPackagePrefix() {
-        assert pkgName.indexOf('/') == -1 : "package name invalid: " + pkgName;
-        sb.append("// Generated by jextract\n\n");
-        if (!pkgName.isEmpty()) {
-            sb.append("package ");
-            sb.append(pkgName);
-            sb.append(";\n\n");
-        }
-    }
-
-    protected void addImportSection() {
-        sb.append("import java.lang.invoke.MethodHandle;\n");
-        sb.append("import java.lang.invoke.VarHandle;\n");
-        sb.append("import jdk.incubator.foreign.*;\n");
-        sb.append("import jdk.incubator.foreign.MemoryLayout.PathElement;\n");
-        sb.append("import static ");
-        sb.append(OutputFactory.C_LANG_CONSTANTS_HOLDER);
-        sb.append(".*;\n");
-    }
-
-    protected void emitForwardGetter(DirectMethodHandleDesc desc) {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS + displayName(desc.invocationType().returnType()) + " " + desc.methodName() + "() {\n");
-        incrAlign();
-        indent();
-        sb.append("return " + getCallString(desc) + ";\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-    }
-
-    protected String getCallString(DirectMethodHandleDesc desc) {
-        return desc.owner().displayName() + "." + desc.methodName() + "()";
-    }
-
-    protected String displayName(ClassDesc returnType) {
-        return returnType.displayName(); // TODO shorten based on imports
-    }
-
-    protected String functionGetCallString(String javaName, FunctionDescriptor fDesc) {
-        return getCallString(constantHelper.addFunctionDesc(javaName, fDesc));
-    }
-
-    protected String methodHandleGetCallString(String javaName, String nativeName, MethodType mt, FunctionDescriptor fDesc, boolean varargs) {
-        return getCallString(constantHelper.addMethodHandle(javaName, nativeName, mt, fDesc, varargs));
-    }
-
-    protected String varHandleGetCallString(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
-        return getCallString(constantHelper.addVarHandle(javaName, nativeName, layout, type, parentLayout));
-    }
-
-    protected String addressGetCallString(String javaName, String nativeName, MemoryLayout layout) {
-        return getCallString(constantHelper.addAddress(javaName, nativeName, layout));
-    }
-
-    protected void indent() {
-        for (int i = 0; i < align; i++) {
-            sb.append("    ");
-        }
-    }
-
-    protected void incrAlign() {
-        align++;
-    }
-
-    protected void decrAlign() {
-        align--;
-    }
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/JextractTask.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/JextractTask.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/JextractTask.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- *  This code is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 only, as
- *  published by the Free Software Foundation.  Oracle designates this
- *  particular file as subject to the "Classpath" exception as provided
- *  by Oracle in the LICENSE file that accompanied this code.
- *
- *  This code is distributed in the hope that it will be useful, but WITHOUT
- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- *  version 2 for more details (a copy is included in the LICENSE file that
- *  accompanied this code).
- *
- *  You should have received a copy of the GNU General Public License version
- *  2 along with this work; if not, write to the Free Software Foundation,
- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- *  or visit www.oracle.com if you need additional information or have any
- *  questions.
- *
- */
-
-package jdk.incubator.jextract;
-
-import jdk.internal.jextract.impl.JextractTaskImpl;
-
-import javax.tools.JavaFileObject;
-import java.io.UncheckedIOException;
-import java.nio.file.Path;
-import java.util.Optional;
-
-/**
- * This interface models a so called <em>extraction</em> task which aims at generating a suitable Java API from a foreign
- * library. A new extraction task is obtained using the {@link #newTask(boolean, Path...)} factory. Once an extraction
- * task has been obtained, the source files of the foreign library can be parsed into a toplevel foreign
- * declaration (see {@link Declaration}). After parsing, a client can define one or more processing steps
- * (typically by using type and declaration visitors, see {@link Type.Visitor} and {@link Declaration.Visitor}.
- * Once processing is complete, the client should generate a list of {@link JavaFileObject} which embody the result
- * of the API extraction process; such files can be written onto a given destination path using the extraction
- * task (see {@link #write(Path, JavaFileObject...)}).
- */
-public interface JextractTask {
-
-    /**
-     * Creates a new extraction task with given input files.
-     * @param compileSources true, if the task should result in the compilation of the generated {@link JavaFileObject}
-     *                       whose kind is set to {@link JavaFileObject.Kind#SOURCE}.
-     * @param inputFiles the input files of the extraction task.
-     * @return a new extraction task with given input files.
-     */
-    static JextractTask newTask(boolean compileSources, Path... inputFiles) {
-        return new JextractTaskImpl(compileSources, inputFiles);
-    }
-
-    /**
-     * A constant parser is an helper object that is used to parse constant values in a foreign language,
-     * and create a corresponding declaration constant, if possible.
-     */
-    interface ConstantParser {
-        /**
-         * Parses a constant at given position, with given name and list of tokens.
-         * @param pos the constant position.
-         * @param name the constant name.
-         * @param tokens the constant tokens.
-         * @return a constant declaration which embeds the parsed constant value, if possible.
-         */
-        Optional<Declaration.Constant> parseConstant(Position pos, String name, String[] tokens);
-    }
-
-    /**
-     * Parse input files into a toplevel declaration with given options.
-     * @param parserOptions options to be passed to the parser.
-     * @return a toplevel declaration.
-     */
-    Declaration.Scoped parse(String... parserOptions);
-
-    /**
-     * Parse input files into a toplevel declaration with given constant parser and options.
-     * @param constantParser the constant parser to evaluate constants.
-     * @param parserOptions options to be passed to the parser.
-     * @return a toplevel declaration.
-     */
-    Declaration.Scoped parse(ConstantParser constantParser, String... parserOptions);
-
-    /**
-     * Write resulting {@link JavaFileObject} instances into specified destination path.
-     * @param dest the destination path.
-     * @param files the {@link JavaFileObject} instances to be written.
-     */
-    void write(Path dest, JavaFileObject... files) throws UncheckedIOException;
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/JextractTool.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/JextractTool.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/JextractTool.java
@@ -0,0 +1,290 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.incubator.jextract;
+
+import jdk.internal.jextract.impl.Filter;
+import jdk.internal.jextract.impl.OutputFactory;
+import jdk.internal.jextract.impl.Parser;
+import jdk.internal.jextract.impl.Options;
+import jdk.internal.jextract.impl.Writer;
+import jdk.internal.joptsimple.OptionException;
+import jdk.internal.joptsimple.OptionParser;
+import jdk.internal.joptsimple.OptionSet;
+
+import javax.tools.JavaFileObject;
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.UncheckedIOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.text.MessageFormat;
+import java.util.List;
+import java.util.Locale;
+import java.util.Optional;
+import java.util.ResourceBundle;
+import java.util.spi.ToolProvider;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * Simple extraction tool which generates a minimal Java API. Such an API consists mainly of static methods,
+ * where for each native function a static method is added which calls the underlying native method handles.
+ * Similarly, for struct fields and global variables, static accessors (getter and setter) are generated
+ * on top of the underlying memory access var handles. For each struct, a static layout field is generated.
+ */
+public final class JextractTool {
+    private static final String MESSAGES_RESOURCE = "jdk.internal.jextract.impl.resources.Messages";
+
+    private static final ResourceBundle MESSAGES_BUNDLE;
+    static {
+        MESSAGES_BUNDLE = ResourceBundle.getBundle(MESSAGES_RESOURCE, Locale.getDefault());
+    }
+
+    public static final boolean DEBUG = Boolean.getBoolean("jextract.debug");
+
+    // error codes
+    private static final int SUCCESS       = 0;
+    private static final int OPTION_ERROR  = 1;
+    private static final int INPUT_ERROR   = 2;
+    private static final int OUTPUT_ERROR  = 3;
+    private static final int RUNTIME_ERROR = 4;
+
+    private final PrintWriter out;
+    private final PrintWriter err;
+
+    private static String format(String msgId, Object... args) {
+        return new MessageFormat(MESSAGES_BUNDLE.getString(msgId)).format(args);
+    }
+
+    private JextractTool(PrintWriter out, PrintWriter err) {
+        this.out = out;
+        this.err = err;
+    }
+
+    private static Path generateTmpSource(List<Path> headers) {
+        assert headers.size() > 1;
+        try {
+            Path tmpFile = Files.createTempFile("jextract", ".h");
+            tmpFile.toFile().deleteOnExit();
+            Files.write(tmpFile, headers.stream().
+                    map(src -> "#include \"" + src + "\"").
+                    collect(Collectors.toList()));
+            return tmpFile;
+        } catch (IOException ioExp) {
+            throw new UncheckedIOException(ioExp);
+        }
+    }
+
+    /**
+     * Parse input files into a toplevel declaration with given options.
+     * @param parserOptions options to be passed to the parser.
+     * @return a toplevel declaration.
+     */
+    public static Declaration.Scoped parse(List<Path> headers, String... parserOptions) {
+        Path source = headers.size() > 1? generateTmpSource(headers) : headers.iterator().next();
+        return new Parser().parse(source, Stream.of(parserOptions).collect(Collectors.toList()));
+    }
+
+    public static Declaration.Scoped filter(Declaration.Scoped decl, String... includedNames) {
+        return Filter.filter(decl, includedNames);
+    }
+
+    public static List<JavaFileObject> generate(Declaration.Scoped decl, String headerName, String targetPkg, List<String> libNames) {
+        return List.of(OutputFactory.generateWrapped(decl, headerName, targetPkg, libNames));
+    }
+
+    /**
+     * Write resulting {@link JavaFileObject} instances into specified destination path.
+     * @param dest the destination path.
+     * @param compileSources whether to compile .java sources or not
+     * @param files the {@link JavaFileObject} instances to be written.
+     */
+    public static void write(Path dest, boolean compileSources, List<JavaFileObject> files) throws UncheckedIOException {
+        try {
+            new Writer(dest, files).writeAll(compileSources);
+        } catch (IOException ex) {
+            throw new UncheckedIOException(ex);
+        }
+    }
+
+    private int printHelp(OptionParser parser, int exitCode) {
+        try {
+            parser.printHelpOn(err);
+        } catch (IOException ignored) {}
+        return exitCode;
+    }
+
+    /**
+     * Main entry point to run the JextractTool
+     *
+     * @param args command line options passed
+     */
+    public static void main(String[] args) {
+        if (args.length == 0) {
+            System.err.println("Expected a header file");
+            return;
+        }
+
+        JextractTool m = new JextractTool(new PrintWriter(System.out, true), new PrintWriter(System.err, true));
+        System.exit(m.run(args));
+    }
+
+    private int run(String[] args) {
+        OptionParser parser = new OptionParser(false);
+        parser.accepts("C", format("help.C")).withRequiredArg();
+        parser.accepts("I", format("help.I")).withRequiredArg();
+        parser.accepts("d", format("help.d")).withRequiredArg();
+        parser.accepts("filter", format("help.filter")).withRequiredArg();
+        parser.accepts("l", format("help.l")).withRequiredArg();
+        parser.accepts("source", format("help.source"));
+        parser.acceptsAll(List.of("t", "target-package"), format("help.t")).withRequiredArg();
+        parser.acceptsAll(List.of("?", "h", "help"), format("help.h")).forHelp();
+        parser.nonOptions(format("help.non.option"));
+
+        OptionSet optionSet;
+        try {
+            optionSet = parser.parse(args);
+        } catch (OptionException oe) {
+            return printHelp(parser, OPTION_ERROR);
+        }
+
+        if (optionSet.has("h")) {
+            return printHelp(parser, SUCCESS);
+        }
+
+        if (optionSet.nonOptionArguments().size() != 1) {
+            return printHelp(parser, OPTION_ERROR);
+        }
+
+        Options.Builder builder = Options.builder();
+        if (optionSet.has("I")) {
+            optionSet.valuesOf("I").forEach(p -> builder.addClangArg("-I" + p));
+        }
+
+        Path builtinInc = Paths.get(System.getProperty("java.home"), "conf", "jextract");
+        builder.addClangArg("-I" + builtinInc);
+
+        if (optionSet.has("C")) {
+            optionSet.valuesOf("C").forEach(p -> builder.addClangArg((String) p));
+        }
+
+        if (optionSet.has("filter")) {
+            optionSet.valuesOf("filter").forEach(p -> builder.addFilter((String) p));
+        }
+
+        if (optionSet.has("d")) {
+            builder.setOutputDir(optionSet.valueOf("d").toString());
+        }
+
+        if (optionSet.has("source")) {
+            builder.setGenerateSource();
+        }
+        boolean librariesSpecified = optionSet.has("l");
+        if (librariesSpecified) {
+            for (Object arg : optionSet.valuesOf("l")) {
+                String lib = (String)arg;
+                if (lib.indexOf(File.separatorChar) == -1) {
+                    builder.addLibraryName(lib);
+                } else {
+                    Path libPath = Paths.get(lib);
+                    if (libPath.isAbsolute() && Files.isRegularFile(libPath)) {
+                        builder.addLibraryName(lib);
+                    } else {
+                        err.println(format("l.option.value.invalid", lib));
+                        return OPTION_ERROR;
+                    }
+                }
+            }
+        }
+
+        String targetPackage = optionSet.has("t") ? (String) optionSet.valueOf("t") : "";
+        builder.setTargetPackage(targetPackage);
+
+        Options options = builder.build();
+
+        Path header = Paths.get(optionSet.nonOptionArguments().get(0).toString());
+        if (!Files.isReadable(header)) {
+            err.println(format("cannot.read.header.file", header));
+            return INPUT_ERROR;
+        }
+
+        //parse    //generate
+        try {
+            Declaration.Scoped toplevel = parse(List.of(header), options.clangArgs.toArray(new String[0]));
+
+            //filter
+            if (!options.filters.isEmpty()) {
+                toplevel = filter(toplevel, options.filters.toArray(new String[0]));
+            }
+
+            if (JextractTool.DEBUG) {
+                System.out.println(toplevel);
+            }
+
+            Path output = Path.of(options.outputDir);
+
+            List<JavaFileObject> files = generate(
+                toplevel, header.getFileName().toString(),
+                options.targetPackage, options.libraryNames);
+
+            write(output, !options.source, files);
+        } catch (RuntimeException re) {
+            err.println(re);
+            if (JextractTool.DEBUG) {
+                re.printStackTrace(err);
+            }
+            return RUNTIME_ERROR;
+        }
+        return SUCCESS;
+    }
+
+    /**
+     * ToolProvider implementation for jextract tool.
+     */
+    public static class JextractToolProvider implements ToolProvider {
+        @Override
+        public String name() {
+            return "jextract";
+        }
+
+        @Override
+        public int run(PrintWriter out, PrintWriter err, String... args) {
+            // defensive check to throw security exception early.
+            // Note that the successful run of jextract under security
+            // manager would require far more permissions like loading
+            // library (clang), file system access etc.
+            if (System.getSecurityManager() != null) {
+                System.getSecurityManager().
+                    checkPermission(new RuntimePermission("jextract"));
+            }
+
+            JextractTool instance = new JextractTool(out, err);
+            return instance.run(args);
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/OutputFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/OutputFactory.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/OutputFactory.java
+++ /dev/null
@@ -1,418 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.incubator.jextract;
-
-import jdk.incubator.foreign.*;
-import jdk.incubator.jextract.Type.Primitive;
-import javax.tools.JavaFileObject;
-import javax.tools.SimpleJavaFileObject;
-import java.io.IOException;
-import java.io.UncheckedIOException;
-import java.lang.constant.ClassDesc;
-import java.lang.invoke.MethodType;
-import java.net.URI;
-import java.net.URL;
-import java.net.URISyntaxException;
-import java.nio.file.Files;
-import java.nio.file.Paths;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.stream.Collectors;
-
-/*
- * Scan a header file and generate Java source items for entities defined in that header
- * file. Tree visitor visit methods return true/false depending on whether a
- * particular Tree is processed or skipped.
- */
-public class OutputFactory implements Declaration.Visitor<Void, Declaration> {
-    private final Set<String> constants = new HashSet<>();
-    // To detect duplicate Variable and Function declarations.
-    private final Set<Declaration.Variable> variables = new HashSet<>();
-    private final Set<Declaration.Function> functions = new HashSet<>();
-
-    protected final HeaderBuilder builder;
-    protected final ConstantHelper constantHelper;
-    protected final TypeTranslator typeTranslator = new TypeTranslator();
-    private final String clsName;
-    private final String pkgName;
-    private StructBuilder structBuilder;
-    private Map<Declaration, String> structClassNames = new HashMap<>();
-    private List<String> structSources = new ArrayList<>();
-    private Set<String> nestedClassNames = new HashSet<>();
-    private Set<Declaration.Typedef> unresolvedStructTypedefs = new HashSet<>();
-    private int nestedClassNameCount = 0;
-    /*
-     * We may have case-insensitive name collision! A C program may have
-     * defined structs/unions/typedefs with the names FooS, fooS, FoOs, fOOs.
-     * Because we map structs/unions/typedefs to nested classes of header classes,
-     * such a case-insensitive name collision is problematic. This is because in
-     * a case-insensitive file system javac will overwrite classes for
-     * Header$CFooS, Header$CfooS, Header$CFoOs and so on! We solve this by
-     * generating unique case-insensitive names for nested classes.
-     */
-    private String uniqueNestedClassName(String name) {
-        name = Utils.javaSafeIdentifier(name);
-        return nestedClassNames.add(name.toLowerCase())? name : (name + "$" + nestedClassNameCount++);
-    }
-
-    private String structClassName(Declaration decl) {
-        return structClassNames.computeIfAbsent(decl, d -> uniqueNestedClassName(d.name()));
-    }
-
-    private boolean structDefinitionSeen(Declaration decl) {
-        return structClassNames.containsKey(decl);
-    }
-
-    // have we seen this Variable earlier?
-    protected boolean variableSeen(Declaration.Variable tree) {
-        return !variables.add(tree);
-    }
-
-    // have we seen this Function earlier?
-    protected boolean functionSeen(Declaration.Function tree) {
-        return !functions.add(tree);
-    }
-
-    public static JavaFileObject[] generateWrapped(Declaration.Scoped decl, String headerName, String pkgName, List<String> libraryNames) {
-        String clsName = Utils.javaSafeIdentifier(headerName.replace(".h", "_h"), true);
-        String qualName = pkgName.isEmpty() ? clsName : pkgName + "." + clsName;
-        ConstantHelper constantHelper = new ConstantHelper(qualName,
-                ClassDesc.of(pkgName, "RuntimeHelper"), ClassDesc.of("jdk.incubator.foreign", "CSupport"),
-                libraryNames.toArray(String[]::new));
-        return new OutputFactory(clsName, pkgName,
-                new HeaderBuilder(clsName, pkgName, constantHelper), constantHelper).generate(decl);
-    }
-
-    public OutputFactory(String clsName, String pkgName, HeaderBuilder builder, ConstantHelper constantHelper) {
-        this.clsName = clsName;
-        this.pkgName = pkgName;
-        this.builder = builder;
-        this.constantHelper = constantHelper;
-    }
-
-    private static String getCLangConstantsHolder() {
-        String prefix = "jdk.incubator.foreign.CSupport.";
-        String abi = CSupport.getSystemLinker().name();
-        switch (abi) {
-            case CSupport.SysV.NAME:
-                return prefix + "SysV";
-            case CSupport.Win64.NAME:
-                return prefix + "Win64";
-            case CSupport.AArch64.NAME:
-                return prefix + "AArch64";
-            default:
-                throw new UnsupportedOperationException("Unsupported ABI: " + abi);
-        }
-    }
-
-    static final String C_LANG_CONSTANTS_HOLDER = getCLangConstantsHolder();
-
-    public JavaFileObject[] generate(Declaration.Scoped decl) {
-        builder.classBegin();
-        //generate all decls
-        decl.members().forEach(this::generateDecl);
-        for (String src : structSources) {
-            builder.addContent(src);
-        }
-        // check if unresolved typedefs can be resolved now!
-        for (Declaration.Typedef td : unresolvedStructTypedefs) {
-            Declaration.Scoped structDef = ((Type.Declared)td.type()).tree();
-            if (structDefinitionSeen(structDef)) {
-                builder.emitTypedef(uniqueNestedClassName(td.name()), structClassName(structDef));
-            }
-        }
-        builder.classEnd();
-        try {
-            List<JavaFileObject> files = new ArrayList<>();
-            files.add(builder.build());
-            files.addAll(constantHelper.getClasses());
-            files.add(fileFromString(pkgName,"RuntimeHelper", getRuntimeHelperSource()));
-            return files.toArray(new JavaFileObject[0]);
-        } catch (IOException ex) {
-            throw new UncheckedIOException(ex);
-        } catch (URISyntaxException ex2) {
-            throw new RuntimeException(ex2);
-        }
-    }
-
-    private String getRuntimeHelperSource() throws URISyntaxException, IOException {
-        URL runtimeHelper = OutputFactory.class.getResource("resources/RuntimeHelper.java.template");
-        return (pkgName.isEmpty()? "" : "package " + pkgName + ";\n") +
-                        String.join("\n", Files.readAllLines(Paths.get(runtimeHelper.toURI())))
-                                .replace("${C_LANG}", C_LANG_CONSTANTS_HOLDER);
-    }
-
-    private void generateDecl(Declaration tree) {
-        try {
-            tree.accept(this, null);
-        } catch (Exception ex) {
-            ex.printStackTrace();
-        }
-    }
-
-    private static Class<?> classForType(Primitive.Kind type, MemoryLayout layout) {
-        boolean isFloat = switch(type) {
-            case Float, Double, LongDouble -> true;
-            default-> false;
-        };
-        return TypeTranslator.layoutToClass(isFloat, layout);
-    }
-
-    private JavaFileObject fileFromString(String pkgName, String clsName, String contents) {
-        String pkgPrefix = pkgName.isEmpty() ? "" : pkgName.replaceAll("\\.", "/") + "/";
-        return new SimpleJavaFileObject(URI.create(pkgPrefix + clsName + ".java"), JavaFileObject.Kind.SOURCE) {
-            @Override
-            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
-                return contents;
-            }
-        };
-    }
-
-    @Override
-    public Void visitConstant(Declaration.Constant constant, Declaration parent) {
-        if (!constants.add(constant.name())) {
-            //skip
-            return null;
-        }
-
-        builder.addConstantGetter(Utils.javaSafeIdentifier(constant.name()),
-                constant.value() instanceof String ? MemorySegment.class :
-                typeTranslator.getJavaType(constant.type()), constant.value());
-        return null;
-    }
-
-    @Override
-    public Void visitScoped(Declaration.Scoped d, Declaration parent) {
-        if (d.layout().isEmpty()) {
-            //skip decl-only
-            return null;
-        }
-        boolean structClass = false;
-        StructBuilder oldStructBuilder = this.structBuilder;
-        if (!d.name().isEmpty() || !isRecord(parent)) {
-            //only add explicit struct layout if the struct is not to be flattened inside another struct
-            switch (d.kind()) {
-                case STRUCT:
-                case UNION: {
-                    structClass = true;
-                    String className = structClassName(d.name().isEmpty() ? parent : d);
-                    this.structBuilder = new StructBuilder(className, pkgName, constantHelper);
-                    structBuilder.incrAlign();
-                    structBuilder.classBegin();
-                    structBuilder.addLayoutGetter(className, d.layout().get());
-                    break;
-                }
-            }
-        }
-        d.members().forEach(fieldTree -> fieldTree.accept(this, d.name().isEmpty() ? parent : d));
-        if (structClass) {
-            this.structBuilder.classEnd();
-            structSources.add(structBuilder.getSource());
-            this.structBuilder = oldStructBuilder;
-        }
-        return null;
-    }
-
-    @Override
-    public Void visitFunction(Declaration.Function funcTree, Declaration parent) {
-        if (functionSeen(funcTree)) {
-            return null;
-        }
-
-        MethodType mtype = typeTranslator.getMethodType(funcTree.type());
-        FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);
-        if (descriptor == null) {
-            //abort
-            return null;
-        }
-        String mhName = Utils.javaSafeIdentifier(funcTree.name());
-        builder.addMethodHandleGetter(mhName, funcTree.name(), mtype, descriptor, funcTree.type().varargs());
-        //generate static wrapper for function
-        List<String> paramNames = funcTree.parameters()
-                                          .stream()
-                                          .map(Declaration.Variable::name)
-                                          .map(p -> !p.isEmpty() ? Utils.javaSafeIdentifier(p) : p)
-                                          .collect(Collectors.toList());
-        builder.addStaticFunctionWrapper(Utils.javaSafeIdentifier(funcTree.name()), funcTree.name(), mtype,
-                Type.descriptorFor(funcTree.type()).orElseThrow(), funcTree.type().varargs(), paramNames);
-        int i = 0;
-        for (Declaration.Variable param : funcTree.parameters()) {
-            Type.Function f = getAsFunctionPointer(param.type());
-            if (f != null) {
-                String name = funcTree.name() + "$" + (param.name().isEmpty() ? "x" + i : param.name());
-                name = Utils.javaSafeIdentifier(name);
-                //generate functional interface
-                if (f.varargs()) {
-                    System.err.println("WARNING: varargs in callbacks is not supported");
-                }
-                MethodType fitype = typeTranslator.getMethodType(f, false);
-                builder.addFunctionalInterface(name, fitype, Type.descriptorFor(f).orElseThrow());
-                i++;
-            }
-        }
-        return null;
-    }
-
-    Type.Function getAsFunctionPointer(Type type) {
-        if (type instanceof Type.Delegated) {
-            switch (((Type.Delegated) type).kind()) {
-                case POINTER: {
-                    Type pointee = ((Type.Delegated) type).type();
-                    return (pointee instanceof Type.Function) ?
-                        (Type.Function)pointee : null;
-                }
-                default:
-                    return getAsFunctionPointer(((Type.Delegated) type).type());
-            }
-        } else {
-            return null;
-        }
-    }
-
-    @Override
-    public Void visitTypedef(Declaration.Typedef tree, Declaration parent) {
-        Type type = tree.type();
-        if (type instanceof Type.Declared) {
-            Declaration.Scoped s = ((Type.Declared) type).tree();
-            if (!s.name().equals(tree.name())) {
-                switch (s.kind()) {
-                    case STRUCT:
-                    case UNION: {
-                        if (s.name().isEmpty()) {
-                            visitScoped(s, tree);
-                        } else {
-                            /*
-                             * If typedef is seen after the struct/union definition, we can generate subclass
-                             * right away. If not, we've to save it and revisit after all the declarations are
-                             * seen. This is to support forward declaration of typedefs.
-                             *
-                             * typedef struct Foo Bar;
-                             *
-                             * struct Foo {
-                             *     int x, y;
-                             * };
-                             */
-                            if (structDefinitionSeen(s)) {
-                                builder.emitTypedef(uniqueNestedClassName(tree.name()), structClassName(s));
-                            } else {
-                                /*
-                                 * Definition of typedef'ed struct/union not seen yet. May be the definition comes later.
-                                 * Save it to visit at the end of all declarations.
-                                 */
-                                unresolvedStructTypedefs.add(tree);
-                            }
-                        }
-                    }
-                    break;
-                    default:
-                        visitScoped(s, tree);
-                }
-            }
-        } else if (type instanceof Type.Primitive) {
-             builder.emitPrimitiveTypedef((Type.Primitive)type, uniqueNestedClassName(tree.name()));
-        }
-        return null;
-    }
-
-    @Override
-    public Void visitVariable(Declaration.Variable tree, Declaration parent) {
-        if (parent == null && variableSeen(tree)) {
-            return null;
-        }
-
-        String fieldName = tree.name();
-        String symbol = tree.name();
-        assert !symbol.isEmpty();
-        assert !fieldName.isEmpty();
-        fieldName = Utils.javaSafeIdentifier(fieldName);
-
-        Type type = tree.type();
-        MemoryLayout layout = tree.layout().orElse(Type.layoutFor(type).orElse(null));
-        if (layout == null) {
-            //no layout - abort
-            return null;
-        }
-        Class<?> clazz = typeTranslator.getJavaType(type);
-        if (tree.kind() == Declaration.Variable.Kind.BITFIELD ||
-                (layout instanceof ValueLayout && layout.byteSize() > 8)) {
-            //skip
-            return null;
-        }
-
-        boolean isSegment = clazz == MemorySegment.class;
-        MemoryLayout treeLayout = tree.layout().orElseThrow();
-        if (parent != null) { //struct field
-            MemoryLayout parentLayout = parentLayout(parent);
-            if (isSegment) {
-                structBuilder.addAddressGetter(fieldName, tree.name(), treeLayout, parentLayout);
-            } else {
-                structBuilder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
-                structBuilder.addGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
-                structBuilder.addSetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
-            }
-        } else {
-            if (isSegment) {
-                builder.addAddressGetter(fieldName, tree.name(), treeLayout, null);
-            } else {
-                builder.addLayoutGetter(fieldName, layout);
-                builder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz,null);
-                builder.addAddressGetter(fieldName, tree.name(), treeLayout, null);
-                builder.addGetter(fieldName, tree.name(), treeLayout, clazz, null);
-                builder.addSetter(fieldName, tree.name(), treeLayout, clazz, null);
-            }
-        }
-
-        return null;
-    }
-
-    private boolean isRecord(Declaration declaration) {
-        if (declaration == null) {
-            return false;
-        } else if (!(declaration instanceof Declaration.Scoped)) {
-            return false;
-        } else {
-            Declaration.Scoped scope = (Declaration.Scoped)declaration;
-            return scope.kind() == Declaration.Scoped.Kind.CLASS ||
-                    scope.kind() == Declaration.Scoped.Kind.STRUCT ||
-                    scope.kind() == Declaration.Scoped.Kind.UNION;
-        }
-    }
-
-    protected static MemoryLayout parentLayout(Declaration parent) {
-        if (parent instanceof Declaration.Typedef) {
-            Declaration.Typedef alias = (Declaration.Typedef) parent;
-            return Type.layoutFor(alias.type()).orElseThrow();
-        } else if (parent instanceof Declaration.Scoped) {
-            return ((Declaration.Scoped) parent).layout().orElseThrow();
-        } else {
-            throw new IllegalArgumentException("Unexpected parent declaration");
-        }
-        // case like `typedef struct { ... } Foo`
-    }
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/StructBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/StructBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/StructBuilder.java
+++ /dev/null
@@ -1,209 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.incubator.jextract;
-
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.MemorySegment;
-
-/**
- * This class generates static utilities class for C structs, unions.
- */
-public class StructBuilder extends JavaSourceBuilder {
-    public StructBuilder(String className, String pkgName, ConstantHelper constantHelper) {
-        super(className, pkgName, constantHelper);
-    }
-
-    @Override
-    protected String getClassModifiers() {
-        return PUB_MODS;
-    }
-
-    @Override
-    protected void addPackagePrefix() {
-        // nested class. containing class has necessary package declaration
-    }
-
-    @Override
-    protected void addImportSection() {
-        // nested class. containing class has necessary imports
-    }
-
-    @Override
-    public void classEnd() {
-        emitSizeof();
-        emitAllocate();
-        emitScopeAllocate();
-        emitAllocateArray();
-        emitScopeAllocateArray();
-        super.classEnd();
-    }
-
-    @Override
-    public void addLayoutGetter(String javaName, MemoryLayout layout) {
-        var desc = constantHelper.addLayout(javaName + "$struct", layout);
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS + displayName(desc.invocationType().returnType()) + " $LAYOUT() {\n");
-        incrAlign();
-        indent();
-        sb.append("return " + getCallString(desc) + ";\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-    }
-
-    @Override
-    public void addGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS + type.getName() + " " + javaName + "$get(MemorySegment addr) {\n");
-        incrAlign();
-        indent();
-        sb.append("return (" + type.getName() + ")"
-                + varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".get(addr);\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-
-        addIndexGetter(javaName, nativeName, layout, type, parentLayout);
-    }
-
-    @Override
-    public void addSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
-        incrAlign();
-        indent();
-        String param = MemorySegment.class.getName() + " addr";
-        sb.append(PUB_MODS + "void " + javaName + "$set(" + param + ", " + type.getName() + " x) {\n");
-        incrAlign();
-        indent();
-        sb.append(varHandleGetCallString(javaName, nativeName, layout, type, null) + ".set(addr, x);\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-
-        addIndexSetter(javaName, nativeName, layout, type, parentLayout);
-    }
-
-    @Override
-    public void addAddressGetter(String javaName, String nativeName, MemoryLayout layout, MemoryLayout parentLayout) {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS + "MemorySegment " + javaName + "$addr(MemorySegment addr) {\n");
-        incrAlign();
-        indent();
-        sb.append("return addr.asSlice(");
-        sb.append(parentLayout.byteOffset(MemoryLayout.PathElement.groupElement(nativeName)));
-        sb.append(", ");
-        sb.append(layout.byteSize());
-        sb.append(");\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-    }
-
-    private void emitSizeof() {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS);
-        sb.append("long sizeof() { return $LAYOUT().byteSize(); }\n");
-        decrAlign();
-    }
-
-    private void emitAllocate() {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS);
-        sb.append("MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n");
-        decrAlign();
-    }
-
-    private void emitScopeAllocate() {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS);
-        sb.append("MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n");
-        decrAlign();
-    }
-
-    private void emitAllocateArray() {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS);
-        sb.append("MemorySegment allocateArray(int len) {\n");
-        incrAlign();
-        indent();
-        sb.append("return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));");
-        decrAlign();
-        sb.append("}\n");
-        decrAlign();
-    }
-
-    private void emitScopeAllocateArray() {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS);
-        sb.append("MemorySegment allocateArray(int len, NativeScope scope) {\n");
-        incrAlign();
-        indent();
-        sb.append("return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));");
-        decrAlign();
-        sb.append("}\n");
-        decrAlign();
-    }
-
-    private void addIndexGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
-        incrAlign();
-        indent();
-        String params = MemorySegment.class.getName() + " addr, long index";
-        sb.append(PUB_MODS + type.getName() + " " + javaName + "$get(" + params + ") {\n");
-        incrAlign();
-        indent();
-        sb.append("return (" + type.getName() + ")"
-                + varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".get(addr.asSlice(index*sizeof()));\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-    }
-
-    private void addIndexSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
-        incrAlign();
-        indent();
-        String params = MemorySegment.class.getName() + " addr, long index, " + type.getName() + " x";
-        sb.append(PUB_MODS + "void " + javaName + "$set(" + params + ") {\n");
-        incrAlign();
-        indent();
-        sb.append(varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".set(addr.asSlice(index*sizeof()), x);\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-    }
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Utils.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Utils.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Utils.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.incubator.jextract;
-
-import javax.lang.model.SourceVersion;
-import javax.tools.JavaFileObject;
-import javax.tools.SimpleJavaFileObject;
-import java.io.IOException;
-import java.net.URI;
-
-final class Utils {
-
-    private Utils() {}
-
-    private static URI fileName(String pkgName, String clsName, String extension) {
-        String pkgPrefix = pkgName.isEmpty() ? "" : pkgName.replaceAll("\\.", "/") + "/";
-        return URI.create(pkgPrefix + clsName + extension);
-    }
-
-    static JavaFileObject fileFromString(String pkgName, String clsName, String contents) {
-        return new SimpleJavaFileObject(fileName(pkgName, clsName, ".java"), JavaFileObject.Kind.SOURCE) {
-            @Override
-            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
-                return contents;
-            }
-        };
-    }
-
-    static String javaSafeIdentifier(String name) {
-        return javaSafeIdentifier(name, false);
-    }
-
-    static String javaSafeIdentifier(String name, boolean checkAllChars) {
-        if (checkAllChars) {
-            StringBuilder buf = new StringBuilder();
-            char[] chars = name.toCharArray();
-            if (Character.isJavaIdentifierStart(chars[0])) {
-                buf.append(chars[0]);
-            } else {
-                buf.append('_');
-            }
-            if (chars.length > 1) {
-                for (int i = 1; i < chars.length; i++) {
-                    char ch = chars[i];
-                    if (Character.isJavaIdentifierPart(ch)) {
-                        buf.append(ch);
-                    } else {
-                        buf.append('_');
-                    }
-                }
-            }
-            return buf.toString();
-        } else {
-            // We never get the problem of Java non-identifiers (like 123, ab-xy) as
-            // C identifiers. But we may have a java keyword used as a C identifier.
-            assert SourceVersion.isIdentifier(name);
-
-            return SourceVersion.isKeyword(name) ? (name + "_") : name;
-        }
-    }
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Main.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Main.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Main.java
+++ /dev/null
@@ -1,230 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package jdk.incubator.jextract.tool;
-
-import jdk.incubator.jextract.*;
-import jdk.internal.joptsimple.OptionException;
-import jdk.internal.joptsimple.OptionParser;
-import jdk.internal.joptsimple.OptionSet;
-
-import javax.tools.JavaFileObject;
-import java.io.File;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.nio.file.Paths;
-import java.text.MessageFormat;
-import java.util.List;
-import java.util.Locale;
-import java.util.ResourceBundle;
-import java.util.spi.ToolProvider;
-
-/**
- * Simple extraction tool which generates a minimal Java API. Such an API consists mainly of static methods,
- * where for each native function a static method is added which calls the underlying native method handles.
- * Similarly, for struct fields and global variables, static accessors (getter and setter) are generated
- * on top of the underlying memory access var handles. For each struct, a static layout field is generated.
- */
-public class Main {
-    private static final String MESSAGES_RESOURCE = "jdk.incubator.jextract.tool.resources.Messages";
-
-    private static final ResourceBundle MESSAGES_BUNDLE;
-    static {
-        MESSAGES_BUNDLE = ResourceBundle.getBundle(MESSAGES_RESOURCE, Locale.getDefault());
-    }
-
-    public static final boolean DEBUG = Boolean.getBoolean("jextract.debug");
-
-    // error codes
-    private static final int SUCCESS       = 0;
-    private static final int OPTION_ERROR  = 1;
-    private static final int INPUT_ERROR   = 2;
-    private static final int OUTPUT_ERROR  = 3;
-    private static final int RUNTIME_ERROR = 4;
-
-    private final PrintWriter out;
-    private final PrintWriter err;
-
-    private static String format(String msgId, Object... args) {
-        return new MessageFormat(MESSAGES_BUNDLE.getString(msgId)).format(args);
-    }
-
-    private Main(PrintWriter out, PrintWriter err) {
-        this.out = out;
-        this.err = err;
-    }
-
-    private int printHelp(OptionParser parser, int exitCode) {
-        try {
-            parser.printHelpOn(err);
-        } catch (IOException ignored) {}
-        return exitCode;
-    }
-
-    public static void main(String[] args) {
-        if (args.length == 0) {
-            System.err.println("Expected a header file");
-            return;
-        }
-
-        Main m = new Main(new PrintWriter(System.out, true), new PrintWriter(System.err, true));
-        System.exit(m.run(args));
-    }
-
-    private int run(String[] args) {
-        OptionParser parser = new OptionParser(false);
-        parser.accepts("C", format("help.C")).withRequiredArg();
-        parser.accepts("I", format("help.I")).withRequiredArg();
-        parser.accepts("d", format("help.d")).withRequiredArg();
-        parser.accepts("filter", format("help.filter")).withRequiredArg();
-        parser.accepts("l", format("help.l")).withRequiredArg();
-        parser.accepts("source", format("help.source"));
-        parser.acceptsAll(List.of("t", "target-package"), format("help.t")).withRequiredArg();
-        parser.acceptsAll(List.of("?", "h", "help"), format("help.h")).forHelp();
-        parser.nonOptions(format("help.non.option"));
-
-        OptionSet optionSet;
-        try {
-            optionSet = parser.parse(args);
-        } catch (OptionException oe) {
-            return printHelp(parser, OPTION_ERROR);
-        }
-
-        if (optionSet.has("h")) {
-            return printHelp(parser, SUCCESS);
-        }
-
-        if (optionSet.nonOptionArguments().size() != 1) {
-            return printHelp(parser, OPTION_ERROR);
-        }
-
-        Options.Builder builder = Options.builder();
-        if (optionSet.has("I")) {
-            optionSet.valuesOf("I").forEach(p -> builder.addClangArg("-I" + p));
-        }
-
-        Path builtinInc = Paths.get(System.getProperty("java.home"), "conf", "jextract");
-        builder.addClangArg("-I" + builtinInc);
-
-        if (optionSet.has("C")) {
-            optionSet.valuesOf("C").forEach(p -> builder.addClangArg((String) p));
-        }
-
-        if (optionSet.has("filter")) {
-            optionSet.valuesOf("filter").forEach(p -> builder.addFilter((String) p));
-        }
-
-        if (optionSet.has("d")) {
-            builder.setOutputDir(optionSet.valueOf("d").toString());
-        }
-
-        if (optionSet.has("source")) {
-            builder.setGenerateSource();
-        }
-        boolean librariesSpecified = optionSet.has("l");
-        if (librariesSpecified) {
-            for (Object arg : optionSet.valuesOf("l")) {
-                String lib = (String)arg;
-                if (lib.indexOf(File.separatorChar) == -1) {
-                    builder.addLibraryName(lib);
-                } else {
-                    Path libPath = Paths.get(lib);
-                    if (libPath.isAbsolute() && Files.isRegularFile(libPath)) {
-                        builder.addLibraryName(lib);
-                    } else {
-                        err.println(format("l.option.value.invalid", lib));
-                        return OPTION_ERROR;
-                    }
-                }
-            }
-        }
-
-        String targetPackage = optionSet.has("t") ? (String) optionSet.valueOf("t") : "";
-        builder.setTargetPackage(targetPackage);
-
-        Options options = builder.build();
-
-        Path header = Paths.get(optionSet.nonOptionArguments().get(0).toString());
-        if (!Files.isReadable(header)) {
-            err.println(format("cannot.read.header.file", header));
-            return INPUT_ERROR;
-        }
-
-        //parse    //generate
-        try {
-            JextractTask jextractTask = JextractTask.newTask(!options.source, header);
-            Declaration.Scoped toplevel = jextractTask.parse(options.clangArgs.toArray(new String[0]));
-
-            //filter
-            if (!options.filters.isEmpty()) {
-                toplevel = Filter.filter(toplevel, options.filters.toArray(new String[0]));
-            }
-
-            if (Main.DEBUG) {
-                System.out.println(toplevel);
-            }
-
-            Path output = Path.of(options.outputDir);
-
-            JavaFileObject[] files = OutputFactory.generateWrapped(
-                toplevel,
-                header.getFileName().toString(),
-                options.targetPackage,
-                options.libraryNames);
-            jextractTask.write(output, files);
-        } catch (RuntimeException re) {
-            err.println(re);
-            if (Main.DEBUG) {
-                re.printStackTrace(err);
-            }
-            return RUNTIME_ERROR;
-        }
-        return SUCCESS;
-    }
-
-    public static class JextractToolProvider implements ToolProvider {
-        @Override
-        public String name() {
-            return "jextract";
-        }
-
-        @Override
-        public int run(PrintWriter out, PrintWriter err, String... args) {
-            // defensive check to throw security exception early.
-            // Note that the successful run of jextract under security
-            // manager would require far more permissions like loading
-            // library (clang), file system access etc.
-            if (System.getSecurityManager() != null) {
-                System.getSecurityManager().
-                    checkPermission(new RuntimePermission("jextract"));
-            }
-
-            Main instance = new Main(out, err);
-            return instance.run(args);
-        }
-    }
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Options.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Options.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Options.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.incubator.jextract.tool;
-
-import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.regex.Pattern;
-
-public class Options {
-    // The args for parsing C
-    public final List<String> clangArgs;
-    // The list of library names
-    public final List<String> libraryNames;
-    public final List<String> filters;
-    // target package
-    public final String targetPackage;
-    // output directory
-    public final String outputDir;
-    public final boolean source;
-
-    private Options(List<String> clangArgs, List<String> libraryNames,
-            List<String> filters, String targetPackage,
-            String outputDir, boolean source) {
-        this.clangArgs = clangArgs;
-        this.libraryNames = libraryNames;
-        this.filters = filters;
-        this.targetPackage = targetPackage;
-        this.outputDir = outputDir;
-        this.source = source;
-    }
-
-    public static Builder builder() {
-        return new Builder();
-    }
-
-    public static Options createDefault() {
-        return builder().build();
-    }
-
-    public static class Builder {
-        private final List<String> clangArgs;
-        private final List<String> libraryNames;
-        private final List<String> filters;
-        private String targetPackage;
-        private String outputDir;
-        private boolean source;
-
-        public Builder() {
-            this.clangArgs = new ArrayList<>();
-            this.libraryNames = new ArrayList<>();
-            this.filters = new ArrayList<>();
-            this.targetPackage = "";
-            this.outputDir = ".";
-            this.source = false;
-        }
-
-        public Options build() {
-            return new Options(
-                    Collections.unmodifiableList(clangArgs),
-                    Collections.unmodifiableList(libraryNames),
-                    Collections.unmodifiableList(filters),
-                    targetPackage, outputDir, source
-            );
-        }
-
-        public void addClangArg(String arg) {
-            clangArgs.add(arg);
-        }
-
-        public void addLibraryName(String name) {
-            libraryNames.add(name);
-        }
-
-        public void setOutputDir(String outputDir) {
-            this.outputDir = outputDir;
-        }
-
-        public void setTargetPackage(String pkg) {
-            this.targetPackage = pkg;
-        }
-
-        public void addFilter(String filter) {
-            filters.add(filter);
-        }
-
-        public void setGenerateSource() {
-            source = true;
-        }
-    }
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/ConstantHelper.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/ConstantHelper.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/ConstantHelper.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/ConstantHelper.java
@@ -20,11 +20,11 @@
  *
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
-package jdk.incubator.jextract;
+package jdk.internal.jextract.impl;
 
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.LibraryLookup;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Filter.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Filter.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Filter.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.jextract.impl;
+
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Position;
+
+public final class Filter {
+    private Filter() {}
+
+    public static Declaration.Scoped filter(Declaration.Scoped decl, String... validNames) {
+        Declaration[] newMembers = decl.members().stream()
+                .filter(d -> filterDecl(d, validNames))
+                .toArray(Declaration[]::new);
+        return Declaration.toplevel(decl.pos(), newMembers);
+    }
+
+    private static boolean filterDecl(Declaration d, String... validNames) {
+        if (d.pos() == Position.NO_POSITION) {
+            return false;
+        } else {
+            for (String s : validNames) {
+                String pathName = d.pos().path().toString();
+                if (pathName.contains(s)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/FunctionalInterfaceScanner.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/FunctionalInterfaceScanner.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/FunctionalInterfaceScanner.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.jextract.impl;
+
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Type;
+import jdk.incubator.foreign.FunctionDescriptor;
+
+import java.util.Optional;
+import java.util.Set;
+
+class FunctionalInterfaceScanner implements Declaration.Visitor<Void, Set<FunctionDescriptor>> {
+
+    private final Set<FunctionDescriptor> descriptors;
+
+    FunctionalInterfaceScanner(Set<FunctionDescriptor> descriptors) {
+        this.descriptors = descriptors;
+    }
+
+    Declaration.Scoped scan(Declaration.Scoped decl) {
+        decl.accept(this, descriptors);
+        return decl;
+    }
+
+    void scanType(Type t, Set<FunctionDescriptor> functionDescriptors) {
+        t.accept(new TypeScanner(), functionDescriptors);
+    }
+
+    @Override
+    public Void visitScoped(Declaration.Scoped d, Set<FunctionDescriptor> functionDescriptors) {
+        d.members().forEach(m -> m.accept(this, functionDescriptors));
+        return null;
+    }
+
+    @Override
+    public Void visitFunction(Declaration.Function d, Set<FunctionDescriptor> functionDescriptors) {
+        scanType(d.type().returnType(), functionDescriptors);
+        d.parameters().forEach(p -> p.accept(this, functionDescriptors));
+        return null;
+    }
+
+    @Override
+    public Void visitVariable(Declaration.Variable d, Set<FunctionDescriptor> functionDescriptors) {
+        scanType(d.type(), functionDescriptors);
+        return null;
+    }
+
+    @Override
+    public Void visitConstant(Declaration.Constant d, Set<FunctionDescriptor> functionDescriptors) {
+        scanType(d.type(), functionDescriptors);
+        return null;
+    }
+
+    static class TypeScanner implements Type.Visitor<Void, Set<FunctionDescriptor>> {
+
+        @Override
+        public Void visitPrimitive(Type.Primitive t, Set<FunctionDescriptor> functionDescriptors) {
+            return null;
+        }
+
+        @Override
+        public Void visitDelegated(Type.Delegated t, Set<FunctionDescriptor> functionDescriptors) {
+            return t.type().accept(this, functionDescriptors);
+        }
+
+        @Override
+        public Void visitFunction(Type.Function t, Set<FunctionDescriptor> functionDescriptors) {
+            t.returnType().accept(this, functionDescriptors);
+            t.argumentTypes().forEach(a -> a.accept(this, functionDescriptors));
+            Optional<FunctionDescriptor> descriptor = Type.descriptorFor(t);
+            if (descriptor.isPresent()) {
+                functionDescriptors.add(descriptor.get());
+            }
+            return null;
+        }
+
+        @Override
+        public Void visitDeclared(Type.Declared t, Set<FunctionDescriptor> functionDescriptors) {
+            return null;
+        }
+
+        @Override
+        public Void visitArray(Type.Array t, Set<FunctionDescriptor> functionDescriptors) {
+            return t.elementType().accept(this, functionDescriptors);
+        }
+
+        @Override
+        public Void visitType(Type t, Set<FunctionDescriptor> functionDescriptors) {
+            throw new UnsupportedOperationException();
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/HeaderBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/HeaderBuilder.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/HeaderBuilder.java
@@ -0,0 +1,187 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.jextract.impl;
+
+import jdk.incubator.foreign.Addressable;
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.jextract.Type;
+
+import java.lang.invoke.MethodType;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A helper class to generate header interface class in source form.
+ * After aggregating various constituents of a .java source, build
+ * method is called to get overall generated source string.
+ */
+class HeaderBuilder extends JavaSourceBuilder {
+    HeaderBuilder(String className, String pkgName, ConstantHelper constantHelper) {
+        super(className, pkgName, constantHelper);
+    }
+
+    void addFunctionalInterface(String name, MethodType mtype,  FunctionDescriptor fDesc) {
+        incrAlign();
+        indent();
+        sb.append("public interface " + name + " {\n");
+        incrAlign();
+        indent();
+        sb.append(mtype.returnType().getName() + " apply(");
+        String delim = "";
+        for (int i = 0 ; i < mtype.parameterCount(); i++) {
+            sb.append(delim + mtype.parameterType(i).getName() + " x" + i);
+            delim = ", ";
+        }
+        sb.append(");\n");
+        addFunctionalFactory(name, mtype, fDesc);
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+        indent();
+    }
+
+    void addStaticFunctionWrapper(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS + mtype.returnType().getName() + " " + javaName + " (");
+        String delim = "";
+        List<String> pExprs = new ArrayList<>();
+        final int numParams = paramNames.size();
+        for (int i = 0 ; i < numParams; i++) {
+            String pName = paramNames.get(i);
+            if (pName.isEmpty()) {
+                pName = "x" + i;
+            }
+            if (mtype.parameterType(i).equals(MemoryAddress.class)) {
+                pExprs.add(pName + ".address()");
+            } else {
+                pExprs.add(pName);
+            }
+            Class<?> pType = mtype.parameterType(i);
+            if (pType.equals(MemoryAddress.class)) {
+                pType = Addressable.class;
+            }
+            sb.append(delim + pType.getName() + " " + pName);
+            delim = ", ";
+        }
+        if (varargs) {
+            String lastArg = "x" + numParams;
+            if (numParams > 0) {
+                sb.append(", ");
+            }
+            sb.append("Object... " + lastArg);
+            pExprs.add(lastArg);
+        }
+        sb.append(") {\n");
+        incrAlign();
+        indent();
+        sb.append("try {\n");
+        incrAlign();
+        indent();
+        if (!mtype.returnType().equals(void.class)) {
+            sb.append("return (" + mtype.returnType().getName() + ")");
+        }
+        sb.append(methodHandleGetCallString(javaName, nativeName, mtype, desc, varargs) + ".invokeExact(" + String.join(", ", pExprs) + ");\n");
+        decrAlign();
+        indent();
+        sb.append("} catch (Throwable ex) {\n");
+        incrAlign();
+        indent();
+        sb.append("throw new AssertionError(ex);\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    void emitPrimitiveTypedef(Type.Primitive primType, String name) {
+        Type.Primitive.Kind kind = primType.kind();
+        if (primitiveKindSupported(kind) && !kind.layout().isEmpty()) {
+            incrAlign();
+            indent();
+            sb.append(PUB_MODS);
+            sb.append("ValueLayout ");
+            sb.append(name);
+            sb.append(" = ");
+            sb.append(TypeTranslator.typeToLayoutName(kind));
+            sb.append(";\n");
+            decrAlign();
+        }
+    }
+
+    private boolean primitiveKindSupported(Type.Primitive.Kind kind) {
+        return switch(kind) {
+            case Short, Int, Long, LongLong, Float, Double, LongDouble, Char -> true;
+            default -> false;
+        };
+    }
+
+    void emitTypedef(String className, String superClassName) {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS);
+        sb.append("class ");
+        sb.append(className);
+        sb.append(" extends ");
+        sb.append(superClassName);
+        sb.append(" {\n");
+        incrAlign();
+        indent();
+        // private constructor
+        sb.append("private ");
+        sb.append(className);
+        sb.append("() {}\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    private void addFunctionalFactory(String className, MethodType mtype, FunctionDescriptor fDesc) {
+        indent();
+        sb.append(PUB_MODS + "MemorySegment allocate(" + className + " fi) {\n");
+        incrAlign();
+        indent();
+        sb.append("return RuntimeHelper.upcallStub(" + className + ".class, fi, " + functionGetCallString(className, fDesc) + ", " +
+                "\"" + mtype.toMethodDescriptorString() + "\");\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+
+        indent();
+        sb.append(PUB_MODS + "MemorySegment allocate(" + className + " fi, NativeScope scope) {\n");
+        incrAlign();
+        indent();
+        sb.append("return scope.register(allocate(fi));\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/JavaSourceBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/JavaSourceBuilder.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/JavaSourceBuilder.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.jextract.impl;
+
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.MemoryLayout;
+
+import javax.tools.JavaFileObject;
+import java.lang.constant.ClassDesc;
+import java.lang.constant.DirectMethodHandleDesc;
+import java.lang.invoke.MethodType;
+
+/**
+ * Superclass for .java source generator classes.
+ */
+abstract class JavaSourceBuilder {
+    static final String PUB_CLS_MODS = "public final ";
+    static final String PUB_MODS = "public static ";
+    protected final String className;
+    protected final String pkgName;
+    protected final ConstantHelper constantHelper;
+    // buffer
+    protected final StringBuffer sb;
+    // current line alignment (number of 4-spaces)
+    private int align;
+
+    JavaSourceBuilder(String className, String pkgName, ConstantHelper constantHelper, int align) {
+        this.className = className;
+        this.pkgName = pkgName;
+        this.constantHelper = constantHelper;
+        this.align = align;
+        this.sb = new StringBuffer();
+    }
+
+    JavaSourceBuilder(String className, String pkgName, ConstantHelper constantHelper) {
+        this(className, pkgName, constantHelper, 0);
+    }
+
+    protected String getClassModifiers() {
+        return PUB_CLS_MODS;
+    }
+
+    void classBegin() {
+        addPackagePrefix();
+        addImportSection();
+
+        indent();
+        sb.append(getClassModifiers());
+        sb.append("class ");
+        sb.append(className);
+        sb.append(" {\n\n");
+        emitConstructor();
+    }
+
+    void emitConstructor() {
+        incrAlign();
+        indent();
+        sb.append("private ");
+        sb.append(className);
+        sb.append("() {}");
+        sb.append('\n');
+        decrAlign();
+    }
+
+    void classEnd() {
+        indent();
+        sb.append("}\n\n");
+    }
+
+    String getSource() {
+        return sb.toString();
+    }
+
+    void addContent(String src) {
+        sb.append(src);
+    }
+
+    JavaFileObject build() {
+        String res = sb.toString();
+        this.sb.delete(0, res.length());
+        return Utils.fileFromString(pkgName, className, res);
+    }
+
+    void addLayoutGetter(String javaName, MemoryLayout layout) {
+        emitForwardGetter(constantHelper.addLayout(javaName, layout));
+    }
+
+    void addVarHandleGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        emitForwardGetter(constantHelper.addVarHandle(javaName, nativeName, layout, type, parentLayout));
+    }
+
+    void addMethodHandleGetter(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {
+        emitForwardGetter(constantHelper.addMethodHandle(javaName, nativeName, mtype, desc, varargs));
+    }
+
+    void addAddressGetter(String javaName, String nativeName, MemoryLayout layout, MemoryLayout parentLayout) {
+        emitForwardGetter(constantHelper.addAddress(javaName, nativeName, layout));
+    }
+
+    void addConstantGetter(String javaName, Class<?> type, Object value) {
+        emitForwardGetter(constantHelper.addConstant(javaName, type, value));
+    }
+
+    void addGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS + type.getName() + " " + javaName + "$get() {\n");
+        incrAlign();
+        indent();
+        String vhParam = addressGetCallString(javaName, nativeName, layout);
+        sb.append("return (" + type.getName() + ")"
+                + varHandleGetCallString(javaName, nativeName, layout, type, null) + ".get(" + vhParam + ");\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    void addSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS + "void " + javaName + "$set(" + type.getName() + " x) {\n");
+        incrAlign();
+        indent();
+        String vhParam = addressGetCallString(javaName, nativeName, layout);
+        sb.append(varHandleGetCallString(javaName, nativeName, layout, type, null) + ".set(" + vhParam + ", x);\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    // Utility
+
+    protected void addPackagePrefix() {
+        assert pkgName.indexOf('/') == -1 : "package name invalid: " + pkgName;
+        sb.append("// Generated by jextract\n\n");
+        if (!pkgName.isEmpty()) {
+            sb.append("package ");
+            sb.append(pkgName);
+            sb.append(";\n\n");
+        }
+    }
+
+    protected void addImportSection() {
+        sb.append("import java.lang.invoke.MethodHandle;\n");
+        sb.append("import java.lang.invoke.VarHandle;\n");
+        sb.append("import jdk.incubator.foreign.*;\n");
+        sb.append("import jdk.incubator.foreign.MemoryLayout.PathElement;\n");
+        sb.append("import static ");
+        sb.append(OutputFactory.C_LANG_CONSTANTS_HOLDER);
+        sb.append(".*;\n");
+    }
+
+    protected void emitForwardGetter(DirectMethodHandleDesc desc) {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS + displayName(desc.invocationType().returnType()) + " " + desc.methodName() + "() {\n");
+        incrAlign();
+        indent();
+        sb.append("return " + getCallString(desc) + ";\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    protected String getCallString(DirectMethodHandleDesc desc) {
+        return desc.owner().displayName() + "." + desc.methodName() + "()";
+    }
+
+    protected String displayName(ClassDesc returnType) {
+        return returnType.displayName(); // TODO shorten based on imports
+    }
+
+    protected String functionGetCallString(String javaName, FunctionDescriptor fDesc) {
+        return getCallString(constantHelper.addFunctionDesc(javaName, fDesc));
+    }
+
+    protected String methodHandleGetCallString(String javaName, String nativeName, MethodType mt, FunctionDescriptor fDesc, boolean varargs) {
+        return getCallString(constantHelper.addMethodHandle(javaName, nativeName, mt, fDesc, varargs));
+    }
+
+    protected String varHandleGetCallString(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        return getCallString(constantHelper.addVarHandle(javaName, nativeName, layout, type, parentLayout));
+    }
+
+    protected String addressGetCallString(String javaName, String nativeName, MemoryLayout layout) {
+        return getCallString(constantHelper.addAddress(javaName, nativeName, layout));
+    }
+
+    protected void indent() {
+        for (int i = 0; i < align; i++) {
+            sb.append("    ");
+        }
+    }
+
+    protected void incrAlign() {
+        align++;
+    }
+
+    protected void decrAlign() {
+        align--;
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/JextractTaskImpl.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/JextractTaskImpl.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/JextractTaskImpl.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- *  This code is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 only, as
- *  published by the Free Software Foundation.  Oracle designates this
- *  particular file as subject to the "Classpath" exception as provided
- *  by Oracle in the LICENSE file that accompanied this code.
- *
- *  This code is distributed in the hope that it will be useful, but WITHOUT
- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- *  version 2 for more details (a copy is included in the LICENSE file that
- *  accompanied this code).
- *
- *  You should have received a copy of the GNU General Public License version
- *  2 along with this work; if not, write to the Free Software Foundation,
- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- *  or visit www.oracle.com if you need additional information or have any
- *  questions.
- *
- */
-
-package jdk.internal.jextract.impl;
-
-import jdk.incubator.jextract.Declaration;
-import jdk.incubator.jextract.JextractTask;
-
-import javax.tools.JavaFileObject;
-import java.io.IOException;
-import java.io.UncheckedIOException;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.util.List;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-
-public class JextractTaskImpl implements JextractTask {
-
-    private final boolean compileSources;
-    private final List<Path> headers;
-    static final boolean VERBOSE = Boolean.getBoolean("jextract.verbose");
-
-    public JextractTaskImpl(boolean compileSources, Path... headers) {
-        this.compileSources = compileSources;
-        this.headers = Stream.of(headers).collect(Collectors.toList());
-    }
-
-    @Override
-    public Declaration.Scoped parse(String... options) {
-        return parse(null, options);
-    }
-
-    @Override
-    public Declaration.Scoped parse(JextractTask.ConstantParser constantParser, String... options) {
-        Path source = headers.size() > 1? generateTmpSource() : headers.iterator().next();
-        return new Parser(constantParser).parse(source, Stream.of(options).collect(Collectors.toList()));
-    }
-
-    @Override
-    public void write(Path dest, JavaFileObject... files) {
-        try {
-            new Writer(dest, Stream.of(files).collect(Collectors.toList())).writeAll(compileSources);
-        } catch (IOException ex) {
-            throw new UncheckedIOException(ex);
-        }
-    }
-
-    private Path generateTmpSource() {
-        assert headers.size() > 1;
-        try {
-            Path tmpFile = Files.createTempFile("jextract", ".h");
-            tmpFile.toFile().deleteOnExit();
-            Files.write(tmpFile, headers.stream().
-                map(src -> "#include \"" + src + "\"").
-                collect(Collectors.toList()));
-            return tmpFile;
-        } catch (IOException ioExp) {
-            throw new UncheckedIOException(ioExp);
-        }
-    }
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/MacroParserImpl.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/MacroParserImpl.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/MacroParserImpl.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/MacroParserImpl.java
@@ -25,14 +25,13 @@
  */
 
 package jdk.internal.jextract.impl;
 
 import jdk.incubator.jextract.Declaration;
-import jdk.incubator.jextract.JextractTask;
 import jdk.incubator.jextract.Position;
 import jdk.incubator.jextract.Type;
-import jdk.incubator.jextract.tool.Main;
+import jdk.incubator.jextract.JextractTool;
 import jdk.internal.clang.Cursor;
 import jdk.internal.clang.CursorKind;
 import jdk.internal.clang.Diagnostic;
 import jdk.internal.clang.EvalResult;
 import jdk.internal.clang.Index;
@@ -48,11 +47,11 @@
 import java.util.Map;
 import java.util.Optional;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
-class MacroParserImpl implements JextractTask.ConstantParser {
+class MacroParserImpl {
 
     private final ClangReparser reparser;
     private final TreeMaker treeMaker;
     final MacroTable macroTable;
 
@@ -60,11 +59,11 @@
         this.reparser = reparser;
         this.treeMaker = treeMaker;
         this.macroTable = new MacroTable();
     }
 
-    public static MacroParserImpl make(TreeMaker treeMaker, TranslationUnit tu, Collection<String> args) {
+    static MacroParserImpl make(TreeMaker treeMaker, TranslationUnit tu, Collection<String> args) {
         ClangReparser reparser;
         try {
             reparser = new ClangReparser(tu, args);
         } catch (IOException | Index.ParsingFailedException ex) {
             throw new RuntimeException(ex);
@@ -77,12 +76,11 @@
      * This method attempts to evaluate the macro. Evaluation occurs in two steps: first, an attempt is made
      * to see if the macro corresponds to a simple numeric constant. If so, the constant is parsed in Java directly.
      * If that is not possible (e.g. because the macro refers to other macro, or has a more complex grammar), fall
      * back to use clang evaluation support.
      */
-    @Override
-    public Optional<Declaration.Constant> parseConstant(Position pos, String name, String[] tokens) {
+    Optional<Declaration.Constant> parseConstant(Position pos, String name, String[] tokens) {
         if (!(pos instanceof TreeMaker.CursorPosition)) {
             return Optional.empty();
         } else {
             Cursor cursor = ((TreeMaker.CursorPosition)pos).cursor();
             if (cursor.isMacroFunctionLike()) {
@@ -137,11 +135,11 @@
                     false, //add serialization support (needed for macros)
                     patchedArgs);
         }
 
         void processDiagnostics(Diagnostic diag) {
-            if (Main.DEBUG) {
+            if (JextractTool.DEBUG) {
                 System.err.println("Error while processing macro: " + diag.spelling());
             }
         }
 
         public Stream<Cursor> reparse(String snippet) {
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Options.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Options.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Options.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.jextract.impl;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public final class Options {
+    // The args for parsing C
+    public final List<String> clangArgs;
+    // The list of library names
+    public final List<String> libraryNames;
+    public final List<String> filters;
+    // target package
+    public final String targetPackage;
+    // output directory
+    public final String outputDir;
+    public final boolean source;
+
+    private Options(List<String> clangArgs, List<String> libraryNames,
+            List<String> filters, String targetPackage,
+            String outputDir, boolean source) {
+        this.clangArgs = clangArgs;
+        this.libraryNames = libraryNames;
+        this.filters = filters;
+        this.targetPackage = targetPackage;
+        this.outputDir = outputDir;
+        this.source = source;
+    }
+
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    public static Options createDefault() {
+        return builder().build();
+    }
+
+    public static class Builder {
+        private final List<String> clangArgs;
+        private final List<String> libraryNames;
+        private final List<String> filters;
+        private String targetPackage;
+        private String outputDir;
+        private boolean source;
+
+        public Builder() {
+            this.clangArgs = new ArrayList<>();
+            this.libraryNames = new ArrayList<>();
+            this.filters = new ArrayList<>();
+            this.targetPackage = "";
+            this.outputDir = ".";
+            this.source = false;
+        }
+
+        public Options build() {
+            return new Options(
+                    Collections.unmodifiableList(clangArgs),
+                    Collections.unmodifiableList(libraryNames),
+                    Collections.unmodifiableList(filters),
+                    targetPackage, outputDir, source
+            );
+        }
+
+        public void addClangArg(String arg) {
+            clangArgs.add(arg);
+        }
+
+        public void addLibraryName(String name) {
+            libraryNames.add(name);
+        }
+
+        public void setOutputDir(String outputDir) {
+            this.outputDir = outputDir;
+        }
+
+        public void setTargetPackage(String pkg) {
+            this.targetPackage = pkg;
+        }
+
+        public void addFilter(String filter) {
+            filters.add(filter);
+        }
+
+        public void setGenerateSource() {
+            source = true;
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/OutputFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/OutputFactory.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/OutputFactory.java
@@ -0,0 +1,421 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.jextract.impl;
+
+import jdk.incubator.foreign.*;
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Type;
+import jdk.incubator.jextract.Type.Primitive;
+
+import javax.tools.JavaFileObject;
+import javax.tools.SimpleJavaFileObject;
+import java.io.IOException;
+import java.io.UncheckedIOException;
+import java.lang.constant.ClassDesc;
+import java.lang.invoke.MethodType;
+import java.net.URI;
+import java.net.URL;
+import java.net.URISyntaxException;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+/*
+ * Scan a header file and generate Java source items for entities defined in that header
+ * file. Tree visitor visit methods return true/false depending on whether a
+ * particular Tree is processed or skipped.
+ */
+public class OutputFactory implements Declaration.Visitor<Void, Declaration> {
+    private final Set<String> constants = new HashSet<>();
+    // To detect duplicate Variable and Function declarations.
+    private final Set<Declaration.Variable> variables = new HashSet<>();
+    private final Set<Declaration.Function> functions = new HashSet<>();
+
+    protected final HeaderBuilder builder;
+    protected final ConstantHelper constantHelper;
+    protected final TypeTranslator typeTranslator = new TypeTranslator();
+    private final String clsName;
+    private final String pkgName;
+    private StructBuilder structBuilder;
+    private Map<Declaration, String> structClassNames = new HashMap<>();
+    private List<String> structSources = new ArrayList<>();
+    private Set<String> nestedClassNames = new HashSet<>();
+    private Set<Declaration.Typedef> unresolvedStructTypedefs = new HashSet<>();
+    private int nestedClassNameCount = 0;
+    /*
+     * We may have case-insensitive name collision! A C program may have
+     * defined structs/unions/typedefs with the names FooS, fooS, FoOs, fOOs.
+     * Because we map structs/unions/typedefs to nested classes of header classes,
+     * such a case-insensitive name collision is problematic. This is because in
+     * a case-insensitive file system javac will overwrite classes for
+     * Header$CFooS, Header$CfooS, Header$CFoOs and so on! We solve this by
+     * generating unique case-insensitive names for nested classes.
+     */
+    private String uniqueNestedClassName(String name) {
+        name = Utils.javaSafeIdentifier(name);
+        return nestedClassNames.add(name.toLowerCase())? name : (name + "$" + nestedClassNameCount++);
+    }
+
+    private String structClassName(Declaration decl) {
+        return structClassNames.computeIfAbsent(decl, d -> uniqueNestedClassName(d.name()));
+    }
+
+    private boolean structDefinitionSeen(Declaration decl) {
+        return structClassNames.containsKey(decl);
+    }
+
+    // have we seen this Variable earlier?
+    protected boolean variableSeen(Declaration.Variable tree) {
+        return !variables.add(tree);
+    }
+
+    // have we seen this Function earlier?
+    protected boolean functionSeen(Declaration.Function tree) {
+        return !functions.add(tree);
+    }
+
+    public static JavaFileObject[] generateWrapped(Declaration.Scoped decl, String headerName, String pkgName, List<String> libraryNames) {
+        String clsName = Utils.javaSafeIdentifier(headerName.replace(".h", "_h"), true);
+        String qualName = pkgName.isEmpty() ? clsName : pkgName + "." + clsName;
+        ConstantHelper constantHelper = new ConstantHelper(qualName,
+                ClassDesc.of(pkgName, "RuntimeHelper"), ClassDesc.of("jdk.incubator.foreign", "CSupport"),
+                libraryNames.toArray(String[]::new));
+        return new OutputFactory(clsName, pkgName,
+                new HeaderBuilder(clsName, pkgName, constantHelper), constantHelper).generate(decl);
+    }
+
+    private OutputFactory(String clsName, String pkgName, HeaderBuilder builder, ConstantHelper constantHelper) {
+        this.clsName = clsName;
+        this.pkgName = pkgName;
+        this.builder = builder;
+        this.constantHelper = constantHelper;
+    }
+
+    private static String getCLangConstantsHolder() {
+        String prefix = "jdk.incubator.foreign.CSupport.";
+        String abi = CSupport.getSystemLinker().name();
+        switch (abi) {
+            case CSupport.SysV.NAME:
+                return prefix + "SysV";
+            case CSupport.Win64.NAME:
+                return prefix + "Win64";
+            case CSupport.AArch64.NAME:
+                return prefix + "AArch64";
+            default:
+                throw new UnsupportedOperationException("Unsupported ABI: " + abi);
+        }
+    }
+
+    static final String C_LANG_CONSTANTS_HOLDER = getCLangConstantsHolder();
+
+    JavaFileObject[] generate(Declaration.Scoped decl) {
+        builder.classBegin();
+        //generate all decls
+        decl.members().forEach(this::generateDecl);
+        for (String src : structSources) {
+            builder.addContent(src);
+        }
+        // check if unresolved typedefs can be resolved now!
+        for (Declaration.Typedef td : unresolvedStructTypedefs) {
+            Declaration.Scoped structDef = ((Type.Declared)td.type()).tree();
+            if (structDefinitionSeen(structDef)) {
+                builder.emitTypedef(uniqueNestedClassName(td.name()), structClassName(structDef));
+            }
+        }
+        builder.classEnd();
+        try {
+            List<JavaFileObject> files = new ArrayList<>();
+            files.add(builder.build());
+            files.addAll(constantHelper.getClasses());
+            files.add(fileFromString(pkgName,"RuntimeHelper", getRuntimeHelperSource()));
+            return files.toArray(new JavaFileObject[0]);
+        } catch (IOException ex) {
+            throw new UncheckedIOException(ex);
+        } catch (URISyntaxException ex2) {
+            throw new RuntimeException(ex2);
+        }
+    }
+
+    private String getRuntimeHelperSource() throws URISyntaxException, IOException {
+        URL runtimeHelper = OutputFactory.class.getResource("resources/RuntimeHelper.java.template");
+        return (pkgName.isEmpty()? "" : "package " + pkgName + ";\n") +
+                        String.join("\n", Files.readAllLines(Paths.get(runtimeHelper.toURI())))
+                                .replace("${C_LANG}", C_LANG_CONSTANTS_HOLDER);
+    }
+
+    private void generateDecl(Declaration tree) {
+        try {
+            tree.accept(this, null);
+        } catch (Exception ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    private static Class<?> classForType(Primitive.Kind type, MemoryLayout layout) {
+        boolean isFloat = switch(type) {
+            case Float, Double, LongDouble -> true;
+            default-> false;
+        };
+        return TypeTranslator.layoutToClass(isFloat, layout);
+    }
+
+    private JavaFileObject fileFromString(String pkgName, String clsName, String contents) {
+        String pkgPrefix = pkgName.isEmpty() ? "" : pkgName.replaceAll("\\.", "/") + "/";
+        return new SimpleJavaFileObject(URI.create(pkgPrefix + clsName + ".java"), JavaFileObject.Kind.SOURCE) {
+            @Override
+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
+                return contents;
+            }
+        };
+    }
+
+    @Override
+    public Void visitConstant(Declaration.Constant constant, Declaration parent) {
+        if (!constants.add(constant.name())) {
+            //skip
+            return null;
+        }
+
+        builder.addConstantGetter(Utils.javaSafeIdentifier(constant.name()),
+                constant.value() instanceof String ? MemorySegment.class :
+                typeTranslator.getJavaType(constant.type()), constant.value());
+        return null;
+    }
+
+    @Override
+    public Void visitScoped(Declaration.Scoped d, Declaration parent) {
+        if (d.layout().isEmpty()) {
+            //skip decl-only
+            return null;
+        }
+        boolean structClass = false;
+        StructBuilder oldStructBuilder = this.structBuilder;
+        if (!d.name().isEmpty() || !isRecord(parent)) {
+            //only add explicit struct layout if the struct is not to be flattened inside another struct
+            switch (d.kind()) {
+                case STRUCT:
+                case UNION: {
+                    structClass = true;
+                    String className = structClassName(d.name().isEmpty() ? parent : d);
+                    this.structBuilder = new StructBuilder(className, pkgName, constantHelper);
+                    structBuilder.incrAlign();
+                    structBuilder.classBegin();
+                    structBuilder.addLayoutGetter(className, d.layout().get());
+                    break;
+                }
+            }
+        }
+        d.members().forEach(fieldTree -> fieldTree.accept(this, d.name().isEmpty() ? parent : d));
+        if (structClass) {
+            this.structBuilder.classEnd();
+            structSources.add(structBuilder.getSource());
+            this.structBuilder = oldStructBuilder;
+        }
+        return null;
+    }
+
+    @Override
+    public Void visitFunction(Declaration.Function funcTree, Declaration parent) {
+        if (functionSeen(funcTree)) {
+            return null;
+        }
+
+        MethodType mtype = typeTranslator.getMethodType(funcTree.type());
+        FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);
+        if (descriptor == null) {
+            //abort
+            return null;
+        }
+        String mhName = Utils.javaSafeIdentifier(funcTree.name());
+        builder.addMethodHandleGetter(mhName, funcTree.name(), mtype, descriptor, funcTree.type().varargs());
+        //generate static wrapper for function
+        List<String> paramNames = funcTree.parameters()
+                                          .stream()
+                                          .map(Declaration.Variable::name)
+                                          .map(p -> !p.isEmpty() ? Utils.javaSafeIdentifier(p) : p)
+                                          .collect(Collectors.toList());
+        builder.addStaticFunctionWrapper(Utils.javaSafeIdentifier(funcTree.name()), funcTree.name(), mtype,
+                Type.descriptorFor(funcTree.type()).orElseThrow(), funcTree.type().varargs(), paramNames);
+        int i = 0;
+        for (Declaration.Variable param : funcTree.parameters()) {
+            Type.Function f = getAsFunctionPointer(param.type());
+            if (f != null) {
+                String name = funcTree.name() + "$" + (param.name().isEmpty() ? "x" + i : param.name());
+                name = Utils.javaSafeIdentifier(name);
+                //generate functional interface
+                if (f.varargs()) {
+                    System.err.println("WARNING: varargs in callbacks is not supported");
+                }
+                MethodType fitype = typeTranslator.getMethodType(f, false);
+                builder.addFunctionalInterface(name, fitype, Type.descriptorFor(f).orElseThrow());
+                i++;
+            }
+        }
+        return null;
+    }
+
+    Type.Function getAsFunctionPointer(Type type) {
+        if (type instanceof Type.Delegated) {
+            switch (((Type.Delegated) type).kind()) {
+                case POINTER: {
+                    Type pointee = ((Type.Delegated) type).type();
+                    return (pointee instanceof Type.Function) ?
+                        (Type.Function)pointee : null;
+                }
+                default:
+                    return getAsFunctionPointer(((Type.Delegated) type).type());
+            }
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public Void visitTypedef(Declaration.Typedef tree, Declaration parent) {
+        Type type = tree.type();
+        if (type instanceof Type.Declared) {
+            Declaration.Scoped s = ((Type.Declared) type).tree();
+            if (!s.name().equals(tree.name())) {
+                switch (s.kind()) {
+                    case STRUCT:
+                    case UNION: {
+                        if (s.name().isEmpty()) {
+                            visitScoped(s, tree);
+                        } else {
+                            /*
+                             * If typedef is seen after the struct/union definition, we can generate subclass
+                             * right away. If not, we've to save it and revisit after all the declarations are
+                             * seen. This is to support forward declaration of typedefs.
+                             *
+                             * typedef struct Foo Bar;
+                             *
+                             * struct Foo {
+                             *     int x, y;
+                             * };
+                             */
+                            if (structDefinitionSeen(s)) {
+                                builder.emitTypedef(uniqueNestedClassName(tree.name()), structClassName(s));
+                            } else {
+                                /*
+                                 * Definition of typedef'ed struct/union not seen yet. May be the definition comes later.
+                                 * Save it to visit at the end of all declarations.
+                                 */
+                                unresolvedStructTypedefs.add(tree);
+                            }
+                        }
+                    }
+                    break;
+                    default:
+                        visitScoped(s, tree);
+                }
+            }
+        } else if (type instanceof Type.Primitive) {
+             builder.emitPrimitiveTypedef((Type.Primitive)type, uniqueNestedClassName(tree.name()));
+        }
+        return null;
+    }
+
+    @Override
+    public Void visitVariable(Declaration.Variable tree, Declaration parent) {
+        if (parent == null && variableSeen(tree)) {
+            return null;
+        }
+
+        String fieldName = tree.name();
+        String symbol = tree.name();
+        assert !symbol.isEmpty();
+        assert !fieldName.isEmpty();
+        fieldName = Utils.javaSafeIdentifier(fieldName);
+
+        Type type = tree.type();
+        MemoryLayout layout = tree.layout().orElse(Type.layoutFor(type).orElse(null));
+        if (layout == null) {
+            //no layout - abort
+            return null;
+        }
+        Class<?> clazz = typeTranslator.getJavaType(type);
+        if (tree.kind() == Declaration.Variable.Kind.BITFIELD ||
+                (layout instanceof ValueLayout && layout.byteSize() > 8)) {
+            //skip
+            return null;
+        }
+
+        boolean isSegment = clazz == MemorySegment.class;
+        MemoryLayout treeLayout = tree.layout().orElseThrow();
+        if (parent != null) { //struct field
+            MemoryLayout parentLayout = parentLayout(parent);
+            if (isSegment) {
+                structBuilder.addAddressGetter(fieldName, tree.name(), treeLayout, parentLayout);
+            } else {
+                structBuilder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
+                structBuilder.addGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
+                structBuilder.addSetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
+            }
+        } else {
+            if (isSegment) {
+                builder.addAddressGetter(fieldName, tree.name(), treeLayout, null);
+            } else {
+                builder.addLayoutGetter(fieldName, layout);
+                builder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz,null);
+                builder.addAddressGetter(fieldName, tree.name(), treeLayout, null);
+                builder.addGetter(fieldName, tree.name(), treeLayout, clazz, null);
+                builder.addSetter(fieldName, tree.name(), treeLayout, clazz, null);
+            }
+        }
+
+        return null;
+    }
+
+    private boolean isRecord(Declaration declaration) {
+        if (declaration == null) {
+            return false;
+        } else if (!(declaration instanceof Declaration.Scoped)) {
+            return false;
+        } else {
+            Declaration.Scoped scope = (Declaration.Scoped)declaration;
+            return scope.kind() == Declaration.Scoped.Kind.CLASS ||
+                    scope.kind() == Declaration.Scoped.Kind.STRUCT ||
+                    scope.kind() == Declaration.Scoped.Kind.UNION;
+        }
+    }
+
+    protected static MemoryLayout parentLayout(Declaration parent) {
+        if (parent instanceof Declaration.Typedef) {
+            Declaration.Typedef alias = (Declaration.Typedef) parent;
+            return Type.layoutFor(alias.type()).orElseThrow();
+        } else if (parent instanceof Declaration.Scoped) {
+            return ((Declaration.Scoped) parent).layout().orElseThrow();
+        } else {
+            throw new IllegalArgumentException("Unexpected parent declaration");
+        }
+        // case like `typedef struct { ... } Foo`
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Parser.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Parser.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Parser.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Parser.java
@@ -24,13 +24,10 @@
  *
  */
 package jdk.internal.jextract.impl;
 
 import jdk.incubator.jextract.Declaration;
-import jdk.incubator.jextract.JextractTask;
-import jdk.incubator.jextract.Position;
-import jdk.incubator.jextract.Type;
 import jdk.internal.clang.Cursor;
 import jdk.internal.clang.CursorKind;
 import jdk.internal.clang.Diagnostic;
 import jdk.internal.clang.Index;
 import jdk.internal.clang.LibClang;
@@ -39,23 +36,18 @@
 import jdk.internal.clang.TranslationUnit;
 
 import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
 import java.util.List;
-import java.util.Map;
 import java.util.Optional;
 
-class Parser {
+public class Parser {
     private final TreeMaker treeMaker;
-    private final JextractTask.ConstantParser constantParser;
 
-    public Parser(JextractTask.ConstantParser constantParser) {
+    public Parser() {
         this.treeMaker = new TreeMaker();
-        this.constantParser = constantParser;
     }
 
     public Declaration.Scoped parse(Path path, Collection<String> args) {
         final Index index = LibClang.createIndex(false);
 
@@ -65,12 +57,11 @@
                     throw new RuntimeException(d.toString());
                 }
             },
             true, args.toArray(new String[0]));
 
-        JextractTask.ConstantParser constantParser = this.constantParser != null ?
-                this.constantParser : MacroParserImpl.make(treeMaker, tu, args);
+        MacroParserImpl macroParser = MacroParserImpl.make(treeMaker, tu, args);
 
         List<Declaration> decls = new ArrayList<>();
         Cursor tuCursor = tu.getCursor();
         tuCursor.children().
             forEach(c -> {
@@ -98,20 +89,18 @@
                         }
                     }
                 } else if (isMacro(c) && src.path() != null) {
                     SourceRange range = c.getExtent();
                     String[] tokens = c.getTranslationUnit().tokens(range);
-                    Optional<Declaration.Constant> constant = constantParser.parseConstant(treeMaker.toPos(c), c.spelling(), tokens);
+                    Optional<Declaration.Constant> constant = macroParser.parseConstant(treeMaker.toPos(c), c.spelling(), tokens);
                     if (constant.isPresent()) {
                         decls.add(constant.get());
                     }
                 }
             });
 
-        if (constantParser instanceof MacroParserImpl) {
-            decls.addAll(((MacroParserImpl)constantParser).macroTable.reparseConstants());
-        }
+        decls.addAll(macroParser.macroTable.reparseConstants());
         Declaration.Scoped rv = treeMaker.createHeader(tuCursor, decls);
         treeMaker.freeze();
         index.close();
         return rv;
     }
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/StructBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/StructBuilder.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/StructBuilder.java
@@ -0,0 +1,208 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.jextract.impl;
+
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+
+/**
+ * This class generates static utilities class for C structs, unions.
+ */
+class StructBuilder extends JavaSourceBuilder {
+    StructBuilder(String className, String pkgName, ConstantHelper constantHelper) {
+        super(className, pkgName, constantHelper);
+    }
+
+    @Override
+    protected String getClassModifiers() {
+        return PUB_MODS;
+    }
+
+    @Override
+    protected void addPackagePrefix() {
+        // nested class. containing class has necessary package declaration
+    }
+
+    @Override
+    protected void addImportSection() {
+        // nested class. containing class has necessary imports
+    }
+
+    @Override
+    void classEnd() {
+        emitSizeof();
+        emitAllocate();
+        emitScopeAllocate();
+        emitAllocateArray();
+        emitScopeAllocateArray();
+        super.classEnd();
+    }
+
+    @Override
+    void addLayoutGetter(String javaName, MemoryLayout layout) {
+        var desc = constantHelper.addLayout(javaName + "$struct", layout);
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS + displayName(desc.invocationType().returnType()) + " $LAYOUT() {\n");
+        incrAlign();
+        indent();
+        sb.append("return " + getCallString(desc) + ";\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    @Override
+    void addGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS + type.getName() + " " + javaName + "$get(MemorySegment addr) {\n");
+        incrAlign();
+        indent();
+        sb.append("return (" + type.getName() + ")"
+                + varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".get(addr);\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+
+        addIndexGetter(javaName, nativeName, layout, type, parentLayout);
+    }
+
+    @Override
+    void addSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        incrAlign();
+        indent();
+        String param = MemorySegment.class.getName() + " addr";
+        sb.append(PUB_MODS + "void " + javaName + "$set(" + param + ", " + type.getName() + " x) {\n");
+        incrAlign();
+        indent();
+        sb.append(varHandleGetCallString(javaName, nativeName, layout, type, null) + ".set(addr, x);\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+
+        addIndexSetter(javaName, nativeName, layout, type, parentLayout);
+    }
+
+    @Override
+    void addAddressGetter(String javaName, String nativeName, MemoryLayout layout, MemoryLayout parentLayout) {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS + "MemorySegment " + javaName + "$addr(MemorySegment addr) {\n");
+        incrAlign();
+        indent();
+        sb.append("return addr.asSlice(");
+        sb.append(parentLayout.byteOffset(MemoryLayout.PathElement.groupElement(nativeName)));
+        sb.append(", ");
+        sb.append(layout.byteSize());
+        sb.append(");\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    private void emitSizeof() {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS);
+        sb.append("long sizeof() { return $LAYOUT().byteSize(); }\n");
+        decrAlign();
+    }
+
+    private void emitAllocate() {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS);
+        sb.append("MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n");
+        decrAlign();
+    }
+
+    private void emitScopeAllocate() {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS);
+        sb.append("MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n");
+        decrAlign();
+    }
+
+    private void emitAllocateArray() {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS);
+        sb.append("MemorySegment allocateArray(int len) {\n");
+        incrAlign();
+        indent();
+        sb.append("return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));");
+        decrAlign();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    private void emitScopeAllocateArray() {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS);
+        sb.append("MemorySegment allocateArray(int len, NativeScope scope) {\n");
+        incrAlign();
+        indent();
+        sb.append("return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));");
+        decrAlign();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    private void addIndexGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        incrAlign();
+        indent();
+        String params = MemorySegment.class.getName() + " addr, long index";
+        sb.append(PUB_MODS + type.getName() + " " + javaName + "$get(" + params + ") {\n");
+        incrAlign();
+        indent();
+        sb.append("return (" + type.getName() + ")"
+                + varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".get(addr.asSlice(index*sizeof()));\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    private void addIndexSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        incrAlign();
+        indent();
+        String params = MemorySegment.class.getName() + " addr, long index, " + type.getName() + " x";
+        sb.append(PUB_MODS + "void " + javaName + "$set(" + params + ") {\n");
+        incrAlign();
+        indent();
+        sb.append(varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".set(addr.asSlice(index*sizeof()), x);\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/TypeTranslator.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TypeTranslator.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/TypeTranslator.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TypeTranslator.java
@@ -21,11 +21,11 @@
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
-package jdk.incubator.jextract;
+package jdk.internal.jextract.impl;
 
 import jdk.incubator.jextract.Type.Primitive;
 import jdk.incubator.jextract.Type;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Utils.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Utils.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Utils.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Utils.java
@@ -33,11 +33,15 @@
 import jdk.internal.clang.SourceLocation;
 import jdk.internal.clang.Type;
 import jdk.internal.clang.TypeKind;
 
 import javax.lang.model.SourceVersion;
+import javax.tools.JavaFileObject;
+import javax.tools.SimpleJavaFileObject;
+import java.io.IOException;
 import java.lang.reflect.Method;
+import java.net.URI;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
@@ -48,11 +52,58 @@
 
 /**
  * General utility functions
  */
 class Utils {
-    public static void validSimpleIdentifier(String name) {
+    private static URI fileName(String pkgName, String clsName, String extension) {
+        String pkgPrefix = pkgName.isEmpty() ? "" : pkgName.replaceAll("\\.", "/") + "/";
+        return URI.create(pkgPrefix + clsName + extension);
+    }
+
+    static JavaFileObject fileFromString(String pkgName, String clsName, String contents) {
+        return new SimpleJavaFileObject(fileName(pkgName, clsName, ".java"), JavaFileObject.Kind.SOURCE) {
+            @Override
+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
+                return contents;
+            }
+        };
+    }
+
+    static String javaSafeIdentifier(String name) {
+        return javaSafeIdentifier(name, false);
+    }
+
+    static String javaSafeIdentifier(String name, boolean checkAllChars) {
+        if (checkAllChars) {
+            StringBuilder buf = new StringBuilder();
+            char[] chars = name.toCharArray();
+            if (Character.isJavaIdentifierStart(chars[0])) {
+                buf.append(chars[0]);
+            } else {
+                buf.append('_');
+            }
+            if (chars.length > 1) {
+                for (int i = 1; i < chars.length; i++) {
+                    char ch = chars[i];
+                    if (Character.isJavaIdentifierPart(ch)) {
+                        buf.append(ch);
+                    } else {
+                        buf.append('_');
+                    }
+                }
+            }
+            return buf.toString();
+        } else {
+            // We never get the problem of Java non-identifiers (like 123, ab-xy) as
+            // C identifiers. But we may have a java keyword used as a C identifier.
+            assert SourceVersion.isIdentifier(name);
+
+            return SourceVersion.isKeyword(name) ? (name + "_") : name;
+        }
+    }
+
+    static void validSimpleIdentifier(String name) {
         int length = name.length();
         if (length == 0) {
             throw new IllegalArgumentException();
         }
 
@@ -71,11 +122,11 @@
                 throw new IllegalArgumentException("Invalid character for an identifier: " + ch);
             }
         }
     }
 
-    public static void validPackageName(String name) {
+    static void validPackageName(String name) {
         if (name.isEmpty()) {
             throw new IllegalArgumentException();
         }
         int idx = name.lastIndexOf('.');
         if (idx == -1) {
@@ -84,11 +135,11 @@
             validSimpleIdentifier(name.substring(idx + 1));
             validPackageName(name.substring(0, idx));
         }
     }
 
-    public static String toJavaIdentifier(String str) {
+    static String toJavaIdentifier(String str) {
         final int size = str.length();
         StringBuilder sb = new StringBuilder(size);
         if (! Character.isJavaIdentifierStart(str.charAt(0))) {
             sb.append('_');
         }
@@ -101,29 +152,29 @@
             }
         }
         return sb.toString();
     }
 
-    private static String toSafeName(String name) {
+    static String toSafeName(String name) {
         StringBuilder sb = new StringBuilder(name.length());
         name = toJavaIdentifier(name);
         sb.append(name);
         if (SourceVersion.isKeyword(name)) {
             sb.append("$");
         }
         return sb.toString();
     }
 
-    public static String toClassName(String cname) {
+    static String toClassName(String cname) {
         return toSafeName(cname);
     }
 
-    public static String toMacroName(String mname) {
+    static String toMacroName(String mname) {
         return toSafeName(mname);
     }
 
-    public static String toInternalName(String pkg, String name, String... nested) {
+    static String toInternalName(String pkg, String name, String... nested) {
         if ((pkg == null || pkg.isEmpty()) && nested == null) {
             return name;
         }
 
         StringBuilder sb = new StringBuilder();
@@ -139,26 +190,26 @@
             sb.append(n);
         }
         return sb.toString();
     }
 
-    public static String getName(Type type) {
+    static String getName(Type type) {
         return LayoutUtils.getName(type);
     }
 
-    public static Stream<Cursor> flattenableChildren(Cursor c) {
+    static Stream<Cursor> flattenableChildren(Cursor c) {
         return c.children()
                 .filter(cx -> cx.isAnonymousStruct() || cx.kind() == CursorKind.FieldDecl);
     }
 
-    public static Optional<Cursor> lastChild(Cursor c) {
+    static Optional<Cursor> lastChild(Cursor c) {
         List<Cursor> children = flattenableChildren(c)
                 .collect(Collectors.toList());
         return children.isEmpty() ? Optional.empty() : Optional.of(children.get(children.size() - 1));
     }
 
-    public static boolean hasIncompleteArray(Cursor c) {
+    static boolean hasIncompleteArray(Cursor c) {
         switch (c.kind()) {
             case FieldDecl:
                 return c.type().kind() == TypeKind.IncompleteArray;
             case UnionDecl:
                 return flattenableChildren(c)
@@ -169,11 +220,11 @@
                 throw new IllegalStateException("Unhandled cursor kind: " + c.kind());
         }
     }
 
     // return builtin Record types accessible from the given Type
-    public static Stream<Cursor> getBuiltinRecordTypes(Type type) {
+    static Stream<Cursor> getBuiltinRecordTypes(Type type) {
         List<Cursor> recordTypes = new ArrayList<>();
         fillBuiltinRecordTypes(type, recordTypes);
         return recordTypes.stream().distinct();
     }
 
@@ -226,11 +277,11 @@
         }
     }
 
     // return the absolute path of the library of given name by searching
     // in the given array of paths.
-    public static Optional<Path> findLibraryPath(Path[] paths, String libName) {
+    static Optional<Path> findLibraryPath(Path[] paths, String libName) {
         return Arrays.stream(paths).
                 map(p -> p.resolve(System.mapLibraryName(libName))).
                 filter(Files::isRegularFile).map(Path::toAbsolutePath).findFirst();
     }
 
@@ -242,11 +293,11 @@
 
     /**
      * Escapes each character in a string that has an escape sequence or
      * is non-printable ASCII.  Leaves non-ASCII characters alone.
      */
-    public static String quote(String s) {
+    static String quote(String s) {
         StringBuilder buf = new StringBuilder();
         for (int i = 0; i < s.length(); i++) {
             buf.append(quote(s.charAt(i)));
         }
         return buf.toString();
@@ -254,11 +305,11 @@
 
     /**
      * Escapes a character if it has an escape sequence or is
      * non-printable ASCII.  Leaves non-ASCII characters alone.
      */
-    public static String quote(char ch) {
+    static String quote(char ch) {
         switch (ch) {
         case '\b':  return "\\b";
         case '\f':  return "\\f";
         case '\n':  return "\\n";
         case '\r':  return "\\r";
@@ -278,14 +329,14 @@
      */
     private static boolean isPrintableAscii(char ch) {
         return ch >= ' ' && ch <= '~';
     }
 
-    public static Optional<GroupLayout> getContents(MemoryLayout layout) {
+    static Optional<GroupLayout> getContents(MemoryLayout layout) {
         return layout.attribute("contents").map(GroupLayout.class::cast);
     }
 
     @SuppressWarnings("unchecked")
-    public static <Z extends MemoryLayout> Z addContents(Z layout, GroupLayout contents) {
+    static <Z extends MemoryLayout> Z addContents(Z layout, GroupLayout contents) {
         return (Z) layout.withAttribute("contents", contents);
     }
 }
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Writer.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Writer.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Writer.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Writer.java
@@ -34,15 +34,14 @@
 import java.nio.file.Path;
 import java.util.List;
 import java.util.stream.Collectors;
 
 public final class Writer {
-
     private final List<? extends JavaFileObject> files;
     private final Path dest;
 
-    Writer(Path dest, List<? extends JavaFileObject> files) {
+    public Writer(Path dest, List<? extends JavaFileObject> files) {
         this.files = files;
         this.dest = dest;
     }
 
     private List<JavaFileObject> ensureSourcesCompiled() {
@@ -55,11 +54,11 @@
                 "-d", dest.toAbsolutePath().toString(),
                 "-cp", dest.toAbsolutePath().toString());
         }
     }
 
-    void writeAll(boolean compileSources) throws IOException {
+    public void writeAll(boolean compileSources) throws IOException {
         writeClassFiles(resources());
         writeClassFiles(classes());
         if (compileSources) {
             writeClassFiles(ensureSourcesCompiled());
         } else {
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/Messages.properties b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/resources/Messages.properties
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/Messages.properties
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/resources/Messages.properties
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/resources/RuntimeHelper.java.template b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/resources/RuntimeHelper.java.template
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/resources/RuntimeHelper.java.template
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/resources/RuntimeHelper.java.template
diff a/src/jdk.incubator.jextract/share/classes/module-info.java b/src/jdk.incubator.jextract/share/classes/module-info.java
--- a/src/jdk.incubator.jextract/share/classes/module-info.java
+++ b/src/jdk.incubator.jextract/share/classes/module-info.java
@@ -1,9 +1,11 @@
+import jdk.incubator.jextract.JextractTool;
+
 module jdk.incubator.jextract {
     requires transitive java.compiler;
     requires transitive jdk.incubator.foreign;
     requires jdk.internal.opt;
     exports jdk.incubator.jextract;
 
     provides java.util.spi.ToolProvider with
-        jdk.incubator.jextract.tool.Main.JextractToolProvider;
+        JextractTool.JextractToolProvider;
 }
diff a/test/jdk/java/jextract/JextractApiTestBase.java b/test/jdk/java/jextract/JextractApiTestBase.java
--- a/test/jdk/java/jextract/JextractApiTestBase.java
+++ b/test/jdk/java/jextract/JextractApiTestBase.java
@@ -27,11 +27,11 @@
 import java.util.List;
 import java.util.Optional;
 import java.util.function.Predicate;
 
 import jdk.incubator.jextract.Declaration;
-import jdk.incubator.jextract.JextractTask;
+import jdk.incubator.jextract.JextractTool;
 import jdk.incubator.jextract.Type;
 
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertTrue;
 import static org.testng.Assert.fail;
@@ -42,12 +42,11 @@
     static final boolean isWindows =
             System.getProperty("os.name", "unknown").startsWith("Windows");
 
     public static  Declaration.Scoped parse(String headerFilename, String... parseOptions) {
         Path header = Paths.get(System.getProperty("test.src", "."), headerFilename);
-        var task = JextractTask.newTask(false, header);
-        return task.parse(parseOptions);
+        return JextractTool.parse(List.of(header), parseOptions);
     }
 
     public static void checkNames(List<Declaration> members, String... fields) {
         assertEquals(members.size(), fields.length);
         for (int i = 0; i < fields.length; i++) {
