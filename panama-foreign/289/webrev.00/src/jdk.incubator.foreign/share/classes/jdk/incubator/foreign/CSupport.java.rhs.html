<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  *  This code is free software; you can redistribute it and/or modify it
  6  *  under the terms of the GNU General Public License version 2 only, as
  7  *  published by the Free Software Foundation.  Oracle designates this
  8  *  particular file as subject to the &quot;Classpath&quot; exception as provided
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 package jdk.incubator.foreign;
 27 
 28 import jdk.internal.foreign.NativeMemorySegmentImpl;
 29 import jdk.internal.foreign.Utils;
 30 import jdk.internal.foreign.abi.SharedUtils;
 31 
 32 import java.nio.ByteOrder;
 33 import java.nio.charset.Charset;
 34 import java.util.Objects;
 35 import java.util.function.Consumer;
 36 
 37 /**
 38  * A set of utilities for working with libraries using the C language/ABI
 39  */
 40 public class CSupport {
<a name="1" id="anc1"></a><span class="line-added"> 41 </span>
<span class="line-added"> 42     /**</span>
<span class="line-added"> 43      * No need to construct</span>
<span class="line-added"> 44      */</span>
<span class="line-added"> 45     private CSupport() {}</span>
<span class="line-added"> 46 </span>
 47     /**
 48      * Obtain a linker that uses the de facto C ABI of the current system to do it&#39;s linking.
 49      * &lt;p&gt;
 50      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
 51      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
 52      * restricted methods, and use safe and supported functionalities, where possible.
 53      * @return a linker for this system.
 54      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
 55      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
 56      */
 57     public static ForeignLinker getSystemLinker() {
 58         Utils.checkRestrictedAccess(&quot;CSupport.getSystemLinker&quot;);
 59         return SharedUtils.getSystemLinker();
 60     }
 61 
 62     /**
 63      * An interface that models a C {@code va_list}.
 64      * &lt;p&gt;
 65      * A va list is a stateful cursor used to iterate over a set of variadic arguments.
 66      * &lt;p&gt;
 67      * Per the C specification (see C standard 6.5.2.2 Function calls - item 6),
 68      * arguments to variadic calls are erased by way of &#39;default argument promotions&#39;,
 69      * which erases integral types by way of integer promotion (see C standard 6.3.1.1 - item 2),
 70      * and which erases all {@code float} arguments to {@code double}.
 71      * &lt;p&gt;
 72      * As such, this interface only supports reading {@code int}, {@code double},
 73      * and any other type that fits into a {@code long}.
 74      */
 75     public interface VaList extends Addressable, AutoCloseable {
 76 
 77         /**
 78          * Reads the next value as an {@code int} and advances this va list&#39;s position.
 79          *
 80          * @param layout the layout of the value
 81          * @return the value read as an {@code int}
 82          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
 83          * (see {@link #close()}).
 84          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code int}
 85          */
 86         int vargAsInt(MemoryLayout layout);
 87 
 88         /**
 89          * Reads the next value as a {@code long} and advances this va list&#39;s position.
 90          *
 91          * @param layout the layout of the value
 92          * @return the value read as an {@code long}
 93          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
 94          * (see {@link #close()}).
 95          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code long}
 96          */
 97         long vargAsLong(MemoryLayout layout);
 98 
 99         /**
100          * Reads the next value as a {@code double} and advances this va list&#39;s position.
101          *
102          * @param layout the layout of the value
103          * @return the value read as an {@code double}
104          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
105          * (see {@link #close()}).
106          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code double}
107          */
108         double vargAsDouble(MemoryLayout layout);
109 
110         /**
111          * Reads the next value as a {@code MemoryAddress} and advances this va list&#39;s position.
112          *
113          * @param layout the layout of the value
114          * @return the value read as an {@code MemoryAddress}
115          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
116          * (see {@link #close()}).
117          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemoryAddress}
118          */
119         MemoryAddress vargAsAddress(MemoryLayout layout);
120 
121         /**
122          * Reads the next value as a {@code MemorySegment}, and advances this va list&#39;s position.
123          * &lt;p&gt;
124          * The memory segment returned by this method will be allocated using
125          * {@link MemorySegment#allocateNative(long, long)}, and will have to be closed separately.
126          *
127          * @param layout the layout of the value
128          * @return the value read as an {@code MemorySegment}
129          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
130          * (see {@link #close()}).
131          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}
132          */
133         MemorySegment vargAsSegment(MemoryLayout layout);
134 
135         /**
136          * Reads the next value as a {@code MemorySegment}, and advances this va list&#39;s position.
137          * &lt;p&gt;
138          * The memory segment returned by this method will be allocated using the given {@code NativeScope}.
139          *
140          * @param layout the layout of the value
141          * @param scope the scope to allocate the segment in
142          * @return the value read as an {@code MemorySegment}
143          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
144          * (see {@link #close()}).
145          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}
146          */
147         MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope);
148 
149         /**
150          * Skips a number of elements with the given memory layouts, and advances this va list&#39;s position.
151          *
152          * @param layouts the layout of the value
153          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
154          * (see {@link #close()}).
155          */
156         void skip(MemoryLayout... layouts);
157 
158         /**
159          * A predicate used to check if the memory associated with the C {@code va_list} modelled
160          * by this instance is still valid to use.
161          *
162          * @return true, if the memory associated with the C {@code va_list} modelled by this instance is still valid
163          * @see #close()
164          */
165         boolean isAlive();
166 
167         /**
168          * Releases the underlying C {@code va_list} modelled by this instance, and any native memory that is attached
169          * to this va list that holds its elements (see {@link VaList#make(Consumer)}).
170          * &lt;p&gt;
171          * After calling this method, {@link #isAlive()} will return {@code false} and further attempts to read values
172          * from this va list will result in an exception.
173          *
174          * @see #isAlive()
175          */
176         void close();
177 
178         /**
179          * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list&#39;s elements
180          * starting from the current position, without affecting the state of the original va list, essentially
181          * allowing the elements to be traversed multiple times.
182          * &lt;p&gt;
183          * If this method needs to allocate native memory for the copy, it will use
184          * {@link MemorySegment#allocateNative(long, long)} to do so. {@link #close()} will have to be called on the
185          * returned va list instance to release the allocated memory.
186          * &lt;p&gt;
187          * This method only copies the va list cursor itself and not the memory that may be attached to the
188          * va list which holds its elements. That means that if this va list was created with the
189          * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its
190          * elements, making the copy unusable.
191          *
192          * @return a copy of this C {@code va_list}.
193          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
194          * (see {@link #close()}).
195          */
196         VaList copy();
197 
198         /**
199          * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list&#39;s elements
200          * starting from the current position, without affecting the state of the original va list, essentially
201          * allowing the elements to be traversed multiple times.
202          * &lt;p&gt;
203          * If this method needs to allocate native memory for the copy, it will use
204          * the given {@code NativeScope} to do so.
205          * &lt;p&gt;
206          * This method only copies the va list cursor itself and not the memory that may be attached to the
207          * va list which holds its elements. That means that if this va list was created with the
208          * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its
209          * elements, making the copy unusable.
210          *
211          * @param scope the scope to allocate the copy in
212          * @return a copy of this C {@code va_list}.
213          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
214          * (see {@link #close()}).
215          */
216         VaList copy(NativeScope scope);
217 
218         /**
219          * Returns the memory address of the C {@code va_list} associated with this instance.
220          *
221          * @return the memory address of the C {@code va_list} associated with this instance.
222          */
223         @Override
224         MemoryAddress address();
225 
226         /**
227          * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list}.
228          *
229          * @param address a memory address pointing to an existing C {@code va_list}.
230          * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.
231          */
232         static VaList ofAddress(MemoryAddress address) {
233             return SharedUtils.newVaListOfAddress(address);
234         }
235 
236         /**
237          * Constructs a new {@code VaList} using a builder (see {@link Builder}).
238          * &lt;p&gt;
239          * If this method needs to allocate native memory for the va list, it will use
240          * {@link MemorySegment#allocateNative(long, long)} to do so.
241          * &lt;p&gt;
242          * This method will allocate native memory to hold the elements in the va list. This memory
243          * will be &#39;attached&#39; to the returned va list instance, and will be released when {@link VaList#close()}
244          * is called.
245          * &lt;p&gt;
246          * Note that when there are no elements added to the created va list,
247          * this method will return the same as {@linkplain #empty()}.
248          *
249          * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements
250          *                of the underlying C {@code va_list}.
251          * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.
252          */
253         static VaList make(Consumer&lt;VaList.Builder&gt; actions) {
254             return SharedUtils.newVaList(actions, MemorySegment::allocateNative);
255         }
256 
257         /**
258          * Constructs a new {@code VaList} using a builder (see {@link Builder}).
259          * &lt;p&gt;
260          * If this method needs to allocate native memory for the va list, it will use
261          * the given {@code NativeScope} to do so.
262          * &lt;p&gt;
263          * This method will allocate native memory to hold the elements in the va list. This memory
264          * will be managed by the given {@code NativeScope}, and will be released when the scope is closed.
265          * &lt;p&gt;
266          * Note that when there are no elements added to the created va list,
267          * this method will return the same as {@linkplain #empty()}.
268          *
269          * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements
270          *                of the underlying C {@code va_list}.
271          * @param scope the scope to be used for the valist allocation.
272          * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.
273          */
274         static VaList make(Consumer&lt;VaList.Builder&gt; actions, NativeScope scope) {
275             return SharedUtils.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
276         }
277 
278         /**
279          * Returns an empty C {@code va_list} constant.
280          * &lt;p&gt;
281          * The returned {@code VaList} can not be closed.
282          *
283          * @return a {@code VaList} modelling an empty C {@code va_list}.
284          */
285         static VaList empty() {
286             return SharedUtils.emptyVaList();
287         }
288 
289         /**
290          * A builder interface used to construct a C {@code va_list}.
291          */
292         interface Builder {
293 
294             /**
295              * Adds a native value represented as an {@code int} to the C {@code va_list} being constructed.
296              *
297              * @param layout the native layout of the value.
298              * @param value the value, represented as an {@code int}.
299              * @return this builder.
300              * @throws IllegalArgumentException if the given memory layout is not compatible with {@code int}
301              */
302             Builder vargFromInt(MemoryLayout layout, int value);
303 
304             /**
305              * Adds a native value represented as a {@code long} to the C {@code va_list} being constructed.
306              *
307              * @param layout the native layout of the value.
308              * @param value the value, represented as a {@code long}.
309              * @return this builder.
310              * @throws IllegalArgumentException if the given memory layout is not compatible with {@code long}
311              */
312             Builder vargFromLong(MemoryLayout layout, long value);
313 
314             /**
315              * Adds a native value represented as a {@code double} to the C {@code va_list} being constructed.
316              *
317              * @param layout the native layout of the value.
318              * @param value the value, represented as a {@code double}.
319              * @return this builder.
320              * @throws IllegalArgumentException if the given memory layout is not compatible with {@code double}
321              */
322             Builder vargFromDouble(MemoryLayout layout, double value);
323 
324             /**
325              * Adds a native value represented as a {@code MemoryAddress} to the C {@code va_list} being constructed.
326              *
327              * @param layout the native layout of the value.
328              * @param value the value, represented as a {@code MemoryAddress}.
329              * @return this builder.
330              * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemoryAddress}
331              */
332             Builder vargFromAddress(MemoryLayout layout, MemoryAddress value);
333 
334             /**
335              * Adds a native value represented as a {@code MemorySegment} to the C {@code va_list} being constructed.
336              *
337              * @param layout the native layout of the value.
338              * @param value the value, represented as a {@code MemorySegment}.
339              * @return this builder.
340              * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}
341              */
342             Builder vargFromSegment(MemoryLayout layout, MemorySegment value);
343         }
344     }
345 
346     /**
347      * The {@code _Bool} native type.
348      */
349     public static final ValueLayout C_BOOL = Utils.pick(SysV.C_BOOL, Win64.C_BOOL, AArch64.C_BOOL);
350     /**
351      * The {@code char} native type.
352      */
353     public static final ValueLayout C_CHAR = Utils.pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);
354     /**
355      * The {@code short} native type.
356      */
357     public static final ValueLayout C_SHORT = Utils.pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);
358     /**
359      * The {@code int} native type.
360      */
361     public static final ValueLayout C_INT = Utils.pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);
362     /**
363      * The {@code long} native type.
364      */
365     public static final ValueLayout C_LONG = Utils.pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);
366     /**
367      * The {@code long long} native type.
368      */
369     public static final ValueLayout C_LONGLONG = Utils.pick(SysV.C_LONGLONG, Win64.C_LONGLONG, AArch64.C_LONGLONG);
370     /**
371      * The {@code float} native type.
372      */
373     public static final ValueLayout C_FLOAT = Utils.pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);
374     /**
375      * The {@code double} native type.
376      */
377     public static final ValueLayout C_DOUBLE = Utils.pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);
378     /**
379      * The {@code long double} native type.
380      */
381     public static final ValueLayout C_LONGDOUBLE = Utils.pick(SysV.C_LONGDOUBLE, Win64.C_LONGDOUBLE, AArch64.C_LONGDOUBLE);
382     /**
383      * The {@code T*} native type.
384      */
385     public static final ValueLayout C_POINTER = Utils.pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);
386 
387     /**
388      * The {@code va_list} native type.
389      */
390     public static final MemoryLayout C_VA_LIST = Utils.pick(SysV.C_VA_LIST, Win64.C_VA_LIST, AArch64.C_VA_LIST);
391 
392     /**
393      * This class defines layout constants modelling standard primitive types supported by the x64 SystemV ABI.
394      */
395     public static final class SysV {
396         private SysV() {
397             //just the one
398         }
399 
400         /**
401          * The name of the SysV linker
402          * @see ForeignLinker#name
403          */
404         public static final String NAME = &quot;SysV&quot;;
405 
406         /**
407          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
408          * attribute value must be an enum constant from {@link ArgumentClass}.
409          */
410         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/sysv/class&quot;;
411 
412         /**
413          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
414          */
415         public enum ArgumentClass {
416             /** Classification constant for integral values */
417             INTEGER,
418             /** Classification constant for floating point values */
419             SSE,
420             /** Classification constant for x87 floating point values */
421             X87,
422             /** Classification constant for {@code complex long double} values */
423             COMPLEX_87,
424             /** Classification constant for machine pointer values */
425             POINTER;
426         }
427 
428         /**
429          * The {@code _Bool} native type.
430          */
431         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
432                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
433 
434         /**
435          * The {@code char} native type.
436          */
437         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
438                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
439 
440         /**
441          * The {@code short} native type.
442          */
443         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
444                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
445 
446         /**
447          * The {@code int} native type.
448          */
449         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
450                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
451 
452         /**
453          * The {@code long} native type.
454          */
455         public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
456                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
457 
458         /**
459          * The {@code long long} native type.
460          */
461         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
462                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
463 
464         /**
465          * The {@code float} native type.
466          */
467         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
468                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
469 
470         /**
471          * The {@code double} native type.
472          */
473         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
474                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
475 
476         /**
477          * The {@code long double} native type.
478          */
479         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
480                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.X87);
481 
482         /**
483          * The {@code complex long double} native type.
484          */
485         public static final GroupLayout C_COMPLEX_LONGDOUBLE = MemoryLayout.ofStruct(C_LONGDOUBLE, C_LONGDOUBLE)
486                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.COMPLEX_87);
487 
488         /**
489          * The {@code T*} native type.
490          */
491         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
492                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
493 
494         /**
495          * The {@code va_list} native type, as it is passed to a function.
496          */
497         public static final MemoryLayout C_VA_LIST = SysV.C_POINTER;
498     }
499 
500     /**
501      * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.
502      */
503     public static final class Win64 {
504 
505         private Win64() {
506             //just the one
507         }
508 
509         /**
510          * The name of the Windows linker
511          * @see ForeignLinker#name
512          */
513         public final static String NAME = &quot;Windows&quot;;
514 
515         /**
516          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used to mark variadic parameters. The
517          * attribute value must be a boolean.
518          */
519         public final static String VARARGS_ATTRIBUTE_NAME = &quot;abi/windows/varargs&quot;;
520 
521         /**
522          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
523          * attribute value must be an enum constant from {@link ArgumentClass}.
524          */
525         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/windows/class&quot;;
526 
527         /**
528          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
529          */
530         public enum ArgumentClass {
531             /** Classification constant for integral values */
532             INTEGER,
533             /** Classification constant for floating point values */
534             FLOAT,
535             /** Classification constant for machine pointer values */
536             POINTER;
537         }
538 
539         /**
540          * The {@code _Bool} native type.
541          */
542         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
543                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
544 
545         /**
546          * The {@code char} native type.
547          */
548         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
549                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
550 
551         /**
552          * The {@code short} native type.
553          */
554         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
555                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
556 
557         /**
558          * The {@code int} native type.
559          */
560         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
561                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
562 
563         /**
564          * The {@code long} native type.
565          */
566         public static final ValueLayout C_LONG = MemoryLayouts.BITS_32_LE
567                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
568 
569         /**
570          * The {@code long long} native type.
571          */
572         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
573                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
574 
575         /**
576          * The {@code float} native type.
577          */
578         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
579                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
580 
581         /**
582          * The {@code double} native type.
583          */
584         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
585                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
586 
587         /**
588          * The {@code long double} native type.
589          */
590         public static final ValueLayout C_LONGDOUBLE = MemoryLayouts.BITS_64_LE
591                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
592 
593         /**
594          * The {@code T*} native type.
595          */
596         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
597                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
598 
599         /**
600          * The {@code va_list} native type, as it is passed to a function.
601          */
602         public static final MemoryLayout C_VA_LIST = Win64.C_POINTER;
603 
604         /**
605          * Return a new memory layout which describes a variadic parameter to be passed to a function.
606          * @param layout the original parameter layout.
607          * @return a layout which is the same as {@code layout}, except for the extra attribute {@link #VARARGS_ATTRIBUTE_NAME},
608          * which is set to {@code true}.
609          */
610         public static ValueLayout asVarArg(ValueLayout layout) {
611             return layout.withAttribute(VARARGS_ATTRIBUTE_NAME, true);
612         }
613     }
614 
615     /**
616      * This class defines layout constants modelling standard primitive types supported by the AArch64 ABI.
617      */
618     public static final class AArch64 {
619 
620         private AArch64() {
621             //just the one
622         }
623 
624         /**
625          * The name of the AArch64 linker
626          * @see ForeignLinker#name
627          */
628         public final static String NAME = &quot;AArch64&quot;;
629 
630         /**
631          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
632          * attribute value must be an enum constant from {@link ArgumentClass}.
633          */
634         public static final String CLASS_ATTRIBUTE_NAME = &quot;abi/aarch64/class&quot;;
635 
636         /**
637          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
638          */
639         public enum ArgumentClass {
640             /** Classification constant for machine integral values */
641             INTEGER,
642             /** Classification constant for machine floating point values */
643             VECTOR,
644             /** Classification constant for machine pointer values */
645             POINTER;
646         }
647 
648         /**
649          * The {@code _Bool} native type.
650          */
651         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
652                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
653 
654         /**
655          * The {@code char} native type.
656          */
657         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
658                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
659 
660         /**
661          * The {@code short} native type.
662          */
663         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
664                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
665 
666         /**
667          * The {@code int} native type.
668          */
669         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
670                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
671 
672         /**
673          * The {@code long} native type.
674          */
675         public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
676                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
677 
678         /**
679          * The {@code long long} native type.
680          */
681         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
682                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
683 
684         /**
685          * The {@code float} native type.
686          */
687         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
688                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
689 
690         /**
691          * The {@code double} native type.
692          */
693         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
694                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
695 
696         /**
697          * The {@code long double} native type.
698          */
699         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
700                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
701 
702         /**
703          * The {@code T*} native type.
704          */
705         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
706                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
707 
708         /**
709          * The {@code va_list} native type, as it is passed to a function.
710          */
711         public static final MemoryLayout C_VA_LIST = AArch64.C_POINTER;
712     }
713 
714     /**
715      * Convert a Java string into a null-terminated C string, using the
716      * platform&#39;s default charset, storing the result into a new native memory segment.
717      * &lt;p&gt;
718      * This method always replaces malformed-input and unmappable-character
719      * sequences with this charset&#39;s default replacement byte array.  The
720      * {@link java.nio.charset.CharsetEncoder} class should be used when more
721      * control over the encoding process is required.
722      *
723      * @param str the Java string to be converted into a C string.
724      * @return a new native memory segment containing the converted C string.
725      * @throws NullPointerException if either {@code str == null}.
726      */
727     public static MemorySegment toCString(String str) {
728         Objects.requireNonNull(str);
729         return toCString(str.getBytes());
730     }
731 
732     /**
733      * Convert a Java string into a null-terminated C string, using the given {@linkplain java.nio.charset.Charset charset},
734      * storing the result into a new native memory segment.
735      * &lt;p&gt;
736      * This method always replaces malformed-input and unmappable-character
737      * sequences with this charset&#39;s default replacement byte array.  The
738      * {@link java.nio.charset.CharsetEncoder} class should be used when more
739      * control over the encoding process is required.
740      *
741      * @param str the Java string to be converted into a C string.
742      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.
743      * @return a new native memory segment containing the converted C string.
744      * @throws NullPointerException if either {@code str == null} or {@code charset == null}.
745      */
746     public static MemorySegment toCString(String str, Charset charset) {
747         Objects.requireNonNull(str);
748         Objects.requireNonNull(charset);
749         return toCString(str.getBytes(charset));
750     }
751 
752     /**
753      * Convert a Java string into a null-terminated C string, using the platform&#39;s default charset,
754      * storing the result into a native memory segment allocated using the provided scope.
755      * &lt;p&gt;
756      * This method always replaces malformed-input and unmappable-character
757      * sequences with this charset&#39;s default replacement byte array.  The
758      * {@link java.nio.charset.CharsetEncoder} class should be used when more
759      * control over the encoding process is required.
760      *
761      * @param str the Java string to be converted into a C string.
762      * @param scope the scope to be used for the native segment allocation.
763      * @return a new native memory segment containing the converted C string.
764      * @throws NullPointerException if either {@code str == null} or {@code scope == null}.
765      */
766     public static MemorySegment toCString(String str, NativeScope scope) {
767         Objects.requireNonNull(str);
768         Objects.requireNonNull(scope);
769         return toCString(str.getBytes(), scope);
770     }
771 
772     /**
773      * Convert a Java string into a null-terminated C string, using the given {@linkplain java.nio.charset.Charset charset},
774      * storing the result into a new native memory segment native memory segment allocated using the provided scope.
775      * &lt;p&gt;
776      * This method always replaces malformed-input and unmappable-character
777      * sequences with this charset&#39;s default replacement byte array.  The
778      * {@link java.nio.charset.CharsetEncoder} class should be used when more
779      * control over the encoding process is required.
780      *
781      * @param str the Java string to be converted into a C string.
782      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.
783      * @param scope the scope to be used for the native segment allocation.
784      * @return a new native memory segment containing the converted C string.
785      * @throws NullPointerException if either {@code str == null}, {@code charset == null} or {@code scope == null}.
786      */
787     public static MemorySegment toCString(String str, Charset charset, NativeScope scope) {
788         Objects.requireNonNull(str);
789         Objects.requireNonNull(charset);
790         Objects.requireNonNull(scope);
791         return toCString(str.getBytes(charset), scope);
792     }
793 
794     /**
795      * Convert a null-terminated C string stored at given address into a Java string, using the platform&#39;s default charset.
796      * &lt;p&gt;
797      * This method always replaces malformed-input and unmappable-character
798      * sequences with this charset&#39;s default replacement string.  The {@link
799      * java.nio.charset.CharsetDecoder} class should be used when more control
800      * over the decoding process is required.
801      * &lt;p&gt;
802      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
803      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
804      * restricted methods, and use safe and supported functionalities, where possible.
805      * @param addr the address at which the string is stored.
806      * @return a Java string with the contents of the null-terminated C string at given address.
807      * @throws NullPointerException if {@code addr == null}
808      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
809      */
810     public static String toJavaStringRestricted(MemoryAddress addr) {
811         Utils.checkRestrictedAccess(&quot;CSupport.toJavaStringRestricted&quot;);
812         return SharedUtils.toJavaStringInternal(NativeMemorySegmentImpl.EVERYTHING, addr.toRawLongValue(), Charset.defaultCharset());
813     }
814 
815     /**
816      * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.
817      * &lt;p&gt;
818      * This method always replaces malformed-input and unmappable-character
819      * sequences with this charset&#39;s default replacement string.  The {@link
820      * java.nio.charset.CharsetDecoder} class should be used when more control
821      * over the decoding process is required.
822      * &lt;p&gt;
823      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
824      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
825      * restricted methods, and use safe and supported functionalities, where possible.
826      * @param addr the address at which the string is stored.
827      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the Java string.
828      * @return a Java string with the contents of the null-terminated C string at given address.
829      * @throws NullPointerException if {@code addr == null}
830      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
831      */
832     public static String toJavaStringRestricted(MemoryAddress addr, Charset charset) {
833         Utils.checkRestrictedAccess(&quot;CSupport.toJavaStringRestricted&quot;);
834         return SharedUtils.toJavaStringInternal(NativeMemorySegmentImpl.EVERYTHING, addr.toRawLongValue(), charset);
835     }
836 
837     /**
838      * Convert a null-terminated C string stored at given address into a Java string, using the platform&#39;s default charset.
839      * &lt;p&gt;
840      * This method always replaces malformed-input and unmappable-character
841      * sequences with this charset&#39;s default replacement string.  The {@link
842      * java.nio.charset.CharsetDecoder} class should be used when more control
843      * over the decoding process is required.
844      * @param addr the address at which the string is stored.
845      * @return a Java string with the contents of the null-terminated C string at given address.
846      * @throws NullPointerException if {@code addr == null}
847      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
848      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
849      * associated with {@code addr}, or if {@code addr} is associated with a segment that is &lt;em&gt;not alive&lt;/em&gt;.
850      */
851     public static String toJavaString(MemorySegment addr) {
852         return SharedUtils.toJavaStringInternal(addr, 0L, Charset.defaultCharset());
853     }
854 
855     /**
856      * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.
857      * &lt;p&gt;
858      * This method always replaces malformed-input and unmappable-character
859      * sequences with this charset&#39;s default replacement string.  The {@link
860      * java.nio.charset.CharsetDecoder} class should be used when more control
861      * over the decoding process is required.
862      * @param addr the address at which the string is stored.
863      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the Java string.
864      * @return a Java string with the contents of the null-terminated C string at given address.
865      * @throws NullPointerException if {@code addr == null}
866      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
867      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
868      * associated with {@code addr}, or if {@code addr} is associated with a segment that is &lt;em&gt;not alive&lt;/em&gt;.
869      */
870     public static String toJavaString(MemorySegment addr, Charset charset) {
871         return SharedUtils.toJavaStringInternal(addr, 0L, charset);
872     }
873 
874     private static void copy(MemorySegment addr, byte[] bytes) {
875         var heapSegment = MemorySegment.ofArray(bytes);
876         addr.copyFrom(heapSegment);
877         MemoryAccess.setByteAtOffset(addr, bytes.length, (byte)0);
878     }
879 
880     private static MemorySegment toCString(byte[] bytes) {
881         MemorySegment segment = MemorySegment.allocateNative(bytes.length + 1, 1L);
882         copy(segment, bytes);
883         return segment;
884     }
885 
886     private static MemorySegment toCString(byte[] bytes, NativeScope scope) {
887         MemorySegment addr = scope.allocate(bytes.length + 1, 1L);
888         copy(addr, bytes);
889         return addr;
890     }
891 
892     /**
893      * Allocate memory of given size using malloc.
894      *
895      * @param size memory size to be allocated
896      * @return addr memory address of the allocated memory
897      */
898     public static MemoryAddress allocateMemoryRestricted(long size) {
899         Utils.checkRestrictedAccess(&quot;CSupport.allocateMemoryRestricted&quot;);
900         return SharedUtils.allocateMemoryInternal(size);
901     }
902 
903     /**
904      * Free the memory pointed by the given memory address.
905      *
906      * @param addr memory address of the native memory to be freed
907      */
908     public static void freeMemoryRestricted(MemoryAddress addr) {
909         Utils.checkRestrictedAccess(&quot;CSupport.freeMemoryRestricted&quot;);
910         SharedUtils.freeMemoryInternal(addr);
911     }
912 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>