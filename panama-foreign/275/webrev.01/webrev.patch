diff a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -650,5 +650,6 @@
 143e258f64af490010eb7e0bacc1cfaeceff0993 jdk-16+5
 2dad000726b8d5db9f3df647fb4949d88f269dd4 jdk-15+32
 4a8fd81d64bafa523cddb45f82805536edace106 jdk-16+6
 6b65f4e7a975628df51ef755b02642075390041d jdk-15+33
 c3a4a7ea7c304cabdacdc31741eb94c51351668d jdk-16+7
+0a73d6f3aab48ff6d7e61e47f0bc2d87a054f217 jdk-16+8
diff a/doc/hotspot-style.html b/doc/hotspot-style.html
--- /dev/null
+++ b/doc/hotspot-style.html
@@ -0,0 +1,319 @@
+<!DOCTYPE html>
+<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
+<head>
+  <meta charset="utf-8" />
+  <meta name="generator" content="pandoc" />
+  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
+  <title>HotSpot Coding Style</title>
+  <style type="text/css">
+      code{white-space: pre-wrap;}
+      span.smallcaps{font-variant: small-caps;}
+      span.underline{text-decoration: underline;}
+      div.column{display: inline-block; vertical-align: top; width: 50%;}
+  </style>
+  <link rel="stylesheet" href="../make/data/docs-resources/resources/jdk-default.css" />
+  <!--[if lt IE 9]>
+    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
+  <![endif]-->
+</head>
+<body>
+<header id="title-block-header">
+<h1 class="title">HotSpot Coding Style</h1>
+</header>
+<nav id="TOC">
+<ul>
+<li><a href="#introduction">Introduction</a><ul>
+<li><a href="#why-care-about-style">Why Care About Style?</a></li>
+<li><a href="#counterexamples-and-updates">Counterexamples and Updates</a></li>
+</ul></li>
+<li><a href="#structure-and-formatting">Structure and Formatting</a><ul>
+<li><a href="#factoring-and-class-design">Factoring and Class Design</a></li>
+<li><a href="#files">Files</a></li>
+<li><a href="#naming">Naming</a></li>
+<li><a href="#commenting">Commenting</a></li>
+<li><a href="#macros">Macros</a></li>
+<li><a href="#whitespace">Whitespace</a></li>
+<li><a href="#miscellaneous">Miscellaneous</a></li>
+</ul></li>
+<li><a href="#use-of-c-features">Use of C++ Features</a><ul>
+<li><a href="#error-handling">Error Handling</a></li>
+<li><a href="#rtti-runtime-type-information">RTTI (Runtime Type Information)</a></li>
+<li><a href="#memory-allocation">Memory Allocation</a></li>
+<li><a href="#class-inheritance">Class Inheritance</a></li>
+<li><a href="#namespaces">Namespaces</a></li>
+<li><a href="#c-standard-library">C++ Standard Library</a></li>
+<li><a href="#type-deduction">Type Deduction</a></li>
+<li><a href="#expression-sfinae">Expression SFINAE</a></li>
+<li><a href="#enum">enum</a></li>
+<li><a href="#thread_local">thread_local</a></li>
+<li><a href="#nullptr">nullptr</a></li>
+<li><a href="#atomic">&lt;atomic&gt;</a></li>
+<li><a href="#additional-permitted-features">Additional Permitted Features</a></li>
+<li><a href="#excluded-features">Excluded Features</a></li>
+<li><a href="#undecided-features">Undecided Features</a></li>
+</ul></li>
+</ul>
+</nav>
+<h2 id="introduction">Introduction</h2>
+<p>This is a collection of rules, guidelines, and suggestions for writing HotSpot code. Following these will help new code fit in with existing HotSpot code, making it easier to read and maintain. Failure to follow these guidelines may lead to discussion during code reviews, if not outright rejection of a change.</p>
+<h3 id="why-care-about-style">Why Care About Style?</h3>
+<p>Some programmers seem to have lexers and even C preprocessors installed directly behind their eyeballs. The rest of us require code that is not only functionally correct but also easy to read. More than that, since there is no one style for easy-to-read code, and since a mashup of many styles is just as confusing as no style at all, it is important for coders to be conscious of the many implicit stylistic choices that historically have gone into the HotSpot code base.</p>
+<p>Some of these guidelines are driven by the cross-platform requirements for HotSpot. Shared code must work on a variety of platforms, and may encounter deficiencies in some. Using platform conditionalization in shared code is usually avoided, while shared code is strongly preferred to multiple platform-dependent implementations, so some language features may be recommended against.</p>
+<p>Some of the guidelines here are relatively arbitrary choices among equally plausible alternatives. The purpose of stating and enforcing these rules is largely to provide a consistent look to the code. That consistency makes the code more readable by avoiding non-functional distractions from the interesting functionality.</p>
+<p>When changing pre-existing code, it is reasonable to adjust it to match these conventions. Exception: If the pre-existing code clearly conforms locally to its own peculiar conventions, it is not worth reformatting the whole thing. Also consider separating changes that make extensive stylistic updates from those which make functional changes.</p>
+<h3 id="counterexamples-and-updates">Counterexamples and Updates</h3>
+<p>Many of the guidelines mentioned here have (sometimes widespread) counterexamples in the HotSpot code base. Finding a counterexample is not sufficient justification for new code to follow the counterexample as a precedent, since readers of your code will rightfully expect your code to follow the greater bulk of precedents documented here.</p>
+<p>Occasionally a guideline mentioned here may be just out of synch with the actual HotSpot code base. If you find that a guideline is consistently contradicted by a large number of counterexamples, please bring it up for discussion and possible change. The architectural rule, of course, is &quot;When in Rome do as the Romans&quot;. Sometimes in the suburbs of Rome the rules are a little different; these differences can be pointed out here.</p>
+<p>Proposed changes should be discussed on the <a href="mailto:hotspot-dev@openjdk.java.net">HotSpot Developers</a> mailing list, and approved by <a href="https://en.wikipedia.org/wiki/Rough_consensus">rough consensus</a> of the <a href="https://openjdk.java.net/census#hotspot">HotSpot Group</a> Members. The Group Lead determines whether consensus has been reached. Changes are likely to be cautious and incremental, since HotSpot coders have been using these guidelines for years.</p>
+<h2 id="structure-and-formatting">Structure and Formatting</h2>
+<h3 id="factoring-and-class-design">Factoring and Class Design</h3>
+<ul>
+<li><p>Group related code together, so readers can concentrate on one section of one file.</p></li>
+<li><p>Classes are the primary code structuring mechanism. Place related functionality in a class, or a set of related classes. Use of either namespaces or public non-member functions is rare in HotSpot code. Static non-member functions are not uncommon.</p></li>
+<li><p>If a class <code>FooBar</code> is going to be used in more than one place, put it a file named fooBar.hpp and fooBar.cpp. If the class is a sidekick to a more important class <code>BazBat</code>, it can go in bazBat.hpp.</p></li>
+<li><p>Put a member function <code>FooBar::bang</code> into the same file that defined <code>FooBar</code>, or its associated <em>.inline.hpp or </em>.cpp file.</p></li>
+<li><p>Use public accessor functions for member variables accessed outside the class.</p></li>
+<li><p>Assign names to constant literals and use the names instead.</p></li>
+<li><p>Keep functions small, a screenful at most. Split out chunks of logic into file-local classes or static functions if needed.</p></li>
+<li><p>Factor away nonessential complexity into local inline helper functions and helper classes.</p></li>
+<li><p>Think clearly about internal invariants that apply to each class, and document them in the form of asserts within member functions.</p></li>
+<li><p>Make simple, self-evident contracts for member functions. If you cannot communicate a simple contract, redesign the class.</p></li>
+<li><p>Implement classes as if expecting rough usage by clients. Check for incorrect usage of a class using <code>assert(...)</code>, <code>guarantee(...)</code>, <code>ShouldNotReachHere()</code> and comments wherever needed. Performance is almost never a reason to omit asserts.</p></li>
+<li><p>When possible, design as if for reusability. This forces a clear design of the class's externals, and clean hiding of its internals.</p></li>
+<li><p>Initialize all variables and data structures to a known state. If a class has a constructor, initialize it there.</p></li>
+<li><p>Do no optimization before its time. Prove the need to optimize.</p></li>
+<li><p>When you must defactor to optimize, preserve as much structure as possible. If you must hand-inline some name, label the local copy with the original name.</p></li>
+<li><p>If you need to use a hidden detail (e.g., a structure offset), name it (as a constant or function) in the class that owns it.</p></li>
+<li><p>Don't use the Copy and Paste keys to replicate more than a couple lines of code. Name what you must repeat.</p></li>
+<li><p>If a class needs a member function to change a user-visible attribute, the change should be done with a &quot;setter&quot; accessor matched to the simple &quot;getter&quot;.</p></li>
+</ul>
+<h3 id="files">Files</h3>
+<ul>
+<li><p>All source files must have a globally unique basename. The build system depends on this uniqueness.</p></li>
+<li><p>Do not put non-trivial function implementations in .hpp files. If the implementation depends on other .hpp files, put it in a .cpp or a .inline.hpp file.</p></li>
+<li><p>.inline.hpp files should only be included in .cpp or .inline.hpp files.</p></li>
+<li><p>All .cpp files include precompiled.hpp as the first include line.</p></li>
+<li><p>precompiled.hpp is just a build time optimization, so don't rely on it to resolve include problems.</p></li>
+<li><p>Keep the include lines alphabetically sorted.</p></li>
+<li><p>Put conditional inclusions (<code>#if ...</code>) at the end of the include list.</p></li>
+</ul>
+<h3 id="naming">Naming</h3>
+<ul>
+<li><p>The length of a name may be correlated to the size of its scope. In particular, short names (even single letter names) may be fine in a small scope, but are usually inappropriate for larger scopes.</p></li>
+<li><p>Prefer whole words rather than abbreviations, unless the abbreviation is more widely used than the long form in the code's domain.</p></li>
+<li><p>Choose names consistently. Do not introduce spurious variations. Abbreviate corresponding terms to a consistent length.</p></li>
+<li><p>Global names must be unique, to avoid <a href="https://en.cppreference.com/w/cpp/language/definition" title="One Definition Rule">One Definition Rule</a> (ODR) violations. A common prefixing scheme for related global names is often used. (This is instead of using namespaces, which are mostly avoided in HotSpot.)</p></li>
+<li><p>Don't give two names to the semantically same thing. But use different names for semantically different things, even if they are representationally the same. (So use meaningful <code>typedef</code> or template alias names where appropriate.)</p></li>
+<li><p>When choosing names, avoid categorical nouns like &quot;variable&quot;, &quot;field&quot;, &quot;parameter&quot;, &quot;value&quot;, and verbs like &quot;compute&quot;, &quot;get&quot;. (<code>storeValue(int param)</code> is bad.)</p></li>
+<li><p>Type names and global names should use mixed-case with the first letter of each word capitalized (<code>FooBar</code>).</p></li>
+<li><p>Embedded abbreviations in otherwise mixed-case names are usually capitalized entirely rather than being treated as a single word with only the initial letter capitalized, e.g. &quot;HTML&quot; rather than &quot;Html&quot;.</p></li>
+<li><p>Function and local variable names use lowercase with words separated by a single underscore (<code>foo_bar</code>).</p></li>
+<li><p>Class data member names have a leading underscore, and use lowercase with words separated by a single underscore (<code>_foo_bar</code>).</p></li>
+<li><p>Constant names may be upper-case or mixed-case, according to historical necessity. (Note: There are many examples of constants with lowercase names.)</p></li>
+<li><p>Constant names should follow an existing pattern, and must have a distinct appearance from other names in related APIs.</p></li>
+<li><p>Class and type names should be noun phrases. Consider an &quot;er&quot; suffix for a class that represents an action.</p></li>
+<li><p>Function names should be verb phrases that reflect changes of state known to a class's user, or else noun phrases if they cause no change of state visible to the class's user.</p></li>
+<li><p>Getter accessor names are noun phrases, with no &quot;<code>get_</code>&quot; noise word. Boolean getters can also begin with &quot;<code>is_</code>&quot; or &quot;<code>has_</code>&quot;. Member function for reading data members usually have the same name as the data member, exclusive of the leading underscore.</p></li>
+<li><p>Setter accessor names prepend &quot;<code>set_</code>&quot; to the getter name.</p></li>
+<li><p>Other member function names are verb phrases, as if commands to the receiver.</p></li>
+<li><p>Avoid leading underscores (as &quot;<code>_oop</code>&quot;) except in cases required above. (Names with leading underscores can cause portability problems.)</p></li>
+</ul>
+<h3 id="commenting">Commenting</h3>
+<ul>
+<li><p>Clearly comment subtle fixes.</p></li>
+<li><p>Clearly comment tricky classes and functions.</p></li>
+<li><p>If you have to choose between commenting code and writing wiki content, comment the code. Link from the wiki to the source file if it makes sense.</p></li>
+<li><p>As a general rule don't add bug numbers to comments (they would soon overwhelm the code). But if the bug report contains significant information that can't reasonably be added as a comment, then refer to the bug report.</p></li>
+<li><p>Personal names are discouraged in the source code, which is a team product.</p></li>
+</ul>
+<h3 id="macros">Macros</h3>
+<ul>
+<li><p>You can almost always use an inline function or class instead of a macro. Use a macro only when you really need it.</p></li>
+<li><p>Templates may be preferable to multi-line macros. (There may be subtle performance effects with templates on some platforms; revert to macros if absolutely necessary.)</p></li>
+<li><p><code>#ifdef</code>s should not be used to introduce platform-specific code into shared code (except for <code>_LP64</code>). They must be used to manage header files, in the pattern found at the top of every source file. They should be used mainly for major build features, including <code>PRODUCT</code>, <code>ASSERT</code>, <code>_LP64</code>, <code>INCLUDE_SERIALGC</code>, <code>COMPILER1</code>, etc.</p></li>
+<li><p>For build features such as <code>PRODUCT</code>, use <code>#ifdef PRODUCT</code> for multiple-line inclusions or exclusions.</p></li>
+<li><p>For short inclusions or exclusions based on build features, use macros like <code>PRODUCT_ONLY</code> and <code>NOT_PRODUCT</code>. But avoid using them with multiple-line arguments, since debuggers do not handle that well.</p></li>
+<li><p>Use <code>CATCH</code>, <code>THROW</code>, etc. for HotSpot-specific exception processing.</p></li>
+</ul>
+<h3 id="whitespace">Whitespace</h3>
+<ul>
+<li><p>In general, don't change whitespace unless it improves readability or consistency. Gratuitous whitespace changes will make integrations and backports more difficult.</p></li>
+<li><p>Use One-True-Brace-Style. The opening brace for a function or class is normally at the end of the line; it is sometimes moved to the beginning of the next line for emphasis. Substatements are enclosed in braces, even if there is only a single statement. Extremely simple one-line statements may drop braces around a substatement.</p></li>
+<li><p>Indentation levels are two columns.</p></li>
+<li><p>There is no hard line length limit. That said, bear in mind that excessively long lines can cause difficulties. Some people like to have multiple side-by-side windows in their editors, and long lines may force them to choose among unpleasant options. They can use wide windows, reducing the number that can fit across the screen, and wasting a lot of screen real estate because most lines are not that long. Alternatively, they can have more windows across the screen, with long lines wrapping (or worse, requiring scrolling to see in their entirety), which is harder to read. Similar issues exist for side-by-side code reviews.</p></li>
+<li><p>Tabs are not allowed in code. Set your editor accordingly.<br> (Emacs: <code>(setq-default indent-tabs-mode nil)</code>.)</p></li>
+<li><p>Use good taste to break lines and align corresponding tokens on adjacent lines.</p></li>
+<li><p>Use spaces around operators, especially comparisons and assignments. (Relaxable for boolean expressions and high-precedence operators in classic math-style formulas.)</p></li>
+<li><p>Put spaces on both sides of control flow keywords <code>if</code>, <code>else</code>, <code>for</code>, <code>switch</code>, etc. Don't add spaces around the associated <em>control</em> expressions. Examples:</p>
+<pre><code>while (test_foo(args...)) {   // Yes
+while(test_foo(args...)) {    // No, missing space after while
+while ( test_foo(args...) ) { // No, excess spaces around control</code></pre></li>
+<li><p>Use extra parentheses in expressions whenever operator precedence seems doubtful. Always use parentheses in shift/mask expressions (<code>&lt;&lt;</code>, <code>&amp;</code>, <code>|</code>). Don't add whitespace immediately inside parentheses.</p></li>
+<li><p>Use more spaces and blank lines between larger constructs, such as classes or function definitions.</p></li>
+<li><p>If the surrounding code has any sort of vertical organization, adjust new lines horizontally to be consistent with that organization. (E.g., trailing backslashes on long macro definitions often align.)</p></li>
+</ul>
+<h3 id="miscellaneous">Miscellaneous</h3>
+<ul>
+<li><p>Use the <a href="https://en.cppreference.com/w/cpp/language/raii" title="Resource Acquisition Is Initialization">Resource Acquisition Is Initialization</a> (RAII) design pattern to manage bracketed critical sections. See class <code>ResourceMark</code> for an example.</p></li>
+<li>Avoid implicit conversions to <code>bool</code>.
+<ul>
+<li>Use <code>bool</code> for boolean values.</li>
+<li>Do not use ints or pointers as (implicit) booleans with <code>&amp;&amp;</code>, <code>||</code>, <code>if</code>, <code>while</code>. Instead, compare explicitly, i.e. <code>if (x != 0)</code> or <code>if (ptr != nullptr)</code>, etc.</li>
+<li>Do not use declarations in <em>condition</em> forms, i.e. don't use <code>if (T v = value) { ... }</code>.</li>
+</ul></li>
+<li><p>Use functions from globalDefinitions.hpp and related files when performing bitwise operations on integers. Do not code directly as C operators, unless they are extremely simple. (Examples: <code>align_up</code>, <code>is_power_of_2</code>, <code>exact_log2</code>.)</p></li>
+<li><p>Use arrays with abstractions supporting range checks.</p></li>
+<li><p>Always enumerate all cases in a switch statement or provide a default case. It is ok to have an empty default with comment.</p></li>
+</ul>
+<h2 id="use-of-c-features">Use of C++ Features</h2>
+<p>HotSpot was originally written in a subset of the C++98/03 language. More recently, support for C++14 is provided, though again, HotSpot only uses a subset. (Backports to JDK versions lacking support for more recent Standards must of course stick with the original C++98/03 subset.)</p>
+<p>This section describes that subset. Features from the C++98/03 language may be used unless explicitly excluded here. Features from C++11 and C++14 may be explicitly permitted or explicitly excluded, and discussed accordingly here. There is a third category, undecided features, about which HotSpot developers have not yet reached a consensus, or perhaps have not discussed at all. Use of these features is also excluded.</p>
+<p>(The use of some features may not be immediately obvious and may slip in anyway, since the compiler will accept them. The code review process is the main defense against this.)</p>
+<p>Some features are discussed in their own subsection, typically to provide more extensive discussion or rationale for limitations. Features that don't have their own subsection are listed in omnibus feature sections for permitted, excluded, and undecided features.</p>
+<p>Lists of new features for C++11 and C++14, along with links to their descriptions, can be found in the online documentation for some of the compilers and libraries. The C++14 Standard is the definitive description.</p>
+<ul>
+<li><a href="https://gcc.gnu.org/projects/cxx-status.html">C++ Standards Support in GCC</a></li>
+<li><a href="https://clang.llvm.org/cxx_status.html">C++ Support in Clang</a></li>
+<li><a href="https://docs.microsoft.com/en-us/cpp/visual-cpp-language-conformance">Visual C++ Language Conformance</a></li>
+<li><a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html">libstdc++ Status</a></li>
+<li><a href="https://libcxx.llvm.org/cxx1y_status.html">libc++ Status</a></li>
+</ul>
+<p>As a rule of thumb, permitting features which simplify writing code and, especially, reading code, is encouraged.</p>
+<p>Similar discussions for some other projects:</p>
+<ul>
+<li><p><a href="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a> — Currently (2020) targeting C++17.</p></li>
+<li><p><a href="https://chromium-cpp.appspot.com">C++11 and C++14 use in Chromium</a> — Categorizes features as allowed, banned, or to be discussed.</p></li>
+<li><p><a href="https://llvm.org/docs/CodingStandards.html">llvm Coding Standards</a> — Currently (2020) targeting C++14.</p></li>
+<li><p><a href="https://firefox-source-docs.mozilla.org/code-quality/coding-style/using_cxx_in_firefox_code.html">Using C++ in Mozilla code</a> — C++17 support is required for recent versions (2020).</p></li>
+</ul>
+<h3 id="error-handling">Error Handling</h3>
+<p>Do not use exceptions. Exceptions are disabled by the build configuration for some platforms.</p>
+<p>Rationale: There is significant concern over the performance cost of exceptions and their usage model and implications for maintainable code. That's not just a matter of history that has been fixed; there remain questions and problems even today (2019). See, for example, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r0.pdf">Zero cost deterministic exceptions</a>. Because of this, HotSpot has always used a build configuration that disables exceptions where that is available. As a result, HotSpot code uses error handling mechanisms such as two-phase construction, factory functions, returning error codes, and immediate termination. Even if the cost of exceptions were not a concern, the existing body of code was not written with exception safety in mind. Making HotSpot exception safe would be a very large undertaking.</p>
+<p>In addition to the usual alternatives to exceptions, HotSpot provides its own exception mechanism. This is based on a set of macros defined in utilities/exceptions.hpp.</p>
+<h3 id="rtti-runtime-type-information">RTTI (Runtime Type Information)</h3>
+<p>Do not use <a href="https://en.wikipedia.org/wiki/Run-time_type_information" title="Runtime Type Information">Runtime Type Information</a> (RTTI). <a href="https://en.wikipedia.org/wiki/Run-time_type_information" title="Runtime Type Information">RTTI</a> is disabled by the build configuration for some platforms. Among other things, this means <code>dynamic_cast</code> cannot be used.</p>
+<p>Rationale: Other than to implement exceptions (which HotSpot doesn't use), most potential uses of <a href="https://en.wikipedia.org/wiki/Run-time_type_information" title="Runtime Type Information">RTTI</a> are better done via virtual functions. Some of the remainder can be replaced by bespoke mechanisms. The cost of the additional runtime data structures needed to support <a href="https://en.wikipedia.org/wiki/Run-time_type_information" title="Runtime Type Information">RTTI</a> are deemed not worthwhile, given the alternatives.</p>
+<h3 id="memory-allocation">Memory Allocation</h3>
+<p>Do not use the standard global allocation and deallocation functions (operator new and related functions). Use of these functions by HotSpot code is disabled for some platforms.</p>
+<p>Rationale: HotSpot often uses &quot;resource&quot; or &quot;arena&quot; allocation. Even where heap allocation is used, the standard global functions are avoided in favor of wrappers around malloc and free that support the VM's Native Memory Tracking (NMT) feature.</p>
+<p>Native memory allocation failures are often treated as non-recoverable. The place where &quot;out of memory&quot; is (first) detected may be an innocent bystander, unrelated to the actual culprit.</p>
+<h3 id="class-inheritance">Class Inheritance</h3>
+<p>Use public single inheritance.</p>
+<p>Prefer composition rather than non-public inheritance.</p>
+<p>Restrict inheritance to the &quot;is-a&quot; case; use composition rather than non-is-a related inheritance.</p>
+<p>Avoid multiple inheritance. Never use virtual inheritance.</p>
+<h3 id="namespaces">Namespaces</h3>
+<p>Avoid using namespaces. HotSpot code normally uses &quot;all static&quot; classes rather than namespaces for grouping. An &quot;all static&quot; class is not instantiable, has only static members, and is normally derived (possibly indirectly) from the helper class <code>AllStatic</code>.</p>
+<p>Benefits of using such classes include:</p>
+<ul>
+<li><p>Provides access control for members, which is unavailable with namespaces.</p></li>
+<li><p>Avoids <a href="https://en.cppreference.com/w/cpp/language/adl" title="Argument Dependent Lookup">Argument Dependent Lookup</a> (ADL).</p></li>
+<li><p>Closed for additional members. Namespaces allow names to be added in multiple contexts, making it harder to see the complete API.</p></li>
+</ul>
+<p>Namespaces should be used only in cases where one of those &quot;benefits&quot; is actually a hindrance.</p>
+<p>In particular, don't use anonymous namespaces. They seem like they should be useful, and indeed have some real benefits for naming and generated code size on some platforms. Unfortunately, debuggers don't seem to like them at all.</p>
+<p><a href="https://groups.google.com/forum/#!topic/mozilla.dev.platform/KsaG3lEEaRM" class="uri">https://groups.google.com/forum/#!topic/mozilla.dev.platform/KsaG3lEEaRM</a><br> Suggests Visual Studio debugger might not be able to refer to anonymous namespace symbols, so can't set breakpoints in them. Though the discussion seems to go back and forth on that.</p>
+<p><a href="https://firefox-source-docs.mozilla.org/code-quality/coding-style/coding_style_cpp.html" class="uri">https://firefox-source-docs.mozilla.org/code-quality/coding-style/coding_style_cpp.html</a><br> Search for &quot;Anonymous namespaces&quot; Suggests preferring &quot;static&quot; to anonymous namespaces where applicable, because of poor debugger support for anonymous namespaces.</p>
+<p><a href="https://sourceware.org/bugzilla/show_bug.cgi?id=16874" class="uri">https://sourceware.org/bugzilla/show_bug.cgi?id=16874</a><br> Bug for similar gdb problems.</p>
+<h3 id="c-standard-library">C++ Standard Library</h3>
+<p>Avoid using the C++ Standard Library.</p>
+<p>Historically, HotSpot has mostly avoided use of the Standard Library.</p>
+<p>(It used to be impossible to use most of it in shared code, because the build configuration for Solaris with Solaris Studio made all but a couple of pieces inaccessible. Support for header-only parts was added in mid-2017. Support for Solaris was removed in 2020.)</p>
+<p>Some reasons for this include</p>
+<ul>
+<li><p>Exceptions. Perhaps the largest core issue with adopting the use of Standard Library facilities is exceptions. HotSpot does not use exceptions and, for platforms which allow doing so, builds with them turned off. Many Standard Library facilities implicitly or explicitly use exceptions.</p></li>
+<li><p><code>assert</code>. An issue that is quickly encountered is the <code>assert</code> macro name collision (<a href="https://bugs.openjdk.java.net/browse/JDK-8007770">JDK-8007770</a>). Some mechanism for addressing this would be needed before much of the Standard Library could be used. (Not all Standard Library implementations use assert in header files, but some do.)</p></li>
+<li><p>Memory allocation. HotSpot requires explicit control over where allocations occur. The C++98/03 <code>std::allocator</code> class is too limited to support our usage. (Changes in more recent Standards may remove this limitation.)</p></li>
+<li><p>Implementation vagaries. Bugs, or simply different implementation choices, can lead to different behaviors among the various Standard Libraries we need to deal with.</p></li>
+<li><p>Inconsistent naming conventions. HotSpot and the C++ Standard use different naming conventions. The coexistence of those different conventions might appear jarring and reduce readability.</p></li>
+</ul>
+<p>There are a few exceptions to this rule.</p>
+<ul>
+<li><code>#include &lt;new&gt;</code> to use placement <code>new</code>, <code>std::nothrow</code>, and <code>std::nothrow_t</code>.</li>
+<li><code>#include &lt;limits&gt;</code> to use <code>std::numeric_limits</code>.</li>
+<li><code>#include &lt;type_traits&gt;</code>.</li>
+<li><code>#include &lt;cstddef&gt;</code> to use <code>std::nullptr_t</code>.</li>
+</ul>
+<p>TODO: Rather than directly #including (permitted) Standard Library headers, use a convention of #including wrapper headers (in some location like hotspot/shared/stdcpp). This provides a single place for dealing with issues we might have for any given header, esp. platform-specific issues.</p>
+<h3 id="type-deduction">Type Deduction</h3>
+<p>Use type deduction only if it makes the code clearer or safer. Do not use it merely to avoid the inconvenience of writing an explicit type, unless that type is itself difficult to write. An example of the latter is a function template return type that depends on template parameters in a non-trivial way.</p>
+<p>There are several contexts where types are deduced.</p>
+<ul>
+<li><p>Function argument deduction. This is always permitted, and indeed encouraged. It is nearly always better to allow the type of a function template argument to be deduced rather than explicitly specified.</p></li>
+<li><p><code>auto</code> variable declarations (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1984.pdf">n1984</a>)<br> For local variables, this can be used to make the code clearer by eliminating type information that is obvious or irrelevant. Excessive use can make code much harder to understand.</p></li>
+<li><p>Function return type deduction (<a href="https://isocpp.org/files/papers/N3638.html">n3638</a>)<br> Only use if the function body has a very small number of <code>return</code> statements, and generally relatively little other code.</p></li>
+<li><p>Generic lambdas. Lambdas are not (yet) permitted.</p></li>
+<li><p>Lambda init captures. Lambdas are not (yet) permitted.</p></li>
+</ul>
+<h3 id="expression-sfinae">Expression SFINAE</h3>
+<p><a href="https://en.cppreference.com/w/cpp/language/sfinae" title="Substitution Failure Is Not An Error">Substitution Failure Is Not An Error</a> (SFINAE) is a template metaprogramming technique that makes use of template parameter substitution failures to make compile-time decisions.</p>
+<p>C++11 relaxed the rules for what constitutes a hard-error when attempting to substitute template parameters with template arguments, making most deduction errors be substitution errors; see (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2634.html">n2634</a>). This makes <a href="https://en.cppreference.com/w/cpp/language/sfinae" title="Substitution Failure Is Not An Error">SFINAE</a> more powerful and easier to use. However, the implementation complexity for this change is significant, and this seems to be a place where obscure corner-case bugs in various compilers can be found. So while this feature can (and indeed should) be used (and would be difficult to avoid), caution should be used when pushing to extremes.</p>
+<p>Here are a few closely related example bugs:<br> <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95468" class="uri">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95468</a><br> <a href="https://developercommunity.visualstudio.com/content/problem/396562/sizeof-deduced-type-is-sometimes-not-a-constant-ex.html" class="uri">https://developercommunity.visualstudio.com/content/problem/396562/sizeof-deduced-type-is-sometimes-not-a-constant-ex.html</a></p>
+<h3 id="enum">enum</h3>
+<p>Where appropriate, <em>scoped-enums</em> should be used. (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf">n2347</a>)</p>
+<p>Use of <em>unscoped-enums</em> is permitted, though ordinary constants may be preferable when the automatic initializer feature isn't used.</p>
+<p>The underlying type (the <em>enum-base</em>) of an unscoped enum type should always be specified explicitly. When unspecified, the underlying type is dependent on the range of the enumerator values and the platform.</p>
+<p>The underlying type of a <em>scoped-enum</em> should also be specified explicitly if conversions may be applied to values of that type.</p>
+<p>Due to bugs in certain (very old) compilers, there is widespread use of enums and avoidance of in-class initialization of static integral constant members. Compilers having such bugs are no longer supported. Except where an enum is semantically appropriate, new code should use integral constants.</p>
+<h3 id="thread_local">thread_local</h3>
+<p>Do not use <code>thread_local</code> (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2659.htm">n2659</a>); instead, use the HotSpot macro <code>THREAD_LOCAL</code>. The initializer must be a constant expression.</p>
+<p>As was discussed in the review for <a href="https://mail.openjdk.java.net/pipermail/hotspot-dev/2019-September/039487.html">JDK-8230877</a>, <code>thread_local</code> allows dynamic initialization and destruction semantics. However, that support requires a run-time penalty for references to non-function-local <code>thread_local</code> variables defined in a different translation unit, even if they don't need dynamic initialization. Dynamic initialization and destruction of namespace-scoped thread local variables also has the same ordering problems as for ordinary namespace-scoped variables.</p>
+<h3 id="nullptr">nullptr</h3>
+<p>Prefer <code>nullptr</code> (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2431.pdf">n2431</a>) to <code>NULL</code>. Don't use (constexpr or literal) 0 for pointers.</p>
+<p>For historical reasons there are widespread uses of both <code>NULL</code> and of integer 0 as a pointer value.</p>
+<h3 id="atomic">&lt;atomic&gt;</h3>
+<p>Do not use facilities provided by the <code>&lt;atomic&gt;</code> header (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html">n2427</a>), (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2752.htm">n2752</a>); instead, use the HotSpot <code>Atomic</code> class and related facilities.</p>
+<p>Atomic operations in HotSpot code must have semantics which are consistent with those provided by the JDK's compilers for Java. There are platform-specific implementation choices that a C++ compiler might make or change that are outside the scope of the C++ Standard, and might differ from what the Java compilers implement.</p>
+<p>In addition, HotSpot <code>Atomic</code> has a concept of &quot;conservative&quot; memory ordering, which may differ from (may be stronger than) sequentially consistent. There are algorithms in HotSpot that are believed to rely on that ordering.</p>
+<h3 id="additional-permitted-features">Additional Permitted Features</h3>
+<ul>
+<li><p><code>constexpr</code> (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf">n2235</a>) (<a href="https://isocpp.org/files/papers/N3652.html">n3652</a>)</p></li>
+<li><p>Sized deallocation (<a href="https://isocpp.org/files/papers/n3778.html">n3778</a>)</p></li>
+<li><p>Variadic templates (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2242.pdf">n2242</a>) (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2555.pdf">n2555</a>)</p></li>
+<li><p>Static assertions (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1720.html">n1720</a>)</p></li>
+<li><p><code>decltype</code> (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2343.pdf">n2343</a>) (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3276.pdf">n3276</a>)</p></li>
+<li><p>Right angle brackets (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1757.html">n1757</a>)</p></li>
+<li><p>Default template arguments for function templates (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#226">CWG D226</a>)</p></li>
+<li><p>Template aliases (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2258.pdf">n2258</a>)</p></li>
+<li><p>Delegating constructors (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1986.pdf">n1986</a>)</p></li>
+<li><p>Explicit conversion operators (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2437.pdf">n2437</a>)</p></li>
+<li><p>Standard Layout Types (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2342.htm">n2342</a>)</p></li>
+<li><p>Defaulted and deleted functions (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2346.htm">n2346</a>)</p></li>
+<li><p>Dynamic initialization and destruction with concurrency (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2660.htm">n2660</a>)</p></li>
+<li><p><code>final</code> virtual specifiers for classes and virtual functions (<a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2928.htm">n2928</a>), (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3206.htm">n3206</a>), (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3272.htm">n3272</a>)</p></li>
+<li><p>Local and unnamed types as template parameters (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2657.htm">n2657</a>)</p></li>
+</ul>
+<h3 id="excluded-features">Excluded Features</h3>
+<ul>
+<li>New string and character literals
+<ul>
+<li>New character types (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2249.html">n2249</a>)</li>
+<li>Unicode string literals (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2442.htm">n2442</a>)</li>
+<li>Raw string literals (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2442.htm">n2442</a>)</li>
+<li>Universal character name literals (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2170.html">n2170</a>)</li>
+</ul>
+<p>HotSpot doesn't need any of the new character and string literal types.</p></li>
+<li><p>User-defined literals (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2765.pdf">n2765</a>) — User-defined literals should not be added casually, but only through a proposal to add a specific UDL.</p></li>
+<li><p>Inline namespaces (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2535.htm">n2535</a>) — HotSpot makes very limited use of namespaces.</p></li>
+<li><p><code>using namespace</code> directives. In particular, don't use <code>using namespace std;</code> to avoid needing to qualify Standard Library names.</p></li>
+<li><p>Propagating exceptions (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2179.html">n2179</a>) — HotSpot does not permit the use of exceptions, so this feature isn't useful.</p></li>
+<li><p>Avoid namespace-scoped variables with non-constexpr initialization. In particular, avoid variables with types requiring non-trivial initialization or destruction. Initialization order problems can be difficult to deal with and lead to surprises, as can destruction ordering. HotSpot doesn't generally try to cleanup on exit, and running destructors at exit can also lead to problems.</p></li>
+<li><p><code>[[deprecated]]</code> attribute (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3760.html">n3760</a>) — Not relevant in HotSpot code.</p></li>
+<li><p>Avoid most operator overloading, preferring named functions. When operator overloading is used, ensure the semantics conform to the normal expected behavior of the operation.</p></li>
+<li><p>Avoid most implicit conversion constructors and (implicit or explicit) conversion operators. (Note that conversion to <code>bool</code> isn't needed in HotSpot code because of the &quot;no implicit boolean&quot; guideline.)</p></li>
+<li><p>Avoid covariant return types.</p></li>
+<li><p>Avoid <code>goto</code> statements.</p></li>
+</ul>
+<h3 id="undecided-features">Undecided Features</h3>
+<p>This list is incomplete; it serves to explicitly call out some features that have not yet been discussed.</p>
+<ul>
+<li><p><code>overrides</code> virtual specifiers for virtual functions (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3272.htm">n3272</a>)</p></li>
+<li><p>Trailing return type syntax for functions (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2541.htm">n2541</a>)</p></li>
+<li><p>Variable templates (<a href="https://isocpp.org/files/papers/N3651.pdf">n3651</a>)</p></li>
+<li><p>Member initializers and aggregates (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3653.html">n3653</a>)</p></li>
+<li><p><code>[[noreturn]]</code> attribute (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2761.pdf">n2761</a>)</p></li>
+<li><p>Rvalue references and move semantics</p></li>
+<li><p>Lambdas</p></li>
+</ul>
+</body>
+</html>
diff a/doc/hotspot-style.md b/doc/hotspot-style.md
--- /dev/null
+++ b/doc/hotspot-style.md
@@ -0,0 +1,810 @@
+% HotSpot Coding Style
+
+## Introduction
+
+This is a collection of rules, guidelines, and suggestions for writing
+HotSpot code.  Following these will help new code fit in with existing
+HotSpot code, making it easier to read and maintain.  Failure to
+follow these guidelines may lead to discussion during code reviews, if
+not outright rejection of a change.
+
+### Why Care About Style?
+
+Some programmers seem to have lexers and even C preprocessors
+installed directly behind their eyeballs. The rest of us require code
+that is not only functionally correct but also easy to read. More than
+that, since there is no one style for easy-to-read code, and since a
+mashup of many styles is just as confusing as no style at all, it is
+important for coders to be conscious of the many implicit stylistic
+choices that historically have gone into the HotSpot code base.
+
+Some of these guidelines are driven by the cross-platform requirements
+for HotSpot.  Shared code must work on a variety of platforms, and may
+encounter deficiencies in some.  Using platform conditionalization in
+shared code is usually avoided, while shared code is strongly
+preferred to multiple platform-dependent implementations, so some
+language features may be recommended against.
+
+Some of the guidelines here are relatively arbitrary choices among
+equally plausible alternatives.  The purpose of stating and enforcing
+these rules is largely to provide a consistent look to the code.  That
+consistency makes the code more readable by avoiding non-functional
+distractions from the interesting functionality.
+
+When changing pre-existing code, it is reasonable to adjust it to
+match these conventions. Exception: If the pre-existing code clearly
+conforms locally to its own peculiar conventions, it is not worth
+reformatting the whole thing.  Also consider separating changes that
+make extensive stylistic updates from those which make functional
+changes.
+
+### Counterexamples and Updates
+
+Many of the guidelines mentioned here have (sometimes widespread)
+counterexamples in the HotSpot code base. Finding a counterexample is
+not sufficient justification for new code to follow the counterexample
+as a precedent, since readers of your code will rightfully expect your
+code to follow the greater bulk of precedents documented here.
+
+Occasionally a guideline mentioned here may be just out of synch with
+the actual HotSpot code base. If you find that a guideline is
+consistently contradicted by a large number of counterexamples, please
+bring it up for discussion and possible change. The architectural
+rule, of course, is "When in Rome do as the Romans". Sometimes in the
+suburbs of Rome the rules are a little different; these differences
+can be pointed out here.
+
+Proposed changes should be discussed on the
+[HotSpot Developers](mailto:hotspot-dev@openjdk.java.net) mailing
+list, and approved by
+[rough consensus](https://en.wikipedia.org/wiki/Rough_consensus) of
+the [HotSpot Group](https://openjdk.java.net/census#hotspot) Members.
+The Group Lead determines whether consensus has been reached.
+Changes are likely to be cautious and incremental, since HotSpot
+coders have been using these guidelines for years.
+
+## Structure and Formatting
+
+### Factoring and Class Design
+
+* Group related code together, so readers can concentrate on one
+section of one file.
+
+* Classes are the primary code structuring mechanism.  Place related
+functionality in a class, or a set of related classes.  Use of either
+namespaces or public non-member functions is rare in HotSpot code.
+Static non-member functions are not uncommon.
+
+* If a class `FooBar` is going to be used in more than one place, put it
+a file named fooBar.hpp and fooBar.cpp. If the class is a sidekick
+to a more important class `BazBat`, it can go in bazBat.hpp.
+
+* Put a member function `FooBar::bang` into the same file that defined
+`FooBar`, or its associated *.inline.hpp or *.cpp file.
+
+* Use public accessor functions for member variables accessed
+outside the class.
+
+* Assign names to constant literals and use the names instead.
+
+* Keep functions small, a screenful at most.  Split out chunks of
+logic into file-local classes or static functions if needed.
+
+* Factor away nonessential complexity into local inline helper
+functions and helper classes.
+
+* Think clearly about internal invariants that apply to each class,
+and document them in the form of asserts within member functions.
+
+* Make simple, self-evident contracts for member functions.  If you cannot
+communicate a simple contract, redesign the class.
+
+* Implement classes as if expecting rough usage by clients. Check for
+incorrect usage of a class using `assert(...)`, `guarantee(...)`,
+`ShouldNotReachHere()` and comments wherever needed.  Performance is
+almost never a reason to omit asserts.
+
+* When possible, design as if for reusability.  This forces a clear
+design of the class's externals, and clean hiding of its internals.
+
+* Initialize all variables and data structures to a known state. If a
+class has a constructor, initialize it there.
+
+* Do no optimization before its time. Prove the need to optimize.
+
+* When you must defactor to optimize, preserve as much structure as
+possible. If you must hand-inline some name, label the local copy with
+the original name.
+
+* If you need to use a hidden detail (e.g., a structure offset), name
+it (as a constant or function) in the class that owns it.
+
+* Don't use the Copy and Paste keys to replicate more than a couple
+lines of code.  Name what you must repeat.
+
+* If a class needs a member function to change a user-visible attribute, the
+change should be done with a "setter" accessor matched to the simple
+"getter".
+
+### Files
+
+* All source files must have a globally unique basename.  The build
+system depends on this uniqueness.
+
+* Do not put non-trivial function implementations in .hpp files. If
+the implementation depends on other .hpp files, put it in a .cpp or
+a .inline.hpp file.
+
+* .inline.hpp files should only be included in .cpp or .inline.hpp
+files.
+
+* All .cpp files include precompiled.hpp as the first include line.
+
+* precompiled.hpp is just a build time optimization, so don't rely on
+it to resolve include problems.
+
+* Keep the include lines alphabetically sorted.
+
+* Put conditional inclusions (`#if ...`) at the end of the include list.
+
+### Naming
+
+* The length of a name may be correlated to the size of its scope.  In
+particular, short names (even single letter names) may be fine in a
+small scope, but are usually inappropriate for larger scopes.
+
+* Prefer whole words rather than abbreviations, unless the
+abbreviation is more widely used than the long form in the code's
+domain.
+
+* Choose names consistently. Do not introduce spurious
+variations. Abbreviate corresponding terms to a consistent length.
+
+* Global names must be unique, to avoid [One Definition Rule][ODR] (ODR)
+violations.  A common prefixing scheme for related global names is
+often used.  (This is instead of using namespaces, which are mostly
+avoided in HotSpot.)
+
+* Don't give two names to the semantically same thing.  But use
+different names for semantically different things, even if they are
+representationally the same.  (So use meaningful `typedef` or template
+alias names where appropriate.)
+
+* When choosing names, avoid categorical nouns like "variable",
+"field", "parameter", "value", and verbs like "compute", "get".
+(`storeValue(int param)` is bad.)
+
+* Type names and global names should use mixed-case with the first
+letter of each word capitalized (`FooBar`).
+
+* Embedded abbreviations in
+otherwise mixed-case names are usually capitalized entirely rather
+than being treated as a single word with only the initial letter
+capitalized, e.g. "HTML" rather than "Html".
+
+* Function and local variable names use lowercase with words separated
+by a single underscore (`foo_bar`).
+
+* Class data member names have a leading underscore, and use lowercase
+with words separated by a single underscore (`_foo_bar`).
+
+* Constant names may be upper-case or mixed-case, according to
+historical necessity.  (Note: There are many examples of constants
+with lowercase names.)
+
+* Constant names should follow an existing pattern, and must have a
+distinct appearance from other names in related APIs.
+
+* Class and type names should be noun phrases. Consider an "er" suffix
+for a class that represents an action.
+
+* Function names should be verb phrases that reflect changes of state
+known to a class's user, or else noun phrases if they cause no change
+of state visible to the class's user.
+
+* Getter accessor names are noun phrases, with no "`get_`" noise
+word. Boolean getters can also begin with "`is_`" or "`has_`".  Member
+function for reading data members usually have the same name as the
+data member, exclusive of the leading underscore.
+
+* Setter accessor names prepend "`set_`" to the getter name.
+
+* Other member function names are verb phrases, as if commands to the receiver.
+
+* Avoid leading underscores (as "`_oop`") except in cases required
+above. (Names with leading underscores can cause portability
+problems.)
+
+### Commenting
+
+* Clearly comment subtle fixes.
+
+* Clearly comment tricky classes and functions.
+
+* If you have to choose between commenting code and writing wiki
+content, comment the code. Link from the wiki to the source file if
+it makes sense.
+
+* As a general rule don't add bug numbers to comments (they would soon
+overwhelm the code). But if the bug report contains significant
+information that can't reasonably be added as a comment, then refer to
+the bug report.
+
+* Personal names are discouraged in the source code, which is a team
+product.
+
+### Macros
+
+* You can almost always use an inline function or class instead of a
+macro. Use a macro only when you really need it.
+
+* Templates may be preferable to multi-line macros. (There may be
+subtle performance effects with templates on some platforms; revert
+to macros if absolutely necessary.)
+
+* `#ifdef`s should not be used to introduce platform-specific code
+into shared code (except for `_LP64`). They must be used to manage
+header files, in the pattern found at the top of every source
+file. They should be used mainly for major build features, including
+`PRODUCT`, `ASSERT`, `_LP64`, `INCLUDE_SERIALGC`, `COMPILER1`, etc.
+
+* For build features such as `PRODUCT`, use `#ifdef PRODUCT` for
+multiple-line inclusions or exclusions.
+
+* For short inclusions or exclusions based on build features, use
+macros like `PRODUCT_ONLY` and `NOT_PRODUCT`. But avoid using them
+with multiple-line arguments, since debuggers do not handle that
+well.
+
+* Use `CATCH`, `THROW`, etc. for HotSpot-specific exception processing.
+
+### Whitespace
+
+* In general, don't change whitespace unless it improves readability
+or consistency.  Gratuitous whitespace changes will make integrations
+and backports more difficult.
+
+* Use One-True-Brace-Style. The opening brace for a function or class
+is normally at the end of the line; it is sometimes moved to the
+beginning of the next line for emphasis.  Substatements are enclosed
+in braces, even if there is only a single statement.  Extremely simple
+one-line statements may drop braces around a substatement.
+
+* Indentation levels are two columns.
+
+* There is no hard line length limit.  That said, bear in mind that
+excessively long lines can cause difficulties.  Some people like to
+have multiple side-by-side windows in their editors, and long lines
+may force them to choose among unpleasant options. They can use wide
+windows, reducing the number that can fit across the screen, and
+wasting a lot of screen real estate because most lines are not that
+long.  Alternatively, they can have more windows across the screen,
+with long lines wrapping (or worse, requiring scrolling to see in
+their entirety), which is harder to read.  Similar issues exist for
+side-by-side code reviews.
+
+* Tabs are not allowed in code. Set your editor accordingly.<br>
+(Emacs: `(setq-default indent-tabs-mode nil)`.)
+
+* Use good taste to break lines and align corresponding tokens on
+adjacent lines.
+
+* Use spaces around operators, especially comparisons and
+assignments. (Relaxable for boolean expressions and high-precedence
+operators in classic math-style formulas.)
+
+* Put spaces on both sides of control flow keywords `if`, `else`,
+`for`, `switch`, etc.  Don't add spaces around the associated
+_control_ expressions.  Examples:
+
+    ```
+    while (test_foo(args...)) {   // Yes
+    while(test_foo(args...)) {    // No, missing space after while
+    while ( test_foo(args...) ) { // No, excess spaces around control
+    ```
+
+* Use extra parentheses in expressions whenever operator precedence
+seems doubtful. Always use parentheses in shift/mask expressions
+(`<<`, `&`, `|`).  Don't add whitespace immediately inside
+parentheses.
+
+* Use more spaces and blank lines between larger constructs, such as
+classes or function definitions.
+
+* If the surrounding code has any sort of vertical organization,
+adjust new lines horizontally to be consistent with that
+organization. (E.g., trailing backslashes on long macro definitions
+often align.)
+
+### Miscellaneous
+
+* Use the [Resource Acquisition Is Initialization][RAII] (RAII)
+design pattern to manage bracketed critical
+sections. See class `ResourceMark` for an example.
+
+* Avoid implicit conversions to `bool`.
+    * Use `bool` for boolean values.
+    * Do not use ints or pointers as (implicit) booleans with `&&`, `||`,
+      `if`, `while`. Instead, compare explicitly, i.e. `if (x != 0)` or
+      `if (ptr != nullptr)`, etc.
+    * Do not use declarations in _condition_ forms, i.e. don't use
+      `if (T v = value) { ... }`.
+
+* Use functions from globalDefinitions.hpp and related files when
+performing bitwise
+operations on integers. Do not code directly as C operators, unless
+they are extremely simple. (Examples: `align_up`, `is_power_of_2`,
+`exact_log2`.)
+
+* Use arrays with abstractions supporting range checks.
+
+* Always enumerate all cases in a switch statement or provide a default
+case. It is ok to have an empty default with comment.
+
+
+## Use of C++ Features
+
+HotSpot was originally written in a subset of the C++98/03 language.
+More recently, support for C++14 is provided, though again,
+HotSpot only uses a subset.  (Backports to JDK versions lacking
+support for more recent Standards must of course stick with the
+original C++98/03 subset.)
+
+This section describes that subset.  Features from the C++98/03
+language may be used unless explicitly excluded here.  Features from
+C++11 and C++14 may be explicitly permitted or explicitly excluded,
+and discussed accordingly here.  There is a third category, undecided
+features, about which HotSpot developers have not yet reached a
+consensus, or perhaps have not discussed at all.  Use of these
+features is also excluded.
+
+(The use of some features may not be immediately obvious and may slip
+in anyway, since the compiler will accept them.  The code review
+process is the main defense against this.)
+
+Some features are discussed in their own subsection, typically to provide
+more extensive discussion or rationale for limitations.  Features that
+don't have their own subsection are listed in omnibus feature sections
+for permitted, excluded, and undecided features.
+
+Lists of new features for C++11 and C++14, along with links to their
+descriptions, can be found in the online documentation for some of the
+compilers and libraries.  The C++14 Standard is the definitive
+description.
+
+* [C++ Standards Support in GCC](https://gcc.gnu.org/projects/cxx-status.html)
+* [C++ Support in Clang](https://clang.llvm.org/cxx_status.html)
+* [Visual C++ Language Conformance](https://docs.microsoft.com/en-us/cpp/visual-cpp-language-conformance)
+* [libstdc++ Status](https://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html)
+* [libc++ Status](https://libcxx.llvm.org/cxx1y_status.html)
+
+As a rule of thumb, permitting features which simplify writing code
+and, especially, reading code, is encouraged.
+
+Similar discussions for some other projects:
+
+* [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html) &mdash;
+Currently (2020) targeting C++17.
+
+* [C++11 and C++14 use in Chromium](https://chromium-cpp.appspot.com) &mdash;
+Categorizes features as allowed, banned, or to be discussed.
+
+* [llvm Coding Standards](https://llvm.org/docs/CodingStandards.html) &mdash;
+Currently (2020) targeting C++14.
+
+* [Using C++ in Mozilla code](https://firefox-source-docs.mozilla.org/code-quality/coding-style/using_cxx_in_firefox_code.html) &mdash;
+C++17 support is required for recent versions (2020).
+
+### Error Handling
+
+Do not use exceptions. Exceptions are disabled by the build configuration
+for some platforms.
+
+Rationale: There is significant concern over the performance cost of
+exceptions and their usage model and implications for maintainable code.
+That's not just a matter of history that has been fixed; there remain
+questions and problems even today (2019). See, for example, [Zero cost
+deterministic
+exceptions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r0.pdf).
+Because of this, HotSpot has always used a build configuration that disables
+exceptions where that is available. As a result, HotSpot code uses error
+handling mechanisms such as two-phase construction, factory functions,
+returning error codes, and immediate termination. Even if the cost of
+exceptions were not a concern, the existing body of code was not written with
+exception safety in mind. Making HotSpot exception safe would be a very large
+undertaking.
+
+In addition to the usual alternatives to exceptions, HotSpot provides its
+own exception mechanism. This is based on a set of macros defined in
+utilities/exceptions.hpp.
+
+### RTTI (Runtime Type Information)
+
+Do not use [Runtime Type Information][RTTI] (RTTI).
+[RTTI][] is disabled by the build configuration for some
+platforms.  Among other things, this means `dynamic_cast` cannot be used.
+
+Rationale: Other than to implement exceptions (which HotSpot doesn't use),
+most potential uses of [RTTI][] are better done via virtual functions.  Some of
+the remainder can be replaced by bespoke mechanisms.  The cost of the
+additional runtime data structures needed to support [RTTI][] are deemed not
+worthwhile, given the alternatives.
+
+### Memory Allocation
+
+Do not use the standard global allocation and deallocation functions
+(operator new and related functions).  Use of these functions by HotSpot
+code is disabled for some platforms.
+
+Rationale: HotSpot often uses "resource" or "arena" allocation.  Even
+where heap allocation is used, the standard global functions are
+avoided in favor of wrappers around malloc and free that support the
+VM's Native Memory Tracking (NMT) feature.
+
+Native memory allocation failures are often treated as non-recoverable.
+The place where "out of memory" is (first) detected may be an innocent
+bystander, unrelated to the actual culprit.
+
+### Class Inheritance
+
+Use public single inheritance.
+
+Prefer composition rather than non-public inheritance.
+
+Restrict inheritance to the "is-a" case; use composition rather than
+non-is-a related inheritance.
+
+Avoid multiple inheritance.  Never use virtual inheritance.
+
+### Namespaces
+
+Avoid using namespaces.  HotSpot code normally uses "all static"
+classes rather than namespaces for grouping.  An "all static" class is
+not instantiable, has only static members, and is normally derived
+(possibly indirectly) from the helper class `AllStatic`.
+
+Benefits of using such classes include:
+
+* Provides access control for members, which is unavailable with
+namespaces.
+
+* Avoids [Argument Dependent Lookup][ADL] (ADL).
+
+* Closed for additional members.  Namespaces allow names to be added in
+multiple contexts, making it harder to see the complete API.
+
+Namespaces should be used only in cases where one of those "benefits"
+is actually a hindrance.
+
+In particular, don't use anonymous namespaces.  They seem like they should
+be useful, and indeed have some real benefits for naming and generated code
+size on some platforms.  Unfortunately, debuggers don't seem to like them at
+all.
+
+<https://groups.google.com/forum/#!topic/mozilla.dev.platform/KsaG3lEEaRM><br>
+Suggests Visual Studio debugger might not be able to refer to
+anonymous namespace symbols, so can't set breakpoints in them.
+Though the discussion seems to go back and forth on that.
+
+<https://firefox-source-docs.mozilla.org/code-quality/coding-style/coding_style_cpp.html><br>
+Search for "Anonymous namespaces"
+Suggests preferring "static" to anonymous namespaces where applicable,
+because of poor debugger support for anonymous namespaces.
+
+<https://sourceware.org/bugzilla/show_bug.cgi?id=16874><br>
+Bug for similar gdb problems.
+
+### C++ Standard Library
+
+Avoid using the C++ Standard Library.
+
+Historically, HotSpot has mostly avoided use of the Standard
+Library.
+
+(It used to be impossible to use most of it in shared code,
+because the build configuration for Solaris with Solaris Studio made
+all but a couple of pieces inaccessible.  Support for header-only
+parts was added in mid-2017.  Support for Solaris was removed
+in 2020.)
+
+Some reasons for this include
+
+* Exceptions. Perhaps the largest core issue with adopting the use of
+Standard Library facilities is exceptions. HotSpot does not use
+exceptions and, for platforms which allow doing so, builds with them
+turned off.  Many Standard Library facilities implicitly or explicitly
+use exceptions.
+
+* `assert`.  An issue that is quickly encountered is the `assert` macro name
+collision ([JDK-8007770](https://bugs.openjdk.java.net/browse/JDK-8007770)).
+Some mechanism for addressing this would be needed before much of the
+Standard Library could be used.  (Not all Standard Library implementations
+use assert in header files, but some do.)
+
+* Memory allocation. HotSpot requires explicit control over where
+allocations occur. The C++98/03 `std::allocator` class is too limited
+to support our usage.  (Changes in more recent Standards may remove
+this limitation.)
+
+* Implementation vagaries. Bugs, or simply different implementation choices,
+can lead to different behaviors among the various Standard Libraries we need
+to deal with.
+
+* Inconsistent naming conventions. HotSpot and the C++ Standard use
+different naming conventions. The coexistence of those different conventions
+might appear jarring and reduce readability.
+
+There are a few exceptions to this rule.
+
+* `#include <new>` to use placement `new`, `std::nothrow`, and `std::nothrow_t`.
+* `#include <limits>` to use `std::numeric_limits`.
+* `#include <type_traits>`.
+* `#include <cstddef>` to use `std::nullptr_t`.
+
+TODO: Rather than directly \#including (permitted) Standard Library
+headers, use a convention of \#including wrapper headers (in some
+location like hotspot/shared/stdcpp).  This provides a single place
+for dealing with issues we might have for any given header, esp.
+platform-specific issues.
+
+### Type Deduction
+
+Use type deduction only if it makes the code clearer or safer.  Do not
+use it merely to avoid the inconvenience of writing an explicit type,
+unless that type is itself difficult to write.  An example of the
+latter is a function template return type that depends on template
+parameters in a non-trivial way.
+
+There are several contexts where types are deduced.
+
+* Function argument deduction.  This is always permitted, and indeed
+encouraged.  It is nearly always better to allow the type of a
+function template argument to be deduced rather than explicitly
+specified.
+
+* `auto` variable declarations
+([n1984](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1984.pdf))<br>
+For local variables, this can be used to make the code clearer by
+eliminating type information that is obvious or irrelevant.  Excessive
+use can make code much harder to understand.
+
+* Function return type deduction
+([n3638](https://isocpp.org/files/papers/N3638.html))<br>
+Only use if the function body has a very small number of `return`
+statements, and generally relatively little other code.
+
+* Generic lambdas.  Lambdas are not (yet) permitted.
+
+* Lambda init captures.  Lambdas are not (yet) permitted.
+
+### Expression SFINAE
+
+[Substitution Failure Is Not An Error][SFINAE] (SFINAE)
+is a template metaprogramming technique that makes use of
+template parameter substitution failures to make compile-time decisions.
+
+C++11 relaxed the rules for what constitutes a hard-error when
+attempting to substitute template parameters with template arguments,
+making most deduction errors be substitution errors; see
+([n2634](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2634.html)).
+This makes [SFINAE][] more powerful and easier to use.  However, the
+implementation complexity for this change is significant, and this
+seems to be a place where obscure corner-case bugs in various
+compilers can be found.  So while this feature can (and indeed should)
+be used (and would be difficult to avoid), caution should be used when
+pushing to extremes.
+
+Here are a few closely related example bugs:<br>
+<https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95468><br>
+<https://developercommunity.visualstudio.com/content/problem/396562/sizeof-deduced-type-is-sometimes-not-a-constant-ex.html>
+
+### enum
+
+Where appropriate, _scoped-enums_ should be used.
+([n2347](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf)) 
+
+Use of _unscoped-enums_ is permitted, though ordinary constants may be
+preferable when the automatic initializer feature isn't used.
+
+The underlying type (the _enum-base_) of an unscoped enum type should
+always be specified explicitly.  When unspecified, the underlying type
+is dependent on the range of the enumerator values and the platform.
+
+The underlying type of a _scoped-enum_ should also be specified
+explicitly if conversions may be applied to values of that type.
+
+Due to bugs in certain (very old) compilers, there is widespread use
+of enums and avoidance of in-class initialization of static integral
+constant members.  Compilers having such bugs are no longer supported.
+Except where an enum is semantically appropriate, new code should use
+integral constants.
+
+### thread_local
+
+Do not use `thread_local`
+([n2659](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2659.htm));
+instead, use the HotSpot macro `THREAD_LOCAL`.  The initializer must
+be a constant expression.
+
+As was discussed in the review for
+[JDK-8230877](https://mail.openjdk.java.net/pipermail/hotspot-dev/2019-September/039487.html),
+`thread_local` allows dynamic initialization and destruction
+semantics.  However, that support requires a run-time penalty for
+references to non-function-local `thread_local` variables defined in a
+different translation unit, even if they don't need dynamic
+initialization.  Dynamic initialization and destruction of
+namespace-scoped thread local variables also has the same ordering
+problems as for ordinary namespace-scoped variables.
+
+### nullptr
+
+Prefer `nullptr`
+([n2431](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2431.pdf))
+to `NULL`.  Don't use (constexpr or literal) 0 for pointers. 
+
+For historical reasons there are widespread uses of both `NULL` and of
+integer 0 as a pointer value.
+
+### &lt;atomic&gt;
+
+Do not use facilities provided by the `<atomic>` header
+([n2427](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html)),
+([n2752](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2752.htm));
+instead, use the HotSpot `Atomic` class and related facilities.
+
+Atomic operations in HotSpot code must have semantics which are
+consistent with those provided by the JDK's compilers for Java.  There
+are platform-specific implementation choices that a C++ compiler might
+make or change that are outside the scope of the C++ Standard, and
+might differ from what the Java compilers implement.
+
+In addition, HotSpot `Atomic` has a concept of "conservative" memory
+ordering, which may differ from (may be stronger than) sequentially
+consistent.  There are algorithms in HotSpot that are believed to rely
+on that ordering.
+
+### Additional Permitted Features
+
+* `constexpr`
+([n2235](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf)) 
+([n3652](https://isocpp.org/files/papers/N3652.html))
+
+* Sized deallocation
+([n3778](https://isocpp.org/files/papers/n3778.html))
+
+* Variadic templates
+([n2242](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2242.pdf))
+([n2555](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2555.pdf))
+
+* Static assertions
+([n1720](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1720.html))
+
+* `decltype`
+([n2343](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2343.pdf))
+([n3276](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3276.pdf))
+
+* Right angle brackets
+([n1757](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1757.html))
+
+* Default template arguments for function templates
+([CWG D226](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#226))
+
+* Template aliases
+([n2258](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2258.pdf))
+
+* Delegating constructors
+([n1986](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1986.pdf))
+
+* Explicit conversion operators
+([n2437](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2437.pdf))
+
+* Standard Layout Types
+([n2342](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2342.htm))
+
+* Defaulted and deleted functions
+([n2346](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2346.htm))
+
+* Dynamic initialization and destruction with concurrency
+([n2660](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2660.htm))
+
+* `final` virtual specifiers for classes and virtual functions
+([n2928](http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2928.htm)),
+([n3206](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3206.htm)),
+([n3272](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3272.htm))
+
+* Local and unnamed types as template parameters
+([n2657](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2657.htm))
+
+### Excluded Features
+
+* New string and character literals
+    * New character types
+    ([n2249](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2249.html))
+    * Unicode string literals
+    ([n2442](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2442.htm))
+    * Raw string literals
+    ([n2442](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2442.htm))
+    * Universal character name literals
+    ([n2170](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2170.html))
+
+    HotSpot doesn't need any of the new character and string literal
+    types.
+
+* User-defined literals
+([n2765](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2765.pdf)) &mdash;
+User-defined literals should not be added casually, but only
+through a proposal to add a specific UDL.
+
+* Inline namespaces
+([n2535](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2535.htm)) &mdash;
+HotSpot makes very limited use of namespaces.
+
+* `using namespace` directives.  In particular, don't use `using
+namespace std;` to avoid needing to qualify Standard Library names.
+
+* Propagating exceptions
+([n2179](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2179.html)) &mdash;
+HotSpot does not permit the use of exceptions, so this feature isn't useful.
+
+* Avoid namespace-scoped variables with non-constexpr initialization.
+In particular, avoid variables with types requiring non-trivial
+initialization or destruction.  Initialization order problems can be
+difficult to deal with and lead to surprises, as can destruction
+ordering.  HotSpot doesn't generally try to cleanup on exit, and
+running destructors at exit can also lead to problems.
+
+* `[[deprecated]]` attribute
+([n3760](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3760.html)) &mdash;
+Not relevant in HotSpot code.
+
+* Avoid most operator overloading, preferring named functions.  When
+operator overloading is used, ensure the semantics conform to the
+normal expected behavior of the operation.
+
+* Avoid most implicit conversion constructors and (implicit or explicit)
+conversion operators.  (Note that conversion to `bool` isn't needed
+in HotSpot code because of the "no implicit boolean" guideline.)
+
+* Avoid covariant return types.
+
+* Avoid `goto` statements. 
+
+### Undecided Features
+
+This list is incomplete; it serves to explicitly call out some
+features that have not yet been discussed.
+
+* `overrides` virtual specifiers for virtual functions 
+([n3272](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3272.htm))
+
+* Trailing return type syntax for functions 
+([n2541](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2541.htm))
+
+* Variable templates
+([n3651](https://isocpp.org/files/papers/N3651.pdf))
+
+* Member initializers and aggregates
+([n3653](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3653.html))
+
+* `[[noreturn]]` attribute
+([n2761](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2761.pdf))
+
+* Rvalue references and move semantics
+
+* Lambdas
+
+
+[ADL]: https://en.cppreference.com/w/cpp/language/adl 
+  "Argument Dependent Lookup"
+
+[ODR]: https://en.cppreference.com/w/cpp/language/definition
+  "One Definition Rule"
+
+[RAII]: https://en.cppreference.com/w/cpp/language/raii
+  "Resource Acquisition Is Initialization"
+
+[RTTI]: https://en.wikipedia.org/wiki/Run-time_type_information
+  "Runtime Type Information"
+
+[SFINAE]: https://en.cppreference.com/w/cpp/language/sfinae
+  "Substitution Failure Is Not An Error"
diff a/make/Main.gmk b/make/Main.gmk
--- a/make/Main.gmk
+++ b/make/Main.gmk
@@ -676,11 +676,11 @@
     MAKEFILE := test/JtregGraalUnit, \
     TARGET := test-image-hotspot-jtreg-graal, \
     DEPS := build-test-hotspot-jtreg-graal, \
 ))
 
-ifneq ($GTEST_FRAMEWORK_SRC), )
+ifneq ($(GTEST_FRAMEWORK_SRC), )
   $(eval $(call SetupTarget, test-image-hotspot-gtest, \
       MAKEFILE := hotspot/test/GtestImage, \
       DEPS := hotspot, \
   ))
 endif
diff a/make/common/modules/LauncherCommon.gmk b/make/common/modules/LauncherCommon.gmk
--- a/make/common/modules/LauncherCommon.gmk
+++ b/make/common/modules/LauncherCommon.gmk
@@ -100,16 +100,26 @@
       $$(addprefix -J, $$($1_JAVA_ARGS)) $$($1_LAUNCHER_CLASS), "$$a"$(COMMA) )) }'
   $1_CFLAGS += -DJAVA_ARGS=$$($1_JAVA_ARGS_STR)
 
   ifeq ($(call isTargetOs, macosx), true)
     ifeq ($$($1_MACOSX_PRIVILEGED), true)
-      $1_PLIST_FILE := Info-privileged.plist
+      $1_PLIST_SRC_FILE := Info-privileged.plist
     else
-      $1_PLIST_FILE := Info-cmdline.plist
+      $1_PLIST_SRC_FILE := Info-cmdline.plist
     endif
 
-    $1_LDFLAGS += -sectcreate __TEXT __info_plist $(MACOSX_PLIST_DIR)/$$($1_PLIST_FILE)
+    $1_PLIST_FILE := $$(SUPPORT_OUTPUTDIR)/native/$$(MODULE)/$1/Info.plist
+
+    $$(eval $$(call SetupTextFileProcessing, BUILD_PLIST_$1, \
+        SOURCE_FILES := $$(TOPDIR)/src/java.base/macosx/native/launcher/$$($1_PLIST_SRC_FILE), \
+        OUTPUT_FILE := $$($1_PLIST_FILE), \
+        REPLACEMENTS := \
+            @@ID@@ => $(MACOSX_BUNDLE_ID_BASE).$(VERSION_SHORT).$1 ; \
+            @@VERSION@@ => $(VERSION_NUMBER) ; \
+    ))
+
+    $1_LDFLAGS += -sectcreate __TEXT __info_plist $$($1_PLIST_FILE)
 
     ifeq ($(STATIC_BUILD), true)
       $1_LDFLAGS += -exported_symbols_list \
               $(SUPPORT_OUTPUTDIR)/build-static/exported.symbols
       $1_LIBS += \
@@ -165,10 +175,12 @@
   ))
 
   $1 += $$(BUILD_LAUNCHER_$1)
   TARGETS += $$($1)
 
+  $$(BUILD_LAUNCHER_$1): $$(BUILD_PLIST_$1)
+
   ifeq ($(call isTargetOs, aix), true)
     $$(BUILD_LAUNCHER_$1): $(call FindStaticLib, java.base, jli_static)
   endif
 
   ifeq ($(call isTargetOs, windows), true)
diff a/make/conf/jib-profiles.js b/make/conf/jib-profiles.js
--- a/make/conf/jib-profiles.js
+++ b/make/conf/jib-profiles.js
@@ -1067,19 +1067,19 @@
             revision: "1.21+1.0"
         },
 
         jcov: {
             // Until an official build of JCov is available, use custom
-            // build to support classfile version 57.
-            // See CODETOOLS-7902358 for more info.
+            // build to support classfile version 60.
+            // See CODETOOLS-7902734 for more info.
             // server: "jpg",
             // product: "jcov",
             // version: "3.0",
             // build_number: "b07",
             // file: "bundles/jcov-3_0.zip",
             organization: common.organization,
-            revision: "3.0-59-support+1.0",
+            revision: "3.0-60-support+1.0",
             ext: "zip",
             environment_name: "JCOV_HOME",
         },
 
         gnumake: {
diff a/make/data/bundle/JDK-Info.plist b/make/data/bundle/JDK-Info.plist
--- a/make/data/bundle/JDK-Info.plist
+++ b/make/data/bundle/JDK-Info.plist
@@ -20,10 +20,12 @@
         <string>1.0</string>
         <key>CFBundleSignature</key>
         <string>????</string>
         <key>CFBundleVersion</key>
         <string>@@VERSION@@</string>
+        <key>NSMicrophoneUsageDescription</key>
+        <string>The application is requesting access to the microphone.</string>
         <key>JavaVM</key>
         <dict>
                 <key>JVMCapabilities</key>
                 <array>
                         <string>CommandLine</string>
diff a/make/data/bundle/JRE-Info.plist b/make/data/bundle/JRE-Info.plist
--- a/make/data/bundle/JRE-Info.plist
+++ b/make/data/bundle/JRE-Info.plist
@@ -20,10 +20,12 @@
         <string>1.0</string>
         <key>CFBundleSignature</key>
         <string>????</string>
         <key>CFBundleVersion</key>
         <string>@@VERSION@@</string>
+        <key>NSMicrophoneUsageDescription</key>
+        <string>The application is requesting access to the microphone.</string>
         <key>JavaVM</key>
         <dict>
                 <key>JVMMinimumFrameworkVersion</key>
                 <string>13.2.9</string>
                 <key>JVMMinimumSystemVersion</key>
diff a/make/data/cacerts/entrustrootcag4 b/make/data/cacerts/entrustrootcag4
--- /dev/null
+++ b/make/data/cacerts/entrustrootcag4
@@ -0,0 +1,43 @@
+Owner: CN=Entrust Root Certification Authority - G4, OU="(c) 2015 Entrust, Inc. - for authorized use only", OU=See www.entrust.net/legal-terms, O="Entrust, Inc.", C=US
+Issuer: CN=Entrust Root Certification Authority - G4, OU="(c) 2015 Entrust, Inc. - for authorized use only", OU=See www.entrust.net/legal-terms, O="Entrust, Inc.", C=US
+Serial number: d9b5437fafa9390f000000005565ad58
+Valid from: Wed May 27 11:11:16 GMT 2015 until: Sun Dec 27 11:41:16 GMT 2037
+Signature algorithm name: SHA256withRSA
+Subject Public Key Algorithm: 4096-bit RSA key
+Version: 3
+-----BEGIN CERTIFICATE-----
+MIIGSzCCBDOgAwIBAgIRANm1Q3+vqTkPAAAAAFVlrVgwDQYJKoZIhvcNAQELBQAw
+gb4xCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMSgwJgYDVQQL
+Ex9TZWUgd3d3LmVudHJ1c3QubmV0L2xlZ2FsLXRlcm1zMTkwNwYDVQQLEzAoYykg
+MjAxNSBFbnRydXN0LCBJbmMuIC0gZm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxMjAw
+BgNVBAMTKUVudHJ1c3QgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEc0
+MB4XDTE1MDUyNzExMTExNloXDTM3MTIyNzExNDExNlowgb4xCzAJBgNVBAYTAlVT
+MRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMSgwJgYDVQQLEx9TZWUgd3d3LmVudHJ1
+c3QubmV0L2xlZ2FsLXRlcm1zMTkwNwYDVQQLEzAoYykgMjAxNSBFbnRydXN0LCBJ
+bmMuIC0gZm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxMjAwBgNVBAMTKUVudHJ1c3Qg
+Um9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEc0MIICIjANBgkqhkiG9w0B
+AQEFAAOCAg8AMIICCgKCAgEAsewsQu7i0TD/pZJH4i3DumSXbcr3DbVZwbPLqGgZ
+2K+EbTBwXX7zLtJTmeH+H17ZSK9dE43b/2MzTdMAArzE+NEGCJR5WIoV3imz/f3E
+T+iq4qA7ec2/a0My3dl0ELn39GjUu9CH1apLiipvKgS1sqbHoHrmSKvS0VnM1n4j
+5pds8ELl3FFLFUHtSUrJ3hCX1nbB76W1NhSXNdh4IjVS70O92yfbYVaCNNzLiGAM
+C1rlLAHGVK/XqsEQe9IFWrhAnoanw5CGAlZSCXqc0ieCU0plUmr1POeo8pyvi73T
+DtTUXm6Hnmo9RR3RXRv06QqsYJn7ibT/mCzPfB3pAqoEmh643IhuJbNsZvc8kPNX
+wbMv9W3y+8qh+CmdRouzavbmZwe+LGcKKh9asj5XxNMhIWNlUpEbsZmOeX7m640A
+2Vqq6nPopIICR5b+W45UYaPrL0swsIsjdXJ8ITzI9vF01Bx7owVV7rtNOzK+mndm
+nqxpkCIHH2E6lr7lmk/MBTwoWdPBDFSoWWG9yHJM6Nyfh3+9nEg2XpWjDrk4JFX8
+dWbrAuMINClKxuMrLzOg2qOGpRKX/YAr2hRC45K9PvJdXmd0LhyIRyk0X+IyqJwl
+N4y6mACXi0mWHv0liqzc2thddG5msP9E36EYxr5ILzeUePiVSj9/E15dWf10hkNj
+c0kCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYD
+VR0OBBYEFJ84xFYjwznooHFs6FRM5Og6sb9nMA0GCSqGSIb3DQEBCwUAA4ICAQAS
+5UKme4sPDORGpbZgQIeMJX6tuGguW8ZAdjwD+MlZ9POrYs4QjbRaZIxowLByQzTS
+Gwv2LFPSypBLhmb8qoMi9IsabyZIrHZ3CL/FmFz0Jomee8O5ZDIBf9PD3Vht7LGr
+hFV0d4QEJ1JrhkzO3bll/9bGXp+aEJlLdWr+aumXIOTkdnrG0CSqkM0gkLpHZPt/
+B7NTeLUKYvJzQ85BK4FqLoUWlFPUa19yIqtRLULVAJyZv967lDtX/Zr1hstWO1uI
+AeV8KEsD+UmDfLJ/fOPtjqF/YFOOVZ1QNBIPt5d7bIdKROf1beyAN/BYGW5KaHbw
+H5Lk6rWS02FREAutp9lfx1/cH6NcjKF+m7ee01ZvZl4HliDtC3T7Zk6LERXpgUl+
+b7DUUH8i119lAg2m9IUe2K4GS0qn0jFmwvjO5QimpAKWRGhXxNUzzxkvFMSUHHuk
+2fCfDrGA4tGeEWSpiBE6doLlYsKA2KSD7ZPvfC+QsDJMlhVoSFLUmQjAJOgc47Ol
+IQ6SwJAfzyBfyjs4x7dtOvPmRLgOMWuIjnDrnBdSqEGULoe256YSxXXfW8AKbnuk
+5F6G+TaU33fD6Q3AOfF5u0aOq0NZJ7cguyPpVkAh7DE9ZapD8j3fcEThuk0mEDuY
+n/PIjhs4ViFqUZPTkcpG2om3PVODLAgfi49T3f+sHw==
+-----END CERTIFICATE-----
diff a/make/data/symbols/java.base-F.sym.txt b/make/data/symbols/java.base-F.sym.txt
--- a/make/data/symbols/java.base-F.sym.txt
+++ b/make/data/symbols/java.base-F.sym.txt
@@ -67,10 +67,13 @@
 
 class name java/lang/Math
 method name absExact descriptor (I)I flags 9
 method name absExact descriptor (J)J flags 9
 
+class name java/lang/NullPointerException
+method name fillInStackTrace descriptor ()Ljava/lang/Throwable; flags 21
+
 class name java/lang/Short
 header extends java/lang/Number implements java/lang/Comparable,java/lang/constant/Constable flags 31 signature Ljava/lang/Number;Ljava/lang/Comparable<Ljava/lang/Short;>;Ljava/lang/constant/Constable;
 method name describeConstable descriptor ()Ljava/util/Optional; flags 1 signature ()Ljava/util/Optional<Ljava/lang/constant/DynamicConstantDesc<Ljava/lang/Short;>;>;
 
 class name java/lang/StrictMath
diff a/make/hotspot/symbols/symbols-linux b/make/hotspot/symbols/symbols-linux
--- a/make/hotspot/symbols/symbols-linux
+++ b/make/hotspot/symbols/symbols-linux
@@ -20,8 +20,9 @@
 # or visit www.oracle.com if you need additional information or have any
 # questions.
 #
 
 JVM_handle_linux_signal
+JVM_IsUseContainerSupport
 numa_error
 numa_warn
 sysThreadAvailableStackWithSlack
diff a/make/modules/java.desktop/lib/Awt2dLibraries.gmk b/make/modules/java.desktop/lib/Awt2dLibraries.gmk
--- a/make/modules/java.desktop/lib/Awt2dLibraries.gmk
+++ b/make/modules/java.desktop/lib/Awt2dLibraries.gmk
@@ -430,14 +430,19 @@
   TARGETS += $(BUILD_LIBFREETYPE)
 endif
 
 ###########################################################################
 
-#### Begin harfbuzz configuration
-
 HARFBUZZ_CFLAGS := -DHAVE_OT -DHAVE_FALLBACK -DHAVE_UCDN -DHAVE_ROUND
 
+# This is better than adding EXPORT_ALL_SYMBOLS
+ifneq ($(filter $(TOOLCHAIN_TYPE), gcc clang), )
+  HARFBUZZ_CFLAGS += -DHB_EXTERN=__attribute__\(\(visibility\(\"default\"\)\)\)
+else ifeq ($(TOOLCHAIN_TYPE), microsoft)
+  HARFBUZZ_CFLAGS += -DHB_EXTERN=__declspec\(dllexport\)
+endif
+
 ifeq ($(call isTargetOs, windows), false)
   HARFBUZZ_CFLAGS += -DGETPAGESIZE -DHAVE_MPROTECT -DHAVE_PTHREAD \
                       -DHAVE_SYSCONF -DHAVE_SYS_MMAN_H -DHAVE_UNISTD_H \
                       -DHB_NO_PRAGMA_GCC_DIAGNOSTIC
 endif
@@ -446,31 +451,78 @@
 endif
 ifeq ($(call isTargetOs, macosx), true)
   HARFBUZZ_CFLAGS += -DHAVE_CORETEXT
 endif
 ifeq ($(call isTargetOs, macosx), false)
-  LIBFONTMANAGER_EXCLUDE_FILES += harfbuzz/hb-coretext.cc
+  LIBHARFBUZZ_EXCLUDE_FILES += harfbuzz/hb-coretext.cc
 endif
 # hb-ft.cc is not presently needed, and requires freetype 2.4.2 or later.
-LIBFONTMANAGER_EXCLUDE_FILES += harfbuzz/hb-ft.cc
+LIBHARFBUZZ_EXCLUDE_FILES += harfbuzz/hb-ft.cc
 
-LIBFONTMANAGER_CFLAGS += $(HARFBUZZ_CFLAGS)
+LIBHARFBUZZ_CFLAGS += $(HARFBUZZ_CFLAGS)
+
+# For use by libfontmanager:
+ifeq ($(call isTargetOs, windows), true)
+  LIBHARFBUZZ_LIBS := $(SUPPORT_OUTPUTDIR)/native/$(MODULE)/libharfbuzz/harfbuzz.lib
+else
+  LIBHARFBUZZ_LIBS := -lharfbuzz
+endif
+
+LIBHARFBUZZ_EXTRA_HEADER_DIRS := \
+    libharfbuzz/hb-ucdn \
+    #
 
-#### End harfbuzz configuration
+LIBHARFBUZZ_OPTIMIZATION := HIGH
+
+LIBHARFBUZZ_CFLAGS += $(X_CFLAGS) -DLE_STANDALONE -DHEADLESS
+
+$(eval $(call SetupJdkLibrary, BUILD_LIBHARFBUZZ, \
+    NAME := harfbuzz, \
+    EXCLUDE_FILES := $(LIBHARFBUZZ_EXCLUDE_FILES), \
+    TOOLCHAIN := TOOLCHAIN_LINK_CXX, \
+    CFLAGS := $(CFLAGS_JDKLIB) $(LIBHARFBUZZ_CFLAGS), \
+    CXXFLAGS := $(CXXFLAGS_JDKLIB) $(LIBHARFBUZZ_CFLAGS), \
+    OPTIMIZATION := $(LIBHARFBUZZ_OPTIMIZATION), \
+    CFLAGS_windows = -DCC_NOEX, \
+    EXTRA_HEADER_DIRS := $(LIBHARFBUZZ_EXTRA_HEADER_DIRS), \
+    WARNINGS_AS_ERRORS_xlc := false, \
+    DISABLED_WARNINGS_gcc := type-limits missing-field-initializers strict-aliasing, \
+    DISABLED_WARNINGS_CXX_gcc := reorder delete-non-virtual-dtor strict-overflow \
+        maybe-uninitialized class-memaccess, \
+    DISABLED_WARNINGS_clang := unused-value incompatible-pointer-types \
+        tautological-constant-out-of-range-compare int-to-pointer-cast \
+        undef missing-field-initializers, \
+    DISABLED_WARNINGS_microsoft := 4267 4244 4090 4146 4334 4819 4101 4068 4805 4138, \
+    LDFLAGS := $(LDFLAGS_JDKLIB) \
+        $(call SET_SHARED_LIBRARY_ORIGIN), \
+    LDFLAGS_unix := -L$(INSTALL_LIBRARIES_HERE), \
+    LDFLAGS_aix := -Wl$(COMMA)-berok, \
+    LIBS := $(BUILD_LIBHARFBUZZ), \
+    LIBS_unix := $(LIBM) $(LIBCXX), \
+    LIBS_macosx := -framework CoreText -framework CoreFoundation -framework CoreGraphics, \
+    LIBS_windows := user32.lib, \
+))
+
+ifeq ($(FREETYPE_TO_USE), bundled)
+  $(BUILD_LIBHARFBUZZ): $(BUILD_LIBFREETYPE)
+endif
+
+TARGETS += $(BUILD_LIBHARFBUZZ)
+
+###########################################################################
 
 LIBFONTMANAGER_EXTRA_HEADER_DIRS := \
-    libfontmanager/harfbuzz \
-    libfontmanager/harfbuzz/hb-ucdn \
+    libharfbuzz \
     common/awt \
     common/font \
     libawt/java2d \
     libawt/java2d/pipe \
     libawt/java2d/loops \
     #
 
-LIBFONTMANAGER_CFLAGS += $(LIBFREETYPE_CFLAGS)
-BUILD_LIBFONTMANAGER_FONTLIB += $(LIBFREETYPE_LIBS)
+LIBFONTMANAGER_CFLAGS += $(LIBFREETYPE_CFLAGS) $(HARFBUZZ_FLAGS)
+BUILD_LIBFONTMANAGER_FONTLIB += $(LIBHARFBUZZ_LIBS) $(LIBFREETYPE_LIBS)
 
 LIBFONTMANAGER_OPTIMIZATION := HIGH
 
 ifeq ($(call isTargetOs, windows), true)
   LIBFONTMANAGER_EXCLUDE_FILES += X11FontScaler.c \
@@ -507,33 +559,26 @@
     CXXFLAGS := $(CXXFLAGS_JDKLIB) $(LIBFONTMANAGER_CFLAGS), \
     OPTIMIZATION := $(LIBFONTMANAGER_OPTIMIZATION), \
     CFLAGS_windows = -DCC_NOEX, \
     EXTRA_HEADER_DIRS := $(LIBFONTMANAGER_EXTRA_HEADER_DIRS), \
     WARNINGS_AS_ERRORS_xlc := false, \
-    DISABLED_WARNINGS_gcc := sign-compare int-to-pointer-cast \
-        type-limits missing-field-initializers implicit-fallthrough \
-        strict-aliasing undef unused-function, \
-    DISABLED_WARNINGS_CXX_gcc := reorder delete-non-virtual-dtor strict-overflow \
-        maybe-uninitialized class-memaccess, \
-    DISABLED_WARNINGS_clang := unused-value incompatible-pointer-types \
-        tautological-constant-out-of-range-compare int-to-pointer-cast \
-        sign-compare undef missing-field-initializers, \
-    DISABLED_WARNINGS_microsoft := 4267 4244 4018 4090 4996 4146 4334 4819 4101 4068 4805 4138, \
+    DISABLED_WARNINGS_gcc := sign-compare unused-function int-to-pointer-cast, \
+    DISABLED_WARNINGS_clang := sign-compare, \
+    DISABLED_WARNINGS_microsoft := 4018 4146 4244 4996, \
     LDFLAGS := $(subst -Xlinker -z -Xlinker defs,, \
         $(subst -Wl$(COMMA)-z$(COMMA)defs,,$(LDFLAGS_JDKLIB))) $(LDFLAGS_CXX_JDK) \
         $(call SET_SHARED_LIBRARY_ORIGIN), \
     LDFLAGS_unix := -L$(INSTALL_LIBRARIES_HERE), \
     LDFLAGS_aix := -Wl$(COMMA)-berok, \
     LIBS := $(BUILD_LIBFONTMANAGER_FONTLIB), \
     LIBS_unix := -lawt -ljava -ljvm $(LIBM) $(LIBCXX), \
-    LIBS_macosx := -lawt_lwawt -framework CoreText -framework CoreFoundation \
-        -framework CoreGraphics, \
+    LIBS_macosx := -lawt_lwawt, \
     LIBS_windows := $(WIN_JAVA_LIB) advapi32.lib user32.lib gdi32.lib \
         $(WIN_AWT_LIB), \
 ))
 
-$(BUILD_LIBFONTMANAGER): $(BUILD_LIBAWT)
+$(BUILD_LIBFONTMANAGER): $(BUILD_LIBAWT) $(BUILD_LIBHARFBUZZ)
 
 ifeq ($(call isTargetOs, macosx), true)
   $(BUILD_LIBFONTMANAGER): $(call FindLib, $(MODULE), awt_lwawt)
 endif
 
diff a/src/hotspot/cpu/aarch64/aarch64.ad b/src/hotspot/cpu/aarch64/aarch64.ad
--- a/src/hotspot/cpu/aarch64/aarch64.ad
+++ b/src/hotspot/cpu/aarch64/aarch64.ad
@@ -3705,11 +3705,11 @@
   stack_direction(TOWARDS_LOW);
 
   // These three registers define part of the calling convention
   // between compiled code and the interpreter.
 
-  // Inline Cache Register or methodOop for I2C.
+  // Inline Cache Register or Method for I2C.
   inline_cache_reg(R12);
 
   // Method Oop Register when calling interpreter.
   interpreter_method_oop_reg(R12);
 
@@ -4056,10 +4056,22 @@
   op_cost(0);
   format %{ %}
   interface(CONST_INTER);
 %}
 
+operand immL_positive_bitmaskI()
+%{
+  predicate((n->get_long() != 0)
+            && ((julong)n->get_long() < 0x80000000ULL)
+            && is_power_of_2(n->get_long() + 1));
+  match(ConL);
+
+  op_cost(0);
+  format %{ %}
+  interface(CONST_INTER);
+%}
+
 // Scale values for scaled offset addressing modes (up to long but not quad)
 operand immIScale()
 %{
   predicate(0 <= n->get_int() && (n->get_int() <= 3));
   match(ConI);
@@ -12152,10 +12164,54 @@
           as_Register($src$$reg), lshift, width);
   %}
   ins_pipe(ialu_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
+
+// We can use ubfiz when masking by a positive number and then left shifting the result.
+// We know that the mask is positive because immI_bitmask guarantees it.
+instruct ubfizwIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI lshift, immI_bitmask mask)
+%{
+  match(Set dst (ConvI2L (LShiftI (AndI src mask) lshift)));
+  predicate((exact_log2(n->in(1)->in(1)->in(2)->get_int() + 1) + (n->in(1)->in(2)->get_int() & 31)) <= 31);
+
+  ins_cost(INSN_COST);
+  format %{ "ubfizw $dst, $src, $lshift, $mask" %}
+  ins_encode %{
+    int lshift = $lshift$$constant & 31;
+    intptr_t mask = $mask$$constant;
+    int width = exact_log2(mask+1);
+    __ ubfizw(as_Register($dst$$reg),
+          as_Register($src$$reg), lshift, width);
+  %}
+  ins_pipe(ialu_reg_shift);
+%}
+
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
+
+// We can use ubfiz when masking by a positive number and then left shifting the result.
+// We know that the mask is positive because immL_bitmask guarantees it.
+instruct ubfizLConvL2I(iRegINoSp dst, iRegL src, immI lshift, immL_positive_bitmaskI mask)
+%{
+  match(Set dst (ConvL2I (LShiftL (AndL src mask) lshift)));
+  predicate((exact_log2_long(n->in(1)->in(1)->in(2)->get_long() + 1) + (n->in(1)->in(2)->get_int() & 63)) <= 31);
+
+  ins_cost(INSN_COST);
+  format %{ "ubfiz $dst, $src, $lshift, $mask" %}
+  ins_encode %{
+    int lshift = $lshift$$constant & 63;
+    intptr_t mask = $mask$$constant;
+    int width = exact_log2_long(mask+1);
+    __ ubfiz(as_Register($dst$$reg),
+          as_Register($src$$reg), lshift, width);
+  %}
+  ins_pipe(ialu_reg_shift);
+%}
+
 
 // This pattern is automatically generated from aarch64_ad.m4
 // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 
 // If there is a convert I to L block between and AndI and a LShiftL, we can also match ubfiz
@@ -12174,10 +12230,46 @@
              as_Register($src$$reg), lshift, width);
   %}
   ins_pipe(ialu_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
+
+// If there is a convert L to I block between and AndL and a LShiftI, we can also match ubfiz
+instruct ubfizLConvL2Ix(iRegINoSp dst, iRegL src, immI lshift, immL_positive_bitmaskI mask)
+%{
+  match(Set dst (LShiftI (ConvL2I (AndL src mask)) lshift));
+  predicate((exact_log2_long(n->in(1)->in(1)->in(2)->get_long() + 1) + (n->in(2)->get_int() & 31)) <= 31);
+
+  ins_cost(INSN_COST);
+  format %{ "ubfiz $dst, $src, $lshift, $mask" %}
+  ins_encode %{
+    int lshift = $lshift$$constant & 31;
+    intptr_t mask = $mask$$constant;
+    int width = exact_log2(mask+1);
+    __ ubfiz(as_Register($dst$$reg),
+             as_Register($src$$reg), lshift, width);
+  %}
+  ins_pipe(ialu_reg_shift);
+%}
+
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
+
+// Can skip int2long conversions after AND with small bitmask
+instruct ubfizIConvI2LAndI(iRegLNoSp dst, iRegI src, immI_bitmask msk)
+%{
+  match(Set dst (ConvI2L (AndI src msk)));
+  ins_cost(INSN_COST);
+  format %{ "ubfiz $dst, $src, 0, exact_log2($msk + 1) " %}
+  ins_encode %{
+    __ ubfiz(as_Register($dst$$reg), as_Register($src$$reg), 0, exact_log2($msk$$constant + 1));
+  %}
+  ins_pipe(ialu_reg_shift);
+%}
+
 
 // Rotations 
 // This pattern is automatically generated from aarch64_ad.m4
 // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct extrOrL(iRegLNoSp dst, iRegL src1, iRegL src2, immI lshift, immI rshift, rFlagsReg cr)
@@ -15481,17 +15573,17 @@
 
 // Tail Call; Jump from runtime stub to Java code.
 // Also known as an 'interprocedural jump'.
 // Target of jump will eventually return to caller.
 // TailJump below removes the return address.
-instruct TailCalljmpInd(iRegPNoSp jump_target, inline_cache_RegP method_oop)
+instruct TailCalljmpInd(iRegPNoSp jump_target, inline_cache_RegP method_ptr)
 %{
-  match(TailCall jump_target method_oop);
+  match(TailCall jump_target method_ptr);
 
   ins_cost(CALL_COST);
 
-  format %{ "br $jump_target\t# $method_oop holds method oop" %}
+  format %{ "br $jump_target\t# $method_ptr holds method" %}
 
   ins_encode(aarch64_enc_tail_call(jump_target));
 
   ins_pipe(pipe_class_call);
 %}
diff a/src/hotspot/cpu/aarch64/aarch64_ad.m4 b/src/hotspot/cpu/aarch64/aarch64_ad.m4
--- a/src/hotspot/cpu/aarch64/aarch64_ad.m4
+++ b/src/hotspot/cpu/aarch64/aarch64_ad.m4
@@ -235,50 +235,73 @@
 define(`UBFIZ_INSN', `// This pattern is automatically generated from aarch64_ad.m4
 // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 
 // We can use ubfiz when masking by a positive number and then left shifting the result.
 // We know that the mask is positive because imm$1_bitmask guarantees it.
-instruct $2$1(iReg$1NoSp dst, iReg$1`'ORL2I($1) src, immI lshift, imm$1_bitmask mask)
+instruct $3$1$8(iReg$2NoSp dst, iReg$1`'ORL2I($1) src, immI lshift, $7 mask)
 %{
-  match(Set dst (LShift$1 (And$1 src mask) lshift));
-  predicate((exact_log2$5(n->in(1)->in(2)->get_$4() + 1) + (n->in(2)->get_int() & $3)) <= ($3 + 1));
+  ifelse($8,,
+    match(Set dst (LShift$1 (And$1 src mask) lshift));,
+    match(Set dst ($8 (LShift$1 (And$1 src mask) lshift)));)
+  ifelse($8,,
+    predicate(($6(n->in(1)->in(2)->get_$5() + 1) + (n->in(2)->get_int() & $4)) <= ($4 + 1));,
+    predicate(($6(n->in(1)->in(1)->in(2)->get_$5() + 1) + (n->in(1)->in(2)->get_int() & $4)) <= 31);)
 
   ins_cost(INSN_COST);
-  format %{ "$2 $dst, $src, $lshift, $mask" %}
+  format %{ "$3 $dst, $src, $lshift, $mask" %}
   ins_encode %{
-    int lshift = $lshift$$constant & $3;
+    int lshift = $lshift$$constant & $4;
     intptr_t mask = $mask$$constant;
-    int width = exact_log2$5(mask+1);
-    __ $2(as_Register($dst$$reg),
+    int width = $6(mask+1);
+    __ $3(as_Register($dst$$reg),
           as_Register($src$$reg), lshift, width);
   %}
   ins_pipe(ialu_reg_shift);
 %}
 ')
-UBFIZ_INSN(I, ubfizw, 31, int)
-UBFIZ_INSN(L, ubfiz,  63, long, _long)
+UBFIZ_INSN(I, I, ubfizw, 31, int,  exact_log2,      immI_bitmask)
+UBFIZ_INSN(L, L, ubfiz,  63, long, exact_log2_long, immL_bitmask)
+UBFIZ_INSN(I, L, ubfizw, 31, int,  exact_log2,      immI_bitmask,           ConvI2L)
+UBFIZ_INSN(L, I, ubfiz,  63, long, exact_log2_long, immL_positive_bitmaskI, ConvL2I)
 
-// This pattern is automatically generated from aarch64_ad.m4
+define(`BFX1_INSN', `// This pattern is automatically generated from aarch64_ad.m4
 // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 
-// If there is a convert I to L block between and AndI and a LShiftL, we can also match ubfiz
-instruct ubfizIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI lshift, immI_bitmask mask)
+// If there is a convert $1 to $2 block between and And$1 and a LShift$2, we can also match ubfiz
+instruct ubfiz$1Conv$3$9(iReg$2NoSp dst, iReg$1`'ORL2I($1) src, immI lshift, $8 mask)
 %{
-  match(Set dst (LShiftL (ConvI2L (AndI src mask)) lshift));
-  predicate((exact_log2(n->in(1)->in(1)->in(2)->get_int() + 1) + (n->in(2)->get_int() & 63)) <= (63 + 1));
+  match(Set dst (LShift$2 (Conv$3 (And$1 src mask)) lshift));
+  predicate(($4(n->in(1)->in(1)->in(2)->$5() + 1) + (n->in(2)->get_int() & $6)) <= $7);
 
   ins_cost(INSN_COST);
   format %{ "ubfiz $dst, $src, $lshift, $mask" %}
   ins_encode %{
-    int lshift = $lshift$$constant & 63;
+    int lshift = $lshift$$constant & $6;
     intptr_t mask = $mask$$constant;
     int width = exact_log2(mask+1);
     __ ubfiz(as_Register($dst$$reg),
              as_Register($src$$reg), lshift, width);
   %}
   ins_pipe(ialu_reg_shift);
 %}
+')dnl
+BFX1_INSN(I, L, I2L, exact_log2,      get_int,  63, (63 + 1), immI_bitmask)
+BFX1_INSN(L, I, L2I, exact_log2_long, get_long, 31, 31,       immL_positive_bitmaskI, x)
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
+
+// Can skip int2long conversions after AND with small bitmask
+instruct ubfizIConvI2LAndI(iRegLNoSp dst, iRegI src, immI_bitmask msk)
+%{
+  match(Set dst (ConvI2L (AndI src msk)));
+  ins_cost(INSN_COST);
+  format %{ "ubfiz $dst, $src, 0, exact_log2($msk + 1) " %}
+  ins_encode %{
+    __ ubfiz(as_Register($dst$$reg), as_Register($src$$reg), 0, exact_log2($msk$$constant + 1));
+  %}
+  ins_pipe(ialu_reg_shift);
+%}
 
 
 // Rotations dnl
 define(`EXTRACT_INSN',`
 // This pattern is automatically generated from aarch64_ad.m4
diff a/src/hotspot/cpu/aarch64/assembler_aarch64.hpp b/src/hotspot/cpu/aarch64/assembler_aarch64.hpp
--- a/src/hotspot/cpu/aarch64/assembler_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/assembler_aarch64.hpp
@@ -552,18 +552,11 @@
               "Bad addressing mode for non-temporal op");
   }
 
   void lea(MacroAssembler *, Register) const;
 
-  static bool offset_ok_for_immed(int64_t offset, int shift) {
-    unsigned mask = (1 << shift) - 1;
-    if (offset < 0 || offset & mask) {
-      return (uabs(offset) < (1 << (20 - 12))); // Unscaled offset
-    } else {
-      return ((offset >> shift) < (1 << (21 - 10 + 1))); // Scaled, unsigned offset
-    }
-  }
+  static bool offset_ok_for_immed(int64_t offset, uint shift);
 };
 
 // Convience classes
 class RuntimeAddress: public Address {
 
diff a/src/hotspot/cpu/aarch64/assembler_aarch64.inline.hpp b/src/hotspot/cpu/aarch64/assembler_aarch64.inline.hpp
--- a/src/hotspot/cpu/aarch64/assembler_aarch64.inline.hpp
+++ b/src/hotspot/cpu/aarch64/assembler_aarch64.inline.hpp
@@ -28,6 +28,18 @@
 
 #include "asm/assembler.inline.hpp"
 #include "asm/codeBuffer.hpp"
 #include "code/codeCache.hpp"
 
+
+inline bool Address::offset_ok_for_immed(int64_t offset, uint shift) {
+  uint mask = (1 << shift) - 1;
+  if (offset < 0 || (offset & mask) != 0) {
+    // Unscaled signed offset, encoded in a signed imm9 field.
+    return Assembler::is_simm9(offset);
+  } else {
+    // Scaled unsigned offset, encoded in an unsigned imm12:_ field.
+    return Assembler::is_uimm12(offset >> shift);
+  }
+}
+
 #endif // CPU_AARCH64_ASSEMBLER_AARCH64_INLINE_HPP
diff a/src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp b/src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp
--- a/src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp
@@ -209,10 +209,23 @@
 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
   return as_Address(addr, rscratch1);  // Ouch
   // FIXME: This needs to be much more clever.  See x86.
 }
 
+// Ensure a valid Address (base + offset) to a stack-slot. If stack access is
+// not encodable as a base + (immediate) offset, generate an explicit address
+// calculation to hold the address in a temporary register.
+Address LIR_Assembler::stack_slot_address(int index, uint size, Register tmp, int adjust) {
+  precond(size == 4 || size == 8);
+  Address addr = frame_map()->address_for_slot(index, adjust);
+  precond(addr.getMode() == Address::base_plus_offset);
+  precond(addr.base() == sp);
+  precond(addr.offset() > 0);
+  uint mask = size - 1;
+  assert((addr.offset() & mask) == 0, "scaled offsets only");
+  return __ legitimize_address(addr, size, tmp);
+}
 
 void LIR_Assembler::osr_entry() {
   offsets()->set_value(CodeOffsets::OSR_Entry, code_offset());
   BlockBegin* osr_entry = compilation()->hir()->osr_entry();
   ValueStack* entry_state = osr_entry->state();
@@ -733,36 +746,42 @@
     ShouldNotReachHere();
   }
 }
 
 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
+  precond(src->is_register() && dest->is_stack());
+
+  uint const c_sz32 = sizeof(uint32_t);
+  uint const c_sz64 = sizeof(uint64_t);
+
   if (src->is_single_cpu()) {
+    int index = dest->single_stack_ix();
     if (is_reference_type(type)) {
-      __ str(src->as_register(), frame_map()->address_for_slot(dest->single_stack_ix()));
+      __ str(src->as_register(), stack_slot_address(index, c_sz64, rscratch1));
       __ verify_oop(src->as_register());
     } else if (type == T_METADATA || type == T_DOUBLE || type == T_ADDRESS) {
-      __ str(src->as_register(), frame_map()->address_for_slot(dest->single_stack_ix()));
+      __ str(src->as_register(), stack_slot_address(index, c_sz64, rscratch1));
     } else {
-      __ strw(src->as_register(), frame_map()->address_for_slot(dest->single_stack_ix()));
+      __ strw(src->as_register(), stack_slot_address(index, c_sz32, rscratch1));
     }
 
   } else if (src->is_double_cpu()) {
-    Address dest_addr_LO = frame_map()->address_for_slot(dest->double_stack_ix(), lo_word_offset_in_bytes);
+    int index = dest->double_stack_ix();
+    Address dest_addr_LO = stack_slot_address(index, c_sz64, rscratch1, lo_word_offset_in_bytes);
     __ str(src->as_register_lo(), dest_addr_LO);
 
   } else if (src->is_single_fpu()) {
-    Address dest_addr = frame_map()->address_for_slot(dest->single_stack_ix());
-    __ strs(src->as_float_reg(), dest_addr);
+    int index = dest->single_stack_ix();
+    __ strs(src->as_float_reg(), stack_slot_address(index, c_sz32, rscratch1));
 
   } else if (src->is_double_fpu()) {
-    Address dest_addr = frame_map()->address_for_slot(dest->double_stack_ix());
-    __ strd(src->as_double_reg(), dest_addr);
+    int index = dest->double_stack_ix();
+    __ strd(src->as_double_reg(), stack_slot_address(index, c_sz64, rscratch1));
 
   } else {
     ShouldNotReachHere();
   }
-
 }
 
 
 void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool /* unaligned */) {
   LIR_Address* to_addr = dest->as_address_ptr();
@@ -843,34 +862,38 @@
   }
 }
 
 
 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
-  assert(src->is_stack(), "should not call otherwise");
-  assert(dest->is_register(), "should not call otherwise");
+  precond(src->is_stack() && dest->is_register());
+
+  uint const c_sz32 = sizeof(uint32_t);
+  uint const c_sz64 = sizeof(uint64_t);
 
   if (dest->is_single_cpu()) {
+    int index = src->single_stack_ix();
     if (is_reference_type(type)) {
-      __ ldr(dest->as_register(), frame_map()->address_for_slot(src->single_stack_ix()));
+      __ ldr(dest->as_register(), stack_slot_address(index, c_sz64, rscratch1));
       __ verify_oop(dest->as_register());
     } else if (type == T_METADATA || type == T_ADDRESS) {
-      __ ldr(dest->as_register(), frame_map()->address_for_slot(src->single_stack_ix()));
+      __ ldr(dest->as_register(), stack_slot_address(index, c_sz64, rscratch1));
     } else {
-      __ ldrw(dest->as_register(), frame_map()->address_for_slot(src->single_stack_ix()));
+      __ ldrw(dest->as_register(), stack_slot_address(index, c_sz32, rscratch1));
     }
 
   } else if (dest->is_double_cpu()) {
-    Address src_addr_LO = frame_map()->address_for_slot(src->double_stack_ix(), lo_word_offset_in_bytes);
+    int index = src->double_stack_ix();
+    Address src_addr_LO = stack_slot_address(index, c_sz64, rscratch1, lo_word_offset_in_bytes);
     __ ldr(dest->as_register_lo(), src_addr_LO);
 
   } else if (dest->is_single_fpu()) {
-    Address src_addr = frame_map()->address_for_slot(src->single_stack_ix());
-    __ ldrs(dest->as_float_reg(), src_addr);
+    int index = src->single_stack_ix();
+    __ ldrs(dest->as_float_reg(), stack_slot_address(index, c_sz32, rscratch1));
 
   } else if (dest->is_double_fpu()) {
-    Address src_addr = frame_map()->address_for_slot(src->double_stack_ix());
-    __ ldrd(dest->as_double_reg(), src_addr);
+    int index = src->double_stack_ix();
+    __ ldrd(dest->as_double_reg(), stack_slot_address(index, c_sz64, rscratch1));
 
   } else {
     ShouldNotReachHere();
   }
 }
@@ -2083,10 +2106,17 @@
   info->add_register_oop(exceptionOop);
   Runtime1::StubID unwind_id;
 
   // get current pc information
   // pc is only needed if the method has an exception handler, the unwind code does not need it.
+  if (compilation()->debug_info_recorder()->last_pc_offset() == __ offset()) {
+    // As no instructions have been generated yet for this LIR node it's
+    // possible that an oop map already exists for the current offset.
+    // In that case insert an dummy NOP here to ensure all oop map PCs
+    // are unique. See JDK-8237483.
+    __ nop();
+  }
   int pc_for_athrow_offset = __ offset();
   InternalAddress pc_for_athrow(__ pc());
   __ adr(exceptionPC->as_register(), pc_for_athrow);
   add_call_info(pc_for_athrow_offset, info); // for exception handler
 
diff a/src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.hpp b/src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.hpp
--- a/src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.hpp
@@ -43,14 +43,16 @@
 
   address int_constant(jlong n);
 
   bool is_literal_address(LIR_Address* addr);
 
-  // When we need to use something other than rscratch1 use this
-  // method.
+  // When we need to use something other than rscratch1 use this method.
   Address as_Address(LIR_Address* addr, Register tmp);
 
+  // Ensure we have a valid Address (base+offset) to a stack-slot.
+  Address stack_slot_address(int index, uint shift, Register tmp, int adjust = 0);
+
   // Record the type of the receiver in ReceiverTypeData
   void type_profile_helper(Register mdo,
                            ciMethodData *md, ciProfileData *data,
                            Register recv, Label* update_done);
   void add_debug_info_for_branch(address adr, CodeEmitInfo* info);
diff a/src/hotspot/cpu/aarch64/frame_aarch64.hpp b/src/hotspot/cpu/aarch64/frame_aarch64.hpp
--- a/src/hotspot/cpu/aarch64/frame_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/frame_aarch64.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
@@ -48,11 +48,11 @@
 
 //    [klass of method       ]                   = mirror()             mirror_offset
 //    [padding               ]
 
 //    [methodData            ]                   = mdp()                mdx_offset
-//    [methodOop             ]                   = method()             method_offset
+//    [Method                ]                   = method()             method_offset
 
 //    [last esp              ]                   = last_sp()            last_sp_offset
 //    [old stack pointer     ]                     (sender_sp)          sender_sp_offset
 
 //    [old frame pointer     ]   <- fp           = link()
diff a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp
--- a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp
@@ -24,11 +24,11 @@
  */
 
 #ifndef CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP
 #define CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP
 
-#include "asm/assembler.hpp"
+#include "asm/assembler.inline.hpp"
 #include "oops/compressedOops.hpp"
 #include "utilities/powerOfTwo.hpp"
 
 // MacroAssembler extends Assembler by frequently used macros.
 //
diff a/src/hotspot/cpu/aarch64/macroAssembler_aarch64_log.cpp b/src/hotspot/cpu/aarch64/macroAssembler_aarch64_log.cpp
--- a/src/hotspot/cpu/aarch64/macroAssembler_aarch64_log.cpp
+++ b/src/hotspot/cpu/aarch64/macroAssembler_aarch64_log.cpp
@@ -63,11 +63,11 @@
 //
 /******************************************************************************/
 
 // Table with p(r) polynomial coefficients
 // and table representation of logarithm values (hi and low parts)
-__attribute__ ((aligned(64))) juint _L_tbl[] =
+ATTRIBUTE_ALIGNED(64) juint _L_tbl[] =
 {
     // coefficients of p(r) polynomial:
     // _coeff[]
     0x00000000UL, 0xbfd00000UL, // C1_0 = -0.25
     0x92492492UL, 0x3fc24924UL, // C1_1 = 0.14285714285714285
diff a/src/hotspot/cpu/aarch64/stubRoutines_aarch64.cpp b/src/hotspot/cpu/aarch64/stubRoutines_aarch64.cpp
--- a/src/hotspot/cpu/aarch64/stubRoutines_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/stubRoutines_aarch64.cpp
@@ -60,11 +60,11 @@
 bool StubRoutines::aarch64::_completed = false;
 
 /**
  *  crc_table[] from jdk/src/share/native/java/util/zip/zlib-1.2.5/crc32.h
  */
-juint StubRoutines::aarch64::_crc_table[] ATTRIBUTE_ALIGNED(4096) =
+ATTRIBUTE_ALIGNED(4096) juint StubRoutines::aarch64::_crc_table[] =
 {
     // Table 0
     0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,
     0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,
     0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,
@@ -287,15 +287,15 @@
     0x02D578EDUL, 0x7DAEED62UL,         // word swap
     0xD502ED78UL, 0xAE7D62EDUL,         // byte swap of word swap
 };
 
 // Accumulation coefficients for adler32 upper 16 bits
-jubyte StubRoutines::aarch64::_adler_table[] __attribute__ ((aligned(64))) = {
+ATTRIBUTE_ALIGNED(64) jubyte StubRoutines::aarch64::_adler_table[] = {
     16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
 };
 
-juint StubRoutines::aarch64::_npio2_hw[] __attribute__ ((aligned(64))) = {
+ATTRIBUTE_ALIGNED(64) juint StubRoutines::aarch64::_npio2_hw[] = {
     // first, various coefficient values: 0.5, invpio2, pio2_1, pio2_1t, pio2_2,
     // pio2_2t, pio2_3, pio2_3t
     // This is a small optimization wich keeping double[8] values in int[] table
     // to have less address calculation instructions
     //
@@ -323,22 +323,22 @@
     0x404858EB, 0x404921FB
 };
 
 // Coefficients for sin(x) polynomial approximation: S1..S6.
 // See kernel_sin comments in macroAssembler_aarch64_trig.cpp for details
-jdouble StubRoutines::aarch64::_dsin_coef[] __attribute__ ((aligned(64))) = {
+ATTRIBUTE_ALIGNED(64) jdouble StubRoutines::aarch64::_dsin_coef[] = {
     -1.66666666666666324348e-01, // 0xBFC5555555555549
      8.33333333332248946124e-03, // 0x3F8111111110F8A6
     -1.98412698298579493134e-04, // 0xBF2A01A019C161D5
      2.75573137070700676789e-06, // 0x3EC71DE357B1FE7D
     -2.50507602534068634195e-08, // 0xBE5AE5E68A2B9CEB
      1.58969099521155010221e-10  // 0x3DE5D93A5ACFD57C
 };
 
 // Coefficients for cos(x) polynomial approximation: C1..C6.
 // See kernel_cos comments in macroAssembler_aarch64_trig.cpp for details
-jdouble StubRoutines::aarch64::_dcos_coef[] __attribute__ ((aligned(64))) = {
+ATTRIBUTE_ALIGNED(64) jdouble StubRoutines::aarch64::_dcos_coef[] = {
      4.16666666666666019037e-02, // c0x3FA555555555554C
     -1.38888888888741095749e-03, // 0xBF56C16C16C15177
      2.48015872894767294178e-05, // 0x3EFA01A019CB1590
     -2.75573143513906633035e-07, // 0xBE927E4F809C52AD
      2.08757232129817482790e-09, // 0x3E21EE9EBDB4B1C4
@@ -349,11 +349,11 @@
 // Used in cases of very large argument. 396 hex digits is enough to support
 // required precision.
 // Converted to double to avoid unnecessary conversion in code
 // NOTE: table looks like original int table: {0xA2F983, 0x6E4E44,...} with
 //       only (double) conversion added
-jdouble StubRoutines::aarch64::_two_over_pi[] __attribute__ ((aligned(64))) = {
+ATTRIBUTE_ALIGNED(64) jdouble StubRoutines::aarch64::_two_over_pi[] = {
   (double)0xA2F983, (double)0x6E4E44, (double)0x1529FC, (double)0x2757D1, (double)0xF534DD, (double)0xC0DB62,
   (double)0x95993C, (double)0x439041, (double)0xFE5163, (double)0xABDEBB, (double)0xC561B7, (double)0x246E3A,
   (double)0x424DD2, (double)0xE00649, (double)0x2EEA09, (double)0xD1921C, (double)0xFE1DEB, (double)0x1CB129,
   (double)0xA73EE8, (double)0x8235F5, (double)0x2EBB44, (double)0x84E99C, (double)0x7026B4, (double)0x5F7E41,
   (double)0x3991D6, (double)0x398353, (double)0x39F49C, (double)0x845F8B, (double)0xBDF928, (double)0x3B1FF8,
@@ -364,11 +364,11 @@
   (double)0x91615E, (double)0xE61B08, (double)0x659985, (double)0x5F14A0, (double)0x68408D, (double)0xFFD880,
   (double)0x4D7327, (double)0x310606, (double)0x1556CA, (double)0x73A8C9, (double)0x60E27B, (double)0xC08C6B,
 };
 
 // Pi over 2 value
-jdouble StubRoutines::aarch64::_pio2[] __attribute__ ((aligned(64))) = {
+ATTRIBUTE_ALIGNED(64) jdouble StubRoutines::aarch64::_pio2[] = {
   1.57079625129699707031e+00, // 0x3FF921FB40000000
   7.54978941586159635335e-08, // 0x3E74442D00000000
   5.39030252995776476554e-15, // 0x3CF8469880000000
   3.28200341580791294123e-22, // 0x3B78CC5160000000
   1.27065575308067607349e-29, // 0x39F01B8380000000
diff a/src/hotspot/cpu/aarch64/templateTable_aarch64.cpp b/src/hotspot/cpu/aarch64/templateTable_aarch64.cpp
--- a/src/hotspot/cpu/aarch64/templateTable_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/templateTable_aarch64.cpp
@@ -3284,11 +3284,11 @@
   Label notFinal;
   __ tbz(flags, ConstantPoolCacheEntry::is_vfinal_shift, notFinal);
 
   const Register method = index;  // method must be rmethod
   assert(method == rmethod,
-         "methodOop must be rmethod for interpreter calling convention");
+         "Method must be rmethod for interpreter calling convention");
 
   // do the call - the index is actually the method to call
   // that is, f2 is a vtable index if !is_vfinal, else f2 is a Method*
 
   // It's final, need a null check here!
@@ -3307,11 +3307,11 @@
   __ load_klass(r0, recv);
 
   // profile this call
   __ profile_virtual_call(r0, rlocals, r3);
 
-  // get target methodOop & entry point
+  // get target Method & entry point
   __ lookup_virtual_method(r0, index, method);
   __ profile_arguments_type(r3, method, r4, true);
   // FIXME -- this looks completely redundant. is it?
   // __ ldr(r3, Address(method, Method::interpreter_entry_offset()));
   __ jump_from_interpreted(method, r3);
@@ -3442,11 +3442,11 @@
                              rlocals, r0, rmethod,
                              // outputs: method, scan temp. reg
                              rmethod, r13,
                              no_such_interface);
 
-  // rmethod,: methodOop to call
+  // rmethod,: Method to call
   // r2: receiver
   // Check for abstract method error
   // Note: This should be done more efficiently via a throw_abstract_method_error
   //       interpreter entry point and a conditional jump to it in case of a null
   //       method.
@@ -3454,11 +3454,11 @@
 
   __ profile_arguments_type(r3, rmethod, r13, true);
 
   // do the call
   // r2: receiver
-  // rmethod,: methodOop
+  // rmethod,: Method
   __ jump_from_interpreted(rmethod, r3);
   __ should_not_reach_here();
 
   // exception handling code follows...
   // note: must restore interpreter registers to canonical
diff a/src/hotspot/cpu/arm/arm.ad b/src/hotspot/cpu/arm/arm.ad
--- a/src/hotspot/cpu/arm/arm.ad
+++ b/src/hotspot/cpu/arm/arm.ad
@@ -8867,16 +8867,16 @@
 
 // Tail Call; Jump from runtime stub to Java code.
 // Also known as an 'interprocedural jump'.
 // Target of jump will eventually return to caller.
 // TailJump below removes the return address.
-instruct TailCalljmpInd(IPRegP jump_target, inline_cache_regP method_oop) %{
-  match(TailCall jump_target method_oop );
+instruct TailCalljmpInd(IPRegP jump_target, inline_cache_regP method_ptr) %{
+  match(TailCall jump_target method_ptr);
 
   ins_cost(CALL_COST);
   format %{ "MOV    Rexception_pc, LR\n\t"
-            "jump   $jump_target  \t! $method_oop holds method oop" %}
+            "jump   $jump_target  \t! $method_ptr holds method" %}
   ins_encode %{
     __ mov(Rexception_pc, LR);   // this is used only to call
                                  // StubRoutines::forward_exception_entry()
                                  // which expects PC of exception in
                                  // R5. FIXME?
diff a/src/hotspot/cpu/arm/methodHandles_arm.hpp b/src/hotspot/cpu/arm/methodHandles_arm.hpp
--- a/src/hotspot/cpu/arm/methodHandles_arm.hpp
+++ b/src/hotspot/cpu/arm/methodHandles_arm.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -40,11 +40,11 @@
 
   static void verify_ref_kind(MacroAssembler* _masm, int ref_kind, Register member_reg, Register temp) NOT_DEBUG_RETURN;
 
   // Similar to InterpreterMacroAssembler::jump_from_interpreted.
   // Takes care of special dispatch from single stepping too.
-  // Rmethod should contain target methodOop.
+  // Rmethod should contain target Method.
   static void jump_from_method_handle(MacroAssembler* _masm, bool for_compiler_entry);
 
   static void jump_to_lambda_form(MacroAssembler* _masm,
                                   Register recv, Register tmp,
                                   bool for_compiler_entry);
diff a/src/hotspot/cpu/ppc/ppc.ad b/src/hotspot/cpu/ppc/ppc.ad
--- a/src/hotspot/cpu/ppc/ppc.ad
+++ b/src/hotspot/cpu/ppc/ppc.ad
@@ -3938,11 +3938,11 @@
       __ load_klass(R11_scratch1, R3);
 
       int entry_offset = in_bytes(Klass::vtable_start_offset()) + _vtable_index * vtableEntry::size_in_bytes();
       int v_off = entry_offset + vtableEntry::method_offset_in_bytes();
       __ li(R19_method, v_off);
-      __ ldx(R19_method/*method oop*/, R19_method/*method offset*/, R11_scratch1/*class*/);
+      __ ldx(R19_method/*method*/, R19_method/*method offset*/, R11_scratch1/*class*/);
       // NOTE: for vtable dispatches, the vtable entry will never be
       // null. However it may very well end up in handle_wrong_method
       // if the method is abstract for the particular class.
       __ ld(R11_scratch1, in_bytes(Method::from_compiled_offset()), R19_method);
       // Call target. Either compiled code or C2I adapter.
@@ -15122,15 +15122,15 @@
 
 // Tail Call; Jump from runtime stub to Java code.
 // Also known as an 'interprocedural jump'.
 // Target of jump will eventually return to caller.
 // TailJump below removes the return address.
-instruct TailCalljmpInd(iRegPdstNoScratch jump_target, inline_cache_regP method_oop) %{
-  match(TailCall jump_target method_oop);
+instruct TailCalljmpInd(iRegPdstNoScratch jump_target, inline_cache_regP method_ptr) %{
+  match(TailCall jump_target method_ptr);
   ins_cost(CALL_COST);
 
-  format %{ "MTCTR   $jump_target \t// $method_oop holds method oop\n\t"
+  format %{ "MTCTR   $jump_target \t// $method_ptr holds method\n\t"
             "BCTR         \t// tail call" %}
   size(8);
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
     __ mtctr($jump_target$$Register);
diff a/src/hotspot/cpu/s390/s390.ad b/src/hotspot/cpu/s390/s390.ad
--- a/src/hotspot/cpu/s390/s390.ad
+++ b/src/hotspot/cpu/s390/s390.ad
@@ -9828,15 +9828,15 @@
 
 // Tail Call; Jump from runtime stub to Java code.
 // Also known as an 'interprocedural jump'.
 // Target of jump will eventually return to caller.
 // TailJump below removes the return address.
-instruct TailCalljmpInd(iRegP jump_target, inline_cache_regP method_oop) %{
-  match(TailCall jump_target method_oop);
+instruct TailCalljmpInd(iRegP jump_target, inline_cache_regP method_ptr) %{
+  match(TailCall jump_target method_ptr);
   ins_cost(CALL_COST);
   size(2);
-  format %{ "Jmp     $jump_target\t # $method_oop holds method oop" %}
+  format %{ "Jmp     $jump_target\t # $method_ptr holds method" %}
   ins_encode %{ __ z_br($jump_target$$Register); %}
   ins_pipe(pipe_class_dummy);
 %}
 
 // Return Instruction
diff a/src/hotspot/cpu/s390/sharedRuntime_s390.cpp b/src/hotspot/cpu/s390/sharedRuntime_s390.cpp
--- a/src/hotspot/cpu/s390/sharedRuntime_s390.cpp
+++ b/src/hotspot/cpu/s390/sharedRuntime_s390.cpp
@@ -2623,14 +2623,14 @@
       ld_offset -= wordSize;
     }
   }
 
   // Jump to the compiled code just as if compiled code was doing it.
-  // load target address from method oop:
+  // load target address from method:
   __ z_lg(Z_R1_scratch, Address(Z_method, Method::from_compiled_offset()));
 
-  // Store method oop into thread->callee_target.
+  // Store method into thread->callee_target.
   // 6243940: We might end up in handle_wrong_method if
   // the callee is deoptimized as we race thru here. If that
   // happens we don't want to take a safepoint because the
   // caller frame will look interpreted and arguments are now
   // "compiled" so it is much better to make this transition
diff a/src/hotspot/cpu/s390/vtableStubs_s390.cpp b/src/hotspot/cpu/s390/vtableStubs_s390.cpp
--- a/src/hotspot/cpu/s390/vtableStubs_s390.cpp
+++ b/src/hotspot/cpu/s390/vtableStubs_s390.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2016, 2018 SAP SE. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
@@ -115,18 +115,18 @@
   int v_off        = entry_offset + vtableEntry::method_offset_in_bytes();
 
   // Set method (in case of interpreted method), and destination address.
   // Duplicate safety code from enc_class Java_Dynamic_Call_dynTOC.
   if (Displacement::is_validDisp(v_off)) {
-    __ z_lg(Z_method/*method oop*/, v_off, rcvr_klass/*class oop*/);
+    __ z_lg(Z_method/*method*/, v_off, rcvr_klass/*class*/);
     // Account for the load_const in the else path.
     slop_delta  = __ load_const_size();
   } else {
     // Worse case, offset does not fit in displacement field.
     //               worst case             actual size
     slop_delta  = __ load_const_size() - __ load_const_optimized_rtn_len(Z_method, v_off, true);
-    __ z_lg(Z_method/*method oop*/, 0, Z_method/*method offset*/, rcvr_klass/*class oop*/);
+    __ z_lg(Z_method/*method*/, 0, Z_method/*method offset*/, rcvr_klass/*class*/);
   }
   slop_bytes += slop_delta;
 
 #ifndef PRODUCT
   if (DebugVtables) {
diff a/src/hotspot/cpu/x86/gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp b/src/hotspot/cpu/x86/gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp
--- a/src/hotspot/cpu/x86/gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp
+++ b/src/hotspot/cpu/x86/gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp
@@ -44,10 +44,34 @@
 
 #define __ masm->
 
 address ShenandoahBarrierSetAssembler::_shenandoah_lrb = NULL;
 
+static void save_xmm_registers(MacroAssembler* masm) {
+    __ subptr(rsp, 64);
+    __ movdbl(Address(rsp, 0), xmm0);
+    __ movdbl(Address(rsp, 8), xmm1);
+    __ movdbl(Address(rsp, 16), xmm2);
+    __ movdbl(Address(rsp, 24), xmm3);
+    __ movdbl(Address(rsp, 32), xmm4);
+    __ movdbl(Address(rsp, 40), xmm5);
+    __ movdbl(Address(rsp, 48), xmm6);
+    __ movdbl(Address(rsp, 56), xmm7);
+}
+
+static void restore_xmm_registers(MacroAssembler* masm) {
+    __ movdbl(xmm0, Address(rsp, 0));
+    __ movdbl(xmm1, Address(rsp, 8));
+    __ movdbl(xmm2, Address(rsp, 16));
+    __ movdbl(xmm3, Address(rsp, 24));
+    __ movdbl(xmm4, Address(rsp, 32));
+    __ movdbl(xmm5, Address(rsp, 40));
+    __ movdbl(xmm6, Address(rsp, 48));
+    __ movdbl(xmm7, Address(rsp, 56));
+    __ addptr(rsp, 64);
+}
+
 void ShenandoahBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
                                                        Register src, Register dst, Register count) {
 
   bool dest_uninitialized = (decorators & IS_DEST_UNINITIALIZED) != 0;
 
@@ -288,11 +312,13 @@
 
     // we can clobber it, since it is outgoing register
     __ lea(src_addr, src);
   }
 
+  save_xmm_registers(masm);
   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ShenandoahBarrierSetAssembler::shenandoah_lrb())));
+  restore_xmm_registers(masm);
 
   if (need_addr_setup) {
     if (dst != rax) {
       __ movptr(dst, rax);
       __ pop(rax);
@@ -366,11 +392,14 @@
   __ push(r15);
 #endif
 
   assert_different_registers(dst, rsi);
   __ lea(rsi, src);
+
+  save_xmm_registers(masm);
   __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native), dst, rsi);
+  restore_xmm_registers(masm);
 
 #ifdef _LP64
   __ pop(r15);
   __ pop(r14);
   __ pop(r13);
@@ -512,19 +541,11 @@
   if (ShenandoahBarrierSet::need_keep_alive_barrier(decorators, type)) {
     __ push_IU_state();
     // That path can be reached from the c2i adapter with live fp
     // arguments in registers.
     LP64_ONLY(assert(Argument::n_float_register_parameters_j == 8, "8 fp registers to save at java call"));
-    __ subptr(rsp, 64);
-    __ movdbl(Address(rsp, 0), xmm0);
-    __ movdbl(Address(rsp, 8), xmm1);
-    __ movdbl(Address(rsp, 16), xmm2);
-    __ movdbl(Address(rsp, 24), xmm3);
-    __ movdbl(Address(rsp, 32), xmm4);
-    __ movdbl(Address(rsp, 40), xmm5);
-    __ movdbl(Address(rsp, 48), xmm6);
-    __ movdbl(Address(rsp, 56), xmm7);
+    save_xmm_registers(masm);
 
     Register thread = NOT_LP64(tmp_thread) LP64_ONLY(r15_thread);
     assert_different_registers(dst, tmp1, tmp_thread);
     if (!thread->is_valid()) {
       thread = rdx;
@@ -537,19 +558,11 @@
                                  dst /* pre_val */,
                                  thread /* thread */,
                                  tmp1 /* tmp */,
                                  true /* tosca_live */,
                                  true /* expand_call */);
-    __ movdbl(xmm0, Address(rsp, 0));
-    __ movdbl(xmm1, Address(rsp, 8));
-    __ movdbl(xmm2, Address(rsp, 16));
-    __ movdbl(xmm3, Address(rsp, 24));
-    __ movdbl(xmm4, Address(rsp, 32));
-    __ movdbl(xmm5, Address(rsp, 40));
-    __ movdbl(xmm6, Address(rsp, 48));
-    __ movdbl(xmm7, Address(rsp, 56));
-    __ addptr(rsp, 64);
+    restore_xmm_registers(masm);
     __ pop_IU_state();
   }
 }
 
 void ShenandoahBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
diff a/src/hotspot/cpu/x86/stubGenerator_x86_32.cpp b/src/hotspot/cpu/x86/stubGenerator_x86_32.cpp
--- a/src/hotspot/cpu/x86/stubGenerator_x86_32.cpp
+++ b/src/hotspot/cpu/x86/stubGenerator_x86_32.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -427,42 +427,10 @@
     __ jmp(handler_addr);
 
     return start;
   }
 
-
-  //----------------------------------------------------------------------------------------------------
-  // Implementation of int32_t atomic_xchg(int32_t exchange_value, volatile int32_t* dest)
-  // used by Atomic::xchg(volatile int32_t* dest, int32_t exchange_value)
-  //
-  // xchg exists as far back as 8086, lock needed for MP only
-  // Stack layout immediately after call:
-  //
-  // 0 [ret addr ] <--- rsp
-  // 1 [  ex     ]
-  // 2 [  dest   ]
-  //
-  // Result:   *dest <- ex, return (old *dest)
-  //
-  // Note: win32 does not currently use this code
-
-  address generate_atomic_xchg() {
-    StubCodeMark mark(this, "StubRoutines", "atomic_xchg");
-    address start = __ pc();
-
-    __ push(rdx);
-    Address exchange(rsp, 2 * wordSize);
-    Address dest_addr(rsp, 3 * wordSize);
-    __ movl(rax, exchange);
-    __ movptr(rdx, dest_addr);
-    __ xchgl(rax, Address(rdx, 0));
-    __ pop(rdx);
-    __ ret(0);
-
-    return start;
-  }
-
   //----------------------------------------------------------------------------------------------------
   // Support for void verify_mxcsr()
   //
   // This routine is used with -Xcheck:jni to verify that native
   // JNI code does not return to Java code without restoring the
@@ -3795,13 +3763,10 @@
     StubRoutines::_call_stub_entry              =
       generate_call_stub(StubRoutines::_call_stub_return_address);
     // is referenced by megamorphic call
     StubRoutines::_catch_exception_entry        = generate_catch_exception();
 
-    // These are currently used by Solaris/Intel
-    StubRoutines::_atomic_xchg_entry            = generate_atomic_xchg();
-
     // platform dependent
     create_control_words();
 
     StubRoutines::x86::_verify_mxcsr_entry                 = generate_verify_mxcsr();
     StubRoutines::x86::_verify_fpu_cntrl_wrd_entry         = generate_verify_fpu_cntrl_wrd();
diff a/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp b/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp
--- a/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp
+++ b/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -550,174 +550,10 @@
     __ jmp(rbx);
 
     return start;
   }
 
-  // Implementation of jint atomic_xchg(jint add_value, volatile jint* dest)
-  // used by Atomic::xchg(volatile jint* dest, jint exchange_value)
-  //
-  // Arguments :
-  //    c_rarg0: exchange_value
-  //    c_rarg0: dest
-  //
-  // Result:
-  //    *dest <- ex, return (orig *dest)
-  address generate_atomic_xchg() {
-    StubCodeMark mark(this, "StubRoutines", "atomic_xchg");
-    address start = __ pc();
-
-    __ movl(rax, c_rarg0); // Copy to eax we need a return value anyhow
-    __ xchgl(rax, Address(c_rarg1, 0)); // automatic LOCK
-    __ ret(0);
-
-    return start;
-  }
-
-  // Implementation of intptr_t atomic_xchg(jlong add_value, volatile jlong* dest)
-  // used by Atomic::xchg(volatile jlong* dest, jlong exchange_value)
-  //
-  // Arguments :
-  //    c_rarg0: exchange_value
-  //    c_rarg1: dest
-  //
-  // Result:
-  //    *dest <- ex, return (orig *dest)
-  address generate_atomic_xchg_long() {
-    StubCodeMark mark(this, "StubRoutines", "atomic_xchg_long");
-    address start = __ pc();
-
-    __ movptr(rax, c_rarg0); // Copy to eax we need a return value anyhow
-    __ xchgptr(rax, Address(c_rarg1, 0)); // automatic LOCK
-    __ ret(0);
-
-    return start;
-  }
-
-  // Support for jint atomic::atomic_cmpxchg(jint exchange_value, volatile jint* dest,
-  //                                         jint compare_value)
-  //
-  // Arguments :
-  //    c_rarg0: exchange_value
-  //    c_rarg1: dest
-  //    c_rarg2: compare_value
-  //
-  // Result:
-  //    if ( compare_value == *dest ) {
-  //       *dest = exchange_value
-  //       return compare_value;
-  //    else
-  //       return *dest;
-  address generate_atomic_cmpxchg() {
-    StubCodeMark mark(this, "StubRoutines", "atomic_cmpxchg");
-    address start = __ pc();
-
-    __ movl(rax, c_rarg2);
-    __ lock();
-    __ cmpxchgl(c_rarg0, Address(c_rarg1, 0));
-    __ ret(0);
-
-    return start;
-  }
-
-  // Support for int8_t atomic::atomic_cmpxchg(int8_t exchange_value, volatile int8_t* dest,
-  //                                           int8_t compare_value)
-  //
-  // Arguments :
-  //    c_rarg0: exchange_value
-  //    c_rarg1: dest
-  //    c_rarg2: compare_value
-  //
-  // Result:
-  //    if ( compare_value == *dest ) {
-  //       *dest = exchange_value
-  //       return compare_value;
-  //    else
-  //       return *dest;
-  address generate_atomic_cmpxchg_byte() {
-    StubCodeMark mark(this, "StubRoutines", "atomic_cmpxchg_byte");
-    address start = __ pc();
-
-    __ movsbq(rax, c_rarg2);
-    __ lock();
-    __ cmpxchgb(c_rarg0, Address(c_rarg1, 0));
-    __ ret(0);
-
-    return start;
-  }
-
-  // Support for int64_t atomic::atomic_cmpxchg(int64_t exchange_value,
-  //                                            volatile int64_t* dest,
-  //                                            int64_t compare_value)
-  // Arguments :
-  //    c_rarg0: exchange_value
-  //    c_rarg1: dest
-  //    c_rarg2: compare_value
-  //
-  // Result:
-  //    if ( compare_value == *dest ) {
-  //       *dest = exchange_value
-  //       return compare_value;
-  //    else
-  //       return *dest;
-  address generate_atomic_cmpxchg_long() {
-    StubCodeMark mark(this, "StubRoutines", "atomic_cmpxchg_long");
-    address start = __ pc();
-
-    __ movq(rax, c_rarg2);
-    __ lock();
-    __ cmpxchgq(c_rarg0, Address(c_rarg1, 0));
-    __ ret(0);
-
-    return start;
-  }
-
-  // Implementation of jint atomic_add(jint add_value, volatile jint* dest)
-  // used by Atomic::add(volatile jint* dest, jint add_value)
-  //
-  // Arguments :
-  //    c_rarg0: add_value
-  //    c_rarg1: dest
-  //
-  // Result:
-  //    *dest += add_value
-  //    return *dest;
-  address generate_atomic_add() {
-    StubCodeMark mark(this, "StubRoutines", "atomic_add");
-    address start = __ pc();
-
-    __ movl(rax, c_rarg0);
-    __ lock();
-    __ xaddl(Address(c_rarg1, 0), c_rarg0);
-    __ addl(rax, c_rarg0);
-    __ ret(0);
-
-    return start;
-  }
-
-  // Implementation of intptr_t atomic_add(intptr_t add_value, volatile intptr_t* dest)
-  // used by Atomic::add(volatile intptr_t* dest, intptr_t add_value)
-  //
-  // Arguments :
-  //    c_rarg0: add_value
-  //    c_rarg1: dest
-  //
-  // Result:
-  //    *dest += add_value
-  //    return *dest;
-  address generate_atomic_add_long() {
-    StubCodeMark mark(this, "StubRoutines", "atomic_add_long");
-    address start = __ pc();
-
-    __ movptr(rax, c_rarg0); // Copy to eax we need a return value anyhow
-    __ lock();
-    __ xaddptr(Address(c_rarg1, 0), c_rarg0);
-    __ addptr(rax, c_rarg0);
-    __ ret(0);
-
-    return start;
-  }
-
   // Support for intptr_t OrderAccess::fence()
   //
   // Arguments :
   //
   // Result:
@@ -6330,17 +6166,10 @@
 
     // is referenced by megamorphic call
     StubRoutines::_catch_exception_entry = generate_catch_exception();
 
     // atomic calls
-    StubRoutines::_atomic_xchg_entry          = generate_atomic_xchg();
-    StubRoutines::_atomic_xchg_long_entry     = generate_atomic_xchg_long();
-    StubRoutines::_atomic_cmpxchg_entry       = generate_atomic_cmpxchg();
-    StubRoutines::_atomic_cmpxchg_byte_entry  = generate_atomic_cmpxchg_byte();
-    StubRoutines::_atomic_cmpxchg_long_entry  = generate_atomic_cmpxchg_long();
-    StubRoutines::_atomic_add_entry           = generate_atomic_add();
-    StubRoutines::_atomic_add_long_entry      = generate_atomic_add_long();
     StubRoutines::_fence_entry                = generate_orderaccess_fence();
 
     // platform dependent
     StubRoutines::x86::_get_previous_fp_entry = generate_get_previous_fp();
     StubRoutines::x86::_get_previous_sp_entry = generate_get_previous_sp();
diff a/src/hotspot/cpu/x86/templateInterpreterGenerator_x86.cpp b/src/hotspot/cpu/x86/templateInterpreterGenerator_x86.cpp
--- a/src/hotspot/cpu/x86/templateInterpreterGenerator_x86.cpp
+++ b/src/hotspot/cpu/x86/templateInterpreterGenerator_x86.cpp
@@ -951,11 +951,11 @@
   assert(InterpreterRuntime::SignatureHandlerGenerator::to() == rsp,
          "adjust this code");
   assert(InterpreterRuntime::SignatureHandlerGenerator::temp() == NOT_LP64(t) LP64_ONLY(rscratch1),
          "adjust this code");
 
-  // The generated handlers do not touch RBX (the method oop).
+  // The generated handlers do not touch RBX (the method).
   // However, large signatures cannot be cached and are generated
   // each time here.  The slow-path generator can do a GC on return,
   // so we must reload it after the call.
   __ call(t);
   __ get_method(method);        // slow path can do a GC, reload RBX
diff a/src/hotspot/cpu/x86/x86_32.ad b/src/hotspot/cpu/x86/x86_32.ad
--- a/src/hotspot/cpu/x86/x86_32.ad
+++ b/src/hotspot/cpu/x86/x86_32.ad
@@ -1932,13 +1932,13 @@
 //     // int ic_reg     = Matcher::inline_cache_reg();
 //     // int ic_encode  = Matcher::_regEncode[ic_reg];
 //     // int imo_reg    = Matcher::interpreter_method_oop_reg();
 //     // int imo_encode = Matcher::_regEncode[imo_reg];
 //
-//     // // Interpreter expects method_oop in EBX, currently a callee-saved register,
+//     // // Interpreter expects method_ptr in EBX, currently a callee-saved register,
 //     // // so we load it immediately before the call
-//     // emit_opcode(cbuf, 0x8B);                     // MOV    imo_reg,ic_reg  # method_oop
+//     // emit_opcode(cbuf, 0x8B);                     // MOV    imo_reg,ic_reg  # method_ptr
 //     // emit_rm(cbuf, 0x03, imo_encode, ic_encode ); // R/M byte
 //
 //     // xor rbp,ebp
 //     emit_opcode(cbuf, 0x33);
 //     emit_rm(cbuf, 0x3, EBP_enc, EBP_enc);
@@ -13315,14 +13315,14 @@
 
 // Tail Call; Jump from runtime stub to Java code.
 // Also known as an 'interprocedural jump'.
 // Target of jump will eventually return to caller.
 // TailJump below removes the return address.
-instruct TailCalljmpInd(eRegP_no_EBP jump_target, eBXRegP method_oop) %{
-  match(TailCall jump_target method_oop );
+instruct TailCalljmpInd(eRegP_no_EBP jump_target, eBXRegP method_ptr) %{
+  match(TailCall jump_target method_ptr);
   ins_cost(300);
-  format %{ "JMP    $jump_target \t# EBX holds method oop" %}
+  format %{ "JMP    $jump_target \t# EBX holds method" %}
   opcode(0xFF, 0x4);  /* Opcode FF /4 */
   ins_encode( OpcP, RegOpc(jump_target) );
   ins_pipe( pipe_jmp );
 %}
 
diff a/src/hotspot/cpu/x86/x86_64.ad b/src/hotspot/cpu/x86/x86_64.ad
--- a/src/hotspot/cpu/x86/x86_64.ad
+++ b/src/hotspot/cpu/x86/x86_64.ad
@@ -12602,16 +12602,16 @@
 
 // Tail Call; Jump from runtime stub to Java code.
 // Also known as an 'interprocedural jump'.
 // Target of jump will eventually return to caller.
 // TailJump below removes the return address.
-instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_oop)
+instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_ptr)
 %{
-  match(TailCall jump_target method_oop);
+  match(TailCall jump_target method_ptr);
 
   ins_cost(300);
-  format %{ "jmp     $jump_target\t# rbx holds method oop" %}
+  format %{ "jmp     $jump_target\t# rbx holds method" %}
   opcode(0xFF, 0x4); /* Opcode FF /4 */
   ins_encode(REX_reg(jump_target), OpcP, reg_opc(jump_target));
   ins_pipe(pipe_jmp);
 %}
 
diff a/src/hotspot/os/windows/os_windows.cpp b/src/hotspot/os/windows/os_windows.cpp
--- a/src/hotspot/os/windows/os_windows.cpp
+++ b/src/hotspot/os/windows/os_windows.cpp
@@ -2378,11 +2378,12 @@
 #endif
 
 //-----------------------------------------------------------------------------
 LONG WINAPI topLevelExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {
   if (InterceptOSException) return EXCEPTION_CONTINUE_SEARCH;
-  DWORD exception_code = exceptionInfo->ExceptionRecord->ExceptionCode;
+  PEXCEPTION_RECORD exception_record = exceptionInfo->ExceptionRecord;
+  DWORD exception_code = exception_record->ExceptionCode;
 #ifdef _M_AMD64
   address pc = (address) exceptionInfo->ContextRecord->Rip;
 #else
   address pc = (address) exceptionInfo->ContextRecord->Eip;
 #endif
@@ -2397,13 +2398,12 @@
   // Execution protection violation - win32 running on AMD64 only
   // Handled first to avoid misdiagnosis as a "normal" access violation;
   // This is safe to do because we have a new/unique ExceptionInformation
   // code for this condition.
   if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
-    PEXCEPTION_RECORD exceptionRecord = exceptionInfo->ExceptionRecord;
-    int exception_subcode = (int) exceptionRecord->ExceptionInformation[0];
-    address addr = (address) exceptionRecord->ExceptionInformation[1];
+    int exception_subcode = (int) exception_record->ExceptionInformation[0];
+    address addr = (address) exception_record->ExceptionInformation[1];
 
     if (exception_subcode == EXCEPTION_INFO_EXEC_VIOLATION) {
       int page_size = os::vm_page_size();
 
       // Make sure the pc and the faulting address are sane.
@@ -2463,11 +2463,11 @@
         }
       }
 
       // Last unguard failed or not unguarding
       tty->print_raw_cr("Execution protection violation");
-      report_error(t, exception_code, addr, exceptionInfo->ExceptionRecord,
+      report_error(t, exception_code, addr, exception_record,
                    exceptionInfo->ContextRecord);
       return EXCEPTION_CONTINUE_SEARCH;
     }
   }
 #endif // _WIN64
@@ -2479,45 +2479,44 @@
   }
 
   if (t != NULL && t->is_Java_thread()) {
     JavaThread* thread = (JavaThread*) t;
     bool in_java = thread->thread_state() == _thread_in_Java;
+    bool in_native = thread->thread_state() == _thread_in_native;
+    bool in_vm = thread->thread_state() == _thread_in_vm;
 
     // Handle potential stack overflows up front.
     if (exception_code == EXCEPTION_STACK_OVERFLOW) {
       if (thread->stack_guards_enabled()) {
         if (in_java) {
           frame fr;
-          PEXCEPTION_RECORD exceptionRecord = exceptionInfo->ExceptionRecord;
-          address addr = (address) exceptionRecord->ExceptionInformation[1];
           if (os::win32::get_frame_at_stack_banging_point(thread, exceptionInfo, pc, &fr)) {
             assert(fr.is_java_frame(), "Must be a Java frame");
             SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);
           }
         }
         // Yellow zone violation.  The o/s has unprotected the first yellow
         // zone page for us.  Note:  must call disable_stack_yellow_zone to
         // update the enabled status, even if the zone contains only one page.
-        assert(thread->thread_state() != _thread_in_vm, "Undersized StackShadowPages");
+        assert(!in_vm, "Undersized StackShadowPages");
         thread->disable_stack_yellow_reserved_zone();
         // If not in java code, return and hope for the best.
         return in_java
             ? Handle_Exception(exceptionInfo, SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW))
             :  EXCEPTION_CONTINUE_EXECUTION;
       } else {
         // Fatal red zone violation.
         thread->disable_stack_red_zone();
         tty->print_raw_cr("An unrecoverable stack overflow has occurred.");
-        report_error(t, exception_code, pc, exceptionInfo->ExceptionRecord,
+        report_error(t, exception_code, pc, exception_record,
                       exceptionInfo->ContextRecord);
         return EXCEPTION_CONTINUE_SEARCH;
       }
     } else if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
-      // Either stack overflow or null pointer exception.
       if (in_java) {
-        PEXCEPTION_RECORD exceptionRecord = exceptionInfo->ExceptionRecord;
-        address addr = (address) exceptionRecord->ExceptionInformation[1];
+        // Either stack overflow or null pointer exception.
+        address addr = (address) exception_record->ExceptionInformation[1];
         address stack_end = thread->stack_end();
         if (addr < stack_end && addr >= stack_end - os::vm_page_size()) {
           // Stack overflow.
           assert(!os::uses_stack_guard_pages(),
                  "should be caught by red zone code above.");
@@ -2532,51 +2531,42 @@
           if (SafepointMechanism::is_poll_address(addr)) {
             address stub = SharedRuntime::get_poll_stub(pc);
             return Handle_Exception(exceptionInfo, stub);
           }
         }
-        {
 #ifdef _WIN64
-          // If it's a legal stack address map the entire region in
-          //
-          PEXCEPTION_RECORD exceptionRecord = exceptionInfo->ExceptionRecord;
-          address addr = (address) exceptionRecord->ExceptionInformation[1];
-          if (thread->is_in_usable_stack(addr)) {
-            addr = (address)((uintptr_t)addr &
-                             (~((uintptr_t)os::vm_page_size() - (uintptr_t)1)));
-            os::commit_memory((char *)addr, thread->stack_base() - addr,
-                              !ExecMem);
-            return EXCEPTION_CONTINUE_EXECUTION;
-          } else
+        // If it's a legal stack address map the entire region in
+        if (thread->is_in_usable_stack(addr)) {
+          addr = (address)((uintptr_t)addr &
+                            (~((uintptr_t)os::vm_page_size() - (uintptr_t)1)));
+          os::commit_memory((char *)addr, thread->stack_base() - addr,
+                            !ExecMem);
+          return EXCEPTION_CONTINUE_EXECUTION;
+        }
 #endif
-          {
-            // Null pointer exception.
-            if (MacroAssembler::uses_implicit_null_check((void*)addr)) {
-              address stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
-              if (stub != NULL) return Handle_Exception(exceptionInfo, stub);
-            }
-            report_error(t, exception_code, pc, exceptionInfo->ExceptionRecord,
-                         exceptionInfo->ContextRecord);
-            return EXCEPTION_CONTINUE_SEARCH;
-          }
+        // Null pointer exception.
+        if (MacroAssembler::uses_implicit_null_check((void*)addr)) {
+          address stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
+          if (stub != NULL) return Handle_Exception(exceptionInfo, stub);
         }
+        report_error(t, exception_code, pc, exception_record,
+                      exceptionInfo->ContextRecord);
+        return EXCEPTION_CONTINUE_SEARCH;
       }
 
 #ifdef _WIN64
       // Special care for fast JNI field accessors.
       // jni_fast_Get<Primitive>Field can trap at certain pc's if a GC kicks
       // in and the heap gets shrunk before the field access.
-      if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
-        address addr = JNI_FastGetField::find_slowcase_pc(pc);
-        if (addr != (address)-1) {
-          return Handle_Exception(exceptionInfo, addr);
-        }
+      address slowcase_pc = JNI_FastGetField::find_slowcase_pc(pc);
+      if (slowcase_pc != (address)-1) {
+        return Handle_Exception(exceptionInfo, slowcase_pc);
       }
 #endif
 
       // Stack overflow or null pointer exception in native code.
-      report_error(t, exception_code, pc, exceptionInfo->ExceptionRecord,
+      report_error(t, exception_code, pc, exception_record,
                    exceptionInfo->ContextRecord);
       return EXCEPTION_CONTINUE_SEARCH;
     } // /EXCEPTION_ACCESS_VIOLATION
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
@@ -2586,15 +2576,12 @@
       if (in_java) {
         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
         nm = (cb != NULL) ? cb->as_compiled_method_or_null() : NULL;
       }
 
-      bool is_unsafe_arraycopy = (thread->thread_state() == _thread_in_native || in_java) && UnsafeCopyMemory::contains_pc(pc);
-      if (((thread->thread_state() == _thread_in_vm ||
-           thread->thread_state() == _thread_in_native ||
-           is_unsafe_arraycopy) &&
-          thread->doing_unsafe_access()) ||
+      bool is_unsafe_arraycopy = (in_native || in_java) && UnsafeCopyMemory::contains_pc(pc);
+      if (((in_vm || in_native || is_unsafe_arraycopy) && thread->doing_unsafe_access()) ||
           (nm != NULL && nm->has_unsafe_access())) {
         address next_pc =  Assembler::locate_next_instruction(pc);
         if (is_unsafe_arraycopy) {
           next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);
         }
@@ -2610,20 +2597,18 @@
       case EXCEPTION_INT_OVERFLOW:
         return Handle_IDiv_Exception(exceptionInfo);
 
       } // switch
     }
-    if (((thread->thread_state() == _thread_in_Java) ||
-         (thread->thread_state() == _thread_in_native)) &&
-         exception_code != EXCEPTION_UNCAUGHT_CXX_EXCEPTION) {
+    if ((in_java || in_native) && exception_code != EXCEPTION_UNCAUGHT_CXX_EXCEPTION) {
       LONG result=Handle_FLT_Exception(exceptionInfo);
       if (result==EXCEPTION_CONTINUE_EXECUTION) return result;
     }
   }
 
   if (exception_code != EXCEPTION_BREAKPOINT) {
-    report_error(t, exception_code, pc, exceptionInfo->ExceptionRecord,
+    report_error(t, exception_code, pc, exception_record,
                  exceptionInfo->ContextRecord);
   }
   return EXCEPTION_CONTINUE_SEARCH;
 }
 
diff a/src/hotspot/os/windows/threadCritical_windows.cpp b/src/hotspot/os/windows/threadCritical_windows.cpp
--- a/src/hotspot/os/windows/threadCritical_windows.cpp
+++ b/src/hotspot/os/windows/threadCritical_windows.cpp
@@ -33,14 +33,14 @@
 
 //
 // See threadCritical.hpp for details of this class.
 //
 
-static bool initialized = false;
-static volatile int lock_count = -1;
+static INIT_ONCE initialized = INIT_ONCE_STATIC_INIT;
+static int lock_count = 0;
 static HANDLE lock_event;
-static DWORD lock_owner = -1;
+static DWORD lock_owner = 0;
 
 //
 // Note that Microsoft's critical region code contains a race
 // condition, and is not suitable for use. A thread holding the
 // critical section cannot safely suspend a thread attempting
@@ -49,50 +49,38 @@
 //
 // I experiemented with the use of ordinary windows mutex objects
 // and found them ~30 times slower than the critical region code.
 //
 
+static BOOL WINAPI initialize(PINIT_ONCE InitOnce, PVOID Parameter, PVOID *Context) {
+  lock_event = CreateEvent(NULL, false, true, NULL);
+  assert(lock_event != NULL, "unexpected return value from CreateEvent");
+  return true;
+}
+
 ThreadCritical::ThreadCritical() {
-  DWORD current_thread = GetCurrentThreadId();
+  InitOnceExecuteOnce(&initialized, &initialize, NULL, NULL);
 
+  DWORD current_thread = GetCurrentThreadId();
   if (lock_owner != current_thread) {
     // Grab the lock before doing anything.
-    while (Atomic::cmpxchg(&lock_count, -1, 0) != -1) {
-      if (initialized) {
-        DWORD ret = WaitForSingleObject(lock_event,  INFINITE);
-        assert(ret == WAIT_OBJECT_0, "unexpected return value from WaitForSingleObject");
-      }
-    }
-
-    // Make sure the event object is allocated.
-    if (!initialized) {
-      // Locking will not work correctly unless this is autoreset.
-      lock_event = CreateEvent(NULL, false, false, NULL);
-      initialized = true;
-    }
-
-    assert(lock_owner == -1, "Lock acquired illegally.");
+    DWORD ret = WaitForSingleObject(lock_event,  INFINITE);
+    assert(ret == WAIT_OBJECT_0, "unexpected return value from WaitForSingleObject");
     lock_owner = current_thread;
-  } else {
-    // Atomicity isn't required. Bump the recursion count.
-    lock_count++;
   }
-
-  assert(lock_owner == GetCurrentThreadId(), "Lock acquired illegally.");
+  // Atomicity isn't required. Bump the recursion count.
+  lock_count++;
 }
 
 ThreadCritical::~ThreadCritical() {
   assert(lock_owner == GetCurrentThreadId(), "unlock attempt by wrong thread");
   assert(lock_count >= 0, "Attempt to unlock when already unlocked");
 
+  lock_count--;
   if (lock_count == 0) {
     // We're going to unlock
-    lock_owner = -1;
-    lock_count = -1;
+    lock_owner = 0;
     // No lost wakeups, lock_event stays signaled until reset.
     DWORD ret = SetEvent(lock_event);
     assert(ret != 0, "unexpected return value from SetEvent");
-  } else {
-    // Just unwinding a recursive lock;
-    lock_count--;
   }
 }
diff a/src/hotspot/os_cpu/windows_x86/atomic_windows_x86.hpp b/src/hotspot/os_cpu/windows_x86/atomic_windows_x86.hpp
--- a/src/hotspot/os_cpu/windows_x86/atomic_windows_x86.hpp
+++ b/src/hotspot/os_cpu/windows_x86/atomic_windows_x86.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,10 +23,11 @@
  */
 
 #ifndef OS_CPU_WINDOWS_X86_ATOMIC_WINDOWS_X86_HPP
 #define OS_CPU_WINDOWS_X86_ATOMIC_WINDOWS_X86_HPP
 
+#include <intrin.h>
 #include "runtime/os.hpp"
 
 // Note that in MSVC, volatile memory accesses are explicitly
 // guaranteed to have acquire release semantics (w.r.t. compiler
 // reordering) and therefore does not even need a compiler barrier
@@ -36,25 +37,10 @@
 template<> inline void ScopedFence<X_ACQUIRE>::postfix()       { }
 template<> inline void ScopedFence<RELEASE_X>::prefix()        { }
 template<> inline void ScopedFence<RELEASE_X_FENCE>::prefix()  { }
 template<> inline void ScopedFence<RELEASE_X_FENCE>::postfix() { OrderAccess::fence(); }
 
-// The following alternative implementations are needed because
-// Windows 95 doesn't support (some of) the corresponding Windows NT
-// calls. Furthermore, these versions allow inlining in the caller.
-// (More precisely: The documentation for InterlockedExchange says
-// it is supported for Windows 95. However, when single-stepping
-// through the assembly code we cannot step into the routine and
-// when looking at the routine address we see only garbage code.
-// Better safe then sorry!). Was bug 7/31/98 (gri).
-//
-// Performance note: On uniprocessors, the 'lock' prefixes are not
-// necessary (and expensive). We should generate separate cases if
-// this becomes a performance problem.
-
-#pragma warning(disable: 4035) // Disables warnings reporting missing return statement
-
 template<size_t byte_size>
 struct Atomic::PlatformAdd {
   template<typename D, typename I>
   D add_and_fetch(D volatile* dest, I add_value, atomic_memory_order order) const;
 
@@ -62,144 +48,74 @@
   D fetch_and_add(D volatile* dest, I add_value, atomic_memory_order order) const {
     return add_and_fetch(dest, add_value, order) - add_value;
   }
 };
 
-#ifdef AMD64
-template<>
-template<typename D, typename I>
-inline D Atomic::PlatformAdd<4>::add_and_fetch(D volatile* dest, I add_value,
-                                               atomic_memory_order order) const {
-  return add_using_helper<int32_t>(os::atomic_add_func, dest, add_value);
-}
-
-template<>
-template<typename D, typename I>
-inline D Atomic::PlatformAdd<8>::add_and_fetch(D volatile* dest, I add_value,
-                                               atomic_memory_order order) const {
-  return add_using_helper<int64_t>(os::atomic_add_long_func, dest, add_value);
-}
-
-#define DEFINE_STUB_XCHG(ByteSize, StubType, StubName)                  \
-  template<>                                                            \
-  template<typename T>                                                  \
-  inline T Atomic::PlatformXchg<ByteSize>::operator()(T volatile* dest, \
-                                                      T exchange_value, \
-                                                      atomic_memory_order order) const { \
-    STATIC_ASSERT(ByteSize == sizeof(T));                               \
-    return xchg_using_helper<StubType>(StubName, dest, exchange_value); \
+// The Interlocked* APIs only take long and will not accept __int32. That is
+// acceptable on Windows, since long is a 32-bits integer type.
+
+#define DEFINE_INTRINSIC_ADD(IntrinsicName, IntrinsicType)                \
+  template<>                                                              \
+  template<typename D, typename I>                                        \
+  inline D Atomic::PlatformAdd<sizeof(IntrinsicType)>::add_and_fetch(D volatile* dest, \
+                                                                     I add_value, \
+                                                                     atomic_memory_order order) const { \
+    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(D));                    \
+    return PrimitiveConversions::cast<D>(                                 \
+      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \
+                    PrimitiveConversions::cast<IntrinsicType>(add_value))); \
   }
 
-DEFINE_STUB_XCHG(4, int32_t, os::atomic_xchg_func)
-DEFINE_STUB_XCHG(8, int64_t, os::atomic_xchg_long_func)
-
-#undef DEFINE_STUB_XCHG
-
-#define DEFINE_STUB_CMPXCHG(ByteSize, StubType, StubName)                  \
-  template<>                                                               \
-  template<typename T>                                                     \
-  inline T Atomic::PlatformCmpxchg<ByteSize>::operator()(T volatile* dest, \
-                                                         T compare_value,  \
-                                                         T exchange_value, \
-                                                         atomic_memory_order order) const { \
-    STATIC_ASSERT(ByteSize == sizeof(T));                                  \
-    return cmpxchg_using_helper<StubType>(StubName, dest, compare_value, exchange_value); \
+DEFINE_INTRINSIC_ADD(InterlockedAdd,   long)
+DEFINE_INTRINSIC_ADD(InterlockedAdd64, __int64)
+
+#undef DEFINE_INTRINSIC_ADD
+
+#define DEFINE_INTRINSIC_XCHG(IntrinsicName, IntrinsicType)               \
+  template<>                                                              \
+  template<typename T>                                                    \
+  inline T Atomic::PlatformXchg<sizeof(IntrinsicType)>::operator()(T volatile* dest, \
+                                                                   T exchange_value, \
+                                                                   atomic_memory_order order) const { \
+    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(T));                    \
+    return PrimitiveConversions::cast<T>(                                 \
+      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \
+                    PrimitiveConversions::cast<IntrinsicType>(exchange_value))); \
   }
 
-DEFINE_STUB_CMPXCHG(1, int8_t,  os::atomic_cmpxchg_byte_func)
-DEFINE_STUB_CMPXCHG(4, int32_t, os::atomic_cmpxchg_func)
-DEFINE_STUB_CMPXCHG(8, int64_t, os::atomic_cmpxchg_long_func)
-
-#undef DEFINE_STUB_CMPXCHG
-
-#else // !AMD64
-
-template<>
-template<typename D, typename I>
-inline D Atomic::PlatformAdd<4>::add_and_fetch(D volatile* dest, I add_value,
-                                               atomic_memory_order order) const {
-  STATIC_ASSERT(4 == sizeof(I));
-  STATIC_ASSERT(4 == sizeof(D));
-  __asm {
-    mov edx, dest;
-    mov eax, add_value;
-    mov ecx, eax;
-    lock xadd dword ptr [edx], eax;
-    add eax, ecx;
+DEFINE_INTRINSIC_XCHG(InterlockedExchange,   long)
+DEFINE_INTRINSIC_XCHG(InterlockedExchange64, __int64)
+
+#undef DEFINE_INTRINSIC_XCHG
+
+// Note: the order of the parameters is different between
+// Atomic::PlatformCmpxchg<*>::operator() and the
+// InterlockedCompareExchange* API.
+
+#define DEFINE_INTRINSIC_CMPXCHG(IntrinsicName, IntrinsicType)            \
+  template<>                                                              \
+  template<typename T>                                                    \
+  inline T Atomic::PlatformCmpxchg<sizeof(IntrinsicType)>::operator()(T volatile* dest, \
+                                                                      T compare_value, \
+                                                                      T exchange_value, \
+                                                                      atomic_memory_order order) const { \
+    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(T));                    \
+    return PrimitiveConversions::cast<T>(                                 \
+      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \
+                    PrimitiveConversions::cast<IntrinsicType>(exchange_value), \
+                    PrimitiveConversions::cast<IntrinsicType>(compare_value))); \
   }
-}
 
-template<>
-template<typename T>
-inline T Atomic::PlatformXchg<4>::operator()(T volatile* dest,
-                                             T exchange_value,
-                                             atomic_memory_order order) const {
-  STATIC_ASSERT(4 == sizeof(T));
-  // alternative for InterlockedExchange
-  __asm {
-    mov eax, exchange_value;
-    mov ecx, dest;
-    xchg eax, dword ptr [ecx];
-  }
-}
+DEFINE_INTRINSIC_CMPXCHG(_InterlockedCompareExchange8, char) // Use the intrinsic as InterlockedCompareExchange8 does not exist
+DEFINE_INTRINSIC_CMPXCHG(InterlockedCompareExchange,   long)
+DEFINE_INTRINSIC_CMPXCHG(InterlockedCompareExchange64, __int64)
 
-template<>
-template<typename T>
-inline T Atomic::PlatformCmpxchg<1>::operator()(T volatile* dest,
-                                                T compare_value,
-                                                T exchange_value,
-                                                atomic_memory_order order) const {
-  STATIC_ASSERT(1 == sizeof(T));
-  // alternative for InterlockedCompareExchange
-  __asm {
-    mov edx, dest
-    mov cl, exchange_value
-    mov al, compare_value
-    lock cmpxchg byte ptr [edx], cl
-  }
-}
+#undef DEFINE_INTRINSIC_CMPXCHG
 
-template<>
-template<typename T>
-inline T Atomic::PlatformCmpxchg<4>::operator()(T volatile* dest,
-                                                T compare_value,
-                                                T exchange_value,
-                                                atomic_memory_order order) const {
-  STATIC_ASSERT(4 == sizeof(T));
-  // alternative for InterlockedCompareExchange
-  __asm {
-    mov edx, dest
-    mov ecx, exchange_value
-    mov eax, compare_value
-    lock cmpxchg dword ptr [edx], ecx
-  }
-}
+#ifndef AMD64
 
-template<>
-template<typename T>
-inline T Atomic::PlatformCmpxchg<8>::operator()(T volatile* dest,
-                                                T compare_value,
-                                                T exchange_value,
-                                                atomic_memory_order order) const {
-  STATIC_ASSERT(8 == sizeof(T));
-  int32_t ex_lo  = (int32_t)exchange_value;
-  int32_t ex_hi  = *( ((int32_t*)&exchange_value) + 1 );
-  int32_t cmp_lo = (int32_t)compare_value;
-  int32_t cmp_hi = *( ((int32_t*)&compare_value) + 1 );
-  __asm {
-    push ebx
-    push edi
-    mov eax, cmp_lo
-    mov edx, cmp_hi
-    mov edi, dest
-    mov ebx, ex_lo
-    mov ecx, ex_hi
-    lock cmpxchg8b qword ptr [edi]
-    pop edi
-    pop ebx
-  }
-}
+#pragma warning(disable: 4035) // Disables warnings reporting missing return statement
 
 template<>
 template<typename T>
 inline T Atomic::PlatformLoad<8>::operator()(T const volatile* src) const {
   STATIC_ASSERT(8 == sizeof(T));
@@ -226,15 +142,12 @@
     mov eax, dest
     fistp    qword ptr [eax]
   }
 }
 
-#endif // AMD64
-
 #pragma warning(default: 4035) // Enables warnings reporting missing return statement
 
-#ifndef AMD64
 template<>
 struct Atomic::PlatformOrderedStore<1, RELEASE_X_FENCE>
 {
   template <typename T>
   void operator()(volatile T* p, T v) const {
diff a/src/hotspot/os_cpu/windows_x86/os_windows_x86.cpp b/src/hotspot/os_cpu/windows_x86/os_windows_x86.cpp
--- a/src/hotspot/os_cpu/windows_x86/os_windows_x86.cpp
+++ b/src/hotspot/os_cpu/windows_x86/os_windows_x86.cpp
@@ -209,142 +209,10 @@
 
 #endif // AMD64
   return true;
 }
 
-// Atomics and Stub Functions
-
-typedef int32_t   xchg_func_t            (int32_t,  volatile int32_t*);
-typedef int64_t   xchg_long_func_t       (int64_t,  volatile int64_t*);
-typedef int32_t   cmpxchg_func_t         (int32_t,  volatile int32_t*, int32_t);
-typedef int8_t    cmpxchg_byte_func_t    (int8_t,   volatile int8_t*,  int8_t);
-typedef int64_t   cmpxchg_long_func_t    (int64_t,  volatile int64_t*, int64_t);
-typedef int32_t   add_func_t             (int32_t,  volatile int32_t*);
-typedef int64_t   add_long_func_t        (int64_t,  volatile int64_t*);
-
-#ifdef AMD64
-
-int32_t os::atomic_xchg_bootstrap(int32_t exchange_value, volatile int32_t* dest) {
-  // try to use the stub:
-  xchg_func_t* func = CAST_TO_FN_PTR(xchg_func_t*, StubRoutines::atomic_xchg_entry());
-
-  if (func != NULL) {
-    os::atomic_xchg_func = func;
-    return (*func)(exchange_value, dest);
-  }
-  assert(Threads::number_of_threads() == 0, "for bootstrap only");
-
-  int32_t old_value = *dest;
-  *dest = exchange_value;
-  return old_value;
-}
-
-int64_t os::atomic_xchg_long_bootstrap(int64_t exchange_value, volatile int64_t* dest) {
-  // try to use the stub:
-  xchg_long_func_t* func = CAST_TO_FN_PTR(xchg_long_func_t*, StubRoutines::atomic_xchg_long_entry());
-
-  if (func != NULL) {
-    os::atomic_xchg_long_func = func;
-    return (*func)(exchange_value, dest);
-  }
-  assert(Threads::number_of_threads() == 0, "for bootstrap only");
-
-  int64_t old_value = *dest;
-  *dest = exchange_value;
-  return old_value;
-}
-
-
-int32_t os::atomic_cmpxchg_bootstrap(int32_t exchange_value, volatile int32_t* dest, int32_t compare_value) {
-  // try to use the stub:
-  cmpxchg_func_t* func = CAST_TO_FN_PTR(cmpxchg_func_t*, StubRoutines::atomic_cmpxchg_entry());
-
-  if (func != NULL) {
-    os::atomic_cmpxchg_func = func;
-    return (*func)(exchange_value, dest, compare_value);
-  }
-  assert(Threads::number_of_threads() == 0, "for bootstrap only");
-
-  int32_t old_value = *dest;
-  if (old_value == compare_value)
-    *dest = exchange_value;
-  return old_value;
-}
-
-int8_t os::atomic_cmpxchg_byte_bootstrap(int8_t exchange_value, volatile int8_t* dest, int8_t compare_value) {
-  // try to use the stub:
-  cmpxchg_byte_func_t* func = CAST_TO_FN_PTR(cmpxchg_byte_func_t*, StubRoutines::atomic_cmpxchg_byte_entry());
-
-  if (func != NULL) {
-    os::atomic_cmpxchg_byte_func = func;
-    return (*func)(exchange_value, dest, compare_value);
-  }
-  assert(Threads::number_of_threads() == 0, "for bootstrap only");
-
-  int8_t old_value = *dest;
-  if (old_value == compare_value)
-    *dest = exchange_value;
-  return old_value;
-}
-
-#endif // AMD64
-
-int64_t os::atomic_cmpxchg_long_bootstrap(int64_t exchange_value, volatile int64_t* dest, int64_t compare_value) {
-  // try to use the stub:
-  cmpxchg_long_func_t* func = CAST_TO_FN_PTR(cmpxchg_long_func_t*, StubRoutines::atomic_cmpxchg_long_entry());
-
-  if (func != NULL) {
-    os::atomic_cmpxchg_long_func = func;
-    return (*func)(exchange_value, dest, compare_value);
-  }
-  assert(Threads::number_of_threads() == 0, "for bootstrap only");
-
-  int64_t old_value = *dest;
-  if (old_value == compare_value)
-    *dest = exchange_value;
-  return old_value;
-}
-
-#ifdef AMD64
-
-int32_t os::atomic_add_bootstrap(int32_t add_value, volatile int32_t* dest) {
-  // try to use the stub:
-  add_func_t* func = CAST_TO_FN_PTR(add_func_t*, StubRoutines::atomic_add_entry());
-
-  if (func != NULL) {
-    os::atomic_add_func = func;
-    return (*func)(add_value, dest);
-  }
-  assert(Threads::number_of_threads() == 0, "for bootstrap only");
-
-  return (*dest) += add_value;
-}
-
-int64_t os::atomic_add_long_bootstrap(int64_t add_value, volatile int64_t* dest) {
-  // try to use the stub:
-  add_long_func_t* func = CAST_TO_FN_PTR(add_long_func_t*, StubRoutines::atomic_add_long_entry());
-
-  if (func != NULL) {
-    os::atomic_add_long_func = func;
-    return (*func)(add_value, dest);
-  }
-  assert(Threads::number_of_threads() == 0, "for bootstrap only");
-
-  return (*dest) += add_value;
-}
-
-xchg_func_t*         os::atomic_xchg_func         = os::atomic_xchg_bootstrap;
-xchg_long_func_t*    os::atomic_xchg_long_func    = os::atomic_xchg_long_bootstrap;
-cmpxchg_func_t*      os::atomic_cmpxchg_func      = os::atomic_cmpxchg_bootstrap;
-cmpxchg_byte_func_t* os::atomic_cmpxchg_byte_func = os::atomic_cmpxchg_byte_bootstrap;
-add_func_t*          os::atomic_add_func          = os::atomic_add_bootstrap;
-add_long_func_t*     os::atomic_add_long_func     = os::atomic_add_long_bootstrap;
-
-#endif // AMD64
-
-cmpxchg_long_func_t* os::atomic_cmpxchg_long_func = os::atomic_cmpxchg_long_bootstrap;
-
 #ifdef AMD64
 /*
  * Windows/x64 does not use stack frames the way expected by Java:
  * [1] in most cases, there is no frame pointer. All locals are addressed via RSP
  * [2] in rare cases, when alloca() is used, a frame pointer is used, but this may
diff a/src/hotspot/os_cpu/windows_x86/os_windows_x86.hpp b/src/hotspot/os_cpu/windows_x86/os_windows_x86.hpp
--- a/src/hotspot/os_cpu/windows_x86/os_windows_x86.hpp
+++ b/src/hotspot/os_cpu/windows_x86/os_windows_x86.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -26,38 +26,10 @@
 #define OS_CPU_WINDOWS_X86_OS_WINDOWS_X86_HPP
 
   //
   // NOTE: we are back in class os here, not win32
   //
-#ifdef AMD64
-  static int32_t   (*atomic_xchg_func)          (int32_t, volatile int32_t*);
-  static int64_t   (*atomic_xchg_long_func)     (int64_t, volatile int64_t*);
-
-  static int32_t   (*atomic_cmpxchg_func)       (int32_t,  volatile int32_t*, int32_t);
-  static int8_t    (*atomic_cmpxchg_byte_func)  (int8_t,   volatile int8_t*,  int8_t);
-  static int64_t   (*atomic_cmpxchg_long_func)  (int64_t,  volatile int64_t*, int64_t);
-
-  static int32_t   (*atomic_add_func)           (int32_t,  volatile int32_t*);
-  static int64_t   (*atomic_add_long_func)      (int64_t,  volatile int64_t*);
-
-  static int32_t   atomic_xchg_bootstrap        (int32_t,  volatile int32_t*);
-  static int64_t   atomic_xchg_long_bootstrap   (int64_t,  volatile int64_t*);
-
-  static int32_t   atomic_cmpxchg_bootstrap     (int32_t,  volatile int32_t*, int32_t);
-  static int8_t    atomic_cmpxchg_byte_bootstrap(int8_t,   volatile int8_t*,  int8_t);
-#else
-
-  static int64_t (*atomic_cmpxchg_long_func)  (int64_t, volatile int64_t*, int64_t);
-
-#endif // AMD64
-
-  static int64_t atomic_cmpxchg_long_bootstrap(int64_t, volatile int64_t*, int64_t);
-
-#ifdef AMD64
-  static int32_t  atomic_add_bootstrap         (int32_t,  volatile int32_t*);
-  static int64_t  atomic_add_long_bootstrap    (int64_t,  volatile int64_t*);
-#endif // AMD64
 
   static void setup_fpu();
   static bool supports_sse() { return true; }
   static juint cpu_microcode_revision();
 
diff a/src/hotspot/os_cpu/windows_x86/thread_windows_x86.cpp b/src/hotspot/os_cpu/windows_x86/thread_windows_x86.cpp
--- a/src/hotspot/os_cpu/windows_x86/thread_windows_x86.cpp
+++ b/src/hotspot/os_cpu/windows_x86/thread_windows_x86.cpp
@@ -61,37 +61,26 @@
 
   // At this point, we don't have a last_Java_frame, so
   // we try to glean some information out of the CONTEXT
   // if we were running Java code when SIGPROF came in.
   if (isInJava) {
-    CONTEXT* uc = (CONTEXT*)ucontext;
-
-#ifdef AMD64
-    intptr_t* ret_fp = (intptr_t*) uc->Rbp;
-    intptr_t* ret_sp = (intptr_t*) uc->Rsp;
-    address addr = (address)uc->Rip;
-#else
-    intptr_t* ret_fp = (intptr_t*) uc->Ebp;
-    intptr_t* ret_sp = (intptr_t*) uc->Esp;
-    address addr = (address)uc->Eip;
-#endif // AMD64
-    if (addr == NULL || ret_sp == NULL ) {
+    frame ret_frame = os::fetch_frame_from_context(ucontext);
+    if (ret_frame.pc() == NULL || ret_frame.sp() == NULL ) {
       // CONTEXT wasn't useful
       return false;
     }
 
-    if (MetaspaceShared::is_in_trampoline_frame(addr)) {
+    if (MetaspaceShared::is_in_trampoline_frame(ret_frame.pc())) {
       // In the middle of a trampoline call. Bail out for safety.
       // This happens rarely so shouldn't affect profiling.
       return false;
     }
 
-    frame ret_frame(ret_sp, ret_fp, addr);
     if (!ret_frame.safe_for_sender(jt)) {
 #if COMPILER2_OR_JVMCI
       // C2 and JVMCI use ebp as a general register see if NULL fp helps
-      frame ret_frame2(ret_sp, NULL, addr);
+      frame ret_frame2(ret_frame.sp(), NULL, ret_frame.pc());
       if (!ret_frame2.safe_for_sender(jt)) {
         // nothing else to try if the frame isn't good
         return false;
       }
       ret_frame = ret_frame2;
diff a/src/hotspot/share/adlc/adlparse.cpp b/src/hotspot/share/adlc/adlparse.cpp
--- a/src/hotspot/share/adlc/adlparse.cpp
+++ b/src/hotspot/share/adlc/adlparse.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -1148,11 +1148,11 @@
   frame->_inline_cache_reg = parse_one_arg("inline cache reg entry");
 }
 
 //------------------------------interpreter_method_oop_parse------------------
 void ADLParser::interpreter_method_oop_parse(FrameForm *frame, bool native) {
-  frame->_interpreter_method_oop_reg = parse_one_arg("method oop reg entry");
+  frame->_interpreter_method_oop_reg = parse_one_arg("method reg entry");
 }
 
 //------------------------------cisc_spilling_operand_parse---------------------
 void ADLParser::cisc_spilling_operand_name_parse(FrameForm *frame, bool native) {
   frame->_cisc_spilling_operand_name = parse_one_arg("cisc spilling operand name");
diff a/src/hotspot/share/c1/c1_CodeStubs.hpp b/src/hotspot/share/c1/c1_CodeStubs.hpp
--- a/src/hotspot/share/c1/c1_CodeStubs.hpp
+++ b/src/hotspot/share/c1/c1_CodeStubs.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -381,11 +381,11 @@
   Label         _patched_code_entry;
   Label         _patch_site_entry;
   Label         _patch_site_continuation;
   Register      _obj;
   CodeEmitInfo* _info;
-  int           _index;  // index of the patchable oop or Klass* in nmethod oop or metadata table if needed
+  int           _index;  // index of the patchable oop or Klass* in nmethod or metadata table if needed
   static int    _patch_info_offset;
 
   void align_patch_site(MacroAssembler* masm);
 
  public:
diff a/src/hotspot/share/c1/c1_Runtime1.cpp b/src/hotspot/share/c1/c1_Runtime1.cpp
--- a/src/hotspot/share/c1/c1_Runtime1.cpp
+++ b/src/hotspot/share/c1/c1_Runtime1.cpp
@@ -427,11 +427,11 @@
 JRT_END
 
 
 // counter_overflow() is called from within C1-compiled methods. The enclosing method is the method
 // associated with the top activation record. The inlinee (that is possibly included in the enclosing
-// method) method oop is passed as an argument. In order to do that it is embedded in the code as
+// method) method is passed as an argument. In order to do that it is embedded in the code as
 // a constant.
 static nmethod* counter_overflow_helper(JavaThread* THREAD, int branch_bci, Method* m) {
   nmethod* osr_nm = NULL;
   methodHandle method(THREAD, m);
 
diff a/src/hotspot/share/ci/ciReplay.cpp b/src/hotspot/share/ci/ciReplay.cpp
--- a/src/hotspot/share/ci/ciReplay.cpp
+++ b/src/hotspot/share/ci/ciReplay.cpp
@@ -625,11 +625,11 @@
 
     // To be properly initialized, some profiling in the MDO needs the
     // method to be rewritten (number of arguments at a call for
     // instance)
     method->method_holder()->link_class(CHECK);
-    // methodOopDesc::build_interpreter_method_data(method, CHECK);
+    // Method::build_interpreter_method_data(method, CHECK);
     {
       // Grab a lock here to prevent multiple
       // MethodData*s from being created.
       MutexLocker ml(THREAD, MethodData_lock);
       if (method->method_data() == NULL) {
@@ -1106,12 +1106,12 @@
   }
   return data;
 }
 
 int ciReplay::replay_impl(TRAPS) {
-  HandleMark hm;
-  ResourceMark rm;
+  HandleMark hm(THREAD);
+  ResourceMark rm(THREAD);
 
   if (ReplaySuppressInitializers > 2) {
     // ReplaySuppressInitializers > 2 means that we want to allow
     // normal VM bootstrap but once we get into the replay itself
     // don't allow any intializers to be run.
diff a/src/hotspot/share/classfile/classLoaderDataGraph.cpp b/src/hotspot/share/classfile/classLoaderDataGraph.cpp
--- a/src/hotspot/share/classfile/classLoaderDataGraph.cpp
+++ b/src/hotspot/share/classfile/classLoaderDataGraph.cpp
@@ -304,18 +304,18 @@
 
 // Iterating over the CLDG needs to be locked because
 // unloading can remove entries concurrently soon.
 class ClassLoaderDataGraphIterator : public StackObj {
   ClassLoaderData* _next;
+  Thread*          _thread;
   HandleMark       _hm;  // clean up handles when this is done.
   Handle           _holder;
-  Thread*          _thread;
   NoSafepointVerifier _nsv; // No safepoints allowed in this scope
                             // unless verifying at a safepoint.
 
 public:
-  ClassLoaderDataGraphIterator() : _next(ClassLoaderDataGraph::_head) {
+  ClassLoaderDataGraphIterator() : _next(ClassLoaderDataGraph::_head), _thread(Thread::current()), _hm(_thread) {
     _thread = Thread::current();
     assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
   }
 
   ClassLoaderData* get_next() {
diff a/src/hotspot/share/classfile/dictionary.hpp b/src/hotspot/share/classfile/dictionary.hpp
--- a/src/hotspot/share/classfile/dictionary.hpp
+++ b/src/hotspot/share/classfile/dictionary.hpp
@@ -193,10 +193,13 @@
   void set_method(Method* p)        { _method = p; }
 
   oop      method_type() const;
   void set_method_type(oop p);
 
+  // We need to clear the OopHandle because these hashtable entries are not constructed properly.
+  void clear_method_type() { _method_type = OopHandle(); }
+
   void free_entry();
 
   SymbolPropertyEntry* next() const {
     return (SymbolPropertyEntry*)HashtableEntry<Symbol*, mtSymbol>::next();
   }
@@ -245,11 +248,11 @@
     SymbolPropertyEntry* entry = (SymbolPropertyEntry*) Hashtable<Symbol*, mtSymbol>::new_entry(hash, symbol);
     // Hashtable with Symbol* literal must increment and decrement refcount.
     symbol->increment_refcount();
     entry->set_symbol_mode(symbol_mode);
     entry->set_method(NULL);
-    entry->set_method_type(NULL);
+    entry->clear_method_type();
     return entry;
   }
 
 public:
   SymbolPropertyTable(int table_size);
diff a/src/hotspot/share/classfile/javaClasses.cpp b/src/hotspot/share/classfile/javaClasses.cpp
--- a/src/hotspot/share/classfile/javaClasses.cpp
+++ b/src/hotspot/share/classfile/javaClasses.cpp
@@ -893,11 +893,11 @@
     if (HeapShared::open_archive_heap_region_mapped()) {
       bool present = restore_archived_mirror(k, Handle(), Handle(), Handle(), CHECK);
       assert(present, "Missing archived mirror for %s", k->external_name());
       return;
     } else {
-      k->set_java_mirror_handle(OopHandle());
+      k->clear_java_mirror_handle();
       k->clear_has_raw_archived_mirror();
     }
   }
   create_mirror(k, Handle(), Handle(), Handle(), Handle(), CHECK);
 }
@@ -1119,12 +1119,13 @@
 
 void java_lang_Class::archive_basic_type_mirrors(TRAPS) {
   assert(HeapShared::is_heap_object_archiving_allowed(),
          "HeapShared::is_heap_object_archiving_allowed() must be true");
 
-  for (int t = 0; t <= T_VOID; t++) {
-    oop m = Universe::_mirrors[t];
+  for (int t = T_BOOLEAN; t < T_VOID+1; t++) {
+    BasicType bt = (BasicType)t;
+    oop m = Universe::_mirrors[t].resolve();
     if (m != NULL) {
       // Update the field at _array_klass_offset to point to the relocated array klass.
       oop archived_m = HeapShared::archive_heap_object(m, THREAD);
       assert(archived_m != NULL, "sanity");
       Klass *ak = (Klass*)(archived_m->metadata_field(_array_klass_offset));
@@ -1140,37 +1141,16 @@
       ResetMirrorField reset(archived_mirror_h);
       InstanceKlass::cast(k)->do_nonstatic_fields(&reset);
 
       log_trace(cds, heap, mirror)(
         "Archived %s mirror object from " PTR_FORMAT " ==> " PTR_FORMAT,
-        type2name((BasicType)t), p2i(Universe::_mirrors[t]), p2i(archived_m));
+        type2name(bt), p2i(m), p2i(archived_m));
 
-      Universe::_mirrors[t] = archived_m;
+      Universe::replace_mirror(bt, archived_m);
     }
   }
-
-  assert(Universe::_mirrors[T_INT] != NULL &&
-         Universe::_mirrors[T_FLOAT] != NULL &&
-         Universe::_mirrors[T_DOUBLE] != NULL &&
-         Universe::_mirrors[T_BYTE] != NULL &&
-         Universe::_mirrors[T_BOOLEAN] != NULL &&
-         Universe::_mirrors[T_CHAR] != NULL &&
-         Universe::_mirrors[T_LONG] != NULL &&
-         Universe::_mirrors[T_SHORT] != NULL &&
-         Universe::_mirrors[T_VOID] != NULL, "sanity");
-
-  Universe::set_int_mirror(Universe::_mirrors[T_INT]);
-  Universe::set_float_mirror(Universe::_mirrors[T_FLOAT]);
-  Universe::set_double_mirror(Universe::_mirrors[T_DOUBLE]);
-  Universe::set_byte_mirror(Universe::_mirrors[T_BYTE]);
-  Universe::set_bool_mirror(Universe::_mirrors[T_BOOLEAN]);
-  Universe::set_char_mirror(Universe::_mirrors[T_CHAR]);
-  Universe::set_long_mirror(Universe::_mirrors[T_LONG]);
-  Universe::set_short_mirror(Universe::_mirrors[T_SHORT]);
-  Universe::set_void_mirror(Universe::_mirrors[T_VOID]);
 }
-
 //
 // After the mirror object is successfully archived, the archived
 // klass is set with _has_archived_raw_mirror flag.
 //
 // The _has_archived_raw_mirror flag is cleared at runtime when the
@@ -1199,11 +1179,11 @@
 
     if (!(ik->is_shared_boot_class() || ik->is_shared_platform_class() ||
           ik->is_shared_app_class())) {
       // Archiving mirror for classes from non-builtin loaders is not
       // supported. Clear the _java_mirror within the archived class.
-      k->set_java_mirror_handle(OopHandle());
+      k->clear_java_mirror_handle();
       return NULL;
     }
   }
 
   // Now start archiving the mirror object
diff a/src/hotspot/share/classfile/klassFactory.cpp b/src/hotspot/share/classfile/klassFactory.cpp
--- a/src/hotspot/share/classfile/klassFactory.cpp
+++ b/src/hotspot/share/classfile/klassFactory.cpp
@@ -171,12 +171,12 @@
                                                 TRAPS) {
   assert(stream != NULL, "invariant");
   assert(loader_data != NULL, "invariant");
   assert(THREAD->is_Java_thread(), "must be a JavaThread");
 
-  ResourceMark rm;
-  HandleMark hm;
+  ResourceMark rm(THREAD);
+  HandleMark hm(THREAD);
 
   JvmtiCachedClassFileData* cached_class_file = NULL;
 
   ClassFileStream* old_stream = stream;
 
diff a/src/hotspot/share/classfile/systemDictionaryShared.cpp b/src/hotspot/share/classfile/systemDictionaryShared.cpp
--- a/src/hotspot/share/classfile/systemDictionaryShared.cpp
+++ b/src/hotspot/share/classfile/systemDictionaryShared.cpp
@@ -1771,11 +1771,11 @@
   }
   if (klass->is_shared_platform_class() || klass->is_shared_app_class()) {
     RunTimeSharedClassInfo* info = RunTimeSharedClassInfo::get_for(klass);
     assert(info != NULL, "Sanity");
     if (info->_num_loader_constraints > 0) {
-      HandleMark hm;
+      HandleMark hm(THREAD);
       for (int i = 0; i < info->_num_loader_constraints; i++) {
         RunTimeSharedClassInfo::RTLoaderConstraint* lc = info->loader_constraint_at(i);
         Symbol* name = lc->constraint_name();
         Handle loader1(THREAD, get_class_loader_by(lc->_loader_type1));
         Handle loader2(THREAD, get_class_loader_by(lc->_loader_type2));
diff a/src/hotspot/share/code/nmethod.cpp b/src/hotspot/share/code/nmethod.cpp
--- a/src/hotspot/share/code/nmethod.cpp
+++ b/src/hotspot/share/code/nmethod.cpp
@@ -879,11 +879,10 @@
 
 
 void nmethod::log_new_nmethod() const {
   if (LogCompilation && xtty != NULL) {
     ttyLocker ttyl;
-    HandleMark hm;
     xtty->begin_elem("nmethod");
     log_identity(xtty);
     xtty->print(" entry='" INTPTR_FORMAT "' size='%d'", p2i(code_begin()), size());
     xtty->print(" address='" INTPTR_FORMAT "'", p2i(this));
 
@@ -937,11 +936,10 @@
     xtty->end_head();
   }
   // Print the header part, then print the requested information.
   // This is both handled in decode2().
   if (printmethod) {
-    HandleMark hm;
     ResourceMark m;
     if (is_compiled_by_c1()) {
       tty->cr();
       tty->print_cr("============================= C1-compiled nmethod ==============================");
     }
@@ -2422,20 +2420,23 @@
   metadata_do(&vmc);
 }
 
 
 void nmethod::verify_interrupt_point(address call_site) {
+
   // Verify IC only when nmethod installation is finished.
   if (!is_not_installed()) {
     if (CompiledICLocker::is_safe(this)) {
       CompiledIC_at(this, call_site);
     } else {
       CompiledICLocker ml_verify(this);
       CompiledIC_at(this, call_site);
     }
   }
 
+  HandleMark hm(Thread::current());
+
   PcDesc* pd = pc_desc_at(nativeCall_at(call_site)->return_address());
   assert(pd != NULL, "PcDesc must exist");
   for (ScopeDesc* sd = new ScopeDesc(this, pd->scope_decode_offset(),
                                      pd->obj_decode_offset(), pd->should_reexecute(), pd->rethrow_exception(),
                                      pd->return_oop());
@@ -2571,11 +2572,10 @@
                                              jvmci_data_size());
 #endif
 }
 
 void nmethod::print_code() {
-  HandleMark hm;
   ResourceMark m;
   ttyLocker ttyl;
   // Call the specialized decode method of this class.
   decode(tty);
 }
@@ -2601,11 +2601,10 @@
 
 #if defined(SUPPORT_DATA_STRUCTS)
 
 // Print the oops from the underlying CodeBlob.
 void nmethod::print_oops(outputStream* st) {
-  HandleMark hm;
   ResourceMark m;
   st->print("Oops:");
   if (oops_begin() < oops_end()) {
     st->cr();
     for (oop* p = oops_begin(); p < oops_end(); p++) {
@@ -2627,11 +2626,10 @@
   }
 }
 
 // Print metadata pool.
 void nmethod::print_metadata(outputStream* st) {
-  HandleMark hm;
   ResourceMark m;
   st->print("Metadata:");
   if (metadata_begin() < metadata_end()) {
     st->cr();
     for (Metadata** p = metadata_begin(); p < metadata_end(); p++) {
diff a/src/hotspot/share/code/scopeDesc.cpp b/src/hotspot/share/code/scopeDesc.cpp
--- a/src/hotspot/share/code/scopeDesc.cpp
+++ b/src/hotspot/share/code/scopeDesc.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -251,11 +251,13 @@
 }
 
 #endif
 
 void ScopeDesc::verify() {
-  ResourceMark rm;
+  Thread* current_thread = Thread::current();
+  ResourceMark rm(current_thread);
+  HandleMark hm(current_thread);
   guarantee(method()->is_method(), "type check");
 
   // check if we have any illegal elements on the expression stack
   { GrowableArray<ScopeValue*>* l = expressions();
     if (l != NULL) {
diff a/src/hotspot/share/code/vtableStubs.cpp b/src/hotspot/share/code/vtableStubs.cpp
--- a/src/hotspot/share/code/vtableStubs.cpp
+++ b/src/hotspot/share/code/vtableStubs.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -318,11 +318,10 @@
 // Non-product code
 #ifndef PRODUCT
 
 extern "C" void bad_compiled_vtable_index(JavaThread* thread, oop receiver, int index) {
   ResourceMark rm;
-  HandleMark hm;
   Klass* klass = receiver->klass();
   InstanceKlass* ik = InstanceKlass::cast(klass);
   klassVtable vt = ik->vtable();
   ik->print();
   fatal("bad compiled vtable dispatch: receiver " INTPTR_FORMAT ", "
diff a/src/hotspot/share/compiler/compileBroker.cpp b/src/hotspot/share/compiler/compileBroker.cpp
--- a/src/hotspot/share/compiler/compileBroker.cpp
+++ b/src/hotspot/share/compiler/compileBroker.cpp
@@ -1653,11 +1653,11 @@
 
   methodHandle method(thread, task->method());
   bool free_task;
 #if INCLUDE_JVMCI
   AbstractCompiler* comp = compiler(task->comp_level());
-  if (!UseJVMCINativeLibrary && comp->is_jvmci() && !task->should_wait_for_compilation()) {
+  if (comp->is_jvmci() && !task->should_wait_for_compilation()) {
     // It may return before compilation is completed.
     free_task = wait_for_jvmci_completion((JVMCICompiler*) comp, task, thread);
   } else
 #endif
   {
diff a/src/hotspot/share/compiler/compileTask.hpp b/src/hotspot/share/compiler/compileTask.hpp
--- a/src/hotspot/share/compiler/compileTask.hpp
+++ b/src/hotspot/share/compiler/compileTask.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -40,19 +40,16 @@
   friend class VMStructs;
   friend class JVMCIVMStructs;
 
  public:
   // Different reasons for a compilation
-  // The order is important - Reason_Whitebox and higher can not become
-  // stale, see CompileTask::can_become_stale()
-  // Also mapped to reason_names[]
+  // The order is important - mapped to reason_names[]
   enum CompileReason {
       Reason_None,
       Reason_InvocationCount,  // Simple/StackWalk-policy
       Reason_BackedgeCount,    // Simple/StackWalk-policy
       Reason_Tiered,           // Tiered-policy
-      Reason_CTW,              // Compile the world
       Reason_Replay,           // ciReplay
       Reason_Whitebox,         // Whitebox API
       Reason_MustBeCompiled,   // Used for -Xcomp or AlwaysCompileLoopMethods (see CompilationPolicy::must_be_compiled())
       Reason_Bootstrap,        // JVMCI bootstrap
       Reason_Count
@@ -62,11 +59,10 @@
     static const char* reason_names[] = {
       "no_reason",
       "count",
       "backedge_count",
       "tiered",
-      "CTW",
       "replay",
       "whitebox",
       "must_be_compiled",
       "bootstrap"
     };
@@ -135,11 +131,10 @@
   }
 #if INCLUDE_JVMCI
   bool         should_wait_for_compilation() const {
     // Wait for blocking compilation to finish.
     switch (_compile_reason) {
-        case Reason_CTW:
         case Reason_Replay:
         case Reason_Whitebox:
         case Reason_Bootstrap:
           return _is_blocking;
         default:
diff a/src/hotspot/share/gc/g1/g1CollectedHeap.cpp b/src/hotspot/share/gc/g1/g1CollectedHeap.cpp
--- a/src/hotspot/share/gc/g1/g1CollectedHeap.cpp
+++ b/src/hotspot/share/gc/g1/g1CollectedHeap.cpp
@@ -3414,11 +3414,10 @@
   {}
 
   virtual void work(uint worker_id) {
     // The reference processing task executed by a single worker.
     ResourceMark rm;
-    HandleMark   hm;
 
     G1STWIsAliveClosure is_alive(_g1h);
 
     G1ParScanThreadState* pss = _pss->state_for_worker(worker_id);
     pss->set_ref_discoverer(NULL);
@@ -3787,11 +3786,10 @@
   void work(uint worker_id) {
     start_work(worker_id);
 
     {
       ResourceMark rm;
-      HandleMark   hm;
 
       G1ParScanThreadState* pss = _per_thread_states->state_for_worker(worker_id);
       pss->set_ref_discoverer(_g1h->ref_processor_stw());
 
       scan_roots(pss, worker_id);
diff a/src/hotspot/share/gc/g1/g1ConcurrentMark.cpp b/src/hotspot/share/gc/g1/g1ConcurrentMark.cpp
--- a/src/hotspot/share/gc/g1/g1ConcurrentMark.cpp
+++ b/src/hotspot/share/gc/g1/g1ConcurrentMark.cpp
@@ -1477,11 +1477,10 @@
     assert(rp->processing_is_mt(), "shouldn't be here otherwise");
   }
 
   virtual void work(uint worker_id) {
     ResourceMark rm;
-    HandleMark hm;
     G1CMTask* task = _cm->task(worker_id);
     G1CMIsAliveClosure g1_is_alive(_g1h);
     G1CMKeepAliveAndDrainClosure g1_par_keep_alive(_cm, task, false /* is_serial */);
     G1CMDrainMarkingStackClosure g1_par_drain(_cm, task, false /* is_serial */);
 
@@ -1506,11 +1505,10 @@
   _workers->run_task(&proc_task_proxy, ergo_workers);
 }
 
 void G1ConcurrentMark::weak_refs_work(bool clear_all_soft_refs) {
   ResourceMark rm;
-  HandleMark   hm;
 
   // Is alive closure.
   G1CMIsAliveClosure g1_is_alive(_g1h);
 
   // Inner scope to exclude the cleaning of the string table
@@ -1753,11 +1751,10 @@
   void work(uint worker_id) {
     G1CMTask* task = _cm->task(worker_id);
     task->record_start_time();
     {
       ResourceMark rm;
-      HandleMark hm;
 
       G1RemarkThreadsClosure threads_f(G1CollectedHeap::heap(), task);
       Threads::threads_do(&threads_f);
     }
 
@@ -1777,11 +1774,10 @@
   }
 };
 
 void G1ConcurrentMark::finalize_marking() {
   ResourceMark rm;
-  HandleMark   hm;
 
   _g1h->ensure_parsability(false);
 
   // this is remark, so we'll use up all active threads
   uint active_workers = _g1h->workers()->active_workers();
diff a/src/hotspot/share/gc/g1/g1ConcurrentMarkThread.cpp b/src/hotspot/share/gc/g1/g1ConcurrentMarkThread.cpp
--- a/src/hotspot/share/gc/g1/g1ConcurrentMarkThread.cpp
+++ b/src/hotspot/share/gc/g1/g1ConcurrentMarkThread.cpp
@@ -151,11 +151,11 @@
     _cm->concurrent_cycle_start();
 
     GCTraceConcTime(Info, gc) tt("Concurrent Cycle");
     {
       ResourceMark rm;
-      HandleMark   hm;
+
       double cycle_start = os::elapsedVTime();
 
       {
         G1ConcPhaseTimer p(_cm, "Concurrent Clear Claimed Marks");
         ClassLoaderDataGraph::clear_claimed_marks();
diff a/src/hotspot/share/gc/g1/g1FullCollector.cpp b/src/hotspot/share/gc/g1/g1FullCollector.cpp
--- a/src/hotspot/share/gc/g1/g1FullCollector.cpp
+++ b/src/hotspot/share/gc/g1/g1FullCollector.cpp
@@ -275,11 +275,10 @@
   if (!VerifyDuringGC || !_heap->verifier()->should_verify(G1HeapVerifier::G1VerifyFull)) {
     // Only do verification if VerifyDuringGC and G1VerifyFull is set.
     return;
   }
 
-  HandleMark hm;  // handle scope
 #if COMPILER2_OR_JVMCI
   DerivedPointerTableDeactivate dpt_deact;
 #endif
   _heap->prepare_for_verify();
   // Note: we can verify only the heap here. When an object is
diff a/src/hotspot/share/gc/g1/g1HeapVerifier.cpp b/src/hotspot/share/gc/g1/g1HeapVerifier.cpp
--- a/src/hotspot/share/gc/g1/g1HeapVerifier.cpp
+++ b/src/hotspot/share/gc/g1/g1HeapVerifier.cpp
@@ -447,11 +447,10 @@
   bool failures() {
     return _failures;
   }
 
   void work(uint worker_id) {
-    HandleMark hm;
     VerifyRegionClosure blk(true, _vo);
     _g1h->heap_region_par_iterate_from_worker_offset(&blk, &_hrclaimer, worker_id);
     if (blk.failures()) {
       _failures = true;
     }
@@ -617,11 +616,10 @@
 double G1HeapVerifier::verify(G1VerifyType type, VerifyOption vo, const char* msg) {
   double verify_time_ms = 0.0;
 
   if (should_verify(type) && _g1h->total_collections() >= VerifyGCStartAt) {
     double verify_start = os::elapsedTime();
-    HandleMark hm;  // Discard invalid handles created during verification
     prepare_for_verify();
     Universe::verify(vo, msg);
     verify_time_ms = (os::elapsedTime() - verify_start) * 1000;
   }
 
diff a/src/hotspot/share/gc/g1/heapRegionRemSet.cpp b/src/hotspot/share/gc/g1/heapRegionRemSet.cpp
--- a/src/hotspot/share/gc/g1/heapRegionRemSet.cpp
+++ b/src/hotspot/share/gc/g1/heapRegionRemSet.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -68,11 +68,11 @@
 OtherRegionsTable::OtherRegionsTable(Mutex* m) :
   _g1h(G1CollectedHeap::heap()),
   _m(m),
   _num_occupied(0),
   _coarse_map(mtGC),
-  _n_coarse_entries(0),
+  _has_coarse_entries(false),
   _fine_grain_regions(NULL),
   _n_fine_entries(0),
   _first_all_fine_prts(NULL),
   _last_all_fine_prts(NULL),
   _fine_eviction_start(0),
@@ -259,23 +259,23 @@
   }
 
   guarantee(max != NULL, "Since _n_fine_entries > 0");
   guarantee(max_prev != NULL, "Since max != NULL.");
 
-  // Set the corresponding coarse bit.
+  // Ensure the corresponding coarse bit is set.
   size_t max_hrm_index = (size_t) max->hr()->hrm_index();
-  if (_n_coarse_entries == 0) {
+  if (Atomic::load(&_has_coarse_entries)) {
+    _coarse_map.at_put(max_hrm_index, true);
+  } else {
     // This will lazily initialize an uninitialized bitmap
     _coarse_map.reinitialize(G1CollectedHeap::heap()->max_regions());
+    assert(!_coarse_map.at(max_hrm_index), "No coarse entries");
     _coarse_map.at_put(max_hrm_index, true);
     // Release store guarantees that the bitmap has initialized before any
-    // concurrent reader will ever see a non-zero value for _n_coarse_entries
+    // concurrent reader will ever see _has_coarse_entries is true
     // (when read with load_acquire)
-    Atomic::release_store(&_n_coarse_entries, _n_coarse_entries + 1);
-  } else if (!_coarse_map.at(max_hrm_index)) {
-    _coarse_map.at_put(max_hrm_index, true);
-    _n_coarse_entries++;
+    Atomic::release_store(&_has_coarse_entries, true);
   }
 
   added_by_deleted = HeapRegion::CardsPerRegion - max_occ;
   // Unsplice.
   *max_prev = max->collision_list_next();
@@ -329,15 +329,15 @@
     guarantee(_first_all_fine_prts == NULL && _last_all_fine_prts == NULL, "just checking");
   }
 
   _first_all_fine_prts = _last_all_fine_prts = NULL;
   _sparse_table.clear();
-  if (_n_coarse_entries > 0) {
+  if (Atomic::load(&_has_coarse_entries)) {
     _coarse_map.clear();
   }
   _n_fine_entries = 0;
-  _n_coarse_entries = 0;
+  Atomic::store(&_has_coarse_entries, false);
 
   _num_occupied = 0;
 }
 
 bool OtherRegionsTable::contains_reference(OopOrNarrowOopStar from) const {
@@ -360,15 +360,15 @@
     CardIdx_t card_index = card_within_region(from, hr);
     return _sparse_table.contains_card(hr_ind, card_index);
   }
 }
 
-// A load_acquire on _n_coarse_entries - coupled with the release_store in
+// A load_acquire on _has_coarse_entries - coupled with the release_store in
 // delete_region_table - guarantees we don't access _coarse_map before
 // it's been properly initialized.
 bool OtherRegionsTable::is_region_coarsened(RegionIdx_t from_hrm_ind) const {
-  return Atomic::load_acquire(&_n_coarse_entries) > 0 && _coarse_map.at(from_hrm_ind);
+  return Atomic::load_acquire(&_has_coarse_entries) && _coarse_map.at(from_hrm_ind);
 }
 
 HeapRegionRemSet::HeapRegionRemSet(G1BlockOffsetTable* bot,
                                    HeapRegion* hr)
   : _bot(bot),
diff a/src/hotspot/share/gc/g1/heapRegionRemSet.hpp b/src/hotspot/share/gc/g1/heapRegionRemSet.hpp
--- a/src/hotspot/share/gc/g1/heapRegionRemSet.hpp
+++ b/src/hotspot/share/gc/g1/heapRegionRemSet.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -72,13 +72,13 @@
   Mutex*           _m;
 
   size_t volatile _num_occupied;
 
   // These are protected by "_m".
-  CHeapBitMap _coarse_map;
-  size_t      _n_coarse_entries;
-  static jint _n_coarsenings;
+  CHeapBitMap   _coarse_map;
+  bool volatile _has_coarse_entries;
+  static jint   _n_coarsenings;
 
   PerRegionTable** _fine_grain_regions;
   size_t           _n_fine_entries;
 
   // The fine grain remembered sets are linked together using
diff a/src/hotspot/share/gc/g1/heapRegionRemSet.inline.hpp b/src/hotspot/share/gc/g1/heapRegionRemSet.inline.hpp
--- a/src/hotspot/share/gc/g1/heapRegionRemSet.inline.hpp
+++ b/src/hotspot/share/gc/g1/heapRegionRemSet.inline.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -71,11 +71,11 @@
   Atomic::release_store(&_hr, hr);
 }
 
 template <class Closure>
 void OtherRegionsTable::iterate(Closure& cl) {
-  if (_n_coarse_entries > 0) {
+  if (Atomic::load(&_has_coarse_entries)) {
     BitMap::idx_t cur = _coarse_map.get_next_one_offset(0);
     while (cur != _coarse_map.size()) {
       cl.next_coarse_prt((uint)cur);
       cur = _coarse_map.get_next_one_offset(cur + 1);
     }
diff a/src/hotspot/share/gc/parallel/psParallelCompact.cpp b/src/hotspot/share/gc/parallel/psParallelCompact.cpp
--- a/src/hotspot/share/gc/parallel/psParallelCompact.cpp
+++ b/src/hotspot/share/gc/parallel/psParallelCompact.cpp
@@ -1005,11 +1005,10 @@
 
   // Fill in TLABs
   heap->ensure_parsability(true);  // retire TLABs
 
   if (VerifyBeforeGC && heap->total_collections() >= VerifyGCStartAt) {
-    HandleMark hm;  // Discard invalid handles created during verification
     Universe::verify("Before GC");
   }
 
   // Verify object start arrays
   if (VerifyObjectStartArray &&
@@ -1786,11 +1785,10 @@
   ParCompactionManager* const vmthread_cm =
     ParCompactionManager::manager_array(ParallelScavengeHeap::heap()->workers().total_workers());
 
   {
     ResourceMark rm;
-    HandleMark hm;
 
     const uint active_workers =
       WorkerPolicy::calc_active_workers(ParallelScavengeHeap::heap()->workers().total_workers(),
                                         ParallelScavengeHeap::heap()->workers().active_workers(),
                                         Threads::number_of_non_daemon_threads());
@@ -1943,11 +1941,10 @@
     assert(cm->region_stack()->is_empty(), "Region stack " SIZE_FORMAT " is not empty", i);
   }
 #endif // ASSERT
 
   if (VerifyAfterGC && heap->total_collections() >= VerifyGCStartAt) {
-    HandleMark hm;  // Discard invalid handles created during verification
     Universe::verify("After GC");
   }
 
   // Re-verify object start arrays
   if (VerifyObjectStartArray &&
diff a/src/hotspot/share/gc/parallel/psScavenge.cpp b/src/hotspot/share/gc/parallel/psScavenge.cpp
--- a/src/hotspot/share/gc/parallel/psScavenge.cpp
+++ b/src/hotspot/share/gc/parallel/psScavenge.cpp
@@ -428,17 +428,15 @@
 
   // Fill in TLABs
   heap->ensure_parsability(true);  // retire TLABs
 
   if (VerifyBeforeGC && heap->total_collections() >= VerifyGCStartAt) {
-    HandleMark hm;  // Discard invalid handles created during verification
     Universe::verify("Before GC");
   }
 
   {
     ResourceMark rm;
-    HandleMark hm;
 
     GCTraceCPUTime tcpu;
     GCTraceTime(Info, gc) tm("Pause Young", NULL, gc_cause, true);
     TraceCollectorStats tcs(counters());
     TraceMemoryManagerStats tms(heap->young_gc_manager(), gc_cause);
@@ -712,11 +710,10 @@
     MemoryService::track_memory_usage();
     heap->update_counters();
   }
 
   if (VerifyAfterGC && heap->total_collections() >= VerifyGCStartAt) {
-    HandleMark hm;  // Discard invalid handles created during verification
     Universe::verify("After GC");
   }
 
   heap->print_heap_after_gc();
   heap->trace_heap_after_gc(&_gc_tracer);
diff a/src/hotspot/share/gc/shared/collectedHeap.cpp b/src/hotspot/share/gc/shared/collectedHeap.cpp
--- a/src/hotspot/share/gc/shared/collectedHeap.cpp
+++ b/src/hotspot/share/gc/shared/collectedHeap.cpp
@@ -227,24 +227,25 @@
 // This interface assumes that it's being called by the
 // vm thread. It collects the heap assuming that the
 // heap lock is already held and that we are executing in
 // the context of the vm thread.
 void CollectedHeap::collect_as_vm_thread(GCCause::Cause cause) {
-  assert(Thread::current()->is_VM_thread(), "Precondition#1");
+  Thread* thread = Thread::current();
+  assert(thread->is_VM_thread(), "Precondition#1");
   assert(Heap_lock->is_locked(), "Precondition#2");
   GCCauseSetter gcs(this, cause);
   switch (cause) {
     case GCCause::_heap_inspection:
     case GCCause::_heap_dump:
     case GCCause::_metadata_GC_threshold : {
-      HandleMark hm;
+      HandleMark hm(thread);
       do_full_collection(false);        // don't clear all soft refs
       break;
     }
     case GCCause::_archive_time_gc:
     case GCCause::_metadata_GC_clear_soft_refs: {
-      HandleMark hm;
+      HandleMark hm(thread);
       do_full_collection(true);         // do clear all soft refs
       break;
     }
     default:
       ShouldNotReachHere(); // Unexpected use of this function
@@ -410,18 +411,18 @@
 }
 
 void CollectedHeap::fill_with_object(HeapWord* start, size_t words, bool zap)
 {
   DEBUG_ONLY(fill_args_check(start, words);)
-  HandleMark hm;  // Free handles before leaving.
+  HandleMark hm(Thread::current());  // Free handles before leaving.
   fill_with_object_impl(start, words, zap);
 }
 
 void CollectedHeap::fill_with_objects(HeapWord* start, size_t words, bool zap)
 {
   DEBUG_ONLY(fill_args_check(start, words);)
-  HandleMark hm;  // Free handles before leaving.
+  HandleMark hm(Thread::current());  // Free handles before leaving.
 
   // Multiple objects may be required depending on the filler array maximum size. Fill
   // the range up to that with objects that are filler_array_max_size sized. The
   // remainder is filled with a single object.
   const size_t min = min_fill_size();
diff a/src/hotspot/share/gc/shared/gcVMOperations.cpp b/src/hotspot/share/gc/shared/gcVMOperations.cpp
--- a/src/hotspot/share/gc/shared/gcVMOperations.cpp
+++ b/src/hotspot/share/gc/shared/gcVMOperations.cpp
@@ -128,11 +128,10 @@
   Universe::heap()->collect_as_vm_thread(GCCause::_heap_inspection);
   return true;
 }
 
 void VM_GC_HeapInspection::doit() {
-  HandleMark hm;
   Universe::heap()->ensure_parsability(false); // must happen, even if collection does
                                                // not happen (e.g. due to GCLocker)
                                                // or _full_gc being false
   if (_full_gc) {
     if (!collect()) {
diff a/src/hotspot/share/gc/shared/genCollectedHeap.cpp b/src/hotspot/share/gc/shared/genCollectedHeap.cpp
--- a/src/hotspot/share/gc/shared/genCollectedHeap.cpp
+++ b/src/hotspot/share/gc/shared/genCollectedHeap.cpp
@@ -315,11 +315,10 @@
 
   HeapWord* result = NULL;
 
   // Loop until the allocation is satisfied, or unsatisfied after GC.
   for (uint try_count = 1, gclocker_stalled_count = 0; /* return or throw */; try_count += 1) {
-    HandleMark hm; // Discard any handles allocated in each iteration.
 
     // First allocation attempt is lock-free.
     Generation *young = _young_gen;
     assert(young->supports_inline_contig_alloc(),
       "Otherwise, must do alloc within heap lock");
@@ -475,11 +474,10 @@
   record_gen_tops_before_GC();
 
   log_trace(gc)("%s invoke=%d size=" SIZE_FORMAT, heap()->is_young_gen(gen) ? "Young" : "Old", gen->stat_record()->invocations, size * HeapWordSize);
 
   if (run_verification && VerifyBeforeGC) {
-    HandleMark hm;  // Discard invalid handles created during verification
     Universe::verify("Before GC");
   }
   COMPILER2_OR_JVMCI_PRESENT(DerivedPointerTable::clear());
 
   if (restore_marks_for_biased_locking) {
@@ -500,11 +498,10 @@
     // an appropriate indication in the case that notification on
     // the ref lock was needed. This will make the treatment of
     // weak refs more uniform (and indeed remove such concerns
     // from GCH). XXX
 
-    HandleMark hm;  // Discard invalid handles created during gc
     save_marks();   // save marks for all gens
     // We want to discover references, but not process them yet.
     // This mode is disabled in process_discovered_references if the
     // generation does some collection work, or in
     // enqueue_discovered_references if the generation returns
@@ -533,11 +530,10 @@
   gen->stat_record()->accumulated_time.stop();
 
   update_gc_stats(gen, full);
 
   if (run_verification && VerifyAfterGC) {
-    HandleMark hm;  // Discard invalid handles created during verification
     Universe::verify("After GC");
   }
 }
 
 void GenCollectedHeap::do_collection(bool           full,
diff a/src/hotspot/share/gc/shenandoah/shenandoahConcurrentMark.cpp b/src/hotspot/share/gc/shenandoah/shenandoahConcurrentMark.cpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahConcurrentMark.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahConcurrentMark.cpp
@@ -652,12 +652,13 @@
     _proc_task(proc_task),
     _terminator(t) {
   }
 
   void work(uint worker_id) {
-    ResourceMark rm;
-    HandleMark hm;
+    Thread* current_thread = Thread::current();
+    ResourceMark rm(current_thread);
+    HandleMark hm(current_thread);
     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), "Must be at a safepoint");
     ShenandoahHeap* heap = ShenandoahHeap::heap();
     ShenandoahParallelWorkerSession worker_session(worker_id);
     ShenandoahCMDrainMarkingStackClosure complete_gc(worker_id, _terminator);
     if (heap->has_forwarded_objects()) {
diff a/src/hotspot/share/include/jvm.h b/src/hotspot/share/include/jvm.h
--- a/src/hotspot/share/include/jvm.h
+++ b/src/hotspot/share/include/jvm.h
@@ -156,10 +156,13 @@
 JVM_MaxMemory(void);
 
 JNIEXPORT jint JNICALL
 JVM_ActiveProcessorCount(void);
 
+JNIEXPORT jboolean JNICALL
+JVM_IsUseContainerSupport(void);
+
 JNIEXPORT void * JNICALL
 JVM_LoadLibrary(const char *name);
 
 JNIEXPORT void JNICALL
 JVM_UnloadLibrary(void * handle);
diff a/src/hotspot/share/interpreter/interpreterRuntime.cpp b/src/hotspot/share/interpreter/interpreterRuntime.cpp
--- a/src/hotspot/share/interpreter/interpreterRuntime.cpp
+++ b/src/hotspot/share/interpreter/interpreterRuntime.cpp
@@ -1101,12 +1101,10 @@
   int bci = method->bci_from(bcp);
 
   address mdp2 = mdo->bci_to_dp(bci);
   if (mdp != mdp2) {
     ResourceMark rm;
-    ResetNoHandleMark rnm; // In a LEAF entry.
-    HandleMark hm;
     tty->print_cr("FAILED verify : actual mdp %p   expected mdp %p @ bci %d", mdp, mdp2, bci);
     int current_di = mdo->dp_to_di(mdp);
     int expected_di  = mdo->dp_to_di(mdp2);
     tty->print_cr("  actual di %d   expected di %d", current_di, expected_di);
     int expected_approx_bci = mdo->data_at(expected_di)->bci();
@@ -1123,11 +1121,10 @@
 #endif // ASSERT
 
 JRT_ENTRY(void, InterpreterRuntime::update_mdp_for_ret(JavaThread* thread, int return_bci))
   assert(ProfileInterpreter, "must be profiling interpreter");
   ResourceMark rm(thread);
-  HandleMark hm(thread);
   LastFrameAccessor last_frame(thread);
   assert(last_frame.is_interpreted_frame(), "must come from interpreter");
   MethodData* h_mdo = last_frame.method()->method_data();
 
   // Grab a lock to ensure atomic access to setting the return bci and
@@ -1477,12 +1474,10 @@
 #if defined(IA32) || defined(AMD64) || defined(ARM)
 JRT_LEAF(void, InterpreterRuntime::popframe_move_outgoing_args(JavaThread* thread, void* src_address, void* dest_address))
   if (src_address == dest_address) {
     return;
   }
-  ResetNoHandleMark rnm; // In a LEAF entry.
-  HandleMark hm;
   ResourceMark rm;
   LastFrameAccessor last_frame(thread);
   assert(last_frame.is_interpreted_frame(), "");
   jint bci = last_frame.bci();
   methodHandle mh(thread, last_frame.method());
diff a/src/hotspot/share/interpreter/oopMapCache.cpp b/src/hotspot/share/interpreter/oopMapCache.cpp
--- a/src/hotspot/share/interpreter/oopMapCache.cpp
+++ b/src/hotspot/share/interpreter/oopMapCache.cpp
@@ -319,11 +319,10 @@
   mf.generate();
 }
 
 
 void OopMapCacheEntry::fill(const methodHandle& method, int bci) {
-  HandleMark hm;
   // Flush entry to deallocate an existing entry
   flush();
   set_method(method());
   set_bci(bci);
   if (method->is_native()) {
diff a/src/hotspot/share/jfr/jni/jfrJavaSupport.cpp b/src/hotspot/share/jfr/jni/jfrJavaSupport.cpp
--- a/src/hotspot/share/jfr/jni/jfrJavaSupport.cpp
+++ b/src/hotspot/share/jfr/jni/jfrJavaSupport.cpp
@@ -833,10 +833,10 @@
   assert(Thread::current() == t, "invariant");
   if (!t->is_Java_thread()) {
     return;
   }
   DEBUG_ONLY(check_new_unstarted_java_thread(t);)
-  HandleMark hm;
+  HandleMark hm(t);
   if (check_exclusion_state_on_thread_start((JavaThread*)t)) {
     JfrThreadLocal::exclude(t);
   }
 }
diff a/src/hotspot/share/jfr/recorder/jfrRecorder.cpp b/src/hotspot/share/jfr/recorder/jfrRecorder.cpp
--- a/src/hotspot/share/jfr/recorder/jfrRecorder.cpp
+++ b/src/hotspot/share/jfr/recorder/jfrRecorder.cpp
@@ -244,12 +244,13 @@
 bool JfrRecorder::is_created() {
   return _created;
 }
 
 bool JfrRecorder::create_components() {
-  ResourceMark rm;
-  HandleMark hm;
+  // Move these down into the functions that might create handles!
+  ResourceMark rm(Thread::current());
+  HandleMark hm(Thread::current());
 
   if (!create_java_event_writer()) {
     return false;
   }
   if (!create_jvmti_agent()) {
diff a/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp b/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp
--- a/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp
+++ b/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -786,11 +786,11 @@
   return size;
 }
 
 // perform data and call relocation on the CodeBuffer
 JVMCI::CodeInstallResult CodeInstaller::initialize_buffer(CodeBuffer& buffer, bool check_size, JVMCI_TRAPS) {
-  HandleMark hm;
+  HandleMark hm(Thread::current());
   JVMCIObjectArray sites = this->sites();
   int locs_buffer_size = JVMCIENV->get_length(sites) * (relocInfo::length_limit + sizeof(relocInfo));
 
   // Allocate enough space in the stub section for the static call
   // stubs.  Stubs have extra relocs but they are managed by the stub
diff a/src/hotspot/share/jvmci/jvmciCompiler.cpp b/src/hotspot/share/jvmci/jvmciCompiler.cpp
--- a/src/hotspot/share/jvmci/jvmciCompiler.cpp
+++ b/src/hotspot/share/jvmci/jvmciCompiler.cpp
@@ -55,12 +55,12 @@
   if (Arguments::mode() == Arguments::_int) {
     // Nothing to do in -Xint mode
     return;
   }
   _bootstrapping = true;
-  ResourceMark rm;
-  HandleMark hm;
+  ResourceMark rm(THREAD);
+  HandleMark hm(THREAD);
   if (PrintBootstrap) {
     tty->print("Bootstrapping JVMCI");
   }
   jlong start = os::javaTimeNanos();
 
diff a/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp b/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp
--- a/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp
+++ b/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp
@@ -817,11 +817,11 @@
   method->set_dont_inline(true);
 C2V_END
 
 C2V_VMENTRY_0(jint, installCode, (JNIEnv *env, jobject, jobject target, jobject compiled_code,
             jobject installed_code, jlong failed_speculations_address, jbyteArray speculations_obj))
-  HandleMark hm;
+  HandleMark hm(THREAD);
   JNIHandleMark jni_hm(thread);
 
   JVMCIObject target_handle = JVMCIENV->wrap(target);
   JVMCIObject compiled_code_handle = JVMCIENV->wrap(compiled_code);
   CodeBlob* cb = NULL;
@@ -878,11 +878,11 @@
   return result;
 C2V_END
 
 C2V_VMENTRY_0(jint, getMetadata, (JNIEnv *env, jobject, jobject target, jobject compiled_code, jobject metadata))
 #if INCLUDE_AOT
-  HandleMark hm;
+  HandleMark hm(THREAD);
   assert(JVMCIENV->is_hotspot(), "AOT code is executed only in HotSpot mode");
 
   JVMCIObject target_handle = JVMCIENV->wrap(target);
   JVMCIObject compiled_code_handle = JVMCIENV->wrap(compiled_code);
   JVMCIObject metadata_handle = JVMCIENV->wrap(metadata);
@@ -966,11 +966,11 @@
   stats->_standard.reset();
   stats->_osr.reset();
 C2V_END
 
 C2V_VMENTRY_NULL(jobject, disassembleCodeBlob, (JNIEnv* env, jobject, jobject installedCode))
-  HandleMark hm;
+  HandleMark hm(THREAD);
 
   if (installedCode == NULL) {
     JVMCI_THROW_MSG_NULL(NullPointerException, "installedCode is null");
   }
 
@@ -1004,11 +1004,11 @@
   JVMCIObject result = JVMCIENV->create_string(st.as_string(), JVMCI_CHECK_NULL);
   return JVMCIENV->get_jobject(result);
 C2V_END
 
 C2V_VMENTRY_NULL(jobject, getStackTraceElement, (JNIEnv* env, jobject, jobject jvmci_method, int bci))
-  HandleMark hm;
+  HandleMark hm(THREAD);
 
   methodHandle method(THREAD, JVMCIENV->asMethod(jvmci_method));
   JVMCIObject element = JVMCIENV->new_StackTraceElement(method, bci, JVMCI_CHECK_NULL);
   return JVMCIENV->get_jobject(element);
 C2V_END
@@ -1016,11 +1016,11 @@
 C2V_VMENTRY_NULL(jobject, executeHotSpotNmethod, (JNIEnv* env, jobject, jobject args, jobject hs_nmethod))
   // The incoming arguments array would have to contain JavaConstants instead of regular objects
   // and the return value would have to be wrapped as a JavaConstant.
   requireInHotSpot("executeHotSpotNmethod", JVMCI_CHECK_NULL);
 
-  HandleMark hm;
+  HandleMark hm(THREAD);
 
   JVMCIObject nmethod_mirror = JVMCIENV->wrap(hs_nmethod);
   nmethodLocker locker;
   nmethod* nm = JVMCIENV->get_nmethod(nmethod_mirror, locker);
   if (nm == NULL || !nm->is_in_use()) {
@@ -1150,16 +1150,16 @@
 
 C2V_VMENTRY_0(jint, getCountersSize, (JNIEnv* env, jobject))
   return (jint) JVMCICounterSize;
 C2V_END
 
-C2V_VMENTRY(void, setCountersSize, (JNIEnv* env, jobject, jint new_size))
-  JavaThread::resize_all_jvmci_counters(new_size);
+C2V_VMENTRY_0(jboolean, setCountersSize, (JNIEnv* env, jobject, jint new_size))
+  return JavaThread::resize_all_jvmci_counters(new_size);
 C2V_END
 
 C2V_VMENTRY_0(jint, allocateCompileId, (JNIEnv* env, jobject, jobject jvmci_method, int entry_bci))
-  HandleMark hm;
+  HandleMark hm(THREAD);
   if (jvmci_method == NULL) {
     JVMCI_THROW_0(NullPointerException);
   }
   methodHandle method(THREAD, JVMCIENV->asMethod(jvmci_method));
   if (entry_bci >= method->code_size() || entry_bci < -1) {
@@ -1571,11 +1571,11 @@
   HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, hs_frame, JNI_TRUE);
 C2V_END
 
 // Creates a scope where the current thread is attached and detached
 // from HotSpot if it wasn't already attached when entering the scope.
-extern "C" void jio_printf(const char *fmt, ...);
+extern "C" int jio_printf(const char *fmt, ...);
 class AttachDetach : public StackObj {
  public:
   bool _attached;
   AttachDetach(JNIEnv* env, JavaThread* current_thread) {
     if (current_thread == NULL) {
@@ -2244,11 +2244,11 @@
   JVMCIRuntime* runtime = JVMCI::compiler_runtime();
   {
     // Ensure the JVMCI shared library runtime is initialized.
     JVMCIEnv __peer_jvmci_env__(thread, false, __FILE__, __LINE__);
     JVMCIEnv* peerEnv = &__peer_jvmci_env__;
-    HandleMark hm;
+    HandleMark hm(THREAD);
     JVMCIObject receiver = runtime->get_HotSpotJVMCIRuntime(peerEnv);
     if (peerEnv->has_pending_exception()) {
       peerEnv->describe_pending_exception(true);
     }
     sl_handle = JVMCI::get_shared_library(sl_path, false);
@@ -2758,11 +2758,11 @@
   {CC "reprofile",                                    CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(reprofile)},
   {CC "invalidateHotSpotNmethod",                     CC "(" HS_NMETHOD ")V",                                                               FN_PTR(invalidateHotSpotNmethod)},
   {CC "readUncompressedOop",                          CC "(J)" OBJECTCONSTANT,                                                              FN_PTR(readUncompressedOop)},
   {CC "collectCounters",                              CC "()[J",                                                                            FN_PTR(collectCounters)},
   {CC "getCountersSize",                              CC "()I",                                                                             FN_PTR(getCountersSize)},
-  {CC "setCountersSize",                              CC "(I)V",                                                                            FN_PTR(setCountersSize)},
+  {CC "setCountersSize",                              CC "(I)Z",                                                                            FN_PTR(setCountersSize)},
   {CC "allocateCompileId",                            CC "(" HS_RESOLVED_METHOD "I)I",                                                      FN_PTR(allocateCompileId)},
   {CC "isMature",                                     CC "(" METASPACE_METHOD_DATA ")Z",                                                    FN_PTR(isMature)},
   {CC "hasCompiledCodeForOSR",                        CC "(" HS_RESOLVED_METHOD "II)Z",                                                     FN_PTR(hasCompiledCodeForOSR)},
   {CC "getSymbol",                                    CC "(J)" STRING,                                                                      FN_PTR(getSymbol)},
   {CC "iterateFrames",                                CC "([" RESOLVED_METHOD "[" RESOLVED_METHOD "I" INSPECTED_FRAME_VISITOR ")" OBJECT,   FN_PTR(iterateFrames)},
diff a/src/hotspot/share/jvmci/jvmciEnv.cpp b/src/hotspot/share/jvmci/jvmciEnv.cpp
--- a/src/hotspot/share/jvmci/jvmciEnv.cpp
+++ b/src/hotspot/share/jvmci/jvmciEnv.cpp
@@ -659,12 +659,12 @@
 
   }
 }
 
 void JVMCIEnv::call_HotSpotJVMCIRuntime_shutdown (JVMCIObject runtime) {
-  HandleMark hm;
   JavaThread* THREAD = JavaThread::current();
+  HandleMark hm(THREAD);
   if (is_hotspot()) {
     JavaCallArguments jargs;
     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
     JavaValue result(T_VOID);
     JavaCalls::call_special(&result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::shutdown_name(), vmSymbols::void_method_signature(), &jargs, THREAD);
diff a/src/hotspot/share/jvmci/jvmciRuntime.cpp b/src/hotspot/share/jvmci/jvmciRuntime.cpp
--- a/src/hotspot/share/jvmci/jvmciRuntime.cpp
+++ b/src/hotspot/share/jvmci/jvmciRuntime.cpp
@@ -923,13 +923,13 @@
   _init_state = being_initialized;
 
   {
     MutexUnlocker unlock(JVMCI_lock);
 
-    HandleMark hm;
-    ResourceMark rm;
     JavaThread* THREAD = JavaThread::current();
+    HandleMark hm(THREAD);
+    ResourceMark rm(THREAD);
     if (JVMCIENV->is_hotspot()) {
       HotSpotJVMCI::compute_offsets(CHECK_EXIT);
     } else {
       JNIAccessMark jni(JVMCIENV);
 
@@ -1011,11 +1011,11 @@
   }
 
   JVMCIENV->runtime()->initialize(JVMCIENV);
 
   {
-    ResourceMark rm;
+    ResourceMark rm(thread);
     HandleMark hm(thread);
     ThreadToNativeFromVM trans(thread);
 
     // Ensure _non_oop_bits is initialized
     Universe::non_oop_word();
@@ -1481,11 +1481,11 @@
   if (JVMCI::in_shutdown()) {
     compile_state->set_failure(false, "Avoiding compilation during shutdown");
     return;
   }
 
-  HandleMark hm;
+  HandleMark hm(thread);
   JVMCIObject receiver = get_HotSpotJVMCIRuntime(JVMCIENV);
   if (JVMCIENV->has_pending_exception()) {
     fatal_exception_in_compile(JVMCIENV, thread, "Exception during HotSpotJVMCIRuntime initialization");
   }
   JVMCIObject jvmci_method = JVMCIENV->get_jvmci_method(method, JVMCIENV);
diff a/src/hotspot/share/memory/dynamicArchive.cpp b/src/hotspot/share/memory/dynamicArchive.cpp
--- a/src/hotspot/share/memory/dynamicArchive.cpp
+++ b/src/hotspot/share/memory/dynamicArchive.cpp
@@ -559,11 +559,10 @@
   // Do this before and after the archive dump to see if any corruption
   // is caused by dynamic dumping.
   void verify_universe(const char* info) {
     if (VerifyBeforeExit) {
       log_info(cds)("Verify %s", info);
-      HandleMark hm;
       // Among other things, this ensures that Eden top is correct.
       Universe::heap()->prepare_for_verify();
       Universe::verify(info);
     }
   }
diff a/src/hotspot/share/memory/metaspaceShared.cpp b/src/hotspot/share/memory/metaspaceShared.cpp
--- a/src/hotspot/share/memory/metaspaceShared.cpp
+++ b/src/hotspot/share/memory/metaspaceShared.cpp
@@ -712,23 +712,10 @@
       k->remove_java_mirror();
     }
   }
 }
 
-static void clear_basic_type_mirrors() {
-  assert(!HeapShared::is_heap_object_archiving_allowed(), "Sanity");
-  Universe::set_int_mirror(NULL);
-  Universe::set_float_mirror(NULL);
-  Universe::set_double_mirror(NULL);
-  Universe::set_byte_mirror(NULL);
-  Universe::set_bool_mirror(NULL);
-  Universe::set_char_mirror(NULL);
-  Universe::set_long_mirror(NULL);
-  Universe::set_short_mirror(NULL);
-  Universe::set_void_mirror(NULL);
-}
-
 static void rewrite_nofast_bytecode(const methodHandle& method) {
   BytecodeStream bcs(method);
   while (!bcs.is_last_bytecode()) {
     Bytecodes::Code opcode = bcs.next();
     switch (opcode) {
@@ -1538,11 +1525,11 @@
 char* VM_PopulateDumpSharedSpace::dump_read_only_tables() {
   ArchiveCompactor::OtherROAllocMark mark;
 
   log_info(cds)("Removing java_mirror ... ");
   if (!HeapShared::is_heap_object_archiving_allowed()) {
-    clear_basic_type_mirrors();
+    Universe::clear_basic_type_mirrors();
   }
   remove_java_mirror_in_classes();
   log_info(cds)("done. ");
 
   SystemDictionaryShared::write_to_archive();
@@ -2090,11 +2077,11 @@
 }
 
 void ReadClosure::do_oop(oop *p) {
   narrowOop o = (narrowOop)nextPtr();
   if (o == 0 || !HeapShared::open_archive_heap_region_mapped()) {
-    p = NULL;
+    *p = NULL;
   } else {
     assert(HeapShared::is_heap_object_archiving_allowed(),
            "Archived heap object is not allowed");
     assert(HeapShared::open_archive_heap_region_mapped(),
            "Open archive heap region is not mapped");
diff a/src/hotspot/share/memory/universe.cpp b/src/hotspot/share/memory/universe.cpp
--- a/src/hotspot/share/memory/universe.cpp
+++ b/src/hotspot/share/memory/universe.cpp
@@ -86,29 +86,14 @@
 #include "utilities/hashtable.inline.hpp"
 #include "utilities/macros.hpp"
 #include "utilities/ostream.hpp"
 #include "utilities/preserveException.hpp"
 
-#define PRIMITIVE_MIRRORS_DO(func) \
-  func(_int_mirror)    \
-  func(_float_mirror)  \
-  func(_double_mirror) \
-  func(_byte_mirror)   \
-  func(_bool_mirror)   \
-  func(_char_mirror)   \
-  func(_long_mirror)   \
-  func(_short_mirror)  \
-  func(_void_mirror)
-
-#define DEFINE_PRIMITIVE_MIRROR(m) \
-    oop Universe::m  = NULL;
-
 // Known objects
-PRIMITIVE_MIRRORS_DO(DEFINE_PRIMITIVE_MIRROR)
 Klass* Universe::_typeArrayKlassObjs[T_LONG+1]        = { NULL /*, NULL...*/ };
 Klass* Universe::_objectArrayKlassObj                 = NULL;
-oop Universe::_mirrors[T_VOID+1]                      = { NULL /*, NULL...*/ };
+OopHandle Universe::_mirrors[T_VOID+1];
 
 OopHandle Universe::_main_thread_group;
 OopHandle Universe::_system_thread_group;
 OopHandle Universe::_the_empty_class_array;
 OopHandle Universe::_the_null_string;
@@ -134,11 +119,11 @@
 
 OopHandle Universe::_null_ptr_exception_instance;
 OopHandle Universe::_arithmetic_exception_instance;
 OopHandle Universe::_virtual_machine_error_instance;
 
-oop Universe::_reference_pending_list = NULL;
+OopHandle Universe::_reference_pending_list;
 
 Array<Klass*>* Universe::_the_array_interfaces_array = NULL;
 LatestMethodCache* Universe::_finalizer_register_cache = NULL;
 LatestMethodCache* Universe::_loader_addClass_cache    = NULL;
 LatestMethodCache* Universe::_throw_illegal_access_error_cache = NULL;
@@ -195,10 +180,39 @@
 oop Universe::arithmetic_exception_instance()     { return _arithmetic_exception_instance.resolve(); }
 oop Universe::virtual_machine_error_instance()    { return _virtual_machine_error_instance.resolve(); }
 
 oop Universe::the_null_sentinel()                 { return _the_null_sentinel.resolve(); }
 
+oop Universe::int_mirror()                        { return check_mirror(_mirrors[T_INT].resolve()); }
+oop Universe::float_mirror()                      { return check_mirror(_mirrors[T_FLOAT].resolve()); }
+oop Universe::double_mirror()                     { return check_mirror(_mirrors[T_DOUBLE].resolve()); }
+oop Universe::byte_mirror()                       { return check_mirror(_mirrors[T_BYTE].resolve()); }
+oop Universe::bool_mirror()                       { return check_mirror(_mirrors[T_BOOLEAN].resolve()); }
+oop Universe::char_mirror()                       { return check_mirror(_mirrors[T_CHAR].resolve()); }
+oop Universe::long_mirror()                       { return check_mirror(_mirrors[T_LONG].resolve()); }
+oop Universe::short_mirror()                      { return check_mirror(_mirrors[T_SHORT].resolve()); }
+oop Universe::void_mirror()                       { return check_mirror(_mirrors[T_VOID].resolve()); }
+
+oop Universe::java_mirror(BasicType t) {
+  assert((uint)t < T_VOID+1, "range check");
+  return check_mirror(_mirrors[t].resolve());
+}
+
+// Used by CDS dumping
+void Universe::replace_mirror(BasicType t, oop new_mirror) {
+  Universe::_mirrors[t].replace(new_mirror);
+}
+
+// Not sure why CDS has to do this
+void Universe::clear_basic_type_mirrors() {
+  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {
+    if (!is_reference_type((BasicType)i)) {
+      Universe::_mirrors[i].replace(NULL);
+    }
+  }
+}
+
 void Universe::basic_type_classes_do(void f(Klass*)) {
   for (int i = T_BOOLEAN; i < T_LONG+1; i++) {
     f(_typeArrayKlassObjs[i]);
   }
 }
@@ -207,22 +221,12 @@
   for (int i = T_BOOLEAN; i < T_LONG+1; i++) {
     closure->do_klass(_typeArrayKlassObjs[i]);
   }
 }
 
-#define DO_PRIMITIVE_MIRROR(m) \
-  f->do_oop((oop*) &m);
-
 void Universe::oops_do(OopClosure* f) {
-  PRIMITIVE_MIRRORS_DO(DO_PRIMITIVE_MIRROR);
 
-  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {
-    f->do_oop(&_mirrors[i]);
-  }
-  assert(_mirrors[0] == NULL && _mirrors[T_BOOLEAN - 1] == NULL, "checking");
-
-  f->do_oop(&_reference_pending_list);
   ThreadsSMRSupport::exiting_threads_oops_do(f);
 }
 
 void LatestMethodCache::metaspace_pointers_do(MetaspaceClosure* it) {
   it->push(&_klass);
@@ -246,33 +250,40 @@
   _throw_illegal_access_error_cache->metaspace_pointers_do(it);
   _throw_no_such_method_error_cache->metaspace_pointers_do(it);
   _do_stack_walk_cache->metaspace_pointers_do(it);
 }
 
-#define ASSERT_MIRROR_NULL(m) \
-  assert(m == NULL, "archived mirrors should be NULL");
-
-#define SERIALIZE_MIRROR(m) \
-  f->do_oop(&m); \
-  if (m != NULL) { java_lang_Class::update_archived_primitive_mirror_native_pointers(m); }
-
 // Serialize metadata and pointers to primitive type mirrors in and out of CDS archive
 void Universe::serialize(SerializeClosure* f) {
 
+#if INCLUDE_CDS_JAVA_HEAP
+  {
+    oop mirror_oop;
+    for (int i = T_BOOLEAN; i < T_VOID+1; i++) {
+      if (f->reading()) {
+        f->do_oop(&mirror_oop); // read from archive
+        assert(oopDesc::is_oop_or_null(mirror_oop), "is oop");
+        // Only create an OopHandle for non-null mirrors
+        if (mirror_oop != NULL) {
+          _mirrors[i] = OopHandle(vm_global(), mirror_oop);
+        }
+      } else {
+        mirror_oop = _mirrors[i].resolve();
+        f->do_oop(&mirror_oop); // write to archive
+      }
+      if (mirror_oop != NULL) { // may be null if archived heap is disabled
+        java_lang_Class::update_archived_primitive_mirror_native_pointers(mirror_oop);
+      }
+    }
+  }
+#endif
+
   for (int i = 0; i < T_LONG+1; i++) {
     f->do_ptr((void**)&_typeArrayKlassObjs[i]);
   }
 
   f->do_ptr((void**)&_objectArrayKlassObj);
-
-#if INCLUDE_CDS_JAVA_HEAP
-  DEBUG_ONLY(if (DumpSharedSpaces && !HeapShared::is_heap_object_archiving_allowed()) {
-      PRIMITIVE_MIRRORS_DO(ASSERT_MIRROR_NULL);
-    });
-  PRIMITIVE_MIRRORS_DO(SERIALIZE_MIRROR);
-#endif
-
   f->do_ptr((void**)&_the_array_interfaces_array);
   f->do_ptr((void**)&_the_empty_int_array);
   f->do_ptr((void**)&_the_empty_short_array);
   f->do_ptr((void**)&_the_empty_method_array);
   f->do_ptr((void**)&_the_empty_klass_array);
@@ -282,10 +293,11 @@
   _throw_illegal_access_error_cache->serialize(f);
   _throw_no_such_method_error_cache->serialize(f);
   _do_stack_walk_cache->serialize(f);
 }
 
+
 void Universe::check_alignment(uintx size, uintx alignment, const char* name) {
   if (size < alignment || size % alignment != 0) {
     vm_exit_during_initialization(
       err_msg("Size of %s (" UINTX_FORMAT " bytes) must be aligned to " UINTX_FORMAT " bytes", name, size, alignment));
   }
@@ -310,10 +322,11 @@
   k->append_to_sibling_list();
 }
 
 void Universe::genesis(TRAPS) {
   ResourceMark rm(THREAD);
+  HandleMark   hm(THREAD);
 
   { AutoModifyRestore<bool> temporarily(_bootstrapping, true);
 
     { MutexLocker mc(THREAD, Compile_lock);
 
@@ -377,10 +390,13 @@
   {
     Handle tns = java_lang_String::create_from_str("<null_sentinel>", CHECK);
     _the_null_sentinel = OopHandle(vm_global(), tns());
   }
 
+  // Create a handle for reference_pending_list
+  _reference_pending_list = OopHandle(vm_global(), NULL);
+
   // Maybe this could be lifted up now that object array can be initialized
   // during the bootstrapping.
 
   // OLD
   // Initialize _objectArrayKlass after core bootstraping to make
@@ -433,55 +449,36 @@
     assert(i == ((objArrayOop)_fullgc_alot_dummy_array.resolve())->length(), "just checking");
   }
   #endif
 }
 
-#define ASSERT_MIRROR_NOT_NULL(m) \
-  assert(m != NULL, "archived mirrors should not be NULL");
-
 void Universe::initialize_basic_type_mirrors(TRAPS) {
 #if INCLUDE_CDS_JAVA_HEAP
     if (UseSharedSpaces &&
         HeapShared::open_archive_heap_region_mapped() &&
-        _int_mirror != NULL) {
+        _mirrors[T_INT].resolve() != NULL) {
       assert(HeapShared::is_heap_object_archiving_allowed(), "Sanity");
-      PRIMITIVE_MIRRORS_DO(ASSERT_MIRROR_NOT_NULL);
+
+      // check that all mirrors are mapped also
+      for (int i = T_BOOLEAN; i < T_VOID+1; i++) {
+        if (!is_reference_type((BasicType)i)) {
+          oop m = _mirrors[i].resolve();
+          assert(m != NULL, "archived mirrors should not be NULL");
+        }
+      }
     } else
-      // _int_mirror could be NULL if archived heap is not mapped.
+      // _mirror[T_INT} could be NULL if archived heap is not mapped.
 #endif
     {
-      _int_mirror     =
-        java_lang_Class::create_basic_type_mirror("int",    T_INT, CHECK);
-      _float_mirror   =
-        java_lang_Class::create_basic_type_mirror("float",  T_FLOAT,   CHECK);
-      _double_mirror  =
-        java_lang_Class::create_basic_type_mirror("double", T_DOUBLE,  CHECK);
-      _byte_mirror    =
-        java_lang_Class::create_basic_type_mirror("byte",   T_BYTE, CHECK);
-      _bool_mirror    =
-        java_lang_Class::create_basic_type_mirror("boolean",T_BOOLEAN, CHECK);
-      _char_mirror    =
-        java_lang_Class::create_basic_type_mirror("char",   T_CHAR, CHECK);
-      _long_mirror    =
-        java_lang_Class::create_basic_type_mirror("long",   T_LONG, CHECK);
-      _short_mirror   =
-        java_lang_Class::create_basic_type_mirror("short",  T_SHORT,   CHECK);
-      _void_mirror    =
-        java_lang_Class::create_basic_type_mirror("void",   T_VOID, CHECK);
+      for (int i = T_BOOLEAN; i < T_VOID+1; i++) {
+        BasicType bt = (BasicType)i;
+        if (!is_reference_type(bt)) {
+          oop m = java_lang_Class::create_basic_type_mirror(type2name(bt), bt, CHECK);
+          _mirrors[i] = OopHandle(vm_global(), m);
+        }
+      }
     }
-
-    _mirrors[T_INT]     = _int_mirror;
-    _mirrors[T_FLOAT]   = _float_mirror;
-    _mirrors[T_DOUBLE]  = _double_mirror;
-    _mirrors[T_BYTE]    = _byte_mirror;
-    _mirrors[T_BOOLEAN] = _bool_mirror;
-    _mirrors[T_CHAR]    = _char_mirror;
-    _mirrors[T_LONG]    = _long_mirror;
-    _mirrors[T_SHORT]   = _short_mirror;
-    _mirrors[T_VOID]    = _void_mirror;
-  //_mirrors[T_OBJECT]  = _object_klass->java_mirror();
-  //_mirrors[T_ARRAY]   = _object_klass->java_mirror();
 }
 
 void Universe::fixup_mirrors(TRAPS) {
   // Bootstrap problem: all classes gets a mirror (java.lang.Class instance) assigned eagerly,
   // but we cannot do that for classes created before java.lang.Class is loaded. Here we simply
@@ -516,26 +513,26 @@
   if (Thread::current()->is_VM_thread()) {
     assert_pll_locked(is_locked);
   } else {
     assert_pll_ownership();
   }
-  return _reference_pending_list;
+  return _reference_pending_list.resolve();
 }
 
 void Universe::clear_reference_pending_list() {
   assert_pll_ownership();
-  _reference_pending_list = NULL;
+  _reference_pending_list.replace(NULL);
 }
 
 bool Universe::has_reference_pending_list() {
   assert_pll_ownership();
-  return _reference_pending_list != NULL;
+  return _reference_pending_list.peek() != NULL;
 }
 
 oop Universe::swap_reference_pending_list(oop list) {
   assert_pll_locked(is_locked);
-  return Atomic::xchg(&_reference_pending_list, list);
+  return _reference_pending_list.xchg(list);
 }
 
 #undef assert_pll_locked
 #undef assert_pll_ownership
 
@@ -1143,12 +1140,13 @@
     assert(!DerivedPointerTable::is_active(),
          "DPT should not be active during verification "
          "(of thread stacks below)");
   )
 
-  ResourceMark rm;
-  HandleMark hm;  // Handles created during verification can be zapped
+  Thread* thread = Thread::current();
+  ResourceMark rm(thread);
+  HandleMark hm(thread);  // Handles created during verification can be zapped
   _verify_count++;
 
   FormatBuffer<> title("Verifying %s", prefix);
   GCTraceTime(Info, gc, verify) tm(title.buffer());
   if (should_verify_subset(Verify_Threads)) {
diff a/src/hotspot/share/memory/universe.hpp b/src/hotspot/share/memory/universe.hpp
--- a/src/hotspot/share/memory/universe.hpp
+++ b/src/hotspot/share/memory/universe.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -93,22 +93,10 @@
   // Known classes in the VM
   static Klass* _typeArrayKlassObjs[T_LONG+1];
   static Klass* _objectArrayKlassObj;
 
   // Known objects in the VM
-
-  // Primitive objects
-  static oop _int_mirror;
-  static oop _float_mirror;
-  static oop _double_mirror;
-  static oop _byte_mirror;
-  static oop _bool_mirror;
-  static oop _char_mirror;
-  static oop _long_mirror;
-  static oop _short_mirror;
-  static oop _void_mirror;
-
   static OopHandle    _main_thread_group;             // Reference to the main thread group object
   static OopHandle    _system_thread_group;           // Reference to the system thread group object
 
   static OopHandle    _the_empty_class_array;         // Canonicalized obj array of type java.lang.Class
   static OopHandle    _the_null_string;               // A cache of "null" as a Java string
@@ -145,11 +133,11 @@
   static OopHandle    _null_ptr_exception_instance;   // preallocated exception object
   static OopHandle    _arithmetic_exception_instance; // preallocated exception object
   static OopHandle    _virtual_machine_error_instance; // preallocated exception object
 
   // References waiting to be transferred to the ReferenceHandler
-  static oop          _reference_pending_list;
+  static OopHandle    _reference_pending_list;
 
   // The particular choice of collected heap.
   static CollectedHeap* _collectedHeap;
 
   static intptr_t _non_oop_bits;
@@ -230,37 +218,28 @@
     assert(_typeArrayKlassObjs[t] != NULL, "domain check");
     return _typeArrayKlassObjs[t];
   }
 
   // Known objects in the VM
-  static oop int_mirror()                   { return check_mirror(_int_mirror); }
-  static oop float_mirror()                 { return check_mirror(_float_mirror); }
-  static oop double_mirror()                { return check_mirror(_double_mirror); }
-  static oop byte_mirror()                  { return check_mirror(_byte_mirror); }
-  static oop bool_mirror()                  { return check_mirror(_bool_mirror); }
-  static oop char_mirror()                  { return check_mirror(_char_mirror); }
-  static oop long_mirror()                  { return check_mirror(_long_mirror); }
-  static oop short_mirror()                 { return check_mirror(_short_mirror); }
-  static oop void_mirror()                  { return check_mirror(_void_mirror); }
-
-  static void set_int_mirror(oop m)         { _int_mirror = m;    }
-  static void set_float_mirror(oop m)       { _float_mirror = m;  }
-  static void set_double_mirror(oop m)      { _double_mirror = m; }
-  static void set_byte_mirror(oop m)        { _byte_mirror = m;   }
-  static void set_bool_mirror(oop m)        { _bool_mirror = m;   }
-  static void set_char_mirror(oop m)        { _char_mirror = m;   }
-  static void set_long_mirror(oop m)        { _long_mirror = m;   }
-  static void set_short_mirror(oop m)       { _short_mirror = m;  }
-  static void set_void_mirror(oop m)        { _void_mirror = m;   }
-
-  // table of same
-  static oop _mirrors[T_VOID+1];
-
-  static oop java_mirror(BasicType t) {
-    assert((uint)t < T_VOID+1, "range check");
-    return check_mirror(_mirrors[t]);
-  }
+  static oop int_mirror();
+  static oop float_mirror();
+  static oop double_mirror();
+  static oop byte_mirror();
+  static oop bool_mirror();
+  static oop char_mirror();
+  static oop long_mirror();
+  static oop short_mirror();
+  static oop void_mirror();
+
+  // Table of primitive type mirrors, excluding T_OBJECT and T_ARRAY
+  // but including T_VOID, hence the index including T_VOID
+  static OopHandle _mirrors[T_VOID+1];
+
+  static oop java_mirror(BasicType t);
+  static void replace_mirror(BasicType t, oop obj);
+  static void clear_basic_type_mirrors();
+
   static oop      main_thread_group();
   static void set_main_thread_group(oop group);
 
   static oop      system_thread_group();
   static void set_system_thread_group(oop group);
diff a/src/hotspot/share/oops/generateOopMap.cpp b/src/hotspot/share/oops/generateOopMap.cpp
--- a/src/hotspot/share/oops/generateOopMap.cpp
+++ b/src/hotspot/share/oops/generateOopMap.cpp
@@ -2328,11 +2328,11 @@
 
 void GenerateOopMap::rewrite_refval_conflict(int from, int to) {
   bool startOver;
   do {
     // Make sure that the BytecodeStream is constructed in the loop, since
-    // during rewriting a new method oop is going to be used, and the next time
+    // during rewriting a new method is going to be used, and the next time
     // around we want to use that.
     BytecodeStream bcs(_method);
     startOver = false;
 
     while( !startOver && !_got_error &&
@@ -2465,11 +2465,11 @@
   if (m.is_null() || HAS_PENDING_EXCEPTION) {
     report_error("could not rewrite method - exception occurred or bytecode buffer overflow");
     return;
   }
 
-  // Relocator returns a new method oop.
+  // Relocator returns a new method.
   _did_relocation = true;
   _method = m;
 }
 
 
diff a/src/hotspot/share/oops/klass.cpp b/src/hotspot/share/oops/klass.cpp
--- a/src/hotspot/share/oops/klass.cpp
+++ b/src/hotspot/share/oops/klass.cpp
@@ -51,18 +51,22 @@
 #include "utilities/powerOfTwo.hpp"
 #include "utilities/stack.inline.hpp"
 
 void Klass::set_java_mirror(Handle m) {
   assert(!m.is_null(), "New mirror should never be null.");
-  assert(_java_mirror.resolve() == NULL, "should only be used to initialize mirror");
+  assert(_java_mirror.is_empty(), "should only be used to initialize mirror");
   _java_mirror = class_loader_data()->add_handle(m);
 }
 
 oop Klass::java_mirror_no_keepalive() const {
   return _java_mirror.peek();
 }
 
+void Klass::replace_java_mirror(oop mirror) {
+  _java_mirror.replace(mirror);
+}
+
 bool Klass::is_cloneable() const {
   return _access_flags.is_cloneable_fast() ||
          is_subtype_of(SystemDictionary::Cloneable_klass());
 }
 
@@ -193,14 +197,11 @@
 
 // "Normal" instantiation is preceeded by a MetaspaceObj allocation
 // which zeros out memory - calloc equivalent.
 // The constructor is also used from CppVtableCloner,
 // which doesn't zero out the memory before calling the constructor.
-// Need to set the _java_mirror field explicitly to not hit an assert that the field
-// should be NULL before setting it.
 Klass::Klass(KlassID id) : _id(id),
-                           _java_mirror(NULL),
                            _prototype_header(markWord::prototype()),
                            _shared_class_path_index(-1) {
   CDS_ONLY(_shared_class_flags = 0;)
   CDS_JAVA_HEAP_ONLY(_archived_mirror = 0;)
   _primary_supers[0] = this;
@@ -553,11 +554,11 @@
   if (log_is_enabled(Trace, cds, unshareable)) {
     ResourceMark rm;
     log_trace(cds, unshareable)("remove java_mirror: %s", external_name());
   }
   // Just null out the mirror.  The class_loader_data() no longer exists.
-  _java_mirror = OopHandle();
+  clear_java_mirror_handle();
 }
 
 void Klass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, TRAPS) {
   assert(is_klass(), "ensure C++ vtable is restored");
   assert(is_shared(), "must be set");
@@ -607,11 +608,11 @@
       }
     }
 
     // No archived mirror data
     log_debug(cds, mirror)("No archived mirror data for %s", external_name());
-    _java_mirror = OopHandle();
+    clear_java_mirror_handle();
     this->clear_has_raw_archived_mirror();
   }
 
   // Only recreate it if not present.  A previous attempt to restore may have
   // gotten an OOM later but keep the mirror if it was created.
diff a/src/hotspot/share/oops/klass.hpp b/src/hotspot/share/oops/klass.hpp
--- a/src/hotspot/share/oops/klass.hpp
+++ b/src/hotspot/share/oops/klass.hpp
@@ -265,16 +265,15 @@
   oop archived_java_mirror_raw() NOT_CDS_JAVA_HEAP_RETURN_(NULL); // no GC barrier
   narrowOop archived_java_mirror_raw_narrow() NOT_CDS_JAVA_HEAP_RETURN_(0); // no GC barrier
   void set_archived_java_mirror_raw(oop m) NOT_CDS_JAVA_HEAP_RETURN; // no GC barrier
 
   // Temporary mirror switch used by RedefineClasses
-  // Both mirrors are on the ClassLoaderData::_handles list already so no
-  // barriers are needed.
-  void set_java_mirror_handle(OopHandle mirror) { _java_mirror = mirror; }
-  OopHandle java_mirror_handle() const          {
-    return _java_mirror;
-  }
+  void replace_java_mirror(oop mirror);
+
+  // Set java mirror OopHandle to NULL for CDS
+  // This leaves the OopHandle in the CLD, but that's ok, you can't release them.
+  void clear_java_mirror_handle() { _java_mirror = OopHandle(); }
 
   // modifier flags
   jint modifier_flags() const          { return _modifier_flags; }
   void set_modifier_flags(jint flags)  { _modifier_flags = flags; }
 
diff a/src/hotspot/share/oops/klassVtable.cpp b/src/hotspot/share/oops/klassVtable.cpp
--- a/src/hotspot/share/oops/klassVtable.cpp
+++ b/src/hotspot/share/oops/klassVtable.cpp
@@ -1196,11 +1196,11 @@
 
 void klassItable::initialize_itable_for_interface(int method_table_offset, InstanceKlass* interf, bool checkconstraints, TRAPS) {
   assert(interf->is_interface(), "must be");
   Array<Method*>* methods = interf->methods();
   int nof_methods = methods->length();
-  HandleMark hm;
+  HandleMark hm(THREAD);
   Handle interface_loader (THREAD, interf->class_loader());
 
   int ime_count = method_count_for_interface(interf);
   for (int i = 0; i < nof_methods; i++) {
     Method* m = methods->at(i);
@@ -1588,11 +1588,10 @@
 int VtableStats::entries = 0;
 int VtableStats::array_entries = 0;
 
 void klassVtable::print_statistics() {
   ResourceMark rm;
-  HandleMark hm;
   VtableStats::compute();
   tty->print_cr("vtable statistics:");
   tty->print_cr("%6d classes (%d instance, %d array)", VtableStats::no_klasses, VtableStats::no_instance_klasses, VtableStats::no_array_klasses);
   int total = VtableStats::fixed + VtableStats::filler + VtableStats::entries;
   tty->print_cr("%6d bytes fixed overhead (refs + vtable object header)", VtableStats::fixed);
diff a/src/hotspot/share/oops/method.cpp b/src/hotspot/share/oops/method.cpp
--- a/src/hotspot/share/oops/method.cpp
+++ b/src/hotspot/share/oops/method.cpp
@@ -348,11 +348,11 @@
   it->push_method_entry(&this_ptr, (intptr_t*)&_i2i_entry);
   it->push_method_entry(&this_ptr, (intptr_t*)&_from_compiled_entry);
   it->push_method_entry(&this_ptr, (intptr_t*)&_from_interpreted_entry);
 }
 
-// Attempt to return method oop to original state.  Clear any pointers
+// Attempt to return method to original state.  Clear any pointers
 // (to objects outside the shared spaces).  We won't be able to predict
 // where they should point in a new JVM.  Further initialize some
 // entries now in order allow them to be write protected later.
 
 void Method::remove_unshareable_info() {
diff a/src/hotspot/share/oops/oopHandle.hpp b/src/hotspot/share/oops/oopHandle.hpp
--- a/src/hotspot/share/oops/oopHandle.hpp
+++ b/src/hotspot/share/oops/oopHandle.hpp
@@ -43,17 +43,31 @@
 public:
   OopHandle() : _obj(NULL) {}
   explicit OopHandle(oop* w) : _obj(w) {}
   OopHandle(OopStorage* storage, oop obj);
 
+  OopHandle(const OopHandle& copy) : _obj(copy._obj) {}
+
+  OopHandle& operator=(const OopHandle& copy) {
+    // Allow "this" to be junk if copy is empty; needed by initialization of
+    // raw memory in hashtables.
+    assert(is_empty() || copy.is_empty(), "can only copy if empty");
+    _obj = copy._obj;
+    return *this;
+  }
+
   inline oop resolve() const;
   inline oop peek() const;
 
   bool is_empty() const { return _obj == NULL; }
 
   inline void release(OopStorage* storage);
 
+  inline void replace(oop obj);
+
+  inline oop xchg(oop new_value);
+
   // Used only for removing handle.
   oop* ptr_raw() const { return _obj; }
 };
 
 // Convert OopHandle to oop*
diff a/src/hotspot/share/oops/oopHandle.inline.hpp b/src/hotspot/share/oops/oopHandle.inline.hpp
--- a/src/hotspot/share/oops/oopHandle.inline.hpp
+++ b/src/hotspot/share/oops/oopHandle.inline.hpp
@@ -52,6 +52,16 @@
     NativeAccess<>::oop_store(_obj, (oop)NULL);
     storage->release(_obj);
   }
 }
 
+inline void OopHandle::replace(oop obj) {
+  oop* ptr = ptr_raw();
+  assert(ptr != NULL, "should not use replace");
+  NativeAccess<>::oop_store(ptr, obj);
+}
+
+inline oop OopHandle::xchg(oop new_value) {
+  return NativeAccess<MO_SEQ_CST>::oop_atomic_xchg(_obj, new_value);
+}
+
 #endif // SHARE_OOPS_OOPHANDLE_INLINE_HPP
diff a/src/hotspot/share/oops/symbol.cpp b/src/hotspot/share/oops/symbol.cpp
--- a/src/hotspot/share/oops/symbol.cpp
+++ b/src/hotspot/share/oops/symbol.cpp
@@ -49,11 +49,16 @@
 }
 
 Symbol::Symbol(const u1* name, int length, int refcount) {
   _hash_and_refcount =  pack_hash_and_refcount((short)os::random(), refcount);
   _length = length;
-  _body[0] = 0;  // in case length == 0
+  // _body[0..1] are allocated in the header just by coincidence in the current
+  // implementation of Symbol. They are read by identity_hash(), so make sure they
+  // are initialized.
+  // No other code should assume that _body[0..1] are always allocated. E.g., do
+  // not unconditionally read base()[0] as that will be invalid for an empty Symbol.
+  _body[0] = _body[1] = 0;
   memcpy(_body, name, length);
 }
 
 void* Symbol::operator new(size_t sz, int len) throw() {
 #if INCLUDE_CDS
diff a/src/hotspot/share/opto/c2compiler.hpp b/src/hotspot/share/opto/c2compiler.hpp
--- a/src/hotspot/share/opto/c2compiler.hpp
+++ b/src/hotspot/share/opto/c2compiler.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -63,11 +63,11 @@
     return is_intrinsic_supported(method, false);
   }
 
   // Check if the compiler supports an intrinsic for 'method' given the
   // the dispatch mode specified by the 'is_virtual' parameter.
-  virtual bool is_intrinsic_supported(const methodHandle& method, bool is_virtual);
+  bool is_intrinsic_supported(const methodHandle& method, bool is_virtual);
 
   // Initial size of the code buffer (may be increased at runtime)
   static int initial_code_buffer_size(int const_size = initial_const_capacity);
 };
 
diff a/src/hotspot/share/opto/compile.cpp b/src/hotspot/share/opto/compile.cpp
--- a/src/hotspot/share/opto/compile.cpp
+++ b/src/hotspot/share/opto/compile.cpp
@@ -2415,19 +2415,25 @@
 
 static void eval_operands(Node* n,
                           uint& func1, uint& func2, uint& func3,
                           ResourceHashtable<Node*,uint>& eval_map) {
   assert(is_vector_bitwise_op(n), "");
-  func1 = eval_operand(n->in(1), eval_map);
 
-  if (is_vector_binary_bitwise_op(n)) {
+  if (is_vector_unary_bitwise_op(n)) {
+    Node* opnd = n->in(1);
+    if (VectorNode::is_vector_bitwise_not_pattern(n) && VectorNode::is_all_ones_vector(opnd)) {
+      opnd = n->in(2);
+    }
+    func1 = eval_operand(opnd, eval_map);
+  } else if (is_vector_binary_bitwise_op(n)) {
+    func1 = eval_operand(n->in(1), eval_map);
     func2 = eval_operand(n->in(2), eval_map);
-  } else if (is_vector_ternary_bitwise_op(n)) {
+  } else {
+    assert(is_vector_ternary_bitwise_op(n), "unknown operation");
+    func1 = eval_operand(n->in(1), eval_map);
     func2 = eval_operand(n->in(2), eval_map);
     func3 = eval_operand(n->in(3), eval_map);
-  } else {
-    assert(is_vector_unary_bitwise_op(n), "not unary");
   }
 }
 
 uint Compile::compute_truth_table(Unique_Node_List& partition, Unique_Node_List& inputs) {
   assert(inputs.size() <= 3, "sanity");
diff a/src/hotspot/share/opto/compile.hpp b/src/hotspot/share/opto/compile.hpp
--- a/src/hotspot/share/opto/compile.hpp
+++ b/src/hotspot/share/opto/compile.hpp
@@ -1015,18 +1015,10 @@
   Compile(ciEnv* ci_env, const TypeFunc *(*gen)(),
           address stub_function, const char *stub_name,
           int is_fancy_jump, bool pass_tls,
           bool save_arg_registers, bool return_pc, DirectiveSet* directive);
 
-  // From the TypeFunc signature, generate code to pass arguments
-  // from Compiled calling convention to Interpreter's calling convention
-  void Generate_Compiled_To_Interpreter_Graph(const TypeFunc *tf, address interpreter_entry);
-
-  // From the TypeFunc signature, generate code to pass arguments
-  // from Interpreter's calling convention to Compiler's calling convention
-  void Generate_Interpreter_To_Compiled_Graph(const TypeFunc *tf);
-
   // Are we compiling a method?
   bool has_method() { return method() != NULL; }
 
   // Maybe print some information about this compile.
   void print_compile_messages();
diff a/src/hotspot/share/opto/ifnode.cpp b/src/hotspot/share/opto/ifnode.cpp
--- a/src/hotspot/share/opto/ifnode.cpp
+++ b/src/hotspot/share/opto/ifnode.cpp
@@ -991,15 +991,19 @@
     lo = NULL;
     hi = NULL;
   }
 
   if (lo && hi) {
+    Node* hook = new Node(1);
+    hook->init_req(0, lo); // Add a use to lo to prevent him from dying
     // Merge the two compares into a single unsigned compare by building (CmpU (n - lo) (hi - lo))
     Node* adjusted_val = igvn->transform(new SubINode(n,  lo));
     if (adjusted_lim == NULL) {
       adjusted_lim = igvn->transform(new SubINode(hi, lo));
     }
+    hook->del_req(0); // Just yank bogus edge
+    hook->destruct();
     Node* newcmp = igvn->transform(new CmpUNode(adjusted_val, adjusted_lim));
     Node* newbool = igvn->transform(new BoolNode(newcmp, cond));
 
     igvn->replace_input_of(dom_iff, 1, igvn->intcon(proj->_con));
     igvn->_worklist.push(in(1));
diff a/src/hotspot/share/opto/loopTransform.cpp b/src/hotspot/share/opto/loopTransform.cpp
--- a/src/hotspot/share/opto/loopTransform.cpp
+++ b/src/hotspot/share/opto/loopTransform.cpp
@@ -1478,18 +1478,18 @@
 
   VectorSet visited;
   Node_Stack clones(main_head->back_control()->outcnt());
   // Step B3: Make the fall-in values to the main-loop come from the
   // fall-out values of the pre-loop.
-  for (DUIterator_Fast i2max, i2 = main_head->fast_outs(i2max); i2 < i2max; i2++) {
-    Node* main_phi = main_head->fast_out(i2);
+  for (DUIterator i2 = main_head->outs(); main_head->has_out(i2); i2++) {
+    Node* main_phi = main_head->out(i2);
     if (main_phi->is_Phi() && main_phi->in(0) == main_head && main_phi->outcnt() > 0) {
-      Node *pre_phi = old_new[main_phi->_idx];
-      Node *fallpre  = clone_up_backedge_goo(pre_head->back_control(),
-                                             main_head->skip_strip_mined()->in(LoopNode::EntryControl),
-                                             pre_phi->in(LoopNode::LoopBackControl),
-                                             visited, clones);
+      Node* pre_phi = old_new[main_phi->_idx];
+      Node* fallpre = clone_up_backedge_goo(pre_head->back_control(),
+                                            main_head->skip_strip_mined()->in(LoopNode::EntryControl),
+                                            pre_phi->in(LoopNode::LoopBackControl),
+                                            visited, clones);
       _igvn.hash_delete(main_phi);
       main_phi->set_req(LoopNode::EntryControl, fallpre);
     }
   }
 
@@ -1763,15 +1763,15 @@
 
   VectorSet visited;
   Node_Stack clones(main_head->back_control()->outcnt());
   // Step A3: Make the fall-in values to the post-loop come from the
   // fall-out values of the main-loop.
-  for (DUIterator_Fast imax, i = main_head->fast_outs(imax); i < imax; i++) {
-    Node* main_phi = main_head->fast_out(i);
+  for (DUIterator i = main_head->outs(); main_head->has_out(i); i++) {
+    Node* main_phi = main_head->out(i);
     if (main_phi->is_Phi() && main_phi->in(0) == main_head && main_phi->outcnt() > 0) {
-      Node *cur_phi = old_new[main_phi->_idx];
-      Node *fallnew = clone_up_backedge_goo(main_head->back_control(),
+      Node* cur_phi = old_new[main_phi->_idx];
+      Node* fallnew = clone_up_backedge_goo(main_head->back_control(),
                                             post_head->init_control(),
                                             main_phi->in(LoopNode::LoopBackControl),
                                             visited, clones);
       _igvn.hash_delete(cur_phi);
       cur_phi->set_req(LoopNode::EntryControl, fallnew);
diff a/src/hotspot/share/opto/loopopts.cpp b/src/hotspot/share/opto/loopopts.cpp
--- a/src/hotspot/share/opto/loopopts.cpp
+++ b/src/hotspot/share/opto/loopopts.cpp
@@ -44,11 +44,11 @@
 #include "utilities/macros.hpp"
 
 //=============================================================================
 //------------------------------split_thru_phi---------------------------------
 // Split Node 'n' through merge point if there is enough win.
-Node *PhaseIdealLoop::split_thru_phi( Node *n, Node *region, int policy ) {
+Node* PhaseIdealLoop::split_thru_phi(Node* n, Node* region, int policy) {
   if (n->Opcode() == Op_ConvI2L && n->bottom_type() != TypeLong::LONG) {
     // ConvI2L may have type information on it which is unsafe to push up
     // so disable this for now
     return NULL;
   }
@@ -59,45 +59,60 @@
   if (n->Opcode() == Op_CastII && n->as_CastII()->has_range_check() &&
       region->is_CountedLoop() && n->in(1) == region->as_CountedLoop()->phi()) {
     return NULL;
   }
 
+  // Bail out if 'n' is a Div or Mod node whose zero check was removed earlier (i.e. control is NULL) and its divisor is an induction variable
+  // phi p of a trip-counted (integer) loop whose inputs could be zero (include zero in their type range). p could have a more precise type
+  // range that does not necessarily include all values of its inputs. Since each of these inputs will be a divisor of the newly cloned nodes
+  // of 'n', we need to bail out of one of these divisors could be zero (zero in its type range).
+  if ((n->Opcode() == Op_DivI || n->Opcode() == Op_ModI) && n->in(0) == NULL
+      && region->is_CountedLoop() && n->in(2) == region->as_CountedLoop()->phi()) {
+    Node* phi = region->as_CountedLoop()->phi();
+    for (uint i = 1; i < phi->req(); i++) {
+      if (_igvn.type(phi->in(i))->filter_speculative(TypeInt::ZERO) != Type::TOP) {
+        // Zero could be a possible value but we already removed the zero check. Bail out to avoid a possible division by zero at a later point.
+        return NULL;
+      }
+    }
+  }
+
   int wins = 0;
   assert(!n->is_CFG(), "");
   assert(region->is_Region(), "");
 
   const Type* type = n->bottom_type();
-  const TypeOopPtr *t_oop = _igvn.type(n)->isa_oopptr();
-  Node *phi;
+  const TypeOopPtr* t_oop = _igvn.type(n)->isa_oopptr();
+  Node* phi;
   if (t_oop != NULL && t_oop->is_known_instance_field()) {
     int iid    = t_oop->instance_id();
     int index  = C->get_alias_index(t_oop);
     int offset = t_oop->offset();
     phi = new PhiNode(region, type, NULL, iid, index, offset);
   } else {
     phi = PhiNode::make_blank(region, n);
   }
   uint old_unique = C->unique();
   for (uint i = 1; i < region->req(); i++) {
-    Node *x;
+    Node* x;
     Node* the_clone = NULL;
     if (region->in(i) == C->top()) {
       x = C->top();             // Dead path?  Use a dead data op
     } else {
       x = n->clone();           // Else clone up the data op
       the_clone = x;            // Remember for possible deletion.
       // Alter data node to use pre-phi inputs
       if (n->in(0) == region)
         x->set_req( 0, region->in(i) );
       for (uint j = 1; j < n->req(); j++) {
-        Node *in = n->in(j);
+        Node* in = n->in(j);
         if (in->is_Phi() && in->in(0) == region)
-          x->set_req( j, in->in(i) ); // Use pre-Phi input for the clone
+          x->set_req(j, in->in(i)); // Use pre-Phi input for the clone
       }
     }
     // Check for a 'win' on some paths
-    const Type *t = x->Value(&_igvn);
+    const Type* t = x->Value(&_igvn);
 
     bool singleton = t->singleton();
 
     // A TOP singleton indicates that there are no possible values incoming
     // along a particular edge. In most cases, this is OK, and the Phi will
diff a/src/hotspot/share/opto/matcher.cpp b/src/hotspot/share/opto/matcher.cpp
--- a/src/hotspot/share/opto/matcher.cpp
+++ b/src/hotspot/share/opto/matcher.cpp
@@ -1963,11 +1963,11 @@
   }
   return false;
 }
 
 // A method-klass-holder may be passed in the inline_cache_reg
-// and then expanded into the inline_cache_reg and a method_oop register
+// and then expanded into the inline_cache_reg and a method_ptr register
 //   defined in ad_<arch>.cpp
 
 //------------------------------find_shared------------------------------------
 // Set bits if Node is shared or otherwise a root
 void Matcher::find_shared(Node* n) {
diff a/src/hotspot/share/opto/matcher.hpp b/src/hotspot/share/opto/matcher.hpp
--- a/src/hotspot/share/opto/matcher.hpp
+++ b/src/hotspot/share/opto/matcher.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -406,11 +406,11 @@
   // Number of callee-save + always-save registers
   // Ignores frame pointer and "special" registers
   static int  number_of_saved_registers();
 
   // The Method-klass-holder may be passed in the inline_cache_reg
-  // and then expanded into the inline_cache_reg and a method_oop register
+  // and then expanded into the inline_cache_reg and a method_ptr register
 
   static OptoReg::Name  interpreter_method_oop_reg();
   static int            interpreter_method_oop_reg_encode();
 
   static OptoReg::Name  compiler_method_oop_reg();
diff a/src/hotspot/share/prims/jni.cpp b/src/hotspot/share/prims/jni.cpp
--- a/src/hotspot/share/prims/jni.cpp
+++ b/src/hotspot/share/prims/jni.cpp
@@ -1169,15 +1169,16 @@
 
   if (name == NULL || signature == NULL) {
     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
   }
 
-  Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
+  oop mirror = JNIHandles::resolve_non_null(clazz);
+  Klass* klass = java_lang_Class::as_Klass(mirror);
 
   // Throw a NoSuchMethodError exception if we have an instance of a
   // primitive java.lang.Class
-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(clazz))) {
+  if (java_lang_Class::is_primitive(mirror)) {
     ResourceMark rm;
     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg("%s%s.%s%s", is_static ? "static " : "", klass->signature_name(), name_str, sig));
   }
 
   // Make sure class is linked and initialized before handing id's out to
@@ -3775,11 +3776,11 @@
         if (BootstrapJVMCI) {
           JavaThread* THREAD = thread;
           JVMCICompiler* compiler = JVMCICompiler::instance(true, CATCH);
           compiler->bootstrap(THREAD);
           if (HAS_PENDING_EXCEPTION) {
-            HandleMark hm;
+            HandleMark hm(THREAD);
             vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
           }
         }
       }
     }
@@ -3809,11 +3810,11 @@
     // to continue.
     if (Universe::is_fully_initialized()) {
       // otherwise no pending exception possible - VM will already have aborted
       JavaThread* THREAD = JavaThread::current();
       if (HAS_PENDING_EXCEPTION) {
-        HandleMark hm;
+        HandleMark hm(THREAD);
         vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
       }
     }
 
     if (can_try_again) {
diff a/src/hotspot/share/prims/jvm.cpp b/src/hotspot/share/prims/jvm.cpp
--- a/src/hotspot/share/prims/jvm.cpp
+++ b/src/hotspot/share/prims/jvm.cpp
@@ -536,11 +536,19 @@
 JVM_ENTRY_NO_ENV(jint, JVM_ActiveProcessorCount(void))
   JVMWrapper("JVM_ActiveProcessorCount");
   return os::active_processor_count();
 JVM_END
 
-
+JVM_ENTRY_NO_ENV(jboolean, JVM_IsUseContainerSupport(void))
+  JVMWrapper("JVM_IsUseContainerSupport");
+#ifdef LINUX
+  if (UseContainerSupport) {
+    return JNI_TRUE;
+  }
+#endif
+  return JNI_FALSE;
+JVM_END
 
 // java.lang.Throwable //////////////////////////////////////////////////////
 
 JVM_ENTRY(void, JVM_FillInStackTrace(JNIEnv *env, jobject receiver))
   JVMWrapper("JVM_FillInStackTrace");
@@ -1302,16 +1310,17 @@
 JVM_END
 
 JVM_ENTRY(jobjectArray, JVM_GetClassSigners(JNIEnv *env, jclass cls))
   JVMWrapper("JVM_GetClassSigners");
   JvmtiVMObjectAllocEventCollector oam;
-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
+  oop mirror = JNIHandles::resolve_non_null(cls);
+  if (java_lang_Class::is_primitive(mirror)) {
     // There are no signers for primitive types
     return NULL;
   }
 
-  objArrayHandle signers(THREAD, java_lang_Class::signers(JNIHandles::resolve_non_null(cls)));
+  objArrayHandle signers(THREAD, java_lang_Class::signers(mirror));
 
   // If there are no signers set in the class, or if the class
   // is an array, return NULL.
   if (signers == NULL) return NULL;
 
@@ -1327,34 +1336,36 @@
 JVM_END
 
 
 JVM_ENTRY(void, JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers))
   JVMWrapper("JVM_SetClassSigners");
-  if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
+  oop mirror = JNIHandles::resolve_non_null(cls);
+  if (!java_lang_Class::is_primitive(mirror)) {
     // This call is ignored for primitive types and arrays.
     // Signers are only set once, ClassLoader.java, and thus shouldn't
     // be called with an array.  Only the bootstrap loader creates arrays.
-    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
+    Klass* k = java_lang_Class::as_Klass(mirror);
     if (k->is_instance_klass()) {
       java_lang_Class::set_signers(k->java_mirror(), objArrayOop(JNIHandles::resolve(signers)));
     }
   }
 JVM_END
 
 
 JVM_ENTRY(jobject, JVM_GetProtectionDomain(JNIEnv *env, jclass cls))
   JVMWrapper("JVM_GetProtectionDomain");
-  if (JNIHandles::resolve(cls) == NULL) {
+  oop mirror = JNIHandles::resolve_non_null(cls);
+  if (mirror == NULL) {
     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
   }
 
-  if (java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
+  if (java_lang_Class::is_primitive(mirror)) {
     // Primitive types does not have a protection domain.
     return NULL;
   }
 
-  oop pd = java_lang_Class::protection_domain(JNIHandles::resolve(cls));
+  oop pd = java_lang_Class::protection_domain(mirror);
   return (jobject) JNIHandles::make_local(THREAD, pd);
 JVM_END
 
 
 // Returns the inherited_access_control_context field of the running thread.
@@ -1472,16 +1483,17 @@
 JVM_END
 
 
 JVM_ENTRY(jint, JVM_GetClassModifiers(JNIEnv *env, jclass cls))
   JVMWrapper("JVM_GetClassModifiers");
-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
+  oop mirror = JNIHandles::resolve_non_null(cls);
+  if (java_lang_Class::is_primitive(mirror)) {
     // Primitive type
     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
   }
 
-  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
+  Klass* k = java_lang_Class::as_Klass(mirror);
   debug_only(int computed_modifiers = k->compute_modifier_flags(CHECK_0));
   assert(k->modifier_flags() == computed_modifiers, "modifiers cache is OK");
   return k->modifier_flags();
 JVM_END
 
@@ -1490,18 +1502,18 @@
 
 JVM_ENTRY(jobjectArray, JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass))
   JvmtiVMObjectAllocEventCollector oam;
   // ofClass is a reference to a java_lang_Class object. The mirror object
   // of an InstanceKlass
-
-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
-      ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))->is_instance_klass()) {
+  oop ofMirror = JNIHandles::resolve_non_null(ofClass);
+  if (java_lang_Class::is_primitive(ofMirror) ||
+      ! java_lang_Class::as_Klass(ofMirror)->is_instance_klass()) {
     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
     return (jobjectArray)JNIHandles::make_local(THREAD, result);
   }
 
-  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
+  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(ofMirror));
   InnerClassesIterator iter(k);
 
   if (iter.length() == 0) {
     // Neither an inner nor outer class
     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
@@ -1555,33 +1567,39 @@
 
 
 JVM_ENTRY(jclass, JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass))
 {
   // ofClass is a reference to a java_lang_Class object.
-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
-      ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))->is_instance_klass()) {
+  oop ofMirror = JNIHandles::resolve_non_null(ofClass);
+  if (java_lang_Class::is_primitive(ofMirror)) {
+    return NULL;
+  }
+  Klass* klass = java_lang_Class::as_Klass(ofMirror);
+  if (!klass->is_instance_klass()) {
     return NULL;
   }
 
   bool inner_is_member = false;
   Klass* outer_klass
-    = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))
-                          )->compute_enclosing_class(&inner_is_member, CHECK_NULL);
+    = InstanceKlass::cast(klass)->compute_enclosing_class(&inner_is_member, CHECK_NULL);
   if (outer_klass == NULL)  return NULL;  // already a top-level class
   if (!inner_is_member)  return NULL;     // a hidden or unsafe anonymous class (inside a method)
   return (jclass) JNIHandles::make_local(THREAD, outer_klass->java_mirror());
 }
 JVM_END
 
 JVM_ENTRY(jstring, JVM_GetSimpleBinaryName(JNIEnv *env, jclass cls))
 {
   oop mirror = JNIHandles::resolve_non_null(cls);
-  if (java_lang_Class::is_primitive(mirror) ||
-      !java_lang_Class::as_Klass(mirror)->is_instance_klass()) {
+  if (java_lang_Class::is_primitive(mirror)) {
     return NULL;
   }
-  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
+  Klass* klass = java_lang_Class::as_Klass(mirror);
+  if (!klass->is_instance_klass()) {
+    return NULL;
+  }
+  InstanceKlass* k = InstanceKlass::cast(klass);
   int ooff = 0, noff = 0;
   if (k->find_inner_classes_attr(&ooff, &noff, THREAD)) {
     if (noff != 0) {
       constantPoolHandle i_cp(thread, k->constants());
       Symbol* name = i_cp->symbol_at(noff);
@@ -1596,13 +1614,14 @@
 JVM_ENTRY(jstring, JVM_GetClassSignature(JNIEnv *env, jclass cls))
   assert (cls != NULL, "illegal class");
   JVMWrapper("JVM_GetClassSignature");
   JvmtiVMObjectAllocEventCollector oam;
   ResourceMark rm(THREAD);
+  oop mirror = JNIHandles::resolve_non_null(cls);
   // Return null for arrays and primatives
-  if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
-    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
+  if (!java_lang_Class::is_primitive(mirror)) {
+    Klass* k = java_lang_Class::as_Klass(mirror);
     if (k->is_instance_klass()) {
       Symbol* sym = InstanceKlass::cast(k)->generic_signature();
       if (sym == NULL) return NULL;
       Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
       return (jstring) JNIHandles::make_local(THREAD, str());
@@ -1613,14 +1632,14 @@
 
 
 JVM_ENTRY(jbyteArray, JVM_GetClassAnnotations(JNIEnv *env, jclass cls))
   assert (cls != NULL, "illegal class");
   JVMWrapper("JVM_GetClassAnnotations");
-
+  oop mirror = JNIHandles::resolve_non_null(cls);
   // Return null for arrays and primitives
-  if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
-    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
+  if (!java_lang_Class::is_primitive(mirror)) {
+    Klass* k = java_lang_Class::as_Klass(mirror);
     if (k->is_instance_klass()) {
       typeArrayOop a = Annotations::make_java_array(InstanceKlass::cast(k)->class_annotations(), CHECK_NULL);
       return (jbyteArray) JNIHandles::make_local(THREAD, a);
     }
   }
@@ -1795,19 +1814,20 @@
 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly))
 {
   JVMWrapper("JVM_GetClassDeclaredFields");
   JvmtiVMObjectAllocEventCollector oam;
 
+  oop ofMirror = JNIHandles::resolve_non_null(ofClass);
   // Exclude primitive types and array types
-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
-      java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))->is_array_klass()) {
+  if (java_lang_Class::is_primitive(ofMirror) ||
+      java_lang_Class::as_Klass(ofMirror)->is_array_klass()) {
     // Return empty array
     oop res = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), 0, CHECK_NULL);
     return (jobjectArray) JNIHandles::make_local(THREAD, res);
   }
 
-  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
+  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(ofMirror));
   constantPoolHandle cp(THREAD, k->constants());
 
   // Ensure class is linked
   k->link_class(CHECK_NULL);
 
@@ -1903,19 +1923,20 @@
                                   bool want_constructor,
                                   Klass* klass, TRAPS) {
 
   JvmtiVMObjectAllocEventCollector oam;
 
+  oop ofMirror = JNIHandles::resolve_non_null(ofClass);
   // Exclude primitive types and array types
-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
-      || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))->is_array_klass()) {
+  if (java_lang_Class::is_primitive(ofMirror)
+      || java_lang_Class::as_Klass(ofMirror)->is_array_klass()) {
     // Return empty array
     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
     return (jobjectArray) JNIHandles::make_local(THREAD, res);
   }
 
-  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
+  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(ofMirror));
 
   // Ensure class is linked
   k->link_class(CHECK_NULL);
 
   Array<Method*>* methods = k->methods();
@@ -1985,16 +2006,17 @@
 JVM_END
 
 JVM_ENTRY(jint, JVM_GetClassAccessFlags(JNIEnv *env, jclass cls))
 {
   JVMWrapper("JVM_GetClassAccessFlags");
-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
+  oop mirror = JNIHandles::resolve_non_null(cls);
+  if (java_lang_Class::is_primitive(mirror)) {
     // Primitive type
     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
   }
 
-  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
+  Klass* k = java_lang_Class::as_Klass(mirror);
   return k->access_flags().as_int() & JVM_ACC_WRITTEN_FLAGS;
 }
 JVM_END
 
 JVM_ENTRY(jboolean, JVM_AreNestMates(JNIEnv *env, jclass current, jclass member))
@@ -2105,12 +2127,13 @@
 JVM_END
 
 JVM_ENTRY(jobjectArray, JVM_GetPermittedSubclasses(JNIEnv* env, jclass current))
 {
   JVMWrapper("JVM_GetPermittedSubclasses");
-  assert(!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(current)), "should not be");
-  Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
+  oop mirror = JNIHandles::resolve_non_null(current);
+  assert(!java_lang_Class::is_primitive(mirror), "should not be");
+  Klass* c = java_lang_Class::as_Klass(mirror);
   assert(c->is_instance_klass(), "must be");
   InstanceKlass* ik = InstanceKlass::cast(c);
   {
     JvmtiVMObjectAllocEventCollector oam;
     Array<u2>* subclasses = ik->permitted_subclasses();
@@ -2135,14 +2158,14 @@
 
 JVM_ENTRY(jobject, JVM_GetClassConstantPool(JNIEnv *env, jclass cls))
 {
   JVMWrapper("JVM_GetClassConstantPool");
   JvmtiVMObjectAllocEventCollector oam;
-
+  oop mirror = JNIHandles::resolve_non_null(cls);
   // Return null for primitives and arrays
-  if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
-    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
+  if (!java_lang_Class::is_primitive(mirror)) {
+    Klass* k = java_lang_Class::as_Klass(mirror);
     if (k->is_instance_klass()) {
       InstanceKlass* k_h = InstanceKlass::cast(k);
       Handle jcp = reflect_ConstantPool::create(CHECK_NULL);
       reflect_ConstantPool::set_cp(jcp(), k_h->constants());
       return JNIHandles::make_local(THREAD, jcp());
diff a/src/hotspot/share/prims/jvmtiEnter.xsl b/src/hotspot/share/prims/jvmtiEnter.xsl
--- a/src/hotspot/share/prims/jvmtiEnter.xsl
+++ b/src/hotspot/share/prims/jvmtiEnter.xsl
@@ -1,8 +1,8 @@
 <?xml version="1.0"?> 
 <!--
- Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.
+ Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 
  This code is free software; you can redistribute it and/or modify it
  under the terms of the GNU General Public License version 2 only, as
  published by the Free Software Foundation.
@@ -885,23 +885,23 @@
 </xsl:template>
 
 
 <xsl:template match="jmethodID" mode="dochecks">
   <xsl:param name="name"/>
-  <xsl:text>  Method* method_oop = Method::checked_resolve_jmethod_id(</xsl:text>
+  <xsl:text>  Method* checked_method = Method::checked_resolve_jmethod_id(</xsl:text>
   <xsl:value-of select="$name"/>
   <xsl:text>);&#xA;</xsl:text>
-  <xsl:text>  if (method_oop == NULL) {&#xA;</xsl:text>
+  <xsl:text>  if (checked_method == NULL) {&#xA;</xsl:text>
   <xsl:apply-templates select=".." mode="traceError">     
     <xsl:with-param name="err">JVMTI_ERROR_INVALID_METHODID</xsl:with-param>
     <xsl:with-param name="comment"></xsl:with-param>
     <xsl:with-param name="extraValue"></xsl:with-param>
   </xsl:apply-templates>
   <xsl:text>&#xA;</xsl:text>
   <xsl:text>  }&#xA;</xsl:text>
   <xsl:if test="count(@native)=1 and contains(@native,'error')">
-    <xsl:text>  if (method_oop->is_native()) {&#xA;</xsl:text>   
+    <xsl:text>  if (checked_method->is_native()) {&#xA;</xsl:text>   
     <xsl:text>    return JVMTI_ERROR_NATIVE_METHOD;&#xA;</xsl:text>   
     <xsl:text>  }&#xA;</xsl:text>   
   </xsl:if>
 </xsl:template>
 
@@ -1150,12 +1150,12 @@
 </xsl:template>
 
 <xsl:template match="jmethodID" mode="traceInValue">
   <xsl:param name="name"/>
   <xsl:text>, 
-                    method_oop == NULL? "NULL" : method_oop->klass_name()->as_C_string(),
-                    method_oop == NULL? "NULL" : method_oop->name()->as_C_string()
+                    checked_method == NULL? "NULL" : checked_method->klass_name()->as_C_string(),
+                    checked_method == NULL? "NULL" : checked_method->name()->as_C_string()
              </xsl:text>
 </xsl:template>
 
 <xsl:template match="jfieldID" mode="traceInValue">
   <xsl:param name="name"/>
diff a/src/hotspot/share/prims/jvmtiEnv.cpp b/src/hotspot/share/prims/jvmtiEnv.cpp
--- a/src/hotspot/share/prims/jvmtiEnv.cpp
+++ b/src/hotspot/share/prims/jvmtiEnv.cpp
@@ -658,11 +658,11 @@
       return JVMTI_ERROR_ILLEGAL_ARGUMENT;
     }
 
     // lock the loader
     Thread* thread = Thread::current();
-    HandleMark hm;
+    HandleMark hm(thread);
     Handle loader_lock = Handle(thread, SystemDictionary::system_loader_lock());
 
     ObjectLocker ol(loader_lock, thread);
 
     // add the jar file to the bootclasspath
@@ -695,24 +695,23 @@
     return JVMTI_ERROR_NONE;
   } else if (phase == JVMTI_PHASE_LIVE) {
     // The phase is checked by the wrapper that called this function,
     // but this thread could be racing with the thread that is
     // terminating the VM so we check one more time.
-    HandleMark hm;
+    Thread* THREAD = Thread::current();
+    HandleMark hm(THREAD);
 
     // create the zip entry (which will open the zip file and hence
     // check that the segment is indeed a zip file).
     ClassPathZipEntry* zip_entry = ClassLoader::create_class_path_zip_entry(segment, false);
     if (zip_entry == NULL) {
       return JVMTI_ERROR_ILLEGAL_ARGUMENT;
     }
     delete zip_entry;   // no longer needed
 
     // lock the loader
-    Thread* THREAD = Thread::current();
     Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
-
     ObjectLocker ol(loader, THREAD);
 
     // need the path as java.lang.String
     Handle path = java_lang_String::create_from_platform_dependent_str(segment, THREAD);
     if (HAS_PENDING_EXCEPTION) {
@@ -913,15 +912,16 @@
 // threads_ptr - pre-checked for NULL
 jvmtiError
 JvmtiEnv::GetAllThreads(jint* threads_count_ptr, jthread** threads_ptr) {
   int nthreads        = 0;
   Handle *thread_objs = NULL;
-  ResourceMark rm;
-  HandleMark hm;
+  Thread* current_thread = Thread::current();
+  ResourceMark rm(current_thread);
+  HandleMark hm(current_thread);
 
   // enumerate threads (including agent threads)
-  ThreadsListEnumerator tle(Thread::current(), true);
+  ThreadsListEnumerator tle(current_thread, true);
   nthreads = tle.num_threads();
   *threads_count_ptr = nthreads;
 
   if (nthreads == 0) {
     *threads_ptr = NULL;
@@ -1123,14 +1123,14 @@
 // Threads_lock NOT held
 // thread - NOT pre-checked
 // info_ptr - pre-checked for NULL
 jvmtiError
 JvmtiEnv::GetThreadInfo(jthread thread, jvmtiThreadInfo* info_ptr) {
-  ResourceMark rm;
-  HandleMark hm;
-
   JavaThread* current_thread = JavaThread::current();
+  ResourceMark rm(current_thread);
+  HandleMark hm(current_thread);
+
   ThreadsListHandle tlh(current_thread);
 
   // if thread is NULL the current thread is used
   oop thread_oop = NULL;
   if (thread == NULL) {
@@ -1398,14 +1398,13 @@
 
 
 // info_ptr - pre-checked for NULL
 jvmtiError
 JvmtiEnv::GetThreadGroupInfo(jthreadGroup group, jvmtiThreadGroupInfo* info_ptr) {
-  ResourceMark rm;
-  HandleMark hm;
-
-  JavaThread* current_thread = JavaThread::current();
+  Thread* current_thread = Thread::current();
+  ResourceMark rm(current_thread);
+  HandleMark hm(current_thread);
 
   Handle group_obj (current_thread, JNIHandles::resolve_external_guard(group));
   NULL_CHECK(group_obj(), JVMTI_ERROR_INVALID_THREAD_GROUP);
 
   const char* name;
@@ -1616,18 +1615,18 @@
   if (state == NULL) {
     return JVMTI_ERROR_THREAD_NOT_ALIVE;
   }
 
   // It is only safe to perform the direct operation on the current
-  // thread. All other usage needs to use a vm-safepoint-op for safety.
+  // thread. All other usage needs to use a direct handshake for safety.
   if (java_thread == JavaThread::current()) {
     err = get_frame_count(state, count_ptr);
   } else {
-    // get java stack frame count at safepoint.
-    VM_GetFrameCount op(this, state, count_ptr);
-    VMThread::execute(&op);
-    err = op.result();
+    // get java stack frame count with handshake.
+    GetFrameCountClosure op(this, state, count_ptr);
+    bool executed = Handshake::execute_direct(&op, java_thread);
+    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;
   }
   return err;
 } /* end GetFrameCount */
 
 
@@ -1746,18 +1745,18 @@
 jvmtiError
 JvmtiEnv::GetFrameLocation(JavaThread* java_thread, jint depth, jmethodID* method_ptr, jlocation* location_ptr) {
   jvmtiError err = JVMTI_ERROR_NONE;
 
   // It is only safe to perform the direct operation on the current
-  // thread. All other usage needs to use a vm-safepoint-op for safety.
+  // thread. All other usage needs to use a direct handshake for safety.
   if (java_thread == JavaThread::current()) {
     err = get_frame_location(java_thread, depth, method_ptr, location_ptr);
   } else {
-    // JVMTI get java stack frame location at safepoint.
-    VM_GetFrameLocation op(this, java_thread, depth, method_ptr, location_ptr);
-    VMThread::execute(&op);
-    err = op.result();
+    // JVMTI get java stack frame location via direct handshake.
+    GetFrameLocationClosure op(this, depth, method_ptr, location_ptr);
+    bool executed = Handshake::execute_direct(&op, java_thread);
+    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;
   }
   return err;
 } /* end GetFrameLocation */
 
 
@@ -2248,24 +2247,24 @@
 
   //
   // Breakpoint functions
   //
 
-// method_oop - pre-checked for validity, but may be NULL meaning obsolete method
+// method - pre-checked for validity, but may be NULL meaning obsolete method
 jvmtiError
-JvmtiEnv::SetBreakpoint(Method* method_oop, jlocation location) {
-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);
+JvmtiEnv::SetBreakpoint(Method* method, jlocation location) {
+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);
   if (location < 0) {   // simple invalid location check first
     return JVMTI_ERROR_INVALID_LOCATION;
   }
   // verify that the breakpoint is not past the end of the method
-  if (location >= (jlocation) method_oop->code_size()) {
+  if (location >= (jlocation) method->code_size()) {
     return JVMTI_ERROR_INVALID_LOCATION;
   }
 
   ResourceMark rm;
-  JvmtiBreakpoint bp(method_oop, location);
+  JvmtiBreakpoint bp(method, location);
   JvmtiBreakpoints& jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
   if (jvmti_breakpoints.set(bp) == JVMTI_ERROR_DUPLICATE)
     return JVMTI_ERROR_DUPLICATE;
 
   if (TraceJVMTICalls) {
@@ -2274,25 +2273,25 @@
 
   return JVMTI_ERROR_NONE;
 } /* end SetBreakpoint */
 
 
-// method_oop - pre-checked for validity, but may be NULL meaning obsolete method
+// method - pre-checked for validity, but may be NULL meaning obsolete method
 jvmtiError
-JvmtiEnv::ClearBreakpoint(Method* method_oop, jlocation location) {
-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);
+JvmtiEnv::ClearBreakpoint(Method* method, jlocation location) {
+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);
 
   if (location < 0) {   // simple invalid location check first
     return JVMTI_ERROR_INVALID_LOCATION;
   }
 
   // verify that the breakpoint is not past the end of the method
-  if (location >= (jlocation) method_oop->code_size()) {
+  if (location >= (jlocation) method->code_size()) {
     return JVMTI_ERROR_INVALID_LOCATION;
   }
 
-  JvmtiBreakpoint bp(method_oop, location);
+  JvmtiBreakpoint bp(method, location);
 
   JvmtiBreakpoints& jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
   if (jvmti_breakpoints.clear(bp) == JVMTI_ERROR_NOT_FOUND)
     return JVMTI_ERROR_NOT_FOUND;
 
@@ -2514,58 +2513,58 @@
   // Allocate the result and fill it in
   int result_length = ik->methods()->length();
   jmethodID* result_list = (jmethodID*)jvmtiMalloc(result_length * sizeof(jmethodID));
   int index;
   bool jmethodids_found = true;
-
-  if (JvmtiExport::can_maintain_original_method_order()) {
-    // Use the original method ordering indices stored in the class, so we can emit
-    // jmethodIDs in the order they appeared in the class file
-    for (index = 0; index < result_length; index++) {
-      Method* m = ik->methods()->at(index);
-      int original_index = ik->method_ordering()->at(index);
-      assert(original_index >= 0 && original_index < result_length, "invalid original method index");
-      jmethodID id;
-      if (jmethodids_found) {
-        id = m->find_jmethod_id_or_null();
-        if (id == NULL) {
-          // If we find an uninitialized value, make sure there is
-          // enough space for all the uninitialized values we might
-          // find.
-          ik->ensure_space_for_methodids(index);
-          jmethodids_found = false;
-          id = m->jmethod_id();
-        }
-      } else {
+  int skipped = 0;  // skip overpass methods
+
+  for (index = 0; index < result_length; index++) {
+    Method* m = ik->methods()->at(index);
+    // Depending on can_maintain_original_method_order capability use the original
+    // method ordering indices stored in the class, so we can emit jmethodIDs in
+    // the order they appeared in the class file or just copy in current order.
+    int result_index = JvmtiExport::can_maintain_original_method_order() ? ik->method_ordering()->at(index) : index;
+    assert(result_index >= 0 && result_index < result_length, "invalid original method index");
+    if (m->is_overpass()) {
+      result_list[result_index] = NULL;
+      skipped++;
+      continue;
+    }
+    jmethodID id;
+    if (jmethodids_found) {
+      id = m->find_jmethod_id_or_null();
+      if (id == NULL) {
+        // If we find an uninitialized value, make sure there is
+        // enough space for all the uninitialized values we might
+        // find.
+        ik->ensure_space_for_methodids(index);
+        jmethodids_found = false;
         id = m->jmethod_id();
       }
-      result_list[original_index] = id;
+    } else {
+      id = m->jmethod_id();
     }
-  } else {
-    // otherwise just copy in any order
-    for (index = 0; index < result_length; index++) {
-      Method* m = ik->methods()->at(index);
-      jmethodID id;
-      if (jmethodids_found) {
-        id = m->find_jmethod_id_or_null();
-        if (id == NULL) {
-          // If we find an uninitialized value, make sure there is
-          // enough space for all the uninitialized values we might
-          // find.
-          ik->ensure_space_for_methodids(index);
-          jmethodids_found = false;
-          id = m->jmethod_id();
-        }
+    result_list[result_index] = id;
+  }
+
+  // Fill in return value.
+  if (skipped > 0) {
+    // copy results skipping NULL methodIDs
+    *methods_ptr = (jmethodID*)jvmtiMalloc((result_length - skipped) * sizeof(jmethodID));
+    *method_count_ptr = result_length - skipped;
+    for (index = 0, skipped = 0; index < result_length; index++) {
+      if (result_list[index] == NULL) {
+        skipped++;
       } else {
-        id = m->jmethod_id();
+        (*methods_ptr)[index - skipped] = result_list[index];
       }
-      result_list[index] = id;
     }
+    deallocate((unsigned char *)result_list);
+  } else {
+    *method_count_ptr = result_length;
+    *methods_ptr = result_list;
   }
-  // Fill in return value.
-  *method_count_ptr = result_length;
-  *methods_ptr = result_list;
 
   return JVMTI_ERROR_NONE;
 } /* end GetClassMethods */
 
 
@@ -2943,38 +2942,38 @@
 
   //
   // Method functions
   //
 
-// method_oop - pre-checked for validity, but may be NULL meaning obsolete method
+// method - pre-checked for validity, but may be NULL meaning obsolete method
 // name_ptr - NULL is a valid value, must be checked
 // signature_ptr - NULL is a valid value, must be checked
 // generic_ptr - NULL is a valid value, must be checked
 jvmtiError
-JvmtiEnv::GetMethodName(Method* method_oop, char** name_ptr, char** signature_ptr, char** generic_ptr) {
-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);
+JvmtiEnv::GetMethodName(Method* method, char** name_ptr, char** signature_ptr, char** generic_ptr) {
+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);
   JavaThread* current_thread  = JavaThread::current();
 
   ResourceMark rm(current_thread); // get the utf8 name and signature
   if (name_ptr == NULL) {
     // just don't return the name
   } else {
-    const char* utf8_name = (const char *) method_oop->name()->as_utf8();
+    const char* utf8_name = (const char *) method->name()->as_utf8();
     *name_ptr = (char *) jvmtiMalloc(strlen(utf8_name)+1);
     strcpy(*name_ptr, utf8_name);
   }
   if (signature_ptr == NULL) {
     // just don't return the signature
   } else {
-    const char* utf8_signature = (const char *) method_oop->signature()->as_utf8();
+    const char* utf8_signature = (const char *) method->signature()->as_utf8();
     *signature_ptr = (char *) jvmtiMalloc(strlen(utf8_signature) + 1);
     strcpy(*signature_ptr, utf8_signature);
   }
 
   if (generic_ptr != NULL) {
     *generic_ptr = NULL;
-    Symbol* soop = method_oop->generic_signature();
+    Symbol* soop = method->generic_signature();
     if (soop != NULL) {
       const char* gen_sig = soop->as_C_string();
       if (gen_sig != NULL) {
         jvmtiError err = allocate(strlen(gen_sig) + 1, (unsigned char **)generic_ptr);
         if (err != JVMTI_ERROR_NONE) {
@@ -2986,79 +2985,79 @@
   }
   return JVMTI_ERROR_NONE;
 } /* end GetMethodName */
 
 
-// method_oop - pre-checked for validity, but may be NULL meaning obsolete method
+// method - pre-checked for validity, but may be NULL meaning obsolete method
 // declaring_class_ptr - pre-checked for NULL
 jvmtiError
-JvmtiEnv::GetMethodDeclaringClass(Method* method_oop, jclass* declaring_class_ptr) {
-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);
-  (*declaring_class_ptr) = get_jni_class_non_null(method_oop->method_holder());
+JvmtiEnv::GetMethodDeclaringClass(Method* method, jclass* declaring_class_ptr) {
+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);
+  (*declaring_class_ptr) = get_jni_class_non_null(method->method_holder());
   return JVMTI_ERROR_NONE;
 } /* end GetMethodDeclaringClass */
 
 
-// method_oop - pre-checked for validity, but may be NULL meaning obsolete method
+// method - pre-checked for validity, but may be NULL meaning obsolete method
 // modifiers_ptr - pre-checked for NULL
 jvmtiError
-JvmtiEnv::GetMethodModifiers(Method* method_oop, jint* modifiers_ptr) {
-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);
-  (*modifiers_ptr) = method_oop->access_flags().as_int() & JVM_RECOGNIZED_METHOD_MODIFIERS;
+JvmtiEnv::GetMethodModifiers(Method* method, jint* modifiers_ptr) {
+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);
+  (*modifiers_ptr) = method->access_flags().as_int() & JVM_RECOGNIZED_METHOD_MODIFIERS;
   return JVMTI_ERROR_NONE;
 } /* end GetMethodModifiers */
 
 
-// method_oop - pre-checked for validity, but may be NULL meaning obsolete method
+// method - pre-checked for validity, but may be NULL meaning obsolete method
 // max_ptr - pre-checked for NULL
 jvmtiError
-JvmtiEnv::GetMaxLocals(Method* method_oop, jint* max_ptr) {
-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);
+JvmtiEnv::GetMaxLocals(Method* method, jint* max_ptr) {
+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);
   // get max stack
-  (*max_ptr) = method_oop->max_locals();
+  (*max_ptr) = method->max_locals();
   return JVMTI_ERROR_NONE;
 } /* end GetMaxLocals */
 
 
-// method_oop - pre-checked for validity, but may be NULL meaning obsolete method
+// method - pre-checked for validity, but may be NULL meaning obsolete method
 // size_ptr - pre-checked for NULL
 jvmtiError
-JvmtiEnv::GetArgumentsSize(Method* method_oop, jint* size_ptr) {
-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);
+JvmtiEnv::GetArgumentsSize(Method* method, jint* size_ptr) {
+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);
   // get size of arguments
 
-  (*size_ptr) = method_oop->size_of_parameters();
+  (*size_ptr) = method->size_of_parameters();
   return JVMTI_ERROR_NONE;
 } /* end GetArgumentsSize */
 
 
-// method_oop - pre-checked for validity, but may be NULL meaning obsolete method
+// method - pre-checked for validity, but may be NULL meaning obsolete method
 // entry_count_ptr - pre-checked for NULL
 // table_ptr - pre-checked for NULL
 jvmtiError
-JvmtiEnv::GetLineNumberTable(Method* method_oop, jint* entry_count_ptr, jvmtiLineNumberEntry** table_ptr) {
-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);
-  if (!method_oop->has_linenumber_table()) {
+JvmtiEnv::GetLineNumberTable(Method* method, jint* entry_count_ptr, jvmtiLineNumberEntry** table_ptr) {
+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);
+  if (!method->has_linenumber_table()) {
     return (JVMTI_ERROR_ABSENT_INFORMATION);
   }
 
   // The line number table is compressed so we don't know how big it is until decompressed.
   // Decompression is really fast so we just do it twice.
 
   // Compute size of table
   jint num_entries = 0;
-  CompressedLineNumberReadStream stream(method_oop->compressed_linenumber_table());
+  CompressedLineNumberReadStream stream(method->compressed_linenumber_table());
   while (stream.read_pair()) {
     num_entries++;
   }
   jvmtiLineNumberEntry *jvmti_table =
             (jvmtiLineNumberEntry *)jvmtiMalloc(num_entries * (sizeof(jvmtiLineNumberEntry)));
 
   // Fill jvmti table
   if (num_entries > 0) {
     int index = 0;
-    CompressedLineNumberReadStream stream(method_oop->compressed_linenumber_table());
+    CompressedLineNumberReadStream stream(method->compressed_linenumber_table());
     while (stream.read_pair()) {
       jvmti_table[index].start_location = (jlocation) stream.bci();
       jvmti_table[index].line_number = (jint) stream.line();
       index++;
     }
@@ -3071,57 +3070,57 @@
 
   return JVMTI_ERROR_NONE;
 } /* end GetLineNumberTable */
 
 
-// method_oop - pre-checked for validity, but may be NULL meaning obsolete method
+// method - pre-checked for validity, but may be NULL meaning obsolete method
 // start_location_ptr - pre-checked for NULL
 // end_location_ptr - pre-checked for NULL
 jvmtiError
-JvmtiEnv::GetMethodLocation(Method* method_oop, jlocation* start_location_ptr, jlocation* end_location_ptr) {
+JvmtiEnv::GetMethodLocation(Method* method, jlocation* start_location_ptr, jlocation* end_location_ptr) {
 
-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);
+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);
   // get start and end location
-  (*end_location_ptr) = (jlocation) (method_oop->code_size() - 1);
-  if (method_oop->code_size() == 0) {
+  (*end_location_ptr) = (jlocation) (method->code_size() - 1);
+  if (method->code_size() == 0) {
     // there is no code so there is no start location
     (*start_location_ptr) = (jlocation)(-1);
   } else {
     (*start_location_ptr) = (jlocation)(0);
   }
 
   return JVMTI_ERROR_NONE;
 } /* end GetMethodLocation */
 
 
-// method_oop - pre-checked for validity, but may be NULL meaning obsolete method
+// method - pre-checked for validity, but may be NULL meaning obsolete method
 // entry_count_ptr - pre-checked for NULL
 // table_ptr - pre-checked for NULL
 jvmtiError
-JvmtiEnv::GetLocalVariableTable(Method* method_oop, jint* entry_count_ptr, jvmtiLocalVariableEntry** table_ptr) {
+JvmtiEnv::GetLocalVariableTable(Method* method, jint* entry_count_ptr, jvmtiLocalVariableEntry** table_ptr) {
 
-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);
+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);
   JavaThread* current_thread  = JavaThread::current();
 
   // does the klass have any local variable information?
-  InstanceKlass* ik = method_oop->method_holder();
+  InstanceKlass* ik = method->method_holder();
   if (!ik->access_flags().has_localvariable_table()) {
     return (JVMTI_ERROR_ABSENT_INFORMATION);
   }
 
-  ConstantPool* constants = method_oop->constants();
+  ConstantPool* constants = method->constants();
   NULL_CHECK(constants, JVMTI_ERROR_ABSENT_INFORMATION);
 
   // in the vm localvariable table representation, 6 consecutive elements in the table
   // represent a 6-tuple of shorts
   // [start_pc, length, name_index, descriptor_index, signature_index, index]
-  jint num_entries = method_oop->localvariable_table_length();
+  jint num_entries = method->localvariable_table_length();
   jvmtiLocalVariableEntry *jvmti_table = (jvmtiLocalVariableEntry *)
                 jvmtiMalloc(num_entries * (sizeof(jvmtiLocalVariableEntry)));
 
   if (num_entries > 0) {
-    LocalVariableTableElement* table = method_oop->localvariable_table_start();
+    LocalVariableTableElement* table = method->localvariable_table_start();
     for (int i = 0; i < num_entries; i++) {
       // get the 5 tuple information from the vm table
       jlocation start_location = (jlocation) table[i].start_bci;
       jint length = (jint) table[i].length;
       int name_index = (int) table[i].name_cp_index;
@@ -3168,66 +3167,65 @@
 
   return JVMTI_ERROR_NONE;
 } /* end GetLocalVariableTable */
 
 
-// method_oop - pre-checked for validity, but may be NULL meaning obsolete method
+// method - pre-checked for validity, but may be NULL meaning obsolete method
 // bytecode_count_ptr - pre-checked for NULL
 // bytecodes_ptr - pre-checked for NULL
 jvmtiError
-JvmtiEnv::GetBytecodes(Method* method_oop, jint* bytecode_count_ptr, unsigned char** bytecodes_ptr) {
-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);
+JvmtiEnv::GetBytecodes(Method* method, jint* bytecode_count_ptr, unsigned char** bytecodes_ptr) {
+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);
 
-  HandleMark hm;
-  methodHandle method(Thread::current(), method_oop);
-  jint size = (jint)method->code_size();
+  methodHandle mh(Thread::current(), method);
+  jint size = (jint)mh->code_size();
   jvmtiError err = allocate(size, bytecodes_ptr);
   if (err != JVMTI_ERROR_NONE) {
     return err;
   }
 
   (*bytecode_count_ptr) = size;
   // get byte codes
-  JvmtiClassFileReconstituter::copy_bytecodes(method, *bytecodes_ptr);
+  JvmtiClassFileReconstituter::copy_bytecodes(mh, *bytecodes_ptr);
 
   return JVMTI_ERROR_NONE;
 } /* end GetBytecodes */
 
 
-// method_oop - pre-checked for validity, but may be NULL meaning obsolete method
+// method - pre-checked for validity, but may be NULL meaning obsolete method
 // is_native_ptr - pre-checked for NULL
 jvmtiError
-JvmtiEnv::IsMethodNative(Method* method_oop, jboolean* is_native_ptr) {
-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);
-  (*is_native_ptr) = method_oop->is_native();
+JvmtiEnv::IsMethodNative(Method* method, jboolean* is_native_ptr) {
+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);
+  (*is_native_ptr) = method->is_native();
   return JVMTI_ERROR_NONE;
 } /* end IsMethodNative */
 
 
-// method_oop - pre-checked for validity, but may be NULL meaning obsolete method
+// method - pre-checked for validity, but may be NULL meaning obsolete method
 // is_synthetic_ptr - pre-checked for NULL
 jvmtiError
-JvmtiEnv::IsMethodSynthetic(Method* method_oop, jboolean* is_synthetic_ptr) {
-  NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);
-  (*is_synthetic_ptr) = method_oop->is_synthetic();
+JvmtiEnv::IsMethodSynthetic(Method* method, jboolean* is_synthetic_ptr) {
+  NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);
+  (*is_synthetic_ptr) = method->is_synthetic();
   return JVMTI_ERROR_NONE;
 } /* end IsMethodSynthetic */
 
 
-// method_oop - pre-checked for validity, but may be NULL meaning obsolete method
+// method - pre-checked for validity, but may be NULL meaning obsolete method
 // is_obsolete_ptr - pre-checked for NULL
 jvmtiError
-JvmtiEnv::IsMethodObsolete(Method* method_oop, jboolean* is_obsolete_ptr) {
+JvmtiEnv::IsMethodObsolete(Method* method, jboolean* is_obsolete_ptr) {
   if (use_version_1_0_semantics() &&
       get_capabilities()->can_redefine_classes == 0) {
     // This JvmtiEnv requested version 1.0 semantics and this function
     // requires the can_redefine_classes capability in version 1.0 so
     // we need to return an error here.
     return JVMTI_ERROR_MUST_POSSESS_CAPABILITY;
   }
 
-  if (method_oop == NULL || method_oop->is_obsolete()) {
+  if (method == NULL || method->is_obsolete()) {
     *is_obsolete_ptr = true;
   } else {
     *is_obsolete_ptr = false;
   }
   return JVMTI_ERROR_NONE;
diff a/src/hotspot/share/prims/jvmtiEnv.xsl b/src/hotspot/share/prims/jvmtiEnv.xsl
--- a/src/hotspot/share/prims/jvmtiEnv.xsl
+++ b/src/hotspot/share/prims/jvmtiEnv.xsl
@@ -1,8 +1,8 @@
 <?xml version="1.0"?> 
 <!--
- Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
+ Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 
  This code is free software; you can redistribute it and/or modify it
  under the terms of the GNU General Public License version 2 only, as
  published by the Free Software Foundation.
@@ -137,11 +137,11 @@
 </xsl:template>
 
 <xsl:template match="jmethodID" mode="advice">
   <xsl:param name="name"/>
   <xsl:text>
-// method_oop - pre-checked for validity, but may be NULL meaning obsolete method</xsl:text>
+// method - pre-checked for validity, but may be NULL meaning obsolete method</xsl:text>
 </xsl:template>
 
 <xsl:template match="jfieldID" mode="advice">
   <xsl:param name="name"/>
 </xsl:template>
diff a/src/hotspot/share/prims/jvmtiEnvBase.cpp b/src/hotspot/share/prims/jvmtiEnvBase.cpp
--- a/src/hotspot/share/prims/jvmtiEnvBase.cpp
+++ b/src/hotspot/share/prims/jvmtiEnvBase.cpp
@@ -620,12 +620,13 @@
   jint ret = 0;
   if (!java_thread->has_last_Java_frame()) {
     return ret;  // no Java frames so no monitors
   }
 
-  ResourceMark rm;
-  HandleMark   hm;
+  Thread* current_thread = Thread::current();
+  ResourceMark rm(current_thread);
+  HandleMark   hm(current_thread);
   RegisterMap  reg_map(java_thread);
 
   for(javaVFrame *jvf=java_thread->last_java_vframe(&reg_map); jvf != NULL;
                                                  jvf = jvf->java_sender()) {
     GrowableArray<MonitorInfo*>* mons = jvf->monitors();
@@ -673,11 +674,11 @@
   }
 
   if (obj == NULL) {
     *monitor_ptr = NULL;
   } else {
-    HandleMark hm;
+    HandleMark hm(current_jt);
     Handle     hobj(current_jt, obj);
     *monitor_ptr = jni_reference(calling_thread, hobj);
   }
   return JVMTI_ERROR_NONE;
 }
@@ -691,12 +692,12 @@
   assert(current_jt == java_thread ||
          current_jt == java_thread->active_handshaker(),
          "call by myself or at direct handshake");
 
   if (java_thread->has_last_Java_frame()) {
-    ResourceMark rm;
-    HandleMark   hm;
+    ResourceMark rm(current_jt);
+    HandleMark   hm(current_jt);
     RegisterMap  reg_map(java_thread);
 
     int depth = 0;
     for (javaVFrame *jvf = java_thread->last_java_vframe(&reg_map); jvf != NULL;
          jvf = jvf->java_sender()) {
@@ -721,12 +722,13 @@
 // Save JNI local handles for any objects that this frame owns.
 jvmtiError
 JvmtiEnvBase::get_locked_objects_in_frame(JavaThread* calling_thread, JavaThread* java_thread,
                                  javaVFrame *jvf, GrowableArray<jvmtiMonitorStackDepthInfo*>* owned_monitors_list, jint stack_depth) {
   jvmtiError err = JVMTI_ERROR_NONE;
-  ResourceMark rm;
-  HandleMark hm;
+  Thread* current_thread = Thread::current();
+  ResourceMark rm(current_thread);
+  HandleMark   hm(current_thread);
 
   GrowableArray<MonitorInfo*>* mons = jvf->monitors();
   if (mons->is_empty()) {
     return err;  // this javaVFrame holds no monitors
   }
@@ -898,14 +900,14 @@
 JvmtiEnvBase::get_frame_location(JavaThread *java_thread, jint depth,
                                  jmethodID* method_ptr, jlocation* location_ptr) {
 #ifdef ASSERT
   uint32_t debug_bits = 0;
 #endif
-  assert((SafepointSynchronize::is_at_safepoint() ||
-          java_thread->is_thread_fully_suspended(false, &debug_bits)),
-         "at safepoint or target thread is suspended");
   Thread* current_thread = Thread::current();
+  assert(current_thread == java_thread ||
+         current_thread == java_thread->active_handshaker(),
+         "call by myself or at direct handshake");
   ResourceMark rm(current_thread);
 
   vframe *vf = vframeFor(java_thread, depth);
   if (vf == NULL) {
     return JVMTI_ERROR_NO_MORE_FRAMES;
@@ -1556,24 +1558,22 @@
                                                       _frame_buffer, _count_ptr);
   }
 }
 
 void
-VM_GetFrameCount::doit() {
-  _result = JVMTI_ERROR_THREAD_NOT_ALIVE;
+GetFrameCountClosure::do_thread(Thread *target) {
   JavaThread* jt = _state->get_thread();
-  ThreadsListHandle tlh;
-  if (jt != NULL && tlh.includes(jt) && !jt->is_exiting() && jt->threadObj() != NULL) {
+  assert(target == jt, "just checking");
+  if (!jt->is_exiting() && jt->threadObj() != NULL) {
     _result = ((JvmtiEnvBase*)_env)->get_frame_count(_state, _count_ptr);
   }
 }
 
 void
-VM_GetFrameLocation::doit() {
-  _result = JVMTI_ERROR_THREAD_NOT_ALIVE;
-  ThreadsListHandle tlh;
-  if (_java_thread != NULL && tlh.includes(_java_thread)
-      && !_java_thread->is_exiting() && _java_thread->threadObj() != NULL) {
-    _result = ((JvmtiEnvBase*)_env)->get_frame_location(_java_thread, _depth,
+GetFrameLocationClosure::do_thread(Thread *target) {
+  assert(target->is_Java_thread(), "just checking");
+  JavaThread *jt = (JavaThread *)target;
+  if (!jt->is_exiting() && jt->threadObj() != NULL) {
+    _result = ((JvmtiEnvBase*)_env)->get_frame_location(jt, _depth,
                                                         _method_ptr, _location_ptr);
   }
 }
diff a/src/hotspot/share/prims/jvmtiEnvBase.hpp b/src/hotspot/share/prims/jvmtiEnvBase.hpp
--- a/src/hotspot/share/prims/jvmtiEnvBase.hpp
+++ b/src/hotspot/share/prims/jvmtiEnvBase.hpp
@@ -555,51 +555,51 @@
   void do_thread(Thread *target);
   jvmtiStackInfo *stack_info()    { return _collector.stack_info(); }
   jvmtiError result()             { return _collector.result(); }
 };
 
-// VM operation to count stack frames at safepoint.
-class VM_GetFrameCount : public VM_Operation {
+// HandshakeClosure to count stack frames.
+class GetFrameCountClosure : public HandshakeClosure {
 private:
   JvmtiEnv *_env;
   JvmtiThreadState *_state;
   jint *_count_ptr;
   jvmtiError _result;
 
 public:
-  VM_GetFrameCount(JvmtiEnv *env, JvmtiThreadState *state, jint *count_ptr) {
-    _env = env;
-    _state = state;
-    _count_ptr = count_ptr;
+  GetFrameCountClosure(JvmtiEnv *env, JvmtiThreadState *state, jint *count_ptr)
+    : HandshakeClosure("GetFrameCount"),
+      _env(env),
+      _state(state),
+      _count_ptr(count_ptr),
+      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {
   }
-  VMOp_Type type() const { return VMOp_GetFrameCount; }
   jvmtiError result()    { return _result; }
-  void doit();
+  void do_thread(Thread *target);
 };
 
-// VM operation to frame location at safepoint.
-class VM_GetFrameLocation : public VM_Operation {
+// HandshakeClosure to get frame location.
+class GetFrameLocationClosure : public HandshakeClosure {
 private:
   JvmtiEnv *_env;
-  JavaThread* _java_thread;
   jint _depth;
   jmethodID* _method_ptr;
   jlocation* _location_ptr;
   jvmtiError _result;
 
 public:
-  VM_GetFrameLocation(JvmtiEnv *env, JavaThread* java_thread, jint depth,
-                      jmethodID* method_ptr, jlocation* location_ptr) {
-    _env = env;
-    _java_thread = java_thread;
-    _depth = depth;
-    _method_ptr = method_ptr;
-    _location_ptr = location_ptr;
+  GetFrameLocationClosure(JvmtiEnv *env, jint depth,
+                          jmethodID* method_ptr, jlocation* location_ptr)
+    : HandshakeClosure("GetFrameLocation"),
+      _env(env),
+      _depth(depth),
+      _method_ptr(method_ptr),
+      _location_ptr(location_ptr),
+      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {
   }
-  VMOp_Type type() const { return VMOp_GetFrameLocation; }
   jvmtiError result()    { return _result; }
-  void doit();
+  void do_thread(Thread *target);
 };
 
 
 // ResourceTracker
 //
diff a/src/hotspot/share/prims/jvmtiExport.cpp b/src/hotspot/share/prims/jvmtiExport.cpp
--- a/src/hotspot/share/prims/jvmtiExport.cpp
+++ b/src/hotspot/share/prims/jvmtiExport.cpp
@@ -103,11 +103,11 @@
   HandleMark _hm;
   JavaThreadState _saved_state;
   JavaThread *_jthread;
 
 public:
-  JvmtiThreadEventTransition(Thread *thread) : _rm(), _hm() {
+  JvmtiThreadEventTransition(Thread *thread) : _rm(), _hm(thread) {
     if (thread->is_Java_thread()) {
        _jthread = (JavaThread *)thread;
        _saved_state = _jthread->thread_state();
        if (_saved_state == _thread_in_Java) {
          ThreadStateTransition::transition_from_java(_jthread, _thread_in_native);
diff a/src/hotspot/share/prims/jvmtiImpl.cpp b/src/hotspot/share/prims/jvmtiImpl.cpp
--- a/src/hotspot/share/prims/jvmtiImpl.cpp
+++ b/src/hotspot/share/prims/jvmtiImpl.cpp
@@ -529,19 +529,19 @@
 //   JVMTI_ERROR_INVALID_SLOT
 //   JVMTI_ERROR_TYPE_MISMATCH
 // Returns: 'true' - everything is Ok, 'false' - error code
 
 bool VM_GetOrSetLocal::check_slot_type_lvt(javaVFrame* jvf) {
-  Method* method_oop = jvf->method();
-  jint num_entries = method_oop->localvariable_table_length();
+  Method* method = jvf->method();
+  jint num_entries = method->localvariable_table_length();
   if (num_entries == 0) {
     _result = JVMTI_ERROR_INVALID_SLOT;
     return false;       // There are no slots
   }
   int signature_idx = -1;
   int vf_bci = jvf->bci();
-  LocalVariableTableElement* table = method_oop->localvariable_table_start();
+  LocalVariableTableElement* table = method->localvariable_table_start();
   for (int i = 0; i < num_entries; i++) {
     int start_bci = table[i].start_bci;
     int end_bci = start_bci + table[i].length;
 
     // Here we assume that locations of LVT entries
@@ -553,11 +553,11 @@
   }
   if (signature_idx == -1) {
     _result = JVMTI_ERROR_INVALID_SLOT;
     return false;       // Incorrect slot index
   }
-  Symbol*   sign_sym  = method_oop->constants()->symbol_at(signature_idx);
+  Symbol*   sign_sym  = method->constants()->symbol_at(signature_idx);
   BasicType slot_type = Signature::basic_type(sign_sym);
 
   switch (slot_type) {
   case T_BYTE:
   case T_SHORT:
@@ -595,14 +595,14 @@
   }
   return true;
 }
 
 bool VM_GetOrSetLocal::check_slot_type_no_lvt(javaVFrame* jvf) {
-  Method* method_oop = jvf->method();
+  Method* method = jvf->method();
   jint extra_slot = (_type == T_LONG || _type == T_DOUBLE) ? 1 : 0;
 
-  if (_index < 0 || _index + extra_slot >= method_oop->max_locals()) {
+  if (_index < 0 || _index + extra_slot >= method->max_locals()) {
     _result = JVMTI_ERROR_INVALID_SLOT;
     return false;
   }
   StackValueCollection *locals = _jvf->locals();
   BasicType slot_type = locals->at(_index)->type();
@@ -631,28 +631,28 @@
 
 bool VM_GetOrSetLocal::doit_prologue() {
   _jvf = get_java_vframe();
   NULL_CHECK(_jvf, false);
 
-  Method* method_oop = _jvf->method();
+  Method* method = _jvf->method();
   if (getting_receiver()) {
-    if (method_oop->is_static()) {
+    if (method->is_static()) {
       _result = JVMTI_ERROR_INVALID_SLOT;
       return false;
     }
     return true;
   }
 
-  if (method_oop->is_native()) {
+  if (method->is_native()) {
     _result = JVMTI_ERROR_OPAQUE_FRAME;
     return false;
   }
 
   if (!check_slot_type_no_lvt(_jvf)) {
     return false;
   }
-  if (method_oop->has_localvariable_table()) {
+  if (method->has_localvariable_table()) {
     return check_slot_type_lvt(_jvf);
   }
   return true;
 }
 
@@ -693,19 +693,20 @@
       _jvf = get_java_vframe();
       ((compiledVFrame*)_jvf)->update_local(_type, _index, _value);
       return;
     }
     StackValueCollection *locals = _jvf->locals();
-    HandleMark hm;
+    Thread* current_thread = Thread::current();
+    HandleMark hm(current_thread);
 
     switch (_type) {
       case T_INT:    locals->set_int_at   (_index, _value.i); break;
       case T_LONG:   locals->set_long_at  (_index, _value.j); break;
       case T_FLOAT:  locals->set_float_at (_index, _value.f); break;
       case T_DOUBLE: locals->set_double_at(_index, _value.d); break;
       case T_OBJECT: {
-        Handle ob_h(Thread::current(), JNIHandles::resolve_external_guard(_value.l));
+        Handle ob_h(current_thread, JNIHandles::resolve_external_guard(_value.l));
         locals->set_obj_at (_index, ob_h);
         break;
       }
       default: ShouldNotReachHere();
     }
diff a/src/hotspot/share/prims/jvmtiLib.xsl b/src/hotspot/share/prims/jvmtiLib.xsl
--- a/src/hotspot/share/prims/jvmtiLib.xsl
+++ b/src/hotspot/share/prims/jvmtiLib.xsl
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
 
- Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
+ Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 
  This code is free software; you can redistribute it and/or modify it
  under the terms of the GNU General Public License version 2 only, as
  published by the Free Software Foundation.
@@ -930,11 +930,11 @@
 <xsl:template match="jframeID" mode="HotSpotName">
   <xsl:text>depth</xsl:text>
 </xsl:template>
 
 <xsl:template match="jmethodID" mode="HotSpotName">
-  <xsl:text>method_oop</xsl:text>
+  <xsl:text>checked_method</xsl:text>
 </xsl:template>
 
 <xsl:template match="jfieldID" mode="HotSpotName">
   <xsl:text>fdesc_ptr</xsl:text>
 </xsl:template>
diff a/src/hotspot/share/prims/jvmtiRedefineClasses.cpp b/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
--- a/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
+++ b/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
@@ -1219,10 +1219,48 @@
 
   return true;  // made it through the gauntlet; this is our special case
 } // end is_unresolved_class_mismatch()
 
 
+// The bug 6214132 caused the verification to fail.
+// 1. What's done in RedefineClasses() before verification:
+//  a) A reference to the class being redefined (_the_class) and a
+//     reference to new version of the class (_scratch_class) are
+//     saved here for use during the bytecode verification phase of
+//     RedefineClasses.
+//  b) The _java_mirror field from _the_class is copied to the
+//     _java_mirror field in _scratch_class. This means that a jclass
+//     returned for _the_class or _scratch_class will refer to the
+//     same Java mirror. The verifier will see the "one true mirror"
+//     for the class being verified.
+// 2. See comments in JvmtiThreadState for what is done during verification.
+
+class RedefineVerifyMark : public StackObj {
+ private:
+  JvmtiThreadState* _state;
+  Klass*            _scratch_class;
+  Handle            _scratch_mirror;
+
+ public:
+
+  RedefineVerifyMark(Klass* the_class, Klass* scratch_class,
+                     JvmtiThreadState* state) : _state(state), _scratch_class(scratch_class)
+  {
+    _state->set_class_versions_map(the_class, scratch_class);
+    _scratch_mirror = Handle(_state->get_thread(), _scratch_class->java_mirror());
+    _scratch_class->replace_java_mirror(the_class->java_mirror());
+  }
+
+  ~RedefineVerifyMark() {
+    // Restore the scratch class's mirror, so when scratch_class is removed
+    // the correct mirror pointing to it can be cleared.
+    _scratch_class->replace_java_mirror(_scratch_mirror());
+    _state->clear_class_versions_map();
+  }
+};
+
+
 jvmtiError VM_RedefineClasses::load_new_class_versions(TRAPS) {
 
   // For consistency allocate memory using os::malloc wrapper.
   _scratch_classes = (InstanceKlass**)
     os::malloc(sizeof(InstanceKlass*) * _class_count, mtClass);
diff a/src/hotspot/share/prims/jvmtiTagMap.cpp b/src/hotspot/share/prims/jvmtiTagMap.cpp
--- a/src/hotspot/share/prims/jvmtiTagMap.cpp
+++ b/src/hotspot/share/prims/jvmtiTagMap.cpp
@@ -839,11 +839,10 @@
 
 // Returns a heap allocated ClassFieldMap to describe the static fields
 // of the given class.
 //
 ClassFieldMap* ClassFieldMap::create_map_of_static_fields(Klass* k) {
-  HandleMark hm;
   InstanceKlass* ik = InstanceKlass::cast(k);
 
   // create the field map
   ClassFieldMap* field_map = new ClassFieldMap();
 
@@ -864,11 +863,10 @@
 // Returns a heap allocated ClassFieldMap to describe the instance fields
 // of the given class. All instance fields are included (this means public
 // and private fields declared in superclasses and superinterfaces too).
 //
 ClassFieldMap* ClassFieldMap::create_map_of_instance_fields(oop obj) {
-  HandleMark hm;
   InstanceKlass* ik = InstanceKlass::cast(obj->klass());
 
   // create the field map
   ClassFieldMap* field_map = new ClassFieldMap();
 
diff a/src/hotspot/share/prims/jvmtiThreadState.cpp b/src/hotspot/share/prims/jvmtiThreadState.cpp
--- a/src/hotspot/share/prims/jvmtiThreadState.cpp
+++ b/src/hotspot/share/prims/jvmtiThreadState.cpp
@@ -214,13 +214,17 @@
 }
 
 
 // Helper routine used in several places
 int JvmtiThreadState::count_frames() {
-  guarantee(SafepointSynchronize::is_at_safepoint() ||
-    (JavaThread *)Thread::current() == get_thread(),
-    "must be current thread or at safepoint");
+#ifdef ASSERT
+  Thread *current_thread = Thread::current();
+#endif
+  assert(current_thread == get_thread() ||
+         SafepointSynchronize::is_at_safepoint() ||
+         current_thread == get_thread()->active_handshaker(),
+         "call by myself / at safepoint / at handshake");
 
   if (!get_thread()->has_last_Java_frame()) return 0;  // no Java frames
 
   ResourceMark rm;
   RegisterMap reg_map(get_thread());
diff a/src/hotspot/share/prims/jvmtiThreadState.hpp b/src/hotspot/share/prims/jvmtiThreadState.hpp
--- a/src/hotspot/share/prims/jvmtiThreadState.hpp
+++ b/src/hotspot/share/prims/jvmtiThreadState.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -245,23 +245,12 @@
   }
 
   // RedefineClasses support
   // The bug 6214132 caused the verification to fail.
   //
-  // Below is the detailed description of the fix approach taken:
-  // 1. What's done in RedefineClasses() before verification:
-  //  a) A reference to the class being redefined (_the_class) and a
-  //     reference to new version of the class (_scratch_class) are
-  //     saved here for use during the bytecode verification phase of
-  //     RedefineClasses. See RedefineVerifyMark for how these fields
-  //     are managed.
-  //   b) The _java_mirror field from _the_class is copied to the
-  //     _java_mirror field in _scratch_class. This means that a jclass
-  //     returned for _the_class or _scratch_class will refer to the
-  //     same Java mirror. The verifier will see the "one true mirror"
-  //     for the class being verified.
-  // 2. What is done at verification:
+  // What is done at verification:
+  //   (This seems to only apply to the old verifier.)
   //   When the verifier makes calls into the VM to ask questions about
   //   the class being verified, it will pass the jclass to JVM_* functions.
   //   The jclass is always pointing to the mirror of _the_class.
   //   ~28 JVM_* functions called by the verifier for the information
   //   about CP entries and klass structure should check the jvmtiThreadState
@@ -399,29 +388,6 @@
   void enqueue_event(JvmtiDeferredEvent* event) NOT_JVMTI_RETURN;
   void post_events(JvmtiEnv* env);
   void run_nmethod_entry_barriers();
 };
 
-class RedefineVerifyMark : public StackObj {
- private:
-  JvmtiThreadState* _state;
-  Klass*            _scratch_class;
-  OopHandle         _scratch_mirror;
-
- public:
-  RedefineVerifyMark(Klass* the_class, Klass* scratch_class,
-                     JvmtiThreadState *state) : _state(state), _scratch_class(scratch_class)
-  {
-    _state->set_class_versions_map(the_class, scratch_class);
-    _scratch_mirror = _scratch_class->java_mirror_handle();
-    _scratch_class->set_java_mirror_handle(the_class->java_mirror_handle());
-  }
-
-  ~RedefineVerifyMark() {
-    // Restore the scratch class's mirror, so when scratch_class is removed
-    // the correct mirror pointing to it can be cleared.
-    _scratch_class->set_java_mirror_handle(_scratch_mirror);
-    _state->clear_class_versions_map();
-  }
-};
-
 #endif // SHARE_PRIMS_JVMTITHREADSTATE_HPP
diff a/src/hotspot/share/prims/resolvedMethodTable.cpp b/src/hotspot/share/prims/resolvedMethodTable.cpp
--- a/src/hotspot/share/prims/resolvedMethodTable.cpp
+++ b/src/hotspot/share/prims/resolvedMethodTable.cpp
@@ -51,13 +51,14 @@
 static const size_t GROW_HINT = 32;
 
 static const size_t ResolvedMethodTableSizeLog = 10;
 
 unsigned int method_hash(const Method* method) {
-  unsigned int name_hash = method->name()->identity_hash();
-  unsigned int signature_hash = method->signature()->identity_hash();
-  return name_hash ^ signature_hash;
+  unsigned int hash = method->klass_name()->identity_hash();
+  hash = (hash * 31) ^ method->name()->identity_hash();
+  hash = (hash * 31) ^ method->signature()->identity_hash();
+  return hash;
 }
 
 typedef ConcurrentHashTable<ResolvedMethodTableConfig,
                             mtClass> ResolvedMethodTableHash;
 
diff a/src/hotspot/share/prims/whitebox.cpp b/src/hotspot/share/prims/whitebox.cpp
--- a/src/hotspot/share/prims/whitebox.cpp
+++ b/src/hotspot/share/prims/whitebox.cpp
@@ -2029,15 +2029,15 @@
       tty->cr();
       Atomic::inc(&_num_threads_completed);
     }
 
   public:
-    TraceSelfClosure() : HandshakeClosure("WB_TraceSelf"), _num_threads_completed(0) {}
+    TraceSelfClosure(Thread* thread) : HandshakeClosure("WB_TraceSelf"), _num_threads_completed(0) {}
 
     jint num_threads_completed() const { return _num_threads_completed; }
   };
-  TraceSelfClosure tsc;
+  TraceSelfClosure tsc(Thread::current());
 
   if (all_threads) {
     Handshake::execute(&tsc);
   } else {
     oop thread_oop = JNIHandles::resolve(thread_handle);
diff a/src/hotspot/share/runtime/deoptimization.cpp b/src/hotspot/share/runtime/deoptimization.cpp
--- a/src/hotspot/share/runtime/deoptimization.cpp
+++ b/src/hotspot/share/runtime/deoptimization.cpp
@@ -214,11 +214,12 @@
   }
   return realloc_failures;
 }
 
 static void eliminate_locks(JavaThread* thread, GrowableArray<compiledVFrame*>* chunk, bool realloc_failures) {
-  HandleMark hm;
+  assert(thread == Thread::current(), "should be");
+  HandleMark hm(thread);
 #ifndef PRODUCT
   bool first = true;
 #endif
   for (int i = 0; i < chunk->length(); i++) {
     compiledVFrame* cvf = chunk->at(i);
@@ -634,11 +635,11 @@
 
   // It is actually ok to allocate handles in a leaf method. It causes no safepoints,
   // but makes the entry a little slower. There is however a little dance we have to
   // do in debug mode to get around the NoHandleMark code in the JRT_LEAF macro
   ResetNoHandleMark rnhm; // No-op in release/product versions
-  HandleMark hm;
+  HandleMark hm(thread);
 
   frame stub_frame = thread->last_frame();
 
   // Since the frame to unpack is the top frame of this thread, the vframe_array_head
   // must point to the vframeArray for the unpack frame.
@@ -1532,12 +1533,13 @@
 
 void Deoptimization::revoke_from_deopt_handler(JavaThread* thread, frame fr, RegisterMap* map) {
   if (!UseBiasedLocking) {
     return;
   }
-  ResourceMark rm;
-  HandleMark hm;
+  assert(thread == Thread::current(), "should be");
+  ResourceMark rm(thread);
+  HandleMark hm(thread);
   GrowableArray<Handle>* objects_to_revoke = new GrowableArray<Handle>();
   get_monitors_from_stack(objects_to_revoke, thread, fr, map);
 
   int len = objects_to_revoke->length();
   for (int i = 0; i < len; i++) {
@@ -1765,11 +1767,11 @@
 }
 
 #endif // INCLUDE_JFR
 
 JRT_ENTRY(void, Deoptimization::uncommon_trap_inner(JavaThread* thread, jint trap_request)) {
-  HandleMark hm;
+  HandleMark hm(thread);
 
   // uncommon_trap() is called at the beginning of the uncommon trap
   // handler. Note this fact before we start generating temporary frames
   // that can confuse an asynchronous stack walker. This counter is
   // decremented at the end of unpack_frames().
diff a/src/hotspot/share/runtime/globals.hpp b/src/hotspot/share/runtime/globals.hpp
--- a/src/hotspot/share/runtime/globals.hpp
+++ b/src/hotspot/share/runtime/globals.hpp
@@ -866,11 +866,11 @@
                                                                             \
   develop(bool, TimeOopMap2, false,                                         \
           "Time calls to GenerateOopMap::compute_map() individually")       \
                                                                             \
   develop(bool, TraceOopMapRewrites, false,                                 \
-          "Trace rewriting of method oops during oop map generation")       \
+          "Trace rewriting of methods during oop map generation")           \
                                                                             \
   develop(bool, TraceICBuffer, false,                                       \
           "Trace usage of IC buffer")                                       \
                                                                             \
   develop(bool, TraceCompiledIC, false,                                     \
diff a/src/hotspot/share/runtime/handles.cpp b/src/hotspot/share/runtime/handles.cpp
--- a/src/hotspot/share/runtime/handles.cpp
+++ b/src/hotspot/share/runtime/handles.cpp
@@ -114,11 +114,11 @@
 
   if (_prev != NULL) _prev->oops_do(f);
 }
 
 void HandleMark::initialize(Thread* thread) {
-  _thread = thread;
+  _thread = thread;  // Not the current thread during thread creation.
   // Save area
   _area  = thread->handle_area();
   // Save current top
   _chunk = _area->_chunk;
   _hwm   = _area->_hwm;
diff a/src/hotspot/share/runtime/handles.hpp b/src/hotspot/share/runtime/handles.hpp
--- a/src/hotspot/share/runtime/handles.hpp
+++ b/src/hotspot/share/runtime/handles.hpp
@@ -226,11 +226,11 @@
 // destructor will reset the top, destroying all handles allocated in between.
 // The following code will therefore NOT work:
 //
 //   Handle h;
 //   {
-//     HandleMark hm;
+//     HandleMark hm(THREAD);
 //     h = Handle(THREAD, obj);
 //   }
 //   h()->print();       // WRONG, h destroyed by HandleMark destructor.
 //
 // If h has to be preserved, it can be converted to an oop or a local JNI handle
@@ -255,11 +255,10 @@
 
   size_t size_in_bytes() const { return _size_in_bytes; }
   // remove all chunks beginning with the next
   void chop_later_chunks();
  public:
-  HandleMark();                            // see handles_inline.hpp
   HandleMark(Thread* thread)                      { initialize(thread); }
   ~HandleMark();
 
   // Functions used by HandleMarkCleaner
   // called in the constructor of HandleMarkCleaner
diff a/src/hotspot/share/runtime/handles.inline.hpp b/src/hotspot/share/runtime/handles.inline.hpp
--- a/src/hotspot/share/runtime/handles.inline.hpp
+++ b/src/hotspot/share/runtime/handles.inline.hpp
@@ -65,14 +65,10 @@
 }                                                                      \
 
 DEF_METADATA_HANDLE_FN(method, Method)
 DEF_METADATA_HANDLE_FN(constantPool, ConstantPool)
 
-inline HandleMark::HandleMark() {
-  initialize(Thread::current());
-}
-
 inline void HandleMark::push() {
   // This is intentionally a NOP. pop_and_restore will reset
   // values to the HandleMark further down the stack, typically
   // in JavaCalls::call_helper.
   debug_only(_area->_handle_mark_nesting++);
diff a/src/hotspot/share/runtime/init.cpp b/src/hotspot/share/runtime/init.cpp
--- a/src/hotspot/share/runtime/init.cpp
+++ b/src/hotspot/share/runtime/init.cpp
@@ -105,11 +105,10 @@
   SuspendibleThreadSet_init();
 }
 
 
 jint init_globals() {
-  HandleMark hm;
   management_init();
   bytecodes_init();
   classLoader_init1();
   compilationPolicy_init();
   codeCache_init();
diff a/src/hotspot/share/runtime/java.cpp b/src/hotspot/share/runtime/java.cpp
--- a/src/hotspot/share/runtime/java.cpp
+++ b/src/hotspot/share/runtime/java.cpp
@@ -109,11 +109,10 @@
 
 void print_method_profiling_data() {
   if (ProfileInterpreter COMPILER1_PRESENT(|| C1UpdateMethodData) &&
      (PrintMethodData || CompilerOracle::should_print_methods())) {
     ResourceMark rm;
-    HandleMark hm;
     collected_profiled_methods = new GrowableArray<Method*>(1024);
     SystemDictionary::methods_do(collect_profiled_methods);
     collected_profiled_methods->sort(&compare_methods);
 
     int count = collected_profiled_methods->length();
@@ -156,11 +155,10 @@
 
 
 
 void print_method_invocation_histogram() {
   ResourceMark rm;
-  HandleMark hm;
   collected_invoked_methods = new GrowableArray<Method*>(1024);
   SystemDictionary::methods_do(collect_invoked_methods);
   collected_invoked_methods->sort(&compare_methods);
   //
   tty->cr();
diff a/src/hotspot/share/runtime/safepointMechanism.hpp b/src/hotspot/share/runtime/safepointMechanism.hpp
--- a/src/hotspot/share/runtime/safepointMechanism.hpp
+++ b/src/hotspot/share/runtime/safepointMechanism.hpp
@@ -71,12 +71,10 @@
 
   // Caller is responsible for using a memory barrier if needed.
   static inline void arm_local_poll(JavaThread* thread);
   // Release semantics
   static inline void arm_local_poll_release(JavaThread* thread);
-  // Optional release
-  static inline void disarm_if_needed(JavaThread* thread, bool memory_order_release);
 
   // Setup the selected safepoint mechanism
   static void initialize();
   static void initialize_header(JavaThread* thread);
 };
diff a/src/hotspot/share/runtime/thread.cpp b/src/hotspot/share/runtime/thread.cpp
--- a/src/hotspot/share/runtime/thread.cpp
+++ b/src/hotspot/share/runtime/thread.cpp
@@ -1573,11 +1573,14 @@
   }
 }
 
 // Attempt to enlarge the array for per thread counters.
 jlong* resize_counters_array(jlong* old_counters, int current_size, int new_size) {
-  jlong* new_counters = NEW_C_HEAP_ARRAY(jlong, new_size, mtJVMCI);
+  jlong* new_counters = NEW_C_HEAP_ARRAY_RETURN_NULL(jlong, new_size, mtJVMCI);
+  if (new_counters == NULL) {
+    return NULL;
+  }
   if (old_counters == NULL) {
     old_counters = new_counters;
     memset(old_counters, 0, sizeof(jlong) * new_size);
   } else {
     for (int i = 0; i < MIN2((int) current_size, new_size); i++) {
@@ -1590,38 +1593,58 @@
   }
   return new_counters;
 }
 
 // Attempt to enlarge the array for per thread counters.
-void JavaThread::resize_counters(int current_size, int new_size) {
-  _jvmci_counters = resize_counters_array(_jvmci_counters, current_size, new_size);
+bool JavaThread::resize_counters(int current_size, int new_size) {
+  jlong* new_counters = resize_counters_array(_jvmci_counters, current_size, new_size);
+  if (new_counters == NULL) {
+    return false;
+  } else {
+    _jvmci_counters = new_counters;
+    return true;
+  }
 }
 
 class VM_JVMCIResizeCounters : public VM_Operation {
  private:
   int _new_size;
+  bool _failed;
 
  public:
-  VM_JVMCIResizeCounters(int new_size) : _new_size(new_size) { }
+  VM_JVMCIResizeCounters(int new_size) : _new_size(new_size), _failed(false) { }
   VMOp_Type type()                  const        { return VMOp_JVMCIResizeCounters; }
   bool allow_nested_vm_operations() const        { return true; }
   void doit() {
     // Resize the old thread counters array
     jlong* new_counters = resize_counters_array(JavaThread::_jvmci_old_thread_counters, JVMCICounterSize, _new_size);
-    JavaThread::_jvmci_old_thread_counters = new_counters;
+    if (new_counters == NULL) {
+      _failed = true;
+      return;
+    } else {
+      JavaThread::_jvmci_old_thread_counters = new_counters;
+    }
 
     // Now resize each threads array
     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *tp = jtiwh.next(); ) {
-      tp->resize_counters(JVMCICounterSize, _new_size);
+      if (!tp->resize_counters(JVMCICounterSize, _new_size)) {
+        _failed = true;
+        break;
+      }
+    }
+    if (!_failed) {
+      JVMCICounterSize = _new_size;
     }
-    JVMCICounterSize = _new_size;
   }
+
+  bool failed() { return _failed; }
 };
 
-void JavaThread::resize_all_jvmci_counters(int new_size) {
+bool JavaThread::resize_all_jvmci_counters(int new_size) {
   VM_JVMCIResizeCounters op(new_size);
   VMThread::execute(&op);
+  return !op.failed();
 }
 
 #endif // INCLUDE_JVMCI
 
 // A JavaThread is a normal Java thread
@@ -3241,12 +3264,14 @@
 }
 
 
 void JavaThread::print_stack_on(outputStream* st) {
   if (!has_last_Java_frame()) return;
-  ResourceMark rm;
-  HandleMark   hm;
+
+  Thread* current_thread = Thread::current();
+  ResourceMark rm(current_thread);
+  HandleMark hm(current_thread);
 
   RegisterMap reg_map(this);
   vframe* start_vf = last_java_vframe(&reg_map);
   int count = 0;
   for (vframe* f = start_vf; f != NULL; f = f->sender()) {
@@ -3371,12 +3396,13 @@
 }
 
 
 void JavaThread::trace_stack() {
   if (!has_last_Java_frame()) return;
-  ResourceMark rm;
-  HandleMark   hm;
+  Thread* current_thread = Thread::current();
+  ResourceMark rm(current_thread);
+  HandleMark hm(current_thread);
   RegisterMap reg_map(this);
   trace_stack_from(last_java_vframe(&reg_map));
 }
 
 
@@ -3895,12 +3921,10 @@
   JFR_ONLY(Jfr::on_create_vm_1();)
 
   // Should be done after the heap is fully created
   main_thread->cache_global_variables();
 
-  HandleMark hm;
-
   { MutexLocker mu(Threads_lock);
     Threads::add(main_thread);
   }
 
   // Any JVMTI raw monitors entered in onload will transition into
@@ -3943,10 +3967,11 @@
   // This update must happen before we initialize the java classes, but
   // after any initialization logic that might modify the flags.
   Arguments::update_vm_info_property(VM_Version::vm_info_string());
 
   Thread* THREAD = Thread::current();
+  HandleMark hm(THREAD);
 
   // Always call even when there are not JVMTI environments yet, since environments
   // may be attached late and JVMTI must track phases of VM execution
   JvmtiExport::enter_early_start_phase();
 
diff a/src/hotspot/share/runtime/thread.hpp b/src/hotspot/share/runtime/thread.hpp
--- a/src/hotspot/share/runtime/thread.hpp
+++ b/src/hotspot/share/runtime/thread.hpp
@@ -1181,12 +1181,14 @@
   jlong*    _jvmci_counters;
 
  public:
   static jlong* _jvmci_old_thread_counters;
   static void collect_counters(jlong* array, int length);
-  void resize_counters(int current_size, int new_size);
-  static void resize_all_jvmci_counters(int new_size);
+
+  bool resize_counters(int current_size, int new_size);
+
+  static bool resize_all_jvmci_counters(int new_size);
 
  private:
 #endif // INCLUDE_JVMCI
 
   StackGuardState  _stack_guard_state;
diff a/src/hotspot/share/runtime/vframe.cpp b/src/hotspot/share/runtime/vframe.cpp
--- a/src/hotspot/share/runtime/vframe.cpp
+++ b/src/hotspot/share/runtime/vframe.cpp
@@ -516,11 +516,10 @@
 }
 
 
 void vframeStreamCommon::skip_prefixed_method_and_wrappers() {
   ResourceMark rm;
-  HandleMark hm;
 
   int    method_prefix_count = 0;
   char** method_prefixes = JvmtiExport::get_all_native_method_prefixes(&method_prefix_count);
   Klass* prefixed_klass = method()->method_holder();
   const char* prefixed_name = method()->name()->as_C_string();
@@ -625,12 +624,13 @@
   values->print();
 }
 
 
 void javaVFrame::print() {
-  ResourceMark rm;
-  HandleMark hm;
+  Thread* current_thread = Thread::current();
+  ResourceMark rm(current_thread);
+  HandleMark hm(current_thread);
 
   vframe::print();
   tty->print("\t");
   method()->print_value();
   tty->cr();
diff a/src/hotspot/share/runtime/vframeArray.cpp b/src/hotspot/share/runtime/vframeArray.cpp
--- a/src/hotspot/share/runtime/vframeArray.cpp
+++ b/src/hotspot/share/runtime/vframeArray.cpp
@@ -69,12 +69,14 @@
 #endif
 
   int index;
 
   {
-    ResourceMark rm;
-    HandleMark hm;
+    Thread* current_thread = Thread::current();
+    ResourceMark rm(current_thread);
+    HandleMark hm(current_thread);
+
     // Get the monitors off-stack
 
     GrowableArray<MonitorInfo*>* list = vf->monitors();
     if (list->is_empty()) {
       _monitors = NULL;
diff a/src/hotspot/share/runtime/vmOperations.hpp b/src/hotspot/share/runtime/vmOperations.hpp
--- a/src/hotspot/share/runtime/vmOperations.hpp
+++ b/src/hotspot/share/runtime/vmOperations.hpp
@@ -79,12 +79,10 @@
   template(UpdateForPopTopFrame)                  \
   template(SetFramePop)                           \
   template(GetObjectMonitorUsage)                 \
   template(GetAllStackTraces)                     \
   template(GetThreadListStackTraces)              \
-  template(GetFrameCount)                         \
-  template(GetFrameLocation)                      \
   template(ChangeBreakpoints)                     \
   template(GetOrSetLocal)                         \
   template(GetCurrentLocation)                    \
   template(ChangeSingleStep)                      \
   template(HeapWalkOperation)                     \
diff a/src/hotspot/share/services/attachListener.cpp b/src/hotspot/share/services/attachListener.cpp
--- a/src/hotspot/share/services/attachListener.cpp
+++ b/src/hotspot/share/services/attachListener.cpp
@@ -61,11 +61,11 @@
   return ik;
 }
 
 static jint get_properties(AttachOperation* op, outputStream* out, Symbol* serializePropertiesMethod) {
   Thread* THREAD = Thread::current();
-  HandleMark hm;
+  HandleMark hm(THREAD);
 
   // load VMSupport
   Symbol* klass = vmSymbols::jdk_internal_vm_VMSupport();
   InstanceKlass* k = load_and_initialize_klass(klass, THREAD);
   if (HAS_PENDING_EXCEPTION) {
diff a/src/hotspot/share/services/heapDumper.cpp b/src/hotspot/share/services/heapDumper.cpp
--- a/src/hotspot/share/services/heapDumper.cpp
+++ b/src/hotspot/share/services/heapDumper.cpp
@@ -828,11 +828,10 @@
   }
 }
 
 // returns the size of the instance of the given class
 u4 DumperSupport::instance_size(Klass* k) {
-  HandleMark hm;
   InstanceKlass* ik = InstanceKlass::cast(k);
   u4 size = 0;
 
   for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {
     if (!fld.access_flags().is_static()) {
@@ -841,11 +840,10 @@
   }
   return size;
 }
 
 u4 DumperSupport::get_static_fields_size(InstanceKlass* ik, u2& field_count) {
-  HandleMark hm;
   field_count = 0;
   u4 size = 0;
 
   for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {
     if (fldc.access_flags().is_static()) {
@@ -884,11 +882,10 @@
   return size + field_count * (sizeof(address) + 1);
 }
 
 // dumps static fields of the given class
 void DumperSupport::dump_static_fields(DumpWriter* writer, Klass* k) {
-  HandleMark hm;
   InstanceKlass* ik = InstanceKlass::cast(k);
 
   // dump the field descriptors and raw values
   for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {
     if (fld.access_flags().is_static()) {
@@ -928,11 +925,10 @@
   }
 }
 
 // dump the raw values of the instance fields of the given object
 void DumperSupport::dump_instance_fields(DumpWriter* writer, oop o) {
-  HandleMark hm;
   InstanceKlass* ik = InstanceKlass::cast(o->klass());
 
   for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {
     if (!fld.access_flags().is_static()) {
       Symbol* sig = fld.signature();
@@ -941,11 +937,10 @@
   }
 }
 
 // dumps the definition of the instance fields for a given class
 u2 DumperSupport::get_instance_fields_count(InstanceKlass* ik) {
-  HandleMark hm;
   u2 field_count = 0;
 
   for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {
     if (!fldc.access_flags().is_static()) field_count++;
   }
@@ -953,11 +948,10 @@
   return field_count;
 }
 
 // dumps the definition of the instance fields for a given class
 void DumperSupport::dump_instance_field_descriptors(DumpWriter* writer, Klass* k) {
-  HandleMark hm;
   InstanceKlass* ik = InstanceKlass::cast(k);
 
   // dump the field descriptors
   for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {
     if (!fld.access_flags().is_static()) {
@@ -1775,11 +1769,10 @@
 // records as we go. Once that is done we write records for some of the GC
 // roots.
 
 void VM_HeapDumper::doit() {
 
-  HandleMark hm;
   CollectedHeap* ch = Universe::heap();
 
   ch->ensure_parsability(false); // must happen, even if collection does
                                  // not happen (e.g. due to GCLocker)
 
diff a/src/hotspot/share/services/threadService.cpp b/src/hotspot/share/services/threadService.cpp
--- a/src/hotspot/share/services/threadService.cpp
+++ b/src/hotspot/share/services/threadService.cpp
@@ -564,12 +564,13 @@
   _method = jvf->method();
   _bci = jvf->bci();
   _class_holder = OopHandle(Universe::vm_global(), _method->method_holder()->klass_holder());
   _locked_monitors = NULL;
   if (with_lock_info) {
-    ResourceMark rm;
-    HandleMark hm;
+    Thread* current_thread = Thread::current();
+    ResourceMark rm(current_thread);
+    HandleMark hm(current_thread);
     GrowableArray<MonitorInfo*>* list = jvf->locked_monitors();
     int length = list->length();
     if (length > 0) {
       _locked_monitors = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<OopHandle>(length, mtServiceability);
       for (int i = 0; i < length; i++) {
diff a/src/hotspot/share/utilities/debug.cpp b/src/hotspot/share/utilities/debug.cpp
--- a/src/hotspot/share/utilities/debug.cpp
+++ b/src/hotspot/share/utilities/debug.cpp
@@ -353,12 +353,10 @@
 // flushes the logfile to prevent file sharing problems.
 
 class Command : public StackObj {
  private:
   ResourceMark rm;
-  ResetNoHandleMark rnhm;
-  HandleMark   hm;
   bool debug_save;
  public:
   static int level;
   Command(const char* str) {
     debug_save = Debugging;
diff a/src/java.base/linux/classes/jdk/internal/platform/CgroupMetrics.java b/src/java.base/linux/classes/jdk/internal/platform/CgroupMetrics.java
--- a/src/java.base/linux/classes/jdk/internal/platform/CgroupMetrics.java
+++ b/src/java.base/linux/classes/jdk/internal/platform/CgroupMetrics.java
@@ -158,9 +158,15 @@
     public long getBlkIOServiced() {
         return subsystem.getBlkIOServiced();
     }
 
     public static Metrics getInstance() {
+        if (!isUseContainerSupport()) {
+            // Return null on -XX:-UseContainerSupport
+            return null;
+        }
         return CgroupSubsystemFactory.create();
     }
 
-}
+    private static native boolean isUseContainerSupport();
+
+}
diff a/src/java.base/linux/native/libjava/CgroupMetrics.c b/src/java.base/linux/native/libjava/CgroupMetrics.c
--- /dev/null
+++ b/src/java.base/linux/native/libjava/CgroupMetrics.c
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2020, Red Hat, Inc.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "jni.h"
+#include "jvm.h"
+
+#include "jdk_internal_platform_CgroupMetrics.h"
+
+JNIEXPORT jboolean JNICALL
+Java_jdk_internal_platform_CgroupMetrics_isUseContainerSupport(JNIEnv *env, jclass ignored)
+{
+    return JVM_IsUseContainerSupport();
+}
diff a/src/java.base/macosx/native/launcher/Info-cmdline.plist b/src/java.base/macosx/native/launcher/Info-cmdline.plist
--- a/src/java.base/macosx/native/launcher/Info-cmdline.plist
+++ b/src/java.base/macosx/native/launcher/Info-cmdline.plist
@@ -1,14 +1,16 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
 <plist version="1.0">
 <dict>
         <key>CFBundleIdentifier</key>
-        <string>net.java.openjdk.cmd</string>
+        <string>@@ID@@</string>
         <key>CFBundleInfoDictionaryVersion</key>
         <string>6.0</string>
         <key>CFBundleShortVersionString</key>
         <string>1.0</string>
         <key>CFBundleVersion</key>
-        <string>1.0</string>
+        <string>@@VERSION@@</string>
+        <key>NSMicrophoneUsageDescription</key>
+        <string>The application is requesting access to the microphone.</string>
 </dict>
 </plist>
diff a/src/java.base/macosx/native/launcher/Info-privileged.plist b/src/java.base/macosx/native/launcher/Info-privileged.plist
--- a/src/java.base/macosx/native/launcher/Info-privileged.plist
+++ b/src/java.base/macosx/native/launcher/Info-privileged.plist
@@ -1,18 +1,18 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
 <plist version="1.0">
 <dict>
         <key>CFBundleIdentifier</key>
-        <string>net.java.openjdk.cmd</string>
+        <string>@@ID@@</string>
         <key>CFBundleInfoDictionaryVersion</key>
         <string>6.0</string>
         <key>CFBundleName</key>
         <string>OpenJDK Command</string>
         <key>CFBundleShortVersionString</key>
         <string>1.0</string>
         <key>CFBundleVersion</key>
-        <string>1.0</string>
+        <string>@@VERSION@@</string>
         <key>SecTaskAccess</key>
         <string>allowed</string>
 </dict>
 </plist>
diff a/src/java.base/share/classes/java/lang/ProcessHandleImpl.java b/src/java.base/share/classes/java/lang/ProcessHandleImpl.java
--- a/src/java.base/share/classes/java/lang/ProcessHandleImpl.java
+++ b/src/java.base/share/classes/java/lang/ProcessHandleImpl.java
@@ -34,10 +34,11 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadLocalRandom;
 import java.util.stream.IntStream;
 import java.util.stream.Stream;
 
 import static java.security.AccessController.doPrivileged;
 
@@ -81,10 +82,13 @@
     /**
      * The thread pool of "process reaper" daemon threads.
      */
     private static final Executor processReaperExecutor =
             doPrivileged((PrivilegedAction<Executor>) () -> {
+                // Initialize ThreadLocalRandom now to avoid using the smaller stack
+                // of the processReaper threads.
+                ThreadLocalRandom.current();
 
                 ThreadGroup tg = Thread.currentThread().getThreadGroup();
                 while (tg.getParent() != null) tg = tg.getParent();
                 ThreadGroup systemThreadGroup = tg;
 
diff a/src/java.base/share/classes/java/net/Authenticator.java b/src/java.base/share/classes/java/net/Authenticator.java
--- a/src/java.base/share/classes/java/net/Authenticator.java
+++ b/src/java.base/share/classes/java/net/Authenticator.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -72,10 +72,15 @@
     private String requestingScheme;
     private URL requestingURL;
     private RequestorType requestingAuthType;
     private final String key = AuthenticatorKeys.computeKey(this);
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public Authenticator() {}
+
     /**
      * The type of the entity requesting authentication.
      *
      * @since 1.5
      */
diff a/src/java.base/share/classes/java/net/CacheRequest.java b/src/java.base/share/classes/java/net/CacheRequest.java
--- a/src/java.base/share/classes/java/net/CacheRequest.java
+++ b/src/java.base/share/classes/java/net/CacheRequest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -41,10 +41,15 @@
  * @author Yingxian Wang
  * @since 1.5
  */
 public abstract class CacheRequest {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public CacheRequest() {}
+
     /**
      * Returns an OutputStream to which the response body can be
      * written.
      *
      * @return an OutputStream to which the response body can
diff a/src/java.base/share/classes/java/net/CacheResponse.java b/src/java.base/share/classes/java/net/CacheResponse.java
--- a/src/java.base/share/classes/java/net/CacheResponse.java
+++ b/src/java.base/share/classes/java/net/CacheResponse.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -39,10 +39,15 @@
  * @author Yingxian Wang
  * @since 1.5
  */
 public abstract class CacheResponse {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public CacheResponse() {}
+
     /**
      * Returns the response headers as a Map.
      *
      * @return An immutable Map from response header field names to
      *         lists of field values. The status line has null as its
diff a/src/java.base/share/classes/java/net/ContentHandler.java b/src/java.base/share/classes/java/net/ContentHandler.java
--- a/src/java.base/share/classes/java/net/ContentHandler.java
+++ b/src/java.base/share/classes/java/net/ContentHandler.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -81,10 +81,15 @@
  * @see     java.net.URLConnection#setContentHandlerFactory(java.net.ContentHandlerFactory)
  * @since   1.0
  */
 public abstract class ContentHandler {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public ContentHandler() {}
+
     /**
      * Given a URL connect stream positioned at the beginning of the
      * representation of an object, this method reads that stream and
      * creates an object from it.
      *
diff a/src/java.base/share/classes/java/net/CookieHandler.java b/src/java.base/share/classes/java/net/CookieHandler.java
--- a/src/java.base/share/classes/java/net/CookieHandler.java
+++ b/src/java.base/share/classes/java/net/CookieHandler.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -48,10 +48,15 @@
  *
  * @author Yingxian Wang
  * @since 1.5
  */
 public abstract class CookieHandler {
+    /**
+     * Constructor for subclasses to call.
+     */
+    public CookieHandler() {}
+
     /**
      * The system-wide cookie handler that will apply cookies to the
      * request headers and manage cookies from the response headers.
      *
      * @see setDefault(CookieHandler)
diff a/src/java.base/share/classes/java/net/DatagramSocketImpl.java b/src/java.base/share/classes/java/net/DatagramSocketImpl.java
--- a/src/java.base/share/classes/java/net/DatagramSocketImpl.java
+++ b/src/java.base/share/classes/java/net/DatagramSocketImpl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -55,10 +55,15 @@
  * @since  1.1
  */
 
 public abstract class DatagramSocketImpl implements SocketOptions {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public DatagramSocketImpl() {}
+
     /**
      * The local port number.
      */
     protected int localPort;
 
diff a/src/java.base/share/classes/java/net/ProxySelector.java b/src/java.base/share/classes/java/net/ProxySelector.java
--- a/src/java.base/share/classes/java/net/ProxySelector.java
+++ b/src/java.base/share/classes/java/net/ProxySelector.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -78,10 +78,15 @@
         } catch (Exception e) {
             theProxySelector = null;
         }
     }
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public ProxySelector() {}
+
     /**
      * Gets the system-wide proxy selector.
      *
      * @throws  SecurityException
      *          If a security manager has been installed and it denies
diff a/src/java.base/share/classes/java/net/ResponseCache.java b/src/java.base/share/classes/java/net/ResponseCache.java
--- a/src/java.base/share/classes/java/net/ResponseCache.java
+++ b/src/java.base/share/classes/java/net/ResponseCache.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -58,10 +58,15 @@
  * @author Yingxian Wang
  * @since 1.5
  */
 public abstract class ResponseCache {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public ResponseCache() {}
+
     /**
      * The system wide cache that provides access to a url
      * caching mechanism.
      *
      * @see #setDefault(ResponseCache)
diff a/src/java.base/share/classes/java/net/SecureCacheResponse.java b/src/java.base/share/classes/java/net/SecureCacheResponse.java
--- a/src/java.base/share/classes/java/net/SecureCacheResponse.java
+++ b/src/java.base/share/classes/java/net/SecureCacheResponse.java
@@ -37,10 +37,15 @@
  * means, such as TLS.
  *
  * @since 1.5
  */
 public abstract class SecureCacheResponse extends CacheResponse {
+    /**
+     * Constructor for subclasses to call.
+     */
+    public SecureCacheResponse() {}
+
     /**
      * Returns the cipher suite in use on the original connection that
      * retrieved the network resource.
      *
      * @return a string representing the cipher suite
diff a/src/java.base/share/classes/java/net/SocketAddress.java b/src/java.base/share/classes/java/net/SocketAddress.java
--- a/src/java.base/share/classes/java/net/SocketAddress.java
+++ b/src/java.base/share/classes/java/net/SocketAddress.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -41,6 +41,10 @@
 public abstract class SocketAddress implements java.io.Serializable {
 
     @java.io.Serial
     static final long serialVersionUID = 5215720748342549866L;
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public SocketAddress() {}
 }
diff a/src/java.base/share/classes/java/net/URLDecoder.java b/src/java.base/share/classes/java/net/URLDecoder.java
--- a/src/java.base/share/classes/java/net/URLDecoder.java
+++ b/src/java.base/share/classes/java/net/URLDecoder.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -79,10 +79,16 @@
  * @since   1.2
  */
 
 public class URLDecoder {
 
+    /**
+     * Do not call.
+     */
+    @Deprecated(since="16", forRemoval=true)
+    public URLDecoder() {}
+
     // The platform default encoding
     static String dfltEncName = URLEncoder.dfltEncName;
 
     /**
      * Decodes a {@code x-www-form-urlencoded} string.
diff a/src/java.base/share/classes/java/net/URLStreamHandler.java b/src/java.base/share/classes/java/net/URLStreamHandler.java
--- a/src/java.base/share/classes/java/net/URLStreamHandler.java
+++ b/src/java.base/share/classes/java/net/URLStreamHandler.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -49,10 +49,15 @@
  * @author  James Gosling
  * @see     java.net.URL#URL(java.lang.String, java.lang.String, int, java.lang.String)
  * @since   1.0
  */
 public abstract class URLStreamHandler {
+    /**
+     * Constructor for subclasses to call.
+     */
+    public URLStreamHandler() {}
+
     /**
      * Opens a connection to the object referenced by the
      * {@code URL} argument.
      * This method should be overridden by a subclass.
      *
diff a/src/java.base/share/classes/java/security/AlgorithmParameterGeneratorSpi.java b/src/java.base/share/classes/java/security/AlgorithmParameterGeneratorSpi.java
--- a/src/java.base/share/classes/java/security/AlgorithmParameterGeneratorSpi.java
+++ b/src/java.base/share/classes/java/security/AlgorithmParameterGeneratorSpi.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -58,10 +58,15 @@
  * @since 1.2
  */
 
 public abstract class AlgorithmParameterGeneratorSpi {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public AlgorithmParameterGeneratorSpi() {}
+
     /**
      * Initializes this parameter generator for a certain size
      * and source of randomness.
      *
      * @param size the size (number of bits).
diff a/src/java.base/share/classes/java/security/AlgorithmParametersSpi.java b/src/java.base/share/classes/java/security/AlgorithmParametersSpi.java
--- a/src/java.base/share/classes/java/security/AlgorithmParametersSpi.java
+++ b/src/java.base/share/classes/java/security/AlgorithmParametersSpi.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -48,10 +48,15 @@
  * @since 1.2
  */
 
 public abstract class AlgorithmParametersSpi {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public AlgorithmParametersSpi() {}
+
     /**
      * Initializes this parameters object using the parameters
      * specified in {@code paramSpec}.
      *
      * @param paramSpec the parameter specification.
diff a/src/java.base/share/classes/java/security/KeyFactorySpi.java b/src/java.base/share/classes/java/security/KeyFactorySpi.java
--- a/src/java.base/share/classes/java/security/KeyFactorySpi.java
+++ b/src/java.base/share/classes/java/security/KeyFactorySpi.java
@@ -67,10 +67,15 @@
  * @since 1.2
  */
 
 public abstract class KeyFactorySpi {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public KeyFactorySpi() {}
+
     /**
      * Generates a public key object from the provided key
      * specification (key material).
      *
      * @param keySpec the specification (key material) of the public key.
diff a/src/java.base/share/classes/java/security/KeyPairGeneratorSpi.java b/src/java.base/share/classes/java/security/KeyPairGeneratorSpi.java
--- a/src/java.base/share/classes/java/security/KeyPairGeneratorSpi.java
+++ b/src/java.base/share/classes/java/security/KeyPairGeneratorSpi.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -56,10 +56,15 @@
  * @see java.security.spec.AlgorithmParameterSpec
  */
 
 public abstract class KeyPairGeneratorSpi {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public KeyPairGeneratorSpi() {}
+
     /**
      * Initializes the key pair generator for a certain keysize, using
      * the default parameter set.
      *
      * @param keysize the keysize. This is an
diff a/src/java.base/share/classes/java/security/KeyStoreSpi.java b/src/java.base/share/classes/java/security/KeyStoreSpi.java
--- a/src/java.base/share/classes/java/security/KeyStoreSpi.java
+++ b/src/java.base/share/classes/java/security/KeyStoreSpi.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -51,10 +51,15 @@
  * @since 1.2
  */
 
 public abstract class KeyStoreSpi {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public KeyStoreSpi() {}
+
     /**
      * Returns the key associated with the given alias, using the given
      * password to recover it.  The key must have been associated with
      * the alias by a call to {@code setKeyEntry},
      * or by a call to {@code setEntry} with a
diff a/src/java.base/share/classes/java/security/MessageDigestSpi.java b/src/java.base/share/classes/java/security/MessageDigestSpi.java
--- a/src/java.base/share/classes/java/security/MessageDigestSpi.java
+++ b/src/java.base/share/classes/java/security/MessageDigestSpi.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -52,10 +52,15 @@
 public abstract class MessageDigestSpi {
 
     // for re-use in engineUpdate(ByteBuffer input)
     private byte[] tempArray;
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public MessageDigestSpi() {}
+
     /**
      * Returns the digest length in bytes.
      *
      * <p>This concrete method has been added to this previously-defined
      * abstract class. (For backwards compatibility, it cannot be abstract.)
diff a/src/java.base/share/classes/java/security/PermissionCollection.java b/src/java.base/share/classes/java/security/PermissionCollection.java
--- a/src/java.base/share/classes/java/security/PermissionCollection.java
+++ b/src/java.base/share/classes/java/security/PermissionCollection.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -100,10 +100,15 @@
     private static final long serialVersionUID = -6727011328946861783L;
 
     // when set, add will throw an exception.
     private volatile boolean readOnly;
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public PermissionCollection() {}
+
     /**
      * Adds a permission object to the current collection of permission objects.
      *
      * @param permission the Permission object to add.
      *
diff a/src/java.base/share/classes/java/security/Policy.java b/src/java.base/share/classes/java/security/Policy.java
--- a/src/java.base/share/classes/java/security/Policy.java
+++ b/src/java.base/share/classes/java/security/Policy.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -85,10 +85,15 @@
  * @see java.security.Security security properties
  */
 
 public abstract class Policy {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public Policy() {}
+
     /**
      * A read-only empty PermissionCollection instance.
      * @since 1.6
      */
     public static final PermissionCollection UNSUPPORTED_EMPTY_COLLECTION =
diff a/src/java.base/share/classes/java/security/PolicySpi.java b/src/java.base/share/classes/java/security/PolicySpi.java
--- a/src/java.base/share/classes/java/security/PolicySpi.java
+++ b/src/java.base/share/classes/java/security/PolicySpi.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -42,10 +42,15 @@
  * @since 1.6
  */
 
 public abstract class PolicySpi {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public PolicySpi() {}
+
     /**
      * Check whether the policy has granted a Permission to a ProtectionDomain.
      *
      * @param domain the ProtectionDomain to check.
      *
diff a/src/java.base/share/classes/java/security/SignatureSpi.java b/src/java.base/share/classes/java/security/SignatureSpi.java
--- a/src/java.base/share/classes/java/security/SignatureSpi.java
+++ b/src/java.base/share/classes/java/security/SignatureSpi.java
@@ -51,10 +51,15 @@
  */
 
 public abstract class SignatureSpi {
 
     /**
+     * Constructor for subclasses to call.
+     */
+    public SignatureSpi() {}
+
+    /**
      * Application-specified source of randomness.
      */
     protected SecureRandom appRandom = null;
 
     /**
diff a/src/java.base/share/classes/java/security/cert/CertificateFactorySpi.java b/src/java.base/share/classes/java/security/cert/CertificateFactorySpi.java
--- a/src/java.base/share/classes/java/security/cert/CertificateFactorySpi.java
+++ b/src/java.base/share/classes/java/security/cert/CertificateFactorySpi.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -63,10 +63,15 @@
  * @since 1.2
  */
 
 public abstract class CertificateFactorySpi {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public CertificateFactorySpi() {}
+
     /**
      * Generates a certificate object and initializes it with
      * the data read from the input stream {@code inStream}.
      *
      * <p>In order to take advantage of the specialized certificate format
diff a/src/java.base/share/classes/java/security/cert/X509CRLEntry.java b/src/java.base/share/classes/java/security/cert/X509CRLEntry.java
--- a/src/java.base/share/classes/java/security/cert/X509CRLEntry.java
+++ b/src/java.base/share/classes/java/security/cert/X509CRLEntry.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -65,10 +65,15 @@
  * @since 1.2
  */
 
 public abstract class X509CRLEntry implements X509Extension {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public X509CRLEntry() {}
+
     /**
      * Compares this CRL entry for equality with the given
      * object. If the {@code other} object is an
      * {@code instanceof} {@code X509CRLEntry}, then
      * its encoded form (the inner SEQUENCE) is retrieved and compared
diff a/src/java.base/share/classes/java/util/regex/Pattern.java b/src/java.base/share/classes/java/util/regex/Pattern.java
--- a/src/java.base/share/classes/java/util/regex/Pattern.java
+++ b/src/java.base/share/classes/java/util/regex/Pattern.java
@@ -1047,13 +1047,14 @@
      * Holds the length of the pattern string.
      */
     private transient int patternLength;
 
     /**
-     * If the Start node might possibly match supplementary characters.
+     * If the Start node might possibly match supplementary or surrogate
+     * code points.
      * It is set to true during compiling if
-     * (1) There is supplementary char in pattern, or
+     * (1) There is supplementary or surrogate code point in pattern, or
      * (2) There is complement node of a "family" CharProperty
      */
     private transient boolean hasSupplementary;
 
     /**
@@ -2946,12 +2947,14 @@
     private CharProperty newCharProperty(CharPredicate p) {
         if (p == null)
             return null;
         if (p instanceof BmpCharPredicate)
             return new BmpCharProperty((BmpCharPredicate)p);
-        else
+        else {
+            hasSupplementary = true;
             return new CharProperty(p);
+        }
     }
 
     /**
      * Parses and returns the name of a "named capturing group", the trailing
      * ">" is consumed after parsing.
@@ -5783,22 +5786,22 @@
     private static boolean inRange(int lower, int ch, int upper) {
         return lower <= ch && ch <= upper;
     }
 
     /**
-     * Charactrs within a explicit value range
+     * Characters within a explicit value range
      */
     static CharPredicate Range(int lower, int upper) {
         if (upper < Character.MIN_HIGH_SURROGATE ||
-            lower > Character.MAX_HIGH_SURROGATE &&
+            lower > Character.MAX_LOW_SURROGATE &&
             upper < Character.MIN_SUPPLEMENTARY_CODE_POINT)
             return (BmpCharPredicate)(ch -> inRange(lower, ch, upper));
         return ch -> inRange(lower, ch, upper);
     }
 
    /**
-    * Charactrs within a explicit value range in a case insensitive manner.
+    * Characters within a explicit value range in a case insensitive manner.
     */
     static CharPredicate CIRange(int lower, int upper) {
         return ch -> inRange(lower, ch, upper) ||
                      ASCII.isAscii(ch) &&
                      (inRange(lower, ASCII.toUpper(ch), upper) ||
diff a/src/java.base/share/classes/javax/crypto/CipherSpi.java b/src/java.base/share/classes/javax/crypto/CipherSpi.java
--- a/src/java.base/share/classes/javax/crypto/CipherSpi.java
+++ b/src/java.base/share/classes/javax/crypto/CipherSpi.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -227,10 +227,15 @@
  * @since 1.4
  */
 
 public abstract class CipherSpi {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public CipherSpi() {}
+
     /**
      * Sets the mode of this cipher.
      *
      * @param mode the cipher mode
      *
diff a/src/java.base/share/classes/javax/crypto/ExemptionMechanismSpi.java b/src/java.base/share/classes/javax/crypto/ExemptionMechanismSpi.java
--- a/src/java.base/share/classes/javax/crypto/ExemptionMechanismSpi.java
+++ b/src/java.base/share/classes/javax/crypto/ExemptionMechanismSpi.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -43,10 +43,15 @@
  * @since 1.4
  */
 
 public abstract class ExemptionMechanismSpi {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public ExemptionMechanismSpi() {}
+
     /**
      * Returns the length in bytes that an output buffer would need to be in
      * order to hold the result of the next
      * {@link #engineGenExemptionBlob(byte[], int) engineGenExemptionBlob}
      * operation, given the input length <code>inputLen</code> (in bytes).
diff a/src/java.base/share/classes/javax/crypto/KeyAgreementSpi.java b/src/java.base/share/classes/javax/crypto/KeyAgreementSpi.java
--- a/src/java.base/share/classes/javax/crypto/KeyAgreementSpi.java
+++ b/src/java.base/share/classes/javax/crypto/KeyAgreementSpi.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -60,10 +60,15 @@
  * @since 1.4
  */
 
 public abstract class KeyAgreementSpi {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public KeyAgreementSpi() {}
+
     /**
      * Initializes this key agreement with the given key and source of
      * randomness. The given key is required to contain all the algorithm
      * parameters required for this key agreement.
      *
diff a/src/java.base/share/classes/javax/crypto/KeyGeneratorSpi.java b/src/java.base/share/classes/javax/crypto/KeyGeneratorSpi.java
--- a/src/java.base/share/classes/javax/crypto/KeyGeneratorSpi.java
+++ b/src/java.base/share/classes/javax/crypto/KeyGeneratorSpi.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -53,10 +53,15 @@
  * @since 1.4
  */
 
 public abstract class KeyGeneratorSpi {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public KeyGeneratorSpi() {}
+
     /**
      * Initializes the key generator.
      *
      * @param random the source of randomness for this generator
      */
diff a/src/java.base/share/classes/javax/crypto/MacSpi.java b/src/java.base/share/classes/javax/crypto/MacSpi.java
--- a/src/java.base/share/classes/javax/crypto/MacSpi.java
+++ b/src/java.base/share/classes/javax/crypto/MacSpi.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -44,10 +44,15 @@
  * @since 1.4
  */
 
 public abstract class MacSpi {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public MacSpi() {}
+
     /**
      * Returns the length of the MAC in bytes.
      *
      * @return the MAC length in bytes.
      */
diff a/src/java.base/share/classes/javax/crypto/SecretKeyFactorySpi.java b/src/java.base/share/classes/javax/crypto/SecretKeyFactorySpi.java
--- a/src/java.base/share/classes/javax/crypto/SecretKeyFactorySpi.java
+++ b/src/java.base/share/classes/javax/crypto/SecretKeyFactorySpi.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -51,10 +51,15 @@
  * @since 1.4
  */
 
 public abstract class SecretKeyFactorySpi {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public SecretKeyFactorySpi() {}
+
     /**
      * Generates a <code>SecretKey</code> object from the
      * provided key specification (key material).
      *
      * @param keySpec the specification (key material) of the secret key
diff a/src/java.base/share/classes/javax/security/auth/login/ConfigurationSpi.java b/src/java.base/share/classes/javax/security/auth/login/ConfigurationSpi.java
--- a/src/java.base/share/classes/javax/security/auth/login/ConfigurationSpi.java
+++ b/src/java.base/share/classes/javax/security/auth/login/ConfigurationSpi.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -41,10 +41,15 @@
  *
  * @since 1.6
  */
 
 public abstract class ConfigurationSpi {
+    /**
+     * Constructor for subclasses to call.
+     */
+    public ConfigurationSpi() {}
+
     /**
      * Retrieve the AppConfigurationEntries for the specified {@code name}.
      *
      * @param name the name used to index the Configuration.
      *
diff a/src/java.base/share/classes/javax/security/cert/Certificate.java b/src/java.base/share/classes/javax/security/cert/Certificate.java
--- a/src/java.base/share/classes/javax/security/cert/Certificate.java
+++ b/src/java.base/share/classes/javax/security/cert/Certificate.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -63,10 +63,15 @@
  */
 @SuppressWarnings("removal")
 @Deprecated(since="9", forRemoval=true)
 public abstract class Certificate {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public Certificate() {}
+
     /**
      * Compares this certificate for equality with the specified
      * object. If the {@code other} object is an
      * {@code instanceof} {@code Certificate}, then
      * its encoded form is retrieved and compared with the
diff a/src/java.base/share/classes/javax/security/cert/X509Certificate.java b/src/java.base/share/classes/javax/security/cert/X509Certificate.java
--- a/src/java.base/share/classes/javax/security/cert/X509Certificate.java
+++ b/src/java.base/share/classes/javax/security/cert/X509Certificate.java
@@ -128,10 +128,15 @@
  */
 @SuppressWarnings("removal")
 @Deprecated(since="9", forRemoval=true)
 public abstract class X509Certificate extends Certificate {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public X509Certificate() {}
+
     /**
      * Constant to lookup in the Security properties file.
      * In the Security properties file the default implementation
      * for X.509 v3 is given as:
      * <pre>
diff a/src/java.base/share/classes/sun/security/ssl/KeyShareExtension.java b/src/java.base/share/classes/sun/security/ssl/KeyShareExtension.java
--- a/src/java.base/share/classes/sun/security/ssl/KeyShareExtension.java
+++ b/src/java.base/share/classes/sun/security/ssl/KeyShareExtension.java
@@ -29,16 +29,19 @@
 import java.nio.ByteBuffer;
 import java.security.GeneralSecurityException;
 import java.text.MessageFormat;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.EnumSet;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.ListIterator;
 import java.util.Locale;
 import java.util.Map;
 import javax.net.ssl.SSLProtocolException;
 import sun.security.ssl.KeyShareExtension.CHKeyShareSpec;
+import sun.security.ssl.NamedGroup.NamedGroupSpec;
 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 import sun.security.util.HexDumpEncoder;
@@ -246,37 +249,27 @@
                     }
                     return null;
                 }
             }
 
+            // Go through the named groups and take the most-preferred
+            // group from two categories (i.e. XDH and ECDHE).  Once we have
+            // the most preferred group from two types we can exit the loop.
             List<KeyShareEntry> keyShares = new LinkedList<>();
+            EnumSet<NamedGroupSpec> ngTypes =
+                    EnumSet.noneOf(NamedGroupSpec.class);
+            byte[] keyExchangeData;
             for (NamedGroup ng : namedGroups) {
-                SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
-                if (ke == null) {
-                    if (SSLLogger.isOn && SSLLogger.isOn("ssl,handshake")) {
-                        SSLLogger.warning(
-                            "No key exchange for named group " + ng.name);
-                    }
-                    continue;
-                }
-
-                SSLPossession[] poses = ke.createPossessions(chc);
-                for (SSLPossession pos : poses) {
-                    // update the context
-                    chc.handshakePossessions.add(pos);
-                    if (!(pos instanceof NamedGroupPossession)) {
-                        // May need more possesion types in the future.
-                        continue;
+                if (!ngTypes.contains(ng.spec)) {
+                    if ((keyExchangeData = getShare(chc, ng)) != null) {
+                        keyShares.add(new KeyShareEntry(ng.id,
+                                keyExchangeData));
+                        ngTypes.add(ng.spec);
+                        if (ngTypes.size() == 2) {
+                            break;
+                        }
                     }
-
-                    keyShares.add(new KeyShareEntry(ng.id, pos.encode()));
-                }
-
-                // One key share entry only.  Too much key share entries makes
-                // the ClientHello handshake message really big.
-                if (!keyShares.isEmpty()) {
-                    break;
                 }
             }
 
             int listLen = 0;
             for (KeyShareEntry entry : keyShares) {
@@ -293,10 +286,33 @@
             chc.handshakeExtensions.put(SSLExtension.CH_KEY_SHARE,
                     new CHKeyShareSpec(keyShares));
 
             return extData;
         }
+
+        private static byte[] getShare(ClientHandshakeContext chc,
+                NamedGroup ng) {
+            byte[] share = null;
+            SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
+            if (ke == null) {
+                if (SSLLogger.isOn && SSLLogger.isOn("ssl,handshake")) {
+                    SSLLogger.warning(
+                        "No key exchange for named group " + ng.name);
+                }
+            } else {
+                SSLPossession[] poses = ke.createPossessions(chc);
+                for (SSLPossession pos : poses) {
+                    // update the context
+                    chc.handshakePossessions.add(pos);
+                    // May need more possesion types in the future.
+                    if (pos instanceof NamedGroupPossession) {
+                        return pos.encode();
+                    }
+                }
+            }
+            return share;
+        }
     }
 
     /**
      * Network data consumer of the extension in a ClientHello
      * handshake message.
@@ -871,15 +887,37 @@
                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
                         "Unsupported HelloRetryRequest selected group: " +
                                 NamedGroup.nameOf(spec.selectedGroup));
             }
 
+            // The server-selected named group from a HelloRetryRequest must
+            // meet the following criteria:
+            // 1. It must be one of the named groups in the supported_groups
+            //    extension in the client hello.
+            // 2. It cannot be one of the groups in the key_share extension
+            //    from the client hello.
             if (!chc.clientRequestedNamedGroups.contains(serverGroup)) {
                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
                         "Unexpected HelloRetryRequest selected group: " +
                                 serverGroup.name);
             }
+            CHKeyShareSpec chKsSpec = (CHKeyShareSpec)
+                    chc.handshakeExtensions.get(SSLExtension.CH_KEY_SHARE);
+            if (chKsSpec != null) {
+                for (KeyShareEntry kse : chKsSpec.clientShares) {
+                    if (serverGroup.id == kse.namedGroupId) {
+                        throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
+                                "Illegal HelloRetryRequest selected group: " +
+                                        serverGroup.name);
+                    }
+                }
+            } else {
+                // Something has gone very wrong if we're here.
+                throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
+                        "Unable to retrieve ClientHello key_share extension " +
+                                "during HRR processing");
+            }
 
             // update the context
 
             // When sending the new ClientHello, the client MUST replace the
             // original "key_share" extension with one containing only a new
diff a/src/java.base/share/classes/sun/security/ssl/SSLLogger.java b/src/java.base/share/classes/sun/security/ssl/SSLLogger.java
--- a/src/java.base/share/classes/sun/security/ssl/SSLLogger.java
+++ b/src/java.base/share/classes/sun/security/ssl/SSLLogger.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -34,15 +34,17 @@
 import java.nio.ByteBuffer;
 import java.security.cert.Certificate;
 import java.security.cert.Extension;
 import java.security.cert.X509Certificate;
 import java.text.MessageFormat;
-import java.text.SimpleDateFormat;
-import java.util.Date;
+import java.time.Instant;
+import java.time.ZoneId;
+import java.time.format.DateTimeFormatter;
 import java.util.Locale;
 import java.util.Map;
 import java.util.ResourceBundle;
+
 import sun.security.action.GetPropertyAction;
 import sun.security.util.HexDumpEncoder;
 import sun.security.x509.*;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
@@ -252,17 +254,13 @@
             }
         }
     }
 
     private static class SSLSimpleFormatter {
-        private static final ThreadLocal<SimpleDateFormat> dateFormat =
-            new ThreadLocal<SimpleDateFormat>() {
-                @Override protected SimpleDateFormat initialValue() {
-                    return new SimpleDateFormat(
-                            "yyyy-MM-dd kk:mm:ss.SSS z", Locale.ENGLISH);
-                }
-            };
+        private static final String PATTERN = "yyyy-MM-dd kk:mm:ss.SSS z";
+        private static final DateTimeFormatter dateTimeFormat = DateTimeFormatter.ofPattern(PATTERN, Locale.ENGLISH)
+                                                                                 .withZone(ZoneId.systemDefault());
 
         private static final MessageFormat basicCertFormat = new MessageFormat(
                 "\"version\"            : \"v{0}\",\n" +
                 "\"serial number\"      : \"{1}\",\n" +
                 "\"signature algorithm\": \"{2}\",\n" +
@@ -355,11 +353,11 @@
                 Object[] messageFields = {
                     logger.loggerName,
                     level.getName(),
                     Utilities.toHexString(Thread.currentThread().getId()),
                     Thread.currentThread().getName(),
-                    dateFormat.get().format(new Date(System.currentTimeMillis())),
+                    dateTimeFormat.format(Instant.now()),
                     formatCaller(),
                     message
                 };
 
                 if (logger.useCompactFormat) {
@@ -372,11 +370,11 @@
             Object[] messageFields = {
                     logger.loggerName,
                     level.getName(),
                     Utilities.toHexString(Thread.currentThread().getId()),
                     Thread.currentThread().getName(),
-                    dateFormat.get().format(new Date(System.currentTimeMillis())),
+                    dateTimeFormat.format(Instant.now()),
                     formatCaller(),
                     message,
                     (logger.useCompactFormat ?
                         formatParameters(parameters) :
                         Utilities.indent(formatParameters(parameters)))
@@ -474,12 +472,12 @@
                         x509.getVersion(),
                         Utilities.toHexString(
                                 x509.getSerialNumber().toByteArray()),
                         x509.getSigAlgName(),
                         x509.getIssuerX500Principal().toString(),
-                        dateFormat.get().format(x509.getNotBefore()),
-                        dateFormat.get().format(x509.getNotAfter()),
+                        dateTimeFormat.format(x509.getNotBefore().toInstant()),
+                        dateTimeFormat.format(x509.getNotAfter().toInstant()),
                         x509.getSubjectX500Principal().toString(),
                         x509.getPublicKey().getAlgorithm()
                         };
                     builder.append(Utilities.indent(
                             basicCertFormat.format(certFields)));
@@ -499,12 +497,12 @@
                         x509.getVersion(),
                         Utilities.toHexString(
                                 x509.getSerialNumber().toByteArray()),
                         x509.getSigAlgName(),
                         x509.getIssuerX500Principal().toString(),
-                        dateFormat.get().format(x509.getNotBefore()),
-                        dateFormat.get().format(x509.getNotAfter()),
+                        dateTimeFormat.format(x509.getNotBefore().toInstant()),
+                        dateTimeFormat.format(x509.getNotAfter().toInstant()),
                         x509.getSubjectX500Principal().toString(),
                         x509.getPublicKey().getAlgorithm(),
                         Utilities.indent(extBuilder.toString())
                         };
                     builder.append(Utilities.indent(
diff a/src/java.base/share/man/java.1 b/src/java.base/share/man/java.1
--- a/src/java.base/share/man/java.1
+++ b/src/java.base/share/man/java.1
@@ -20,11 +20,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JAVA" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JAVA" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 java \- launch a Java application
 .SH SYNOPSIS
@@ -178,13 +178,14 @@
 .PP
 \f[B]Note:\f[R] The valid values of \f[I]N\f[R] change for each release,
 with new values added and old values removed.
 You\[aq]ll get an error message if you use a value of \f[I]N\f[R] that is
 no longer supported.
-Supported values of \f[I]N\f[R] for this release are \f[CB]7\f[R],
-\f[CB]8\f[R], \f[CB]9\f[R], \f[CB]10\f[R], \f[CB]11\f[R], \f[CB]12\f[R],
-\f[CB]13\f[R], and \f[CB]14\f[R].
+The supported values of \f[I]N\f[R] are the current Java SE release
+(\f[CB]15\f[R]) and a limited number of previous releases, detailed in the
+command\-line help for \f[CB]javac\f[R], under the \f[CB]\-\-source\f[R] and
+\f[CB]\-\-release\f[R] options.
 .RE
 .PP
 If the file does not have the \f[CB]\&.java\f[R] extension, the
 \f[CB]\-\-source\f[R] option must be used to tell the \f[CB]java\f[R]
 command to use the source\-file mode.
@@ -435,13 +436,13 @@
 Loads the specified native agent library.
 After the library name, a comma\-separated list of options specific to
 the library can be used.
 .RS
 .IP \[bu] 2
-\f[B]Oracle Solaris, Linux, and macOS:\f[R] If the option
-\f[CB]\-agentlib:foo\f[R] is specified, then the JVM attempts to load the
-library named \f[CB]libfoo.so\f[R] in the location specified by the
+\f[B]Linux and macOS:\f[R] If the option \f[CB]\-agentlib:foo\f[R] is
+specified, then the JVM attempts to load the library named
+\f[CB]libfoo.so\f[R] in the location specified by the
 \f[CB]LD_LIBRARY_PATH\f[R] system variable (on macOS this variable is
 \f[CB]DYLD_LIBRARY_PATH\f[R]).
 .IP \[bu] 2
 \f[B]Windows:\f[R] If the option \f[CB]\-agentlib:foo\f[R] is specified,
 then the JVM attempts to load the library named \f[CB]foo.dll\f[R] in the
@@ -782,12 +783,12 @@
 .B \f[CB]\-Xbootclasspath/a:\f[R]\f[I]directories\f[R]|\f[I]zip\f[R]|\f[I]JAR\-files\f[R]
 Specifies a list of directories, JAR files, and ZIP archives to append
 to the end of the default bootstrap class path.
 .RS
 .PP
-\f[B]Oracle Solaris, Linux, and macOS:\f[R] Colons (\f[CB]:\f[R]) separate
-entities in this list.
+\f[B]Linux and macOS:\f[R] Colons (\f[CB]:\f[R]) separate entities in this
+list.
 .PP
 \f[B]Windows:\f[R] Semicolons (\f[CB];\f[R]) separate entities in this
 list.
 .RE
 .TP
@@ -946,11 +947,11 @@
 Shutdown hooks enable the orderly shutdown of a Java application by
 running user cleanup code (such as closing database connections) at
 shutdown, even if the JVM terminates abruptly.
 .RS
 .IP \[bu] 2
-\f[B]Oracle Solaris, Linux, and macOS:\f[R]
+\f[B]Linux and macOS:\f[R]
 .RS 2
 .IP \[bu] 2
 The JVM catches signals to implement shutdown hooks for unexpected
 termination.
 The JVM uses \f[CB]SIGHUP\f[R], \f[CB]SIGINT\f[R], and \f[CB]SIGTERM\f[R] to
@@ -992,12 +993,12 @@
 \f[CB]CTRL_LOGOFF_EVENT\f[R], or \f[CB]CTRL_SHUTDOWN_EVENT\f[R].
 .RE
 .PP
 There are two consequences of specifying \f[CB]\-Xrs\f[R]:
 .IP \[bu] 2
-\f[B]Oracle Solaris, Linux, and macOS:\f[R] \f[CB]SIGQUIT\f[R] thread dumps
-aren\[aq]t available.
+\f[B]Linux and macOS:\f[R] \f[CB]SIGQUIT\f[R] thread dumps aren\[aq]t
+available.
 .IP \[bu] 2
 \f[B]Windows:\f[R] Ctrl + Break thread dumps aren\[aq]t available.
 .PP
 User code is responsible for causing shutdown hooks to run, for example,
 by calling the \f[CB]System.exit()\f[R] when the JVM is to be terminated.
@@ -1080,12 +1081,10 @@
 .IP \[bu] 2
 Linux/x64 (64\-bit): 1024 KB
 .IP \[bu] 2
 macOS (64\-bit): 1024 KB
 .IP \[bu] 2
-Oracle Solaris (64\-bit): 1024 KB
-.IP \[bu] 2
 Windows: The default value depends on virtual memory
 .PP
 The following examples set the thread stack size to 1024 KB in different
 units:
 .IP
@@ -1332,12 +1331,12 @@
 .RS
 .PP
 \f[CB]\-XX:ErrorFile=./hs_err_pid%p.log\f[R]
 .RE
 .IP \[bu] 2
-\f[B]Oracle Solaris, Linux, and macOS:\f[R] The following example shows
-how to set the error log to \f[CB]/var/log/java/java_error.log\f[R]:
+\f[B]Linux and macOS:\f[R] The following example shows how to set the
+error log to \f[CB]/var/log/java/java_error.log\f[R]:
 .RS 2
 .RS
 .PP
 \f[CB]\-XX:ErrorFile=/var/log/java/java_error.log\f[R]
 .RE
@@ -1355,12 +1354,11 @@
 If the file exists, and is writeable, then it will be overwritten.
 Otherwise, if the file can\[aq]t be created in the specified directory
 (due to insufficient space, permission problem, or another issue), then
 the file is created in the temporary directory for the operating system:
 .IP \[bu] 2
-\f[B]Oracle Solaris, Linux, and macOS:\f[R] The temporary directory is
-\f[CB]/tmp\f[R].
+\f[B]Linux and macOS:\f[R] The temporary directory is \f[CB]/tmp\f[R].
 .IP \[bu] 2
 \f[B]Windows:\f[R] The temporary directory is specified by the value of
 the \f[CB]TMP\f[R] environment variable; if that environment variable
 isn\[aq]t defined, then the value of the \f[CB]TEMP\f[R] environment
 variable is used.
@@ -1577,16 +1575,15 @@
 run when an irrecoverable error occurs.
 If the string contains spaces, then it must be enclosed in quotation
 marks.
 .RS
 .IP \[bu] 2
-\f[B]Oracle Solaris, Linux, and macOS:\f[R] The following example shows
-how the \f[CB]\-XX:OnError\f[R] option can be used to run the
-\f[CB]gcore\f[R] command to create a core image, and start the
-\f[CB]gdb\f[R] debugger to attach to the process in case of an
-irrecoverable error (the \f[CB]%p\f[R] designates the current process
-identifier):
+\f[B]Linux and macOS:\f[R] The following example shows how the
+\f[CB]\-XX:OnError\f[R] option can be used to run the \f[CB]gcore\f[R]
+command to create a core image, and start the \f[CB]gdb\f[R] debugger to
+attach to the process in case of an irrecoverable error (the \f[CB]%p\f[R]
+designates the current process identifier):
 .RS 2
 .RS
 .PP
 \f[CB]\-XX:OnError="gcore\ %p;gdb\ \-p\ %p"\f[R]
 .RE
@@ -1689,11 +1686,11 @@
 determine precisely which reference is \f[CB]null\f[R], and describes the
 source with a null\-detail message.
 The null\-detail message is calculated and returned by
 \f[CB]NullPointerException.getMessage()\f[R], and will be printed as the
 exception message along with the method, filename, and line number.
-By default, this option is disabled.
+By default, this option is enabled.
 .RS
 .RE
 .TP
 .B \f[CB]\-XX:+ShowMessageBoxOnError\f[R]
 Enables the display of a dialog box when the JVM experiences an
@@ -1837,12 +1834,10 @@
 .IP \[bu] 2
 Linux/x64 (64\-bit): 1024 KB
 .IP \[bu] 2
 macOS (64\-bit): 1024 KB
 .IP \[bu] 2
-Oracle Solaris (64\-bit): 1024 KB
-.IP \[bu] 2
 Windows: The default value depends on virtual memory
 .PP
 The following examples show how to set the thread stack size to 1
 megabyte in different units:
 .IP
@@ -1854,21 +1849,10 @@
 .fi
 .PP
 This option is similar to \f[CB]\-Xss\f[R].
 .RE
 .TP
-.B \f[CB]\-XX:\-UseBiasedLocking\f[R]
-Disables the use of biased locking.
-Some applications with significant amounts of uncontended
-synchronization may attain significant speedups with this flag enabled,
-but applications with certain patterns of locking may see slowdowns.
-\&.
-.RS
-.PP
-By default, this option is enabled.
-.RE
-.TP
 .B \f[CB]\-XX:\-UseCompressedOops\f[R]
 Disables the use of compressed pointers.
 By default, this option is enabled, and compressed pointers are used.
 This will automatically limit the maximum ergonomically determined Java
 heap size to the maximum amount of memory that can be covered by
@@ -2360,10 +2344,11 @@
 .RE
 .TP
 .B \f[CB]\-XX:InlineSmallCode=\f[R]\f[I]size\f[R]
 Sets the maximum code size (in bytes) for already compiled methods that
 may be inlined.
+This flag only applies to the C2 compiler.
 Append the letter \f[CB]k\f[R] or \f[CB]K\f[R] to indicate kilobytes,
 \f[CB]m\f[R] or \f[CB]M\f[R] to indicate megabytes, or \f[CB]g\f[R] or
 \f[CB]G\f[R] to indicate gigabytes.
 The default value depends on the platform and on whether tiered
 compilation is enabled.
@@ -2393,10 +2378,11 @@
 \f[CB]\-XX:+PrintCompilation\f[R] option.
 .RE
 .TP
 .B \f[CB]\-XX:FreqInlineSize=\f[R]\f[I]size\f[R]
 Sets the maximum bytecode size (in bytes) of a hot method to be inlined.
+This flag only applies to the C2 compiler.
 Append the letter \f[CB]k\f[R] or \f[CB]K\f[R] to indicate kilobytes,
 \f[CB]m\f[R] or \f[CB]M\f[R] to indicate megabytes, or \f[CB]g\f[R] or
 \f[CB]G\f[R] to indicate gigabytes.
 The default value depends on the platform.
 In the following example it is set to 325 bytes:
@@ -2408,10 +2394,26 @@
 .RE
 .TP
 .B \f[CB]\-XX:MaxInlineSize=\f[R]\f[I]size\f[R]
 Sets the maximum bytecode size (in bytes) of a cold method to be
 inlined.
+This flag only applies to the C2 compiler.
+Append the letter \f[CB]k\f[R] or \f[CB]K\f[R] to indicate kilobytes,
+\f[CB]m\f[R] or \f[CB]M\f[R] to indicate megabytes, or \f[CB]g\f[R] or
+\f[CB]G\f[R] to indicate gigabytes.
+By default, the maximum bytecode size is set to 35 bytes:
+.RS
+.RS
+.PP
+\f[CB]\-XX:MaxInlineSize=35\f[R]
+.RE
+.RE
+.TP
+.B \f[CB]\-XX:C1MaxInlineSize=\f[R]\f[I]size\f[R]
+Sets the maximum bytecode size (in bytes) of a cold method to be
+inlined.
+This flag only applies to the C1 compiler.
 Append the letter \f[CB]k\f[R] or \f[CB]K\f[R] to indicate kilobytes,
 \f[CB]m\f[R] or \f[CB]M\f[R] to indicate megabytes, or \f[CB]g\f[R] or
 \f[CB]G\f[R] to indicate gigabytes.
 By default, the maximum bytecode size is set to 35 bytes:
 .RS
@@ -2422,10 +2424,27 @@
 .RE
 .TP
 .B \f[CB]\-XX:MaxTrivialSize=\f[R]\f[I]size\f[R]
 Sets the maximum bytecode size (in bytes) of a trivial method to be
 inlined.
+This flag only applies to the C2 compiler.
+Append the letter \f[CB]k\f[R] or \f[CB]K\f[R] to indicate kilobytes,
+\f[CB]m\f[R] or \f[CB]M\f[R] to indicate megabytes, or \f[CB]g\f[R] or
+\f[CB]G\f[R] to indicate gigabytes.
+By default, the maximum bytecode size of a trivial method is set to 6
+bytes:
+.RS
+.RS
+.PP
+\f[CB]\-XX:MaxTrivialSize=6\f[R]
+.RE
+.RE
+.TP
+.B \f[CB]\-XX:C1MaxTrivialSize=\f[R]\f[I]size\f[R]
+Sets the maximum bytecode size (in bytes) of a trivial method to be
+inlined.
+This flag only applies to the C1 compiler.
 Append the letter \f[CB]k\f[R] or \f[CB]K\f[R] to indicate kilobytes,
 \f[CB]m\f[R] or \f[CB]M\f[R] to indicate megabytes, or \f[CB]g\f[R] or
 \f[CB]G\f[R] to indicate gigabytes.
 By default, the maximum bytecode size of a trivial method is set to 6
 bytes:
@@ -2673,11 +2692,11 @@
 .RS
 .RE
 .TP
 .B \f[CB]\-XX:+UseSHA\f[R]
 Enables hardware\-based intrinsics for SHA crypto hash functions for
-SPARC hardware.
+some hardware.
 The \f[CB]UseSHA\f[R] option is used in conjunction with the
 \f[CB]UseSHA1Intrinsics\f[R], \f[CB]UseSHA256Intrinsics\f[R], and
 \f[CB]UseSHA512Intrinsics\f[R] options.
 .RS
 .PP
@@ -2815,11 +2834,11 @@
 .RS
 .RE
 .TP
 .B \f[CB]\-XX:+UseFMA\f[R]
 Enables hardware\-based FMA intrinsics for hardware where FMA
-instructions are available (such as, Intel, SPARC, and ARM64).
+instructions are available (such as, Intel and ARM64).
 FMA intrinsics are generated for the
 \f[CB]java.lang.Math.fma(\f[R]\f[I]a\f[R]\f[CB],\f[R] \f[I]b\f[R]\f[CB],\f[R]
 \f[I]c\f[R]\f[CB])\f[R] methods that calculate the value of \f[CB](\f[R]
 \f[I]a\f[R] \f[CB]*\f[R] \f[I]b\f[R] \f[CB]+\f[R] \f[I]c\f[R] \f[CB])\f[R]
 expressions.
@@ -2914,12 +2933,12 @@
 different JDK version.
 .RE
 .RE
 .TP
 .B \f[CB]\-XX:+ExtendedDTraceProbes\f[R]
-\f[B]Oracle Solaris, Linux, and macOS:\f[R] Enables additional
-\f[CB]dtrace\f[R] tool probes that affect the performance.
+\f[B]Linux and macOS:\f[R] Enables additional \f[CB]dtrace\f[R] tool probes
+that affect the performance.
 By default, this option is disabled and \f[CB]dtrace\f[R] performs only
 standard probes.
 .RS
 .RE
 .TP
@@ -2947,13 +2966,12 @@
 .RS
 .PP
 \f[CB]\-XX:HeapDumpPath=./java_pid%p.hprof\f[R]
 .RE
 .IP \[bu] 2
-\f[B]Oracle Solaris, Linux, and macOS:\f[R] The following example shows
-how to set the heap dump file to
-\f[CB]/var/log/java/java_heapdump.hprof\f[R]:
+\f[B]Linux and macOS:\f[R] The following example shows how to set the
+heap dump file to \f[CB]/var/log/java/java_heapdump.hprof\f[R]:
 .RS 2
 .RS
 .PP
 \f[CB]\-XX:HeapDumpPath=/var/log/java/java_heapdump.hprof\f[R]
 .RE
@@ -2973,12 +2991,12 @@
 Sets the path and file name to where log data is written.
 By default, the file is created in the current working directory, and
 it\[aq]s named \f[CB]hotspot.log\f[R].
 .RS
 .IP \[bu] 2
-\f[B]Oracle Solaris, Linux, and macOS:\f[R] The following example shows
-how to set the log file to \f[CB]/var/log/java/hotspot.log\f[R]:
+\f[B]Linux and macOS:\f[R] The following example shows how to set the log
+file to \f[CB]/var/log/java/hotspot.log\f[R]:
 .RS 2
 .RS
 .PP
 \f[CB]\-XX:LogFile=/var/log/java/hotspot.log\f[R]
 .RE
@@ -2997,11 +3015,11 @@
 .B \f[CB]\-XX:+PrintClassHistogram\f[R]
 Enables printing of a class instance histogram after one of the
 following events:
 .RS
 .IP \[bu] 2
-\f[B]Oracle Solaris, Linux, and macOS:\f[R] \f[CB]Control+Break\f[R]
+\f[B]Linux and macOS:\f[R] \f[CB]Control+Break\f[R]
 .IP \[bu] 2
 \f[B]Windows:\f[R] \f[CB]Control+C\f[R] (\f[CB]SIGTERM\f[R])
 .PP
 By default, this option is disabled.
 .PP
@@ -3013,11 +3031,11 @@
 .B \f[CB]\-XX:+PrintConcurrentLocks\f[R]
 Enables printing of \f[CB]java.util.concurrent\f[R] locks after one of the
 following events:
 .RS
 .IP \[bu] 2
-\f[B]Oracle Solaris, Linux, and macOS:\f[R] \f[CB]Control+Break\f[R]
+\f[B]Linux and macOS:\f[R] \f[CB]Control+Break\f[R]
 .IP \[bu] 2
 \f[B]Windows:\f[R] \f[CB]Control+C\f[R] (\f[CB]SIGTERM\f[R])
 .PP
 By default, this option is disabled.
 .PP
@@ -3276,17 +3294,15 @@
 .RE
 .RE
 .TP
 .B \f[CB]\-XX:InitialSurvivorRatio=\f[R]\f[I]ratio\f[R]
 Sets the initial survivor space ratio used by the throughput garbage
-collector (which is enabled by the \f[CB]\-XX:+UseParallelGC\f[R] and/or
-\f[CB]\-XX:+UseParallelOldGC\f[R] options).
+collector (which is enabled by the \f[CB]\-XX:+UseParallelGC\f[R] option).
 Adaptive sizing is enabled by default with the throughput garbage
-collector by using the \f[CB]\-XX:+UseParallelGC\f[R] and
-\f[CB]\-XX:+UseParallelOldGC\f[R] options, and the survivor space is
-resized according to the application behavior, starting with the initial
-value.
+collector by using the \f[CB]\-XX:+UseParallelGC\f[R] option, and the
+survivor space is resized according to the application behavior,
+starting with the initial value.
 If adaptive sizing is disabled (using the
 \f[CB]\-XX:\-UseAdaptiveSizePolicy\f[R] option), then the
 \f[CB]\-XX:SurvivorRatio\f[R] option should be used to set the size of the
 survivor space for the entire execution of the application.
 .RS
@@ -3809,12 +3825,10 @@
 as the throughput collector) to improve the performance of your
 application by leveraging multiple processors.
 .RS
 .PP
 By default, this option is disabled and the default collector is used.
-If it\[aq]s enabled, then the \f[CB]\-XX:+UseParallelOldGC\f[R] option is
-automatically enabled, unless you explicitly disable it.
 .RE
 .TP
 .B \f[CB]\-XX:+UseSerialGC\f[R]
 Enables the use of the serial garbage collector.
 This is generally the best choice for small and simple applications that
@@ -3853,23 +3867,70 @@
 To disable the use of TLABs, specify the option \f[CB]\-XX:\-UseTLAB\f[R].
 .RS
 .RE
 .TP
 .B \f[CB]\-XX:+UseZGC\f[R]
-Enables the use of the Z garbage collector.
-This garbage collector is best for providing lowest latency with large
-Java heaps at some throughput cost.
-This is an experimental garbage collector, you need to specify
-\f[CB]\-XX:+UnlockExperimentalVMOptions\f[R] before \f[CB]\-XX:+UseZGC\f[R]
-on the command line.
+Enables the use of the Z garbage collector (ZGC).
+This is a low latency garbage collector, providing max pause times of a
+few milliseconds, at some throughput cost.
+Pause times are independent of what heap size is used.
+Supports heap sizes from 8MB to 16TB.
 .RS
-.PP
-Example:
+.RE
+.TP
+.B \f[CB]\-XX:ZAllocationSpikeTolerance\f[R]=\f[I]factor\f[R]
+Sets the allocation spike tolerance for ZGC.
+By default, this option is set to 2.0.
+This factor describes the level of allocation spikes to expect.
+For example, using a factor of 3.0 means the current allocation rate can
+be expected to triple at any time.
+.RS
+.RE
+.TP
+.B \f[CB]\-XX:ZCollectionInterval\f[R]=\f[I]seconds\f[R]
+Sets the maximum interval (in seconds) between two GC cycles when using
+ZGC.
+By default, this option is set to 0 (disabled).
+.RS
+.RE
+.TP
+.B \f[CB]\-XX:ZFragmentationLimit\f[R]=\f[I]percent\f[R]
+Sets the maximum acceptable heap fragmentation (in percent) for ZGC.
+By default, this option is set to 25.
+Using a lower value will cause the heap to be compacted more
+aggressively, to reclaim more memory at the cost of using more CPU time.
+.RS
+.RE
+.TP
+.B \f[CB]\-XX:+ZProactive\f[R]
+Enables proactive GC cycles when using ZGC.
+By default, this option is enabled.
+ZGC will start a proactive GC cycle if doing so is expected to have
+minimal impact on the running application.
+This is useful if the application is mostly idle or allocates very few
+objects, but you still want to keep the heap size down and allow
+reference processing to happen even when there are a lot of free space
+on the heap.
+.RS
+.RE
+.TP
+.B \f[CB]\-XX:+ZUncommit\f[R]
+Enables uncommitting of unused heap memory when using ZGC.
+By default, this option is enabled.
+Uncommitting unused heap memory will lower the memory footprint of the
+JVM, and make that memory available for other processes to use.
 .RS
-.PP
-\f[CB]\-XX:+UnlockExperimentalVMOptions\ \-XX:+UseZGC\f[R]
 .RE
+.TP
+.B \f[CB]\-XX:ZUncommitDelay\f[R]=\f[I]seconds\f[R]
+Sets the amount of time (in seconds) that heap memory must have been
+unused before being uncommitted.
+By default, this option is set to 300 (5 minutes).
+Committing and uncommitting memory are relatively expensive operations.
+Using a lower value will cause heap memory to be uncommitted earlier, at
+the risk of soon having to commit it again.
+.RS
 .RE
 .SH DEPRECATED JAVA OPTIONS
 .PP
 These \f[CB]java\f[R] options are deprecated and might be removed in a
 future JDK release.
@@ -3991,31 +4052,24 @@
 The replacement Unified Logging syntax is
 \f[CB]\-Xlog:class+loader+constraints=info\f[R].
 See \f[B]Enable Logging with the JVM Unified Logging Framework\f[R].
 .RE
 .TP
-.B \f[CB]\-XX:+UseParallelOldGC\f[R]
-Enables the use of the parallel garbage collector for full GCs.
-By default, this option is disabled.
-Enabling it automatically enables the \f[CB]\-XX:+UseParallelGC\f[R]
-option.
+.B \f[CB]\-XX:+UseBiasedLocking\f[R]
+Enables the use of biased locking.
+Some applications with significant amounts of uncontended
+synchronization may attain significant speedups with this flag enabled,
+but applications with certain patterns of locking may see slowdowns.
 .RS
+.PP
+By default, this option is disabled.
 .RE
 .SH OBSOLETE JAVA OPTIONS
 .PP
 These \f[CB]java\f[R] options are still accepted but ignored, and a
 warning is issued when they\[aq]re used.
 .TP
-.B \f[CB]\-XX:+FailOverToOldVerifier\f[R]
-Enables automatic failover to the old verifier when the new type checker
-fails.
-By default, this option is disabled and it\[aq]s ignored (that is,
-treated as disabled) for classes with a recent bytecode version.
-You can enable it only for classes with older versions of the bytecode.
-.RS
-.RE
-.TP
 .B \f[CB]\-XX:+UseMembar\f[R]
 Enabled issuing membars on thread\-state transitions.
 This option was disabled by default on all platforms except ARM servers,
 where it was enabled.
 .RS
@@ -4033,17 +4087,52 @@
 triggers a garbage collection if it\[aq]s exceeded.
 This option was deprecated in JDK 8 and superseded by the
 \f[CB]\-XX:MetaspaceSize\f[R] option.
 .RS
 .RE
+.TP
+.B \f[CB]\-XX:+UseParallelOldGC\f[R]
+Enables the use of the parallel garbage collector for full GCs.
+By default, this option is disabled.
+Enabling it automatically enables the \f[CB]\-XX:+UseParallelGC\f[R]
+option.
+.RS
+.RE
 .SH REMOVED JAVA OPTIONS
 .PP
-No documented \f[CB]java\f[R] options have been removed in JDK 14.
+These \f[CB]java\f[R] options have been removed in JDK 15 and using them
+results in an error of:
+.RS
+.PP
+\f[CB]Unrecognized\ VM\ option\f[R] \f[I]option\-name\f[R]
+.RE
+.TP
+.B \f[CB]\-XX:+FailOverToOldVerifier\f[R]
+Enables automatic failover to the old verifier when the new type checker
+fails.
+By default, this option is disabled and it\[aq]s ignored (that is,
+treated as disabled) for classes with a recent bytecode version.
+You can enable it only for classes with older versions of the bytecode.
+.RS
+.RE
+.TP
+.B \f[CB]\-XX:+UseConcMarkSweepGC\f[R]
+Enables the use of the CMS garbage collector for the old generation.
+CMS is an alternative to the default garbage collector (G1), which also
+focuses on meeting application latency requirements.
+By default, this option is disabled and the collector is selected
+automatically based on the configuration of the machine and type of the
+JVM.
+.RS
+.RE
 .PP
 For the lists and descriptions of options removed in previous releases
 see the \f[I]Removed Java Options\f[R] section in:
 .IP \[bu] 2
+\f[B]Java Platform, Standard Edition Tools Reference, Release 14\f[R]
+[https://docs.oracle.com/en/java/javase/14/docs/specs/man/java.html]
+.IP \[bu] 2
 \f[B]Java Platform, Standard Edition Tools Reference, Release 13\f[R]
 [https://docs.oracle.com/en/java/javase/13/docs/specs/man/java.html]
 .IP \[bu] 2
 \f[B]Java Platform, Standard Edition Tools Reference, Release 12\f[R]
 [https://docs.oracle.com/en/java/javase/12/tools/java.html#GUID\-3B1CE181\-CD30\-4178\-9602\-230B800D4FAE]
@@ -5058,15 +5147,11 @@
 Also, a system that has been up for a long time could produce excessive
 fragmentation, which could make it impossible to reserve enough large
 page memory.
 When this happens, either the OS or JVM reverts to using regular pages.
 .PP
-Oracle Solaris, Linux, and Windows support large pages.
-.SS Large Pages Support for Oracle Solaris
-.PP
-Oracle Solaris includes Multiple Page Size Support (MPSS).
-No additional configuration is necessary.
+Linux and Windows support large pages.
 .SS Large Pages Support for Linux
 .PP
 The 2.6 kernel supports large pages.
 Some vendors have backported the code to their 2.4\-based releases.
 To check if your system can support large page memory, try the
@@ -5621,13 +5706,13 @@
 .IP "2." 3
 Create a single list of classes used by all the applications that will
 share the shared archive file.
 .RS 4
 .PP
-\f[B]Oracle Solaris, Linux, and macOS\f[R] The following commands combine
-the files \f[CB]hello.classlist\f[R] and \f[CB]hi.classlist\f[R] into one
-file, \f[CB]common.classlist\f[R]:
+\f[B]Linux and macOS\f[R] The following commands combine the files
+\f[CB]hello.classlist\f[R] and \f[CB]hi.classlist\f[R] into one file,
+\f[CB]common.classlist\f[R]:
 .RS
 .PP
 \f[CB]cat\ hello.classlist\ hi.classlist\ >\ common.classlist\f[R]
 .RE
 .PP
diff a/src/java.base/share/man/jfr.1 b/src/java.base/share/man/jfr.1
--- a/src/java.base/share/man/jfr.1
+++ b/src/java.base/share/man/jfr.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JFR" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JFR" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jfr \- parse and print Flight Recorder files
 .SH SYNOPSIS
diff a/src/java.base/share/man/keytool.1 b/src/java.base/share/man/keytool.1
--- a/src/java.base/share/man/keytool.1
+++ b/src/java.base/share/man/keytool.1
@@ -1,7 +1,7 @@
 .\"t
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -20,11 +20,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "KEYTOOL" "1" "2020" "JDK 14" "JDK Commands"
+.TH "KEYTOOL" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 keytool \- a key and certificate management utility
 .SH SYNOPSIS
@@ -99,10 +99,20 @@
 Encryption Standard).
 It can also display other security\-related information.
 .PP
 The \f[CB]keytool\f[R] command stores the keys and certificates in a
 keystore.
+.PP
+The \f[CB]keytool\f[R] command uses the
+\f[CB]jdk.certpath.disabledAlgorithms\f[R] and
+\f[CB]jdk.security.legacyAlgorithms\f[R] security properties to determine
+which algorithms are considered a security risk.
+It emits warnings when disabled or legacy algorithms are being used.
+The \f[CB]jdk.certpath.disabledAlgorithms\f[R] and
+\f[CB]jdk.security.legacyAlgorithms\f[R] security properties are defined
+in the \f[CB]java.security\f[R] file (located in the JDK\[aq]s
+\f[CB]$JAVA_HOME/conf/security\f[R] directory).
 .SH COMMAND AND OPTION NOTES
 .PP
 The following notes apply to the descriptions in \f[B]Commands and
 Options\f[R]:
 .IP \[bu] 2
@@ -258,16 +268,14 @@
 \f[CB]keytool\ \-addprovider\ SunPKCS11\ \-providerarg\ some.cfg\ ...\f[R]
 .RE
 .PP
 \f[B]Note:\f[R]
 .PP
-For compatibility reasons, the SunPKCS11 and OracleUcrypto providers can
-still be loaded with
-\f[CB]\-providerclass\ sun.security.pkcs11.SunPKCS11\f[R] and
-\f[CB]\-providerclass\ com.oracle.security.crypto.UcryptoProvider\f[R]
-even if they are now defined in modules.
-These are the only modules included in JDK that need a configuration,
+For compatibility reasons, the SunPKCS11 provider can still be loaded
+with \f[CB]\-providerclass\ sun.security.pkcs11.SunPKCS11\f[R] even if it
+is now defined in a module.
+This is the only module included in the JDK that needs a configuration,
 and therefore the most widely used with the \f[CB]\-providerclass\f[R]
 option.
 For legacy security providers located on classpath and loaded by
 reflection, \f[CB]\-providerclass\f[R] should still be used.
 .RE
@@ -2197,12 +2205,11 @@
 \f[CB]keystore.type\f[R] property specified in the security properties
 file.
 The security properties file is called \f[CB]java.security\f[R], and
 resides in the security properties directory:
 .IP \[bu] 2
-\f[B]Oracle Solaris, Linux, and OS X:\f[R]
-\f[CB]java.home/lib/security\f[R]
+\f[B]Linux and OS X:\f[R] \f[CB]java.home/lib/security\f[R]
 .IP \[bu] 2
 \f[B]Windows:\f[R] \f[CB]java.home\\lib\\security\f[R]
 .PP
 Each tool gets the \f[CB]keystore.type\f[R] value and then examines all
 the currently installed providers until it finds one that implements a
@@ -2475,28 +2482,23 @@
 .B cacerts Certificates File
 A certificates file named \f[CB]cacerts\f[R] resides in the security
 properties directory:
 .RS
 .IP \[bu] 2
-\f[B]Oracle Solaris, Linux, and OS X:\f[R]
-\f[I]JAVA_HOME\f[R]\f[CB]/lib/security\f[R]
+\f[B]Linux and OS X:\f[R] \f[I]JAVA_HOME\f[R]\f[CB]/lib/security\f[R]
 .IP \[bu] 2
 \f[B]Windows:\f[R] \f[I]JAVA_HOME\f[R]\f[CB]\\lib\\security\f[R]
 .PP
-\f[I]JAVA_HOME\f[R] is the runtime environment directory, which is the
-\f[CB]jre\f[R] directory in the JDK or the top\-level directory of the
-Java Runtime Environment (JRE).
-.PP
 The \f[CB]cacerts\f[R] file represents a system\-wide keystore with CA
 certificates.
 System administrators can configure and manage that file with the
 \f[CB]keytool\f[R] command by specifying \f[CB]jks\f[R] as the keystore
 type.
 The \f[CB]cacerts\f[R] keystore file ships with a default set of root CA
 certificates.
-For Oracle Solaris, Linux, OS X, and Windows, you can list the default
-certificates with the following command:
+For Linux, OS X, and Windows, you can list the default certificates with
+the following command:
 .RS
 .PP
 \f[CB]keytool\ \-list\ \-cacerts\f[R]
 .RE
 .PP
@@ -2516,14 +2518,14 @@
 It is your responsibility to verify the trusted root CA certificates
 bundled in the \f[CB]cacerts\f[R] file and make your own trust decisions.
 .PP
 To remove an untrusted CA certificate from the \f[CB]cacerts\f[R] file,
 use the \f[CB]\-delete\f[R] option of the \f[CB]keytool\f[R] command.
-You can find the \f[CB]cacerts\f[R] file in the JRE installation
-directory.
+You can find the \f[CB]cacerts\f[R] file in the JDK\[aq]s
+\f[CB]$JAVA_HOME/lib/security\f[R] directory.
 Contact your system administrator if you don\[aq]t have permission to
-edit this file
+edit this file.
 .RE
 .TP
 .B Internet RFC 1421 Certificate Encoding Standard
 Certificates are often stored using the printable encoding format
 defined by the Internet RFC 1421 standard, instead of their binary
@@ -2670,11 +2672,11 @@
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ SHA\-256:\ 90:7B:70:0A:EA:DC:16:79:92:99:41:FF:8A:FE:EB:90:
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 17:75:E0:90:B2:24:4D:3A:2A:16:A6:E4:11:0F:67:A4
 \f[R]
 .fi
 .PP
-\f[B]Oracle Solaris Example:\f[R]
+\f[B]Linux Example:\f[R]
 .PP
 View the certificate first with the \f[CB]\-printcert\f[R] command or the
 \f[CB]\-importcert\f[R] command without the \f[CB]\-noprompt\f[R] option.
 Ensure that the displayed certificate fingerprints match the expected
 ones.
@@ -2741,11 +2743,11 @@
 The \f[CB]keytool\f[R] command doesn\[aq]t enforce all of these rules so
 it can generate certificates that don\[aq]t conform to the standard,
 such as self\-signed certificates that would be used for internal
 testing purposes.
 Certificates that don\[aq]t conform to the standard might be rejected by
-JRE or other applications.
+the JDK or other applications.
 Users should ensure that they provide the correct options for
 \f[CB]\-dname\f[R], \f[CB]\-ext\f[R], and so on.
 .SH IMPORT A NEW TRUSTED CERTIFICATE
 .PP
 Before you add the certificate to the keystore, the \f[CB]keytool\f[R]
diff a/src/java.base/share/native/libfdlibm/k_standard.c b/src/java.base/share/native/libfdlibm/k_standard.c
--- a/src/java.base/share/native/libfdlibm/k_standard.c
+++ b/src/java.base/share/native/libfdlibm/k_standard.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2001, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -737,8 +737,12 @@
                     _LIB_VERSION == _POSIX_) exc.retval = 1.0;
                 else if (!matherr(&exc)) {
                         errno = EDOM;
                 }
                 break;
+            default:
+                exc.retval = zero / zero;
+                errno = EINVAL;
+                break;
         }
         return exc.retval;
 }
diff a/src/java.base/unix/native/libnet/NetworkInterface.c b/src/java.base/unix/native/libnet/NetworkInterface.c
--- a/src/java.base/unix/native/libnet/NetworkInterface.c
+++ b/src/java.base/unix/native/libnet/NetworkInterface.c
@@ -1294,11 +1294,12 @@
  * Try to get the interface index.
  */
 static int getIndex(int sock, const char *name) {
     struct ifreq if2;
     memset((char *)&if2, 0, sizeof(if2));
-    strncpy(if2.ifr_name, name, sizeof(if2.ifr_name) - 1);
+    strncpy(if2.ifr_name, name, sizeof(if2.ifr_name));
+    if2.ifr_name[sizeof(if2.ifr_name) - 1] = 0;
 
     if (ioctl(sock, SIOCGIFINDEX, (char *)&if2) < 0) {
         return -1;
     }
 
@@ -1357,11 +1358,12 @@
 }
 
 static int getFlags(int sock, const char *ifname, int *flags) {
     struct ifreq if2;
     memset((char *)&if2, 0, sizeof(if2));
-    strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
+    strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name));
+    if2.ifr_name[sizeof(if2.ifr_name) - 1] = 0;
 
     if (ioctl(sock, SIOCGIFFLAGS, (char *)&if2) < 0) {
         return -1;
     }
 
diff a/src/java.desktop/macosx/classes/sun/font/CFontManager.java b/src/java.desktop/macosx/classes/sun/font/CFontManager.java
--- a/src/java.desktop/macosx/classes/sun/font/CFontManager.java
+++ b/src/java.desktop/macosx/classes/sun/font/CFontManager.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -94,12 +94,12 @@
         // plus they never need to be added to the generic font list
         // or the fullNameToFont table since they are covers for
         // already existing fonts in this list
         if (logicalFont || !genericFonts.containsKey(fontName)) {
             if (FontUtilities.debugFonts()) {
-                FontUtilities.getLogger().info("Add to Family "+familyName +
-                    ", Font " + fontName + " rank="+rank);
+                FontUtilities.logInfo("Add to Family " + familyName +
+                    ", Font " + fontName + " rank=" + rank);
             }
             FontFamily family = FontFamily.getFamily(familyName);
             if (family == null) {
                 family = new FontFamily(familyName, false, rank);
                 family.setFont(f, f.style);
diff a/src/java.desktop/share/classes/java/awt/Font.java b/src/java.desktop/share/classes/java/awt/Font.java
--- a/src/java.desktop/share/classes/java/awt/Font.java
+++ b/src/java.desktop/share/classes/java/awt/Font.java
@@ -2599,11 +2599,11 @@
               values.getBaselineTransform() == null);
         if (simple) {
             simple = ! FontUtilities.isComplexText(chars, beginIndex, limit);
         }
 
-        if (simple) {
+        if (simple || ((limit - beginIndex) == 0)) {
             FontDesignMetrics metrics = FontDesignMetrics.getMetrics(this, frc);
             return metrics.getSimpleBounds(chars, beginIndex, limit-beginIndex);
         } else {
             // need char array constructor on textlayout
             String str = new String(chars, beginIndex, limit - beginIndex);
diff a/src/java.desktop/share/classes/javax/swing/JTabbedPane.java b/src/java.desktop/share/classes/javax/swing/JTabbedPane.java
--- a/src/java.desktop/share/classes/javax/swing/JTabbedPane.java
+++ b/src/java.desktop/share/classes/javax/swing/JTabbedPane.java
@@ -172,11 +172,11 @@
      * The <code>changeListener</code> is the listener we add to the
      * model.
      */
     protected ChangeListener changeListener = null;
 
-    private final java.util.List<Page> pages;
+    private java.util.List<Page> pages;
 
     /* The component that is currently visible */
     private Component visComp = null;
 
     /**
@@ -1825,10 +1825,11 @@
     /**
      * See <code>readObject</code> and <code>writeObject</code> in
      * <code>JComponent</code> for more
      * information about serialization in Swing.
      */
+    @SuppressWarnings("unchecked")
     private void readObject(ObjectInputStream s)
         throws IOException, ClassNotFoundException
     {
         ObjectInputStream.GetField f = s.readFields();
 
@@ -1839,10 +1840,11 @@
         checkTabLayoutPolicy(newTabLayoutPolicy);
         tabLayoutPolicy = newTabLayoutPolicy;
         model = (SingleSelectionModel) f.get("model", null);
         haveRegistered = f.get("haveRegistered", false);
         changeListener = (ChangeListener) f.get("changeListener", null);
+        pages = (java.util.List<JTabbedPane.Page>) f.get("pages", null);
         visComp = (Component) f.get("visComp", null);
 
         if ((ui != null) && (getUIClassID().equals(uiClassID))) {
             ui.installUI(this);
         }
diff a/src/java.desktop/share/classes/javax/swing/plaf/nimbus/DerivedColor.java b/src/java.desktop/share/classes/javax/swing/plaf/nimbus/DerivedColor.java
--- a/src/java.desktop/share/classes/javax/swing/plaf/nimbus/DerivedColor.java
+++ b/src/java.desktop/share/classes/javax/swing/plaf/nimbus/DerivedColor.java
@@ -80,18 +80,18 @@
     public void rederiveColor() {
         Color src = UIManager.getColor(uiDefaultParentName);
         if (src != null) {
             float[] tmp = Color.RGBtoHSB(src.getRed(), src.getGreen(), src.getBlue(), null);
             // apply offsets
-            tmp[0] = clamp(tmp[0] + hOffset);
+            tmp[0] = tmp[0] + hOffset;
             tmp[1] = clamp(tmp[1] + sOffset);
             tmp[2] = clamp(tmp[2] + bOffset);
             int alpha = clamp(src.getAlpha() + aOffset);
             argbValue = (Color.HSBtoRGB(tmp[0], tmp[1], tmp[2]) & 0xFFFFFF) | (alpha << 24);
         } else {
             float[] tmp = new float[3];
-            tmp[0] = clamp(hOffset);
+            tmp[0] = hOffset;
             tmp[1] = clamp(sOffset);
             tmp[2] = clamp(bOffset);
             int alpha = clamp(aOffset);
             argbValue = (Color.HSBtoRGB(tmp[0], tmp[1], tmp[2]) & 0xFFFFFF) | (alpha << 24);
         }
diff a/src/java.desktop/share/classes/javax/swing/plaf/nimbus/NimbusIcon.java b/src/java.desktop/share/classes/javax/swing/plaf/nimbus/NimbusIcon.java
--- a/src/java.desktop/share/classes/javax/swing/plaf/nimbus/NimbusIcon.java
+++ b/src/java.desktop/share/classes/javax/swing/plaf/nimbus/NimbusIcon.java
@@ -22,18 +22,24 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package javax.swing.plaf.nimbus;
 
+import javax.swing.JComponent;
+import javax.swing.JMenu;
+import javax.swing.JToolBar;
 import javax.swing.Painter;
+import javax.swing.UIManager;
+import javax.swing.plaf.UIResource;
+import javax.swing.plaf.synth.SynthContext;
 import javax.swing.plaf.synth.SynthIcon;
 
-import javax.swing.plaf.synth.SynthContext;
-import javax.swing.*;
-import java.awt.*;
+import java.awt.BorderLayout;
+import java.awt.Component;
+import java.awt.Graphics2D;
+import java.awt.Graphics;
 import java.awt.image.BufferedImage;
-import javax.swing.plaf.UIResource;
 
 /**
  * An icon that delegates to a painter.
  * @author rbair
  */
diff a/src/java.desktop/share/classes/javax/swing/tree/DefaultTreeCellRenderer.java b/src/java.desktop/share/classes/javax/swing/tree/DefaultTreeCellRenderer.java
--- a/src/java.desktop/share/classes/javax/swing/tree/DefaultTreeCellRenderer.java
+++ b/src/java.desktop/share/classes/javax/swing/tree/DefaultTreeCellRenderer.java
@@ -30,10 +30,11 @@
 import java.awt.Dimension;
 import java.awt.Font;
 import java.awt.Graphics;
 import java.awt.Insets;
 import java.awt.Rectangle;
+import javax.swing.plaf.BorderUIResource.EmptyBorderUIResource;
 import javax.swing.plaf.ColorUIResource;
 import javax.swing.plaf.FontUIResource;
 import javax.swing.plaf.UIResource;
 import javax.swing.plaf.basic.BasicGraphicsUtils;
 import javax.swing.Icon;
@@ -243,14 +244,17 @@
                 this, ui, "Tree.drawsFocusBorderAroundIcon", false);
         drawDashedFocusIndicator = DefaultLookup.getBoolean(
                 this, ui, "Tree.drawDashedFocusIndicator", false);
 
         fillBackground = DefaultLookup.getBoolean(this, ui, "Tree.rendererFillBackground", true);
-        Insets margins = DefaultLookup.getInsets(this, ui, "Tree.rendererMargins");
-        if (margins != null) {
-            setBorder(new EmptyBorder(margins.top, margins.left,
-                    margins.bottom, margins.right));
+        if (!inited || getBorder() instanceof UIResource)  {
+            Insets margins = DefaultLookup.getInsets(this, ui, "Tree.rendererMargins");
+            if (margins != null) {
+                setBorder(new EmptyBorderUIResource(margins));
+            } else {
+                setBorder(new EmptyBorderUIResource(0, 0, 0, 0));
+            }
         }
 
         setName("Tree.cellRenderer");
     }
 
diff a/src/java.desktop/share/classes/sun/awt/FontConfiguration.java b/src/java.desktop/share/classes/sun/awt/FontConfiguration.java
--- a/src/java.desktop/share/classes/sun/awt/FontConfiguration.java
+++ b/src/java.desktop/share/classes/sun/awt/FontConfiguration.java
@@ -81,12 +81,11 @@
     /* A default FontConfiguration must be created before an alternate
      * one to ensure proper static initialisation takes place.
      */
     public FontConfiguration(SunFontManager fm) {
         if (FontUtilities.debugFonts()) {
-            FontUtilities.getLogger()
-                .info("Creating standard Font Configuration");
+            FontUtilities.logInfo("Creating standard Font Configuration");
         }
         if (FontUtilities.debugFonts() && logger == null) {
             logger = PlatformLogger.getLogger("sun.awt.FontConfiguration");
         }
         fontManager = fm;
@@ -114,12 +113,11 @@
     public FontConfiguration(SunFontManager fm,
                              boolean preferLocaleFonts,
                              boolean preferPropFonts) {
         fontManager = fm;
         if (FontUtilities.debugFonts()) {
-            FontUtilities.getLogger()
-                .info("Creating alternate Font Configuration");
+            FontUtilities.logInfo("Creating alternate Font Configuration");
         }
         this.preferLocaleFonts = preferLocaleFonts;
         this.preferPropFonts = preferPropFonts;
         /* fontConfig should be initialised by default constructor, and
          * its data tables can be shared, since readFontConfigFile doesn't
diff a/src/java.desktop/share/classes/sun/font/CMap.java b/src/java.desktop/share/classes/sun/font/CMap.java
--- a/src/java.desktop/share/classes/sun/font/CMap.java
+++ b/src/java.desktop/share/classes/sun/font/CMap.java
@@ -398,14 +398,12 @@
         if (subtableFormat < 8) {
             subtableLength = buffer.getChar(offset+2);
         } else {
             subtableLength = buffer.getInt(offset+4) & INTMASK;
         }
-        if (offset+subtableLength > buffer.capacity()) {
-            if (FontUtilities.isLogging()) {
-                FontUtilities.getLogger().warning("Cmap subtable overflows buffer.");
-            }
+        if (FontUtilities.isLogging() && offset + subtableLength > buffer.capacity()) {
+            FontUtilities.logWarning("Cmap subtable overflows buffer.");
         }
         switch (subtableFormat) {
         case 0:  return new CMapFormat0(buffer, offset);
         case 2:  return new CMapFormat2(buffer, offset, xlat);
         case 4:  return new CMapFormat4(buffer, offset, xlat);
@@ -420,15 +418,12 @@
 
     private void createUVS(ByteBuffer buffer, int offset) {
         int subtableFormat = buffer.getChar(offset);
         if (subtableFormat == 14) {
             long subtableLength = buffer.getInt(offset + 2) & INTMASK;
-            if (offset + subtableLength > buffer.capacity()) {
-                if (FontUtilities.isLogging()) {
-                    FontUtilities.getLogger()
-                            .warning("Cmap UVS subtable overflows buffer.");
-                }
+            if (FontUtilities.isLogging() && offset + subtableLength > buffer.capacity()) {
+                FontUtilities.logWarning("Cmap UVS subtable overflows buffer.");
             }
             try {
                 this.uvs = new UVS(buffer, offset);
             } catch (Throwable t) {
                 t.printStackTrace();
diff a/src/java.desktop/share/classes/sun/font/FileFontStrike.java b/src/java.desktop/share/classes/sun/font/FileFontStrike.java
--- a/src/java.desktop/share/classes/sun/font/FileFontStrike.java
+++ b/src/java.desktop/share/classes/sun/font/FileFontStrike.java
@@ -221,12 +221,11 @@
              matrix[0] >= 3.0 && matrix[0] <= 100.0) &&
             !((TrueTypeFont)fileFont).useEmbeddedBitmapsForSize(intPtSize)) {
             useNatives = true;
         }
         if (FontUtilities.isLogging() && FontUtilities.isWindows) {
-            FontUtilities.getLogger().info
-                ("Strike for " + fileFont + " at size = " + intPtSize +
+            FontUtilities.logInfo("Strike for " + fileFont + " at size = " + intPtSize +
                  " use natives = " + useNatives +
                  " useJavaRasteriser = " + fileFont.useJavaRasterizer +
                  " AAHint = " + desc.aaHint +
                  " Has Embedded bitmaps = " +
                  ((TrueTypeFont)fileFont).
@@ -317,14 +316,13 @@
             StrikeCache.unsafe.putFloat(ptr + StrikeCache.xAdvanceOffset,
                                         advance);
             return ptr;
         } else {
             if (FontUtilities.isLogging()) {
-                FontUtilities.getLogger().warning(
-                        "Failed to render glyph using GDI: code=" + glyphCode
-                                + ", fontFamily=" + family + ", style=" + style
-                                + ", size=" + size);
+                FontUtilities.logWarning("Failed to render glyph using GDI: code=" + glyphCode
+                                    + ", fontFamily=" + family + ", style=" + style
+                                    + ", size=" + size);
             }
             return fileFont.getGlyphImage(pScalerContext, glyphCode);
         }
     }
 
@@ -354,18 +352,17 @@
             return glyphPtr;
         } else {
             if (useNatives) {
                 glyphPtr = getGlyphImageFromNative(glyphCode);
                 if (glyphPtr == 0L && FontUtilities.isLogging()) {
-                    FontUtilities.getLogger().info
-                        ("Strike for " + fileFont +
+                    FontUtilities.logInfo("Strike for " + fileFont +
                          " at size = " + intPtSize +
                          " couldn't get native glyph for code = " + glyphCode);
-                 }
-            } if (glyphPtr == 0L) {
-                glyphPtr = fileFont.getGlyphImage(pScalerContext,
-                                                  glyphCode);
+                }
+            }
+            if (glyphPtr == 0L) {
+                glyphPtr = fileFont.getGlyphImage(pScalerContext, glyphCode);
             }
             return setCachedGlyphPtr(glyphCode, glyphPtr);
         }
     }
 
diff a/src/java.desktop/share/classes/sun/font/FontFamily.java b/src/java.desktop/share/classes/sun/font/FontFamily.java
--- a/src/java.desktop/share/classes/sun/font/FontFamily.java
+++ b/src/java.desktop/share/classes/sun/font/FontFamily.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -179,21 +179,21 @@
 
         if (Math.abs(Font2D.FWIDTH_NORMAL - newWidth) <
             Math.abs(Font2D.FWIDTH_NORMAL - familyWidth))
         {
            if (FontUtilities.debugFonts()) {
-               FontUtilities.getLogger().info(
+               FontUtilities.logInfo(
                "Found more preferred width. New width = " + newWidth +
                " Old width = " + familyWidth + " in font " + font +
                " nulling out fonts plain: " + plain + " bold: " + bold +
                " italic: " + italic + " bolditalic: " + bolditalic);
            }
            familyWidth = newWidth;
            plain = bold = italic = bolditalic = null;
            return true;
         } else if (FontUtilities.debugFonts()) {
-               FontUtilities.getLogger().info(
+               FontUtilities.logInfo(
                "Family rejecting font " + font +
                " of less preferred width " + newWidth);
         }
         return false;
     }
@@ -206,11 +206,11 @@
         if (currFont == null) {
             return true;
         }
 
         if (FontUtilities.debugFonts()) {
-            FontUtilities.getLogger().info(
+            FontUtilities.logInfo(
             "New weight for style " + style + ". Curr.font=" + currFont +
             " New font="+font+" Curr.weight="+ + currFont.getWeight()+
             " New weight="+font.getWeight());
         }
 
@@ -240,22 +240,21 @@
                       " with style " + style + " to family " + familyName;
             } else {
                 msg = "Request to add " + font +
                       " with style " + style + " to family " + this;
             }
-            FontUtilities.getLogger().info(msg);
+            FontUtilities.logInfo(msg);
         }
         /* Allow a lower-rank font only if its a file font
          * from the exact same source as any previous font.
          */
         if ((font.getRank() > familyRank) && !isFromSameSource(font)) {
             if (FontUtilities.isLogging()) {
-                FontUtilities.getLogger()
-                                  .warning("Rejecting adding " + font +
-                                           " of lower rank " + font.getRank() +
-                                           " to family " + this +
-                                           " of rank " + familyRank);
+                FontUtilities.logWarning("Rejecting adding " + font +
+                                         " of lower rank " + font.getRank() +
+                                         " to family " + this +
+                                         " of rank " + familyRank);
             }
             return;
         }
 
         switch (style) {
diff a/src/java.desktop/share/classes/sun/font/FontUtilities.java b/src/java.desktop/share/classes/sun/font/FontUtilities.java
--- a/src/java.desktop/share/classes/sun/font/FontUtilities.java
+++ b/src/java.desktop/share/classes/sun/font/FontUtilities.java
@@ -24,14 +24,10 @@
  */
 
 package sun.font;
 
 import java.awt.Font;
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.InputStreamReader;
 import java.lang.ref.SoftReference;
 import java.util.concurrent.ConcurrentHashMap;
 import java.security.AccessController;
 
 import java.security.PrivilegedAction;
@@ -110,14 +106,10 @@
                     if (debugLevel.equals("warning")) {
                         logger.setLevel(PlatformLogger.Level.WARNING);
                     } else if (debugLevel.equals("severe")) {
                         logger.setLevel(PlatformLogger.Level.SEVERE);
                     }
-                }
-
-                if (debugFonts) {
-                    logger = PlatformLogger.getLogger("sun.java2d");
                     logging = logger.isEnabled();
                 }
 
                 return null;
             }
@@ -322,10 +314,21 @@
 
     public static boolean debugFonts() {
         return debugFonts;
     }
 
+    public static void logWarning(String s) {
+        getLogger().warning(s);
+    }
+
+    public static void logInfo(String s) {
+        getLogger().info(s);
+    }
+
+    public static void logSevere(String s) {
+        getLogger().severe(s);
+    }
 
     // The following methods are used by Swing.
 
     /* Revise the implementation to in fact mean "font is a composite font.
      * This ensures that Swing components will always benefit from the
diff a/src/java.desktop/share/classes/sun/font/GlyphLayout.java b/src/java.desktop/share/classes/sun/font/GlyphLayout.java
--- a/src/java.desktop/share/classes/sun/font/GlyphLayout.java
+++ b/src/java.desktop/share/classes/sun/font/GlyphLayout.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -476,12 +476,11 @@
         // a complete blank layout.
         StandardGlyphVector gv;
         if (_gvdata._count < 0) {
             gv = new StandardGlyphVector(font, text, offset, count, frc);
             if (FontUtilities.debugFonts()) {
-               FontUtilities.getLogger().warning("OpenType layout failed on font: " +
-                                                 font);
+               FontUtilities.logWarning("OpenType layout failed on font: " + font);
             }
         } else {
             gv = _gvdata.createGlyphVector(font, frc, result);
         }
         //        System.err.println("Layout returns: " + gv);
diff a/src/java.desktop/share/classes/sun/font/SunFontManager.java b/src/java.desktop/share/classes/sun/font/SunFontManager.java
--- a/src/java.desktop/share/classes/sun/font/SunFontManager.java
+++ b/src/java.desktop/share/classes/sun/font/SunFontManager.java
@@ -318,11 +318,11 @@
                             String name = br.readLine();
                             if (name == null) {
                                 break;
                             } else {
                                 if (FontUtilities.debugFonts()) {
-                                    FontUtilities.getLogger().warning("read bad font: " + name);
+                                    FontUtilities.logWarning("read bad font: " + name);
                                 }
                                 badFonts.add(name);
                             }
                         }
                     } catch (IOException e) {
@@ -352,11 +352,11 @@
                 fontConfig = createFontConfiguration();
 
                 String[] fontInfo = getDefaultPlatformFont();
                 defaultFontName = fontInfo[0];
                 if (defaultFontName == null && FontUtilities.debugFonts()) {
-                    FontUtilities.getLogger().warning("defaultFontName is null");
+                    FontUtilities.logWarning("defaultFontName is null");
                 }
                 defaultFontFileName = fontInfo[1];
 
                 String extraFontPath = fontConfig.getExtraFontPath();
 
@@ -401,14 +401,13 @@
                             dbgFontPath.substring("append:".length());
                     }
                 }
 
                 if (FontUtilities.debugFonts()) {
-                    PlatformLogger logger = FontUtilities.getLogger();
-                    logger.info("JRE font directory: " + jreFontDirName);
-                    logger.info("Extra font path: " + extraFontPath);
-                    logger.info("Debug font path: " + dbgFontPath);
+                    FontUtilities.logInfo("JRE font directory: " + jreFontDirName);
+                    FontUtilities.logInfo("Extra font path: " + extraFontPath);
+                    FontUtilities.logInfo("Debug font path: " + dbgFontPath);
                 }
 
                 if (dbgFontPath != null) {
                     /* In debugging mode we register all the paths
                      * Caution: this is a very expensive call on Solaris:-
@@ -560,14 +559,13 @@
         }
         altNameCache.put(compositeName.toLowerCase(Locale.ENGLISH), cf);
     }
 
     private void addCompositeToFontList(CompositeFont f, int rank) {
-
         if (FontUtilities.isLogging()) {
-            FontUtilities.getLogger().info("Add to Family "+ f.familyName +
-                        ", Font " + f.fullName + " rank="+rank);
+            FontUtilities.logInfo("Add to Family " + f.familyName +
+                        ", Font " + f.fullName + " rank=" + rank);
         }
         f.setRank(rank);
         compositeFonts.put(f.fullName, f);
         fullNameToFont.put(f.fullName.toLowerCase(Locale.ENGLISH), f);
 
@@ -623,12 +621,12 @@
             return null;
         }
         f.setRank(rank);
         if (!physicalFonts.containsKey(fontName)) {
             if (FontUtilities.isLogging()) {
-                FontUtilities.getLogger().info("Add to Family "+familyName +
-                            ", Font " + fontName + " rank="+rank);
+                FontUtilities.logInfo("Add to Family " + familyName +
+                            ", Font " + fontName + " rank=" + rank);
             }
             physicalFonts.put(fontName, f);
             FontFamily family = FontFamily.getFamily(familyName);
             if (family == null) {
                 family = new FontFamily(familyName, false, rank);
@@ -697,25 +695,22 @@
                  * In other words if we reach here, there's a possible
                  * problem with our choice of font configuration fonts.
                  */
                 if (oldFont.platName.startsWith(jreFontDirName)) {
                     if (FontUtilities.isLogging()) {
-                        FontUtilities.getLogger()
-                              .warning("Unexpected attempt to replace a JRE " +
-                                       " font " + fontName + " from " +
-                                        oldFont.platName +
+                        FontUtilities.logWarning("Unexpected attempt to replace a JRE " +
+                                       " font " + fontName + " from " + oldFont.platName +
                                        " with " + newFont.platName);
                     }
                     return oldFont;
                 }
 
                 if (FontUtilities.isLogging()) {
-                    FontUtilities.getLogger()
-                          .info("Replace in Family " + familyName +
-                                ",Font " + fontName + " new rank="+rank +
-                                " from " + oldFont.platName +
-                                " with " + newFont.platName);
+                    FontUtilities.logInfo("Replace in Family " + familyName +
+                                    ",Font " + fontName + " new rank="+rank +
+                                    " from " + oldFont.platName +
+                                    " with " + newFont.platName);
                 }
                 replaceFont(oldFont, newFont);
                 physicalFonts.put(fontName, newFont);
                 fullNameToFont.put(fontName.toLowerCase(Locale.ENGLISH),
                                    newFont);
@@ -901,12 +896,11 @@
 
         if (fileNameKey == null) {
             return null;
         }
         if (FontUtilities.isLogging()) {
-            FontUtilities.getLogger()
-                            .info("Opening deferred font file " + fileNameKey);
+            FontUtilities.logInfo("Opening deferred font file " + fileNameKey);
         }
 
         PhysicalFont physicalFont = null;
         FontRegistrationInfo regInfo = deferredFontFiles.get(fileNameKey);
         if (regInfo != null) {
@@ -989,18 +983,16 @@
                 break;
             default:
 
             }
             if (FontUtilities.isLogging()) {
-                FontUtilities.getLogger()
-                      .info("Registered file " + fileName + " as font " +
-                            physicalFont + " rank="  + fontRank);
+                FontUtilities.logInfo("Registered file " + fileName + " as font " +
+                                physicalFont + " rank="  + fontRank);
             }
         } catch (FontFormatException ffe) {
             if (FontUtilities.isLogging()) {
-                FontUtilities.getLogger().warning("Unusable font: " +
-                               fileName + " " + ffe.toString());
+                FontUtilities.logInfo("Unusable font: " + fileName + " " + ffe.toString());
             }
         }
         if (physicalFont != null &&
             fontFormat != FONTFORMAT_NATIVE) {
             registeredFonts.put(fileName, physicalFont);
@@ -1040,12 +1032,11 @@
             if (font2d != null) {
                 if (font2d instanceof PhysicalFont) {
                     defaultPhysicalFont = (PhysicalFont)font2d;
                 } else {
                     if (FontUtilities.isLogging()) {
-                        FontUtilities.getLogger()
-                            .warning("Font returned by findFont2D for default font name " +
+                        FontUtilities.logWarning("Font returned by findFont2D for default font name " +
                                      defaultFontName + " is not a physical font: " + font2d.getFontName(null));
                     }
                 }
             }
             if (defaultPhysicalFont == null) {
@@ -1302,12 +1293,11 @@
                             }
                         }
                     }
                     fontToFamilyNameMap.remove(name);
                     if (FontUtilities.isLogging()) {
-                        FontUtilities.getLogger()
-                                             .info("No file for font:" + name);
+                        FontUtilities.logInfo("No file for font:" + name);
                     }
                 }
             }
         }
     }
@@ -1353,12 +1343,11 @@
         HashMap<String,ArrayList<String>> familyToFontListMap2 = null;;
 
         for (String pathFile : getFontFilesFromPath(false)) {
             if (!registryFiles.contains(pathFile)) {
                 if (FontUtilities.isLogging()) {
-                    FontUtilities.getLogger()
-                                 .info("Found non-registry file : " + pathFile);
+                    FontUtilities.logInfo("Found non-registry file : " + pathFile);
                 }
                 PhysicalFont f = registerFontFile(getPathName(pathFile));
                 if (f == null) {
                     continue;
                 }
@@ -1398,24 +1387,22 @@
             try {
                 int fn = 0;
                 TrueTypeFont ttf;
                 String fullPath = getPathName(file);
                 if (FontUtilities.isLogging()) {
-                    FontUtilities.getLogger()
-                                   .info("Trying to resolve file " + fullPath);
+                    FontUtilities.logInfo("Trying to resolve file " + fullPath);
                 }
                 do {
                     ttf = new TrueTypeFont(fullPath, null, fn++, false);
                     //  prefer the font's locale name.
                     String fontName = ttf.getFontName(l).toLowerCase();
                     if (unmappedFonts.contains(fontName)) {
                         fontToFileMap.put(fontName, file);
                         unmappedFonts.remove(fontName);
                         if (FontUtilities.isLogging()) {
-                            FontUtilities.getLogger()
-                                  .info("Resolved absent registry entry for " +
-                                        fontName + " located in " + fullPath);
+                            FontUtilities.logInfo("Resolved absent registry entry for " +
+                                            fontName + " located in " + fullPath);
                         }
                     }
                 }
                 while (fn < ttf.getFontCount());
             } catch (Exception e) {
@@ -1536,12 +1523,11 @@
             }
         }
 
         if (failure) {
             if (FontUtilities.isLogging()) {
-                FontUtilities.getLogger().
-                    info("Hardcoded file missing looking for " + lcName);
+                FontUtilities.logInfo("Hardcoded file missing looking for " + lcName);
             }
             platformFontMap.remove(firstWord);
             return null;
         }
 
@@ -1564,12 +1550,11 @@
              }
          });
 
         if (failure) {
             if (FontUtilities.isLogging()) {
-                FontUtilities.getLogger().
-                    info("Hardcoded file missing looking for " + lcName);
+                FontUtilities.logInfo("Hardcoded file missing looking for " + lcName);
             }
             platformFontMap.remove(firstWord);
             return null;
         }
 
@@ -1832,13 +1817,12 @@
         for (int f=0;f<fontList.length;f++) {
             String fontNameLC = fontList[f].toLowerCase(Locale.ENGLISH);
             String fileName = fontToFileMap.get(fontNameLC);
             if (fileName == null) {
                 if (FontUtilities.isLogging()) {
-                    FontUtilities.getLogger()
-                          .info("Platform lookup : No file for font " +
-                                fontList[f] + " in family " +familyName);
+                    FontUtilities.logInfo("Platform lookup : No file for font " +
+                                    fontList[f] + " in family " +familyName);
                 }
                 return null;
             }
         }
 
@@ -1903,13 +1887,12 @@
          */
         Font2D font = fontNameCache.get(mapName);
         if (font != null) {
             return font;
         }
-
         if (FontUtilities.isLogging()) {
-            FontUtilities.getLogger().info("Search for font: " + name);
+            FontUtilities.logInfo("Search for font: " + name);
         }
 
         // The check below is just so that the bitmap fonts being set by
         // AWT and Swing thru the desktop properties do not trigger the
         // the load fonts case. The two bitmap fonts are now mapped to
@@ -2019,13 +2002,13 @@
 
         if (FontUtilities.isWindows) {
 
             font = findFontFromPlatformMap(lowerCaseName, style);
             if (FontUtilities.isLogging()) {
-                FontUtilities.getLogger()
-                    .info("findFontFromPlatformMap returned " + font);
+                FontUtilities.logInfo("findFontFromPlatformMap returned " + font);
             }
+
             if (font != null) {
                 fontNameCache.put(mapName, font);
                 return font;
             }
             /* Don't want Windows to return a font from C:\Windows\Fonts
@@ -2040,14 +2023,13 @@
                 }
             }
             font = findFontFromPlatform(lowerCaseName, style);
             if (font != null) {
                 if (FontUtilities.isLogging()) {
-                    FontUtilities.getLogger()
-                          .info("Found font via platform API for request:\"" +
-                                name + "\":, style="+style+
-                                " found font: " + font);
+                    FontUtilities.logInfo("Found font via platform API for request:\"" +
+                                    name + "\":, style="+style+
+                                    " found font: " + font);
                 }
                 fontNameCache.put(mapName, font);
                 return font;
             }
         }
@@ -2114,22 +2096,20 @@
         /* If reach here and no match has been located, then if all fonts
          * are not yet loaded, do so, and then recurse.
          */
         if (!loadedAllFonts) {
             if (FontUtilities.isLogging()) {
-                FontUtilities.getLogger()
-                                       .info("Load fonts looking for:" + name);
+                FontUtilities.logInfo("Load fonts looking for:" + name);
             }
             loadFonts();
             loadedAllFonts = true;
             return findFont2D(name, style, fallback);
         }
 
         if (!loadedAllFontFiles) {
             if (FontUtilities.isLogging()) {
-                FontUtilities.getLogger()
-                                  .info("Load font files looking for:" + name);
+                FontUtilities.logInfo("Load font files looking for:" + name);
             }
             loadFontFiles();
             loadedAllFontFiles = true;
             return findFont2D(name, style, fallback);
         }
@@ -2183,13 +2163,12 @@
         } else if (lowerCaseName.equals("courier")) {
             font = findFont2D("monospaced", style, fallback);
             fontNameCache.put(mapName, font);
             return font;
         }
-
         if (FontUtilities.isLogging()) {
-            FontUtilities.getLogger().info("No font found for:" + name);
+            FontUtilities.logInfo("No font found for:" + name);
         }
 
         switch (fallback) {
         case PHYSICAL_FALLBACK: return getDefaultPhysicalFont();
         case LOGICAL_FALLBACK: return getDefaultLogicalFont(style);
@@ -2360,12 +2339,11 @@
         if (!(font2D instanceof PhysicalFont)) {
             /* We should never reach here, but just in case */
             return;
         } else {
             if (FontUtilities.isLogging()) {
-                FontUtilities.getLogger()
-                                     .severe("Deregister bad font: " + font2D);
+                FontUtilities.logSevere("Deregister bad font: " + font2D);
             }
             replaceFont((PhysicalFont)font2D, getDefaultPhysicalFont());
         }
     }
 
@@ -2384,24 +2362,22 @@
         /* If we try to replace the font with itself, that won't work,
          * so pick any alternative physical font
          */
         if (oldFont == newFont) {
             if (FontUtilities.isLogging()) {
-                FontUtilities.getLogger()
-                      .severe("Can't replace bad font with itself " + oldFont);
+                FontUtilities.logSevere("Can't replace bad font with itself " + oldFont);
             }
             PhysicalFont[] physFonts = getPhysicalFonts();
             for (int i=0; i<physFonts.length;i++) {
                 if (physFonts[i] != newFont) {
                     newFont = physFonts[i];
                     break;
                 }
             }
             if (oldFont == newFont) {
                 if (FontUtilities.isLogging()) {
-                    FontUtilities.getLogger()
-                           .severe("This is bad. No good physicalFonts found.");
+                    FontUtilities.logSevere("This is bad. No good physicalFonts found.");
                 }
                 return;
             }
         }
 
@@ -2498,14 +2474,12 @@
      * almost never used. The main case in which it is called is when
      * a bogus font name is used and we need to check all possible names
      * before returning the default case.
      */
     private Font2D findFont2DAllLocales(String name, int style) {
-
         if (FontUtilities.isLogging()) {
-            FontUtilities.getLogger()
-                           .info("Searching localised font names for:" + name);
+            FontUtilities.logInfo("Searching localised font names for:" + name);
         }
 
         /* If reach here and no match has been located, then if we have
          * not yet built the map of localeFullNamesToFont for TT fonts, do so
          * now. This method must be called after all fonts have been loaded.
@@ -2637,13 +2611,13 @@
      * to use Mincho instead of Gothic for dialoginput in JA locales
      * on windows. Not needed on other platforms.
      */
     public synchronized void useAlternateFontforJALocales() {
         if (FontUtilities.isLogging()) {
-            FontUtilities.getLogger()
-                .info("Entered useAlternateFontforJALocales().");
+            FontUtilities.logInfo("Entered useAlternateFontforJALocales().");
         }
+
         if (!FontUtilities.isWindows) {
             return;
         }
         gAltJAFont = true;
     }
@@ -2652,12 +2626,13 @@
         return gAltJAFont;
     }
 
     public synchronized void preferLocaleFonts() {
         if (FontUtilities.isLogging()) {
-            FontUtilities.getLogger().info("Entered preferLocaleFonts().");
+            FontUtilities.logInfo("Entered preferLocaleFonts().");
         }
+
         /* Test if re-ordering will have any effect */
         if (!FontConfiguration.willReorderForStartupLocale()) {
             return;
         }
         if (gLocalePref == true) {
@@ -2668,13 +2643,13 @@
         _usingAlternateComposites = true;
     }
 
     public synchronized void preferProportionalFonts() {
         if (FontUtilities.isLogging()) {
-            FontUtilities.getLogger()
-                .info("Entered preferProportionalFonts().");
+            FontUtilities.logInfo("Entered preferProportionalFonts().");
         }
+
         /* If no proportional fonts are configured, there's no need
          * to take any action.
          */
         if (!FontConfiguration.hasMonoToPropMap()) {
             return;
@@ -2910,12 +2885,11 @@
                 continue;
             }
 
             if (badFonts != null && badFonts.contains(fullName)) {
                 if (FontUtilities.debugFonts()) {
-                    FontUtilities.getLogger()
-                                         .warning("skip bad font " + fullName);
+                    FontUtilities.logWarning("skip bad font " + fullName);
                 }
                 continue; // skip this font file.
             }
 
             registeredFontFiles.add(fullName);
@@ -2930,11 +2904,11 @@
                     message += " with native name(s) " + natNames[0];
                     for (int nn = 1; nn < natNames.length; nn++) {
                         message += ", " + natNames[nn];
                     }
                 }
-                FontUtilities.getLogger().info(message);
+                FontUtilities.logInfo(message);
             }
             fontNames[fontCount] = fullName;
             nativeNames[fontCount++] = getNativeNames(fullName, null);
         }
         registerFonts(fontNames, nativeNames, fontCount, fontFormat,
@@ -2980,12 +2954,11 @@
         }
         /* Use lock specific to the font system */
         synchronized (this) {
             if (FontUtilities.debugFonts()) {
                 Thread.dumpStack();
-                FontUtilities.getLogger()
-                            .info("SunGraphicsEnvironment.loadFonts() called");
+                FontUtilities.logInfo("SunGraphicsEnvironment.loadFonts() called");
             }
             initialiseDeferredFonts();
 
             AccessController.doPrivileged(new PrivilegedAction<Void>() {
                 public Void run() {
@@ -3099,11 +3072,11 @@
         }
         /* Use lock specific to the font system */
         synchronized (this) {
             if (FontUtilities.debugFonts()) {
                 Thread.dumpStack();
-                FontUtilities.getLogger().info("loadAllFontFiles() called");
+                FontUtilities.logInfo("loadAllFontFiles() called");
             }
             AccessController.doPrivileged(new PrivilegedAction<Void>() {
                 public Void run() {
                     if (fontPath == null) {
                         fontPath = getPlatformFontPath(noType1Font);
@@ -3131,14 +3104,12 @@
      * The composites themselves are then registered.
      */
     private void
         initCompositeFonts(FontConfiguration fontConfig,
                            ConcurrentHashMap<String, Font2D>  altNameCache) {
-
         if (FontUtilities.isLogging()) {
-            FontUtilities.getLogger()
-                            .info("Initialising composite fonts");
+            FontUtilities.logInfo("Initialising composite fonts");
         }
 
         int numCoreFonts = fontConfig.getNumberCoreFonts();
         String[] fcFonts = fontConfig.getPlatformFontNames();
         for (int f=0; f<fcFonts.length; f++) {
@@ -3234,12 +3205,11 @@
                                       descriptor.getExclusionRanges(),
                                       descriptor.getExclusionRangeLimits(),
                                       true);
             }
             if (FontUtilities.debugFonts()) {
-                FontUtilities.getLogger()
-                               .info("registered " + descriptor.getFaceName());
+                FontUtilities.logInfo("registered " + descriptor.getFaceName());
             }
         }
     }
 
     /**
diff a/src/java.desktop/share/classes/sun/font/TrueTypeFont.java b/src/java.desktop/share/classes/sun/font/TrueTypeFont.java
--- a/src/java.desktop/share/classes/sun/font/TrueTypeFont.java
+++ b/src/java.desktop/share/classes/sun/font/TrueTypeFont.java
@@ -242,11 +242,11 @@
      */
     private synchronized FileChannel open(boolean usePool)
                                      throws FontFormatException {
         if (disposerRecord.channel == null) {
             if (FontUtilities.isLogging()) {
-                FontUtilities.getLogger().info("open TTF: " + platName);
+                FontUtilities.logInfo("open TTF: " + platName);
             }
             try {
                 RandomAccessFile raf = AccessController.doPrivileged(
                     new PrivilegedExceptionAction<RandomAccessFile>() {
                         public RandomAccessFile run() throws FileNotFoundException {
@@ -308,13 +308,13 @@
                          * isn't updated. If the file has changed whilst we
                          * are executing we want to bail, not spin.
                          */
                         if (FontUtilities.isLogging()) {
                             String msg = "Read offset is " + offset +
-                                " file size is " + fileSize+
-                                " file is " + platName;
-                            FontUtilities.getLogger().severe(msg);
+                                    " file size is " + fileSize+
+                                    " file is " + platName;
+                            FontUtilities.logSevere(msg);
                         }
                         return -1;
                     } else {
                         length = fileSize - offset;
                     }
@@ -329,11 +329,11 @@
                         if (currSize != fileSize) {
                             msg += " File size was " + fileSize +
                                 " and now is " + currSize;
                         }
                         if (FontUtilities.isLogging()) {
-                            FontUtilities.getLogger().severe(msg);
+                            FontUtilities.logSevere(msg);
                         }
                         // We could still flip() the buffer here because
                         // it's possible that we did read some data in
                         // an earlier loop, and we probably should
                         // return that to the caller. Although if
@@ -344,13 +344,12 @@
                         // but is meant to allow cases where enough
                         // data was read to probably continue.
                         if (bread > length/2 || bread > 16384) {
                             buffer.flip();
                             if (FontUtilities.isLogging()) {
-                                msg = "Returning " + bread +
-                                    " bytes instead of " + length;
-                                FontUtilities.getLogger().severe(msg);
+                                msg = "Returning " + bread + " bytes instead of " + length;
+                                FontUtilities.logSevere(msg);
                             }
                         } else {
                             bread = -1;
                         }
                         throw new IOException(msg);
@@ -362,12 +361,11 @@
                     bread = length;
                 }
             }
         } catch (FontFormatException e) {
             if (FontUtilities.isLogging()) {
-                FontUtilities.getLogger().severe(
-                                       "While reading " + platName, e);
+                FontUtilities.getLogger().severe("While reading " + platName, e);
             }
             bread = -1; // signal EOF
             deregisterFontAndClearStrikeCache();
         } catch (ClosedChannelException e) {
             /* NIO I/O is interruptible, recurse to retry operation.
@@ -383,12 +381,11 @@
              * Other than an attempt to read past the end of the file it
              * seems unlikely this would occur as problems opening the
              * file are handled as a FontFormatException.
              */
             if (FontUtilities.isLogging()) {
-                FontUtilities.getLogger().severe(
-                                       "While reading " + platName, e);
+                FontUtilities.getLogger().severe("While reading " + platName, e);
             }
             if (bread == 0) {
                 bread = -1; // signal EOF
                 deregisterFontAndClearStrikeCache();
             }
@@ -521,11 +518,11 @@
                 throw new FontFormatException("missing hhea table");
             }
             initNames();
         } catch (Exception e) {
             if (FontUtilities.isLogging()) {
-                FontUtilities.getLogger().severe(e.toString());
+                FontUtilities.logSevere(e.toString());
             }
             if (e instanceof FontFormatException) {
                 throw (FontFormatException)e;
             } else {
                 throw new FontFormatException(e.toString());
@@ -1071,11 +1068,11 @@
 
         try {
             return new String(bytes, 0, len, charset);
         } catch (UnsupportedEncodingException e) {
             if (FontUtilities.isLogging()) {
-                FontUtilities.getLogger().warning(e + " EncodingID=" + encoding);
+                FontUtilities.logWarning(e + " EncodingID=" + encoding);
             }
             return new String(bytes, 0, len);
         } catch (Throwable t) {
             return null;
         }
diff a/src/java.desktop/share/classes/sun/font/TrueTypeGlyphMapper.java b/src/java.desktop/share/classes/sun/font/TrueTypeGlyphMapper.java
--- a/src/java.desktop/share/classes/sun/font/TrueTypeGlyphMapper.java
+++ b/src/java.desktop/share/classes/sun/font/TrueTypeGlyphMapper.java
@@ -72,14 +72,13 @@
             if (glyphCode < numGlyphs ||
                 glyphCode >= FileFontStrike.INVISIBLE_GLYPHS) {
                 return glyphCode;
             } else {
                 if (FontUtilities.isLogging()) {
-                    FontUtilities.getLogger().warning
-                        (font + " out of range glyph id=" +
-                         Integer.toHexString((int)glyphCode) +
-                         " for char " + Integer.toHexString(charCode));
+                    FontUtilities.logWarning(font + " out of range glyph id=" +
+                             Integer.toHexString((int)glyphCode) +
+                             " for char " + Integer.toHexString(charCode));
                 }
                 return (char)missingGlyph;
             }
         } catch(Exception e) {
             handleBadCMAP();
@@ -97,12 +96,11 @@
             if (glyphCode < numGlyphs ||
                 glyphCode >= FileFontStrike.INVISIBLE_GLYPHS) {
                 return glyphCode;
             } else {
                 if (FontUtilities.isLogging()) {
-                    FontUtilities.getLogger().warning
-                        (font + " out of range glyph id=" +
+                    FontUtilities.logWarning(font + " out of range glyph id=" +
                          Integer.toHexString((int)glyphCode) +
                          " for char " + Integer.toHexString(charCode) +
                          " for vs " + Integer.toHexString(variationSelector));
                 }
                 return (char)missingGlyph;
@@ -113,13 +111,14 @@
         }
     }
 
     private void handleBadCMAP() {
         if (FontUtilities.isLogging()) {
-            FontUtilities.getLogger().severe("Null Cmap for " + font +
-                                      "substituting for this font");
+            FontUtilities.logSevere("Null Cmap for " + font +
+                                    "substituting for this font");
         }
+
         SunFontManager.getInstance().deRegisterBadFont(font);
         /* The next line is not really a solution, but might
          * reduce the exceptions until references to this font2D
          * are gone.
          */
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-fdsc-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-aat-fdsc-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-fdsc-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-aat-fdsc-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout-ankr-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout-ankr-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout-ankr-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout-ankr-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout-bsln-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout-bsln-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout-bsln-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout-bsln-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout-common.hh b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout-common.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout-common.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout-common.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout-feat-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout-feat-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout-feat-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout-feat-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout-just-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout-just-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout-just-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout-just-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout-kerx-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout-kerx-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout-kerx-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout-kerx-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout-lcar-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout-lcar-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout-lcar-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout-lcar-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout-morx-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout-morx-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout-morx-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout-morx-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout-trak-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout-trak-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout-trak-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout-trak-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout.cc b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout.h b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout.hh b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-aat-layout.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-ltag-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-aat-ltag-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-ltag-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-aat-ltag-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-map.cc b/src/java.desktop/share/native/libharfbuzz/hb-aat-map.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-map.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-aat-map.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-map.hh b/src/java.desktop/share/native/libharfbuzz/hb-aat-map.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-map.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-aat-map.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat.h b/src/java.desktop/share/native/libharfbuzz/hb-aat.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-aat.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-array.hh b/src/java.desktop/share/native/libharfbuzz/hb-array.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-array.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-array.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-atomic.hh b/src/java.desktop/share/native/libharfbuzz/hb-atomic.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-atomic.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-atomic.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-blob.cc b/src/java.desktop/share/native/libharfbuzz/hb-blob.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-blob.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-blob.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-blob.h b/src/java.desktop/share/native/libharfbuzz/hb-blob.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-blob.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-blob.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-blob.hh b/src/java.desktop/share/native/libharfbuzz/hb-blob.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-blob.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-blob.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer-deserialize-json.hh b/src/java.desktop/share/native/libharfbuzz/hb-buffer-deserialize-json.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer-deserialize-json.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-buffer-deserialize-json.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer-deserialize-text.hh b/src/java.desktop/share/native/libharfbuzz/hb-buffer-deserialize-text.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer-deserialize-text.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-buffer-deserialize-text.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer-serialize.cc b/src/java.desktop/share/native/libharfbuzz/hb-buffer-serialize.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer-serialize.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-buffer-serialize.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer.cc b/src/java.desktop/share/native/libharfbuzz/hb-buffer.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-buffer.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer.h b/src/java.desktop/share/native/libharfbuzz/hb-buffer.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-buffer.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer.hh b/src/java.desktop/share/native/libharfbuzz/hb-buffer.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-buffer.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-cff-interp-common.hh b/src/java.desktop/share/native/libharfbuzz/hb-cff-interp-common.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-cff-interp-common.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-cff-interp-common.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-cff-interp-cs-common.hh b/src/java.desktop/share/native/libharfbuzz/hb-cff-interp-cs-common.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-cff-interp-cs-common.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-cff-interp-cs-common.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-cff-interp-dict-common.hh b/src/java.desktop/share/native/libharfbuzz/hb-cff-interp-dict-common.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-cff-interp-dict-common.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-cff-interp-dict-common.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-cff1-interp-cs.hh b/src/java.desktop/share/native/libharfbuzz/hb-cff1-interp-cs.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-cff1-interp-cs.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-cff1-interp-cs.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-cff2-interp-cs.hh b/src/java.desktop/share/native/libharfbuzz/hb-cff2-interp-cs.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-cff2-interp-cs.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-cff2-interp-cs.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-common.cc b/src/java.desktop/share/native/libharfbuzz/hb-common.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-common.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-common.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-common.h b/src/java.desktop/share/native/libharfbuzz/hb-common.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-common.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-common.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-coretext.cc b/src/java.desktop/share/native/libharfbuzz/hb-coretext.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-coretext.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-coretext.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-coretext.h b/src/java.desktop/share/native/libharfbuzz/hb-coretext.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-coretext.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-coretext.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-debug.hh b/src/java.desktop/share/native/libharfbuzz/hb-debug.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-debug.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-debug.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-deprecated.h b/src/java.desktop/share/native/libharfbuzz/hb-deprecated.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-deprecated.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-deprecated.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-dsalgs.hh b/src/java.desktop/share/native/libharfbuzz/hb-dsalgs.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-dsalgs.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-dsalgs.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-face.cc b/src/java.desktop/share/native/libharfbuzz/hb-face.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-face.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-face.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-face.h b/src/java.desktop/share/native/libharfbuzz/hb-face.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-face.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-face.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-face.hh b/src/java.desktop/share/native/libharfbuzz/hb-face.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-face.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-face.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-fallback-shape.cc b/src/java.desktop/share/native/libharfbuzz/hb-fallback-shape.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-fallback-shape.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-fallback-shape.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-font.cc b/src/java.desktop/share/native/libharfbuzz/hb-font.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-font.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-font.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-font.h b/src/java.desktop/share/native/libharfbuzz/hb-font.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-font.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-font.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-font.hh b/src/java.desktop/share/native/libharfbuzz/hb-font.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-font.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-font.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ft.cc b/src/java.desktop/share/native/libharfbuzz/hb-ft.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ft.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ft.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ft.h b/src/java.desktop/share/native/libharfbuzz/hb-ft.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ft.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ft.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-iter.hh b/src/java.desktop/share/native/libharfbuzz/hb-iter.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-iter.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-iter.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-kern.hh b/src/java.desktop/share/native/libharfbuzz/hb-kern.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-kern.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-kern.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-machinery.hh b/src/java.desktop/share/native/libharfbuzz/hb-machinery.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-machinery.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-machinery.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-map.cc b/src/java.desktop/share/native/libharfbuzz/hb-map.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-map.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-map.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-map.h b/src/java.desktop/share/native/libharfbuzz/hb-map.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-map.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-map.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-map.hh b/src/java.desktop/share/native/libharfbuzz/hb-map.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-map.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-map.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-mutex.hh b/src/java.desktop/share/native/libharfbuzz/hb-mutex.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-mutex.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-mutex.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-null.hh b/src/java.desktop/share/native/libharfbuzz/hb-null.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-null.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-null.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-object.hh b/src/java.desktop/share/native/libharfbuzz/hb-object.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-object.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-object.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-open-file.hh b/src/java.desktop/share/native/libharfbuzz/hb-open-file.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-open-file.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-open-file.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-open-type.hh b/src/java.desktop/share/native/libharfbuzz/hb-open-type.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-open-type.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-open-type.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-cff-common.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-cff-common.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-cff-common.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-cff-common.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-cff1-table.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-cff1-table.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-cff1-table.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-cff1-table.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-cff1-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-cff1-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-cff1-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-cff1-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-cff2-table.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-cff2-table.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-cff2-table.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-cff2-table.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-cff2-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-cff2-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-cff2-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-cff2-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-cmap-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-cmap-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-cmap-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-cmap-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-cbdt-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-color-cbdt-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-cbdt-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-color-cbdt-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-colr-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-color-colr-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-colr-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-color-colr-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-cpal-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-color-cpal-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-cpal-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-color-cpal-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-sbix-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-color-sbix-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-sbix-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-color-sbix-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-svg-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-color-svg-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-svg-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-color-svg-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-color.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-color.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color.h b/src/java.desktop/share/native/libharfbuzz/hb-ot-color.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-color.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-deprecated.h b/src/java.desktop/share/native/libharfbuzz/hb-ot-deprecated.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-deprecated.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-deprecated.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-face.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-face.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-face.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-face.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-face.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-face.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-face.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-face.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-font.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-font.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-font.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-font.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-font.h b/src/java.desktop/share/native/libharfbuzz/hb-ot-font.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-font.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-font.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-gasp-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-gasp-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-gasp-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-gasp-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-glyf-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-glyf-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-glyf-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-glyf-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-hdmx-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-hdmx-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-hdmx-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-hdmx-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-head-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-head-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-head-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-head-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-hhea-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-hhea-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-hhea-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-hhea-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-hmtx-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-hmtx-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-hmtx-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-hmtx-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-kern-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-kern-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-kern-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-kern-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-base-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-layout-base-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-base-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-layout-base-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-common.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-layout-common.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-common.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-layout-common.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gdef-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-layout-gdef-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gdef-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-layout-gdef-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gpos-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-layout-gpos-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gpos-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-layout-gpos-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gsub-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-layout-gsub-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gsub-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-layout-gsub-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gsubgpos.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-layout-gsubgpos.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gsubgpos.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-layout-gsubgpos.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-jstf-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-layout-jstf-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-jstf-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-layout-jstf-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-layout.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-layout.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout.h b/src/java.desktop/share/native/libharfbuzz/hb-ot-layout.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-layout.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-layout.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-layout.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-map.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-map.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-map.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-map.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-map.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-map.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-map.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-map.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-math-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-math-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-math-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-math-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-math.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-math.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-math.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-math.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-math.h b/src/java.desktop/share/native/libharfbuzz/hb-ot-math.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-math.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-math.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-maxp-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-maxp-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-maxp-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-maxp-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-name-language.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-name-language.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-name-language.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-name-language.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-name-language.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-name-language.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-name-language.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-name-language.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-name-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-name-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-name-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-name-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-name.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-name.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-name.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-name.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-name.h b/src/java.desktop/share/native/libharfbuzz/hb-ot-name.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-name.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-name.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-os2-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-os2-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-os2-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-os2-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-os2-unicode-ranges.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-os2-unicode-ranges.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-os2-unicode-ranges.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-os2-unicode-ranges.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-post-macroman.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-post-macroman.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-post-macroman.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-post-macroman.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-post-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-post-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-post-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-post-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-arabic-fallback.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-arabic-fallback.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-arabic-fallback.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-arabic-fallback.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-arabic-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-arabic-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-arabic-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-arabic-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-arabic-win1256.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-arabic-win1256.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-arabic-win1256.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-arabic-win1256.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-arabic.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-arabic.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-arabic.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-arabic.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-arabic.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-arabic.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-arabic.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-arabic.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-default.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-default.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-default.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-default.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-hangul.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-hangul.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-hangul.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-hangul.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-hebrew.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-hebrew.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-hebrew.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-hebrew.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-indic-machine.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-indic-machine.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-indic-machine.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-indic-machine.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-indic-table.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-indic-table.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-indic-table.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-indic-table.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-indic.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-indic.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-indic.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-indic.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-indic.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-indic.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-indic.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-indic.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-khmer-machine.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-khmer-machine.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-khmer-machine.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-khmer-machine.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-khmer.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-khmer.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-khmer.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-khmer.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-khmer.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-khmer.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-khmer.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-khmer.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-myanmar-machine.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-myanmar-machine.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-myanmar-machine.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-myanmar-machine.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-myanmar.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-myanmar.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-myanmar.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-myanmar.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-myanmar.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-myanmar.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-myanmar.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-myanmar.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-thai.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-thai.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-thai.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-thai.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-use-machine.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-use-machine.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-use-machine.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-use-machine.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-use-table.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-use-table.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-use-table.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-use-table.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-use.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-use.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-use.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-use.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-use.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-use.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-use.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-use.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-vowel-constraints.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-vowel-constraints.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-vowel-constraints.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-vowel-constraints.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-vowel-constraints.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-vowel-constraints.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-vowel-constraints.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-vowel-constraints.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-fallback.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-fallback.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-fallback.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-fallback.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-fallback.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-fallback.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-fallback.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-fallback.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-normalize.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-normalize.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-normalize.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-normalize.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-normalize.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-normalize.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-normalize.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape-normalize.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape.h b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-shape.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-stat-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-stat-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-stat-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-stat-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-tag-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-tag-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-tag-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-tag-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-tag.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-tag.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-tag.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-tag.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-var-avar-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-var-avar-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-var-avar-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-var-avar-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-var-fvar-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-var-fvar-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-var-fvar-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-var-fvar-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-var-hvar-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-var-hvar-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-var-hvar-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-var-hvar-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-var-mvar-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-var-mvar-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-var-mvar-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-var-mvar-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-var.cc b/src/java.desktop/share/native/libharfbuzz/hb-ot-var.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-var.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-var.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-var.h b/src/java.desktop/share/native/libharfbuzz/hb-ot-var.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-var.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-var.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-vorg-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-ot-vorg-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-vorg-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot-vorg-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot.h b/src/java.desktop/share/native/libharfbuzz/hb-ot.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ot.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-set-digest.hh b/src/java.desktop/share/native/libharfbuzz/hb-set-digest.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-set-digest.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-set-digest.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-set.cc b/src/java.desktop/share/native/libharfbuzz/hb-set.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-set.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-set.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-set.h b/src/java.desktop/share/native/libharfbuzz/hb-set.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-set.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-set.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-set.hh b/src/java.desktop/share/native/libharfbuzz/hb-set.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-set.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-set.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shape-plan.cc b/src/java.desktop/share/native/libharfbuzz/hb-shape-plan.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shape-plan.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-shape-plan.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shape-plan.h b/src/java.desktop/share/native/libharfbuzz/hb-shape-plan.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shape-plan.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-shape-plan.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shape-plan.hh b/src/java.desktop/share/native/libharfbuzz/hb-shape-plan.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shape-plan.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-shape-plan.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shape.cc b/src/java.desktop/share/native/libharfbuzz/hb-shape.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shape.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-shape.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shape.h b/src/java.desktop/share/native/libharfbuzz/hb-shape.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shape.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-shape.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shaper-impl.hh b/src/java.desktop/share/native/libharfbuzz/hb-shaper-impl.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shaper-impl.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-shaper-impl.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shaper-list.hh b/src/java.desktop/share/native/libharfbuzz/hb-shaper-list.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shaper-list.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-shaper-list.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shaper.cc b/src/java.desktop/share/native/libharfbuzz/hb-shaper.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shaper.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-shaper.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shaper.hh b/src/java.desktop/share/native/libharfbuzz/hb-shaper.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shaper.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-shaper.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-static.cc b/src/java.desktop/share/native/libharfbuzz/hb-static.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-static.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-static.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-string-array.hh b/src/java.desktop/share/native/libharfbuzz/hb-string-array.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-string-array.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-string-array.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-cff-common.cc b/src/java.desktop/share/native/libharfbuzz/hb-subset-cff-common.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-cff-common.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-subset-cff-common.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-cff-common.hh b/src/java.desktop/share/native/libharfbuzz/hb-subset-cff-common.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-cff-common.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-subset-cff-common.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-cff1.cc b/src/java.desktop/share/native/libharfbuzz/hb-subset-cff1.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-cff1.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-subset-cff1.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-cff1.hh b/src/java.desktop/share/native/libharfbuzz/hb-subset-cff1.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-cff1.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-subset-cff1.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-cff2.cc b/src/java.desktop/share/native/libharfbuzz/hb-subset-cff2.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-cff2.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-subset-cff2.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-cff2.hh b/src/java.desktop/share/native/libharfbuzz/hb-subset-cff2.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-cff2.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-subset-cff2.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-glyf.cc b/src/java.desktop/share/native/libharfbuzz/hb-subset-glyf.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-glyf.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-subset-glyf.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-glyf.hh b/src/java.desktop/share/native/libharfbuzz/hb-subset-glyf.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-glyf.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-subset-glyf.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-input.cc b/src/java.desktop/share/native/libharfbuzz/hb-subset-input.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-input.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-subset-input.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-input.hh b/src/java.desktop/share/native/libharfbuzz/hb-subset-input.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-input.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-subset-input.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-plan.cc b/src/java.desktop/share/native/libharfbuzz/hb-subset-plan.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-plan.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-subset-plan.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-plan.hh b/src/java.desktop/share/native/libharfbuzz/hb-subset-plan.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset-plan.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-subset-plan.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset.cc b/src/java.desktop/share/native/libharfbuzz/hb-subset.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-subset.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset.h b/src/java.desktop/share/native/libharfbuzz/hb-subset.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-subset.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset.hh b/src/java.desktop/share/native/libharfbuzz/hb-subset.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-subset.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-subset.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ucdn.cc b/src/java.desktop/share/native/libharfbuzz/hb-ucdn.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ucdn.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ucdn.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ucdn/ucdn.c b/src/java.desktop/share/native/libharfbuzz/hb-ucdn/ucdn.c
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ucdn/ucdn.c
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ucdn/ucdn.c
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ucdn/ucdn.h b/src/java.desktop/share/native/libharfbuzz/hb-ucdn/ucdn.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ucdn/ucdn.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ucdn/ucdn.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ucdn/ucdn_db.h b/src/java.desktop/share/native/libharfbuzz/hb-ucdn/ucdn_db.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ucdn/ucdn_db.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-ucdn/ucdn_db.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-unicode-emoji-table.hh b/src/java.desktop/share/native/libharfbuzz/hb-unicode-emoji-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-unicode-emoji-table.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-unicode-emoji-table.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-unicode.cc b/src/java.desktop/share/native/libharfbuzz/hb-unicode.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-unicode.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-unicode.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-unicode.h b/src/java.desktop/share/native/libharfbuzz/hb-unicode.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-unicode.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-unicode.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-unicode.hh b/src/java.desktop/share/native/libharfbuzz/hb-unicode.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-unicode.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-unicode.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-utf.hh b/src/java.desktop/share/native/libharfbuzz/hb-utf.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-utf.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-utf.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-vector.hh b/src/java.desktop/share/native/libharfbuzz/hb-vector.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-vector.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb-vector.hh
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-version.h b/src/java.desktop/share/native/libharfbuzz/hb-version.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-version.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-version.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-warning.cc b/src/java.desktop/share/native/libharfbuzz/hb-warning.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-warning.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-warning.cc
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb.h b/src/java.desktop/share/native/libharfbuzz/hb.h
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb.h
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb.hh b/src/java.desktop/share/native/libharfbuzz/hb.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb.hh
+++ b/src/java.desktop/share/native/libharfbuzz/hb.hh
diff a/src/java.desktop/unix/classes/sun/awt/X11FontManager.java b/src/java.desktop/unix/classes/sun/awt/X11FontManager.java
--- a/src/java.desktop/unix/classes/sun/awt/X11FontManager.java
+++ b/src/java.desktop/unix/classes/sun/awt/X11FontManager.java
@@ -222,19 +222,17 @@
         if (fontID != null) {
             fileName = fontNameMap.get(fontID);
             if (fontPath == null &&
                 (fileName == null || !fileName.startsWith("/"))) {
                 if (FontUtilities.debugFonts()) {
-                    FontUtilities.getLogger()
-                          .warning("** Registering all font paths because " +
-                                   "can't find file for " + platName);
+                    FontUtilities.logWarning("** Registering all font paths because " +
+                                             "can't find file for " + platName);
                 }
                 fontPath = getPlatformFontPath(noType1Font);
                 registerFontDirs(fontPath);
                 if (FontUtilities.debugFonts()) {
-                    FontUtilities.getLogger()
-                            .warning("** Finished registering all font paths");
+                    FontUtilities.logWarning("** Finished registering all font paths");
                 }
                 fileName = fontNameMap.get(fontID);
             }
             if (fileName == null && !isHeadless()) {
                 /* Query X11 directly to see if this font is available
@@ -287,11 +285,11 @@
          * Arial.ttf -monotype-arial-regular-r-normal--0-0-0-0-p-0-iso8859-1
          * Arial-Bold.ttf -monotype-arial-bold-r-normal--0-0-0-0-p-0-iso8859-1
          * ...
          */
         if (FontUtilities.debugFonts()) {
-            FontUtilities.getLogger().info("ParseFontDir " + path);
+            FontUtilities.logInfo("ParseFontDir " + path);
         }
         File fontsDotDir = new File(path + File.separator + "fonts.dir");
         FileReader fr = null;
         try {
             if (fontsDotDir.canRead()) {
@@ -366,14 +364,13 @@
                             String fontPart = st.sval.substring(breakPos+1);
                             String fontID = specificFontIDForName(fontPart);
                             String sVal = fontNameMap.get(fontID);
 
                             if (FontUtilities.debugFonts()) {
-                                PlatformLogger logger = FontUtilities.getLogger();
-                                logger.info("file=" + fileName +
+                                FontUtilities.logInfo("file=" + fileName +
                                             " xlfd=" + fontPart);
-                                logger.info("fontID=" + fontID +
+                                FontUtilities.logInfo("fontID=" + fontID +
                                             " sVal=" + sVal);
                             }
                             String fullPath = null;
                             try {
                                 File file = new File(path,fileName);
@@ -392,20 +389,18 @@
                             } catch (IOException e) {
                                 fullPath = path + File.separator + fileName;
                             }
                             Vector<String> xVal = xlfdMap.get(fullPath);
                             if (FontUtilities.debugFonts()) {
-                                FontUtilities.getLogger()
-                                      .info("fullPath=" + fullPath +
-                                            " xVal=" + xVal);
+                                FontUtilities.logInfo("fullPath=" + fullPath +
+                                                      " xVal=" + xVal);
                             }
                             if ((xVal == null || !xVal.contains(fontPart)) &&
                                 (sVal == null) || !sVal.startsWith("/")) {
                                 if (FontUtilities.debugFonts()) {
-                                    FontUtilities.getLogger()
-                                          .info("Map fontID:"+fontID +
-                                                "to file:" + fullPath);
+                                    FontUtilities.logInfo("Map fontID:"+fontID +
+                                                          "to file:" + fullPath);
                                 }
                                 fontNameMap.put(fontID, fullPath);
                                 if (xVal == null) {
                                     xVal = new Vector<>();
                                     xlfdMap.put (fullPath, xVal);
@@ -479,12 +474,11 @@
             }
         }
 
         if (hyphenCnt != 14) {
             if (FontUtilities.debugFonts()) {
-                FontUtilities.getLogger()
-                    .severe("Font Configuration Font ID is malformed:" + name);
+                FontUtilities.logSevere("Font Configuration Font ID is malformed:" + name);
             }
             return name; // what else can we do?
         }
 
         StringBuffer sb =
@@ -509,12 +503,11 @@
             }
         }
 
         if (hyphenCnt != 14) {
             if (FontUtilities.debugFonts()) {
-                FontUtilities.getLogger()
-                    .severe("Font Configuration Font ID is malformed:" + name);
+                FontUtilities.logSevere("Font Configuration Font ID is malformed:" + name);
             }
             return name; // what else can we do?
         }
 
         String slant = name.substring(hPos[SLANT_FIELD-1]+1,
@@ -673,11 +666,11 @@
         if (fontConfigDirs == null) {
             fontConfigDirs = getFontConfiguration().getAWTFontPathSet();
             if (FontUtilities.debugFonts() && fontConfigDirs != null) {
                 String[] names = fontConfigDirs.toArray(new String[0]);
                 for (int i=0;i<names.length;i++) {
-                    FontUtilities.getLogger().info("awtfontpath : " + names[i]);
+                    FontUtilities.logInfo("awtfontpath : " + names[i]);
                 }
             }
         }
     }
 
diff a/src/java.desktop/unix/classes/sun/font/FcFontConfiguration.java b/src/java.desktop/unix/classes/sun/font/FcFontConfiguration.java
--- a/src/java.desktop/unix/classes/sun/font/FcFontConfiguration.java
+++ b/src/java.desktop/unix/classes/sun/font/FcFontConfiguration.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -538,12 +538,11 @@
                 warning(t.toString());
             }
         }
 
         if (FontUtilities.debugFonts()) {
-            PlatformLogger logger = FontUtilities.getLogger();
-            logger.info("successfully parsed the fontconfig file at " + fcFile.toString());
+            FontUtilities.logInfo("successfully parsed the fontconfig file at " + fcFile.toString());
         }
     }
 
     private static void warning(String msg) {
         PlatformLogger logger = PlatformLogger.getLogger("sun.awt.FontConfiguration");
diff a/src/java.desktop/unix/classes/sun/font/FontConfigManager.java b/src/java.desktop/unix/classes/sun/font/FontConfigManager.java
--- a/src/java.desktop/unix/classes/sun/font/FontConfigManager.java
+++ b/src/java.desktop/unix/classes/sun/font/FontConfigManager.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -193,24 +193,21 @@
         /* If don't find anything (eg no libfontconfig), then just return */
         for (int i = 0; i< fontArr.length; i++) {
             FcCompFont fci = fontArr[i];
             if (fci.firstFont == null) {
                 if (FontUtilities.isLogging()) {
-                    PlatformLogger logger = FontUtilities.getLogger();
-                    logger.info("Fontconfig returned no font for " +
-                                fontArr[i].fcName);
+                    FontUtilities.logInfo("Fontconfig returned no font for " + fontArr[i].fcName);
                 }
                 fontConfigFailed = true;
             } else if (anyFont == null) {
                 anyFont = fci.firstFont;
             }
         }
 
         if (anyFont == null) {
             if (FontUtilities.isLogging()) {
-                PlatformLogger logger = FontUtilities.getLogger();
-                logger.info("Fontconfig returned no fonts at all.");
+                FontUtilities.logInfo("Fontconfig returned no fonts at all.");
             }
             fontConfigFailed = true;
             return;
         } else if (fontConfigFailed) {
             for (int i = 0; i< fontArr.length; i++) {
@@ -221,26 +218,23 @@
         }
 
         fontConfigFonts = fontArr;
 
         if (FontUtilities.isLogging()) {
-
-            PlatformLogger logger = FontUtilities.getLogger();
-
             long t1 = System.nanoTime();
-            logger.info("Time spent accessing fontconfig="
+            FontUtilities.logInfo("Time spent accessing fontconfig="
                         + ((t1 - t0) / 1000000) + "ms.");
 
             for (int i = 0; i< fontConfigFonts.length; i++) {
                 FcCompFont fci = fontConfigFonts[i];
-                logger.info("FC font " + fci.fcName+" maps to family " +
+                FontUtilities.logInfo("FC font " + fci.fcName+" maps to family " +
                             fci.firstFont.familyName +
                             " in file " + fci.firstFont.fontFile);
                 if (fci.allFonts != null) {
                     for (int f=0;f<fci.allFonts.length;f++) {
                         FontConfigFont fcf = fci.allFonts[f];
-                        logger.info("Family=" + fcf.familyName +
+                        FontUtilities.logInfo("Family=" + fcf.familyName +
                                     " Style="+ fcf.styleStr +
                                     " Fullname="+fcf.fullName +
                                     " File="+fcf.fontFile);
                     }
                 }
@@ -358,14 +352,13 @@
         if (fcInfo == null) {
             fcInfo = fontConfigFonts[0];
         }
 
         if (FontUtilities.isLogging()) {
-            FontUtilities.getLogger()
-                          .info("FC name=" + name + " style=" + style +
-                                " uses " + fcInfo.firstFont.familyName +
-                                " in file: " + fcInfo.firstFont.fontFile);
+            FontUtilities.logInfo("FC name=" + name + " style=" + style +
+                                  " uses " + fcInfo.firstFont.familyName +
+                                  " in file: " + fcInfo.firstFont.fontFile);
         }
 
         if (fcInfo.compFont != null) {
             return fcInfo.compFont;
         }
diff a/src/java.desktop/unix/classes/sun/font/NativeStrike.java b/src/java.desktop/unix/classes/sun/font/NativeStrike.java
--- a/src/java.desktop/unix/classes/sun/font/NativeStrike.java
+++ b/src/java.desktop/unix/classes/sun/font/NativeStrike.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -114,13 +114,12 @@
          if (pScalerContext == 0L) {
              SunFontManager.getInstance().deRegisterBadFont(nativeFont);
              pScalerContext = createNullScalerContext();
              numGlyphs = 0;
              if (FontUtilities.isLogging()) {
-                 FontUtilities.getLogger()
-                                   .severe("Could not create native strike " +
-                                           new String(nameBytes));
+                 FontUtilities.logSevere("Could not create native strike " +
+                                         new String(nameBytes));
              }
              return;
          }
          numGlyphs = nativeFont.getMapper().getNumGlyphs();
          this.disposer = new NativeStrikeDisposer(nativeFont, desc,
diff a/src/java.management/share/classes/javax/management/AttributeChangeNotificationFilter.java b/src/java.management/share/classes/javax/management/AttributeChangeNotificationFilter.java
--- a/src/java.management/share/classes/javax/management/AttributeChangeNotificationFilter.java
+++ b/src/java.management/share/classes/javax/management/AttributeChangeNotificationFilter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -48,10 +48,14 @@
      * @serial {@link Vector} that contains the enabled attribute names.
      *         The default value is an empty vector.
      */
     private Vector<String> enabledAttributes = new Vector<String>();
 
+    /**
+     * Constructs an {@code AttributeChangeNotificationFilter}.
+     */
+    public AttributeChangeNotificationFilter() {}
 
     /**
      * Invoked before sending the specified notification to the listener.
      * <BR>This filter compares the attribute name of the specified attribute change notification
      * with each enabled attribute name.
diff a/src/java.management/share/classes/javax/management/DefaultLoaderRepository.java b/src/java.management/share/classes/javax/management/DefaultLoaderRepository.java
--- a/src/java.management/share/classes/javax/management/DefaultLoaderRepository.java
+++ b/src/java.management/share/classes/javax/management/DefaultLoaderRepository.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -48,10 +48,15 @@
  *
  * @since 1.5
  */
 @Deprecated
 public class DefaultLoaderRepository {
+    /**
+     * Constructs an {@code DefaultLoaderRepository}.
+     */
+    public DefaultLoaderRepository() {}
+
     /**
      * Go through the list of class loaders and try to load the requested class.
      * The method will stop as soon as the class is found. If the class
      * is not found the method will throw a <CODE>ClassNotFoundException</CODE>
      * exception.
diff a/src/java.management/share/classes/javax/management/NotificationFilterSupport.java b/src/java.management/share/classes/javax/management/NotificationFilterSupport.java
--- a/src/java.management/share/classes/javax/management/NotificationFilterSupport.java
+++ b/src/java.management/share/classes/javax/management/NotificationFilterSupport.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -66,10 +66,15 @@
      */
     @SuppressWarnings("serial") // Not statically typed as Serializable
     private List<String> enabledTypes = new Vector<String>();
 
 
+    /**
+     * Constructs a {@code NotificationFilterSupport}.
+     */
+    public NotificationFilterSupport() {}
+
     /**
      * Invoked before sending the specified notification to the listener.
      * <BR>This filter compares the type of the specified notification with each enabled type.
      * If the notification type matches one of the enabled types,
      * the notification should be sent to the listener and this method returns <CODE>true</CODE>.
diff a/src/java.management/share/classes/javax/management/QueryEval.java b/src/java.management/share/classes/javax/management/QueryEval.java
--- a/src/java.management/share/classes/javax/management/QueryEval.java
+++ b/src/java.management/share/classes/javax/management/QueryEval.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -39,10 +39,15 @@
     private static final long serialVersionUID = 2675899265640874796L;
 
     private static ThreadLocal<MBeanServer> server =
         new InheritableThreadLocal<MBeanServer>();
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public QueryEval() {}
+
     /**
      * <p>Sets the MBean server on which the query is to be performed.
      * The setting is valid for the thread performing the set.
      * It is copied to any threads created by that thread at the moment
      * of their creation.</p>
diff a/src/java.management/share/classes/javax/management/loading/DefaultLoaderRepository.java b/src/java.management/share/classes/javax/management/loading/DefaultLoaderRepository.java
--- a/src/java.management/share/classes/javax/management/loading/DefaultLoaderRepository.java
+++ b/src/java.management/share/classes/javax/management/loading/DefaultLoaderRepository.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -53,10 +53,15 @@
  * @since 1.5
  */
 @Deprecated
 public class DefaultLoaderRepository {
 
+    /**
+     * Constructs a {@code DefaultLoaderRepository}.
+     */
+    public DefaultLoaderRepository() {}
+
     /**
      * Go through the list of class loaders and try to load the requested
      * class.
      * The method will stop as soon as the class is found. If the class
      * is not found the method will throw a <CODE>ClassNotFoundException</CODE>
diff a/src/java.management/share/classes/javax/management/monitor/Monitor.java b/src/java.management/share/classes/javax/management/monitor/Monitor.java
--- a/src/java.management/share/classes/javax/management/monitor/Monitor.java
+++ b/src/java.management/share/classes/javax/management/monitor/Monitor.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -74,10 +74,15 @@
  */
 public abstract class Monitor
     extends NotificationBroadcasterSupport
     implements MonitorMBean, MBeanRegistration {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public Monitor() {}
+
     /*
      * ------------------------------------------
      *  PACKAGE CLASSES
      * ------------------------------------------
      */
diff a/src/java.management/share/classes/javax/management/relation/RoleStatus.java b/src/java.management/share/classes/javax/management/relation/RoleStatus.java
--- a/src/java.management/share/classes/javax/management/relation/RoleStatus.java
+++ b/src/java.management/share/classes/javax/management/relation/RoleStatus.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -31,10 +31,16 @@
  *
  * @since 1.5
  */
 public class RoleStatus {
 
+    /**
+     * Do not call.
+     */
+    @Deprecated(since="16", forRemoval=true)
+    public RoleStatus() {}
+
     //
     // Possible problems
     //
 
     /**
diff a/src/java.rmi/share/classes/java/rmi/server/RMIClassLoaderSpi.java b/src/java.rmi/share/classes/java/rmi/server/RMIClassLoaderSpi.java
--- a/src/java.rmi/share/classes/java/rmi/server/RMIClassLoaderSpi.java
+++ b/src/java.rmi/share/classes/java/rmi/server/RMIClassLoaderSpi.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -59,10 +59,15 @@
  * @see         RMIClassLoader
  * @since       1.4
  */
 public abstract class RMIClassLoaderSpi {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public RMIClassLoaderSpi() {}
+
     /**
      * Provides the implementation for
      * {@link RMIClassLoader#loadClass(URL,String)},
      * {@link RMIClassLoader#loadClass(String,String)}, and
      * {@link RMIClassLoader#loadClass(String,String,ClassLoader)}.
diff a/src/java.rmi/share/man/rmid.1 b/src/java.rmi/share/man/rmid.1
--- a/src/java.rmi/share/man/rmid.1
+++ b/src/java.rmi/share/man/rmid.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "RMID" "1" "2020" "JDK 14" "JDK Commands"
+.TH "RMID" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 rmid \- start the activation system daemon that enables objects to be
 registered and activated in a Java Virtual Machine (JVM)
@@ -36,10 +36,16 @@
 See \f[B]Options for rmid\f[R].
 .RS
 .RE
 .SH DESCRIPTION
 .PP
+\f[B]Deprecation Notice:\f[R] The rmid tool and the RMI Activation
+mechanism have been deprecated and may be removed from a future version
+of the platform.
+See \f[B]JEP 385\f[R] [https://openjdk.java.net/jeps/385] for further
+information.
+.PP
 The \f[CB]rmid\f[R] command starts the activation system daemon.
 The activation system daemon must be started before objects that can be
 activated are either registered with the activation system or activated
 in a JVM.
 .PP
@@ -77,15 +83,14 @@
 and a registry on the registry\[aq]s default port, 1099.
 .RS
 .PP
 \f[CB]rmid\ \-J\-Djava.security.policy=rmid.policy\ \-port\ 1099\f[R]
 .RE
-.SH START RMID ON DEMAND (ORACLE SOLARIS AND LINUX ONLY)
+.SH START RMID ON DEMAND (LINUX ONLY)
 .PP
 An alternative to starting \f[CB]rmid\f[R] from the command line is to
-configure \f[CB]inetd\f[R] (Oracle Solaris) or \f[CB]xinetd\f[R] (Linux) to
-start \f[CB]rmid\f[R] on demand.
+configure \f[CB]xinetd\f[R] (Linux) to start \f[CB]rmid\f[R] on demand.
 .PP
 When RMID starts, it attempts to obtain an inherited channel (inherited
 from \f[CB]inetd\f[R]/\f[CB]xinetd\f[R]) by calling the
 \f[CB]System.inheritedChannel\f[R] method.
 If the inherited channel is null or not an instance of
@@ -255,18 +260,18 @@
 \f[CB]rmid\f[R] command checks these permissions.
 .PP
 An example policy file that grants various execute permissions to the
 \f[CB]rmid\f[R] command is:
 .IP \[bu] 2
-\f[B]Oracle Solaris:\f[R]
+\f[B]Linux:\f[R]
 .RS 2
 .IP
 .nf
 \f[CB]
 grant\ {
 \ \ \ \ permission\ com.sun.rmi.rmid.ExecPermission
-\ \ \ \ \ \ \ \ "/files/apps/java/jdk1.7.0/solaris/bin/java";
+\ \ \ \ \ \ \ \ "/files/apps/java/jdk1.7.0/linux/bin/java";
 
 \ \ \ \ permission\ com.sun.rmi.rmid.ExecPermission
 \ \ \ \ \ \ \ \ "/files/apps/rmidcmds/*";
 
 \ \ \ \ permission\ com.sun.rmi.rmid.ExecOptionPermission
@@ -312,19 +317,17 @@
 explicit path name.
 By default, the version of the \f[CB]java\f[R] command found in
 \f[CB]java.home\f[R] is used (the same one that the \f[CB]rmid\f[R] command
 uses), and doesn\[aq]t need to be specified in the policy file.
 The second permission allows the \f[CB]rmid\f[R] command to execute any
-command in either the directory \f[CB]/files/apps/rmidcmds\f[R] (Oracle
-Solaris, Linux, and macOS) or the directory
-\f[CB]c:\\files\\apps\\rmidcmds\\\f[R] (Windows).
+command in either the directory \f[CB]/files/apps/rmidcmds\f[R] (Linux and
+macOS) or the directory \f[CB]c:\\files\\apps\\rmidcmds\\\f[R] (Windows).
 .PP
 The third permission granted, \f[CB]ExecOptionPermission\f[R], allows the
 \f[CB]rmid\f[R] command to start an activation group that defines the
 security policy file to be either \f[CB]/files/policies/group.policy\f[R]
-(Oracle Solaris) or \f[CB]c:\\files\\policies\\group.policy\f[R]
-(Windows).
+(Linux) or \f[CB]c:\\files\\policies\\group.policy\f[R] (Windows).
 The next permission allows the \f[CB]java.security.debug\ property\f[R] to
 be used by an activation group.
 The last permission allows any property in the
 \f[CB]sun.rmi\ property\f[R] name hierarchy to be used by activation
 groups.
diff a/src/java.rmi/share/man/rmiregistry.1 b/src/java.rmi/share/man/rmiregistry.1
--- a/src/java.rmi/share/man/rmiregistry.1
+++ b/src/java.rmi/share/man/rmiregistry.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "RMIREGISTRY" "1" "2020" "JDK 14" "JDK Commands"
+.TH "RMIREGISTRY" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 rmiregistry \- create and start a remote object registry on the
 specified port on the current host
diff a/src/java.scripting/share/man/jrunscript.1 b/src/java.scripting/share/man/jrunscript.1
--- a/src/java.scripting/share/man/jrunscript.1
+++ b/src/java.scripting/share/man/jrunscript.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 2006, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JRUNSCRIPT" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JRUNSCRIPT" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jrunscript \- run a command\-line script shell that supports interactive
 and batch modes
diff a/src/java.security.jgss/share/classes/org/ietf/jgss/GSSManager.java b/src/java.security.jgss/share/classes/org/ietf/jgss/GSSManager.java
--- a/src/java.security.jgss/share/classes/org/ietf/jgss/GSSManager.java
+++ b/src/java.security.jgss/share/classes/org/ietf/jgss/GSSManager.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -136,10 +136,15 @@
  * @see GSSContext
  * @since 1.4
  */
 public abstract class GSSManager {
 
+    /**
+     * Constructor for subclasses to call.
+     */
+    public GSSManager() {}
+
     /**
      * Returns the default GSSManager implementation.
      *
      * @return a GSSManager implementation
      */
diff a/src/java.security.jgss/share/classes/sun/security/krb5/internal/CredentialsUtil.java b/src/java.security.jgss/share/classes/sun/security/krb5/internal/CredentialsUtil.java
--- a/src/java.security.jgss/share/classes/sun/security/krb5/internal/CredentialsUtil.java
+++ b/src/java.security.jgss/share/classes/sun/security/krb5/internal/CredentialsUtil.java
@@ -163,11 +163,11 @@
      */
     public static Credentials acquireServiceCreds(
                 String service, Credentials ccreds)
             throws KrbException, IOException {
         PrincipalName sname = new PrincipalName(service,
-                PrincipalName.KRB_NT_SRV_HST);
+                PrincipalName.KRB_NT_UNKNOWN);
         return serviceCreds(sname, ccreds);
     }
 
     /**
      * Gets a TGT to another realm
diff a/src/java.sql.rowset/share/classes/javax/sql/rowset/RowSetMetaDataImpl.java b/src/java.sql.rowset/share/classes/javax/sql/rowset/RowSetMetaDataImpl.java
--- a/src/java.sql.rowset/share/classes/javax/sql/rowset/RowSetMetaDataImpl.java
+++ b/src/java.sql.rowset/share/classes/javax/sql/rowset/RowSetMetaDataImpl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -50,10 +50,14 @@
  * before the <code>RowSet</code> object contains data.
  *
  * @since 1.5
  */
 public class RowSetMetaDataImpl implements RowSetMetaData,  Serializable {
+    /**
+     * Constructs a {@code RowSetMetaDataImpl} object.
+     */
+    public RowSetMetaDataImpl() {}
 
     /**
      * The number of columns in the <code>RowSet</code> object that created
      * this <code>RowSetMetaDataImpl</code> object.
      * @serial
diff a/src/java.xml/share/classes/org/w3c/dom/package-info.java b/src/java.xml/share/classes/org/w3c/dom/package-info.java
--- a/src/java.xml/share/classes/org/w3c/dom/package-info.java
+++ b/src/java.xml/share/classes/org/w3c/dom/package-info.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -29,10 +29,46 @@
  * <a href="http://www.w3.org/TR/DOM-Level-3-Core">
  *     Document Object Model (DOM) Level 3 Core Specification</a>,
  * and <a href="http://www.w3.org/TR/DOM-Level-3-LS">
  *     Document Object Model (DOM) Level 3 Load and Save Specification</a>.
  *
+ * @apiNote
+ * The documentation comments for the get and set methods within this API are
+ * written as property definitions and are shared between both methods. These
+ * methods do not follow the standard Java SE specification format.
+ *
+ * <p>
+ * Take the {@link org.w3c.dom.Node Node} TextContent property as an example, both
+ * {@link org.w3c.dom.Node#getTextContent() getTextContent} and
+ * {@link org.w3c.dom.Node#setTextContent(String) setTextContent} shared the same
+ * content that defined the TextContent property itself.
+ *
+ * @implNote
+ * The JDK implementation of {@link org.w3c.dom.ls.LSSerializer LSSerializer}
+ * follows the <a href="https://www.w3.org/TR/xml/#charsets">Characters</a> section
+ * of the XML Specification in handling characters output. In particular, the
+ * specification defined a character range that excluded the surrogate blocks.
+ * As a result, the JDK LSSerializer writes characters in the surrogate blocks
+ * as Character References. Character {@code 0xf0 0x9f 0x9a 0xa9}
+ * (Unicode code point U+1F6A9) for example will be written as {@code &#128681;}.
+ *
+ * <p>
+ * This behavior is different from what was in the class description of
+ * {@link org.w3c.dom.ls.LSSerializer LSSerializer}. The relevant section is quoted
+ * below:
+ *
+ * <p>
+ * {@code Within the character data of a document (outside of markup), any characters
+ * that cannot be represented directly are replaced with character references...
+ * Any characters that cannot be represented directly in the output character encoding
+ * are serialized as numeric character references }
+ *
+ * <p>
+ * The JDK implementation does not follow this definition because it is not consistent
+ * with the XML Specification that defined an explicit character range with no
+ * association to the setting of the output character encoding.
+ *
  *
  * @since 1.4
  */
 
 package org.w3c.dom;
diff a/src/jdk.accessibility/windows/native/libwindowsaccessbridge/WinAccessBridge.cpp b/src/jdk.accessibility/windows/native/libwindowsaccessbridge/WinAccessBridge.cpp
--- a/src/jdk.accessibility/windows/native/libwindowsaccessbridge/WinAccessBridge.cpp
+++ b/src/jdk.accessibility/windows/native/libwindowsaccessbridge/WinAccessBridge.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -166,11 +166,11 @@
 
     /**
      * Our window proc
      *
      */
-    BOOL CALLBACK AccessBridgeDialogProc(HWND hDlg, UINT message, UINT wParam, LONG lParam) {
+    BOOL CALLBACK AccessBridgeDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
         COPYDATASTRUCT *sentToUs;
         char *package;
 
         switch (message) {
         case WM_INITDIALOG:
diff a/src/jdk.accessibility/windows/native/libwindowsaccessbridge/WinAccessBridge.h b/src/jdk.accessibility/windows/native/libwindowsaccessbridge/WinAccessBridge.h
--- a/src/jdk.accessibility/windows/native/libwindowsaccessbridge/WinAccessBridge.h
+++ b/src/jdk.accessibility/windows/native/libwindowsaccessbridge/WinAccessBridge.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -41,19 +41,14 @@
 extern "C" {
     BOOL WINAPI DllMain(HINSTANCE hinstDll, DWORD fdwReason,
                         LPVOID lpvReserved);
     void AppendToCallOutput(char *s);
     BOOL CALLBACK AccessBridgeDialogProc(HWND hDlg, UINT message,
-                                         UINT wParam, LONG lParam);
+                                         WPARAM wParam, LPARAM lParam);
     HWND getTopLevelHWND(HWND descendent);
 }
 
-LRESULT CALLBACK WinAccessBridgeWindowProc(HWND hWnd, UINT message,
-                                           UINT wParam, LONG lParam);
-
-BOOL CALLBACK DeleteItemProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
-
 /**
  * The WinAccessBridge class.  The core of the Windows AT AccessBridge dll
  */
 class WinAccessBridge {
     HINSTANCE windowsInstance;
diff a/src/jdk.aot/share/man/jaotc.1 b/src/jdk.aot/share/man/jaotc.1
--- a/src/jdk.aot/share/man/jaotc.1
+++ b/src/jdk.aot/share/man/jaotc.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JAOTC" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JAOTC" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jaotc \- The Java static compiler that produces native code for compiled
 Java methods
diff a/src/jdk.compiler/share/classes/com/sun/source/util/DocTreePathScanner.java b/src/jdk.compiler/share/classes/com/sun/source/util/DocTreePathScanner.java
--- a/src/jdk.compiler/share/classes/com/sun/source/util/DocTreePathScanner.java
+++ b/src/jdk.compiler/share/classes/com/sun/source/util/DocTreePathScanner.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2006, 2014, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -36,10 +36,15 @@
  * nodes.
  *
  * @since 1.8
  */
 public class DocTreePathScanner<R, P> extends DocTreeScanner<R, P> {
+    /**
+     * Constructs a {@code DocTreePathScanner}.
+     */
+    public DocTreePathScanner() {}
+
     /**
      * Scans a tree from a position identified by a tree path.
      * @param path the path
      * @param p a value to be passed to visitor methods
      * @return the result returned from the main visitor method
diff a/src/jdk.compiler/share/classes/com/sun/source/util/DocTreeScanner.java b/src/jdk.compiler/share/classes/com/sun/source/util/DocTreeScanner.java
--- a/src/jdk.compiler/share/classes/com/sun/source/util/DocTreeScanner.java
+++ b/src/jdk.compiler/share/classes/com/sun/source/util/DocTreeScanner.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -66,10 +66,14 @@
  * </pre>
  *
  * @since 1.8
  */
 public class DocTreeScanner<R,P> implements DocTreeVisitor<R,P> {
+    /**
+     * Constructs a {@code DocTreeScanner}.
+     */
+    public DocTreeScanner() {}
 
     /**
      * Scans a single node.
      * @param node the node to be scanned
      * @param p a parameter value passed to the visit method
diff a/src/jdk.compiler/share/classes/com/sun/source/util/DocTrees.java b/src/jdk.compiler/share/classes/com/sun/source/util/DocTrees.java
--- a/src/jdk.compiler/share/classes/com/sun/source/util/DocTrees.java
+++ b/src/jdk.compiler/share/classes/com/sun/source/util/DocTrees.java
@@ -44,10 +44,15 @@
  * Provides access to syntax trees for doc comments.
  *
  * @since 1.8
  */
 public abstract class DocTrees extends Trees {
+    /**
+     * Constructor for subclasses to call.
+     */
+    public DocTrees() {}
+
     /**
      * Returns a DocTrees object for a given CompilationTask.
      * @param task the compilation task for which to get the Trees object
      * @return the DocTrees object
      * @throws IllegalArgumentException if the task does not support the Trees API.
diff a/src/jdk.compiler/share/classes/com/sun/source/util/JavacTask.java b/src/jdk.compiler/share/classes/com/sun/source/util/JavacTask.java
--- a/src/jdk.compiler/share/classes/com/sun/source/util/JavacTask.java
+++ b/src/jdk.compiler/share/classes/com/sun/source/util/JavacTask.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -48,10 +48,14 @@
  * @author Peter von der Ah&eacute;
  * @author Jonathan Gibbons
  * @since 1.6
  */
 public abstract class JavacTask implements CompilationTask {
+    /**
+     * Constructor for subclasses to call.
+     */
+    public JavacTask() {}
 
     /**
      * Returns the {@code JavacTask} for a {@code ProcessingEnvironment}.
      * If the compiler is being invoked using a
      * {@link javax.tools.JavaCompiler.CompilationTask CompilationTask},
diff a/src/jdk.compiler/share/classes/com/sun/source/util/TreePathScanner.java b/src/jdk.compiler/share/classes/com/sun/source/util/TreePathScanner.java
--- a/src/jdk.compiler/share/classes/com/sun/source/util/TreePathScanner.java
+++ b/src/jdk.compiler/share/classes/com/sun/source/util/TreePathScanner.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2006, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -41,10 +41,14 @@
  *
  * @author Jonathan Gibbons
  * @since 1.6
  */
 public class TreePathScanner<R, P> extends TreeScanner<R, P> {
+    /**
+     * Constructs a {@code TreePathScanner}.
+     */
+    public TreePathScanner() {}
 
     /**
      * Scans a tree from a position identified by a TreePath.
      * @param path the path identifying the node to be scanned
      * @param p a parameter value passed to visit methods
diff a/src/jdk.compiler/share/classes/com/sun/source/util/TreeScanner.java b/src/jdk.compiler/share/classes/com/sun/source/util/TreeScanner.java
--- a/src/jdk.compiler/share/classes/com/sun/source/util/TreeScanner.java
+++ b/src/jdk.compiler/share/classes/com/sun/source/util/TreeScanner.java
@@ -73,10 +73,14 @@
  * @author Peter von der Ah&eacute;
  * @author Jonathan Gibbons
  * @since 1.6
  */
 public class TreeScanner<R,P> implements TreeVisitor<R,P> {
+    /**
+     * Constructs a {@code TreeScanner}.
+     */
+    public TreeScanner() {}
 
     /**
      * Scans a single node.
      * @param tree the node to be scanned
      * @param p a parameter value passed to the visit method
diff a/src/jdk.compiler/share/classes/com/sun/source/util/Trees.java b/src/jdk.compiler/share/classes/com/sun/source/util/Trees.java
--- a/src/jdk.compiler/share/classes/com/sun/source/util/Trees.java
+++ b/src/jdk.compiler/share/classes/com/sun/source/util/Trees.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2014, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -50,10 +50,15 @@
  * Bridges JSR 199, JSR 269, and the Tree API.
  *
  * @author Peter von der Ah&eacute;
  */
 public abstract class Trees {
+    /**
+     * Constructor for subclasses to call.
+     */
+    public Trees() {}
+
     /**
      * Returns a Trees object for a given CompilationTask.
      * @param task the compilation task for which to get the Trees object
      * @throws IllegalArgumentException if the task does not support the Trees API.
      * @return the Trees object
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/Main.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/Main.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/Main.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/Main.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -32,10 +32,15 @@
  * compiler, javac.
  * See the <a href="{@docRoot}/jdk.compiler/module-summary.html">{@code jdk.compiler}</a>
  * module for details on replacement APIs.
  */
 public class Main {
+    /**
+     * Do not call.
+     */
+    @Deprecated(since="16", forRemoval=true)
+    public Main(){}
 
     /** Main entry point for the launcher.
      *  Note: This method calls System.exit.
      *  @param args command line arguments
      *  @throws Exception only if an uncaught internal exception occurs;
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java
@@ -2905,14 +2905,13 @@
 
     /** Check an annotation of a symbol.
      */
     private void validateAnnotation(JCAnnotation a, JCTree declarationTree, Symbol s) {
         validateAnnotationTree(a);
-        boolean isRecordMember = (s.flags_field & RECORD) != 0 || s.enclClass() != null && s.enclClass().isRecord();
+        boolean isRecordMember = ((s.flags_field & RECORD) != 0 || s.enclClass() != null && s.enclClass().isRecord());
 
-        boolean isRecordField = isRecordMember &&
-                (s.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &&
+        boolean isRecordField = (s.flags_field & RECORD) != 0 &&
                 declarationTree.hasTag(VARDEF) &&
                 s.owner.kind == TYP;
 
         if (isRecordField) {
             // first we need to check if the annotation is applicable to records
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/DeferredAttr.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/DeferredAttr.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/DeferredAttr.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/DeferredAttr.java
@@ -917,10 +917,17 @@
             public void visitApply(JCMethodInvocation tree) {
                 //do nothing
             }
 
             @Override
+            public void visitConditional(JCTree.JCConditional tree) {
+                //skip tree.cond
+                scan(tree.truepart);
+                scan(tree.falsepart);
+            }
+
+            @Override
             public void visitReference(JCMemberReference tree) {
                 Assert.checkNonNull(tree.getOverloadKind());
                 Check.CheckContext checkContext = resultInfo.checkContext;
                 Type pt = resultInfo.pt;
                 if (!inferenceContext.inferencevars.contains(pt)) {
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java
@@ -2287,17 +2287,15 @@
         }
         return typeNotFound;
     }
 
     boolean isInnerClassOfMethod(Symbol msym, Symbol csym) {
-        if (csym.owner == msym && !csym.isStatic()) {
-            return true;
-        } else if (csym.owner.kind == TYP) {
-            return isInnerClassOfMethod(msym, csym.owner);
-        } else {
-            return false;
+        while (csym.owner != msym) {
+            if (csym.isStatic()) return false;
+            csym = csym.owner.enclClass();
         }
+        return (csym.owner == msym && !csym.isStatic());
     }
 
     /** Find an unqualified type symbol.
      *  @param env       The current environment.
      *  @param name      The type's name.
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeCopier.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeCopier.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeCopier.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeCopier.java
@@ -152,11 +152,17 @@
     @DefinedBy(Api.COMPILER_TREE)
     public JCTree visitCase(CaseTree node, P p) {
         JCCase t = (JCCase) node;
         List<JCExpression> pats = copy(t.pats, p);
         List<JCStatement> stats = copy(t.stats, p);
-        JCTree body = copy(t.body, p);
+        JCTree body;
+        if (node.getCaseKind() == CaseTree.CaseKind.RULE) {
+            body = t.body instanceof JCExpression && t.stats.head.hasTag(Tag.YIELD)
+                    ? ((JCYield) t.stats.head).value : t.stats.head;
+        } else {
+            body = null;
+        }
         return M.at(t.pos).Case(t.caseKind, pats, stats, body);
     }
 
     @DefinedBy(Api.COMPILER_TREE)
     public JCTree visitCatch(CatchTree node, P p) {
diff a/src/jdk.compiler/share/man/javac.1 b/src/jdk.compiler/share/man/javac.1
--- a/src/jdk.compiler/share/man/javac.1
+++ b/src/jdk.compiler/share/man/javac.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JAVAC" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JAVAC" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 javac \- read Java declarations and compile them into class files
 .SH SYNOPSIS
@@ -1025,11 +1025,11 @@
 Note that the following lists have no line\-continuation characters.
 .RS
 .PP
 Create a file named \f[CB]options\f[R] that contains the following:
 .PP
-\f[B]Oracle Solaris, Linux, and macOS:\f[R]
+\f[B]Linux and macOS:\f[R]
 .IP
 .nf
 \f[CB]
 \-d\ classes
 \-g
@@ -1272,11 +1272,11 @@
 .PP
 This example compiles the \f[CB]Aloha.java\f[R], \f[CB]GutenTag.java\f[R],
 \f[CB]Hello.java\f[R], and \f[CB]Hi.java\f[R] source files in the
 \f[CB]greetings\f[R] package.
 .PP
-\f[B]Oracle Solaris, Linux, and macOS:\f[R]
+\f[B]Linux and macOS:\f[R]
 .IP
 .nf
 \f[CB]
 %\ javac\ greetings/*.java
 %\ ls\ greetings
@@ -1298,11 +1298,11 @@
 .SS Example of Specifying a User Class Path
 .PP
 After changing one of the source files in the previous example,
 recompile it:
 .PP
-\f[B]Oracle Solaris, Linux, and macOS:\f[R]
+\f[B]Linux and macOS:\f[R]
 .IP
 .nf
 \f[CB]
 pwd
 /examples
@@ -1328,11 +1328,11 @@
 If you want to recompile this file without concern for which directory
 you are in, then add the examples directory to the user class path by
 setting \f[CB]CLASSPATH\f[R].
 This example uses the \f[CB]\-classpath\f[R] option.
 .PP
-\f[B]Oracle Solaris, Linux, and macOS:\f[R]
+\f[B]Linux and macOS:\f[R]
 .RS
 .PP
 \f[CB]javac\ \-classpath\ /examples\ /examples/greetings/Hi.java\f[R]
 .RE
 .PP
@@ -1343,11 +1343,11 @@
 .RE
 .PP
 If you change \f[CB]greetings.Hi\f[R] to use a banner utility, then that
 utility also needs to be accessible through the user class path.
 .PP
-\f[B]Oracle Solaris, Linux, and macOS:\f[R]
+\f[B]Linux and macOS:\f[R]
 .IP
 .nf
 \f[CB]
 javac\ \-classpath\ /examples:/lib/Banners.jar\ \\
 \ \ \ \ \ \ \ \ \ \ \ \ /examples/greetings/Hi.java
@@ -1365,11 +1365,11 @@
 .PP
 To execute a class in the \f[CB]greetings\f[R] package, the program needs
 access to the \f[CB]greetings\f[R] package, and to the classes that the
 \f[CB]greetings\f[R] classes use.
 .PP
-\f[B]Oracle Solaris, Linux, and macOS:\f[R]
+\f[B]Linux and macOS:\f[R]
 .RS
 .PP
 \f[CB]java\ \-classpath\ /examples:/lib/Banners.jar\ greetings.Hi\f[R]
 .RE
 .PP
@@ -1569,11 +1569,11 @@
 hierarchy\f[R], a \f[I]module hierarchy\f[R], and a \f[I]module source
 hierarchy\f[R].
 .PP
 While \f[CB]javac\f[R] is fairly relaxed about the organization of source
 code, beyond the expectation that source will be organized in one or
-package hierarchies, and can generally accomodate organizations
+package hierarchies, and can generally accommodate organizations
 prescribed by development environments and build tools, Java tools in
 general, and \f[CB]javac\f[R] and the Java launcher in particular, are
 more stringent regarding the organization of compiled class files, and
 will be organized in package hierarchies or module hierarchies, as
 appropriate.
@@ -2103,11 +2103,11 @@
 Such warnings cannot be suppressed with the \f[CB]\@SuppressWarnings\f[R]
 annotation.
 For example:
 .RS
 .IP \[bu] 2
-\f[B]Oracle Solaris, Linux, and macOS:\f[R]
+\f[B]Linux and macOS:\f[R]
 \f[CB]javac\ \-Xlint:path\ \-classpath\ /nonexistentpath\ Example.java\f[R]
 .IP \[bu] 2
 \f[B]Windows:\f[R]
 \f[CB]javac\ \-Xlint:path\ \-classpath\ C:\\nonexistentpath\ Example.java\f[R]
 .RE
diff a/src/jdk.compiler/share/man/serialver.1 b/src/jdk.compiler/share/man/serialver.1
--- a/src/jdk.compiler/share/man/serialver.1
+++ b/src/jdk.compiler/share/man/serialver.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "SERIALVER" "1" "2020" "JDK 14" "JDK Commands"
+.TH "SERIALVER" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 serialver \- return the \f[CB]serialVersionUID\f[R] for one or more
 classes in a form suitable for copying into an evolving class
diff a/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.c b/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.c
--- a/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.c
+++ b/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -206,15 +206,15 @@
   destroy_lib_info(ph);
   destroy_thread_info(ph);
   free(ph);
 }
 
-lib_info* add_lib_info(struct ps_prochandle* ph, const char* libname, uintptr_t base) {
-  return add_lib_info_fd(ph, libname, -1, base);
+lib_info* add_lib_info(struct ps_prochandle* ph, const char* libname, uintptr_t base, size_t memsz) {
+  return add_lib_info_fd(ph, libname, -1, base, memsz);
 }
 
-lib_info* add_lib_info_fd(struct ps_prochandle* ph, const char* libname, int fd, uintptr_t base) {
+lib_info* add_lib_info_fd(struct ps_prochandle* ph, const char* libname, int fd, uintptr_t base, size_t memsz) {
    lib_info* newlib;
   print_debug("add_lib_info_fd %s\n", libname);
 
   if ( (newlib = (lib_info*) calloc(1, sizeof(struct lib_info))) == NULL) {
     print_debug("can't allocate memory for lib_info\n");
@@ -227,10 +227,11 @@
     return NULL;
   }
   strcpy(newlib->name, libname);
 
   newlib->base = base;
+  newlib->memsz = memsz;
 
   if (fd == -1) {
     if ( (newlib->fd = pathmap_open(newlib->name)) < 0) {
       print_debug("can't open shared object %s\n", newlib->name);
       free(newlib);
@@ -260,11 +261,11 @@
 
   newlib->symtab = build_symtab(newlib->fd);
   if (newlib->symtab == NULL) {
     print_debug("symbol table build failed for %s\n", newlib->name);
   } else {
-    print_debug("built symbol table for %s\n", newlib->name);
+    print_debug("built symbol table for 0x%lx %s\n", newlib, newlib->name);
   }
 
   // even if symbol table building fails, we add the lib_info.
   // This is because we may need to read from the ELF file or MachO file for core file
   // address read functionality. lookup_symbol checks for NULL symtab.
@@ -303,12 +304,16 @@
 }
 
 const char* symbol_for_pc(struct ps_prochandle* ph, uintptr_t addr, uintptr_t* poffset) {
   const char* res = NULL;
   lib_info* lib = ph->libs;
+  print_debug("symbol_for_pc: addr 0x%lx\n", addr);
   while (lib) {
-    if (lib->symtab && addr >= lib->base) {
+    print_debug("symbol_for_pc: checking lib 0x%lx 0x%lx %s\n", lib->base, lib->memsz, lib->name);
+    if (lib->symtab && addr >= lib->base && addr < lib->base + lib->memsz) {
+      print_debug("symbol_for_pc: address=0x%lx offset=0x%lx found inside lib base=0x%lx memsz=0x%lx %s\n",
+                  addr, addr - lib->base, lib->base, lib->memsz, lib->name);
       res = nearest_symbol(lib->symtab, addr - lib->base, poffset);
       if (res) return res;
     }
     lib = lib->next;
   }
diff a/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h b/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h
--- a/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h
+++ b/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -93,10 +93,11 @@
   char             name[BUF_SIZE];
   uintptr_t        base;
   struct symtab*   symtab;
   int              fd;        // file descriptor for lib
   struct lib_info* next;
+  size_t           memsz;
 } lib_info;
 
 // list of threads
 typedef struct sa_thread_info {
    lwpid_t                  lwp_id;     // same as pthread_t
@@ -106,12 +107,12 @@
 } sa_thread_info;
 
 // list of virtual memory maps
 typedef struct map_info {
    int              fd;       // file descriptor
-   off_t            offset;   // file offset of this mapping
-   uintptr_t        vaddr;    // starting virtual address
+   uint64_t         offset;   // file offset of this mapping
+   uint64_t         vaddr;    // starting virtual address
    size_t           memsz;    // size of the mapping
    struct map_info* next;
 } map_info;
 
 // vtable for ps_prochandle
@@ -168,15 +169,15 @@
 
 // reads thread info using libthread_db and calls above callback for each thread
 bool read_thread_info(struct ps_prochandle* ph, thread_info_callback cb);
 
 // adds a new shared object to lib list, returns NULL on failure
-lib_info* add_lib_info(struct ps_prochandle* ph, const char* libname, uintptr_t base);
+lib_info* add_lib_info(struct ps_prochandle* ph, const char* libname, uintptr_t base, size_t memsz);
 
 // adds a new shared object to lib list, supply open lib file descriptor as well
 lib_info* add_lib_info_fd(struct ps_prochandle* ph, const char* libname, int fd,
-                          uintptr_t base);
+                          uintptr_t base, size_t memsz);
 
 sa_thread_info* add_thread_info(struct ps_prochandle* ph, pthread_t pthread_id, lwpid_t lwp_id);
 // a test for ELF signature without using libelf
 
 #ifdef __APPLE__
diff a/src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c b/src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c
--- a/src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c
+++ b/src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -239,22 +239,24 @@
     lseek(fd, offset, SEEK_SET);
     if (read(fd, (void *)&lcmd, sizeof(load_command)) != sizeof(load_command)) {
       goto err;
     }
     offset += lcmd.cmdsize;    // next command position
+    //print_debug("LC: 0x%x\n", lcmd.cmd);
     if (lcmd.cmd == LC_SEGMENT_64) {
       lseek(fd, -sizeof(load_command), SEEK_CUR);
       if (read(fd, (void *)&segcmd, sizeof(segment_command_64)) != sizeof(segment_command_64)) {
         print_debug("failed to read LC_SEGMENT_64 i = %d!\n", i);
         goto err;
       }
       if (add_map_info(ph, fd, segcmd.fileoff, segcmd.vmaddr, segcmd.vmsize) == NULL) {
         print_debug("Failed to add map_info at i = %d\n", i);
         goto err;
       }
-      print_debug("segment added: %" PRIu64 " 0x%" PRIx64 " %d\n",
-                   segcmd.fileoff, segcmd.vmaddr, segcmd.vmsize);
+      print_debug("LC_SEGMENT_64 added: nsects=%d fileoff=0x%llx vmaddr=0x%llx vmsize=0x%llx filesize=0x%llx %s\n",
+                  segcmd.nsects, segcmd.fileoff, segcmd.vmaddr, segcmd.vmsize,
+                  segcmd.filesize, &segcmd.segname[0]);
     } else if (lcmd.cmd == LC_THREAD || lcmd.cmd == LC_UNIXTHREAD) {
       typedef struct thread_fc {
         uint32_t  flavor;
         uint32_t  count;
       } thread_fc;
@@ -438,11 +440,11 @@
     off_t fpos = iter->offset;
     if (iter->fd != fd) {
       // only search core file!
       continue;
     }
-    print_debug("map_info %d: vmaddr = 0x%016" PRIx64 "  fileoff = %" PRIu64 "  vmsize = %" PRIu64 "\n",
+    print_debug("map_info %d: vmaddr = 0x%016llx fileoff = 0x%llx vmsize = 0x%lx\n",
                            j, iter->vaddr, iter->offset, iter->memsz);
     lseek(fd, fpos, SEEK_SET);
     // we assume .dylib loaded at segment address --- which is true for JVM libraries
     // multiple files may be loaded in one segment.
     // if first word is not a magic word, means this segment does not contain lib file.
@@ -462,11 +464,11 @@
       if (v != MH_MAGIC_64) {
         fpos = (ltell(fd) + pagesize -1)/pagesize * pagesize;
         continue;
       }
       lseek(fd, -sizeof(uint32_t), SEEK_CUR);
-      // this is the file begining to core file.
+      // This is the begining of the mach-o file in the segment.
       if (read(fd, (void *)&header, sizeof(mach_header_64)) != sizeof(mach_header_64)) {
         goto err;
       }
       fpos = ltell(fd);
 
@@ -495,22 +497,30 @@
           while (j < BUF_SIZE) {
             read(fd, (void *)(name + j), sizeof(char));
             if (name[j] == '\0') break;
             j++;
           }
-          print_debug("%s\n", name);
+          print_debug("%d %s\n", lcmd.cmd, name);
           // changed name from @rpath/xxxx.dylib to real path
           if (strrchr(name, '@')) {
             get_real_path(ph, name);
             print_debug("get_real_path returned: %s\n", name);
+          } else {
+            break; // Ignore non-relative paths, which are system libs. See JDK-8249779.
           }
-          add_lib_info(ph, name, iter->vaddr);
+          add_lib_info(ph, name, iter->vaddr, iter->memsz);
           break;
         }
       }
       // done with the file, advanced to next page to search more files
+#if 0
+      // This line is disabled due to JDK-8249779. Instead we break out of the loop
+      // and don't attempt to find any more mach-o files in this segment.
       fpos = (ltell(fd) + pagesize - 1) / pagesize * pagesize;
+#else
+      break;
+#endif
     }
   }
   return true;
 err:
   return false;
diff a/src/jdk.hotspot.agent/macosx/native/libsaproc/symtab.c b/src/jdk.hotspot.agent/macosx/native/libsaproc/symtab.c
--- a/src/jdk.hotspot.agent/macosx/native/libsaproc/symtab.c
+++ b/src/jdk.hotspot.agent/macosx/native/libsaproc/symtab.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -22,10 +22,11 @@
  *
  */
 
 #include <unistd.h>
 #include <search.h>
+#include <stddef.h>
 #include <stdlib.h>
 #include <string.h>
 #include <db.h>
 #include <fcntl.h>
 
@@ -55,16 +56,18 @@
 
 #ifdef __APPLE__
 
 void build_search_table(symtab_t *symtab) {
   int i;
+  print_debug("build_search_table\n");
   for (i = 0; i < symtab->num_symbols; i++) {
     DBT key, value;
     key.data = symtab->symbols[i].name;
     key.size = strlen(key.data) + 1;
     value.data = &(symtab->symbols[i]);
     value.size = sizeof(symtab_symbol);
+    //print_debug("build_search_table: %d 0x%x %s\n", i, symtab->symbols[i].offset, symtab->symbols[i].name);
     (*symtab->hash_table->put)(symtab->hash_table, &key, &value, 0);
 
     // check result
     if (is_debug()) {
       DBT rkey, rvalue;
@@ -90,14 +93,15 @@
 }
 
 // read symbol table from given fd.
 struct symtab* build_symtab(int fd) {
   symtab_t* symtab = NULL;
-  int i;
+  int i, j;
   mach_header_64 header;
   off_t image_start;
 
+  print_debug("build_symtab\n");
   if (!get_arch_off(fd, CPU_TYPE_X86_64, &image_start)) {
     print_debug("failed in get fat header\n");
     return NULL;
   }
   lseek(fd, image_start, SEEK_SET);
@@ -149,50 +153,63 @@
   // manipulate the hash table.
   symtab->hash_table = dbopen(NULL, O_CREAT | O_RDWR, 0600, DB_HASH, NULL);
   if (symtab->hash_table == NULL)
     goto quit;
 
+  // allocate the symtab
   symtab->num_symbols = symtabcmd.nsyms;
   symtab->symbols = (symtab_symbol *)malloc(sizeof(symtab_symbol) * symtab->num_symbols);
   symtab->strs    = (char *)malloc(sizeof(char) * symtabcmd.strsize);
   if (symtab->symbols == NULL || symtab->strs == NULL) {
      print_debug("out of memory: allocating symtab.symbol or symtab.strs\n");
      goto quit;
   }
-  lseek(fd, image_start + symtabcmd.symoff, SEEK_SET);
-  for (i = 0; i < symtab->num_symbols; i++) {
-    if (read(fd, (void *)&lentry, sizeof(nlist_64)) != sizeof(nlist_64)) {
-      print_debug("read nlist_64 failed at %i\n", i);
-      goto quit;
-    }
-    symtab->symbols[i].offset = lentry.n_value;
-    symtab->symbols[i].size  = lentry.n_un.n_strx;        // index
-  }
 
-  // string table
+  // read in the string table
   lseek(fd, image_start + symtabcmd.stroff, SEEK_SET);
   int size = read(fd, (void *)(symtab->strs), symtabcmd.strsize * sizeof(char));
   if (size != symtabcmd.strsize * sizeof(char)) {
      print_debug("reading string table failed\n");
      goto quit;
   }
 
-  for (i = 0; i < symtab->num_symbols; i++) {
-    symtab->symbols[i].name = symtab->strs + symtab->symbols[i].size;
-    if (i > 0) {
-      // fix size
-      symtab->symbols[i - 1].size = symtab->symbols[i].size - symtab->symbols[i - 1].size;
-      print_debug("%s size = %d\n", symtab->symbols[i - 1].name, symtab->symbols[i - 1].size);
+  // read in each nlist_64 from the symbol table and use to fill in symtab->symbols
+  lseek(fd, image_start + symtabcmd.symoff, SEEK_SET);
+  i = 0;
+  for (j = 0; j < symtab->num_symbols; j++) {
+    if (read(fd, (void *)&lentry, sizeof(nlist_64)) != sizeof(nlist_64)) {
+      print_debug("read nlist_64 failed at %j\n", j);
+      goto quit;
+    }
+
+    uintptr_t offset = lentry.n_value;     // offset of the symbol code/data in the file
+    uintptr_t stridx = lentry.n_un.n_strx; // offset of symbol string in the symtabcmd.symoff section
 
+    if (stridx == 0 || offset == 0) {
+      continue; // Skip this entry. It's not a reference to code or data
     }
+    symtab->symbols[i].offset = offset;
+    symtab->symbols[i].name = symtab->strs + stridx;
+    symtab->symbols[i].size = strlen(symtab->symbols[i].name);
 
-    if (i == symtab->num_symbols - 1) {
-      // last index
-      symtab->symbols[i].size =
-            symtabcmd.strsize - symtab->symbols[i].size;
-      print_debug("%s size = %d\n", symtab->symbols[i].name, symtab->symbols[i].size);
+    if (symtab->symbols[i].size == 0) {
+      continue; // Skip this entry. It points to an empty string.
     }
+
+    print_debug("symbol read: %d %d n_type=0x%x n_sect=0x%x n_desc=0x%x n_strx=0x%lx offset=0x%lx %s\n",
+                j, i, lentry.n_type, lentry.n_sect, lentry.n_desc, stridx, offset, symtab->symbols[i].name);
+    i++;
+  }
+
+  // Update symtab->num_symbols to be the actual number of symbols we added. Since the symbols
+  // array was allocated larger, reallocate it to the proper size.
+  print_debug("build_symtab: included %d of %d entries.\n", i, symtab->num_symbols);
+  symtab->num_symbols = i;
+  symtab->symbols = (symtab_symbol *)realloc(symtab->symbols, sizeof(symtab_symbol) * symtab->num_symbols);
+  if (symtab->symbols == NULL) {
+     print_debug("out of memory: reallocating symtab.symbol\n");
+     goto quit;
   }
 
   // build a hashtable for fast query
   build_search_table(symtab);
   return symtab;
@@ -387,16 +404,39 @@
 }
 
 const char* nearest_symbol(struct symtab* symtab, uintptr_t offset,
                            uintptr_t* poffset) {
   int n = 0;
+  char* result = NULL;
+  ptrdiff_t lowest_offset_from_sym = -1;
   if (!symtab) return NULL;
+  // Search the symbol table for the symbol that is closest to the specified offset, but is not under.
+  //
+  // Note we can't just use the first symbol that is >= the offset because the symbols may not be
+  // sorted by offset.
+  //
+  // Note this is a rather slow search that is O(n/2), and libjvm has as many as 250k symbols.
+  // Probably would be good to sort the array and do a binary search, or use a hash table like
+  // we do for name -> address lookups. However, this functionality is not used often and
+  // generally just involves one lookup, such as with the clhsdb "findpc" command.
   for (; n < symtab->num_symbols; n++) {
     symtab_symbol* sym = &(symtab->symbols[n]);
-    if (sym->name != NULL &&
-      offset >= sym->offset && offset < sym->offset + sym->size) {
-      if (poffset) *poffset = (offset - sym->offset);
-      return sym->name;
+    if (sym->size != 0 && offset >= sym->offset) {
+      ptrdiff_t offset_from_sym = offset - sym->offset;
+      if (offset_from_sym >= 0) { // ignore symbols that come after "offset"
+        if (lowest_offset_from_sym == -1 || offset_from_sym < lowest_offset_from_sym) {
+          lowest_offset_from_sym = offset_from_sym;
+          result = sym->name;
+          //print_debug("nearest_symbol: found %d %s 0x%x 0x%x 0x%x\n",
+          //            n, sym->name, offset, sym->offset, lowest_offset_from_sym);
+        }
+      }
     }
   }
-  return NULL;
+  print_debug("nearest_symbol: found symbol %d file_offset=0x%lx sym_offset=0x%lx %s\n",
+              n, offset, lowest_offset_from_sym, result);
+  // Save the offset from the symbol if requested.
+  if (result != NULL && poffset) {
+    *poffset = lowest_offset_from_sym;
+  }
+  return result;
 }
diff a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/CLHSDB.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/CLHSDB.java
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/CLHSDB.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/CLHSDB.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -193,11 +193,11 @@
         thread or the Swing/AWT event handler thread, so we must be very
         careful when creating or removing widgets */
     private void attachDebugger(final String executablePath, final String corePath) {
         // Try to open this core file
         try {
-            System.err.println("Opening core file, please wait...");
+            System.out.println("Opening core file, please wait...");
 
             // FIXME: display exec'd debugger's output messages during this
             // lengthy call
             agent.attach(executablePath, corePath);
             attached = true;
diff a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/tools/PMap.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/tools/PMap.java
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/tools/PMap.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/tools/PMap.java
@@ -52,19 +52,21 @@
    public void run(PrintStream out) {
       run(out, getAgent().getDebugger());
    }
 
    public void run(PrintStream out, Debugger dbg) {
-      if (PlatformInfo.getOS().equals("darwin")) {
-        out.println("Not available on Mac OS X");
-        return;
-      }
-
       CDebugger cdbg = dbg.getCDebugger();
       if (cdbg != null) {
          List<LoadObject> l = cdbg.getLoadObjectList();
-         for (Iterator<LoadObject> itr = l.iterator() ; itr.hasNext();) {
+         Iterator<LoadObject> itr = l.iterator();
+         if (!itr.hasNext() && PlatformInfo.getOS().equals("darwin")) {
+             // If the list is empty, we assume we attached to a process, and on OSX we can only
+             // get LoadObjects for a core file.
+             out.println("Not available for Mac OS X processes");
+             return;
+         }
+         while (itr.hasNext()) {
             LoadObject lo = itr.next();
             out.print(lo.getBase() + "\t");
             out.print(lo.getSize()/1024 + "K\t");
             out.println(lo.getName());
          }
diff a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/tools/PStack.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/tools/PStack.java
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/tools/PStack.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/tools/PStack.java
@@ -57,15 +57,10 @@
       Debugger dbg = getAgent().getDebugger();
       run(out, dbg);
    }
 
    public void run(PrintStream out, Debugger dbg) {
-      if (PlatformInfo.getOS().equals("darwin")) {
-        out.println("Not available on Mac OS X");
-        return;
-      }
-
       CDebugger cdbg = dbg.getCDebugger();
       if (cdbg != null) {
          ConcurrentLocksPrinter concLocksPrinter = null;
          // compute and cache java Vframes.
          initJFrameCache();
@@ -78,10 +73,16 @@
          } catch (Exception exp) {
             out.println("can't print deadlock information: " + exp.getMessage());
          }
 
          List<ThreadProxy> l = cdbg.getThreadList();
+         if (l.isEmpty() && PlatformInfo.getOS().equals("darwin")) {
+           // If the list is empty, we assume we attached to a process, and on OSX we can only
+           // get the native thread list for core files.
+           out.println("Not available for Mac OS X processes");
+           return;
+        }
          final boolean cdbgCanDemangle = cdbg.canDemangle();
          for (Iterator<ThreadProxy> itr = l.iterator() ; itr.hasNext();) {
             ThreadProxy th = itr.next();
             try {
                CFrame f = cdbg.topFrameForThread(th);
diff a/src/jdk.hotspot.agent/share/man/jhsdb.1 b/src/jdk.hotspot.agent/share/man/jhsdb.1
--- a/src/jdk.hotspot.agent/share/man/jhsdb.1
+++ b/src/jdk.hotspot.agent/share/man/jhsdb.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JHSDB" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JHSDB" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jhsdb \- attach to a Java process or launch a postmortem debugger to
 analyze the content of a core dump from a crashed Java Virtual Machine
@@ -67,18 +67,10 @@
 The process must be a Java process.
 To get a list of Java processes running on a machine, use the
 \f[CB]ps\f[R] command or, if the JVM processes are not running in a
 separate docker instance, the \f[B]jps\f[R] command.
 .RS
-.PP
-\f[B]Note:\f[R] JDK 10 has added support for using the Attach API when
-attaching to Java processes running in a separate docker process.
-However, the \f[CB]jps\f[R] command will not list the JVM processes that
-are running in a separate docker instance.
-If you are trying to connect a Linux host with a Virtual Machine that is
-in a docker container, you must use tools such as \f[CB]ps\f[R] to look up
-the PID of the JVM.
 .RE
 .TP
 .B \f[I]executable\f[R]
 The Java executable file from which the core dump was produced.
 .RS
@@ -169,10 +161,35 @@
 .B \f[CB]\-\-serverid\f[R] \f[I]server\-id\f[R]
 An optional unique ID for this debug server.
 This is required if multiple debug servers are run on the same machine.
 .RS
 .RE
+.TP
+.B \f[CB]\-\-rmiport\f[R] \f[I]port\f[R]
+Sets the port number to which the RMI connector is bound.
+If not specified a random available port is used.
+.RS
+.RE
+.TP
+.B \f[CB]\-\-registryport\f[R] \f[I]port\f[R]
+Sets the RMI registry port.
+This option overrides the system property
+\[aq]sun.jvm.hotspot.rmi.port\[aq].
+If not specified, the system property is used.
+If the system property is not set, the default port 1099 is used.
+.RS
+.RE
+.TP
+.B \f[CB]\-\-hostname\f[R] \f[I]hostname\f[R]
+Sets the hostname the RMI connector is bound.
+The value could be a hostname or an IPv4/IPv6 address.
+This option overrides the system property
+\[aq]java.rmi.server.hostname\[aq].
+If not specified, the system property is used.
+If the system property is not set, a system hostname is used.
+.RS
+.RE
 .SH OPTIONS FOR THE JINFO MODE
 .TP
 .B \f[CB]\-\-flags\f[R]
 Prints the VM flags.
 .RS
diff a/src/jdk.incubator.jpackage/linux/native/applauncher/LinuxLauncher.cpp b/src/jdk.incubator.jpackage/linux/native/applauncher/LinuxLauncher.cpp
--- a/src/jdk.incubator.jpackage/linux/native/applauncher/LinuxLauncher.cpp
+++ b/src/jdk.incubator.jpackage/linux/native/applauncher/LinuxLauncher.cpp
@@ -22,18 +22,28 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 #include <stdio.h>
+#include <stdlib.h>
 #include "AppLauncher.h"
 #include "FileUtils.h"
 #include "UnixSysInfo.h"
 #include "Package.h"
+#include "Log.h"
+#include "ErrorHandling.h"
 
 
 namespace {
 
+size_t hash(const std::string& str) {
+    size_t h = 0;
+    for(std::string::const_iterator it = str.begin(); it != str.end(); ++it) {
+        h = 31 * h + (*it & 0xff);
+    }
+    return h;
+}
 
 void launchApp() {
     setlocale(LC_ALL, "en_US.utf8");
 
     const tstring launcherPath = SysInfo::getProcessModulePath();
@@ -55,10 +65,60 @@
                     << _T("lib/runtime"));
     } else {
         ownerPackage.initAppLauncher(appLauncher);
     }
 
+    const std::string _JPACKAGE_LAUNCHER = "_JPACKAGE_LAUNCHER";
+
+    std::string launchInfo = SysInfo::getEnvVariable(std::nothrow,
+            _JPACKAGE_LAUNCHER, "");
+
+    const std::string thisLdLibraryPath = SysInfo::getEnvVariable(std::nothrow,
+            "LD_LIBRARY_PATH", "");
+
+    const size_t thisHash = hash(thisLdLibraryPath);
+
+    if (!launchInfo.empty()) {
+        LOG_TRACE(tstrings::any() << "Found "
+                << _JPACKAGE_LAUNCHER << "=[" << launchInfo << "]");
+
+        tistringstream iss(launchInfo);
+        iss.exceptions(std::ios::failbit | std::ios::badbit);
+
+        size_t hash = 0;
+        iss >> hash;
+
+        launchInfo = "";
+
+        if (thisHash != hash) {
+            // This launcher execution is the result of execve() call from
+            // withing JVM.
+            // This means all JVM arguments are already configured in launcher
+            // process command line.
+            // No need to construct command line for JVM.
+            LOG_TRACE("Not building JVM arguments from cfg file");
+            appLauncher.setInitJvmFromCmdlineOnly(true);
+        }
+    } else {
+        // Changed LD_LIBRARY_PATH environment variable might result in
+        // execve() call from within JVM.
+        // Set _JPACKAGE_LAUNCHER environment variable accordingly so that
+        // restarted launcher process can detect a restart.
+
+        launchInfo = (tstrings::any() << thisHash).str();
+    }
+
+    JP_TRY;
+    if (0 != setenv(_JPACKAGE_LAUNCHER.c_str(), launchInfo.c_str(), 1)) {
+        JP_THROW(tstrings::any() << "setenv(" << _JPACKAGE_LAUNCHER
+                << ", " << launchInfo << ") failed. Error: " << lastCRTError());
+    } else {
+        LOG_TRACE(tstrings::any() << "Set "
+                << _JPACKAGE_LAUNCHER << "=[" << launchInfo << "]");
+    }
+    JP_CATCH_ALL;
+
     appLauncher.launch();
 }
 
 } // namespace
 
diff a/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacDmgBundler.java b/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacDmgBundler.java
--- a/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacDmgBundler.java
+++ b/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacDmgBundler.java
@@ -357,11 +357,11 @@
                 hdiutil,
                 "attach",
                 protoDMG.toAbsolutePath().toString(),
                 hdiUtilVerbosityFlag,
                 "-mountroot", imagesRoot.toAbsolutePath().toString());
-        IOUtils.exec(pb, false, null, true);
+        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);
 
         Path mountedRoot = imagesRoot.resolve(APP_NAME.fetchFrom(params));
 
         // Copy app image, since we did not create DMG with it, but instead we created
         // empty one.
@@ -390,11 +390,11 @@
             // to install-dir in DMG as critical error, since it can fail in
             // headless enviroment.
             try {
                 pb = new ProcessBuilder("osascript",
                         getConfig_VolumeScript(params).toAbsolutePath().toString());
-                IOUtils.exec(pb);
+                IOUtils.exec(pb, 180); // Wait 3 minutes. See JDK-8248248.
             } catch (IOException ex) {
                 Log.verbose(ex);
             }
 
             // volume icon
diff a/src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/Executor.java b/src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/Executor.java
--- a/src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/Executor.java
+++ b/src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/Executor.java
@@ -28,10 +28,11 @@
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.List;
+import java.util.concurrent.TimeUnit;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
@@ -53,10 +54,20 @@
     Executor setWriteOutputToFile(boolean v) {
         writeOutputToFile = v;
         return this;
     }
 
+    Executor setTimeout(long v) {
+        timeout = v;
+        if (timeout != INFINITE_TIMEOUT) {
+            // Redirect output to file if timeout is requested, otherwise we will
+            // reading until process ends and timeout will never be reached.
+            setWriteOutputToFile(true);
+        }
+        return this;
+    }
+
     Executor setProcessBuilder(ProcessBuilder v) {
         pb = v;
         return this;
     }
 
@@ -101,11 +112,11 @@
         Process p = pb.start();
 
         int code = 0;
         if (writeOutputToFile) {
             try {
-                code = p.waitFor();
+                code = waitForProcess(p);
             } catch (InterruptedException ex) {
                 Log.verbose(ex);
                 throw new RuntimeException(ex);
             }
         }
@@ -182,10 +193,25 @@
             Log.verbose(ex);
             throw new RuntimeException(ex);
         }
     }
 
+    private int waitForProcess(Process p) throws InterruptedException {
+        if (timeout == INFINITE_TIMEOUT) {
+            return p.waitFor();
+        } else {
+            if (p.waitFor(timeout, TimeUnit.SECONDS)) {
+                return p.exitValue();
+            } else {
+                Log.verbose(String.format("Command %s timeout after %d seconds",
+                            createLogMessage(pb), timeout));
+                p.destroy();
+                return -1;
+            }
+        }
+    }
+
     static Executor of(String... cmdline) {
         return new Executor().setCommandLine(cmdline);
     }
 
     static Executor of(ProcessBuilder pb) {
@@ -199,11 +225,14 @@
             sb.append(String.format("in %s", pb.directory().getAbsolutePath()));
         }
         return sb.toString();
     }
 
+    public final static int INFINITE_TIMEOUT = -1;
+
     private ProcessBuilder pb;
     private boolean saveOutput;
     private boolean writeOutputToFile;
+    private long timeout = INFINITE_TIMEOUT;
     private List<String> output;
     private Consumer<Stream<String>> outputConsumer;
 }
diff a/src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/IOUtils.java b/src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/IOUtils.java
--- a/src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/IOUtils.java
+++ b/src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/IOUtils.java
@@ -146,33 +146,40 @@
         }
     }
 
     public static void exec(ProcessBuilder pb)
             throws IOException {
-        exec(pb, false, null, false);
+        exec(pb, false, null, false, Executor.INFINITE_TIMEOUT);
+    }
+
+    // timeout in seconds. -1 will be return if process timeouts.
+    public static void exec(ProcessBuilder pb, long timeout)
+            throws IOException {
+        exec(pb, false, null, false, timeout);
     }
 
     // See JDK-8236282
     // Reading output from some processes (currently known "hdiutil attach")
     // might hang even if process already exited. Only possible workaround found
     // in "hdiutil attach" case is to redirect the output to a temp file and then
     // read this file back.
     public static void exec(ProcessBuilder pb, boolean writeOutputToFile)
             throws IOException {
-        exec(pb, false, null, writeOutputToFile);
+        exec(pb, false, null, writeOutputToFile, Executor.INFINITE_TIMEOUT);
     }
 
     static void exec(ProcessBuilder pb, boolean testForPresenceOnly,
             PrintStream consumer) throws IOException {
-        exec(pb, testForPresenceOnly, consumer, false);
+        exec(pb, testForPresenceOnly, consumer, false, Executor.INFINITE_TIMEOUT);
     }
 
     static void exec(ProcessBuilder pb, boolean testForPresenceOnly,
-            PrintStream consumer, boolean writeOutputToFile) throws IOException {
+            PrintStream consumer, boolean writeOutputToFile, long timeout)
+            throws IOException {
         List<String> output = new ArrayList<>();
         Executor exec = Executor.of(pb).setWriteOutputToFile(writeOutputToFile)
-                .setOutputConsumer(lines -> {
+                .setTimeout(timeout).setOutputConsumer(lines -> {
             lines.forEach(output::add);
             if (consumer != null) {
                 output.forEach(consumer::println);
             }
         });
diff a/src/jdk.incubator.jpackage/share/man/jpackage.1 b/src/jdk.incubator.jpackage/share/man/jpackage.1
--- a/src/jdk.incubator.jpackage/share/man/jpackage.1
+++ b/src/jdk.incubator.jpackage/share/man/jpackage.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JPACKAGE" "1" "2019" "JDK 14" "JDK Commands"
+.TH "JPACKAGE" "1" "2019" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jpackage \- tool for packaging self\-contained Java applications.
 .SH SYNOPSIS
@@ -54,56 +54,56 @@
 .RS
 .PP
 This option can be used multiple times.
 .RE
 .TP
-.B \f[CB]\-\-type\f[R] or \f[CB]\-t\f[R] \f[I]type string\f[R]
+.B \f[CB]\-\-type\f[R] or \f[CB]\-t\f[R] <type string>
 The type of package to create
 .RS
 .PP
 Valid values are: {"app\-image", "exe", "msi", "rpm", "deb", "pkg",
 "dmg"}
 .PP
 If this option is not specified a platform dependent default type will
 be created.
 .RE
 .TP
-.B \f[CB]\-\-app\-version\f[R] \f[I]version\f[R]
+.B \f[CB]\-\-app\-version\f[R] <version>
 Version of the application and/or package`
 .RS
 .RE
 .TP
-.B \f[CB]\-\-copyright\f[R] \f[I]copyright string\f[R]
+.B \f[CB]\-\-copyright\f[R] <copyright string>
 Copyright for the application.
 .RS
 .RE
 .TP
-.B \f[CB]\-\-description\f[R] \f[I]description string\f[R]
+.B \f[CB]\-\-description\f[R] <description string>
 Description of the application.
 .RS
 .RE
 .TP
 .B \f[CB]\-\-help\f[R] or \f[CB]\-h\f[R]
 Print the usage text with a list and description of each valid option
 for the current platform to the output stream, and exit.
 .RS
 .RE
 .TP
-.B \f[CB]\-\-name\f[R] or \f[CB]\-n\f[R] \f[I]name\f[R]
+.B \f[CB]\-\-name\f[R] or \f[CB]\-n\f[R] <name>
 Name of the application and/or package.
 .RS
 .RE
 .TP
-.B \f[CB]\-\-dest\f[R] or \f[CB]\-d\f[R] \f[I]output path\f[R]
+.B \f[CB]\-\-dest\f[R] or \f[CB]\-d\f[R] <output path>
 Path where generated output file is placed
 .RS
 .PP
 Defaults to the current working directory.
 (absolute path or relative to the current directory).
 .RE
 .TP
-.B \f[CB]\-\-temp\f[R] \f[I]file path\f[R]
+.B \f[CB]\-\-temp\f[R] <file path>
 Path of a new or empty directory used to create temporary files
 (absolute path or relative to the current directory).
 .RS
 .PP
 If specified, the temp dir will not be removed upon the task completion
@@ -111,11 +111,11 @@
 .PP
 If not specified, a temporary directory will be created and removed upon
 the task completion.
 .RE
 .TP
-.B \f[CB]\-\-vendor\f[R] \f[I]vendor string\f[R]
+.B \f[CB]\-\-vendor\f[R] <vendor string>
 Vendor of the application.
 .RS
 .RE
 .TP
 .B \f[CB]\-\-verbose\f[R]
@@ -127,11 +127,11 @@
 Print the product version to the output stream and exit.
 .RS
 .RE
 .SS Options for creating the runtime image:
 .TP
-.B \f[CB]\-\-add\-modules\f[R] \f[I]module name\f[R] [\f[CB],\f[R]\f[I]module name\f[R]...]
+.B \f[CB]\-\-add\-modules\f[R] <module name> [\f[CB],\f[R]<module name>...]
 A comma (",") separated list of modules to add.
 .RS
 .PP
 This module list, along with the main module (if specified) will be
 passed to jlink as the \-\-add\-module argument.
@@ -140,11 +140,11 @@
 specified) are used.
 .PP
 This option can be used multiple times.
 .RE
 .TP
-.B \f[CB]\-\-module\-path\f[R] or \f[CB]\-p\f[R] \f[I]module path\f[R]...
+.B \f[CB]\-\-module\-path\f[R] or \f[CB]\-p\f[R] <module path>...
 A File.pathSeparator separated list of paths.
 .RS
 .PP
 Each path is either a directory of modules or the path to a modular jar,
 and is absolute or relative to the current directory.
@@ -156,11 +156,11 @@
 Pass on \-\-bind\-services option to jlink (which will link in service
 provider modules and their dependences).
 .RS
 .RE
 .TP
-.B \f[CB]\-\-runtime\-image\f[R] \f[I]file path\f[R]
+.B \f[CB]\-\-runtime\-image\f[R] <file paths>
 Path of the predefined runtime image that will be copied into the
 application image (absolute path or relative to the current directory).
 .RS
 .PP
 If \-\-runtime\-image is not specified, jpackage will run jlink to
@@ -168,27 +168,27 @@
 \-\-no\-header\-files, \-\-no\-man\-pages, and
 \-\-strip\-native\-commands.
 .RE
 .SS Options for creating the application image:
 .TP
-.B \f[CB]\-\-icon\f[R] \f[I]icon file path\f[R]
+.B \f[CB]\-\-icon\f[R] <icon file path>
 Path of the icon of the application bundle (absolute path or relative to
 the current directory).
 .RS
 .RE
 .TP
-.B \f[CB]\-\-input\f[R] or \f[CB]\-i\f[R] \f[I]input path\f[R]
+.B \f[CB]\-\-input\f[R] or \f[CB]\-i\f[R] <input path>
 Path of the input directory that contains the files to be packaged
 (absolute path or relative to the current directory).
 .RS
 .PP
 All files in the input directory will be packaged into the application
 image.
 .RE
 .SS Options for creating the application launcher(s):
 .TP
-.B \f[CB]\-\-add\-launcher\f[R] \f[I]launcher name\f[R]=\f[I]file path\f[R]
+.B \f[CB]\-\-add\-launcher\f[R] <launcher name>=<file path>
 Name of launcher, and a path to a Properties file that contains a list
 of key, value pairs (absolute path or relative to the current
 directory).
 .RS
 .PP
@@ -203,41 +203,41 @@
 Additional alternative launchers can be built using this option, and
 this option can be used multiple times to build multiple additional
 launchers.
 .RE
 .TP
-.B \f[CB]\-\-arguments\f[R] \f[I]main class arguments\f[R]
+.B \f[CB]\-\-arguments\f[R] <main class arguments>
 Command line arguments to pass to the main class if no command line
 arguments are given to the launcher.
 .RS
 .PP
 This option can be used multiple times.
 .RE
 .TP
-.B \f[CB]\-\-java\-options\f[R] \f[I]java options\f[R]
+.B \f[CB]\-\-java\-options\f[R] <java options>
 Options to pass to the Java runtime.
 .RS
 .PP
 This option can be used multiple times.
 .RE
 .TP
-.B \f[CB]\-\-main\-class\f[R] \f[I]class name\f[R]
+.B \f[CB]\-\-main\-class\f[R] <class name>
 Qualified name of the application main class to execute.
 .RS
 .PP
 This option can only be used if \-\-main\-jar is specified.
 .RE
 .TP
-.B \f[CB]\-\-main\-jar\f[R] \f[I]main jar file\f[R]
+.B \f[CB]\-\-main\-jar\f[R] <main jar file>
 The main JAR of the application; containing the main class (specified as
 a path relative to the input path).
 .RS
 .PP
 Either \-\-module or \-\-main\-jar option can be specified but not both.
 .RE
 .TP
-.B \f[CB]\-\-module\f[R] or \f[CB]\-m\f[R] \f[I]module name\f[R]/\f[I]main class\f[R]]
+.B \f[CB]\-\-module\f[R] or \f[CB]\-m\f[R] <module name>/<main class>]
 The main module (and optionally main class) of the application This
 module must be located on the module path.
 .RS
 .PP
 When this option is specified, the main module will be linked in the
@@ -252,32 +252,32 @@
 application which requires console interactions
 .RS
 .RE
 .SS macOS platform options (available only when running on macOS):
 .TP
-.B \f[CB]\-\-mac\-package\-identifier\f[R] \f[I]ID string\f[R]
+.B \f[CB]\-\-mac\-package\-identifier\f[R] <ID string>
 An identifier that uniquely identifies the application for macOSX.
 .RS
 .PP
 Defaults to the the main class name.
 .PP
 May only use alphanumeric (A\-Z,a\-z,0\-9), hyphen (\-), and period (.)
 characters.
 .RE
 .TP
-.B \f[CB]\-\-mac\-package\-name\f[R] \f[I]name string\f[R]
+.B \f[CB]\-\-mac\-package\-name\f[R] <name string>
 Name of the application as it appears in the Menu Bar.
 .RS
 .PP
 This can be different from the application name.
 .PP
 This name must be less than 16 characters long and be suitable for
 displaying in the menu bar and the application Info window.
 Defaults to the application name.
 .RE
 .TP
-.B \f[CB]\-\-mac\-bundle\-signing\-prefix\f[R] \f[I]prefix string\f[R]
+.B \f[CB]\-\-mac\-bundle\-signing\-prefix\f[R] <prefix string>
 When signing the application bundle, this value is prefixed to all
 components that need to be signed that don\[aq]t have an existing bundle
 identifier.
 .RS
 .RE
@@ -285,70 +285,70 @@
 .B \f[CB]\-\-mac\-sign\f[R]
 Request that the bundle be signed.
 .RS
 .RE
 .TP
-.B \f[CB]\-\-mac\-signing\-keychain\f[R] \f[I]file path\f[R]
+.B \f[CB]\-\-mac\-signing\-keychain\f[R] <file path>
 Path of the keychain to search for the signing identity (absolute path
 or relative to the current directory).
 .RS
 .PP
 If not specified, the standard keychains are used.
 .RE
 .TP
-.B \f[CB]\-\-mac\-signing\-key\-user\-name\f[R] \f[I]team name\f[R]
+.B \f[CB]\-\-mac\-signing\-key\-user\-name\f[R] <team name>
 Team name portion in Apple signing identities\[aq] names.
 .RS
 .PP
-For example "Developer ID Application: "
+For example "Developer ID Application: <team name>"
 .RE
 .SS Options for creating the application package:
 .TP
-.B \f[CB]\-\-app\-image\f[R] \f[I]file path\f[R]
+.B \f[CB]\-\-app\-image\f[R] <file path>
 Location of the predefined application image that is used to build an
 installable package (absolute path or relative to the current
 directory).
 .RS
 .PP
 See create\-app\-image mode options to create the application image.
 .RE
 .TP
-.B \f[CB]\-\-file\-associations\f[R] \f[I]file path\f[R]
+.B \f[CB]\-\-file\-associations\f[R] <file path>
 Path to a Properties file that contains list of key, value pairs
 (absolute path or relative to the current directory).
 .RS
 .PP
 The keys "extension", "mime\-type", "icon", and "description" can be
 used to describe the association.
 .PP
 This option can be used multiple times.
 .RE
 .TP
-.B \f[CB]\-\-install\-dir\f[R] \f[I]file path\f[R]
+.B \f[CB]\-\-install\-dir\f[R] <file path>
 Absolute path of the installation directory of the application on OS X
 or Linux.
 Relative sub\-path of the installation location of the application such
 as "Program Files" or "AppData" on Windows.
 .RS
 .RE
 .TP
-.B \f[CB]\-\-license\-file\f[R] \f[I]file path\f[R]
+.B \f[CB]\-\-license\-file\f[R] <file path>
 Path to the license file (absolute path or relative to the current
 directory).
 .RS
 .RE
 .TP
-.B \f[CB]\-\-resource\-dir\f[R] \f[I]path\f[R]
+.B \f[CB]\-\-resource\-dir\f[R] <path>
 Path to override jpackage resources (absolute path or relative to the
 current directory).
 .RS
 .PP
 Icons, template files, and other resources of jpackage can be
 over\-ridden by adding replacement resources to this directory.
 .RE
 .TP
-.B \f[CB]\-\-runtime\-image\f[R] \f[I]file\-path\f[R]
+.B \f[CB]\-\-runtime\-image\f[R] <file\-path>
 Path of the predefined runtime image to install (absolute path or
 relative to the current directory).
 .RS
 .PP
 Option is required when creating a runtime installer.
@@ -365,11 +365,11 @@
 .B \f[CB]\-\-win\-menu\f[R]
 Adds the application to the system menu.
 .RS
 .RE
 .TP
-.B \f[CB]\-\-win\-menu\-group\f[R] \f[I]menu group name\f[R]
+.B \f[CB]\-\-win\-menu\-group\f[R] <menu group name>
 Start Menu group this application is placed in.
 .RS
 .RE
 .TP
 .B \f[CB]\-\-win\-per\-user\-install\f[R]
@@ -380,49 +380,50 @@
 .B \f[CB]\-\-win\-shortcut\f[R]
 Creates a desktop shortcut for the application.
 .RS
 .RE
 .TP
-.B \f[CB]\-\-win\-upgrade\-uuid\f[R] \f[I]id string\f[R]
+.B \f[CB]\-\-win\-upgrade\-uuid\f[R] <id string>
 UUID associated with upgrades for this package.
 .RS
 .RE
 .SS Linux platform options (available only when running on Linux):
 .TP
-.B \f[CB]\-\-linux\-package\-name\f[R] \f[I]package name\f[R]
+.B \f[CB]\-\-linux\-package\-name\f[R] <package name>
 Name for Linux package, defaults to the application name.
 .RS
 .RE
 .TP
-.B \f[CB]\-\-linux\-deb\-maintainer\f[R] \f[I]email address\f[R]
+.B \f[CB]\-\-linux\-deb\-maintainer\f[R] <email address>
 Maintainer for .deb bundle.
 .RS
 .RE
 .TP
-.B \f[CB]\-\-linux\-menu\-group\f[R] \f[I]menu\-group\-name\f[R]
+.B \f[CB]\-\-linux\-menu\-group\f[R] <menu\-group\-name>
 Menu group this application is placed in.
 .RS
 .RE
 .TP
 .B \f[CB]\-\-linux\-package\-deps\f[R]
 Required packages or capabilities for the application
 .RS
 .RE
 .TP
-.B \f[CB]\-\-linux\-rpm\-license\-type\f[R] \f[I]type string\f[R]
-Type of the license ("License: " of the RPM .spec).
+.B \f[CB]\-\-linux\-rpm\-license\-type\f[R] <type string>
+Type of the license ("License: <value>" of the RPM .spec).
 .RS
 .RE
 .TP
-.B \f[CB]\-\-linux\-app\-release\f[R] \f[I]release string\f[R]
-Release value of the RPM .spec file or Debian revision value of the DEB
-control file.
+.B \f[CB]\-\-linux\-app\-release\f[R] <release string>
+Release value of the RPM <name>.spec file or Debian revision value of
+the DEB control file.
 .RS
 .RE
 .TP
-.B \f[CB]\-\-linux\-app\-category\f[R] \f[I]category string\f[R]
-Group value of the RPM .spec file or Section value of DEB control file.
+.B \f[CB]\-\-linux\-app\-category\f[R] <category string>
+Group value of the RPM <name>.spec file or Section value of DEB control
+file.
 .RS
 .RE
 .TP
 .B \f[CB]\-\-linux\-shortcut\f[R]
 Creates a shortcut for the application
diff a/src/jdk.incubator.jpackage/share/native/applauncher/AppLauncher.cpp b/src/jdk.incubator.jpackage/share/native/applauncher/AppLauncher.cpp
--- a/src/jdk.incubator.jpackage/share/native/applauncher/AppLauncher.cpp
+++ b/src/jdk.incubator.jpackage/share/native/applauncher/AppLauncher.cpp
@@ -33,10 +33,11 @@
 #include "SysInfo.h"
 #include "FileUtils.h"
 
 
 AppLauncher::AppLauncher() {
+    setInitJvmFromCmdlineOnly(false);
     launcherPath = SysInfo::getProcessModulePath();
     args = SysInfo::getCommandArgs();
 }
 
 
@@ -114,12 +115,21 @@
 
     std::unique_ptr<Jvm> jvm(new Jvm());
 
     (*jvm)
         .setPath(findJvmLib(cfgFile, defaultRuntimePath, jvmLibNames))
-        .addArgument(launcherPath)
-        .initFromConfigFile(cfgFile);
+        .addArgument(launcherPath);
+
+    if (initJvmFromCmdlineOnly) {
+        tstring_array::const_iterator argIt = args.begin();
+        const tstring_array::const_iterator argEnd = args.end();
+        for (; argIt != argEnd; ++argIt) {
+            (*jvm).addArgument(*argIt);
+        }
+    } else {
+        (*jvm).initFromConfigFile(cfgFile);
+    }
 
     return jvm.release();
 }
 
 
diff a/src/jdk.incubator.jpackage/share/native/applauncher/AppLauncher.h b/src/jdk.incubator.jpackage/share/native/applauncher/AppLauncher.h
--- a/src/jdk.incubator.jpackage/share/native/applauncher/AppLauncher.h
+++ b/src/jdk.incubator.jpackage/share/native/applauncher/AppLauncher.h
@@ -49,10 +49,15 @@
     AppLauncher& setAppDir(const tstring& v) {
         appDirPath = v;
         return *this;
     }
 
+    AppLauncher& setInitJvmFromCmdlineOnly(bool v) {
+        initJvmFromCmdlineOnly = v;
+        return *this;
+    }
+
     AppLauncher& addJvmLibName(const tstring& v) {
         jvmLibNames.push_back(v);
         return *this;
     }
 
@@ -76,8 +81,9 @@
     tstring launcherPath;
     tstring defaultRuntimePath;
     tstring appDirPath;
     tstring imageRoot;
     tstring_array jvmLibNames;
+    bool initJvmFromCmdlineOnly;
 };
 
 #endif // AppLauncher_h
diff a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java
--- a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java
@@ -555,14 +555,14 @@
      * the flag {@code JVMCICounterSize}.
      */
     native int getCountersSize();
 
     /**
-     * Change the size of the counters allocated for JVMCI. This requires a safepoint to
+     * Attempt to change the size of the counters allocated for JVMCI. This requires a safepoint to
      * safely reallocate the storage but it's advisable to increase the size in reasonable chunks.
      */
-    native void setCountersSize(int newSize);
+    native boolean setCountersSize(int newSize);
 
     /**
      * Determines if {@code metaspaceMethodData} is mature.
      */
     native boolean isMature(long metaspaceMethodData);
diff a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java
--- a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java
@@ -897,17 +897,18 @@
     public int getCountersSize() {
         return compilerToVm.getCountersSize();
     }
 
     /**
-     * Enlarge the number of per thread counters available. Requires a safepoint so
+     * Attempt to enlarge the number of per thread counters available. Requires a safepoint so
      * resizing should be rare to avoid performance effects.
      *
      * @param newSize
+     * @return false if the resizing failed
      */
-    public void setCountersSize(int newSize) {
-        compilerToVm.setCountersSize(newSize);
+    public boolean setCountersSize(int newSize) {
+        return compilerToVm.setCountersSize(newSize);
     }
 
     /**
      * The offset from the origin of an array to the first element.
      *
diff a/src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Main.java b/src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Main.java
--- a/src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Main.java
+++ b/src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Main.java
@@ -1057,221 +1057,213 @@
         List<String> info = new ArrayList<>();
 
         boolean signerNotExpired = expireDate == null
                 || expireDate.after(new Date());
 
-        if (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType ||
-                notYetValidCert || chainNotValidated || hasExpiredCert ||
-                hasUnsignedEntry || signerSelfSigned || (legacyAlg != 0) ||
-                (disabledAlg != 0) || aliasNotInStore || notSignedByAlias ||
-                tsaChainNotValidated ||
-                (hasExpiredTsaCert && !signerNotExpired)) {
-
-            if (strict) {
-                result = isSigning
-                        ? rb.getString("jar.signed.with.signer.errors.")
-                        : rb.getString("jar.verified.with.signer.errors.");
-            } else {
-                result = isSigning
-                        ? rb.getString("jar.signed.")
-                        : rb.getString("jar.verified.");
-            }
+        if (badKeyUsage) {
+            errors.add(isSigning
+                    ? rb.getString("The.signer.certificate.s.KeyUsage.extension.doesn.t.allow.code.signing.")
+                    : rb.getString("This.jar.contains.entries.whose.signer.certificate.s.KeyUsage.extension.doesn.t.allow.code.signing."));
+        }
 
-            if (badKeyUsage) {
-                errors.add(isSigning
-                        ? rb.getString("The.signer.certificate.s.KeyUsage.extension.doesn.t.allow.code.signing.")
-                        : rb.getString("This.jar.contains.entries.whose.signer.certificate.s.KeyUsage.extension.doesn.t.allow.code.signing."));
-            }
+        if (badExtendedKeyUsage) {
+            errors.add(isSigning
+                    ? rb.getString("The.signer.certificate.s.ExtendedKeyUsage.extension.doesn.t.allow.code.signing.")
+                    : rb.getString("This.jar.contains.entries.whose.signer.certificate.s.ExtendedKeyUsage.extension.doesn.t.allow.code.signing."));
+        }
 
-            if (badExtendedKeyUsage) {
-                errors.add(isSigning
-                        ? rb.getString("The.signer.certificate.s.ExtendedKeyUsage.extension.doesn.t.allow.code.signing.")
-                        : rb.getString("This.jar.contains.entries.whose.signer.certificate.s.ExtendedKeyUsage.extension.doesn.t.allow.code.signing."));
-            }
+        if (badNetscapeCertType) {
+            errors.add(isSigning
+                    ? rb.getString("The.signer.certificate.s.NetscapeCertType.extension.doesn.t.allow.code.signing.")
+                    : rb.getString("This.jar.contains.entries.whose.signer.certificate.s.NetscapeCertType.extension.doesn.t.allow.code.signing."));
+        }
 
-            if (badNetscapeCertType) {
-                errors.add(isSigning
-                        ? rb.getString("The.signer.certificate.s.NetscapeCertType.extension.doesn.t.allow.code.signing.")
-                        : rb.getString("This.jar.contains.entries.whose.signer.certificate.s.NetscapeCertType.extension.doesn.t.allow.code.signing."));
-            }
+        // only in verifying
+        if (hasUnsignedEntry) {
+            errors.add(rb.getString(
+                    "This.jar.contains.unsigned.entries.which.have.not.been.integrity.checked."));
+        }
 
-            // only in verifying
-            if (hasUnsignedEntry) {
-                errors.add(rb.getString(
-                        "This.jar.contains.unsigned.entries.which.have.not.been.integrity.checked."));
-            }
-            if (hasExpiredCert) {
-                errors.add(isSigning
-                        ? rb.getString("The.signer.certificate.has.expired.")
-                        : rb.getString("This.jar.contains.entries.whose.signer.certificate.has.expired."));
-            }
-            if (notYetValidCert) {
-                errors.add(isSigning
-                        ? rb.getString("The.signer.certificate.is.not.yet.valid.")
-                        : rb.getString("This.jar.contains.entries.whose.signer.certificate.is.not.yet.valid."));
-            }
+        if (hasExpiredCert) {
+            errors.add(isSigning
+                    ? rb.getString("The.signer.certificate.has.expired.")
+                    : rb.getString("This.jar.contains.entries.whose.signer.certificate.has.expired."));
+        }
 
-            if (chainNotValidated) {
-                errors.add(String.format(isSigning
-                                ? rb.getString("The.signer.s.certificate.chain.is.invalid.reason.1")
-                                : rb.getString("This.jar.contains.entries.whose.certificate.chain.is.invalid.reason.1"),
-                        chainNotValidatedReason.getLocalizedMessage()));
-            }
+        if (notYetValidCert) {
+            errors.add(isSigning
+                    ? rb.getString("The.signer.certificate.is.not.yet.valid.")
+                    : rb.getString("This.jar.contains.entries.whose.signer.certificate.is.not.yet.valid."));
+        }
 
-            if (hasExpiredTsaCert) {
-                errors.add(rb.getString("The.timestamp.has.expired."));
-            }
-            if (tsaChainNotValidated) {
-                errors.add(String.format(isSigning
-                                ? rb.getString("The.tsa.certificate.chain.is.invalid.reason.1")
-                                : rb.getString("This.jar.contains.entries.whose.tsa.certificate.chain.is.invalid.reason.1"),
-                        tsaChainNotValidatedReason.getLocalizedMessage()));
-            }
+        if (chainNotValidated) {
+            errors.add(String.format(isSigning
+                            ? rb.getString("The.signer.s.certificate.chain.is.invalid.reason.1")
+                            : rb.getString("This.jar.contains.entries.whose.certificate.chain.is.invalid.reason.1"),
+                    chainNotValidatedReason.getLocalizedMessage()));
+        }
 
-            // only in verifying
-            if (notSignedByAlias) {
-                errors.add(
-                        rb.getString("This.jar.contains.signed.entries.which.is.not.signed.by.the.specified.alias.es."));
+        if (tsaChainNotValidated) {
+            errors.add(String.format(isSigning
+                            ? rb.getString("The.tsa.certificate.chain.is.invalid.reason.1")
+                            : rb.getString("This.jar.contains.entries.whose.tsa.certificate.chain.is.invalid.reason.1"),
+                    tsaChainNotValidatedReason.getLocalizedMessage()));
+        }
+
+        // only in verifying
+        if (notSignedByAlias) {
+            errors.add(
+                    rb.getString("This.jar.contains.signed.entries.which.is.not.signed.by.the.specified.alias.es."));
+        }
+
+        // only in verifying
+        if (aliasNotInStore) {
+            errors.add(rb.getString("This.jar.contains.signed.entries.that.s.not.signed.by.alias.in.this.keystore."));
+        }
+
+        if (signerSelfSigned) {
+            errors.add(isSigning
+                    ? rb.getString("The.signer.s.certificate.is.self.signed.")
+                    : rb.getString("This.jar.contains.entries.whose.signer.certificate.is.self.signed."));
+        }
+
+        if (isSigning) {
+            if ((legacyAlg & 1) == 1) {
+                warnings.add(String.format(
+                        rb.getString("The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update."),
+                        digestalg, "-digestalg"));
             }
 
-            // only in verifying
-            if (aliasNotInStore) {
-                errors.add(rb.getString("This.jar.contains.signed.entries.that.s.not.signed.by.alias.in.this.keystore."));
+            if ((disabledAlg & 1) == 1) {
+                errors.add(String.format(
+                        rb.getString("The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.and.is.disabled."),
+                        digestalg, "-digestalg"));
             }
 
-            if (signerSelfSigned) {
-                errors.add(isSigning
-                        ? rb.getString("The.signer.s.certificate.is.self.signed.")
-                        : rb.getString("This.jar.contains.entries.whose.signer.certificate.is.self.signed."));
+            if ((legacyAlg & 2) == 2) {
+                warnings.add(String.format(
+                        rb.getString("The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update."),
+                        sigalg, "-sigalg"));
             }
 
-            if (isSigning) {
-                if ((legacyAlg & 1) == 1) {
-                    warnings.add(String.format(
-                            rb.getString("The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update."),
-                            digestalg, "-digestalg"));
-                }
+            if ((disabledAlg & 2) == 2) {
+                errors.add(String.format(
+                        rb.getString("The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.and.is.disabled."),
+                        sigalg, "-sigalg"));
+            }
 
-                if ((disabledAlg & 1) == 1) {
-                    errors.add(String.format(
-                            rb.getString("The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.and.is.disabled."),
-                            digestalg, "-digestalg"));
-                }
+            if ((legacyAlg & 4) == 4) {
+                warnings.add(String.format(
+                        rb.getString("The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update."),
+                        tSADigestAlg, "-tsadigestalg"));
+            }
 
-                if ((legacyAlg & 2) == 2) {
-                    warnings.add(String.format(
-                            rb.getString("The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update."),
-                            sigalg, "-sigalg"));
-                }
-                if ((disabledAlg & 2) == 2) {
-                    errors.add(String.format(
-                            rb.getString("The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.and.is.disabled."),
-                            sigalg, "-sigalg"));
-                }
+            if ((disabledAlg & 4) == 4) {
+                errors.add(String.format(
+                        rb.getString("The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.and.is.disabled."),
+                        tSADigestAlg, "-tsadigestalg"));
+            }
 
-                if ((legacyAlg & 4) == 4) {
-                    warnings.add(String.format(
-                            rb.getString("The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update."),
-                            tSADigestAlg, "-tsadigestalg"));
-                }
-                if ((disabledAlg & 4) == 4) {
-                    errors.add(String.format(
-                            rb.getString("The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.and.is.disabled."),
-                            tSADigestAlg, "-tsadigestalg"));
-                }
+            if ((legacyAlg & 8) == 8) {
+                warnings.add(String.format(
+                        rb.getString("The.1.signing.key.has.a.keysize.of.2.which.is.considered.a.security.risk..This.key.size.will.be.disabled.in.a.future.update."),
+                        privateKey.getAlgorithm(), KeyUtil.getKeySize(privateKey)));
+            }
 
-                if ((legacyAlg & 8) == 8) {
-                    warnings.add(String.format(
-                            rb.getString("The.1.signing.key.has.a.keysize.of.2.which.is.considered.a.security.risk..This.key.size.will.be.disabled.in.a.future.update."),
-                            privateKey.getAlgorithm(), KeyUtil.getKeySize(privateKey)));
-                }
-                if ((disabledAlg & 8) == 8) {
-                    errors.add(String.format(
-                            rb.getString("The.1.signing.key.has.a.keysize.of.2.which.is.considered.a.security.risk.and.is.disabled."),
-                            privateKey.getAlgorithm(), KeyUtil.getKeySize(privateKey)));
-                }
-            } else {
-                if ((legacyAlg & 1) != 0) {
-                    warnings.add(String.format(
-                            rb.getString("The.digest.algorithm.1.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update."),
-                            legacyDigestAlg));
-                }
+            if ((disabledAlg & 8) == 8) {
+                errors.add(String.format(
+                        rb.getString("The.1.signing.key.has.a.keysize.of.2.which.is.considered.a.security.risk.and.is.disabled."),
+                        privateKey.getAlgorithm(), KeyUtil.getKeySize(privateKey)));
+            }
+        } else {
+            if ((legacyAlg & 1) != 0) {
+                warnings.add(String.format(
+                        rb.getString("The.digest.algorithm.1.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update."),
+                        legacyDigestAlg));
+            }
 
-                if ((legacyAlg & 2) == 2) {
-                     warnings.add(String.format(
-                             rb.getString("The.signature.algorithm.1.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update."),
-                             legacySigAlg));
-                }
+            if ((legacyAlg & 2) == 2) {
+                warnings.add(String.format(
+                        rb.getString("The.signature.algorithm.1.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update."),
+                        legacySigAlg));
+            }
 
-                if ((legacyAlg & 4) != 0) {
-                    warnings.add(String.format(
-                            rb.getString("The.timestamp.digest.algorithm.1.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update."),
-                            legacyTsaDigestAlg));
-                }
+            if ((legacyAlg & 4) != 0) {
+                warnings.add(String.format(
+                        rb.getString("The.timestamp.digest.algorithm.1.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update."),
+                        legacyTsaDigestAlg));
+            }
 
-                if ((legacyAlg & 8) == 8) {
-                    warnings.add(String.format(
-                            rb.getString("The.1.signing.key.has.a.keysize.of.2.which.is.considered.a.security.risk..This.key.size.will.be.disabled.in.a.future.update."),
-                            weakPublicKey.getAlgorithm(), KeyUtil.getKeySize(weakPublicKey)));
-                }
+            if ((legacyAlg & 8) == 8) {
+                warnings.add(String.format(
+                        rb.getString("The.1.signing.key.has.a.keysize.of.2.which.is.considered.a.security.risk..This.key.size.will.be.disabled.in.a.future.update."),
+                        weakPublicKey.getAlgorithm(), KeyUtil.getKeySize(weakPublicKey)));
             }
-        } else {
-            result = isSigning ? rb.getString("jar.signed.") : rb.getString("jar.verified.");
         }
 
+        // This check must be placed after all other "errors.add()" calls were done.
         if (hasExpiredTsaCert) {
             // No need to warn about expiring if already expired
             hasExpiringTsaCert = false;
-        }
-
-        if (hasExpiringCert ||
-                (hasExpiringTsaCert  && expireDate != null) ||
-                (noTimestamp && expireDate != null) ||
-                (hasExpiredTsaCert && signerNotExpired) ||
-                permsDetected) {
-
-            if (hasExpiredTsaCert && signerNotExpired) {
+            // If there are already another errors, we just say it expired.
+            if (!signerNotExpired || !errors.isEmpty()) {
+                errors.add(rb.getString("The.timestamp.has.expired."));
+            } else if (signerNotExpired) {
                 if (expireDate != null) {
                     warnings.add(String.format(
                             rb.getString("The.timestamp.expired.1.but.usable.2"),
                             tsaExpireDate,
                             expireDate));
                 }
                 // Reset the flag so exit code is 0
                 hasExpiredTsaCert = false;
             }
-            if (hasExpiringCert) {
-                warnings.add(isSigning
-                        ? rb.getString("The.signer.certificate.will.expire.within.six.months.")
-                        : rb.getString("This.jar.contains.entries.whose.signer.certificate.will.expire.within.six.months."));
-            }
-            if (hasExpiringTsaCert && expireDate != null) {
-                if (expireDate.after(tsaExpireDate)) {
-                    warnings.add(String.format(rb.getString(
-                            "The.timestamp.will.expire.within.one.year.on.1.but.2"), tsaExpireDate, expireDate));
-                } else {
-                    warnings.add(String.format(rb.getString(
-                            "The.timestamp.will.expire.within.one.year.on.1"), tsaExpireDate));
-                }
-            }
-            if (noTimestamp && expireDate != null) {
-                if (hasTimestampBlock) {
-                    warnings.add(String.format(isSigning
-                            ? rb.getString("invalid.timestamp.signing")
-                            : rb.getString("bad.timestamp.verifying"), expireDate));
-                } else {
-                    warnings.add(String.format(isSigning
-                            ? rb.getString("no.timestamp.signing")
-                            : rb.getString("no.timestamp.verifying"), expireDate));
-                }
+        }
+
+        if (hasExpiringCert) {
+            warnings.add(isSigning
+                    ? rb.getString("The.signer.certificate.will.expire.within.six.months.")
+                    : rb.getString("This.jar.contains.entries.whose.signer.certificate.will.expire.within.six.months."));
+        }
+
+        if (hasExpiringTsaCert && expireDate != null) {
+            if (expireDate.after(tsaExpireDate)) {
+                warnings.add(String.format(rb.getString(
+                        "The.timestamp.will.expire.within.one.year.on.1.but.2"), tsaExpireDate, expireDate));
+            } else {
+                warnings.add(String.format(rb.getString(
+                        "The.timestamp.will.expire.within.one.year.on.1"), tsaExpireDate));
             }
-            if (permsDetected) {
-                warnings.add(rb.getString("posix.attributes.detected"));
+        }
+
+        if (noTimestamp && expireDate != null) {
+            if (hasTimestampBlock) {
+                warnings.add(String.format(isSigning
+                        ? rb.getString("invalid.timestamp.signing")
+                        : rb.getString("bad.timestamp.verifying"), expireDate));
+            } else {
+                warnings.add(String.format(isSigning
+                        ? rb.getString("no.timestamp.signing")
+                        : rb.getString("no.timestamp.verifying"), expireDate));
             }
         }
 
+        if (permsDetected) {
+            warnings.add(rb.getString("posix.attributes.detected"));
+        }
+
+        if ((strict) && (!errors.isEmpty())) {
+            result = isSigning
+                    ? rb.getString("jar.signed.with.signer.errors.")
+                    : rb.getString("jar.verified.with.signer.errors.");
+        } else {
+            result = isSigning
+                    ? rb.getString("jar.signed.")
+                    : rb.getString("jar.verified.");
+        }
         System.out.println(result);
+
         if (strict) {
             if (!errors.isEmpty()) {
                 System.out.println();
                 System.out.println(rb.getString("Error."));
                 errors.forEach(System.out::println);
@@ -1287,10 +1279,11 @@
                 System.out.println(rb.getString("Warning."));
                 errors.forEach(System.out::println);
                 warnings.forEach(System.out::println);
             }
         }
+
         if (!isSigning && (!errors.isEmpty() || !warnings.isEmpty())) {
             if (! (verbose != null && showcerts)) {
                 System.out.println();
                 System.out.println(rb.getString(
                         "Re.run.with.the.verbose.and.certs.options.for.more.details."));
diff a/src/jdk.jartool/share/man/jar.1 b/src/jdk.jartool/share/man/jar.1
--- a/src/jdk.jartool/share/man/jar.1
+++ b/src/jdk.jartool/share/man/jar.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JAR" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JAR" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jar \- create an archive for classes and resources, and manipulate or
 restore individual classes or resources from an archive
diff a/src/jdk.jartool/share/man/jarsigner.1 b/src/jdk.jartool/share/man/jarsigner.1
--- a/src/jdk.jartool/share/man/jarsigner.1
+++ b/src/jdk.jartool/share/man/jarsigner.1
@@ -1,7 +1,7 @@
 .\"t
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -20,11 +20,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JARSIGNER" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JARSIGNER" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jarsigner \- sign and verify Java Archive (JAR) files
 .SH SYNOPSIS
@@ -143,10 +143,13 @@
 file.
 Use the \f[CB]\-verify\f[R] option to verify a signed JAR file.
 .PP
 The \f[CB]jarsigner\f[R] command also attempts to validate the
 signer\[aq]s certificate after signing or verifying.
+During validation, it checks the revocation status of each certificate
+in the signer\[aq]s certificate chain when the \f[CB]\-revCheck\f[R]
+option is specified.
 If there is a validation error or any other problem, the command
 generates warning messages.
 If you specify the \f[CB]\-strict\f[R] option, then the command treats
 severe warnings as errors.
 See \f[B]Errors and Warnings\f[R].
@@ -174,12 +177,12 @@
 specifying the URL of the keystore to be used.
 The keystore is by default stored in a file named \f[CB]\&.keystore\f[R]
 in the user\[aq]s home directory, as determined by the
 \f[CB]user.home\f[R] system property.
 .PP
-\f[B]Oracle Solaris, Linux, and OS X:\f[R] \f[CB]user.home\f[R] defaults to
-the user\[aq]s home directory.
+\f[B]Linux and OS X:\f[R] \f[CB]user.home\f[R] defaults to the user\[aq]s
+home directory.
 .PP
 The input stream from the \f[CB]\-keystore\f[R] option is passed to the
 \f[CB]KeyStore.load\f[R] method.
 If \f[CB]NONE\f[R] is specified as the URL, then a null stream is passed
 to the \f[CB]KeyStore.load\f[R] method.
@@ -349,20 +352,25 @@
 .TE
 .PP
 These default signature algorithms can be overridden by using the
 \f[CB]\-sigalg\f[R] option.
 .PP
-Signed JAR file algorithms are checked against the
-\f[CB]jdk.jar.disabledAlgorithms\f[R] security property during
-verification (\f[CB]\-verify\f[R]).
+The \f[CB]jarsigner\f[R] command uses the
+\f[CB]jdk.jar.disabledAlgorithms\f[R] and
+\f[CB]jdk.security.legacyAlgorithms\f[R] security properties to determine
+which algorithms are considered a security risk.
 If the JAR file was signed with any algorithms that are disabled, it
 will be treated as an unsigned JAR file.
+If the JAR file was signed with any legacy algorithms, it will be
+treated as signed with an informational warning to inform users that the
+legacy algorithm will be disabled in a future update.
 For detailed verification output, include
 \f[CB]\-J\-Djava.security.debug=jar\f[R].
-The default value for the \f[CB]jdk.jar.disabledAlgorithms\f[R] security
-property is defined in the \f[CB]java.security\f[R] file (located in the
-JRE\[aq]s \f[CB]$JAVA_HOME/conf/security\f[R] directory).
+The \f[CB]jdk.jar.disabledAlgorithms\f[R] and
+\f[CB]jdk.security.legacyAlgorithms\f[R] security properties are defined
+in the \f[CB]java.security\f[R] file (located in the JDK\[aq]s
+\f[CB]$JAVA_HOME/conf/security\f[R] directory).
 .PP
 \f[B]Note:\f[R]
 .PP
 In order to improve out of the box security, default key size and
 signature algorithm names are periodically updated to stronger values
@@ -593,11 +601,11 @@
 .IP \[bu] 2
 \f[CB]\-keystore\ file:\f[R]\f[I]filePathAndName\f[R]
 .PP
 If the Sun PKCS #11 provider was configured in the
 \f[CB]java.security\f[R] security properties file (located in the
-JRE\[aq]s \f[CB]$JAVA_HOME/conf/security\f[R] directory), then the
+JDK\[aq]s \f[CB]$JAVA_HOME/conf/security\f[R] directory), then the
 \f[CB]keytool\f[R] and \f[CB]jarsigner\f[R] tools can operate on the PKCS
 #11 token by specifying these options:
 .RS
 .PP
 \f[CB]\-keystore\ NONE\ \-storetype\ PKCS11\f[R]
@@ -808,10 +816,21 @@
 If the public key certificate for a signer matches an entry in the
 keystore, then the alias name for the keystore entry for that signer is
 displayed in parentheses.
 .RE
 .TP
+.B \f[CB]\-revCheck\f[R]
+This option enables revocation checking of certificates when signing or
+verifying a JAR file.
+The \f[CB]jarsigner\f[R] command attempts to make network connections to
+fetch OCSP responses and CRLs if the \f[CB]\-revCheck\f[R] option is
+specified on the command line.
+Note that revocation checks are not enabled unless this option is
+specified.
+.RS
+.RE
+.TP
 .B \f[CB]\-tsa\f[R] \f[I]url\f[R]
 If \f[CB]\-tsa\ http://example.tsa.url\f[R] appears on the command line
 when signing a JAR file then a time stamp is generated for the
 signature.
 The URL, \f[CB]http://example.tsa.url\f[R], identifies the location of the
@@ -1029,11 +1048,11 @@
 An absolute path or a path relative to the current directory can be
 specified.
 If \f[I]classpathlist\f[R] contains multiple paths or JAR files, then
 they should be separated with a:
 .IP \[bu] 2
-Colon (\f[CB]:\f[R]) on Oracle Solaris, Linux, and macOS
+Colon (\f[CB]:\f[R]) on Linux and macOS
 .IP \[bu] 2
 Semicolon (\f[CB];\f[R]) on Windows
 .PP
 This option isn\[aq]t necessary when the class is already in the search
 path.
@@ -1071,11 +1090,11 @@
 KeyUsage extension that doesn\[aq]t allow it to sign a file, the
 \f[CB]jarsigner\f[R] command exits with code 12 (=4+8) when the
 \f[CB]\-strict\f[R] option is specified.
 .PP
 \f[B]Note:\f[R] Exit codes are reused because only the values from 0 to
-255 are legal on Oracle Solaris, Linux, and OS X.
+255 are legal on Linux and OS X.
 .PP
 The following sections describes the names, codes, and descriptions of
 the errors and warnings that the \f[CB]jarsigner\f[R] command can issue.
 .SH FAILURE
 .PP
@@ -1133,14 +1152,13 @@
 Code 4.
 This JAR contains entries whose signer certificate is self signed.
 .RS
 .RE
 .TP
-.B weakAlg
+.B disabledAlg
 Code 4.
-An algorithm specified on the command line is considered a security
-risk.
+An algorithm used is considered a security risk and is disabled.
 .RS
 .RE
 .TP
 .B badKeyUsage
 Code 8.
@@ -1204,10 +1222,15 @@
 .B hasExpiringTsaCert
 The timestamp will expire within one year on \f[CB]YYYY\-MM\-DD\f[R].
 .RS
 .RE
 .TP
+.B legacyAlg
+An algorithm used is considered a security risk but not disabled.
+.RS
+.RE
+.TP
 .B noTimestamp
 This JAR contains signatures that doesn\[aq]t include a timestamp.
 Without a timestamp, users may not be able to validate this JAR file
 after the signer certificate\[aq]s expiration date
 (\f[CB]YYYY\-MM\-DD\f[R]) or after any future revocation date.
diff a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractExecutableMemberWriter.java b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractExecutableMemberWriter.java
--- a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractExecutableMemberWriter.java
+++ b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractExecutableMemberWriter.java
@@ -175,18 +175,15 @@
      * @param member the member to write parameters for.
      * @param htmltree the content tree to which the parameters information will be added.
      */
     protected void addParameters(ExecutableElement member, Content htmltree) {
         Content paramTree = getParameters(member, false);
-        if (paramTree.isEmpty()) {
-            htmltree.add("()");
-        } else {
+        if (paramTree.charCount() > 2) {
+            // only add zero-width-space for non-empty parameters
             htmltree.add(Entity.ZERO_WIDTH_SPACE);
-            htmltree.add("(");
-            htmltree.add(paramTree);
-            paramTree.add(")");
         }
+        htmltree.add(paramTree);
     }
 
     /**
      * Add all the parameters for the executable member.
      *
@@ -194,17 +191,18 @@
      * @param includeAnnotations true if annotation information needs to be added.
      * @return the content tree containing the parameter information
      */
     protected Content getParameters(ExecutableElement member, boolean includeAnnotations) {
         Content paramTree = new ContentBuilder();
+        paramTree.add("(");
         String sep = "";
         List<? extends VariableElement> parameters = member.getParameters();
         TypeMirror rcvrType = member.getReceiverType();
         if (includeAnnotations && rcvrType != null && utils.isAnnotated(rcvrType)) {
             List<? extends AnnotationMirror> annotationMirrors = rcvrType.getAnnotationMirrors();
             addReceiverAnnotations(member, rcvrType, annotationMirrors, paramTree);
-            sep = "," + DocletConstants.NL;
+            sep = "," + DocletConstants.NL + " ";
         }
         int paramstart;
         ExecutableType instMeth = utils.asInstantiatedMethodType(typeElement, member);
         for (paramstart = 0; paramstart < parameters.size(); paramstart++) {
             paramTree.add(sep);
@@ -215,10 +213,11 @@
                 if (includeAnnotations) {
                     boolean foundAnnotations =
                             writer.addAnnotationInfo(param, paramTree);
                     if (foundAnnotations) {
                         paramTree.add(DocletConstants.NL);
+                        paramTree.add(" ");
                     }
                 }
                 addParam(member, param, paramType,
                     (paramstart == parameters.size() - 1) && member.isVarArgs(), paramTree);
                 break;
@@ -226,23 +225,26 @@
         }
 
         for (int i = paramstart + 1; i < parameters.size(); i++) {
             paramTree.add(",");
             paramTree.add(DocletConstants.NL);
+            paramTree.add(" ");
+
             if (includeAnnotations) {
                 boolean foundAnnotations =
                         writer.addAnnotationInfo(parameters.get(i),
                         paramTree);
                 if (foundAnnotations) {
                     paramTree.add(DocletConstants.NL);
+                    paramTree.add(" ");
                 }
             }
             addParam(member, parameters.get(i), instMeth.getParameterTypes().get(i),
                     (i == parameters.size() - 1) && member.isVarArgs(),
                     paramTree);
         }
-
+        paramTree.add(")");
         return paramTree;
     }
 
     /**
      * Get a content tree containing the exception information for the executable member.
diff a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractMemberWriter.java b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractMemberWriter.java
--- a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractMemberWriter.java
+++ b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractMemberWriter.java
@@ -684,16 +684,15 @@
          */
         private void appendParametersAndExceptions(Content htmltree, int lastLineSeparator) {
             // Record current position for indentation of exceptions
             int indentSize = htmltree.charCount() - lastLineSeparator;
 
-            if (parameters.isEmpty()) {
-                htmltree.add("()");
+            if (parameters.charCount() == 2) {
+                // empty parameters are added without packing
+                htmltree.add(parameters);
             } else {
-                parameters.add(")");
                 htmltree.add(Entity.ZERO_WIDTH_SPACE);
-                htmltree.add("(");
                 htmltree.add(HtmlTree.SPAN(HtmlStyle.parameters, parameters));
             }
 
             // Exceptions
             if (exceptions != null && !exceptions.isEmpty()) {
diff a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/resources/script.js b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/resources/script.js
--- a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/resources/script.js
+++ b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/resources/script.js
@@ -101,26 +101,28 @@
         && memberSearchIndex
         && tagSearchIndex;
 }
 
 // Workaround for scroll position not being included in browser history (8249133)
-document.addEventListener("DOMContentLoaded", function() {
+document.addEventListener("DOMContentLoaded", function(e) {
     var contentDiv = document.querySelector("div.flex-content");
-    window.onpopstate = function(e) {
+    window.addEventListener("popstate", function(e) {
         if (e.state !== null) {
             contentDiv.scrollTop = e.state;
         }
-    }
-    window.onhashchange = function(e) {
+    });
+    window.addEventListener("hashchange", function(e) {
         history.replaceState(contentDiv.scrollTop, document.title);
-    }
-    contentDiv.onscroll = function(e) {
+    });
+    contentDiv.addEventListener("scroll", function(e) {
         var timeoutID;
         if (!timeoutID) {
             timeoutID = setTimeout(function() {
                 history.replaceState(contentDiv.scrollTop, document.title);
                 timeoutID = null;
             }, 100);
         }
+    });
+    if (!location.hash) {
+        history.replaceState(contentDiv.scrollTop, document.title);
     }
-    history.replaceState(contentDiv.scrollTop, document.title);
 });
diff a/src/jdk.javadoc/share/man/javadoc.1 b/src/jdk.javadoc/share/man/javadoc.1
--- a/src/jdk.javadoc/share/man/javadoc.1
+++ b/src/jdk.javadoc/share/man/javadoc.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JAVADOC" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JAVADOC" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 javadoc \- generate HTML pages of API documentation from Java source
 files
@@ -139,11 +139,11 @@
 .IP \[bu] 2
 \f[CB]\-\-module\-source\-path\f[R]
 .IP \[bu] 2
 \f[CB]\-\-release\f[R]
 .IP \[bu] 2
-\f[CB]\-source\f[R]
+\f[CB]\-\-source\f[R] or \f[CB]\-source\f[R]
 .IP \[bu] 2
 \f[CB]\-\-source\-path\f[R] or \f[CB]\-sourcepath\f[R]
 .IP \[bu] 2
 \f[CB]\-\-system\f[R]
 .IP \[bu] 2
@@ -200,12 +200,12 @@
 If the starting class file is in a JAR file, then this option specifies
 the path to that JAR file.
 You can specify an absolute path or a path relative to the current
 directory.
 If \f[CB]classpathlist\f[R] contains multiple paths or JAR files, then
-they should be separated with a colon (\f[CB]:\f[R]) on Oracle Solaris and
-a semi\-colon (\f[CB];\f[R]) on Windows.
+they should be separated with a colon (\f[CB]:\f[R]) on Linux and a
+semi\-colon (\f[CB];\f[R]) on Windows.
 This option isn\[aq]t necessary when the \f[CB]doclet\f[R] starting class
 is already in the search path.
 .RS
 .RE
 .TP
@@ -220,11 +220,11 @@
 \f[CB]java.util\f[R], and \f[CB]java.math\f[R] (among others), but would
 exclude packages rooted at \f[CB]java.net\f[R] and \f[CB]java.lang\f[R].
 Notice that these examples exclude \f[CB]java.lang.ref\f[R], which is a
 subpackage of \f[CB]java.lang\f[R].
 .IP \[bu] 2
-\f[B]Oracle Solaris, Linux, and OS X:\f[R]
+\f[B]Linux and OS X:\f[R]
 .RS 2
 .RS
 .PP
 \f[CB]javadoc\ \-sourcepath\ /home/user/src\ \-subpackages\ java\ \-exclude\ java.net:java.lang\f[R]
 .RE
@@ -251,18 +251,17 @@
 dependencies of those modules.
 .IP \[bu] 2
 \f[CB]all\f[R]: includes all dependencies.
 .RE
 .TP
-.B \f[CB]\-help\f[R] or \f[CB]\-\-help\f[R]
-Displays the online help, which lists all of the \f[CB]javadoc\f[R] and
-\f[CB]doclet\f[R] command\-line options.
+.B \f[CB]\-\-help\f[R], \f[CB]\-help\f[R], \f[CB]\-h\f[R], or \f[CB]\-?\f[R]
+Prints a synopsis of the standard options.
 .RS
 .RE
 .TP
 .B \f[CB]\-\-help\-extra\f[R] or \f[CB]\-X\f[R]
-Prints a synopsis of non\-standard options and exits.
+Prints a synopsis of the set of extra options.
 .RS
 .RE
 .TP
 .B \f[CB]\-J\f[R]\f[I]flag\f[R]
 Passes \f[I]flag\f[R] directly to the Java Runtime Environment (JRE) that
@@ -403,11 +402,11 @@
 .PP
 For example, the following commands generates documentation for packages
 named \f[CB]java\f[R] and \f[CB]javax.swing\f[R] and all of their
 subpackages.
 .IP \[bu] 2
-\f[B]Oracle Solaris, Linux, and OS X:\f[R]
+\f[B]Linux and OS X:\f[R]
 .RS 2
 .RS
 .PP
 \f[CB]javadoc\ \-d\ docs\ \-sourcepath\ /home/user/src\ \-subpackages\ java:javax.swing\f[R]
 .RE
@@ -434,10 +433,15 @@
 .TP
 .B \f[CB]\-\-version\f[R]
 Prints version information.
 .RS
 .RE
+.TP
+.B \f[CB]\-Werror\f[R]
+Reports an error if any warnings occur.
+.RS
+.RE
 .SH EXTENDED OPTIONS
 .PP
 \f[B]Note:\f[R]
 .PP
 The extended options for \f[CB]javadoc\f[R] are subject to change without
@@ -455,23 +459,10 @@
 \f[CB]\-\-patch\-module\f[R]
 .IP \[bu] 2
 \f[CB]\-Xmaxerrs\f[R]
 .IP \[bu] 2
 \f[CB]\-Xmaxwarns\f[R]
-.PP
-The following extended \f[CB]javadoc\f[R] options are not equivalent to a
-corresponding \f[CB]javac\f[R] option:
-.TP
-.B \f[CB]\-Xmodule:\f[R]\f[I]module\-name\f[R]
-Specifies a module to which the classes being compiled belong.
-.RS
-.RE
-.TP
-.B \f[CB]\-Xold\f[R]
-Invokes the legacy javadoc tool.
-.RS
-.RE
 .SH STANDARD DOCLET OPTIONS
 .PP
 The following options are provided by the standard doclet.
 .TP
 .B \f[CB]\-\-add\-stylesheet\f[R] \f[I]file\f[R]
@@ -541,14 +532,13 @@
 working directory.
 The destination directory is automatically created when the
 \f[CB]javadoc\f[R] tool runs.
 .RS
 .IP \[bu] 2
-\f[B]Oracle Solaris, Linux, and OS X:\f[R] For example, the following
-command generates the documentation for the package
-\f[CB]com.mypackage\f[R] and saves the results in the \f[CB]/user/doc/\f[R]
-directory:
+\f[B]Linux and OS X:\f[R] For example, the following command generates
+the documentation for the package \f[CB]com.mypackage\f[R] and saves the
+results in the \f[CB]/user/doc/\f[R] directory:
 .RS 2
 .RS
 .PP
 \f[CB]javadoc\ \-d\ /user/doc/\ com.mypackage\f[R]
 .RE
@@ -631,15 +621,10 @@
 quotation marks.
 Use escape characters for any internal quotation marks within a footer.
 .RS
 .RE
 .TP
-.B \f[CB]\-\-frames\f[R]
-Enables the use of frames in the generated output (default).
-.RS
-.RE
-.TP
 .B \f[CB]\-group\f[R] \f[I]namep1\f[R]\f[CB]:\f[R]\f[I]p2\f[R]
 Group the specified packages together in the Overview page.
 .RS
 .RE
 .TP
@@ -666,11 +651,11 @@
 The \f[CB]javadoc\f[R] tool adjusts the links in the navigation bar
 accordingly.
 For example:
 .RS
 .IP \[bu] 2
-\f[B]Oracle Solaris, Linux, and OS X:\f[R]
+\f[B]Linux and OS X:\f[R]
 .RS 2
 .RS
 .PP
 \f[CB]javadoc\ \-helpfile\ /home/user/myhelp.html\ java.awt.\f[R]
 .RE
@@ -683,19 +668,13 @@
 \f[CB]javadoc\ \-helpfile\ C:\\user\\myhelp.html\ java.awt.\f[R]
 .RE
 .RE
 .RE
 .TP
-.B \f[CB]\-html4\f[R]
-Generates HTML 4.0.1 output.
-If the option is not used, \f[CB]\-html4\f[R] is the default
-.RS
-.RE
-.TP
 .B \f[CB]\-html5\f[R]
-Generates HTML 5 output.
-If the option is not used, \f[CB]\-html4\f[R] is the default.
+This option is a no\-op and is just retained for backwards
+compatibility.
 .RS
 .RE
 .TP
 .B \f[CB]\-\-javafx\f[R] or \f[CB]\-javafx\f[R]
 Enables JavaFX functionality.
@@ -921,11 +900,12 @@
 you want to make the navigation bar cleaner.
 .RS
 .RE
 .TP
 .B \f[CB]\-\-no\-frames\f[R]
-Disables the use of frames in the generated output.
+This option is a no\-op and is just retained for backwards
+compatibility.
 .RS
 .RE
 .TP
 .B \f[CB]\-nohelp\f[R]
 Omits the HELP link in the navigation bars at the top and bottom of each
@@ -1018,14 +998,13 @@
 \f[CB]overview.html\f[R] and place it in the source tree at the directory
 that contains the topmost package directories.
 In this location, no path is needed when documenting packages, because
 the \f[CB]\-sourcepath\f[R] option points to this file.
 .IP \[bu] 2
-\f[B]Oracle Solaris, Linux, and OS X:\f[R] For example, if the source
-tree for the \f[CB]java.lang\f[R] package is
-\f[CB]/src/classes/java/lang/\f[R], then you could place the overview file
-at /src/classes/overview.html.
+\f[B]Linux and OS X:\f[R] For example, if the source tree for the
+\f[CB]java.lang\f[R] package is \f[CB]/src/classes/java/lang/\f[R], then you
+could place the overview file at /src/classes/overview.html.
 .IP \[bu] 2
 \f[B]Windows:\f[R] For example, if the source tree for the
 \f[CB]java.lang\f[R] package is \f[CB]\\src\\classes\\java\\lang\\\f[R],
 then you could place the overview file at
 \f[CB]\\src\\classes\\overview.html\f[R]
@@ -1175,42 +1154,43 @@
 .RE
 .SH ADDITIONAL OPTIONS PROVIDED BY THE STANDARD DOCLET
 .PP
 The following are additional options provided by the standard doclet and
 are subject to change without notice.
-Additional options might are less commonly used or are otherwise
-regarded as advanced.
+Additional options are less commonly used or are otherwise regarded as
+advanced.
 .TP
 .B \f[CB]\-Xdoclint\f[R]
-Enables recommended checks for problems in Javadoc comments.
+Enables recommended checks for problems in documentation comments.
 .RS
 .RE
 .TP
 .B \f[CB]\-Xdoclint:\f[R](\f[CB]all\f[R]|\f[CB]none\f[R]|[\f[CB]\-\f[R]]\f[I]group\f[R])
-Enable or disable specific checks for bad references, lack of
-accessibility, missing Javadoc comments, and reports errors for invalid
-Javadoc syntax and missing HTML tags.
+Enable or disable specific checks for bad references, accessibility
+issues, missing documentation comments, errors in documentation comment
+syntax and missing HTML tags.
 .RS
 .PP
 This option enables the \f[CB]javadoc\f[R] tool to check for all
 documentation comments included in the generated output.
 You can select which items to include in the generated output with the
 standard options \f[CB]\-public\f[R], \f[CB]\-protected\f[R],
 \f[CB]\-package\f[R] and \f[CB]\-private\f[R].
 .PP
-When the \f[CB]\-Xdoclint\f[R] is enabled, it reports issues with messages
-similar to the \f[CB]javac\f[R] command.
+When the \f[CB]\-Xdoclint\f[R] option is enabled, it reports issues with
+messages similar to the \f[CB]javac\f[R] command.
 The \f[CB]javadoc\f[R] tool prints a message, a copy of the source line,
 and a caret pointing at the exact position where the error was detected.
 Messages may be either warnings or errors, depending on their severity
 and the likelihood to cause an error if the generated documentation were
-run through a validator.
-For example, bad references or missing Javadoc comments don\[aq]t cause
-the \f[CB]javadoc\f[R] tool to generate invalid HTML, so these issues are
-reported as warnings.
-Syntax errors or missing HTML end tags cause the \f[CB]javadoc\f[R] tool
-to generate invalid output, so these issues are reported as errors.
+to be run through a validator.
+For example: missing documentation comments, duplicate information, and
+extraneous comments do not cause the \f[CB]javadoc\f[R] tool to generate
+invalid HTML, so these issues are reported as warnings; syntax errors,
+missing required HTML end tags, and references to missing or misspelled
+elements cause the \f[CB]javadoc\f[R] tool to generate invalid output, so
+these issues are reported as errors.
 .PP
 \f[CB]\-Xdoclint\f[R] option validates input comments based upon the
 requested markup.
 .PP
 By default, the \f[CB]\-Xdoclint\f[R] option is enabled.
@@ -1242,21 +1222,21 @@
 [http://www.w3.org/TR/2014/REC\-html5\-20141028/] based on the standard
 doclet \f[CB]html\f[R] output generation selected.
 This type of check enables the \f[CB]javadoc\f[R] tool to detect HTML
 issues that some browsers might not interpret as intended.
 .IP \[bu] 2
-\f[CB]missing\f[R]: Checks for missing Javadoc comments or tags (for
+\f[CB]missing\f[R]: Checks for missing documentation comments or tags (for
 example, a missing comment or class, or a missing \f[CB]\@return\f[R] tag
 or similar tag on a method).
 .IP \[bu] 2
 \f[CB]reference\f[R]: Checks for issues relating to the references to Java
-API elements from Javadoc tags (for example, item not found in
-\f[CB]\@see\f[R], or a bad name after \f[CB]\@param)\f[R].
+API elements from documentation comment tags (for example, item not
+found in \f[CB]\@see\f[R], or a bad name after \f[CB]\@param)\f[R].
 .IP \[bu] 2
 \f[CB]syntax\f[R]: Checks for low level issues like unescaped angle
 brackets (\f[CB]<\f[R] and \f[CB]>\f[R]) and ampersands (\f[CB]&\f[R]) and
-invalid Javadoc tags.
+invalid documentation comment tags.
 .PP
 You can specify the \f[CB]\-Xdoclint\f[R] option multiple times to enable
 the option to check errors and warnings in multiple categories.
 Alternatively, you can specify multiple error and warning categories by
 using the preceding options.
diff a/src/jdk.jcmd/share/man/jcmd.1 b/src/jdk.jcmd/share/man/jcmd.1
--- a/src/jdk.jcmd/share/man/jcmd.1
+++ b/src/jdk.jcmd/share/man/jcmd.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JCMD" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JCMD" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jcmd \- send diagnostic command requests to a running Java Virtual
 Machine (JVM)
@@ -246,62 +246,10 @@
 .IP \[bu] 2
 \f[CB]\-all\f[R]: (Optional) Inspects all objects, including unreachable
 objects (BOOLEAN, false)
 .RE
 .TP
-.B \f[CB]GC.class_stats\f[R] [\f[I]options\f[R]] [\f[I]arguments\f[R]]
-(Deprecated) Provide statistics about Java class meta data.
-.RS
-.PP
-Impact: High \-\-\- depends on Java heap size and content.
-.PP
-\f[B]Note:\f[R]
-.PP
-The \f[I]options\f[R] must be specified using either \f[I]key\f[R] or
-\f[I]key\f[R]\f[CB]=\f[R]\f[I]value\f[R] syntax.
-.PP
-\f[I]options\f[R]:
-.IP \[bu] 2
-\f[CB]\-all\f[R]: (Optional) Shows all columns (BOOLEAN, false)
-.IP \[bu] 2
-\f[CB]\-csv\f[R]: (Optional) Prints in CSV (comma\-separated values)
-format for spreadsheets (BOOLEAN, false)
-.IP \[bu] 2
-\f[CB]\-help\f[R]: (Optional) Shows the meaning of all the columns
-(BOOLEAN, false)
-.PP
-\f[I]arguments\f[R]:
-.IP \[bu] 2
-\f[I]columns\f[R]: (Optional) Comma\-separated list of all the columns to
-be shown.
-If not specified, the following columns are shown:
-.RS 2
-.IP \[bu] 2
-InstBytes
-.IP \[bu] 2
-KlassBytes
-.IP \[bu] 2
-CpAll
-.IP \[bu] 2
-annotations
-.IP \[bu] 2
-MethodCount
-.IP \[bu] 2
-Bytecodes
-.IP \[bu] 2
-MethodAll
-.IP \[bu] 2
-ROAll
-.IP \[bu] 2
-RWAll
-.IP \[bu] 2
-Total
-.PP
-(STRING, no default value)
-.RE
-.RE
-.TP
 .B \f[CB]GC.finalizer_info\f[R]
 Provides information about the Java finalization queue.
 .RS
 .PP
 Impact: Medium
@@ -866,11 +814,11 @@
 Permission: \f[CB]java.lang.management.ManagementPermission(monitor)\f[R]
 .RE
 .TP
 .B \f[CB]VM.log\f[R] [\f[I]options\f[R]]
 Lists current log configuration, enables/disables/configures a log
-output, or ro tates all logs.
+output, or rotates all logs.
 .RS
 .PP
 Impact: Low
 .PP
 Permission: \f[CB]java.lang.management.ManagementPermission(control)\f[R]
diff a/src/jdk.jcmd/share/man/jinfo.1 b/src/jdk.jcmd/share/man/jinfo.1
--- a/src/jdk.jcmd/share/man/jinfo.1
+++ b/src/jdk.jcmd/share/man/jinfo.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 2004, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JINFO" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JINFO" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jinfo \- generate Java configuration information for a specified Java
 process
@@ -44,18 +44,10 @@
 The process must be a Java process.
 To get a list of Java processes running on a machine, use either the
 \f[CB]ps\f[R] command or, if the JVM processes are not running in a
 separate docker instance, the \f[B]jps\f[R] command.
 .RS
-.PP
-\f[B]Note:\f[R] JDK 10 has added support for using the Attach API when
-attaching to Java processes running in a separate docker process.
-However, the \f[CB]jps\f[R] command will not list the JVM processes that
-are running in a separate docker instance.
-If you are trying to connect a Linux host with a Virtual Machine that is
-in a docker container, you must use tools such as \f[CB]ps\f[R] to look up
-the PID of the JVM.
 .RE
 .SH DESCRIPTION
 .PP
 The \f[CB]jinfo\f[R] command prints Java configuration information for a
 specified Java process.
diff a/src/jdk.jcmd/share/man/jmap.1 b/src/jdk.jcmd/share/man/jmap.1
--- a/src/jdk.jcmd/share/man/jmap.1
+++ b/src/jdk.jcmd/share/man/jmap.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 2004, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JMAP" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JMAP" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jmap \- print details of a specified process
 .SH SYNOPSIS
@@ -44,18 +44,10 @@
 The process must be a Java process.
 To get a list of Java processes running on a machine, use either the
 \f[CB]ps\f[R] command or, if the JVM processes are not running in a
 separate docker instance, the \f[B]jps\f[R] command.
 .RS
-.PP
-\f[B]Note:\f[R] JDK 10 has added support for using the Attach API when
-attaching to Java processes running in a separate docker process.
-However, the \f[CB]jps\f[R] command will not list the JVM processes that
-are running in a separate docker instance.
-If you are trying to connect a Linux host with a Virtual Machine that is
-in a docker container, you must use tools such as \f[CB]ps\f[R] to look up
-the PID of the JVM.
 .RE
 .SH DESCRIPTION
 .PP
 The \f[CB]jmap\f[R] command prints details of a specified running process.
 .PP
diff a/src/jdk.jcmd/share/man/jps.1 b/src/jdk.jcmd/share/man/jps.1
--- a/src/jdk.jcmd/share/man/jps.1
+++ b/src/jdk.jcmd/share/man/jps.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 2004, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JPS" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JPS" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jps \- list the instrumented JVMs on the target system
 .SH SYNOPSIS
@@ -79,21 +79,10 @@
 The \f[CB]jps\f[R] command lists the instrumented Java HotSpot VMs on the
 target system.
 The command is limited to reporting information on JVMs for which it has
 the access permissions.
 .PP
-\f[B]Note:\f[R]
-.PP
-JDK 10 added support for using the Attach API when attaching to Java
-processes running in a separate docker process.
-However, the \f[CB]jps\f[R] tool cannot see JVM processes running in a
-separate docker instance.
-If you are trying to connect a Linux host with a Virtual Machine within
-a docker container, you must use tools such as \f[CB]ps\f[R] to look up
-the PID of the JVM and then specify the PID on the command line of the
-tools that accept the PID.
-.PP
 If the \f[CB]jps\f[R] command is run without specifying a \f[CB]hostid\f[R],
 then it searches for instrumented JVMs on the local host.
 If started with a \f[CB]hostid\f[R], then it searches for JVMs on the
 indicated host, using the specified protocol and port.
 A \f[CB]jstatd\f[R] process is assumed to be running on the target host.
diff a/src/jdk.jcmd/share/man/jstack.1 b/src/jdk.jcmd/share/man/jstack.1
--- a/src/jdk.jcmd/share/man/jstack.1
+++ b/src/jdk.jcmd/share/man/jstack.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 2004, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JSTACK" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JSTACK" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jstack \- print Java stack traces of Java threads for a specified Java
 process
@@ -44,18 +44,10 @@
 The process must be a Java process.
 To get a list of Java processes running on a machine, use either the
 \f[CB]ps\f[R] command or, if the JVM processes are not running in a
 separate docker instance, the \f[B]jps\f[R] command.
 .RS
-.PP
-\f[B]Note:\f[R] JDK 10 has added support for using the Attach API when
-attaching to Java processes running in a separate docker process.
-However, the \f[CB]jps\f[R] command will not list the JVM processes that
-are running in a separate docker instance.
-If you are trying to connect a Linux host with a Virtual Machine that is
-in a docker container, you must use tools such as \f[CB]ps\f[R] to look up
-the PID of the JVM.
 .RE
 .SH DESCRIPTION
 .PP
 The \f[CB]jstack\f[R] command prints Java stack traces of Java threads for
 a specified Java process.
diff a/src/jdk.jcmd/share/man/jstat.1 b/src/jdk.jcmd/share/man/jstat.1
--- a/src/jdk.jcmd/share/man/jstat.1
+++ b/src/jdk.jcmd/share/man/jstat.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 2004, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JSTAT" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JSTAT" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jstat \- monitor JVM statistics
 .SH SYNOPSIS
@@ -551,22 +551,14 @@
 identifier.
 The \f[I]lvmid\f[R] is typically, but not necessarily, the operating
 system\[aq]s process identifier for the target JVM process.
 You can use the \f[CB]jps\f[R] command to determine the \f[I]lvmid\f[R]
 provided the JVM processes is not running in a separate docker instance.
-You can also determine the \f[I]lvmid\f[R] on Oracle Solaris, Linux, and
-OS X platforms with the \f[CB]ps\f[R] command, and on Windows with the
-Windows Task Manager.
+You can also determine the \f[I]lvmid\f[R] on Linux and OS X platforms
+with the \f[CB]ps\f[R] command, and on Windows with the Windows Task
+Manager.
 .RS
-.PP
-\f[B]Note:\f[R] JDK 10 has added support for using the Attach API when
-attaching to Java processes running in a separate docker process.
-However, the \f[CB]jps\f[R] command will not list the JVM processes that
-are running in a separate docker instance.
-If you are trying to connect a Linux host with a Virtual Machine that is
-in a docker container, you must use tools such as \f[CB]ps\f[R] to look up
-the PID of the JVM.
 .RE
 .TP
 .B \f[I]hostname\f[R]
 A host name or IP address that indicates the target host.
 If the \f[I]hostname\f[R] value is omitted, then the target host is the
diff a/src/jdk.jconsole/share/man/jconsole.1 b/src/jdk.jconsole/share/man/jconsole.1
--- a/src/jdk.jconsole/share/man/jconsole.1
+++ b/src/jdk.jconsole/share/man/jconsole.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 2004, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JCONSOLE" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JCONSOLE" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jconsole \- start a graphical console to monitor and manage Java
 applications
diff a/src/jdk.jdeps/share/man/javap.1 b/src/jdk.jdeps/share/man/javap.1
--- a/src/jdk.jdeps/share/man/javap.1
+++ b/src/jdk.jdeps/share/man/javap.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JAVAP" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JAVAP" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 javap \- disassemble one or more class files
 .SH SYNOPSIS
@@ -77,11 +77,11 @@
 In tools that support \f[CB]\-\-\f[R] style options, the GNU\-style
 options can use the equal sign (\f[CB]=\f[R]) instead of a white space to
 separate the name of an option from its value.
 .SH OPTIONS FOR JAVAP
 .TP
-.B \f[CB]\-help\f[R], \f[CB]\-\-help\f[R] , or \f[CB]\-?\f[R]
+.B \f[CB]\-\-help\f[R], \f[CB]\-help\f[R] , \f[CB]\-h\f[R], or \f[CB]\-?\f[R]
 Prints a help message for the \f[CB]javap\f[R] command.
 .RS
 .RE
 .TP
 .B \f[CB]\-version\f[R]
diff a/src/jdk.jdeps/share/man/jdeprscan.1 b/src/jdk.jdeps/share/man/jdeprscan.1
--- a/src/jdk.jdeps/share/man/jdeprscan.1
+++ b/src/jdk.jdeps/share/man/jdeprscan.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JDEPRSCAN" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JDEPRSCAN" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jdeprscan \- static analysis tool that scans a jar file (or some other
 aggregation of class files) for uses of deprecated API elements
@@ -102,11 +102,11 @@
 .PP
 \f[I]path\f[R] can be a search path that consists of one or more
 directories separated by the system\-specific path separator.
 For example:
 .IP \[bu] 2
-\f[B]Oracle Solaris, Linux, and OS X:\f[R]
+\f[B]Linux and OS X:\f[R]
 .RS 2
 .RS
 .PP
 \f[CB]\-\-class\-path\ /some/directory:/another/different/dir\f[R]
 .RE
diff a/src/jdk.jdeps/share/man/jdeps.1 b/src/jdk.jdeps/share/man/jdeps.1
--- a/src/jdk.jdeps/share/man/jdeps.1
+++ b/src/jdk.jdeps/share/man/jdeps.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JDEPS" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JDEPS" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jdeps \- launch the Java class dependency analyzer
 .SH SYNOPSIS
@@ -335,11 +335,11 @@
 .SH EXAMPLE OF ANALYZING DEPENDENCIES
 .PP
 The following example demonstrates analyzing the dependencies of the
 \f[CB]Notepad.jar\f[R] file.
 .PP
-\f[B]Oracle Solaris, Linux, and OS X:\f[R]
+\f[B]Linux and OS X:\f[R]
 .IP
 .nf
 \f[CB]
 $\ jdeps\ demo/jfc/Notepad/Notepad.jar
 Notepad.jar\ \->\ java.base
diff a/src/jdk.jdi/share/classes/com/sun/jdi/Bootstrap.java b/src/jdk.jdi/share/classes/com/sun/jdi/Bootstrap.java
--- a/src/jdk.jdi/share/classes/com/sun/jdi/Bootstrap.java
+++ b/src/jdk.jdi/share/classes/com/sun/jdi/Bootstrap.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -36,10 +36,15 @@
  * @author Gordon Hirsch
  * @since  1.3
  */
 
 public class Bootstrap extends Object {
+    /**
+     * Do not call.
+     */
+    @Deprecated(since="16", forRemoval=true)
+    public Bootstrap() {}
 
     /**
      * Returns the virtual machine manager.
      *
      * <p> May throw an unspecified error if initialization of the
diff a/src/jdk.jdi/share/classes/com/sun/jdi/connect/spi/Connection.java b/src/jdk.jdi/share/classes/com/sun/jdi/connect/spi/Connection.java
--- a/src/jdk.jdi/share/classes/com/sun/jdi/connect/spi/Connection.java
+++ b/src/jdk.jdi/share/classes/com/sun/jdi/connect/spi/Connection.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -53,10 +53,14 @@
  * be writing at any given time.
  *
  * @since 1.5
  */
 public abstract class Connection {
+    /**
+     * Constructor for subclasses to call.
+     */
+    public Connection() {}
 
     /**
      * Reads a packet from the target VM.
      *
      * <p> Attempts to read a JDWP packet from the target VM.
diff a/src/jdk.jdi/share/classes/com/sun/jdi/connect/spi/TransportService.java b/src/jdk.jdi/share/classes/com/sun/jdi/connect/spi/TransportService.java
--- a/src/jdk.jdi/share/classes/com/sun/jdi/connect/spi/TransportService.java
+++ b/src/jdk.jdi/share/classes/com/sun/jdi/connect/spi/TransportService.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -77,10 +77,14 @@
  * target VM.
  *
  * @since 1.5
  */
 public abstract class TransportService {
+    /**
+     * Constructor for subclasses to call.
+     */
+    public TransportService() {}
 
     /**
      * Returns a name to identify the transport service.
      *
      * @return  The name of the transport service
@@ -96,10 +100,14 @@
 
     /**
      * The transport service capabilities.
      */
     public static abstract class Capabilities {
+        /**
+         * Constructor for subclasses to call.
+         */
+        public Capabilities() {}
 
         /**
          * Tells whether or not this transport service can support
          * multiple concurrent connections to a single address that
          * it is listening on.
@@ -227,10 +235,14 @@
      * key is valid until it is used as an argument to {@link
      * #stopListening stopListening} to stop the transport
      * service from listening on an address.
      */
     public static abstract class ListenKey {
+        /**
+         * Constructor for subclasses to call.
+         */
+        public ListenKey() {}
 
         /**
          * Returns a string representation of the listen key.
          */
         public abstract String address();
diff a/src/jdk.jdi/share/man/jdb.1 b/src/jdk.jdi/share/man/jdb.1
--- a/src/jdk.jdi/share/man/jdb.1
+++ b/src/jdk.jdi/share/man/jdb.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JDB" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JDB" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jdb \- find and fix bugs in Java platform programs
 .SH SYNOPSIS
diff a/src/jdk.jlink/share/man/jlink.1 b/src/jdk.jlink/share/man/jlink.1
--- a/src/jdk.jlink/share/man/jlink.1
+++ b/src/jdk.jlink/share/man/jlink.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JLINK" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JLINK" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jlink \- assemble and optimize a set of modules and their dependencies
 into a custom runtime image
diff a/src/jdk.jlink/share/man/jmod.1 b/src/jdk.jlink/share/man/jmod.1
--- a/src/jdk.jlink/share/man/jmod.1
+++ b/src/jdk.jlink/share/man/jmod.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JMOD" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JMOD" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jmod \- create JMOD files and list the content of existing JMOD files
 .SH SYNOPSIS
@@ -410,11 +410,11 @@
 from the directory \f[CB]jmodhashex2\f[R] but the module \f[CB]mb\f[R] from
 the directory \f[CB]jmodhashex\f[R].
 Run the following command from the \f[CB]jmodhashex2\f[R] directory:
 .RS 4
 .IP \[bu] 2
-\f[B]Oracle Solaris, Linux, and OS X:\f[R]
+\f[B]Linux and OS X:\f[R]
 .RS 2
 .RS
 .PP
 \f[CB]jlink\ \-\-module\-path\ $JAVA_HOME/jmods:jmods/ma.jmod:../jmodhashex/jmods/mb.jmod\ \-\-add\-modules\ ma\ \-\-output\ ma\-app\f[R]
 .RE
diff a/src/jdk.jshell/share/man/jshell.1 b/src/jdk.jshell/share/man/jshell.1
--- a/src/jdk.jshell/share/man/jshell.1
+++ b/src/jdk.jshell/share/man/jshell.1
@@ -1,7 +1,7 @@
 .\"t
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -20,11 +20,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JSHELL" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JSHELL" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jshell \- interactively evaluate declarations, statements, and
 expressions of the Java programming language in a read\-eval\-print loop
@@ -100,10 +100,16 @@
 Snippets can be modified within the session to try out different
 variations and make corrections.
 To keep snippets for later use, save them to a file.
 .SH OPTIONS FOR JSHELL
 .TP
+.B \f[CB]\-\-add\-exports\f[R] \f[I]module\f[R]/\f[I]package\f[R]
+Specifies a package to be considered as exported from its defining
+module.
+.RS
+.RE
+.TP
 .B \f[CB]\-\-add\-modules\f[R] \f[I]module\f[R][\f[CB],\f[R]\f[I]module\f[R]...]
 Specifies the root modules to resolve in addition to the initial module.
 .RS
 .RE
 .TP
@@ -119,16 +125,28 @@
 files.
 This option overrides the path in the \f[CB]CLASSPATH\f[R] environment
 variable.
 If the environment variable isn\[aq]t set and this option isn\[aq]t
 used, then the current directory is searched.
-For Oracle Solaris, Linux, and macOS, use a colon (:) to separate items
-in the path.
+For Linux and macOS, use a colon (:) to separate items in the path.
 For Windows, use a semicolon (;) to separate items.
 .RS
 .RE
 .TP
+.B \f[CB]\-\-enable\-preview\f[R]
+Allows code to depend on the preview features of this release.
+.RS
+.RE
+.TP
+.B \f[CB]\-\-execution\f[R] \f[I]specification\f[R]
+Specifies an alternate execution engine, where \f[I]specification\f[R] is
+an ExecutionControl spec.
+See the documentation of the package jdk.jshell.spi for the syntax of
+the spec.
+.RS
+.RE
+.TP
 .B \f[CB]\-\-feedback\f[R] \f[I]mode\f[R]
 Sets the initial level of feedback provided in response to what\[aq]s
 entered.
 The initial level can be overridden within a session by using the
 \f[CB]/set\ feedback\f[R] \f[I]mode\f[R] command.
@@ -189,12 +207,11 @@
 .RS
 .RE
 .TP
 .B \f[CB]\-\-module\-path\f[R] \f[I]modulepath\f[R]
 Specifies where to find application modules.
-For Oracle Solaris, Linux, and macOS, use a colon (:) to separate items
-in the path.
+For Linux and macOS, use a colon (:) to separate items in the path.
 For Windows, use a semicolon (;) to separate items.
 .RS
 .RE
 .TP
 .B \f[CB]\-\-no\-startup\f[R]
@@ -374,20 +391,20 @@
 files.
 This option overrides the path in the \f[CB]CLASSPATH\f[R] environment
 variable.
 If the environment variable isn\[aq]t set and this option isn\[aq]t
 used, then the current directory is searched.
-For Oracle Solaris, Linux, and macOS, use a colon (\f[CB]:\f[R]) to
-separate items in the path.
+For Linux and macOS, use a colon (\f[CB]:\f[R]) to separate items in the
+path.
 For Windows, use a semicolon (\f[CB];\f[R]) to separate items.
 .RS
 .RE
 .TP
 .B \f[CB]\-\-module\-path\f[R] \f[I]modulepath\f[R]
 Specifies where to find application modules.
-For Oracle Solaris, Linux, and macOS, use a colon (\f[CB]:\f[R]) to
-separate items in the path.
+For Linux and macOS, use a colon (\f[CB]:\f[R]) to separate items in the
+path.
 For Windows, use a semicolon (\f[CB];\f[R]) to separate items.
 .RS
 .RE
 .RE
 .TP
@@ -564,20 +581,20 @@
 files.
 This option overrides the path in the \f[CB]CLASSPATH\f[R] environment
 variable.
 If the environment variable isn\[aq]t set and this option isn\[aq]t
 used, then the current directory is searched.
-For Oracle Solaris, Linux, and macOS, use a colon (\f[CB]:\f[R]) to
-separate items in the path.
+For Linux and macOS, use a colon (\f[CB]:\f[R]) to separate items in the
+path.
 For Windows, use a semicolon (\f[CB];\f[R]) to separate items.
 .RS
 .RE
 .TP
 .B \f[CB]\-\-module\-path\f[R] \f[I]modulepath\f[R]
 Specifies where to find application modules.
-For Oracle Solaris, Linux, and macOS, use a colon (\f[CB]:\f[R]) to
-separate items in the path.
+For Linux and macOS, use a colon (\f[CB]:\f[R]) to separate items in the
+path.
 For Windows, use a semicolon (\f[CB];\f[R]) to separate items.
 .RS
 .RE
 .TP
 .B \f[CB]\-quiet\f[R]
@@ -632,20 +649,20 @@
 files.
 This option overrides the path in the \f[CB]CLASSPATH\f[R] environment
 variable.
 If the environment variable isn\[aq]t set and this option isn\[aq]t
 used, then the current directory is searched.
-For Oracle Solaris, Linux, and macOS, use a colon (\f[CB]:\f[R]) to
-separate items in the path.
+For Linux and macOS, use a colon (\f[CB]:\f[R]) to separate items in the
+path.
 For Windows, use a semicolon (\f[CB];\f[R]) to separate items.
 .RS
 .RE
 .TP
 .B \f[CB]\-\-module\-path\f[R] \f[I]modulepath\f[R]
 Specifies where to find application modules.
-For Oracle Solaris, Linux, and macOS, use a colon (\f[CB]:\f[R]) to
-separate items in the path.
+For Linux and macOS, use a colon (\f[CB]:\f[R]) to separate items in the
+path.
 For Windows, use a semicolon (\f[CB];\f[R]) to separate items.
 .RS
 .RE
 .RE
 .TP
diff a/src/jdk.jstatd/share/man/jstatd.1 b/src/jdk.jstatd/share/man/jstatd.1
--- a/src/jdk.jstatd/share/man/jstatd.1
+++ b/src/jdk.jstatd/share/man/jstatd.1
@@ -1,6 +1,6 @@
-.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 2004, 2020, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
@@ -19,11 +19,11 @@
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
 .\" Automatically generated by Pandoc 2.3.1
 .\"
-.TH "JSTATD" "1" "2020" "JDK 14" "JDK Commands"
+.TH "JSTATD" "1" "2020" "JDK 15" "JDK Commands"
 .hy
 .SH NAME
 .PP
 jstatd \- monitor the creation and termination of instrumented Java
 HotSpot VMs
@@ -70,10 +70,16 @@
 be found, or when not found, created if the \f[CB]\-nr\f[R] option
 isn\[aq]t specified.
 .RS
 .RE
 .TP
+.B \f[CB]\-r\f[R] \f[I]rmiport\f[R]
+This option sets the port number to which the RMI connector is bound.
+If not specified a random available port is used.
+.RS
+.RE
+.TP
 .B \f[CB]\-n\f[R] \f[I]rminame\f[R]
 This option sets the name to which the remote RMI object is bound in the
 RMI registry.
 The default name is \f[CB]JStatRemoteHost\f[R].
 If multiple \f[CB]jstatd\f[R] servers are started on the same host, then
@@ -96,13 +102,13 @@
 .PP
 The \f[CB]jstatd\f[R] server can monitor only JVMs for which it has the
 appropriate native access permissions.
 Therefore, the \f[CB]jstatd\f[R] process must be running with the same
 user credentials as the target JVMs.
-Some user credentials, such as the root user in Oracle Solaris, Linux,
-and OS X operating systems, have permission to access the
-instrumentation exported by any JVM on the system.
+Some user credentials, such as the root user in Linux and OS X operating
+systems, have permission to access the instrumentation exported by any
+JVM on the system.
 A \f[CB]jstatd\f[R] process running with such credentials can monitor any
 JVM on the system, but introduces additional security concerns.
 .PP
 The \f[CB]jstatd\f[R] server doesn\[aq]t provide any authentication of
 remote clients.
@@ -166,10 +172,21 @@
 jstatd\ \-J\-Djava.security.policy=all.policy\ \-p\ 2020
 \f[R]
 .fi
 .PP
 This example starts a \f[CB]jstatd\f[R] session with an external RMI
+registry server on port \f[CB]2020\f[R] and JMX connector bound to port
+\f[CB]2021\f[R].
+.IP
+.nf
+\f[CB]
+jrmiregistry\ 2020&
+jstatd\ \-J\-Djava.security.policy=all.policy\ \-p\ 2020\ \-r\ 2021
+\f[R]
+.fi
+.PP
+This example starts a \f[CB]jstatd\f[R] session with an external RMI
 registry on port 2020 that\[aq]s bound to
 \f[CB]AlternateJstatdServerName\f[R].
 .IP
 .nf
 \f[CB]
diff a/src/jdk.management/unix/classes/com/sun/management/internal/OperatingSystemImpl.java b/src/jdk.management/unix/classes/com/sun/management/internal/OperatingSystemImpl.java
--- a/src/jdk.management/unix/classes/com/sun/management/internal/OperatingSystemImpl.java
+++ b/src/jdk.management/unix/classes/com/sun/management/internal/OperatingSystemImpl.java
@@ -59,12 +59,11 @@
             // or if a docker container was started without specifying a memory limit (without '--memory='
             // Docker option). In latter case there is no limit on how much memory the container can use and
             // it can use as much memory as the host's OS allows.
             long memLimit = containerMetrics.getMemoryLimit();
             if (limit >= 0 && memLimit >= 0) {
-                // we see a limit == 0 on some machines where "kernel does not support swap limit capabilities"
-                return (limit < memLimit) ? 0 : limit - memLimit;
+                return limit - memLimit; // might potentially be 0 for limit == memLimit
             }
         }
         return getTotalSwapSpaceSize0();
     }
 
diff a/src/jdk.security.auth/share/classes/com/sun/security/auth/module/JndiLoginModule.java b/src/jdk.security.auth/share/classes/com/sun/security/auth/module/JndiLoginModule.java
--- a/src/jdk.security.auth/share/classes/com/sun/security/auth/module/JndiLoginModule.java
+++ b/src/jdk.security.auth/share/classes/com/sun/security/auth/module/JndiLoginModule.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -193,10 +193,15 @@
     private static final String USER_GID = "gidNumber";
     private static final String GROUP_ID = "gidNumber";
     private static final String NAME = "javax.security.auth.login.name";
     private static final String PWD = "javax.security.auth.login.password";
 
+    /**
+     * Creates a {@code JndiLoginModule}.
+     */
+    public JndiLoginModule() {}
+
     /**
      * Initialize this {@code LoginModule}.
      *
      * @param subject the {@code Subject} to be authenticated.
      *
diff a/src/jdk.security.auth/share/classes/com/sun/security/auth/module/KeyStoreLoginModule.java b/src/jdk.security.auth/share/classes/com/sun/security/auth/module/KeyStoreLoginModule.java
--- a/src/jdk.security.auth/share/classes/com/sun/security/auth/module/KeyStoreLoginModule.java
+++ b/src/jdk.security.auth/share/classes/com/sun/security/auth/module/KeyStoreLoginModule.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -160,10 +160,15 @@
     private int status = UNINITIALIZED;
     private boolean nullStream = false;
     private boolean token = false;
     private boolean protectedPath = false;
 
+    /**
+     * Creates a {@code KeyStoreLoginModule}.
+     */
+    public KeyStoreLoginModule() {}
+
     /* -- Methods -- */
 
     /**
      * Initialize this {@code LoginModule}.
      *
diff a/src/jdk.security.auth/share/classes/com/sun/security/auth/module/Krb5LoginModule.java b/src/jdk.security.auth/share/classes/com/sun/security/auth/module/Krb5LoginModule.java
--- a/src/jdk.security.auth/share/classes/com/sun/security/auth/module/Krb5LoginModule.java
+++ b/src/jdk.security.auth/share/classes/com/sun/security/auth/module/Krb5LoginModule.java
@@ -417,10 +417,15 @@
     private char[] password = null;
 
     private static final String NAME = "javax.security.auth.login.name";
     private static final String PWD = "javax.security.auth.login.password";
 
+    /**
+     * Creates a {@code Krb5LoginModule}.
+     */
+    public Krb5LoginModule() {}
+
     /**
      * Initialize this {@code LoginModule}.
      *
      * @param subject the {@code Subject} to be authenticated.
      *
diff a/src/jdk.security.auth/share/classes/com/sun/security/auth/module/LdapLoginModule.java b/src/jdk.security.auth/share/classes/com/sun/security/auth/module/LdapLoginModule.java
--- a/src/jdk.security.auth/share/classes/com/sun/security/auth/module/LdapLoginModule.java
+++ b/src/jdk.security.auth/share/classes/com/sun/security/auth/module/LdapLoginModule.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -353,10 +353,15 @@
     private Matcher identityMatcher = null;
     private Matcher filterMatcher = null;
     private Hashtable<String, Object> ldapEnvironment;
     private SearchControls constraints = null;
 
+    /**
+     * Creates an {@code LdapLoginModule}.
+     */
+    public LdapLoginModule() {}
+
     /**
      * Initialize this {@code LoginModule}.
      *
      * @param subject the {@code Subject} to be authenticated.
      * @param callbackHandler a {@code CallbackHandler} to acquire the
diff a/src/jdk.security.auth/share/classes/com/sun/security/auth/module/NTLoginModule.java b/src/jdk.security.auth/share/classes/com/sun/security/auth/module/NTLoginModule.java
--- a/src/jdk.security.auth/share/classes/com/sun/security/auth/module/NTLoginModule.java
+++ b/src/jdk.security.auth/share/classes/com/sun/security/auth/module/NTLoginModule.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -81,10 +81,15 @@
     private NTSidDomainPrincipal domainSID;             // domain SID
     private NTSidPrimaryGroupPrincipal primaryGroup;    // primary group
     private NTSidGroupPrincipal[] groups;               // supplementary groups
     private NTNumericCredential iToken;                 // impersonation token
 
+    /**
+     * Creates an {@code NTLoginModule}.
+     */
+    public NTLoginModule() {}
+
     /**
      * Initialize this {@code LoginModule}.
      *
      * @param subject the {@code Subject} to be authenticated.
      *
diff a/src/jdk.security.auth/share/classes/com/sun/security/auth/module/UnixLoginModule.java b/src/jdk.security.auth/share/classes/com/sun/security/auth/module/UnixLoginModule.java
--- a/src/jdk.security.auth/share/classes/com/sun/security/auth/module/UnixLoginModule.java
+++ b/src/jdk.security.auth/share/classes/com/sun/security/auth/module/UnixLoginModule.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -70,10 +70,15 @@
     private UnixNumericUserPrincipal UIDPrincipal;
     private UnixNumericGroupPrincipal GIDPrincipal;
     private LinkedList<UnixNumericGroupPrincipal> supplementaryGroups =
                 new LinkedList<>();
 
+    /**
+     * Creates a {@code UnixLoginModule}.
+     */
+    public UnixLoginModule() {}
+
     /**
      * Initialize this {@code LoginModule}.
      *
      * @param subject the {@code Subject} to be authenticated.
      *
diff a/src/jdk.security.jgss/share/classes/com/sun/security/jgss/GSSUtil.java b/src/jdk.security.jgss/share/classes/com/sun/security/jgss/GSSUtil.java
--- a/src/jdk.security.jgss/share/classes/com/sun/security/jgss/GSSUtil.java
+++ b/src/jdk.security.jgss/share/classes/com/sun/security/jgss/GSSUtil.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -32,10 +32,15 @@
 /**
  * GSS-API Utilities for using in conjunction with Sun Microsystem's
  * implementation of Java GSS-API.
  */
 public class GSSUtil {
+    /**
+     * Do not call.
+     */
+    @Deprecated(since="16", forRemoval=true)
+    public GSSUtil() {}
 
     /**
      * Use this method to convert a GSSName and GSSCredential into a
      * Subject. Typically this would be done by a server that wants to
      * impersonate a client thread at the Java level by setting a client
diff a/src/utils/LogCompilation/src/main/java/com/sun/hotspot/tools/compiler/LogParser.java b/src/utils/LogCompilation/src/main/java/com/sun/hotspot/tools/compiler/LogParser.java
--- a/src/utils/LogCompilation/src/main/java/com/sun/hotspot/tools/compiler/LogParser.java
+++ b/src/utils/LogCompilation/src/main/java/com/sun/hotspot/tools/compiler/LogParser.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -549,10 +549,15 @@
      * A document locator to provide better error messages: this allows the
      * tool to display in which line of the log file the problem occurred.
      */
     private Locator locator;
 
+    /**
+     * Record the location in a replace_string_concat.
+     */
+    private boolean expectStringConcatTrap = false;
+
     /**
      * Callback for the SAX framework to set the document locator.
      */
     @Override
     public void setDocumentLocator(Locator locator) {
@@ -985,10 +990,12 @@
             CallSite cs = (site != null) ? site : scopes.peek();
             assert cs != null : "no CallSite?";
             cs.setIntrinsicName(id);
         } else if (qname.equals("regalloc")) {
             compile.setAttempts(Integer.parseInt(search(atts, "attempts")));
+        } else if (qname.equals("replace_string_concat")) {
+            expectStringConcatTrap = true;
         } else if (qname.equals("inline_fail")) {
             if (methodHandleSite != null) {
                 scopes.peek().add(methodHandleSite);
                 methodHandleSite = null;
             }
@@ -1085,13 +1092,18 @@
             } else if (lateInlineScope != null) {
                 current_bci = Integer.parseInt(search(atts, "bci"));
                 Method m = method(search(atts, "method"));
                 site = new CallSite(current_bci, m);
                 lateInlineScope.push(site);
+            } else if (expectStringConcatTrap == true) {
+                // Record the location of the replace_string_concat for the
+                // uncommon_trap 'intrinsic_or_type_checked_inlining' that should follow it
+                current_bci = Integer.parseInt(search(atts, "bci"));
+                Method m = method(search(atts, "method"));
+                site = new CallSite(current_bci, m);
             } else {
                 // Ignore <eliminate_allocation type='667'>,
-                //        <replace_string_concat arguments='2' string_alloc='0' multiple='0'>
             }
         } else if (qname.equals("inline_id")) {
             if (methodHandleSite != null) {
                 reportInternalError("method handle site should have been replaced");
             }
@@ -1140,11 +1152,11 @@
                 scopes.push(site);
             } else {
                 // The method being parsed is *not* the current compilation's
                 // top scope; i.e., we're dealing with an actual call site
                 // in the top scope or somewhere further down a call stack.
-                if (site.getMethod() == m) {
+                if (site != null && site.getMethod() == m) {
                     // We're dealing with monomorphic inlining that didn't have
                     // to be narrowed down, because the receiver was known
                     // beforehand.
                     scopes.push(site);
                 } else if (scopes.peek().getCalls().size() > 2 && m == scopes.peek().lastButOne().getMethod()) {
@@ -1213,10 +1225,12 @@
                 // left, no late inlining can be going on.
                 scopes.pop();
                 if (scopes.size() == 0) {
                     lateInlining = false;
                 }
+                // Don't carry a stale site to the next parse
+                site = null;
             } else if (qname.equals("uncommon_trap")) {
                 currentTrap = null;
             } else if (qname.startsWith("eliminate_lock")) {
                 currentLockElimination = null;
             } else if (qname.equals("late_inline")) {
@@ -1287,10 +1301,12 @@
             } else if (qname.equals("task")) {
                 types.clear();
                 methods.clear();
                 site = null;
                 lateInlining = false;
+            } else if (qname.equals("replace_string_concat")) {
+                expectStringConcatTrap = false;
             }
         } catch (Exception e) {
             reportInternalError("exception while processing end element", e);
         }
     }
diff a/test/hotspot/jtreg/ProblemList-graal.txt b/test/hotspot/jtreg/ProblemList-graal.txt
--- a/test/hotspot/jtreg/ProblemList-graal.txt
+++ b/test/hotspot/jtreg/ProblemList-graal.txt
@@ -229,12 +229,10 @@
 compiler/loopopts/TestOverunrolling.java                8207267   generic-all
 compiler/jsr292/NonInlinedCall/InvokeTest.java          8207267   generic-all
 compiler/codegen/TestTrichotomyExpressions.java         8207267   generic-all
 gc/stress/TestReclaimStringsLeaksMemory.java            8207267   generic-all
 
-runtime/exceptionMsgs/AbstractMethodError/AbstractMethodErrorTest.java        8222582 generic-all
-
 # Graal unit tests
 org.graalvm.compiler.core.test.OptionsVerifierTest                               8205081
 org.graalvm.compiler.hotspot.test.CompilationWrapperTest                         8205081
 org.graalvm.compiler.replacements.test.classfile.ClassfileBytecodeProviderTest   8205081
 
diff a/test/hotspot/jtreg/ProblemList-zgc.txt b/test/hotspot/jtreg/ProblemList-zgc.txt
--- a/test/hotspot/jtreg/ProblemList-zgc.txt
+++ b/test/hotspot/jtreg/ProblemList-zgc.txt
@@ -42,11 +42,12 @@
 serviceability/sa/ClhsdbJstack.java#id0                       8220624   generic-all
 serviceability/sa/ClhsdbJstack.java#id1                       8220624   generic-all
 serviceability/sa/ClhsdbJstackXcompStress.java                8220624   generic-all
 serviceability/sa/ClhsdbPrintAs.java                          8220624   generic-all
 serviceability/sa/ClhsdbPrintStatics.java                     8220624   generic-all
-serviceability/sa/ClhsdbPstack.java                           8220624   generic-all
+serviceability/sa/ClhsdbPstack.java#id0                       8220624   generic-all
+serviceability/sa/ClhsdbPstack.java#id1                       8220624   generic-all
 serviceability/sa/ClhsdbSource.java                           8220624   generic-all
 serviceability/sa/ClhsdbThread.java                           8220624   generic-all
 serviceability/sa/ClhsdbWhere.java                            8220624   generic-all
 serviceability/sa/DeadlockDetectionTest.java                  8220624   generic-all
 serviceability/sa/JhsdbThreadInfoTest.java                    8220624   generic-all
diff a/test/hotspot/jtreg/compiler/c2/TestFoldCompares.java b/test/hotspot/jtreg/compiler/c2/TestFoldCompares.java
--- /dev/null
+++ b/test/hotspot/jtreg/compiler/c2/TestFoldCompares.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2020, Huawei Technologies Co. Ltd. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 8250609
+ * @summary C2 crash in IfNode::fold_compares
+ *
+ * @run main/othervm -XX:CompileOnly=compiler.c2.TestFoldCompares::test
+ *                   -XX:-BackgroundCompilation compiler.c2.TestFoldCompares
+ */
+
+package compiler.c2;
+
+public class TestFoldCompares {
+
+    public int test() {
+        byte by = -37;
+        int result = 1;
+        int iArr[] = new int[6];
+
+        for (int i = 0; i < iArr.length; i++) {
+            iArr[i] = 0;
+        }
+
+        for (int i = 16; i < 308; i++) {
+            result *= i;
+            if ((result--) <= (++by)) {
+                continue;
+            }
+
+            for (int j = 3; j < 86; j++) {
+                for (int k = 1; k < 2; k++) {
+                    result >>= 25;
+                }
+
+                for (int k = 1; k < 2; k += 3) {
+                    try {
+                        iArr[k] = (16986 / result);
+                    } catch (ArithmeticException a_e) {
+                    }
+                    result = k;
+                }
+            }
+        }
+
+        return result;
+    }
+
+    public static void main(String[] args) {
+        TestFoldCompares obj = new TestFoldCompares();
+        for (int i = 0; i < 10; i++) {
+            int result = obj.test();
+            if (result != 1) {
+                throw new RuntimeException("Test failed.");
+            }
+        }
+        System.out.println("Test passed.");
+    }
+
+}
diff a/test/hotspot/jtreg/compiler/loopopts/TestPreMainPostFallInEdges.java b/test/hotspot/jtreg/compiler/loopopts/TestPreMainPostFallInEdges.java
--- /dev/null
+++ b/test/hotspot/jtreg/compiler/loopopts/TestPreMainPostFallInEdges.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8249602
+ * @summary Tests the rewiring and cloning of fall-in values from the main loop (and pre loop) to the post (and main loop)
+ *          which resulted in a DUIterator_Fast assertion failure due to an insertion in the outputs of the loop header node.
+ *
+ * @run main compiler.loopopts.TestPreMainPostFallInEdges
+ */
+
+package compiler.loopopts;
+
+public class TestPreMainPostFallInEdges {
+
+    public static int test() {
+        int iArr[] = new int[400];
+        float fArr[] = new float[400];
+        int x = 0;
+        byte y = 124;
+        short z = 0;
+
+        int i = 1;
+        do {
+            int j = 1;
+            do {
+                z *= 11;
+
+                // These 4 array stores live in the back control block and cannot float. They are cloned and their control input set to the preheader control
+                // block of the post loop. If their input edges also have their placement in the back control block (get_ctrl == back control) then they are
+                // cloned as well. The following code hits the assertion failure when we clone a node with a control edge to the loop header block of the main.
+                // loop. The DUIterator_Fast does not allow insertions. The fix is to replace it by a normal DUIterator which allows insertions.
+                iArr[j] = 3;
+                // load of iArr[j + 1] is also cloned but has a control edge to the main loop header block hitting the assertion failure.
+                iArr[j + 1] += 4;
+                fArr[j] = 5;
+                fArr[j + 1] += fArr[j + 5]; // same for load of fArr[j + 1] and load of fArr[j + 5]
+
+                int k = 1;
+                do {
+                    iArr[j] *= 324;
+                    x = 34;
+                    y *= 54;
+                } while (k < 1);
+            } while (++j < 6);
+        } while (++i < 289);
+        return checkSum(iArr) + checkSum(fArr);
+    }
+
+    public static int checkSum(int[] a) {
+        int sum = 0;
+        for (int j = 0; j < a.length; j++) {
+            sum += a[j] % (j + 1);
+        }
+        return sum;
+    }
+
+    public static int checkSum(float[] a) {
+        int sum = 0;
+        for (int j = 0; j < a.length; j++) {
+            sum += a[j] % (j + 1);
+        }
+        return sum;
+    }
+
+    public static void main(String[] strArr) {
+        for (int i = 0; i < 10000; i++) {
+            test();
+        }
+    }
+}
+
diff a/test/hotspot/jtreg/compiler/loopopts/TestSplitThruPhiDivMod.java b/test/hotspot/jtreg/compiler/loopopts/TestSplitThruPhiDivMod.java
--- /dev/null
+++ b/test/hotspot/jtreg/compiler/loopopts/TestSplitThruPhiDivMod.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8248552
+ * @summary A Division/modulo node whose zero check was removed is split through an induction variable phi and executed before
+ *          the loop limit check resulting in a SIGFPE because the divisor is zero.
+ *
+ * @run main/othervm -XX:CompileCommand=dontinline,compiler.c2.loopopts.TestSplitThruPhiDivMod::test* compiler.c2.loopopts.TestSplitThruPhiDivMod
+ */
+package compiler.c2.loopopts;
+
+public class TestSplitThruPhiDivMod {
+
+    int x;
+
+    public int testMod() {
+        int i1 = 2;
+        for (int i = 5; i < 25; i++) {
+            for (int j = 50; j > 1; j -= 2) {
+                /*
+                 * Zero check is removed based on the type of the induction variable phi (variable j) since its always between 1 and 50.
+                 * However, when splitting the modulo node through the phi, it can be executed right after the subtraction j-2 which can be
+                 * 0 before evaluation the loop limit condition in the last iteration when j is 2: j-2 = 2-2 = 0. This results in a SIGFPE.
+                 * The fix is to not split a division or modulo node 'n' through the induction variable phi if the zero check was removed
+                 * earlier and the new inputs of the clones of 'n' after the split could be zero (i.e. the type of the clones of 'n' include 0).
+                 */
+                x = (20 % j); // Problematic division as part of modulo. Results in a SIGFPE, even though j is always non-zero.
+                i1 = (i1 / i);
+                for (int k = 3; k > 1; k--) {
+                    switch ((i % 4) + 22) {
+                    case 22:
+                        switch (j % 10) {
+                        case 83:
+                            x += 5;
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+        return i1;
+    }
+
+    public int testDiv() {
+        int i1 = 2;
+        for (int i = 5; i < 25; i++) {
+            for (int j = 50; j > 1; j -= 2) {
+                // Same issue as above but with a division node. See explanation above.
+                x = (20 / j); // Problematic division. Results in a SIGFPE, even though j is always non-zero.
+                i1 = (i1 / i);
+                for (int k = 3; k > 1; k--) {
+                    switch ((i % 4) + 22) {
+                    case 22:
+                        switch (j % 10) {
+                        case 83:
+                            x += 5;
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+        return i1;
+    }
+
+    public static void main(String[] strArr) {
+        TestSplitThruPhiDivMod t = new TestSplitThruPhiDivMod();
+        for (int i = 0; i < 10000; i++) {
+            t.testDiv();
+            t.testMod();
+        }
+    }
+}
diff a/test/hotspot/jtreg/gc/g1/humongousObjects/TestHumongousNonArrayAllocation.java b/test/hotspot/jtreg/gc/g1/humongousObjects/TestHumongousNonArrayAllocation.java
--- a/test/hotspot/jtreg/gc/g1/humongousObjects/TestHumongousNonArrayAllocation.java
+++ b/test/hotspot/jtreg/gc/g1/humongousObjects/TestHumongousNonArrayAllocation.java
@@ -43,27 +43,27 @@
  * @modules java.management
  * @build sun.hotspot.WhiteBox
  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
  *
  * @run main/othervm -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:.
- *                   -XX:G1HeapRegionSize=1M
+ *                   -XX:G1HeapRegionSize=1M -XX:AbortVMOnException=java.lang.StackOverflowError
  *                   gc.g1.humongousObjects.TestHumongousNonArrayAllocation LARGEST_NON_HUMONGOUS
  *
  * @run main/othervm -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:.
- *                   -XX:G1HeapRegionSize=1M
+ *                   -XX:G1HeapRegionSize=1M -XX:AbortVMOnException=java.lang.StackOverflowError
  *                   gc.g1.humongousObjects.TestHumongousNonArrayAllocation SMALLEST_HUMONGOUS
  *
  * @run main/othervm -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:.
- *                   -XX:G1HeapRegionSize=1M
+ *                   -XX:G1HeapRegionSize=1M -XX:AbortVMOnException=java.lang.StackOverflowError
  *                   gc.g1.humongousObjects.TestHumongousNonArrayAllocation ONE_REGION_HUMONGOUS
  *
  * @run main/othervm -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:.
- *                   -XX:G1HeapRegionSize=1M
+ *                   -XX:G1HeapRegionSize=1M -XX:AbortVMOnException=java.lang.StackOverflowError
  *                   gc.g1.humongousObjects.TestHumongousNonArrayAllocation TWO_REGION_HUMONGOUS
  *
  * @run main/othervm -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:.
- *                   -XX:G1HeapRegionSize=1M
+ *                   -XX:G1HeapRegionSize=1M -XX:AbortVMOnException=java.lang.StackOverflowError
  *                   gc.g1.humongousObjects.TestHumongousNonArrayAllocation MORE_THAN_TWO_REGION_HUMONGOUS
  *
  */
 
 /**
diff a/test/hotspot/jtreg/gc/stress/gclocker/TestGCLocker.java b/test/hotspot/jtreg/gc/stress/gclocker/TestGCLocker.java
--- a/test/hotspot/jtreg/gc/stress/gclocker/TestGCLocker.java
+++ b/test/hotspot/jtreg/gc/stress/gclocker/TestGCLocker.java
@@ -78,17 +78,18 @@
     private MemoryPoolMXBean bean;
     private final int thresholdPromille = 750;
     private final int criticalThresholdPromille = 800;
     private final int minGCWaitMS = 1000;
     private final int minFreeWaitElapsedMS = 30000;
-    private final int minFreeCriticalWaitMS = 500;
+    private final int minFreeCriticalWaitMS;
 
     private int lastUsage = 0;
     private long lastGCDetected = System.currentTimeMillis();
     private long lastFree = System.currentTimeMillis();
 
-    public MemoryWatcher(String mxBeanName) {
+    public MemoryWatcher(String mxBeanName, int minFreeCriticalWaitMS) {
+        this.minFreeCriticalWaitMS = minFreeCriticalWaitMS;
         List<MemoryPoolMXBean> memoryBeans = ManagementFactory.getMemoryPoolMXBeans();
         for (MemoryPoolMXBean bean : memoryBeans) {
             if (bean.getName().equals(mxBeanName)) {
                 this.bean = bean;
                 break;
@@ -149,12 +150,12 @@
             }
         }
         cache.add(new Filler());
     }
 
-    public MemoryUser(String mxBeanName) {
-        watcher = new MemoryWatcher(mxBeanName);
+    public MemoryUser(String mxBeanName, int minFreeCriticalWaitMS) {
+        watcher = new MemoryWatcher(mxBeanName, minFreeCriticalWaitMS);
     }
 
     @Override
     public void run() {
         for (int i = 0; i < 200; i++) {
@@ -189,12 +190,12 @@
         thread.start();
 
         return task;
     }
 
-    private static Exitable startMemoryUser(String mxBeanName) {
-        MemoryUser task = new MemoryUser(mxBeanName);
+    private static Exitable startMemoryUser(String mxBeanName, int minFreeCriticalWaitMS) {
+        MemoryUser task = new MemoryUser(mxBeanName, minFreeCriticalWaitMS);
 
         Thread thread = new Thread(task);
         thread.setName("Memory User");
         thread.start();
 
@@ -204,16 +205,17 @@
     public static void main(String[] args) {
         System.loadLibrary("TestGCLocker");
 
         long durationMinutes = args.length > 0 ? Long.parseLong(args[0]) : 5;
         String mxBeanName = args.length > 1 ? args[1] : null;
+        int minFreeCriticalWaitMS = args.length > 2 ? Integer.parseInt(args[2]) : 500;
 
         long startMS = System.currentTimeMillis();
 
         Exitable stresser1 = startGCLockerStresser("GCLockerStresser1");
         Exitable stresser2 = startGCLockerStresser("GCLockerStresser2");
-        Exitable memoryUser = startMemoryUser(mxBeanName);
+        Exitable memoryUser = startMemoryUser(mxBeanName, minFreeCriticalWaitMS);
 
         long durationMS = durationMinutes * 60 * 1000;
         while ((System.currentTimeMillis() - startMS) < durationMS) {
             ThreadUtils.sleep(10 * 1010);
         }
diff a/test/hotspot/jtreg/gc/stress/gclocker/TestGCLockerWithShenandoah.java b/test/hotspot/jtreg/gc/stress/gclocker/TestGCLockerWithShenandoah.java
--- a/test/hotspot/jtreg/gc/stress/gclocker/TestGCLockerWithShenandoah.java
+++ b/test/hotspot/jtreg/gc/stress/gclocker/TestGCLockerWithShenandoah.java
@@ -56,9 +56,9 @@
  *      -XX:+ShenandoahAllocFailureALot
  *      gc.stress.gclocker.TestGCLockerWithShenandoah
  */
 public class TestGCLockerWithShenandoah {
     public static void main(String[] args) {
-        String[] testArgs = {"2", "Shenandoah heap"};
+        String[] testArgs = {"2", "Shenandoah", "0"};
         TestGCLocker.main(testArgs);
     }
 }
diff a/test/hotspot/jtreg/runtime/MemberName/ResolvedMethodTableHash.java b/test/hotspot/jtreg/runtime/MemberName/ResolvedMethodTableHash.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/MemberName/ResolvedMethodTableHash.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8249719
+ * @summary ResolvedMethodTable hash function should take method class into account
+ * @run main/othervm/manual -Xmx256m -XX:MaxMetaspaceSize=256m ResolvedMethodTableHash 200000
+ */
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+
+// The test generates thousands MethodHandles to the methods of the same name
+// and the same signature. This should not take too long, unless Method hash
+// function takes only the name and the signature as an input.
+public class ResolvedMethodTableHash extends ClassLoader {
+
+    // Generate a MethodHandle for ClassName.m()
+    private MethodHandle generate(String className) throws ReflectiveOperationException {
+        byte[] buf = new byte[100];
+        int size = writeClass(buf, className);
+        Class<?> cls = defineClass(null, buf, 0, size);
+        return MethodHandles.publicLookup().findStatic(cls, "m", MethodType.methodType(void.class));
+    }
+
+    // Produce a class file with the given name and a single method:
+    //     public static native void m();
+    private int writeClass(byte[] buf, String className) {
+        return ByteBuffer.wrap(buf)
+                .putInt(0xCAFEBABE)       // magic
+                .putInt(50)               // version: 50
+                .putShort((short) 7)      // constant_pool_count: 7
+                .put((byte) 7).putShort((short) 2)
+                .put((byte) 1).putShort((short) className.length()).put(className.getBytes())
+                .put((byte) 7).putShort((short) 4)
+                .put((byte) 1).putShort((short) 16).put("java/lang/Object".getBytes())
+                .put((byte) 1).putShort((short) 1).put("m".getBytes())
+                .put((byte) 1).putShort((short) 3).put("()V".getBytes())
+                .putShort((short) 0x21)   // access_flags: public super
+                .putShort((short) 1)      // this_class: #1
+                .putShort((short) 3)      // super_class: #3
+                .putShort((short) 0)      // interfaces_count: 0
+                .putShort((short) 0)      // fields_count: 0
+                .putShort((short) 1)      // methods_count: 1
+                .putShort((short) 0x109)  //   access_flags: public static native
+                .putShort((short) 5)      //   name_index: #5
+                .putShort((short) 6)      //   descriptor_index: #6
+                .putShort((short) 0)      //   attributes_count: 0
+                .putShort((short) 0)      // attributes_count: 0
+                .position();
+    }
+
+    public static void main(String[] args) throws Exception {
+        ResolvedMethodTableHash generator = new ResolvedMethodTableHash();
+        List<MethodHandle> handles = new ArrayList<>();
+
+        int count = args.length > 0 ? Integer.parseInt(args[0]) : 200000;
+
+        for (int i = 0; i < count; i++) {
+            handles.add(generator.generate("MH$" + i));
+            if (i % 1000 == 0) {
+                System.out.println("Generated " + i + " handles");
+            }
+        }
+
+        System.out.println("Test passed");
+    }
+}
diff a/test/hotspot/jtreg/runtime/cds/appcds/sharedStrings/IncompatibleOptions.java b/test/hotspot/jtreg/runtime/cds/appcds/sharedStrings/IncompatibleOptions.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/sharedStrings/IncompatibleOptions.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/sharedStrings/IncompatibleOptions.java
@@ -107,11 +107,11 @@
 
         // incompatible GCs
         testDump(2, "-XX:+UseParallelGC", "", GC_WARNING, false);
         testDump(3, "-XX:+UseSerialGC", "", GC_WARNING, false);
 
-        // ======= archive with compressed oops, run w/o
+        // Explicitly archive with compressed oops, run without.
         testDump(5, "-XX:+UseG1GC", "-XX:+UseCompressedOops", null, false);
         testExec(5, "-XX:+UseG1GC", "-XX:-UseCompressedOops",
                  COMPRESSED_OOPS_NOT_CONSISTENT, true);
 
         // NOTE: No warning is displayed, by design
@@ -122,24 +122,29 @@
         // Test various oops encodings, by varying ObjectAlignmentInBytes and heap sizes
         testDump(9, "-XX:+UseG1GC", "-XX:ObjectAlignmentInBytes=8", null, false);
         testExec(9, "-XX:+UseG1GC", "-XX:ObjectAlignmentInBytes=16",
                  OBJ_ALIGNMENT_MISMATCH, true);
 
-        // See JDK-8081416 - Oops encoding mismatch with shared strings
-        // produces unclear or incorrect warning
-        // Correct the test case once the above is fixed
-        // @ignore JDK-8081416 - for tracking purposes
-        // for now, run test as is until the proper behavior is determined
+        // Implicitly archive with compressed oops, run without.
+        // Max heap size for compressed oops is around 31G.
+        // UseCompressedOops is turned on by default when heap
+        // size is under 31G, but will be turned off when heap
+        // size is greater than that.
         testDump(10, "-XX:+UseG1GC", "-Xmx1g", null, false);
         testExec(10, "-XX:+UseG1GC", "-Xmx32g", null, true);
-
+        // Explicitly archive without compressed oops and run with.
+        testDump(11, "-XX:+UseG1GC", "-XX:-UseCompressedOops", null, false);
+        testExec(11, "-XX:+UseG1GC", "-XX:+UseCompressedOops", null, true);
+        // Implicitly archive without compressed oops and run with.
+        testDump(12, "-XX:+UseG1GC", "-Xmx32G", null, false);
+        testExec(12, "-XX:+UseG1GC", "-Xmx1G", null, true);
         // CompactStrings must match between dump time and run time
-        testDump(11, "-XX:+UseG1GC", "-XX:-CompactStrings", null, false);
-        testExec(11, "-XX:+UseG1GC", "-XX:+CompactStrings",
+        testDump(13, "-XX:+UseG1GC", "-XX:-CompactStrings", null, false);
+        testExec(13, "-XX:+UseG1GC", "-XX:+CompactStrings",
                  COMPACT_STRING_MISMATCH, true);
-        testDump(12, "-XX:+UseG1GC", "-XX:+CompactStrings", null, false);
-        testExec(12, "-XX:+UseG1GC", "-XX:-CompactStrings",
+        testDump(14, "-XX:+UseG1GC", "-XX:+CompactStrings", null, false);
+        testExec(14, "-XX:+UseG1GC", "-XX:-CompactStrings",
                  COMPACT_STRING_MISMATCH, true);
     }
 
     static void testDump(int testCaseNr, String collectorOption, String extraOption,
         String expectedWarning, boolean expectedToFail) throws Exception {
diff a/test/hotspot/jtreg/runtime/exceptionMsgs/AbstractMethodError/AbstractMethodErrorTest.java b/test/hotspot/jtreg/runtime/exceptionMsgs/AbstractMethodError/AbstractMethodErrorTest.java
--- a/test/hotspot/jtreg/runtime/exceptionMsgs/AbstractMethodError/AbstractMethodErrorTest.java
+++ b/test/hotspot/jtreg/runtime/exceptionMsgs/AbstractMethodError/AbstractMethodErrorTest.java
@@ -23,11 +23,11 @@
  */
 
 /**
  * @test
  * @summary Check that the verbose message of the AME is printed correctly.
- * @requires !(os.arch=="arm") & vm.flavor == "server" & !vm.emulatedClient & vm.compMode=="Xmixed" & (!vm.graal.enabled | vm.opt.TieredCompilation == true) & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel==4)
+ * @requires !(os.arch=="arm") & vm.flavor == "server" & !vm.emulatedClient & vm.compMode=="Xmixed" & !vm.graal.enabled & vm.opt.UseJVMCICompiler != true & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel==4)
  * @library /test/lib /
  * @build sun.hotspot.WhiteBox
  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
  * @compile AbstractMethodErrorTest.java
  * @compile AME1_E.jasm AME2_C.jasm AME3_C.jasm AME4_E.jasm AME5_B.jasm AME6_B.jasm
diff a/test/hotspot/jtreg/serviceability/jvmti/GetClassMethods/OverpassMethods.java b/test/hotspot/jtreg/serviceability/jvmti/GetClassMethods/OverpassMethods.java
--- /dev/null
+++ b/test/hotspot/jtreg/serviceability/jvmti/GetClassMethods/OverpassMethods.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 8216324
+ * @summary GetClassMethods is confused by the presence of default methods in super interfaces
+ * @library /test/lib
+ * @compile OverpassMethods.java
+ * @run main/othervm/native -agentlib:OverpassMethods OverpassMethods
+ * @run main/othervm/native -agentlib:OverpassMethods=maintain_original_method_order OverpassMethods
+  */
+
+import java.lang.reflect.Method;
+import java.util.Arrays;
+
+public class OverpassMethods {
+
+    static {
+        try {
+            System.loadLibrary("OverpassMethods");
+        } catch (UnsatisfiedLinkError ex) {
+            System.err.println("Could not load OverpassMethods library");
+            System.err.println("java.library.path:" + System.getProperty("java.library.path"));
+            throw ex;
+        }
+    }
+
+    static private void log(Object msg) {
+        System.out.println(String.valueOf(msg));
+    }
+
+    static private native Method[] getJVMTIDeclaredMethods(Class<?> klass);
+
+    public interface Parent {
+        default String def() { return "Parent.def"; }
+        String method0();
+        String method1();
+    }
+
+    public interface Child extends Parent {
+        String method2();
+    }
+
+    public static class Impl implements Child {
+        public String method0() { return "Impl.method0"; }
+        public String method1() { return "Impl.method1"; }
+        public String method2() { return "Impl.method2"; }
+    }
+
+    public static void main(String[] args) {
+        new Impl(); // To get classes initialized
+
+        Method[] reflectMethods = Child.class.getDeclaredMethods();
+        Method[] jvmtiMethods = getJVMTIDeclaredMethods(Child.class);
+
+        if (jvmtiMethods == null) {
+            throw new RuntimeException("getJVMTIDeclaredMethods failed");
+        }
+
+        log("Reflection getDeclaredMethods returned: " + Arrays.toString(reflectMethods));
+        log("JVMTI GetClassMethods returned: " + Arrays.toString(jvmtiMethods));
+
+        if (reflectMethods.length != jvmtiMethods.length) {
+            throw new RuntimeException("OverpassMethods failed: Unexpected method count from JVMTI GetClassMethods!");
+        }
+        if (!reflectMethods[0].equals(jvmtiMethods[0])) {
+            throw new RuntimeException("OverpassMethods failed: Unexpected method from JVMTI GetClassMethods!");
+        }
+        log("Test passed: Got expected output from JVMTI GetClassMethods!");
+    }
+}
diff a/test/hotspot/jtreg/serviceability/jvmti/GetClassMethods/libOverpassMethods.cpp b/test/hotspot/jtreg/serviceability/jvmti/GetClassMethods/libOverpassMethods.cpp
--- /dev/null
+++ b/test/hotspot/jtreg/serviceability/jvmti/GetClassMethods/libOverpassMethods.cpp
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include "jvmti.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ACC_STATIC 0x0008
+
+static jvmtiEnv *jvmti = NULL;
+
+JNIEXPORT
+jint JNICALL JNI_OnLoad(JavaVM *jvm, void *reserved) {
+  return JNI_VERSION_9;
+}
+
+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {
+  vm->GetEnv((void **)&jvmti, JVMTI_VERSION_11);
+
+  if (options != NULL && strcmp(options, "maintain_original_method_order") == 0) {
+    printf("Enabled capability: maintain_original_method_order\n");
+    jvmtiCapabilities caps = {};
+    caps.can_maintain_original_method_order = 1;
+
+    jvmtiError err = jvmti->AddCapabilities(&caps);
+    if (err != JVMTI_ERROR_NONE) {
+      printf("Agent_OnLoad: AddCapabilities failed with error: %d\n", err);
+      return JNI_ERR;
+    }
+  }
+  return JNI_OK;
+}
+
+JNIEXPORT jobjectArray JNICALL Java_OverpassMethods_getJVMTIDeclaredMethods(JNIEnv *env, jclass static_klass, jclass klass) {
+  jint method_count = 0;
+  jmethodID* methods = NULL;
+  jvmtiError err = jvmti->GetClassMethods(klass, &method_count, &methods);
+  if (err != JVMTI_ERROR_NONE) {
+    printf("GetClassMethods failed with error: %d\n", err);
+    return NULL;
+  }
+
+  jclass method_cls = env->FindClass("java/lang/reflect/Method");
+  if (method_cls == NULL) {
+    printf("FindClass (Method) failed\n");
+    return NULL;
+  }
+  jobjectArray array = env->NewObjectArray(method_count, method_cls, NULL);
+  if (array == NULL) {
+    printf("NewObjectArray failed\n");
+    return NULL;
+  }
+
+  for (int i = 0; i < method_count; i++) {
+    jint modifiers = 0;
+    err = jvmti->GetMethodModifiers(methods[i], &modifiers);
+    if (err != JVMTI_ERROR_NONE) {
+      printf("GetMethodModifiers failed with error: %d\n", err);
+      return NULL;
+    }
+
+    jobject m = env->ToReflectedMethod(klass, methods[i], (modifiers & ACC_STATIC) == ACC_STATIC);
+    if (array == NULL) {
+      printf("ToReflectedMethod failed\n");
+      return NULL;
+    }
+    env->SetObjectArrayElement(array, i, m);
+
+    env->DeleteLocalRef(m);
+  }
+  jvmti->Deallocate((unsigned char *)methods);
+
+  return array;
+}
+#ifdef __cplusplus
+}
+#endif
diff a/test/hotspot/jtreg/serviceability/sa/ClhsdbPmap.java b/test/hotspot/jtreg/serviceability/sa/ClhsdbPmap.java
--- a/test/hotspot/jtreg/serviceability/sa/ClhsdbPmap.java
+++ b/test/hotspot/jtreg/serviceability/sa/ClhsdbPmap.java
@@ -24,50 +24,73 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import jdk.test.lib.apps.LingeredApp;
+import jdk.test.lib.util.CoreUtils;
 import jdk.test.lib.Platform;
 import jtreg.SkippedException;
 
 /**
  * @test
  * @bug 8190198
- * @summary Test clhsdb pmap command
+ * @summary Test clhsdb pmap command on a live process
  * @requires vm.hasSA
  * @library /test/lib
- * @run main/othervm ClhsdbPmap
+ * @run main/othervm ClhsdbPmap false
+ */
+
+/**
+ * @test
+ * @bug 8190198
+ * @summary Test clhsdb pmap command on a core file
+ * @requires vm.hasSA
+ * @library /test/lib
+ * @run main/othervm ClhsdbPmap true
  */
 
 public class ClhsdbPmap {
 
     public static void main(String[] args) throws Exception {
-        System.out.println("Starting ClhsdbPmap test");
+        boolean withCore = Boolean.parseBoolean(args[0]);
+        System.out.println("Starting ClhsdbPmap test: withCore==" + withCore);
 
         LingeredApp theApp = null;
+        String coreFileName = null;
         try {
             ClhsdbLauncher test = new ClhsdbLauncher();
-            theApp = LingeredApp.startApp();
+            theApp = new LingeredApp();
+            theApp.setForceCrash(withCore);
+            LingeredApp.startApp(theApp);
             System.out.println("Started LingeredApp with pid " + theApp.getPid());
 
+            if (withCore) {
+                String crashOutput = theApp.getOutput().getStdout();
+                coreFileName = CoreUtils.getCoreFileLocation(crashOutput);
+            }
+
             List<String> cmds = List.of("pmap");
 
             Map<String, List<String>> expStrMap = new HashMap<>();
-            if (Platform.isOSX()) {
-                expStrMap.put("pmap",
-                    List.of("Not available on Mac OS X"));
+            if (!withCore && Platform.isOSX()) {
+                expStrMap.put("pmap", List.of("Not available for Mac OS X processes"));
             } else {
-                expStrMap.put("pmap",
-                    List.of("jvm", "java", "net", "nio", "jimage"));
+                expStrMap.put("pmap", List.of("jvm", "java", "jli", "jimage"));
             }
 
-            test.run(theApp.getPid(), cmds, expStrMap, null);
+            if (withCore) {
+                test.runOnCore(coreFileName, cmds, expStrMap, null);
+            } else {
+                test.run(theApp.getPid(), cmds, expStrMap, null);
+            }
         } catch (SkippedException se) {
             throw se;
         } catch (Exception ex) {
             throw new RuntimeException("Test ERROR " + ex, ex);
         } finally {
-            LingeredApp.stopApp(theApp);
+            if (!withCore) {
+                LingeredApp.stopApp(theApp);
+            }
         }
         System.out.println("Test PASSED");
     }
 }
diff a/test/hotspot/jtreg/serviceability/sa/ClhsdbPstack.java b/test/hotspot/jtreg/serviceability/sa/ClhsdbPstack.java
--- a/test/hotspot/jtreg/serviceability/sa/ClhsdbPstack.java
+++ b/test/hotspot/jtreg/serviceability/sa/ClhsdbPstack.java
@@ -24,53 +24,78 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import jdk.test.lib.apps.LingeredApp;
+import jdk.test.lib.util.CoreUtils;
 import jdk.test.lib.Platform;
 import jtreg.SkippedException;
 
 /**
  * @test
  * @bug 8190198
- * @summary Test clhsdb pstack command
+ * @summary Test clhsdb pstack command on a live process
  * @requires vm.hasSA
  * @library /test/lib
- * @run main/othervm ClhsdbPstack
+ * @run main/othervm ClhsdbPstack false
+ */
+
+/**
+ * @test
+ * @bug 8190198
+ * @summary Test clhsdb pstack command on a core file
+ * @requires vm.hasSA
+ * @library /test/lib
+ * @run main/othervm ClhsdbPstack true
  */
 
 public class ClhsdbPstack {
 
     public static void main(String[] args) throws Exception {
-        System.out.println("Starting ClhsdbPstack test");
+        boolean withCore = Boolean.parseBoolean(args[0]);
+        System.out.println("Starting ClhsdbPstack test: withCore==" + withCore);
 
         LingeredApp theApp = null;
+        String coreFileName = null;
         try {
             ClhsdbLauncher test = new ClhsdbLauncher();
-            theApp = LingeredApp.startApp();
+            theApp = new LingeredApp();
+            theApp.setForceCrash(withCore);
+            LingeredApp.startApp(theApp);
             System.out.println("Started LingeredApp with pid " + theApp.getPid());
 
+            if (withCore) {
+                String crashOutput = theApp.getOutput().getStdout();
+                coreFileName = CoreUtils.getCoreFileLocation(crashOutput);
+            }
+
             List<String> cmds = List.of("pstack -v");
 
             Map<String, List<String>> expStrMap = new HashMap<>();
-            if (Platform.isOSX()) {
+            if (!withCore && Platform.isOSX()) {
                 expStrMap.put("pstack -v", List.of(
-                    "Not available on Mac OS X"));
+                    "Not available for Mac OS X processes"));
             } else {
                 expStrMap.put("pstack -v", List.of(
                     "No deadlocks found", "Common-Cleaner",
                     "Signal Dispatcher", "CompilerThread",
                     "Sweeper thread", "Service Thread",
                     "Reference Handler", "Finalizer", "main"));
             }
 
-            test.run(theApp.getPid(), cmds, expStrMap, null);
+            if (withCore) {
+                test.runOnCore(coreFileName, cmds, expStrMap, null);
+            } else {
+                test.run(theApp.getPid(), cmds, expStrMap, null);
+            }
         } catch (SkippedException se) {
             throw se;
         } catch (Exception ex) {
             throw new RuntimeException("Test ERROR " + ex, ex);
         } finally {
-            LingeredApp.stopApp(theApp);
+            if (!withCore) {
+                LingeredApp.stopApp(theApp);
+            }
         }
         System.out.println("Test PASSED");
     }
 }
diff a/test/hotspot/jtreg/vmTestbase/nsk/jvmti/GetClassMethods/getclmthd007.java b/test/hotspot/jtreg/vmTestbase/nsk/jvmti/GetClassMethods/getclmthd007.java
--- a/test/hotspot/jtreg/vmTestbase/nsk/jvmti/GetClassMethods/getclmthd007.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/jvmti/GetClassMethods/getclmthd007.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -79,10 +79,11 @@
             fld = s;
         }
     }
 
     static interface InnerInterface {
+        default void meth_def1() {}
         void meth_n1();
     }
 
     static class InnerClass2 implements InnerInterface {
         static int count = 0;
@@ -107,11 +108,15 @@
     int meth_o3() {
         return 3;
     }
 }
 
-interface OuterInterface1 {
+interface DefaultInterface {
+    default void default_method() { }
+}
+
+interface OuterInterface1 extends DefaultInterface {
     int meth_i1();
 }
 
 interface OuterInterface2 extends OuterInterface1 {
     int meth_i2();
diff a/test/hotspot/jtreg/vmTestbase/nsk/jvmti/GetClassMethods/getclmthd007/getclmthd007.cpp b/test/hotspot/jtreg/vmTestbase/nsk/jvmti/GetClassMethods/getclmthd007/getclmthd007.cpp
--- a/test/hotspot/jtreg/vmTestbase/nsk/jvmti/GetClassMethods/getclmthd007/getclmthd007.cpp
+++ b/test/hotspot/jtreg/vmTestbase/nsk/jvmti/GetClassMethods/getclmthd007/getclmthd007.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -52,11 +52,12 @@
     { "<init>", "(Lnsk/jvmti/GetClassMethods/getclmthd007;)V" },
     { "meth_1", "(Ljava/lang/String;)V" }
 };
 
 static meth_info m1[] = {
-    { "meth_n1", "()V" }
+    { "meth_n1", "()V" },
+    { "meth_def1", "()V" }
 };
 
 static meth_info m2[] = {
     { "<init>", "()V" },
     { "meth_n1", "()V" },
@@ -96,11 +97,11 @@
     { "meth_i1", "()I" }
 };
 
 static class_info classes[] = {
     { "InnerClass1", 2, m0 },
-    { "InnerInterface", 1, m1 },
+    { "InnerInterface", 2, m1 },
     { "InnerClass2", 4, m2 },
     { "OuterClass1", 1, m3 },
     { "OuterClass2", 2, m4 },
     { "OuterClass3", 2, m5 },
     { "OuterInterface1", 1, m6 },
@@ -143,10 +144,11 @@
     jint mcount;
     jmethodID *methods;
     char *name, *sig, *generic;
     int j, k;
 
+    int failed = JNI_FALSE; // enable debugging on failure
     if (jvmti == NULL) {
         printf("JVMTI client was not properly loaded!\n");
         result = STATUS_FAILED;
         return;
     }
@@ -165,16 +167,18 @@
 
     if (mcount != classes[i].mcount) {
         printf("(%d) wrong number of methods: %d, expected: %d\n",
                i, mcount, classes[i].mcount);
         result = STATUS_FAILED;
+        failed = JNI_TRUE; // show the methods found
+        printf(">>> %s:\n", classes[i].name);
     }
     for (k = 0; k < mcount; k++) {
         if (methods[k] == NULL) {
             printf("(%d:%d) methodID = null\n", i, k);
             result = STATUS_FAILED;
-        } else if (printdump == JNI_TRUE) {
+        } else if (printdump == JNI_TRUE || failed == JNI_TRUE) {
             err = jvmti->GetMethodName(methods[k],
                 &name, &sig, &generic);
             if (err == JVMTI_ERROR_NONE) {
                 printf(">>>   [%d]: %s%s\n", k, name, sig);
             }
diff a/test/hotspot/jtreg/vmTestbase/nsk/share/Harakiri.java b/test/hotspot/jtreg/vmTestbase/nsk/share/Harakiri.java
--- a/test/hotspot/jtreg/vmTestbase/nsk/share/Harakiri.java
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package nsk.share;
-
-/**
- * Harakiri is used to terminate a stress test with PASS exit status
- * before the test is terminated as timed out (and so failed).
- *
- * <p>Harakiri class holds a thread which sleeps for the given amount
- * of time, and then wakes up and executes <tt>System.exit()</tt>
- * with the given exit status. That thread is daemon, so it doesn't
- * prevent application from exiting once all its threads finish
- * before it's time for harakiri. Appointing harakiri in zero
- * delay implies immediate <tt>exit()</tt>.
- *
- * <p>There is a limitation: you may appoint no more than one harakiri
- * per application.
- */
-public class Harakiri {
-    /**
-     * Use specific <tt>appoint()</tt> method to appoint harakiri.
-     *
-     * @see #appoint(int)
-     * @see #appoint(int,int)
-     */
-    protected Harakiri() {}
-
-    /**
-     * One harakiri per application, or <tt>null</tt> (by default).
-     */
-    private static Thread harakiri = null;
-
-    /**
-     * <p>Return timeout (or waittime) value munus the margin
-     * value (which is assumed 1 minute by default).
-     *
-     * <p>Treat <tt>args[0]</tt> as <tt>$TIMEOUT</tt> value, or seek for
-     * <tt>-waittime=$WAITTIME</tt> value. If both parameters
-     * (or either none of them) are assigned, throw an exception to
-     * report parameters inconsistency.
-     *
-     * <p>Also, seek for <tt>-margin=...</tt> assignment, or assume margin
-     * is 1 minute.
-     *
-     * @param args Is usually obtained via the application's command-line.
-     *
-     * @throws IllegalArgumentException If <tt>args[]</tt> is inconsistent.
-     *
-     * @see #appoint(int)
-     * @see #appoint(int,int)
-     */
-    public static int parseAppointment(String args[]) {
-        int timeout=-1, margin=1;
-        int timeouts=0, waittimes=0, margins=0;
-        for (int i=0; i<args.length; i++) {
-            if (args[i].startsWith("-")) {
-                if (args[i].startsWith("-waittime=")) {
-                    timeout = Integer.parseInt(args[i].substring(10));
-                    waittimes++;
-                }
-                if (args[i].startsWith("-margin=")) {
-                    margin = Integer.parseInt(args[i].substring(8));
-                    margins++;
-                }
-            } else {
-                if (i == 0) {
-                    timeout = Integer.parseInt(args[i]);
-                    timeouts++;
-                }
-            }
-        };
-        if (timeouts==0 && waittimes==0)
-            throw new IllegalArgumentException(
-                "no $TIMEOUT, nor -waittime=$WAITTIME is set");
-        if (waittimes > 1)
-            throw new IllegalArgumentException(
-                "more than one -waittime=... is set");
-        if (margins > 1)
-            throw new IllegalArgumentException(
-                "more than one -margin=... is set");
-
-        int result = timeout - margin;
-        if (result <= 0)
-            throw new IllegalArgumentException(
-                "delay appointment must be greater than "+margin+" minutes");
-        return result;
-    }
-
-    /**
-     * Appoint harakiri after the given amount of <tt>minutes</tt>,
-     * so that exit status would be 95 (to simulate JCK-like PASS
-     * status).
-     *
-     * @throws IllegalStateException If harakiri is already appointed.
-     *
-     * @see #appoint(int,int)
-     * @see #parseAppointment(String[])
-     */
-    public static void appoint(int minutes) {
-        appoint(minutes,95); // JCK-like PASS status
-    }
-
-    /**
-     * Appoint Harakiri for the given amount of <tt>minutes</tt>,
-     * so that the given <tt>status</tt> would be exited when time
-     * is over.
-     *
-     * @throws IllegalStateException If harakiri is already appointed.
-     *
-     * @see #appoint(int)
-     * @see #parseAppointment(String[])
-     */
-    public static void appoint(int minutes, int status) {
-        if (harakiri != null)
-            throw new IllegalStateException("Harakiri is already appointed.");
-
-        final long timeToExit = System.currentTimeMillis() + 60*1000L*minutes;
-        final int  exitStatus = status;
-
-        harakiri = new Thread(Harakiri.class.getName()) {
-            public void run() {
-                long timeToSleep = timeToExit - System.currentTimeMillis();
-                if (timeToSleep > 0)
-                    try {
-                        //
-                        // Use wait() instead of sleep(), because Java 2
-                        // specification doesn't guarantee the method
-                        // sleep() to yield to other threads.
-                        //
-                        Object someDummyObject = new Object();
-                        synchronized (someDummyObject) {
-                            someDummyObject.wait(timeToSleep);
-                        }
-                    } catch (InterruptedException exception) {
-                        exception.printStackTrace(System.err);
-                       //
-                       // OOPS, the dagger for harakiri looks broken:
-                       //
-                       return;
-                    };
-                //
-                // OK, lets do it now:
-                //
-                System.err.println(
-                    "#\n# Harakiri: prescheduled program termination.\n#");
-                System.exit(exitStatus); // harakiri to all threads
-            }
-        };
-
-        harakiri.setPriority(Thread.MAX_PRIORITY);
-        harakiri.setDaemon(true);
-        harakiri.start();
-    }
-}
diff a/test/hotspot/jtreg/vmTestbase/nsk/share/README b/test/hotspot/jtreg/vmTestbase/nsk/share/README
--- a/test/hotspot/jtreg/vmTestbase/nsk/share/README
+++ b/test/hotspot/jtreg/vmTestbase/nsk/share/README
@@ -1,6 +1,6 @@
-Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
 DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 
 This code is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License version 2 only, as
 published by the Free Software Foundation.
@@ -52,11 +52,11 @@
     threads synchronization:
         Wicket.java
     text processing:
         Grep.java, Paragrep.java
     timeouts handling:
-        Harakiri.java, TimeoutHandler.java
+        Terminator.java, TimeoutHandler.java
     tree structures support:
         Denotation.java, TreeNodesDenotation.java
     RAS mode support:
         RASagent.java, JVMTIagent.c
     JVMDI tests support:
diff a/test/hotspot/jtreg/vmTestbase/nsk/share/Terminator.java b/test/hotspot/jtreg/vmTestbase/nsk/share/Terminator.java
--- /dev/null
+++ b/test/hotspot/jtreg/vmTestbase/nsk/share/Terminator.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package nsk.share;
+
+/**
+ * Terminator is used to terminate a stress test with PASS exit status
+ * before the test is terminated as timed out (and so failed).
+ *
+ * <p>Terminator class holds a thread which sleeps for the given amount
+ * of time, and then wakes up and executes <tt>System.exit()</tt>
+ * with the given exit status. That thread is daemon, so it doesn't
+ * prevent application from exiting once all its threads finish
+ * before it's time for termination. Appointing terminator in zero
+ * delay implies immediate <tt>exit()</tt>.
+ *
+ * <p>There is a limitation: you may appoint no more than one terminator
+ * per application.
+ */
+public class Terminator {
+    /**
+     * Use specific <tt>appoint()</tt> method to appoint terminator.
+     *
+     * @see #appoint(int)
+     * @see #appoint(int,int)
+     */
+    protected Terminator() {}
+
+    /**
+     * One terminator per application, or <tt>null</tt> (by default).
+     */
+    private static Thread terminator = null;
+
+    /**
+     * <p>Return timeout (or waittime) value munus the margin
+     * value (which is assumed 1 minute by default).
+     *
+     * <p>Treat <tt>args[0]</tt> as <tt>$TIMEOUT</tt> value, or seek for
+     * <tt>-waittime=$WAITTIME</tt> value. If both parameters
+     * (or either none of them) are assigned, throw an exception to
+     * report parameters inconsistency.
+     *
+     * <p>Also, seek for <tt>-margin=...</tt> assignment, or assume margin
+     * is 1 minute.
+     *
+     * @param args Is usually obtained via the application's command-line.
+     *
+     * @throws IllegalArgumentException If <tt>args[]</tt> is inconsistent.
+     *
+     * @see #appoint(int)
+     * @see #appoint(int,int)
+     */
+    public static int parseAppointment(String args[]) {
+        int timeout=-1, margin=1;
+        int timeouts=0, waittimes=0, margins=0;
+        for (int i=0; i<args.length; i++) {
+            if (args[i].startsWith("-")) {
+                if (args[i].startsWith("-waittime=")) {
+                    timeout = Integer.parseInt(args[i].substring(10));
+                    waittimes++;
+                }
+                if (args[i].startsWith("-margin=")) {
+                    margin = Integer.parseInt(args[i].substring(8));
+                    margins++;
+                }
+            } else {
+                if (i == 0) {
+                    timeout = Integer.parseInt(args[i]);
+                    timeouts++;
+                }
+            }
+        };
+        if (timeouts==0 && waittimes==0)
+            throw new IllegalArgumentException(
+                "no $TIMEOUT, nor -waittime=$WAITTIME is set");
+        if (waittimes > 1)
+            throw new IllegalArgumentException(
+                "more than one -waittime=... is set");
+        if (margins > 1)
+            throw new IllegalArgumentException(
+                "more than one -margin=... is set");
+
+        int result = timeout - margin;
+        if (result <= 0)
+            throw new IllegalArgumentException(
+                "delay appointment must be greater than "+margin+" minutes");
+        return result;
+    }
+
+    /**
+     * Appoint terminator after the given amount of <tt>minutes</tt>,
+     * so that exit status would be 95 (to simulate JCK-like PASS
+     * status).
+     *
+     * @throws IllegalStateException If terminator is already appointed.
+     *
+     * @see #appoint(int,int)
+     * @see #parseAppointment(String[])
+     */
+    public static void appoint(int minutes) {
+        appoint(minutes,95); // JCK-like PASS status
+    }
+
+    /**
+     * Appoint Terminator for the given amount of <tt>minutes</tt>,
+     * so that the given <tt>status</tt> would be exited when time
+     * is over.
+     *
+     * @throws IllegalStateException If terminator is already appointed.
+     *
+     * @see #appoint(int)
+     * @see #parseAppointment(String[])
+     */
+    public static void appoint(int minutes, int status) {
+        if (terminator != null)
+            throw new IllegalStateException("Terminator is already appointed.");
+
+        final long timeToExit = System.currentTimeMillis() + 60*1000L*minutes;
+        final int  exitStatus = status;
+
+        terminator = new Thread(Terminator.class.getName()) {
+            public void run() {
+                long timeToSleep = timeToExit - System.currentTimeMillis();
+                if (timeToSleep > 0)
+                    try {
+                        //
+                        // Use wait() instead of sleep(), because Java 2
+                        // specification doesn't guarantee the method
+                        // sleep() to yield to other threads.
+                        //
+                        Object someDummyObject = new Object();
+                        synchronized (someDummyObject) {
+                            someDummyObject.wait(timeToSleep);
+                        }
+                    } catch (InterruptedException exception) {
+                        exception.printStackTrace(System.err);
+                        return;
+                    };
+                //
+                // OK, lets do it now:
+                //
+                System.err.println(
+                    "#\n# Terminator: prescheduled program termination.\n#");
+                System.exit(exitStatus); // terminator to all threads
+            }
+        };
+
+        terminator.setPriority(Thread.MAX_PRIORITY);
+        terminator.setDaemon(true);
+        terminator.start();
+    }
+}
diff a/test/hotspot/jtreg/vmTestbase/nsk/stress/stack/stack016.java b/test/hotspot/jtreg/vmTestbase/nsk/stress/stack/stack016.java
--- a/test/hotspot/jtreg/vmTestbase/nsk/stress/stack/stack016.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/stress/stack/stack016.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -55,11 +55,11 @@
  */
 
 package nsk.stress.stack;
 
 
-import nsk.share.Harakiri;
+import nsk.share.Terminator;
 
 import java.io.PrintStream;
 
 public class stack016 extends Thread {
     private final static int THREADS = 10;
@@ -80,11 +80,11 @@
             if (args[i].toLowerCase().equals("-verbose"))
                 verbose = true;
             else if (args[i].toLowerCase().equals("-eager"))
                 eager = true;
         if (!eager)
-            Harakiri.appoint(Harakiri.parseAppointment(args));
+            Terminator.appoint(Terminator.parseAppointment(args));
         stack016.out = out;
         stack016 test = new stack016();
         return test.doRun();
     }
 
diff a/test/hotspot/jtreg/vmTestbase/nsk/stress/stack/stack017.java b/test/hotspot/jtreg/vmTestbase/nsk/stress/stack/stack017.java
--- a/test/hotspot/jtreg/vmTestbase/nsk/stress/stack/stack017.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/stress/stack/stack017.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -48,11 +48,11 @@
  */
 
 package nsk.stress.stack;
 
 
-import nsk.share.Harakiri;
+import nsk.share.Terminator;
 
 import java.io.PrintStream;
 
 public class stack017 extends Thread {
     private final static int THREADS = 10;
@@ -71,11 +71,11 @@
             if (args[i].toLowerCase().equals("-verbose"))
                 verbose = true;
             else if (args[i].toLowerCase().equals("-eager"))
                 eager = true;
         if (!eager)
-            Harakiri.appoint(Harakiri.parseAppointment(args));
+            Terminator.appoint(Terminator.parseAppointment(args));
         stack017.out = out;
         stack017 test = new stack017();
         return test.doRun();
     }
 
diff a/test/hotspot/jtreg/vmTestbase/nsk/stress/stack/stack018.java b/test/hotspot/jtreg/vmTestbase/nsk/stress/stack/stack018.java
--- a/test/hotspot/jtreg/vmTestbase/nsk/stress/stack/stack018.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/stress/stack/stack018.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -53,11 +53,11 @@
  */
 
 package nsk.stress.stack;
 
 
-import nsk.share.Harakiri;
+import nsk.share.Terminator;
 
 import java.io.PrintStream;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 
@@ -79,11 +79,11 @@
             if (args[i].toLowerCase().equals("-verbose"))
                 verbose = true;
             else if (args[i].toLowerCase().equals("-eager"))
                 eager = true;
         if (!eager)
-            Harakiri.appoint(Harakiri.parseAppointment(args));
+            Terminator.appoint(Terminator.parseAppointment(args));
         stack018.out = out;
         stack018 test = new stack018();
         return test.doRun();
     }
 
diff a/test/hotspot/jtreg/vmTestbase/nsk/stress/stack/stack019.java b/test/hotspot/jtreg/vmTestbase/nsk/stress/stack/stack019.java
--- a/test/hotspot/jtreg/vmTestbase/nsk/stress/stack/stack019.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/stress/stack/stack019.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -46,11 +46,11 @@
  */
 
 package nsk.stress.stack;
 
 
-import nsk.share.Harakiri;
+import nsk.share.Terminator;
 
 import java.io.PrintStream;
 
 public class stack019 {
     private final static int CYCLES = 100;
@@ -67,11 +67,11 @@
             if (args[i].toLowerCase().equals("-verbose"))
                 verbose = true;
             else if (args[i].toLowerCase().equals("-eager"))
                 eager = true;
         if (!eager)
-            Harakiri.appoint(Harakiri.parseAppointment(args));
+            Terminator.appoint(Terminator.parseAppointment(args));
         //
         // Measure recursive depth before stack overflow:
         //
         try {
             recurse(0);
diff a/test/jdk/ProblemList.txt b/test/jdk/ProblemList.txt
--- a/test/jdk/ProblemList.txt
+++ b/test/jdk/ProblemList.txt
@@ -588,11 +588,11 @@
 ############################################################################
 
 # jdk_io
 
 java/io/pathNames/GeneralWin32.java                             8180264 windows-all
-java/io/File/GetXSpace.java                                     6501010,8249703 windows-all,macosx-all
+java/io/File/GetXSpace.java                                     8249703 macosx-all
 
 ############################################################################
 
 # jdk_management
 
@@ -634,12 +634,10 @@
 
 java/nio/channels/AsynchronousSocketChannel/StressLoopback.java 8211851 aix-ppc64
 
 java/nio/channels/Selector/Wakeup.java                          6963118 windows-all
 
-sun/nio/ch/TestMaxCachedBufferSize.java                         8212812 macosx-all
-
 ############################################################################
 
 # jdk_rmi
 
 java/rmi/server/Unreferenced/finiteGCLatency/FiniteGCLatency.java 7140992 generic-all
@@ -819,11 +817,10 @@
 javax/swing/UIDefaults/8133926/InternalFrameIcon.java 8199075 generic-all
 javax/swing/UIDefaults/8149879/InternalResourceBundle.java 8199054 windows-all
 javax/swing/text/html/parser/Parser/8078268/bug8078268.java 8199092 generic-all
 javax/swing/PopupFactory/8048506/bug8048506.java 8202660 windows-all
 javax/swing/JTextArea/TextViewOOM/TextViewOOM.java 8167355 generic-all
-javax/swing/text/Utilities/8142966/SwingFontMetricsTest.java 8199529 windows-all
 javax/swing/JPopupMenu/8075063/ContextMenuScrollTest.java 202880 linux-all
 javax/swing/dnd/8139050/NativeErrorsInTableDnD.java 8202765  macosx-all,linux-all
 javax/swing/Popup/TaskbarPositionTest.java 8065097 macosx-all,linux-all
 javax/swing/JEditorPane/6917744/bug6917744.java 8213124 macosx-all
 javax/swing/JTable/6263446/bug6263446.java 8169959 macosx-all
@@ -926,8 +923,7 @@
 ############################################################################
 
 # jdk_jpackage
 
 tools/jpackage/share/jdk/jpackage/tests/ModulePathTest3.java#id0    8248418 generic-all
-tools/jpackage/share/EmptyFolderPackageTest.java                    8249201 macosx-all
 
 ############################################################################
diff a/test/jdk/java/awt/FontClass/ZeroWidthStringBoundsTest.java b/test/jdk/java/awt/FontClass/ZeroWidthStringBoundsTest.java
--- /dev/null
+++ b/test/jdk/java/awt/FontClass/ZeroWidthStringBoundsTest.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8245159 8239725
+ * @summary Ensure no exception getting bounds of an empty string when the font has
+ * layout attributes.
+ * @run main/othervm ZeroWidthStringBoundsTest
+ */
+
+import java.awt.Font;
+import java.awt.font.FontRenderContext;
+import java.awt.font.TextAttribute;
+import java.text.AttributedCharacterIterator;
+import java.util.HashMap;
+
+public class ZeroWidthStringBoundsTest {
+
+   public static void main(String[] args) {
+       FontRenderContext frc = new FontRenderContext(null, false, false);
+       Font f1 = new Font(Font.MONOSPACED, Font.PLAIN, 12);
+       f1.getStringBounds("", frc);
+       HashMap<AttributedCharacterIterator.Attribute, Object> attrs = new HashMap<>();
+       attrs.put(TextAttribute.KERNING, TextAttribute.KERNING_ON);
+       Font f2 = f1.deriveFont(attrs);
+       f2.getStringBounds("", frc);
+   }
+}
diff a/test/jdk/java/io/File/GetXSpace.java b/test/jdk/java/io/File/GetXSpace.java
--- a/test/jdk/java/io/File/GetXSpace.java
+++ b/test/jdk/java/io/File/GetXSpace.java
@@ -45,78 +45,60 @@
 public class GetXSpace {
 
     private static SecurityManager [] sma = { null, new Allow(), new DenyFSA(),
                                               new DenyRead() };
 
-    private static final String name = System.getProperty("os.name");
-    private static final String dfFormat;
-    static {
-        if (name.equals("Linux") || name.contains("OS X")) {
-            // FileSystem Total Used Available Use% MountedOn
-            dfFormat = "([^\\s]+)\\s+(\\d+)\\s+\\d+\\s+(\\d+)\\s+\\d+%\\s+([^\\s]+)";
-        } else if (name.startsWith("Windows")) {
-            // Drive (MountedOn) Available/Total
-            dfFormat = "([^\\s]+)\\s+\\(([^\\s]+)\\)\\s+(\\d+)\\/(\\d+)\\s+";
-        } else {
-            throw new RuntimeException("unrecognized system:"
-                                       + " os.name == " + name);
-        }
-    }
-    private static Pattern dfPattern = Pattern.compile(dfFormat);
+    private static final String osName = System.getProperty("os.name");
+    // FileSystem Total Used Available Use% MountedOn
+    private static final Pattern dfPattern = Pattern.compile("([^\\s]+)\\s+(\\d+)\\s+\\d+\\s+(\\d+)\\s+\\d+%\\s+([^\\s].*)\n");
 
     private static int fail = 0;
     private static int pass = 0;
     private static Throwable first;
 
     static void pass() {
         pass++;
     }
 
     static void fail(String p) {
-        if (first == null)
-            setFirst(p);
+        setFirst(p);
         System.err.format("FAILED: %s%n", p);
         fail++;
     }
 
     static void fail(String p, long exp, String cmp, long got) {
         String s = String.format("'%s': %d %s %d", p, exp, cmp, got);
-        if (first == null)
-            setFirst(s);
+        setFirst(s);
         System.err.format("FAILED: %s%n", s);
         fail++;
     }
 
     private static void fail(String p, Class ex) {
         String s = String.format("'%s': expected %s - FAILED%n", p, ex.getName());
-        if (first == null)
-            setFirst(s);
+        setFirst(s);
         System.err.format("FAILED: %s%n", s);
         fail++;
     }
 
     private static void setFirst(String s) {
-        try {
-            throw new RuntimeException(s);
-        } catch (RuntimeException x) {
-            first = x;
+        if (first == null) {
+            first = new RuntimeException(s);
         }
     }
 
     private static class Space {
         private static final long KSIZE = 1024;
-        private String name;
-        private long total;
-        private long free;
+        private final String name;
+        private final long total;
+        private final long free;
 
         Space(String total, String free, String name) {
             try {
                 this.total = Long.valueOf(total) * KSIZE;
                 this.free = Long.valueOf(free) * KSIZE;
             } catch (NumberFormatException x) {
-                // the regex should have caught this
-                assert false;
+                throw new RuntimeException("the regex should have caught this", x);
             }
             this.name = name;
         }
 
         String name() { return name; }
@@ -128,40 +110,39 @@
         public String toString() {
             return String.format("%s (%d/%d)", name, free, total);
         }
     }
 
-    private static ArrayList space(String f) throws IOException {
-        ArrayList al = new ArrayList();
+    private static ArrayList<Space> space(String f) throws IOException {
+        ArrayList<Space> al = new ArrayList<>();
 
-        Process p = null;
         String cmd = "df -k -P" + (f == null ? "" : " " + f);
-        p = Runtime.getRuntime().exec(cmd);
-        BufferedReader in = new BufferedReader
-            (new InputStreamReader(p.getInputStream()));
-        String s;
-        int i = 0;
         StringBuilder sb = new StringBuilder();
-        while ((s = in.readLine()) != null) {
-            // skip header
-            if (i++ == 0 && !name.startsWith("Windows")) continue;
-            sb.append(s).append("\n");
+        Process p = Runtime.getRuntime().exec(cmd);
+        try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {
+            String s;
+            int i = 0;
+            while ((s = in.readLine()) != null) {
+                // skip header
+                if (i++ == 0) continue;
+                sb.append(s).append("\n");
+            }
         }
+        out.println(sb);
 
         Matcher m = dfPattern.matcher(sb);
         int j = 0;
         while (j < sb.length()) {
             if (m.find(j)) {
-                if (!name.startsWith("Windows")) {
-                    // swap can change while this test is running
-                    if (!m.group(1).equals("swap")) {
-                        String name = (f == null ? m.group(4): f);
-                        al.add(new Space(m.group(2), m.group(3), name));;
+                // swap can change while this test is running
+                if (!m.group(1).equals("swap")) {
+                    String name = f;
+                    if (name == null) {
+                        // cygwin's df lists windows path as FileSystem (1st group)
+                        name = osName.startsWith("Windows") ? m.group(1) : m.group(4);
                     }
-                } else {
-                    String name = (f == null ? m.group(2) : f);
-                    al.add(new Space(m.group(4), m.group(3), name ));;
+                    al.add(new Space(m.group(2), m.group(3), name));;
                 }
                 j = m.end() + 1;
             } else {
                 throw new RuntimeException("unrecognized df output format: "
                                            + "charAt(" + j + ") = '"
@@ -172,11 +153,10 @@
         if (al.size() == 0) {
             // df did not produce output
             String name = (f == null ? "" : f);
             al.add(new Space("0", "0", name));
         }
-        in.close();
         return al;
     }
 
     private static void tryCatch(Space s) {
         out.format("%s:%n", s.name());
@@ -218,66 +198,74 @@
         String fmt = "  %-4s total= %12d free = %12d usable = %12d%n";
         out.format(fmt, "df", s.total(), 0, s.free());
         out.format(fmt, "getX", ts, fs, us);
 
         // if the file system can dynamically change size, this check will fail
-        if (ts != s.total())
+        if (ts != s.total()) {
             fail(s.name(), s.total(), "!=", ts);
-        else
+        } else {
             pass();
+        }
 
         // unix df returns statvfs.f_bavail
-        long tsp = (!name.startsWith("Windows") ? us : fs);
-        if (!s.woomFree(tsp))
+        long tsp = (!osName.startsWith("Windows") ? us : fs);
+        if (!s.woomFree(tsp)) {
             fail(s.name(), s.free(), "??", tsp);
-        else
+        } else {
             pass();
+        }
 
-        if (fs > s.total())
+        if (fs > s.total()) {
             fail(s.name(), s.total(), ">", fs);
-        else
+        } else {
             pass();
+        }
 
-        if (us > s.total())
+        if (us > s.total()) {
             fail(s.name(), s.total(), ">", us);
-        else
+        } else {
             pass();
+        }
     }
 
     private static String FILE_PREFIX = "/getSpace.";
     private static void compareZeroNonExist() {
         File f;
         while (true) {
             f = new File(FILE_PREFIX + Math.random());
-            if (f.exists())
+            if (f.exists()) {
                 continue;
+            }
             break;
         }
 
         long [] s = { f.getTotalSpace(), f.getFreeSpace(), f.getUsableSpace() };
 
         for (int i = 0; i < s.length; i++) {
-            if (s[i] != 0L)
+            if (s[i] != 0L) {
                 fail(f.getName(), s[i], "!=", 0L);
-            else
+            } else {
                 pass();
+            }
         }
     }
 
     private static void compareZeroExist() {
         try {
             File f = File.createTempFile("tmp", null, new File("."));
 
             long [] s = { f.getTotalSpace(), f.getFreeSpace(), f.getUsableSpace() };
 
             for (int i = 0; i < s.length; i++) {
-                if (s[i] == 0L)
+                if (s[i] == 0L) {
                     fail(f.getName(), s[i], "==", 0L);
-                else
+                } else {
                     pass();
+                }
             }
         } catch (IOException x) {
+            x.printStackTrace();
             fail("Couldn't create temp file for test");
         }
     }
 
     private static class Allow extends SecurityManager {
@@ -326,24 +314,24 @@
         }
     }
 
     private static void testFile(String dirName) {
         out.format("--- Testing %s%n", dirName);
-        ArrayList l;
+        ArrayList<Space> l;
         try {
             l = space(dirName);
         } catch (IOException x) {
             throw new RuntimeException(dirName + " can't get file system information", x);
         }
-        compare((GetXSpace.Space) l.get(0));
+        compare(l.get(0));
     }
 
     private static void testDF() {
-        out.format("--- Testing df");
+        out.println("--- Testing df");
         // Find all of the partitions on the machine and verify that the size
         // returned by "df" is equivalent to File.getXSpace() values.
-        ArrayList l;
+        ArrayList<Space> l;
         try {
             l = space(null);
         } catch (IOException x) {
             throw new RuntimeException("can't get file system information", x);
         }
@@ -357,12 +345,11 @@
                 throw new RuntimeException("Test configuration error "
                                            + " - can't set security manager");
 
             out.format("%nSecurityManager = %s%n" ,
                        (sm == null ? "null" : sm.getClass().getName()));
-            for (int j = 0; j < l.size(); j++) {
-                Space s = (GetXSpace.Space) l.get(j);
+            for (var s : l) {
                 if (sm instanceof Deny) {
                     tryCatch(s);
                 } else {
                     compare(s);
                     compareZeroNonExist();
@@ -377,12 +364,13 @@
             testFile(args[0]);
         } else {
             testDF();
         }
 
-        if (fail != 0)
+        if (fail != 0) {
             throw new RuntimeException((fail + pass) + " tests: "
                                        + fail + " failure(s), first", first);
-        else
+        } else {
             out.format("all %d tests passed%n", fail + pass);
+        }
     }
 }
diff a/test/jdk/java/io/File/GetXSpace.sh b/test/jdk/java/io/File/GetXSpace.sh
--- a/test/jdk/java/io/File/GetXSpace.sh
+++ b/test/jdk/java/io/File/GetXSpace.sh
@@ -26,13 +26,14 @@
 # set platform-dependent variable
 OS=`uname -s`
 case "$OS" in
   Linux | Darwin ) TMP=/tmp ;;
   Windows_98 )    return    ;;
+  CYGWIN_* )      TMP="c:/temp" ;;
   Windows* )      SID=`sid`; TMP="c:/temp"  ;;
   * )
-    echo "Unrecognized system!"
+    echo "Unrecognized system! ${OS}"
     exit 1
     ;;
 esac
 
 TMP1=${TMP}/tmp1_$$
diff a/test/jdk/java/util/regex/RegExTest.java b/test/jdk/java/util/regex/RegExTest.java
--- a/test/jdk/java/util/regex/RegExTest.java
+++ b/test/jdk/java/util/regex/RegExTest.java
@@ -34,11 +34,11 @@
  * 7067045 7014640 7189363 8007395 8013252 8013254 8012646 8023647 6559590
  * 8027645 8035076 8039124 8035975 8074678 6854417 8143854 8147531 7071819
  * 8151481 4867170 7080302 6728861 6995635 6736245 4916384 6328855 6192895
  * 6345469 6988218 6693451 7006761 8140212 8143282 8158482 8176029 8184706
  * 8194667 8197462 8184692 8221431 8224789 8228352 8230829 8236034 8235812
- * 8216332 8214245 8237599 8241055
+ * 8216332 8214245 8237599 8241055 8247546
  *
  * @library /test/lib
  * @library /lib/testlibrary/java/lang
  * @build jdk.test.lib.RandomFactory
  * @run main RegExTest
diff a/test/jdk/java/util/regex/SupplementaryTestCases.txt b/test/jdk/java/util/regex/SupplementaryTestCases.txt
--- a/test/jdk/java/util/regex/SupplementaryTestCases.txt
+++ b/test/jdk/java/util/regex/SupplementaryTestCases.txt
@@ -1,7 +1,7 @@
 //
-// Copyright (c) 1999, 2009, Oracle and/or its affiliates. All rights reserved.
+// Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 //
 // This code is free software; you can redistribute it and/or modify it
 // under the terms of the GNU General Public License version 2 only, as
 // published by the Free Software Foundation.
@@ -127,10 +127,35 @@
 ///
 ///[a-\uffff]
 ///\ud800\udc00
 ///false 0
 
+// unpaired surrogate should match
+[\x{d800}-\x{dbff}\x{dc00}-\x{dfff}]
+xxx\udca9\ud83dyyy
+true \udca9 0
+
+// surrogates in a supplementary character should not match
+[\x{d800}-\x{dbff}\x{dc00}-\x{dfff}]
+\ud83d\udca9
+false 0
+
+// unpaired surrogate should match
+[\p{InHIGH_SURROGATES}\p{InLOW_SURROGATES}]
+xxx\udca9\ud83dyyy
+true \udca9 0
+
+// surrogates part of a supplementary character should not match
+[\p{InHIGH_SURROGATES}\p{InLOW_SURROGATES}]
+\ud83d\udca9
+false 0
+
+// low surrogate part of a supplementary character should not match
+[\x{dc00}-\x{dfff}]
+\ud83d\udca9
+false 0
+
 // use of x modifier
 \ud800\udc61bc(?x)bl\ud800\udc61h
 \ud800\udc61bcbl\ud800\udc61h
 true \ud800\udc61bcbl\ud800\udc61h 0
 
diff a/test/jdk/javax/net/ssl/TLSv13/ClientHelloKeyShares.java b/test/jdk/javax/net/ssl/TLSv13/ClientHelloKeyShares.java
--- /dev/null
+++ b/test/jdk/javax/net/ssl/TLSv13/ClientHelloKeyShares.java
@@ -0,0 +1,276 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.  For further debugging output
+// set the -Djavax.net.debug=ssl:handshake property on the @run lines.
+
+/*
+ * @test
+ * @bug 8247630
+ * @summary Use two key share entries
+ * @run main/othervm ClientHelloKeyShares 29 23
+ * @run main/othervm -Djdk.tls.namedGroups=secp384r1,secp521r1,x448,ffdhe2048 ClientHelloKeyShares 24 30
+ * @run main/othervm -Djdk.tls.namedGroups=sect163k1,sect163r1,x25519 ClientHelloKeyShares 29
+ * @run main/othervm -Djdk.tls.namedGroups=sect163k1,sect163r1,secp256r1 ClientHelloKeyShares 23
+ * @run main/othervm -Djdk.tls.namedGroups=sect163k1,sect163r1,ffdhe2048,ffdhe3072,ffdhe4096 ClientHelloKeyShares 256
+ * @run main/othervm -Djdk.tls.namedGroups=sect163k1,ffdhe2048,x25519,secp256r1 ClientHelloKeyShares 256 29
+ * @run main/othervm -Djdk.tls.namedGroups=secp256r1,secp384r1,ffdhe2048,x25519 ClientHelloKeyShares 23 256
+ */
+
+import javax.net.ssl.*;
+import javax.net.ssl.SSLEngineResult.*;
+import java.nio.ByteBuffer;
+import java.util.*;
+
+
+public class ClientHelloKeyShares {
+
+    // Some TLS constants we'll use for testing
+    private static final int TLS_REC_HANDSHAKE = 22;
+    private static final int HELLO_EXT_SUPP_GROUPS = 10;
+    private static final int HELLO_EXT_SUPP_VERS = 43;
+    private static final int HELLO_EXT_KEY_SHARE = 51;
+    private static final int TLS_PROT_VER_13 = 0x0304;
+    private static final int NG_SECP256R1 = 0x0017;
+    private static final int NG_SECP384R1 = 0x0018;
+    private static final int NG_X25519 = 0x001D;
+    private static final int NG_X448 = 0x001E;
+
+    public static void main(String args[]) throws Exception {
+        // Arguments to this test are an abitrary number of integer
+        // values which will be the expected NamedGroup IDs in the key_share
+        // extension.  Expected named group assertions may also be affected
+        // by setting the jdk.tls.namedGroups System property.
+        List<Integer> expectedKeyShares = new ArrayList<>();
+        Arrays.stream(args).forEach(arg ->
+                expectedKeyShares.add(Integer.valueOf(arg)));
+
+        SSLContext sslCtx = SSLContext.getDefault();
+        SSLEngine engine = sslCtx.createSSLEngine();
+        engine.setUseClientMode(true);
+        SSLSession session = engine.getSession();
+        ByteBuffer clientOut = ByteBuffer.wrap("I'm a Client".getBytes());
+        ByteBuffer cTOs =
+                ByteBuffer.allocateDirect(session.getPacketBufferSize());
+
+        // Create and check the ClientHello message
+        SSLEngineResult clientResult = engine.wrap(clientOut, cTOs);
+        logResult("client wrap: ", clientResult);
+        if (clientResult.getStatus() != SSLEngineResult.Status.OK) {
+            throw new RuntimeException("Client wrap got status: " +
+                    clientResult.getStatus());
+        }
+
+        cTOs.flip();
+        System.out.println(dumpHexBytes(cTOs));
+        checkClientHello(cTOs, expectedKeyShares);
+    }
+
+    private static void logResult(String str, SSLEngineResult result) {
+        HandshakeStatus hsStatus = result.getHandshakeStatus();
+        System.out.println(str +
+            result.getStatus() + "/" + hsStatus + ", " +
+            result.bytesConsumed() + "/" + result.bytesProduced() +
+            " bytes");
+        if (hsStatus == HandshakeStatus.FINISHED) {
+            System.out.println("\t...ready for application data");
+        }
+    }
+
+    /**
+     * Dump a ByteBuffer as a hexdump to stdout.  The dumping routine will
+     * start at the current position of the buffer and run to its limit.
+     * After completing the dump, the position will be returned to its
+     * starting point.
+     *
+     * @param data the ByteBuffer to dump to stdout.
+     *
+     * @return the hexdump of the byte array.
+     */
+    private static String dumpHexBytes(ByteBuffer data) {
+        StringBuilder sb = new StringBuilder();
+        if (data != null) {
+            int i = 0;
+            data.mark();
+            while (data.hasRemaining()) {
+                if (i % 16 == 0 && i != 0) {
+                    sb.append("\n");
+                }
+                sb.append(String.format("%02X ", data.get()));
+                i++;
+            }
+            data.reset();
+        }
+
+        return sb.toString();
+    }
+
+    /**
+     * Tests the ClientHello for the presence of the key shares in the supplied
+     * List of key share identifiers.
+     *
+     * @param data the ByteBuffer containing the ClientHello bytes
+     * @param keyShareTypes a List containing the expected key shares
+     *
+     * @throws RuntimeException if there is a deviation between what is expected
+     * and what is supplied.  It will also throw this exception if other
+     * basic structural elements of the ClientHello are not found (e.g. TLS 1.3
+     * is not in the list of supported groups, etc.)
+     */
+    private static void checkClientHello(ByteBuffer data,
+            List<Integer> expectedKeyShares) {
+        Objects.requireNonNull(data);
+        data.mark();
+
+        // Process the TLS record header
+        int type = Byte.toUnsignedInt(data.get());
+        int ver_major = Byte.toUnsignedInt(data.get());
+        int ver_minor = Byte.toUnsignedInt(data.get());
+        int recLen = Short.toUnsignedInt(data.getShort());
+
+        // Simple sanity checks
+        if (type != 22) {
+            throw new RuntimeException("Not a handshake: Type = " + type);
+        } else if (recLen > data.remaining()) {
+            throw new RuntimeException("Incomplete record in buffer: " +
+                    "Record length = " + recLen + ", Remaining = " +
+                    data.remaining());
+        }
+
+        // Grab the handshake message header.
+        int msgHdr = data.getInt();
+        int msgType = (msgHdr >> 24) & 0x000000FF;
+        int msgLen = msgHdr & 0x00FFFFFF;
+
+        // More simple sanity checks
+        if (msgType != 1) {
+            throw new RuntimeException("Not a ClientHello: Type = " + msgType);
+        }
+
+        // Skip over the protocol version and client random
+        data.position(data.position() + 34);
+
+        // Jump past the session ID (if there is one)
+        int sessLen = Byte.toUnsignedInt(data.get());
+        if (sessLen != 0) {
+            data.position(data.position() + sessLen);
+        }
+
+        // Jump past the cipher suites
+        int csLen = Short.toUnsignedInt(data.getShort());
+        if (csLen != 0) {
+            data.position(data.position() + csLen);
+        }
+
+        // ...and the compression
+        int compLen = Byte.toUnsignedInt(data.get());
+        if (compLen != 0) {
+            data.position(data.position() + compLen);
+        }
+
+        // Now for the fun part.  Go through the extensions and look
+        // for supported_versions (to make sure TLS 1.3 is asserted) and
+        // the expected key shares are present.
+        boolean foundSupVer = false;
+        boolean foundKeyShare = false;
+        int extsLen = Short.toUnsignedInt(data.getShort());
+        List<Integer> supGrpList = new ArrayList<>();
+        List<Integer> chKeyShares = new ArrayList<>();
+        while (data.hasRemaining()) {
+            int extType = Short.toUnsignedInt(data.getShort());
+            int extLen = Short.toUnsignedInt(data.getShort());
+            boolean foundTLS13 = false;
+            switch (extType) {
+                case HELLO_EXT_SUPP_GROUPS:
+                    int supGrpLen = Short.toUnsignedInt(data.getShort());
+                    for (int remain = supGrpLen; remain > 0; remain -= 2) {
+                        supGrpList.add(Short.toUnsignedInt(data.getShort()));
+                    }
+                    break;
+                case HELLO_EXT_SUPP_VERS:
+                    foundSupVer = true;
+                    int supVerLen = Byte.toUnsignedInt(data.get());
+                    for (int remain = supVerLen; remain > 0; remain -= 2) {
+                        foundTLS13 |= (Short.toUnsignedInt(data.getShort()) ==
+                                TLS_PROT_VER_13);
+                    }
+
+                    if (!foundTLS13) {
+                        throw new RuntimeException("Missing TLS 1.3 Protocol " +
+                                "Version in supported_groups");
+                    }
+                    break;
+                case HELLO_EXT_KEY_SHARE:
+                    foundKeyShare = true;
+                    int ksListLen = Short.toUnsignedInt(data.getShort());
+                    while (ksListLen > 0) {
+                        chKeyShares.add(Short.toUnsignedInt(data.getShort()));
+                        int ksLen = Short.toUnsignedInt(data.getShort());
+                        data.position(data.position() + ksLen);
+                        ksListLen -= (4 + ksLen);
+                    }
+                    break;
+                default:
+                    data.position(data.position() + extLen);
+                    break;
+            }
+        }
+
+        // We must have parsed supported_versions, key_share and
+        // supported_groups extensions.
+        if ((foundSupVer && foundKeyShare && !supGrpList.isEmpty()) == false) {
+            throw new RuntimeException("Missing one or more of key_share, " +
+                    "supported_versions and/or supported_groups extensions");
+        }
+
+        // The key share types we expected in the test should match exactly what
+        // was asserted in the client hello
+        if (!expectedKeyShares.equals(chKeyShares)) {
+            StringBuilder sb = new StringBuilder(
+                    "Expected and Actual key_share lists differ: ");
+            sb.append("Expected: ");
+            expectedKeyShares.forEach(ng -> sb.append(ng).append(" "));
+            sb.append(", Actual: ");
+            chKeyShares.forEach(ng -> sb.append(ng).append(" "));
+            throw new RuntimeException(sb.toString());
+        }
+
+        // The order of the key shares should match the order of precedence
+        // of the same named groups asserted in the supported_groups extension.
+        // (RFC 8446, 4.2.8)
+        int prevChNg = -1;
+        for (int ng : chKeyShares) {
+            int chNgPos = supGrpList.indexOf(ng);
+            if (chNgPos <= prevChNg) {
+                throw new RuntimeException("Order of precedence violation " +
+                        "for NamedGroup " + ng + " between key_share and " +
+                        "supported_groups extensions");
+            }
+            prevChNg = chNgPos;
+        }
+
+        // We should be at the end of the ClientHello
+        data.reset();
+    }
+}
diff a/test/jdk/javax/net/ssl/TLSv13/HRRKeyShares.java b/test/jdk/javax/net/ssl/TLSv13/HRRKeyShares.java
--- /dev/null
+++ b/test/jdk/javax/net/ssl/TLSv13/HRRKeyShares.java
@@ -0,0 +1,435 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.  For further debugging output
+// set the -Djavax.net.debug=ssl:handshake property on the @run lines.
+
+/*
+ * @test
+ * @bug 8247630
+ * @summary Use two key share entries
+ * @library /test/lib
+ * @run main/othervm -Djdk.tls.namedGroups=x25519,secp256r1,secp384r1 HRRKeyShares
+ */
+
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import javax.net.ssl.*;
+import javax.net.ssl.SSLEngineResult.*;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import jdk.test.lib.Utils;
+
+
+public class HRRKeyShares {
+
+    // Some TLS constants we'll use for testing
+    private static final int TLS_REC_HANDSHAKE = 22;
+    private static final int TLS_REC_ALERT = 21;
+    private static final int HS_MSG_CLIHELLO = 1;
+    private static final int HS_MSG_SERVHELLO = 2;          // Also for HRR
+    private static final int HELLO_EXT_SUPP_GROUPS = 10;
+    private static final int HELLO_EXT_SUPP_VERS = 43;
+    private static final int HELLO_EXT_KEY_SHARE = 51;
+    private static final int TLS_LEGACY_VER = 0x0303;       // TLSv1.2
+    private static final int TLS_PROT_VER_13 = 0x0304;      // TLSv1.3
+    private static final int NG_SECP256R1 = 0x0017;
+    private static final int NG_SECP384R1 = 0x0018;
+    private static final int NG_X25519 = 0x001D;
+    private static final int NG_X448 = 0x001E;
+    private static final int NG_GC512A = 0x0026;
+    private static final int COMP_NONE = 0;
+    private static final int ALERT_TYPE_FATAL = 2;
+    private static final int ALERT_DESC_ILLEGAL_PARAM = 47;
+    private static final byte[] HRR_RANDOM = Utils.toByteArray(
+            "CF21AD74E59A6111BE1D8C021E65B891" +
+            "C2A211167ABB8C5E079E09E2C8A8339C");
+
+    static class ClientHello {
+        // TLS Record header fields
+        final int recType;
+        final int recVers;
+        final int recLength;
+
+        // Handshake header fields
+        final int hsMsgType;
+        final int hsMsgLength;
+
+        // ClientHello fields
+        final int version;
+        final byte[] random;
+        final byte[] sessId;
+        final List<Integer> cipherSuites = new ArrayList<>();
+        final List<Integer> compressionList = new ArrayList<>();
+        final Map<Integer,byte[]> extensionMap = new LinkedHashMap<>();
+
+        // These are fields built from specific extension data fields we
+        // are interested in for our tests
+        final List<Integer> suppGroups = new ArrayList<>();
+        final Map<Integer,byte[]> keyShares = new LinkedHashMap<>();
+        final List<Integer> suppVersions = new ArrayList<>();
+
+        ClientHello(ByteBuffer data) {
+            Objects.requireNonNull(data);
+            data.mark();
+
+            // Process the TLS record header
+            recType = Byte.toUnsignedInt(data.get());
+            recVers = Short.toUnsignedInt(data.getShort());
+            recLength = Short.toUnsignedInt(data.getShort());
+            if (recType != TLS_REC_HANDSHAKE) {
+                throw new RuntimeException("Not a Handshake TLS record. " +
+                        "Type = " + recType);
+            }
+
+            // Process the Handshake message header
+            int recHdr = data.getInt();
+            hsMsgType = recHdr >>> 24;
+            hsMsgLength = recHdr & 0x00FFFFFF;
+            if (hsMsgType != HS_MSG_CLIHELLO) {
+                throw new RuntimeException("Not a ClientHello message. " +
+                        "Type = " + hsMsgType);
+            } else if (hsMsgLength > data.remaining()) {
+                throw new RuntimeException("Incomplete record in buffer: " +
+                        "Record length = " + hsMsgLength + ", Remaining = " +
+                        data.remaining());
+            }
+
+            version = Short.toUnsignedInt(data.getShort());
+            random = new byte[32];
+            data.get(random);
+            sessId = new byte[Byte.toUnsignedInt(data.get())];
+            data.get(sessId);
+
+            int suiteLen = Short.toUnsignedInt(data.getShort());
+            while (suiteLen > 0) {
+                cipherSuites.add(Short.toUnsignedInt(data.getShort()));
+                suiteLen -= 2;
+            }
+
+            int compLen = Byte.toUnsignedInt(data.get());
+            while (compLen > 0) {
+                compressionList.add(Byte.toUnsignedInt(data.get()));
+                compLen--;
+            }
+
+            // Extension processing time!
+            int extListLen = Short.toUnsignedInt(data.getShort());
+            while (extListLen > 0) {
+                int extType = Short.toUnsignedInt(data.getShort());
+                int extLen = Short.toUnsignedInt(data.getShort());
+                byte[] extData = new byte[extLen];
+                data.get(extData);
+                extensionMap.put(extType, extData);
+                switch (extType) {
+                    case HELLO_EXT_SUPP_GROUPS:
+                        ByteBuffer sgBuf = ByteBuffer.wrap(extData);
+                        int supGrpLen = Short.toUnsignedInt(sgBuf.getShort());
+                        for (int remain = supGrpLen; remain > 0; remain -= 2) {
+                            suppGroups.add(Short.toUnsignedInt(
+                                    sgBuf.getShort()));
+                        }
+                        break;
+                    case HELLO_EXT_SUPP_VERS:
+                        ByteBuffer svBuf = ByteBuffer.wrap(extData);
+                        int supVerLen = Byte.toUnsignedInt(svBuf.get());
+                        for (int remain = supVerLen; remain > 0; remain -= 2) {
+                            suppVersions.add(Short.toUnsignedInt(
+                                    svBuf.getShort()));
+                        }
+                        break;
+                    case HELLO_EXT_KEY_SHARE:
+                        ByteBuffer ksBuf = ByteBuffer.wrap(extData);
+                        int ksListLen = Short.toUnsignedInt(ksBuf.getShort());
+                        while (ksListLen > 0) {
+                            int namedGroup = Short.toUnsignedInt(
+                                    ksBuf.getShort());
+                            int ksLen = Short.toUnsignedInt(ksBuf.getShort());
+                            byte[] ksData = new byte[ksLen];
+                            ksBuf.get(ksData);
+                            keyShares.put(namedGroup, ksData);
+                            ksListLen -= (4 + ksLen);
+                        }
+                        break;
+                }
+                extListLen -= (4 + extLen);
+            }
+        }
+    }
+
+    static class Alert {
+        final int recType;
+        final int recVers;
+        final int recLength;
+        final int alertType;
+        final int alertDesc;
+
+        Alert(ByteBuffer data) {
+            Objects.requireNonNull(data);
+            data.mark();
+
+            // Process the TLS record header
+            recType = Byte.toUnsignedInt(data.get());
+            recVers = Short.toUnsignedInt(data.getShort());
+            recLength = Short.toUnsignedInt(data.getShort());
+            if (recType != TLS_REC_ALERT) {
+                throw new RuntimeException("Not a Handshake TLS record. " +
+                        "Type = " + recType);
+            }
+
+            alertType = Byte.toUnsignedInt(data.get());
+            alertDesc = Byte.toUnsignedInt(data.get());
+        }
+    }
+
+    public static void main(String args[]) throws Exception {
+        System.out.println("Test 1: Good HRR exchange using secp384r1");
+        hrrKeyShareTest(NG_SECP384R1, true);
+        System.out.println();
+
+        System.out.println("Test 2: Bad HRR exchange using secp256r1");
+        hrrKeyShareTest(NG_SECP256R1, false);
+        System.out.println();
+
+        System.out.println("Test 3: Bad HRR using unknown GC512A");
+        hrrKeyShareTest(NG_GC512A, false);
+        System.out.println();
+
+        System.out.println("Test 4: Bad HRR using known / unasserted x448");
+        hrrKeyShareTest(NG_X448, false);
+        System.out.println();
+    }
+
+    private static void logResult(String str, SSLEngineResult result) {
+        HandshakeStatus hsStatus = result.getHandshakeStatus();
+        System.out.println(str +
+            result.getStatus() + "/" + hsStatus + ", " +
+            result.bytesConsumed() + "/" + result.bytesProduced() +
+            " bytes");
+        if (hsStatus == HandshakeStatus.FINISHED) {
+            System.out.println("\t...ready for application data");
+        }
+    }
+
+    /*
+     * If the result indicates that we have outstanding tasks to do,
+     * go ahead and run them in this thread.
+     */
+    private static void runDelegatedTasks(SSLEngine engine) throws Exception {
+        if (engine.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {
+            Runnable runnable;
+            while ((runnable = engine.getDelegatedTask()) != null) {
+                System.out.println("    running delegated task...");
+                runnable.run();
+            }
+            HandshakeStatus hsStatus = engine.getHandshakeStatus();
+            if (hsStatus == HandshakeStatus.NEED_TASK) {
+                throw new Exception(
+                    "handshake shouldn't need additional tasks");
+            }
+        }
+    }
+
+    /**
+     * Dump a ByteBuffer as a hexdump to stdout.  The dumping routine will
+     * start at the current position of the buffer and run to its limit.
+     * After completing the dump, the position will be returned to its
+     * starting point.
+     *
+     * @param data the ByteBuffer to dump to stdout.
+     *
+     * @return the hexdump of the byte array.
+     */
+    private static String dumpHexBytes(ByteBuffer data) {
+        StringBuilder sb = new StringBuilder();
+        if (data != null) {
+            int i = 0;
+            data.mark();
+            while (data.hasRemaining()) {
+                if (i % 16 == 0 && i != 0) {
+                    sb.append("\n");
+                }
+                sb.append(String.format("%02X ", data.get()));
+                i++;
+            }
+            data.reset();
+        }
+
+        return sb.toString();
+    }
+
+    private static void hrrKeyShareTest(int hrrNamedGroup, boolean expectedPass)
+            throws Exception {
+        SSLContext sslCtx = SSLContext.getDefault();
+        SSLEngine engine = sslCtx.createSSLEngine();
+        engine.setUseClientMode(true);
+        SSLSession session = engine.getSession();
+        ByteBuffer clientOut =
+                ByteBuffer.wrap("I'm a Client".getBytes());
+        ByteBuffer cTOs = ByteBuffer.allocateDirect(
+                session.getPacketBufferSize());
+
+        // Create and check the ClientHello message
+        SSLEngineResult clientResult = engine.wrap(clientOut, cTOs);
+        logResult("client wrap: ", clientResult);
+        if (clientResult.getStatus() != SSLEngineResult.Status.OK) {
+            throw new RuntimeException("Client wrap got status: " +
+                    clientResult.getStatus());
+        }
+
+        cTOs.flip();
+        System.out.println("----- ORIGINAL CLIENT HELLO -----\n" +
+                dumpHexBytes(cTOs));
+        ClientHello initialCh = new ClientHello(cTOs);
+
+        if (!initialCh.suppVersions.contains(TLS_PROT_VER_13)) {
+            throw new RuntimeException(
+                    "Missing TLSv1.3 protocol in supported_versions");
+        } else if (!initialCh.keyShares.containsKey(NG_X25519) ||
+                !initialCh.keyShares.containsKey(NG_SECP256R1)) {
+            throw new RuntimeException(
+                    "Missing one or more expected KeyShares");
+        }
+
+        // Craft the HRR message with the passed-in named group as the
+        // key share named group to request.
+        ByteBuffer sTOc = buildHRRMessage(initialCh, hrrNamedGroup);
+        System.out.println("----- SERVER HELLO RETRY REQUEST -----\n" +
+                dumpHexBytes(sTOc));
+
+        // Unwrap the HRR and process it
+        clientResult = engine.unwrap(sTOc, clientOut);
+        logResult("client unwrap: ", clientResult);
+        if (clientResult.getStatus() != SSLEngineResult.Status.OK) {
+            throw new RuntimeException("Client wrap got status: " +
+                    clientResult.getStatus());
+        }
+        runDelegatedTasks(engine);
+
+        try {
+            // Now we're expecting to reissue the ClientHello, this time
+            // with a secp384r1 share.
+            cTOs.compact();
+            clientResult = engine.wrap(clientOut, cTOs);
+            logResult("client wrap: ", clientResult);
+            if (clientResult.getStatus() != SSLEngineResult.Status.OK) {
+                throw new RuntimeException("Client wrap got status: " +
+                        clientResult.getStatus());
+            }
+        } catch (RuntimeException | SSLException ssle) {
+            if (expectedPass) {
+                System.out.println("Caught unexpected exception");
+                throw ssle;
+            } else {
+                System.out.println("Caught expected exception: " + ssle);
+
+                // Try issuing another wrap call and see if we can get
+                // the Alert out.
+                clientResult = engine.wrap(clientOut, cTOs);
+                logResult("client wrap: ", clientResult);
+                if (clientResult.getStatus() != SSLEngineResult.Status.CLOSED) {
+                    throw new RuntimeException("Client wrap got status: " +
+                            clientResult.getStatus());
+                }
+
+                cTOs.flip();
+                System.out.println("----- ALERT -----\n" + dumpHexBytes(cTOs));
+                Alert alert = new Alert(cTOs);
+                if (alert.alertType != ALERT_TYPE_FATAL ||
+                        alert.alertDesc != ALERT_DESC_ILLEGAL_PARAM) {
+                    throw new RuntimeException("Unexpected alert.  " +
+                            "received " + alert.alertType + " / " +
+                            alert.alertDesc);
+                }
+                return;
+            }
+        }
+
+        cTOs.flip();
+        System.out.println("----- REISSUED CLIENT HELLO -----\n" +
+                dumpHexBytes(cTOs));
+        ClientHello reissuedCh = new ClientHello(cTOs);
+
+        if (!reissuedCh.keyShares.containsKey(hrrNamedGroup)) {
+            throw new RuntimeException("Missing secp384r1 key share");
+        }
+    }
+
+    private static ByteBuffer buildHRRMessage(ClientHello cliHello,
+            int namedGroup) throws IOException {
+        // Create a ByteBuffer that will be large enough to handle
+        // the HelloRetryRequest
+        ByteBuffer hrrBuf = ByteBuffer.allocate(2048);  // More than enough!
+
+        // Advance past the TLS record and handshake message headers.  We will
+        // go back later and scribble in the proper lengths.  The record header
+        // is 5 bytes long, the handshake header is 4.
+        hrrBuf.position(9);
+        hrrBuf.putShort((short)TLS_LEGACY_VER);
+        hrrBuf.put(HRR_RANDOM);
+        hrrBuf.put((byte)cliHello.sessId.length);
+        hrrBuf.put(cliHello.sessId);
+        hrrBuf.putShort(cliHello.cipherSuites.get(0).shortValue());
+        hrrBuf.put((byte)COMP_NONE);
+
+        // Use a separate stream for creating the extension section
+        ByteArrayOutputStream extBaos = new ByteArrayOutputStream();
+        DataOutputStream extStream = new DataOutputStream(extBaos);
+
+        // Supported version
+        extStream.writeShort(HELLO_EXT_SUPP_VERS);
+        extStream.writeShort(2);
+        extStream.writeShort(TLS_PROT_VER_13);
+
+        // Key share
+        extStream.writeShort(HELLO_EXT_KEY_SHARE);
+        extStream.writeShort(2);
+        extStream.writeShort(namedGroup);
+
+        // Now add in the extensions into the main message
+        hrrBuf.putShort((short)extStream.size());
+        hrrBuf.put(extBaos.toByteArray());
+
+        // At this point we can go back and write in the TLS record and
+        // handshake message headers.
+        hrrBuf.flip();
+
+        // Write in the TLS record header
+        hrrBuf.put((byte)TLS_REC_HANDSHAKE);
+        hrrBuf.putShort((short)TLS_LEGACY_VER);
+        hrrBuf.putShort((short)(hrrBuf.limit() - 5));
+
+        // Write the Handshake message header
+        hrrBuf.putInt((HS_MSG_SERVHELLO << 24) |
+                ((hrrBuf.limit() - 9) & 0x00FFFFFF));
+
+        hrrBuf.rewind();
+        return hrrBuf;
+    }
+}
diff a/test/jdk/javax/swing/JTabbedPane/JTabbedPaneSerialization.java b/test/jdk/javax/swing/JTabbedPane/JTabbedPaneSerialization.java
--- /dev/null
+++ b/test/jdk/javax/swing/JTabbedPane/JTabbedPaneSerialization.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8245785
+ * @summary  Verifies if javax.swing.JTabbedPane can be deserialized
+ * @run main JTabbedPaneSerialization
+ */
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.IOException;
+import javax.swing.JTabbedPane;
+import javax.swing.JLabel;
+
+public class JTabbedPaneSerialization {
+
+    public static void main(final String[] args) throws Exception {
+
+        JTabbedPane tabbedPane = new JTabbedPane();
+        tabbedPane.addTab("Tab1", new JLabel("Label1"));
+        tabbedPane.addTab("Tab2", new JLabel("Label2"));
+        tabbedPane.addTab("Tab3", new JLabel("Label3"));
+
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        ObjectOutputStream out = new ObjectOutputStream(baos);
+
+        out.writeObject(tabbedPane);
+        out.close();
+
+        byte[] bytes = baos.toByteArray();
+        ByteArrayInputStream is = new ByteArrayInputStream(bytes);
+        ObjectInputStream oin = new ObjectInputStream(is);
+
+        final JTabbedPane readPane = (JTabbedPane) oin.readObject();
+        System.out.println("readPane: " + readPane.toString());
+        oin.close();
+        if (tabbedPane.getTabCount() != readPane.getTabCount()) {
+            System.out.println("tabbedPane.tabCount " +
+                                          tabbedPane.getTabCount());
+            System.out.println("readPane.tabCount " +
+                                            readPane.getTabCount());
+            throw new
+               RuntimeException("Number of pages/tab of JTabbedPane is not deserialized");
+        }
+    }
+}
diff a/test/jdk/javax/swing/JTree/8041705/DefaultTreeCellRendererBorderTest.java b/test/jdk/javax/swing/JTree/8041705/DefaultTreeCellRendererBorderTest.java
--- /dev/null
+++ b/test/jdk/javax/swing/JTree/8041705/DefaultTreeCellRendererBorderTest.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 8041705
+ * @summary  Bugs in DefaultTreeCellRenderer.updateUI()
+ * @key headful
+ * @run main DefaultTreeCellRendererBorderTest
+ */
+
+import java.awt.BorderLayout;
+import java.awt.Insets;
+import java.awt.Robot;
+import javax.swing.JFrame;
+import javax.swing.JTree;
+import javax.swing.SwingUtilities;
+import javax.swing.UIManager;
+import javax.swing.WindowConstants;
+import javax.swing.tree.DefaultTreeCellRenderer;
+
+public class DefaultTreeCellRendererBorderTest {
+    private static JFrame frame;
+    private static JTree tree;
+    private static DefaultTreeCellRenderer treeCellRenderer;
+    private static Robot robot;
+    private static Insets margin1;
+    private static Insets margin2;
+
+    public static void main(String[] args) throws Exception {
+        try{
+            robot = new Robot();
+            robot.setAutoDelay(50);
+            SwingUtilities.invokeAndWait(()-> {
+                frame = new JFrame();
+                tree = new JTree();
+                treeCellRenderer = new DefaultTreeCellRenderer();
+                tree.add(treeCellRenderer);
+                frame.setDefaultCloseOperation(
+                        WindowConstants.DISPOSE_ON_CLOSE);
+                frame.setSize(300,300);
+                frame.setVisible(true);
+                frame.setLayout(new BorderLayout());
+                tree.setRootVisible(true);
+                tree.setShowsRootHandles(true);
+                frame.add(tree, BorderLayout.CENTER);
+            });
+            robot.waitForIdle();
+
+            UIManager.setLookAndFeel(
+                    "javax.swing.plaf.nimbus.NimbusLookAndFeel");
+            UIManager.put("Tree.rendererMargins", new Insets(2, 2, 2, 2));
+            SwingUtilities.invokeAndWait(() -> {
+                SwingUtilities.updateComponentTreeUI(frame);
+                margin1 = treeCellRenderer.getInsets();
+            });
+            robot.waitForIdle();
+
+            UIManager.put("Tree.rendererMargins", null);
+            UIManager.setLookAndFeel(
+                    "javax.swing.plaf.metal.MetalLookAndFeel");
+            SwingUtilities.invokeAndWait(()->{
+                SwingUtilities.updateComponentTreeUI(frame);
+                margin2 = treeCellRenderer.getInsets();
+            });
+            robot.waitForIdle();
+
+            if(margin1.equals(margin2)) {
+                throw new RuntimeException("Test Failed : NimbusLookAndFeel "+
+                        "Border persists for MetalLookAndFeel");
+            }
+        } finally {
+            if(frame != null) {
+                SwingUtilities.invokeAndWait(frame::dispose);
+            }
+        }
+    }
+}
diff a/test/jdk/javax/swing/plaf/nimbus/DerivedColorHueTest.java b/test/jdk/javax/swing/plaf/nimbus/DerivedColorHueTest.java
--- /dev/null
+++ b/test/jdk/javax/swing/plaf/nimbus/DerivedColorHueTest.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+/*
+ * @test
+ * @bug 8042055
+ * @summary  Verifies Nimbus DerivedColor clamps hue correctly
+ * @run main DerivedColorHueTest
+ */
+
+import java.awt.Color;
+import javax.swing.UIManager;
+import javax.swing.plaf.nimbus.NimbusLookAndFeel;
+
+/**
+ * Explanation: We get a color from the Nimbus L&F and hue-shift it in two
+ * different ways:
+ * 1. Using the Nimbus getDerivedColor method.
+ * 2. Manually using AWT's Color.RGBtoHSB / HSBtoRGB.
+ * Since the hue spectrum is cyclic, a hue less than 0 or larger than 1 should
+ * wrap around to stay within this range. This is what Color.HSBtoRGB does.
+ * The bug is that the Nimbus getDerivedColor method clamps the value, so that
+ * large hue shifts cause any hue to become 0 (red) or 1 (also red).
+ */
+public class DerivedColorHueTest {
+    public static void main(String[] args) throws Exception {
+        UIManager.setLookAndFeel("javax.swing.plaf.nimbus.NimbusLookAndFeel");
+
+        Color base = UIManager.getColor("nimbusBlueGrey");
+        float[] hsbBase = hsb(base);
+        float hueShift = 0.5f - 10; // magnitude bigger than 1 to ensure it cycles
+
+        Color derived = ((NimbusLookAndFeel)UIManager.getLookAndFeel())
+                         .getDerivedColor("nimbusBlueGrey", hueShift, 0, 0, 0, false);
+        Color derivedCorrect = new Color(
+                   Color.HSBtoRGB(hsbBase[0] + hueShift, hsbBase[1], hsbBase[2]));
+
+        float hueDerived = hsb(derived)[0];
+        float hueCorrect = hsb(derivedCorrect)[0];
+
+        if (hueCorrect < 0.01f || hueCorrect > 0.99f)
+            throw new RuntimeException("Test indeterminate! (Hue too close to red)");
+
+        System.out.println(" base: " + hsbString(base));
+        System.out.println(" derived: " + hsbString(derived));
+        System.out.println("derivedCorrect: " + hsbString(derivedCorrect));
+
+        if (Math.abs(hueDerived - hueCorrect) < 0.001f) {
+            System.out.println("[PASS]");
+        } else {
+            throw new RuntimeException("Nimbus derived hue color is not correct");
+        }
+    }
+
+    private static float[] hsb(Color c) {
+        return Color.RGBtoHSB(c.getRed(), c.getGreen(), c.getBlue(), null);
+    }
+
+    private static String hsbString(Color c) {
+        float[] hsb = hsb(c);
+        return String.format("H=%.2f, S=%.2f, B=%.2f", hsb[0], hsb[1], hsb[2]);
+    }
+}
diff a/test/jdk/javax/swing/text/Utilities/8142966/SwingFontMetricsTest.java b/test/jdk/javax/swing/text/Utilities/8142966/SwingFontMetricsTest.java
--- a/test/jdk/javax/swing/text/Utilities/8142966/SwingFontMetricsTest.java
+++ b/test/jdk/javax/swing/text/Utilities/8142966/SwingFontMetricsTest.java
@@ -20,32 +20,44 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 import java.awt.Font;
 import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.RenderingHints;
+import static java.awt.RenderingHints.*;
+import java.awt.Toolkit;
+import java.util.Map;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import javax.swing.JFrame;
 import javax.swing.JLabel;
 import javax.swing.SwingUtilities;
 
 /**
  * @test
  * @key headful
- * @bug 8142966
+ * @bug 8142966 8199529
  * @summary Wrong cursor position in text components on HiDPI display
  * @run main/othervm -Dsun.java2d.uiScale=2 SwingFontMetricsTest
  */
 public class SwingFontMetricsTest {
 
     private static final String LOWER_CASE_TEXT = "the quick brown fox jumps over the lazy dog";
     private static final String UPPER_CASE_TEXT = LOWER_CASE_TEXT.toUpperCase();
     private static final String TEXT = LOWER_CASE_TEXT + UPPER_CASE_TEXT;
     private static boolean passed = false;
     private static CountDownLatch latch = new CountDownLatch(1);
+    private static Object aaHint = null;
 
     public static void main(String[] args) throws Exception {
+        Map map = (Map)Toolkit.getDefaultToolkit().getDesktopProperty("awt.font.desktophints");
+        aaHint = map.get(RenderingHints.KEY_TEXT_ANTIALIASING);
+        if (aaHint == null) {
+            aaHint = VALUE_TEXT_ANTIALIAS_DEFAULT;
+        }
+
         SwingUtilities.invokeAndWait(SwingFontMetricsTest::createAndShowGUI);
         latch.await(5, TimeUnit.SECONDS);
 
         if (!passed) {
             throw new RuntimeException("Test Failed!");
@@ -59,11 +71,14 @@
         JLabel label = new JLabel(TEXT) {
             @Override
             public void paint(Graphics g) {
                 super.paint(g);
                 Font font = getFont();
+                Graphics2D g2d = (Graphics2D)g;
                 int width1 = getFontMetrics(font).stringWidth(TEXT);
+                // Set the same AA hint that the built-in Swing L&Fs set.
+                g2d.setRenderingHint(KEY_TEXT_ANTIALIASING, aaHint);
                 int width2 = g.getFontMetrics(font).stringWidth(TEXT);
                 passed = (width1 == width2);
                 latch.countDown();
                 frame.dispose();
             }
diff a/test/jdk/jdk/internal/platform/docker/CheckUseContainerSupport.java b/test/jdk/jdk/internal/platform/docker/CheckUseContainerSupport.java
--- /dev/null
+++ b/test/jdk/jdk/internal/platform/docker/CheckUseContainerSupport.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2020, Red Hat, Inc.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import jdk.internal.platform.Metrics;
+
+public class CheckUseContainerSupport {
+
+    // Usage: boolean value of -XX:+/-UseContainerSupport
+    //        passed as the only argument
+    public static void main(String[] args) throws Exception {
+        if (args.length != 1) {
+            throw new RuntimeException("Expected only one boolean argument");
+        }
+        boolean expectedContainerSupport = Boolean.parseBoolean(args[0]);
+        boolean actualContainerSupport = (Metrics.systemMetrics() != null);
+        if (expectedContainerSupport != actualContainerSupport) {
+            String msg = "-XX:" + ( expectedContainerSupport ? "+" : "-") + "UseContainerSupport, but got " +
+                         "Metrics.systemMetrics() == " + (Metrics.systemMetrics() == null ? "null" : "non-null");
+            System.out.println(msg);
+            System.out.println("TEST FAILED!!!");
+            return;
+        }
+        System.out.println("TEST PASSED!!!");
+    }
+
+}
diff a/test/jdk/jdk/internal/platform/docker/TestUseContainerSupport.java b/test/jdk/jdk/internal/platform/docker/TestUseContainerSupport.java
--- /dev/null
+++ b/test/jdk/jdk/internal/platform/docker/TestUseContainerSupport.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2020, Red Hat, Inc.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @summary UseContainerSupport flag should reflect Metrics being available
+ * @requires docker.support
+ * @library /test/lib
+ * @modules java.base/jdk.internal.platform
+ * @build CheckUseContainerSupport
+ * @run main/timeout=360 TestUseContainerSupport
+ */
+
+import jdk.test.lib.Utils;
+import jdk.test.lib.containers.docker.Common;
+import jdk.test.lib.containers.docker.DockerRunOptions;
+import jdk.test.lib.containers.docker.DockerTestUtils;
+
+public class TestUseContainerSupport {
+    private static final String imageName = Common.imageName("useContainerSupport");
+
+    public static void main(String[] args) throws Exception {
+        if (!DockerTestUtils.canTestDocker()) {
+            return;
+        }
+
+        DockerTestUtils.buildJdkDockerImage(imageName, "Dockerfile-BasicTest", "jdk-docker");
+
+        try {
+            testUseContainerSupport(true);
+            testUseContainerSupport(false);
+        } finally {
+            DockerTestUtils.removeDockerImage(imageName);
+        }
+    }
+
+    private static void testUseContainerSupport(boolean useContainerSupport) throws Exception {
+        String testMsg = " with -XX:" + (useContainerSupport ? "+" : "-") + "UseContainerSupport";
+        Common.logNewTestCase("Test TestUseContainerSupport" + testMsg);
+        DockerRunOptions opts =
+                new DockerRunOptions(imageName, "/jdk/bin/java", "CheckUseContainerSupport");
+        opts.addClassOptions(Boolean.valueOf(useContainerSupport).toString());
+        opts.addDockerOpts("--memory", "200m")
+            .addDockerOpts("--volume", Utils.TEST_CLASSES + ":/test-classes/");
+        if (useContainerSupport) {
+            opts.addJavaOpts("-XX:+UseContainerSupport");
+        } else {
+            opts.addJavaOpts("-XX:-UseContainerSupport");
+        }
+        opts.addJavaOpts("-cp", "/test-classes/");
+        opts.addJavaOpts("--add-exports", "java.base/jdk.internal.platform=ALL-UNNAMED");
+        DockerTestUtils.dockerRunJava(opts).shouldHaveExitValue(0).shouldContain("TEST PASSED!!!");
+    }
+}
diff a/test/jdk/security/infra/java/security/cert/CertPathValidator/certification/EntrustCA.java b/test/jdk/security/infra/java/security/cert/CertPathValidator/certification/EntrustCA.java
--- a/test/jdk/security/infra/java/security/cert/CertPathValidator/certification/EntrustCA.java
+++ b/test/jdk/security/infra/java/security/cert/CertPathValidator/certification/EntrustCA.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -21,26 +21,50 @@
  * questions.
  */
 
 /*
  * @test
- * @bug 8195774
- * @summary Interoperability tests with Entrust EC CA
+ * @bug 8195774 8243321
+ * @summary Interoperability tests with Entrust CAs
  * @build ValidatePathWithParams
  * @run main/othervm -Djava.security.debug=certpath EntrustCA OCSP
  * @run main/othervm -Djava.security.debug=certpath EntrustCA CRL
  */
 
 /*
- * Obtain test artifacts for Entrust EC CA from:
- *
- * Valid https://validec.entrust.net
+ * Obtain test artifacts for Entrust CA from:
  *
+ * EC CA:
+ * Valid: https://validec.entrust.net
  * Revoked https://revokedec.entrust.net
+ *
+ * G4 CA:
+ * Valid: https://validg4.entrust.net
+ * Revoked: https://revokedg4.entrust.net
  */
 public class EntrustCA {
 
+    public static void main(String[] args) throws Exception {
+
+        ValidatePathWithParams pathValidator = new ValidatePathWithParams(null);
+        boolean ocspEnabled = false;
+
+        if (args.length >= 1 && "CRL".equalsIgnoreCase(args[0])) {
+            pathValidator.enableCRLCheck();
+        } else {
+            // OCSP check by default
+            pathValidator.enableOCSPCheck();
+            ocspEnabled = true;
+        }
+
+        new Entrust_ECCA().runTest(pathValidator, ocspEnabled);
+        new Entrust_G4().runTest(pathValidator, ocspEnabled);
+    }
+}
+
+class Entrust_ECCA {
+
     // Owner: CN=Entrust Certification Authority - L1J, OU="(c) 2016 Entrust, Inc. - for authorized use only",
     // OU=See www.entrust.net/legal-terms, O="Entrust, Inc.", C=US
     // Issuer: CN=Entrust Root Certification Authority - EC1, OU="(c) 2012 Entrust, Inc. - for authorized use only",
     // OU=See www.entrust.net/legal-terms, O="Entrust, Inc.", C=US
     private static final String INT = "-----BEGIN CERTIFICATE-----\n" +
@@ -143,27 +167,153 @@
             "ZnBQOLK0rlLUMAkGA1UdEwQCMAAwCgYIKoZIzj0EAwIDaQAwZgIxANzqGRI0en5P\n" +
             "gSUDcdwoQSNKrBPBfGz2AQVLHAXsxvIlGhKZAQtM49zxA8AdFy/agwIxAMEjJH6A\n" +
             "4UbcGZc40eYu6wUbAxiUDD3gwSElNQ8Z6IhNLPCCdMM6KZORyaagAcXn4A==\n" +
             "-----END CERTIFICATE-----";
 
-    public static void main(String[] args) throws Exception {
+    public void runTest(ValidatePathWithParams pathValidator, boolean ocspEnabled) throws Exception {
+        // Validate valid
+        pathValidator.validate(new String[]{VALID, INT},
+                ValidatePathWithParams.Status.GOOD, null, System.out);
 
-        ValidatePathWithParams pathValidator = new ValidatePathWithParams(null);
+        // Validate Revoked
+        pathValidator.validate(new String[]{REVOKED, INT},
+                ValidatePathWithParams.Status.REVOKED,
+                "Wed May 24 10:39:28 PDT 2017", System.out);
+    }
+}
 
-        if (args.length >= 1 && "CRL".equalsIgnoreCase(args[0])) {
-            pathValidator.enableCRLCheck();
-        } else {
-            // OCSP check by default
-            pathValidator.enableOCSPCheck();
-        }
+class Entrust_G4 {
+
+    // Owner: CN=Entrust Certification Authority - L1N, OU="(c) 2014 Entrust, Inc. - for authorized use only",
+    // OU=See www.entrust.net/legal-terms, O="Entrust, Inc.", C=US
+    // Issuer: CN=Entrust Root Certification Authority - G4, OU="(c) 2015 Entrust, Inc. - for authorized use only",
+    // OU=See www.entrust.net/legal-terms, O="Entrust, Inc.", C=US
+    private static final String INT = "-----BEGIN CERTIFICATE-----\n" +
+            "MIIGMjCCBBqgAwIBAgIRAKvsd/8bQQwHAAAAAFVl2AUwDQYJKoZIhvcNAQELBQAw\n" +
+            "gb4xCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMSgwJgYDVQQL\n" +
+            "Ex9TZWUgd3d3LmVudHJ1c3QubmV0L2xlZ2FsLXRlcm1zMTkwNwYDVQQLEzAoYykg\n" +
+            "MjAxNSBFbnRydXN0LCBJbmMuIC0gZm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxMjAw\n" +
+            "BgNVBAMTKUVudHJ1c3QgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEc0\n" +
+            "MB4XDTE3MTEyMjIwMDQyMFoXDTMwMTIyMjIwMzQyMFowgboxCzAJBgNVBAYTAlVT\n" +
+            "MRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMSgwJgYDVQQLEx9TZWUgd3d3LmVudHJ1\n" +
+            "c3QubmV0L2xlZ2FsLXRlcm1zMTkwNwYDVQQLEzAoYykgMjAxNCBFbnRydXN0LCBJ\n" +
+            "bmMuIC0gZm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxLjAsBgNVBAMTJUVudHJ1c3Qg\n" +
+            "Q2VydGlmaWNhdGlvbiBBdXRob3JpdHkgLSBMMU4wggEiMA0GCSqGSIb3DQEBAQUA\n" +
+            "A4IBDwAwggEKAoIBAQDcSG+caYQ4xcvf+dt8bgCEHorO0g5j0H1NOtQzRXgUoG8y\n" +
+            "QuRbJX9swyKqQZbsc18YvTV8OKA/uSNE46Jvq47TFPojWWTVLbNDqpM07e4EFYKs\n" +
+            "A9NFzAUngijnf3ivnXA6iNPAMXaEhXmhY/YFjk8NoM7Y1PFsA0oj5hamKQ06iO/j\n" +
+            "gvBScLmnQ1ju9Qj9IGIg18UL5AJNw0frspLUQBYVrLGaqAy5Nl2BUJKaZ4vnSLvP\n" +
+            "nk6YrB15mo1phHae10Ba4fx7R3z8IZ/hby4OXTy/KZpu107VEQPAwTuDK8ZXxB5y\n" +
+            "0DSzi4vaw27aLrUsq4aFqUo03gEfC31vWW76TNkFAgMBAAGjggErMIIBJzAOBgNV\n" +
+            "HQ8BAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHSUEFjAUBggrBgEF\n" +
+            "BQcDAQYIKwYBBQUHAwIwOwYDVR0gBDQwMjAwBgRVHSAAMCgwJgYIKwYBBQUHAgEW\n" +
+            "Gmh0dHA6Ly93d3cuZW50cnVzdC5uZXQvcnBhMDMGCCsGAQUFBwEBBCcwJTAjBggr\n" +
+            "BgEFBQcwAYYXaHR0cDovL29jc3AuZW50cnVzdC5uZXQwMAYDVR0fBCkwJzAloCOg\n" +
+            "IYYfaHR0cDovL2NybC5lbnRydXN0Lm5ldC9nNGNhLmNybDAdBgNVHQ4EFgQU7kfR\n" +
+            "hXHx/S23P7s+Y1h3F0lADpUwHwYDVR0jBBgwFoAUnzjEViPDOeigcWzoVEzk6Dqx\n" +
+            "v2cwDQYJKoZIhvcNAQELBQADggIBACMeFFgsWmC7h6D1v8DJUkOpm/m5UhVhO0hb\n" +
+            "pQMQKMhKkl744Y9SWG4WNmpQy743TTciEJPZFhc7ke2R6VmK8ZJUqro2awOw1RWZ\n" +
+            "OtHla59Btf1NQd41vOVdU+qFhs8lFfXg9sK7YHTrfxHtMXLoGnkkamK3xJgn7sXa\n" +
+            "/zUvUDBTpDCXcpO9SyHoKIQswmkIPpRyIdPF4biRdR3N+9MYmlfqN/Nk3OEZ73xZ\n" +
+            "AUZP6Gu+f9cEiHTA8NdYHCPLJWyFnIHWK+QuTFEnKYnOYxCeroLBNOO64e8JWZ39\n" +
+            "kZ22BBXhHzqOCCczS7JOJTRF+JgvWuxbFwRstj8qf3fE+JndWmq2FC4hTHtpuK5K\n" +
+            "ENuiRm5gdkXfsXmB+qB6y5gaajiTIMscGIcZIKTe2YdKrLoicvEz8k+loM7favik\n" +
+            "vzFioTNTDHYGx3mkfElBE7ycY8n+jZE3QBBv33k28MeQi7XNgEaMc4tYwoZIdE9A\n" +
+            "xVccXTzEQzka82dOkRB1dU0XZId9XAWv+CtNc2TjF6Wgx2seA/c6H8S0IfgQBIV2\n" +
+            "8iN2wZns2QFdawkdy3hMUqPnA++kuGhLW3GemsIY5dP/WxY8rd+OfLb/Ks9T1pCd\n" +
+            "28t7PQRcQsgkYmouzrOW9ASBvYqLLdhl4y+fFXff8RkPIKMNoYP06WJvRKmky9R/\n" +
+            "41/nXRas\n" +
+            "-----END CERTIFICATE-----";
+
+    // Owner: CN=validg4.entrust.net, SERIALNUMBER=1913605, OID.2.5.4.15=Private Organization,
+    // O=Entrust Datacard Limited, OID.1.3.6.1.4.1.311.60.2.1.2=Ontario, OID.1.3.6.1.4.1.311.60.2.1.3=CA,
+    // L=Ottawa, ST=Ontario, C=CA
+    // Issuer: CN=Entrust Certification Authority - L1N, OU="(c) 2014 Entrust, Inc. - for authorized use only",
+    // OU=See www.entrust.net/legal-terms, O="Entrust, Inc.", C=US
+    // Serial number: 83790beb78eeb966007ad3dbf11d570
+    // Valid from: Fri May 29 13:29:00 PDT 2020 until: Sun Aug 28 13:34:23 PDT 2022
+    private static final String VALID = "-----BEGIN CERTIFICATE-----\n" +
+            "MIIFpjCCBI6gAwIBAgIQCDeQvreO65ZgB609vxHVcDANBgkqhkiG9w0BAQsFADCB\n" +
+            "ujELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsT\n" +
+            "H1NlZSB3d3cuZW50cnVzdC5uZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAy\n" +
+            "MDE0IEVudHJ1c3QsIEluYy4gLSBmb3IgYXV0aG9yaXplZCB1c2Ugb25seTEuMCwG\n" +
+            "A1UEAxMlRW50cnVzdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEwxTjAeFw0y\n" +
+            "MDA1MjkyMDI5MDBaFw0yMjA4MjgyMDM0MjNaMIHRMQswCQYDVQQGEwJDQTEQMA4G\n" +
+            "A1UECBMHT250YXJpbzEPMA0GA1UEBxMGT3R0YXdhMRMwEQYLKwYBBAGCNzwCAQMT\n" +
+            "AkNBMRgwFgYLKwYBBAGCNzwCAQITB09udGFyaW8xITAfBgNVBAoTGEVudHJ1c3Qg\n" +
+            "RGF0YWNhcmQgTGltaXRlZDEdMBsGA1UEDxMUUHJpdmF0ZSBPcmdhbml6YXRpb24x\n" +
+            "EDAOBgNVBAUTBzE5MTM2MDUxHDAaBgNVBAMTE3ZhbGlkZzQuZW50cnVzdC5uZXQw\n" +
+            "ggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC508f77Kp/kfbqs9DHfa+V\n" +
+            "977gsVzI78TzfN4tF3ujwnPgd9mzLArM71VJvceOJUto7ywRasxmFxOLHf7WN2Kg\n" +
+            "U1yk/Kp9WUNfjmjIkI+JfCTkaz1RztpW85GNN9SL/W2yFIxv0ijAiGoQeC7J80Ni\n" +
+            "+y31Q5+M0oPMzngBOtD8LpyVt+/lSwUvxwhlChu7LWpIFmBUriILkvh11vxaItZV\n" +
+            "Jm4g8amE33/eXPFjZxB4ABQpBMC4QVg10UP+DpimZuJa6oQZfoNUjDF2yKlyrA+z\n" +
+            "s3kK8SXzJhE5LQxBp158jAoCVZuER08cumw3wvXI5NGzkzDxpTGacDO0bDo2ULpN\n" +
+            "AgMBAAGjggGNMIIBiTAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUH\n" +
+            "AwIGCCsGAQUFBwMBMAwGA1UdEwEB/wQCMAAwHQYDVR0OBBYEFOA38RC6Sv6hMUgY\n" +
+            "eLACjvqO13vsMB8GA1UdIwQYMBaAFO5H0YVx8f0ttz+7PmNYdxdJQA6VMGgGCCsG\n" +
+            "AQUFBwEBBFwwWjAjBggrBgEFBQcwAYYXaHR0cDovL29jc3AuZW50cnVzdC5uZXQw\n" +
+            "MwYIKwYBBQUHMAKGJ2h0dHA6Ly9haWEuZW50cnVzdC5uZXQvbDFuLWNoYWluMjU2\n" +
+            "LmNlcjAzBgNVHR8ELDAqMCigJqAkhiJodHRwOi8vY3JsLmVudHJ1c3QubmV0L2xl\n" +
+            "dmVsMW4uY3JsMB4GA1UdEQQXMBWCE3ZhbGlkZzQuZW50cnVzdC5uZXQwSwYDVR0g\n" +
+            "BEQwQjA3BgpghkgBhvpsCgECMCkwJwYIKwYBBQUHAgEWG2h0dHBzOi8vd3d3LmVu\n" +
+            "dHJ1c3QubmV0L3JwYTAHBgVngQwBATANBgkqhkiG9w0BAQsFAAOCAQEAOExxxxEk\n" +
+            "iAZZ4RJSWwI/CBQYAlUmd2wb/SBk9eYNAu/UL0XiAbwbOjH2dV6JHwAdwn0eoPR1\n" +
+            "KK/E1/OVoVibVBdxLMISPqdodRgHps6kGCOJxS8Zz8d3AEvx27EQ/Hg/EwIJZsUK\n" +
+            "dyb48V6a3XzExqLiwGu9oI9Ozm3/mo11ixmhvSFXH+FZf93qvvCSO+XTGGrLv5ja\n" +
+            "Tkazn/HgnwUBHd1TiO0jLhAdc+rZyd/SDjXMAXsa99zVfc2MY0Mb8+MohNHOwqYg\n" +
+            "tuYuirvtt9P0oteauL+iEBCRcqsmJaHGeaEyJH2QMxC5W22KpW245eHisW7rMoGQ\n" +
+            "9nbGmfe97p7bHQ==\n" +
+            "-----END CERTIFICATE-----";
 
+    // Owner: CN=revokedg4.entrust.net, SERIALNUMBER=1913605, OID.2.5.4.15=Private Organization,
+    // O=Entrust Datacard Limited, OID.1.3.6.1.4.1.311.60.2.1.2=Ontario, OID.1.3.6.1.4.1.311.60.2.1.3=CA,
+    // L=Ottawa, ST=Ontario, C=CA
+    // Issuer: CN=Entrust Certification Authority - L1N, OU="(c) 2014 Entrust, Inc. - for authorized use only",
+    // OU=See www.entrust.net/legal-terms, O="Entrust, Inc.", C=US
+    // Serial number: 24c5f46412b9dcc242a93017176979d6
+    // Valid from: Fri May 29 13:36:00 PDT 2020 until: Sun Aug 28 13:40:43 PDT 2022
+    private static final String REVOKED = "-----BEGIN CERTIFICATE-----\n" +
+            "MIIFqjCCBJKgAwIBAgIQJMX0ZBK53MJCqTAXF2l51jANBgkqhkiG9w0BAQsFADCB\n" +
+            "ujELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsT\n" +
+            "H1NlZSB3d3cuZW50cnVzdC5uZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAy\n" +
+            "MDE0IEVudHJ1c3QsIEluYy4gLSBmb3IgYXV0aG9yaXplZCB1c2Ugb25seTEuMCwG\n" +
+            "A1UEAxMlRW50cnVzdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEwxTjAeFw0y\n" +
+            "MDA1MjkyMDM2MDBaFw0yMjA4MjgyMDQwNDNaMIHTMQswCQYDVQQGEwJDQTEQMA4G\n" +
+            "A1UECBMHT250YXJpbzEPMA0GA1UEBxMGT3R0YXdhMRMwEQYLKwYBBAGCNzwCAQMT\n" +
+            "AkNBMRgwFgYLKwYBBAGCNzwCAQITB09udGFyaW8xITAfBgNVBAoTGEVudHJ1c3Qg\n" +
+            "RGF0YWNhcmQgTGltaXRlZDEdMBsGA1UEDxMUUHJpdmF0ZSBPcmdhbml6YXRpb24x\n" +
+            "EDAOBgNVBAUTBzE5MTM2MDUxHjAcBgNVBAMTFXJldm9rZWRnNC5lbnRydXN0Lm5l\n" +
+            "dDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAN6Bvaj7EG752e15UQH9\n" +
+            "4o8+660Gi3caUAAu45vZebO7EfRgrz0zyalpiexmQzocGn6Zog2yVqmMZjrMY11a\n" +
+            "q96s0pzVKImnA/787G7J5lRncP+PM6/WGtUUGS2hHiifoW5Ya/kcI1uk6EDT0leb\n" +
+            "HIedOiwcfDkq38g5ckuWNae24DAD8AM9XBJXMuNbuiqo03wMlDL3Jif8wNQfpmPD\n" +
+            "b+KR6IwGJdYwLBMoMcPmZF0rykW3YTO2NTDGCwvT8zzvjIKp8caRkI6pfkKmc89U\n" +
+            "Nvgbk/d9JEsgQLbYmRKVnhtnt756U7v3+0kZITxzfsBvQZ6zC7X4FAcTN1302RGn\n" +
+            "NGsCAwEAAaOCAY8wggGLMA4GA1UdDwEB/wQEAwIFoDAdBgNVHSUEFjAUBggrBgEF\n" +
+            "BQcDAgYIKwYBBQUHAwEwDAYDVR0TAQH/BAIwADAdBgNVHQ4EFgQULjRc9DEsa0kD\n" +
+            "uhKNo6cCqQ+mPjgwHwYDVR0jBBgwFoAU7kfRhXHx/S23P7s+Y1h3F0lADpUwaAYI\n" +
+            "KwYBBQUHAQEEXDBaMCMGCCsGAQUFBzABhhdodHRwOi8vb2NzcC5lbnRydXN0Lm5l\n" +
+            "dDAzBggrBgEFBQcwAoYnaHR0cDovL2FpYS5lbnRydXN0Lm5ldC9sMW4tY2hhaW4y\n" +
+            "NTYuY2VyMDMGA1UdHwQsMCowKKAmoCSGImh0dHA6Ly9jcmwuZW50cnVzdC5uZXQv\n" +
+            "bGV2ZWwxbi5jcmwwIAYDVR0RBBkwF4IVcmV2b2tlZGc0LmVudHJ1c3QubmV0MEsG\n" +
+            "A1UdIAREMEIwNwYKYIZIAYb6bAoBAjApMCcGCCsGAQUFBwIBFhtodHRwczovL3d3\n" +
+            "dy5lbnRydXN0Lm5ldC9ycGEwBwYFZ4EMAQEwDQYJKoZIhvcNAQELBQADggEBAGab\n" +
+            "wtgpooQW3YL2Cqk9RDJFbNct5BSbzgY9qN1TOe4L7gbjV0BJBCcsHOCjvbgEuzME\n" +
+            "FC/kAmBu7eMnKVAqCCsWaI8XV7xB7P/BqHpvf9LI/GyHg4wCYdxgFGBXHOjlSy+8\n" +
+            "YWRM5UnFUknqbj1B4u2/U+U3X66QXi+MWrmBdjpcMahpY5zP1Bh90OmIc8DY4arf\n" +
+            "widObgJe2H/VFScudLf5JMpBso2v772GYTRr5Tqqq3ouS9WvDf0NBvoStt1oiUMP\n" +
+            "oowesfNiaYa/rZzWRlhYNs089KUeLhjOZswtIY5LCyy+Wt3CHgXljGEQFgi7p59s\n" +
+            "gk0aMRYM9Gri26VbD5A=\n" +
+            "-----END CERTIFICATE-----";
+
+    public void runTest(ValidatePathWithParams pathValidator, boolean ocspEnabled) throws Exception {
         // Validate valid
         pathValidator.validate(new String[]{VALID, INT},
                 ValidatePathWithParams.Status.GOOD, null, System.out);
 
         // Validate Revoked
         pathValidator.validate(new String[]{REVOKED, INT},
                 ValidatePathWithParams.Status.REVOKED,
-                "Wed May 24 10:39:28 PDT 2017", System.out);
+                "Fri May 29 13:42:13 PDT 2020", System.out);
     }
-
 }
diff a/test/jdk/sun/nio/ch/TestMaxCachedBufferSize.java b/test/jdk/sun/nio/ch/TestMaxCachedBufferSize.java
--- a/test/jdk/sun/nio/ch/TestMaxCachedBufferSize.java
+++ b/test/jdk/sun/nio/ch/TestMaxCachedBufferSize.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -20,40 +20,40 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 import java.io.IOException;
-
 import java.lang.management.BufferPoolMXBean;
 import java.lang.management.ManagementFactory;
-
 import java.nio.ByteBuffer;
-
 import java.nio.channels.FileChannel;
-
 import java.nio.file.Path;
 import java.nio.file.Paths;
+import java.util.List;
+import java.util.SplittableRandom;
+import java.util.concurrent.CountDownLatch;
 
 import static java.nio.file.StandardOpenOption.CREATE;
 import static java.nio.file.StandardOpenOption.TRUNCATE_EXISTING;
 import static java.nio.file.StandardOpenOption.WRITE;
 
-import java.util.List;
-import java.util.Random;
-import java.util.concurrent.CountDownLatch;
+import jdk.test.lib.RandomFactory;
 
 /*
  * @test
  * @requires sun.arch.data.model == "64"
  * @modules java.management
+ * @library /test/lib
  * @build TestMaxCachedBufferSize
  * @run main/othervm TestMaxCachedBufferSize
  * @run main/othervm -Djdk.nio.maxCachedBufferSize=0 TestMaxCachedBufferSize
  * @run main/othervm -Djdk.nio.maxCachedBufferSize=2000 TestMaxCachedBufferSize
  * @run main/othervm -Djdk.nio.maxCachedBufferSize=100000 TestMaxCachedBufferSize
  * @run main/othervm -Djdk.nio.maxCachedBufferSize=10000000 TestMaxCachedBufferSize
- * @summary Test the implementation of the jdk.nio.maxCachedBufferSize property.
+ * @summary Test the implementation of the jdk.nio.maxCachedBufferSize property
+ * (use -Dseed=X to set PRNG seed)
+ * @key randomness
  */
 public class TestMaxCachedBufferSize {
     private static final int DEFAULT_ITERS = 10 * 1000;
     private static final int DEFAULT_THREAD_NUM = 4;
 
@@ -68,11 +68,13 @@
                                  LARGE_BUFFER_MAX_SIZE - LARGE_BUFFER_MIN_SIZE;
 
     private static final int LARGE_BUFFER_FREQUENCY = 100;
 
     private static final String FILE_NAME_PREFIX = "nio-out-file-";
-    private static final int VERBOSE_PERIOD = 5 * 1000;
+    private static final int VERBOSE_PERIOD = DEFAULT_ITERS / 10;
+
+    private static final SplittableRandom SRAND = RandomFactory.getSplittableRandom();
 
     private static int iters = DEFAULT_ITERS;
     private static int threadNum = DEFAULT_THREAD_NUM;
 
     private static BufferPoolMXBean getDirectPool() {
@@ -84,20 +86,22 @@
             }
         }
         throw new Error("could not find direct pool");
     }
     private static final BufferPoolMXBean directPool = getDirectPool();
+    private static long initialCount;
+    private static long initialCapacity;
 
     // Each worker will do write operations on a file channel using
     // buffers of various sizes. The buffer size is randomly chosen to
     // be within a small or a large range. This way we can control
     // which buffers can be cached (all, only the small ones, or none)
     // by setting the jdk.nio.maxCachedBufferSize property.
     private static class Worker implements Runnable {
         private final int id;
         private final CountDownLatch finishLatch, exitLatch;
-        private final Random random = new Random();
+        private SplittableRandom random = SRAND.split();
         private long smallBufferCount = 0;
         private long largeBufferCount = 0;
 
         private int getWriteSize() {
             int minSize = 0;
@@ -175,12 +179,13 @@
             this.exitLatch = exitLatch;
         }
     }
 
     public static void checkDirectBuffers(long expectedCount, long expectedMax) {
-        final long directCount = directPool.getCount();
-        final long directTotalCapacity = directPool.getTotalCapacity();
+        final long directCount = directPool.getCount() - initialCount;
+        final long directTotalCapacity =
+            directPool.getTotalCapacity() - initialCapacity;
         System.out.printf("Direct %d / %dK\n",
                           directCount, directTotalCapacity / 1024);
 
         if (directCount > expectedCount) {
             throw new Error(String.format(
@@ -188,16 +193,19 @@
                 expectedCount, directCount));
         }
 
         if (directTotalCapacity > expectedMax) {
             throw new Error(String.format(
-                "inconsistent direct buffer total capacity, expectex max = %d, found = %d",
+                "inconsistent direct buffer total capacity, expected max = %d, found = %d",
                 expectedMax, directTotalCapacity));
         }
     }
 
     public static void main(String[] args) {
+        initialCount = directPool.getCount();
+        initialCapacity = directPool.getTotalCapacity();
+
         final String maxBufferSizeStr = System.getProperty("jdk.nio.maxCachedBufferSize");
         final long maxBufferSize =
             (maxBufferSizeStr != null) ? Long.valueOf(maxBufferSizeStr) : Long.MAX_VALUE;
 
         // We assume that the max cannot be equal to a size of a
diff a/test/jdk/sun/security/lib/cacerts/VerifyCACerts.java b/test/jdk/sun/security/lib/cacerts/VerifyCACerts.java
--- a/test/jdk/sun/security/lib/cacerts/VerifyCACerts.java
+++ b/test/jdk/sun/security/lib/cacerts/VerifyCACerts.java
@@ -24,11 +24,11 @@
 
 /**
  * @test
  * @bug 8189131 8198240 8191844 8189949 8191031 8196141 8204923 8195774 8199779
  *      8209452 8209506 8210432 8195793 8216577 8222089 8222133 8222137 8222136
- *      8223499 8225392 8232019 8234245 8233223 8225068 8225069
+ *      8223499 8225392 8232019 8234245 8233223 8225068 8225069 8243321
  * @summary Check root CA entries in cacerts file
  */
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.nio.file.Files;
@@ -50,16 +50,16 @@
     private static final String CACERTS
             = System.getProperty("java.home") + File.separator + "lib"
             + File.separator + "security" + File.separator + "cacerts";
 
     // The numbers of certs now.
-    private static final int COUNT = 91;
+    private static final int COUNT = 92;
 
     // SHA-256 of cacerts, can be generated with
     // shasum -a 256 cacerts | sed -e 's/../&:/g' | tr '[:lower:]' '[:upper:]' | cut -c1-95
     private static final String CHECKSUM
-            = "60:EF:3A:F8:44:CF:79:6F:A3:55:AD:3A:80:61:A7:EE:69:2A:B4:E4:F4:01:C4:47:FF:F8:25:1E:AB:87:31:F2";
+            = "44:AE:94:16:D1:2A:5B:CB:C3:89:19:D5:7A:87:C9:4A:E1:D4:ED:24:81:25:0A:0F:70:75:08:2A:D5:90:93:8B";
 
     // map of cert alias to SHA-256 fingerprint
     @SuppressWarnings("serial")
     private static final Map<String, String> FINGERPRINT_MAP = new HashMap<>() {
         {
@@ -243,10 +243,12 @@
                     "1B:A5:B2:AA:8C:65:40:1A:82:96:01:18:F8:0B:EC:4F:62:30:4D:83:CE:C4:71:3A:19:C3:9C:01:1E:A4:6D:B4");
             put("amazonrootca3 [jdk]",
                     "18:CE:6C:FE:7B:F1:4E:60:B2:E3:47:B8:DF:E8:68:CB:31:D0:2E:BB:3A:DA:27:15:69:F5:03:43:B4:6D:B3:A4");
             put("amazonrootca4 [jdk]",
                     "E3:5D:28:41:9E:D0:20:25:CF:A6:90:38:CD:62:39:62:45:8D:A5:C6:95:FB:DE:A3:C2:2B:0B:FB:25:89:70:92");
+            put("entrustrootcag4 [jdk]",
+                    "DB:35:17:D1:F6:73:2A:2D:5A:B9:7C:53:3E:C7:07:79:EE:32:70:A6:2F:B4:AC:42:38:37:24:60:E6:F0:1E:88");
         }
     };
 
     // Exception list to 90 days expiry policy
     // No error will be reported if certificate in this list expires
diff a/test/jdk/sun/security/ssl/SSLLogger/LoggerDateFormatterTest.java b/test/jdk/sun/security/ssl/SSLLogger/LoggerDateFormatterTest.java
--- /dev/null
+++ b/test/jdk/sun/security/ssl/SSLLogger/LoggerDateFormatterTest.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 8245306
+ * @summary Replace ThreadLocal date format with DateTimeFormatter
+ * @modules java.base/sun.security.ssl:+open
+ * @compile LoggerDateFormatterTest.java
+ * @run testng/othervm -Djavax.net.debug=all LoggerDateFormatterTest
+ */
+
+import org.testng.annotations.BeforeTest;
+import org.testng.annotations.Test;
+import sun.security.ssl.SSLLogger;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.PrintStream;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import static java.lang.System.out;
+import static org.testng.Assert.fail;
+
+public class LoggerDateFormatterTest {
+
+    SSLPrintStream sslStream;
+    static String year = "(\\|\\d\\d\\d\\d-\\d\\d-\\d\\d";
+    static String hour = "\\s\\d\\d:\\d\\d:\\d\\d\\.\\d\\d\\d\\s";
+    static String zone = "([A-Za-z]+([\\+\\-][0-2]?[0-9](\\:[0-5]?[0-9]))?))";
+    static Pattern pattern;
+    Matcher matcher;
+
+    @BeforeTest
+    public void setUp() {
+        sslStream = new SSLPrintStream(System.err);
+        System.setErr(sslStream);
+        String format = year + hour + zone;
+        pattern = Pattern.compile(format);
+    }
+
+    @Test
+    public void testDateFormat() {
+        SSLLogger.info("logging");
+        System.out.println("The value is: " + sslStream.bos.toString());
+        matcher = pattern.matcher(sslStream.bos.toString());
+        if (matcher.find()) {
+            out.println("Test Passed with value :" + matcher.group());
+        }
+        else {
+            fail("Test failed wrong SSL DateFormat");
+        }
+    }
+
+    public static class SSLPrintStream extends PrintStream {
+
+        public ByteArrayOutputStream bos; // Stream that accumulates System.err
+
+        public SSLPrintStream(OutputStream out) {
+            super(out);
+            bos = new ByteArrayOutputStream();
+        }
+
+        @Override
+        public void write(int b) {
+            super.write(b);
+            bos.write(b);
+        }
+
+        @Override
+        public void write(byte[] buf, int off, int len) {
+            super.write(buf, off, len);
+            bos.write(buf, off, len);
+        }
+
+        @Override
+        public void write(byte[] buf) throws IOException {
+            super.write(buf);
+            bos.write(buf);
+        }
+
+        @Override
+        public void writeBytes(byte[] buf) {
+            super.writeBytes(buf);
+            bos.writeBytes(buf);
+        }
+    }
+
+}
diff a/test/jdk/sun/security/tools/jarsigner/TimestampCheck.java b/test/jdk/sun/security/tools/jarsigner/TimestampCheck.java
--- a/test/jdk/sun/security/tools/jarsigner/TimestampCheck.java
+++ b/test/jdk/sun/security/tools/jarsigner/TimestampCheck.java
@@ -55,11 +55,11 @@
 import sun.security.pkcs.SignerInfo;
 import sun.security.timestamp.TimestampToken;
 
 /*
  * @test
- * @bug 6543842 6543440 6939248 8009636 8024302 8163304 8169911 8180289 8172404
+ * @bug 6543842 6543440 6939248 8009636 8024302 8163304 8169911 8180289 8172404 8247960
  * @summary checking response of timestamp
  * @modules java.base/sun.security.pkcs
  *          java.base/sun.security.timestamp
  *          java.base/sun.security.x509
  *          java.base/sun.security.util
@@ -291,27 +291,31 @@
 
                 // Legacy algorithms
                 signVerbose(null, "unsigned.jar", "sha1alg.jar", "signer",
                         "-strict", "-digestalg", "SHA-1")
                         .shouldHaveExitValue(0)
-                        .shouldContain("jar signed, with signer errors")
+                        .shouldContain("jar signed")
+                        .shouldNotContain("with signer errors")
                         .shouldMatch("SHA-1.*-digestalg.*will be disabled");
                 verify("sha1alg.jar", "-strict")
                         .shouldHaveExitValue(0)
-                        .shouldContain("jar verified, with signer errors")
+                        .shouldContain("jar verified")
+                        .shouldNotContain("with signer errors")
                         .shouldContain("SHA-1 digest algorithm is considered a security risk")
                         .shouldContain("This algorithm will be disabled in a future update")
                         .shouldNotContain("is disabled");
 
                 sign("sha1tsaalg", "-tsadigestalg", "SHA-1", "-strict")
                         .shouldHaveExitValue(0)
-                        .shouldContain("jar signed, with signer errors")
+                        .shouldContain("jar signed")
+                        .shouldNotContain("with signer errors")
                         .shouldMatch("SHA-1.*-tsadigestalg.*will be disabled")
                         .shouldNotContain("is disabled");
                 verify("sha1tsaalg.jar", "-strict")
                         .shouldHaveExitValue(0)
-                        .shouldContain("jar verified, with signer errors")
+                        .shouldContain("jar verified")
+                        .shouldNotContain("with signer errors")
                         .shouldContain("SHA-1 timestamp digest algorithm is considered a security risk")
                         .shouldNotContain("is disabled");
 
                 // Disabled algorithms
                 sign("tsdisabled", "-digestalg", "MD5",
diff a/test/langtools/jdk/javadoc/doclet/testIndentation/TestIndentation.java b/test/langtools/jdk/javadoc/doclet/testIndentation/TestIndentation.java
--- a/test/langtools/jdk/javadoc/doclet/testIndentation/TestIndentation.java
+++ b/test/langtools/jdk/javadoc/doclet/testIndentation/TestIndentation.java
@@ -49,13 +49,13 @@
 
         checkOutput("p/Indent.html", true,
                 """
                     <div class="member-signature"><span class="modifiers">public</span>&nbsp;<span c\
                     lass="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type">void</spa\
-                    n>&nbsp;<span class="member-name">m</span>&#8203;(<span class="parameters">T&nbs\
+                    n>&nbsp;<span class="member-name">m</span>&#8203;<span class="parameters">(T&nbs\
                     p;t1,
-                    T&nbsp;t2)</span>
+                     T&nbsp;t2)</span>
                                throws <span class="exceptions">java.lang.Exception</span></div>""");
 
         // Test indentation of annotations and annotated method arguments
         checkOutput("p/IndentAnnot.html", false,
                 " @Deprecated",
diff a/test/langtools/jdk/javadoc/doclet/testJavaFX/TestJavaFX.java b/test/langtools/jdk/javadoc/doclet/testJavaFX/TestJavaFX.java
--- a/test/langtools/jdk/javadoc/doclet/testJavaFX/TestJavaFX.java
+++ b/test/langtools/jdk/javadoc/doclet/testJavaFX/TestJavaFX.java
@@ -60,11 +60,11 @@
                     <dd><a href="#getRate()"><code>getRate()</code></a>,\s
                     <a href="#setRate(double)"><code>setRate(double)</code></a></dd>""",
                 """
                     <div class="member-signature"><span class="modifiers">public final</span>&nbsp;<\
                     span class="return-type">void</span>&nbsp;<span class="member-name">setRate</spa\
-                    n>&#8203;(<span class="parameters">double&nbsp;value)</span></div>
+                    n>&#8203;<span class="parameters">(double&nbsp;value)</span></div>
                     <div class="block">Sets the value of the property rate.</div>
                     <dl class="notes">
                     <dt>Property description:</dt>""",
                 """
                     <div class="member-signature"><span class="modifiers">public final</span>&nbsp;<\
@@ -112,11 +112,11 @@
                 """
                     <section class="detail" id="setPaused(boolean)">
                     <h3>setPaused</h3>
                     <div class="member-signature"><span class="modifiers">public final</span>&nbsp;<\
                     span class="return-type">void</span>&nbsp;<span class="member-name">setPaused</s\
-                    pan>&#8203;(<span class="parameters">boolean&nbsp;value)</span></div>
+                    pan>&#8203;<span class="parameters">(boolean&nbsp;value)</span></div>
                     <div class="block">Sets the value of the property paused.</div>
                     <dl class="notes">
                     <dt>Property description:</dt>
                     <dd>Defines if paused. The second line.</dd>
                     <dt>Default value:</dt>
@@ -145,11 +145,11 @@
                 """
                     <section class="detail" id="setRate(double)">
                     <h3>setRate</h3>
                     <div class="member-signature"><span class="modifiers">public final</span>&nbsp;<\
                     span class="return-type">void</span>&nbsp;<span class="member-name">setRate</spa\
-                    n>&#8203;(<span class="parameters">double&nbsp;value)</span></div>
+                    n>&#8203;<span class="parameters">(double&nbsp;value)</span></div>
                     <div class="block">Sets the value of the property rate.</div>
                     <dl class="notes">
                     <dt>Property description:</dt>
                     <dd>Defines the direction/speed at which the <code>Timeline</code> is expected to
                      be played. This is the second line.</dd>
diff a/test/langtools/jdk/javadoc/doclet/testLinkOption/TestLinkOption.java b/test/langtools/jdk/javadoc/doclet/testLinkOption/TestLinkOption.java
--- a/test/langtools/jdk/javadoc/doclet/testLinkOption/TestLinkOption.java
+++ b/test/langtools/jdk/javadoc/doclet/testLinkOption/TestLinkOption.java
@@ -75,16 +75,16 @@
                     java/lang/String.html" title="class or interface in java.lang" class="external-l\
                     ink"><code>Link to String Class</code></a>""",
                 //Make sure the parameters are formatted properly when the -link option is used.
                 """
                     (int&nbsp;p1,
-                    int&nbsp;p2,
-                    int&nbsp;p3)""",
+                     int&nbsp;p2,
+                     int&nbsp;p3)""",
                 """
                     (int&nbsp;p1,
-                    int&nbsp;p2,
-                    <a href=\"""" + url + """
+                     int&nbsp;p2,
+                     <a href=\"""" + url + """
                     java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a>&nbsp;p3)""");
 
         checkOutput("pkg/B.html", true,
                 """
                     <div class="block">A method with html tag the method <a href=\"""" + url + """
diff a/test/langtools/jdk/javadoc/doclet/testMemberInheritance/TestMemberInheritance.java b/test/langtools/jdk/javadoc/doclet/testMemberInheritance/TestMemberInheritance.java
--- a/test/langtools/jdk/javadoc/doclet/testMemberInheritance/TestMemberInheritance.java
+++ b/test/langtools/jdk/javadoc/doclet/testMemberInheritance/TestMemberInheritance.java
@@ -103,11 +103,11 @@
                 """
                     <td class="col-first"><code>static java.time.Period</code></td>
                     <th class="col-second" scope="row"><code><span class="member-name-link"><a href=\
                     "#between(java.time.LocalDate,java.time.LocalDate)">between</a></span>&#8203;(ja\
                     va.time.LocalDate&nbsp;startDateInclusive,
-                    java.time.LocalDate&nbsp;endDateExclusive)</code></th>""");
+                     java.time.LocalDate&nbsp;endDateExclusive)</code></th>""");
 
         checkOutput("pkg1/Implementer.html", false,
                 """
                     <h3>Methods inherited from interface&nbsp;pkg1.<a href="Interface.html" title="interface in pkg1">Interface</a></h3>
                     <code><a href="Interface.html#between(java.time.chrono.ChronoLocalDate,java.time\
@@ -137,11 +137,11 @@
                 """
                     <section class="detail" id="parentMethod(T)">
                     <h3 id="parentMethod(java.lang.Object)">parentMethod</h3>
                     <div class="member-signature"><span class="modifiers">protected abstract</span>&\
                     nbsp;<span class="return-type">java.lang.String</span>&nbsp;<span class="member-\
-                    name">parentMethod</span>&#8203;(<span class="parameters">java.lang.String&nbsp;\
+                    name">parentMethod</span>&#8203;<span class="parameters">(java.lang.String&nbsp;\
                     t)</span>
                                                               throws <span class="exceptions">java.lang.IllegalArgumentException,
                     java.lang.InterruptedException,
                     java.lang.IllegalStateException</span></div>
                     <div class="block">Returns some value with an <span id="inheritedsearchtag" clas\
@@ -178,11 +178,11 @@
                 """
                     <section class="detail" id="method(T)">
                     <h3 id="method(java.lang.Object)">method</h3>
                     <div class="member-signature"><span class="modifiers">public</span>&nbsp;<span c\
                     lass="return-type">java.lang.String</span>&nbsp;<span class="member-name">method\
-                    </span>&#8203;(<span class="parameters">java.lang.String&nbsp;t)</span></div>
+                    </span>&#8203;<span class="parameters">(java.lang.String&nbsp;t)</span></div>
                     </section>""");
 
         checkOutput("index-all.html", true,
                 """
                     <dt><span class="member-name-link"><a href="pkg2/DocumentedNonGenericChild.html#\
@@ -225,11 +225,11 @@
                 """
                     <section class="detail" id="parentMethod(T)">
                     <h3 id="parentMethod(java.lang.Object)">parentMethod</h3>
                     <div class="member-signature"><span class="modifiers">protected abstract</span>&\
                     nbsp;<span class="return-type">java.lang.String</span>&nbsp;<span class="member-\
-                    name">parentMethod</span>&#8203;(<span class="parameters">java.lang.String&nbsp;\
+                    name">parentMethod</span>&#8203;<span class="parameters">(java.lang.String&nbsp;\
                     t)</span>
                                                               throws <span class="exceptions">java.lang.IllegalArgumentException,
                     java.lang.InterruptedException,
                     java.lang.IllegalStateException</span></div>
                     <div class="block">Returns some value with an <span id="inheritedsearchtag" clas\
diff a/test/langtools/jdk/javadoc/doclet/testMethodSignature/TestMethodSignature.java b/test/langtools/jdk/javadoc/doclet/testMethodSignature/TestMethodSignature.java
--- a/test/langtools/jdk/javadoc/doclet/testMethodSignature/TestMethodSignature.java
+++ b/test/langtools/jdk/javadoc/doclet/testMethodSignature/TestMethodSignature.java
@@ -53,23 +53,23 @@
                     </span><span class="modifiers">public</span>&nbsp;<span class="member-name">C</span>()</div>""",
 
                 """
                     <div class="member-signature"><span class="modifiers">public static</span>&nbsp;\
                     <span class="return-type">void</span>&nbsp;<span class="member-name">simpleMetho\
-                    d</span>&#8203;(<span class="parameters">int&nbsp;i,
-                    java.lang.String&nbsp;s,
-                    boolean&nbsp;b)</span></div>""",
+                    d</span>&#8203;<span class="parameters">(int&nbsp;i,
+                     java.lang.String&nbsp;s,
+                     boolean&nbsp;b)</span></div>""",
 
                 """
                     <div class="member-signature"><span class="annotations">@Generated(value="SomeGeneratedName",
                                date="a date",
                                comments="some comment about the method below")
                     </span><span class="modifiers">public static</span>&nbsp;<span class="return-typ\
-                    e">void</span>&nbsp;<span class="member-name">annotatedMethod</span>&#8203;(<spa\
-                    n class="parameters">int&nbsp;i,
-                    java.lang.String&nbsp;s,
-                    boolean&nbsp;b)</span></div>""",
+                    e">void</span>&nbsp;<span class="member-name">annotatedMethod</span>&#8203;<span\
+                     class="parameters">(int&nbsp;i,
+                     java.lang.String&nbsp;s,
+                     boolean&nbsp;b)</span></div>""",
 
                 """
                     <div class="member-signature"><span class="modifiers">public static</span>&nbsp;\
                     <span class="type-parameters-long">&lt;T1 extends java.lang.AutoCloseable,&#8203\
                     ;
@@ -81,19 +81,19 @@
                     T7 extends java.lang.AutoCloseable,&#8203;
                     T8 extends java.lang.AutoCloseable&gt;</span>
                     <span class="return-type"><a href="C.With8Types.html" title="class in pkg">C.Wit\
                     h8Types</a>&lt;T1,&#8203;T2,&#8203;T3,&#8203;T4,&#8203;T5,&#8203;T6,&#8203;T7,&#\
                     8203;T8&gt;</span>&nbsp;<span class="member-name">bigGenericMethod</span>&#8203;\
-                    (<span class="parameters"><a href="C.F0.html" title="interface in pkg">C.F0</a>&\
+                    <span class="parameters">(<a href="C.F0.html" title="interface in pkg">C.F0</a>&\
                     lt;? extends T1&gt;&nbsp;t1,
-                    <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T2&gt;&nbsp;t2,
-                    <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T3&gt;&nbsp;t3,
-                    <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T4&gt;&nbsp;t4,
-                    <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T5&gt;&nbsp;t5,
-                    <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T6&gt;&nbsp;t6,
-                    <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T7&gt;&nbsp;t7,
-                    <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T8&gt;&nbsp;t8)</span>
+                     <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T2&gt;&nbsp;t2,
+                     <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T3&gt;&nbsp;t3,
+                     <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T4&gt;&nbsp;t4,
+                     <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T5&gt;&nbsp;t5,
+                     <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T6&gt;&nbsp;t6,
+                     <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T7&gt;&nbsp;t7,
+                     <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T8&gt;&nbsp;t8)</span>
                                                                     throws <span class="exceptions">java.lang.IllegalArgumentException,
                     java.lang.IllegalStateException</span></div>""",
 
                 """
                     <div class="member-signature"><span class="annotations">@Generated(value="SomeGeneratedName",
@@ -109,19 +109,19 @@
                     T7 extends java.lang.AutoCloseable,&#8203;
                     T8 extends java.lang.AutoCloseable&gt;</span>
                     <span class="return-type"><a href="C.With8Types.html" title="class in pkg">C.Wit\
                     h8Types</a>&lt;T1,&#8203;T2,&#8203;T3,&#8203;T4,&#8203;T5,&#8203;T6,&#8203;T7,&#\
                     8203;T8&gt;</span>&nbsp;<span class="member-name">bigGenericAnnotatedMethod</spa\
-                    n>&#8203;(<span class="parameters"><a href="C.F0.html" title="interface in pkg">\
+                    n>&#8203;<span class="parameters">(<a href="C.F0.html" title="interface in pkg">\
                     C.F0</a>&lt;? extends T1&gt;&nbsp;t1,
-                    <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T2&gt;&nbsp;t2,
-                    <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T3&gt;&nbsp;t3,
-                    <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T4&gt;&nbsp;t4,
-                    <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T5&gt;&nbsp;t5,
-                    <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T6&gt;&nbsp;t6,
-                    <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T7&gt;&nbsp;t7,
-                    <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T8&gt;&nbsp;t8)</span>
+                     <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T2&gt;&nbsp;t2,
+                     <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T3&gt;&nbsp;t3,
+                     <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T4&gt;&nbsp;t4,
+                     <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T5&gt;&nbsp;t5,
+                     <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T6&gt;&nbsp;t6,
+                     <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T7&gt;&nbsp;t7,
+                     <a href="C.F0.html" title="interface in pkg">C.F0</a>&lt;? extends T8&gt;&nbsp;t8)</span>
                                                                              throws <span class="exc\
                     eptions">java.lang.IllegalArgumentException,
                     java.lang.IllegalStateException</span></div>
                     <div class="block">Generic method with eight type args and annotation.</div>""");
 
diff a/test/langtools/jdk/javadoc/doclet/testNewLanguageFeatures/TestNewLanguageFeatures.java b/test/langtools/jdk/javadoc/doclet/testNewLanguageFeatures/TestNewLanguageFeatures.java
--- a/test/langtools/jdk/javadoc/doclet/testNewLanguageFeatures/TestNewLanguageFeatures.java
+++ b/test/langtools/jdk/javadoc/doclet/testNewLanguageFeatures/TestNewLanguageFeatures.java
@@ -80,11 +80,11 @@
                 "Overloaded valueOf() method has correct documentation.",
                 "Overloaded values method  has correct documentation.",
                 """
                     <div class="member-signature"><span class="modifiers">public static</span>&nbsp;\
                     <span class="return-type"><a href="Coin.html" title="enum in pkg">Coin</a></span\
-                    >&nbsp;<span class="member-name">valueOf</span>&#8203;(<span class="parameters">\
+                    >&nbsp;<span class="member-name">valueOf</span>&#8203;<span class="parameters">(\
                     java.lang.String&nbsp;name)</span></div>
                     <div class="block">Returns the enum constant of this type with the specified name.
                     The string must match <i>exactly</i> an identifier used to declare an
                     enum constant in this type.  (Extraneous whitespace characters are\s
                     not permitted.)</div>
@@ -132,13 +132,13 @@
                 """
                     <div class="member-signature"><span class="modifiers">public</span>&nbsp;<span c\
                     lass="type-parameters">&lt;T extends java.util.List,&#8203;
                     V&gt;</span>
                     <span class="return-type">java.lang.String[]</span>&nbsp;<span class="member-nam\
-                    e">methodThatHasTypeParameters</span>&#8203;(<span class="parameters">T&nbsp;par\
+                    e">methodThatHasTypeParameters</span>&#8203;<span class="parameters">(T&nbsp;par\
                     am1,
-                    V&nbsp;param2)</span></div>""",
+                     V&nbsp;param2)</span></div>""",
                 // Method that returns TypeParameters
                 """
                     <td class="col-first"><code><a href="TypeParameters.html" title="type parameter in TypeParameters">E</a>[]</code></td>
                     <th class="col-second" scope="row"><code><span class="member-name-link"><a href=\
                     "#methodThatReturnsTypeParameterA(E%5B%5D)">methodThatReturnsTypeParameterA</a><\
@@ -146,11 +146,11 @@
                     ers">E</a>[]&nbsp;e)</code>""",
                 """
                     <div class="member-signature"><span class="modifiers">public</span>&nbsp;<span c\
                     lass="return-type"><a href="TypeParameters.html" title="type parameter in TypePa\
                     rameters">E</a>[]</span>&nbsp;<span class="member-name">methodThatReturnsTypePar\
-                    ameterA</span>&#8203;(<span class="parameters"><a href="TypeParameters.html" tit\
+                    ameterA</span>&#8203;<span class="parameters">(<a href="TypeParameters.html" tit\
                     le="type parameter in TypeParameters">E</a>[]&nbsp;e)</span></div>
                     """,
                 """
                     <td class="col-first"><code>&lt;T extends java.lang.Object &amp; java.lang.Compa\
                     rable&lt;? super T&gt;&gt;<br>T</code></td>
@@ -223,11 +223,11 @@
                 """
                     <div class="member-signature"><span class="modifiers">public</span>&nbsp;<span c\
                     lass="type-parameters">&lt;T extends java.lang.Number &amp; java.lang.Runnable&g\
                     t;</span>
                     <span class="return-type">T</span>&nbsp;<span class="member-name">foo</span>&#82\
-                    03;(<span class="parameters">T&nbsp;t)</span></div>""");
+                    03;<span class="parameters">(T&nbsp;t)</span></div>""");
 
         //==============================================================
         // Test Class-Use Documentation for Type Parameters.
         //==============================================================
         // ClassUseTest1: <T extends Foo & Foo2>
@@ -549,25 +549,25 @@
                     </span>&nbsp;<span class="member-name">method</span>()</div>""",
                 // METHOD PARAMS
                 """
                     <div class="member-signature"><span class="modifiers">public</span>&nbsp;<span c\
                     lass="return-type">void</span>&nbsp;<span class="member-name">methodWithParams</\
-                    span>&#8203;(<span class="parameters"><a href="AnnotationType.html" title="annot\
+                    span>&#8203;<span class="parameters">(<a href="AnnotationType.html" title="annot\
                     ation in pkg">@AnnotationType</a>(<a href="AnnotationType.html#optional()">optio\
                     nal</a>="Parameter Annotation",<a href="AnnotationType.html#required()">required\
                     </a>=1994)
-                    int&nbsp;documented,
-                    int&nbsp;undocmented)</span></div>""",
+                     int&nbsp;documented,
+                     int&nbsp;undocmented)</span></div>""",
                 // CONSTRUCTOR PARAMS
                 """
                     <div class="member-signature"><span class="modifiers">public</span>&nbsp;<span c\
-                    lass="member-name">AnnotationTypeUsage</span>&#8203;(<span class="parameters"><a\
+                    lass="member-name">AnnotationTypeUsage</span>&#8203;<span class="parameters">(<a\
                      href="AnnotationType.html" title="annotation in pkg">@AnnotationType</a>(<a hre\
                     f="AnnotationType.html#optional()">optional</a>="Constructor Param Annotation",<\
                     a href="AnnotationType.html#required()">required</a>=1994)
-                    int&nbsp;documented,
-                    int&nbsp;undocmented)</span></div>""");
+                     int&nbsp;documented,
+                     int&nbsp;undocmented)</span></div>""");
 
         //=================================
         // Annotatation Type Usage
         //=================================
         checkOutput("pkg/class-use/AnnotationType.html", true,
diff a/test/langtools/jdk/javadoc/doclet/testPrivateClasses/TestPrivateClasses.java b/test/langtools/jdk/javadoc/doclet/testPrivateClasses/TestPrivateClasses.java
--- a/test/langtools/jdk/javadoc/doclet/testPrivateClasses/TestPrivateClasses.java
+++ b/test/langtools/jdk/javadoc/doclet/testPrivateClasses/TestPrivateClasses.java
@@ -71,11 +71,11 @@
                     </div>""",
                 // Method is documented as though it is declared in the inheriting method.
                 """
                     <div class="member-signature"><span class="modifiers">public</span>&nbsp;<span c\
                     lass="return-type">void</span>&nbsp;<span class="member-name">methodInheritedFro\
-                    mParent</span>&#8203;(<span class="parameters">int&nbsp;p1)</span>
+                    mParent</span>&#8203;<span class="parameters">(int&nbsp;p1)</span>
                                                    throws <span class="exceptions">java.lang.Exception</span></div>""",
                 """
                     <dl class="notes">
                     <dt>All Implemented Interfaces:</dt>
                     <dd><code><a href="PublicInterface.html" title="interface in pkg">PublicInterface</a></code></dd>
diff a/test/langtools/jdk/javadoc/doclet/testRecordTypes/TestRecordTypes.java b/test/langtools/jdk/javadoc/doclet/testRecordTypes/TestRecordTypes.java
--- a/test/langtools/jdk/javadoc/doclet/testRecordTypes/TestRecordTypes.java
+++ b/test/langtools/jdk/javadoc/doclet/testRecordTypes/TestRecordTypes.java
@@ -476,11 +476,11 @@
         Set<ElementType> t = types.isEmpty() ? EnumSet.allOf(ElementType.class) : types;
         String anno = """
             <a href="Anno.html" title="annotation in p">@Anno</a>""";
         String rcAnno = t.contains(ElementType.RECORD_COMPONENT) ? anno + " " : "";
         String fAnno = t.contains(ElementType.FIELD) ? "<span class=\"annotations\">" + anno + "\n</span>" : "";
-        String pAnno = t.contains(ElementType.PARAMETER) ? anno + "\n" : "";
+        String pAnno = t.contains(ElementType.PARAMETER) ? anno + "\n " : "";
         String mAnno= t.contains(ElementType.METHOD) ? "<span class=\"annotations\">" + anno + "\n</span>" : "";
 
         checkOutput("p/R.html", true,
                 """
                     <pre>public record <span class="type-name-label">R</span>("""
@@ -493,11 +493,11 @@
                         + """
                             <span class="modifiers">private final</span>&nbsp;<span class="return-type">int<\
                             /span>&nbsp;<span class="member-name">i</span></div>""",
                 """
                     <div class="member-signature"><span class="modifiers">public</span>&nbsp;<span c\
-                    lass="member-name">R</span>&#8203;(<span class="parameters">"""
+                    lass="member-name">R</span>&#8203;<span class="parameters">("""
                         + pAnno
                         + "int&nbsp;i)</span></div>",
                 "<div class=\"member-signature\">"
                         + mAnno
                         + """
diff a/test/langtools/jdk/javadoc/doclet/testSerializedFormWithClassFile/TestSerializedFormWithClassFile.java b/test/langtools/jdk/javadoc/doclet/testSerializedFormWithClassFile/TestSerializedFormWithClassFile.java
--- a/test/langtools/jdk/javadoc/doclet/testSerializedFormWithClassFile/TestSerializedFormWithClassFile.java
+++ b/test/langtools/jdk/javadoc/doclet/testSerializedFormWithClassFile/TestSerializedFormWithClassFile.java
@@ -74,11 +74,11 @@
 
         checkOutput("serialized-form.html", true,
                 """
                     <div class="member-signature"><span class="modifiers">public</span>&nbsp;<span c\
                     lass="return-type">void</span>&nbsp;<span class="member-name">readObject</span>&\
-                    #8203;(<span class="parameters">java.io.ObjectInputStream&nbsp;arg0)</span>
+                    #8203;<span class="parameters">(java.io.ObjectInputStream&nbsp;arg0)</span>
                                     throws <span class="exceptions">java.lang.ClassNotFoundException,
                     java.io.IOException</span></div>
                     """);
     }
 
diff a/test/langtools/jdk/javadoc/doclet/testTypeAnnotations/TestTypeAnnotations.java b/test/langtools/jdk/javadoc/doclet/testTypeAnnotations/TestTypeAnnotations.java
--- a/test/langtools/jdk/javadoc/doclet/testTypeAnnotations/TestTypeAnnotations.java
+++ b/test/langtools/jdk/javadoc/doclet/testTypeAnnotations/TestTypeAnnotations.java
@@ -228,29 +228,29 @@
 
         // Test for type annotations on parameters (Parameters.java).
         checkOutput("typeannos/Parameters.html", true,
                 """
                     <div class="member-signature"><span class="return-type">void</span>&nbsp;<span c\
-                    lass="member-name">unannotated</span>&#8203;(<span class="parameters"><a href="P\
+                    lass="member-name">unannotated</span>&#8203;<span class="parameters">(<a href="P\
                     araParameterized.html" title="class in typeannos">ParaParameterized</a>&lt;java.\
                     lang.String,&#8203;java.lang.String&gt;&nbsp;a)</span></div>""",
 
                 """
                     <div class="member-signature"><span class="return-type">void</span>&nbsp;<span c\
-                    lass="member-name">nestedParaParameterized</span>&#8203;(<span class="parameters\
-                    "><a href="ParaParameterized.html" title="class in typeannos">ParaParameterized<\
+                    lass="member-name">nestedParaParameterized</span>&#8203;<span class="parameters\
+                    ">(<a href="ParaParameterized.html" title="class in typeannos">ParaParameterized<\
                     /a>&lt;<a href="ParamA.html" title="annotation in typeannos">@ParamA</a> <a href\
                     ="ParaParameterized.html" title="class in typeannos">ParaParameterized</a>&lt;<a\
                      href="ParamA.html" title="annotation in typeannos">@ParamA</a> java.lang.String\
                     ,&#8203;<a href="ParamB.html" title="annotation in typeannos">@ParamB</a> java.l\
                     ang.String&gt;,&#8203;<a href="ParamB.html" title="annotation in typeannos">@Par\
                     amB</a> java.lang.String&gt;&nbsp;a)</span></div>""",
 
                 // When JDK-8068737 is fixed, we should change the order
                 """
                     <div class="member-signature"><span class="return-type">void</span>&nbsp;<span c\
-                    lass="member-name">array2Deep</span>&#8203;(<span class="parameters"><a href="Pa\
+                    lass="member-name">array2Deep</span>&#8203;<span class="parameters">(<a href="Pa\
                     ramA.html" title="annotation in typeannos">@ParamA</a> java.lang.String <a href=\
                     "ParamB.html" title="annotation in typeannos">@ParamB</a> [] <a href="ParamA.htm\
                     l" title="annotation in typeannos">@ParamA</a> []&nbsp;a)</span></div>""");
 
         // Test for type annotations on throws (Throws.java).
@@ -269,18 +269,18 @@
 
         checkOutput("typeannos/ThrPublicModified.html", true,
                 """
                     <div class="member-signature"><span class="modifiers">public final</span>&nbsp;<\
                     span class="return-type">void</span>&nbsp;<span class="member-name">oneException\
-                    </span>&#8203;(<span class="parameters">java.lang.String&nbsp;a)</span>
+                    </span>&#8203;<span class="parameters">(java.lang.String&nbsp;a)</span>
                                             throws <span class="exceptions"><a href="ThrA.html" titl\
                     e="annotation in typeannos">@ThrA</a> java.lang.Exception</span></div>""",
 
                 """
                     <div class="member-signature"><span class="modifiers">public final</span>&nbsp;<\
                     span class="return-type">void</span>&nbsp;<span class="member-name">twoException\
-                    s</span>&#8203;(<span class="parameters">java.lang.String&nbsp;a)</span>
+                    s</span>&#8203;<span class="parameters">(java.lang.String&nbsp;a)</span>
                                              throws <span class="exceptions"><a href="ThrA.html" tit\
                     le="annotation in typeannos">@ThrA</a> java.lang.RuntimeException,
                     <a href="ThrA.html" title="annotation in typeannos">@ThrA</a> java.lang.Exception</span></div>""");
 
         checkOutput("typeannos/ThrWithValue.html", true,
@@ -308,11 +308,11 @@
 
         // Test for type annotations on wildcard type (Wildcards.java).
         checkOutput("typeannos/BoundTest.html", true,
                 """
                     <div class="member-signature"><span class="return-type">void</span>&nbsp;<span c\
-                    lass="member-name">wcExtends</span>&#8203;(<span class="parameters"><a href="MyL\
+                    lass="member-name">wcExtends</span>&#8203;<span class="parameters">(<a href="MyL\
                     ist.html" title="class in typeannos">MyList</a>&lt;? extends <a href="WldA.html"\
                      title="annotation in typeannos">@WldA</a> java.lang.String&gt;&nbsp;l)</span></\
                     div>""",
 
                 """
@@ -322,11 +322,11 @@
                     r-name">returnWcSuper</span>()</div>""");
 
         checkOutput("typeannos/BoundWithValue.html", true,
                 """
                     <div class="member-signature"><span class="return-type">void</span>&nbsp;<span c\
-                    lass="member-name">wcSuper</span>&#8203;(<span class="parameters"><a href="MyLis\
+                    lass="member-name">wcSuper</span>&#8203;<span class="parameters">(<a href="MyLis\
                     t.html" title="class in typeannos">MyList</a>&lt;? super <a href="WldB.html" tit\
                     le="annotation in typeannos">@WldB</a>("m") java.lang.String&gt;&nbsp;l)</span><\
                     /div>""",
 
                 """
@@ -366,74 +366,74 @@
 
         // Test for receiver annotations (Receivers.java).
         checkOutput("typeannos/DefaultUnmodified.html", true,
                 """
                     <div class="member-signature"><span class="return-type">void</span>&nbsp;<span c\
-                    lass="member-name">withException</span>&#8203;(<span class="parameters"><a href=\
+                    lass="member-name">withException</span>&#8203;<span class="parameters">(<a href=\
                     "RcvrA.html" title="annotation in typeannos">@RcvrA</a>&nbsp;DefaultUnmodified&n\
                     bsp;this)</span>
                                 throws <span class="exceptions">java.lang.Exception</span></div>""",
 
                 """
                     <div class="member-signature"><span class="return-type">java.lang.String</span>&\
-                    nbsp;<span class="member-name">nonVoid</span>&#8203;(<span class="parameters"><a\
+                    nbsp;<span class="member-name">nonVoid</span>&#8203;<span class="parameters">(<a\
                      href="RcvrA.html" title="annotation in typeannos">@RcvrA</a> <a href="RcvrB.htm\
                     l" title="annotation in typeannos">@RcvrB</a>("m")&nbsp;DefaultUnmodified&nbsp;t\
                     his)</span></div>""",
 
                 """
                     <div class="member-signature"><span class="type-parameters">&lt;T extends java.l\
                     ang.Runnable&gt;</span>&nbsp;<span class="return-type">void</span>&nbsp;<span cl\
-                    ass="member-name">accept</span>&#8203;(<span class="parameters"><a href="RcvrA.h\
+                    ass="member-name">accept</span>&#8203;<span class="parameters">(<a href="RcvrA.h\
                     tml" title="annotation in typeannos">@RcvrA</a>&nbsp;DefaultUnmodified&nbsp;this\
                     ,
-                    T&nbsp;r)</span>
+                     T&nbsp;r)</span>
                                                         throws <span class="exceptions">java.lang.Exception</span></div>""");
 
         checkOutput("typeannos/PublicModified.html", true,
                 """
                     <div class="member-signature"><span class="modifiers">public final</span>&nbsp;<\
                     span class="return-type">java.lang.String</span>&nbsp;<span class="member-name">\
-                    nonVoid</span>&#8203;(<span class="parameters"><a href="RcvrA.html" title="annot\
+                    nonVoid</span>&#8203;<span class="parameters">(<a href="RcvrA.html" title="annot\
                     ation in typeannos">@RcvrA</a>&nbsp;PublicModified&nbsp;this)</span></div>""",
 
                 """
                     <div class="member-signature"><span class="modifiers">public final</span>&nbsp;<\
                     span class="type-parameters">&lt;T extends java.lang.Runnable&gt;</span>&nbsp;<s\
                     pan class="return-type">void</span>&nbsp;<span class="member-name">accept</span>\
-                    &#8203;(<span class="parameters"><a href="RcvrA.html" title="annotation in typea\
+                    &#8203;<span class="parameters">(<a href="RcvrA.html" title="annotation in typea\
                     nnos">@RcvrA</a>&nbsp;PublicModified&nbsp;this,
-                    T&nbsp;r)</span>
+                     T&nbsp;r)</span>
                                                                      throws <span class="exceptions">java.lang.Exception</span></div>""");
 
         checkOutput("typeannos/WithValue.html", true,
                 """
                     <div class="member-signature"><span class="type-parameters">&lt;T extends java.l\
                     ang.Runnable&gt;</span>&nbsp;<span class="return-type">void</span>&nbsp;<span cl\
-                    ass="member-name">accept</span>&#8203;(<span class="parameters"><a href="RcvrB.h\
+                    ass="member-name">accept</span>&#8203;<span class="parameters">(<a href="RcvrB.h\
                     tml" title="annotation in typeannos">@RcvrB</a>("m")&nbsp;WithValue&nbsp;this,
-                    T&nbsp;r)</span>
+                     T&nbsp;r)</span>
                                                         throws <span class="exceptions">java.lang.Exception</span></div>""");
 
         checkOutput("typeannos/WithFinal.html", true,
                 """
                     <div class="member-signature"><span class="return-type">java.lang.String</span>&\
-                    nbsp;<span class="member-name">nonVoid</span>&#8203;(<span class="parameters"><a\
+                    nbsp;<span class="member-name">nonVoid</span>&#8203;<span class="parameters">(<a\
                      href="RcvrB.html" title="annotation in typeannos">@RcvrB</a>("m") <a href="With\
                     Final.html" title="class in typeannos">WithFinal</a>&nbsp;afield)</span></div>""");
 
         checkOutput("typeannos/WithBody.html", true,
                 """
                     <div class="member-signature"><span class="return-type">void</span>&nbsp;<span c\
-                    lass="member-name">field</span>&#8203;(<span class="parameters"><a href="RcvrA.h\
+                    lass="member-name">field</span>&#8203;<span class="parameters">(<a href="RcvrA.h\
                     tml" title="annotation in typeannos">@RcvrA</a>&nbsp;WithBody&nbsp;this)</span><\
                     /div>""");
 
         checkOutput("typeannos/Generic2.html", true,
                 """
                     <div class="member-signature"><span class="return-type">void</span>&nbsp;<span c\
-                    lass="member-name">test2</span>&#8203;(<span class="parameters"><a href="RcvrA.h\
+                    lass="member-name">test2</span>&#8203;<span class="parameters">(<a href="RcvrA.h\
                     tml" title="annotation in typeannos">@RcvrA</a>&nbsp;Generic2&lt;X&gt;&nbsp;this\
                     )</span></div>""");
 
 
         // Test for repeated type annotations (RepeatedAnnotations.java).
@@ -482,68 +482,68 @@
                     .html" title="annotation in typeannos">@RepConstructorA</a> <a href="RepConstruc\
                     torA.html" title="annotation in typeannos">@RepConstructorA</a>
                     <a href="RepConstructorB.html" title="annotation in typeannos">@RepConstructorB<\
                     /a> <a href="RepConstructorB.html" title="annotation in typeannos">@RepConstruct\
                     orB</a>
-                    </span><span class="member-name">RepeatingOnConstructor</span>&#8203;(<span class="parameters">int&nbsp;i,
-                    int&nbsp;j)</span></div>""",
+                    </span><span class="member-name">RepeatingOnConstructor</span>&#8203;<span class="parameters">(int&nbsp;i,
+                     int&nbsp;j)</span></div>""",
 
                 """
                     <div class="member-signature"><span class="annotations"><a href="RepAllContextsA\
                     .html" title="annotation in typeannos">@RepAllContextsA</a> <a href="RepAllConte\
                     xtsA.html" title="annotation in typeannos">@RepAllContextsA</a>
                     <a href="RepAllContextsB.html" title="annotation in typeannos">@RepAllContextsB<\
                     /a> <a href="RepAllContextsB.html" title="annotation in typeannos">@RepAllContex\
                     tsB</a>
-                    </span><span class="member-name">RepeatingOnConstructor</span>&#8203;(<span class="parameters">int&nbsp;i,
-                    int&nbsp;j,
-                    int&nbsp;k)</span></div>""",
+                    </span><span class="member-name">RepeatingOnConstructor</span>&#8203;<span class="parameters">(int&nbsp;i,
+                     int&nbsp;j,
+                     int&nbsp;k)</span></div>""",
 
                 """
                     <div class="member-signature"><span class="member-name">RepeatingOnConstructor</\
-                    span>&#8203;(<span class="parameters"><a href="RepParameterA.html" title="annota\
+                    span>&#8203;<span class="parameters">(<a href="RepParameterA.html" title="annota\
                     tion in typeannos">@RepParameterA</a> <a href="RepParameterA.html" title="annota\
                     tion in typeannos">@RepParameterA</a> <a href="RepParameterB.html" title="annota\
                     tion in typeannos">@RepParameterB</a> <a href="RepParameterB.html" title="annota\
                     tion in typeannos">@RepParameterB</a>
-                    java.lang.String&nbsp;parameter,
-                    <a href="RepParameterA.html" title="annotation in typeannos">@RepParameterA</a> \
+                     java.lang.String&nbsp;parameter,
+                     <a href="RepParameterA.html" title="annotation in typeannos">@RepParameterA</a> \
                     <a href="RepParameterA.html" title="annotation in typeannos">@RepParameterA</a> \
                     <a href="RepParameterB.html" title="annotation in typeannos">@RepParameterB</a> \
                     <a href="RepParameterB.html" title="annotation in typeannos">@RepParameterB</a>
-                    java.lang.String <a href="RepTypeUseA.html" title="annotation in typeannos">@Rep\
+                     java.lang.String <a href="RepTypeUseA.html" title="annotation in typeannos">@Rep\
                     TypeUseA</a> <a href="RepTypeUseA.html" title="annotation in typeannos">@RepType\
                     UseA</a> <a href="RepTypeUseB.html" title="annotation in typeannos">@RepTypeUseB\
                     </a> <a href="RepTypeUseB.html" title="annotation in typeannos">@RepTypeUseB</a>\
                      ...&nbsp;vararg)</span></div>"""
         );
 
         checkOutput("typeannos/RepeatingOnConstructor.Inner.html", true,
                 """
                     <code><span class="member-name-link"><a href="#%3Cinit%3E(java.lang.String,java.\
                     lang.String...)">Inner</a></span>&#8203;(java.lang.String&nbsp;parameter,
-                    java.lang.String <a href="RepTypeUseA.html" title="annotation in typeannos">@Rep\
+                     java.lang.String <a href="RepTypeUseA.html" title="annotation in typeannos">@Rep\
                     TypeUseA</a> <a href="RepTypeUseA.html" title="annotation in typeannos">@RepType\
                     UseA</a> <a href="RepTypeUseB.html" title="annotation in typeannos">@RepTypeUseB\
                     </a> <a href="RepTypeUseB.html" title="annotation in typeannos">@RepTypeUseB</a>\
                      ...&nbsp;vararg)</code>""",
                 """
-                    Inner</span>&#8203;(<span class="parameters"><a href="RepTypeUseA.html" title="a\
+                    Inner</span>&#8203;<span class="parameters">(<a href="RepTypeUseA.html" title="a\
                     nnotation in typeannos">@RepTypeUseA</a> <a href="RepTypeUseA.html" title="annot\
                     ation in typeannos">@RepTypeUseA</a> <a href="RepTypeUseB.html" title="annotatio\
                     n in typeannos">@RepTypeUseB</a> <a href="RepTypeUseB.html" title="annotation in\
                      typeannos">@RepTypeUseB</a>&nbsp;RepeatingOnConstructor&nbsp;this,
-                    <a href="RepParameterA.html" title="annotation in typeannos">@RepParameterA</a> \
+                     <a href="RepParameterA.html" title="annotation in typeannos">@RepParameterA</a> \
                     <a href="RepParameterA.html" title="annotation in typeannos">@RepParameterA</a> \
                     <a href="RepParameterB.html" title="annotation in typeannos">@RepParameterB</a> \
                     <a href="RepParameterB.html" title="annotation in typeannos">@RepParameterB</a>
-                    java.lang.String&nbsp;parameter,
-                    <a href="RepParameterA.html" title="annotation in typeannos">@RepParameterA</a> \
+                     java.lang.String&nbsp;parameter,
+                     <a href="RepParameterA.html" title="annotation in typeannos">@RepParameterA</a> \
                     <a href="RepParameterA.html" title="annotation in typeannos">@RepParameterA</a> \
                     <a href="RepParameterB.html" title="annotation in typeannos">@RepParameterB</a> \
                     <a href="RepParameterB.html" title="annotation in typeannos">@RepParameterB</a>
-                    java.lang.String <a href="RepTypeUseA.html" title="annotation in typeannos">@Rep\
+                     java.lang.String <a href="RepTypeUseA.html" title="annotation in typeannos">@Rep\
                     TypeUseA</a> <a href="RepTypeUseA.html" title="annotation in typeannos">@RepType\
                     UseA</a> <a href="RepTypeUseB.html" title="annotation in typeannos">@RepTypeUseB\
                     </a> <a href="RepTypeUseB.html" title="annotation in typeannos">@RepTypeUseB</a>\
                      ...&nbsp;vararg)</span>""");
 
@@ -673,11 +673,11 @@
                     <th class="col-second" scope="row"><code><span class="member-name-link"><a href="#test4()">test4</a></span>()</code>""",
 
                 """
                     <code><span class="member-name-link"><a href="#test5(java.lang.String,java.lang.\
                     String...)">test5</a></span>&#8203;(java.lang.String&nbsp;parameter,
-                    java.lang.String <a href="RepTypeUseA.html" title="annotation in typeannos">@Rep\
+                     java.lang.String <a href="RepTypeUseA.html" title="annotation in typeannos">@Rep\
                     TypeUseA</a> <a href="RepTypeUseA.html" title="annotation in typeannos">@RepType\
                     UseA</a> <a href="RepTypeUseB.html" title="annotation in typeannos">@RepTypeUseB\
                     </a> <a href="RepTypeUseB.html" title="annotation in typeannos">@RepTypeUseB</a>\
                      ...&nbsp;vararg)</code>""",
 
@@ -720,26 +720,26 @@
                     nnotation in typeannos">@RepAllContextsB</a> <a href="RepAllContextsB.html" titl\
                     e="annotation in typeannos">@RepAllContextsB</a> java.lang.String</span>&nbsp;<s\
                     pan class="member-name">test4</span>()""",
 
                 """
-                    java.lang.String</span>&nbsp;<span class="member-name">test5</span>&#8203;(<span\
-                     class="parameters"><a href="RepTypeUseA.html" title="annotation in typeannos">@\
+                    java.lang.String</span>&nbsp;<span class="member-name">test5</span>&#8203;<span\
+                     class="parameters">(<a href="RepTypeUseA.html" title="annotation in typeannos">@\
                     RepTypeUseA</a> <a href="RepTypeUseA.html" title="annotation in typeannos">@RepT\
                     ypeUseA</a> <a href="RepTypeUseB.html" title="annotation in typeannos">@RepTypeU\
                     seB</a> <a href="RepTypeUseB.html" title="annotation in typeannos">@RepTypeUseB<\
                     /a>&nbsp;RepeatingOnMethod&nbsp;this,
-                    <a href="RepParameterA.html" title="annotation in typeannos">@RepParameterA</a> \
+                     <a href="RepParameterA.html" title="annotation in typeannos">@RepParameterA</a> \
                     <a href="RepParameterA.html" title="annotation in typeannos">@RepParameterA</a> \
                     <a href="RepParameterB.html" title="annotation in typeannos">@RepParameterB</a> \
                     <a href="RepParameterB.html" title="annotation in typeannos">@RepParameterB</a>
-                    java.lang.String&nbsp;parameter,
-                    <a href="RepParameterA.html" title="annotation in typeannos">@RepParameterA</a> \
+                     java.lang.String&nbsp;parameter,
+                     <a href="RepParameterA.html" title="annotation in typeannos">@RepParameterA</a> \
                     <a href="RepParameterA.html" title="annotation in typeannos">@RepParameterA</a> \
                     <a href="RepParameterB.html" title="annotation in typeannos">@RepParameterB</a> \
                     <a href="RepParameterB.html" title="annotation in typeannos">@RepParameterB</a>
-                    java.lang.String <a href="RepTypeUseA.html" title="annotation in typeannos">@Rep\
+                     java.lang.String <a href="RepTypeUseA.html" title="annotation in typeannos">@Rep\
                     TypeUseA</a> <a href="RepTypeUseA.html" title="annotation in typeannos">@RepType\
                     UseA</a> <a href="RepTypeUseB.html" title="annotation in typeannos">@RepTypeUseB\
                     </a> <a href="RepTypeUseB.html" title="annotation in typeannos">@RepTypeUseB</a>\
                      ...&nbsp;vararg)""");
 
@@ -762,11 +762,11 @@
                     <code>(package private) java.lang.String</code></td>
                     <th class="col-second" scope="row"><code><span class="member-name-link"><a href="#test()">test</a></span>()</code>""",
 
                 """
                     <span class="return-type">java.lang.String</span>&nbsp;<span class="member-name"\
-                    >test</span>&#8203;(<span class="parameters"><a href="RepTypeUseA.html" title="a\
+                    >test</span>&#8203;<span class="parameters">(<a href="RepTypeUseA.html" title="a\
                     nnotation in typeannos">@RepTypeUseA</a> <a href="RepTypeUseA.html" title="annot\
                     ation in typeannos">@RepTypeUseA</a> <a href="RepTypeUseB.html" title="annotatio\
                     n in typeannos">@RepTypeUseB</a> <a href="RepTypeUseB.html" title="annotation in\
                      typeannos">@RepTypeUseB</a>&nbsp;RepeatingOnTypeParametersBoundsTypeArgumentsOn\
                     Method&lt;<a href="RepTypeUseA.html" title="annotation in typeannos">@RepTypeUse\
diff a/test/langtools/tools/javac/api/TestGetScopeResult.java b/test/langtools/tools/javac/api/TestGetScopeResult.java
--- a/test/langtools/tools/javac/api/TestGetScopeResult.java
+++ b/test/langtools/tools/javac/api/TestGetScopeResult.java
@@ -21,21 +21,22 @@
  * questions.
  */
 
 /*
  * @test
- * @bug 8205418 8207229 8207230 8230847 8245786 8247334
+ * @bug 8205418 8207229 8207230 8230847 8245786 8247334 8248641
  * @summary Test the outcomes from Trees.getScope
  * @modules jdk.compiler/com.sun.tools.javac.api
  *          jdk.compiler/com.sun.tools.javac.comp
  *          jdk.compiler/com.sun.tools.javac.tree
  *          jdk.compiler/com.sun.tools.javac.util
  */
 
 import java.io.IOException;
 import java.net.URI;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 import javax.lang.model.element.Element;
 import javax.tools.JavaCompiler;
 import javax.tools.SimpleJavaFileObject;
@@ -58,15 +59,18 @@
 import com.sun.source.util.TaskEvent;
 import com.sun.source.util.TaskListener;
 import com.sun.source.util.TreePath;
 import com.sun.source.util.TreePathScanner;
 import com.sun.source.util.Trees;
+import com.sun.tools.javac.api.JavacScope;
 
 import com.sun.tools.javac.api.JavacTool;
 import com.sun.tools.javac.comp.Analyzer;
 import com.sun.tools.javac.comp.AttrContext;
 import com.sun.tools.javac.comp.Env;
+import com.sun.tools.javac.tree.JCTree;
+import com.sun.tools.javac.tree.JCTree.JCCase;
 import com.sun.tools.javac.tree.JCTree.JCStatement;
 import com.sun.tools.javac.util.Context;
 import com.sun.tools.javac.util.Context.Factory;
 
 import static javax.tools.JavaFileObject.Kind.SOURCE;
@@ -80,10 +84,11 @@
         new TestGetScopeResult().testAnnotations();
         new TestGetScopeResult().testAnnotationsLazy();
         new TestGetScopeResult().testCircular();
         new TestGetScopeResult().testRecord();
         new TestGetScopeResult().testLocalRecordAnnotation();
+        new TestGetScopeResult().testRuleCases();
     }
 
     public void run() throws IOException {
         String[] simpleLambda = {
             "s:java.lang.String",
@@ -634,10 +639,107 @@
                 }
             }
         }
     }
 
+    void testRuleCases() throws IOException {
+        JavacTool c = JavacTool.create();
+        try (StandardJavaFileManager fm = c.getStandardFileManager(null, null, null)) {
+            String code = """
+                          class Test {
+                              void t(int i) {
+                                  long local;
+                                  System.err.println(switch (i) {
+                                    case 0 -> {
+                                        String var;
+                                        int scopeHere;
+                                        yield "";
+                                    }
+                                    default -> {
+                                        String var;
+                                        int scopeHere;
+                                        yield "";
+                                    }
+                                  });
+                                  switch (i) {
+                                    case 0 -> {
+                                        String var;
+                                        int scopeHere;
+                                    }
+                                    default -> {
+                                        String var;
+                                        int scopeHere;
+                                    }
+                                  };
+                                  switch (i) {
+                                    case 0: {
+                                        int checkTree;
+                                    }
+                                  }
+                              }
+                          }
+                          """;
+            class MyFileObject extends SimpleJavaFileObject {
+                MyFileObject() {
+                    super(URI.create("myfo:///Test.java"), SOURCE);
+                }
+                @Override
+                public String getCharContent(boolean ignoreEncodingErrors) {
+                    return code;
+                }
+            }
+            Context ctx = new Context();
+            TestAnalyzer.preRegister(ctx);
+            List<String> options = List.of("--enable-preview",
+                                           "-source", System.getProperty("java.specification.version"));
+            JavacTask t = (JavacTask) c.getTask(null, fm, null, options, null,
+                                                List.of(new MyFileObject()), ctx);
+            CompilationUnitTree cut = t.parse().iterator().next();
+            t.analyze();
+
+            List<List<String>> actual = new ArrayList<>();
+
+            new TreePathScanner<Void, Void>() {
+                @Override
+                public Void visitVariable(VariableTree node, Void p) {
+                    if (node.getName().contentEquals("scopeHere")) {
+                        Scope scope = Trees.instance(t).getScope(getCurrentPath());
+                        actual.add(dumpScope(scope));
+                        JCTree body = getCaseBody(scope);
+                        if (body == null) {
+                            throw new AssertionError("Unexpected null body.");
+                        }
+                    } else if (node.getName().contentEquals("checkTree")) {
+                        Scope scope = Trees.instance(t).getScope(getCurrentPath());
+                        JCTree body = getCaseBody(scope);
+                        if (body != null) {
+                            throw new AssertionError("Unexpected body tree: " + body);
+                        }
+                    }
+                    return super.visitVariable(node, p);
+                }
+                JCTree getCaseBody(Scope scope) {
+                    return ((JCCase) ((JavacScope) scope).getEnv().next.next.tree).body;
+                }
+            }.scan(cut, null);
+
+            List<List<String>> expected =
+                    Collections.nCopies(4,
+                                        List.of("scopeHere:int",
+                                                "var:java.lang.String",
+                                                "local:long",
+                                                "i:int",
+                                                "super:java.lang.Object",
+                                                "this:Test"
+                                            ));
+
+            if (!expected.equals(actual)) {
+                throw new AssertionError("Unexpected Scope content: " + actual);
+            }
+        }
+    }
+
     private List<String> dumpScope(Scope scope) {
         List<String> content = new ArrayList<>();
         while (scope.getEnclosingClass() != null) {
             for (Element el : scope.getLocalElements()) {
                 content.add(el.getSimpleName() + ":" +el.asType().toString());
diff a/test/langtools/tools/javac/lambda/methodReference/MethodRefStuck8249261.java b/test/langtools/tools/javac/lambda/methodReference/MethodRefStuck8249261.java
--- /dev/null
+++ b/test/langtools/tools/javac/lambda/methodReference/MethodRefStuck8249261.java
@@ -0,0 +1,30 @@
+/*
+ * @test /nodynamiccopyright/
+ * @bug 8249261
+ * @summary Verify method references as conditions to conditional expressions
+ *          are handled properly.
+ * @compile/fail/ref=MethodRefStuck8249261.out -XDrawDiagnostics MethodRefStuck8249261.java
+ */
+class MethodRefStuck8249261 {
+
+    void p(int padding) {}
+
+    static boolean t() {
+        return true;
+    }
+
+    private void test() {
+        p(MethodRefStuck8249261::t);
+        p((MethodRefStuck8249261::t));
+        p(MethodRefStuck8249261::t + 1);
+        p(MethodRefStuck8249261::t ? 1 : 0);
+        p(true ? MethodRefStuck8249261::t : 0);
+        p(switch (MethodRefStuck8249261::t) { default -> 0; });
+        p(() -> true);
+        p((() -> true));
+        p((() -> true) + 1);
+        p((() -> true) ? 1 : 0);
+        p(true ? (() -> true) : 0);
+        p(switch ((() -> true)) { default -> 0; });
+  }
+}
diff a/test/langtools/tools/javac/lambda/methodReference/MethodRefStuck8249261.out b/test/langtools/tools/javac/lambda/methodReference/MethodRefStuck8249261.out
--- /dev/null
+++ b/test/langtools/tools/javac/lambda/methodReference/MethodRefStuck8249261.out
@@ -0,0 +1,13 @@
+MethodRefStuck8249261.java:17:9: compiler.err.cant.apply.symbol: kindname.method, p, int, @11, kindname.class, MethodRefStuck8249261, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.not.a.functional.intf: int))
+MethodRefStuck8249261.java:18:9: compiler.err.cant.apply.symbol: kindname.method, p, int, @11, kindname.class, MethodRefStuck8249261, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.not.a.functional.intf: int))
+MethodRefStuck8249261.java:19:11: compiler.err.unexpected.mref
+MethodRefStuck8249261.java:20:11: compiler.err.prob.found.req: (compiler.misc.not.a.functional.intf: boolean)
+MethodRefStuck8249261.java:21:9: compiler.err.cant.apply.symbol: kindname.method, p, int, @16, kindname.class, MethodRefStuck8249261, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.incompatible.type.in.conditional: (compiler.misc.not.a.functional.intf: int)))
+MethodRefStuck8249261.java:22:19: compiler.err.unexpected.mref
+MethodRefStuck8249261.java:23:9: compiler.err.cant.apply.symbol: kindname.method, p, int, @11, kindname.class, MethodRefStuck8249261, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.not.a.functional.intf: int))
+MethodRefStuck8249261.java:24:9: compiler.err.cant.apply.symbol: kindname.method, p, int, @11, kindname.class, MethodRefStuck8249261, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.not.a.functional.intf: int))
+MethodRefStuck8249261.java:25:12: compiler.err.unexpected.lambda
+MethodRefStuck8249261.java:26:12: compiler.err.prob.found.req: (compiler.misc.not.a.functional.intf: boolean)
+MethodRefStuck8249261.java:27:9: compiler.err.cant.apply.symbol: kindname.method, p, int, @16, kindname.class, MethodRefStuck8249261, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.incompatible.type.in.conditional: (compiler.misc.not.a.functional.intf: int)))
+MethodRefStuck8249261.java:28:20: compiler.err.unexpected.lambda
+12 errors
diff a/test/langtools/tools/javac/records/RecordCompilationTests.java b/test/langtools/tools/javac/records/RecordCompilationTests.java
--- a/test/langtools/tools/javac/records/RecordCompilationTests.java
+++ b/test/langtools/tools/javac/records/RecordCompilationTests.java
@@ -798,10 +798,52 @@
                         static record RR(int x) { };
                     }
                 }
                 """
         );
+
+        // positive cases
+        assertOK(
+                """
+                import java.security.*;
+                class Test {
+                    static Test newInstance(Object provider) {
+                        return new Test() {
+                            private final PrivilegedExceptionAction<KeyStore> action = new PrivilegedExceptionAction<KeyStore>() {
+                                public KeyStore run() throws Exception {
+                                    if (provider == null) {}
+                                    return null;
+                                }
+                            };
+                        };
+                    }
+                }
+                """
+        );
+
+        assertOK(
+                """
+                import java.security.*;
+                class Test {
+                    static Test newInstance(Object provider) {
+                        return new Test() {
+                            int m(PrivilegedExceptionAction<KeyStore> a) { return 0; }
+                            {
+                                m(
+                                    new PrivilegedExceptionAction<KeyStore>() {
+                                        public KeyStore run() throws Exception {
+                                            if (provider == null) {}
+                                            return null;
+                                        }
+                                    }
+                                );
+                            }
+                        };
+                    }
+                }
+                """
+        );
     }
 
     public void testReturnInCanonical_Compact() {
         assertFail("compiler.err.invalid.canonical.constructor.in.record", "record R(int x) { # }",
                 "public R { return; }");
@@ -1561,6 +1603,39 @@
                     }
                 }
                 """
         );
     }
+
+    public void testNoNPEStaticAnnotatedFields() {
+        assertOK(
+                """
+                import java.lang.annotation.Native;
+                record R() {
+                    @Native public static final int i = 0;
+                }
+                """
+        );
+        assertOK(
+                """
+                import java.lang.annotation.Native;
+                class Outer {
+                    record R() {
+                        @Native public static final int i = 0;
+                    }
+                }
+                """
+        );
+        assertOK(
+                """
+                import java.lang.annotation.Native;
+                class Outer {
+                    void m() {
+                        record R () {
+                            @Native public static final int i = 0;
+                        }
+                    }
+                }
+                """
+        );
+    }
 }
diff a/test/micro/org/openjdk/bench/vm/compiler/SkipIntToLongCast.java b/test/micro/org/openjdk/bench/vm/compiler/SkipIntToLongCast.java
--- a/test/micro/org/openjdk/bench/vm/compiler/SkipIntToLongCast.java
+++ b/test/micro/org/openjdk/bench/vm/compiler/SkipIntToLongCast.java
@@ -45,10 +45,11 @@
 public class SkipIntToLongCast {
 
     private static final long ARRAYSIZE_L = 40L;
 
     public int[] intValues;
+    public int intValue;
 
     @Setup
     public void setup() {
         int size = (int)ARRAYSIZE_L;
         intValues = new int[size];
@@ -74,6 +75,15 @@
                 return i;
             }
         }
         return 0;
     }
+
+    @Benchmark
+    public long skipMaskedSmallPositiveCast() {
+        int value = intValue;
+        return (long)(value & 0x1)    ^ (long)(value & 0x3)    ^ (long)(value & 0x7)    ^ (long)(value & 0xF)   ^
+               (long)(value & 0x1F)   ^ (long)(value & 0x3F)   ^ (long)(value & 0x7F)   ^ (long)(value & 0xFF)  ^
+               (long)(value & 0x1FF)  ^ (long)(value & 0x3FF)  ^ (long)(value & 0x7FF)  ^ (long)(value & 0xFFF) ^
+               (long)(value & 0x1FFF) ^ (long)(value & 0x3FFF) ^ (long)(value & 0x7FFF) ^ (long)(value & 0xFFFF);
+    }
 }
