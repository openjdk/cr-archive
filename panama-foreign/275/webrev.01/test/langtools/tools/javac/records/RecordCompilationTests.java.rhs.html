<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/tools/javac/records/RecordCompilationTests.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /**
  27  * RecordCompilationTests
  28  *
  29  * @test
  30  * @summary Negative compilation tests, and positive compilation (smoke) tests for records
  31  * @library /lib/combo /tools/lib /tools/javac/lib
  32  * @modules
  33  *      jdk.compiler/com.sun.tools.javac.api
  34  *      jdk.compiler/com.sun.tools.javac.code
  35  *      jdk.compiler/com.sun.tools.javac.util
  36  *      jdk.jdeps/com.sun.tools.classfile
  37  * @build JavacTestingAbstractProcessor
  38  * @compile --enable-preview -source ${jdk.version} RecordCompilationTests.java
  39  * @run testng/othervm -DuseAP=false --enable-preview RecordCompilationTests
  40  * @run testng/othervm -DuseAP=true --enable-preview RecordCompilationTests
  41  */
  42 
  43 import java.io.File;
  44 
  45 import java.lang.annotation.ElementType;
  46 import java.util.Arrays;
  47 import java.util.EnumMap;
  48 import java.util.EnumSet;
  49 import java.util.HashSet;
  50 import java.util.List;
  51 import java.util.Map;
  52 import java.util.Set;
  53 import java.util.stream.Collectors;
  54 import java.util.stream.Stream;
  55 
  56 
  57 import com.sun.tools.javac.util.Assert;
  58 
  59 import javax.annotation.processing.AbstractProcessor;
  60 import javax.annotation.processing.RoundEnvironment;
  61 import javax.annotation.processing.SupportedAnnotationTypes;
  62 
  63 import javax.lang.model.element.AnnotationMirror;
  64 import javax.lang.model.element.AnnotationValue;
  65 import javax.lang.model.element.Element;
  66 import javax.lang.model.element.ElementKind;
  67 import javax.lang.model.element.ExecutableElement;
  68 import javax.lang.model.element.RecordComponentElement;
  69 import javax.lang.model.element.TypeElement;
  70 import javax.lang.model.element.VariableElement;
  71 
  72 import javax.lang.model.type.ArrayType;
  73 import javax.lang.model.type.TypeMirror;
  74 
  75 import com.sun.tools.classfile.AccessFlags;
  76 import com.sun.tools.classfile.Annotation;
  77 import com.sun.tools.classfile.Attribute;
  78 import com.sun.tools.classfile.Attributes;
  79 import com.sun.tools.classfile.ClassFile;
  80 import com.sun.tools.classfile.Code_attribute;
  81 import com.sun.tools.classfile.ConstantPool;
  82 import com.sun.tools.classfile.ConstantPool.CONSTANT_Fieldref_info;
  83 import com.sun.tools.classfile.ConstantPool.CPInfo;
  84 import com.sun.tools.classfile.Field;
  85 import com.sun.tools.classfile.Instruction;
  86 import com.sun.tools.classfile.Method;
  87 import com.sun.tools.classfile.Record_attribute;
  88 import com.sun.tools.classfile.Record_attribute.ComponentInfo;
  89 import com.sun.tools.classfile.RuntimeAnnotations_attribute;
  90 import com.sun.tools.classfile.RuntimeTypeAnnotations_attribute;
  91 import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;
  92 import com.sun.tools.classfile.RuntimeVisibleParameterAnnotations_attribute;
  93 import com.sun.tools.classfile.RuntimeVisibleTypeAnnotations_attribute;
  94 import com.sun.tools.classfile.TypeAnnotation;
  95 
  96 import com.sun.tools.javac.api.ClientCodeWrapper.DiagnosticSourceUnwrapper;
  97 import com.sun.tools.javac.code.Attribute.TypeCompound;
  98 import com.sun.tools.javac.code.Symbol;
  99 import com.sun.tools.javac.code.Symbol.VarSymbol;
 100 import com.sun.tools.javac.util.JCDiagnostic;
 101 
 102 import org.testng.annotations.Test;
 103 import tools.javac.combo.CompilationTestCase;
 104 
 105 import static java.lang.annotation.ElementType.*;
 106 import static org.testng.Assert.assertEquals;
 107 
 108 /** Records are the first feature which sports automatic injection of (declarative and type) annotations : from a
 109  *  given record component to one or more record members, if applicable.
 110  *  This implies that the record&#39;s implementation can be stressed with the presence of annotation processors. Which is
 111  *  something the implementator could easily skip. For this reason this test is executed twice, once without the
 112  *  presence of any annotation processor and one with a simple annotation processor (which does not annotation processing
 113  *  at all) just to force at least a round of annotation processing.
 114  *
 115  *  Tests needing special compilation options need to store current options, set its customs options by invoking method
 116  *  `setCompileOptions` and then reset the previous compilation options for other tests. To see an example of this check
 117  *  method: testAnnos()
 118  */
 119 
 120 @Test
 121 public class RecordCompilationTests extends CompilationTestCase {
 122     // @@@ When records become a permanent feature, we don&#39;t need these any more
 123     private static String[] PREVIEW_OPTIONS = {
 124             &quot;--enable-preview&quot;,
 125             &quot;-source&quot;, Integer.toString(Runtime.version().feature())
 126     };
 127 
 128     private static String[] PREVIEW_OPTIONS_WITH_AP = {
 129             &quot;--enable-preview&quot;,
 130             &quot;-source&quot;, Integer.toString(Runtime.version().feature()),
 131             &quot;-processor&quot;, SimplestAP.class.getName()
 132     };
 133 
 134     private static final List&lt;String&gt; BAD_COMPONENT_NAMES = List.of(
 135             &quot;clone&quot;, &quot;finalize&quot;, &quot;getClass&quot;, &quot;hashCode&quot;,
 136             &quot;notify&quot;, &quot;notifyAll&quot;, &quot;toString&quot;, &quot;wait&quot;);
 137 
 138     /* simplest annotation processor just to force a round of annotation processing for all tests
 139      */
 140     @SupportedAnnotationTypes(&quot;*&quot;)
 141     public static class SimplestAP extends AbstractProcessor {
 142         @Override
 143         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
 144             return true;
 145         }
 146     }
 147 
 148     public RecordCompilationTests() {
 149         boolean useAP = System.getProperty(&quot;useAP&quot;) == null ? false : System.getProperty(&quot;useAP&quot;).equals(&quot;true&quot;);
 150         setDefaultFilename(&quot;R.java&quot;);
 151         setCompileOptions(useAP ? PREVIEW_OPTIONS_WITH_AP : PREVIEW_OPTIONS);
 152         System.out.println(useAP ? &quot;running all tests using an annotation processor&quot; : &quot;running all tests without annotation processor&quot;);
 153     }
 154 
 155     public void testMalformedDeclarations() {
 156         assertFail(&quot;compiler.err.premature.eof&quot;, &quot;record R()&quot;);
 157         assertFail(&quot;compiler.err.premature.eof&quot;, &quot;record R();&quot;);
 158         assertFail(&quot;compiler.err.illegal.start.of.type&quot;, &quot;record R(,) { }&quot;);
 159         assertFail(&quot;compiler.err.illegal.start.of.type&quot;, &quot;record R((int x)) { }&quot;);
 160         assertFail(&quot;compiler.err.record.header.expected&quot;, &quot;record R { }&quot;);
 161         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(foo) { }&quot;);
 162         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int int) { }&quot;);
 163         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;abstract record R(String foo) { }&quot;);
 164         //assertFail(&quot;compiler.err.illegal.combination.of.modifiers&quot;, &quot;non-sealed record R(String foo) { }&quot;);
 165         assertFail(&quot;compiler.err.repeated.modifier&quot;, &quot;public public record R(String foo) { }&quot;);
 166         assertFail(&quot;compiler.err.repeated.modifier&quot;, &quot;private private record R(String foo) { }&quot;);
 167         assertFail(&quot;compiler.err.already.defined&quot;, &quot;record R(int x, int x) {}&quot;);
 168         for (String s : List.of(&quot;var&quot;, &quot;record&quot;))
 169             assertFail(&quot;compiler.err.restricted.type.not.allowed.here&quot;, &quot;record R(# x) { }&quot;, s);
 170         for (String s : List.of(&quot;public&quot;, &quot;protected&quot;, &quot;private&quot;, &quot;static&quot;, &quot;final&quot;, &quot;transient&quot;, &quot;volatile&quot;,
 171                 &quot;abstract&quot;, &quot;synchronized&quot;, &quot;native&quot;, &quot;strictfp&quot;)) // missing: sealed and non-sealed
 172             assertFail(&quot;compiler.err.record.cant.declare.field.modifiers&quot;, &quot;record R(# String foo) { }&quot;, s);
 173         assertFail(&quot;compiler.err.varargs.must.be.last&quot;, &quot;record R(int... x, int... y) {}&quot;);
 174         assertFail(&quot;compiler.err.instance.initializer.not.allowed.in.records&quot;, &quot;record R(int i) { {} }&quot;);
 175     }
 176 
 177     public void testGoodDeclarations() {
 178         assertOK(&quot;public record R() { }&quot;);
 179         assertOK(&quot;record R() { }&quot;);
 180         assertOK(&quot;record R() implements java.io.Serializable, Runnable { public void run() { } }&quot;);
 181         assertOK(&quot;record R(int x) { }&quot;);
 182         assertOK(&quot;record R(int x, int y) { }&quot;);
 183         assertOK(&quot;record R(int... xs) { }&quot;);
 184         assertOK(&quot;record R(String... ss) { }&quot;);
 185         assertOK(&quot;@Deprecated record R(int x, int y) { }&quot;);
 186         assertOK(&quot;record R(@Deprecated int x, int y) { }&quot;);
 187         assertOK(&quot;record R&lt;T&gt;(T x, T y) { }&quot;);
 188     }
 189 
 190     public void testGoodMemberDeclarations() {
 191         String template = &quot;public record R(int x) {\n&quot;
 192                 + &quot;    public R(int x) { this.x = x; }\n&quot;
 193                 + &quot;    public int x() { return x; }\n&quot;
 194                 + &quot;    public boolean equals(Object o) { return true; }\n&quot;
 195                 + &quot;    public int hashCode() { return 0; }\n&quot;
 196                 + &quot;    public String toString() { return null; }\n&quot;
 197                 + &quot;}&quot;;
 198         assertOK(template);
 199     }
 200 
 201     public void testBadComponentNames() {
 202         for (String s : BAD_COMPONENT_NAMES)
 203             assertFail(&quot;compiler.err.illegal.record.component.name&quot;, &quot;record R(int #) { } &quot;, s);
 204     }
 205 
 206     public void testRestrictedIdentifiers() {
 207         for (String s : List.of(&quot;interface record { void m(); }&quot;,
 208                 &quot;@interface record { }&quot;,
 209                 &quot;class record { }&quot;,
 210                 &quot;record record(int x) { }&quot;,
 211                 &quot;enum record { A, B }&quot;,
 212                 &quot;class R&lt;record&gt; { }&quot;)) {
 213             assertFail(
 214                     &quot;compiler.err.restricted.type.not.allowed&quot;,
 215                     diagWrapper -&gt; {
 216                         JCDiagnostic diagnostic = ((DiagnosticSourceUnwrapper)diagWrapper).d;
 217                         Object[] args = diagnostic.getArgs();
 218                         Assert.check(args.length == 2);
 219                         Assert.check(args[1].toString().equals(&quot;JDK14&quot;));
 220                     },
 221                     s);
 222         }
 223     }
 224 
 225     public void testValidMembers() {
 226         for (String s : List.of(&quot;record X(int j) { }&quot;,
 227                 &quot;interface I { }&quot;,
 228                 &quot;static { }&quot;,
 229                 &quot;enum E { A, B }&quot;,
 230                 &quot;class C { }&quot;
 231         )) {
 232             assertOK(&quot;record R(int i) { # }&quot;, s);
 233         }
 234     }
 235 
 236     public void testCyclic() {
 237         // Cyclic records are OK, but cyclic inline records would not be
 238         assertOK(&quot;record R(R r) { }&quot;);
 239     }
 240 
 241     public void testBadExtends() {
 242         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int x) extends Object { }&quot;);
 243         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int x) {}\n&quot;
 244                 + &quot;record R2(int x) extends R { }&quot;);
 245         assertFail(&quot;compiler.err.cant.inherit.from.final&quot;, &quot;record R(int x) {}\n&quot;
 246                 + &quot;class C extends R { }&quot;);
 247     }
 248 
 249     public void testNoExtendRecord() {
 250         assertFail(&quot;compiler.err.invalid.supertype.record&quot;,
 251                    &quot;&quot;&quot;
 252                    class R extends Record {
 253                        public String toString() { return null; }
 254                        public int hashCode() { return 0; }
 255                        public boolean equals(Object o) { return false; }
 256                    }
 257                    &quot;&quot;&quot;
 258         );
 259     }
 260 
 261     public void testFieldDeclarations() {
 262         // static fields are OK
 263         assertOK(&quot;public record R(int x) {\n&quot; +
 264                 &quot;    static int I = 1;\n&quot; +
 265                 &quot;    static final String S = \&quot;Hello World!\&quot;;\n&quot; +
 266                 &quot;    static private Object O = null;\n&quot; +
 267                 &quot;    static protected Object O2 = null;\n&quot; +
 268                 &quot;}&quot;);
 269 
 270         // instance fields are not
 271         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
 272                 &quot;public record R(int x) {\n&quot; +
 273                         &quot;    private final int y = 0;&quot; +
 274                         &quot;}&quot;);
 275 
 276         // mutable instance fields definitely not
 277         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
 278                 &quot;public record R(int x) {\n&quot; +
 279                         &quot;    private int y = 0;&quot; +
 280                         &quot;}&quot;);
 281 
 282         // redeclaring components also not
 283         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
 284                 &quot;public record R(int x) {\n&quot; +
 285                         &quot;    private final int x;&quot; +
 286                         &quot;}&quot;);
 287     }
 288 
 289     public void testAccessorRedeclaration() {
 290         assertOK(&quot;public record R(int x) {\n&quot; +
 291                 &quot;    public int x() { return x; };&quot; +
 292                 &quot;}&quot;);
 293 
 294         assertOK(&quot;public record R(int... x) {\n&quot; +
 295                 &quot;    public int[] x() { return x; };&quot; +
 296                 &quot;}&quot;);
 297 
 298         assertOK(&quot;public record R(int x) {\n&quot; +
 299                 &quot;    public final int x() { return 0; };&quot; +
 300                 &quot;}&quot;);
 301 
 302         assertOK(&quot;public record R(int x) {\n&quot; +
 303                 &quot;    public final int x() { return 0; };&quot; +
 304                 &quot;}&quot;);
 305 
 306         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 307                 &quot;public record R(int x) {\n&quot; +
 308                         &quot;    final int x() { return 0; };&quot; +
 309                         &quot;}&quot;);
 310 
 311         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 312                 &quot;public record R(int x) {\n&quot; +
 313                         &quot;    int x() { return 0; };&quot; +
 314                         &quot;}&quot;);
 315 
 316         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 317                 &quot;public record R(int x) {\n&quot; +
 318                         &quot;    private int x() { return 0; };&quot; +
 319                         &quot;}&quot;);
 320 
 321         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 322                    &quot;public record R(int x) {\n&quot; +
 323                    &quot;    public int x() throws Exception { return 0; };&quot; +
 324                    &quot;}&quot;);
 325 
 326         for (String s : List.of(&quot;List&quot;, &quot;List&lt;?&gt;&quot;, &quot;Object&quot;, &quot;ArrayList&lt;String&gt;&quot;, &quot;int&quot;))
 327             assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 328                     &quot;import java.util.*;\n&quot; +
 329                             &quot;public record R(List&lt;String&gt; x) {\n&quot; +
 330                             &quot;    public # x() { return null; };&quot; +
 331                             &quot;}&quot;, s);
 332 
 333         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 334                 &quot;public record R(int x) {\n&quot; +
 335                         &quot;    public &lt;T&gt; int x() { return x; };&quot; +
 336                         &quot;}&quot;);
 337 
 338         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 339                 &quot;public record R(int x) {\n&quot; +
 340                         &quot;    static private final j = 0;&quot; +
 341                         &quot;    static public int x() { return j; };&quot; +
 342                         &quot;}&quot;);
 343     }
 344 
 345     public void testConstructorRedeclaration() {
 346         for (String goodCtor : List.of(
 347                 &quot;public R(int x) { this(x, 0); }&quot;,
 348                 &quot;public R(int x, int y) { this.x = x; this.y = y; }&quot;,
 349                 &quot;public R { }&quot;))
 350             assertOK(&quot;record R(int x, int y) { # }&quot;, goodCtor);
 351 
 352         assertOK(&quot;import java.util.*; record R(String x, String y) {  public R { Objects.requireNonNull(x); Objects.requireNonNull(y); } }&quot;);
 353 
 354         // Not OK to redeclare canonical without DA
 355         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;, &quot;record R(int x, int y) { # }&quot;,
 356                    &quot;public R(int x, int y) { this.x = x; }&quot;);
 357 
 358         // Not OK to rearrange or change names
 359         for (String s : List.of(&quot;public R(int y, int x) { this.x = x; this.y = y; }&quot;,
 360                                 &quot;public R(int _x, int _y) { this.x = _x; this.y = _y; }&quot;))
 361             assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x, int y) { # }&quot;, s);
 362 
 363         // ctor args must match types
 364         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 365                 &quot;import java.util.*;\n&quot; +
 366                         &quot;record R(List&lt;String&gt; list) { # }&quot;,
 367                 &quot;R(List list) { this.list = list; }&quot;);
 368 
 369         // canonical ctor should not throw checked exceptions
 370         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 371                    &quot;record R() { # }&quot;,
 372                    &quot;public R() throws Exception { }&quot;);
 373 
 374         // same for compact
 375         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 376                 &quot;record R() { # }&quot;,
 377                 &quot;public R throws Exception { }&quot;);
 378 
 379         // not even unchecked exceptions
 380         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 381                 &quot;record R() { # }&quot;,
 382                  &quot;public R() throws IllegalArgumentException { }&quot;);
 383 
 384         // ditto
 385         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 386                 &quot;record R() { # }&quot;,
 387                 &quot;public R throws IllegalArgumentException { }&quot;);
 388 
 389         // If types match, names must match
 390         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 391                    &quot;record R(int x, int y) { public R(int y, int x) { this.x = this.y = 0; }}&quot;);
 392 
 393         // first invocation should be one to the canonical
 394         assertFail(&quot;compiler.err.first.statement.must.be.call.to.another.constructor&quot;,
 395                 &quot;record R(int x, int y) { public R(int y, int x, int z) { this.x = this.y = 0; } }&quot;);
 396 
 397         assertOK(&quot;record R(int x, int y) { &quot; +
 398                  &quot;    public R(int x, int y, int z) { this(x, y); } &quot; +
 399                  &quot;}&quot;);
 400 
 401         assertOK(&quot;record R(int x) { &quot; +
 402                 &quot;    public R(int x, int y) { this(x, y, 0); } &quot; +
 403                 &quot;    public R(int x, int y, int z) { this(x); } &quot; +
 404                 &quot;}&quot;);
 405 
 406         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 407                 &quot;record R&lt;T&gt;(T a) { # }&quot;,
 408                 &quot;public &lt;T&gt; R {}&quot;);
 409 
 410         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 411                 &quot;record R(int i) { # }&quot;,
 412                 &quot;public &lt;T&gt; R(int i) { this.i = i; }&quot;);
 413 
 414         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 415                 &quot;record R&lt;T&gt;(T a) { # }&quot;,
 416                 &quot;public &lt;T&gt; R(T a) { this.a = a; }&quot;);
 417 
 418         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 419                 &quot;record R(int a) { # }&quot;,
 420                 &quot;public R(int a) { super(); this.a = a; }&quot;);
 421     }
 422 
 423     public void testAnnotationCriteria() {
 424         String imports = &quot;import java.lang.annotation.*;\n&quot;;
 425         String template = &quot;@Target({ # }) @interface A {}\n&quot;;
 426         EnumMap&lt;ElementType, String&gt; annotations = new EnumMap&lt;&gt;(ElementType.class);
 427         for (ElementType e : values())
 428             annotations.put(e, template.replace(&quot;#&quot;, &quot;ElementType.&quot; + e.name()));
 429         EnumSet&lt;ElementType&gt; goodSet = EnumSet.of(RECORD_COMPONENT, FIELD, METHOD, PARAMETER, TYPE_USE);
 430         EnumSet&lt;ElementType&gt; badSet = EnumSet.of(CONSTRUCTOR, PACKAGE, TYPE, LOCAL_VARIABLE, ANNOTATION_TYPE, TYPE_PARAMETER, MODULE);
 431 
 432         assertEquals(goodSet.size() + badSet.size(), values().length);
 433         String A_GOOD = template.replace(&quot;#&quot;,
 434                                          goodSet.stream().map(ElementType::name).map(s -&gt; &quot;ElementType.&quot; + s).collect(Collectors.joining(&quot;,&quot;)));
 435         String A_BAD = template.replace(&quot;#&quot;,
 436                                         badSet.stream().map(ElementType::name).map(s -&gt; &quot;ElementType.&quot; + s).collect(Collectors.joining(&quot;,&quot;)));
 437         String A_ALL = template.replace(&quot;#&quot;,
 438                                         Stream.of(ElementType.values()).map(ElementType::name).map(s -&gt; &quot;ElementType.&quot; + s).collect(Collectors.joining(&quot;,&quot;)));
 439         String A_NONE = &quot;@interface A {}&quot;;
 440 
 441         for (ElementType e : goodSet)
 442             assertOK(imports + annotations.get(e) + &quot;record R(@A int x) { }&quot;);
 443         assertOK(imports + A_GOOD + &quot;record R(@A int x) { }&quot;);
 444         assertOK(imports + A_ALL + &quot;record R(@A int x) { }&quot;);
 445         assertOK(imports + A_NONE);
 446 
 447         for (ElementType e : badSet) {
 448             assertFail(&quot;compiler.err.annotation.type.not.applicable&quot;, imports + annotations.get(e) + &quot;record R(@A int x) { }&quot;);
 449         }
 450 
 451         assertFail(&quot;compiler.err.annotation.type.not.applicable&quot;, imports + A_BAD + &quot;record R(@A int x) { }&quot;);
 452 
 453         // TODO: OK to redeclare with or without same annos
 454     }
 455 
 456     public void testNestedRecords() {
 457         String template = &quot;class R { \n&quot; +
 458                           &quot;    # record RR(int a) { }\n&quot; +
 459                           &quot;}&quot;;
 460 
 461         for (String s : List.of(&quot;&quot;, &quot;static&quot;, &quot;final&quot;,
 462                                 &quot;private&quot;, &quot;public&quot;, &quot;protected&quot;,
 463                                 &quot;private static&quot;, &quot;public static&quot;, &quot;private static final&quot;))
 464             assertOK(template, s);
 465 
 466         for (String s : List.of(&quot;class C { }&quot;,
 467                                 &quot;static class C { }&quot;,
 468                                 &quot;enum X { A; }&quot;,
 469                                 &quot;interface I { }&quot;,
 470                                 &quot;record RR(int y) { }&quot;))
 471             assertOK(&quot;record R(int x) { # }&quot;, s);
 472     }
 473 
 474     public void testDuplicatedMember() {
 475         String template
 476                 = &quot;    record R(int i) {\n&quot; +
 477                   &quot;        public int i() { return i; }\n&quot; +
 478                   &quot;        public int i() { return i; }\n&quot; +
 479                   &quot;    }&quot;;
 480         assertFail(&quot;compiler.err.already.defined&quot;, template);
 481     }
 482 
 483     public void testStaticLocalTypes() {
 484         // local records can also be final
 485         assertOK(&quot;class R { \n&quot; +
 486                 &quot;    void m() { \n&quot; +
 487                 &quot;        final record RR(int x) { };\n&quot; +
 488                 &quot;    }\n&quot; +
 489                 &quot;}&quot;);
 490 
 491         // Can&#39;t capture locals
 492         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 493                 &quot;class R { \n&quot; +
 494                         &quot;    void m(int y) { \n&quot; +
 495                         &quot;        record RR(int x) { public int x() { return y; }};\n&quot; +
 496                         &quot;    }\n&quot; +
 497                         &quot;}&quot;);
 498 
 499         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 500                 &quot;class R { \n&quot; +
 501                         &quot;    void m() {\n&quot; +
 502                         &quot;        int y;\n&quot; +
 503                         &quot;        record RR(int x) { public int x() { return y; }};\n&quot; +
 504                         &quot;    }\n&quot; +
 505                         &quot;}&quot;);
 506 
 507         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 508                 &quot;class C {\n&quot; +
 509                 &quot;    public static void m() {\n&quot; +
 510                 &quot;        String hello = \&quot;hello\&quot;;\n&quot; +
 511                 &quot;        interface I {\n&quot; +
 512                 &quot;            public default void test1() {\n&quot; +
 513                 &quot;                class X {\n&quot; +
 514                 &quot;                    public void test2() {\n&quot; +
 515                 &quot;                        System.err.println(hello);\n&quot; +
 516                 &quot;                    }\n&quot; +
 517                 &quot;                }\n&quot; +
 518                 &quot;            }\n&quot; +
 519                 &quot;        }\n&quot; +
 520                 &quot;    }\n&quot; +
 521                 &quot;}&quot;);
 522 
 523         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 524                 &quot;class C {\n&quot; +
 525                 &quot;    public static void m() {\n&quot; +
 526                 &quot;        String hello = \&quot;hello\&quot;;\n&quot; +
 527                 &quot;        record R(int i) {\n&quot; +
 528                 &quot;            public void test1() {\n&quot; +
 529                 &quot;                class X {\n&quot; +
 530                 &quot;                    public void test2() {\n&quot; +
 531                 &quot;                        System.err.println(hello);\n&quot; +
 532                 &quot;                    }\n&quot; +
 533                 &quot;                }\n&quot; +
 534                 &quot;            }\n&quot; +
 535                 &quot;        }\n&quot; +
 536                 &quot;    }\n&quot; +
 537                 &quot;}&quot;);
 538 
 539         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 540                 &quot;class C {\n&quot; +
 541                 &quot;    public static void m() {\n&quot; +
 542                 &quot;        String hello = \&quot;hello\&quot;;\n&quot; +
 543                 &quot;        enum E {\n&quot; +
 544                 &quot;            A;\n&quot; +
 545                 &quot;            public void test1() {\n&quot; +
 546                 &quot;                class X {\n&quot; +
 547                 &quot;                    public void test2() {\n&quot; +
 548                 &quot;                        System.err.println(hello);\n&quot; +
 549                 &quot;                    }\n&quot; +
 550                 &quot;                }\n&quot; +
 551                 &quot;            }\n&quot; +
 552                 &quot;        }\n&quot; +
 553                 &quot;    }\n&quot; +
 554                 &quot;}&quot;);
 555 
 556         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 557                 &quot;class C {\n&quot; +
 558                 &quot;    public static void m(String param) {\n&quot; +
 559                 &quot;        interface I {\n&quot; +
 560                 &quot;            public default void test1() {\n&quot; +
 561                 &quot;                class X {\n&quot; +
 562                 &quot;                    public void test2() {\n&quot; +
 563                 &quot;                        System.err.println(param);\n&quot; +
 564                 &quot;                    }\n&quot; +
 565                 &quot;                }\n&quot; +
 566                 &quot;            }\n&quot; +
 567                 &quot;        }\n&quot; +
 568                 &quot;    }\n&quot; +
 569                 &quot;}&quot;);
 570 
 571         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 572                 &quot;class C {\n&quot; +
 573                 &quot;    public static void m(String param) {\n&quot; +
 574                 &quot;        record R(int i) {\n&quot; +
 575                 &quot;            public void test1() {\n&quot; +
 576                 &quot;                class X {\n&quot; +
 577                 &quot;                    public void test2() {\n&quot; +
 578                 &quot;                        System.err.println(param);\n&quot; +
 579                 &quot;                    }\n&quot; +
 580                 &quot;                }\n&quot; +
 581                 &quot;            }\n&quot; +
 582                 &quot;        }\n&quot; +
 583                 &quot;    }\n&quot; +
 584                 &quot;}&quot;);
 585 
 586         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 587                 &quot;class C {\n&quot; +
 588                 &quot;    public static void m(String param) {\n&quot; +
 589                 &quot;        enum E {\n&quot; +
 590                 &quot;            A;\n&quot; +
 591                 &quot;            public void test1() {\n&quot; +
 592                 &quot;                class X {\n&quot; +
 593                 &quot;                    public void test2() {\n&quot; +
 594                 &quot;                        System.err.println(param);\n&quot; +
 595                 &quot;                    }\n&quot; +
 596                 &quot;                }\n&quot; +
 597                 &quot;            }\n&quot; +
 598                 &quot;        }\n&quot; +
 599                 &quot;    }\n&quot; +
 600                 &quot;}&quot;);
 601 
 602         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 603                 &quot;class C {\n&quot; +
 604                 &quot;    String instanceField = \&quot;instance\&quot;;\n&quot; +
 605                 &quot;    public static void m() {\n&quot; +
 606                 &quot;        interface I {\n&quot; +
 607                 &quot;            public default void test1() {\n&quot; +
 608                 &quot;                class X {\n&quot; +
 609                 &quot;                    public void test2() {\n&quot; +
 610                 &quot;                        System.err.println(instanceField);\n&quot; +
 611                 &quot;                    }\n&quot; +
 612                 &quot;                }\n&quot; +
 613                 &quot;            }\n&quot; +
 614                 &quot;        }\n&quot; +
 615                 &quot;    }\n&quot; +
 616                 &quot;}&quot;);
 617 
 618         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 619                 &quot;class C {\n&quot; +
 620                 &quot;    String instanceField = \&quot;instance\&quot;;\n&quot; +
 621                 &quot;    public static void m(String param) {\n&quot; +
 622                 &quot;        record R(int i) {\n&quot; +
 623                 &quot;            public void test1() {\n&quot; +
 624                 &quot;                class X {\n&quot; +
 625                 &quot;                    public void test2() {\n&quot; +
 626                 &quot;                        System.err.println(instanceField);\n&quot; +
 627                 &quot;                    }\n&quot; +
 628                 &quot;                }\n&quot; +
 629                 &quot;            }\n&quot; +
 630                 &quot;        }\n&quot; +
 631                 &quot;    }\n&quot; +
 632                 &quot;}&quot;);
 633 
 634         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 635                 &quot;class C {\n&quot; +
 636                 &quot;    String instanceField = \&quot;instance\&quot;;\n&quot; +
 637                 &quot;    public static void m(String param) {\n&quot; +
 638                 &quot;        enum E {\n&quot; +
 639                 &quot;            A;\n&quot; +
 640                 &quot;            public void test1() {\n&quot; +
 641                 &quot;                class X {\n&quot; +
 642                 &quot;                    public void test2() {\n&quot; +
 643                 &quot;                        System.err.println(instanceField);\n&quot; +
 644                 &quot;                    }\n&quot; +
 645                 &quot;                }\n&quot; +
 646                 &quot;            }\n&quot; +
 647                 &quot;        }\n&quot; +
 648                 &quot;    }\n&quot; +
 649                 &quot;}&quot;);
 650 
 651         // instance fields
 652         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 653                 &quot;class R { \n&quot; +
 654                         &quot;    int z = 0;\n&quot; +
 655                         &quot;    void m() { \n&quot; +
 656                         &quot;        record RR(int x) { public int x() { return z; }};\n&quot; +
 657                         &quot;    }\n&quot; +
 658                         &quot;}&quot;);
 659 
 660         // or type variables
 661         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 662                 &quot;class R&lt;T&gt; { \n&quot; +
 663                         &quot;    void m() { \n&quot; +
 664                         &quot;        record RR(T t) {};\n&quot; +
 665                         &quot;    }\n&quot; +
 666                         &quot;}&quot;);
 667 
 668         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 669                 &quot;class R {\n&quot; +
 670                 &quot;    static &lt;U&gt; U make(U u) { //method is static\n&quot; +
 671                 &quot;        interface Checker {\n&quot; +
 672                 &quot;            void check(U u);\n&quot; +
 673                 &quot;        }\n&quot; +
 674                 &quot;        return null;\n&quot; +
 675                 &quot;    }\n&quot; +
 676                 &quot;}&quot;);
 677 
 678         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 679                 &quot;class LocalEnum {\n&quot; +
 680                 &quot;    static &lt;U&gt; U getAndSet(U u) { //method is static\n&quot; +
 681                 &quot;        enum X {\n&quot; +
 682                 &quot;            A;\n&quot; +
 683                 &quot;            U u;\n&quot; +
 684                 &quot;        }\n&quot; +
 685                 &quot;        return null;\n&quot; +
 686                 &quot;    }\n&quot; +
 687                 &quot;}\n&quot;);
 688 
 689         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 690                 &quot;class R {\n&quot; +
 691                 &quot;    static &lt;U&gt; U make(U u) { //method is static\n&quot; +
 692                 &quot;        record Checker() {\n&quot; +
 693                 &quot;            void check(U u);\n&quot; +
 694                 &quot;        }\n&quot; +
 695                 &quot;        return null;\n&quot; +
 696                 &quot;    }\n&quot; +
 697                 &quot;}&quot;);
 698 
 699         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 700                 &quot;class R {\n&quot; +
 701                 &quot;    &lt;U&gt; U make(U u) { // enclosing method is not static\n&quot; +
 702                 &quot;        interface Checker {\n&quot; +
 703                 &quot;            void check(U u);\n&quot; +
 704                 &quot;        }\n&quot; +
 705                 &quot;        return null;\n&quot; +
 706                 &quot;    }\n&quot; +
 707                 &quot;}&quot;);
 708 
 709         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 710                 &quot;class LocalEnum {\n&quot; +
 711                 &quot;    &lt;U&gt; U getAndSet(U u) { // enclosing method is not static\n&quot; +
 712                 &quot;        enum X {\n&quot; +
 713                 &quot;            A;\n&quot; +
 714                 &quot;            U u;\n&quot; +
 715                 &quot;        }\n&quot; +
 716                 &quot;        return null;\n&quot; +
 717                 &quot;    }\n&quot; +
 718                 &quot;}\n&quot;);
 719 
 720         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 721                 &quot;class R {\n&quot; +
 722                 &quot;    &lt;U&gt; U make(U u) { // enclosing method is not static\n&quot; +
 723                 &quot;        record Checker() {\n&quot; +
 724                 &quot;            void check(U u);\n&quot; +
 725                 &quot;        }\n&quot; +
 726                 &quot;        return null;\n&quot; +
 727                 &quot;    }\n&quot; +
 728                 &quot;}&quot;);
 729 
 730         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 731                 &quot;class C {\n&quot; +
 732                 &quot;    public static &lt;T&gt; void main(String[] args) {\n&quot; +
 733                 &quot;        interface I {\n&quot; +
 734                 &quot;            public default void test1() {\n&quot; +
 735                 &quot;                class X {\n&quot; +
 736                 &quot;                    public void test2() {\n&quot; +
 737                 &quot;                        T t = null;\n&quot; +
 738                 &quot;                    }\n&quot; +
 739                 &quot;                }\n&quot; +
 740                 &quot;            }\n&quot; +
 741                 &quot;        }\n&quot; +
 742                 &quot;    }\n&quot; +
 743                 &quot;}&quot;);
 744 
 745         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 746                 &quot;class C {\n&quot; +
 747                 &quot;    public static &lt;T&gt; void main(String[] args) {\n&quot; +
 748                 &quot;        record R(int i) {\n&quot; +
 749                 &quot;            public void test1() {\n&quot; +
 750                 &quot;                class X {\n&quot; +
 751                 &quot;                    public void test2() {\n&quot; +
 752                 &quot;                        T t = null;\n&quot; +
 753                 &quot;                    }\n&quot; +
 754                 &quot;                }\n&quot; +
 755                 &quot;            }\n&quot; +
 756                 &quot;        }\n&quot; +
 757                 &quot;    }\n&quot; +
 758                 &quot;}&quot;);
 759 
 760         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 761                 &quot;class C {\n&quot; +
 762                 &quot;    public static &lt;T&gt; void main(String[] args) {\n&quot; +
 763                 &quot;        enum E {\n&quot; +
 764                 &quot;            A;\n&quot; +
 765                 &quot;            public void test1() {\n&quot; +
 766                 &quot;                class X {\n&quot; +
 767                 &quot;                    public void test2() {\n&quot; +
 768                 &quot;                        T t = null;\n&quot; +
 769                 &quot;                    }\n&quot; +
 770                 &quot;                }\n&quot; +
 771                 &quot;            }\n&quot; +
 772                 &quot;        }\n&quot; +
 773                 &quot;    }\n&quot; +
 774                 &quot;}&quot;);
 775 
 776         // but static fields are OK
 777         assertOK(&quot;class R { \n&quot; +
 778                 &quot;    static int z = 0;\n&quot; +
 779                 &quot;    void m() { \n&quot; +
 780                 &quot;        record RR(int x) { public int x() { return z; }};\n&quot; +
 781                 &quot;    }\n&quot; +
 782                 &quot;}&quot;);
 783         // Can&#39;t self-shadow
 784         assertFail(&quot;compiler.err.already.defined&quot;,
 785                 &quot;&quot;&quot;
 786                 class R {
 787                     void m() {
 788                         record R(int x) { };
 789                     }
 790                 }
 791                 &quot;&quot;&quot;
 792         );
 793         // can&#39;t be explicitly static
 794         assertFail(&quot;compiler.err.illegal.start.of.expr&quot;,
 795                 &quot;&quot;&quot;
 796                 class R {
 797                     void m() {
 798                         static record RR(int x) { };
 799                     }
 800                 }
 801                 &quot;&quot;&quot;
 802         );
<a name="1" id="anc1"></a><span class="line-added"> 803 </span>
<span class="line-added"> 804         // positive cases</span>
<span class="line-added"> 805         assertOK(</span>
<span class="line-added"> 806                 &quot;&quot;&quot;</span>
<span class="line-added"> 807                 import java.security.*;</span>
<span class="line-added"> 808                 class Test {</span>
<span class="line-added"> 809                     static Test newInstance(Object provider) {</span>
<span class="line-added"> 810                         return new Test() {</span>
<span class="line-added"> 811                             private final PrivilegedExceptionAction&lt;KeyStore&gt; action = new PrivilegedExceptionAction&lt;KeyStore&gt;() {</span>
<span class="line-added"> 812                                 public KeyStore run() throws Exception {</span>
<span class="line-added"> 813                                     if (provider == null) {}</span>
<span class="line-added"> 814                                     return null;</span>
<span class="line-added"> 815                                 }</span>
<span class="line-added"> 816                             };</span>
<span class="line-added"> 817                         };</span>
<span class="line-added"> 818                     }</span>
<span class="line-added"> 819                 }</span>
<span class="line-added"> 820                 &quot;&quot;&quot;</span>
<span class="line-added"> 821         );</span>
<span class="line-added"> 822 </span>
<span class="line-added"> 823         assertOK(</span>
<span class="line-added"> 824                 &quot;&quot;&quot;</span>
<span class="line-added"> 825                 import java.security.*;</span>
<span class="line-added"> 826                 class Test {</span>
<span class="line-added"> 827                     static Test newInstance(Object provider) {</span>
<span class="line-added"> 828                         return new Test() {</span>
<span class="line-added"> 829                             int m(PrivilegedExceptionAction&lt;KeyStore&gt; a) { return 0; }</span>
<span class="line-added"> 830                             {</span>
<span class="line-added"> 831                                 m(</span>
<span class="line-added"> 832                                     new PrivilegedExceptionAction&lt;KeyStore&gt;() {</span>
<span class="line-added"> 833                                         public KeyStore run() throws Exception {</span>
<span class="line-added"> 834                                             if (provider == null) {}</span>
<span class="line-added"> 835                                             return null;</span>
<span class="line-added"> 836                                         }</span>
<span class="line-added"> 837                                     }</span>
<span class="line-added"> 838                                 );</span>
<span class="line-added"> 839                             }</span>
<span class="line-added"> 840                         };</span>
<span class="line-added"> 841                     }</span>
<span class="line-added"> 842                 }</span>
<span class="line-added"> 843                 &quot;&quot;&quot;</span>
<span class="line-added"> 844         );</span>
 845     }
 846 
 847     public void testReturnInCanonical_Compact() {
 848         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x) { # }&quot;,
 849                 &quot;public R { return; }&quot;);
 850         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x) { # }&quot;,
 851                 &quot;public R { if (i &lt; 0) { return; }}&quot;);
 852         assertOK(&quot;record R(int x) { public R(int x) { this.x = x; return; } }&quot;);
 853         assertOK(&quot;record R(int x) { public R { Runnable r = () -&gt; { return; };} }&quot;);
 854     }
 855 
 856     public void testArgumentsAreNotFinalInCompact() {
 857         assertOK(
 858                 &quot;&quot;&quot;
 859                 record R(int x) {
 860                     public R {
 861                         x++;
 862                     }
 863                 }
 864                 &quot;&quot;&quot;);
 865     }
 866 
 867     public void testNoNativeMethods() {
 868         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;record R(int x) { # }&quot;,
 869                 &quot;public native R {}&quot;);
 870         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;record R(int x) { # }&quot;,
 871                 &quot;public native void m();&quot;);
 872     }
 873 
 874     public void testRecordsInsideInner() {
 875         assertFail(&quot;compiler.err.static.declaration.not.allowed.in.inner.classes&quot;,
 876                 &quot;&quot;&quot;
 877                 class Outer {
 878                     class Inner {
 879                         record R(int a) {}
 880                     }
 881                 }
 882                 &quot;&quot;&quot;
 883         );
 884         assertFail(&quot;compiler.err.static.declaration.not.allowed.in.inner.classes&quot;,
 885                 &quot;&quot;&quot;
 886                 class Outer {
 887                     public void test() {
 888                         class Inner extends Outer {
 889                             record R(int i) {}
 890                         }
 891                     }
 892                 }
 893                 &quot;&quot;&quot;);
 894         assertFail(&quot;compiler.err.static.declaration.not.allowed.in.inner.classes&quot;,
 895                 &quot;&quot;&quot;
 896                 class Outer {
 897                     Runnable run = new Runnable() {
 898                         record TestRecord(int i) {}
 899                         public void run() {}
 900                     };
 901                 }
 902                 &quot;&quot;&quot;);
 903         assertFail(&quot;compiler.err.static.declaration.not.allowed.in.inner.classes&quot;,
 904                 &quot;&quot;&quot;
 905                 class Outer {
 906                     void m() {
 907                         record A() {
 908                             record B() { }
 909                         }
 910                     }
 911                 }
 912                 &quot;&quot;&quot;);
 913     }
 914 
 915     public void testReceiverParameter() {
 916         assertFail(&quot;compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class&quot;,
 917                 &quot;&quot;&quot;
 918                 record R(int i) {
 919                     public R(R this, int i) {
 920                         this.i = i;
 921                     }
 922                 }
 923                 &quot;&quot;&quot;);
 924         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 925                 &quot;&quot;&quot;
 926                 class Outer {
 927                     record R(int i) {
 928                         public R(Outer Outer.this, int i) {
 929                             this.i = i;
 930                         }
 931                     }
 932                 }
 933                 &quot;&quot;&quot;);
 934         assertOK(
 935                 &quot;&quot;&quot;
 936                 record R(int i) {
 937                     void m(R this) {}
 938                     public int i(R this) { return i; }
 939                 }
 940                 &quot;&quot;&quot;);
 941     }
 942 
 943     public void testOnlyOneFieldRef() throws Exception {
 944         int numberOfFieldRefs = 0;
 945         File dir = assertOK(true, &quot;record R(int recordComponent) {}&quot;);
 946         for (final File fileEntry : dir.listFiles()) {
 947             if (fileEntry.getName().equals(&quot;R.class&quot;)) {
 948                 ClassFile classFile = ClassFile.read(fileEntry);
 949                 for (CPInfo cpInfo : classFile.constant_pool.entries()) {
 950                     if (cpInfo instanceof ConstantPool.CONSTANT_Fieldref_info) {
 951                         numberOfFieldRefs++;
 952                         ConstantPool.CONSTANT_NameAndType_info nameAndType =
 953                                 (ConstantPool.CONSTANT_NameAndType_info)classFile.constant_pool
 954                                         .get(((ConstantPool.CONSTANT_Fieldref_info)cpInfo).name_and_type_index);
 955                         Assert.check(nameAndType.getName().equals(&quot;recordComponent&quot;));
 956                     }
 957                 }
 958             }
 959         }
 960         Assert.check(numberOfFieldRefs == 1);
 961     }
 962 
 963     /*  check that fields are initialized in a canonical constructor in the same declaration order as the corresponding
 964      *  record component
 965      */
 966     public void testCheckInitializationOrderInCompactConstructor() throws Exception {
 967         int putField1 = -1;
 968         int putField2 = -1;
 969         File dir = assertOK(true, &quot;record R(int i, String s) { R {} }&quot;);
 970         for (final File fileEntry : dir.listFiles()) {
 971             if (fileEntry.getName().equals(&quot;R.class&quot;)) {
 972                 ClassFile classFile = ClassFile.read(fileEntry);
 973                 for (Method method : classFile.methods) {
 974                     if (method.getName(classFile.constant_pool).equals(&quot;&lt;init&gt;&quot;)) {
 975                         Code_attribute code_attribute = (Code_attribute) method.attributes.get(&quot;Code&quot;);
 976                         for (Instruction instruction : code_attribute.getInstructions()) {
 977                             if (instruction.getMnemonic().equals(&quot;putfield&quot;)) {
 978                                 if (putField1 != -1 &amp;&amp; putField2 != -1) {
 979                                     throw new AssertionError(&quot;was expecting only two putfield instructions in this method&quot;);
 980                                 }
 981                                 if (putField1 == -1) {
 982                                     putField1 = instruction.getShort(1);
 983                                 } else if (putField2 == -1) {
 984                                     putField2 = instruction.getShort(1);
 985                                 }
 986                             }
 987                         }
 988                         // now we need to check that we are assigning to `i` first and to `s` afterwards
 989                         CONSTANT_Fieldref_info fieldref_info1 = (CONSTANT_Fieldref_info)classFile.constant_pool.get(putField1);
 990                         if (!fieldref_info1.getNameAndTypeInfo().getName().equals(&quot;i&quot;)) {
 991                             throw new AssertionError(&quot;was expecting variable name &#39;i&#39;&quot;);
 992                         }
 993 
 994                         CONSTANT_Fieldref_info fieldref_info2 = (CONSTANT_Fieldref_info)classFile.constant_pool.get(putField2);
 995                         if (!fieldref_info2.getNameAndTypeInfo().getName().equals(&quot;s&quot;)) {
 996                             throw new AssertionError(&quot;was expecting variable name &#39;s&#39;&quot;);
 997                         }
 998                     }
 999                 }
1000             }
1001         }
1002     }
1003 
1004     public void testAcceptRecordId() {
1005         String[] previousOptions = getCompileOptions();
1006         String[] testOptions = {/* no options */};
1007         setCompileOptions(testOptions);
1008         assertOKWithWarning(&quot;compiler.warn.restricted.type.not.allowed.preview&quot;,
1009                 &quot;class R {\n&quot; +
1010                 &quot;    record RR(int i) {\n&quot; +
1011                 &quot;        return null;\n&quot; +
1012                 &quot;    }\n&quot; +
1013                 &quot;    class record {}\n&quot; +
1014                 &quot;}&quot;);
1015         setCompileOptions(previousOptions);
1016     }
1017 
1018     public void testAnnos() throws Exception {
1019         String[] previousOptions = getCompileOptions();
1020         String srcTemplate =
1021                 &quot;&quot;&quot;
1022                     import java.lang.annotation.*;
1023                     @Target({#TARGET})
1024                     @Retention(RetentionPolicy.RUNTIME)
1025                     @interface Anno { }
1026 
1027                     record R(@Anno String s) {}
1028                 &quot;&quot;&quot;;
1029 
1030         // testing several combinations, adding even more combinations won&#39;t add too much value
1031         List&lt;String&gt; annoApplicableTargets = List.of(
1032                 &quot;ElementType.FIELD&quot;,
1033                 &quot;ElementType.METHOD&quot;,
1034                 &quot;ElementType.PARAMETER&quot;,
1035                 &quot;ElementType.RECORD_COMPONENT&quot;,
1036                 &quot;ElementType.TYPE_USE&quot;,
1037                 &quot;ElementType.TYPE_USE,ElementType.FIELD&quot;,
1038                 &quot;ElementType.TYPE_USE,ElementType.METHOD&quot;,
1039                 &quot;ElementType.TYPE_USE,ElementType.PARAMETER&quot;,
1040                 &quot;ElementType.TYPE_USE,ElementType.RECORD_COMPONENT&quot;,
1041                 &quot;ElementType.TYPE_USE,ElementType.FIELD,ElementType.METHOD&quot;,
1042                 &quot;ElementType.TYPE_USE,ElementType.FIELD,ElementType.PARAMETER&quot;,
1043                 &quot;ElementType.TYPE_USE,ElementType.FIELD,ElementType.RECORD_COMPONENT&quot;,
1044                 &quot;ElementType.FIELD,ElementType.TYPE_USE&quot;,
1045                 &quot;ElementType.METHOD,ElementType.TYPE_USE&quot;,
1046                 &quot;ElementType.PARAMETER,ElementType.TYPE_USE&quot;,
1047                 &quot;ElementType.RECORD_COMPONENT,ElementType.TYPE_USE&quot;,
1048                 &quot;ElementType.FIELD,ElementType.METHOD,ElementType.TYPE_USE&quot;,
1049                 &quot;ElementType.FIELD,ElementType.PARAMETER,ElementType.TYPE_USE&quot;,
1050                 &quot;ElementType.FIELD,ElementType.RECORD_COMPONENT,ElementType.TYPE_USE&quot;
1051         );
1052 
1053         String[] generalOptions = {
1054                 &quot;--enable-preview&quot;,
1055                 &quot;-source&quot;, Integer.toString(Runtime.version().feature()),
1056                 &quot;-processor&quot;, Processor.class.getName(),
1057                 &quot;-Atargets=&quot;
1058         };
1059 
1060         for (String target : annoApplicableTargets) {
1061             String code = srcTemplate.replaceFirst(&quot;#TARGET&quot;, target);
1062             String[] testOptions = generalOptions.clone();
1063             testOptions[testOptions.length - 1] = testOptions[testOptions.length - 1] + target;
1064             setCompileOptions(testOptions);
1065 
1066             File dir = assertOK(true, code);
1067 
1068             ClassFile classFile = ClassFile.read(findClassFileOrFail(dir, &quot;R.class&quot;));
1069 
1070             // field first
1071             Assert.check(classFile.fields.length == 1);
1072             Field field = classFile.fields[0];
1073             /* if FIELD is one of the targets then there must be a declaration annotation applied to the field, apart from
1074              * the type annotation
1075              */
1076             if (target.contains(&quot;FIELD&quot;)) {
1077                 checkAnno(classFile,
1078                         (RuntimeAnnotations_attribute)findAttributeOrFail(
1079                                 field.attributes,
1080                                 RuntimeVisibleAnnotations_attribute.class),
1081                         &quot;Anno&quot;);
1082             } else {
1083                 assertAttributeNotPresent(field.attributes, RuntimeVisibleAnnotations_attribute.class);
1084             }
1085 
1086             // lets check now for the type annotation
1087             if (target.contains(&quot;TYPE_USE&quot;)) {
1088                 checkTypeAnno(
1089                         classFile,
1090                         (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class),
1091                         &quot;FIELD&quot;,
1092                         &quot;Anno&quot;);
1093             } else {
1094                 assertAttributeNotPresent(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class);
1095             }
1096 
1097             // checking for the annotation on the corresponding parameter of the canonical constructor
1098             Method init = findMethodOrFail(classFile, &quot;&lt;init&gt;&quot;);
1099             /* if PARAMETER is one of the targets then there must be a declaration annotation applied to the parameter, apart from
1100              * the type annotation
1101              */
1102             if (target.contains(&quot;PARAMETER&quot;)) {
1103                 checkParameterAnno(classFile,
1104                         (RuntimeVisibleParameterAnnotations_attribute)findAttributeOrFail(
1105                                 init.attributes,
1106                                 RuntimeVisibleParameterAnnotations_attribute.class),
1107                         &quot;Anno&quot;);
1108             } else {
1109                 assertAttributeNotPresent(init.attributes, RuntimeVisibleAnnotations_attribute.class);
1110             }
1111             // let&#39;s check now for the type annotation
1112             if (target.contains(&quot;TYPE_USE&quot;)) {
1113                 checkTypeAnno(
1114                         classFile,
1115                         (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class),
1116                         &quot;METHOD_FORMAL_PARAMETER&quot;, &quot;Anno&quot;);
1117             } else {
1118                 assertAttributeNotPresent(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class);
1119             }
1120 
1121             // checking for the annotation in the accessor
1122             Method accessor = findMethodOrFail(classFile, &quot;s&quot;);
1123             /* if METHOD is one of the targets then there must be a declaration annotation applied to the accessor, apart from
1124              * the type annotation
1125              */
1126             if (target.contains(&quot;METHOD&quot;)) {
1127                 checkAnno(classFile,
1128                         (RuntimeAnnotations_attribute)findAttributeOrFail(
1129                                 accessor.attributes,
1130                                 RuntimeVisibleAnnotations_attribute.class),
1131                         &quot;Anno&quot;);
1132             } else {
1133                 assertAttributeNotPresent(accessor.attributes, RuntimeVisibleAnnotations_attribute.class);
1134             }
1135             // let&#39;s check now for the type annotation
1136             if (target.contains(&quot;TYPE_USE&quot;)) {
1137                 checkTypeAnno(
1138                         classFile,
1139                         (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class),
1140                         &quot;METHOD_RETURN&quot;, &quot;Anno&quot;);
1141             } else {
1142                 assertAttributeNotPresent(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class);
1143             }
1144 
1145             // checking for the annotation in the Record attribute
1146             Record_attribute record = (Record_attribute)findAttributeOrFail(classFile.attributes, Record_attribute.class);
1147             Assert.check(record.component_count == 1);
1148             /* if RECORD_COMPONENT is one of the targets then there must be a declaration annotation applied to the
1149              * field, apart from the type annotation
1150              */
1151             if (target.contains(&quot;RECORD_COMPONENT&quot;)) {
1152                 checkAnno(classFile,
1153                         (RuntimeAnnotations_attribute)findAttributeOrFail(
1154                                 record.component_info_arr[0].attributes,
1155                                 RuntimeVisibleAnnotations_attribute.class),
1156                         &quot;Anno&quot;);
1157             } else {
1158                 assertAttributeNotPresent(record.component_info_arr[0].attributes, RuntimeVisibleAnnotations_attribute.class);
1159             }
1160             // lets check now for the type annotation
1161             if (target.contains(&quot;TYPE_USE&quot;)) {
1162                 checkTypeAnno(
1163                         classFile,
1164                         (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(
1165                                 record.component_info_arr[0].attributes,
1166                                 RuntimeVisibleTypeAnnotations_attribute.class),
1167                         &quot;FIELD&quot;, &quot;Anno&quot;);
1168             } else {
1169                 assertAttributeNotPresent(record.component_info_arr[0].attributes, RuntimeVisibleTypeAnnotations_attribute.class);
1170             }
1171         }
1172 
1173         // let&#39;s reset the default compiler options for other tests
1174         setCompileOptions(previousOptions);
1175     }
1176 
1177     private void checkTypeAnno(ClassFile classFile,
1178                                RuntimeTypeAnnotations_attribute rtAnnos,
1179                                String positionType,
1180                                String annoName) throws Exception {
1181         // containing only one type annotation
1182         Assert.check(rtAnnos.annotations.length == 1);
1183         TypeAnnotation tAnno = (TypeAnnotation)rtAnnos.annotations[0];
1184         Assert.check(tAnno.position.type.toString().equals(positionType));
1185         String annotationName = classFile.constant_pool.getUTF8Value(tAnno.annotation.type_index).toString().substring(1);
1186         Assert.check(annotationName.startsWith(annoName));
1187     }
1188 
1189     private void checkAnno(ClassFile classFile,
1190                            RuntimeAnnotations_attribute rAnnos,
1191                            String annoName) throws Exception {
1192         // containing only one type annotation
1193         Assert.check(rAnnos.annotations.length == 1);
1194         Annotation anno = (Annotation)rAnnos.annotations[0];
1195         String annotationName = classFile.constant_pool.getUTF8Value(anno.type_index).toString().substring(1);
1196         Assert.check(annotationName.startsWith(annoName));
1197     }
1198 
1199     // special case for parameter annotations
1200     private void checkParameterAnno(ClassFile classFile,
1201                            RuntimeVisibleParameterAnnotations_attribute rAnnos,
1202                            String annoName) throws Exception {
1203         // containing only one type annotation
1204         Assert.check(rAnnos.parameter_annotations.length == 1);
1205         Assert.check(rAnnos.parameter_annotations[0].length == 1);
1206         Annotation anno = (Annotation)rAnnos.parameter_annotations[0][0];
1207         String annotationName = classFile.constant_pool.getUTF8Value(anno.type_index).toString().substring(1);
1208         Assert.check(annotationName.startsWith(annoName));
1209     }
1210 
1211     private File findClassFileOrFail(File dir, String name) {
1212         for (final File fileEntry : dir.listFiles()) {
1213             if (fileEntry.getName().equals(&quot;R.class&quot;)) {
1214                 return fileEntry;
1215             }
1216         }
1217         throw new AssertionError(&quot;file not found&quot;);
1218     }
1219 
1220     private Method findMethodOrFail(ClassFile classFile, String name) throws Exception {
1221         for (Method method : classFile.methods) {
1222             if (method.getName(classFile.constant_pool).equals(name)) {
1223                 return method;
1224             }
1225         }
1226         throw new AssertionError(&quot;method not found&quot;);
1227     }
1228 
1229     private Attribute findAttributeOrFail(Attributes attributes, Class&lt;? extends Attribute&gt; attrClass) {
1230         for (Attribute attribute : attributes) {
1231             if (attribute.getClass() == attrClass) {
1232                 return attribute;
1233             }
1234         }
1235         throw new AssertionError(&quot;attribute not found&quot;);
1236     }
1237 
1238     private void assertAttributeNotPresent(Attributes attributes, Class&lt;? extends Attribute&gt; attrClass) {
1239         for (Attribute attribute : attributes) {
1240             if (attribute.getClass() == attrClass) {
1241                 throw new AssertionError(&quot;attribute not expected&quot;);
1242             }
1243         }
1244     }
1245 
1246     @SupportedAnnotationTypes(&quot;*&quot;)
1247     public static final class Processor extends JavacTestingAbstractProcessor {
1248 
1249         String targets;
1250         int numberOfTypeAnnotations;
1251 
1252         @Override
1253         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
1254             targets = processingEnv.getOptions().get(&quot;targets&quot;);
1255             for (TypeElement te : annotations) {
1256                 if (te.toString().equals(&quot;Anno&quot;)) {
1257                     checkElements(te, roundEnv, targets);
1258                     if (targets.contains(&quot;TYPE_USE&quot;)) {
1259                         Element element = processingEnv.getElementUtils().getTypeElement(&quot;R&quot;);
1260                         numberOfTypeAnnotations = 0;
1261                         checkTypeAnnotations(element);
1262                         Assert.check(numberOfTypeAnnotations == 4);
1263                     }
1264                 }
1265             }
1266             return true;
1267         }
1268 
1269         void checkElements(TypeElement te, RoundEnvironment renv, String targets) {
1270             Set&lt;? extends Element&gt; annoElements = renv.getElementsAnnotatedWith(te);
1271             Set&lt;String&gt; targetSet = new HashSet&lt;&gt;(Arrays.asList(targets.split(&quot;,&quot;)));
1272             // we will check for type annotation in another method
1273             targetSet.remove(&quot;ElementType.TYPE_USE&quot;);
1274             for (Element e : annoElements) {
1275                 Symbol s = (Symbol) e;
1276                 switch (s.getKind()) {
1277                     case FIELD:
1278                         Assert.check(targetSet.contains(&quot;ElementType.FIELD&quot;));
1279                         targetSet.remove(&quot;ElementType.FIELD&quot;);
1280                         break;
1281                     case METHOD:
1282                         Assert.check(targetSet.contains(&quot;ElementType.METHOD&quot;));
1283                         targetSet.remove(&quot;ElementType.METHOD&quot;);
1284                         break;
1285                     case PARAMETER:
1286                         Assert.check(targetSet.contains(&quot;ElementType.PARAMETER&quot;));
1287                         targetSet.remove(&quot;ElementType.PARAMETER&quot;);
1288                         break;
1289                     case RECORD_COMPONENT:
1290                         Assert.check(targetSet.contains(&quot;ElementType.RECORD_COMPONENT&quot;));
1291                         targetSet.remove(&quot;ElementType.RECORD_COMPONENT&quot;);
1292                         break;
1293                     default:
1294                         throw new AssertionError(&quot;unexpected element kind&quot;);
1295                 }
1296             }
1297             Assert.check(targetSet.isEmpty(), targetSet.toString());
1298         }
1299 
1300         private void checkTypeAnnotations(Element rootElement) {
1301             new ElementScanner&lt;Void, Void&gt;() {
1302                 @Override public Void visitVariable(VariableElement e, Void p) {
1303                     Symbol s = (Symbol) e;
1304                     if (s.getKind() == ElementKind.FIELD ||
1305                             s.getKind() == ElementKind.PARAMETER &amp;&amp;
1306                             s.name.toString().equals(&quot;s&quot;)) {
1307                         int currentTAs = numberOfTypeAnnotations;
1308                         verifyTypeAnnotations(e.asType().getAnnotationMirrors());
1309                         Assert.check(currentTAs + 1 == numberOfTypeAnnotations);
1310                     }
1311                     return null;
1312                 }
1313                 @Override
1314                 public Void visitExecutable(ExecutableElement e, Void p) {
1315                     Symbol s = (Symbol) e;
1316                     if (s.getKind() == ElementKind.METHOD &amp;&amp;
1317                                     s.name.toString().equals(&quot;s&quot;)) {
1318                         int currentTAs = numberOfTypeAnnotations;
1319                         verifyTypeAnnotations(e.getReturnType().getAnnotationMirrors());
1320                         Assert.check(currentTAs + 1 == numberOfTypeAnnotations);
1321                     }
1322                     scan(e.getParameters(), p);
1323                     return null;
1324                 }
1325                 @Override public Void visitRecordComponent(RecordComponentElement e, Void p) {
1326                     int currentTAs = numberOfTypeAnnotations;
1327                     verifyTypeAnnotations(e.asType().getAnnotationMirrors());
1328                     Assert.check(currentTAs + 1 == numberOfTypeAnnotations);
1329                     return null;
1330                 }
1331             }.scan(rootElement, null);
1332         }
1333 
1334         private void verifyTypeAnnotations(Iterable&lt;? extends AnnotationMirror&gt; annotations) {
1335             for (AnnotationMirror mirror : annotations) {
1336                 Assert.check(mirror.toString().startsWith(&quot;@Anno&quot;));
1337                 if (mirror instanceof TypeCompound) {
1338                     numberOfTypeAnnotations++;
1339                 }
1340             }
1341         }
1342     }
1343 
1344     public void testMethodsInheritedFromRecordArePublicAndFinal() throws Exception {
1345         int numberOfFieldRefs = 0;
1346         File dir = assertOK(true, &quot;record R() {}&quot;);
1347         for (final File fileEntry : dir.listFiles()) {
1348             if (fileEntry.getName().equals(&quot;R.class&quot;)) {
1349                 ClassFile classFile = ClassFile.read(fileEntry);
1350                 for (Method method : classFile.methods)
1351                     switch (method.getName(classFile.constant_pool)) {
1352                         case &quot;toString&quot;, &quot;equals&quot;, &quot;hashCode&quot; -&gt;
1353                             Assert.check(method.access_flags.is(AccessFlags.ACC_PUBLIC) &amp;&amp; method.access_flags.is(AccessFlags.ACC_FINAL));
1354                         default -&gt; { /* do nothing */ }
1355                     }
1356             }
1357         }
1358     }
1359 
1360     private static final List&lt;String&gt; ACCESSIBILITY = List.of(
1361             &quot;public&quot;, &quot;protected&quot;, &quot;&quot;, &quot;private&quot;);
1362 
1363     public void testCanonicalAccessibility() throws Exception {
1364         // accessibility of canonical can&#39;t be stronger than that of the record type
1365         for (String a1 : ACCESSIBILITY) {
1366             for (String a2 : ACCESSIBILITY) {
1367                 if (protection(a2) &gt; protection(a1)) {
1368                     assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;class R {# record RR() { # RR {} } }&quot;, a1, a2);
1369                 } else {
1370                     assertOK(&quot;class R {# record RR() { # RR {} } }&quot;, a1, a2);
1371                 }
1372             }
1373         }
1374 
1375         // now lets check that when compiler the compiler generates the canonical, it has the same accessibility
1376         // as the record type
1377         for (String a : ACCESSIBILITY) {
1378             File dir = assertOK(true, &quot;class R {# record RR() {} }&quot;, a);
1379             for (final File fileEntry : dir.listFiles()) {
1380                 if (fileEntry.getName().equals(&quot;R$RR.class&quot;)) {
1381                     ClassFile classFile = ClassFile.read(fileEntry);
1382                     for (Method method : classFile.methods)
1383                         if (method.getName(classFile.constant_pool).equals(&quot;&lt;init&gt;&quot;)) {
1384                             Assert.check(method.access_flags.flags == accessFlag(a),
1385                                     &quot;was expecting access flag &quot; + accessFlag(a) + &quot; but found &quot; + method.access_flags.flags);
1386                         }
1387                 }
1388             }
1389         }
1390     }
1391 
1392     private int protection(String access) {
1393         switch (access) {
1394             case &quot;private&quot;: return 3;
1395             case &quot;protected&quot;: return 1;
1396             case &quot;public&quot;: return 0;
1397             case &quot;&quot;: return 2;
1398             default:
1399                 throw new AssertionError();
1400         }
1401     }
1402 
1403     private int accessFlag(String access) {
1404         switch (access) {
1405             case &quot;private&quot;: return AccessFlags.ACC_PRIVATE;
1406             case &quot;protected&quot;: return AccessFlags.ACC_PROTECTED;
1407             case &quot;public&quot;: return AccessFlags.ACC_PUBLIC;
1408             case &quot;&quot;: return 0;
1409             default:
1410                 throw new AssertionError();
1411         }
1412     }
1413 
1414     public void testSameArity() {
1415         for (String source : List.of(
1416                 &quot;&quot;&quot;
1417                 record R(int... args) {
1418                     public R(int... args) {
1419                         this.args = args;
1420                     }
1421                 }
1422                 &quot;&quot;&quot;,
1423                 &quot;&quot;&quot;
1424                 record R(int[] args) {
1425                     public R(int[] args) {
1426                         this.args = args;
1427                     }
1428                 }
1429                 &quot;&quot;&quot;,
1430                 &quot;&quot;&quot;
1431                 record R(@A int... ints) {}
1432 
1433                 @java.lang.annotation.Target({
1434                         java.lang.annotation.ElementType.TYPE_USE,
1435                         java.lang.annotation.ElementType.RECORD_COMPONENT})
1436                 @interface A {}
1437                 &quot;&quot;&quot;,
1438                 &quot;&quot;&quot;
1439                 record R(@A int... ints) {
1440                     R(@A int... ints) {
1441                         this.ints = ints;
1442                     }
1443                 }
1444 
1445                 @java.lang.annotation.Target({
1446                         java.lang.annotation.ElementType.TYPE_USE,
1447                         java.lang.annotation.ElementType.RECORD_COMPONENT})
1448                 @interface A {}
1449                 &quot;&quot;&quot;
1450         )) {
1451             assertOK(source);
1452         }
1453 
1454         for (String source : List.of(
1455                 &quot;&quot;&quot;
1456                 record R(int... args) {
1457                     public R(int[] args) {
1458                         this.args = args;
1459                     }
1460                 }
1461                 &quot;&quot;&quot;,
1462                 &quot;&quot;&quot;
1463                 record R(int... args) {
1464                     public R(int[] args) {
1465                         this.args = args;
1466                     }
1467                 }
1468                 &quot;&quot;&quot;,
1469                 &quot;&quot;&quot;
1470                 record R(String... args) {
1471                     public R(String[] args) {
1472                         this.args = args;
1473                     }
1474                 }
1475                 &quot;&quot;&quot;,
1476                 &quot;&quot;&quot;
1477                 record R(String... args) {
1478                     public R(String[] args) {
1479                         this.args = args;
1480                     }
1481                 }
1482                 &quot;&quot;&quot;
1483         )) {
1484             assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, source);
1485         }
1486     }
1487 
1488     public void testSafeVararsAnno() {
1489         assertFail(&quot;compiler.err.annotation.type.not.applicable&quot;,
1490                 &quot;&quot;&quot;
1491                 @SafeVarargs
1492                 record R&lt;T&gt;(T... t) {}
1493                 &quot;&quot;&quot;,
1494                 &quot;&quot;&quot;
1495                 @SafeVarargs
1496                 record R&lt;T&gt;(T... t) {
1497                     R(T... t) {
1498                         this.t = t;
1499                     }
1500                 }
1501                 &quot;&quot;&quot;
1502         );
1503 
1504         assertOK(
1505                 &quot;&quot;&quot;
1506                 record R&lt;T&gt;(T... t) {
1507                     @SafeVarargs
1508                     R(T... t) {
1509                         this.t = t;
1510                     }
1511                 }
1512                 &quot;&quot;&quot;
1513         );
1514 
1515         appendCompileOptions(&quot;-Xlint:unchecked&quot;);
1516         assertOKWithWarning(&quot;compiler.warn.unchecked.varargs.non.reifiable.type&quot;,
1517                 &quot;&quot;&quot;
1518                 record R&lt;T&gt;(T... t) {
1519                     R(T... t) {
1520                         this.t = t;
1521                     }
1522                 }
1523                 &quot;&quot;&quot;
1524         );
1525         removeLastCompileOptions(1);
1526 
1527         assertOK(
1528                 &quot;&quot;&quot;
1529                 @SuppressWarnings(&quot;unchecked&quot;)
1530                 record R&lt;T&gt;(T... t) {
1531                     R(T... t) {
1532                         this.t = t;
1533                     }
1534                 }
1535                 &quot;&quot;&quot;
1536         );
1537 
1538         assertOK(
1539                 &quot;&quot;&quot;
1540                 record R&lt;T&gt;(T... t) {
1541                     @SuppressWarnings(&quot;unchecked&quot;)
1542                     R(T... t) {
1543                         this.t = t;
1544                     }
1545                 }
1546                 &quot;&quot;&quot;
1547         );
1548     }
1549 
1550     public void testOverrideAtAccessor() {
1551         assertOK(
1552                 &quot;&quot;&quot;
1553                 record R(int i) {
1554                     @Override
1555                     public int i() { return i; }
1556                 }
1557                 &quot;&quot;&quot;,
1558                 &quot;&quot;&quot;
1559                 record R(int i, int j) {
1560                     @Override
1561                     public int i() { return i; }
1562                     public int j() { return j; }
1563                 }
1564                 &quot;&quot;&quot;,
1565                 &quot;&quot;&quot;
1566                 interface I { int i(); }
1567                 record R(int i) implements I {
1568                     @Override
1569                     public int i() { return i; }
1570                 }
1571                 &quot;&quot;&quot;,
1572                 &quot;&quot;&quot;
1573                 interface I { int i(); }
1574                 record R(int i) implements I {
1575                     public int i() { return i; }
1576                 }
1577                 &quot;&quot;&quot;,
1578                 &quot;&quot;&quot;
1579                 interface I { default int i() { return 0; } }
1580                 record R(int i) implements I {
1581                     @Override
1582                     public int i() { return i; }
1583                 }
1584                 &quot;&quot;&quot;
1585         );
1586     }
1587 
1588     public void testNoAssigmentInsideCompactRecord() {
1589         assertFail(&quot;compiler.err.cant.assign.val.to.final.var&quot;,
1590                 &quot;&quot;&quot;
1591                 record R(int i) {
1592                     R {
1593                         this.i = i;
1594                     }
1595                 }
1596                 &quot;&quot;&quot;
1597         );
1598         assertFail(&quot;compiler.err.cant.assign.val.to.final.var&quot;,
1599                 &quot;&quot;&quot;
1600                 record R(int i) {
1601                     R {
1602                         (this).i = i;
1603                     }
1604                 }
1605                 &quot;&quot;&quot;
1606         );
1607     }
<a name="2" id="anc2"></a><span class="line-added">1608 </span>
<span class="line-added">1609     public void testNoNPEStaticAnnotatedFields() {</span>
<span class="line-added">1610         assertOK(</span>
<span class="line-added">1611                 &quot;&quot;&quot;</span>
<span class="line-added">1612                 import java.lang.annotation.Native;</span>
<span class="line-added">1613                 record R() {</span>
<span class="line-added">1614                     @Native public static final int i = 0;</span>
<span class="line-added">1615                 }</span>
<span class="line-added">1616                 &quot;&quot;&quot;</span>
<span class="line-added">1617         );</span>
<span class="line-added">1618         assertOK(</span>
<span class="line-added">1619                 &quot;&quot;&quot;</span>
<span class="line-added">1620                 import java.lang.annotation.Native;</span>
<span class="line-added">1621                 class Outer {</span>
<span class="line-added">1622                     record R() {</span>
<span class="line-added">1623                         @Native public static final int i = 0;</span>
<span class="line-added">1624                     }</span>
<span class="line-added">1625                 }</span>
<span class="line-added">1626                 &quot;&quot;&quot;</span>
<span class="line-added">1627         );</span>
<span class="line-added">1628         assertOK(</span>
<span class="line-added">1629                 &quot;&quot;&quot;</span>
<span class="line-added">1630                 import java.lang.annotation.Native;</span>
<span class="line-added">1631                 class Outer {</span>
<span class="line-added">1632                     void m() {</span>
<span class="line-added">1633                         record R () {</span>
<span class="line-added">1634                             @Native public static final int i = 0;</span>
<span class="line-added">1635                         }</span>
<span class="line-added">1636                     }</span>
<span class="line-added">1637                 }</span>
<span class="line-added">1638                 &quot;&quot;&quot;</span>
<span class="line-added">1639         );</span>
<span class="line-added">1640     }</span>
1641 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>