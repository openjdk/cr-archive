<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/langtools/tools/javac/records/RecordCompilationTests.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /**
  27  * RecordCompilationTests
  28  *
  29  * @test
  30  * @summary Negative compilation tests, and positive compilation (smoke) tests for records
  31  * @library /lib/combo /tools/lib /tools/javac/lib
  32  * @modules
  33  *      jdk.compiler/com.sun.tools.javac.api
  34  *      jdk.compiler/com.sun.tools.javac.code
  35  *      jdk.compiler/com.sun.tools.javac.util
  36  *      jdk.jdeps/com.sun.tools.classfile
  37  * @build JavacTestingAbstractProcessor
  38  * @compile --enable-preview -source ${jdk.version} RecordCompilationTests.java
  39  * @run testng/othervm -DuseAP=false --enable-preview RecordCompilationTests
  40  * @run testng/othervm -DuseAP=true --enable-preview RecordCompilationTests
  41  */
  42 
  43 import java.io.File;
  44 
  45 import java.lang.annotation.ElementType;
  46 import java.util.Arrays;
  47 import java.util.EnumMap;
  48 import java.util.EnumSet;
  49 import java.util.HashSet;
  50 import java.util.List;
  51 import java.util.Map;
  52 import java.util.Set;
  53 import java.util.stream.Collectors;
  54 import java.util.stream.Stream;
  55 
  56 
  57 import com.sun.tools.javac.util.Assert;
  58 
  59 import javax.annotation.processing.AbstractProcessor;
  60 import javax.annotation.processing.RoundEnvironment;
  61 import javax.annotation.processing.SupportedAnnotationTypes;
  62 
  63 import javax.lang.model.element.AnnotationMirror;
  64 import javax.lang.model.element.AnnotationValue;
  65 import javax.lang.model.element.Element;
  66 import javax.lang.model.element.ElementKind;
  67 import javax.lang.model.element.ExecutableElement;
  68 import javax.lang.model.element.RecordComponentElement;
  69 import javax.lang.model.element.TypeElement;
  70 import javax.lang.model.element.VariableElement;
  71 
  72 import javax.lang.model.type.ArrayType;
  73 import javax.lang.model.type.TypeMirror;
  74 
  75 import com.sun.tools.classfile.AccessFlags;
  76 import com.sun.tools.classfile.Annotation;
  77 import com.sun.tools.classfile.Attribute;
  78 import com.sun.tools.classfile.Attributes;
  79 import com.sun.tools.classfile.ClassFile;
  80 import com.sun.tools.classfile.Code_attribute;
  81 import com.sun.tools.classfile.ConstantPool;
  82 import com.sun.tools.classfile.ConstantPool.CONSTANT_Fieldref_info;
  83 import com.sun.tools.classfile.ConstantPool.CPInfo;
  84 import com.sun.tools.classfile.Field;
  85 import com.sun.tools.classfile.Instruction;
  86 import com.sun.tools.classfile.Method;
  87 import com.sun.tools.classfile.Record_attribute;
  88 import com.sun.tools.classfile.Record_attribute.ComponentInfo;
  89 import com.sun.tools.classfile.RuntimeAnnotations_attribute;
  90 import com.sun.tools.classfile.RuntimeTypeAnnotations_attribute;
  91 import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;
  92 import com.sun.tools.classfile.RuntimeVisibleParameterAnnotations_attribute;
  93 import com.sun.tools.classfile.RuntimeVisibleTypeAnnotations_attribute;
  94 import com.sun.tools.classfile.TypeAnnotation;
  95 
  96 import com.sun.tools.javac.api.ClientCodeWrapper.DiagnosticSourceUnwrapper;
  97 import com.sun.tools.javac.code.Attribute.TypeCompound;
  98 import com.sun.tools.javac.code.Symbol;
  99 import com.sun.tools.javac.code.Symbol.VarSymbol;
 100 import com.sun.tools.javac.util.JCDiagnostic;
 101 
 102 import org.testng.annotations.Test;
 103 import tools.javac.combo.CompilationTestCase;
 104 
 105 import static java.lang.annotation.ElementType.*;
 106 import static org.testng.Assert.assertEquals;
 107 
 108 /** Records are the first feature which sports automatic injection of (declarative and type) annotations : from a
 109  *  given record component to one or more record members, if applicable.
 110  *  This implies that the record&#39;s implementation can be stressed with the presence of annotation processors. Which is
 111  *  something the implementator could easily skip. For this reason this test is executed twice, once without the
 112  *  presence of any annotation processor and one with a simple annotation processor (which does not annotation processing
 113  *  at all) just to force at least a round of annotation processing.
 114  *
 115  *  Tests needing special compilation options need to store current options, set its customs options by invoking method
 116  *  `setCompileOptions` and then reset the previous compilation options for other tests. To see an example of this check
 117  *  method: testAnnos()
 118  */
 119 
 120 @Test
 121 public class RecordCompilationTests extends CompilationTestCase {
 122     // @@@ When records become a permanent feature, we don&#39;t need these any more
 123     private static String[] PREVIEW_OPTIONS = {
 124             &quot;--enable-preview&quot;,
 125             &quot;-source&quot;, Integer.toString(Runtime.version().feature())
 126     };
 127 
 128     private static String[] PREVIEW_OPTIONS_WITH_AP = {
 129             &quot;--enable-preview&quot;,
 130             &quot;-source&quot;, Integer.toString(Runtime.version().feature()),
 131             &quot;-processor&quot;, SimplestAP.class.getName()
 132     };
 133 
 134     private static final List&lt;String&gt; BAD_COMPONENT_NAMES = List.of(
 135             &quot;clone&quot;, &quot;finalize&quot;, &quot;getClass&quot;, &quot;hashCode&quot;,
 136             &quot;notify&quot;, &quot;notifyAll&quot;, &quot;toString&quot;, &quot;wait&quot;);
 137 
 138     /* simplest annotation processor just to force a round of annotation processing for all tests
 139      */
 140     @SupportedAnnotationTypes(&quot;*&quot;)
 141     public static class SimplestAP extends AbstractProcessor {
 142         @Override
 143         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
 144             return true;
 145         }
 146     }
 147 
 148     public RecordCompilationTests() {
 149         boolean useAP = System.getProperty(&quot;useAP&quot;) == null ? false : System.getProperty(&quot;useAP&quot;).equals(&quot;true&quot;);
 150         setDefaultFilename(&quot;R.java&quot;);
 151         setCompileOptions(useAP ? PREVIEW_OPTIONS_WITH_AP : PREVIEW_OPTIONS);
 152         System.out.println(useAP ? &quot;running all tests using an annotation processor&quot; : &quot;running all tests without annotation processor&quot;);
 153     }
 154 
 155     public void testMalformedDeclarations() {
 156         assertFail(&quot;compiler.err.premature.eof&quot;, &quot;record R()&quot;);
 157         assertFail(&quot;compiler.err.premature.eof&quot;, &quot;record R();&quot;);
 158         assertFail(&quot;compiler.err.illegal.start.of.type&quot;, &quot;record R(,) { }&quot;);
 159         assertFail(&quot;compiler.err.illegal.start.of.type&quot;, &quot;record R((int x)) { }&quot;);
 160         assertFail(&quot;compiler.err.record.header.expected&quot;, &quot;record R { }&quot;);
 161         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(foo) { }&quot;);
 162         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int int) { }&quot;);
 163         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;abstract record R(String foo) { }&quot;);
 164         //assertFail(&quot;compiler.err.illegal.combination.of.modifiers&quot;, &quot;non-sealed record R(String foo) { }&quot;);
 165         assertFail(&quot;compiler.err.repeated.modifier&quot;, &quot;public public record R(String foo) { }&quot;);
 166         assertFail(&quot;compiler.err.repeated.modifier&quot;, &quot;private private record R(String foo) { }&quot;);
 167         assertFail(&quot;compiler.err.already.defined&quot;, &quot;record R(int x, int x) {}&quot;);
 168         for (String s : List.of(&quot;var&quot;, &quot;record&quot;))
 169             assertFail(&quot;compiler.err.restricted.type.not.allowed.here&quot;, &quot;record R(# x) { }&quot;, s);
 170         for (String s : List.of(&quot;public&quot;, &quot;protected&quot;, &quot;private&quot;, &quot;static&quot;, &quot;final&quot;, &quot;transient&quot;, &quot;volatile&quot;,
 171                 &quot;abstract&quot;, &quot;synchronized&quot;, &quot;native&quot;, &quot;strictfp&quot;)) // missing: sealed and non-sealed
 172             assertFail(&quot;compiler.err.record.cant.declare.field.modifiers&quot;, &quot;record R(# String foo) { }&quot;, s);
 173         assertFail(&quot;compiler.err.varargs.must.be.last&quot;, &quot;record R(int... x, int... y) {}&quot;);
 174         assertFail(&quot;compiler.err.instance.initializer.not.allowed.in.records&quot;, &quot;record R(int i) { {} }&quot;);
 175     }
 176 
 177     public void testGoodDeclarations() {
 178         assertOK(&quot;public record R() { }&quot;);
 179         assertOK(&quot;record R() { }&quot;);
 180         assertOK(&quot;record R() implements java.io.Serializable, Runnable { public void run() { } }&quot;);
 181         assertOK(&quot;record R(int x) { }&quot;);
 182         assertOK(&quot;record R(int x, int y) { }&quot;);
 183         assertOK(&quot;record R(int... xs) { }&quot;);
 184         assertOK(&quot;record R(String... ss) { }&quot;);
 185         assertOK(&quot;@Deprecated record R(int x, int y) { }&quot;);
 186         assertOK(&quot;record R(@Deprecated int x, int y) { }&quot;);
 187         assertOK(&quot;record R&lt;T&gt;(T x, T y) { }&quot;);
 188     }
 189 
 190     public void testGoodMemberDeclarations() {
 191         String template = &quot;public record R(int x) {\n&quot;
 192                 + &quot;    public R(int x) { this.x = x; }\n&quot;
 193                 + &quot;    public int x() { return x; }\n&quot;
 194                 + &quot;    public boolean equals(Object o) { return true; }\n&quot;
 195                 + &quot;    public int hashCode() { return 0; }\n&quot;
 196                 + &quot;    public String toString() { return null; }\n&quot;
 197                 + &quot;}&quot;;
 198         assertOK(template);
 199     }
 200 
 201     public void testBadComponentNames() {
 202         for (String s : BAD_COMPONENT_NAMES)
 203             assertFail(&quot;compiler.err.illegal.record.component.name&quot;, &quot;record R(int #) { } &quot;, s);
 204     }
 205 
 206     public void testRestrictedIdentifiers() {
 207         for (String s : List.of(&quot;interface record { void m(); }&quot;,
 208                 &quot;@interface record { }&quot;,
 209                 &quot;class record { }&quot;,
 210                 &quot;record record(int x) { }&quot;,
 211                 &quot;enum record { A, B }&quot;,
 212                 &quot;class R&lt;record&gt; { }&quot;)) {
 213             assertFail(
 214                     &quot;compiler.err.restricted.type.not.allowed&quot;,
 215                     diagWrapper -&gt; {
 216                         JCDiagnostic diagnostic = ((DiagnosticSourceUnwrapper)diagWrapper).d;
 217                         Object[] args = diagnostic.getArgs();
 218                         Assert.check(args.length == 2);
 219                         Assert.check(args[1].toString().equals(&quot;JDK14&quot;));
 220                     },
 221                     s);
 222         }
 223     }
 224 
 225     public void testValidMembers() {
 226         for (String s : List.of(&quot;record X(int j) { }&quot;,
 227                 &quot;interface I { }&quot;,
 228                 &quot;static { }&quot;,
 229                 &quot;enum E { A, B }&quot;,
 230                 &quot;class C { }&quot;
 231         )) {
 232             assertOK(&quot;record R(int i) { # }&quot;, s);
 233         }
 234     }
 235 
 236     public void testCyclic() {
 237         // Cyclic records are OK, but cyclic inline records would not be
 238         assertOK(&quot;record R(R r) { }&quot;);
 239     }
 240 
 241     public void testBadExtends() {
 242         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int x) extends Object { }&quot;);
 243         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int x) {}\n&quot;
 244                 + &quot;record R2(int x) extends R { }&quot;);
 245         assertFail(&quot;compiler.err.cant.inherit.from.final&quot;, &quot;record R(int x) {}\n&quot;
 246                 + &quot;class C extends R { }&quot;);
 247     }
 248 
 249     public void testNoExtendRecord() {
 250         assertFail(&quot;compiler.err.invalid.supertype.record&quot;,
 251                    &quot;&quot;&quot;
 252                    class R extends Record {
 253                        public String toString() { return null; }
 254                        public int hashCode() { return 0; }
 255                        public boolean equals(Object o) { return false; }
 256                    }
 257                    &quot;&quot;&quot;
 258         );
 259     }
 260 
 261     public void testFieldDeclarations() {
 262         // static fields are OK
 263         assertOK(&quot;public record R(int x) {\n&quot; +
 264                 &quot;    static int I = 1;\n&quot; +
 265                 &quot;    static final String S = \&quot;Hello World!\&quot;;\n&quot; +
 266                 &quot;    static private Object O = null;\n&quot; +
 267                 &quot;    static protected Object O2 = null;\n&quot; +
 268                 &quot;}&quot;);
 269 
 270         // instance fields are not
 271         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
 272                 &quot;public record R(int x) {\n&quot; +
 273                         &quot;    private final int y = 0;&quot; +
 274                         &quot;}&quot;);
 275 
 276         // mutable instance fields definitely not
 277         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
 278                 &quot;public record R(int x) {\n&quot; +
 279                         &quot;    private int y = 0;&quot; +
 280                         &quot;}&quot;);
 281 
 282         // redeclaring components also not
 283         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
 284                 &quot;public record R(int x) {\n&quot; +
 285                         &quot;    private final int x;&quot; +
 286                         &quot;}&quot;);
 287     }
 288 
 289     public void testAccessorRedeclaration() {
 290         assertOK(&quot;public record R(int x) {\n&quot; +
 291                 &quot;    public int x() { return x; };&quot; +
 292                 &quot;}&quot;);
 293 
 294         assertOK(&quot;public record R(int... x) {\n&quot; +
 295                 &quot;    public int[] x() { return x; };&quot; +
 296                 &quot;}&quot;);
 297 
 298         assertOK(&quot;public record R(int x) {\n&quot; +
 299                 &quot;    public final int x() { return 0; };&quot; +
 300                 &quot;}&quot;);
 301 
 302         assertOK(&quot;public record R(int x) {\n&quot; +
 303                 &quot;    public final int x() { return 0; };&quot; +
 304                 &quot;}&quot;);
 305 
 306         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 307                 &quot;public record R(int x) {\n&quot; +
 308                         &quot;    final int x() { return 0; };&quot; +
 309                         &quot;}&quot;);
 310 
 311         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 312                 &quot;public record R(int x) {\n&quot; +
 313                         &quot;    int x() { return 0; };&quot; +
 314                         &quot;}&quot;);
 315 
 316         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 317                 &quot;public record R(int x) {\n&quot; +
 318                         &quot;    private int x() { return 0; };&quot; +
 319                         &quot;}&quot;);
 320 
 321         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 322                    &quot;public record R(int x) {\n&quot; +
 323                    &quot;    public int x() throws Exception { return 0; };&quot; +
 324                    &quot;}&quot;);
 325 
 326         for (String s : List.of(&quot;List&quot;, &quot;List&lt;?&gt;&quot;, &quot;Object&quot;, &quot;ArrayList&lt;String&gt;&quot;, &quot;int&quot;))
 327             assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 328                     &quot;import java.util.*;\n&quot; +
 329                             &quot;public record R(List&lt;String&gt; x) {\n&quot; +
 330                             &quot;    public # x() { return null; };&quot; +
 331                             &quot;}&quot;, s);
 332 
 333         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 334                 &quot;public record R(int x) {\n&quot; +
 335                         &quot;    public &lt;T&gt; int x() { return x; };&quot; +
 336                         &quot;}&quot;);
 337 
 338         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 339                 &quot;public record R(int x) {\n&quot; +
 340                         &quot;    static private final j = 0;&quot; +
 341                         &quot;    static public int x() { return j; };&quot; +
 342                         &quot;}&quot;);
 343     }
 344 
 345     public void testConstructorRedeclaration() {
 346         for (String goodCtor : List.of(
 347                 &quot;public R(int x) { this(x, 0); }&quot;,
 348                 &quot;public R(int x, int y) { this.x = x; this.y = y; }&quot;,
 349                 &quot;public R { }&quot;))
 350             assertOK(&quot;record R(int x, int y) { # }&quot;, goodCtor);
 351 
 352         assertOK(&quot;import java.util.*; record R(String x, String y) {  public R { Objects.requireNonNull(x); Objects.requireNonNull(y); } }&quot;);
 353 
 354         // Not OK to redeclare canonical without DA
 355         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;, &quot;record R(int x, int y) { # }&quot;,
 356                    &quot;public R(int x, int y) { this.x = x; }&quot;);
 357 
 358         // Not OK to rearrange or change names
 359         for (String s : List.of(&quot;public R(int y, int x) { this.x = x; this.y = y; }&quot;,
 360                                 &quot;public R(int _x, int _y) { this.x = _x; this.y = _y; }&quot;))
 361             assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x, int y) { # }&quot;, s);
 362 
 363         // ctor args must match types
 364         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 365                 &quot;import java.util.*;\n&quot; +
 366                         &quot;record R(List&lt;String&gt; list) { # }&quot;,
 367                 &quot;R(List list) { this.list = list; }&quot;);
 368 
 369         // canonical ctor should not throw checked exceptions
 370         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 371                    &quot;record R() { # }&quot;,
 372                    &quot;public R() throws Exception { }&quot;);
 373 
 374         // same for compact
 375         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 376                 &quot;record R() { # }&quot;,
 377                 &quot;public R throws Exception { }&quot;);
 378 
 379         // not even unchecked exceptions
 380         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 381                 &quot;record R() { # }&quot;,
 382                  &quot;public R() throws IllegalArgumentException { }&quot;);
 383 
 384         // ditto
 385         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 386                 &quot;record R() { # }&quot;,
 387                 &quot;public R throws IllegalArgumentException { }&quot;);
 388 
 389         // If types match, names must match
 390         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 391                    &quot;record R(int x, int y) { public R(int y, int x) { this.x = this.y = 0; }}&quot;);
 392 
 393         // first invocation should be one to the canonical
 394         assertFail(&quot;compiler.err.first.statement.must.be.call.to.another.constructor&quot;,
 395                 &quot;record R(int x, int y) { public R(int y, int x, int z) { this.x = this.y = 0; } }&quot;);
 396 
 397         assertOK(&quot;record R(int x, int y) { &quot; +
 398                  &quot;    public R(int x, int y, int z) { this(x, y); } &quot; +
 399                  &quot;}&quot;);
 400 
 401         assertOK(&quot;record R(int x) { &quot; +
 402                 &quot;    public R(int x, int y) { this(x, y, 0); } &quot; +
 403                 &quot;    public R(int x, int y, int z) { this(x); } &quot; +
 404                 &quot;}&quot;);
 405 
 406         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 407                 &quot;record R&lt;T&gt;(T a) { # }&quot;,
 408                 &quot;public &lt;T&gt; R {}&quot;);
 409 
 410         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 411                 &quot;record R(int i) { # }&quot;,
 412                 &quot;public &lt;T&gt; R(int i) { this.i = i; }&quot;);
 413 
 414         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 415                 &quot;record R&lt;T&gt;(T a) { # }&quot;,
 416                 &quot;public &lt;T&gt; R(T a) { this.a = a; }&quot;);
 417 
 418         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 419                 &quot;record R(int a) { # }&quot;,
 420                 &quot;public R(int a) { super(); this.a = a; }&quot;);
 421     }
 422 
 423     public void testAnnotationCriteria() {
 424         String imports = &quot;import java.lang.annotation.*;\n&quot;;
 425         String template = &quot;@Target({ # }) @interface A {}\n&quot;;
 426         EnumMap&lt;ElementType, String&gt; annotations = new EnumMap&lt;&gt;(ElementType.class);
 427         for (ElementType e : values())
 428             annotations.put(e, template.replace(&quot;#&quot;, &quot;ElementType.&quot; + e.name()));
 429         EnumSet&lt;ElementType&gt; goodSet = EnumSet.of(RECORD_COMPONENT, FIELD, METHOD, PARAMETER, TYPE_USE);
 430         EnumSet&lt;ElementType&gt; badSet = EnumSet.of(CONSTRUCTOR, PACKAGE, TYPE, LOCAL_VARIABLE, ANNOTATION_TYPE, TYPE_PARAMETER, MODULE);
 431 
 432         assertEquals(goodSet.size() + badSet.size(), values().length);
 433         String A_GOOD = template.replace(&quot;#&quot;,
 434                                          goodSet.stream().map(ElementType::name).map(s -&gt; &quot;ElementType.&quot; + s).collect(Collectors.joining(&quot;,&quot;)));
 435         String A_BAD = template.replace(&quot;#&quot;,
 436                                         badSet.stream().map(ElementType::name).map(s -&gt; &quot;ElementType.&quot; + s).collect(Collectors.joining(&quot;,&quot;)));
 437         String A_ALL = template.replace(&quot;#&quot;,
 438                                         Stream.of(ElementType.values()).map(ElementType::name).map(s -&gt; &quot;ElementType.&quot; + s).collect(Collectors.joining(&quot;,&quot;)));
 439         String A_NONE = &quot;@interface A {}&quot;;
 440 
 441         for (ElementType e : goodSet)
 442             assertOK(imports + annotations.get(e) + &quot;record R(@A int x) { }&quot;);
 443         assertOK(imports + A_GOOD + &quot;record R(@A int x) { }&quot;);
 444         assertOK(imports + A_ALL + &quot;record R(@A int x) { }&quot;);
 445         assertOK(imports + A_NONE);
 446 
 447         for (ElementType e : badSet) {
 448             assertFail(&quot;compiler.err.annotation.type.not.applicable&quot;, imports + annotations.get(e) + &quot;record R(@A int x) { }&quot;);
 449         }
 450 
 451         assertFail(&quot;compiler.err.annotation.type.not.applicable&quot;, imports + A_BAD + &quot;record R(@A int x) { }&quot;);
 452 
 453         // TODO: OK to redeclare with or without same annos
 454     }
 455 
 456     public void testNestedRecords() {
 457         String template = &quot;class R { \n&quot; +
 458                           &quot;    # record RR(int a) { }\n&quot; +
 459                           &quot;}&quot;;
 460 
 461         for (String s : List.of(&quot;&quot;, &quot;static&quot;, &quot;final&quot;,
 462                                 &quot;private&quot;, &quot;public&quot;, &quot;protected&quot;,
 463                                 &quot;private static&quot;, &quot;public static&quot;, &quot;private static final&quot;))
 464             assertOK(template, s);
 465 
 466         for (String s : List.of(&quot;class C { }&quot;,
 467                                 &quot;static class C { }&quot;,
 468                                 &quot;enum X { A; }&quot;,
 469                                 &quot;interface I { }&quot;,
 470                                 &quot;record RR(int y) { }&quot;))
 471             assertOK(&quot;record R(int x) { # }&quot;, s);
 472     }
 473 
 474     public void testDuplicatedMember() {
 475         String template
 476                 = &quot;    record R(int i) {\n&quot; +
 477                   &quot;        public int i() { return i; }\n&quot; +
 478                   &quot;        public int i() { return i; }\n&quot; +
 479                   &quot;    }&quot;;
 480         assertFail(&quot;compiler.err.already.defined&quot;, template);
 481     }
 482 
 483     public void testStaticLocalTypes() {
 484         // local records can also be final
 485         assertOK(&quot;class R { \n&quot; +
 486                 &quot;    void m() { \n&quot; +
 487                 &quot;        final record RR(int x) { };\n&quot; +
 488                 &quot;    }\n&quot; +
 489                 &quot;}&quot;);
 490 
 491         // Can&#39;t capture locals
 492         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 493                 &quot;class R { \n&quot; +
 494                         &quot;    void m(int y) { \n&quot; +
 495                         &quot;        record RR(int x) { public int x() { return y; }};\n&quot; +
 496                         &quot;    }\n&quot; +
 497                         &quot;}&quot;);
 498 
 499         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 500                 &quot;class R { \n&quot; +
 501                         &quot;    void m() {\n&quot; +
 502                         &quot;        int y;\n&quot; +
 503                         &quot;        record RR(int x) { public int x() { return y; }};\n&quot; +
 504                         &quot;    }\n&quot; +
 505                         &quot;}&quot;);
 506 
 507         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 508                 &quot;class C {\n&quot; +
 509                 &quot;    public static void m() {\n&quot; +
 510                 &quot;        String hello = \&quot;hello\&quot;;\n&quot; +
 511                 &quot;        interface I {\n&quot; +
 512                 &quot;            public default void test1() {\n&quot; +
 513                 &quot;                class X {\n&quot; +
 514                 &quot;                    public void test2() {\n&quot; +
 515                 &quot;                        System.err.println(hello);\n&quot; +
 516                 &quot;                    }\n&quot; +
 517                 &quot;                }\n&quot; +
 518                 &quot;            }\n&quot; +
 519                 &quot;        }\n&quot; +
 520                 &quot;    }\n&quot; +
 521                 &quot;}&quot;);
 522 
 523         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 524                 &quot;class C {\n&quot; +
 525                 &quot;    public static void m() {\n&quot; +
 526                 &quot;        String hello = \&quot;hello\&quot;;\n&quot; +
 527                 &quot;        record R(int i) {\n&quot; +
 528                 &quot;            public void test1() {\n&quot; +
 529                 &quot;                class X {\n&quot; +
 530                 &quot;                    public void test2() {\n&quot; +
 531                 &quot;                        System.err.println(hello);\n&quot; +
 532                 &quot;                    }\n&quot; +
 533                 &quot;                }\n&quot; +
 534                 &quot;            }\n&quot; +
 535                 &quot;        }\n&quot; +
 536                 &quot;    }\n&quot; +
 537                 &quot;}&quot;);
 538 
 539         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 540                 &quot;class C {\n&quot; +
 541                 &quot;    public static void m() {\n&quot; +
 542                 &quot;        String hello = \&quot;hello\&quot;;\n&quot; +
 543                 &quot;        enum E {\n&quot; +
 544                 &quot;            A;\n&quot; +
 545                 &quot;            public void test1() {\n&quot; +
 546                 &quot;                class X {\n&quot; +
 547                 &quot;                    public void test2() {\n&quot; +
 548                 &quot;                        System.err.println(hello);\n&quot; +
 549                 &quot;                    }\n&quot; +
 550                 &quot;                }\n&quot; +
 551                 &quot;            }\n&quot; +
 552                 &quot;        }\n&quot; +
 553                 &quot;    }\n&quot; +
 554                 &quot;}&quot;);
 555 
 556         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 557                 &quot;class C {\n&quot; +
 558                 &quot;    public static void m(String param) {\n&quot; +
 559                 &quot;        interface I {\n&quot; +
 560                 &quot;            public default void test1() {\n&quot; +
 561                 &quot;                class X {\n&quot; +
 562                 &quot;                    public void test2() {\n&quot; +
 563                 &quot;                        System.err.println(param);\n&quot; +
 564                 &quot;                    }\n&quot; +
 565                 &quot;                }\n&quot; +
 566                 &quot;            }\n&quot; +
 567                 &quot;        }\n&quot; +
 568                 &quot;    }\n&quot; +
 569                 &quot;}&quot;);
 570 
 571         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 572                 &quot;class C {\n&quot; +
 573                 &quot;    public static void m(String param) {\n&quot; +
 574                 &quot;        record R(int i) {\n&quot; +
 575                 &quot;            public void test1() {\n&quot; +
 576                 &quot;                class X {\n&quot; +
 577                 &quot;                    public void test2() {\n&quot; +
 578                 &quot;                        System.err.println(param);\n&quot; +
 579                 &quot;                    }\n&quot; +
 580                 &quot;                }\n&quot; +
 581                 &quot;            }\n&quot; +
 582                 &quot;        }\n&quot; +
 583                 &quot;    }\n&quot; +
 584                 &quot;}&quot;);
 585 
 586         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 587                 &quot;class C {\n&quot; +
 588                 &quot;    public static void m(String param) {\n&quot; +
 589                 &quot;        enum E {\n&quot; +
 590                 &quot;            A;\n&quot; +
 591                 &quot;            public void test1() {\n&quot; +
 592                 &quot;                class X {\n&quot; +
 593                 &quot;                    public void test2() {\n&quot; +
 594                 &quot;                        System.err.println(param);\n&quot; +
 595                 &quot;                    }\n&quot; +
 596                 &quot;                }\n&quot; +
 597                 &quot;            }\n&quot; +
 598                 &quot;        }\n&quot; +
 599                 &quot;    }\n&quot; +
 600                 &quot;}&quot;);
 601 
 602         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 603                 &quot;class C {\n&quot; +
 604                 &quot;    String instanceField = \&quot;instance\&quot;;\n&quot; +
 605                 &quot;    public static void m() {\n&quot; +
 606                 &quot;        interface I {\n&quot; +
 607                 &quot;            public default void test1() {\n&quot; +
 608                 &quot;                class X {\n&quot; +
 609                 &quot;                    public void test2() {\n&quot; +
 610                 &quot;                        System.err.println(instanceField);\n&quot; +
 611                 &quot;                    }\n&quot; +
 612                 &quot;                }\n&quot; +
 613                 &quot;            }\n&quot; +
 614                 &quot;        }\n&quot; +
 615                 &quot;    }\n&quot; +
 616                 &quot;}&quot;);
 617 
 618         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 619                 &quot;class C {\n&quot; +
 620                 &quot;    String instanceField = \&quot;instance\&quot;;\n&quot; +
 621                 &quot;    public static void m(String param) {\n&quot; +
 622                 &quot;        record R(int i) {\n&quot; +
 623                 &quot;            public void test1() {\n&quot; +
 624                 &quot;                class X {\n&quot; +
 625                 &quot;                    public void test2() {\n&quot; +
 626                 &quot;                        System.err.println(instanceField);\n&quot; +
 627                 &quot;                    }\n&quot; +
 628                 &quot;                }\n&quot; +
 629                 &quot;            }\n&quot; +
 630                 &quot;        }\n&quot; +
 631                 &quot;    }\n&quot; +
 632                 &quot;}&quot;);
 633 
 634         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 635                 &quot;class C {\n&quot; +
 636                 &quot;    String instanceField = \&quot;instance\&quot;;\n&quot; +
 637                 &quot;    public static void m(String param) {\n&quot; +
 638                 &quot;        enum E {\n&quot; +
 639                 &quot;            A;\n&quot; +
 640                 &quot;            public void test1() {\n&quot; +
 641                 &quot;                class X {\n&quot; +
 642                 &quot;                    public void test2() {\n&quot; +
 643                 &quot;                        System.err.println(instanceField);\n&quot; +
 644                 &quot;                    }\n&quot; +
 645                 &quot;                }\n&quot; +
 646                 &quot;            }\n&quot; +
 647                 &quot;        }\n&quot; +
 648                 &quot;    }\n&quot; +
 649                 &quot;}&quot;);
 650 
 651         // instance fields
 652         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 653                 &quot;class R { \n&quot; +
 654                         &quot;    int z = 0;\n&quot; +
 655                         &quot;    void m() { \n&quot; +
 656                         &quot;        record RR(int x) { public int x() { return z; }};\n&quot; +
 657                         &quot;    }\n&quot; +
 658                         &quot;}&quot;);
 659 
 660         // or type variables
 661         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 662                 &quot;class R&lt;T&gt; { \n&quot; +
 663                         &quot;    void m() { \n&quot; +
 664                         &quot;        record RR(T t) {};\n&quot; +
 665                         &quot;    }\n&quot; +
 666                         &quot;}&quot;);
 667 
 668         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 669                 &quot;class R {\n&quot; +
 670                 &quot;    static &lt;U&gt; U make(U u) { //method is static\n&quot; +
 671                 &quot;        interface Checker {\n&quot; +
 672                 &quot;            void check(U u);\n&quot; +
 673                 &quot;        }\n&quot; +
 674                 &quot;        return null;\n&quot; +
 675                 &quot;    }\n&quot; +
 676                 &quot;}&quot;);
 677 
 678         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 679                 &quot;class LocalEnum {\n&quot; +
 680                 &quot;    static &lt;U&gt; U getAndSet(U u) { //method is static\n&quot; +
 681                 &quot;        enum X {\n&quot; +
 682                 &quot;            A;\n&quot; +
 683                 &quot;            U u;\n&quot; +
 684                 &quot;        }\n&quot; +
 685                 &quot;        return null;\n&quot; +
 686                 &quot;    }\n&quot; +
 687                 &quot;}\n&quot;);
 688 
 689         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 690                 &quot;class R {\n&quot; +
 691                 &quot;    static &lt;U&gt; U make(U u) { //method is static\n&quot; +
 692                 &quot;        record Checker() {\n&quot; +
 693                 &quot;            void check(U u);\n&quot; +
 694                 &quot;        }\n&quot; +
 695                 &quot;        return null;\n&quot; +
 696                 &quot;    }\n&quot; +
 697                 &quot;}&quot;);
 698 
 699         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 700                 &quot;class R {\n&quot; +
 701                 &quot;    &lt;U&gt; U make(U u) { // enclosing method is not static\n&quot; +
 702                 &quot;        interface Checker {\n&quot; +
 703                 &quot;            void check(U u);\n&quot; +
 704                 &quot;        }\n&quot; +
 705                 &quot;        return null;\n&quot; +
 706                 &quot;    }\n&quot; +
 707                 &quot;}&quot;);
 708 
 709         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 710                 &quot;class LocalEnum {\n&quot; +
 711                 &quot;    &lt;U&gt; U getAndSet(U u) { // enclosing method is not static\n&quot; +
 712                 &quot;        enum X {\n&quot; +
 713                 &quot;            A;\n&quot; +
 714                 &quot;            U u;\n&quot; +
 715                 &quot;        }\n&quot; +
 716                 &quot;        return null;\n&quot; +
 717                 &quot;    }\n&quot; +
 718                 &quot;}\n&quot;);
 719 
 720         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 721                 &quot;class R {\n&quot; +
 722                 &quot;    &lt;U&gt; U make(U u) { // enclosing method is not static\n&quot; +
 723                 &quot;        record Checker() {\n&quot; +
 724                 &quot;            void check(U u);\n&quot; +
 725                 &quot;        }\n&quot; +
 726                 &quot;        return null;\n&quot; +
 727                 &quot;    }\n&quot; +
 728                 &quot;}&quot;);
 729 
 730         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 731                 &quot;class C {\n&quot; +
 732                 &quot;    public static &lt;T&gt; void main(String[] args) {\n&quot; +
 733                 &quot;        interface I {\n&quot; +
 734                 &quot;            public default void test1() {\n&quot; +
 735                 &quot;                class X {\n&quot; +
 736                 &quot;                    public void test2() {\n&quot; +
 737                 &quot;                        T t = null;\n&quot; +
 738                 &quot;                    }\n&quot; +
 739                 &quot;                }\n&quot; +
 740                 &quot;            }\n&quot; +
 741                 &quot;        }\n&quot; +
 742                 &quot;    }\n&quot; +
 743                 &quot;}&quot;);
 744 
 745         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 746                 &quot;class C {\n&quot; +
 747                 &quot;    public static &lt;T&gt; void main(String[] args) {\n&quot; +
 748                 &quot;        record R(int i) {\n&quot; +
 749                 &quot;            public void test1() {\n&quot; +
 750                 &quot;                class X {\n&quot; +
 751                 &quot;                    public void test2() {\n&quot; +
 752                 &quot;                        T t = null;\n&quot; +
 753                 &quot;                    }\n&quot; +
 754                 &quot;                }\n&quot; +
 755                 &quot;            }\n&quot; +
 756                 &quot;        }\n&quot; +
 757                 &quot;    }\n&quot; +
 758                 &quot;}&quot;);
 759 
 760         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 761                 &quot;class C {\n&quot; +
 762                 &quot;    public static &lt;T&gt; void main(String[] args) {\n&quot; +
 763                 &quot;        enum E {\n&quot; +
 764                 &quot;            A;\n&quot; +
 765                 &quot;            public void test1() {\n&quot; +
 766                 &quot;                class X {\n&quot; +
 767                 &quot;                    public void test2() {\n&quot; +
 768                 &quot;                        T t = null;\n&quot; +
 769                 &quot;                    }\n&quot; +
 770                 &quot;                }\n&quot; +
 771                 &quot;            }\n&quot; +
 772                 &quot;        }\n&quot; +
 773                 &quot;    }\n&quot; +
 774                 &quot;}&quot;);
 775 
 776         // but static fields are OK
 777         assertOK(&quot;class R { \n&quot; +
 778                 &quot;    static int z = 0;\n&quot; +
 779                 &quot;    void m() { \n&quot; +
 780                 &quot;        record RR(int x) { public int x() { return z; }};\n&quot; +
 781                 &quot;    }\n&quot; +
 782                 &quot;}&quot;);
 783         // Can&#39;t self-shadow
 784         assertFail(&quot;compiler.err.already.defined&quot;,
 785                 &quot;&quot;&quot;
 786                 class R {
 787                     void m() {
 788                         record R(int x) { };
 789                     }
 790                 }
 791                 &quot;&quot;&quot;
 792         );
 793         // can&#39;t be explicitly static
 794         assertFail(&quot;compiler.err.illegal.start.of.expr&quot;,
 795                 &quot;&quot;&quot;
 796                 class R {
 797                     void m() {
 798                         static record RR(int x) { };
 799                     }
 800                 }
 801                 &quot;&quot;&quot;
 802         );
 803     }
 804 
 805     public void testReturnInCanonical_Compact() {
 806         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x) { # }&quot;,
 807                 &quot;public R { return; }&quot;);
 808         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x) { # }&quot;,
 809                 &quot;public R { if (i &lt; 0) { return; }}&quot;);
 810         assertOK(&quot;record R(int x) { public R(int x) { this.x = x; return; } }&quot;);
 811         assertOK(&quot;record R(int x) { public R { Runnable r = () -&gt; { return; };} }&quot;);
 812     }
 813 
 814     public void testArgumentsAreNotFinalInCompact() {
 815         assertOK(
 816                 &quot;&quot;&quot;
 817                 record R(int x) {
 818                     public R {
 819                         x++;
 820                     }
 821                 }
 822                 &quot;&quot;&quot;);
 823     }
 824 
 825     public void testNoNativeMethods() {
 826         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;record R(int x) { # }&quot;,
 827                 &quot;public native R {}&quot;);
 828         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;record R(int x) { # }&quot;,
 829                 &quot;public native void m();&quot;);
 830     }
 831 
 832     public void testRecordsInsideInner() {
 833         assertFail(&quot;compiler.err.static.declaration.not.allowed.in.inner.classes&quot;,
 834                 &quot;&quot;&quot;
 835                 class Outer {
 836                     class Inner {
 837                         record R(int a) {}
 838                     }
 839                 }
 840                 &quot;&quot;&quot;
 841         );
 842         assertFail(&quot;compiler.err.static.declaration.not.allowed.in.inner.classes&quot;,
 843                 &quot;&quot;&quot;
 844                 class Outer {
 845                     public void test() {
 846                         class Inner extends Outer {
 847                             record R(int i) {}
 848                         }
 849                     }
 850                 }
 851                 &quot;&quot;&quot;);
 852         assertFail(&quot;compiler.err.static.declaration.not.allowed.in.inner.classes&quot;,
 853                 &quot;&quot;&quot;
 854                 class Outer {
 855                     Runnable run = new Runnable() {
 856                         record TestRecord(int i) {}
 857                         public void run() {}
 858                     };
 859                 }
 860                 &quot;&quot;&quot;);
 861         assertFail(&quot;compiler.err.static.declaration.not.allowed.in.inner.classes&quot;,
 862                 &quot;&quot;&quot;
 863                 class Outer {
 864                     void m() {
 865                         record A() {
 866                             record B() { }
 867                         }
 868                     }
 869                 }
 870                 &quot;&quot;&quot;);
 871     }
 872 
 873     public void testReceiverParameter() {
 874         assertFail(&quot;compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class&quot;,
 875                 &quot;&quot;&quot;
 876                 record R(int i) {
 877                     public R(R this, int i) {
 878                         this.i = i;
 879                     }
 880                 }
 881                 &quot;&quot;&quot;);
 882         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 883                 &quot;&quot;&quot;
 884                 class Outer {
 885                     record R(int i) {
 886                         public R(Outer Outer.this, int i) {
 887                             this.i = i;
 888                         }
 889                     }
 890                 }
 891                 &quot;&quot;&quot;);
 892         assertOK(
 893                 &quot;&quot;&quot;
 894                 record R(int i) {
 895                     void m(R this) {}
 896                     public int i(R this) { return i; }
 897                 }
 898                 &quot;&quot;&quot;);
 899     }
 900 
 901     public void testOnlyOneFieldRef() throws Exception {
 902         int numberOfFieldRefs = 0;
 903         File dir = assertOK(true, &quot;record R(int recordComponent) {}&quot;);
 904         for (final File fileEntry : dir.listFiles()) {
 905             if (fileEntry.getName().equals(&quot;R.class&quot;)) {
 906                 ClassFile classFile = ClassFile.read(fileEntry);
 907                 for (CPInfo cpInfo : classFile.constant_pool.entries()) {
 908                     if (cpInfo instanceof ConstantPool.CONSTANT_Fieldref_info) {
 909                         numberOfFieldRefs++;
 910                         ConstantPool.CONSTANT_NameAndType_info nameAndType =
 911                                 (ConstantPool.CONSTANT_NameAndType_info)classFile.constant_pool
 912                                         .get(((ConstantPool.CONSTANT_Fieldref_info)cpInfo).name_and_type_index);
 913                         Assert.check(nameAndType.getName().equals(&quot;recordComponent&quot;));
 914                     }
 915                 }
 916             }
 917         }
 918         Assert.check(numberOfFieldRefs == 1);
 919     }
 920 
 921     /*  check that fields are initialized in a canonical constructor in the same declaration order as the corresponding
 922      *  record component
 923      */
 924     public void testCheckInitializationOrderInCompactConstructor() throws Exception {
 925         int putField1 = -1;
 926         int putField2 = -1;
 927         File dir = assertOK(true, &quot;record R(int i, String s) { R {} }&quot;);
 928         for (final File fileEntry : dir.listFiles()) {
 929             if (fileEntry.getName().equals(&quot;R.class&quot;)) {
 930                 ClassFile classFile = ClassFile.read(fileEntry);
 931                 for (Method method : classFile.methods) {
 932                     if (method.getName(classFile.constant_pool).equals(&quot;&lt;init&gt;&quot;)) {
 933                         Code_attribute code_attribute = (Code_attribute) method.attributes.get(&quot;Code&quot;);
 934                         for (Instruction instruction : code_attribute.getInstructions()) {
 935                             if (instruction.getMnemonic().equals(&quot;putfield&quot;)) {
 936                                 if (putField1 != -1 &amp;&amp; putField2 != -1) {
 937                                     throw new AssertionError(&quot;was expecting only two putfield instructions in this method&quot;);
 938                                 }
 939                                 if (putField1 == -1) {
 940                                     putField1 = instruction.getShort(1);
 941                                 } else if (putField2 == -1) {
 942                                     putField2 = instruction.getShort(1);
 943                                 }
 944                             }
 945                         }
 946                         // now we need to check that we are assigning to `i` first and to `s` afterwards
 947                         CONSTANT_Fieldref_info fieldref_info1 = (CONSTANT_Fieldref_info)classFile.constant_pool.get(putField1);
 948                         if (!fieldref_info1.getNameAndTypeInfo().getName().equals(&quot;i&quot;)) {
 949                             throw new AssertionError(&quot;was expecting variable name &#39;i&#39;&quot;);
 950                         }
 951 
 952                         CONSTANT_Fieldref_info fieldref_info2 = (CONSTANT_Fieldref_info)classFile.constant_pool.get(putField2);
 953                         if (!fieldref_info2.getNameAndTypeInfo().getName().equals(&quot;s&quot;)) {
 954                             throw new AssertionError(&quot;was expecting variable name &#39;s&#39;&quot;);
 955                         }
 956                     }
 957                 }
 958             }
 959         }
 960     }
 961 
 962     public void testAcceptRecordId() {
 963         String[] previousOptions = getCompileOptions();
 964         String[] testOptions = {/* no options */};
 965         setCompileOptions(testOptions);
 966         assertOKWithWarning(&quot;compiler.warn.restricted.type.not.allowed.preview&quot;,
 967                 &quot;class R {\n&quot; +
 968                 &quot;    record RR(int i) {\n&quot; +
 969                 &quot;        return null;\n&quot; +
 970                 &quot;    }\n&quot; +
 971                 &quot;    class record {}\n&quot; +
 972                 &quot;}&quot;);
 973         setCompileOptions(previousOptions);
 974     }
 975 
 976     public void testAnnos() throws Exception {
 977         String[] previousOptions = getCompileOptions();
 978         String srcTemplate =
 979                 &quot;&quot;&quot;
 980                     import java.lang.annotation.*;
 981                     @Target({#TARGET})
 982                     @Retention(RetentionPolicy.RUNTIME)
 983                     @interface Anno { }
 984 
 985                     record R(@Anno String s) {}
 986                 &quot;&quot;&quot;;
 987 
 988         // testing several combinations, adding even more combinations won&#39;t add too much value
 989         List&lt;String&gt; annoApplicableTargets = List.of(
 990                 &quot;ElementType.FIELD&quot;,
 991                 &quot;ElementType.METHOD&quot;,
 992                 &quot;ElementType.PARAMETER&quot;,
 993                 &quot;ElementType.RECORD_COMPONENT&quot;,
 994                 &quot;ElementType.TYPE_USE&quot;,
 995                 &quot;ElementType.TYPE_USE,ElementType.FIELD&quot;,
 996                 &quot;ElementType.TYPE_USE,ElementType.METHOD&quot;,
 997                 &quot;ElementType.TYPE_USE,ElementType.PARAMETER&quot;,
 998                 &quot;ElementType.TYPE_USE,ElementType.RECORD_COMPONENT&quot;,
 999                 &quot;ElementType.TYPE_USE,ElementType.FIELD,ElementType.METHOD&quot;,
1000                 &quot;ElementType.TYPE_USE,ElementType.FIELD,ElementType.PARAMETER&quot;,
1001                 &quot;ElementType.TYPE_USE,ElementType.FIELD,ElementType.RECORD_COMPONENT&quot;,
1002                 &quot;ElementType.FIELD,ElementType.TYPE_USE&quot;,
1003                 &quot;ElementType.METHOD,ElementType.TYPE_USE&quot;,
1004                 &quot;ElementType.PARAMETER,ElementType.TYPE_USE&quot;,
1005                 &quot;ElementType.RECORD_COMPONENT,ElementType.TYPE_USE&quot;,
1006                 &quot;ElementType.FIELD,ElementType.METHOD,ElementType.TYPE_USE&quot;,
1007                 &quot;ElementType.FIELD,ElementType.PARAMETER,ElementType.TYPE_USE&quot;,
1008                 &quot;ElementType.FIELD,ElementType.RECORD_COMPONENT,ElementType.TYPE_USE&quot;
1009         );
1010 
1011         String[] generalOptions = {
1012                 &quot;--enable-preview&quot;,
1013                 &quot;-source&quot;, Integer.toString(Runtime.version().feature()),
1014                 &quot;-processor&quot;, Processor.class.getName(),
1015                 &quot;-Atargets=&quot;
1016         };
1017 
1018         for (String target : annoApplicableTargets) {
1019             String code = srcTemplate.replaceFirst(&quot;#TARGET&quot;, target);
1020             String[] testOptions = generalOptions.clone();
1021             testOptions[testOptions.length - 1] = testOptions[testOptions.length - 1] + target;
1022             setCompileOptions(testOptions);
1023 
1024             File dir = assertOK(true, code);
1025 
1026             ClassFile classFile = ClassFile.read(findClassFileOrFail(dir, &quot;R.class&quot;));
1027 
1028             // field first
1029             Assert.check(classFile.fields.length == 1);
1030             Field field = classFile.fields[0];
1031             /* if FIELD is one of the targets then there must be a declaration annotation applied to the field, apart from
1032              * the type annotation
1033              */
1034             if (target.contains(&quot;FIELD&quot;)) {
1035                 checkAnno(classFile,
1036                         (RuntimeAnnotations_attribute)findAttributeOrFail(
1037                                 field.attributes,
1038                                 RuntimeVisibleAnnotations_attribute.class),
1039                         &quot;Anno&quot;);
1040             } else {
1041                 assertAttributeNotPresent(field.attributes, RuntimeVisibleAnnotations_attribute.class);
1042             }
1043 
1044             // lets check now for the type annotation
1045             if (target.contains(&quot;TYPE_USE&quot;)) {
1046                 checkTypeAnno(
1047                         classFile,
1048                         (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class),
1049                         &quot;FIELD&quot;,
1050                         &quot;Anno&quot;);
1051             } else {
1052                 assertAttributeNotPresent(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class);
1053             }
1054 
1055             // checking for the annotation on the corresponding parameter of the canonical constructor
1056             Method init = findMethodOrFail(classFile, &quot;&lt;init&gt;&quot;);
1057             /* if PARAMETER is one of the targets then there must be a declaration annotation applied to the parameter, apart from
1058              * the type annotation
1059              */
1060             if (target.contains(&quot;PARAMETER&quot;)) {
1061                 checkParameterAnno(classFile,
1062                         (RuntimeVisibleParameterAnnotations_attribute)findAttributeOrFail(
1063                                 init.attributes,
1064                                 RuntimeVisibleParameterAnnotations_attribute.class),
1065                         &quot;Anno&quot;);
1066             } else {
1067                 assertAttributeNotPresent(init.attributes, RuntimeVisibleAnnotations_attribute.class);
1068             }
1069             // let&#39;s check now for the type annotation
1070             if (target.contains(&quot;TYPE_USE&quot;)) {
1071                 checkTypeAnno(
1072                         classFile,
1073                         (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class),
1074                         &quot;METHOD_FORMAL_PARAMETER&quot;, &quot;Anno&quot;);
1075             } else {
1076                 assertAttributeNotPresent(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class);
1077             }
1078 
1079             // checking for the annotation in the accessor
1080             Method accessor = findMethodOrFail(classFile, &quot;s&quot;);
1081             /* if METHOD is one of the targets then there must be a declaration annotation applied to the accessor, apart from
1082              * the type annotation
1083              */
1084             if (target.contains(&quot;METHOD&quot;)) {
1085                 checkAnno(classFile,
1086                         (RuntimeAnnotations_attribute)findAttributeOrFail(
1087                                 accessor.attributes,
1088                                 RuntimeVisibleAnnotations_attribute.class),
1089                         &quot;Anno&quot;);
1090             } else {
1091                 assertAttributeNotPresent(accessor.attributes, RuntimeVisibleAnnotations_attribute.class);
1092             }
1093             // let&#39;s check now for the type annotation
1094             if (target.contains(&quot;TYPE_USE&quot;)) {
1095                 checkTypeAnno(
1096                         classFile,
1097                         (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class),
1098                         &quot;METHOD_RETURN&quot;, &quot;Anno&quot;);
1099             } else {
1100                 assertAttributeNotPresent(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class);
1101             }
1102 
1103             // checking for the annotation in the Record attribute
1104             Record_attribute record = (Record_attribute)findAttributeOrFail(classFile.attributes, Record_attribute.class);
1105             Assert.check(record.component_count == 1);
1106             /* if RECORD_COMPONENT is one of the targets then there must be a declaration annotation applied to the
1107              * field, apart from the type annotation
1108              */
1109             if (target.contains(&quot;RECORD_COMPONENT&quot;)) {
1110                 checkAnno(classFile,
1111                         (RuntimeAnnotations_attribute)findAttributeOrFail(
1112                                 record.component_info_arr[0].attributes,
1113                                 RuntimeVisibleAnnotations_attribute.class),
1114                         &quot;Anno&quot;);
1115             } else {
1116                 assertAttributeNotPresent(record.component_info_arr[0].attributes, RuntimeVisibleAnnotations_attribute.class);
1117             }
1118             // lets check now for the type annotation
1119             if (target.contains(&quot;TYPE_USE&quot;)) {
1120                 checkTypeAnno(
1121                         classFile,
1122                         (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(
1123                                 record.component_info_arr[0].attributes,
1124                                 RuntimeVisibleTypeAnnotations_attribute.class),
1125                         &quot;FIELD&quot;, &quot;Anno&quot;);
1126             } else {
1127                 assertAttributeNotPresent(record.component_info_arr[0].attributes, RuntimeVisibleTypeAnnotations_attribute.class);
1128             }
1129         }
1130 
1131         // let&#39;s reset the default compiler options for other tests
1132         setCompileOptions(previousOptions);
1133     }
1134 
1135     private void checkTypeAnno(ClassFile classFile,
1136                                RuntimeTypeAnnotations_attribute rtAnnos,
1137                                String positionType,
1138                                String annoName) throws Exception {
1139         // containing only one type annotation
1140         Assert.check(rtAnnos.annotations.length == 1);
1141         TypeAnnotation tAnno = (TypeAnnotation)rtAnnos.annotations[0];
1142         Assert.check(tAnno.position.type.toString().equals(positionType));
1143         String annotationName = classFile.constant_pool.getUTF8Value(tAnno.annotation.type_index).toString().substring(1);
1144         Assert.check(annotationName.startsWith(annoName));
1145     }
1146 
1147     private void checkAnno(ClassFile classFile,
1148                            RuntimeAnnotations_attribute rAnnos,
1149                            String annoName) throws Exception {
1150         // containing only one type annotation
1151         Assert.check(rAnnos.annotations.length == 1);
1152         Annotation anno = (Annotation)rAnnos.annotations[0];
1153         String annotationName = classFile.constant_pool.getUTF8Value(anno.type_index).toString().substring(1);
1154         Assert.check(annotationName.startsWith(annoName));
1155     }
1156 
1157     // special case for parameter annotations
1158     private void checkParameterAnno(ClassFile classFile,
1159                            RuntimeVisibleParameterAnnotations_attribute rAnnos,
1160                            String annoName) throws Exception {
1161         // containing only one type annotation
1162         Assert.check(rAnnos.parameter_annotations.length == 1);
1163         Assert.check(rAnnos.parameter_annotations[0].length == 1);
1164         Annotation anno = (Annotation)rAnnos.parameter_annotations[0][0];
1165         String annotationName = classFile.constant_pool.getUTF8Value(anno.type_index).toString().substring(1);
1166         Assert.check(annotationName.startsWith(annoName));
1167     }
1168 
1169     private File findClassFileOrFail(File dir, String name) {
1170         for (final File fileEntry : dir.listFiles()) {
1171             if (fileEntry.getName().equals(&quot;R.class&quot;)) {
1172                 return fileEntry;
1173             }
1174         }
1175         throw new AssertionError(&quot;file not found&quot;);
1176     }
1177 
1178     private Method findMethodOrFail(ClassFile classFile, String name) throws Exception {
1179         for (Method method : classFile.methods) {
1180             if (method.getName(classFile.constant_pool).equals(name)) {
1181                 return method;
1182             }
1183         }
1184         throw new AssertionError(&quot;method not found&quot;);
1185     }
1186 
1187     private Attribute findAttributeOrFail(Attributes attributes, Class&lt;? extends Attribute&gt; attrClass) {
1188         for (Attribute attribute : attributes) {
1189             if (attribute.getClass() == attrClass) {
1190                 return attribute;
1191             }
1192         }
1193         throw new AssertionError(&quot;attribute not found&quot;);
1194     }
1195 
1196     private void assertAttributeNotPresent(Attributes attributes, Class&lt;? extends Attribute&gt; attrClass) {
1197         for (Attribute attribute : attributes) {
1198             if (attribute.getClass() == attrClass) {
1199                 throw new AssertionError(&quot;attribute not expected&quot;);
1200             }
1201         }
1202     }
1203 
1204     @SupportedAnnotationTypes(&quot;*&quot;)
1205     public static final class Processor extends JavacTestingAbstractProcessor {
1206 
1207         String targets;
1208         int numberOfTypeAnnotations;
1209 
1210         @Override
1211         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
1212             targets = processingEnv.getOptions().get(&quot;targets&quot;);
1213             for (TypeElement te : annotations) {
1214                 if (te.toString().equals(&quot;Anno&quot;)) {
1215                     checkElements(te, roundEnv, targets);
1216                     if (targets.contains(&quot;TYPE_USE&quot;)) {
1217                         Element element = processingEnv.getElementUtils().getTypeElement(&quot;R&quot;);
1218                         numberOfTypeAnnotations = 0;
1219                         checkTypeAnnotations(element);
1220                         Assert.check(numberOfTypeAnnotations == 4);
1221                     }
1222                 }
1223             }
1224             return true;
1225         }
1226 
1227         void checkElements(TypeElement te, RoundEnvironment renv, String targets) {
1228             Set&lt;? extends Element&gt; annoElements = renv.getElementsAnnotatedWith(te);
1229             Set&lt;String&gt; targetSet = new HashSet&lt;&gt;(Arrays.asList(targets.split(&quot;,&quot;)));
1230             // we will check for type annotation in another method
1231             targetSet.remove(&quot;ElementType.TYPE_USE&quot;);
1232             for (Element e : annoElements) {
1233                 Symbol s = (Symbol) e;
1234                 switch (s.getKind()) {
1235                     case FIELD:
1236                         Assert.check(targetSet.contains(&quot;ElementType.FIELD&quot;));
1237                         targetSet.remove(&quot;ElementType.FIELD&quot;);
1238                         break;
1239                     case METHOD:
1240                         Assert.check(targetSet.contains(&quot;ElementType.METHOD&quot;));
1241                         targetSet.remove(&quot;ElementType.METHOD&quot;);
1242                         break;
1243                     case PARAMETER:
1244                         Assert.check(targetSet.contains(&quot;ElementType.PARAMETER&quot;));
1245                         targetSet.remove(&quot;ElementType.PARAMETER&quot;);
1246                         break;
1247                     case RECORD_COMPONENT:
1248                         Assert.check(targetSet.contains(&quot;ElementType.RECORD_COMPONENT&quot;));
1249                         targetSet.remove(&quot;ElementType.RECORD_COMPONENT&quot;);
1250                         break;
1251                     default:
1252                         throw new AssertionError(&quot;unexpected element kind&quot;);
1253                 }
1254             }
1255             Assert.check(targetSet.isEmpty(), targetSet.toString());
1256         }
1257 
1258         private void checkTypeAnnotations(Element rootElement) {
1259             new ElementScanner&lt;Void, Void&gt;() {
1260                 @Override public Void visitVariable(VariableElement e, Void p) {
1261                     Symbol s = (Symbol) e;
1262                     if (s.getKind() == ElementKind.FIELD ||
1263                             s.getKind() == ElementKind.PARAMETER &amp;&amp;
1264                             s.name.toString().equals(&quot;s&quot;)) {
1265                         int currentTAs = numberOfTypeAnnotations;
1266                         verifyTypeAnnotations(e.asType().getAnnotationMirrors());
1267                         Assert.check(currentTAs + 1 == numberOfTypeAnnotations);
1268                     }
1269                     return null;
1270                 }
1271                 @Override
1272                 public Void visitExecutable(ExecutableElement e, Void p) {
1273                     Symbol s = (Symbol) e;
1274                     if (s.getKind() == ElementKind.METHOD &amp;&amp;
1275                                     s.name.toString().equals(&quot;s&quot;)) {
1276                         int currentTAs = numberOfTypeAnnotations;
1277                         verifyTypeAnnotations(e.getReturnType().getAnnotationMirrors());
1278                         Assert.check(currentTAs + 1 == numberOfTypeAnnotations);
1279                     }
1280                     scan(e.getParameters(), p);
1281                     return null;
1282                 }
1283                 @Override public Void visitRecordComponent(RecordComponentElement e, Void p) {
1284                     int currentTAs = numberOfTypeAnnotations;
1285                     verifyTypeAnnotations(e.asType().getAnnotationMirrors());
1286                     Assert.check(currentTAs + 1 == numberOfTypeAnnotations);
1287                     return null;
1288                 }
1289             }.scan(rootElement, null);
1290         }
1291 
1292         private void verifyTypeAnnotations(Iterable&lt;? extends AnnotationMirror&gt; annotations) {
1293             for (AnnotationMirror mirror : annotations) {
1294                 Assert.check(mirror.toString().startsWith(&quot;@Anno&quot;));
1295                 if (mirror instanceof TypeCompound) {
1296                     numberOfTypeAnnotations++;
1297                 }
1298             }
1299         }
1300     }
1301 
1302     public void testMethodsInheritedFromRecordArePublicAndFinal() throws Exception {
1303         int numberOfFieldRefs = 0;
1304         File dir = assertOK(true, &quot;record R() {}&quot;);
1305         for (final File fileEntry : dir.listFiles()) {
1306             if (fileEntry.getName().equals(&quot;R.class&quot;)) {
1307                 ClassFile classFile = ClassFile.read(fileEntry);
1308                 for (Method method : classFile.methods)
1309                     switch (method.getName(classFile.constant_pool)) {
1310                         case &quot;toString&quot;, &quot;equals&quot;, &quot;hashCode&quot; -&gt;
1311                             Assert.check(method.access_flags.is(AccessFlags.ACC_PUBLIC) &amp;&amp; method.access_flags.is(AccessFlags.ACC_FINAL));
1312                         default -&gt; { /* do nothing */ }
1313                     }
1314             }
1315         }
1316     }
1317 
1318     private static final List&lt;String&gt; ACCESSIBILITY = List.of(
1319             &quot;public&quot;, &quot;protected&quot;, &quot;&quot;, &quot;private&quot;);
1320 
1321     public void testCanonicalAccessibility() throws Exception {
1322         // accessibility of canonical can&#39;t be stronger than that of the record type
1323         for (String a1 : ACCESSIBILITY) {
1324             for (String a2 : ACCESSIBILITY) {
1325                 if (protection(a2) &gt; protection(a1)) {
1326                     assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;class R {# record RR() { # RR {} } }&quot;, a1, a2);
1327                 } else {
1328                     assertOK(&quot;class R {# record RR() { # RR {} } }&quot;, a1, a2);
1329                 }
1330             }
1331         }
1332 
1333         // now lets check that when compiler the compiler generates the canonical, it has the same accessibility
1334         // as the record type
1335         for (String a : ACCESSIBILITY) {
1336             File dir = assertOK(true, &quot;class R {# record RR() {} }&quot;, a);
1337             for (final File fileEntry : dir.listFiles()) {
1338                 if (fileEntry.getName().equals(&quot;R$RR.class&quot;)) {
1339                     ClassFile classFile = ClassFile.read(fileEntry);
1340                     for (Method method : classFile.methods)
1341                         if (method.getName(classFile.constant_pool).equals(&quot;&lt;init&gt;&quot;)) {
1342                             Assert.check(method.access_flags.flags == accessFlag(a),
1343                                     &quot;was expecting access flag &quot; + accessFlag(a) + &quot; but found &quot; + method.access_flags.flags);
1344                         }
1345                 }
1346             }
1347         }
1348     }
1349 
1350     private int protection(String access) {
1351         switch (access) {
1352             case &quot;private&quot;: return 3;
1353             case &quot;protected&quot;: return 1;
1354             case &quot;public&quot;: return 0;
1355             case &quot;&quot;: return 2;
1356             default:
1357                 throw new AssertionError();
1358         }
1359     }
1360 
1361     private int accessFlag(String access) {
1362         switch (access) {
1363             case &quot;private&quot;: return AccessFlags.ACC_PRIVATE;
1364             case &quot;protected&quot;: return AccessFlags.ACC_PROTECTED;
1365             case &quot;public&quot;: return AccessFlags.ACC_PUBLIC;
1366             case &quot;&quot;: return 0;
1367             default:
1368                 throw new AssertionError();
1369         }
1370     }
1371 
1372     public void testSameArity() {
1373         for (String source : List.of(
1374                 &quot;&quot;&quot;
1375                 record R(int... args) {
1376                     public R(int... args) {
1377                         this.args = args;
1378                     }
1379                 }
1380                 &quot;&quot;&quot;,
1381                 &quot;&quot;&quot;
1382                 record R(int[] args) {
1383                     public R(int[] args) {
1384                         this.args = args;
1385                     }
1386                 }
1387                 &quot;&quot;&quot;,
1388                 &quot;&quot;&quot;
1389                 record R(@A int... ints) {}
1390 
1391                 @java.lang.annotation.Target({
1392                         java.lang.annotation.ElementType.TYPE_USE,
1393                         java.lang.annotation.ElementType.RECORD_COMPONENT})
1394                 @interface A {}
1395                 &quot;&quot;&quot;,
1396                 &quot;&quot;&quot;
1397                 record R(@A int... ints) {
1398                     R(@A int... ints) {
1399                         this.ints = ints;
1400                     }
1401                 }
1402 
1403                 @java.lang.annotation.Target({
1404                         java.lang.annotation.ElementType.TYPE_USE,
1405                         java.lang.annotation.ElementType.RECORD_COMPONENT})
1406                 @interface A {}
1407                 &quot;&quot;&quot;
1408         )) {
1409             assertOK(source);
1410         }
1411 
1412         for (String source : List.of(
1413                 &quot;&quot;&quot;
1414                 record R(int... args) {
1415                     public R(int[] args) {
1416                         this.args = args;
1417                     }
1418                 }
1419                 &quot;&quot;&quot;,
1420                 &quot;&quot;&quot;
1421                 record R(int... args) {
1422                     public R(int[] args) {
1423                         this.args = args;
1424                     }
1425                 }
1426                 &quot;&quot;&quot;,
1427                 &quot;&quot;&quot;
1428                 record R(String... args) {
1429                     public R(String[] args) {
1430                         this.args = args;
1431                     }
1432                 }
1433                 &quot;&quot;&quot;,
1434                 &quot;&quot;&quot;
1435                 record R(String... args) {
1436                     public R(String[] args) {
1437                         this.args = args;
1438                     }
1439                 }
1440                 &quot;&quot;&quot;
1441         )) {
1442             assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, source);
1443         }
1444     }
1445 
1446     public void testSafeVararsAnno() {
1447         assertFail(&quot;compiler.err.annotation.type.not.applicable&quot;,
1448                 &quot;&quot;&quot;
1449                 @SafeVarargs
1450                 record R&lt;T&gt;(T... t) {}
1451                 &quot;&quot;&quot;,
1452                 &quot;&quot;&quot;
1453                 @SafeVarargs
1454                 record R&lt;T&gt;(T... t) {
1455                     R(T... t) {
1456                         this.t = t;
1457                     }
1458                 }
1459                 &quot;&quot;&quot;
1460         );
1461 
1462         assertOK(
1463                 &quot;&quot;&quot;
1464                 record R&lt;T&gt;(T... t) {
1465                     @SafeVarargs
1466                     R(T... t) {
1467                         this.t = t;
1468                     }
1469                 }
1470                 &quot;&quot;&quot;
1471         );
1472 
1473         appendCompileOptions(&quot;-Xlint:unchecked&quot;);
1474         assertOKWithWarning(&quot;compiler.warn.unchecked.varargs.non.reifiable.type&quot;,
1475                 &quot;&quot;&quot;
1476                 record R&lt;T&gt;(T... t) {
1477                     R(T... t) {
1478                         this.t = t;
1479                     }
1480                 }
1481                 &quot;&quot;&quot;
1482         );
1483         removeLastCompileOptions(1);
1484 
1485         assertOK(
1486                 &quot;&quot;&quot;
1487                 @SuppressWarnings(&quot;unchecked&quot;)
1488                 record R&lt;T&gt;(T... t) {
1489                     R(T... t) {
1490                         this.t = t;
1491                     }
1492                 }
1493                 &quot;&quot;&quot;
1494         );
1495 
1496         assertOK(
1497                 &quot;&quot;&quot;
1498                 record R&lt;T&gt;(T... t) {
1499                     @SuppressWarnings(&quot;unchecked&quot;)
1500                     R(T... t) {
1501                         this.t = t;
1502                     }
1503                 }
1504                 &quot;&quot;&quot;
1505         );
1506     }
1507 
1508     public void testOverrideAtAccessor() {
1509         assertOK(
1510                 &quot;&quot;&quot;
1511                 record R(int i) {
1512                     @Override
1513                     public int i() { return i; }
1514                 }
1515                 &quot;&quot;&quot;,
1516                 &quot;&quot;&quot;
1517                 record R(int i, int j) {
1518                     @Override
1519                     public int i() { return i; }
1520                     public int j() { return j; }
1521                 }
1522                 &quot;&quot;&quot;,
1523                 &quot;&quot;&quot;
1524                 interface I { int i(); }
1525                 record R(int i) implements I {
1526                     @Override
1527                     public int i() { return i; }
1528                 }
1529                 &quot;&quot;&quot;,
1530                 &quot;&quot;&quot;
1531                 interface I { int i(); }
1532                 record R(int i) implements I {
1533                     public int i() { return i; }
1534                 }
1535                 &quot;&quot;&quot;,
1536                 &quot;&quot;&quot;
1537                 interface I { default int i() { return 0; } }
1538                 record R(int i) implements I {
1539                     @Override
1540                     public int i() { return i; }
1541                 }
1542                 &quot;&quot;&quot;
1543         );
1544     }
1545 
1546     public void testNoAssigmentInsideCompactRecord() {
1547         assertFail(&quot;compiler.err.cant.assign.val.to.final.var&quot;,
1548                 &quot;&quot;&quot;
1549                 record R(int i) {
1550                     R {
1551                         this.i = i;
1552                     }
1553                 }
1554                 &quot;&quot;&quot;
1555         );
1556         assertFail(&quot;compiler.err.cant.assign.val.to.final.var&quot;,
1557                 &quot;&quot;&quot;
1558                 record R(int i) {
1559                     R {
1560                         (this).i = i;
1561                     }
1562                 }
1563                 &quot;&quot;&quot;
1564         );
1565     }
1566 }
    </pre>
  </body>
</html>