<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sun/security/tools/jarsigner/TimestampCheck.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.ByteArrayInputStream;
 25 import java.io.File;
 26 import java.io.IOException;
 27 import java.io.InputStream;
 28 import java.math.BigInteger;
 29 import java.nio.file.Files;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import java.security.KeyStore;
 33 import java.security.cert.CertificateException;
 34 import java.security.cert.CertificateFactory;
 35 import java.security.cert.X509Certificate;
 36 import java.time.Instant;
 37 import java.time.temporal.ChronoUnit;
 38 import java.util.ArrayList;
 39 import java.util.Arrays;
 40 import java.util.Date;
 41 import java.util.List;
 42 import java.util.Map;
 43 import java.util.jar.JarEntry;
 44 import java.util.jar.JarFile;
 45 
 46 import com.sun.net.httpserver.HttpExchange;
 47 
 48 import jdk.test.lib.SecurityTools;
 49 import jdk.test.lib.process.OutputAnalyzer;
 50 import jdk.test.lib.security.KeyStoreUtils;
 51 import jdk.test.lib.security.timestamp.*;
 52 import jdk.test.lib.util.JarUtils;
 53 import sun.security.pkcs.PKCS7;
 54 import sun.security.pkcs.PKCS9Attribute;
 55 import sun.security.pkcs.SignerInfo;
 56 import sun.security.timestamp.TimestampToken;
 57 
 58 /*
 59  * @test
 60  * @bug 6543842 6543440 6939248 8009636 8024302 8163304 8169911 8180289 8172404 8247960
 61  * @summary checking response of timestamp
 62  * @modules java.base/sun.security.pkcs
 63  *          java.base/sun.security.timestamp
 64  *          java.base/sun.security.x509
 65  *          java.base/sun.security.util
 66  *          java.base/sun.security.tools.keytool
 67  * @library /lib/testlibrary
 68  * @library /test/lib
 69  * @build jdk.test.lib.util.JarUtils
 70  *        jdk.test.lib.SecurityTools
 71  *        jdk.test.lib.Utils
 72  *        jdk.test.lib.Asserts
 73  *        jdk.test.lib.JDKToolFinder
 74  *        jdk.test.lib.JDKToolLauncher
 75  *        jdk.test.lib.Platform
 76  *        jdk.test.lib.process.*
 77  * @compile -XDignore.symbol.file TimestampCheck.java
 78  * @run main/timeout=600 TimestampCheck
 79  */
 80 public class TimestampCheck {
 81 
 82     private static final String PASSWORD = &quot;changeit&quot;;
 83     private static final String defaultPolicyId = &quot;2.3.4&quot;;
 84     private static String host = null;
 85 
 86     private static class Interceptor implements RespInterceptor {
 87 
 88         private final String path;
 89 
 90         Interceptor(String path) {
 91             this.path = path;
 92         }
 93 
 94         @Override
 95         public X509Certificate[] getSignerCertChain(
 96                 X509Certificate[] signerCertChain, boolean certReq)
 97                 throws Exception {
 98             if (path.equals(&quot;fullchain&quot;)) { // Only case 5 uses full chain
 99                 return signerCertChain;
100             } else if (path.equals(&quot;nocert&quot;)) {
101                 return new X509Certificate[0];
102             } else {
103                 return new X509Certificate[] { signerCertChain[0] };
104             }
105         }
106 
107         @Override
108         public String getSigAlgo(String sigAlgo) throws Exception {
109             return &quot;SHA256withRSA&quot;;
110         }
111 
112         @Override
113         public TsaParam getRespParam(TsaParam reqParam) {
114             TsaParam respParam = RespInterceptor.super.getRespParam(reqParam);
115 
116             String policyId
117                     = respParam.policyId() == null || path.equals(&quot;diffpolicy&quot;)
118                     ? TimestampCheck.defaultPolicyId
119                     : respParam.policyId();
120             respParam.policyId(policyId);
121 
122             String digestAlgo = respParam.digestAlgo();
123             if (path.equals(&quot;diffalg&quot;)) {
124                 digestAlgo = digestAlgo.contains(&quot;256&quot;)
125                         ? &quot;SHA-1&quot; : &quot;SHA-256&quot;;
126             }
127             respParam.digestAlgo(digestAlgo);
128 
129             byte[] hashedMessage = respParam.hashedMessage();
130             if (path.equals(&quot;baddigest&quot;)) {
131                 hashedMessage[hashedMessage.length - 1] = (byte) 0x01;
132                 hashedMessage[hashedMessage.length - 2] = (byte) 0x02;
133                 hashedMessage[hashedMessage.length - 3] = (byte) 0x03;
134             }
135             respParam.hashedMessage(hashedMessage);
136 
137             Instant instant = Instant.now();
138             if (path.equals(&quot;tsold&quot;)) {
139                 instant = instant.minus(20, ChronoUnit.DAYS);
140             }
141             respParam.genTime(Date.from(instant));
142 
143             BigInteger nonce = respParam.nonce();
144             if (path.equals(&quot;diffnonce&quot;)) {
145                 nonce = BigInteger.valueOf(1234);
146             } else if (path.equals(&quot;nononce&quot;)) {
147                 nonce = null;
148             }
149             respParam.nonce(nonce);
150 
151             return respParam;
152         }
153     }
154 
155     private static class Handler extends TsaHandler {
156 
157         Handler(String keystore) throws Exception {
158             super(KeyStoreUtils.loadKeyStore(keystore, PASSWORD), PASSWORD);
159         }
160 
161         public TsaSigner createSigner(HttpExchange exchange)
162                 throws Exception {
163             String path = exchange.getRequestURI().getPath().substring(1);
164 
165             SignerEntry signerEntry = createSignerEntry(
166                     path.startsWith(&quot;ts&quot;) ? path : &quot;ts&quot;);
167             byte[] requestData = exchange.getRequestBody().readAllBytes();
168             RespInterceptor interceptor = new Interceptor(path);
169             return new TsaSigner(signerEntry, requestData, interceptor);
170         }
171     }
172 
173     private static TsaServer initServer(String keystore) throws Exception {
174         return new TsaServer(0, new Handler(keystore));
175     }
176 
177     public static void main(String[] args) throws Throwable {
178         prepare();
179 
180         try (TsaServer tsa = initServer(&quot;ks&quot;);) {
181             tsa.start();
182             int port = tsa.getPort();
183             host = &quot;http://localhost:&quot; + port + &quot;/&quot;;
184 
185             if (args.length == 0) {         // Run this test
186 
187                 sign(&quot;normal&quot;)
188                         .shouldNotContain(&quot;Warning&quot;)
189                         .shouldContain(&quot;The signer certificate will expire on&quot;)
190                         .shouldContain(&quot;The timestamp will expire on&quot;)
191                         .shouldHaveExitValue(0);
192 
193                 verify(&quot;normal.jar&quot;)
194                         .shouldNotContain(&quot;Warning&quot;)
195                         .shouldHaveExitValue(0);
196 
197                 verify(&quot;normal.jar&quot;, &quot;-verbose&quot;)
198                         .shouldNotContain(&quot;Warning&quot;)
199                         .shouldContain(&quot;The signer certificate will expire on&quot;)
200                         .shouldContain(&quot;The timestamp will expire on&quot;)
201                         .shouldHaveExitValue(0);
202 
203                 // Simulate signing at a previous date:
204                 // 1. tsold will create a timestamp of 20 days ago.
205                 // 2. oldsigner expired 10 days ago.
206                 signVerbose(&quot;tsold&quot;, &quot;unsigned.jar&quot;, &quot;tsold.jar&quot;, &quot;oldsigner&quot;)
207                         .shouldNotContain(&quot;Warning&quot;)
208                         .shouldMatch(&quot;signer certificate expired on .*. &quot;
209                                 + &quot;However, the JAR will be valid&quot;)
210                         .shouldHaveExitValue(0);
211 
212                 // It verifies perfectly.
213                 verify(&quot;tsold.jar&quot;, &quot;-verbose&quot;, &quot;-certs&quot;)
214                         .shouldNotContain(&quot;Warning&quot;)
215                         .shouldMatch(&quot;signer certificate expired on .*. &quot;
216                                 + &quot;However, the JAR will be valid&quot;)
217                         .shouldHaveExitValue(0);
218 
219                 // No timestamp
220                 signVerbose(null, &quot;unsigned.jar&quot;, &quot;none.jar&quot;, &quot;signer&quot;)
221                         .shouldContain(&quot;is not timestamped&quot;)
222                         .shouldContain(&quot;The signer certificate will expire on&quot;)
223                         .shouldHaveExitValue(0);
224 
225                 verify(&quot;none.jar&quot;, &quot;-verbose&quot;)
226                         .shouldContain(&quot;do not include a timestamp&quot;)
227                         .shouldContain(&quot;The signer certificate will expire on&quot;)
228                         .shouldHaveExitValue(0);
229 
230                 // Error cases
231 
232                 signVerbose(null, &quot;unsigned.jar&quot;, &quot;badku.jar&quot;, &quot;badku&quot;)
233                         .shouldContain(&quot;KeyUsage extension doesn&#39;t allow code signing&quot;)
234                         .shouldHaveExitValue(8);
235                 checkBadKU(&quot;badku.jar&quot;);
236 
237                 // 8180289: unvalidated TSA cert chain
238                 sign(&quot;tsnoca&quot;)
239                         .shouldContain(&quot;The TSA certificate chain is invalid. &quot;
240                                 + &quot;Reason: Path does not chain with any of the trust anchors&quot;)
241                         .shouldHaveExitValue(64);
242 
243                 verify(&quot;tsnoca.jar&quot;, &quot;-verbose&quot;, &quot;-certs&quot;)
244                         .shouldHaveExitValue(64)
245                         .shouldContain(&quot;jar verified&quot;)
246                         .shouldContain(&quot;Invalid TSA certificate chain: &quot;
247                                 + &quot;Path does not chain with any of the trust anchors&quot;)
248                         .shouldContain(&quot;TSA certificate chain is invalid.&quot;
249                                 + &quot; Reason: Path does not chain with any of the trust anchors&quot;);
250 
251                 sign(&quot;nononce&quot;)
252                         .shouldContain(&quot;Nonce missing in timestamp token&quot;)
253                         .shouldHaveExitValue(1);
254                 sign(&quot;diffnonce&quot;)
255                         .shouldContain(&quot;Nonce changed in timestamp token&quot;)
256                         .shouldHaveExitValue(1);
257                 sign(&quot;baddigest&quot;)
258                         .shouldContain(&quot;Digest octets changed in timestamp token&quot;)
259                         .shouldHaveExitValue(1);
260                 sign(&quot;diffalg&quot;)
261                         .shouldContain(&quot;Digest algorithm not&quot;)
262                         .shouldHaveExitValue(1);
263 
264                 sign(&quot;fullchain&quot;)
265                         .shouldHaveExitValue(0);   // Success, 6543440 solved.
266 
267                 sign(&quot;tsbad1&quot;)
268                         .shouldContain(&quot;Certificate is not valid for timestamping&quot;)
269                         .shouldHaveExitValue(1);
270                 sign(&quot;tsbad2&quot;)
271                         .shouldContain(&quot;Certificate is not valid for timestamping&quot;)
272                         .shouldHaveExitValue(1);
273                 sign(&quot;tsbad3&quot;)
274                         .shouldContain(&quot;Certificate is not valid for timestamping&quot;)
275                         .shouldHaveExitValue(1);
276                 sign(&quot;nocert&quot;)
277                         .shouldContain(&quot;Certificate not included in timestamp token&quot;)
278                         .shouldHaveExitValue(1);
279 
280                 sign(&quot;policy&quot;, &quot;-tsapolicyid&quot;,  &quot;1.2.3&quot;)
281                         .shouldHaveExitValue(0);
282                 checkTimestamp(&quot;policy.jar&quot;, &quot;1.2.3&quot;, &quot;SHA-256&quot;);
283 
284                 sign(&quot;diffpolicy&quot;, &quot;-tsapolicyid&quot;, &quot;1.2.3&quot;)
285                         .shouldContain(&quot;TSAPolicyID changed in timestamp token&quot;)
286                         .shouldHaveExitValue(1);
287 
288                 sign(&quot;sha384alg&quot;, &quot;-tsadigestalg&quot;, &quot;SHA-384&quot;)
289                         .shouldHaveExitValue(0);
290                 checkTimestamp(&quot;sha384alg.jar&quot;, defaultPolicyId, &quot;SHA-384&quot;);
291 
292                 // Legacy algorithms
293                 signVerbose(null, &quot;unsigned.jar&quot;, &quot;sha1alg.jar&quot;, &quot;signer&quot;,
294                         &quot;-strict&quot;, &quot;-digestalg&quot;, &quot;SHA-1&quot;)
295                         .shouldHaveExitValue(0)
296                         .shouldContain(&quot;jar signed&quot;)
297                         .shouldNotContain(&quot;with signer errors&quot;)
298                         .shouldMatch(&quot;SHA-1.*-digestalg.*will be disabled&quot;);
299                 verify(&quot;sha1alg.jar&quot;, &quot;-strict&quot;)
300                         .shouldHaveExitValue(0)
301                         .shouldContain(&quot;jar verified&quot;)
302                         .shouldNotContain(&quot;with signer errors&quot;)
303                         .shouldContain(&quot;SHA-1 digest algorithm is considered a security risk&quot;)
304                         .shouldContain(&quot;This algorithm will be disabled in a future update&quot;)
305                         .shouldNotContain(&quot;is disabled&quot;);
306 
307                 sign(&quot;sha1tsaalg&quot;, &quot;-tsadigestalg&quot;, &quot;SHA-1&quot;, &quot;-strict&quot;)
308                         .shouldHaveExitValue(0)
309                         .shouldContain(&quot;jar signed&quot;)
310                         .shouldNotContain(&quot;with signer errors&quot;)
311                         .shouldMatch(&quot;SHA-1.*-tsadigestalg.*will be disabled&quot;)
312                         .shouldNotContain(&quot;is disabled&quot;);
313                 verify(&quot;sha1tsaalg.jar&quot;, &quot;-strict&quot;)
314                         .shouldHaveExitValue(0)
315                         .shouldContain(&quot;jar verified&quot;)
316                         .shouldNotContain(&quot;with signer errors&quot;)
317                         .shouldContain(&quot;SHA-1 timestamp digest algorithm is considered a security risk&quot;)
318                         .shouldNotContain(&quot;is disabled&quot;);
319 
320                 // Disabled algorithms
321                 sign(&quot;tsdisabled&quot;, &quot;-digestalg&quot;, &quot;MD5&quot;,
322                                 &quot;-sigalg&quot;, &quot;MD5withRSA&quot;, &quot;-tsadigestalg&quot;, &quot;MD5&quot;)
323                         .shouldHaveExitValue(68)
324                         .shouldContain(&quot;The timestamp is invalid. Without a valid timestamp&quot;)
325                         .shouldMatch(&quot;MD5.*-digestalg.*is disabled&quot;)
326                         .shouldMatch(&quot;MD5.*-tsadigestalg.*is disabled&quot;)
327                         .shouldMatch(&quot;MD5withRSA.*-sigalg.*is disabled&quot;);
328                 checkDisabled(&quot;tsdisabled.jar&quot;);
329 
330                 signVerbose(&quot;tsdisabled&quot;, &quot;unsigned.jar&quot;, &quot;tsdisabled2.jar&quot;, &quot;signer&quot;)
331                         .shouldHaveExitValue(64)
332                         .shouldContain(&quot;The timestamp is invalid. Without a valid timestamp&quot;)
333                         .shouldContain(&quot;TSA certificate chain is invalid&quot;);
334 
335                 // Disabled timestamp is an error and jar treated unsigned
336                 verify(&quot;tsdisabled2.jar&quot;, &quot;-verbose&quot;)
337                         .shouldHaveExitValue(16)
338                         .shouldContain(&quot;treated as unsigned&quot;)
339                         .shouldMatch(&quot;Timestamp.*512.*(disabled)&quot;);
340 
341                 // Algorithm used in signing is disabled
342                 signVerbose(&quot;normal&quot;, &quot;unsigned.jar&quot;, &quot;halfDisabled.jar&quot;, &quot;signer&quot;,
343                         &quot;-digestalg&quot;, &quot;MD5&quot;)
344                         .shouldContain(&quot;-digestalg option is considered a security risk and is disabled&quot;)
345                         .shouldHaveExitValue(4);
346                 checkHalfDisabled(&quot;halfDisabled.jar&quot;);
347 
348                 // sign with DSA key
349                 signVerbose(&quot;normal&quot;, &quot;unsigned.jar&quot;, &quot;sign1.jar&quot;, &quot;dsakey&quot;)
350                         .shouldHaveExitValue(0);
351 
352                 // sign with RSAkeysize &lt; 1024
353                 signVerbose(&quot;normal&quot;, &quot;sign1.jar&quot;, &quot;sign2.jar&quot;, &quot;disabledkeysize&quot;)
354                         .shouldContain(&quot;Algorithm constraints check failed on keysize&quot;)
355                         .shouldHaveExitValue(4);
356                 checkMultiple(&quot;sign2.jar&quot;);
357 
358                 // Legacy algorithms
359                 sign(&quot;tsweak&quot;, &quot;-digestalg&quot;, &quot;SHA1&quot;,
360                                 &quot;-sigalg&quot;, &quot;SHA1withRSA&quot;, &quot;-tsadigestalg&quot;, &quot;SHA1&quot;)
361                         .shouldHaveExitValue(0)
362                         .shouldMatch(&quot;SHA1.*-digestalg.*will be disabled&quot;)
363                         .shouldMatch(&quot;SHA1.*-tsadigestalg.*will be disabled&quot;)
364                         .shouldMatch(&quot;SHA1withRSA.*-sigalg.*will be disabled&quot;);
365                 checkWeak(&quot;tsweak.jar&quot;);
366 
367                 signVerbose(&quot;tsweak&quot;, &quot;unsigned.jar&quot;, &quot;tsweak2.jar&quot;, &quot;signer&quot;)
368                         .shouldHaveExitValue(0);
369 
370                 verify(&quot;tsweak2.jar&quot;, &quot;-verbose&quot;)
371                         .shouldHaveExitValue(0)
372                         .shouldContain(&quot;jar verified&quot;)
373                         .shouldMatch(&quot;Timestamp.*1024.*(weak)&quot;);
374 
375                 // Algorithm used in signing is weak
376                 signVerbose(&quot;normal&quot;, &quot;unsigned.jar&quot;, &quot;halfWeak.jar&quot;, &quot;signer&quot;,
377                         &quot;-digestalg&quot;, &quot;SHA1&quot;)
378                         .shouldContain(&quot;-digestalg option is considered a security risk.&quot;)
379                         .shouldContain(&quot;This algorithm will be disabled in a future update.&quot;)
380                         .shouldHaveExitValue(0);
381                 checkHalfWeak(&quot;halfWeak.jar&quot;);
382 
383                 // sign with DSA key
384                 signVerbose(&quot;normal&quot;, &quot;unsigned.jar&quot;, &quot;sign1.jar&quot;, &quot;dsakey&quot;)
385                         .shouldHaveExitValue(0);
386 
387                 // sign with RSAkeysize &lt; 2048
388                 signVerbose(&quot;normal&quot;, &quot;sign1.jar&quot;, &quot;sign2.jar&quot;, &quot;weakkeysize&quot;)
389                         .shouldNotContain(&quot;Algorithm constraints check failed on keysize&quot;)
390                         .shouldHaveExitValue(0);
391                 checkMultipleWeak(&quot;sign2.jar&quot;);
392 
393 
394                 // 8191438: jarsigner should print when a timestamp will expire
395                 checkExpiration();
396 
397                 // When .SF or .RSA is missing or invalid
398                 checkMissingOrInvalidFiles(&quot;normal.jar&quot;);
399 
400                 if (Files.exists(Paths.get(&quot;ts2.cert&quot;))) {
401                     checkInvalidTsaCertKeyUsage();
402                 }
403             } else {                        // Run as a standalone server
404                 System.out.println(&quot;TSA started at &quot; + host
405                         + &quot;. Press Enter to quit server&quot;);
406                 System.in.read();
407             }
408         }
409     }
410 
411     private static void checkExpiration() throws Exception {
412 
413         // Warning when expired or expiring
414         signVerbose(null, &quot;unsigned.jar&quot;, &quot;expired.jar&quot;, &quot;expired&quot;)
415                 .shouldContain(&quot;signer certificate has expired&quot;)
416                 .shouldHaveExitValue(4);
417         verify(&quot;expired.jar&quot;)
418                 .shouldContain(&quot;signer certificate has expired&quot;)
419                 .shouldHaveExitValue(4);
420         signVerbose(null, &quot;unsigned.jar&quot;, &quot;expiring.jar&quot;, &quot;expiring&quot;)
421                 .shouldContain(&quot;signer certificate will expire within&quot;)
422                 .shouldHaveExitValue(0);
423         verify(&quot;expiring.jar&quot;)
424                 .shouldContain(&quot;signer certificate will expire within&quot;)
425                 .shouldHaveExitValue(0);
426         // Info for long
427         signVerbose(null, &quot;unsigned.jar&quot;, &quot;long.jar&quot;, &quot;long&quot;)
428                 .shouldNotContain(&quot;signer certificate has expired&quot;)
429                 .shouldNotContain(&quot;signer certificate will expire within&quot;)
430                 .shouldContain(&quot;signer certificate will expire on&quot;)
431                 .shouldHaveExitValue(0);
432         verify(&quot;long.jar&quot;)
433                 .shouldNotContain(&quot;signer certificate has expired&quot;)
434                 .shouldNotContain(&quot;signer certificate will expire within&quot;)
435                 .shouldNotContain(&quot;The signer certificate will expire&quot;)
436                 .shouldHaveExitValue(0);
437         verify(&quot;long.jar&quot;, &quot;-verbose&quot;)
438                 .shouldContain(&quot;The signer certificate will expire&quot;)
439                 .shouldHaveExitValue(0);
440 
441         // Both expired
442         signVerbose(&quot;tsexpired&quot;, &quot;unsigned.jar&quot;,
443                 &quot;tsexpired-expired.jar&quot;, &quot;expired&quot;)
444                 .shouldContain(&quot;The signer certificate has expired.&quot;)
445                 .shouldContain(&quot;The timestamp has expired.&quot;)
446                 .shouldHaveExitValue(4);
447         verify(&quot;tsexpired-expired.jar&quot;)
448                 .shouldContain(&quot;signer certificate has expired&quot;)
449                 .shouldContain(&quot;timestamp has expired.&quot;)
450                 .shouldHaveExitValue(4);
451 
452         // TS expired but signer still good
453         signVerbose(&quot;tsexpired&quot;, &quot;unsigned.jar&quot;,
454                 &quot;tsexpired-long.jar&quot;, &quot;long&quot;)
455                 .shouldContain(&quot;The timestamp expired on&quot;)
456                 .shouldHaveExitValue(0);
457         verify(&quot;tsexpired-long.jar&quot;)
458                 .shouldMatch(&quot;timestamp expired on.*However, the JAR will be valid&quot;)
459                 .shouldNotContain(&quot;Error&quot;)
460                 .shouldHaveExitValue(0);
461 
462         signVerbose(&quot;tsexpired&quot;, &quot;unsigned.jar&quot;,
463                 &quot;tsexpired-ca.jar&quot;, &quot;ca&quot;)
464                 .shouldContain(&quot;The timestamp has expired.&quot;)
465                 .shouldHaveExitValue(4);
466         verify(&quot;tsexpired-ca.jar&quot;)
467                 .shouldNotContain(&quot;timestamp has expired&quot;)
468                 .shouldNotContain(&quot;Error&quot;)
469                 .shouldHaveExitValue(0);
470 
471         // Warning when expiring
472         sign(&quot;tsexpiring&quot;)
473                 .shouldContain(&quot;timestamp will expire within&quot;)
474                 .shouldHaveExitValue(0);
475         verify(&quot;tsexpiring.jar&quot;)
476                 .shouldContain(&quot;timestamp will expire within&quot;)
477                 .shouldNotContain(&quot;still valid&quot;)
478                 .shouldHaveExitValue(0);
479 
480         signVerbose(&quot;tsexpiring&quot;, &quot;unsigned.jar&quot;,
481                 &quot;tsexpiring-ca.jar&quot;, &quot;ca&quot;)
482                 .shouldContain(&quot;self-signed&quot;)
483                 .stderrShouldNotMatch(&quot;The.*expir&quot;)
484                 .shouldHaveExitValue(4); // self-signed
485         verify(&quot;tsexpiring-ca.jar&quot;)
486                 .stderrShouldNotMatch(&quot;The.*expir&quot;)
487                 .shouldHaveExitValue(0);
488 
489         signVerbose(&quot;tsexpiringsoon&quot;, &quot;unsigned.jar&quot;,
490                 &quot;tsexpiringsoon-long.jar&quot;, &quot;long&quot;)
491                 .shouldContain(&quot;The timestamp will expire&quot;)
492                 .shouldHaveExitValue(0);
493         verify(&quot;tsexpiringsoon-long.jar&quot;)
494                 .shouldMatch(&quot;timestamp will expire.*However, the JAR will be valid until&quot;)
495                 .shouldHaveExitValue(0);
496 
497         // Info for long
498         sign(&quot;tslong&quot;)
499                 .shouldNotContain(&quot;timestamp has expired&quot;)
500                 .shouldNotContain(&quot;timestamp will expire within&quot;)
501                 .shouldContain(&quot;timestamp will expire on&quot;)
502                 .shouldContain(&quot;signer certificate will expire on&quot;)
503                 .shouldHaveExitValue(0);
504         verify(&quot;tslong.jar&quot;)
505                 .shouldNotContain(&quot;timestamp has expired&quot;)
506                 .shouldNotContain(&quot;timestamp will expire within&quot;)
507                 .shouldNotContain(&quot;timestamp will expire on&quot;)
508                 .shouldNotContain(&quot;signer certificate will expire on&quot;)
509                 .shouldHaveExitValue(0);
510         verify(&quot;tslong.jar&quot;, &quot;-verbose&quot;)
511                 .shouldContain(&quot;timestamp will expire on&quot;)
512                 .shouldContain(&quot;signer certificate will expire on&quot;)
513                 .shouldHaveExitValue(0);
514     }
515 
516     private static void checkInvalidTsaCertKeyUsage() throws Exception {
517 
518         // Hack: Rewrite the TSA cert inside normal.jar into ts2.jar.
519 
520         // Both the cert and the serial number must be rewritten.
521         byte[] tsCert = Files.readAllBytes(Paths.get(&quot;ts.cert&quot;));
522         byte[] ts2Cert = Files.readAllBytes(Paths.get(&quot;ts2.cert&quot;));
523         byte[] tsSerial = getCert(tsCert)
524                 .getSerialNumber().toByteArray();
525         byte[] ts2Serial = getCert(ts2Cert)
526                 .getSerialNumber().toByteArray();
527 
528         byte[] oldBlock;
529         try (JarFile normal = new JarFile(&quot;normal.jar&quot;)) {
530             oldBlock = normal.getInputStream(
531                     normal.getJarEntry(&quot;META-INF/SIGNER.RSA&quot;)).readAllBytes();
532         }
533 
534         JarUtils.updateJar(&quot;normal.jar&quot;, &quot;ts2.jar&quot;,
535                 Map.of(&quot;META-INF/SIGNER.RSA&quot;,
536                         updateBytes(updateBytes(oldBlock, tsCert, ts2Cert),
537                                 tsSerial, ts2Serial)));
538 
539         verify(&quot;ts2.jar&quot;, &quot;-verbose&quot;, &quot;-certs&quot;)
540                 .shouldHaveExitValue(64)
541                 .shouldContain(&quot;jar verified&quot;)
542                 .shouldContain(&quot;Invalid TSA certificate chain: Extended key usage does not permit use for TSA server&quot;);
543     }
544 
545     public static X509Certificate getCert(byte[] data)
546             throws CertificateException, IOException {
547         return (X509Certificate)
548                 CertificateFactory.getInstance(&quot;X.509&quot;)
549                         .generateCertificate(new ByteArrayInputStream(data));
550     }
551 
552     private static byte[] updateBytes(byte[] old, byte[] from, byte[] to) {
553         int pos = 0;
554         while (true) {
555             if (pos + from.length &gt; old.length) {
556                 return null;
557             }
558             if (Arrays.equals(Arrays.copyOfRange(old, pos, pos+from.length), from)) {
559                 byte[] result = old.clone();
560                 System.arraycopy(to, 0, result, pos, from.length);
561                 return result;
562             }
563             pos++;
564         }
565     }
566 
567     private static void checkMissingOrInvalidFiles(String s)
568             throws Throwable {
569 
570         JarUtils.updateJar(s, &quot;1.jar&quot;, Map.of(&quot;META-INF/SIGNER.SF&quot;, Boolean.FALSE));
571         verify(&quot;1.jar&quot;, &quot;-verbose&quot;)
572                 .shouldHaveExitValue(16)
573                 .shouldContain(&quot;treated as unsigned&quot;)
574                 .shouldContain(&quot;Missing signature-related file META-INF/SIGNER.SF&quot;);
575         JarUtils.updateJar(s, &quot;2.jar&quot;, Map.of(&quot;META-INF/SIGNER.RSA&quot;, Boolean.FALSE));
576         verify(&quot;2.jar&quot;, &quot;-verbose&quot;)
577                 .shouldHaveExitValue(16)
578                 .shouldContain(&quot;treated as unsigned&quot;)
579                 .shouldContain(&quot;Missing block file for signature-related file META-INF/SIGNER.SF&quot;);
580         JarUtils.updateJar(s, &quot;3.jar&quot;, Map.of(&quot;META-INF/SIGNER.SF&quot;, &quot;dummy&quot;));
581         verify(&quot;3.jar&quot;, &quot;-verbose&quot;)
582                 .shouldHaveExitValue(16)
583                 .shouldContain(&quot;treated as unsigned&quot;)
584                 .shouldContain(&quot;Unparsable signature-related file META-INF/SIGNER.SF&quot;);
585         JarUtils.updateJar(s, &quot;4.jar&quot;, Map.of(&quot;META-INF/SIGNER.RSA&quot;, &quot;dummy&quot;));
586         verify(&quot;4.jar&quot;, &quot;-verbose&quot;)
587                 .shouldHaveExitValue(16)
588                 .shouldContain(&quot;treated as unsigned&quot;)
589                 .shouldContain(&quot;Unparsable signature-related file META-INF/SIGNER.RSA&quot;);
590     }
591 
592     static OutputAnalyzer jarsigner(List&lt;String&gt; extra)
593             throws Exception {
594         List&lt;String&gt; args = new ArrayList&lt;&gt;(
595                 List.of(&quot;-keystore&quot;, &quot;ks&quot;, &quot;-storepass&quot;, &quot;changeit&quot;));
596         args.addAll(extra);
597         return SecurityTools.jarsigner(args);
598     }
599 
600     static OutputAnalyzer verify(String file, String... extra)
601             throws Exception {
602         List&lt;String&gt; args = new ArrayList&lt;&gt;();
603         args.add(&quot;-verify&quot;);
604         args.add(&quot;-strict&quot;);
605         args.add(file);
606         args.addAll(Arrays.asList(extra));
607         return jarsigner(args);
608     }
609 
610     static void checkBadKU(String file) throws Exception {
611         verify(file)
612                 .shouldHaveExitValue(16)
613                 .shouldContain(&quot;treated as unsigned&quot;)
614                 .shouldContain(&quot;re-run jarsigner with debug enabled&quot;);
615         verify(file, &quot;-verbose&quot;)
616                 .shouldHaveExitValue(16)
617                 .shouldContain(&quot;Signed by&quot;)
618                 .shouldContain(&quot;treated as unsigned&quot;)
619                 .shouldContain(&quot;re-run jarsigner with debug enabled&quot;);
620         verify(file, &quot;-J-Djava.security.debug=jar&quot;)
621                 .shouldHaveExitValue(16)
622                 .shouldContain(&quot;SignatureException: Key usage restricted&quot;)
623                 .shouldContain(&quot;treated as unsigned&quot;)
624                 .shouldContain(&quot;re-run jarsigner with debug enabled&quot;);
625     }
626 
627     static void checkDisabled(String file) throws Exception {
628         verify(file)
629                 .shouldHaveExitValue(16)
630                 .shouldContain(&quot;treated as unsigned&quot;)
631                 .shouldMatch(&quot;weak algorithm that is now disabled.&quot;)
632                 .shouldMatch(&quot;Re-run jarsigner with the -verbose option for more details&quot;);
633         verify(file, &quot;-verbose&quot;)
634                 .shouldHaveExitValue(16)
635                 .shouldContain(&quot;treated as unsigned&quot;)
636                 .shouldMatch(&quot;weak algorithm that is now disabled by&quot;)
637                 .shouldMatch(&quot;Digest algorithm: .*(disabled)&quot;)
638                 .shouldMatch(&quot;Signature algorithm: .*(disabled)&quot;)
639                 .shouldMatch(&quot;Timestamp digest algorithm: .*(disabled)&quot;)
640                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(weak).*(weak)&quot;)
641                 .shouldMatch(&quot;Timestamp signature algorithm: .*key.*(disabled)&quot;);
642         verify(file, &quot;-J-Djava.security.debug=jar&quot;)
643                 .shouldHaveExitValue(16)
644                 .shouldMatch(&quot;SignatureException:.*disabled&quot;);
645 
646         // For 8171319: keytool should print out warnings when reading or
647         //              generating cert/cert req using disabled algorithms.
648         // Must call keytool the command, otherwise doPrintCert() might not
649         // be able to reset &quot;jdk.certpath.disabledAlgorithms&quot;.
650         String sout = SecurityTools.keytool(&quot;-printcert -jarfile &quot; + file)
651                 .stderrShouldContain(&quot;The TSA certificate uses a 512-bit RSA key&quot; +
652                         &quot; which is considered a security risk and is disabled.&quot;)
653                 .getStdout();
654         if (sout.indexOf(&quot;disabled&quot;, sout.indexOf(&quot;Timestamp:&quot;)) &lt; 0) {
655             throw new RuntimeException(&quot;timestamp not disabled: &quot; + sout);
656         }
657     }
658 
659     static void checkHalfDisabled(String file) throws Exception {
660         verify(file)
661                 .shouldHaveExitValue(16)
662                 .shouldContain(&quot;treated as unsigned&quot;)
663                 .shouldMatch(&quot;weak algorithm that is now disabled.&quot;)
664                 .shouldMatch(&quot;Re-run jarsigner with the -verbose option for more details&quot;);
665         verify(file, &quot;-verbose&quot;)
666                 .shouldHaveExitValue(16)
667                 .shouldContain(&quot;treated as unsigned&quot;)
668                 .shouldMatch(&quot;weak algorithm that is now disabled by&quot;)
669                 .shouldMatch(&quot;Digest algorithm: .*(disabled)&quot;)
670                 .shouldNotMatch(&quot;Signature algorithm: .*(weak)&quot;)
671                 .shouldNotMatch(&quot;Signature algorithm: .*(disabled)&quot;)
672                 .shouldNotMatch(&quot;Timestamp digest algorithm: .*(disabled)&quot;)
673                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(weak).*(weak)&quot;)
674                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(disabled).*(disabled)&quot;)
675                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*key.*(weak)&quot;)
676                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*key.*(disabled)&quot;);
677      }
678 
679     static void checkMultiple(String file) throws Exception {
680         verify(file)
681                 .shouldHaveExitValue(0)
682                 .shouldContain(&quot;jar verified&quot;);
683         verify(file, &quot;-verbose&quot;, &quot;-certs&quot;)
684                 .shouldHaveExitValue(0)
685                 .shouldContain(&quot;jar verified&quot;)
686                 .shouldMatch(&quot;X.509.*CN=dsakey&quot;)
687                 .shouldNotMatch(&quot;X.509.*CN=disabledkeysize&quot;)
688                 .shouldMatch(&quot;Signed by .*CN=dsakey&quot;)
689                 .shouldMatch(&quot;Signed by .*CN=disabledkeysize&quot;)
690                 .shouldMatch(&quot;Signature algorithm: .*key.*(disabled)&quot;);
691     }
692 
693     static void checkWeak(String file) throws Exception {
694         verify(file)
695                 .shouldHaveExitValue(0)
696                 .shouldNotContain(&quot;treated as unsigned&quot;);
697         verify(file, &quot;-verbose&quot;)
698                 .shouldHaveExitValue(0)
699                 .shouldNotContain(&quot;treated as unsigned&quot;)
700                 .shouldMatch(&quot;Digest algorithm: .*(weak)&quot;)
701                 .shouldMatch(&quot;Signature algorithm: .*(weak)&quot;)
702                 .shouldMatch(&quot;Timestamp digest algorithm: .*(weak)&quot;)
703                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(weak).*(weak)&quot;)
704                 .shouldMatch(&quot;Timestamp signature algorithm: .*key.*(weak)&quot;);
705         verify(file, &quot;-J-Djava.security.debug=jar&quot;)
706                 .shouldHaveExitValue(0)
707                 .shouldNotMatch(&quot;SignatureException:.*disabled&quot;);
708 
709         // keytool should print out warnings when reading or
710         // generating cert/cert req using legacy algorithms.
711         String sout = SecurityTools.keytool(&quot;-printcert -jarfile &quot; + file)
712                 .stderrShouldContain(&quot;The TSA certificate uses a 1024-bit RSA key&quot; +
713                         &quot; which is considered a security risk.&quot; +
714                         &quot; This key size will be disabled in a future update.&quot;)
715                 .getStdout();
716         if (sout.indexOf(&quot;weak&quot;, sout.indexOf(&quot;Timestamp:&quot;)) &lt; 0) {
717             throw new RuntimeException(&quot;timestamp not weak: &quot; + sout);
718         }
719     }
720 
721     static void checkHalfWeak(String file) throws Exception {
722         verify(file)
723                 .shouldHaveExitValue(0)
724                 .shouldNotContain(&quot;treated as unsigned&quot;);
725         verify(file, &quot;-verbose&quot;)
726                 .shouldHaveExitValue(0)
727                 .shouldNotContain(&quot;treated as unsigned&quot;)
728                 .shouldMatch(&quot;Digest algorithm: .*(weak)&quot;)
729                 .shouldNotMatch(&quot;Signature algorithm: .*(weak)&quot;)
730                 .shouldNotMatch(&quot;Signature algorithm: .*(disabled)&quot;)
731                 .shouldNotMatch(&quot;Timestamp digest algorithm: .*(weak)&quot;)
732                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(weak).*(weak)&quot;)
733                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(disabled).*(disabled)&quot;)
734                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*key.*(weak)&quot;)
735                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*key.*(disabled)&quot;);
736     }
737 
738     static void checkMultipleWeak(String file) throws Exception {
739         verify(file)
740                 .shouldHaveExitValue(0)
741                 .shouldContain(&quot;jar verified&quot;);
742         verify(file, &quot;-verbose&quot;, &quot;-certs&quot;)
743                 .shouldHaveExitValue(0)
744                 .shouldContain(&quot;jar verified&quot;)
745                 .shouldMatch(&quot;X.509.*CN=dsakey&quot;)
746                 .shouldMatch(&quot;X.509.*CN=weakkeysize&quot;)
747                 .shouldMatch(&quot;Signed by .*CN=dsakey&quot;)
748                 .shouldMatch(&quot;Signed by .*CN=weakkeysize&quot;)
749                 .shouldMatch(&quot;Signature algorithm: .*key.*(weak)&quot;);
750     }
751 
752     static void checkTimestamp(String file, String policyId, String digestAlg)
753             throws Exception {
754         try (JarFile jf = new JarFile(file)) {
755             JarEntry je = jf.getJarEntry(&quot;META-INF/SIGNER.RSA&quot;);
756             try (InputStream is = jf.getInputStream(je)) {
757                 byte[] content = is.readAllBytes();
758                 PKCS7 p7 = new PKCS7(content);
759                 SignerInfo[] si = p7.getSignerInfos();
760                 if (si == null || si.length == 0) {
761                     throw new Exception(&quot;Not signed&quot;);
762                 }
763                 PKCS9Attribute p9 = si[0].getUnauthenticatedAttributes()
764                         .getAttribute(PKCS9Attribute.SIGNATURE_TIMESTAMP_TOKEN_OID);
765                 PKCS7 tsToken = new PKCS7((byte[]) p9.getValue());
766                 TimestampToken tt =
767                         new TimestampToken(tsToken.getContentInfo().getData());
768                 if (!tt.getHashAlgorithm().toString().equals(digestAlg)) {
769                     throw new Exception(&quot;Digest alg different&quot;);
770                 }
771                 if (!tt.getPolicyID().equals(policyId)) {
772                     throw new Exception(&quot;policyId different&quot;);
773                 }
774             }
775         }
776     }
777 
778     static int which = 0;
779 
780     /**
781      * Sign with a TSA path. Always use alias &quot;signer&quot; to sign &quot;unsigned.jar&quot;.
782      * The signed jar name is always path.jar.
783      *
784      * @param extra more args given to jarsigner
785      */
786     static OutputAnalyzer sign(String path, String... extra)
787             throws Exception {
788         return signVerbose(
789                 path,
790                 &quot;unsigned.jar&quot;,
791                 path + &quot;.jar&quot;,
792                 &quot;signer&quot;,
793                 extra);
794     }
795 
796     static OutputAnalyzer signVerbose(
797             String path,    // TSA URL path
798             String oldJar,
799             String newJar,
800             String alias,   // signer
801             String...extra) throws Exception {
802         which++;
803         System.out.println(&quot;\n&gt;&gt; Test #&quot; + which);
804         List&lt;String&gt; args = new ArrayList&lt;&gt;(List.of(
805                 &quot;-strict&quot;, &quot;-verbose&quot;, &quot;-debug&quot;, &quot;-signedjar&quot;, newJar, oldJar, alias));
806         if (path != null) {
807             args.add(&quot;-tsa&quot;);
808             args.add(host + path);
809         }
810         args.addAll(Arrays.asList(extra));
811         return jarsigner(args);
812     }
813 
814     static void prepare() throws Exception {
815         JarUtils.createJar(&quot;unsigned.jar&quot;, &quot;A&quot;);
816         Files.deleteIfExists(Paths.get(&quot;ks&quot;));
817         keytool(&quot;-alias signer -genkeypair -ext bc -dname CN=signer&quot;);
818         keytool(&quot;-alias oldsigner -genkeypair -dname CN=oldsigner&quot;);
819         keytool(&quot;-alias dsakey -genkeypair -keyalg DSA -dname CN=dsakey&quot;);
820         keytool(&quot;-alias weakkeysize -genkeypair -keysize 1024 -dname CN=weakkeysize&quot;);
821         keytool(&quot;-alias disabledkeysize -genkeypair -keysize 512 -dname CN=disabledkeysize&quot;);
822         keytool(&quot;-alias badku -genkeypair -dname CN=badku&quot;);
823         keytool(&quot;-alias ts -genkeypair -dname CN=ts&quot;);
824         keytool(&quot;-alias tsold -genkeypair -dname CN=tsold&quot;);
825         keytool(&quot;-alias tsweak -genkeypair -keysize 1024 -dname CN=tsweak&quot;);
826         keytool(&quot;-alias tsdisabled -genkeypair -keysize 512 -dname CN=tsdisabled&quot;);
827         keytool(&quot;-alias tsbad1 -genkeypair -dname CN=tsbad1&quot;);
828         keytool(&quot;-alias tsbad2 -genkeypair -dname CN=tsbad2&quot;);
829         keytool(&quot;-alias tsbad3 -genkeypair -dname CN=tsbad3&quot;);
830         keytool(&quot;-alias tsnoca -genkeypair -dname CN=tsnoca&quot;);
831 
832         keytool(&quot;-alias expired -genkeypair -dname CN=expired&quot;);
833         keytool(&quot;-alias expiring -genkeypair -dname CN=expiring&quot;);
834         keytool(&quot;-alias long -genkeypair -dname CN=long&quot;);
835         keytool(&quot;-alias tsexpired -genkeypair -dname CN=tsexpired&quot;);
836         keytool(&quot;-alias tsexpiring -genkeypair -dname CN=tsexpiring&quot;);
837         keytool(&quot;-alias tsexpiringsoon -genkeypair -dname CN=tsexpiringsoon&quot;);
838         keytool(&quot;-alias tslong -genkeypair -dname CN=tslong&quot;);
839 
840         // tsnoca&#39;s issuer will be removed from keystore later
841         keytool(&quot;-alias ca -genkeypair -ext bc -dname CN=CA&quot;);
842         gencert(&quot;tsnoca&quot;, &quot;-ext eku:critical=ts&quot;);
843         keytool(&quot;-delete -alias ca&quot;);
844         keytool(&quot;-alias ca -genkeypair -ext bc -dname CN=CA -startdate -40d&quot;);
845 
846         gencert(&quot;signer&quot;);
847         gencert(&quot;oldsigner&quot;, &quot;-startdate -30d -validity 20&quot;);
848         gencert(&quot;dsakey&quot;);
849         gencert(&quot;weakkeysize&quot;);
850         gencert(&quot;disabledkeysize&quot;);
851         gencert(&quot;badku&quot;, &quot;-ext ku:critical=keyAgreement&quot;);
852         gencert(&quot;ts&quot;, &quot;-ext eku:critical=ts -validity 500&quot;);
853 
854         gencert(&quot;expired&quot;, &quot;-validity 10 -startdate -12d&quot;);
855         gencert(&quot;expiring&quot;, &quot;-validity 178&quot;);
856         gencert(&quot;long&quot;, &quot;-validity 182&quot;);
857         gencert(&quot;tsexpired&quot;, &quot;-ext eku:critical=ts -validity 10 -startdate -12d&quot;);
858         gencert(&quot;tsexpiring&quot;, &quot;-ext eku:critical=ts -validity 364&quot;);
859         gencert(&quot;tsexpiringsoon&quot;, &quot;-ext eku:critical=ts -validity 170&quot;); // earlier than expiring
860         gencert(&quot;tslong&quot;, &quot;-ext eku:critical=ts -validity 367&quot;);
861 
862 
863         for (int i = 0; i &lt; 5; i++) {
864             // Issue another cert for &quot;ts&quot; with a different EKU.
865             // Length might be different because serial number is
866             // random. Try several times until a cert with the same
867             // length is generated so we can substitute ts.cert
868             // embedded in the PKCS7 block with ts2.cert.
869             // If cannot create one, related test will be ignored.
870             keytool(&quot;-gencert -alias ca -infile ts.req -outfile ts2.cert &quot; +
871                     &quot;-ext eku:critical=1.3.6.1.5.5.7.3.9&quot;);
872             if (Files.size(Paths.get(&quot;ts.cert&quot;)) != Files.size(Paths.get(&quot;ts2.cert&quot;))) {
873                 Files.delete(Paths.get(&quot;ts2.cert&quot;));
874                 System.out.println(&quot;Warning: cannot create same length&quot;);
875             } else {
876                 break;
877             }
878         }
879 
880         gencert(&quot;tsold&quot;, &quot;-ext eku:critical=ts -startdate -40d -validity 500&quot;);
881 
882         gencert(&quot;tsweak&quot;, &quot;-ext eku:critical=ts&quot;);
883         gencert(&quot;tsdisabled&quot;, &quot;-ext eku:critical=ts&quot;);
884         gencert(&quot;tsbad1&quot;);
885         gencert(&quot;tsbad2&quot;, &quot;-ext eku=ts&quot;);
886         gencert(&quot;tsbad3&quot;, &quot;-ext eku:critical=cs&quot;);
887     }
888 
889     static void gencert(String alias, String... extra) throws Exception {
890         keytool(&quot;-alias &quot; + alias + &quot; -certreq -file &quot; + alias + &quot;.req&quot;);
891         String genCmd = &quot;-gencert -alias ca -infile &quot; +
892                 alias + &quot;.req -outfile &quot; + alias + &quot;.cert&quot;;
893         for (String s : extra) {
894             genCmd += &quot; &quot; + s;
895         }
896         keytool(genCmd);
897         keytool(&quot;-alias &quot; + alias + &quot; -importcert -file &quot; + alias + &quot;.cert&quot;);
898     }
899 
900     static void keytool(String cmd) throws Exception {
901         cmd = &quot;-keystore ks -storepass changeit -keypass changeit &quot; +
902                 &quot;-keyalg rsa -validity 200 &quot; + cmd;
903         sun.security.tools.keytool.Main.main(cmd.split(&quot; &quot;));
904     }
905 }
    </pre>
  </body>
</html>