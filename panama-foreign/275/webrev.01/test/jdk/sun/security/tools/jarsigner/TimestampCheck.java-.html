<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/sun/security/tools/jarsigner/TimestampCheck.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.ByteArrayInputStream;
 25 import java.io.File;
 26 import java.io.IOException;
 27 import java.io.InputStream;
 28 import java.math.BigInteger;
 29 import java.nio.file.Files;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import java.security.KeyStore;
 33 import java.security.cert.CertificateException;
 34 import java.security.cert.CertificateFactory;
 35 import java.security.cert.X509Certificate;
 36 import java.time.Instant;
 37 import java.time.temporal.ChronoUnit;
 38 import java.util.ArrayList;
 39 import java.util.Arrays;
 40 import java.util.Date;
 41 import java.util.List;
 42 import java.util.Map;
 43 import java.util.jar.JarEntry;
 44 import java.util.jar.JarFile;
 45 
 46 import com.sun.net.httpserver.HttpExchange;
 47 
 48 import jdk.test.lib.SecurityTools;
 49 import jdk.test.lib.process.OutputAnalyzer;
 50 import jdk.test.lib.security.KeyStoreUtils;
 51 import jdk.test.lib.security.timestamp.*;
 52 import jdk.test.lib.util.JarUtils;
 53 import sun.security.pkcs.PKCS7;
 54 import sun.security.pkcs.PKCS9Attribute;
 55 import sun.security.pkcs.SignerInfo;
 56 import sun.security.timestamp.TimestampToken;
 57 
 58 /*
 59  * @test
 60  * @bug 6543842 6543440 6939248 8009636 8024302 8163304 8169911 8180289 8172404
 61  * @summary checking response of timestamp
 62  * @modules java.base/sun.security.pkcs
 63  *          java.base/sun.security.timestamp
 64  *          java.base/sun.security.x509
 65  *          java.base/sun.security.util
 66  *          java.base/sun.security.tools.keytool
 67  * @library /lib/testlibrary
 68  * @library /test/lib
 69  * @build jdk.test.lib.util.JarUtils
 70  *        jdk.test.lib.SecurityTools
 71  *        jdk.test.lib.Utils
 72  *        jdk.test.lib.Asserts
 73  *        jdk.test.lib.JDKToolFinder
 74  *        jdk.test.lib.JDKToolLauncher
 75  *        jdk.test.lib.Platform
 76  *        jdk.test.lib.process.*
 77  * @compile -XDignore.symbol.file TimestampCheck.java
 78  * @run main/timeout=600 TimestampCheck
 79  */
 80 public class TimestampCheck {
 81 
 82     private static final String PASSWORD = &quot;changeit&quot;;
 83     private static final String defaultPolicyId = &quot;2.3.4&quot;;
 84     private static String host = null;
 85 
 86     private static class Interceptor implements RespInterceptor {
 87 
 88         private final String path;
 89 
 90         Interceptor(String path) {
 91             this.path = path;
 92         }
 93 
 94         @Override
 95         public X509Certificate[] getSignerCertChain(
 96                 X509Certificate[] signerCertChain, boolean certReq)
 97                 throws Exception {
 98             if (path.equals(&quot;fullchain&quot;)) { // Only case 5 uses full chain
 99                 return signerCertChain;
100             } else if (path.equals(&quot;nocert&quot;)) {
101                 return new X509Certificate[0];
102             } else {
103                 return new X509Certificate[] { signerCertChain[0] };
104             }
105         }
106 
107         @Override
108         public String getSigAlgo(String sigAlgo) throws Exception {
109             return &quot;SHA256withRSA&quot;;
110         }
111 
112         @Override
113         public TsaParam getRespParam(TsaParam reqParam) {
114             TsaParam respParam = RespInterceptor.super.getRespParam(reqParam);
115 
116             String policyId
117                     = respParam.policyId() == null || path.equals(&quot;diffpolicy&quot;)
118                     ? TimestampCheck.defaultPolicyId
119                     : respParam.policyId();
120             respParam.policyId(policyId);
121 
122             String digestAlgo = respParam.digestAlgo();
123             if (path.equals(&quot;diffalg&quot;)) {
124                 digestAlgo = digestAlgo.contains(&quot;256&quot;)
125                         ? &quot;SHA-1&quot; : &quot;SHA-256&quot;;
126             }
127             respParam.digestAlgo(digestAlgo);
128 
129             byte[] hashedMessage = respParam.hashedMessage();
130             if (path.equals(&quot;baddigest&quot;)) {
131                 hashedMessage[hashedMessage.length - 1] = (byte) 0x01;
132                 hashedMessage[hashedMessage.length - 2] = (byte) 0x02;
133                 hashedMessage[hashedMessage.length - 3] = (byte) 0x03;
134             }
135             respParam.hashedMessage(hashedMessage);
136 
137             Instant instant = Instant.now();
138             if (path.equals(&quot;tsold&quot;)) {
139                 instant = instant.minus(20, ChronoUnit.DAYS);
140             }
141             respParam.genTime(Date.from(instant));
142 
143             BigInteger nonce = respParam.nonce();
144             if (path.equals(&quot;diffnonce&quot;)) {
145                 nonce = BigInteger.valueOf(1234);
146             } else if (path.equals(&quot;nononce&quot;)) {
147                 nonce = null;
148             }
149             respParam.nonce(nonce);
150 
151             return respParam;
152         }
153     }
154 
155     private static class Handler extends TsaHandler {
156 
157         Handler(String keystore) throws Exception {
158             super(KeyStoreUtils.loadKeyStore(keystore, PASSWORD), PASSWORD);
159         }
160 
161         public TsaSigner createSigner(HttpExchange exchange)
162                 throws Exception {
163             String path = exchange.getRequestURI().getPath().substring(1);
164 
165             SignerEntry signerEntry = createSignerEntry(
166                     path.startsWith(&quot;ts&quot;) ? path : &quot;ts&quot;);
167             byte[] requestData = exchange.getRequestBody().readAllBytes();
168             RespInterceptor interceptor = new Interceptor(path);
169             return new TsaSigner(signerEntry, requestData, interceptor);
170         }
171     }
172 
173     private static TsaServer initServer(String keystore) throws Exception {
174         return new TsaServer(0, new Handler(keystore));
175     }
176 
177     public static void main(String[] args) throws Throwable {
178         prepare();
179 
180         try (TsaServer tsa = initServer(&quot;ks&quot;);) {
181             tsa.start();
182             int port = tsa.getPort();
183             host = &quot;http://localhost:&quot; + port + &quot;/&quot;;
184 
185             if (args.length == 0) {         // Run this test
186 
187                 sign(&quot;normal&quot;)
188                         .shouldNotContain(&quot;Warning&quot;)
189                         .shouldContain(&quot;The signer certificate will expire on&quot;)
190                         .shouldContain(&quot;The timestamp will expire on&quot;)
191                         .shouldHaveExitValue(0);
192 
193                 verify(&quot;normal.jar&quot;)
194                         .shouldNotContain(&quot;Warning&quot;)
195                         .shouldHaveExitValue(0);
196 
197                 verify(&quot;normal.jar&quot;, &quot;-verbose&quot;)
198                         .shouldNotContain(&quot;Warning&quot;)
199                         .shouldContain(&quot;The signer certificate will expire on&quot;)
200                         .shouldContain(&quot;The timestamp will expire on&quot;)
201                         .shouldHaveExitValue(0);
202 
203                 // Simulate signing at a previous date:
204                 // 1. tsold will create a timestamp of 20 days ago.
205                 // 2. oldsigner expired 10 days ago.
206                 signVerbose(&quot;tsold&quot;, &quot;unsigned.jar&quot;, &quot;tsold.jar&quot;, &quot;oldsigner&quot;)
207                         .shouldNotContain(&quot;Warning&quot;)
208                         .shouldMatch(&quot;signer certificate expired on .*. &quot;
209                                 + &quot;However, the JAR will be valid&quot;)
210                         .shouldHaveExitValue(0);
211 
212                 // It verifies perfectly.
213                 verify(&quot;tsold.jar&quot;, &quot;-verbose&quot;, &quot;-certs&quot;)
214                         .shouldNotContain(&quot;Warning&quot;)
215                         .shouldMatch(&quot;signer certificate expired on .*. &quot;
216                                 + &quot;However, the JAR will be valid&quot;)
217                         .shouldHaveExitValue(0);
218 
219                 // No timestamp
220                 signVerbose(null, &quot;unsigned.jar&quot;, &quot;none.jar&quot;, &quot;signer&quot;)
221                         .shouldContain(&quot;is not timestamped&quot;)
222                         .shouldContain(&quot;The signer certificate will expire on&quot;)
223                         .shouldHaveExitValue(0);
224 
225                 verify(&quot;none.jar&quot;, &quot;-verbose&quot;)
226                         .shouldContain(&quot;do not include a timestamp&quot;)
227                         .shouldContain(&quot;The signer certificate will expire on&quot;)
228                         .shouldHaveExitValue(0);
229 
230                 // Error cases
231 
232                 signVerbose(null, &quot;unsigned.jar&quot;, &quot;badku.jar&quot;, &quot;badku&quot;)
233                         .shouldContain(&quot;KeyUsage extension doesn&#39;t allow code signing&quot;)
234                         .shouldHaveExitValue(8);
235                 checkBadKU(&quot;badku.jar&quot;);
236 
237                 // 8180289: unvalidated TSA cert chain
238                 sign(&quot;tsnoca&quot;)
239                         .shouldContain(&quot;The TSA certificate chain is invalid. &quot;
240                                 + &quot;Reason: Path does not chain with any of the trust anchors&quot;)
241                         .shouldHaveExitValue(64);
242 
243                 verify(&quot;tsnoca.jar&quot;, &quot;-verbose&quot;, &quot;-certs&quot;)
244                         .shouldHaveExitValue(64)
245                         .shouldContain(&quot;jar verified&quot;)
246                         .shouldContain(&quot;Invalid TSA certificate chain: &quot;
247                                 + &quot;Path does not chain with any of the trust anchors&quot;)
248                         .shouldContain(&quot;TSA certificate chain is invalid.&quot;
249                                 + &quot; Reason: Path does not chain with any of the trust anchors&quot;);
250 
251                 sign(&quot;nononce&quot;)
252                         .shouldContain(&quot;Nonce missing in timestamp token&quot;)
253                         .shouldHaveExitValue(1);
254                 sign(&quot;diffnonce&quot;)
255                         .shouldContain(&quot;Nonce changed in timestamp token&quot;)
256                         .shouldHaveExitValue(1);
257                 sign(&quot;baddigest&quot;)
258                         .shouldContain(&quot;Digest octets changed in timestamp token&quot;)
259                         .shouldHaveExitValue(1);
260                 sign(&quot;diffalg&quot;)
261                         .shouldContain(&quot;Digest algorithm not&quot;)
262                         .shouldHaveExitValue(1);
263 
264                 sign(&quot;fullchain&quot;)
265                         .shouldHaveExitValue(0);   // Success, 6543440 solved.
266 
267                 sign(&quot;tsbad1&quot;)
268                         .shouldContain(&quot;Certificate is not valid for timestamping&quot;)
269                         .shouldHaveExitValue(1);
270                 sign(&quot;tsbad2&quot;)
271                         .shouldContain(&quot;Certificate is not valid for timestamping&quot;)
272                         .shouldHaveExitValue(1);
273                 sign(&quot;tsbad3&quot;)
274                         .shouldContain(&quot;Certificate is not valid for timestamping&quot;)
275                         .shouldHaveExitValue(1);
276                 sign(&quot;nocert&quot;)
277                         .shouldContain(&quot;Certificate not included in timestamp token&quot;)
278                         .shouldHaveExitValue(1);
279 
280                 sign(&quot;policy&quot;, &quot;-tsapolicyid&quot;,  &quot;1.2.3&quot;)
281                         .shouldHaveExitValue(0);
282                 checkTimestamp(&quot;policy.jar&quot;, &quot;1.2.3&quot;, &quot;SHA-256&quot;);
283 
284                 sign(&quot;diffpolicy&quot;, &quot;-tsapolicyid&quot;, &quot;1.2.3&quot;)
285                         .shouldContain(&quot;TSAPolicyID changed in timestamp token&quot;)
286                         .shouldHaveExitValue(1);
287 
288                 sign(&quot;sha384alg&quot;, &quot;-tsadigestalg&quot;, &quot;SHA-384&quot;)
289                         .shouldHaveExitValue(0);
290                 checkTimestamp(&quot;sha384alg.jar&quot;, defaultPolicyId, &quot;SHA-384&quot;);
291 
292                 // Legacy algorithms
293                 signVerbose(null, &quot;unsigned.jar&quot;, &quot;sha1alg.jar&quot;, &quot;signer&quot;,
294                         &quot;-strict&quot;, &quot;-digestalg&quot;, &quot;SHA-1&quot;)
295                         .shouldHaveExitValue(0)
296                         .shouldContain(&quot;jar signed, with signer errors&quot;)
297                         .shouldMatch(&quot;SHA-1.*-digestalg.*will be disabled&quot;);
298                 verify(&quot;sha1alg.jar&quot;, &quot;-strict&quot;)
299                         .shouldHaveExitValue(0)
300                         .shouldContain(&quot;jar verified, with signer errors&quot;)
301                         .shouldContain(&quot;SHA-1 digest algorithm is considered a security risk&quot;)
302                         .shouldContain(&quot;This algorithm will be disabled in a future update&quot;)
303                         .shouldNotContain(&quot;is disabled&quot;);
304 
305                 sign(&quot;sha1tsaalg&quot;, &quot;-tsadigestalg&quot;, &quot;SHA-1&quot;, &quot;-strict&quot;)
306                         .shouldHaveExitValue(0)
307                         .shouldContain(&quot;jar signed, with signer errors&quot;)
308                         .shouldMatch(&quot;SHA-1.*-tsadigestalg.*will be disabled&quot;)
309                         .shouldNotContain(&quot;is disabled&quot;);
310                 verify(&quot;sha1tsaalg.jar&quot;, &quot;-strict&quot;)
311                         .shouldHaveExitValue(0)
312                         .shouldContain(&quot;jar verified, with signer errors&quot;)
313                         .shouldContain(&quot;SHA-1 timestamp digest algorithm is considered a security risk&quot;)
314                         .shouldNotContain(&quot;is disabled&quot;);
315 
316                 // Disabled algorithms
317                 sign(&quot;tsdisabled&quot;, &quot;-digestalg&quot;, &quot;MD5&quot;,
318                                 &quot;-sigalg&quot;, &quot;MD5withRSA&quot;, &quot;-tsadigestalg&quot;, &quot;MD5&quot;)
319                         .shouldHaveExitValue(68)
320                         .shouldContain(&quot;The timestamp is invalid. Without a valid timestamp&quot;)
321                         .shouldMatch(&quot;MD5.*-digestalg.*is disabled&quot;)
322                         .shouldMatch(&quot;MD5.*-tsadigestalg.*is disabled&quot;)
323                         .shouldMatch(&quot;MD5withRSA.*-sigalg.*is disabled&quot;);
324                 checkDisabled(&quot;tsdisabled.jar&quot;);
325 
326                 signVerbose(&quot;tsdisabled&quot;, &quot;unsigned.jar&quot;, &quot;tsdisabled2.jar&quot;, &quot;signer&quot;)
327                         .shouldHaveExitValue(64)
328                         .shouldContain(&quot;The timestamp is invalid. Without a valid timestamp&quot;)
329                         .shouldContain(&quot;TSA certificate chain is invalid&quot;);
330 
331                 // Disabled timestamp is an error and jar treated unsigned
332                 verify(&quot;tsdisabled2.jar&quot;, &quot;-verbose&quot;)
333                         .shouldHaveExitValue(16)
334                         .shouldContain(&quot;treated as unsigned&quot;)
335                         .shouldMatch(&quot;Timestamp.*512.*(disabled)&quot;);
336 
337                 // Algorithm used in signing is disabled
338                 signVerbose(&quot;normal&quot;, &quot;unsigned.jar&quot;, &quot;halfDisabled.jar&quot;, &quot;signer&quot;,
339                         &quot;-digestalg&quot;, &quot;MD5&quot;)
340                         .shouldContain(&quot;-digestalg option is considered a security risk and is disabled&quot;)
341                         .shouldHaveExitValue(4);
342                 checkHalfDisabled(&quot;halfDisabled.jar&quot;);
343 
344                 // sign with DSA key
345                 signVerbose(&quot;normal&quot;, &quot;unsigned.jar&quot;, &quot;sign1.jar&quot;, &quot;dsakey&quot;)
346                         .shouldHaveExitValue(0);
347 
348                 // sign with RSAkeysize &lt; 1024
349                 signVerbose(&quot;normal&quot;, &quot;sign1.jar&quot;, &quot;sign2.jar&quot;, &quot;disabledkeysize&quot;)
350                         .shouldContain(&quot;Algorithm constraints check failed on keysize&quot;)
351                         .shouldHaveExitValue(4);
352                 checkMultiple(&quot;sign2.jar&quot;);
353 
354                 // Legacy algorithms
355                 sign(&quot;tsweak&quot;, &quot;-digestalg&quot;, &quot;SHA1&quot;,
356                                 &quot;-sigalg&quot;, &quot;SHA1withRSA&quot;, &quot;-tsadigestalg&quot;, &quot;SHA1&quot;)
357                         .shouldHaveExitValue(0)
358                         .shouldMatch(&quot;SHA1.*-digestalg.*will be disabled&quot;)
359                         .shouldMatch(&quot;SHA1.*-tsadigestalg.*will be disabled&quot;)
360                         .shouldMatch(&quot;SHA1withRSA.*-sigalg.*will be disabled&quot;);
361                 checkWeak(&quot;tsweak.jar&quot;);
362 
363                 signVerbose(&quot;tsweak&quot;, &quot;unsigned.jar&quot;, &quot;tsweak2.jar&quot;, &quot;signer&quot;)
364                         .shouldHaveExitValue(0);
365 
366                 verify(&quot;tsweak2.jar&quot;, &quot;-verbose&quot;)
367                         .shouldHaveExitValue(0)
368                         .shouldContain(&quot;jar verified&quot;)
369                         .shouldMatch(&quot;Timestamp.*1024.*(weak)&quot;);
370 
371                 // Algorithm used in signing is weak
372                 signVerbose(&quot;normal&quot;, &quot;unsigned.jar&quot;, &quot;halfWeak.jar&quot;, &quot;signer&quot;,
373                         &quot;-digestalg&quot;, &quot;SHA1&quot;)
374                         .shouldContain(&quot;-digestalg option is considered a security risk.&quot;)
375                         .shouldContain(&quot;This algorithm will be disabled in a future update.&quot;)
376                         .shouldHaveExitValue(0);
377                 checkHalfWeak(&quot;halfWeak.jar&quot;);
378 
379                 // sign with DSA key
380                 signVerbose(&quot;normal&quot;, &quot;unsigned.jar&quot;, &quot;sign1.jar&quot;, &quot;dsakey&quot;)
381                         .shouldHaveExitValue(0);
382 
383                 // sign with RSAkeysize &lt; 2048
384                 signVerbose(&quot;normal&quot;, &quot;sign1.jar&quot;, &quot;sign2.jar&quot;, &quot;weakkeysize&quot;)
385                         .shouldNotContain(&quot;Algorithm constraints check failed on keysize&quot;)
386                         .shouldHaveExitValue(0);
387                 checkMultipleWeak(&quot;sign2.jar&quot;);
388 
389 
390                 // 8191438: jarsigner should print when a timestamp will expire
391                 checkExpiration();
392 
393                 // When .SF or .RSA is missing or invalid
394                 checkMissingOrInvalidFiles(&quot;normal.jar&quot;);
395 
396                 if (Files.exists(Paths.get(&quot;ts2.cert&quot;))) {
397                     checkInvalidTsaCertKeyUsage();
398                 }
399             } else {                        // Run as a standalone server
400                 System.out.println(&quot;TSA started at &quot; + host
401                         + &quot;. Press Enter to quit server&quot;);
402                 System.in.read();
403             }
404         }
405     }
406 
407     private static void checkExpiration() throws Exception {
408 
409         // Warning when expired or expiring
410         signVerbose(null, &quot;unsigned.jar&quot;, &quot;expired.jar&quot;, &quot;expired&quot;)
411                 .shouldContain(&quot;signer certificate has expired&quot;)
412                 .shouldHaveExitValue(4);
413         verify(&quot;expired.jar&quot;)
414                 .shouldContain(&quot;signer certificate has expired&quot;)
415                 .shouldHaveExitValue(4);
416         signVerbose(null, &quot;unsigned.jar&quot;, &quot;expiring.jar&quot;, &quot;expiring&quot;)
417                 .shouldContain(&quot;signer certificate will expire within&quot;)
418                 .shouldHaveExitValue(0);
419         verify(&quot;expiring.jar&quot;)
420                 .shouldContain(&quot;signer certificate will expire within&quot;)
421                 .shouldHaveExitValue(0);
422         // Info for long
423         signVerbose(null, &quot;unsigned.jar&quot;, &quot;long.jar&quot;, &quot;long&quot;)
424                 .shouldNotContain(&quot;signer certificate has expired&quot;)
425                 .shouldNotContain(&quot;signer certificate will expire within&quot;)
426                 .shouldContain(&quot;signer certificate will expire on&quot;)
427                 .shouldHaveExitValue(0);
428         verify(&quot;long.jar&quot;)
429                 .shouldNotContain(&quot;signer certificate has expired&quot;)
430                 .shouldNotContain(&quot;signer certificate will expire within&quot;)
431                 .shouldNotContain(&quot;The signer certificate will expire&quot;)
432                 .shouldHaveExitValue(0);
433         verify(&quot;long.jar&quot;, &quot;-verbose&quot;)
434                 .shouldContain(&quot;The signer certificate will expire&quot;)
435                 .shouldHaveExitValue(0);
436 
437         // Both expired
438         signVerbose(&quot;tsexpired&quot;, &quot;unsigned.jar&quot;,
439                 &quot;tsexpired-expired.jar&quot;, &quot;expired&quot;)
440                 .shouldContain(&quot;The signer certificate has expired.&quot;)
441                 .shouldContain(&quot;The timestamp has expired.&quot;)
442                 .shouldHaveExitValue(4);
443         verify(&quot;tsexpired-expired.jar&quot;)
444                 .shouldContain(&quot;signer certificate has expired&quot;)
445                 .shouldContain(&quot;timestamp has expired.&quot;)
446                 .shouldHaveExitValue(4);
447 
448         // TS expired but signer still good
449         signVerbose(&quot;tsexpired&quot;, &quot;unsigned.jar&quot;,
450                 &quot;tsexpired-long.jar&quot;, &quot;long&quot;)
451                 .shouldContain(&quot;The timestamp expired on&quot;)
452                 .shouldHaveExitValue(0);
453         verify(&quot;tsexpired-long.jar&quot;)
454                 .shouldMatch(&quot;timestamp expired on.*However, the JAR will be valid&quot;)
455                 .shouldNotContain(&quot;Error&quot;)
456                 .shouldHaveExitValue(0);
457 
458         signVerbose(&quot;tsexpired&quot;, &quot;unsigned.jar&quot;,
459                 &quot;tsexpired-ca.jar&quot;, &quot;ca&quot;)
460                 .shouldContain(&quot;The timestamp has expired.&quot;)
461                 .shouldHaveExitValue(4);
462         verify(&quot;tsexpired-ca.jar&quot;)
463                 .shouldNotContain(&quot;timestamp has expired&quot;)
464                 .shouldNotContain(&quot;Error&quot;)
465                 .shouldHaveExitValue(0);
466 
467         // Warning when expiring
468         sign(&quot;tsexpiring&quot;)
469                 .shouldContain(&quot;timestamp will expire within&quot;)
470                 .shouldHaveExitValue(0);
471         verify(&quot;tsexpiring.jar&quot;)
472                 .shouldContain(&quot;timestamp will expire within&quot;)
473                 .shouldNotContain(&quot;still valid&quot;)
474                 .shouldHaveExitValue(0);
475 
476         signVerbose(&quot;tsexpiring&quot;, &quot;unsigned.jar&quot;,
477                 &quot;tsexpiring-ca.jar&quot;, &quot;ca&quot;)
478                 .shouldContain(&quot;self-signed&quot;)
479                 .stderrShouldNotMatch(&quot;The.*expir&quot;)
480                 .shouldHaveExitValue(4); // self-signed
481         verify(&quot;tsexpiring-ca.jar&quot;)
482                 .stderrShouldNotMatch(&quot;The.*expir&quot;)
483                 .shouldHaveExitValue(0);
484 
485         signVerbose(&quot;tsexpiringsoon&quot;, &quot;unsigned.jar&quot;,
486                 &quot;tsexpiringsoon-long.jar&quot;, &quot;long&quot;)
487                 .shouldContain(&quot;The timestamp will expire&quot;)
488                 .shouldHaveExitValue(0);
489         verify(&quot;tsexpiringsoon-long.jar&quot;)
490                 .shouldMatch(&quot;timestamp will expire.*However, the JAR will be valid until&quot;)
491                 .shouldHaveExitValue(0);
492 
493         // Info for long
494         sign(&quot;tslong&quot;)
495                 .shouldNotContain(&quot;timestamp has expired&quot;)
496                 .shouldNotContain(&quot;timestamp will expire within&quot;)
497                 .shouldContain(&quot;timestamp will expire on&quot;)
498                 .shouldContain(&quot;signer certificate will expire on&quot;)
499                 .shouldHaveExitValue(0);
500         verify(&quot;tslong.jar&quot;)
501                 .shouldNotContain(&quot;timestamp has expired&quot;)
502                 .shouldNotContain(&quot;timestamp will expire within&quot;)
503                 .shouldNotContain(&quot;timestamp will expire on&quot;)
504                 .shouldNotContain(&quot;signer certificate will expire on&quot;)
505                 .shouldHaveExitValue(0);
506         verify(&quot;tslong.jar&quot;, &quot;-verbose&quot;)
507                 .shouldContain(&quot;timestamp will expire on&quot;)
508                 .shouldContain(&quot;signer certificate will expire on&quot;)
509                 .shouldHaveExitValue(0);
510     }
511 
512     private static void checkInvalidTsaCertKeyUsage() throws Exception {
513 
514         // Hack: Rewrite the TSA cert inside normal.jar into ts2.jar.
515 
516         // Both the cert and the serial number must be rewritten.
517         byte[] tsCert = Files.readAllBytes(Paths.get(&quot;ts.cert&quot;));
518         byte[] ts2Cert = Files.readAllBytes(Paths.get(&quot;ts2.cert&quot;));
519         byte[] tsSerial = getCert(tsCert)
520                 .getSerialNumber().toByteArray();
521         byte[] ts2Serial = getCert(ts2Cert)
522                 .getSerialNumber().toByteArray();
523 
524         byte[] oldBlock;
525         try (JarFile normal = new JarFile(&quot;normal.jar&quot;)) {
526             oldBlock = normal.getInputStream(
527                     normal.getJarEntry(&quot;META-INF/SIGNER.RSA&quot;)).readAllBytes();
528         }
529 
530         JarUtils.updateJar(&quot;normal.jar&quot;, &quot;ts2.jar&quot;,
531                 Map.of(&quot;META-INF/SIGNER.RSA&quot;,
532                         updateBytes(updateBytes(oldBlock, tsCert, ts2Cert),
533                                 tsSerial, ts2Serial)));
534 
535         verify(&quot;ts2.jar&quot;, &quot;-verbose&quot;, &quot;-certs&quot;)
536                 .shouldHaveExitValue(64)
537                 .shouldContain(&quot;jar verified&quot;)
538                 .shouldContain(&quot;Invalid TSA certificate chain: Extended key usage does not permit use for TSA server&quot;);
539     }
540 
541     public static X509Certificate getCert(byte[] data)
542             throws CertificateException, IOException {
543         return (X509Certificate)
544                 CertificateFactory.getInstance(&quot;X.509&quot;)
545                         .generateCertificate(new ByteArrayInputStream(data));
546     }
547 
548     private static byte[] updateBytes(byte[] old, byte[] from, byte[] to) {
549         int pos = 0;
550         while (true) {
551             if (pos + from.length &gt; old.length) {
552                 return null;
553             }
554             if (Arrays.equals(Arrays.copyOfRange(old, pos, pos+from.length), from)) {
555                 byte[] result = old.clone();
556                 System.arraycopy(to, 0, result, pos, from.length);
557                 return result;
558             }
559             pos++;
560         }
561     }
562 
563     private static void checkMissingOrInvalidFiles(String s)
564             throws Throwable {
565 
566         JarUtils.updateJar(s, &quot;1.jar&quot;, Map.of(&quot;META-INF/SIGNER.SF&quot;, Boolean.FALSE));
567         verify(&quot;1.jar&quot;, &quot;-verbose&quot;)
568                 .shouldHaveExitValue(16)
569                 .shouldContain(&quot;treated as unsigned&quot;)
570                 .shouldContain(&quot;Missing signature-related file META-INF/SIGNER.SF&quot;);
571         JarUtils.updateJar(s, &quot;2.jar&quot;, Map.of(&quot;META-INF/SIGNER.RSA&quot;, Boolean.FALSE));
572         verify(&quot;2.jar&quot;, &quot;-verbose&quot;)
573                 .shouldHaveExitValue(16)
574                 .shouldContain(&quot;treated as unsigned&quot;)
575                 .shouldContain(&quot;Missing block file for signature-related file META-INF/SIGNER.SF&quot;);
576         JarUtils.updateJar(s, &quot;3.jar&quot;, Map.of(&quot;META-INF/SIGNER.SF&quot;, &quot;dummy&quot;));
577         verify(&quot;3.jar&quot;, &quot;-verbose&quot;)
578                 .shouldHaveExitValue(16)
579                 .shouldContain(&quot;treated as unsigned&quot;)
580                 .shouldContain(&quot;Unparsable signature-related file META-INF/SIGNER.SF&quot;);
581         JarUtils.updateJar(s, &quot;4.jar&quot;, Map.of(&quot;META-INF/SIGNER.RSA&quot;, &quot;dummy&quot;));
582         verify(&quot;4.jar&quot;, &quot;-verbose&quot;)
583                 .shouldHaveExitValue(16)
584                 .shouldContain(&quot;treated as unsigned&quot;)
585                 .shouldContain(&quot;Unparsable signature-related file META-INF/SIGNER.RSA&quot;);
586     }
587 
588     static OutputAnalyzer jarsigner(List&lt;String&gt; extra)
589             throws Exception {
590         List&lt;String&gt; args = new ArrayList&lt;&gt;(
591                 List.of(&quot;-keystore&quot;, &quot;ks&quot;, &quot;-storepass&quot;, &quot;changeit&quot;));
592         args.addAll(extra);
593         return SecurityTools.jarsigner(args);
594     }
595 
596     static OutputAnalyzer verify(String file, String... extra)
597             throws Exception {
598         List&lt;String&gt; args = new ArrayList&lt;&gt;();
599         args.add(&quot;-verify&quot;);
600         args.add(&quot;-strict&quot;);
601         args.add(file);
602         args.addAll(Arrays.asList(extra));
603         return jarsigner(args);
604     }
605 
606     static void checkBadKU(String file) throws Exception {
607         verify(file)
608                 .shouldHaveExitValue(16)
609                 .shouldContain(&quot;treated as unsigned&quot;)
610                 .shouldContain(&quot;re-run jarsigner with debug enabled&quot;);
611         verify(file, &quot;-verbose&quot;)
612                 .shouldHaveExitValue(16)
613                 .shouldContain(&quot;Signed by&quot;)
614                 .shouldContain(&quot;treated as unsigned&quot;)
615                 .shouldContain(&quot;re-run jarsigner with debug enabled&quot;);
616         verify(file, &quot;-J-Djava.security.debug=jar&quot;)
617                 .shouldHaveExitValue(16)
618                 .shouldContain(&quot;SignatureException: Key usage restricted&quot;)
619                 .shouldContain(&quot;treated as unsigned&quot;)
620                 .shouldContain(&quot;re-run jarsigner with debug enabled&quot;);
621     }
622 
623     static void checkDisabled(String file) throws Exception {
624         verify(file)
625                 .shouldHaveExitValue(16)
626                 .shouldContain(&quot;treated as unsigned&quot;)
627                 .shouldMatch(&quot;weak algorithm that is now disabled.&quot;)
628                 .shouldMatch(&quot;Re-run jarsigner with the -verbose option for more details&quot;);
629         verify(file, &quot;-verbose&quot;)
630                 .shouldHaveExitValue(16)
631                 .shouldContain(&quot;treated as unsigned&quot;)
632                 .shouldMatch(&quot;weak algorithm that is now disabled by&quot;)
633                 .shouldMatch(&quot;Digest algorithm: .*(disabled)&quot;)
634                 .shouldMatch(&quot;Signature algorithm: .*(disabled)&quot;)
635                 .shouldMatch(&quot;Timestamp digest algorithm: .*(disabled)&quot;)
636                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(weak).*(weak)&quot;)
637                 .shouldMatch(&quot;Timestamp signature algorithm: .*key.*(disabled)&quot;);
638         verify(file, &quot;-J-Djava.security.debug=jar&quot;)
639                 .shouldHaveExitValue(16)
640                 .shouldMatch(&quot;SignatureException:.*disabled&quot;);
641 
642         // For 8171319: keytool should print out warnings when reading or
643         //              generating cert/cert req using disabled algorithms.
644         // Must call keytool the command, otherwise doPrintCert() might not
645         // be able to reset &quot;jdk.certpath.disabledAlgorithms&quot;.
646         String sout = SecurityTools.keytool(&quot;-printcert -jarfile &quot; + file)
647                 .stderrShouldContain(&quot;The TSA certificate uses a 512-bit RSA key&quot; +
648                         &quot; which is considered a security risk and is disabled.&quot;)
649                 .getStdout();
650         if (sout.indexOf(&quot;disabled&quot;, sout.indexOf(&quot;Timestamp:&quot;)) &lt; 0) {
651             throw new RuntimeException(&quot;timestamp not disabled: &quot; + sout);
652         }
653     }
654 
655     static void checkHalfDisabled(String file) throws Exception {
656         verify(file)
657                 .shouldHaveExitValue(16)
658                 .shouldContain(&quot;treated as unsigned&quot;)
659                 .shouldMatch(&quot;weak algorithm that is now disabled.&quot;)
660                 .shouldMatch(&quot;Re-run jarsigner with the -verbose option for more details&quot;);
661         verify(file, &quot;-verbose&quot;)
662                 .shouldHaveExitValue(16)
663                 .shouldContain(&quot;treated as unsigned&quot;)
664                 .shouldMatch(&quot;weak algorithm that is now disabled by&quot;)
665                 .shouldMatch(&quot;Digest algorithm: .*(disabled)&quot;)
666                 .shouldNotMatch(&quot;Signature algorithm: .*(weak)&quot;)
667                 .shouldNotMatch(&quot;Signature algorithm: .*(disabled)&quot;)
668                 .shouldNotMatch(&quot;Timestamp digest algorithm: .*(disabled)&quot;)
669                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(weak).*(weak)&quot;)
670                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(disabled).*(disabled)&quot;)
671                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*key.*(weak)&quot;)
672                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*key.*(disabled)&quot;);
673      }
674 
675     static void checkMultiple(String file) throws Exception {
676         verify(file)
677                 .shouldHaveExitValue(0)
678                 .shouldContain(&quot;jar verified&quot;);
679         verify(file, &quot;-verbose&quot;, &quot;-certs&quot;)
680                 .shouldHaveExitValue(0)
681                 .shouldContain(&quot;jar verified&quot;)
682                 .shouldMatch(&quot;X.509.*CN=dsakey&quot;)
683                 .shouldNotMatch(&quot;X.509.*CN=disabledkeysize&quot;)
684                 .shouldMatch(&quot;Signed by .*CN=dsakey&quot;)
685                 .shouldMatch(&quot;Signed by .*CN=disabledkeysize&quot;)
686                 .shouldMatch(&quot;Signature algorithm: .*key.*(disabled)&quot;);
687     }
688 
689     static void checkWeak(String file) throws Exception {
690         verify(file)
691                 .shouldHaveExitValue(0)
692                 .shouldNotContain(&quot;treated as unsigned&quot;);
693         verify(file, &quot;-verbose&quot;)
694                 .shouldHaveExitValue(0)
695                 .shouldNotContain(&quot;treated as unsigned&quot;)
696                 .shouldMatch(&quot;Digest algorithm: .*(weak)&quot;)
697                 .shouldMatch(&quot;Signature algorithm: .*(weak)&quot;)
698                 .shouldMatch(&quot;Timestamp digest algorithm: .*(weak)&quot;)
699                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(weak).*(weak)&quot;)
700                 .shouldMatch(&quot;Timestamp signature algorithm: .*key.*(weak)&quot;);
701         verify(file, &quot;-J-Djava.security.debug=jar&quot;)
702                 .shouldHaveExitValue(0)
703                 .shouldNotMatch(&quot;SignatureException:.*disabled&quot;);
704 
705         // keytool should print out warnings when reading or
706         // generating cert/cert req using legacy algorithms.
707         String sout = SecurityTools.keytool(&quot;-printcert -jarfile &quot; + file)
708                 .stderrShouldContain(&quot;The TSA certificate uses a 1024-bit RSA key&quot; +
709                         &quot; which is considered a security risk.&quot; +
710                         &quot; This key size will be disabled in a future update.&quot;)
711                 .getStdout();
712         if (sout.indexOf(&quot;weak&quot;, sout.indexOf(&quot;Timestamp:&quot;)) &lt; 0) {
713             throw new RuntimeException(&quot;timestamp not weak: &quot; + sout);
714         }
715     }
716 
717     static void checkHalfWeak(String file) throws Exception {
718         verify(file)
719                 .shouldHaveExitValue(0)
720                 .shouldNotContain(&quot;treated as unsigned&quot;);
721         verify(file, &quot;-verbose&quot;)
722                 .shouldHaveExitValue(0)
723                 .shouldNotContain(&quot;treated as unsigned&quot;)
724                 .shouldMatch(&quot;Digest algorithm: .*(weak)&quot;)
725                 .shouldNotMatch(&quot;Signature algorithm: .*(weak)&quot;)
726                 .shouldNotMatch(&quot;Signature algorithm: .*(disabled)&quot;)
727                 .shouldNotMatch(&quot;Timestamp digest algorithm: .*(weak)&quot;)
728                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(weak).*(weak)&quot;)
729                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(disabled).*(disabled)&quot;)
730                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*key.*(weak)&quot;)
731                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*key.*(disabled)&quot;);
732     }
733 
734     static void checkMultipleWeak(String file) throws Exception {
735         verify(file)
736                 .shouldHaveExitValue(0)
737                 .shouldContain(&quot;jar verified&quot;);
738         verify(file, &quot;-verbose&quot;, &quot;-certs&quot;)
739                 .shouldHaveExitValue(0)
740                 .shouldContain(&quot;jar verified&quot;)
741                 .shouldMatch(&quot;X.509.*CN=dsakey&quot;)
742                 .shouldMatch(&quot;X.509.*CN=weakkeysize&quot;)
743                 .shouldMatch(&quot;Signed by .*CN=dsakey&quot;)
744                 .shouldMatch(&quot;Signed by .*CN=weakkeysize&quot;)
745                 .shouldMatch(&quot;Signature algorithm: .*key.*(weak)&quot;);
746     }
747 
748     static void checkTimestamp(String file, String policyId, String digestAlg)
749             throws Exception {
750         try (JarFile jf = new JarFile(file)) {
751             JarEntry je = jf.getJarEntry(&quot;META-INF/SIGNER.RSA&quot;);
752             try (InputStream is = jf.getInputStream(je)) {
753                 byte[] content = is.readAllBytes();
754                 PKCS7 p7 = new PKCS7(content);
755                 SignerInfo[] si = p7.getSignerInfos();
756                 if (si == null || si.length == 0) {
757                     throw new Exception(&quot;Not signed&quot;);
758                 }
759                 PKCS9Attribute p9 = si[0].getUnauthenticatedAttributes()
760                         .getAttribute(PKCS9Attribute.SIGNATURE_TIMESTAMP_TOKEN_OID);
761                 PKCS7 tsToken = new PKCS7((byte[]) p9.getValue());
762                 TimestampToken tt =
763                         new TimestampToken(tsToken.getContentInfo().getData());
764                 if (!tt.getHashAlgorithm().toString().equals(digestAlg)) {
765                     throw new Exception(&quot;Digest alg different&quot;);
766                 }
767                 if (!tt.getPolicyID().equals(policyId)) {
768                     throw new Exception(&quot;policyId different&quot;);
769                 }
770             }
771         }
772     }
773 
774     static int which = 0;
775 
776     /**
777      * Sign with a TSA path. Always use alias &quot;signer&quot; to sign &quot;unsigned.jar&quot;.
778      * The signed jar name is always path.jar.
779      *
780      * @param extra more args given to jarsigner
781      */
782     static OutputAnalyzer sign(String path, String... extra)
783             throws Exception {
784         return signVerbose(
785                 path,
786                 &quot;unsigned.jar&quot;,
787                 path + &quot;.jar&quot;,
788                 &quot;signer&quot;,
789                 extra);
790     }
791 
792     static OutputAnalyzer signVerbose(
793             String path,    // TSA URL path
794             String oldJar,
795             String newJar,
796             String alias,   // signer
797             String...extra) throws Exception {
798         which++;
799         System.out.println(&quot;\n&gt;&gt; Test #&quot; + which);
800         List&lt;String&gt; args = new ArrayList&lt;&gt;(List.of(
801                 &quot;-strict&quot;, &quot;-verbose&quot;, &quot;-debug&quot;, &quot;-signedjar&quot;, newJar, oldJar, alias));
802         if (path != null) {
803             args.add(&quot;-tsa&quot;);
804             args.add(host + path);
805         }
806         args.addAll(Arrays.asList(extra));
807         return jarsigner(args);
808     }
809 
810     static void prepare() throws Exception {
811         JarUtils.createJar(&quot;unsigned.jar&quot;, &quot;A&quot;);
812         Files.deleteIfExists(Paths.get(&quot;ks&quot;));
813         keytool(&quot;-alias signer -genkeypair -ext bc -dname CN=signer&quot;);
814         keytool(&quot;-alias oldsigner -genkeypair -dname CN=oldsigner&quot;);
815         keytool(&quot;-alias dsakey -genkeypair -keyalg DSA -dname CN=dsakey&quot;);
816         keytool(&quot;-alias weakkeysize -genkeypair -keysize 1024 -dname CN=weakkeysize&quot;);
817         keytool(&quot;-alias disabledkeysize -genkeypair -keysize 512 -dname CN=disabledkeysize&quot;);
818         keytool(&quot;-alias badku -genkeypair -dname CN=badku&quot;);
819         keytool(&quot;-alias ts -genkeypair -dname CN=ts&quot;);
820         keytool(&quot;-alias tsold -genkeypair -dname CN=tsold&quot;);
821         keytool(&quot;-alias tsweak -genkeypair -keysize 1024 -dname CN=tsweak&quot;);
822         keytool(&quot;-alias tsdisabled -genkeypair -keysize 512 -dname CN=tsdisabled&quot;);
823         keytool(&quot;-alias tsbad1 -genkeypair -dname CN=tsbad1&quot;);
824         keytool(&quot;-alias tsbad2 -genkeypair -dname CN=tsbad2&quot;);
825         keytool(&quot;-alias tsbad3 -genkeypair -dname CN=tsbad3&quot;);
826         keytool(&quot;-alias tsnoca -genkeypair -dname CN=tsnoca&quot;);
827 
828         keytool(&quot;-alias expired -genkeypair -dname CN=expired&quot;);
829         keytool(&quot;-alias expiring -genkeypair -dname CN=expiring&quot;);
830         keytool(&quot;-alias long -genkeypair -dname CN=long&quot;);
831         keytool(&quot;-alias tsexpired -genkeypair -dname CN=tsexpired&quot;);
832         keytool(&quot;-alias tsexpiring -genkeypair -dname CN=tsexpiring&quot;);
833         keytool(&quot;-alias tsexpiringsoon -genkeypair -dname CN=tsexpiringsoon&quot;);
834         keytool(&quot;-alias tslong -genkeypair -dname CN=tslong&quot;);
835 
836         // tsnoca&#39;s issuer will be removed from keystore later
837         keytool(&quot;-alias ca -genkeypair -ext bc -dname CN=CA&quot;);
838         gencert(&quot;tsnoca&quot;, &quot;-ext eku:critical=ts&quot;);
839         keytool(&quot;-delete -alias ca&quot;);
840         keytool(&quot;-alias ca -genkeypair -ext bc -dname CN=CA -startdate -40d&quot;);
841 
842         gencert(&quot;signer&quot;);
843         gencert(&quot;oldsigner&quot;, &quot;-startdate -30d -validity 20&quot;);
844         gencert(&quot;dsakey&quot;);
845         gencert(&quot;weakkeysize&quot;);
846         gencert(&quot;disabledkeysize&quot;);
847         gencert(&quot;badku&quot;, &quot;-ext ku:critical=keyAgreement&quot;);
848         gencert(&quot;ts&quot;, &quot;-ext eku:critical=ts -validity 500&quot;);
849 
850         gencert(&quot;expired&quot;, &quot;-validity 10 -startdate -12d&quot;);
851         gencert(&quot;expiring&quot;, &quot;-validity 178&quot;);
852         gencert(&quot;long&quot;, &quot;-validity 182&quot;);
853         gencert(&quot;tsexpired&quot;, &quot;-ext eku:critical=ts -validity 10 -startdate -12d&quot;);
854         gencert(&quot;tsexpiring&quot;, &quot;-ext eku:critical=ts -validity 364&quot;);
855         gencert(&quot;tsexpiringsoon&quot;, &quot;-ext eku:critical=ts -validity 170&quot;); // earlier than expiring
856         gencert(&quot;tslong&quot;, &quot;-ext eku:critical=ts -validity 367&quot;);
857 
858 
859         for (int i = 0; i &lt; 5; i++) {
860             // Issue another cert for &quot;ts&quot; with a different EKU.
861             // Length might be different because serial number is
862             // random. Try several times until a cert with the same
863             // length is generated so we can substitute ts.cert
864             // embedded in the PKCS7 block with ts2.cert.
865             // If cannot create one, related test will be ignored.
866             keytool(&quot;-gencert -alias ca -infile ts.req -outfile ts2.cert &quot; +
867                     &quot;-ext eku:critical=1.3.6.1.5.5.7.3.9&quot;);
868             if (Files.size(Paths.get(&quot;ts.cert&quot;)) != Files.size(Paths.get(&quot;ts2.cert&quot;))) {
869                 Files.delete(Paths.get(&quot;ts2.cert&quot;));
870                 System.out.println(&quot;Warning: cannot create same length&quot;);
871             } else {
872                 break;
873             }
874         }
875 
876         gencert(&quot;tsold&quot;, &quot;-ext eku:critical=ts -startdate -40d -validity 500&quot;);
877 
878         gencert(&quot;tsweak&quot;, &quot;-ext eku:critical=ts&quot;);
879         gencert(&quot;tsdisabled&quot;, &quot;-ext eku:critical=ts&quot;);
880         gencert(&quot;tsbad1&quot;);
881         gencert(&quot;tsbad2&quot;, &quot;-ext eku=ts&quot;);
882         gencert(&quot;tsbad3&quot;, &quot;-ext eku:critical=cs&quot;);
883     }
884 
885     static void gencert(String alias, String... extra) throws Exception {
886         keytool(&quot;-alias &quot; + alias + &quot; -certreq -file &quot; + alias + &quot;.req&quot;);
887         String genCmd = &quot;-gencert -alias ca -infile &quot; +
888                 alias + &quot;.req -outfile &quot; + alias + &quot;.cert&quot;;
889         for (String s : extra) {
890             genCmd += &quot; &quot; + s;
891         }
892         keytool(genCmd);
893         keytool(&quot;-alias &quot; + alias + &quot; -importcert -file &quot; + alias + &quot;.cert&quot;);
894     }
895 
896     static void keytool(String cmd) throws Exception {
897         cmd = &quot;-keystore ks -storepass changeit -keypass changeit &quot; +
898                 &quot;-keyalg rsa -validity 200 &quot; + cmd;
899         sun.security.tools.keytool.Main.main(cmd.split(&quot; &quot;));
900     }
901 }
    </pre>
  </body>
</html>