<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/safepointMechanism.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="java.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/safepointMechanism.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
56 
57   // By adding 8 to the base address of the protected polling page we can differentiate
58   // between the armed and disarmed value by masking out this bit.
59   const static intptr_t _poll_bit = 8;
60 public:
61   static intptr_t poll_bit() { return _poll_bit; }
62 
63   static address get_polling_page()             { return _polling_page; }
64   static bool    is_poll_address(address addr)  { return addr &gt;= _polling_page &amp;&amp; addr &lt; (_polling_page + os::vm_page_size()); }
65 
66   // Call this method to see if this thread should block for a safepoint or process handshake.
67   static inline bool should_block(Thread* thread);
68 
69   // Blocks a thread until safepoint/handshake is completed.
70   static inline void block_if_requested(JavaThread* thread);
71 
72   // Caller is responsible for using a memory barrier if needed.
73   static inline void arm_local_poll(JavaThread* thread);
74   // Release semantics
75   static inline void arm_local_poll_release(JavaThread* thread);
<span class="line-removed">76   // Optional release</span>
<span class="line-removed">77   static inline void disarm_if_needed(JavaThread* thread, bool memory_order_release);</span>
78 
79   // Setup the selected safepoint mechanism
80   static void initialize();
81   static void initialize_header(JavaThread* thread);
82 };
83 
84 #endif // SHARE_RUNTIME_SAFEPOINTMECHANISM_HPP
</pre>
</td>
<td>
<hr />
<pre>
56 
57   // By adding 8 to the base address of the protected polling page we can differentiate
58   // between the armed and disarmed value by masking out this bit.
59   const static intptr_t _poll_bit = 8;
60 public:
61   static intptr_t poll_bit() { return _poll_bit; }
62 
63   static address get_polling_page()             { return _polling_page; }
64   static bool    is_poll_address(address addr)  { return addr &gt;= _polling_page &amp;&amp; addr &lt; (_polling_page + os::vm_page_size()); }
65 
66   // Call this method to see if this thread should block for a safepoint or process handshake.
67   static inline bool should_block(Thread* thread);
68 
69   // Blocks a thread until safepoint/handshake is completed.
70   static inline void block_if_requested(JavaThread* thread);
71 
72   // Caller is responsible for using a memory barrier if needed.
73   static inline void arm_local_poll(JavaThread* thread);
74   // Release semantics
75   static inline void arm_local_poll_release(JavaThread* thread);


76 
77   // Setup the selected safepoint mechanism
78   static void initialize();
79   static void initialize_header(JavaThread* thread);
80 };
81 
82 #endif // SHARE_RUNTIME_SAFEPOINTMECHANISM_HPP
</pre>
</td>
</tr>
</table>
<center><a href="java.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>