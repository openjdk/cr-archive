<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/matcher.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;oops/compressedOops.hpp&quot;
  31 #include &quot;opto/ad.hpp&quot;
  32 #include &quot;opto/addnode.hpp&quot;
  33 #include &quot;opto/callnode.hpp&quot;
  34 #include &quot;opto/idealGraphPrinter.hpp&quot;
  35 #include &quot;opto/matcher.hpp&quot;
  36 #include &quot;opto/memnode.hpp&quot;
  37 #include &quot;opto/movenode.hpp&quot;
  38 #include &quot;opto/opcodes.hpp&quot;
  39 #include &quot;opto/regmask.hpp&quot;
  40 #include &quot;opto/rootnode.hpp&quot;
  41 #include &quot;opto/runtime.hpp&quot;
  42 #include &quot;opto/type.hpp&quot;
  43 #include &quot;opto/vectornode.hpp&quot;
  44 #include &quot;runtime/os.hpp&quot;
  45 #include &quot;runtime/sharedRuntime.hpp&quot;
  46 #include &quot;utilities/align.hpp&quot;
  47 
  48 OptoReg::Name OptoReg::c_frame_pointer;
  49 
  50 const RegMask *Matcher::idealreg2regmask[_last_machine_leaf];
  51 RegMask Matcher::mreg2regmask[_last_Mach_Reg];
  52 RegMask Matcher::STACK_ONLY_mask;
  53 RegMask Matcher::c_frame_ptr_mask;
  54 const uint Matcher::_begin_rematerialize = _BEGIN_REMATERIALIZE;
  55 const uint Matcher::_end_rematerialize   = _END_REMATERIALIZE;
  56 
  57 //---------------------------Matcher-------------------------------------------
  58 Matcher::Matcher()
  59 : PhaseTransform( Phase::Ins_Select ),
  60   _states_arena(Chunk::medium_size, mtCompiler),
  61   _visited(&amp;_states_arena),
  62   _shared(&amp;_states_arena),
  63   _dontcare(&amp;_states_arena),
  64   _reduceOp(reduceOp), _leftOp(leftOp), _rightOp(rightOp),
  65   _swallowed(swallowed),
  66   _begin_inst_chain_rule(_BEGIN_INST_CHAIN_RULE),
  67   _end_inst_chain_rule(_END_INST_CHAIN_RULE),
  68   _must_clone(must_clone),
  69   _shared_nodes(C-&gt;comp_arena()),
  70 #ifdef ASSERT
  71   _old2new_map(C-&gt;comp_arena()),
  72   _new2old_map(C-&gt;comp_arena()),
  73 #endif
  74   _allocation_started(false),
  75   _ruleName(ruleName),
  76   _register_save_policy(register_save_policy),
  77   _c_reg_save_policy(c_reg_save_policy),
  78   _register_save_type(register_save_type) {
  79   C-&gt;set_matcher(this);
  80 
  81   idealreg2spillmask  [Op_RegI] = NULL;
  82   idealreg2spillmask  [Op_RegN] = NULL;
  83   idealreg2spillmask  [Op_RegL] = NULL;
  84   idealreg2spillmask  [Op_RegF] = NULL;
  85   idealreg2spillmask  [Op_RegD] = NULL;
  86   idealreg2spillmask  [Op_RegP] = NULL;
  87   idealreg2spillmask  [Op_VecS] = NULL;
  88   idealreg2spillmask  [Op_VecD] = NULL;
  89   idealreg2spillmask  [Op_VecX] = NULL;
  90   idealreg2spillmask  [Op_VecY] = NULL;
  91   idealreg2spillmask  [Op_VecZ] = NULL;
  92   idealreg2spillmask  [Op_RegFlags] = NULL;
  93 
  94   idealreg2debugmask  [Op_RegI] = NULL;
  95   idealreg2debugmask  [Op_RegN] = NULL;
  96   idealreg2debugmask  [Op_RegL] = NULL;
  97   idealreg2debugmask  [Op_RegF] = NULL;
  98   idealreg2debugmask  [Op_RegD] = NULL;
  99   idealreg2debugmask  [Op_RegP] = NULL;
 100   idealreg2debugmask  [Op_VecS] = NULL;
 101   idealreg2debugmask  [Op_VecD] = NULL;
 102   idealreg2debugmask  [Op_VecX] = NULL;
 103   idealreg2debugmask  [Op_VecY] = NULL;
 104   idealreg2debugmask  [Op_VecZ] = NULL;
 105   idealreg2debugmask  [Op_RegFlags] = NULL;
 106 
 107   idealreg2mhdebugmask[Op_RegI] = NULL;
 108   idealreg2mhdebugmask[Op_RegN] = NULL;
 109   idealreg2mhdebugmask[Op_RegL] = NULL;
 110   idealreg2mhdebugmask[Op_RegF] = NULL;
 111   idealreg2mhdebugmask[Op_RegD] = NULL;
 112   idealreg2mhdebugmask[Op_RegP] = NULL;
 113   idealreg2mhdebugmask[Op_VecS] = NULL;
 114   idealreg2mhdebugmask[Op_VecD] = NULL;
 115   idealreg2mhdebugmask[Op_VecX] = NULL;
 116   idealreg2mhdebugmask[Op_VecY] = NULL;
 117   idealreg2mhdebugmask[Op_VecZ] = NULL;
 118   idealreg2mhdebugmask[Op_RegFlags] = NULL;
 119 
 120   debug_only(_mem_node = NULL;)   // Ideal memory node consumed by mach node
 121 }
 122 
 123 //------------------------------warp_incoming_stk_arg------------------------
 124 // This warps a VMReg into an OptoReg::Name
 125 OptoReg::Name Matcher::warp_incoming_stk_arg( VMReg reg ) {
 126   OptoReg::Name warped;
 127   if( reg-&gt;is_stack() ) {  // Stack slot argument?
 128     warped = OptoReg::add(_old_SP, reg-&gt;reg2stack() );
 129     warped = OptoReg::add(warped, C-&gt;out_preserve_stack_slots());
 130     if( warped &gt;= _in_arg_limit )
 131       _in_arg_limit = OptoReg::add(warped, 1); // Bump max stack slot seen
 132     if (!RegMask::can_represent_arg(warped)) {
 133       // the compiler cannot represent this method&#39;s calling sequence
 134       C-&gt;record_method_not_compilable(&quot;unsupported incoming calling sequence&quot;);
 135       return OptoReg::Bad;
 136     }
 137     return warped;
 138   }
 139   return OptoReg::as_OptoReg(reg);
 140 }
 141 
 142 //---------------------------compute_old_SP------------------------------------
 143 OptoReg::Name Compile::compute_old_SP() {
 144   int fixed    = fixed_slots();
 145   int preserve = in_preserve_stack_slots();
 146   return OptoReg::stack2reg(align_up(fixed + preserve, (int)Matcher::stack_alignment_in_slots()));
 147 }
 148 
 149 
 150 
 151 #ifdef ASSERT
 152 void Matcher::verify_new_nodes_only(Node* xroot) {
 153   // Make sure that the new graph only references new nodes
 154   ResourceMark rm;
 155   Unique_Node_List worklist;
 156   VectorSet visited;
 157   worklist.push(xroot);
 158   while (worklist.size() &gt; 0) {
 159     Node* n = worklist.pop();
 160     visited.set(n-&gt;_idx);
 161     assert(C-&gt;node_arena()-&gt;contains(n), &quot;dead node&quot;);
 162     for (uint j = 0; j &lt; n-&gt;req(); j++) {
 163       Node* in = n-&gt;in(j);
 164       if (in != NULL) {
 165         assert(C-&gt;node_arena()-&gt;contains(in), &quot;dead node&quot;);
 166         if (!visited.test(in-&gt;_idx)) {
 167           worklist.push(in);
 168         }
 169       }
 170     }
 171   }
 172 }
 173 #endif
 174 
 175 
 176 //---------------------------match---------------------------------------------
 177 void Matcher::match( ) {
 178   if( MaxLabelRootDepth &lt; 100 ) { // Too small?
 179     assert(false, &quot;invalid MaxLabelRootDepth, increase it to 100 minimum&quot;);
 180     MaxLabelRootDepth = 100;
 181   }
 182   // One-time initialization of some register masks.
 183   init_spill_mask( C-&gt;root()-&gt;in(1) );
 184   _return_addr_mask = return_addr();
 185 #ifdef _LP64
 186   // Pointers take 2 slots in 64-bit land
 187   _return_addr_mask.Insert(OptoReg::add(return_addr(),1));
 188 #endif
 189 
 190   // Map a Java-signature return type into return register-value
 191   // machine registers for 0, 1 and 2 returned values.
 192   const TypeTuple *range = C-&gt;tf()-&gt;range();
 193   if( range-&gt;cnt() &gt; TypeFunc::Parms ) { // If not a void function
 194     // Get ideal-register return type
 195     uint ireg = range-&gt;field_at(TypeFunc::Parms)-&gt;ideal_reg();
 196     // Get machine return register
 197     uint sop = C-&gt;start()-&gt;Opcode();
 198     OptoRegPair regs = return_value(ireg, false);
 199 
 200     // And mask for same
 201     _return_value_mask = RegMask(regs.first());
 202     if( OptoReg::is_valid(regs.second()) )
 203       _return_value_mask.Insert(regs.second());
 204   }
 205 
 206   // ---------------
 207   // Frame Layout
 208 
 209   // Need the method signature to determine the incoming argument types,
 210   // because the types determine which registers the incoming arguments are
 211   // in, and this affects the matched code.
 212   const TypeTuple *domain = C-&gt;tf()-&gt;domain();
 213   uint             argcnt = domain-&gt;cnt() - TypeFunc::Parms;
 214   BasicType *sig_bt        = NEW_RESOURCE_ARRAY( BasicType, argcnt );
 215   VMRegPair *vm_parm_regs  = NEW_RESOURCE_ARRAY( VMRegPair, argcnt );
 216   _parm_regs               = NEW_RESOURCE_ARRAY( OptoRegPair, argcnt );
 217   _calling_convention_mask = NEW_RESOURCE_ARRAY( RegMask, argcnt );
 218   uint i;
 219   for( i = 0; i&lt;argcnt; i++ ) {
 220     sig_bt[i] = domain-&gt;field_at(i+TypeFunc::Parms)-&gt;basic_type();
 221   }
 222 
 223   // Pass array of ideal registers and length to USER code (from the AD file)
 224   // that will convert this to an array of register numbers.
 225   const StartNode *start = C-&gt;start();
 226   start-&gt;calling_convention( sig_bt, vm_parm_regs, argcnt );
 227 #ifdef ASSERT
 228   // Sanity check users&#39; calling convention.  Real handy while trying to
 229   // get the initial port correct.
 230   { for (uint i = 0; i&lt;argcnt; i++) {
 231       if( !vm_parm_regs[i].first()-&gt;is_valid() &amp;&amp; !vm_parm_regs[i].second()-&gt;is_valid() ) {
 232         assert(domain-&gt;field_at(i+TypeFunc::Parms)==Type::HALF, &quot;only allowed on halve&quot; );
 233         _parm_regs[i].set_bad();
 234         continue;
 235       }
 236       VMReg parm_reg = vm_parm_regs[i].first();
 237       assert(parm_reg-&gt;is_valid(), &quot;invalid arg?&quot;);
 238       if (parm_reg-&gt;is_reg()) {
 239         OptoReg::Name opto_parm_reg = OptoReg::as_OptoReg(parm_reg);
 240         assert(can_be_java_arg(opto_parm_reg) ||
 241                C-&gt;stub_function() == CAST_FROM_FN_PTR(address, OptoRuntime::rethrow_C) ||
 242                opto_parm_reg == inline_cache_reg(),
 243                &quot;parameters in register must be preserved by runtime stubs&quot;);
 244       }
 245       for (uint j = 0; j &lt; i; j++) {
 246         assert(parm_reg != vm_parm_regs[j].first(),
 247                &quot;calling conv. must produce distinct regs&quot;);
 248       }
 249     }
 250   }
 251 #endif
 252 
 253   // Do some initial frame layout.
 254 
 255   // Compute the old incoming SP (may be called FP) as
 256   //   OptoReg::stack0() + locks + in_preserve_stack_slots + pad2.
 257   _old_SP = C-&gt;compute_old_SP();
 258   assert( is_even(_old_SP), &quot;must be even&quot; );
 259 
 260   // Compute highest incoming stack argument as
 261   //   _old_SP + out_preserve_stack_slots + incoming argument size.
 262   _in_arg_limit = OptoReg::add(_old_SP, C-&gt;out_preserve_stack_slots());
 263   assert( is_even(_in_arg_limit), &quot;out_preserve must be even&quot; );
 264   for( i = 0; i &lt; argcnt; i++ ) {
 265     // Permit args to have no register
 266     _calling_convention_mask[i].Clear();
 267     if( !vm_parm_regs[i].first()-&gt;is_valid() &amp;&amp; !vm_parm_regs[i].second()-&gt;is_valid() ) {
 268       continue;
 269     }
 270     // calling_convention returns stack arguments as a count of
 271     // slots beyond OptoReg::stack0()/VMRegImpl::stack0.  We need to convert this to
 272     // the allocators point of view, taking into account all the
 273     // preserve area, locks &amp; pad2.
 274 
 275     OptoReg::Name reg1 = warp_incoming_stk_arg(vm_parm_regs[i].first());
 276     if( OptoReg::is_valid(reg1))
 277       _calling_convention_mask[i].Insert(reg1);
 278 
 279     OptoReg::Name reg2 = warp_incoming_stk_arg(vm_parm_regs[i].second());
 280     if( OptoReg::is_valid(reg2))
 281       _calling_convention_mask[i].Insert(reg2);
 282 
 283     // Saved biased stack-slot register number
 284     _parm_regs[i].set_pair(reg2, reg1);
 285   }
 286 
 287   // Finally, make sure the incoming arguments take up an even number of
 288   // words, in case the arguments or locals need to contain doubleword stack
 289   // slots.  The rest of the system assumes that stack slot pairs (in
 290   // particular, in the spill area) which look aligned will in fact be
 291   // aligned relative to the stack pointer in the target machine.  Double
 292   // stack slots will always be allocated aligned.
 293   _new_SP = OptoReg::Name(align_up(_in_arg_limit, (int)RegMask::SlotsPerLong));
 294 
 295   // Compute highest outgoing stack argument as
 296   //   _new_SP + out_preserve_stack_slots + max(outgoing argument size).
 297   _out_arg_limit = OptoReg::add(_new_SP, C-&gt;out_preserve_stack_slots());
 298   assert( is_even(_out_arg_limit), &quot;out_preserve must be even&quot; );
 299 
 300   if (!RegMask::can_represent_arg(OptoReg::add(_out_arg_limit,-1))) {
 301     // the compiler cannot represent this method&#39;s calling sequence
 302     C-&gt;record_method_not_compilable(&quot;must be able to represent all call arguments in reg mask&quot;);
 303   }
 304 
 305   if (C-&gt;failing())  return;  // bailed out on incoming arg failure
 306 
 307   // ---------------
 308   // Collect roots of matcher trees.  Every node for which
 309   // _shared[_idx] is cleared is guaranteed to not be shared, and thus
 310   // can be a valid interior of some tree.
 311   find_shared( C-&gt;root() );
 312   find_shared( C-&gt;top() );
 313 
 314   C-&gt;print_method(PHASE_BEFORE_MATCHING);
 315 
 316   // Create new ideal node ConP #NULL even if it does exist in old space
 317   // to avoid false sharing if the corresponding mach node is not used.
 318   // The corresponding mach node is only used in rare cases for derived
 319   // pointers.
 320   Node* new_ideal_null = ConNode::make(TypePtr::NULL_PTR);
 321 
 322   // Swap out to old-space; emptying new-space
 323   Arena *old = C-&gt;node_arena()-&gt;move_contents(C-&gt;old_arena());
 324 
 325   // Save debug and profile information for nodes in old space:
 326   _old_node_note_array = C-&gt;node_note_array();
 327   if (_old_node_note_array != NULL) {
 328     C-&gt;set_node_note_array(new(C-&gt;comp_arena()) GrowableArray&lt;Node_Notes*&gt;
 329                            (C-&gt;comp_arena(), _old_node_note_array-&gt;length(),
 330                             0, NULL));
 331   }
 332 
 333   // Pre-size the new_node table to avoid the need for range checks.
 334   grow_new_node_array(C-&gt;unique());
 335 
 336   // Reset node counter so MachNodes start with _idx at 0
 337   int live_nodes = C-&gt;live_nodes();
 338   C-&gt;set_unique(0);
 339   C-&gt;reset_dead_node_list();
 340 
 341   // Recursively match trees from old space into new space.
 342   // Correct leaves of new-space Nodes; they point to old-space.
 343   _visited.clear();
 344   C-&gt;set_cached_top_node(xform( C-&gt;top(), live_nodes ));
 345   if (!C-&gt;failing()) {
 346     Node* xroot =        xform( C-&gt;root(), 1 );
 347     if (xroot == NULL) {
 348       Matcher::soft_match_failure();  // recursive matching process failed
 349       C-&gt;record_method_not_compilable(&quot;instruction match failed&quot;);
 350     } else {
 351       // During matching shared constants were attached to C-&gt;root()
 352       // because xroot wasn&#39;t available yet, so transfer the uses to
 353       // the xroot.
 354       for( DUIterator_Fast jmax, j = C-&gt;root()-&gt;fast_outs(jmax); j &lt; jmax; j++ ) {
 355         Node* n = C-&gt;root()-&gt;fast_out(j);
 356         if (C-&gt;node_arena()-&gt;contains(n)) {
 357           assert(n-&gt;in(0) == C-&gt;root(), &quot;should be control user&quot;);
 358           n-&gt;set_req(0, xroot);
 359           --j;
 360           --jmax;
 361         }
 362       }
 363 
 364       // Generate new mach node for ConP #NULL
 365       assert(new_ideal_null != NULL, &quot;sanity&quot;);
 366       _mach_null = match_tree(new_ideal_null);
 367       // Don&#39;t set control, it will confuse GCM since there are no uses.
 368       // The control will be set when this node is used first time
 369       // in find_base_for_derived().
 370       assert(_mach_null != NULL, &quot;&quot;);
 371 
 372       C-&gt;set_root(xroot-&gt;is_Root() ? xroot-&gt;as_Root() : NULL);
 373 
 374 #ifdef ASSERT
 375       verify_new_nodes_only(xroot);
 376 #endif
 377     }
 378   }
 379   if (C-&gt;top() == NULL || C-&gt;root() == NULL) {
 380     C-&gt;record_method_not_compilable(&quot;graph lost&quot;); // %%% cannot happen?
 381   }
 382   if (C-&gt;failing()) {
 383     // delete old;
 384     old-&gt;destruct_contents();
 385     return;
 386   }
 387   assert( C-&gt;top(), &quot;&quot; );
 388   assert( C-&gt;root(), &quot;&quot; );
 389   validate_null_checks();
 390 
 391   // Now smoke old-space
 392   NOT_DEBUG( old-&gt;destruct_contents() );
 393 
 394   // ------------------------
 395   // Set up save-on-entry registers.
 396   Fixup_Save_On_Entry( );
 397 
 398   { // Cleanup mach IR after selection phase is over.
 399     Compile::TracePhase tp(&quot;postselect_cleanup&quot;, &amp;timers[_t_postselect_cleanup]);
 400     do_postselect_cleanup();
 401     if (C-&gt;failing())  return;
 402     assert(verify_after_postselect_cleanup(), &quot;&quot;);
 403   }
 404 }
 405 
 406 //------------------------------Fixup_Save_On_Entry----------------------------
 407 // The stated purpose of this routine is to take care of save-on-entry
 408 // registers.  However, the overall goal of the Match phase is to convert into
 409 // machine-specific instructions which have RegMasks to guide allocation.
 410 // So what this procedure really does is put a valid RegMask on each input
 411 // to the machine-specific variations of all Return, TailCall and Halt
 412 // instructions.  It also adds edgs to define the save-on-entry values (and of
 413 // course gives them a mask).
 414 
 415 static RegMask *init_input_masks( uint size, RegMask &amp;ret_adr, RegMask &amp;fp ) {
 416   RegMask *rms = NEW_RESOURCE_ARRAY( RegMask, size );
 417   // Do all the pre-defined register masks
 418   rms[TypeFunc::Control  ] = RegMask::Empty;
 419   rms[TypeFunc::I_O      ] = RegMask::Empty;
 420   rms[TypeFunc::Memory   ] = RegMask::Empty;
 421   rms[TypeFunc::ReturnAdr] = ret_adr;
 422   rms[TypeFunc::FramePtr ] = fp;
 423   return rms;
 424 }
 425 
 426 #define NOF_STACK_MASKS (3*6+5)
 427 
 428 // Create the initial stack mask used by values spilling to the stack.
 429 // Disallow any debug info in outgoing argument areas by setting the
 430 // initial mask accordingly.
 431 void Matcher::init_first_stack_mask() {
 432 
 433   // Allocate storage for spill masks as masks for the appropriate load type.
 434   RegMask *rms = (RegMask*)C-&gt;comp_arena()-&gt;Amalloc_D(sizeof(RegMask) * NOF_STACK_MASKS);
 435 
 436   // Initialize empty placeholder masks into the newly allocated arena
 437   for (int i = 0; i &lt; NOF_STACK_MASKS; i++) {
 438     new (rms + i) RegMask();
 439   }
 440 
 441   idealreg2spillmask  [Op_RegN] = &amp;rms[0];
 442   idealreg2spillmask  [Op_RegI] = &amp;rms[1];
 443   idealreg2spillmask  [Op_RegL] = &amp;rms[2];
 444   idealreg2spillmask  [Op_RegF] = &amp;rms[3];
 445   idealreg2spillmask  [Op_RegD] = &amp;rms[4];
 446   idealreg2spillmask  [Op_RegP] = &amp;rms[5];
 447 
 448   idealreg2debugmask  [Op_RegN] = &amp;rms[6];
 449   idealreg2debugmask  [Op_RegI] = &amp;rms[7];
 450   idealreg2debugmask  [Op_RegL] = &amp;rms[8];
 451   idealreg2debugmask  [Op_RegF] = &amp;rms[9];
 452   idealreg2debugmask  [Op_RegD] = &amp;rms[10];
 453   idealreg2debugmask  [Op_RegP] = &amp;rms[11];
 454 
 455   idealreg2mhdebugmask[Op_RegN] = &amp;rms[12];
 456   idealreg2mhdebugmask[Op_RegI] = &amp;rms[13];
 457   idealreg2mhdebugmask[Op_RegL] = &amp;rms[14];
 458   idealreg2mhdebugmask[Op_RegF] = &amp;rms[15];
 459   idealreg2mhdebugmask[Op_RegD] = &amp;rms[16];
 460   idealreg2mhdebugmask[Op_RegP] = &amp;rms[17];
 461 
 462   idealreg2spillmask  [Op_VecS] = &amp;rms[18];
 463   idealreg2spillmask  [Op_VecD] = &amp;rms[19];
 464   idealreg2spillmask  [Op_VecX] = &amp;rms[20];
 465   idealreg2spillmask  [Op_VecY] = &amp;rms[21];
 466   idealreg2spillmask  [Op_VecZ] = &amp;rms[22];
 467 
 468   OptoReg::Name i;
 469 
 470   // At first, start with the empty mask
 471   C-&gt;FIRST_STACK_mask().Clear();
 472 
 473   // Add in the incoming argument area
 474   OptoReg::Name init_in = OptoReg::add(_old_SP, C-&gt;out_preserve_stack_slots());
 475   for (i = init_in; i &lt; _in_arg_limit; i = OptoReg::add(i,1)) {
 476     C-&gt;FIRST_STACK_mask().Insert(i);
 477   }
 478   // Add in all bits past the outgoing argument area
 479   guarantee(RegMask::can_represent_arg(OptoReg::add(_out_arg_limit,-1)),
 480             &quot;must be able to represent all call arguments in reg mask&quot;);
 481   OptoReg::Name init = _out_arg_limit;
 482   for (i = init; RegMask::can_represent(i); i = OptoReg::add(i,1)) {
 483     C-&gt;FIRST_STACK_mask().Insert(i);
 484   }
 485   // Finally, set the &quot;infinite stack&quot; bit.
 486   C-&gt;FIRST_STACK_mask().set_AllStack();
 487 
 488   // Make spill masks.  Registers for their class, plus FIRST_STACK_mask.
 489   RegMask aligned_stack_mask = C-&gt;FIRST_STACK_mask();
 490   // Keep spill masks aligned.
 491   aligned_stack_mask.clear_to_pairs();
 492   assert(aligned_stack_mask.is_AllStack(), &quot;should be infinite stack&quot;);
 493 
 494   *idealreg2spillmask[Op_RegP] = *idealreg2regmask[Op_RegP];
 495 #ifdef _LP64
 496   *idealreg2spillmask[Op_RegN] = *idealreg2regmask[Op_RegN];
 497    idealreg2spillmask[Op_RegN]-&gt;OR(C-&gt;FIRST_STACK_mask());
 498    idealreg2spillmask[Op_RegP]-&gt;OR(aligned_stack_mask);
 499 #else
 500    idealreg2spillmask[Op_RegP]-&gt;OR(C-&gt;FIRST_STACK_mask());
 501 #endif
 502   *idealreg2spillmask[Op_RegI] = *idealreg2regmask[Op_RegI];
 503    idealreg2spillmask[Op_RegI]-&gt;OR(C-&gt;FIRST_STACK_mask());
 504   *idealreg2spillmask[Op_RegL] = *idealreg2regmask[Op_RegL];
 505    idealreg2spillmask[Op_RegL]-&gt;OR(aligned_stack_mask);
 506   *idealreg2spillmask[Op_RegF] = *idealreg2regmask[Op_RegF];
 507    idealreg2spillmask[Op_RegF]-&gt;OR(C-&gt;FIRST_STACK_mask());
 508   *idealreg2spillmask[Op_RegD] = *idealreg2regmask[Op_RegD];
 509    idealreg2spillmask[Op_RegD]-&gt;OR(aligned_stack_mask);
 510 
 511   if (Matcher::vector_size_supported(T_BYTE,4)) {
 512     *idealreg2spillmask[Op_VecS] = *idealreg2regmask[Op_VecS];
 513      idealreg2spillmask[Op_VecS]-&gt;OR(C-&gt;FIRST_STACK_mask());
 514   }
 515   if (Matcher::vector_size_supported(T_FLOAT,2)) {
 516     // For VecD we need dual alignment and 8 bytes (2 slots) for spills.
 517     // RA guarantees such alignment since it is needed for Double and Long values.
 518     *idealreg2spillmask[Op_VecD] = *idealreg2regmask[Op_VecD];
 519      idealreg2spillmask[Op_VecD]-&gt;OR(aligned_stack_mask);
 520   }
 521   if (Matcher::vector_size_supported(T_FLOAT,4)) {
 522     // For VecX we need quadro alignment and 16 bytes (4 slots) for spills.
 523     //
 524     // RA can use input arguments stack slots for spills but until RA
 525     // we don&#39;t know frame size and offset of input arg stack slots.
 526     //
 527     // Exclude last input arg stack slots to avoid spilling vectors there
 528     // otherwise vector spills could stomp over stack slots in caller frame.
 529     OptoReg::Name in = OptoReg::add(_in_arg_limit, -1);
 530     for (int k = 1; (in &gt;= init_in) &amp;&amp; (k &lt; RegMask::SlotsPerVecX); k++) {
 531       aligned_stack_mask.Remove(in);
 532       in = OptoReg::add(in, -1);
 533     }
 534      aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecX);
 535      assert(aligned_stack_mask.is_AllStack(), &quot;should be infinite stack&quot;);
 536     *idealreg2spillmask[Op_VecX] = *idealreg2regmask[Op_VecX];
 537      idealreg2spillmask[Op_VecX]-&gt;OR(aligned_stack_mask);
 538   }
 539   if (Matcher::vector_size_supported(T_FLOAT,8)) {
 540     // For VecY we need octo alignment and 32 bytes (8 slots) for spills.
 541     OptoReg::Name in = OptoReg::add(_in_arg_limit, -1);
 542     for (int k = 1; (in &gt;= init_in) &amp;&amp; (k &lt; RegMask::SlotsPerVecY); k++) {
 543       aligned_stack_mask.Remove(in);
 544       in = OptoReg::add(in, -1);
 545     }
 546      aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecY);
 547      assert(aligned_stack_mask.is_AllStack(), &quot;should be infinite stack&quot;);
 548     *idealreg2spillmask[Op_VecY] = *idealreg2regmask[Op_VecY];
 549      idealreg2spillmask[Op_VecY]-&gt;OR(aligned_stack_mask);
 550   }
 551   if (Matcher::vector_size_supported(T_FLOAT,16)) {
 552     // For VecZ we need enough alignment and 64 bytes (16 slots) for spills.
 553     OptoReg::Name in = OptoReg::add(_in_arg_limit, -1);
 554     for (int k = 1; (in &gt;= init_in) &amp;&amp; (k &lt; RegMask::SlotsPerVecZ); k++) {
 555       aligned_stack_mask.Remove(in);
 556       in = OptoReg::add(in, -1);
 557     }
 558      aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecZ);
 559      assert(aligned_stack_mask.is_AllStack(), &quot;should be infinite stack&quot;);
 560     *idealreg2spillmask[Op_VecZ] = *idealreg2regmask[Op_VecZ];
 561      idealreg2spillmask[Op_VecZ]-&gt;OR(aligned_stack_mask);
 562   }
 563    if (UseFPUForSpilling) {
 564      // This mask logic assumes that the spill operations are
 565      // symmetric and that the registers involved are the same size.
 566      // On sparc for instance we may have to use 64 bit moves will
 567      // kill 2 registers when used with F0-F31.
 568      idealreg2spillmask[Op_RegI]-&gt;OR(*idealreg2regmask[Op_RegF]);
 569      idealreg2spillmask[Op_RegF]-&gt;OR(*idealreg2regmask[Op_RegI]);
 570 #ifdef _LP64
 571      idealreg2spillmask[Op_RegN]-&gt;OR(*idealreg2regmask[Op_RegF]);
 572      idealreg2spillmask[Op_RegL]-&gt;OR(*idealreg2regmask[Op_RegD]);
 573      idealreg2spillmask[Op_RegD]-&gt;OR(*idealreg2regmask[Op_RegL]);
 574      idealreg2spillmask[Op_RegP]-&gt;OR(*idealreg2regmask[Op_RegD]);
 575 #else
 576      idealreg2spillmask[Op_RegP]-&gt;OR(*idealreg2regmask[Op_RegF]);
 577 #ifdef ARM
 578      // ARM has support for moving 64bit values between a pair of
 579      // integer registers and a double register
 580      idealreg2spillmask[Op_RegL]-&gt;OR(*idealreg2regmask[Op_RegD]);
 581      idealreg2spillmask[Op_RegD]-&gt;OR(*idealreg2regmask[Op_RegL]);
 582 #endif
 583 #endif
 584    }
 585 
 586   // Make up debug masks.  Any spill slot plus callee-save registers.
 587   // Caller-save registers are assumed to be trashable by the various
 588   // inline-cache fixup routines.
 589   *idealreg2debugmask  [Op_RegN]= *idealreg2spillmask[Op_RegN];
 590   *idealreg2debugmask  [Op_RegI]= *idealreg2spillmask[Op_RegI];
 591   *idealreg2debugmask  [Op_RegL]= *idealreg2spillmask[Op_RegL];
 592   *idealreg2debugmask  [Op_RegF]= *idealreg2spillmask[Op_RegF];
 593   *idealreg2debugmask  [Op_RegD]= *idealreg2spillmask[Op_RegD];
 594   *idealreg2debugmask  [Op_RegP]= *idealreg2spillmask[Op_RegP];
 595 
 596   *idealreg2mhdebugmask[Op_RegN]= *idealreg2spillmask[Op_RegN];
 597   *idealreg2mhdebugmask[Op_RegI]= *idealreg2spillmask[Op_RegI];
 598   *idealreg2mhdebugmask[Op_RegL]= *idealreg2spillmask[Op_RegL];
 599   *idealreg2mhdebugmask[Op_RegF]= *idealreg2spillmask[Op_RegF];
 600   *idealreg2mhdebugmask[Op_RegD]= *idealreg2spillmask[Op_RegD];
 601   *idealreg2mhdebugmask[Op_RegP]= *idealreg2spillmask[Op_RegP];
 602 
 603   // Prevent stub compilations from attempting to reference
 604   // callee-saved registers from debug info
 605   bool exclude_soe = !Compile::current()-&gt;is_method_compilation();
 606 
 607   for( i=OptoReg::Name(0); i&lt;OptoReg::Name(_last_Mach_Reg); i = OptoReg::add(i,1) ) {
 608     // registers the caller has to save do not work
 609     if( _register_save_policy[i] == &#39;C&#39; ||
 610         _register_save_policy[i] == &#39;A&#39; ||
 611         (_register_save_policy[i] == &#39;E&#39; &amp;&amp; exclude_soe) ) {
 612       idealreg2debugmask  [Op_RegN]-&gt;Remove(i);
 613       idealreg2debugmask  [Op_RegI]-&gt;Remove(i); // Exclude save-on-call
 614       idealreg2debugmask  [Op_RegL]-&gt;Remove(i); // registers from debug
 615       idealreg2debugmask  [Op_RegF]-&gt;Remove(i); // masks
 616       idealreg2debugmask  [Op_RegD]-&gt;Remove(i);
 617       idealreg2debugmask  [Op_RegP]-&gt;Remove(i);
 618 
 619       idealreg2mhdebugmask[Op_RegN]-&gt;Remove(i);
 620       idealreg2mhdebugmask[Op_RegI]-&gt;Remove(i);
 621       idealreg2mhdebugmask[Op_RegL]-&gt;Remove(i);
 622       idealreg2mhdebugmask[Op_RegF]-&gt;Remove(i);
 623       idealreg2mhdebugmask[Op_RegD]-&gt;Remove(i);
 624       idealreg2mhdebugmask[Op_RegP]-&gt;Remove(i);
 625     }
 626   }
 627 
 628   // Subtract the register we use to save the SP for MethodHandle
 629   // invokes to from the debug mask.
 630   const RegMask save_mask = method_handle_invoke_SP_save_mask();
 631   idealreg2mhdebugmask[Op_RegN]-&gt;SUBTRACT(save_mask);
 632   idealreg2mhdebugmask[Op_RegI]-&gt;SUBTRACT(save_mask);
 633   idealreg2mhdebugmask[Op_RegL]-&gt;SUBTRACT(save_mask);
 634   idealreg2mhdebugmask[Op_RegF]-&gt;SUBTRACT(save_mask);
 635   idealreg2mhdebugmask[Op_RegD]-&gt;SUBTRACT(save_mask);
 636   idealreg2mhdebugmask[Op_RegP]-&gt;SUBTRACT(save_mask);
 637 }
 638 
 639 //---------------------------is_save_on_entry----------------------------------
 640 bool Matcher::is_save_on_entry( int reg ) {
 641   return
 642     _register_save_policy[reg] == &#39;E&#39; ||
 643     _register_save_policy[reg] == &#39;A&#39; || // Save-on-entry register?
 644     // Also save argument registers in the trampolining stubs
 645     (C-&gt;save_argument_registers() &amp;&amp; is_spillable_arg(reg));
 646 }
 647 
 648 //---------------------------Fixup_Save_On_Entry-------------------------------
 649 void Matcher::Fixup_Save_On_Entry( ) {
 650   init_first_stack_mask();
 651 
 652   Node *root = C-&gt;root();       // Short name for root
 653   // Count number of save-on-entry registers.
 654   uint soe_cnt = number_of_saved_registers();
 655   uint i;
 656 
 657   // Find the procedure Start Node
 658   StartNode *start = C-&gt;start();
 659   assert( start, &quot;Expect a start node&quot; );
 660 
 661   // Save argument registers in the trampolining stubs
 662   if( C-&gt;save_argument_registers() )
 663     for( i = 0; i &lt; _last_Mach_Reg; i++ )
 664       if( is_spillable_arg(i) )
 665         soe_cnt++;
 666 
 667   // Input RegMask array shared by all Returns.
 668   // The type for doubles and longs has a count of 2, but
 669   // there is only 1 returned value
 670   uint ret_edge_cnt = TypeFunc::Parms + ((C-&gt;tf()-&gt;range()-&gt;cnt() == TypeFunc::Parms) ? 0 : 1);
 671   RegMask *ret_rms  = init_input_masks( ret_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 672   // Returns have 0 or 1 returned values depending on call signature.
 673   // Return register is specified by return_value in the AD file.
 674   if (ret_edge_cnt &gt; TypeFunc::Parms)
 675     ret_rms[TypeFunc::Parms+0] = _return_value_mask;
 676 
 677   // Input RegMask array shared by all Rethrows.
 678   uint reth_edge_cnt = TypeFunc::Parms+1;
 679   RegMask *reth_rms  = init_input_masks( reth_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 680   // Rethrow takes exception oop only, but in the argument 0 slot.
 681   OptoReg::Name reg = find_receiver(false);
 682   if (reg &gt;= 0) {
 683     reth_rms[TypeFunc::Parms] = mreg2regmask[reg];
 684 #ifdef _LP64
 685     // Need two slots for ptrs in 64-bit land
 686     reth_rms[TypeFunc::Parms].Insert(OptoReg::add(OptoReg::Name(reg), 1));
 687 #endif
 688   }
 689 
 690   // Input RegMask array shared by all TailCalls
 691   uint tail_call_edge_cnt = TypeFunc::Parms+2;
 692   RegMask *tail_call_rms = init_input_masks( tail_call_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 693 
 694   // Input RegMask array shared by all TailJumps
 695   uint tail_jump_edge_cnt = TypeFunc::Parms+2;
 696   RegMask *tail_jump_rms = init_input_masks( tail_jump_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 697 
 698   // TailCalls have 2 returned values (target &amp; moop), whose masks come
 699   // from the usual MachNode/MachOper mechanism.  Find a sample
 700   // TailCall to extract these masks and put the correct masks into
 701   // the tail_call_rms array.
 702   for( i=1; i &lt; root-&gt;req(); i++ ) {
 703     MachReturnNode *m = root-&gt;in(i)-&gt;as_MachReturn();
 704     if( m-&gt;ideal_Opcode() == Op_TailCall ) {
 705       tail_call_rms[TypeFunc::Parms+0] = m-&gt;MachNode::in_RegMask(TypeFunc::Parms+0);
 706       tail_call_rms[TypeFunc::Parms+1] = m-&gt;MachNode::in_RegMask(TypeFunc::Parms+1);
 707       break;
 708     }
 709   }
 710 
 711   // TailJumps have 2 returned values (target &amp; ex_oop), whose masks come
 712   // from the usual MachNode/MachOper mechanism.  Find a sample
 713   // TailJump to extract these masks and put the correct masks into
 714   // the tail_jump_rms array.
 715   for( i=1; i &lt; root-&gt;req(); i++ ) {
 716     MachReturnNode *m = root-&gt;in(i)-&gt;as_MachReturn();
 717     if( m-&gt;ideal_Opcode() == Op_TailJump ) {
 718       tail_jump_rms[TypeFunc::Parms+0] = m-&gt;MachNode::in_RegMask(TypeFunc::Parms+0);
 719       tail_jump_rms[TypeFunc::Parms+1] = m-&gt;MachNode::in_RegMask(TypeFunc::Parms+1);
 720       break;
 721     }
 722   }
 723 
 724   // Input RegMask array shared by all Halts
 725   uint halt_edge_cnt = TypeFunc::Parms;
 726   RegMask *halt_rms = init_input_masks( halt_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 727 
 728   // Capture the return input masks into each exit flavor
 729   for( i=1; i &lt; root-&gt;req(); i++ ) {
 730     MachReturnNode *exit = root-&gt;in(i)-&gt;as_MachReturn();
 731     switch( exit-&gt;ideal_Opcode() ) {
 732       case Op_Return   : exit-&gt;_in_rms = ret_rms;  break;
 733       case Op_Rethrow  : exit-&gt;_in_rms = reth_rms; break;
 734       case Op_TailCall : exit-&gt;_in_rms = tail_call_rms; break;
 735       case Op_TailJump : exit-&gt;_in_rms = tail_jump_rms; break;
 736       case Op_Halt     : exit-&gt;_in_rms = halt_rms; break;
 737       default          : ShouldNotReachHere();
 738     }
 739   }
 740 
 741   // Next unused projection number from Start.
 742   int proj_cnt = C-&gt;tf()-&gt;domain()-&gt;cnt();
 743 
 744   // Do all the save-on-entry registers.  Make projections from Start for
 745   // them, and give them a use at the exit points.  To the allocator, they
 746   // look like incoming register arguments.
 747   for( i = 0; i &lt; _last_Mach_Reg; i++ ) {
 748     if( is_save_on_entry(i) ) {
 749 
 750       // Add the save-on-entry to the mask array
 751       ret_rms      [      ret_edge_cnt] = mreg2regmask[i];
 752       reth_rms     [     reth_edge_cnt] = mreg2regmask[i];
 753       tail_call_rms[tail_call_edge_cnt] = mreg2regmask[i];
 754       tail_jump_rms[tail_jump_edge_cnt] = mreg2regmask[i];
 755       // Halts need the SOE registers, but only in the stack as debug info.
 756       // A just-prior uncommon-trap or deoptimization will use the SOE regs.
 757       halt_rms     [     halt_edge_cnt] = *idealreg2spillmask[_register_save_type[i]];
 758 
 759       Node *mproj;
 760 
 761       // Is this a RegF low half of a RegD?  Double up 2 adjacent RegF&#39;s
 762       // into a single RegD.
 763       if( (i&amp;1) == 0 &amp;&amp;
 764           _register_save_type[i  ] == Op_RegF &amp;&amp;
 765           _register_save_type[i+1] == Op_RegF &amp;&amp;
 766           is_save_on_entry(i+1) ) {
 767         // Add other bit for double
 768         ret_rms      [      ret_edge_cnt].Insert(OptoReg::Name(i+1));
 769         reth_rms     [     reth_edge_cnt].Insert(OptoReg::Name(i+1));
 770         tail_call_rms[tail_call_edge_cnt].Insert(OptoReg::Name(i+1));
 771         tail_jump_rms[tail_jump_edge_cnt].Insert(OptoReg::Name(i+1));
 772         halt_rms     [     halt_edge_cnt].Insert(OptoReg::Name(i+1));
 773         mproj = new MachProjNode( start, proj_cnt, ret_rms[ret_edge_cnt], Op_RegD );
 774         proj_cnt += 2;          // Skip 2 for doubles
 775       }
 776       else if( (i&amp;1) == 1 &amp;&amp;    // Else check for high half of double
 777                _register_save_type[i-1] == Op_RegF &amp;&amp;
 778                _register_save_type[i  ] == Op_RegF &amp;&amp;
 779                is_save_on_entry(i-1) ) {
 780         ret_rms      [      ret_edge_cnt] = RegMask::Empty;
 781         reth_rms     [     reth_edge_cnt] = RegMask::Empty;
 782         tail_call_rms[tail_call_edge_cnt] = RegMask::Empty;
 783         tail_jump_rms[tail_jump_edge_cnt] = RegMask::Empty;
 784         halt_rms     [     halt_edge_cnt] = RegMask::Empty;
 785         mproj = C-&gt;top();
 786       }
 787       // Is this a RegI low half of a RegL?  Double up 2 adjacent RegI&#39;s
 788       // into a single RegL.
 789       else if( (i&amp;1) == 0 &amp;&amp;
 790           _register_save_type[i  ] == Op_RegI &amp;&amp;
 791           _register_save_type[i+1] == Op_RegI &amp;&amp;
 792         is_save_on_entry(i+1) ) {
 793         // Add other bit for long
 794         ret_rms      [      ret_edge_cnt].Insert(OptoReg::Name(i+1));
 795         reth_rms     [     reth_edge_cnt].Insert(OptoReg::Name(i+1));
 796         tail_call_rms[tail_call_edge_cnt].Insert(OptoReg::Name(i+1));
 797         tail_jump_rms[tail_jump_edge_cnt].Insert(OptoReg::Name(i+1));
 798         halt_rms     [     halt_edge_cnt].Insert(OptoReg::Name(i+1));
 799         mproj = new MachProjNode( start, proj_cnt, ret_rms[ret_edge_cnt], Op_RegL );
 800         proj_cnt += 2;          // Skip 2 for longs
 801       }
 802       else if( (i&amp;1) == 1 &amp;&amp;    // Else check for high half of long
 803                _register_save_type[i-1] == Op_RegI &amp;&amp;
 804                _register_save_type[i  ] == Op_RegI &amp;&amp;
 805                is_save_on_entry(i-1) ) {
 806         ret_rms      [      ret_edge_cnt] = RegMask::Empty;
 807         reth_rms     [     reth_edge_cnt] = RegMask::Empty;
 808         tail_call_rms[tail_call_edge_cnt] = RegMask::Empty;
 809         tail_jump_rms[tail_jump_edge_cnt] = RegMask::Empty;
 810         halt_rms     [     halt_edge_cnt] = RegMask::Empty;
 811         mproj = C-&gt;top();
 812       } else {
 813         // Make a projection for it off the Start
 814         mproj = new MachProjNode( start, proj_cnt++, ret_rms[ret_edge_cnt], _register_save_type[i] );
 815       }
 816 
 817       ret_edge_cnt ++;
 818       reth_edge_cnt ++;
 819       tail_call_edge_cnt ++;
 820       tail_jump_edge_cnt ++;
 821       halt_edge_cnt ++;
 822 
 823       // Add a use of the SOE register to all exit paths
 824       for( uint j=1; j &lt; root-&gt;req(); j++ )
 825         root-&gt;in(j)-&gt;add_req(mproj);
 826     } // End of if a save-on-entry register
 827   } // End of for all machine registers
 828 }
 829 
 830 //------------------------------init_spill_mask--------------------------------
 831 void Matcher::init_spill_mask( Node *ret ) {
 832   if( idealreg2regmask[Op_RegI] ) return; // One time only init
 833 
 834   OptoReg::c_frame_pointer = c_frame_pointer();
 835   c_frame_ptr_mask = c_frame_pointer();
 836 #ifdef _LP64
 837   // pointers are twice as big
 838   c_frame_ptr_mask.Insert(OptoReg::add(c_frame_pointer(),1));
 839 #endif
 840 
 841   // Start at OptoReg::stack0()
 842   STACK_ONLY_mask.Clear();
 843   OptoReg::Name init = OptoReg::stack2reg(0);
 844   // STACK_ONLY_mask is all stack bits
 845   OptoReg::Name i;
 846   for (i = init; RegMask::can_represent(i); i = OptoReg::add(i,1))
 847     STACK_ONLY_mask.Insert(i);
 848   // Also set the &quot;infinite stack&quot; bit.
 849   STACK_ONLY_mask.set_AllStack();
 850 
 851   // Copy the register names over into the shared world
 852   for( i=OptoReg::Name(0); i&lt;OptoReg::Name(_last_Mach_Reg); i = OptoReg::add(i,1) ) {
 853     // SharedInfo::regName[i] = regName[i];
 854     // Handy RegMasks per machine register
 855     mreg2regmask[i].Insert(i);
 856   }
 857 
 858   // Grab the Frame Pointer
 859   Node *fp  = ret-&gt;in(TypeFunc::FramePtr);
 860   // Share frame pointer while making spill ops
 861   set_shared(fp);
 862 
 863 // Get the ADLC notion of the right regmask, for each basic type.
 864 #ifdef _LP64
 865   idealreg2regmask[Op_RegN] = regmask_for_ideal_register(Op_RegN, ret);
 866 #endif
 867   idealreg2regmask[Op_RegI] = regmask_for_ideal_register(Op_RegI, ret);
 868   idealreg2regmask[Op_RegP] = regmask_for_ideal_register(Op_RegP, ret);
 869   idealreg2regmask[Op_RegF] = regmask_for_ideal_register(Op_RegF, ret);
 870   idealreg2regmask[Op_RegD] = regmask_for_ideal_register(Op_RegD, ret);
 871   idealreg2regmask[Op_RegL] = regmask_for_ideal_register(Op_RegL, ret);
 872   idealreg2regmask[Op_VecS] = regmask_for_ideal_register(Op_VecS, ret);
 873   idealreg2regmask[Op_VecD] = regmask_for_ideal_register(Op_VecD, ret);
 874   idealreg2regmask[Op_VecX] = regmask_for_ideal_register(Op_VecX, ret);
 875   idealreg2regmask[Op_VecY] = regmask_for_ideal_register(Op_VecY, ret);
 876   idealreg2regmask[Op_VecZ] = regmask_for_ideal_register(Op_VecZ, ret);
 877 }
 878 
 879 #ifdef ASSERT
 880 static void match_alias_type(Compile* C, Node* n, Node* m) {
 881   if (!VerifyAliases)  return;  // do not go looking for trouble by default
 882   const TypePtr* nat = n-&gt;adr_type();
 883   const TypePtr* mat = m-&gt;adr_type();
 884   int nidx = C-&gt;get_alias_index(nat);
 885   int midx = C-&gt;get_alias_index(mat);
 886   // Detune the assert for cases like (AndI 0xFF (LoadB p)).
 887   if (nidx == Compile::AliasIdxTop &amp;&amp; midx &gt;= Compile::AliasIdxRaw) {
 888     for (uint i = 1; i &lt; n-&gt;req(); i++) {
 889       Node* n1 = n-&gt;in(i);
 890       const TypePtr* n1at = n1-&gt;adr_type();
 891       if (n1at != NULL) {
 892         nat = n1at;
 893         nidx = C-&gt;get_alias_index(n1at);
 894       }
 895     }
 896   }
 897   // %%% Kludgery.  Instead, fix ideal adr_type methods for all these cases:
 898   if (nidx == Compile::AliasIdxTop &amp;&amp; midx == Compile::AliasIdxRaw) {
 899     switch (n-&gt;Opcode()) {
 900     case Op_PrefetchAllocation:
 901       nidx = Compile::AliasIdxRaw;
 902       nat = TypeRawPtr::BOTTOM;
 903       break;
 904     }
 905   }
 906   if (nidx == Compile::AliasIdxRaw &amp;&amp; midx == Compile::AliasIdxTop) {
 907     switch (n-&gt;Opcode()) {
 908     case Op_ClearArray:
 909       midx = Compile::AliasIdxRaw;
 910       mat = TypeRawPtr::BOTTOM;
 911       break;
 912     }
 913   }
 914   if (nidx == Compile::AliasIdxTop &amp;&amp; midx == Compile::AliasIdxBot) {
 915     switch (n-&gt;Opcode()) {
 916     case Op_Return:
 917     case Op_Rethrow:
 918     case Op_Halt:
 919     case Op_TailCall:
 920     case Op_TailJump:
 921       nidx = Compile::AliasIdxBot;
 922       nat = TypePtr::BOTTOM;
 923       break;
 924     }
 925   }
 926   if (nidx == Compile::AliasIdxBot &amp;&amp; midx == Compile::AliasIdxTop) {
 927     switch (n-&gt;Opcode()) {
 928     case Op_StrComp:
 929     case Op_StrEquals:
 930     case Op_StrIndexOf:
 931     case Op_StrIndexOfChar:
 932     case Op_AryEq:
 933     case Op_HasNegatives:
 934     case Op_MemBarVolatile:
 935     case Op_MemBarCPUOrder: // %%% these ideals should have narrower adr_type?
 936     case Op_StrInflatedCopy:
 937     case Op_StrCompressedCopy:
 938     case Op_OnSpinWait:
 939     case Op_EncodeISOArray:
 940       nidx = Compile::AliasIdxTop;
 941       nat = NULL;
 942       break;
 943     }
 944   }
 945   if (nidx != midx) {
 946     if (PrintOpto || (PrintMiscellaneous &amp;&amp; (WizardMode || Verbose))) {
 947       tty-&gt;print_cr(&quot;==== Matcher alias shift %d =&gt; %d&quot;, nidx, midx);
 948       n-&gt;dump();
 949       m-&gt;dump();
 950     }
 951     assert(C-&gt;subsume_loads() &amp;&amp; C-&gt;must_alias(nat, midx),
 952            &quot;must not lose alias info when matching&quot;);
 953   }
 954 }
 955 #endif
 956 
 957 //------------------------------xform------------------------------------------
 958 // Given a Node in old-space, Match him (Label/Reduce) to produce a machine
 959 // Node in new-space.  Given a new-space Node, recursively walk his children.
 960 Node *Matcher::transform( Node *n ) { ShouldNotCallThis(); return n; }
 961 Node *Matcher::xform( Node *n, int max_stack ) {
 962   // Use one stack to keep both: child&#39;s node/state and parent&#39;s node/index
 963   MStack mstack(max_stack * 2 * 2); // usually: C-&gt;live_nodes() * 2 * 2
 964   mstack.push(n, Visit, NULL, -1);  // set NULL as parent to indicate root
 965   while (mstack.is_nonempty()) {
 966     C-&gt;check_node_count(NodeLimitFudgeFactor, &quot;too many nodes matching instructions&quot;);
 967     if (C-&gt;failing()) return NULL;
 968     n = mstack.node();          // Leave node on stack
 969     Node_State nstate = mstack.state();
 970     if (nstate == Visit) {
 971       mstack.set_state(Post_Visit);
 972       Node *oldn = n;
 973       // Old-space or new-space check
 974       if (!C-&gt;node_arena()-&gt;contains(n)) {
 975         // Old space!
 976         Node* m;
 977         if (has_new_node(n)) {  // Not yet Label/Reduced
 978           m = new_node(n);
 979         } else {
 980           if (!is_dontcare(n)) { // Matcher can match this guy
 981             // Calls match special.  They match alone with no children.
 982             // Their children, the incoming arguments, match normally.
 983             m = n-&gt;is_SafePoint() ? match_sfpt(n-&gt;as_SafePoint()):match_tree(n);
 984             if (C-&gt;failing())  return NULL;
 985             if (m == NULL) { Matcher::soft_match_failure(); return NULL; }
 986             if (n-&gt;is_MemBar()) {
 987               m-&gt;as_MachMemBar()-&gt;set_adr_type(n-&gt;adr_type());
 988             }
 989           } else {                  // Nothing the matcher cares about
 990             if (n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_Multi()) {       // Projections?
 991               // Convert to machine-dependent projection
 992               m = n-&gt;in(0)-&gt;as_Multi()-&gt;match( n-&gt;as_Proj(), this );
 993 #ifdef ASSERT
 994               _new2old_map.map(m-&gt;_idx, n);
 995 #endif
 996               if (m-&gt;in(0) != NULL) // m might be top
 997                 collect_null_checks(m, n);
 998             } else {                // Else just a regular &#39;ol guy
 999               m = n-&gt;clone();       // So just clone into new-space
1000 #ifdef ASSERT
1001               _new2old_map.map(m-&gt;_idx, n);
1002 #endif
1003               // Def-Use edges will be added incrementally as Uses
1004               // of this node are matched.
1005               assert(m-&gt;outcnt() == 0, &quot;no Uses of this clone yet&quot;);
1006             }
1007           }
1008 
1009           set_new_node(n, m);       // Map old to new
1010           if (_old_node_note_array != NULL) {
1011             Node_Notes* nn = C-&gt;locate_node_notes(_old_node_note_array,
1012                                                   n-&gt;_idx);
1013             C-&gt;set_node_notes_at(m-&gt;_idx, nn);
1014           }
1015           debug_only(match_alias_type(C, n, m));
1016         }
1017         n = m;    // n is now a new-space node
1018         mstack.set_node(n);
1019       }
1020 
1021       // New space!
1022       if (_visited.test_set(n-&gt;_idx)) continue; // while(mstack.is_nonempty())
1023 
1024       int i;
1025       // Put precedence edges on stack first (match them last).
1026       for (i = oldn-&gt;req(); (uint)i &lt; oldn-&gt;len(); i++) {
1027         Node *m = oldn-&gt;in(i);
1028         if (m == NULL) break;
1029         // set -1 to call add_prec() instead of set_req() during Step1
1030         mstack.push(m, Visit, n, -1);
1031       }
1032 
1033       // Handle precedence edges for interior nodes
1034       for (i = n-&gt;len()-1; (uint)i &gt;= n-&gt;req(); i--) {
1035         Node *m = n-&gt;in(i);
1036         if (m == NULL || C-&gt;node_arena()-&gt;contains(m)) continue;
1037         n-&gt;rm_prec(i);
1038         // set -1 to call add_prec() instead of set_req() during Step1
1039         mstack.push(m, Visit, n, -1);
1040       }
1041 
1042       // For constant debug info, I&#39;d rather have unmatched constants.
1043       int cnt = n-&gt;req();
1044       JVMState* jvms = n-&gt;jvms();
1045       int debug_cnt = jvms ? jvms-&gt;debug_start() : cnt;
1046 
1047       // Now do only debug info.  Clone constants rather than matching.
1048       // Constants are represented directly in the debug info without
1049       // the need for executable machine instructions.
1050       // Monitor boxes are also represented directly.
1051       for (i = cnt - 1; i &gt;= debug_cnt; --i) { // For all debug inputs do
1052         Node *m = n-&gt;in(i);          // Get input
1053         int op = m-&gt;Opcode();
1054         assert((op == Op_BoxLock) == jvms-&gt;is_monitor_use(i), &quot;boxes only at monitor sites&quot;);
1055         if( op == Op_ConI || op == Op_ConP || op == Op_ConN || op == Op_ConNKlass ||
1056             op == Op_ConF || op == Op_ConD || op == Op_ConL
1057             // || op == Op_BoxLock  // %%%% enable this and remove (+++) in chaitin.cpp
1058             ) {
1059           m = m-&gt;clone();
1060 #ifdef ASSERT
1061           _new2old_map.map(m-&gt;_idx, n);
1062 #endif
1063           mstack.push(m, Post_Visit, n, i); // Don&#39;t need to visit
1064           mstack.push(m-&gt;in(0), Visit, m, 0);
1065         } else {
1066           mstack.push(m, Visit, n, i);
1067         }
1068       }
1069 
1070       // And now walk his children, and convert his inputs to new-space.
1071       for( ; i &gt;= 0; --i ) { // For all normal inputs do
1072         Node *m = n-&gt;in(i);  // Get input
1073         if(m != NULL)
1074           mstack.push(m, Visit, n, i);
1075       }
1076 
1077     }
1078     else if (nstate == Post_Visit) {
1079       // Set xformed input
1080       Node *p = mstack.parent();
1081       if (p != NULL) { // root doesn&#39;t have parent
1082         int i = (int)mstack.index();
1083         if (i &gt;= 0)
1084           p-&gt;set_req(i, n); // required input
1085         else if (i == -1)
1086           p-&gt;add_prec(n);   // precedence input
1087         else
1088           ShouldNotReachHere();
1089       }
1090       mstack.pop(); // remove processed node from stack
1091     }
1092     else {
1093       ShouldNotReachHere();
1094     }
1095   } // while (mstack.is_nonempty())
1096   return n; // Return new-space Node
1097 }
1098 
1099 //------------------------------warp_outgoing_stk_arg------------------------
1100 OptoReg::Name Matcher::warp_outgoing_stk_arg( VMReg reg, OptoReg::Name begin_out_arg_area, OptoReg::Name &amp;out_arg_limit_per_call ) {
1101   // Convert outgoing argument location to a pre-biased stack offset
1102   if (reg-&gt;is_stack()) {
1103     OptoReg::Name warped = reg-&gt;reg2stack();
1104     // Adjust the stack slot offset to be the register number used
1105     // by the allocator.
1106     warped = OptoReg::add(begin_out_arg_area, warped);
1107     // Keep track of the largest numbered stack slot used for an arg.
1108     // Largest used slot per call-site indicates the amount of stack
1109     // that is killed by the call.
1110     if( warped &gt;= out_arg_limit_per_call )
1111       out_arg_limit_per_call = OptoReg::add(warped,1);
1112     if (!RegMask::can_represent_arg(warped)) {
1113       C-&gt;record_method_not_compilable(&quot;unsupported calling sequence&quot;);
1114       return OptoReg::Bad;
1115     }
1116     return warped;
1117   }
1118   return OptoReg::as_OptoReg(reg);
1119 }
1120 
1121 
1122 //------------------------------match_sfpt-------------------------------------
1123 // Helper function to match call instructions.  Calls match special.
1124 // They match alone with no children.  Their children, the incoming
1125 // arguments, match normally.
1126 MachNode *Matcher::match_sfpt( SafePointNode *sfpt ) {
1127   MachSafePointNode *msfpt = NULL;
1128   MachCallNode      *mcall = NULL;
1129   uint               cnt;
1130   // Split out case for SafePoint vs Call
1131   CallNode *call;
1132   const TypeTuple *domain;
1133   ciMethod*        method = NULL;
1134   bool             is_method_handle_invoke = false;  // for special kill effects
1135   if( sfpt-&gt;is_Call() ) {
1136     call = sfpt-&gt;as_Call();
1137     domain = call-&gt;tf()-&gt;domain();
1138     cnt = domain-&gt;cnt();
1139 
1140     // Match just the call, nothing else
1141     MachNode *m = match_tree(call);
1142     if (C-&gt;failing())  return NULL;
1143     if( m == NULL ) { Matcher::soft_match_failure(); return NULL; }
1144 
1145     // Copy data from the Ideal SafePoint to the machine version
1146     mcall = m-&gt;as_MachCall();
1147 
1148     mcall-&gt;set_tf(                  call-&gt;tf());
1149     mcall-&gt;set_entry_point(         call-&gt;entry_point());
1150     mcall-&gt;set_cnt(                 call-&gt;cnt());
1151     mcall-&gt;set_guaranteed_safepoint(call-&gt;guaranteed_safepoint());
1152 
1153     if( mcall-&gt;is_MachCallJava() ) {
1154       MachCallJavaNode *mcall_java  = mcall-&gt;as_MachCallJava();
1155       const CallJavaNode *call_java =  call-&gt;as_CallJava();
1156       assert(call_java-&gt;validate_symbolic_info(), &quot;inconsistent info&quot;);
1157       method = call_java-&gt;method();
1158       mcall_java-&gt;_method = method;
1159       mcall_java-&gt;_bci = call_java-&gt;_bci;
1160       mcall_java-&gt;_optimized_virtual = call_java-&gt;is_optimized_virtual();
1161       is_method_handle_invoke = call_java-&gt;is_method_handle_invoke();
1162       mcall_java-&gt;_method_handle_invoke = is_method_handle_invoke;
1163       mcall_java-&gt;_override_symbolic_info = call_java-&gt;override_symbolic_info();
1164       if (is_method_handle_invoke) {
1165         C-&gt;set_has_method_handle_invokes(true);
1166       }
1167       if( mcall_java-&gt;is_MachCallStaticJava() )
1168         mcall_java-&gt;as_MachCallStaticJava()-&gt;_name =
1169          call_java-&gt;as_CallStaticJava()-&gt;_name;
1170       if( mcall_java-&gt;is_MachCallDynamicJava() )
1171         mcall_java-&gt;as_MachCallDynamicJava()-&gt;_vtable_index =
1172          call_java-&gt;as_CallDynamicJava()-&gt;_vtable_index;
1173     }
1174     else if( mcall-&gt;is_MachCallRuntime() ) {
1175       mcall-&gt;as_MachCallRuntime()-&gt;_name = call-&gt;as_CallRuntime()-&gt;_name;
1176     }
1177     else if( mcall-&gt;is_MachCallNative() ) {
1178       MachCallNativeNode* mach_call_native = mcall-&gt;as_MachCallNative();
1179       CallNativeNode* call_native = call-&gt;as_CallNative();
1180       mach_call_native-&gt;_name = call_native-&gt;_name;
1181       mach_call_native-&gt;_arg_regs = call_native-&gt;_arg_regs;
1182       mach_call_native-&gt;_ret_regs = call_native-&gt;_ret_regs;
1183     }
1184     msfpt = mcall;
1185   }
1186   // This is a non-call safepoint
1187   else {
1188     call = NULL;
1189     domain = NULL;
1190     MachNode *mn = match_tree(sfpt);
1191     if (C-&gt;failing())  return NULL;
1192     msfpt = mn-&gt;as_MachSafePoint();
1193     cnt = TypeFunc::Parms;
1194   }
1195 
1196   // Advertise the correct memory effects (for anti-dependence computation).
1197   msfpt-&gt;set_adr_type(sfpt-&gt;adr_type());
1198 
1199   // Allocate a private array of RegMasks.  These RegMasks are not shared.
1200   msfpt-&gt;_in_rms = NEW_RESOURCE_ARRAY( RegMask, cnt );
1201   // Empty them all.
1202   for (uint i = 0; i &lt; cnt; i++) ::new (&amp;(msfpt-&gt;_in_rms[i])) RegMask();
1203 
1204   // Do all the pre-defined non-Empty register masks
1205   msfpt-&gt;_in_rms[TypeFunc::ReturnAdr] = _return_addr_mask;
1206   msfpt-&gt;_in_rms[TypeFunc::FramePtr ] = c_frame_ptr_mask;
1207 
1208   // Place first outgoing argument can possibly be put.
1209   OptoReg::Name begin_out_arg_area = OptoReg::add(_new_SP, C-&gt;out_preserve_stack_slots());
1210   assert( is_even(begin_out_arg_area), &quot;&quot; );
1211   // Compute max outgoing register number per call site.
1212   OptoReg::Name out_arg_limit_per_call = begin_out_arg_area;
1213   // Calls to C may hammer extra stack slots above and beyond any arguments.
1214   // These are usually backing store for register arguments for varargs.
1215   if( call != NULL &amp;&amp; call-&gt;is_CallRuntime() )
1216     out_arg_limit_per_call = OptoReg::add(out_arg_limit_per_call,C-&gt;varargs_C_out_slots_killed());
1217   if( call != NULL &amp;&amp; call-&gt;is_CallNative() )
1218     out_arg_limit_per_call = OptoReg::add(out_arg_limit_per_call, call-&gt;as_CallNative()-&gt;_shadow_space_bytes);
1219 
1220 
1221   // Do the normal argument list (parameters) register masks
1222   int argcnt = cnt - TypeFunc::Parms;
1223   if( argcnt &gt; 0 ) {          // Skip it all if we have no args
1224     BasicType *sig_bt  = NEW_RESOURCE_ARRAY( BasicType, argcnt );
1225     VMRegPair *parm_regs = NEW_RESOURCE_ARRAY( VMRegPair, argcnt );
1226     int i;
1227     for( i = 0; i &lt; argcnt; i++ ) {
1228       sig_bt[i] = domain-&gt;field_at(i+TypeFunc::Parms)-&gt;basic_type();
1229     }
1230     // V-call to pick proper calling convention
1231     call-&gt;calling_convention( sig_bt, parm_regs, argcnt );
1232 
1233 #ifdef ASSERT
1234     // Sanity check users&#39; calling convention.  Really handy during
1235     // the initial porting effort.  Fairly expensive otherwise.
1236     { for (int i = 0; i&lt;argcnt; i++) {
1237       if( !parm_regs[i].first()-&gt;is_valid() &amp;&amp;
1238           !parm_regs[i].second()-&gt;is_valid() ) continue;
1239       VMReg reg1 = parm_regs[i].first();
1240       VMReg reg2 = parm_regs[i].second();
1241       for (int j = 0; j &lt; i; j++) {
1242         if( !parm_regs[j].first()-&gt;is_valid() &amp;&amp;
1243             !parm_regs[j].second()-&gt;is_valid() ) continue;
1244         VMReg reg3 = parm_regs[j].first();
1245         VMReg reg4 = parm_regs[j].second();
1246         if( !reg1-&gt;is_valid() ) {
1247           assert( !reg2-&gt;is_valid(), &quot;valid halvsies&quot; );
1248         } else if( !reg3-&gt;is_valid() ) {
1249           assert( !reg4-&gt;is_valid(), &quot;valid halvsies&quot; );
1250         } else {
1251           assert( reg1 != reg2, &quot;calling conv. must produce distinct regs&quot;);
1252           assert( reg1 != reg3, &quot;calling conv. must produce distinct regs&quot;);
1253           assert( reg1 != reg4, &quot;calling conv. must produce distinct regs&quot;);
1254           assert( reg2 != reg3, &quot;calling conv. must produce distinct regs&quot;);
1255           assert( reg2 != reg4 || !reg2-&gt;is_valid(), &quot;calling conv. must produce distinct regs&quot;);
1256           assert( reg3 != reg4, &quot;calling conv. must produce distinct regs&quot;);
1257         }
1258       }
1259     }
1260     }
1261 #endif
1262 
1263     // Visit each argument.  Compute its outgoing register mask.
1264     // Return results now can have 2 bits returned.
1265     // Compute max over all outgoing arguments both per call-site
1266     // and over the entire method.
1267     for( i = 0; i &lt; argcnt; i++ ) {
1268       // Address of incoming argument mask to fill in
1269       RegMask *rm = &amp;mcall-&gt;_in_rms[i+TypeFunc::Parms];
1270       if( !parm_regs[i].first()-&gt;is_valid() &amp;&amp;
1271           !parm_regs[i].second()-&gt;is_valid() ) {
1272         continue;               // Avoid Halves
1273       }
1274       // Grab first register, adjust stack slots and insert in mask.
1275       OptoReg::Name reg1 = warp_outgoing_stk_arg(parm_regs[i].first(), begin_out_arg_area, out_arg_limit_per_call );
1276       if (OptoReg::is_valid(reg1))
1277         rm-&gt;Insert( reg1 );
1278       // Grab second register (if any), adjust stack slots and insert in mask.
1279       OptoReg::Name reg2 = warp_outgoing_stk_arg(parm_regs[i].second(), begin_out_arg_area, out_arg_limit_per_call );
1280       if (OptoReg::is_valid(reg2))
1281         rm-&gt;Insert( reg2 );
1282     } // End of for all arguments
1283 
1284     // Compute number of stack slots needed to restore stack in case of
1285     // Pascal-style argument popping.
1286     mcall-&gt;_argsize = out_arg_limit_per_call - begin_out_arg_area;
1287   }
1288 
1289   // Compute the max stack slot killed by any call.  These will not be
1290   // available for debug info, and will be used to adjust FIRST_STACK_mask
1291   // after all call sites have been visited.
1292   if( _out_arg_limit &lt; out_arg_limit_per_call)
1293     _out_arg_limit = out_arg_limit_per_call;
1294 
1295   if (mcall) {
1296     // Kill the outgoing argument area, including any non-argument holes and
1297     // any legacy C-killed slots.  Use Fat-Projections to do the killing.
1298     // Since the max-per-method covers the max-per-call-site and debug info
1299     // is excluded on the max-per-method basis, debug info cannot land in
1300     // this killed area.
1301     uint r_cnt = mcall-&gt;tf()-&gt;range()-&gt;cnt();
1302     MachProjNode *proj = new MachProjNode( mcall, r_cnt+10000, RegMask::Empty, MachProjNode::fat_proj );
1303     if (!RegMask::can_represent_arg(OptoReg::Name(out_arg_limit_per_call-1))) {
1304       C-&gt;record_method_not_compilable(&quot;unsupported outgoing calling sequence&quot;);
1305     } else {
1306       for (int i = begin_out_arg_area; i &lt; out_arg_limit_per_call; i++)
1307         proj-&gt;_rout.Insert(OptoReg::Name(i));
1308     }
1309     if (proj-&gt;_rout.is_NotEmpty()) {
1310       push_projection(proj);
1311     }
1312   }
1313   // Transfer the safepoint information from the call to the mcall
1314   // Move the JVMState list
1315   msfpt-&gt;set_jvms(sfpt-&gt;jvms());
1316   for (JVMState* jvms = msfpt-&gt;jvms(); jvms; jvms = jvms-&gt;caller()) {
1317     jvms-&gt;set_map(sfpt);
1318   }
1319 
1320   // Debug inputs begin just after the last incoming parameter
1321   assert((mcall == NULL) || (mcall-&gt;jvms() == NULL) ||
1322          (mcall-&gt;jvms()-&gt;debug_start() + mcall-&gt;_jvmadj == mcall-&gt;tf()-&gt;domain()-&gt;cnt()), &quot;&quot;);
1323 
1324   // Move the OopMap
1325   msfpt-&gt;_oop_map = sfpt-&gt;_oop_map;
1326 
1327   // Add additional edges.
1328   if (msfpt-&gt;mach_constant_base_node_input() != (uint)-1 &amp;&amp; !msfpt-&gt;is_MachCallLeaf()) {
1329     // For these calls we can not add MachConstantBase in expand(), as the
1330     // ins are not complete then.
1331     msfpt-&gt;ins_req(msfpt-&gt;mach_constant_base_node_input(), C-&gt;mach_constant_base_node());
1332     if (msfpt-&gt;jvms() &amp;&amp;
1333         msfpt-&gt;mach_constant_base_node_input() &lt;= msfpt-&gt;jvms()-&gt;debug_start() + msfpt-&gt;_jvmadj) {
1334       // We added an edge before jvms, so we must adapt the position of the ins.
1335       msfpt-&gt;jvms()-&gt;adapt_position(+1);
1336     }
1337   }
1338 
1339   // Registers killed by the call are set in the local scheduling pass
1340   // of Global Code Motion.
1341   return msfpt;
1342 }
1343 
1344 //---------------------------match_tree----------------------------------------
1345 // Match a Ideal Node DAG - turn it into a tree; Label &amp; Reduce.  Used as part
1346 // of the whole-sale conversion from Ideal to Mach Nodes.  Also used for
1347 // making GotoNodes while building the CFG and in init_spill_mask() to identify
1348 // a Load&#39;s result RegMask for memoization in idealreg2regmask[]
1349 MachNode *Matcher::match_tree( const Node *n ) {
1350   assert( n-&gt;Opcode() != Op_Phi, &quot;cannot match&quot; );
1351   assert( !n-&gt;is_block_start(), &quot;cannot match&quot; );
1352   // Set the mark for all locally allocated State objects.
1353   // When this call returns, the _states_arena arena will be reset
1354   // freeing all State objects.
1355   ResourceMark rm( &amp;_states_arena );
1356 
1357   LabelRootDepth = 0;
1358 
1359   // StoreNodes require their Memory input to match any LoadNodes
1360   Node *mem = n-&gt;is_Store() ? n-&gt;in(MemNode::Memory) : (Node*)1 ;
1361 #ifdef ASSERT
1362   Node* save_mem_node = _mem_node;
1363   _mem_node = n-&gt;is_Store() ? (Node*)n : NULL;
1364 #endif
1365   // State object for root node of match tree
1366   // Allocate it on _states_arena - stack allocation can cause stack overflow.
1367   State *s = new (&amp;_states_arena) State;
1368   s-&gt;_kids[0] = NULL;
1369   s-&gt;_kids[1] = NULL;
1370   s-&gt;_leaf = (Node*)n;
1371   // Label the input tree, allocating labels from top-level arena
1372   Node* root_mem = mem;
1373   Label_Root(n, s, n-&gt;in(0), root_mem);
1374   if (C-&gt;failing())  return NULL;
1375 
1376   // The minimum cost match for the whole tree is found at the root State
1377   uint mincost = max_juint;
1378   uint cost = max_juint;
1379   uint i;
1380   for( i = 0; i &lt; NUM_OPERANDS; i++ ) {
1381     if( s-&gt;valid(i) &amp;&amp;                // valid entry and
1382         s-&gt;_cost[i] &lt; cost &amp;&amp;         // low cost and
1383         s-&gt;_rule[i] &gt;= NUM_OPERANDS ) // not an operand
1384       cost = s-&gt;_cost[mincost=i];
1385   }
1386   if (mincost == max_juint) {
1387 #ifndef PRODUCT
1388     tty-&gt;print(&quot;No matching rule for:&quot;);
1389     s-&gt;dump();
1390 #endif
1391     Matcher::soft_match_failure();
1392     return NULL;
1393   }
1394   // Reduce input tree based upon the state labels to machine Nodes
1395   MachNode *m = ReduceInst( s, s-&gt;_rule[mincost], mem );
1396 #ifdef ASSERT
1397   _old2new_map.map(n-&gt;_idx, m);
1398   _new2old_map.map(m-&gt;_idx, (Node*)n);
1399 #endif
1400 
1401   // Add any Matcher-ignored edges
1402   uint cnt = n-&gt;req();
1403   uint start = 1;
1404   if( mem != (Node*)1 ) start = MemNode::Memory+1;
1405   if( n-&gt;is_AddP() ) {
1406     assert( mem == (Node*)1, &quot;&quot; );
1407     start = AddPNode::Base+1;
1408   }
1409   for( i = start; i &lt; cnt; i++ ) {
1410     if( !n-&gt;match_edge(i) ) {
1411       if( i &lt; m-&gt;req() )
1412         m-&gt;ins_req( i, n-&gt;in(i) );
1413       else
1414         m-&gt;add_req( n-&gt;in(i) );
1415     }
1416   }
1417 
1418   debug_only( _mem_node = save_mem_node; )
1419   return m;
1420 }
1421 
1422 
1423 //------------------------------match_into_reg---------------------------------
1424 // Choose to either match this Node in a register or part of the current
1425 // match tree.  Return true for requiring a register and false for matching
1426 // as part of the current match tree.
1427 static bool match_into_reg( const Node *n, Node *m, Node *control, int i, bool shared ) {
1428 
1429   const Type *t = m-&gt;bottom_type();
1430 
1431   if (t-&gt;singleton()) {
1432     // Never force constants into registers.  Allow them to match as
1433     // constants or registers.  Copies of the same value will share
1434     // the same register.  See find_shared_node.
1435     return false;
1436   } else {                      // Not a constant
1437     // Stop recursion if they have different Controls.
1438     Node* m_control = m-&gt;in(0);
1439     // Control of load&#39;s memory can post-dominates load&#39;s control.
1440     // So use it since load can&#39;t float above its memory.
1441     Node* mem_control = (m-&gt;is_Load()) ? m-&gt;in(MemNode::Memory)-&gt;in(0) : NULL;
1442     if (control &amp;&amp; m_control &amp;&amp; control != m_control &amp;&amp; control != mem_control) {
1443 
1444       // Actually, we can live with the most conservative control we
1445       // find, if it post-dominates the others.  This allows us to
1446       // pick up load/op/store trees where the load can float a little
1447       // above the store.
1448       Node *x = control;
1449       const uint max_scan = 6;  // Arbitrary scan cutoff
1450       uint j;
1451       for (j=0; j&lt;max_scan; j++) {
1452         if (x-&gt;is_Region())     // Bail out at merge points
1453           return true;
1454         x = x-&gt;in(0);
1455         if (x == m_control)     // Does &#39;control&#39; post-dominate
1456           break;                // m-&gt;in(0)?  If so, we can use it
1457         if (x == mem_control)   // Does &#39;control&#39; post-dominate
1458           break;                // mem_control?  If so, we can use it
1459       }
1460       if (j == max_scan)        // No post-domination before scan end?
1461         return true;            // Then break the match tree up
1462     }
1463     if ((m-&gt;is_DecodeN() &amp;&amp; Matcher::narrow_oop_use_complex_address()) ||
1464         (m-&gt;is_DecodeNKlass() &amp;&amp; Matcher::narrow_klass_use_complex_address())) {
1465       // These are commonly used in address expressions and can
1466       // efficiently fold into them on X64 in some cases.
1467       return false;
1468     }
1469   }
1470 
1471   // Not forceable cloning.  If shared, put it into a register.
1472   return shared;
1473 }
1474 
1475 
1476 //------------------------------Instruction Selection--------------------------
1477 // Label method walks a &quot;tree&quot; of nodes, using the ADLC generated DFA to match
1478 // ideal nodes to machine instructions.  Trees are delimited by shared Nodes,
1479 // things the Matcher does not match (e.g., Memory), and things with different
1480 // Controls (hence forced into different blocks).  We pass in the Control
1481 // selected for this entire State tree.
1482 
1483 // The Matcher works on Trees, but an Intel add-to-memory requires a DAG: the
1484 // Store and the Load must have identical Memories (as well as identical
1485 // pointers).  Since the Matcher does not have anything for Memory (and
1486 // does not handle DAGs), I have to match the Memory input myself.  If the
1487 // Tree root is a Store or if there are multiple Loads in the tree, I require
1488 // all Loads to have the identical memory.
1489 Node* Matcher::Label_Root(const Node* n, State* svec, Node* control, Node*&amp; mem) {
1490   // Since Label_Root is a recursive function, its possible that we might run
1491   // out of stack space.  See bugs 6272980 &amp; 6227033 for more info.
1492   LabelRootDepth++;
1493   if (LabelRootDepth &gt; MaxLabelRootDepth) {
1494     C-&gt;record_method_not_compilable(&quot;Out of stack space, increase MaxLabelRootDepth&quot;);
1495     return NULL;
1496   }
1497   uint care = 0;                // Edges matcher cares about
1498   uint cnt = n-&gt;req();
1499   uint i = 0;
1500 
1501   // Examine children for memory state
1502   // Can only subsume a child into your match-tree if that child&#39;s memory state
1503   // is not modified along the path to another input.
1504   // It is unsafe even if the other inputs are separate roots.
1505   Node *input_mem = NULL;
1506   for( i = 1; i &lt; cnt; i++ ) {
1507     if( !n-&gt;match_edge(i) ) continue;
1508     Node *m = n-&gt;in(i);         // Get ith input
1509     assert( m, &quot;expect non-null children&quot; );
1510     if( m-&gt;is_Load() ) {
1511       if( input_mem == NULL ) {
1512         input_mem = m-&gt;in(MemNode::Memory);
1513         if (mem == (Node*)1) {
1514           // Save this memory to bail out if there&#39;s another memory access
1515           // to a different memory location in the same tree.
1516           mem = input_mem;
1517         }
1518       } else if( input_mem != m-&gt;in(MemNode::Memory) ) {
1519         input_mem = NodeSentinel;
1520       }
1521     }
1522   }
1523 
1524   for( i = 1; i &lt; cnt; i++ ){// For my children
1525     if( !n-&gt;match_edge(i) ) continue;
1526     Node *m = n-&gt;in(i);         // Get ith input
1527     // Allocate states out of a private arena
1528     State *s = new (&amp;_states_arena) State;
1529     svec-&gt;_kids[care++] = s;
1530     assert( care &lt;= 2, &quot;binary only for now&quot; );
1531 
1532     // Recursively label the State tree.
1533     s-&gt;_kids[0] = NULL;
1534     s-&gt;_kids[1] = NULL;
1535     s-&gt;_leaf = m;
1536 
1537     // Check for leaves of the State Tree; things that cannot be a part of
1538     // the current tree.  If it finds any, that value is matched as a
1539     // register operand.  If not, then the normal matching is used.
1540     if( match_into_reg(n, m, control, i, is_shared(m)) ||
1541         // Stop recursion if this is a LoadNode and there is another memory access
1542         // to a different memory location in the same tree (for example, a StoreNode
1543         // at the root of this tree or another LoadNode in one of the children).
1544         ((mem!=(Node*)1) &amp;&amp; m-&gt;is_Load() &amp;&amp; m-&gt;in(MemNode::Memory) != mem) ||
1545         // Can NOT include the match of a subtree when its memory state
1546         // is used by any of the other subtrees
1547         (input_mem == NodeSentinel) ) {
1548       // Print when we exclude matching due to different memory states at input-loads
1549       if (PrintOpto &amp;&amp; (Verbose &amp;&amp; WizardMode) &amp;&amp; (input_mem == NodeSentinel)
1550           &amp;&amp; !((mem!=(Node*)1) &amp;&amp; m-&gt;is_Load() &amp;&amp; m-&gt;in(MemNode::Memory) != mem)) {
1551         tty-&gt;print_cr(&quot;invalid input_mem&quot;);
1552       }
1553       // Switch to a register-only opcode; this value must be in a register
1554       // and cannot be subsumed as part of a larger instruction.
1555       s-&gt;DFA( m-&gt;ideal_reg(), m );
1556 
1557     } else {
1558       // If match tree has no control and we do, adopt it for entire tree
1559       if( control == NULL &amp;&amp; m-&gt;in(0) != NULL &amp;&amp; m-&gt;req() &gt; 1 )
1560         control = m-&gt;in(0);         // Pick up control
1561       // Else match as a normal part of the match tree.
1562       control = Label_Root(m, s, control, mem);
1563       if (C-&gt;failing()) return NULL;
1564     }
1565   }
1566 
1567 
1568   // Call DFA to match this node, and return
1569   svec-&gt;DFA( n-&gt;Opcode(), n );
1570 
1571 #ifdef ASSERT
1572   uint x;
1573   for( x = 0; x &lt; _LAST_MACH_OPER; x++ )
1574     if( svec-&gt;valid(x) )
1575       break;
1576 
1577   if (x &gt;= _LAST_MACH_OPER) {
1578     n-&gt;dump();
1579     svec-&gt;dump();
1580     assert( false, &quot;bad AD file&quot; );
1581   }
1582 #endif
1583   return control;
1584 }
1585 
1586 
1587 // Con nodes reduced using the same rule can share their MachNode
1588 // which reduces the number of copies of a constant in the final
1589 // program.  The register allocator is free to split uses later to
1590 // split live ranges.
1591 MachNode* Matcher::find_shared_node(Node* leaf, uint rule) {
1592   if (!leaf-&gt;is_Con() &amp;&amp; !leaf-&gt;is_DecodeNarrowPtr()) return NULL;
1593 
1594   // See if this Con has already been reduced using this rule.
1595   if (_shared_nodes.Size() &lt;= leaf-&gt;_idx) return NULL;
1596   MachNode* last = (MachNode*)_shared_nodes.at(leaf-&gt;_idx);
1597   if (last != NULL &amp;&amp; rule == last-&gt;rule()) {
1598     // Don&#39;t expect control change for DecodeN
1599     if (leaf-&gt;is_DecodeNarrowPtr())
1600       return last;
1601     // Get the new space root.
1602     Node* xroot = new_node(C-&gt;root());
1603     if (xroot == NULL) {
1604       // This shouldn&#39;t happen give the order of matching.
1605       return NULL;
1606     }
1607 
1608     // Shared constants need to have their control be root so they
1609     // can be scheduled properly.
1610     Node* control = last-&gt;in(0);
1611     if (control != xroot) {
1612       if (control == NULL || control == C-&gt;root()) {
1613         last-&gt;set_req(0, xroot);
1614       } else {
1615         assert(false, &quot;unexpected control&quot;);
1616         return NULL;
1617       }
1618     }
1619     return last;
1620   }
1621   return NULL;
1622 }
1623 
1624 
1625 //------------------------------ReduceInst-------------------------------------
1626 // Reduce a State tree (with given Control) into a tree of MachNodes.
1627 // This routine (and it&#39;s cohort ReduceOper) convert Ideal Nodes into
1628 // complicated machine Nodes.  Each MachNode covers some tree of Ideal Nodes.
1629 // Each MachNode has a number of complicated MachOper operands; each
1630 // MachOper also covers a further tree of Ideal Nodes.
1631 
1632 // The root of the Ideal match tree is always an instruction, so we enter
1633 // the recursion here.  After building the MachNode, we need to recurse
1634 // the tree checking for these cases:
1635 // (1) Child is an instruction -
1636 //     Build the instruction (recursively), add it as an edge.
1637 //     Build a simple operand (register) to hold the result of the instruction.
1638 // (2) Child is an interior part of an instruction -
1639 //     Skip over it (do nothing)
1640 // (3) Child is the start of a operand -
1641 //     Build the operand, place it inside the instruction
1642 //     Call ReduceOper.
1643 MachNode *Matcher::ReduceInst( State *s, int rule, Node *&amp;mem ) {
1644   assert( rule &gt;= NUM_OPERANDS, &quot;called with operand rule&quot; );
1645 
1646   MachNode* shared_node = find_shared_node(s-&gt;_leaf, rule);
1647   if (shared_node != NULL) {
1648     return shared_node;
1649   }
1650 
1651   // Build the object to represent this state &amp; prepare for recursive calls
1652   MachNode *mach = s-&gt;MachNodeGenerator(rule);
1653   guarantee(mach != NULL, &quot;Missing MachNode&quot;);
1654   mach-&gt;_opnds[0] = s-&gt;MachOperGenerator(_reduceOp[rule]);
1655   assert( mach-&gt;_opnds[0] != NULL, &quot;Missing result operand&quot; );
1656   Node *leaf = s-&gt;_leaf;
1657   // Check for instruction or instruction chain rule
1658   if( rule &gt;= _END_INST_CHAIN_RULE || rule &lt; _BEGIN_INST_CHAIN_RULE ) {
1659     assert(C-&gt;node_arena()-&gt;contains(s-&gt;_leaf) || !has_new_node(s-&gt;_leaf),
1660            &quot;duplicating node that&#39;s already been matched&quot;);
1661     // Instruction
1662     mach-&gt;add_req( leaf-&gt;in(0) ); // Set initial control
1663     // Reduce interior of complex instruction
1664     ReduceInst_Interior( s, rule, mem, mach, 1 );
1665   } else {
1666     // Instruction chain rules are data-dependent on their inputs
1667     mach-&gt;add_req(0);             // Set initial control to none
1668     ReduceInst_Chain_Rule( s, rule, mem, mach );
1669   }
1670 
1671   // If a Memory was used, insert a Memory edge
1672   if( mem != (Node*)1 ) {
1673     mach-&gt;ins_req(MemNode::Memory,mem);
1674 #ifdef ASSERT
1675     // Verify adr type after matching memory operation
1676     const MachOper* oper = mach-&gt;memory_operand();
1677     if (oper != NULL &amp;&amp; oper != (MachOper*)-1) {
1678       // It has a unique memory operand.  Find corresponding ideal mem node.
1679       Node* m = NULL;
1680       if (leaf-&gt;is_Mem()) {
1681         m = leaf;
1682       } else {
1683         m = _mem_node;
1684         assert(m != NULL &amp;&amp; m-&gt;is_Mem(), &quot;expecting memory node&quot;);
1685       }
1686       const Type* mach_at = mach-&gt;adr_type();
1687       // DecodeN node consumed by an address may have different type
1688       // than its input. Don&#39;t compare types for such case.
1689       if (m-&gt;adr_type() != mach_at &amp;&amp;
1690           (m-&gt;in(MemNode::Address)-&gt;is_DecodeNarrowPtr() ||
1691            (m-&gt;in(MemNode::Address)-&gt;is_AddP() &amp;&amp;
1692             m-&gt;in(MemNode::Address)-&gt;in(AddPNode::Address)-&gt;is_DecodeNarrowPtr()) ||
1693            (m-&gt;in(MemNode::Address)-&gt;is_AddP() &amp;&amp;
1694             m-&gt;in(MemNode::Address)-&gt;in(AddPNode::Address)-&gt;is_AddP() &amp;&amp;
1695             m-&gt;in(MemNode::Address)-&gt;in(AddPNode::Address)-&gt;in(AddPNode::Address)-&gt;is_DecodeNarrowPtr()))) {
1696         mach_at = m-&gt;adr_type();
1697       }
1698       if (m-&gt;adr_type() != mach_at) {
1699         m-&gt;dump();
1700         tty-&gt;print_cr(&quot;mach:&quot;);
1701         mach-&gt;dump(1);
1702       }
1703       assert(m-&gt;adr_type() == mach_at, &quot;matcher should not change adr type&quot;);
1704     }
1705 #endif
1706   }
1707 
1708   // If the _leaf is an AddP, insert the base edge
1709   if (leaf-&gt;is_AddP()) {
1710     mach-&gt;ins_req(AddPNode::Base,leaf-&gt;in(AddPNode::Base));
1711   }
1712 
1713   uint number_of_projections_prior = number_of_projections();
1714 
1715   // Perform any 1-to-many expansions required
1716   MachNode *ex = mach-&gt;Expand(s, _projection_list, mem);
1717   if (ex != mach) {
1718     assert(ex-&gt;ideal_reg() == mach-&gt;ideal_reg(), &quot;ideal types should match&quot;);
1719     if( ex-&gt;in(1)-&gt;is_Con() )
1720       ex-&gt;in(1)-&gt;set_req(0, C-&gt;root());
1721     // Remove old node from the graph
1722     for( uint i=0; i&lt;mach-&gt;req(); i++ ) {
1723       mach-&gt;set_req(i,NULL);
1724     }
1725 #ifdef ASSERT
1726     _new2old_map.map(ex-&gt;_idx, s-&gt;_leaf);
1727 #endif
1728   }
1729 
1730   // PhaseChaitin::fixup_spills will sometimes generate spill code
1731   // via the matcher.  By the time, nodes have been wired into the CFG,
1732   // and any further nodes generated by expand rules will be left hanging
1733   // in space, and will not get emitted as output code.  Catch this.
1734   // Also, catch any new register allocation constraints (&quot;projections&quot;)
1735   // generated belatedly during spill code generation.
1736   if (_allocation_started) {
1737     guarantee(ex == mach, &quot;no expand rules during spill generation&quot;);
1738     guarantee(number_of_projections_prior == number_of_projections(), &quot;no allocation during spill generation&quot;);
1739   }
1740 
1741   if (leaf-&gt;is_Con() || leaf-&gt;is_DecodeNarrowPtr()) {
1742     // Record the con for sharing
1743     _shared_nodes.map(leaf-&gt;_idx, ex);
1744   }
1745 
1746   // Have mach nodes inherit GC barrier data
1747   if (leaf-&gt;is_LoadStore()) {
1748     mach-&gt;set_barrier_data(leaf-&gt;as_LoadStore()-&gt;barrier_data());
1749   } else if (leaf-&gt;is_Mem()) {
1750     mach-&gt;set_barrier_data(leaf-&gt;as_Mem()-&gt;barrier_data());
1751   }
1752 
1753   return ex;
1754 }
1755 
1756 void Matcher::handle_precedence_edges(Node* n, MachNode *mach) {
1757   for (uint i = n-&gt;req(); i &lt; n-&gt;len(); i++) {
1758     if (n-&gt;in(i) != NULL) {
1759       mach-&gt;add_prec(n-&gt;in(i));
1760     }
1761   }
1762 }
1763 
1764 void Matcher::ReduceInst_Chain_Rule( State *s, int rule, Node *&amp;mem, MachNode *mach ) {
1765   // &#39;op&#39; is what I am expecting to receive
1766   int op = _leftOp[rule];
1767   // Operand type to catch childs result
1768   // This is what my child will give me.
1769   int opnd_class_instance = s-&gt;_rule[op];
1770   // Choose between operand class or not.
1771   // This is what I will receive.
1772   int catch_op = (FIRST_OPERAND_CLASS &lt;= op &amp;&amp; op &lt; NUM_OPERANDS) ? opnd_class_instance : op;
1773   // New rule for child.  Chase operand classes to get the actual rule.
1774   int newrule = s-&gt;_rule[catch_op];
1775 
1776   if( newrule &lt; NUM_OPERANDS ) {
1777     // Chain from operand or operand class, may be output of shared node
1778     assert( 0 &lt;= opnd_class_instance &amp;&amp; opnd_class_instance &lt; NUM_OPERANDS,
1779             &quot;Bad AD file: Instruction chain rule must chain from operand&quot;);
1780     // Insert operand into array of operands for this instruction
1781     mach-&gt;_opnds[1] = s-&gt;MachOperGenerator(opnd_class_instance);
1782 
1783     ReduceOper( s, newrule, mem, mach );
1784   } else {
1785     // Chain from the result of an instruction
1786     assert( newrule &gt;= _LAST_MACH_OPER, &quot;Do NOT chain from internal operand&quot;);
1787     mach-&gt;_opnds[1] = s-&gt;MachOperGenerator(_reduceOp[catch_op]);
1788     Node *mem1 = (Node*)1;
1789     debug_only(Node *save_mem_node = _mem_node;)
1790     mach-&gt;add_req( ReduceInst(s, newrule, mem1) );
1791     debug_only(_mem_node = save_mem_node;)
1792   }
1793   return;
1794 }
1795 
1796 
1797 uint Matcher::ReduceInst_Interior( State *s, int rule, Node *&amp;mem, MachNode *mach, uint num_opnds ) {
1798   handle_precedence_edges(s-&gt;_leaf, mach);
1799 
1800   if( s-&gt;_leaf-&gt;is_Load() ) {
1801     Node *mem2 = s-&gt;_leaf-&gt;in(MemNode::Memory);
1802     assert( mem == (Node*)1 || mem == mem2, &quot;multiple Memories being matched at once?&quot; );
1803     debug_only( if( mem == (Node*)1 ) _mem_node = s-&gt;_leaf;)
1804     mem = mem2;
1805   }
1806   if( s-&gt;_leaf-&gt;in(0) != NULL &amp;&amp; s-&gt;_leaf-&gt;req() &gt; 1) {
1807     if( mach-&gt;in(0) == NULL )
1808       mach-&gt;set_req(0, s-&gt;_leaf-&gt;in(0));
1809   }
1810 
1811   // Now recursively walk the state tree &amp; add operand list.
1812   for( uint i=0; i&lt;2; i++ ) {   // binary tree
1813     State *newstate = s-&gt;_kids[i];
1814     if( newstate == NULL ) break;      // Might only have 1 child
1815     // &#39;op&#39; is what I am expecting to receive
1816     int op;
1817     if( i == 0 ) {
1818       op = _leftOp[rule];
1819     } else {
1820       op = _rightOp[rule];
1821     }
1822     // Operand type to catch childs result
1823     // This is what my child will give me.
1824     int opnd_class_instance = newstate-&gt;_rule[op];
1825     // Choose between operand class or not.
1826     // This is what I will receive.
1827     int catch_op = (op &gt;= FIRST_OPERAND_CLASS &amp;&amp; op &lt; NUM_OPERANDS) ? opnd_class_instance : op;
1828     // New rule for child.  Chase operand classes to get the actual rule.
1829     int newrule = newstate-&gt;_rule[catch_op];
1830 
1831     if( newrule &lt; NUM_OPERANDS ) { // Operand/operandClass or internalOp/instruction?
1832       // Operand/operandClass
1833       // Insert operand into array of operands for this instruction
1834       mach-&gt;_opnds[num_opnds++] = newstate-&gt;MachOperGenerator(opnd_class_instance);
1835       ReduceOper( newstate, newrule, mem, mach );
1836 
1837     } else {                    // Child is internal operand or new instruction
1838       if( newrule &lt; _LAST_MACH_OPER ) { // internal operand or instruction?
1839         // internal operand --&gt; call ReduceInst_Interior
1840         // Interior of complex instruction.  Do nothing but recurse.
1841         num_opnds = ReduceInst_Interior( newstate, newrule, mem, mach, num_opnds );
1842       } else {
1843         // instruction --&gt; call build operand(  ) to catch result
1844         //             --&gt; ReduceInst( newrule )
1845         mach-&gt;_opnds[num_opnds++] = s-&gt;MachOperGenerator(_reduceOp[catch_op]);
1846         Node *mem1 = (Node*)1;
1847         debug_only(Node *save_mem_node = _mem_node;)
1848         mach-&gt;add_req( ReduceInst( newstate, newrule, mem1 ) );
1849         debug_only(_mem_node = save_mem_node;)
1850       }
1851     }
1852     assert( mach-&gt;_opnds[num_opnds-1], &quot;&quot; );
1853   }
1854   return num_opnds;
1855 }
1856 
1857 // This routine walks the interior of possible complex operands.
1858 // At each point we check our children in the match tree:
1859 // (1) No children -
1860 //     We are a leaf; add _leaf field as an input to the MachNode
1861 // (2) Child is an internal operand -
1862 //     Skip over it ( do nothing )
1863 // (3) Child is an instruction -
1864 //     Call ReduceInst recursively and
1865 //     and instruction as an input to the MachNode
1866 void Matcher::ReduceOper( State *s, int rule, Node *&amp;mem, MachNode *mach ) {
1867   assert( rule &lt; _LAST_MACH_OPER, &quot;called with operand rule&quot; );
1868   State *kid = s-&gt;_kids[0];
1869   assert( kid == NULL || s-&gt;_leaf-&gt;in(0) == NULL, &quot;internal operands have no control&quot; );
1870 
1871   // Leaf?  And not subsumed?
1872   if( kid == NULL &amp;&amp; !_swallowed[rule] ) {
1873     mach-&gt;add_req( s-&gt;_leaf );  // Add leaf pointer
1874     return;                     // Bail out
1875   }
1876 
1877   if( s-&gt;_leaf-&gt;is_Load() ) {
1878     assert( mem == (Node*)1, &quot;multiple Memories being matched at once?&quot; );
1879     mem = s-&gt;_leaf-&gt;in(MemNode::Memory);
1880     debug_only(_mem_node = s-&gt;_leaf;)
1881   }
1882 
1883   handle_precedence_edges(s-&gt;_leaf, mach);
1884 
1885   if( s-&gt;_leaf-&gt;in(0) &amp;&amp; s-&gt;_leaf-&gt;req() &gt; 1) {
1886     if( !mach-&gt;in(0) )
1887       mach-&gt;set_req(0,s-&gt;_leaf-&gt;in(0));
1888     else {
1889       assert( s-&gt;_leaf-&gt;in(0) == mach-&gt;in(0), &quot;same instruction, differing controls?&quot; );
1890     }
1891   }
1892 
1893   for( uint i=0; kid != NULL &amp;&amp; i&lt;2; kid = s-&gt;_kids[1], i++ ) {   // binary tree
1894     int newrule;
1895     if( i == 0)
1896       newrule = kid-&gt;_rule[_leftOp[rule]];
1897     else
1898       newrule = kid-&gt;_rule[_rightOp[rule]];
1899 
1900     if( newrule &lt; _LAST_MACH_OPER ) { // Operand or instruction?
1901       // Internal operand; recurse but do nothing else
1902       ReduceOper( kid, newrule, mem, mach );
1903 
1904     } else {                    // Child is a new instruction
1905       // Reduce the instruction, and add a direct pointer from this
1906       // machine instruction to the newly reduced one.
1907       Node *mem1 = (Node*)1;
1908       debug_only(Node *save_mem_node = _mem_node;)
1909       mach-&gt;add_req( ReduceInst( kid, newrule, mem1 ) );
1910       debug_only(_mem_node = save_mem_node;)
1911     }
1912   }
1913 }
1914 
1915 
1916 // -------------------------------------------------------------------------
1917 // Java-Java calling convention
1918 // (what you use when Java calls Java)
1919 
1920 //------------------------------find_receiver----------------------------------
1921 // For a given signature, return the OptoReg for parameter 0.
1922 OptoReg::Name Matcher::find_receiver( bool is_outgoing ) {
1923   VMRegPair regs;
1924   BasicType sig_bt = T_OBJECT;
1925   calling_convention(&amp;sig_bt, &amp;regs, 1, is_outgoing);
1926   // Return argument 0 register.  In the LP64 build pointers
1927   // take 2 registers, but the VM wants only the &#39;main&#39; name.
1928   return OptoReg::as_OptoReg(regs.first());
1929 }
1930 
1931 bool Matcher::is_vshift_con_pattern(Node *n, Node *m) {
1932   if (n != NULL &amp;&amp; m != NULL) {
1933     return VectorNode::is_vector_shift(n) &amp;&amp;
1934            VectorNode::is_vector_shift_count(m) &amp;&amp; m-&gt;in(1)-&gt;is_Con();
1935   }
1936   return false;
1937 }
1938 
1939 
1940 bool Matcher::clone_node(Node* n, Node* m, Matcher::MStack&amp; mstack) {
1941   // Must clone all producers of flags, or we will not match correctly.
1942   // Suppose a compare setting int-flags is shared (e.g., a switch-tree)
1943   // then it will match into an ideal Op_RegFlags.  Alas, the fp-flags
1944   // are also there, so we may match a float-branch to int-flags and
1945   // expect the allocator to haul the flags from the int-side to the
1946   // fp-side.  No can do.
1947   if (_must_clone[m-&gt;Opcode()]) {
1948     mstack.push(m, Visit);
1949     return true;
1950   }
1951   return pd_clone_node(n, m, mstack);
1952 }
1953 
1954 bool Matcher::clone_base_plus_offset_address(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {
1955   Node *off = m-&gt;in(AddPNode::Offset);
1956   if (off-&gt;is_Con()) {
1957     address_visited.test_set(m-&gt;_idx); // Flag as address_visited
1958     mstack.push(m-&gt;in(AddPNode::Address), Pre_Visit);
1959     // Clone X+offset as it also folds into most addressing expressions
1960     mstack.push(off, Visit);
1961     mstack.push(m-&gt;in(AddPNode::Base), Pre_Visit);
1962     return true;
1963   }
1964   return false;
1965 }
1966 
1967 // A method-klass-holder may be passed in the inline_cache_reg
1968 // and then expanded into the inline_cache_reg and a method_ptr register
1969 //   defined in ad_&lt;arch&gt;.cpp
1970 
1971 //------------------------------find_shared------------------------------------
1972 // Set bits if Node is shared or otherwise a root
1973 void Matcher::find_shared(Node* n) {
1974   // Allocate stack of size C-&gt;live_nodes() * 2 to avoid frequent realloc
1975   MStack mstack(C-&gt;live_nodes() * 2);
1976   // Mark nodes as address_visited if they are inputs to an address expression
1977   VectorSet address_visited;
1978   mstack.push(n, Visit);     // Don&#39;t need to pre-visit root node
1979   while (mstack.is_nonempty()) {
1980     n = mstack.node();       // Leave node on stack
1981     Node_State nstate = mstack.state();
1982     uint nop = n-&gt;Opcode();
1983     if (nstate == Pre_Visit) {
1984       if (address_visited.test(n-&gt;_idx)) { // Visited in address already?
1985         // Flag as visited and shared now.
1986         set_visited(n);
1987       }
1988       if (is_visited(n)) {   // Visited already?
1989         // Node is shared and has no reason to clone.  Flag it as shared.
1990         // This causes it to match into a register for the sharing.
1991         set_shared(n);       // Flag as shared and
1992         if (n-&gt;is_DecodeNarrowPtr()) {
1993           // Oop field/array element loads must be shared but since
1994           // they are shared through a DecodeN they may appear to have
1995           // a single use so force sharing here.
1996           set_shared(n-&gt;in(1));
1997         }
1998         mstack.pop();        // remove node from stack
1999         continue;
2000       }
2001       nstate = Visit; // Not already visited; so visit now
2002     }
2003     if (nstate == Visit) {
2004       mstack.set_state(Post_Visit);
2005       set_visited(n);   // Flag as visited now
2006       bool mem_op = false;
2007       int mem_addr_idx = MemNode::Address;
2008       if (find_shared_visit(mstack, n, nop, mem_op, mem_addr_idx)) {
2009         continue;
2010       }
2011       for (int i = n-&gt;req() - 1; i &gt;= 0; --i) { // For my children
2012         Node* m = n-&gt;in(i); // Get ith input
2013         if (m == NULL) {
2014           continue;  // Ignore NULLs
2015         }
2016         if (clone_node(n, m, mstack)) {
2017           continue;
2018         }
2019 
2020         // Clone addressing expressions as they are &quot;free&quot; in memory access instructions
2021         if (mem_op &amp;&amp; i == mem_addr_idx &amp;&amp; m-&gt;is_AddP() &amp;&amp;
2022             // When there are other uses besides address expressions
2023             // put it on stack and mark as shared.
2024             !is_visited(m)) {
2025           // Some inputs for address expression are not put on stack
2026           // to avoid marking them as shared and forcing them into register
2027           // if they are used only in address expressions.
2028           // But they should be marked as shared if there are other uses
2029           // besides address expressions.
2030 
2031           if (pd_clone_address_expressions(m-&gt;as_AddP(), mstack, address_visited)) {
2032             continue;
2033           }
2034         }   // if( mem_op &amp;&amp;
2035         mstack.push(m, Pre_Visit);
2036       }     // for(int i = ...)
2037     }
2038     else if (nstate == Alt_Post_Visit) {
2039       mstack.pop(); // Remove node from stack
2040       // We cannot remove the Cmp input from the Bool here, as the Bool may be
2041       // shared and all users of the Bool need to move the Cmp in parallel.
2042       // This leaves both the Bool and the If pointing at the Cmp.  To
2043       // prevent the Matcher from trying to Match the Cmp along both paths
2044       // BoolNode::match_edge always returns a zero.
2045 
2046       // We reorder the Op_If in a pre-order manner, so we can visit without
2047       // accidentally sharing the Cmp (the Bool and the If make 2 users).
2048       n-&gt;add_req( n-&gt;in(1)-&gt;in(1) ); // Add the Cmp next to the Bool
2049     }
2050     else if (nstate == Post_Visit) {
2051       mstack.pop(); // Remove node from stack
2052 
2053       // Now hack a few special opcodes
2054       uint opcode = n-&gt;Opcode();
2055       bool gc_handled = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;matcher_find_shared_post_visit(this, n, opcode);
2056       if (!gc_handled) {
2057         find_shared_post_visit(n, opcode);
2058       }
2059     }
2060     else {
2061       ShouldNotReachHere();
2062     }
2063   } // end of while (mstack.is_nonempty())
2064 }
2065 
2066 bool Matcher::find_shared_visit(MStack&amp; mstack, Node* n, uint opcode, bool&amp; mem_op, int&amp; mem_addr_idx) {
2067   switch(opcode) {  // Handle some opcodes special
2068     case Op_Phi:             // Treat Phis as shared roots
2069     case Op_Parm:
2070     case Op_Proj:            // All handled specially during matching
2071     case Op_SafePointScalarObject:
2072       set_shared(n);
2073       set_dontcare(n);
2074       break;
2075     case Op_If:
2076     case Op_CountedLoopEnd:
2077       mstack.set_state(Alt_Post_Visit); // Alternative way
2078       // Convert (If (Bool (CmpX A B))) into (If (Bool) (CmpX A B)).  Helps
2079       // with matching cmp/branch in 1 instruction.  The Matcher needs the
2080       // Bool and CmpX side-by-side, because it can only get at constants
2081       // that are at the leaves of Match trees, and the Bool&#39;s condition acts
2082       // as a constant here.
2083       mstack.push(n-&gt;in(1), Visit);         // Clone the Bool
2084       mstack.push(n-&gt;in(0), Pre_Visit);     // Visit control input
2085       return true; // while (mstack.is_nonempty())
2086     case Op_ConvI2D:         // These forms efficiently match with a prior
2087     case Op_ConvI2F:         //   Load but not a following Store
2088       if( n-&gt;in(1)-&gt;is_Load() &amp;&amp;        // Prior load
2089           n-&gt;outcnt() == 1 &amp;&amp;           // Not already shared
2090           n-&gt;unique_out()-&gt;is_Store() ) // Following store
2091         set_shared(n);       // Force it to be a root
2092       break;
2093     case Op_ReverseBytesI:
2094     case Op_ReverseBytesL:
2095       if( n-&gt;in(1)-&gt;is_Load() &amp;&amp;        // Prior load
2096           n-&gt;outcnt() == 1 )            // Not already shared
2097         set_shared(n);                  // Force it to be a root
2098       break;
2099     case Op_BoxLock:         // Cant match until we get stack-regs in ADLC
2100     case Op_IfFalse:
2101     case Op_IfTrue:
2102     case Op_MachProj:
2103     case Op_MergeMem:
2104     case Op_Catch:
2105     case Op_CatchProj:
2106     case Op_CProj:
2107     case Op_JumpProj:
2108     case Op_JProj:
2109     case Op_NeverBranch:
2110       set_dontcare(n);
2111       break;
2112     case Op_Jump:
2113       mstack.push(n-&gt;in(1), Pre_Visit);     // Switch Value (could be shared)
2114       mstack.push(n-&gt;in(0), Pre_Visit);     // Visit Control input
2115       return true;                             // while (mstack.is_nonempty())
2116     case Op_StrComp:
2117     case Op_StrEquals:
2118     case Op_StrIndexOf:
2119     case Op_StrIndexOfChar:
2120     case Op_AryEq:
2121     case Op_HasNegatives:
2122     case Op_StrInflatedCopy:
2123     case Op_StrCompressedCopy:
2124     case Op_EncodeISOArray:
2125     case Op_FmaD:
2126     case Op_FmaF:
2127     case Op_FmaVD:
2128     case Op_FmaVF:
2129     case Op_MacroLogicV:
2130       set_shared(n); // Force result into register (it will be anyways)
2131       break;
2132     case Op_ConP: {  // Convert pointers above the centerline to NUL
2133       TypeNode *tn = n-&gt;as_Type(); // Constants derive from type nodes
2134       const TypePtr* tp = tn-&gt;type()-&gt;is_ptr();
2135       if (tp-&gt;_ptr == TypePtr::AnyNull) {
2136         tn-&gt;set_type(TypePtr::NULL_PTR);
2137       }
2138       break;
2139     }
2140     case Op_ConN: {  // Convert narrow pointers above the centerline to NUL
2141       TypeNode *tn = n-&gt;as_Type(); // Constants derive from type nodes
2142       const TypePtr* tp = tn-&gt;type()-&gt;make_ptr();
2143       if (tp &amp;&amp; tp-&gt;_ptr == TypePtr::AnyNull) {
2144         tn-&gt;set_type(TypeNarrowOop::NULL_PTR);
2145       }
2146       break;
2147     }
2148     case Op_Binary:         // These are introduced in the Post_Visit state.
2149       ShouldNotReachHere();
2150       break;
2151     case Op_ClearArray:
2152     case Op_SafePoint:
2153       mem_op = true;
2154       break;
2155     default:
2156       if( n-&gt;is_Store() ) {
2157         // Do match stores, despite no ideal reg
2158         mem_op = true;
2159         break;
2160       }
2161       if( n-&gt;is_Mem() ) { // Loads and LoadStores
2162         mem_op = true;
2163         // Loads must be root of match tree due to prior load conflict
2164         if( C-&gt;subsume_loads() == false )
2165           set_shared(n);
2166       }
2167       // Fall into default case
2168       if( !n-&gt;ideal_reg() )
2169         set_dontcare(n);  // Unmatchable Nodes
2170   } // end_switch
2171   return false;
2172 }
2173 
2174 void Matcher::find_shared_post_visit(Node* n, uint opcode) {
2175   switch(opcode) {       // Handle some opcodes special
2176     case Op_StorePConditional:
2177     case Op_StoreIConditional:
2178     case Op_StoreLConditional:
2179     case Op_CompareAndExchangeB:
2180     case Op_CompareAndExchangeS:
2181     case Op_CompareAndExchangeI:
2182     case Op_CompareAndExchangeL:
2183     case Op_CompareAndExchangeP:
2184     case Op_CompareAndExchangeN:
2185     case Op_WeakCompareAndSwapB:
2186     case Op_WeakCompareAndSwapS:
2187     case Op_WeakCompareAndSwapI:
2188     case Op_WeakCompareAndSwapL:
2189     case Op_WeakCompareAndSwapP:
2190     case Op_WeakCompareAndSwapN:
2191     case Op_CompareAndSwapB:
2192     case Op_CompareAndSwapS:
2193     case Op_CompareAndSwapI:
2194     case Op_CompareAndSwapL:
2195     case Op_CompareAndSwapP:
2196     case Op_CompareAndSwapN: {   // Convert trinary to binary-tree
2197       Node* newval = n-&gt;in(MemNode::ValueIn);
2198       Node* oldval = n-&gt;in(LoadStoreConditionalNode::ExpectedIn);
2199       Node* pair = new BinaryNode(oldval, newval);
2200       n-&gt;set_req(MemNode::ValueIn, pair);
2201       n-&gt;del_req(LoadStoreConditionalNode::ExpectedIn);
2202       break;
2203     }
2204     case Op_CMoveD:              // Convert trinary to binary-tree
2205     case Op_CMoveF:
2206     case Op_CMoveI:
2207     case Op_CMoveL:
2208     case Op_CMoveN:
2209     case Op_CMoveP:
2210     case Op_CMoveVF:
2211     case Op_CMoveVD:  {
2212       // Restructure into a binary tree for Matching.  It&#39;s possible that
2213       // we could move this code up next to the graph reshaping for IfNodes
2214       // or vice-versa, but I do not want to debug this for Ladybird.
2215       // 10/2/2000 CNC.
2216       Node* pair1 = new BinaryNode(n-&gt;in(1), n-&gt;in(1)-&gt;in(1));
2217       n-&gt;set_req(1, pair1);
2218       Node* pair2 = new BinaryNode(n-&gt;in(2), n-&gt;in(3));
2219       n-&gt;set_req(2, pair2);
2220       n-&gt;del_req(3);
2221       break;
2222     }
2223     case Op_MacroLogicV: {
2224       Node* pair1 = new BinaryNode(n-&gt;in(1), n-&gt;in(2));
2225       Node* pair2 = new BinaryNode(n-&gt;in(3), n-&gt;in(4));
2226       n-&gt;set_req(1, pair1);
2227       n-&gt;set_req(2, pair2);
2228       n-&gt;del_req(4);
2229       n-&gt;del_req(3);
2230       break;
2231     }
2232     case Op_LoopLimit: {
2233       Node* pair1 = new BinaryNode(n-&gt;in(1), n-&gt;in(2));
2234       n-&gt;set_req(1, pair1);
2235       n-&gt;set_req(2, n-&gt;in(3));
2236       n-&gt;del_req(3);
2237       break;
2238     }
2239     case Op_StrEquals:
2240     case Op_StrIndexOfChar: {
2241       Node* pair1 = new BinaryNode(n-&gt;in(2), n-&gt;in(3));
2242       n-&gt;set_req(2, pair1);
2243       n-&gt;set_req(3, n-&gt;in(4));
2244       n-&gt;del_req(4);
2245       break;
2246     }
2247     case Op_StrComp:
2248     case Op_StrIndexOf: {
2249       Node* pair1 = new BinaryNode(n-&gt;in(2), n-&gt;in(3));
2250       n-&gt;set_req(2, pair1);
2251       Node* pair2 = new BinaryNode(n-&gt;in(4),n-&gt;in(5));
2252       n-&gt;set_req(3, pair2);
2253       n-&gt;del_req(5);
2254       n-&gt;del_req(4);
2255       break;
2256     }
2257     case Op_StrCompressedCopy:
2258     case Op_StrInflatedCopy:
2259     case Op_EncodeISOArray: {
2260       // Restructure into a binary tree for Matching.
2261       Node* pair = new BinaryNode(n-&gt;in(3), n-&gt;in(4));
2262       n-&gt;set_req(3, pair);
2263       n-&gt;del_req(4);
2264       break;
2265     }
2266     case Op_FmaD:
2267     case Op_FmaF:
2268     case Op_FmaVD:
2269     case Op_FmaVF: {
2270       // Restructure into a binary tree for Matching.
2271       Node* pair = new BinaryNode(n-&gt;in(1), n-&gt;in(2));
2272       n-&gt;set_req(2, pair);
2273       n-&gt;set_req(1, n-&gt;in(3));
2274       n-&gt;del_req(3);
2275       break;
2276     }
2277     case Op_MulAddS2I: {
2278       Node* pair1 = new BinaryNode(n-&gt;in(1), n-&gt;in(2));
2279       Node* pair2 = new BinaryNode(n-&gt;in(3), n-&gt;in(4));
2280       n-&gt;set_req(1, pair1);
2281       n-&gt;set_req(2, pair2);
2282       n-&gt;del_req(4);
2283       n-&gt;del_req(3);
2284       break;
2285     }
2286     default:
2287       break;
2288   }
2289 }
2290 
2291 #ifdef ASSERT
2292 // machine-independent root to machine-dependent root
2293 void Matcher::dump_old2new_map() {
2294   _old2new_map.dump();
2295 }
2296 #endif
2297 
2298 //---------------------------collect_null_checks-------------------------------
2299 // Find null checks in the ideal graph; write a machine-specific node for
2300 // it.  Used by later implicit-null-check handling.  Actually collects
2301 // either an IfTrue or IfFalse for the common NOT-null path, AND the ideal
2302 // value being tested.
2303 void Matcher::collect_null_checks( Node *proj, Node *orig_proj ) {
2304   Node *iff = proj-&gt;in(0);
2305   if( iff-&gt;Opcode() == Op_If ) {
2306     // During matching If&#39;s have Bool &amp; Cmp side-by-side
2307     BoolNode *b = iff-&gt;in(1)-&gt;as_Bool();
2308     Node *cmp = iff-&gt;in(2);
2309     int opc = cmp-&gt;Opcode();
2310     if (opc != Op_CmpP &amp;&amp; opc != Op_CmpN) return;
2311 
2312     const Type* ct = cmp-&gt;in(2)-&gt;bottom_type();
2313     if (ct == TypePtr::NULL_PTR ||
2314         (opc == Op_CmpN &amp;&amp; ct == TypeNarrowOop::NULL_PTR)) {
2315 
2316       bool push_it = false;
2317       if( proj-&gt;Opcode() == Op_IfTrue ) {
2318 #ifndef PRODUCT
2319         extern int all_null_checks_found;
2320         all_null_checks_found++;
2321 #endif
2322         if( b-&gt;_test._test == BoolTest::ne ) {
2323           push_it = true;
2324         }
2325       } else {
2326         assert( proj-&gt;Opcode() == Op_IfFalse, &quot;&quot; );
2327         if( b-&gt;_test._test == BoolTest::eq ) {
2328           push_it = true;
2329         }
2330       }
2331       if( push_it ) {
2332         _null_check_tests.push(proj);
2333         Node* val = cmp-&gt;in(1);
2334 #ifdef _LP64
2335         if (val-&gt;bottom_type()-&gt;isa_narrowoop() &amp;&amp;
2336             !Matcher::narrow_oop_use_complex_address()) {
2337           //
2338           // Look for DecodeN node which should be pinned to orig_proj.
2339           // On platforms (Sparc) which can not handle 2 adds
2340           // in addressing mode we have to keep a DecodeN node and
2341           // use it to do implicit NULL check in address.
2342           //
2343           // DecodeN node was pinned to non-null path (orig_proj) during
2344           // CastPP transformation in final_graph_reshaping_impl().
2345           //
2346           uint cnt = orig_proj-&gt;outcnt();
2347           for (uint i = 0; i &lt; orig_proj-&gt;outcnt(); i++) {
2348             Node* d = orig_proj-&gt;raw_out(i);
2349             if (d-&gt;is_DecodeN() &amp;&amp; d-&gt;in(1) == val) {
2350               val = d;
2351               val-&gt;set_req(0, NULL); // Unpin now.
2352               // Mark this as special case to distinguish from
2353               // a regular case: CmpP(DecodeN, NULL).
2354               val = (Node*)(((intptr_t)val) | 1);
2355               break;
2356             }
2357           }
2358         }
2359 #endif
2360         _null_check_tests.push(val);
2361       }
2362     }
2363   }
2364 }
2365 
2366 //---------------------------validate_null_checks------------------------------
2367 // Its possible that the value being NULL checked is not the root of a match
2368 // tree.  If so, I cannot use the value in an implicit null check.
2369 void Matcher::validate_null_checks( ) {
2370   uint cnt = _null_check_tests.size();
2371   for( uint i=0; i &lt; cnt; i+=2 ) {
2372     Node *test = _null_check_tests[i];
2373     Node *val = _null_check_tests[i+1];
2374     bool is_decoden = ((intptr_t)val) &amp; 1;
2375     val = (Node*)(((intptr_t)val) &amp; ~1);
2376     if (has_new_node(val)) {
2377       Node* new_val = new_node(val);
2378       if (is_decoden) {
2379         assert(val-&gt;is_DecodeNarrowPtr() &amp;&amp; val-&gt;in(0) == NULL, &quot;sanity&quot;);
2380         // Note: new_val may have a control edge if
2381         // the original ideal node DecodeN was matched before
2382         // it was unpinned in Matcher::collect_null_checks().
2383         // Unpin the mach node and mark it.
2384         new_val-&gt;set_req(0, NULL);
2385         new_val = (Node*)(((intptr_t)new_val) | 1);
2386       }
2387       // Is a match-tree root, so replace with the matched value
2388       _null_check_tests.map(i+1, new_val);
2389     } else {
2390       // Yank from candidate list
2391       _null_check_tests.map(i+1,_null_check_tests[--cnt]);
2392       _null_check_tests.map(i,_null_check_tests[--cnt]);
2393       _null_check_tests.pop();
2394       _null_check_tests.pop();
2395       i-=2;
2396     }
2397   }
2398 }
2399 
2400 bool Matcher::gen_narrow_oop_implicit_null_checks() {
2401   // Advice matcher to perform null checks on the narrow oop side.
2402   // Implicit checks are not possible on the uncompressed oop side anyway
2403   // (at least not for read accesses).
2404   // Performs significantly better (especially on Power 6).
2405   if (!os::zero_page_read_protected()) {
2406     return true;
2407   }
2408   return CompressedOops::use_implicit_null_checks() &amp;&amp;
2409          (narrow_oop_use_complex_address() ||
2410           CompressedOops::base() != NULL);
2411 }
2412 
2413 // Compute RegMask for an ideal register.
2414 const RegMask* Matcher::regmask_for_ideal_register(uint ideal_reg, Node* ret) {
2415   const Type* t = Type::mreg2type[ideal_reg];
2416   if (t == NULL) {
2417     assert(ideal_reg &gt;= Op_VecS &amp;&amp; ideal_reg &lt;= Op_VecZ, &quot;not a vector: %d&quot;, ideal_reg);
2418     return NULL; // not supported
2419   }
2420   Node* fp  = ret-&gt;in(TypeFunc::FramePtr);
2421   Node* mem = ret-&gt;in(TypeFunc::Memory);
2422   const TypePtr* atp = TypePtr::BOTTOM;
2423   MemNode::MemOrd mo = MemNode::unordered;
2424 
2425   Node* spill;
2426   switch (ideal_reg) {
2427     case Op_RegN: spill = new LoadNNode(NULL, mem, fp, atp, t-&gt;is_narrowoop(), mo); break;
2428     case Op_RegI: spill = new LoadINode(NULL, mem, fp, atp, t-&gt;is_int(),       mo); break;
2429     case Op_RegP: spill = new LoadPNode(NULL, mem, fp, atp, t-&gt;is_ptr(),       mo); break;
2430     case Op_RegF: spill = new LoadFNode(NULL, mem, fp, atp, t,                 mo); break;
2431     case Op_RegD: spill = new LoadDNode(NULL, mem, fp, atp, t,                 mo); break;
2432     case Op_RegL: spill = new LoadLNode(NULL, mem, fp, atp, t-&gt;is_long(),      mo); break;
2433 
2434     case Op_VecS: // fall-through
2435     case Op_VecD: // fall-through
2436     case Op_VecX: // fall-through
2437     case Op_VecY: // fall-through
2438     case Op_VecZ: spill = new LoadVectorNode(NULL, mem, fp, atp, t-&gt;is_vect()); break;
2439 
2440     default: ShouldNotReachHere();
2441   }
2442   MachNode* mspill = match_tree(spill);
2443   assert(mspill != NULL, &quot;matching failed: %d&quot;, ideal_reg);
2444   // Handle generic vector operand case
2445   if (Matcher::supports_generic_vector_operands &amp;&amp; t-&gt;isa_vect()) {
2446     specialize_mach_node(mspill);
2447   }
2448   return &amp;mspill-&gt;out_RegMask();
2449 }
2450 
2451 // Process Mach IR right after selection phase is over.
2452 void Matcher::do_postselect_cleanup() {
2453   if (supports_generic_vector_operands) {
2454     specialize_generic_vector_operands();
2455     if (C-&gt;failing())  return;
2456   }
2457 }
2458 
2459 //----------------------------------------------------------------------
2460 // Generic machine operands elision.
2461 //----------------------------------------------------------------------
2462 
2463 // Compute concrete vector operand for a generic TEMP vector mach node based on its user info.
2464 void Matcher::specialize_temp_node(MachTempNode* tmp, MachNode* use, uint idx) {
2465   assert(use-&gt;in(idx) == tmp, &quot;not a user&quot;);
2466   assert(!Matcher::is_generic_vector(use-&gt;_opnds[0]), &quot;use not processed yet&quot;);
2467 
2468   if ((uint)idx == use-&gt;two_adr()) { // DEF_TEMP case
2469     tmp-&gt;_opnds[0] = use-&gt;_opnds[0]-&gt;clone();
2470   } else {
2471     uint ideal_vreg = vector_ideal_reg(C-&gt;max_vector_size());
2472     tmp-&gt;_opnds[0] = Matcher::pd_specialize_generic_vector_operand(tmp-&gt;_opnds[0], ideal_vreg, true /*is_temp*/);
2473   }
2474 }
2475 
2476 // Compute concrete vector operand for a generic DEF/USE vector operand (of mach node m at index idx).
2477 MachOper* Matcher::specialize_vector_operand(MachNode* m, uint opnd_idx) {
2478   assert(Matcher::is_generic_vector(m-&gt;_opnds[opnd_idx]), &quot;repeated updates&quot;);
2479   Node* def = NULL;
2480   if (opnd_idx == 0) { // DEF
2481     def = m; // use mach node itself to compute vector operand type
2482   } else {
2483     int base_idx = m-&gt;operand_index(opnd_idx);
2484     def = m-&gt;in(base_idx);
2485     if (def-&gt;is_Mach()) {
2486       if (def-&gt;is_MachTemp() &amp;&amp; Matcher::is_generic_vector(def-&gt;as_Mach()-&gt;_opnds[0])) {
2487         specialize_temp_node(def-&gt;as_MachTemp(), m, base_idx); // MachTemp node use site
2488       } else if (is_generic_reg2reg_move(def-&gt;as_Mach())) {
2489         def = def-&gt;in(1); // skip over generic reg-to-reg moves
2490       }
2491     }
2492   }
2493   assert(def-&gt;bottom_type()-&gt;isa_vect(), &quot;not a vector&quot;);
2494   uint ideal_vreg = def-&gt;bottom_type()-&gt;ideal_reg();
2495   return Matcher::pd_specialize_generic_vector_operand(m-&gt;_opnds[opnd_idx], ideal_vreg, false /*is_temp*/);
2496 }
2497 
2498 void Matcher::specialize_mach_node(MachNode* m) {
2499   assert(!m-&gt;is_MachTemp(), &quot;processed along with its user&quot;);
2500   // For generic use operands pull specific register class operands from
2501   // its def instruction&#39;s output operand (def operand).
2502   for (uint i = 0; i &lt; m-&gt;num_opnds(); i++) {
2503     if (Matcher::is_generic_vector(m-&gt;_opnds[i])) {
2504       m-&gt;_opnds[i] = specialize_vector_operand(m, i);
2505     }
2506   }
2507 }
2508 
2509 // Replace generic vector operands with concrete vector operands and eliminate generic reg-to-reg moves from the graph.
2510 void Matcher::specialize_generic_vector_operands() {
2511   assert(supports_generic_vector_operands, &quot;sanity&quot;);
2512   ResourceMark rm;
2513 
2514   if (C-&gt;max_vector_size() == 0) {
2515     return; // no vector instructions or operands
2516   }
2517   // Replace generic vector operands (vec/legVec) with concrete ones (vec[SDXYZ]/legVec[SDXYZ])
2518   // and remove reg-to-reg vector moves (MoveVec2Leg and MoveLeg2Vec).
2519   Unique_Node_List live_nodes;
2520   C-&gt;identify_useful_nodes(live_nodes);
2521 
2522   while (live_nodes.size() &gt; 0) {
2523     MachNode* m = live_nodes.pop()-&gt;isa_Mach();
2524     if (m != NULL) {
2525       if (Matcher::is_generic_reg2reg_move(m)) {
2526         // Register allocator properly handles vec &lt;=&gt; leg moves using register masks.
2527         int opnd_idx = m-&gt;operand_index(1);
2528         Node* def = m-&gt;in(opnd_idx);
2529         m-&gt;subsume_by(def, C);
2530       } else if (m-&gt;is_MachTemp()) {
2531         // process MachTemp nodes at use site (see Matcher::specialize_vector_operand)
2532       } else {
2533         specialize_mach_node(m);
2534       }
2535     }
2536   }
2537 }
2538 
2539 #ifdef ASSERT
2540 bool Matcher::verify_after_postselect_cleanup() {
2541   assert(!C-&gt;failing(), &quot;sanity&quot;);
2542   if (supports_generic_vector_operands) {
2543     Unique_Node_List useful;
2544     C-&gt;identify_useful_nodes(useful);
2545     for (uint i = 0; i &lt; useful.size(); i++) {
2546       MachNode* m = useful.at(i)-&gt;isa_Mach();
2547       if (m != NULL) {
2548         assert(!Matcher::is_generic_reg2reg_move(m), &quot;no MoveVec nodes allowed&quot;);
2549         for (uint j = 0; j &lt; m-&gt;num_opnds(); j++) {
2550           assert(!Matcher::is_generic_vector(m-&gt;_opnds[j]), &quot;no generic vector operands allowed&quot;);
2551         }
2552       }
2553     }
2554   }
2555   return true;
2556 }
2557 #endif // ASSERT
2558 
2559 // Used by the DFA in dfa_xxx.cpp.  Check for a following barrier or
2560 // atomic instruction acting as a store_load barrier without any
2561 // intervening volatile load, and thus we don&#39;t need a barrier here.
2562 // We retain the Node to act as a compiler ordering barrier.
2563 bool Matcher::post_store_load_barrier(const Node* vmb) {
2564   Compile* C = Compile::current();
2565   assert(vmb-&gt;is_MemBar(), &quot;&quot;);
2566   assert(vmb-&gt;Opcode() != Op_MemBarAcquire &amp;&amp; vmb-&gt;Opcode() != Op_LoadFence, &quot;&quot;);
2567   const MemBarNode* membar = vmb-&gt;as_MemBar();
2568 
2569   // Get the Ideal Proj node, ctrl, that can be used to iterate forward
2570   Node* ctrl = NULL;
2571   for (DUIterator_Fast imax, i = membar-&gt;fast_outs(imax); i &lt; imax; i++) {
2572     Node* p = membar-&gt;fast_out(i);
2573     assert(p-&gt;is_Proj(), &quot;only projections here&quot;);
2574     if ((p-&gt;as_Proj()-&gt;_con == TypeFunc::Control) &amp;&amp;
2575         !C-&gt;node_arena()-&gt;contains(p)) { // Unmatched old-space only
2576       ctrl = p;
2577       break;
2578     }
2579   }
2580   assert((ctrl != NULL), &quot;missing control projection&quot;);
2581 
2582   for (DUIterator_Fast jmax, j = ctrl-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2583     Node *x = ctrl-&gt;fast_out(j);
2584     int xop = x-&gt;Opcode();
2585 
2586     // We don&#39;t need current barrier if we see another or a lock
2587     // before seeing volatile load.
2588     //
2589     // Op_Fastunlock previously appeared in the Op_* list below.
2590     // With the advent of 1-0 lock operations we&#39;re no longer guaranteed
2591     // that a monitor exit operation contains a serializing instruction.
2592 
2593     if (xop == Op_MemBarVolatile ||
2594         xop == Op_CompareAndExchangeB ||
2595         xop == Op_CompareAndExchangeS ||
2596         xop == Op_CompareAndExchangeI ||
2597         xop == Op_CompareAndExchangeL ||
2598         xop == Op_CompareAndExchangeP ||
2599         xop == Op_CompareAndExchangeN ||
2600         xop == Op_WeakCompareAndSwapB ||
2601         xop == Op_WeakCompareAndSwapS ||
2602         xop == Op_WeakCompareAndSwapL ||
2603         xop == Op_WeakCompareAndSwapP ||
2604         xop == Op_WeakCompareAndSwapN ||
2605         xop == Op_WeakCompareAndSwapI ||
2606         xop == Op_CompareAndSwapB ||
2607         xop == Op_CompareAndSwapS ||
2608         xop == Op_CompareAndSwapL ||
2609         xop == Op_CompareAndSwapP ||
2610         xop == Op_CompareAndSwapN ||
2611         xop == Op_CompareAndSwapI ||
2612         BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;matcher_is_store_load_barrier(x, xop)) {
2613       return true;
2614     }
2615 
2616     // Op_FastLock previously appeared in the Op_* list above.
2617     // With biased locking we&#39;re no longer guaranteed that a monitor
2618     // enter operation contains a serializing instruction.
2619     if ((xop == Op_FastLock) &amp;&amp; !UseBiasedLocking) {
2620       return true;
2621     }
2622 
2623     if (x-&gt;is_MemBar()) {
2624       // We must retain this membar if there is an upcoming volatile
2625       // load, which will be followed by acquire membar.
2626       if (xop == Op_MemBarAcquire || xop == Op_LoadFence) {
2627         return false;
2628       } else {
2629         // For other kinds of barriers, check by pretending we
2630         // are them, and seeing if we can be removed.
2631         return post_store_load_barrier(x-&gt;as_MemBar());
2632       }
2633     }
2634 
2635     // probably not necessary to check for these
2636     if (x-&gt;is_Call() || x-&gt;is_SafePoint() || x-&gt;is_block_proj()) {
2637       return false;
2638     }
2639   }
2640   return false;
2641 }
2642 
2643 // Check whether node n is a branch to an uncommon trap that we could
2644 // optimize as test with very high branch costs in case of going to
2645 // the uncommon trap. The code must be able to be recompiled to use
2646 // a cheaper test.
2647 bool Matcher::branches_to_uncommon_trap(const Node *n) {
2648   // Don&#39;t do it for natives, adapters, or runtime stubs
2649   Compile *C = Compile::current();
2650   if (!C-&gt;is_method_compilation()) return false;
2651 
2652   assert(n-&gt;is_If(), &quot;You should only call this on if nodes.&quot;);
2653   IfNode *ifn = n-&gt;as_If();
2654 
2655   Node *ifFalse = NULL;
2656   for (DUIterator_Fast imax, i = ifn-&gt;fast_outs(imax); i &lt; imax; i++) {
2657     if (ifn-&gt;fast_out(i)-&gt;is_IfFalse()) {
2658       ifFalse = ifn-&gt;fast_out(i);
2659       break;
2660     }
2661   }
2662   assert(ifFalse, &quot;An If should have an ifFalse. Graph is broken.&quot;);
2663 
2664   Node *reg = ifFalse;
2665   int cnt = 4; // We must protect against cycles.  Limit to 4 iterations.
2666                // Alternatively use visited set?  Seems too expensive.
2667   while (reg != NULL &amp;&amp; cnt &gt; 0) {
2668     CallNode *call = NULL;
2669     RegionNode *nxt_reg = NULL;
2670     for (DUIterator_Fast imax, i = reg-&gt;fast_outs(imax); i &lt; imax; i++) {
2671       Node *o = reg-&gt;fast_out(i);
2672       if (o-&gt;is_Call()) {
2673         call = o-&gt;as_Call();
2674       }
2675       if (o-&gt;is_Region()) {
2676         nxt_reg = o-&gt;as_Region();
2677       }
2678     }
2679 
2680     if (call &amp;&amp;
2681         call-&gt;entry_point() == SharedRuntime::uncommon_trap_blob()-&gt;entry_point()) {
2682       const Type* trtype = call-&gt;in(TypeFunc::Parms)-&gt;bottom_type();
2683       if (trtype-&gt;isa_int() &amp;&amp; trtype-&gt;is_int()-&gt;is_con()) {
2684         jint tr_con = trtype-&gt;is_int()-&gt;get_con();
2685         Deoptimization::DeoptReason reason = Deoptimization::trap_request_reason(tr_con);
2686         Deoptimization::DeoptAction action = Deoptimization::trap_request_action(tr_con);
2687         assert((int)reason &lt; (int)BitsPerInt, &quot;recode bit map&quot;);
2688 
2689         if (is_set_nth_bit(C-&gt;allowed_deopt_reasons(), (int)reason)
2690             &amp;&amp; action != Deoptimization::Action_none) {
2691           // This uncommon trap is sure to recompile, eventually.
2692           // When that happens, C-&gt;too_many_traps will prevent
2693           // this transformation from happening again.
2694           return true;
2695         }
2696       }
2697     }
2698 
2699     reg = nxt_reg;
2700     cnt--;
2701   }
2702 
2703   return false;
2704 }
2705 
2706 //=============================================================================
2707 //---------------------------State---------------------------------------------
2708 State::State(void) {
2709 #ifdef ASSERT
2710   _id = 0;
2711   _kids[0] = _kids[1] = (State*)(intptr_t) CONST64(0xcafebabecafebabe);
2712   _leaf = (Node*)(intptr_t) CONST64(0xbaadf00dbaadf00d);
2713   //memset(_cost, -1, sizeof(_cost));
2714   //memset(_rule, -1, sizeof(_rule));
2715 #endif
2716   memset(_valid, 0, sizeof(_valid));
2717 }
2718 
2719 #ifdef ASSERT
2720 State::~State() {
2721   _id = 99;
2722   _kids[0] = _kids[1] = (State*)(intptr_t) CONST64(0xcafebabecafebabe);
2723   _leaf = (Node*)(intptr_t) CONST64(0xbaadf00dbaadf00d);
2724   memset(_cost, -3, sizeof(_cost));
2725   memset(_rule, -3, sizeof(_rule));
2726 }
2727 #endif
2728 
2729 #ifndef PRODUCT
2730 //---------------------------dump----------------------------------------------
2731 void State::dump() {
2732   tty-&gt;print(&quot;\n&quot;);
2733   dump(0);
2734 }
2735 
2736 void State::dump(int depth) {
2737   for( int j = 0; j &lt; depth; j++ )
2738     tty-&gt;print(&quot;   &quot;);
2739   tty-&gt;print(&quot;--N: &quot;);
2740   _leaf-&gt;dump();
2741   uint i;
2742   for( i = 0; i &lt; _LAST_MACH_OPER; i++ )
2743     // Check for valid entry
2744     if( valid(i) ) {
2745       for( int j = 0; j &lt; depth; j++ )
2746         tty-&gt;print(&quot;   &quot;);
2747         assert(_cost[i] != max_juint, &quot;cost must be a valid value&quot;);
2748         assert(_rule[i] &lt; _last_Mach_Node, &quot;rule[i] must be valid rule&quot;);
2749         tty-&gt;print_cr(&quot;%s  %d  %s&quot;,
2750                       ruleName[i], _cost[i], ruleName[_rule[i]] );
2751       }
2752   tty-&gt;cr();
2753 
2754   for( i=0; i&lt;2; i++ )
2755     if( _kids[i] )
2756       _kids[i]-&gt;dump(depth+1);
2757 }
2758 #endif
    </pre>
  </body>
</html>