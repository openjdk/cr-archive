<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/loopopts.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;opto/addnode.hpp&quot;
  31 #include &quot;opto/callnode.hpp&quot;
  32 #include &quot;opto/castnode.hpp&quot;
  33 #include &quot;opto/connode.hpp&quot;
  34 #include &quot;opto/castnode.hpp&quot;
  35 #include &quot;opto/divnode.hpp&quot;
  36 #include &quot;opto/loopnode.hpp&quot;
  37 #include &quot;opto/matcher.hpp&quot;
  38 #include &quot;opto/mulnode.hpp&quot;
  39 #include &quot;opto/movenode.hpp&quot;
  40 #include &quot;opto/opaquenode.hpp&quot;
  41 #include &quot;opto/rootnode.hpp&quot;
  42 #include &quot;opto/subnode.hpp&quot;
  43 #include &quot;opto/subtypenode.hpp&quot;
  44 #include &quot;utilities/macros.hpp&quot;
  45 
  46 //=============================================================================
  47 //------------------------------split_thru_phi---------------------------------
  48 // Split Node &#39;n&#39; through merge point if there is enough win.
  49 Node* PhaseIdealLoop::split_thru_phi(Node* n, Node* region, int policy) {
  50   if (n-&gt;Opcode() == Op_ConvI2L &amp;&amp; n-&gt;bottom_type() != TypeLong::LONG) {
  51     // ConvI2L may have type information on it which is unsafe to push up
  52     // so disable this for now
  53     return NULL;
  54   }
  55 
  56   // Splitting range check CastIIs through a loop induction Phi can
  57   // cause new Phis to be created that are left unrelated to the loop
  58   // induction Phi and prevent optimizations (vectorization)
  59   if (n-&gt;Opcode() == Op_CastII &amp;&amp; n-&gt;as_CastII()-&gt;has_range_check() &amp;&amp;
  60       region-&gt;is_CountedLoop() &amp;&amp; n-&gt;in(1) == region-&gt;as_CountedLoop()-&gt;phi()) {
  61     return NULL;
  62   }
  63 
  64   // Bail out if &#39;n&#39; is a Div or Mod node whose zero check was removed earlier (i.e. control is NULL) and its divisor is an induction variable
  65   // phi p of a trip-counted (integer) loop whose inputs could be zero (include zero in their type range). p could have a more precise type
  66   // range that does not necessarily include all values of its inputs. Since each of these inputs will be a divisor of the newly cloned nodes
  67   // of &#39;n&#39;, we need to bail out of one of these divisors could be zero (zero in its type range).
  68   if ((n-&gt;Opcode() == Op_DivI || n-&gt;Opcode() == Op_ModI) &amp;&amp; n-&gt;in(0) == NULL
  69       &amp;&amp; region-&gt;is_CountedLoop() &amp;&amp; n-&gt;in(2) == region-&gt;as_CountedLoop()-&gt;phi()) {
  70     Node* phi = region-&gt;as_CountedLoop()-&gt;phi();
  71     for (uint i = 1; i &lt; phi-&gt;req(); i++) {
  72       if (_igvn.type(phi-&gt;in(i))-&gt;filter_speculative(TypeInt::ZERO) != Type::TOP) {
  73         // Zero could be a possible value but we already removed the zero check. Bail out to avoid a possible division by zero at a later point.
  74         return NULL;
  75       }
  76     }
  77   }
  78 
  79   int wins = 0;
  80   assert(!n-&gt;is_CFG(), &quot;&quot;);
  81   assert(region-&gt;is_Region(), &quot;&quot;);
  82 
  83   const Type* type = n-&gt;bottom_type();
  84   const TypeOopPtr* t_oop = _igvn.type(n)-&gt;isa_oopptr();
  85   Node* phi;
  86   if (t_oop != NULL &amp;&amp; t_oop-&gt;is_known_instance_field()) {
  87     int iid    = t_oop-&gt;instance_id();
  88     int index  = C-&gt;get_alias_index(t_oop);
  89     int offset = t_oop-&gt;offset();
  90     phi = new PhiNode(region, type, NULL, iid, index, offset);
  91   } else {
  92     phi = PhiNode::make_blank(region, n);
  93   }
  94   uint old_unique = C-&gt;unique();
  95   for (uint i = 1; i &lt; region-&gt;req(); i++) {
  96     Node* x;
  97     Node* the_clone = NULL;
  98     if (region-&gt;in(i) == C-&gt;top()) {
  99       x = C-&gt;top();             // Dead path?  Use a dead data op
 100     } else {
 101       x = n-&gt;clone();           // Else clone up the data op
 102       the_clone = x;            // Remember for possible deletion.
 103       // Alter data node to use pre-phi inputs
 104       if (n-&gt;in(0) == region)
 105         x-&gt;set_req( 0, region-&gt;in(i) );
 106       for (uint j = 1; j &lt; n-&gt;req(); j++) {
 107         Node* in = n-&gt;in(j);
 108         if (in-&gt;is_Phi() &amp;&amp; in-&gt;in(0) == region)
 109           x-&gt;set_req(j, in-&gt;in(i)); // Use pre-Phi input for the clone
 110       }
 111     }
 112     // Check for a &#39;win&#39; on some paths
 113     const Type* t = x-&gt;Value(&amp;_igvn);
 114 
 115     bool singleton = t-&gt;singleton();
 116 
 117     // A TOP singleton indicates that there are no possible values incoming
 118     // along a particular edge. In most cases, this is OK, and the Phi will
 119     // be eliminated later in an Ideal call. However, we can&#39;t allow this to
 120     // happen if the singleton occurs on loop entry, as the elimination of
 121     // the PhiNode may cause the resulting node to migrate back to a previous
 122     // loop iteration.
 123     if (singleton &amp;&amp; t == Type::TOP) {
 124       // Is_Loop() == false does not confirm the absence of a loop (e.g., an
 125       // irreducible loop may not be indicated by an affirmative is_Loop());
 126       // therefore, the only top we can split thru a phi is on a backedge of
 127       // a loop.
 128       singleton &amp;= region-&gt;is_Loop() &amp;&amp; (i != LoopNode::EntryControl);
 129     }
 130 
 131     if (singleton) {
 132       wins++;
 133       x = ((PhaseGVN&amp;)_igvn).makecon(t);
 134     } else {
 135       // We now call Identity to try to simplify the cloned node.
 136       // Note that some Identity methods call phase-&gt;type(this).
 137       // Make sure that the type array is big enough for
 138       // our new node, even though we may throw the node away.
 139       // (Note: This tweaking with igvn only works because x is a new node.)
 140       _igvn.set_type(x, t);
 141       // If x is a TypeNode, capture any more-precise type permanently into Node
 142       // otherwise it will be not updated during igvn-&gt;transform since
 143       // igvn-&gt;type(x) is set to x-&gt;Value() already.
 144       x-&gt;raise_bottom_type(t);
 145       Node* y = x-&gt;Identity(&amp;_igvn);
 146       if (y != x) {
 147         wins++;
 148         x = y;
 149       } else {
 150         y = _igvn.hash_find(x);
 151         if (y) {
 152           wins++;
 153           x = y;
 154         } else {
 155           // Else x is a new node we are keeping
 156           // We do not need register_new_node_with_optimizer
 157           // because set_type has already been called.
 158           _igvn._worklist.push(x);
 159         }
 160       }
 161     }
 162     if (x != the_clone &amp;&amp; the_clone != NULL)
 163       _igvn.remove_dead_node(the_clone);
 164     phi-&gt;set_req( i, x );
 165   }
 166   // Too few wins?
 167   if (wins &lt;= policy) {
 168     _igvn.remove_dead_node(phi);
 169     return NULL;
 170   }
 171 
 172   // Record Phi
 173   register_new_node( phi, region );
 174 
 175   for (uint i2 = 1; i2 &lt; phi-&gt;req(); i2++) {
 176     Node *x = phi-&gt;in(i2);
 177     // If we commoned up the cloned &#39;x&#39; with another existing Node,
 178     // the existing Node picks up a new use.  We need to make the
 179     // existing Node occur higher up so it dominates its uses.
 180     Node *old_ctrl;
 181     IdealLoopTree *old_loop;
 182 
 183     if (x-&gt;is_Con()) {
 184       // Constant&#39;s control is always root.
 185       set_ctrl(x, C-&gt;root());
 186       continue;
 187     }
 188     // The occasional new node
 189     if (x-&gt;_idx &gt;= old_unique) {     // Found a new, unplaced node?
 190       old_ctrl = NULL;
 191       old_loop = NULL;               // Not in any prior loop
 192     } else {
 193       old_ctrl = get_ctrl(x);
 194       old_loop = get_loop(old_ctrl); // Get prior loop
 195     }
 196     // New late point must dominate new use
 197     Node *new_ctrl = dom_lca(old_ctrl, region-&gt;in(i2));
 198     if (new_ctrl == old_ctrl) // Nothing is changed
 199       continue;
 200 
 201     IdealLoopTree *new_loop = get_loop(new_ctrl);
 202 
 203     // Don&#39;t move x into a loop if its uses are
 204     // outside of loop. Otherwise x will be cloned
 205     // for each use outside of this loop.
 206     IdealLoopTree *use_loop = get_loop(region);
 207     if (!new_loop-&gt;is_member(use_loop) &amp;&amp;
 208         (old_loop == NULL || !new_loop-&gt;is_member(old_loop))) {
 209       // Take early control, later control will be recalculated
 210       // during next iteration of loop optimizations.
 211       new_ctrl = get_early_ctrl(x);
 212       new_loop = get_loop(new_ctrl);
 213     }
 214     // Set new location
 215     set_ctrl(x, new_ctrl);
 216     // If changing loop bodies, see if we need to collect into new body
 217     if (old_loop != new_loop) {
 218       if (old_loop &amp;&amp; !old_loop-&gt;_child)
 219         old_loop-&gt;_body.yank(x);
 220       if (!new_loop-&gt;_child)
 221         new_loop-&gt;_body.push(x);  // Collect body info
 222     }
 223   }
 224 
 225   return phi;
 226 }
 227 
 228 //------------------------------dominated_by------------------------------------
 229 // Replace the dominated test with an obvious true or false.  Place it on the
 230 // IGVN worklist for later cleanup.  Move control-dependent data Nodes on the
 231 // live path up to the dominating control.
 232 void PhaseIdealLoop::dominated_by( Node *prevdom, Node *iff, bool flip, bool exclude_loop_predicate ) {
 233   if (VerifyLoopOptimizations &amp;&amp; PrintOpto) { tty-&gt;print_cr(&quot;dominating test&quot;); }
 234 
 235   // prevdom is the dominating projection of the dominating test.
 236   assert( iff-&gt;is_If(), &quot;&quot; );
 237   assert(iff-&gt;Opcode() == Op_If || iff-&gt;Opcode() == Op_CountedLoopEnd || iff-&gt;Opcode() == Op_RangeCheck, &quot;Check this code when new subtype is added&quot;);
 238   int pop = prevdom-&gt;Opcode();
 239   assert( pop == Op_IfFalse || pop == Op_IfTrue, &quot;&quot; );
 240   if (flip) {
 241     if (pop == Op_IfTrue)
 242       pop = Op_IfFalse;
 243     else
 244       pop = Op_IfTrue;
 245   }
 246   // &#39;con&#39; is set to true or false to kill the dominated test.
 247   Node *con = _igvn.makecon(pop == Op_IfTrue ? TypeInt::ONE : TypeInt::ZERO);
 248   set_ctrl(con, C-&gt;root()); // Constant gets a new use
 249   // Hack the dominated test
 250   _igvn.replace_input_of(iff, 1, con);
 251 
 252   // If I dont have a reachable TRUE and FALSE path following the IfNode then
 253   // I can assume this path reaches an infinite loop.  In this case it&#39;s not
 254   // important to optimize the data Nodes - either the whole compilation will
 255   // be tossed or this path (and all data Nodes) will go dead.
 256   if (iff-&gt;outcnt() != 2) return;
 257 
 258   // Make control-dependent data Nodes on the live path (path that will remain
 259   // once the dominated IF is removed) become control-dependent on the
 260   // dominating projection.
 261   Node* dp = iff-&gt;as_If()-&gt;proj_out_or_null(pop == Op_IfTrue);
 262 
 263   // Loop predicates may have depending checks which should not
 264   // be skipped. For example, range check predicate has two checks
 265   // for lower and upper bounds.
 266   if (dp == NULL)
 267     return;
 268 
 269   ProjNode* dp_proj  = dp-&gt;as_Proj();
 270   ProjNode* unc_proj = iff-&gt;as_If()-&gt;proj_out(1 - dp_proj-&gt;_con)-&gt;as_Proj();
 271   if (exclude_loop_predicate &amp;&amp;
 272       (unc_proj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_predicate) != NULL ||
 273        unc_proj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != NULL ||
 274        unc_proj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_range_check) != NULL)) {
 275     // If this is a range check (IfNode::is_range_check), do not
 276     // reorder because Compile::allow_range_check_smearing might have
 277     // changed the check.
 278     return; // Let IGVN transformation change control dependence.
 279   }
 280 
 281   IdealLoopTree *old_loop = get_loop(dp);
 282 
 283   for (DUIterator_Fast imax, i = dp-&gt;fast_outs(imax); i &lt; imax; i++) {
 284     Node* cd = dp-&gt;fast_out(i); // Control-dependent node
 285     if (cd-&gt;depends_only_on_test()) {
 286       assert(cd-&gt;in(0) == dp, &quot;&quot;);
 287       _igvn.replace_input_of(cd, 0, prevdom);
 288       set_early_ctrl(cd);
 289       IdealLoopTree *new_loop = get_loop(get_ctrl(cd));
 290       if (old_loop != new_loop) {
 291         if (!old_loop-&gt;_child) old_loop-&gt;_body.yank(cd);
 292         if (!new_loop-&gt;_child) new_loop-&gt;_body.push(cd);
 293       }
 294       --i;
 295       --imax;
 296     }
 297   }
 298 }
 299 
 300 //------------------------------has_local_phi_input----------------------------
 301 // Return TRUE if &#39;n&#39; has Phi inputs from its local block and no other
 302 // block-local inputs (all non-local-phi inputs come from earlier blocks)
 303 Node *PhaseIdealLoop::has_local_phi_input( Node *n ) {
 304   Node *n_ctrl = get_ctrl(n);
 305   // See if some inputs come from a Phi in this block, or from before
 306   // this block.
 307   uint i;
 308   for( i = 1; i &lt; n-&gt;req(); i++ ) {
 309     Node *phi = n-&gt;in(i);
 310     if( phi-&gt;is_Phi() &amp;&amp; phi-&gt;in(0) == n_ctrl )
 311       break;
 312   }
 313   if( i &gt;= n-&gt;req() )
 314     return NULL;                // No Phi inputs; nowhere to clone thru
 315 
 316   // Check for inputs created between &#39;n&#39; and the Phi input.  These
 317   // must split as well; they have already been given the chance
 318   // (courtesy of a post-order visit) and since they did not we must
 319   // recover the &#39;cost&#39; of splitting them by being very profitable
 320   // when splitting &#39;n&#39;.  Since this is unlikely we simply give up.
 321   for( i = 1; i &lt; n-&gt;req(); i++ ) {
 322     Node *m = n-&gt;in(i);
 323     if( get_ctrl(m) == n_ctrl &amp;&amp; !m-&gt;is_Phi() ) {
 324       // We allow the special case of AddP&#39;s with no local inputs.
 325       // This allows us to split-up address expressions.
 326       if (m-&gt;is_AddP() &amp;&amp;
 327           get_ctrl(m-&gt;in(2)) != n_ctrl &amp;&amp;
 328           get_ctrl(m-&gt;in(3)) != n_ctrl) {
 329         // Move the AddP up to dominating point
 330         Node* c = find_non_split_ctrl(idom(n_ctrl));
 331         if (c-&gt;is_OuterStripMinedLoop()) {
 332           c-&gt;as_Loop()-&gt;verify_strip_mined(1);
 333           c = c-&gt;in(LoopNode::EntryControl);
 334         }
 335         set_ctrl_and_loop(m, c);
 336         continue;
 337       }
 338       return NULL;
 339     }
 340     assert(n-&gt;is_Phi() || m-&gt;is_Phi() || is_dominator(get_ctrl(m), n_ctrl), &quot;m has strange control&quot;);
 341   }
 342 
 343   return n_ctrl;
 344 }
 345 
 346 //------------------------------remix_address_expressions----------------------
 347 // Rework addressing expressions to get the most loop-invariant stuff
 348 // moved out.  We&#39;d like to do all associative operators, but it&#39;s especially
 349 // important (common) to do address expressions.
 350 Node *PhaseIdealLoop::remix_address_expressions( Node *n ) {
 351   if (!has_ctrl(n))  return NULL;
 352   Node *n_ctrl = get_ctrl(n);
 353   IdealLoopTree *n_loop = get_loop(n_ctrl);
 354 
 355   // See if &#39;n&#39; mixes loop-varying and loop-invariant inputs and
 356   // itself is loop-varying.
 357 
 358   // Only interested in binary ops (and AddP)
 359   if( n-&gt;req() &lt; 3 || n-&gt;req() &gt; 4 ) return NULL;
 360 
 361   Node *n1_ctrl = get_ctrl(n-&gt;in(                    1));
 362   Node *n2_ctrl = get_ctrl(n-&gt;in(                    2));
 363   Node *n3_ctrl = get_ctrl(n-&gt;in(n-&gt;req() == 3 ? 2 : 3));
 364   IdealLoopTree *n1_loop = get_loop( n1_ctrl );
 365   IdealLoopTree *n2_loop = get_loop( n2_ctrl );
 366   IdealLoopTree *n3_loop = get_loop( n3_ctrl );
 367 
 368   // Does one of my inputs spin in a tighter loop than self?
 369   if( (n_loop-&gt;is_member( n1_loop ) &amp;&amp; n_loop != n1_loop) ||
 370       (n_loop-&gt;is_member( n2_loop ) &amp;&amp; n_loop != n2_loop) ||
 371       (n_loop-&gt;is_member( n3_loop ) &amp;&amp; n_loop != n3_loop) )
 372     return NULL;                // Leave well enough alone
 373 
 374   // Is at least one of my inputs loop-invariant?
 375   if( n1_loop == n_loop &amp;&amp;
 376       n2_loop == n_loop &amp;&amp;
 377       n3_loop == n_loop )
 378     return NULL;                // No loop-invariant inputs
 379 
 380 
 381   int n_op = n-&gt;Opcode();
 382 
 383   // Replace expressions like ((V+I) &lt;&lt; 2) with (V&lt;&lt;2 + I&lt;&lt;2).
 384   if( n_op == Op_LShiftI ) {
 385     // Scale is loop invariant
 386     Node *scale = n-&gt;in(2);
 387     Node *scale_ctrl = get_ctrl(scale);
 388     IdealLoopTree *scale_loop = get_loop(scale_ctrl );
 389     if( n_loop == scale_loop || !scale_loop-&gt;is_member( n_loop ) )
 390       return NULL;
 391     const TypeInt *scale_t = scale-&gt;bottom_type()-&gt;isa_int();
 392     if( scale_t &amp;&amp; scale_t-&gt;is_con() &amp;&amp; scale_t-&gt;get_con() &gt;= 16 )
 393       return NULL;              // Dont bother with byte/short masking
 394     // Add must vary with loop (else shift would be loop-invariant)
 395     Node *add = n-&gt;in(1);
 396     Node *add_ctrl = get_ctrl(add);
 397     IdealLoopTree *add_loop = get_loop(add_ctrl);
 398     //assert( n_loop == add_loop, &quot;&quot; );
 399     if( n_loop != add_loop ) return NULL;  // happens w/ evil ZKM loops
 400 
 401     // Convert I-V into I+ (0-V); same for V-I
 402     if( add-&gt;Opcode() == Op_SubI &amp;&amp;
 403         _igvn.type( add-&gt;in(1) ) != TypeInt::ZERO ) {
 404       Node *zero = _igvn.intcon(0);
 405       set_ctrl(zero, C-&gt;root());
 406       Node *neg = new SubINode( _igvn.intcon(0), add-&gt;in(2) );
 407       register_new_node( neg, get_ctrl(add-&gt;in(2) ) );
 408       add = new AddINode( add-&gt;in(1), neg );
 409       register_new_node( add, add_ctrl );
 410     }
 411     if( add-&gt;Opcode() != Op_AddI ) return NULL;
 412     // See if one add input is loop invariant
 413     Node *add_var = add-&gt;in(1);
 414     Node *add_var_ctrl = get_ctrl(add_var);
 415     IdealLoopTree *add_var_loop = get_loop(add_var_ctrl );
 416     Node *add_invar = add-&gt;in(2);
 417     Node *add_invar_ctrl = get_ctrl(add_invar);
 418     IdealLoopTree *add_invar_loop = get_loop(add_invar_ctrl );
 419     if( add_var_loop == n_loop ) {
 420     } else if( add_invar_loop == n_loop ) {
 421       // Swap to find the invariant part
 422       add_invar = add_var;
 423       add_invar_ctrl = add_var_ctrl;
 424       add_invar_loop = add_var_loop;
 425       add_var = add-&gt;in(2);
 426       Node *add_var_ctrl = get_ctrl(add_var);
 427       IdealLoopTree *add_var_loop = get_loop(add_var_ctrl );
 428     } else                      // Else neither input is loop invariant
 429       return NULL;
 430     if( n_loop == add_invar_loop || !add_invar_loop-&gt;is_member( n_loop ) )
 431       return NULL;              // No invariant part of the add?
 432 
 433     // Yes!  Reshape address expression!
 434     Node *inv_scale = new LShiftINode( add_invar, scale );
 435     Node *inv_scale_ctrl =
 436       dom_depth(add_invar_ctrl) &gt; dom_depth(scale_ctrl) ?
 437       add_invar_ctrl : scale_ctrl;
 438     register_new_node( inv_scale, inv_scale_ctrl );
 439     Node *var_scale = new LShiftINode( add_var, scale );
 440     register_new_node( var_scale, n_ctrl );
 441     Node *var_add = new AddINode( var_scale, inv_scale );
 442     register_new_node( var_add, n_ctrl );
 443     _igvn.replace_node( n, var_add );
 444     return var_add;
 445   }
 446 
 447   // Replace (I+V) with (V+I)
 448   if( n_op == Op_AddI ||
 449       n_op == Op_AddL ||
 450       n_op == Op_AddF ||
 451       n_op == Op_AddD ||
 452       n_op == Op_MulI ||
 453       n_op == Op_MulL ||
 454       n_op == Op_MulF ||
 455       n_op == Op_MulD ) {
 456     if( n2_loop == n_loop ) {
 457       assert( n1_loop != n_loop, &quot;&quot; );
 458       n-&gt;swap_edges(1, 2);
 459     }
 460   }
 461 
 462   // Replace ((I1 +p V) +p I2) with ((I1 +p I2) +p V),
 463   // but not if I2 is a constant.
 464   if( n_op == Op_AddP ) {
 465     if( n2_loop == n_loop &amp;&amp; n3_loop != n_loop ) {
 466       if( n-&gt;in(2)-&gt;Opcode() == Op_AddP &amp;&amp; !n-&gt;in(3)-&gt;is_Con() ) {
 467         Node *n22_ctrl = get_ctrl(n-&gt;in(2)-&gt;in(2));
 468         Node *n23_ctrl = get_ctrl(n-&gt;in(2)-&gt;in(3));
 469         IdealLoopTree *n22loop = get_loop( n22_ctrl );
 470         IdealLoopTree *n23_loop = get_loop( n23_ctrl );
 471         if( n22loop != n_loop &amp;&amp; n22loop-&gt;is_member(n_loop) &amp;&amp;
 472             n23_loop == n_loop ) {
 473           Node *add1 = new AddPNode( n-&gt;in(1), n-&gt;in(2)-&gt;in(2), n-&gt;in(3) );
 474           // Stuff new AddP in the loop preheader
 475           register_new_node( add1, n_loop-&gt;_head-&gt;in(LoopNode::EntryControl) );
 476           Node *add2 = new AddPNode( n-&gt;in(1), add1, n-&gt;in(2)-&gt;in(3) );
 477           register_new_node( add2, n_ctrl );
 478           _igvn.replace_node( n, add2 );
 479           return add2;
 480         }
 481       }
 482     }
 483 
 484     // Replace (I1 +p (I2 + V)) with ((I1 +p I2) +p V)
 485     if (n2_loop != n_loop &amp;&amp; n3_loop == n_loop) {
 486       if (n-&gt;in(3)-&gt;Opcode() == Op_AddX) {
 487         Node *V = n-&gt;in(3)-&gt;in(1);
 488         Node *I = n-&gt;in(3)-&gt;in(2);
 489         if (is_member(n_loop,get_ctrl(V))) {
 490         } else {
 491           Node *tmp = V; V = I; I = tmp;
 492         }
 493         if (!is_member(n_loop,get_ctrl(I))) {
 494           Node *add1 = new AddPNode(n-&gt;in(1), n-&gt;in(2), I);
 495           // Stuff new AddP in the loop preheader
 496           register_new_node(add1, n_loop-&gt;_head-&gt;in(LoopNode::EntryControl));
 497           Node *add2 = new AddPNode(n-&gt;in(1), add1, V);
 498           register_new_node(add2, n_ctrl);
 499           _igvn.replace_node(n, add2);
 500           return add2;
 501         }
 502       }
 503     }
 504   }
 505 
 506   return NULL;
 507 }
 508 
 509 // Optimize ((in1[2*i] * in2[2*i]) + (in1[2*i+1] * in2[2*i+1]))
 510 Node *PhaseIdealLoop::convert_add_to_muladd(Node* n) {
 511   assert(n-&gt;Opcode() == Op_AddI, &quot;sanity&quot;);
 512   Node * nn = NULL;
 513   Node * in1 = n-&gt;in(1);
 514   Node * in2 = n-&gt;in(2);
 515   if (in1-&gt;Opcode() == Op_MulI &amp;&amp; in2-&gt;Opcode() == Op_MulI) {
 516     IdealLoopTree* loop_n = get_loop(get_ctrl(n));
 517     if (loop_n-&gt;is_counted() &amp;&amp;
 518         loop_n-&gt;_head-&gt;as_Loop()-&gt;is_valid_counted_loop() &amp;&amp;
 519         Matcher::match_rule_supported(Op_MulAddVS2VI) &amp;&amp;
 520         Matcher::match_rule_supported(Op_MulAddS2I)) {
 521       Node* mul_in1 = in1-&gt;in(1);
 522       Node* mul_in2 = in1-&gt;in(2);
 523       Node* mul_in3 = in2-&gt;in(1);
 524       Node* mul_in4 = in2-&gt;in(2);
 525       if (mul_in1-&gt;Opcode() == Op_LoadS &amp;&amp;
 526           mul_in2-&gt;Opcode() == Op_LoadS &amp;&amp;
 527           mul_in3-&gt;Opcode() == Op_LoadS &amp;&amp;
 528           mul_in4-&gt;Opcode() == Op_LoadS) {
 529         IdealLoopTree* loop1 = get_loop(get_ctrl(mul_in1));
 530         IdealLoopTree* loop2 = get_loop(get_ctrl(mul_in2));
 531         IdealLoopTree* loop3 = get_loop(get_ctrl(mul_in3));
 532         IdealLoopTree* loop4 = get_loop(get_ctrl(mul_in4));
 533         IdealLoopTree* loop5 = get_loop(get_ctrl(in1));
 534         IdealLoopTree* loop6 = get_loop(get_ctrl(in2));
 535         // All nodes should be in the same counted loop.
 536         if (loop_n == loop1 &amp;&amp; loop_n == loop2 &amp;&amp; loop_n == loop3 &amp;&amp;
 537             loop_n == loop4 &amp;&amp; loop_n == loop5 &amp;&amp; loop_n == loop6) {
 538           Node* adr1 = mul_in1-&gt;in(MemNode::Address);
 539           Node* adr2 = mul_in2-&gt;in(MemNode::Address);
 540           Node* adr3 = mul_in3-&gt;in(MemNode::Address);
 541           Node* adr4 = mul_in4-&gt;in(MemNode::Address);
 542           if (adr1-&gt;is_AddP() &amp;&amp; adr2-&gt;is_AddP() &amp;&amp; adr3-&gt;is_AddP() &amp;&amp; adr4-&gt;is_AddP()) {
 543             if ((adr1-&gt;in(AddPNode::Base) == adr3-&gt;in(AddPNode::Base)) &amp;&amp;
 544                 (adr2-&gt;in(AddPNode::Base) == adr4-&gt;in(AddPNode::Base))) {
 545               nn = new MulAddS2INode(mul_in1, mul_in2, mul_in3, mul_in4);
 546               register_new_node(nn, get_ctrl(n));
 547               _igvn.replace_node(n, nn);
 548               return nn;
 549             } else if ((adr1-&gt;in(AddPNode::Base) == adr4-&gt;in(AddPNode::Base)) &amp;&amp;
 550                        (adr2-&gt;in(AddPNode::Base) == adr3-&gt;in(AddPNode::Base))) {
 551               nn = new MulAddS2INode(mul_in1, mul_in2, mul_in4, mul_in3);
 552               register_new_node(nn, get_ctrl(n));
 553               _igvn.replace_node(n, nn);
 554               return nn;
 555             }
 556           }
 557         }
 558       }
 559     }
 560   }
 561   return nn;
 562 }
 563 
 564 //------------------------------conditional_move-------------------------------
 565 // Attempt to replace a Phi with a conditional move.  We have some pretty
 566 // strict profitability requirements.  All Phis at the merge point must
 567 // be converted, so we can remove the control flow.  We need to limit the
 568 // number of c-moves to a small handful.  All code that was in the side-arms
 569 // of the CFG diamond is now speculatively executed.  This code has to be
 570 // &quot;cheap enough&quot;.  We are pretty much limited to CFG diamonds that merge
 571 // 1 or 2 items with a total of 1 or 2 ops executed speculatively.
 572 Node *PhaseIdealLoop::conditional_move( Node *region ) {
 573 
 574   assert(region-&gt;is_Region(), &quot;sanity check&quot;);
 575   if (region-&gt;req() != 3) return NULL;
 576 
 577   // Check for CFG diamond
 578   Node *lp = region-&gt;in(1);
 579   Node *rp = region-&gt;in(2);
 580   if (!lp || !rp) return NULL;
 581   Node *lp_c = lp-&gt;in(0);
 582   if (lp_c == NULL || lp_c != rp-&gt;in(0) || !lp_c-&gt;is_If()) return NULL;
 583   IfNode *iff = lp_c-&gt;as_If();
 584 
 585   // Check for ops pinned in an arm of the diamond.
 586   // Can&#39;t remove the control flow in this case
 587   if (lp-&gt;outcnt() &gt; 1) return NULL;
 588   if (rp-&gt;outcnt() &gt; 1) return NULL;
 589 
 590   IdealLoopTree* r_loop = get_loop(region);
 591   assert(r_loop == get_loop(iff), &quot;sanity&quot;);
 592   // Always convert to CMOVE if all results are used only outside this loop.
 593   bool used_inside_loop = (r_loop == _ltree_root);
 594 
 595   // Check profitability
 596   int cost = 0;
 597   int phis = 0;
 598   for (DUIterator_Fast imax, i = region-&gt;fast_outs(imax); i &lt; imax; i++) {
 599     Node *out = region-&gt;fast_out(i);
 600     if (!out-&gt;is_Phi()) continue; // Ignore other control edges, etc
 601     phis++;
 602     PhiNode* phi = out-&gt;as_Phi();
 603     BasicType bt = phi-&gt;type()-&gt;basic_type();
 604     switch (bt) {
 605     case T_DOUBLE:
 606     case T_FLOAT:
 607       if (C-&gt;use_cmove()) {
 608         continue; //TODO: maybe we want to add some cost
 609       }
 610       cost += Matcher::float_cmove_cost(); // Could be very expensive
 611       break;
 612     case T_LONG: {
 613       cost += Matcher::long_cmove_cost(); // May encodes as 2 CMOV&#39;s
 614     }
 615     case T_INT:                 // These all CMOV fine
 616     case T_ADDRESS: {           // (RawPtr)
 617       cost++;
 618       break;
 619     }
 620     case T_NARROWOOP: // Fall through
 621     case T_OBJECT: {            // Base oops are OK, but not derived oops
 622       const TypeOopPtr *tp = phi-&gt;type()-&gt;make_ptr()-&gt;isa_oopptr();
 623       // Derived pointers are Bad (tm): what&#39;s the Base (for GC purposes) of a
 624       // CMOVE&#39;d derived pointer?  It&#39;s a CMOVE&#39;d derived base.  Thus
 625       // CMOVE&#39;ing a derived pointer requires we also CMOVE the base.  If we
 626       // have a Phi for the base here that we convert to a CMOVE all is well
 627       // and good.  But if the base is dead, we&#39;ll not make a CMOVE.  Later
 628       // the allocator will have to produce a base by creating a CMOVE of the
 629       // relevant bases.  This puts the allocator in the business of
 630       // manufacturing expensive instructions, generally a bad plan.
 631       // Just Say No to Conditionally-Moved Derived Pointers.
 632       if (tp &amp;&amp; tp-&gt;offset() != 0)
 633         return NULL;
 634       cost++;
 635       break;
 636     }
 637     default:
 638       return NULL;              // In particular, can&#39;t do memory or I/O
 639     }
 640     // Add in cost any speculative ops
 641     for (uint j = 1; j &lt; region-&gt;req(); j++) {
 642       Node *proj = region-&gt;in(j);
 643       Node *inp = phi-&gt;in(j);
 644       if (get_ctrl(inp) == proj) { // Found local op
 645         cost++;
 646         // Check for a chain of dependent ops; these will all become
 647         // speculative in a CMOV.
 648         for (uint k = 1; k &lt; inp-&gt;req(); k++)
 649           if (get_ctrl(inp-&gt;in(k)) == proj)
 650             cost += ConditionalMoveLimit; // Too much speculative goo
 651       }
 652     }
 653     // See if the Phi is used by a Cmp or Narrow oop Decode/Encode.
 654     // This will likely Split-If, a higher-payoff operation.
 655     for (DUIterator_Fast kmax, k = phi-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 656       Node* use = phi-&gt;fast_out(k);
 657       if (use-&gt;is_Cmp() || use-&gt;is_DecodeNarrowPtr() || use-&gt;is_EncodeNarrowPtr())
 658         cost += ConditionalMoveLimit;
 659       // Is there a use inside the loop?
 660       // Note: check only basic types since CMoveP is pinned.
 661       if (!used_inside_loop &amp;&amp; is_java_primitive(bt)) {
 662         IdealLoopTree* u_loop = get_loop(has_ctrl(use) ? get_ctrl(use) : use);
 663         if (r_loop == u_loop || r_loop-&gt;is_member(u_loop)) {
 664           used_inside_loop = true;
 665         }
 666       }
 667     }
 668   }//for
 669   Node* bol = iff-&gt;in(1);
 670   if (bol-&gt;Opcode() == Op_Opaque4) {
 671     return NULL; // Ignore loop predicate checks (the Opaque4 ensures they will go away)
 672   }
 673   assert(bol-&gt;Opcode() == Op_Bool, &quot;Unexpected node&quot;);
 674   int cmp_op = bol-&gt;in(1)-&gt;Opcode();
 675   if (cmp_op == Op_SubTypeCheck) { // SubTypeCheck expansion expects an IfNode
 676     return NULL;
 677   }
 678   // It is expensive to generate flags from a float compare.
 679   // Avoid duplicated float compare.
 680   if (phis &gt; 1 &amp;&amp; (cmp_op == Op_CmpF || cmp_op == Op_CmpD)) return NULL;
 681 
 682   float infrequent_prob = PROB_UNLIKELY_MAG(3);
 683   // Ignore cost and blocks frequency if CMOVE can be moved outside the loop.
 684   if (used_inside_loop) {
 685     if (cost &gt;= ConditionalMoveLimit) return NULL; // Too much goo
 686 
 687     // BlockLayoutByFrequency optimization moves infrequent branch
 688     // from hot path. No point in CMOV&#39;ing in such case (110 is used
 689     // instead of 100 to take into account not exactness of float value).
 690     if (BlockLayoutByFrequency) {
 691       infrequent_prob = MAX2(infrequent_prob, (float)BlockLayoutMinDiamondPercentage/110.0f);
 692     }
 693   }
 694   // Check for highly predictable branch.  No point in CMOV&#39;ing if
 695   // we are going to predict accurately all the time.
 696   if (C-&gt;use_cmove() &amp;&amp; (cmp_op == Op_CmpF || cmp_op == Op_CmpD)) {
 697     //keep going
 698   } else if (iff-&gt;_prob &lt; infrequent_prob ||
 699       iff-&gt;_prob &gt; (1.0f - infrequent_prob))
 700     return NULL;
 701 
 702   // --------------
 703   // Now replace all Phis with CMOV&#39;s
 704   Node *cmov_ctrl = iff-&gt;in(0);
 705   uint flip = (lp-&gt;Opcode() == Op_IfTrue);
 706   Node_List wq;
 707   while (1) {
 708     PhiNode* phi = NULL;
 709     for (DUIterator_Fast imax, i = region-&gt;fast_outs(imax); i &lt; imax; i++) {
 710       Node *out = region-&gt;fast_out(i);
 711       if (out-&gt;is_Phi()) {
 712         phi = out-&gt;as_Phi();
 713         break;
 714       }
 715     }
 716     if (phi == NULL)  break;
 717     if (PrintOpto &amp;&amp; VerifyLoopOptimizations) { tty-&gt;print_cr(&quot;CMOV&quot;); }
 718     // Move speculative ops
 719     wq.push(phi);
 720     while (wq.size() &gt; 0) {
 721       Node *n = wq.pop();
 722       for (uint j = 1; j &lt; n-&gt;req(); j++) {
 723         Node* m = n-&gt;in(j);
 724         if (m != NULL &amp;&amp; !is_dominator(get_ctrl(m), cmov_ctrl)) {
 725 #ifndef PRODUCT
 726           if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
 727             tty-&gt;print(&quot;  speculate: &quot;);
 728             m-&gt;dump();
 729           }
 730 #endif
 731           set_ctrl(m, cmov_ctrl);
 732           wq.push(m);
 733         }
 734       }
 735     }
 736     Node *cmov = CMoveNode::make(cmov_ctrl, iff-&gt;in(1), phi-&gt;in(1+flip), phi-&gt;in(2-flip), _igvn.type(phi));
 737     register_new_node( cmov, cmov_ctrl );
 738     _igvn.replace_node( phi, cmov );
 739 #ifndef PRODUCT
 740     if (TraceLoopOpts) {
 741       tty-&gt;print(&quot;CMOV  &quot;);
 742       r_loop-&gt;dump_head();
 743       if (Verbose) {
 744         bol-&gt;in(1)-&gt;dump(1);
 745         cmov-&gt;dump(1);
 746       }
 747     }
 748     if (VerifyLoopOptimizations) verify();
 749 #endif
 750   }
 751 
 752   // The useless CFG diamond will fold up later; see the optimization in
 753   // RegionNode::Ideal.
 754   _igvn._worklist.push(region);
 755 
 756   return iff-&gt;in(1);
 757 }
 758 
 759 static void enqueue_cfg_uses(Node* m, Unique_Node_List&amp; wq) {
 760   for (DUIterator_Fast imax, i = m-&gt;fast_outs(imax); i &lt; imax; i++) {
 761     Node* u = m-&gt;fast_out(i);
 762     if (u-&gt;is_CFG()) {
 763       if (u-&gt;Opcode() == Op_NeverBranch) {
 764         u = ((NeverBranchNode*)u)-&gt;proj_out(0);
 765         enqueue_cfg_uses(u, wq);
 766       } else {
 767         wq.push(u);
 768       }
 769     }
 770   }
 771 }
 772 
 773 // Try moving a store out of a loop, right before the loop
 774 Node* PhaseIdealLoop::try_move_store_before_loop(Node* n, Node *n_ctrl) {
 775   // Store has to be first in the loop body
 776   IdealLoopTree *n_loop = get_loop(n_ctrl);
 777   if (n-&gt;is_Store() &amp;&amp; n_loop != _ltree_root &amp;&amp;
 778       n_loop-&gt;is_loop() &amp;&amp; n_loop-&gt;_head-&gt;is_Loop() &amp;&amp;
 779       n-&gt;in(0) != NULL) {
 780     Node* address = n-&gt;in(MemNode::Address);
 781     Node* value = n-&gt;in(MemNode::ValueIn);
 782     Node* mem = n-&gt;in(MemNode::Memory);
 783     IdealLoopTree* address_loop = get_loop(get_ctrl(address));
 784     IdealLoopTree* value_loop = get_loop(get_ctrl(value));
 785 
 786     // - address and value must be loop invariant
 787     // - memory must be a memory Phi for the loop
 788     // - Store must be the only store on this memory slice in the
 789     // loop: if there&#39;s another store following this one then value
 790     // written at iteration i by the second store could be overwritten
 791     // at iteration i+n by the first store: it&#39;s not safe to move the
 792     // first store out of the loop
 793     // - nothing must observe the memory Phi: it guarantees no read
 794     // before the store, we are also guaranteed the store post
 795     // dominates the loop head (ignoring a possible early
 796     // exit). Otherwise there would be extra Phi involved between the
 797     // loop&#39;s Phi and the store.
 798     // - there must be no early exit from the loop before the Store
 799     // (such an exit most of the time would be an extra use of the
 800     // memory Phi but sometimes is a bottom memory Phi that takes the
 801     // store as input).
 802 
 803     if (!n_loop-&gt;is_member(address_loop) &amp;&amp;
 804         !n_loop-&gt;is_member(value_loop) &amp;&amp;
 805         mem-&gt;is_Phi() &amp;&amp; mem-&gt;in(0) == n_loop-&gt;_head &amp;&amp;
 806         mem-&gt;outcnt() == 1 &amp;&amp;
 807         mem-&gt;in(LoopNode::LoopBackControl) == n) {
 808 
 809       assert(n_loop-&gt;_tail != NULL, &quot;need a tail&quot;);
 810       assert(is_dominator(n_ctrl, n_loop-&gt;_tail), &quot;store control must not be in a branch in the loop&quot;);
 811 
 812       // Verify that there&#39;s no early exit of the loop before the store.
 813       bool ctrl_ok = false;
 814       {
 815         // Follow control from loop head until n, we exit the loop or
 816         // we reach the tail
 817         ResourceMark rm;
 818         Unique_Node_List wq;
 819         wq.push(n_loop-&gt;_head);
 820 
 821         for (uint next = 0; next &lt; wq.size(); ++next) {
 822           Node *m = wq.at(next);
 823           if (m == n-&gt;in(0)) {
 824             ctrl_ok = true;
 825             continue;
 826           }
 827           assert(!has_ctrl(m), &quot;should be CFG&quot;);
 828           if (!n_loop-&gt;is_member(get_loop(m)) || m == n_loop-&gt;_tail) {
 829             ctrl_ok = false;
 830             break;
 831           }
 832           enqueue_cfg_uses(m, wq);
 833           if (wq.size() &gt; 10) {
 834             ctrl_ok = false;
 835             break;
 836           }
 837         }
 838       }
 839       if (ctrl_ok) {
 840         // move the Store
 841         _igvn.replace_input_of(mem, LoopNode::LoopBackControl, mem);
 842         _igvn.replace_input_of(n, 0, n_loop-&gt;_head-&gt;as_Loop()-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl));
 843         _igvn.replace_input_of(n, MemNode::Memory, mem-&gt;in(LoopNode::EntryControl));
 844         // Disconnect the phi now. An empty phi can confuse other
 845         // optimizations in this pass of loop opts.
 846         _igvn.replace_node(mem, mem-&gt;in(LoopNode::EntryControl));
 847         n_loop-&gt;_body.yank(mem);
 848 
 849         set_ctrl_and_loop(n, n-&gt;in(0));
 850 
 851         return n;
 852       }
 853     }
 854   }
 855   return NULL;
 856 }
 857 
 858 // Try moving a store out of a loop, right after the loop
 859 void PhaseIdealLoop::try_move_store_after_loop(Node* n) {
 860   if (n-&gt;is_Store() &amp;&amp; n-&gt;in(0) != NULL) {
 861     Node *n_ctrl = get_ctrl(n);
 862     IdealLoopTree *n_loop = get_loop(n_ctrl);
 863     // Store must be in a loop
 864     if (n_loop != _ltree_root &amp;&amp; !n_loop-&gt;_irreducible) {
 865       Node* address = n-&gt;in(MemNode::Address);
 866       Node* value = n-&gt;in(MemNode::ValueIn);
 867       IdealLoopTree* address_loop = get_loop(get_ctrl(address));
 868       // address must be loop invariant
 869       if (!n_loop-&gt;is_member(address_loop)) {
 870         // Store must be last on this memory slice in the loop and
 871         // nothing in the loop must observe it
 872         Node* phi = NULL;
 873         for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
 874           Node* u = n-&gt;fast_out(i);
 875           if (has_ctrl(u)) { // control use?
 876             IdealLoopTree *u_loop = get_loop(get_ctrl(u));
 877             if (!n_loop-&gt;is_member(u_loop)) {
 878               continue;
 879             }
 880             if (u-&gt;is_Phi() &amp;&amp; u-&gt;in(0) == n_loop-&gt;_head) {
 881               assert(_igvn.type(u) == Type::MEMORY, &quot;bad phi&quot;);
 882               // multiple phis on the same slice are possible
 883               if (phi != NULL) {
 884                 return;
 885               }
 886               phi = u;
 887               continue;
 888             }
 889           }
 890           return;
 891         }
 892         if (phi != NULL) {
 893           // Nothing in the loop before the store (next iteration)
 894           // must observe the stored value
 895           bool mem_ok = true;
 896           {
 897             ResourceMark rm;
 898             Unique_Node_List wq;
 899             wq.push(phi);
 900             for (uint next = 0; next &lt; wq.size() &amp;&amp; mem_ok; ++next) {
 901               Node *m = wq.at(next);
 902               for (DUIterator_Fast imax, i = m-&gt;fast_outs(imax); i &lt; imax &amp;&amp; mem_ok; i++) {
 903                 Node* u = m-&gt;fast_out(i);
 904                 if (u-&gt;is_Store() || u-&gt;is_Phi()) {
 905                   if (u != n) {
 906                     wq.push(u);
 907                     mem_ok = (wq.size() &lt;= 10);
 908                   }
 909                 } else {
 910                   mem_ok = false;
 911                   break;
 912                 }
 913               }
 914             }
 915           }
 916           if (mem_ok) {
 917             // Move the store out of the loop if the LCA of all
 918             // users (except for the phi) is outside the loop.
 919             Node* hook = new Node(1);
 920             hook-&gt;init_req(0, n_ctrl); // Add an input to prevent hook from being dead
 921             _igvn.rehash_node_delayed(phi);
 922             int count = phi-&gt;replace_edge(n, hook);
 923             assert(count &gt; 0, &quot;inconsistent phi&quot;);
 924 
 925             // Compute latest point this store can go
 926             Node* lca = get_late_ctrl(n, get_ctrl(n));
 927             if (lca-&gt;is_OuterStripMinedLoop()) {
 928               lca = lca-&gt;in(LoopNode::EntryControl);
 929             }
 930             if (n_loop-&gt;is_member(get_loop(lca))) {
 931               // LCA is in the loop - bail out
 932               _igvn.replace_node(hook, n);
 933               return;
 934             }
 935 #ifdef ASSERT
 936             if (n_loop-&gt;_head-&gt;is_Loop() &amp;&amp; n_loop-&gt;_head-&gt;as_Loop()-&gt;is_strip_mined()) {
 937               assert(n_loop-&gt;_head-&gt;Opcode() == Op_CountedLoop, &quot;outer loop is a strip mined&quot;);
 938               n_loop-&gt;_head-&gt;as_Loop()-&gt;verify_strip_mined(1);
 939               Node* outer = n_loop-&gt;_head-&gt;as_CountedLoop()-&gt;outer_loop();
 940               IdealLoopTree* outer_loop = get_loop(outer);
 941               assert(n_loop-&gt;_parent == outer_loop, &quot;broken loop tree&quot;);
 942               assert(get_loop(lca) == outer_loop, &quot;safepoint in outer loop consume all memory state&quot;);
 943             }
 944 #endif
 945 
 946             // Move store out of the loop
 947             _igvn.replace_node(hook, n-&gt;in(MemNode::Memory));
 948             _igvn.replace_input_of(n, 0, lca);
 949             set_ctrl_and_loop(n, lca);
 950 
 951             // Disconnect the phi now. An empty phi can confuse other
 952             // optimizations in this pass of loop opts..
 953             if (phi-&gt;in(LoopNode::LoopBackControl) == phi) {
 954               _igvn.replace_node(phi, phi-&gt;in(LoopNode::EntryControl));
 955               n_loop-&gt;_body.yank(phi);
 956             }
 957           }
 958         }
 959       }
 960     }
 961   }
 962 }
 963 
 964 //------------------------------split_if_with_blocks_pre-----------------------
 965 // Do the real work in a non-recursive function.  Data nodes want to be
 966 // cloned in the pre-order so they can feed each other nicely.
 967 Node *PhaseIdealLoop::split_if_with_blocks_pre( Node *n ) {
 968   // Cloning these guys is unlikely to win
 969   int n_op = n-&gt;Opcode();
 970   if (n_op == Op_MergeMem) {
 971     return n;
 972   }
 973   if (n-&gt;is_Proj()) {
 974     return n;
 975   }
 976   // Do not clone-up CmpFXXX variations, as these are always
 977   // followed by a CmpI
 978   if (n-&gt;is_Cmp()) {
 979     return n;
 980   }
 981   // Attempt to use a conditional move instead of a phi/branch
 982   if (ConditionalMoveLimit &gt; 0 &amp;&amp; n_op == Op_Region) {
 983     Node *cmov = conditional_move( n );
 984     if (cmov) {
 985       return cmov;
 986     }
 987   }
 988   if (n-&gt;is_CFG() || n-&gt;is_LoadStore()) {
 989     return n;
 990   }
 991   if (n-&gt;is_Opaque1() ||     // Opaque nodes cannot be mod&#39;d
 992       n_op == Op_Opaque2) {
 993     if (!C-&gt;major_progress()) {   // If chance of no more loop opts...
 994       _igvn._worklist.push(n);  // maybe we&#39;ll remove them
 995     }
 996     return n;
 997   }
 998 
 999   if (n-&gt;is_Con()) {
1000     return n;   // No cloning for Con nodes
1001   }
1002 
1003   Node *n_ctrl = get_ctrl(n);
1004   if (!n_ctrl) {
1005     return n;       // Dead node
1006   }
1007 
1008   Node* res = try_move_store_before_loop(n, n_ctrl);
1009   if (res != NULL) {
1010     return n;
1011   }
1012 
1013   // Attempt to remix address expressions for loop invariants
1014   Node *m = remix_address_expressions( n );
1015   if( m ) return m;
1016 
1017   if (n_op == Op_AddI) {
1018     Node *nn = convert_add_to_muladd( n );
1019     if ( nn ) return nn;
1020   }
1021 
1022   if (n-&gt;is_ConstraintCast()) {
1023     Node* dom_cast = n-&gt;as_ConstraintCast()-&gt;dominating_cast(&amp;_igvn, this);
1024     // ConstraintCastNode::dominating_cast() uses node control input to determine domination.
1025     // Node control inputs don&#39;t necessarily agree with loop control info (due to
1026     // transformations happened in between), thus additional dominance check is needed
1027     // to keep loop info valid.
1028     if (dom_cast != NULL &amp;&amp; is_dominator(get_ctrl(dom_cast), get_ctrl(n))) {
1029       _igvn.replace_node(n, dom_cast);
1030       return dom_cast;
1031     }
1032   }
1033 
1034   // Determine if the Node has inputs from some local Phi.
1035   // Returns the block to clone thru.
1036   Node *n_blk = has_local_phi_input( n );
1037   if( !n_blk ) return n;
1038 
1039   // Do not clone the trip counter through on a CountedLoop
1040   // (messes up the canonical shape).
1041   if( n_blk-&gt;is_CountedLoop() &amp;&amp; n-&gt;Opcode() == Op_AddI ) return n;
1042 
1043   // Check for having no control input; not pinned.  Allow
1044   // dominating control.
1045   if (n-&gt;in(0)) {
1046     Node *dom = idom(n_blk);
1047     if (dom_lca(n-&gt;in(0), dom) != n-&gt;in(0)) {
1048       return n;
1049     }
1050   }
1051   // Policy: when is it profitable.  You must get more wins than
1052   // policy before it is considered profitable.  Policy is usually 0,
1053   // so 1 win is considered profitable.  Big merges will require big
1054   // cloning, so get a larger policy.
1055   int policy = n_blk-&gt;req() &gt;&gt; 2;
1056 
1057   // If the loop is a candidate for range check elimination,
1058   // delay splitting through it&#39;s phi until a later loop optimization
1059   if (n_blk-&gt;is_CountedLoop()) {
1060     IdealLoopTree *lp = get_loop(n_blk);
1061     if (lp &amp;&amp; lp-&gt;_rce_candidate) {
1062       return n;
1063     }
1064   }
1065 
1066   if (must_throttle_split_if()) return n;
1067 
1068   // Split &#39;n&#39; through the merge point if it is profitable
1069   Node *phi = split_thru_phi( n, n_blk, policy );
1070   if (!phi) return n;
1071 
1072   // Found a Phi to split thru!
1073   // Replace &#39;n&#39; with the new phi
1074   _igvn.replace_node( n, phi );
1075   // Moved a load around the loop, &#39;en-registering&#39; something.
1076   if (n_blk-&gt;is_Loop() &amp;&amp; n-&gt;is_Load() &amp;&amp;
1077       !phi-&gt;in(LoopNode::LoopBackControl)-&gt;is_Load())
1078     C-&gt;set_major_progress();
1079 
1080   return phi;
1081 }
1082 
1083 static bool merge_point_too_heavy(Compile* C, Node* region) {
1084   // Bail out if the region and its phis have too many users.
1085   int weight = 0;
1086   for (DUIterator_Fast imax, i = region-&gt;fast_outs(imax); i &lt; imax; i++) {
1087     weight += region-&gt;fast_out(i)-&gt;outcnt();
1088   }
1089   int nodes_left = C-&gt;max_node_limit() - C-&gt;live_nodes();
1090   if (weight * 8 &gt; nodes_left) {
1091     if (PrintOpto) {
1092       tty-&gt;print_cr(&quot;*** Split-if bails out:  %d nodes, region weight %d&quot;, C-&gt;unique(), weight);
1093     }
1094     return true;
1095   } else {
1096     return false;
1097   }
1098 }
1099 
1100 static bool merge_point_safe(Node* region) {
1101   // 4799512: Stop split_if_with_blocks from splitting a block with a ConvI2LNode
1102   // having a PhiNode input. This sidesteps the dangerous case where the split
1103   // ConvI2LNode may become TOP if the input Value() does not
1104   // overlap the ConvI2L range, leaving a node which may not dominate its
1105   // uses.
1106   // A better fix for this problem can be found in the BugTraq entry, but
1107   // expediency for Mantis demands this hack.
1108 #ifdef _LP64
1109   for (DUIterator_Fast imax, i = region-&gt;fast_outs(imax); i &lt; imax; i++) {
1110     Node* n = region-&gt;fast_out(i);
1111     if (n-&gt;is_Phi()) {
1112       for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1113         Node* m = n-&gt;fast_out(j);
1114         if (m-&gt;Opcode() == Op_ConvI2L)
1115           return false;
1116         if (m-&gt;is_CastII() &amp;&amp; m-&gt;isa_CastII()-&gt;has_range_check()) {
1117           return false;
1118         }
1119       }
1120     }
1121   }
1122 #endif
1123   return true;
1124 }
1125 
1126 
1127 //------------------------------place_near_use---------------------------------
1128 // Place some computation next to use but not inside inner loops.
1129 // For inner loop uses move it to the preheader area.
1130 Node *PhaseIdealLoop::place_near_use(Node *useblock) const {
1131   IdealLoopTree *u_loop = get_loop( useblock );
1132   if (u_loop-&gt;_irreducible) {
1133     return useblock;
1134   }
1135   if (u_loop-&gt;_child) {
1136     if (useblock == u_loop-&gt;_head &amp;&amp; u_loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1137       return u_loop-&gt;_head-&gt;in(LoopNode::EntryControl);
1138     }
1139     return useblock;
1140   }
1141   return u_loop-&gt;_head-&gt;as_Loop()-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1142 }
1143 
1144 
1145 bool PhaseIdealLoop::identical_backtoback_ifs(Node *n) {
1146   if (!n-&gt;is_If() || n-&gt;is_CountedLoopEnd()) {
1147     return false;
1148   }
1149   if (!n-&gt;in(0)-&gt;is_Region()) {
1150     return false;
1151   }
1152   Node* region = n-&gt;in(0);
1153   Node* dom = idom(region);
1154   if (!dom-&gt;is_If() || dom-&gt;in(1) != n-&gt;in(1)) {
1155     return false;
1156   }
1157   IfNode* dom_if = dom-&gt;as_If();
1158   Node* proj_true = dom_if-&gt;proj_out(1);
1159   Node* proj_false = dom_if-&gt;proj_out(0);
1160 
1161   for (uint i = 1; i &lt; region-&gt;req(); i++) {
1162     if (is_dominator(proj_true, region-&gt;in(i))) {
1163       continue;
1164     }
1165     if (is_dominator(proj_false, region-&gt;in(i))) {
1166       continue;
1167     }
1168     return false;
1169   }
1170 
1171   return true;
1172 }
1173 
1174 
1175 bool PhaseIdealLoop::can_split_if(Node* n_ctrl) {
1176   if (must_throttle_split_if()) {
1177     return false;
1178   }
1179 
1180   // Do not do &#39;split-if&#39; if irreducible loops are present.
1181   if (_has_irreducible_loops) {
1182     return false;
1183   }
1184 
1185   if (merge_point_too_heavy(C, n_ctrl)) {
1186     return false;
1187   }
1188 
1189   // Do not do &#39;split-if&#39; if some paths are dead.  First do dead code
1190   // elimination and then see if its still profitable.
1191   for (uint i = 1; i &lt; n_ctrl-&gt;req(); i++) {
1192     if (n_ctrl-&gt;in(i) == C-&gt;top()) {
1193       return false;
1194     }
1195   }
1196 
1197   // If trying to do a &#39;Split-If&#39; at the loop head, it is only
1198   // profitable if the cmp folds up on BOTH paths.  Otherwise we
1199   // risk peeling a loop forever.
1200 
1201   // CNC - Disabled for now.  Requires careful handling of loop
1202   // body selection for the cloned code.  Also, make sure we check
1203   // for any input path not being in the same loop as n_ctrl.  For
1204   // irreducible loops we cannot check for &#39;n_ctrl-&gt;is_Loop()&#39;
1205   // because the alternative loop entry points won&#39;t be converted
1206   // into LoopNodes.
1207   IdealLoopTree *n_loop = get_loop(n_ctrl);
1208   for (uint j = 1; j &lt; n_ctrl-&gt;req(); j++) {
1209     if (get_loop(n_ctrl-&gt;in(j)) != n_loop) {
1210       return false;
1211     }
1212   }
1213 
1214   // Check for safety of the merge point.
1215   if (!merge_point_safe(n_ctrl)) {
1216     return false;
1217   }
1218 
1219   return true;
1220 }
1221 
1222 // Detect if the node is the inner strip-mined loop
1223 // Return: NULL if it&#39;s not the case, or the exit of outer strip-mined loop
1224 static Node* is_inner_of_stripmined_loop(const Node* out) {
1225   Node* out_le = NULL;
1226 
1227   if (out-&gt;is_CountedLoopEnd()) {
1228       const CountedLoopNode* loop = out-&gt;as_CountedLoopEnd()-&gt;loopnode();
1229 
1230       if (loop != NULL &amp;&amp; loop-&gt;is_strip_mined()) {
1231         out_le = loop-&gt;in(LoopNode::EntryControl)-&gt;as_OuterStripMinedLoop()-&gt;outer_loop_exit();
1232       }
1233   }
1234 
1235   return out_le;
1236 }
1237 
1238 //------------------------------split_if_with_blocks_post----------------------
1239 // Do the real work in a non-recursive function.  CFG hackery wants to be
1240 // in the post-order, so it can dirty the I-DOM info and not use the dirtied
1241 // info.
1242 void PhaseIdealLoop::split_if_with_blocks_post(Node *n) {
1243 
1244   // Cloning Cmp through Phi&#39;s involves the split-if transform.
1245   // FastLock is not used by an If
1246   if (n-&gt;is_Cmp() &amp;&amp; !n-&gt;is_FastLock()) {
1247     Node *n_ctrl = get_ctrl(n);
1248     // Determine if the Node has inputs from some local Phi.
1249     // Returns the block to clone thru.
1250     Node *n_blk = has_local_phi_input(n);
1251     if (n_blk != n_ctrl) {
1252       return;
1253     }
1254 
1255     if (!can_split_if(n_ctrl)) {
1256       return;
1257     }
1258 
1259     if (n-&gt;outcnt() != 1) {
1260       return; // Multiple bool&#39;s from 1 compare?
1261     }
1262     Node *bol = n-&gt;unique_out();
1263     assert(bol-&gt;is_Bool(), &quot;expect a bool here&quot;);
1264     if (bol-&gt;outcnt() != 1) {
1265       return;// Multiple branches from 1 compare?
1266     }
1267     Node *iff = bol-&gt;unique_out();
1268 
1269     // Check some safety conditions
1270     if (iff-&gt;is_If()) {        // Classic split-if?
1271       if (iff-&gt;in(0) != n_ctrl) {
1272         return; // Compare must be in same blk as if
1273       }
1274     } else if (iff-&gt;is_CMove()) { // Trying to split-up a CMOVE
1275       // Can&#39;t split CMove with different control edge.
1276       if (iff-&gt;in(0) != NULL &amp;&amp; iff-&gt;in(0) != n_ctrl ) {
1277         return;
1278       }
1279       if (get_ctrl(iff-&gt;in(2)) == n_ctrl ||
1280           get_ctrl(iff-&gt;in(3)) == n_ctrl) {
1281         return;                 // Inputs not yet split-up
1282       }
1283       if (get_loop(n_ctrl) != get_loop(get_ctrl(iff))) {
1284         return;                 // Loop-invar test gates loop-varying CMOVE
1285       }
1286     } else {
1287       return;  // some other kind of node, such as an Allocate
1288     }
1289 
1290     // When is split-if profitable?  Every &#39;win&#39; on means some control flow
1291     // goes dead, so it&#39;s almost always a win.
1292     int policy = 0;
1293     // Split compare &#39;n&#39; through the merge point if it is profitable
1294     Node *phi = split_thru_phi( n, n_ctrl, policy);
1295     if (!phi) {
1296       return;
1297     }
1298 
1299     // Found a Phi to split thru!
1300     // Replace &#39;n&#39; with the new phi
1301     _igvn.replace_node(n, phi);
1302 
1303     // Now split the bool up thru the phi
1304     Node *bolphi = split_thru_phi(bol, n_ctrl, -1);
1305     guarantee(bolphi != NULL, &quot;null boolean phi node&quot;);
1306 
1307     _igvn.replace_node(bol, bolphi);
1308     assert(iff-&gt;in(1) == bolphi, &quot;&quot;);
1309 
1310     if (bolphi-&gt;Value(&amp;_igvn)-&gt;singleton()) {
1311       return;
1312     }
1313 
1314     // Conditional-move?  Must split up now
1315     if (!iff-&gt;is_If()) {
1316       Node *cmovphi = split_thru_phi(iff, n_ctrl, -1);
1317       _igvn.replace_node(iff, cmovphi);
1318       return;
1319     }
1320 
1321     // Now split the IF
1322     do_split_if(iff);
1323     return;
1324   }
1325 
1326   // Two identical ifs back to back can be merged
1327   if (identical_backtoback_ifs(n) &amp;&amp; can_split_if(n-&gt;in(0))) {
1328     Node *n_ctrl = n-&gt;in(0);
1329     PhiNode* bolphi = PhiNode::make_blank(n_ctrl, n-&gt;in(1));
1330     IfNode* dom_if = idom(n_ctrl)-&gt;as_If();
1331     Node* proj_true = dom_if-&gt;proj_out(1);
1332     Node* proj_false = dom_if-&gt;proj_out(0);
1333     Node* con_true = _igvn.makecon(TypeInt::ONE);
1334     Node* con_false = _igvn.makecon(TypeInt::ZERO);
1335 
1336     for (uint i = 1; i &lt; n_ctrl-&gt;req(); i++) {
1337       if (is_dominator(proj_true, n_ctrl-&gt;in(i))) {
1338         bolphi-&gt;init_req(i, con_true);
1339       } else {
1340         assert(is_dominator(proj_false, n_ctrl-&gt;in(i)), &quot;bad if&quot;);
1341         bolphi-&gt;init_req(i, con_false);
1342       }
1343     }
1344     register_new_node(bolphi, n_ctrl);
1345     _igvn.replace_input_of(n, 1, bolphi);
1346 
1347     // Now split the IF
1348     do_split_if(n);
1349     return;
1350   }
1351 
1352   // Check for an IF ready to split; one that has its
1353   // condition codes input coming from a Phi at the block start.
1354   int n_op = n-&gt;Opcode();
1355 
1356   // Check for an IF being dominated by another IF same test
1357   if (n_op == Op_If ||
1358       n_op == Op_RangeCheck) {
1359     Node *bol = n-&gt;in(1);
1360     uint max = bol-&gt;outcnt();
1361     // Check for same test used more than once?
1362     if (max &gt; 1 &amp;&amp; bol-&gt;is_Bool()) {
1363       // Search up IDOMs to see if this IF is dominated.
1364       Node *cutoff = get_ctrl(bol);
1365 
1366       // Now search up IDOMs till cutoff, looking for a dominating test
1367       Node *prevdom = n;
1368       Node *dom = idom(prevdom);
1369       while (dom != cutoff) {
1370         if (dom-&gt;req() &gt; 1 &amp;&amp; dom-&gt;in(1) == bol &amp;&amp; prevdom-&gt;in(0) == dom) {
1371           // It&#39;s invalid to move control dependent data nodes in the inner
1372           // strip-mined loop, because:
1373           //  1) break validation of LoopNode::verify_strip_mined()
1374           //  2) move code with side-effect in strip-mined loop
1375           // Move to the exit of outer strip-mined loop in that case.
1376           Node* out_le = is_inner_of_stripmined_loop(dom);
1377           if (out_le != NULL) {
1378             prevdom = out_le;
1379           }
1380           // Replace the dominated test with an obvious true or false.
1381           // Place it on the IGVN worklist for later cleanup.
1382           C-&gt;set_major_progress();
1383           dominated_by(prevdom, n, false, true);
1384 #ifndef PRODUCT
1385           if( VerifyLoopOptimizations ) verify();
1386 #endif
1387           return;
1388         }
1389         prevdom = dom;
1390         dom = idom(prevdom);
1391       }
1392     }
1393   }
1394 
1395   // See if a shared loop-varying computation has no loop-varying uses.
1396   // Happens if something is only used for JVM state in uncommon trap exits,
1397   // like various versions of induction variable+offset.  Clone the
1398   // computation per usage to allow it to sink out of the loop.
1399   if (has_ctrl(n) &amp;&amp; !n-&gt;in(0)) {// n not dead and has no control edge (can float about)
1400     Node *n_ctrl = get_ctrl(n);
1401     IdealLoopTree *n_loop = get_loop(n_ctrl);
1402     if( n_loop != _ltree_root ) {
1403       DUIterator_Fast imax, i = n-&gt;fast_outs(imax);
1404       for (; i &lt; imax; i++) {
1405         Node* u = n-&gt;fast_out(i);
1406         if( !has_ctrl(u) )     break; // Found control user
1407         IdealLoopTree *u_loop = get_loop(get_ctrl(u));
1408         if( u_loop == n_loop ) break; // Found loop-varying use
1409         if( n_loop-&gt;is_member( u_loop ) ) break; // Found use in inner loop
1410         if( u-&gt;Opcode() == Op_Opaque1 ) break; // Found loop limit, bugfix for 4677003
1411       }
1412       bool did_break = (i &lt; imax);  // Did we break out of the previous loop?
1413       if (!did_break &amp;&amp; n-&gt;outcnt() &gt; 1) { // All uses in outer loops!
1414         Node *late_load_ctrl = NULL;
1415         if (n-&gt;is_Load()) {
1416           // If n is a load, get and save the result from get_late_ctrl(),
1417           // to be later used in calculating the control for n&#39;s clones.
1418           clear_dom_lca_tags();
1419           late_load_ctrl = get_late_ctrl(n, n_ctrl);
1420         }
1421         // If n is a load, and the late control is the same as the current
1422         // control, then the cloning of n is a pointless exercise, because
1423         // GVN will ensure that we end up where we started.
1424         if (!n-&gt;is_Load() || late_load_ctrl != n_ctrl) {
1425           for (DUIterator_Last jmin, j = n-&gt;last_outs(jmin); j &gt;= jmin; ) {
1426             Node *u = n-&gt;last_out(j); // Clone private computation per use
1427             _igvn.rehash_node_delayed(u);
1428             Node *x = n-&gt;clone(); // Clone computation
1429             Node *x_ctrl = NULL;
1430             if( u-&gt;is_Phi() ) {
1431               // Replace all uses of normal nodes.  Replace Phi uses
1432               // individually, so the separate Nodes can sink down
1433               // different paths.
1434               uint k = 1;
1435               while( u-&gt;in(k) != n ) k++;
1436               u-&gt;set_req( k, x );
1437               // x goes next to Phi input path
1438               x_ctrl = u-&gt;in(0)-&gt;in(k);
1439               --j;
1440             } else {              // Normal use
1441               // Replace all uses
1442               for( uint k = 0; k &lt; u-&gt;req(); k++ ) {
1443                 if( u-&gt;in(k) == n ) {
1444                   u-&gt;set_req( k, x );
1445                   --j;
1446                 }
1447               }
1448               x_ctrl = get_ctrl(u);
1449             }
1450 
1451             // Find control for &#39;x&#39; next to use but not inside inner loops.
1452             // For inner loop uses get the preheader area.
1453             x_ctrl = place_near_use(x_ctrl);
1454 
1455             if (n-&gt;is_Load()) {
1456               // For loads, add a control edge to a CFG node outside of the loop
1457               // to force them to not combine and return back inside the loop
1458               // during GVN optimization (4641526).
1459               //
1460               // Because we are setting the actual control input, factor in
1461               // the result from get_late_ctrl() so we respect any
1462               // anti-dependences. (6233005).
1463               x_ctrl = dom_lca(late_load_ctrl, x_ctrl);
1464 
1465               // Don&#39;t allow the control input to be a CFG splitting node.
1466               // Such nodes should only have ProjNodes as outs, e.g. IfNode
1467               // should only have IfTrueNode and IfFalseNode (4985384).
1468               x_ctrl = find_non_split_ctrl(x_ctrl);
1469 
1470               IdealLoopTree* x_loop = get_loop(x_ctrl);
1471               Node* x_head = x_loop-&gt;_head;
1472               if (x_head-&gt;is_Loop() &amp;&amp; (x_head-&gt;is_OuterStripMinedLoop() || x_head-&gt;as_Loop()-&gt;is_strip_mined()) &amp;&amp; is_dominator(n_ctrl, x_head)) {
1473                 // Anti dependence analysis is sometimes too
1474                 // conservative: a store in the outer strip mined loop
1475                 // can prevent a load from floating out of the outer
1476                 // strip mined loop but the load may not be referenced
1477                 // from the safepoint: loop strip mining verification
1478                 // code reports a problem in that case. Make sure the
1479                 // load is not moved in the outer strip mined loop in
1480                 // that case.
1481                 x_ctrl = x_head-&gt;as_Loop()-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1482               }
1483               assert(dom_depth(n_ctrl) &lt;= dom_depth(x_ctrl), &quot;n is later than its clone&quot;);
1484 
1485               x-&gt;set_req(0, x_ctrl);
1486             }
1487             register_new_node(x, x_ctrl);
1488 
1489             // Some institutional knowledge is needed here: &#39;x&#39; is
1490             // yanked because if the optimizer runs GVN on it all the
1491             // cloned x&#39;s will common up and undo this optimization and
1492             // be forced back in the loop.
1493             // I tried setting control edges on the x&#39;s to force them to
1494             // not combine, but the matching gets worried when it tries
1495             // to fold a StoreP and an AddP together (as part of an
1496             // address expression) and the AddP and StoreP have
1497             // different controls.
1498             if (!x-&gt;is_Load() &amp;&amp; !x-&gt;is_DecodeNarrowPtr()) _igvn._worklist.yank(x);
1499           }
1500           _igvn.remove_dead_node(n);
1501         }
1502       }
1503     }
1504   }
1505 
1506   try_move_store_after_loop(n);
1507 
1508   // Check for Opaque2&#39;s who&#39;s loop has disappeared - who&#39;s input is in the
1509   // same loop nest as their output.  Remove &#39;em, they are no longer useful.
1510   if( n_op == Op_Opaque2 &amp;&amp;
1511       n-&gt;in(1) != NULL &amp;&amp;
1512       get_loop(get_ctrl(n)) == get_loop(get_ctrl(n-&gt;in(1))) ) {
1513     _igvn.replace_node( n, n-&gt;in(1) );
1514   }
1515 }
1516 
1517 //------------------------------split_if_with_blocks---------------------------
1518 // Check for aggressive application of &#39;split-if&#39; optimization,
1519 // using basic block level info.
1520 void PhaseIdealLoop::split_if_with_blocks(VectorSet &amp;visited, Node_Stack &amp;nstack) {
1521   Node* root = C-&gt;root();
1522   visited.set(root-&gt;_idx); // first, mark root as visited
1523   // Do pre-visit work for root
1524   Node* n   = split_if_with_blocks_pre(root);
1525   uint  cnt = n-&gt;outcnt();
1526   uint  i   = 0;
1527 
1528   while (true) {
1529     // Visit all children
1530     if (i &lt; cnt) {
1531       Node* use = n-&gt;raw_out(i);
1532       ++i;
1533       if (use-&gt;outcnt() != 0 &amp;&amp; !visited.test_set(use-&gt;_idx)) {
1534         // Now do pre-visit work for this use
1535         use = split_if_with_blocks_pre(use);
1536         nstack.push(n, i); // Save parent and next use&#39;s index.
1537         n   = use;         // Process all children of current use.
1538         cnt = use-&gt;outcnt();
1539         i   = 0;
1540       }
1541     }
1542     else {
1543       // All of n&#39;s children have been processed, complete post-processing.
1544       if (cnt != 0 &amp;&amp; !n-&gt;is_Con()) {
1545         assert(has_node(n), &quot;no dead nodes&quot;);
1546         split_if_with_blocks_post(n);
1547       }
1548       if (must_throttle_split_if()) {
1549         nstack.clear();
1550       }
1551       if (nstack.is_empty()) {
1552         // Finished all nodes on stack.
1553         break;
1554       }
1555       // Get saved parent node and next use&#39;s index. Visit the rest of uses.
1556       n   = nstack.node();
1557       cnt = n-&gt;outcnt();
1558       i   = nstack.index();
1559       nstack.pop();
1560     }
1561   }
1562 }
1563 
1564 
1565 //=============================================================================
1566 //
1567 //                   C L O N E   A   L O O P   B O D Y
1568 //
1569 
1570 //------------------------------clone_iff--------------------------------------
1571 // Passed in a Phi merging (recursively) some nearly equivalent Bool/Cmps.
1572 // &quot;Nearly&quot; because all Nodes have been cloned from the original in the loop,
1573 // but the fall-in edges to the Cmp are different.  Clone bool/Cmp pairs
1574 // through the Phi recursively, and return a Bool.
1575 Node* PhaseIdealLoop::clone_iff(PhiNode *phi, IdealLoopTree *loop) {
1576 
1577   // Convert this Phi into a Phi merging Bools
1578   uint i;
1579   for (i = 1; i &lt; phi-&gt;req(); i++) {
1580     Node *b = phi-&gt;in(i);
1581     if (b-&gt;is_Phi()) {
1582       _igvn.replace_input_of(phi, i, clone_iff(b-&gt;as_Phi(), loop));
1583     } else {
1584       assert(b-&gt;is_Bool() || b-&gt;Opcode() == Op_Opaque4, &quot;&quot;);
1585     }
1586   }
1587 
1588   Node* n = phi-&gt;in(1);
1589   Node* sample_opaque = NULL;
1590   Node *sample_bool = NULL;
1591   if (n-&gt;Opcode() == Op_Opaque4) {
1592     sample_opaque = n;
1593     sample_bool = n-&gt;in(1);
1594     assert(sample_bool-&gt;is_Bool(), &quot;wrong type&quot;);
1595   } else {
1596     sample_bool = n;
1597   }
1598   Node *sample_cmp = sample_bool-&gt;in(1);
1599 
1600   // Make Phis to merge the Cmp&#39;s inputs.
1601   PhiNode *phi1 = new PhiNode(phi-&gt;in(0), Type::TOP);
1602   PhiNode *phi2 = new PhiNode(phi-&gt;in(0), Type::TOP);
1603   for (i = 1; i &lt; phi-&gt;req(); i++) {
1604     Node *n1 = sample_opaque == NULL ? phi-&gt;in(i)-&gt;in(1)-&gt;in(1) : phi-&gt;in(i)-&gt;in(1)-&gt;in(1)-&gt;in(1);
1605     Node *n2 = sample_opaque == NULL ? phi-&gt;in(i)-&gt;in(1)-&gt;in(2) : phi-&gt;in(i)-&gt;in(1)-&gt;in(1)-&gt;in(2);
1606     phi1-&gt;set_req(i, n1);
1607     phi2-&gt;set_req(i, n2);
1608     phi1-&gt;set_type(phi1-&gt;type()-&gt;meet_speculative(n1-&gt;bottom_type()));
1609     phi2-&gt;set_type(phi2-&gt;type()-&gt;meet_speculative(n2-&gt;bottom_type()));
1610   }
1611   // See if these Phis have been made before.
1612   // Register with optimizer
1613   Node *hit1 = _igvn.hash_find_insert(phi1);
1614   if (hit1) {                   // Hit, toss just made Phi
1615     _igvn.remove_dead_node(phi1); // Remove new phi
1616     assert(hit1-&gt;is_Phi(), &quot;&quot; );
1617     phi1 = (PhiNode*)hit1;      // Use existing phi
1618   } else {                      // Miss
1619     _igvn.register_new_node_with_optimizer(phi1);
1620   }
1621   Node *hit2 = _igvn.hash_find_insert(phi2);
1622   if (hit2) {                   // Hit, toss just made Phi
1623     _igvn.remove_dead_node(phi2); // Remove new phi
1624     assert(hit2-&gt;is_Phi(), &quot;&quot; );
1625     phi2 = (PhiNode*)hit2;      // Use existing phi
1626   } else {                      // Miss
1627     _igvn.register_new_node_with_optimizer(phi2);
1628   }
1629   // Register Phis with loop/block info
1630   set_ctrl(phi1, phi-&gt;in(0));
1631   set_ctrl(phi2, phi-&gt;in(0));
1632   // Make a new Cmp
1633   Node *cmp = sample_cmp-&gt;clone();
1634   cmp-&gt;set_req(1, phi1);
1635   cmp-&gt;set_req(2, phi2);
1636   _igvn.register_new_node_with_optimizer(cmp);
1637   set_ctrl(cmp, phi-&gt;in(0));
1638 
1639   // Make a new Bool
1640   Node *b = sample_bool-&gt;clone();
1641   b-&gt;set_req(1,cmp);
1642   _igvn.register_new_node_with_optimizer(b);
1643   set_ctrl(b, phi-&gt;in(0));
1644 
1645   if (sample_opaque != NULL) {
1646     Node* opaque = sample_opaque-&gt;clone();
1647     opaque-&gt;set_req(1, b);
1648     _igvn.register_new_node_with_optimizer(opaque);
1649     set_ctrl(opaque, phi-&gt;in(0));
1650     return opaque;
1651   }
1652 
1653   assert(b-&gt;is_Bool(), &quot;&quot;);
1654   return b;
1655 }
1656 
1657 //------------------------------clone_bool-------------------------------------
1658 // Passed in a Phi merging (recursively) some nearly equivalent Bool/Cmps.
1659 // &quot;Nearly&quot; because all Nodes have been cloned from the original in the loop,
1660 // but the fall-in edges to the Cmp are different.  Clone bool/Cmp pairs
1661 // through the Phi recursively, and return a Bool.
1662 CmpNode *PhaseIdealLoop::clone_bool( PhiNode *phi, IdealLoopTree *loop ) {
1663   uint i;
1664   // Convert this Phi into a Phi merging Bools
1665   for( i = 1; i &lt; phi-&gt;req(); i++ ) {
1666     Node *b = phi-&gt;in(i);
1667     if( b-&gt;is_Phi() ) {
1668       _igvn.replace_input_of(phi, i, clone_bool( b-&gt;as_Phi(), loop ));
1669     } else {
1670       assert( b-&gt;is_Cmp() || b-&gt;is_top(), &quot;inputs are all Cmp or TOP&quot; );
1671     }
1672   }
1673 
1674   Node *sample_cmp = phi-&gt;in(1);
1675 
1676   // Make Phis to merge the Cmp&#39;s inputs.
1677   PhiNode *phi1 = new PhiNode( phi-&gt;in(0), Type::TOP );
1678   PhiNode *phi2 = new PhiNode( phi-&gt;in(0), Type::TOP );
1679   for( uint j = 1; j &lt; phi-&gt;req(); j++ ) {
1680     Node *cmp_top = phi-&gt;in(j); // Inputs are all Cmp or TOP
1681     Node *n1, *n2;
1682     if( cmp_top-&gt;is_Cmp() ) {
1683       n1 = cmp_top-&gt;in(1);
1684       n2 = cmp_top-&gt;in(2);
1685     } else {
1686       n1 = n2 = cmp_top;
1687     }
1688     phi1-&gt;set_req( j, n1 );
1689     phi2-&gt;set_req( j, n2 );
1690     phi1-&gt;set_type(phi1-&gt;type()-&gt;meet_speculative(n1-&gt;bottom_type()));
1691     phi2-&gt;set_type(phi2-&gt;type()-&gt;meet_speculative(n2-&gt;bottom_type()));
1692   }
1693 
1694   // See if these Phis have been made before.
1695   // Register with optimizer
1696   Node *hit1 = _igvn.hash_find_insert(phi1);
1697   if( hit1 ) {                  // Hit, toss just made Phi
1698     _igvn.remove_dead_node(phi1); // Remove new phi
1699     assert( hit1-&gt;is_Phi(), &quot;&quot; );
1700     phi1 = (PhiNode*)hit1;      // Use existing phi
1701   } else {                      // Miss
1702     _igvn.register_new_node_with_optimizer(phi1);
1703   }
1704   Node *hit2 = _igvn.hash_find_insert(phi2);
1705   if( hit2 ) {                  // Hit, toss just made Phi
1706     _igvn.remove_dead_node(phi2); // Remove new phi
1707     assert( hit2-&gt;is_Phi(), &quot;&quot; );
1708     phi2 = (PhiNode*)hit2;      // Use existing phi
1709   } else {                      // Miss
1710     _igvn.register_new_node_with_optimizer(phi2);
1711   }
1712   // Register Phis with loop/block info
1713   set_ctrl(phi1, phi-&gt;in(0));
1714   set_ctrl(phi2, phi-&gt;in(0));
1715   // Make a new Cmp
1716   Node *cmp = sample_cmp-&gt;clone();
1717   cmp-&gt;set_req( 1, phi1 );
1718   cmp-&gt;set_req( 2, phi2 );
1719   _igvn.register_new_node_with_optimizer(cmp);
1720   set_ctrl(cmp, phi-&gt;in(0));
1721 
1722   assert( cmp-&gt;is_Cmp(), &quot;&quot; );
1723   return (CmpNode*)cmp;
1724 }
1725 
1726 //------------------------------sink_use---------------------------------------
1727 // If &#39;use&#39; was in the loop-exit block, it now needs to be sunk
1728 // below the post-loop merge point.
1729 void PhaseIdealLoop::sink_use( Node *use, Node *post_loop ) {
1730   if (!use-&gt;is_CFG() &amp;&amp; get_ctrl(use) == post_loop-&gt;in(2)) {
1731     set_ctrl(use, post_loop);
1732     for (DUIterator j = use-&gt;outs(); use-&gt;has_out(j); j++)
1733       sink_use(use-&gt;out(j), post_loop);
1734   }
1735 }
1736 
1737 void PhaseIdealLoop::clone_loop_handle_data_uses(Node* old, Node_List &amp;old_new,
1738                                                  IdealLoopTree* loop, IdealLoopTree* outer_loop,
1739                                                  Node_List*&amp; split_if_set, Node_List*&amp; split_bool_set,
1740                                                  Node_List*&amp; split_cex_set, Node_List&amp; worklist,
1741                                                  uint new_counter, CloneLoopMode mode) {
1742   Node* nnn = old_new[old-&gt;_idx];
1743   // Copy uses to a worklist, so I can munge the def-use info
1744   // with impunity.
1745   for (DUIterator_Fast jmax, j = old-&gt;fast_outs(jmax); j &lt; jmax; j++)
1746     worklist.push(old-&gt;fast_out(j));
1747 
1748   while( worklist.size() ) {
1749     Node *use = worklist.pop();
1750     if (!has_node(use))  continue; // Ignore dead nodes
1751     if (use-&gt;in(0) == C-&gt;top())  continue;
1752     IdealLoopTree *use_loop = get_loop( has_ctrl(use) ? get_ctrl(use) : use );
1753     // Check for data-use outside of loop - at least one of OLD or USE
1754     // must not be a CFG node.
1755 #ifdef ASSERT
1756     if (loop-&gt;_head-&gt;as_Loop()-&gt;is_strip_mined() &amp;&amp; outer_loop-&gt;is_member(use_loop) &amp;&amp; !loop-&gt;is_member(use_loop) &amp;&amp; old_new[use-&gt;_idx] == NULL) {
1757       Node* sfpt = loop-&gt;_head-&gt;as_CountedLoop()-&gt;outer_safepoint();
1758       assert(mode != IgnoreStripMined, &quot;incorrect cloning mode&quot;);
1759       assert((mode == ControlAroundStripMined &amp;&amp; use == sfpt) || !use-&gt;is_reachable_from_root(), &quot;missed a node&quot;);
1760     }
1761 #endif
1762     if (!loop-&gt;is_member(use_loop) &amp;&amp; !outer_loop-&gt;is_member(use_loop) &amp;&amp; (!old-&gt;is_CFG() || !use-&gt;is_CFG())) {
1763 
1764       // If the Data use is an IF, that means we have an IF outside of the
1765       // loop that is switching on a condition that is set inside of the
1766       // loop.  Happens if people set a loop-exit flag; then test the flag
1767       // in the loop to break the loop, then test is again outside of the
1768       // loop to determine which way the loop exited.
1769       // Loop predicate If node connects to Bool node through Opaque1 node.
1770       if (use-&gt;is_If() || use-&gt;is_CMove() || C-&gt;is_predicate_opaq(use) || use-&gt;Opcode() == Op_Opaque4) {
1771         // Since this code is highly unlikely, we lazily build the worklist
1772         // of such Nodes to go split.
1773         if (!split_if_set) {
1774           split_if_set = new Node_List();
1775         }
1776         split_if_set-&gt;push(use);
1777       }
1778       if (use-&gt;is_Bool()) {
1779         if (!split_bool_set) {
1780           split_bool_set = new Node_List();
1781         }
1782         split_bool_set-&gt;push(use);
1783       }
1784       if (use-&gt;Opcode() == Op_CreateEx) {
1785         if (!split_cex_set) {
1786           split_cex_set = new Node_List();
1787         }
1788         split_cex_set-&gt;push(use);
1789       }
1790 
1791 
1792       // Get &quot;block&quot; use is in
1793       uint idx = 0;
1794       while( use-&gt;in(idx) != old ) idx++;
1795       Node *prev = use-&gt;is_CFG() ? use : get_ctrl(use);
1796       assert(!loop-&gt;is_member(get_loop(prev)) &amp;&amp; !outer_loop-&gt;is_member(get_loop(prev)), &quot;&quot; );
1797       Node *cfg = prev-&gt;_idx &gt;= new_counter
1798         ? prev-&gt;in(2)
1799         : idom(prev);
1800       if( use-&gt;is_Phi() )     // Phi use is in prior block
1801         cfg = prev-&gt;in(idx);  // NOT in block of Phi itself
1802       if (cfg-&gt;is_top()) {    // Use is dead?
1803         _igvn.replace_input_of(use, idx, C-&gt;top());
1804         continue;
1805       }
1806 
1807       // If use is referenced through control edge... (idx == 0)
1808       if (mode == IgnoreStripMined &amp;&amp; idx == 0) {
1809         LoopNode *head = loop-&gt;_head-&gt;as_Loop();
1810         if (head-&gt;is_strip_mined() &amp;&amp; is_dominator(head-&gt;outer_loop_exit(), prev)) {
1811           // That node is outside the inner loop, leave it outside the
1812           // outer loop as well to not confuse verification code.
1813           assert(!loop-&gt;_parent-&gt;is_member(use_loop), &quot;should be out of the outer loop&quot;);
1814           _igvn.replace_input_of(use, 0, head-&gt;outer_loop_exit());
1815           continue;
1816         }
1817       }
1818 
1819       while(!outer_loop-&gt;is_member(get_loop(cfg))) {
1820         prev = cfg;
1821         cfg = cfg-&gt;_idx &gt;= new_counter ? cfg-&gt;in(2) : idom(cfg);
1822       }
1823       // If the use occurs after merging several exits from the loop, then
1824       // old value must have dominated all those exits.  Since the same old
1825       // value was used on all those exits we did not need a Phi at this
1826       // merge point.  NOW we do need a Phi here.  Each loop exit value
1827       // is now merged with the peeled body exit; each exit gets its own
1828       // private Phi and those Phis need to be merged here.
1829       Node *phi;
1830       if( prev-&gt;is_Region() ) {
1831         if( idx == 0 ) {      // Updating control edge?
1832           phi = prev;         // Just use existing control
1833         } else {              // Else need a new Phi
1834           phi = PhiNode::make( prev, old );
1835           // Now recursively fix up the new uses of old!
1836           for( uint i = 1; i &lt; prev-&gt;req(); i++ ) {
1837             worklist.push(phi); // Onto worklist once for each &#39;old&#39; input
1838           }
1839         }
1840       } else {
1841         // Get new RegionNode merging old and new loop exits
1842         prev = old_new[prev-&gt;_idx];
1843         assert( prev, &quot;just made this in step 7&quot; );
1844         if( idx == 0) {      // Updating control edge?
1845           phi = prev;         // Just use existing control
1846         } else {              // Else need a new Phi
1847           // Make a new Phi merging data values properly
1848           phi = PhiNode::make( prev, old );
1849           phi-&gt;set_req( 1, nnn );
1850         }
1851       }
1852       // If inserting a new Phi, check for prior hits
1853       if( idx != 0 ) {
1854         Node *hit = _igvn.hash_find_insert(phi);
1855         if( hit == NULL ) {
1856           _igvn.register_new_node_with_optimizer(phi); // Register new phi
1857         } else {                                      // or
1858           // Remove the new phi from the graph and use the hit
1859           _igvn.remove_dead_node(phi);
1860           phi = hit;                                  // Use existing phi
1861         }
1862         set_ctrl(phi, prev);
1863       }
1864       // Make &#39;use&#39; use the Phi instead of the old loop body exit value
1865       _igvn.replace_input_of(use, idx, phi);
1866       if( use-&gt;_idx &gt;= new_counter ) { // If updating new phis
1867         // Not needed for correctness, but prevents a weak assert
1868         // in AddPNode from tripping (when we end up with different
1869         // base &amp; derived Phis that will become the same after
1870         // IGVN does CSE).
1871         Node *hit = _igvn.hash_find_insert(use);
1872         if( hit )             // Go ahead and re-hash for hits.
1873           _igvn.replace_node( use, hit );
1874       }
1875 
1876       // If &#39;use&#39; was in the loop-exit block, it now needs to be sunk
1877       // below the post-loop merge point.
1878       sink_use( use, prev );
1879     }
1880   }
1881 }
1882 
1883 static void clone_outer_loop_helper(Node* n, const IdealLoopTree *loop, const IdealLoopTree* outer_loop,
1884                                     const Node_List &amp;old_new, Unique_Node_List&amp; wq, PhaseIdealLoop* phase,
1885                                     bool check_old_new) {
1886   for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1887     Node* u = n-&gt;fast_out(j);
1888     assert(check_old_new || old_new[u-&gt;_idx] == NULL, &quot;shouldn&#39;t have been cloned&quot;);
1889     if (!u-&gt;is_CFG() &amp;&amp; (!check_old_new || old_new[u-&gt;_idx] == NULL)) {
1890       Node* c = phase-&gt;get_ctrl(u);
1891       IdealLoopTree* u_loop = phase-&gt;get_loop(c);
1892       assert(!loop-&gt;is_member(u_loop), &quot;can be in outer loop or out of both loops only&quot;);
1893       if (outer_loop-&gt;is_member(u_loop)) {
1894         wq.push(u);
1895       }
1896     }
1897   }
1898 }
1899 
1900 void PhaseIdealLoop::clone_outer_loop(LoopNode* head, CloneLoopMode mode, IdealLoopTree *loop,
1901                                       IdealLoopTree* outer_loop, int dd, Node_List &amp;old_new,
1902                                       Node_List&amp; extra_data_nodes) {
1903   if (head-&gt;is_strip_mined() &amp;&amp; mode != IgnoreStripMined) {
1904     CountedLoopNode* cl = head-&gt;as_CountedLoop();
1905     Node* l = cl-&gt;outer_loop();
1906     Node* tail = cl-&gt;outer_loop_tail();
1907     IfNode* le = cl-&gt;outer_loop_end();
1908     Node* sfpt = cl-&gt;outer_safepoint();
1909     CountedLoopEndNode* cle = cl-&gt;loopexit();
1910     CountedLoopNode* new_cl = old_new[cl-&gt;_idx]-&gt;as_CountedLoop();
1911     CountedLoopEndNode* new_cle = new_cl-&gt;as_CountedLoop()-&gt;loopexit_or_null();
1912     Node* cle_out = cle-&gt;proj_out(false);
1913 
1914     Node* new_sfpt = NULL;
1915     Node* new_cle_out = cle_out-&gt;clone();
1916     old_new.map(cle_out-&gt;_idx, new_cle_out);
1917     if (mode == CloneIncludesStripMined) {
1918       // clone outer loop body
1919       Node* new_l = l-&gt;clone();
1920       Node* new_tail = tail-&gt;clone();
1921       IfNode* new_le = le-&gt;clone()-&gt;as_If();
1922       new_sfpt = sfpt-&gt;clone();
1923 
1924       set_loop(new_l, outer_loop-&gt;_parent);
1925       set_idom(new_l, new_l-&gt;in(LoopNode::EntryControl), dd);
1926       set_loop(new_cle_out, outer_loop-&gt;_parent);
1927       set_idom(new_cle_out, new_cle, dd);
1928       set_loop(new_sfpt, outer_loop-&gt;_parent);
1929       set_idom(new_sfpt, new_cle_out, dd);
1930       set_loop(new_le, outer_loop-&gt;_parent);
1931       set_idom(new_le, new_sfpt, dd);
1932       set_loop(new_tail, outer_loop-&gt;_parent);
1933       set_idom(new_tail, new_le, dd);
1934       set_idom(new_cl, new_l, dd);
1935 
1936       old_new.map(l-&gt;_idx, new_l);
1937       old_new.map(tail-&gt;_idx, new_tail);
1938       old_new.map(le-&gt;_idx, new_le);
1939       old_new.map(sfpt-&gt;_idx, new_sfpt);
1940 
1941       new_l-&gt;set_req(LoopNode::LoopBackControl, new_tail);
1942       new_l-&gt;set_req(0, new_l);
1943       new_tail-&gt;set_req(0, new_le);
1944       new_le-&gt;set_req(0, new_sfpt);
1945       new_sfpt-&gt;set_req(0, new_cle_out);
1946       new_cle_out-&gt;set_req(0, new_cle);
1947       new_cl-&gt;set_req(LoopNode::EntryControl, new_l);
1948 
1949       _igvn.register_new_node_with_optimizer(new_l);
1950       _igvn.register_new_node_with_optimizer(new_tail);
1951       _igvn.register_new_node_with_optimizer(new_le);
1952     } else {
1953       Node *newhead = old_new[loop-&gt;_head-&gt;_idx];
1954       newhead-&gt;as_Loop()-&gt;clear_strip_mined();
1955       _igvn.replace_input_of(newhead, LoopNode::EntryControl, newhead-&gt;in(LoopNode::EntryControl)-&gt;in(LoopNode::EntryControl));
1956       set_idom(newhead, newhead-&gt;in(LoopNode::EntryControl), dd);
1957     }
1958     // Look at data node that were assigned a control in the outer
1959     // loop: they are kept in the outer loop by the safepoint so start
1960     // from the safepoint node&#39;s inputs.
1961     IdealLoopTree* outer_loop = get_loop(l);
1962     Node_Stack stack(2);
1963     stack.push(sfpt, 1);
1964     uint new_counter = C-&gt;unique();
1965     while (stack.size() &gt; 0) {
1966       Node* n = stack.node();
1967       uint i = stack.index();
1968       while (i &lt; n-&gt;req() &amp;&amp;
1969              (n-&gt;in(i) == NULL ||
1970               !has_ctrl(n-&gt;in(i)) ||
1971               get_loop(get_ctrl(n-&gt;in(i))) != outer_loop ||
1972               (old_new[n-&gt;in(i)-&gt;_idx] != NULL &amp;&amp; old_new[n-&gt;in(i)-&gt;_idx]-&gt;_idx &gt;= new_counter))) {
1973         i++;
1974       }
1975       if (i &lt; n-&gt;req()) {
1976         stack.set_index(i+1);
1977         stack.push(n-&gt;in(i), 0);
1978       } else {
1979         assert(old_new[n-&gt;_idx] == NULL || n == sfpt || old_new[n-&gt;_idx]-&gt;_idx &lt; new_counter, &quot;no clone yet&quot;);
1980         Node* m = n == sfpt ? new_sfpt : n-&gt;clone();
1981         if (m != NULL) {
1982           for (uint i = 0; i &lt; n-&gt;req(); i++) {
1983             if (m-&gt;in(i) != NULL &amp;&amp; old_new[m-&gt;in(i)-&gt;_idx] != NULL) {
1984               m-&gt;set_req(i, old_new[m-&gt;in(i)-&gt;_idx]);
1985             }
1986           }
1987         } else {
1988           assert(n == sfpt &amp;&amp; mode != CloneIncludesStripMined, &quot;where&#39;s the safepoint clone?&quot;);
1989         }
1990         if (n != sfpt) {
1991           extra_data_nodes.push(n);
1992           _igvn.register_new_node_with_optimizer(m);
1993           assert(get_ctrl(n) == cle_out, &quot;what other control?&quot;);
1994           set_ctrl(m, new_cle_out);
1995           old_new.map(n-&gt;_idx, m);
1996         }
1997         stack.pop();
1998       }
1999     }
2000     if (mode == CloneIncludesStripMined) {
2001       _igvn.register_new_node_with_optimizer(new_sfpt);
2002       _igvn.register_new_node_with_optimizer(new_cle_out);
2003     }
2004     // Some other transformation may have pessimistically assign some
2005     // data nodes to the outer loop. Set their control so they are out
2006     // of the outer loop.
2007     ResourceMark rm;
2008     Unique_Node_List wq;
2009     for (uint i = 0; i &lt; extra_data_nodes.size(); i++) {
2010       Node* old = extra_data_nodes.at(i);
2011       clone_outer_loop_helper(old, loop, outer_loop, old_new, wq, this, true);
2012     }
2013     Node* new_ctrl = cl-&gt;outer_loop_exit();
2014     assert(get_loop(new_ctrl) != outer_loop, &quot;must be out of the loop nest&quot;);
2015     for (uint i = 0; i &lt; wq.size(); i++) {
2016       Node* n = wq.at(i);
2017       set_ctrl(n, new_ctrl);
2018       clone_outer_loop_helper(n, loop, outer_loop, old_new, wq, this, false);
2019     }
2020   } else {
2021     Node *newhead = old_new[loop-&gt;_head-&gt;_idx];
2022     set_idom(newhead, newhead-&gt;in(LoopNode::EntryControl), dd);
2023   }
2024 }
2025 
2026 //------------------------------clone_loop-------------------------------------
2027 //
2028 //                   C L O N E   A   L O O P   B O D Y
2029 //
2030 // This is the basic building block of the loop optimizations.  It clones an
2031 // entire loop body.  It makes an old_new loop body mapping; with this mapping
2032 // you can find the new-loop equivalent to an old-loop node.  All new-loop
2033 // nodes are exactly equal to their old-loop counterparts, all edges are the
2034 // same.  All exits from the old-loop now have a RegionNode that merges the
2035 // equivalent new-loop path.  This is true even for the normal &quot;loop-exit&quot;
2036 // condition.  All uses of loop-invariant old-loop values now come from (one
2037 // or more) Phis that merge their new-loop equivalents.
2038 //
2039 // This operation leaves the graph in an illegal state: there are two valid
2040 // control edges coming from the loop pre-header to both loop bodies.  I&#39;ll
2041 // definitely have to hack the graph after running this transform.
2042 //
2043 // From this building block I will further edit edges to perform loop peeling
2044 // or loop unrolling or iteration splitting (Range-Check-Elimination), etc.
2045 //
2046 // Parameter side_by_size_idom:
2047 //   When side_by_size_idom is NULL, the dominator tree is constructed for
2048 //      the clone loop to dominate the original.  Used in construction of
2049 //      pre-main-post loop sequence.
2050 //   When nonnull, the clone and original are side-by-side, both are
2051 //      dominated by the side_by_side_idom node.  Used in construction of
2052 //      unswitched loops.
2053 void PhaseIdealLoop::clone_loop( IdealLoopTree *loop, Node_List &amp;old_new, int dd,
2054                                 CloneLoopMode mode, Node* side_by_side_idom) {
2055 
2056   LoopNode* head = loop-&gt;_head-&gt;as_Loop();
2057   head-&gt;verify_strip_mined(1);
2058 
2059   if (C-&gt;do_vector_loop() &amp;&amp; PrintOpto) {
2060     const char* mname = C-&gt;method()-&gt;name()-&gt;as_quoted_ascii();
2061     if (mname != NULL) {
2062       tty-&gt;print(&quot;PhaseIdealLoop::clone_loop: for vectorize method %s\n&quot;, mname);
2063     }
2064   }
2065 
2066   CloneMap&amp; cm = C-&gt;clone_map();
2067   Dict* dict = cm.dict();
2068   if (C-&gt;do_vector_loop()) {
2069     cm.set_clone_idx(cm.max_gen()+1);
2070 #ifndef PRODUCT
2071     if (PrintOpto) {
2072       tty-&gt;print_cr(&quot;PhaseIdealLoop::clone_loop: _clone_idx %d&quot;, cm.clone_idx());
2073       loop-&gt;dump_head();
2074     }
2075 #endif
2076   }
2077 
2078   // Step 1: Clone the loop body.  Make the old-&gt;new mapping.
2079   uint i;
2080   for( i = 0; i &lt; loop-&gt;_body.size(); i++ ) {
2081     Node *old = loop-&gt;_body.at(i);
2082     Node *nnn = old-&gt;clone();
2083     old_new.map( old-&gt;_idx, nnn );
2084     if (C-&gt;do_vector_loop()) {
2085       cm.verify_insert_and_clone(old, nnn, cm.clone_idx());
2086     }
2087     _igvn.register_new_node_with_optimizer(nnn);
2088   }
2089 
2090   IdealLoopTree* outer_loop = (head-&gt;is_strip_mined() &amp;&amp; mode != IgnoreStripMined) ? get_loop(head-&gt;as_CountedLoop()-&gt;outer_loop()) : loop;
2091 
2092   // Step 2: Fix the edges in the new body.  If the old input is outside the
2093   // loop use it.  If the old input is INside the loop, use the corresponding
2094   // new node instead.
2095   for( i = 0; i &lt; loop-&gt;_body.size(); i++ ) {
2096     Node *old = loop-&gt;_body.at(i);
2097     Node *nnn = old_new[old-&gt;_idx];
2098     // Fix CFG/Loop controlling the new node
2099     if (has_ctrl(old)) {
2100       set_ctrl(nnn, old_new[get_ctrl(old)-&gt;_idx]);
2101     } else {
2102       set_loop(nnn, outer_loop-&gt;_parent);
2103       if (old-&gt;outcnt() &gt; 0) {
2104         set_idom( nnn, old_new[idom(old)-&gt;_idx], dd );
2105       }
2106     }
2107     // Correct edges to the new node
2108     for( uint j = 0; j &lt; nnn-&gt;req(); j++ ) {
2109         Node *n = nnn-&gt;in(j);
2110         if( n ) {
2111           IdealLoopTree *old_in_loop = get_loop( has_ctrl(n) ? get_ctrl(n) : n );
2112           if( loop-&gt;is_member( old_in_loop ) )
2113             nnn-&gt;set_req(j, old_new[n-&gt;_idx]);
2114         }
2115     }
2116     _igvn.hash_find_insert(nnn);
2117   }
2118 
2119   Node_List extra_data_nodes; // data nodes in the outer strip mined loop
2120   clone_outer_loop(head, mode, loop, outer_loop, dd, old_new, extra_data_nodes);
2121 
2122   // Step 3: Now fix control uses.  Loop varying control uses have already
2123   // been fixed up (as part of all input edges in Step 2).  Loop invariant
2124   // control uses must be either an IfFalse or an IfTrue.  Make a merge
2125   // point to merge the old and new IfFalse/IfTrue nodes; make the use
2126   // refer to this.
2127   Node_List worklist;
2128   uint new_counter = C-&gt;unique();
2129   for( i = 0; i &lt; loop-&gt;_body.size(); i++ ) {
2130     Node* old = loop-&gt;_body.at(i);
2131     if( !old-&gt;is_CFG() ) continue;
2132 
2133     // Copy uses to a worklist, so I can munge the def-use info
2134     // with impunity.
2135     for (DUIterator_Fast jmax, j = old-&gt;fast_outs(jmax); j &lt; jmax; j++)
2136       worklist.push(old-&gt;fast_out(j));
2137 
2138     while( worklist.size() ) {  // Visit all uses
2139       Node *use = worklist.pop();
2140       if (!has_node(use))  continue; // Ignore dead nodes
2141       IdealLoopTree *use_loop = get_loop( has_ctrl(use) ? get_ctrl(use) : use );
2142       if( !loop-&gt;is_member( use_loop ) &amp;&amp; use-&gt;is_CFG() ) {
2143         // Both OLD and USE are CFG nodes here.
2144         assert( use-&gt;is_Proj(), &quot;&quot; );
2145         Node* nnn = old_new[old-&gt;_idx];
2146 
2147         Node* newuse = NULL;
2148         if (head-&gt;is_strip_mined() &amp;&amp; mode != IgnoreStripMined) {
2149           CountedLoopNode* cl = head-&gt;as_CountedLoop();
2150           CountedLoopEndNode* cle = cl-&gt;loopexit();
2151           Node* cle_out = cle-&gt;proj_out_or_null(false);
2152           if (use == cle_out) {
2153             IfNode* le = cl-&gt;outer_loop_end();
2154             use = le-&gt;proj_out(false);
2155             use_loop = get_loop(use);
2156             if (mode == CloneIncludesStripMined) {
2157               nnn = old_new[le-&gt;_idx];
2158             } else {
2159               newuse = old_new[cle_out-&gt;_idx];
2160             }
2161           }
2162         }
2163         if (newuse == NULL) {
2164           newuse = use-&gt;clone();
2165         }
2166 
2167         // Clone the loop exit control projection
2168         if (C-&gt;do_vector_loop()) {
2169           cm.verify_insert_and_clone(use, newuse, cm.clone_idx());
2170         }
2171         newuse-&gt;set_req(0,nnn);
2172         _igvn.register_new_node_with_optimizer(newuse);
2173         set_loop(newuse, use_loop);
2174         set_idom(newuse, nnn, dom_depth(nnn) + 1 );
2175 
2176         // We need a Region to merge the exit from the peeled body and the
2177         // exit from the old loop body.
2178         RegionNode *r = new RegionNode(3);
2179         // Map the old use to the new merge point
2180         old_new.map( use-&gt;_idx, r );
2181         uint dd_r = MIN2(dom_depth(newuse),dom_depth(use));
2182         assert( dd_r &gt;= dom_depth(dom_lca(newuse,use)), &quot;&quot; );
2183 
2184         // The original user of &#39;use&#39; uses &#39;r&#39; instead.
2185         for (DUIterator_Last lmin, l = use-&gt;last_outs(lmin); l &gt;= lmin;) {
2186           Node* useuse = use-&gt;last_out(l);
2187           _igvn.rehash_node_delayed(useuse);
2188           uint uses_found = 0;
2189           if( useuse-&gt;in(0) == use ) {
2190             useuse-&gt;set_req(0, r);
2191             uses_found++;
2192             if( useuse-&gt;is_CFG() ) {
2193               // This is not a dom_depth &gt; dd_r because when new
2194               // control flow is constructed by a loop opt, a node and
2195               // its dominator can end up at the same dom_depth
2196               assert(dom_depth(useuse) &gt;= dd_r, &quot;&quot;);
2197               set_idom(useuse, r, dom_depth(useuse));
2198             }
2199           }
2200           for( uint k = 1; k &lt; useuse-&gt;req(); k++ ) {
2201             if( useuse-&gt;in(k) == use ) {
2202               useuse-&gt;set_req(k, r);
2203               uses_found++;
2204               if (useuse-&gt;is_Loop() &amp;&amp; k == LoopNode::EntryControl) {
2205                 // This is not a dom_depth &gt; dd_r because when new
2206                 // control flow is constructed by a loop opt, a node
2207                 // and its dominator can end up at the same dom_depth
2208                 assert(dom_depth(useuse) &gt;= dd_r , &quot;&quot;);
2209                 set_idom(useuse, r, dom_depth(useuse));
2210               }
2211             }
2212           }
2213           l -= uses_found;    // we deleted 1 or more copies of this edge
2214         }
2215 
2216         // Now finish up &#39;r&#39;
2217         r-&gt;set_req( 1, newuse );
2218         r-&gt;set_req( 2,    use );
2219         _igvn.register_new_node_with_optimizer(r);
2220         set_loop(r, use_loop);
2221         set_idom(r, !side_by_side_idom ? newuse-&gt;in(0) : side_by_side_idom, dd_r);
2222       } // End of if a loop-exit test
2223     }
2224   }
2225 
2226   // Step 4: If loop-invariant use is not control, it must be dominated by a
2227   // loop exit IfFalse/IfTrue.  Find &quot;proper&quot; loop exit.  Make a Region
2228   // there if needed.  Make a Phi there merging old and new used values.
2229   Node_List *split_if_set = NULL;
2230   Node_List *split_bool_set = NULL;
2231   Node_List *split_cex_set = NULL;
2232   for( i = 0; i &lt; loop-&gt;_body.size(); i++ ) {
2233     Node* old = loop-&gt;_body.at(i);
2234     clone_loop_handle_data_uses(old, old_new, loop, outer_loop, split_if_set,
2235                                 split_bool_set, split_cex_set, worklist, new_counter,
2236                                 mode);
2237   }
2238 
2239   for (i = 0; i &lt; extra_data_nodes.size(); i++) {
2240     Node* old = extra_data_nodes.at(i);
2241     clone_loop_handle_data_uses(old, old_new, loop, outer_loop, split_if_set,
2242                                 split_bool_set, split_cex_set, worklist, new_counter,
2243                                 mode);
2244   }
2245 
2246   // Check for IFs that need splitting/cloning.  Happens if an IF outside of
2247   // the loop uses a condition set in the loop.  The original IF probably
2248   // takes control from one or more OLD Regions (which in turn get from NEW
2249   // Regions).  In any case, there will be a set of Phis for each merge point
2250   // from the IF up to where the original BOOL def exists the loop.
2251   if (split_if_set) {
2252     while (split_if_set-&gt;size()) {
2253       Node *iff = split_if_set-&gt;pop();
2254       if (iff-&gt;in(1)-&gt;is_Phi()) {
2255         Node *b = clone_iff(iff-&gt;in(1)-&gt;as_Phi(), loop);
2256         _igvn.replace_input_of(iff, 1, b);
2257       }
2258     }
2259   }
2260   if (split_bool_set) {
2261     while (split_bool_set-&gt;size()) {
2262       Node *b = split_bool_set-&gt;pop();
2263       Node *phi = b-&gt;in(1);
2264       assert(phi-&gt;is_Phi(), &quot;&quot;);
2265       CmpNode *cmp = clone_bool((PhiNode*)phi, loop);
2266       _igvn.replace_input_of(b, 1, cmp);
2267     }
2268   }
2269   if (split_cex_set) {
2270     while (split_cex_set-&gt;size()) {
2271       Node *b = split_cex_set-&gt;pop();
2272       assert(b-&gt;in(0)-&gt;is_Region(), &quot;&quot;);
2273       assert(b-&gt;in(1)-&gt;is_Phi(), &quot;&quot;);
2274       assert(b-&gt;in(0)-&gt;in(0) == b-&gt;in(1)-&gt;in(0), &quot;&quot;);
2275       split_up(b, b-&gt;in(0), NULL);
2276     }
2277   }
2278 
2279 }
2280 
2281 
2282 //---------------------- stride_of_possible_iv -------------------------------------
2283 // Looks for an iff/bool/comp with one operand of the compare
2284 // being a cycle involving an add and a phi,
2285 // with an optional truncation (left-shift followed by a right-shift)
2286 // of the add. Returns zero if not an iv.
2287 int PhaseIdealLoop::stride_of_possible_iv(Node* iff) {
2288   Node* trunc1 = NULL;
2289   Node* trunc2 = NULL;
2290   const TypeInt* ttype = NULL;
2291   if (!iff-&gt;is_If() || iff-&gt;in(1) == NULL || !iff-&gt;in(1)-&gt;is_Bool()) {
2292     return 0;
2293   }
2294   BoolNode* bl = iff-&gt;in(1)-&gt;as_Bool();
2295   Node* cmp = bl-&gt;in(1);
2296   if (!cmp || (cmp-&gt;Opcode() != Op_CmpI &amp;&amp; cmp-&gt;Opcode() != Op_CmpU)) {
2297     return 0;
2298   }
2299   // Must have an invariant operand
2300   if (is_member(get_loop(iff), get_ctrl(cmp-&gt;in(2)))) {
2301     return 0;
2302   }
2303   Node* add2 = NULL;
2304   Node* cmp1 = cmp-&gt;in(1);
2305   if (cmp1-&gt;is_Phi()) {
2306     // (If (Bool (CmpX phi:(Phi ...(Optional-trunc(AddI phi add2))) )))
2307     Node* phi = cmp1;
2308     for (uint i = 1; i &lt; phi-&gt;req(); i++) {
2309       Node* in = phi-&gt;in(i);
2310       Node* add = CountedLoopNode::match_incr_with_optional_truncation(in,
2311                                 &amp;trunc1, &amp;trunc2, &amp;ttype);
2312       if (add &amp;&amp; add-&gt;in(1) == phi) {
2313         add2 = add-&gt;in(2);
2314         break;
2315       }
2316     }
2317   } else {
2318     // (If (Bool (CmpX addtrunc:(Optional-trunc((AddI (Phi ...addtrunc...) add2)) )))
2319     Node* addtrunc = cmp1;
2320     Node* add = CountedLoopNode::match_incr_with_optional_truncation(addtrunc,
2321                                 &amp;trunc1, &amp;trunc2, &amp;ttype);
2322     if (add &amp;&amp; add-&gt;in(1)-&gt;is_Phi()) {
2323       Node* phi = add-&gt;in(1);
2324       for (uint i = 1; i &lt; phi-&gt;req(); i++) {
2325         if (phi-&gt;in(i) == addtrunc) {
2326           add2 = add-&gt;in(2);
2327           break;
2328         }
2329       }
2330     }
2331   }
2332   if (add2 != NULL) {
2333     const TypeInt* add2t = _igvn.type(add2)-&gt;is_int();
2334     if (add2t-&gt;is_con()) {
2335       return add2t-&gt;get_con();
2336     }
2337   }
2338   return 0;
2339 }
2340 
2341 
2342 //---------------------- stay_in_loop -------------------------------------
2343 // Return the (unique) control output node that&#39;s in the loop (if it exists.)
2344 Node* PhaseIdealLoop::stay_in_loop( Node* n, IdealLoopTree *loop) {
2345   Node* unique = NULL;
2346   if (!n) return NULL;
2347   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2348     Node* use = n-&gt;fast_out(i);
2349     if (!has_ctrl(use) &amp;&amp; loop-&gt;is_member(get_loop(use))) {
2350       if (unique != NULL) {
2351         return NULL;
2352       }
2353       unique = use;
2354     }
2355   }
2356   return unique;
2357 }
2358 
2359 //------------------------------ register_node -------------------------------------
2360 // Utility to register node &quot;n&quot; with PhaseIdealLoop
2361 void PhaseIdealLoop::register_node(Node* n, IdealLoopTree *loop, Node* pred, int ddepth) {
2362   _igvn.register_new_node_with_optimizer(n);
2363   loop-&gt;_body.push(n);
2364   if (n-&gt;is_CFG()) {
2365     set_loop(n, loop);
2366     set_idom(n, pred, ddepth);
2367   } else {
2368     set_ctrl(n, pred);
2369   }
2370 }
2371 
2372 //------------------------------ proj_clone -------------------------------------
2373 // Utility to create an if-projection
2374 ProjNode* PhaseIdealLoop::proj_clone(ProjNode* p, IfNode* iff) {
2375   ProjNode* c = p-&gt;clone()-&gt;as_Proj();
2376   c-&gt;set_req(0, iff);
2377   return c;
2378 }
2379 
2380 //------------------------------ short_circuit_if -------------------------------------
2381 // Force the iff control output to be the live_proj
2382 Node* PhaseIdealLoop::short_circuit_if(IfNode* iff, ProjNode* live_proj) {
2383   guarantee(live_proj != NULL, &quot;null projection&quot;);
2384   int proj_con = live_proj-&gt;_con;
2385   assert(proj_con == 0 || proj_con == 1, &quot;false or true projection&quot;);
2386   Node *con = _igvn.intcon(proj_con);
2387   set_ctrl(con, C-&gt;root());
2388   if (iff) {
2389     iff-&gt;set_req(1, con);
2390   }
2391   return con;
2392 }
2393 
2394 //------------------------------ insert_if_before_proj -------------------------------------
2395 // Insert a new if before an if projection (* - new node)
2396 //
2397 // before
2398 //           if(test)
2399 //           /     \
2400 //          v       v
2401 //    other-proj   proj (arg)
2402 //
2403 // after
2404 //           if(test)
2405 //           /     \
2406 //          /       v
2407 //         |      * proj-clone
2408 //         v          |
2409 //    other-proj      v
2410 //                * new_if(relop(cmp[IU](left,right)))
2411 //                  /  \
2412 //                 v    v
2413 //         * new-proj  proj
2414 //         (returned)
2415 //
2416 ProjNode* PhaseIdealLoop::insert_if_before_proj(Node* left, bool Signed, BoolTest::mask relop, Node* right, ProjNode* proj) {
2417   IfNode* iff = proj-&gt;in(0)-&gt;as_If();
2418   IdealLoopTree *loop = get_loop(proj);
2419   ProjNode *other_proj = iff-&gt;proj_out(!proj-&gt;is_IfTrue())-&gt;as_Proj();
2420   int ddepth = dom_depth(proj);
2421 
2422   _igvn.rehash_node_delayed(iff);
2423   _igvn.rehash_node_delayed(proj);
2424 
2425   proj-&gt;set_req(0, NULL);  // temporary disconnect
2426   ProjNode* proj2 = proj_clone(proj, iff);
2427   register_node(proj2, loop, iff, ddepth);
2428 
2429   Node* cmp = Signed ? (Node*) new CmpINode(left, right) : (Node*) new CmpUNode(left, right);
2430   register_node(cmp, loop, proj2, ddepth);
2431 
2432   BoolNode* bol = new BoolNode(cmp, relop);
2433   register_node(bol, loop, proj2, ddepth);
2434 
2435   int opcode = iff-&gt;Opcode();
2436   assert(opcode == Op_If || opcode == Op_RangeCheck, &quot;unexpected opcode&quot;);
2437   IfNode* new_if = (opcode == Op_If) ? new IfNode(proj2, bol, iff-&gt;_prob, iff-&gt;_fcnt):
2438     new RangeCheckNode(proj2, bol, iff-&gt;_prob, iff-&gt;_fcnt);
2439   register_node(new_if, loop, proj2, ddepth);
2440 
2441   proj-&gt;set_req(0, new_if); // reattach
2442   set_idom(proj, new_if, ddepth);
2443 
2444   ProjNode* new_exit = proj_clone(other_proj, new_if)-&gt;as_Proj();
2445   guarantee(new_exit != NULL, &quot;null exit node&quot;);
2446   register_node(new_exit, get_loop(other_proj), new_if, ddepth);
2447 
2448   return new_exit;
2449 }
2450 
2451 //------------------------------ insert_region_before_proj -------------------------------------
2452 // Insert a region before an if projection (* - new node)
2453 //
2454 // before
2455 //           if(test)
2456 //          /      |
2457 //         v       |
2458 //       proj      v
2459 //               other-proj
2460 //
2461 // after
2462 //           if(test)
2463 //          /      |
2464 //         v       |
2465 // * proj-clone    v
2466 //         |     other-proj
2467 //         v
2468 // * new-region
2469 //         |
2470 //         v
2471 // *      dum_if
2472 //       /     \
2473 //      v       \
2474 // * dum-proj    v
2475 //              proj
2476 //
2477 RegionNode* PhaseIdealLoop::insert_region_before_proj(ProjNode* proj) {
2478   IfNode* iff = proj-&gt;in(0)-&gt;as_If();
2479   IdealLoopTree *loop = get_loop(proj);
2480   ProjNode *other_proj = iff-&gt;proj_out(!proj-&gt;is_IfTrue())-&gt;as_Proj();
2481   int ddepth = dom_depth(proj);
2482 
2483   _igvn.rehash_node_delayed(iff);
2484   _igvn.rehash_node_delayed(proj);
2485 
2486   proj-&gt;set_req(0, NULL);  // temporary disconnect
2487   ProjNode* proj2 = proj_clone(proj, iff);
2488   register_node(proj2, loop, iff, ddepth);
2489 
2490   RegionNode* reg = new RegionNode(2);
2491   reg-&gt;set_req(1, proj2);
2492   register_node(reg, loop, iff, ddepth);
2493 
2494   IfNode* dum_if = new IfNode(reg, short_circuit_if(NULL, proj), iff-&gt;_prob, iff-&gt;_fcnt);
2495   register_node(dum_if, loop, reg, ddepth);
2496 
2497   proj-&gt;set_req(0, dum_if); // reattach
2498   set_idom(proj, dum_if, ddepth);
2499 
2500   ProjNode* dum_proj = proj_clone(other_proj, dum_if);
2501   register_node(dum_proj, loop, dum_if, ddepth);
2502 
2503   return reg;
2504 }
2505 
2506 //------------------------------ insert_cmpi_loop_exit -------------------------------------
2507 // Clone a signed compare loop exit from an unsigned compare and
2508 // insert it before the unsigned cmp on the stay-in-loop path.
2509 // All new nodes inserted in the dominator tree between the original
2510 // if and it&#39;s projections.  The original if test is replaced with
2511 // a constant to force the stay-in-loop path.
2512 //
2513 // This is done to make sure that the original if and it&#39;s projections
2514 // still dominate the same set of control nodes, that the ctrl() relation
2515 // from data nodes to them is preserved, and that their loop nesting is
2516 // preserved.
2517 //
2518 // before
2519 //          if(i &lt;u limit)    unsigned compare loop exit
2520 //         /       |
2521 //        v        v
2522 //   exit-proj   stay-in-loop-proj
2523 //
2524 // after
2525 //          if(stay-in-loop-const)  original if
2526 //         /       |
2527 //        /        v
2528 //       /  if(i &lt;  limit)    new signed test
2529 //      /  /       |
2530 //     /  /        v
2531 //    /  /  if(i &lt;u limit)    new cloned unsigned test
2532 //   /  /   /      |
2533 //   v  v  v       |
2534 //    region       |
2535 //        |        |
2536 //      dum-if     |
2537 //     /  |        |
2538 // ether  |        |
2539 //        v        v
2540 //   exit-proj   stay-in-loop-proj
2541 //
2542 IfNode* PhaseIdealLoop::insert_cmpi_loop_exit(IfNode* if_cmpu, IdealLoopTree *loop) {
2543   const bool Signed   = true;
2544   const bool Unsigned = false;
2545 
2546   BoolNode* bol = if_cmpu-&gt;in(1)-&gt;as_Bool();
2547   if (bol-&gt;_test._test != BoolTest::lt) return NULL;
2548   CmpNode* cmpu = bol-&gt;in(1)-&gt;as_Cmp();
2549   if (cmpu-&gt;Opcode() != Op_CmpU) return NULL;
2550   int stride = stride_of_possible_iv(if_cmpu);
2551   if (stride == 0) return NULL;
2552 
2553   Node* lp_proj = stay_in_loop(if_cmpu, loop);
2554   guarantee(lp_proj != NULL, &quot;null loop node&quot;);
2555 
2556   ProjNode* lp_continue = lp_proj-&gt;as_Proj();
2557   ProjNode* lp_exit     = if_cmpu-&gt;proj_out(!lp_continue-&gt;is_IfTrue())-&gt;as_Proj();
2558 
2559   Node* limit = NULL;
2560   if (stride &gt; 0) {
2561     limit = cmpu-&gt;in(2);
2562   } else {
2563     limit = _igvn.makecon(TypeInt::ZERO);
2564     set_ctrl(limit, C-&gt;root());
2565   }
2566   // Create a new region on the exit path
2567   RegionNode* reg = insert_region_before_proj(lp_exit);
2568   guarantee(reg != NULL, &quot;null region node&quot;);
2569 
2570   // Clone the if-cmpu-true-false using a signed compare
2571   BoolTest::mask rel_i = stride &gt; 0 ? bol-&gt;_test._test : BoolTest::ge;
2572   ProjNode* cmpi_exit = insert_if_before_proj(cmpu-&gt;in(1), Signed, rel_i, limit, lp_continue);
2573   reg-&gt;add_req(cmpi_exit);
2574 
2575   // Clone the if-cmpu-true-false
2576   BoolTest::mask rel_u = bol-&gt;_test._test;
2577   ProjNode* cmpu_exit = insert_if_before_proj(cmpu-&gt;in(1), Unsigned, rel_u, cmpu-&gt;in(2), lp_continue);
2578   reg-&gt;add_req(cmpu_exit);
2579 
2580   // Force original if to stay in loop.
2581   short_circuit_if(if_cmpu, lp_continue);
2582 
2583   return cmpi_exit-&gt;in(0)-&gt;as_If();
2584 }
2585 
2586 //------------------------------ remove_cmpi_loop_exit -------------------------------------
2587 // Remove a previously inserted signed compare loop exit.
2588 void PhaseIdealLoop::remove_cmpi_loop_exit(IfNode* if_cmp, IdealLoopTree *loop) {
2589   Node* lp_proj = stay_in_loop(if_cmp, loop);
2590   assert(if_cmp-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpI &amp;&amp;
2591          stay_in_loop(lp_proj, loop)-&gt;is_If() &amp;&amp;
2592          stay_in_loop(lp_proj, loop)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpU, &quot;inserted cmpi before cmpu&quot;);
2593   Node *con = _igvn.makecon(lp_proj-&gt;is_IfTrue() ? TypeInt::ONE : TypeInt::ZERO);
2594   set_ctrl(con, C-&gt;root());
2595   if_cmp-&gt;set_req(1, con);
2596 }
2597 
2598 //------------------------------ scheduled_nodelist -------------------------------------
2599 // Create a post order schedule of nodes that are in the
2600 // &quot;member&quot; set.  The list is returned in &quot;sched&quot;.
2601 // The first node in &quot;sched&quot; is the loop head, followed by
2602 // nodes which have no inputs in the &quot;member&quot; set, and then
2603 // followed by the nodes that have an immediate input dependence
2604 // on a node in &quot;sched&quot;.
2605 void PhaseIdealLoop::scheduled_nodelist( IdealLoopTree *loop, VectorSet&amp; member, Node_List &amp;sched ) {
2606 
2607   assert(member.test(loop-&gt;_head-&gt;_idx), &quot;loop head must be in member set&quot;);
2608   VectorSet visited;
2609   Node_Stack nstack(loop-&gt;_body.size());
2610 
2611   Node* n  = loop-&gt;_head;  // top of stack is cached in &quot;n&quot;
2612   uint idx = 0;
2613   visited.set(n-&gt;_idx);
2614 
2615   // Initially push all with no inputs from within member set
2616   for(uint i = 0; i &lt; loop-&gt;_body.size(); i++ ) {
2617     Node *elt = loop-&gt;_body.at(i);
2618     if (member.test(elt-&gt;_idx)) {
2619       bool found = false;
2620       for (uint j = 0; j &lt; elt-&gt;req(); j++) {
2621         Node* def = elt-&gt;in(j);
2622         if (def &amp;&amp; member.test(def-&gt;_idx) &amp;&amp; def != elt) {
2623           found = true;
2624           break;
2625         }
2626       }
2627       if (!found &amp;&amp; elt != loop-&gt;_head) {
2628         nstack.push(n, idx);
2629         n = elt;
2630         assert(!visited.test(n-&gt;_idx), &quot;not seen yet&quot;);
2631         visited.set(n-&gt;_idx);
2632       }
2633     }
2634   }
2635 
2636   // traverse out&#39;s that are in the member set
2637   while (true) {
2638     if (idx &lt; n-&gt;outcnt()) {
2639       Node* use = n-&gt;raw_out(idx);
2640       idx++;
2641       if (!visited.test_set(use-&gt;_idx)) {
2642         if (member.test(use-&gt;_idx)) {
2643           nstack.push(n, idx);
2644           n = use;
2645           idx = 0;
2646         }
2647       }
2648     } else {
2649       // All outputs processed
2650       sched.push(n);
2651       if (nstack.is_empty()) break;
2652       n   = nstack.node();
2653       idx = nstack.index();
2654       nstack.pop();
2655     }
2656   }
2657 }
2658 
2659 
2660 //------------------------------ has_use_in_set -------------------------------------
2661 // Has a use in the vector set
2662 bool PhaseIdealLoop::has_use_in_set( Node* n, VectorSet&amp; vset ) {
2663   for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2664     Node* use = n-&gt;fast_out(j);
2665     if (vset.test(use-&gt;_idx)) {
2666       return true;
2667     }
2668   }
2669   return false;
2670 }
2671 
2672 
2673 //------------------------------ has_use_internal_to_set -------------------------------------
2674 // Has use internal to the vector set (ie. not in a phi at the loop head)
2675 bool PhaseIdealLoop::has_use_internal_to_set( Node* n, VectorSet&amp; vset, IdealLoopTree *loop ) {
2676   Node* head  = loop-&gt;_head;
2677   for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2678     Node* use = n-&gt;fast_out(j);
2679     if (vset.test(use-&gt;_idx) &amp;&amp; !(use-&gt;is_Phi() &amp;&amp; use-&gt;in(0) == head)) {
2680       return true;
2681     }
2682   }
2683   return false;
2684 }
2685 
2686 
2687 //------------------------------ clone_for_use_outside_loop -------------------------------------
2688 // clone &quot;n&quot; for uses that are outside of loop
2689 int PhaseIdealLoop::clone_for_use_outside_loop( IdealLoopTree *loop, Node* n, Node_List&amp; worklist ) {
2690   int cloned = 0;
2691   assert(worklist.size() == 0, &quot;should be empty&quot;);
2692   for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2693     Node* use = n-&gt;fast_out(j);
2694     if( !loop-&gt;is_member(get_loop(has_ctrl(use) ? get_ctrl(use) : use)) ) {
2695       worklist.push(use);
2696     }
2697   }
2698   while( worklist.size() ) {
2699     Node *use = worklist.pop();
2700     if (!has_node(use) || use-&gt;in(0) == C-&gt;top()) continue;
2701     uint j;
2702     for (j = 0; j &lt; use-&gt;req(); j++) {
2703       if (use-&gt;in(j) == n) break;
2704     }
2705     assert(j &lt; use-&gt;req(), &quot;must be there&quot;);
2706 
2707     // clone &quot;n&quot; and insert it between the inputs of &quot;n&quot; and the use outside the loop
2708     Node* n_clone = n-&gt;clone();
2709     _igvn.replace_input_of(use, j, n_clone);
2710     cloned++;
2711     Node* use_c;
2712     if (!use-&gt;is_Phi()) {
2713       use_c = has_ctrl(use) ? get_ctrl(use) : use-&gt;in(0);
2714     } else {
2715       // Use in a phi is considered a use in the associated predecessor block
2716       use_c = use-&gt;in(0)-&gt;in(j);
2717     }
2718     set_ctrl(n_clone, use_c);
2719     assert(!loop-&gt;is_member(get_loop(use_c)), &quot;should be outside loop&quot;);
2720     get_loop(use_c)-&gt;_body.push(n_clone);
2721     _igvn.register_new_node_with_optimizer(n_clone);
2722 #ifndef PRODUCT
2723     if (TracePartialPeeling) {
2724       tty-&gt;print_cr(&quot;loop exit cloning old: %d new: %d newbb: %d&quot;, n-&gt;_idx, n_clone-&gt;_idx, get_ctrl(n_clone)-&gt;_idx);
2725     }
2726 #endif
2727   }
2728   return cloned;
2729 }
2730 
2731 
2732 //------------------------------ clone_for_special_use_inside_loop -------------------------------------
2733 // clone &quot;n&quot; for special uses that are in the not_peeled region.
2734 // If these def-uses occur in separate blocks, the code generator
2735 // marks the method as not compilable.  For example, if a &quot;BoolNode&quot;
2736 // is in a different basic block than the &quot;IfNode&quot; that uses it, then
2737 // the compilation is aborted in the code generator.
2738 void PhaseIdealLoop::clone_for_special_use_inside_loop( IdealLoopTree *loop, Node* n,
2739                                                         VectorSet&amp; not_peel, Node_List&amp; sink_list, Node_List&amp; worklist ) {
2740   if (n-&gt;is_Phi() || n-&gt;is_Load()) {
2741     return;
2742   }
2743   assert(worklist.size() == 0, &quot;should be empty&quot;);
2744   for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2745     Node* use = n-&gt;fast_out(j);
2746     if ( not_peel.test(use-&gt;_idx) &amp;&amp;
2747          (use-&gt;is_If() || use-&gt;is_CMove() || use-&gt;is_Bool()) &amp;&amp;
2748          use-&gt;in(1) == n)  {
2749       worklist.push(use);
2750     }
2751   }
2752   if (worklist.size() &gt; 0) {
2753     // clone &quot;n&quot; and insert it between inputs of &quot;n&quot; and the use
2754     Node* n_clone = n-&gt;clone();
2755     loop-&gt;_body.push(n_clone);
2756     _igvn.register_new_node_with_optimizer(n_clone);
2757     set_ctrl(n_clone, get_ctrl(n));
2758     sink_list.push(n_clone);
2759     not_peel.set(n_clone-&gt;_idx);
2760 #ifndef PRODUCT
2761     if (TracePartialPeeling) {
2762       tty-&gt;print_cr(&quot;special not_peeled cloning old: %d new: %d&quot;, n-&gt;_idx, n_clone-&gt;_idx);
2763     }
2764 #endif
2765     while( worklist.size() ) {
2766       Node *use = worklist.pop();
2767       _igvn.rehash_node_delayed(use);
2768       for (uint j = 1; j &lt; use-&gt;req(); j++) {
2769         if (use-&gt;in(j) == n) {
2770           use-&gt;set_req(j, n_clone);
2771         }
2772       }
2773     }
2774   }
2775 }
2776 
2777 
2778 //------------------------------ insert_phi_for_loop -------------------------------------
2779 // Insert phi(lp_entry_val, back_edge_val) at use-&gt;in(idx) for loop lp if phi does not already exist
2780 void PhaseIdealLoop::insert_phi_for_loop( Node* use, uint idx, Node* lp_entry_val, Node* back_edge_val, LoopNode* lp ) {
2781   Node *phi = PhiNode::make(lp, back_edge_val);
2782   phi-&gt;set_req(LoopNode::EntryControl, lp_entry_val);
2783   // Use existing phi if it already exists
2784   Node *hit = _igvn.hash_find_insert(phi);
2785   if( hit == NULL ) {
2786     _igvn.register_new_node_with_optimizer(phi);
2787     set_ctrl(phi, lp);
2788   } else {
2789     // Remove the new phi from the graph and use the hit
2790     _igvn.remove_dead_node(phi);
2791     phi = hit;
2792   }
2793   _igvn.replace_input_of(use, idx, phi);
2794 }
2795 
2796 #ifdef ASSERT
2797 //------------------------------ is_valid_loop_partition -------------------------------------
2798 // Validate the loop partition sets: peel and not_peel
2799 bool PhaseIdealLoop::is_valid_loop_partition( IdealLoopTree *loop, VectorSet&amp; peel, Node_List&amp; peel_list,
2800                                               VectorSet&amp; not_peel ) {
2801   uint i;
2802   // Check that peel_list entries are in the peel set
2803   for (i = 0; i &lt; peel_list.size(); i++) {
2804     if (!peel.test(peel_list.at(i)-&gt;_idx)) {
2805       return false;
2806     }
2807   }
2808   // Check at loop members are in one of peel set or not_peel set
2809   for (i = 0; i &lt; loop-&gt;_body.size(); i++ ) {
2810     Node *def  = loop-&gt;_body.at(i);
2811     uint di = def-&gt;_idx;
2812     // Check that peel set elements are in peel_list
2813     if (peel.test(di)) {
2814       if (not_peel.test(di)) {
2815         return false;
2816       }
2817       // Must be in peel_list also
2818       bool found = false;
2819       for (uint j = 0; j &lt; peel_list.size(); j++) {
2820         if (peel_list.at(j)-&gt;_idx == di) {
2821           found = true;
2822           break;
2823         }
2824       }
2825       if (!found) {
2826         return false;
2827       }
2828     } else if (not_peel.test(di)) {
2829       if (peel.test(di)) {
2830         return false;
2831       }
2832     } else {
2833       return false;
2834     }
2835   }
2836   return true;
2837 }
2838 
2839 //------------------------------ is_valid_clone_loop_exit_use -------------------------------------
2840 // Ensure a use outside of loop is of the right form
2841 bool PhaseIdealLoop::is_valid_clone_loop_exit_use( IdealLoopTree *loop, Node* use, uint exit_idx) {
2842   Node *use_c = has_ctrl(use) ? get_ctrl(use) : use;
2843   return (use-&gt;is_Phi() &amp;&amp;
2844           use_c-&gt;is_Region() &amp;&amp; use_c-&gt;req() == 3 &amp;&amp;
2845           (use_c-&gt;in(exit_idx)-&gt;Opcode() == Op_IfTrue ||
2846            use_c-&gt;in(exit_idx)-&gt;Opcode() == Op_IfFalse ||
2847            use_c-&gt;in(exit_idx)-&gt;Opcode() == Op_JumpProj) &amp;&amp;
2848           loop-&gt;is_member( get_loop( use_c-&gt;in(exit_idx)-&gt;in(0) ) ) );
2849 }
2850 
2851 //------------------------------ is_valid_clone_loop_form -------------------------------------
2852 // Ensure that all uses outside of loop are of the right form
2853 bool PhaseIdealLoop::is_valid_clone_loop_form( IdealLoopTree *loop, Node_List&amp; peel_list,
2854                                                uint orig_exit_idx, uint clone_exit_idx) {
2855   uint len = peel_list.size();
2856   for (uint i = 0; i &lt; len; i++) {
2857     Node *def = peel_list.at(i);
2858 
2859     for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2860       Node *use = def-&gt;fast_out(j);
2861       Node *use_c = has_ctrl(use) ? get_ctrl(use) : use;
2862       if (!loop-&gt;is_member(get_loop(use_c))) {
2863         // use is not in the loop, check for correct structure
2864         if (use-&gt;in(0) == def) {
2865           // Okay
2866         } else if (!is_valid_clone_loop_exit_use(loop, use, orig_exit_idx)) {
2867           return false;
2868         }
2869       }
2870     }
2871   }
2872   return true;
2873 }
2874 #endif
2875 
2876 //------------------------------ partial_peel -------------------------------------
2877 // Partially peel (aka loop rotation) the top portion of a loop (called
2878 // the peel section below) by cloning it and placing one copy just before
2879 // the new loop head and the other copy at the bottom of the new loop.
2880 //
2881 //    before                       after                where it came from
2882 //
2883 //    stmt1                        stmt1
2884 //  loop:                          stmt2                     clone
2885 //    stmt2                        if condA goto exitA       clone
2886 //    if condA goto exitA        new_loop:                   new
2887 //    stmt3                        stmt3                     clone
2888 //    if !condB goto loop          if condB goto exitB       clone
2889 //  exitB:                         stmt2                     orig
2890 //    stmt4                        if !condA goto new_loop   orig
2891 //  exitA:                         goto exitA
2892 //                               exitB:
2893 //                                 stmt4
2894 //                               exitA:
2895 //
2896 // Step 1: find the cut point: an exit test on probable
2897 //         induction variable.
2898 // Step 2: schedule (with cloning) operations in the peel
2899 //         section that can be executed after the cut into
2900 //         the section that is not peeled.  This may need
2901 //         to clone operations into exit blocks.  For
2902 //         instance, a reference to A[i] in the not-peel
2903 //         section and a reference to B[i] in an exit block
2904 //         may cause a left-shift of i by 2 to be placed
2905 //         in the peel block.  This step will clone the left
2906 //         shift into the exit block and sink the left shift
2907 //         from the peel to the not-peel section.
2908 // Step 3: clone the loop, retarget the control, and insert
2909 //         phis for values that are live across the new loop
2910 //         head.  This is very dependent on the graph structure
2911 //         from clone_loop.  It creates region nodes for
2912 //         exit control and associated phi nodes for values
2913 //         flow out of the loop through that exit.  The region
2914 //         node is dominated by the clone&#39;s control projection.
2915 //         So the clone&#39;s peel section is placed before the
2916 //         new loop head, and the clone&#39;s not-peel section is
2917 //         forms the top part of the new loop.  The original
2918 //         peel section forms the tail of the new loop.
2919 // Step 4: update the dominator tree and recompute the
2920 //         dominator depth.
2921 //
2922 //                   orig
2923 //
2924 //                   stmt1
2925 //                     |
2926 //                     v
2927 //               loop predicate
2928 //                     |
2929 //                     v
2930 //                   loop&lt;----+
2931 //                     |      |
2932 //                   stmt2    |
2933 //                     |      |
2934 //                     v      |
2935 //                    ifA     |
2936 //                   / |      |
2937 //                  v  v      |
2938 //               false true   ^  &lt;-- last_peel
2939 //               /     |      |
2940 //              /   ===|==cut |
2941 //             /     stmt3    |  &lt;-- first_not_peel
2942 //            /        |      |
2943 //            |        v      |
2944 //            v       ifB     |
2945 //          exitA:   / \      |
2946 //                  /   \     |
2947 //                 v     v    |
2948 //               false true   |
2949 //               /       \    |
2950 //              /         ----+
2951 //             |
2952 //             v
2953 //           exitB:
2954 //           stmt4
2955 //
2956 //
2957 //            after clone loop
2958 //
2959 //                   stmt1
2960 //                     |
2961 //                     v
2962 //               loop predicate
2963 //                 /       \
2964 //        clone   /         \   orig
2965 //               /           \
2966 //              /             \
2967 //             v               v
2968 //   +----&gt;loop                loop&lt;----+
2969 //   |      |                    |      |
2970 //   |    stmt2                stmt2    |
2971 //   |      |                    |      |
2972 //   |      v                    v      |
2973 //   |      ifA                 ifA     |
2974 //   |      | \                / |      |
2975 //   |      v  v              v  v      |
2976 //   ^    true  false      false true   ^  &lt;-- last_peel
2977 //   |      |   ^   \       /    |      |
2978 //   | cut==|==  \   \     /  ===|==cut |
2979 //   |    stmt3   \   \   /    stmt3    |  &lt;-- first_not_peel
2980 //   |      |    dom   | |       |      |
2981 //   |      v      \  1v v2      v      |
2982 //   |      ifB     regionA     ifB     |
2983 //   |      / \        |       / \      |
2984 //   |     /   \       v      /   \     |
2985 //   |    v     v    exitA:  v     v    |
2986 //   |    true  false      false true   |
2987 //   |    /     ^   \      /       \    |
2988 //   +----       \   \    /         ----+
2989 //               dom  \  /
2990 //                 \  1v v2
2991 //                  regionB
2992 //                     |
2993 //                     v
2994 //                   exitB:
2995 //                   stmt4
2996 //
2997 //
2998 //           after partial peel
2999 //
3000 //                  stmt1
3001 //                     |
3002 //                     v
3003 //               loop predicate
3004 //                 /
3005 //        clone   /             orig
3006 //               /          TOP
3007 //              /             \
3008 //             v               v
3009 //    TOP-&gt;loop                loop----+
3010 //          |                    |      |
3011 //        stmt2                stmt2    |
3012 //          |                    |      |
3013 //          v                    v      |
3014 //          ifA                 ifA     |
3015 //          | \                / |      |
3016 //          v  v              v  v      |
3017 //        true  false      false true   |     &lt;-- last_peel
3018 //          |   ^   \       /    +------|---+
3019 //  +-&gt;newloop   \   \     /  === ==cut |   |
3020 //  |     stmt3   \   \   /     TOP     |   |
3021 //  |       |    dom   | |      stmt3   |   | &lt;-- first_not_peel
3022 //  |       v      \  1v v2      v      |   |
3023 //  |       ifB     regionA     ifB     ^   v
3024 //  |       / \        |       / \      |   |
3025 //  |      /   \       v      /   \     |   |
3026 //  |     v     v    exitA:  v     v    |   |
3027 //  |     true  false      false true   |   |
3028 //  |     /     ^   \      /       \    |   |
3029 //  |    |       \   \    /         v   |   |
3030 //  |    |       dom  \  /         TOP  |   |
3031 //  |    |         \  1v v2             |   |
3032 //  ^    v          regionB             |   |
3033 //  |    |             |                |   |
3034 //  |    |             v                ^   v
3035 //  |    |           exitB:             |   |
3036 //  |    |           stmt4              |   |
3037 //  |    +------------&gt;-----------------+   |
3038 //  |                                       |
3039 //  +-----------------&lt;---------------------+
3040 //
3041 //
3042 //              final graph
3043 //
3044 //                  stmt1
3045 //                    |
3046 //                    v
3047 //               loop predicate
3048 //                    |
3049 //                    v
3050 //                  stmt2 clone
3051 //                    |
3052 //                    v
3053 //         ........&gt; ifA clone
3054 //         :        / |
3055 //        dom      /  |
3056 //         :      v   v
3057 //         :  false   true
3058 //         :  |       |
3059 //         :  |       v
3060 //         :  |    newloop&lt;-----+
3061 //         :  |        |        |
3062 //         :  |     stmt3 clone |
3063 //         :  |        |        |
3064 //         :  |        v        |
3065 //         :  |       ifB       |
3066 //         :  |      / \        |
3067 //         :  |     v   v       |
3068 //         :  |  false true     |
3069 //         :  |   |     |       |
3070 //         :  |   v    stmt2    |
3071 //         :  | exitB:  |       |
3072 //         :  | stmt4   v       |
3073 //         :  |       ifA orig  |
3074 //         :  |      /  \       |
3075 //         :  |     /    \      |
3076 //         :  |    v     v      |
3077 //         :  |  false  true    |
3078 //         :  |  /        \     |
3079 //         :  v  v         -----+
3080 //          RegionA
3081 //             |
3082 //             v
3083 //           exitA
3084 //
3085 bool PhaseIdealLoop::partial_peel( IdealLoopTree *loop, Node_List &amp;old_new ) {
3086 
3087   assert(!loop-&gt;_head-&gt;is_CountedLoop(), &quot;Non-counted loop only&quot;);
3088   if (!loop-&gt;_head-&gt;is_Loop()) {
3089     return false;
3090   }
3091   LoopNode *head = loop-&gt;_head-&gt;as_Loop();
3092 
3093   if (head-&gt;is_partial_peel_loop() || head-&gt;partial_peel_has_failed()) {
3094     return false;
3095   }
3096 
3097   // Check for complex exit control
3098   for (uint ii = 0; ii &lt; loop-&gt;_body.size(); ii++) {
3099     Node *n = loop-&gt;_body.at(ii);
3100     int opc = n-&gt;Opcode();
3101     if (n-&gt;is_Call()        ||
3102         opc == Op_Catch     ||
3103         opc == Op_CatchProj ||
3104         opc == Op_Jump      ||
3105         opc == Op_JumpProj) {
3106 #ifndef PRODUCT
3107       if (TracePartialPeeling) {
3108         tty-&gt;print_cr(&quot;\nExit control too complex: lp: %d&quot;, head-&gt;_idx);
3109       }
3110 #endif
3111       return false;
3112     }
3113   }
3114 
3115   int dd = dom_depth(head);
3116 
3117   // Step 1: find cut point
3118 
3119   // Walk up dominators to loop head looking for first loop exit
3120   // which is executed on every path thru loop.
3121   IfNode *peel_if = NULL;
3122   IfNode *peel_if_cmpu = NULL;
3123 
3124   Node *iff = loop-&gt;tail();
3125   while (iff != head) {
3126     if (iff-&gt;is_If()) {
3127       Node *ctrl = get_ctrl(iff-&gt;in(1));
3128       if (ctrl-&gt;is_top()) return false; // Dead test on live IF.
3129       // If loop-varying exit-test, check for induction variable
3130       if (loop-&gt;is_member(get_loop(ctrl)) &amp;&amp;
3131           loop-&gt;is_loop_exit(iff) &amp;&amp;
3132           is_possible_iv_test(iff)) {
3133         Node* cmp = iff-&gt;in(1)-&gt;in(1);
3134         if (cmp-&gt;Opcode() == Op_CmpI) {
3135           peel_if = iff-&gt;as_If();
3136         } else {
3137           assert(cmp-&gt;Opcode() == Op_CmpU, &quot;must be CmpI or CmpU&quot;);
3138           peel_if_cmpu = iff-&gt;as_If();
3139         }
3140       }
3141     }
3142     iff = idom(iff);
3143   }
3144 
3145   // Prefer signed compare over unsigned compare.
3146   IfNode* new_peel_if = NULL;
3147   if (peel_if == NULL) {
3148     if (!PartialPeelAtUnsignedTests || peel_if_cmpu == NULL) {
3149       return false;   // No peel point found
3150     }
3151     new_peel_if = insert_cmpi_loop_exit(peel_if_cmpu, loop);
3152     if (new_peel_if == NULL) {
3153       return false;   // No peel point found
3154     }
3155     peel_if = new_peel_if;
3156   }
3157   Node* last_peel        = stay_in_loop(peel_if, loop);
3158   Node* first_not_peeled = stay_in_loop(last_peel, loop);
3159   if (first_not_peeled == NULL || first_not_peeled == head) {
3160     return false;
3161   }
3162 
3163 #ifndef PRODUCT
3164   if (TraceLoopOpts) {
3165     tty-&gt;print(&quot;PartialPeel  &quot;);
3166     loop-&gt;dump_head();
3167   }
3168 
3169   if (TracePartialPeeling) {
3170     tty-&gt;print_cr(&quot;before partial peel one iteration&quot;);
3171     Node_List wl;
3172     Node* t = head-&gt;in(2);
3173     while (true) {
3174       wl.push(t);
3175       if (t == head) break;
3176       t = idom(t);
3177     }
3178     while (wl.size() &gt; 0) {
3179       Node* tt = wl.pop();
3180       tt-&gt;dump();
3181       if (tt == last_peel) tty-&gt;print_cr(&quot;-- cut --&quot;);
3182     }
3183   }
3184 #endif
3185   VectorSet peel;
3186   VectorSet not_peel;
3187   Node_List peel_list;
3188   Node_List worklist;
3189   Node_List sink_list;
3190 
3191   uint estimate = loop-&gt;est_loop_clone_sz(1);
3192   if (exceeding_node_budget(estimate)) {
3193     return false;
3194   }
3195 
3196   // Set of cfg nodes to peel are those that are executable from
3197   // the head through last_peel.
3198   assert(worklist.size() == 0, &quot;should be empty&quot;);
3199   worklist.push(head);
3200   peel.set(head-&gt;_idx);
3201   while (worklist.size() &gt; 0) {
3202     Node *n = worklist.pop();
3203     if (n != last_peel) {
3204       for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++) {
3205         Node* use = n-&gt;fast_out(j);
3206         if (use-&gt;is_CFG() &amp;&amp;
3207             loop-&gt;is_member(get_loop(use)) &amp;&amp;
3208             !peel.test_set(use-&gt;_idx)) {
3209           worklist.push(use);
3210         }
3211       }
3212     }
3213   }
3214 
3215   // Set of non-cfg nodes to peel are those that are control
3216   // dependent on the cfg nodes.
3217   for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
3218     Node *n = loop-&gt;_body.at(i);
3219     Node *n_c = has_ctrl(n) ? get_ctrl(n) : n;
3220     if (peel.test(n_c-&gt;_idx)) {
3221       peel.set(n-&gt;_idx);
3222     } else {
3223       not_peel.set(n-&gt;_idx);
3224     }
3225   }
3226 
3227   // Step 2: move operations from the peeled section down into the
3228   //         not-peeled section
3229 
3230   // Get a post order schedule of nodes in the peel region
3231   // Result in right-most operand.
3232   scheduled_nodelist(loop, peel, peel_list);
3233 
3234   assert(is_valid_loop_partition(loop, peel, peel_list, not_peel), &quot;bad partition&quot;);
3235 
3236   // For future check for too many new phis
3237   uint old_phi_cnt = 0;
3238   for (DUIterator_Fast jmax, j = head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
3239     Node* use = head-&gt;fast_out(j);
3240     if (use-&gt;is_Phi()) old_phi_cnt++;
3241   }
3242 
3243 #ifndef PRODUCT
3244   if (TracePartialPeeling) {
3245     tty-&gt;print_cr(&quot;\npeeled list&quot;);
3246   }
3247 #endif
3248 
3249   // Evacuate nodes in peel region into the not_peeled region if possible
3250   uint new_phi_cnt = 0;
3251   uint cloned_for_outside_use = 0;
3252   for (uint i = 0; i &lt; peel_list.size();) {
3253     Node* n = peel_list.at(i);
3254 #ifndef PRODUCT
3255   if (TracePartialPeeling) n-&gt;dump();
3256 #endif
3257     bool incr = true;
3258     if (!n-&gt;is_CFG()) {
3259       if (has_use_in_set(n, not_peel)) {
3260         // If not used internal to the peeled region,
3261         // move &quot;n&quot; from peeled to not_peeled region.
3262         if (!has_use_internal_to_set(n, peel, loop)) {
3263           // if not pinned and not a load (which maybe anti-dependent on a store)
3264           // and not a CMove (Matcher expects only bool-&gt;cmove).
3265           if (n-&gt;in(0) == NULL &amp;&amp; !n-&gt;is_Load() &amp;&amp; !n-&gt;is_CMove()) {
3266             cloned_for_outside_use += clone_for_use_outside_loop(loop, n, worklist);
3267             sink_list.push(n);
3268             peel.remove(n-&gt;_idx);
3269             not_peel.set(n-&gt;_idx);
3270             peel_list.remove(i);
3271             incr = false;
3272 #ifndef PRODUCT
3273             if (TracePartialPeeling) {
3274               tty-&gt;print_cr(&quot;sink to not_peeled region: %d newbb: %d&quot;,
3275                             n-&gt;_idx, get_ctrl(n)-&gt;_idx);
3276             }
3277 #endif
3278           }
3279         } else {
3280           // Otherwise check for special def-use cases that span
3281           // the peel/not_peel boundary such as bool-&gt;if
3282           clone_for_special_use_inside_loop(loop, n, not_peel, sink_list, worklist);
3283           new_phi_cnt++;
3284         }
3285       }
3286     }
3287     if (incr) i++;
3288   }
3289 
3290   estimate += cloned_for_outside_use + new_phi_cnt;
3291   bool exceed_node_budget = !may_require_nodes(estimate);
3292   bool exceed_phi_limit = new_phi_cnt &gt; old_phi_cnt + PartialPeelNewPhiDelta;
3293 
3294   if (exceed_node_budget || exceed_phi_limit) {
3295 #ifndef PRODUCT
3296     if (TracePartialPeeling) {
3297       tty-&gt;print_cr(&quot;\nToo many new phis: %d  old %d new cmpi: %c&quot;,
3298                     new_phi_cnt, old_phi_cnt, new_peel_if != NULL?&#39;T&#39;:&#39;F&#39;);
3299     }
3300 #endif
3301     if (new_peel_if != NULL) {
3302       remove_cmpi_loop_exit(new_peel_if, loop);
3303     }
3304     // Inhibit more partial peeling on this loop
3305     assert(!head-&gt;is_partial_peel_loop(), &quot;not partial peeled&quot;);
3306     head-&gt;mark_partial_peel_failed();
3307     if (cloned_for_outside_use &gt; 0) {
3308       // Terminate this round of loop opts because
3309       // the graph outside this loop was changed.
3310       C-&gt;set_major_progress();
3311       return true;
3312     }
3313     return false;
3314   }
3315 
3316   // Step 3: clone loop, retarget control, and insert new phis
3317 
3318   // Create new loop head for new phis and to hang
3319   // the nodes being moved (sinked) from the peel region.
3320   LoopNode* new_head = new LoopNode(last_peel, last_peel);
3321   new_head-&gt;set_unswitch_count(head-&gt;unswitch_count()); // Preserve
3322   _igvn.register_new_node_with_optimizer(new_head);
3323   assert(first_not_peeled-&gt;in(0) == last_peel, &quot;last_peel &lt;- first_not_peeled&quot;);
3324   _igvn.replace_input_of(first_not_peeled, 0, new_head);
3325   set_loop(new_head, loop);
3326   loop-&gt;_body.push(new_head);
3327   not_peel.set(new_head-&gt;_idx);
3328   set_idom(new_head, last_peel, dom_depth(first_not_peeled));
3329   set_idom(first_not_peeled, new_head, dom_depth(first_not_peeled));
3330 
3331   while (sink_list.size() &gt; 0) {
3332     Node* n = sink_list.pop();
3333     set_ctrl(n, new_head);
3334   }
3335 
3336   assert(is_valid_loop_partition(loop, peel, peel_list, not_peel), &quot;bad partition&quot;);
3337 
3338   clone_loop(loop, old_new, dd, IgnoreStripMined);
3339 
3340   const uint clone_exit_idx = 1;
3341   const uint orig_exit_idx  = 2;
3342   assert(is_valid_clone_loop_form(loop, peel_list, orig_exit_idx, clone_exit_idx), &quot;bad clone loop&quot;);
3343 
3344   Node* head_clone             = old_new[head-&gt;_idx];
3345   LoopNode* new_head_clone     = old_new[new_head-&gt;_idx]-&gt;as_Loop();
3346   Node* orig_tail_clone        = head_clone-&gt;in(2);
3347 
3348   // Add phi if &quot;def&quot; node is in peel set and &quot;use&quot; is not
3349 
3350   for (uint i = 0; i &lt; peel_list.size(); i++) {
3351     Node *def  = peel_list.at(i);
3352     if (!def-&gt;is_CFG()) {
3353       for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
3354         Node *use = def-&gt;fast_out(j);
3355         if (has_node(use) &amp;&amp; use-&gt;in(0) != C-&gt;top() &amp;&amp;
3356             (!peel.test(use-&gt;_idx) ||
3357              (use-&gt;is_Phi() &amp;&amp; use-&gt;in(0) == head)) ) {
3358           worklist.push(use);
3359         }
3360       }
3361       while( worklist.size() ) {
3362         Node *use = worklist.pop();
3363         for (uint j = 1; j &lt; use-&gt;req(); j++) {
3364           Node* n = use-&gt;in(j);
3365           if (n == def) {
3366 
3367             // &quot;def&quot; is in peel set, &quot;use&quot; is not in peel set
3368             // or &quot;use&quot; is in the entry boundary (a phi) of the peel set
3369 
3370             Node* use_c = has_ctrl(use) ? get_ctrl(use) : use;
3371 
3372             if ( loop-&gt;is_member(get_loop( use_c )) ) {
3373               // use is in loop
3374               if (old_new[use-&gt;_idx] != NULL) { // null for dead code
3375                 Node* use_clone = old_new[use-&gt;_idx];
3376                 _igvn.replace_input_of(use, j, C-&gt;top());
3377                 insert_phi_for_loop( use_clone, j, old_new[def-&gt;_idx], def, new_head_clone );
3378               }
3379             } else {
3380               assert(is_valid_clone_loop_exit_use(loop, use, orig_exit_idx), &quot;clone loop format&quot;);
3381               // use is not in the loop, check if the live range includes the cut
3382               Node* lp_if = use_c-&gt;in(orig_exit_idx)-&gt;in(0);
3383               if (not_peel.test(lp_if-&gt;_idx)) {
3384                 assert(j == orig_exit_idx, &quot;use from original loop&quot;);
3385                 insert_phi_for_loop( use, clone_exit_idx, old_new[def-&gt;_idx], def, new_head_clone );
3386               }
3387             }
3388           }
3389         }
3390       }
3391     }
3392   }
3393 
3394   // Step 3b: retarget control
3395 
3396   // Redirect control to the new loop head if a cloned node in
3397   // the not_peeled region has control that points into the peeled region.
3398   // This necessary because the cloned peeled region will be outside
3399   // the loop.
3400   //                            from    to
3401   //          cloned-peeled    &lt;---+
3402   //    new_head_clone:            |    &lt;--+
3403   //          cloned-not_peeled  in(0)    in(0)
3404   //          orig-peeled
3405 
3406   for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
3407     Node *n = loop-&gt;_body.at(i);
3408     if (!n-&gt;is_CFG()           &amp;&amp; n-&gt;in(0) != NULL        &amp;&amp;
3409         not_peel.test(n-&gt;_idx) &amp;&amp; peel.test(n-&gt;in(0)-&gt;_idx)) {
3410       Node* n_clone = old_new[n-&gt;_idx];
3411       _igvn.replace_input_of(n_clone, 0, new_head_clone);
3412     }
3413   }
3414 
3415   // Backedge of the surviving new_head (the clone) is original last_peel
3416   _igvn.replace_input_of(new_head_clone, LoopNode::LoopBackControl, last_peel);
3417 
3418   // Cut first node in original not_peel set
3419   _igvn.rehash_node_delayed(new_head);                     // Multiple edge updates:
3420   new_head-&gt;set_req(LoopNode::EntryControl,    C-&gt;top());  //   use rehash_node_delayed / set_req instead of
3421   new_head-&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());  //   multiple replace_input_of calls
3422 
3423   // Copy head_clone back-branch info to original head
3424   // and remove original head&#39;s loop entry and
3425   // clone head&#39;s back-branch
3426   _igvn.rehash_node_delayed(head); // Multiple edge updates
3427   head-&gt;set_req(LoopNode::EntryControl,    head_clone-&gt;in(LoopNode::LoopBackControl));
3428   head-&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
3429   _igvn.replace_input_of(head_clone, LoopNode::LoopBackControl, C-&gt;top());
3430 
3431   // Similarly modify the phis
3432   for (DUIterator_Fast kmax, k = head-&gt;fast_outs(kmax); k &lt; kmax; k++) {
3433     Node* use = head-&gt;fast_out(k);
3434     if (use-&gt;is_Phi() &amp;&amp; use-&gt;outcnt() &gt; 0) {
3435       Node* use_clone = old_new[use-&gt;_idx];
3436       _igvn.rehash_node_delayed(use); // Multiple edge updates
3437       use-&gt;set_req(LoopNode::EntryControl,    use_clone-&gt;in(LoopNode::LoopBackControl));
3438       use-&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
3439       _igvn.replace_input_of(use_clone, LoopNode::LoopBackControl, C-&gt;top());
3440     }
3441   }
3442 
3443   // Step 4: update dominator tree and dominator depth
3444 
3445   set_idom(head, orig_tail_clone, dd);
3446   recompute_dom_depth();
3447 
3448   // Inhibit more partial peeling on this loop
3449   new_head_clone-&gt;set_partial_peel_loop();
3450   C-&gt;set_major_progress();
3451   loop-&gt;record_for_igvn();
3452 
3453 #ifndef PRODUCT
3454   if (TracePartialPeeling) {
3455     tty-&gt;print_cr(&quot;\nafter partial peel one iteration&quot;);
3456     Node_List wl;
3457     Node* t = last_peel;
3458     while (true) {
3459       wl.push(t);
3460       if (t == head_clone) break;
3461       t = idom(t);
3462     }
3463     while (wl.size() &gt; 0) {
3464       Node* tt = wl.pop();
3465       if (tt == head) tty-&gt;print_cr(&quot;orig head&quot;);
3466       else if (tt == new_head_clone) tty-&gt;print_cr(&quot;new head&quot;);
3467       else if (tt == head_clone) tty-&gt;print_cr(&quot;clone head&quot;);
3468       tt-&gt;dump();
3469     }
3470   }
3471 #endif
3472   return true;
3473 }
3474 
3475 //------------------------------reorg_offsets----------------------------------
3476 // Reorganize offset computations to lower register pressure.  Mostly
3477 // prevent loop-fallout uses of the pre-incremented trip counter (which are
3478 // then alive with the post-incremented trip counter forcing an extra
3479 // register move)
3480 void PhaseIdealLoop::reorg_offsets(IdealLoopTree *loop) {
3481   // Perform it only for canonical counted loops.
3482   // Loop&#39;s shape could be messed up by iteration_split_impl.
3483   if (!loop-&gt;_head-&gt;is_CountedLoop())
3484     return;
3485   if (!loop-&gt;_head-&gt;as_Loop()-&gt;is_valid_counted_loop())
3486     return;
3487 
3488   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
3489   CountedLoopEndNode *cle = cl-&gt;loopexit();
3490   Node *exit = cle-&gt;proj_out(false);
3491   Node *phi = cl-&gt;phi();
3492 
3493   // Check for the special case when using the pre-incremented trip-counter on
3494   // the fall-out  path (forces the pre-incremented  and post-incremented trip
3495   // counter to be live  at the same time).  Fix this by  adjusting to use the
3496   // post-increment trip counter.
3497 
3498   bool progress = true;
3499   while (progress) {
3500     progress = false;
3501     for (DUIterator_Fast imax, i = phi-&gt;fast_outs(imax); i &lt; imax; i++) {
3502       Node* use = phi-&gt;fast_out(i);   // User of trip-counter
3503       if (!has_ctrl(use))  continue;
3504       Node *u_ctrl = get_ctrl(use);
3505       if (use-&gt;is_Phi()) {
3506         u_ctrl = NULL;
3507         for (uint j = 1; j &lt; use-&gt;req(); j++)
3508           if (use-&gt;in(j) == phi)
3509             u_ctrl = dom_lca(u_ctrl, use-&gt;in(0)-&gt;in(j));
3510       }
3511       IdealLoopTree *u_loop = get_loop(u_ctrl);
3512       // Look for loop-invariant use
3513       if (u_loop == loop) continue;
3514       if (loop-&gt;is_member(u_loop)) continue;
3515       // Check that use is live out the bottom.  Assuming the trip-counter
3516       // update is right at the bottom, uses of of the loop middle are ok.
3517       if (dom_lca(exit, u_ctrl) != exit) continue;
3518       // Hit!  Refactor use to use the post-incremented tripcounter.
3519       // Compute a post-increment tripcounter.
3520       Node* c = exit;
3521       if (cl-&gt;is_strip_mined()) {
3522         IdealLoopTree* outer_loop = get_loop(cl-&gt;outer_loop());
3523         if (!outer_loop-&gt;is_member(u_loop)) {
3524           c = cl-&gt;outer_loop_exit();
3525         }
3526       }
3527       Node *opaq = new Opaque2Node(C, cle-&gt;incr());
3528       register_new_node(opaq, c);
3529       Node *neg_stride = _igvn.intcon(-cle-&gt;stride_con());
3530       set_ctrl(neg_stride, C-&gt;root());
3531       Node *post = new AddINode(opaq, neg_stride);
3532       register_new_node(post, c);
3533       _igvn.rehash_node_delayed(use);
3534       for (uint j = 1; j &lt; use-&gt;req(); j++) {
3535         if (use-&gt;in(j) == phi)
3536           use-&gt;set_req(j, post);
3537       }
3538       // Since DU info changed, rerun loop
3539       progress = true;
3540       break;
3541     }
3542   }
3543 
3544 }
    </pre>
  </body>
</html>