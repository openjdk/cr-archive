<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/loopTransform.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;opto/addnode.hpp&quot;
  29 #include &quot;opto/callnode.hpp&quot;
  30 #include &quot;opto/castnode.hpp&quot;
  31 #include &quot;opto/connode.hpp&quot;
  32 #include &quot;opto/convertnode.hpp&quot;
  33 #include &quot;opto/divnode.hpp&quot;
  34 #include &quot;opto/loopnode.hpp&quot;
  35 #include &quot;opto/mulnode.hpp&quot;
  36 #include &quot;opto/movenode.hpp&quot;
  37 #include &quot;opto/opaquenode.hpp&quot;
  38 #include &quot;opto/rootnode.hpp&quot;
  39 #include &quot;opto/runtime.hpp&quot;
  40 #include &quot;opto/subnode.hpp&quot;
  41 #include &quot;opto/superword.hpp&quot;
  42 #include &quot;opto/vectornode.hpp&quot;
  43 
  44 //------------------------------is_loop_exit-----------------------------------
  45 // Given an IfNode, return the loop-exiting projection or NULL if both
  46 // arms remain in the loop.
  47 Node *IdealLoopTree::is_loop_exit(Node *iff) const {
  48   if (iff-&gt;outcnt() != 2) return NULL;  // Ignore partially dead tests
  49   PhaseIdealLoop *phase = _phase;
  50   // Test is an IfNode, has 2 projections.  If BOTH are in the loop
  51   // we need loop unswitching instead of peeling.
  52   if (!is_member(phase-&gt;get_loop(iff-&gt;raw_out(0))))
  53     return iff-&gt;raw_out(0);
  54   if (!is_member(phase-&gt;get_loop(iff-&gt;raw_out(1))))
  55     return iff-&gt;raw_out(1);
  56   return NULL;
  57 }
  58 
  59 
  60 //=============================================================================
  61 
  62 
  63 //------------------------------record_for_igvn----------------------------
  64 // Put loop body on igvn work list
  65 void IdealLoopTree::record_for_igvn() {
  66   for (uint i = 0; i &lt; _body.size(); i++) {
  67     Node *n = _body.at(i);
  68     _phase-&gt;_igvn._worklist.push(n);
  69   }
  70   // put body of outer strip mined loop on igvn work list as well
  71   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_Loop()-&gt;is_strip_mined()) {
  72     CountedLoopNode* l = _head-&gt;as_CountedLoop();
  73     Node* outer_loop = l-&gt;outer_loop();
  74     assert(outer_loop != NULL, &quot;missing piece of strip mined loop&quot;);
  75     _phase-&gt;_igvn._worklist.push(outer_loop);
  76     Node* outer_loop_tail = l-&gt;outer_loop_tail();
  77     assert(outer_loop_tail != NULL, &quot;missing piece of strip mined loop&quot;);
  78     _phase-&gt;_igvn._worklist.push(outer_loop_tail);
  79     Node* outer_loop_end = l-&gt;outer_loop_end();
  80     assert(outer_loop_end != NULL, &quot;missing piece of strip mined loop&quot;);
  81     _phase-&gt;_igvn._worklist.push(outer_loop_end);
  82     Node* outer_safepoint = l-&gt;outer_safepoint();
  83     assert(outer_safepoint != NULL, &quot;missing piece of strip mined loop&quot;);
  84     _phase-&gt;_igvn._worklist.push(outer_safepoint);
  85     Node* cle_out = _head-&gt;as_CountedLoop()-&gt;loopexit()-&gt;proj_out(false);
  86     assert(cle_out != NULL, &quot;missing piece of strip mined loop&quot;);
  87     _phase-&gt;_igvn._worklist.push(cle_out);
  88   }
  89 }
  90 
  91 //------------------------------compute_exact_trip_count-----------------------
  92 // Compute loop trip count if possible. Do not recalculate trip count for
  93 // split loops (pre-main-post) which have their limits and inits behind Opaque node.
  94 void IdealLoopTree::compute_trip_count(PhaseIdealLoop* phase) {
  95   if (!_head-&gt;as_Loop()-&gt;is_valid_counted_loop()) {
  96     return;
  97   }
  98   CountedLoopNode* cl = _head-&gt;as_CountedLoop();
  99   // Trip count may become nonexact for iteration split loops since
 100   // RCE modifies limits. Note, _trip_count value is not reset since
 101   // it is used to limit unrolling of main loop.
 102   cl-&gt;set_nonexact_trip_count();
 103 
 104   // Loop&#39;s test should be part of loop.
 105   if (!phase-&gt;is_member(this, phase-&gt;get_ctrl(cl-&gt;loopexit()-&gt;in(CountedLoopEndNode::TestValue))))
 106     return; // Infinite loop
 107 
 108 #ifdef ASSERT
 109   BoolTest::mask bt = cl-&gt;loopexit()-&gt;test_trip();
 110   assert(bt == BoolTest::lt || bt == BoolTest::gt ||
 111          bt == BoolTest::ne, &quot;canonical test is expected&quot;);
 112 #endif
 113 
 114   Node* init_n = cl-&gt;init_trip();
 115   Node* limit_n = cl-&gt;limit();
 116   if (init_n != NULL &amp;&amp; limit_n != NULL) {
 117     // Use longs to avoid integer overflow.
 118     int stride_con = cl-&gt;stride_con();
 119     const TypeInt* init_type = phase-&gt;_igvn.type(init_n)-&gt;is_int();
 120     const TypeInt* limit_type = phase-&gt;_igvn.type(limit_n)-&gt;is_int();
 121     jlong init_con = (stride_con &gt; 0) ? init_type-&gt;_lo : init_type-&gt;_hi;
 122     jlong limit_con = (stride_con &gt; 0) ? limit_type-&gt;_hi : limit_type-&gt;_lo;
 123     int stride_m = stride_con - (stride_con &gt; 0 ? 1 : -1);
 124     jlong trip_count = (limit_con - init_con + stride_m)/stride_con;
 125     if (trip_count &gt; 0 &amp;&amp; (julong)trip_count &lt; (julong)max_juint) {
 126       if (init_n-&gt;is_Con() &amp;&amp; limit_n-&gt;is_Con()) {
 127         // Set exact trip count.
 128         cl-&gt;set_exact_trip_count((uint)trip_count);
 129       } else if (cl-&gt;unrolled_count() == 1) {
 130         // Set maximum trip count before unrolling.
 131         cl-&gt;set_trip_count((uint)trip_count);
 132       }
 133     }
 134   }
 135 }
 136 
 137 //------------------------------compute_profile_trip_cnt----------------------------
 138 // Compute loop trip count from profile data as
 139 //    (backedge_count + loop_exit_count) / loop_exit_count
 140 
 141 float IdealLoopTree::compute_profile_trip_cnt_helper(Node* n) {
 142   if (n-&gt;is_If()) {
 143     IfNode *iff = n-&gt;as_If();
 144     if (iff-&gt;_fcnt != COUNT_UNKNOWN &amp;&amp; iff-&gt;_prob != PROB_UNKNOWN) {
 145       Node *exit = is_loop_exit(iff);
 146       if (exit) {
 147         float exit_prob = iff-&gt;_prob;
 148         if (exit-&gt;Opcode() == Op_IfFalse) {
 149           exit_prob = 1.0 - exit_prob;
 150         }
 151         if (exit_prob &gt; PROB_MIN) {
 152           float exit_cnt = iff-&gt;_fcnt * exit_prob;
 153           return exit_cnt;
 154         }
 155       }
 156     }
 157   }
 158   if (n-&gt;is_Jump()) {
 159     JumpNode *jmp = n-&gt;as_Jump();
 160     if (jmp-&gt;_fcnt != COUNT_UNKNOWN) {
 161       float* probs = jmp-&gt;_probs;
 162       float exit_prob = 0;
 163       PhaseIdealLoop *phase = _phase;
 164       for (DUIterator_Fast imax, i = jmp-&gt;fast_outs(imax); i &lt; imax; i++) {
 165         JumpProjNode* u = jmp-&gt;fast_out(i)-&gt;as_JumpProj();
 166         if (!is_member(_phase-&gt;get_loop(u))) {
 167           exit_prob += probs[u-&gt;_con];
 168         }
 169       }
 170       return exit_prob * jmp-&gt;_fcnt;
 171     }
 172   }
 173   return 0;
 174 }
 175 
 176 void IdealLoopTree::compute_profile_trip_cnt(PhaseIdealLoop *phase) {
 177   if (!_head-&gt;is_Loop()) {
 178     return;
 179   }
 180   LoopNode* head = _head-&gt;as_Loop();
 181   if (head-&gt;profile_trip_cnt() != COUNT_UNKNOWN) {
 182     return; // Already computed
 183   }
 184   float trip_cnt = (float)max_jint; // default is big
 185 
 186   Node* back = head-&gt;in(LoopNode::LoopBackControl);
 187   while (back != head) {
 188     if ((back-&gt;Opcode() == Op_IfTrue || back-&gt;Opcode() == Op_IfFalse) &amp;&amp;
 189         back-&gt;in(0) &amp;&amp;
 190         back-&gt;in(0)-&gt;is_If() &amp;&amp;
 191         back-&gt;in(0)-&gt;as_If()-&gt;_fcnt != COUNT_UNKNOWN &amp;&amp;
 192         back-&gt;in(0)-&gt;as_If()-&gt;_prob != PROB_UNKNOWN &amp;&amp;
 193         (back-&gt;Opcode() == Op_IfTrue ? 1-back-&gt;in(0)-&gt;as_If()-&gt;_prob : back-&gt;in(0)-&gt;as_If()-&gt;_prob) &gt; PROB_MIN) {
 194       break;
 195     }
 196     back = phase-&gt;idom(back);
 197   }
 198   if (back != head) {
 199     assert((back-&gt;Opcode() == Op_IfTrue || back-&gt;Opcode() == Op_IfFalse) &amp;&amp;
 200            back-&gt;in(0), &quot;if-projection exists&quot;);
 201     IfNode* back_if = back-&gt;in(0)-&gt;as_If();
 202     float loop_back_cnt = back_if-&gt;_fcnt * (back-&gt;Opcode() == Op_IfTrue ? back_if-&gt;_prob : (1 - back_if-&gt;_prob));
 203 
 204     // Now compute a loop exit count
 205     float loop_exit_cnt = 0.0f;
 206     if (_child == NULL) {
 207       for (uint i = 0; i &lt; _body.size(); i++) {
 208         Node *n = _body[i];
 209         loop_exit_cnt += compute_profile_trip_cnt_helper(n);
 210       }
 211     } else {
 212       ResourceMark rm;
 213       Unique_Node_List wq;
 214       wq.push(back);
 215       for (uint i = 0; i &lt; wq.size(); i++) {
 216         Node *n = wq.at(i);
 217         assert(n-&gt;is_CFG(), &quot;only control nodes&quot;);
 218         if (n != head) {
 219           if (n-&gt;is_Region()) {
 220             for (uint j = 1; j &lt; n-&gt;req(); j++) {
 221               wq.push(n-&gt;in(j));
 222             }
 223           } else {
 224             loop_exit_cnt += compute_profile_trip_cnt_helper(n);
 225             wq.push(n-&gt;in(0));
 226           }
 227         }
 228       }
 229 
 230     }
 231     if (loop_exit_cnt &gt; 0.0f) {
 232       trip_cnt = (loop_back_cnt + loop_exit_cnt) / loop_exit_cnt;
 233     } else {
 234       // No exit count so use
 235       trip_cnt = loop_back_cnt;
 236     }
 237   } else {
 238     head-&gt;mark_profile_trip_failed();
 239   }
 240 #ifndef PRODUCT
 241   if (TraceProfileTripCount) {
 242     tty-&gt;print_cr(&quot;compute_profile_trip_cnt  lp: %d cnt: %f\n&quot;, head-&gt;_idx, trip_cnt);
 243   }
 244 #endif
 245   head-&gt;set_profile_trip_cnt(trip_cnt);
 246 }
 247 
 248 //---------------------is_invariant_addition-----------------------------
 249 // Return nonzero index of invariant operand for an Add or Sub
 250 // of (nonconstant) invariant and variant values. Helper for reassociate_invariants.
 251 int IdealLoopTree::is_invariant_addition(Node* n, PhaseIdealLoop *phase) {
 252   int op = n-&gt;Opcode();
 253   if (op == Op_AddI || op == Op_SubI) {
 254     bool in1_invar = this-&gt;is_invariant(n-&gt;in(1));
 255     bool in2_invar = this-&gt;is_invariant(n-&gt;in(2));
 256     if (in1_invar &amp;&amp; !in2_invar) return 1;
 257     if (!in1_invar &amp;&amp; in2_invar) return 2;
 258   }
 259   return 0;
 260 }
 261 
 262 //---------------------reassociate_add_sub-----------------------------
 263 // Reassociate invariant add and subtract expressions:
 264 //
 265 // inv1 + (x + inv2)  =&gt;  ( inv1 + inv2) + x
 266 // (x + inv2) + inv1  =&gt;  ( inv1 + inv2) + x
 267 // inv1 + (x - inv2)  =&gt;  ( inv1 - inv2) + x
 268 // inv1 - (inv2 - x)  =&gt;  ( inv1 - inv2) + x
 269 // (x + inv2) - inv1  =&gt;  (-inv1 + inv2) + x
 270 // (x - inv2) + inv1  =&gt;  ( inv1 - inv2) + x
 271 // (x - inv2) - inv1  =&gt;  (-inv1 - inv2) + x
 272 // inv1 + (inv2 - x)  =&gt;  ( inv1 + inv2) - x
 273 // inv1 - (x - inv2)  =&gt;  ( inv1 + inv2) - x
 274 // (inv2 - x) + inv1  =&gt;  ( inv1 + inv2) - x
 275 // (inv2 - x) - inv1  =&gt;  (-inv1 + inv2) - x
 276 // inv1 - (x + inv2)  =&gt;  ( inv1 - inv2) - x
 277 //
 278 Node* IdealLoopTree::reassociate_add_sub(Node* n1, PhaseIdealLoop *phase) {
 279   if ((!n1-&gt;is_Add() &amp;&amp; !n1-&gt;is_Sub()) || n1-&gt;outcnt() == 0) return NULL;
 280   if (is_invariant(n1)) return NULL;
 281   int inv1_idx = is_invariant_addition(n1, phase);
 282   if (!inv1_idx) return NULL;
 283   // Don&#39;t mess with add of constant (igvn moves them to expression tree root.)
 284   if (n1-&gt;is_Add() &amp;&amp; n1-&gt;in(2)-&gt;is_Con()) return NULL;
 285   Node* inv1 = n1-&gt;in(inv1_idx);
 286   Node* n2 = n1-&gt;in(3 - inv1_idx);
 287   int inv2_idx = is_invariant_addition(n2, phase);
 288   if (!inv2_idx) return NULL;
 289 
 290   if (!phase-&gt;may_require_nodes(10, 10)) return NULL;
 291 
 292   Node* x    = n2-&gt;in(3 - inv2_idx);
 293   Node* inv2 = n2-&gt;in(inv2_idx);
 294 
 295   bool neg_x    = n2-&gt;is_Sub() &amp;&amp; inv2_idx == 1;
 296   bool neg_inv2 = n2-&gt;is_Sub() &amp;&amp; inv2_idx == 2;
 297   bool neg_inv1 = n1-&gt;is_Sub() &amp;&amp; inv1_idx == 2;
 298   if (n1-&gt;is_Sub() &amp;&amp; inv1_idx == 1) {
 299     neg_x    = !neg_x;
 300     neg_inv2 = !neg_inv2;
 301   }
 302   Node* inv1_c = phase-&gt;get_ctrl(inv1);
 303   Node* inv2_c = phase-&gt;get_ctrl(inv2);
 304   Node* n_inv1;
 305   if (neg_inv1) {
 306     Node *zero = phase-&gt;_igvn.intcon(0);
 307     phase-&gt;set_ctrl(zero, phase-&gt;C-&gt;root());
 308     n_inv1 = new SubINode(zero, inv1);
 309     phase-&gt;register_new_node(n_inv1, inv1_c);
 310   } else {
 311     n_inv1 = inv1;
 312   }
 313   Node* inv;
 314   if (neg_inv2) {
 315     inv = new SubINode(n_inv1, inv2);
 316   } else {
 317     inv = new AddINode(n_inv1, inv2);
 318   }
 319   phase-&gt;register_new_node(inv, phase-&gt;get_early_ctrl(inv));
 320 
 321   Node* addx;
 322   if (neg_x) {
 323     addx = new SubINode(inv, x);
 324   } else {
 325     addx = new AddINode(x, inv);
 326   }
 327   phase-&gt;register_new_node(addx, phase-&gt;get_ctrl(x));
 328   phase-&gt;_igvn.replace_node(n1, addx);
 329   assert(phase-&gt;get_loop(phase-&gt;get_ctrl(n1)) == this, &quot;&quot;);
 330   _body.yank(n1);
 331   return addx;
 332 }
 333 
 334 //---------------------reassociate_invariants-----------------------------
 335 // Reassociate invariant expressions:
 336 void IdealLoopTree::reassociate_invariants(PhaseIdealLoop *phase) {
 337   for (int i = _body.size() - 1; i &gt;= 0; i--) {
 338     Node *n = _body.at(i);
 339     for (int j = 0; j &lt; 5; j++) {
 340       Node* nn = reassociate_add_sub(n, phase);
 341       if (nn == NULL) break;
 342       n = nn; // again
 343     }
 344   }
 345 }
 346 
 347 //------------------------------policy_peeling---------------------------------
 348 // Return TRUE if the loop should be peeled, otherwise return FALSE. Peeling
 349 // is applicable if we can make a loop-invariant test (usually a null-check)
 350 // execute before we enter the loop. When TRUE, the estimated node budget is
 351 // also requested.
 352 bool IdealLoopTree::policy_peeling(PhaseIdealLoop *phase) {
 353   uint estimate = estimate_peeling(phase);
 354 
 355   return estimate == 0 ? false : phase-&gt;may_require_nodes(estimate);
 356 }
 357 
 358 // Perform actual policy and size estimate for the loop peeling transform, and
 359 // return the estimated loop size if peeling is applicable, otherwise return
 360 // zero. No node budget is allocated.
 361 uint IdealLoopTree::estimate_peeling(PhaseIdealLoop *phase) {
 362 
 363   // If nodes are depleted, some transform has miscalculated its needs.
 364   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);
 365 
 366   // Peeling does loop cloning which can result in O(N^2) node construction.
 367   if (_body.size() &gt; 255) {
 368     return 0;   // Suppress too large body size.
 369   }
 370   // Optimistic estimate that approximates loop body complexity via data and
 371   // control flow fan-out (instead of using the more pessimistic: BodySize^2).
 372   uint estimate = est_loop_clone_sz(2);
 373 
 374   if (phase-&gt;exceeding_node_budget(estimate)) {
 375     return 0;   // Too large to safely clone.
 376   }
 377 
 378   // Check for vectorized loops, any peeling done was already applied.
 379   if (_head-&gt;is_CountedLoop()) {
 380     CountedLoopNode* cl = _head-&gt;as_CountedLoop();
 381     if (cl-&gt;is_unroll_only() || cl-&gt;trip_count() == 1) {
 382       return 0;
 383     }
 384   }
 385 
 386   Node* test = tail();
 387 
 388   while (test != _head) {   // Scan till run off top of loop
 389     if (test-&gt;is_If()) {    // Test?
 390       Node *ctrl = phase-&gt;get_ctrl(test-&gt;in(1));
 391       if (ctrl-&gt;is_top()) {
 392         return 0;           // Found dead test on live IF?  No peeling!
 393       }
 394       // Standard IF only has one input value to check for loop invariance.
 395       assert(test-&gt;Opcode() == Op_If ||
 396              test-&gt;Opcode() == Op_CountedLoopEnd ||
 397              test-&gt;Opcode() == Op_RangeCheck,
 398              &quot;Check this code when new subtype is added&quot;);
 399       // Condition is not a member of this loop?
 400       if (!is_member(phase-&gt;get_loop(ctrl)) &amp;&amp; is_loop_exit(test)) {
 401         return estimate;    // Found reason to peel!
 402       }
 403     }
 404     // Walk up dominators to loop _head looking for test which is executed on
 405     // every path through the loop.
 406     test = phase-&gt;idom(test);
 407   }
 408   return 0;
 409 }
 410 
 411 //------------------------------peeled_dom_test_elim---------------------------
 412 // If we got the effect of peeling, either by actually peeling or by making
 413 // a pre-loop which must execute at least once, we can remove all
 414 // loop-invariant dominated tests in the main body.
 415 void PhaseIdealLoop::peeled_dom_test_elim(IdealLoopTree *loop, Node_List &amp;old_new) {
 416   bool progress = true;
 417   while (progress) {
 418     progress = false;           // Reset for next iteration
 419     Node *prev = loop-&gt;_head-&gt;in(LoopNode::LoopBackControl);//loop-&gt;tail();
 420     Node *test = prev-&gt;in(0);
 421     while (test != loop-&gt;_head) { // Scan till run off top of loop
 422 
 423       int p_op = prev-&gt;Opcode();
 424       if ((p_op == Op_IfFalse || p_op == Op_IfTrue) &amp;&amp;
 425           test-&gt;is_If() &amp;&amp;      // Test?
 426           !test-&gt;in(1)-&gt;is_Con() &amp;&amp; // And not already obvious?
 427           // Condition is not a member of this loop?
 428           !loop-&gt;is_member(get_loop(get_ctrl(test-&gt;in(1))))){
 429         // Walk loop body looking for instances of this test
 430         for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
 431           Node *n = loop-&gt;_body.at(i);
 432           if (n-&gt;is_If() &amp;&amp; n-&gt;in(1) == test-&gt;in(1) /*&amp;&amp; n != loop-&gt;tail()-&gt;in(0)*/) {
 433             // IfNode was dominated by version in peeled loop body
 434             progress = true;
 435             dominated_by(old_new[prev-&gt;_idx], n);
 436           }
 437         }
 438       }
 439       prev = test;
 440       test = idom(test);
 441     } // End of scan tests in loop
 442 
 443   } // End of while (progress)
 444 }
 445 
 446 //------------------------------do_peeling-------------------------------------
 447 // Peel the first iteration of the given loop.
 448 // Step 1: Clone the loop body.  The clone becomes the peeled iteration.
 449 //         The pre-loop illegally has 2 control users (old &amp; new loops).
 450 // Step 2: Make the old-loop fall-in edges point to the peeled iteration.
 451 //         Do this by making the old-loop fall-in edges act as if they came
 452 //         around the loopback from the prior iteration (follow the old-loop
 453 //         backedges) and then map to the new peeled iteration.  This leaves
 454 //         the pre-loop with only 1 user (the new peeled iteration), but the
 455 //         peeled-loop backedge has 2 users.
 456 // Step 3: Cut the backedge on the clone (so its not a loop) and remove the
 457 //         extra backedge user.
 458 //
 459 //                   orig
 460 //
 461 //                  stmt1
 462 //                    |
 463 //                    v
 464 //              loop predicate
 465 //                    |
 466 //                    v
 467 //                   loop&lt;----+
 468 //                     |      |
 469 //                   stmt2    |
 470 //                     |      |
 471 //                     v      |
 472 //                    if      ^
 473 //                   / \      |
 474 //                  /   \     |
 475 //                 v     v    |
 476 //               false true   |
 477 //               /       \    |
 478 //              /         ----+
 479 //             |
 480 //             v
 481 //           exit
 482 //
 483 //
 484 //            after clone loop
 485 //
 486 //                   stmt1
 487 //                     |
 488 //                     v
 489 //               loop predicate
 490 //                 /       \
 491 //        clone   /         \   orig
 492 //               /           \
 493 //              /             \
 494 //             v               v
 495 //   +----&gt;loop clone          loop&lt;----+
 496 //   |      |                    |      |
 497 //   |    stmt2 clone          stmt2    |
 498 //   |      |                    |      |
 499 //   |      v                    v      |
 500 //   ^      if clone            If      ^
 501 //   |      / \                / \      |
 502 //   |     /   \              /   \     |
 503 //   |    v     v            v     v    |
 504 //   |    true  false      false true   |
 505 //   |    /         \      /       \    |
 506 //   +----           \    /         ----+
 507 //                    \  /
 508 //                    1v v2
 509 //                  region
 510 //                     |
 511 //                     v
 512 //                   exit
 513 //
 514 //
 515 //         after peel and predicate move
 516 //
 517 //                   stmt1
 518 //                    /
 519 //                   /
 520 //        clone     /            orig
 521 //                 /
 522 //                /              +----------+
 523 //               /               |          |
 524 //              /          loop predicate   |
 525 //             /                 |          |
 526 //            v                  v          |
 527 //   TOP--&gt;loop clone          loop&lt;----+   |
 528 //          |                    |      |   |
 529 //        stmt2 clone          stmt2    |   |
 530 //          |                    |      |   ^
 531 //          v                    v      |   |
 532 //          if clone            If      ^   |
 533 //          / \                / \      |   |
 534 //         /   \              /   \     |   |
 535 //        v     v            v     v    |   |
 536 //      true   false      false  true   |   |
 537 //        |         \      /       \    |   |
 538 //        |          \    /         ----+   ^
 539 //        |           \  /                  |
 540 //        |           1v v2                 |
 541 //        v         region                  |
 542 //        |            |                    |
 543 //        |            v                    |
 544 //        |          exit                   |
 545 //        |                                 |
 546 //        +---------------&gt;-----------------+
 547 //
 548 //
 549 //              final graph
 550 //
 551 //                  stmt1
 552 //                    |
 553 //                    v
 554 //                  stmt2 clone
 555 //                    |
 556 //                    v
 557 //                   if clone
 558 //                  / |
 559 //                 /  |
 560 //                v   v
 561 //            false  true
 562 //             |      |
 563 //             |      v
 564 //             | loop predicate
 565 //             |      |
 566 //             |      v
 567 //             |     loop&lt;----+
 568 //             |      |       |
 569 //             |    stmt2     |
 570 //             |      |       |
 571 //             |      v       |
 572 //             v      if      ^
 573 //             |     /  \     |
 574 //             |    /    \    |
 575 //             |   v     v    |
 576 //             | false  true  |
 577 //             |  |        \  |
 578 //             v  v         --+
 579 //            region
 580 //              |
 581 //              v
 582 //             exit
 583 //
 584 void PhaseIdealLoop::do_peeling(IdealLoopTree *loop, Node_List &amp;old_new) {
 585 
 586   C-&gt;set_major_progress();
 587   // Peeling a &#39;main&#39; loop in a pre/main/post situation obfuscates the
 588   // &#39;pre&#39; loop from the main and the &#39;pre&#39; can no longer have its
 589   // iterations adjusted.  Therefore, we need to declare this loop as
 590   // no longer a &#39;main&#39; loop; it will need new pre and post loops before
 591   // we can do further RCE.
 592 #ifndef PRODUCT
 593   if (TraceLoopOpts) {
 594     tty-&gt;print(&quot;Peel         &quot;);
 595     loop-&gt;dump_head();
 596   }
 597 #endif
 598   LoopNode* head = loop-&gt;_head-&gt;as_Loop();
 599   bool counted_loop = head-&gt;is_CountedLoop();
 600   if (counted_loop) {
 601     CountedLoopNode *cl = head-&gt;as_CountedLoop();
 602     assert(cl-&gt;trip_count() &gt; 0, &quot;peeling a fully unrolled loop&quot;);
 603     cl-&gt;set_trip_count(cl-&gt;trip_count() - 1);
 604     if (cl-&gt;is_main_loop()) {
 605       cl-&gt;set_normal_loop();
 606 #ifndef PRODUCT
 607       if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
 608         tty-&gt;print(&quot;Peeling a &#39;main&#39; loop; resetting to &#39;normal&#39; &quot;);
 609         loop-&gt;dump_head();
 610       }
 611 #endif
 612     }
 613   }
 614   Node* entry = head-&gt;in(LoopNode::EntryControl);
 615 
 616   // Step 1: Clone the loop body.  The clone becomes the peeled iteration.
 617   //         The pre-loop illegally has 2 control users (old &amp; new loops).
 618   clone_loop(loop, old_new, dom_depth(head-&gt;skip_strip_mined()), ControlAroundStripMined);
 619 
 620   // Step 2: Make the old-loop fall-in edges point to the peeled iteration.
 621   //         Do this by making the old-loop fall-in edges act as if they came
 622   //         around the loopback from the prior iteration (follow the old-loop
 623   //         backedges) and then map to the new peeled iteration.  This leaves
 624   //         the pre-loop with only 1 user (the new peeled iteration), but the
 625   //         peeled-loop backedge has 2 users.
 626   Node* new_entry = old_new[head-&gt;in(LoopNode::LoopBackControl)-&gt;_idx];
 627   _igvn.hash_delete(head-&gt;skip_strip_mined());
 628   head-&gt;skip_strip_mined()-&gt;set_req(LoopNode::EntryControl, new_entry);
 629   for (DUIterator_Fast jmax, j = head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 630     Node* old = head-&gt;fast_out(j);
 631     if (old-&gt;in(0) == loop-&gt;_head &amp;&amp; old-&gt;req() == 3 &amp;&amp; old-&gt;is_Phi()) {
 632       Node* new_exit_value = old_new[old-&gt;in(LoopNode::LoopBackControl)-&gt;_idx];
 633       if (!new_exit_value)     // Backedge value is ALSO loop invariant?
 634         // Then loop body backedge value remains the same.
 635         new_exit_value = old-&gt;in(LoopNode::LoopBackControl);
 636       _igvn.hash_delete(old);
 637       old-&gt;set_req(LoopNode::EntryControl, new_exit_value);
 638     }
 639   }
 640 
 641 
 642   // Step 3: Cut the backedge on the clone (so its not a loop) and remove the
 643   //         extra backedge user.
 644   Node* new_head = old_new[head-&gt;_idx];
 645   _igvn.hash_delete(new_head);
 646   new_head-&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
 647   for (DUIterator_Fast j2max, j2 = new_head-&gt;fast_outs(j2max); j2 &lt; j2max; j2++) {
 648     Node* use = new_head-&gt;fast_out(j2);
 649     if (use-&gt;in(0) == new_head &amp;&amp; use-&gt;req() == 3 &amp;&amp; use-&gt;is_Phi()) {
 650       _igvn.hash_delete(use);
 651       use-&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
 652     }
 653   }
 654 
 655   // Step 4: Correct dom-depth info.  Set to loop-head depth.
 656 
 657   int dd = dom_depth(head-&gt;skip_strip_mined());
 658   set_idom(head-&gt;skip_strip_mined(), head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl), dd);
 659   for (uint j3 = 0; j3 &lt; loop-&gt;_body.size(); j3++) {
 660     Node *old = loop-&gt;_body.at(j3);
 661     Node *nnn = old_new[old-&gt;_idx];
 662     if (!has_ctrl(nnn)) {
 663       set_idom(nnn, idom(nnn), dd-1);
 664     }
 665   }
 666 
 667   // Now force out all loop-invariant dominating tests.  The optimizer
 668   // finds some, but we _know_ they are all useless.
 669   peeled_dom_test_elim(loop,old_new);
 670 
 671   loop-&gt;record_for_igvn();
 672 }
 673 
 674 //------------------------------policy_maximally_unroll------------------------
 675 // Calculate the exact  loop trip-count and return TRUE if loop can be fully,
 676 // i.e. maximally, unrolled, otherwise return FALSE. When TRUE, the estimated
 677 // node budget is also requested.
 678 bool IdealLoopTree::policy_maximally_unroll(PhaseIdealLoop* phase) const {
 679   CountedLoopNode* cl = _head-&gt;as_CountedLoop();
 680   assert(cl-&gt;is_normal_loop(), &quot;&quot;);
 681   if (!cl-&gt;is_valid_counted_loop()) {
 682     return false;   // Malformed counted loop.
 683   }
 684   if (!cl-&gt;has_exact_trip_count()) {
 685     return false;   // Trip count is not exact.
 686   }
 687 
 688   uint trip_count = cl-&gt;trip_count();
 689   // Note, max_juint is used to indicate unknown trip count.
 690   assert(trip_count &gt; 1, &quot;one iteration loop should be optimized out already&quot;);
 691   assert(trip_count &lt; max_juint, &quot;exact trip_count should be less than max_juint.&quot;);
 692 
 693   // If nodes are depleted, some transform has miscalculated its needs.
 694   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);
 695 
 696   // Allow the unrolled body to get larger than the standard loop size limit.
 697   uint unroll_limit = (uint)LoopUnrollLimit * 4;
 698   assert((intx)unroll_limit == LoopUnrollLimit * 4, &quot;LoopUnrollLimit must fit in 32bits&quot;);
 699   if (trip_count &gt; unroll_limit || _body.size() &gt; unroll_limit) {
 700     return false;
 701   }
 702 
 703   uint new_body_size = est_loop_unroll_sz(trip_count);
 704 
 705   if (new_body_size == UINT_MAX) { // Check for bad estimate (overflow).
 706     return false;
 707   }
 708 
 709   // Fully unroll a loop with few iterations, regardless of other conditions,
 710   // since the following (general) loop optimizations will split such loop in
 711   // any case (into pre-main-post).
 712   if (trip_count &lt;= 3) {
 713     return phase-&gt;may_require_nodes(new_body_size);
 714   }
 715 
 716   // Reject if unrolling will result in too much node construction.
 717   if (new_body_size &gt; unroll_limit || phase-&gt;exceeding_node_budget(new_body_size)) {
 718     return false;
 719   }
 720 
 721   // Do not unroll a loop with String intrinsics code.
 722   // String intrinsics are large and have loops.
 723   for (uint k = 0; k &lt; _body.size(); k++) {
 724     Node* n = _body.at(k);
 725     switch (n-&gt;Opcode()) {
 726       case Op_StrComp:
 727       case Op_StrEquals:
 728       case Op_StrIndexOf:
 729       case Op_StrIndexOfChar:
 730       case Op_EncodeISOArray:
 731       case Op_AryEq:
 732       case Op_HasNegatives: {
 733         return false;
 734       }
 735 #if INCLUDE_RTM_OPT
 736       case Op_FastLock:
 737       case Op_FastUnlock: {
 738         // Don&#39;t unroll RTM locking code because it is large.
 739         if (UseRTMLocking) {
 740           return false;
 741         }
 742       }
 743 #endif
 744     } // switch
 745   }
 746 
 747   return phase-&gt;may_require_nodes(new_body_size);
 748 }
 749 
 750 
 751 //------------------------------policy_unroll----------------------------------
 752 // Return TRUE or FALSE if the loop should be unrolled or not. Apply unroll if
 753 // the loop is  a counted loop and  the loop body is small  enough. When TRUE,
 754 // the estimated node budget is also requested.
 755 bool IdealLoopTree::policy_unroll(PhaseIdealLoop *phase) {
 756 
 757   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
 758   assert(cl-&gt;is_normal_loop() || cl-&gt;is_main_loop(), &quot;&quot;);
 759 
 760   if (!cl-&gt;is_valid_counted_loop()) {
 761     return false; // Malformed counted loop
 762   }
 763 
 764   // If nodes are depleted, some transform has miscalculated its needs.
 765   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);
 766 
 767   // Protect against over-unrolling.
 768   // After split at least one iteration will be executed in pre-loop.
 769   if (cl-&gt;trip_count() &lt;= (cl-&gt;is_normal_loop() ? 2u : 1u)) {
 770     return false;
 771   }
 772   _local_loop_unroll_limit  = LoopUnrollLimit;
 773   _local_loop_unroll_factor = 4;
 774   int future_unroll_cnt = cl-&gt;unrolled_count() * 2;
 775   if (!cl-&gt;is_vectorized_loop()) {
 776     if (future_unroll_cnt &gt; LoopMaxUnroll) return false;
 777   } else {
 778     // obey user constraints on vector mapped loops with additional unrolling applied
 779     int unroll_constraint = (cl-&gt;slp_max_unroll()) ? cl-&gt;slp_max_unroll() : 1;
 780     if ((future_unroll_cnt / unroll_constraint) &gt; LoopMaxUnroll) return false;
 781   }
 782 
 783   // Check for initial stride being a small enough constant
 784   if (abs(cl-&gt;stride_con()) &gt; (1&lt;&lt;2)*future_unroll_cnt) return false;
 785 
 786   // Don&#39;t unroll if the next round of unrolling would push us
 787   // over the expected trip count of the loop.  One is subtracted
 788   // from the expected trip count because the pre-loop normally
 789   // executes 1 iteration.
 790   if (UnrollLimitForProfileCheck &gt; 0 &amp;&amp;
 791       cl-&gt;profile_trip_cnt() != COUNT_UNKNOWN &amp;&amp;
 792       future_unroll_cnt        &gt; UnrollLimitForProfileCheck &amp;&amp;
 793       (float)future_unroll_cnt &gt; cl-&gt;profile_trip_cnt() - 1.0) {
 794     return false;
 795   }
 796 
 797   // When unroll count is greater than LoopUnrollMin, don&#39;t unroll if:
 798   //   the residual iterations are more than 10% of the trip count
 799   //   and rounds of &quot;unroll,optimize&quot; are not making significant progress
 800   //   Progress defined as current size less than 20% larger than previous size.
 801   if (UseSuperWord &amp;&amp; cl-&gt;node_count_before_unroll() &gt; 0 &amp;&amp;
 802       future_unroll_cnt &gt; LoopUnrollMin &amp;&amp;
 803       (future_unroll_cnt - 1) * (100 / LoopPercentProfileLimit) &gt; cl-&gt;profile_trip_cnt() &amp;&amp;
 804       1.2 * cl-&gt;node_count_before_unroll() &lt; (double)_body.size()) {
 805     return false;
 806   }
 807 
 808   Node *init_n = cl-&gt;init_trip();
 809   Node *limit_n = cl-&gt;limit();
 810   int stride_con = cl-&gt;stride_con();
 811   if (limit_n == NULL) return false; // We will dereference it below.
 812 
 813   // Non-constant bounds.
 814   // Protect against over-unrolling when init or/and limit are not constant
 815   // (so that trip_count&#39;s init value is maxint) but iv range is known.
 816   if (init_n == NULL || !init_n-&gt;is_Con() || !limit_n-&gt;is_Con()) {
 817     Node* phi = cl-&gt;phi();
 818     if (phi != NULL) {
 819       assert(phi-&gt;is_Phi() &amp;&amp; phi-&gt;in(0) == _head, &quot;Counted loop should have iv phi.&quot;);
 820       const TypeInt* iv_type = phase-&gt;_igvn.type(phi)-&gt;is_int();
 821       int next_stride = stride_con * 2; // stride after this unroll
 822       if (next_stride &gt; 0) {
 823         if (iv_type-&gt;_lo + next_stride &lt;= iv_type-&gt;_lo || // overflow
 824             iv_type-&gt;_lo + next_stride &gt;  iv_type-&gt;_hi) {
 825           return false;  // over-unrolling
 826         }
 827       } else if (next_stride &lt; 0) {
 828         if (iv_type-&gt;_hi + next_stride &gt;= iv_type-&gt;_hi || // overflow
 829             iv_type-&gt;_hi + next_stride &lt;  iv_type-&gt;_lo) {
 830           return false;  // over-unrolling
 831         }
 832       }
 833     }
 834   }
 835 
 836   // After unroll limit will be adjusted: new_limit = limit-stride.
 837   // Bailout if adjustment overflow.
 838   const TypeInt* limit_type = phase-&gt;_igvn.type(limit_n)-&gt;is_int();
 839   if ((stride_con &gt; 0 &amp;&amp; ((limit_type-&gt;_hi - stride_con) &gt;= limit_type-&gt;_hi)) ||
 840       (stride_con &lt; 0 &amp;&amp; ((limit_type-&gt;_lo - stride_con) &lt;= limit_type-&gt;_lo)))
 841     return false;  // overflow
 842 
 843   // Adjust body_size to determine if we unroll or not
 844   uint body_size = _body.size();
 845   // Key test to unroll loop in CRC32 java code
 846   int xors_in_loop = 0;
 847   // Also count ModL, DivL and MulL which expand mightly
 848   for (uint k = 0; k &lt; _body.size(); k++) {
 849     Node* n = _body.at(k);
 850     switch (n-&gt;Opcode()) {
 851       case Op_XorI: xors_in_loop++; break; // CRC32 java code
 852       case Op_ModL: body_size += 30; break;
 853       case Op_DivL: body_size += 30; break;
 854       case Op_MulL: body_size += 10; break;
 855       case Op_StrComp:
 856       case Op_StrEquals:
 857       case Op_StrIndexOf:
 858       case Op_StrIndexOfChar:
 859       case Op_EncodeISOArray:
 860       case Op_AryEq:
 861       case Op_HasNegatives: {
 862         // Do not unroll a loop with String intrinsics code.
 863         // String intrinsics are large and have loops.
 864         return false;
 865       }
 866 #if INCLUDE_RTM_OPT
 867       case Op_FastLock:
 868       case Op_FastUnlock: {
 869         // Don&#39;t unroll RTM locking code because it is large.
 870         if (UseRTMLocking) {
 871           return false;
 872         }
 873       }
 874 #endif
 875     } // switch
 876   }
 877 
 878   if (UseSuperWord) {
 879     if (!cl-&gt;is_reduction_loop()) {
 880       phase-&gt;mark_reductions(this);
 881     }
 882 
 883     // Only attempt slp analysis when user controls do not prohibit it
 884     if (LoopMaxUnroll &gt; _local_loop_unroll_factor) {
 885       // Once policy_slp_analysis succeeds, mark the loop with the
 886       // maximal unroll factor so that we minimize analysis passes
 887       if (future_unroll_cnt &gt;= _local_loop_unroll_factor) {
 888         policy_unroll_slp_analysis(cl, phase, future_unroll_cnt);
 889       }
 890     }
 891   }
 892 
 893   int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
 894   if ((LoopMaxUnroll &lt; slp_max_unroll_factor) &amp;&amp; FLAG_IS_DEFAULT(LoopMaxUnroll) &amp;&amp; UseSubwordForMaxVector) {
 895     LoopMaxUnroll = slp_max_unroll_factor;
 896   }
 897 
 898   uint estimate = est_loop_clone_sz(2);
 899 
 900   if (cl-&gt;has_passed_slp()) {
 901     if (slp_max_unroll_factor &gt;= future_unroll_cnt) {
 902       return phase-&gt;may_require_nodes(estimate);
 903     }
 904     return false; // Loop too big.
 905   }
 906 
 907   // Check for being too big
 908   if (body_size &gt; (uint)_local_loop_unroll_limit) {
 909     if ((cl-&gt;is_subword_loop() || xors_in_loop &gt;= 4) &amp;&amp; body_size &lt; 4u * LoopUnrollLimit) {
 910       return phase-&gt;may_require_nodes(estimate);
 911     }
 912     return false; // Loop too big.
 913   }
 914 
 915   if (cl-&gt;is_unroll_only()) {
 916     if (TraceSuperWordLoopUnrollAnalysis) {
 917       tty-&gt;print_cr(&quot;policy_unroll passed vector loop(vlen=%d, factor=%d)\n&quot;,
 918                     slp_max_unroll_factor, future_unroll_cnt);
 919     }
 920   }
 921 
 922   // Unroll once!  (Each trip will soon do double iterations)
 923   return phase-&gt;may_require_nodes(estimate);
 924 }
 925 
 926 void IdealLoopTree::policy_unroll_slp_analysis(CountedLoopNode *cl, PhaseIdealLoop *phase, int future_unroll_cnt) {
 927 
 928   // If nodes are depleted, some transform has miscalculated its needs.
 929   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);
 930 
 931   // Enable this functionality target by target as needed
 932   if (SuperWordLoopUnrollAnalysis) {
 933     if (!cl-&gt;was_slp_analyzed()) {
 934       SuperWord sw(phase);
 935       sw.transform_loop(this, false);
 936 
 937       // If the loop is slp canonical analyze it
 938       if (sw.early_return() == false) {
 939         sw.unrolling_analysis(_local_loop_unroll_factor);
 940       }
 941     }
 942 
 943     if (cl-&gt;has_passed_slp()) {
 944       int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
 945       if (slp_max_unroll_factor &gt;= future_unroll_cnt) {
 946         int new_limit = cl-&gt;node_count_before_unroll() * slp_max_unroll_factor;
 947         if (new_limit &gt; LoopUnrollLimit) {
 948           if (TraceSuperWordLoopUnrollAnalysis) {
 949             tty-&gt;print_cr(&quot;slp analysis unroll=%d, default limit=%d\n&quot;, new_limit, _local_loop_unroll_limit);
 950           }
 951           _local_loop_unroll_limit = new_limit;
 952         }
 953       }
 954     }
 955   }
 956 }
 957 
 958 //------------------------------policy_align-----------------------------------
 959 // Return TRUE or FALSE if the loop should be cache-line aligned.  Gather the
 960 // expression that does the alignment.  Note that only one array base can be
 961 // aligned in a loop (unless the VM guarantees mutual alignment).  Note that
 962 // if we vectorize short memory ops into longer memory ops, we may want to
 963 // increase alignment.
 964 bool IdealLoopTree::policy_align(PhaseIdealLoop *phase) const {
 965   return false;
 966 }
 967 
 968 //------------------------------policy_range_check-----------------------------
 969 // Return TRUE or FALSE if the loop should be range-check-eliminated or not.
 970 // When TRUE, the estimated node budget is also requested.
 971 //
 972 // We will actually perform iteration-splitting, a more powerful form of RCE.
 973 bool IdealLoopTree::policy_range_check(PhaseIdealLoop *phase) const {
 974   if (!RangeCheckElimination) return false;
 975 
 976   // If nodes are depleted, some transform has miscalculated its needs.
 977   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);
 978 
 979   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
 980   // If we unrolled  with no intention of doing RCE and we  later changed our
 981   // minds, we got no pre-loop.  Either we need to make a new pre-loop, or we
 982   // have to disallow RCE.
 983   if (cl-&gt;is_main_no_pre_loop()) return false; // Disallowed for now.
 984   Node *trip_counter = cl-&gt;phi();
 985 
 986   // check for vectorized loops, some opts are no longer needed
 987   if (cl-&gt;is_unroll_only()) return false;
 988 
 989   // Check loop body for tests of trip-counter plus loop-invariant vs
 990   // loop-invariant.
 991   for (uint i = 0; i &lt; _body.size(); i++) {
 992     Node *iff = _body[i];
 993     if (iff-&gt;Opcode() == Op_If ||
 994         iff-&gt;Opcode() == Op_RangeCheck) { // Test?
 995 
 996       // Comparing trip+off vs limit
 997       Node *bol = iff-&gt;in(1);
 998       if (bol-&gt;req() != 2) {
 999         continue; // dead constant test
1000       }
1001       if (!bol-&gt;is_Bool()) {
1002         assert(bol-&gt;Opcode() == Op_Conv2B, &quot;predicate check only&quot;);
1003         continue;
1004       }
1005       if (bol-&gt;as_Bool()-&gt;_test._test == BoolTest::ne) {
1006         continue; // not RC
1007       }
1008       Node *cmp = bol-&gt;in(1);
1009       Node *rc_exp = cmp-&gt;in(1);
1010       Node *limit = cmp-&gt;in(2);
1011 
1012       Node *limit_c = phase-&gt;get_ctrl(limit);
1013       if (limit_c == phase-&gt;C-&gt;top()) {
1014         return false;           // Found dead test on live IF?  No RCE!
1015       }
1016       if (is_member(phase-&gt;get_loop(limit_c))) {
1017         // Compare might have operands swapped; commute them
1018         rc_exp = cmp-&gt;in(2);
1019         limit  = cmp-&gt;in(1);
1020         limit_c = phase-&gt;get_ctrl(limit);
1021         if (is_member(phase-&gt;get_loop(limit_c))) {
1022           continue;             // Both inputs are loop varying; cannot RCE
1023         }
1024       }
1025 
1026       if (!phase-&gt;is_scaled_iv_plus_offset(rc_exp, trip_counter, NULL, NULL)) {
1027         continue;
1028       }
1029       // Found a test like &#39;trip+off vs limit&#39;. Test is an IfNode, has two (2)
1030       // projections. If BOTH are in the loop we need loop unswitching instead
1031       // of iteration splitting.
1032       if (is_loop_exit(iff)) {
1033         // Found valid reason to split iterations (if there is room).
1034         // NOTE: Usually a gross overestimate.
1035         return phase-&gt;may_require_nodes(est_loop_clone_sz(2));
1036       }
1037     } // End of is IF
1038   }
1039 
1040   return false;
1041 }
1042 
1043 //------------------------------policy_peel_only-------------------------------
1044 // Return TRUE or FALSE if the loop should NEVER be RCE&#39;d or aligned.  Useful
1045 // for unrolling loops with NO array accesses.
1046 bool IdealLoopTree::policy_peel_only(PhaseIdealLoop *phase) const {
1047 
1048   // If nodes are depleted, some transform has miscalculated its needs.
1049   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);
1050 
1051   // check for vectorized loops, any peeling done was already applied
1052   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;is_unroll_only()) {
1053     return false;
1054   }
1055 
1056   for (uint i = 0; i &lt; _body.size(); i++) {
1057     if (_body[i]-&gt;is_Mem()) {
1058       return false;
1059     }
1060   }
1061   // No memory accesses at all!
1062   return true;
1063 }
1064 
1065 //------------------------------clone_up_backedge_goo--------------------------
1066 // If Node n lives in the back_ctrl block and cannot float, we clone a private
1067 // version of n in preheader_ctrl block and return that, otherwise return n.
1068 Node *PhaseIdealLoop::clone_up_backedge_goo(Node *back_ctrl, Node *preheader_ctrl, Node *n, VectorSet &amp;visited, Node_Stack &amp;clones) {
1069   if (get_ctrl(n) != back_ctrl) return n;
1070 
1071   // Only visit once
1072   if (visited.test_set(n-&gt;_idx)) {
1073     Node *x = clones.find(n-&gt;_idx);
1074     return (x != NULL) ? x : n;
1075   }
1076 
1077   Node *x = NULL;               // If required, a clone of &#39;n&#39;
1078   // Check for &#39;n&#39; being pinned in the backedge.
1079   if (n-&gt;in(0) &amp;&amp; n-&gt;in(0) == back_ctrl) {
1080     assert(clones.find(n-&gt;_idx) == NULL, &quot;dead loop&quot;);
1081     x = n-&gt;clone();             // Clone a copy of &#39;n&#39; to preheader
1082     clones.push(x, n-&gt;_idx);
1083     x-&gt;set_req(0, preheader_ctrl); // Fix x&#39;s control input to preheader
1084   }
1085 
1086   // Recursive fixup any other input edges into x.
1087   // If there are no changes we can just return &#39;n&#39;, otherwise
1088   // we need to clone a private copy and change it.
1089   for (uint i = 1; i &lt; n-&gt;req(); i++) {
1090     Node *g = clone_up_backedge_goo(back_ctrl, preheader_ctrl, n-&gt;in(i), visited, clones);
1091     if (g != n-&gt;in(i)) {
1092       if (!x) {
1093         assert(clones.find(n-&gt;_idx) == NULL, &quot;dead loop&quot;);
1094         x = n-&gt;clone();
1095         clones.push(x, n-&gt;_idx);
1096       }
1097       x-&gt;set_req(i, g);
1098     }
1099   }
1100   if (x) {                     // x can legally float to pre-header location
1101     register_new_node(x, preheader_ctrl);
1102     return x;
1103   } else {                      // raise n to cover LCA of uses
1104     set_ctrl(n, find_non_split_ctrl(back_ctrl-&gt;in(0)));
1105   }
1106   return n;
1107 }
1108 
1109 Node* PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop) {
1110   Node* castii = new CastIINode(incr, TypeInt::INT, true);
1111   castii-&gt;set_req(0, ctrl);
1112   register_new_node(castii, ctrl);
1113   for (DUIterator_Fast imax, i = incr-&gt;fast_outs(imax); i &lt; imax; i++) {
1114     Node* n = incr-&gt;fast_out(i);
1115     if (n-&gt;is_Phi() &amp;&amp; n-&gt;in(0) == loop) {
1116       int nrep = n-&gt;replace_edge(incr, castii);
1117       return castii;
1118     }
1119   }
1120   return NULL;
1121 }
1122 
1123 #ifdef ASSERT
1124 void PhaseIdealLoop::ensure_zero_trip_guard_proj(Node* node, bool is_main_loop) {
1125   assert(node-&gt;is_IfProj(), &quot;must be the zero trip guard If node&quot;);
1126   Node* zer_bol = node-&gt;in(0)-&gt;in(1);
1127   assert(zer_bol != NULL &amp;&amp; zer_bol-&gt;is_Bool(), &quot;must be Bool&quot;);
1128   Node* zer_cmp = zer_bol-&gt;in(1);
1129   assert(zer_cmp != NULL &amp;&amp; zer_cmp-&gt;Opcode() == Op_CmpI, &quot;must be CmpI&quot;);
1130   // For the main loop, the opaque node is the second input to zer_cmp, for the post loop it&#39;s the first input node
1131   Node* zer_opaq = zer_cmp-&gt;in(is_main_loop ? 2 : 1);
1132   assert(zer_opaq != NULL &amp;&amp; zer_opaq-&gt;Opcode() == Op_Opaque1, &quot;must be Opaque1&quot;);
1133 }
1134 #endif
1135 
1136 // Make a copy of the skeleton range check predicates before the main
1137 // loop and set the initial value of loop as input. After unrolling,
1138 // the range of values for the induction variable in the main loop can
1139 // fall outside the allowed range of values by the array access (main
1140 // loop is never executed). When that happens, range check
1141 // CastII/ConvI2L nodes cause some data paths to die. For consistency,
1142 // the control paths must die too but the range checks were removed by
1143 // predication. The range checks that we add here guarantee that they do.
1144 void PhaseIdealLoop::copy_skeleton_predicates_to_main_loop_helper(Node* predicate, Node* init, Node* stride,
1145                                                  IdealLoopTree* outer_loop, LoopNode* outer_main_head,
1146                                                  uint dd_main_head, const uint idx_before_pre_post,
1147                                                  const uint idx_after_post_before_pre, Node* zero_trip_guard_proj_main,
1148                                                  Node* zero_trip_guard_proj_post, const Node_List &amp;old_new) {
1149   if (predicate != NULL) {
1150 #ifdef ASSERT
1151     ensure_zero_trip_guard_proj(zero_trip_guard_proj_main, true);
1152     ensure_zero_trip_guard_proj(zero_trip_guard_proj_post, false);
1153 #endif
1154     IfNode* iff = predicate-&gt;in(0)-&gt;as_If();
1155     ProjNode* uncommon_proj = iff-&gt;proj_out(1 - predicate-&gt;as_Proj()-&gt;_con);
1156     Node* rgn = uncommon_proj-&gt;unique_ctrl_out();
1157     assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
1158     assert(iff-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_Opaque1, &quot;unexpected predicate shape&quot;);
1159     predicate = iff-&gt;in(0);
1160     Node* current_proj = outer_main_head-&gt;in(LoopNode::EntryControl);
1161     Node* prev_proj = current_proj;
1162     Node* opaque_init = new OpaqueLoopInitNode(C, init);
1163     register_new_node(opaque_init, outer_main_head-&gt;in(LoopNode::EntryControl));
1164     Node* opaque_stride = new OpaqueLoopStrideNode(C, stride);
1165     register_new_node(opaque_stride, outer_main_head-&gt;in(LoopNode::EntryControl));
1166 
1167     while (predicate != NULL &amp;&amp; predicate-&gt;is_Proj() &amp;&amp; predicate-&gt;in(0)-&gt;is_If()) {
1168       iff = predicate-&gt;in(0)-&gt;as_If();
1169       uncommon_proj = iff-&gt;proj_out(1 - predicate-&gt;as_Proj()-&gt;_con);
1170       if (uncommon_proj-&gt;unique_ctrl_out() != rgn)
1171         break;
1172       if (iff-&gt;in(1)-&gt;Opcode() == Op_Opaque4) {
1173         assert(skeleton_predicate_has_opaque(iff), &quot;unexpected&quot;);
1174         // Clone the skeleton predicate twice and initialize one with the initial
1175         // value of the loop induction variable. Leave the other predicate
1176         // to be initialized when increasing the stride during loop unrolling.
1177         prev_proj = clone_skeleton_predicate(iff, opaque_init, NULL, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);
1178         assert(skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()), &quot;&quot;);
1179 
1180         prev_proj = clone_skeleton_predicate(iff, init, stride, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);
1181         assert(!skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()), &quot;&quot;);
1182 
1183         // Rewire any control inputs from the cloned skeleton predicates down to the main and post loop for data nodes that are part of the
1184         // main loop (and were cloned to the pre and post loop).
1185         for (DUIterator i = predicate-&gt;outs(); predicate-&gt;has_out(i); i++) {
1186           Node* loop_node = predicate-&gt;out(i);
1187           Node* pre_loop_node = old_new[loop_node-&gt;_idx];
1188           // Change the control if &#39;loop_node&#39; is part of the main loop. If there is an old-&gt;new mapping and the index of
1189           // &#39;pre_loop_node&#39; is greater than idx_before_pre_post, then we know that &#39;loop_node&#39; was cloned and is part of
1190           // the main loop (and &#39;pre_loop_node&#39; is part of the pre loop).
1191           if (!loop_node-&gt;is_CFG() &amp;&amp; (pre_loop_node != NULL &amp;&amp; pre_loop_node-&gt;_idx &gt; idx_after_post_before_pre)) {
1192             // &#39;loop_node&#39; is a data node and part of the main loop. Rewire the control to the projection of the zero-trip guard if node
1193             // of the main loop that is immediately preceding the cloned predicates.
1194             _igvn.replace_input_of(loop_node, 0, zero_trip_guard_proj_main);
1195             --i;
1196           } else if (loop_node-&gt;_idx &gt; idx_before_pre_post &amp;&amp; loop_node-&gt;_idx &lt; idx_after_post_before_pre) {
1197             // &#39;loop_node&#39; is a data node and part of the post loop. Rewire the control to the projection of the zero-trip guard if node
1198             // of the post loop that is immediately preceding the post loop header node (there are no cloned predicates for the post loop).
1199             assert(pre_loop_node == NULL, &quot;a node belonging to the post loop should not have an old_new mapping at this stage&quot;);
1200             _igvn.replace_input_of(loop_node, 0, zero_trip_guard_proj_post);
1201             --i;
1202           }
1203         }
1204 
1205         // Remove the skeleton predicate from the pre-loop
1206         _igvn.replace_input_of(iff, 1, _igvn.intcon(1));
1207       }
1208       predicate = predicate-&gt;in(0)-&gt;in(0);
1209     }
1210     _igvn.replace_input_of(outer_main_head, LoopNode::EntryControl, prev_proj);
1211     set_idom(outer_main_head, prev_proj, dd_main_head);
1212   }
1213 }
1214 
1215 static bool skeleton_follow_inputs(Node* n, int op) {
1216   return (n-&gt;is_Bool() ||
1217           n-&gt;is_Cmp() ||
1218           op == Op_AndL ||
1219           op == Op_OrL ||
1220           op == Op_RShiftL ||
1221           op == Op_LShiftL ||
1222           op == Op_AddL ||
1223           op == Op_AddI ||
1224           op == Op_MulL ||
1225           op == Op_MulI ||
1226           op == Op_SubL ||
1227           op == Op_SubI ||
1228           op == Op_ConvI2L);
1229 }
1230 
1231 bool PhaseIdealLoop::skeleton_predicate_has_opaque(IfNode* iff) {
1232   ResourceMark rm;
1233   Unique_Node_List wq;
1234   wq.push(iff-&gt;in(1)-&gt;in(1));
1235   for (uint i = 0; i &lt; wq.size(); i++) {
1236     Node* n = wq.at(i);
1237     int op = n-&gt;Opcode();
1238     if (skeleton_follow_inputs(n, op)) {
1239       for (uint j = 1; j &lt; n-&gt;req(); j++) {
1240         Node* m = n-&gt;in(j);
1241         if (m != NULL) {
1242           wq.push(m);
1243         }
1244       }
1245       continue;
1246     }
1247     if (n-&gt;is_Opaque1()) {
1248       return true;
1249     }
1250   }
1251   return false;
1252 }
1253 
1254 Node* PhaseIdealLoop::clone_skeleton_predicate(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,
1255                                                Node* current_proj, IdealLoopTree* outer_loop, Node* prev_proj) {
1256   Node_Stack to_clone(2);
1257   to_clone.push(iff-&gt;in(1), 1);
1258   uint current = C-&gt;unique();
1259   Node* result = NULL;
1260   // Look for the opaque node to replace with the new value
1261   // and clone everything in between. We keep the Opaque4 node
1262   // so the duplicated predicates are eliminated once loop
1263   // opts are over: they are here only to keep the IR graph
1264   // consistent.
1265   do {
1266     Node* n = to_clone.node();
1267     uint i = to_clone.index();
1268     Node* m = n-&gt;in(i);
1269     int op = m-&gt;Opcode();
1270     if (skeleton_follow_inputs(m, op)) {
1271         to_clone.push(m, 1);
1272         continue;
1273     }
1274     if (m-&gt;is_Opaque1()) {
1275       if (n-&gt;_idx &lt; current) {
1276         n = n-&gt;clone();
1277         register_new_node(n, current_proj);
1278       }
1279       if (op == Op_OpaqueLoopInit) {
1280         n-&gt;set_req(i, new_init);
1281       } else {
1282         assert(op == Op_OpaqueLoopStride, &quot;unexpected opaque node&quot;);
1283         if (new_stride != NULL) {
1284           n-&gt;set_req(i, new_stride);
1285         }
1286       }
1287       to_clone.set_node(n);
1288     }
1289     for (;;) {
1290       Node* cur = to_clone.node();
1291       uint j = to_clone.index();
1292       if (j+1 &lt; cur-&gt;req()) {
1293         to_clone.set_index(j+1);
1294         break;
1295       }
1296       to_clone.pop();
1297       if (to_clone.size() == 0) {
1298         result = cur;
1299         break;
1300       }
1301       Node* next = to_clone.node();
1302       j = to_clone.index();
1303       if (next-&gt;in(j) != cur) {
1304         assert(cur-&gt;_idx &gt;= current || next-&gt;in(j)-&gt;Opcode() == Op_Opaque1, &quot;new node or Opaque1 being replaced&quot;);
1305         if (next-&gt;_idx &lt; current) {
1306           next = next-&gt;clone();
1307           register_new_node(next, current_proj);
1308           to_clone.set_node(next);
1309         }
1310         next-&gt;set_req(j, cur);
1311       }
1312     }
1313   } while (result == NULL);
1314   assert(result-&gt;_idx &gt;= current, &quot;new node expected&quot;);
1315 
1316   Node* proj = predicate-&gt;clone();
1317   Node* other_proj = uncommon_proj-&gt;clone();
1318   Node* new_iff = iff-&gt;clone();
1319   new_iff-&gt;set_req(1, result);
1320   proj-&gt;set_req(0, new_iff);
1321   other_proj-&gt;set_req(0, new_iff);
1322   Node *frame = new ParmNode(C-&gt;start(), TypeFunc::FramePtr);
1323   register_new_node(frame, C-&gt;start());
1324   // It&#39;s impossible for the predicate to fail at runtime. Use an Halt node.
1325   Node* halt = new HaltNode(other_proj, frame, &quot;duplicated predicate failed which is impossible&quot;);
1326   C-&gt;root()-&gt;add_req(halt);
1327   new_iff-&gt;set_req(0, prev_proj);
1328 
1329   register_control(new_iff, outer_loop-&gt;_parent, prev_proj);
1330   register_control(proj, outer_loop-&gt;_parent, new_iff);
1331   register_control(other_proj, _ltree_root, new_iff);
1332   register_control(halt, _ltree_root, other_proj);
1333   return proj;
1334 }
1335 
1336 void PhaseIdealLoop::copy_skeleton_predicates_to_main_loop(CountedLoopNode* pre_head, Node* init, Node* stride,
1337                                           IdealLoopTree* outer_loop, LoopNode* outer_main_head,
1338                                           uint dd_main_head, const uint idx_before_pre_post,
1339                                           const uint idx_after_post_before_pre, Node* zero_trip_guard_proj_main,
1340                                           Node* zero_trip_guard_proj_post, const Node_List &amp;old_new) {
1341   if (UseLoopPredicate) {
1342     Node* entry = pre_head-&gt;in(LoopNode::EntryControl);
1343     Node* predicate = NULL;
1344     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
1345     if (predicate != NULL) {
1346       entry = skip_loop_predicates(entry);
1347     }
1348     Node* profile_predicate = NULL;
1349     if (UseProfiledLoopPredicate) {
1350       profile_predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
1351       if (profile_predicate != NULL) {
1352         entry = skip_loop_predicates(entry);
1353       }
1354     }
1355     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
1356     copy_skeleton_predicates_to_main_loop_helper(predicate, init, stride, outer_loop, outer_main_head, dd_main_head,
1357                                                  idx_before_pre_post, idx_after_post_before_pre, zero_trip_guard_proj_main,
1358                                                  zero_trip_guard_proj_post, old_new);
1359     copy_skeleton_predicates_to_main_loop_helper(profile_predicate, init, stride, outer_loop, outer_main_head, dd_main_head,
1360                                                  idx_before_pre_post, idx_after_post_before_pre, zero_trip_guard_proj_main,
1361                                                  zero_trip_guard_proj_post, old_new);
1362   }
1363 }
1364 
1365 //------------------------------insert_pre_post_loops--------------------------
1366 // Insert pre and post loops.  If peel_only is set, the pre-loop can not have
1367 // more iterations added.  It acts as a &#39;peel&#39; only, no lower-bound RCE, no
1368 // alignment.  Useful to unroll loops that do no array accesses.
1369 void PhaseIdealLoop::insert_pre_post_loops(IdealLoopTree *loop, Node_List &amp;old_new, bool peel_only) {
1370 
1371 #ifndef PRODUCT
1372   if (TraceLoopOpts) {
1373     if (peel_only)
1374       tty-&gt;print(&quot;PeelMainPost &quot;);
1375     else
1376       tty-&gt;print(&quot;PreMainPost  &quot;);
1377     loop-&gt;dump_head();
1378   }
1379 #endif
1380   C-&gt;set_major_progress();
1381 
1382   // Find common pieces of the loop being guarded with pre &amp; post loops
1383   CountedLoopNode *main_head = loop-&gt;_head-&gt;as_CountedLoop();
1384   assert(main_head-&gt;is_normal_loop(), &quot;&quot;);
1385   CountedLoopEndNode *main_end = main_head-&gt;loopexit();
1386   assert(main_end-&gt;outcnt() == 2, &quot;1 true, 1 false path only&quot;);
1387 
1388   Node *pre_header= main_head-&gt;in(LoopNode::EntryControl);
1389   Node *init      = main_head-&gt;init_trip();
1390   Node *incr      = main_end -&gt;incr();
1391   Node *limit     = main_end -&gt;limit();
1392   Node *stride    = main_end -&gt;stride();
1393   Node *cmp       = main_end -&gt;cmp_node();
1394   BoolTest::mask b_test = main_end-&gt;test_trip();
1395 
1396   // Need only 1 user of &#39;bol&#39; because I will be hacking the loop bounds.
1397   Node *bol = main_end-&gt;in(CountedLoopEndNode::TestValue);
1398   if (bol-&gt;outcnt() != 1) {
1399     bol = bol-&gt;clone();
1400     register_new_node(bol,main_end-&gt;in(CountedLoopEndNode::TestControl));
1401     _igvn.replace_input_of(main_end, CountedLoopEndNode::TestValue, bol);
1402   }
1403   // Need only 1 user of &#39;cmp&#39; because I will be hacking the loop bounds.
1404   if (cmp-&gt;outcnt() != 1) {
1405     cmp = cmp-&gt;clone();
1406     register_new_node(cmp,main_end-&gt;in(CountedLoopEndNode::TestControl));
1407     _igvn.replace_input_of(bol, 1, cmp);
1408   }
1409 
1410   // Add the post loop
1411   const uint idx_before_pre_post = Compile::current()-&gt;unique();
1412   CountedLoopNode *post_head = NULL;
1413   Node *main_exit = insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);
1414   const uint idx_after_post_before_pre = Compile::current()-&gt;unique();
1415 
1416   //------------------------------
1417   // Step B: Create Pre-Loop.
1418 
1419   // Step B1: Clone the loop body.  The clone becomes the pre-loop.  The main
1420   // loop pre-header illegally has 2 control users (old &amp; new loops).
1421   LoopNode* outer_main_head = main_head;
1422   IdealLoopTree* outer_loop = loop;
1423   if (main_head-&gt;is_strip_mined()) {
1424     main_head-&gt;verify_strip_mined(1);
1425     outer_main_head = main_head-&gt;outer_loop();
1426     outer_loop = loop-&gt;_parent;
1427     assert(outer_loop-&gt;_head == outer_main_head, &quot;broken loop tree&quot;);
1428   }
1429   uint dd_main_head = dom_depth(outer_main_head);
1430   clone_loop(loop, old_new, dd_main_head, ControlAroundStripMined);
1431   CountedLoopNode*    pre_head = old_new[main_head-&gt;_idx]-&gt;as_CountedLoop();
1432   CountedLoopEndNode* pre_end  = old_new[main_end -&gt;_idx]-&gt;as_CountedLoopEnd();
1433   pre_head-&gt;set_pre_loop(main_head);
1434   Node *pre_incr = old_new[incr-&gt;_idx];
1435 
1436   // Reduce the pre-loop trip count.
1437   pre_end-&gt;_prob = PROB_FAIR;
1438 
1439   // Find the pre-loop normal exit.
1440   Node* pre_exit = pre_end-&gt;proj_out(false);
1441   assert(pre_exit-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
1442   IfFalseNode *new_pre_exit = new IfFalseNode(pre_end);
1443   _igvn.register_new_node_with_optimizer(new_pre_exit);
1444   set_idom(new_pre_exit, pre_end, dd_main_head);
1445   set_loop(new_pre_exit, outer_loop-&gt;_parent);
1446 
1447   // Step B2: Build a zero-trip guard for the main-loop.  After leaving the
1448   // pre-loop, the main-loop may not execute at all.  Later in life this
1449   // zero-trip guard will become the minimum-trip guard when we unroll
1450   // the main-loop.
1451   Node *min_opaq = new Opaque1Node(C, limit);
1452   Node *min_cmp  = new CmpINode(pre_incr, min_opaq);
1453   Node *min_bol  = new BoolNode(min_cmp, b_test);
1454   register_new_node(min_opaq, new_pre_exit);
1455   register_new_node(min_cmp , new_pre_exit);
1456   register_new_node(min_bol , new_pre_exit);
1457 
1458   // Build the IfNode (assume the main-loop is executed always).
1459   IfNode *min_iff = new IfNode(new_pre_exit, min_bol, PROB_ALWAYS, COUNT_UNKNOWN);
1460   _igvn.register_new_node_with_optimizer(min_iff);
1461   set_idom(min_iff, new_pre_exit, dd_main_head);
1462   set_loop(min_iff, outer_loop-&gt;_parent);
1463 
1464   // Plug in the false-path, taken if we need to skip main-loop
1465   _igvn.hash_delete(pre_exit);
1466   pre_exit-&gt;set_req(0, min_iff);
1467   set_idom(pre_exit, min_iff, dd_main_head);
1468   set_idom(pre_exit-&gt;unique_ctrl_out(), min_iff, dd_main_head);
1469   // Make the true-path, must enter the main loop
1470   Node *min_taken = new IfTrueNode(min_iff);
1471   _igvn.register_new_node_with_optimizer(min_taken);
1472   set_idom(min_taken, min_iff, dd_main_head);
1473   set_loop(min_taken, outer_loop-&gt;_parent);
1474   // Plug in the true path
1475   _igvn.hash_delete(outer_main_head);
1476   outer_main_head-&gt;set_req(LoopNode::EntryControl, min_taken);
1477   set_idom(outer_main_head, min_taken, dd_main_head);
1478 
1479   VectorSet visited;
1480   Node_Stack clones(main_head-&gt;back_control()-&gt;outcnt());
1481   // Step B3: Make the fall-in values to the main-loop come from the
1482   // fall-out values of the pre-loop.
1483   for (DUIterator_Fast i2max, i2 = main_head-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1484     Node* main_phi = main_head-&gt;fast_out(i2);
1485     if (main_phi-&gt;is_Phi() &amp;&amp; main_phi-&gt;in(0) == main_head &amp;&amp; main_phi-&gt;outcnt() &gt; 0) {
1486       Node *pre_phi = old_new[main_phi-&gt;_idx];
1487       Node *fallpre  = clone_up_backedge_goo(pre_head-&gt;back_control(),
1488                                              main_head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl),
1489                                              pre_phi-&gt;in(LoopNode::LoopBackControl),
1490                                              visited, clones);
1491       _igvn.hash_delete(main_phi);
1492       main_phi-&gt;set_req(LoopNode::EntryControl, fallpre);
1493     }
1494   }
1495 
1496   // Nodes inside the loop may be control dependent on a predicate
1497   // that was moved before the preloop. If the back branch of the main
1498   // or post loops becomes dead, those nodes won&#39;t be dependent on the
1499   // test that guards that loop nest anymore which could lead to an
1500   // incorrect array access because it executes independently of the
1501   // test that was guarding the loop nest. We add a special CastII on
1502   // the if branch that enters the loop, between the input induction
1503   // variable value and the induction variable Phi to preserve correct
1504   // dependencies.
1505 
1506   // CastII for the main loop:
1507   Node* castii = cast_incr_before_loop(pre_incr, min_taken, main_head);
1508   assert(castii != NULL, &quot;no castII inserted&quot;);
1509   assert(post_head-&gt;in(1)-&gt;is_IfProj(), &quot;must be zero-trip guard If node projection of the post loop&quot;);
1510   copy_skeleton_predicates_to_main_loop(pre_head, castii, stride, outer_loop, outer_main_head, dd_main_head,
1511                                         idx_before_pre_post, idx_after_post_before_pre, min_taken, post_head-&gt;in(1), old_new);
1512 
1513   // Step B4: Shorten the pre-loop to run only 1 iteration (for now).
1514   // RCE and alignment may change this later.
1515   Node *cmp_end = pre_end-&gt;cmp_node();
1516   assert(cmp_end-&gt;in(2) == limit, &quot;&quot;);
1517   Node *pre_limit = new AddINode(init, stride);
1518 
1519   // Save the original loop limit in this Opaque1 node for
1520   // use by range check elimination.
1521   Node *pre_opaq  = new Opaque1Node(C, pre_limit, limit);
1522 
1523   register_new_node(pre_limit, pre_head-&gt;in(0));
1524   register_new_node(pre_opaq , pre_head-&gt;in(0));
1525 
1526   // Since no other users of pre-loop compare, I can hack limit directly
1527   assert(cmp_end-&gt;outcnt() == 1, &quot;no other users&quot;);
1528   _igvn.hash_delete(cmp_end);
1529   cmp_end-&gt;set_req(2, peel_only ? pre_limit : pre_opaq);
1530 
1531   // Special case for not-equal loop bounds:
1532   // Change pre loop test, main loop test, and the
1533   // main loop guard test to use lt or gt depending on stride
1534   // direction:
1535   // positive stride use &lt;
1536   // negative stride use &gt;
1537   //
1538   // not-equal test is kept for post loop to handle case
1539   // when init &gt; limit when stride &gt; 0 (and reverse).
1540 
1541   if (pre_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne) {
1542 
1543     BoolTest::mask new_test = (main_end-&gt;stride_con() &gt; 0) ? BoolTest::lt : BoolTest::gt;
1544     // Modify pre loop end condition
1545     Node* pre_bol = pre_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();
1546     BoolNode* new_bol0 = new BoolNode(pre_bol-&gt;in(1), new_test);
1547     register_new_node(new_bol0, pre_head-&gt;in(0));
1548     _igvn.replace_input_of(pre_end, CountedLoopEndNode::TestValue, new_bol0);
1549     // Modify main loop guard condition
1550     assert(min_iff-&gt;in(CountedLoopEndNode::TestValue) == min_bol, &quot;guard okay&quot;);
1551     BoolNode* new_bol1 = new BoolNode(min_bol-&gt;in(1), new_test);
1552     register_new_node(new_bol1, new_pre_exit);
1553     _igvn.hash_delete(min_iff);
1554     min_iff-&gt;set_req(CountedLoopEndNode::TestValue, new_bol1);
1555     // Modify main loop end condition
1556     BoolNode* main_bol = main_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();
1557     BoolNode* new_bol2 = new BoolNode(main_bol-&gt;in(1), new_test);
1558     register_new_node(new_bol2, main_end-&gt;in(CountedLoopEndNode::TestControl));
1559     _igvn.replace_input_of(main_end, CountedLoopEndNode::TestValue, new_bol2);
1560   }
1561 
1562   // Flag main loop
1563   main_head-&gt;set_main_loop();
1564   if (peel_only) {
1565     main_head-&gt;set_main_no_pre_loop();
1566   }
1567 
1568   // Subtract a trip count for the pre-loop.
1569   main_head-&gt;set_trip_count(main_head-&gt;trip_count() - 1);
1570 
1571   // It&#39;s difficult to be precise about the trip-counts
1572   // for the pre/post loops.  They are usually very short,
1573   // so guess that 4 trips is a reasonable value.
1574   post_head-&gt;set_profile_trip_cnt(4.0);
1575   pre_head-&gt;set_profile_trip_cnt(4.0);
1576 
1577   // Now force out all loop-invariant dominating tests.  The optimizer
1578   // finds some, but we _know_ they are all useless.
1579   peeled_dom_test_elim(loop,old_new);
1580   loop-&gt;record_for_igvn();
1581 }
1582 
1583 //------------------------------insert_vector_post_loop------------------------
1584 // Insert a copy of the atomic unrolled vectorized main loop as a post loop,
1585 // unroll_policy has  already informed  us that more  unrolling is  about to
1586 // happen  to the  main  loop.  The  resultant  post loop  will  serve as  a
1587 // vectorized drain loop.
1588 void PhaseIdealLoop::insert_vector_post_loop(IdealLoopTree *loop, Node_List &amp;old_new) {
1589   if (!loop-&gt;_head-&gt;is_CountedLoop()) return;
1590 
1591   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
1592 
1593   // only process vectorized main loops
1594   if (!cl-&gt;is_vectorized_loop() || !cl-&gt;is_main_loop()) return;
1595 
1596   int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
1597   int cur_unroll = cl-&gt;unrolled_count();
1598 
1599   if (slp_max_unroll_factor == 0) return;
1600 
1601   // only process atomic unroll vector loops (not super unrolled after vectorization)
1602   if (cur_unroll != slp_max_unroll_factor) return;
1603 
1604   // we only ever process this one time
1605   if (cl-&gt;has_atomic_post_loop()) return;
1606 
1607   if (!may_require_nodes(loop-&gt;est_loop_clone_sz(2))) {
1608     return;
1609   }
1610 
1611 #ifndef PRODUCT
1612   if (TraceLoopOpts) {
1613     tty-&gt;print(&quot;PostVector  &quot;);
1614     loop-&gt;dump_head();
1615   }
1616 #endif
1617   C-&gt;set_major_progress();
1618 
1619   // Find common pieces of the loop being guarded with pre &amp; post loops
1620   CountedLoopNode *main_head = loop-&gt;_head-&gt;as_CountedLoop();
1621   CountedLoopEndNode *main_end = main_head-&gt;loopexit();
1622   // diagnostic to show loop end is not properly formed
1623   assert(main_end-&gt;outcnt() == 2, &quot;1 true, 1 false path only&quot;);
1624 
1625   // mark this loop as processed
1626   main_head-&gt;mark_has_atomic_post_loop();
1627 
1628   Node *incr = main_end-&gt;incr();
1629   Node *limit = main_end-&gt;limit();
1630 
1631   // In this case we throw away the result as we are not using it to connect anything else.
1632   CountedLoopNode *post_head = NULL;
1633   insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);
1634 
1635   // It&#39;s difficult to be precise about the trip-counts
1636   // for post loops.  They are usually very short,
1637   // so guess that unit vector trips is a reasonable value.
1638   post_head-&gt;set_profile_trip_cnt(cur_unroll);
1639 
1640   // Now force out all loop-invariant dominating tests.  The optimizer
1641   // finds some, but we _know_ they are all useless.
1642   peeled_dom_test_elim(loop, old_new);
1643   loop-&gt;record_for_igvn();
1644 }
1645 
1646 
1647 //-------------------------insert_scalar_rced_post_loop------------------------
1648 // Insert a copy of the rce&#39;d main loop as a post loop,
1649 // We have not unrolled the main loop, so this is the right time to inject this.
1650 // Later we will examine the partner of this post loop pair which still has range checks
1651 // to see inject code which tests at runtime if the range checks are applicable.
1652 void PhaseIdealLoop::insert_scalar_rced_post_loop(IdealLoopTree *loop, Node_List &amp;old_new) {
1653   if (!loop-&gt;_head-&gt;is_CountedLoop()) return;
1654 
1655   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
1656 
1657   // only process RCE&#39;d main loops
1658   if (!cl-&gt;is_main_loop() || cl-&gt;range_checks_present()) return;
1659 
1660 #ifndef PRODUCT
1661   if (TraceLoopOpts) {
1662     tty-&gt;print(&quot;PostScalarRce  &quot;);
1663     loop-&gt;dump_head();
1664   }
1665 #endif
1666   C-&gt;set_major_progress();
1667 
1668   // Find common pieces of the loop being guarded with pre &amp; post loops
1669   CountedLoopNode *main_head = loop-&gt;_head-&gt;as_CountedLoop();
1670   CountedLoopEndNode *main_end = main_head-&gt;loopexit();
1671   // diagnostic to show loop end is not properly formed
1672   assert(main_end-&gt;outcnt() == 2, &quot;1 true, 1 false path only&quot;);
1673 
1674   Node *incr = main_end-&gt;incr();
1675   Node *limit = main_end-&gt;limit();
1676 
1677   // In this case we throw away the result as we are not using it to connect anything else.
1678   CountedLoopNode *post_head = NULL;
1679   insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);
1680 
1681   // It&#39;s difficult to be precise about the trip-counts
1682   // for post loops.  They are usually very short,
1683   // so guess that unit vector trips is a reasonable value.
1684   post_head-&gt;set_profile_trip_cnt(4.0);
1685   post_head-&gt;set_is_rce_post_loop();
1686 
1687   // Now force out all loop-invariant dominating tests.  The optimizer
1688   // finds some, but we _know_ they are all useless.
1689   peeled_dom_test_elim(loop, old_new);
1690   loop-&gt;record_for_igvn();
1691 }
1692 
1693 
1694 //------------------------------insert_post_loop-------------------------------
1695 // Insert post loops.  Add a post loop to the given loop passed.
1696 Node *PhaseIdealLoop::insert_post_loop(IdealLoopTree *loop, Node_List &amp;old_new,
1697                                        CountedLoopNode *main_head, CountedLoopEndNode *main_end,
1698                                        Node *incr, Node *limit, CountedLoopNode *&amp;post_head) {
1699   IfNode* outer_main_end = main_end;
1700   IdealLoopTree* outer_loop = loop;
1701   if (main_head-&gt;is_strip_mined()) {
1702     main_head-&gt;verify_strip_mined(1);
1703     outer_main_end = main_head-&gt;outer_loop_end();
1704     outer_loop = loop-&gt;_parent;
1705     assert(outer_loop-&gt;_head == main_head-&gt;in(LoopNode::EntryControl), &quot;broken loop tree&quot;);
1706   }
1707 
1708   //------------------------------
1709   // Step A: Create a new post-Loop.
1710   Node* main_exit = outer_main_end-&gt;proj_out(false);
1711   assert(main_exit-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
1712   int dd_main_exit = dom_depth(main_exit);
1713 
1714   // Step A1: Clone the loop body of main. The clone becomes the post-loop.
1715   // The main loop pre-header illegally has 2 control users (old &amp; new loops).
1716   clone_loop(loop, old_new, dd_main_exit, ControlAroundStripMined);
1717   assert(old_new[main_end-&gt;_idx]-&gt;Opcode() == Op_CountedLoopEnd, &quot;&quot;);
1718   post_head = old_new[main_head-&gt;_idx]-&gt;as_CountedLoop();
1719   post_head-&gt;set_normal_loop();
1720   post_head-&gt;set_post_loop(main_head);
1721 
1722   // Reduce the post-loop trip count.
1723   CountedLoopEndNode* post_end = old_new[main_end-&gt;_idx]-&gt;as_CountedLoopEnd();
1724   post_end-&gt;_prob = PROB_FAIR;
1725 
1726   // Build the main-loop normal exit.
1727   IfFalseNode *new_main_exit = new IfFalseNode(outer_main_end);
1728   _igvn.register_new_node_with_optimizer(new_main_exit);
1729   set_idom(new_main_exit, outer_main_end, dd_main_exit);
1730   set_loop(new_main_exit, outer_loop-&gt;_parent);
1731 
1732   // Step A2: Build a zero-trip guard for the post-loop.  After leaving the
1733   // main-loop, the post-loop may not execute at all.  We &#39;opaque&#39; the incr
1734   // (the previous loop trip-counter exit value) because we will be changing
1735   // the exit value (via additional unrolling) so we cannot constant-fold away the zero
1736   // trip guard until all unrolling is done.
1737   Node *zer_opaq = new Opaque1Node(C, incr);
1738   Node *zer_cmp = new CmpINode(zer_opaq, limit);
1739   Node *zer_bol = new BoolNode(zer_cmp, main_end-&gt;test_trip());
1740   register_new_node(zer_opaq, new_main_exit);
1741   register_new_node(zer_cmp, new_main_exit);
1742   register_new_node(zer_bol, new_main_exit);
1743 
1744   // Build the IfNode
1745   IfNode *zer_iff = new IfNode(new_main_exit, zer_bol, PROB_FAIR, COUNT_UNKNOWN);
1746   _igvn.register_new_node_with_optimizer(zer_iff);
1747   set_idom(zer_iff, new_main_exit, dd_main_exit);
1748   set_loop(zer_iff, outer_loop-&gt;_parent);
1749 
1750   // Plug in the false-path, taken if we need to skip this post-loop
1751   _igvn.replace_input_of(main_exit, 0, zer_iff);
1752   set_idom(main_exit, zer_iff, dd_main_exit);
1753   set_idom(main_exit-&gt;unique_out(), zer_iff, dd_main_exit);
1754   // Make the true-path, must enter this post loop
1755   Node *zer_taken = new IfTrueNode(zer_iff);
1756   _igvn.register_new_node_with_optimizer(zer_taken);
1757   set_idom(zer_taken, zer_iff, dd_main_exit);
1758   set_loop(zer_taken, outer_loop-&gt;_parent);
1759   // Plug in the true path
1760   _igvn.hash_delete(post_head);
1761   post_head-&gt;set_req(LoopNode::EntryControl, zer_taken);
1762   set_idom(post_head, zer_taken, dd_main_exit);
1763 
1764   VectorSet visited;
1765   Node_Stack clones(main_head-&gt;back_control()-&gt;outcnt());
1766   // Step A3: Make the fall-in values to the post-loop come from the
1767   // fall-out values of the main-loop.
1768   for (DUIterator_Fast imax, i = main_head-&gt;fast_outs(imax); i &lt; imax; i++) {
1769     Node* main_phi = main_head-&gt;fast_out(i);
1770     if (main_phi-&gt;is_Phi() &amp;&amp; main_phi-&gt;in(0) == main_head &amp;&amp; main_phi-&gt;outcnt() &gt; 0) {
1771       Node *cur_phi = old_new[main_phi-&gt;_idx];
1772       Node *fallnew = clone_up_backedge_goo(main_head-&gt;back_control(),
1773                                             post_head-&gt;init_control(),
1774                                             main_phi-&gt;in(LoopNode::LoopBackControl),
1775                                             visited, clones);
1776       _igvn.hash_delete(cur_phi);
1777       cur_phi-&gt;set_req(LoopNode::EntryControl, fallnew);
1778     }
1779   }
1780 
1781   // CastII for the new post loop:
1782   Node* castii = cast_incr_before_loop(zer_opaq-&gt;in(1), zer_taken, post_head);
1783   assert(castii != NULL, &quot;no castII inserted&quot;);
1784 
1785   return new_main_exit;
1786 }
1787 
1788 //------------------------------is_invariant-----------------------------
1789 // Return true if n is invariant
1790 bool IdealLoopTree::is_invariant(Node* n) const {
1791   Node *n_c = _phase-&gt;has_ctrl(n) ? _phase-&gt;get_ctrl(n) : n;
1792   if (n_c-&gt;is_top()) return false;
1793   return !is_member(_phase-&gt;get_loop(n_c));
1794 }
1795 
1796 void PhaseIdealLoop::update_main_loop_skeleton_predicates(Node* ctrl, CountedLoopNode* loop_head, Node* init, int stride_con) {
1797   // Search for skeleton predicates and update them according to the new stride
1798   Node* entry = ctrl;
1799   Node* prev_proj = ctrl;
1800   LoopNode* outer_loop_head = loop_head-&gt;skip_strip_mined();
1801   IdealLoopTree* outer_loop = get_loop(outer_loop_head);
1802 
1803   // Compute the value of the loop induction variable at the end of the
1804   // first iteration of the unrolled loop: init + new_stride_con - init_inc
1805   int new_stride_con = stride_con * 2;
1806   Node* max_value = _igvn.intcon(new_stride_con);
1807   set_ctrl(max_value, C-&gt;root());
1808 
1809   while (entry != NULL &amp;&amp; entry-&gt;is_Proj() &amp;&amp; entry-&gt;in(0)-&gt;is_If()) {
1810     IfNode* iff = entry-&gt;in(0)-&gt;as_If();
1811     ProjNode* proj = iff-&gt;proj_out(1 - entry-&gt;as_Proj()-&gt;_con);
1812     if (proj-&gt;unique_ctrl_out()-&gt;Opcode() != Op_Halt) {
1813       break;
1814     }
1815     if (iff-&gt;in(1)-&gt;Opcode() == Op_Opaque4) {
1816       // Look for predicate with an Opaque1 node that can be used as a template
1817       if (!skeleton_predicate_has_opaque(iff)) {
1818         // No Opaque1 node? It&#39;s either the check for the first value
1819         // of the first iteration or the check for the last value of
1820         // the first iteration of an unrolled loop. We can&#39;t
1821         // tell. Kill it in any case.
1822         _igvn.replace_input_of(iff, 1, iff-&gt;in(1)-&gt;in(2));
1823       } else {
1824         // Add back predicates updated for the new stride.
1825         prev_proj = clone_skeleton_predicate(iff, init, max_value, entry, proj, ctrl, outer_loop, prev_proj);
1826         assert(!skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
1827       }
1828     }
1829     entry = entry-&gt;in(0)-&gt;in(0);
1830   }
1831   if (prev_proj != ctrl) {
1832     _igvn.replace_input_of(outer_loop_head, LoopNode::EntryControl, prev_proj);
1833     set_idom(outer_loop_head, prev_proj, dom_depth(outer_loop_head));
1834   }
1835 }
1836 
1837 //------------------------------do_unroll--------------------------------------
1838 // Unroll the loop body one step - make each trip do 2 iterations.
1839 void PhaseIdealLoop::do_unroll(IdealLoopTree *loop, Node_List &amp;old_new, bool adjust_min_trip) {
1840   assert(LoopUnrollLimit, &quot;&quot;);
1841   CountedLoopNode *loop_head = loop-&gt;_head-&gt;as_CountedLoop();
1842   CountedLoopEndNode *loop_end = loop_head-&gt;loopexit();
1843 #ifndef PRODUCT
1844   if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
1845     tty-&gt;print(&quot;Unrolling &quot;);
1846     loop-&gt;dump_head();
1847   } else if (TraceLoopOpts) {
1848     if (loop_head-&gt;trip_count() &lt; (uint)LoopUnrollLimit) {
1849       tty-&gt;print(&quot;Unroll %d(%2d) &quot;, loop_head-&gt;unrolled_count()*2, loop_head-&gt;trip_count());
1850     } else {
1851       tty-&gt;print(&quot;Unroll %d     &quot;, loop_head-&gt;unrolled_count()*2);
1852     }
1853     loop-&gt;dump_head();
1854   }
1855 
1856   if (C-&gt;do_vector_loop() &amp;&amp; (PrintOpto &amp;&amp; (VerifyLoopOptimizations || TraceLoopOpts))) {
1857     Node_Stack stack(C-&gt;live_nodes() &gt;&gt; 2);
1858     Node_List rpo_list;
1859     VectorSet visited;
1860     visited.set(loop_head-&gt;_idx);
1861     rpo(loop_head, stack, visited, rpo_list);
1862     dump(loop, rpo_list.size(), rpo_list);
1863   }
1864 #endif
1865 
1866   // Remember loop node count before unrolling to detect
1867   // if rounds of unroll,optimize are making progress
1868   loop_head-&gt;set_node_count_before_unroll(loop-&gt;_body.size());
1869 
1870   Node *ctrl  = loop_head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1871   Node *limit = loop_head-&gt;limit();
1872   Node *init  = loop_head-&gt;init_trip();
1873   Node *stride = loop_head-&gt;stride();
1874 
1875   Node *opaq = NULL;
1876   if (adjust_min_trip) {       // If not maximally unrolling, need adjustment
1877     // Search for zero-trip guard.
1878 
1879     // Check the shape of the graph at the loop entry. If an inappropriate
1880     // graph shape is encountered, the compiler bails out loop unrolling;
1881     // compilation of the method will still succeed.
1882     if (!is_canonical_loop_entry(loop_head)) {
1883       return;
1884     }
1885     opaq = loop_head-&gt;skip_predicates()-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2);
1886     // Zero-trip test uses an &#39;opaque&#39; node which is not shared.
1887     assert(opaq-&gt;outcnt() == 1 &amp;&amp; opaq-&gt;in(1) == limit, &quot;&quot;);
1888   }
1889 
1890   C-&gt;set_major_progress();
1891 
1892   Node* new_limit = NULL;
1893   int stride_con = stride-&gt;get_int();
1894   int stride_p = (stride_con &gt; 0) ? stride_con : -stride_con;
1895   uint old_trip_count = loop_head-&gt;trip_count();
1896   // Verify that unroll policy result is still valid.
1897   assert(old_trip_count &gt; 1 &amp;&amp;
1898       (!adjust_min_trip || stride_p &lt;= (1&lt;&lt;3)*loop_head-&gt;unrolled_count()), &quot;sanity&quot;);
1899 
1900   update_main_loop_skeleton_predicates(ctrl, loop_head, init, stride_con);
1901 
1902   // Adjust loop limit to keep valid iterations number after unroll.
1903   // Use (limit - stride) instead of (((limit - init)/stride) &amp; (-2))*stride
1904   // which may overflow.
1905   if (!adjust_min_trip) {
1906     assert(old_trip_count &gt; 1 &amp;&amp; (old_trip_count &amp; 1) == 0,
1907         &quot;odd trip count for maximally unroll&quot;);
1908     // Don&#39;t need to adjust limit for maximally unroll since trip count is even.
1909   } else if (loop_head-&gt;has_exact_trip_count() &amp;&amp; init-&gt;is_Con()) {
1910     // Loop&#39;s limit is constant. Loop&#39;s init could be constant when pre-loop
1911     // become peeled iteration.
1912     jlong init_con = init-&gt;get_int();
1913     // We can keep old loop limit if iterations count stays the same:
1914     //   old_trip_count == new_trip_count * 2
1915     // Note: since old_trip_count &gt;= 2 then new_trip_count &gt;= 1
1916     // so we also don&#39;t need to adjust zero trip test.
1917     jlong limit_con  = limit-&gt;get_int();
1918     // (stride_con*2) not overflow since stride_con &lt;= 8.
1919     int new_stride_con = stride_con * 2;
1920     int stride_m    = new_stride_con - (stride_con &gt; 0 ? 1 : -1);
1921     jlong trip_count = (limit_con - init_con + stride_m)/new_stride_con;
1922     // New trip count should satisfy next conditions.
1923     assert(trip_count &gt; 0 &amp;&amp; (julong)trip_count &lt; (julong)max_juint/2, &quot;sanity&quot;);
1924     uint new_trip_count = (uint)trip_count;
1925     adjust_min_trip = (old_trip_count != new_trip_count*2);
1926   }
1927 
1928   if (adjust_min_trip) {
1929     // Step 2: Adjust the trip limit if it is called for.
1930     // The adjustment amount is -stride. Need to make sure if the
1931     // adjustment underflows or overflows, then the main loop is skipped.
1932     Node* cmp = loop_end-&gt;cmp_node();
1933     assert(cmp-&gt;in(2) == limit, &quot;sanity&quot;);
1934     assert(opaq != NULL &amp;&amp; opaq-&gt;in(1) == limit, &quot;sanity&quot;);
1935 
1936     // Verify that policy_unroll result is still valid.
1937     const TypeInt* limit_type = _igvn.type(limit)-&gt;is_int();
1938     assert(stride_con &gt; 0 &amp;&amp; ((limit_type-&gt;_hi - stride_con) &lt; limit_type-&gt;_hi) ||
1939            stride_con &lt; 0 &amp;&amp; ((limit_type-&gt;_lo - stride_con) &gt; limit_type-&gt;_lo),
1940            &quot;sanity&quot;);
1941 
1942     if (limit-&gt;is_Con()) {
1943       // The check in policy_unroll and the assert above guarantee
1944       // no underflow if limit is constant.
1945       new_limit = _igvn.intcon(limit-&gt;get_int() - stride_con);
1946       set_ctrl(new_limit, C-&gt;root());
1947     } else {
1948       // Limit is not constant.
1949       if (loop_head-&gt;unrolled_count() == 1) { // only for first unroll
1950         // Separate limit by Opaque node in case it is an incremented
1951         // variable from previous loop to avoid using pre-incremented
1952         // value which could increase register pressure.
1953         // Otherwise reorg_offsets() optimization will create a separate
1954         // Opaque node for each use of trip-counter and as result
1955         // zero trip guard limit will be different from loop limit.
1956         assert(has_ctrl(opaq), &quot;should have it&quot;);
1957         Node* opaq_ctrl = get_ctrl(opaq);
1958         limit = new Opaque2Node(C, limit);
1959         register_new_node(limit, opaq_ctrl);
1960       }
1961       if ((stride_con &gt; 0 &amp;&amp; (java_subtract(limit_type-&gt;_lo, stride_con) &lt; limit_type-&gt;_lo)) ||
1962           (stride_con &lt; 0 &amp;&amp; (java_subtract(limit_type-&gt;_hi, stride_con) &gt; limit_type-&gt;_hi))) {
1963         // No underflow.
1964         new_limit = new SubINode(limit, stride);
1965       } else {
1966         // (limit - stride) may underflow.
1967         // Clamp the adjustment value with MININT or MAXINT:
1968         //
1969         //   new_limit = limit-stride
1970         //   if (stride &gt; 0)
1971         //     new_limit = (limit &lt; new_limit) ? MININT : new_limit;
1972         //   else
1973         //     new_limit = (limit &gt; new_limit) ? MAXINT : new_limit;
1974         //
1975         BoolTest::mask bt = loop_end-&gt;test_trip();
1976         assert(bt == BoolTest::lt || bt == BoolTest::gt, &quot;canonical test is expected&quot;);
1977         Node* adj_max = _igvn.intcon((stride_con &gt; 0) ? min_jint : max_jint);
1978         set_ctrl(adj_max, C-&gt;root());
1979         Node* old_limit = NULL;
1980         Node* adj_limit = NULL;
1981         Node* bol = limit-&gt;is_CMove() ? limit-&gt;in(CMoveNode::Condition) : NULL;
1982         if (loop_head-&gt;unrolled_count() &gt; 1 &amp;&amp;
1983             limit-&gt;is_CMove() &amp;&amp; limit-&gt;Opcode() == Op_CMoveI &amp;&amp;
1984             limit-&gt;in(CMoveNode::IfTrue) == adj_max &amp;&amp;
1985             bol-&gt;as_Bool()-&gt;_test._test == bt &amp;&amp;
1986             bol-&gt;in(1)-&gt;Opcode() == Op_CmpI &amp;&amp;
1987             bol-&gt;in(1)-&gt;in(2) == limit-&gt;in(CMoveNode::IfFalse)) {
1988           // Loop was unrolled before.
1989           // Optimize the limit to avoid nested CMove:
1990           // use original limit as old limit.
1991           old_limit = bol-&gt;in(1)-&gt;in(1);
1992           // Adjust previous adjusted limit.
1993           adj_limit = limit-&gt;in(CMoveNode::IfFalse);
1994           adj_limit = new SubINode(adj_limit, stride);
1995         } else {
1996           old_limit = limit;
1997           adj_limit = new SubINode(limit, stride);
1998         }
1999         assert(old_limit != NULL &amp;&amp; adj_limit != NULL, &quot;&quot;);
2000         register_new_node(adj_limit, ctrl); // adjust amount
2001         Node* adj_cmp = new CmpINode(old_limit, adj_limit);
2002         register_new_node(adj_cmp, ctrl);
2003         Node* adj_bool = new BoolNode(adj_cmp, bt);
2004         register_new_node(adj_bool, ctrl);
2005         new_limit = new CMoveINode(adj_bool, adj_limit, adj_max, TypeInt::INT);
2006       }
2007       register_new_node(new_limit, ctrl);
2008     }
2009 
2010     assert(new_limit != NULL, &quot;&quot;);
2011     // Replace in loop test.
2012     assert(loop_end-&gt;in(1)-&gt;in(1) == cmp, &quot;sanity&quot;);
2013     if (cmp-&gt;outcnt() == 1 &amp;&amp; loop_end-&gt;in(1)-&gt;outcnt() == 1) {
2014       // Don&#39;t need to create new test since only one user.
2015       _igvn.hash_delete(cmp);
2016       cmp-&gt;set_req(2, new_limit);
2017     } else {
2018       // Create new test since it is shared.
2019       Node* ctrl2 = loop_end-&gt;in(0);
2020       Node* cmp2  = cmp-&gt;clone();
2021       cmp2-&gt;set_req(2, new_limit);
2022       register_new_node(cmp2, ctrl2);
2023       Node* bol2 = loop_end-&gt;in(1)-&gt;clone();
2024       bol2-&gt;set_req(1, cmp2);
2025       register_new_node(bol2, ctrl2);
2026       _igvn.replace_input_of(loop_end, 1, bol2);
2027     }
2028     // Step 3: Find the min-trip test guaranteed before a &#39;main&#39; loop.
2029     // Make it a 1-trip test (means at least 2 trips).
2030 
2031     // Guard test uses an &#39;opaque&#39; node which is not shared.  Hence I
2032     // can edit it&#39;s inputs directly.  Hammer in the new limit for the
2033     // minimum-trip guard.
2034     assert(opaq-&gt;outcnt() == 1, &quot;&quot;);
2035     _igvn.replace_input_of(opaq, 1, new_limit);
2036   }
2037 
2038   // Adjust max trip count. The trip count is intentionally rounded
2039   // down here (e.g. 15-&gt; 7-&gt; 3-&gt; 1) because if we unwittingly over-unroll,
2040   // the main, unrolled, part of the loop will never execute as it is protected
2041   // by the min-trip test.  See bug 4834191 for a case where we over-unrolled
2042   // and later determined that part of the unrolled loop was dead.
2043   loop_head-&gt;set_trip_count(old_trip_count / 2);
2044 
2045   // Double the count of original iterations in the unrolled loop body.
2046   loop_head-&gt;double_unrolled_count();
2047 
2048   // ---------
2049   // Step 4: Clone the loop body.  Move it inside the loop.  This loop body
2050   // represents the odd iterations; since the loop trips an even number of
2051   // times its backedge is never taken.  Kill the backedge.
2052   uint dd = dom_depth(loop_head);
2053   clone_loop(loop, old_new, dd, IgnoreStripMined);
2054 
2055   // Make backedges of the clone equal to backedges of the original.
2056   // Make the fall-in from the original come from the fall-out of the clone.
2057   for (DUIterator_Fast jmax, j = loop_head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2058     Node* phi = loop_head-&gt;fast_out(j);
2059     if (phi-&gt;is_Phi() &amp;&amp; phi-&gt;in(0) == loop_head &amp;&amp; phi-&gt;outcnt() &gt; 0) {
2060       Node *newphi = old_new[phi-&gt;_idx];
2061       _igvn.hash_delete(phi);
2062       _igvn.hash_delete(newphi);
2063 
2064       phi   -&gt;set_req(LoopNode::   EntryControl, newphi-&gt;in(LoopNode::LoopBackControl));
2065       newphi-&gt;set_req(LoopNode::LoopBackControl, phi   -&gt;in(LoopNode::LoopBackControl));
2066       phi   -&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
2067     }
2068   }
2069   Node *clone_head = old_new[loop_head-&gt;_idx];
2070   _igvn.hash_delete(clone_head);
2071   loop_head -&gt;set_req(LoopNode::   EntryControl, clone_head-&gt;in(LoopNode::LoopBackControl));
2072   clone_head-&gt;set_req(LoopNode::LoopBackControl, loop_head -&gt;in(LoopNode::LoopBackControl));
2073   loop_head -&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
2074   loop-&gt;_head = clone_head;     // New loop header
2075 
2076   set_idom(loop_head,  loop_head -&gt;in(LoopNode::EntryControl), dd);
2077   set_idom(clone_head, clone_head-&gt;in(LoopNode::EntryControl), dd);
2078 
2079   // Kill the clone&#39;s backedge
2080   Node *newcle = old_new[loop_end-&gt;_idx];
2081   _igvn.hash_delete(newcle);
2082   Node *one = _igvn.intcon(1);
2083   set_ctrl(one, C-&gt;root());
2084   newcle-&gt;set_req(1, one);
2085   // Force clone into same loop body
2086   uint max = loop-&gt;_body.size();
2087   for (uint k = 0; k &lt; max; k++) {
2088     Node *old = loop-&gt;_body.at(k);
2089     Node *nnn = old_new[old-&gt;_idx];
2090     loop-&gt;_body.push(nnn);
2091     if (!has_ctrl(old)) {
2092       set_loop(nnn, loop);
2093     }
2094   }
2095 
2096   loop-&gt;record_for_igvn();
2097   loop_head-&gt;clear_strip_mined();
2098 
2099 #ifndef PRODUCT
2100   if (C-&gt;do_vector_loop() &amp;&amp; (PrintOpto &amp;&amp; (VerifyLoopOptimizations || TraceLoopOpts))) {
2101     tty-&gt;print(&quot;\nnew loop after unroll\n&quot;);       loop-&gt;dump_head();
2102     for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
2103       loop-&gt;_body.at(i)-&gt;dump();
2104     }
2105     if (C-&gt;clone_map().is_debug()) {
2106       tty-&gt;print(&quot;\nCloneMap\n&quot;);
2107       Dict* dict = C-&gt;clone_map().dict();
2108       DictI i(dict);
2109       tty-&gt;print_cr(&quot;Dict@%p[%d] = &quot;, dict, dict-&gt;Size());
2110       for (int ii = 0; i.test(); ++i, ++ii) {
2111         NodeCloneInfo cl((uint64_t)dict-&gt;operator[]((void*)i._key));
2112         tty-&gt;print(&quot;%d-&gt;%d:%d,&quot;, (int)(intptr_t)i._key, cl.idx(), cl.gen());
2113         if (ii % 10 == 9) {
2114           tty-&gt;print_cr(&quot; &quot;);
2115         }
2116       }
2117       tty-&gt;print_cr(&quot; &quot;);
2118     }
2119   }
2120 #endif
2121 }
2122 
2123 //------------------------------do_maximally_unroll----------------------------
2124 
2125 void PhaseIdealLoop::do_maximally_unroll(IdealLoopTree *loop, Node_List &amp;old_new) {
2126   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
2127   assert(cl-&gt;has_exact_trip_count(), &quot;trip count is not exact&quot;);
2128   assert(cl-&gt;trip_count() &gt; 0, &quot;&quot;);
2129 #ifndef PRODUCT
2130   if (TraceLoopOpts) {
2131     tty-&gt;print(&quot;MaxUnroll  %d &quot;, cl-&gt;trip_count());
2132     loop-&gt;dump_head();
2133   }
2134 #endif
2135 
2136   // If loop is tripping an odd number of times, peel odd iteration
2137   if ((cl-&gt;trip_count() &amp; 1) == 1) {
2138     do_peeling(loop, old_new);
2139   }
2140 
2141   // Now its tripping an even number of times remaining.  Double loop body.
2142   // Do not adjust pre-guards; they are not needed and do not exist.
2143   if (cl-&gt;trip_count() &gt; 0) {
2144     assert((cl-&gt;trip_count() &amp; 1) == 0, &quot;missed peeling&quot;);
2145     do_unroll(loop, old_new, false);
2146   }
2147 }
2148 
2149 void PhaseIdealLoop::mark_reductions(IdealLoopTree *loop) {
2150   if (SuperWordReductions == false) return;
2151 
2152   CountedLoopNode* loop_head = loop-&gt;_head-&gt;as_CountedLoop();
2153   if (loop_head-&gt;unrolled_count() &gt; 1) {
2154     return;
2155   }
2156 
2157   Node* trip_phi = loop_head-&gt;phi();
2158   for (DUIterator_Fast imax, i = loop_head-&gt;fast_outs(imax); i &lt; imax; i++) {
2159     Node* phi = loop_head-&gt;fast_out(i);
2160     if (phi-&gt;is_Phi() &amp;&amp; phi-&gt;outcnt() &gt; 0 &amp;&amp; phi != trip_phi) {
2161       // For definitions which are loop inclusive and not tripcounts.
2162       Node* def_node = phi-&gt;in(LoopNode::LoopBackControl);
2163 
2164       if (def_node != NULL) {
2165         Node* n_ctrl = get_ctrl(def_node);
2166         if (n_ctrl != NULL &amp;&amp; loop-&gt;is_member(get_loop(n_ctrl))) {
2167           // Now test it to see if it fits the standard pattern for a reduction operator.
2168           int opc = def_node-&gt;Opcode();
2169           if (opc != ReductionNode::opcode(opc, def_node-&gt;bottom_type()-&gt;basic_type())
2170               || opc == Op_MinD || opc == Op_MinF || opc == Op_MaxD || opc == Op_MaxF) {
2171             if (!def_node-&gt;is_reduction()) { // Not marked yet
2172               // To be a reduction, the arithmetic node must have the phi as input and provide a def to it
2173               bool ok = false;
2174               for (unsigned j = 1; j &lt; def_node-&gt;req(); j++) {
2175                 Node* in = def_node-&gt;in(j);
2176                 if (in == phi) {
2177                   ok = true;
2178                   break;
2179                 }
2180               }
2181 
2182               // do nothing if we did not match the initial criteria
2183               if (ok == false) {
2184                 continue;
2185               }
2186 
2187               // The result of the reduction must not be used in the loop
2188               for (DUIterator_Fast imax, i = def_node-&gt;fast_outs(imax); i &lt; imax &amp;&amp; ok; i++) {
2189                 Node* u = def_node-&gt;fast_out(i);
2190                 if (!loop-&gt;is_member(get_loop(ctrl_or_self(u)))) {
2191                   continue;
2192                 }
2193                 if (u == phi) {
2194                   continue;
2195                 }
2196                 ok = false;
2197               }
2198 
2199               // iff the uses conform
2200               if (ok) {
2201                 def_node-&gt;add_flag(Node::Flag_is_reduction);
2202                 loop_head-&gt;mark_has_reductions();
2203               }
2204             }
2205           }
2206         }
2207       }
2208     }
2209   }
2210 }
2211 
2212 //------------------------------adjust_limit-----------------------------------
2213 // Helper function for add_constraint().
2214 Node* PhaseIdealLoop::adjust_limit(int stride_con, Node * scale, Node *offset, Node *rc_limit, Node *loop_limit, Node *pre_ctrl, bool round_up) {
2215   // Compute &quot;I :: (limit-offset)/scale&quot;
2216   Node *con = new SubINode(rc_limit, offset);
2217   register_new_node(con, pre_ctrl);
2218   Node *X = new DivINode(0, con, scale);
2219   register_new_node(X, pre_ctrl);
2220 
2221   // When the absolute value of scale is greater than one, the integer
2222   // division may round limit down so add one to the limit.
2223   if (round_up) {
2224     X = new AddINode(X, _igvn.intcon(1));
2225     register_new_node(X, pre_ctrl);
2226   }
2227 
2228   // Adjust loop limit
2229   loop_limit = (stride_con &gt; 0)
2230                ? (Node*)(new MinINode(loop_limit, X))
2231                : (Node*)(new MaxINode(loop_limit, X));
2232   register_new_node(loop_limit, pre_ctrl);
2233   return loop_limit;
2234 }
2235 
2236 //------------------------------add_constraint---------------------------------
2237 // Constrain the main loop iterations so the conditions:
2238 //    low_limit &lt;= scale_con * I + offset  &lt;  upper_limit
2239 // always holds true.  That is, either increase the number of iterations in
2240 // the pre-loop or the post-loop until the condition holds true in the main
2241 // loop.  Stride, scale, offset and limit are all loop invariant.  Further,
2242 // stride and scale are constants (offset and limit often are).
2243 void PhaseIdealLoop::add_constraint(int stride_con, int scale_con, Node *offset, Node *low_limit, Node *upper_limit, Node *pre_ctrl, Node **pre_limit, Node **main_limit) {
2244   // For positive stride, the pre-loop limit always uses a MAX function
2245   // and the main loop a MIN function.  For negative stride these are
2246   // reversed.
2247 
2248   // Also for positive stride*scale the affine function is increasing, so the
2249   // pre-loop must check for underflow and the post-loop for overflow.
2250   // Negative stride*scale reverses this; pre-loop checks for overflow and
2251   // post-loop for underflow.
2252 
2253   Node *scale = _igvn.intcon(scale_con);
2254   set_ctrl(scale, C-&gt;root());
2255 
2256   if ((stride_con^scale_con) &gt;= 0) { // Use XOR to avoid overflow
2257     // The overflow limit: scale*I+offset &lt; upper_limit
2258     // For main-loop compute
2259     //   ( if (scale &gt; 0) /* and stride &gt; 0 */
2260     //       I &lt; (upper_limit-offset)/scale
2261     //     else /* scale &lt; 0 and stride &lt; 0 */
2262     //       I &gt; (upper_limit-offset)/scale
2263     //   )
2264     //
2265     // (upper_limit-offset) may overflow or underflow.
2266     // But it is fine since main loop will either have
2267     // less iterations or will be skipped in such case.
2268     *main_limit = adjust_limit(stride_con, scale, offset, upper_limit, *main_limit, pre_ctrl, false);
2269 
2270     // The underflow limit: low_limit &lt;= scale*I+offset.
2271     // For pre-loop compute
2272     //   NOT(scale*I+offset &gt;= low_limit)
2273     //   scale*I+offset &lt; low_limit
2274     //   ( if (scale &gt; 0) /* and stride &gt; 0 */
2275     //       I &lt; (low_limit-offset)/scale
2276     //     else /* scale &lt; 0 and stride &lt; 0 */
2277     //       I &gt; (low_limit-offset)/scale
2278     //   )
2279 
2280     if (low_limit-&gt;get_int() == -max_jint) {
2281       // We need this guard when scale*pre_limit+offset &gt;= limit
2282       // due to underflow. So we need execute pre-loop until
2283       // scale*I+offset &gt;= min_int. But (min_int-offset) will
2284       // underflow when offset &gt; 0 and X will be &gt; original_limit
2285       // when stride &gt; 0. To avoid it we replace positive offset with 0.
2286       //
2287       // Also (min_int+1 == -max_int) is used instead of min_int here
2288       // to avoid problem with scale == -1 (min_int/(-1) == min_int).
2289       Node* shift = _igvn.intcon(31);
2290       set_ctrl(shift, C-&gt;root());
2291       Node* sign = new RShiftINode(offset, shift);
2292       register_new_node(sign, pre_ctrl);
2293       offset = new AndINode(offset, sign);
2294       register_new_node(offset, pre_ctrl);
2295     } else {
2296       assert(low_limit-&gt;get_int() == 0, &quot;wrong low limit for range check&quot;);
2297       // The only problem we have here when offset == min_int
2298       // since (0-min_int) == min_int. It may be fine for stride &gt; 0
2299       // but for stride &lt; 0 X will be &lt; original_limit. To avoid it
2300       // max(pre_limit, original_limit) is used in do_range_check().
2301     }
2302     // Pass (-stride) to indicate pre_loop_cond = NOT(main_loop_cond);
2303     *pre_limit = adjust_limit((-stride_con), scale, offset, low_limit, *pre_limit, pre_ctrl,
2304                               scale_con &gt; 1 &amp;&amp; stride_con &gt; 0);
2305 
2306   } else { // stride_con*scale_con &lt; 0
2307     // For negative stride*scale pre-loop checks for overflow and
2308     // post-loop for underflow.
2309     //
2310     // The overflow limit: scale*I+offset &lt; upper_limit
2311     // For pre-loop compute
2312     //   NOT(scale*I+offset &lt; upper_limit)
2313     //   scale*I+offset &gt;= upper_limit
2314     //   scale*I+offset+1 &gt; upper_limit
2315     //   ( if (scale &lt; 0) /* and stride &gt; 0 */
2316     //       I &lt; (upper_limit-(offset+1))/scale
2317     //     else /* scale &gt; 0 and stride &lt; 0 */
2318     //       I &gt; (upper_limit-(offset+1))/scale
2319     //   )
2320     //
2321     // (upper_limit-offset-1) may underflow or overflow.
2322     // To avoid it min(pre_limit, original_limit) is used
2323     // in do_range_check() for stride &gt; 0 and max() for &lt; 0.
2324     Node *one  = _igvn.intcon(1);
2325     set_ctrl(one, C-&gt;root());
2326 
2327     Node *plus_one = new AddINode(offset, one);
2328     register_new_node(plus_one, pre_ctrl);
2329     // Pass (-stride) to indicate pre_loop_cond = NOT(main_loop_cond);
2330     *pre_limit = adjust_limit((-stride_con), scale, plus_one, upper_limit, *pre_limit, pre_ctrl,
2331                               scale_con &lt; -1 &amp;&amp; stride_con &gt; 0);
2332 
2333     if (low_limit-&gt;get_int() == -max_jint) {
2334       // We need this guard when scale*main_limit+offset &gt;= limit
2335       // due to underflow. So we need execute main-loop while
2336       // scale*I+offset+1 &gt; min_int. But (min_int-offset-1) will
2337       // underflow when (offset+1) &gt; 0 and X will be &lt; main_limit
2338       // when scale &lt; 0 (and stride &gt; 0). To avoid it we replace
2339       // positive (offset+1) with 0.
2340       //
2341       // Also (min_int+1 == -max_int) is used instead of min_int here
2342       // to avoid problem with scale == -1 (min_int/(-1) == min_int).
2343       Node* shift = _igvn.intcon(31);
2344       set_ctrl(shift, C-&gt;root());
2345       Node* sign = new RShiftINode(plus_one, shift);
2346       register_new_node(sign, pre_ctrl);
2347       plus_one = new AndINode(plus_one, sign);
2348       register_new_node(plus_one, pre_ctrl);
2349     } else {
2350       assert(low_limit-&gt;get_int() == 0, &quot;wrong low limit for range check&quot;);
2351       // The only problem we have here when offset == max_int
2352       // since (max_int+1) == min_int and (0-min_int) == min_int.
2353       // But it is fine since main loop will either have
2354       // less iterations or will be skipped in such case.
2355     }
2356     // The underflow limit: low_limit &lt;= scale*I+offset.
2357     // For main-loop compute
2358     //   scale*I+offset+1 &gt; low_limit
2359     //   ( if (scale &lt; 0) /* and stride &gt; 0 */
2360     //       I &lt; (low_limit-(offset+1))/scale
2361     //     else /* scale &gt; 0 and stride &lt; 0 */
2362     //       I &gt; (low_limit-(offset+1))/scale
2363     //   )
2364 
2365     *main_limit = adjust_limit(stride_con, scale, plus_one, low_limit, *main_limit, pre_ctrl,
2366                                false);
2367   }
2368 }
2369 
2370 
2371 //------------------------------is_scaled_iv---------------------------------
2372 // Return true if exp is a constant times an induction var
2373 bool PhaseIdealLoop::is_scaled_iv(Node* exp, Node* iv, int* p_scale) {
2374   if (exp == iv) {
2375     if (p_scale != NULL) {
2376       *p_scale = 1;
2377     }
2378     return true;
2379   }
2380   int opc = exp-&gt;Opcode();
2381   if (opc == Op_MulI) {
2382     if (exp-&gt;in(1) == iv &amp;&amp; exp-&gt;in(2)-&gt;is_Con()) {
2383       if (p_scale != NULL) {
2384         *p_scale = exp-&gt;in(2)-&gt;get_int();
2385       }
2386       return true;
2387     }
2388     if (exp-&gt;in(2) == iv &amp;&amp; exp-&gt;in(1)-&gt;is_Con()) {
2389       if (p_scale != NULL) {
2390         *p_scale = exp-&gt;in(1)-&gt;get_int();
2391       }
2392       return true;
2393     }
2394   } else if (opc == Op_LShiftI) {
2395     if (exp-&gt;in(1) == iv &amp;&amp; exp-&gt;in(2)-&gt;is_Con()) {
2396       if (p_scale != NULL) {
2397         *p_scale = 1 &lt;&lt; exp-&gt;in(2)-&gt;get_int();
2398       }
2399       return true;
2400     }
2401   }
2402   return false;
2403 }
2404 
2405 //-----------------------------is_scaled_iv_plus_offset------------------------------
2406 // Return true if exp is a simple induction variable expression: k1*iv + (invar + k2)
2407 bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, int* p_scale, Node** p_offset, int depth) {
2408   if (is_scaled_iv(exp, iv, p_scale)) {
2409     if (p_offset != NULL) {
2410       Node *zero = _igvn.intcon(0);
2411       set_ctrl(zero, C-&gt;root());
2412       *p_offset = zero;
2413     }
2414     return true;
2415   }
2416   int opc = exp-&gt;Opcode();
2417   if (opc == Op_AddI) {
2418     if (is_scaled_iv(exp-&gt;in(1), iv, p_scale)) {
2419       if (p_offset != NULL) {
2420         *p_offset = exp-&gt;in(2);
2421       }
2422       return true;
2423     }
2424     if (is_scaled_iv(exp-&gt;in(2), iv, p_scale)) {
2425       if (p_offset != NULL) {
2426         *p_offset = exp-&gt;in(1);
2427       }
2428       return true;
2429     }
2430     if (exp-&gt;in(2)-&gt;is_Con()) {
2431       Node* offset2 = NULL;
2432       if (depth &lt; 2 &amp;&amp;
2433           is_scaled_iv_plus_offset(exp-&gt;in(1), iv, p_scale,
2434                                    p_offset != NULL ? &amp;offset2 : NULL, depth+1)) {
2435         if (p_offset != NULL) {
2436           Node *ctrl_off2 = get_ctrl(offset2);
2437           Node* offset = new AddINode(offset2, exp-&gt;in(2));
2438           register_new_node(offset, ctrl_off2);
2439           *p_offset = offset;
2440         }
2441         return true;
2442       }
2443     }
2444   } else if (opc == Op_SubI) {
2445     if (is_scaled_iv(exp-&gt;in(1), iv, p_scale)) {
2446       if (p_offset != NULL) {
2447         Node *zero = _igvn.intcon(0);
2448         set_ctrl(zero, C-&gt;root());
2449         Node *ctrl_off = get_ctrl(exp-&gt;in(2));
2450         Node* offset = new SubINode(zero, exp-&gt;in(2));
2451         register_new_node(offset, ctrl_off);
2452         *p_offset = offset;
2453       }
2454       return true;
2455     }
2456     if (is_scaled_iv(exp-&gt;in(2), iv, p_scale)) {
2457       if (p_offset != NULL) {
2458         *p_scale *= -1;
2459         *p_offset = exp-&gt;in(1);
2460       }
2461       return true;
2462     }
2463   }
2464   return false;
2465 }
2466 
2467 // Same as PhaseIdealLoop::duplicate_predicates() but for range checks
2468 // eliminated by iteration splitting.
2469 Node* PhaseIdealLoop::add_range_check_predicate(IdealLoopTree* loop, CountedLoopNode* cl,
2470                                                 Node* predicate_proj, int scale_con, Node* offset,
2471                                                 Node* limit, jint stride_con, Node* value) {
2472   bool overflow = false;
2473   BoolNode* bol = rc_predicate(loop, predicate_proj, scale_con, offset, value, NULL, stride_con, limit, (stride_con &gt; 0) != (scale_con &gt; 0), overflow);
2474   Node* opaque_bol = new Opaque4Node(C, bol, _igvn.intcon(1));
2475   register_new_node(opaque_bol, predicate_proj);
2476   IfNode* new_iff = NULL;
2477   if (overflow) {
2478     new_iff = new IfNode(predicate_proj, opaque_bol, PROB_MAX, COUNT_UNKNOWN);
2479   } else {
2480     new_iff = new RangeCheckNode(predicate_proj, opaque_bol, PROB_MAX, COUNT_UNKNOWN);
2481   }
2482   register_control(new_iff, loop-&gt;_parent, predicate_proj);
2483   Node* iffalse = new IfFalseNode(new_iff);
2484   register_control(iffalse, _ltree_root, new_iff);
2485   ProjNode* iftrue = new IfTrueNode(new_iff);
2486   register_control(iftrue, loop-&gt;_parent, new_iff);
2487   Node *frame = new ParmNode(C-&gt;start(), TypeFunc::FramePtr);
2488   register_new_node(frame, C-&gt;start());
2489   Node* halt = new HaltNode(iffalse, frame, &quot;range check predicate failed which is impossible&quot;);
2490   register_control(halt, _ltree_root, iffalse);
2491   C-&gt;root()-&gt;add_req(halt);
2492   return iftrue;
2493 }
2494 
2495 //------------------------------do_range_check---------------------------------
2496 // Eliminate range-checks and other trip-counter vs loop-invariant tests.
2497 int PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &amp;old_new) {
2498 #ifndef PRODUCT
2499   if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
2500     tty-&gt;print(&quot;Range Check Elimination &quot;);
2501     loop-&gt;dump_head();
2502   } else if (TraceLoopOpts) {
2503     tty-&gt;print(&quot;RangeCheck   &quot;);
2504     loop-&gt;dump_head();
2505   }
2506 #endif
2507 
2508   assert(RangeCheckElimination, &quot;&quot;);
2509   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
2510   // If we fail before trying to eliminate range checks, set multiversion state
2511   int closed_range_checks = 1;
2512 
2513   // protect against stride not being a constant
2514   if (!cl-&gt;stride_is_con()) {
2515     return closed_range_checks;
2516   }
2517   // Find the trip counter; we are iteration splitting based on it
2518   Node *trip_counter = cl-&gt;phi();
2519   // Find the main loop limit; we will trim it&#39;s iterations
2520   // to not ever trip end tests
2521   Node *main_limit = cl-&gt;limit();
2522 
2523   // Check graph shape. Cannot optimize a loop if zero-trip
2524   // Opaque1 node is optimized away and then another round
2525   // of loop opts attempted.
2526   if (!is_canonical_loop_entry(cl)) {
2527     return closed_range_checks;
2528   }
2529 
2530   // Need to find the main-loop zero-trip guard
2531   Node *ctrl = cl-&gt;skip_predicates();
2532   Node *iffm = ctrl-&gt;in(0);
2533   Node *opqzm = iffm-&gt;in(1)-&gt;in(1)-&gt;in(2);
2534   assert(opqzm-&gt;in(1) == main_limit, &quot;do not understand situation&quot;);
2535 
2536   // Find the pre-loop limit; we will expand its iterations to
2537   // not ever trip low tests.
2538   Node *p_f = iffm-&gt;in(0);
2539   // pre loop may have been optimized out
2540   if (p_f-&gt;Opcode() != Op_IfFalse) {
2541     return closed_range_checks;
2542   }
2543   CountedLoopEndNode *pre_end = p_f-&gt;in(0)-&gt;as_CountedLoopEnd();
2544   assert(pre_end-&gt;loopnode()-&gt;is_pre_loop(), &quot;&quot;);
2545   Node *pre_opaq1 = pre_end-&gt;limit();
2546   // Occasionally it&#39;s possible for a pre-loop Opaque1 node to be
2547   // optimized away and then another round of loop opts attempted.
2548   // We can not optimize this particular loop in that case.
2549   if (pre_opaq1-&gt;Opcode() != Op_Opaque1) {
2550     return closed_range_checks;
2551   }
2552   Opaque1Node *pre_opaq = (Opaque1Node*)pre_opaq1;
2553   Node *pre_limit = pre_opaq-&gt;in(1);
2554 
2555   // Where do we put new limit calculations
2556   Node *pre_ctrl = pre_end-&gt;loopnode()-&gt;in(LoopNode::EntryControl);
2557 
2558   // Ensure the original loop limit is available from the
2559   // pre-loop Opaque1 node.
2560   Node *orig_limit = pre_opaq-&gt;original_loop_limit();
2561   if (orig_limit == NULL || _igvn.type(orig_limit) == Type::TOP) {
2562     return closed_range_checks;
2563   }
2564   // Must know if its a count-up or count-down loop
2565 
2566   int stride_con = cl-&gt;stride_con();
2567   Node *zero = _igvn.intcon(0);
2568   Node *one  = _igvn.intcon(1);
2569   // Use symmetrical int range [-max_jint,max_jint]
2570   Node *mini = _igvn.intcon(-max_jint);
2571   set_ctrl(zero, C-&gt;root());
2572   set_ctrl(one,  C-&gt;root());
2573   set_ctrl(mini, C-&gt;root());
2574 
2575   // Range checks that do not dominate the loop backedge (ie.
2576   // conditionally executed) can lengthen the pre loop limit beyond
2577   // the original loop limit. To prevent this, the pre limit is
2578   // (for stride &gt; 0) MINed with the original loop limit (MAXed
2579   // stride &lt; 0) when some range_check (rc) is conditionally
2580   // executed.
2581   bool conditional_rc = false;
2582 
2583   // Count number of range checks and reduce by load range limits, if zero,
2584   // the loop is in canonical form to multiversion.
2585   closed_range_checks = 0;
2586 
2587   Node* predicate_proj = cl-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
2588   assert(predicate_proj-&gt;is_Proj() &amp;&amp; predicate_proj-&gt;in(0)-&gt;is_If(), &quot;if projection only&quot;);
2589 
2590   // Check loop body for tests of trip-counter plus loop-invariant vs loop-variant.
2591   for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
2592     Node *iff = loop-&gt;_body[i];
2593     if (iff-&gt;Opcode() == Op_If ||
2594         iff-&gt;Opcode() == Op_RangeCheck) { // Test?
2595       // Test is an IfNode, has 2 projections.  If BOTH are in the loop
2596       // we need loop unswitching instead of iteration splitting.
2597       closed_range_checks++;
2598       Node *exit = loop-&gt;is_loop_exit(iff);
2599       if (!exit) continue;
2600       int flip = (exit-&gt;Opcode() == Op_IfTrue) ? 1 : 0;
2601 
2602       // Get boolean condition to test
2603       Node *i1 = iff-&gt;in(1);
2604       if (!i1-&gt;is_Bool()) continue;
2605       BoolNode *bol = i1-&gt;as_Bool();
2606       BoolTest b_test = bol-&gt;_test;
2607       // Flip sense of test if exit condition is flipped
2608       if (flip) {
2609         b_test = b_test.negate();
2610       }
2611       // Get compare
2612       Node *cmp = bol-&gt;in(1);
2613 
2614       // Look for trip_counter + offset vs limit
2615       Node *rc_exp = cmp-&gt;in(1);
2616       Node *limit  = cmp-&gt;in(2);
2617       int scale_con= 1;        // Assume trip counter not scaled
2618 
2619       Node *limit_c = get_ctrl(limit);
2620       if (loop-&gt;is_member(get_loop(limit_c))) {
2621         // Compare might have operands swapped; commute them
2622         b_test = b_test.commute();
2623         rc_exp = cmp-&gt;in(2);
2624         limit  = cmp-&gt;in(1);
2625         limit_c = get_ctrl(limit);
2626         if (loop-&gt;is_member(get_loop(limit_c))) {
2627           continue;             // Both inputs are loop varying; cannot RCE
2628         }
2629       }
2630       // Here we know &#39;limit&#39; is loop invariant
2631 
2632       // &#39;limit&#39; maybe pinned below the zero trip test (probably from a
2633       // previous round of rce), in which case, it can&#39;t be used in the
2634       // zero trip test expression which must occur before the zero test&#39;s if.
2635       if (is_dominator(ctrl, limit_c)) {
2636         continue;  // Don&#39;t rce this check but continue looking for other candidates.
2637       }
2638 
2639       // Check for scaled induction variable plus an offset
2640       Node *offset = NULL;
2641 
2642       if (!is_scaled_iv_plus_offset(rc_exp, trip_counter, &amp;scale_con, &amp;offset)) {
2643         continue;
2644       }
2645 
2646       Node *offset_c = get_ctrl(offset);
2647       if (loop-&gt;is_member(get_loop(offset_c))) {
2648         continue;               // Offset is not really loop invariant
2649       }
2650       // Here we know &#39;offset&#39; is loop invariant.
2651 
2652       // As above for the &#39;limit&#39;, the &#39;offset&#39; maybe pinned below the
2653       // zero trip test.
2654       if (is_dominator(ctrl, offset_c)) {
2655         continue; // Don&#39;t rce this check but continue looking for other candidates.
2656       }
2657 #ifdef ASSERT
2658       if (TraceRangeLimitCheck) {
2659         tty-&gt;print_cr(&quot;RC bool node%s&quot;, flip ? &quot; flipped:&quot; : &quot;:&quot;);
2660         bol-&gt;dump(2);
2661       }
2662 #endif
2663       // At this point we have the expression as:
2664       //   scale_con * trip_counter + offset :: limit
2665       // where scale_con, offset and limit are loop invariant.  Trip_counter
2666       // monotonically increases by stride_con, a constant.  Both (or either)
2667       // stride_con and scale_con can be negative which will flip about the
2668       // sense of the test.
2669 
2670       // Adjust pre and main loop limits to guard the correct iteration set
2671       if (cmp-&gt;Opcode() == Op_CmpU) { // Unsigned compare is really 2 tests
2672         if (b_test._test == BoolTest::lt) { // Range checks always use lt
2673           // The underflow and overflow limits: 0 &lt;= scale*I+offset &lt; limit
2674           add_constraint(stride_con, scale_con, offset, zero, limit, pre_ctrl, &amp;pre_limit, &amp;main_limit);
2675           // (0-offset)/scale could be outside of loop iterations range.
2676           conditional_rc = true;
2677           Node* init = cl-&gt;init_trip();
2678           Node* opaque_init = new OpaqueLoopInitNode(C, init);
2679           register_new_node(opaque_init, predicate_proj);
2680 
2681           // predicate on first value of first iteration
2682           predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, offset, limit, stride_con, init);
2683           assert(!skeleton_predicate_has_opaque(predicate_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
2684 
2685           // template predicate so it can be updated on next unrolling
2686           predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, offset, limit, stride_con, opaque_init);
2687           assert(skeleton_predicate_has_opaque(predicate_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
2688 
2689           Node* opaque_stride = new OpaqueLoopStrideNode(C, cl-&gt;stride());
2690           register_new_node(opaque_stride, predicate_proj);
2691           Node* max_value = new SubINode(opaque_stride, cl-&gt;stride());
2692           register_new_node(max_value, predicate_proj);
2693           max_value = new AddINode(opaque_init, max_value);
2694           register_new_node(max_value, predicate_proj);
2695           predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, offset, limit, stride_con, max_value);
2696           assert(skeleton_predicate_has_opaque(predicate_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
2697 
2698         } else {
2699           if (PrintOpto) {
2700             tty-&gt;print_cr(&quot;missed RCE opportunity&quot;);
2701           }
2702           continue;             // In release mode, ignore it
2703         }
2704       } else {                  // Otherwise work on normal compares
2705         switch(b_test._test) {
2706         case BoolTest::gt:
2707           // Fall into GE case
2708         case BoolTest::ge:
2709           // Convert (I*scale+offset) &gt;= Limit to (I*(-scale)+(-offset)) &lt;= -Limit
2710           scale_con = -scale_con;
2711           offset = new SubINode(zero, offset);
2712           register_new_node(offset, pre_ctrl);
2713           limit  = new SubINode(zero, limit);
2714           register_new_node(limit, pre_ctrl);
2715           // Fall into LE case
2716         case BoolTest::le:
2717           if (b_test._test != BoolTest::gt) {
2718             // Convert X &lt;= Y to X &lt; Y+1
2719             limit = new AddINode(limit, one);
2720             register_new_node(limit, pre_ctrl);
2721           }
2722           // Fall into LT case
2723         case BoolTest::lt:
2724           // The underflow and overflow limits: MIN_INT &lt;= scale*I+offset &lt; limit
2725           // Note: (MIN_INT+1 == -MAX_INT) is used instead of MIN_INT here
2726           // to avoid problem with scale == -1: MIN_INT/(-1) == MIN_INT.
2727           add_constraint(stride_con, scale_con, offset, mini, limit, pre_ctrl, &amp;pre_limit, &amp;main_limit);
2728           // ((MIN_INT+1)-offset)/scale could be outside of loop iterations range.
2729           // Note: negative offset is replaced with 0 but (MIN_INT+1)/scale could
2730           // still be outside of loop range.
2731           conditional_rc = true;
2732           break;
2733         default:
2734           if (PrintOpto) {
2735             tty-&gt;print_cr(&quot;missed RCE opportunity&quot;);
2736           }
2737           continue;             // Unhandled case
2738         }
2739       }
2740 
2741       // Kill the eliminated test
2742       C-&gt;set_major_progress();
2743       Node *kill_con = _igvn.intcon(1-flip);
2744       set_ctrl(kill_con, C-&gt;root());
2745       _igvn.replace_input_of(iff, 1, kill_con);
2746       // Find surviving projection
2747       assert(iff-&gt;is_If(), &quot;&quot;);
2748       ProjNode* dp = ((IfNode*)iff)-&gt;proj_out(1-flip);
2749       // Find loads off the surviving projection; remove their control edge
2750       for (DUIterator_Fast imax, i = dp-&gt;fast_outs(imax); i &lt; imax; i++) {
2751         Node* cd = dp-&gt;fast_out(i); // Control-dependent node
2752         if (cd-&gt;is_Load() &amp;&amp; cd-&gt;depends_only_on_test()) {   // Loads can now float around in the loop
2753           // Allow the load to float around in the loop, or before it
2754           // but NOT before the pre-loop.
2755           _igvn.replace_input_of(cd, 0, ctrl); // ctrl, not NULL
2756           --i;
2757           --imax;
2758         }
2759       }
2760       if (limit-&gt;Opcode() == Op_LoadRange) {
2761         closed_range_checks--;
2762       }
2763     } // End of is IF
2764   }
2765   if (predicate_proj != cl-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl)) {
2766     _igvn.replace_input_of(cl-&gt;skip_strip_mined(), LoopNode::EntryControl, predicate_proj);
2767     set_idom(cl-&gt;skip_strip_mined(), predicate_proj, dom_depth(cl-&gt;skip_strip_mined()));
2768   }
2769 
2770   // Update loop limits
2771   if (conditional_rc) {
2772     pre_limit = (stride_con &gt; 0) ? (Node*)new MinINode(pre_limit, orig_limit)
2773                                  : (Node*)new MaxINode(pre_limit, orig_limit);
2774     register_new_node(pre_limit, pre_ctrl);
2775   }
2776   _igvn.replace_input_of(pre_opaq, 1, pre_limit);
2777 
2778   // Note:: we are making the main loop limit no longer precise;
2779   // need to round up based on stride.
2780   cl-&gt;set_nonexact_trip_count();
2781   Node *main_cle = cl-&gt;loopexit();
2782   Node *main_bol = main_cle-&gt;in(1);
2783   // Hacking loop bounds; need private copies of exit test
2784   if (main_bol-&gt;outcnt() &gt; 1) {     // BoolNode shared?
2785     main_bol = main_bol-&gt;clone();   // Clone a private BoolNode
2786     register_new_node(main_bol, main_cle-&gt;in(0));
2787     _igvn.replace_input_of(main_cle, 1, main_bol);
2788   }
2789   Node *main_cmp = main_bol-&gt;in(1);
2790   if (main_cmp-&gt;outcnt() &gt; 1) {     // CmpNode shared?
2791     main_cmp = main_cmp-&gt;clone();   // Clone a private CmpNode
2792     register_new_node(main_cmp, main_cle-&gt;in(0));
2793     _igvn.replace_input_of(main_bol, 1, main_cmp);
2794   }
2795   // Hack the now-private loop bounds
2796   _igvn.replace_input_of(main_cmp, 2, main_limit);
2797   // The OpaqueNode is unshared by design
2798   assert(opqzm-&gt;outcnt() == 1, &quot;cannot hack shared node&quot;);
2799   _igvn.replace_input_of(opqzm, 1, main_limit);
2800 
2801   return closed_range_checks;
2802 }
2803 
2804 //------------------------------has_range_checks-------------------------------
2805 // Check to see if RCE cleaned the current loop of range-checks.
2806 void PhaseIdealLoop::has_range_checks(IdealLoopTree *loop) {
2807   assert(RangeCheckElimination, &quot;&quot;);
2808 
2809   // skip if not a counted loop
2810   if (!loop-&gt;is_counted()) return;
2811 
2812   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
2813 
2814   // skip this loop if it is already checked
2815   if (cl-&gt;has_been_range_checked()) return;
2816 
2817   // Now check for existence of range checks
2818   for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
2819     Node *iff = loop-&gt;_body[i];
2820     int iff_opc = iff-&gt;Opcode();
2821     if (iff_opc == Op_If || iff_opc == Op_RangeCheck) {
2822       cl-&gt;mark_has_range_checks();
2823       break;
2824     }
2825   }
2826   cl-&gt;set_has_been_range_checked();
2827 }
2828 
2829 //-------------------------multi_version_post_loops----------------------------
2830 // Check the range checks that remain, if simple, use the bounds to guard
2831 // which version to a post loop we execute, one with range checks or one without
2832 bool PhaseIdealLoop::multi_version_post_loops(IdealLoopTree *rce_loop, IdealLoopTree *legacy_loop) {
2833   bool multi_version_succeeded = false;
2834   assert(RangeCheckElimination, &quot;&quot;);
2835   CountedLoopNode *legacy_cl = legacy_loop-&gt;_head-&gt;as_CountedLoop();
2836   assert(legacy_cl-&gt;is_post_loop(), &quot;&quot;);
2837 
2838   // Check for existence of range checks using the unique instance to make a guard with
2839   Unique_Node_List worklist;
2840   for (uint i = 0; i &lt; legacy_loop-&gt;_body.size(); i++) {
2841     Node *iff = legacy_loop-&gt;_body[i];
2842     int iff_opc = iff-&gt;Opcode();
2843     if (iff_opc == Op_If || iff_opc == Op_RangeCheck) {
2844       worklist.push(iff);
2845     }
2846   }
2847 
2848   // Find RCE&#39;d post loop so that we can stage its guard.
2849   if (!is_canonical_loop_entry(legacy_cl)) return multi_version_succeeded;
2850   Node* ctrl = legacy_cl-&gt;in(LoopNode::EntryControl);
2851   Node* iffm = ctrl-&gt;in(0);
2852 
2853   // Now we test that both the post loops are connected
2854   Node* post_loop_region = iffm-&gt;in(0);
2855   if (post_loop_region == NULL) return multi_version_succeeded;
2856   if (!post_loop_region-&gt;is_Region()) return multi_version_succeeded;
2857   Node* covering_region = post_loop_region-&gt;in(RegionNode::Control+1);
2858   if (covering_region == NULL) return multi_version_succeeded;
2859   if (!covering_region-&gt;is_Region()) return multi_version_succeeded;
2860   Node* p_f = covering_region-&gt;in(RegionNode::Control);
2861   if (p_f == NULL) return multi_version_succeeded;
2862   if (!p_f-&gt;is_IfFalse()) return multi_version_succeeded;
2863   if (!p_f-&gt;in(0)-&gt;is_CountedLoopEnd()) return multi_version_succeeded;
2864   CountedLoopEndNode* rce_loop_end = p_f-&gt;in(0)-&gt;as_CountedLoopEnd();
2865   if (rce_loop_end == NULL) return multi_version_succeeded;
2866   CountedLoopNode* rce_cl = rce_loop_end-&gt;loopnode();
2867   if (rce_cl == NULL || !rce_cl-&gt;is_post_loop()) return multi_version_succeeded;
2868   CountedLoopNode *known_rce_cl = rce_loop-&gt;_head-&gt;as_CountedLoop();
2869   if (rce_cl != known_rce_cl) return multi_version_succeeded;
2870 
2871   // Then we fetch the cover entry test
2872   ctrl = rce_cl-&gt;in(LoopNode::EntryControl);
2873   if (!ctrl-&gt;is_IfTrue() &amp;&amp; !ctrl-&gt;is_IfFalse()) return multi_version_succeeded;
2874 
2875 #ifndef PRODUCT
2876   if (TraceLoopOpts) {
2877     tty-&gt;print(&quot;PostMultiVersion\n&quot;);
2878     rce_loop-&gt;dump_head();
2879     legacy_loop-&gt;dump_head();
2880   }
2881 #endif
2882 
2883   // Now fetch the limit we want to compare against
2884   Node *limit = rce_cl-&gt;limit();
2885   bool first_time = true;
2886 
2887   // If we got this far, we identified the post loop which has been RCE&#39;d and
2888   // we have a work list.  Now we will try to transform the if guard to cause
2889   // the loop pair to be multi version executed with the determination left to runtime
2890   // or the optimizer if full information is known about the given arrays at compile time.
2891   Node *last_min = NULL;
2892   multi_version_succeeded = true;
2893   while (worklist.size()) {
2894     Node* rc_iffm = worklist.pop();
2895     if (rc_iffm-&gt;is_If()) {
2896       Node *rc_bolzm = rc_iffm-&gt;in(1);
2897       if (rc_bolzm-&gt;is_Bool()) {
2898         Node *rc_cmpzm = rc_bolzm-&gt;in(1);
2899         if (rc_cmpzm-&gt;is_Cmp()) {
2900           Node *rc_left = rc_cmpzm-&gt;in(2);
2901           if (rc_left-&gt;Opcode() != Op_LoadRange) {
2902             multi_version_succeeded = false;
2903             break;
2904           }
2905           if (first_time) {
2906             last_min = rc_left;
2907             first_time = false;
2908           } else {
2909             Node *cur_min = new MinINode(last_min, rc_left);
2910             last_min = cur_min;
2911             _igvn.register_new_node_with_optimizer(last_min);
2912           }
2913         }
2914       }
2915     }
2916   }
2917 
2918   // All we have to do is update the limit of the rce loop
2919   // with the min of our expression and the current limit.
2920   // We will use this expression to replace the current limit.
2921   if (last_min &amp;&amp; multi_version_succeeded) {
2922     Node *cur_min = new MinINode(last_min, limit);
2923     _igvn.register_new_node_with_optimizer(cur_min);
2924     Node *cmp_node = rce_loop_end-&gt;cmp_node();
2925     _igvn.replace_input_of(cmp_node, 2, cur_min);
2926     set_ctrl(cur_min, ctrl);
2927     set_loop(cur_min, rce_loop-&gt;_parent);
2928 
2929     legacy_cl-&gt;mark_is_multiversioned();
2930     rce_cl-&gt;mark_is_multiversioned();
2931     multi_version_succeeded = true;
2932 
2933     C-&gt;set_major_progress();
2934   }
2935 
2936   return multi_version_succeeded;
2937 }
2938 
2939 //-------------------------poison_rce_post_loop--------------------------------
2940 // Causes the rce&#39;d post loop to be optimized away if multiversioning fails
2941 void PhaseIdealLoop::poison_rce_post_loop(IdealLoopTree *rce_loop) {
2942   CountedLoopNode *rce_cl = rce_loop-&gt;_head-&gt;as_CountedLoop();
2943   Node* ctrl = rce_cl-&gt;in(LoopNode::EntryControl);
2944   if (ctrl-&gt;is_IfTrue() || ctrl-&gt;is_IfFalse()) {
2945     Node* iffm = ctrl-&gt;in(0);
2946     if (iffm-&gt;is_If()) {
2947       Node* cur_bool = iffm-&gt;in(1);
2948       if (cur_bool-&gt;is_Bool()) {
2949         Node* cur_cmp = cur_bool-&gt;in(1);
2950         if (cur_cmp-&gt;is_Cmp()) {
2951           BoolTest::mask new_test = BoolTest::gt;
2952           BoolNode *new_bool = new BoolNode(cur_cmp, new_test);
2953           _igvn.replace_node(cur_bool, new_bool);
2954           _igvn._worklist.push(new_bool);
2955           Node* left_op = cur_cmp-&gt;in(1);
2956           _igvn.replace_input_of(cur_cmp, 2, left_op);
2957           C-&gt;set_major_progress();
2958         }
2959       }
2960     }
2961   }
2962 }
2963 
2964 //------------------------------DCE_loop_body----------------------------------
2965 // Remove simplistic dead code from loop body
2966 void IdealLoopTree::DCE_loop_body() {
2967   for (uint i = 0; i &lt; _body.size(); i++) {
2968     if (_body.at(i)-&gt;outcnt() == 0) {
2969       _body.map(i, _body.pop());
2970       i--; // Ensure we revisit the updated index.
2971     }
2972   }
2973 }
2974 
2975 
2976 //------------------------------adjust_loop_exit_prob--------------------------
2977 // Look for loop-exit tests with the 50/50 (or worse) guesses from the parsing stage.
2978 // Replace with a 1-in-10 exit guess.
2979 void IdealLoopTree::adjust_loop_exit_prob(PhaseIdealLoop *phase) {
2980   Node *test = tail();
2981   while (test != _head) {
2982     uint top = test-&gt;Opcode();
2983     if (top == Op_IfTrue || top == Op_IfFalse) {
2984       int test_con = ((ProjNode*)test)-&gt;_con;
2985       assert(top == (uint)(test_con? Op_IfTrue: Op_IfFalse), &quot;sanity&quot;);
2986       IfNode *iff = test-&gt;in(0)-&gt;as_If();
2987       if (iff-&gt;outcnt() == 2) {         // Ignore dead tests
2988         Node *bol = iff-&gt;in(1);
2989         if (bol &amp;&amp; bol-&gt;req() &gt; 1 &amp;&amp; bol-&gt;in(1) &amp;&amp;
2990             ((bol-&gt;in(1)-&gt;Opcode() == Op_StorePConditional) ||
2991              (bol-&gt;in(1)-&gt;Opcode() == Op_StoreIConditional) ||
2992              (bol-&gt;in(1)-&gt;Opcode() == Op_StoreLConditional) ||
2993              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeB) ||
2994              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeS) ||
2995              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeI) ||
2996              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeL) ||
2997              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeP) ||
2998              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeN) ||
2999              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapB) ||
3000              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapS) ||
3001              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapI) ||
3002              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapL) ||
3003              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapP) ||
3004              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapN) ||
3005              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapB) ||
3006              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapS) ||
3007              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapI) ||
3008              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapL) ||
3009              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapP) ||
3010              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapN) ||
3011              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndExchangeP) ||
3012              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndExchangeN) ||
3013              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahWeakCompareAndSwapP) ||
3014              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahWeakCompareAndSwapN) ||
3015              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndSwapP) ||
3016              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndSwapN)))
3017           return;               // Allocation loops RARELY take backedge
3018         // Find the OTHER exit path from the IF
3019         Node* ex = iff-&gt;proj_out(1-test_con);
3020         float p = iff-&gt;_prob;
3021         if (!phase-&gt;is_member(this, ex) &amp;&amp; iff-&gt;_fcnt == COUNT_UNKNOWN) {
3022           if (top == Op_IfTrue) {
3023             if (p &lt; (PROB_FAIR + PROB_UNLIKELY_MAG(3))) {
3024               iff-&gt;_prob = PROB_STATIC_FREQUENT;
3025             }
3026           } else {
3027             if (p &gt; (PROB_FAIR - PROB_UNLIKELY_MAG(3))) {
3028               iff-&gt;_prob = PROB_STATIC_INFREQUENT;
3029             }
3030           }
3031         }
3032       }
3033     }
3034     test = phase-&gt;idom(test);
3035   }
3036 }
3037 
3038 #ifdef ASSERT
3039 static CountedLoopNode* locate_pre_from_main(CountedLoopNode* main_loop) {
3040   assert(!main_loop-&gt;is_main_no_pre_loop(), &quot;Does not have a pre loop&quot;);
3041   Node* ctrl = main_loop-&gt;skip_predicates();
3042   assert(ctrl-&gt;Opcode() == Op_IfTrue || ctrl-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
3043   Node* iffm = ctrl-&gt;in(0);
3044   assert(iffm-&gt;Opcode() == Op_If, &quot;&quot;);
3045   Node* p_f = iffm-&gt;in(0);
3046   assert(p_f-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
3047   CountedLoopNode* pre_loop = p_f-&gt;in(0)-&gt;as_CountedLoopEnd()-&gt;loopnode();
3048   assert(pre_loop-&gt;is_pre_loop(), &quot;No pre loop found&quot;);
3049   return pre_loop;
3050 }
3051 #endif
3052 
3053 // Remove the main and post loops and make the pre loop execute all
3054 // iterations. Useful when the pre loop is found empty.
3055 void IdealLoopTree::remove_main_post_loops(CountedLoopNode *cl, PhaseIdealLoop *phase) {
3056   CountedLoopEndNode* pre_end = cl-&gt;loopexit();
3057   Node* pre_cmp = pre_end-&gt;cmp_node();
3058   if (pre_cmp-&gt;in(2)-&gt;Opcode() != Op_Opaque1) {
3059     // Only safe to remove the main loop if the compiler optimized it
3060     // out based on an unknown number of iterations
3061     return;
3062   }
3063 
3064   // Can we find the main loop?
3065   if (_next == NULL) {
3066     return;
3067   }
3068 
3069   Node* next_head = _next-&gt;_head;
3070   if (!next_head-&gt;is_CountedLoop()) {
3071     return;
3072   }
3073 
3074   CountedLoopNode* main_head = next_head-&gt;as_CountedLoop();
3075   if (!main_head-&gt;is_main_loop() || main_head-&gt;is_main_no_pre_loop()) {
3076     return;
3077   }
3078 
3079   assert(locate_pre_from_main(main_head) == cl, &quot;bad main loop&quot;);
3080   Node* main_iff = main_head-&gt;skip_predicates()-&gt;in(0);
3081 
3082   // Remove the Opaque1Node of the pre loop and make it execute all iterations
3083   phase-&gt;_igvn.replace_input_of(pre_cmp, 2, pre_cmp-&gt;in(2)-&gt;in(2));
3084   // Remove the Opaque1Node of the main loop so it can be optimized out
3085   Node* main_cmp = main_iff-&gt;in(1)-&gt;in(1);
3086   assert(main_cmp-&gt;in(2)-&gt;Opcode() == Op_Opaque1, &quot;main loop has no opaque node?&quot;);
3087   phase-&gt;_igvn.replace_input_of(main_cmp, 2, main_cmp-&gt;in(2)-&gt;in(1));
3088 }
3089 
3090 //------------------------------do_remove_empty_loop---------------------------
3091 // We always attempt remove empty loops.   The approach is to replace the trip
3092 // counter with the value it will have on the last iteration.  This will break
3093 // the loop.
3094 bool IdealLoopTree::do_remove_empty_loop(PhaseIdealLoop *phase) {
3095   // Minimum size must be empty loop
3096   if (_body.size() &gt; EMPTY_LOOP_SIZE) {
3097     return false;
3098   }
3099   if (!_head-&gt;is_CountedLoop()) {
3100     return false;   // Dead loop
3101   }
3102   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
3103   if (!cl-&gt;is_valid_counted_loop()) {
3104     return false;   // Malformed loop
3105   }
3106   if (!phase-&gt;is_member(this, phase-&gt;get_ctrl(cl-&gt;loopexit()-&gt;in(CountedLoopEndNode::TestValue)))) {
3107     return false;   // Infinite loop
3108   }
3109   if (cl-&gt;is_pre_loop()) {
3110     // If the loop we are removing is a pre-loop then the main and post loop
3111     // can be removed as well.
3112     remove_main_post_loops(cl, phase);
3113   }
3114 
3115 #ifdef ASSERT
3116   // Ensure only one phi which is the iv.
3117   Node* iv = NULL;
3118   for (DUIterator_Fast imax, i = cl-&gt;fast_outs(imax); i &lt; imax; i++) {
3119     Node* n = cl-&gt;fast_out(i);
3120     if (n-&gt;Opcode() == Op_Phi) {
3121       assert(iv == NULL, &quot;Too many phis&quot;);
3122       iv = n;
3123     }
3124   }
3125   assert(iv == cl-&gt;phi(), &quot;Wrong phi&quot;);
3126 #endif
3127 
3128   // main and post loops have explicitly created zero trip guard
3129   bool needs_guard = !cl-&gt;is_main_loop() &amp;&amp; !cl-&gt;is_post_loop();
3130   if (needs_guard) {
3131     // Skip guard if values not overlap.
3132     const TypeInt* init_t = phase-&gt;_igvn.type(cl-&gt;init_trip())-&gt;is_int();
3133     const TypeInt* limit_t = phase-&gt;_igvn.type(cl-&gt;limit())-&gt;is_int();
3134     int  stride_con = cl-&gt;stride_con();
3135     if (stride_con &gt; 0) {
3136       needs_guard = (init_t-&gt;_hi &gt;= limit_t-&gt;_lo);
3137     } else {
3138       needs_guard = (init_t-&gt;_lo &lt;= limit_t-&gt;_hi);
3139     }
3140   }
3141   if (needs_guard) {
3142     // Check for an obvious zero trip guard.
3143     Node* inctrl = PhaseIdealLoop::skip_all_loop_predicates(cl-&gt;skip_predicates());
3144     if (inctrl-&gt;Opcode() == Op_IfTrue || inctrl-&gt;Opcode() == Op_IfFalse) {
3145       bool maybe_swapped = (inctrl-&gt;Opcode() == Op_IfFalse);
3146       // The test should look like just the backedge of a CountedLoop
3147       Node* iff = inctrl-&gt;in(0);
3148       if (iff-&gt;is_If()) {
3149         Node* bol = iff-&gt;in(1);
3150         if (bol-&gt;is_Bool()) {
3151           BoolTest test = bol-&gt;as_Bool()-&gt;_test;
3152           if (maybe_swapped) {
3153             test._test = test.commute();
3154             test._test = test.negate();
3155           }
3156           if (test._test == cl-&gt;loopexit()-&gt;test_trip()) {
3157             Node* cmp = bol-&gt;in(1);
3158             int init_idx = maybe_swapped ? 2 : 1;
3159             int limit_idx = maybe_swapped ? 1 : 2;
3160             if (cmp-&gt;is_Cmp() &amp;&amp; cmp-&gt;in(init_idx) == cl-&gt;init_trip() &amp;&amp; cmp-&gt;in(limit_idx) == cl-&gt;limit()) {
3161               needs_guard = false;
3162             }
3163           }
3164         }
3165       }
3166     }
3167   }
3168 
3169 #ifndef PRODUCT
3170   if (PrintOpto) {
3171     tty-&gt;print(&quot;Removing empty loop with%s zero trip guard&quot;, needs_guard ? &quot;out&quot; : &quot;&quot;);
3172     this-&gt;dump_head();
3173   } else if (TraceLoopOpts) {
3174     tty-&gt;print(&quot;Empty with%s zero trip guard   &quot;, needs_guard ? &quot;out&quot; : &quot;&quot;);
3175     this-&gt;dump_head();
3176   }
3177 #endif
3178 
3179   if (needs_guard) {
3180     // Peel the loop to ensure there&#39;s a zero trip guard
3181     Node_List old_new;
3182     phase-&gt;do_peeling(this, old_new);
3183   }
3184 
3185   // Replace the phi at loop head with the final value of the last
3186   // iteration.  Then the CountedLoopEnd will collapse (backedge never
3187   // taken) and all loop-invariant uses of the exit values will be correct.
3188   Node *phi = cl-&gt;phi();
3189   Node *exact_limit = phase-&gt;exact_limit(this);
3190   if (exact_limit != cl-&gt;limit()) {
3191     // We also need to replace the original limit to collapse loop exit.
3192     Node* cmp = cl-&gt;loopexit()-&gt;cmp_node();
3193     assert(cl-&gt;limit() == cmp-&gt;in(2), &quot;sanity&quot;);
3194     // Duplicate cmp node if it has other users
3195     if (cmp-&gt;outcnt() &gt; 1) {
3196       cmp = cmp-&gt;clone();
3197       cmp = phase-&gt;_igvn.register_new_node_with_optimizer(cmp);
3198       BoolNode *bol = cl-&gt;loopexit()-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();
3199       phase-&gt;_igvn.replace_input_of(bol, 1, cmp); // put bol on worklist
3200     }
3201     phase-&gt;_igvn._worklist.push(cmp-&gt;in(2)); // put limit on worklist
3202     phase-&gt;_igvn.replace_input_of(cmp, 2, exact_limit); // put cmp on worklist
3203   }
3204   // Note: the final value after increment should not overflow since
3205   // counted loop has limit check predicate.
3206   Node *final = new SubINode(exact_limit, cl-&gt;stride());
3207   phase-&gt;register_new_node(final,cl-&gt;in(LoopNode::EntryControl));
3208   phase-&gt;_igvn.replace_node(phi,final);
3209   phase-&gt;C-&gt;set_major_progress();
3210   return true;
3211 }
3212 
3213 //------------------------------do_one_iteration_loop--------------------------
3214 // Convert one iteration loop into normal code.
3215 bool IdealLoopTree::do_one_iteration_loop(PhaseIdealLoop *phase) {
3216   if (!_head-&gt;as_Loop()-&gt;is_valid_counted_loop()) {
3217     return false; // Only for counted loop
3218   }
3219   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
3220   if (!cl-&gt;has_exact_trip_count() || cl-&gt;trip_count() != 1) {
3221     return false;
3222   }
3223 
3224 #ifndef PRODUCT
3225   if (TraceLoopOpts) {
3226     tty-&gt;print(&quot;OneIteration &quot;);
3227     this-&gt;dump_head();
3228   }
3229 #endif
3230 
3231   Node *init_n = cl-&gt;init_trip();
3232 #ifdef ASSERT
3233   // Loop boundaries should be constant since trip count is exact.
3234   assert(init_n-&gt;get_int() + cl-&gt;stride_con() &gt;= cl-&gt;limit()-&gt;get_int(), &quot;should be one iteration&quot;);
3235 #endif
3236   // Replace the phi at loop head with the value of the init_trip.
3237   // Then the CountedLoopEnd will collapse (backedge will not be taken)
3238   // and all loop-invariant uses of the exit values will be correct.
3239   phase-&gt;_igvn.replace_node(cl-&gt;phi(), cl-&gt;init_trip());
3240   phase-&gt;C-&gt;set_major_progress();
3241   return true;
3242 }
3243 
3244 //=============================================================================
3245 //------------------------------iteration_split_impl---------------------------
3246 bool IdealLoopTree::iteration_split_impl(PhaseIdealLoop *phase, Node_List &amp;old_new) {
3247   // Compute loop trip count if possible.
3248   compute_trip_count(phase);
3249 
3250   // Convert one iteration loop into normal code.
3251   if (do_one_iteration_loop(phase)) {
3252     return true;
3253   }
3254   // Check and remove empty loops (spam micro-benchmarks)
3255   if (do_remove_empty_loop(phase)) {
3256     return true;  // Here we removed an empty loop
3257   }
3258 
3259   AutoNodeBudget node_budget(phase);
3260 
3261   // Non-counted loops may be peeled; exactly 1 iteration is peeled.
3262   // This removes loop-invariant tests (usually null checks).
3263   if (!_head-&gt;is_CountedLoop()) { // Non-counted loop
3264     if (PartialPeelLoop &amp;&amp; phase-&gt;partial_peel(this, old_new)) {
3265       // Partial peel succeeded so terminate this round of loop opts
3266       return false;
3267     }
3268     if (policy_peeling(phase)) {    // Should we peel?
3269       if (PrintOpto) { tty-&gt;print_cr(&quot;should_peel&quot;); }
3270       phase-&gt;do_peeling(this, old_new);
3271     } else if (policy_unswitching(phase)) {
3272       phase-&gt;do_unswitching(this, old_new);
3273     }
3274     return true;
3275   }
3276   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
3277 
3278   if (!cl-&gt;is_valid_counted_loop()) return true; // Ignore various kinds of broken loops
3279 
3280   // Do nothing special to pre- and post- loops
3281   if (cl-&gt;is_pre_loop() || cl-&gt;is_post_loop()) return true;
3282 
3283   // Compute loop trip count from profile data
3284   compute_profile_trip_cnt(phase);
3285 
3286   // Before attempting fancy unrolling, RCE or alignment, see if we want
3287   // to completely unroll this loop or do loop unswitching.
3288   if (cl-&gt;is_normal_loop()) {
3289     if (policy_unswitching(phase)) {
3290       phase-&gt;do_unswitching(this, old_new);
3291       return true;
3292     }
3293     if (policy_maximally_unroll(phase)) {
3294       // Here we did some unrolling and peeling.  Eventually we will
3295       // completely unroll this loop and it will no longer be a loop.
3296       phase-&gt;do_maximally_unroll(this, old_new);
3297       return true;
3298     }
3299   }
3300 
3301   uint est_peeling = estimate_peeling(phase);
3302   bool should_peel = 0 &lt; est_peeling;
3303 
3304   // Counted loops may be peeled, may need some iterations run up
3305   // front for RCE, and may want to align loop refs to a cache
3306   // line.  Thus we clone a full loop up front whose trip count is
3307   // at least 1 (if peeling), but may be several more.
3308 
3309   // The main loop will start cache-line aligned with at least 1
3310   // iteration of the unrolled body (zero-trip test required) and
3311   // will have some range checks removed.
3312 
3313   // A post-loop will finish any odd iterations (leftover after
3314   // unrolling), plus any needed for RCE purposes.
3315 
3316   bool should_unroll = policy_unroll(phase);
3317   bool should_rce    = policy_range_check(phase);
3318   // TODO: Remove align -- not used.
3319   bool should_align  = policy_align(phase);
3320 
3321   // If not RCE&#39;ing  (iteration splitting) or Aligning, then we  do not need a
3322   // pre-loop.  We may still need to peel an initial iteration but we will not
3323   // be needing an unknown number of pre-iterations.
3324   //
3325   // Basically, if may_rce_align reports FALSE first time through, we will not
3326   // be able to later do RCE or Aligning on this loop.
3327   bool may_rce_align = !policy_peel_only(phase) || should_rce || should_align;
3328 
3329   // If we have any of these conditions (RCE, alignment, unrolling) met, then
3330   // we switch to the pre-/main-/post-loop model.  This model also covers
3331   // peeling.
3332   if (should_rce || should_align || should_unroll) {
3333     if (cl-&gt;is_normal_loop()) { // Convert to &#39;pre/main/post&#39; loops
3334       uint estimate = est_loop_clone_sz(3);
3335       if (!phase-&gt;may_require_nodes(estimate)) {
3336         return false;
3337       }
3338       phase-&gt;insert_pre_post_loops(this, old_new, !may_rce_align);
3339     }
3340     // Adjust the pre- and main-loop limits to let the pre and  post loops run
3341     // with full checks, but the main-loop with no checks.  Remove said checks
3342     // from the main body.
3343     if (should_rce) {
3344       if (phase-&gt;do_range_check(this, old_new) != 0) {
3345         cl-&gt;mark_has_range_checks();
3346       }
3347     } else if (PostLoopMultiversioning) {
3348       phase-&gt;has_range_checks(this);
3349     }
3350 
3351     if (should_unroll &amp;&amp; !should_peel &amp;&amp; PostLoopMultiversioning) {
3352       // Try to setup multiversioning on main loops before they are unrolled
3353       if (cl-&gt;is_main_loop() &amp;&amp; (cl-&gt;unrolled_count() == 1)) {
3354         phase-&gt;insert_scalar_rced_post_loop(this, old_new);
3355       }
3356     }
3357 
3358     // Double loop body for unrolling.  Adjust the minimum-trip test (will do
3359     // twice as many iterations as before) and the main body limit (only do
3360     // an even number of trips).  If we are peeling, we might enable some RCE
3361     // and we&#39;d rather unroll the post-RCE&#39;d loop SO... do not unroll if
3362     // peeling.
3363     if (should_unroll &amp;&amp; !should_peel) {
3364       if (SuperWordLoopUnrollAnalysis) {
3365         phase-&gt;insert_vector_post_loop(this, old_new);
3366       }
3367       phase-&gt;do_unroll(this, old_new, true);
3368     }
3369 
3370     // Adjust the pre-loop limits to align the main body iterations.
3371     if (should_align) {
3372       Unimplemented();
3373     }
3374   } else {                      // Else we have an unchanged counted loop
3375     if (should_peel) {          // Might want to peel but do nothing else
3376       if (phase-&gt;may_require_nodes(est_peeling)) {
3377         phase-&gt;do_peeling(this, old_new);
3378       }
3379     }
3380   }
3381   return true;
3382 }
3383 
3384 
3385 //=============================================================================
3386 //------------------------------iteration_split--------------------------------
3387 bool IdealLoopTree::iteration_split(PhaseIdealLoop* phase, Node_List &amp;old_new) {
3388   // Recursively iteration split nested loops
3389   if (_child &amp;&amp; !_child-&gt;iteration_split(phase, old_new)) {
3390     return false;
3391   }
3392 
3393   // Clean out prior deadwood
3394   DCE_loop_body();
3395 
3396   // Look for loop-exit tests with my 50/50 guesses from the Parsing stage.
3397   // Replace with a 1-in-10 exit guess.
3398   if (!is_root() &amp;&amp; is_loop()) {
3399     adjust_loop_exit_prob(phase);
3400   }
3401 
3402   // Unrolling, RCE and peeling efforts, iff innermost loop.
3403   if (_allow_optimizations &amp;&amp; is_innermost()) {
3404     if (!_has_call) {
3405       if (!iteration_split_impl(phase, old_new)) {
3406         return false;
3407       }
3408     } else {
3409       AutoNodeBudget node_budget(phase);
3410       if (policy_unswitching(phase)) {
3411         phase-&gt;do_unswitching(this, old_new);
3412       }
3413     }
3414   }
3415 
3416   // Minor offset re-organization to remove loop-fallout uses of
3417   // trip counter when there was no major reshaping.
3418   phase-&gt;reorg_offsets(this);
3419 
3420   if (_next &amp;&amp; !_next-&gt;iteration_split(phase, old_new)) {
3421     return false;
3422   }
3423   return true;
3424 }
3425 
3426 
3427 //=============================================================================
3428 // Process all the loops in the loop tree and replace any fill
3429 // patterns with an intrinsic version.
3430 bool PhaseIdealLoop::do_intrinsify_fill() {
3431   bool changed = false;
3432   for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {
3433     IdealLoopTree* lpt = iter.current();
3434     changed |= intrinsify_fill(lpt);
3435   }
3436   return changed;
3437 }
3438 
3439 
3440 // Examine an inner loop looking for a a single store of an invariant
3441 // value in a unit stride loop,
3442 bool PhaseIdealLoop::match_fill_loop(IdealLoopTree* lpt, Node*&amp; store, Node*&amp; store_value,
3443                                      Node*&amp; shift, Node*&amp; con) {
3444   const char* msg = NULL;
3445   Node* msg_node = NULL;
3446 
3447   store_value = NULL;
3448   con = NULL;
3449   shift = NULL;
3450 
3451   // Process the loop looking for stores.  If there are multiple
3452   // stores or extra control flow give at this point.
3453   CountedLoopNode* head = lpt-&gt;_head-&gt;as_CountedLoop();
3454   for (uint i = 0; msg == NULL &amp;&amp; i &lt; lpt-&gt;_body.size(); i++) {
3455     Node* n = lpt-&gt;_body.at(i);
3456     if (n-&gt;outcnt() == 0) continue; // Ignore dead
3457     if (n-&gt;is_Store()) {
3458       if (store != NULL) {
3459         msg = &quot;multiple stores&quot;;
3460         break;
3461       }
3462       int opc = n-&gt;Opcode();
3463       if (opc == Op_StoreP || opc == Op_StoreN || opc == Op_StoreNKlass || opc == Op_StoreCM) {
3464         msg = &quot;oop fills not handled&quot;;
3465         break;
3466       }
3467       Node* value = n-&gt;in(MemNode::ValueIn);
3468       if (!lpt-&gt;is_invariant(value)) {
3469         msg  = &quot;variant store value&quot;;
3470       } else if (!_igvn.type(n-&gt;in(MemNode::Address))-&gt;isa_aryptr()) {
3471         msg = &quot;not array address&quot;;
3472       }
3473       store = n;
3474       store_value = value;
3475     } else if (n-&gt;is_If() &amp;&amp; n != head-&gt;loopexit_or_null()) {
3476       msg = &quot;extra control flow&quot;;
3477       msg_node = n;
3478     }
3479   }
3480 
3481   if (store == NULL) {
3482     // No store in loop
3483     return false;
3484   }
3485 
3486   if (msg == NULL &amp;&amp; head-&gt;stride_con() != 1) {
3487     // could handle negative strides too
3488     if (head-&gt;stride_con() &lt; 0) {
3489       msg = &quot;negative stride&quot;;
3490     } else {
3491       msg = &quot;non-unit stride&quot;;
3492     }
3493   }
3494 
3495   if (msg == NULL &amp;&amp; !store-&gt;in(MemNode::Address)-&gt;is_AddP()) {
3496     msg = &quot;can&#39;t handle store address&quot;;
3497     msg_node = store-&gt;in(MemNode::Address);
3498   }
3499 
3500   if (msg == NULL &amp;&amp;
3501       (!store-&gt;in(MemNode::Memory)-&gt;is_Phi() ||
3502        store-&gt;in(MemNode::Memory)-&gt;in(LoopNode::LoopBackControl) != store)) {
3503     msg = &quot;store memory isn&#39;t proper phi&quot;;
3504     msg_node = store-&gt;in(MemNode::Memory);
3505   }
3506 
3507   // Make sure there is an appropriate fill routine
3508   BasicType t = store-&gt;as_Mem()-&gt;memory_type();
3509   const char* fill_name;
3510   if (msg == NULL &amp;&amp;
3511       StubRoutines::select_fill_function(t, false, fill_name) == NULL) {
3512     msg = &quot;unsupported store&quot;;
3513     msg_node = store;
3514   }
3515 
3516   if (msg != NULL) {
3517 #ifndef PRODUCT
3518     if (TraceOptimizeFill) {
3519       tty-&gt;print_cr(&quot;not fill intrinsic candidate: %s&quot;, msg);
3520       if (msg_node != NULL) msg_node-&gt;dump();
3521     }
3522 #endif
3523     return false;
3524   }
3525 
3526   // Make sure the address expression can be handled.  It should be
3527   // head-&gt;phi * elsize + con.  head-&gt;phi might have a ConvI2L(CastII()).
3528   Node* elements[4];
3529   Node* cast = NULL;
3530   Node* conv = NULL;
3531   bool found_index = false;
3532   int count = store-&gt;in(MemNode::Address)-&gt;as_AddP()-&gt;unpack_offsets(elements, ARRAY_SIZE(elements));
3533   for (int e = 0; e &lt; count; e++) {
3534     Node* n = elements[e];
3535     if (n-&gt;is_Con() &amp;&amp; con == NULL) {
3536       con = n;
3537     } else if (n-&gt;Opcode() == Op_LShiftX &amp;&amp; shift == NULL) {
3538       Node* value = n-&gt;in(1);
3539 #ifdef _LP64
3540       if (value-&gt;Opcode() == Op_ConvI2L) {
3541         conv = value;
3542         value = value-&gt;in(1);
3543       }
3544       if (value-&gt;Opcode() == Op_CastII &amp;&amp;
3545           value-&gt;as_CastII()-&gt;has_range_check()) {
3546         // Skip range check dependent CastII nodes
3547         cast = value;
3548         value = value-&gt;in(1);
3549       }
3550 #endif
3551       if (value != head-&gt;phi()) {
3552         msg = &quot;unhandled shift in address&quot;;
3553       } else {
3554         if (type2aelembytes(store-&gt;as_Mem()-&gt;memory_type(), true) != (1 &lt;&lt; n-&gt;in(2)-&gt;get_int())) {
3555           msg = &quot;scale doesn&#39;t match&quot;;
3556         } else {
3557           found_index = true;
3558           shift = n;
3559         }
3560       }
3561     } else if (n-&gt;Opcode() == Op_ConvI2L &amp;&amp; conv == NULL) {
3562       conv = n;
3563       n = n-&gt;in(1);
3564       if (n-&gt;Opcode() == Op_CastII &amp;&amp;
3565           n-&gt;as_CastII()-&gt;has_range_check()) {
3566         // Skip range check dependent CastII nodes
3567         cast = n;
3568         n = n-&gt;in(1);
3569       }
3570       if (n == head-&gt;phi()) {
3571         found_index = true;
3572       } else {
3573         msg = &quot;unhandled input to ConvI2L&quot;;
3574       }
3575     } else if (n == head-&gt;phi()) {
3576       // no shift, check below for allowed cases
3577       found_index = true;
3578     } else {
3579       msg = &quot;unhandled node in address&quot;;
3580       msg_node = n;
3581     }
3582   }
3583 
3584   if (count == -1) {
3585     msg = &quot;malformed address expression&quot;;
3586     msg_node = store;
3587   }
3588 
3589   if (!found_index) {
3590     msg = &quot;missing use of index&quot;;
3591   }
3592 
3593   // byte sized items won&#39;t have a shift
3594   if (msg == NULL &amp;&amp; shift == NULL &amp;&amp; t != T_BYTE &amp;&amp; t != T_BOOLEAN) {
3595     msg = &quot;can&#39;t find shift&quot;;
3596     msg_node = store;
3597   }
3598 
3599   if (msg != NULL) {
3600 #ifndef PRODUCT
3601     if (TraceOptimizeFill) {
3602       tty-&gt;print_cr(&quot;not fill intrinsic: %s&quot;, msg);
3603       if (msg_node != NULL) msg_node-&gt;dump();
3604     }
3605 #endif
3606     return false;
3607   }
3608 
3609   // No make sure all the other nodes in the loop can be handled
3610   VectorSet ok;
3611 
3612   // store related values are ok
3613   ok.set(store-&gt;_idx);
3614   ok.set(store-&gt;in(MemNode::Memory)-&gt;_idx);
3615 
3616   CountedLoopEndNode* loop_exit = head-&gt;loopexit();
3617 
3618   // Loop structure is ok
3619   ok.set(head-&gt;_idx);
3620   ok.set(loop_exit-&gt;_idx);
3621   ok.set(head-&gt;phi()-&gt;_idx);
3622   ok.set(head-&gt;incr()-&gt;_idx);
3623   ok.set(loop_exit-&gt;cmp_node()-&gt;_idx);
3624   ok.set(loop_exit-&gt;in(1)-&gt;_idx);
3625 
3626   // Address elements are ok
3627   if (con)   ok.set(con-&gt;_idx);
3628   if (shift) ok.set(shift-&gt;_idx);
3629   if (cast)  ok.set(cast-&gt;_idx);
3630   if (conv)  ok.set(conv-&gt;_idx);
3631 
3632   for (uint i = 0; msg == NULL &amp;&amp; i &lt; lpt-&gt;_body.size(); i++) {
3633     Node* n = lpt-&gt;_body.at(i);
3634     if (n-&gt;outcnt() == 0) continue; // Ignore dead
3635     if (ok.test(n-&gt;_idx)) continue;
3636     // Backedge projection is ok
3637     if (n-&gt;is_IfTrue() &amp;&amp; n-&gt;in(0) == loop_exit) continue;
3638     if (!n-&gt;is_AddP()) {
3639       msg = &quot;unhandled node&quot;;
3640       msg_node = n;
3641       break;
3642     }
3643   }
3644 
3645   // Make sure no unexpected values are used outside the loop
3646   for (uint i = 0; msg == NULL &amp;&amp; i &lt; lpt-&gt;_body.size(); i++) {
3647     Node* n = lpt-&gt;_body.at(i);
3648     // These values can be replaced with other nodes if they are used
3649     // outside the loop.
3650     if (n == store || n == loop_exit || n == head-&gt;incr() || n == store-&gt;in(MemNode::Memory)) continue;
3651     for (SimpleDUIterator iter(n); iter.has_next(); iter.next()) {
3652       Node* use = iter.get();
3653       if (!lpt-&gt;_body.contains(use)) {
3654         if (n-&gt;is_CountedLoop() &amp;&amp; n-&gt;as_CountedLoop()-&gt;is_strip_mined()) {
3655           // In strip-mined counted loops, the CountedLoopNode may be
3656           // used by the address polling node of the outer safepoint.
3657           // Skip this use because it&#39;s safe.
3658 #ifdef ASSERT
3659           Node* sfpt = n-&gt;as_CountedLoop()-&gt;outer_safepoint();
3660           Node* polladr = sfpt-&gt;in(TypeFunc::Parms+0);
3661           assert(use == polladr, &quot;the use should be a safepoint polling&quot;);
3662 #endif
3663           continue;
3664         } else {
3665           msg = &quot;node is used outside loop&quot;;
3666           msg_node = n;
3667           break;
3668         }
3669       }
3670     }
3671   }
3672 
3673 #ifdef ASSERT
3674   if (TraceOptimizeFill) {
3675     if (msg != NULL) {
3676       tty-&gt;print_cr(&quot;no fill intrinsic: %s&quot;, msg);
3677       if (msg_node != NULL) msg_node-&gt;dump();
3678     } else {
3679       tty-&gt;print_cr(&quot;fill intrinsic for:&quot;);
3680     }
3681     store-&gt;dump();
3682     if (Verbose) {
3683       lpt-&gt;_body.dump();
3684     }
3685   }
3686 #endif
3687 
3688   return msg == NULL;
3689 }
3690 
3691 
3692 
3693 bool PhaseIdealLoop::intrinsify_fill(IdealLoopTree* lpt) {
3694   // Only for counted inner loops
3695   if (!lpt-&gt;is_counted() || !lpt-&gt;is_innermost()) {
3696     return false;
3697   }
3698 
3699   // Must have constant stride
3700   CountedLoopNode* head = lpt-&gt;_head-&gt;as_CountedLoop();
3701   if (!head-&gt;is_valid_counted_loop() || !head-&gt;is_normal_loop()) {
3702     return false;
3703   }
3704 
3705   head-&gt;verify_strip_mined(1);
3706 
3707   // Check that the body only contains a store of a loop invariant
3708   // value that is indexed by the loop phi.
3709   Node* store = NULL;
3710   Node* store_value = NULL;
3711   Node* shift = NULL;
3712   Node* offset = NULL;
3713   if (!match_fill_loop(lpt, store, store_value, shift, offset)) {
3714     return false;
3715   }
3716 
3717   Node* exit = head-&gt;loopexit()-&gt;proj_out_or_null(0);
3718   if (exit == NULL) {
3719     return false;
3720   }
3721 
3722 #ifndef PRODUCT
3723   if (TraceLoopOpts) {
3724     tty-&gt;print(&quot;ArrayFill    &quot;);
3725     lpt-&gt;dump_head();
3726   }
3727 #endif
3728 
3729   // Now replace the whole loop body by a call to a fill routine that
3730   // covers the same region as the loop.
3731   Node* base = store-&gt;in(MemNode::Address)-&gt;as_AddP()-&gt;in(AddPNode::Base);
3732 
3733   // Build an expression for the beginning of the copy region
3734   Node* index = head-&gt;init_trip();
3735 #ifdef _LP64
3736   index = new ConvI2LNode(index);
3737   _igvn.register_new_node_with_optimizer(index);
3738 #endif
3739   if (shift != NULL) {
3740     // byte arrays don&#39;t require a shift but others do.
3741     index = new LShiftXNode(index, shift-&gt;in(2));
3742     _igvn.register_new_node_with_optimizer(index);
3743   }
3744   index = new AddPNode(base, base, index);
3745   _igvn.register_new_node_with_optimizer(index);
3746   Node* from = new AddPNode(base, index, offset);
3747   _igvn.register_new_node_with_optimizer(from);
3748   // Compute the number of elements to copy
3749   Node* len = new SubINode(head-&gt;limit(), head-&gt;init_trip());
3750   _igvn.register_new_node_with_optimizer(len);
3751 
3752   BasicType t = store-&gt;as_Mem()-&gt;memory_type();
3753   bool aligned = false;
3754   if (offset != NULL &amp;&amp; head-&gt;init_trip()-&gt;is_Con()) {
3755     int element_size = type2aelembytes(t);
3756     aligned = (offset-&gt;find_intptr_t_type()-&gt;get_con() + head-&gt;init_trip()-&gt;get_int() * element_size) % HeapWordSize == 0;
3757   }
3758 
3759   // Build a call to the fill routine
3760   const char* fill_name;
3761   address fill = StubRoutines::select_fill_function(t, aligned, fill_name);
3762   assert(fill != NULL, &quot;what?&quot;);
3763 
3764   // Convert float/double to int/long for fill routines
3765   if (t == T_FLOAT) {
3766     store_value = new MoveF2INode(store_value);
3767     _igvn.register_new_node_with_optimizer(store_value);
3768   } else if (t == T_DOUBLE) {
3769     store_value = new MoveD2LNode(store_value);
3770     _igvn.register_new_node_with_optimizer(store_value);
3771   }
3772 
3773   Node* mem_phi = store-&gt;in(MemNode::Memory);
3774   Node* result_ctrl;
3775   Node* result_mem;
3776   const TypeFunc* call_type = OptoRuntime::array_fill_Type();
3777   CallLeafNode *call = new CallLeafNoFPNode(call_type, fill,
3778                                             fill_name, TypeAryPtr::get_array_body_type(t));
3779   uint cnt = 0;
3780   call-&gt;init_req(TypeFunc::Parms + cnt++, from);
3781   call-&gt;init_req(TypeFunc::Parms + cnt++, store_value);
3782 #ifdef _LP64
3783   len = new ConvI2LNode(len);
3784   _igvn.register_new_node_with_optimizer(len);
3785 #endif
3786   call-&gt;init_req(TypeFunc::Parms + cnt++, len);
3787 #ifdef _LP64
3788   call-&gt;init_req(TypeFunc::Parms + cnt++, C-&gt;top());
3789 #endif
3790   call-&gt;init_req(TypeFunc::Control,   head-&gt;init_control());
3791   call-&gt;init_req(TypeFunc::I_O,       C-&gt;top());       // Does no I/O.
3792   call-&gt;init_req(TypeFunc::Memory,    mem_phi-&gt;in(LoopNode::EntryControl));
3793   call-&gt;init_req(TypeFunc::ReturnAdr, C-&gt;start()-&gt;proj_out_or_null(TypeFunc::ReturnAdr));
3794   call-&gt;init_req(TypeFunc::FramePtr,  C-&gt;start()-&gt;proj_out_or_null(TypeFunc::FramePtr));
3795   _igvn.register_new_node_with_optimizer(call);
3796   result_ctrl = new ProjNode(call,TypeFunc::Control);
3797   _igvn.register_new_node_with_optimizer(result_ctrl);
3798   result_mem = new ProjNode(call,TypeFunc::Memory);
3799   _igvn.register_new_node_with_optimizer(result_mem);
3800 
3801 /* Disable following optimization until proper fix (add missing checks).
3802 
3803   // If this fill is tightly coupled to an allocation and overwrites
3804   // the whole body, allow it to take over the zeroing.
3805   AllocateNode* alloc = AllocateNode::Ideal_allocation(base, this);
3806   if (alloc != NULL &amp;&amp; alloc-&gt;is_AllocateArray()) {
3807     Node* length = alloc-&gt;as_AllocateArray()-&gt;Ideal_length();
3808     if (head-&gt;limit() == length &amp;&amp;
3809         head-&gt;init_trip() == _igvn.intcon(0)) {
3810       if (TraceOptimizeFill) {
3811         tty-&gt;print_cr(&quot;Eliminated zeroing in allocation&quot;);
3812       }
3813       alloc-&gt;maybe_set_complete(&amp;_igvn);
3814     } else {
3815 #ifdef ASSERT
3816       if (TraceOptimizeFill) {
3817         tty-&gt;print_cr(&quot;filling array but bounds don&#39;t match&quot;);
3818         alloc-&gt;dump();
3819         head-&gt;init_trip()-&gt;dump();
3820         head-&gt;limit()-&gt;dump();
3821         length-&gt;dump();
3822       }
3823 #endif
3824     }
3825   }
3826 */
3827 
3828   if (head-&gt;is_strip_mined()) {
3829     // Inner strip mined loop goes away so get rid of outer strip
3830     // mined loop
3831     Node* outer_sfpt = head-&gt;outer_safepoint();
3832     Node* in = outer_sfpt-&gt;in(0);
3833     Node* outer_out = head-&gt;outer_loop_exit();
3834     lazy_replace(outer_out, in);
3835     _igvn.replace_input_of(outer_sfpt, 0, C-&gt;top());
3836   }
3837 
3838   // Redirect the old control and memory edges that are outside the loop.
3839   // Sometimes the memory phi of the head is used as the outgoing
3840   // state of the loop.  It&#39;s safe in this case to replace it with the
3841   // result_mem.
3842   _igvn.replace_node(store-&gt;in(MemNode::Memory), result_mem);
3843   lazy_replace(exit, result_ctrl);
3844   _igvn.replace_node(store, result_mem);
3845   // Any uses the increment outside of the loop become the loop limit.
3846   _igvn.replace_node(head-&gt;incr(), head-&gt;limit());
3847 
3848   // Disconnect the head from the loop.
3849   for (uint i = 0; i &lt; lpt-&gt;_body.size(); i++) {
3850     Node* n = lpt-&gt;_body.at(i);
3851     _igvn.replace_node(n, C-&gt;top());
3852   }
3853 
3854   return true;
3855 }
    </pre>
  </body>
</html>