<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/ifnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciTypeFlow.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;memory/resourceArea.hpp&quot;
  29 #include &quot;opto/addnode.hpp&quot;
  30 #include &quot;opto/castnode.hpp&quot;
  31 #include &quot;opto/cfgnode.hpp&quot;
  32 #include &quot;opto/connode.hpp&quot;
  33 #include &quot;opto/loopnode.hpp&quot;
  34 #include &quot;opto/phaseX.hpp&quot;
  35 #include &quot;opto/runtime.hpp&quot;
  36 #include &quot;opto/rootnode.hpp&quot;
  37 #include &quot;opto/subnode.hpp&quot;
  38 
  39 // Portions of code courtesy of Clifford Click
  40 
  41 // Optimization - Graph Style
  42 
  43 
  44 #ifndef PRODUCT
  45 extern int explicit_null_checks_elided;
  46 #endif
  47 
  48 //=============================================================================
  49 //------------------------------Value------------------------------------------
  50 // Return a tuple for whichever arm of the IF is reachable
  51 const Type* IfNode::Value(PhaseGVN* phase) const {
  52   if( !in(0) ) return Type::TOP;
  53   if( phase-&gt;type(in(0)) == Type::TOP )
  54     return Type::TOP;
  55   const Type *t = phase-&gt;type(in(1));
  56   if( t == Type::TOP )          // data is undefined
  57     return TypeTuple::IFNEITHER; // unreachable altogether
  58   if( t == TypeInt::ZERO )      // zero, or false
  59     return TypeTuple::IFFALSE;  // only false branch is reachable
  60   if( t == TypeInt::ONE )       // 1, or true
  61     return TypeTuple::IFTRUE;   // only true branch is reachable
  62   assert( t == TypeInt::BOOL, &quot;expected boolean type&quot; );
  63 
  64   return TypeTuple::IFBOTH;     // No progress
  65 }
  66 
  67 const RegMask &amp;IfNode::out_RegMask() const {
  68   return RegMask::Empty;
  69 }
  70 
  71 //------------------------------split_if---------------------------------------
  72 // Look for places where we merge constants, then test on the merged value.
  73 // If the IF test will be constant folded on the path with the constant, we
  74 // win by splitting the IF to before the merge point.
  75 static Node* split_if(IfNode *iff, PhaseIterGVN *igvn) {
  76   // I could be a lot more general here, but I&#39;m trying to squeeze this
  77   // in before the Christmas &#39;98 break so I&#39;m gonna be kinda restrictive
  78   // on the patterns I accept.  CNC
  79 
  80   // Look for a compare of a constant and a merged value
  81   Node *i1 = iff-&gt;in(1);
  82   if( !i1-&gt;is_Bool() ) return NULL;
  83   BoolNode *b = i1-&gt;as_Bool();
  84   Node *cmp = b-&gt;in(1);
  85   if( !cmp-&gt;is_Cmp() ) return NULL;
  86   i1 = cmp-&gt;in(1);
  87   if( i1 == NULL || !i1-&gt;is_Phi() ) return NULL;
  88   PhiNode *phi = i1-&gt;as_Phi();
  89   if( phi-&gt;is_copy() ) return NULL;
  90   Node *con2 = cmp-&gt;in(2);
  91   if( !con2-&gt;is_Con() ) return NULL;
  92   // See that the merge point contains some constants
  93   Node *con1=NULL;
  94   uint i4;
  95   for( i4 = 1; i4 &lt; phi-&gt;req(); i4++ ) {
  96     con1 = phi-&gt;in(i4);
  97     if( !con1 ) return NULL;    // Do not optimize partially collapsed merges
  98     if( con1-&gt;is_Con() ) break; // Found a constant
  99     // Also allow null-vs-not-null checks
 100     const TypePtr *tp = igvn-&gt;type(con1)-&gt;isa_ptr();
 101     if( tp &amp;&amp; tp-&gt;_ptr == TypePtr::NotNull )
 102       break;
 103   }
 104   if( i4 &gt;= phi-&gt;req() ) return NULL; // Found no constants
 105 
 106   igvn-&gt;C-&gt;set_has_split_ifs(true); // Has chance for split-if
 107 
 108   // Make sure that the compare can be constant folded away
 109   Node *cmp2 = cmp-&gt;clone();
 110   cmp2-&gt;set_req(1,con1);
 111   cmp2-&gt;set_req(2,con2);
 112   const Type *t = cmp2-&gt;Value(igvn);
 113   // This compare is dead, so whack it!
 114   igvn-&gt;remove_dead_node(cmp2);
 115   if( !t-&gt;singleton() ) return NULL;
 116 
 117   // No intervening control, like a simple Call
 118   Node *r = iff-&gt;in(0);
 119   if( !r-&gt;is_Region() ) return NULL;
 120   if (r-&gt;is_Loop()) return NULL;
 121   if( phi-&gt;region() != r ) return NULL;
 122   // No other users of the cmp/bool
 123   if (b-&gt;outcnt() != 1 || cmp-&gt;outcnt() != 1) {
 124     //tty-&gt;print_cr(&quot;many users of cmp/bool&quot;);
 125     return NULL;
 126   }
 127 
 128   // Make sure we can determine where all the uses of merged values go
 129   for (DUIterator_Fast jmax, j = r-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 130     Node* u = r-&gt;fast_out(j);
 131     if( u == r ) continue;
 132     if( u == iff ) continue;
 133     if( u-&gt;outcnt() == 0 ) continue; // use is dead &amp; ignorable
 134     if( !u-&gt;is_Phi() ) {
 135       /*
 136       if( u-&gt;is_Start() ) {
 137         tty-&gt;print_cr(&quot;Region has inlined start use&quot;);
 138       } else {
 139         tty-&gt;print_cr(&quot;Region has odd use&quot;);
 140         u-&gt;dump(2);
 141       }*/
 142       return NULL;
 143     }
 144     if( u != phi ) {
 145       // CNC - do not allow any other merged value
 146       //tty-&gt;print_cr(&quot;Merging another value&quot;);
 147       //u-&gt;dump(2);
 148       return NULL;
 149     }
 150     // Make sure we can account for all Phi uses
 151     for (DUIterator_Fast kmax, k = u-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 152       Node* v = u-&gt;fast_out(k); // User of the phi
 153       // CNC - Allow only really simple patterns.
 154       // In particular I disallow AddP of the Phi, a fairly common pattern
 155       if (v == cmp) continue;  // The compare is OK
 156       if (v-&gt;is_ConstraintCast()) {
 157         // If the cast is derived from data flow edges, it may not have a control edge.
 158         // If so, it should be safe to split. But follow-up code can not deal with
 159         // this (l. 359). So skip.
 160         if (v-&gt;in(0) == NULL) {
 161           return NULL;
 162         }
 163         if (v-&gt;in(0)-&gt;in(0) == iff) {
 164           continue;               // CastPP/II of the IfNode is OK
 165         }
 166       }
 167       // Disabled following code because I cannot tell if exactly one
 168       // path dominates without a real dominator check. CNC 9/9/1999
 169       //uint vop = v-&gt;Opcode();
 170       //if( vop == Op_Phi ) {     // Phi from another merge point might be OK
 171       //  Node *r = v-&gt;in(0);     // Get controlling point
 172       //  if( !r ) return NULL;   // Degraded to a copy
 173       //  // Find exactly one path in (either True or False doms, but not IFF)
 174       //  int cnt = 0;
 175       //  for( uint i = 1; i &lt; r-&gt;req(); i++ )
 176       //    if( r-&gt;in(i) &amp;&amp; r-&gt;in(i)-&gt;in(0) == iff )
 177       //      cnt++;
 178       //  if( cnt == 1 ) continue; // Exactly one of True or False guards Phi
 179       //}
 180       if( !v-&gt;is_Call() ) {
 181         /*
 182         if( v-&gt;Opcode() == Op_AddP ) {
 183           tty-&gt;print_cr(&quot;Phi has AddP use&quot;);
 184         } else if( v-&gt;Opcode() == Op_CastPP ) {
 185           tty-&gt;print_cr(&quot;Phi has CastPP use&quot;);
 186         } else if( v-&gt;Opcode() == Op_CastII ) {
 187           tty-&gt;print_cr(&quot;Phi has CastII use&quot;);
 188         } else {
 189           tty-&gt;print_cr(&quot;Phi has use I cant be bothered with&quot;);
 190         }
 191         */
 192       }
 193       return NULL;
 194 
 195       /* CNC - Cut out all the fancy acceptance tests
 196       // Can we clone this use when doing the transformation?
 197       // If all uses are from Phis at this merge or constants, then YES.
 198       if( !v-&gt;in(0) &amp;&amp; v != cmp ) {
 199         tty-&gt;print_cr(&quot;Phi has free-floating use&quot;);
 200         v-&gt;dump(2);
 201         return NULL;
 202       }
 203       for( uint l = 1; l &lt; v-&gt;req(); l++ ) {
 204         if( (!v-&gt;in(l)-&gt;is_Phi() || v-&gt;in(l)-&gt;in(0) != r) &amp;&amp;
 205             !v-&gt;in(l)-&gt;is_Con() ) {
 206           tty-&gt;print_cr(&quot;Phi has use&quot;);
 207           v-&gt;dump(2);
 208           return NULL;
 209         } // End of if Phi-use input is neither Phi nor Constant
 210       } // End of for all inputs to Phi-use
 211       */
 212     } // End of for all uses of Phi
 213   } // End of for all uses of Region
 214 
 215   // Only do this if the IF node is in a sane state
 216   if (iff-&gt;outcnt() != 2)
 217     return NULL;
 218 
 219   // Got a hit!  Do the Mondo Hack!
 220   //
 221   //ABC  a1c   def   ghi            B     1     e     h   A C   a c   d f   g i
 222   // R - Phi - Phi - Phi            Rc - Phi - Phi - Phi   Rx - Phi - Phi - Phi
 223   //     cmp - 2                         cmp - 2               cmp - 2
 224   //       bool                            bool_c                bool_x
 225   //       if                               if_c                  if_x
 226   //      T  F                              T  F                  T  F
 227   // ..s..    ..t ..                   ..s..    ..t..        ..s..    ..t..
 228   //
 229   // Split the paths coming into the merge point into 2 separate groups of
 230   // merges.  On the left will be all the paths feeding constants into the
 231   // Cmp&#39;s Phi.  On the right will be the remaining paths.  The Cmp&#39;s Phi
 232   // will fold up into a constant; this will let the Cmp fold up as well as
 233   // all the control flow.  Below the original IF we have 2 control
 234   // dependent regions, &#39;s&#39; and &#39;t&#39;.  Now we will merge the two paths
 235   // just prior to &#39;s&#39; and &#39;t&#39; from the two IFs.  At least 1 path (and quite
 236   // likely 2 or more) will promptly constant fold away.
 237   PhaseGVN *phase = igvn;
 238 
 239   // Make a region merging constants and a region merging the rest
 240   uint req_c = 0;
 241   for (uint ii = 1; ii &lt; r-&gt;req(); ii++) {
 242     if (phi-&gt;in(ii) == con1) {
 243       req_c++;
 244     }
 245     Node* proj = PhaseIdealLoop::find_predicate(r-&gt;in(ii));
 246     if (proj != NULL) {
 247       return NULL;
 248     }
 249   }
 250 
 251   // If all the defs of the phi are the same constant, we already have the desired end state.
 252   // Skip the split that would create empty phi and region nodes.
 253   if((r-&gt;req() - req_c) == 1) {
 254     return NULL;
 255   }
 256 
 257   Node *region_c = new RegionNode(req_c + 1);
 258   Node *phi_c    = con1;
 259   uint  len      = r-&gt;req();
 260   Node *region_x = new RegionNode(len - req_c);
 261   Node *phi_x    = PhiNode::make_blank(region_x, phi);
 262   for (uint i = 1, i_c = 1, i_x = 1; i &lt; len; i++) {
 263     if (phi-&gt;in(i) == con1) {
 264       region_c-&gt;init_req( i_c++, r  -&gt;in(i) );
 265     } else {
 266       region_x-&gt;init_req( i_x,   r  -&gt;in(i) );
 267       phi_x   -&gt;init_req( i_x++, phi-&gt;in(i) );
 268     }
 269   }
 270 
 271   // Register the new RegionNodes but do not transform them.  Cannot
 272   // transform until the entire Region/Phi conglomerate has been hacked
 273   // as a single huge transform.
 274   igvn-&gt;register_new_node_with_optimizer( region_c );
 275   igvn-&gt;register_new_node_with_optimizer( region_x );
 276   // Prevent the untimely death of phi_x.  Currently he has no uses.  He is
 277   // about to get one.  If this only use goes away, then phi_x will look dead.
 278   // However, he will be picking up some more uses down below.
 279   Node *hook = new Node(4);
 280   hook-&gt;init_req(0, phi_x);
 281   hook-&gt;init_req(1, phi_c);
 282   phi_x = phase-&gt;transform( phi_x );
 283 
 284   // Make the compare
 285   Node *cmp_c = phase-&gt;makecon(t);
 286   Node *cmp_x = cmp-&gt;clone();
 287   cmp_x-&gt;set_req(1,phi_x);
 288   cmp_x-&gt;set_req(2,con2);
 289   cmp_x = phase-&gt;transform(cmp_x);
 290   // Make the bool
 291   Node *b_c = phase-&gt;transform(new BoolNode(cmp_c,b-&gt;_test._test));
 292   Node *b_x = phase-&gt;transform(new BoolNode(cmp_x,b-&gt;_test._test));
 293   // Make the IfNode
 294   IfNode* iff_c = iff-&gt;clone()-&gt;as_If();
 295   iff_c-&gt;set_req(0, region_c);
 296   iff_c-&gt;set_req(1, b_c);
 297   igvn-&gt;set_type_bottom(iff_c);
 298   igvn-&gt;_worklist.push(iff_c);
 299   hook-&gt;init_req(2, iff_c);
 300 
 301   IfNode* iff_x = iff-&gt;clone()-&gt;as_If();
 302   iff_x-&gt;set_req(0, region_x);
 303   iff_x-&gt;set_req(1, b_x);
 304   igvn-&gt;set_type_bottom(iff_x);
 305   igvn-&gt;_worklist.push(iff_x);
 306   hook-&gt;init_req(3, iff_x);
 307 
 308   // Make the true/false arms
 309   Node *iff_c_t = phase-&gt;transform(new IfTrueNode (iff_c));
 310   Node *iff_c_f = phase-&gt;transform(new IfFalseNode(iff_c));
 311   Node *iff_x_t = phase-&gt;transform(new IfTrueNode (iff_x));
 312   Node *iff_x_f = phase-&gt;transform(new IfFalseNode(iff_x));
 313 
 314   // Merge the TRUE paths
 315   Node *region_s = new RegionNode(3);
 316   igvn-&gt;_worklist.push(region_s);
 317   region_s-&gt;init_req(1, iff_c_t);
 318   region_s-&gt;init_req(2, iff_x_t);
 319   igvn-&gt;register_new_node_with_optimizer( region_s );
 320 
 321   // Merge the FALSE paths
 322   Node *region_f = new RegionNode(3);
 323   igvn-&gt;_worklist.push(region_f);
 324   region_f-&gt;init_req(1, iff_c_f);
 325   region_f-&gt;init_req(2, iff_x_f);
 326   igvn-&gt;register_new_node_with_optimizer( region_f );
 327 
 328   igvn-&gt;hash_delete(cmp);// Remove soon-to-be-dead node from hash table.
 329   cmp-&gt;set_req(1,NULL);  // Whack the inputs to cmp because it will be dead
 330   cmp-&gt;set_req(2,NULL);
 331   // Check for all uses of the Phi and give them a new home.
 332   // The &#39;cmp&#39; got cloned, but CastPP/IIs need to be moved.
 333   Node *phi_s = NULL;     // do not construct unless needed
 334   Node *phi_f = NULL;     // do not construct unless needed
 335   for (DUIterator_Last i2min, i2 = phi-&gt;last_outs(i2min); i2 &gt;= i2min; --i2) {
 336     Node* v = phi-&gt;last_out(i2);// User of the phi
 337     igvn-&gt;rehash_node_delayed(v); // Have to fixup other Phi users
 338     uint vop = v-&gt;Opcode();
 339     Node *proj = NULL;
 340     if( vop == Op_Phi ) {       // Remote merge point
 341       Node *r = v-&gt;in(0);
 342       for (uint i3 = 1; i3 &lt; r-&gt;req(); i3++)
 343         if (r-&gt;in(i3) &amp;&amp; r-&gt;in(i3)-&gt;in(0) == iff) {
 344           proj = r-&gt;in(i3);
 345           break;
 346         }
 347     } else if( v-&gt;is_ConstraintCast() ) {
 348       proj = v-&gt;in(0);          // Controlling projection
 349     } else {
 350       assert( 0, &quot;do not know how to handle this guy&quot; );
 351     }
 352     guarantee(proj != NULL, &quot;sanity&quot;);
 353 
 354     Node *proj_path_data, *proj_path_ctrl;
 355     if( proj-&gt;Opcode() == Op_IfTrue ) {
 356       if( phi_s == NULL ) {
 357         // Only construct phi_s if needed, otherwise provides
 358         // interfering use.
 359         phi_s = PhiNode::make_blank(region_s,phi);
 360         phi_s-&gt;init_req( 1, phi_c );
 361         phi_s-&gt;init_req( 2, phi_x );
 362         hook-&gt;add_req(phi_s);
 363         phi_s = phase-&gt;transform(phi_s);
 364       }
 365       proj_path_data = phi_s;
 366       proj_path_ctrl = region_s;
 367     } else {
 368       if( phi_f == NULL ) {
 369         // Only construct phi_f if needed, otherwise provides
 370         // interfering use.
 371         phi_f = PhiNode::make_blank(region_f,phi);
 372         phi_f-&gt;init_req( 1, phi_c );
 373         phi_f-&gt;init_req( 2, phi_x );
 374         hook-&gt;add_req(phi_f);
 375         phi_f = phase-&gt;transform(phi_f);
 376       }
 377       proj_path_data = phi_f;
 378       proj_path_ctrl = region_f;
 379     }
 380 
 381     // Fixup &#39;v&#39; for for the split
 382     if( vop == Op_Phi ) {       // Remote merge point
 383       uint i;
 384       for( i = 1; i &lt; v-&gt;req(); i++ )
 385         if( v-&gt;in(i) == phi )
 386           break;
 387       v-&gt;set_req(i, proj_path_data );
 388     } else if( v-&gt;is_ConstraintCast() ) {
 389       v-&gt;set_req(0, proj_path_ctrl );
 390       v-&gt;set_req(1, proj_path_data );
 391     } else
 392       ShouldNotReachHere();
 393   }
 394 
 395   // Now replace the original iff&#39;s True/False with region_s/region_t.
 396   // This makes the original iff go dead.
 397   for (DUIterator_Last i3min, i3 = iff-&gt;last_outs(i3min); i3 &gt;= i3min; --i3) {
 398     Node* p = iff-&gt;last_out(i3);
 399     assert( p-&gt;Opcode() == Op_IfTrue || p-&gt;Opcode() == Op_IfFalse, &quot;&quot; );
 400     Node *u = (p-&gt;Opcode() == Op_IfTrue) ? region_s : region_f;
 401     // Replace p with u
 402     igvn-&gt;add_users_to_worklist(p);
 403     for (DUIterator_Last lmin, l = p-&gt;last_outs(lmin); l &gt;= lmin;) {
 404       Node* x = p-&gt;last_out(l);
 405       igvn-&gt;hash_delete(x);
 406       uint uses_found = 0;
 407       for( uint j = 0; j &lt; x-&gt;req(); j++ ) {
 408         if( x-&gt;in(j) == p ) {
 409           x-&gt;set_req(j, u);
 410           uses_found++;
 411         }
 412       }
 413       l -= uses_found;    // we deleted 1 or more copies of this edge
 414     }
 415     igvn-&gt;remove_dead_node(p);
 416   }
 417 
 418   // Force the original merge dead
 419   igvn-&gt;hash_delete(r);
 420   // First, remove region&#39;s dead users.
 421   for (DUIterator_Last lmin, l = r-&gt;last_outs(lmin); l &gt;= lmin;) {
 422     Node* u = r-&gt;last_out(l);
 423     if( u == r ) {
 424       r-&gt;set_req(0, NULL);
 425     } else {
 426       assert(u-&gt;outcnt() == 0, &quot;only dead users&quot;);
 427       igvn-&gt;remove_dead_node(u);
 428     }
 429     l -= 1;
 430   }
 431   igvn-&gt;remove_dead_node(r);
 432 
 433   // Now remove the bogus extra edges used to keep things alive
 434   igvn-&gt;remove_dead_node( hook );
 435 
 436   // Must return either the original node (now dead) or a new node
 437   // (Do not return a top here, since that would break the uniqueness of top.)
 438   return new ConINode(TypeInt::ZERO);
 439 }
 440 
 441 // if this IfNode follows a range check pattern return the projection
 442 // for the failed path
 443 ProjNode* IfNode::range_check_trap_proj(int&amp; flip_test, Node*&amp; l, Node*&amp; r) {
 444   if (outcnt() != 2) {
 445     return NULL;
 446   }
 447   Node* b = in(1);
 448   if (b == NULL || !b-&gt;is_Bool())  return NULL;
 449   BoolNode* bn = b-&gt;as_Bool();
 450   Node* cmp = bn-&gt;in(1);
 451   if (cmp == NULL)  return NULL;
 452   if (cmp-&gt;Opcode() != Op_CmpU)  return NULL;
 453 
 454   l = cmp-&gt;in(1);
 455   r = cmp-&gt;in(2);
 456   flip_test = 1;
 457   if (bn-&gt;_test._test == BoolTest::le) {
 458     l = cmp-&gt;in(2);
 459     r = cmp-&gt;in(1);
 460     flip_test = 2;
 461   } else if (bn-&gt;_test._test != BoolTest::lt) {
 462     return NULL;
 463   }
 464   if (l-&gt;is_top())  return NULL;   // Top input means dead test
 465   if (r-&gt;Opcode() != Op_LoadRange &amp;&amp; !is_RangeCheck())  return NULL;
 466 
 467   // We have recognized one of these forms:
 468   //  Flip 1:  If (Bool[&lt;] CmpU(l, LoadRange)) ...
 469   //  Flip 2:  If (Bool[&lt;=] CmpU(LoadRange, l)) ...
 470 
 471   ProjNode* iftrap = proj_out_or_null(flip_test == 2 ? true : false);
 472   return iftrap;
 473 }
 474 
 475 
 476 //------------------------------is_range_check---------------------------------
 477 // Return 0 if not a range check.  Return 1 if a range check and set index and
 478 // offset.  Return 2 if we had to negate the test.  Index is NULL if the check
 479 // is versus a constant.
 480 int RangeCheckNode::is_range_check(Node* &amp;range, Node* &amp;index, jint &amp;offset) {
 481   int flip_test = 0;
 482   Node* l = NULL;
 483   Node* r = NULL;
 484   ProjNode* iftrap = range_check_trap_proj(flip_test, l, r);
 485 
 486   if (iftrap == NULL) {
 487     return 0;
 488   }
 489 
 490   // Make sure it&#39;s a real range check by requiring an uncommon trap
 491   // along the OOB path.  Otherwise, it&#39;s possible that the user wrote
 492   // something which optimized to look like a range check but behaves
 493   // in some other way.
 494   if (iftrap-&gt;is_uncommon_trap_proj(Deoptimization::Reason_range_check) == NULL) {
 495     return 0;
 496   }
 497 
 498   // Look for index+offset form
 499   Node* ind = l;
 500   jint  off = 0;
 501   if (l-&gt;is_top()) {
 502     return 0;
 503   } else if (l-&gt;Opcode() == Op_AddI) {
 504     if ((off = l-&gt;in(1)-&gt;find_int_con(0)) != 0) {
 505       ind = l-&gt;in(2)-&gt;uncast();
 506     } else if ((off = l-&gt;in(2)-&gt;find_int_con(0)) != 0) {
 507       ind = l-&gt;in(1)-&gt;uncast();
 508     }
 509   } else if ((off = l-&gt;find_int_con(-1)) &gt;= 0) {
 510     // constant offset with no variable index
 511     ind = NULL;
 512   } else {
 513     // variable index with no constant offset (or dead negative index)
 514     off = 0;
 515   }
 516 
 517   // Return all the values:
 518   index  = ind;
 519   offset = off;
 520   range  = r;
 521   return flip_test;
 522 }
 523 
 524 //------------------------------adjust_check-----------------------------------
 525 // Adjust (widen) a prior range check
 526 static void adjust_check(Node* proj, Node* range, Node* index,
 527                          int flip, jint off_lo, PhaseIterGVN* igvn) {
 528   PhaseGVN *gvn = igvn;
 529   // Break apart the old check
 530   Node *iff = proj-&gt;in(0);
 531   Node *bol = iff-&gt;in(1);
 532   if( bol-&gt;is_top() ) return;   // In case a partially dead range check appears
 533   // bail (or bomb[ASSERT/DEBUG]) if NOT projection--&gt;IfNode--&gt;BoolNode
 534   DEBUG_ONLY( if( !bol-&gt;is_Bool() ) { proj-&gt;dump(3); fatal(&quot;Expect projection--&gt;IfNode--&gt;BoolNode&quot;); } )
 535   if( !bol-&gt;is_Bool() ) return;
 536 
 537   Node *cmp = bol-&gt;in(1);
 538   // Compute a new check
 539   Node *new_add = gvn-&gt;intcon(off_lo);
 540   if( index ) {
 541     new_add = off_lo ? gvn-&gt;transform(new AddINode( index, new_add )) : index;
 542   }
 543   Node *new_cmp = (flip == 1)
 544     ? new CmpUNode( new_add, range )
 545     : new CmpUNode( range, new_add );
 546   new_cmp = gvn-&gt;transform(new_cmp);
 547   // See if no need to adjust the existing check
 548   if( new_cmp == cmp ) return;
 549   // Else, adjust existing check
 550   Node *new_bol = gvn-&gt;transform( new BoolNode( new_cmp, bol-&gt;as_Bool()-&gt;_test._test ) );
 551   igvn-&gt;rehash_node_delayed( iff );
 552   iff-&gt;set_req_X( 1, new_bol, igvn );
 553 }
 554 
 555 //------------------------------up_one_dom-------------------------------------
 556 // Walk up the dominator tree one step.  Return NULL at root or true
 557 // complex merges.  Skips through small diamonds.
 558 Node* IfNode::up_one_dom(Node *curr, bool linear_only) {
 559   Node *dom = curr-&gt;in(0);
 560   if( !dom )                    // Found a Region degraded to a copy?
 561     return curr-&gt;nonnull_req(); // Skip thru it
 562 
 563   if( curr != dom )             // Normal walk up one step?
 564     return dom;
 565 
 566   // Use linear_only if we are still parsing, since we cannot
 567   // trust the regions to be fully filled in.
 568   if (linear_only)
 569     return NULL;
 570 
 571   if( dom-&gt;is_Root() )
 572     return NULL;
 573 
 574   // Else hit a Region.  Check for a loop header
 575   if( dom-&gt;is_Loop() )
 576     return dom-&gt;in(1);          // Skip up thru loops
 577 
 578   // Check for small diamonds
 579   Node *din1, *din2, *din3, *din4;
 580   if( dom-&gt;req() == 3 &amp;&amp;        // 2-path merge point
 581       (din1 = dom -&gt;in(1)) &amp;&amp;   // Left  path exists
 582       (din2 = dom -&gt;in(2)) &amp;&amp;   // Right path exists
 583       (din3 = din1-&gt;in(0)) &amp;&amp;   // Left  path up one
 584       (din4 = din2-&gt;in(0)) ) {  // Right path up one
 585     if( din3-&gt;is_Call() &amp;&amp;      // Handle a slow-path call on either arm
 586         (din3 = din3-&gt;in(0)) )
 587       din3 = din3-&gt;in(0);
 588     if( din4-&gt;is_Call() &amp;&amp;      // Handle a slow-path call on either arm
 589         (din4 = din4-&gt;in(0)) )
 590       din4 = din4-&gt;in(0);
 591     if (din3 != NULL &amp;&amp; din3 == din4 &amp;&amp; din3-&gt;is_If()) // Regions not degraded to a copy
 592       return din3;              // Skip around diamonds
 593   }
 594 
 595   // Give up the search at true merges
 596   return NULL;                  // Dead loop?  Or hit root?
 597 }
 598 
 599 
 600 //------------------------------filtered_int_type--------------------------------
 601 // Return a possibly more restrictive type for val based on condition control flow for an if
 602 const TypeInt* IfNode::filtered_int_type(PhaseGVN* gvn, Node* val, Node* if_proj) {
 603   assert(if_proj &amp;&amp;
 604          (if_proj-&gt;Opcode() == Op_IfTrue || if_proj-&gt;Opcode() == Op_IfFalse), &quot;expecting an if projection&quot;);
 605   if (if_proj-&gt;in(0) &amp;&amp; if_proj-&gt;in(0)-&gt;is_If()) {
 606     IfNode* iff = if_proj-&gt;in(0)-&gt;as_If();
 607     if (iff-&gt;in(1) &amp;&amp; iff-&gt;in(1)-&gt;is_Bool()) {
 608       BoolNode* bol = iff-&gt;in(1)-&gt;as_Bool();
 609       if (bol-&gt;in(1) &amp;&amp; bol-&gt;in(1)-&gt;is_Cmp()) {
 610         const CmpNode* cmp  = bol-&gt;in(1)-&gt;as_Cmp();
 611         if (cmp-&gt;in(1) == val) {
 612           const TypeInt* cmp2_t = gvn-&gt;type(cmp-&gt;in(2))-&gt;isa_int();
 613           if (cmp2_t != NULL) {
 614             jint lo = cmp2_t-&gt;_lo;
 615             jint hi = cmp2_t-&gt;_hi;
 616             BoolTest::mask msk = if_proj-&gt;Opcode() == Op_IfTrue ? bol-&gt;_test._test : bol-&gt;_test.negate();
 617             switch (msk) {
 618             case BoolTest::ne: {
 619               // If val is compared to its lower or upper bound, we can narrow the type
 620               const TypeInt* val_t = gvn-&gt;type(val)-&gt;isa_int();
 621               if (val_t != NULL &amp;&amp; !val_t-&gt;singleton() &amp;&amp; cmp2_t-&gt;is_con()) {
 622                 if (val_t-&gt;_lo == lo) {
 623                   return TypeInt::make(val_t-&gt;_lo + 1, val_t-&gt;_hi, val_t-&gt;_widen);
 624                 } else if (val_t-&gt;_hi == hi) {
 625                   return TypeInt::make(val_t-&gt;_lo, val_t-&gt;_hi - 1, val_t-&gt;_widen);
 626                 }
 627               }
 628               // Can&#39;t refine type
 629               return NULL;
 630             }
 631             case BoolTest::eq:
 632               return cmp2_t;
 633             case BoolTest::lt:
 634               lo = TypeInt::INT-&gt;_lo;
 635               if (hi - 1 &lt; hi) {
 636                 hi = hi - 1;
 637               }
 638               break;
 639             case BoolTest::le:
 640               lo = TypeInt::INT-&gt;_lo;
 641               break;
 642             case BoolTest::gt:
 643               if (lo + 1 &gt; lo) {
 644                 lo = lo + 1;
 645               }
 646               hi = TypeInt::INT-&gt;_hi;
 647               break;
 648             case BoolTest::ge:
 649               // lo unchanged
 650               hi = TypeInt::INT-&gt;_hi;
 651               break;
 652             default:
 653               break;
 654             }
 655             const TypeInt* rtn_t = TypeInt::make(lo, hi, cmp2_t-&gt;_widen);
 656             return rtn_t;
 657           }
 658         }
 659       }
 660     }
 661   }
 662   return NULL;
 663 }
 664 
 665 //------------------------------fold_compares----------------------------
 666 // See if a pair of CmpIs can be converted into a CmpU.  In some cases
 667 // the direction of this if is determined by the preceding if so it
 668 // can be eliminate entirely.
 669 //
 670 // Given an if testing (CmpI n v) check for an immediately control
 671 // dependent if that is testing (CmpI n v2) and has one projection
 672 // leading to this if and the other projection leading to a region
 673 // that merges one of this ifs control projections.
 674 //
 675 //                   If
 676 //                  / |
 677 //                 /  |
 678 //                /   |
 679 //              If    |
 680 //              /\    |
 681 //             /  \   |
 682 //            /    \  |
 683 //           /    Region
 684 //
 685 // Or given an if testing (CmpI n v) check for a dominating if that is
 686 // testing (CmpI n v2), both having one projection leading to an
 687 // uncommon trap. Allow Another independent guard in between to cover
 688 // an explicit range check:
 689 // if (index &lt; 0 || index &gt;= array.length) {
 690 // which may need a null check to guard the LoadRange
 691 //
 692 //                   If
 693 //                  / \
 694 //                 /   \
 695 //                /     \
 696 //              If      unc
 697 //              /\
 698 //             /  \
 699 //            /    \
 700 //           /      unc
 701 //
 702 
 703 // Is the comparison for this If suitable for folding?
 704 bool IfNode::cmpi_folds(PhaseIterGVN* igvn, bool fold_ne) {
 705   return in(1) != NULL &amp;&amp;
 706     in(1)-&gt;is_Bool() &amp;&amp;
 707     in(1)-&gt;in(1) != NULL &amp;&amp;
 708     in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpI &amp;&amp;
 709     in(1)-&gt;in(1)-&gt;in(2) != NULL &amp;&amp;
 710     in(1)-&gt;in(1)-&gt;in(2) != igvn-&gt;C-&gt;top() &amp;&amp;
 711     (in(1)-&gt;as_Bool()-&gt;_test.is_less() ||
 712      in(1)-&gt;as_Bool()-&gt;_test.is_greater() ||
 713      (fold_ne &amp;&amp; in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne));
 714 }
 715 
 716 // Is a dominating control suitable for folding with this if?
 717 bool IfNode::is_ctrl_folds(Node* ctrl, PhaseIterGVN* igvn) {
 718   return ctrl != NULL &amp;&amp;
 719     ctrl-&gt;is_Proj() &amp;&amp;
 720     ctrl-&gt;in(0) != NULL &amp;&amp;
 721     ctrl-&gt;in(0)-&gt;Opcode() == Op_If &amp;&amp;
 722     ctrl-&gt;in(0)-&gt;outcnt() == 2 &amp;&amp;
 723     ctrl-&gt;in(0)-&gt;as_If()-&gt;cmpi_folds(igvn, true) &amp;&amp;
 724     // Must compare same value
 725     ctrl-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) != NULL &amp;&amp;
 726     ctrl-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == in(1)-&gt;in(1)-&gt;in(1);
 727 }
 728 
 729 // Do this If and the dominating If share a region?
 730 bool IfNode::has_shared_region(ProjNode* proj, ProjNode*&amp; success, ProjNode*&amp; fail) {
 731   ProjNode* otherproj = proj-&gt;other_if_proj();
 732   Node* otherproj_ctrl_use = otherproj-&gt;unique_ctrl_out();
 733   RegionNode* region = (otherproj_ctrl_use != NULL &amp;&amp; otherproj_ctrl_use-&gt;is_Region()) ? otherproj_ctrl_use-&gt;as_Region() : NULL;
 734   success = NULL;
 735   fail = NULL;
 736 
 737   if (otherproj-&gt;outcnt() == 1 &amp;&amp; region != NULL &amp;&amp; !region-&gt;has_phi()) {
 738     for (int i = 0; i &lt; 2; i++) {
 739       ProjNode* proj = proj_out(i);
 740       if (success == NULL &amp;&amp; proj-&gt;outcnt() == 1 &amp;&amp; proj-&gt;unique_out() == region) {
 741         success = proj;
 742       } else if (fail == NULL) {
 743         fail = proj;
 744       } else {
 745         success = fail = NULL;
 746       }
 747     }
 748   }
 749   return success != NULL &amp;&amp; fail != NULL;
 750 }
 751 
 752 bool IfNode::is_dominator_unc(CallStaticJavaNode* dom_unc, CallStaticJavaNode* unc) {
 753   // Different methods and methods containing jsrs are not supported.
 754   ciMethod* method = unc-&gt;jvms()-&gt;method();
 755   ciMethod* dom_method = dom_unc-&gt;jvms()-&gt;method();
 756   if (method != dom_method || method-&gt;has_jsrs()) {
 757     return false;
 758   }
 759   // Check that both traps are in the same activation of the method (instead
 760   // of two activations being inlined through different call sites) by verifying
 761   // that the call stacks are equal for both JVMStates.
 762   JVMState* dom_caller = dom_unc-&gt;jvms()-&gt;caller();
 763   JVMState* caller = unc-&gt;jvms()-&gt;caller();
 764   if ((dom_caller == NULL) != (caller == NULL)) {
 765     // The current method must either be inlined into both dom_caller and
 766     // caller or must not be inlined at all (top method). Bail out otherwise.
 767     return false;
 768   } else if (dom_caller != NULL &amp;&amp; !dom_caller-&gt;same_calls_as(caller)) {
 769     return false;
 770   }
 771   // Check that the bci of the dominating uncommon trap dominates the bci
 772   // of the dominated uncommon trap. Otherwise we may not re-execute
 773   // the dominated check after deoptimization from the merged uncommon trap.
 774   ciTypeFlow* flow = dom_method-&gt;get_flow_analysis();
 775   int bci = unc-&gt;jvms()-&gt;bci();
 776   int dom_bci = dom_unc-&gt;jvms()-&gt;bci();
 777   if (!flow-&gt;is_dominated_by(bci, dom_bci)) {
 778     return false;
 779   }
 780 
 781   return true;
 782 }
 783 
 784 // Return projection that leads to an uncommon trap if any
 785 ProjNode* IfNode::uncommon_trap_proj(CallStaticJavaNode*&amp; call) const {
 786   for (int i = 0; i &lt; 2; i++) {
 787     call = proj_out(i)-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none);
 788     if (call != NULL) {
 789       return proj_out(i);
 790     }
 791   }
 792   return NULL;
 793 }
 794 
 795 // Do this If and the dominating If both branch out to an uncommon trap
 796 bool IfNode::has_only_uncommon_traps(ProjNode* proj, ProjNode*&amp; success, ProjNode*&amp; fail, PhaseIterGVN* igvn) {
 797   ProjNode* otherproj = proj-&gt;other_if_proj();
 798   CallStaticJavaNode* dom_unc = otherproj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none);
 799 
 800   if (otherproj-&gt;outcnt() == 1 &amp;&amp; dom_unc != NULL) {
 801     // We need to re-execute the folded Ifs after deoptimization from the merged traps
 802     if (!dom_unc-&gt;jvms()-&gt;should_reexecute()) {
 803       return false;
 804     }
 805 
 806     CallStaticJavaNode* unc = NULL;
 807     ProjNode* unc_proj = uncommon_trap_proj(unc);
 808     if (unc_proj != NULL &amp;&amp; unc_proj-&gt;outcnt() == 1) {
 809       if (dom_unc == unc) {
 810         // Allow the uncommon trap to be shared through a region
 811         RegionNode* r = unc-&gt;in(0)-&gt;as_Region();
 812         if (r-&gt;outcnt() != 2 || r-&gt;req() != 3 || r-&gt;find_edge(otherproj) == -1 || r-&gt;find_edge(unc_proj) == -1) {
 813           return false;
 814         }
 815         assert(r-&gt;has_phi() == NULL, &quot;simple region shouldn&#39;t have a phi&quot;);
 816       } else if (dom_unc-&gt;in(0) != otherproj || unc-&gt;in(0) != unc_proj) {
 817         return false;
 818       }
 819 
 820       if (!is_dominator_unc(dom_unc, unc)) {
 821         return false;
 822       }
 823 
 824       // See merge_uncommon_traps: the reason of the uncommon trap
 825       // will be changed and the state of the dominating If will be
 826       // used. Checked that we didn&#39;t apply this transformation in a
 827       // previous compilation and it didn&#39;t cause too many traps
 828       ciMethod* dom_method = dom_unc-&gt;jvms()-&gt;method();
 829       int dom_bci = dom_unc-&gt;jvms()-&gt;bci();
 830       if (!igvn-&gt;C-&gt;too_many_traps(dom_method, dom_bci, Deoptimization::Reason_unstable_fused_if) &amp;&amp;
 831           !igvn-&gt;C-&gt;too_many_traps(dom_method, dom_bci, Deoptimization::Reason_range_check)) {
 832         success = unc_proj;
 833         fail = unc_proj-&gt;other_if_proj();
 834         return true;
 835       }
 836     }
 837   }
 838   return false;
 839 }
 840 
 841 // Check that the 2 CmpI can be folded into as single CmpU and proceed with the folding
 842 bool IfNode::fold_compares_helper(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn) {
 843   Node* this_cmp = in(1)-&gt;in(1);
 844   BoolNode* this_bool = in(1)-&gt;as_Bool();
 845   IfNode* dom_iff = proj-&gt;in(0)-&gt;as_If();
 846   BoolNode* dom_bool = dom_iff-&gt;in(1)-&gt;as_Bool();
 847   Node* lo = dom_iff-&gt;in(1)-&gt;in(1)-&gt;in(2);
 848   Node* hi = this_cmp-&gt;in(2);
 849   Node* n = this_cmp-&gt;in(1);
 850   ProjNode* otherproj = proj-&gt;other_if_proj();
 851 
 852   const TypeInt* lo_type = IfNode::filtered_int_type(igvn, n, otherproj);
 853   const TypeInt* hi_type = IfNode::filtered_int_type(igvn, n, success);
 854 
 855   BoolTest::mask lo_test = dom_bool-&gt;_test._test;
 856   BoolTest::mask hi_test = this_bool-&gt;_test._test;
 857   BoolTest::mask cond = hi_test;
 858 
 859   // convert:
 860   //
 861   //          dom_bool = x {&lt;,&lt;=,&gt;,&gt;=} a
 862   //                           / \
 863   //     proj = {True,False}  /   \ otherproj = {False,True}
 864   //                         /
 865   //        this_bool = x {&lt;,&lt;=} b
 866   //                       / \
 867   //  fail = {True,False} /   \ success = {False,True}
 868   //                     /
 869   //
 870   // (Second test guaranteed canonicalized, first one may not have
 871   // been canonicalized yet)
 872   //
 873   // into:
 874   //
 875   // cond = (x - lo) {&lt;u,&lt;=u,&gt;u,&gt;=u} adjusted_lim
 876   //                       / \
 877   //                 fail /   \ success
 878   //                     /
 879   //
 880 
 881   // Figure out which of the two tests sets the upper bound and which
 882   // sets the lower bound if any.
 883   Node* adjusted_lim = NULL;
 884   if (lo_type != NULL &amp;&amp; hi_type != NULL &amp;&amp; hi_type-&gt;_lo &gt; lo_type-&gt;_hi &amp;&amp;
 885       hi_type-&gt;_hi == max_jint &amp;&amp; lo_type-&gt;_lo == min_jint &amp;&amp; lo_test != BoolTest::ne) {
 886     assert((dom_bool-&gt;_test.is_less() &amp;&amp; !proj-&gt;_con) ||
 887            (dom_bool-&gt;_test.is_greater() &amp;&amp; proj-&gt;_con), &quot;incorrect test&quot;);
 888     // this test was canonicalized
 889     assert(this_bool-&gt;_test.is_less() &amp;&amp; fail-&gt;_con, &quot;incorrect test&quot;);
 890 
 891     // this_bool = &lt;
 892     //   dom_bool = &gt;= (proj = True) or dom_bool = &lt; (proj = False)
 893     //     x in [a, b[ on the fail (= True) projection, b &gt; a-1 (because of hi_type-&gt;_lo &gt; lo_type-&gt;_hi test above):
 894     //     lo = a, hi = b, adjusted_lim = b-a, cond = &lt;u
 895     //   dom_bool = &gt; (proj = True) or dom_bool = &lt;= (proj = False)
 896     //     x in ]a, b[ on the fail (= True) projection, b &gt; a:
 897     //     lo = a+1, hi = b, adjusted_lim = b-a-1, cond = &lt;u
 898     // this_bool = &lt;=
 899     //   dom_bool = &gt;= (proj = True) or dom_bool = &lt; (proj = False)
 900     //     x in [a, b] on the fail (= True) projection, b+1 &gt; a-1:
 901     //     lo = a, hi = b, adjusted_lim = b-a+1, cond = &lt;u
 902     //     lo = a, hi = b, adjusted_lim = b-a, cond = &lt;=u doesn&#39;t work because b = a - 1 is possible, then b-a = -1
 903     //   dom_bool = &gt; (proj = True) or dom_bool = &lt;= (proj = False)
 904     //     x in ]a, b] on the fail (= True) projection b+1 &gt; a:
 905     //     lo = a+1, hi = b, adjusted_lim = b-a, cond = &lt;u
 906     //     lo = a+1, hi = b, adjusted_lim = b-a-1, cond = &lt;=u doesn&#39;t work because a = b is possible, then b-a-1 = -1
 907 
 908     if (hi_test == BoolTest::lt) {
 909       if (lo_test == BoolTest::gt || lo_test == BoolTest::le) {
 910         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
 911       }
 912     } else {
 913       assert(hi_test == BoolTest::le, &quot;bad test&quot;);
 914       if (lo_test == BoolTest::ge || lo_test == BoolTest::lt) {
 915         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 916         adjusted_lim = igvn-&gt;transform(new AddINode(adjusted_lim, igvn-&gt;intcon(1)));
 917         cond = BoolTest::lt;
 918       } else {
 919         assert(lo_test == BoolTest::gt || lo_test == BoolTest::le, &quot;bad test&quot;);
 920         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 921         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
 922         cond = BoolTest::lt;
 923       }
 924     }
 925   } else if (lo_type != NULL &amp;&amp; hi_type != NULL &amp;&amp; lo_type-&gt;_lo &gt; hi_type-&gt;_hi &amp;&amp;
 926              lo_type-&gt;_hi == max_jint &amp;&amp; hi_type-&gt;_lo == min_jint &amp;&amp; lo_test != BoolTest::ne) {
 927 
 928     // this_bool = &lt;
 929     //   dom_bool = &lt; (proj = True) or dom_bool = &gt;= (proj = False)
 930     //     x in [b, a[ on the fail (= False) projection, a &gt; b-1 (because of lo_type-&gt;_lo &gt; hi_type-&gt;_hi above):
 931     //     lo = b, hi = a, adjusted_lim = a-b, cond = &gt;=u
 932     //   dom_bool = &lt;= (proj = True) or dom_bool = &gt; (proj = False)
 933     //     x in [b, a] on the fail (= False) projection, a+1 &gt; b-1:
 934     //     lo = b, hi = a, adjusted_lim = a-b+1, cond = &gt;=u
 935     //     lo = b, hi = a, adjusted_lim = a-b, cond = &gt;u doesn&#39;t work because a = b - 1 is possible, then b-a = -1
 936     // this_bool = &lt;=
 937     //   dom_bool = &lt; (proj = True) or dom_bool = &gt;= (proj = False)
 938     //     x in ]b, a[ on the fail (= False) projection, a &gt; b:
 939     //     lo = b+1, hi = a, adjusted_lim = a-b-1, cond = &gt;=u
 940     //   dom_bool = &lt;= (proj = True) or dom_bool = &gt; (proj = False)
 941     //     x in ]b, a] on the fail (= False) projection, a+1 &gt; b:
 942     //     lo = b+1, hi = a, adjusted_lim = a-b, cond = &gt;=u
 943     //     lo = b+1, hi = a, adjusted_lim = a-b-1, cond = &gt;u doesn&#39;t work because a = b is possible, then b-a-1 = -1
 944 
 945     swap(lo, hi);
 946     swap(lo_type, hi_type);
 947     swap(lo_test, hi_test);
 948 
 949     assert((dom_bool-&gt;_test.is_less() &amp;&amp; proj-&gt;_con) ||
 950            (dom_bool-&gt;_test.is_greater() &amp;&amp; !proj-&gt;_con), &quot;incorrect test&quot;);
 951     // this test was canonicalized
 952     assert(this_bool-&gt;_test.is_less() &amp;&amp; !fail-&gt;_con, &quot;incorrect test&quot;);
 953 
 954     cond = (hi_test == BoolTest::le || hi_test == BoolTest::gt) ? BoolTest::gt : BoolTest::ge;
 955 
 956     if (lo_test == BoolTest::lt) {
 957       if (hi_test == BoolTest::lt || hi_test == BoolTest::ge) {
 958         cond = BoolTest::ge;
 959       } else {
 960         assert(hi_test == BoolTest::le || hi_test == BoolTest::gt, &quot;bad test&quot;);
 961         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 962         adjusted_lim = igvn-&gt;transform(new AddINode(adjusted_lim, igvn-&gt;intcon(1)));
 963         cond = BoolTest::ge;
 964       }
 965     } else if (lo_test == BoolTest::le) {
 966       if (hi_test == BoolTest::lt || hi_test == BoolTest::ge) {
 967         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
 968         cond = BoolTest::ge;
 969       } else {
 970         assert(hi_test == BoolTest::le || hi_test == BoolTest::gt, &quot;bad test&quot;);
 971         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 972         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
 973         cond = BoolTest::ge;
 974       }
 975     }
 976   } else {
 977     const TypeInt* failtype = filtered_int_type(igvn, n, proj);
 978     if (failtype != NULL) {
 979       const TypeInt* type2 = filtered_int_type(igvn, n, fail);
 980       if (type2 != NULL) {
 981         failtype = failtype-&gt;join(type2)-&gt;is_int();
 982         if (failtype-&gt;_lo &gt; failtype-&gt;_hi) {
 983           // previous if determines the result of this if so
 984           // replace Bool with constant
 985           igvn-&gt;_worklist.push(in(1));
 986           igvn-&gt;replace_input_of(this, 1, igvn-&gt;intcon(success-&gt;_con));
 987           return true;
 988         }
 989       }
 990     }
 991     lo = NULL;
 992     hi = NULL;
 993   }
 994 
 995   if (lo &amp;&amp; hi) {
<a name="1" id="anc1"></a><span class="line-added"> 996     Node* hook = new Node(1);</span>
<span class="line-added"> 997     hook-&gt;init_req(0, lo); // Add a use to lo to prevent him from dying</span>
 998     // Merge the two compares into a single unsigned compare by building (CmpU (n - lo) (hi - lo))
 999     Node* adjusted_val = igvn-&gt;transform(new SubINode(n,  lo));
1000     if (adjusted_lim == NULL) {
1001       adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
1002     }
<a name="2" id="anc2"></a><span class="line-added">1003     hook-&gt;del_req(0); // Just yank bogus edge</span>
<span class="line-added">1004     hook-&gt;destruct();</span>
1005     Node* newcmp = igvn-&gt;transform(new CmpUNode(adjusted_val, adjusted_lim));
1006     Node* newbool = igvn-&gt;transform(new BoolNode(newcmp, cond));
1007 
1008     igvn-&gt;replace_input_of(dom_iff, 1, igvn-&gt;intcon(proj-&gt;_con));
1009     igvn-&gt;_worklist.push(in(1));
1010     igvn-&gt;replace_input_of(this, 1, newbool);
1011 
1012     return true;
1013   }
1014   return false;
1015 }
1016 
1017 // Merge the branches that trap for this If and the dominating If into
1018 // a single region that branches to the uncommon trap for the
1019 // dominating If
1020 Node* IfNode::merge_uncommon_traps(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn) {
1021   Node* res = this;
1022   assert(success-&gt;in(0) == this, &quot;bad projection&quot;);
1023 
1024   ProjNode* otherproj = proj-&gt;other_if_proj();
1025 
1026   CallStaticJavaNode* unc = success-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none);
1027   CallStaticJavaNode* dom_unc = otherproj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none);
1028 
1029   if (unc != dom_unc) {
1030     Node* r = new RegionNode(3);
1031 
1032     r-&gt;set_req(1, otherproj);
1033     r-&gt;set_req(2, success);
1034     r = igvn-&gt;transform(r);
1035     assert(r-&gt;is_Region(), &quot;can&#39;t go away&quot;);
1036 
1037     // Make both If trap at the state of the first If: once the CmpI
1038     // nodes are merged, if we trap we don&#39;t know which of the CmpI
1039     // nodes would have caused the trap so we have to restart
1040     // execution at the first one
1041     igvn-&gt;replace_input_of(dom_unc, 0, r);
1042     igvn-&gt;replace_input_of(unc, 0, igvn-&gt;C-&gt;top());
1043   }
1044   int trap_request = dom_unc-&gt;uncommon_trap_request();
1045   Deoptimization::DeoptReason reason = Deoptimization::trap_request_reason(trap_request);
1046   Deoptimization::DeoptAction action = Deoptimization::trap_request_action(trap_request);
1047 
1048   int flip_test = 0;
1049   Node* l = NULL;
1050   Node* r = NULL;
1051 
1052   if (success-&gt;in(0)-&gt;as_If()-&gt;range_check_trap_proj(flip_test, l, r) != NULL) {
1053     // If this looks like a range check, change the trap to
1054     // Reason_range_check so the compiler recognizes it as a range
1055     // check and applies the corresponding optimizations
1056     trap_request = Deoptimization::make_trap_request(Deoptimization::Reason_range_check, action);
1057 
1058     improve_address_types(l, r, fail, igvn);
1059 
1060     res = igvn-&gt;transform(new RangeCheckNode(in(0), in(1), _prob, _fcnt));
1061   } else if (unc != dom_unc) {
1062     // If we trap we won&#39;t know what CmpI would have caused the trap
1063     // so use a special trap reason to mark this pair of CmpI nodes as
1064     // bad candidate for folding. On recompilation we won&#39;t fold them
1065     // and we may trap again but this time we&#39;ll know what branch
1066     // traps
1067     trap_request = Deoptimization::make_trap_request(Deoptimization::Reason_unstable_fused_if, action);
1068   }
1069   igvn-&gt;replace_input_of(dom_unc, TypeFunc::Parms, igvn-&gt;intcon(trap_request));
1070   return res;
1071 }
1072 
1073 // If we are turning 2 CmpI nodes into a CmpU that follows the pattern
1074 // of a rangecheck on index i, on 64 bit the compares may be followed
1075 // by memory accesses using i as index. In that case, the CmpU tells
1076 // us something about the values taken by i that can help the compiler
1077 // (see Compile::conv_I2X_index())
1078 void IfNode::improve_address_types(Node* l, Node* r, ProjNode* fail, PhaseIterGVN* igvn) {
1079 #ifdef _LP64
1080   ResourceMark rm;
1081   Node_Stack stack(2);
1082 
1083   assert(r-&gt;Opcode() == Op_LoadRange, &quot;unexpected range check&quot;);
1084   const TypeInt* array_size = igvn-&gt;type(r)-&gt;is_int();
1085 
1086   stack.push(l, 0);
1087 
1088   while(stack.size() &gt; 0) {
1089     Node* n = stack.node();
1090     uint start = stack.index();
1091 
1092     uint i = start;
1093     for (; i &lt; n-&gt;outcnt(); i++) {
1094       Node* use = n-&gt;raw_out(i);
1095       if (stack.size() == 1) {
1096         if (use-&gt;Opcode() == Op_ConvI2L) {
1097           const TypeLong* bounds = use-&gt;as_Type()-&gt;type()-&gt;is_long();
1098           if (bounds-&gt;_lo &lt;= array_size-&gt;_lo &amp;&amp; bounds-&gt;_hi &gt;= array_size-&gt;_hi &amp;&amp;
1099               (bounds-&gt;_lo != array_size-&gt;_lo || bounds-&gt;_hi != array_size-&gt;_hi)) {
1100             stack.set_index(i+1);
1101             stack.push(use, 0);
1102             break;
1103           }
1104         }
1105       } else if (use-&gt;is_Mem()) {
1106         Node* ctrl = use-&gt;in(0);
1107         for (int i = 0; i &lt; 10 &amp;&amp; ctrl != NULL &amp;&amp; ctrl != fail; i++) {
1108           ctrl = up_one_dom(ctrl);
1109         }
1110         if (ctrl == fail) {
1111           Node* init_n = stack.node_at(1);
1112           assert(init_n-&gt;Opcode() == Op_ConvI2L, &quot;unexpected first node&quot;);
1113           // Create a new narrow ConvI2L node that is dependent on the range check
1114           Node* new_n = igvn-&gt;C-&gt;conv_I2X_index(igvn, l, array_size, fail);
1115 
1116           // The type of the ConvI2L may be widen and so the new
1117           // ConvI2L may not be better than an existing ConvI2L
1118           if (new_n != init_n) {
1119             for (uint j = 2; j &lt; stack.size(); j++) {
1120               Node* n = stack.node_at(j);
1121               Node* clone = n-&gt;clone();
1122               int rep = clone-&gt;replace_edge(init_n, new_n);
1123               assert(rep &gt; 0, &quot;can&#39;t find expected node?&quot;);
1124               clone = igvn-&gt;transform(clone);
1125               init_n = n;
1126               new_n = clone;
1127             }
1128             igvn-&gt;hash_delete(use);
1129             int rep = use-&gt;replace_edge(init_n, new_n);
1130             assert(rep &gt; 0, &quot;can&#39;t find expected node?&quot;);
1131             igvn-&gt;transform(use);
1132             if (init_n-&gt;outcnt() == 0) {
1133               igvn-&gt;_worklist.push(init_n);
1134             }
1135           }
1136         }
1137       } else if (use-&gt;in(0) == NULL &amp;&amp; (igvn-&gt;type(use)-&gt;isa_long() ||
1138                                         igvn-&gt;type(use)-&gt;isa_ptr())) {
1139         stack.set_index(i+1);
1140         stack.push(use, 0);
1141         break;
1142       }
1143     }
1144     if (i == n-&gt;outcnt()) {
1145       stack.pop();
1146     }
1147   }
1148 #endif
1149 }
1150 
1151 bool IfNode::is_cmp_with_loadrange(ProjNode* proj) {
1152   if (in(1) != NULL &amp;&amp;
1153       in(1)-&gt;in(1) != NULL &amp;&amp;
1154       in(1)-&gt;in(1)-&gt;in(2) != NULL) {
1155     Node* other = in(1)-&gt;in(1)-&gt;in(2);
1156     if (other-&gt;Opcode() == Op_LoadRange &amp;&amp;
1157         ((other-&gt;in(0) != NULL &amp;&amp; other-&gt;in(0) == proj) ||
1158          (other-&gt;in(0) == NULL &amp;&amp;
1159           other-&gt;in(2) != NULL &amp;&amp;
1160           other-&gt;in(2)-&gt;is_AddP() &amp;&amp;
1161           other-&gt;in(2)-&gt;in(1) != NULL &amp;&amp;
1162           other-&gt;in(2)-&gt;in(1)-&gt;Opcode() == Op_CastPP &amp;&amp;
1163           other-&gt;in(2)-&gt;in(1)-&gt;in(0) == proj))) {
1164       return true;
1165     }
1166   }
1167   return false;
1168 }
1169 
1170 bool IfNode::is_null_check(ProjNode* proj, PhaseIterGVN* igvn) {
1171   Node* other = in(1)-&gt;in(1)-&gt;in(2);
1172   if (other-&gt;in(MemNode::Address) != NULL &amp;&amp;
1173       proj-&gt;in(0)-&gt;in(1) != NULL &amp;&amp;
1174       proj-&gt;in(0)-&gt;in(1)-&gt;is_Bool() &amp;&amp;
1175       proj-&gt;in(0)-&gt;in(1)-&gt;in(1) != NULL &amp;&amp;
1176       proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;
1177       proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2) != NULL &amp;&amp;
1178       proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == other-&gt;in(MemNode::Address)-&gt;in(AddPNode::Address)-&gt;uncast() &amp;&amp;
1179       igvn-&gt;type(proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)) == TypePtr::NULL_PTR) {
1180     return true;
1181   }
1182   return false;
1183 }
1184 
1185 // Check that the If that is in between the 2 integer comparisons has
1186 // no side effect
1187 bool IfNode::is_side_effect_free_test(ProjNode* proj, PhaseIterGVN* igvn) {
1188   if (proj == NULL) {
1189     return false;
1190   }
1191   CallStaticJavaNode* unc = proj-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1192   if (unc != NULL &amp;&amp; proj-&gt;outcnt() &lt;= 2) {
1193     if (proj-&gt;outcnt() == 1 ||
1194         // Allow simple null check from LoadRange
1195         (is_cmp_with_loadrange(proj) &amp;&amp; is_null_check(proj, igvn))) {
1196       CallStaticJavaNode* unc = proj-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1197       CallStaticJavaNode* dom_unc = proj-&gt;in(0)-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1198       assert(dom_unc != NULL, &quot;is_uncommon_trap_if_pattern returned NULL&quot;);
1199 
1200       // reroute_side_effect_free_unc changes the state of this
1201       // uncommon trap to restart execution at the previous
1202       // CmpI. Check that this change in a previous compilation didn&#39;t
1203       // cause too many traps.
1204       int trap_request = unc-&gt;uncommon_trap_request();
1205       Deoptimization::DeoptReason reason = Deoptimization::trap_request_reason(trap_request);
1206 
1207       if (igvn-&gt;C-&gt;too_many_traps(dom_unc-&gt;jvms()-&gt;method(), dom_unc-&gt;jvms()-&gt;bci(), reason)) {
1208         return false;
1209       }
1210 
1211       if (!is_dominator_unc(dom_unc, unc)) {
1212         return false;
1213       }
1214 
1215       return true;
1216     }
1217   }
1218   return false;
1219 }
1220 
1221 // Make the If between the 2 integer comparisons trap at the state of
1222 // the first If: the last CmpI is the one replaced by a CmpU and the
1223 // first CmpI is eliminated, so the test between the 2 CmpI nodes
1224 // won&#39;t be guarded by the first CmpI anymore. It can trap in cases
1225 // where the first CmpI would have prevented it from executing: on a
1226 // trap, we need to restart execution at the state of the first CmpI
1227 void IfNode::reroute_side_effect_free_unc(ProjNode* proj, ProjNode* dom_proj, PhaseIterGVN* igvn) {
1228   CallStaticJavaNode* dom_unc = dom_proj-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1229   ProjNode* otherproj = proj-&gt;other_if_proj();
1230   CallStaticJavaNode* unc = proj-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1231   Node* call_proj = dom_unc-&gt;unique_ctrl_out();
1232   Node* halt = call_proj-&gt;unique_ctrl_out();
1233 
1234   Node* new_unc = dom_unc-&gt;clone();
1235   call_proj = call_proj-&gt;clone();
1236   halt = halt-&gt;clone();
1237   Node* c = otherproj-&gt;clone();
1238 
1239   c = igvn-&gt;transform(c);
1240   new_unc-&gt;set_req(TypeFunc::Parms, unc-&gt;in(TypeFunc::Parms));
1241   new_unc-&gt;set_req(0, c);
1242   new_unc = igvn-&gt;transform(new_unc);
1243   call_proj-&gt;set_req(0, new_unc);
1244   call_proj = igvn-&gt;transform(call_proj);
1245   halt-&gt;set_req(0, call_proj);
1246   halt = igvn-&gt;transform(halt);
1247 
1248   igvn-&gt;replace_node(otherproj, igvn-&gt;C-&gt;top());
1249   igvn-&gt;C-&gt;root()-&gt;add_req(halt);
1250 }
1251 
1252 Node* IfNode::fold_compares(PhaseIterGVN* igvn) {
1253   if (Opcode() != Op_If) return NULL;
1254 
1255   if (cmpi_folds(igvn)) {
1256     Node* ctrl = in(0);
1257     if (is_ctrl_folds(ctrl, igvn) &amp;&amp; ctrl-&gt;outcnt() == 1) {
1258       // A integer comparison immediately dominated by another integer
1259       // comparison
1260       ProjNode* success = NULL;
1261       ProjNode* fail = NULL;
1262       ProjNode* dom_cmp = ctrl-&gt;as_Proj();
1263       if (has_shared_region(dom_cmp, success, fail) &amp;&amp;
1264           // Next call modifies graph so must be last
1265           fold_compares_helper(dom_cmp, success, fail, igvn)) {
1266         return this;
1267       }
1268       if (has_only_uncommon_traps(dom_cmp, success, fail, igvn) &amp;&amp;
1269           // Next call modifies graph so must be last
1270           fold_compares_helper(dom_cmp, success, fail, igvn)) {
1271         return merge_uncommon_traps(dom_cmp, success, fail, igvn);
1272       }
1273       return NULL;
1274     } else if (ctrl-&gt;in(0) != NULL &amp;&amp;
1275                ctrl-&gt;in(0)-&gt;in(0) != NULL) {
1276       ProjNode* success = NULL;
1277       ProjNode* fail = NULL;
1278       Node* dom = ctrl-&gt;in(0)-&gt;in(0);
1279       ProjNode* dom_cmp = dom-&gt;isa_Proj();
1280       ProjNode* other_cmp = ctrl-&gt;isa_Proj();
1281 
1282       // Check if it&#39;s an integer comparison dominated by another
1283       // integer comparison with another test in between
1284       if (is_ctrl_folds(dom, igvn) &amp;&amp;
1285           has_only_uncommon_traps(dom_cmp, success, fail, igvn) &amp;&amp;
1286           is_side_effect_free_test(other_cmp, igvn) &amp;&amp;
1287           // Next call modifies graph so must be last
1288           fold_compares_helper(dom_cmp, success, fail, igvn)) {
1289         reroute_side_effect_free_unc(other_cmp, dom_cmp, igvn);
1290         return merge_uncommon_traps(dom_cmp, success, fail, igvn);
1291       }
1292     }
1293   }
1294   return NULL;
1295 }
1296 
1297 //------------------------------remove_useless_bool----------------------------
1298 // Check for people making a useless boolean: things like
1299 // if( (x &lt; y ? true : false) ) { ... }
1300 // Replace with if( x &lt; y ) { ... }
1301 static Node *remove_useless_bool(IfNode *iff, PhaseGVN *phase) {
1302   Node *i1 = iff-&gt;in(1);
1303   if( !i1-&gt;is_Bool() ) return NULL;
1304   BoolNode *bol = i1-&gt;as_Bool();
1305 
1306   Node *cmp = bol-&gt;in(1);
1307   if( cmp-&gt;Opcode() != Op_CmpI ) return NULL;
1308 
1309   // Must be comparing against a bool
1310   const Type *cmp2_t = phase-&gt;type( cmp-&gt;in(2) );
1311   if( cmp2_t != TypeInt::ZERO &amp;&amp;
1312       cmp2_t != TypeInt::ONE )
1313     return NULL;
1314 
1315   // Find a prior merge point merging the boolean
1316   i1 = cmp-&gt;in(1);
1317   if( !i1-&gt;is_Phi() ) return NULL;
1318   PhiNode *phi = i1-&gt;as_Phi();
1319   if( phase-&gt;type( phi ) != TypeInt::BOOL )
1320     return NULL;
1321 
1322   // Check for diamond pattern
1323   int true_path = phi-&gt;is_diamond_phi();
1324   if( true_path == 0 ) return NULL;
1325 
1326   // Make sure that iff and the control of the phi are different. This
1327   // should really only happen for dead control flow since it requires
1328   // an illegal cycle.
1329   if (phi-&gt;in(0)-&gt;in(1)-&gt;in(0) == iff) return NULL;
1330 
1331   // phi-&gt;region-&gt;if_proj-&gt;ifnode-&gt;bool-&gt;cmp
1332   BoolNode *bol2 = phi-&gt;in(0)-&gt;in(1)-&gt;in(0)-&gt;in(1)-&gt;as_Bool();
1333 
1334   // Now get the &#39;sense&#39; of the test correct so we can plug in
1335   // either iff2-&gt;in(1) or its complement.
1336   int flip = 0;
1337   if( bol-&gt;_test._test == BoolTest::ne ) flip = 1-flip;
1338   else if( bol-&gt;_test._test != BoolTest::eq ) return NULL;
1339   if( cmp2_t == TypeInt::ZERO ) flip = 1-flip;
1340 
1341   const Type *phi1_t = phase-&gt;type( phi-&gt;in(1) );
1342   const Type *phi2_t = phase-&gt;type( phi-&gt;in(2) );
1343   // Check for Phi(0,1) and flip
1344   if( phi1_t == TypeInt::ZERO ) {
1345     if( phi2_t != TypeInt::ONE ) return NULL;
1346     flip = 1-flip;
1347   } else {
1348     // Check for Phi(1,0)
1349     if( phi1_t != TypeInt::ONE  ) return NULL;
1350     if( phi2_t != TypeInt::ZERO ) return NULL;
1351   }
1352   if( true_path == 2 ) {
1353     flip = 1-flip;
1354   }
1355 
1356   Node* new_bol = (flip ? phase-&gt;transform( bol2-&gt;negate(phase) ) : bol2);
1357   assert(new_bol != iff-&gt;in(1), &quot;must make progress&quot;);
1358   iff-&gt;set_req(1, new_bol);
1359   // Intervening diamond probably goes dead
1360   phase-&gt;C-&gt;set_major_progress();
1361   return iff;
1362 }
1363 
1364 static IfNode* idealize_test(PhaseGVN* phase, IfNode* iff);
1365 
1366 struct RangeCheck {
1367   Node* ctl;
1368   jint off;
1369 };
1370 
1371 Node* IfNode::Ideal_common(PhaseGVN *phase, bool can_reshape) {
1372   if (remove_dead_region(phase, can_reshape))  return this;
1373   // No Def-Use info?
1374   if (!can_reshape)  return NULL;
1375 
1376   // Don&#39;t bother trying to transform a dead if
1377   if (in(0)-&gt;is_top())  return NULL;
1378   // Don&#39;t bother trying to transform an if with a dead test
1379   if (in(1)-&gt;is_top())  return NULL;
1380   // Another variation of a dead test
1381   if (in(1)-&gt;is_Con())  return NULL;
1382   // Another variation of a dead if
1383   if (outcnt() &lt; 2)  return NULL;
1384 
1385   // Canonicalize the test.
1386   Node* idt_if = idealize_test(phase, this);
1387   if (idt_if != NULL)  return idt_if;
1388 
1389   // Try to split the IF
1390   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1391   Node *s = split_if(this, igvn);
1392   if (s != NULL)  return s;
1393 
1394   return NodeSentinel;
1395 }
1396 
1397 //------------------------------Ideal------------------------------------------
1398 // Return a node which is more &quot;ideal&quot; than the current node.  Strip out
1399 // control copies
1400 Node* IfNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1401   Node* res = Ideal_common(phase, can_reshape);
1402   if (res != NodeSentinel) {
1403     return res;
1404   }
1405 
1406   // Check for people making a useless boolean: things like
1407   // if( (x &lt; y ? true : false) ) { ... }
1408   // Replace with if( x &lt; y ) { ... }
1409   Node* bol2 = remove_useless_bool(this, phase);
1410   if (bol2) return bol2;
1411 
1412   if (in(0) == NULL) return NULL;     // Dead loop?
1413 
1414   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
1415   Node* result = fold_compares(igvn);
1416   if (result != NULL) {
1417     return result;
1418   }
1419 
1420   // Scan for an equivalent test
1421   int dist = 4;               // Cutoff limit for search
1422   if (is_If() &amp;&amp; in(1)-&gt;is_Bool()) {
1423     Node* cmp = in(1)-&gt;in(1);
1424     if (cmp-&gt;Opcode() == Op_CmpP &amp;&amp;
1425         cmp-&gt;in(2) != NULL &amp;&amp; // make sure cmp is not already dead
1426         cmp-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {
1427       dist = 64;              // Limit for null-pointer scans
1428     }
1429   }
1430 
1431   Node* prev_dom = search_identical(dist);
1432 
1433   if (prev_dom != NULL) {
1434     // Replace dominated IfNode
1435     return dominated_by(prev_dom, igvn);
1436   }
1437 
1438   return simple_subsuming(igvn);
1439 }
1440 
1441 //------------------------------dominated_by-----------------------------------
1442 Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN *igvn) {
1443 #ifndef PRODUCT
1444   if (TraceIterativeGVN) {
1445     tty-&gt;print(&quot;   Removing IfNode: &quot;); this-&gt;dump();
1446   }
1447 #endif
1448 
1449   igvn-&gt;hash_delete(this);      // Remove self to prevent spurious V-N
1450   Node *idom = in(0);
1451   // Need opcode to decide which way &#39;this&#39; test goes
1452   int prev_op = prev_dom-&gt;Opcode();
1453   Node *top = igvn-&gt;C-&gt;top(); // Shortcut to top
1454 
1455   // Loop predicates may have depending checks which should not
1456   // be skipped. For example, range check predicate has two checks
1457   // for lower and upper bounds.
1458   ProjNode* unc_proj = proj_out(1 - prev_dom-&gt;as_Proj()-&gt;_con)-&gt;as_Proj();
1459   if (unc_proj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_predicate) != NULL ||
1460       unc_proj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != NULL) {
1461     prev_dom = idom;
1462   }
1463 
1464   // Now walk the current IfNode&#39;s projections.
1465   // Loop ends when &#39;this&#39; has no more uses.
1466   for (DUIterator_Last imin, i = last_outs(imin); i &gt;= imin; --i) {
1467     Node *ifp = last_out(i);     // Get IfTrue/IfFalse
1468     igvn-&gt;add_users_to_worklist(ifp);
1469     // Check which projection it is and set target.
1470     // Data-target is either the dominating projection of the same type
1471     // or TOP if the dominating projection is of opposite type.
1472     // Data-target will be used as the new control edge for the non-CFG
1473     // nodes like Casts and Loads.
1474     Node *data_target = (ifp-&gt;Opcode() == prev_op) ? prev_dom : top;
1475     // Control-target is just the If&#39;s immediate dominator or TOP.
1476     Node *ctrl_target = (ifp-&gt;Opcode() == prev_op) ?     idom : top;
1477 
1478     // For each child of an IfTrue/IfFalse projection, reroute.
1479     // Loop ends when projection has no more uses.
1480     for (DUIterator_Last jmin, j = ifp-&gt;last_outs(jmin); j &gt;= jmin; --j) {
1481       Node* s = ifp-&gt;last_out(j);   // Get child of IfTrue/IfFalse
1482       if( !s-&gt;depends_only_on_test() ) {
1483         // Find the control input matching this def-use edge.
1484         // For Regions it may not be in slot 0.
1485         uint l;
1486         for( l = 0; s-&gt;in(l) != ifp; l++ ) { }
1487         igvn-&gt;replace_input_of(s, l, ctrl_target);
1488       } else {                      // Else, for control producers,
1489         igvn-&gt;replace_input_of(s, 0, data_target); // Move child to data-target
1490       }
1491     } // End for each child of a projection
1492 
1493     igvn-&gt;remove_dead_node(ifp);
1494   } // End for each IfTrue/IfFalse child of If
1495 
1496   // Kill the IfNode
1497   igvn-&gt;remove_dead_node(this);
1498 
1499   // Must return either the original node (now dead) or a new node
1500   // (Do not return a top here, since that would break the uniqueness of top.)
1501   return new ConINode(TypeInt::ZERO);
1502 }
1503 
1504 Node* IfNode::search_identical(int dist) {
1505   // Setup to scan up the CFG looking for a dominating test
1506   Node* dom = in(0);
1507   Node* prev_dom = this;
1508   int op = Opcode();
1509   // Search up the dominator tree for an If with an identical test
1510   while (dom-&gt;Opcode() != op    ||  // Not same opcode?
1511          dom-&gt;in(1)    != in(1) ||  // Not same input 1?
1512          prev_dom-&gt;in(0) != dom) {  // One path of test does not dominate?
1513     if (dist &lt; 0) return NULL;
1514 
1515     dist--;
1516     prev_dom = dom;
1517     dom = up_one_dom(dom);
1518     if (!dom) return NULL;
1519   }
1520 
1521   // Check that we did not follow a loop back to ourselves
1522   if (this == dom) {
1523     return NULL;
1524   }
1525 
1526 #ifndef PRODUCT
1527   if (dist &gt; 2) { // Add to count of NULL checks elided
1528     explicit_null_checks_elided++;
1529   }
1530 #endif
1531 
1532   return prev_dom;
1533 }
1534 
1535 
1536 static int subsuming_bool_test_encode(Node*);
1537 
1538 // Check if dominating test is subsuming &#39;this&#39; one.
1539 //
1540 //              cmp
1541 //              / \
1542 //     (r1)  bool  \
1543 //            /    bool (r2)
1544 //    (dom) if       \
1545 //            \       )
1546 //    (pre)  if[TF]  /
1547 //               \  /
1548 //                if (this)
1549 //   \r1
1550 //  r2\  eqT  eqF  neT  neF  ltT  ltF  leT  leF  gtT  gtF  geT  geF
1551 //  eq    t    f    f    t    f    -    -    f    f    -    -    f
1552 //  ne    f    t    t    f    t    -    -    t    t    -    -    t
1553 //  lt    f    -    -    f    t    f    -    f    f    -    f    t
1554 //  le    t    -    -    t    t    -    t    f    f    t    -    t
1555 //  gt    f    -    -    f    f    -    f    t    t    f    -    f
1556 //  ge    t    -    -    t    f    t    -    t    t    -    t    f
1557 //
1558 Node* IfNode::simple_subsuming(PhaseIterGVN* igvn) {
1559   // Table encoding: N/A (na), True-branch (tb), False-branch (fb).
1560   static enum { na, tb, fb } s_short_circuit_map[6][12] = {
1561   /*rel: eq+T eq+F ne+T ne+F lt+T lt+F le+T le+F gt+T gt+F ge+T ge+F*/
1562   /*eq*/{ tb,  fb,  fb,  tb,  fb,  na,  na,  fb,  fb,  na,  na,  fb },
1563   /*ne*/{ fb,  tb,  tb,  fb,  tb,  na,  na,  tb,  tb,  na,  na,  tb },
1564   /*lt*/{ fb,  na,  na,  fb,  tb,  fb,  na,  fb,  fb,  na,  fb,  tb },
1565   /*le*/{ tb,  na,  na,  tb,  tb,  na,  tb,  fb,  fb,  tb,  na,  tb },
1566   /*gt*/{ fb,  na,  na,  fb,  fb,  na,  fb,  tb,  tb,  fb,  na,  fb },
1567   /*ge*/{ tb,  na,  na,  tb,  fb,  tb,  na,  tb,  tb,  na,  tb,  fb }};
1568 
1569   Node* pre = in(0);
1570   if (!pre-&gt;is_IfTrue() &amp;&amp; !pre-&gt;is_IfFalse()) {
1571     return NULL;
1572   }
1573   Node* dom = pre-&gt;in(0);
1574   if (!dom-&gt;is_If()) {
1575     return NULL;
1576   }
1577   Node* bol = in(1);
1578   if (!bol-&gt;is_Bool()) {
1579     return NULL;
1580   }
1581   Node* cmp = in(1)-&gt;in(1);
1582   if (!cmp-&gt;is_Cmp()) {
1583     return NULL;
1584   }
1585 
1586   if (!dom-&gt;in(1)-&gt;is_Bool()) {
1587     return NULL;
1588   }
1589   if (dom-&gt;in(1)-&gt;in(1) != cmp) {  // Not same cond?
1590     return NULL;
1591   }
1592 
1593   int drel = subsuming_bool_test_encode(dom-&gt;in(1));
1594   int trel = subsuming_bool_test_encode(bol);
1595   int bout = pre-&gt;is_IfFalse() ? 1 : 0;
1596 
1597   if (drel &lt; 0 || trel &lt; 0) {
1598     return NULL;
1599   }
1600   int br = s_short_circuit_map[trel][2*drel+bout];
1601   if (br == na) {
1602     return NULL;
1603   }
1604 #ifndef PRODUCT
1605   if (TraceIterativeGVN) {
1606     tty-&gt;print(&quot;   Subsumed IfNode: &quot;); dump();
1607   }
1608 #endif
1609   // Replace condition with constant True(1)/False(0).
1610   set_req(1, igvn-&gt;intcon(br == tb ? 1 : 0));
1611 
1612   if (bol-&gt;outcnt() == 0) {
1613     igvn-&gt;remove_dead_node(bol);    // Kill the BoolNode.
1614   }
1615   return this;
1616 }
1617 
1618 // Map BoolTest to local table encoding. The BoolTest (e)numerals
1619 //   { eq = 0, ne = 4, le = 5, ge = 7, lt = 3, gt = 1 }
1620 // are mapped to table indices, while the remaining (e)numerals in BoolTest
1621 //   { overflow = 2, no_overflow = 6, never = 8, illegal = 9 }
1622 // are ignored (these are not modeled in the table).
1623 //
1624 static int subsuming_bool_test_encode(Node* node) {
1625   precond(node-&gt;is_Bool());
1626   BoolTest::mask x = node-&gt;as_Bool()-&gt;_test._test;
1627   switch (x) {
1628     case BoolTest::eq: return 0;
1629     case BoolTest::ne: return 1;
1630     case BoolTest::lt: return 2;
1631     case BoolTest::le: return 3;
1632     case BoolTest::gt: return 4;
1633     case BoolTest::ge: return 5;
1634     case BoolTest::overflow:
1635     case BoolTest::no_overflow:
1636     case BoolTest::never:
1637     case BoolTest::illegal:
1638     default:
1639       return -1;
1640   }
1641 }
1642 
1643 //------------------------------Identity---------------------------------------
1644 // If the test is constant &amp; we match, then we are the input Control
1645 Node* IfProjNode::Identity(PhaseGVN* phase) {
1646   // Can only optimize if cannot go the other way
1647   const TypeTuple *t = phase-&gt;type(in(0))-&gt;is_tuple();
1648   if (t == TypeTuple::IFNEITHER || (always_taken(t) &amp;&amp;
1649        // During parsing (GVN) we don&#39;t remove dead code aggressively.
1650        // Cut off dead branch and let PhaseRemoveUseless take care of it.
1651       (!phase-&gt;is_IterGVN() ||
1652        // During IGVN, first wait for the dead branch to be killed.
1653        // Otherwise, the IfNode&#39;s control will have two control uses (the IfNode
1654        // that doesn&#39;t go away because it still has uses and this branch of the
1655        // If) which breaks other optimizations. Node::has_special_unique_user()
1656        // will cause this node to be reprocessed once the dead branch is killed.
1657        in(0)-&gt;outcnt() == 1))) {
1658     // IfNode control
1659     return in(0)-&gt;in(0);
1660   }
1661   // no progress
1662   return this;
1663 }
1664 
1665 #ifndef PRODUCT
1666 //-------------------------------related---------------------------------------
1667 // An IfProjNode&#39;s related node set consists of its input (an IfNode) including
1668 // the IfNode&#39;s condition, plus all of its outputs at level 1. In compact mode,
1669 // the restrictions for IfNode apply (see IfNode::rel).
1670 void IfProjNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
1671   Node* ifNode = this-&gt;in(0);
1672   in_rel-&gt;append(ifNode);
1673   if (compact) {
1674     ifNode-&gt;collect_nodes(in_rel, 3, false, true);
1675   } else {
1676     ifNode-&gt;collect_nodes_in_all_data(in_rel, false);
1677   }
1678   this-&gt;collect_nodes(out_rel, -1, false, false);
1679 }
1680 
1681 //------------------------------dump_spec--------------------------------------
1682 void IfNode::dump_spec(outputStream *st) const {
1683   st-&gt;print(&quot;P=%f, C=%f&quot;,_prob,_fcnt);
1684 }
1685 
1686 //-------------------------------related---------------------------------------
1687 // For an IfNode, the set of related output nodes is just the output nodes till
1688 // depth 2, i.e, the IfTrue/IfFalse projection nodes plus the nodes they refer.
1689 // The related input nodes contain no control nodes, but all data nodes
1690 // pertaining to the condition. In compact mode, the input nodes are collected
1691 // up to a depth of 3.
1692 void IfNode::related(GrowableArray &lt;Node *&gt; *in_rel, GrowableArray &lt;Node *&gt; *out_rel, bool compact) const {
1693   if (compact) {
1694     this-&gt;collect_nodes(in_rel, 3, false, true);
1695   } else {
1696     this-&gt;collect_nodes_in_all_data(in_rel, false);
1697   }
1698   this-&gt;collect_nodes(out_rel, -2, false, false);
1699 }
1700 #endif
1701 
1702 //------------------------------idealize_test----------------------------------
1703 // Try to canonicalize tests better.  Peek at the Cmp/Bool/If sequence and
1704 // come up with a canonical sequence.  Bools getting &#39;eq&#39;, &#39;gt&#39; and &#39;ge&#39; forms
1705 // converted to &#39;ne&#39;, &#39;le&#39; and &#39;lt&#39; forms.  IfTrue/IfFalse get swapped as
1706 // needed.
1707 static IfNode* idealize_test(PhaseGVN* phase, IfNode* iff) {
1708   assert(iff-&gt;in(0) != NULL, &quot;If must be live&quot;);
1709 
1710   if (iff-&gt;outcnt() != 2)  return NULL; // Malformed projections.
1711   Node* old_if_f = iff-&gt;proj_out(false);
1712   Node* old_if_t = iff-&gt;proj_out(true);
1713 
1714   // CountedLoopEnds want the back-control test to be TRUE, irregardless of
1715   // whether they are testing a &#39;gt&#39; or &#39;lt&#39; condition.  The &#39;gt&#39; condition
1716   // happens in count-down loops
1717   if (iff-&gt;is_CountedLoopEnd())  return NULL;
1718   if (!iff-&gt;in(1)-&gt;is_Bool())  return NULL; // Happens for partially optimized IF tests
1719   BoolNode *b = iff-&gt;in(1)-&gt;as_Bool();
1720   BoolTest bt = b-&gt;_test;
1721   // Test already in good order?
1722   if( bt.is_canonical() )
1723     return NULL;
1724 
1725   // Flip test to be canonical.  Requires flipping the IfFalse/IfTrue and
1726   // cloning the IfNode.
1727   Node* new_b = phase-&gt;transform( new BoolNode(b-&gt;in(1), bt.negate()) );
1728   if( !new_b-&gt;is_Bool() ) return NULL;
1729   b = new_b-&gt;as_Bool();
1730 
1731   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1732   assert( igvn, &quot;Test is not canonical in parser?&quot; );
1733 
1734   // The IF node never really changes, but it needs to be cloned
1735   iff = iff-&gt;clone()-&gt;as_If();
1736   iff-&gt;set_req(1, b);
1737   iff-&gt;_prob = 1.0-iff-&gt;_prob;
1738 
1739   Node *prior = igvn-&gt;hash_find_insert(iff);
1740   if( prior ) {
1741     igvn-&gt;remove_dead_node(iff);
1742     iff = (IfNode*)prior;
1743   } else {
1744     // Cannot call transform on it just yet
1745     igvn-&gt;set_type_bottom(iff);
1746   }
1747   igvn-&gt;_worklist.push(iff);
1748 
1749   // Now handle projections.  Cloning not required.
1750   Node* new_if_f = (Node*)(new IfFalseNode( iff ));
1751   Node* new_if_t = (Node*)(new IfTrueNode ( iff ));
1752 
1753   igvn-&gt;register_new_node_with_optimizer(new_if_f);
1754   igvn-&gt;register_new_node_with_optimizer(new_if_t);
1755   // Flip test, so flip trailing control
1756   igvn-&gt;replace_node(old_if_f, new_if_t);
1757   igvn-&gt;replace_node(old_if_t, new_if_f);
1758 
1759   // Progress
1760   return iff;
1761 }
1762 
1763 Node* RangeCheckNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1764   Node* res = Ideal_common(phase, can_reshape);
1765   if (res != NodeSentinel) {
1766     return res;
1767   }
1768 
1769   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1770   // Setup to scan up the CFG looking for a dominating test
1771   Node* prev_dom = this;
1772 
1773   // Check for range-check vs other kinds of tests
1774   Node* index1;
1775   Node* range1;
1776   jint offset1;
1777   int flip1 = is_range_check(range1, index1, offset1);
1778   if (flip1) {
1779     Node* dom = in(0);
1780     // Try to remove extra range checks.  All &#39;up_one_dom&#39; gives up at merges
1781     // so all checks we inspect post-dominate the top-most check we find.
1782     // If we are going to fail the current check and we reach the top check
1783     // then we are guaranteed to fail, so just start interpreting there.
1784     // We &#39;expand&#39; the top 3 range checks to include all post-dominating
1785     // checks.
1786 
1787     // The top 3 range checks seen
1788     const int NRC = 3;
1789     RangeCheck prev_checks[NRC];
1790     int nb_checks = 0;
1791 
1792     // Low and high offsets seen so far
1793     jint off_lo = offset1;
1794     jint off_hi = offset1;
1795 
1796     bool found_immediate_dominator = false;
1797 
1798     // Scan for the top checks and collect range of offsets
1799     for (int dist = 0; dist &lt; 999; dist++) { // Range-Check scan limit
1800       if (dom-&gt;Opcode() == Op_RangeCheck &amp;&amp;  // Not same opcode?
1801           prev_dom-&gt;in(0) == dom) { // One path of test does dominate?
1802         if (dom == this) return NULL; // dead loop
1803         // See if this is a range check
1804         Node* index2;
1805         Node* range2;
1806         jint offset2;
1807         int flip2 = dom-&gt;as_RangeCheck()-&gt;is_range_check(range2, index2, offset2);
1808         // See if this is a _matching_ range check, checking against
1809         // the same array bounds.
1810         if (flip2 == flip1 &amp;&amp; range2 == range1 &amp;&amp; index2 == index1 &amp;&amp;
1811             dom-&gt;outcnt() == 2) {
1812           if (nb_checks == 0 &amp;&amp; dom-&gt;in(1) == in(1)) {
1813             // Found an immediately dominating test at the same offset.
1814             // This kind of back-to-back test can be eliminated locally,
1815             // and there is no need to search further for dominating tests.
1816             assert(offset2 == offset1, &quot;Same test but different offsets&quot;);
1817             found_immediate_dominator = true;
1818             break;
1819           }
1820           // Gather expanded bounds
1821           off_lo = MIN2(off_lo,offset2);
1822           off_hi = MAX2(off_hi,offset2);
1823           // Record top NRC range checks
1824           prev_checks[nb_checks%NRC].ctl = prev_dom;
1825           prev_checks[nb_checks%NRC].off = offset2;
1826           nb_checks++;
1827         }
1828       }
1829       prev_dom = dom;
1830       dom = up_one_dom(dom);
1831       if (!dom) break;
1832     }
1833 
1834     if (!found_immediate_dominator) {
1835       // Attempt to widen the dominating range check to cover some later
1836       // ones.  Since range checks &quot;fail&quot; by uncommon-trapping to the
1837       // interpreter, widening a check can make us speculatively enter
1838       // the interpreter.  If we see range-check deopt&#39;s, do not widen!
1839       if (!phase-&gt;C-&gt;allow_range_check_smearing())  return NULL;
1840 
1841       // Didn&#39;t find prior covering check, so cannot remove anything.
1842       if (nb_checks == 0) {
1843         return NULL;
1844       }
1845       // Constant indices only need to check the upper bound.
1846       // Non-constant indices must check both low and high.
1847       int chk0 = (nb_checks - 1) % NRC;
1848       if (index1) {
1849         if (nb_checks == 1) {
1850           return NULL;
1851         } else {
1852           // If the top range check&#39;s constant is the min or max of
1853           // all constants we widen the next one to cover the whole
1854           // range of constants.
1855           RangeCheck rc0 = prev_checks[chk0];
1856           int chk1 = (nb_checks - 2) % NRC;
1857           RangeCheck rc1 = prev_checks[chk1];
1858           if (rc0.off == off_lo) {
1859             adjust_check(rc1.ctl, range1, index1, flip1, off_hi, igvn);
1860             prev_dom = rc1.ctl;
1861           } else if (rc0.off == off_hi) {
1862             adjust_check(rc1.ctl, range1, index1, flip1, off_lo, igvn);
1863             prev_dom = rc1.ctl;
1864           } else {
1865             // If the top test&#39;s constant is not the min or max of all
1866             // constants, we need 3 range checks. We must leave the
1867             // top test unchanged because widening it would allow the
1868             // accesses it protects to successfully read/write out of
1869             // bounds.
1870             if (nb_checks == 2) {
1871               return NULL;
1872             }
1873             int chk2 = (nb_checks - 3) % NRC;
1874             RangeCheck rc2 = prev_checks[chk2];
1875             // The top range check a+i covers interval: -a &lt;= i &lt; length-a
1876             // The second range check b+i covers interval: -b &lt;= i &lt; length-b
1877             if (rc1.off &lt;= rc0.off) {
1878               // if b &lt;= a, we change the second range check to:
1879               // -min_of_all_constants &lt;= i &lt; length-min_of_all_constants
1880               // Together top and second range checks now cover:
1881               // -min_of_all_constants &lt;= i &lt; length-a
1882               // which is more restrictive than -b &lt;= i &lt; length-b:
1883               // -b &lt;= -min_of_all_constants &lt;= i &lt; length-a &lt;= length-b
1884               // The third check is then changed to:
1885               // -max_of_all_constants &lt;= i &lt; length-max_of_all_constants
1886               // so 2nd and 3rd checks restrict allowed values of i to:
1887               // -min_of_all_constants &lt;= i &lt; length-max_of_all_constants
1888               adjust_check(rc1.ctl, range1, index1, flip1, off_lo, igvn);
1889               adjust_check(rc2.ctl, range1, index1, flip1, off_hi, igvn);
1890             } else {
1891               // if b &gt; a, we change the second range check to:
1892               // -max_of_all_constants &lt;= i &lt; length-max_of_all_constants
1893               // Together top and second range checks now cover:
1894               // -a &lt;= i &lt; length-max_of_all_constants
1895               // which is more restrictive than -b &lt;= i &lt; length-b:
1896               // -b &lt; -a &lt;= i &lt; length-max_of_all_constants &lt;= length-b
1897               // The third check is then changed to:
1898               // -max_of_all_constants &lt;= i &lt; length-max_of_all_constants
1899               // so 2nd and 3rd checks restrict allowed values of i to:
1900               // -min_of_all_constants &lt;= i &lt; length-max_of_all_constants
1901               adjust_check(rc1.ctl, range1, index1, flip1, off_hi, igvn);
1902               adjust_check(rc2.ctl, range1, index1, flip1, off_lo, igvn);
1903             }
1904             prev_dom = rc2.ctl;
1905           }
1906         }
1907       } else {
1908         RangeCheck rc0 = prev_checks[chk0];
1909         // &#39;Widen&#39; the offset of the 1st and only covering check
1910         adjust_check(rc0.ctl, range1, index1, flip1, off_hi, igvn);
1911         // Test is now covered by prior checks, dominate it out
1912         prev_dom = rc0.ctl;
1913       }
1914     }
1915   } else {
1916     prev_dom = search_identical(4);
1917 
1918     if (prev_dom == NULL) {
1919       return NULL;
1920     }
1921   }
1922 
1923   // Replace dominated IfNode
1924   return dominated_by(prev_dom, igvn);
1925 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>