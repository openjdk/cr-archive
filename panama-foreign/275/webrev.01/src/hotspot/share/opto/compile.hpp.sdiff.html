<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/compile.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ifnode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1000   void set_inner_loops(int z) { _inner_loops = z; }
1001 
1002   Dependencies* dependencies() { return env()-&gt;dependencies(); }
1003 
1004   // Major entry point.  Given a Scope, compile the associated method.
1005   // For normal compilations, entry_bci is InvocationEntryBci.  For on stack
1006   // replacement, entry_bci indicates the bytecode for which to compile a
1007   // continuation.
1008   Compile(ciEnv* ci_env, ciMethod* target,
1009           int entry_bci, bool subsume_loads, bool do_escape_analysis,
1010           bool eliminate_boxing, bool install_code, DirectiveSet* directive);
1011 
1012   // Second major entry point.  From the TypeFunc signature, generate code
1013   // to pass arguments from the Java calling convention to the C calling
1014   // convention.
1015   Compile(ciEnv* ci_env, const TypeFunc *(*gen)(),
1016           address stub_function, const char *stub_name,
1017           int is_fancy_jump, bool pass_tls,
1018           bool save_arg_registers, bool return_pc, DirectiveSet* directive);
1019 
<span class="line-removed">1020   // From the TypeFunc signature, generate code to pass arguments</span>
<span class="line-removed">1021   // from Compiled calling convention to Interpreter&#39;s calling convention</span>
<span class="line-removed">1022   void Generate_Compiled_To_Interpreter_Graph(const TypeFunc *tf, address interpreter_entry);</span>
<span class="line-removed">1023 </span>
<span class="line-removed">1024   // From the TypeFunc signature, generate code to pass arguments</span>
<span class="line-removed">1025   // from Interpreter&#39;s calling convention to Compiler&#39;s calling convention</span>
<span class="line-removed">1026   void Generate_Interpreter_To_Compiled_Graph(const TypeFunc *tf);</span>
<span class="line-removed">1027 </span>
1028   // Are we compiling a method?
1029   bool has_method() { return method() != NULL; }
1030 
1031   // Maybe print some information about this compile.
1032   void print_compile_messages();
1033 
1034   // Final graph reshaping, a post-pass after the regular optimizer is done.
1035   bool final_graph_reshaping();
1036 
1037   // returns true if adr is completely contained in the given alias category
1038   bool must_alias(const TypePtr* adr, int alias_idx);
1039 
1040   // returns true if adr overlaps with the given alias category
1041   bool can_alias(const TypePtr* adr, int alias_idx);
1042 
1043   // If &quot;objs&quot; contains an ObjectValue whose id is &quot;id&quot;, returns it, else NULL.
1044   static ObjectValue* sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id);
1045 
1046   // Stack slots that may be unused by the calling convention but must
1047   // otherwise be preserved.  On Intel this includes the return address.
</pre>
</td>
<td>
<hr />
<pre>
1000   void set_inner_loops(int z) { _inner_loops = z; }
1001 
1002   Dependencies* dependencies() { return env()-&gt;dependencies(); }
1003 
1004   // Major entry point.  Given a Scope, compile the associated method.
1005   // For normal compilations, entry_bci is InvocationEntryBci.  For on stack
1006   // replacement, entry_bci indicates the bytecode for which to compile a
1007   // continuation.
1008   Compile(ciEnv* ci_env, ciMethod* target,
1009           int entry_bci, bool subsume_loads, bool do_escape_analysis,
1010           bool eliminate_boxing, bool install_code, DirectiveSet* directive);
1011 
1012   // Second major entry point.  From the TypeFunc signature, generate code
1013   // to pass arguments from the Java calling convention to the C calling
1014   // convention.
1015   Compile(ciEnv* ci_env, const TypeFunc *(*gen)(),
1016           address stub_function, const char *stub_name,
1017           int is_fancy_jump, bool pass_tls,
1018           bool save_arg_registers, bool return_pc, DirectiveSet* directive);
1019 








1020   // Are we compiling a method?
1021   bool has_method() { return method() != NULL; }
1022 
1023   // Maybe print some information about this compile.
1024   void print_compile_messages();
1025 
1026   // Final graph reshaping, a post-pass after the regular optimizer is done.
1027   bool final_graph_reshaping();
1028 
1029   // returns true if adr is completely contained in the given alias category
1030   bool must_alias(const TypePtr* adr, int alias_idx);
1031 
1032   // returns true if adr overlaps with the given alias category
1033   bool can_alias(const TypePtr* adr, int alias_idx);
1034 
1035   // If &quot;objs&quot; contains an ObjectValue whose id is &quot;id&quot;, returns it, else NULL.
1036   static ObjectValue* sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id);
1037 
1038   // Stack slots that may be unused by the calling convention but must
1039   // otherwise be preserved.  On Intel this includes the return address.
</pre>
</td>
</tr>
</table>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ifnode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>