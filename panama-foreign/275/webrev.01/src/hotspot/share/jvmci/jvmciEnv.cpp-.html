<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/jvmci/jvmciEnv.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/stringTable.hpp&quot;
  27 #include &quot;classfile/symbolTable.hpp&quot;
  28 #include &quot;code/codeCache.hpp&quot;
  29 #include &quot;compiler/compileTask.hpp&quot;
  30 #include &quot;memory/oopFactory.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;memory/universe.hpp&quot;
  33 #include &quot;oops/objArrayKlass.hpp&quot;
  34 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  35 #include &quot;runtime/deoptimization.hpp&quot;
  36 #include &quot;runtime/jniHandles.inline.hpp&quot;
  37 #include &quot;runtime/javaCalls.hpp&quot;
  38 #include &quot;jvmci/jniAccessMark.inline.hpp&quot;
  39 #include &quot;jvmci/jvmciRuntime.hpp&quot;
  40 
  41 JVMCICompileState::JVMCICompileState(CompileTask* task):
  42   _task(task),
  43   _retryable(true),
  44   _failure_reason(NULL),
  45   _failure_reason_on_C_heap(false) {
  46   // Get Jvmti capabilities under lock to get consistent values.
  47   MutexLocker mu(JvmtiThreadState_lock);
  48   _jvmti_redefinition_count             = JvmtiExport::redefinition_count();
  49   _jvmti_can_hotswap_or_post_breakpoint = JvmtiExport::can_hotswap_or_post_breakpoint() ? 1 : 0;
  50   _jvmti_can_access_local_variables     = JvmtiExport::can_access_local_variables() ? 1 : 0;
  51   _jvmti_can_post_on_exceptions         = JvmtiExport::can_post_on_exceptions() ? 1 : 0;
  52   _jvmti_can_pop_frame                  = JvmtiExport::can_pop_frame() ? 1 : 0;
  53   _target_method_is_old                 = _task != NULL &amp;&amp; _task-&gt;method()-&gt;is_old();
  54 }
  55 
  56 bool JVMCICompileState::jvmti_state_changed() const {
  57   // Some classes were redefined
  58   if (jvmti_redefinition_count() != JvmtiExport::redefinition_count()) {
  59     return true;
  60   }
  61   if (!jvmti_can_access_local_variables() &amp;&amp;
  62       JvmtiExport::can_access_local_variables()) {
  63     return true;
  64   }
  65   if (!jvmti_can_hotswap_or_post_breakpoint() &amp;&amp;
  66       JvmtiExport::can_hotswap_or_post_breakpoint()) {
  67     return true;
  68   }
  69   if (!jvmti_can_post_on_exceptions() &amp;&amp;
  70       JvmtiExport::can_post_on_exceptions()) {
  71     return true;
  72   }
  73   if (!jvmti_can_pop_frame() &amp;&amp;
  74       JvmtiExport::can_pop_frame()) {
  75     return true;
  76   }
  77   return false;
  78 }
  79 
  80 void JVMCIEnv::copy_saved_properties() {
  81   assert(!is_hotspot(), &quot;can only copy saved properties from HotSpot to native image&quot;);
  82 
  83   JavaThread* THREAD = JavaThread::current();
  84 
  85   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_services_Services(), Handle(), Handle(), true, THREAD);
  86   if (HAS_PENDING_EXCEPTION) {
  87     JVMCIRuntime::exit_on_pending_exception(NULL, &quot;Error initializing jdk.vm.ci.services.Services&quot;);
  88   }
  89   InstanceKlass* ik = InstanceKlass::cast(k);
  90   if (ik-&gt;should_be_initialized()) {
  91     ik-&gt;initialize(THREAD);
  92     if (HAS_PENDING_EXCEPTION) {
  93       JVMCIRuntime::exit_on_pending_exception(NULL, &quot;Error initializing jdk.vm.ci.services.Services&quot;);
  94     }
  95   }
  96 
  97   // Get the serialized saved properties from HotSpot
  98   TempNewSymbol serializeSavedProperties = SymbolTable::new_symbol(&quot;serializeSavedProperties&quot;);
  99   JavaValue result(T_OBJECT);
 100   JavaCallArguments args;
 101   JavaCalls::call_static(&amp;result, ik, serializeSavedProperties, vmSymbols::serializePropertiesToByteArray_signature(), &amp;args, THREAD);
 102   if (HAS_PENDING_EXCEPTION) {
 103     JVMCIRuntime::exit_on_pending_exception(NULL, &quot;Error calling jdk.vm.ci.services.Services.serializeSavedProperties&quot;);
 104   }
 105   oop res = (oop) result.get_jobject();
 106   assert(res-&gt;is_typeArray(), &quot;must be&quot;);
 107   assert(TypeArrayKlass::cast(res-&gt;klass())-&gt;element_type() == T_BYTE, &quot;must be&quot;);
 108   typeArrayOop ba = typeArrayOop(res);
 109   int serialized_properties_len = ba-&gt;length();
 110 
 111   // Copy serialized saved properties from HotSpot object into native buffer
 112   jbyte* serialized_properties = NEW_RESOURCE_ARRAY(jbyte, serialized_properties_len);
 113   memcpy(serialized_properties, ba-&gt;byte_at_addr(0), serialized_properties_len);
 114 
 115   // Copy native buffer into shared library object
 116   JVMCIPrimitiveArray buf = new_byteArray(serialized_properties_len, this);
 117   if (has_pending_exception()) {
 118     describe_pending_exception(true);
 119     fatal(&quot;Error in copy_saved_properties&quot;);
 120   }
 121   copy_bytes_from(serialized_properties, buf, 0, serialized_properties_len);
 122   if (has_pending_exception()) {
 123     describe_pending_exception(true);
 124     fatal(&quot;Error in copy_saved_properties&quot;);
 125   }
 126 
 127   // Initialize saved properties in shared library
 128   jclass servicesClass = JNIJVMCI::Services::clazz();
 129   jmethodID initializeSavedProperties = JNIJVMCI::Services::initializeSavedProperties_method();
 130   JNIAccessMark jni(this, THREAD);
 131   jni()-&gt;CallStaticVoidMethod(servicesClass, initializeSavedProperties, buf.as_jobject());
 132   if (jni()-&gt;ExceptionCheck()) {
 133     jni()-&gt;ExceptionDescribe();
 134     fatal(&quot;Error calling jdk.vm.ci.services.Services.initializeSavedProperties&quot;);
 135   }
 136 }
 137 
 138 void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env) {
 139   assert(thread != NULL, &quot;npe&quot;);
 140   _env = NULL;
 141   _pop_frame_on_close = false;
 142   _detach_on_close = false;
 143   if (!UseJVMCINativeLibrary) {
 144     // In HotSpot mode, JNI isn&#39;t used at all.
 145     _runtime = JVMCI::java_runtime();
 146     _is_hotspot = true;
 147     return;
 148   }
 149 
 150   if (parent_env != NULL) {
 151     // If the parent JNI environment is non-null then figure out whether it
 152     // is a HotSpot or shared library JNIEnv and set the state appropriately.
 153     _is_hotspot = thread-&gt;jni_environment() == parent_env;
 154     if (_is_hotspot) {
 155       // Select the Java runtime
 156       _runtime = JVMCI::java_runtime();
 157       return;
 158     }
 159     _runtime = JVMCI::compiler_runtime();
 160     assert(_runtime != NULL, &quot;npe&quot;);
 161     _env = parent_env;
 162     return;
 163   }
 164 
 165   // Running in JVMCI shared library mode so ensure the shared library
 166   // is loaded and initialized and get a shared library JNIEnv
 167   _is_hotspot = false;
 168 
 169   _runtime = JVMCI::compiler_runtime();
 170   _env = _runtime-&gt;init_shared_library_javavm();
 171 
 172   if (_env != NULL) {
 173     // Creating the JVMCI shared library VM also attaches the current thread
 174     _detach_on_close = true;
 175   } else {
 176     _runtime-&gt;GetEnv(thread, (void**)&amp;parent_env, JNI_VERSION_1_2);
 177     if (parent_env != NULL) {
 178       // Even though there&#39;s a parent JNI env, there&#39;s no guarantee
 179       // it was opened by a JVMCIEnv scope and thus may not have
 180       // pushed a local JNI frame. As such, we use a new JNI local
 181       // frame in this scope to ensure local JNI refs are collected
 182       // in a timely manner after leaving this scope.
 183       _env = parent_env;
 184     } else {
 185       ResourceMark rm; // Thread name is resource allocated
 186       JavaVMAttachArgs attach_args;
 187       attach_args.version = JNI_VERSION_1_2;
 188       attach_args.name = thread-&gt;name();
 189       attach_args.group = NULL;
 190       if (_runtime-&gt;AttachCurrentThread(thread, (void**) &amp;_env, &amp;attach_args) != JNI_OK) {
 191         fatal(&quot;Error attaching current thread (%s) to JVMCI shared library JNI interface&quot;, attach_args.name);
 192       }
 193       _detach_on_close = true;
 194     }
 195   }
 196 
 197   assert(_env != NULL, &quot;missing env&quot;);
 198   assert(_throw_to_caller == false, &quot;must be&quot;);
 199 
 200   JNIAccessMark jni(this, thread);
 201   jint result = _env-&gt;PushLocalFrame(32);
 202   if (result != JNI_OK) {
 203     char message[256];
 204     jio_snprintf(message, 256, &quot;Uncaught exception pushing local frame for JVMCIEnv scope entered at %s:%d&quot;, _file, _line);
 205     JVMCIRuntime::exit_on_pending_exception(this, message);
 206   }
 207   _pop_frame_on_close = true;
 208 }
 209 
 210 JVMCIEnv::JVMCIEnv(JavaThread* thread, JVMCICompileState* compile_state, const char* file, int line):
 211     _throw_to_caller(false), _file(file), _line(line), _compile_state(compile_state) {
 212   init_env_mode_runtime(thread, NULL);
 213 }
 214 
 215 JVMCIEnv::JVMCIEnv(JavaThread* thread, const char* file, int line):
 216     _throw_to_caller(false), _file(file), _line(line), _compile_state(NULL) {
 217   init_env_mode_runtime(thread, NULL);
 218 }
 219 
 220 JVMCIEnv::JVMCIEnv(JavaThread* thread, JNIEnv* parent_env, const char* file, int line):
 221     _throw_to_caller(true), _file(file), _line(line), _compile_state(NULL) {
 222   init_env_mode_runtime(thread, parent_env);
 223   assert(_env == NULL || parent_env == _env, &quot;mismatched JNIEnvironment&quot;);
 224 }
 225 
 226 void JVMCIEnv::init(JavaThread* thread, bool is_hotspot, const char* file, int line) {
 227   _compile_state = NULL;
 228   _throw_to_caller = false;
 229   _file = file;
 230   _line = line;
 231   if (is_hotspot) {
 232     _env = NULL;
 233     _pop_frame_on_close = false;
 234     _detach_on_close = false;
 235     _is_hotspot = true;
 236     _runtime = JVMCI::java_runtime();
 237   } else {
 238     init_env_mode_runtime(thread, NULL);
 239   }
 240 }
 241 
 242 // Prints a pending exception (if any) and its stack trace.
 243 void JVMCIEnv::describe_pending_exception(bool clear) {
 244   Thread* THREAD = Thread::current();
 245   if (!is_hotspot()) {
 246     JNIAccessMark jni(this);
 247     if (jni()-&gt;ExceptionCheck()) {
 248       jthrowable ex = !clear ? jni()-&gt;ExceptionOccurred() : NULL;
 249       jni()-&gt;ExceptionDescribe();
 250       if (ex != NULL) {
 251         jni()-&gt;Throw(ex);
 252       }
 253     }
 254   } else {
 255     if (HAS_PENDING_EXCEPTION) {
 256       JVMCIRuntime::describe_pending_hotspot_exception((JavaThread*) THREAD, clear);
 257     }
 258   }
 259 }
 260 
 261 void JVMCIEnv::translate_hotspot_exception_to_jni_exception(JavaThread* THREAD, const Handle&amp; throwable) {
 262   assert(!is_hotspot(), &quot;must_be&quot;);
 263   // Resolve HotSpotJVMCIRuntime class explicitly as HotSpotJVMCI::compute_offsets
 264   // may not have been called.
 265   Klass* runtimeKlass = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_hotspot_HotSpotJVMCIRuntime(), true, CHECK);
 266   JavaCallArguments jargs;
 267   jargs.push_oop(throwable);
 268   JavaValue result(T_OBJECT);
 269   JavaCalls::call_static(&amp;result,
 270                           runtimeKlass,
 271                           vmSymbols::encodeThrowable_name(),
 272                           vmSymbols::encodeThrowable_signature(), &amp;jargs, THREAD);
 273   if (HAS_PENDING_EXCEPTION) {
 274     JVMCIRuntime::exit_on_pending_exception(this, &quot;HotSpotJVMCIRuntime.encodeThrowable should not throw an exception&quot;);
 275   }
 276 
 277   oop encoded_throwable_string = (oop) result.get_jobject();
 278 
 279   ResourceMark rm;
 280   const char* encoded_throwable_chars = java_lang_String::as_utf8_string(encoded_throwable_string);
 281 
 282   JNIAccessMark jni(this, THREAD);
 283   jobject jni_encoded_throwable_string = jni()-&gt;NewStringUTF(encoded_throwable_chars);
 284   jthrowable jni_throwable = (jthrowable) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
 285                                 JNIJVMCI::HotSpotJVMCIRuntime::decodeThrowable_method(),
 286                                 jni_encoded_throwable_string);
 287   jni()-&gt;Throw(jni_throwable);
 288 }
 289 
 290 JVMCIEnv::~JVMCIEnv() {
 291   if (_throw_to_caller) {
 292     if (is_hotspot()) {
 293       // Nothing to do
 294     } else {
 295       if (Thread::current()-&gt;is_Java_thread()) {
 296         JavaThread* THREAD = JavaThread::current();
 297         if (HAS_PENDING_EXCEPTION) {
 298           Handle throwable = Handle(THREAD, PENDING_EXCEPTION);
 299           CLEAR_PENDING_EXCEPTION;
 300           translate_hotspot_exception_to_jni_exception(THREAD, throwable);
 301         }
 302       }
 303     }
 304   } else {
 305     if (_pop_frame_on_close) {
 306       // Pop the JNI local frame that was pushed when entering this JVMCIEnv scope.
 307       JNIAccessMark jni(this);
 308       jni()-&gt;PopLocalFrame(NULL);
 309     }
 310 
 311     if (has_pending_exception()) {
 312       char message[256];
 313       jio_snprintf(message, 256, &quot;Uncaught exception exiting JVMCIEnv scope entered at %s:%d&quot;, _file, _line);
 314       JVMCIRuntime::exit_on_pending_exception(this, message);
 315     }
 316 
 317     if (_detach_on_close) {
 318       _runtime-&gt;DetachCurrentThread(JavaThread::current());
 319     }
 320   }
 321 }
 322 
 323 jboolean JVMCIEnv::has_pending_exception() {
 324   if (is_hotspot()) {
 325     Thread* THREAD = Thread::current();
 326     return HAS_PENDING_EXCEPTION;
 327   } else {
 328     JNIAccessMark jni(this);
 329     return jni()-&gt;ExceptionCheck();
 330   }
 331 }
 332 
 333 void JVMCIEnv::clear_pending_exception() {
 334   if (is_hotspot()) {
 335     Thread* THREAD = Thread::current();
 336     CLEAR_PENDING_EXCEPTION;
 337   } else {
 338     JNIAccessMark jni(this);
 339     jni()-&gt;ExceptionClear();
 340   }
 341 }
 342 
 343 int JVMCIEnv::get_length(JVMCIArray array) {
 344   if (is_hotspot()) {
 345     return HotSpotJVMCI::resolve(array)-&gt;length();
 346   } else {
 347     JNIAccessMark jni(this);
 348     return jni()-&gt;GetArrayLength(get_jarray(array));
 349   }
 350 }
 351 
 352 JVMCIObject JVMCIEnv::get_object_at(JVMCIObjectArray array, int index) {
 353   if (is_hotspot()) {
 354     oop result = HotSpotJVMCI::resolve(array)-&gt;obj_at(index);
 355     return wrap(result);
 356   } else {
 357     JNIAccessMark jni(this);
 358     jobject result = jni()-&gt;GetObjectArrayElement(get_jobjectArray(array), index);
 359     return wrap(result);
 360   }
 361 }
 362 
 363 void JVMCIEnv::put_object_at(JVMCIObjectArray array, int index, JVMCIObject value) {
 364   if (is_hotspot()) {
 365     HotSpotJVMCI::resolve(array)-&gt;obj_at_put(index, HotSpotJVMCI::resolve(value));
 366   } else {
 367     JNIAccessMark jni(this);
 368     jni()-&gt;SetObjectArrayElement(get_jobjectArray(array), index, get_jobject(value));
 369   }
 370 }
 371 
 372 jboolean JVMCIEnv::get_bool_at(JVMCIPrimitiveArray array, int index) {
 373   if (is_hotspot()) {
 374     return HotSpotJVMCI::resolve(array)-&gt;bool_at(index);
 375   } else {
 376     JNIAccessMark jni(this);
 377     jboolean result;
 378     jni()-&gt;GetBooleanArrayRegion(array.as_jbooleanArray(), index, 1, &amp;result);
 379     return result;
 380   }
 381 }
 382 void JVMCIEnv::put_bool_at(JVMCIPrimitiveArray array, int index, jboolean value) {
 383   if (is_hotspot()) {
 384     HotSpotJVMCI::resolve(array)-&gt;bool_at_put(index, value);
 385   } else {
 386     JNIAccessMark jni(this);
 387     jni()-&gt;SetBooleanArrayRegion(array.as_jbooleanArray(), index, 1, &amp;value);
 388   }
 389 }
 390 
 391 jbyte JVMCIEnv::get_byte_at(JVMCIPrimitiveArray array, int index) {
 392   if (is_hotspot()) {
 393     return HotSpotJVMCI::resolve(array)-&gt;byte_at(index);
 394   } else {
 395     JNIAccessMark jni(this);
 396     jbyte result;
 397     jni()-&gt;GetByteArrayRegion(array.as_jbyteArray(), index, 1, &amp;result);
 398     return result;
 399   }
 400 }
 401 void JVMCIEnv::put_byte_at(JVMCIPrimitiveArray array, int index, jbyte value) {
 402   if (is_hotspot()) {
 403     HotSpotJVMCI::resolve(array)-&gt;byte_at_put(index, value);
 404   } else {
 405     JNIAccessMark jni(this);
 406     jni()-&gt;SetByteArrayRegion(array.as_jbyteArray(), index, 1, &amp;value);
 407   }
 408 }
 409 
 410 jint JVMCIEnv::get_int_at(JVMCIPrimitiveArray array, int index) {
 411   if (is_hotspot()) {
 412     return HotSpotJVMCI::resolve(array)-&gt;int_at(index);
 413   } else {
 414     JNIAccessMark jni(this);
 415     jint result;
 416     jni()-&gt;GetIntArrayRegion(array.as_jintArray(), index, 1, &amp;result);
 417     return result;
 418   }
 419 }
 420 void JVMCIEnv::put_int_at(JVMCIPrimitiveArray array, int index, jint value) {
 421   if (is_hotspot()) {
 422     HotSpotJVMCI::resolve(array)-&gt;int_at_put(index, value);
 423   } else {
 424     JNIAccessMark jni(this);
 425     jni()-&gt;SetIntArrayRegion(array.as_jintArray(), index, 1, &amp;value);
 426   }
 427 }
 428 
 429 long JVMCIEnv::get_long_at(JVMCIPrimitiveArray array, int index) {
 430   if (is_hotspot()) {
 431     return HotSpotJVMCI::resolve(array)-&gt;long_at(index);
 432   } else {
 433     JNIAccessMark jni(this);
 434     jlong result;
 435     jni()-&gt;GetLongArrayRegion(array.as_jlongArray(), index, 1, &amp;result);
 436     return result;
 437   }
 438 }
 439 void JVMCIEnv::put_long_at(JVMCIPrimitiveArray array, int index, jlong value) {
 440   if (is_hotspot()) {
 441     HotSpotJVMCI::resolve(array)-&gt;long_at_put(index, value);
 442   } else {
 443     JNIAccessMark jni(this);
 444     jni()-&gt;SetLongArrayRegion(array.as_jlongArray(), index, 1, &amp;value);
 445   }
 446 }
 447 
 448 void JVMCIEnv::copy_bytes_to(JVMCIPrimitiveArray src, jbyte* dest, int offset, jsize length) {
 449   if (length == 0) {
 450     return;
 451   }
 452   if (is_hotspot()) {
 453     memcpy(dest, HotSpotJVMCI::resolve(src)-&gt;byte_at_addr(offset), length);
 454   } else {
 455     JNIAccessMark jni(this);
 456     jni()-&gt;GetByteArrayRegion(src.as_jbyteArray(), offset, length, dest);
 457   }
 458 }
 459 void JVMCIEnv::copy_bytes_from(jbyte* src, JVMCIPrimitiveArray dest, int offset, jsize length) {
 460   if (length == 0) {
 461     return;
 462   }
 463   if (is_hotspot()) {
 464     memcpy(HotSpotJVMCI::resolve(dest)-&gt;byte_at_addr(offset), src, length);
 465   } else {
 466     JNIAccessMark jni(this);
 467     jni()-&gt;SetByteArrayRegion(dest.as_jbyteArray(), offset, length, src);
 468   }
 469 }
 470 
 471 void JVMCIEnv::copy_longs_from(jlong* src, JVMCIPrimitiveArray dest, int offset, jsize length) {
 472   if (length == 0) {
 473     return;
 474   }
 475   if (is_hotspot()) {
 476     memcpy(HotSpotJVMCI::resolve(dest)-&gt;long_at_addr(offset), src, length * sizeof(jlong));
 477   } else {
 478     JNIAccessMark jni(this);
 479     jni()-&gt;SetLongArrayRegion(dest.as_jlongArray(), offset, length, src);
 480   }
 481 }
 482 
 483 jboolean JVMCIEnv::is_boxing_object(BasicType type, JVMCIObject object) {
 484   if (is_hotspot()) {
 485     return java_lang_boxing_object::is_instance(HotSpotJVMCI::resolve(object), type);
 486   } else {
 487     JNIAccessMark jni(this);
 488     return jni()-&gt;IsInstanceOf(get_jobject(object), JNIJVMCI::box_class(type));
 489   }
 490 }
 491 
 492 // Get the primitive value from a Java boxing object.  It&#39;s hard error to
 493 // pass a non-primitive BasicType.
 494 jvalue JVMCIEnv::get_boxed_value(BasicType type, JVMCIObject object) {
 495   jvalue result;
 496   if (is_hotspot()) {
 497     if (java_lang_boxing_object::get_value(HotSpotJVMCI::resolve(object), &amp;result) == T_ILLEGAL) {
 498       ShouldNotReachHere();
 499     }
 500   } else {
 501     JNIAccessMark jni(this);
 502     jfieldID field = JNIJVMCI::box_field(type);
 503     switch (type) {
 504       case T_BOOLEAN: result.z = jni()-&gt;GetBooleanField(get_jobject(object), field); break;
 505       case T_BYTE:    result.b = jni()-&gt;GetByteField(get_jobject(object), field); break;
 506       case T_SHORT:   result.s = jni()-&gt;GetShortField(get_jobject(object), field); break;
 507       case T_CHAR:    result.c = jni()-&gt;GetCharField(get_jobject(object), field); break;
 508       case T_INT:     result.i = jni()-&gt;GetIntField(get_jobject(object), field); break;
 509       case T_LONG:    result.j = jni()-&gt;GetLongField(get_jobject(object), field); break;
 510       case T_FLOAT:   result.f = jni()-&gt;GetFloatField(get_jobject(object), field); break;
 511       case T_DOUBLE:  result.d = jni()-&gt;GetDoubleField(get_jobject(object), field); break;
 512       default:
 513         ShouldNotReachHere();
 514     }
 515   }
 516   return result;
 517 }
 518 
 519 // Return the BasicType of the object if it&#39;s a boxing object, otherwise return T_ILLEGAL.
 520 BasicType JVMCIEnv::get_box_type(JVMCIObject object) {
 521   if (is_hotspot()) {
 522     return java_lang_boxing_object::basic_type(HotSpotJVMCI::resolve(object));
 523   } else {
 524     JNIAccessMark jni(this);
 525     jclass clazz = jni()-&gt;GetObjectClass(get_jobject(object));
 526     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_BOOLEAN))) return T_BOOLEAN;
 527     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_BYTE))) return T_BYTE;
 528     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_SHORT))) return T_SHORT;
 529     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_CHAR))) return T_CHAR;
 530     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_INT))) return T_INT;
 531     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_LONG))) return T_LONG;
 532     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_FLOAT))) return T_FLOAT;
 533     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_DOUBLE))) return T_DOUBLE;
 534     return T_ILLEGAL;
 535   }
 536 }
 537 
 538 // Create a boxing object of the appropriate primitive type.
 539 JVMCIObject JVMCIEnv::create_box(BasicType type, jvalue* value, JVMCI_TRAPS) {
 540   switch (type) {
 541     case T_BOOLEAN:
 542     case T_BYTE:
 543     case T_CHAR:
 544     case T_SHORT:
 545     case T_INT:
 546     case T_LONG:
 547     case T_FLOAT:
 548     case T_DOUBLE:
 549       break;
 550     default:
 551       JVMCI_THROW_MSG_(IllegalArgumentException, &quot;Only boxes for primitive values can be created&quot;, JVMCIObject());
 552   }
 553   JavaThread* THREAD = JavaThread::current();
 554   if (is_hotspot()) {
 555     oop box = java_lang_boxing_object::create(type, value, CHECK_(JVMCIObject()));
 556     return HotSpotJVMCI::wrap(box);
 557   } else {
 558     JNIAccessMark jni(this, THREAD);
 559     jobject box = jni()-&gt;NewObjectA(JNIJVMCI::box_class(type), JNIJVMCI::box_constructor(type), value);
 560     assert(box != NULL, &quot;&quot;);
 561     return wrap(box);
 562   }
 563 }
 564 
 565 const char* JVMCIEnv::as_utf8_string(JVMCIObject str) {
 566   if (is_hotspot()) {
 567     return java_lang_String::as_utf8_string(HotSpotJVMCI::resolve(str));
 568   } else {
 569     JNIAccessMark jni(this);
 570     int length = jni()-&gt;GetStringLength(str.as_jstring());
 571     int utf8_length = jni()-&gt;GetStringUTFLength(str.as_jstring());
 572     char* result = NEW_RESOURCE_ARRAY(char, utf8_length + 1);
 573     jni()-&gt;GetStringUTFRegion(str.as_jstring(), 0, length, result);
 574     return result;
 575   }
 576 }
 577 
 578 #define DO_THROW(name)                             \
 579 void JVMCIEnv::throw_##name(const char* msg) {     \
 580   if (is_hotspot()) {                              \
 581     JavaThread* THREAD = JavaThread::current();    \
 582     THROW_MSG(HotSpotJVMCI::name::symbol(), msg);  \
 583   } else {                                         \
 584     JNIAccessMark jni(this);                       \
 585     jni()-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg); \
 586   }                                                \
 587 }
 588 
 589 DO_THROW(InternalError)
 590 DO_THROW(ArrayIndexOutOfBoundsException)
 591 DO_THROW(IllegalStateException)
 592 DO_THROW(NullPointerException)
 593 DO_THROW(IllegalArgumentException)
 594 DO_THROW(InvalidInstalledCodeException)
 595 DO_THROW(UnsatisfiedLinkError)
 596 DO_THROW(UnsupportedOperationException)
 597 DO_THROW(ClassNotFoundException)
 598 
 599 #undef DO_THROW
 600 
 601 void JVMCIEnv::fthrow_error(const char* file, int line, const char* format, ...) {
 602   const int max_msg_size = 1024;
 603   va_list ap;
 604   va_start(ap, format);
 605   char msg[max_msg_size];
 606   vsnprintf(msg, max_msg_size, format, ap);
 607   msg[max_msg_size-1] = &#39;\0&#39;;
 608   va_end(ap);
 609   JavaThread* THREAD = JavaThread::current();
 610   if (is_hotspot()) {
 611     Handle h_loader = Handle();
 612     Handle h_protection_domain = Handle();
 613     Exceptions::_throw_msg(THREAD, file, line, vmSymbols::jdk_vm_ci_common_JVMCIError(), msg, h_loader, h_protection_domain);
 614   } else {
 615     JNIAccessMark jni(this, THREAD);
 616     jni()-&gt;ThrowNew(JNIJVMCI::JVMCIError::clazz(), msg);
 617   }
 618 }
 619 
 620 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_compileMethod (JVMCIObject runtime, JVMCIObject method, int entry_bci,
 621                                                               jlong compile_state, int id) {
 622   if (is_hotspot()) {
 623     Thread* THREAD = Thread::current();
 624     JavaCallArguments jargs;
 625     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 626     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(method)));
 627     jargs.push_int(entry_bci);
 628     jargs.push_long(compile_state);
 629     jargs.push_int(id);
 630     JavaValue result(T_OBJECT);
 631     JavaCalls::call_special(&amp;result,
 632                             HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),
 633                             vmSymbols::compileMethod_name(),
 634                             vmSymbols::compileMethod_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 635     return wrap((oop) result.get_jobject());
 636   } else {
 637     JNIAccessMark jni(this);
 638     jobject result = jni()-&gt;CallNonvirtualObjectMethod(runtime.as_jobject(),
 639                                                      JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
 640                                                      JNIJVMCI::HotSpotJVMCIRuntime::compileMethod_method(),
 641                                                      method.as_jobject(), entry_bci, compile_state, id);
 642     if (jni()-&gt;ExceptionCheck()) {
 643       return JVMCIObject();
 644     }
 645     return wrap(result);
 646   }
 647 }
 648 
 649 void JVMCIEnv::call_HotSpotJVMCIRuntime_bootstrapFinished (JVMCIObject runtime, JVMCIEnv* JVMCIENV) {
 650   if (is_hotspot()) {
 651     Thread* THREAD = Thread::current();
 652     JavaCallArguments jargs;
 653     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 654     JavaValue result(T_VOID);
 655     JavaCalls::call_special(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::bootstrapFinished_name(), vmSymbols::void_method_signature(), &amp;jargs, CHECK);
 656   } else {
 657     JNIAccessMark jni(this);
 658     jni()-&gt;CallNonvirtualVoidMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::bootstrapFinished_method());
 659 
 660   }
 661 }
 662 
 663 void JVMCIEnv::call_HotSpotJVMCIRuntime_shutdown (JVMCIObject runtime) {
 664   HandleMark hm;
 665   JavaThread* THREAD = JavaThread::current();
 666   if (is_hotspot()) {
 667     JavaCallArguments jargs;
 668     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 669     JavaValue result(T_VOID);
 670     JavaCalls::call_special(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::shutdown_name(), vmSymbols::void_method_signature(), &amp;jargs, THREAD);
 671   } else {
 672     JNIAccessMark jni(this, THREAD);
 673     jni()-&gt;CallNonvirtualVoidMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::shutdown_method());
 674   }
 675   if (has_pending_exception()) {
 676     // This should never happen as HotSpotJVMCIRuntime.shutdown() should
 677     // handle all exceptions.
 678     describe_pending_exception(true);
 679   }
 680 }
 681 
 682 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_runtime (JVMCIEnv* JVMCIENV) {
 683   JavaThread* THREAD = JavaThread::current();
 684   if (is_hotspot()) {
 685     JavaCallArguments jargs;
 686     JavaValue result(T_OBJECT);
 687     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::runtime_name(), vmSymbols::runtime_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 688     return wrap((oop) result.get_jobject());
 689   } else {
 690     JNIAccessMark jni(this, THREAD);
 691     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::runtime_method());
 692     if (jni()-&gt;ExceptionCheck()) {
 693       return JVMCIObject();
 694     }
 695     return wrap(result);
 696   }
 697 }
 698 
 699 JVMCIObject JVMCIEnv::call_JVMCI_getRuntime (JVMCIEnv* JVMCIENV) {
 700   JavaThread* THREAD = JavaThread::current();
 701   if (is_hotspot()) {
 702     JavaCallArguments jargs;
 703     JavaValue result(T_OBJECT);
 704     JavaCalls::call_static(&amp;result, HotSpotJVMCI::JVMCI::klass(), vmSymbols::getRuntime_name(), vmSymbols::getRuntime_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 705     return wrap((oop) result.get_jobject());
 706   } else {
 707     JNIAccessMark jni(this, THREAD);
 708     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JVMCI::clazz(), JNIJVMCI::JVMCI::getRuntime_method());
 709     if (jni()-&gt;ExceptionCheck()) {
 710       return JVMCIObject();
 711     }
 712     return wrap(result);
 713   }
 714 }
 715 
 716 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_getCompiler (JVMCIObject runtime, JVMCIEnv* JVMCIENV) {
 717   JavaThread* THREAD = JavaThread::current();
 718   if (is_hotspot()) {
 719     JavaCallArguments jargs;
 720     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 721     JavaValue result(T_OBJECT);
 722     JavaCalls::call_virtual(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::getCompiler_name(), vmSymbols::getCompiler_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 723     return wrap((oop) result.get_jobject());
 724   } else {
 725     JNIAccessMark jni(this, THREAD);
 726     jobject result = jni()-&gt;CallObjectMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::getCompiler_method());
 727     if (jni()-&gt;ExceptionCheck()) {
 728       return JVMCIObject();
 729     }
 730     return wrap(result);
 731   }
 732 }
 733 
 734 
 735 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_callToString(JVMCIObject object, JVMCIEnv* JVMCIENV) {
 736   JavaThread* THREAD = JavaThread::current();
 737   if (is_hotspot()) {
 738     JavaCallArguments jargs;
 739     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(object)));
 740     JavaValue result(T_OBJECT);
 741     JavaCalls::call_static(&amp;result,
 742                            HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),
 743                            vmSymbols::callToString_name(),
 744                            vmSymbols::callToString_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 745     return wrap((oop) result.get_jobject());
 746   } else {
 747     JNIAccessMark jni(this, THREAD);
 748     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
 749                                                      JNIJVMCI::HotSpotJVMCIRuntime::callToString_method(),
 750                                                      object.as_jobject());
 751     if (jni()-&gt;ExceptionCheck()) {
 752       return JVMCIObject();
 753     }
 754     return wrap(result);
 755   }
 756 }
 757 
 758 
 759 JVMCIObject JVMCIEnv::call_PrimitiveConstant_forTypeChar(jchar kind, jlong value, JVMCI_TRAPS) {
 760   JavaThread* THREAD = JavaThread::current();
 761   if (is_hotspot()) {
 762     JavaCallArguments jargs;
 763     jargs.push_int(kind);
 764     jargs.push_long(value);
 765     JavaValue result(T_OBJECT);
 766     JavaCalls::call_static(&amp;result,
 767                            HotSpotJVMCI::PrimitiveConstant::klass(),
 768                            vmSymbols::forTypeChar_name(),
 769                            vmSymbols::forTypeChar_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 770     return wrap((oop) result.get_jobject());
 771   } else {
 772     JNIAccessMark jni(this, THREAD);
 773     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::PrimitiveConstant::clazz(),
 774                                                      JNIJVMCI::PrimitiveConstant::forTypeChar_method(),
 775                                                      kind, value);
 776     if (jni()-&gt;ExceptionCheck()) {
 777       return JVMCIObject();
 778     }
 779     return wrap(result);
 780   }
 781 }
 782 
 783 JVMCIObject JVMCIEnv::call_JavaConstant_forFloat(float value, JVMCI_TRAPS) {
 784   JavaThread* THREAD = JavaThread::current();
 785   if (is_hotspot()) {
 786     JavaCallArguments jargs;
 787     jargs.push_float(value);
 788     JavaValue result(T_OBJECT);
 789     JavaCalls::call_static(&amp;result,
 790                            HotSpotJVMCI::JavaConstant::klass(),
 791                            vmSymbols::forFloat_name(),
 792                            vmSymbols::forFloat_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 793     return wrap((oop) result.get_jobject());
 794   } else {
 795     JNIAccessMark jni(this, THREAD);
 796     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),
 797                                                      JNIJVMCI::JavaConstant::forFloat_method(),
 798                                                      value);
 799     if (jni()-&gt;ExceptionCheck()) {
 800       return JVMCIObject();
 801     }
 802     return wrap(result);
 803   }
 804 }
 805 
 806 JVMCIObject JVMCIEnv::call_JavaConstant_forDouble(double value, JVMCI_TRAPS) {
 807   JavaThread* THREAD = JavaThread::current();
 808   if (is_hotspot()) {
 809     JavaCallArguments jargs;
 810     jargs.push_double(value);
 811     JavaValue result(T_OBJECT);
 812     JavaCalls::call_static(&amp;result,
 813                            HotSpotJVMCI::JavaConstant::klass(),
 814                            vmSymbols::forDouble_name(),
 815                            vmSymbols::forDouble_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 816     return wrap((oop) result.get_jobject());
 817   } else {
 818     JNIAccessMark jni(this, THREAD);
 819     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),
 820                                                      JNIJVMCI::JavaConstant::forDouble_method(),
 821                                                      value);
 822     if (jni()-&gt;ExceptionCheck()) {
 823       return JVMCIObject();
 824     }
 825     return wrap(result);
 826   }
 827 }
 828 
 829 JVMCIObject JVMCIEnv::get_jvmci_primitive_type(BasicType type) {
 830   JVMCIObjectArray primitives = get_HotSpotResolvedPrimitiveType_primitives();
 831   JVMCIObject result = get_object_at(primitives, type);
 832   return result;
 833 }
 834 
 835 JVMCIObject JVMCIEnv::new_StackTraceElement(const methodHandle&amp; method, int bci, JVMCI_TRAPS) {
 836   JavaThread* THREAD = JavaThread::current();
 837   Symbol* file_name_sym;
 838   int line_number;
 839   java_lang_StackTraceElement::decode(method, bci, file_name_sym, line_number, CHECK_(JVMCIObject()));
 840 
 841   Symbol* method_name_sym = method-&gt;name();
 842   InstanceKlass* holder = method-&gt;method_holder();
 843   const char* declaring_class_str = holder-&gt;external_name();
 844 
 845   if (is_hotspot()) {
 846     HotSpotJVMCI::StackTraceElement::klass()-&gt;initialize(CHECK_(JVMCIObject()));
 847     oop objOop = HotSpotJVMCI::StackTraceElement::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
 848     Handle obj = Handle(THREAD, objOop);
 849 
 850     oop declaring_class = StringTable::intern((char*) declaring_class_str, CHECK_(JVMCIObject()));
 851     HotSpotJVMCI::StackTraceElement::set_declaringClass(this, obj(), declaring_class);
 852 
 853     oop method_name = StringTable::intern(method_name_sym, CHECK_(JVMCIObject()));
 854     HotSpotJVMCI::StackTraceElement::set_methodName(this, obj(), method_name);
 855 
 856     if (file_name_sym != NULL) {
 857       oop file_name = StringTable::intern(file_name_sym, CHECK_(JVMCIObject()));
 858       HotSpotJVMCI::StackTraceElement::set_fileName(this, obj(), file_name);
 859     }
 860     HotSpotJVMCI::StackTraceElement::set_lineNumber(this, obj(), line_number);
 861     return wrap(obj());
 862   } else {
 863     JNIAccessMark jni(this, THREAD);
 864     jobject declaring_class = jni()-&gt;NewStringUTF(declaring_class_str);
 865     if (jni()-&gt;ExceptionCheck()) {
 866       return JVMCIObject();
 867     }
 868     jobject method_name = jni()-&gt;NewStringUTF(method_name_sym-&gt;as_C_string());
 869     if (jni()-&gt;ExceptionCheck()) {
 870       return JVMCIObject();
 871     }
 872     jobject file_name = NULL;
 873     if (file_name_sym != NULL) {
 874       file_name = jni()-&gt;NewStringUTF(file_name_sym-&gt;as_C_string());
 875       if (jni()-&gt;ExceptionCheck()) {
 876         return JVMCIObject();
 877       }
 878     }
 879 
 880     jobject result = jni()-&gt;NewObject(JNIJVMCI::StackTraceElement::clazz(),
 881                                       JNIJVMCI::StackTraceElement::constructor(),
 882                                       declaring_class, method_name, file_name, line_number);
 883     return wrap(result);
 884   }
 885 }
 886 
 887 JVMCIObject JVMCIEnv::new_HotSpotNmethod(const methodHandle&amp; method, const char* name, jboolean isDefault, jlong compileId, JVMCI_TRAPS) {
 888   JavaThread* THREAD = JavaThread::current();
 889 
 890   JVMCIObject methodObject = get_jvmci_method(method, JVMCI_CHECK_(JVMCIObject()));
 891 
 892   if (is_hotspot()) {
 893     InstanceKlass* ik = InstanceKlass::cast(HotSpotJVMCI::HotSpotNmethod::klass());
 894     if (ik-&gt;should_be_initialized()) {
 895       ik-&gt;initialize(CHECK_(JVMCIObject()));
 896     }
 897     oop obj = ik-&gt;allocate_instance(CHECK_(JVMCIObject()));
 898     Handle obj_h(THREAD, obj);
 899     Handle nameStr = java_lang_String::create_from_str(name, CHECK_(JVMCIObject()));
 900 
 901     // Call constructor
 902     JavaCallArguments jargs;
 903     jargs.push_oop(obj_h);
 904     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(methodObject)));
 905     jargs.push_oop(nameStr);
 906     jargs.push_int(isDefault);
 907     jargs.push_long(compileId);
 908     JavaValue result(T_VOID);
 909     JavaCalls::call_special(&amp;result, ik,
 910                             vmSymbols::object_initializer_name(),
 911                             vmSymbols::method_string_bool_long_signature(),
 912                             &amp;jargs, CHECK_(JVMCIObject()));
 913     return wrap(obj_h());
 914   } else {
 915     JNIAccessMark jni(this, THREAD);
 916     jobject nameStr = name == NULL ? NULL : jni()-&gt;NewStringUTF(name);
 917     if (jni()-&gt;ExceptionCheck()) {
 918       return JVMCIObject();
 919     }
 920 
 921     jobject result = jni()-&gt;NewObject(JNIJVMCI::HotSpotNmethod::clazz(),
 922                                       JNIJVMCI::HotSpotNmethod::constructor(),
 923                                       methodObject.as_jobject(), nameStr, isDefault);
 924     return wrap(result);
 925   }
 926 }
 927 
 928 JVMCIObject JVMCIEnv::make_local(JVMCIObject object) {
 929   if (object.is_null()) {
 930     return JVMCIObject();
 931   }
 932   if (is_hotspot()) {
 933     return wrap(JNIHandles::make_local(HotSpotJVMCI::resolve(object)));
 934   } else {
 935     JNIAccessMark jni(this);
 936     return wrap(jni()-&gt;NewLocalRef(object.as_jobject()));
 937   }
 938 }
 939 
 940 JVMCIObject JVMCIEnv::make_global(JVMCIObject object) {
 941   if (object.is_null()) {
 942     return JVMCIObject();
 943   }
 944   if (is_hotspot()) {
 945     return wrap(JNIHandles::make_global(Handle(Thread::current(), HotSpotJVMCI::resolve(object))));
 946   } else {
 947     JNIAccessMark jni(this);
 948     return wrap(jni()-&gt;NewGlobalRef(object.as_jobject()));
 949   }
 950 }
 951 
 952 void JVMCIEnv::destroy_local(JVMCIObject object) {
 953   if (is_hotspot()) {
 954     JNIHandles::destroy_local(object.as_jobject());
 955   } else {
 956     JNIAccessMark jni(this);
 957     jni()-&gt;DeleteLocalRef(object.as_jobject());
 958   }
 959 }
 960 
 961 void JVMCIEnv::destroy_global(JVMCIObject object) {
 962   if (is_hotspot()) {
 963     JNIHandles::destroy_global(object.as_jobject());
 964   } else {
 965     JNIAccessMark jni(this);
 966     jni()-&gt;DeleteGlobalRef(object.as_jobject());
 967   }
 968 }
 969 
 970 const char* JVMCIEnv::klass_name(JVMCIObject object) {
 971   if (is_hotspot()) {
 972     return HotSpotJVMCI::resolve(object)-&gt;klass()-&gt;signature_name();
 973   } else {
 974     JVMCIObject name;
 975     {
 976       JNIAccessMark jni(this);
 977       jclass jcl = jni()-&gt;GetObjectClass(object.as_jobject());
 978       jobject result = jni()-&gt;CallObjectMethod(jcl, JNIJVMCI::Class_getName_method());
 979       name = JVMCIObject::create(result, is_hotspot());
 980     }
 981     return as_utf8_string(name);
 982   }
 983 }
 984 
 985 JVMCIObject JVMCIEnv::get_jvmci_method(const methodHandle&amp; method, JVMCI_TRAPS) {
 986   JVMCIObject method_object;
 987   if (method() == NULL) {
 988     return method_object;
 989   }
 990 
 991   Thread* THREAD = Thread::current();
 992   jmetadata handle = _runtime-&gt;allocate_handle(method);
 993   jboolean exception = false;
 994   if (is_hotspot()) {
 995     JavaValue result(T_OBJECT);
 996     JavaCallArguments args;
 997     args.push_long((jlong) handle);
 998     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotResolvedJavaMethodImpl::klass(),
 999                            vmSymbols::fromMetaspace_name(),
1000                            vmSymbols::method_fromMetaspace_signature(), &amp;args, THREAD);
1001     if (HAS_PENDING_EXCEPTION) {
1002       exception = true;
1003     } else {
1004       method_object = wrap((oop)result.get_jobject());
1005     }
1006   } else {
1007     JNIAccessMark jni(this);
1008     method_object = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedJavaMethodImpl::clazz(),
1009                                                                   JNIJVMCI::HotSpotResolvedJavaMethodImpl_fromMetaspace_method(),
1010                                                                   (jlong) handle));
1011     exception = jni()-&gt;ExceptionCheck();
1012   }
1013 
1014   if (exception) {
1015     _runtime-&gt;release_handle(handle);
1016     return JVMCIObject();
1017   }
1018 
1019   assert(asMethod(method_object) == method(), &quot;must be&quot;);
1020   if (get_HotSpotResolvedJavaMethodImpl_metadataHandle(method_object) != (jlong) handle) {
1021     _runtime-&gt;release_handle(handle);
1022   }
1023   assert(!method_object.is_null(), &quot;must be&quot;);
1024   return method_object;
1025 }
1026 
1027 JVMCIObject JVMCIEnv::get_jvmci_type(const JVMCIKlassHandle&amp; klass, JVMCI_TRAPS) {
1028   JVMCIObject type;
1029   if (klass.is_null()) {
1030     return type;
1031   }
1032 
1033   jlong pointer = (jlong) klass();
1034   JavaThread* THREAD = JavaThread::current();
1035   JVMCIObject signature = create_string(klass-&gt;signature_name(), JVMCI_CHECK_(JVMCIObject()));
1036   jboolean exception = false;
1037   if (is_hotspot()) {
1038     JavaValue result(T_OBJECT);
1039     JavaCallArguments args;
1040     args.push_long(pointer);
1041     args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(signature)));
1042     JavaCalls::call_static(&amp;result,
1043                            HotSpotJVMCI::HotSpotResolvedObjectTypeImpl::klass(),
1044                            vmSymbols::fromMetaspace_name(),
1045                            vmSymbols::klass_fromMetaspace_signature(), &amp;args, THREAD);
1046 
1047     if (HAS_PENDING_EXCEPTION) {
1048       exception = true;
1049     } else {
1050       type = wrap((oop)result.get_jobject());
1051     }
1052   } else {
1053     JNIAccessMark jni(this, THREAD);
1054 
1055     HandleMark hm(THREAD);
1056     type = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedObjectTypeImpl::clazz(),
1057                                                         JNIJVMCI::HotSpotResolvedObjectTypeImpl_fromMetaspace_method(),
1058                                                         pointer, signature.as_jstring()));
1059     exception = jni()-&gt;ExceptionCheck();
1060   }
1061   if (exception) {
1062     return JVMCIObject();
1063   }
1064 
1065   assert(type.is_non_null(), &quot;must have result&quot;);
1066   return type;
1067 }
1068 
1069 JVMCIObject JVMCIEnv::get_jvmci_constant_pool(const constantPoolHandle&amp; cp, JVMCI_TRAPS) {
1070   JVMCIObject cp_object;
1071   jmetadata handle = _runtime-&gt;allocate_handle(cp);
1072   jboolean exception = false;
1073   JavaThread* THREAD = JavaThread::current();
1074   if (is_hotspot()) {
1075     JavaValue result(T_OBJECT);
1076     JavaCallArguments args;
1077     args.push_long((jlong) handle);
1078     JavaCalls::call_static(&amp;result,
1079                            HotSpotJVMCI::HotSpotConstantPool::klass(),
1080                            vmSymbols::fromMetaspace_name(),
1081                            vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, THREAD);
1082     if (HAS_PENDING_EXCEPTION) {
1083       exception = true;
1084     } else {
1085       cp_object = wrap((oop)result.get_jobject());
1086     }
1087   } else {
1088     JNIAccessMark jni(this, THREAD);
1089     cp_object = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotConstantPool::clazz(),
1090                                                              JNIJVMCI::HotSpotConstantPool_fromMetaspace_method(),
1091                                                              (jlong) handle));
1092     exception = jni()-&gt;ExceptionCheck();
1093   }
1094 
1095   if (exception) {
1096     _runtime-&gt;release_handle(handle);
1097     return JVMCIObject();
1098   }
1099 
1100   assert(!cp_object.is_null(), &quot;must be&quot;);
1101   // Constant pools aren&#39;t cached so this is always a newly created object using the handle
1102   assert(get_HotSpotConstantPool_metadataHandle(cp_object) == (jlong) handle, &quot;must use same handle&quot;);
1103   return cp_object;
1104 }
1105 
1106 JVMCIPrimitiveArray JVMCIEnv::new_booleanArray(int length, JVMCI_TRAPS) {
1107   JavaThread* THREAD = JavaThread::current();
1108   if (is_hotspot()) {
1109     typeArrayOop result = oopFactory::new_boolArray(length, CHECK_(JVMCIObject()));
1110     return wrap(result);
1111   } else {
1112     JNIAccessMark jni(this, THREAD);
1113     jbooleanArray result = jni()-&gt;NewBooleanArray(length);
1114     return wrap(result);
1115   }
1116 }
1117 
1118 JVMCIPrimitiveArray JVMCIEnv::new_byteArray(int length, JVMCI_TRAPS) {
1119   JavaThread* THREAD = JavaThread::current();
1120   if (is_hotspot()) {
1121     typeArrayOop result = oopFactory::new_byteArray(length, CHECK_(JVMCIObject()));
1122     return wrap(result);
1123   } else {
1124     JNIAccessMark jni(this, THREAD);
1125     jbyteArray result = jni()-&gt;NewByteArray(length);
1126     return wrap(result);
1127   }
1128 }
1129 
1130 JVMCIObjectArray JVMCIEnv::new_byte_array_array(int length, JVMCI_TRAPS) {
1131   JavaThread* THREAD = JavaThread::current();
1132   if (is_hotspot()) {
1133     Klass* byteArrayArrayKlass = TypeArrayKlass::cast(Universe::byteArrayKlassObj  ())-&gt;array_klass(CHECK_(JVMCIObject()));
1134     objArrayOop result = ObjArrayKlass::cast(byteArrayArrayKlass) -&gt;allocate(length, CHECK_(JVMCIObject()));
1135     return wrap(result);
1136   } else {
1137     JNIAccessMark jni(this, THREAD);
1138     jobjectArray result = jni()-&gt;NewObjectArray(length, JNIJVMCI::byte_array(), NULL);
1139     return wrap(result);
1140   }
1141 }
1142 
1143 JVMCIPrimitiveArray JVMCIEnv::new_intArray(int length, JVMCI_TRAPS) {
1144   JavaThread* THREAD = JavaThread::current();
1145   if (is_hotspot()) {
1146     typeArrayOop result = oopFactory::new_intArray(length, CHECK_(JVMCIObject()));
1147     return wrap(result);
1148   } else {
1149     JNIAccessMark jni(this, THREAD);
1150     jintArray result = jni()-&gt;NewIntArray(length);
1151     return wrap(result);
1152   }
1153 }
1154 
1155 JVMCIPrimitiveArray JVMCIEnv::new_longArray(int length, JVMCI_TRAPS) {
1156   JavaThread* THREAD = JavaThread::current();
1157   if (is_hotspot()) {
1158     typeArrayOop result = oopFactory::new_longArray(length, CHECK_(JVMCIObject()));
1159     return wrap(result);
1160   } else {
1161     JNIAccessMark jni(this, THREAD);
1162     jlongArray result = jni()-&gt;NewLongArray(length);
1163     return wrap(result);
1164   }
1165 }
1166 
1167 JVMCIObject JVMCIEnv::new_VMField(JVMCIObject name, JVMCIObject type, jlong offset, jlong address, JVMCIObject value, JVMCI_TRAPS) {
1168   JavaThread* THREAD = JavaThread::current();
1169   if (is_hotspot()) {
1170     HotSpotJVMCI::VMField::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1171     oop obj = HotSpotJVMCI::VMField::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1172     HotSpotJVMCI::VMField::set_name(this, obj, HotSpotJVMCI::resolve(name));
1173     HotSpotJVMCI::VMField::set_type(this, obj, HotSpotJVMCI::resolve(type));
1174     HotSpotJVMCI::VMField::set_offset(this, obj, offset);
1175     HotSpotJVMCI::VMField::set_address(this, obj, address);
1176     HotSpotJVMCI::VMField::set_value(this, obj, HotSpotJVMCI::resolve(value));
1177     return wrap(obj);
1178   } else {
1179     JNIAccessMark jni(this, THREAD);
1180     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMField::clazz(),
1181                                     JNIJVMCI::VMField::constructor(),
1182                                     get_jobject(name), get_jobject(type), offset, address, get_jobject(value));
1183     return wrap(result);
1184   }
1185 }
1186 
1187 JVMCIObject JVMCIEnv::new_VMFlag(JVMCIObject name, JVMCIObject type, JVMCIObject value, JVMCI_TRAPS) {
1188   JavaThread* THREAD = JavaThread::current();
1189   if (is_hotspot()) {
1190     HotSpotJVMCI::VMFlag::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1191     oop obj = HotSpotJVMCI::VMFlag::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1192     HotSpotJVMCI::VMFlag::set_name(this, obj, HotSpotJVMCI::resolve(name));
1193     HotSpotJVMCI::VMFlag::set_type(this, obj, HotSpotJVMCI::resolve(type));
1194     HotSpotJVMCI::VMFlag::set_value(this, obj, HotSpotJVMCI::resolve(value));
1195     return wrap(obj);
1196   } else {
1197     JNIAccessMark jni(this, THREAD);
1198     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMFlag::clazz(),
1199                                     JNIJVMCI::VMFlag::constructor(),
1200                                     get_jobject(name), get_jobject(type), get_jobject(value));
1201     return wrap(result);
1202   }
1203 }
1204 
1205 JVMCIObject JVMCIEnv::new_VMIntrinsicMethod(JVMCIObject declaringClass, JVMCIObject name, JVMCIObject descriptor, int id, JVMCI_TRAPS) {
1206   JavaThread* THREAD = JavaThread::current();
1207   if (is_hotspot()) {
1208     HotSpotJVMCI::VMIntrinsicMethod::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1209     oop obj = HotSpotJVMCI::VMIntrinsicMethod::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1210     HotSpotJVMCI::VMIntrinsicMethod::set_declaringClass(this, obj, HotSpotJVMCI::resolve(declaringClass));
1211     HotSpotJVMCI::VMIntrinsicMethod::set_name(this, obj, HotSpotJVMCI::resolve(name));
1212     HotSpotJVMCI::VMIntrinsicMethod::set_descriptor(this, obj, HotSpotJVMCI::resolve(descriptor));
1213     HotSpotJVMCI::VMIntrinsicMethod::set_id(this, obj, id);
1214     return wrap(obj);
1215   } else {
1216     JNIAccessMark jni(this, THREAD);
1217     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMIntrinsicMethod::clazz(),
1218                                     JNIJVMCI::VMIntrinsicMethod::constructor(),
1219                                     get_jobject(declaringClass), get_jobject(name), get_jobject(descriptor), id);
1220     return wrap(result);
1221   }
1222 }
1223 
1224 JVMCIObject JVMCIEnv::new_HotSpotStackFrameReference(JVMCI_TRAPS) {
1225   if (is_hotspot()) {
1226     JavaThread* THREAD = JavaThread::current();
1227     HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1228     oop obj = HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1229     return wrap(obj);
1230   } else {
1231     ShouldNotReachHere();
1232     return JVMCIObject();
1233   }
1234 }
1235 JVMCIObject JVMCIEnv::new_JVMCIError(JVMCI_TRAPS) {
1236   if (is_hotspot()) {
1237     JavaThread* THREAD = JavaThread::current();
1238     HotSpotJVMCI::JVMCIError::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1239     oop obj = HotSpotJVMCI::JVMCIError::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1240     return wrap(obj);
1241   } else {
1242     ShouldNotReachHere();
1243     return JVMCIObject();
1244   }
1245 }
1246 
1247 
1248 JVMCIObject JVMCIEnv::get_object_constant(oop objOop, bool compressed, bool dont_register) {
1249   JavaThread* THREAD = JavaThread::current();
1250   Handle obj = Handle(THREAD, objOop);
1251   if (obj.is_null()) {
1252     return JVMCIObject();
1253   }
1254   if (is_hotspot()) {
1255     HotSpotJVMCI::DirectHotSpotObjectConstantImpl::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1256     oop constant = HotSpotJVMCI::DirectHotSpotObjectConstantImpl::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1257     HotSpotJVMCI::DirectHotSpotObjectConstantImpl::set_object(this, constant, obj());
1258     HotSpotJVMCI::HotSpotObjectConstantImpl::set_compressed(this, constant, compressed);
1259     return wrap(constant);
1260   } else {
1261     jlong handle = make_handle(obj);
1262     JNIAccessMark jni(this, THREAD);
1263     jobject result = jni()-&gt;NewObject(JNIJVMCI::IndirectHotSpotObjectConstantImpl::clazz(),
1264                                       JNIJVMCI::IndirectHotSpotObjectConstantImpl::constructor(),
1265                                       handle, compressed, dont_register);
1266     return wrap(result);
1267   }
1268 }
1269 
1270 
1271 Handle JVMCIEnv::asConstant(JVMCIObject constant, JVMCI_TRAPS) {
1272   if (constant.is_null()) {
1273     return Handle();
1274   }
1275   JavaThread* THREAD = JavaThread::current();
1276   if (is_hotspot()) {
1277     assert(HotSpotJVMCI::DirectHotSpotObjectConstantImpl::is_instance(this, constant), &quot;wrong type&quot;);
1278     oop obj = HotSpotJVMCI::DirectHotSpotObjectConstantImpl::object(this, HotSpotJVMCI::resolve(constant));
1279     return Handle(THREAD, obj);
1280   } else if (isa_IndirectHotSpotObjectConstantImpl(constant)) {
1281     jlong object_handle = get_IndirectHotSpotObjectConstantImpl_objectHandle(constant);
1282     if (object_handle == 0L) {
1283       JVMCI_THROW_MSG_(NullPointerException, &quot;Foreign object reference has been cleared&quot;, Handle());
1284     }
1285     oop result = resolve_handle(object_handle);
1286     if (result == NULL) {
1287       JVMCI_THROW_MSG_(InternalError, &quot;Constant was unexpectedly NULL&quot;, Handle());
1288     }
1289     return Handle(THREAD, result);
1290   } else {
1291     JVMCI_THROW_MSG_(IllegalArgumentException, &quot;DirectHotSpotObjectConstantImpl shouldn&#39;t reach JVMCI in SVM mode&quot;, Handle());
1292   }
1293 }
1294 
1295 JVMCIObject JVMCIEnv::wrap(jobject object) {
1296   return JVMCIObject::create(object, is_hotspot());
1297 }
1298 
1299 jlong JVMCIEnv::make_handle(const Handle&amp; obj) {
1300   assert(!obj.is_null(), &quot;should only create handle for non-NULL oops&quot;);
1301   jobject handle = _runtime-&gt;make_global(obj);
1302   return (jlong) handle;
1303 }
1304 
1305 oop JVMCIEnv::resolve_handle(jlong objectHandle) {
1306   assert(objectHandle != 0, &quot;should be a valid handle&quot;);
1307   oop obj = *((oopDesc**)objectHandle);
1308   if (obj != NULL) {
1309     oopDesc::verify(obj);
1310   }
1311   return obj;
1312 }
1313 
1314 JVMCIObject JVMCIEnv::create_string(const char* str, JVMCI_TRAPS) {
1315   JavaThread* THREAD = JavaThread::current();
1316   if (is_hotspot()) {
1317     Handle result = java_lang_String::create_from_str(str, CHECK_(JVMCIObject()));
1318     return HotSpotJVMCI::wrap(result());
1319   } else {
1320     jobject result;
1321     jboolean exception = false;
1322     {
1323       JNIAccessMark jni(this, THREAD);
1324       result = jni()-&gt;NewStringUTF(str);
1325       exception = jni()-&gt;ExceptionCheck();
1326     }
1327     return wrap(result);
1328   }
1329 }
1330 
1331 bool JVMCIEnv::equals(JVMCIObject a, JVMCIObject b) {
1332   if (is_hotspot()) {
1333     return HotSpotJVMCI::resolve(a) == HotSpotJVMCI::resolve(b);
1334   } else {
1335     JNIAccessMark jni(this);
1336     return jni()-&gt;IsSameObject(a.as_jobject(), b.as_jobject()) != 0;
1337   }
1338 }
1339 
1340 BasicType JVMCIEnv::kindToBasicType(JVMCIObject kind, JVMCI_TRAPS) {
1341   if (kind.is_null()) {
1342     JVMCI_THROW_(NullPointerException, T_ILLEGAL);
1343   }
1344   jchar ch = get_JavaKind_typeChar(kind);
1345   switch(ch) {
1346     case &#39;Z&#39;: return T_BOOLEAN;
1347     case &#39;B&#39;: return T_BYTE;
1348     case &#39;S&#39;: return T_SHORT;
1349     case &#39;C&#39;: return T_CHAR;
1350     case &#39;I&#39;: return T_INT;
1351     case &#39;F&#39;: return T_FLOAT;
1352     case &#39;J&#39;: return T_LONG;
1353     case &#39;D&#39;: return T_DOUBLE;
1354     case &#39;A&#39;: return T_OBJECT;
1355     case &#39;-&#39;: return T_ILLEGAL;
1356     default:
1357       JVMCI_ERROR_(T_ILLEGAL, &quot;unexpected Kind: %c&quot;, ch);
1358   }
1359 }
1360 
1361 void JVMCIEnv::initialize_installed_code(JVMCIObject installed_code, CodeBlob* cb, JVMCI_TRAPS) {
1362   // Ensure that all updates to the InstalledCode fields are consistent.
1363   if (get_InstalledCode_address(installed_code) != 0) {
1364     JVMCI_THROW_MSG(InternalError, &quot;InstalledCode instance already in use&quot;);
1365   }
1366   if (!isa_HotSpotInstalledCode(installed_code)) {
1367     JVMCI_THROW_MSG(InternalError, &quot;InstalledCode instance must be a subclass of HotSpotInstalledCode&quot;);
1368   }
1369 
1370   // Ignore the version which can stay at 0
1371   if (cb-&gt;is_nmethod()) {
1372     nmethod* nm = cb-&gt;as_nmethod_or_null();
1373     if (!nm-&gt;is_alive()) {
1374       JVMCI_THROW_MSG(InternalError, &quot;nmethod has been reclaimed&quot;);
1375     }
1376     if (nm-&gt;is_in_use()) {
1377       set_InstalledCode_entryPoint(installed_code, (jlong) nm-&gt;verified_entry_point());
1378     }
1379   } else {
1380     set_InstalledCode_entryPoint(installed_code, (jlong) cb-&gt;code_begin());
1381   }
1382   set_InstalledCode_address(installed_code, (jlong) cb);
1383   set_HotSpotInstalledCode_size(installed_code, cb-&gt;size());
1384   set_HotSpotInstalledCode_codeStart(installed_code, (jlong) cb-&gt;code_begin());
1385   set_HotSpotInstalledCode_codeSize(installed_code, cb-&gt;code_size());
1386 }
1387 
1388 
1389 void JVMCIEnv::invalidate_nmethod_mirror(JVMCIObject mirror, JVMCI_TRAPS) {
1390   if (mirror.is_null()) {
1391     JVMCI_THROW(NullPointerException);
1392   }
1393 
1394   nmethodLocker locker;
1395   nmethod* nm = JVMCIENV-&gt;get_nmethod(mirror, locker);
1396   if (nm == NULL) {
1397     // Nothing to do
1398     return;
1399   }
1400 
1401   Thread* THREAD = Thread::current();
1402   if (!mirror.is_hotspot() &amp;&amp; !THREAD-&gt;is_Java_thread()) {
1403     // Calling back into native might cause the execution to block, so only allow this when calling
1404     // from a JavaThread, which is the normal case anyway.
1405     JVMCI_THROW_MSG(IllegalArgumentException,
1406                     &quot;Cannot invalidate HotSpotNmethod object in shared library VM heap from non-JavaThread&quot;);
1407   }
1408 
1409   nmethodLocker nml(nm);
1410   if (nm-&gt;is_alive()) {
1411     // Invalidating the HotSpotNmethod means we want the nmethod to be deoptimized.
1412     Deoptimization::deoptimize_all_marked(nm);
1413   }
1414 
1415   // A HotSpotNmethod instance can only reference a single nmethod
1416   // during its lifetime so simply clear it here.
1417   set_InstalledCode_address(mirror, 0);
1418 }
1419 
1420 Klass* JVMCIEnv::asKlass(JVMCIObject obj) {
1421   return (Klass*) get_HotSpotResolvedObjectTypeImpl_metadataPointer(obj);
1422 }
1423 
1424 Method* JVMCIEnv::asMethod(JVMCIObject obj) {
1425   Method** metadataHandle = (Method**) get_HotSpotResolvedJavaMethodImpl_metadataHandle(obj);
1426   return *metadataHandle;
1427 }
1428 
1429 ConstantPool* JVMCIEnv::asConstantPool(JVMCIObject obj) {
1430   ConstantPool** metadataHandle = (ConstantPool**) get_HotSpotConstantPool_metadataHandle(obj);
1431   return *metadataHandle;
1432 }
1433 
1434 CodeBlob* JVMCIEnv::get_code_blob(JVMCIObject obj, nmethodLocker&amp; locker) {
1435   address code = (address) get_InstalledCode_address(obj);
1436   if (code == NULL) {
1437     return NULL;
1438   }
1439   if (isa_HotSpotNmethod(obj)) {
1440     nmethod* nm = NULL;
1441     {
1442       // Lookup the CodeBlob while holding the CodeCache_lock to ensure the nmethod can&#39;t be freed
1443       // by nmethod::flush while we&#39;re interrogating it.
1444       MutexLocker cm_lock(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1445       CodeBlob* cb = CodeCache::find_blob_unsafe(code);
1446       if (cb == (CodeBlob*) code) {
1447         nmethod* the_nm = cb-&gt;as_nmethod_or_null();
1448         if (the_nm != NULL &amp;&amp; the_nm-&gt;is_alive()) {
1449           // Lock the nmethod to stop any further transitions by the sweeper.  It&#39;s still possible
1450           // for this code to execute in the middle of the sweeping of the nmethod but that will be
1451           // handled below.
1452           locker.set_code(nm, true);
1453           nm = the_nm;
1454         }
1455       }
1456     }
1457 
1458     if (nm != NULL) {
1459       // We found the nmethod but it could be in the process of being freed.  Check the state of the
1460       // nmethod while holding the CompiledMethod_lock.  This ensures that any transitions by other
1461       // threads have seen the is_locked_by_vm() update above.
1462       MutexLocker cm_lock(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
1463       if (!nm-&gt;is_alive()) {
1464         //  It was alive when we looked it up but it&#39;s no longer alive so release it.
1465         locker.set_code(NULL);
1466         nm = NULL;
1467       }
1468     }
1469 
1470     jlong compile_id_snapshot = get_HotSpotNmethod_compileIdSnapshot(obj);
1471     if (compile_id_snapshot != 0L) {
1472       // Found a live nmethod with the same address, make sure it&#39;s the same nmethod
1473       if (nm == (nmethod*) code &amp;&amp; nm-&gt;compile_id() == compile_id_snapshot &amp;&amp; nm-&gt;is_alive()) {
1474         if (nm-&gt;is_not_entrant()) {
1475           // Zero the entry point so that the nmethod
1476           // cannot be invoked by the mirror but can
1477           // still be deoptimized.
1478           set_InstalledCode_entryPoint(obj, 0);
1479         }
1480         return nm;
1481       }
1482       // The HotSpotNmethod no longer refers to a valid nmethod so clear the state
1483       locker.set_code(NULL);
1484       nm = NULL;
1485     }
1486 
1487     if (nm == NULL) {
1488       // The HotSpotNmethod was pointing at some nmethod but the nmethod is no longer valid, so
1489       // clear the InstalledCode fields of this HotSpotNmethod so that it no longer refers to a
1490       // nmethod in the code cache.
1491       set_InstalledCode_address(obj, 0);
1492       set_InstalledCode_entryPoint(obj, 0);
1493     }
1494     return nm;
1495   }
1496 
1497   CodeBlob* cb = (CodeBlob*) code;
1498   assert(!cb-&gt;is_nmethod(), &quot;unexpected nmethod&quot;);
1499   return cb;
1500 }
1501 
1502 nmethod* JVMCIEnv::get_nmethod(JVMCIObject obj, nmethodLocker&amp; locker) {
1503   CodeBlob* cb = get_code_blob(obj, locker);
1504   if (cb != NULL) {
1505     return cb-&gt;as_nmethod_or_null();
1506   }
1507   return NULL;
1508 }
1509 
1510 // Generate implementations for the initialize, new, isa, get and set methods for all the types and
1511 // fields declared in the JVMCI_CLASSES_DO macro.
1512 
1513 #define START_CLASS(className, fullClassName)                                                                        \
1514   void JVMCIEnv::className##_initialize(JVMCI_TRAPS) {                                                               \
1515     if (is_hotspot()) {                                                                                              \
1516       HotSpotJVMCI::className::initialize(JVMCI_CHECK);                                                              \
1517     } else {                                                                                                         \
1518       JNIJVMCI::className::initialize(JVMCI_CHECK);                                                                  \
1519     }                                                                                                                \
1520   }                                                                                                                  \
1521   JVMCIObjectArray JVMCIEnv::new_##className##_array(int length, JVMCI_TRAPS) {                                      \
1522     if (is_hotspot()) {                                                                                              \
1523       Thread* THREAD = Thread::current();                                                                            \
1524       objArrayOop array = oopFactory::new_objArray(HotSpotJVMCI::className::klass(), length, CHECK_(JVMCIObject())); \
1525       return (JVMCIObjectArray) wrap(array);                                                                         \
1526     } else {                                                                                                         \
1527       JNIAccessMark jni(this);                                                                                       \
1528       jobjectArray result = jni()-&gt;NewObjectArray(length, JNIJVMCI::className::clazz(), NULL);                       \
1529       return wrap(result);                                                                                           \
1530     }                                                                                                                \
1531   }                                                                                                                  \
1532   bool JVMCIEnv::isa_##className(JVMCIObject object) {                                                               \
1533     if (is_hotspot()) {                                                                                              \
1534       return HotSpotJVMCI::className::is_instance(this, object);                                                     \
1535     } else {                                                                                                         \
1536       return JNIJVMCI::className::is_instance(this, object);                                                         \
1537     }                                                                                                                \
1538   }
1539 
1540 #define END_CLASS
1541 
1542 #define FIELD(className, name, type, accessor, cast)                 \
1543   type JVMCIEnv::get_##className##_##name(JVMCIObject obj) {         \
1544     if (is_hotspot()) {                                              \
1545       return HotSpotJVMCI::className::get_##name(this, obj);         \
1546     } else {                                                         \
1547       return JNIJVMCI::className::get_##name(this, obj);             \
1548     }                                                                \
1549   }                                                                  \
1550   void JVMCIEnv::set_##className##_##name(JVMCIObject obj, type x) { \
1551     if (is_hotspot()) {                                              \
1552       HotSpotJVMCI::className::set_##name(this, obj, x);             \
1553     } else {                                                         \
1554       JNIJVMCI::className::set_##name(this, obj, x);                 \
1555     }                                                                \
1556   }
1557 
1558 #define EMPTY_CAST
1559 #define CHAR_FIELD(className, name)                    FIELD(className, name, jchar, Char, EMPTY_CAST)
1560 #define INT_FIELD(className, name)                     FIELD(className, name, jint, Int, EMPTY_CAST)
1561 #define BOOLEAN_FIELD(className, name)                 FIELD(className, name, jboolean, Boolean, EMPTY_CAST)
1562 #define LONG_FIELD(className, name)                    FIELD(className, name, jlong, Long, EMPTY_CAST)
1563 #define FLOAT_FIELD(className, name)                   FIELD(className, name, jfloat, Float, EMPTY_CAST)
1564 
1565 #define OBJECT_FIELD(className, name, signature)              OOPISH_FIELD(className, name, JVMCIObject, Object, EMPTY_CAST)
1566 #define OBJECTARRAY_FIELD(className, name, signature)         OOPISH_FIELD(className, name, JVMCIObjectArray, Object, (JVMCIObjectArray))
1567 #define PRIMARRAY_FIELD(className, name, signature)           OOPISH_FIELD(className, name, JVMCIPrimitiveArray, Object, (JVMCIPrimitiveArray))
1568 
1569 #define STATIC_OBJECT_FIELD(className, name, signature)       STATIC_OOPISH_FIELD(className, name, JVMCIObject, Object, (JVMCIObject))
1570 #define STATIC_OBJECTARRAY_FIELD(className, name, signature)  STATIC_OOPISH_FIELD(className, name, JVMCIObjectArray, Object, (JVMCIObjectArray))
1571 
1572 #define OOPISH_FIELD(className, name, type, accessor, cast)           \
1573   type JVMCIEnv::get_##className##_##name(JVMCIObject obj) {          \
1574     if (is_hotspot()) {                                               \
1575       return HotSpotJVMCI::className::get_##name(this, obj);          \
1576     } else {                                                          \
1577       return JNIJVMCI::className::get_##name(this, obj);              \
1578     }                                                                 \
1579   }                                                                   \
1580   void JVMCIEnv::set_##className##_##name(JVMCIObject obj, type x) {  \
1581     if (is_hotspot()) {                                               \
1582       HotSpotJVMCI::className::set_##name(this, obj, x);              \
1583     } else {                                                          \
1584       JNIJVMCI::className::set_##name(this, obj, x);                  \
1585     }                                                                 \
1586   }
1587 
1588 #define STATIC_OOPISH_FIELD(className, name, type, accessor, cast)    \
1589   type JVMCIEnv::get_##className##_##name() {                         \
1590     if (is_hotspot()) {                                               \
1591       return HotSpotJVMCI::className::get_##name(this);               \
1592     } else {                                                          \
1593       return JNIJVMCI::className::get_##name(this);                   \
1594     }                                                                 \
1595   }                                                                   \
1596   void JVMCIEnv::set_##className##_##name(type x) {                   \
1597     if (is_hotspot()) {                                               \
1598       HotSpotJVMCI::className::set_##name(this, x);                   \
1599     } else {                                                          \
1600       JNIJVMCI::className::set_##name(this, x);                       \
1601     }                                                                 \
1602   }
1603 
1604 #define STATIC_PRIMITIVE_FIELD(className, name, type, accessor, cast) \
1605   type JVMCIEnv::get_##className##_##name() {                         \
1606     if (is_hotspot()) {                                               \
1607       return HotSpotJVMCI::className::get_##name(this);               \
1608     } else {                                                          \
1609       return JNIJVMCI::className::get_##name(this);                   \
1610     }                                                                 \
1611   }                                                                   \
1612   void JVMCIEnv::set_##className##_##name(type x) {                   \
1613     if (is_hotspot()) {                                               \
1614       HotSpotJVMCI::className::set_##name(this, x);                   \
1615     } else {                                                          \
1616       JNIJVMCI::className::set_##name(this, x);                       \
1617     }                                                                 \
1618   }
1619 #define STATIC_INT_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jint, Int, EMPTY_CAST)
1620 #define STATIC_BOOLEAN_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jboolean, Boolean, EMPTY_CAST)
1621 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)
1622 #define CONSTRUCTOR(className, signature)
1623 
1624 JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, PRIMARRAY_FIELD, OBJECTARRAY_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECTARRAY_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)
1625 
1626 #undef START_CLASS
1627 #undef END_CLASS
1628 #undef METHOD
1629 #undef CONSTRUCTOR
1630 #undef FIELD
1631 #undef CHAR_FIELD
1632 #undef INT_FIELD
1633 #undef BOOLEAN_FIELD
1634 #undef LONG_FIELD
1635 #undef FLOAT_FIELD
1636 #undef OBJECT_FIELD
1637 #undef PRIMARRAY_FIELD
1638 #undef OBJECTARRAY_FIELD
1639 #undef STATIC_OOPISH_FIELD
1640 #undef STATIC_OBJECT_FIELD
1641 #undef STATIC_OBJECTARRAY_FIELD
1642 #undef STATIC_INT_FIELD
1643 #undef STATIC_BOOLEAN_FIELD
1644 #undef EMPTY_CAST
    </pre>
  </body>
</html>