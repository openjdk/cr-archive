<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jvmci/jvmciRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;classfile/javaClasses.inline.hpp&quot;
  26 #include &quot;classfile/symbolTable.hpp&quot;
  27 #include &quot;compiler/compileBroker.hpp&quot;
  28 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
  29 #include &quot;jvmci/jniAccessMark.inline.hpp&quot;
  30 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  31 #include &quot;jvmci/jvmciRuntime.hpp&quot;
  32 #include &quot;jvmci/metadataHandles.hpp&quot;
  33 #include &quot;logging/log.hpp&quot;
  34 #include &quot;memory/oopFactory.hpp&quot;
  35 #include &quot;memory/universe.hpp&quot;
  36 #include &quot;oops/constantPool.inline.hpp&quot;
  37 #include &quot;oops/method.inline.hpp&quot;
  38 #include &quot;oops/objArrayKlass.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  41 #include &quot;runtime/atomic.hpp&quot;
  42 #include &quot;runtime/biasedLocking.hpp&quot;
  43 #include &quot;runtime/deoptimization.hpp&quot;
  44 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  45 #include &quot;runtime/frame.inline.hpp&quot;
  46 #include &quot;runtime/jniHandles.inline.hpp&quot;
  47 #include &quot;runtime/sharedRuntime.hpp&quot;
  48 #if INCLUDE_G1GC
  49 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
  50 #endif // INCLUDE_G1GC
  51 
  52 // Simple helper to see if the caller of a runtime stub which
  53 // entered the VM has been deoptimized
  54 
  55 static bool caller_is_deopted() {
  56   JavaThread* thread = JavaThread::current();
  57   RegisterMap reg_map(thread, false);
  58   frame runtime_frame = thread-&gt;last_frame();
  59   frame caller_frame = runtime_frame.sender(&amp;reg_map);
  60   assert(caller_frame.is_compiled_frame(), &quot;must be compiled&quot;);
  61   return caller_frame.is_deoptimized_frame();
  62 }
  63 
  64 // Stress deoptimization
  65 static void deopt_caller() {
  66   if ( !caller_is_deopted()) {
  67     JavaThread* thread = JavaThread::current();
  68     RegisterMap reg_map(thread, false);
  69     frame runtime_frame = thread-&gt;last_frame();
  70     frame caller_frame = runtime_frame.sender(&amp;reg_map);
  71     Deoptimization::deoptimize_frame(thread, caller_frame.id(), Deoptimization::Reason_constraint);
  72     assert(caller_is_deopted(), &quot;Must be deoptimized&quot;);
  73   }
  74 }
  75 
  76 // Manages a scope for a JVMCI runtime call that attempts a heap allocation.
  77 // If there is a pending exception upon closing the scope and the runtime
  78 // call is of the variety where allocation failure returns NULL without an
  79 // exception, the following action is taken:
  80 //   1. The pending exception is cleared
  81 //   2. NULL is written to JavaThread::_vm_result
  82 //   3. Checks that an OutOfMemoryError is Universe::out_of_memory_error_retry().
  83 class RetryableAllocationMark: public StackObj {
  84  private:
  85   JavaThread* _thread;
  86  public:
  87   RetryableAllocationMark(JavaThread* thread, bool activate) {
  88     if (activate) {
  89       assert(!thread-&gt;in_retryable_allocation(), &quot;retryable allocation scope is non-reentrant&quot;);
  90       _thread = thread;
  91       _thread-&gt;set_in_retryable_allocation(true);
  92     } else {
  93       _thread = NULL;
  94     }
  95   }
  96   ~RetryableAllocationMark() {
  97     if (_thread != NULL) {
  98       _thread-&gt;set_in_retryable_allocation(false);
  99       JavaThread* THREAD = _thread;
 100       if (HAS_PENDING_EXCEPTION) {
 101         oop ex = PENDING_EXCEPTION;
 102         CLEAR_PENDING_EXCEPTION;
 103         oop retry_oome = Universe::out_of_memory_error_retry();
 104         if (ex-&gt;is_a(retry_oome-&gt;klass()) &amp;&amp; retry_oome != ex) {
 105           ResourceMark rm;
 106           fatal(&quot;Unexpected exception in scope of retryable allocation: &quot; INTPTR_FORMAT &quot; of type %s&quot;, p2i(ex), ex-&gt;klass()-&gt;external_name());
 107         }
 108         _thread-&gt;set_vm_result(NULL);
 109       }
 110     }
 111   }
 112 };
 113 
 114 JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_instance_common(JavaThread* thread, Klass* klass, bool null_on_fail))
 115   JRT_BLOCK;
 116   assert(klass-&gt;is_klass(), &quot;not a class&quot;);
 117   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 118   InstanceKlass* h = InstanceKlass::cast(klass);
 119   {
 120     RetryableAllocationMark ram(thread, null_on_fail);
 121     h-&gt;check_valid_for_instantiation(true, CHECK);
 122     oop obj;
 123     if (null_on_fail) {
 124       if (!h-&gt;is_initialized()) {
 125         // Cannot re-execute class initialization without side effects
 126         // so return without attempting the initialization
 127         return;
 128       }
 129     } else {
 130       // make sure klass is initialized
 131       h-&gt;initialize(CHECK);
 132     }
 133     // allocate instance and return via TLS
 134     obj = h-&gt;allocate_instance(CHECK);
 135     thread-&gt;set_vm_result(obj);
 136   }
 137   JRT_BLOCK_END;
 138   SharedRuntime::on_slowpath_allocation_exit(thread);
 139 JRT_END
 140 
 141 JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_array_common(JavaThread* thread, Klass* array_klass, jint length, bool null_on_fail))
 142   JRT_BLOCK;
 143   // Note: no handle for klass needed since they are not used
 144   //       anymore after new_objArray() and no GC can happen before.
 145   //       (This may have to change if this code changes!)
 146   assert(array_klass-&gt;is_klass(), &quot;not a class&quot;);
 147   oop obj;
 148   if (array_klass-&gt;is_typeArray_klass()) {
 149     BasicType elt_type = TypeArrayKlass::cast(array_klass)-&gt;element_type();
 150     RetryableAllocationMark ram(thread, null_on_fail);
 151     obj = oopFactory::new_typeArray(elt_type, length, CHECK);
 152   } else {
 153     Handle holder(THREAD, array_klass-&gt;klass_holder()); // keep the klass alive
 154     Klass* elem_klass = ObjArrayKlass::cast(array_klass)-&gt;element_klass();
 155     RetryableAllocationMark ram(thread, null_on_fail);
 156     obj = oopFactory::new_objArray(elem_klass, length, CHECK);
 157   }
 158   thread-&gt;set_vm_result(obj);
 159   // This is pretty rare but this runtime patch is stressful to deoptimization
 160   // if we deoptimize here so force a deopt to stress the path.
 161   if (DeoptimizeALot) {
 162     static int deopts = 0;
 163     // Alternate between deoptimizing and raising an error (which will also cause a deopt)
 164     if (deopts++ % 2 == 0) {
 165       if (null_on_fail) {
 166         return;
 167       } else {
 168         ResourceMark rm(THREAD);
 169         THROW(vmSymbols::java_lang_OutOfMemoryError());
 170       }
 171     } else {
 172       deopt_caller();
 173     }
 174   }
 175   JRT_BLOCK_END;
 176   SharedRuntime::on_slowpath_allocation_exit(thread);
 177 JRT_END
 178 
 179 JRT_ENTRY(void, JVMCIRuntime::new_multi_array_common(JavaThread* thread, Klass* klass, int rank, jint* dims, bool null_on_fail))
 180   assert(klass-&gt;is_klass(), &quot;not a class&quot;);
 181   assert(rank &gt;= 1, &quot;rank must be nonzero&quot;);
 182   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 183   RetryableAllocationMark ram(thread, null_on_fail);
 184   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(rank, dims, CHECK);
 185   thread-&gt;set_vm_result(obj);
 186 JRT_END
 187 
 188 JRT_ENTRY(void, JVMCIRuntime::dynamic_new_array_common(JavaThread* thread, oopDesc* element_mirror, jint length, bool null_on_fail))
 189   RetryableAllocationMark ram(thread, null_on_fail);
 190   oop obj = Reflection::reflect_new_array(element_mirror, length, CHECK);
 191   thread-&gt;set_vm_result(obj);
 192 JRT_END
 193 
 194 JRT_ENTRY(void, JVMCIRuntime::dynamic_new_instance_common(JavaThread* thread, oopDesc* type_mirror, bool null_on_fail))
 195   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(type_mirror));
 196 
 197   if (klass == NULL) {
 198     ResourceMark rm(THREAD);
 199     THROW(vmSymbols::java_lang_InstantiationException());
 200   }
 201   RetryableAllocationMark ram(thread, null_on_fail);
 202 
 203   // Create new instance (the receiver)
 204   klass-&gt;check_valid_for_instantiation(false, CHECK);
 205 
 206   if (null_on_fail) {
 207     if (!klass-&gt;is_initialized()) {
 208       // Cannot re-execute class initialization without side effects
 209       // so return without attempting the initialization
 210       return;
 211     }
 212   } else {
 213     // Make sure klass gets initialized
 214     klass-&gt;initialize(CHECK);
 215   }
 216 
 217   oop obj = klass-&gt;allocate_instance(CHECK);
 218   thread-&gt;set_vm_result(obj);
 219 JRT_END
 220 
 221 extern void vm_exit(int code);
 222 
 223 // Enter this method from compiled code handler below. This is where we transition
 224 // to VM mode. This is done as a helper routine so that the method called directly
 225 // from compiled code does not have to transition to VM. This allows the entry
 226 // method to see if the nmethod that we have just looked up a handler for has
 227 // been deoptimized while we were in the vm. This simplifies the assembly code
 228 // cpu directories.
 229 //
 230 // We are entering here from exception stub (via the entry method below)
 231 // If there is a compiled exception handler in this method, we will continue there;
 232 // otherwise we will unwind the stack and continue at the caller of top frame method
 233 // Note: we enter in Java using a special JRT wrapper. This wrapper allows us to
 234 // control the area where we can allow a safepoint. After we exit the safepoint area we can
 235 // check to see if the handler we are going to return is now in a nmethod that has
 236 // been deoptimized. If that is the case we return the deopt blob
 237 // unpack_with_exception entry instead. This makes life for the exception blob easier
 238 // because making that same check and diverting is painful from assembly language.
 239 JRT_ENTRY_NO_ASYNC(static address, exception_handler_for_pc_helper(JavaThread* thread, oopDesc* ex, address pc, CompiledMethod*&amp; cm))
 240   // Reset method handle flag.
 241   thread-&gt;set_is_method_handle_return(false);
 242 
 243   Handle exception(thread, ex);
 244   cm = CodeCache::find_compiled(pc);
 245   assert(cm != NULL, &quot;this is not a compiled method&quot;);
 246   // Adjust the pc as needed/
 247   if (cm-&gt;is_deopt_pc(pc)) {
 248     RegisterMap map(thread, false);
 249     frame exception_frame = thread-&gt;last_frame().sender(&amp;map);
 250     // if the frame isn&#39;t deopted then pc must not correspond to the caller of last_frame
 251     assert(exception_frame.is_deoptimized_frame(), &quot;must be deopted&quot;);
 252     pc = exception_frame.pc();
 253   }
 254 #ifdef ASSERT
 255   assert(exception.not_null(), &quot;NULL exceptions should be handled by throw_exception&quot;);
 256   assert(oopDesc::is_oop(exception()), &quot;just checking&quot;);
 257   // Check that exception is a subclass of Throwable, otherwise we have a VerifyError
 258   if (!(exception-&gt;is_a(SystemDictionary::Throwable_klass()))) {
 259     if (ExitVMOnVerifyError) vm_exit(-1);
 260     ShouldNotReachHere();
 261   }
 262 #endif
 263 
 264   // Check the stack guard pages and reenable them if necessary and there is
 265   // enough space on the stack to do so.  Use fast exceptions only if the guard
 266   // pages are enabled.
 267   bool guard_pages_enabled = thread-&gt;stack_guards_enabled();
 268   if (!guard_pages_enabled) guard_pages_enabled = thread-&gt;reguard_stack();
 269 
 270   if (JvmtiExport::can_post_on_exceptions()) {
 271     // To ensure correct notification of exception catches and throws
 272     // we have to deoptimize here.  If we attempted to notify the
 273     // catches and throws during this exception lookup it&#39;s possible
 274     // we could deoptimize on the way out of the VM and end back in
 275     // the interpreter at the throw site.  This would result in double
 276     // notifications since the interpreter would also notify about
 277     // these same catches and throws as it unwound the frame.
 278 
 279     RegisterMap reg_map(thread);
 280     frame stub_frame = thread-&gt;last_frame();
 281     frame caller_frame = stub_frame.sender(&amp;reg_map);
 282 
 283     // We don&#39;t really want to deoptimize the nmethod itself since we
 284     // can actually continue in the exception handler ourselves but I
 285     // don&#39;t see an easy way to have the desired effect.
 286     Deoptimization::deoptimize_frame(thread, caller_frame.id(), Deoptimization::Reason_constraint);
 287     assert(caller_is_deopted(), &quot;Must be deoptimized&quot;);
 288 
 289     return SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
 290   }
 291 
 292   // ExceptionCache is used only for exceptions at call sites and not for implicit exceptions
 293   if (guard_pages_enabled) {
 294     address fast_continuation = cm-&gt;handler_for_exception_and_pc(exception, pc);
 295     if (fast_continuation != NULL) {
 296       // Set flag if return address is a method handle call site.
 297       thread-&gt;set_is_method_handle_return(cm-&gt;is_method_handle_return(pc));
 298       return fast_continuation;
 299     }
 300   }
 301 
 302   // If the stack guard pages are enabled, check whether there is a handler in
 303   // the current method.  Otherwise (guard pages disabled), force an unwind and
 304   // skip the exception cache update (i.e., just leave continuation==NULL).
 305   address continuation = NULL;
 306   if (guard_pages_enabled) {
 307 
 308     // New exception handling mechanism can support inlined methods
 309     // with exception handlers since the mappings are from PC to PC
 310 
 311     // debugging support
 312     // tracing
 313     if (log_is_enabled(Info, exceptions)) {
 314       ResourceMark rm;
 315       stringStream tempst;
 316       assert(cm-&gt;method() != NULL, &quot;Unexpected null method()&quot;);
 317       tempst.print(&quot;compiled method &lt;%s&gt;\n&quot;
 318                    &quot; at PC&quot; INTPTR_FORMAT &quot; for thread &quot; INTPTR_FORMAT,
 319                    cm-&gt;method()-&gt;print_value_string(), p2i(pc), p2i(thread));
 320       Exceptions::log_exception(exception, tempst.as_string());
 321     }
 322     // for AbortVMOnException flag
 323     NOT_PRODUCT(Exceptions::debug_check_abort(exception));
 324 
 325     // Clear out the exception oop and pc since looking up an
 326     // exception handler can cause class loading, which might throw an
 327     // exception and those fields are expected to be clear during
 328     // normal bytecode execution.
 329     thread-&gt;clear_exception_oop_and_pc();
 330 
 331     bool recursive_exception = false;
 332     continuation = SharedRuntime::compute_compiled_exc_handler(cm, pc, exception, false, false, recursive_exception);
 333     // If an exception was thrown during exception dispatch, the exception oop may have changed
 334     thread-&gt;set_exception_oop(exception());
 335     thread-&gt;set_exception_pc(pc);
 336 
 337     // The exception cache is used only for non-implicit exceptions
 338     // Update the exception cache only when another exception did
 339     // occur during the computation of the compiled exception handler
 340     // (e.g., when loading the class of the catch type).
 341     // Checking for exception oop equality is not
 342     // sufficient because some exceptions are pre-allocated and reused.
 343     if (continuation != NULL &amp;&amp; !recursive_exception &amp;&amp; !SharedRuntime::deopt_blob()-&gt;contains(continuation)) {
 344       cm-&gt;add_handler_for_exception_and_pc(exception, pc, continuation);
 345     }
 346   }
 347 
 348   // Set flag if return address is a method handle call site.
 349   thread-&gt;set_is_method_handle_return(cm-&gt;is_method_handle_return(pc));
 350 
 351   if (log_is_enabled(Info, exceptions)) {
 352     ResourceMark rm;
 353     log_info(exceptions)(&quot;Thread &quot; PTR_FORMAT &quot; continuing at PC &quot; PTR_FORMAT
 354                          &quot; for exception thrown at PC &quot; PTR_FORMAT,
 355                          p2i(thread), p2i(continuation), p2i(pc));
 356   }
 357 
 358   return continuation;
 359 JRT_END
 360 
 361 // Enter this method from compiled code only if there is a Java exception handler
 362 // in the method handling the exception.
 363 // We are entering here from exception stub. We don&#39;t do a normal VM transition here.
 364 // We do it in a helper. This is so we can check to see if the nmethod we have just
 365 // searched for an exception handler has been deoptimized in the meantime.
 366 address JVMCIRuntime::exception_handler_for_pc(JavaThread* thread) {
 367   oop exception = thread-&gt;exception_oop();
 368   address pc = thread-&gt;exception_pc();
 369   // Still in Java mode
 370   DEBUG_ONLY(ResetNoHandleMark rnhm);
 371   CompiledMethod* cm = NULL;
 372   address continuation = NULL;
 373   {
 374     // Enter VM mode by calling the helper
 375     ResetNoHandleMark rnhm;
 376     continuation = exception_handler_for_pc_helper(thread, exception, pc, cm);
 377   }
 378   // Back in JAVA, use no oops DON&#39;T safepoint
 379 
 380   // Now check to see if the compiled method we were called from is now deoptimized.
 381   // If so we must return to the deopt blob and deoptimize the nmethod
 382   if (cm != NULL &amp;&amp; caller_is_deopted()) {
 383     continuation = SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
 384   }
 385 
 386   assert(continuation != NULL, &quot;no handler found&quot;);
 387   return continuation;
 388 }
 389 
 390 JRT_BLOCK_ENTRY(void, JVMCIRuntime::monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock))
 391   SharedRuntime::monitor_enter_helper(obj, lock, thread);
 392 JRT_END
 393 
 394 JRT_LEAF(void, JVMCIRuntime::monitorexit(JavaThread* thread, oopDesc* obj, BasicLock* lock))
 395   assert(thread-&gt;last_Java_sp(), &quot;last_Java_sp must be set&quot;);
 396   assert(oopDesc::is_oop(obj), &quot;invalid lock object pointer dected&quot;);
 397   SharedRuntime::monitor_exit_helper(obj, lock, thread);
 398 JRT_END
 399 
 400 // Object.notify() fast path, caller does slow path
 401 JRT_LEAF(jboolean, JVMCIRuntime::object_notify(JavaThread *thread, oopDesc* obj))
 402 
 403   // Very few notify/notifyAll operations find any threads on the waitset, so
 404   // the dominant fast-path is to simply return.
 405   // Relatedly, it&#39;s critical that notify/notifyAll be fast in order to
 406   // reduce lock hold times.
 407   if (!SafepointSynchronize::is_synchronizing()) {
 408     if (ObjectSynchronizer::quick_notify(obj, thread, false)) {
 409       return true;
 410     }
 411   }
 412   return false; // caller must perform slow path
 413 
 414 JRT_END
 415 
 416 // Object.notifyAll() fast path, caller does slow path
 417 JRT_LEAF(jboolean, JVMCIRuntime::object_notifyAll(JavaThread *thread, oopDesc* obj))
 418 
 419   if (!SafepointSynchronize::is_synchronizing() ) {
 420     if (ObjectSynchronizer::quick_notify(obj, thread, true)) {
 421       return true;
 422     }
 423   }
 424   return false; // caller must perform slow path
 425 
 426 JRT_END
 427 
 428 JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message))
 429   JRT_BLOCK;
 430   TempNewSymbol symbol = SymbolTable::new_symbol(exception);
 431   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);
 432   JRT_BLOCK_END;
 433   return caller_is_deopted();
 434 JRT_END
 435 
 436 JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass))
 437   JRT_BLOCK;
 438   ResourceMark rm(thread);
 439   TempNewSymbol symbol = SymbolTable::new_symbol(exception);
 440   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, klass-&gt;external_name());
 441   JRT_BLOCK_END;
 442   return caller_is_deopted();
 443 JRT_END
 444 
 445 JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass))
 446   JRT_BLOCK;
 447   ResourceMark rm(thread);
 448   const char* message = SharedRuntime::generate_class_cast_message(caster_klass, target_klass);
 449   TempNewSymbol symbol = SymbolTable::new_symbol(exception);
 450   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);
 451   JRT_BLOCK_END;
 452   return caller_is_deopted();
 453 JRT_END
 454 
 455 JRT_LEAF(void, JVMCIRuntime::log_object(JavaThread* thread, oopDesc* obj, bool as_string, bool newline))
 456   ttyLocker ttyl;
 457 
 458   if (obj == NULL) {
 459     tty-&gt;print(&quot;NULL&quot;);
 460   } else if (oopDesc::is_oop_or_null(obj, true) &amp;&amp; (!as_string || !java_lang_String::is_instance(obj))) {
 461     if (oopDesc::is_oop_or_null(obj, true)) {
 462       char buf[O_BUFLEN];
 463       tty-&gt;print(&quot;%s@&quot; INTPTR_FORMAT, obj-&gt;klass()-&gt;name()-&gt;as_C_string(buf, O_BUFLEN), p2i(obj));
 464     } else {
 465       tty-&gt;print(INTPTR_FORMAT, p2i(obj));
 466     }
 467   } else {
 468     ResourceMark rm;
 469     assert(obj != NULL &amp;&amp; java_lang_String::is_instance(obj), &quot;must be&quot;);
 470     char *buf = java_lang_String::as_utf8_string(obj);
 471     tty-&gt;print_raw(buf);
 472   }
 473   if (newline) {
 474     tty-&gt;cr();
 475   }
 476 JRT_END
 477 
 478 #if INCLUDE_G1GC
 479 
 480 JRT_LEAF(void, JVMCIRuntime::write_barrier_pre(JavaThread* thread, oopDesc* obj))
 481   G1ThreadLocalData::satb_mark_queue(thread).enqueue(obj);
 482 JRT_END
 483 
 484 JRT_LEAF(void, JVMCIRuntime::write_barrier_post(JavaThread* thread, void* card_addr))
 485   G1ThreadLocalData::dirty_card_queue(thread).enqueue(card_addr);
 486 JRT_END
 487 
 488 #endif // INCLUDE_G1GC
 489 
 490 JRT_LEAF(jboolean, JVMCIRuntime::validate_object(JavaThread* thread, oopDesc* parent, oopDesc* child))
 491   bool ret = true;
 492   if(!Universe::heap()-&gt;is_in(parent)) {
 493     tty-&gt;print_cr(&quot;Parent Object &quot; INTPTR_FORMAT &quot; not in heap&quot;, p2i(parent));
 494     parent-&gt;print();
 495     ret=false;
 496   }
 497   if(!Universe::heap()-&gt;is_in(child)) {
 498     tty-&gt;print_cr(&quot;Child Object &quot; INTPTR_FORMAT &quot; not in heap&quot;, p2i(child));
 499     child-&gt;print();
 500     ret=false;
 501   }
 502   return (jint)ret;
 503 JRT_END
 504 
 505 JRT_ENTRY(void, JVMCIRuntime::vm_error(JavaThread* thread, jlong where, jlong format, jlong value))
 506   ResourceMark rm;
 507   const char *error_msg = where == 0L ? &quot;&lt;internal JVMCI error&gt;&quot; : (char*) (address) where;
 508   char *detail_msg = NULL;
 509   if (format != 0L) {
 510     const char* buf = (char*) (address) format;
 511     size_t detail_msg_length = strlen(buf) * 2;
 512     detail_msg = (char *) NEW_RESOURCE_ARRAY(u_char, detail_msg_length);
 513     jio_snprintf(detail_msg, detail_msg_length, buf, value);
 514   }
 515   report_vm_error(__FILE__, __LINE__, error_msg, &quot;%s&quot;, detail_msg);
 516 JRT_END
 517 
 518 JRT_LEAF(oopDesc*, JVMCIRuntime::load_and_clear_exception(JavaThread* thread))
 519   oop exception = thread-&gt;exception_oop();
 520   assert(exception != NULL, &quot;npe&quot;);
 521   thread-&gt;set_exception_oop(NULL);
 522   thread-&gt;set_exception_pc(0);
 523   return exception;
 524 JRT_END
 525 
 526 PRAGMA_DIAG_PUSH
 527 PRAGMA_FORMAT_NONLITERAL_IGNORED
 528 JRT_LEAF(void, JVMCIRuntime::log_printf(JavaThread* thread, const char* format, jlong v1, jlong v2, jlong v3))
 529   ResourceMark rm;
 530   tty-&gt;print(format, v1, v2, v3);
 531 JRT_END
 532 PRAGMA_DIAG_POP
 533 
 534 static void decipher(jlong v, bool ignoreZero) {
 535   if (v != 0 || !ignoreZero) {
 536     void* p = (void *)(address) v;
 537     CodeBlob* cb = CodeCache::find_blob(p);
 538     if (cb) {
 539       if (cb-&gt;is_nmethod()) {
 540         char buf[O_BUFLEN];
 541         tty-&gt;print(&quot;%s [&quot; INTPTR_FORMAT &quot;+&quot; JLONG_FORMAT &quot;]&quot;, cb-&gt;as_nmethod_or_null()-&gt;method()-&gt;name_and_sig_as_C_string(buf, O_BUFLEN), p2i(cb-&gt;code_begin()), (jlong)((address)v - cb-&gt;code_begin()));
 542         return;
 543       }
 544       cb-&gt;print_value_on(tty);
 545       return;
 546     }
 547     if (Universe::heap()-&gt;is_in(p)) {
 548       oop obj = oop(p);
 549       obj-&gt;print_value_on(tty);
 550       return;
 551     }
 552     tty-&gt;print(INTPTR_FORMAT &quot; [long: &quot; JLONG_FORMAT &quot;, double %lf, char %c]&quot;,p2i((void *)v), (jlong)v, (jdouble)v, (char)v);
 553   }
 554 }
 555 
 556 PRAGMA_DIAG_PUSH
 557 PRAGMA_FORMAT_NONLITERAL_IGNORED
 558 JRT_LEAF(void, JVMCIRuntime::vm_message(jboolean vmError, jlong format, jlong v1, jlong v2, jlong v3))
 559   ResourceMark rm;
 560   const char *buf = (const char*) (address) format;
 561   if (vmError) {
 562     if (buf != NULL) {
 563       fatal(buf, v1, v2, v3);
 564     } else {
 565       fatal(&quot;&lt;anonymous error&gt;&quot;);
 566     }
 567   } else if (buf != NULL) {
 568     tty-&gt;print(buf, v1, v2, v3);
 569   } else {
 570     assert(v2 == 0, &quot;v2 != 0&quot;);
 571     assert(v3 == 0, &quot;v3 != 0&quot;);
 572     decipher(v1, false);
 573   }
 574 JRT_END
 575 PRAGMA_DIAG_POP
 576 
 577 JRT_LEAF(void, JVMCIRuntime::log_primitive(JavaThread* thread, jchar typeChar, jlong value, jboolean newline))
 578   union {
 579       jlong l;
 580       jdouble d;
 581       jfloat f;
 582   } uu;
 583   uu.l = value;
 584   switch (typeChar) {
 585     case &#39;Z&#39;: tty-&gt;print(value == 0 ? &quot;false&quot; : &quot;true&quot;); break;
 586     case &#39;B&#39;: tty-&gt;print(&quot;%d&quot;, (jbyte) value); break;
 587     case &#39;C&#39;: tty-&gt;print(&quot;%c&quot;, (jchar) value); break;
 588     case &#39;S&#39;: tty-&gt;print(&quot;%d&quot;, (jshort) value); break;
 589     case &#39;I&#39;: tty-&gt;print(&quot;%d&quot;, (jint) value); break;
 590     case &#39;F&#39;: tty-&gt;print(&quot;%f&quot;, uu.f); break;
 591     case &#39;J&#39;: tty-&gt;print(JLONG_FORMAT, value); break;
 592     case &#39;D&#39;: tty-&gt;print(&quot;%lf&quot;, uu.d); break;
 593     default: assert(false, &quot;unknown typeChar&quot;); break;
 594   }
 595   if (newline) {
 596     tty-&gt;cr();
 597   }
 598 JRT_END
 599 
 600 JRT_ENTRY(jint, JVMCIRuntime::identity_hash_code(JavaThread* thread, oopDesc* obj))
 601   return (jint) obj-&gt;identity_hash();
 602 JRT_END
 603 
 604 JRT_ENTRY(jint, JVMCIRuntime::test_deoptimize_call_int(JavaThread* thread, int value))
 605   deopt_caller();
 606   return (jint) value;
 607 JRT_END
 608 
 609 
 610 // private static JVMCIRuntime JVMCI.initializeRuntime()
 611 JVM_ENTRY_NO_ENV(jobject, JVM_GetJVMCIRuntime(JNIEnv *env, jclass c))
 612   JNI_JVMCIENV(thread, env);
 613   if (!EnableJVMCI) {
 614     JVMCI_THROW_MSG_NULL(InternalError, &quot;JVMCI is not enabled&quot;);
 615   }
 616   JVMCIENV-&gt;runtime()-&gt;initialize_HotSpotJVMCIRuntime(JVMCI_CHECK_NULL);
 617   JVMCIObject runtime = JVMCIENV-&gt;runtime()-&gt;get_HotSpotJVMCIRuntime(JVMCI_CHECK_NULL);
 618   return JVMCIENV-&gt;get_jobject(runtime);
 619 JVM_END
 620 
 621 void JVMCIRuntime::call_getCompiler(TRAPS) {
 622   THREAD_JVMCIENV(JavaThread::current());
 623   JVMCIObject jvmciRuntime = JVMCIRuntime::get_HotSpotJVMCIRuntime(JVMCI_CHECK);
 624   initialize(JVMCIENV);
 625   JVMCIENV-&gt;call_HotSpotJVMCIRuntime_getCompiler(jvmciRuntime, JVMCI_CHECK);
 626 }
 627 
 628 void JVMCINMethodData::initialize(
 629   int nmethod_mirror_index,
 630   const char* name,
 631   FailedSpeculation** failed_speculations)
 632 {
 633   _failed_speculations = failed_speculations;
 634   _nmethod_mirror_index = nmethod_mirror_index;
 635   if (name != NULL) {
 636     _has_name = true;
 637     char* dest = (char*) this-&gt;name();
 638     strcpy(dest, name);
 639   } else {
 640     _has_name = false;
 641   }
 642 }
 643 
 644 void JVMCINMethodData::add_failed_speculation(nmethod* nm, jlong speculation) {
 645   uint index = (speculation &gt;&gt; 32) &amp; 0xFFFFFFFF;
 646   int length = (int) speculation;
 647   if (index + length &gt; (uint) nm-&gt;speculations_size()) {
 648     fatal(INTPTR_FORMAT &quot;[index: %d, length: %d] out of bounds wrt encoded speculations of length %u&quot;, speculation, index, length, nm-&gt;speculations_size());
 649   }
 650   address data = nm-&gt;speculations_begin() + index;
 651   FailedSpeculation::add_failed_speculation(nm, _failed_speculations, data, length);
 652 }
 653 
 654 oop JVMCINMethodData::get_nmethod_mirror(nmethod* nm, bool phantom_ref) {
 655   if (_nmethod_mirror_index == -1) {
 656     return NULL;
 657   }
 658   if (phantom_ref) {
 659     return nm-&gt;oop_at_phantom(_nmethod_mirror_index);
 660   } else {
 661     return nm-&gt;oop_at(_nmethod_mirror_index);
 662   }
 663 }
 664 
 665 void JVMCINMethodData::set_nmethod_mirror(nmethod* nm, oop new_mirror) {
 666   assert(_nmethod_mirror_index != -1, &quot;cannot set JVMCI mirror for nmethod&quot;);
 667   oop* addr = nm-&gt;oop_addr_at(_nmethod_mirror_index);
 668   assert(new_mirror != NULL, &quot;use clear_nmethod_mirror to clear the mirror&quot;);
 669   assert(*addr == NULL, &quot;cannot overwrite non-null mirror&quot;);
 670 
 671   *addr = new_mirror;
 672 
 673   // Since we&#39;ve patched some oops in the nmethod,
 674   // (re)register it with the heap.
 675   MutexLocker ml(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 676   Universe::heap()-&gt;register_nmethod(nm);
 677 }
 678 
 679 void JVMCINMethodData::clear_nmethod_mirror(nmethod* nm) {
 680   if (_nmethod_mirror_index != -1) {
 681     oop* addr = nm-&gt;oop_addr_at(_nmethod_mirror_index);
 682     *addr = NULL;
 683   }
 684 }
 685 
 686 void JVMCINMethodData::invalidate_nmethod_mirror(nmethod* nm) {
 687   oop nmethod_mirror = get_nmethod_mirror(nm, /* phantom_ref */ false);
 688   if (nmethod_mirror == NULL) {
 689     return;
 690   }
 691 
 692   // Update the values in the mirror if it still refers to nm.
 693   // We cannot use JVMCIObject to wrap the mirror as this is called
 694   // during GC, forbidding the creation of JNIHandles.
 695   JVMCIEnv* jvmciEnv = NULL;
 696   nmethod* current = (nmethod*) HotSpotJVMCI::InstalledCode::address(jvmciEnv, nmethod_mirror);
 697   if (nm == current) {
 698     if (!nm-&gt;is_alive()) {
 699       // Break the link from the mirror to nm such that
 700       // future invocations via the mirror will result in
 701       // an InvalidInstalledCodeException.
 702       HotSpotJVMCI::InstalledCode::set_address(jvmciEnv, nmethod_mirror, 0);
 703       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);
 704     } else if (nm-&gt;is_not_entrant()) {
 705       // Zero the entry point so any new invocation will fail but keep
 706       // the address link around that so that existing activations can
 707       // be deoptimized via the mirror (i.e. JVMCIEnv::invalidate_installed_code).
 708       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);
 709     }
 710   }
 711 }
 712 
 713 JVMCIRuntime::JVMCIRuntime(int id) {
 714   _init_state = uninitialized;
 715   _shared_library_javavm = NULL;
 716   _id = id;
 717   _metadata_handles = new MetadataHandles();
 718   JVMCI_event_1(&quot;created new JVMCI runtime %d (&quot; PTR_FORMAT &quot;)&quot;, id, p2i(this));
 719 }
 720 
 721 // Handles to objects in the Hotspot heap.
 722 static OopStorage* object_handles() {
 723   return Universe::vm_global();
 724 }
 725 
 726 jobject JVMCIRuntime::make_global(const Handle&amp; obj) {
 727   assert(!Universe::heap()-&gt;is_gc_active(), &quot;can&#39;t extend the root set during GC&quot;);
 728   assert(oopDesc::is_oop(obj()), &quot;not an oop&quot;);
 729   oop* ptr = object_handles()-&gt;allocate();
 730   jobject res = NULL;
 731   if (ptr != NULL) {
 732     assert(*ptr == NULL, &quot;invariant&quot;);
 733     NativeAccess&lt;&gt;::oop_store(ptr, obj());
 734     res = reinterpret_cast&lt;jobject&gt;(ptr);
 735   } else {
 736     vm_exit_out_of_memory(sizeof(oop), OOM_MALLOC_ERROR,
 737                           &quot;Cannot create JVMCI oop handle&quot;);
 738   }
 739   MutexLocker ml(JVMCI_lock);
 740   return res;
 741 }
 742 
 743 void JVMCIRuntime::destroy_global(jobject handle) {
 744   // Assert before nulling out, for better debugging.
 745   assert(is_global_handle(handle), &quot;precondition&quot;);
 746   oop* oop_ptr = reinterpret_cast&lt;oop*&gt;(handle);
 747   NativeAccess&lt;&gt;::oop_store(oop_ptr, (oop)NULL);
 748   object_handles()-&gt;release(oop_ptr);
 749   MutexLocker ml(JVMCI_lock);
 750 }
 751 
 752 bool JVMCIRuntime::is_global_handle(jobject handle) {
 753   const oop* ptr = reinterpret_cast&lt;oop*&gt;(handle);
 754   return object_handles()-&gt;allocation_status(ptr) == OopStorage::ALLOCATED_ENTRY;
 755 }
 756 
 757 jmetadata JVMCIRuntime::allocate_handle(const methodHandle&amp; handle) {
 758   MutexLocker ml(JVMCI_lock);
 759   return _metadata_handles-&gt;allocate_handle(handle);
 760 }
 761 
 762 jmetadata JVMCIRuntime::allocate_handle(const constantPoolHandle&amp; handle) {
 763   MutexLocker ml(JVMCI_lock);
 764   return _metadata_handles-&gt;allocate_handle(handle);
 765 }
 766 
 767 void JVMCIRuntime::release_handle(jmetadata handle) {
 768   MutexLocker ml(JVMCI_lock);
 769   _metadata_handles-&gt;chain_free_list(handle);
 770 }
 771 
 772 // Function for redirecting shared library JavaVM output to tty
 773 static void _log(const char* buf, size_t count) {
 774   tty-&gt;write((char*) buf, count);
 775 }
 776 
 777 // Function for shared library JavaVM to flush tty
 778 static void _flush_log() {
 779   tty-&gt;flush();
 780 }
 781 
 782 // Function for shared library JavaVM to exit HotSpot on a fatal error
 783 static void _fatal() {
 784   fatal(&quot;Fatal error in JVMCI shared library&quot;);
 785 }
 786 
 787 JNIEnv* JVMCIRuntime::init_shared_library_javavm() {
 788   JavaVM* javaVM = (JavaVM*) _shared_library_javavm;
 789   if (javaVM == NULL) {
 790     MutexLocker locker(JVMCI_lock);
 791     // Check again under JVMCI_lock
 792     javaVM = (JavaVM*) _shared_library_javavm;
 793     if (javaVM != NULL) {
 794       return NULL;
 795     }
 796     char* sl_path;
 797     void* sl_handle = JVMCI::get_shared_library(sl_path, true);
 798 
 799     jint (*JNI_CreateJavaVM)(JavaVM **pvm, void **penv, void *args);
 800     typedef jint (*JNI_CreateJavaVM_t)(JavaVM **pvm, void **penv, void *args);
 801 
 802     JNI_CreateJavaVM = CAST_TO_FN_PTR(JNI_CreateJavaVM_t, os::dll_lookup(sl_handle, &quot;JNI_CreateJavaVM&quot;));
 803     if (JNI_CreateJavaVM == NULL) {
 804       fatal(&quot;Unable to find JNI_CreateJavaVM in %s&quot;, sl_path);
 805     }
 806 
 807     ResourceMark rm;
 808     JavaVMInitArgs vm_args;
 809     vm_args.version = JNI_VERSION_1_2;
 810     vm_args.ignoreUnrecognized = JNI_TRUE;
 811     JavaVMOption options[4];
 812     jlong javaVM_id = 0;
 813 
 814     // Protocol: JVMCI shared library JavaVM should support a non-standard &quot;_javavm_id&quot;
 815     // option whose extraInfo info field is a pointer to which a unique id for the
 816     // JavaVM should be written.
 817     options[0].optionString = (char*) &quot;_javavm_id&quot;;
 818     options[0].extraInfo = &amp;javaVM_id;
 819 
 820     options[1].optionString = (char*) &quot;_log&quot;;
 821     options[1].extraInfo = (void*) _log;
 822     options[2].optionString = (char*) &quot;_flush_log&quot;;
 823     options[2].extraInfo = (void*) _flush_log;
 824     options[3].optionString = (char*) &quot;_fatal&quot;;
 825     options[3].extraInfo = (void*) _fatal;
 826 
 827     vm_args.version = JNI_VERSION_1_2;
 828     vm_args.options = options;
 829     vm_args.nOptions = sizeof(options) / sizeof(JavaVMOption);
 830 
 831     JNIEnv* env = NULL;
 832     int result = (*JNI_CreateJavaVM)(&amp;javaVM, (void**) &amp;env, &amp;vm_args);
 833     if (result == JNI_OK) {
 834       guarantee(env != NULL, &quot;missing env&quot;);
 835       _shared_library_javavm = javaVM;
 836       JVMCI_event_1(&quot;created JavaVM[%ld]@&quot; PTR_FORMAT &quot; for JVMCI runtime %d&quot;, javaVM_id, p2i(javaVM), _id);
 837       return env;
 838     } else {
 839       fatal(&quot;JNI_CreateJavaVM failed with return value %d&quot;, result);
 840     }
 841   }
 842   return NULL;
 843 }
 844 
 845 void JVMCIRuntime::init_JavaVM_info(jlongArray info, JVMCI_TRAPS) {
 846   if (info != NULL) {
 847     typeArrayOop info_oop = (typeArrayOop) JNIHandles::resolve(info);
 848     if (info_oop-&gt;length() &lt; 4) {
 849       JVMCI_THROW_MSG(ArrayIndexOutOfBoundsException, err_msg(&quot;%d &lt; 4&quot;, info_oop-&gt;length()));
 850     }
 851     JavaVM* javaVM = (JavaVM*) _shared_library_javavm;
 852     info_oop-&gt;long_at_put(0, (jlong) (address) javaVM);
 853     info_oop-&gt;long_at_put(1, (jlong) (address) javaVM-&gt;functions-&gt;reserved0);
 854     info_oop-&gt;long_at_put(2, (jlong) (address) javaVM-&gt;functions-&gt;reserved1);
 855     info_oop-&gt;long_at_put(3, (jlong) (address) javaVM-&gt;functions-&gt;reserved2);
 856   }
 857 }
 858 
 859 #define JAVAVM_CALL_BLOCK                                             \
 860   guarantee(thread != NULL &amp;&amp; _shared_library_javavm != NULL, &quot;npe&quot;); \
 861   ThreadToNativeFromVM ttnfv(thread);                                 \
 862   JavaVM* javavm = (JavaVM*) _shared_library_javavm;
 863 
 864 jint JVMCIRuntime::AttachCurrentThread(JavaThread* thread, void **penv, void *args) {
 865   JAVAVM_CALL_BLOCK
 866   return javavm-&gt;AttachCurrentThread(penv, args);
 867 }
 868 
 869 jint JVMCIRuntime::AttachCurrentThreadAsDaemon(JavaThread* thread, void **penv, void *args) {
 870   JAVAVM_CALL_BLOCK
 871   return javavm-&gt;AttachCurrentThreadAsDaemon(penv, args);
 872 }
 873 
 874 jint JVMCIRuntime::DetachCurrentThread(JavaThread* thread) {
 875   JAVAVM_CALL_BLOCK
 876   return javavm-&gt;DetachCurrentThread();
 877 }
 878 
 879 jint JVMCIRuntime::GetEnv(JavaThread* thread, void **penv, jint version) {
 880   JAVAVM_CALL_BLOCK
 881   return javavm-&gt;GetEnv(penv, version);
 882 }
 883 #undef JAVAVM_CALL_BLOCK                                             \
 884 
 885 void JVMCIRuntime::initialize_HotSpotJVMCIRuntime(JVMCI_TRAPS) {
 886   if (is_HotSpotJVMCIRuntime_initialized()) {
 887     if (JVMCIENV-&gt;is_hotspot() &amp;&amp; UseJVMCINativeLibrary) {
 888       JVMCI_THROW_MSG(InternalError, &quot;JVMCI has already been enabled in the JVMCI shared library&quot;);
 889     }
 890   }
 891 
 892   initialize(JVMCIENV);
 893 
 894   // This should only be called in the context of the JVMCI class being initialized
 895   JVMCIObject result = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_runtime(JVMCI_CHECK);
 896 
 897   _HotSpotJVMCIRuntime_instance = JVMCIENV-&gt;make_global(result);
 898   JVMCI::_is_initialized = true;
 899 }
 900 
 901 void JVMCIRuntime::initialize(JVMCIEnv* JVMCIENV) {
 902   // Check first without JVMCI_lock
 903   if (_init_state == fully_initialized) {
 904     return;
 905   }
 906 
 907   MutexLocker locker(JVMCI_lock);
 908   // Check again under JVMCI_lock
 909   if (_init_state == fully_initialized) {
 910     return;
 911   }
 912 
 913   while (_init_state == being_initialized) {
 914     JVMCI_event_1(&quot;waiting for initialization of JVMCI runtime %d&quot;, _id);
 915     JVMCI_lock-&gt;wait();
 916     if (_init_state == fully_initialized) {
 917       JVMCI_event_1(&quot;done waiting for initialization of JVMCI runtime %d&quot;, _id);
 918       return;
 919     }
 920   }
 921 
 922   JVMCI_event_1(&quot;initializing JVMCI runtime %d&quot;, _id);
 923   _init_state = being_initialized;
 924 
 925   {
 926     MutexUnlocker unlock(JVMCI_lock);
 927 
<a name="1" id="anc1"></a>

 928     JavaThread* THREAD = JavaThread::current();
<a name="2" id="anc2"></a><span class="line-added"> 929     HandleMark hm(THREAD);</span>
<span class="line-added"> 930     ResourceMark rm(THREAD);</span>
 931     if (JVMCIENV-&gt;is_hotspot()) {
 932       HotSpotJVMCI::compute_offsets(CHECK_EXIT);
 933     } else {
 934       JNIAccessMark jni(JVMCIENV);
 935 
 936       JNIJVMCI::initialize_ids(jni.env());
 937       if (jni()-&gt;ExceptionCheck()) {
 938         jni()-&gt;ExceptionDescribe();
 939         fatal(&quot;JNI exception during init&quot;);
 940       }
 941     }
 942 
 943     if (!JVMCIENV-&gt;is_hotspot()) {
 944       JNIAccessMark jni(JVMCIENV, THREAD);
 945       JNIJVMCI::register_natives(jni.env());
 946     }
 947     create_jvmci_primitive_type(T_BOOLEAN, JVMCI_CHECK_EXIT_((void)0));
 948     create_jvmci_primitive_type(T_BYTE, JVMCI_CHECK_EXIT_((void)0));
 949     create_jvmci_primitive_type(T_CHAR, JVMCI_CHECK_EXIT_((void)0));
 950     create_jvmci_primitive_type(T_SHORT, JVMCI_CHECK_EXIT_((void)0));
 951     create_jvmci_primitive_type(T_INT, JVMCI_CHECK_EXIT_((void)0));
 952     create_jvmci_primitive_type(T_LONG, JVMCI_CHECK_EXIT_((void)0));
 953     create_jvmci_primitive_type(T_FLOAT, JVMCI_CHECK_EXIT_((void)0));
 954     create_jvmci_primitive_type(T_DOUBLE, JVMCI_CHECK_EXIT_((void)0));
 955     create_jvmci_primitive_type(T_VOID, JVMCI_CHECK_EXIT_((void)0));
 956 
 957     if (!JVMCIENV-&gt;is_hotspot()) {
 958       JVMCIENV-&gt;copy_saved_properties();
 959     }
 960   }
 961 
 962   _init_state = fully_initialized;
 963   JVMCI_event_1(&quot;initialized JVMCI runtime %d&quot;, _id);
 964   JVMCI_lock-&gt;notify_all();
 965 }
 966 
 967 JVMCIObject JVMCIRuntime::create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS) {
 968   Thread* THREAD = Thread::current();
 969   // These primitive types are long lived and are created before the runtime is fully set up
 970   // so skip registering them for scanning.
 971   JVMCIObject mirror = JVMCIENV-&gt;get_object_constant(java_lang_Class::primitive_mirror(type), false, true);
 972   if (JVMCIENV-&gt;is_hotspot()) {
 973     JavaValue result(T_OBJECT);
 974     JavaCallArguments args;
 975     args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(mirror)));
 976     args.push_int(type2char(type));
 977     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotResolvedPrimitiveType::klass(), vmSymbols::fromMetaspace_name(), vmSymbols::primitive_fromMetaspace_signature(), &amp;args, CHECK_(JVMCIObject()));
 978 
 979     return JVMCIENV-&gt;wrap(JNIHandles::make_local((oop)result.get_jobject()));
 980   } else {
 981     JNIAccessMark jni(JVMCIENV);
 982     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedPrimitiveType::clazz(),
 983                                            JNIJVMCI::HotSpotResolvedPrimitiveType_fromMetaspace_method(),
 984                                            mirror.as_jobject(), type2char(type));
 985     if (jni()-&gt;ExceptionCheck()) {
 986       return JVMCIObject();
 987     }
 988     return JVMCIENV-&gt;wrap(result);
 989   }
 990 }
 991 
 992 void JVMCIRuntime::initialize_JVMCI(JVMCI_TRAPS) {
 993   if (!is_HotSpotJVMCIRuntime_initialized()) {
 994     initialize(JVMCI_CHECK);
 995     JVMCIENV-&gt;call_JVMCI_getRuntime(JVMCI_CHECK);
 996   }
 997 }
 998 
 999 JVMCIObject JVMCIRuntime::get_HotSpotJVMCIRuntime(JVMCI_TRAPS) {
1000   initialize(JVMCIENV);
1001   initialize_JVMCI(JVMCI_CHECK_(JVMCIObject()));
1002   return _HotSpotJVMCIRuntime_instance;
1003 }
1004 
1005 // private static void CompilerToVM.registerNatives()
1006 JVM_ENTRY_NO_ENV(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))
1007   JNI_JVMCIENV(thread, env);
1008 
1009   if (!EnableJVMCI) {
1010     JVMCI_THROW_MSG(InternalError, &quot;JVMCI is not enabled&quot;);
1011   }
1012 
1013   JVMCIENV-&gt;runtime()-&gt;initialize(JVMCIENV);
1014 
1015   {
<a name="3" id="anc3"></a><span class="line-modified">1016     ResourceMark rm(thread);</span>
1017     HandleMark hm(thread);
1018     ThreadToNativeFromVM trans(thread);
1019 
1020     // Ensure _non_oop_bits is initialized
1021     Universe::non_oop_word();
1022 
1023     if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods, CompilerToVM::methods_count())) {
1024       if (!env-&gt;ExceptionCheck()) {
1025         for (int i = 0; i &lt; CompilerToVM::methods_count(); i++) {
1026           if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods + i, 1)) {
1027             guarantee(false, &quot;Error registering JNI method %s%s&quot;, CompilerToVM::methods[i].name, CompilerToVM::methods[i].signature);
1028             break;
1029           }
1030         }
1031       } else {
1032         env-&gt;ExceptionDescribe();
1033       }
1034       guarantee(false, &quot;Failed registering CompilerToVM native methods&quot;);
1035     }
1036   }
1037 JVM_END
1038 
1039 
1040 void JVMCIRuntime::shutdown() {
1041   if (_HotSpotJVMCIRuntime_instance.is_non_null()) {
1042     JVMCI_event_1(&quot;shutting down HotSpotJVMCIRuntime for JVMCI runtime %d&quot;, _id);
1043     JVMCIEnv __stack_jvmci_env__(JavaThread::current(), _HotSpotJVMCIRuntime_instance.is_hotspot(), __FILE__, __LINE__);
1044     JVMCIEnv* JVMCIENV = &amp;__stack_jvmci_env__;
1045     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_shutdown(_HotSpotJVMCIRuntime_instance);
1046     JVMCI_event_1(&quot;shut down HotSpotJVMCIRuntime for JVMCI runtime %d&quot;, _id);
1047   }
1048 }
1049 
1050 void JVMCIRuntime::bootstrap_finished(TRAPS) {
1051   if (_HotSpotJVMCIRuntime_instance.is_non_null()) {
1052     THREAD_JVMCIENV(JavaThread::current());
1053     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_bootstrapFinished(_HotSpotJVMCIRuntime_instance, JVMCIENV);
1054   }
1055 }
1056 
1057 void JVMCIRuntime::describe_pending_hotspot_exception(JavaThread* THREAD, bool clear) {
1058   if (HAS_PENDING_EXCEPTION) {
1059     Handle exception(THREAD, PENDING_EXCEPTION);
1060     const char* exception_file = THREAD-&gt;exception_file();
1061     int exception_line = THREAD-&gt;exception_line();
1062     CLEAR_PENDING_EXCEPTION;
1063     if (exception-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {
1064       // Don&#39;t print anything if we are being killed.
1065     } else {
1066       java_lang_Throwable::print_stack_trace(exception, tty);
1067 
1068       // Clear and ignore any exceptions raised during printing
1069       CLEAR_PENDING_EXCEPTION;
1070     }
1071     if (!clear) {
1072       THREAD-&gt;set_pending_exception(exception(), exception_file, exception_line);
1073     }
1074   }
1075 }
1076 
1077 
1078 void JVMCIRuntime::exit_on_pending_exception(JVMCIEnv* JVMCIENV, const char* message) {
1079   JavaThread* THREAD = JavaThread::current();
1080 
1081   static volatile int report_error = 0;
1082   if (!report_error &amp;&amp; Atomic::cmpxchg(&amp;report_error, 0, 1) == 0) {
1083     // Only report an error once
1084     tty-&gt;print_raw_cr(message);
1085     if (JVMCIENV != NULL) {
1086       JVMCIENV-&gt;describe_pending_exception(true);
1087     } else {
1088       describe_pending_hotspot_exception(THREAD, true);
1089     }
1090   } else {
1091     // Allow error reporting thread to print the stack trace.
1092     THREAD-&gt;sleep(200);
1093   }
1094 
1095   before_exit(THREAD);
1096   vm_exit(-1);
1097 }
1098 
1099 // ------------------------------------------------------------------
1100 // Note: the logic of this method should mirror the logic of
1101 // constantPoolOopDesc::verify_constant_pool_resolve.
1102 bool JVMCIRuntime::check_klass_accessibility(Klass* accessing_klass, Klass* resolved_klass) {
1103   if (accessing_klass-&gt;is_objArray_klass()) {
1104     accessing_klass = ObjArrayKlass::cast(accessing_klass)-&gt;bottom_klass();
1105   }
1106   if (!accessing_klass-&gt;is_instance_klass()) {
1107     return true;
1108   }
1109 
1110   if (resolved_klass-&gt;is_objArray_klass()) {
1111     // Find the element klass, if this is an array.
1112     resolved_klass = ObjArrayKlass::cast(resolved_klass)-&gt;bottom_klass();
1113   }
1114   if (resolved_klass-&gt;is_instance_klass()) {
1115     Reflection::VerifyClassAccessResults result =
1116       Reflection::verify_class_access(accessing_klass, InstanceKlass::cast(resolved_klass), true);
1117     return result == Reflection::ACCESS_OK;
1118   }
1119   return true;
1120 }
1121 
1122 // ------------------------------------------------------------------
1123 Klass* JVMCIRuntime::get_klass_by_name_impl(Klass*&amp; accessing_klass,
1124                                           const constantPoolHandle&amp; cpool,
1125                                           Symbol* sym,
1126                                           bool require_local) {
1127   JVMCI_EXCEPTION_CONTEXT;
1128 
1129   // Now we need to check the SystemDictionary
1130   if (sym-&gt;char_at(0) == JVM_SIGNATURE_CLASS &amp;&amp;
1131       sym-&gt;char_at(sym-&gt;utf8_length()-1) == JVM_SIGNATURE_ENDCLASS) {
1132     // This is a name from a signature.  Strip off the trimmings.
1133     // Call recursive to keep scope of strippedsym.
1134     TempNewSymbol strippedsym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,
1135                                                         sym-&gt;utf8_length()-2);
1136     return get_klass_by_name_impl(accessing_klass, cpool, strippedsym, require_local);
1137   }
1138 
1139   Handle loader(THREAD, (oop)NULL);
1140   Handle domain(THREAD, (oop)NULL);
1141   if (accessing_klass != NULL) {
1142     loader = Handle(THREAD, accessing_klass-&gt;class_loader());
1143     domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
1144   }
1145 
1146   Klass* found_klass;
1147   {
1148     ttyUnlocker ttyul;  // release tty lock to avoid ordering problems
1149     MutexLocker ml(Compile_lock);
1150     if (!require_local) {
1151       found_klass = SystemDictionary::find_constrained_instance_or_array_klass(sym, loader, CHECK_NULL);
1152     } else {
1153       found_klass = SystemDictionary::find_instance_or_array_klass(sym, loader, domain, CHECK_NULL);
1154     }
1155   }
1156 
1157   // If we fail to find an array klass, look again for its element type.
1158   // The element type may be available either locally or via constraints.
1159   // In either case, if we can find the element type in the system dictionary,
1160   // we must build an array type around it.  The CI requires array klasses
1161   // to be loaded if their element klasses are loaded, except when memory
1162   // is exhausted.
1163   if (sym-&gt;char_at(0) == JVM_SIGNATURE_ARRAY &amp;&amp;
1164       (sym-&gt;char_at(1) == JVM_SIGNATURE_ARRAY || sym-&gt;char_at(1) == JVM_SIGNATURE_CLASS)) {
1165     // We have an unloaded array.
1166     // Build it on the fly if the element class exists.
1167     TempNewSymbol elem_sym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,
1168                                                      sym-&gt;utf8_length()-1);
1169 
1170     // Get element Klass recursively.
1171     Klass* elem_klass =
1172       get_klass_by_name_impl(accessing_klass,
1173                              cpool,
1174                              elem_sym,
1175                              require_local);
1176     if (elem_klass != NULL) {
1177       // Now make an array for it
1178       return elem_klass-&gt;array_klass(THREAD);
1179     }
1180   }
1181 
1182   if (found_klass == NULL &amp;&amp; !cpool.is_null() &amp;&amp; cpool-&gt;has_preresolution()) {
1183     // Look inside the constant pool for pre-resolved class entries.
1184     for (int i = cpool-&gt;length() - 1; i &gt;= 1; i--) {
1185       if (cpool-&gt;tag_at(i).is_klass()) {
1186         Klass*  kls = cpool-&gt;resolved_klass_at(i);
1187         if (kls-&gt;name() == sym) {
1188           return kls;
1189         }
1190       }
1191     }
1192   }
1193 
1194   return found_klass;
1195 }
1196 
1197 // ------------------------------------------------------------------
1198 Klass* JVMCIRuntime::get_klass_by_name(Klass* accessing_klass,
1199                                   Symbol* klass_name,
1200                                   bool require_local) {
1201   ResourceMark rm;
1202   constantPoolHandle cpool;
1203   return get_klass_by_name_impl(accessing_klass,
1204                                                  cpool,
1205                                                  klass_name,
1206                                                  require_local);
1207 }
1208 
1209 // ------------------------------------------------------------------
1210 // Implementation of get_klass_by_index.
1211 Klass* JVMCIRuntime::get_klass_by_index_impl(const constantPoolHandle&amp; cpool,
1212                                         int index,
1213                                         bool&amp; is_accessible,
1214                                         Klass* accessor) {
1215   JVMCI_EXCEPTION_CONTEXT;
1216   Klass* klass = ConstantPool::klass_at_if_loaded(cpool, index);
1217   Symbol* klass_name = NULL;
1218   if (klass == NULL) {
1219     klass_name = cpool-&gt;klass_name_at(index);
1220   }
1221 
1222   if (klass == NULL) {
1223     // Not found in constant pool.  Use the name to do the lookup.
1224     Klass* k = get_klass_by_name_impl(accessor,
1225                                         cpool,
1226                                         klass_name,
1227                                         false);
1228     // Calculate accessibility the hard way.
1229     if (k == NULL) {
1230       is_accessible = false;
1231     } else if (k-&gt;class_loader() != accessor-&gt;class_loader() &amp;&amp;
1232                get_klass_by_name_impl(accessor, cpool, k-&gt;name(), true) == NULL) {
1233       // Loaded only remotely.  Not linked yet.
1234       is_accessible = false;
1235     } else {
1236       // Linked locally, and we must also check public/private, etc.
1237       is_accessible = check_klass_accessibility(accessor, k);
1238     }
1239     if (!is_accessible) {
1240       return NULL;
1241     }
1242     return k;
1243   }
1244 
1245   // It is known to be accessible, since it was found in the constant pool.
1246   is_accessible = true;
1247   return klass;
1248 }
1249 
1250 // ------------------------------------------------------------------
1251 // Get a klass from the constant pool.
1252 Klass* JVMCIRuntime::get_klass_by_index(const constantPoolHandle&amp; cpool,
1253                                    int index,
1254                                    bool&amp; is_accessible,
1255                                    Klass* accessor) {
1256   ResourceMark rm;
1257   Klass* result = get_klass_by_index_impl(cpool, index, is_accessible, accessor);
1258   return result;
1259 }
1260 
1261 // ------------------------------------------------------------------
1262 // Implementation of get_field_by_index.
1263 //
1264 // Implementation note: the results of field lookups are cached
1265 // in the accessor klass.
1266 void JVMCIRuntime::get_field_by_index_impl(InstanceKlass* klass, fieldDescriptor&amp; field_desc,
1267                                         int index) {
1268   JVMCI_EXCEPTION_CONTEXT;
1269 
1270   assert(klass-&gt;is_linked(), &quot;must be linked before using its constant-pool&quot;);
1271 
1272   constantPoolHandle cpool(thread, klass-&gt;constants());
1273 
1274   // Get the field&#39;s name, signature, and type.
1275   Symbol* name  = cpool-&gt;name_ref_at(index);
1276 
1277   int nt_index = cpool-&gt;name_and_type_ref_index_at(index);
1278   int sig_index = cpool-&gt;signature_ref_index_at(nt_index);
1279   Symbol* signature = cpool-&gt;symbol_at(sig_index);
1280 
1281   // Get the field&#39;s declared holder.
1282   int holder_index = cpool-&gt;klass_ref_index_at(index);
1283   bool holder_is_accessible;
1284   Klass* declared_holder = get_klass_by_index(cpool, holder_index,
1285                                                holder_is_accessible,
1286                                                klass);
1287 
1288   // The declared holder of this field may not have been loaded.
1289   // Bail out with partial field information.
1290   if (!holder_is_accessible) {
1291     return;
1292   }
1293 
1294 
1295   // Perform the field lookup.
1296   Klass*  canonical_holder =
1297     InstanceKlass::cast(declared_holder)-&gt;find_field(name, signature, &amp;field_desc);
1298   if (canonical_holder == NULL) {
1299     return;
1300   }
1301 
1302   assert(canonical_holder == field_desc.field_holder(), &quot;just checking&quot;);
1303 }
1304 
1305 // ------------------------------------------------------------------
1306 // Get a field by index from a klass&#39;s constant pool.
1307 void JVMCIRuntime::get_field_by_index(InstanceKlass* accessor, fieldDescriptor&amp; fd, int index) {
1308   ResourceMark rm;
1309   return get_field_by_index_impl(accessor, fd, index);
1310 }
1311 
1312 // ------------------------------------------------------------------
1313 // Perform an appropriate method lookup based on accessor, holder,
1314 // name, signature, and bytecode.
1315 Method* JVMCIRuntime::lookup_method(InstanceKlass* accessor,
1316                                     Klass*        holder,
1317                                     Symbol*       name,
1318                                     Symbol*       sig,
1319                                     Bytecodes::Code bc,
1320                                     constantTag   tag) {
1321   // Accessibility checks are performed in JVMCIEnv::get_method_by_index_impl().
1322   assert(check_klass_accessibility(accessor, holder), &quot;holder not accessible&quot;);
1323 
1324   Method* dest_method;
1325   LinkInfo link_info(holder, name, sig, accessor, LinkInfo::needs_access_check, tag);
1326   switch (bc) {
1327   case Bytecodes::_invokestatic:
1328     dest_method =
1329       LinkResolver::resolve_static_call_or_null(link_info);
1330     break;
1331   case Bytecodes::_invokespecial:
1332     dest_method =
1333       LinkResolver::resolve_special_call_or_null(link_info);
1334     break;
1335   case Bytecodes::_invokeinterface:
1336     dest_method =
1337       LinkResolver::linktime_resolve_interface_method_or_null(link_info);
1338     break;
1339   case Bytecodes::_invokevirtual:
1340     dest_method =
1341       LinkResolver::linktime_resolve_virtual_method_or_null(link_info);
1342     break;
1343   default: ShouldNotReachHere();
1344   }
1345 
1346   return dest_method;
1347 }
1348 
1349 
1350 // ------------------------------------------------------------------
1351 Method* JVMCIRuntime::get_method_by_index_impl(const constantPoolHandle&amp; cpool,
1352                                                int index, Bytecodes::Code bc,
1353                                                InstanceKlass* accessor) {
1354   if (bc == Bytecodes::_invokedynamic) {
1355     ConstantPoolCacheEntry* cpce = cpool-&gt;invokedynamic_cp_cache_entry_at(index);
1356     bool is_resolved = !cpce-&gt;is_f1_null();
1357     if (is_resolved) {
1358       // Get the invoker Method* from the constant pool.
1359       // (The appendix argument, if any, will be noted in the method&#39;s signature.)
1360       Method* adapter = cpce-&gt;f1_as_method();
1361       return adapter;
1362     }
1363 
1364     return NULL;
1365   }
1366 
1367   int holder_index = cpool-&gt;klass_ref_index_at(index);
1368   bool holder_is_accessible;
1369   Klass* holder = get_klass_by_index_impl(cpool, holder_index, holder_is_accessible, accessor);
1370 
1371   // Get the method&#39;s name and signature.
1372   Symbol* name_sym = cpool-&gt;name_ref_at(index);
1373   Symbol* sig_sym  = cpool-&gt;signature_ref_at(index);
1374 
1375   if (cpool-&gt;has_preresolution()
1376       || ((holder == SystemDictionary::MethodHandle_klass() || holder == SystemDictionary::VarHandle_klass()) &amp;&amp;
1377           MethodHandles::is_signature_polymorphic_name(holder, name_sym))) {
1378     // Short-circuit lookups for JSR 292-related call sites.
1379     // That is, do not rely only on name-based lookups, because they may fail
1380     // if the names are not resolvable in the boot class loader (7056328).
1381     switch (bc) {
1382     case Bytecodes::_invokevirtual:
1383     case Bytecodes::_invokeinterface:
1384     case Bytecodes::_invokespecial:
1385     case Bytecodes::_invokestatic:
1386       {
1387         Method* m = ConstantPool::method_at_if_loaded(cpool, index);
1388         if (m != NULL) {
1389           return m;
1390         }
1391       }
1392       break;
1393     default:
1394       break;
1395     }
1396   }
1397 
1398   if (holder_is_accessible) { // Our declared holder is loaded.
1399     constantTag tag = cpool-&gt;tag_ref_at(index);
1400     Method* m = lookup_method(accessor, holder, name_sym, sig_sym, bc, tag);
1401     if (m != NULL) {
1402       // We found the method.
1403       return m;
1404     }
1405   }
1406 
1407   // Either the declared holder was not loaded, or the method could
1408   // not be found.
1409 
1410   return NULL;
1411 }
1412 
1413 // ------------------------------------------------------------------
1414 InstanceKlass* JVMCIRuntime::get_instance_klass_for_declared_method_holder(Klass* method_holder) {
1415   // For the case of &lt;array&gt;.clone(), the method holder can be an ArrayKlass*
1416   // instead of an InstanceKlass*.  For that case simply pretend that the
1417   // declared holder is Object.clone since that&#39;s where the call will bottom out.
1418   if (method_holder-&gt;is_instance_klass()) {
1419     return InstanceKlass::cast(method_holder);
1420   } else if (method_holder-&gt;is_array_klass()) {
1421     return SystemDictionary::Object_klass();
1422   } else {
1423     ShouldNotReachHere();
1424   }
1425   return NULL;
1426 }
1427 
1428 
1429 // ------------------------------------------------------------------
1430 Method* JVMCIRuntime::get_method_by_index(const constantPoolHandle&amp; cpool,
1431                                      int index, Bytecodes::Code bc,
1432                                      InstanceKlass* accessor) {
1433   ResourceMark rm;
1434   return get_method_by_index_impl(cpool, index, bc, accessor);
1435 }
1436 
1437 // ------------------------------------------------------------------
1438 // Check for changes to the system dictionary during compilation
1439 // class loads, evolution, breakpoints
1440 JVMCI::CodeInstallResult JVMCIRuntime::validate_compile_task_dependencies(Dependencies* dependencies, JVMCICompileState* compile_state, char** failure_detail) {
1441   // If JVMTI capabilities were enabled during compile, the compilation is invalidated.
1442   if (compile_state != NULL &amp;&amp; compile_state-&gt;jvmti_state_changed()) {
1443     *failure_detail = (char*) &quot;Jvmti state change during compilation invalidated dependencies&quot;;
1444     return JVMCI::dependencies_failed;
1445   }
1446 
1447   CompileTask* task = compile_state == NULL ? NULL : compile_state-&gt;task();
1448   Dependencies::DepType result = dependencies-&gt;validate_dependencies(task, failure_detail);
1449   if (result == Dependencies::end_marker) {
1450     return JVMCI::ok;
1451   }
1452 
1453   return JVMCI::dependencies_failed;
1454 }
1455 
1456 // Reports a pending exception and exits the VM.
1457 static void fatal_exception_in_compile(JVMCIEnv* JVMCIENV, JavaThread* thread, const char* msg) {
1458   // Only report a fatal JVMCI compilation exception once
1459   static volatile int report_init_failure = 0;
1460   if (!report_init_failure &amp;&amp; Atomic::cmpxchg(&amp;report_init_failure, 0, 1) == 0) {
1461       tty-&gt;print_cr(&quot;%s:&quot;, msg);
1462       JVMCIENV-&gt;describe_pending_exception(true);
1463   }
1464   JVMCIENV-&gt;clear_pending_exception();
1465   before_exit(thread);
1466   vm_exit(-1);
1467 }
1468 
1469 void JVMCIRuntime::compile_method(JVMCIEnv* JVMCIENV, JVMCICompiler* compiler, const methodHandle&amp; method, int entry_bci) {
1470   JVMCI_EXCEPTION_CONTEXT
1471 
1472   JVMCICompileState* compile_state = JVMCIENV-&gt;compile_state();
1473 
1474   bool is_osr = entry_bci != InvocationEntryBci;
1475   if (compiler-&gt;is_bootstrapping() &amp;&amp; is_osr) {
1476     // no OSR compilations during bootstrap - the compiler is just too slow at this point,
1477     // and we know that there are no endless loops
1478     compile_state-&gt;set_failure(true, &quot;No OSR during bootstrap&quot;);
1479     return;
1480   }
1481   if (JVMCI::in_shutdown()) {
1482     compile_state-&gt;set_failure(false, &quot;Avoiding compilation during shutdown&quot;);
1483     return;
1484   }
1485 
<a name="4" id="anc4"></a><span class="line-modified">1486   HandleMark hm(thread);</span>
1487   JVMCIObject receiver = get_HotSpotJVMCIRuntime(JVMCIENV);
1488   if (JVMCIENV-&gt;has_pending_exception()) {
1489     fatal_exception_in_compile(JVMCIENV, thread, &quot;Exception during HotSpotJVMCIRuntime initialization&quot;);
1490   }
1491   JVMCIObject jvmci_method = JVMCIENV-&gt;get_jvmci_method(method, JVMCIENV);
1492   if (JVMCIENV-&gt;has_pending_exception()) {
1493     JVMCIENV-&gt;describe_pending_exception(true);
1494     compile_state-&gt;set_failure(false, &quot;exception getting JVMCI wrapper method&quot;);
1495     return;
1496   }
1497 
1498   JVMCIObject result_object = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_compileMethod(receiver, jvmci_method, entry_bci,
1499                                                                      (jlong) compile_state, compile_state-&gt;task()-&gt;compile_id());
1500   if (!JVMCIENV-&gt;has_pending_exception()) {
1501     if (result_object.is_non_null()) {
1502       JVMCIObject failure_message = JVMCIENV-&gt;get_HotSpotCompilationRequestResult_failureMessage(result_object);
1503       if (failure_message.is_non_null()) {
1504         // Copy failure reason into resource memory first ...
1505         const char* failure_reason = JVMCIENV-&gt;as_utf8_string(failure_message);
1506         // ... and then into the C heap.
1507         failure_reason = os::strdup(failure_reason, mtJVMCI);
1508         bool retryable = JVMCIENV-&gt;get_HotSpotCompilationRequestResult_retry(result_object) != 0;
1509         compile_state-&gt;set_failure(retryable, failure_reason, true);
1510       } else {
1511         if (compile_state-&gt;task()-&gt;code() == NULL) {
1512           compile_state-&gt;set_failure(true, &quot;no nmethod produced&quot;);
1513         } else {
1514           compile_state-&gt;task()-&gt;set_num_inlined_bytecodes(JVMCIENV-&gt;get_HotSpotCompilationRequestResult_inlinedBytecodes(result_object));
1515           compiler-&gt;inc_methods_compiled();
1516         }
1517       }
1518     } else {
1519       assert(false, &quot;JVMCICompiler.compileMethod should always return non-null&quot;);
1520     }
1521   } else {
1522     // An uncaught exception here implies failure during compiler initialization.
1523     // The only sensible thing to do here is to exit the VM.
1524     fatal_exception_in_compile(JVMCIENV, thread, &quot;Exception during JVMCI compiler initialization&quot;);
1525   }
1526   if (compiler-&gt;is_bootstrapping()) {
1527     compiler-&gt;set_bootstrap_compilation_request_handled();
1528   }
1529 }
1530 
1531 
1532 // ------------------------------------------------------------------
1533 JVMCI::CodeInstallResult JVMCIRuntime::register_method(JVMCIEnv* JVMCIENV,
1534                                 const methodHandle&amp; method,
1535                                 nmethod*&amp; nm,
1536                                 int entry_bci,
1537                                 CodeOffsets* offsets,
1538                                 int orig_pc_offset,
1539                                 CodeBuffer* code_buffer,
1540                                 int frame_words,
1541                                 OopMapSet* oop_map_set,
1542                                 ExceptionHandlerTable* handler_table,
1543                                 ImplicitExceptionTable* implicit_exception_table,
1544                                 AbstractCompiler* compiler,
1545                                 DebugInformationRecorder* debug_info,
1546                                 Dependencies* dependencies,
1547                                 int compile_id,
1548                                 bool has_unsafe_access,
1549                                 bool has_wide_vector,
1550                                 JVMCIObject compiled_code,
1551                                 JVMCIObject nmethod_mirror,
1552                                 FailedSpeculation** failed_speculations,
1553                                 char* speculations,
1554                                 int speculations_len) {
1555   JVMCI_EXCEPTION_CONTEXT;
1556   nm = NULL;
1557   int comp_level = CompLevel_full_optimization;
1558   char* failure_detail = NULL;
1559 
1560   bool install_default = JVMCIENV-&gt;get_HotSpotNmethod_isDefault(nmethod_mirror) != 0;
1561   assert(JVMCIENV-&gt;isa_HotSpotNmethod(nmethod_mirror), &quot;must be&quot;);
1562   JVMCIObject name = JVMCIENV-&gt;get_InstalledCode_name(nmethod_mirror);
1563   const char* nmethod_mirror_name = name.is_null() ? NULL : JVMCIENV-&gt;as_utf8_string(name);
1564   int nmethod_mirror_index;
1565   if (!install_default) {
1566     // Reserve or initialize mirror slot in the oops table.
1567     OopRecorder* oop_recorder = debug_info-&gt;oop_recorder();
1568     nmethod_mirror_index = oop_recorder-&gt;allocate_oop_index(nmethod_mirror.is_hotspot() ? nmethod_mirror.as_jobject() : NULL);
1569   } else {
1570     // A default HotSpotNmethod mirror is never tracked by the nmethod
1571     nmethod_mirror_index = -1;
1572   }
1573 
1574   JVMCI::CodeInstallResult result;
1575   {
1576     // To prevent compile queue updates.
1577     MutexLocker locker(THREAD, MethodCompileQueue_lock);
1578 
1579     // Prevent SystemDictionary::add_to_hierarchy from running
1580     // and invalidating our dependencies until we install this method.
1581     MutexLocker ml(Compile_lock);
1582 
1583     // Encode the dependencies now, so we can check them right away.
1584     dependencies-&gt;encode_content_bytes();
1585 
1586     // Record the dependencies for the current compile in the log
1587     if (LogCompilation) {
1588       for (Dependencies::DepStream deps(dependencies); deps.next(); ) {
1589         deps.log_dependency();
1590       }
1591     }
1592 
1593     // Check for {class loads, evolution, breakpoints} during compilation
1594     result = validate_compile_task_dependencies(dependencies, JVMCIENV-&gt;compile_state(), &amp;failure_detail);
1595     if (result != JVMCI::ok) {
1596       // While not a true deoptimization, it is a preemptive decompile.
1597       MethodData* mdp = method()-&gt;method_data();
1598       if (mdp != NULL) {
1599         mdp-&gt;inc_decompile_count();
1600 #ifdef ASSERT
1601         if (mdp-&gt;decompile_count() &gt; (uint)PerMethodRecompilationCutoff) {
1602           ResourceMark m;
1603           tty-&gt;print_cr(&quot;WARN: endless recompilation of %s. Method was set to not compilable.&quot;, method()-&gt;name_and_sig_as_C_string());
1604         }
1605 #endif
1606       }
1607 
1608       // All buffers in the CodeBuffer are allocated in the CodeCache.
1609       // If the code buffer is created on each compile attempt
1610       // as in C2, then it must be freed.
1611       //code_buffer-&gt;free_blob();
1612     } else {
1613       nm =  nmethod::new_nmethod(method,
1614                                  compile_id,
1615                                  entry_bci,
1616                                  offsets,
1617                                  orig_pc_offset,
1618                                  debug_info, dependencies, code_buffer,
1619                                  frame_words, oop_map_set,
1620                                  handler_table, implicit_exception_table,
1621                                  compiler, comp_level, NULL, 0,
1622                                  speculations, speculations_len,
1623                                  nmethod_mirror_index, nmethod_mirror_name, failed_speculations);
1624 
1625 
1626       // Free codeBlobs
1627       if (nm == NULL) {
1628         // The CodeCache is full.  Print out warning and disable compilation.
1629         {
1630           MutexUnlocker ml(Compile_lock);
1631           MutexUnlocker locker(MethodCompileQueue_lock);
1632           CompileBroker::handle_full_code_cache(CodeCache::get_code_blob_type(comp_level));
1633         }
1634       } else {
1635         nm-&gt;set_has_unsafe_access(has_unsafe_access);
1636         nm-&gt;set_has_wide_vectors(has_wide_vector);
1637 
1638         // Record successful registration.
1639         // (Put nm into the task handle *before* publishing to the Java heap.)
1640         if (JVMCIENV-&gt;compile_state() != NULL) {
1641           JVMCIENV-&gt;compile_state()-&gt;task()-&gt;set_code(nm);
1642         }
1643 
1644         JVMCINMethodData* data = nm-&gt;jvmci_nmethod_data();
1645         assert(data != NULL, &quot;must be&quot;);
1646         if (install_default) {
1647           assert(!nmethod_mirror.is_hotspot() || data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ false) == NULL, &quot;must be&quot;);
1648           if (entry_bci == InvocationEntryBci) {
1649             if (TieredCompilation) {
1650               // If there is an old version we&#39;re done with it
1651               CompiledMethod* old = method-&gt;code();
1652               if (TraceMethodReplacement &amp;&amp; old != NULL) {
1653                 ResourceMark rm;
1654                 char *method_name = method-&gt;name_and_sig_as_C_string();
1655                 tty-&gt;print_cr(&quot;Replacing method %s&quot;, method_name);
1656               }
1657               if (old != NULL ) {
1658                 old-&gt;make_not_entrant();
1659               }
1660             }
1661 
1662             LogTarget(Info, nmethod, install) lt;
1663             if (lt.is_enabled()) {
1664               ResourceMark rm;
1665               char *method_name = method-&gt;name_and_sig_as_C_string();
1666               lt.print(&quot;Installing method (%d) %s [entry point: %p]&quot;,
1667                         comp_level, method_name, nm-&gt;entry_point());
1668             }
1669             // Allow the code to be executed
1670             MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
1671             if (nm-&gt;make_in_use()) {
1672               method-&gt;set_code(method, nm);
1673             }
1674           } else {
1675             LogTarget(Info, nmethod, install) lt;
1676             if (lt.is_enabled()) {
1677               ResourceMark rm;
1678               char *method_name = method-&gt;name_and_sig_as_C_string();
1679               lt.print(&quot;Installing osr method (%d) %s @ %d&quot;,
1680                         comp_level, method_name, entry_bci);
1681             }
1682             MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
1683             if (nm-&gt;make_in_use()) {
1684               InstanceKlass::cast(method-&gt;method_holder())-&gt;add_osr_nmethod(nm);
1685             }
1686           }
1687         } else {
1688           assert(!nmethod_mirror.is_hotspot() || data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ false) == HotSpotJVMCI::resolve(nmethod_mirror), &quot;must be&quot;);
1689         }
1690       }
1691       result = nm != NULL ? JVMCI::ok :JVMCI::cache_full;
1692     }
1693   }
1694 
1695   // String creation must be done outside lock
1696   if (failure_detail != NULL) {
1697     // A failure to allocate the string is silently ignored.
1698     JVMCIObject message = JVMCIENV-&gt;create_string(failure_detail, JVMCIENV);
1699     JVMCIENV-&gt;set_HotSpotCompiledNmethod_installationFailureMessage(compiled_code, message);
1700   }
1701 
1702   // JVMTI -- compiled method notification (must be done outside lock)
1703   if (nm != NULL) {
1704     nm-&gt;post_compiled_method_load_event();
1705   }
1706 
1707   return result;
1708 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>