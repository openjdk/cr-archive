<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jvmci/jvmciCompilerToVM.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciCompiler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciEnv.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciCompilerToVM.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 802 
 803 C2V_VMENTRY_0(jlong, getMaxCallTargetOffset, (JNIEnv* env, jobject, jlong addr))
 804   address target_addr = (address) addr;
 805   if (target_addr != 0x0) {
 806     int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
 807     int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
 808     return MAX2(ABS(off_low), ABS(off_high));
 809   }
 810   return -1;
 811 C2V_END
 812 
 813 C2V_VMENTRY(void, setNotInlinableOrCompilable,(JNIEnv* env, jobject,  jobject jvmci_method))
 814   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 815   method-&gt;set_not_c1_compilable();
 816   method-&gt;set_not_c2_compilable();
 817   method-&gt;set_dont_inline(true);
 818 C2V_END
 819 
 820 C2V_VMENTRY_0(jint, installCode, (JNIEnv *env, jobject, jobject target, jobject compiled_code,
 821             jobject installed_code, jlong failed_speculations_address, jbyteArray speculations_obj))
<span class="line-modified"> 822   HandleMark hm;</span>
 823   JNIHandleMark jni_hm(thread);
 824 
 825   JVMCIObject target_handle = JVMCIENV-&gt;wrap(target);
 826   JVMCIObject compiled_code_handle = JVMCIENV-&gt;wrap(compiled_code);
 827   CodeBlob* cb = NULL;
 828   JVMCIObject installed_code_handle = JVMCIENV-&gt;wrap(installed_code);
 829   JVMCIPrimitiveArray speculations_handle = JVMCIENV-&gt;wrap(speculations_obj);
 830 
 831   int speculations_len = JVMCIENV-&gt;get_length(speculations_handle);
 832   char* speculations = NEW_RESOURCE_ARRAY(char, speculations_len);
 833   JVMCIENV-&gt;copy_bytes_to(speculations_handle, (jbyte*) speculations, 0, speculations_len);
 834 
 835   JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK_JNI_ERR);
 836 
 837   TraceTime install_time(&quot;installCode&quot;, JVMCICompiler::codeInstallTimer());
 838   bool is_immutable_PIC = JVMCIENV-&gt;get_HotSpotCompiledCode_isImmutablePIC(compiled_code_handle) &gt; 0;
 839 
 840   CodeInstaller installer(JVMCIENV, is_immutable_PIC);
 841   JVMCI::CodeInstallResult result = installer.install(compiler,
 842       target_handle,
</pre>
<hr />
<pre>
 863     assert(cb == NULL, &quot;should be&quot;);
 864   } else {
 865     if (installed_code_handle.is_non_null()) {
 866       if (cb-&gt;is_nmethod()) {
 867         assert(JVMCIENV-&gt;isa_HotSpotNmethod(installed_code_handle), &quot;wrong type&quot;);
 868         // Clear the link to an old nmethod first
 869         JVMCIObject nmethod_mirror = installed_code_handle;
 870         JVMCIENV-&gt;invalidate_nmethod_mirror(nmethod_mirror, JVMCI_CHECK_0);
 871       } else {
 872         assert(JVMCIENV-&gt;isa_InstalledCode(installed_code_handle), &quot;wrong type&quot;);
 873       }
 874       // Initialize the link to the new code blob
 875       JVMCIENV-&gt;initialize_installed_code(installed_code_handle, cb, JVMCI_CHECK_0);
 876     }
 877   }
 878   return result;
 879 C2V_END
 880 
 881 C2V_VMENTRY_0(jint, getMetadata, (JNIEnv *env, jobject, jobject target, jobject compiled_code, jobject metadata))
 882 #if INCLUDE_AOT
<span class="line-modified"> 883   HandleMark hm;</span>
 884   assert(JVMCIENV-&gt;is_hotspot(), &quot;AOT code is executed only in HotSpot mode&quot;);
 885 
 886   JVMCIObject target_handle = JVMCIENV-&gt;wrap(target);
 887   JVMCIObject compiled_code_handle = JVMCIENV-&gt;wrap(compiled_code);
 888   JVMCIObject metadata_handle = JVMCIENV-&gt;wrap(metadata);
 889 
 890   CodeMetadata code_metadata;
 891 
 892   CodeInstaller installer(JVMCIENV, true /* immutable PIC compilation */);
 893   JVMCI::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, JVMCI_CHECK_0);
 894   if (result != JVMCI::ok) {
 895     return result;
 896   }
 897 
 898   if (code_metadata.get_nr_pc_desc() &gt; 0) {
 899     int size = sizeof(PcDesc) * code_metadata.get_nr_pc_desc();
 900     JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));
 901     JVMCIENV-&gt;copy_bytes_from((jbyte*) code_metadata.get_pc_desc(), array, 0, size);
 902     HotSpotJVMCI::HotSpotMetaData::set_pcDescBytes(JVMCIENV, metadata_handle, array);
 903   }
</pre>
<hr />
<pre>
 951   JVMCIPrimitiveArray implicitExceptionArray = JVMCIENV-&gt;new_byteArray(implicit_table_size, JVMCI_CHECK_(JVMCI::cache_full));
 952   if (implicit_table_size &gt; 0) {
 953     implicit-&gt;copy_bytes_to((address) HotSpotJVMCI::resolve(implicitExceptionArray)-&gt;byte_at_addr(0), implicit_table_size);
 954   }
 955   HotSpotJVMCI::HotSpotMetaData::set_implicitExceptionBytes(JVMCIENV, metadata_handle, implicitExceptionArray);
 956 
 957   return result;
 958 #else
 959   JVMCI_THROW_MSG_0(InternalError, &quot;unimplemented&quot;);
 960 #endif
 961 C2V_END
 962 
 963 C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv* env, jobject))
 964   JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK);
 965   CompilerStatistics* stats = compiler-&gt;stats();
 966   stats-&gt;_standard.reset();
 967   stats-&gt;_osr.reset();
 968 C2V_END
 969 
 970 C2V_VMENTRY_NULL(jobject, disassembleCodeBlob, (JNIEnv* env, jobject, jobject installedCode))
<span class="line-modified"> 971   HandleMark hm;</span>
 972 
 973   if (installedCode == NULL) {
 974     JVMCI_THROW_MSG_NULL(NullPointerException, &quot;installedCode is null&quot;);
 975   }
 976 
 977   JVMCIObject installedCodeObject = JVMCIENV-&gt;wrap(installedCode);
 978   nmethodLocker locker;
 979   CodeBlob* cb = JVMCIENV-&gt;get_code_blob(installedCodeObject, locker);
 980   if (cb == NULL) {
 981     return NULL;
 982   }
 983 
 984   // We don&#39;t want the stringStream buffer to resize during disassembly as it
 985   // uses scoped resource memory. If a nested function called during disassembly uses
 986   // a ResourceMark and the buffer expands within the scope of the mark,
 987   // the buffer becomes garbage when that scope is exited. Experience shows that
 988   // the disassembled code is typically about 10x the code size so a fixed buffer
 989   // sized to 20x code size plus a fixed amount for header info should be sufficient.
 990   int bufferSize = cb-&gt;code_size() * 20 + 1024;
 991   char* buffer = NEW_RESOURCE_ARRAY(char, bufferSize);
 992   stringStream st(buffer, bufferSize);
 993   if (cb-&gt;is_nmethod()) {
 994     nmethod* nm = (nmethod*) cb;
 995     if (!nm-&gt;is_alive()) {
 996       return NULL;
 997     }
 998   }
 999   Disassembler::decode(cb, &amp;st);
1000   if (st.size() &lt;= 0) {
1001     return NULL;
1002   }
1003 
1004   JVMCIObject result = JVMCIENV-&gt;create_string(st.as_string(), JVMCI_CHECK_NULL);
1005   return JVMCIENV-&gt;get_jobject(result);
1006 C2V_END
1007 
1008 C2V_VMENTRY_NULL(jobject, getStackTraceElement, (JNIEnv* env, jobject, jobject jvmci_method, int bci))
<span class="line-modified">1009   HandleMark hm;</span>
1010 
1011   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
1012   JVMCIObject element = JVMCIENV-&gt;new_StackTraceElement(method, bci, JVMCI_CHECK_NULL);
1013   return JVMCIENV-&gt;get_jobject(element);
1014 C2V_END
1015 
1016 C2V_VMENTRY_NULL(jobject, executeHotSpotNmethod, (JNIEnv* env, jobject, jobject args, jobject hs_nmethod))
1017   // The incoming arguments array would have to contain JavaConstants instead of regular objects
1018   // and the return value would have to be wrapped as a JavaConstant.
1019   requireInHotSpot(&quot;executeHotSpotNmethod&quot;, JVMCI_CHECK_NULL);
1020 
<span class="line-modified">1021   HandleMark hm;</span>
1022 
1023   JVMCIObject nmethod_mirror = JVMCIENV-&gt;wrap(hs_nmethod);
1024   nmethodLocker locker;
1025   nmethod* nm = JVMCIENV-&gt;get_nmethod(nmethod_mirror, locker);
1026   if (nm == NULL || !nm-&gt;is_in_use()) {
1027     JVMCI_THROW_NULL(InvalidInstalledCodeException);
1028   }
1029   methodHandle mh(THREAD, nm-&gt;method());
1030   Symbol* signature = mh-&gt;signature();
1031   JavaCallArguments jca(mh-&gt;size_of_parameters());
1032 
1033   JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
1034   JavaValue result(jap.return_type());
1035   jca.set_alternative_target(Handle(THREAD, JNIHandles::resolve(nmethod_mirror.as_jobject())));
1036   JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
1037 
1038   if (jap.return_type() == T_VOID) {
1039     return NULL;
1040   } else if (is_reference_type(jap.return_type())) {
1041     return JNIHandles::make_local(THREAD, (oop) result.get_jobject());
</pre>
<hr />
<pre>
1135 C2V_VMENTRY_NULL(jobject, readUncompressedOop, (JNIEnv* env, jobject, jlong addr))
1136   oop ret = RawAccess&lt;&gt;::oop_load((oop*)(address)addr);
1137   return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_object_constant(ret));
1138  C2V_END
1139 
1140 C2V_VMENTRY_NULL(jlongArray, collectCounters, (JNIEnv* env, jobject))
1141   // Returns a zero length array if counters aren&#39;t enabled
1142   JVMCIPrimitiveArray array = JVMCIENV-&gt;new_longArray(JVMCICounterSize, JVMCI_CHECK_NULL);
1143   if (JVMCICounterSize &gt; 0) {
1144     jlong* temp_array = NEW_RESOURCE_ARRAY(jlong, JVMCICounterSize);
1145     JavaThread::collect_counters(temp_array, JVMCICounterSize);
1146     JVMCIENV-&gt;copy_longs_from(temp_array, array, 0, JVMCICounterSize);
1147   }
1148   return (jlongArray) JVMCIENV-&gt;get_jobject(array);
1149 C2V_END
1150 
1151 C2V_VMENTRY_0(jint, getCountersSize, (JNIEnv* env, jobject))
1152   return (jint) JVMCICounterSize;
1153 C2V_END
1154 
<span class="line-modified">1155 C2V_VMENTRY(void, setCountersSize, (JNIEnv* env, jobject, jint new_size))</span>
<span class="line-modified">1156   JavaThread::resize_all_jvmci_counters(new_size);</span>
1157 C2V_END
1158 
1159 C2V_VMENTRY_0(jint, allocateCompileId, (JNIEnv* env, jobject, jobject jvmci_method, int entry_bci))
<span class="line-modified">1160   HandleMark hm;</span>
1161   if (jvmci_method == NULL) {
1162     JVMCI_THROW_0(NullPointerException);
1163   }
1164   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
1165   if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
1166     JVMCI_THROW_MSG_0(IllegalArgumentException, err_msg(&quot;Unexpected bci %d&quot;, entry_bci));
1167   }
1168   return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
1169 C2V_END
1170 
1171 
1172 C2V_VMENTRY_0(jboolean, isMature, (JNIEnv* env, jobject, jlong metaspace_method_data))
1173   MethodData* mdo = JVMCIENV-&gt;asMethodData(metaspace_method_data);
1174   return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
1175 C2V_END
1176 
1177 C2V_VMENTRY_0(jboolean, hasCompiledCodeForOSR, (JNIEnv* env, jobject, jobject jvmci_method, int entry_bci, int comp_level))
1178   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
1179   return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
1180 C2V_END
</pre>
<hr />
<pre>
1556       }
1557     }
1558   }
1559 
1560   // all locals are materialized by now
1561   JVMCIENV-&gt;set_HotSpotStackFrameReference_localIsVirtual(hs_frame, NULL);
1562   // update the locals array
1563   JVMCIObjectArray array = JVMCIENV-&gt;get_HotSpotStackFrameReference_locals(hs_frame);
1564   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1565   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1566     StackValue* var = locals-&gt;at(i);
1567     if (var-&gt;type() == T_OBJECT) {
1568       JVMCIENV-&gt;put_object_at(array, i, HotSpotJVMCI::wrap(locals-&gt;at(i)-&gt;get_obj()()));
1569     }
1570   }
1571   HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, hs_frame, JNI_TRUE);
1572 C2V_END
1573 
1574 // Creates a scope where the current thread is attached and detached
1575 // from HotSpot if it wasn&#39;t already attached when entering the scope.
<span class="line-modified">1576 extern &quot;C&quot; void jio_printf(const char *fmt, ...);</span>
1577 class AttachDetach : public StackObj {
1578  public:
1579   bool _attached;
1580   AttachDetach(JNIEnv* env, JavaThread* current_thread) {
1581     if (current_thread == NULL) {
1582       extern struct JavaVM_ main_vm;
1583       JNIEnv* hotspotEnv;
1584       jint res = main_vm.AttachCurrentThread((void**)&amp;hotspotEnv, NULL);
1585       _attached = res == JNI_OK;
1586       static volatile int report_attach_error = 0;
1587       if (res != JNI_OK &amp;&amp; report_attach_error == 0 &amp;&amp; Atomic::cmpxchg(&amp;report_attach_error, 0, 1) == 0) {
1588         // Only report an attach error once
1589         jio_printf(&quot;Warning: attaching current thread to VM failed with %d (future attach errors are suppressed)\n&quot;, res);
1590       }
1591     } else {
1592       _attached = false;
1593     }
1594   }
1595   ~AttachDetach() {
1596     if (_attached &amp;&amp; get_current_thread() != NULL) {
</pre>
<hr />
<pre>
2229     JVMCIENV-&gt;runtime()-&gt;destroy_global(handle);
2230   }
2231 }
2232 
2233 static void requireJVMCINativeLibrary(JVMCI_TRAPS) {
2234   if (!UseJVMCINativeLibrary) {
2235     JVMCI_THROW_MSG(UnsupportedOperationException, &quot;JVMCI shared library is not enabled (requires -XX:+UseJVMCINativeLibrary)&quot;);
2236   }
2237 }
2238 
2239 C2V_VMENTRY_NULL(jlongArray, registerNativeMethods, (JNIEnv* env, jobject, jclass mirror))
2240   requireJVMCINativeLibrary(JVMCI_CHECK_NULL);
2241   requireInHotSpot(&quot;registerNativeMethods&quot;, JVMCI_CHECK_NULL);
2242   char* sl_path;
2243   void* sl_handle;
2244   JVMCIRuntime* runtime = JVMCI::compiler_runtime();
2245   {
2246     // Ensure the JVMCI shared library runtime is initialized.
2247     JVMCIEnv __peer_jvmci_env__(thread, false, __FILE__, __LINE__);
2248     JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;
<span class="line-modified">2249     HandleMark hm;</span>
2250     JVMCIObject receiver = runtime-&gt;get_HotSpotJVMCIRuntime(peerEnv);
2251     if (peerEnv-&gt;has_pending_exception()) {
2252       peerEnv-&gt;describe_pending_exception(true);
2253     }
2254     sl_handle = JVMCI::get_shared_library(sl_path, false);
2255     if (sl_handle == NULL) {
2256       JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Error initializing JVMCI runtime %d&quot;, runtime-&gt;id()));
2257     }
2258   }
2259 
2260   if (mirror == NULL) {
2261     JVMCI_THROW_0(NullPointerException);
2262   }
2263   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
2264   if (klass == NULL || !klass-&gt;is_instance_klass()) {
2265     JVMCI_THROW_MSG_0(IllegalArgumentException, &quot;clazz is for primitive type&quot;);
2266   }
2267 
2268   InstanceKlass* iklass = InstanceKlass::cast(klass);
2269   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
</pre>
<hr />
<pre>
2743   {CC &quot;hasFinalizableSubclass&quot;,                       CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)Z&quot;,                                                        FN_PTR(hasFinalizableSubclass)},
2744   {CC &quot;getMaxCallTargetOffset&quot;,                       CC &quot;(J)J&quot;,                                                                            FN_PTR(getMaxCallTargetOffset)},
2745   {CC &quot;asResolvedJavaMethod&quot;,                         CC &quot;(&quot; EXECUTABLE &quot;)&quot; HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},
2746   {CC &quot;getResolvedJavaMethod&quot;,                        CC &quot;(&quot; OBJECTCONSTANT &quot;J)&quot; HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},
2747   {CC &quot;getConstantPool&quot;,                              CC &quot;(&quot; METASPACE_OBJECT &quot;)&quot; HS_CONSTANT_POOL,                                         FN_PTR(getConstantPool)},
2748   {CC &quot;getResolvedJavaType0&quot;,                         CC &quot;(Ljava/lang/Object;JZ)&quot; HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType0)},
2749   {CC &quot;readConfiguration&quot;,                            CC &quot;()[&quot; OBJECT,                                                                      FN_PTR(readConfiguration)},
2750   {CC &quot;installCode&quot;,                                  CC &quot;(&quot; TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE &quot;J[B)I&quot;,                    FN_PTR(installCode)},
2751   {CC &quot;getMetadata&quot;,                                  CC &quot;(&quot; TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA &quot;)I&quot;,                          FN_PTR(getMetadata)},
2752   {CC &quot;resetCompilationStatistics&quot;,                   CC &quot;()V&quot;,                                                                             FN_PTR(resetCompilationStatistics)},
2753   {CC &quot;disassembleCodeBlob&quot;,                          CC &quot;(&quot; INSTALLED_CODE &quot;)&quot; STRING,                                                     FN_PTR(disassembleCodeBlob)},
2754   {CC &quot;executeHotSpotNmethod&quot;,                        CC &quot;([&quot; OBJECT HS_NMETHOD &quot;)&quot; OBJECT,                                                 FN_PTR(executeHotSpotNmethod)},
2755   {CC &quot;getLineNumberTable&quot;,                           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)[J&quot;,                                                      FN_PTR(getLineNumberTable)},
2756   {CC &quot;getLocalVariableTableStart&quot;,                   CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getLocalVariableTableStart)},
2757   {CC &quot;getLocalVariableTableLength&quot;,                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)I&quot;,                                                       FN_PTR(getLocalVariableTableLength)},
2758   {CC &quot;reprofile&quot;,                                    CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)V&quot;,                                                       FN_PTR(reprofile)},
2759   {CC &quot;invalidateHotSpotNmethod&quot;,                     CC &quot;(&quot; HS_NMETHOD &quot;)V&quot;,                                                               FN_PTR(invalidateHotSpotNmethod)},
2760   {CC &quot;readUncompressedOop&quot;,                          CC &quot;(J)&quot; OBJECTCONSTANT,                                                              FN_PTR(readUncompressedOop)},
2761   {CC &quot;collectCounters&quot;,                              CC &quot;()[J&quot;,                                                                            FN_PTR(collectCounters)},
2762   {CC &quot;getCountersSize&quot;,                              CC &quot;()I&quot;,                                                                             FN_PTR(getCountersSize)},
<span class="line-modified">2763   {CC &quot;setCountersSize&quot;,                              CC &quot;(I)V&quot;,                                                                            FN_PTR(setCountersSize)},</span>
2764   {CC &quot;allocateCompileId&quot;,                            CC &quot;(&quot; HS_RESOLVED_METHOD &quot;I)I&quot;,                                                      FN_PTR(allocateCompileId)},
2765   {CC &quot;isMature&quot;,                                     CC &quot;(&quot; METASPACE_METHOD_DATA &quot;)Z&quot;,                                                    FN_PTR(isMature)},
2766   {CC &quot;hasCompiledCodeForOSR&quot;,                        CC &quot;(&quot; HS_RESOLVED_METHOD &quot;II)Z&quot;,                                                     FN_PTR(hasCompiledCodeForOSR)},
2767   {CC &quot;getSymbol&quot;,                                    CC &quot;(J)&quot; STRING,                                                                      FN_PTR(getSymbol)},
2768   {CC &quot;iterateFrames&quot;,                                CC &quot;([&quot; RESOLVED_METHOD &quot;[&quot; RESOLVED_METHOD &quot;I&quot; INSPECTED_FRAME_VISITOR &quot;)&quot; OBJECT,   FN_PTR(iterateFrames)},
2769   {CC &quot;materializeVirtualObjects&quot;,                    CC &quot;(&quot; HS_STACK_FRAME_REF &quot;Z)V&quot;,                                                      FN_PTR(materializeVirtualObjects)},
2770   {CC &quot;shouldDebugNonSafepoints&quot;,                     CC &quot;()Z&quot;,                                                                             FN_PTR(shouldDebugNonSafepoints)},
2771   {CC &quot;writeDebugOutput&quot;,                             CC &quot;([BIIZZ)I&quot;,                                                                       FN_PTR(writeDebugOutput)},
2772   {CC &quot;flushDebugOutput&quot;,                             CC &quot;()V&quot;,                                                                             FN_PTR(flushDebugOutput)},
2773   {CC &quot;methodDataProfileDataSize&quot;,                    CC &quot;(JI)I&quot;,                                                                           FN_PTR(methodDataProfileDataSize)},
2774   {CC &quot;getFingerprint&quot;,                               CC &quot;(J)J&quot;,                                                                            FN_PTR(getFingerprint)},
2775   {CC &quot;getHostClass&quot;,                                 CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(getHostClass)},
2776   {CC &quot;interpreterFrameSize&quot;,                         CC &quot;(&quot; BYTECODE_FRAME &quot;)I&quot;,                                                           FN_PTR(interpreterFrameSize)},
2777   {CC &quot;compileToBytecode&quot;,                            CC &quot;(&quot; OBJECTCONSTANT &quot;)V&quot;,                                                           FN_PTR(compileToBytecode)},
2778   {CC &quot;getFlagValue&quot;,                                 CC &quot;(&quot; STRING &quot;)&quot; OBJECT,                                                             FN_PTR(getFlagValue)},
2779   {CC &quot;getObjectAtAddress&quot;,                           CC &quot;(J)&quot; OBJECT,                                                                      FN_PTR(getObjectAtAddress)},
2780   {CC &quot;getInterfaces&quot;,                                CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)[&quot; HS_RESOLVED_KLASS,                                      FN_PTR(getInterfaces)},
2781   {CC &quot;getComponentType&quot;,                             CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_TYPE,                                        FN_PTR(getComponentType)},
2782   {CC &quot;ensureInitialized&quot;,                            CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)V&quot;,                                                        FN_PTR(ensureInitialized)},
2783   {CC &quot;ensureLinked&quot;,                                 CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)V&quot;,                                                        FN_PTR(ensureLinked)},
</pre>
</td>
<td>
<hr />
<pre>
 802 
 803 C2V_VMENTRY_0(jlong, getMaxCallTargetOffset, (JNIEnv* env, jobject, jlong addr))
 804   address target_addr = (address) addr;
 805   if (target_addr != 0x0) {
 806     int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
 807     int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
 808     return MAX2(ABS(off_low), ABS(off_high));
 809   }
 810   return -1;
 811 C2V_END
 812 
 813 C2V_VMENTRY(void, setNotInlinableOrCompilable,(JNIEnv* env, jobject,  jobject jvmci_method))
 814   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 815   method-&gt;set_not_c1_compilable();
 816   method-&gt;set_not_c2_compilable();
 817   method-&gt;set_dont_inline(true);
 818 C2V_END
 819 
 820 C2V_VMENTRY_0(jint, installCode, (JNIEnv *env, jobject, jobject target, jobject compiled_code,
 821             jobject installed_code, jlong failed_speculations_address, jbyteArray speculations_obj))
<span class="line-modified"> 822   HandleMark hm(THREAD);</span>
 823   JNIHandleMark jni_hm(thread);
 824 
 825   JVMCIObject target_handle = JVMCIENV-&gt;wrap(target);
 826   JVMCIObject compiled_code_handle = JVMCIENV-&gt;wrap(compiled_code);
 827   CodeBlob* cb = NULL;
 828   JVMCIObject installed_code_handle = JVMCIENV-&gt;wrap(installed_code);
 829   JVMCIPrimitiveArray speculations_handle = JVMCIENV-&gt;wrap(speculations_obj);
 830 
 831   int speculations_len = JVMCIENV-&gt;get_length(speculations_handle);
 832   char* speculations = NEW_RESOURCE_ARRAY(char, speculations_len);
 833   JVMCIENV-&gt;copy_bytes_to(speculations_handle, (jbyte*) speculations, 0, speculations_len);
 834 
 835   JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK_JNI_ERR);
 836 
 837   TraceTime install_time(&quot;installCode&quot;, JVMCICompiler::codeInstallTimer());
 838   bool is_immutable_PIC = JVMCIENV-&gt;get_HotSpotCompiledCode_isImmutablePIC(compiled_code_handle) &gt; 0;
 839 
 840   CodeInstaller installer(JVMCIENV, is_immutable_PIC);
 841   JVMCI::CodeInstallResult result = installer.install(compiler,
 842       target_handle,
</pre>
<hr />
<pre>
 863     assert(cb == NULL, &quot;should be&quot;);
 864   } else {
 865     if (installed_code_handle.is_non_null()) {
 866       if (cb-&gt;is_nmethod()) {
 867         assert(JVMCIENV-&gt;isa_HotSpotNmethod(installed_code_handle), &quot;wrong type&quot;);
 868         // Clear the link to an old nmethod first
 869         JVMCIObject nmethod_mirror = installed_code_handle;
 870         JVMCIENV-&gt;invalidate_nmethod_mirror(nmethod_mirror, JVMCI_CHECK_0);
 871       } else {
 872         assert(JVMCIENV-&gt;isa_InstalledCode(installed_code_handle), &quot;wrong type&quot;);
 873       }
 874       // Initialize the link to the new code blob
 875       JVMCIENV-&gt;initialize_installed_code(installed_code_handle, cb, JVMCI_CHECK_0);
 876     }
 877   }
 878   return result;
 879 C2V_END
 880 
 881 C2V_VMENTRY_0(jint, getMetadata, (JNIEnv *env, jobject, jobject target, jobject compiled_code, jobject metadata))
 882 #if INCLUDE_AOT
<span class="line-modified"> 883   HandleMark hm(THREAD);</span>
 884   assert(JVMCIENV-&gt;is_hotspot(), &quot;AOT code is executed only in HotSpot mode&quot;);
 885 
 886   JVMCIObject target_handle = JVMCIENV-&gt;wrap(target);
 887   JVMCIObject compiled_code_handle = JVMCIENV-&gt;wrap(compiled_code);
 888   JVMCIObject metadata_handle = JVMCIENV-&gt;wrap(metadata);
 889 
 890   CodeMetadata code_metadata;
 891 
 892   CodeInstaller installer(JVMCIENV, true /* immutable PIC compilation */);
 893   JVMCI::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, JVMCI_CHECK_0);
 894   if (result != JVMCI::ok) {
 895     return result;
 896   }
 897 
 898   if (code_metadata.get_nr_pc_desc() &gt; 0) {
 899     int size = sizeof(PcDesc) * code_metadata.get_nr_pc_desc();
 900     JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));
 901     JVMCIENV-&gt;copy_bytes_from((jbyte*) code_metadata.get_pc_desc(), array, 0, size);
 902     HotSpotJVMCI::HotSpotMetaData::set_pcDescBytes(JVMCIENV, metadata_handle, array);
 903   }
</pre>
<hr />
<pre>
 951   JVMCIPrimitiveArray implicitExceptionArray = JVMCIENV-&gt;new_byteArray(implicit_table_size, JVMCI_CHECK_(JVMCI::cache_full));
 952   if (implicit_table_size &gt; 0) {
 953     implicit-&gt;copy_bytes_to((address) HotSpotJVMCI::resolve(implicitExceptionArray)-&gt;byte_at_addr(0), implicit_table_size);
 954   }
 955   HotSpotJVMCI::HotSpotMetaData::set_implicitExceptionBytes(JVMCIENV, metadata_handle, implicitExceptionArray);
 956 
 957   return result;
 958 #else
 959   JVMCI_THROW_MSG_0(InternalError, &quot;unimplemented&quot;);
 960 #endif
 961 C2V_END
 962 
 963 C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv* env, jobject))
 964   JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK);
 965   CompilerStatistics* stats = compiler-&gt;stats();
 966   stats-&gt;_standard.reset();
 967   stats-&gt;_osr.reset();
 968 C2V_END
 969 
 970 C2V_VMENTRY_NULL(jobject, disassembleCodeBlob, (JNIEnv* env, jobject, jobject installedCode))
<span class="line-modified"> 971   HandleMark hm(THREAD);</span>
 972 
 973   if (installedCode == NULL) {
 974     JVMCI_THROW_MSG_NULL(NullPointerException, &quot;installedCode is null&quot;);
 975   }
 976 
 977   JVMCIObject installedCodeObject = JVMCIENV-&gt;wrap(installedCode);
 978   nmethodLocker locker;
 979   CodeBlob* cb = JVMCIENV-&gt;get_code_blob(installedCodeObject, locker);
 980   if (cb == NULL) {
 981     return NULL;
 982   }
 983 
 984   // We don&#39;t want the stringStream buffer to resize during disassembly as it
 985   // uses scoped resource memory. If a nested function called during disassembly uses
 986   // a ResourceMark and the buffer expands within the scope of the mark,
 987   // the buffer becomes garbage when that scope is exited. Experience shows that
 988   // the disassembled code is typically about 10x the code size so a fixed buffer
 989   // sized to 20x code size plus a fixed amount for header info should be sufficient.
 990   int bufferSize = cb-&gt;code_size() * 20 + 1024;
 991   char* buffer = NEW_RESOURCE_ARRAY(char, bufferSize);
 992   stringStream st(buffer, bufferSize);
 993   if (cb-&gt;is_nmethod()) {
 994     nmethod* nm = (nmethod*) cb;
 995     if (!nm-&gt;is_alive()) {
 996       return NULL;
 997     }
 998   }
 999   Disassembler::decode(cb, &amp;st);
1000   if (st.size() &lt;= 0) {
1001     return NULL;
1002   }
1003 
1004   JVMCIObject result = JVMCIENV-&gt;create_string(st.as_string(), JVMCI_CHECK_NULL);
1005   return JVMCIENV-&gt;get_jobject(result);
1006 C2V_END
1007 
1008 C2V_VMENTRY_NULL(jobject, getStackTraceElement, (JNIEnv* env, jobject, jobject jvmci_method, int bci))
<span class="line-modified">1009   HandleMark hm(THREAD);</span>
1010 
1011   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
1012   JVMCIObject element = JVMCIENV-&gt;new_StackTraceElement(method, bci, JVMCI_CHECK_NULL);
1013   return JVMCIENV-&gt;get_jobject(element);
1014 C2V_END
1015 
1016 C2V_VMENTRY_NULL(jobject, executeHotSpotNmethod, (JNIEnv* env, jobject, jobject args, jobject hs_nmethod))
1017   // The incoming arguments array would have to contain JavaConstants instead of regular objects
1018   // and the return value would have to be wrapped as a JavaConstant.
1019   requireInHotSpot(&quot;executeHotSpotNmethod&quot;, JVMCI_CHECK_NULL);
1020 
<span class="line-modified">1021   HandleMark hm(THREAD);</span>
1022 
1023   JVMCIObject nmethod_mirror = JVMCIENV-&gt;wrap(hs_nmethod);
1024   nmethodLocker locker;
1025   nmethod* nm = JVMCIENV-&gt;get_nmethod(nmethod_mirror, locker);
1026   if (nm == NULL || !nm-&gt;is_in_use()) {
1027     JVMCI_THROW_NULL(InvalidInstalledCodeException);
1028   }
1029   methodHandle mh(THREAD, nm-&gt;method());
1030   Symbol* signature = mh-&gt;signature();
1031   JavaCallArguments jca(mh-&gt;size_of_parameters());
1032 
1033   JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
1034   JavaValue result(jap.return_type());
1035   jca.set_alternative_target(Handle(THREAD, JNIHandles::resolve(nmethod_mirror.as_jobject())));
1036   JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
1037 
1038   if (jap.return_type() == T_VOID) {
1039     return NULL;
1040   } else if (is_reference_type(jap.return_type())) {
1041     return JNIHandles::make_local(THREAD, (oop) result.get_jobject());
</pre>
<hr />
<pre>
1135 C2V_VMENTRY_NULL(jobject, readUncompressedOop, (JNIEnv* env, jobject, jlong addr))
1136   oop ret = RawAccess&lt;&gt;::oop_load((oop*)(address)addr);
1137   return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_object_constant(ret));
1138  C2V_END
1139 
1140 C2V_VMENTRY_NULL(jlongArray, collectCounters, (JNIEnv* env, jobject))
1141   // Returns a zero length array if counters aren&#39;t enabled
1142   JVMCIPrimitiveArray array = JVMCIENV-&gt;new_longArray(JVMCICounterSize, JVMCI_CHECK_NULL);
1143   if (JVMCICounterSize &gt; 0) {
1144     jlong* temp_array = NEW_RESOURCE_ARRAY(jlong, JVMCICounterSize);
1145     JavaThread::collect_counters(temp_array, JVMCICounterSize);
1146     JVMCIENV-&gt;copy_longs_from(temp_array, array, 0, JVMCICounterSize);
1147   }
1148   return (jlongArray) JVMCIENV-&gt;get_jobject(array);
1149 C2V_END
1150 
1151 C2V_VMENTRY_0(jint, getCountersSize, (JNIEnv* env, jobject))
1152   return (jint) JVMCICounterSize;
1153 C2V_END
1154 
<span class="line-modified">1155 C2V_VMENTRY_0(jboolean, setCountersSize, (JNIEnv* env, jobject, jint new_size))</span>
<span class="line-modified">1156   return JavaThread::resize_all_jvmci_counters(new_size);</span>
1157 C2V_END
1158 
1159 C2V_VMENTRY_0(jint, allocateCompileId, (JNIEnv* env, jobject, jobject jvmci_method, int entry_bci))
<span class="line-modified">1160   HandleMark hm(THREAD);</span>
1161   if (jvmci_method == NULL) {
1162     JVMCI_THROW_0(NullPointerException);
1163   }
1164   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
1165   if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
1166     JVMCI_THROW_MSG_0(IllegalArgumentException, err_msg(&quot;Unexpected bci %d&quot;, entry_bci));
1167   }
1168   return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
1169 C2V_END
1170 
1171 
1172 C2V_VMENTRY_0(jboolean, isMature, (JNIEnv* env, jobject, jlong metaspace_method_data))
1173   MethodData* mdo = JVMCIENV-&gt;asMethodData(metaspace_method_data);
1174   return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
1175 C2V_END
1176 
1177 C2V_VMENTRY_0(jboolean, hasCompiledCodeForOSR, (JNIEnv* env, jobject, jobject jvmci_method, int entry_bci, int comp_level))
1178   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
1179   return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
1180 C2V_END
</pre>
<hr />
<pre>
1556       }
1557     }
1558   }
1559 
1560   // all locals are materialized by now
1561   JVMCIENV-&gt;set_HotSpotStackFrameReference_localIsVirtual(hs_frame, NULL);
1562   // update the locals array
1563   JVMCIObjectArray array = JVMCIENV-&gt;get_HotSpotStackFrameReference_locals(hs_frame);
1564   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1565   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1566     StackValue* var = locals-&gt;at(i);
1567     if (var-&gt;type() == T_OBJECT) {
1568       JVMCIENV-&gt;put_object_at(array, i, HotSpotJVMCI::wrap(locals-&gt;at(i)-&gt;get_obj()()));
1569     }
1570   }
1571   HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, hs_frame, JNI_TRUE);
1572 C2V_END
1573 
1574 // Creates a scope where the current thread is attached and detached
1575 // from HotSpot if it wasn&#39;t already attached when entering the scope.
<span class="line-modified">1576 extern &quot;C&quot; int jio_printf(const char *fmt, ...);</span>
1577 class AttachDetach : public StackObj {
1578  public:
1579   bool _attached;
1580   AttachDetach(JNIEnv* env, JavaThread* current_thread) {
1581     if (current_thread == NULL) {
1582       extern struct JavaVM_ main_vm;
1583       JNIEnv* hotspotEnv;
1584       jint res = main_vm.AttachCurrentThread((void**)&amp;hotspotEnv, NULL);
1585       _attached = res == JNI_OK;
1586       static volatile int report_attach_error = 0;
1587       if (res != JNI_OK &amp;&amp; report_attach_error == 0 &amp;&amp; Atomic::cmpxchg(&amp;report_attach_error, 0, 1) == 0) {
1588         // Only report an attach error once
1589         jio_printf(&quot;Warning: attaching current thread to VM failed with %d (future attach errors are suppressed)\n&quot;, res);
1590       }
1591     } else {
1592       _attached = false;
1593     }
1594   }
1595   ~AttachDetach() {
1596     if (_attached &amp;&amp; get_current_thread() != NULL) {
</pre>
<hr />
<pre>
2229     JVMCIENV-&gt;runtime()-&gt;destroy_global(handle);
2230   }
2231 }
2232 
2233 static void requireJVMCINativeLibrary(JVMCI_TRAPS) {
2234   if (!UseJVMCINativeLibrary) {
2235     JVMCI_THROW_MSG(UnsupportedOperationException, &quot;JVMCI shared library is not enabled (requires -XX:+UseJVMCINativeLibrary)&quot;);
2236   }
2237 }
2238 
2239 C2V_VMENTRY_NULL(jlongArray, registerNativeMethods, (JNIEnv* env, jobject, jclass mirror))
2240   requireJVMCINativeLibrary(JVMCI_CHECK_NULL);
2241   requireInHotSpot(&quot;registerNativeMethods&quot;, JVMCI_CHECK_NULL);
2242   char* sl_path;
2243   void* sl_handle;
2244   JVMCIRuntime* runtime = JVMCI::compiler_runtime();
2245   {
2246     // Ensure the JVMCI shared library runtime is initialized.
2247     JVMCIEnv __peer_jvmci_env__(thread, false, __FILE__, __LINE__);
2248     JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;
<span class="line-modified">2249     HandleMark hm(THREAD);</span>
2250     JVMCIObject receiver = runtime-&gt;get_HotSpotJVMCIRuntime(peerEnv);
2251     if (peerEnv-&gt;has_pending_exception()) {
2252       peerEnv-&gt;describe_pending_exception(true);
2253     }
2254     sl_handle = JVMCI::get_shared_library(sl_path, false);
2255     if (sl_handle == NULL) {
2256       JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Error initializing JVMCI runtime %d&quot;, runtime-&gt;id()));
2257     }
2258   }
2259 
2260   if (mirror == NULL) {
2261     JVMCI_THROW_0(NullPointerException);
2262   }
2263   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
2264   if (klass == NULL || !klass-&gt;is_instance_klass()) {
2265     JVMCI_THROW_MSG_0(IllegalArgumentException, &quot;clazz is for primitive type&quot;);
2266   }
2267 
2268   InstanceKlass* iklass = InstanceKlass::cast(klass);
2269   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
</pre>
<hr />
<pre>
2743   {CC &quot;hasFinalizableSubclass&quot;,                       CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)Z&quot;,                                                        FN_PTR(hasFinalizableSubclass)},
2744   {CC &quot;getMaxCallTargetOffset&quot;,                       CC &quot;(J)J&quot;,                                                                            FN_PTR(getMaxCallTargetOffset)},
2745   {CC &quot;asResolvedJavaMethod&quot;,                         CC &quot;(&quot; EXECUTABLE &quot;)&quot; HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},
2746   {CC &quot;getResolvedJavaMethod&quot;,                        CC &quot;(&quot; OBJECTCONSTANT &quot;J)&quot; HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},
2747   {CC &quot;getConstantPool&quot;,                              CC &quot;(&quot; METASPACE_OBJECT &quot;)&quot; HS_CONSTANT_POOL,                                         FN_PTR(getConstantPool)},
2748   {CC &quot;getResolvedJavaType0&quot;,                         CC &quot;(Ljava/lang/Object;JZ)&quot; HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType0)},
2749   {CC &quot;readConfiguration&quot;,                            CC &quot;()[&quot; OBJECT,                                                                      FN_PTR(readConfiguration)},
2750   {CC &quot;installCode&quot;,                                  CC &quot;(&quot; TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE &quot;J[B)I&quot;,                    FN_PTR(installCode)},
2751   {CC &quot;getMetadata&quot;,                                  CC &quot;(&quot; TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA &quot;)I&quot;,                          FN_PTR(getMetadata)},
2752   {CC &quot;resetCompilationStatistics&quot;,                   CC &quot;()V&quot;,                                                                             FN_PTR(resetCompilationStatistics)},
2753   {CC &quot;disassembleCodeBlob&quot;,                          CC &quot;(&quot; INSTALLED_CODE &quot;)&quot; STRING,                                                     FN_PTR(disassembleCodeBlob)},
2754   {CC &quot;executeHotSpotNmethod&quot;,                        CC &quot;([&quot; OBJECT HS_NMETHOD &quot;)&quot; OBJECT,                                                 FN_PTR(executeHotSpotNmethod)},
2755   {CC &quot;getLineNumberTable&quot;,                           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)[J&quot;,                                                      FN_PTR(getLineNumberTable)},
2756   {CC &quot;getLocalVariableTableStart&quot;,                   CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getLocalVariableTableStart)},
2757   {CC &quot;getLocalVariableTableLength&quot;,                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)I&quot;,                                                       FN_PTR(getLocalVariableTableLength)},
2758   {CC &quot;reprofile&quot;,                                    CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)V&quot;,                                                       FN_PTR(reprofile)},
2759   {CC &quot;invalidateHotSpotNmethod&quot;,                     CC &quot;(&quot; HS_NMETHOD &quot;)V&quot;,                                                               FN_PTR(invalidateHotSpotNmethod)},
2760   {CC &quot;readUncompressedOop&quot;,                          CC &quot;(J)&quot; OBJECTCONSTANT,                                                              FN_PTR(readUncompressedOop)},
2761   {CC &quot;collectCounters&quot;,                              CC &quot;()[J&quot;,                                                                            FN_PTR(collectCounters)},
2762   {CC &quot;getCountersSize&quot;,                              CC &quot;()I&quot;,                                                                             FN_PTR(getCountersSize)},
<span class="line-modified">2763   {CC &quot;setCountersSize&quot;,                              CC &quot;(I)Z&quot;,                                                                            FN_PTR(setCountersSize)},</span>
2764   {CC &quot;allocateCompileId&quot;,                            CC &quot;(&quot; HS_RESOLVED_METHOD &quot;I)I&quot;,                                                      FN_PTR(allocateCompileId)},
2765   {CC &quot;isMature&quot;,                                     CC &quot;(&quot; METASPACE_METHOD_DATA &quot;)Z&quot;,                                                    FN_PTR(isMature)},
2766   {CC &quot;hasCompiledCodeForOSR&quot;,                        CC &quot;(&quot; HS_RESOLVED_METHOD &quot;II)Z&quot;,                                                     FN_PTR(hasCompiledCodeForOSR)},
2767   {CC &quot;getSymbol&quot;,                                    CC &quot;(J)&quot; STRING,                                                                      FN_PTR(getSymbol)},
2768   {CC &quot;iterateFrames&quot;,                                CC &quot;([&quot; RESOLVED_METHOD &quot;[&quot; RESOLVED_METHOD &quot;I&quot; INSPECTED_FRAME_VISITOR &quot;)&quot; OBJECT,   FN_PTR(iterateFrames)},
2769   {CC &quot;materializeVirtualObjects&quot;,                    CC &quot;(&quot; HS_STACK_FRAME_REF &quot;Z)V&quot;,                                                      FN_PTR(materializeVirtualObjects)},
2770   {CC &quot;shouldDebugNonSafepoints&quot;,                     CC &quot;()Z&quot;,                                                                             FN_PTR(shouldDebugNonSafepoints)},
2771   {CC &quot;writeDebugOutput&quot;,                             CC &quot;([BIIZZ)I&quot;,                                                                       FN_PTR(writeDebugOutput)},
2772   {CC &quot;flushDebugOutput&quot;,                             CC &quot;()V&quot;,                                                                             FN_PTR(flushDebugOutput)},
2773   {CC &quot;methodDataProfileDataSize&quot;,                    CC &quot;(JI)I&quot;,                                                                           FN_PTR(methodDataProfileDataSize)},
2774   {CC &quot;getFingerprint&quot;,                               CC &quot;(J)J&quot;,                                                                            FN_PTR(getFingerprint)},
2775   {CC &quot;getHostClass&quot;,                                 CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(getHostClass)},
2776   {CC &quot;interpreterFrameSize&quot;,                         CC &quot;(&quot; BYTECODE_FRAME &quot;)I&quot;,                                                           FN_PTR(interpreterFrameSize)},
2777   {CC &quot;compileToBytecode&quot;,                            CC &quot;(&quot; OBJECTCONSTANT &quot;)V&quot;,                                                           FN_PTR(compileToBytecode)},
2778   {CC &quot;getFlagValue&quot;,                                 CC &quot;(&quot; STRING &quot;)&quot; OBJECT,                                                             FN_PTR(getFlagValue)},
2779   {CC &quot;getObjectAtAddress&quot;,                           CC &quot;(J)&quot; OBJECT,                                                                      FN_PTR(getObjectAtAddress)},
2780   {CC &quot;getInterfaces&quot;,                                CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)[&quot; HS_RESOLVED_KLASS,                                      FN_PTR(getInterfaces)},
2781   {CC &quot;getComponentType&quot;,                             CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_TYPE,                                        FN_PTR(getComponentType)},
2782   {CC &quot;ensureInitialized&quot;,                            CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)V&quot;,                                                        FN_PTR(ensureInitialized)},
2783   {CC &quot;ensureLinked&quot;,                                 CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)V&quot;,                                                        FN_PTR(ensureLinked)},
</pre>
</td>
</tr>
</table>
<center><a href="jvmciCompiler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciEnv.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>