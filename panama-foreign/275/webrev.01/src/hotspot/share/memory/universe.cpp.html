<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/memory/universe.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoader.hpp&quot;
  28 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  29 #include &quot;classfile/javaClasses.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/systemDictionary.hpp&quot;
  33 #include &quot;classfile/vmSymbols.hpp&quot;
  34 #include &quot;code/codeBehaviours.hpp&quot;
  35 #include &quot;code/codeCache.hpp&quot;
  36 #include &quot;code/dependencies.hpp&quot;
  37 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  38 #include &quot;gc/shared/gcArguments.hpp&quot;
  39 #include &quot;gc/shared/gcConfig.hpp&quot;
  40 #include &quot;gc/shared/gcLogPrecious.hpp&quot;
  41 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  42 #include &quot;gc/shared/oopStorageSet.hpp&quot;
  43 #include &quot;interpreter/interpreter.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;logging/logStream.hpp&quot;
  46 #include &quot;memory/heapShared.hpp&quot;
  47 #include &quot;memory/filemap.hpp&quot;
  48 #include &quot;memory/metadataFactory.hpp&quot;
  49 #include &quot;memory/metaspaceClosure.hpp&quot;
  50 #include &quot;memory/metaspaceCounters.hpp&quot;
  51 #include &quot;memory/metaspaceShared.hpp&quot;
  52 #include &quot;memory/oopFactory.hpp&quot;
  53 #include &quot;memory/resourceArea.hpp&quot;
  54 #include &quot;memory/universe.hpp&quot;
  55 #include &quot;oops/compressedOops.hpp&quot;
  56 #include &quot;oops/constantPool.hpp&quot;
  57 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  58 #include &quot;oops/instanceKlass.hpp&quot;
  59 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  60 #include &quot;oops/instanceRefKlass.hpp&quot;
  61 #include &quot;oops/objArrayOop.inline.hpp&quot;
  62 #include &quot;oops/oop.inline.hpp&quot;
  63 #include &quot;oops/oopHandle.inline.hpp&quot;
  64 #include &quot;oops/typeArrayKlass.hpp&quot;
  65 #include &quot;prims/resolvedMethodTable.hpp&quot;
  66 #include &quot;runtime/arguments.hpp&quot;
  67 #include &quot;runtime/atomic.hpp&quot;
  68 #include &quot;runtime/deoptimization.hpp&quot;
  69 #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;
  70 #include &quot;runtime/handles.inline.hpp&quot;
  71 #include &quot;runtime/init.hpp&quot;
  72 #include &quot;runtime/java.hpp&quot;
  73 #include &quot;runtime/javaCalls.hpp&quot;
  74 #include &quot;runtime/sharedRuntime.hpp&quot;
  75 #include &quot;runtime/synchronizer.hpp&quot;
  76 #include &quot;runtime/thread.inline.hpp&quot;
  77 #include &quot;runtime/timerTrace.hpp&quot;
  78 #include &quot;runtime/vmOperations.hpp&quot;
  79 #include &quot;services/memoryService.hpp&quot;
  80 #include &quot;utilities/align.hpp&quot;
  81 #include &quot;utilities/autoRestore.hpp&quot;
  82 #include &quot;utilities/copy.hpp&quot;
  83 #include &quot;utilities/debug.hpp&quot;
  84 #include &quot;utilities/events.hpp&quot;
  85 #include &quot;utilities/formatBuffer.hpp&quot;
  86 #include &quot;utilities/hashtable.inline.hpp&quot;
  87 #include &quot;utilities/macros.hpp&quot;
  88 #include &quot;utilities/ostream.hpp&quot;
  89 #include &quot;utilities/preserveException.hpp&quot;
  90 
  91 // Known objects
  92 Klass* Universe::_typeArrayKlassObjs[T_LONG+1]        = { NULL /*, NULL...*/ };
  93 Klass* Universe::_objectArrayKlassObj                 = NULL;
  94 OopHandle Universe::_mirrors[T_VOID+1];
  95 
  96 OopHandle Universe::_main_thread_group;
  97 OopHandle Universe::_system_thread_group;
  98 OopHandle Universe::_the_empty_class_array;
  99 OopHandle Universe::_the_null_string;
 100 OopHandle Universe::_the_min_jint_string;
 101 
 102 OopHandle Universe::_the_null_sentinel;
 103 
 104 // _out_of_memory_errors is an objArray
 105 enum OutOfMemoryInstance { _oom_java_heap,
 106                            _oom_c_heap,
 107                            _oom_metaspace,
 108                            _oom_class_metaspace,
 109                            _oom_array_size,
 110                            _oom_gc_overhead_limit,
 111                            _oom_realloc_objects,
 112                            _oom_retry,
 113                            _oom_count };
 114 
 115 OopHandle Universe::_out_of_memory_errors;
 116 OopHandle Universe::_delayed_stack_overflow_error_message;
 117 OopHandle Universe::_preallocated_out_of_memory_error_array;
 118 volatile jint Universe::_preallocated_out_of_memory_error_avail_count = 0;
 119 
 120 OopHandle Universe::_null_ptr_exception_instance;
 121 OopHandle Universe::_arithmetic_exception_instance;
 122 OopHandle Universe::_virtual_machine_error_instance;
 123 
 124 OopHandle Universe::_reference_pending_list;
 125 
 126 Array&lt;Klass*&gt;* Universe::_the_array_interfaces_array = NULL;
 127 LatestMethodCache* Universe::_finalizer_register_cache = NULL;
 128 LatestMethodCache* Universe::_loader_addClass_cache    = NULL;
 129 LatestMethodCache* Universe::_throw_illegal_access_error_cache = NULL;
 130 LatestMethodCache* Universe::_throw_no_such_method_error_cache = NULL;
 131 LatestMethodCache* Universe::_do_stack_walk_cache     = NULL;
 132 
 133 bool Universe::_verify_in_progress                    = false;
 134 long Universe::verify_flags                           = Universe::Verify_All;
 135 
 136 Array&lt;int&gt;* Universe::_the_empty_int_array            = NULL;
 137 Array&lt;u2&gt;* Universe::_the_empty_short_array           = NULL;
 138 Array&lt;Klass*&gt;* Universe::_the_empty_klass_array     = NULL;
 139 Array&lt;InstanceKlass*&gt;* Universe::_the_empty_instance_klass_array  = NULL;
 140 Array&lt;Method*&gt;* Universe::_the_empty_method_array   = NULL;
 141 
 142 // These variables are guarded by FullGCALot_lock.
 143 debug_only(OopHandle Universe::_fullgc_alot_dummy_array;)
 144 debug_only(int Universe::_fullgc_alot_dummy_next = 0;)
 145 
 146 // Heap
 147 int             Universe::_verify_count = 0;
 148 
 149 // Oop verification (see MacroAssembler::verify_oop)
 150 uintptr_t       Universe::_verify_oop_mask = 0;
 151 uintptr_t       Universe::_verify_oop_bits = (uintptr_t) -1;
 152 
 153 int             Universe::_base_vtable_size = 0;
 154 bool            Universe::_bootstrapping = false;
 155 bool            Universe::_module_initialized = false;
 156 bool            Universe::_fully_initialized = false;
 157 
 158 size_t          Universe::_heap_capacity_at_last_gc;
 159 size_t          Universe::_heap_used_at_last_gc = 0;
 160 
 161 OopStorage*     Universe::_vm_weak = NULL;
 162 OopStorage*     Universe::_vm_global = NULL;
 163 
 164 CollectedHeap*  Universe::_collectedHeap = NULL;
 165 
 166 objArrayOop Universe::the_empty_class_array ()  {
 167   return (objArrayOop)_the_empty_class_array.resolve();
 168 }
 169 
 170 oop Universe::main_thread_group()                 { return _main_thread_group.resolve(); }
 171 void Universe::set_main_thread_group(oop group)   { _main_thread_group = OopHandle(vm_global(), group); }
 172 
 173 oop Universe::system_thread_group()               { return _system_thread_group.resolve(); }
 174 void Universe::set_system_thread_group(oop group) { _system_thread_group = OopHandle(vm_global(), group); }
 175 
 176 oop Universe::the_null_string()                   { return _the_null_string.resolve(); }
 177 oop Universe::the_min_jint_string()               { return _the_min_jint_string.resolve(); }
 178 
 179 oop Universe::null_ptr_exception_instance()       { return _null_ptr_exception_instance.resolve(); }
 180 oop Universe::arithmetic_exception_instance()     { return _arithmetic_exception_instance.resolve(); }
 181 oop Universe::virtual_machine_error_instance()    { return _virtual_machine_error_instance.resolve(); }
 182 
 183 oop Universe::the_null_sentinel()                 { return _the_null_sentinel.resolve(); }
 184 
 185 oop Universe::int_mirror()                        { return check_mirror(_mirrors[T_INT].resolve()); }
 186 oop Universe::float_mirror()                      { return check_mirror(_mirrors[T_FLOAT].resolve()); }
 187 oop Universe::double_mirror()                     { return check_mirror(_mirrors[T_DOUBLE].resolve()); }
 188 oop Universe::byte_mirror()                       { return check_mirror(_mirrors[T_BYTE].resolve()); }
 189 oop Universe::bool_mirror()                       { return check_mirror(_mirrors[T_BOOLEAN].resolve()); }
 190 oop Universe::char_mirror()                       { return check_mirror(_mirrors[T_CHAR].resolve()); }
 191 oop Universe::long_mirror()                       { return check_mirror(_mirrors[T_LONG].resolve()); }
 192 oop Universe::short_mirror()                      { return check_mirror(_mirrors[T_SHORT].resolve()); }
 193 oop Universe::void_mirror()                       { return check_mirror(_mirrors[T_VOID].resolve()); }
 194 
 195 oop Universe::java_mirror(BasicType t) {
 196   assert((uint)t &lt; T_VOID+1, &quot;range check&quot;);
 197   return check_mirror(_mirrors[t].resolve());
 198 }
 199 
 200 // Used by CDS dumping
 201 void Universe::replace_mirror(BasicType t, oop new_mirror) {
 202   Universe::_mirrors[t].replace(new_mirror);
 203 }
 204 
 205 // Not sure why CDS has to do this
 206 void Universe::clear_basic_type_mirrors() {
 207   for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
 208     if (!is_reference_type((BasicType)i)) {
 209       Universe::_mirrors[i].replace(NULL);
 210     }
 211   }
 212 }
 213 
 214 void Universe::basic_type_classes_do(void f(Klass*)) {
 215   for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 216     f(_typeArrayKlassObjs[i]);
 217   }
 218 }
 219 
 220 void Universe::basic_type_classes_do(KlassClosure *closure) {
 221   for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 222     closure-&gt;do_klass(_typeArrayKlassObjs[i]);
 223   }
 224 }
 225 
 226 void Universe::oops_do(OopClosure* f) {
 227 
 228   ThreadsSMRSupport::exiting_threads_oops_do(f);
 229 }
 230 
 231 void LatestMethodCache::metaspace_pointers_do(MetaspaceClosure* it) {
 232   it-&gt;push(&amp;_klass);
 233 }
 234 
 235 void Universe::metaspace_pointers_do(MetaspaceClosure* it) {
 236   for (int i = 0; i &lt; T_LONG+1; i++) {
 237     it-&gt;push(&amp;_typeArrayKlassObjs[i]);
 238   }
 239   it-&gt;push(&amp;_objectArrayKlassObj);
 240 
 241   it-&gt;push(&amp;_the_empty_int_array);
 242   it-&gt;push(&amp;_the_empty_short_array);
 243   it-&gt;push(&amp;_the_empty_klass_array);
 244   it-&gt;push(&amp;_the_empty_instance_klass_array);
 245   it-&gt;push(&amp;_the_empty_method_array);
 246   it-&gt;push(&amp;_the_array_interfaces_array);
 247 
 248   _finalizer_register_cache-&gt;metaspace_pointers_do(it);
 249   _loader_addClass_cache-&gt;metaspace_pointers_do(it);
 250   _throw_illegal_access_error_cache-&gt;metaspace_pointers_do(it);
 251   _throw_no_such_method_error_cache-&gt;metaspace_pointers_do(it);
 252   _do_stack_walk_cache-&gt;metaspace_pointers_do(it);
 253 }
 254 
 255 // Serialize metadata and pointers to primitive type mirrors in and out of CDS archive
 256 void Universe::serialize(SerializeClosure* f) {
 257 
 258 #if INCLUDE_CDS_JAVA_HEAP
 259   {
 260     oop mirror_oop;
 261     for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
 262       if (f-&gt;reading()) {
 263         f-&gt;do_oop(&amp;mirror_oop); // read from archive
 264         assert(oopDesc::is_oop_or_null(mirror_oop), &quot;is oop&quot;);
 265         // Only create an OopHandle for non-null mirrors
 266         if (mirror_oop != NULL) {
 267           _mirrors[i] = OopHandle(vm_global(), mirror_oop);
 268         }
 269       } else {
 270         mirror_oop = _mirrors[i].resolve();
 271         f-&gt;do_oop(&amp;mirror_oop); // write to archive
 272       }
 273       if (mirror_oop != NULL) { // may be null if archived heap is disabled
 274         java_lang_Class::update_archived_primitive_mirror_native_pointers(mirror_oop);
 275       }
 276     }
 277   }
 278 #endif
 279 
 280   for (int i = 0; i &lt; T_LONG+1; i++) {
 281     f-&gt;do_ptr((void**)&amp;_typeArrayKlassObjs[i]);
 282   }
 283 
 284   f-&gt;do_ptr((void**)&amp;_objectArrayKlassObj);
 285   f-&gt;do_ptr((void**)&amp;_the_array_interfaces_array);
 286   f-&gt;do_ptr((void**)&amp;_the_empty_int_array);
 287   f-&gt;do_ptr((void**)&amp;_the_empty_short_array);
 288   f-&gt;do_ptr((void**)&amp;_the_empty_method_array);
 289   f-&gt;do_ptr((void**)&amp;_the_empty_klass_array);
 290   f-&gt;do_ptr((void**)&amp;_the_empty_instance_klass_array);
 291   _finalizer_register_cache-&gt;serialize(f);
 292   _loader_addClass_cache-&gt;serialize(f);
 293   _throw_illegal_access_error_cache-&gt;serialize(f);
 294   _throw_no_such_method_error_cache-&gt;serialize(f);
 295   _do_stack_walk_cache-&gt;serialize(f);
 296 }
 297 
 298 
 299 void Universe::check_alignment(uintx size, uintx alignment, const char* name) {
 300   if (size &lt; alignment || size % alignment != 0) {
 301     vm_exit_during_initialization(
 302       err_msg(&quot;Size of %s (&quot; UINTX_FORMAT &quot; bytes) must be aligned to &quot; UINTX_FORMAT &quot; bytes&quot;, name, size, alignment));
 303   }
 304 }
 305 
 306 void initialize_basic_type_klass(Klass* k, TRAPS) {
 307   Klass* ok = SystemDictionary::Object_klass();
 308 #if INCLUDE_CDS
 309   if (UseSharedSpaces) {
 310     ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
 311     assert(k-&gt;super() == ok, &quot;u3&quot;);
 312     if (k-&gt;is_instance_klass()) {
 313       InstanceKlass::cast(k)-&gt;restore_unshareable_info(loader_data, Handle(), NULL, CHECK);
 314     } else {
 315       ArrayKlass::cast(k)-&gt;restore_unshareable_info(loader_data, Handle(), CHECK);
 316     }
 317   } else
 318 #endif
 319   {
 320     k-&gt;initialize_supers(ok, NULL, CHECK);
 321   }
 322   k-&gt;append_to_sibling_list();
 323 }
 324 
 325 void Universe::genesis(TRAPS) {
 326   ResourceMark rm(THREAD);
 327   HandleMark   hm(THREAD);
 328 
 329   { AutoModifyRestore&lt;bool&gt; temporarily(_bootstrapping, true);
 330 
 331     { MutexLocker mc(THREAD, Compile_lock);
 332 
 333       java_lang_Class::allocate_fixup_lists();
 334 
 335       // determine base vtable size; without that we cannot create the array klasses
 336       compute_base_vtable_size();
 337 
 338       if (!UseSharedSpaces) {
 339         for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 340           _typeArrayKlassObjs[i] = TypeArrayKlass::create_klass((BasicType)i, CHECK);
 341         }
 342 
 343         ClassLoaderData* null_cld = ClassLoaderData::the_null_class_loader_data();
 344 
 345         _the_array_interfaces_array     = MetadataFactory::new_array&lt;Klass*&gt;(null_cld, 2, NULL, CHECK);
 346         _the_empty_int_array            = MetadataFactory::new_array&lt;int&gt;(null_cld, 0, CHECK);
 347         _the_empty_short_array          = MetadataFactory::new_array&lt;u2&gt;(null_cld, 0, CHECK);
 348         _the_empty_method_array         = MetadataFactory::new_array&lt;Method*&gt;(null_cld, 0, CHECK);
 349         _the_empty_klass_array          = MetadataFactory::new_array&lt;Klass*&gt;(null_cld, 0, CHECK);
 350         _the_empty_instance_klass_array = MetadataFactory::new_array&lt;InstanceKlass*&gt;(null_cld, 0, CHECK);
 351       }
 352     }
 353 
 354     vmSymbols::initialize(CHECK);
 355 
 356     SystemDictionary::initialize(CHECK);
 357 
 358     // Create string constants
 359     oop s = StringTable::intern(&quot;null&quot;, CHECK);
 360     _the_null_string = OopHandle(vm_global(), s);
 361     s = StringTable::intern(&quot;-2147483648&quot;, CHECK);
 362     _the_min_jint_string = OopHandle(vm_global(), s);
 363 
 364 
 365 #if INCLUDE_CDS
 366     if (UseSharedSpaces) {
 367       // Verify shared interfaces array.
 368       assert(_the_array_interfaces_array-&gt;at(0) ==
 369              SystemDictionary::Cloneable_klass(), &quot;u3&quot;);
 370       assert(_the_array_interfaces_array-&gt;at(1) ==
 371              SystemDictionary::Serializable_klass(), &quot;u3&quot;);
 372     } else
 373 #endif
 374     {
 375       // Set up shared interfaces array.  (Do this before supers are set up.)
 376       _the_array_interfaces_array-&gt;at_put(0, SystemDictionary::Cloneable_klass());
 377       _the_array_interfaces_array-&gt;at_put(1, SystemDictionary::Serializable_klass());
 378     }
 379 
 380     initialize_basic_type_klass(boolArrayKlassObj(), CHECK);
 381     initialize_basic_type_klass(charArrayKlassObj(), CHECK);
 382     initialize_basic_type_klass(floatArrayKlassObj(), CHECK);
 383     initialize_basic_type_klass(doubleArrayKlassObj(), CHECK);
 384     initialize_basic_type_klass(byteArrayKlassObj(), CHECK);
 385     initialize_basic_type_klass(shortArrayKlassObj(), CHECK);
 386     initialize_basic_type_klass(intArrayKlassObj(), CHECK);
 387     initialize_basic_type_klass(longArrayKlassObj(), CHECK);
 388   } // end of core bootstrapping
 389 
 390   {
 391     Handle tns = java_lang_String::create_from_str(&quot;&lt;null_sentinel&gt;&quot;, CHECK);
 392     _the_null_sentinel = OopHandle(vm_global(), tns());
 393   }
 394 
 395   // Create a handle for reference_pending_list
 396   _reference_pending_list = OopHandle(vm_global(), NULL);
 397 
 398   // Maybe this could be lifted up now that object array can be initialized
 399   // during the bootstrapping.
 400 
 401   // OLD
 402   // Initialize _objectArrayKlass after core bootstraping to make
 403   // sure the super class is set up properly for _objectArrayKlass.
 404   // ---
 405   // NEW
 406   // Since some of the old system object arrays have been converted to
 407   // ordinary object arrays, _objectArrayKlass will be loaded when
 408   // SystemDictionary::initialize(CHECK); is run. See the extra check
 409   // for Object_klass_loaded in objArrayKlassKlass::allocate_objArray_klass_impl.
 410   _objectArrayKlassObj = InstanceKlass::
 411     cast(SystemDictionary::Object_klass())-&gt;array_klass(1, CHECK);
 412   // OLD
 413   // Add the class to the class hierarchy manually to make sure that
 414   // its vtable is initialized after core bootstrapping is completed.
 415   // ---
 416   // New
 417   // Have already been initialized.
 418   _objectArrayKlassObj-&gt;append_to_sibling_list();
 419 
 420   #ifdef ASSERT
 421   if (FullGCALot) {
 422     // Allocate an array of dummy objects.
 423     // We&#39;d like these to be at the bottom of the old generation,
 424     // so that when we free one and then collect,
 425     // (almost) the whole heap moves
 426     // and we find out if we actually update all the oops correctly.
 427     // But we can&#39;t allocate directly in the old generation,
 428     // so we allocate wherever, and hope that the first collection
 429     // moves these objects to the bottom of the old generation.
 430     int size = FullGCALotDummies * 2;
 431 
 432     objArrayOop    naked_array = oopFactory::new_objArray(SystemDictionary::Object_klass(), size, CHECK);
 433     objArrayHandle dummy_array(THREAD, naked_array);
 434     int i = 0;
 435     while (i &lt; size) {
 436         // Allocate dummy in old generation
 437       oop dummy = SystemDictionary::Object_klass()-&gt;allocate_instance(CHECK);
 438       dummy_array-&gt;obj_at_put(i++, dummy);
 439     }
 440     {
 441       // Only modify the global variable inside the mutex.
 442       // If we had a race to here, the other dummy_array instances
 443       // and their elements just get dropped on the floor, which is fine.
 444       MutexLocker ml(THREAD, FullGCALot_lock);
 445       if (_fullgc_alot_dummy_array.is_empty()) {
 446         _fullgc_alot_dummy_array = OopHandle(vm_global(), dummy_array());
 447       }
 448     }
 449     assert(i == ((objArrayOop)_fullgc_alot_dummy_array.resolve())-&gt;length(), &quot;just checking&quot;);
 450   }
 451   #endif
 452 }
 453 
 454 void Universe::initialize_basic_type_mirrors(TRAPS) {
 455 #if INCLUDE_CDS_JAVA_HEAP
 456     if (UseSharedSpaces &amp;&amp;
 457         HeapShared::open_archive_heap_region_mapped() &amp;&amp;
 458         _mirrors[T_INT].resolve() != NULL) {
 459       assert(HeapShared::is_heap_object_archiving_allowed(), &quot;Sanity&quot;);
 460 
 461       // check that all mirrors are mapped also
 462       for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
 463         if (!is_reference_type((BasicType)i)) {
 464           oop m = _mirrors[i].resolve();
 465           assert(m != NULL, &quot;archived mirrors should not be NULL&quot;);
 466         }
 467       }
 468     } else
 469       // _mirror[T_INT} could be NULL if archived heap is not mapped.
 470 #endif
 471     {
 472       for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
 473         BasicType bt = (BasicType)i;
 474         if (!is_reference_type(bt)) {
 475           oop m = java_lang_Class::create_basic_type_mirror(type2name(bt), bt, CHECK);
 476           _mirrors[i] = OopHandle(vm_global(), m);
 477         }
 478       }
 479     }
 480 }
 481 
 482 void Universe::fixup_mirrors(TRAPS) {
 483   // Bootstrap problem: all classes gets a mirror (java.lang.Class instance) assigned eagerly,
 484   // but we cannot do that for classes created before java.lang.Class is loaded. Here we simply
 485   // walk over permanent objects created so far (mostly classes) and fixup their mirrors. Note
 486   // that the number of objects allocated at this point is very small.
 487   assert(SystemDictionary::Class_klass_loaded(), &quot;java.lang.Class should be loaded&quot;);
 488   HandleMark hm(THREAD);
 489 
 490   if (!UseSharedSpaces) {
 491     // Cache the start of the static fields
 492     InstanceMirrorKlass::init_offset_of_static_fields();
 493   }
 494 
 495   GrowableArray &lt;Klass*&gt;* list = java_lang_Class::fixup_mirror_list();
 496   int list_length = list-&gt;length();
 497   for (int i = 0; i &lt; list_length; i++) {
 498     Klass* k = list-&gt;at(i);
 499     assert(k-&gt;is_klass(), &quot;List should only hold classes&quot;);
 500     EXCEPTION_MARK;
 501     java_lang_Class::fixup_mirror(k, CATCH);
 502   }
 503   delete java_lang_Class::fixup_mirror_list();
 504   java_lang_Class::set_fixup_mirror_list(NULL);
 505 }
 506 
 507 #define assert_pll_locked(test) \
 508   assert(Heap_lock-&gt;test(), &quot;Reference pending list access requires lock&quot;)
 509 
 510 #define assert_pll_ownership() assert_pll_locked(owned_by_self)
 511 
 512 oop Universe::reference_pending_list() {
 513   if (Thread::current()-&gt;is_VM_thread()) {
 514     assert_pll_locked(is_locked);
 515   } else {
 516     assert_pll_ownership();
 517   }
 518   return _reference_pending_list.resolve();
 519 }
 520 
 521 void Universe::clear_reference_pending_list() {
 522   assert_pll_ownership();
 523   _reference_pending_list.replace(NULL);
 524 }
 525 
 526 bool Universe::has_reference_pending_list() {
 527   assert_pll_ownership();
 528   return _reference_pending_list.peek() != NULL;
 529 }
 530 
 531 oop Universe::swap_reference_pending_list(oop list) {
 532   assert_pll_locked(is_locked);
 533   return _reference_pending_list.xchg(list);
 534 }
 535 
 536 #undef assert_pll_locked
 537 #undef assert_pll_ownership
 538 
 539 void Universe::reinitialize_vtable_of(Klass* ko, TRAPS) {
 540   // init vtable of k and all subclasses
 541   ko-&gt;vtable().initialize_vtable(false, CHECK);
 542   if (ko-&gt;is_instance_klass()) {
 543     for (Klass* sk = ko-&gt;subklass();
 544          sk != NULL;
 545          sk = sk-&gt;next_sibling()) {
 546       reinitialize_vtable_of(sk, CHECK);
 547     }
 548   }
 549 }
 550 
 551 void Universe::reinitialize_vtables(TRAPS) {
 552   // The vtables are initialized by starting at java.lang.Object and
 553   // initializing through the subclass links, so that the super
 554   // classes are always initialized first.
 555   Klass* ok = SystemDictionary::Object_klass();
 556   Universe::reinitialize_vtable_of(ok, THREAD);
 557 }
 558 
 559 
 560 void initialize_itable_for_klass(InstanceKlass* k, TRAPS) {
 561   k-&gt;itable().initialize_itable(false, CHECK);
 562 }
 563 
 564 
 565 void Universe::reinitialize_itables(TRAPS) {
 566   MutexLocker mcld(THREAD, ClassLoaderDataGraph_lock);
 567   ClassLoaderDataGraph::dictionary_classes_do(initialize_itable_for_klass, CHECK);
 568 }
 569 
 570 
 571 bool Universe::on_page_boundary(void* addr) {
 572   return is_aligned(addr, os::vm_page_size());
 573 }
 574 
 575 // the array of preallocated errors with backtraces
 576 objArrayOop Universe::preallocated_out_of_memory_errors() {
 577   return (objArrayOop)_preallocated_out_of_memory_error_array.resolve();
 578 }
 579 
 580 objArrayOop Universe::out_of_memory_errors() { return (objArrayOop)_out_of_memory_errors.resolve(); }
 581 
 582 oop Universe::out_of_memory_error_java_heap() {
 583   return gen_out_of_memory_error(out_of_memory_errors()-&gt;obj_at(_oom_java_heap));
 584 }
 585 
 586 oop Universe::out_of_memory_error_c_heap() {
 587   return gen_out_of_memory_error(out_of_memory_errors()-&gt;obj_at(_oom_c_heap));
 588 }
 589 
 590 oop Universe::out_of_memory_error_metaspace() {
 591   return gen_out_of_memory_error(out_of_memory_errors()-&gt;obj_at(_oom_metaspace));
 592 }
 593 
 594 oop Universe::out_of_memory_error_class_metaspace() {
 595   return gen_out_of_memory_error(out_of_memory_errors()-&gt;obj_at(_oom_class_metaspace));
 596 }
 597 
 598 oop Universe::out_of_memory_error_array_size() {
 599   return gen_out_of_memory_error(out_of_memory_errors()-&gt;obj_at(_oom_array_size));
 600 }
 601 
 602 oop Universe::out_of_memory_error_gc_overhead_limit() {
 603   return gen_out_of_memory_error(out_of_memory_errors()-&gt;obj_at(_oom_gc_overhead_limit));
 604 }
 605 
 606 oop Universe::out_of_memory_error_realloc_objects() {
 607   return gen_out_of_memory_error(out_of_memory_errors()-&gt;obj_at(_oom_realloc_objects));
 608 }
 609 
 610 // Throw default _out_of_memory_error_retry object as it will never propagate out of the VM
 611 oop Universe::out_of_memory_error_retry()              { return out_of_memory_errors()-&gt;obj_at(_oom_retry);  }
 612 oop Universe::delayed_stack_overflow_error_message()   { return _delayed_stack_overflow_error_message.resolve(); }
 613 
 614 
 615 bool Universe::should_fill_in_stack_trace(Handle throwable) {
 616   // never attempt to fill in the stack trace of preallocated errors that do not have
 617   // backtrace. These errors are kept alive forever and may be &quot;re-used&quot; when all
 618   // preallocated errors with backtrace have been consumed. Also need to avoid
 619   // a potential loop which could happen if an out of memory occurs when attempting
 620   // to allocate the backtrace.
 621   objArrayOop preallocated_oom = out_of_memory_errors();
 622   for (int i = 0; i &lt; _oom_count; i++) {
 623     if (throwable() == preallocated_oom-&gt;obj_at(i)) {
 624       return false;
 625     }
 626   }
 627   return true;
 628 }
 629 
 630 
 631 oop Universe::gen_out_of_memory_error(oop default_err) {
 632   // generate an out of memory error:
 633   // - if there is a preallocated error and stack traces are available
 634   //   (j.l.Throwable is initialized), then return the preallocated
 635   //   error with a filled in stack trace, and with the message
 636   //   provided by the default error.
 637   // - otherwise, return the default error, without a stack trace.
 638   int next;
 639   if ((_preallocated_out_of_memory_error_avail_count &gt; 0) &amp;&amp;
 640       SystemDictionary::Throwable_klass()-&gt;is_initialized()) {
 641     next = (int)Atomic::add(&amp;_preallocated_out_of_memory_error_avail_count, -1);
 642     assert(next &lt; (int)PreallocatedOutOfMemoryErrorCount, &quot;avail count is corrupt&quot;);
 643   } else {
 644     next = -1;
 645   }
 646   if (next &lt; 0) {
 647     // all preallocated errors have been used.
 648     // return default
 649     return default_err;
 650   } else {
 651     Thread* THREAD = Thread::current();
 652     Handle default_err_h(THREAD, default_err);
 653     // get the error object at the slot and set set it to NULL so that the
 654     // array isn&#39;t keeping it alive anymore.
 655     Handle exc(THREAD, preallocated_out_of_memory_errors()-&gt;obj_at(next));
 656     assert(exc() != NULL, &quot;slot has been used already&quot;);
 657     preallocated_out_of_memory_errors()-&gt;obj_at_put(next, NULL);
 658 
 659     // use the message from the default error
 660     oop msg = java_lang_Throwable::message(default_err_h());
 661     assert(msg != NULL, &quot;no message&quot;);
 662     java_lang_Throwable::set_message(exc(), msg);
 663 
 664     // populate the stack trace and return it.
 665     java_lang_Throwable::fill_in_stack_trace_of_preallocated_backtrace(exc);
 666     return exc();
 667   }
 668 }
 669 
 670 // Setup preallocated OutOfMemoryError errors
 671 void Universe::create_preallocated_out_of_memory_errors(TRAPS) {
 672   InstanceKlass* ik = SystemDictionary::OutOfMemoryError_klass();
 673   objArrayOop oa = oopFactory::new_objArray(ik, _oom_count, CHECK);
 674   objArrayHandle oom_array(THREAD, oa);
 675 
 676   for (int i = 0; i &lt; _oom_count; i++) {
 677     oop oom_obj = ik-&gt;allocate_instance(CHECK);
 678     oom_array-&gt;obj_at_put(i, oom_obj);
 679   }
 680   _out_of_memory_errors = OopHandle(vm_global(), oom_array());
 681 
 682   Handle msg = java_lang_String::create_from_str(&quot;Java heap space&quot;, CHECK);
 683   java_lang_Throwable::set_message(oom_array-&gt;obj_at(_oom_java_heap), msg());
 684 
 685   msg = java_lang_String::create_from_str(&quot;C heap space&quot;, CHECK);
 686   java_lang_Throwable::set_message(oom_array-&gt;obj_at(_oom_c_heap), msg());
 687 
 688   msg = java_lang_String::create_from_str(&quot;Metaspace&quot;, CHECK);
 689   java_lang_Throwable::set_message(oom_array-&gt;obj_at(_oom_metaspace), msg());
 690 
 691   msg = java_lang_String::create_from_str(&quot;Compressed class space&quot;, CHECK);
 692   java_lang_Throwable::set_message(oom_array-&gt;obj_at(_oom_class_metaspace), msg());
 693 
 694   msg = java_lang_String::create_from_str(&quot;Requested array size exceeds VM limit&quot;, CHECK);
 695   java_lang_Throwable::set_message(oom_array-&gt;obj_at(_oom_array_size), msg());
 696 
 697   msg = java_lang_String::create_from_str(&quot;GC overhead limit exceeded&quot;, CHECK);
 698   java_lang_Throwable::set_message(oom_array-&gt;obj_at(_oom_gc_overhead_limit), msg());
 699 
 700   msg = java_lang_String::create_from_str(&quot;Java heap space: failed reallocation of scalar replaced objects&quot;, CHECK);
 701   java_lang_Throwable::set_message(oom_array-&gt;obj_at(_oom_realloc_objects), msg());
 702 
 703   msg = java_lang_String::create_from_str(&quot;Java heap space: failed retryable allocation&quot;, CHECK);
 704   java_lang_Throwable::set_message(oom_array-&gt;obj_at(_oom_retry), msg());
 705 
 706   // Setup the array of errors that have preallocated backtrace
 707   int len = (StackTraceInThrowable) ? (int)PreallocatedOutOfMemoryErrorCount : 0;
 708   objArrayOop instance = oopFactory::new_objArray(ik, len, CHECK);
 709   _preallocated_out_of_memory_error_array = OopHandle(vm_global(), instance);
 710   objArrayHandle preallocated_oom_array(THREAD, instance);
 711 
 712   for (int i=0; i&lt;len; i++) {
 713     oop err = ik-&gt;allocate_instance(CHECK);
 714     Handle err_h(THREAD, err);
 715     java_lang_Throwable::allocate_backtrace(err_h, CHECK);
 716     preallocated_oom_array-&gt;obj_at_put(i, err_h());
 717   }
 718   _preallocated_out_of_memory_error_avail_count = (jint)len;
 719 }
 720 
 721 intptr_t Universe::_non_oop_bits = 0;
 722 
 723 void* Universe::non_oop_word() {
 724   // Neither the high bits nor the low bits of this value is allowed
 725   // to look like (respectively) the high or low bits of a real oop.
 726   //
 727   // High and low are CPU-specific notions, but low always includes
 728   // the low-order bit.  Since oops are always aligned at least mod 4,
 729   // setting the low-order bit will ensure that the low half of the
 730   // word will never look like that of a real oop.
 731   //
 732   // Using the OS-supplied non-memory-address word (usually 0 or -1)
 733   // will take care of the high bits, however many there are.
 734 
 735   if (_non_oop_bits == 0) {
 736     _non_oop_bits = (intptr_t)os::non_memory_address_word() | 1;
 737   }
 738 
 739   return (void*)_non_oop_bits;
 740 }
 741 
 742 static void initialize_global_behaviours() {
 743   CompiledICProtectionBehaviour::set_current(new DefaultICProtectionBehaviour());
 744 }
 745 
 746 jint universe_init() {
 747   assert(!Universe::_fully_initialized, &quot;called after initialize_vtables&quot;);
 748   guarantee(1 &lt;&lt; LogHeapWordSize == sizeof(HeapWord),
 749          &quot;LogHeapWordSize is incorrect.&quot;);
 750   guarantee(sizeof(oop) &gt;= sizeof(HeapWord), &quot;HeapWord larger than oop?&quot;);
 751   guarantee(sizeof(oop) % sizeof(HeapWord) == 0,
 752             &quot;oop size is not not a multiple of HeapWord size&quot;);
 753 
 754   TraceTime timer(&quot;Genesis&quot;, TRACETIME_LOG(Info, startuptime));
 755 
 756   initialize_global_behaviours();
 757 
 758   GCLogPrecious::initialize();
 759 
 760   GCConfig::arguments()-&gt;initialize_heap_sizes();
 761 
 762   jint status = Universe::initialize_heap();
 763   if (status != JNI_OK) {
 764     return status;
 765   }
 766 
 767   Universe::initialize_tlab();
 768 
 769   Metaspace::global_initialize();
 770 
 771   // Initialize performance counters for metaspaces
 772   MetaspaceCounters::initialize_performance_counters();
 773   CompressedClassSpaceCounters::initialize_performance_counters();
 774 
 775   AOTLoader::universe_init();
 776 
 777   // Checks &#39;AfterMemoryInit&#39; constraints.
 778   if (!JVMFlagConstraintList::check_constraints(JVMFlagConstraint::AfterMemoryInit)) {
 779     return JNI_EINVAL;
 780   }
 781 
 782   // Create memory for metadata.  Must be after initializing heap for
 783   // DumpSharedSpaces.
 784   ClassLoaderData::init_null_class_loader_data();
 785 
 786   // We have a heap so create the Method* caches before
 787   // Metaspace::initialize_shared_spaces() tries to populate them.
 788   Universe::_finalizer_register_cache = new LatestMethodCache();
 789   Universe::_loader_addClass_cache    = new LatestMethodCache();
 790   Universe::_throw_illegal_access_error_cache = new LatestMethodCache();
 791   Universe::_throw_no_such_method_error_cache = new LatestMethodCache();
 792   Universe::_do_stack_walk_cache = new LatestMethodCache();
 793 
 794 #if INCLUDE_CDS
 795   if (UseSharedSpaces) {
 796     // Read the data structures supporting the shared spaces (shared
 797     // system dictionary, symbol table, etc.).  After that, access to
 798     // the file (other than the mapped regions) is no longer needed, and
 799     // the file is closed. Closing the file does not affect the
 800     // currently mapped regions.
 801     MetaspaceShared::initialize_shared_spaces();
 802     StringTable::create_table();
 803   } else
 804 #endif
 805   {
 806     SymbolTable::create_table();
 807     StringTable::create_table();
 808   }
 809 
 810 #if INCLUDE_CDS
 811   if (Arguments::is_dumping_archive()) {
 812     MetaspaceShared::prepare_for_dumping();
 813   }
 814 #endif
 815 
 816   if (strlen(VerifySubSet) &gt; 0) {
 817     Universe::initialize_verify_flags();
 818   }
 819 
 820   ResolvedMethodTable::create_table();
 821 
 822   return JNI_OK;
 823 }
 824 
 825 jint Universe::initialize_heap() {
 826   assert(_collectedHeap == NULL, &quot;Heap already created&quot;);
 827   _collectedHeap = GCConfig::arguments()-&gt;create_heap();
 828 
 829   log_info(gc)(&quot;Using %s&quot;, _collectedHeap-&gt;name());
 830   return _collectedHeap-&gt;initialize();
 831 }
 832 
 833 void Universe::initialize_tlab() {
 834   ThreadLocalAllocBuffer::set_max_size(Universe::heap()-&gt;max_tlab_size());
 835   if (UseTLAB) {
 836     assert(Universe::heap()-&gt;supports_tlab_allocation(),
 837            &quot;Should support thread-local allocation buffers&quot;);
 838     ThreadLocalAllocBuffer::startup_initialization();
 839   }
 840 }
 841 
 842 ReservedHeapSpace Universe::reserve_heap(size_t heap_size, size_t alignment) {
 843 
 844   assert(alignment &lt;= Arguments::conservative_max_heap_alignment(),
 845          &quot;actual alignment &quot; SIZE_FORMAT &quot; must be within maximum heap alignment &quot; SIZE_FORMAT,
 846          alignment, Arguments::conservative_max_heap_alignment());
 847 
 848   size_t total_reserved = align_up(heap_size, alignment);
 849   assert(!UseCompressedOops || (total_reserved &lt;= (OopEncodingHeapMax - os::vm_page_size())),
 850       &quot;heap size is too big for compressed oops&quot;);
 851 
 852   bool use_large_pages = UseLargePages &amp;&amp; is_aligned(alignment, os::large_page_size());
 853   assert(!UseLargePages
 854       || UseParallelGC
 855       || use_large_pages, &quot;Wrong alignment to use large pages&quot;);
 856 
 857   // Now create the space.
 858   ReservedHeapSpace total_rs(total_reserved, alignment, use_large_pages, AllocateHeapAt);
 859 
 860   if (total_rs.is_reserved()) {
 861     assert((total_reserved == total_rs.size()) &amp;&amp; ((uintptr_t)total_rs.base() % alignment == 0),
 862            &quot;must be exactly of required size and alignment&quot;);
 863     // We are good.
 864 
 865     if (AllocateHeapAt != NULL) {
 866       log_info(gc,heap)(&quot;Successfully allocated Java heap at location %s&quot;, AllocateHeapAt);
 867     }
 868 
 869     if (UseCompressedOops) {
 870       CompressedOops::initialize(total_rs);
 871     }
 872 
 873     Universe::calculate_verify_data((HeapWord*)total_rs.base(), (HeapWord*)total_rs.end());
 874 
 875     return total_rs;
 876   }
 877 
 878   vm_exit_during_initialization(
 879     err_msg(&quot;Could not reserve enough space for &quot; SIZE_FORMAT &quot;KB object heap&quot;,
 880             total_reserved/K));
 881 
 882   // satisfy compiler
 883   ShouldNotReachHere();
 884   return ReservedHeapSpace(0, 0, false);
 885 }
 886 
 887 
 888 // It&#39;s the caller&#39;s responsibility to ensure glitch-freedom
 889 // (if required).
 890 void Universe::update_heap_info_at_gc() {
 891   _heap_capacity_at_last_gc = heap()-&gt;capacity();
 892   _heap_used_at_last_gc     = heap()-&gt;used();
 893 }
 894 
 895 OopStorage* Universe::vm_weak() {
 896   return Universe::_vm_weak;
 897 }
 898 
 899 OopStorage* Universe::vm_global() {
 900   return Universe::_vm_global;
 901 }
 902 
 903 void Universe::oopstorage_init() {
 904   Universe::_vm_global = OopStorageSet::create_strong(&quot;VM Global&quot;);
 905   Universe::_vm_weak = OopStorageSet::create_weak(&quot;VM Weak&quot;);
 906 }
 907 
 908 void universe_oopstorage_init() {
 909   Universe::oopstorage_init();
 910 }
 911 
 912 void initialize_known_method(LatestMethodCache* method_cache,
 913                              InstanceKlass* ik,
 914                              const char* method,
 915                              Symbol* signature,
 916                              bool is_static, TRAPS)
 917 {
 918   TempNewSymbol name = SymbolTable::new_symbol(method);
 919   Method* m = NULL;
 920   // The klass must be linked before looking up the method.
 921   if (!ik-&gt;link_class_or_fail(THREAD) ||
 922       ((m = ik-&gt;find_method(name, signature)) == NULL) ||
 923       is_static != m-&gt;is_static()) {
 924     ResourceMark rm(THREAD);
 925     // NoSuchMethodException doesn&#39;t actually work because it tries to run the
 926     // &lt;init&gt; function before java_lang_Class is linked. Print error and exit.
 927     vm_exit_during_initialization(err_msg(&quot;Unable to link/verify %s.%s method&quot;,
 928                                  ik-&gt;name()-&gt;as_C_string(), method));
 929   }
 930   method_cache-&gt;init(ik, m);
 931 }
 932 
 933 void Universe::initialize_known_methods(TRAPS) {
 934   // Set up static method for registering finalizers
 935   initialize_known_method(_finalizer_register_cache,
 936                           SystemDictionary::Finalizer_klass(),
 937                           &quot;register&quot;,
 938                           vmSymbols::object_void_signature(), true, CHECK);
 939 
 940   initialize_known_method(_throw_illegal_access_error_cache,
 941                           SystemDictionary::internal_Unsafe_klass(),
 942                           &quot;throwIllegalAccessError&quot;,
 943                           vmSymbols::void_method_signature(), true, CHECK);
 944 
 945   initialize_known_method(_throw_no_such_method_error_cache,
 946                           SystemDictionary::internal_Unsafe_klass(),
 947                           &quot;throwNoSuchMethodError&quot;,
 948                           vmSymbols::void_method_signature(), true, CHECK);
 949 
 950   // Set up method for registering loaded classes in class loader vector
 951   initialize_known_method(_loader_addClass_cache,
 952                           SystemDictionary::ClassLoader_klass(),
 953                           &quot;addClass&quot;,
 954                           vmSymbols::class_void_signature(), false, CHECK);
 955 
 956   // Set up method for stack walking
 957   initialize_known_method(_do_stack_walk_cache,
 958                           SystemDictionary::AbstractStackWalker_klass(),
 959                           &quot;doStackWalk&quot;,
 960                           vmSymbols::doStackWalk_signature(), false, CHECK);
 961 }
 962 
 963 void universe2_init() {
 964   EXCEPTION_MARK;
 965   Universe::genesis(CATCH);
 966 }
 967 
 968 // Set after initialization of the module runtime, call_initModuleRuntime
 969 void universe_post_module_init() {
 970   Universe::_module_initialized = true;
 971 }
 972 
 973 bool universe_post_init() {
 974   assert(!is_init_completed(), &quot;Error: initialization not yet completed!&quot;);
 975   Universe::_fully_initialized = true;
 976   EXCEPTION_MARK;
 977   if (!UseSharedSpaces) {
 978     ResourceMark rm;
 979     Universe::reinitialize_vtables(CHECK_false);
 980     Universe::reinitialize_itables(CHECK_false);
 981   }
 982 
 983   HandleMark hm(THREAD);
 984   // Setup preallocated empty java.lang.Class array for Method reflection.
 985 
 986   objArrayOop the_empty_class_array = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_false);
 987   Universe::_the_empty_class_array = OopHandle(Universe::vm_global(), the_empty_class_array);
 988 
 989   // Setup preallocated OutOfMemoryError errors
 990   Universe::create_preallocated_out_of_memory_errors(CHECK_false);
 991 
 992   oop instance;
 993   // Setup preallocated cause message for delayed StackOverflowError
 994   if (StackReservedPages &gt; 0) {
 995     instance = java_lang_String::create_oop_from_str(&quot;Delayed StackOverflowError due to ReservedStackAccess annotated method&quot;, CHECK_false);
 996     Universe::_delayed_stack_overflow_error_message = OopHandle(Universe::vm_global(), instance);
 997   }
 998 
 999   // Setup preallocated NullPointerException
1000   // (this is currently used for a cheap &amp; dirty solution in compiler exception handling)
1001   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_NullPointerException(), true, CHECK_false);
1002   instance = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK_false);
1003   Universe::_null_ptr_exception_instance = OopHandle(Universe::vm_global(), instance);
1004 
1005   // Setup preallocated ArithmeticException
1006   // (this is currently used for a cheap &amp; dirty solution in compiler exception handling)
1007   k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_ArithmeticException(), true, CHECK_false);
1008   instance = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK_false);
1009   Universe::_arithmetic_exception_instance = OopHandle(Universe::vm_global(), instance);
1010 
1011   // Virtual Machine Error for when we get into a situation we can&#39;t resolve
1012   k = SystemDictionary::VirtualMachineError_klass();
1013   bool linked = InstanceKlass::cast(k)-&gt;link_class_or_fail(CHECK_false);
1014   if (!linked) {
1015      tty-&gt;print_cr(&quot;Unable to link/verify VirtualMachineError class&quot;);
1016      return false; // initialization failed
1017   }
1018   instance = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK_false);
1019   Universe::_virtual_machine_error_instance = OopHandle(Universe::vm_global(), instance);
1020 
1021   Handle msg = java_lang_String::create_from_str(&quot;/ by zero&quot;, CHECK_false);
1022   java_lang_Throwable::set_message(Universe::arithmetic_exception_instance(), msg());
1023 
1024   Universe::initialize_known_methods(CHECK_false);
1025 
1026   // This needs to be done before the first scavenge/gc, since
1027   // it&#39;s an input to soft ref clearing policy.
1028   {
1029     MutexLocker x(THREAD, Heap_lock);
1030     Universe::update_heap_info_at_gc();
1031   }
1032 
1033   // (&quot;weak&quot;) refs processing infrastructure initialization
1034   Universe::heap()-&gt;post_initialize();
1035 
1036   MemoryService::add_metaspace_memory_pools();
1037 
1038   MemoryService::set_universe_heap(Universe::heap());
1039 #if INCLUDE_CDS
1040   MetaspaceShared::post_initialize(CHECK_false);
1041 #endif
1042   return true;
1043 }
1044 
1045 
1046 void Universe::compute_base_vtable_size() {
1047   _base_vtable_size = ClassLoader::compute_Object_vtable();
1048 }
1049 
1050 void Universe::print_on(outputStream* st) {
1051   GCMutexLocker hl(Heap_lock); // Heap_lock might be locked by caller thread.
1052   st-&gt;print_cr(&quot;Heap&quot;);
1053   heap()-&gt;print_on(st);
1054 }
1055 
1056 void Universe::print_heap_at_SIGBREAK() {
1057   if (PrintHeapAtSIGBREAK) {
1058     print_on(tty);
1059     tty-&gt;cr();
1060     tty-&gt;flush();
1061   }
1062 }
1063 
1064 void Universe::print_heap_before_gc() {
1065   LogTarget(Debug, gc, heap) lt;
1066   if (lt.is_enabled()) {
1067     LogStream ls(lt);
1068     ls.print(&quot;Heap before GC invocations=%u (full %u):&quot;, heap()-&gt;total_collections(), heap()-&gt;total_full_collections());
1069     ResourceMark rm;
1070     heap()-&gt;print_on(&amp;ls);
1071   }
1072 }
1073 
1074 void Universe::print_heap_after_gc() {
1075   LogTarget(Debug, gc, heap) lt;
1076   if (lt.is_enabled()) {
1077     LogStream ls(lt);
1078     ls.print(&quot;Heap after GC invocations=%u (full %u):&quot;, heap()-&gt;total_collections(), heap()-&gt;total_full_collections());
1079     ResourceMark rm;
1080     heap()-&gt;print_on(&amp;ls);
1081   }
1082 }
1083 
1084 void Universe::initialize_verify_flags() {
1085   verify_flags = 0;
1086   const char delimiter[] = &quot; ,&quot;;
1087 
1088   size_t length = strlen(VerifySubSet);
1089   char* subset_list = NEW_C_HEAP_ARRAY(char, length + 1, mtInternal);
1090   strncpy(subset_list, VerifySubSet, length + 1);
1091   char* save_ptr;
1092 
1093   char* token = strtok_r(subset_list, delimiter, &amp;save_ptr);
1094   while (token != NULL) {
1095     if (strcmp(token, &quot;threads&quot;) == 0) {
1096       verify_flags |= Verify_Threads;
1097     } else if (strcmp(token, &quot;heap&quot;) == 0) {
1098       verify_flags |= Verify_Heap;
1099     } else if (strcmp(token, &quot;symbol_table&quot;) == 0) {
1100       verify_flags |= Verify_SymbolTable;
1101     } else if (strcmp(token, &quot;string_table&quot;) == 0) {
1102       verify_flags |= Verify_StringTable;
1103     } else if (strcmp(token, &quot;codecache&quot;) == 0) {
1104       verify_flags |= Verify_CodeCache;
1105     } else if (strcmp(token, &quot;dictionary&quot;) == 0) {
1106       verify_flags |= Verify_SystemDictionary;
1107     } else if (strcmp(token, &quot;classloader_data_graph&quot;) == 0) {
1108       verify_flags |= Verify_ClassLoaderDataGraph;
1109     } else if (strcmp(token, &quot;metaspace&quot;) == 0) {
1110       verify_flags |= Verify_MetaspaceUtils;
1111     } else if (strcmp(token, &quot;jni_handles&quot;) == 0) {
1112       verify_flags |= Verify_JNIHandles;
1113     } else if (strcmp(token, &quot;codecache_oops&quot;) == 0) {
1114       verify_flags |= Verify_CodeCacheOops;
1115     } else if (strcmp(token, &quot;resolved_method_table&quot;) == 0) {
1116       verify_flags |= Verify_ResolvedMethodTable;
1117     } else {
1118       vm_exit_during_initialization(err_msg(&quot;VerifySubSet: \&#39;%s\&#39; memory sub-system is unknown, please correct it&quot;, token));
1119     }
1120     token = strtok_r(NULL, delimiter, &amp;save_ptr);
1121   }
1122   FREE_C_HEAP_ARRAY(char, subset_list);
1123 }
1124 
1125 bool Universe::should_verify_subset(uint subset) {
1126   if (verify_flags &amp; subset) {
1127     return true;
1128   }
1129   return false;
1130 }
1131 
1132 void Universe::verify(VerifyOption option, const char* prefix) {
1133   // The use of _verify_in_progress is a temporary work around for
1134   // 6320749.  Don&#39;t bother with a creating a class to set and clear
1135   // it since it is only used in this method and the control flow is
1136   // straight forward.
1137   _verify_in_progress = true;
1138 
1139   COMPILER2_PRESENT(
1140     assert(!DerivedPointerTable::is_active(),
1141          &quot;DPT should not be active during verification &quot;
1142          &quot;(of thread stacks below)&quot;);
1143   )
1144 
1145   Thread* thread = Thread::current();
1146   ResourceMark rm(thread);
1147   HandleMark hm(thread);  // Handles created during verification can be zapped
1148   _verify_count++;
1149 
1150   FormatBuffer&lt;&gt; title(&quot;Verifying %s&quot;, prefix);
1151   GCTraceTime(Info, gc, verify) tm(title.buffer());
1152   if (should_verify_subset(Verify_Threads)) {
1153     log_debug(gc, verify)(&quot;Threads&quot;);
1154     Threads::verify();
1155   }
1156   if (should_verify_subset(Verify_Heap)) {
1157     log_debug(gc, verify)(&quot;Heap&quot;);
1158     heap()-&gt;verify(option);
1159   }
1160   if (should_verify_subset(Verify_SymbolTable)) {
1161     log_debug(gc, verify)(&quot;SymbolTable&quot;);
1162     SymbolTable::verify();
1163   }
1164   if (should_verify_subset(Verify_StringTable)) {
1165     log_debug(gc, verify)(&quot;StringTable&quot;);
1166     StringTable::verify();
1167   }
1168   if (should_verify_subset(Verify_CodeCache)) {
1169   {
1170     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1171     log_debug(gc, verify)(&quot;CodeCache&quot;);
1172     CodeCache::verify();
1173   }
1174   }
1175   if (should_verify_subset(Verify_SystemDictionary)) {
1176     log_debug(gc, verify)(&quot;SystemDictionary&quot;);
1177     SystemDictionary::verify();
1178   }
1179   if (should_verify_subset(Verify_ClassLoaderDataGraph)) {
1180     log_debug(gc, verify)(&quot;ClassLoaderDataGraph&quot;);
1181     ClassLoaderDataGraph::verify();
1182   }
1183   if (should_verify_subset(Verify_MetaspaceUtils)) {
1184     log_debug(gc, verify)(&quot;MetaspaceUtils&quot;);
1185     MetaspaceUtils::verify_free_chunks();
1186   }
1187   if (should_verify_subset(Verify_JNIHandles)) {
1188     log_debug(gc, verify)(&quot;JNIHandles&quot;);
1189     JNIHandles::verify();
1190   }
1191   if (should_verify_subset(Verify_CodeCacheOops)) {
1192     log_debug(gc, verify)(&quot;CodeCache Oops&quot;);
1193     CodeCache::verify_oops();
1194   }
1195   if (should_verify_subset(Verify_ResolvedMethodTable)) {
1196     log_debug(gc, verify)(&quot;ResolvedMethodTable Oops&quot;);
1197     ResolvedMethodTable::verify();
1198   }
1199 
1200   _verify_in_progress = false;
1201 }
1202 
1203 
1204 #ifndef PRODUCT
1205 void Universe::calculate_verify_data(HeapWord* low_boundary, HeapWord* high_boundary) {
1206   assert(low_boundary &lt; high_boundary, &quot;bad interval&quot;);
1207 
1208   // decide which low-order bits we require to be clear:
1209   size_t alignSize = MinObjAlignmentInBytes;
1210   size_t min_object_size = CollectedHeap::min_fill_size();
1211 
1212   // make an inclusive limit:
1213   uintptr_t max = (uintptr_t)high_boundary - min_object_size*wordSize;
1214   uintptr_t min = (uintptr_t)low_boundary;
1215   assert(min &lt; max, &quot;bad interval&quot;);
1216   uintptr_t diff = max ^ min;
1217 
1218   // throw away enough low-order bits to make the diff vanish
1219   uintptr_t mask = (uintptr_t)(-1);
1220   while ((mask &amp; diff) != 0)
1221     mask &lt;&lt;= 1;
1222   uintptr_t bits = (min &amp; mask);
1223   assert(bits == (max &amp; mask), &quot;correct mask&quot;);
1224   // check an intermediate value between min and max, just to make sure:
1225   assert(bits == ((min + (max-min)/2) &amp; mask), &quot;correct mask&quot;);
1226 
1227   // require address alignment, too:
1228   mask |= (alignSize - 1);
1229 
1230   if (!(_verify_oop_mask == 0 &amp;&amp; _verify_oop_bits == (uintptr_t)-1)) {
1231     assert(_verify_oop_mask == mask &amp;&amp; _verify_oop_bits == bits, &quot;mask stability&quot;);
1232   }
1233   _verify_oop_mask = mask;
1234   _verify_oop_bits = bits;
1235 }
1236 
1237 // Oop verification (see MacroAssembler::verify_oop)
1238 
1239 uintptr_t Universe::verify_oop_mask() {
1240   return _verify_oop_mask;
1241 }
1242 
1243 uintptr_t Universe::verify_oop_bits() {
1244   return _verify_oop_bits;
1245 }
1246 
1247 uintptr_t Universe::verify_mark_mask() {
1248   return markWord::lock_mask_in_place;
1249 }
1250 
1251 uintptr_t Universe::verify_mark_bits() {
1252   intptr_t mask = verify_mark_mask();
1253   intptr_t bits = (intptr_t)markWord::prototype().value();
1254   assert((bits &amp; ~mask) == 0, &quot;no stray header bits&quot;);
1255   return bits;
1256 }
1257 #endif // PRODUCT
1258 
1259 
1260 void LatestMethodCache::init(Klass* k, Method* m) {
1261   if (!UseSharedSpaces) {
1262     _klass = k;
1263   }
1264 #ifndef PRODUCT
1265   else {
1266     // sharing initilization should have already set up _klass
1267     assert(_klass != NULL, &quot;just checking&quot;);
1268   }
1269 #endif
1270 
1271   _method_idnum = m-&gt;method_idnum();
1272   assert(_method_idnum &gt;= 0, &quot;sanity check&quot;);
1273 }
1274 
1275 
1276 Method* LatestMethodCache::get_method() {
1277   if (klass() == NULL) return NULL;
1278   InstanceKlass* ik = InstanceKlass::cast(klass());
1279   Method* m = ik-&gt;method_with_idnum(method_idnum());
1280   assert(m != NULL, &quot;sanity check&quot;);
1281   return m;
1282 }
1283 
1284 
1285 #ifdef ASSERT
1286 // Release dummy object(s) at bottom of heap
1287 bool Universe::release_fullgc_alot_dummy() {
1288   MutexLocker ml(FullGCALot_lock);
1289   objArrayOop fullgc_alot_dummy_array = (objArrayOop)_fullgc_alot_dummy_array.resolve();
1290   if (fullgc_alot_dummy_array != NULL) {
1291     if (_fullgc_alot_dummy_next &gt;= fullgc_alot_dummy_array-&gt;length()) {
1292       // No more dummies to release, release entire array instead
1293       _fullgc_alot_dummy_array.release(Universe::vm_global());
1294       return false;
1295     }
1296 
1297     // Release dummy at bottom of old generation
1298     fullgc_alot_dummy_array-&gt;obj_at_put(_fullgc_alot_dummy_next++, NULL);
1299   }
1300   return true;
1301 }
1302 
1303 #endif // ASSERT
    </pre>
  </body>
</html>